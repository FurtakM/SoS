// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33908 0 0
// InitNature ;
  19: CALL 33732 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10881 0 0
// PrepareRussian ;
  40: CALL 6874 0 0
// PrepareLegion ;
  44: CALL 4114 0 0
// PreparePowell ;
  48: CALL 2868 0 0
// PrepareAmerican ;
  52: CALL 1640 0 0
// Action ;
  56: CALL 14788 0 0
// MC_Start ( ) ;
  60: CALL 36020 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 58401 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 58494 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57844 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 57659 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 58401 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 58494 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 22
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 52
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 22
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 52
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_INT 24
 792: PUSH
 793: LD_INT 3
 795: PUSH
 796: LD_INT 3
 798: PUSH
 799: LD_INT 47
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: PUSH
 808: LD_INT 24
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 3
 816: PUSH
 817: LD_INT 47
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: LIST
 835: PPUSH
 836: CALL 57659 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 840: LD_INT 2
 842: PPUSH
 843: LD_INT 5
 845: PPUSH
 846: CALL 57844 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 850: LD_INT 2
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL 58274 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 860: LD_INT 3
 862: PPUSH
 863: LD_INT 10
 865: PUSH
 866: LD_INT 12
 868: PUSH
 869: LD_INT 15
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_OWVAR 67
 881: ARRAY
 882: PPUSH
 883: LD_INT 27
 885: PPUSH
 886: CALL 57341 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 890: LD_INT 3
 892: PPUSH
 893: LD_INT 10
 895: PUSH
 896: LD_INT 11
 898: PUSH
 899: LD_INT 13
 901: PUSH
 902: LD_INT 15
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: PPUSH
 911: CALL 58401 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 915: LD_INT 3
 917: PPUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: PPUSH
 924: CALL 58494 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 928: LD_ADDR_EXP 128
 932: PUSH
 933: LD_EXP 128
 937: PPUSH
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 22
 943: PUSH
 944: LD_INT 8
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 25
 953: PUSH
 954: LD_INT 15
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PPUSH
 965: CALL_OW 69
 969: PPUSH
 970: CALL_OW 1
 974: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 975: LD_INT 3
 977: PPUSH
 978: LD_INT 13
 980: PUSH
 981: LD_INT 2
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 31
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 2
1001: PUSH
1002: LD_INT 1
1004: PUSH
1005: LD_INT 31
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 13
1016: PUSH
1017: LD_INT 3
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 32
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL 57659 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1041: LD_INT 4
1043: PPUSH
1044: LD_INT 10
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: PPUSH
1054: CALL 58401 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1058: LD_INT 4
1060: PPUSH
1061: LD_INT 9
1063: PUSH
1064: EMPTY
1065: LIST
1066: PPUSH
1067: CALL 58494 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1071: LD_INT 4
1073: PPUSH
1074: LD_INT 26
1076: PUSH
1077: LD_INT 74
1079: PUSH
1080: LD_INT 107
1082: PUSH
1083: LD_INT 0
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_INT 32
1094: PUSH
1095: LD_INT 77
1097: PUSH
1098: LD_INT 101
1100: PUSH
1101: LD_INT 4
1103: PUSH
1104: EMPTY
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 32
1112: PUSH
1113: LD_INT 69
1115: PUSH
1116: LD_INT 86
1118: PUSH
1119: LD_INT 4
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 77
1133: PUSH
1134: LD_INT 110
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 27
1148: PUSH
1149: LD_INT 42
1151: PUSH
1152: LD_INT 79
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: LD_INT 29
1166: PUSH
1167: LD_INT 86
1169: PUSH
1170: LD_INT 105
1172: PUSH
1173: LD_INT 2
1175: PUSH
1176: EMPTY
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PUSH
1182: LD_INT 30
1184: PUSH
1185: LD_INT 40
1187: PUSH
1188: LD_INT 75
1190: PUSH
1191: LD_INT 1
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 32
1202: PUSH
1203: LD_INT 80
1205: PUSH
1206: LD_INT 106
1208: PUSH
1209: LD_INT 4
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 32
1220: PUSH
1221: LD_INT 75
1223: PUSH
1224: LD_INT 114
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: PUSH
1236: LD_INT 32
1238: PUSH
1239: LD_INT 82
1241: PUSH
1242: LD_INT 110
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_INT 32
1256: PUSH
1257: LD_INT 62
1259: PUSH
1260: LD_INT 78
1262: PUSH
1263: LD_INT 4
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: PUSH
1272: LD_INT 4
1274: PUSH
1275: LD_INT 39
1277: PUSH
1278: LD_INT 61
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL 57551 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1308: LD_INT 4
1310: PPUSH
1311: LD_INT 5
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: LD_INT 7
1319: PUSH
1320: LD_INT 9
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: PPUSH
1329: CALL 58812 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1333: LD_INT 4
1335: PPUSH
1336: LD_INT 40
1338: PUSH
1339: LD_INT 75
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: LIST
1349: PUSH
1350: LD_INT 86
1352: PUSH
1353: LD_INT 105
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PPUSH
1368: CALL 57983 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1372: LD_INT 4
1374: PPUSH
1375: LD_INT 2
1377: PPUSH
1378: CALL 58274 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 0
1387: PPUSH
1388: CALL 58274 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1392: LD_INT 4
1394: PPUSH
1395: LD_INT 54
1397: PPUSH
1398: LD_INT 85
1400: PPUSH
1401: LD_INT 2
1403: PPUSH
1404: LD_INT 19
1406: PUSH
1407: LD_INT 16
1409: PUSH
1410: LD_INT 17
1412: PUSH
1413: LD_INT 18
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: PPUSH
1422: CALL 58606 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1426: LD_INT 4
1428: PPUSH
1429: LD_INT 3
1431: PUSH
1432: LD_INT 1
1434: PUSH
1435: LD_INT 1
1437: PUSH
1438: LD_INT 5
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: PUSH
1447: LD_INT 4
1449: PUSH
1450: LD_INT 1
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 6
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: PUSH
1465: LD_INT 4
1467: PUSH
1468: LD_INT 1
1470: PUSH
1471: LD_INT 1
1473: PUSH
1474: LD_INT 7
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: PUSH
1483: LD_INT 4
1485: PUSH
1486: LD_INT 1
1488: PUSH
1489: LD_INT 1
1491: PUSH
1492: LD_INT 6
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: PUSH
1501: EMPTY
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: PPUSH
1507: CALL 57659 0 2
// MC_SetTame ( 4 , powellApe ) ;
1511: LD_INT 4
1513: PPUSH
1514: LD_INT 13
1516: PPUSH
1517: CALL 58225 0 2
// end ;
1521: LD_VAR 0 1
1525: RET
// every 0 0$1 trigger debug do var i , tmp ;
1526: LD_EXP 1
1530: IFFALSE 1637
1532: GO 1534
1534: DISABLE
1535: LD_INT 0
1537: PPUSH
1538: PPUSH
// begin enable ;
1539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_INT 22
1547: PUSH
1548: LD_INT 1
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 3
1557: PUSH
1558: LD_INT 21
1560: PUSH
1561: LD_INT 3
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: LD_INT 3
1574: PUSH
1575: LD_INT 24
1577: PUSH
1578: LD_INT 999
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: ST_TO_ADDR
// if not tmp then
1599: LD_VAR 0 2
1603: NOT
1604: IFFALSE 1608
// exit ;
1606: GO 1637
// for i in tmp do
1608: LD_ADDR_VAR 0 1
1612: PUSH
1613: LD_VAR 0 2
1617: PUSH
1618: FOR_IN
1619: IFFALSE 1635
// SetLives ( i , 1000 ) ;
1621: LD_VAR 0 1
1625: PPUSH
1626: LD_INT 1000
1628: PPUSH
1629: CALL_OW 234
1633: GO 1618
1635: POP
1636: POP
// end ; end_of_file
1637: PPOPN 2
1639: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1640: LD_INT 0
1642: PPUSH
// uc_side := 1 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 1
1650: ST_TO_ADDR
// uc_nation := 1 ;
1651: LD_ADDR_OWVAR 21
1655: PUSH
1656: LD_INT 1
1658: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1659: LD_ADDR_EXP 36
1663: PUSH
1664: LD_STRING JMM
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 14_
1675: PPUSH
1676: CALL 64051 0 3
1680: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1681: LD_EXP 4
1685: NOT
1686: PUSH
1687: LD_EXP 4
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PUSH
1696: LD_INT 1
1698: ARRAY
1699: NOT
1700: OR
1701: IFFALSE 1724
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 1
1711: PPUSH
1712: LD_INT 5
1714: PPUSH
1715: LD_INT 100
1717: PPUSH
1718: CALL 71077 0 5
1722: GO 1783
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1724: LD_EXP 4
1728: PUSH
1729: LD_INT 1
1731: ARRAY
1732: PUSH
1733: LD_INT 1
1735: ARRAY
1736: PPUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 2
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: PPUSH
1750: LD_EXP 4
1754: PUSH
1755: LD_INT 3
1757: ARRAY
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PPUSH
1763: LD_EXP 4
1767: PUSH
1768: LD_INT 4
1770: ARRAY
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PPUSH
1776: LD_INT 30
1778: PPUSH
1779: CALL 71077 0 5
// JMMNewVeh := CreateVehicle ;
1783: LD_ADDR_EXP 53
1787: PUSH
1788: CALL_OW 45
1792: ST_TO_ADDR
// if not JMMNewVeh then
1793: LD_EXP 53
1797: NOT
1798: IFFALSE 1829
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 3
1805: PPUSH
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 5
1811: PPUSH
1812: LD_INT 100
1814: PPUSH
1815: CALL 71077 0 5
// JMMNewVeh := CreateVehicle ;
1819: LD_ADDR_EXP 53
1823: PUSH
1824: CALL_OW 45
1828: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1829: LD_EXP 53
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1841: LD_EXP 53
1845: PPUSH
1846: LD_INT 79
1848: PPUSH
1849: LD_INT 91
1851: PPUSH
1852: LD_INT 0
1854: PPUSH
1855: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1859: LD_EXP 36
1863: PPUSH
1864: LD_EXP 53
1868: PPUSH
1869: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1873: LD_EXP 6
1877: PUSH
1878: LD_EXP 2
1882: NOT
1883: AND
1884: IFFALSE 2142
// begin if not JMMGirlVeh then
1886: LD_EXP 5
1890: NOT
1891: IFFALSE 1914
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1893: LD_INT 3
1895: PPUSH
1896: LD_INT 3
1898: PPUSH
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 9
1904: PPUSH
1905: LD_INT 100
1907: PPUSH
1908: CALL 71077 0 5
1912: GO 1973
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1914: LD_EXP 5
1918: PUSH
1919: LD_INT 1
1921: ARRAY
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: PPUSH
1927: LD_EXP 5
1931: PUSH
1932: LD_INT 2
1934: ARRAY
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PPUSH
1940: LD_EXP 5
1944: PUSH
1945: LD_INT 3
1947: ARRAY
1948: PUSH
1949: LD_INT 1
1951: ARRAY
1952: PPUSH
1953: LD_EXP 5
1957: PUSH
1958: LD_INT 4
1960: ARRAY
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PPUSH
1966: LD_INT 30
1968: PPUSH
1969: CALL 71077 0 5
// GirlNewVeh := CreateVehicle ;
1973: LD_ADDR_EXP 54
1977: PUSH
1978: CALL_OW 45
1982: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1983: LD_EXP 54
1987: PPUSH
1988: LD_INT 4
1990: PPUSH
1991: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1995: LD_EXP 54
1999: PPUSH
2000: LD_INT 82
2002: PPUSH
2003: LD_INT 96
2005: PPUSH
2006: LD_INT 0
2008: PPUSH
2009: CALL_OW 48
// if JMMGirl = 1 then
2013: LD_EXP 7
2017: PUSH
2018: LD_INT 1
2020: EQUAL
2021: IFFALSE 2056
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2023: LD_ADDR_EXP 37
2027: PUSH
2028: LD_STRING Joan
2030: PPUSH
2031: LD_INT 1
2033: PPUSH
2034: LD_STRING 14_
2036: PPUSH
2037: CALL 64051 0 3
2041: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2042: LD_EXP 37
2046: PPUSH
2047: LD_EXP 54
2051: PPUSH
2052: CALL_OW 52
// end ; if JMMGirl = 2 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 2
2063: EQUAL
2064: IFFALSE 2099
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Lisa
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 64051 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 54
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 3 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 3
2106: EQUAL
2107: IFFALSE 2142
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2109: LD_ADDR_EXP 51
2113: PUSH
2114: LD_STRING Connie
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 64051 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2128: LD_EXP 51
2132: PPUSH
2133: LD_EXP 54
2137: PPUSH
2138: CALL_OW 52
// end ; end ; end ;
2142: LD_VAR 0 1
2146: RET
// export function PrepareStevensSquad ; var tmp ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// uc_side := 1 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// uc_nation := 1 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 1
2166: ST_TO_ADDR
// tmp := [ ] ;
2167: LD_ADDR_VAR 0 2
2171: PUSH
2172: EMPTY
2173: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2174: LD_ADDR_EXP 38
2178: PUSH
2179: LD_STRING Stevens
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13f_
2190: PPUSH
2191: CALL 64051 0 3
2195: ST_TO_ADDR
// if not Stevens then
2196: LD_EXP 38
2200: NOT
2201: IFFALSE 2257
// begin hc_name = Baker Smith ;
2203: LD_ADDR_OWVAR 26
2207: PUSH
2208: LD_STRING Baker Smith
2210: ST_TO_ADDR
// hc_gallery =  ;
2211: LD_ADDR_OWVAR 33
2215: PUSH
2216: LD_STRING 
2218: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2219: LD_INT 1
2221: PPUSH
2222: LD_INT 10
2224: PPUSH
2225: CALL_OW 384
// Baker = CreateHuman ;
2229: LD_ADDR_EXP 52
2233: PUSH
2234: CALL_OW 44
2238: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 52
2253: ADD
2254: ST_TO_ADDR
// end else
2255: GO 2273
// tmp := tmp ^ Stevens ;
2257: LD_ADDR_VAR 0 2
2261: PUSH
2262: LD_VAR 0 2
2266: PUSH
2267: LD_EXP 38
2271: ADD
2272: ST_TO_ADDR
// if not Lisa then
2273: LD_EXP 39
2277: NOT
2278: IFFALSE 2324
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2280: LD_ADDR_EXP 39
2284: PUSH
2285: LD_STRING Lisa
2287: PPUSH
2288: LD_EXP 1
2292: NOT
2293: PPUSH
2294: LD_STRING 13f_
2296: PPUSH
2297: CALL 64051 0 3
2301: ST_TO_ADDR
// if Lisa then
2302: LD_EXP 39
2306: IFFALSE 2324
// tmp := tmp ^ Lisa ;
2308: LD_ADDR_VAR 0 2
2312: PUSH
2313: LD_VAR 0 2
2317: PUSH
2318: LD_EXP 39
2322: ADD
2323: ST_TO_ADDR
// end ; if not Donaldson then
2324: LD_EXP 40
2328: NOT
2329: IFFALSE 2375
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2331: LD_ADDR_EXP 40
2335: PUSH
2336: LD_STRING Donaldson
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13f_
2347: PPUSH
2348: CALL 64051 0 3
2352: ST_TO_ADDR
// if Donaldson then
2353: LD_EXP 40
2357: IFFALSE 2375
// tmp := tmp ^ Donaldson ;
2359: LD_ADDR_VAR 0 2
2363: PUSH
2364: LD_VAR 0 2
2368: PUSH
2369: LD_EXP 40
2373: ADD
2374: ST_TO_ADDR
// end ; if not Bobby then
2375: LD_EXP 41
2379: NOT
2380: IFFALSE 2426
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2382: LD_ADDR_EXP 41
2386: PUSH
2387: LD_STRING Bobby
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: LD_STRING 13f_
2398: PPUSH
2399: CALL 64051 0 3
2403: ST_TO_ADDR
// if Bobby then
2404: LD_EXP 41
2408: IFFALSE 2426
// tmp := tmp ^ Bobby ;
2410: LD_ADDR_VAR 0 2
2414: PUSH
2415: LD_VAR 0 2
2419: PUSH
2420: LD_EXP 41
2424: ADD
2425: ST_TO_ADDR
// end ; if not Cyrus then
2426: LD_EXP 42
2430: NOT
2431: IFFALSE 2477
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2433: LD_ADDR_EXP 42
2437: PUSH
2438: LD_STRING Cyrus
2440: PPUSH
2441: LD_EXP 1
2445: NOT
2446: PPUSH
2447: LD_STRING 13f_
2449: PPUSH
2450: CALL 64051 0 3
2454: ST_TO_ADDR
// if Cyrus then
2455: LD_EXP 42
2459: IFFALSE 2477
// tmp := tmp ^ Cyrus ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 2
2470: PUSH
2471: LD_EXP 42
2475: ADD
2476: ST_TO_ADDR
// end ; if not Brown then
2477: LD_EXP 44
2481: NOT
2482: IFFALSE 2528
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Brown
2491: PPUSH
2492: LD_EXP 1
2496: NOT
2497: PPUSH
2498: LD_STRING 13f_
2500: PPUSH
2501: CALL 64051 0 3
2505: ST_TO_ADDR
// if Brown then
2506: LD_EXP 44
2510: IFFALSE 2528
// tmp := tmp ^ Brown ;
2512: LD_ADDR_VAR 0 2
2516: PUSH
2517: LD_VAR 0 2
2521: PUSH
2522: LD_EXP 44
2526: ADD
2527: ST_TO_ADDR
// end ; if not Gladstone then
2528: LD_EXP 45
2532: NOT
2533: IFFALSE 2579
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2535: LD_ADDR_EXP 45
2539: PUSH
2540: LD_STRING Gladstone
2542: PPUSH
2543: LD_EXP 1
2547: NOT
2548: PPUSH
2549: LD_STRING 13f_
2551: PPUSH
2552: CALL 64051 0 3
2556: ST_TO_ADDR
// if Gladstone then
2557: LD_EXP 45
2561: IFFALSE 2579
// tmp := tmp ^ Gladstone ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_VAR 0 2
2572: PUSH
2573: LD_EXP 45
2577: ADD
2578: ST_TO_ADDR
// end ; if not Houten then
2579: LD_EXP 46
2583: NOT
2584: IFFALSE 2630
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2586: LD_ADDR_EXP 46
2590: PUSH
2591: LD_STRING Houten
2593: PPUSH
2594: LD_EXP 1
2598: NOT
2599: PPUSH
2600: LD_STRING 13f_
2602: PPUSH
2603: CALL 64051 0 3
2607: ST_TO_ADDR
// if Houten then
2608: LD_EXP 46
2612: IFFALSE 2630
// tmp := tmp ^ Houten ;
2614: LD_ADDR_VAR 0 2
2618: PUSH
2619: LD_VAR 0 2
2623: PUSH
2624: LD_EXP 46
2628: ADD
2629: ST_TO_ADDR
// end ; if not Cornel then
2630: LD_EXP 47
2634: NOT
2635: IFFALSE 2681
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2637: LD_ADDR_EXP 47
2641: PUSH
2642: LD_STRING Cornel
2644: PPUSH
2645: LD_EXP 1
2649: NOT
2650: PPUSH
2651: LD_STRING 13f_
2653: PPUSH
2654: CALL 64051 0 3
2658: ST_TO_ADDR
// if Cornel then
2659: LD_EXP 47
2663: IFFALSE 2681
// tmp := tmp ^ Cornel ;
2665: LD_ADDR_VAR 0 2
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: LD_EXP 47
2679: ADD
2680: ST_TO_ADDR
// end ; if not Gary then
2681: LD_EXP 48
2685: NOT
2686: IFFALSE 2732
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2688: LD_ADDR_EXP 48
2692: PUSH
2693: LD_STRING Gary
2695: PPUSH
2696: LD_EXP 1
2700: NOT
2701: PPUSH
2702: LD_STRING 13f_
2704: PPUSH
2705: CALL 64051 0 3
2709: ST_TO_ADDR
// if Gary then
2710: LD_EXP 48
2714: IFFALSE 2732
// tmp := tmp ^ Gary ;
2716: LD_ADDR_VAR 0 2
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: LD_EXP 48
2730: ADD
2731: ST_TO_ADDR
// end ; if not Frank then
2732: LD_EXP 49
2736: NOT
2737: IFFALSE 2783
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2739: LD_ADDR_EXP 49
2743: PUSH
2744: LD_STRING Frank
2746: PPUSH
2747: LD_EXP 1
2751: NOT
2752: PPUSH
2753: LD_STRING 13f_
2755: PPUSH
2756: CALL 64051 0 3
2760: ST_TO_ADDR
// if Frank then
2761: LD_EXP 49
2765: IFFALSE 2783
// tmp := tmp ^ Frank ;
2767: LD_ADDR_VAR 0 2
2771: PUSH
2772: LD_VAR 0 2
2776: PUSH
2777: LD_EXP 49
2781: ADD
2782: ST_TO_ADDR
// end ; if not Kikuchi then
2783: LD_EXP 50
2787: NOT
2788: IFFALSE 2834
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2790: LD_ADDR_EXP 50
2794: PUSH
2795: LD_STRING Kikuchi
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_STRING 13f_
2806: PPUSH
2807: CALL 64051 0 3
2811: ST_TO_ADDR
// if Kikuchi then
2812: LD_EXP 50
2816: IFFALSE 2834
// tmp := tmp ^ Kikuchi ;
2818: LD_ADDR_VAR 0 2
2822: PUSH
2823: LD_VAR 0 2
2827: PUSH
2828: LD_EXP 50
2832: ADD
2833: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_STRING 13_other_survivors
2846: PPUSH
2847: CALL_OW 31
2851: UNION
2852: ST_TO_ADDR
// result := tmp ;
2853: LD_ADDR_VAR 0 1
2857: PUSH
2858: LD_VAR 0 2
2862: ST_TO_ADDR
// end ; end_of_file
2863: LD_VAR 0 1
2867: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2868: LD_INT 0
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
2876: PPUSH
2877: PPUSH
2878: PPUSH
2879: PPUSH
// uc_side := 4 ;
2880: LD_ADDR_OWVAR 20
2884: PUSH
2885: LD_INT 4
2887: ST_TO_ADDR
// uc_nation := 1 ;
2888: LD_ADDR_OWVAR 21
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2896: LD_INT 387
2898: PPUSH
2899: CALL_OW 274
2903: PPUSH
2904: LD_INT 1
2906: PPUSH
2907: LD_INT 2500
2909: PPUSH
2910: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2914: LD_INT 387
2916: PPUSH
2917: CALL_OW 274
2921: PPUSH
2922: LD_INT 2
2924: PPUSH
2925: LD_INT 400
2927: PPUSH
2928: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2932: LD_INT 387
2934: PPUSH
2935: CALL_OW 274
2939: PPUSH
2940: LD_INT 3
2942: PPUSH
2943: LD_INT 10
2945: PPUSH
2946: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2950: LD_ADDR_EXP 55
2954: PUSH
2955: LD_STRING Powell
2957: PPUSH
2958: CALL_OW 25
2962: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2963: LD_EXP 55
2967: PPUSH
2968: LD_INT 57
2970: PPUSH
2971: LD_INT 94
2973: PPUSH
2974: LD_INT 0
2976: PPUSH
2977: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2981: LD_EXP 55
2985: PPUSH
2986: LD_INT 58
2988: PPUSH
2989: LD_INT 94
2991: PPUSH
2992: CALL_OW 118
// vip := [ ] ;
2996: LD_ADDR_EXP 56
3000: PUSH
3001: EMPTY
3002: ST_TO_ADDR
// tmp := [ ] ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if JMMGirl <> 2 then
3010: LD_EXP 7
3014: PUSH
3015: LD_INT 2
3017: NONEQUAL
3018: IFFALSE 3042
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3020: LD_ADDR_EXP 39
3024: PUSH
3025: LD_STRING Lisa
3027: PPUSH
3028: LD_EXP 1
3032: NOT
3033: PPUSH
3034: LD_STRING 13s_
3036: PPUSH
3037: CALL 64051 0 3
3041: ST_TO_ADDR
// if Lisa then
3042: LD_EXP 39
3046: IFFALSE 3064
// tmp := tmp ^ Lisa ;
3048: LD_ADDR_VAR 0 6
3052: PUSH
3053: LD_VAR 0 6
3057: PUSH
3058: LD_EXP 39
3062: ADD
3063: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3064: LD_ADDR_EXP 40
3068: PUSH
3069: LD_STRING Donaldson
3071: PPUSH
3072: LD_EXP 1
3076: NOT
3077: PPUSH
3078: LD_STRING 13s_
3080: PPUSH
3081: CALL 64051 0 3
3085: ST_TO_ADDR
// if Donaldson then
3086: LD_EXP 40
3090: IFFALSE 3108
// tmp := tmp ^ Donaldson ;
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: LD_VAR 0 6
3101: PUSH
3102: LD_EXP 40
3106: ADD
3107: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3108: LD_ADDR_EXP 41
3112: PUSH
3113: LD_STRING Bobby
3115: PPUSH
3116: LD_EXP 1
3120: NOT
3121: PPUSH
3122: LD_STRING 13s_
3124: PPUSH
3125: CALL 64051 0 3
3129: ST_TO_ADDR
// if Bobby then
3130: LD_EXP 41
3134: IFFALSE 3152
// tmp := tmp ^ Bobby ;
3136: LD_ADDR_VAR 0 6
3140: PUSH
3141: LD_VAR 0 6
3145: PUSH
3146: LD_EXP 41
3150: ADD
3151: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3152: LD_ADDR_EXP 42
3156: PUSH
3157: LD_STRING Cyrus
3159: PPUSH
3160: LD_EXP 1
3164: NOT
3165: PPUSH
3166: LD_STRING 13s_
3168: PPUSH
3169: CALL 64051 0 3
3173: ST_TO_ADDR
// if Cyrus then
3174: LD_EXP 42
3178: IFFALSE 3196
// tmp := tmp ^ Cyrus ;
3180: LD_ADDR_VAR 0 6
3184: PUSH
3185: LD_VAR 0 6
3189: PUSH
3190: LD_EXP 42
3194: ADD
3195: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3196: LD_ADDR_EXP 43
3200: PUSH
3201: LD_STRING Denis
3203: PPUSH
3204: LD_EXP 1
3208: NOT
3209: PPUSH
3210: LD_STRING 13s_
3212: PPUSH
3213: CALL 64051 0 3
3217: ST_TO_ADDR
// if not Denis then
3218: LD_EXP 43
3222: NOT
3223: IFFALSE 3247
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3225: LD_ADDR_EXP 43
3229: PUSH
3230: LD_STRING Denis
3232: PPUSH
3233: LD_EXP 1
3237: NOT
3238: PPUSH
3239: LD_STRING 13f_
3241: PPUSH
3242: CALL 64051 0 3
3246: ST_TO_ADDR
// if Denis then
3247: LD_EXP 43
3251: IFFALSE 3269
// tmp := tmp ^ Denis ;
3253: LD_ADDR_VAR 0 6
3257: PUSH
3258: LD_VAR 0 6
3262: PUSH
3263: LD_EXP 43
3267: ADD
3268: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3269: LD_ADDR_EXP 44
3273: PUSH
3274: LD_STRING Brown
3276: PPUSH
3277: LD_EXP 1
3281: NOT
3282: PPUSH
3283: LD_STRING 13s_
3285: PPUSH
3286: CALL 64051 0 3
3290: ST_TO_ADDR
// if Brown then
3291: LD_EXP 44
3295: IFFALSE 3313
// tmp := tmp ^ Brown ;
3297: LD_ADDR_VAR 0 6
3301: PUSH
3302: LD_VAR 0 6
3306: PUSH
3307: LD_EXP 44
3311: ADD
3312: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3313: LD_ADDR_EXP 45
3317: PUSH
3318: LD_STRING Gladstone
3320: PPUSH
3321: LD_EXP 1
3325: NOT
3326: PPUSH
3327: LD_STRING 13s_
3329: PPUSH
3330: CALL 64051 0 3
3334: ST_TO_ADDR
// if Gladstone then
3335: LD_EXP 45
3339: IFFALSE 3357
// tmp := tmp ^ Gladstone ;
3341: LD_ADDR_VAR 0 6
3345: PUSH
3346: LD_VAR 0 6
3350: PUSH
3351: LD_EXP 45
3355: ADD
3356: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3357: LD_ADDR_EXP 46
3361: PUSH
3362: LD_STRING Houten
3364: PPUSH
3365: LD_EXP 1
3369: NOT
3370: PPUSH
3371: LD_STRING 13s_
3373: PPUSH
3374: CALL 64051 0 3
3378: ST_TO_ADDR
// if Houten then
3379: LD_EXP 46
3383: IFFALSE 3401
// tmp := tmp ^ Houten ;
3385: LD_ADDR_VAR 0 6
3389: PUSH
3390: LD_VAR 0 6
3394: PUSH
3395: LD_EXP 46
3399: ADD
3400: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3401: LD_ADDR_EXP 47
3405: PUSH
3406: LD_STRING Cornel
3408: PPUSH
3409: LD_EXP 1
3413: NOT
3414: PPUSH
3415: LD_STRING 13s_
3417: PPUSH
3418: CALL 64051 0 3
3422: ST_TO_ADDR
// if Cornel then
3423: LD_EXP 47
3427: IFFALSE 3445
// tmp := tmp ^ Cornel ;
3429: LD_ADDR_VAR 0 6
3433: PUSH
3434: LD_VAR 0 6
3438: PUSH
3439: LD_EXP 47
3443: ADD
3444: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3445: LD_ADDR_EXP 48
3449: PUSH
3450: LD_STRING Gary
3452: PPUSH
3453: LD_EXP 1
3457: NOT
3458: PPUSH
3459: LD_STRING 13s_
3461: PPUSH
3462: CALL 64051 0 3
3466: ST_TO_ADDR
// if Gary then
3467: LD_EXP 48
3471: IFFALSE 3489
// tmp := tmp ^ Gary ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_VAR 0 6
3482: PUSH
3483: LD_EXP 48
3487: ADD
3488: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3489: LD_ADDR_EXP 49
3493: PUSH
3494: LD_STRING Frank
3496: PPUSH
3497: LD_EXP 1
3501: NOT
3502: PPUSH
3503: LD_STRING 13s_
3505: PPUSH
3506: CALL 64051 0 3
3510: ST_TO_ADDR
// if Frank then
3511: LD_EXP 49
3515: IFFALSE 3533
// tmp := tmp ^ Frank ;
3517: LD_ADDR_VAR 0 6
3521: PUSH
3522: LD_VAR 0 6
3526: PUSH
3527: LD_EXP 49
3531: ADD
3532: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3533: LD_ADDR_EXP 50
3537: PUSH
3538: LD_STRING Kikuchi
3540: PPUSH
3541: LD_EXP 1
3545: NOT
3546: PPUSH
3547: LD_STRING 13s_
3549: PPUSH
3550: CALL 64051 0 3
3554: ST_TO_ADDR
// if Kikuchi then
3555: LD_EXP 50
3559: IFFALSE 3577
// tmp := tmp ^ Kikuchi ;
3561: LD_ADDR_VAR 0 6
3565: PUSH
3566: LD_VAR 0 6
3570: PUSH
3571: LD_EXP 50
3575: ADD
3576: ST_TO_ADDR
// vip := tmp ;
3577: LD_ADDR_EXP 56
3581: PUSH
3582: LD_VAR 0 6
3586: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_VAR 0 6
3596: PUSH
3597: LD_STRING 13s_others
3599: PPUSH
3600: CALL_OW 31
3604: UNION
3605: ST_TO_ADDR
// if tmp < 20 then
3606: LD_VAR 0 6
3610: PUSH
3611: LD_INT 20
3613: LESS
3614: IFFALSE 3681
// for i = 1 to 20 - tmp do
3616: LD_ADDR_VAR 0 2
3620: PUSH
3621: DOUBLE
3622: LD_INT 1
3624: DEC
3625: ST_TO_ADDR
3626: LD_INT 20
3628: PUSH
3629: LD_VAR 0 6
3633: MINUS
3634: PUSH
3635: FOR_TO
3636: IFFALSE 3679
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3638: LD_INT 1
3640: PPUSH
3641: LD_VAR 0 2
3645: PUSH
3646: LD_INT 4
3648: MOD
3649: PUSH
3650: LD_INT 1
3652: PLUS
3653: PPUSH
3654: LD_INT 5
3656: PPUSH
3657: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: CALL_OW 44
3675: ADD
3676: ST_TO_ADDR
// end ;
3677: GO 3635
3679: POP
3680: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 7
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 8
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 6
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 9
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 4
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3795: LD_ADDR_VAR 0 10
3799: PUSH
3800: LD_INT 22
3802: PUSH
3803: LD_INT 4
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: LD_INT 30
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PPUSH
3824: CALL_OW 69
3828: PUSH
3829: LD_INT 1
3831: ARRAY
3832: ST_TO_ADDR
// for i in tmp do
3833: LD_ADDR_VAR 0 2
3837: PUSH
3838: LD_VAR 0 6
3842: PUSH
3843: FOR_IN
3844: IFFALSE 3970
// begin cl := GetClass ( i ) ;
3846: LD_ADDR_VAR 0 5
3850: PUSH
3851: LD_VAR 0 2
3855: PPUSH
3856: CALL_OW 257
3860: ST_TO_ADDR
// if cl > 4 then
3861: LD_VAR 0 5
3865: PUSH
3866: LD_INT 4
3868: GREATER
3869: IFFALSE 3879
// cl := 1 ;
3871: LD_ADDR_VAR 0 5
3875: PUSH
3876: LD_INT 1
3878: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3879: LD_ADDR_VAR 0 3
3883: PUSH
3884: LD_VAR 0 9
3888: PUSH
3889: LD_VAR 0 7
3893: PUSH
3894: LD_VAR 0 10
3898: PUSH
3899: LD_VAR 0 8
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_VAR 0 5
3914: ARRAY
3915: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3916: LD_VAR 0 3
3920: PPUSH
3921: CALL_OW 313
3925: PUSH
3926: LD_INT 5
3928: LESS
3929: IFFALSE 3947
// PlaceHumanInUnit ( i , b ) else
3931: LD_VAR 0 2
3935: PPUSH
3936: LD_VAR 0 3
3940: PPUSH
3941: CALL_OW 52
3945: GO 3968
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3947: LD_VAR 0 2
3951: PPUSH
3952: LD_INT 58
3954: PPUSH
3955: LD_INT 91
3957: PPUSH
3958: LD_INT 6
3960: PPUSH
3961: LD_INT 0
3963: PPUSH
3964: CALL_OW 50
// end ;
3968: GO 3843
3970: POP
3971: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3972: LD_INT 2
3974: PPUSH
3975: LD_INT 1
3977: PPUSH
3978: LD_INT 1
3980: PPUSH
3981: LD_INT 12
3983: PPUSH
3984: LD_INT 100
3986: PPUSH
3987: CALL 71077 0 5
// veh := CreateVehicle ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: CALL_OW 45
4000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4001: LD_VAR 0 4
4005: PPUSH
4006: LD_INT 4
4008: PPUSH
4009: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4013: LD_VAR 0 4
4017: PPUSH
4018: LD_INT 49
4020: PPUSH
4021: LD_INT 88
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4031: LD_VAR 0 4
4035: PPUSH
4036: LD_INT 1
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL_OW 290
// uc_side := 0 ;
4046: LD_ADDR_OWVAR 20
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// uc_nation := 0 ;
4054: LD_ADDR_OWVAR 21
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// for i = 1 to 4 do
4062: LD_ADDR_VAR 0 2
4066: PUSH
4067: DOUBLE
4068: LD_INT 1
4070: DEC
4071: ST_TO_ADDR
4072: LD_INT 4
4074: PUSH
4075: FOR_TO
4076: IFFALSE 4107
// begin InitHc ;
4078: CALL_OW 19
// hc_class := class_apeman ;
4082: LD_ADDR_OWVAR 28
4086: PUSH
4087: LD_INT 12
4089: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4090: CALL_OW 44
4094: PPUSH
4095: LD_INT 13
4097: PPUSH
4098: LD_INT 0
4100: PPUSH
4101: CALL_OW 49
// end ;
4105: GO 4075
4107: POP
4108: POP
// end ; end_of_file
4109: LD_VAR 0 1
4113: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4114: LD_INT 0
4116: PPUSH
4117: PPUSH
4118: PPUSH
4119: PPUSH
4120: PPUSH
// side := 8 ;
4121: LD_ADDR_VAR 0 3
4125: PUSH
4126: LD_INT 8
4128: ST_TO_ADDR
// uc_side := side ;
4129: LD_ADDR_OWVAR 20
4133: PUSH
4134: LD_VAR 0 3
4138: ST_TO_ADDR
// uc_nation := 2 ;
4139: LD_ADDR_OWVAR 21
4143: PUSH
4144: LD_INT 2
4146: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4147: LD_ADDR_VAR 0 2
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: LD_VAR 0 3
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: LD_INT 21
4166: PUSH
4167: LD_INT 3
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PPUSH
4178: CALL_OW 69
4182: PUSH
4183: FOR_IN
4184: IFFALSE 4200
// SetBLevel ( i , 10 ) ;
4186: LD_VAR 0 2
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: CALL_OW 241
4198: GO 4183
4200: POP
4201: POP
// if KurtStatus then
4202: LD_EXP 3
4206: IFFALSE 4229
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4208: LD_ADDR_EXP 57
4212: PUSH
4213: LD_STRING Kurt
4215: PPUSH
4216: LD_INT 0
4218: PPUSH
4219: LD_STRING 
4221: PPUSH
4222: CALL 64051 0 3
4226: ST_TO_ADDR
4227: GO 4251
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4229: LD_ADDR_EXP 57
4233: PUSH
4234: LD_STRING AltKurt
4236: PPUSH
4237: LD_EXP 1
4241: NOT
4242: PPUSH
4243: LD_STRING 
4245: PPUSH
4246: CALL 64051 0 3
4250: ST_TO_ADDR
// if not Kurt then
4251: LD_EXP 57
4255: NOT
4256: IFFALSE 4282
// begin InitHc ;
4258: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 10
4267: PPUSH
4268: CALL_OW 381
// Kurt := CreateHuman ;
4272: LD_ADDR_EXP 57
4276: PUSH
4277: CALL_OW 44
4281: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4282: LD_EXP 57
4286: PPUSH
4287: LD_INT 324
4289: PPUSH
4290: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4294: LD_ADDR_EXP 58
4298: PUSH
4299: LD_STRING Kozlov
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: LD_STRING 
4307: PPUSH
4308: CALL 64051 0 3
4312: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4313: LD_EXP 58
4317: PPUSH
4318: LD_INT 22
4320: PUSH
4321: LD_INT 8
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 23
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: LD_INT 30
4340: PUSH
4341: LD_INT 8
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: PPUSH
4353: CALL_OW 69
4357: PUSH
4358: LD_INT 1
4360: ARRAY
4361: PPUSH
4362: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4366: LD_EXP 58
4370: PPUSH
4371: LD_INT 3
4373: PPUSH
4374: LD_INT 10
4376: PPUSH
4377: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4381: LD_ADDR_VAR 0 5
4385: PUSH
4386: LD_INT 22
4388: PUSH
4389: LD_VAR 0 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 30
4400: PUSH
4401: LD_INT 32
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 58
4410: PUSH
4411: EMPTY
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: PPUSH
4419: CALL_OW 69
4423: ST_TO_ADDR
// for i = 1 to 10 do
4424: LD_ADDR_VAR 0 2
4428: PUSH
4429: DOUBLE
4430: LD_INT 1
4432: DEC
4433: ST_TO_ADDR
4434: LD_INT 10
4436: PUSH
4437: FOR_TO
4438: IFFALSE 4510
// begin uc_nation := nation_nature ;
4440: LD_ADDR_OWVAR 21
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4448: LD_ADDR_OWVAR 28
4452: PUSH
4453: LD_INT 15
4455: ST_TO_ADDR
// hc_gallery :=  ;
4456: LD_ADDR_OWVAR 33
4460: PUSH
4461: LD_STRING 
4463: ST_TO_ADDR
// hc_name :=  ;
4464: LD_ADDR_OWVAR 26
4468: PUSH
4469: LD_STRING 
4471: ST_TO_ADDR
// un := CreateHuman ;
4472: LD_ADDR_VAR 0 4
4476: PUSH
4477: CALL_OW 44
4481: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4482: LD_VAR 0 4
4486: PPUSH
4487: LD_VAR 0 5
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_VAR 0 2
4501: MINUS
4502: ARRAY
4503: PPUSH
4504: CALL_OW 52
// end ;
4508: GO 4437
4510: POP
4511: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_STRING 12_kurt_squad
4519: PPUSH
4520: CALL_OW 31
4524: ST_TO_ADDR
// if tmp then
4525: LD_VAR 0 5
4529: IFFALSE 4563
// for i in tmp do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: LD_VAR 0 5
4540: PUSH
4541: FOR_IN
4542: IFFALSE 4561
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_INT 5
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 49
4559: GO 4541
4561: POP
4562: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4563: LD_INT 324
4565: PPUSH
4566: LD_INT 5
4568: PPUSH
4569: LD_STRING 
4571: PPUSH
4572: LD_INT 8
4574: PUSH
4575: LD_INT 9
4577: PUSH
4578: LD_INT 10
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_OWVAR 67
4590: ARRAY
4591: PPUSH
4592: LD_INT 3000
4594: PUSH
4595: LD_INT 500
4597: PUSH
4598: LD_INT 150
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: LIST
4605: PPUSH
4606: LD_INT 16
4608: PUSH
4609: LD_INT 6
4611: PUSH
4612: LD_INT 6
4614: PUSH
4615: LD_INT 8
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: PPUSH
4624: CALL 74486 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4628: LD_ADDR_EXP 99
4632: PUSH
4633: LD_EXP 99
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 22
4643: PUSH
4644: LD_VAR 0 3
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 23
4655: PUSH
4656: LD_INT 2
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 3
4665: PUSH
4666: LD_INT 21
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PPUSH
4685: CALL_OW 69
4689: PUSH
4690: LD_EXP 57
4694: DIFF
4695: PPUSH
4696: CALL_OW 1
4700: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 7
4706: PPUSH
4707: CALL_OW 383
// Friend := CreateHuman ;
4711: LD_ADDR_EXP 59
4715: PUSH
4716: CALL_OW 44
4720: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4721: LD_INT 14
4723: PPUSH
4724: LD_INT 3
4726: PPUSH
4727: LD_INT 1
4729: PPUSH
4730: LD_INT 29
4732: PPUSH
4733: LD_INT 100
4735: PPUSH
4736: CALL 71077 0 5
// powellBomb := CreateVehicle ;
4740: LD_ADDR_EXP 60
4744: PUSH
4745: CALL_OW 45
4749: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4750: LD_EXP 60
4754: PPUSH
4755: LD_INT 90
4757: PPUSH
4758: LD_INT 51
4760: PPUSH
4761: LD_INT 0
4763: PPUSH
4764: CALL_OW 48
// end ;
4768: LD_VAR 0 1
4772: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4773: LD_INT 0
4775: PPUSH
4776: PPUSH
4777: PPUSH
// if IsLive ( kozlov_fac ) then
4778: LD_INT 332
4780: PPUSH
4781: CALL_OW 300
4785: IFFALSE 4789
// exit ;
4787: GO 5356
// ComExitBuilding ( Kozlov ) ;
4789: LD_EXP 58
4793: PPUSH
4794: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4798: LD_EXP 58
4802: PPUSH
4803: CALL_OW 257
4807: PUSH
4808: LD_INT 2
4810: NONEQUAL
4811: IFFALSE 4846
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 324
4820: PPUSH
4821: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4825: LD_EXP 58
4829: PPUSH
4830: LD_INT 2
4832: PPUSH
4833: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4837: LD_EXP 58
4841: PPUSH
4842: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4846: LD_EXP 58
4850: PPUSH
4851: LD_INT 2
4853: PPUSH
4854: LD_INT 93
4856: PPUSH
4857: LD_INT 32
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4867: LD_INT 35
4869: PPUSH
4870: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4874: LD_INT 22
4876: PUSH
4877: LD_INT 8
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 30
4886: PUSH
4887: LD_INT 3
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 23
4896: PUSH
4897: LD_INT 3
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 57
4906: PUSH
4907: EMPTY
4908: LIST
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: IFFALSE 4867
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4922: LD_ADDR_VAR 0 2
4926: PUSH
4927: LD_INT 22
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 30
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 23
4949: PUSH
4950: LD_INT 3
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: LD_INT 57
4959: PUSH
4960: EMPTY
4961: LIST
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 69
4973: PUSH
4974: LD_INT 1
4976: ARRAY
4977: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4978: LD_INT 22
4980: PUSH
4981: LD_INT 8
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 23
4990: PUSH
4991: LD_INT 3
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 30
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: NOT
5018: IFFALSE 5096
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5020: LD_EXP 58
5024: PPUSH
5025: LD_INT 21
5027: PPUSH
5028: LD_INT 97
5030: PPUSH
5031: LD_INT 36
5033: PPUSH
5034: LD_INT 5
5036: PPUSH
5037: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5041: LD_INT 35
5043: PPUSH
5044: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5048: LD_INT 22
5050: PUSH
5051: LD_INT 8
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: LD_INT 23
5060: PUSH
5061: LD_INT 3
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 30
5070: PUSH
5071: LD_INT 21
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 57
5080: PUSH
5081: EMPTY
5082: LIST
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: IFFALSE 5041
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5096: LD_INT 22
5098: PUSH
5099: LD_INT 8
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 23
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 18
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: LIST
5130: PPUSH
5131: CALL_OW 69
5135: NOT
5136: IFFALSE 5214
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5138: LD_EXP 58
5142: PPUSH
5143: LD_INT 18
5145: PPUSH
5146: LD_INT 89
5148: PPUSH
5149: LD_INT 32
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5159: LD_INT 35
5161: PPUSH
5162: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5166: LD_INT 22
5168: PUSH
5169: LD_INT 8
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 23
5178: PUSH
5179: LD_INT 3
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 30
5188: PUSH
5189: LD_INT 18
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 57
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: IFFALSE 5159
// end ; lab := kozlov_lab ;
5214: LD_ADDR_VAR 0 3
5218: PUSH
5219: LD_INT 336
5221: ST_TO_ADDR
// if not lab then
5222: LD_VAR 0 3
5226: NOT
5227: IFFALSE 5231
// exit ;
5229: GO 5356
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5231: LD_EXP 58
5235: PPUSH
5236: LD_VAR 0 3
5240: PUSH
5241: LD_INT 1
5243: ARRAY
5244: PPUSH
5245: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5249: LD_EXP 58
5253: PPUSH
5254: LD_INT 4
5256: PPUSH
5257: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5261: LD_VAR 0 3
5265: PUSH
5266: LD_INT 1
5268: ARRAY
5269: PPUSH
5270: LD_INT 25
5272: PPUSH
5273: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5277: LD_INT 35
5279: PPUSH
5280: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5284: LD_INT 25
5286: PPUSH
5287: LD_INT 8
5289: PPUSH
5290: CALL_OW 321
5294: PUSH
5295: LD_INT 2
5297: EQUAL
5298: IFFALSE 5277
// ComExitBuilding ( Kozlov ) ;
5300: LD_EXP 58
5304: PPUSH
5305: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5309: LD_EXP 58
5313: PPUSH
5314: LD_VAR 0 2
5318: PPUSH
5319: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5323: LD_EXP 58
5327: PPUSH
5328: LD_INT 3
5330: PPUSH
5331: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5335: LD_VAR 0 2
5339: PPUSH
5340: LD_INT 23
5342: PPUSH
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: LD_INT 48
5351: PPUSH
5352: CALL_OW 125
// end ;
5356: LD_VAR 0 1
5360: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5361: LD_EXP 22
5365: NOT
5366: PUSH
5367: LD_EXP 15
5371: PUSH
5372: LD_INT 6
5374: GREATEREQUAL
5375: AND
5376: IFFALSE 5457
5378: GO 5380
5380: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5381: LD_INT 3
5383: PPUSH
5384: LD_INT 3
5386: PPUSH
5387: CALL 57844 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 14
5396: PUSH
5397: LD_INT 1
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 28
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 14
5414: PUSH
5415: LD_INT 1
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 28
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 14
5432: PUSH
5433: LD_INT 1
5435: PUSH
5436: LD_INT 1
5438: PUSH
5439: LD_INT 28
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: PPUSH
5453: CALL 57707 0 2
// end ;
5457: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5458: LD_EXP 22
5462: NOT
5463: PUSH
5464: LD_EXP 15
5468: PUSH
5469: LD_INT 6
5471: GREATEREQUAL
5472: AND
5473: PUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL 59125 0 2
5484: NOT
5485: AND
5486: IFFALSE 6326
5488: GO 5490
5490: DISABLE
5491: LD_INT 0
5493: PPUSH
5494: PPUSH
5495: PPUSH
// begin enable ;
5496: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5497: LD_INT 22
5499: PUSH
5500: LD_INT 8
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 30
5519: PUSH
5520: LD_INT 3
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: PPUSH
5532: CALL_OW 69
5536: NOT
5537: IFFALSE 5541
// exit ;
5539: GO 6326
// if Prob ( 40 ) then
5541: LD_INT 40
5543: PPUSH
5544: CALL_OW 13
5548: IFFALSE 5675
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5550: LD_INT 3
5552: PPUSH
5553: LD_INT 14
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 28
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 14
5573: PUSH
5574: LD_INT 1
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 28
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 28
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 14
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: LD_INT 28
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_INT 14
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: LD_INT 2
5633: PUSH
5634: LD_INT 28
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 14
5645: PUSH
5646: LD_INT 1
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL 57707 0 2
// end else
5673: GO 5866
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5675: LD_INT 3
5677: PPUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 27
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 26
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_OWVAR 67
5705: ARRAY
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 14
5715: PUSH
5716: LD_INT 1
5718: PUSH
5719: LD_INT 2
5721: PUSH
5722: LD_INT 27
5724: PUSH
5725: LD_INT 26
5727: PUSH
5728: LD_INT 26
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_OWVAR 67
5740: ARRAY
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 14
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: LD_INT 2
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: LD_INT 29
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 13
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 29
5797: PUSH
5798: LD_INT 29
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: PUSH
5806: LD_OWVAR 67
5810: ARRAY
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 13
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: LD_INT 2
5826: PUSH
5827: LD_INT 29
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 26
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PPUSH
5862: CALL 57707 0 2
// end ; repeat wait ( 0 0$1 ) ;
5866: LD_INT 35
5868: PPUSH
5869: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 59125 0 2
5883: PUSH
5884: LD_INT 6
5886: GREATEREQUAL
5887: IFFALSE 5866
// wait ( 0 0$30 ) ;
5889: LD_INT 1050
5891: PPUSH
5892: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5896: LD_ADDR_VAR 0 2
5900: PUSH
5901: LD_INT 3
5903: PPUSH
5904: LD_INT 1
5906: PPUSH
5907: CALL 59125 0 2
5911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5912: LD_ADDR_EXP 118
5916: PUSH
5917: LD_EXP 118
5921: PPUSH
5922: LD_INT 3
5924: PPUSH
5925: LD_EXP 118
5929: PUSH
5930: LD_INT 3
5932: ARRAY
5933: PUSH
5934: LD_VAR 0 2
5938: DIFF
5939: PPUSH
5940: CALL_OW 1
5944: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 0
5952: PPUSH
5953: LD_INT 2
5955: PPUSH
5956: CALL_OW 12
5960: ST_TO_ADDR
// if target then
5961: LD_VAR 0 3
5965: IFFALSE 6093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: LD_VAR 0 2
5976: PPUSH
5977: LD_INT 24
5979: PUSH
5980: LD_INT 250
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PPUSH
5987: CALL_OW 72
5991: ST_TO_ADDR
// for i in tmp do
5992: LD_ADDR_VAR 0 1
5996: PUSH
5997: LD_VAR 0 2
6001: PUSH
6002: FOR_IN
6003: IFFALSE 6043
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6005: LD_VAR 0 1
6009: PPUSH
6010: LD_INT 89
6012: PPUSH
6013: LD_INT 71
6015: PPUSH
6016: CALL_OW 297
6020: PUSH
6021: LD_INT 9
6023: GREATER
6024: IFFALSE 6041
// ComMoveXY ( i , 89 , 71 ) ;
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 89
6033: PPUSH
6034: LD_INT 71
6036: PPUSH
6037: CALL_OW 111
6041: GO 6002
6043: POP
6044: POP
// wait ( 0 0$1 ) ;
6045: LD_INT 35
6047: PPUSH
6048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6052: LD_VAR 0 2
6056: PPUSH
6057: LD_INT 92
6059: PUSH
6060: LD_INT 89
6062: PUSH
6063: LD_INT 71
6065: PUSH
6066: LD_INT 9
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: PUSH
6080: LD_VAR 0 2
6084: PUSH
6085: LD_INT 1
6087: MINUS
6088: GREATEREQUAL
6089: IFFALSE 5967
// end else
6091: GO 6217
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 24
6105: PUSH
6106: LD_INT 250
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: PPUSH
6113: CALL_OW 72
6117: ST_TO_ADDR
// for i in tmp do
6118: LD_ADDR_VAR 0 1
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6169
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 125
6138: PPUSH
6139: LD_INT 129
6141: PPUSH
6142: CALL_OW 297
6146: PUSH
6147: LD_INT 9
6149: GREATER
6150: IFFALSE 6167
// ComMoveXY ( i , 125 , 129 ) ;
6152: LD_VAR 0 1
6156: PPUSH
6157: LD_INT 125
6159: PPUSH
6160: LD_INT 129
6162: PPUSH
6163: CALL_OW 111
6167: GO 6128
6169: POP
6170: POP
// wait ( 0 0$1 ) ;
6171: LD_INT 35
6173: PPUSH
6174: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6178: LD_VAR 0 2
6182: PPUSH
6183: LD_INT 92
6185: PUSH
6186: LD_INT 125
6188: PUSH
6189: LD_INT 129
6191: PUSH
6192: LD_INT 9
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 72
6205: PUSH
6206: LD_VAR 0 2
6210: PUSH
6211: LD_INT 1
6213: MINUS
6214: GREATEREQUAL
6215: IFFALSE 6093
// end ; repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// for i in tmp do
6224: LD_ADDR_VAR 0 1
6228: PUSH
6229: LD_VAR 0 2
6233: PUSH
6234: FOR_IN
6235: IFFALSE 6317
// begin if GetLives ( i ) > 251 then
6237: LD_VAR 0 1
6241: PPUSH
6242: CALL_OW 256
6246: PUSH
6247: LD_INT 251
6249: GREATER
6250: IFFALSE 6288
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6252: LD_VAR 0 1
6256: PPUSH
6257: LD_INT 81
6259: PUSH
6260: LD_INT 8
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PPUSH
6267: CALL_OW 69
6271: PPUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 74
6281: PPUSH
6282: CALL_OW 115
6286: GO 6315
// if IsDead ( i ) then
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 301
6297: IFFALSE 6315
// tmp := tmp diff i ;
6299: LD_ADDR_VAR 0 2
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: LD_VAR 0 1
6313: DIFF
6314: ST_TO_ADDR
// end ;
6315: GO 6234
6317: POP
6318: POP
// until not tmp ;
6319: LD_VAR 0 2
6323: NOT
6324: IFFALSE 6217
// end ;
6326: PPOPN 3
6328: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6329: LD_EXP 22
6333: NOT
6334: PUSH
6335: LD_EXP 15
6339: PUSH
6340: LD_INT 6
6342: GREATEREQUAL
6343: AND
6344: PUSH
6345: LD_OWVAR 67
6349: PUSH
6350: LD_INT 1
6352: GREATER
6353: AND
6354: IFFALSE 6871
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
// begin enable ;
6364: ENABLE
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6372: LD_ADDR_VAR 0 1
6376: PUSH
6377: DOUBLE
6378: LD_INT 1
6380: DEC
6381: ST_TO_ADDR
6382: LD_INT 4
6384: PUSH
6385: LD_INT 6
6387: PUSH
6388: LD_INT 7
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PUSH
6402: FOR_TO
6403: IFFALSE 6563
// begin uc_side := 8 ;
6405: LD_ADDR_OWVAR 20
6409: PUSH
6410: LD_INT 8
6412: ST_TO_ADDR
// uc_nation := 2 ;
6413: LD_ADDR_OWVAR 21
6417: PUSH
6418: LD_INT 2
6420: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6421: LD_INT 13
6423: PUSH
6424: LD_INT 14
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 2
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: LD_INT 1
6445: PPUSH
6446: LD_INT 5
6448: PPUSH
6449: LD_INT 27
6451: PUSH
6452: LD_INT 28
6454: PUSH
6455: LD_INT 26
6457: PUSH
6458: LD_INT 25
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 4
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 88
6481: PPUSH
6482: CALL 71077 0 5
// un := CreateVehicle ;
6486: LD_ADDR_VAR 0 2
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// tmp := tmp ^ un ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: LD_VAR 0 2
6510: ADD
6511: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6512: LD_VAR 0 2
6516: PPUSH
6517: LD_INT 3
6519: PPUSH
6520: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6524: LD_VAR 0 2
6528: PPUSH
6529: LD_INT 30
6531: PPUSH
6532: LD_INT 0
6534: PPUSH
6535: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6539: LD_VAR 0 2
6543: PPUSH
6544: LD_INT 16
6546: PPUSH
6547: LD_INT 11
6549: PPUSH
6550: CALL_OW 111
// wait ( 0 0$2 ) ;
6554: LD_INT 70
6556: PPUSH
6557: CALL_OW 67
// end ;
6561: GO 6402
6563: POP
6564: POP
// for i = 1 to Difficulty do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: DOUBLE
6571: LD_INT 1
6573: DEC
6574: ST_TO_ADDR
6575: LD_OWVAR 67
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6706
// begin uc_side := 8 ;
6583: LD_ADDR_OWVAR 20
6587: PUSH
6588: LD_INT 8
6590: ST_TO_ADDR
// uc_nation := 2 ;
6591: LD_ADDR_OWVAR 21
6595: PUSH
6596: LD_INT 2
6598: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6599: LD_INT 0
6601: PPUSH
6602: LD_INT 8
6604: PPUSH
6605: LD_INT 8
6607: PUSH
6608: LD_INT 8
6610: PUSH
6611: LD_INT 9
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_OWVAR 67
6623: ARRAY
6624: PPUSH
6625: CALL_OW 380
// un := CreateHuman ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: CALL_OW 44
6638: ST_TO_ADDR
// tmp := tmp ^ un ;
6639: LD_ADDR_VAR 0 3
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: LD_VAR 0 2
6653: ADD
6654: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 30
6674: PPUSH
6675: LD_INT 0
6677: PPUSH
6678: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6682: LD_VAR 0 2
6686: PPUSH
6687: LD_INT 16
6689: PPUSH
6690: LD_INT 11
6692: PPUSH
6693: CALL_OW 111
// wait ( 0 0$2 ) ;
6697: LD_INT 70
6699: PPUSH
6700: CALL_OW 67
// end ;
6704: GO 6580
6706: POP
6707: POP
// repeat wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// for i in tmp do
6715: LD_ADDR_VAR 0 1
6719: PUSH
6720: LD_VAR 0 3
6724: PUSH
6725: FOR_IN
6726: IFFALSE 6862
// begin if GetLives ( i ) > 250 then
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 256
6737: PUSH
6738: LD_INT 250
6740: GREATER
6741: IFFALSE 6833
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6743: LD_INT 81
6745: PUSH
6746: LD_INT 8
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 91
6755: PUSH
6756: LD_VAR 0 1
6760: PUSH
6761: LD_INT 10
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: NOT
6778: IFFALSE 6797
// ComAgressiveMove ( i , 67 , 110 ) else
6780: LD_VAR 0 1
6784: PPUSH
6785: LD_INT 67
6787: PPUSH
6788: LD_INT 110
6790: PPUSH
6791: CALL_OW 114
6795: GO 6831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_INT 81
6804: PUSH
6805: LD_INT 8
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PPUSH
6812: CALL_OW 69
6816: PPUSH
6817: LD_VAR 0 1
6821: PPUSH
6822: CALL_OW 74
6826: PPUSH
6827: CALL_OW 115
// end else
6831: GO 6860
// if IsDead ( i ) then
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 301
6842: IFFALSE 6860
// tmp := tmp diff i ;
6844: LD_ADDR_VAR 0 3
6848: PUSH
6849: LD_VAR 0 3
6853: PUSH
6854: LD_VAR 0 1
6858: DIFF
6859: ST_TO_ADDR
// end ;
6860: GO 6725
6862: POP
6863: POP
// until not tmp ;
6864: LD_VAR 0 3
6868: NOT
6869: IFFALSE 6708
// end ; end_of_file
6871: PPOPN 3
6873: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
6884: PPUSH
// side := 3 ;
6885: LD_ADDR_VAR 0 6
6889: PUSH
6890: LD_INT 3
6892: ST_TO_ADDR
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 6
6902: ST_TO_ADDR
// uc_nation := 3 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 3
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_VAR 0 6
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 21
6930: PUSH
6931: LD_INT 3
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PPUSH
6942: CALL_OW 69
6946: PUSH
6947: FOR_IN
6948: IFFALSE 6964
// SetBLevel ( i , 10 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 10
6957: PPUSH
6958: CALL_OW 241
6962: GO 6947
6964: POP
6965: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6966: LD_ADDR_VAR 0 9
6970: PUSH
6971: LD_INT 22
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 30
6985: PUSH
6986: LD_INT 34
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: PPUSH
6997: CALL_OW 69
7001: ST_TO_ADDR
// if teleport then
7002: LD_VAR 0 9
7006: IFFALSE 7027
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7008: LD_VAR 0 9
7012: PUSH
7013: LD_INT 1
7015: ARRAY
7016: PPUSH
7017: LD_INT 123
7019: PPUSH
7020: LD_INT 122
7022: PPUSH
7023: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7027: LD_ADDR_EXP 61
7031: PUSH
7032: LD_STRING Platonov
7034: PPUSH
7035: CALL_OW 25
7039: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7040: LD_ADDR_EXP 62
7044: PUSH
7045: LD_STRING Kovalyuk
7047: PPUSH
7048: CALL_OW 25
7052: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7053: LD_ADDR_EXP 64
7057: PUSH
7058: LD_STRING Yakotich
7060: PPUSH
7061: CALL_OW 25
7065: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7066: LD_ADDR_EXP 63
7070: PUSH
7071: LD_STRING Bystrov
7073: PPUSH
7074: CALL_OW 25
7078: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7079: LD_ADDR_EXP 65
7083: PUSH
7084: LD_STRING Gleb
7086: PPUSH
7087: CALL_OW 25
7091: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7092: LD_STRING 03_Cornel
7094: PPUSH
7095: CALL_OW 28
7099: IFFALSE 7147
// begin Bierezov := NewCharacter ( Mikhail ) ;
7101: LD_ADDR_EXP 66
7105: PUSH
7106: LD_STRING Mikhail
7108: PPUSH
7109: CALL_OW 25
7113: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7114: LD_EXP 66
7118: PPUSH
7119: LD_INT 197
7121: PPUSH
7122: LD_INT 111
7124: PPUSH
7125: LD_INT 9
7127: PPUSH
7128: LD_INT 0
7130: PPUSH
7131: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7135: LD_EXP 66
7139: PPUSH
7140: LD_INT 3
7142: PPUSH
7143: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7147: LD_EXP 61
7151: PPUSH
7152: LD_INT 126
7154: PPUSH
7155: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7159: LD_EXP 62
7163: PPUSH
7164: LD_INT 134
7166: PPUSH
7167: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7171: LD_EXP 64
7175: PPUSH
7176: LD_INT 197
7178: PPUSH
7179: LD_INT 111
7181: PPUSH
7182: LD_INT 9
7184: PPUSH
7185: LD_INT 0
7187: PPUSH
7188: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7192: LD_EXP 63
7196: PPUSH
7197: LD_INT 197
7199: PPUSH
7200: LD_INT 111
7202: PPUSH
7203: LD_INT 9
7205: PPUSH
7206: LD_INT 0
7208: PPUSH
7209: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7213: LD_EXP 65
7217: PPUSH
7218: LD_INT 197
7220: PPUSH
7221: LD_INT 111
7223: PPUSH
7224: LD_INT 9
7226: PPUSH
7227: LD_INT 0
7229: PPUSH
7230: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7234: LD_ADDR_VAR 0 5
7238: PUSH
7239: LD_INT 126
7241: PPUSH
7242: LD_INT 4
7244: PPUSH
7245: LD_STRING zhukov
7247: PPUSH
7248: LD_INT 9
7250: PUSH
7251: LD_INT 10
7253: PUSH
7254: LD_INT 10
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: ARRAY
7267: PPUSH
7268: LD_INT 90000
7270: PUSH
7271: LD_INT 1000
7273: PUSH
7274: LD_INT 300
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: LIST
7281: PPUSH
7282: LD_INT 21
7284: PUSH
7285: LD_INT 8
7287: PUSH
7288: LD_INT 13
7290: PUSH
7291: LD_INT 8
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL 74486 0 6
7304: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: LD_INT 267
7312: PPUSH
7313: CALL_OW 274
7317: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7318: LD_VAR 0 4
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 5000
7328: PPUSH
7329: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7333: LD_VAR 0 4
7337: PPUSH
7338: LD_INT 2
7340: PPUSH
7341: LD_INT 200
7343: PPUSH
7344: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7348: LD_VAR 0 4
7352: PPUSH
7353: LD_INT 3
7355: PPUSH
7356: LD_INT 200
7358: PPUSH
7359: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7363: LD_ADDR_EXP 99
7367: PUSH
7368: LD_EXP 99
7372: PPUSH
7373: LD_INT 2
7375: PPUSH
7376: LD_VAR 0 5
7380: PUSH
7381: LD_INT 22
7383: PUSH
7384: LD_VAR 0 6
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: LD_INT 3
7395: PUSH
7396: LD_INT 21
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: EMPTY
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL_OW 69
7418: UNION
7419: PUSH
7420: LD_EXP 61
7424: DIFF
7425: PPUSH
7426: CALL_OW 1
7430: ST_TO_ADDR
// behemoths := [ ] ;
7431: LD_ADDR_EXP 69
7435: PUSH
7436: EMPTY
7437: ST_TO_ADDR
// behemothBuilders := [ ] ;
7438: LD_ADDR_EXP 70
7442: PUSH
7443: EMPTY
7444: ST_TO_ADDR
// if Kovalyuk then
7445: LD_EXP 62
7449: IFFALSE 7471
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7451: LD_ADDR_EXP 70
7455: PUSH
7456: LD_EXP 70
7460: PPUSH
7461: LD_EXP 62
7465: PPUSH
7466: CALL 106822 0 2
7470: ST_TO_ADDR
// j := 3 ;
7471: LD_ADDR_VAR 0 3
7475: PUSH
7476: LD_INT 3
7478: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7479: LD_ADDR_VAR 0 2
7483: PUSH
7484: LD_INT 22
7486: PUSH
7487: LD_INT 3
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 25
7496: PUSH
7497: LD_INT 3
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: PPUSH
7508: CALL_OW 69
7512: PUSH
7513: LD_EXP 62
7517: DIFF
7518: PUSH
7519: FOR_IN
7520: IFFALSE 7570
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7522: LD_ADDR_EXP 70
7526: PUSH
7527: LD_EXP 70
7531: PPUSH
7532: LD_VAR 0 2
7536: PPUSH
7537: CALL 106822 0 2
7541: ST_TO_ADDR
// j := j - 1 ;
7542: LD_ADDR_VAR 0 3
7546: PUSH
7547: LD_VAR 0 3
7551: PUSH
7552: LD_INT 1
7554: MINUS
7555: ST_TO_ADDR
// if j = 0 then
7556: LD_VAR 0 3
7560: PUSH
7561: LD_INT 0
7563: EQUAL
7564: IFFALSE 7568
// break ;
7566: GO 7570
// end ;
7568: GO 7519
7570: POP
7571: POP
// end ;
7572: LD_VAR 0 1
7576: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7577: LD_INT 0
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7584: LD_ADDR_VAR 0 4
7588: PUSH
7589: LD_INT 209
7591: PUSH
7592: LD_INT 149
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 219
7601: PUSH
7602: LD_INT 154
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 223
7611: PUSH
7612: LD_INT 149
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 232
7621: PUSH
7622: LD_INT 155
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: ST_TO_ADDR
// if not behemothBuilders then
7635: LD_EXP 70
7639: NOT
7640: IFFALSE 7644
// exit ;
7642: GO 7748
// j := 1 ;
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_INT 1
7651: ST_TO_ADDR
// for i in behemothBuilders do
7652: LD_ADDR_VAR 0 2
7656: PUSH
7657: LD_EXP 70
7661: PUSH
7662: FOR_IN
7663: IFFALSE 7746
// begin if IsInUnit ( i ) then
7665: LD_VAR 0 2
7669: PPUSH
7670: CALL_OW 310
7674: IFFALSE 7685
// ComExitBuilding ( i ) ;
7676: LD_VAR 0 2
7680: PPUSH
7681: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7685: LD_VAR 0 2
7689: PPUSH
7690: LD_INT 37
7692: PPUSH
7693: LD_VAR 0 4
7697: PUSH
7698: LD_VAR 0 3
7702: ARRAY
7703: PUSH
7704: LD_INT 1
7706: ARRAY
7707: PPUSH
7708: LD_VAR 0 4
7712: PUSH
7713: LD_VAR 0 3
7717: ARRAY
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: LD_INT 0
7725: PPUSH
7726: CALL_OW 230
// j := j + 1 ;
7730: LD_ADDR_VAR 0 3
7734: PUSH
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: PLUS
7743: ST_TO_ADDR
// end ;
7744: GO 7662
7746: POP
7747: POP
// end ;
7748: LD_VAR 0 1
7752: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7753: LD_INT 24
7755: PPUSH
7756: LD_INT 30
7758: PUSH
7759: LD_INT 37
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 70
7770: IFFALSE 7783
7772: GO 7774
7774: DISABLE
// behemothUnderConstruct := true ;
7775: LD_ADDR_EXP 26
7779: PUSH
7780: LD_INT 1
7782: ST_TO_ADDR
7783: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7784: LD_INT 3
7786: PPUSH
7787: CALL 106870 0 1
7791: PUSH
7792: LD_INT 22
7794: PUSH
7795: LD_INT 3
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PUSH
7802: LD_INT 30
7804: PUSH
7805: LD_INT 37
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: NOT
7821: AND
7822: IFFALSE 8008
7824: GO 7826
7826: DISABLE
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
// begin enable ;
7831: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL 106870 0 1
7844: ST_TO_ADDR
// for i in tmp do
7845: LD_ADDR_VAR 0 1
7849: PUSH
7850: LD_VAR 0 2
7854: PUSH
7855: FOR_IN
7856: IFFALSE 8006
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7858: LD_VAR 0 1
7862: PPUSH
7863: LD_INT 9
7865: PPUSH
7866: CALL_OW 308
7870: PUSH
7871: LD_VAR 0 1
7875: PPUSH
7876: CALL_OW 110
7880: PUSH
7881: LD_INT 2
7883: EQUAL
7884: NOT
7885: AND
7886: IFFALSE 7900
// SetTag ( i , 2 ) ;
7888: LD_VAR 0 1
7892: PPUSH
7893: LD_INT 2
7895: PPUSH
7896: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7900: LD_INT 81
7902: PUSH
7903: LD_INT 3
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 91
7912: PUSH
7913: LD_VAR 0 1
7917: PUSH
7918: LD_INT 12
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 69
7934: NOT
7935: PUSH
7936: LD_VAR 0 1
7940: PPUSH
7941: CALL_OW 110
7945: PUSH
7946: LD_INT 2
7948: EQUAL
7949: NOT
7950: AND
7951: IFFALSE 7970
// ComAgressiveMove ( i , 64 , 93 ) else
7953: LD_VAR 0 1
7957: PPUSH
7958: LD_INT 64
7960: PPUSH
7961: LD_INT 93
7963: PPUSH
7964: CALL_OW 114
7968: GO 8004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7970: LD_VAR 0 1
7974: PPUSH
7975: LD_INT 81
7977: PUSH
7978: LD_INT 3
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: PPUSH
7990: LD_VAR 0 1
7994: PPUSH
7995: CALL_OW 74
7999: PPUSH
8000: CALL_OW 115
// end ;
8004: GO 7855
8006: POP
8007: POP
// end ;
8008: PPOPN 2
8010: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8011: LD_INT 0
8013: PPUSH
8014: PPUSH
8015: PPUSH
// result := [ ] ;
8016: LD_ADDR_VAR 0 2
8020: PUSH
8021: EMPTY
8022: ST_TO_ADDR
// uc_side := 6 ;
8023: LD_ADDR_OWVAR 20
8027: PUSH
8028: LD_INT 6
8030: ST_TO_ADDR
// uc_nation := 3 ;
8031: LD_ADDR_OWVAR 21
8035: PUSH
8036: LD_INT 3
8038: ST_TO_ADDR
// case strength of 1 :
8039: LD_VAR 0 1
8043: PUSH
8044: LD_INT 1
8046: DOUBLE
8047: EQUAL
8048: IFTRUE 8052
8050: GO 8190
8052: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8053: LD_ADDR_VAR 0 3
8057: PUSH
8058: DOUBLE
8059: LD_INT 1
8061: DEC
8062: ST_TO_ADDR
8063: LD_INT 4
8065: PUSH
8066: LD_INT 5
8068: PUSH
8069: LD_INT 6
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_OWVAR 67
8081: ARRAY
8082: PUSH
8083: FOR_TO
8084: IFFALSE 8186
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8086: LD_INT 22
8088: PUSH
8089: LD_INT 24
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: LD_INT 2
8103: MOD
8104: PUSH
8105: LD_INT 1
8107: PLUS
8108: ARRAY
8109: PPUSH
8110: LD_INT 1
8112: PUSH
8113: LD_INT 3
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: LD_INT 1
8122: PPUSH
8123: LD_INT 2
8125: PPUSH
8126: CALL_OW 12
8130: ARRAY
8131: PPUSH
8132: LD_INT 3
8134: PPUSH
8135: LD_INT 43
8137: PUSH
8138: LD_INT 44
8140: PUSH
8141: LD_INT 45
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 1
8151: PPUSH
8152: LD_INT 3
8154: PPUSH
8155: CALL_OW 12
8159: ARRAY
8160: PPUSH
8161: LD_INT 80
8163: PPUSH
8164: CALL 71077 0 5
// result := result union CreateVehicle ;
8168: LD_ADDR_VAR 0 2
8172: PUSH
8173: LD_VAR 0 2
8177: PUSH
8178: CALL_OW 45
8182: UNION
8183: ST_TO_ADDR
// end ;
8184: GO 8083
8186: POP
8187: POP
// end ; 2 :
8188: GO 9134
8190: LD_INT 2
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8354
8198: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8199: LD_ADDR_VAR 0 3
8203: PUSH
8204: DOUBLE
8205: LD_INT 1
8207: DEC
8208: ST_TO_ADDR
8209: LD_INT 6
8211: PUSH
8212: LD_INT 6
8214: PUSH
8215: LD_INT 7
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_OWVAR 67
8227: ARRAY
8228: PUSH
8229: FOR_TO
8230: IFFALSE 8350
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8232: LD_INT 22
8234: PUSH
8235: LD_INT 24
8237: PUSH
8238: LD_INT 24
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: PUSH
8246: LD_VAR 0 3
8250: PUSH
8251: LD_INT 3
8253: MOD
8254: PUSH
8255: LD_INT 1
8257: PLUS
8258: ARRAY
8259: PPUSH
8260: LD_INT 1
8262: PUSH
8263: LD_INT 3
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 1
8272: PPUSH
8273: LD_INT 2
8275: PPUSH
8276: CALL_OW 12
8280: ARRAY
8281: PPUSH
8282: LD_INT 3
8284: PPUSH
8285: LD_INT 43
8287: PUSH
8288: LD_INT 44
8290: PUSH
8291: LD_INT 45
8293: PUSH
8294: LD_INT 44
8296: PUSH
8297: LD_INT 46
8299: PUSH
8300: LD_INT 46
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: PUSH
8311: LD_VAR 0 3
8315: PUSH
8316: LD_INT 6
8318: MOD
8319: PUSH
8320: LD_INT 1
8322: PLUS
8323: ARRAY
8324: PPUSH
8325: LD_INT 80
8327: PPUSH
8328: CALL 71077 0 5
// result := result union CreateVehicle ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_VAR 0 2
8341: PUSH
8342: CALL_OW 45
8346: UNION
8347: ST_TO_ADDR
// end ;
8348: GO 8229
8350: POP
8351: POP
// end ; 3 :
8352: GO 9134
8354: LD_INT 3
8356: DOUBLE
8357: EQUAL
8358: IFTRUE 8362
8360: GO 8518
8362: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8363: LD_ADDR_VAR 0 3
8367: PUSH
8368: DOUBLE
8369: LD_INT 1
8371: DEC
8372: ST_TO_ADDR
8373: LD_INT 6
8375: PUSH
8376: LD_INT 7
8378: PUSH
8379: LD_INT 8
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 47
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 45
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 71077 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 4 :
8516: GO 9134
8518: LD_INT 4
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 9133
8526: POP
// begin uc_nation := 3 ;
8527: LD_ADDR_OWVAR 21
8531: PUSH
8532: LD_INT 3
8534: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 7
8547: PUSH
8548: LD_INT 8
8550: PUSH
8551: LD_INT 9
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PUSH
8559: LD_OWVAR 67
8563: ARRAY
8564: PUSH
8565: FOR_TO
8566: IFFALSE 8686
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8568: LD_INT 22
8570: PUSH
8571: LD_INT 24
8573: PUSH
8574: LD_INT 24
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_VAR 0 3
8586: PUSH
8587: LD_INT 3
8589: MOD
8590: PUSH
8591: LD_INT 1
8593: PLUS
8594: ARRAY
8595: PPUSH
8596: LD_INT 1
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 1
8608: PPUSH
8609: LD_INT 2
8611: PPUSH
8612: CALL_OW 12
8616: ARRAY
8617: PPUSH
8618: LD_INT 3
8620: PPUSH
8621: LD_INT 45
8623: PUSH
8624: LD_INT 47
8626: PUSH
8627: LD_INT 47
8629: PUSH
8630: LD_INT 45
8632: PUSH
8633: LD_INT 46
8635: PUSH
8636: LD_INT 46
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: PUSH
8647: LD_VAR 0 3
8651: PUSH
8652: LD_INT 6
8654: MOD
8655: PUSH
8656: LD_INT 1
8658: PLUS
8659: ARRAY
8660: PPUSH
8661: LD_INT 80
8663: PPUSH
8664: CALL 71077 0 5
// result := result union CreateVehicle ;
8668: LD_ADDR_VAR 0 2
8672: PUSH
8673: LD_VAR 0 2
8677: PUSH
8678: CALL_OW 45
8682: UNION
8683: ST_TO_ADDR
// end ;
8684: GO 8565
8686: POP
8687: POP
// if not KappaStatus then
8688: LD_EXP 2
8692: NOT
8693: IFFALSE 8928
// begin uc_nation := 1 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// for i = 1 to 3 do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 3
8715: PUSH
8716: FOR_TO
8717: IFFALSE 8853
// begin j := rand ( 0 , 1 ) ;
8719: LD_ADDR_VAR 0 4
8723: PUSH
8724: LD_INT 0
8726: PPUSH
8727: LD_INT 1
8729: PPUSH
8730: CALL_OW 12
8734: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8735: LD_INT 3
8737: PUSH
8738: LD_INT 5
8740: PUSH
8741: LD_INT 5
8743: PUSH
8744: LD_INT 4
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: PUSH
8753: LD_VAR 0 4
8757: PUSH
8758: LD_INT 1
8760: PPUSH
8761: LD_INT 3
8763: PPUSH
8764: CALL_OW 12
8768: PLUS
8769: ARRAY
8770: PPUSH
8771: LD_INT 1
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 1
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 12
8791: ARRAY
8792: PPUSH
8793: LD_INT 3
8795: PPUSH
8796: LD_INT 9
8798: PUSH
8799: LD_INT 7
8801: PUSH
8802: LD_INT 6
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: LD_VAR 0 4
8814: PUSH
8815: LD_INT 1
8817: PPUSH
8818: LD_INT 2
8820: PPUSH
8821: CALL_OW 12
8825: PLUS
8826: ARRAY
8827: PPUSH
8828: LD_INT 85
8830: PPUSH
8831: CALL 71077 0 5
// result := result union CreateVehicle ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_VAR 0 2
8844: PUSH
8845: CALL_OW 45
8849: UNION
8850: ST_TO_ADDR
// end ;
8851: GO 8716
8853: POP
8854: POP
// if vsevolodFirstAttack then
8855: LD_EXP 24
8859: IFFALSE 8926
// begin vsevolodFirstAttack := false ;
8861: LD_ADDR_EXP 24
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8869: LD_INT 5
8871: PPUSH
8872: LD_INT 3
8874: PPUSH
8875: LD_INT 1
8877: PPUSH
8878: LD_INT 6
8880: PPUSH
8881: LD_INT 100
8883: PPUSH
8884: CALL 71077 0 5
// sewiVeh := CreateVehicle ;
8888: LD_ADDR_EXP 68
8892: PUSH
8893: CALL_OW 45
8897: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8898: LD_EXP 68
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: CALL_OW 242
// result := result union sewiVeh ;
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_VAR 0 2
8919: PUSH
8920: LD_EXP 68
8924: UNION
8925: ST_TO_ADDR
// end ; end else
8926: GO 9131
// if vsevolodFirstAttack then
8928: LD_EXP 24
8932: IFFALSE 9131
// begin vsevolodFirstAttack := false ;
8934: LD_ADDR_EXP 24
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// uc_nation := 3 ;
8942: LD_ADDR_OWVAR 21
8946: PUSH
8947: LD_INT 3
8949: ST_TO_ADDR
// for i = 1 to 3 do
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: DOUBLE
8956: LD_INT 1
8958: DEC
8959: ST_TO_ADDR
8960: LD_INT 3
8962: PUSH
8963: FOR_TO
8964: IFFALSE 9072
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8966: LD_INT 22
8968: PUSH
8969: LD_INT 24
8971: PUSH
8972: LD_INT 24
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: PUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_INT 3
8987: MOD
8988: PUSH
8989: LD_INT 1
8991: PLUS
8992: ARRAY
8993: PPUSH
8994: LD_INT 1
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: LD_INT 1
9006: PPUSH
9007: LD_INT 2
9009: PPUSH
9010: CALL_OW 12
9014: ARRAY
9015: PPUSH
9016: LD_INT 3
9018: PPUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 47
9024: PUSH
9025: LD_INT 47
9027: PUSH
9028: EMPTY
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_VAR 0 3
9037: PUSH
9038: LD_INT 3
9040: MOD
9041: PUSH
9042: LD_INT 1
9044: PLUS
9045: ARRAY
9046: PPUSH
9047: LD_INT 80
9049: PPUSH
9050: CALL 71077 0 5
// result := result union CreateVehicle ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: CALL_OW 45
9068: UNION
9069: ST_TO_ADDR
// end ;
9070: GO 8963
9072: POP
9073: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9074: LD_INT 24
9076: PPUSH
9077: LD_INT 3
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 47
9085: PPUSH
9086: LD_INT 100
9088: PPUSH
9089: CALL 71077 0 5
// sewiVeh := CreateVehicle ;
9093: LD_ADDR_EXP 68
9097: PUSH
9098: CALL_OW 45
9102: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9103: LD_EXP 68
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 242
// result := result union sewiVeh ;
9115: LD_ADDR_VAR 0 2
9119: PUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_EXP 68
9129: UNION
9130: ST_TO_ADDR
// end ; end ; end ;
9131: GO 9134
9133: POP
// end ;
9134: LD_VAR 0 2
9138: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9139: LD_EXP 16
9143: IFFALSE 9891
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
9153: PPUSH
9154: PPUSH
9155: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9156: LD_ADDR_VAR 0 4
9160: PUSH
9161: LD_INT 11
9163: PUSH
9164: LD_INT 12
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9171: LD_ADDR_VAR 0 3
9175: PUSH
9176: LD_INT 8400
9178: PUSH
9179: LD_INT 7350
9181: PUSH
9182: LD_INT 6650
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: LIST
9189: PUSH
9190: LD_OWVAR 67
9194: ARRAY
9195: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9196: LD_ADDR_VAR 0 6
9200: PUSH
9201: LD_INT 70
9203: PUSH
9204: LD_INT 118
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: LD_INT 78
9213: PUSH
9214: LD_INT 31
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: ST_TO_ADDR
// repeat if missionStage = 2 then
9225: LD_EXP 15
9229: PUSH
9230: LD_INT 2
9232: EQUAL
9233: IFFALSE 9244
// wait ( 1 1$30 ) else
9235: LD_INT 3150
9237: PPUSH
9238: CALL_OW 67
9242: GO 9253
// wait ( time ) ;
9244: LD_VAR 0 3
9248: PPUSH
9249: CALL_OW 67
// if missionStage = 6 then
9253: LD_EXP 15
9257: PUSH
9258: LD_INT 6
9260: EQUAL
9261: IFFALSE 9289
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9263: LD_INT 51
9265: PPUSH
9266: LD_INT 6
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9276: LD_INT 57
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 2
9284: PPUSH
9285: CALL_OW 322
// end ; if missionStage = 8 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 8
9296: EQUAL
9297: IFFALSE 9325
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9299: LD_INT 52
9301: PPUSH
9302: LD_INT 6
9304: PPUSH
9305: LD_INT 2
9307: PPUSH
9308: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9312: LD_INT 58
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 2
9320: PPUSH
9321: CALL_OW 322
// end ; if missionStage = 10 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: EQUAL
9333: IFFALSE 9361
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9335: LD_INT 53
9337: PPUSH
9338: LD_INT 6
9340: PPUSH
9341: LD_INT 2
9343: PPUSH
9344: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9348: LD_INT 59
9350: PPUSH
9351: LD_INT 6
9353: PPUSH
9354: LD_INT 2
9356: PPUSH
9357: CALL_OW 322
// end ; if activeAttacks then
9361: LD_EXP 16
9365: IFFALSE 9885
// begin if missionStage = 2 then
9367: LD_EXP 15
9371: PUSH
9372: LD_INT 2
9374: EQUAL
9375: IFFALSE 9385
// strength := 1 ;
9377: LD_ADDR_VAR 0 5
9381: PUSH
9382: LD_INT 1
9384: ST_TO_ADDR
// if missionStage > 2 then
9385: LD_EXP 15
9389: PUSH
9390: LD_INT 2
9392: GREATER
9393: IFFALSE 9403
// strength := 2 ;
9395: LD_ADDR_VAR 0 5
9399: PUSH
9400: LD_INT 2
9402: ST_TO_ADDR
// if missionStage > 6 then
9403: LD_EXP 15
9407: PUSH
9408: LD_INT 6
9410: GREATER
9411: IFFALSE 9421
// strength := 3 ;
9413: LD_ADDR_VAR 0 5
9417: PUSH
9418: LD_INT 3
9420: ST_TO_ADDR
// if missionStage > 10 then
9421: LD_EXP 15
9425: PUSH
9426: LD_INT 10
9428: GREATER
9429: IFFALSE 9439
// strength := 4 ;
9431: LD_ADDR_VAR 0 5
9435: PUSH
9436: LD_INT 4
9438: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9439: LD_ADDR_VAR 0 2
9443: PUSH
9444: LD_VAR 0 5
9448: PPUSH
9449: CALL 8011 0 1
9453: ST_TO_ADDR
// for i in tmp do
9454: LD_ADDR_VAR 0 1
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: FOR_IN
9465: IFFALSE 9565
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9467: LD_VAR 0 1
9471: PPUSH
9472: LD_VAR 0 4
9476: PUSH
9477: LD_INT 1
9479: PPUSH
9480: LD_INT 2
9482: PPUSH
9483: CALL_OW 12
9487: ARRAY
9488: PPUSH
9489: LD_INT 0
9491: PPUSH
9492: CALL_OW 49
// if i = sewiVeh then
9496: LD_VAR 0 1
9500: PUSH
9501: LD_EXP 68
9505: EQUAL
9506: IFFALSE 9541
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9508: LD_ADDR_EXP 67
9512: PUSH
9513: LD_STRING Vsevolod
9515: PPUSH
9516: LD_INT 0
9518: PPUSH
9519: LD_STRING 
9521: PPUSH
9522: CALL 64051 0 3
9526: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9527: LD_EXP 67
9531: PPUSH
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9541: LD_VAR 0 1
9545: PPUSH
9546: LD_INT 111
9548: PPUSH
9549: LD_INT 197
9551: PPUSH
9552: CALL_OW 111
// wait ( 0 0$2 ) ;
9556: LD_INT 70
9558: PPUSH
9559: CALL_OW 67
// end ;
9563: GO 9464
9565: POP
9566: POP
// repeat wait ( 0 0$1 ) ;
9567: LD_INT 35
9569: PPUSH
9570: CALL_OW 67
// for i in tmp do
9574: LD_ADDR_VAR 0 1
9578: PUSH
9579: LD_VAR 0 2
9583: PUSH
9584: FOR_IN
9585: IFFALSE 9866
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9587: LD_INT 81
9589: PUSH
9590: LD_INT 6
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PUSH
9597: LD_INT 91
9599: PUSH
9600: LD_VAR 0 1
9604: PUSH
9605: LD_INT 12
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PPUSH
9617: CALL_OW 69
9621: IFFALSE 9679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9623: LD_VAR 0 1
9627: PPUSH
9628: LD_INT 81
9630: PUSH
9631: LD_INT 6
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PUSH
9638: LD_INT 91
9640: PUSH
9641: LD_VAR 0 1
9645: PUSH
9646: LD_INT 12
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: LIST
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PPUSH
9658: CALL_OW 69
9662: PPUSH
9663: LD_VAR 0 1
9667: PPUSH
9668: CALL_OW 74
9672: PPUSH
9673: CALL_OW 115
9677: GO 9864
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9679: LD_INT 9
9681: PPUSH
9682: LD_INT 81
9684: PUSH
9685: LD_INT 6
9687: PUSH
9688: EMPTY
9689: LIST
9690: LIST
9691: PPUSH
9692: CALL_OW 70
9696: IFFALSE 9830
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9698: LD_VAR 0 1
9702: PPUSH
9703: LD_VAR 0 6
9707: PUSH
9708: LD_INT 1
9710: ARRAY
9711: PUSH
9712: LD_INT 1
9714: ARRAY
9715: PPUSH
9716: LD_VAR 0 6
9720: PUSH
9721: LD_INT 1
9723: ARRAY
9724: PUSH
9725: LD_INT 2
9727: ARRAY
9728: PPUSH
9729: CALL_OW 297
9733: PUSH
9734: LD_INT 10
9736: GREATER
9737: PUSH
9738: LD_VAR 0 1
9742: PPUSH
9743: LD_INT 9
9745: PPUSH
9746: CALL_OW 308
9750: NOT
9751: AND
9752: IFFALSE 9791
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9754: LD_VAR 0 1
9758: PPUSH
9759: LD_VAR 0 6
9763: PUSH
9764: LD_INT 1
9766: ARRAY
9767: PUSH
9768: LD_INT 1
9770: ARRAY
9771: PPUSH
9772: LD_VAR 0 6
9776: PUSH
9777: LD_INT 1
9779: ARRAY
9780: PUSH
9781: LD_INT 2
9783: ARRAY
9784: PPUSH
9785: CALL_OW 114
9789: GO 9828
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_INT 9
9798: PPUSH
9799: LD_INT 81
9801: PUSH
9802: LD_INT 6
9804: PUSH
9805: EMPTY
9806: LIST
9807: LIST
9808: PPUSH
9809: CALL_OW 70
9813: PPUSH
9814: LD_VAR 0 1
9818: PPUSH
9819: CALL_OW 74
9823: PPUSH
9824: CALL_OW 115
// end else
9828: GO 9864
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9830: LD_VAR 0 1
9834: PPUSH
9835: LD_INT 81
9837: PUSH
9838: LD_INT 6
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: PPUSH
9845: CALL_OW 69
9849: PPUSH
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 74
9859: PPUSH
9860: CALL_OW 115
// end ;
9864: GO 9584
9866: POP
9867: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9868: LD_INT 22
9870: PUSH
9871: LD_INT 6
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PPUSH
9878: CALL_OW 69
9882: NOT
9883: IFFALSE 9567
// end ; until russianDestroyed ;
9885: LD_EXP 21
9889: IFFALSE 9225
// end ;
9891: PPOPN 6
9893: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9894: LD_EXP 21
9898: NOT
9899: PUSH
9900: LD_EXP 15
9904: PUSH
9905: LD_INT 6
9907: GREATEREQUAL
9908: AND
9909: PUSH
9910: LD_INT 2
9912: PPUSH
9913: LD_INT 1
9915: PPUSH
9916: CALL 59125 0 2
9920: NOT
9921: AND
9922: IFFALSE 10878
9924: GO 9926
9926: DISABLE
9927: LD_INT 0
9929: PPUSH
9930: PPUSH
9931: PPUSH
9932: PPUSH
// begin enable ;
9933: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9934: LD_INT 22
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: LD_INT 30
9946: PUSH
9947: LD_INT 3
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PPUSH
9958: CALL_OW 69
9962: NOT
9963: IFFALSE 9967
// exit ;
9965: GO 10878
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9967: LD_ADDR_VAR 0 4
9971: PUSH
9972: LD_INT 22
9974: PUSH
9975: LD_INT 3
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: LD_INT 30
9984: PUSH
9985: LD_INT 34
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PPUSH
9996: CALL_OW 69
10000: ST_TO_ADDR
// if Prob ( 40 ) then
10001: LD_INT 40
10003: PPUSH
10004: CALL_OW 13
10008: IFFALSE 10135
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10010: LD_INT 2
10012: PPUSH
10013: LD_INT 22
10015: PUSH
10016: LD_INT 3
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: LD_INT 49
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: LD_INT 3
10039: PUSH
10040: LD_INT 49
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: LIST
10048: PUSH
10049: LD_INT 22
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 49
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 46
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 46
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 24
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: LD_INT 46
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL 57707 0 2
// end else
10133: GO 10258
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10135: LD_INT 2
10137: PPUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 47
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 47
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 24
10176: PUSH
10177: LD_INT 3
10179: PUSH
10180: LD_INT 3
10182: PUSH
10183: LD_INT 47
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: PUSH
10192: LD_INT 24
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: LD_INT 46
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_INT 24
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 3
10218: PUSH
10219: LD_INT 46
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 24
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 46
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: LIST
10253: PPUSH
10254: CALL 57707 0 2
// end ; if Difficulty > 1 then
10258: LD_OWVAR 67
10262: PUSH
10263: LD_INT 1
10265: GREATER
10266: IFFALSE 10296
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10268: LD_INT 2
10270: PPUSH
10271: LD_INT 24
10273: PUSH
10274: LD_INT 3
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: LD_INT 47
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: PUSH
10289: EMPTY
10290: LIST
10291: PPUSH
10292: CALL 57707 0 2
// repeat wait ( 0 0$1 ) ;
10296: LD_INT 35
10298: PPUSH
10299: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10303: LD_INT 2
10305: PPUSH
10306: LD_INT 1
10308: PPUSH
10309: CALL 59125 0 2
10313: PUSH
10314: LD_INT 6
10316: PUSH
10317: LD_INT 7
10319: PUSH
10320: LD_INT 7
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: LIST
10327: PUSH
10328: LD_OWVAR 67
10332: ARRAY
10333: GREATEREQUAL
10334: IFFALSE 10296
// wait ( 0 0$30 ) ;
10336: LD_INT 1050
10338: PPUSH
10339: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10343: LD_ADDR_VAR 0 2
10347: PUSH
10348: LD_INT 2
10350: PPUSH
10351: LD_INT 1
10353: PPUSH
10354: CALL 59125 0 2
10358: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10359: LD_ADDR_EXP 118
10363: PUSH
10364: LD_EXP 118
10368: PPUSH
10369: LD_INT 2
10371: PPUSH
10372: LD_EXP 118
10376: PUSH
10377: LD_INT 2
10379: ARRAY
10380: PUSH
10381: LD_VAR 0 2
10385: DIFF
10386: PPUSH
10387: CALL_OW 1
10391: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10392: LD_ADDR_VAR 0 3
10396: PUSH
10397: LD_INT 0
10399: PPUSH
10400: LD_INT 1
10402: PPUSH
10403: CALL_OW 12
10407: ST_TO_ADDR
// if target then
10408: LD_VAR 0 3
10412: IFFALSE 10540
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10414: LD_ADDR_VAR 0 2
10418: PUSH
10419: LD_VAR 0 2
10423: PPUSH
10424: LD_INT 24
10426: PUSH
10427: LD_INT 250
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PPUSH
10434: CALL_OW 72
10438: ST_TO_ADDR
// for i in tmp do
10439: LD_ADDR_VAR 0 1
10443: PUSH
10444: LD_VAR 0 2
10448: PUSH
10449: FOR_IN
10450: IFFALSE 10490
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10452: LD_VAR 0 1
10456: PPUSH
10457: LD_INT 139
10459: PPUSH
10460: LD_INT 89
10462: PPUSH
10463: CALL_OW 297
10467: PUSH
10468: LD_INT 9
10470: GREATER
10471: IFFALSE 10488
// ComMoveXY ( i , 139 , 89 ) ;
10473: LD_VAR 0 1
10477: PPUSH
10478: LD_INT 139
10480: PPUSH
10481: LD_INT 89
10483: PPUSH
10484: CALL_OW 111
10488: GO 10449
10490: POP
10491: POP
// wait ( 0 0$1 ) ;
10492: LD_INT 35
10494: PPUSH
10495: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10499: LD_VAR 0 2
10503: PPUSH
10504: LD_INT 92
10506: PUSH
10507: LD_INT 139
10509: PUSH
10510: LD_INT 89
10512: PUSH
10513: LD_INT 9
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: PPUSH
10522: CALL_OW 72
10526: PUSH
10527: LD_VAR 0 2
10531: PUSH
10532: LD_INT 1
10534: MINUS
10535: GREATEREQUAL
10536: IFFALSE 10414
// end else
10538: GO 10682
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10540: LD_VAR 0 2
10544: PPUSH
10545: LD_VAR 0 4
10549: PUSH
10550: LD_INT 1
10552: ARRAY
10553: PPUSH
10554: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10558: LD_ADDR_VAR 0 2
10562: PUSH
10563: LD_VAR 0 2
10567: PPUSH
10568: LD_INT 24
10570: PUSH
10571: LD_INT 250
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PPUSH
10578: CALL_OW 72
10582: ST_TO_ADDR
// for i in tmp do
10583: LD_ADDR_VAR 0 1
10587: PUSH
10588: LD_VAR 0 2
10592: PUSH
10593: FOR_IN
10594: IFFALSE 10634
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10596: LD_VAR 0 1
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 139
10606: PPUSH
10607: CALL_OW 297
10611: PUSH
10612: LD_INT 9
10614: GREATER
10615: IFFALSE 10632
// ComMoveXY ( i , 124 , 139 ) ;
10617: LD_VAR 0 1
10621: PPUSH
10622: LD_INT 124
10624: PPUSH
10625: LD_INT 139
10627: PPUSH
10628: CALL_OW 111
10632: GO 10593
10634: POP
10635: POP
// wait ( 0 0$1 ) ;
10636: LD_INT 35
10638: PPUSH
10639: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10643: LD_VAR 0 2
10647: PPUSH
10648: LD_INT 92
10650: PUSH
10651: LD_INT 124
10653: PUSH
10654: LD_INT 139
10656: PUSH
10657: LD_INT 9
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 72
10670: PUSH
10671: LD_VAR 0 2
10675: PUSH
10676: LD_INT 1
10678: MINUS
10679: GREATEREQUAL
10680: IFFALSE 10558
// end ; repeat wait ( 0 0$1 ) ;
10682: LD_INT 35
10684: PPUSH
10685: CALL_OW 67
// for i in tmp do
10689: LD_ADDR_VAR 0 1
10693: PUSH
10694: LD_VAR 0 2
10698: PUSH
10699: FOR_IN
10700: IFFALSE 10869
// begin if GetLives ( i ) > 251 then
10702: LD_VAR 0 1
10706: PPUSH
10707: CALL_OW 256
10711: PUSH
10712: LD_INT 251
10714: GREATER
10715: IFFALSE 10840
// begin if GetWeapon ( i ) = ru_time_lapser then
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 264
10726: PUSH
10727: LD_INT 49
10729: EQUAL
10730: IFFALSE 10786
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10732: LD_VAR 0 1
10736: PPUSH
10737: LD_INT 2
10739: PUSH
10740: LD_INT 22
10742: PUSH
10743: LD_INT 1
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 22
10752: PUSH
10753: LD_INT 8
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PPUSH
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 74
10779: PPUSH
10780: CALL_OW 112
10784: GO 10838
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10786: LD_VAR 0 1
10790: PPUSH
10791: LD_INT 2
10793: PUSH
10794: LD_INT 22
10796: PUSH
10797: LD_INT 1
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PUSH
10804: LD_INT 22
10806: PUSH
10807: LD_INT 8
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: LIST
10818: PPUSH
10819: CALL_OW 69
10823: PPUSH
10824: LD_VAR 0 1
10828: PPUSH
10829: CALL_OW 74
10833: PPUSH
10834: CALL_OW 115
// end else
10838: GO 10867
// if IsDead ( i ) then
10840: LD_VAR 0 1
10844: PPUSH
10845: CALL_OW 301
10849: IFFALSE 10867
// tmp := tmp diff i ;
10851: LD_ADDR_VAR 0 2
10855: PUSH
10856: LD_VAR 0 2
10860: PUSH
10861: LD_VAR 0 1
10865: DIFF
10866: ST_TO_ADDR
// end ;
10867: GO 10699
10869: POP
10870: POP
// until not tmp ;
10871: LD_VAR 0 2
10875: NOT
10876: IFFALSE 10682
// end ; end_of_file
10878: PPOPN 4
10880: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10881: LD_INT 0
10883: PPUSH
10884: PPUSH
10885: PPUSH
10886: PPUSH
10887: PPUSH
10888: PPUSH
// side := 7 ;
10889: LD_ADDR_VAR 0 5
10893: PUSH
10894: LD_INT 7
10896: ST_TO_ADDR
// uc_side := side ;
10897: LD_ADDR_OWVAR 20
10901: PUSH
10902: LD_VAR 0 5
10906: ST_TO_ADDR
// uc_nation := 1 ;
10907: LD_ADDR_OWVAR 21
10911: PUSH
10912: LD_INT 1
10914: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10915: LD_ADDR_VAR 0 2
10919: PUSH
10920: LD_INT 22
10922: PUSH
10923: LD_VAR 0 5
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 21
10934: PUSH
10935: LD_INT 3
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 69
10950: PUSH
10951: FOR_IN
10952: IFFALSE 10968
// SetBLevel ( i , 10 ) ;
10954: LD_VAR 0 2
10958: PPUSH
10959: LD_INT 10
10961: PPUSH
10962: CALL_OW 241
10966: GO 10951
10968: POP
10969: POP
// base := GetBase ( al_depot ) ;
10970: LD_ADDR_VAR 0 4
10974: PUSH
10975: LD_INT 2
10977: PPUSH
10978: CALL_OW 274
10982: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10983: LD_ADDR_VAR 0 6
10987: PUSH
10988: LD_INT 22
10990: PUSH
10991: LD_VAR 0 5
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PUSH
11000: LD_INT 30
11002: PUSH
11003: LD_INT 34
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: EMPTY
11011: LIST
11012: LIST
11013: PPUSH
11014: CALL_OW 69
11018: ST_TO_ADDR
// if teleport then
11019: LD_VAR 0 6
11023: IFFALSE 11044
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11025: LD_VAR 0 6
11029: PUSH
11030: LD_INT 1
11032: ARRAY
11033: PPUSH
11034: LD_INT 262
11036: PPUSH
11037: LD_INT 119
11039: PPUSH
11040: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11044: LD_VAR 0 4
11048: PPUSH
11049: LD_INT 1
11051: PPUSH
11052: LD_INT 19500
11054: PPUSH
11055: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11059: LD_VAR 0 4
11063: PPUSH
11064: LD_INT 2
11066: PPUSH
11067: LD_INT 200
11069: PPUSH
11070: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11074: LD_VAR 0 4
11078: PPUSH
11079: LD_INT 3
11081: PPUSH
11082: LD_INT 650
11084: PPUSH
11085: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11089: LD_ADDR_EXP 71
11093: PUSH
11094: LD_STRING Roth
11096: PPUSH
11097: CALL_OW 25
11101: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11102: LD_ADDR_EXP 72
11106: PUSH
11107: LD_STRING Simms
11109: PPUSH
11110: LD_EXP 1
11114: NOT
11115: PPUSH
11116: LD_STRING 10c_
11118: PPUSH
11119: CALL 64051 0 3
11123: ST_TO_ADDR
// if not Simms then
11124: LD_EXP 72
11128: NOT
11129: IFFALSE 11159
// begin uc_nation := 1 ;
11131: LD_ADDR_OWVAR 21
11135: PUSH
11136: LD_INT 1
11138: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11139: LD_INT 2
11141: PPUSH
11142: LD_INT 10
11144: PPUSH
11145: CALL_OW 384
// Simms := CreateHuman ;
11149: LD_ADDR_EXP 72
11153: PUSH
11154: CALL_OW 44
11158: ST_TO_ADDR
// end ; uc_nation := 3 ;
11159: LD_ADDR_OWVAR 21
11163: PUSH
11164: LD_INT 3
11166: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11167: LD_ADDR_EXP 73
11171: PUSH
11172: LD_STRING Kirilenkova
11174: PPUSH
11175: CALL_OW 25
11179: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11180: LD_ADDR_EXP 87
11184: PUSH
11185: LD_STRING Oblukov
11187: PPUSH
11188: CALL_OW 25
11192: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11193: LD_ADDR_EXP 74
11197: PUSH
11198: LD_STRING Dolgov
11200: PPUSH
11201: CALL_OW 25
11205: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11206: LD_ADDR_EXP 75
11210: PUSH
11211: LD_STRING Petrosyan
11213: PPUSH
11214: CALL_OW 25
11218: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11219: LD_ADDR_EXP 86
11223: PUSH
11224: LD_STRING Scholtze
11226: PPUSH
11227: CALL_OW 25
11231: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11232: LD_ADDR_EXP 85
11236: PUSH
11237: LD_STRING Kapitsova
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11245: LD_ADDR_EXP 76
11249: PUSH
11250: LD_STRING Petrovova
11252: PPUSH
11253: CALL_OW 25
11257: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11258: LD_ADDR_EXP 77
11262: PUSH
11263: LD_STRING Kuzmov
11265: PPUSH
11266: CALL_OW 25
11270: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11271: LD_ADDR_EXP 84
11275: PUSH
11276: LD_STRING Karamazov
11278: PPUSH
11279: CALL_OW 25
11283: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11284: LD_STRING 13_Lipshchin_1
11286: PPUSH
11287: LD_INT 0
11289: PPUSH
11290: CALL_OW 30
11294: IFFALSE 11309
// Lipshchin := NewCharacter ( Lipshchin ) ;
11296: LD_ADDR_EXP 78
11300: PUSH
11301: LD_STRING Lipshchin
11303: PPUSH
11304: CALL_OW 25
11308: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11309: LD_STRING 13_Titov_1
11311: PPUSH
11312: LD_INT 0
11314: PPUSH
11315: CALL_OW 30
11319: IFFALSE 11334
// Titov := NewCharacter ( Titov ) ;
11321: LD_ADDR_EXP 80
11325: PUSH
11326: LD_STRING Titov
11328: PPUSH
11329: CALL_OW 25
11333: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11334: LD_STRING 13_Gnyevko_1
11336: PPUSH
11337: LD_INT 0
11339: PPUSH
11340: CALL_OW 30
11344: IFFALSE 11359
// Gnyevko := NewCharacter ( Gnyevko ) ;
11346: LD_ADDR_EXP 79
11350: PUSH
11351: LD_STRING Gnyevko
11353: PPUSH
11354: CALL_OW 25
11358: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11359: LD_STRING 13_Xavier_1
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL_OW 30
11369: IFFALSE 11384
// Xavier := NewCharacter ( Xavier2 ) ;
11371: LD_ADDR_EXP 81
11375: PUSH
11376: LD_STRING Xavier2
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11384: LD_STRING 13_Belkov_1
11386: PPUSH
11387: LD_INT 0
11389: PPUSH
11390: CALL_OW 30
11394: IFFALSE 11409
// Belkov := NewCharacter ( Belkov ) ;
11396: LD_ADDR_EXP 82
11400: PUSH
11401: LD_STRING Belkov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// if not BurlakStatus then
11409: LD_EXP 9
11413: NOT
11414: IFFALSE 11429
// Burlak = NewCharacter ( Burlak ) ;
11416: LD_ADDR_EXP 83
11420: PUSH
11421: LD_STRING Burlak
11423: PPUSH
11424: CALL_OW 25
11428: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11429: LD_ADDR_VAR 0 3
11433: PUSH
11434: LD_EXP 71
11438: PUSH
11439: LD_EXP 73
11443: PUSH
11444: LD_EXP 87
11448: PUSH
11449: LD_EXP 74
11453: PUSH
11454: LD_EXP 75
11458: PUSH
11459: LD_EXP 86
11463: PUSH
11464: LD_EXP 85
11468: PUSH
11469: LD_EXP 76
11473: PUSH
11474: LD_EXP 77
11478: PUSH
11479: LD_EXP 84
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: ST_TO_ADDR
// if Simms then
11496: LD_EXP 72
11500: IFFALSE 11518
// tmp := tmp ^ Simms ;
11502: LD_ADDR_VAR 0 3
11506: PUSH
11507: LD_VAR 0 3
11511: PUSH
11512: LD_EXP 72
11516: ADD
11517: ST_TO_ADDR
// if Titov then
11518: LD_EXP 80
11522: IFFALSE 11540
// tmp := tmp ^ Titov ;
11524: LD_ADDR_VAR 0 3
11528: PUSH
11529: LD_VAR 0 3
11533: PUSH
11534: LD_EXP 80
11538: ADD
11539: ST_TO_ADDR
// if Lipshchin then
11540: LD_EXP 78
11544: IFFALSE 11562
// tmp := tmp ^ Lipshchin ;
11546: LD_ADDR_VAR 0 3
11550: PUSH
11551: LD_VAR 0 3
11555: PUSH
11556: LD_EXP 78
11560: ADD
11561: ST_TO_ADDR
// if Gnyevko then
11562: LD_EXP 79
11566: IFFALSE 11584
// tmp := tmp ^ Gnyevko ;
11568: LD_ADDR_VAR 0 3
11572: PUSH
11573: LD_VAR 0 3
11577: PUSH
11578: LD_EXP 79
11582: ADD
11583: ST_TO_ADDR
// if Xavier then
11584: LD_EXP 81
11588: IFFALSE 11606
// tmp := tmp ^ Xavier ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_VAR 0 3
11599: PUSH
11600: LD_EXP 81
11604: ADD
11605: ST_TO_ADDR
// if Belkov then
11606: LD_EXP 82
11610: IFFALSE 11628
// tmp := tmp ^ Belkov ;
11612: LD_ADDR_VAR 0 3
11616: PUSH
11617: LD_VAR 0 3
11621: PUSH
11622: LD_EXP 82
11626: ADD
11627: ST_TO_ADDR
// if Burlak then
11628: LD_EXP 83
11632: IFFALSE 11650
// tmp := tmp ^ Burlak ;
11634: LD_ADDR_VAR 0 3
11638: PUSH
11639: LD_VAR 0 3
11643: PUSH
11644: LD_EXP 83
11648: ADD
11649: ST_TO_ADDR
// for i = 1 to 8 do
11650: LD_ADDR_VAR 0 2
11654: PUSH
11655: DOUBLE
11656: LD_INT 1
11658: DEC
11659: ST_TO_ADDR
11660: LD_INT 8
11662: PUSH
11663: FOR_TO
11664: IFFALSE 11730
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11666: LD_ADDR_OWVAR 21
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: LD_INT 3
11676: PUSH
11677: EMPTY
11678: LIST
11679: LIST
11680: PUSH
11681: LD_INT 1
11683: PPUSH
11684: LD_INT 2
11686: PPUSH
11687: CALL_OW 12
11691: ARRAY
11692: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11693: LD_INT 0
11695: PPUSH
11696: LD_VAR 0 2
11700: PUSH
11701: LD_INT 2
11703: DIV
11704: PPUSH
11705: LD_INT 10
11707: PPUSH
11708: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11712: LD_ADDR_VAR 0 3
11716: PUSH
11717: LD_VAR 0 3
11721: PUSH
11722: CALL_OW 44
11726: ADD
11727: ST_TO_ADDR
// end ;
11728: GO 11663
11730: POP
11731: POP
// for i in tmp do
11732: LD_ADDR_VAR 0 2
11736: PUSH
11737: LD_VAR 0 3
11741: PUSH
11742: FOR_IN
11743: IFFALSE 11768
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11745: LD_VAR 0 2
11749: PPUSH
11750: LD_INT 260
11752: PPUSH
11753: LD_INT 235
11755: PPUSH
11756: LD_INT 8
11758: PPUSH
11759: LD_INT 0
11761: PPUSH
11762: CALL_OW 50
11766: GO 11742
11768: POP
11769: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11770: LD_ADDR_EXP 99
11774: PUSH
11775: LD_EXP 99
11779: PPUSH
11780: LD_INT 1
11782: PPUSH
11783: LD_INT 22
11785: PUSH
11786: LD_VAR 0 5
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: LD_INT 3
11797: PUSH
11798: LD_INT 21
11800: PUSH
11801: LD_INT 2
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PPUSH
11816: CALL_OW 69
11820: PUSH
11821: LD_EXP 71
11825: PUSH
11826: LD_EXP 72
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: DIFF
11835: PPUSH
11836: CALL_OW 1
11840: ST_TO_ADDR
// uc_side := 0 ;
11841: LD_ADDR_OWVAR 20
11845: PUSH
11846: LD_INT 0
11848: ST_TO_ADDR
// uc_nation := 0 ;
11849: LD_ADDR_OWVAR 21
11853: PUSH
11854: LD_INT 0
11856: ST_TO_ADDR
// for i = 1 to 5 do
11857: LD_ADDR_VAR 0 2
11861: PUSH
11862: DOUBLE
11863: LD_INT 1
11865: DEC
11866: ST_TO_ADDR
11867: LD_INT 5
11869: PUSH
11870: FOR_TO
11871: IFFALSE 11908
// begin InitHc ;
11873: CALL_OW 19
// hc_class := class_apeman ;
11877: LD_ADDR_OWVAR 28
11881: PUSH
11882: LD_INT 12
11884: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11885: CALL_OW 44
11889: PPUSH
11890: LD_INT 299
11892: PPUSH
11893: LD_INT 229
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: LD_INT 0
11901: PPUSH
11902: CALL_OW 50
// end ;
11906: GO 11870
11908: POP
11909: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11910: LD_EXP 71
11914: PPUSH
11915: LD_INT 259
11917: PPUSH
11918: LD_INT 235
11920: PPUSH
11921: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11925: LD_EXP 71
11929: PPUSH
11930: LD_INT 262
11932: PPUSH
11933: LD_INT 235
11935: PPUSH
11936: CALL_OW 178
// if Simms then
11940: LD_EXP 72
11944: IFFALSE 11975
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11946: LD_EXP 72
11950: PPUSH
11951: LD_INT 262
11953: PPUSH
11954: LD_INT 235
11956: PPUSH
11957: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11961: LD_EXP 72
11965: PPUSH
11966: LD_EXP 71
11970: PPUSH
11971: CALL_OW 179
// end ; end ;
11975: LD_VAR 0 1
11979: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11980: LD_EXP 31
11984: PUSH
11985: LD_EXP 23
11989: NOT
11990: AND
11991: IFFALSE 12167
11993: GO 11995
11995: DISABLE
11996: LD_INT 0
11998: PPUSH
11999: PPUSH
12000: PPUSH
// begin enable ;
12001: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12002: LD_ADDR_VAR 0 2
12006: PUSH
12007: LD_INT 81
12009: PUSH
12010: LD_INT 7
12012: PUSH
12013: EMPTY
12014: LIST
12015: LIST
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: LD_INT 32
12022: PUSH
12023: LD_INT 3
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: LD_INT 30
12032: PUSH
12033: LD_INT 30
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 30
12042: PUSH
12043: LD_INT 28
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 34
12052: PUSH
12053: LD_INT 49
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: LD_INT 34
12062: PUSH
12063: LD_INT 10
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 34
12072: PUSH
12073: LD_INT 8
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PPUSH
12093: CALL_OW 69
12097: ST_TO_ADDR
// if not tmp then
12098: LD_VAR 0 2
12102: NOT
12103: IFFALSE 12107
// exit ;
12105: GO 12167
// target := tmp [ rand ( 1 , tmp ) ] ;
12107: LD_ADDR_VAR 0 3
12111: PUSH
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 1
12119: PPUSH
12120: LD_VAR 0 2
12124: PPUSH
12125: CALL_OW 12
12129: ARRAY
12130: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12131: LD_VAR 0 3
12135: PPUSH
12136: CALL_OW 255
12140: PUSH
12141: LD_INT 1
12143: EQUAL
12144: IFFALSE 12155
// CenterNowOnUnits ( target ) ;
12146: LD_VAR 0 3
12150: PPUSH
12151: CALL_OW 87
// SetLives ( target , 0 ) ;
12155: LD_VAR 0 3
12159: PPUSH
12160: LD_INT 0
12162: PPUSH
12163: CALL_OW 234
// end ;
12167: PPOPN 3
12169: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12170: LD_EXP 23
12174: NOT
12175: PUSH
12176: LD_EXP 31
12180: AND
12181: IFFALSE 12703
12183: GO 12185
12185: DISABLE
12186: LD_INT 0
12188: PPUSH
12189: PPUSH
12190: PPUSH
// begin uc_side := 7 ;
12191: LD_ADDR_OWVAR 20
12195: PUSH
12196: LD_INT 7
12198: ST_TO_ADDR
// uc_nation := 1 ;
12199: LD_ADDR_OWVAR 21
12203: PUSH
12204: LD_INT 1
12206: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12207: LD_ADDR_VAR 0 3
12211: PUSH
12212: LD_INT 125
12214: PUSH
12215: LD_INT 163
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 185
12224: PUSH
12225: LD_INT 168
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 111
12234: PUSH
12235: LD_INT 97
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: PPUSH
12247: CALL 106914 0 1
12251: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12252: LD_ADDR_EXP 88
12256: PUSH
12257: EMPTY
12258: ST_TO_ADDR
// for i = 1 to Difficulty do
12259: LD_ADDR_VAR 0 1
12263: PUSH
12264: DOUBLE
12265: LD_INT 1
12267: DEC
12268: ST_TO_ADDR
12269: LD_OWVAR 67
12273: PUSH
12274: FOR_TO
12275: IFFALSE 12433
// begin InitHc ;
12277: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12281: LD_INT 0
12283: PPUSH
12284: LD_INT 8
12286: PPUSH
12287: CALL_OW 381
// un := CreateHuman ;
12291: LD_ADDR_VAR 0 2
12295: PUSH
12296: CALL_OW 44
12300: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12301: LD_VAR 0 2
12305: PPUSH
12306: LD_INT 258
12308: PPUSH
12309: LD_INT 267
12311: PPUSH
12312: LD_INT 4
12314: PPUSH
12315: LD_INT 0
12317: PPUSH
12318: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12322: LD_ADDR_EXP 88
12326: PUSH
12327: LD_EXP 88
12331: PUSH
12332: LD_VAR 0 2
12336: UNION
12337: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12338: LD_VAR 0 2
12342: PPUSH
12343: LD_VAR 0 3
12347: PUSH
12348: LD_VAR 0 1
12352: ARRAY
12353: PUSH
12354: LD_INT 1
12356: ARRAY
12357: PPUSH
12358: LD_VAR 0 3
12362: PUSH
12363: LD_VAR 0 1
12367: ARRAY
12368: PUSH
12369: LD_INT 2
12371: ARRAY
12372: PPUSH
12373: LD_INT 4
12375: PPUSH
12376: LD_INT 1
12378: PPUSH
12379: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12383: LD_VAR 0 2
12387: PPUSH
12388: LD_VAR 0 3
12392: PUSH
12393: LD_VAR 0 1
12397: ARRAY
12398: PUSH
12399: LD_INT 1
12401: ARRAY
12402: PPUSH
12403: LD_VAR 0 3
12407: PUSH
12408: LD_VAR 0 1
12412: ARRAY
12413: PUSH
12414: LD_INT 2
12416: ARRAY
12417: PPUSH
12418: CALL_OW 171
// AddComInvisible ( un ) ;
12422: LD_VAR 0 2
12426: PPUSH
12427: CALL_OW 212
// end ;
12431: GO 12274
12433: POP
12434: POP
// repeat wait ( 0 0$20 ) ;
12435: LD_INT 700
12437: PPUSH
12438: CALL_OW 67
// for i in allianceSpecialForce do
12442: LD_ADDR_VAR 0 1
12446: PUSH
12447: LD_EXP 88
12451: PUSH
12452: FOR_IN
12453: IFFALSE 12688
// begin if IsInvisible ( i ) then
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 571
12464: IFFALSE 12657
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12466: LD_ADDR_VAR 0 3
12470: PUSH
12471: LD_INT 22
12473: PUSH
12474: LD_INT 1
12476: PUSH
12477: EMPTY
12478: LIST
12479: LIST
12480: PUSH
12481: LD_INT 50
12483: PUSH
12484: EMPTY
12485: LIST
12486: PUSH
12487: LD_INT 56
12489: PUSH
12490: EMPTY
12491: LIST
12492: PUSH
12493: LD_INT 91
12495: PUSH
12496: LD_VAR 0 1
12500: PUSH
12501: LD_INT 25
12503: PUSH
12504: LD_INT 30
12506: PUSH
12507: LD_INT 35
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: LIST
12514: PUSH
12515: LD_OWVAR 67
12519: ARRAY
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 2
12528: PUSH
12529: LD_INT 25
12531: PUSH
12532: LD_INT 1
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 2
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 3
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 25
12561: PUSH
12562: LD_INT 4
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 25
12571: PUSH
12572: LD_INT 5
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 8
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: LIST
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: PPUSH
12605: CALL_OW 69
12609: ST_TO_ADDR
// if not tmp then
12610: LD_VAR 0 3
12614: NOT
12615: IFFALSE 12619
// continue ;
12617: GO 12452
// if Prob ( 30 * Difficulty ) then
12619: LD_INT 30
12621: PUSH
12622: LD_OWVAR 67
12626: MUL
12627: PPUSH
12628: CALL_OW 13
12632: IFFALSE 12657
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12634: LD_VAR 0 3
12638: PUSH
12639: LD_INT 1
12641: PPUSH
12642: LD_VAR 0 3
12646: PPUSH
12647: CALL_OW 12
12651: ARRAY
12652: PPUSH
12653: CALL 30114 0 1
// end ; if IsDead ( i ) then
12657: LD_VAR 0 1
12661: PPUSH
12662: CALL_OW 301
12666: IFFALSE 12686
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12668: LD_ADDR_EXP 88
12672: PUSH
12673: LD_EXP 88
12677: PUSH
12678: LD_VAR 0 1
12682: DIFF
12683: ST_TO_ADDR
// continue ;
12684: GO 12452
// end ; end ;
12686: GO 12452
12688: POP
12689: POP
// until allianceDestroyed or not allianceSpecialForce ;
12690: LD_EXP 23
12694: PUSH
12695: LD_EXP 88
12699: NOT
12700: OR
12701: IFFALSE 12435
// end ;
12703: PPOPN 3
12705: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12706: LD_EXP 23
12710: NOT
12711: PUSH
12712: LD_EXP 31
12716: AND
12717: PUSH
12718: LD_INT 1
12720: PPUSH
12721: LD_INT 1
12723: PPUSH
12724: CALL 59125 0 2
12728: NOT
12729: AND
12730: IFFALSE 13697
12732: GO 12734
12734: DISABLE
12735: LD_INT 0
12737: PPUSH
12738: PPUSH
12739: PPUSH
12740: PPUSH
// begin enable ;
12741: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12742: LD_INT 22
12744: PUSH
12745: LD_INT 7
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: LD_INT 30
12754: PUSH
12755: LD_INT 3
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PPUSH
12766: CALL_OW 69
12770: NOT
12771: IFFALSE 12775
// exit ;
12773: GO 13697
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12775: LD_ADDR_VAR 0 4
12779: PUSH
12780: LD_INT 22
12782: PUSH
12783: LD_INT 7
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 30
12792: PUSH
12793: LD_INT 34
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PPUSH
12804: CALL_OW 69
12808: ST_TO_ADDR
// if Prob ( 40 ) then
12809: LD_INT 40
12811: PPUSH
12812: CALL_OW 13
12816: IFFALSE 12943
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12818: LD_INT 1
12820: PPUSH
12821: LD_INT 5
12823: PUSH
12824: LD_INT 3
12826: PUSH
12827: LD_INT 2
12829: PUSH
12830: LD_INT 6
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: PUSH
12839: LD_INT 5
12841: PUSH
12842: LD_INT 3
12844: PUSH
12845: LD_INT 2
12847: PUSH
12848: LD_INT 6
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: LIST
12855: LIST
12856: PUSH
12857: LD_INT 5
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 2
12865: PUSH
12866: LD_INT 6
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 24
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: LD_INT 45
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PUSH
12893: LD_INT 24
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: LD_INT 3
12901: PUSH
12902: LD_INT 47
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: PUSH
12911: LD_INT 24
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 3
12919: PUSH
12920: LD_INT 45
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: PPUSH
12937: CALL 57707 0 2
// end else
12941: GO 13066
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 24
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: LD_INT 3
12954: PUSH
12955: LD_INT 47
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 24
12966: PUSH
12967: LD_INT 3
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 47
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 5
12984: PUSH
12985: LD_INT 3
12987: PUSH
12988: LD_INT 2
12990: PUSH
12991: LD_INT 9
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: PUSH
13000: LD_INT 5
13002: PUSH
13003: LD_INT 3
13005: PUSH
13006: LD_INT 2
13008: PUSH
13009: LD_INT 9
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: PUSH
13018: LD_INT 24
13020: PUSH
13021: LD_INT 1
13023: PUSH
13024: LD_INT 3
13026: PUSH
13027: LD_INT 45
13029: PUSH
13030: EMPTY
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: PUSH
13036: LD_INT 24
13038: PUSH
13039: LD_INT 1
13041: PUSH
13042: LD_INT 3
13044: PUSH
13045: LD_INT 45
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: PPUSH
13062: CALL 57707 0 2
// end ; if Difficulty > 1 then
13066: LD_OWVAR 67
13070: PUSH
13071: LD_INT 1
13073: GREATER
13074: IFFALSE 13104
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13076: LD_INT 1
13078: PPUSH
13079: LD_INT 24
13081: PUSH
13082: LD_INT 3
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: LD_INT 47
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: PUSH
13097: EMPTY
13098: LIST
13099: PPUSH
13100: CALL 57707 0 2
// repeat wait ( 0 0$1 ) ;
13104: LD_INT 35
13106: PPUSH
13107: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13111: LD_INT 1
13113: PPUSH
13114: LD_INT 1
13116: PPUSH
13117: CALL 59125 0 2
13121: PUSH
13122: LD_INT 6
13124: PUSH
13125: LD_INT 7
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_OWVAR 67
13140: ARRAY
13141: GREATEREQUAL
13142: IFFALSE 13104
// wait ( 0 0$40 ) ;
13144: LD_INT 1400
13146: PPUSH
13147: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13151: LD_ADDR_VAR 0 2
13155: PUSH
13156: LD_INT 1
13158: PPUSH
13159: LD_INT 1
13161: PPUSH
13162: CALL 59125 0 2
13166: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13167: LD_ADDR_EXP 118
13171: PUSH
13172: LD_EXP 118
13176: PPUSH
13177: LD_INT 1
13179: PPUSH
13180: LD_EXP 118
13184: PUSH
13185: LD_INT 1
13187: ARRAY
13188: PUSH
13189: LD_VAR 0 2
13193: DIFF
13194: PPUSH
13195: CALL_OW 1
13199: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13200: LD_ADDR_VAR 0 3
13204: PUSH
13205: LD_INT 0
13207: PPUSH
13208: LD_INT 1
13210: PPUSH
13211: CALL_OW 12
13215: ST_TO_ADDR
// if target then
13216: LD_VAR 0 3
13220: IFFALSE 13386
// begin for i in tmp do
13222: LD_ADDR_VAR 0 1
13226: PUSH
13227: LD_VAR 0 2
13231: PUSH
13232: FOR_IN
13233: IFFALSE 13258
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13235: LD_VAR 0 1
13239: PPUSH
13240: LD_INT 179
13242: PPUSH
13243: LD_INT 209
13245: PPUSH
13246: LD_INT 8
13248: PPUSH
13249: LD_INT 1
13251: PPUSH
13252: CALL_OW 483
13256: GO 13232
13258: POP
13259: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13260: LD_ADDR_VAR 0 2
13264: PUSH
13265: LD_VAR 0 2
13269: PPUSH
13270: LD_INT 24
13272: PUSH
13273: LD_INT 250
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: PPUSH
13280: CALL_OW 72
13284: ST_TO_ADDR
// for i in tmp do
13285: LD_ADDR_VAR 0 1
13289: PUSH
13290: LD_VAR 0 2
13294: PUSH
13295: FOR_IN
13296: IFFALSE 13336
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13298: LD_VAR 0 1
13302: PPUSH
13303: LD_INT 179
13305: PPUSH
13306: LD_INT 209
13308: PPUSH
13309: CALL_OW 297
13313: PUSH
13314: LD_INT 9
13316: GREATER
13317: IFFALSE 13334
// ComMoveXY ( i , 179 , 209 ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: LD_INT 179
13326: PPUSH
13327: LD_INT 209
13329: PPUSH
13330: CALL_OW 111
13334: GO 13295
13336: POP
13337: POP
// wait ( 0 0$1 ) ;
13338: LD_INT 35
13340: PPUSH
13341: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13345: LD_VAR 0 2
13349: PPUSH
13350: LD_INT 92
13352: PUSH
13353: LD_INT 179
13355: PUSH
13356: LD_INT 209
13358: PUSH
13359: LD_INT 9
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: PPUSH
13368: CALL_OW 72
13372: PUSH
13373: LD_VAR 0 2
13377: PUSH
13378: LD_INT 1
13380: MINUS
13381: GREATEREQUAL
13382: IFFALSE 13260
// end else
13384: GO 13548
// begin for i in tmp do
13386: LD_ADDR_VAR 0 1
13390: PUSH
13391: LD_VAR 0 2
13395: PUSH
13396: FOR_IN
13397: IFFALSE 13422
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13399: LD_VAR 0 1
13403: PPUSH
13404: LD_INT 285
13406: PPUSH
13407: LD_INT 163
13409: PPUSH
13410: LD_INT 8
13412: PPUSH
13413: LD_INT 1
13415: PPUSH
13416: CALL_OW 483
13420: GO 13396
13422: POP
13423: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13424: LD_ADDR_VAR 0 2
13428: PUSH
13429: LD_VAR 0 2
13433: PPUSH
13434: LD_INT 24
13436: PUSH
13437: LD_INT 250
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PPUSH
13444: CALL_OW 72
13448: ST_TO_ADDR
// for i in tmp do
13449: LD_ADDR_VAR 0 1
13453: PUSH
13454: LD_VAR 0 2
13458: PUSH
13459: FOR_IN
13460: IFFALSE 13500
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13462: LD_VAR 0 1
13466: PPUSH
13467: LD_INT 285
13469: PPUSH
13470: LD_INT 163
13472: PPUSH
13473: CALL_OW 297
13477: PUSH
13478: LD_INT 9
13480: GREATER
13481: IFFALSE 13498
// ComMoveXY ( i , 285 , 163 ) ;
13483: LD_VAR 0 1
13487: PPUSH
13488: LD_INT 285
13490: PPUSH
13491: LD_INT 163
13493: PPUSH
13494: CALL_OW 111
13498: GO 13459
13500: POP
13501: POP
// wait ( 0 0$1 ) ;
13502: LD_INT 35
13504: PPUSH
13505: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13509: LD_VAR 0 2
13513: PPUSH
13514: LD_INT 92
13516: PUSH
13517: LD_INT 285
13519: PUSH
13520: LD_INT 163
13522: PUSH
13523: LD_INT 9
13525: PUSH
13526: EMPTY
13527: LIST
13528: LIST
13529: LIST
13530: LIST
13531: PPUSH
13532: CALL_OW 72
13536: PUSH
13537: LD_VAR 0 2
13541: PUSH
13542: LD_INT 1
13544: MINUS
13545: GREATEREQUAL
13546: IFFALSE 13424
// end ; repeat wait ( 0 0$1 ) ;
13548: LD_INT 35
13550: PPUSH
13551: CALL_OW 67
// for i in tmp do
13555: LD_ADDR_VAR 0 1
13559: PUSH
13560: LD_VAR 0 2
13564: PUSH
13565: FOR_IN
13566: IFFALSE 13688
// if GetLives ( i ) > 251 then
13568: LD_VAR 0 1
13572: PPUSH
13573: CALL_OW 256
13577: PUSH
13578: LD_INT 251
13580: GREATER
13581: IFFALSE 13670
// begin if GetWeapon ( i ) = ru_time_lapser then
13583: LD_VAR 0 1
13587: PPUSH
13588: CALL_OW 264
13592: PUSH
13593: LD_INT 49
13595: EQUAL
13596: IFFALSE 13634
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13598: LD_VAR 0 1
13602: PPUSH
13603: LD_INT 81
13605: PUSH
13606: LD_INT 7
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PPUSH
13613: CALL_OW 69
13617: PPUSH
13618: LD_VAR 0 1
13622: PPUSH
13623: CALL_OW 74
13627: PPUSH
13628: CALL_OW 112
13632: GO 13668
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13634: LD_VAR 0 1
13638: PPUSH
13639: LD_INT 81
13641: PUSH
13642: LD_INT 7
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 69
13653: PPUSH
13654: LD_VAR 0 1
13658: PPUSH
13659: CALL_OW 74
13663: PPUSH
13664: CALL_OW 115
// end else
13668: GO 13686
// tmp := tmp diff i ;
13670: LD_ADDR_VAR 0 2
13674: PUSH
13675: LD_VAR 0 2
13679: PUSH
13680: LD_VAR 0 1
13684: DIFF
13685: ST_TO_ADDR
13686: GO 13565
13688: POP
13689: POP
// until not tmp ;
13690: LD_VAR 0 2
13694: NOT
13695: IFFALSE 13548
// end ; end_of_file
13697: PPOPN 4
13699: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13700: LD_INT 0
13702: PPUSH
13703: PPUSH
13704: PPUSH
13705: PPUSH
// missionStage := 13 ;
13706: LD_ADDR_EXP 15
13710: PUSH
13711: LD_INT 13
13713: ST_TO_ADDR
// uc_side := 2 ;
13714: LD_ADDR_OWVAR 20
13718: PUSH
13719: LD_INT 2
13721: ST_TO_ADDR
// uc_nation := 2 ;
13722: LD_ADDR_OWVAR 21
13726: PUSH
13727: LD_INT 2
13729: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13730: LD_ADDR_EXP 89
13734: PUSH
13735: LD_STRING Omar
13737: PPUSH
13738: CALL_OW 25
13742: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13743: LD_EXP 89
13747: PPUSH
13748: LD_INT 4
13750: PPUSH
13751: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13755: LD_EXP 89
13759: PPUSH
13760: LD_INT 242
13762: PPUSH
13763: LD_INT 75
13765: PPUSH
13766: LD_INT 0
13768: PPUSH
13769: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13773: LD_ADDR_EXP 90
13777: PUSH
13778: LD_STRING Heike
13780: PPUSH
13781: CALL_OW 25
13785: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13786: LD_INT 14
13788: PPUSH
13789: LD_INT 3
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: LD_INT 27
13797: PPUSH
13798: LD_INT 100
13800: PPUSH
13801: CALL 71077 0 5
// veh := CreateVehicle ;
13805: LD_ADDR_VAR 0 3
13809: PUSH
13810: CALL_OW 45
13814: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13815: LD_VAR 0 3
13819: PPUSH
13820: LD_INT 1
13822: PPUSH
13823: CALL_OW 242
// SetDir ( veh , 4 ) ;
13827: LD_VAR 0 3
13831: PPUSH
13832: LD_INT 4
13834: PPUSH
13835: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13839: LD_VAR 0 3
13843: PPUSH
13844: LD_INT 241
13846: PPUSH
13847: LD_INT 72
13849: PPUSH
13850: LD_INT 0
13852: PPUSH
13853: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13857: LD_EXP 90
13861: PPUSH
13862: LD_VAR 0 3
13866: PPUSH
13867: CALL_OW 52
// if KhatamStatus then
13871: LD_EXP 8
13875: IFFALSE 13926
// begin Khatam := NewCharacter ( Khatam ) ;
13877: LD_ADDR_EXP 91
13881: PUSH
13882: LD_STRING Khatam
13884: PPUSH
13885: CALL_OW 25
13889: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13890: LD_EXP 91
13894: PPUSH
13895: LD_INT 245
13897: PPUSH
13898: LD_INT 78
13900: PPUSH
13901: LD_INT 3
13903: PPUSH
13904: LD_INT 0
13906: PPUSH
13907: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13911: LD_EXP 91
13915: PPUSH
13916: LD_INT 4
13918: PPUSH
13919: LD_INT 10
13921: PPUSH
13922: CALL_OW 237
// end ; for i = 1 to Difficulty do
13926: LD_ADDR_VAR 0 2
13930: PUSH
13931: DOUBLE
13932: LD_INT 1
13934: DEC
13935: ST_TO_ADDR
13936: LD_OWVAR 67
13940: PUSH
13941: FOR_TO
13942: IFFALSE 14008
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13944: LD_INT 0
13946: PPUSH
13947: LD_INT 7
13949: PUSH
13950: LD_OWVAR 67
13954: PLUS
13955: PPUSH
13956: CALL_OW 384
// un := CreateHuman ;
13960: LD_ADDR_VAR 0 4
13964: PUSH
13965: CALL_OW 44
13969: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13970: LD_VAR 0 4
13974: PPUSH
13975: LD_INT 28
13977: PUSH
13978: LD_INT 29
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: PUSH
13985: LD_VAR 0 2
13989: PUSH
13990: LD_INT 2
13992: MOD
13993: PUSH
13994: LD_INT 1
13996: PLUS
13997: ARRAY
13998: PPUSH
13999: LD_INT 0
14001: PPUSH
14002: CALL_OW 49
// end ;
14006: GO 13941
14008: POP
14009: POP
// for i = 1 to 6 do
14010: LD_ADDR_VAR 0 2
14014: PUSH
14015: DOUBLE
14016: LD_INT 1
14018: DEC
14019: ST_TO_ADDR
14020: LD_INT 6
14022: PUSH
14023: FOR_TO
14024: IFFALSE 14069
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14026: LD_INT 0
14028: PPUSH
14029: LD_INT 7
14031: PUSH
14032: LD_OWVAR 67
14036: PLUS
14037: PPUSH
14038: CALL_OW 381
// un := CreateHuman ;
14042: LD_ADDR_VAR 0 4
14046: PUSH
14047: CALL_OW 44
14051: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14052: LD_VAR 0 4
14056: PPUSH
14057: LD_INT 28
14059: PPUSH
14060: LD_INT 0
14062: PPUSH
14063: CALL_OW 49
// end ;
14067: GO 14023
14069: POP
14070: POP
// for i = 1 to 3 do
14071: LD_ADDR_VAR 0 2
14075: PUSH
14076: DOUBLE
14077: LD_INT 1
14079: DEC
14080: ST_TO_ADDR
14081: LD_INT 3
14083: PUSH
14084: FOR_TO
14085: IFFALSE 14133
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14087: LD_INT 0
14089: PPUSH
14090: LD_INT 8
14092: PPUSH
14093: LD_INT 7
14095: PUSH
14096: LD_OWVAR 67
14100: PLUS
14101: PPUSH
14102: CALL_OW 380
// un := CreateHuman ;
14106: LD_ADDR_VAR 0 4
14110: PUSH
14111: CALL_OW 44
14115: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14116: LD_VAR 0 4
14120: PPUSH
14121: LD_INT 28
14123: PPUSH
14124: LD_INT 0
14126: PPUSH
14127: CALL_OW 49
// end ;
14131: GO 14084
14133: POP
14134: POP
// for i = 1 to 3 do
14135: LD_ADDR_VAR 0 2
14139: PUSH
14140: DOUBLE
14141: LD_INT 1
14143: DEC
14144: ST_TO_ADDR
14145: LD_INT 3
14147: PUSH
14148: FOR_TO
14149: IFFALSE 14239
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14151: LD_INT 14
14153: PPUSH
14154: LD_INT 2
14156: PPUSH
14157: LD_INT 1
14159: PPUSH
14160: LD_INT 28
14162: PPUSH
14163: LD_INT 80
14165: PPUSH
14166: CALL 71077 0 5
// veh := CreateVehicle ;
14170: LD_ADDR_VAR 0 3
14174: PUSH
14175: CALL_OW 45
14179: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14180: LD_VAR 0 3
14184: PPUSH
14185: LD_INT 3
14187: PPUSH
14188: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14192: LD_VAR 0 3
14196: PPUSH
14197: LD_INT 29
14199: PPUSH
14200: LD_INT 0
14202: PPUSH
14203: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14207: LD_INT 0
14209: PPUSH
14210: LD_INT 7
14212: PUSH
14213: LD_OWVAR 67
14217: PLUS
14218: PPUSH
14219: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14223: CALL_OW 44
14227: PPUSH
14228: LD_VAR 0 3
14232: PPUSH
14233: CALL_OW 52
// end ;
14237: GO 14148
14239: POP
14240: POP
// for i = 1 to 5 + Difficulty do
14241: LD_ADDR_VAR 0 2
14245: PUSH
14246: DOUBLE
14247: LD_INT 1
14249: DEC
14250: ST_TO_ADDR
14251: LD_INT 5
14253: PUSH
14254: LD_OWVAR 67
14258: PLUS
14259: PUSH
14260: FOR_TO
14261: IFFALSE 14388
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14263: LD_INT 14
14265: PPUSH
14266: LD_INT 1
14268: PPUSH
14269: LD_INT 3
14271: PPUSH
14272: CALL_OW 12
14276: PPUSH
14277: LD_INT 1
14279: PPUSH
14280: LD_INT 28
14282: PUSH
14283: LD_INT 26
14285: PUSH
14286: LD_INT 27
14288: PUSH
14289: LD_INT 25
14291: PUSH
14292: EMPTY
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: PUSH
14298: LD_VAR 0 2
14302: PUSH
14303: LD_INT 4
14305: MOD
14306: PUSH
14307: LD_INT 1
14309: PLUS
14310: ARRAY
14311: PPUSH
14312: LD_INT 80
14314: PPUSH
14315: CALL 71077 0 5
// veh := CreateVehicle ;
14319: LD_ADDR_VAR 0 3
14323: PUSH
14324: CALL_OW 45
14328: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14329: LD_VAR 0 3
14333: PPUSH
14334: LD_INT 4
14336: PPUSH
14337: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14341: LD_VAR 0 3
14345: PPUSH
14346: LD_INT 28
14348: PPUSH
14349: LD_INT 0
14351: PPUSH
14352: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14356: LD_INT 0
14358: PPUSH
14359: LD_INT 7
14361: PUSH
14362: LD_OWVAR 67
14366: PLUS
14367: PPUSH
14368: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14372: CALL_OW 44
14376: PPUSH
14377: LD_VAR 0 3
14381: PPUSH
14382: CALL_OW 52
// end ;
14386: GO 14260
14388: POP
14389: POP
// for i = 1 to 3 do
14390: LD_ADDR_VAR 0 2
14394: PUSH
14395: DOUBLE
14396: LD_INT 1
14398: DEC
14399: ST_TO_ADDR
14400: LD_INT 3
14402: PUSH
14403: FOR_TO
14404: IFFALSE 14464
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14406: LD_INT 14
14408: PPUSH
14409: LD_INT 3
14411: PPUSH
14412: LD_INT 5
14414: PPUSH
14415: LD_INT 29
14417: PPUSH
14418: LD_INT 80
14420: PPUSH
14421: CALL 71077 0 5
// veh := CreateVehicle ;
14425: LD_ADDR_VAR 0 3
14429: PUSH
14430: CALL_OW 45
14434: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14435: LD_VAR 0 3
14439: PPUSH
14440: LD_INT 4
14442: PPUSH
14443: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14447: LD_VAR 0 3
14451: PPUSH
14452: LD_INT 28
14454: PPUSH
14455: LD_INT 0
14457: PPUSH
14458: CALL_OW 49
// end ;
14462: GO 14403
14464: POP
14465: POP
// end ;
14466: LD_VAR 0 1
14470: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14471: LD_INT 22
14473: PUSH
14474: LD_INT 2
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PPUSH
14481: CALL_OW 69
14485: IFFALSE 14785
14487: GO 14489
14489: DISABLE
14490: LD_INT 0
14492: PPUSH
14493: PPUSH
14494: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14495: LD_ADDR_VAR 0 3
14499: PUSH
14500: LD_INT 22
14502: PUSH
14503: LD_INT 2
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PUSH
14510: LD_INT 25
14512: PUSH
14513: LD_INT 4
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: PPUSH
14524: CALL_OW 69
14528: PUSH
14529: LD_EXP 91
14533: DIFF
14534: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14535: LD_ADDR_VAR 0 2
14539: PUSH
14540: LD_INT 22
14542: PUSH
14543: LD_INT 2
14545: PUSH
14546: EMPTY
14547: LIST
14548: LIST
14549: PPUSH
14550: CALL_OW 69
14554: PUSH
14555: LD_EXP 91
14559: PUSH
14560: LD_VAR 0 3
14564: UNION
14565: DIFF
14566: ST_TO_ADDR
// if Khatam then
14567: LD_EXP 91
14571: IFFALSE 14588
// ComMoveXY ( Khatam , 211 , 92 ) ;
14573: LD_EXP 91
14577: PPUSH
14578: LD_INT 211
14580: PPUSH
14581: LD_INT 92
14583: PPUSH
14584: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14588: LD_INT 197
14590: PPUSH
14591: LD_INT 80
14593: PPUSH
14594: LD_INT 2
14596: PPUSH
14597: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14601: LD_INT 213
14603: PPUSH
14604: LD_INT 90
14606: PPUSH
14607: LD_INT 2
14609: PPUSH
14610: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14614: LD_INT 215
14616: PPUSH
14617: LD_INT 129
14619: PPUSH
14620: LD_INT 2
14622: PPUSH
14623: CALL_OW 441
// if sci then
14627: LD_VAR 0 3
14631: IFFALSE 14652
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14633: LD_VAR 0 3
14637: PUSH
14638: LD_INT 1
14640: ARRAY
14641: PPUSH
14642: LD_INT 197
14644: PPUSH
14645: LD_INT 80
14647: PPUSH
14648: CALL_OW 158
// if sci > 1 then
14652: LD_VAR 0 3
14656: PUSH
14657: LD_INT 1
14659: GREATER
14660: IFFALSE 14681
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14662: LD_VAR 0 3
14666: PUSH
14667: LD_INT 2
14669: ARRAY
14670: PPUSH
14671: LD_INT 213
14673: PPUSH
14674: LD_INT 90
14676: PPUSH
14677: CALL_OW 158
// if sci > 2 then
14681: LD_VAR 0 3
14685: PUSH
14686: LD_INT 2
14688: GREATER
14689: IFFALSE 14710
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14691: LD_VAR 0 3
14695: PUSH
14696: LD_INT 3
14698: ARRAY
14699: PPUSH
14700: LD_INT 215
14702: PPUSH
14703: LD_INT 129
14705: PPUSH
14706: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14710: LD_INT 35
14712: PPUSH
14713: CALL_OW 67
// for i in tmp do
14717: LD_ADDR_VAR 0 1
14721: PUSH
14722: LD_VAR 0 2
14726: PUSH
14727: FOR_IN
14728: IFFALSE 14766
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14730: LD_VAR 0 1
14734: PPUSH
14735: LD_INT 81
14737: PUSH
14738: LD_INT 2
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: PPUSH
14745: CALL_OW 69
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: PPUSH
14760: CALL_OW 115
14764: GO 14727
14766: POP
14767: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14768: LD_INT 22
14770: PUSH
14771: LD_INT 2
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: PPUSH
14778: CALL_OW 69
14782: NOT
14783: IFFALSE 14710
// end ; end_of_file
14785: PPOPN 3
14787: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14788: LD_INT 0
14790: PPUSH
14791: PPUSH
14792: PPUSH
14793: PPUSH
14794: PPUSH
14795: PPUSH
14796: PPUSH
14797: PPUSH
14798: PPUSH
// Video ( true ) ;
14799: LD_INT 1
14801: PPUSH
14802: CALL 106794 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14806: LD_ADDR_VAR 0 5
14810: PUSH
14811: LD_INT 7
14813: PPUSH
14814: LD_INT 0
14816: PPUSH
14817: CALL_OW 517
14821: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14822: LD_ADDR_VAR 0 2
14826: PUSH
14827: DOUBLE
14828: LD_INT 1
14830: DEC
14831: ST_TO_ADDR
14832: LD_VAR 0 5
14836: PUSH
14837: LD_INT 1
14839: ARRAY
14840: PUSH
14841: FOR_TO
14842: IFFALSE 14887
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14844: LD_VAR 0 5
14848: PUSH
14849: LD_INT 1
14851: ARRAY
14852: PUSH
14853: LD_VAR 0 2
14857: ARRAY
14858: PPUSH
14859: LD_VAR 0 5
14863: PUSH
14864: LD_INT 2
14866: ARRAY
14867: PUSH
14868: LD_VAR 0 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 1
14876: PPUSH
14877: LD_INT 15
14879: NEG
14880: PPUSH
14881: CALL 106708 0 4
14885: GO 14841
14887: POP
14888: POP
// CenterNowOnUnits ( Powell ) ;
14889: LD_EXP 55
14893: PPUSH
14894: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14898: LD_ADDR_VAR 0 5
14902: PUSH
14903: LD_EXP 53
14907: PUSH
14908: EMPTY
14909: LIST
14910: ST_TO_ADDR
// if GirlNewVeh then
14911: LD_EXP 54
14915: IFFALSE 14933
// tmp := tmp ^ GirlNewVeh ;
14917: LD_ADDR_VAR 0 5
14921: PUSH
14922: LD_VAR 0 5
14926: PUSH
14927: LD_EXP 54
14931: ADD
14932: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14933: LD_VAR 0 5
14937: PPUSH
14938: LD_INT 60
14940: PPUSH
14941: LD_INT 109
14943: PPUSH
14944: CALL_OW 111
// if KappaStatus then
14948: LD_EXP 2
14952: IFFALSE 15004
// begin Say ( JMM , D1nT-JMM-1 ) ;
14954: LD_EXP 36
14958: PPUSH
14959: LD_STRING D1nT-JMM-1
14961: PPUSH
14962: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14966: LD_EXP 55
14970: PPUSH
14971: LD_STRING D1T-Pow-1
14973: PPUSH
14974: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14978: LD_EXP 36
14982: PPUSH
14983: LD_STRING D1T-JMM-2
14985: PPUSH
14986: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14990: LD_EXP 55
14994: PPUSH
14995: LD_STRING D1T-Pow-2
14997: PPUSH
14998: CALL_OW 88
// end else
15002: GO 15210
// if JMMGirlStatus then
15004: LD_EXP 6
15008: IFFALSE 15153
// begin Say ( JMM , D1T-JMM-1 ) ;
15010: LD_EXP 36
15014: PPUSH
15015: LD_STRING D1T-JMM-1
15017: PPUSH
15018: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15022: LD_EXP 55
15026: PPUSH
15027: LD_STRING D1T-Pow-1
15029: PPUSH
15030: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15034: LD_EXP 36
15038: PPUSH
15039: LD_STRING D1T-JMM-3
15041: PPUSH
15042: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15046: LD_EXP 55
15050: PPUSH
15051: LD_STRING D1T-Pow-3
15053: PPUSH
15054: CALL_OW 88
// if JMMGirl then
15058: LD_EXP 7
15062: IFFALSE 15151
// begin case JMMGirl of 1 :
15064: LD_EXP 7
15068: PUSH
15069: LD_INT 1
15071: DOUBLE
15072: EQUAL
15073: IFTRUE 15077
15075: GO 15092
15077: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15078: LD_EXP 37
15082: PPUSH
15083: LD_STRING D1T-Joan-3
15085: PPUSH
15086: CALL_OW 88
15090: GO 15139
15092: LD_INT 2
15094: DOUBLE
15095: EQUAL
15096: IFTRUE 15100
15098: GO 15115
15100: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15101: LD_EXP 39
15105: PPUSH
15106: LD_STRING D1T-Lisa-3
15108: PPUSH
15109: CALL_OW 88
15113: GO 15139
15115: LD_INT 3
15117: DOUBLE
15118: EQUAL
15119: IFTRUE 15123
15121: GO 15138
15123: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15124: LD_EXP 51
15128: PPUSH
15129: LD_STRING D1T-Con-3
15131: PPUSH
15132: CALL_OW 88
15136: GO 15139
15138: POP
// Say ( Powell , D1T-Pow-4 ) ;
15139: LD_EXP 55
15143: PPUSH
15144: LD_STRING D1T-Pow-4
15146: PPUSH
15147: CALL_OW 88
// end ; end else
15151: GO 15210
// if not FastEnd then
15153: LD_EXP 11
15157: NOT
15158: IFFALSE 15186
// begin Say ( JMM , D1T-JMM-4 ) ;
15160: LD_EXP 36
15164: PPUSH
15165: LD_STRING D1T-JMM-4
15167: PPUSH
15168: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15172: LD_EXP 55
15176: PPUSH
15177: LD_STRING D1T-Pow-5
15179: PPUSH
15180: CALL_OW 88
// end else
15184: GO 15210
// begin Say ( JMM , D1nT-JMM-1 ) ;
15186: LD_EXP 36
15190: PPUSH
15191: LD_STRING D1nT-JMM-1
15193: PPUSH
15194: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15198: LD_EXP 55
15202: PPUSH
15203: LD_STRING D1nT-Pow-1
15205: PPUSH
15206: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15210: LD_INT 35
15212: PPUSH
15213: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15217: LD_EXP 53
15221: PPUSH
15222: CALL_OW 314
15226: NOT
15227: IFFALSE 15210
// ComExitVehicle ( JMM ) ;
15229: LD_EXP 36
15233: PPUSH
15234: CALL_OW 121
// wait ( 3 ) ;
15238: LD_INT 3
15240: PPUSH
15241: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15245: LD_EXP 36
15249: PPUSH
15250: LD_INT 60
15252: PPUSH
15253: LD_INT 94
15255: PPUSH
15256: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15260: LD_EXP 36
15264: PPUSH
15265: LD_EXP 55
15269: PPUSH
15270: CALL_OW 179
// if Joan then
15274: LD_EXP 37
15278: IFFALSE 15332
// begin ComExitVehicle ( Joan ) ;
15280: LD_EXP 37
15284: PPUSH
15285: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15289: LD_EXP 37
15293: PPUSH
15294: LD_INT 35
15296: PPUSH
15297: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15301: LD_EXP 37
15305: PPUSH
15306: LD_INT 65
15308: PPUSH
15309: LD_INT 104
15311: PPUSH
15312: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15316: LD_EXP 37
15320: PPUSH
15321: LD_EXP 36
15325: PPUSH
15326: CALL_OW 179
// end else
15330: GO 15466
// if Lisa and JMMGirl = 2 then
15332: LD_EXP 39
15336: PUSH
15337: LD_EXP 7
15341: PUSH
15342: LD_INT 2
15344: EQUAL
15345: AND
15346: IFFALSE 15400
// begin ComExitVehicle ( Lisa ) ;
15348: LD_EXP 39
15352: PPUSH
15353: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15357: LD_EXP 39
15361: PPUSH
15362: LD_INT 35
15364: PPUSH
15365: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15369: LD_EXP 39
15373: PPUSH
15374: LD_INT 65
15376: PPUSH
15377: LD_INT 104
15379: PPUSH
15380: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15384: LD_EXP 39
15388: PPUSH
15389: LD_EXP 36
15393: PPUSH
15394: CALL_OW 179
// end else
15398: GO 15466
// if Connie and JMMGirl = 3 then
15400: LD_EXP 51
15404: PUSH
15405: LD_EXP 7
15409: PUSH
15410: LD_INT 3
15412: EQUAL
15413: AND
15414: IFFALSE 15466
// begin ComExitVehicle ( Connie ) ;
15416: LD_EXP 51
15420: PPUSH
15421: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15425: LD_EXP 51
15429: PPUSH
15430: LD_INT 35
15432: PPUSH
15433: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15437: LD_EXP 51
15441: PPUSH
15442: LD_INT 65
15444: PPUSH
15445: LD_INT 104
15447: PPUSH
15448: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15452: LD_EXP 51
15456: PPUSH
15457: LD_EXP 36
15461: PPUSH
15462: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15466: LD_INT 35
15468: PPUSH
15469: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15473: LD_EXP 36
15477: PPUSH
15478: LD_EXP 55
15482: PPUSH
15483: CALL_OW 296
15487: PUSH
15488: LD_INT 6
15490: LESS
15491: IFFALSE 15466
// wait ( 0 0$0.5 ) ;
15493: LD_INT 18
15495: PPUSH
15496: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15500: LD_EXP 36
15504: PPUSH
15505: LD_STRING D1-JMM-1
15507: PPUSH
15508: CALL_OW 88
// async ;
15512: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15513: LD_EXP 55
15517: PPUSH
15518: LD_STRING D1-Pow-1
15520: PPUSH
15521: CALL_OW 88
// if not dialogue_skipped then
15525: LD_OWVAR 59
15529: NOT
15530: IFFALSE 15539
// wait ( 0 0$2 ) ;
15532: LD_INT 70
15534: PPUSH
15535: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15539: LD_INT 170
15541: PPUSH
15542: LD_INT 99
15544: PPUSH
15545: LD_INT 1
15547: PPUSH
15548: LD_INT 6
15550: NEG
15551: PPUSH
15552: CALL 106708 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15556: LD_INT 174
15558: PPUSH
15559: LD_INT 115
15561: PPUSH
15562: LD_INT 1
15564: PPUSH
15565: LD_INT 6
15567: NEG
15568: PPUSH
15569: CALL 106708 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15573: LD_INT 169
15575: PPUSH
15576: LD_INT 71
15578: PPUSH
15579: LD_INT 1
15581: PPUSH
15582: LD_INT 6
15584: NEG
15585: PPUSH
15586: CALL 106708 0 4
// if not dialogue_skipped then
15590: LD_OWVAR 59
15594: NOT
15595: IFFALSE 15614
// begin CenterOnXY ( 170 , 99 ) ;
15597: LD_INT 170
15599: PPUSH
15600: LD_INT 99
15602: PPUSH
15603: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15607: LD_INT 80
15609: PPUSH
15610: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15614: LD_INT 75
15616: PPUSH
15617: LD_INT 53
15619: PPUSH
15620: LD_INT 1
15622: PPUSH
15623: LD_INT 9
15625: NEG
15626: PPUSH
15627: CALL 106708 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15631: LD_INT 54
15633: PPUSH
15634: LD_INT 42
15636: PPUSH
15637: LD_INT 1
15639: PPUSH
15640: LD_INT 9
15642: NEG
15643: PPUSH
15644: CALL 106708 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15648: LD_INT 62
15650: PPUSH
15651: LD_INT 51
15653: PPUSH
15654: LD_INT 1
15656: PPUSH
15657: LD_INT 9
15659: NEG
15660: PPUSH
15661: CALL 106708 0 4
// if not dialogue_skipped then
15665: LD_OWVAR 59
15669: NOT
15670: IFFALSE 15689
// begin CenterOnXY ( 75 , 53 ) ;
15672: LD_INT 75
15674: PPUSH
15675: LD_INT 53
15677: PPUSH
15678: CALL_OW 84
// wait ( 0 0$4 ) ;
15682: LD_INT 140
15684: PPUSH
15685: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15689: LD_EXP 55
15693: PPUSH
15694: CALL_OW 87
// if not dialogue_skipped then
15698: LD_OWVAR 59
15702: NOT
15703: IFFALSE 15712
// wait ( 0 0$2 ) ;
15705: LD_INT 70
15707: PPUSH
15708: CALL_OW 67
// sync ;
15712: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15713: LD_EXP 36
15717: PPUSH
15718: LD_STRING D1-JMM-2
15720: PPUSH
15721: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15725: LD_EXP 55
15729: PPUSH
15730: LD_STRING D1-Pow-2
15732: PPUSH
15733: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15737: LD_EXP 36
15741: PPUSH
15742: LD_STRING D1-JMM-3
15744: PPUSH
15745: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15749: LD_EXP 55
15753: PPUSH
15754: LD_STRING D1-Pow-3
15756: PPUSH
15757: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15761: LD_EXP 36
15765: PPUSH
15766: LD_STRING D1-JMM-4
15768: PPUSH
15769: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15773: LD_EXP 55
15777: PPUSH
15778: LD_STRING D1-Pow-4
15780: PPUSH
15781: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15785: LD_EXP 36
15789: PPUSH
15790: LD_STRING D1-JMM-5
15792: PPUSH
15793: CALL_OW 88
// async ;
15797: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15798: LD_EXP 55
15802: PPUSH
15803: LD_STRING D1-Pow-5
15805: PPUSH
15806: CALL_OW 88
// if not dialogue_skipped then
15810: LD_OWVAR 59
15814: NOT
15815: IFFALSE 15824
// wait ( 0 0$3.6 ) ;
15817: LD_INT 126
15819: PPUSH
15820: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15824: LD_INT 134
15826: PPUSH
15827: LD_INT 210
15829: PPUSH
15830: LD_INT 1
15832: PPUSH
15833: LD_INT 11
15835: NEG
15836: PPUSH
15837: CALL 106708 0 4
// if not dialogue_skipped then
15841: LD_OWVAR 59
15845: NOT
15846: IFFALSE 15865
// begin CenterOnXY ( 134 , 210 ) ;
15848: LD_INT 134
15850: PPUSH
15851: LD_INT 210
15853: PPUSH
15854: CALL_OW 84
// wait ( 0 0$2 ) ;
15858: LD_INT 70
15860: PPUSH
15861: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15865: LD_INT 101
15867: PPUSH
15868: LD_INT 159
15870: PPUSH
15871: LD_INT 1
15873: PPUSH
15874: LD_INT 10
15876: NEG
15877: PPUSH
15878: CALL 106708 0 4
// if not dialogue_skipped then
15882: LD_OWVAR 59
15886: NOT
15887: IFFALSE 15906
// begin CenterOnXY ( 101 , 159 ) ;
15889: LD_INT 101
15891: PPUSH
15892: LD_INT 159
15894: PPUSH
15895: CALL_OW 84
// wait ( 0 0$2 ) ;
15899: LD_INT 70
15901: PPUSH
15902: CALL_OW 67
// end ; sync ;
15906: SYNC
// CenterNowOnUnits ( Powell ) ;
15907: LD_EXP 55
15911: PPUSH
15912: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15916: LD_ADDR_VAR 0 6
15920: PUSH
15921: LD_INT 1
15923: PUSH
15924: LD_INT 2
15926: PUSH
15927: LD_INT 3
15929: PUSH
15930: LD_INT 4
15932: PUSH
15933: LD_INT 5
15935: PUSH
15936: LD_INT 6
15938: PUSH
15939: EMPTY
15940: LIST
15941: LIST
15942: LIST
15943: LIST
15944: LIST
15945: LIST
15946: ST_TO_ADDR
// if not dialogue_skipped then
15947: LD_OWVAR 59
15951: NOT
15952: IFFALSE 16121
// begin game_speed := 4 ;
15954: LD_ADDR_OWVAR 65
15958: PUSH
15959: LD_INT 4
15961: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15962: LD_INT 210
15964: PPUSH
15965: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15969: LD_ADDR_VAR 0 7
15973: PUSH
15974: LD_STRING Q1
15976: PPUSH
15977: LD_VAR 0 6
15981: PPUSH
15982: CALL_OW 98
15986: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15987: LD_ADDR_VAR 0 7
15991: PUSH
15992: LD_STRING Q1
15994: PPUSH
15995: LD_VAR 0 6
15999: PPUSH
16000: CALL_OW 98
16004: ST_TO_ADDR
// options = options diff dec ;
16005: LD_ADDR_VAR 0 6
16009: PUSH
16010: LD_VAR 0 6
16014: PUSH
16015: LD_VAR 0 7
16019: DIFF
16020: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16021: LD_VAR 0 7
16025: PPUSH
16026: LD_VAR 0 6
16030: PPUSH
16031: CALL 17424 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16035: LD_VAR 0 7
16039: PUSH
16040: LD_INT 5
16042: PUSH
16043: LD_INT 6
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: IN
16050: PUSH
16051: LD_VAR 0 6
16055: PUSH
16056: LD_INT 2
16058: EQUAL
16059: OR
16060: IFFALSE 15987
// if not ( dec in [ 5 , 6 ] ) then
16062: LD_VAR 0 7
16066: PUSH
16067: LD_INT 5
16069: PUSH
16070: LD_INT 6
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: IN
16077: NOT
16078: IFFALSE 16121
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16080: LD_ADDR_VAR 0 7
16084: PUSH
16085: LD_STRING Q1a
16087: PPUSH
16088: LD_INT 1
16090: PUSH
16091: LD_INT 2
16093: PUSH
16094: EMPTY
16095: LIST
16096: LIST
16097: PPUSH
16098: CALL_OW 98
16102: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16103: LD_VAR 0 7
16107: PUSH
16108: LD_INT 4
16110: PLUS
16111: PPUSH
16112: LD_VAR 0 6
16116: PPUSH
16117: CALL 17424 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16121: LD_INT 81
16123: PPUSH
16124: LD_INT 127
16126: PPUSH
16127: CALL_OW 84
// amount := 5 ;
16131: LD_ADDR_VAR 0 8
16135: PUSH
16136: LD_INT 5
16138: ST_TO_ADDR
// macmilan_squad := [ ] ;
16139: LD_ADDR_VAR 0 9
16143: PUSH
16144: EMPTY
16145: ST_TO_ADDR
// if vip < amount then
16146: LD_EXP 56
16150: PUSH
16151: LD_VAR 0 8
16155: LESS
16156: IFFALSE 16200
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16158: LD_ADDR_VAR 0 5
16162: PUSH
16163: LD_EXP 56
16167: PUSH
16168: LD_INT 22
16170: PUSH
16171: LD_INT 4
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: PUSH
16178: LD_INT 21
16180: PUSH
16181: LD_INT 1
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: EMPTY
16189: LIST
16190: LIST
16191: PPUSH
16192: CALL_OW 69
16196: UNION
16197: ST_TO_ADDR
16198: GO 16210
// tmp := vip ;
16200: LD_ADDR_VAR 0 5
16204: PUSH
16205: LD_EXP 56
16209: ST_TO_ADDR
// tmp := tmp diff Powell ;
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_VAR 0 5
16219: PUSH
16220: LD_EXP 55
16224: DIFF
16225: ST_TO_ADDR
// if tmp < amount then
16226: LD_VAR 0 5
16230: PUSH
16231: LD_VAR 0 8
16235: LESS
16236: IFFALSE 16248
// amount := tmp ;
16238: LD_ADDR_VAR 0 8
16242: PUSH
16243: LD_VAR 0 5
16247: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16248: LD_VAR 0 5
16252: PUSH
16253: LD_INT 1
16255: ARRAY
16256: PPUSH
16257: CALL_OW 257
16261: PUSH
16262: LD_INT 2
16264: NONEQUAL
16265: IFFALSE 16327
// begin if IsInUnit ( tmp [ 1 ] ) then
16267: LD_VAR 0 5
16271: PUSH
16272: LD_INT 1
16274: ARRAY
16275: PPUSH
16276: CALL_OW 310
16280: IFFALSE 16295
// ComExitBuilding ( tmp [ 1 ] ) ;
16282: LD_VAR 0 5
16286: PUSH
16287: LD_INT 1
16289: ARRAY
16290: PPUSH
16291: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16295: LD_VAR 0 5
16299: PUSH
16300: LD_INT 1
16302: ARRAY
16303: PPUSH
16304: LD_INT 387
16306: PPUSH
16307: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16311: LD_VAR 0 5
16315: PUSH
16316: LD_INT 1
16318: ARRAY
16319: PPUSH
16320: LD_INT 2
16322: PPUSH
16323: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16327: LD_EXP 36
16331: PPUSH
16332: LD_INT 82
16334: PPUSH
16335: LD_INT 129
16337: PPUSH
16338: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16342: LD_EXP 36
16346: PPUSH
16347: LD_EXP 55
16351: PPUSH
16352: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16356: LD_INT 22
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PPUSH
16366: CALL_OW 69
16370: PUSH
16371: LD_EXP 36
16375: DIFF
16376: PPUSH
16377: LD_INT 84
16379: PPUSH
16380: LD_INT 128
16382: PPUSH
16383: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16387: LD_INT 22
16389: PUSH
16390: LD_INT 1
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PPUSH
16397: CALL_OW 69
16401: PUSH
16402: LD_EXP 36
16406: DIFF
16407: PPUSH
16408: LD_EXP 36
16412: PPUSH
16413: CALL_OW 179
// for i = 1 to amount do
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: DOUBLE
16423: LD_INT 1
16425: DEC
16426: ST_TO_ADDR
16427: LD_VAR 0 8
16431: PUSH
16432: FOR_TO
16433: IFFALSE 16601
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16435: LD_ADDR_VAR 0 9
16439: PUSH
16440: LD_VAR 0 9
16444: PUSH
16445: LD_VAR 0 5
16449: PUSH
16450: LD_VAR 0 2
16454: ARRAY
16455: ADD
16456: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16457: LD_VAR 0 5
16461: PUSH
16462: LD_VAR 0 2
16466: ARRAY
16467: PPUSH
16468: CALL_OW 310
16472: IFFALSE 16489
// AddComExitBuilding ( tmp [ i ] ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_VAR 0 2
16483: ARRAY
16484: PPUSH
16485: CALL_OW 182
// if i = 2 and JMMNewVeh then
16489: LD_VAR 0 2
16493: PUSH
16494: LD_INT 2
16496: EQUAL
16497: PUSH
16498: LD_EXP 53
16502: AND
16503: IFFALSE 16561
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16505: LD_VAR 0 5
16509: PUSH
16510: LD_VAR 0 2
16514: ARRAY
16515: PPUSH
16516: LD_EXP 53
16520: PPUSH
16521: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16525: LD_VAR 0 5
16529: PUSH
16530: LD_VAR 0 2
16534: ARRAY
16535: PPUSH
16536: LD_INT 86
16538: PPUSH
16539: LD_INT 133
16541: PPUSH
16542: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16546: LD_VAR 0 5
16550: PUSH
16551: LD_VAR 0 2
16555: ARRAY
16556: PPUSH
16557: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16561: LD_VAR 0 5
16565: PUSH
16566: LD_VAR 0 2
16570: ARRAY
16571: PPUSH
16572: LD_INT 8
16574: PPUSH
16575: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16579: LD_VAR 0 5
16583: PUSH
16584: LD_VAR 0 2
16588: ARRAY
16589: PPUSH
16590: LD_EXP 36
16594: PPUSH
16595: CALL_OW 179
// end ;
16599: GO 16432
16601: POP
16602: POP
// if GirlNewVeh then
16603: LD_EXP 54
16607: IFFALSE 16621
// SetSide ( GirlNewVeh , 4 ) ;
16609: LD_EXP 54
16613: PPUSH
16614: LD_INT 4
16616: PPUSH
16617: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16621: LD_INT 35
16623: PPUSH
16624: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16628: LD_VAR 0 9
16632: PPUSH
16633: LD_INT 95
16635: PUSH
16636: LD_INT 9
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: PPUSH
16643: CALL_OW 72
16647: PUSH
16648: LD_INT 0
16650: EQUAL
16651: PUSH
16652: LD_EXP 36
16656: PPUSH
16657: LD_INT 9
16659: PPUSH
16660: CALL_OW 308
16664: NOT
16665: AND
16666: IFFALSE 16621
// wait ( 0 0$2 ) ;
16668: LD_INT 70
16670: PPUSH
16671: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16675: LD_VAR 0 9
16679: PPUSH
16680: LD_INT 1
16682: PPUSH
16683: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16687: LD_INT 21
16689: PUSH
16690: LD_INT 2
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: PUSH
16697: LD_INT 92
16699: PUSH
16700: LD_INT 83
16702: PUSH
16703: LD_INT 130
16705: PUSH
16706: LD_INT 10
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PPUSH
16719: CALL_OW 69
16723: PPUSH
16724: LD_INT 1
16726: PPUSH
16727: CALL_OW 235
// Video ( false ) ;
16731: LD_INT 0
16733: PPUSH
16734: CALL 106794 0 1
// ChangeMissionObjectives ( M1 ) ;
16738: LD_STRING M1
16740: PPUSH
16741: CALL_OW 337
// SaveForQuickRestart ;
16745: CALL_OW 22
// missionStart := true ;
16749: LD_ADDR_EXP 13
16753: PUSH
16754: LD_INT 1
16756: ST_TO_ADDR
// missionStage := 2 ;
16757: LD_ADDR_EXP 15
16761: PUSH
16762: LD_INT 2
16764: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16765: LD_INT 105
16767: PPUSH
16768: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16772: LD_ADDR_VAR 0 5
16776: PUSH
16777: LD_INT 22
16779: PUSH
16780: LD_INT 4
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PUSH
16787: LD_INT 21
16789: PUSH
16790: LD_INT 1
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PPUSH
16801: CALL_OW 69
16805: PUSH
16806: LD_EXP 55
16810: DIFF
16811: ST_TO_ADDR
// if not tmp then
16812: LD_VAR 0 5
16816: NOT
16817: IFFALSE 16832
// tmp := [ Powell ] ;
16819: LD_ADDR_VAR 0 5
16823: PUSH
16824: LD_EXP 55
16828: PUSH
16829: EMPTY
16830: LIST
16831: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16832: LD_ADDR_EXP 99
16836: PUSH
16837: LD_EXP 99
16841: PPUSH
16842: LD_INT 4
16844: PPUSH
16845: LD_INT 22
16847: PUSH
16848: LD_INT 4
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 23
16857: PUSH
16858: LD_INT 1
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 3
16867: PUSH
16868: LD_INT 21
16870: PUSH
16871: LD_INT 2
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: LIST
16886: PPUSH
16887: CALL_OW 69
16891: PUSH
16892: LD_EXP 55
16896: DIFF
16897: PPUSH
16898: CALL_OW 1
16902: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16903: LD_ADDR_VAR 0 4
16907: PUSH
16908: LD_INT 22
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 34
16920: PUSH
16921: LD_INT 12
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PPUSH
16932: CALL_OW 69
16936: PUSH
16937: LD_INT 1
16939: ARRAY
16940: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16941: LD_VAR 0 5
16945: PUSH
16946: LD_INT 1
16948: ARRAY
16949: PPUSH
16950: CALL_OW 310
16954: IFFALSE 16969
// ComExitBuilding ( tmp [ 1 ] ) ;
16956: LD_VAR 0 5
16960: PUSH
16961: LD_INT 1
16963: ARRAY
16964: PPUSH
16965: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16969: LD_VAR 0 5
16973: PUSH
16974: LD_INT 1
16976: ARRAY
16977: PPUSH
16978: LD_VAR 0 4
16982: PPUSH
16983: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16987: LD_VAR 0 5
16991: PUSH
16992: LD_INT 1
16994: ARRAY
16995: PPUSH
16996: LD_INT 80
16998: PPUSH
16999: LD_INT 136
17001: PPUSH
17002: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17006: LD_VAR 0 5
17010: PUSH
17011: LD_INT 1
17013: ARRAY
17014: PPUSH
17015: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17019: LD_VAR 0 5
17023: PUSH
17024: LD_INT 1
17026: ARRAY
17027: PPUSH
17028: LD_INT 59
17030: PPUSH
17031: LD_INT 112
17033: PPUSH
17034: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17038: LD_VAR 0 5
17042: PUSH
17043: LD_INT 1
17045: ARRAY
17046: PPUSH
17047: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17051: LD_EXP 39
17055: PUSH
17056: LD_EXP 56
17060: IN
17061: PUSH
17062: LD_EXP 39
17066: PPUSH
17067: CALL_OW 255
17071: PUSH
17072: LD_INT 1
17074: EQUAL
17075: AND
17076: IFFALSE 17092
// Say ( Lisa , D3nW-Lisa-1 ) else
17078: LD_EXP 39
17082: PPUSH
17083: LD_STRING D3nW-Lisa-1
17085: PPUSH
17086: CALL_OW 88
17090: GO 17336
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17092: LD_EXP 42
17096: PUSH
17097: LD_EXP 56
17101: IN
17102: PUSH
17103: LD_EXP 42
17107: PPUSH
17108: CALL_OW 255
17112: PUSH
17113: LD_INT 1
17115: EQUAL
17116: AND
17117: IFFALSE 17133
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17119: LD_EXP 42
17123: PPUSH
17124: LD_STRING D3nW-Cyrus-1
17126: PPUSH
17127: CALL_OW 88
17131: GO 17336
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17133: LD_EXP 41
17137: PUSH
17138: LD_EXP 56
17142: IN
17143: PUSH
17144: LD_EXP 41
17148: PPUSH
17149: CALL_OW 255
17153: PUSH
17154: LD_INT 1
17156: EQUAL
17157: AND
17158: IFFALSE 17174
// Say ( Bobby , D3nW-Bobby-1 ) else
17160: LD_EXP 41
17164: PPUSH
17165: LD_STRING D3nW-Bobby-1
17167: PPUSH
17168: CALL_OW 88
17172: GO 17336
// if Gary in vip and GetSide ( Gary ) = 1 then
17174: LD_EXP 48
17178: PUSH
17179: LD_EXP 56
17183: IN
17184: PUSH
17185: LD_EXP 48
17189: PPUSH
17190: CALL_OW 255
17194: PUSH
17195: LD_INT 1
17197: EQUAL
17198: AND
17199: IFFALSE 17215
// Say ( Gary , D3nW-Gary-1 ) else
17201: LD_EXP 48
17205: PPUSH
17206: LD_STRING D3nW-Gary-1
17208: PPUSH
17209: CALL_OW 88
17213: GO 17336
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17215: LD_EXP 40
17219: PUSH
17220: LD_EXP 56
17224: IN
17225: PUSH
17226: LD_EXP 40
17230: PPUSH
17231: CALL_OW 255
17235: PUSH
17236: LD_INT 1
17238: EQUAL
17239: AND
17240: IFFALSE 17256
// Say ( Donaldson , D3nW-Don-1 ) else
17242: LD_EXP 40
17246: PPUSH
17247: LD_STRING D3nW-Don-1
17249: PPUSH
17250: CALL_OW 88
17254: GO 17336
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17256: LD_EXP 47
17260: PUSH
17261: LD_EXP 56
17265: IN
17266: PUSH
17267: LD_EXP 47
17271: PPUSH
17272: CALL_OW 255
17276: PUSH
17277: LD_INT 1
17279: EQUAL
17280: AND
17281: IFFALSE 17297
// Say ( Cornel , D3nW-Corn-1 ) else
17283: LD_EXP 47
17287: PPUSH
17288: LD_STRING D3nW-Corn-1
17290: PPUSH
17291: CALL_OW 88
17295: GO 17336
// if Frank in vip and GetSide ( Frank ) = 1 then
17297: LD_EXP 49
17301: PUSH
17302: LD_EXP 56
17306: IN
17307: PUSH
17308: LD_EXP 49
17312: PPUSH
17313: CALL_OW 255
17317: PUSH
17318: LD_INT 1
17320: EQUAL
17321: AND
17322: IFFALSE 17336
// Say ( Frank , D3nW-Frank-1 ) ;
17324: LD_EXP 49
17328: PPUSH
17329: LD_STRING D3nW-Frank-1
17331: PPUSH
17332: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17336: LD_EXP 36
17340: PPUSH
17341: LD_STRING D3nW-JMM-1
17343: PPUSH
17344: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17348: LD_EXP 36
17352: PPUSH
17353: LD_STRING D3nW-JMM-1a
17355: PPUSH
17356: CALL_OW 88
// t := 0 0$00 ;
17360: LD_ADDR_VAR 0 3
17364: PUSH
17365: LD_INT 0
17367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17368: LD_INT 35
17370: PPUSH
17371: CALL_OW 67
// t := t + 0 0$1 ;
17375: LD_ADDR_VAR 0 3
17379: PUSH
17380: LD_VAR 0 3
17384: PUSH
17385: LD_INT 35
17387: PLUS
17388: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17389: LD_INT 59
17391: PPUSH
17392: LD_INT 112
17394: PPUSH
17395: CALL_OW 428
17399: PUSH
17400: LD_VAR 0 3
17404: PUSH
17405: LD_INT 2100
17407: GREATER
17408: OR
17409: IFFALSE 17368
// activeAttacks := true ;
17411: LD_ADDR_EXP 16
17415: PUSH
17416: LD_INT 1
17418: ST_TO_ADDR
// end ;
17419: LD_VAR 0 1
17423: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17424: LD_INT 0
17426: PPUSH
// case question of 1 :
17427: LD_VAR 0 1
17431: PUSH
17432: LD_INT 1
17434: DOUBLE
17435: EQUAL
17436: IFTRUE 17440
17438: GO 17491
17440: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17441: LD_EXP 36
17445: PPUSH
17446: LD_STRING D2Mot-JMM-1
17448: PPUSH
17449: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17453: LD_EXP 55
17457: PPUSH
17458: LD_STRING D2Mot-Pow-1
17460: PPUSH
17461: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17465: LD_EXP 36
17469: PPUSH
17470: LD_STRING D2Mot-JMM-2
17472: PPUSH
17473: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17477: LD_EXP 55
17481: PPUSH
17482: LD_STRING D2Mot-Pow-2
17484: PPUSH
17485: CALL_OW 88
// end ; 2 :
17489: GO 17834
17491: LD_INT 2
17493: DOUBLE
17494: EQUAL
17495: IFTRUE 17499
17497: GO 17575
17499: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17500: LD_EXP 36
17504: PPUSH
17505: LD_STRING D2Rus-JMM-1
17507: PPUSH
17508: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17512: LD_EXP 55
17516: PPUSH
17517: LD_STRING D2Rus-Pow-1
17519: PPUSH
17520: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17524: LD_EXP 36
17528: PPUSH
17529: LD_STRING D2Rus-JMM-2
17531: PPUSH
17532: CALL_OW 88
// if not ( 3 in list_of_q ) then
17536: LD_INT 3
17538: PUSH
17539: LD_VAR 0 2
17543: IN
17544: NOT
17545: IFFALSE 17561
// Say ( Powell , D2Rus-Pow-2 ) else
17547: LD_EXP 55
17551: PPUSH
17552: LD_STRING D2Rus-Pow-2
17554: PPUSH
17555: CALL_OW 88
17559: GO 17573
// Say ( Powell , D2Rus-Pow-2a ) ;
17561: LD_EXP 55
17565: PPUSH
17566: LD_STRING D2Rus-Pow-2a
17568: PPUSH
17569: CALL_OW 88
// end ; 3 :
17573: GO 17834
17575: LD_INT 3
17577: DOUBLE
17578: EQUAL
17579: IFTRUE 17583
17581: GO 17668
17583: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17584: LD_EXP 36
17588: PPUSH
17589: LD_STRING D2Leg-JMM-1
17591: PPUSH
17592: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17596: LD_EXP 55
17600: PPUSH
17601: LD_STRING D2Leg-Pow-1
17603: PPUSH
17604: CALL_OW 88
// if 2 in list_of_q then
17608: LD_INT 2
17610: PUSH
17611: LD_VAR 0 2
17615: IN
17616: IFFALSE 17642
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17618: LD_EXP 36
17622: PPUSH
17623: LD_STRING D2Leg-JMM-2
17625: PPUSH
17626: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17630: LD_EXP 55
17634: PPUSH
17635: LD_STRING D2Leg-Pow-2
17637: PPUSH
17638: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17642: LD_EXP 36
17646: PPUSH
17647: LD_STRING D2Leg-JMM-3
17649: PPUSH
17650: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17654: LD_EXP 55
17658: PPUSH
17659: LD_STRING D2Leg-Pow-3
17661: PPUSH
17662: CALL_OW 88
// end ; 4 :
17666: GO 17834
17668: LD_INT 4
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17751
17676: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17677: LD_EXP 36
17681: PPUSH
17682: LD_STRING D2Ar-JMM-1
17684: PPUSH
17685: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17689: LD_EXP 55
17693: PPUSH
17694: LD_STRING D2Ar-Pow-1
17696: PPUSH
17697: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17701: LD_EXP 36
17705: PPUSH
17706: LD_STRING D2Ar-JMM-2
17708: PPUSH
17709: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17713: LD_EXP 55
17717: PPUSH
17718: LD_STRING D2Ar-Pow-2
17720: PPUSH
17721: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17725: LD_EXP 36
17729: PPUSH
17730: LD_STRING D2Ar-JMM-3
17732: PPUSH
17733: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17737: LD_EXP 55
17741: PPUSH
17742: LD_STRING D2Ar-Pow-3
17744: PPUSH
17745: CALL_OW 88
// end ; 5 :
17749: GO 17834
17751: LD_INT 5
17753: DOUBLE
17754: EQUAL
17755: IFTRUE 17759
17757: GO 17774
17759: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17760: LD_EXP 36
17764: PPUSH
17765: LD_STRING D2Conf-JMM-1
17767: PPUSH
17768: CALL_OW 88
17772: GO 17834
17774: LD_INT 6
17776: DOUBLE
17777: EQUAL
17778: IFTRUE 17782
17780: GO 17833
17782: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17783: LD_EXP 36
17787: PPUSH
17788: LD_STRING D2Com-JMM-1
17790: PPUSH
17791: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17795: LD_EXP 55
17799: PPUSH
17800: LD_STRING D2Com-Pow-1
17802: PPUSH
17803: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17807: LD_EXP 36
17811: PPUSH
17812: LD_STRING D2Com-JMM-2
17814: PPUSH
17815: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17819: LD_EXP 55
17823: PPUSH
17824: LD_STRING D2Com-Pow-2
17826: PPUSH
17827: CALL_OW 88
// end ; end ;
17831: GO 17834
17833: POP
// end ;
17834: LD_VAR 0 3
17838: RET
// every 0 0$5 trigger missionStart do var tmp ;
17839: LD_EXP 13
17843: IFFALSE 18126
17845: GO 17847
17847: DISABLE
17848: LD_INT 0
17850: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17851: LD_INT 35
17853: PPUSH
17854: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17858: LD_INT 14
17860: PPUSH
17861: LD_INT 22
17863: PUSH
17864: LD_INT 1
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: PPUSH
17871: CALL_OW 70
17875: PUSH
17876: LD_EXP 15
17880: PUSH
17881: LD_INT 2
17883: PUSH
17884: LD_INT 3
17886: PUSH
17887: LD_INT 4
17889: PUSH
17890: LD_INT 5
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: IN
17899: AND
17900: IFFALSE 18116
// begin powellAnger := powellAnger + 1 ;
17902: LD_ADDR_EXP 17
17906: PUSH
17907: LD_EXP 17
17911: PUSH
17912: LD_INT 1
17914: PLUS
17915: ST_TO_ADDR
// Video ( true ) ;
17916: LD_INT 1
17918: PPUSH
17919: CALL 106794 0 1
// CenterNowOnUnits ( tmp ) ;
17923: LD_VAR 0 1
17927: PPUSH
17928: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17932: LD_INT 14
17934: PPUSH
17935: LD_INT 22
17937: PUSH
17938: LD_INT 1
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: PPUSH
17945: CALL_OW 70
17949: PPUSH
17950: LD_INT 86
17952: PPUSH
17953: LD_INT 133
17955: PPUSH
17956: CALL_OW 111
// async ;
17960: ASYNC
// case powellAnger of 1 :
17961: LD_EXP 17
17965: PUSH
17966: LD_INT 1
17968: DOUBLE
17969: EQUAL
17970: IFTRUE 17974
17972: GO 17989
17974: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17975: LD_EXP 55
17979: PPUSH
17980: LD_STRING DBack1-Pow-1
17982: PPUSH
17983: CALL_OW 88
17987: GO 18036
17989: LD_INT 2
17991: DOUBLE
17992: EQUAL
17993: IFTRUE 17997
17995: GO 18012
17997: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17998: LD_EXP 55
18002: PPUSH
18003: LD_STRING DBack2-Pow-1
18005: PPUSH
18006: CALL_OW 88
18010: GO 18036
18012: LD_INT 3
18014: DOUBLE
18015: EQUAL
18016: IFTRUE 18020
18018: GO 18035
18020: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18021: LD_EXP 55
18025: PPUSH
18026: LD_STRING DBack3-Pow-1
18028: PPUSH
18029: CALL_OW 88
18033: GO 18036
18035: POP
// sync ;
18036: SYNC
// repeat wait ( 0 0$1 ) ;
18037: LD_INT 35
18039: PPUSH
18040: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18044: LD_INT 14
18046: PPUSH
18047: LD_INT 22
18049: PUSH
18050: LD_INT 1
18052: PUSH
18053: EMPTY
18054: LIST
18055: LIST
18056: PPUSH
18057: CALL_OW 70
18061: PPUSH
18062: LD_INT 86
18064: PPUSH
18065: LD_INT 133
18067: PPUSH
18068: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18072: LD_INT 14
18074: PPUSH
18075: LD_INT 22
18077: PUSH
18078: LD_INT 1
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: PPUSH
18085: CALL_OW 70
18089: NOT
18090: IFFALSE 18037
// if powellAnger >= 3 then
18092: LD_EXP 17
18096: PUSH
18097: LD_INT 3
18099: GREATEREQUAL
18100: IFFALSE 18109
// YouLost ( Dismissed ) ;
18102: LD_STRING Dismissed
18104: PPUSH
18105: CALL_OW 104
// Video ( false ) ;
18109: LD_INT 0
18111: PPUSH
18112: CALL 106794 0 1
// end ; until missionStage > 5 ;
18116: LD_EXP 15
18120: PUSH
18121: LD_INT 5
18123: GREATER
18124: IFFALSE 17851
// end ;
18126: PPOPN 1
18128: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18129: LD_EXP 13
18133: PUSH
18134: LD_INT 22
18136: PUSH
18137: LD_INT 4
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: PUSH
18144: LD_INT 21
18146: PUSH
18147: LD_INT 2
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: PPUSH
18158: CALL_OW 69
18162: PUSH
18163: LD_INT 4
18165: GREATEREQUAL
18166: AND
18167: PUSH
18168: LD_EXP 15
18172: PUSH
18173: LD_INT 2
18175: EQUAL
18176: AND
18177: IFFALSE 20000
18179: GO 18181
18181: DISABLE
18182: LD_INT 0
18184: PPUSH
18185: PPUSH
18186: PPUSH
18187: PPUSH
18188: PPUSH
18189: PPUSH
18190: PPUSH
18191: PPUSH
// begin missionStage := 3 ;
18192: LD_ADDR_EXP 15
18196: PUSH
18197: LD_INT 3
18199: ST_TO_ADDR
// retreat := false ;
18200: LD_ADDR_VAR 0 4
18204: PUSH
18205: LD_INT 0
18207: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18208: LD_ADDR_VAR 0 5
18212: PUSH
18213: LD_INT 22
18215: PUSH
18216: LD_INT 4
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: PUSH
18223: LD_INT 30
18225: PUSH
18226: LD_INT 4
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: PPUSH
18237: CALL_OW 69
18241: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18242: LD_ADDR_VAR 0 6
18246: PUSH
18247: LD_INT 22
18249: PUSH
18250: LD_INT 4
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: PUSH
18257: LD_INT 30
18259: PUSH
18260: LD_INT 5
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: EMPTY
18268: LIST
18269: LIST
18270: PPUSH
18271: CALL_OW 69
18275: ST_TO_ADDR
// if not bar then
18276: LD_VAR 0 6
18280: NOT
18281: IFFALSE 18334
// begin repeat wait ( 0 0$1 ) ;
18283: LD_INT 35
18285: PPUSH
18286: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18290: LD_INT 22
18292: PUSH
18293: LD_INT 4
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 3
18302: PUSH
18303: LD_INT 57
18305: PUSH
18306: EMPTY
18307: LIST
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 5
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: LIST
18327: PPUSH
18328: CALL_OW 69
18332: IFFALSE 18283
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18334: LD_ADDR_VAR 0 6
18338: PUSH
18339: LD_INT 22
18341: PUSH
18342: LD_INT 4
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PUSH
18349: LD_INT 30
18351: PUSH
18352: LD_INT 5
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PPUSH
18363: CALL_OW 69
18367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18368: LD_INT 35
18370: PPUSH
18371: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18375: LD_EXP 118
18379: PUSH
18380: LD_INT 4
18382: ARRAY
18383: PUSH
18384: LD_INT 4
18386: GREATEREQUAL
18387: IFFALSE 18368
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18389: LD_ADDR_VAR 0 2
18393: PUSH
18394: LD_INT 22
18396: PUSH
18397: LD_INT 4
18399: PUSH
18400: EMPTY
18401: LIST
18402: LIST
18403: PUSH
18404: LD_INT 2
18406: PUSH
18407: LD_INT 25
18409: PUSH
18410: LD_INT 1
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: PUSH
18417: LD_INT 25
18419: PUSH
18420: LD_INT 2
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 25
18429: PUSH
18430: LD_INT 3
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 25
18439: PUSH
18440: LD_INT 4
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 25
18449: PUSH
18450: LD_INT 5
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: LIST
18463: LIST
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PPUSH
18469: CALL_OW 69
18473: PUSH
18474: LD_EXP 55
18478: PUSH
18479: LD_EXP 56
18483: ADD
18484: DIFF
18485: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18486: LD_ADDR_VAR 0 3
18490: PUSH
18491: LD_VAR 0 2
18495: PPUSH
18496: LD_INT 26
18498: PUSH
18499: LD_INT 1
18501: PUSH
18502: EMPTY
18503: LIST
18504: LIST
18505: PPUSH
18506: CALL_OW 72
18510: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18511: LD_ADDR_VAR 0 2
18515: PUSH
18516: LD_VAR 0 2
18520: PUSH
18521: LD_VAR 0 3
18525: DIFF
18526: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18527: LD_ADDR_VAR 0 2
18531: PUSH
18532: LD_VAR 0 2
18536: PPUSH
18537: LD_INT 1
18539: PPUSH
18540: CALL 105447 0 2
18544: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18545: LD_ADDR_VAR 0 3
18549: PUSH
18550: LD_VAR 0 3
18554: PPUSH
18555: LD_INT 1
18557: PPUSH
18558: CALL 105447 0 2
18562: ST_TO_ADDR
// for i = 1 to 4 do
18563: LD_ADDR_VAR 0 1
18567: PUSH
18568: DOUBLE
18569: LD_INT 1
18571: DEC
18572: ST_TO_ADDR
18573: LD_INT 4
18575: PUSH
18576: FOR_TO
18577: IFFALSE 18743
// begin if tmp2 then
18579: LD_VAR 0 3
18583: IFFALSE 18664
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18585: LD_ADDR_EXP 18
18589: PUSH
18590: LD_EXP 18
18594: PPUSH
18595: LD_INT 1
18597: PPUSH
18598: LD_EXP 18
18602: PUSH
18603: LD_INT 1
18605: ARRAY
18606: PUSH
18607: LD_VAR 0 3
18611: PUSH
18612: LD_VAR 0 3
18616: ARRAY
18617: ADD
18618: PPUSH
18619: CALL_OW 1
18623: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18624: LD_VAR 0 3
18628: PUSH
18629: LD_VAR 0 3
18633: ARRAY
18634: PPUSH
18635: LD_INT 1
18637: PPUSH
18638: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18642: LD_ADDR_VAR 0 3
18646: PUSH
18647: LD_VAR 0 3
18651: PPUSH
18652: LD_VAR 0 3
18656: PPUSH
18657: CALL_OW 3
18661: ST_TO_ADDR
// end else
18662: GO 18741
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18664: LD_ADDR_EXP 18
18668: PUSH
18669: LD_EXP 18
18673: PPUSH
18674: LD_INT 1
18676: PPUSH
18677: LD_EXP 18
18681: PUSH
18682: LD_INT 1
18684: ARRAY
18685: PUSH
18686: LD_VAR 0 2
18690: PUSH
18691: LD_VAR 0 2
18695: ARRAY
18696: ADD
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18703: LD_VAR 0 2
18707: PUSH
18708: LD_VAR 0 2
18712: ARRAY
18713: PPUSH
18714: LD_INT 1
18716: PPUSH
18717: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18721: LD_ADDR_VAR 0 2
18725: PUSH
18726: LD_VAR 0 2
18730: PPUSH
18731: LD_VAR 0 2
18735: PPUSH
18736: CALL_OW 3
18740: ST_TO_ADDR
// end ; end ;
18741: GO 18576
18743: POP
18744: POP
// if tmp2 then
18745: LD_VAR 0 3
18749: IFFALSE 18767
// tmp := tmp union tmp2 ;
18751: LD_ADDR_VAR 0 2
18755: PUSH
18756: LD_VAR 0 2
18760: PUSH
18761: LD_VAR 0 3
18765: UNION
18766: ST_TO_ADDR
// for i = 1 to 4 do
18767: LD_ADDR_VAR 0 1
18771: PUSH
18772: DOUBLE
18773: LD_INT 1
18775: DEC
18776: ST_TO_ADDR
18777: LD_INT 4
18779: PUSH
18780: FOR_TO
18781: IFFALSE 18830
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18783: LD_ADDR_EXP 18
18787: PUSH
18788: LD_EXP 18
18792: PPUSH
18793: LD_INT 2
18795: PPUSH
18796: LD_EXP 18
18800: PUSH
18801: LD_INT 2
18803: ARRAY
18804: PUSH
18805: LD_VAR 0 2
18809: PUSH
18810: LD_VAR 0 2
18814: PUSH
18815: LD_VAR 0 1
18819: MINUS
18820: ARRAY
18821: ADD
18822: PPUSH
18823: CALL_OW 1
18827: ST_TO_ADDR
18828: GO 18780
18830: POP
18831: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18832: LD_ADDR_EXP 99
18836: PUSH
18837: LD_EXP 99
18841: PPUSH
18842: LD_INT 4
18844: PPUSH
18845: LD_EXP 99
18849: PUSH
18850: LD_INT 4
18852: ARRAY
18853: PUSH
18854: LD_EXP 18
18858: PUSH
18859: LD_INT 1
18861: ARRAY
18862: DIFF
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18869: LD_VAR 0 5
18873: PUSH
18874: LD_INT 1
18876: ARRAY
18877: PPUSH
18878: CALL_OW 313
18882: IFFALSE 18937
// begin for i in UnitsInside ( arm [ 1 ] ) do
18884: LD_ADDR_VAR 0 1
18888: PUSH
18889: LD_VAR 0 5
18893: PUSH
18894: LD_INT 1
18896: ARRAY
18897: PPUSH
18898: CALL_OW 313
18902: PUSH
18903: FOR_IN
18904: IFFALSE 18935
// begin ComExitBuilding ( i ) ;
18906: LD_VAR 0 1
18910: PPUSH
18911: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18915: LD_VAR 0 1
18919: PPUSH
18920: LD_VAR 0 6
18924: PUSH
18925: LD_INT 1
18927: ARRAY
18928: PPUSH
18929: CALL_OW 180
// end ;
18933: GO 18903
18935: POP
18936: POP
// end ; wait ( 0 0$3 ) ;
18937: LD_INT 105
18939: PPUSH
18940: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18944: LD_ADDR_VAR 0 1
18948: PUSH
18949: LD_EXP 18
18953: PUSH
18954: LD_INT 1
18956: ARRAY
18957: PUSH
18958: FOR_IN
18959: IFFALSE 19066
// begin if IsInUnit ( i ) then
18961: LD_VAR 0 1
18965: PPUSH
18966: CALL_OW 310
18970: IFFALSE 18981
// ComExitBuilding ( i ) ;
18972: LD_VAR 0 1
18976: PPUSH
18977: CALL_OW 122
// if GetClass ( i ) <> 1 then
18981: LD_VAR 0 1
18985: PPUSH
18986: CALL_OW 257
18990: PUSH
18991: LD_INT 1
18993: NONEQUAL
18994: IFFALSE 19035
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18996: LD_VAR 0 1
19000: PPUSH
19001: LD_VAR 0 5
19005: PUSH
19006: LD_INT 1
19008: ARRAY
19009: PPUSH
19010: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19014: LD_VAR 0 1
19018: PPUSH
19019: LD_INT 1
19021: PPUSH
19022: CALL_OW 183
// AddComExitBuilding ( i ) ;
19026: LD_VAR 0 1
19030: PPUSH
19031: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19035: LD_VAR 0 1
19039: PPUSH
19040: LD_INT 60
19042: PPUSH
19043: LD_INT 94
19045: PPUSH
19046: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19050: LD_VAR 0 1
19054: PPUSH
19055: LD_EXP 55
19059: PPUSH
19060: CALL_OW 179
// end ;
19064: GO 18958
19066: POP
19067: POP
// wait ( 0 0$15 ) ;
19068: LD_INT 525
19070: PPUSH
19071: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19075: LD_EXP 55
19079: PPUSH
19080: LD_STRING D4-Pow-1
19082: PPUSH
19083: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19087: LD_ADDR_VAR 0 2
19091: PUSH
19092: LD_EXP 18
19096: PUSH
19097: LD_INT 1
19099: ARRAY
19100: PPUSH
19101: LD_INT 26
19103: PUSH
19104: LD_INT 1
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PPUSH
19111: CALL_OW 72
19115: ST_TO_ADDR
// if tmp then
19116: LD_VAR 0 2
19120: IFFALSE 19138
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19122: LD_VAR 0 2
19126: PUSH
19127: LD_INT 1
19129: ARRAY
19130: PPUSH
19131: LD_STRING D4-Sol1-1
19133: PPUSH
19134: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19138: LD_EXP 55
19142: PPUSH
19143: LD_STRING D4-Pow-2
19145: PPUSH
19146: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: DOUBLE
19156: LD_INT 1
19158: DEC
19159: ST_TO_ADDR
19160: LD_EXP 18
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: PUSH
19169: FOR_TO
19170: IFFALSE 19263
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19172: LD_EXP 18
19176: PUSH
19177: LD_INT 1
19179: ARRAY
19180: PUSH
19181: LD_VAR 0 1
19185: ARRAY
19186: PPUSH
19187: LD_EXP 118
19191: PUSH
19192: LD_INT 4
19194: ARRAY
19195: PUSH
19196: LD_INT 1
19198: ARRAY
19199: PPUSH
19200: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19204: LD_ADDR_EXP 118
19208: PUSH
19209: LD_EXP 118
19213: PPUSH
19214: LD_INT 4
19216: PPUSH
19217: LD_EXP 118
19221: PUSH
19222: LD_INT 4
19224: ARRAY
19225: PPUSH
19226: LD_INT 1
19228: PPUSH
19229: CALL_OW 3
19233: PPUSH
19234: CALL_OW 1
19238: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19239: LD_INT 8
19241: PPUSH
19242: LD_EXP 18
19246: PUSH
19247: LD_INT 1
19249: ARRAY
19250: PUSH
19251: LD_VAR 0 1
19255: ARRAY
19256: PPUSH
19257: CALL_OW 471
// end ;
19261: GO 19169
19263: POP
19264: POP
// repeat wait ( 0 0$1 ) ;
19265: LD_INT 35
19267: PPUSH
19268: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19272: LD_EXP 18
19276: PUSH
19277: LD_INT 1
19279: ARRAY
19280: PPUSH
19281: LD_INT 55
19283: PUSH
19284: EMPTY
19285: LIST
19286: PPUSH
19287: CALL_OW 72
19291: PUSH
19292: LD_INT 4
19294: GREATEREQUAL
19295: IFFALSE 19265
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19297: LD_EXP 18
19301: PUSH
19302: LD_INT 1
19304: ARRAY
19305: PPUSH
19306: LD_INT 69
19308: PPUSH
19309: LD_INT 94
19311: PPUSH
19312: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19316: LD_EXP 18
19320: PUSH
19321: LD_INT 1
19323: ARRAY
19324: PPUSH
19325: LD_INT 82
19327: PPUSH
19328: LD_INT 83
19330: PPUSH
19331: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19335: LD_EXP 18
19339: PUSH
19340: LD_INT 1
19342: ARRAY
19343: PPUSH
19344: LD_INT 77
19346: PPUSH
19347: LD_INT 69
19349: PPUSH
19350: CALL_OW 174
// repeat wait ( 3 ) ;
19354: LD_INT 3
19356: PPUSH
19357: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19361: LD_ADDR_VAR 0 1
19365: PUSH
19366: LD_EXP 18
19370: PUSH
19371: LD_INT 1
19373: ARRAY
19374: PUSH
19375: FOR_IN
19376: IFFALSE 19512
// begin if GetLives ( i ) < 990 then
19378: LD_VAR 0 1
19382: PPUSH
19383: CALL_OW 256
19387: PUSH
19388: LD_INT 990
19390: LESS
19391: IFFALSE 19405
// SetLives ( i , 1000 ) ;
19393: LD_VAR 0 1
19397: PPUSH
19398: LD_INT 1000
19400: PPUSH
19401: CALL_OW 234
// if not IsInUnit ( i ) then
19405: LD_VAR 0 1
19409: PPUSH
19410: CALL_OW 310
19414: NOT
19415: IFFALSE 19510
// begin if not HasTask ( i ) then
19417: LD_VAR 0 1
19421: PPUSH
19422: CALL_OW 314
19426: NOT
19427: IFFALSE 19444
// ComMoveXY ( i , 64 , 93 ) ;
19429: LD_VAR 0 1
19433: PPUSH
19434: LD_INT 64
19436: PPUSH
19437: LD_INT 93
19439: PPUSH
19440: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19444: LD_VAR 0 4
19448: NOT
19449: PUSH
19450: LD_VAR 0 1
19454: PPUSH
19455: CALL_OW 258
19459: PUSH
19460: LD_INT 1
19462: EQUAL
19463: AND
19464: IFFALSE 19510
// begin retreat := true ;
19466: LD_ADDR_VAR 0 4
19470: PUSH
19471: LD_INT 1
19473: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19474: LD_VAR 0 1
19478: PPUSH
19479: LD_INT 2
19481: PPUSH
19482: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19486: LD_VAR 0 1
19490: PPUSH
19491: LD_STRING D4a-Sol1-1
19493: PPUSH
19494: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19498: LD_EXP 55
19502: PPUSH
19503: LD_STRING D4a-Pow-1
19505: PPUSH
19506: CALL_OW 88
// end ; end ; end ;
19510: GO 19375
19512: POP
19513: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19514: LD_EXP 18
19518: PUSH
19519: LD_INT 1
19521: ARRAY
19522: PPUSH
19523: LD_INT 95
19525: PUSH
19526: LD_INT 9
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PUSH
19533: LD_INT 3
19535: PUSH
19536: LD_INT 55
19538: PUSH
19539: EMPTY
19540: LIST
19541: PUSH
19542: EMPTY
19543: LIST
19544: LIST
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: PPUSH
19550: CALL_OW 72
19554: PUSH
19555: LD_INT 4
19557: GREATEREQUAL
19558: IFFALSE 19354
// for i in powellSquadAttack [ 1 ] do
19560: LD_ADDR_VAR 0 1
19564: PUSH
19565: LD_EXP 18
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PUSH
19574: FOR_IN
19575: IFFALSE 19711
// begin if GetTag ( i ) = 2 then
19577: LD_VAR 0 1
19581: PPUSH
19582: CALL_OW 110
19586: PUSH
19587: LD_INT 2
19589: EQUAL
19590: IFFALSE 19652
// begin ComMoveXY ( i , 60 , 94 ) ;
19592: LD_VAR 0 1
19596: PPUSH
19597: LD_INT 60
19599: PPUSH
19600: LD_INT 94
19602: PPUSH
19603: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19607: LD_VAR 0 1
19611: PPUSH
19612: LD_EXP 55
19616: PPUSH
19617: CALL_OW 179
// wait ( 0 0$3 ) ;
19621: LD_INT 105
19623: PPUSH
19624: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19628: LD_VAR 0 1
19632: PPUSH
19633: LD_STRING D4a-Sol1-2
19635: PPUSH
19636: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19640: LD_EXP 55
19644: PPUSH
19645: LD_STRING D4a-Pow-2
19647: PPUSH
19648: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19652: LD_VAR 0 1
19656: PPUSH
19657: LD_INT 0
19659: PPUSH
19660: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19664: LD_ADDR_EXP 99
19668: PUSH
19669: LD_EXP 99
19673: PPUSH
19674: LD_INT 4
19676: PPUSH
19677: LD_EXP 99
19681: PUSH
19682: LD_INT 4
19684: ARRAY
19685: PUSH
19686: LD_VAR 0 1
19690: UNION
19691: PPUSH
19692: CALL_OW 1
19696: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19697: LD_INT 8
19699: PPUSH
19700: LD_VAR 0 1
19704: PPUSH
19705: CALL_OW 472
// end ;
19709: GO 19574
19711: POP
19712: POP
// wait ( 4 4$00 ) ;
19713: LD_INT 8400
19715: PPUSH
19716: CALL_OW 67
// uc_side := 6 ;
19720: LD_ADDR_OWVAR 20
19724: PUSH
19725: LD_INT 6
19727: ST_TO_ADDR
// uc_nation := 3 ;
19728: LD_ADDR_OWVAR 21
19732: PUSH
19733: LD_INT 3
19735: ST_TO_ADDR
// ru := [ ] ;
19736: LD_ADDR_VAR 0 7
19740: PUSH
19741: EMPTY
19742: ST_TO_ADDR
// for i = 1 to 4 do
19743: LD_ADDR_VAR 0 1
19747: PUSH
19748: DOUBLE
19749: LD_INT 1
19751: DEC
19752: ST_TO_ADDR
19753: LD_INT 4
19755: PUSH
19756: FOR_TO
19757: IFFALSE 19858
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19759: LD_INT 22
19761: PPUSH
19762: LD_INT 1
19764: PPUSH
19765: LD_INT 3
19767: PPUSH
19768: LD_INT 43
19770: PUSH
19771: LD_INT 44
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PUSH
19778: LD_INT 1
19780: PPUSH
19781: LD_INT 2
19783: PPUSH
19784: CALL_OW 12
19788: ARRAY
19789: PPUSH
19790: LD_INT 89
19792: PPUSH
19793: CALL 71077 0 5
// un := CreateVehicle ;
19797: LD_ADDR_VAR 0 8
19801: PUSH
19802: CALL_OW 45
19806: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19807: LD_VAR 0 8
19811: PPUSH
19812: LD_INT 4
19814: PPUSH
19815: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19819: LD_VAR 0 8
19823: PPUSH
19824: LD_INT 136
19826: PPUSH
19827: LD_INT 90
19829: PPUSH
19830: LD_INT 8
19832: PPUSH
19833: LD_INT 0
19835: PPUSH
19836: CALL_OW 50
// ru := ru ^ un ;
19840: LD_ADDR_VAR 0 7
19844: PUSH
19845: LD_VAR 0 7
19849: PUSH
19850: LD_VAR 0 8
19854: ADD
19855: ST_TO_ADDR
// end ;
19856: GO 19756
19858: POP
19859: POP
// if ru then
19860: LD_VAR 0 7
19864: IFFALSE 19881
// ComAgressiveMove ( ru , 80 , 92 ) ;
19866: LD_VAR 0 7
19870: PPUSH
19871: LD_INT 80
19873: PPUSH
19874: LD_INT 92
19876: PPUSH
19877: CALL_OW 114
// wait ( 8 8$00 ) ;
19881: LD_INT 16800
19883: PPUSH
19884: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19888: LD_INT 4
19890: PPUSH
19891: LD_INT 3
19893: PUSH
19894: LD_INT 1
19896: PUSH
19897: LD_INT 1
19899: PUSH
19900: LD_INT 5
19902: PUSH
19903: EMPTY
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: PUSH
19909: LD_INT 4
19911: PUSH
19912: LD_INT 1
19914: PUSH
19915: LD_INT 1
19917: PUSH
19918: LD_INT 6
19920: PUSH
19921: EMPTY
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: PUSH
19927: LD_INT 4
19929: PUSH
19930: LD_INT 1
19932: PUSH
19933: LD_INT 1
19935: PUSH
19936: LD_INT 7
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: LIST
19944: PUSH
19945: LD_INT 3
19947: PUSH
19948: LD_INT 1
19950: PUSH
19951: LD_INT 1
19953: PUSH
19954: LD_INT 7
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: PUSH
19963: LD_INT 3
19965: PUSH
19966: LD_INT 1
19968: PUSH
19969: LD_INT 1
19971: PUSH
19972: LD_INT 5
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: PPUSH
19988: CALL 57659 0 2
// missionStage := 4 ;
19992: LD_ADDR_EXP 15
19996: PUSH
19997: LD_INT 4
19999: ST_TO_ADDR
// end ;
20000: PPOPN 8
20002: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20003: LD_EXP 15
20007: PUSH
20008: LD_INT 4
20010: EQUAL
20011: PUSH
20012: LD_INT 22
20014: PUSH
20015: LD_INT 4
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: PUSH
20022: LD_INT 21
20024: PUSH
20025: LD_INT 2
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PPUSH
20036: CALL_OW 69
20040: PUSH
20041: LD_INT 5
20043: GREATEREQUAL
20044: AND
20045: IFFALSE 24138
20047: GO 20049
20049: DISABLE
20050: LD_INT 0
20052: PPUSH
20053: PPUSH
20054: PPUSH
20055: PPUSH
20056: PPUSH
20057: PPUSH
20058: PPUSH
20059: PPUSH
20060: PPUSH
20061: PPUSH
20062: PPUSH
20063: PPUSH
20064: PPUSH
// begin missionStage := 5 ;
20065: LD_ADDR_EXP 15
20069: PUSH
20070: LD_INT 5
20072: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20073: LD_ADDR_VAR 0 10
20077: PUSH
20078: LD_INT 22
20080: PUSH
20081: LD_INT 4
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 2
20090: PUSH
20091: LD_INT 30
20093: PUSH
20094: LD_INT 4
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: PUSH
20101: LD_INT 30
20103: PUSH
20104: LD_INT 5
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: PUSH
20111: EMPTY
20112: LIST
20113: LIST
20114: LIST
20115: PUSH
20116: EMPTY
20117: LIST
20118: LIST
20119: PPUSH
20120: CALL_OW 69
20124: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20125: LD_ADDR_VAR 0 6
20129: PUSH
20130: LD_INT 22
20132: PUSH
20133: LD_INT 4
20135: PUSH
20136: EMPTY
20137: LIST
20138: LIST
20139: PUSH
20140: LD_INT 21
20142: PUSH
20143: LD_INT 1
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: PUSH
20150: LD_INT 3
20152: PUSH
20153: LD_INT 25
20155: PUSH
20156: LD_INT 16
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: LD_INT 25
20172: PUSH
20173: LD_INT 12
20175: PUSH
20176: EMPTY
20177: LIST
20178: LIST
20179: PUSH
20180: EMPTY
20181: LIST
20182: LIST
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: PPUSH
20190: CALL_OW 69
20194: PUSH
20195: LD_EXP 55
20199: DIFF
20200: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20201: LD_ADDR_VAR 0 9
20205: PUSH
20206: LD_INT 22
20208: PUSH
20209: LD_INT 4
20211: PUSH
20212: EMPTY
20213: LIST
20214: LIST
20215: PUSH
20216: LD_INT 30
20218: PUSH
20219: LD_INT 3
20221: PUSH
20222: EMPTY
20223: LIST
20224: LIST
20225: PUSH
20226: EMPTY
20227: LIST
20228: LIST
20229: PPUSH
20230: CALL_OW 69
20234: PUSH
20235: LD_INT 1
20237: ARRAY
20238: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20239: LD_INT 35
20241: PPUSH
20242: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20246: LD_EXP 118
20250: PUSH
20251: LD_INT 4
20253: ARRAY
20254: PUSH
20255: LD_INT 5
20257: GREATEREQUAL
20258: PUSH
20259: LD_EXP 118
20263: PUSH
20264: LD_INT 4
20266: ARRAY
20267: PPUSH
20268: LD_INT 58
20270: PUSH
20271: EMPTY
20272: LIST
20273: PPUSH
20274: CALL_OW 72
20278: PUSH
20279: LD_INT 5
20281: GREATEREQUAL
20282: AND
20283: IFFALSE 20239
// powellAllowRetreat := false ;
20285: LD_ADDR_EXP 19
20289: PUSH
20290: LD_INT 0
20292: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20293: LD_INT 700
20295: PPUSH
20296: CALL_OW 67
// activeAttacks := false ;
20300: LD_ADDR_EXP 16
20304: PUSH
20305: LD_INT 0
20307: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20308: LD_INT 35
20310: PPUSH
20311: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20315: LD_INT 22
20317: PUSH
20318: LD_INT 6
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: PPUSH
20325: CALL_OW 69
20329: PUSH
20330: LD_INT 0
20332: EQUAL
20333: IFFALSE 20308
// tmp := mc_vehicles [ 4 ] ;
20335: LD_ADDR_VAR 0 3
20339: PUSH
20340: LD_EXP 118
20344: PUSH
20345: LD_INT 4
20347: ARRAY
20348: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20349: LD_ADDR_VAR 0 1
20353: PUSH
20354: DOUBLE
20355: LD_INT 1
20357: DEC
20358: ST_TO_ADDR
20359: LD_EXP 18
20363: PUSH
20364: FOR_TO
20365: IFFALSE 20626
// begin for j in powellSquadAttack [ i ] do
20367: LD_ADDR_VAR 0 2
20371: PUSH
20372: LD_EXP 18
20376: PUSH
20377: LD_VAR 0 1
20381: ARRAY
20382: PUSH
20383: FOR_IN
20384: IFFALSE 20622
// begin forces := forces diff j ;
20386: LD_ADDR_VAR 0 6
20390: PUSH
20391: LD_VAR 0 6
20395: PUSH
20396: LD_VAR 0 2
20400: DIFF
20401: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20402: LD_VAR 0 2
20406: PPUSH
20407: LD_INT 1
20409: PPUSH
20410: CALL_OW 109
// wait ( 0 0$2 ) ;
20414: LD_INT 70
20416: PPUSH
20417: CALL_OW 67
// if IsInUnit ( j ) then
20421: LD_VAR 0 2
20425: PPUSH
20426: CALL_OW 310
20430: IFFALSE 20441
// ComExitBuilding ( j ) ;
20432: LD_VAR 0 2
20436: PPUSH
20437: CALL_OW 122
// if GetClass ( j ) <> 1 then
20441: LD_VAR 0 2
20445: PPUSH
20446: CALL_OW 257
20450: PUSH
20451: LD_INT 1
20453: NONEQUAL
20454: IFFALSE 20534
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20456: LD_VAR 0 10
20460: PUSH
20461: LD_INT 1
20463: ARRAY
20464: PPUSH
20465: CALL_OW 313
20469: PUSH
20470: LD_INT 5
20472: GREATEREQUAL
20473: IFFALSE 20495
// AddComEnterUnit ( j , arm [ 2 ] ) else
20475: LD_VAR 0 2
20479: PPUSH
20480: LD_VAR 0 10
20484: PUSH
20485: LD_INT 2
20487: ARRAY
20488: PPUSH
20489: CALL_OW 180
20493: GO 20513
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20495: LD_VAR 0 2
20499: PPUSH
20500: LD_VAR 0 10
20504: PUSH
20505: LD_INT 1
20507: ARRAY
20508: PPUSH
20509: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20513: LD_VAR 0 2
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: CALL_OW 183
// AddComExitBuilding ( j ) ;
20525: LD_VAR 0 2
20529: PPUSH
20530: CALL_OW 182
// end ; if i = 2 then
20534: LD_VAR 0 1
20538: PUSH
20539: LD_INT 2
20541: EQUAL
20542: IFFALSE 20559
// AddComMoveXY ( j , 61 , 93 ) ;
20544: LD_VAR 0 2
20548: PPUSH
20549: LD_INT 61
20551: PPUSH
20552: LD_INT 93
20554: PPUSH
20555: CALL_OW 171
// if i = 1 then
20559: LD_VAR 0 1
20563: PUSH
20564: LD_INT 1
20566: EQUAL
20567: IFFALSE 20620
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20569: LD_VAR 0 2
20573: PPUSH
20574: LD_VAR 0 3
20578: PUSH
20579: LD_INT 1
20581: ARRAY
20582: PPUSH
20583: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20587: LD_ADDR_VAR 0 3
20591: PUSH
20592: LD_VAR 0 3
20596: PPUSH
20597: LD_INT 1
20599: PPUSH
20600: CALL_OW 3
20604: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20605: LD_VAR 0 2
20609: PPUSH
20610: LD_INT 69
20612: PPUSH
20613: LD_INT 94
20615: PPUSH
20616: CALL_OW 171
// end ; end ;
20620: GO 20383
20622: POP
20623: POP
// end ;
20624: GO 20364
20626: POP
20627: POP
// wait ( 0 0$55 ) ;
20628: LD_INT 1925
20630: PPUSH
20631: CALL_OW 67
// MC_Kill ( 4 ) ;
20635: LD_INT 4
20637: PPUSH
20638: CALL 34143 0 1
// tmp := UnitsInside ( fac ) ;
20642: LD_ADDR_VAR 0 3
20646: PUSH
20647: LD_VAR 0 9
20651: PPUSH
20652: CALL_OW 313
20656: ST_TO_ADDR
// if tmp then
20657: LD_VAR 0 3
20661: IFFALSE 20782
// for i in tmp do
20663: LD_ADDR_VAR 0 1
20667: PUSH
20668: LD_VAR 0 3
20672: PUSH
20673: FOR_IN
20674: IFFALSE 20780
// begin ComExitBuilding ( i ) ;
20676: LD_VAR 0 1
20680: PPUSH
20681: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20685: LD_VAR 0 10
20689: PUSH
20690: LD_INT 2
20692: ARRAY
20693: PPUSH
20694: CALL_OW 313
20698: PUSH
20699: LD_INT 6
20701: LESS
20702: IFFALSE 20724
// AddComEnterUnit ( i , arm [ 2 ] ) else
20704: LD_VAR 0 1
20708: PPUSH
20709: LD_VAR 0 10
20713: PUSH
20714: LD_INT 2
20716: ARRAY
20717: PPUSH
20718: CALL_OW 180
20722: GO 20778
// if UnitsInside ( arm [ 1 ] ) < 6 then
20724: LD_VAR 0 10
20728: PUSH
20729: LD_INT 1
20731: ARRAY
20732: PPUSH
20733: CALL_OW 313
20737: PUSH
20738: LD_INT 6
20740: LESS
20741: IFFALSE 20763
// AddComEnterUnit ( i , arm [ 1 ] ) else
20743: LD_VAR 0 1
20747: PPUSH
20748: LD_VAR 0 10
20752: PUSH
20753: LD_INT 1
20755: ARRAY
20756: PPUSH
20757: CALL_OW 180
20761: GO 20778
// AddComMoveXY ( i , 37 , 68 ) ;
20763: LD_VAR 0 1
20767: PPUSH
20768: LD_INT 37
20770: PPUSH
20771: LD_INT 68
20773: PPUSH
20774: CALL_OW 171
// end ;
20778: GO 20673
20780: POP
20781: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20782: LD_ADDR_VAR 0 11
20786: PUSH
20787: LD_VAR 0 6
20791: PPUSH
20792: LD_INT 26
20794: PUSH
20795: LD_INT 1
20797: PUSH
20798: EMPTY
20799: LIST
20800: LIST
20801: PPUSH
20802: CALL_OW 72
20806: PUSH
20807: LD_EXP 56
20811: DIFF
20812: ST_TO_ADDR
// if not speaker then
20813: LD_VAR 0 11
20817: NOT
20818: IFFALSE 20845
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20820: LD_ADDR_VAR 0 11
20824: PUSH
20825: LD_VAR 0 6
20829: PPUSH
20830: LD_INT 26
20832: PUSH
20833: LD_INT 1
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: PPUSH
20840: CALL_OW 72
20844: ST_TO_ADDR
// if speaker then
20845: LD_VAR 0 11
20849: IFFALSE 20865
// speaker := speaker [ 1 ] ;
20851: LD_ADDR_VAR 0 11
20855: PUSH
20856: LD_VAR 0 11
20860: PUSH
20861: LD_INT 1
20863: ARRAY
20864: ST_TO_ADDR
// Video ( true ) ;
20865: LD_INT 1
20867: PPUSH
20868: CALL 106794 0 1
// CenterNowOnUnits ( Powell ) ;
20872: LD_EXP 55
20876: PPUSH
20877: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20881: LD_ADDR_VAR 0 3
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_INT 3
20893: PUSH
20894: LD_INT 25
20896: PUSH
20897: LD_INT 1
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: PPUSH
20908: CALL_OW 72
20912: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20913: LD_ADDR_VAR 0 12
20917: PUSH
20918: LD_INT 22
20920: PUSH
20921: LD_INT 4
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: PUSH
20928: LD_INT 30
20930: PUSH
20931: LD_INT 32
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PUSH
20938: LD_INT 58
20940: PUSH
20941: EMPTY
20942: LIST
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: LIST
20948: PPUSH
20949: CALL_OW 69
20953: ST_TO_ADDR
// for i = 1 to 6 do
20954: LD_ADDR_VAR 0 1
20958: PUSH
20959: DOUBLE
20960: LD_INT 1
20962: DEC
20963: ST_TO_ADDR
20964: LD_INT 6
20966: PUSH
20967: FOR_TO
20968: IFFALSE 21109
// begin if IsInUnit ( tmp [ i ] ) then
20970: LD_VAR 0 3
20974: PUSH
20975: LD_VAR 0 1
20979: ARRAY
20980: PPUSH
20981: CALL_OW 310
20985: IFFALSE 21002
// ComExitBuilding ( tmp [ i ] ) ;
20987: LD_VAR 0 3
20991: PUSH
20992: LD_VAR 0 1
20996: ARRAY
20997: PPUSH
20998: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21002: LD_VAR 0 3
21006: PUSH
21007: LD_VAR 0 1
21011: ARRAY
21012: PPUSH
21013: LD_VAR 0 10
21017: PUSH
21018: LD_INT 1
21020: ARRAY
21021: PPUSH
21022: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21026: LD_VAR 0 3
21030: PUSH
21031: LD_VAR 0 1
21035: ARRAY
21036: PPUSH
21037: LD_INT 1
21039: PPUSH
21040: CALL_OW 183
// if emp_towers then
21044: LD_VAR 0 12
21048: IFFALSE 21107
// begin AddComExitBuilding ( tmp [ i ] ) ;
21050: LD_VAR 0 3
21054: PUSH
21055: LD_VAR 0 1
21059: ARRAY
21060: PPUSH
21061: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21065: LD_VAR 0 3
21069: PUSH
21070: LD_VAR 0 1
21074: ARRAY
21075: PPUSH
21076: LD_VAR 0 12
21080: PUSH
21081: LD_INT 1
21083: ARRAY
21084: PPUSH
21085: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21089: LD_ADDR_VAR 0 12
21093: PUSH
21094: LD_VAR 0 12
21098: PPUSH
21099: LD_INT 1
21101: PPUSH
21102: CALL_OW 3
21106: ST_TO_ADDR
// end ; end ;
21107: GO 20967
21109: POP
21110: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: LD_EXP 18
21120: PUSH
21121: LD_INT 1
21123: ARRAY
21124: PUSH
21125: LD_EXP 18
21129: PUSH
21130: LD_INT 2
21132: ARRAY
21133: ADD
21134: PPUSH
21135: LD_INT 26
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PPUSH
21145: CALL_OW 72
21149: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21150: LD_ADDR_VAR 0 1
21154: PUSH
21155: LD_EXP 18
21159: PUSH
21160: LD_INT 2
21162: ARRAY
21163: PUSH
21164: FOR_IN
21165: IFFALSE 21183
// ComTurnUnit ( i , Powell ) ;
21167: LD_VAR 0 1
21171: PPUSH
21172: LD_EXP 55
21176: PPUSH
21177: CALL_OW 119
21181: GO 21164
21183: POP
21184: POP
// Say ( Powell , D5-Pow-1 ) ;
21185: LD_EXP 55
21189: PPUSH
21190: LD_STRING D5-Pow-1
21192: PPUSH
21193: CALL_OW 88
// if tmp then
21197: LD_VAR 0 3
21201: IFFALSE 21219
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21203: LD_VAR 0 3
21207: PUSH
21208: LD_INT 1
21210: ARRAY
21211: PPUSH
21212: LD_STRING D5-Sol2-1
21214: PPUSH
21215: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21219: LD_EXP 55
21223: PPUSH
21224: LD_STRING D5-Pow-2
21226: PPUSH
21227: CALL_OW 88
// if tmp > 1 then
21231: LD_VAR 0 3
21235: PUSH
21236: LD_INT 1
21238: GREATER
21239: IFFALSE 21257
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21241: LD_VAR 0 3
21245: PUSH
21246: LD_INT 2
21248: ARRAY
21249: PPUSH
21250: LD_STRING D5-Sol2-2
21252: PPUSH
21253: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21257: LD_EXP 55
21261: PPUSH
21262: LD_STRING D5-Pow-3
21264: PPUSH
21265: CALL_OW 88
// wait ( 0 0$1 ) ;
21269: LD_INT 35
21271: PPUSH
21272: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21276: LD_ADDR_VAR 0 3
21280: PUSH
21281: LD_EXP 18
21285: PUSH
21286: LD_INT 1
21288: ARRAY
21289: PUSH
21290: LD_EXP 18
21294: PUSH
21295: LD_INT 2
21297: ARRAY
21298: UNION
21299: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21300: LD_VAR 0 3
21304: PPUSH
21305: LD_INT 80
21307: PPUSH
21308: LD_INT 67
21310: PPUSH
21311: CALL_OW 114
// wait ( 0 0$2 ) ;
21315: LD_INT 70
21317: PPUSH
21318: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21322: LD_INT 79
21324: PPUSH
21325: LD_INT 72
21327: PPUSH
21328: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21332: LD_INT 35
21334: PPUSH
21335: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21339: LD_VAR 0 3
21343: PPUSH
21344: LD_INT 3
21346: PUSH
21347: LD_INT 24
21349: PUSH
21350: LD_INT 1000
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: PUSH
21357: EMPTY
21358: LIST
21359: LIST
21360: PPUSH
21361: CALL_OW 72
21365: IFFALSE 21332
// Say ( Powell , D5a-Pow-1 ) ;
21367: LD_EXP 55
21371: PPUSH
21372: LD_STRING D5a-Pow-1
21374: PPUSH
21375: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21379: LD_EXP 55
21383: PPUSH
21384: LD_STRING D5a-Pow-1a
21386: PPUSH
21387: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21391: LD_INT 10
21393: PPUSH
21394: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21398: LD_EXP 55
21402: PPUSH
21403: LD_STRING D5a-Pow-1b
21405: PPUSH
21406: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21410: LD_EXP 55
21414: PPUSH
21415: LD_STRING D5a-Pow-1c
21417: PPUSH
21418: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21422: LD_EXP 55
21426: PPUSH
21427: LD_STRING D5a-Pow-1d
21429: PPUSH
21430: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21434: LD_INT 35
21436: PPUSH
21437: CALL_OW 67
// if not HasTask ( tmp ) then
21441: LD_VAR 0 3
21445: PPUSH
21446: CALL_OW 314
21450: NOT
21451: IFFALSE 21468
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21453: LD_VAR 0 3
21457: PPUSH
21458: LD_INT 80
21460: PPUSH
21461: LD_INT 67
21463: PPUSH
21464: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21468: LD_VAR 0 3
21472: PPUSH
21473: LD_INT 24
21475: PUSH
21476: LD_INT 1
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: PPUSH
21483: CALL_OW 72
21487: NOT
21488: IFFALSE 21434
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21490: LD_ADDR_VAR 0 3
21494: PUSH
21495: LD_INT 22
21497: PUSH
21498: LD_INT 4
21500: PUSH
21501: EMPTY
21502: LIST
21503: LIST
21504: PUSH
21505: LD_INT 92
21507: PUSH
21508: LD_INT 60
21510: PUSH
21511: LD_INT 93
21513: PUSH
21514: LD_INT 10
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: LIST
21521: LIST
21522: PUSH
21523: LD_INT 3
21525: PUSH
21526: LD_INT 54
21528: PUSH
21529: EMPTY
21530: LIST
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: PUSH
21536: EMPTY
21537: LIST
21538: LIST
21539: LIST
21540: PPUSH
21541: CALL_OW 69
21545: PUSH
21546: LD_EXP 55
21550: DIFF
21551: ST_TO_ADDR
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21590
// for i in tmp do
21558: LD_ADDR_VAR 0 1
21562: PUSH
21563: LD_VAR 0 3
21567: PUSH
21568: FOR_IN
21569: IFFALSE 21588
// ComMoveXY ( i , 36 , 67 ) ;
21571: LD_VAR 0 1
21575: PPUSH
21576: LD_INT 36
21578: PPUSH
21579: LD_INT 67
21581: PPUSH
21582: CALL_OW 111
21586: GO 21568
21588: POP
21589: POP
// wait ( 0 0$3 ) ;
21590: LD_INT 105
21592: PPUSH
21593: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21597: LD_VAR 0 11
21601: PPUSH
21602: LD_STRING D6-Sol3-1
21604: PPUSH
21605: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21609: LD_EXP 55
21613: PPUSH
21614: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21618: LD_EXP 55
21622: PPUSH
21623: LD_STRING D6-Pow-1
21625: PPUSH
21626: CALL_OW 88
// tmp := [ ] ;
21630: LD_ADDR_VAR 0 3
21634: PUSH
21635: EMPTY
21636: ST_TO_ADDR
// for i = 1 to 2 do
21637: LD_ADDR_VAR 0 1
21641: PUSH
21642: DOUBLE
21643: LD_INT 1
21645: DEC
21646: ST_TO_ADDR
21647: LD_INT 2
21649: PUSH
21650: FOR_TO
21651: IFFALSE 21765
// begin uc_side := 8 ;
21653: LD_ADDR_OWVAR 20
21657: PUSH
21658: LD_INT 8
21660: ST_TO_ADDR
// uc_nation := 2 ;
21661: LD_ADDR_OWVAR 21
21665: PUSH
21666: LD_INT 2
21668: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21669: LD_INT 14
21671: PPUSH
21672: LD_INT 3
21674: PPUSH
21675: LD_INT 2
21677: PPUSH
21678: LD_INT 29
21680: PPUSH
21681: LD_INT 100
21683: PPUSH
21684: CALL 71077 0 5
// veh := CreateVehicle ;
21688: LD_ADDR_VAR 0 13
21692: PUSH
21693: CALL_OW 45
21697: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21698: LD_VAR 0 13
21702: PPUSH
21703: LD_INT 4
21705: PPUSH
21706: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21710: LD_VAR 0 13
21714: PPUSH
21715: LD_INT 99
21717: PPUSH
21718: LD_INT 83
21720: PPUSH
21721: LD_INT 6
21723: PPUSH
21724: LD_INT 0
21726: PPUSH
21727: CALL_OW 50
// wait ( 3 ) ;
21731: LD_INT 3
21733: PPUSH
21734: CALL_OW 67
// Connect ( veh ) ;
21738: LD_VAR 0 13
21742: PPUSH
21743: CALL 74132 0 1
// tmp := tmp ^ veh ;
21747: LD_ADDR_VAR 0 3
21751: PUSH
21752: LD_VAR 0 3
21756: PUSH
21757: LD_VAR 0 13
21761: ADD
21762: ST_TO_ADDR
// end ;
21763: GO 21650
21765: POP
21766: POP
// wait ( 0 0$1 ) ;
21767: LD_INT 35
21769: PPUSH
21770: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21774: LD_INT 99
21776: PPUSH
21777: LD_INT 83
21779: PPUSH
21780: LD_INT 1
21782: PPUSH
21783: LD_INT 10
21785: PPUSH
21786: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21790: LD_INT 99
21792: PPUSH
21793: LD_INT 83
21795: PPUSH
21796: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21800: LD_VAR 0 11
21804: PPUSH
21805: LD_STRING D6-Sol3-2
21807: PPUSH
21808: CALL_OW 88
// async ;
21812: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21813: LD_EXP 55
21817: PPUSH
21818: LD_STRING D6-Pow-2
21820: PPUSH
21821: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21825: LD_VAR 0 3
21829: PUSH
21830: LD_INT 1
21832: ARRAY
21833: PPUSH
21834: LD_VAR 0 9
21838: PPUSH
21839: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21843: LD_VAR 0 3
21847: PUSH
21848: LD_INT 2
21850: ARRAY
21851: PPUSH
21852: LD_INT 22
21854: PUSH
21855: LD_INT 4
21857: PUSH
21858: EMPTY
21859: LIST
21860: LIST
21861: PUSH
21862: LD_INT 21
21864: PUSH
21865: LD_INT 3
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PPUSH
21876: CALL_OW 69
21880: PPUSH
21881: LD_VAR 0 3
21885: PUSH
21886: LD_INT 2
21888: ARRAY
21889: PPUSH
21890: CALL_OW 74
21894: PPUSH
21895: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21899: LD_EXP 55
21903: PPUSH
21904: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21908: LD_INT 99
21910: PPUSH
21911: LD_INT 83
21913: PPUSH
21914: LD_INT 1
21916: PPUSH
21917: CALL_OW 331
// repeat wait ( 4 ) ;
21921: LD_INT 4
21923: PPUSH
21924: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21928: LD_VAR 0 3
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PPUSH
21937: CALL_OW 256
21941: PUSH
21942: LD_INT 1000
21944: LESS
21945: IFFALSE 21963
// SetLives ( tmp [ 1 ] , 1000 ) ;
21947: LD_VAR 0 3
21951: PUSH
21952: LD_INT 1
21954: ARRAY
21955: PPUSH
21956: LD_INT 1000
21958: PPUSH
21959: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21963: LD_INT 22
21965: PUSH
21966: LD_INT 4
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: PUSH
21973: LD_INT 30
21975: PUSH
21976: LD_INT 3
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PUSH
21983: EMPTY
21984: LIST
21985: LIST
21986: PPUSH
21987: CALL_OW 69
21991: PUSH
21992: LD_INT 0
21994: EQUAL
21995: IFFALSE 21921
// sync ;
21997: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21998: LD_EXP 55
22002: PPUSH
22003: LD_STRING D6a-Pow-1
22005: PPUSH
22006: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22010: LD_VAR 0 11
22014: PPUSH
22015: LD_STRING D6a-Sol3-1
22017: PPUSH
22018: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22022: LD_EXP 55
22026: PPUSH
22027: LD_STRING D6a-Pow-2
22029: PPUSH
22030: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22034: LD_VAR 0 11
22038: PPUSH
22039: LD_STRING D6a-Sol3-2
22041: PPUSH
22042: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22046: LD_EXP 55
22050: PPUSH
22051: LD_STRING D6a-Pow-3
22053: PPUSH
22054: CALL_OW 88
// powellCenterCameraMode := true ;
22058: LD_ADDR_EXP 20
22062: PUSH
22063: LD_INT 1
22065: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22066: LD_ADDR_VAR 0 1
22070: PUSH
22071: LD_INT 22
22073: PUSH
22074: LD_INT 8
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: PUSH
22081: LD_INT 25
22083: PUSH
22084: LD_INT 2
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PPUSH
22095: CALL_OW 69
22099: PUSH
22100: FOR_IN
22101: IFFALSE 22156
// begin SetTag ( i , 1 ) ;
22103: LD_VAR 0 1
22107: PPUSH
22108: LD_INT 1
22110: PPUSH
22111: CALL_OW 109
// ComExitBuilding ( i ) ;
22115: LD_VAR 0 1
22119: PPUSH
22120: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22124: LD_VAR 0 1
22128: PPUSH
22129: LD_INT 35
22131: PPUSH
22132: LD_INT 6
22134: PPUSH
22135: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22139: LD_VAR 0 1
22143: PPUSH
22144: LD_INT 53
22146: PPUSH
22147: LD_INT 4
22149: PPUSH
22150: CALL_OW 171
// end ;
22154: GO 22100
22156: POP
22157: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22158: LD_ADDR_VAR 0 3
22162: PUSH
22163: LD_INT 22
22165: PUSH
22166: LD_INT 4
22168: PUSH
22169: EMPTY
22170: LIST
22171: LIST
22172: PUSH
22173: LD_INT 21
22175: PUSH
22176: LD_INT 2
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: PUSH
22183: LD_INT 3
22185: PUSH
22186: LD_INT 34
22188: PUSH
22189: LD_INT 12
22191: PUSH
22192: EMPTY
22193: LIST
22194: LIST
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: PUSH
22200: EMPTY
22201: LIST
22202: LIST
22203: LIST
22204: PPUSH
22205: CALL_OW 69
22209: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22210: LD_EXP 55
22214: PPUSH
22215: LD_VAR 0 3
22219: PPUSH
22220: LD_EXP 55
22224: PPUSH
22225: CALL_OW 74
22229: PPUSH
22230: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22234: LD_EXP 55
22238: PPUSH
22239: LD_INT 100
22241: PPUSH
22242: LD_INT 88
22244: PPUSH
22245: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22249: LD_EXP 55
22253: PPUSH
22254: LD_INT 100
22256: PPUSH
22257: LD_INT 75
22259: PPUSH
22260: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22264: LD_EXP 55
22268: PPUSH
22269: LD_INT 88
22271: PPUSH
22272: LD_INT 53
22274: PPUSH
22275: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22279: LD_INT 8
22281: PPUSH
22282: LD_EXP 55
22286: PPUSH
22287: CALL_OW 471
// repeat wait ( 3 ) ;
22291: LD_INT 3
22293: PPUSH
22294: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22298: LD_INT 22
22300: PUSH
22301: LD_INT 4
22303: PUSH
22304: EMPTY
22305: LIST
22306: LIST
22307: PUSH
22308: LD_INT 92
22310: PUSH
22311: LD_INT 100
22313: PUSH
22314: LD_INT 75
22316: PUSH
22317: LD_INT 6
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: LIST
22324: LIST
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL_OW 69
22334: IFFALSE 22291
// async ;
22336: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22337: LD_EXP 55
22341: PPUSH
22342: LD_STRING D6b-Pow-1
22344: PPUSH
22345: CALL_OW 88
// repeat wait ( 3 ) ;
22349: LD_INT 3
22351: PPUSH
22352: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22356: LD_EXP 55
22360: PPUSH
22361: CALL_OW 310
22365: PPUSH
22366: CALL_OW 256
22370: PUSH
22371: LD_INT 1000
22373: LESS
22374: IFFALSE 22393
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22376: LD_EXP 55
22380: PPUSH
22381: CALL_OW 310
22385: PPUSH
22386: LD_INT 1000
22388: PPUSH
22389: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22393: LD_EXP 55
22397: PPUSH
22398: CALL_OW 256
22402: PUSH
22403: LD_INT 1000
22405: LESS
22406: IFFALSE 22420
// SetLives ( Powell , 1000 ) ;
22408: LD_EXP 55
22412: PPUSH
22413: LD_INT 1000
22415: PPUSH
22416: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22420: LD_EXP 55
22424: PPUSH
22425: LD_EXP 60
22429: PPUSH
22430: CALL_OW 296
22434: PUSH
22435: LD_INT 5
22437: LESS
22438: PUSH
22439: LD_EXP 55
22443: PPUSH
22444: CALL_OW 310
22448: PPUSH
22449: LD_EXP 60
22453: PPUSH
22454: CALL_OW 296
22458: PUSH
22459: LD_INT 5
22461: LESS
22462: OR
22463: IFFALSE 22482
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22465: LD_EXP 55
22469: PPUSH
22470: CALL_OW 310
22474: PPUSH
22475: LD_INT 100
22477: PPUSH
22478: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22482: LD_EXP 55
22486: PPUSH
22487: CALL_OW 310
22491: NOT
22492: IFFALSE 22349
// game_speed := 4 ;
22494: LD_ADDR_OWVAR 65
22498: PUSH
22499: LD_INT 4
22501: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22502: LD_EXP 55
22506: PPUSH
22507: LD_STRING D6b-Pow-1a
22509: PPUSH
22510: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22514: LD_EXP 55
22518: PPUSH
22519: LD_EXP 60
22523: PPUSH
22524: CALL_OW 180
// sync ;
22528: SYNC
// repeat wait ( 0 0$1 ) ;
22529: LD_INT 35
22531: PPUSH
22532: CALL_OW 67
// until IsInUnit ( Powell ) ;
22536: LD_EXP 55
22540: PPUSH
22541: CALL_OW 310
22545: IFFALSE 22529
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22547: LD_INT 8
22549: PPUSH
22550: LD_EXP 55
22554: PPUSH
22555: CALL_OW 310
22559: PPUSH
22560: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22564: LD_EXP 55
22568: PPUSH
22569: LD_INT 91
22571: PPUSH
22572: LD_INT 44
22574: PPUSH
22575: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22579: LD_EXP 55
22583: PPUSH
22584: LD_INT 96
22586: PPUSH
22587: LD_INT 44
22589: PPUSH
22590: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22594: LD_EXP 55
22598: PPUSH
22599: LD_INT 96
22601: PPUSH
22602: LD_INT 41
22604: PPUSH
22605: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22609: LD_EXP 55
22613: PPUSH
22614: LD_INT 92
22616: PPUSH
22617: LD_INT 39
22619: PPUSH
22620: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22624: LD_EXP 55
22628: PPUSH
22629: LD_INT 88
22631: PPUSH
22632: LD_INT 41
22634: PPUSH
22635: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22639: LD_EXP 55
22643: PPUSH
22644: LD_INT 91
22646: PPUSH
22647: LD_INT 44
22649: PPUSH
22650: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22654: LD_EXP 55
22658: PPUSH
22659: LD_INT 96
22661: PPUSH
22662: LD_INT 44
22664: PPUSH
22665: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22669: LD_EXP 55
22673: PPUSH
22674: LD_INT 96
22676: PPUSH
22677: LD_INT 41
22679: PPUSH
22680: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22684: LD_EXP 55
22688: PPUSH
22689: LD_INT 92
22691: PPUSH
22692: LD_INT 39
22694: PPUSH
22695: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22699: LD_EXP 55
22703: PPUSH
22704: LD_INT 88
22706: PPUSH
22707: LD_INT 41
22709: PPUSH
22710: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22714: LD_EXP 55
22718: PPUSH
22719: LD_INT 91
22721: PPUSH
22722: LD_INT 44
22724: PPUSH
22725: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22729: LD_EXP 55
22733: PPUSH
22734: LD_INT 93
22736: PPUSH
22737: LD_INT 39
22739: PPUSH
22740: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22744: LD_EXP 55
22748: PPUSH
22749: LD_INT 93
22751: PPUSH
22752: LD_INT 36
22754: PPUSH
22755: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22759: LD_INT 122
22761: PPUSH
22762: CALL_OW 67
// game_speed := 4 ;
22766: LD_ADDR_OWVAR 65
22770: PUSH
22771: LD_INT 4
22773: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22774: LD_EXP 55
22778: PPUSH
22779: LD_STRING D6b-Pow-1b
22781: PPUSH
22782: CALL_OW 88
// tmp := [ ] ;
22786: LD_ADDR_VAR 0 3
22790: PUSH
22791: EMPTY
22792: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22793: LD_ADDR_VAR 0 5
22797: PUSH
22798: LD_INT 78
22800: PUSH
22801: LD_INT 47
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: PUSH
22808: LD_INT 106
22810: PUSH
22811: LD_INT 53
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22822: LD_ADDR_VAR 0 1
22826: PUSH
22827: LD_INT 22
22829: PUSH
22830: LD_INT 8
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: PUSH
22837: LD_INT 21
22839: PUSH
22840: LD_INT 3
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 92
22849: PUSH
22850: LD_INT 90
22852: PUSH
22853: LD_INT 52
22855: PUSH
22856: LD_INT 12
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 69
22874: PUSH
22875: FOR_IN
22876: IFFALSE 22901
// tmp := tmp ^ UnitsInside ( i ) ;
22878: LD_ADDR_VAR 0 3
22882: PUSH
22883: LD_VAR 0 3
22887: PUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: CALL_OW 313
22897: ADD
22898: ST_TO_ADDR
22899: GO 22875
22901: POP
22902: POP
// for i in tmp do
22903: LD_ADDR_VAR 0 1
22907: PUSH
22908: LD_VAR 0 3
22912: PUSH
22913: FOR_IN
22914: IFFALSE 23076
// begin dist := 9999 ;
22916: LD_ADDR_VAR 0 8
22920: PUSH
22921: LD_INT 9999
22923: ST_TO_ADDR
// _xy := [ ] ;
22924: LD_ADDR_VAR 0 7
22928: PUSH
22929: EMPTY
22930: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22931: LD_VAR 0 1
22935: PPUSH
22936: LD_INT 1
22938: PPUSH
22939: CALL_OW 109
// ComExitBuilding ( i ) ;
22943: LD_VAR 0 1
22947: PPUSH
22948: CALL_OW 122
// for j in xy do
22952: LD_ADDR_VAR 0 2
22956: PUSH
22957: LD_VAR 0 5
22961: PUSH
22962: FOR_IN
22963: IFFALSE 23045
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22965: LD_VAR 0 1
22969: PPUSH
22970: LD_VAR 0 2
22974: PUSH
22975: LD_INT 1
22977: ARRAY
22978: PPUSH
22979: LD_VAR 0 2
22983: PUSH
22984: LD_INT 2
22986: ARRAY
22987: PPUSH
22988: CALL_OW 297
22992: PUSH
22993: LD_VAR 0 8
22997: LESS
22998: IFFALSE 23043
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23000: LD_ADDR_VAR 0 8
23004: PUSH
23005: LD_VAR 0 1
23009: PPUSH
23010: LD_VAR 0 2
23014: PUSH
23015: LD_INT 1
23017: ARRAY
23018: PPUSH
23019: LD_VAR 0 2
23023: PUSH
23024: LD_INT 2
23026: ARRAY
23027: PPUSH
23028: CALL_OW 297
23032: ST_TO_ADDR
// _xy := j ;
23033: LD_ADDR_VAR 0 7
23037: PUSH
23038: LD_VAR 0 2
23042: ST_TO_ADDR
// end ;
23043: GO 22962
23045: POP
23046: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23047: LD_VAR 0 1
23051: PPUSH
23052: LD_VAR 0 7
23056: PUSH
23057: LD_INT 1
23059: ARRAY
23060: PPUSH
23061: LD_VAR 0 7
23065: PUSH
23066: LD_INT 2
23068: ARRAY
23069: PPUSH
23070: CALL_OW 171
// end ;
23074: GO 22913
23076: POP
23077: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23078: LD_ADDR_VAR 0 4
23082: PUSH
23083: LD_VAR 0 3
23087: PPUSH
23088: LD_INT 26
23090: PUSH
23091: LD_INT 1
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: PUSH
23098: LD_INT 25
23100: PUSH
23101: LD_INT 1
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: PPUSH
23112: CALL_OW 72
23116: ST_TO_ADDR
// if tmp2 < 2 then
23117: LD_VAR 0 4
23121: PUSH
23122: LD_INT 2
23124: LESS
23125: IFFALSE 23194
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23127: LD_ADDR_VAR 0 4
23131: PUSH
23132: LD_INT 22
23134: PUSH
23135: LD_INT 8
23137: PUSH
23138: EMPTY
23139: LIST
23140: LIST
23141: PUSH
23142: LD_INT 26
23144: PUSH
23145: LD_INT 1
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: PUSH
23152: LD_INT 3
23154: PUSH
23155: LD_INT 25
23157: PUSH
23158: LD_INT 15
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: LIST
23173: PPUSH
23174: CALL_OW 69
23178: PUSH
23179: LD_EXP 57
23183: PUSH
23184: LD_EXP 58
23188: PUSH
23189: EMPTY
23190: LIST
23191: LIST
23192: DIFF
23193: ST_TO_ADDR
// if tmp2 then
23194: LD_VAR 0 4
23198: IFFALSE 23216
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23200: LD_VAR 0 4
23204: PUSH
23205: LD_INT 1
23207: ARRAY
23208: PPUSH
23209: LD_STRING D6b-ArSol1-1
23211: PPUSH
23212: CALL_OW 88
// async ;
23216: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23217: LD_EXP 55
23221: PPUSH
23222: LD_STRING D6b-Pow-2
23224: PPUSH
23225: CALL_OW 88
// wait ( 0 0$1 ) ;
23229: LD_INT 35
23231: PPUSH
23232: CALL_OW 67
// if tmp2 > 1 then
23236: LD_VAR 0 4
23240: PUSH
23241: LD_INT 1
23243: GREATER
23244: IFFALSE 23262
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23246: LD_VAR 0 4
23250: PUSH
23251: LD_INT 2
23253: ARRAY
23254: PPUSH
23255: LD_STRING D6b-ArSol2-1
23257: PPUSH
23258: CALL_OW 88
// sync ;
23262: SYNC
// repeat wait ( 5 ) ;
23263: LD_INT 5
23265: PPUSH
23266: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23270: LD_INT 93
23272: PPUSH
23273: LD_INT 36
23275: PPUSH
23276: CALL_OW 428
23280: PPUSH
23281: CALL_OW 255
23285: PUSH
23286: LD_INT 4
23288: EQUAL
23289: IFFALSE 23263
// DialogueOn ;
23291: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23295: LD_INT 10
23297: PPUSH
23298: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23302: LD_EXP 55
23306: PPUSH
23307: LD_STRING D6b-Pow-2a
23309: PPUSH
23310: CALL_OW 88
// DialogueOff ;
23314: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23318: LD_EXP 55
23322: PPUSH
23323: CALL_OW 310
23327: PPUSH
23328: LD_INT 332
23330: PPUSH
23331: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23335: LD_INT 93
23337: PPUSH
23338: LD_INT 35
23340: PPUSH
23341: LD_INT 1
23343: PPUSH
23344: LD_INT 6
23346: NEG
23347: PPUSH
23348: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23352: LD_INT 35
23354: PPUSH
23355: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23359: LD_INT 332
23361: PPUSH
23362: CALL_OW 256
23366: PUSH
23367: LD_INT 1000
23369: LESS
23370: PUSH
23371: LD_INT 332
23373: PPUSH
23374: CALL_OW 300
23378: AND
23379: IFFALSE 23391
// SetLives ( kozlov_fac , 0 ) ;
23381: LD_INT 332
23383: PPUSH
23384: LD_INT 0
23386: PPUSH
23387: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23391: LD_INT 332
23393: PPUSH
23394: CALL_OW 301
23398: PUSH
23399: LD_EXP 55
23403: PPUSH
23404: CALL_OW 301
23408: OR
23409: IFFALSE 23352
// game_speed := 4 ;
23411: LD_ADDR_OWVAR 65
23415: PUSH
23416: LD_INT 4
23418: ST_TO_ADDR
// powellCenterCameraMode := false ;
23419: LD_ADDR_EXP 20
23423: PUSH
23424: LD_INT 0
23426: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23427: LD_ADDR_VAR 0 1
23431: PUSH
23432: LD_VAR 0 3
23436: PUSH
23437: LD_INT 22
23439: PUSH
23440: LD_INT 8
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 25
23449: PUSH
23450: LD_INT 2
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: PPUSH
23461: CALL_OW 69
23465: UNION
23466: PUSH
23467: FOR_IN
23468: IFFALSE 23484
// SetTag ( i , 0 ) ;
23470: LD_VAR 0 1
23474: PPUSH
23475: LD_INT 0
23477: PPUSH
23478: CALL_OW 109
23482: GO 23467
23484: POP
23485: POP
// wait ( 0 0$3 ) ;
23486: LD_INT 105
23488: PPUSH
23489: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23493: LD_INT 93
23495: PPUSH
23496: LD_INT 35
23498: PPUSH
23499: LD_INT 1
23501: PPUSH
23502: CALL_OW 331
// DialogueOn ;
23506: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23510: LD_VAR 0 11
23514: PPUSH
23515: LD_STRING D6c-Sol3-1
23517: PPUSH
23518: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23522: LD_INT 10
23524: PPUSH
23525: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23529: LD_EXP 36
23533: PPUSH
23534: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23538: LD_EXP 36
23542: PPUSH
23543: LD_STRING D6c-JMM-1
23545: PPUSH
23546: CALL_OW 88
// if Cyrus then
23550: LD_EXP 42
23554: IFFALSE 23568
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23556: LD_EXP 42
23560: PPUSH
23561: LD_STRING D6c-Cyrus-1
23563: PPUSH
23564: CALL_OW 88
// if Bobby then
23568: LD_EXP 41
23572: IFFALSE 23586
// Say ( Bobby , D6c-Bobby-1 ) ;
23574: LD_EXP 41
23578: PPUSH
23579: LD_STRING D6c-Bobby-1
23581: PPUSH
23582: CALL_OW 88
// if Cornel then
23586: LD_EXP 47
23590: IFFALSE 23604
// Say ( Cornel , D6c-Corn-1 ) ;
23592: LD_EXP 47
23596: PPUSH
23597: LD_STRING D6c-Corn-1
23599: PPUSH
23600: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23604: LD_ADDR_VAR 0 4
23608: PUSH
23609: LD_INT 2
23611: PUSH
23612: LD_INT 22
23614: PUSH
23615: LD_INT 1
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 22
23624: PUSH
23625: LD_INT 4
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: PUSH
23637: LD_INT 26
23639: PUSH
23640: LD_INT 1
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 3
23649: PUSH
23650: LD_INT 25
23652: PUSH
23653: LD_INT 16
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 25
23662: PUSH
23663: LD_INT 12
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: LIST
23679: PPUSH
23680: CALL_OW 69
23684: PUSH
23685: LD_VAR 0 11
23689: PUSH
23690: LD_EXP 36
23694: UNION
23695: PUSH
23696: LD_EXP 56
23700: UNION
23701: PUSH
23702: EMPTY
23703: LIST
23704: DIFF
23705: ST_TO_ADDR
// if tmp2 then
23706: LD_VAR 0 4
23710: IFFALSE 23728
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23712: LD_VAR 0 4
23716: PUSH
23717: LD_INT 1
23719: ARRAY
23720: PPUSH
23721: LD_STRING D6c-Sol1-1
23723: PPUSH
23724: CALL_OW 88
// if Lisa then
23728: LD_EXP 39
23732: IFFALSE 23746
// Say ( Lisa , D6c-Lisa-1 ) ;
23734: LD_EXP 39
23738: PPUSH
23739: LD_STRING D6c-Lisa-1
23741: PPUSH
23742: CALL_OW 88
// if Gary then
23746: LD_EXP 48
23750: IFFALSE 23764
// Say ( Gary , D6c-Gary-1 ) ;
23752: LD_EXP 48
23756: PPUSH
23757: LD_STRING D6c-Gary-1
23759: PPUSH
23760: CALL_OW 88
// if Donaldson then
23764: LD_EXP 40
23768: IFFALSE 23782
// Say ( Donaldson , D6c-Don-1 ) ;
23770: LD_EXP 40
23774: PPUSH
23775: LD_STRING D6c-Don-1
23777: PPUSH
23778: CALL_OW 88
// if tmp2 > 1 then
23782: LD_VAR 0 4
23786: PUSH
23787: LD_INT 1
23789: GREATER
23790: IFFALSE 23808
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23792: LD_VAR 0 4
23796: PUSH
23797: LD_INT 2
23799: ARRAY
23800: PPUSH
23801: LD_STRING D6c-Sol2-1
23803: PPUSH
23804: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23808: LD_VAR 0 11
23812: PPUSH
23813: LD_STRING D6c-Sol3-2
23815: PPUSH
23816: CALL_OW 88
// dwait ( 0 0$1 ) ;
23820: LD_INT 35
23822: PPUSH
23823: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23827: LD_EXP 36
23831: PPUSH
23832: LD_STRING D6c-JMM-2
23834: PPUSH
23835: CALL_OW 88
// DialogueOff ;
23839: CALL_OW 7
// Video ( false ) ;
23843: LD_INT 0
23845: PPUSH
23846: CALL 106794 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23850: LD_INT 22
23852: PUSH
23853: LD_INT 4
23855: PUSH
23856: EMPTY
23857: LIST
23858: LIST
23859: PPUSH
23860: CALL_OW 69
23864: PPUSH
23865: LD_INT 1
23867: PPUSH
23868: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23872: LD_INT 4
23874: PPUSH
23875: LD_INT 4
23877: PPUSH
23878: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23882: LD_ADDR_VAR 0 1
23886: PUSH
23887: LD_INT 4
23889: PPUSH
23890: LD_INT 1
23892: PPUSH
23893: LD_INT 2
23895: PPUSH
23896: CALL 64114 0 3
23900: PUSH
23901: FOR_IN
23902: IFFALSE 23939
// if GetTech ( i , 1 ) <> state_researched then
23904: LD_VAR 0 1
23908: PPUSH
23909: LD_INT 1
23911: PPUSH
23912: CALL_OW 321
23916: PUSH
23917: LD_INT 2
23919: NONEQUAL
23920: IFFALSE 23937
// SetTech ( i , 1 , state_researched ) ;
23922: LD_VAR 0 1
23926: PPUSH
23927: LD_INT 1
23929: PPUSH
23930: LD_INT 2
23932: PPUSH
23933: CALL_OW 322
23937: GO 23901
23939: POP
23940: POP
// missionStage := 6 ;
23941: LD_ADDR_EXP 15
23945: PUSH
23946: LD_INT 6
23948: ST_TO_ADDR
// activeAttacks := true ;
23949: LD_ADDR_EXP 16
23953: PUSH
23954: LD_INT 1
23956: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23957: LD_STRING M2
23959: PPUSH
23960: CALL_OW 337
// SaveForQuickRestart ;
23964: CALL_OW 22
// wait ( 0 0$40 ) ;
23968: LD_INT 1400
23970: PPUSH
23971: CALL_OW 67
// DialogueOn ;
23975: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23979: LD_EXP 59
23983: PPUSH
23984: LD_STRING D7-Friend-1
23986: PPUSH
23987: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23991: LD_EXP 36
23995: PPUSH
23996: LD_STRING D7-JMM-1
23998: PPUSH
23999: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24003: LD_EXP 59
24007: PPUSH
24008: LD_STRING D7-Friend-2
24010: PPUSH
24011: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24015: LD_EXP 36
24019: PPUSH
24020: LD_STRING D7-JMM-2
24022: PPUSH
24023: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24027: LD_EXP 59
24031: PPUSH
24032: LD_STRING D7-Friend-3
24034: PPUSH
24035: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24039: LD_EXP 36
24043: PPUSH
24044: LD_STRING D7-JMM-3
24046: PPUSH
24047: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24051: LD_EXP 59
24055: PPUSH
24056: LD_STRING D7-Friend-4
24058: PPUSH
24059: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24063: LD_EXP 36
24067: PPUSH
24068: LD_STRING D7-JMM-4
24070: PPUSH
24071: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24075: LD_EXP 59
24079: PPUSH
24080: LD_STRING D7-Friend-5
24082: PPUSH
24083: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24087: LD_EXP 36
24091: PPUSH
24092: LD_STRING D7-JMM-5
24094: PPUSH
24095: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24099: LD_EXP 59
24103: PPUSH
24104: LD_STRING D7-Friend-6
24106: PPUSH
24107: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24111: LD_EXP 36
24115: PPUSH
24116: LD_STRING D7-JMM-6
24118: PPUSH
24119: CALL_OW 88
// DialogueOff ;
24123: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24127: LD_STRING Mlegion
24129: PPUSH
24130: CALL_OW 337
// RebuildKozlovFactory ;
24134: CALL 4773 0 0
// end ;
24138: PPOPN 13
24140: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24141: LD_EXP 20
24145: PUSH
24146: LD_EXP 55
24150: PPUSH
24151: CALL_OW 300
24155: AND
24156: IFFALSE 24198
24158: GO 24160
24160: DISABLE
// begin enable ;
24161: ENABLE
// if IsInUnit ( Powell ) then
24162: LD_EXP 55
24166: PPUSH
24167: CALL_OW 310
24171: IFFALSE 24189
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24173: LD_EXP 55
24177: PPUSH
24178: CALL_OW 310
24182: PPUSH
24183: CALL_OW 85
24187: GO 24198
// CenterOnUnits ( Powell ) ;
24189: LD_EXP 55
24193: PPUSH
24194: CALL_OW 85
// end ;
24198: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24199: LD_INT 22
24201: PUSH
24202: LD_INT 8
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 34
24211: PUSH
24212: LD_INT 48
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PUSH
24219: EMPTY
24220: LIST
24221: LIST
24222: PPUSH
24223: CALL_OW 69
24227: IFFALSE 24490
24229: GO 24231
24231: DISABLE
24232: LD_INT 0
24234: PPUSH
24235: PPUSH
// begin if missionStage < 9 then
24236: LD_EXP 15
24240: PUSH
24241: LD_INT 9
24243: LESS
24244: IFFALSE 24254
// missionStage := 9 ;
24246: LD_ADDR_EXP 15
24250: PUSH
24251: LD_INT 9
24253: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24254: LD_ADDR_VAR 0 1
24258: PUSH
24259: LD_INT 22
24261: PUSH
24262: LD_INT 8
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_INT 34
24271: PUSH
24272: LD_INT 48
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: PUSH
24279: EMPTY
24280: LIST
24281: LIST
24282: PPUSH
24283: CALL_OW 69
24287: PUSH
24288: LD_INT 1
24290: ARRAY
24291: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24292: LD_INT 175
24294: PPUSH
24295: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24299: LD_EXP 12
24303: PUSH
24304: LD_EXP 3
24308: PUSH
24309: LD_INT 0
24311: PUSH
24312: LD_INT 2
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: IN
24319: OR
24320: IFFALSE 24343
// target := [ 68 , 108 , 1 ] else
24322: LD_ADDR_VAR 0 2
24326: PUSH
24327: LD_INT 68
24329: PUSH
24330: LD_INT 108
24332: PUSH
24333: LD_INT 1
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: ST_TO_ADDR
24341: GO 24362
// target := [ 181 , 88 , 2 ] ;
24343: LD_ADDR_VAR 0 2
24347: PUSH
24348: LD_INT 181
24350: PUSH
24351: LD_INT 88
24353: PUSH
24354: LD_INT 2
24356: PUSH
24357: EMPTY
24358: LIST
24359: LIST
24360: LIST
24361: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24362: LD_VAR 0 1
24366: PPUSH
24367: LD_VAR 0 2
24371: PUSH
24372: LD_INT 1
24374: ARRAY
24375: PPUSH
24376: LD_VAR 0 2
24380: PUSH
24381: LD_INT 2
24383: ARRAY
24384: PPUSH
24385: CALL_OW 176
// if target [ 3 ] = 1 then
24389: LD_VAR 0 2
24393: PUSH
24394: LD_INT 3
24396: ARRAY
24397: PUSH
24398: LD_INT 1
24400: EQUAL
24401: IFFALSE 24417
// SayRadio ( Kurt , D12-Kurt-1 ) else
24403: LD_EXP 57
24407: PPUSH
24408: LD_STRING D12-Kurt-1
24410: PPUSH
24411: CALL_OW 94
24415: GO 24441
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24417: LD_EXP 57
24421: PPUSH
24422: LD_STRING D12a-Kurt-1
24424: PPUSH
24425: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24429: LD_EXP 71
24433: PPUSH
24434: LD_STRING D12a-Roth-1
24436: PPUSH
24437: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24441: LD_INT 350
24443: PPUSH
24444: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24448: LD_VAR 0 1
24452: PPUSH
24453: LD_INT 22
24455: PUSH
24456: LD_INT 8
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PUSH
24463: LD_INT 30
24465: PUSH
24466: LD_INT 3
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PPUSH
24477: CALL_OW 69
24481: PUSH
24482: LD_INT 1
24484: ARRAY
24485: PPUSH
24486: CALL_OW 228
// end ;
24490: PPOPN 2
24492: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24493: LD_INT 22
24495: PUSH
24496: LD_INT 8
24498: PUSH
24499: EMPTY
24500: LIST
24501: LIST
24502: PUSH
24503: LD_INT 21
24505: PUSH
24506: LD_INT 1
24508: PUSH
24509: EMPTY
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 23
24515: PUSH
24516: LD_INT 2
24518: PUSH
24519: EMPTY
24520: LIST
24521: LIST
24522: PUSH
24523: EMPTY
24524: LIST
24525: LIST
24526: LIST
24527: PPUSH
24528: CALL_OW 69
24532: PUSH
24533: LD_INT 8
24535: PUSH
24536: LD_INT 7
24538: PUSH
24539: LD_INT 6
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: LIST
24546: PUSH
24547: LD_OWVAR 67
24551: ARRAY
24552: LESSEQUAL
24553: PUSH
24554: LD_INT 22
24556: PUSH
24557: LD_INT 8
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: LD_INT 34
24566: PUSH
24567: LD_INT 48
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PPUSH
24578: CALL_OW 69
24582: NOT
24583: AND
24584: PUSH
24585: LD_EXP 57
24589: PPUSH
24590: CALL_OW 302
24594: AND
24595: IFFALSE 24912
24597: GO 24599
24599: DISABLE
// begin DialogueOn ;
24600: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24604: LD_EXP 36
24608: PPUSH
24609: LD_STRING D13-JMM-1
24611: PPUSH
24612: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24616: LD_EXP 57
24620: PPUSH
24621: LD_STRING D13-Kurt-1
24623: PPUSH
24624: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24628: LD_EXP 36
24632: PPUSH
24633: LD_STRING D13-JMM-2
24635: PPUSH
24636: CALL_OW 88
// if FakeInfo then
24640: LD_EXP 12
24644: IFFALSE 24664
// begin Say ( Kurt , D13-Kurt-2 ) ;
24646: LD_EXP 57
24650: PPUSH
24651: LD_STRING D13-Kurt-2
24653: PPUSH
24654: CALL_OW 88
// DialogueOff ;
24658: CALL_OW 7
// exit ;
24662: GO 24912
// end ; if not KurtStatus then
24664: LD_EXP 3
24668: NOT
24669: IFFALSE 24685
// Say ( Kurt , D13-Kurt-2b ) else
24671: LD_EXP 57
24675: PPUSH
24676: LD_STRING D13-Kurt-2b
24678: PPUSH
24679: CALL_OW 88
24683: GO 24697
// Say ( Kurt , D13-Kurt-2a ) ;
24685: LD_EXP 57
24689: PPUSH
24690: LD_STRING D13-Kurt-2a
24692: PPUSH
24693: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24697: LD_EXP 57
24701: PPUSH
24702: LD_STRING D13-Kurt-2a
24704: PPUSH
24705: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24709: LD_EXP 36
24713: PPUSH
24714: LD_STRING D13-JMM-3
24716: PPUSH
24717: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24721: LD_EXP 57
24725: PPUSH
24726: LD_STRING D13-Kurt-3
24728: PPUSH
24729: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24733: LD_EXP 36
24737: PPUSH
24738: LD_STRING D13-JMM-4
24740: PPUSH
24741: CALL_OW 88
// DialogueOff ;
24745: CALL_OW 7
// MC_Kill ( 3 ) ;
24749: LD_INT 3
24751: PPUSH
24752: CALL 34143 0 1
// KillUnit ( Kozlov ) ;
24756: LD_EXP 58
24760: PPUSH
24761: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24765: LD_INT 22
24767: PUSH
24768: LD_INT 8
24770: PUSH
24771: EMPTY
24772: LIST
24773: LIST
24774: PUSH
24775: LD_INT 21
24777: PUSH
24778: LD_INT 3
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 23
24787: PUSH
24788: LD_INT 3
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 30
24797: PUSH
24798: LD_INT 3
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: LIST
24810: PPUSH
24811: CALL_OW 69
24815: PUSH
24816: LD_INT 1
24818: ARRAY
24819: PPUSH
24820: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24824: LD_INT 8
24826: PPUSH
24827: LD_INT 1
24829: PPUSH
24830: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24834: LD_INT 22
24836: PUSH
24837: LD_INT 8
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 69
24848: PPUSH
24849: LD_INT 1
24851: PPUSH
24852: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24856: LD_INT 8
24858: PPUSH
24859: LD_INT 1
24861: PPUSH
24862: LD_INT 1
24864: PPUSH
24865: LD_INT 1
24867: PPUSH
24868: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24872: LD_EXP 59
24876: PPUSH
24877: LD_INT 37
24879: PPUSH
24880: LD_INT 1
24882: PPUSH
24883: LD_INT 0
24885: PPUSH
24886: CALL_OW 48
// wait ( 0 0$1 ) ;
24890: LD_INT 35
24892: PPUSH
24893: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24897: LD_EXP 59
24901: PPUSH
24902: LD_INT 60
24904: PPUSH
24905: LD_INT 95
24907: PPUSH
24908: CALL_OW 111
// end ;
24912: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24913: LD_INT 22
24915: PUSH
24916: LD_INT 8
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: PUSH
24923: LD_INT 21
24925: PUSH
24926: LD_INT 1
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PPUSH
24937: CALL_OW 69
24941: PUSH
24942: LD_INT 0
24944: EQUAL
24945: IFFALSE 24965
24947: GO 24949
24949: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24950: LD_STRING MlegionOut
24952: PPUSH
24953: CALL_OW 337
// legionDestroyed := true ;
24957: LD_ADDR_EXP 22
24961: PUSH
24962: LD_INT 1
24964: ST_TO_ADDR
// end ;
24965: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24966: LD_INT 1
24968: PPUSH
24969: LD_EXP 59
24973: PPUSH
24974: CALL_OW 292
24978: IFFALSE 25278
24980: GO 24982
24982: DISABLE
24983: LD_INT 0
24985: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24986: LD_EXP 59
24990: PPUSH
24991: CALL_OW 87
// DialogueOn ;
24995: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24999: LD_EXP 36
25003: PPUSH
25004: LD_STRING D14-JMM-1
25006: PPUSH
25007: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25011: LD_EXP 59
25015: PPUSH
25016: LD_STRING D14-Friend-1
25018: PPUSH
25019: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25023: LD_EXP 36
25027: PPUSH
25028: LD_STRING D14-JMM-2
25030: PPUSH
25031: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25035: LD_EXP 59
25039: PPUSH
25040: LD_STRING D14-Friend-2
25042: PPUSH
25043: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25047: LD_EXP 36
25051: PPUSH
25052: LD_STRING D14-JMM-3
25054: PPUSH
25055: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25059: LD_EXP 59
25063: PPUSH
25064: LD_STRING D14-Friend-3
25066: PPUSH
25067: CALL_OW 88
// DialogueOff ;
25071: CALL_OW 7
// dec = Query ( Q14 ) ;
25075: LD_ADDR_VAR 0 1
25079: PUSH
25080: LD_STRING Q14
25082: PPUSH
25083: CALL_OW 97
25087: ST_TO_ADDR
// if dec = 1 then
25088: LD_VAR 0 1
25092: PUSH
25093: LD_INT 1
25095: EQUAL
25096: IFFALSE 25130
// begin DialogueOn ;
25098: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25102: LD_EXP 36
25106: PPUSH
25107: LD_STRING D14a-JMM-1
25109: PPUSH
25110: CALL_OW 88
// DialogueOff ;
25114: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25118: LD_EXP 59
25122: PPUSH
25123: LD_INT 1
25125: PPUSH
25126: CALL_OW 235
// end ; if dec = 2 then
25130: LD_VAR 0 1
25134: PUSH
25135: LD_INT 2
25137: EQUAL
25138: IFFALSE 25184
// begin DialogueOn ;
25140: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25144: LD_EXP 36
25148: PPUSH
25149: LD_STRING D14b-JMM-1
25151: PPUSH
25152: CALL_OW 88
// DialogueOff ;
25156: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25160: LD_EXP 59
25164: PPUSH
25165: LD_INT 9
25167: PPUSH
25168: LD_INT 2
25170: PPUSH
25171: CALL_OW 111
// AddComHold ( Friend ) ;
25175: LD_EXP 59
25179: PPUSH
25180: CALL_OW 200
// end ; if dec = 3 then
25184: LD_VAR 0 1
25188: PUSH
25189: LD_INT 3
25191: EQUAL
25192: IFFALSE 25278
// begin DialogueOn ;
25194: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25198: LD_EXP 36
25202: PPUSH
25203: LD_STRING D14c-JMM-1
25205: PPUSH
25206: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25210: LD_EXP 59
25214: PPUSH
25215: LD_STRING D14c-Friend-1
25217: PPUSH
25218: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25222: LD_EXP 36
25226: PPUSH
25227: LD_STRING D14c-JMM-2
25229: PPUSH
25230: CALL_OW 88
// DialogueOff ;
25234: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25238: LD_INT 8
25240: PPUSH
25241: LD_INT 1
25243: PPUSH
25244: LD_INT 2
25246: PPUSH
25247: LD_INT 1
25249: PPUSH
25250: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25254: LD_EXP 59
25258: PPUSH
25259: LD_INT 9
25261: PPUSH
25262: LD_INT 2
25264: PPUSH
25265: CALL_OW 111
// AddComHold ( Friend ) ;
25269: LD_EXP 59
25273: PPUSH
25274: CALL_OW 200
// end ; end ;
25278: PPOPN 1
25280: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25281: LD_INT 9
25283: PPUSH
25284: LD_INT 2
25286: PPUSH
25287: CALL_OW 428
25291: PUSH
25292: LD_EXP 59
25296: EQUAL
25297: PUSH
25298: LD_EXP 59
25302: PPUSH
25303: CALL_OW 255
25307: PUSH
25308: LD_INT 8
25310: EQUAL
25311: AND
25312: IFFALSE 25326
25314: GO 25316
25316: DISABLE
// RemoveUnit ( Friend ) ;
25317: LD_EXP 59
25321: PPUSH
25322: CALL_OW 64
25326: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25327: LD_EXP 14
25331: PUSH
25332: LD_INT 31500
25334: GREATEREQUAL
25335: PUSH
25336: LD_EXP 7
25340: AND
25341: PUSH
25342: LD_EXP 2
25346: AND
25347: IFFALSE 25777
25349: GO 25351
25351: DISABLE
25352: LD_INT 0
25354: PPUSH
25355: PPUSH
25356: PPUSH
// begin missionStage := 7 ;
25357: LD_ADDR_EXP 15
25361: PUSH
25362: LD_INT 7
25364: ST_TO_ADDR
// uc_side = 1 ;
25365: LD_ADDR_OWVAR 20
25369: PUSH
25370: LD_INT 1
25372: ST_TO_ADDR
// uc_nation = 1 ;
25373: LD_ADDR_OWVAR 21
25377: PUSH
25378: LD_INT 1
25380: ST_TO_ADDR
// for i = 1 to 5 do
25381: LD_ADDR_VAR 0 1
25385: PUSH
25386: DOUBLE
25387: LD_INT 1
25389: DEC
25390: ST_TO_ADDR
25391: LD_INT 5
25393: PUSH
25394: FOR_TO
25395: IFFALSE 25491
// begin vc_engine = 3 ;
25397: LD_ADDR_OWVAR 39
25401: PUSH
25402: LD_INT 3
25404: ST_TO_ADDR
// vc_control = 3 ;
25405: LD_ADDR_OWVAR 38
25409: PUSH
25410: LD_INT 3
25412: ST_TO_ADDR
// vc_chassis = 3 ;
25413: LD_ADDR_OWVAR 37
25417: PUSH
25418: LD_INT 3
25420: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25421: LD_ADDR_OWVAR 40
25425: PUSH
25426: LD_INT 5
25428: PUSH
25429: LD_INT 9
25431: PUSH
25432: LD_INT 7
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: LIST
25439: PUSH
25440: LD_INT 1
25442: PPUSH
25443: LD_INT 3
25445: PPUSH
25446: CALL_OW 12
25450: ARRAY
25451: ST_TO_ADDR
// veh = CreateVehicle ;
25452: LD_ADDR_VAR 0 2
25456: PUSH
25457: CALL_OW 45
25461: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25462: LD_VAR 0 2
25466: PPUSH
25467: LD_INT 1
25469: PPUSH
25470: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25474: LD_VAR 0 2
25478: PPUSH
25479: LD_INT 19
25481: PPUSH
25482: LD_INT 0
25484: PPUSH
25485: CALL_OW 49
// end ;
25489: GO 25394
25491: POP
25492: POP
// vc_engine = 3 ;
25493: LD_ADDR_OWVAR 39
25497: PUSH
25498: LD_INT 3
25500: ST_TO_ADDR
// vc_control = 1 ;
25501: LD_ADDR_OWVAR 38
25505: PUSH
25506: LD_INT 1
25508: ST_TO_ADDR
// vc_chassis = 3 ;
25509: LD_ADDR_OWVAR 37
25513: PUSH
25514: LD_INT 3
25516: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25517: LD_ADDR_OWVAR 40
25521: PUSH
25522: LD_INT 5
25524: PUSH
25525: LD_INT 9
25527: PUSH
25528: LD_INT 7
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 1
25538: PPUSH
25539: LD_INT 3
25541: PPUSH
25542: CALL_OW 12
25546: ARRAY
25547: ST_TO_ADDR
// vehG = CreateVehicle ;
25548: LD_ADDR_VAR 0 3
25552: PUSH
25553: CALL_OW 45
25557: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25558: LD_VAR 0 3
25562: PPUSH
25563: LD_INT 1
25565: PPUSH
25566: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25570: LD_VAR 0 3
25574: PPUSH
25575: LD_INT 19
25577: PPUSH
25578: LD_INT 0
25580: PPUSH
25581: CALL_OW 49
// if JMMGirl = 1 then
25585: LD_EXP 7
25589: PUSH
25590: LD_INT 1
25592: EQUAL
25593: IFFALSE 25649
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25595: LD_ADDR_EXP 37
25599: PUSH
25600: LD_STRING Joan
25602: PPUSH
25603: LD_INT 1
25605: PPUSH
25606: LD_STRING 14_
25608: PPUSH
25609: CALL 64051 0 3
25613: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25614: LD_EXP 37
25618: PPUSH
25619: LD_VAR 0 3
25623: PPUSH
25624: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25628: LD_VAR 0 3
25632: PPUSH
25633: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25637: LD_EXP 37
25641: PPUSH
25642: LD_STRING D10BW-Joan-1
25644: PPUSH
25645: CALL_OW 94
// end ; if JMMGirl = 2 then
25649: LD_EXP 7
25653: PUSH
25654: LD_INT 2
25656: EQUAL
25657: IFFALSE 25713
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25659: LD_ADDR_EXP 39
25663: PUSH
25664: LD_STRING Lisa
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: LD_STRING 14_
25672: PPUSH
25673: CALL 64051 0 3
25677: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25678: LD_EXP 39
25682: PPUSH
25683: LD_VAR 0 3
25687: PPUSH
25688: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25692: LD_VAR 0 3
25696: PPUSH
25697: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25701: LD_EXP 39
25705: PPUSH
25706: LD_STRING D10BW-Lisa-1
25708: PPUSH
25709: CALL_OW 94
// end ; if JMMGirl = 3 then
25713: LD_EXP 7
25717: PUSH
25718: LD_INT 3
25720: EQUAL
25721: IFFALSE 25777
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25723: LD_ADDR_EXP 51
25727: PUSH
25728: LD_STRING Connie
25730: PPUSH
25731: LD_INT 1
25733: PPUSH
25734: LD_STRING 14_
25736: PPUSH
25737: CALL 64051 0 3
25741: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25742: LD_EXP 51
25746: PPUSH
25747: LD_VAR 0 3
25751: PPUSH
25752: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25756: LD_VAR 0 3
25760: PPUSH
25761: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25765: LD_EXP 39
25769: PPUSH
25770: LD_STRING D10BW-Con-1
25772: PPUSH
25773: CALL_OW 94
// end ; end ;
25777: PPOPN 3
25779: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25780: LD_EXP 14
25784: PUSH
25785: LD_INT 94500
25787: GREATEREQUAL
25788: IFFALSE 26200
25790: GO 25792
25792: DISABLE
25793: LD_INT 0
25795: PPUSH
25796: PPUSH
25797: PPUSH
// begin tmp := PrepareStevensSquad ;
25798: LD_ADDR_VAR 0 3
25802: PUSH
25803: CALL 2147 0 0
25807: ST_TO_ADDR
// if not tmp then
25808: LD_VAR 0 3
25812: NOT
25813: IFFALSE 25817
// exit ;
25815: GO 26200
// uc_side := 1 ;
25817: LD_ADDR_OWVAR 20
25821: PUSH
25822: LD_INT 1
25824: ST_TO_ADDR
// uc_nation := 1 ;
25825: LD_ADDR_OWVAR 21
25829: PUSH
25830: LD_INT 1
25832: ST_TO_ADDR
// for i in tmp do
25833: LD_ADDR_VAR 0 1
25837: PUSH
25838: LD_VAR 0 3
25842: PUSH
25843: FOR_IN
25844: IFFALSE 25941
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25846: LD_INT 3
25848: PPUSH
25849: LD_INT 3
25851: PPUSH
25852: LD_INT 1
25854: PPUSH
25855: LD_INT 5
25857: PUSH
25858: LD_INT 9
25860: PUSH
25861: LD_INT 7
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: LIST
25868: PUSH
25869: LD_INT 1
25871: PPUSH
25872: LD_INT 3
25874: PPUSH
25875: CALL_OW 12
25879: ARRAY
25880: PPUSH
25881: LD_INT 40
25883: PPUSH
25884: CALL 71077 0 5
// veh := CreateVehicle ;
25888: LD_ADDR_VAR 0 2
25892: PUSH
25893: CALL_OW 45
25897: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25898: LD_VAR 0 2
25902: PPUSH
25903: LD_INT 1
25905: PPUSH
25906: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25910: LD_VAR 0 2
25914: PPUSH
25915: LD_INT 19
25917: PPUSH
25918: LD_INT 0
25920: PPUSH
25921: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25925: LD_VAR 0 1
25929: PPUSH
25930: LD_VAR 0 2
25934: PPUSH
25935: CALL_OW 52
// end ;
25939: GO 25843
25941: POP
25942: POP
// missionStage := 8 ;
25943: LD_ADDR_EXP 15
25947: PUSH
25948: LD_INT 8
25950: ST_TO_ADDR
// DialogueOn ;
25951: CALL_OW 6
// if Stevens then
25955: LD_EXP 38
25959: IFFALSE 26073
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25961: LD_EXP 38
25965: PPUSH
25966: CALL_OW 310
25970: PPUSH
25971: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25975: LD_EXP 38
25979: PPUSH
25980: LD_STRING D8-Huck-1
25982: PPUSH
25983: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25987: LD_EXP 36
25991: PPUSH
25992: LD_STRING D8-JMM-1
25994: PPUSH
25995: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25999: LD_EXP 38
26003: PPUSH
26004: LD_STRING D8-Huck-2
26006: PPUSH
26007: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26011: LD_EXP 36
26015: PPUSH
26016: LD_STRING D8-JMM-2
26018: PPUSH
26019: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26023: LD_EXP 38
26027: PPUSH
26028: LD_STRING D8-Huck-3
26030: PPUSH
26031: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26035: LD_EXP 36
26039: PPUSH
26040: LD_STRING D8-JMM-3
26042: PPUSH
26043: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26047: LD_EXP 38
26051: PPUSH
26052: LD_STRING D8-Huck-4
26054: PPUSH
26055: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26059: LD_EXP 36
26063: PPUSH
26064: LD_STRING D8-JMM-4
26066: PPUSH
26067: CALL_OW 88
// end else
26071: GO 26183
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26073: LD_EXP 52
26077: PPUSH
26078: CALL_OW 310
26082: PPUSH
26083: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26087: LD_EXP 52
26091: PPUSH
26092: LD_STRING D8-Huck-1
26094: PPUSH
26095: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26099: LD_EXP 36
26103: PPUSH
26104: LD_STRING D8-JMM-1a
26106: PPUSH
26107: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26111: LD_EXP 52
26115: PPUSH
26116: LD_STRING D8-Huck-2
26118: PPUSH
26119: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26123: LD_EXP 36
26127: PPUSH
26128: LD_STRING D8-JMM-2
26130: PPUSH
26131: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26135: LD_EXP 52
26139: PPUSH
26140: LD_STRING D8-Huck-3
26142: PPUSH
26143: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26147: LD_EXP 36
26151: PPUSH
26152: LD_STRING D8-JMM-3
26154: PPUSH
26155: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26159: LD_EXP 52
26163: PPUSH
26164: LD_STRING D8-Huck-4
26166: PPUSH
26167: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26171: LD_EXP 36
26175: PPUSH
26176: LD_STRING D8-JMM-4
26178: PPUSH
26179: CALL_OW 88
// end ; DialogueOff ;
26183: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26187: LD_INT 25
26189: PPUSH
26190: LD_INT 1
26192: PPUSH
26193: LD_INT 1
26195: PPUSH
26196: CALL_OW 322
// end ;
26200: PPOPN 3
26202: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26203: LD_INT 1
26205: PPUSH
26206: LD_EXP 68
26210: PPUSH
26211: CALL_OW 292
26215: IFFALSE 26466
26217: GO 26219
26219: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26220: LD_EXP 68
26224: PPUSH
26225: CALL_OW 87
// DialogueOn ;
26229: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26233: LD_EXP 36
26237: PPUSH
26238: LD_STRING D10nB-JMM-1
26240: PPUSH
26241: CALL_OW 88
// if BurlakStatus = 1 then
26245: LD_EXP 9
26249: PUSH
26250: LD_INT 1
26252: EQUAL
26253: IFFALSE 26267
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26255: LD_EXP 67
26259: PPUSH
26260: LD_STRING D10nB-Vse-1a
26262: PPUSH
26263: CALL_OW 94
// end ; if BurlakStatus = 0 then
26267: LD_EXP 9
26271: PUSH
26272: LD_INT 0
26274: EQUAL
26275: IFFALSE 26289
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26277: LD_EXP 67
26281: PPUSH
26282: LD_STRING D10nB-Vse-1
26284: PPUSH
26285: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26289: LD_EXP 36
26293: PPUSH
26294: LD_STRING D10nB-JMM-2
26296: PPUSH
26297: CALL_OW 88
// if KappaStatus then
26301: LD_EXP 2
26305: IFFALSE 26319
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26307: LD_EXP 67
26311: PPUSH
26312: LD_STRING D10nB-Vse-5a
26314: PPUSH
26315: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26319: LD_EXP 2
26323: NOT
26324: PUSH
26325: LD_EXP 6
26329: PUSH
26330: LD_INT 0
26332: EQUAL
26333: AND
26334: IFFALSE 26462
// begin if JMMGirl = 1 then
26336: LD_EXP 7
26340: PUSH
26341: LD_INT 1
26343: EQUAL
26344: IFFALSE 26394
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26346: LD_EXP 67
26350: PPUSH
26351: LD_STRING D10nB-Vse-2
26353: PPUSH
26354: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26358: LD_EXP 36
26362: PPUSH
26363: LD_STRING D10nB-JMM-3
26365: PPUSH
26366: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26370: LD_EXP 67
26374: PPUSH
26375: LD_STRING D10nB-Vse-3
26377: PPUSH
26378: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26382: LD_EXP 36
26386: PPUSH
26387: LD_STRING D10nB-JMM-4
26389: PPUSH
26390: CALL_OW 88
// end ; if JMMGirl = 2 then
26394: LD_EXP 7
26398: PUSH
26399: LD_INT 2
26401: EQUAL
26402: IFFALSE 26428
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26404: LD_EXP 67
26408: PPUSH
26409: LD_STRING D10nB-Vse-4
26411: PPUSH
26412: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26416: LD_EXP 36
26420: PPUSH
26421: LD_STRING D10nB-JMM-5
26423: PPUSH
26424: CALL_OW 88
// end ; if JMMGirl = 3 then
26428: LD_EXP 7
26432: PUSH
26433: LD_INT 3
26435: EQUAL
26436: IFFALSE 26462
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26438: LD_EXP 67
26442: PPUSH
26443: LD_STRING D10nB-Vse-5
26445: PPUSH
26446: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26450: LD_EXP 36
26454: PPUSH
26455: LD_STRING D10nB-JMM-6
26457: PPUSH
26458: CALL_OW 88
// end ; end ; DialogueOff ;
26462: CALL_OW 7
// end ;
26466: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26467: LD_EXP 14
26471: PUSH
26472: LD_INT 115500
26474: GREATEREQUAL
26475: IFFALSE 26834
26477: GO 26479
26479: DISABLE
26480: LD_INT 0
26482: PPUSH
// begin missionStage := 10 ;
26483: LD_ADDR_EXP 15
26487: PUSH
26488: LD_INT 10
26490: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26491: LD_ADDR_VAR 0 1
26495: PUSH
26496: LD_INT 22
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 26
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 3
26518: PUSH
26519: LD_INT 25
26521: PUSH
26522: LD_INT 12
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: PUSH
26533: LD_INT 3
26535: PUSH
26536: LD_INT 25
26538: PUSH
26539: LD_INT 16
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: PPUSH
26556: CALL_OW 69
26560: PUSH
26561: LD_EXP 36
26565: PUSH
26566: LD_EXP 38
26570: PUSH
26571: LD_EXP 52
26575: PUSH
26576: LD_EXP 39
26580: PUSH
26581: LD_EXP 40
26585: PUSH
26586: LD_EXP 41
26590: PUSH
26591: LD_EXP 42
26595: PUSH
26596: LD_EXP 43
26600: PUSH
26601: LD_EXP 44
26605: PUSH
26606: LD_EXP 45
26610: PUSH
26611: LD_EXP 46
26615: PUSH
26616: LD_EXP 47
26620: PUSH
26621: LD_EXP 48
26625: PUSH
26626: LD_EXP 49
26630: PUSH
26631: LD_EXP 50
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: DIFF
26653: ST_TO_ADDR
// if not tmp and Brown then
26654: LD_VAR 0 1
26658: NOT
26659: PUSH
26660: LD_EXP 44
26664: AND
26665: IFFALSE 26680
// tmp := [ Brown ] ;
26667: LD_ADDR_VAR 0 1
26671: PUSH
26672: LD_EXP 44
26676: PUSH
26677: EMPTY
26678: LIST
26679: ST_TO_ADDR
// DialogueOn ;
26680: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26684: LD_VAR 0 1
26688: PUSH
26689: LD_INT 1
26691: ARRAY
26692: PPUSH
26693: LD_STRING D11-Sol1-1
26695: PPUSH
26696: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26700: LD_EXP 61
26704: PPUSH
26705: LD_STRING D11-Pla-1
26707: PPUSH
26708: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26712: LD_EXP 62
26716: PPUSH
26717: LD_STRING D11-Kov-1
26719: PPUSH
26720: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26724: LD_EXP 61
26728: PPUSH
26729: LD_STRING D11-Pla-2
26731: PPUSH
26732: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26736: LD_VAR 0 1
26740: PUSH
26741: LD_INT 1
26743: ARRAY
26744: PPUSH
26745: LD_STRING D11-Sol1-2
26747: PPUSH
26748: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26752: LD_EXP 36
26756: PPUSH
26757: LD_STRING D11-JMM-2
26759: PPUSH
26760: CALL_OW 88
// DialogueOff ;
26764: CALL_OW 7
// allowBehemothConstruct := true ;
26768: LD_ADDR_EXP 25
26772: PUSH
26773: LD_INT 1
26775: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26776: LD_STRING M4
26778: PPUSH
26779: CALL_OW 337
// BuildBehemoths ;
26783: CALL 7577 0 0
// repeat wait ( 15 15$00 ) ;
26787: LD_INT 31500
26789: PPUSH
26790: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26794: LD_EXP 27
26798: IFFALSE 26802
// break ;
26800: GO 26834
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26802: LD_INT 267
26804: PPUSH
26805: CALL_OW 274
26809: PPUSH
26810: LD_INT 1
26812: PPUSH
26813: CALL_OW 275
26817: PUSH
26818: LD_INT 1000
26820: GREATEREQUAL
26821: IFFALSE 26827
// BuildBehemoths ;
26823: CALL 7577 0 0
// until not behemothBuilders ;
26827: LD_EXP 70
26831: NOT
26832: IFFALSE 26787
// end ;
26834: PPOPN 1
26836: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26837: LD_EXP 70
26841: NOT
26842: PUSH
26843: LD_EXP 28
26847: NOT
26848: AND
26849: PUSH
26850: LD_EXP 25
26854: AND
26855: IFFALSE 26875
26857: GO 26859
26859: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26860: LD_STRING M4a
26862: PPUSH
26863: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26867: LD_ADDR_EXP 27
26871: PUSH
26872: LD_INT 1
26874: ST_TO_ADDR
// end ;
26875: END
// every 0 0$1 trigger behemothDone do
26876: LD_EXP 28
26880: IFFALSE 26892
26882: GO 26884
26884: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26885: LD_STRING M4b
26887: PPUSH
26888: CALL_OW 337
26892: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26893: LD_EXP 29
26897: NOT
26898: IFFALSE 27094
26900: GO 26902
26902: DISABLE
26903: LD_INT 0
26905: PPUSH
26906: PPUSH
// begin enable ;
26907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26908: LD_ADDR_VAR 0 1
26912: PUSH
26913: LD_INT 3
26915: PPUSH
26916: CALL 106870 0 1
26920: ST_TO_ADDR
// if not tmp and not behemothDone then
26921: LD_VAR 0 1
26925: NOT
26926: PUSH
26927: LD_EXP 28
26931: NOT
26932: AND
26933: IFFALSE 26969
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26935: LD_ADDR_VAR 0 1
26939: PUSH
26940: LD_INT 22
26942: PUSH
26943: LD_INT 3
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 30
26952: PUSH
26953: LD_INT 37
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PPUSH
26964: CALL_OW 69
26968: ST_TO_ADDR
// if not tmp then
26969: LD_VAR 0 1
26973: NOT
26974: IFFALSE 26978
// exit ;
26976: GO 27094
// for i in tmp do
26978: LD_ADDR_VAR 0 2
26982: PUSH
26983: LD_VAR 0 1
26987: PUSH
26988: FOR_IN
26989: IFFALSE 27092
// if See ( 1 , i ) then
26991: LD_INT 1
26993: PPUSH
26994: LD_VAR 0 2
26998: PPUSH
26999: CALL_OW 292
27003: IFFALSE 27090
// begin if GetType ( i ) = unit_building then
27005: LD_VAR 0 2
27009: PPUSH
27010: CALL_OW 247
27014: PUSH
27015: LD_INT 3
27017: EQUAL
27018: IFFALSE 27056
// begin CenterNowOnUnits ( i ) ;
27020: LD_VAR 0 2
27024: PPUSH
27025: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27029: LD_EXP 36
27033: PPUSH
27034: LD_STRING D17a-JMM-1
27036: PPUSH
27037: CALL_OW 88
// seeBehemoth := true ;
27041: LD_ADDR_EXP 29
27045: PUSH
27046: LD_INT 1
27048: ST_TO_ADDR
// disable ;
27049: DISABLE
// exit ;
27050: POP
27051: POP
27052: GO 27094
// end else
27054: GO 27090
// begin CenterNowOnUnits ( i ) ;
27056: LD_VAR 0 2
27060: PPUSH
27061: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27065: LD_EXP 36
27069: PPUSH
27070: LD_STRING D17b-JMM-1
27072: PPUSH
27073: CALL_OW 88
// seeBehemoth := true ;
27077: LD_ADDR_EXP 29
27081: PUSH
27082: LD_INT 1
27084: ST_TO_ADDR
// disable ;
27085: DISABLE
// exit ;
27086: POP
27087: POP
27088: GO 27094
// end ; end ;
27090: GO 26988
27092: POP
27093: POP
// end ;
27094: PPOPN 2
27096: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27097: LD_EXP 14
27101: PUSH
27102: LD_INT 116550
27104: GREATEREQUAL
27105: IFFALSE 28281
27107: GO 27109
27109: DISABLE
27110: LD_INT 0
27112: PPUSH
27113: PPUSH
27114: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27115: LD_INT 2
27117: PPUSH
27118: LD_INT 23
27120: PUSH
27121: LD_INT 3
27123: PUSH
27124: LD_INT 3
27126: PUSH
27127: LD_INT 48
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: PUSH
27136: EMPTY
27137: LIST
27138: PPUSH
27139: CALL 57707 0 2
// repeat wait ( 0 0$1 ) ;
27143: LD_INT 35
27145: PPUSH
27146: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27150: LD_INT 22
27152: PUSH
27153: LD_INT 3
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: LD_INT 34
27162: PUSH
27163: LD_INT 48
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PPUSH
27174: CALL_OW 69
27178: IFFALSE 27143
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27180: LD_ADDR_VAR 0 1
27184: PUSH
27185: LD_INT 22
27187: PUSH
27188: LD_INT 3
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 34
27197: PUSH
27198: LD_INT 48
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: PPUSH
27209: CALL_OW 69
27213: PUSH
27214: LD_INT 1
27216: ARRAY
27217: ST_TO_ADDR
// missionStage := 12 ;
27218: LD_ADDR_EXP 15
27222: PUSH
27223: LD_INT 12
27225: ST_TO_ADDR
// platonovHasBomb := true ;
27226: LD_ADDR_EXP 30
27230: PUSH
27231: LD_INT 1
27233: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27234: LD_VAR 0 1
27238: PPUSH
27239: LD_INT 181
27241: PPUSH
27242: LD_INT 86
27244: PPUSH
27245: CALL_OW 171
// AddComHold ( bomb ) ;
27249: LD_VAR 0 1
27253: PPUSH
27254: CALL_OW 200
// wait ( 0 0$10 ) ;
27258: LD_INT 350
27260: PPUSH
27261: CALL_OW 67
// DialogueOn ;
27265: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27269: LD_EXP 61
27273: PPUSH
27274: LD_STRING D15-Pla-1
27276: PPUSH
27277: CALL_OW 94
// dec = Query ( Q15a ) ;
27281: LD_ADDR_VAR 0 2
27285: PUSH
27286: LD_STRING Q15a
27288: PPUSH
27289: CALL_OW 97
27293: ST_TO_ADDR
// if dec = 1 then
27294: LD_VAR 0 2
27298: PUSH
27299: LD_INT 1
27301: EQUAL
27302: IFFALSE 27325
// begin Say ( JMM , D15a-JMM-1 ) ;
27304: LD_EXP 36
27308: PPUSH
27309: LD_STRING D15a-JMM-1
27311: PPUSH
27312: CALL_OW 88
// YouLost ( Surrender ) ;
27316: LD_STRING Surrender
27318: PPUSH
27319: CALL_OW 104
// exit ;
27323: GO 28281
// end ; if dec = 2 then
27325: LD_VAR 0 2
27329: PUSH
27330: LD_INT 2
27332: EQUAL
27333: IFFALSE 27402
// begin Say ( JMM , D15b-JMM-1 ) ;
27335: LD_EXP 36
27339: PPUSH
27340: LD_STRING D15b-JMM-1
27342: PPUSH
27343: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27347: LD_EXP 61
27351: PPUSH
27352: LD_STRING D15b-Pla-1
27354: PPUSH
27355: CALL_OW 94
// DialogueOff ;
27359: CALL_OW 7
// wait ( 3 3$00 ) ;
27363: LD_INT 6300
27365: PPUSH
27366: CALL_OW 67
// DialogueOn ;
27370: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27374: LD_EXP 36
27378: PPUSH
27379: LD_STRING D15d-JMM-1a
27381: PPUSH
27382: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27386: LD_EXP 61
27390: PPUSH
27391: LD_STRING D15d-Pla-1
27393: PPUSH
27394: CALL_OW 94
// DialogueOff ;
27398: CALL_OW 7
// end ; if dec = 3 then
27402: LD_VAR 0 2
27406: PUSH
27407: LD_INT 3
27409: EQUAL
27410: IFFALSE 27464
// begin Say ( JMM , D15c-JMM-1 ) ;
27412: LD_EXP 36
27416: PPUSH
27417: LD_STRING D15c-JMM-1
27419: PPUSH
27420: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27424: LD_EXP 61
27428: PPUSH
27429: LD_STRING D15c-Pla-1
27431: PPUSH
27432: CALL_OW 94
// DialogueOff ;
27436: CALL_OW 7
// wait ( 0 0$15 ) ;
27440: LD_INT 525
27442: PPUSH
27443: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 60
27454: PPUSH
27455: LD_INT 95
27457: PPUSH
27458: CALL_OW 116
// exit ;
27462: GO 28281
// end ; if dec = 4 then
27464: LD_VAR 0 2
27468: PUSH
27469: LD_INT 4
27471: EQUAL
27472: IFFALSE 27502
// begin Say ( JMM , D15d-JMM-1 ) ;
27474: LD_EXP 36
27478: PPUSH
27479: LD_STRING D15d-JMM-1
27481: PPUSH
27482: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27486: LD_EXP 61
27490: PPUSH
27491: LD_STRING D15d-Pla-1
27493: PPUSH
27494: CALL_OW 94
// DialogueOff ;
27498: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27502: LD_EXP 59
27506: PPUSH
27507: CALL_OW 302
27511: PUSH
27512: LD_EXP 59
27516: PPUSH
27517: CALL_OW 255
27521: PUSH
27522: LD_INT 1
27524: EQUAL
27525: AND
27526: PUSH
27527: LD_INT 22
27529: PUSH
27530: LD_INT 1
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 34
27539: PUSH
27540: LD_INT 8
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: PPUSH
27551: CALL_OW 69
27555: NOT
27556: AND
27557: IFFALSE 28182
// begin SetSide ( Friend , 8 ) ;
27559: LD_EXP 59
27563: PPUSH
27564: LD_INT 8
27566: PPUSH
27567: CALL_OW 235
// if IsInUnit ( Friend ) then
27571: LD_EXP 59
27575: PPUSH
27576: CALL_OW 310
27580: IFFALSE 27591
// ComExitBuilding ( Friend ) ;
27582: LD_EXP 59
27586: PPUSH
27587: CALL_OW 122
// if IsDriver ( Friend ) then
27591: LD_EXP 59
27595: PPUSH
27596: CALL 104547 0 1
27600: IFFALSE 27611
// ComExitVehicle ( Friend ) ;
27602: LD_EXP 59
27606: PPUSH
27607: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27611: LD_EXP 59
27615: PPUSH
27616: LD_INT 9
27618: PPUSH
27619: LD_INT 2
27621: PPUSH
27622: CALL_OW 171
// wait ( 0 0$05 ) ;
27626: LD_INT 175
27628: PPUSH
27629: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27633: LD_EXP 59
27637: PPUSH
27638: CALL_OW 87
// DialogueOn ;
27642: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27646: LD_EXP 36
27650: PPUSH
27651: LD_STRING D16-JMM-1
27653: PPUSH
27654: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27658: LD_EXP 59
27662: PPUSH
27663: LD_STRING D16-Friend-1
27665: PPUSH
27666: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27670: LD_EXP 36
27674: PPUSH
27675: LD_STRING D16-JMM-2
27677: PPUSH
27678: CALL_OW 88
// DialogueOff ;
27682: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27686: LD_EXP 59
27690: PPUSH
27691: LD_INT 1
27693: PPUSH
27694: CALL_OW 235
// ComHold ( Friend ) ;
27698: LD_EXP 59
27702: PPUSH
27703: CALL_OW 140
// wait ( 0 0$20 ) ;
27707: LD_INT 700
27709: PPUSH
27710: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27714: LD_EXP 59
27718: PPUSH
27719: LD_INT 9
27721: PPUSH
27722: LD_INT 2
27724: PPUSH
27725: CALL_OW 297
27729: PUSH
27730: LD_INT 30
27732: LESS
27733: IFFALSE 27802
// begin SetSide ( Friend , 8 ) ;
27735: LD_EXP 59
27739: PPUSH
27740: LD_INT 8
27742: PPUSH
27743: CALL_OW 235
// if IsInUnit ( Friend ) then
27747: LD_EXP 59
27751: PPUSH
27752: CALL_OW 310
27756: IFFALSE 27767
// ComExitBuilding ( Friend ) ;
27758: LD_EXP 59
27762: PPUSH
27763: CALL_OW 122
// if IsDriver ( Friend ) then
27767: LD_EXP 59
27771: PPUSH
27772: CALL 104547 0 1
27776: IFFALSE 27787
// ComExitVehicle ( Friend ) ;
27778: LD_EXP 59
27782: PPUSH
27783: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27787: LD_EXP 59
27791: PPUSH
27792: LD_INT 9
27794: PPUSH
27795: LD_INT 2
27797: PPUSH
27798: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27802: LD_INT 1050
27804: PPUSH
27805: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27809: LD_INT 22
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 34
27821: PUSH
27822: LD_INT 8
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PPUSH
27833: CALL_OW 69
27837: NOT
27838: IFFALSE 28160
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27840: LD_ADDR_VAR 0 3
27844: PUSH
27845: LD_INT 22
27847: PUSH
27848: LD_INT 1
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: LD_INT 26
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 3
27867: PUSH
27868: LD_INT 25
27870: PUSH
27871: LD_INT 12
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 25
27880: PUSH
27881: LD_INT 16
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: LIST
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: LIST
27897: PPUSH
27898: CALL_OW 69
27902: PUSH
27903: LD_EXP 36
27907: PUSH
27908: LD_EXP 38
27912: PUSH
27913: LD_EXP 52
27917: PUSH
27918: LD_EXP 39
27922: PUSH
27923: LD_EXP 40
27927: PUSH
27928: LD_EXP 41
27932: PUSH
27933: LD_EXP 42
27937: PUSH
27938: LD_EXP 43
27942: PUSH
27943: LD_EXP 44
27947: PUSH
27948: LD_EXP 45
27952: PUSH
27953: LD_EXP 46
27957: PUSH
27958: LD_EXP 47
27962: PUSH
27963: LD_EXP 48
27967: PUSH
27968: LD_EXP 49
27972: PUSH
27973: LD_EXP 50
27977: PUSH
27978: EMPTY
27979: LIST
27980: LIST
27981: LIST
27982: LIST
27983: LIST
27984: LIST
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: LIST
27991: LIST
27992: LIST
27993: LIST
27994: DIFF
27995: ST_TO_ADDR
// DialogueOn ;
27996: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28000: LD_EXP 61
28004: PPUSH
28005: LD_STRING D16a-Pla-1
28007: PPUSH
28008: CALL_OW 94
// if Stevens then
28012: LD_EXP 38
28016: IFFALSE 28032
// Say ( Stevens , D16a-Huck-1 ) else
28018: LD_EXP 38
28022: PPUSH
28023: LD_STRING D16a-Huck-1
28025: PPUSH
28026: CALL_OW 88
28030: GO 28074
// if Baker then
28032: LD_EXP 52
28036: IFFALSE 28052
// Say ( Baker , D16a-Huck-1 ) else
28038: LD_EXP 52
28042: PPUSH
28043: LD_STRING D16a-Huck-1
28045: PPUSH
28046: CALL_OW 88
28050: GO 28074
// if tmp then
28052: LD_VAR 0 3
28056: IFFALSE 28074
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28058: LD_VAR 0 3
28062: PUSH
28063: LD_INT 1
28065: ARRAY
28066: PPUSH
28067: LD_STRING D16a-Sol1-1
28069: PPUSH
28070: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28074: LD_EXP 59
28078: PPUSH
28079: CALL_OW 255
28083: PUSH
28084: LD_INT 8
28086: EQUAL
28087: IFFALSE 28103
// Say ( JMM , D16a-JMM-1 ) else
28089: LD_EXP 36
28093: PPUSH
28094: LD_STRING D16a-JMM-1
28096: PPUSH
28097: CALL_OW 88
28101: GO 28139
// begin Say ( JMM , D16a-JMM-1a ) ;
28103: LD_EXP 36
28107: PPUSH
28108: LD_STRING D16a-JMM-1a
28110: PPUSH
28111: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28115: LD_EXP 59
28119: PPUSH
28120: LD_STRING D16a-Friend-1
28122: PPUSH
28123: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28127: LD_EXP 59
28131: PPUSH
28132: LD_INT 3
28134: PPUSH
28135: CALL_OW 235
// end ; DialogueOff ;
28139: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28143: LD_VAR 0 1
28147: PPUSH
28148: LD_INT 60
28150: PPUSH
28151: LD_INT 95
28153: PPUSH
28154: CALL_OW 116
// end else
28158: GO 28180
// begin DialogueOn ;
28160: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28164: LD_EXP 61
28168: PPUSH
28169: LD_STRING D16c-Pla-
28171: PPUSH
28172: CALL_OW 94
// DialogueOff ;
28176: CALL_OW 7
// end ; end else
28180: GO 28281
// begin wait ( 3 3$00 ) ;
28182: LD_INT 6300
28184: PPUSH
28185: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28189: LD_INT 22
28191: PUSH
28192: LD_INT 1
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 34
28201: PUSH
28202: LD_INT 8
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 69
28217: NOT
28218: IFFALSE 28261
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28220: LD_EXP 61
28224: PPUSH
28225: LD_STRING D16b-Pla-1
28227: PPUSH
28228: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28232: LD_EXP 36
28236: PPUSH
28237: LD_STRING D16b-JMM-
28239: PPUSH
28240: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28244: LD_VAR 0 1
28248: PPUSH
28249: LD_INT 60
28251: PPUSH
28252: LD_INT 95
28254: PPUSH
28255: CALL_OW 116
// end else
28259: GO 28281
// begin DialogueOn ;
28261: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28265: LD_EXP 61
28269: PPUSH
28270: LD_STRING D16c-Pla-
28272: PPUSH
28273: CALL_OW 94
// DialogueOff ;
28277: CALL_OW 7
// end ; end ; end ;
28281: PPOPN 3
28283: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28284: LD_EXP 14
28288: PUSH
28289: LD_INT 126000
28291: GREATEREQUAL
28292: PUSH
28293: LD_EXP 23
28297: NOT
28298: AND
28299: PUSH
28300: LD_EXP 71
28304: PPUSH
28305: CALL_OW 302
28309: AND
28310: IFFALSE 28668
28312: GO 28314
28314: DISABLE
28315: LD_INT 0
28317: PPUSH
// begin missionStage = 11 ;
28318: LD_ADDR_EXP 15
28322: PUSH
28323: LD_INT 11
28325: ST_TO_ADDR
// DialogueOn ;
28326: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28330: LD_EXP 71
28334: PPUSH
28335: LD_STRING D9-Roth-1
28337: PPUSH
28338: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28342: LD_EXP 36
28346: PPUSH
28347: LD_STRING D9-JMM-1
28349: PPUSH
28350: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28354: LD_EXP 71
28358: PPUSH
28359: LD_STRING D9-Roth-2
28361: PPUSH
28362: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28366: LD_EXP 71
28370: PPUSH
28371: LD_STRING D9-Roth-2a
28373: PPUSH
28374: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28378: LD_EXP 61
28382: PPUSH
28383: LD_STRING D9-Pla-2
28385: PPUSH
28386: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28390: LD_EXP 71
28394: PPUSH
28395: LD_STRING D9-Roth-3
28397: PPUSH
28398: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28402: LD_EXP 61
28406: PPUSH
28407: LD_STRING D9-Pla-3
28409: PPUSH
28410: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28414: LD_EXP 71
28418: PPUSH
28419: LD_STRING D9-Roth-4
28421: PPUSH
28422: CALL_OW 94
// dec = Query ( Q9 ) ;
28426: LD_ADDR_VAR 0 1
28430: PUSH
28431: LD_STRING Q9
28433: PPUSH
28434: CALL_OW 97
28438: ST_TO_ADDR
// if dec = 1 then
28439: LD_VAR 0 1
28443: PUSH
28444: LD_INT 1
28446: EQUAL
28447: IFFALSE 28461
// SayRadio ( Roth , D9a-Roth-1 ) ;
28449: LD_EXP 71
28453: PPUSH
28454: LD_STRING D9a-Roth-1
28456: PPUSH
28457: CALL_OW 94
// if dec = 2 then
28461: LD_VAR 0 1
28465: PUSH
28466: LD_INT 2
28468: EQUAL
28469: IFFALSE 28495
// begin Say ( JMM , D9b-JMM-1 ) ;
28471: LD_EXP 36
28475: PPUSH
28476: LD_STRING D9b-JMM-1
28478: PPUSH
28479: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28483: LD_EXP 71
28487: PPUSH
28488: LD_STRING D9b-Roth-1
28490: PPUSH
28491: CALL_OW 94
// end ; if dec = 3 then
28495: LD_VAR 0 1
28499: PUSH
28500: LD_INT 3
28502: EQUAL
28503: IFFALSE 28565
// begin Say ( JMM , D9c-JMM-1 ) ;
28505: LD_EXP 36
28509: PPUSH
28510: LD_STRING D9c-JMM-1
28512: PPUSH
28513: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28517: LD_EXP 71
28521: PPUSH
28522: LD_STRING D9c-Roth-1
28524: PPUSH
28525: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28529: LD_EXP 36
28533: PPUSH
28534: LD_STRING D9c-JMM-2
28536: PPUSH
28537: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28541: LD_EXP 71
28545: PPUSH
28546: LD_STRING D9c-Roth-2
28548: PPUSH
28549: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28553: LD_EXP 36
28557: PPUSH
28558: LD_STRING D9c-JMM-3
28560: PPUSH
28561: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28565: LD_EXP 71
28569: PPUSH
28570: LD_STRING D9c-Roth-3
28572: PPUSH
28573: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28577: LD_EXP 71
28581: PPUSH
28582: LD_STRING D9cont-Roth-1
28584: PPUSH
28585: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28589: LD_EXP 36
28593: PPUSH
28594: LD_STRING D9cont-JMM-1
28596: PPUSH
28597: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28601: LD_EXP 71
28605: PPUSH
28606: LD_STRING D9cont-Roth-2
28608: PPUSH
28609: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28613: LD_EXP 36
28617: PPUSH
28618: LD_STRING D9cont-JMM-2
28620: PPUSH
28621: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28625: LD_EXP 71
28629: PPUSH
28630: LD_STRING D9cont-Roth-3
28632: PPUSH
28633: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28637: LD_EXP 36
28641: PPUSH
28642: LD_STRING D9cont-JMM-3
28644: PPUSH
28645: CALL_OW 88
// DialogueOff ;
28649: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28653: LD_STRING M3
28655: PPUSH
28656: CALL_OW 337
// allianceActive := true ;
28660: LD_ADDR_EXP 31
28664: PUSH
28665: LD_INT 1
28667: ST_TO_ADDR
// end ;
28668: PPOPN 1
28670: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28671: LD_EXP 61
28675: PPUSH
28676: CALL_OW 301
28680: PUSH
28681: LD_EXP 64
28685: PPUSH
28686: CALL_OW 301
28690: AND
28691: PUSH
28692: LD_INT 22
28694: PUSH
28695: LD_INT 3
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 21
28704: PUSH
28705: LD_INT 1
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 50
28714: PUSH
28715: EMPTY
28716: LIST
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: LIST
28722: PPUSH
28723: CALL_OW 69
28727: PUSH
28728: LD_INT 7
28730: PUSH
28731: LD_INT 8
28733: PUSH
28734: LD_INT 9
28736: PUSH
28737: EMPTY
28738: LIST
28739: LIST
28740: LIST
28741: PUSH
28742: LD_OWVAR 67
28746: ARRAY
28747: LESS
28748: AND
28749: IFFALSE 29520
28751: GO 28753
28753: DISABLE
28754: LD_INT 0
28756: PPUSH
28757: PPUSH
28758: PPUSH
28759: PPUSH
// begin MC_Kill ( 1 ) ;
28760: LD_INT 1
28762: PPUSH
28763: CALL 34143 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28767: LD_INT 1
28769: PPUSH
28770: LD_INT 3
28772: PPUSH
28773: LD_INT 1
28775: PPUSH
28776: LD_INT 1
28778: PPUSH
28779: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28783: LD_ADDR_VAR 0 1
28787: PUSH
28788: LD_INT 22
28790: PUSH
28791: LD_INT 3
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 21
28800: PUSH
28801: LD_INT 1
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 24
28810: PUSH
28811: LD_INT 900
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: LIST
28822: PPUSH
28823: CALL_OW 69
28827: PUSH
28828: FOR_IN
28829: IFFALSE 28860
// if GetSex ( i ) = sex_male then
28831: LD_VAR 0 1
28835: PPUSH
28836: CALL_OW 258
28840: PUSH
28841: LD_INT 1
28843: EQUAL
28844: IFFALSE 28858
// begin tmp = i ;
28846: LD_ADDR_VAR 0 2
28850: PUSH
28851: LD_VAR 0 1
28855: ST_TO_ADDR
// break ;
28856: GO 28860
// end ;
28858: GO 28828
28860: POP
28861: POP
// if tmp = 0 then
28862: LD_VAR 0 2
28866: PUSH
28867: LD_INT 0
28869: EQUAL
28870: IFFALSE 28924
// begin uc_side = 3 ;
28872: LD_ADDR_OWVAR 20
28876: PUSH
28877: LD_INT 3
28879: ST_TO_ADDR
// uc_nation = 3 ;
28880: LD_ADDR_OWVAR 21
28884: PUSH
28885: LD_INT 3
28887: ST_TO_ADDR
// hc_name =  ;
28888: LD_ADDR_OWVAR 26
28892: PUSH
28893: LD_STRING 
28895: ST_TO_ADDR
// hc_gallery =  ;
28896: LD_ADDR_OWVAR 33
28900: PUSH
28901: LD_STRING 
28903: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28904: LD_INT 1
28906: PPUSH
28907: LD_INT 10
28909: PPUSH
28910: CALL_OW 381
// tmp = CreateHuman ;
28914: LD_ADDR_VAR 0 2
28918: PUSH
28919: CALL_OW 44
28923: ST_TO_ADDR
// end ; DialogueOn ;
28924: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28928: LD_VAR 0 2
28932: PPUSH
28933: LD_STRING DSurrenderRussians-RSol1-1a
28935: PPUSH
28936: CALL_OW 88
// DialogueOff ;
28940: CALL_OW 7
// russianDestroyed := true ;
28944: LD_ADDR_EXP 21
28948: PUSH
28949: LD_INT 1
28951: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28952: LD_INT 22
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 21
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: PPUSH
28976: CALL_OW 69
28980: PPUSH
28981: CALL_OW 122
// wait ( 0 0$1 ) ;
28985: LD_INT 35
28987: PPUSH
28988: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28992: LD_INT 22
28994: PUSH
28995: LD_INT 3
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 21
29004: PUSH
29005: LD_INT 1
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PPUSH
29016: CALL_OW 69
29020: PPUSH
29021: LD_INT 25
29023: PPUSH
29024: CALL_OW 173
// wait ( 0 0$10 ) ;
29028: LD_INT 350
29030: PPUSH
29031: CALL_OW 67
// PrepareOmarInvasion ;
29035: CALL 13700 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29039: LD_ADDR_VAR 0 2
29043: PUSH
29044: LD_EXP 89
29048: PPUSH
29049: CALL_OW 250
29053: PUSH
29054: LD_EXP 89
29058: PPUSH
29059: CALL_OW 251
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29068: LD_VAR 0 2
29072: PUSH
29073: LD_INT 1
29075: ARRAY
29076: PPUSH
29077: LD_VAR 0 2
29081: PUSH
29082: LD_INT 2
29084: ARRAY
29085: PPUSH
29086: LD_INT 1
29088: PPUSH
29089: LD_INT 8
29091: NEG
29092: PPUSH
29093: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29097: LD_EXP 89
29101: PPUSH
29102: CALL_OW 87
// DialogueOn ;
29106: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29110: LD_EXP 36
29114: PPUSH
29115: LD_STRING D19-JMM-1
29117: PPUSH
29118: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29122: LD_ADDR_VAR 0 3
29126: PUSH
29127: LD_INT 22
29129: PUSH
29130: LD_INT 1
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 26
29139: PUSH
29140: LD_INT 1
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 2
29149: PUSH
29150: LD_INT 25
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 25
29162: PUSH
29163: LD_INT 2
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 25
29172: PUSH
29173: LD_INT 3
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 25
29182: PUSH
29183: LD_INT 4
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 25
29192: PUSH
29193: LD_INT 5
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 25
29202: PUSH
29203: LD_INT 8
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: LIST
29223: PPUSH
29224: CALL_OW 69
29228: PUSH
29229: LD_EXP 36
29233: PUSH
29234: LD_EXP 37
29238: PUSH
29239: LD_EXP 38
29243: PUSH
29244: LD_EXP 39
29248: PUSH
29249: LD_EXP 40
29253: PUSH
29254: LD_EXP 41
29258: PUSH
29259: LD_EXP 42
29263: PUSH
29264: LD_EXP 43
29268: PUSH
29269: LD_EXP 44
29273: PUSH
29274: LD_EXP 45
29278: PUSH
29279: LD_EXP 46
29283: PUSH
29284: LD_EXP 47
29288: PUSH
29289: LD_EXP 48
29293: PUSH
29294: LD_EXP 49
29298: PUSH
29299: LD_EXP 50
29303: PUSH
29304: LD_EXP 51
29308: PUSH
29309: LD_EXP 52
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: DIFF
29333: ST_TO_ADDR
// if tmp2 then
29334: LD_VAR 0 3
29338: IFFALSE 29356
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29340: LD_VAR 0 3
29344: PUSH
29345: LD_INT 1
29347: ARRAY
29348: PPUSH
29349: LD_STRING D19-Sol1-1
29351: PPUSH
29352: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29356: LD_EXP 36
29360: PPUSH
29361: LD_STRING D19-JMM-2
29363: PPUSH
29364: CALL_OW 88
// DialogueOff ;
29368: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29372: LD_VAR 0 2
29376: PUSH
29377: LD_INT 1
29379: ARRAY
29380: PPUSH
29381: LD_VAR 0 2
29385: PUSH
29386: LD_INT 2
29388: ARRAY
29389: PPUSH
29390: LD_INT 1
29392: PPUSH
29393: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29397: LD_STRING M5
29399: PPUSH
29400: CALL_OW 337
// omarOnMotherLode := false ;
29404: LD_ADDR_VAR 0 4
29408: PUSH
29409: LD_INT 0
29411: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29412: LD_INT 35
29414: PPUSH
29415: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29419: LD_EXP 89
29423: PPUSH
29424: LD_INT 215
29426: PPUSH
29427: LD_INT 100
29429: PPUSH
29430: CALL_OW 297
29434: PUSH
29435: LD_INT 10
29437: LESS
29438: PUSH
29439: LD_VAR 0 4
29443: NOT
29444: AND
29445: IFFALSE 29479
// begin omarOnMotherLode := true ;
29447: LD_ADDR_VAR 0 4
29451: PUSH
29452: LD_INT 1
29454: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29455: LD_EXP 36
29459: PPUSH
29460: LD_STRING D19b-JMM-1
29462: PPUSH
29463: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29467: LD_EXP 89
29471: PPUSH
29472: LD_STRING DOmarContam-Omar-1
29474: PPUSH
29475: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29479: LD_EXP 89
29483: PPUSH
29484: CALL_OW 301
29488: IFFALSE 29412
// Say ( JMM , D19a-JMM-1 ) ;
29490: LD_EXP 36
29494: PPUSH
29495: LD_STRING D19a-JMM-1
29497: PPUSH
29498: CALL_OW 88
// if Heike then
29502: LD_EXP 90
29506: IFFALSE 29520
// Say ( Heike , D19a-Hke-1 ) ;
29508: LD_EXP 90
29512: PPUSH
29513: LD_STRING D19a-Hke-1
29515: PPUSH
29516: CALL_OW 88
// end ;
29520: PPOPN 4
29522: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29523: LD_INT 22
29525: PUSH
29526: LD_INT 3
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 21
29535: PUSH
29536: LD_INT 1
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL_OW 69
29551: PUSH
29552: LD_EXP 21
29556: AND
29557: IFFALSE 29625
29559: GO 29561
29561: DISABLE
29562: LD_INT 0
29564: PPUSH
29565: PPUSH
// begin enable ;
29566: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29567: LD_ADDR_VAR 0 2
29571: PUSH
29572: LD_INT 25
29574: PPUSH
29575: LD_INT 22
29577: PUSH
29578: LD_INT 3
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PPUSH
29585: CALL_OW 70
29589: ST_TO_ADDR
// if not tmp then
29590: LD_VAR 0 2
29594: NOT
29595: IFFALSE 29599
// exit ;
29597: GO 29625
// for i in tmp do
29599: LD_ADDR_VAR 0 1
29603: PUSH
29604: LD_VAR 0 2
29608: PUSH
29609: FOR_IN
29610: IFFALSE 29623
// RemoveUnit ( i ) ;
29612: LD_VAR 0 1
29616: PPUSH
29617: CALL_OW 64
29621: GO 29609
29623: POP
29624: POP
// end ;
29625: PPOPN 2
29627: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29628: LD_INT 22
29630: PUSH
29631: LD_INT 7
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 21
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PPUSH
29652: CALL_OW 69
29656: PUSH
29657: LD_INT 6
29659: LESS
29660: IFFALSE 30111
29662: GO 29664
29664: DISABLE
29665: LD_INT 0
29667: PPUSH
29668: PPUSH
// begin MC_Kill ( 1 ) ;
29669: LD_INT 1
29671: PPUSH
29672: CALL 34143 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29676: LD_INT 7
29678: PPUSH
29679: LD_INT 1
29681: PPUSH
29682: LD_INT 1
29684: PPUSH
29685: LD_INT 1
29687: PPUSH
29688: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29692: LD_ADDR_VAR 0 1
29696: PUSH
29697: LD_INT 22
29699: PUSH
29700: LD_INT 7
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 26
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PPUSH
29721: CALL_OW 69
29725: PUSH
29726: LD_EXP 71
29730: DIFF
29731: ST_TO_ADDR
// if tmp then
29732: LD_VAR 0 1
29736: IFFALSE 29754
// tmp := tmp [ 1 ] else
29738: LD_ADDR_VAR 0 1
29742: PUSH
29743: LD_VAR 0 1
29747: PUSH
29748: LD_INT 1
29750: ARRAY
29751: ST_TO_ADDR
29752: GO 29790
// begin uc_side := 7 ;
29754: LD_ADDR_OWVAR 20
29758: PUSH
29759: LD_INT 7
29761: ST_TO_ADDR
// uc_nation := 1 ;
29762: LD_ADDR_OWVAR 21
29766: PUSH
29767: LD_INT 1
29769: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29770: LD_INT 1
29772: PPUSH
29773: LD_INT 8
29775: PPUSH
29776: CALL_OW 384
// tmp := CreateHuman ;
29780: LD_ADDR_VAR 0 1
29784: PUSH
29785: CALL_OW 44
29789: ST_TO_ADDR
// end ; DialogueOn ;
29790: CALL_OW 6
// if IsOK ( Roth ) then
29794: LD_EXP 71
29798: PPUSH
29799: CALL_OW 302
29803: IFFALSE 29817
// Say ( JMM , DAb-JMM-1 ) ;
29805: LD_EXP 36
29809: PPUSH
29810: LD_STRING DAb-JMM-1
29812: PPUSH
29813: CALL_OW 88
// if IsOK ( Roth ) then
29817: LD_EXP 71
29821: PPUSH
29822: CALL_OW 302
29826: IFFALSE 29850
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29828: LD_EXP 71
29832: PPUSH
29833: LD_STRING DSurrenderAlliance-Roth-1
29835: PPUSH
29836: CALL_OW 88
// RothCaptured := true ;
29840: LD_ADDR_EXP 33
29844: PUSH
29845: LD_INT 1
29847: ST_TO_ADDR
// end else
29848: GO 29862
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29850: LD_VAR 0 1
29854: PPUSH
29855: LD_STRING DSurrenderAlliance-Sci1-1
29857: PPUSH
29858: CALL_OW 88
// DialogueOff ;
29862: CALL_OW 7
// allianceDestroyed := true ;
29866: LD_ADDR_EXP 23
29870: PUSH
29871: LD_INT 1
29873: ST_TO_ADDR
// if trueAmericans then
29874: LD_EXP 35
29878: IFFALSE 29954
// begin if trueAmericans = 1 then
29880: LD_EXP 35
29884: PUSH
29885: LD_INT 1
29887: EQUAL
29888: IFFALSE 29904
// Say ( JMM , DAb-JMM-1a ) else
29890: LD_EXP 36
29894: PPUSH
29895: LD_STRING DAb-JMM-1a
29897: PPUSH
29898: CALL_OW 88
29902: GO 29916
// Say ( JMM , DAb-JMM-1b ) ;
29904: LD_EXP 36
29908: PPUSH
29909: LD_STRING DAb-JMM-1b
29911: PPUSH
29912: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29916: LD_EXP 35
29920: PPUSH
29921: CALL_OW 87
// for i in trueAmericans do
29925: LD_ADDR_VAR 0 2
29929: PUSH
29930: LD_EXP 35
29934: PUSH
29935: FOR_IN
29936: IFFALSE 29952
// SetSide ( i , 1 ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_INT 1
29945: PPUSH
29946: CALL_OW 235
29950: GO 29935
29952: POP
29953: POP
// end ; repeat wait ( 0 0$1 ) ;
29954: LD_INT 35
29956: PPUSH
29957: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29961: LD_ADDR_VAR 0 2
29965: PUSH
29966: LD_INT 22
29968: PUSH
29969: LD_INT 7
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 21
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PPUSH
29990: CALL_OW 69
29994: PUSH
29995: FOR_IN
29996: IFFALSE 30078
// begin if IsInUnit ( i ) then
29998: LD_VAR 0 2
30002: PPUSH
30003: CALL_OW 310
30007: IFFALSE 30018
// ComExitBuilding ( i ) ;
30009: LD_VAR 0 2
30013: PPUSH
30014: CALL_OW 122
// if IsDriver ( i ) then
30018: LD_VAR 0 2
30022: PPUSH
30023: CALL 104547 0 1
30027: IFFALSE 30038
// ComExitVehicle ( i ) ;
30029: LD_VAR 0 2
30033: PPUSH
30034: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30038: LD_VAR 0 2
30042: PPUSH
30043: LD_INT 26
30045: PPUSH
30046: CALL_OW 308
30050: NOT
30051: IFFALSE 30067
// AddComMoveToArea ( i , allianceEscapeArea ) else
30053: LD_VAR 0 2
30057: PPUSH
30058: LD_INT 26
30060: PPUSH
30061: CALL_OW 173
30065: GO 30076
// RemoveUnit ( i ) ;
30067: LD_VAR 0 2
30071: PPUSH
30072: CALL_OW 64
// end ;
30076: GO 29995
30078: POP
30079: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30080: LD_INT 22
30082: PUSH
30083: LD_INT 7
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 21
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PPUSH
30104: CALL_OW 69
30108: NOT
30109: IFFALSE 29954
// end ;
30111: PPOPN 2
30113: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30114: LD_INT 0
30116: PPUSH
30117: PPUSH
// if not unit then
30118: LD_VAR 0 1
30122: NOT
30123: IFFALSE 30127
// exit ;
30125: GO 31625
// DoNotAttack ( 7 , unit ) ;
30127: LD_INT 7
30129: PPUSH
30130: LD_VAR 0 1
30134: PPUSH
30135: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30139: LD_VAR 0 1
30143: PPUSH
30144: LD_INT 260
30146: PPUSH
30147: LD_INT 235
30149: PPUSH
30150: LD_INT 3
30152: PPUSH
30153: LD_INT 1
30155: PPUSH
30156: CALL_OW 483
// SetSide ( unit , 4 ) ;
30160: LD_VAR 0 1
30164: PPUSH
30165: LD_INT 4
30167: PPUSH
30168: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30172: LD_ADDR_EXP 34
30176: PUSH
30177: LD_EXP 34
30181: PUSH
30182: LD_INT 1
30184: PLUS
30185: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30186: LD_INT 70
30188: PPUSH
30189: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30193: LD_INT 260
30195: PPUSH
30196: LD_INT 235
30198: PPUSH
30199: LD_INT 1
30201: PPUSH
30202: LD_INT 8
30204: NEG
30205: PPUSH
30206: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30210: LD_VAR 0 1
30214: PPUSH
30215: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30219: LD_VAR 0 1
30223: PPUSH
30224: LD_EXP 71
30228: PPUSH
30229: CALL_OW 119
// DialogueOn ;
30233: CALL_OW 6
// case unit of JMM :
30237: LD_VAR 0 1
30241: PUSH
30242: LD_EXP 36
30246: DOUBLE
30247: EQUAL
30248: IFTRUE 30252
30250: GO 30267
30252: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30253: LD_EXP 36
30257: PPUSH
30258: LD_STRING DA1-JMM-1
30260: PPUSH
30261: CALL_OW 91
30265: GO 30709
30267: LD_EXP 37
30271: DOUBLE
30272: EQUAL
30273: IFTRUE 30277
30275: GO 30292
30277: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30278: LD_EXP 37
30282: PPUSH
30283: LD_STRING DA1-Joan-1
30285: PPUSH
30286: CALL_OW 91
30290: GO 30709
30292: LD_EXP 39
30296: DOUBLE
30297: EQUAL
30298: IFTRUE 30302
30300: GO 30317
30302: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30303: LD_EXP 39
30307: PPUSH
30308: LD_STRING DA1-Lisa-1
30310: PPUSH
30311: CALL_OW 91
30315: GO 30709
30317: LD_EXP 40
30321: DOUBLE
30322: EQUAL
30323: IFTRUE 30327
30325: GO 30342
30327: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30328: LD_EXP 40
30332: PPUSH
30333: LD_STRING DA1-Don-1
30335: PPUSH
30336: CALL_OW 91
30340: GO 30709
30342: LD_EXP 47
30346: DOUBLE
30347: EQUAL
30348: IFTRUE 30352
30350: GO 30367
30352: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30353: LD_EXP 47
30357: PPUSH
30358: LD_STRING DA1-Corn-1
30360: PPUSH
30361: CALL_OW 91
30365: GO 30709
30367: LD_EXP 43
30371: DOUBLE
30372: EQUAL
30373: IFTRUE 30377
30375: GO 30392
30377: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30378: LD_EXP 43
30382: PPUSH
30383: LD_STRING DA1-Den-1
30385: PPUSH
30386: CALL_OW 91
30390: GO 30709
30392: LD_EXP 41
30396: DOUBLE
30397: EQUAL
30398: IFTRUE 30402
30400: GO 30417
30402: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30403: LD_EXP 41
30407: PPUSH
30408: LD_STRING DA1-Bobby-1
30410: PPUSH
30411: CALL_OW 91
30415: GO 30709
30417: LD_EXP 45
30421: DOUBLE
30422: EQUAL
30423: IFTRUE 30427
30425: GO 30442
30427: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30428: LD_EXP 45
30432: PPUSH
30433: LD_STRING DA1-Glad-1
30435: PPUSH
30436: CALL_OW 91
30440: GO 30709
30442: LD_EXP 42
30446: DOUBLE
30447: EQUAL
30448: IFTRUE 30452
30450: GO 30467
30452: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30453: LD_EXP 42
30457: PPUSH
30458: LD_STRING DA1-Cyrus-1
30460: PPUSH
30461: CALL_OW 91
30465: GO 30709
30467: LD_EXP 38
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30492
30477: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30478: LD_EXP 38
30482: PPUSH
30483: LD_STRING DA1-Huck-1
30485: PPUSH
30486: CALL_OW 91
30490: GO 30709
30492: LD_EXP 52
30496: DOUBLE
30497: EQUAL
30498: IFTRUE 30502
30500: GO 30517
30502: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30503: LD_EXP 52
30507: PPUSH
30508: LD_STRING DA1-Huck-1
30510: PPUSH
30511: CALL_OW 91
30515: GO 30709
30517: LD_EXP 44
30521: DOUBLE
30522: EQUAL
30523: IFTRUE 30527
30525: GO 30542
30527: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30528: LD_EXP 44
30532: PPUSH
30533: LD_STRING DA1-Brown-1
30535: PPUSH
30536: CALL_OW 91
30540: GO 30709
30542: LD_EXP 48
30546: DOUBLE
30547: EQUAL
30548: IFTRUE 30552
30550: GO 30567
30552: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30553: LD_EXP 48
30557: PPUSH
30558: LD_STRING DA1-Gary-1
30560: PPUSH
30561: CALL_OW 91
30565: GO 30709
30567: LD_EXP 51
30571: DOUBLE
30572: EQUAL
30573: IFTRUE 30577
30575: GO 30592
30577: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30578: LD_EXP 51
30582: PPUSH
30583: LD_STRING DA1-Con-1
30585: PPUSH
30586: CALL_OW 91
30590: GO 30709
30592: LD_EXP 57
30596: DOUBLE
30597: EQUAL
30598: IFTRUE 30602
30600: GO 30617
30602: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30603: LD_EXP 57
30607: PPUSH
30608: LD_STRING DA1-Kurt-1
30610: PPUSH
30611: CALL_OW 91
30615: GO 30709
30617: LD_EXP 50
30621: DOUBLE
30622: EQUAL
30623: IFTRUE 30627
30625: GO 30642
30627: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30628: LD_EXP 50
30632: PPUSH
30633: LD_STRING DA1-Yam-1
30635: PPUSH
30636: CALL_OW 91
30640: GO 30709
30642: LD_EXP 49
30646: DOUBLE
30647: EQUAL
30648: IFTRUE 30652
30650: GO 30667
30652: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30653: LD_EXP 49
30657: PPUSH
30658: LD_STRING DA1-Frank-1
30660: PPUSH
30661: CALL_OW 91
30665: GO 30709
30667: POP
// begin if GetSex ( unit ) = sex_male then
30668: LD_VAR 0 1
30672: PPUSH
30673: CALL_OW 258
30677: PUSH
30678: LD_INT 1
30680: EQUAL
30681: IFFALSE 30697
// ForceSay ( unit , DA1-Sol1-1 ) else
30683: LD_VAR 0 1
30687: PPUSH
30688: LD_STRING DA1-Sol1-1
30690: PPUSH
30691: CALL_OW 91
30695: GO 30709
// ForceSay ( unit , DA1-FSol1-1 ) ;
30697: LD_VAR 0 1
30701: PPUSH
30702: LD_STRING DA1-FSol1-1
30704: PPUSH
30705: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30709: LD_EXP 71
30713: PPUSH
30714: LD_STRING DA-Roth-1
30716: PPUSH
30717: CALL_OW 88
// if capturedUnit = 1 then
30721: LD_EXP 34
30725: PUSH
30726: LD_INT 1
30728: EQUAL
30729: IFFALSE 30757
// begin Say ( Simms , DA-Sim-1 ) ;
30731: LD_EXP 72
30735: PPUSH
30736: LD_STRING DA-Sim-1
30738: PPUSH
30739: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30743: LD_EXP 71
30747: PPUSH
30748: LD_STRING DA-Roth-2
30750: PPUSH
30751: CALL_OW 88
// end else
30755: GO 30769
// Say ( Simms , DA-Sim-2 ) ;
30757: LD_EXP 72
30761: PPUSH
30762: LD_STRING DA-Sim-2
30764: PPUSH
30765: CALL_OW 88
// case unit of JMM :
30769: LD_VAR 0 1
30773: PUSH
30774: LD_EXP 36
30778: DOUBLE
30779: EQUAL
30780: IFTRUE 30784
30782: GO 30799
30784: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30785: LD_EXP 36
30789: PPUSH
30790: LD_STRING DA1-JMM-1a
30792: PPUSH
30793: CALL_OW 91
30797: GO 31306
30799: LD_EXP 37
30803: DOUBLE
30804: EQUAL
30805: IFTRUE 30809
30807: GO 30824
30809: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30810: LD_EXP 37
30814: PPUSH
30815: LD_STRING DA1-Joan-1a
30817: PPUSH
30818: CALL_OW 91
30822: GO 31306
30824: LD_EXP 39
30828: DOUBLE
30829: EQUAL
30830: IFTRUE 30834
30832: GO 30849
30834: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30835: LD_EXP 39
30839: PPUSH
30840: LD_STRING DA1-Lisa-1a
30842: PPUSH
30843: CALL_OW 91
30847: GO 31306
30849: LD_EXP 40
30853: DOUBLE
30854: EQUAL
30855: IFTRUE 30859
30857: GO 30874
30859: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30860: LD_EXP 40
30864: PPUSH
30865: LD_STRING DA1-Don-1a
30867: PPUSH
30868: CALL_OW 91
30872: GO 31306
30874: LD_EXP 47
30878: DOUBLE
30879: EQUAL
30880: IFTRUE 30884
30882: GO 30899
30884: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30885: LD_EXP 47
30889: PPUSH
30890: LD_STRING DA1-Corn-1a
30892: PPUSH
30893: CALL_OW 91
30897: GO 31306
30899: LD_EXP 43
30903: DOUBLE
30904: EQUAL
30905: IFTRUE 30909
30907: GO 30924
30909: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30910: LD_EXP 43
30914: PPUSH
30915: LD_STRING DA1-Den-1a
30917: PPUSH
30918: CALL_OW 91
30922: GO 31306
30924: LD_EXP 41
30928: DOUBLE
30929: EQUAL
30930: IFTRUE 30934
30932: GO 30949
30934: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30935: LD_EXP 41
30939: PPUSH
30940: LD_STRING DA1-Bobby-1a
30942: PPUSH
30943: CALL_OW 91
30947: GO 31306
30949: LD_EXP 45
30953: DOUBLE
30954: EQUAL
30955: IFTRUE 30959
30957: GO 30974
30959: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30960: LD_EXP 45
30964: PPUSH
30965: LD_STRING DA1-Glad-1a
30967: PPUSH
30968: CALL_OW 91
30972: GO 31306
30974: LD_EXP 42
30978: DOUBLE
30979: EQUAL
30980: IFTRUE 30984
30982: GO 30999
30984: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30985: LD_EXP 42
30989: PPUSH
30990: LD_STRING DA1-Cyrus-1a
30992: PPUSH
30993: CALL_OW 91
30997: GO 31306
30999: LD_EXP 38
31003: DOUBLE
31004: EQUAL
31005: IFTRUE 31009
31007: GO 31024
31009: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31010: LD_EXP 38
31014: PPUSH
31015: LD_STRING DA1-Huck-1a
31017: PPUSH
31018: CALL_OW 91
31022: GO 31306
31024: LD_EXP 52
31028: DOUBLE
31029: EQUAL
31030: IFTRUE 31034
31032: GO 31049
31034: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31035: LD_EXP 52
31039: PPUSH
31040: LD_STRING DA1-Huck-1a
31042: PPUSH
31043: CALL_OW 91
31047: GO 31306
31049: LD_EXP 44
31053: DOUBLE
31054: EQUAL
31055: IFTRUE 31059
31057: GO 31074
31059: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31060: LD_EXP 44
31064: PPUSH
31065: LD_STRING DA1-Brown-1a
31067: PPUSH
31068: CALL_OW 91
31072: GO 31306
31074: LD_EXP 48
31078: DOUBLE
31079: EQUAL
31080: IFTRUE 31084
31082: GO 31099
31084: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31085: LD_EXP 48
31089: PPUSH
31090: LD_STRING DA1-Gary-1a
31092: PPUSH
31093: CALL_OW 91
31097: GO 31306
31099: LD_EXP 51
31103: DOUBLE
31104: EQUAL
31105: IFTRUE 31109
31107: GO 31124
31109: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31110: LD_EXP 51
31114: PPUSH
31115: LD_STRING DA1-Con-1a
31117: PPUSH
31118: CALL_OW 91
31122: GO 31306
31124: LD_EXP 57
31128: DOUBLE
31129: EQUAL
31130: IFTRUE 31134
31132: GO 31149
31134: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31135: LD_EXP 57
31139: PPUSH
31140: LD_STRING DA1-Kurt-1a
31142: PPUSH
31143: CALL_OW 91
31147: GO 31306
31149: LD_EXP 50
31153: DOUBLE
31154: EQUAL
31155: IFTRUE 31159
31157: GO 31174
31159: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31160: LD_EXP 50
31164: PPUSH
31165: LD_STRING DA1-Yam-1a
31167: PPUSH
31168: CALL_OW 91
31172: GO 31306
31174: LD_EXP 49
31178: DOUBLE
31179: EQUAL
31180: IFTRUE 31184
31182: GO 31199
31184: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31185: LD_EXP 49
31189: PPUSH
31190: LD_STRING DA1-Frank-1a
31192: PPUSH
31193: CALL_OW 91
31197: GO 31306
31199: POP
// begin join := rand ( 0 , 1 ) ;
31200: LD_ADDR_VAR 0 3
31204: PUSH
31205: LD_INT 0
31207: PPUSH
31208: LD_INT 1
31210: PPUSH
31211: CALL_OW 12
31215: ST_TO_ADDR
// if join then
31216: LD_VAR 0 3
31220: IFFALSE 31265
// begin if GetSex ( unit ) = sex_male then
31222: LD_VAR 0 1
31226: PPUSH
31227: CALL_OW 258
31231: PUSH
31232: LD_INT 1
31234: EQUAL
31235: IFFALSE 31251
// ForceSay ( unit , DA1-Sol1-1b ) else
31237: LD_VAR 0 1
31241: PPUSH
31242: LD_STRING DA1-Sol1-1b
31244: PPUSH
31245: CALL_OW 91
31249: GO 31263
// ForceSay ( unit , DA1-FSol1-1b ) ;
31251: LD_VAR 0 1
31255: PPUSH
31256: LD_STRING DA1-FSol1-1b
31258: PPUSH
31259: CALL_OW 91
// end else
31263: GO 31306
// begin if GetSex ( unit ) = sex_male then
31265: LD_VAR 0 1
31269: PPUSH
31270: CALL_OW 258
31274: PUSH
31275: LD_INT 1
31277: EQUAL
31278: IFFALSE 31294
// ForceSay ( unit , DA1-Sol1-1a ) else
31280: LD_VAR 0 1
31284: PPUSH
31285: LD_STRING DA1-Sol1-1a
31287: PPUSH
31288: CALL_OW 91
31292: GO 31306
// ForceSay ( unit , DA1-FSol1-1a ) ;
31294: LD_VAR 0 1
31298: PPUSH
31299: LD_STRING DA1-FSol1-1a
31301: PPUSH
31302: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31306: LD_VAR 0 1
31310: PUSH
31311: LD_EXP 36
31315: EQUAL
31316: IFFALSE 31327
// begin YouLost ( JMMCaptured ) ;
31318: LD_STRING JMMCaptured
31320: PPUSH
31321: CALL_OW 104
// exit ;
31325: GO 31625
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31327: LD_VAR 0 1
31331: PUSH
31332: LD_EXP 40
31336: PUSH
31337: LD_EXP 43
31341: PUSH
31342: LD_EXP 41
31346: PUSH
31347: LD_EXP 38
31351: PUSH
31352: LD_EXP 52
31356: PUSH
31357: LD_EXP 44
31361: PUSH
31362: LD_EXP 50
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: IN
31376: PUSH
31377: LD_VAR 0 3
31381: OR
31382: IFFALSE 31481
// begin Say ( Roth , DA-Roth-3 ) ;
31384: LD_EXP 71
31388: PPUSH
31389: LD_STRING DA-Roth-3
31391: PPUSH
31392: CALL_OW 88
// SetSide ( unit , 7 ) ;
31396: LD_VAR 0 1
31400: PPUSH
31401: LD_INT 7
31403: PPUSH
31404: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31408: LD_ADDR_EXP 99
31412: PUSH
31413: LD_EXP 99
31417: PPUSH
31418: LD_INT 1
31420: PPUSH
31421: LD_EXP 99
31425: PUSH
31426: LD_INT 1
31428: ARRAY
31429: PUSH
31430: LD_VAR 0 1
31434: ADD
31435: PPUSH
31436: CALL_OW 1
31440: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31441: LD_INT 260
31443: PPUSH
31444: LD_INT 235
31446: PPUSH
31447: LD_INT 1
31449: PPUSH
31450: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31454: LD_VAR 0 1
31458: PPUSH
31459: LD_INT 1000
31461: PPUSH
31462: CALL_OW 234
// DialogueOff ;
31466: CALL_OW 7
// ComFree ( unit ) ;
31470: LD_VAR 0 1
31474: PPUSH
31475: CALL_OW 139
// end else
31479: GO 31562
// begin Say ( Roth , DA-Roth-3a ) ;
31481: LD_EXP 71
31485: PPUSH
31486: LD_STRING DA-Roth-3a
31488: PPUSH
31489: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31493: LD_ADDR_EXP 35
31497: PUSH
31498: LD_EXP 35
31502: PUSH
31503: LD_VAR 0 1
31507: ADD
31508: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31509: LD_INT 260
31511: PPUSH
31512: LD_INT 235
31514: PPUSH
31515: LD_INT 1
31517: PPUSH
31518: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31522: LD_VAR 0 1
31526: PPUSH
31527: LD_INT 1000
31529: PPUSH
31530: CALL_OW 234
// DialogueOff ;
31534: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31538: LD_VAR 0 1
31542: PPUSH
31543: LD_INT 272
31545: PPUSH
31546: LD_INT 254
31548: PPUSH
31549: CALL_OW 111
// AddComHold ( unit ) ;
31553: LD_VAR 0 1
31557: PPUSH
31558: CALL_OW 200
// end ; if capturedUnit = 1 then
31562: LD_EXP 34
31566: PUSH
31567: LD_INT 1
31569: EQUAL
31570: IFFALSE 31625
// begin DialogueOn ;
31572: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31576: LD_EXP 36
31580: PPUSH
31581: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31585: LD_EXP 36
31589: PPUSH
31590: LD_STRING DAa-JMM-1
31592: PPUSH
31593: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31597: LD_EXP 36
31601: PPUSH
31602: LD_STRING DAa-JMM-1a
31604: PPUSH
31605: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31609: LD_EXP 36
31613: PPUSH
31614: LD_STRING DAa-JMM-1b
31616: PPUSH
31617: CALL_OW 88
// DialogueOff ;
31621: CALL_OW 7
// end ; end ;
31625: LD_VAR 0 2
31629: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31630: LD_EXP 15
31634: PUSH
31635: LD_INT 13
31637: GREATEREQUAL
31638: PUSH
31639: LD_INT 22
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 21
31651: PUSH
31652: LD_INT 1
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PPUSH
31663: CALL_OW 69
31667: PUSH
31668: LD_INT 0
31670: EQUAL
31671: AND
31672: PUSH
31673: LD_INT 22
31675: PUSH
31676: LD_INT 2
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 21
31685: PUSH
31686: LD_INT 2
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 50
31695: PUSH
31696: EMPTY
31697: LIST
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: LIST
31703: PPUSH
31704: CALL_OW 69
31708: PUSH
31709: LD_INT 0
31711: EQUAL
31712: AND
31713: PUSH
31714: LD_EXP 21
31718: AND
31719: PUSH
31720: LD_EXP 22
31724: AND
31725: PUSH
31726: LD_EXP 23
31730: AND
31731: IFFALSE 32335
31733: GO 31735
31735: DISABLE
31736: LD_INT 0
31738: PPUSH
31739: PPUSH
31740: PPUSH
// begin m1 := false ;
31741: LD_ADDR_VAR 0 1
31745: PUSH
31746: LD_INT 0
31748: ST_TO_ADDR
// m2 := false ;
31749: LD_ADDR_VAR 0 2
31753: PUSH
31754: LD_INT 0
31756: ST_TO_ADDR
// m3 := false ;
31757: LD_ADDR_VAR 0 3
31761: PUSH
31762: LD_INT 0
31764: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
31765: LD_EXP 36
31769: PPUSH
31770: CALL_OW 87
// music_class := 5 ;
31774: LD_ADDR_OWVAR 72
31778: PUSH
31779: LD_INT 5
31781: ST_TO_ADDR
// music_nat := 5 ;
31782: LD_ADDR_OWVAR 71
31786: PUSH
31787: LD_INT 5
31789: ST_TO_ADDR
// DialogueOn ;
31790: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
31794: LD_EXP 36
31798: PPUSH
31799: LD_STRING D20-JMM-1
31801: PPUSH
31802: CALL_OW 88
// if IsOK ( Joan ) then
31806: LD_EXP 37
31810: PPUSH
31811: CALL_OW 302
31815: IFFALSE 31829
// Say ( Joan , D20-Joan-1 ) ;
31817: LD_EXP 37
31821: PPUSH
31822: LD_STRING D20-Joan-1
31824: PPUSH
31825: CALL_OW 88
// if IsOk ( Lisa ) then
31829: LD_EXP 39
31833: PPUSH
31834: CALL_OW 302
31838: IFFALSE 31852
// Say ( Lisa , D20-Lisa-1 ) ;
31840: LD_EXP 39
31844: PPUSH
31845: LD_STRING D20-Lisa-1
31847: PPUSH
31848: CALL_OW 88
// if IsOk ( Donaldson ) then
31852: LD_EXP 40
31856: PPUSH
31857: CALL_OW 302
31861: IFFALSE 31875
// Say ( Donaldson , D20-Don-1 ) ;
31863: LD_EXP 40
31867: PPUSH
31868: LD_STRING D20-Don-1
31870: PPUSH
31871: CALL_OW 88
// if IsOK ( Cornel ) then
31875: LD_EXP 47
31879: PPUSH
31880: CALL_OW 302
31884: IFFALSE 31898
// Say ( Cornel , D20-Corn-1 ) ;
31886: LD_EXP 47
31890: PPUSH
31891: LD_STRING D20-Corn-1
31893: PPUSH
31894: CALL_OW 88
// if IsOk ( Denis ) then
31898: LD_EXP 43
31902: PPUSH
31903: CALL_OW 302
31907: IFFALSE 31921
// Say ( Denis , D20-Den-1 ) ;
31909: LD_EXP 43
31913: PPUSH
31914: LD_STRING D20-Den-1
31916: PPUSH
31917: CALL_OW 88
// if IsOk ( Bobby ) then
31921: LD_EXP 41
31925: PPUSH
31926: CALL_OW 302
31930: IFFALSE 31944
// Say ( Bobby , D20-Bobby-1 ) ;
31932: LD_EXP 41
31936: PPUSH
31937: LD_STRING D20-Bobby-1
31939: PPUSH
31940: CALL_OW 88
// if IsOk ( Gladstone ) then
31944: LD_EXP 45
31948: PPUSH
31949: CALL_OW 302
31953: IFFALSE 31967
// Say ( Gladstone , D20-Glad-1 ) ;
31955: LD_EXP 45
31959: PPUSH
31960: LD_STRING D20-Glad-1
31962: PPUSH
31963: CALL_OW 88
// if IsOk ( Cyrus ) then
31967: LD_EXP 42
31971: PPUSH
31972: CALL_OW 302
31976: IFFALSE 31990
// Say ( Cyrus , D20-Cyrus-1 ) ;
31978: LD_EXP 42
31982: PPUSH
31983: LD_STRING D20-Cyrus-1
31985: PPUSH
31986: CALL_OW 88
// if IsOk ( Stevens ) then
31990: LD_EXP 38
31994: PPUSH
31995: CALL_OW 302
31999: IFFALSE 32013
// Say ( Stevens , D20-Huck-1 ) ;
32001: LD_EXP 38
32005: PPUSH
32006: LD_STRING D20-Huck-1
32008: PPUSH
32009: CALL_OW 88
// if IsOk ( Brown ) then
32013: LD_EXP 44
32017: PPUSH
32018: CALL_OW 302
32022: IFFALSE 32036
// Say ( Brown , D20-Brown-1 ) ;
32024: LD_EXP 44
32028: PPUSH
32029: LD_STRING D20-Brown-1
32031: PPUSH
32032: CALL_OW 88
// if IsOk ( Gary ) then
32036: LD_EXP 48
32040: PPUSH
32041: CALL_OW 302
32045: IFFALSE 32059
// Say ( Gary , D20-Gary-1 ) ;
32047: LD_EXP 48
32051: PPUSH
32052: LD_STRING D20-Gary-1
32054: PPUSH
32055: CALL_OW 88
// if IsOk ( Connie ) then
32059: LD_EXP 51
32063: PPUSH
32064: CALL_OW 302
32068: IFFALSE 32082
// Say ( Connie , D20-Con-1 ) ;
32070: LD_EXP 51
32074: PPUSH
32075: LD_STRING D20-Con-1
32077: PPUSH
32078: CALL_OW 88
// if IsOk ( Kurt ) then
32082: LD_EXP 57
32086: PPUSH
32087: CALL_OW 302
32091: IFFALSE 32105
// Say ( Kurt , D20-Kurt-1 ) ;
32093: LD_EXP 57
32097: PPUSH
32098: LD_STRING D20-Kurt-1
32100: PPUSH
32101: CALL_OW 88
// if IsOk ( Kikuchi ) then
32105: LD_EXP 50
32109: PPUSH
32110: CALL_OW 302
32114: IFFALSE 32128
// Say ( Kikuchi , D20-Yam-1 ) ;
32116: LD_EXP 50
32120: PPUSH
32121: LD_STRING D20-Yam-1
32123: PPUSH
32124: CALL_OW 88
// if IsOk ( Frank ) then
32128: LD_EXP 49
32132: PPUSH
32133: CALL_OW 302
32137: IFFALSE 32151
// Say ( Frank , D20-Frank-1 ) ;
32139: LD_EXP 49
32143: PPUSH
32144: LD_STRING D20-Frank-1
32146: PPUSH
32147: CALL_OW 88
// DialogueOff ;
32151: CALL_OW 7
// if RothCaptured then
32155: LD_EXP 33
32159: IFFALSE 32181
// begin m1 := true ;
32161: LD_ADDR_VAR 0 1
32165: PUSH
32166: LD_INT 1
32168: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32169: LD_STRING Roth
32171: PPUSH
32172: LD_INT 1
32174: PPUSH
32175: CALL_OW 101
// end else
32179: GO 32192
// AddMedal ( Roth , - 1 ) ;
32181: LD_STRING Roth
32183: PPUSH
32184: LD_INT 1
32186: NEG
32187: PPUSH
32188: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32192: LD_EXP 27
32196: IFFALSE 32218
// begin m2 := true ;
32198: LD_ADDR_VAR 0 2
32202: PUSH
32203: LD_INT 1
32205: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32206: LD_STRING Project
32208: PPUSH
32209: LD_INT 1
32211: PPUSH
32212: CALL_OW 101
// end else
32216: GO 32229
// AddMedal ( Project , - 1 ) ;
32218: LD_STRING Project
32220: PPUSH
32221: LD_INT 1
32223: NEG
32224: PPUSH
32225: CALL_OW 101
// if lostCounter = 0 then
32229: LD_EXP 32
32233: PUSH
32234: LD_INT 0
32236: EQUAL
32237: IFFALSE 32259
// begin m3 := true ;
32239: LD_ADDR_VAR 0 3
32243: PUSH
32244: LD_INT 1
32246: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32247: LD_STRING NoLosses
32249: PPUSH
32250: LD_INT 1
32252: PPUSH
32253: CALL_OW 101
// end else
32257: GO 32270
// AddMedal ( NoLosses , - 1 ) ;
32259: LD_STRING NoLosses
32261: PPUSH
32262: LD_INT 1
32264: NEG
32265: PPUSH
32266: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32270: LD_VAR 0 1
32274: PUSH
32275: LD_VAR 0 2
32279: AND
32280: PUSH
32281: LD_VAR 0 3
32285: AND
32286: PUSH
32287: LD_OWVAR 67
32291: PUSH
32292: LD_INT 3
32294: EQUAL
32295: AND
32296: IFFALSE 32308
// SetAchievementEX ( ACH_AMER , 15 ) ;
32298: LD_STRING ACH_AMER
32300: PPUSH
32301: LD_INT 15
32303: PPUSH
32304: CALL_OW 564
// GiveMedals ( MAIN ) ;
32308: LD_STRING MAIN
32310: PPUSH
32311: CALL_OW 102
// music_class := 4 ;
32315: LD_ADDR_OWVAR 72
32319: PUSH
32320: LD_INT 4
32322: ST_TO_ADDR
// music_nat := 1 ;
32323: LD_ADDR_OWVAR 71
32327: PUSH
32328: LD_INT 1
32330: ST_TO_ADDR
// YouWin ;
32331: CALL_OW 103
// end ; end_of_file
32335: PPOPN 3
32337: END
// export function CustomEvent ( event ) ; begin
32338: LD_INT 0
32340: PPUSH
// end ;
32341: LD_VAR 0 2
32345: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32346: LD_VAR 0 1
32350: PUSH
32351: LD_INT 1
32353: EQUAL
32354: PUSH
32355: LD_VAR 0 2
32359: PUSH
32360: LD_INT 4
32362: EQUAL
32363: AND
32364: PUSH
32365: LD_EXP 55
32369: PPUSH
32370: CALL_OW 300
32374: AND
32375: IFFALSE 32391
// begin wait ( 0 0$2 ) ;
32377: LD_INT 70
32379: PPUSH
32380: CALL_OW 67
// YouLost ( Dismissed ) ;
32384: LD_STRING Dismissed
32386: PPUSH
32387: CALL_OW 104
// end ; end ;
32391: PPOPN 2
32393: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32394: LD_VAR 0 2
32398: PPUSH
32399: LD_VAR 0 3
32403: PPUSH
32404: LD_INT 18
32406: PPUSH
32407: CALL_OW 309
32411: IFFALSE 32420
// YouLost ( Motherlode3 ) ;
32413: LD_STRING Motherlode3
32415: PPUSH
32416: CALL_OW 104
// end ;
32420: PPOPN 3
32422: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32423: LD_EXP 27
32427: NOT
32428: IFFALSE 32438
// behemothDone := true ;
32430: LD_ADDR_EXP 28
32434: PUSH
32435: LD_INT 1
32437: ST_TO_ADDR
// end ;
32438: PPOPN 1
32440: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 255
32450: PUSH
32451: LD_INT 1
32453: EQUAL
32454: PUSH
32455: LD_EXP 30
32459: AND
32460: PUSH
32461: LD_INT 22
32463: PUSH
32464: LD_INT 3
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 34
32473: PUSH
32474: LD_INT 48
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PPUSH
32485: CALL_OW 69
32489: AND
32490: PUSH
32491: LD_INT 22
32493: PUSH
32494: LD_INT 1
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 34
32503: PUSH
32504: LD_INT 8
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PPUSH
32515: CALL_OW 69
32519: NOT
32520: AND
32521: IFFALSE 32573
// begin wait ( 0 0$5 ) ;
32523: LD_INT 175
32525: PPUSH
32526: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32530: LD_INT 22
32532: PUSH
32533: LD_INT 3
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 34
32542: PUSH
32543: LD_INT 48
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PPUSH
32554: CALL_OW 69
32558: PUSH
32559: LD_INT 1
32561: ARRAY
32562: PPUSH
32563: LD_INT 60
32565: PPUSH
32566: LD_INT 95
32568: PPUSH
32569: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32573: LD_VAR 0 2
32577: PPUSH
32578: LD_VAR 0 3
32582: PPUSH
32583: LD_INT 18
32585: PPUSH
32586: CALL_OW 309
32590: IFFALSE 32650
// begin if GetSide ( unit ) = 1 then
32592: LD_VAR 0 1
32596: PPUSH
32597: CALL_OW 255
32601: PUSH
32602: LD_INT 1
32604: EQUAL
32605: IFFALSE 32621
// begin wait ( 0 0$6 ) ;
32607: LD_INT 210
32609: PPUSH
32610: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32614: LD_STRING Motherlode2
32616: PPUSH
32617: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32621: LD_VAR 0 1
32625: PPUSH
32626: CALL_OW 255
32630: PUSH
32631: LD_INT 8
32633: EQUAL
32634: IFFALSE 32650
// begin wait ( 0 0$6 ) ;
32636: LD_INT 210
32638: PPUSH
32639: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32643: LD_STRING Motherlode1
32645: PPUSH
32646: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32650: LD_VAR 0 1
32654: PPUSH
32655: CALL_OW 255
32659: PUSH
32660: LD_INT 3
32662: EQUAL
32663: IFFALSE 32684
// begin wait ( 0 0$5 ) ;
32665: LD_INT 175
32667: PPUSH
32668: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32672: LD_EXP 61
32676: PPUSH
32677: LD_STRING D18-Pla-1
32679: PPUSH
32680: CALL_OW 94
// end ; end ;
32684: PPOPN 3
32686: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32687: LD_VAR 0 1
32691: PUSH
32692: LD_EXP 70
32696: IN
32697: IFFALSE 32717
// begin behemothBuilders := behemothBuilders diff un ;
32699: LD_ADDR_EXP 70
32703: PUSH
32704: LD_EXP 70
32708: PUSH
32709: LD_VAR 0 1
32713: DIFF
32714: ST_TO_ADDR
// exit ;
32715: GO 32815
// end ; if un = JMM then
32717: LD_VAR 0 1
32721: PUSH
32722: LD_EXP 36
32726: EQUAL
32727: IFFALSE 32738
// begin YouLost ( JMM ) ;
32729: LD_STRING JMM
32731: PPUSH
32732: CALL_OW 104
// exit ;
32736: GO 32815
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32738: LD_VAR 0 1
32742: PUSH
32743: LD_INT 22
32745: PUSH
32746: LD_INT 1
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: PUSH
32753: LD_INT 3
32755: PUSH
32756: LD_INT 25
32758: PUSH
32759: LD_INT 16
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 25
32768: PUSH
32769: LD_INT 12
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: LIST
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PPUSH
32785: CALL_OW 69
32789: IN
32790: IFFALSE 32806
// lostCounter := lostCounter + 1 ;
32792: LD_ADDR_EXP 32
32796: PUSH
32797: LD_EXP 32
32801: PUSH
32802: LD_INT 1
32804: PLUS
32805: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32806: LD_VAR 0 1
32810: PPUSH
32811: CALL 61099 0 1
// end ;
32815: PPOPN 1
32817: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32818: LD_VAR 0 1
32822: PPUSH
32823: LD_VAR 0 2
32827: PPUSH
32828: CALL 63433 0 2
// end ;
32832: PPOPN 2
32834: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32835: LD_VAR 0 1
32839: PPUSH
32840: CALL 62501 0 1
// end ;
32844: PPOPN 1
32846: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32847: LD_VAR 0 1
32851: PUSH
32852: LD_INT 22
32854: PUSH
32855: LD_INT 8
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: LD_INT 30
32864: PUSH
32865: LD_INT 2
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: PUSH
32872: LD_INT 23
32874: PUSH
32875: LD_INT 3
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: LIST
32886: PPUSH
32887: CALL_OW 69
32891: IN
32892: IFFALSE 32919
// begin ComUpgrade ( building ) ;
32894: LD_VAR 0 1
32898: PPUSH
32899: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32903: LD_EXP 58
32907: PPUSH
32908: LD_VAR 0 1
32912: PPUSH
32913: CALL 74050 0 2
// exit ;
32917: GO 32928
// end ; MCE_BuildingComplete ( building ) ;
32919: LD_VAR 0 1
32923: PPUSH
32924: CALL 62742 0 1
// end ;
32928: PPOPN 1
32930: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32931: LD_VAR 0 1
32935: PPUSH
32936: LD_VAR 0 2
32940: PPUSH
32941: CALL 60795 0 2
// end ;
32945: PPOPN 2
32947: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32948: LD_VAR 0 1
32952: PPUSH
32953: LD_VAR 0 2
32957: PPUSH
32958: LD_VAR 0 3
32962: PPUSH
32963: LD_VAR 0 4
32967: PPUSH
32968: LD_VAR 0 5
32972: PPUSH
32973: CALL 60415 0 5
// end ;
32977: PPOPN 5
32979: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32980: LD_VAR 0 1
32984: PPUSH
32985: LD_VAR 0 2
32989: PPUSH
32990: CALL 60011 0 2
// end ;
32994: PPOPN 2
32996: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32997: LD_VAR 0 1
33001: PPUSH
33002: LD_VAR 0 2
33006: PPUSH
33007: LD_VAR 0 3
33011: PPUSH
33012: LD_VAR 0 4
33016: PPUSH
33017: CALL 59849 0 4
// end ;
33021: PPOPN 4
33023: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33024: LD_VAR 0 1
33028: PPUSH
33029: LD_VAR 0 2
33033: PPUSH
33034: LD_VAR 0 3
33038: PPUSH
33039: CALL 59624 0 3
// end ;
33043: PPOPN 3
33045: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33046: LD_VAR 0 1
33050: PPUSH
33051: LD_VAR 0 2
33055: PPUSH
33056: CALL 59509 0 2
// end ;
33060: PPOPN 2
33062: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33063: LD_VAR 0 1
33067: PPUSH
33068: LD_VAR 0 2
33072: PPUSH
33073: CALL 63694 0 2
// end ;
33077: PPOPN 2
33079: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33080: LD_VAR 0 1
33084: PPUSH
33085: CALL_OW 255
33089: PUSH
33090: LD_INT 4
33092: EQUAL
33093: PUSH
33094: LD_VAR 0 1
33098: PUSH
33099: LD_EXP 18
33103: PUSH
33104: LD_INT 1
33106: ARRAY
33107: IN
33108: AND
33109: PUSH
33110: LD_EXP 19
33114: AND
33115: IFFALSE 33134
// begin ComMoveXY ( driver , 61 , 93 ) ;
33117: LD_VAR 0 1
33121: PPUSH
33122: LD_INT 61
33124: PPUSH
33125: LD_INT 93
33127: PPUSH
33128: CALL_OW 111
// exit ;
33132: GO 33158
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33134: LD_VAR 0 1
33138: PPUSH
33139: LD_VAR 0 2
33143: PPUSH
33144: LD_VAR 0 3
33148: PPUSH
33149: LD_VAR 0 4
33153: PPUSH
33154: CALL 63910 0 4
// end ;
33158: PPOPN 4
33160: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33161: LD_VAR 0 1
33165: PPUSH
33166: LD_VAR 0 2
33170: PPUSH
33171: CALL 59318 0 2
// end ;
33175: PPOPN 2
33177: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33178: LD_VAR 0 1
33182: PPUSH
33183: CALL 107222 0 1
// end ; end_of_file
33187: PPOPN 1
33189: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33190: LD_EXP 15
33194: PUSH
33195: LD_INT 2
33197: EQUAL
33198: IFFALSE 33677
33200: GO 33202
33202: DISABLE
33203: LD_INT 0
33205: PPUSH
// begin time := 0 0$40 ;
33206: LD_ADDR_VAR 0 1
33210: PUSH
33211: LD_INT 1400
33213: ST_TO_ADDR
// repeat wait ( time ) ;
33214: LD_VAR 0 1
33218: PPUSH
33219: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33223: LD_INT 1
33225: PPUSH
33226: LD_INT 5
33228: PPUSH
33229: CALL_OW 12
33233: PPUSH
33234: LD_INT 106
33236: PPUSH
33237: LD_INT 150
33239: PPUSH
33240: LD_INT 19
33242: PPUSH
33243: LD_INT 1
33245: PPUSH
33246: CALL_OW 56
// time := time + 0 0$9 ;
33250: LD_ADDR_VAR 0 1
33254: PUSH
33255: LD_VAR 0 1
33259: PUSH
33260: LD_INT 315
33262: PLUS
33263: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33264: LD_INT 455
33266: PPUSH
33267: LD_INT 840
33269: PPUSH
33270: CALL_OW 12
33274: PPUSH
33275: CALL_OW 67
// if Prob ( 50 ) then
33279: LD_INT 50
33281: PPUSH
33282: CALL_OW 13
33286: IFFALSE 33315
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33288: LD_INT 1
33290: PPUSH
33291: LD_INT 5
33293: PPUSH
33294: CALL_OW 12
33298: PPUSH
33299: LD_INT 62
33301: PPUSH
33302: LD_INT 108
33304: PPUSH
33305: LD_INT 10
33307: PPUSH
33308: LD_INT 1
33310: PPUSH
33311: CALL_OW 56
// until missionStage > 4 ;
33315: LD_EXP 15
33319: PUSH
33320: LD_INT 4
33322: GREATER
33323: IFFALSE 33214
// repeat wait ( 0 0$1 ) ;
33325: LD_INT 35
33327: PPUSH
33328: CALL_OW 67
// until missionStage = 6 ;
33332: LD_EXP 15
33336: PUSH
33337: LD_INT 6
33339: EQUAL
33340: IFFALSE 33325
// time := 0 0$50 ;
33342: LD_ADDR_VAR 0 1
33346: PUSH
33347: LD_INT 1750
33349: ST_TO_ADDR
// repeat wait ( time ) ;
33350: LD_VAR 0 1
33354: PPUSH
33355: CALL_OW 67
// if Prob ( 50 ) then
33359: LD_INT 50
33361: PPUSH
33362: CALL_OW 13
33366: IFFALSE 33395
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33368: LD_INT 1
33370: PPUSH
33371: LD_INT 5
33373: PPUSH
33374: CALL_OW 12
33378: PPUSH
33379: LD_INT 106
33381: PPUSH
33382: LD_INT 89
33384: PPUSH
33385: LD_INT 45
33387: PPUSH
33388: LD_INT 1
33390: PPUSH
33391: CALL_OW 56
// time := time + 0 0$3 ;
33395: LD_ADDR_VAR 0 1
33399: PUSH
33400: LD_VAR 0 1
33404: PUSH
33405: LD_INT 105
33407: PLUS
33408: ST_TO_ADDR
// if Prob ( 30 ) then
33409: LD_INT 30
33411: PPUSH
33412: CALL_OW 13
33416: IFFALSE 33462
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33418: LD_INT 525
33420: PPUSH
33421: LD_INT 735
33423: PPUSH
33424: CALL_OW 12
33428: PPUSH
33429: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33433: LD_INT 1
33435: PPUSH
33436: LD_INT 5
33438: PPUSH
33439: CALL_OW 12
33443: PPUSH
33444: LD_INT 21
33446: PPUSH
33447: LD_INT 26
33449: PPUSH
33450: LD_INT 12
33452: PPUSH
33453: LD_INT 1
33455: PPUSH
33456: CALL_OW 56
// end else
33460: GO 33498
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33462: LD_INT 700
33464: PPUSH
33465: LD_INT 1225
33467: PPUSH
33468: CALL_OW 12
33472: PPUSH
33473: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33477: LD_INT 1
33479: PPUSH
33480: LD_INT 5
33482: PPUSH
33483: CALL_OW 12
33487: PPUSH
33488: LD_INT 16
33490: PPUSH
33491: LD_INT 1
33493: PPUSH
33494: CALL_OW 55
// end ; if Prob ( 50 ) then
33498: LD_INT 50
33500: PPUSH
33501: CALL_OW 13
33505: IFFALSE 33551
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33507: LD_INT 700
33509: PPUSH
33510: LD_INT 1050
33512: PPUSH
33513: CALL_OW 12
33517: PPUSH
33518: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33522: LD_INT 1
33524: PPUSH
33525: LD_INT 5
33527: PPUSH
33528: CALL_OW 12
33532: PPUSH
33533: LD_INT 181
33535: PPUSH
33536: LD_INT 218
33538: PPUSH
33539: LD_INT 16
33541: PPUSH
33542: LD_INT 1
33544: PPUSH
33545: CALL_OW 56
// end else
33549: GO 33587
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33551: LD_INT 350
33553: PPUSH
33554: LD_INT 525
33556: PPUSH
33557: CALL_OW 12
33561: PPUSH
33562: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33566: LD_INT 1
33568: PPUSH
33569: LD_INT 5
33571: PPUSH
33572: CALL_OW 12
33576: PPUSH
33577: LD_INT 15
33579: PPUSH
33580: LD_INT 1
33582: PPUSH
33583: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33587: LD_INT 45
33589: PUSH
33590: LD_INT 32
33592: PUSH
33593: LD_INT 25
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: LIST
33600: PUSH
33601: LD_OWVAR 67
33605: ARRAY
33606: PPUSH
33607: CALL_OW 13
33611: IFFALSE 33655
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33613: LD_INT 525
33615: PPUSH
33616: LD_INT 875
33618: PPUSH
33619: CALL_OW 12
33623: PPUSH
33624: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33628: LD_INT 1
33630: PPUSH
33631: LD_INT 5
33633: PPUSH
33634: CALL_OW 12
33638: PPUSH
33639: LD_INT 103
33641: PPUSH
33642: LD_INT 140
33644: PPUSH
33645: LD_INT 20
33647: PPUSH
33648: LD_INT 1
33650: PPUSH
33651: CALL_OW 56
// end ; if time > 2 2$20 then
33655: LD_VAR 0 1
33659: PUSH
33660: LD_INT 4900
33662: GREATER
33663: IFFALSE 33673
// time := 0 0$50 ;
33665: LD_ADDR_VAR 0 1
33669: PUSH
33670: LD_INT 1750
33672: ST_TO_ADDR
// until false ;
33673: LD_INT 0
33675: IFFALSE 33350
// end ; end_of_file
33677: PPOPN 1
33679: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33680: LD_EXP 13
33684: PUSH
33685: LD_EXP 15
33689: PUSH
33690: LD_INT 6
33692: GREATEREQUAL
33693: AND
33694: IFFALSE 33731
33696: GO 33698
33698: DISABLE
// begin enable ;
33699: ENABLE
// missionTime := missionTime + 0 0$1 ;
33700: LD_ADDR_EXP 14
33704: PUSH
33705: LD_EXP 14
33709: PUSH
33710: LD_INT 35
33712: PLUS
33713: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33714: LD_ADDR_OWVAR 47
33718: PUSH
33719: LD_STRING #Am15-1
33721: PUSH
33722: LD_EXP 14
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: ST_TO_ADDR
// end ; end_of_file
33731: END
// export function InitNature ; begin
33732: LD_INT 0
33734: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33735: LD_INT 3
33737: PPUSH
33738: LD_INT 3
33740: PPUSH
33741: LD_INT 2
33743: PPUSH
33744: LD_INT 1
33746: PPUSH
33747: LD_INT 1
33749: PPUSH
33750: LD_INT 0
33752: PPUSH
33753: LD_INT 0
33755: PPUSH
33756: LD_INT 20
33758: PPUSH
33759: LD_INT 0
33761: PPUSH
33762: CALL 98891 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33766: LD_INT 2
33768: PPUSH
33769: LD_INT 1
33771: PPUSH
33772: LD_INT 1
33774: PPUSH
33775: LD_INT 1
33777: PPUSH
33778: LD_INT 1
33780: PPUSH
33781: LD_INT 0
33783: PPUSH
33784: LD_INT 0
33786: PPUSH
33787: LD_INT 21
33789: PPUSH
33790: LD_INT 0
33792: PPUSH
33793: CALL 98891 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33797: LD_INT 4
33799: PPUSH
33800: LD_INT 1
33802: PPUSH
33803: LD_INT 2
33805: PPUSH
33806: LD_INT 4
33808: PPUSH
33809: LD_INT 2
33811: PPUSH
33812: LD_INT 1
33814: PPUSH
33815: LD_INT 0
33817: PPUSH
33818: LD_INT 22
33820: PPUSH
33821: LD_INT 0
33823: PPUSH
33824: CALL 98891 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33828: LD_INT 0
33830: PPUSH
33831: LD_INT 0
33833: PPUSH
33834: LD_INT 0
33836: PPUSH
33837: LD_INT 0
33839: PPUSH
33840: LD_INT 0
33842: PPUSH
33843: LD_INT 0
33845: PPUSH
33846: LD_INT 9
33848: PPUSH
33849: LD_INT 0
33851: PPUSH
33852: LD_INT 23
33854: PPUSH
33855: CALL 98891 0 9
// end ; end_of_file
33859: LD_VAR 0 1
33863: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33864: GO 33866
33866: DISABLE
// begin ru_radar := 98 ;
33867: LD_ADDR_EXP 92
33871: PUSH
33872: LD_INT 98
33874: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33875: LD_ADDR_EXP 93
33879: PUSH
33880: LD_INT 89
33882: ST_TO_ADDR
// us_hack := 99 ;
33883: LD_ADDR_EXP 94
33887: PUSH
33888: LD_INT 99
33890: ST_TO_ADDR
// us_artillery := 97 ;
33891: LD_ADDR_EXP 95
33895: PUSH
33896: LD_INT 97
33898: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33899: LD_ADDR_EXP 96
33903: PUSH
33904: LD_INT 91
33906: ST_TO_ADDR
// end ; end_of_file
33907: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33908: LD_INT 0
33910: PPUSH
33911: PPUSH
// skirmish := false ;
33912: LD_ADDR_EXP 97
33916: PUSH
33917: LD_INT 0
33919: ST_TO_ADDR
// debug_mc := false ;
33920: LD_ADDR_EXP 98
33924: PUSH
33925: LD_INT 0
33927: ST_TO_ADDR
// mc_bases := [ ] ;
33928: LD_ADDR_EXP 99
33932: PUSH
33933: EMPTY
33934: ST_TO_ADDR
// mc_sides := [ ] ;
33935: LD_ADDR_EXP 125
33939: PUSH
33940: EMPTY
33941: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33942: LD_ADDR_EXP 100
33946: PUSH
33947: EMPTY
33948: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33949: LD_ADDR_EXP 101
33953: PUSH
33954: EMPTY
33955: ST_TO_ADDR
// mc_need_heal := [ ] ;
33956: LD_ADDR_EXP 102
33960: PUSH
33961: EMPTY
33962: ST_TO_ADDR
// mc_healers := [ ] ;
33963: LD_ADDR_EXP 103
33967: PUSH
33968: EMPTY
33969: ST_TO_ADDR
// mc_build_list := [ ] ;
33970: LD_ADDR_EXP 104
33974: PUSH
33975: EMPTY
33976: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33977: LD_ADDR_EXP 131
33981: PUSH
33982: EMPTY
33983: ST_TO_ADDR
// mc_builders := [ ] ;
33984: LD_ADDR_EXP 105
33988: PUSH
33989: EMPTY
33990: ST_TO_ADDR
// mc_construct_list := [ ] ;
33991: LD_ADDR_EXP 106
33995: PUSH
33996: EMPTY
33997: ST_TO_ADDR
// mc_turret_list := [ ] ;
33998: LD_ADDR_EXP 107
34002: PUSH
34003: EMPTY
34004: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34005: LD_ADDR_EXP 108
34009: PUSH
34010: EMPTY
34011: ST_TO_ADDR
// mc_miners := [ ] ;
34012: LD_ADDR_EXP 113
34016: PUSH
34017: EMPTY
34018: ST_TO_ADDR
// mc_mines := [ ] ;
34019: LD_ADDR_EXP 112
34023: PUSH
34024: EMPTY
34025: ST_TO_ADDR
// mc_minefields := [ ] ;
34026: LD_ADDR_EXP 114
34030: PUSH
34031: EMPTY
34032: ST_TO_ADDR
// mc_crates := [ ] ;
34033: LD_ADDR_EXP 115
34037: PUSH
34038: EMPTY
34039: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34040: LD_ADDR_EXP 116
34044: PUSH
34045: EMPTY
34046: ST_TO_ADDR
// mc_crates_area := [ ] ;
34047: LD_ADDR_EXP 117
34051: PUSH
34052: EMPTY
34053: ST_TO_ADDR
// mc_vehicles := [ ] ;
34054: LD_ADDR_EXP 118
34058: PUSH
34059: EMPTY
34060: ST_TO_ADDR
// mc_attack := [ ] ;
34061: LD_ADDR_EXP 119
34065: PUSH
34066: EMPTY
34067: ST_TO_ADDR
// mc_produce := [ ] ;
34068: LD_ADDR_EXP 120
34072: PUSH
34073: EMPTY
34074: ST_TO_ADDR
// mc_defender := [ ] ;
34075: LD_ADDR_EXP 121
34079: PUSH
34080: EMPTY
34081: ST_TO_ADDR
// mc_parking := [ ] ;
34082: LD_ADDR_EXP 123
34086: PUSH
34087: EMPTY
34088: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34089: LD_ADDR_EXP 109
34093: PUSH
34094: EMPTY
34095: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34096: LD_ADDR_EXP 111
34100: PUSH
34101: EMPTY
34102: ST_TO_ADDR
// mc_scan := [ ] ;
34103: LD_ADDR_EXP 122
34107: PUSH
34108: EMPTY
34109: ST_TO_ADDR
// mc_scan_area := [ ] ;
34110: LD_ADDR_EXP 124
34114: PUSH
34115: EMPTY
34116: ST_TO_ADDR
// mc_tech := [ ] ;
34117: LD_ADDR_EXP 126
34121: PUSH
34122: EMPTY
34123: ST_TO_ADDR
// mc_class := [ ] ;
34124: LD_ADDR_EXP 140
34128: PUSH
34129: EMPTY
34130: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34131: LD_ADDR_EXP 141
34135: PUSH
34136: EMPTY
34137: ST_TO_ADDR
// end ;
34138: LD_VAR 0 1
34142: RET
// export function MC_Kill ( base ) ; begin
34143: LD_INT 0
34145: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34146: LD_ADDR_EXP 99
34150: PUSH
34151: LD_EXP 99
34155: PPUSH
34156: LD_VAR 0 1
34160: PPUSH
34161: EMPTY
34162: PPUSH
34163: CALL_OW 1
34167: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34168: LD_ADDR_EXP 100
34172: PUSH
34173: LD_EXP 100
34177: PPUSH
34178: LD_VAR 0 1
34182: PPUSH
34183: EMPTY
34184: PPUSH
34185: CALL_OW 1
34189: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34190: LD_ADDR_EXP 101
34194: PUSH
34195: LD_EXP 101
34199: PPUSH
34200: LD_VAR 0 1
34204: PPUSH
34205: EMPTY
34206: PPUSH
34207: CALL_OW 1
34211: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34212: LD_ADDR_EXP 102
34216: PUSH
34217: LD_EXP 102
34221: PPUSH
34222: LD_VAR 0 1
34226: PPUSH
34227: EMPTY
34228: PPUSH
34229: CALL_OW 1
34233: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34234: LD_ADDR_EXP 103
34238: PUSH
34239: LD_EXP 103
34243: PPUSH
34244: LD_VAR 0 1
34248: PPUSH
34249: EMPTY
34250: PPUSH
34251: CALL_OW 1
34255: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34256: LD_ADDR_EXP 104
34260: PUSH
34261: LD_EXP 104
34265: PPUSH
34266: LD_VAR 0 1
34270: PPUSH
34271: EMPTY
34272: PPUSH
34273: CALL_OW 1
34277: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34278: LD_ADDR_EXP 105
34282: PUSH
34283: LD_EXP 105
34287: PPUSH
34288: LD_VAR 0 1
34292: PPUSH
34293: EMPTY
34294: PPUSH
34295: CALL_OW 1
34299: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34300: LD_ADDR_EXP 106
34304: PUSH
34305: LD_EXP 106
34309: PPUSH
34310: LD_VAR 0 1
34314: PPUSH
34315: EMPTY
34316: PPUSH
34317: CALL_OW 1
34321: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34322: LD_ADDR_EXP 107
34326: PUSH
34327: LD_EXP 107
34331: PPUSH
34332: LD_VAR 0 1
34336: PPUSH
34337: EMPTY
34338: PPUSH
34339: CALL_OW 1
34343: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34344: LD_ADDR_EXP 108
34348: PUSH
34349: LD_EXP 108
34353: PPUSH
34354: LD_VAR 0 1
34358: PPUSH
34359: EMPTY
34360: PPUSH
34361: CALL_OW 1
34365: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34366: LD_ADDR_EXP 109
34370: PUSH
34371: LD_EXP 109
34375: PPUSH
34376: LD_VAR 0 1
34380: PPUSH
34381: EMPTY
34382: PPUSH
34383: CALL_OW 1
34387: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34388: LD_ADDR_EXP 110
34392: PUSH
34393: LD_EXP 110
34397: PPUSH
34398: LD_VAR 0 1
34402: PPUSH
34403: LD_INT 0
34405: PPUSH
34406: CALL_OW 1
34410: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34411: LD_ADDR_EXP 111
34415: PUSH
34416: LD_EXP 111
34420: PPUSH
34421: LD_VAR 0 1
34425: PPUSH
34426: EMPTY
34427: PPUSH
34428: CALL_OW 1
34432: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34433: LD_ADDR_EXP 112
34437: PUSH
34438: LD_EXP 112
34442: PPUSH
34443: LD_VAR 0 1
34447: PPUSH
34448: EMPTY
34449: PPUSH
34450: CALL_OW 1
34454: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34455: LD_ADDR_EXP 113
34459: PUSH
34460: LD_EXP 113
34464: PPUSH
34465: LD_VAR 0 1
34469: PPUSH
34470: EMPTY
34471: PPUSH
34472: CALL_OW 1
34476: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34477: LD_ADDR_EXP 114
34481: PUSH
34482: LD_EXP 114
34486: PPUSH
34487: LD_VAR 0 1
34491: PPUSH
34492: EMPTY
34493: PPUSH
34494: CALL_OW 1
34498: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34499: LD_ADDR_EXP 115
34503: PUSH
34504: LD_EXP 115
34508: PPUSH
34509: LD_VAR 0 1
34513: PPUSH
34514: EMPTY
34515: PPUSH
34516: CALL_OW 1
34520: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34521: LD_ADDR_EXP 116
34525: PUSH
34526: LD_EXP 116
34530: PPUSH
34531: LD_VAR 0 1
34535: PPUSH
34536: EMPTY
34537: PPUSH
34538: CALL_OW 1
34542: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34543: LD_ADDR_EXP 117
34547: PUSH
34548: LD_EXP 117
34552: PPUSH
34553: LD_VAR 0 1
34557: PPUSH
34558: EMPTY
34559: PPUSH
34560: CALL_OW 1
34564: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34565: LD_ADDR_EXP 118
34569: PUSH
34570: LD_EXP 118
34574: PPUSH
34575: LD_VAR 0 1
34579: PPUSH
34580: EMPTY
34581: PPUSH
34582: CALL_OW 1
34586: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34587: LD_ADDR_EXP 119
34591: PUSH
34592: LD_EXP 119
34596: PPUSH
34597: LD_VAR 0 1
34601: PPUSH
34602: EMPTY
34603: PPUSH
34604: CALL_OW 1
34608: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34609: LD_ADDR_EXP 120
34613: PUSH
34614: LD_EXP 120
34618: PPUSH
34619: LD_VAR 0 1
34623: PPUSH
34624: EMPTY
34625: PPUSH
34626: CALL_OW 1
34630: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34631: LD_ADDR_EXP 121
34635: PUSH
34636: LD_EXP 121
34640: PPUSH
34641: LD_VAR 0 1
34645: PPUSH
34646: EMPTY
34647: PPUSH
34648: CALL_OW 1
34652: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34653: LD_ADDR_EXP 122
34657: PUSH
34658: LD_EXP 122
34662: PPUSH
34663: LD_VAR 0 1
34667: PPUSH
34668: EMPTY
34669: PPUSH
34670: CALL_OW 1
34674: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34675: LD_ADDR_EXP 123
34679: PUSH
34680: LD_EXP 123
34684: PPUSH
34685: LD_VAR 0 1
34689: PPUSH
34690: EMPTY
34691: PPUSH
34692: CALL_OW 1
34696: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34697: LD_ADDR_EXP 124
34701: PUSH
34702: LD_EXP 124
34706: PPUSH
34707: LD_VAR 0 1
34711: PPUSH
34712: EMPTY
34713: PPUSH
34714: CALL_OW 1
34718: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34719: LD_ADDR_EXP 126
34723: PUSH
34724: LD_EXP 126
34728: PPUSH
34729: LD_VAR 0 1
34733: PPUSH
34734: EMPTY
34735: PPUSH
34736: CALL_OW 1
34740: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34741: LD_ADDR_EXP 128
34745: PUSH
34746: LD_EXP 128
34750: PPUSH
34751: LD_VAR 0 1
34755: PPUSH
34756: EMPTY
34757: PPUSH
34758: CALL_OW 1
34762: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34763: LD_ADDR_EXP 129
34767: PUSH
34768: LD_EXP 129
34772: PPUSH
34773: LD_VAR 0 1
34777: PPUSH
34778: EMPTY
34779: PPUSH
34780: CALL_OW 1
34784: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34785: LD_ADDR_EXP 130
34789: PUSH
34790: LD_EXP 130
34794: PPUSH
34795: LD_VAR 0 1
34799: PPUSH
34800: EMPTY
34801: PPUSH
34802: CALL_OW 1
34806: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34807: LD_ADDR_EXP 131
34811: PUSH
34812: LD_EXP 131
34816: PPUSH
34817: LD_VAR 0 1
34821: PPUSH
34822: EMPTY
34823: PPUSH
34824: CALL_OW 1
34828: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34829: LD_ADDR_EXP 132
34833: PUSH
34834: LD_EXP 132
34838: PPUSH
34839: LD_VAR 0 1
34843: PPUSH
34844: EMPTY
34845: PPUSH
34846: CALL_OW 1
34850: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34851: LD_ADDR_EXP 133
34855: PUSH
34856: LD_EXP 133
34860: PPUSH
34861: LD_VAR 0 1
34865: PPUSH
34866: EMPTY
34867: PPUSH
34868: CALL_OW 1
34872: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34873: LD_ADDR_EXP 134
34877: PUSH
34878: LD_EXP 134
34882: PPUSH
34883: LD_VAR 0 1
34887: PPUSH
34888: EMPTY
34889: PPUSH
34890: CALL_OW 1
34894: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34895: LD_ADDR_EXP 135
34899: PUSH
34900: LD_EXP 135
34904: PPUSH
34905: LD_VAR 0 1
34909: PPUSH
34910: EMPTY
34911: PPUSH
34912: CALL_OW 1
34916: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34917: LD_ADDR_EXP 136
34921: PUSH
34922: LD_EXP 136
34926: PPUSH
34927: LD_VAR 0 1
34931: PPUSH
34932: EMPTY
34933: PPUSH
34934: CALL_OW 1
34938: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34939: LD_ADDR_EXP 137
34943: PUSH
34944: LD_EXP 137
34948: PPUSH
34949: LD_VAR 0 1
34953: PPUSH
34954: EMPTY
34955: PPUSH
34956: CALL_OW 1
34960: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34961: LD_ADDR_EXP 138
34965: PUSH
34966: LD_EXP 138
34970: PPUSH
34971: LD_VAR 0 1
34975: PPUSH
34976: EMPTY
34977: PPUSH
34978: CALL_OW 1
34982: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34983: LD_ADDR_EXP 139
34987: PUSH
34988: LD_EXP 139
34992: PPUSH
34993: LD_VAR 0 1
34997: PPUSH
34998: EMPTY
34999: PPUSH
35000: CALL_OW 1
35004: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35005: LD_ADDR_EXP 140
35009: PUSH
35010: LD_EXP 140
35014: PPUSH
35015: LD_VAR 0 1
35019: PPUSH
35020: EMPTY
35021: PPUSH
35022: CALL_OW 1
35026: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35027: LD_ADDR_EXP 141
35031: PUSH
35032: LD_EXP 141
35036: PPUSH
35037: LD_VAR 0 1
35041: PPUSH
35042: LD_INT 0
35044: PPUSH
35045: CALL_OW 1
35049: ST_TO_ADDR
// end ;
35050: LD_VAR 0 2
35054: RET
// export function MC_Add ( side , units ) ; var base ; begin
35055: LD_INT 0
35057: PPUSH
35058: PPUSH
// base := mc_bases + 1 ;
35059: LD_ADDR_VAR 0 4
35063: PUSH
35064: LD_EXP 99
35068: PUSH
35069: LD_INT 1
35071: PLUS
35072: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35073: LD_ADDR_EXP 125
35077: PUSH
35078: LD_EXP 125
35082: PPUSH
35083: LD_VAR 0 4
35087: PPUSH
35088: LD_VAR 0 1
35092: PPUSH
35093: CALL_OW 1
35097: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35098: LD_ADDR_EXP 99
35102: PUSH
35103: LD_EXP 99
35107: PPUSH
35108: LD_VAR 0 4
35112: PPUSH
35113: LD_VAR 0 2
35117: PPUSH
35118: CALL_OW 1
35122: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35123: LD_ADDR_EXP 100
35127: PUSH
35128: LD_EXP 100
35132: PPUSH
35133: LD_VAR 0 4
35137: PPUSH
35138: EMPTY
35139: PPUSH
35140: CALL_OW 1
35144: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35145: LD_ADDR_EXP 101
35149: PUSH
35150: LD_EXP 101
35154: PPUSH
35155: LD_VAR 0 4
35159: PPUSH
35160: EMPTY
35161: PPUSH
35162: CALL_OW 1
35166: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35167: LD_ADDR_EXP 102
35171: PUSH
35172: LD_EXP 102
35176: PPUSH
35177: LD_VAR 0 4
35181: PPUSH
35182: EMPTY
35183: PPUSH
35184: CALL_OW 1
35188: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35189: LD_ADDR_EXP 103
35193: PUSH
35194: LD_EXP 103
35198: PPUSH
35199: LD_VAR 0 4
35203: PPUSH
35204: EMPTY
35205: PPUSH
35206: CALL_OW 1
35210: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35211: LD_ADDR_EXP 104
35215: PUSH
35216: LD_EXP 104
35220: PPUSH
35221: LD_VAR 0 4
35225: PPUSH
35226: EMPTY
35227: PPUSH
35228: CALL_OW 1
35232: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35233: LD_ADDR_EXP 105
35237: PUSH
35238: LD_EXP 105
35242: PPUSH
35243: LD_VAR 0 4
35247: PPUSH
35248: EMPTY
35249: PPUSH
35250: CALL_OW 1
35254: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35255: LD_ADDR_EXP 106
35259: PUSH
35260: LD_EXP 106
35264: PPUSH
35265: LD_VAR 0 4
35269: PPUSH
35270: EMPTY
35271: PPUSH
35272: CALL_OW 1
35276: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35277: LD_ADDR_EXP 107
35281: PUSH
35282: LD_EXP 107
35286: PPUSH
35287: LD_VAR 0 4
35291: PPUSH
35292: EMPTY
35293: PPUSH
35294: CALL_OW 1
35298: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35299: LD_ADDR_EXP 108
35303: PUSH
35304: LD_EXP 108
35308: PPUSH
35309: LD_VAR 0 4
35313: PPUSH
35314: EMPTY
35315: PPUSH
35316: CALL_OW 1
35320: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35321: LD_ADDR_EXP 109
35325: PUSH
35326: LD_EXP 109
35330: PPUSH
35331: LD_VAR 0 4
35335: PPUSH
35336: EMPTY
35337: PPUSH
35338: CALL_OW 1
35342: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35343: LD_ADDR_EXP 110
35347: PUSH
35348: LD_EXP 110
35352: PPUSH
35353: LD_VAR 0 4
35357: PPUSH
35358: LD_INT 0
35360: PPUSH
35361: CALL_OW 1
35365: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35366: LD_ADDR_EXP 111
35370: PUSH
35371: LD_EXP 111
35375: PPUSH
35376: LD_VAR 0 4
35380: PPUSH
35381: EMPTY
35382: PPUSH
35383: CALL_OW 1
35387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35388: LD_ADDR_EXP 112
35392: PUSH
35393: LD_EXP 112
35397: PPUSH
35398: LD_VAR 0 4
35402: PPUSH
35403: EMPTY
35404: PPUSH
35405: CALL_OW 1
35409: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35410: LD_ADDR_EXP 113
35414: PUSH
35415: LD_EXP 113
35419: PPUSH
35420: LD_VAR 0 4
35424: PPUSH
35425: EMPTY
35426: PPUSH
35427: CALL_OW 1
35431: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35432: LD_ADDR_EXP 114
35436: PUSH
35437: LD_EXP 114
35441: PPUSH
35442: LD_VAR 0 4
35446: PPUSH
35447: EMPTY
35448: PPUSH
35449: CALL_OW 1
35453: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35454: LD_ADDR_EXP 115
35458: PUSH
35459: LD_EXP 115
35463: PPUSH
35464: LD_VAR 0 4
35468: PPUSH
35469: EMPTY
35470: PPUSH
35471: CALL_OW 1
35475: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35476: LD_ADDR_EXP 116
35480: PUSH
35481: LD_EXP 116
35485: PPUSH
35486: LD_VAR 0 4
35490: PPUSH
35491: EMPTY
35492: PPUSH
35493: CALL_OW 1
35497: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35498: LD_ADDR_EXP 117
35502: PUSH
35503: LD_EXP 117
35507: PPUSH
35508: LD_VAR 0 4
35512: PPUSH
35513: EMPTY
35514: PPUSH
35515: CALL_OW 1
35519: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35520: LD_ADDR_EXP 118
35524: PUSH
35525: LD_EXP 118
35529: PPUSH
35530: LD_VAR 0 4
35534: PPUSH
35535: EMPTY
35536: PPUSH
35537: CALL_OW 1
35541: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35542: LD_ADDR_EXP 119
35546: PUSH
35547: LD_EXP 119
35551: PPUSH
35552: LD_VAR 0 4
35556: PPUSH
35557: EMPTY
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35564: LD_ADDR_EXP 120
35568: PUSH
35569: LD_EXP 120
35573: PPUSH
35574: LD_VAR 0 4
35578: PPUSH
35579: EMPTY
35580: PPUSH
35581: CALL_OW 1
35585: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35586: LD_ADDR_EXP 121
35590: PUSH
35591: LD_EXP 121
35595: PPUSH
35596: LD_VAR 0 4
35600: PPUSH
35601: EMPTY
35602: PPUSH
35603: CALL_OW 1
35607: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35608: LD_ADDR_EXP 122
35612: PUSH
35613: LD_EXP 122
35617: PPUSH
35618: LD_VAR 0 4
35622: PPUSH
35623: EMPTY
35624: PPUSH
35625: CALL_OW 1
35629: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35630: LD_ADDR_EXP 123
35634: PUSH
35635: LD_EXP 123
35639: PPUSH
35640: LD_VAR 0 4
35644: PPUSH
35645: EMPTY
35646: PPUSH
35647: CALL_OW 1
35651: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35652: LD_ADDR_EXP 124
35656: PUSH
35657: LD_EXP 124
35661: PPUSH
35662: LD_VAR 0 4
35666: PPUSH
35667: EMPTY
35668: PPUSH
35669: CALL_OW 1
35673: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35674: LD_ADDR_EXP 126
35678: PUSH
35679: LD_EXP 126
35683: PPUSH
35684: LD_VAR 0 4
35688: PPUSH
35689: EMPTY
35690: PPUSH
35691: CALL_OW 1
35695: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35696: LD_ADDR_EXP 128
35700: PUSH
35701: LD_EXP 128
35705: PPUSH
35706: LD_VAR 0 4
35710: PPUSH
35711: EMPTY
35712: PPUSH
35713: CALL_OW 1
35717: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35718: LD_ADDR_EXP 129
35722: PUSH
35723: LD_EXP 129
35727: PPUSH
35728: LD_VAR 0 4
35732: PPUSH
35733: EMPTY
35734: PPUSH
35735: CALL_OW 1
35739: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35740: LD_ADDR_EXP 130
35744: PUSH
35745: LD_EXP 130
35749: PPUSH
35750: LD_VAR 0 4
35754: PPUSH
35755: EMPTY
35756: PPUSH
35757: CALL_OW 1
35761: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35762: LD_ADDR_EXP 131
35766: PUSH
35767: LD_EXP 131
35771: PPUSH
35772: LD_VAR 0 4
35776: PPUSH
35777: EMPTY
35778: PPUSH
35779: CALL_OW 1
35783: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35784: LD_ADDR_EXP 132
35788: PUSH
35789: LD_EXP 132
35793: PPUSH
35794: LD_VAR 0 4
35798: PPUSH
35799: EMPTY
35800: PPUSH
35801: CALL_OW 1
35805: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35806: LD_ADDR_EXP 133
35810: PUSH
35811: LD_EXP 133
35815: PPUSH
35816: LD_VAR 0 4
35820: PPUSH
35821: EMPTY
35822: PPUSH
35823: CALL_OW 1
35827: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35828: LD_ADDR_EXP 134
35832: PUSH
35833: LD_EXP 134
35837: PPUSH
35838: LD_VAR 0 4
35842: PPUSH
35843: EMPTY
35844: PPUSH
35845: CALL_OW 1
35849: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35850: LD_ADDR_EXP 135
35854: PUSH
35855: LD_EXP 135
35859: PPUSH
35860: LD_VAR 0 4
35864: PPUSH
35865: EMPTY
35866: PPUSH
35867: CALL_OW 1
35871: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35872: LD_ADDR_EXP 136
35876: PUSH
35877: LD_EXP 136
35881: PPUSH
35882: LD_VAR 0 4
35886: PPUSH
35887: EMPTY
35888: PPUSH
35889: CALL_OW 1
35893: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35894: LD_ADDR_EXP 137
35898: PUSH
35899: LD_EXP 137
35903: PPUSH
35904: LD_VAR 0 4
35908: PPUSH
35909: EMPTY
35910: PPUSH
35911: CALL_OW 1
35915: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35916: LD_ADDR_EXP 138
35920: PUSH
35921: LD_EXP 138
35925: PPUSH
35926: LD_VAR 0 4
35930: PPUSH
35931: EMPTY
35932: PPUSH
35933: CALL_OW 1
35937: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35938: LD_ADDR_EXP 139
35942: PUSH
35943: LD_EXP 139
35947: PPUSH
35948: LD_VAR 0 4
35952: PPUSH
35953: EMPTY
35954: PPUSH
35955: CALL_OW 1
35959: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35960: LD_ADDR_EXP 140
35964: PUSH
35965: LD_EXP 140
35969: PPUSH
35970: LD_VAR 0 4
35974: PPUSH
35975: EMPTY
35976: PPUSH
35977: CALL_OW 1
35981: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35982: LD_ADDR_EXP 141
35986: PUSH
35987: LD_EXP 141
35991: PPUSH
35992: LD_VAR 0 4
35996: PPUSH
35997: LD_INT 0
35999: PPUSH
36000: CALL_OW 1
36004: ST_TO_ADDR
// result := base ;
36005: LD_ADDR_VAR 0 3
36009: PUSH
36010: LD_VAR 0 4
36014: ST_TO_ADDR
// end ;
36015: LD_VAR 0 3
36019: RET
// export function MC_Start ( ) ; var i ; begin
36020: LD_INT 0
36022: PPUSH
36023: PPUSH
// for i = 1 to mc_bases do
36024: LD_ADDR_VAR 0 2
36028: PUSH
36029: DOUBLE
36030: LD_INT 1
36032: DEC
36033: ST_TO_ADDR
36034: LD_EXP 99
36038: PUSH
36039: FOR_TO
36040: IFFALSE 37117
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36042: LD_ADDR_EXP 99
36046: PUSH
36047: LD_EXP 99
36051: PPUSH
36052: LD_VAR 0 2
36056: PPUSH
36057: LD_EXP 99
36061: PUSH
36062: LD_VAR 0 2
36066: ARRAY
36067: PUSH
36068: LD_INT 0
36070: DIFF
36071: PPUSH
36072: CALL_OW 1
36076: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36077: LD_ADDR_EXP 100
36081: PUSH
36082: LD_EXP 100
36086: PPUSH
36087: LD_VAR 0 2
36091: PPUSH
36092: EMPTY
36093: PPUSH
36094: CALL_OW 1
36098: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36099: LD_ADDR_EXP 101
36103: PUSH
36104: LD_EXP 101
36108: PPUSH
36109: LD_VAR 0 2
36113: PPUSH
36114: EMPTY
36115: PPUSH
36116: CALL_OW 1
36120: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36121: LD_ADDR_EXP 102
36125: PUSH
36126: LD_EXP 102
36130: PPUSH
36131: LD_VAR 0 2
36135: PPUSH
36136: EMPTY
36137: PPUSH
36138: CALL_OW 1
36142: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36143: LD_ADDR_EXP 103
36147: PUSH
36148: LD_EXP 103
36152: PPUSH
36153: LD_VAR 0 2
36157: PPUSH
36158: EMPTY
36159: PUSH
36160: EMPTY
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PPUSH
36166: CALL_OW 1
36170: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36171: LD_ADDR_EXP 104
36175: PUSH
36176: LD_EXP 104
36180: PPUSH
36181: LD_VAR 0 2
36185: PPUSH
36186: EMPTY
36187: PPUSH
36188: CALL_OW 1
36192: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36193: LD_ADDR_EXP 131
36197: PUSH
36198: LD_EXP 131
36202: PPUSH
36203: LD_VAR 0 2
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL_OW 1
36214: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36215: LD_ADDR_EXP 105
36219: PUSH
36220: LD_EXP 105
36224: PPUSH
36225: LD_VAR 0 2
36229: PPUSH
36230: EMPTY
36231: PPUSH
36232: CALL_OW 1
36236: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36237: LD_ADDR_EXP 106
36241: PUSH
36242: LD_EXP 106
36246: PPUSH
36247: LD_VAR 0 2
36251: PPUSH
36252: EMPTY
36253: PPUSH
36254: CALL_OW 1
36258: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36259: LD_ADDR_EXP 107
36263: PUSH
36264: LD_EXP 107
36268: PPUSH
36269: LD_VAR 0 2
36273: PPUSH
36274: LD_EXP 99
36278: PUSH
36279: LD_VAR 0 2
36283: ARRAY
36284: PPUSH
36285: LD_INT 2
36287: PUSH
36288: LD_INT 30
36290: PUSH
36291: LD_INT 32
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 30
36300: PUSH
36301: LD_INT 33
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: PPUSH
36313: CALL_OW 72
36317: PPUSH
36318: CALL_OW 1
36322: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36323: LD_ADDR_EXP 108
36327: PUSH
36328: LD_EXP 108
36332: PPUSH
36333: LD_VAR 0 2
36337: PPUSH
36338: LD_EXP 99
36342: PUSH
36343: LD_VAR 0 2
36347: ARRAY
36348: PPUSH
36349: LD_INT 2
36351: PUSH
36352: LD_INT 30
36354: PUSH
36355: LD_INT 32
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: LD_INT 30
36364: PUSH
36365: LD_INT 31
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 58
36379: PUSH
36380: EMPTY
36381: LIST
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PPUSH
36387: CALL_OW 72
36391: PPUSH
36392: CALL_OW 1
36396: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36397: LD_ADDR_EXP 109
36401: PUSH
36402: LD_EXP 109
36406: PPUSH
36407: LD_VAR 0 2
36411: PPUSH
36412: EMPTY
36413: PPUSH
36414: CALL_OW 1
36418: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36419: LD_ADDR_EXP 113
36423: PUSH
36424: LD_EXP 113
36428: PPUSH
36429: LD_VAR 0 2
36433: PPUSH
36434: EMPTY
36435: PPUSH
36436: CALL_OW 1
36440: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36441: LD_ADDR_EXP 112
36445: PUSH
36446: LD_EXP 112
36450: PPUSH
36451: LD_VAR 0 2
36455: PPUSH
36456: EMPTY
36457: PPUSH
36458: CALL_OW 1
36462: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36463: LD_ADDR_EXP 114
36467: PUSH
36468: LD_EXP 114
36472: PPUSH
36473: LD_VAR 0 2
36477: PPUSH
36478: EMPTY
36479: PPUSH
36480: CALL_OW 1
36484: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36485: LD_ADDR_EXP 115
36489: PUSH
36490: LD_EXP 115
36494: PPUSH
36495: LD_VAR 0 2
36499: PPUSH
36500: EMPTY
36501: PPUSH
36502: CALL_OW 1
36506: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36507: LD_ADDR_EXP 116
36511: PUSH
36512: LD_EXP 116
36516: PPUSH
36517: LD_VAR 0 2
36521: PPUSH
36522: EMPTY
36523: PPUSH
36524: CALL_OW 1
36528: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36529: LD_ADDR_EXP 117
36533: PUSH
36534: LD_EXP 117
36538: PPUSH
36539: LD_VAR 0 2
36543: PPUSH
36544: EMPTY
36545: PPUSH
36546: CALL_OW 1
36550: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36551: LD_ADDR_EXP 118
36555: PUSH
36556: LD_EXP 118
36560: PPUSH
36561: LD_VAR 0 2
36565: PPUSH
36566: EMPTY
36567: PPUSH
36568: CALL_OW 1
36572: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36573: LD_ADDR_EXP 119
36577: PUSH
36578: LD_EXP 119
36582: PPUSH
36583: LD_VAR 0 2
36587: PPUSH
36588: EMPTY
36589: PPUSH
36590: CALL_OW 1
36594: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36595: LD_ADDR_EXP 120
36599: PUSH
36600: LD_EXP 120
36604: PPUSH
36605: LD_VAR 0 2
36609: PPUSH
36610: EMPTY
36611: PPUSH
36612: CALL_OW 1
36616: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36617: LD_ADDR_EXP 121
36621: PUSH
36622: LD_EXP 121
36626: PPUSH
36627: LD_VAR 0 2
36631: PPUSH
36632: EMPTY
36633: PPUSH
36634: CALL_OW 1
36638: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36639: LD_ADDR_EXP 110
36643: PUSH
36644: LD_EXP 110
36648: PPUSH
36649: LD_VAR 0 2
36653: PPUSH
36654: LD_INT 0
36656: PPUSH
36657: CALL_OW 1
36661: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36662: LD_ADDR_EXP 123
36666: PUSH
36667: LD_EXP 123
36671: PPUSH
36672: LD_VAR 0 2
36676: PPUSH
36677: LD_INT 0
36679: PPUSH
36680: CALL_OW 1
36684: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36685: LD_ADDR_EXP 111
36689: PUSH
36690: LD_EXP 111
36694: PPUSH
36695: LD_VAR 0 2
36699: PPUSH
36700: EMPTY
36701: PPUSH
36702: CALL_OW 1
36706: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36707: LD_ADDR_EXP 122
36711: PUSH
36712: LD_EXP 122
36716: PPUSH
36717: LD_VAR 0 2
36721: PPUSH
36722: LD_INT 0
36724: PPUSH
36725: CALL_OW 1
36729: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36730: LD_ADDR_EXP 124
36734: PUSH
36735: LD_EXP 124
36739: PPUSH
36740: LD_VAR 0 2
36744: PPUSH
36745: EMPTY
36746: PPUSH
36747: CALL_OW 1
36751: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36752: LD_ADDR_EXP 127
36756: PUSH
36757: LD_EXP 127
36761: PPUSH
36762: LD_VAR 0 2
36766: PPUSH
36767: LD_INT 0
36769: PPUSH
36770: CALL_OW 1
36774: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36775: LD_ADDR_EXP 128
36779: PUSH
36780: LD_EXP 128
36784: PPUSH
36785: LD_VAR 0 2
36789: PPUSH
36790: EMPTY
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36797: LD_ADDR_EXP 129
36801: PUSH
36802: LD_EXP 129
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36819: LD_ADDR_EXP 130
36823: PUSH
36824: LD_EXP 130
36828: PPUSH
36829: LD_VAR 0 2
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36841: LD_ADDR_EXP 132
36845: PUSH
36846: LD_EXP 132
36850: PPUSH
36851: LD_VAR 0 2
36855: PPUSH
36856: LD_EXP 99
36860: PUSH
36861: LD_VAR 0 2
36865: ARRAY
36866: PPUSH
36867: LD_INT 2
36869: PUSH
36870: LD_INT 30
36872: PUSH
36873: LD_INT 6
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 30
36882: PUSH
36883: LD_INT 7
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 30
36892: PUSH
36893: LD_INT 8
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: LIST
36904: LIST
36905: PPUSH
36906: CALL_OW 72
36910: PPUSH
36911: CALL_OW 1
36915: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36916: LD_ADDR_EXP 133
36920: PUSH
36921: LD_EXP 133
36925: PPUSH
36926: LD_VAR 0 2
36930: PPUSH
36931: EMPTY
36932: PPUSH
36933: CALL_OW 1
36937: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36938: LD_ADDR_EXP 134
36942: PUSH
36943: LD_EXP 134
36947: PPUSH
36948: LD_VAR 0 2
36952: PPUSH
36953: EMPTY
36954: PPUSH
36955: CALL_OW 1
36959: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36960: LD_ADDR_EXP 135
36964: PUSH
36965: LD_EXP 135
36969: PPUSH
36970: LD_VAR 0 2
36974: PPUSH
36975: EMPTY
36976: PPUSH
36977: CALL_OW 1
36981: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36982: LD_ADDR_EXP 136
36986: PUSH
36987: LD_EXP 136
36991: PPUSH
36992: LD_VAR 0 2
36996: PPUSH
36997: EMPTY
36998: PPUSH
36999: CALL_OW 1
37003: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37004: LD_ADDR_EXP 137
37008: PUSH
37009: LD_EXP 137
37013: PPUSH
37014: LD_VAR 0 2
37018: PPUSH
37019: EMPTY
37020: PPUSH
37021: CALL_OW 1
37025: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37026: LD_ADDR_EXP 138
37030: PUSH
37031: LD_EXP 138
37035: PPUSH
37036: LD_VAR 0 2
37040: PPUSH
37041: EMPTY
37042: PPUSH
37043: CALL_OW 1
37047: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37048: LD_ADDR_EXP 139
37052: PUSH
37053: LD_EXP 139
37057: PPUSH
37058: LD_VAR 0 2
37062: PPUSH
37063: EMPTY
37064: PPUSH
37065: CALL_OW 1
37069: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37070: LD_ADDR_EXP 140
37074: PUSH
37075: LD_EXP 140
37079: PPUSH
37080: LD_VAR 0 2
37084: PPUSH
37085: EMPTY
37086: PPUSH
37087: CALL_OW 1
37091: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37092: LD_ADDR_EXP 141
37096: PUSH
37097: LD_EXP 141
37101: PPUSH
37102: LD_VAR 0 2
37106: PPUSH
37107: LD_INT 0
37109: PPUSH
37110: CALL_OW 1
37114: ST_TO_ADDR
// end ;
37115: GO 36039
37117: POP
37118: POP
// MC_InitSides ( ) ;
37119: CALL 37405 0 0
// MC_InitResearch ( ) ;
37123: CALL 37144 0 0
// CustomInitMacro ( ) ;
37127: CALL 444 0 0
// skirmish := true ;
37131: LD_ADDR_EXP 97
37135: PUSH
37136: LD_INT 1
37138: ST_TO_ADDR
// end ;
37139: LD_VAR 0 1
37143: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37144: LD_INT 0
37146: PPUSH
37147: PPUSH
37148: PPUSH
37149: PPUSH
37150: PPUSH
37151: PPUSH
// if not mc_bases then
37152: LD_EXP 99
37156: NOT
37157: IFFALSE 37161
// exit ;
37159: GO 37400
// for i = 1 to 8 do
37161: LD_ADDR_VAR 0 2
37165: PUSH
37166: DOUBLE
37167: LD_INT 1
37169: DEC
37170: ST_TO_ADDR
37171: LD_INT 8
37173: PUSH
37174: FOR_TO
37175: IFFALSE 37201
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37177: LD_ADDR_EXP 126
37181: PUSH
37182: LD_EXP 126
37186: PPUSH
37187: LD_VAR 0 2
37191: PPUSH
37192: EMPTY
37193: PPUSH
37194: CALL_OW 1
37198: ST_TO_ADDR
37199: GO 37174
37201: POP
37202: POP
// tmp := [ ] ;
37203: LD_ADDR_VAR 0 5
37207: PUSH
37208: EMPTY
37209: ST_TO_ADDR
// for i = 1 to mc_sides do
37210: LD_ADDR_VAR 0 2
37214: PUSH
37215: DOUBLE
37216: LD_INT 1
37218: DEC
37219: ST_TO_ADDR
37220: LD_EXP 125
37224: PUSH
37225: FOR_TO
37226: IFFALSE 37284
// if not mc_sides [ i ] in tmp then
37228: LD_EXP 125
37232: PUSH
37233: LD_VAR 0 2
37237: ARRAY
37238: PUSH
37239: LD_VAR 0 5
37243: IN
37244: NOT
37245: IFFALSE 37282
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37247: LD_ADDR_VAR 0 5
37251: PUSH
37252: LD_VAR 0 5
37256: PPUSH
37257: LD_VAR 0 5
37261: PUSH
37262: LD_INT 1
37264: PLUS
37265: PPUSH
37266: LD_EXP 125
37270: PUSH
37271: LD_VAR 0 2
37275: ARRAY
37276: PPUSH
37277: CALL_OW 2
37281: ST_TO_ADDR
37282: GO 37225
37284: POP
37285: POP
// if not tmp then
37286: LD_VAR 0 5
37290: NOT
37291: IFFALSE 37295
// exit ;
37293: GO 37400
// for j in tmp do
37295: LD_ADDR_VAR 0 3
37299: PUSH
37300: LD_VAR 0 5
37304: PUSH
37305: FOR_IN
37306: IFFALSE 37398
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37308: LD_ADDR_VAR 0 6
37312: PUSH
37313: LD_INT 22
37315: PUSH
37316: LD_VAR 0 3
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PPUSH
37325: CALL_OW 69
37329: ST_TO_ADDR
// if not un then
37330: LD_VAR 0 6
37334: NOT
37335: IFFALSE 37339
// continue ;
37337: GO 37305
// nation := GetNation ( un [ 1 ] ) ;
37339: LD_ADDR_VAR 0 4
37343: PUSH
37344: LD_VAR 0 6
37348: PUSH
37349: LD_INT 1
37351: ARRAY
37352: PPUSH
37353: CALL_OW 248
37357: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37358: LD_ADDR_EXP 126
37362: PUSH
37363: LD_EXP 126
37367: PPUSH
37368: LD_VAR 0 3
37372: PPUSH
37373: LD_VAR 0 3
37377: PPUSH
37378: LD_VAR 0 4
37382: PPUSH
37383: LD_INT 1
37385: PPUSH
37386: CALL 64114 0 3
37390: PPUSH
37391: CALL_OW 1
37395: ST_TO_ADDR
// end ;
37396: GO 37305
37398: POP
37399: POP
// end ;
37400: LD_VAR 0 1
37404: RET
// export function MC_InitSides ( ) ; var i ; begin
37405: LD_INT 0
37407: PPUSH
37408: PPUSH
// if not mc_bases then
37409: LD_EXP 99
37413: NOT
37414: IFFALSE 37418
// exit ;
37416: GO 37492
// for i = 1 to mc_bases do
37418: LD_ADDR_VAR 0 2
37422: PUSH
37423: DOUBLE
37424: LD_INT 1
37426: DEC
37427: ST_TO_ADDR
37428: LD_EXP 99
37432: PUSH
37433: FOR_TO
37434: IFFALSE 37490
// if mc_bases [ i ] then
37436: LD_EXP 99
37440: PUSH
37441: LD_VAR 0 2
37445: ARRAY
37446: IFFALSE 37488
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37448: LD_ADDR_EXP 125
37452: PUSH
37453: LD_EXP 125
37457: PPUSH
37458: LD_VAR 0 2
37462: PPUSH
37463: LD_EXP 99
37467: PUSH
37468: LD_VAR 0 2
37472: ARRAY
37473: PUSH
37474: LD_INT 1
37476: ARRAY
37477: PPUSH
37478: CALL_OW 255
37482: PPUSH
37483: CALL_OW 1
37487: ST_TO_ADDR
37488: GO 37433
37490: POP
37491: POP
// end ;
37492: LD_VAR 0 1
37496: RET
// every 0 0$01 trigger skirmish do
37497: LD_EXP 97
37501: IFFALSE 37655
37503: GO 37505
37505: DISABLE
// begin enable ;
37506: ENABLE
// MC_CheckBuildings ( ) ;
37507: CALL 42153 0 0
// MC_CheckPeopleLife ( ) ;
37511: CALL 42278 0 0
// RaiseSailEvent ( 100 ) ;
37515: LD_INT 100
37517: PPUSH
37518: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37522: LD_INT 103
37524: PPUSH
37525: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37529: LD_INT 104
37531: PPUSH
37532: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37536: LD_INT 105
37538: PPUSH
37539: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37543: LD_INT 106
37545: PPUSH
37546: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37550: LD_INT 107
37552: PPUSH
37553: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37557: LD_INT 108
37559: PPUSH
37560: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37564: LD_INT 109
37566: PPUSH
37567: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37571: LD_INT 110
37573: PPUSH
37574: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37578: LD_INT 111
37580: PPUSH
37581: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37585: LD_INT 112
37587: PPUSH
37588: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37592: LD_INT 113
37594: PPUSH
37595: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37599: LD_INT 120
37601: PPUSH
37602: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37606: LD_INT 121
37608: PPUSH
37609: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37613: LD_INT 122
37615: PPUSH
37616: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37620: LD_INT 123
37622: PPUSH
37623: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37627: LD_INT 124
37629: PPUSH
37630: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37634: LD_INT 125
37636: PPUSH
37637: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37641: LD_INT 126
37643: PPUSH
37644: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37648: LD_INT 200
37650: PPUSH
37651: CALL_OW 427
// end ;
37655: END
// on SailEvent ( event ) do begin if event < 100 then
37656: LD_VAR 0 1
37660: PUSH
37661: LD_INT 100
37663: LESS
37664: IFFALSE 37675
// CustomEvent ( event ) ;
37666: LD_VAR 0 1
37670: PPUSH
37671: CALL 32338 0 1
// if event = 100 then
37675: LD_VAR 0 1
37679: PUSH
37680: LD_INT 100
37682: EQUAL
37683: IFFALSE 37689
// MC_ClassManager ( ) ;
37685: CALL 38081 0 0
// if event = 101 then
37689: LD_VAR 0 1
37693: PUSH
37694: LD_INT 101
37696: EQUAL
37697: IFFALSE 37703
// MC_RepairBuildings ( ) ;
37699: CALL 42874 0 0
// if event = 102 then
37703: LD_VAR 0 1
37707: PUSH
37708: LD_INT 102
37710: EQUAL
37711: IFFALSE 37717
// MC_Heal ( ) ;
37713: CALL 43606 0 0
// if event = 103 then
37717: LD_VAR 0 1
37721: PUSH
37722: LD_INT 103
37724: EQUAL
37725: IFFALSE 37731
// MC_Build ( ) ;
37727: CALL 44028 0 0
// if event = 104 then
37731: LD_VAR 0 1
37735: PUSH
37736: LD_INT 104
37738: EQUAL
37739: IFFALSE 37745
// MC_TurretWeapon ( ) ;
37741: CALL 45641 0 0
// if event = 105 then
37745: LD_VAR 0 1
37749: PUSH
37750: LD_INT 105
37752: EQUAL
37753: IFFALSE 37759
// MC_BuildUpgrade ( ) ;
37755: CALL 45192 0 0
// if event = 106 then
37759: LD_VAR 0 1
37763: PUSH
37764: LD_INT 106
37766: EQUAL
37767: IFFALSE 37773
// MC_PlantMines ( ) ;
37769: CALL 46071 0 0
// if event = 107 then
37773: LD_VAR 0 1
37777: PUSH
37778: LD_INT 107
37780: EQUAL
37781: IFFALSE 37787
// MC_CollectCrates ( ) ;
37783: CALL 47105 0 0
// if event = 108 then
37787: LD_VAR 0 1
37791: PUSH
37792: LD_INT 108
37794: EQUAL
37795: IFFALSE 37801
// MC_LinkRemoteControl ( ) ;
37797: CALL 48881 0 0
// if event = 109 then
37801: LD_VAR 0 1
37805: PUSH
37806: LD_INT 109
37808: EQUAL
37809: IFFALSE 37815
// MC_ProduceVehicle ( ) ;
37811: CALL 49062 0 0
// if event = 110 then
37815: LD_VAR 0 1
37819: PUSH
37820: LD_INT 110
37822: EQUAL
37823: IFFALSE 37829
// MC_SendAttack ( ) ;
37825: CALL 49528 0 0
// if event = 111 then
37829: LD_VAR 0 1
37833: PUSH
37834: LD_INT 111
37836: EQUAL
37837: IFFALSE 37843
// MC_Defend ( ) ;
37839: CALL 49636 0 0
// if event = 112 then
37843: LD_VAR 0 1
37847: PUSH
37848: LD_INT 112
37850: EQUAL
37851: IFFALSE 37857
// MC_Research ( ) ;
37853: CALL 50241 0 0
// if event = 113 then
37857: LD_VAR 0 1
37861: PUSH
37862: LD_INT 113
37864: EQUAL
37865: IFFALSE 37871
// MC_MinesTrigger ( ) ;
37867: CALL 51355 0 0
// if event = 120 then
37871: LD_VAR 0 1
37875: PUSH
37876: LD_INT 120
37878: EQUAL
37879: IFFALSE 37885
// MC_RepairVehicle ( ) ;
37881: CALL 51454 0 0
// if event = 121 then
37885: LD_VAR 0 1
37889: PUSH
37890: LD_INT 121
37892: EQUAL
37893: IFFALSE 37899
// MC_TameApe ( ) ;
37895: CALL 52184 0 0
// if event = 122 then
37899: LD_VAR 0 1
37903: PUSH
37904: LD_INT 122
37906: EQUAL
37907: IFFALSE 37913
// MC_ChangeApeClass ( ) ;
37909: CALL 53013 0 0
// if event = 123 then
37913: LD_VAR 0 1
37917: PUSH
37918: LD_INT 123
37920: EQUAL
37921: IFFALSE 37927
// MC_Bazooka ( ) ;
37923: CALL 53663 0 0
// if event = 124 then
37927: LD_VAR 0 1
37931: PUSH
37932: LD_INT 124
37934: EQUAL
37935: IFFALSE 37941
// MC_TeleportExit ( ) ;
37937: CALL 53861 0 0
// if event = 125 then
37941: LD_VAR 0 1
37945: PUSH
37946: LD_INT 125
37948: EQUAL
37949: IFFALSE 37955
// MC_Deposits ( ) ;
37951: CALL 54508 0 0
// if event = 126 then
37955: LD_VAR 0 1
37959: PUSH
37960: LD_INT 126
37962: EQUAL
37963: IFFALSE 37969
// MC_RemoteDriver ( ) ;
37965: CALL 55133 0 0
// if event = 200 then
37969: LD_VAR 0 1
37973: PUSH
37974: LD_INT 200
37976: EQUAL
37977: IFFALSE 37983
// MC_Idle ( ) ;
37979: CALL 57082 0 0
// end ;
37983: PPOPN 1
37985: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37986: LD_INT 0
37988: PPUSH
37989: PPUSH
// if not mc_bases [ base ] or not tag then
37990: LD_EXP 99
37994: PUSH
37995: LD_VAR 0 1
37999: ARRAY
38000: NOT
38001: PUSH
38002: LD_VAR 0 2
38006: NOT
38007: OR
38008: IFFALSE 38012
// exit ;
38010: GO 38076
// for i in mc_bases [ base ] union mc_ape [ base ] do
38012: LD_ADDR_VAR 0 4
38016: PUSH
38017: LD_EXP 99
38021: PUSH
38022: LD_VAR 0 1
38026: ARRAY
38027: PUSH
38028: LD_EXP 128
38032: PUSH
38033: LD_VAR 0 1
38037: ARRAY
38038: UNION
38039: PUSH
38040: FOR_IN
38041: IFFALSE 38074
// if GetTag ( i ) = tag then
38043: LD_VAR 0 4
38047: PPUSH
38048: CALL_OW 110
38052: PUSH
38053: LD_VAR 0 2
38057: EQUAL
38058: IFFALSE 38072
// SetTag ( i , 0 ) ;
38060: LD_VAR 0 4
38064: PPUSH
38065: LD_INT 0
38067: PPUSH
38068: CALL_OW 109
38072: GO 38040
38074: POP
38075: POP
// end ;
38076: LD_VAR 0 3
38080: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38081: LD_INT 0
38083: PPUSH
38084: PPUSH
38085: PPUSH
38086: PPUSH
38087: PPUSH
38088: PPUSH
38089: PPUSH
38090: PPUSH
// if not mc_bases then
38091: LD_EXP 99
38095: NOT
38096: IFFALSE 38100
// exit ;
38098: GO 38558
// for i = 1 to mc_bases do
38100: LD_ADDR_VAR 0 2
38104: PUSH
38105: DOUBLE
38106: LD_INT 1
38108: DEC
38109: ST_TO_ADDR
38110: LD_EXP 99
38114: PUSH
38115: FOR_TO
38116: IFFALSE 38556
// begin tmp := MC_ClassCheckReq ( i ) ;
38118: LD_ADDR_VAR 0 4
38122: PUSH
38123: LD_VAR 0 2
38127: PPUSH
38128: CALL 38563 0 1
38132: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38133: LD_ADDR_EXP 140
38137: PUSH
38138: LD_EXP 140
38142: PPUSH
38143: LD_VAR 0 2
38147: PPUSH
38148: LD_VAR 0 4
38152: PPUSH
38153: CALL_OW 1
38157: ST_TO_ADDR
// if not tmp then
38158: LD_VAR 0 4
38162: NOT
38163: IFFALSE 38167
// continue ;
38165: GO 38115
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38167: LD_ADDR_VAR 0 6
38171: PUSH
38172: LD_EXP 99
38176: PUSH
38177: LD_VAR 0 2
38181: ARRAY
38182: PPUSH
38183: LD_INT 2
38185: PUSH
38186: LD_INT 30
38188: PUSH
38189: LD_INT 4
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: PUSH
38196: LD_INT 30
38198: PUSH
38199: LD_INT 5
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: LIST
38210: PPUSH
38211: CALL_OW 72
38215: PUSH
38216: LD_EXP 99
38220: PUSH
38221: LD_VAR 0 2
38225: ARRAY
38226: PPUSH
38227: LD_INT 2
38229: PUSH
38230: LD_INT 30
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 30
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: LIST
38254: PPUSH
38255: CALL_OW 72
38259: PUSH
38260: LD_EXP 99
38264: PUSH
38265: LD_VAR 0 2
38269: ARRAY
38270: PPUSH
38271: LD_INT 30
38273: PUSH
38274: LD_INT 3
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PPUSH
38281: CALL_OW 72
38285: PUSH
38286: LD_EXP 99
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: PPUSH
38297: LD_INT 2
38299: PUSH
38300: LD_INT 30
38302: PUSH
38303: LD_INT 6
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 30
38312: PUSH
38313: LD_INT 7
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 30
38322: PUSH
38323: LD_INT 8
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: PPUSH
38336: CALL_OW 72
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: LIST
38345: LIST
38346: ST_TO_ADDR
// for j = 1 to 4 do
38347: LD_ADDR_VAR 0 3
38351: PUSH
38352: DOUBLE
38353: LD_INT 1
38355: DEC
38356: ST_TO_ADDR
38357: LD_INT 4
38359: PUSH
38360: FOR_TO
38361: IFFALSE 38552
// begin if not tmp [ j ] then
38363: LD_VAR 0 4
38367: PUSH
38368: LD_VAR 0 3
38372: ARRAY
38373: NOT
38374: IFFALSE 38378
// continue ;
38376: GO 38360
// for p in tmp [ j ] do
38378: LD_ADDR_VAR 0 5
38382: PUSH
38383: LD_VAR 0 4
38387: PUSH
38388: LD_VAR 0 3
38392: ARRAY
38393: PUSH
38394: FOR_IN
38395: IFFALSE 38548
// begin if not b [ j ] then
38397: LD_VAR 0 6
38401: PUSH
38402: LD_VAR 0 3
38406: ARRAY
38407: NOT
38408: IFFALSE 38412
// break ;
38410: GO 38548
// e := 0 ;
38412: LD_ADDR_VAR 0 7
38416: PUSH
38417: LD_INT 0
38419: ST_TO_ADDR
// for k in b [ j ] do
38420: LD_ADDR_VAR 0 8
38424: PUSH
38425: LD_VAR 0 6
38429: PUSH
38430: LD_VAR 0 3
38434: ARRAY
38435: PUSH
38436: FOR_IN
38437: IFFALSE 38464
// if IsNotFull ( k ) then
38439: LD_VAR 0 8
38443: PPUSH
38444: CALL 68465 0 1
38448: IFFALSE 38462
// begin e := k ;
38450: LD_ADDR_VAR 0 7
38454: PUSH
38455: LD_VAR 0 8
38459: ST_TO_ADDR
// break ;
38460: GO 38464
// end ;
38462: GO 38436
38464: POP
38465: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38466: LD_VAR 0 7
38470: PUSH
38471: LD_VAR 0 5
38475: PPUSH
38476: LD_VAR 0 7
38480: PPUSH
38481: CALL 105584 0 2
38485: NOT
38486: AND
38487: IFFALSE 38546
// begin if IsInUnit ( p ) then
38489: LD_VAR 0 5
38493: PPUSH
38494: CALL_OW 310
38498: IFFALSE 38509
// ComExitBuilding ( p ) ;
38500: LD_VAR 0 5
38504: PPUSH
38505: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38509: LD_VAR 0 5
38513: PPUSH
38514: LD_VAR 0 7
38518: PPUSH
38519: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38523: LD_VAR 0 5
38527: PPUSH
38528: LD_VAR 0 3
38532: PPUSH
38533: CALL_OW 183
// AddComExitBuilding ( p ) ;
38537: LD_VAR 0 5
38541: PPUSH
38542: CALL_OW 182
// end ; end ;
38546: GO 38394
38548: POP
38549: POP
// end ;
38550: GO 38360
38552: POP
38553: POP
// end ;
38554: GO 38115
38556: POP
38557: POP
// end ;
38558: LD_VAR 0 1
38562: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38563: LD_INT 0
38565: PPUSH
38566: PPUSH
38567: PPUSH
38568: PPUSH
38569: PPUSH
38570: PPUSH
38571: PPUSH
38572: PPUSH
38573: PPUSH
38574: PPUSH
38575: PPUSH
38576: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38577: LD_VAR 0 1
38581: NOT
38582: PUSH
38583: LD_EXP 99
38587: PUSH
38588: LD_VAR 0 1
38592: ARRAY
38593: NOT
38594: OR
38595: PUSH
38596: LD_EXP 99
38600: PUSH
38601: LD_VAR 0 1
38605: ARRAY
38606: PPUSH
38607: LD_INT 2
38609: PUSH
38610: LD_INT 30
38612: PUSH
38613: LD_INT 0
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 30
38622: PUSH
38623: LD_INT 1
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: LIST
38634: PPUSH
38635: CALL_OW 72
38639: NOT
38640: OR
38641: IFFALSE 38645
// exit ;
38643: GO 42148
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38645: LD_ADDR_VAR 0 4
38649: PUSH
38650: LD_EXP 99
38654: PUSH
38655: LD_VAR 0 1
38659: ARRAY
38660: PPUSH
38661: LD_INT 2
38663: PUSH
38664: LD_INT 25
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 25
38676: PUSH
38677: LD_INT 2
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 25
38686: PUSH
38687: LD_INT 3
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 25
38696: PUSH
38697: LD_INT 4
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 25
38706: PUSH
38707: LD_INT 5
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 25
38716: PUSH
38717: LD_INT 8
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 25
38726: PUSH
38727: LD_INT 9
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: PPUSH
38744: CALL_OW 72
38748: ST_TO_ADDR
// if not tmp then
38749: LD_VAR 0 4
38753: NOT
38754: IFFALSE 38758
// exit ;
38756: GO 42148
// for i in tmp do
38758: LD_ADDR_VAR 0 3
38762: PUSH
38763: LD_VAR 0 4
38767: PUSH
38768: FOR_IN
38769: IFFALSE 38800
// if GetTag ( i ) then
38771: LD_VAR 0 3
38775: PPUSH
38776: CALL_OW 110
38780: IFFALSE 38798
// tmp := tmp diff i ;
38782: LD_ADDR_VAR 0 4
38786: PUSH
38787: LD_VAR 0 4
38791: PUSH
38792: LD_VAR 0 3
38796: DIFF
38797: ST_TO_ADDR
38798: GO 38768
38800: POP
38801: POP
// if not tmp then
38802: LD_VAR 0 4
38806: NOT
38807: IFFALSE 38811
// exit ;
38809: GO 42148
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38811: LD_ADDR_VAR 0 5
38815: PUSH
38816: LD_EXP 99
38820: PUSH
38821: LD_VAR 0 1
38825: ARRAY
38826: PPUSH
38827: LD_INT 2
38829: PUSH
38830: LD_INT 25
38832: PUSH
38833: LD_INT 1
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: LD_INT 25
38842: PUSH
38843: LD_INT 5
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 25
38852: PUSH
38853: LD_INT 8
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 25
38862: PUSH
38863: LD_INT 9
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: PPUSH
38877: CALL_OW 72
38881: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38882: LD_ADDR_VAR 0 6
38886: PUSH
38887: LD_EXP 99
38891: PUSH
38892: LD_VAR 0 1
38896: ARRAY
38897: PPUSH
38898: LD_INT 25
38900: PUSH
38901: LD_INT 2
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PPUSH
38908: CALL_OW 72
38912: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38913: LD_ADDR_VAR 0 7
38917: PUSH
38918: LD_EXP 99
38922: PUSH
38923: LD_VAR 0 1
38927: ARRAY
38928: PPUSH
38929: LD_INT 25
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PPUSH
38939: CALL_OW 72
38943: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38944: LD_ADDR_VAR 0 8
38948: PUSH
38949: LD_EXP 99
38953: PUSH
38954: LD_VAR 0 1
38958: ARRAY
38959: PPUSH
38960: LD_INT 25
38962: PUSH
38963: LD_INT 4
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: LD_INT 24
38972: PUSH
38973: LD_INT 251
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: EMPTY
38981: LIST
38982: LIST
38983: PPUSH
38984: CALL_OW 72
38988: ST_TO_ADDR
// if mc_scan [ base ] then
38989: LD_EXP 122
38993: PUSH
38994: LD_VAR 0 1
38998: ARRAY
38999: IFFALSE 39460
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39001: LD_ADDR_EXP 141
39005: PUSH
39006: LD_EXP 141
39010: PPUSH
39011: LD_VAR 0 1
39015: PPUSH
39016: LD_INT 4
39018: PPUSH
39019: CALL_OW 1
39023: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39024: LD_ADDR_VAR 0 12
39028: PUSH
39029: LD_EXP 99
39033: PUSH
39034: LD_VAR 0 1
39038: ARRAY
39039: PPUSH
39040: LD_INT 2
39042: PUSH
39043: LD_INT 30
39045: PUSH
39046: LD_INT 4
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: PUSH
39053: LD_INT 30
39055: PUSH
39056: LD_INT 5
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: LIST
39067: PPUSH
39068: CALL_OW 72
39072: ST_TO_ADDR
// if not b then
39073: LD_VAR 0 12
39077: NOT
39078: IFFALSE 39082
// exit ;
39080: GO 42148
// p := [ ] ;
39082: LD_ADDR_VAR 0 11
39086: PUSH
39087: EMPTY
39088: ST_TO_ADDR
// if sci >= 2 then
39089: LD_VAR 0 8
39093: PUSH
39094: LD_INT 2
39096: GREATEREQUAL
39097: IFFALSE 39128
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39099: LD_ADDR_VAR 0 8
39103: PUSH
39104: LD_VAR 0 8
39108: PUSH
39109: LD_INT 1
39111: ARRAY
39112: PUSH
39113: LD_VAR 0 8
39117: PUSH
39118: LD_INT 2
39120: ARRAY
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: ST_TO_ADDR
39126: GO 39189
// if sci = 1 then
39128: LD_VAR 0 8
39132: PUSH
39133: LD_INT 1
39135: EQUAL
39136: IFFALSE 39157
// sci := [ sci [ 1 ] ] else
39138: LD_ADDR_VAR 0 8
39142: PUSH
39143: LD_VAR 0 8
39147: PUSH
39148: LD_INT 1
39150: ARRAY
39151: PUSH
39152: EMPTY
39153: LIST
39154: ST_TO_ADDR
39155: GO 39189
// if sci = 0 then
39157: LD_VAR 0 8
39161: PUSH
39162: LD_INT 0
39164: EQUAL
39165: IFFALSE 39189
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39167: LD_ADDR_VAR 0 11
39171: PUSH
39172: LD_VAR 0 4
39176: PPUSH
39177: LD_INT 4
39179: PPUSH
39180: CALL 105447 0 2
39184: PUSH
39185: LD_INT 1
39187: ARRAY
39188: ST_TO_ADDR
// if eng > 4 then
39189: LD_VAR 0 6
39193: PUSH
39194: LD_INT 4
39196: GREATER
39197: IFFALSE 39243
// for i = eng downto 4 do
39199: LD_ADDR_VAR 0 3
39203: PUSH
39204: DOUBLE
39205: LD_VAR 0 6
39209: INC
39210: ST_TO_ADDR
39211: LD_INT 4
39213: PUSH
39214: FOR_DOWNTO
39215: IFFALSE 39241
// eng := eng diff eng [ i ] ;
39217: LD_ADDR_VAR 0 6
39221: PUSH
39222: LD_VAR 0 6
39226: PUSH
39227: LD_VAR 0 6
39231: PUSH
39232: LD_VAR 0 3
39236: ARRAY
39237: DIFF
39238: ST_TO_ADDR
39239: GO 39214
39241: POP
39242: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39243: LD_ADDR_VAR 0 4
39247: PUSH
39248: LD_VAR 0 4
39252: PUSH
39253: LD_VAR 0 5
39257: PUSH
39258: LD_VAR 0 6
39262: UNION
39263: PUSH
39264: LD_VAR 0 7
39268: UNION
39269: PUSH
39270: LD_VAR 0 8
39274: UNION
39275: DIFF
39276: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39277: LD_ADDR_VAR 0 13
39281: PUSH
39282: LD_EXP 99
39286: PUSH
39287: LD_VAR 0 1
39291: ARRAY
39292: PPUSH
39293: LD_INT 2
39295: PUSH
39296: LD_INT 30
39298: PUSH
39299: LD_INT 32
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 30
39308: PUSH
39309: LD_INT 31
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: LIST
39320: PPUSH
39321: CALL_OW 72
39325: PUSH
39326: LD_EXP 99
39330: PUSH
39331: LD_VAR 0 1
39335: ARRAY
39336: PPUSH
39337: LD_INT 2
39339: PUSH
39340: LD_INT 30
39342: PUSH
39343: LD_INT 4
39345: PUSH
39346: EMPTY
39347: LIST
39348: LIST
39349: PUSH
39350: LD_INT 30
39352: PUSH
39353: LD_INT 5
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: LIST
39364: PPUSH
39365: CALL_OW 72
39369: PUSH
39370: LD_INT 6
39372: MUL
39373: PLUS
39374: ST_TO_ADDR
// if bcount < tmp then
39375: LD_VAR 0 13
39379: PUSH
39380: LD_VAR 0 4
39384: LESS
39385: IFFALSE 39431
// for i = tmp downto bcount do
39387: LD_ADDR_VAR 0 3
39391: PUSH
39392: DOUBLE
39393: LD_VAR 0 4
39397: INC
39398: ST_TO_ADDR
39399: LD_VAR 0 13
39403: PUSH
39404: FOR_DOWNTO
39405: IFFALSE 39429
// tmp := Delete ( tmp , tmp ) ;
39407: LD_ADDR_VAR 0 4
39411: PUSH
39412: LD_VAR 0 4
39416: PPUSH
39417: LD_VAR 0 4
39421: PPUSH
39422: CALL_OW 3
39426: ST_TO_ADDR
39427: GO 39404
39429: POP
39430: POP
// result := [ tmp , 0 , 0 , p ] ;
39431: LD_ADDR_VAR 0 2
39435: PUSH
39436: LD_VAR 0 4
39440: PUSH
39441: LD_INT 0
39443: PUSH
39444: LD_INT 0
39446: PUSH
39447: LD_VAR 0 11
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: ST_TO_ADDR
// exit ;
39458: GO 42148
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39460: LD_EXP 99
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: LD_INT 2
39473: PUSH
39474: LD_INT 30
39476: PUSH
39477: LD_INT 6
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 30
39486: PUSH
39487: LD_INT 7
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 30
39496: PUSH
39497: LD_INT 8
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: LIST
39508: LIST
39509: PPUSH
39510: CALL_OW 72
39514: NOT
39515: PUSH
39516: LD_EXP 99
39520: PUSH
39521: LD_VAR 0 1
39525: ARRAY
39526: PPUSH
39527: LD_INT 30
39529: PUSH
39530: LD_INT 3
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PPUSH
39537: CALL_OW 72
39541: NOT
39542: AND
39543: IFFALSE 39615
// begin if eng = tmp then
39545: LD_VAR 0 6
39549: PUSH
39550: LD_VAR 0 4
39554: EQUAL
39555: IFFALSE 39559
// exit ;
39557: GO 42148
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39559: LD_ADDR_EXP 141
39563: PUSH
39564: LD_EXP 141
39568: PPUSH
39569: LD_VAR 0 1
39573: PPUSH
39574: LD_INT 1
39576: PPUSH
39577: CALL_OW 1
39581: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39582: LD_ADDR_VAR 0 2
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: LD_VAR 0 4
39594: PUSH
39595: LD_VAR 0 6
39599: DIFF
39600: PUSH
39601: LD_INT 0
39603: PUSH
39604: LD_INT 0
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: ST_TO_ADDR
// exit ;
39613: GO 42148
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39615: LD_EXP 126
39619: PUSH
39620: LD_EXP 125
39624: PUSH
39625: LD_VAR 0 1
39629: ARRAY
39630: ARRAY
39631: PUSH
39632: LD_EXP 99
39636: PUSH
39637: LD_VAR 0 1
39641: ARRAY
39642: PPUSH
39643: LD_INT 2
39645: PUSH
39646: LD_INT 30
39648: PUSH
39649: LD_INT 6
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 30
39658: PUSH
39659: LD_INT 7
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 30
39668: PUSH
39669: LD_INT 8
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: PPUSH
39682: CALL_OW 72
39686: AND
39687: PUSH
39688: LD_EXP 99
39692: PUSH
39693: LD_VAR 0 1
39697: ARRAY
39698: PPUSH
39699: LD_INT 30
39701: PUSH
39702: LD_INT 3
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PPUSH
39709: CALL_OW 72
39713: NOT
39714: AND
39715: IFFALSE 39929
// begin if sci >= 6 then
39717: LD_VAR 0 8
39721: PUSH
39722: LD_INT 6
39724: GREATEREQUAL
39725: IFFALSE 39729
// exit ;
39727: GO 42148
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39729: LD_ADDR_EXP 141
39733: PUSH
39734: LD_EXP 141
39738: PPUSH
39739: LD_VAR 0 1
39743: PPUSH
39744: LD_INT 2
39746: PPUSH
39747: CALL_OW 1
39751: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39752: LD_ADDR_VAR 0 9
39756: PUSH
39757: LD_VAR 0 4
39761: PUSH
39762: LD_VAR 0 8
39766: DIFF
39767: PPUSH
39768: LD_INT 4
39770: PPUSH
39771: CALL 105447 0 2
39775: ST_TO_ADDR
// p := [ ] ;
39776: LD_ADDR_VAR 0 11
39780: PUSH
39781: EMPTY
39782: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39783: LD_VAR 0 8
39787: PUSH
39788: LD_INT 6
39790: LESS
39791: PUSH
39792: LD_VAR 0 9
39796: PUSH
39797: LD_INT 6
39799: GREATER
39800: AND
39801: IFFALSE 39882
// begin for i = 1 to 6 - sci do
39803: LD_ADDR_VAR 0 3
39807: PUSH
39808: DOUBLE
39809: LD_INT 1
39811: DEC
39812: ST_TO_ADDR
39813: LD_INT 6
39815: PUSH
39816: LD_VAR 0 8
39820: MINUS
39821: PUSH
39822: FOR_TO
39823: IFFALSE 39878
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39825: LD_ADDR_VAR 0 11
39829: PUSH
39830: LD_VAR 0 11
39834: PPUSH
39835: LD_VAR 0 11
39839: PUSH
39840: LD_INT 1
39842: PLUS
39843: PPUSH
39844: LD_VAR 0 9
39848: PUSH
39849: LD_INT 1
39851: ARRAY
39852: PPUSH
39853: CALL_OW 2
39857: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39858: LD_ADDR_VAR 0 9
39862: PUSH
39863: LD_VAR 0 9
39867: PPUSH
39868: LD_INT 1
39870: PPUSH
39871: CALL_OW 3
39875: ST_TO_ADDR
// end ;
39876: GO 39822
39878: POP
39879: POP
// end else
39880: GO 39902
// if sort then
39882: LD_VAR 0 9
39886: IFFALSE 39902
// p := sort [ 1 ] ;
39888: LD_ADDR_VAR 0 11
39892: PUSH
39893: LD_VAR 0 9
39897: PUSH
39898: LD_INT 1
39900: ARRAY
39901: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39902: LD_ADDR_VAR 0 2
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: LD_INT 0
39912: PUSH
39913: LD_INT 0
39915: PUSH
39916: LD_VAR 0 11
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: ST_TO_ADDR
// exit ;
39927: GO 42148
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39929: LD_EXP 126
39933: PUSH
39934: LD_EXP 125
39938: PUSH
39939: LD_VAR 0 1
39943: ARRAY
39944: ARRAY
39945: PUSH
39946: LD_EXP 99
39950: PUSH
39951: LD_VAR 0 1
39955: ARRAY
39956: PPUSH
39957: LD_INT 2
39959: PUSH
39960: LD_INT 30
39962: PUSH
39963: LD_INT 6
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 30
39972: PUSH
39973: LD_INT 7
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 30
39982: PUSH
39983: LD_INT 8
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: PPUSH
39996: CALL_OW 72
40000: AND
40001: PUSH
40002: LD_EXP 99
40006: PUSH
40007: LD_VAR 0 1
40011: ARRAY
40012: PPUSH
40013: LD_INT 30
40015: PUSH
40016: LD_INT 3
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PPUSH
40023: CALL_OW 72
40027: AND
40028: IFFALSE 40762
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40030: LD_ADDR_EXP 141
40034: PUSH
40035: LD_EXP 141
40039: PPUSH
40040: LD_VAR 0 1
40044: PPUSH
40045: LD_INT 3
40047: PPUSH
40048: CALL_OW 1
40052: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40053: LD_ADDR_VAR 0 2
40057: PUSH
40058: LD_INT 0
40060: PUSH
40061: LD_INT 0
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: LD_INT 0
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: LIST
40074: LIST
40075: ST_TO_ADDR
// if not eng then
40076: LD_VAR 0 6
40080: NOT
40081: IFFALSE 40144
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40083: LD_ADDR_VAR 0 11
40087: PUSH
40088: LD_VAR 0 4
40092: PPUSH
40093: LD_INT 2
40095: PPUSH
40096: CALL 105447 0 2
40100: PUSH
40101: LD_INT 1
40103: ARRAY
40104: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40105: LD_ADDR_VAR 0 2
40109: PUSH
40110: LD_VAR 0 2
40114: PPUSH
40115: LD_INT 2
40117: PPUSH
40118: LD_VAR 0 11
40122: PPUSH
40123: CALL_OW 1
40127: ST_TO_ADDR
// tmp := tmp diff p ;
40128: LD_ADDR_VAR 0 4
40132: PUSH
40133: LD_VAR 0 4
40137: PUSH
40138: LD_VAR 0 11
40142: DIFF
40143: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40144: LD_VAR 0 4
40148: PUSH
40149: LD_VAR 0 8
40153: PUSH
40154: LD_INT 6
40156: LESS
40157: AND
40158: IFFALSE 40346
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40160: LD_ADDR_VAR 0 9
40164: PUSH
40165: LD_VAR 0 4
40169: PUSH
40170: LD_VAR 0 8
40174: PUSH
40175: LD_VAR 0 7
40179: UNION
40180: DIFF
40181: PPUSH
40182: LD_INT 4
40184: PPUSH
40185: CALL 105447 0 2
40189: ST_TO_ADDR
// p := [ ] ;
40190: LD_ADDR_VAR 0 11
40194: PUSH
40195: EMPTY
40196: ST_TO_ADDR
// if sort then
40197: LD_VAR 0 9
40201: IFFALSE 40317
// for i = 1 to 6 - sci do
40203: LD_ADDR_VAR 0 3
40207: PUSH
40208: DOUBLE
40209: LD_INT 1
40211: DEC
40212: ST_TO_ADDR
40213: LD_INT 6
40215: PUSH
40216: LD_VAR 0 8
40220: MINUS
40221: PUSH
40222: FOR_TO
40223: IFFALSE 40315
// begin if i = sort then
40225: LD_VAR 0 3
40229: PUSH
40230: LD_VAR 0 9
40234: EQUAL
40235: IFFALSE 40239
// break ;
40237: GO 40315
// if GetClass ( i ) = 4 then
40239: LD_VAR 0 3
40243: PPUSH
40244: CALL_OW 257
40248: PUSH
40249: LD_INT 4
40251: EQUAL
40252: IFFALSE 40256
// continue ;
40254: GO 40222
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40256: LD_ADDR_VAR 0 11
40260: PUSH
40261: LD_VAR 0 11
40265: PPUSH
40266: LD_VAR 0 11
40270: PUSH
40271: LD_INT 1
40273: PLUS
40274: PPUSH
40275: LD_VAR 0 9
40279: PUSH
40280: LD_VAR 0 3
40284: ARRAY
40285: PPUSH
40286: CALL_OW 2
40290: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40291: LD_ADDR_VAR 0 4
40295: PUSH
40296: LD_VAR 0 4
40300: PUSH
40301: LD_VAR 0 9
40305: PUSH
40306: LD_VAR 0 3
40310: ARRAY
40311: DIFF
40312: ST_TO_ADDR
// end ;
40313: GO 40222
40315: POP
40316: POP
// if p then
40317: LD_VAR 0 11
40321: IFFALSE 40346
// result := Replace ( result , 4 , p ) ;
40323: LD_ADDR_VAR 0 2
40327: PUSH
40328: LD_VAR 0 2
40332: PPUSH
40333: LD_INT 4
40335: PPUSH
40336: LD_VAR 0 11
40340: PPUSH
40341: CALL_OW 1
40345: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40346: LD_VAR 0 4
40350: PUSH
40351: LD_VAR 0 7
40355: PUSH
40356: LD_INT 6
40358: LESS
40359: AND
40360: IFFALSE 40548
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40362: LD_ADDR_VAR 0 9
40366: PUSH
40367: LD_VAR 0 4
40371: PUSH
40372: LD_VAR 0 8
40376: PUSH
40377: LD_VAR 0 7
40381: UNION
40382: DIFF
40383: PPUSH
40384: LD_INT 3
40386: PPUSH
40387: CALL 105447 0 2
40391: ST_TO_ADDR
// p := [ ] ;
40392: LD_ADDR_VAR 0 11
40396: PUSH
40397: EMPTY
40398: ST_TO_ADDR
// if sort then
40399: LD_VAR 0 9
40403: IFFALSE 40519
// for i = 1 to 6 - mech do
40405: LD_ADDR_VAR 0 3
40409: PUSH
40410: DOUBLE
40411: LD_INT 1
40413: DEC
40414: ST_TO_ADDR
40415: LD_INT 6
40417: PUSH
40418: LD_VAR 0 7
40422: MINUS
40423: PUSH
40424: FOR_TO
40425: IFFALSE 40517
// begin if i = sort then
40427: LD_VAR 0 3
40431: PUSH
40432: LD_VAR 0 9
40436: EQUAL
40437: IFFALSE 40441
// break ;
40439: GO 40517
// if GetClass ( i ) = 3 then
40441: LD_VAR 0 3
40445: PPUSH
40446: CALL_OW 257
40450: PUSH
40451: LD_INT 3
40453: EQUAL
40454: IFFALSE 40458
// continue ;
40456: GO 40424
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40458: LD_ADDR_VAR 0 11
40462: PUSH
40463: LD_VAR 0 11
40467: PPUSH
40468: LD_VAR 0 11
40472: PUSH
40473: LD_INT 1
40475: PLUS
40476: PPUSH
40477: LD_VAR 0 9
40481: PUSH
40482: LD_VAR 0 3
40486: ARRAY
40487: PPUSH
40488: CALL_OW 2
40492: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40493: LD_ADDR_VAR 0 4
40497: PUSH
40498: LD_VAR 0 4
40502: PUSH
40503: LD_VAR 0 9
40507: PUSH
40508: LD_VAR 0 3
40512: ARRAY
40513: DIFF
40514: ST_TO_ADDR
// end ;
40515: GO 40424
40517: POP
40518: POP
// if p then
40519: LD_VAR 0 11
40523: IFFALSE 40548
// result := Replace ( result , 3 , p ) ;
40525: LD_ADDR_VAR 0 2
40529: PUSH
40530: LD_VAR 0 2
40534: PPUSH
40535: LD_INT 3
40537: PPUSH
40538: LD_VAR 0 11
40542: PPUSH
40543: CALL_OW 1
40547: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40548: LD_VAR 0 4
40552: PUSH
40553: LD_INT 6
40555: GREATER
40556: PUSH
40557: LD_VAR 0 6
40561: PUSH
40562: LD_INT 6
40564: LESS
40565: AND
40566: IFFALSE 40760
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40568: LD_ADDR_VAR 0 9
40572: PUSH
40573: LD_VAR 0 4
40577: PUSH
40578: LD_VAR 0 8
40582: PUSH
40583: LD_VAR 0 7
40587: UNION
40588: PUSH
40589: LD_VAR 0 6
40593: UNION
40594: DIFF
40595: PPUSH
40596: LD_INT 2
40598: PPUSH
40599: CALL 105447 0 2
40603: ST_TO_ADDR
// p := [ ] ;
40604: LD_ADDR_VAR 0 11
40608: PUSH
40609: EMPTY
40610: ST_TO_ADDR
// if sort then
40611: LD_VAR 0 9
40615: IFFALSE 40731
// for i = 1 to 6 - eng do
40617: LD_ADDR_VAR 0 3
40621: PUSH
40622: DOUBLE
40623: LD_INT 1
40625: DEC
40626: ST_TO_ADDR
40627: LD_INT 6
40629: PUSH
40630: LD_VAR 0 6
40634: MINUS
40635: PUSH
40636: FOR_TO
40637: IFFALSE 40729
// begin if i = sort then
40639: LD_VAR 0 3
40643: PUSH
40644: LD_VAR 0 9
40648: EQUAL
40649: IFFALSE 40653
// break ;
40651: GO 40729
// if GetClass ( i ) = 2 then
40653: LD_VAR 0 3
40657: PPUSH
40658: CALL_OW 257
40662: PUSH
40663: LD_INT 2
40665: EQUAL
40666: IFFALSE 40670
// continue ;
40668: GO 40636
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40670: LD_ADDR_VAR 0 11
40674: PUSH
40675: LD_VAR 0 11
40679: PPUSH
40680: LD_VAR 0 11
40684: PUSH
40685: LD_INT 1
40687: PLUS
40688: PPUSH
40689: LD_VAR 0 9
40693: PUSH
40694: LD_VAR 0 3
40698: ARRAY
40699: PPUSH
40700: CALL_OW 2
40704: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40705: LD_ADDR_VAR 0 4
40709: PUSH
40710: LD_VAR 0 4
40714: PUSH
40715: LD_VAR 0 9
40719: PUSH
40720: LD_VAR 0 3
40724: ARRAY
40725: DIFF
40726: ST_TO_ADDR
// end ;
40727: GO 40636
40729: POP
40730: POP
// if p then
40731: LD_VAR 0 11
40735: IFFALSE 40760
// result := Replace ( result , 2 , p ) ;
40737: LD_ADDR_VAR 0 2
40741: PUSH
40742: LD_VAR 0 2
40746: PPUSH
40747: LD_INT 2
40749: PPUSH
40750: LD_VAR 0 11
40754: PPUSH
40755: CALL_OW 1
40759: ST_TO_ADDR
// end ; exit ;
40760: GO 42148
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40762: LD_EXP 126
40766: PUSH
40767: LD_EXP 125
40771: PUSH
40772: LD_VAR 0 1
40776: ARRAY
40777: ARRAY
40778: NOT
40779: PUSH
40780: LD_EXP 99
40784: PUSH
40785: LD_VAR 0 1
40789: ARRAY
40790: PPUSH
40791: LD_INT 30
40793: PUSH
40794: LD_INT 3
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PPUSH
40801: CALL_OW 72
40805: AND
40806: PUSH
40807: LD_EXP 104
40811: PUSH
40812: LD_VAR 0 1
40816: ARRAY
40817: AND
40818: IFFALSE 41426
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40820: LD_ADDR_EXP 141
40824: PUSH
40825: LD_EXP 141
40829: PPUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: LD_INT 5
40837: PPUSH
40838: CALL_OW 1
40842: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40843: LD_ADDR_VAR 0 2
40847: PUSH
40848: LD_INT 0
40850: PUSH
40851: LD_INT 0
40853: PUSH
40854: LD_INT 0
40856: PUSH
40857: LD_INT 0
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: ST_TO_ADDR
// if sci > 1 then
40866: LD_VAR 0 8
40870: PUSH
40871: LD_INT 1
40873: GREATER
40874: IFFALSE 40902
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40876: LD_ADDR_VAR 0 4
40880: PUSH
40881: LD_VAR 0 4
40885: PUSH
40886: LD_VAR 0 8
40890: PUSH
40891: LD_VAR 0 8
40895: PUSH
40896: LD_INT 1
40898: ARRAY
40899: DIFF
40900: DIFF
40901: ST_TO_ADDR
// if tmp and not sci then
40902: LD_VAR 0 4
40906: PUSH
40907: LD_VAR 0 8
40911: NOT
40912: AND
40913: IFFALSE 40982
// begin sort := SortBySkill ( tmp , 4 ) ;
40915: LD_ADDR_VAR 0 9
40919: PUSH
40920: LD_VAR 0 4
40924: PPUSH
40925: LD_INT 4
40927: PPUSH
40928: CALL 105447 0 2
40932: ST_TO_ADDR
// if sort then
40933: LD_VAR 0 9
40937: IFFALSE 40953
// p := sort [ 1 ] ;
40939: LD_ADDR_VAR 0 11
40943: PUSH
40944: LD_VAR 0 9
40948: PUSH
40949: LD_INT 1
40951: ARRAY
40952: ST_TO_ADDR
// if p then
40953: LD_VAR 0 11
40957: IFFALSE 40982
// result := Replace ( result , 4 , p ) ;
40959: LD_ADDR_VAR 0 2
40963: PUSH
40964: LD_VAR 0 2
40968: PPUSH
40969: LD_INT 4
40971: PPUSH
40972: LD_VAR 0 11
40976: PPUSH
40977: CALL_OW 1
40981: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40982: LD_ADDR_VAR 0 4
40986: PUSH
40987: LD_VAR 0 4
40991: PUSH
40992: LD_VAR 0 7
40996: DIFF
40997: ST_TO_ADDR
// if tmp and mech < 6 then
40998: LD_VAR 0 4
41002: PUSH
41003: LD_VAR 0 7
41007: PUSH
41008: LD_INT 6
41010: LESS
41011: AND
41012: IFFALSE 41200
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41014: LD_ADDR_VAR 0 9
41018: PUSH
41019: LD_VAR 0 4
41023: PUSH
41024: LD_VAR 0 8
41028: PUSH
41029: LD_VAR 0 7
41033: UNION
41034: DIFF
41035: PPUSH
41036: LD_INT 3
41038: PPUSH
41039: CALL 105447 0 2
41043: ST_TO_ADDR
// p := [ ] ;
41044: LD_ADDR_VAR 0 11
41048: PUSH
41049: EMPTY
41050: ST_TO_ADDR
// if sort then
41051: LD_VAR 0 9
41055: IFFALSE 41171
// for i = 1 to 6 - mech do
41057: LD_ADDR_VAR 0 3
41061: PUSH
41062: DOUBLE
41063: LD_INT 1
41065: DEC
41066: ST_TO_ADDR
41067: LD_INT 6
41069: PUSH
41070: LD_VAR 0 7
41074: MINUS
41075: PUSH
41076: FOR_TO
41077: IFFALSE 41169
// begin if i = sort then
41079: LD_VAR 0 3
41083: PUSH
41084: LD_VAR 0 9
41088: EQUAL
41089: IFFALSE 41093
// break ;
41091: GO 41169
// if GetClass ( i ) = 3 then
41093: LD_VAR 0 3
41097: PPUSH
41098: CALL_OW 257
41102: PUSH
41103: LD_INT 3
41105: EQUAL
41106: IFFALSE 41110
// continue ;
41108: GO 41076
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41110: LD_ADDR_VAR 0 11
41114: PUSH
41115: LD_VAR 0 11
41119: PPUSH
41120: LD_VAR 0 11
41124: PUSH
41125: LD_INT 1
41127: PLUS
41128: PPUSH
41129: LD_VAR 0 9
41133: PUSH
41134: LD_VAR 0 3
41138: ARRAY
41139: PPUSH
41140: CALL_OW 2
41144: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41145: LD_ADDR_VAR 0 4
41149: PUSH
41150: LD_VAR 0 4
41154: PUSH
41155: LD_VAR 0 9
41159: PUSH
41160: LD_VAR 0 3
41164: ARRAY
41165: DIFF
41166: ST_TO_ADDR
// end ;
41167: GO 41076
41169: POP
41170: POP
// if p then
41171: LD_VAR 0 11
41175: IFFALSE 41200
// result := Replace ( result , 3 , p ) ;
41177: LD_ADDR_VAR 0 2
41181: PUSH
41182: LD_VAR 0 2
41186: PPUSH
41187: LD_INT 3
41189: PPUSH
41190: LD_VAR 0 11
41194: PPUSH
41195: CALL_OW 1
41199: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41200: LD_ADDR_VAR 0 4
41204: PUSH
41205: LD_VAR 0 4
41209: PUSH
41210: LD_VAR 0 6
41214: DIFF
41215: ST_TO_ADDR
// if tmp and eng < 6 then
41216: LD_VAR 0 4
41220: PUSH
41221: LD_VAR 0 6
41225: PUSH
41226: LD_INT 6
41228: LESS
41229: AND
41230: IFFALSE 41424
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41232: LD_ADDR_VAR 0 9
41236: PUSH
41237: LD_VAR 0 4
41241: PUSH
41242: LD_VAR 0 8
41246: PUSH
41247: LD_VAR 0 7
41251: UNION
41252: PUSH
41253: LD_VAR 0 6
41257: UNION
41258: DIFF
41259: PPUSH
41260: LD_INT 2
41262: PPUSH
41263: CALL 105447 0 2
41267: ST_TO_ADDR
// p := [ ] ;
41268: LD_ADDR_VAR 0 11
41272: PUSH
41273: EMPTY
41274: ST_TO_ADDR
// if sort then
41275: LD_VAR 0 9
41279: IFFALSE 41395
// for i = 1 to 6 - eng do
41281: LD_ADDR_VAR 0 3
41285: PUSH
41286: DOUBLE
41287: LD_INT 1
41289: DEC
41290: ST_TO_ADDR
41291: LD_INT 6
41293: PUSH
41294: LD_VAR 0 6
41298: MINUS
41299: PUSH
41300: FOR_TO
41301: IFFALSE 41393
// begin if i = sort then
41303: LD_VAR 0 3
41307: PUSH
41308: LD_VAR 0 9
41312: EQUAL
41313: IFFALSE 41317
// break ;
41315: GO 41393
// if GetClass ( i ) = 2 then
41317: LD_VAR 0 3
41321: PPUSH
41322: CALL_OW 257
41326: PUSH
41327: LD_INT 2
41329: EQUAL
41330: IFFALSE 41334
// continue ;
41332: GO 41300
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41334: LD_ADDR_VAR 0 11
41338: PUSH
41339: LD_VAR 0 11
41343: PPUSH
41344: LD_VAR 0 11
41348: PUSH
41349: LD_INT 1
41351: PLUS
41352: PPUSH
41353: LD_VAR 0 9
41357: PUSH
41358: LD_VAR 0 3
41362: ARRAY
41363: PPUSH
41364: CALL_OW 2
41368: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41369: LD_ADDR_VAR 0 4
41373: PUSH
41374: LD_VAR 0 4
41378: PUSH
41379: LD_VAR 0 9
41383: PUSH
41384: LD_VAR 0 3
41388: ARRAY
41389: DIFF
41390: ST_TO_ADDR
// end ;
41391: GO 41300
41393: POP
41394: POP
// if p then
41395: LD_VAR 0 11
41399: IFFALSE 41424
// result := Replace ( result , 2 , p ) ;
41401: LD_ADDR_VAR 0 2
41405: PUSH
41406: LD_VAR 0 2
41410: PPUSH
41411: LD_INT 2
41413: PPUSH
41414: LD_VAR 0 11
41418: PPUSH
41419: CALL_OW 1
41423: ST_TO_ADDR
// end ; exit ;
41424: GO 42148
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41426: LD_EXP 126
41430: PUSH
41431: LD_EXP 125
41435: PUSH
41436: LD_VAR 0 1
41440: ARRAY
41441: ARRAY
41442: NOT
41443: PUSH
41444: LD_EXP 99
41448: PUSH
41449: LD_VAR 0 1
41453: ARRAY
41454: PPUSH
41455: LD_INT 30
41457: PUSH
41458: LD_INT 3
41460: PUSH
41461: EMPTY
41462: LIST
41463: LIST
41464: PPUSH
41465: CALL_OW 72
41469: AND
41470: PUSH
41471: LD_EXP 104
41475: PUSH
41476: LD_VAR 0 1
41480: ARRAY
41481: NOT
41482: AND
41483: IFFALSE 42148
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41485: LD_ADDR_EXP 141
41489: PUSH
41490: LD_EXP 141
41494: PPUSH
41495: LD_VAR 0 1
41499: PPUSH
41500: LD_INT 6
41502: PPUSH
41503: CALL_OW 1
41507: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41508: LD_ADDR_VAR 0 2
41512: PUSH
41513: LD_INT 0
41515: PUSH
41516: LD_INT 0
41518: PUSH
41519: LD_INT 0
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: ST_TO_ADDR
// if sci >= 1 then
41531: LD_VAR 0 8
41535: PUSH
41536: LD_INT 1
41538: GREATEREQUAL
41539: IFFALSE 41561
// tmp := tmp diff sci [ 1 ] ;
41541: LD_ADDR_VAR 0 4
41545: PUSH
41546: LD_VAR 0 4
41550: PUSH
41551: LD_VAR 0 8
41555: PUSH
41556: LD_INT 1
41558: ARRAY
41559: DIFF
41560: ST_TO_ADDR
// if tmp and not sci then
41561: LD_VAR 0 4
41565: PUSH
41566: LD_VAR 0 8
41570: NOT
41571: AND
41572: IFFALSE 41641
// begin sort := SortBySkill ( tmp , 4 ) ;
41574: LD_ADDR_VAR 0 9
41578: PUSH
41579: LD_VAR 0 4
41583: PPUSH
41584: LD_INT 4
41586: PPUSH
41587: CALL 105447 0 2
41591: ST_TO_ADDR
// if sort then
41592: LD_VAR 0 9
41596: IFFALSE 41612
// p := sort [ 1 ] ;
41598: LD_ADDR_VAR 0 11
41602: PUSH
41603: LD_VAR 0 9
41607: PUSH
41608: LD_INT 1
41610: ARRAY
41611: ST_TO_ADDR
// if p then
41612: LD_VAR 0 11
41616: IFFALSE 41641
// result := Replace ( result , 4 , p ) ;
41618: LD_ADDR_VAR 0 2
41622: PUSH
41623: LD_VAR 0 2
41627: PPUSH
41628: LD_INT 4
41630: PPUSH
41631: LD_VAR 0 11
41635: PPUSH
41636: CALL_OW 1
41640: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41641: LD_ADDR_VAR 0 4
41645: PUSH
41646: LD_VAR 0 4
41650: PUSH
41651: LD_VAR 0 7
41655: DIFF
41656: ST_TO_ADDR
// if tmp and mech < 6 then
41657: LD_VAR 0 4
41661: PUSH
41662: LD_VAR 0 7
41666: PUSH
41667: LD_INT 6
41669: LESS
41670: AND
41671: IFFALSE 41853
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41673: LD_ADDR_VAR 0 9
41677: PUSH
41678: LD_VAR 0 4
41682: PUSH
41683: LD_VAR 0 7
41687: DIFF
41688: PPUSH
41689: LD_INT 3
41691: PPUSH
41692: CALL 105447 0 2
41696: ST_TO_ADDR
// p := [ ] ;
41697: LD_ADDR_VAR 0 11
41701: PUSH
41702: EMPTY
41703: ST_TO_ADDR
// if sort then
41704: LD_VAR 0 9
41708: IFFALSE 41824
// for i = 1 to 6 - mech do
41710: LD_ADDR_VAR 0 3
41714: PUSH
41715: DOUBLE
41716: LD_INT 1
41718: DEC
41719: ST_TO_ADDR
41720: LD_INT 6
41722: PUSH
41723: LD_VAR 0 7
41727: MINUS
41728: PUSH
41729: FOR_TO
41730: IFFALSE 41822
// begin if i = sort then
41732: LD_VAR 0 3
41736: PUSH
41737: LD_VAR 0 9
41741: EQUAL
41742: IFFALSE 41746
// break ;
41744: GO 41822
// if GetClass ( i ) = 3 then
41746: LD_VAR 0 3
41750: PPUSH
41751: CALL_OW 257
41755: PUSH
41756: LD_INT 3
41758: EQUAL
41759: IFFALSE 41763
// continue ;
41761: GO 41729
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41763: LD_ADDR_VAR 0 11
41767: PUSH
41768: LD_VAR 0 11
41772: PPUSH
41773: LD_VAR 0 11
41777: PUSH
41778: LD_INT 1
41780: PLUS
41781: PPUSH
41782: LD_VAR 0 9
41786: PUSH
41787: LD_VAR 0 3
41791: ARRAY
41792: PPUSH
41793: CALL_OW 2
41797: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41798: LD_ADDR_VAR 0 4
41802: PUSH
41803: LD_VAR 0 4
41807: PUSH
41808: LD_VAR 0 9
41812: PUSH
41813: LD_VAR 0 3
41817: ARRAY
41818: DIFF
41819: ST_TO_ADDR
// end ;
41820: GO 41729
41822: POP
41823: POP
// if p then
41824: LD_VAR 0 11
41828: IFFALSE 41853
// result := Replace ( result , 3 , p ) ;
41830: LD_ADDR_VAR 0 2
41834: PUSH
41835: LD_VAR 0 2
41839: PPUSH
41840: LD_INT 3
41842: PPUSH
41843: LD_VAR 0 11
41847: PPUSH
41848: CALL_OW 1
41852: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41853: LD_ADDR_VAR 0 4
41857: PUSH
41858: LD_VAR 0 4
41862: PUSH
41863: LD_VAR 0 6
41867: DIFF
41868: ST_TO_ADDR
// if tmp and eng < 4 then
41869: LD_VAR 0 4
41873: PUSH
41874: LD_VAR 0 6
41878: PUSH
41879: LD_INT 4
41881: LESS
41882: AND
41883: IFFALSE 42073
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41885: LD_ADDR_VAR 0 9
41889: PUSH
41890: LD_VAR 0 4
41894: PUSH
41895: LD_VAR 0 7
41899: PUSH
41900: LD_VAR 0 6
41904: UNION
41905: DIFF
41906: PPUSH
41907: LD_INT 2
41909: PPUSH
41910: CALL 105447 0 2
41914: ST_TO_ADDR
// p := [ ] ;
41915: LD_ADDR_VAR 0 11
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// if sort then
41922: LD_VAR 0 9
41926: IFFALSE 42042
// for i = 1 to 4 - eng do
41928: LD_ADDR_VAR 0 3
41932: PUSH
41933: DOUBLE
41934: LD_INT 1
41936: DEC
41937: ST_TO_ADDR
41938: LD_INT 4
41940: PUSH
41941: LD_VAR 0 6
41945: MINUS
41946: PUSH
41947: FOR_TO
41948: IFFALSE 42040
// begin if i = sort then
41950: LD_VAR 0 3
41954: PUSH
41955: LD_VAR 0 9
41959: EQUAL
41960: IFFALSE 41964
// break ;
41962: GO 42040
// if GetClass ( i ) = 2 then
41964: LD_VAR 0 3
41968: PPUSH
41969: CALL_OW 257
41973: PUSH
41974: LD_INT 2
41976: EQUAL
41977: IFFALSE 41981
// continue ;
41979: GO 41947
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41981: LD_ADDR_VAR 0 11
41985: PUSH
41986: LD_VAR 0 11
41990: PPUSH
41991: LD_VAR 0 11
41995: PUSH
41996: LD_INT 1
41998: PLUS
41999: PPUSH
42000: LD_VAR 0 9
42004: PUSH
42005: LD_VAR 0 3
42009: ARRAY
42010: PPUSH
42011: CALL_OW 2
42015: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42016: LD_ADDR_VAR 0 4
42020: PUSH
42021: LD_VAR 0 4
42025: PUSH
42026: LD_VAR 0 9
42030: PUSH
42031: LD_VAR 0 3
42035: ARRAY
42036: DIFF
42037: ST_TO_ADDR
// end ;
42038: GO 41947
42040: POP
42041: POP
// if p then
42042: LD_VAR 0 11
42046: IFFALSE 42071
// result := Replace ( result , 2 , p ) ;
42048: LD_ADDR_VAR 0 2
42052: PUSH
42053: LD_VAR 0 2
42057: PPUSH
42058: LD_INT 2
42060: PPUSH
42061: LD_VAR 0 11
42065: PPUSH
42066: CALL_OW 1
42070: ST_TO_ADDR
// end else
42071: GO 42117
// for i = eng downto 5 do
42073: LD_ADDR_VAR 0 3
42077: PUSH
42078: DOUBLE
42079: LD_VAR 0 6
42083: INC
42084: ST_TO_ADDR
42085: LD_INT 5
42087: PUSH
42088: FOR_DOWNTO
42089: IFFALSE 42115
// tmp := tmp union eng [ i ] ;
42091: LD_ADDR_VAR 0 4
42095: PUSH
42096: LD_VAR 0 4
42100: PUSH
42101: LD_VAR 0 6
42105: PUSH
42106: LD_VAR 0 3
42110: ARRAY
42111: UNION
42112: ST_TO_ADDR
42113: GO 42088
42115: POP
42116: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42117: LD_ADDR_VAR 0 2
42121: PUSH
42122: LD_VAR 0 2
42126: PPUSH
42127: LD_INT 1
42129: PPUSH
42130: LD_VAR 0 4
42134: PUSH
42135: LD_VAR 0 5
42139: DIFF
42140: PPUSH
42141: CALL_OW 1
42145: ST_TO_ADDR
// exit ;
42146: GO 42148
// end ; end ;
42148: LD_VAR 0 2
42152: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42153: LD_INT 0
42155: PPUSH
42156: PPUSH
42157: PPUSH
// if not mc_bases then
42158: LD_EXP 99
42162: NOT
42163: IFFALSE 42167
// exit ;
42165: GO 42273
// for i = 1 to mc_bases do
42167: LD_ADDR_VAR 0 2
42171: PUSH
42172: DOUBLE
42173: LD_INT 1
42175: DEC
42176: ST_TO_ADDR
42177: LD_EXP 99
42181: PUSH
42182: FOR_TO
42183: IFFALSE 42264
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42185: LD_ADDR_VAR 0 3
42189: PUSH
42190: LD_EXP 99
42194: PUSH
42195: LD_VAR 0 2
42199: ARRAY
42200: PPUSH
42201: LD_INT 21
42203: PUSH
42204: LD_INT 3
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 3
42213: PUSH
42214: LD_INT 24
42216: PUSH
42217: LD_INT 1000
42219: PUSH
42220: EMPTY
42221: LIST
42222: LIST
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PPUSH
42232: CALL_OW 72
42236: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42237: LD_ADDR_EXP 100
42241: PUSH
42242: LD_EXP 100
42246: PPUSH
42247: LD_VAR 0 2
42251: PPUSH
42252: LD_VAR 0 3
42256: PPUSH
42257: CALL_OW 1
42261: ST_TO_ADDR
// end ;
42262: GO 42182
42264: POP
42265: POP
// RaiseSailEvent ( 101 ) ;
42266: LD_INT 101
42268: PPUSH
42269: CALL_OW 427
// end ;
42273: LD_VAR 0 1
42277: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42278: LD_INT 0
42280: PPUSH
42281: PPUSH
42282: PPUSH
42283: PPUSH
42284: PPUSH
42285: PPUSH
42286: PPUSH
// if not mc_bases then
42287: LD_EXP 99
42291: NOT
42292: IFFALSE 42296
// exit ;
42294: GO 42869
// for i = 1 to mc_bases do
42296: LD_ADDR_VAR 0 2
42300: PUSH
42301: DOUBLE
42302: LD_INT 1
42304: DEC
42305: ST_TO_ADDR
42306: LD_EXP 99
42310: PUSH
42311: FOR_TO
42312: IFFALSE 42860
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42314: LD_ADDR_VAR 0 5
42318: PUSH
42319: LD_EXP 99
42323: PUSH
42324: LD_VAR 0 2
42328: ARRAY
42329: PUSH
42330: LD_EXP 128
42334: PUSH
42335: LD_VAR 0 2
42339: ARRAY
42340: UNION
42341: PPUSH
42342: LD_INT 21
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 1
42354: PUSH
42355: LD_INT 3
42357: PUSH
42358: LD_INT 54
42360: PUSH
42361: EMPTY
42362: LIST
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: LD_INT 24
42373: PUSH
42374: LD_INT 800
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: LIST
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PPUSH
42394: CALL_OW 72
42398: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42399: LD_ADDR_VAR 0 6
42403: PUSH
42404: LD_EXP 99
42408: PUSH
42409: LD_VAR 0 2
42413: ARRAY
42414: PPUSH
42415: LD_INT 21
42417: PUSH
42418: LD_INT 1
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 1
42427: PUSH
42428: LD_INT 3
42430: PUSH
42431: LD_INT 54
42433: PUSH
42434: EMPTY
42435: LIST
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 3
42443: PUSH
42444: LD_INT 24
42446: PUSH
42447: LD_INT 250
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: LIST
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PPUSH
42467: CALL_OW 72
42471: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42472: LD_ADDR_VAR 0 7
42476: PUSH
42477: LD_VAR 0 5
42481: PUSH
42482: LD_VAR 0 6
42486: DIFF
42487: ST_TO_ADDR
// if not need_heal_1 then
42488: LD_VAR 0 6
42492: NOT
42493: IFFALSE 42526
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42495: LD_ADDR_EXP 102
42499: PUSH
42500: LD_EXP 102
42504: PPUSH
42505: LD_VAR 0 2
42509: PUSH
42510: LD_INT 1
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PPUSH
42517: EMPTY
42518: PPUSH
42519: CALL 71199 0 3
42523: ST_TO_ADDR
42524: GO 42596
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42526: LD_ADDR_EXP 102
42530: PUSH
42531: LD_EXP 102
42535: PPUSH
42536: LD_VAR 0 2
42540: PUSH
42541: LD_INT 1
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PPUSH
42548: LD_EXP 102
42552: PUSH
42553: LD_VAR 0 2
42557: ARRAY
42558: PUSH
42559: LD_INT 1
42561: ARRAY
42562: PPUSH
42563: LD_INT 3
42565: PUSH
42566: LD_INT 24
42568: PUSH
42569: LD_INT 1000
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PPUSH
42580: CALL_OW 72
42584: PUSH
42585: LD_VAR 0 6
42589: UNION
42590: PPUSH
42591: CALL 71199 0 3
42595: ST_TO_ADDR
// if not need_heal_2 then
42596: LD_VAR 0 7
42600: NOT
42601: IFFALSE 42634
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42603: LD_ADDR_EXP 102
42607: PUSH
42608: LD_EXP 102
42612: PPUSH
42613: LD_VAR 0 2
42617: PUSH
42618: LD_INT 2
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PPUSH
42625: EMPTY
42626: PPUSH
42627: CALL 71199 0 3
42631: ST_TO_ADDR
42632: GO 42666
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42634: LD_ADDR_EXP 102
42638: PUSH
42639: LD_EXP 102
42643: PPUSH
42644: LD_VAR 0 2
42648: PUSH
42649: LD_INT 2
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PPUSH
42656: LD_VAR 0 7
42660: PPUSH
42661: CALL 71199 0 3
42665: ST_TO_ADDR
// if need_heal_2 then
42666: LD_VAR 0 7
42670: IFFALSE 42842
// for j in need_heal_2 do
42672: LD_ADDR_VAR 0 3
42676: PUSH
42677: LD_VAR 0 7
42681: PUSH
42682: FOR_IN
42683: IFFALSE 42840
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42685: LD_ADDR_VAR 0 5
42689: PUSH
42690: LD_EXP 99
42694: PUSH
42695: LD_VAR 0 2
42699: ARRAY
42700: PPUSH
42701: LD_INT 2
42703: PUSH
42704: LD_INT 30
42706: PUSH
42707: LD_INT 6
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 30
42716: PUSH
42717: LD_INT 7
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 30
42726: PUSH
42727: LD_INT 8
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 30
42736: PUSH
42737: LD_INT 0
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 30
42746: PUSH
42747: LD_INT 1
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: LD_INT 25
42756: PUSH
42757: LD_INT 4
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: PPUSH
42773: CALL_OW 72
42777: ST_TO_ADDR
// if tmp then
42778: LD_VAR 0 5
42782: IFFALSE 42838
// begin k := NearestUnitToUnit ( tmp , j ) ;
42784: LD_ADDR_VAR 0 4
42788: PUSH
42789: LD_VAR 0 5
42793: PPUSH
42794: LD_VAR 0 3
42798: PPUSH
42799: CALL_OW 74
42803: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42804: LD_VAR 0 3
42808: PPUSH
42809: LD_VAR 0 4
42813: PPUSH
42814: CALL_OW 296
42818: PUSH
42819: LD_INT 7
42821: GREATER
42822: IFFALSE 42838
// ComMoveUnit ( j , k ) ;
42824: LD_VAR 0 3
42828: PPUSH
42829: LD_VAR 0 4
42833: PPUSH
42834: CALL_OW 112
// end ; end ;
42838: GO 42682
42840: POP
42841: POP
// if not need_heal_1 and not need_heal_2 then
42842: LD_VAR 0 6
42846: NOT
42847: PUSH
42848: LD_VAR 0 7
42852: NOT
42853: AND
42854: IFFALSE 42858
// continue ;
42856: GO 42311
// end ;
42858: GO 42311
42860: POP
42861: POP
// RaiseSailEvent ( 102 ) ;
42862: LD_INT 102
42864: PPUSH
42865: CALL_OW 427
// end ;
42869: LD_VAR 0 1
42873: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
42874: LD_INT 0
42876: PPUSH
42877: PPUSH
42878: PPUSH
42879: PPUSH
42880: PPUSH
42881: PPUSH
// if not mc_bases then
42882: LD_EXP 99
42886: NOT
42887: IFFALSE 42891
// exit ;
42889: GO 43601
// for i = 1 to mc_bases do
42891: LD_ADDR_VAR 0 2
42895: PUSH
42896: DOUBLE
42897: LD_INT 1
42899: DEC
42900: ST_TO_ADDR
42901: LD_EXP 99
42905: PUSH
42906: FOR_TO
42907: IFFALSE 43599
// begin if not mc_building_need_repair [ i ] then
42909: LD_EXP 100
42913: PUSH
42914: LD_VAR 0 2
42918: ARRAY
42919: NOT
42920: IFFALSE 43094
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
42922: LD_ADDR_VAR 0 6
42926: PUSH
42927: LD_EXP 118
42931: PUSH
42932: LD_VAR 0 2
42936: ARRAY
42937: PPUSH
42938: LD_INT 3
42940: PUSH
42941: LD_INT 24
42943: PUSH
42944: LD_INT 1000
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: LD_INT 34
42960: PUSH
42961: LD_INT 13
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 34
42970: PUSH
42971: LD_INT 52
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: LIST
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PPUSH
42987: CALL_OW 72
42991: ST_TO_ADDR
// if cranes then
42992: LD_VAR 0 6
42996: IFFALSE 43058
// for j in cranes do
42998: LD_ADDR_VAR 0 3
43002: PUSH
43003: LD_VAR 0 6
43007: PUSH
43008: FOR_IN
43009: IFFALSE 43056
// if not IsInArea ( j , mc_parking [ i ] ) then
43011: LD_VAR 0 3
43015: PPUSH
43016: LD_EXP 123
43020: PUSH
43021: LD_VAR 0 2
43025: ARRAY
43026: PPUSH
43027: CALL_OW 308
43031: NOT
43032: IFFALSE 43054
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43034: LD_VAR 0 3
43038: PPUSH
43039: LD_EXP 123
43043: PUSH
43044: LD_VAR 0 2
43048: ARRAY
43049: PPUSH
43050: CALL_OW 113
43054: GO 43008
43056: POP
43057: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43058: LD_ADDR_EXP 101
43062: PUSH
43063: LD_EXP 101
43067: PPUSH
43068: LD_VAR 0 2
43072: PPUSH
43073: EMPTY
43074: PPUSH
43075: CALL_OW 1
43079: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43080: LD_VAR 0 2
43084: PPUSH
43085: LD_INT 101
43087: PPUSH
43088: CALL 37986 0 2
// continue ;
43092: GO 42906
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43094: LD_ADDR_EXP 105
43098: PUSH
43099: LD_EXP 105
43103: PPUSH
43104: LD_VAR 0 2
43108: PPUSH
43109: EMPTY
43110: PPUSH
43111: CALL_OW 1
43115: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43116: LD_VAR 0 2
43120: PPUSH
43121: LD_INT 103
43123: PPUSH
43124: CALL 37986 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43128: LD_ADDR_VAR 0 5
43132: PUSH
43133: LD_EXP 99
43137: PUSH
43138: LD_VAR 0 2
43142: ARRAY
43143: PUSH
43144: LD_EXP 128
43148: PUSH
43149: LD_VAR 0 2
43153: ARRAY
43154: UNION
43155: PPUSH
43156: LD_INT 2
43158: PUSH
43159: LD_INT 25
43161: PUSH
43162: LD_INT 2
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PUSH
43169: LD_INT 25
43171: PUSH
43172: LD_INT 16
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: PPUSH
43187: CALL_OW 72
43191: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43192: LD_ADDR_VAR 0 6
43196: PUSH
43197: LD_EXP 118
43201: PUSH
43202: LD_VAR 0 2
43206: ARRAY
43207: PPUSH
43208: LD_INT 2
43210: PUSH
43211: LD_INT 34
43213: PUSH
43214: LD_INT 13
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 34
43223: PUSH
43224: LD_INT 52
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: LIST
43235: PPUSH
43236: CALL_OW 72
43240: ST_TO_ADDR
// if cranes then
43241: LD_VAR 0 6
43245: IFFALSE 43381
// begin for j in cranes do
43247: LD_ADDR_VAR 0 3
43251: PUSH
43252: LD_VAR 0 6
43256: PUSH
43257: FOR_IN
43258: IFFALSE 43379
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43260: LD_VAR 0 3
43264: PPUSH
43265: CALL_OW 256
43269: PUSH
43270: LD_INT 500
43272: GREATEREQUAL
43273: PUSH
43274: LD_VAR 0 3
43278: PPUSH
43279: CALL_OW 314
43283: NOT
43284: AND
43285: IFFALSE 43319
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43287: LD_VAR 0 3
43291: PPUSH
43292: LD_EXP 100
43296: PUSH
43297: LD_VAR 0 2
43301: ARRAY
43302: PPUSH
43303: LD_VAR 0 3
43307: PPUSH
43308: CALL_OW 74
43312: PPUSH
43313: CALL_OW 130
43317: GO 43377
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43319: LD_VAR 0 3
43323: PPUSH
43324: CALL_OW 256
43328: PUSH
43329: LD_INT 500
43331: LESS
43332: PUSH
43333: LD_VAR 0 3
43337: PPUSH
43338: LD_EXP 123
43342: PUSH
43343: LD_VAR 0 2
43347: ARRAY
43348: PPUSH
43349: CALL_OW 308
43353: NOT
43354: AND
43355: IFFALSE 43377
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43357: LD_VAR 0 3
43361: PPUSH
43362: LD_EXP 123
43366: PUSH
43367: LD_VAR 0 2
43371: ARRAY
43372: PPUSH
43373: CALL_OW 113
43377: GO 43257
43379: POP
43380: POP
// end ; if not tmp then
43381: LD_VAR 0 5
43385: NOT
43386: IFFALSE 43390
// continue ;
43388: GO 42906
// for j in tmp do
43390: LD_ADDR_VAR 0 3
43394: PUSH
43395: LD_VAR 0 5
43399: PUSH
43400: FOR_IN
43401: IFFALSE 43595
// begin if mc_need_heal [ i ] then
43403: LD_EXP 102
43407: PUSH
43408: LD_VAR 0 2
43412: ARRAY
43413: IFFALSE 43461
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43415: LD_VAR 0 3
43419: PUSH
43420: LD_EXP 102
43424: PUSH
43425: LD_VAR 0 2
43429: ARRAY
43430: PUSH
43431: LD_INT 1
43433: ARRAY
43434: IN
43435: PUSH
43436: LD_VAR 0 3
43440: PUSH
43441: LD_EXP 102
43445: PUSH
43446: LD_VAR 0 2
43450: ARRAY
43451: PUSH
43452: LD_INT 2
43454: ARRAY
43455: IN
43456: OR
43457: IFFALSE 43461
// continue ;
43459: GO 43400
// if IsInUnit ( j ) then
43461: LD_VAR 0 3
43465: PPUSH
43466: CALL_OW 310
43470: IFFALSE 43481
// ComExitBuilding ( j ) ;
43472: LD_VAR 0 3
43476: PPUSH
43477: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43481: LD_VAR 0 3
43485: PUSH
43486: LD_EXP 101
43490: PUSH
43491: LD_VAR 0 2
43495: ARRAY
43496: IN
43497: NOT
43498: IFFALSE 43556
// begin SetTag ( j , 101 ) ;
43500: LD_VAR 0 3
43504: PPUSH
43505: LD_INT 101
43507: PPUSH
43508: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43512: LD_ADDR_EXP 101
43516: PUSH
43517: LD_EXP 101
43521: PPUSH
43522: LD_VAR 0 2
43526: PUSH
43527: LD_EXP 101
43531: PUSH
43532: LD_VAR 0 2
43536: ARRAY
43537: PUSH
43538: LD_INT 1
43540: PLUS
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PPUSH
43546: LD_VAR 0 3
43550: PPUSH
43551: CALL 71199 0 3
43555: ST_TO_ADDR
// end ; wait ( 1 ) ;
43556: LD_INT 1
43558: PPUSH
43559: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43563: LD_VAR 0 3
43567: PPUSH
43568: LD_EXP 100
43572: PUSH
43573: LD_VAR 0 2
43577: ARRAY
43578: PPUSH
43579: LD_VAR 0 3
43583: PPUSH
43584: CALL_OW 74
43588: PPUSH
43589: CALL_OW 130
// end ;
43593: GO 43400
43595: POP
43596: POP
// end ;
43597: GO 42906
43599: POP
43600: POP
// end ;
43601: LD_VAR 0 1
43605: RET
// export function MC_Heal ; var i , j , tmp ; begin
43606: LD_INT 0
43608: PPUSH
43609: PPUSH
43610: PPUSH
43611: PPUSH
// if not mc_bases then
43612: LD_EXP 99
43616: NOT
43617: IFFALSE 43621
// exit ;
43619: GO 44023
// for i = 1 to mc_bases do
43621: LD_ADDR_VAR 0 2
43625: PUSH
43626: DOUBLE
43627: LD_INT 1
43629: DEC
43630: ST_TO_ADDR
43631: LD_EXP 99
43635: PUSH
43636: FOR_TO
43637: IFFALSE 44021
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43639: LD_EXP 102
43643: PUSH
43644: LD_VAR 0 2
43648: ARRAY
43649: PUSH
43650: LD_INT 1
43652: ARRAY
43653: NOT
43654: PUSH
43655: LD_EXP 102
43659: PUSH
43660: LD_VAR 0 2
43664: ARRAY
43665: PUSH
43666: LD_INT 2
43668: ARRAY
43669: NOT
43670: AND
43671: IFFALSE 43709
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43673: LD_ADDR_EXP 103
43677: PUSH
43678: LD_EXP 103
43682: PPUSH
43683: LD_VAR 0 2
43687: PPUSH
43688: EMPTY
43689: PPUSH
43690: CALL_OW 1
43694: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43695: LD_VAR 0 2
43699: PPUSH
43700: LD_INT 102
43702: PPUSH
43703: CALL 37986 0 2
// continue ;
43707: GO 43636
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43709: LD_ADDR_VAR 0 4
43713: PUSH
43714: LD_EXP 99
43718: PUSH
43719: LD_VAR 0 2
43723: ARRAY
43724: PPUSH
43725: LD_INT 25
43727: PUSH
43728: LD_INT 4
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PPUSH
43735: CALL_OW 72
43739: ST_TO_ADDR
// if not tmp then
43740: LD_VAR 0 4
43744: NOT
43745: IFFALSE 43749
// continue ;
43747: GO 43636
// if mc_taming [ i ] then
43749: LD_EXP 130
43753: PUSH
43754: LD_VAR 0 2
43758: ARRAY
43759: IFFALSE 43783
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43761: LD_ADDR_EXP 130
43765: PUSH
43766: LD_EXP 130
43770: PPUSH
43771: LD_VAR 0 2
43775: PPUSH
43776: EMPTY
43777: PPUSH
43778: CALL_OW 1
43782: ST_TO_ADDR
// for j in tmp do
43783: LD_ADDR_VAR 0 3
43787: PUSH
43788: LD_VAR 0 4
43792: PUSH
43793: FOR_IN
43794: IFFALSE 44017
// begin if IsInUnit ( j ) then
43796: LD_VAR 0 3
43800: PPUSH
43801: CALL_OW 310
43805: IFFALSE 43816
// ComExitBuilding ( j ) ;
43807: LD_VAR 0 3
43811: PPUSH
43812: CALL_OW 122
// if not j in mc_healers [ i ] then
43816: LD_VAR 0 3
43820: PUSH
43821: LD_EXP 103
43825: PUSH
43826: LD_VAR 0 2
43830: ARRAY
43831: IN
43832: NOT
43833: IFFALSE 43879
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43835: LD_ADDR_EXP 103
43839: PUSH
43840: LD_EXP 103
43844: PPUSH
43845: LD_VAR 0 2
43849: PUSH
43850: LD_EXP 103
43854: PUSH
43855: LD_VAR 0 2
43859: ARRAY
43860: PUSH
43861: LD_INT 1
43863: PLUS
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PPUSH
43869: LD_VAR 0 3
43873: PPUSH
43874: CALL 71199 0 3
43878: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43879: LD_VAR 0 3
43883: PPUSH
43884: CALL_OW 110
43888: PUSH
43889: LD_INT 102
43891: NONEQUAL
43892: IFFALSE 43906
// SetTag ( j , 102 ) ;
43894: LD_VAR 0 3
43898: PPUSH
43899: LD_INT 102
43901: PPUSH
43902: CALL_OW 109
// Wait ( 3 ) ;
43906: LD_INT 3
43908: PPUSH
43909: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43913: LD_EXP 102
43917: PUSH
43918: LD_VAR 0 2
43922: ARRAY
43923: PUSH
43924: LD_INT 1
43926: ARRAY
43927: IFFALSE 43959
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43929: LD_VAR 0 3
43933: PPUSH
43934: LD_EXP 102
43938: PUSH
43939: LD_VAR 0 2
43943: ARRAY
43944: PUSH
43945: LD_INT 1
43947: ARRAY
43948: PUSH
43949: LD_INT 1
43951: ARRAY
43952: PPUSH
43953: CALL_OW 128
43957: GO 44015
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43959: LD_VAR 0 3
43963: PPUSH
43964: CALL_OW 314
43968: NOT
43969: PUSH
43970: LD_EXP 102
43974: PUSH
43975: LD_VAR 0 2
43979: ARRAY
43980: PUSH
43981: LD_INT 2
43983: ARRAY
43984: AND
43985: IFFALSE 44015
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43987: LD_VAR 0 3
43991: PPUSH
43992: LD_EXP 102
43996: PUSH
43997: LD_VAR 0 2
44001: ARRAY
44002: PUSH
44003: LD_INT 2
44005: ARRAY
44006: PUSH
44007: LD_INT 1
44009: ARRAY
44010: PPUSH
44011: CALL_OW 128
// end ;
44015: GO 43793
44017: POP
44018: POP
// end ;
44019: GO 43636
44021: POP
44022: POP
// end ;
44023: LD_VAR 0 1
44027: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44028: LD_INT 0
44030: PPUSH
44031: PPUSH
44032: PPUSH
44033: PPUSH
44034: PPUSH
// if not mc_bases then
44035: LD_EXP 99
44039: NOT
44040: IFFALSE 44044
// exit ;
44042: GO 45187
// for i = 1 to mc_bases do
44044: LD_ADDR_VAR 0 2
44048: PUSH
44049: DOUBLE
44050: LD_INT 1
44052: DEC
44053: ST_TO_ADDR
44054: LD_EXP 99
44058: PUSH
44059: FOR_TO
44060: IFFALSE 45185
// begin if mc_scan [ i ] then
44062: LD_EXP 122
44066: PUSH
44067: LD_VAR 0 2
44071: ARRAY
44072: IFFALSE 44076
// continue ;
44074: GO 44059
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44076: LD_EXP 104
44080: PUSH
44081: LD_VAR 0 2
44085: ARRAY
44086: NOT
44087: PUSH
44088: LD_EXP 106
44092: PUSH
44093: LD_VAR 0 2
44097: ARRAY
44098: NOT
44099: AND
44100: PUSH
44101: LD_EXP 105
44105: PUSH
44106: LD_VAR 0 2
44110: ARRAY
44111: AND
44112: IFFALSE 44150
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44114: LD_ADDR_EXP 105
44118: PUSH
44119: LD_EXP 105
44123: PPUSH
44124: LD_VAR 0 2
44128: PPUSH
44129: EMPTY
44130: PPUSH
44131: CALL_OW 1
44135: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44136: LD_VAR 0 2
44140: PPUSH
44141: LD_INT 103
44143: PPUSH
44144: CALL 37986 0 2
// continue ;
44148: GO 44059
// end ; if mc_construct_list [ i ] then
44150: LD_EXP 106
44154: PUSH
44155: LD_VAR 0 2
44159: ARRAY
44160: IFFALSE 44380
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44162: LD_ADDR_VAR 0 4
44166: PUSH
44167: LD_EXP 99
44171: PUSH
44172: LD_VAR 0 2
44176: ARRAY
44177: PPUSH
44178: LD_INT 25
44180: PUSH
44181: LD_INT 2
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PPUSH
44188: CALL_OW 72
44192: PUSH
44193: LD_EXP 101
44197: PUSH
44198: LD_VAR 0 2
44202: ARRAY
44203: DIFF
44204: ST_TO_ADDR
// if not tmp then
44205: LD_VAR 0 4
44209: NOT
44210: IFFALSE 44214
// continue ;
44212: GO 44059
// for j in tmp do
44214: LD_ADDR_VAR 0 3
44218: PUSH
44219: LD_VAR 0 4
44223: PUSH
44224: FOR_IN
44225: IFFALSE 44376
// begin if not mc_builders [ i ] then
44227: LD_EXP 105
44231: PUSH
44232: LD_VAR 0 2
44236: ARRAY
44237: NOT
44238: IFFALSE 44296
// begin SetTag ( j , 103 ) ;
44240: LD_VAR 0 3
44244: PPUSH
44245: LD_INT 103
44247: PPUSH
44248: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44252: LD_ADDR_EXP 105
44256: PUSH
44257: LD_EXP 105
44261: PPUSH
44262: LD_VAR 0 2
44266: PUSH
44267: LD_EXP 105
44271: PUSH
44272: LD_VAR 0 2
44276: ARRAY
44277: PUSH
44278: LD_INT 1
44280: PLUS
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PPUSH
44286: LD_VAR 0 3
44290: PPUSH
44291: CALL 71199 0 3
44295: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44296: LD_VAR 0 3
44300: PPUSH
44301: CALL_OW 310
44305: IFFALSE 44316
// ComExitBuilding ( j ) ;
44307: LD_VAR 0 3
44311: PPUSH
44312: CALL_OW 122
// wait ( 3 ) ;
44316: LD_INT 3
44318: PPUSH
44319: CALL_OW 67
// if not mc_construct_list [ i ] then
44323: LD_EXP 106
44327: PUSH
44328: LD_VAR 0 2
44332: ARRAY
44333: NOT
44334: IFFALSE 44338
// break ;
44336: GO 44376
// if not HasTask ( j ) then
44338: LD_VAR 0 3
44342: PPUSH
44343: CALL_OW 314
44347: NOT
44348: IFFALSE 44374
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44350: LD_VAR 0 3
44354: PPUSH
44355: LD_EXP 106
44359: PUSH
44360: LD_VAR 0 2
44364: ARRAY
44365: PUSH
44366: LD_INT 1
44368: ARRAY
44369: PPUSH
44370: CALL 74050 0 2
// end ;
44374: GO 44224
44376: POP
44377: POP
// end else
44378: GO 45183
// if mc_build_list [ i ] then
44380: LD_EXP 104
44384: PUSH
44385: LD_VAR 0 2
44389: ARRAY
44390: IFFALSE 45183
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44392: LD_ADDR_VAR 0 5
44396: PUSH
44397: LD_EXP 99
44401: PUSH
44402: LD_VAR 0 2
44406: ARRAY
44407: PPUSH
44408: LD_INT 2
44410: PUSH
44411: LD_INT 30
44413: PUSH
44414: LD_INT 0
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 30
44423: PUSH
44424: LD_INT 1
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: LIST
44435: PPUSH
44436: CALL_OW 72
44440: ST_TO_ADDR
// if depot then
44441: LD_VAR 0 5
44445: IFFALSE 44463
// depot := depot [ 1 ] else
44447: LD_ADDR_VAR 0 5
44451: PUSH
44452: LD_VAR 0 5
44456: PUSH
44457: LD_INT 1
44459: ARRAY
44460: ST_TO_ADDR
44461: GO 44471
// depot := 0 ;
44463: LD_ADDR_VAR 0 5
44467: PUSH
44468: LD_INT 0
44470: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44471: LD_EXP 104
44475: PUSH
44476: LD_VAR 0 2
44480: ARRAY
44481: PUSH
44482: LD_INT 1
44484: ARRAY
44485: PUSH
44486: LD_INT 1
44488: ARRAY
44489: PPUSH
44490: CALL 73880 0 1
44494: PUSH
44495: LD_EXP 99
44499: PUSH
44500: LD_VAR 0 2
44504: ARRAY
44505: PPUSH
44506: LD_INT 2
44508: PUSH
44509: LD_INT 30
44511: PUSH
44512: LD_INT 2
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: LD_INT 30
44521: PUSH
44522: LD_INT 3
44524: PUSH
44525: EMPTY
44526: LIST
44527: LIST
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: LIST
44533: PPUSH
44534: CALL_OW 72
44538: NOT
44539: AND
44540: IFFALSE 44645
// begin for j = 1 to mc_build_list [ i ] do
44542: LD_ADDR_VAR 0 3
44546: PUSH
44547: DOUBLE
44548: LD_INT 1
44550: DEC
44551: ST_TO_ADDR
44552: LD_EXP 104
44556: PUSH
44557: LD_VAR 0 2
44561: ARRAY
44562: PUSH
44563: FOR_TO
44564: IFFALSE 44643
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44566: LD_EXP 104
44570: PUSH
44571: LD_VAR 0 2
44575: ARRAY
44576: PUSH
44577: LD_VAR 0 3
44581: ARRAY
44582: PUSH
44583: LD_INT 1
44585: ARRAY
44586: PUSH
44587: LD_INT 2
44589: EQUAL
44590: IFFALSE 44641
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44592: LD_ADDR_EXP 104
44596: PUSH
44597: LD_EXP 104
44601: PPUSH
44602: LD_VAR 0 2
44606: PPUSH
44607: LD_EXP 104
44611: PUSH
44612: LD_VAR 0 2
44616: ARRAY
44617: PPUSH
44618: LD_VAR 0 3
44622: PPUSH
44623: LD_INT 1
44625: PPUSH
44626: LD_INT 0
44628: PPUSH
44629: CALL 70617 0 4
44633: PPUSH
44634: CALL_OW 1
44638: ST_TO_ADDR
// break ;
44639: GO 44643
// end ;
44641: GO 44563
44643: POP
44644: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44645: LD_EXP 104
44649: PUSH
44650: LD_VAR 0 2
44654: ARRAY
44655: PUSH
44656: LD_INT 1
44658: ARRAY
44659: PUSH
44660: LD_INT 1
44662: ARRAY
44663: PUSH
44664: LD_INT 0
44666: EQUAL
44667: PUSH
44668: LD_VAR 0 5
44672: PUSH
44673: LD_VAR 0 5
44677: PPUSH
44678: LD_EXP 104
44682: PUSH
44683: LD_VAR 0 2
44687: ARRAY
44688: PUSH
44689: LD_INT 1
44691: ARRAY
44692: PUSH
44693: LD_INT 1
44695: ARRAY
44696: PPUSH
44697: LD_EXP 104
44701: PUSH
44702: LD_VAR 0 2
44706: ARRAY
44707: PUSH
44708: LD_INT 1
44710: ARRAY
44711: PUSH
44712: LD_INT 2
44714: ARRAY
44715: PPUSH
44716: LD_EXP 104
44720: PUSH
44721: LD_VAR 0 2
44725: ARRAY
44726: PUSH
44727: LD_INT 1
44729: ARRAY
44730: PUSH
44731: LD_INT 3
44733: ARRAY
44734: PPUSH
44735: LD_EXP 104
44739: PUSH
44740: LD_VAR 0 2
44744: ARRAY
44745: PUSH
44746: LD_INT 1
44748: ARRAY
44749: PUSH
44750: LD_INT 4
44752: ARRAY
44753: PPUSH
44754: CALL 78614 0 5
44758: AND
44759: OR
44760: IFFALSE 45041
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44762: LD_ADDR_VAR 0 4
44766: PUSH
44767: LD_EXP 99
44771: PUSH
44772: LD_VAR 0 2
44776: ARRAY
44777: PPUSH
44778: LD_INT 25
44780: PUSH
44781: LD_INT 2
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PPUSH
44788: CALL_OW 72
44792: PUSH
44793: LD_EXP 101
44797: PUSH
44798: LD_VAR 0 2
44802: ARRAY
44803: DIFF
44804: ST_TO_ADDR
// if not tmp then
44805: LD_VAR 0 4
44809: NOT
44810: IFFALSE 44814
// continue ;
44812: GO 44059
// for j in tmp do
44814: LD_ADDR_VAR 0 3
44818: PUSH
44819: LD_VAR 0 4
44823: PUSH
44824: FOR_IN
44825: IFFALSE 45037
// begin if not mc_builders [ i ] then
44827: LD_EXP 105
44831: PUSH
44832: LD_VAR 0 2
44836: ARRAY
44837: NOT
44838: IFFALSE 44896
// begin SetTag ( j , 103 ) ;
44840: LD_VAR 0 3
44844: PPUSH
44845: LD_INT 103
44847: PPUSH
44848: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44852: LD_ADDR_EXP 105
44856: PUSH
44857: LD_EXP 105
44861: PPUSH
44862: LD_VAR 0 2
44866: PUSH
44867: LD_EXP 105
44871: PUSH
44872: LD_VAR 0 2
44876: ARRAY
44877: PUSH
44878: LD_INT 1
44880: PLUS
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PPUSH
44886: LD_VAR 0 3
44890: PPUSH
44891: CALL 71199 0 3
44895: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44896: LD_VAR 0 3
44900: PPUSH
44901: CALL_OW 310
44905: IFFALSE 44916
// ComExitBuilding ( j ) ;
44907: LD_VAR 0 3
44911: PPUSH
44912: CALL_OW 122
// wait ( 3 ) ;
44916: LD_INT 3
44918: PPUSH
44919: CALL_OW 67
// if not mc_build_list [ i ] then
44923: LD_EXP 104
44927: PUSH
44928: LD_VAR 0 2
44932: ARRAY
44933: NOT
44934: IFFALSE 44938
// break ;
44936: GO 45037
// if not HasTask ( j ) then
44938: LD_VAR 0 3
44942: PPUSH
44943: CALL_OW 314
44947: NOT
44948: IFFALSE 45035
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44950: LD_VAR 0 3
44954: PPUSH
44955: LD_EXP 104
44959: PUSH
44960: LD_VAR 0 2
44964: ARRAY
44965: PUSH
44966: LD_INT 1
44968: ARRAY
44969: PUSH
44970: LD_INT 1
44972: ARRAY
44973: PPUSH
44974: LD_EXP 104
44978: PUSH
44979: LD_VAR 0 2
44983: ARRAY
44984: PUSH
44985: LD_INT 1
44987: ARRAY
44988: PUSH
44989: LD_INT 2
44991: ARRAY
44992: PPUSH
44993: LD_EXP 104
44997: PUSH
44998: LD_VAR 0 2
45002: ARRAY
45003: PUSH
45004: LD_INT 1
45006: ARRAY
45007: PUSH
45008: LD_INT 3
45010: ARRAY
45011: PPUSH
45012: LD_EXP 104
45016: PUSH
45017: LD_VAR 0 2
45021: ARRAY
45022: PUSH
45023: LD_INT 1
45025: ARRAY
45026: PUSH
45027: LD_INT 4
45029: ARRAY
45030: PPUSH
45031: CALL_OW 145
// end ;
45035: GO 44824
45037: POP
45038: POP
// end else
45039: GO 45183
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45041: LD_EXP 99
45045: PUSH
45046: LD_VAR 0 2
45050: ARRAY
45051: PPUSH
45052: LD_EXP 104
45056: PUSH
45057: LD_VAR 0 2
45061: ARRAY
45062: PUSH
45063: LD_INT 1
45065: ARRAY
45066: PUSH
45067: LD_INT 1
45069: ARRAY
45070: PPUSH
45071: LD_EXP 104
45075: PUSH
45076: LD_VAR 0 2
45080: ARRAY
45081: PUSH
45082: LD_INT 1
45084: ARRAY
45085: PUSH
45086: LD_INT 2
45088: ARRAY
45089: PPUSH
45090: LD_EXP 104
45094: PUSH
45095: LD_VAR 0 2
45099: ARRAY
45100: PUSH
45101: LD_INT 1
45103: ARRAY
45104: PUSH
45105: LD_INT 3
45107: ARRAY
45108: PPUSH
45109: LD_EXP 104
45113: PUSH
45114: LD_VAR 0 2
45118: ARRAY
45119: PUSH
45120: LD_INT 1
45122: ARRAY
45123: PUSH
45124: LD_INT 4
45126: ARRAY
45127: PPUSH
45128: CALL 77950 0 5
45132: NOT
45133: IFFALSE 45183
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45135: LD_ADDR_EXP 104
45139: PUSH
45140: LD_EXP 104
45144: PPUSH
45145: LD_VAR 0 2
45149: PPUSH
45150: LD_EXP 104
45154: PUSH
45155: LD_VAR 0 2
45159: ARRAY
45160: PPUSH
45161: LD_INT 1
45163: PPUSH
45164: LD_INT 1
45166: NEG
45167: PPUSH
45168: LD_INT 0
45170: PPUSH
45171: CALL 70617 0 4
45175: PPUSH
45176: CALL_OW 1
45180: ST_TO_ADDR
// continue ;
45181: GO 44059
// end ; end ; end ;
45183: GO 44059
45185: POP
45186: POP
// end ;
45187: LD_VAR 0 1
45191: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45192: LD_INT 0
45194: PPUSH
45195: PPUSH
45196: PPUSH
45197: PPUSH
45198: PPUSH
45199: PPUSH
// if not mc_bases then
45200: LD_EXP 99
45204: NOT
45205: IFFALSE 45209
// exit ;
45207: GO 45636
// for i = 1 to mc_bases do
45209: LD_ADDR_VAR 0 2
45213: PUSH
45214: DOUBLE
45215: LD_INT 1
45217: DEC
45218: ST_TO_ADDR
45219: LD_EXP 99
45223: PUSH
45224: FOR_TO
45225: IFFALSE 45634
// begin tmp := mc_build_upgrade [ i ] ;
45227: LD_ADDR_VAR 0 4
45231: PUSH
45232: LD_EXP 131
45236: PUSH
45237: LD_VAR 0 2
45241: ARRAY
45242: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45243: LD_ADDR_VAR 0 6
45247: PUSH
45248: LD_EXP 132
45252: PUSH
45253: LD_VAR 0 2
45257: ARRAY
45258: PPUSH
45259: LD_INT 2
45261: PUSH
45262: LD_INT 30
45264: PUSH
45265: LD_INT 6
45267: PUSH
45268: EMPTY
45269: LIST
45270: LIST
45271: PUSH
45272: LD_INT 30
45274: PUSH
45275: LD_INT 7
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: LIST
45286: PPUSH
45287: CALL_OW 72
45291: ST_TO_ADDR
// if not tmp and not lab then
45292: LD_VAR 0 4
45296: NOT
45297: PUSH
45298: LD_VAR 0 6
45302: NOT
45303: AND
45304: IFFALSE 45308
// continue ;
45306: GO 45224
// if tmp then
45308: LD_VAR 0 4
45312: IFFALSE 45432
// for j in tmp do
45314: LD_ADDR_VAR 0 3
45318: PUSH
45319: LD_VAR 0 4
45323: PUSH
45324: FOR_IN
45325: IFFALSE 45430
// begin if UpgradeCost ( j ) then
45327: LD_VAR 0 3
45331: PPUSH
45332: CALL 77610 0 1
45336: IFFALSE 45428
// begin ComUpgrade ( j ) ;
45338: LD_VAR 0 3
45342: PPUSH
45343: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45347: LD_ADDR_EXP 131
45351: PUSH
45352: LD_EXP 131
45356: PPUSH
45357: LD_VAR 0 2
45361: PPUSH
45362: LD_EXP 131
45366: PUSH
45367: LD_VAR 0 2
45371: ARRAY
45372: PUSH
45373: LD_VAR 0 3
45377: DIFF
45378: PPUSH
45379: CALL_OW 1
45383: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45384: LD_ADDR_EXP 106
45388: PUSH
45389: LD_EXP 106
45393: PPUSH
45394: LD_VAR 0 2
45398: PUSH
45399: LD_EXP 106
45403: PUSH
45404: LD_VAR 0 2
45408: ARRAY
45409: PUSH
45410: LD_INT 1
45412: PLUS
45413: PUSH
45414: EMPTY
45415: LIST
45416: LIST
45417: PPUSH
45418: LD_VAR 0 3
45422: PPUSH
45423: CALL 71199 0 3
45427: ST_TO_ADDR
// end ; end ;
45428: GO 45324
45430: POP
45431: POP
// if not lab or not mc_lab_upgrade [ i ] then
45432: LD_VAR 0 6
45436: NOT
45437: PUSH
45438: LD_EXP 133
45442: PUSH
45443: LD_VAR 0 2
45447: ARRAY
45448: NOT
45449: OR
45450: IFFALSE 45454
// continue ;
45452: GO 45224
// for j in lab do
45454: LD_ADDR_VAR 0 3
45458: PUSH
45459: LD_VAR 0 6
45463: PUSH
45464: FOR_IN
45465: IFFALSE 45630
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45467: LD_VAR 0 3
45471: PPUSH
45472: CALL_OW 266
45476: PUSH
45477: LD_INT 6
45479: PUSH
45480: LD_INT 7
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: IN
45487: PUSH
45488: LD_VAR 0 3
45492: PPUSH
45493: CALL_OW 461
45497: PUSH
45498: LD_INT 1
45500: NONEQUAL
45501: AND
45502: IFFALSE 45628
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45504: LD_VAR 0 3
45508: PPUSH
45509: LD_EXP 133
45513: PUSH
45514: LD_VAR 0 2
45518: ARRAY
45519: PUSH
45520: LD_INT 1
45522: ARRAY
45523: PPUSH
45524: CALL 77815 0 2
45528: IFFALSE 45628
// begin ComCancel ( j ) ;
45530: LD_VAR 0 3
45534: PPUSH
45535: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45539: LD_VAR 0 3
45543: PPUSH
45544: LD_EXP 133
45548: PUSH
45549: LD_VAR 0 2
45553: ARRAY
45554: PUSH
45555: LD_INT 1
45557: ARRAY
45558: PPUSH
45559: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45563: LD_VAR 0 3
45567: PUSH
45568: LD_EXP 106
45572: PUSH
45573: LD_VAR 0 2
45577: ARRAY
45578: IN
45579: NOT
45580: IFFALSE 45626
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45582: LD_ADDR_EXP 106
45586: PUSH
45587: LD_EXP 106
45591: PPUSH
45592: LD_VAR 0 2
45596: PUSH
45597: LD_EXP 106
45601: PUSH
45602: LD_VAR 0 2
45606: ARRAY
45607: PUSH
45608: LD_INT 1
45610: PLUS
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PPUSH
45616: LD_VAR 0 3
45620: PPUSH
45621: CALL 71199 0 3
45625: ST_TO_ADDR
// break ;
45626: GO 45630
// end ; end ; end ;
45628: GO 45464
45630: POP
45631: POP
// end ;
45632: GO 45224
45634: POP
45635: POP
// end ;
45636: LD_VAR 0 1
45640: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45641: LD_INT 0
45643: PPUSH
45644: PPUSH
45645: PPUSH
45646: PPUSH
45647: PPUSH
45648: PPUSH
45649: PPUSH
45650: PPUSH
45651: PPUSH
// if not mc_bases then
45652: LD_EXP 99
45656: NOT
45657: IFFALSE 45661
// exit ;
45659: GO 46066
// for i = 1 to mc_bases do
45661: LD_ADDR_VAR 0 2
45665: PUSH
45666: DOUBLE
45667: LD_INT 1
45669: DEC
45670: ST_TO_ADDR
45671: LD_EXP 99
45675: PUSH
45676: FOR_TO
45677: IFFALSE 46064
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45679: LD_EXP 107
45683: PUSH
45684: LD_VAR 0 2
45688: ARRAY
45689: NOT
45690: PUSH
45691: LD_EXP 99
45695: PUSH
45696: LD_VAR 0 2
45700: ARRAY
45701: PPUSH
45702: LD_INT 30
45704: PUSH
45705: LD_INT 3
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: PPUSH
45712: CALL_OW 72
45716: NOT
45717: OR
45718: IFFALSE 45722
// continue ;
45720: GO 45676
// busy := false ;
45722: LD_ADDR_VAR 0 8
45726: PUSH
45727: LD_INT 0
45729: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45730: LD_ADDR_VAR 0 4
45734: PUSH
45735: LD_EXP 99
45739: PUSH
45740: LD_VAR 0 2
45744: ARRAY
45745: PPUSH
45746: LD_INT 30
45748: PUSH
45749: LD_INT 3
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PPUSH
45756: CALL_OW 72
45760: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45761: LD_ADDR_VAR 0 6
45765: PUSH
45766: LD_EXP 107
45770: PUSH
45771: LD_VAR 0 2
45775: ARRAY
45776: PPUSH
45777: LD_INT 2
45779: PUSH
45780: LD_INT 30
45782: PUSH
45783: LD_INT 32
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: LD_INT 30
45792: PUSH
45793: LD_INT 33
45795: PUSH
45796: EMPTY
45797: LIST
45798: LIST
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: LIST
45804: PPUSH
45805: CALL_OW 72
45809: ST_TO_ADDR
// if not t then
45810: LD_VAR 0 6
45814: NOT
45815: IFFALSE 45819
// continue ;
45817: GO 45676
// for j in tmp do
45819: LD_ADDR_VAR 0 3
45823: PUSH
45824: LD_VAR 0 4
45828: PUSH
45829: FOR_IN
45830: IFFALSE 45860
// if not BuildingStatus ( j ) = bs_idle then
45832: LD_VAR 0 3
45836: PPUSH
45837: CALL_OW 461
45841: PUSH
45842: LD_INT 2
45844: EQUAL
45845: NOT
45846: IFFALSE 45858
// begin busy := true ;
45848: LD_ADDR_VAR 0 8
45852: PUSH
45853: LD_INT 1
45855: ST_TO_ADDR
// break ;
45856: GO 45860
// end ;
45858: GO 45829
45860: POP
45861: POP
// if busy then
45862: LD_VAR 0 8
45866: IFFALSE 45870
// continue ;
45868: GO 45676
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45870: LD_ADDR_VAR 0 7
45874: PUSH
45875: LD_VAR 0 6
45879: PPUSH
45880: LD_INT 35
45882: PUSH
45883: LD_INT 0
45885: PUSH
45886: EMPTY
45887: LIST
45888: LIST
45889: PPUSH
45890: CALL_OW 72
45894: ST_TO_ADDR
// if tw then
45895: LD_VAR 0 7
45899: IFFALSE 45976
// begin tw := tw [ 1 ] ;
45901: LD_ADDR_VAR 0 7
45905: PUSH
45906: LD_VAR 0 7
45910: PUSH
45911: LD_INT 1
45913: ARRAY
45914: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45915: LD_ADDR_VAR 0 9
45919: PUSH
45920: LD_VAR 0 7
45924: PPUSH
45925: LD_EXP 124
45929: PUSH
45930: LD_VAR 0 2
45934: ARRAY
45935: PPUSH
45936: CALL 76169 0 2
45940: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45941: LD_EXP 138
45945: PUSH
45946: LD_VAR 0 2
45950: ARRAY
45951: IFFALSE 45974
// if not weapon in mc_allowed_tower_weapons [ i ] then
45953: LD_VAR 0 9
45957: PUSH
45958: LD_EXP 138
45962: PUSH
45963: LD_VAR 0 2
45967: ARRAY
45968: IN
45969: NOT
45970: IFFALSE 45974
// continue ;
45972: GO 45676
// end else
45974: GO 46039
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45976: LD_ADDR_VAR 0 5
45980: PUSH
45981: LD_EXP 107
45985: PUSH
45986: LD_VAR 0 2
45990: ARRAY
45991: PPUSH
45992: LD_VAR 0 4
45996: PPUSH
45997: CALL 106370 0 2
46001: ST_TO_ADDR
// if not tmp2 then
46002: LD_VAR 0 5
46006: NOT
46007: IFFALSE 46011
// continue ;
46009: GO 45676
// tw := tmp2 [ 1 ] ;
46011: LD_ADDR_VAR 0 7
46015: PUSH
46016: LD_VAR 0 5
46020: PUSH
46021: LD_INT 1
46023: ARRAY
46024: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46025: LD_ADDR_VAR 0 9
46029: PUSH
46030: LD_VAR 0 5
46034: PUSH
46035: LD_INT 2
46037: ARRAY
46038: ST_TO_ADDR
// end ; if not weapon then
46039: LD_VAR 0 9
46043: NOT
46044: IFFALSE 46048
// continue ;
46046: GO 45676
// ComPlaceWeapon ( tw , weapon ) ;
46048: LD_VAR 0 7
46052: PPUSH
46053: LD_VAR 0 9
46057: PPUSH
46058: CALL_OW 148
// end ;
46062: GO 45676
46064: POP
46065: POP
// end ;
46066: LD_VAR 0 1
46070: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46071: LD_INT 0
46073: PPUSH
46074: PPUSH
46075: PPUSH
46076: PPUSH
46077: PPUSH
46078: PPUSH
// if not mc_bases then
46079: LD_EXP 99
46083: NOT
46084: IFFALSE 46088
// exit ;
46086: GO 47100
// for i = 1 to mc_bases do
46088: LD_ADDR_VAR 0 2
46092: PUSH
46093: DOUBLE
46094: LD_INT 1
46096: DEC
46097: ST_TO_ADDR
46098: LD_EXP 99
46102: PUSH
46103: FOR_TO
46104: IFFALSE 47098
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46106: LD_EXP 112
46110: PUSH
46111: LD_VAR 0 2
46115: ARRAY
46116: NOT
46117: PUSH
46118: LD_EXP 112
46122: PUSH
46123: LD_VAR 0 2
46127: ARRAY
46128: PUSH
46129: LD_EXP 113
46133: PUSH
46134: LD_VAR 0 2
46138: ARRAY
46139: EQUAL
46140: OR
46141: IFFALSE 46145
// continue ;
46143: GO 46103
// if mc_miners [ i ] then
46145: LD_EXP 113
46149: PUSH
46150: LD_VAR 0 2
46154: ARRAY
46155: IFFALSE 46785
// begin k := 1 ;
46157: LD_ADDR_VAR 0 4
46161: PUSH
46162: LD_INT 1
46164: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46165: LD_ADDR_VAR 0 3
46169: PUSH
46170: DOUBLE
46171: LD_EXP 113
46175: PUSH
46176: LD_VAR 0 2
46180: ARRAY
46181: INC
46182: ST_TO_ADDR
46183: LD_INT 1
46185: PUSH
46186: FOR_DOWNTO
46187: IFFALSE 46783
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46189: LD_EXP 113
46193: PUSH
46194: LD_VAR 0 2
46198: ARRAY
46199: PUSH
46200: LD_VAR 0 3
46204: ARRAY
46205: PPUSH
46206: CALL_OW 301
46210: PUSH
46211: LD_EXP 113
46215: PUSH
46216: LD_VAR 0 2
46220: ARRAY
46221: PUSH
46222: LD_VAR 0 3
46226: ARRAY
46227: PPUSH
46228: CALL_OW 257
46232: PUSH
46233: LD_INT 1
46235: NONEQUAL
46236: OR
46237: IFFALSE 46300
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46239: LD_ADDR_VAR 0 5
46243: PUSH
46244: LD_EXP 113
46248: PUSH
46249: LD_VAR 0 2
46253: ARRAY
46254: PUSH
46255: LD_EXP 113
46259: PUSH
46260: LD_VAR 0 2
46264: ARRAY
46265: PUSH
46266: LD_VAR 0 3
46270: ARRAY
46271: DIFF
46272: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46273: LD_ADDR_EXP 113
46277: PUSH
46278: LD_EXP 113
46282: PPUSH
46283: LD_VAR 0 2
46287: PPUSH
46288: LD_VAR 0 5
46292: PPUSH
46293: CALL_OW 1
46297: ST_TO_ADDR
// continue ;
46298: GO 46186
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46300: LD_EXP 113
46304: PUSH
46305: LD_VAR 0 2
46309: ARRAY
46310: PUSH
46311: LD_VAR 0 3
46315: ARRAY
46316: PPUSH
46317: CALL 71135 0 1
46321: PUSH
46322: LD_EXP 113
46326: PUSH
46327: LD_VAR 0 2
46331: ARRAY
46332: PUSH
46333: LD_VAR 0 3
46337: ARRAY
46338: PPUSH
46339: CALL_OW 255
46343: PPUSH
46344: LD_EXP 112
46348: PUSH
46349: LD_VAR 0 2
46353: ARRAY
46354: PUSH
46355: LD_VAR 0 4
46359: ARRAY
46360: PUSH
46361: LD_INT 1
46363: ARRAY
46364: PPUSH
46365: LD_EXP 112
46369: PUSH
46370: LD_VAR 0 2
46374: ARRAY
46375: PUSH
46376: LD_VAR 0 4
46380: ARRAY
46381: PUSH
46382: LD_INT 2
46384: ARRAY
46385: PPUSH
46386: LD_INT 15
46388: PPUSH
46389: CALL 72095 0 4
46393: PUSH
46394: LD_INT 4
46396: ARRAY
46397: PUSH
46398: LD_EXP 113
46402: PUSH
46403: LD_VAR 0 2
46407: ARRAY
46408: PUSH
46409: LD_VAR 0 3
46413: ARRAY
46414: PPUSH
46415: LD_INT 10
46417: PPUSH
46418: CALL 73792 0 2
46422: PUSH
46423: LD_INT 4
46425: ARRAY
46426: OR
46427: AND
46428: IFFALSE 46451
// ComStop ( mc_miners [ i ] [ j ] ) ;
46430: LD_EXP 113
46434: PUSH
46435: LD_VAR 0 2
46439: ARRAY
46440: PUSH
46441: LD_VAR 0 3
46445: ARRAY
46446: PPUSH
46447: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46451: LD_EXP 113
46455: PUSH
46456: LD_VAR 0 2
46460: ARRAY
46461: PUSH
46462: LD_VAR 0 3
46466: ARRAY
46467: PPUSH
46468: CALL_OW 257
46472: PUSH
46473: LD_INT 1
46475: EQUAL
46476: PUSH
46477: LD_EXP 113
46481: PUSH
46482: LD_VAR 0 2
46486: ARRAY
46487: PUSH
46488: LD_VAR 0 3
46492: ARRAY
46493: PPUSH
46494: CALL_OW 459
46498: NOT
46499: AND
46500: PUSH
46501: LD_EXP 113
46505: PUSH
46506: LD_VAR 0 2
46510: ARRAY
46511: PUSH
46512: LD_VAR 0 3
46516: ARRAY
46517: PPUSH
46518: CALL_OW 255
46522: PPUSH
46523: LD_EXP 112
46527: PUSH
46528: LD_VAR 0 2
46532: ARRAY
46533: PUSH
46534: LD_VAR 0 4
46538: ARRAY
46539: PUSH
46540: LD_INT 1
46542: ARRAY
46543: PPUSH
46544: LD_EXP 112
46548: PUSH
46549: LD_VAR 0 2
46553: ARRAY
46554: PUSH
46555: LD_VAR 0 4
46559: ARRAY
46560: PUSH
46561: LD_INT 2
46563: ARRAY
46564: PPUSH
46565: LD_INT 15
46567: PPUSH
46568: CALL 72095 0 4
46572: PUSH
46573: LD_INT 4
46575: ARRAY
46576: PUSH
46577: LD_INT 0
46579: EQUAL
46580: AND
46581: PUSH
46582: LD_EXP 113
46586: PUSH
46587: LD_VAR 0 2
46591: ARRAY
46592: PUSH
46593: LD_VAR 0 3
46597: ARRAY
46598: PPUSH
46599: CALL_OW 314
46603: NOT
46604: AND
46605: IFFALSE 46781
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46607: LD_EXP 113
46611: PUSH
46612: LD_VAR 0 2
46616: ARRAY
46617: PUSH
46618: LD_VAR 0 3
46622: ARRAY
46623: PPUSH
46624: CALL_OW 310
46628: IFFALSE 46651
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46630: LD_EXP 113
46634: PUSH
46635: LD_VAR 0 2
46639: ARRAY
46640: PUSH
46641: LD_VAR 0 3
46645: ARRAY
46646: PPUSH
46647: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46651: LD_EXP 113
46655: PUSH
46656: LD_VAR 0 2
46660: ARRAY
46661: PUSH
46662: LD_VAR 0 3
46666: ARRAY
46667: PPUSH
46668: CALL_OW 314
46672: NOT
46673: IFFALSE 46741
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46675: LD_EXP 113
46679: PUSH
46680: LD_VAR 0 2
46684: ARRAY
46685: PUSH
46686: LD_VAR 0 3
46690: ARRAY
46691: PPUSH
46692: LD_EXP 112
46696: PUSH
46697: LD_VAR 0 2
46701: ARRAY
46702: PUSH
46703: LD_VAR 0 4
46707: ARRAY
46708: PUSH
46709: LD_INT 1
46711: ARRAY
46712: PPUSH
46713: LD_EXP 112
46717: PUSH
46718: LD_VAR 0 2
46722: ARRAY
46723: PUSH
46724: LD_VAR 0 4
46728: ARRAY
46729: PUSH
46730: LD_INT 2
46732: ARRAY
46733: PPUSH
46734: LD_INT 0
46736: PPUSH
46737: CALL_OW 193
// k := k + 1 ;
46741: LD_ADDR_VAR 0 4
46745: PUSH
46746: LD_VAR 0 4
46750: PUSH
46751: LD_INT 1
46753: PLUS
46754: ST_TO_ADDR
// if k > mc_mines [ i ] then
46755: LD_VAR 0 4
46759: PUSH
46760: LD_EXP 112
46764: PUSH
46765: LD_VAR 0 2
46769: ARRAY
46770: GREATER
46771: IFFALSE 46781
// k := 1 ;
46773: LD_ADDR_VAR 0 4
46777: PUSH
46778: LD_INT 1
46780: ST_TO_ADDR
// end ; end ;
46781: GO 46186
46783: POP
46784: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46785: LD_ADDR_VAR 0 5
46789: PUSH
46790: LD_EXP 99
46794: PUSH
46795: LD_VAR 0 2
46799: ARRAY
46800: PPUSH
46801: LD_INT 2
46803: PUSH
46804: LD_INT 30
46806: PUSH
46807: LD_INT 4
46809: PUSH
46810: EMPTY
46811: LIST
46812: LIST
46813: PUSH
46814: LD_INT 30
46816: PUSH
46817: LD_INT 5
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 30
46826: PUSH
46827: LD_INT 32
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: EMPTY
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: PPUSH
46840: CALL_OW 72
46844: ST_TO_ADDR
// if not tmp then
46845: LD_VAR 0 5
46849: NOT
46850: IFFALSE 46854
// continue ;
46852: GO 46103
// list := [ ] ;
46854: LD_ADDR_VAR 0 6
46858: PUSH
46859: EMPTY
46860: ST_TO_ADDR
// for j in tmp do
46861: LD_ADDR_VAR 0 3
46865: PUSH
46866: LD_VAR 0 5
46870: PUSH
46871: FOR_IN
46872: IFFALSE 46941
// begin for k in UnitsInside ( j ) do
46874: LD_ADDR_VAR 0 4
46878: PUSH
46879: LD_VAR 0 3
46883: PPUSH
46884: CALL_OW 313
46888: PUSH
46889: FOR_IN
46890: IFFALSE 46937
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46892: LD_VAR 0 4
46896: PPUSH
46897: CALL_OW 257
46901: PUSH
46902: LD_INT 1
46904: EQUAL
46905: PUSH
46906: LD_VAR 0 4
46910: PPUSH
46911: CALL_OW 459
46915: NOT
46916: AND
46917: IFFALSE 46935
// list := list ^ k ;
46919: LD_ADDR_VAR 0 6
46923: PUSH
46924: LD_VAR 0 6
46928: PUSH
46929: LD_VAR 0 4
46933: ADD
46934: ST_TO_ADDR
46935: GO 46889
46937: POP
46938: POP
// end ;
46939: GO 46871
46941: POP
46942: POP
// list := list diff mc_miners [ i ] ;
46943: LD_ADDR_VAR 0 6
46947: PUSH
46948: LD_VAR 0 6
46952: PUSH
46953: LD_EXP 113
46957: PUSH
46958: LD_VAR 0 2
46962: ARRAY
46963: DIFF
46964: ST_TO_ADDR
// if not list then
46965: LD_VAR 0 6
46969: NOT
46970: IFFALSE 46974
// continue ;
46972: GO 46103
// k := mc_mines [ i ] - mc_miners [ i ] ;
46974: LD_ADDR_VAR 0 4
46978: PUSH
46979: LD_EXP 112
46983: PUSH
46984: LD_VAR 0 2
46988: ARRAY
46989: PUSH
46990: LD_EXP 113
46994: PUSH
46995: LD_VAR 0 2
46999: ARRAY
47000: MINUS
47001: ST_TO_ADDR
// if k > list then
47002: LD_VAR 0 4
47006: PUSH
47007: LD_VAR 0 6
47011: GREATER
47012: IFFALSE 47024
// k := list ;
47014: LD_ADDR_VAR 0 4
47018: PUSH
47019: LD_VAR 0 6
47023: ST_TO_ADDR
// for j = 1 to k do
47024: LD_ADDR_VAR 0 3
47028: PUSH
47029: DOUBLE
47030: LD_INT 1
47032: DEC
47033: ST_TO_ADDR
47034: LD_VAR 0 4
47038: PUSH
47039: FOR_TO
47040: IFFALSE 47094
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47042: LD_ADDR_EXP 113
47046: PUSH
47047: LD_EXP 113
47051: PPUSH
47052: LD_VAR 0 2
47056: PUSH
47057: LD_EXP 113
47061: PUSH
47062: LD_VAR 0 2
47066: ARRAY
47067: PUSH
47068: LD_INT 1
47070: PLUS
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PPUSH
47076: LD_VAR 0 6
47080: PUSH
47081: LD_VAR 0 3
47085: ARRAY
47086: PPUSH
47087: CALL 71199 0 3
47091: ST_TO_ADDR
47092: GO 47039
47094: POP
47095: POP
// end ;
47096: GO 46103
47098: POP
47099: POP
// end ;
47100: LD_VAR 0 1
47104: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47105: LD_INT 0
47107: PPUSH
47108: PPUSH
47109: PPUSH
47110: PPUSH
47111: PPUSH
47112: PPUSH
47113: PPUSH
47114: PPUSH
47115: PPUSH
47116: PPUSH
// if not mc_bases then
47117: LD_EXP 99
47121: NOT
47122: IFFALSE 47126
// exit ;
47124: GO 48876
// for i = 1 to mc_bases do
47126: LD_ADDR_VAR 0 2
47130: PUSH
47131: DOUBLE
47132: LD_INT 1
47134: DEC
47135: ST_TO_ADDR
47136: LD_EXP 99
47140: PUSH
47141: FOR_TO
47142: IFFALSE 48874
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47144: LD_EXP 99
47148: PUSH
47149: LD_VAR 0 2
47153: ARRAY
47154: NOT
47155: PUSH
47156: LD_EXP 106
47160: PUSH
47161: LD_VAR 0 2
47165: ARRAY
47166: OR
47167: IFFALSE 47171
// continue ;
47169: GO 47141
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47171: LD_EXP 115
47175: PUSH
47176: LD_VAR 0 2
47180: ARRAY
47181: NOT
47182: PUSH
47183: LD_EXP 116
47187: PUSH
47188: LD_VAR 0 2
47192: ARRAY
47193: AND
47194: IFFALSE 47232
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47196: LD_ADDR_EXP 116
47200: PUSH
47201: LD_EXP 116
47205: PPUSH
47206: LD_VAR 0 2
47210: PPUSH
47211: EMPTY
47212: PPUSH
47213: CALL_OW 1
47217: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47218: LD_VAR 0 2
47222: PPUSH
47223: LD_INT 107
47225: PPUSH
47226: CALL 37986 0 2
// continue ;
47230: GO 47141
// end ; target := [ ] ;
47232: LD_ADDR_VAR 0 6
47236: PUSH
47237: EMPTY
47238: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47239: LD_ADDR_VAR 0 3
47243: PUSH
47244: DOUBLE
47245: LD_EXP 115
47249: PUSH
47250: LD_VAR 0 2
47254: ARRAY
47255: INC
47256: ST_TO_ADDR
47257: LD_INT 1
47259: PUSH
47260: FOR_DOWNTO
47261: IFFALSE 47521
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47263: LD_EXP 115
47267: PUSH
47268: LD_VAR 0 2
47272: ARRAY
47273: PUSH
47274: LD_VAR 0 3
47278: ARRAY
47279: PUSH
47280: LD_INT 2
47282: ARRAY
47283: PPUSH
47284: LD_EXP 115
47288: PUSH
47289: LD_VAR 0 2
47293: ARRAY
47294: PUSH
47295: LD_VAR 0 3
47299: ARRAY
47300: PUSH
47301: LD_INT 3
47303: ARRAY
47304: PPUSH
47305: CALL_OW 488
47309: PUSH
47310: LD_EXP 115
47314: PUSH
47315: LD_VAR 0 2
47319: ARRAY
47320: PUSH
47321: LD_VAR 0 3
47325: ARRAY
47326: PUSH
47327: LD_INT 2
47329: ARRAY
47330: PPUSH
47331: LD_EXP 115
47335: PUSH
47336: LD_VAR 0 2
47340: ARRAY
47341: PUSH
47342: LD_VAR 0 3
47346: ARRAY
47347: PUSH
47348: LD_INT 3
47350: ARRAY
47351: PPUSH
47352: CALL_OW 284
47356: PUSH
47357: LD_INT 0
47359: EQUAL
47360: AND
47361: IFFALSE 47416
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47363: LD_ADDR_VAR 0 5
47367: PUSH
47368: LD_EXP 115
47372: PUSH
47373: LD_VAR 0 2
47377: ARRAY
47378: PPUSH
47379: LD_VAR 0 3
47383: PPUSH
47384: CALL_OW 3
47388: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47389: LD_ADDR_EXP 115
47393: PUSH
47394: LD_EXP 115
47398: PPUSH
47399: LD_VAR 0 2
47403: PPUSH
47404: LD_VAR 0 5
47408: PPUSH
47409: CALL_OW 1
47413: ST_TO_ADDR
// continue ;
47414: GO 47260
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47416: LD_EXP 99
47420: PUSH
47421: LD_VAR 0 2
47425: ARRAY
47426: PUSH
47427: LD_INT 1
47429: ARRAY
47430: PPUSH
47431: CALL_OW 255
47435: PPUSH
47436: LD_EXP 115
47440: PUSH
47441: LD_VAR 0 2
47445: ARRAY
47446: PUSH
47447: LD_VAR 0 3
47451: ARRAY
47452: PUSH
47453: LD_INT 2
47455: ARRAY
47456: PPUSH
47457: LD_EXP 115
47461: PUSH
47462: LD_VAR 0 2
47466: ARRAY
47467: PUSH
47468: LD_VAR 0 3
47472: ARRAY
47473: PUSH
47474: LD_INT 3
47476: ARRAY
47477: PPUSH
47478: LD_INT 30
47480: PPUSH
47481: CALL 72095 0 4
47485: PUSH
47486: LD_INT 4
47488: ARRAY
47489: PUSH
47490: LD_INT 0
47492: EQUAL
47493: IFFALSE 47519
// begin target := mc_crates [ i ] [ j ] ;
47495: LD_ADDR_VAR 0 6
47499: PUSH
47500: LD_EXP 115
47504: PUSH
47505: LD_VAR 0 2
47509: ARRAY
47510: PUSH
47511: LD_VAR 0 3
47515: ARRAY
47516: ST_TO_ADDR
// break ;
47517: GO 47521
// end ; end ;
47519: GO 47260
47521: POP
47522: POP
// if not target then
47523: LD_VAR 0 6
47527: NOT
47528: IFFALSE 47532
// continue ;
47530: GO 47141
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47532: LD_ADDR_VAR 0 7
47536: PUSH
47537: LD_EXP 118
47541: PUSH
47542: LD_VAR 0 2
47546: ARRAY
47547: PPUSH
47548: LD_INT 2
47550: PUSH
47551: LD_INT 3
47553: PUSH
47554: LD_INT 58
47556: PUSH
47557: EMPTY
47558: LIST
47559: PUSH
47560: EMPTY
47561: LIST
47562: LIST
47563: PUSH
47564: LD_INT 61
47566: PUSH
47567: EMPTY
47568: LIST
47569: PUSH
47570: LD_INT 33
47572: PUSH
47573: LD_INT 5
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 33
47582: PUSH
47583: LD_INT 3
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: PUSH
47597: LD_INT 2
47599: PUSH
47600: LD_INT 34
47602: PUSH
47603: LD_INT 32
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PUSH
47610: LD_INT 34
47612: PUSH
47613: LD_INT 51
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: PUSH
47620: LD_INT 34
47622: PUSH
47623: LD_INT 12
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PPUSH
47640: CALL_OW 72
47644: ST_TO_ADDR
// if not cargo then
47645: LD_VAR 0 7
47649: NOT
47650: IFFALSE 48293
// begin if mc_crates_collector [ i ] < 5 then
47652: LD_EXP 116
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: PUSH
47663: LD_INT 5
47665: LESS
47666: IFFALSE 48032
// begin if mc_ape [ i ] then
47668: LD_EXP 128
47672: PUSH
47673: LD_VAR 0 2
47677: ARRAY
47678: IFFALSE 47725
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47680: LD_ADDR_VAR 0 5
47684: PUSH
47685: LD_EXP 128
47689: PUSH
47690: LD_VAR 0 2
47694: ARRAY
47695: PPUSH
47696: LD_INT 25
47698: PUSH
47699: LD_INT 16
47701: PUSH
47702: EMPTY
47703: LIST
47704: LIST
47705: PUSH
47706: LD_INT 24
47708: PUSH
47709: LD_INT 750
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PPUSH
47720: CALL_OW 72
47724: ST_TO_ADDR
// if not tmp then
47725: LD_VAR 0 5
47729: NOT
47730: IFFALSE 47777
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47732: LD_ADDR_VAR 0 5
47736: PUSH
47737: LD_EXP 99
47741: PUSH
47742: LD_VAR 0 2
47746: ARRAY
47747: PPUSH
47748: LD_INT 25
47750: PUSH
47751: LD_INT 2
47753: PUSH
47754: EMPTY
47755: LIST
47756: LIST
47757: PUSH
47758: LD_INT 24
47760: PUSH
47761: LD_INT 750
47763: PUSH
47764: EMPTY
47765: LIST
47766: LIST
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: PPUSH
47772: CALL_OW 72
47776: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47777: LD_EXP 128
47781: PUSH
47782: LD_VAR 0 2
47786: ARRAY
47787: PUSH
47788: LD_EXP 99
47792: PUSH
47793: LD_VAR 0 2
47797: ARRAY
47798: PPUSH
47799: LD_INT 25
47801: PUSH
47802: LD_INT 2
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PUSH
47809: LD_INT 24
47811: PUSH
47812: LD_INT 750
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PPUSH
47823: CALL_OW 72
47827: AND
47828: PUSH
47829: LD_VAR 0 5
47833: PUSH
47834: LD_INT 5
47836: LESS
47837: AND
47838: IFFALSE 47920
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47840: LD_ADDR_VAR 0 3
47844: PUSH
47845: LD_EXP 99
47849: PUSH
47850: LD_VAR 0 2
47854: ARRAY
47855: PPUSH
47856: LD_INT 25
47858: PUSH
47859: LD_INT 2
47861: PUSH
47862: EMPTY
47863: LIST
47864: LIST
47865: PUSH
47866: LD_INT 24
47868: PUSH
47869: LD_INT 750
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PPUSH
47880: CALL_OW 72
47884: PUSH
47885: FOR_IN
47886: IFFALSE 47918
// begin tmp := tmp union j ;
47888: LD_ADDR_VAR 0 5
47892: PUSH
47893: LD_VAR 0 5
47897: PUSH
47898: LD_VAR 0 3
47902: UNION
47903: ST_TO_ADDR
// if tmp >= 5 then
47904: LD_VAR 0 5
47908: PUSH
47909: LD_INT 5
47911: GREATEREQUAL
47912: IFFALSE 47916
// break ;
47914: GO 47918
// end ;
47916: GO 47885
47918: POP
47919: POP
// end ; if not tmp then
47920: LD_VAR 0 5
47924: NOT
47925: IFFALSE 47929
// continue ;
47927: GO 47141
// for j in tmp do
47929: LD_ADDR_VAR 0 3
47933: PUSH
47934: LD_VAR 0 5
47938: PUSH
47939: FOR_IN
47940: IFFALSE 48030
// if not GetTag ( j ) then
47942: LD_VAR 0 3
47946: PPUSH
47947: CALL_OW 110
47951: NOT
47952: IFFALSE 48028
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47954: LD_ADDR_EXP 116
47958: PUSH
47959: LD_EXP 116
47963: PPUSH
47964: LD_VAR 0 2
47968: PUSH
47969: LD_EXP 116
47973: PUSH
47974: LD_VAR 0 2
47978: ARRAY
47979: PUSH
47980: LD_INT 1
47982: PLUS
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PPUSH
47988: LD_VAR 0 3
47992: PPUSH
47993: CALL 71199 0 3
47997: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47998: LD_VAR 0 3
48002: PPUSH
48003: LD_INT 107
48005: PPUSH
48006: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48010: LD_EXP 116
48014: PUSH
48015: LD_VAR 0 2
48019: ARRAY
48020: PUSH
48021: LD_INT 5
48023: GREATEREQUAL
48024: IFFALSE 48028
// break ;
48026: GO 48030
// end ;
48028: GO 47939
48030: POP
48031: POP
// end ; if mc_crates_collector [ i ] and target then
48032: LD_EXP 116
48036: PUSH
48037: LD_VAR 0 2
48041: ARRAY
48042: PUSH
48043: LD_VAR 0 6
48047: AND
48048: IFFALSE 48291
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48050: LD_EXP 116
48054: PUSH
48055: LD_VAR 0 2
48059: ARRAY
48060: PUSH
48061: LD_VAR 0 6
48065: PUSH
48066: LD_INT 1
48068: ARRAY
48069: LESS
48070: IFFALSE 48090
// tmp := mc_crates_collector [ i ] else
48072: LD_ADDR_VAR 0 5
48076: PUSH
48077: LD_EXP 116
48081: PUSH
48082: LD_VAR 0 2
48086: ARRAY
48087: ST_TO_ADDR
48088: GO 48104
// tmp := target [ 1 ] ;
48090: LD_ADDR_VAR 0 5
48094: PUSH
48095: LD_VAR 0 6
48099: PUSH
48100: LD_INT 1
48102: ARRAY
48103: ST_TO_ADDR
// k := 0 ;
48104: LD_ADDR_VAR 0 4
48108: PUSH
48109: LD_INT 0
48111: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48112: LD_ADDR_VAR 0 3
48116: PUSH
48117: LD_EXP 116
48121: PUSH
48122: LD_VAR 0 2
48126: ARRAY
48127: PUSH
48128: FOR_IN
48129: IFFALSE 48289
// begin k := k + 1 ;
48131: LD_ADDR_VAR 0 4
48135: PUSH
48136: LD_VAR 0 4
48140: PUSH
48141: LD_INT 1
48143: PLUS
48144: ST_TO_ADDR
// if k > tmp then
48145: LD_VAR 0 4
48149: PUSH
48150: LD_VAR 0 5
48154: GREATER
48155: IFFALSE 48159
// break ;
48157: GO 48289
// if not GetClass ( j ) in [ 2 , 16 ] then
48159: LD_VAR 0 3
48163: PPUSH
48164: CALL_OW 257
48168: PUSH
48169: LD_INT 2
48171: PUSH
48172: LD_INT 16
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: IN
48179: NOT
48180: IFFALSE 48233
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48182: LD_ADDR_EXP 116
48186: PUSH
48187: LD_EXP 116
48191: PPUSH
48192: LD_VAR 0 2
48196: PPUSH
48197: LD_EXP 116
48201: PUSH
48202: LD_VAR 0 2
48206: ARRAY
48207: PUSH
48208: LD_VAR 0 3
48212: DIFF
48213: PPUSH
48214: CALL_OW 1
48218: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48219: LD_VAR 0 3
48223: PPUSH
48224: LD_INT 0
48226: PPUSH
48227: CALL_OW 109
// continue ;
48231: GO 48128
// end ; if IsInUnit ( j ) then
48233: LD_VAR 0 3
48237: PPUSH
48238: CALL_OW 310
48242: IFFALSE 48253
// ComExitBuilding ( j ) ;
48244: LD_VAR 0 3
48248: PPUSH
48249: CALL_OW 122
// wait ( 3 ) ;
48253: LD_INT 3
48255: PPUSH
48256: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48260: LD_VAR 0 3
48264: PPUSH
48265: LD_VAR 0 6
48269: PUSH
48270: LD_INT 2
48272: ARRAY
48273: PPUSH
48274: LD_VAR 0 6
48278: PUSH
48279: LD_INT 3
48281: ARRAY
48282: PPUSH
48283: CALL_OW 117
// end ;
48287: GO 48128
48289: POP
48290: POP
// end ; end else
48291: GO 48872
// begin for j in cargo do
48293: LD_ADDR_VAR 0 3
48297: PUSH
48298: LD_VAR 0 7
48302: PUSH
48303: FOR_IN
48304: IFFALSE 48870
// begin if GetTag ( j ) <> 0 then
48306: LD_VAR 0 3
48310: PPUSH
48311: CALL_OW 110
48315: PUSH
48316: LD_INT 0
48318: NONEQUAL
48319: IFFALSE 48323
// continue ;
48321: GO 48303
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48323: LD_VAR 0 3
48327: PPUSH
48328: CALL_OW 256
48332: PUSH
48333: LD_INT 1000
48335: LESS
48336: PUSH
48337: LD_VAR 0 3
48341: PPUSH
48342: LD_EXP 123
48346: PUSH
48347: LD_VAR 0 2
48351: ARRAY
48352: PPUSH
48353: CALL_OW 308
48357: NOT
48358: AND
48359: IFFALSE 48381
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48361: LD_VAR 0 3
48365: PPUSH
48366: LD_EXP 123
48370: PUSH
48371: LD_VAR 0 2
48375: ARRAY
48376: PPUSH
48377: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48381: LD_VAR 0 3
48385: PPUSH
48386: CALL_OW 256
48390: PUSH
48391: LD_INT 1000
48393: LESS
48394: PUSH
48395: LD_VAR 0 3
48399: PPUSH
48400: LD_EXP 123
48404: PUSH
48405: LD_VAR 0 2
48409: ARRAY
48410: PPUSH
48411: CALL_OW 308
48415: AND
48416: IFFALSE 48420
// continue ;
48418: GO 48303
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48420: LD_VAR 0 3
48424: PPUSH
48425: CALL_OW 262
48429: PUSH
48430: LD_INT 2
48432: EQUAL
48433: PUSH
48434: LD_VAR 0 3
48438: PPUSH
48439: CALL_OW 261
48443: PUSH
48444: LD_INT 15
48446: LESS
48447: AND
48448: IFFALSE 48452
// continue ;
48450: GO 48303
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48452: LD_VAR 0 3
48456: PPUSH
48457: CALL_OW 262
48461: PUSH
48462: LD_INT 1
48464: EQUAL
48465: PUSH
48466: LD_VAR 0 3
48470: PPUSH
48471: CALL_OW 261
48475: PUSH
48476: LD_INT 10
48478: LESS
48479: AND
48480: IFFALSE 48809
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48482: LD_ADDR_VAR 0 8
48486: PUSH
48487: LD_EXP 99
48491: PUSH
48492: LD_VAR 0 2
48496: ARRAY
48497: PPUSH
48498: LD_INT 2
48500: PUSH
48501: LD_INT 30
48503: PUSH
48504: LD_INT 0
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PUSH
48511: LD_INT 30
48513: PUSH
48514: LD_INT 1
48516: PUSH
48517: EMPTY
48518: LIST
48519: LIST
48520: PUSH
48521: EMPTY
48522: LIST
48523: LIST
48524: LIST
48525: PPUSH
48526: CALL_OW 72
48530: ST_TO_ADDR
// if not depot then
48531: LD_VAR 0 8
48535: NOT
48536: IFFALSE 48540
// continue ;
48538: GO 48303
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48540: LD_VAR 0 3
48544: PPUSH
48545: LD_VAR 0 8
48549: PPUSH
48550: LD_VAR 0 3
48554: PPUSH
48555: CALL_OW 74
48559: PPUSH
48560: CALL_OW 296
48564: PUSH
48565: LD_INT 6
48567: LESS
48568: IFFALSE 48584
// SetFuel ( j , 100 ) else
48570: LD_VAR 0 3
48574: PPUSH
48575: LD_INT 100
48577: PPUSH
48578: CALL_OW 240
48582: GO 48809
// if GetFuel ( j ) = 0 then
48584: LD_VAR 0 3
48588: PPUSH
48589: CALL_OW 261
48593: PUSH
48594: LD_INT 0
48596: EQUAL
48597: IFFALSE 48809
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48599: LD_ADDR_EXP 118
48603: PUSH
48604: LD_EXP 118
48608: PPUSH
48609: LD_VAR 0 2
48613: PPUSH
48614: LD_EXP 118
48618: PUSH
48619: LD_VAR 0 2
48623: ARRAY
48624: PUSH
48625: LD_VAR 0 3
48629: DIFF
48630: PPUSH
48631: CALL_OW 1
48635: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48636: LD_VAR 0 3
48640: PPUSH
48641: CALL_OW 263
48645: PUSH
48646: LD_INT 1
48648: EQUAL
48649: IFFALSE 48665
// ComExitVehicle ( IsInUnit ( j ) ) ;
48651: LD_VAR 0 3
48655: PPUSH
48656: CALL_OW 310
48660: PPUSH
48661: CALL_OW 121
// if GetControl ( j ) = control_remote then
48665: LD_VAR 0 3
48669: PPUSH
48670: CALL_OW 263
48674: PUSH
48675: LD_INT 2
48677: EQUAL
48678: IFFALSE 48689
// ComUnlink ( j ) ;
48680: LD_VAR 0 3
48684: PPUSH
48685: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48689: LD_ADDR_VAR 0 9
48693: PUSH
48694: LD_VAR 0 2
48698: PPUSH
48699: LD_INT 3
48701: PPUSH
48702: CALL 58162 0 2
48706: ST_TO_ADDR
// if fac then
48707: LD_VAR 0 9
48711: IFFALSE 48807
// begin for k in fac do
48713: LD_ADDR_VAR 0 4
48717: PUSH
48718: LD_VAR 0 9
48722: PUSH
48723: FOR_IN
48724: IFFALSE 48805
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48726: LD_ADDR_VAR 0 10
48730: PUSH
48731: LD_VAR 0 9
48735: PPUSH
48736: LD_VAR 0 3
48740: PPUSH
48741: CALL_OW 265
48745: PPUSH
48746: LD_VAR 0 3
48750: PPUSH
48751: CALL_OW 262
48755: PPUSH
48756: LD_VAR 0 3
48760: PPUSH
48761: CALL_OW 263
48765: PPUSH
48766: LD_VAR 0 3
48770: PPUSH
48771: CALL_OW 264
48775: PPUSH
48776: CALL 68731 0 5
48780: ST_TO_ADDR
// if components then
48781: LD_VAR 0 10
48785: IFFALSE 48803
// begin MC_InsertProduceList ( i , components ) ;
48787: LD_VAR 0 2
48791: PPUSH
48792: LD_VAR 0 10
48796: PPUSH
48797: CALL 57707 0 2
// break ;
48801: GO 48805
// end ; end ;
48803: GO 48723
48805: POP
48806: POP
// end ; continue ;
48807: GO 48303
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48809: LD_VAR 0 3
48813: PPUSH
48814: LD_INT 1
48816: PPUSH
48817: CALL_OW 289
48821: PUSH
48822: LD_INT 100
48824: LESS
48825: PUSH
48826: LD_VAR 0 3
48830: PPUSH
48831: CALL_OW 314
48835: NOT
48836: AND
48837: IFFALSE 48866
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48839: LD_VAR 0 3
48843: PPUSH
48844: LD_VAR 0 6
48848: PUSH
48849: LD_INT 2
48851: ARRAY
48852: PPUSH
48853: LD_VAR 0 6
48857: PUSH
48858: LD_INT 3
48860: ARRAY
48861: PPUSH
48862: CALL_OW 117
// break ;
48866: GO 48870
// end ;
48868: GO 48303
48870: POP
48871: POP
// end ; end ;
48872: GO 47141
48874: POP
48875: POP
// end ;
48876: LD_VAR 0 1
48880: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48881: LD_INT 0
48883: PPUSH
48884: PPUSH
48885: PPUSH
48886: PPUSH
// if not mc_bases then
48887: LD_EXP 99
48891: NOT
48892: IFFALSE 48896
// exit ;
48894: GO 49057
// for i = 1 to mc_bases do
48896: LD_ADDR_VAR 0 2
48900: PUSH
48901: DOUBLE
48902: LD_INT 1
48904: DEC
48905: ST_TO_ADDR
48906: LD_EXP 99
48910: PUSH
48911: FOR_TO
48912: IFFALSE 49055
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48914: LD_ADDR_VAR 0 4
48918: PUSH
48919: LD_EXP 118
48923: PUSH
48924: LD_VAR 0 2
48928: ARRAY
48929: PUSH
48930: LD_EXP 121
48934: PUSH
48935: LD_VAR 0 2
48939: ARRAY
48940: UNION
48941: PPUSH
48942: LD_INT 33
48944: PUSH
48945: LD_INT 2
48947: PUSH
48948: EMPTY
48949: LIST
48950: LIST
48951: PPUSH
48952: CALL_OW 72
48956: ST_TO_ADDR
// if tmp then
48957: LD_VAR 0 4
48961: IFFALSE 49053
// for j in tmp do
48963: LD_ADDR_VAR 0 3
48967: PUSH
48968: LD_VAR 0 4
48972: PUSH
48973: FOR_IN
48974: IFFALSE 49051
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48976: LD_VAR 0 3
48980: PPUSH
48981: CALL_OW 312
48985: NOT
48986: PUSH
48987: LD_VAR 0 3
48991: PPUSH
48992: CALL_OW 256
48996: PUSH
48997: LD_INT 250
48999: GREATEREQUAL
49000: AND
49001: IFFALSE 49014
// Connect ( j ) else
49003: LD_VAR 0 3
49007: PPUSH
49008: CALL 74132 0 1
49012: GO 49049
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49014: LD_VAR 0 3
49018: PPUSH
49019: CALL_OW 256
49023: PUSH
49024: LD_INT 250
49026: LESS
49027: PUSH
49028: LD_VAR 0 3
49032: PPUSH
49033: CALL_OW 312
49037: AND
49038: IFFALSE 49049
// ComUnlink ( j ) ;
49040: LD_VAR 0 3
49044: PPUSH
49045: CALL_OW 136
49049: GO 48973
49051: POP
49052: POP
// end ;
49053: GO 48911
49055: POP
49056: POP
// end ;
49057: LD_VAR 0 1
49061: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49062: LD_INT 0
49064: PPUSH
49065: PPUSH
49066: PPUSH
49067: PPUSH
49068: PPUSH
// if not mc_bases then
49069: LD_EXP 99
49073: NOT
49074: IFFALSE 49078
// exit ;
49076: GO 49523
// for i = 1 to mc_bases do
49078: LD_ADDR_VAR 0 2
49082: PUSH
49083: DOUBLE
49084: LD_INT 1
49086: DEC
49087: ST_TO_ADDR
49088: LD_EXP 99
49092: PUSH
49093: FOR_TO
49094: IFFALSE 49521
// begin if not mc_produce [ i ] then
49096: LD_EXP 120
49100: PUSH
49101: LD_VAR 0 2
49105: ARRAY
49106: NOT
49107: IFFALSE 49111
// continue ;
49109: GO 49093
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49111: LD_ADDR_VAR 0 5
49115: PUSH
49116: LD_EXP 99
49120: PUSH
49121: LD_VAR 0 2
49125: ARRAY
49126: PPUSH
49127: LD_INT 30
49129: PUSH
49130: LD_INT 3
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PPUSH
49137: CALL_OW 72
49141: ST_TO_ADDR
// if not fac then
49142: LD_VAR 0 5
49146: NOT
49147: IFFALSE 49151
// continue ;
49149: GO 49093
// for j in fac do
49151: LD_ADDR_VAR 0 3
49155: PUSH
49156: LD_VAR 0 5
49160: PUSH
49161: FOR_IN
49162: IFFALSE 49517
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49164: LD_VAR 0 3
49168: PPUSH
49169: CALL_OW 461
49173: PUSH
49174: LD_INT 2
49176: NONEQUAL
49177: PUSH
49178: LD_VAR 0 3
49182: PPUSH
49183: LD_INT 15
49185: PPUSH
49186: CALL 73792 0 2
49190: PUSH
49191: LD_INT 4
49193: ARRAY
49194: OR
49195: IFFALSE 49199
// continue ;
49197: GO 49161
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49199: LD_VAR 0 3
49203: PPUSH
49204: LD_EXP 120
49208: PUSH
49209: LD_VAR 0 2
49213: ARRAY
49214: PUSH
49215: LD_INT 1
49217: ARRAY
49218: PUSH
49219: LD_INT 1
49221: ARRAY
49222: PPUSH
49223: LD_EXP 120
49227: PUSH
49228: LD_VAR 0 2
49232: ARRAY
49233: PUSH
49234: LD_INT 1
49236: ARRAY
49237: PUSH
49238: LD_INT 2
49240: ARRAY
49241: PPUSH
49242: LD_EXP 120
49246: PUSH
49247: LD_VAR 0 2
49251: ARRAY
49252: PUSH
49253: LD_INT 1
49255: ARRAY
49256: PUSH
49257: LD_INT 3
49259: ARRAY
49260: PPUSH
49261: LD_EXP 120
49265: PUSH
49266: LD_VAR 0 2
49270: ARRAY
49271: PUSH
49272: LD_INT 1
49274: ARRAY
49275: PUSH
49276: LD_INT 4
49278: ARRAY
49279: PPUSH
49280: CALL_OW 448
49284: PUSH
49285: LD_VAR 0 3
49289: PPUSH
49290: LD_EXP 120
49294: PUSH
49295: LD_VAR 0 2
49299: ARRAY
49300: PUSH
49301: LD_INT 1
49303: ARRAY
49304: PUSH
49305: LD_INT 1
49307: ARRAY
49308: PUSH
49309: LD_EXP 120
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PUSH
49320: LD_INT 1
49322: ARRAY
49323: PUSH
49324: LD_INT 2
49326: ARRAY
49327: PUSH
49328: LD_EXP 120
49332: PUSH
49333: LD_VAR 0 2
49337: ARRAY
49338: PUSH
49339: LD_INT 1
49341: ARRAY
49342: PUSH
49343: LD_INT 3
49345: ARRAY
49346: PUSH
49347: LD_EXP 120
49351: PUSH
49352: LD_VAR 0 2
49356: ARRAY
49357: PUSH
49358: LD_INT 1
49360: ARRAY
49361: PUSH
49362: LD_INT 4
49364: ARRAY
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: PPUSH
49372: CALL 77463 0 2
49376: AND
49377: IFFALSE 49515
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49379: LD_VAR 0 3
49383: PPUSH
49384: LD_EXP 120
49388: PUSH
49389: LD_VAR 0 2
49393: ARRAY
49394: PUSH
49395: LD_INT 1
49397: ARRAY
49398: PUSH
49399: LD_INT 1
49401: ARRAY
49402: PPUSH
49403: LD_EXP 120
49407: PUSH
49408: LD_VAR 0 2
49412: ARRAY
49413: PUSH
49414: LD_INT 1
49416: ARRAY
49417: PUSH
49418: LD_INT 2
49420: ARRAY
49421: PPUSH
49422: LD_EXP 120
49426: PUSH
49427: LD_VAR 0 2
49431: ARRAY
49432: PUSH
49433: LD_INT 1
49435: ARRAY
49436: PUSH
49437: LD_INT 3
49439: ARRAY
49440: PPUSH
49441: LD_EXP 120
49445: PUSH
49446: LD_VAR 0 2
49450: ARRAY
49451: PUSH
49452: LD_INT 1
49454: ARRAY
49455: PUSH
49456: LD_INT 4
49458: ARRAY
49459: PPUSH
49460: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49464: LD_ADDR_VAR 0 4
49468: PUSH
49469: LD_EXP 120
49473: PUSH
49474: LD_VAR 0 2
49478: ARRAY
49479: PPUSH
49480: LD_INT 1
49482: PPUSH
49483: CALL_OW 3
49487: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49488: LD_ADDR_EXP 120
49492: PUSH
49493: LD_EXP 120
49497: PPUSH
49498: LD_VAR 0 2
49502: PPUSH
49503: LD_VAR 0 4
49507: PPUSH
49508: CALL_OW 1
49512: ST_TO_ADDR
// break ;
49513: GO 49517
// end ; end ;
49515: GO 49161
49517: POP
49518: POP
// end ;
49519: GO 49093
49521: POP
49522: POP
// end ;
49523: LD_VAR 0 1
49527: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49528: LD_INT 0
49530: PPUSH
49531: PPUSH
49532: PPUSH
// if not mc_bases then
49533: LD_EXP 99
49537: NOT
49538: IFFALSE 49542
// exit ;
49540: GO 49631
// for i = 1 to mc_bases do
49542: LD_ADDR_VAR 0 2
49546: PUSH
49547: DOUBLE
49548: LD_INT 1
49550: DEC
49551: ST_TO_ADDR
49552: LD_EXP 99
49556: PUSH
49557: FOR_TO
49558: IFFALSE 49629
// begin if mc_attack [ i ] then
49560: LD_EXP 119
49564: PUSH
49565: LD_VAR 0 2
49569: ARRAY
49570: IFFALSE 49627
// begin tmp := mc_attack [ i ] [ 1 ] ;
49572: LD_ADDR_VAR 0 3
49576: PUSH
49577: LD_EXP 119
49581: PUSH
49582: LD_VAR 0 2
49586: ARRAY
49587: PUSH
49588: LD_INT 1
49590: ARRAY
49591: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49592: LD_ADDR_EXP 119
49596: PUSH
49597: LD_EXP 119
49601: PPUSH
49602: LD_VAR 0 2
49606: PPUSH
49607: EMPTY
49608: PPUSH
49609: CALL_OW 1
49613: ST_TO_ADDR
// Attack ( tmp ) ;
49614: LD_VAR 0 3
49618: PPUSH
49619: CALL 99676 0 1
// exit ;
49623: POP
49624: POP
49625: GO 49631
// end ; end ;
49627: GO 49557
49629: POP
49630: POP
// end ;
49631: LD_VAR 0 1
49635: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49636: LD_INT 0
49638: PPUSH
49639: PPUSH
49640: PPUSH
49641: PPUSH
49642: PPUSH
49643: PPUSH
49644: PPUSH
// if not mc_bases then
49645: LD_EXP 99
49649: NOT
49650: IFFALSE 49654
// exit ;
49652: GO 50236
// for i = 1 to mc_bases do
49654: LD_ADDR_VAR 0 2
49658: PUSH
49659: DOUBLE
49660: LD_INT 1
49662: DEC
49663: ST_TO_ADDR
49664: LD_EXP 99
49668: PUSH
49669: FOR_TO
49670: IFFALSE 50234
// begin if not mc_bases [ i ] then
49672: LD_EXP 99
49676: PUSH
49677: LD_VAR 0 2
49681: ARRAY
49682: NOT
49683: IFFALSE 49687
// continue ;
49685: GO 49669
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49687: LD_ADDR_VAR 0 7
49691: PUSH
49692: LD_EXP 99
49696: PUSH
49697: LD_VAR 0 2
49701: ARRAY
49702: PUSH
49703: LD_INT 1
49705: ARRAY
49706: PPUSH
49707: CALL 68035 0 1
49711: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49712: LD_ADDR_EXP 122
49716: PUSH
49717: LD_EXP 122
49721: PPUSH
49722: LD_VAR 0 2
49726: PPUSH
49727: LD_EXP 99
49731: PUSH
49732: LD_VAR 0 2
49736: ARRAY
49737: PUSH
49738: LD_INT 1
49740: ARRAY
49741: PPUSH
49742: CALL_OW 255
49746: PPUSH
49747: LD_EXP 124
49751: PUSH
49752: LD_VAR 0 2
49756: ARRAY
49757: PPUSH
49758: CALL 65678 0 2
49762: PPUSH
49763: CALL_OW 1
49767: ST_TO_ADDR
// if not mc_scan [ i ] then
49768: LD_EXP 122
49772: PUSH
49773: LD_VAR 0 2
49777: ARRAY
49778: NOT
49779: IFFALSE 49934
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49781: LD_ADDR_VAR 0 4
49785: PUSH
49786: LD_EXP 99
49790: PUSH
49791: LD_VAR 0 2
49795: ARRAY
49796: PPUSH
49797: LD_INT 2
49799: PUSH
49800: LD_INT 25
49802: PUSH
49803: LD_INT 5
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 25
49812: PUSH
49813: LD_INT 8
49815: PUSH
49816: EMPTY
49817: LIST
49818: LIST
49819: PUSH
49820: LD_INT 25
49822: PUSH
49823: LD_INT 9
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: EMPTY
49831: LIST
49832: LIST
49833: LIST
49834: LIST
49835: PPUSH
49836: CALL_OW 72
49840: ST_TO_ADDR
// if not tmp then
49841: LD_VAR 0 4
49845: NOT
49846: IFFALSE 49850
// continue ;
49848: GO 49669
// for j in tmp do
49850: LD_ADDR_VAR 0 3
49854: PUSH
49855: LD_VAR 0 4
49859: PUSH
49860: FOR_IN
49861: IFFALSE 49932
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49863: LD_VAR 0 3
49867: PPUSH
49868: CALL_OW 310
49872: PPUSH
49873: CALL_OW 266
49877: PUSH
49878: LD_INT 5
49880: EQUAL
49881: PUSH
49882: LD_VAR 0 3
49886: PPUSH
49887: CALL_OW 257
49891: PUSH
49892: LD_INT 1
49894: EQUAL
49895: AND
49896: PUSH
49897: LD_VAR 0 3
49901: PPUSH
49902: CALL_OW 459
49906: NOT
49907: AND
49908: PUSH
49909: LD_VAR 0 7
49913: AND
49914: IFFALSE 49930
// ComChangeProfession ( j , class ) ;
49916: LD_VAR 0 3
49920: PPUSH
49921: LD_VAR 0 7
49925: PPUSH
49926: CALL_OW 123
49930: GO 49860
49932: POP
49933: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49934: LD_EXP 122
49938: PUSH
49939: LD_VAR 0 2
49943: ARRAY
49944: PUSH
49945: LD_EXP 121
49949: PUSH
49950: LD_VAR 0 2
49954: ARRAY
49955: NOT
49956: AND
49957: PUSH
49958: LD_EXP 99
49962: PUSH
49963: LD_VAR 0 2
49967: ARRAY
49968: PPUSH
49969: LD_INT 30
49971: PUSH
49972: LD_INT 32
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PPUSH
49979: CALL_OW 72
49983: NOT
49984: AND
49985: PUSH
49986: LD_EXP 99
49990: PUSH
49991: LD_VAR 0 2
49995: ARRAY
49996: PPUSH
49997: LD_INT 2
49999: PUSH
50000: LD_INT 30
50002: PUSH
50003: LD_INT 4
50005: PUSH
50006: EMPTY
50007: LIST
50008: LIST
50009: PUSH
50010: LD_INT 30
50012: PUSH
50013: LD_INT 5
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: LIST
50024: PPUSH
50025: CALL_OW 72
50029: NOT
50030: AND
50031: IFFALSE 50163
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50033: LD_ADDR_VAR 0 4
50037: PUSH
50038: LD_EXP 99
50042: PUSH
50043: LD_VAR 0 2
50047: ARRAY
50048: PPUSH
50049: LD_INT 2
50051: PUSH
50052: LD_INT 25
50054: PUSH
50055: LD_INT 1
50057: PUSH
50058: EMPTY
50059: LIST
50060: LIST
50061: PUSH
50062: LD_INT 25
50064: PUSH
50065: LD_INT 5
50067: PUSH
50068: EMPTY
50069: LIST
50070: LIST
50071: PUSH
50072: LD_INT 25
50074: PUSH
50075: LD_INT 8
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: PUSH
50082: LD_INT 25
50084: PUSH
50085: LD_INT 9
50087: PUSH
50088: EMPTY
50089: LIST
50090: LIST
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: LIST
50096: LIST
50097: LIST
50098: PPUSH
50099: CALL_OW 72
50103: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50104: LD_ADDR_VAR 0 4
50108: PUSH
50109: LD_VAR 0 4
50113: PUSH
50114: LD_VAR 0 4
50118: PPUSH
50119: LD_INT 18
50121: PPUSH
50122: CALL 104459 0 2
50126: DIFF
50127: ST_TO_ADDR
// if tmp then
50128: LD_VAR 0 4
50132: IFFALSE 50163
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50134: LD_VAR 0 2
50138: PPUSH
50139: LD_VAR 0 4
50143: PPUSH
50144: LD_EXP 124
50148: PUSH
50149: LD_VAR 0 2
50153: ARRAY
50154: PPUSH
50155: CALL 65713 0 3
// exit ;
50159: POP
50160: POP
50161: GO 50236
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50163: LD_EXP 122
50167: PUSH
50168: LD_VAR 0 2
50172: ARRAY
50173: PUSH
50174: LD_EXP 121
50178: PUSH
50179: LD_VAR 0 2
50183: ARRAY
50184: AND
50185: IFFALSE 50232
// begin tmp := mc_defender [ i ] ;
50187: LD_ADDR_VAR 0 4
50191: PUSH
50192: LD_EXP 121
50196: PUSH
50197: LD_VAR 0 2
50201: ARRAY
50202: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50203: LD_VAR 0 2
50207: PPUSH
50208: LD_VAR 0 4
50212: PPUSH
50213: LD_EXP 122
50217: PUSH
50218: LD_VAR 0 2
50222: ARRAY
50223: PPUSH
50224: CALL 66274 0 3
// exit ;
50228: POP
50229: POP
50230: GO 50236
// end ; end ;
50232: GO 49669
50234: POP
50235: POP
// end ;
50236: LD_VAR 0 1
50240: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50241: LD_INT 0
50243: PPUSH
50244: PPUSH
50245: PPUSH
50246: PPUSH
50247: PPUSH
50248: PPUSH
50249: PPUSH
50250: PPUSH
50251: PPUSH
50252: PPUSH
50253: PPUSH
// if not mc_bases then
50254: LD_EXP 99
50258: NOT
50259: IFFALSE 50263
// exit ;
50261: GO 51350
// for i = 1 to mc_bases do
50263: LD_ADDR_VAR 0 2
50267: PUSH
50268: DOUBLE
50269: LD_INT 1
50271: DEC
50272: ST_TO_ADDR
50273: LD_EXP 99
50277: PUSH
50278: FOR_TO
50279: IFFALSE 51348
// begin tmp := mc_lab [ i ] ;
50281: LD_ADDR_VAR 0 6
50285: PUSH
50286: LD_EXP 132
50290: PUSH
50291: LD_VAR 0 2
50295: ARRAY
50296: ST_TO_ADDR
// if not tmp then
50297: LD_VAR 0 6
50301: NOT
50302: IFFALSE 50306
// continue ;
50304: GO 50278
// idle_lab := 0 ;
50306: LD_ADDR_VAR 0 11
50310: PUSH
50311: LD_INT 0
50313: ST_TO_ADDR
// for j in tmp do
50314: LD_ADDR_VAR 0 3
50318: PUSH
50319: LD_VAR 0 6
50323: PUSH
50324: FOR_IN
50325: IFFALSE 51344
// begin researching := false ;
50327: LD_ADDR_VAR 0 10
50331: PUSH
50332: LD_INT 0
50334: ST_TO_ADDR
// side := GetSide ( j ) ;
50335: LD_ADDR_VAR 0 4
50339: PUSH
50340: LD_VAR 0 3
50344: PPUSH
50345: CALL_OW 255
50349: ST_TO_ADDR
// if not mc_tech [ side ] then
50350: LD_EXP 126
50354: PUSH
50355: LD_VAR 0 4
50359: ARRAY
50360: NOT
50361: IFFALSE 50365
// continue ;
50363: GO 50324
// if BuildingStatus ( j ) = bs_idle then
50365: LD_VAR 0 3
50369: PPUSH
50370: CALL_OW 461
50374: PUSH
50375: LD_INT 2
50377: EQUAL
50378: IFFALSE 50566
// begin if idle_lab and UnitsInside ( j ) < 6 then
50380: LD_VAR 0 11
50384: PUSH
50385: LD_VAR 0 3
50389: PPUSH
50390: CALL_OW 313
50394: PUSH
50395: LD_INT 6
50397: LESS
50398: AND
50399: IFFALSE 50470
// begin tmp2 := UnitsInside ( idle_lab ) ;
50401: LD_ADDR_VAR 0 9
50405: PUSH
50406: LD_VAR 0 11
50410: PPUSH
50411: CALL_OW 313
50415: ST_TO_ADDR
// if tmp2 then
50416: LD_VAR 0 9
50420: IFFALSE 50462
// for x in tmp2 do
50422: LD_ADDR_VAR 0 7
50426: PUSH
50427: LD_VAR 0 9
50431: PUSH
50432: FOR_IN
50433: IFFALSE 50460
// begin ComExitBuilding ( x ) ;
50435: LD_VAR 0 7
50439: PPUSH
50440: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50444: LD_VAR 0 7
50448: PPUSH
50449: LD_VAR 0 3
50453: PPUSH
50454: CALL_OW 180
// end ;
50458: GO 50432
50460: POP
50461: POP
// idle_lab := 0 ;
50462: LD_ADDR_VAR 0 11
50466: PUSH
50467: LD_INT 0
50469: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50470: LD_ADDR_VAR 0 5
50474: PUSH
50475: LD_EXP 126
50479: PUSH
50480: LD_VAR 0 4
50484: ARRAY
50485: PUSH
50486: FOR_IN
50487: IFFALSE 50547
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50489: LD_VAR 0 3
50493: PPUSH
50494: LD_VAR 0 5
50498: PPUSH
50499: CALL_OW 430
50503: PUSH
50504: LD_VAR 0 4
50508: PPUSH
50509: LD_VAR 0 5
50513: PPUSH
50514: CALL 64783 0 2
50518: AND
50519: IFFALSE 50545
// begin researching := true ;
50521: LD_ADDR_VAR 0 10
50525: PUSH
50526: LD_INT 1
50528: ST_TO_ADDR
// ComResearch ( j , t ) ;
50529: LD_VAR 0 3
50533: PPUSH
50534: LD_VAR 0 5
50538: PPUSH
50539: CALL_OW 124
// break ;
50543: GO 50547
// end ;
50545: GO 50486
50547: POP
50548: POP
// if not researching then
50549: LD_VAR 0 10
50553: NOT
50554: IFFALSE 50566
// idle_lab := j ;
50556: LD_ADDR_VAR 0 11
50560: PUSH
50561: LD_VAR 0 3
50565: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50566: LD_VAR 0 3
50570: PPUSH
50571: CALL_OW 461
50575: PUSH
50576: LD_INT 10
50578: EQUAL
50579: IFFALSE 51167
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50581: LD_EXP 128
50585: PUSH
50586: LD_VAR 0 2
50590: ARRAY
50591: NOT
50592: PUSH
50593: LD_EXP 129
50597: PUSH
50598: LD_VAR 0 2
50602: ARRAY
50603: NOT
50604: AND
50605: PUSH
50606: LD_EXP 126
50610: PUSH
50611: LD_VAR 0 4
50615: ARRAY
50616: PUSH
50617: LD_INT 1
50619: GREATER
50620: AND
50621: IFFALSE 50752
// begin ComCancel ( j ) ;
50623: LD_VAR 0 3
50627: PPUSH
50628: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50632: LD_ADDR_EXP 126
50636: PUSH
50637: LD_EXP 126
50641: PPUSH
50642: LD_VAR 0 4
50646: PPUSH
50647: LD_EXP 126
50651: PUSH
50652: LD_VAR 0 4
50656: ARRAY
50657: PPUSH
50658: LD_EXP 126
50662: PUSH
50663: LD_VAR 0 4
50667: ARRAY
50668: PUSH
50669: LD_INT 1
50671: MINUS
50672: PPUSH
50673: LD_EXP 126
50677: PUSH
50678: LD_VAR 0 4
50682: ARRAY
50683: PPUSH
50684: LD_INT 0
50686: PPUSH
50687: CALL 70617 0 4
50691: PPUSH
50692: CALL_OW 1
50696: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50697: LD_ADDR_EXP 126
50701: PUSH
50702: LD_EXP 126
50706: PPUSH
50707: LD_VAR 0 4
50711: PPUSH
50712: LD_EXP 126
50716: PUSH
50717: LD_VAR 0 4
50721: ARRAY
50722: PPUSH
50723: LD_EXP 126
50727: PUSH
50728: LD_VAR 0 4
50732: ARRAY
50733: PPUSH
50734: LD_INT 1
50736: PPUSH
50737: LD_INT 0
50739: PPUSH
50740: CALL 70617 0 4
50744: PPUSH
50745: CALL_OW 1
50749: ST_TO_ADDR
// continue ;
50750: GO 50324
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50752: LD_EXP 128
50756: PUSH
50757: LD_VAR 0 2
50761: ARRAY
50762: PUSH
50763: LD_EXP 129
50767: PUSH
50768: LD_VAR 0 2
50772: ARRAY
50773: NOT
50774: AND
50775: IFFALSE 50902
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50777: LD_ADDR_EXP 129
50781: PUSH
50782: LD_EXP 129
50786: PPUSH
50787: LD_VAR 0 2
50791: PUSH
50792: LD_EXP 129
50796: PUSH
50797: LD_VAR 0 2
50801: ARRAY
50802: PUSH
50803: LD_INT 1
50805: PLUS
50806: PUSH
50807: EMPTY
50808: LIST
50809: LIST
50810: PPUSH
50811: LD_EXP 128
50815: PUSH
50816: LD_VAR 0 2
50820: ARRAY
50821: PUSH
50822: LD_INT 1
50824: ARRAY
50825: PPUSH
50826: CALL 71199 0 3
50830: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50831: LD_EXP 128
50835: PUSH
50836: LD_VAR 0 2
50840: ARRAY
50841: PUSH
50842: LD_INT 1
50844: ARRAY
50845: PPUSH
50846: LD_INT 112
50848: PPUSH
50849: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50853: LD_ADDR_VAR 0 9
50857: PUSH
50858: LD_EXP 128
50862: PUSH
50863: LD_VAR 0 2
50867: ARRAY
50868: PPUSH
50869: LD_INT 1
50871: PPUSH
50872: CALL_OW 3
50876: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50877: LD_ADDR_EXP 128
50881: PUSH
50882: LD_EXP 128
50886: PPUSH
50887: LD_VAR 0 2
50891: PPUSH
50892: LD_VAR 0 9
50896: PPUSH
50897: CALL_OW 1
50901: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50902: LD_EXP 128
50906: PUSH
50907: LD_VAR 0 2
50911: ARRAY
50912: PUSH
50913: LD_EXP 129
50917: PUSH
50918: LD_VAR 0 2
50922: ARRAY
50923: AND
50924: PUSH
50925: LD_EXP 129
50929: PUSH
50930: LD_VAR 0 2
50934: ARRAY
50935: PUSH
50936: LD_INT 1
50938: ARRAY
50939: PPUSH
50940: CALL_OW 310
50944: NOT
50945: AND
50946: PUSH
50947: LD_VAR 0 3
50951: PPUSH
50952: CALL_OW 313
50956: PUSH
50957: LD_INT 6
50959: EQUAL
50960: AND
50961: IFFALSE 51017
// begin tmp2 := UnitsInside ( j ) ;
50963: LD_ADDR_VAR 0 9
50967: PUSH
50968: LD_VAR 0 3
50972: PPUSH
50973: CALL_OW 313
50977: ST_TO_ADDR
// if tmp2 = 6 then
50978: LD_VAR 0 9
50982: PUSH
50983: LD_INT 6
50985: EQUAL
50986: IFFALSE 51017
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50988: LD_VAR 0 9
50992: PUSH
50993: LD_INT 1
50995: ARRAY
50996: PPUSH
50997: LD_INT 112
50999: PPUSH
51000: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51004: LD_VAR 0 9
51008: PUSH
51009: LD_INT 1
51011: ARRAY
51012: PPUSH
51013: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51017: LD_EXP 129
51021: PUSH
51022: LD_VAR 0 2
51026: ARRAY
51027: PUSH
51028: LD_EXP 129
51032: PUSH
51033: LD_VAR 0 2
51037: ARRAY
51038: PUSH
51039: LD_INT 1
51041: ARRAY
51042: PPUSH
51043: CALL_OW 314
51047: NOT
51048: AND
51049: PUSH
51050: LD_EXP 129
51054: PUSH
51055: LD_VAR 0 2
51059: ARRAY
51060: PUSH
51061: LD_INT 1
51063: ARRAY
51064: PPUSH
51065: CALL_OW 310
51069: NOT
51070: AND
51071: IFFALSE 51097
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51073: LD_EXP 129
51077: PUSH
51078: LD_VAR 0 2
51082: ARRAY
51083: PUSH
51084: LD_INT 1
51086: ARRAY
51087: PPUSH
51088: LD_VAR 0 3
51092: PPUSH
51093: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51097: LD_EXP 129
51101: PUSH
51102: LD_VAR 0 2
51106: ARRAY
51107: PUSH
51108: LD_INT 1
51110: ARRAY
51111: PPUSH
51112: CALL_OW 310
51116: PUSH
51117: LD_EXP 129
51121: PUSH
51122: LD_VAR 0 2
51126: ARRAY
51127: PUSH
51128: LD_INT 1
51130: ARRAY
51131: PPUSH
51132: CALL_OW 310
51136: PPUSH
51137: CALL_OW 461
51141: PUSH
51142: LD_INT 3
51144: NONEQUAL
51145: AND
51146: IFFALSE 51167
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51148: LD_EXP 129
51152: PUSH
51153: LD_VAR 0 2
51157: ARRAY
51158: PUSH
51159: LD_INT 1
51161: ARRAY
51162: PPUSH
51163: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51167: LD_VAR 0 3
51171: PPUSH
51172: CALL_OW 461
51176: PUSH
51177: LD_INT 6
51179: EQUAL
51180: PUSH
51181: LD_VAR 0 6
51185: PUSH
51186: LD_INT 1
51188: GREATER
51189: AND
51190: IFFALSE 51342
// begin sci := [ ] ;
51192: LD_ADDR_VAR 0 8
51196: PUSH
51197: EMPTY
51198: ST_TO_ADDR
// for x in ( tmp diff j ) do
51199: LD_ADDR_VAR 0 7
51203: PUSH
51204: LD_VAR 0 6
51208: PUSH
51209: LD_VAR 0 3
51213: DIFF
51214: PUSH
51215: FOR_IN
51216: IFFALSE 51268
// begin if sci = 6 then
51218: LD_VAR 0 8
51222: PUSH
51223: LD_INT 6
51225: EQUAL
51226: IFFALSE 51230
// break ;
51228: GO 51268
// if BuildingStatus ( x ) = bs_idle then
51230: LD_VAR 0 7
51234: PPUSH
51235: CALL_OW 461
51239: PUSH
51240: LD_INT 2
51242: EQUAL
51243: IFFALSE 51266
// sci := sci ^ UnitsInside ( x ) ;
51245: LD_ADDR_VAR 0 8
51249: PUSH
51250: LD_VAR 0 8
51254: PUSH
51255: LD_VAR 0 7
51259: PPUSH
51260: CALL_OW 313
51264: ADD
51265: ST_TO_ADDR
// end ;
51266: GO 51215
51268: POP
51269: POP
// if not sci then
51270: LD_VAR 0 8
51274: NOT
51275: IFFALSE 51279
// continue ;
51277: GO 50324
// for x in sci do
51279: LD_ADDR_VAR 0 7
51283: PUSH
51284: LD_VAR 0 8
51288: PUSH
51289: FOR_IN
51290: IFFALSE 51340
// if IsInUnit ( x ) and not HasTask ( x ) then
51292: LD_VAR 0 7
51296: PPUSH
51297: CALL_OW 310
51301: PUSH
51302: LD_VAR 0 7
51306: PPUSH
51307: CALL_OW 314
51311: NOT
51312: AND
51313: IFFALSE 51338
// begin ComExitBuilding ( x ) ;
51315: LD_VAR 0 7
51319: PPUSH
51320: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51324: LD_VAR 0 7
51328: PPUSH
51329: LD_VAR 0 3
51333: PPUSH
51334: CALL_OW 180
// end ;
51338: GO 51289
51340: POP
51341: POP
// end ; end ;
51342: GO 50324
51344: POP
51345: POP
// end ;
51346: GO 50278
51348: POP
51349: POP
// end ;
51350: LD_VAR 0 1
51354: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51355: LD_INT 0
51357: PPUSH
51358: PPUSH
// if not mc_bases then
51359: LD_EXP 99
51363: NOT
51364: IFFALSE 51368
// exit ;
51366: GO 51449
// for i = 1 to mc_bases do
51368: LD_ADDR_VAR 0 2
51372: PUSH
51373: DOUBLE
51374: LD_INT 1
51376: DEC
51377: ST_TO_ADDR
51378: LD_EXP 99
51382: PUSH
51383: FOR_TO
51384: IFFALSE 51447
// if mc_mines [ i ] and mc_miners [ i ] then
51386: LD_EXP 112
51390: PUSH
51391: LD_VAR 0 2
51395: ARRAY
51396: PUSH
51397: LD_EXP 113
51401: PUSH
51402: LD_VAR 0 2
51406: ARRAY
51407: AND
51408: IFFALSE 51445
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51410: LD_EXP 113
51414: PUSH
51415: LD_VAR 0 2
51419: ARRAY
51420: PUSH
51421: LD_INT 1
51423: ARRAY
51424: PPUSH
51425: CALL_OW 255
51429: PPUSH
51430: LD_EXP 112
51434: PUSH
51435: LD_VAR 0 2
51439: ARRAY
51440: PPUSH
51441: CALL 68188 0 2
51445: GO 51383
51447: POP
51448: POP
// end ;
51449: LD_VAR 0 1
51453: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51454: LD_INT 0
51456: PPUSH
51457: PPUSH
51458: PPUSH
51459: PPUSH
51460: PPUSH
51461: PPUSH
51462: PPUSH
51463: PPUSH
// if not mc_bases or not mc_parking then
51464: LD_EXP 99
51468: NOT
51469: PUSH
51470: LD_EXP 123
51474: NOT
51475: OR
51476: IFFALSE 51480
// exit ;
51478: GO 52179
// for i = 1 to mc_bases do
51480: LD_ADDR_VAR 0 2
51484: PUSH
51485: DOUBLE
51486: LD_INT 1
51488: DEC
51489: ST_TO_ADDR
51490: LD_EXP 99
51494: PUSH
51495: FOR_TO
51496: IFFALSE 52177
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51498: LD_EXP 99
51502: PUSH
51503: LD_VAR 0 2
51507: ARRAY
51508: NOT
51509: PUSH
51510: LD_EXP 123
51514: PUSH
51515: LD_VAR 0 2
51519: ARRAY
51520: NOT
51521: OR
51522: IFFALSE 51526
// continue ;
51524: GO 51495
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51526: LD_ADDR_VAR 0 5
51530: PUSH
51531: LD_EXP 99
51535: PUSH
51536: LD_VAR 0 2
51540: ARRAY
51541: PUSH
51542: LD_INT 1
51544: ARRAY
51545: PPUSH
51546: CALL_OW 255
51550: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51551: LD_ADDR_VAR 0 6
51555: PUSH
51556: LD_EXP 99
51560: PUSH
51561: LD_VAR 0 2
51565: ARRAY
51566: PPUSH
51567: LD_INT 30
51569: PUSH
51570: LD_INT 3
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: PPUSH
51577: CALL_OW 72
51581: ST_TO_ADDR
// if not fac then
51582: LD_VAR 0 6
51586: NOT
51587: IFFALSE 51638
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51589: LD_ADDR_VAR 0 6
51593: PUSH
51594: LD_EXP 99
51598: PUSH
51599: LD_VAR 0 2
51603: ARRAY
51604: PPUSH
51605: LD_INT 2
51607: PUSH
51608: LD_INT 30
51610: PUSH
51611: LD_INT 0
51613: PUSH
51614: EMPTY
51615: LIST
51616: LIST
51617: PUSH
51618: LD_INT 30
51620: PUSH
51621: LD_INT 1
51623: PUSH
51624: EMPTY
51625: LIST
51626: LIST
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: LIST
51632: PPUSH
51633: CALL_OW 72
51637: ST_TO_ADDR
// if not fac then
51638: LD_VAR 0 6
51642: NOT
51643: IFFALSE 51647
// continue ;
51645: GO 51495
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51647: LD_ADDR_VAR 0 7
51651: PUSH
51652: LD_EXP 123
51656: PUSH
51657: LD_VAR 0 2
51661: ARRAY
51662: PPUSH
51663: LD_INT 22
51665: PUSH
51666: LD_VAR 0 5
51670: PUSH
51671: EMPTY
51672: LIST
51673: LIST
51674: PUSH
51675: LD_INT 21
51677: PUSH
51678: LD_INT 2
51680: PUSH
51681: EMPTY
51682: LIST
51683: LIST
51684: PUSH
51685: LD_INT 3
51687: PUSH
51688: LD_INT 24
51690: PUSH
51691: LD_INT 1000
51693: PUSH
51694: EMPTY
51695: LIST
51696: LIST
51697: PUSH
51698: EMPTY
51699: LIST
51700: LIST
51701: PUSH
51702: EMPTY
51703: LIST
51704: LIST
51705: LIST
51706: PPUSH
51707: CALL_OW 70
51711: ST_TO_ADDR
// for j in fac do
51712: LD_ADDR_VAR 0 3
51716: PUSH
51717: LD_VAR 0 6
51721: PUSH
51722: FOR_IN
51723: IFFALSE 51804
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51725: LD_ADDR_VAR 0 7
51729: PUSH
51730: LD_VAR 0 7
51734: PUSH
51735: LD_INT 22
51737: PUSH
51738: LD_VAR 0 5
51742: PUSH
51743: EMPTY
51744: LIST
51745: LIST
51746: PUSH
51747: LD_INT 91
51749: PUSH
51750: LD_VAR 0 3
51754: PUSH
51755: LD_INT 15
51757: PUSH
51758: EMPTY
51759: LIST
51760: LIST
51761: LIST
51762: PUSH
51763: LD_INT 21
51765: PUSH
51766: LD_INT 2
51768: PUSH
51769: EMPTY
51770: LIST
51771: LIST
51772: PUSH
51773: LD_INT 3
51775: PUSH
51776: LD_INT 24
51778: PUSH
51779: LD_INT 1000
51781: PUSH
51782: EMPTY
51783: LIST
51784: LIST
51785: PUSH
51786: EMPTY
51787: LIST
51788: LIST
51789: PUSH
51790: EMPTY
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: PPUSH
51796: CALL_OW 69
51800: UNION
51801: ST_TO_ADDR
51802: GO 51722
51804: POP
51805: POP
// if not vehs then
51806: LD_VAR 0 7
51810: NOT
51811: IFFALSE 51837
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51813: LD_ADDR_EXP 111
51817: PUSH
51818: LD_EXP 111
51822: PPUSH
51823: LD_VAR 0 2
51827: PPUSH
51828: EMPTY
51829: PPUSH
51830: CALL_OW 1
51834: ST_TO_ADDR
// continue ;
51835: GO 51495
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51837: LD_ADDR_VAR 0 8
51841: PUSH
51842: LD_EXP 99
51846: PUSH
51847: LD_VAR 0 2
51851: ARRAY
51852: PPUSH
51853: LD_INT 30
51855: PUSH
51856: LD_INT 3
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: PPUSH
51863: CALL_OW 72
51867: ST_TO_ADDR
// if tmp then
51868: LD_VAR 0 8
51872: IFFALSE 51975
// begin for j in tmp do
51874: LD_ADDR_VAR 0 3
51878: PUSH
51879: LD_VAR 0 8
51883: PUSH
51884: FOR_IN
51885: IFFALSE 51973
// for k in UnitsInside ( j ) do
51887: LD_ADDR_VAR 0 4
51891: PUSH
51892: LD_VAR 0 3
51896: PPUSH
51897: CALL_OW 313
51901: PUSH
51902: FOR_IN
51903: IFFALSE 51969
// if k then
51905: LD_VAR 0 4
51909: IFFALSE 51967
// if not k in mc_repair_vehicle [ i ] then
51911: LD_VAR 0 4
51915: PUSH
51916: LD_EXP 111
51920: PUSH
51921: LD_VAR 0 2
51925: ARRAY
51926: IN
51927: NOT
51928: IFFALSE 51967
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51930: LD_ADDR_EXP 111
51934: PUSH
51935: LD_EXP 111
51939: PPUSH
51940: LD_VAR 0 2
51944: PPUSH
51945: LD_EXP 111
51949: PUSH
51950: LD_VAR 0 2
51954: ARRAY
51955: PUSH
51956: LD_VAR 0 4
51960: UNION
51961: PPUSH
51962: CALL_OW 1
51966: ST_TO_ADDR
51967: GO 51902
51969: POP
51970: POP
51971: GO 51884
51973: POP
51974: POP
// end ; if not mc_repair_vehicle [ i ] then
51975: LD_EXP 111
51979: PUSH
51980: LD_VAR 0 2
51984: ARRAY
51985: NOT
51986: IFFALSE 51990
// continue ;
51988: GO 51495
// for j in mc_repair_vehicle [ i ] do
51990: LD_ADDR_VAR 0 3
51994: PUSH
51995: LD_EXP 111
51999: PUSH
52000: LD_VAR 0 2
52004: ARRAY
52005: PUSH
52006: FOR_IN
52007: IFFALSE 52173
// begin if GetClass ( j ) <> 3 then
52009: LD_VAR 0 3
52013: PPUSH
52014: CALL_OW 257
52018: PUSH
52019: LD_INT 3
52021: NONEQUAL
52022: IFFALSE 52063
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52024: LD_ADDR_EXP 111
52028: PUSH
52029: LD_EXP 111
52033: PPUSH
52034: LD_VAR 0 2
52038: PPUSH
52039: LD_EXP 111
52043: PUSH
52044: LD_VAR 0 2
52048: ARRAY
52049: PUSH
52050: LD_VAR 0 3
52054: DIFF
52055: PPUSH
52056: CALL_OW 1
52060: ST_TO_ADDR
// continue ;
52061: GO 52006
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52063: LD_VAR 0 3
52067: PPUSH
52068: CALL_OW 311
52072: NOT
52073: PUSH
52074: LD_VAR 0 3
52078: PUSH
52079: LD_EXP 102
52083: PUSH
52084: LD_VAR 0 2
52088: ARRAY
52089: PUSH
52090: LD_INT 1
52092: ARRAY
52093: IN
52094: NOT
52095: AND
52096: PUSH
52097: LD_VAR 0 3
52101: PUSH
52102: LD_EXP 102
52106: PUSH
52107: LD_VAR 0 2
52111: ARRAY
52112: PUSH
52113: LD_INT 2
52115: ARRAY
52116: IN
52117: NOT
52118: AND
52119: IFFALSE 52171
// begin if IsInUnit ( j ) then
52121: LD_VAR 0 3
52125: PPUSH
52126: CALL_OW 310
52130: IFFALSE 52141
// ComExitBuilding ( j ) ;
52132: LD_VAR 0 3
52136: PPUSH
52137: CALL_OW 122
// if not HasTask ( j ) then
52141: LD_VAR 0 3
52145: PPUSH
52146: CALL_OW 314
52150: NOT
52151: IFFALSE 52171
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52153: LD_VAR 0 3
52157: PPUSH
52158: LD_VAR 0 7
52162: PUSH
52163: LD_INT 1
52165: ARRAY
52166: PPUSH
52167: CALL_OW 189
// end ; end ;
52171: GO 52006
52173: POP
52174: POP
// end ;
52175: GO 51495
52177: POP
52178: POP
// end ;
52179: LD_VAR 0 1
52183: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52184: LD_INT 0
52186: PPUSH
52187: PPUSH
52188: PPUSH
52189: PPUSH
52190: PPUSH
52191: PPUSH
52192: PPUSH
52193: PPUSH
52194: PPUSH
52195: PPUSH
52196: PPUSH
// if not mc_bases then
52197: LD_EXP 99
52201: NOT
52202: IFFALSE 52206
// exit ;
52204: GO 53008
// for i = 1 to mc_bases do
52206: LD_ADDR_VAR 0 2
52210: PUSH
52211: DOUBLE
52212: LD_INT 1
52214: DEC
52215: ST_TO_ADDR
52216: LD_EXP 99
52220: PUSH
52221: FOR_TO
52222: IFFALSE 53006
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52224: LD_EXP 127
52228: PUSH
52229: LD_VAR 0 2
52233: ARRAY
52234: NOT
52235: PUSH
52236: LD_EXP 102
52240: PUSH
52241: LD_VAR 0 2
52245: ARRAY
52246: PUSH
52247: LD_INT 1
52249: ARRAY
52250: OR
52251: PUSH
52252: LD_EXP 102
52256: PUSH
52257: LD_VAR 0 2
52261: ARRAY
52262: PUSH
52263: LD_INT 2
52265: ARRAY
52266: OR
52267: PUSH
52268: LD_EXP 125
52272: PUSH
52273: LD_VAR 0 2
52277: ARRAY
52278: PPUSH
52279: LD_INT 1
52281: PPUSH
52282: CALL_OW 325
52286: NOT
52287: OR
52288: PUSH
52289: LD_EXP 122
52293: PUSH
52294: LD_VAR 0 2
52298: ARRAY
52299: OR
52300: IFFALSE 52304
// continue ;
52302: GO 52221
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52304: LD_ADDR_VAR 0 8
52308: PUSH
52309: LD_EXP 99
52313: PUSH
52314: LD_VAR 0 2
52318: ARRAY
52319: PPUSH
52320: LD_INT 25
52322: PUSH
52323: LD_INT 4
52325: PUSH
52326: EMPTY
52327: LIST
52328: LIST
52329: PUSH
52330: LD_INT 50
52332: PUSH
52333: EMPTY
52334: LIST
52335: PUSH
52336: LD_INT 3
52338: PUSH
52339: LD_INT 60
52341: PUSH
52342: EMPTY
52343: LIST
52344: PUSH
52345: EMPTY
52346: LIST
52347: LIST
52348: PUSH
52349: EMPTY
52350: LIST
52351: LIST
52352: LIST
52353: PPUSH
52354: CALL_OW 72
52358: PUSH
52359: LD_EXP 103
52363: PUSH
52364: LD_VAR 0 2
52368: ARRAY
52369: DIFF
52370: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52371: LD_ADDR_VAR 0 9
52375: PUSH
52376: LD_EXP 99
52380: PUSH
52381: LD_VAR 0 2
52385: ARRAY
52386: PPUSH
52387: LD_INT 2
52389: PUSH
52390: LD_INT 30
52392: PUSH
52393: LD_INT 0
52395: PUSH
52396: EMPTY
52397: LIST
52398: LIST
52399: PUSH
52400: LD_INT 30
52402: PUSH
52403: LD_INT 1
52405: PUSH
52406: EMPTY
52407: LIST
52408: LIST
52409: PUSH
52410: EMPTY
52411: LIST
52412: LIST
52413: LIST
52414: PPUSH
52415: CALL_OW 72
52419: ST_TO_ADDR
// if not tmp or not dep then
52420: LD_VAR 0 8
52424: NOT
52425: PUSH
52426: LD_VAR 0 9
52430: NOT
52431: OR
52432: IFFALSE 52436
// continue ;
52434: GO 52221
// side := GetSide ( tmp [ 1 ] ) ;
52436: LD_ADDR_VAR 0 11
52440: PUSH
52441: LD_VAR 0 8
52445: PUSH
52446: LD_INT 1
52448: ARRAY
52449: PPUSH
52450: CALL_OW 255
52454: ST_TO_ADDR
// dep := dep [ 1 ] ;
52455: LD_ADDR_VAR 0 9
52459: PUSH
52460: LD_VAR 0 9
52464: PUSH
52465: LD_INT 1
52467: ARRAY
52468: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52469: LD_ADDR_VAR 0 7
52473: PUSH
52474: LD_EXP 127
52478: PUSH
52479: LD_VAR 0 2
52483: ARRAY
52484: PPUSH
52485: LD_INT 22
52487: PUSH
52488: LD_INT 0
52490: PUSH
52491: EMPTY
52492: LIST
52493: LIST
52494: PUSH
52495: LD_INT 25
52497: PUSH
52498: LD_INT 12
52500: PUSH
52501: EMPTY
52502: LIST
52503: LIST
52504: PUSH
52505: EMPTY
52506: LIST
52507: LIST
52508: PPUSH
52509: CALL_OW 70
52513: PUSH
52514: LD_INT 22
52516: PUSH
52517: LD_INT 0
52519: PUSH
52520: EMPTY
52521: LIST
52522: LIST
52523: PUSH
52524: LD_INT 25
52526: PUSH
52527: LD_INT 12
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: PUSH
52534: LD_INT 91
52536: PUSH
52537: LD_VAR 0 9
52541: PUSH
52542: LD_INT 20
52544: PUSH
52545: EMPTY
52546: LIST
52547: LIST
52548: LIST
52549: PUSH
52550: EMPTY
52551: LIST
52552: LIST
52553: LIST
52554: PPUSH
52555: CALL_OW 69
52559: UNION
52560: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52561: LD_ADDR_VAR 0 10
52565: PUSH
52566: LD_EXP 127
52570: PUSH
52571: LD_VAR 0 2
52575: ARRAY
52576: PPUSH
52577: LD_INT 81
52579: PUSH
52580: LD_VAR 0 11
52584: PUSH
52585: EMPTY
52586: LIST
52587: LIST
52588: PPUSH
52589: CALL_OW 70
52593: ST_TO_ADDR
// if not apes or danger_at_area then
52594: LD_VAR 0 7
52598: NOT
52599: PUSH
52600: LD_VAR 0 10
52604: OR
52605: IFFALSE 52655
// begin if mc_taming [ i ] then
52607: LD_EXP 130
52611: PUSH
52612: LD_VAR 0 2
52616: ARRAY
52617: IFFALSE 52653
// begin MC_Reset ( i , 121 ) ;
52619: LD_VAR 0 2
52623: PPUSH
52624: LD_INT 121
52626: PPUSH
52627: CALL 37986 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52631: LD_ADDR_EXP 130
52635: PUSH
52636: LD_EXP 130
52640: PPUSH
52641: LD_VAR 0 2
52645: PPUSH
52646: EMPTY
52647: PPUSH
52648: CALL_OW 1
52652: ST_TO_ADDR
// end ; continue ;
52653: GO 52221
// end ; for j in tmp do
52655: LD_ADDR_VAR 0 3
52659: PUSH
52660: LD_VAR 0 8
52664: PUSH
52665: FOR_IN
52666: IFFALSE 53002
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52668: LD_VAR 0 3
52672: PUSH
52673: LD_EXP 130
52677: PUSH
52678: LD_VAR 0 2
52682: ARRAY
52683: IN
52684: NOT
52685: PUSH
52686: LD_EXP 130
52690: PUSH
52691: LD_VAR 0 2
52695: ARRAY
52696: PUSH
52697: LD_INT 3
52699: LESS
52700: AND
52701: IFFALSE 52759
// begin SetTag ( j , 121 ) ;
52703: LD_VAR 0 3
52707: PPUSH
52708: LD_INT 121
52710: PPUSH
52711: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52715: LD_ADDR_EXP 130
52719: PUSH
52720: LD_EXP 130
52724: PPUSH
52725: LD_VAR 0 2
52729: PUSH
52730: LD_EXP 130
52734: PUSH
52735: LD_VAR 0 2
52739: ARRAY
52740: PUSH
52741: LD_INT 1
52743: PLUS
52744: PUSH
52745: EMPTY
52746: LIST
52747: LIST
52748: PPUSH
52749: LD_VAR 0 3
52753: PPUSH
52754: CALL 71199 0 3
52758: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52759: LD_VAR 0 3
52763: PUSH
52764: LD_EXP 130
52768: PUSH
52769: LD_VAR 0 2
52773: ARRAY
52774: IN
52775: IFFALSE 53000
// begin if GetClass ( j ) <> 4 then
52777: LD_VAR 0 3
52781: PPUSH
52782: CALL_OW 257
52786: PUSH
52787: LD_INT 4
52789: NONEQUAL
52790: IFFALSE 52843
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52792: LD_ADDR_EXP 130
52796: PUSH
52797: LD_EXP 130
52801: PPUSH
52802: LD_VAR 0 2
52806: PPUSH
52807: LD_EXP 130
52811: PUSH
52812: LD_VAR 0 2
52816: ARRAY
52817: PUSH
52818: LD_VAR 0 3
52822: DIFF
52823: PPUSH
52824: CALL_OW 1
52828: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52829: LD_VAR 0 3
52833: PPUSH
52834: LD_INT 0
52836: PPUSH
52837: CALL_OW 109
// continue ;
52841: GO 52665
// end ; if IsInUnit ( j ) then
52843: LD_VAR 0 3
52847: PPUSH
52848: CALL_OW 310
52852: IFFALSE 52863
// ComExitBuilding ( j ) ;
52854: LD_VAR 0 3
52858: PPUSH
52859: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52863: LD_ADDR_VAR 0 6
52867: PUSH
52868: LD_VAR 0 7
52872: PPUSH
52873: LD_VAR 0 3
52877: PPUSH
52878: CALL_OW 74
52882: ST_TO_ADDR
// if not ape then
52883: LD_VAR 0 6
52887: NOT
52888: IFFALSE 52892
// break ;
52890: GO 53002
// x := GetX ( ape ) ;
52892: LD_ADDR_VAR 0 4
52896: PUSH
52897: LD_VAR 0 6
52901: PPUSH
52902: CALL_OW 250
52906: ST_TO_ADDR
// y := GetY ( ape ) ;
52907: LD_ADDR_VAR 0 5
52911: PUSH
52912: LD_VAR 0 6
52916: PPUSH
52917: CALL_OW 251
52921: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52922: LD_VAR 0 4
52926: PPUSH
52927: LD_VAR 0 5
52931: PPUSH
52932: CALL_OW 488
52936: NOT
52937: PUSH
52938: LD_VAR 0 11
52942: PPUSH
52943: LD_VAR 0 4
52947: PPUSH
52948: LD_VAR 0 5
52952: PPUSH
52953: LD_INT 20
52955: PPUSH
52956: CALL 72095 0 4
52960: PUSH
52961: LD_INT 4
52963: ARRAY
52964: OR
52965: IFFALSE 52969
// break ;
52967: GO 53002
// if not HasTask ( j ) then
52969: LD_VAR 0 3
52973: PPUSH
52974: CALL_OW 314
52978: NOT
52979: IFFALSE 53000
// ComTameXY ( j , x , y ) ;
52981: LD_VAR 0 3
52985: PPUSH
52986: LD_VAR 0 4
52990: PPUSH
52991: LD_VAR 0 5
52995: PPUSH
52996: CALL_OW 131
// end ; end ;
53000: GO 52665
53002: POP
53003: POP
// end ;
53004: GO 52221
53006: POP
53007: POP
// end ;
53008: LD_VAR 0 1
53012: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53013: LD_INT 0
53015: PPUSH
53016: PPUSH
53017: PPUSH
53018: PPUSH
53019: PPUSH
53020: PPUSH
53021: PPUSH
53022: PPUSH
// if not mc_bases then
53023: LD_EXP 99
53027: NOT
53028: IFFALSE 53032
// exit ;
53030: GO 53658
// for i = 1 to mc_bases do
53032: LD_ADDR_VAR 0 2
53036: PUSH
53037: DOUBLE
53038: LD_INT 1
53040: DEC
53041: ST_TO_ADDR
53042: LD_EXP 99
53046: PUSH
53047: FOR_TO
53048: IFFALSE 53656
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53050: LD_EXP 128
53054: PUSH
53055: LD_VAR 0 2
53059: ARRAY
53060: NOT
53061: PUSH
53062: LD_EXP 128
53066: PUSH
53067: LD_VAR 0 2
53071: ARRAY
53072: PPUSH
53073: LD_INT 25
53075: PUSH
53076: LD_INT 12
53078: PUSH
53079: EMPTY
53080: LIST
53081: LIST
53082: PPUSH
53083: CALL_OW 72
53087: NOT
53088: OR
53089: IFFALSE 53093
// continue ;
53091: GO 53047
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53093: LD_ADDR_VAR 0 5
53097: PUSH
53098: LD_EXP 128
53102: PUSH
53103: LD_VAR 0 2
53107: ARRAY
53108: PUSH
53109: LD_INT 1
53111: ARRAY
53112: PPUSH
53113: CALL_OW 255
53117: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53118: LD_VAR 0 5
53122: PPUSH
53123: LD_INT 2
53125: PPUSH
53126: CALL_OW 325
53130: IFFALSE 53383
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53132: LD_ADDR_VAR 0 4
53136: PUSH
53137: LD_EXP 128
53141: PUSH
53142: LD_VAR 0 2
53146: ARRAY
53147: PPUSH
53148: LD_INT 25
53150: PUSH
53151: LD_INT 16
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: PPUSH
53158: CALL_OW 72
53162: ST_TO_ADDR
// if tmp < 6 then
53163: LD_VAR 0 4
53167: PUSH
53168: LD_INT 6
53170: LESS
53171: IFFALSE 53383
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53173: LD_ADDR_VAR 0 6
53177: PUSH
53178: LD_EXP 99
53182: PUSH
53183: LD_VAR 0 2
53187: ARRAY
53188: PPUSH
53189: LD_INT 2
53191: PUSH
53192: LD_INT 30
53194: PUSH
53195: LD_INT 0
53197: PUSH
53198: EMPTY
53199: LIST
53200: LIST
53201: PUSH
53202: LD_INT 30
53204: PUSH
53205: LD_INT 1
53207: PUSH
53208: EMPTY
53209: LIST
53210: LIST
53211: PUSH
53212: EMPTY
53213: LIST
53214: LIST
53215: LIST
53216: PPUSH
53217: CALL_OW 72
53221: ST_TO_ADDR
// if depot then
53222: LD_VAR 0 6
53226: IFFALSE 53383
// begin selected := 0 ;
53228: LD_ADDR_VAR 0 7
53232: PUSH
53233: LD_INT 0
53235: ST_TO_ADDR
// for j in depot do
53236: LD_ADDR_VAR 0 3
53240: PUSH
53241: LD_VAR 0 6
53245: PUSH
53246: FOR_IN
53247: IFFALSE 53278
// begin if UnitsInside ( j ) < 6 then
53249: LD_VAR 0 3
53253: PPUSH
53254: CALL_OW 313
53258: PUSH
53259: LD_INT 6
53261: LESS
53262: IFFALSE 53276
// begin selected := j ;
53264: LD_ADDR_VAR 0 7
53268: PUSH
53269: LD_VAR 0 3
53273: ST_TO_ADDR
// break ;
53274: GO 53278
// end ; end ;
53276: GO 53246
53278: POP
53279: POP
// if selected then
53280: LD_VAR 0 7
53284: IFFALSE 53383
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53286: LD_ADDR_VAR 0 3
53290: PUSH
53291: LD_EXP 128
53295: PUSH
53296: LD_VAR 0 2
53300: ARRAY
53301: PPUSH
53302: LD_INT 25
53304: PUSH
53305: LD_INT 12
53307: PUSH
53308: EMPTY
53309: LIST
53310: LIST
53311: PPUSH
53312: CALL_OW 72
53316: PUSH
53317: FOR_IN
53318: IFFALSE 53381
// if not HasTask ( j ) then
53320: LD_VAR 0 3
53324: PPUSH
53325: CALL_OW 314
53329: NOT
53330: IFFALSE 53379
// begin if not IsInUnit ( j ) then
53332: LD_VAR 0 3
53336: PPUSH
53337: CALL_OW 310
53341: NOT
53342: IFFALSE 53358
// ComEnterUnit ( j , selected ) ;
53344: LD_VAR 0 3
53348: PPUSH
53349: LD_VAR 0 7
53353: PPUSH
53354: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53358: LD_VAR 0 3
53362: PPUSH
53363: LD_INT 16
53365: PPUSH
53366: CALL_OW 183
// AddComExitBuilding ( j ) ;
53370: LD_VAR 0 3
53374: PPUSH
53375: CALL_OW 182
// end ;
53379: GO 53317
53381: POP
53382: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53383: LD_VAR 0 5
53387: PPUSH
53388: LD_INT 11
53390: PPUSH
53391: CALL_OW 325
53395: IFFALSE 53654
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53397: LD_ADDR_VAR 0 4
53401: PUSH
53402: LD_EXP 128
53406: PUSH
53407: LD_VAR 0 2
53411: ARRAY
53412: PPUSH
53413: LD_INT 25
53415: PUSH
53416: LD_INT 16
53418: PUSH
53419: EMPTY
53420: LIST
53421: LIST
53422: PPUSH
53423: CALL_OW 72
53427: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53428: LD_VAR 0 4
53432: PUSH
53433: LD_INT 6
53435: GREATEREQUAL
53436: PUSH
53437: LD_VAR 0 5
53441: PPUSH
53442: LD_INT 2
53444: PPUSH
53445: CALL_OW 325
53449: NOT
53450: OR
53451: IFFALSE 53654
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53453: LD_ADDR_VAR 0 8
53457: PUSH
53458: LD_EXP 99
53462: PUSH
53463: LD_VAR 0 2
53467: ARRAY
53468: PPUSH
53469: LD_INT 2
53471: PUSH
53472: LD_INT 30
53474: PUSH
53475: LD_INT 4
53477: PUSH
53478: EMPTY
53479: LIST
53480: LIST
53481: PUSH
53482: LD_INT 30
53484: PUSH
53485: LD_INT 5
53487: PUSH
53488: EMPTY
53489: LIST
53490: LIST
53491: PUSH
53492: EMPTY
53493: LIST
53494: LIST
53495: LIST
53496: PPUSH
53497: CALL_OW 72
53501: ST_TO_ADDR
// if barracks then
53502: LD_VAR 0 8
53506: IFFALSE 53654
// begin selected := 0 ;
53508: LD_ADDR_VAR 0 7
53512: PUSH
53513: LD_INT 0
53515: ST_TO_ADDR
// for j in barracks do
53516: LD_ADDR_VAR 0 3
53520: PUSH
53521: LD_VAR 0 8
53525: PUSH
53526: FOR_IN
53527: IFFALSE 53558
// begin if UnitsInside ( j ) < 6 then
53529: LD_VAR 0 3
53533: PPUSH
53534: CALL_OW 313
53538: PUSH
53539: LD_INT 6
53541: LESS
53542: IFFALSE 53556
// begin selected := j ;
53544: LD_ADDR_VAR 0 7
53548: PUSH
53549: LD_VAR 0 3
53553: ST_TO_ADDR
// break ;
53554: GO 53558
// end ; end ;
53556: GO 53526
53558: POP
53559: POP
// if selected then
53560: LD_VAR 0 7
53564: IFFALSE 53654
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53566: LD_ADDR_VAR 0 3
53570: PUSH
53571: LD_EXP 128
53575: PUSH
53576: LD_VAR 0 2
53580: ARRAY
53581: PPUSH
53582: LD_INT 25
53584: PUSH
53585: LD_INT 12
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PPUSH
53592: CALL_OW 72
53596: PUSH
53597: FOR_IN
53598: IFFALSE 53652
// if not IsInUnit ( j ) and not HasTask ( j ) then
53600: LD_VAR 0 3
53604: PPUSH
53605: CALL_OW 310
53609: NOT
53610: PUSH
53611: LD_VAR 0 3
53615: PPUSH
53616: CALL_OW 314
53620: NOT
53621: AND
53622: IFFALSE 53650
// begin ComEnterUnit ( j , selected ) ;
53624: LD_VAR 0 3
53628: PPUSH
53629: LD_VAR 0 7
53633: PPUSH
53634: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53638: LD_VAR 0 3
53642: PPUSH
53643: LD_INT 15
53645: PPUSH
53646: CALL_OW 183
// end ;
53650: GO 53597
53652: POP
53653: POP
// end ; end ; end ; end ; end ;
53654: GO 53047
53656: POP
53657: POP
// end ;
53658: LD_VAR 0 1
53662: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53663: LD_INT 0
53665: PPUSH
53666: PPUSH
53667: PPUSH
53668: PPUSH
// if not mc_bases then
53669: LD_EXP 99
53673: NOT
53674: IFFALSE 53678
// exit ;
53676: GO 53856
// for i = 1 to mc_bases do
53678: LD_ADDR_VAR 0 2
53682: PUSH
53683: DOUBLE
53684: LD_INT 1
53686: DEC
53687: ST_TO_ADDR
53688: LD_EXP 99
53692: PUSH
53693: FOR_TO
53694: IFFALSE 53854
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53696: LD_ADDR_VAR 0 4
53700: PUSH
53701: LD_EXP 99
53705: PUSH
53706: LD_VAR 0 2
53710: ARRAY
53711: PPUSH
53712: LD_INT 25
53714: PUSH
53715: LD_INT 9
53717: PUSH
53718: EMPTY
53719: LIST
53720: LIST
53721: PPUSH
53722: CALL_OW 72
53726: ST_TO_ADDR
// if not tmp then
53727: LD_VAR 0 4
53731: NOT
53732: IFFALSE 53736
// continue ;
53734: GO 53693
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53736: LD_EXP 125
53740: PUSH
53741: LD_VAR 0 2
53745: ARRAY
53746: PPUSH
53747: LD_INT 29
53749: PPUSH
53750: CALL_OW 325
53754: NOT
53755: PUSH
53756: LD_EXP 125
53760: PUSH
53761: LD_VAR 0 2
53765: ARRAY
53766: PPUSH
53767: LD_INT 28
53769: PPUSH
53770: CALL_OW 325
53774: NOT
53775: AND
53776: IFFALSE 53780
// continue ;
53778: GO 53693
// for j in tmp do
53780: LD_ADDR_VAR 0 3
53784: PUSH
53785: LD_VAR 0 4
53789: PUSH
53790: FOR_IN
53791: IFFALSE 53850
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53793: LD_VAR 0 3
53797: PUSH
53798: LD_EXP 102
53802: PUSH
53803: LD_VAR 0 2
53807: ARRAY
53808: PUSH
53809: LD_INT 1
53811: ARRAY
53812: IN
53813: NOT
53814: PUSH
53815: LD_VAR 0 3
53819: PUSH
53820: LD_EXP 102
53824: PUSH
53825: LD_VAR 0 2
53829: ARRAY
53830: PUSH
53831: LD_INT 2
53833: ARRAY
53834: IN
53835: NOT
53836: AND
53837: IFFALSE 53848
// ComSpaceTimeShoot ( j ) ;
53839: LD_VAR 0 3
53843: PPUSH
53844: CALL 64874 0 1
53848: GO 53790
53850: POP
53851: POP
// end ;
53852: GO 53693
53854: POP
53855: POP
// end ;
53856: LD_VAR 0 1
53860: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53861: LD_INT 0
53863: PPUSH
53864: PPUSH
53865: PPUSH
53866: PPUSH
53867: PPUSH
53868: PPUSH
53869: PPUSH
53870: PPUSH
53871: PPUSH
// if not mc_bases then
53872: LD_EXP 99
53876: NOT
53877: IFFALSE 53881
// exit ;
53879: GO 54503
// for i = 1 to mc_bases do
53881: LD_ADDR_VAR 0 2
53885: PUSH
53886: DOUBLE
53887: LD_INT 1
53889: DEC
53890: ST_TO_ADDR
53891: LD_EXP 99
53895: PUSH
53896: FOR_TO
53897: IFFALSE 54501
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53899: LD_EXP 134
53903: PUSH
53904: LD_VAR 0 2
53908: ARRAY
53909: NOT
53910: PUSH
53911: LD_INT 38
53913: PPUSH
53914: LD_EXP 125
53918: PUSH
53919: LD_VAR 0 2
53923: ARRAY
53924: PPUSH
53925: CALL_OW 321
53929: PUSH
53930: LD_INT 2
53932: NONEQUAL
53933: OR
53934: IFFALSE 53938
// continue ;
53936: GO 53896
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53938: LD_ADDR_VAR 0 8
53942: PUSH
53943: LD_EXP 99
53947: PUSH
53948: LD_VAR 0 2
53952: ARRAY
53953: PPUSH
53954: LD_INT 30
53956: PUSH
53957: LD_INT 34
53959: PUSH
53960: EMPTY
53961: LIST
53962: LIST
53963: PPUSH
53964: CALL_OW 72
53968: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53969: LD_ADDR_VAR 0 9
53973: PUSH
53974: LD_EXP 99
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PPUSH
53985: LD_INT 25
53987: PUSH
53988: LD_INT 4
53990: PUSH
53991: EMPTY
53992: LIST
53993: LIST
53994: PPUSH
53995: CALL_OW 72
53999: PPUSH
54000: LD_INT 0
54002: PPUSH
54003: CALL 104459 0 2
54007: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54008: LD_VAR 0 9
54012: NOT
54013: PUSH
54014: LD_VAR 0 8
54018: NOT
54019: OR
54020: PUSH
54021: LD_EXP 99
54025: PUSH
54026: LD_VAR 0 2
54030: ARRAY
54031: PPUSH
54032: LD_INT 124
54034: PPUSH
54035: CALL 104459 0 2
54039: OR
54040: IFFALSE 54044
// continue ;
54042: GO 53896
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54044: LD_EXP 135
54048: PUSH
54049: LD_VAR 0 2
54053: ARRAY
54054: PUSH
54055: LD_EXP 134
54059: PUSH
54060: LD_VAR 0 2
54064: ARRAY
54065: LESS
54066: PUSH
54067: LD_EXP 135
54071: PUSH
54072: LD_VAR 0 2
54076: ARRAY
54077: PUSH
54078: LD_VAR 0 8
54082: LESS
54083: AND
54084: IFFALSE 54499
// begin tmp := sci [ 1 ] ;
54086: LD_ADDR_VAR 0 7
54090: PUSH
54091: LD_VAR 0 9
54095: PUSH
54096: LD_INT 1
54098: ARRAY
54099: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54100: LD_VAR 0 7
54104: PPUSH
54105: LD_INT 124
54107: PPUSH
54108: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54112: LD_ADDR_VAR 0 3
54116: PUSH
54117: DOUBLE
54118: LD_EXP 134
54122: PUSH
54123: LD_VAR 0 2
54127: ARRAY
54128: INC
54129: ST_TO_ADDR
54130: LD_EXP 134
54134: PUSH
54135: LD_VAR 0 2
54139: ARRAY
54140: PUSH
54141: FOR_DOWNTO
54142: IFFALSE 54485
// begin if IsInUnit ( tmp ) then
54144: LD_VAR 0 7
54148: PPUSH
54149: CALL_OW 310
54153: IFFALSE 54164
// ComExitBuilding ( tmp ) ;
54155: LD_VAR 0 7
54159: PPUSH
54160: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54164: LD_INT 35
54166: PPUSH
54167: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54171: LD_VAR 0 7
54175: PPUSH
54176: CALL_OW 310
54180: NOT
54181: PUSH
54182: LD_VAR 0 7
54186: PPUSH
54187: CALL_OW 314
54191: NOT
54192: AND
54193: IFFALSE 54164
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54195: LD_ADDR_VAR 0 6
54199: PUSH
54200: LD_VAR 0 7
54204: PPUSH
54205: CALL_OW 250
54209: PUSH
54210: LD_VAR 0 7
54214: PPUSH
54215: CALL_OW 251
54219: PUSH
54220: EMPTY
54221: LIST
54222: LIST
54223: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54224: LD_INT 35
54226: PPUSH
54227: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54231: LD_ADDR_VAR 0 4
54235: PUSH
54236: LD_EXP 134
54240: PUSH
54241: LD_VAR 0 2
54245: ARRAY
54246: PUSH
54247: LD_VAR 0 3
54251: ARRAY
54252: PUSH
54253: LD_INT 1
54255: ARRAY
54256: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54257: LD_ADDR_VAR 0 5
54261: PUSH
54262: LD_EXP 134
54266: PUSH
54267: LD_VAR 0 2
54271: ARRAY
54272: PUSH
54273: LD_VAR 0 3
54277: ARRAY
54278: PUSH
54279: LD_INT 2
54281: ARRAY
54282: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54283: LD_VAR 0 7
54287: PPUSH
54288: LD_INT 10
54290: PPUSH
54291: CALL 73792 0 2
54295: PUSH
54296: LD_INT 4
54298: ARRAY
54299: IFFALSE 54337
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54301: LD_VAR 0 7
54305: PPUSH
54306: LD_VAR 0 6
54310: PUSH
54311: LD_INT 1
54313: ARRAY
54314: PPUSH
54315: LD_VAR 0 6
54319: PUSH
54320: LD_INT 2
54322: ARRAY
54323: PPUSH
54324: CALL_OW 111
// wait ( 0 0$10 ) ;
54328: LD_INT 350
54330: PPUSH
54331: CALL_OW 67
// end else
54335: GO 54363
// begin ComMoveXY ( tmp , x , y ) ;
54337: LD_VAR 0 7
54341: PPUSH
54342: LD_VAR 0 4
54346: PPUSH
54347: LD_VAR 0 5
54351: PPUSH
54352: CALL_OW 111
// wait ( 0 0$3 ) ;
54356: LD_INT 105
54358: PPUSH
54359: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54363: LD_VAR 0 7
54367: PPUSH
54368: LD_VAR 0 4
54372: PPUSH
54373: LD_VAR 0 5
54377: PPUSH
54378: CALL_OW 307
54382: IFFALSE 54224
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54384: LD_VAR 0 7
54388: PPUSH
54389: LD_VAR 0 4
54393: PPUSH
54394: LD_VAR 0 5
54398: PPUSH
54399: LD_VAR 0 8
54403: PUSH
54404: LD_VAR 0 3
54408: ARRAY
54409: PPUSH
54410: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54414: LD_INT 35
54416: PPUSH
54417: CALL_OW 67
// until not HasTask ( tmp ) ;
54421: LD_VAR 0 7
54425: PPUSH
54426: CALL_OW 314
54430: NOT
54431: IFFALSE 54414
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54433: LD_ADDR_EXP 135
54437: PUSH
54438: LD_EXP 135
54442: PPUSH
54443: LD_VAR 0 2
54447: PUSH
54448: LD_EXP 135
54452: PUSH
54453: LD_VAR 0 2
54457: ARRAY
54458: PUSH
54459: LD_INT 1
54461: PLUS
54462: PUSH
54463: EMPTY
54464: LIST
54465: LIST
54466: PPUSH
54467: LD_VAR 0 8
54471: PUSH
54472: LD_VAR 0 3
54476: ARRAY
54477: PPUSH
54478: CALL 71199 0 3
54482: ST_TO_ADDR
// end ;
54483: GO 54141
54485: POP
54486: POP
// MC_Reset ( i , 124 ) ;
54487: LD_VAR 0 2
54491: PPUSH
54492: LD_INT 124
54494: PPUSH
54495: CALL 37986 0 2
// end ; end ;
54499: GO 53896
54501: POP
54502: POP
// end ;
54503: LD_VAR 0 1
54507: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54508: LD_INT 0
54510: PPUSH
54511: PPUSH
54512: PPUSH
// if not mc_bases then
54513: LD_EXP 99
54517: NOT
54518: IFFALSE 54522
// exit ;
54520: GO 55128
// for i = 1 to mc_bases do
54522: LD_ADDR_VAR 0 2
54526: PUSH
54527: DOUBLE
54528: LD_INT 1
54530: DEC
54531: ST_TO_ADDR
54532: LD_EXP 99
54536: PUSH
54537: FOR_TO
54538: IFFALSE 55126
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54540: LD_ADDR_VAR 0 3
54544: PUSH
54545: LD_EXP 99
54549: PUSH
54550: LD_VAR 0 2
54554: ARRAY
54555: PPUSH
54556: LD_INT 25
54558: PUSH
54559: LD_INT 4
54561: PUSH
54562: EMPTY
54563: LIST
54564: LIST
54565: PPUSH
54566: CALL_OW 72
54570: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54571: LD_VAR 0 3
54575: NOT
54576: PUSH
54577: LD_EXP 136
54581: PUSH
54582: LD_VAR 0 2
54586: ARRAY
54587: NOT
54588: OR
54589: PUSH
54590: LD_EXP 99
54594: PUSH
54595: LD_VAR 0 2
54599: ARRAY
54600: PPUSH
54601: LD_INT 2
54603: PUSH
54604: LD_INT 30
54606: PUSH
54607: LD_INT 0
54609: PUSH
54610: EMPTY
54611: LIST
54612: LIST
54613: PUSH
54614: LD_INT 30
54616: PUSH
54617: LD_INT 1
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: PUSH
54624: EMPTY
54625: LIST
54626: LIST
54627: LIST
54628: PPUSH
54629: CALL_OW 72
54633: NOT
54634: OR
54635: IFFALSE 54685
// begin if mc_deposits_finder [ i ] then
54637: LD_EXP 137
54641: PUSH
54642: LD_VAR 0 2
54646: ARRAY
54647: IFFALSE 54683
// begin MC_Reset ( i , 125 ) ;
54649: LD_VAR 0 2
54653: PPUSH
54654: LD_INT 125
54656: PPUSH
54657: CALL 37986 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54661: LD_ADDR_EXP 137
54665: PUSH
54666: LD_EXP 137
54670: PPUSH
54671: LD_VAR 0 2
54675: PPUSH
54676: EMPTY
54677: PPUSH
54678: CALL_OW 1
54682: ST_TO_ADDR
// end ; continue ;
54683: GO 54537
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54685: LD_EXP 136
54689: PUSH
54690: LD_VAR 0 2
54694: ARRAY
54695: PUSH
54696: LD_INT 1
54698: ARRAY
54699: PUSH
54700: LD_INT 3
54702: ARRAY
54703: PUSH
54704: LD_INT 1
54706: EQUAL
54707: PUSH
54708: LD_INT 20
54710: PPUSH
54711: LD_EXP 125
54715: PUSH
54716: LD_VAR 0 2
54720: ARRAY
54721: PPUSH
54722: CALL_OW 321
54726: PUSH
54727: LD_INT 2
54729: NONEQUAL
54730: AND
54731: IFFALSE 54781
// begin if mc_deposits_finder [ i ] then
54733: LD_EXP 137
54737: PUSH
54738: LD_VAR 0 2
54742: ARRAY
54743: IFFALSE 54779
// begin MC_Reset ( i , 125 ) ;
54745: LD_VAR 0 2
54749: PPUSH
54750: LD_INT 125
54752: PPUSH
54753: CALL 37986 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54757: LD_ADDR_EXP 137
54761: PUSH
54762: LD_EXP 137
54766: PPUSH
54767: LD_VAR 0 2
54771: PPUSH
54772: EMPTY
54773: PPUSH
54774: CALL_OW 1
54778: ST_TO_ADDR
// end ; continue ;
54779: GO 54537
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54781: LD_EXP 136
54785: PUSH
54786: LD_VAR 0 2
54790: ARRAY
54791: PUSH
54792: LD_INT 1
54794: ARRAY
54795: PUSH
54796: LD_INT 1
54798: ARRAY
54799: PPUSH
54800: LD_EXP 136
54804: PUSH
54805: LD_VAR 0 2
54809: ARRAY
54810: PUSH
54811: LD_INT 1
54813: ARRAY
54814: PUSH
54815: LD_INT 2
54817: ARRAY
54818: PPUSH
54819: LD_EXP 125
54823: PUSH
54824: LD_VAR 0 2
54828: ARRAY
54829: PPUSH
54830: CALL_OW 440
54834: IFFALSE 54877
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54836: LD_ADDR_EXP 136
54840: PUSH
54841: LD_EXP 136
54845: PPUSH
54846: LD_VAR 0 2
54850: PPUSH
54851: LD_EXP 136
54855: PUSH
54856: LD_VAR 0 2
54860: ARRAY
54861: PPUSH
54862: LD_INT 1
54864: PPUSH
54865: CALL_OW 3
54869: PPUSH
54870: CALL_OW 1
54874: ST_TO_ADDR
54875: GO 55124
// begin if not mc_deposits_finder [ i ] then
54877: LD_EXP 137
54881: PUSH
54882: LD_VAR 0 2
54886: ARRAY
54887: NOT
54888: IFFALSE 54940
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54890: LD_ADDR_EXP 137
54894: PUSH
54895: LD_EXP 137
54899: PPUSH
54900: LD_VAR 0 2
54904: PPUSH
54905: LD_VAR 0 3
54909: PUSH
54910: LD_INT 1
54912: ARRAY
54913: PUSH
54914: EMPTY
54915: LIST
54916: PPUSH
54917: CALL_OW 1
54921: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54922: LD_VAR 0 3
54926: PUSH
54927: LD_INT 1
54929: ARRAY
54930: PPUSH
54931: LD_INT 125
54933: PPUSH
54934: CALL_OW 109
// end else
54938: GO 55124
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54940: LD_EXP 137
54944: PUSH
54945: LD_VAR 0 2
54949: ARRAY
54950: PUSH
54951: LD_INT 1
54953: ARRAY
54954: PPUSH
54955: CALL_OW 310
54959: IFFALSE 54982
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54961: LD_EXP 137
54965: PUSH
54966: LD_VAR 0 2
54970: ARRAY
54971: PUSH
54972: LD_INT 1
54974: ARRAY
54975: PPUSH
54976: CALL_OW 122
54980: GO 55124
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54982: LD_EXP 137
54986: PUSH
54987: LD_VAR 0 2
54991: ARRAY
54992: PUSH
54993: LD_INT 1
54995: ARRAY
54996: PPUSH
54997: CALL_OW 314
55001: NOT
55002: PUSH
55003: LD_EXP 137
55007: PUSH
55008: LD_VAR 0 2
55012: ARRAY
55013: PUSH
55014: LD_INT 1
55016: ARRAY
55017: PPUSH
55018: LD_EXP 136
55022: PUSH
55023: LD_VAR 0 2
55027: ARRAY
55028: PUSH
55029: LD_INT 1
55031: ARRAY
55032: PUSH
55033: LD_INT 1
55035: ARRAY
55036: PPUSH
55037: LD_EXP 136
55041: PUSH
55042: LD_VAR 0 2
55046: ARRAY
55047: PUSH
55048: LD_INT 1
55050: ARRAY
55051: PUSH
55052: LD_INT 2
55054: ARRAY
55055: PPUSH
55056: CALL_OW 297
55060: PUSH
55061: LD_INT 6
55063: GREATER
55064: AND
55065: IFFALSE 55124
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55067: LD_EXP 137
55071: PUSH
55072: LD_VAR 0 2
55076: ARRAY
55077: PUSH
55078: LD_INT 1
55080: ARRAY
55081: PPUSH
55082: LD_EXP 136
55086: PUSH
55087: LD_VAR 0 2
55091: ARRAY
55092: PUSH
55093: LD_INT 1
55095: ARRAY
55096: PUSH
55097: LD_INT 1
55099: ARRAY
55100: PPUSH
55101: LD_EXP 136
55105: PUSH
55106: LD_VAR 0 2
55110: ARRAY
55111: PUSH
55112: LD_INT 1
55114: ARRAY
55115: PUSH
55116: LD_INT 2
55118: ARRAY
55119: PPUSH
55120: CALL_OW 111
// end ; end ; end ;
55124: GO 54537
55126: POP
55127: POP
// end ;
55128: LD_VAR 0 1
55132: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55133: LD_INT 0
55135: PPUSH
55136: PPUSH
55137: PPUSH
55138: PPUSH
55139: PPUSH
55140: PPUSH
55141: PPUSH
55142: PPUSH
55143: PPUSH
55144: PPUSH
55145: PPUSH
// if not mc_bases then
55146: LD_EXP 99
55150: NOT
55151: IFFALSE 55155
// exit ;
55153: GO 56095
// for i = 1 to mc_bases do
55155: LD_ADDR_VAR 0 2
55159: PUSH
55160: DOUBLE
55161: LD_INT 1
55163: DEC
55164: ST_TO_ADDR
55165: LD_EXP 99
55169: PUSH
55170: FOR_TO
55171: IFFALSE 56093
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55173: LD_EXP 99
55177: PUSH
55178: LD_VAR 0 2
55182: ARRAY
55183: NOT
55184: PUSH
55185: LD_EXP 122
55189: PUSH
55190: LD_VAR 0 2
55194: ARRAY
55195: OR
55196: IFFALSE 55200
// continue ;
55198: GO 55170
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55200: LD_ADDR_VAR 0 7
55204: PUSH
55205: LD_EXP 99
55209: PUSH
55210: LD_VAR 0 2
55214: ARRAY
55215: PUSH
55216: LD_INT 1
55218: ARRAY
55219: PPUSH
55220: CALL_OW 248
55224: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55225: LD_VAR 0 7
55229: PUSH
55230: LD_INT 3
55232: EQUAL
55233: PUSH
55234: LD_EXP 118
55238: PUSH
55239: LD_VAR 0 2
55243: ARRAY
55244: PUSH
55245: LD_EXP 121
55249: PUSH
55250: LD_VAR 0 2
55254: ARRAY
55255: UNION
55256: PPUSH
55257: LD_INT 33
55259: PUSH
55260: LD_INT 2
55262: PUSH
55263: EMPTY
55264: LIST
55265: LIST
55266: PPUSH
55267: CALL_OW 72
55271: NOT
55272: OR
55273: IFFALSE 55277
// continue ;
55275: GO 55170
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55277: LD_ADDR_VAR 0 9
55281: PUSH
55282: LD_EXP 99
55286: PUSH
55287: LD_VAR 0 2
55291: ARRAY
55292: PPUSH
55293: LD_INT 30
55295: PUSH
55296: LD_INT 36
55298: PUSH
55299: EMPTY
55300: LIST
55301: LIST
55302: PPUSH
55303: CALL_OW 72
55307: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55308: LD_ADDR_VAR 0 10
55312: PUSH
55313: LD_EXP 118
55317: PUSH
55318: LD_VAR 0 2
55322: ARRAY
55323: PPUSH
55324: LD_INT 34
55326: PUSH
55327: LD_INT 31
55329: PUSH
55330: EMPTY
55331: LIST
55332: LIST
55333: PPUSH
55334: CALL_OW 72
55338: ST_TO_ADDR
// if not cts and not mcts then
55339: LD_VAR 0 9
55343: NOT
55344: PUSH
55345: LD_VAR 0 10
55349: NOT
55350: AND
55351: IFFALSE 55355
// continue ;
55353: GO 55170
// x := cts ;
55355: LD_ADDR_VAR 0 11
55359: PUSH
55360: LD_VAR 0 9
55364: ST_TO_ADDR
// if not x then
55365: LD_VAR 0 11
55369: NOT
55370: IFFALSE 55382
// x := mcts ;
55372: LD_ADDR_VAR 0 11
55376: PUSH
55377: LD_VAR 0 10
55381: ST_TO_ADDR
// if not x then
55382: LD_VAR 0 11
55386: NOT
55387: IFFALSE 55391
// continue ;
55389: GO 55170
// if mc_remote_driver [ i ] then
55391: LD_EXP 139
55395: PUSH
55396: LD_VAR 0 2
55400: ARRAY
55401: IFFALSE 55788
// for j in mc_remote_driver [ i ] do
55403: LD_ADDR_VAR 0 3
55407: PUSH
55408: LD_EXP 139
55412: PUSH
55413: LD_VAR 0 2
55417: ARRAY
55418: PUSH
55419: FOR_IN
55420: IFFALSE 55786
// begin if GetClass ( j ) <> 3 then
55422: LD_VAR 0 3
55426: PPUSH
55427: CALL_OW 257
55431: PUSH
55432: LD_INT 3
55434: NONEQUAL
55435: IFFALSE 55488
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55437: LD_ADDR_EXP 139
55441: PUSH
55442: LD_EXP 139
55446: PPUSH
55447: LD_VAR 0 2
55451: PPUSH
55452: LD_EXP 139
55456: PUSH
55457: LD_VAR 0 2
55461: ARRAY
55462: PUSH
55463: LD_VAR 0 3
55467: DIFF
55468: PPUSH
55469: CALL_OW 1
55473: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55474: LD_VAR 0 3
55478: PPUSH
55479: LD_INT 0
55481: PPUSH
55482: CALL_OW 109
// continue ;
55486: GO 55419
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55488: LD_EXP 118
55492: PUSH
55493: LD_VAR 0 2
55497: ARRAY
55498: PPUSH
55499: LD_INT 34
55501: PUSH
55502: LD_INT 31
55504: PUSH
55505: EMPTY
55506: LIST
55507: LIST
55508: PUSH
55509: LD_INT 58
55511: PUSH
55512: EMPTY
55513: LIST
55514: PUSH
55515: EMPTY
55516: LIST
55517: LIST
55518: PPUSH
55519: CALL_OW 72
55523: PUSH
55524: LD_VAR 0 3
55528: PPUSH
55529: CALL 104547 0 1
55533: NOT
55534: AND
55535: IFFALSE 55606
// begin if IsInUnit ( j ) then
55537: LD_VAR 0 3
55541: PPUSH
55542: CALL_OW 310
55546: IFFALSE 55557
// ComExitBuilding ( j ) ;
55548: LD_VAR 0 3
55552: PPUSH
55553: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55557: LD_VAR 0 3
55561: PPUSH
55562: LD_EXP 118
55566: PUSH
55567: LD_VAR 0 2
55571: ARRAY
55572: PPUSH
55573: LD_INT 34
55575: PUSH
55576: LD_INT 31
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: PUSH
55583: LD_INT 58
55585: PUSH
55586: EMPTY
55587: LIST
55588: PUSH
55589: EMPTY
55590: LIST
55591: LIST
55592: PPUSH
55593: CALL_OW 72
55597: PUSH
55598: LD_INT 1
55600: ARRAY
55601: PPUSH
55602: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55606: LD_VAR 0 3
55610: PPUSH
55611: CALL_OW 310
55615: NOT
55616: PUSH
55617: LD_VAR 0 3
55621: PPUSH
55622: CALL_OW 310
55626: PPUSH
55627: CALL_OW 266
55631: PUSH
55632: LD_INT 36
55634: NONEQUAL
55635: PUSH
55636: LD_VAR 0 3
55640: PPUSH
55641: CALL 104547 0 1
55645: NOT
55646: AND
55647: OR
55648: IFFALSE 55784
// begin if IsInUnit ( j ) then
55650: LD_VAR 0 3
55654: PPUSH
55655: CALL_OW 310
55659: IFFALSE 55670
// ComExitBuilding ( j ) ;
55661: LD_VAR 0 3
55665: PPUSH
55666: CALL_OW 122
// ct := 0 ;
55670: LD_ADDR_VAR 0 8
55674: PUSH
55675: LD_INT 0
55677: ST_TO_ADDR
// for k in x do
55678: LD_ADDR_VAR 0 4
55682: PUSH
55683: LD_VAR 0 11
55687: PUSH
55688: FOR_IN
55689: IFFALSE 55762
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55691: LD_VAR 0 4
55695: PPUSH
55696: CALL_OW 264
55700: PUSH
55701: LD_INT 31
55703: EQUAL
55704: PUSH
55705: LD_VAR 0 4
55709: PPUSH
55710: CALL_OW 311
55714: NOT
55715: AND
55716: PUSH
55717: LD_VAR 0 4
55721: PPUSH
55722: CALL_OW 266
55726: PUSH
55727: LD_INT 36
55729: EQUAL
55730: PUSH
55731: LD_VAR 0 4
55735: PPUSH
55736: CALL_OW 313
55740: PUSH
55741: LD_INT 3
55743: LESS
55744: AND
55745: OR
55746: IFFALSE 55760
// begin ct := k ;
55748: LD_ADDR_VAR 0 8
55752: PUSH
55753: LD_VAR 0 4
55757: ST_TO_ADDR
// break ;
55758: GO 55762
// end ;
55760: GO 55688
55762: POP
55763: POP
// if ct then
55764: LD_VAR 0 8
55768: IFFALSE 55784
// ComEnterUnit ( j , ct ) ;
55770: LD_VAR 0 3
55774: PPUSH
55775: LD_VAR 0 8
55779: PPUSH
55780: CALL_OW 120
// end ; end ;
55784: GO 55419
55786: POP
55787: POP
// places := 0 ;
55788: LD_ADDR_VAR 0 5
55792: PUSH
55793: LD_INT 0
55795: ST_TO_ADDR
// for j = 1 to x do
55796: LD_ADDR_VAR 0 3
55800: PUSH
55801: DOUBLE
55802: LD_INT 1
55804: DEC
55805: ST_TO_ADDR
55806: LD_VAR 0 11
55810: PUSH
55811: FOR_TO
55812: IFFALSE 55888
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55814: LD_VAR 0 11
55818: PUSH
55819: LD_VAR 0 3
55823: ARRAY
55824: PPUSH
55825: CALL_OW 264
55829: PUSH
55830: LD_INT 31
55832: EQUAL
55833: IFFALSE 55851
// places := places + 1 else
55835: LD_ADDR_VAR 0 5
55839: PUSH
55840: LD_VAR 0 5
55844: PUSH
55845: LD_INT 1
55847: PLUS
55848: ST_TO_ADDR
55849: GO 55886
// if GetBType ( x [ j ] ) = b_control_tower then
55851: LD_VAR 0 11
55855: PUSH
55856: LD_VAR 0 3
55860: ARRAY
55861: PPUSH
55862: CALL_OW 266
55866: PUSH
55867: LD_INT 36
55869: EQUAL
55870: IFFALSE 55886
// places := places + 3 ;
55872: LD_ADDR_VAR 0 5
55876: PUSH
55877: LD_VAR 0 5
55881: PUSH
55882: LD_INT 3
55884: PLUS
55885: ST_TO_ADDR
55886: GO 55811
55888: POP
55889: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
55890: LD_VAR 0 5
55894: PUSH
55895: LD_INT 0
55897: EQUAL
55898: PUSH
55899: LD_VAR 0 5
55903: PUSH
55904: LD_EXP 139
55908: PUSH
55909: LD_VAR 0 2
55913: ARRAY
55914: LESSEQUAL
55915: OR
55916: IFFALSE 55920
// continue ;
55918: GO 55170
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55920: LD_ADDR_VAR 0 6
55924: PUSH
55925: LD_EXP 99
55929: PUSH
55930: LD_VAR 0 2
55934: ARRAY
55935: PPUSH
55936: LD_INT 25
55938: PUSH
55939: LD_INT 3
55941: PUSH
55942: EMPTY
55943: LIST
55944: LIST
55945: PPUSH
55946: CALL_OW 72
55950: PUSH
55951: LD_EXP 139
55955: PUSH
55956: LD_VAR 0 2
55960: ARRAY
55961: DIFF
55962: PPUSH
55963: LD_INT 3
55965: PPUSH
55966: CALL 105447 0 2
55970: ST_TO_ADDR
// for j in tmp do
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_VAR 0 6
55980: PUSH
55981: FOR_IN
55982: IFFALSE 56017
// if GetTag ( j ) > 0 then
55984: LD_VAR 0 3
55988: PPUSH
55989: CALL_OW 110
55993: PUSH
55994: LD_INT 0
55996: GREATER
55997: IFFALSE 56015
// tmp := tmp diff j ;
55999: LD_ADDR_VAR 0 6
56003: PUSH
56004: LD_VAR 0 6
56008: PUSH
56009: LD_VAR 0 3
56013: DIFF
56014: ST_TO_ADDR
56015: GO 55981
56017: POP
56018: POP
// if not tmp then
56019: LD_VAR 0 6
56023: NOT
56024: IFFALSE 56028
// continue ;
56026: GO 55170
// if places then
56028: LD_VAR 0 5
56032: IFFALSE 56091
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56034: LD_ADDR_EXP 139
56038: PUSH
56039: LD_EXP 139
56043: PPUSH
56044: LD_VAR 0 2
56048: PPUSH
56049: LD_EXP 139
56053: PUSH
56054: LD_VAR 0 2
56058: ARRAY
56059: PUSH
56060: LD_VAR 0 6
56064: PUSH
56065: LD_INT 1
56067: ARRAY
56068: UNION
56069: PPUSH
56070: CALL_OW 1
56074: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56075: LD_VAR 0 6
56079: PUSH
56080: LD_INT 1
56082: ARRAY
56083: PPUSH
56084: LD_INT 126
56086: PPUSH
56087: CALL_OW 109
// end ; end ;
56091: GO 55170
56093: POP
56094: POP
// end ;
56095: LD_VAR 0 1
56099: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56100: LD_INT 0
56102: PPUSH
56103: PPUSH
56104: PPUSH
56105: PPUSH
56106: PPUSH
56107: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56108: LD_VAR 0 1
56112: NOT
56113: PUSH
56114: LD_VAR 0 2
56118: NOT
56119: OR
56120: PUSH
56121: LD_VAR 0 3
56125: NOT
56126: OR
56127: PUSH
56128: LD_VAR 0 4
56132: PUSH
56133: LD_INT 1
56135: PUSH
56136: LD_INT 2
56138: PUSH
56139: LD_INT 3
56141: PUSH
56142: LD_INT 4
56144: PUSH
56145: LD_INT 5
56147: PUSH
56148: LD_INT 8
56150: PUSH
56151: LD_INT 9
56153: PUSH
56154: LD_INT 15
56156: PUSH
56157: LD_INT 16
56159: PUSH
56160: EMPTY
56161: LIST
56162: LIST
56163: LIST
56164: LIST
56165: LIST
56166: LIST
56167: LIST
56168: LIST
56169: LIST
56170: IN
56171: NOT
56172: OR
56173: IFFALSE 56177
// exit ;
56175: GO 57077
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56177: LD_ADDR_VAR 0 2
56181: PUSH
56182: LD_VAR 0 2
56186: PPUSH
56187: LD_INT 21
56189: PUSH
56190: LD_INT 3
56192: PUSH
56193: EMPTY
56194: LIST
56195: LIST
56196: PUSH
56197: LD_INT 24
56199: PUSH
56200: LD_INT 250
56202: PUSH
56203: EMPTY
56204: LIST
56205: LIST
56206: PUSH
56207: EMPTY
56208: LIST
56209: LIST
56210: PPUSH
56211: CALL_OW 72
56215: ST_TO_ADDR
// case class of 1 , 15 :
56216: LD_VAR 0 4
56220: PUSH
56221: LD_INT 1
56223: DOUBLE
56224: EQUAL
56225: IFTRUE 56235
56227: LD_INT 15
56229: DOUBLE
56230: EQUAL
56231: IFTRUE 56235
56233: GO 56320
56235: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56236: LD_ADDR_VAR 0 8
56240: PUSH
56241: LD_VAR 0 2
56245: PPUSH
56246: LD_INT 2
56248: PUSH
56249: LD_INT 30
56251: PUSH
56252: LD_INT 32
56254: PUSH
56255: EMPTY
56256: LIST
56257: LIST
56258: PUSH
56259: LD_INT 30
56261: PUSH
56262: LD_INT 31
56264: PUSH
56265: EMPTY
56266: LIST
56267: LIST
56268: PUSH
56269: EMPTY
56270: LIST
56271: LIST
56272: LIST
56273: PPUSH
56274: CALL_OW 72
56278: PUSH
56279: LD_VAR 0 2
56283: PPUSH
56284: LD_INT 2
56286: PUSH
56287: LD_INT 30
56289: PUSH
56290: LD_INT 4
56292: PUSH
56293: EMPTY
56294: LIST
56295: LIST
56296: PUSH
56297: LD_INT 30
56299: PUSH
56300: LD_INT 5
56302: PUSH
56303: EMPTY
56304: LIST
56305: LIST
56306: PUSH
56307: EMPTY
56308: LIST
56309: LIST
56310: LIST
56311: PPUSH
56312: CALL_OW 72
56316: ADD
56317: ST_TO_ADDR
56318: GO 56566
56320: LD_INT 2
56322: DOUBLE
56323: EQUAL
56324: IFTRUE 56334
56326: LD_INT 16
56328: DOUBLE
56329: EQUAL
56330: IFTRUE 56334
56332: GO 56380
56334: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56335: LD_ADDR_VAR 0 8
56339: PUSH
56340: LD_VAR 0 2
56344: PPUSH
56345: LD_INT 2
56347: PUSH
56348: LD_INT 30
56350: PUSH
56351: LD_INT 0
56353: PUSH
56354: EMPTY
56355: LIST
56356: LIST
56357: PUSH
56358: LD_INT 30
56360: PUSH
56361: LD_INT 1
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: LIST
56372: PPUSH
56373: CALL_OW 72
56377: ST_TO_ADDR
56378: GO 56566
56380: LD_INT 3
56382: DOUBLE
56383: EQUAL
56384: IFTRUE 56388
56386: GO 56434
56388: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56389: LD_ADDR_VAR 0 8
56393: PUSH
56394: LD_VAR 0 2
56398: PPUSH
56399: LD_INT 2
56401: PUSH
56402: LD_INT 30
56404: PUSH
56405: LD_INT 2
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: PUSH
56412: LD_INT 30
56414: PUSH
56415: LD_INT 3
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: PUSH
56422: EMPTY
56423: LIST
56424: LIST
56425: LIST
56426: PPUSH
56427: CALL_OW 72
56431: ST_TO_ADDR
56432: GO 56566
56434: LD_INT 4
56436: DOUBLE
56437: EQUAL
56438: IFTRUE 56442
56440: GO 56499
56442: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56443: LD_ADDR_VAR 0 8
56447: PUSH
56448: LD_VAR 0 2
56452: PPUSH
56453: LD_INT 2
56455: PUSH
56456: LD_INT 30
56458: PUSH
56459: LD_INT 6
56461: PUSH
56462: EMPTY
56463: LIST
56464: LIST
56465: PUSH
56466: LD_INT 30
56468: PUSH
56469: LD_INT 7
56471: PUSH
56472: EMPTY
56473: LIST
56474: LIST
56475: PUSH
56476: LD_INT 30
56478: PUSH
56479: LD_INT 8
56481: PUSH
56482: EMPTY
56483: LIST
56484: LIST
56485: PUSH
56486: EMPTY
56487: LIST
56488: LIST
56489: LIST
56490: LIST
56491: PPUSH
56492: CALL_OW 72
56496: ST_TO_ADDR
56497: GO 56566
56499: LD_INT 5
56501: DOUBLE
56502: EQUAL
56503: IFTRUE 56519
56505: LD_INT 8
56507: DOUBLE
56508: EQUAL
56509: IFTRUE 56519
56511: LD_INT 9
56513: DOUBLE
56514: EQUAL
56515: IFTRUE 56519
56517: GO 56565
56519: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56520: LD_ADDR_VAR 0 8
56524: PUSH
56525: LD_VAR 0 2
56529: PPUSH
56530: LD_INT 2
56532: PUSH
56533: LD_INT 30
56535: PUSH
56536: LD_INT 4
56538: PUSH
56539: EMPTY
56540: LIST
56541: LIST
56542: PUSH
56543: LD_INT 30
56545: PUSH
56546: LD_INT 5
56548: PUSH
56549: EMPTY
56550: LIST
56551: LIST
56552: PUSH
56553: EMPTY
56554: LIST
56555: LIST
56556: LIST
56557: PPUSH
56558: CALL_OW 72
56562: ST_TO_ADDR
56563: GO 56566
56565: POP
// if not tmp then
56566: LD_VAR 0 8
56570: NOT
56571: IFFALSE 56575
// exit ;
56573: GO 57077
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56575: LD_VAR 0 4
56579: PUSH
56580: LD_INT 1
56582: PUSH
56583: LD_INT 15
56585: PUSH
56586: EMPTY
56587: LIST
56588: LIST
56589: IN
56590: PUSH
56591: LD_EXP 108
56595: PUSH
56596: LD_VAR 0 1
56600: ARRAY
56601: AND
56602: IFFALSE 56758
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56604: LD_ADDR_VAR 0 9
56608: PUSH
56609: LD_EXP 108
56613: PUSH
56614: LD_VAR 0 1
56618: ARRAY
56619: PUSH
56620: LD_INT 1
56622: ARRAY
56623: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56624: LD_VAR 0 9
56628: PUSH
56629: LD_EXP 109
56633: PUSH
56634: LD_VAR 0 1
56638: ARRAY
56639: IN
56640: NOT
56641: IFFALSE 56756
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56643: LD_ADDR_EXP 109
56647: PUSH
56648: LD_EXP 109
56652: PPUSH
56653: LD_VAR 0 1
56657: PUSH
56658: LD_EXP 109
56662: PUSH
56663: LD_VAR 0 1
56667: ARRAY
56668: PUSH
56669: LD_INT 1
56671: PLUS
56672: PUSH
56673: EMPTY
56674: LIST
56675: LIST
56676: PPUSH
56677: LD_VAR 0 9
56681: PPUSH
56682: CALL 71199 0 3
56686: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56687: LD_ADDR_EXP 108
56691: PUSH
56692: LD_EXP 108
56696: PPUSH
56697: LD_VAR 0 1
56701: PPUSH
56702: LD_EXP 108
56706: PUSH
56707: LD_VAR 0 1
56711: ARRAY
56712: PUSH
56713: LD_VAR 0 9
56717: DIFF
56718: PPUSH
56719: CALL_OW 1
56723: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56724: LD_VAR 0 3
56728: PPUSH
56729: LD_EXP 109
56733: PUSH
56734: LD_VAR 0 1
56738: ARRAY
56739: PUSH
56740: LD_EXP 109
56744: PUSH
56745: LD_VAR 0 1
56749: ARRAY
56750: ARRAY
56751: PPUSH
56752: CALL_OW 120
// end ; exit ;
56756: GO 57077
// end ; if tmp > 1 then
56758: LD_VAR 0 8
56762: PUSH
56763: LD_INT 1
56765: GREATER
56766: IFFALSE 56870
// for i = 2 to tmp do
56768: LD_ADDR_VAR 0 6
56772: PUSH
56773: DOUBLE
56774: LD_INT 2
56776: DEC
56777: ST_TO_ADDR
56778: LD_VAR 0 8
56782: PUSH
56783: FOR_TO
56784: IFFALSE 56868
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56786: LD_VAR 0 8
56790: PUSH
56791: LD_VAR 0 6
56795: ARRAY
56796: PPUSH
56797: CALL_OW 461
56801: PUSH
56802: LD_INT 6
56804: EQUAL
56805: IFFALSE 56866
// begin x := tmp [ i ] ;
56807: LD_ADDR_VAR 0 9
56811: PUSH
56812: LD_VAR 0 8
56816: PUSH
56817: LD_VAR 0 6
56821: ARRAY
56822: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56823: LD_ADDR_VAR 0 8
56827: PUSH
56828: LD_VAR 0 8
56832: PPUSH
56833: LD_VAR 0 6
56837: PPUSH
56838: CALL_OW 3
56842: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56843: LD_ADDR_VAR 0 8
56847: PUSH
56848: LD_VAR 0 8
56852: PPUSH
56853: LD_INT 1
56855: PPUSH
56856: LD_VAR 0 9
56860: PPUSH
56861: CALL_OW 2
56865: ST_TO_ADDR
// end ;
56866: GO 56783
56868: POP
56869: POP
// for i in tmp do
56870: LD_ADDR_VAR 0 6
56874: PUSH
56875: LD_VAR 0 8
56879: PUSH
56880: FOR_IN
56881: IFFALSE 56950
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56883: LD_VAR 0 6
56887: PPUSH
56888: CALL_OW 313
56892: PUSH
56893: LD_INT 6
56895: LESS
56896: PUSH
56897: LD_VAR 0 6
56901: PPUSH
56902: CALL_OW 266
56906: PUSH
56907: LD_INT 31
56909: PUSH
56910: LD_INT 32
56912: PUSH
56913: EMPTY
56914: LIST
56915: LIST
56916: IN
56917: NOT
56918: AND
56919: PUSH
56920: LD_VAR 0 6
56924: PPUSH
56925: CALL_OW 313
56929: PUSH
56930: LD_INT 0
56932: EQUAL
56933: OR
56934: IFFALSE 56948
// begin j := i ;
56936: LD_ADDR_VAR 0 7
56940: PUSH
56941: LD_VAR 0 6
56945: ST_TO_ADDR
// break ;
56946: GO 56950
// end ; end ;
56948: GO 56880
56950: POP
56951: POP
// if j then
56952: LD_VAR 0 7
56956: IFFALSE 56974
// ComEnterUnit ( unit , j ) else
56958: LD_VAR 0 3
56962: PPUSH
56963: LD_VAR 0 7
56967: PPUSH
56968: CALL_OW 120
56972: GO 57077
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56974: LD_ADDR_VAR 0 10
56978: PUSH
56979: LD_VAR 0 2
56983: PPUSH
56984: LD_INT 2
56986: PUSH
56987: LD_INT 30
56989: PUSH
56990: LD_INT 0
56992: PUSH
56993: EMPTY
56994: LIST
56995: LIST
56996: PUSH
56997: LD_INT 30
56999: PUSH
57000: LD_INT 1
57002: PUSH
57003: EMPTY
57004: LIST
57005: LIST
57006: PUSH
57007: EMPTY
57008: LIST
57009: LIST
57010: LIST
57011: PPUSH
57012: CALL_OW 72
57016: ST_TO_ADDR
// if depot then
57017: LD_VAR 0 10
57021: IFFALSE 57077
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57023: LD_ADDR_VAR 0 10
57027: PUSH
57028: LD_VAR 0 10
57032: PPUSH
57033: LD_VAR 0 3
57037: PPUSH
57038: CALL_OW 74
57042: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57043: LD_VAR 0 3
57047: PPUSH
57048: LD_VAR 0 10
57052: PPUSH
57053: CALL_OW 296
57057: PUSH
57058: LD_INT 10
57060: GREATER
57061: IFFALSE 57077
// ComStandNearbyBuilding ( unit , depot ) ;
57063: LD_VAR 0 3
57067: PPUSH
57068: LD_VAR 0 10
57072: PPUSH
57073: CALL 65491 0 2
// end ; end ; end ;
57077: LD_VAR 0 5
57081: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57082: LD_INT 0
57084: PPUSH
57085: PPUSH
57086: PPUSH
57087: PPUSH
// if not mc_bases then
57088: LD_EXP 99
57092: NOT
57093: IFFALSE 57097
// exit ;
57095: GO 57336
// for i = 1 to mc_bases do
57097: LD_ADDR_VAR 0 2
57101: PUSH
57102: DOUBLE
57103: LD_INT 1
57105: DEC
57106: ST_TO_ADDR
57107: LD_EXP 99
57111: PUSH
57112: FOR_TO
57113: IFFALSE 57334
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57115: LD_ADDR_VAR 0 4
57119: PUSH
57120: LD_EXP 99
57124: PUSH
57125: LD_VAR 0 2
57129: ARRAY
57130: PPUSH
57131: LD_INT 21
57133: PUSH
57134: LD_INT 1
57136: PUSH
57137: EMPTY
57138: LIST
57139: LIST
57140: PPUSH
57141: CALL_OW 72
57145: PUSH
57146: LD_EXP 128
57150: PUSH
57151: LD_VAR 0 2
57155: ARRAY
57156: UNION
57157: ST_TO_ADDR
// if not tmp then
57158: LD_VAR 0 4
57162: NOT
57163: IFFALSE 57167
// continue ;
57165: GO 57112
// for j in tmp do
57167: LD_ADDR_VAR 0 3
57171: PUSH
57172: LD_VAR 0 4
57176: PUSH
57177: FOR_IN
57178: IFFALSE 57330
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57180: LD_VAR 0 3
57184: PPUSH
57185: CALL_OW 110
57189: NOT
57190: PUSH
57191: LD_VAR 0 3
57195: PPUSH
57196: CALL_OW 314
57200: NOT
57201: AND
57202: PUSH
57203: LD_VAR 0 3
57207: PPUSH
57208: CALL_OW 311
57212: NOT
57213: AND
57214: PUSH
57215: LD_VAR 0 3
57219: PPUSH
57220: CALL_OW 310
57224: NOT
57225: AND
57226: PUSH
57227: LD_VAR 0 3
57231: PUSH
57232: LD_EXP 102
57236: PUSH
57237: LD_VAR 0 2
57241: ARRAY
57242: PUSH
57243: LD_INT 1
57245: ARRAY
57246: IN
57247: NOT
57248: AND
57249: PUSH
57250: LD_VAR 0 3
57254: PUSH
57255: LD_EXP 102
57259: PUSH
57260: LD_VAR 0 2
57264: ARRAY
57265: PUSH
57266: LD_INT 2
57268: ARRAY
57269: IN
57270: NOT
57271: AND
57272: PUSH
57273: LD_VAR 0 3
57277: PUSH
57278: LD_EXP 111
57282: PUSH
57283: LD_VAR 0 2
57287: ARRAY
57288: IN
57289: NOT
57290: AND
57291: IFFALSE 57328
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57293: LD_VAR 0 2
57297: PPUSH
57298: LD_EXP 99
57302: PUSH
57303: LD_VAR 0 2
57307: ARRAY
57308: PPUSH
57309: LD_VAR 0 3
57313: PPUSH
57314: LD_VAR 0 3
57318: PPUSH
57319: CALL_OW 257
57323: PPUSH
57324: CALL 56100 0 4
// end ;
57328: GO 57177
57330: POP
57331: POP
// end ;
57332: GO 57112
57334: POP
57335: POP
// end ;
57336: LD_VAR 0 1
57340: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57341: LD_INT 0
57343: PPUSH
57344: PPUSH
57345: PPUSH
57346: PPUSH
57347: PPUSH
57348: PPUSH
// if not mc_bases [ base ] then
57349: LD_EXP 99
57353: PUSH
57354: LD_VAR 0 1
57358: ARRAY
57359: NOT
57360: IFFALSE 57364
// exit ;
57362: GO 57546
// tmp := [ ] ;
57364: LD_ADDR_VAR 0 6
57368: PUSH
57369: EMPTY
57370: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57371: LD_ADDR_VAR 0 7
57375: PUSH
57376: LD_VAR 0 3
57380: PPUSH
57381: LD_INT 0
57383: PPUSH
57384: CALL_OW 517
57388: ST_TO_ADDR
// if not list then
57389: LD_VAR 0 7
57393: NOT
57394: IFFALSE 57398
// exit ;
57396: GO 57546
// for i = 1 to amount do
57398: LD_ADDR_VAR 0 5
57402: PUSH
57403: DOUBLE
57404: LD_INT 1
57406: DEC
57407: ST_TO_ADDR
57408: LD_VAR 0 2
57412: PUSH
57413: FOR_TO
57414: IFFALSE 57494
// begin x := rand ( 1 , list [ 1 ] ) ;
57416: LD_ADDR_VAR 0 8
57420: PUSH
57421: LD_INT 1
57423: PPUSH
57424: LD_VAR 0 7
57428: PUSH
57429: LD_INT 1
57431: ARRAY
57432: PPUSH
57433: CALL_OW 12
57437: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57438: LD_ADDR_VAR 0 6
57442: PUSH
57443: LD_VAR 0 6
57447: PPUSH
57448: LD_VAR 0 5
57452: PPUSH
57453: LD_VAR 0 7
57457: PUSH
57458: LD_INT 1
57460: ARRAY
57461: PUSH
57462: LD_VAR 0 8
57466: ARRAY
57467: PUSH
57468: LD_VAR 0 7
57472: PUSH
57473: LD_INT 2
57475: ARRAY
57476: PUSH
57477: LD_VAR 0 8
57481: ARRAY
57482: PUSH
57483: EMPTY
57484: LIST
57485: LIST
57486: PPUSH
57487: CALL_OW 1
57491: ST_TO_ADDR
// end ;
57492: GO 57413
57494: POP
57495: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57496: LD_ADDR_EXP 112
57500: PUSH
57501: LD_EXP 112
57505: PPUSH
57506: LD_VAR 0 1
57510: PPUSH
57511: LD_VAR 0 6
57515: PPUSH
57516: CALL_OW 1
57520: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57521: LD_ADDR_EXP 114
57525: PUSH
57526: LD_EXP 114
57530: PPUSH
57531: LD_VAR 0 1
57535: PPUSH
57536: LD_VAR 0 3
57540: PPUSH
57541: CALL_OW 1
57545: ST_TO_ADDR
// end ;
57546: LD_VAR 0 4
57550: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57551: LD_INT 0
57553: PPUSH
// if not mc_bases [ base ] then
57554: LD_EXP 99
57558: PUSH
57559: LD_VAR 0 1
57563: ARRAY
57564: NOT
57565: IFFALSE 57569
// exit ;
57567: GO 57594
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57569: LD_ADDR_EXP 104
57573: PUSH
57574: LD_EXP 104
57578: PPUSH
57579: LD_VAR 0 1
57583: PPUSH
57584: LD_VAR 0 2
57588: PPUSH
57589: CALL_OW 1
57593: ST_TO_ADDR
// end ;
57594: LD_VAR 0 3
57598: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57599: LD_INT 0
57601: PPUSH
// if not mc_bases [ base ] then
57602: LD_EXP 99
57606: PUSH
57607: LD_VAR 0 1
57611: ARRAY
57612: NOT
57613: IFFALSE 57617
// exit ;
57615: GO 57654
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57617: LD_ADDR_EXP 104
57621: PUSH
57622: LD_EXP 104
57626: PPUSH
57627: LD_VAR 0 1
57631: PPUSH
57632: LD_EXP 104
57636: PUSH
57637: LD_VAR 0 1
57641: ARRAY
57642: PUSH
57643: LD_VAR 0 2
57647: UNION
57648: PPUSH
57649: CALL_OW 1
57653: ST_TO_ADDR
// end ;
57654: LD_VAR 0 3
57658: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57659: LD_INT 0
57661: PPUSH
// if not mc_bases [ base ] then
57662: LD_EXP 99
57666: PUSH
57667: LD_VAR 0 1
57671: ARRAY
57672: NOT
57673: IFFALSE 57677
// exit ;
57675: GO 57702
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57677: LD_ADDR_EXP 120
57681: PUSH
57682: LD_EXP 120
57686: PPUSH
57687: LD_VAR 0 1
57691: PPUSH
57692: LD_VAR 0 2
57696: PPUSH
57697: CALL_OW 1
57701: ST_TO_ADDR
// end ;
57702: LD_VAR 0 3
57706: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57707: LD_INT 0
57709: PPUSH
// if not mc_bases [ base ] then
57710: LD_EXP 99
57714: PUSH
57715: LD_VAR 0 1
57719: ARRAY
57720: NOT
57721: IFFALSE 57725
// exit ;
57723: GO 57762
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57725: LD_ADDR_EXP 120
57729: PUSH
57730: LD_EXP 120
57734: PPUSH
57735: LD_VAR 0 1
57739: PPUSH
57740: LD_EXP 120
57744: PUSH
57745: LD_VAR 0 1
57749: ARRAY
57750: PUSH
57751: LD_VAR 0 2
57755: ADD
57756: PPUSH
57757: CALL_OW 1
57761: ST_TO_ADDR
// end ;
57762: LD_VAR 0 3
57766: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57767: LD_INT 0
57769: PPUSH
// if not mc_bases [ base ] then
57770: LD_EXP 99
57774: PUSH
57775: LD_VAR 0 1
57779: ARRAY
57780: NOT
57781: IFFALSE 57785
// exit ;
57783: GO 57839
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57785: LD_ADDR_EXP 121
57789: PUSH
57790: LD_EXP 121
57794: PPUSH
57795: LD_VAR 0 1
57799: PPUSH
57800: LD_VAR 0 2
57804: PPUSH
57805: CALL_OW 1
57809: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57810: LD_ADDR_EXP 110
57814: PUSH
57815: LD_EXP 110
57819: PPUSH
57820: LD_VAR 0 1
57824: PPUSH
57825: LD_VAR 0 2
57829: PUSH
57830: LD_INT 0
57832: PLUS
57833: PPUSH
57834: CALL_OW 1
57838: ST_TO_ADDR
// end ;
57839: LD_VAR 0 3
57843: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57844: LD_INT 0
57846: PPUSH
// if not mc_bases [ base ] then
57847: LD_EXP 99
57851: PUSH
57852: LD_VAR 0 1
57856: ARRAY
57857: NOT
57858: IFFALSE 57862
// exit ;
57860: GO 57887
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57862: LD_ADDR_EXP 110
57866: PUSH
57867: LD_EXP 110
57871: PPUSH
57872: LD_VAR 0 1
57876: PPUSH
57877: LD_VAR 0 2
57881: PPUSH
57882: CALL_OW 1
57886: ST_TO_ADDR
// end ;
57887: LD_VAR 0 3
57891: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57892: LD_INT 0
57894: PPUSH
57895: PPUSH
57896: PPUSH
57897: PPUSH
// if not mc_bases [ base ] then
57898: LD_EXP 99
57902: PUSH
57903: LD_VAR 0 1
57907: ARRAY
57908: NOT
57909: IFFALSE 57913
// exit ;
57911: GO 57978
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57913: LD_ADDR_EXP 119
57917: PUSH
57918: LD_EXP 119
57922: PPUSH
57923: LD_VAR 0 1
57927: PUSH
57928: LD_EXP 119
57932: PUSH
57933: LD_VAR 0 1
57937: ARRAY
57938: PUSH
57939: LD_INT 1
57941: PLUS
57942: PUSH
57943: EMPTY
57944: LIST
57945: LIST
57946: PPUSH
57947: LD_VAR 0 1
57951: PUSH
57952: LD_VAR 0 2
57956: PUSH
57957: LD_VAR 0 3
57961: PUSH
57962: LD_VAR 0 4
57966: PUSH
57967: EMPTY
57968: LIST
57969: LIST
57970: LIST
57971: LIST
57972: PPUSH
57973: CALL 71199 0 3
57977: ST_TO_ADDR
// end ;
57978: LD_VAR 0 5
57982: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57983: LD_INT 0
57985: PPUSH
// if not mc_bases [ base ] then
57986: LD_EXP 99
57990: PUSH
57991: LD_VAR 0 1
57995: ARRAY
57996: NOT
57997: IFFALSE 58001
// exit ;
57999: GO 58026
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58001: LD_ADDR_EXP 136
58005: PUSH
58006: LD_EXP 136
58010: PPUSH
58011: LD_VAR 0 1
58015: PPUSH
58016: LD_VAR 0 2
58020: PPUSH
58021: CALL_OW 1
58025: ST_TO_ADDR
// end ;
58026: LD_VAR 0 3
58030: RET
// export function MC_GetMinesField ( base ) ; begin
58031: LD_INT 0
58033: PPUSH
// result := mc_mines [ base ] ;
58034: LD_ADDR_VAR 0 2
58038: PUSH
58039: LD_EXP 112
58043: PUSH
58044: LD_VAR 0 1
58048: ARRAY
58049: ST_TO_ADDR
// end ;
58050: LD_VAR 0 2
58054: RET
// export function MC_GetProduceList ( base ) ; begin
58055: LD_INT 0
58057: PPUSH
// result := mc_produce [ base ] ;
58058: LD_ADDR_VAR 0 2
58062: PUSH
58063: LD_EXP 120
58067: PUSH
58068: LD_VAR 0 1
58072: ARRAY
58073: ST_TO_ADDR
// end ;
58074: LD_VAR 0 2
58078: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58079: LD_INT 0
58081: PPUSH
58082: PPUSH
// if not mc_bases then
58083: LD_EXP 99
58087: NOT
58088: IFFALSE 58092
// exit ;
58090: GO 58157
// if mc_bases [ base ] then
58092: LD_EXP 99
58096: PUSH
58097: LD_VAR 0 1
58101: ARRAY
58102: IFFALSE 58157
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58104: LD_ADDR_VAR 0 3
58108: PUSH
58109: LD_EXP 99
58113: PUSH
58114: LD_VAR 0 1
58118: ARRAY
58119: PPUSH
58120: LD_INT 30
58122: PUSH
58123: LD_VAR 0 2
58127: PUSH
58128: EMPTY
58129: LIST
58130: LIST
58131: PPUSH
58132: CALL_OW 72
58136: ST_TO_ADDR
// if result then
58137: LD_VAR 0 3
58141: IFFALSE 58157
// result := result [ 1 ] ;
58143: LD_ADDR_VAR 0 3
58147: PUSH
58148: LD_VAR 0 3
58152: PUSH
58153: LD_INT 1
58155: ARRAY
58156: ST_TO_ADDR
// end ; end ;
58157: LD_VAR 0 3
58161: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58162: LD_INT 0
58164: PPUSH
58165: PPUSH
// if not mc_bases then
58166: LD_EXP 99
58170: NOT
58171: IFFALSE 58175
// exit ;
58173: GO 58220
// if mc_bases [ base ] then
58175: LD_EXP 99
58179: PUSH
58180: LD_VAR 0 1
58184: ARRAY
58185: IFFALSE 58220
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58187: LD_ADDR_VAR 0 3
58191: PUSH
58192: LD_EXP 99
58196: PUSH
58197: LD_VAR 0 1
58201: ARRAY
58202: PPUSH
58203: LD_INT 30
58205: PUSH
58206: LD_VAR 0 2
58210: PUSH
58211: EMPTY
58212: LIST
58213: LIST
58214: PPUSH
58215: CALL_OW 72
58219: ST_TO_ADDR
// end ;
58220: LD_VAR 0 3
58224: RET
// export function MC_SetTame ( base , area ) ; begin
58225: LD_INT 0
58227: PPUSH
// if not mc_bases or not base then
58228: LD_EXP 99
58232: NOT
58233: PUSH
58234: LD_VAR 0 1
58238: NOT
58239: OR
58240: IFFALSE 58244
// exit ;
58242: GO 58269
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58244: LD_ADDR_EXP 127
58248: PUSH
58249: LD_EXP 127
58253: PPUSH
58254: LD_VAR 0 1
58258: PPUSH
58259: LD_VAR 0 2
58263: PPUSH
58264: CALL_OW 1
58268: ST_TO_ADDR
// end ;
58269: LD_VAR 0 3
58273: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58274: LD_INT 0
58276: PPUSH
58277: PPUSH
// if not mc_bases or not base then
58278: LD_EXP 99
58282: NOT
58283: PUSH
58284: LD_VAR 0 1
58288: NOT
58289: OR
58290: IFFALSE 58294
// exit ;
58292: GO 58396
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58294: LD_ADDR_VAR 0 4
58298: PUSH
58299: LD_EXP 99
58303: PUSH
58304: LD_VAR 0 1
58308: ARRAY
58309: PPUSH
58310: LD_INT 30
58312: PUSH
58313: LD_VAR 0 2
58317: PUSH
58318: EMPTY
58319: LIST
58320: LIST
58321: PPUSH
58322: CALL_OW 72
58326: ST_TO_ADDR
// if not tmp then
58327: LD_VAR 0 4
58331: NOT
58332: IFFALSE 58336
// exit ;
58334: GO 58396
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58336: LD_ADDR_EXP 131
58340: PUSH
58341: LD_EXP 131
58345: PPUSH
58346: LD_VAR 0 1
58350: PPUSH
58351: LD_EXP 131
58355: PUSH
58356: LD_VAR 0 1
58360: ARRAY
58361: PPUSH
58362: LD_EXP 131
58366: PUSH
58367: LD_VAR 0 1
58371: ARRAY
58372: PUSH
58373: LD_INT 1
58375: PLUS
58376: PPUSH
58377: LD_VAR 0 4
58381: PUSH
58382: LD_INT 1
58384: ARRAY
58385: PPUSH
58386: CALL_OW 2
58390: PPUSH
58391: CALL_OW 1
58395: ST_TO_ADDR
// end ;
58396: LD_VAR 0 3
58400: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58401: LD_INT 0
58403: PPUSH
58404: PPUSH
// if not mc_bases or not base or not kinds then
58405: LD_EXP 99
58409: NOT
58410: PUSH
58411: LD_VAR 0 1
58415: NOT
58416: OR
58417: PUSH
58418: LD_VAR 0 2
58422: NOT
58423: OR
58424: IFFALSE 58428
// exit ;
58426: GO 58489
// for i in kinds do
58428: LD_ADDR_VAR 0 4
58432: PUSH
58433: LD_VAR 0 2
58437: PUSH
58438: FOR_IN
58439: IFFALSE 58487
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58441: LD_ADDR_EXP 133
58445: PUSH
58446: LD_EXP 133
58450: PPUSH
58451: LD_VAR 0 1
58455: PUSH
58456: LD_EXP 133
58460: PUSH
58461: LD_VAR 0 1
58465: ARRAY
58466: PUSH
58467: LD_INT 1
58469: PLUS
58470: PUSH
58471: EMPTY
58472: LIST
58473: LIST
58474: PPUSH
58475: LD_VAR 0 4
58479: PPUSH
58480: CALL 71199 0 3
58484: ST_TO_ADDR
58485: GO 58438
58487: POP
58488: POP
// end ;
58489: LD_VAR 0 3
58493: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58494: LD_INT 0
58496: PPUSH
// if not mc_bases or not base or not areas then
58497: LD_EXP 99
58501: NOT
58502: PUSH
58503: LD_VAR 0 1
58507: NOT
58508: OR
58509: PUSH
58510: LD_VAR 0 2
58514: NOT
58515: OR
58516: IFFALSE 58520
// exit ;
58518: GO 58545
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58520: LD_ADDR_EXP 117
58524: PUSH
58525: LD_EXP 117
58529: PPUSH
58530: LD_VAR 0 1
58534: PPUSH
58535: LD_VAR 0 2
58539: PPUSH
58540: CALL_OW 1
58544: ST_TO_ADDR
// end ;
58545: LD_VAR 0 3
58549: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58550: LD_INT 0
58552: PPUSH
// if not mc_bases or not base or not teleports_exit then
58553: LD_EXP 99
58557: NOT
58558: PUSH
58559: LD_VAR 0 1
58563: NOT
58564: OR
58565: PUSH
58566: LD_VAR 0 2
58570: NOT
58571: OR
58572: IFFALSE 58576
// exit ;
58574: GO 58601
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58576: LD_ADDR_EXP 134
58580: PUSH
58581: LD_EXP 134
58585: PPUSH
58586: LD_VAR 0 1
58590: PPUSH
58591: LD_VAR 0 2
58595: PPUSH
58596: CALL_OW 1
58600: ST_TO_ADDR
// end ;
58601: LD_VAR 0 3
58605: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58606: LD_INT 0
58608: PPUSH
58609: PPUSH
58610: PPUSH
// if not mc_bases or not base or not ext_list then
58611: LD_EXP 99
58615: NOT
58616: PUSH
58617: LD_VAR 0 1
58621: NOT
58622: OR
58623: PUSH
58624: LD_VAR 0 5
58628: NOT
58629: OR
58630: IFFALSE 58634
// exit ;
58632: GO 58807
// tmp := GetFacExtXYD ( x , y , d ) ;
58634: LD_ADDR_VAR 0 8
58638: PUSH
58639: LD_VAR 0 2
58643: PPUSH
58644: LD_VAR 0 3
58648: PPUSH
58649: LD_VAR 0 4
58653: PPUSH
58654: CALL 104577 0 3
58658: ST_TO_ADDR
// if not tmp then
58659: LD_VAR 0 8
58663: NOT
58664: IFFALSE 58668
// exit ;
58666: GO 58807
// for i in tmp do
58668: LD_ADDR_VAR 0 7
58672: PUSH
58673: LD_VAR 0 8
58677: PUSH
58678: FOR_IN
58679: IFFALSE 58805
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58681: LD_ADDR_EXP 104
58685: PUSH
58686: LD_EXP 104
58690: PPUSH
58691: LD_VAR 0 1
58695: PPUSH
58696: LD_EXP 104
58700: PUSH
58701: LD_VAR 0 1
58705: ARRAY
58706: PPUSH
58707: LD_EXP 104
58711: PUSH
58712: LD_VAR 0 1
58716: ARRAY
58717: PUSH
58718: LD_INT 1
58720: PLUS
58721: PPUSH
58722: LD_VAR 0 5
58726: PUSH
58727: LD_INT 1
58729: ARRAY
58730: PUSH
58731: LD_VAR 0 7
58735: PUSH
58736: LD_INT 1
58738: ARRAY
58739: PUSH
58740: LD_VAR 0 7
58744: PUSH
58745: LD_INT 2
58747: ARRAY
58748: PUSH
58749: LD_VAR 0 7
58753: PUSH
58754: LD_INT 3
58756: ARRAY
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: LIST
58762: LIST
58763: PPUSH
58764: CALL_OW 2
58768: PPUSH
58769: CALL_OW 1
58773: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58774: LD_ADDR_VAR 0 5
58778: PUSH
58779: LD_VAR 0 5
58783: PPUSH
58784: LD_INT 1
58786: PPUSH
58787: CALL_OW 3
58791: ST_TO_ADDR
// if not ext_list then
58792: LD_VAR 0 5
58796: NOT
58797: IFFALSE 58803
// exit ;
58799: POP
58800: POP
58801: GO 58807
// end ;
58803: GO 58678
58805: POP
58806: POP
// end ;
58807: LD_VAR 0 6
58811: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58812: LD_INT 0
58814: PPUSH
// if not mc_bases or not base or not weapon_list then
58815: LD_EXP 99
58819: NOT
58820: PUSH
58821: LD_VAR 0 1
58825: NOT
58826: OR
58827: PUSH
58828: LD_VAR 0 2
58832: NOT
58833: OR
58834: IFFALSE 58838
// exit ;
58836: GO 58863
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58838: LD_ADDR_EXP 138
58842: PUSH
58843: LD_EXP 138
58847: PPUSH
58848: LD_VAR 0 1
58852: PPUSH
58853: LD_VAR 0 2
58857: PPUSH
58858: CALL_OW 1
58862: ST_TO_ADDR
// end ;
58863: LD_VAR 0 3
58867: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58868: LD_INT 0
58870: PPUSH
// if not mc_bases or not base or not tech_list then
58871: LD_EXP 99
58875: NOT
58876: PUSH
58877: LD_VAR 0 1
58881: NOT
58882: OR
58883: PUSH
58884: LD_VAR 0 2
58888: NOT
58889: OR
58890: IFFALSE 58894
// exit ;
58892: GO 58919
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58894: LD_ADDR_EXP 126
58898: PUSH
58899: LD_EXP 126
58903: PPUSH
58904: LD_VAR 0 1
58908: PPUSH
58909: LD_VAR 0 2
58913: PPUSH
58914: CALL_OW 1
58918: ST_TO_ADDR
// end ;
58919: LD_VAR 0 3
58923: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58924: LD_INT 0
58926: PPUSH
// if not mc_bases or not parking_area or not base then
58927: LD_EXP 99
58931: NOT
58932: PUSH
58933: LD_VAR 0 2
58937: NOT
58938: OR
58939: PUSH
58940: LD_VAR 0 1
58944: NOT
58945: OR
58946: IFFALSE 58950
// exit ;
58948: GO 58975
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58950: LD_ADDR_EXP 123
58954: PUSH
58955: LD_EXP 123
58959: PPUSH
58960: LD_VAR 0 1
58964: PPUSH
58965: LD_VAR 0 2
58969: PPUSH
58970: CALL_OW 1
58974: ST_TO_ADDR
// end ;
58975: LD_VAR 0 3
58979: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58980: LD_INT 0
58982: PPUSH
// if not mc_bases or not base or not scan_area then
58983: LD_EXP 99
58987: NOT
58988: PUSH
58989: LD_VAR 0 1
58993: NOT
58994: OR
58995: PUSH
58996: LD_VAR 0 2
59000: NOT
59001: OR
59002: IFFALSE 59006
// exit ;
59004: GO 59031
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59006: LD_ADDR_EXP 124
59010: PUSH
59011: LD_EXP 124
59015: PPUSH
59016: LD_VAR 0 1
59020: PPUSH
59021: LD_VAR 0 2
59025: PPUSH
59026: CALL_OW 1
59030: ST_TO_ADDR
// end ;
59031: LD_VAR 0 3
59035: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59036: LD_INT 0
59038: PPUSH
59039: PPUSH
// if not mc_bases or not base then
59040: LD_EXP 99
59044: NOT
59045: PUSH
59046: LD_VAR 0 1
59050: NOT
59051: OR
59052: IFFALSE 59056
// exit ;
59054: GO 59120
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59056: LD_ADDR_VAR 0 3
59060: PUSH
59061: LD_INT 1
59063: PUSH
59064: LD_INT 2
59066: PUSH
59067: LD_INT 3
59069: PUSH
59070: LD_INT 4
59072: PUSH
59073: LD_INT 11
59075: PUSH
59076: EMPTY
59077: LIST
59078: LIST
59079: LIST
59080: LIST
59081: LIST
59082: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59083: LD_ADDR_EXP 126
59087: PUSH
59088: LD_EXP 126
59092: PPUSH
59093: LD_VAR 0 1
59097: PPUSH
59098: LD_EXP 126
59102: PUSH
59103: LD_VAR 0 1
59107: ARRAY
59108: PUSH
59109: LD_VAR 0 3
59113: DIFF
59114: PPUSH
59115: CALL_OW 1
59119: ST_TO_ADDR
// end ;
59120: LD_VAR 0 2
59124: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59125: LD_INT 0
59127: PPUSH
// result := mc_vehicles [ base ] ;
59128: LD_ADDR_VAR 0 3
59132: PUSH
59133: LD_EXP 118
59137: PUSH
59138: LD_VAR 0 1
59142: ARRAY
59143: ST_TO_ADDR
// if onlyCombat then
59144: LD_VAR 0 2
59148: IFFALSE 59313
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59150: LD_ADDR_VAR 0 3
59154: PUSH
59155: LD_VAR 0 3
59159: PUSH
59160: LD_VAR 0 3
59164: PPUSH
59165: LD_INT 2
59167: PUSH
59168: LD_INT 34
59170: PUSH
59171: LD_INT 12
59173: PUSH
59174: EMPTY
59175: LIST
59176: LIST
59177: PUSH
59178: LD_INT 34
59180: PUSH
59181: LD_INT 51
59183: PUSH
59184: EMPTY
59185: LIST
59186: LIST
59187: PUSH
59188: LD_INT 34
59190: PUSH
59191: LD_EXP 93
59195: PUSH
59196: EMPTY
59197: LIST
59198: LIST
59199: PUSH
59200: LD_INT 34
59202: PUSH
59203: LD_INT 32
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: PUSH
59210: LD_INT 34
59212: PUSH
59213: LD_INT 13
59215: PUSH
59216: EMPTY
59217: LIST
59218: LIST
59219: PUSH
59220: LD_INT 34
59222: PUSH
59223: LD_INT 52
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: PUSH
59230: LD_INT 34
59232: PUSH
59233: LD_INT 14
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: PUSH
59240: LD_INT 34
59242: PUSH
59243: LD_INT 53
59245: PUSH
59246: EMPTY
59247: LIST
59248: LIST
59249: PUSH
59250: LD_INT 34
59252: PUSH
59253: LD_EXP 92
59257: PUSH
59258: EMPTY
59259: LIST
59260: LIST
59261: PUSH
59262: LD_INT 34
59264: PUSH
59265: LD_INT 31
59267: PUSH
59268: EMPTY
59269: LIST
59270: LIST
59271: PUSH
59272: LD_INT 34
59274: PUSH
59275: LD_INT 48
59277: PUSH
59278: EMPTY
59279: LIST
59280: LIST
59281: PUSH
59282: LD_INT 34
59284: PUSH
59285: LD_INT 8
59287: PUSH
59288: EMPTY
59289: LIST
59290: LIST
59291: PUSH
59292: EMPTY
59293: LIST
59294: LIST
59295: LIST
59296: LIST
59297: LIST
59298: LIST
59299: LIST
59300: LIST
59301: LIST
59302: LIST
59303: LIST
59304: LIST
59305: LIST
59306: PPUSH
59307: CALL_OW 72
59311: DIFF
59312: ST_TO_ADDR
// end ; end_of_file
59313: LD_VAR 0 3
59317: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59318: LD_INT 0
59320: PPUSH
59321: PPUSH
59322: PPUSH
// if not mc_bases or not skirmish then
59323: LD_EXP 99
59327: NOT
59328: PUSH
59329: LD_EXP 97
59333: NOT
59334: OR
59335: IFFALSE 59339
// exit ;
59337: GO 59504
// for i = 1 to mc_bases do
59339: LD_ADDR_VAR 0 4
59343: PUSH
59344: DOUBLE
59345: LD_INT 1
59347: DEC
59348: ST_TO_ADDR
59349: LD_EXP 99
59353: PUSH
59354: FOR_TO
59355: IFFALSE 59502
// begin if sci in mc_bases [ i ] then
59357: LD_VAR 0 2
59361: PUSH
59362: LD_EXP 99
59366: PUSH
59367: LD_VAR 0 4
59371: ARRAY
59372: IN
59373: IFFALSE 59500
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59375: LD_ADDR_EXP 128
59379: PUSH
59380: LD_EXP 128
59384: PPUSH
59385: LD_VAR 0 4
59389: PUSH
59390: LD_EXP 128
59394: PUSH
59395: LD_VAR 0 4
59399: ARRAY
59400: PUSH
59401: LD_INT 1
59403: PLUS
59404: PUSH
59405: EMPTY
59406: LIST
59407: LIST
59408: PPUSH
59409: LD_VAR 0 1
59413: PPUSH
59414: CALL 71199 0 3
59418: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59419: LD_ADDR_VAR 0 5
59423: PUSH
59424: LD_EXP 99
59428: PUSH
59429: LD_VAR 0 4
59433: ARRAY
59434: PPUSH
59435: LD_INT 2
59437: PUSH
59438: LD_INT 30
59440: PUSH
59441: LD_INT 0
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: PUSH
59448: LD_INT 30
59450: PUSH
59451: LD_INT 1
59453: PUSH
59454: EMPTY
59455: LIST
59456: LIST
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: LIST
59462: PPUSH
59463: CALL_OW 72
59467: PPUSH
59468: LD_VAR 0 1
59472: PPUSH
59473: CALL_OW 74
59477: ST_TO_ADDR
// if tmp then
59478: LD_VAR 0 5
59482: IFFALSE 59498
// ComStandNearbyBuilding ( ape , tmp ) ;
59484: LD_VAR 0 1
59488: PPUSH
59489: LD_VAR 0 5
59493: PPUSH
59494: CALL 65491 0 2
// break ;
59498: GO 59502
// end ; end ;
59500: GO 59354
59502: POP
59503: POP
// end ;
59504: LD_VAR 0 3
59508: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59509: LD_INT 0
59511: PPUSH
59512: PPUSH
59513: PPUSH
// if not mc_bases or not skirmish then
59514: LD_EXP 99
59518: NOT
59519: PUSH
59520: LD_EXP 97
59524: NOT
59525: OR
59526: IFFALSE 59530
// exit ;
59528: GO 59619
// for i = 1 to mc_bases do
59530: LD_ADDR_VAR 0 4
59534: PUSH
59535: DOUBLE
59536: LD_INT 1
59538: DEC
59539: ST_TO_ADDR
59540: LD_EXP 99
59544: PUSH
59545: FOR_TO
59546: IFFALSE 59617
// begin if building in mc_busy_turret_list [ i ] then
59548: LD_VAR 0 1
59552: PUSH
59553: LD_EXP 109
59557: PUSH
59558: LD_VAR 0 4
59562: ARRAY
59563: IN
59564: IFFALSE 59615
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59566: LD_ADDR_VAR 0 5
59570: PUSH
59571: LD_EXP 109
59575: PUSH
59576: LD_VAR 0 4
59580: ARRAY
59581: PUSH
59582: LD_VAR 0 1
59586: DIFF
59587: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59588: LD_ADDR_EXP 109
59592: PUSH
59593: LD_EXP 109
59597: PPUSH
59598: LD_VAR 0 4
59602: PPUSH
59603: LD_VAR 0 5
59607: PPUSH
59608: CALL_OW 1
59612: ST_TO_ADDR
// break ;
59613: GO 59617
// end ; end ;
59615: GO 59545
59617: POP
59618: POP
// end ;
59619: LD_VAR 0 3
59623: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59624: LD_INT 0
59626: PPUSH
59627: PPUSH
59628: PPUSH
// if not mc_bases or not skirmish then
59629: LD_EXP 99
59633: NOT
59634: PUSH
59635: LD_EXP 97
59639: NOT
59640: OR
59641: IFFALSE 59645
// exit ;
59643: GO 59844
// for i = 1 to mc_bases do
59645: LD_ADDR_VAR 0 5
59649: PUSH
59650: DOUBLE
59651: LD_INT 1
59653: DEC
59654: ST_TO_ADDR
59655: LD_EXP 99
59659: PUSH
59660: FOR_TO
59661: IFFALSE 59842
// if building in mc_bases [ i ] then
59663: LD_VAR 0 1
59667: PUSH
59668: LD_EXP 99
59672: PUSH
59673: LD_VAR 0 5
59677: ARRAY
59678: IN
59679: IFFALSE 59840
// begin tmp := mc_bases [ i ] diff building ;
59681: LD_ADDR_VAR 0 6
59685: PUSH
59686: LD_EXP 99
59690: PUSH
59691: LD_VAR 0 5
59695: ARRAY
59696: PUSH
59697: LD_VAR 0 1
59701: DIFF
59702: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59703: LD_ADDR_EXP 99
59707: PUSH
59708: LD_EXP 99
59712: PPUSH
59713: LD_VAR 0 5
59717: PPUSH
59718: LD_VAR 0 6
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59728: LD_VAR 0 1
59732: PUSH
59733: LD_EXP 107
59737: PUSH
59738: LD_VAR 0 5
59742: ARRAY
59743: IN
59744: IFFALSE 59783
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59746: LD_ADDR_EXP 107
59750: PUSH
59751: LD_EXP 107
59755: PPUSH
59756: LD_VAR 0 5
59760: PPUSH
59761: LD_EXP 107
59765: PUSH
59766: LD_VAR 0 5
59770: ARRAY
59771: PUSH
59772: LD_VAR 0 1
59776: DIFF
59777: PPUSH
59778: CALL_OW 1
59782: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59783: LD_VAR 0 1
59787: PUSH
59788: LD_EXP 108
59792: PUSH
59793: LD_VAR 0 5
59797: ARRAY
59798: IN
59799: IFFALSE 59838
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59801: LD_ADDR_EXP 108
59805: PUSH
59806: LD_EXP 108
59810: PPUSH
59811: LD_VAR 0 5
59815: PPUSH
59816: LD_EXP 108
59820: PUSH
59821: LD_VAR 0 5
59825: ARRAY
59826: PUSH
59827: LD_VAR 0 1
59831: DIFF
59832: PPUSH
59833: CALL_OW 1
59837: ST_TO_ADDR
// break ;
59838: GO 59842
// end ;
59840: GO 59660
59842: POP
59843: POP
// end ;
59844: LD_VAR 0 4
59848: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59849: LD_INT 0
59851: PPUSH
59852: PPUSH
59853: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59854: LD_EXP 99
59858: NOT
59859: PUSH
59860: LD_EXP 97
59864: NOT
59865: OR
59866: PUSH
59867: LD_VAR 0 3
59871: PUSH
59872: LD_EXP 125
59876: IN
59877: NOT
59878: OR
59879: IFFALSE 59883
// exit ;
59881: GO 60006
// for i = 1 to mc_vehicles do
59883: LD_ADDR_VAR 0 6
59887: PUSH
59888: DOUBLE
59889: LD_INT 1
59891: DEC
59892: ST_TO_ADDR
59893: LD_EXP 118
59897: PUSH
59898: FOR_TO
59899: IFFALSE 60004
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59901: LD_VAR 0 2
59905: PUSH
59906: LD_EXP 118
59910: PUSH
59911: LD_VAR 0 6
59915: ARRAY
59916: IN
59917: PUSH
59918: LD_VAR 0 1
59922: PUSH
59923: LD_EXP 118
59927: PUSH
59928: LD_VAR 0 6
59932: ARRAY
59933: IN
59934: OR
59935: IFFALSE 60002
// begin tmp := mc_vehicles [ i ] diff old ;
59937: LD_ADDR_VAR 0 7
59941: PUSH
59942: LD_EXP 118
59946: PUSH
59947: LD_VAR 0 6
59951: ARRAY
59952: PUSH
59953: LD_VAR 0 2
59957: DIFF
59958: ST_TO_ADDR
// tmp := tmp diff new ;
59959: LD_ADDR_VAR 0 7
59963: PUSH
59964: LD_VAR 0 7
59968: PUSH
59969: LD_VAR 0 1
59973: DIFF
59974: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59975: LD_ADDR_EXP 118
59979: PUSH
59980: LD_EXP 118
59984: PPUSH
59985: LD_VAR 0 6
59989: PPUSH
59990: LD_VAR 0 7
59994: PPUSH
59995: CALL_OW 1
59999: ST_TO_ADDR
// break ;
60000: GO 60004
// end ;
60002: GO 59898
60004: POP
60005: POP
// end ;
60006: LD_VAR 0 5
60010: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60011: LD_INT 0
60013: PPUSH
60014: PPUSH
60015: PPUSH
60016: PPUSH
// if not mc_bases or not skirmish then
60017: LD_EXP 99
60021: NOT
60022: PUSH
60023: LD_EXP 97
60027: NOT
60028: OR
60029: IFFALSE 60033
// exit ;
60031: GO 60410
// side := GetSide ( vehicle ) ;
60033: LD_ADDR_VAR 0 5
60037: PUSH
60038: LD_VAR 0 1
60042: PPUSH
60043: CALL_OW 255
60047: ST_TO_ADDR
// for i = 1 to mc_bases do
60048: LD_ADDR_VAR 0 4
60052: PUSH
60053: DOUBLE
60054: LD_INT 1
60056: DEC
60057: ST_TO_ADDR
60058: LD_EXP 99
60062: PUSH
60063: FOR_TO
60064: IFFALSE 60408
// begin if factory in mc_bases [ i ] then
60066: LD_VAR 0 2
60070: PUSH
60071: LD_EXP 99
60075: PUSH
60076: LD_VAR 0 4
60080: ARRAY
60081: IN
60082: IFFALSE 60406
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60084: LD_EXP 121
60088: PUSH
60089: LD_VAR 0 4
60093: ARRAY
60094: PUSH
60095: LD_EXP 110
60099: PUSH
60100: LD_VAR 0 4
60104: ARRAY
60105: LESS
60106: PUSH
60107: LD_VAR 0 1
60111: PPUSH
60112: CALL_OW 264
60116: PUSH
60117: LD_INT 31
60119: PUSH
60120: LD_INT 32
60122: PUSH
60123: LD_INT 51
60125: PUSH
60126: LD_EXP 93
60130: PUSH
60131: LD_INT 12
60133: PUSH
60134: LD_INT 30
60136: PUSH
60137: LD_EXP 92
60141: PUSH
60142: LD_INT 11
60144: PUSH
60145: LD_INT 53
60147: PUSH
60148: LD_INT 14
60150: PUSH
60151: LD_EXP 96
60155: PUSH
60156: LD_INT 29
60158: PUSH
60159: LD_EXP 94
60163: PUSH
60164: LD_INT 13
60166: PUSH
60167: LD_INT 52
60169: PUSH
60170: LD_INT 48
60172: PUSH
60173: LD_INT 8
60175: PUSH
60176: EMPTY
60177: LIST
60178: LIST
60179: LIST
60180: LIST
60181: LIST
60182: LIST
60183: LIST
60184: LIST
60185: LIST
60186: LIST
60187: LIST
60188: LIST
60189: LIST
60190: LIST
60191: LIST
60192: LIST
60193: LIST
60194: IN
60195: NOT
60196: AND
60197: IFFALSE 60245
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60199: LD_ADDR_EXP 121
60203: PUSH
60204: LD_EXP 121
60208: PPUSH
60209: LD_VAR 0 4
60213: PUSH
60214: LD_EXP 121
60218: PUSH
60219: LD_VAR 0 4
60223: ARRAY
60224: PUSH
60225: LD_INT 1
60227: PLUS
60228: PUSH
60229: EMPTY
60230: LIST
60231: LIST
60232: PPUSH
60233: LD_VAR 0 1
60237: PPUSH
60238: CALL 71199 0 3
60242: ST_TO_ADDR
60243: GO 60289
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60245: LD_ADDR_EXP 118
60249: PUSH
60250: LD_EXP 118
60254: PPUSH
60255: LD_VAR 0 4
60259: PUSH
60260: LD_EXP 118
60264: PUSH
60265: LD_VAR 0 4
60269: ARRAY
60270: PUSH
60271: LD_INT 1
60273: PLUS
60274: PUSH
60275: EMPTY
60276: LIST
60277: LIST
60278: PPUSH
60279: LD_VAR 0 1
60283: PPUSH
60284: CALL 71199 0 3
60288: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60289: LD_VAR 0 1
60293: PPUSH
60294: CALL_OW 263
60298: PUSH
60299: LD_INT 2
60301: EQUAL
60302: IFFALSE 60322
// begin repeat wait ( 0 0$1 ) ;
60304: LD_INT 35
60306: PPUSH
60307: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60311: LD_VAR 0 1
60315: PPUSH
60316: CALL_OW 312
60320: IFFALSE 60304
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60322: LD_VAR 0 1
60326: PPUSH
60327: LD_EXP 123
60331: PUSH
60332: LD_VAR 0 4
60336: ARRAY
60337: PPUSH
60338: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60342: LD_VAR 0 1
60346: PPUSH
60347: CALL_OW 263
60351: PUSH
60352: LD_INT 1
60354: NONEQUAL
60355: IFFALSE 60359
// break ;
60357: GO 60408
// repeat wait ( 0 0$1 ) ;
60359: LD_INT 35
60361: PPUSH
60362: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60366: LD_VAR 0 1
60370: PPUSH
60371: LD_EXP 123
60375: PUSH
60376: LD_VAR 0 4
60380: ARRAY
60381: PPUSH
60382: CALL_OW 308
60386: IFFALSE 60359
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60388: LD_VAR 0 1
60392: PPUSH
60393: CALL_OW 311
60397: PPUSH
60398: CALL_OW 121
// exit ;
60402: POP
60403: POP
60404: GO 60410
// end ; end ;
60406: GO 60063
60408: POP
60409: POP
// end ;
60410: LD_VAR 0 3
60414: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60415: LD_INT 0
60417: PPUSH
60418: PPUSH
60419: PPUSH
60420: PPUSH
// if not mc_bases or not skirmish then
60421: LD_EXP 99
60425: NOT
60426: PUSH
60427: LD_EXP 97
60431: NOT
60432: OR
60433: IFFALSE 60437
// exit ;
60435: GO 60790
// repeat wait ( 0 0$1 ) ;
60437: LD_INT 35
60439: PPUSH
60440: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60444: LD_VAR 0 2
60448: PPUSH
60449: LD_VAR 0 3
60453: PPUSH
60454: CALL_OW 284
60458: IFFALSE 60437
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60460: LD_VAR 0 2
60464: PPUSH
60465: LD_VAR 0 3
60469: PPUSH
60470: CALL_OW 283
60474: PUSH
60475: LD_INT 4
60477: EQUAL
60478: IFFALSE 60482
// exit ;
60480: GO 60790
// for i = 1 to mc_bases do
60482: LD_ADDR_VAR 0 7
60486: PUSH
60487: DOUBLE
60488: LD_INT 1
60490: DEC
60491: ST_TO_ADDR
60492: LD_EXP 99
60496: PUSH
60497: FOR_TO
60498: IFFALSE 60788
// begin if mc_crates_area [ i ] then
60500: LD_EXP 117
60504: PUSH
60505: LD_VAR 0 7
60509: ARRAY
60510: IFFALSE 60621
// for j in mc_crates_area [ i ] do
60512: LD_ADDR_VAR 0 8
60516: PUSH
60517: LD_EXP 117
60521: PUSH
60522: LD_VAR 0 7
60526: ARRAY
60527: PUSH
60528: FOR_IN
60529: IFFALSE 60619
// if InArea ( x , y , j ) then
60531: LD_VAR 0 2
60535: PPUSH
60536: LD_VAR 0 3
60540: PPUSH
60541: LD_VAR 0 8
60545: PPUSH
60546: CALL_OW 309
60550: IFFALSE 60617
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60552: LD_ADDR_EXP 115
60556: PUSH
60557: LD_EXP 115
60561: PPUSH
60562: LD_VAR 0 7
60566: PUSH
60567: LD_EXP 115
60571: PUSH
60572: LD_VAR 0 7
60576: ARRAY
60577: PUSH
60578: LD_INT 1
60580: PLUS
60581: PUSH
60582: EMPTY
60583: LIST
60584: LIST
60585: PPUSH
60586: LD_VAR 0 4
60590: PUSH
60591: LD_VAR 0 2
60595: PUSH
60596: LD_VAR 0 3
60600: PUSH
60601: EMPTY
60602: LIST
60603: LIST
60604: LIST
60605: PPUSH
60606: CALL 71199 0 3
60610: ST_TO_ADDR
// exit ;
60611: POP
60612: POP
60613: POP
60614: POP
60615: GO 60790
// end ;
60617: GO 60528
60619: POP
60620: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60621: LD_ADDR_VAR 0 9
60625: PUSH
60626: LD_EXP 99
60630: PUSH
60631: LD_VAR 0 7
60635: ARRAY
60636: PPUSH
60637: LD_INT 2
60639: PUSH
60640: LD_INT 30
60642: PUSH
60643: LD_INT 0
60645: PUSH
60646: EMPTY
60647: LIST
60648: LIST
60649: PUSH
60650: LD_INT 30
60652: PUSH
60653: LD_INT 1
60655: PUSH
60656: EMPTY
60657: LIST
60658: LIST
60659: PUSH
60660: EMPTY
60661: LIST
60662: LIST
60663: LIST
60664: PPUSH
60665: CALL_OW 72
60669: ST_TO_ADDR
// if not depot then
60670: LD_VAR 0 9
60674: NOT
60675: IFFALSE 60679
// continue ;
60677: GO 60497
// for j in depot do
60679: LD_ADDR_VAR 0 8
60683: PUSH
60684: LD_VAR 0 9
60688: PUSH
60689: FOR_IN
60690: IFFALSE 60784
// if GetDistUnitXY ( j , x , y ) < 30 then
60692: LD_VAR 0 8
60696: PPUSH
60697: LD_VAR 0 2
60701: PPUSH
60702: LD_VAR 0 3
60706: PPUSH
60707: CALL_OW 297
60711: PUSH
60712: LD_INT 30
60714: LESS
60715: IFFALSE 60782
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60717: LD_ADDR_EXP 115
60721: PUSH
60722: LD_EXP 115
60726: PPUSH
60727: LD_VAR 0 7
60731: PUSH
60732: LD_EXP 115
60736: PUSH
60737: LD_VAR 0 7
60741: ARRAY
60742: PUSH
60743: LD_INT 1
60745: PLUS
60746: PUSH
60747: EMPTY
60748: LIST
60749: LIST
60750: PPUSH
60751: LD_VAR 0 4
60755: PUSH
60756: LD_VAR 0 2
60760: PUSH
60761: LD_VAR 0 3
60765: PUSH
60766: EMPTY
60767: LIST
60768: LIST
60769: LIST
60770: PPUSH
60771: CALL 71199 0 3
60775: ST_TO_ADDR
// exit ;
60776: POP
60777: POP
60778: POP
60779: POP
60780: GO 60790
// end ;
60782: GO 60689
60784: POP
60785: POP
// end ;
60786: GO 60497
60788: POP
60789: POP
// end ;
60790: LD_VAR 0 6
60794: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
60795: LD_INT 0
60797: PPUSH
60798: PPUSH
60799: PPUSH
60800: PPUSH
// if not mc_bases or not skirmish then
60801: LD_EXP 99
60805: NOT
60806: PUSH
60807: LD_EXP 97
60811: NOT
60812: OR
60813: IFFALSE 60817
// exit ;
60815: GO 61094
// side := GetSide ( lab ) ;
60817: LD_ADDR_VAR 0 4
60821: PUSH
60822: LD_VAR 0 2
60826: PPUSH
60827: CALL_OW 255
60831: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60832: LD_VAR 0 4
60836: PUSH
60837: LD_EXP 125
60841: IN
60842: NOT
60843: PUSH
60844: LD_EXP 126
60848: NOT
60849: OR
60850: PUSH
60851: LD_EXP 99
60855: NOT
60856: OR
60857: IFFALSE 60861
// exit ;
60859: GO 61094
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60861: LD_ADDR_EXP 126
60865: PUSH
60866: LD_EXP 126
60870: PPUSH
60871: LD_VAR 0 4
60875: PPUSH
60876: LD_EXP 126
60880: PUSH
60881: LD_VAR 0 4
60885: ARRAY
60886: PUSH
60887: LD_VAR 0 1
60891: DIFF
60892: PPUSH
60893: CALL_OW 1
60897: ST_TO_ADDR
// for i = 1 to mc_bases do
60898: LD_ADDR_VAR 0 5
60902: PUSH
60903: DOUBLE
60904: LD_INT 1
60906: DEC
60907: ST_TO_ADDR
60908: LD_EXP 99
60912: PUSH
60913: FOR_TO
60914: IFFALSE 61092
// begin if lab in mc_bases [ i ] then
60916: LD_VAR 0 2
60920: PUSH
60921: LD_EXP 99
60925: PUSH
60926: LD_VAR 0 5
60930: ARRAY
60931: IN
60932: IFFALSE 61090
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60934: LD_VAR 0 1
60938: PUSH
60939: LD_INT 11
60941: PUSH
60942: LD_INT 4
60944: PUSH
60945: LD_INT 3
60947: PUSH
60948: LD_INT 2
60950: PUSH
60951: EMPTY
60952: LIST
60953: LIST
60954: LIST
60955: LIST
60956: IN
60957: PUSH
60958: LD_EXP 129
60962: PUSH
60963: LD_VAR 0 5
60967: ARRAY
60968: AND
60969: IFFALSE 61090
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60971: LD_ADDR_VAR 0 6
60975: PUSH
60976: LD_EXP 129
60980: PUSH
60981: LD_VAR 0 5
60985: ARRAY
60986: PUSH
60987: LD_INT 1
60989: ARRAY
60990: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60991: LD_ADDR_EXP 129
60995: PUSH
60996: LD_EXP 129
61000: PPUSH
61001: LD_VAR 0 5
61005: PPUSH
61006: EMPTY
61007: PPUSH
61008: CALL_OW 1
61012: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61013: LD_VAR 0 6
61017: PPUSH
61018: LD_INT 0
61020: PPUSH
61021: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61025: LD_VAR 0 6
61029: PPUSH
61030: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61034: LD_ADDR_EXP 128
61038: PUSH
61039: LD_EXP 128
61043: PPUSH
61044: LD_VAR 0 5
61048: PPUSH
61049: LD_EXP 128
61053: PUSH
61054: LD_VAR 0 5
61058: ARRAY
61059: PPUSH
61060: LD_INT 1
61062: PPUSH
61063: LD_VAR 0 6
61067: PPUSH
61068: CALL_OW 2
61072: PPUSH
61073: CALL_OW 1
61077: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61078: LD_VAR 0 5
61082: PPUSH
61083: LD_INT 112
61085: PPUSH
61086: CALL 37986 0 2
// end ; end ; end ;
61090: GO 60913
61092: POP
61093: POP
// end ;
61094: LD_VAR 0 3
61098: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61099: LD_INT 0
61101: PPUSH
61102: PPUSH
61103: PPUSH
61104: PPUSH
61105: PPUSH
61106: PPUSH
61107: PPUSH
61108: PPUSH
// if not mc_bases or not skirmish then
61109: LD_EXP 99
61113: NOT
61114: PUSH
61115: LD_EXP 97
61119: NOT
61120: OR
61121: IFFALSE 61125
// exit ;
61123: GO 62496
// for i = 1 to mc_bases do
61125: LD_ADDR_VAR 0 3
61129: PUSH
61130: DOUBLE
61131: LD_INT 1
61133: DEC
61134: ST_TO_ADDR
61135: LD_EXP 99
61139: PUSH
61140: FOR_TO
61141: IFFALSE 62494
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61143: LD_VAR 0 1
61147: PUSH
61148: LD_EXP 99
61152: PUSH
61153: LD_VAR 0 3
61157: ARRAY
61158: IN
61159: PUSH
61160: LD_VAR 0 1
61164: PUSH
61165: LD_EXP 106
61169: PUSH
61170: LD_VAR 0 3
61174: ARRAY
61175: IN
61176: OR
61177: PUSH
61178: LD_VAR 0 1
61182: PUSH
61183: LD_EXP 121
61187: PUSH
61188: LD_VAR 0 3
61192: ARRAY
61193: IN
61194: OR
61195: PUSH
61196: LD_VAR 0 1
61200: PUSH
61201: LD_EXP 118
61205: PUSH
61206: LD_VAR 0 3
61210: ARRAY
61211: IN
61212: OR
61213: PUSH
61214: LD_VAR 0 1
61218: PUSH
61219: LD_EXP 128
61223: PUSH
61224: LD_VAR 0 3
61228: ARRAY
61229: IN
61230: OR
61231: PUSH
61232: LD_VAR 0 1
61236: PUSH
61237: LD_EXP 129
61241: PUSH
61242: LD_VAR 0 3
61246: ARRAY
61247: IN
61248: OR
61249: IFFALSE 62492
// begin if un in mc_ape [ i ] then
61251: LD_VAR 0 1
61255: PUSH
61256: LD_EXP 128
61260: PUSH
61261: LD_VAR 0 3
61265: ARRAY
61266: IN
61267: IFFALSE 61306
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61269: LD_ADDR_EXP 128
61273: PUSH
61274: LD_EXP 128
61278: PPUSH
61279: LD_VAR 0 3
61283: PPUSH
61284: LD_EXP 128
61288: PUSH
61289: LD_VAR 0 3
61293: ARRAY
61294: PUSH
61295: LD_VAR 0 1
61299: DIFF
61300: PPUSH
61301: CALL_OW 1
61305: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61306: LD_VAR 0 1
61310: PUSH
61311: LD_EXP 129
61315: PUSH
61316: LD_VAR 0 3
61320: ARRAY
61321: IN
61322: IFFALSE 61346
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61324: LD_ADDR_EXP 129
61328: PUSH
61329: LD_EXP 129
61333: PPUSH
61334: LD_VAR 0 3
61338: PPUSH
61339: EMPTY
61340: PPUSH
61341: CALL_OW 1
61345: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61346: LD_VAR 0 1
61350: PPUSH
61351: CALL_OW 247
61355: PUSH
61356: LD_INT 2
61358: EQUAL
61359: PUSH
61360: LD_VAR 0 1
61364: PPUSH
61365: CALL_OW 110
61369: PUSH
61370: LD_INT 20
61372: EQUAL
61373: PUSH
61374: LD_VAR 0 1
61378: PUSH
61379: LD_EXP 121
61383: PUSH
61384: LD_VAR 0 3
61388: ARRAY
61389: IN
61390: OR
61391: PUSH
61392: LD_VAR 0 1
61396: PPUSH
61397: CALL_OW 264
61401: PUSH
61402: LD_INT 12
61404: PUSH
61405: LD_INT 51
61407: PUSH
61408: LD_EXP 93
61412: PUSH
61413: LD_INT 32
61415: PUSH
61416: LD_INT 13
61418: PUSH
61419: LD_INT 52
61421: PUSH
61422: LD_INT 31
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: LIST
61429: LIST
61430: LIST
61431: LIST
61432: LIST
61433: IN
61434: OR
61435: AND
61436: IFFALSE 61744
// begin if un in mc_defender [ i ] then
61438: LD_VAR 0 1
61442: PUSH
61443: LD_EXP 121
61447: PUSH
61448: LD_VAR 0 3
61452: ARRAY
61453: IN
61454: IFFALSE 61493
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61456: LD_ADDR_EXP 121
61460: PUSH
61461: LD_EXP 121
61465: PPUSH
61466: LD_VAR 0 3
61470: PPUSH
61471: LD_EXP 121
61475: PUSH
61476: LD_VAR 0 3
61480: ARRAY
61481: PUSH
61482: LD_VAR 0 1
61486: DIFF
61487: PPUSH
61488: CALL_OW 1
61492: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61493: LD_ADDR_VAR 0 8
61497: PUSH
61498: LD_VAR 0 3
61502: PPUSH
61503: LD_INT 3
61505: PPUSH
61506: CALL 58162 0 2
61510: ST_TO_ADDR
// if fac then
61511: LD_VAR 0 8
61515: IFFALSE 61744
// begin for j in fac do
61517: LD_ADDR_VAR 0 4
61521: PUSH
61522: LD_VAR 0 8
61526: PUSH
61527: FOR_IN
61528: IFFALSE 61742
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61530: LD_ADDR_VAR 0 9
61534: PUSH
61535: LD_VAR 0 8
61539: PPUSH
61540: LD_VAR 0 1
61544: PPUSH
61545: CALL_OW 265
61549: PPUSH
61550: LD_VAR 0 1
61554: PPUSH
61555: CALL_OW 262
61559: PPUSH
61560: LD_VAR 0 1
61564: PPUSH
61565: CALL_OW 263
61569: PPUSH
61570: LD_VAR 0 1
61574: PPUSH
61575: CALL_OW 264
61579: PPUSH
61580: CALL 68731 0 5
61584: ST_TO_ADDR
// if components then
61585: LD_VAR 0 9
61589: IFFALSE 61740
// begin if GetWeapon ( un ) = ar_control_tower then
61591: LD_VAR 0 1
61595: PPUSH
61596: CALL_OW 264
61600: PUSH
61601: LD_INT 31
61603: EQUAL
61604: IFFALSE 61721
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61606: LD_VAR 0 1
61610: PPUSH
61611: CALL_OW 311
61615: PPUSH
61616: LD_INT 0
61618: PPUSH
61619: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61623: LD_ADDR_EXP 139
61627: PUSH
61628: LD_EXP 139
61632: PPUSH
61633: LD_VAR 0 3
61637: PPUSH
61638: LD_EXP 139
61642: PUSH
61643: LD_VAR 0 3
61647: ARRAY
61648: PUSH
61649: LD_VAR 0 1
61653: PPUSH
61654: CALL_OW 311
61658: DIFF
61659: PPUSH
61660: CALL_OW 1
61664: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61665: LD_ADDR_VAR 0 7
61669: PUSH
61670: LD_EXP 120
61674: PUSH
61675: LD_VAR 0 3
61679: ARRAY
61680: PPUSH
61681: LD_INT 1
61683: PPUSH
61684: LD_VAR 0 9
61688: PPUSH
61689: CALL_OW 2
61693: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
61694: LD_ADDR_EXP 120
61698: PUSH
61699: LD_EXP 120
61703: PPUSH
61704: LD_VAR 0 3
61708: PPUSH
61709: LD_VAR 0 7
61713: PPUSH
61714: CALL_OW 1
61718: ST_TO_ADDR
// end else
61719: GO 61738
// MC_InsertProduceList ( i , [ components ] ) ;
61721: LD_VAR 0 3
61725: PPUSH
61726: LD_VAR 0 9
61730: PUSH
61731: EMPTY
61732: LIST
61733: PPUSH
61734: CALL 57707 0 2
// break ;
61738: GO 61742
// end ; end ;
61740: GO 61527
61742: POP
61743: POP
// end ; end ; if GetType ( un ) = unit_building then
61744: LD_VAR 0 1
61748: PPUSH
61749: CALL_OW 247
61753: PUSH
61754: LD_INT 3
61756: EQUAL
61757: IFFALSE 62160
// begin btype := GetBType ( un ) ;
61759: LD_ADDR_VAR 0 5
61763: PUSH
61764: LD_VAR 0 1
61768: PPUSH
61769: CALL_OW 266
61773: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61774: LD_VAR 0 5
61778: PUSH
61779: LD_INT 29
61781: PUSH
61782: LD_INT 30
61784: PUSH
61785: EMPTY
61786: LIST
61787: LIST
61788: IN
61789: IFFALSE 61862
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
61791: LD_VAR 0 1
61795: PPUSH
61796: CALL_OW 250
61800: PPUSH
61801: LD_VAR 0 1
61805: PPUSH
61806: CALL_OW 251
61810: PPUSH
61811: LD_VAR 0 1
61815: PPUSH
61816: CALL_OW 255
61820: PPUSH
61821: CALL_OW 440
61825: NOT
61826: IFFALSE 61862
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
61828: LD_VAR 0 1
61832: PPUSH
61833: CALL_OW 250
61837: PPUSH
61838: LD_VAR 0 1
61842: PPUSH
61843: CALL_OW 251
61847: PPUSH
61848: LD_VAR 0 1
61852: PPUSH
61853: CALL_OW 255
61857: PPUSH
61858: CALL_OW 441
// end ; if btype = b_warehouse then
61862: LD_VAR 0 5
61866: PUSH
61867: LD_INT 1
61869: EQUAL
61870: IFFALSE 61888
// begin btype := b_depot ;
61872: LD_ADDR_VAR 0 5
61876: PUSH
61877: LD_INT 0
61879: ST_TO_ADDR
// pos := 1 ;
61880: LD_ADDR_VAR 0 6
61884: PUSH
61885: LD_INT 1
61887: ST_TO_ADDR
// end ; if btype = b_factory then
61888: LD_VAR 0 5
61892: PUSH
61893: LD_INT 3
61895: EQUAL
61896: IFFALSE 61914
// begin btype := b_workshop ;
61898: LD_ADDR_VAR 0 5
61902: PUSH
61903: LD_INT 2
61905: ST_TO_ADDR
// pos := 1 ;
61906: LD_ADDR_VAR 0 6
61910: PUSH
61911: LD_INT 1
61913: ST_TO_ADDR
// end ; if btype = b_barracks then
61914: LD_VAR 0 5
61918: PUSH
61919: LD_INT 5
61921: EQUAL
61922: IFFALSE 61932
// btype := b_armoury ;
61924: LD_ADDR_VAR 0 5
61928: PUSH
61929: LD_INT 4
61931: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
61932: LD_VAR 0 5
61936: PUSH
61937: LD_INT 7
61939: PUSH
61940: LD_INT 8
61942: PUSH
61943: EMPTY
61944: LIST
61945: LIST
61946: IN
61947: IFFALSE 61957
// btype := b_lab ;
61949: LD_ADDR_VAR 0 5
61953: PUSH
61954: LD_INT 6
61956: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
61957: LD_ADDR_EXP 104
61961: PUSH
61962: LD_EXP 104
61966: PPUSH
61967: LD_VAR 0 3
61971: PUSH
61972: LD_EXP 104
61976: PUSH
61977: LD_VAR 0 3
61981: ARRAY
61982: PUSH
61983: LD_INT 1
61985: PLUS
61986: PUSH
61987: EMPTY
61988: LIST
61989: LIST
61990: PPUSH
61991: LD_VAR 0 5
61995: PUSH
61996: LD_VAR 0 1
62000: PPUSH
62001: CALL_OW 250
62005: PUSH
62006: LD_VAR 0 1
62010: PPUSH
62011: CALL_OW 251
62015: PUSH
62016: LD_VAR 0 1
62020: PPUSH
62021: CALL_OW 254
62025: PUSH
62026: EMPTY
62027: LIST
62028: LIST
62029: LIST
62030: LIST
62031: PPUSH
62032: CALL 71199 0 3
62036: ST_TO_ADDR
// if pos = 1 then
62037: LD_VAR 0 6
62041: PUSH
62042: LD_INT 1
62044: EQUAL
62045: IFFALSE 62160
// begin tmp := mc_build_list [ i ] ;
62047: LD_ADDR_VAR 0 7
62051: PUSH
62052: LD_EXP 104
62056: PUSH
62057: LD_VAR 0 3
62061: ARRAY
62062: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62063: LD_VAR 0 7
62067: PPUSH
62068: LD_INT 2
62070: PUSH
62071: LD_INT 30
62073: PUSH
62074: LD_INT 0
62076: PUSH
62077: EMPTY
62078: LIST
62079: LIST
62080: PUSH
62081: LD_INT 30
62083: PUSH
62084: LD_INT 1
62086: PUSH
62087: EMPTY
62088: LIST
62089: LIST
62090: PUSH
62091: EMPTY
62092: LIST
62093: LIST
62094: LIST
62095: PPUSH
62096: CALL_OW 72
62100: IFFALSE 62110
// pos := 2 ;
62102: LD_ADDR_VAR 0 6
62106: PUSH
62107: LD_INT 2
62109: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62110: LD_ADDR_VAR 0 7
62114: PUSH
62115: LD_VAR 0 7
62119: PPUSH
62120: LD_VAR 0 6
62124: PPUSH
62125: LD_VAR 0 7
62129: PPUSH
62130: CALL 71525 0 3
62134: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62135: LD_ADDR_EXP 104
62139: PUSH
62140: LD_EXP 104
62144: PPUSH
62145: LD_VAR 0 3
62149: PPUSH
62150: LD_VAR 0 7
62154: PPUSH
62155: CALL_OW 1
62159: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62160: LD_VAR 0 1
62164: PUSH
62165: LD_EXP 99
62169: PUSH
62170: LD_VAR 0 3
62174: ARRAY
62175: IN
62176: IFFALSE 62215
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62178: LD_ADDR_EXP 99
62182: PUSH
62183: LD_EXP 99
62187: PPUSH
62188: LD_VAR 0 3
62192: PPUSH
62193: LD_EXP 99
62197: PUSH
62198: LD_VAR 0 3
62202: ARRAY
62203: PUSH
62204: LD_VAR 0 1
62208: DIFF
62209: PPUSH
62210: CALL_OW 1
62214: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62215: LD_VAR 0 1
62219: PUSH
62220: LD_EXP 106
62224: PUSH
62225: LD_VAR 0 3
62229: ARRAY
62230: IN
62231: IFFALSE 62270
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62233: LD_ADDR_EXP 106
62237: PUSH
62238: LD_EXP 106
62242: PPUSH
62243: LD_VAR 0 3
62247: PPUSH
62248: LD_EXP 106
62252: PUSH
62253: LD_VAR 0 3
62257: ARRAY
62258: PUSH
62259: LD_VAR 0 1
62263: DIFF
62264: PPUSH
62265: CALL_OW 1
62269: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62270: LD_VAR 0 1
62274: PUSH
62275: LD_EXP 118
62279: PUSH
62280: LD_VAR 0 3
62284: ARRAY
62285: IN
62286: IFFALSE 62325
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62288: LD_ADDR_EXP 118
62292: PUSH
62293: LD_EXP 118
62297: PPUSH
62298: LD_VAR 0 3
62302: PPUSH
62303: LD_EXP 118
62307: PUSH
62308: LD_VAR 0 3
62312: ARRAY
62313: PUSH
62314: LD_VAR 0 1
62318: DIFF
62319: PPUSH
62320: CALL_OW 1
62324: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62325: LD_VAR 0 1
62329: PUSH
62330: LD_EXP 121
62334: PUSH
62335: LD_VAR 0 3
62339: ARRAY
62340: IN
62341: IFFALSE 62380
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62343: LD_ADDR_EXP 121
62347: PUSH
62348: LD_EXP 121
62352: PPUSH
62353: LD_VAR 0 3
62357: PPUSH
62358: LD_EXP 121
62362: PUSH
62363: LD_VAR 0 3
62367: ARRAY
62368: PUSH
62369: LD_VAR 0 1
62373: DIFF
62374: PPUSH
62375: CALL_OW 1
62379: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62380: LD_VAR 0 1
62384: PUSH
62385: LD_EXP 108
62389: PUSH
62390: LD_VAR 0 3
62394: ARRAY
62395: IN
62396: IFFALSE 62435
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62398: LD_ADDR_EXP 108
62402: PUSH
62403: LD_EXP 108
62407: PPUSH
62408: LD_VAR 0 3
62412: PPUSH
62413: LD_EXP 108
62417: PUSH
62418: LD_VAR 0 3
62422: ARRAY
62423: PUSH
62424: LD_VAR 0 1
62428: DIFF
62429: PPUSH
62430: CALL_OW 1
62434: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62435: LD_VAR 0 1
62439: PUSH
62440: LD_EXP 107
62444: PUSH
62445: LD_VAR 0 3
62449: ARRAY
62450: IN
62451: IFFALSE 62490
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62453: LD_ADDR_EXP 107
62457: PUSH
62458: LD_EXP 107
62462: PPUSH
62463: LD_VAR 0 3
62467: PPUSH
62468: LD_EXP 107
62472: PUSH
62473: LD_VAR 0 3
62477: ARRAY
62478: PUSH
62479: LD_VAR 0 1
62483: DIFF
62484: PPUSH
62485: CALL_OW 1
62489: ST_TO_ADDR
// end ; break ;
62490: GO 62494
// end ;
62492: GO 61140
62494: POP
62495: POP
// end ;
62496: LD_VAR 0 2
62500: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62501: LD_INT 0
62503: PPUSH
62504: PPUSH
62505: PPUSH
// if not mc_bases or not skirmish then
62506: LD_EXP 99
62510: NOT
62511: PUSH
62512: LD_EXP 97
62516: NOT
62517: OR
62518: IFFALSE 62522
// exit ;
62520: GO 62737
// for i = 1 to mc_bases do
62522: LD_ADDR_VAR 0 3
62526: PUSH
62527: DOUBLE
62528: LD_INT 1
62530: DEC
62531: ST_TO_ADDR
62532: LD_EXP 99
62536: PUSH
62537: FOR_TO
62538: IFFALSE 62735
// begin if building in mc_construct_list [ i ] then
62540: LD_VAR 0 1
62544: PUSH
62545: LD_EXP 106
62549: PUSH
62550: LD_VAR 0 3
62554: ARRAY
62555: IN
62556: IFFALSE 62733
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62558: LD_ADDR_EXP 106
62562: PUSH
62563: LD_EXP 106
62567: PPUSH
62568: LD_VAR 0 3
62572: PPUSH
62573: LD_EXP 106
62577: PUSH
62578: LD_VAR 0 3
62582: ARRAY
62583: PUSH
62584: LD_VAR 0 1
62588: DIFF
62589: PPUSH
62590: CALL_OW 1
62594: ST_TO_ADDR
// if building in mc_lab [ i ] then
62595: LD_VAR 0 1
62599: PUSH
62600: LD_EXP 132
62604: PUSH
62605: LD_VAR 0 3
62609: ARRAY
62610: IN
62611: IFFALSE 62666
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62613: LD_ADDR_EXP 133
62617: PUSH
62618: LD_EXP 133
62622: PPUSH
62623: LD_VAR 0 3
62627: PPUSH
62628: LD_EXP 133
62632: PUSH
62633: LD_VAR 0 3
62637: ARRAY
62638: PPUSH
62639: LD_INT 1
62641: PPUSH
62642: LD_EXP 133
62646: PUSH
62647: LD_VAR 0 3
62651: ARRAY
62652: PPUSH
62653: LD_INT 0
62655: PPUSH
62656: CALL 70617 0 4
62660: PPUSH
62661: CALL_OW 1
62665: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62666: LD_VAR 0 1
62670: PUSH
62671: LD_EXP 99
62675: PUSH
62676: LD_VAR 0 3
62680: ARRAY
62681: IN
62682: NOT
62683: IFFALSE 62729
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62685: LD_ADDR_EXP 99
62689: PUSH
62690: LD_EXP 99
62694: PPUSH
62695: LD_VAR 0 3
62699: PUSH
62700: LD_EXP 99
62704: PUSH
62705: LD_VAR 0 3
62709: ARRAY
62710: PUSH
62711: LD_INT 1
62713: PLUS
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: PPUSH
62719: LD_VAR 0 1
62723: PPUSH
62724: CALL 71199 0 3
62728: ST_TO_ADDR
// exit ;
62729: POP
62730: POP
62731: GO 62737
// end ; end ;
62733: GO 62537
62735: POP
62736: POP
// end ;
62737: LD_VAR 0 2
62741: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62742: LD_INT 0
62744: PPUSH
62745: PPUSH
62746: PPUSH
62747: PPUSH
62748: PPUSH
62749: PPUSH
62750: PPUSH
// if not mc_bases or not skirmish then
62751: LD_EXP 99
62755: NOT
62756: PUSH
62757: LD_EXP 97
62761: NOT
62762: OR
62763: IFFALSE 62767
// exit ;
62765: GO 63428
// for i = 1 to mc_bases do
62767: LD_ADDR_VAR 0 3
62771: PUSH
62772: DOUBLE
62773: LD_INT 1
62775: DEC
62776: ST_TO_ADDR
62777: LD_EXP 99
62781: PUSH
62782: FOR_TO
62783: IFFALSE 63426
// begin if building in mc_construct_list [ i ] then
62785: LD_VAR 0 1
62789: PUSH
62790: LD_EXP 106
62794: PUSH
62795: LD_VAR 0 3
62799: ARRAY
62800: IN
62801: IFFALSE 63424
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62803: LD_ADDR_EXP 106
62807: PUSH
62808: LD_EXP 106
62812: PPUSH
62813: LD_VAR 0 3
62817: PPUSH
62818: LD_EXP 106
62822: PUSH
62823: LD_VAR 0 3
62827: ARRAY
62828: PUSH
62829: LD_VAR 0 1
62833: DIFF
62834: PPUSH
62835: CALL_OW 1
62839: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62840: LD_ADDR_EXP 99
62844: PUSH
62845: LD_EXP 99
62849: PPUSH
62850: LD_VAR 0 3
62854: PUSH
62855: LD_EXP 99
62859: PUSH
62860: LD_VAR 0 3
62864: ARRAY
62865: PUSH
62866: LD_INT 1
62868: PLUS
62869: PUSH
62870: EMPTY
62871: LIST
62872: LIST
62873: PPUSH
62874: LD_VAR 0 1
62878: PPUSH
62879: CALL 71199 0 3
62883: ST_TO_ADDR
// btype := GetBType ( building ) ;
62884: LD_ADDR_VAR 0 5
62888: PUSH
62889: LD_VAR 0 1
62893: PPUSH
62894: CALL_OW 266
62898: ST_TO_ADDR
// side := GetSide ( building ) ;
62899: LD_ADDR_VAR 0 8
62903: PUSH
62904: LD_VAR 0 1
62908: PPUSH
62909: CALL_OW 255
62913: ST_TO_ADDR
// if btype = b_lab then
62914: LD_VAR 0 5
62918: PUSH
62919: LD_INT 6
62921: EQUAL
62922: IFFALSE 62972
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
62924: LD_ADDR_EXP 132
62928: PUSH
62929: LD_EXP 132
62933: PPUSH
62934: LD_VAR 0 3
62938: PUSH
62939: LD_EXP 132
62943: PUSH
62944: LD_VAR 0 3
62948: ARRAY
62949: PUSH
62950: LD_INT 1
62952: PLUS
62953: PUSH
62954: EMPTY
62955: LIST
62956: LIST
62957: PPUSH
62958: LD_VAR 0 1
62962: PPUSH
62963: CALL 71199 0 3
62967: ST_TO_ADDR
// exit ;
62968: POP
62969: POP
62970: GO 63428
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
62972: LD_VAR 0 5
62976: PUSH
62977: LD_INT 0
62979: PUSH
62980: LD_INT 2
62982: PUSH
62983: LD_INT 4
62985: PUSH
62986: EMPTY
62987: LIST
62988: LIST
62989: LIST
62990: IN
62991: IFFALSE 63115
// begin if btype = b_armoury then
62993: LD_VAR 0 5
62997: PUSH
62998: LD_INT 4
63000: EQUAL
63001: IFFALSE 63011
// btype := b_barracks ;
63003: LD_ADDR_VAR 0 5
63007: PUSH
63008: LD_INT 5
63010: ST_TO_ADDR
// if btype = b_depot then
63011: LD_VAR 0 5
63015: PUSH
63016: LD_INT 0
63018: EQUAL
63019: IFFALSE 63029
// btype := b_warehouse ;
63021: LD_ADDR_VAR 0 5
63025: PUSH
63026: LD_INT 1
63028: ST_TO_ADDR
// if btype = b_workshop then
63029: LD_VAR 0 5
63033: PUSH
63034: LD_INT 2
63036: EQUAL
63037: IFFALSE 63047
// btype := b_factory ;
63039: LD_ADDR_VAR 0 5
63043: PUSH
63044: LD_INT 3
63046: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63047: LD_VAR 0 5
63051: PPUSH
63052: LD_VAR 0 8
63056: PPUSH
63057: CALL_OW 323
63061: PUSH
63062: LD_INT 1
63064: EQUAL
63065: IFFALSE 63111
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63067: LD_ADDR_EXP 131
63071: PUSH
63072: LD_EXP 131
63076: PPUSH
63077: LD_VAR 0 3
63081: PUSH
63082: LD_EXP 131
63086: PUSH
63087: LD_VAR 0 3
63091: ARRAY
63092: PUSH
63093: LD_INT 1
63095: PLUS
63096: PUSH
63097: EMPTY
63098: LIST
63099: LIST
63100: PPUSH
63101: LD_VAR 0 1
63105: PPUSH
63106: CALL 71199 0 3
63110: ST_TO_ADDR
// exit ;
63111: POP
63112: POP
63113: GO 63428
// end ; if btype in [ b_bunker , b_turret ] then
63115: LD_VAR 0 5
63119: PUSH
63120: LD_INT 32
63122: PUSH
63123: LD_INT 33
63125: PUSH
63126: EMPTY
63127: LIST
63128: LIST
63129: IN
63130: IFFALSE 63420
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63132: LD_ADDR_EXP 107
63136: PUSH
63137: LD_EXP 107
63141: PPUSH
63142: LD_VAR 0 3
63146: PUSH
63147: LD_EXP 107
63151: PUSH
63152: LD_VAR 0 3
63156: ARRAY
63157: PUSH
63158: LD_INT 1
63160: PLUS
63161: PUSH
63162: EMPTY
63163: LIST
63164: LIST
63165: PPUSH
63166: LD_VAR 0 1
63170: PPUSH
63171: CALL 71199 0 3
63175: ST_TO_ADDR
// if btype = b_bunker then
63176: LD_VAR 0 5
63180: PUSH
63181: LD_INT 32
63183: EQUAL
63184: IFFALSE 63420
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63186: LD_ADDR_EXP 108
63190: PUSH
63191: LD_EXP 108
63195: PPUSH
63196: LD_VAR 0 3
63200: PUSH
63201: LD_EXP 108
63205: PUSH
63206: LD_VAR 0 3
63210: ARRAY
63211: PUSH
63212: LD_INT 1
63214: PLUS
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: PPUSH
63220: LD_VAR 0 1
63224: PPUSH
63225: CALL 71199 0 3
63229: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63230: LD_ADDR_VAR 0 6
63234: PUSH
63235: LD_EXP 99
63239: PUSH
63240: LD_VAR 0 3
63244: ARRAY
63245: PPUSH
63246: LD_INT 25
63248: PUSH
63249: LD_INT 1
63251: PUSH
63252: EMPTY
63253: LIST
63254: LIST
63255: PUSH
63256: LD_INT 3
63258: PUSH
63259: LD_INT 54
63261: PUSH
63262: EMPTY
63263: LIST
63264: PUSH
63265: EMPTY
63266: LIST
63267: LIST
63268: PUSH
63269: EMPTY
63270: LIST
63271: LIST
63272: PPUSH
63273: CALL_OW 72
63277: ST_TO_ADDR
// if tmp then
63278: LD_VAR 0 6
63282: IFFALSE 63288
// exit ;
63284: POP
63285: POP
63286: GO 63428
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63288: LD_ADDR_VAR 0 6
63292: PUSH
63293: LD_EXP 99
63297: PUSH
63298: LD_VAR 0 3
63302: ARRAY
63303: PPUSH
63304: LD_INT 2
63306: PUSH
63307: LD_INT 30
63309: PUSH
63310: LD_INT 4
63312: PUSH
63313: EMPTY
63314: LIST
63315: LIST
63316: PUSH
63317: LD_INT 30
63319: PUSH
63320: LD_INT 5
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: EMPTY
63328: LIST
63329: LIST
63330: LIST
63331: PPUSH
63332: CALL_OW 72
63336: ST_TO_ADDR
// if not tmp then
63337: LD_VAR 0 6
63341: NOT
63342: IFFALSE 63348
// exit ;
63344: POP
63345: POP
63346: GO 63428
// for j in tmp do
63348: LD_ADDR_VAR 0 4
63352: PUSH
63353: LD_VAR 0 6
63357: PUSH
63358: FOR_IN
63359: IFFALSE 63418
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63361: LD_ADDR_VAR 0 7
63365: PUSH
63366: LD_VAR 0 4
63370: PPUSH
63371: CALL_OW 313
63375: PPUSH
63376: LD_INT 25
63378: PUSH
63379: LD_INT 1
63381: PUSH
63382: EMPTY
63383: LIST
63384: LIST
63385: PPUSH
63386: CALL_OW 72
63390: ST_TO_ADDR
// if units then
63391: LD_VAR 0 7
63395: IFFALSE 63416
// begin ComExitBuilding ( units [ 1 ] ) ;
63397: LD_VAR 0 7
63401: PUSH
63402: LD_INT 1
63404: ARRAY
63405: PPUSH
63406: CALL_OW 122
// exit ;
63410: POP
63411: POP
63412: POP
63413: POP
63414: GO 63428
// end ; end ;
63416: GO 63358
63418: POP
63419: POP
// end ; end ; exit ;
63420: POP
63421: POP
63422: GO 63428
// end ; end ;
63424: GO 62782
63426: POP
63427: POP
// end ;
63428: LD_VAR 0 2
63432: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63433: LD_INT 0
63435: PPUSH
63436: PPUSH
63437: PPUSH
63438: PPUSH
63439: PPUSH
63440: PPUSH
63441: PPUSH
// if not mc_bases or not skirmish then
63442: LD_EXP 99
63446: NOT
63447: PUSH
63448: LD_EXP 97
63452: NOT
63453: OR
63454: IFFALSE 63458
// exit ;
63456: GO 63689
// btype := GetBType ( building ) ;
63458: LD_ADDR_VAR 0 6
63462: PUSH
63463: LD_VAR 0 1
63467: PPUSH
63468: CALL_OW 266
63472: ST_TO_ADDR
// x := GetX ( building ) ;
63473: LD_ADDR_VAR 0 7
63477: PUSH
63478: LD_VAR 0 1
63482: PPUSH
63483: CALL_OW 250
63487: ST_TO_ADDR
// y := GetY ( building ) ;
63488: LD_ADDR_VAR 0 8
63492: PUSH
63493: LD_VAR 0 1
63497: PPUSH
63498: CALL_OW 251
63502: ST_TO_ADDR
// d := GetDir ( building ) ;
63503: LD_ADDR_VAR 0 9
63507: PUSH
63508: LD_VAR 0 1
63512: PPUSH
63513: CALL_OW 254
63517: ST_TO_ADDR
// for i = 1 to mc_bases do
63518: LD_ADDR_VAR 0 4
63522: PUSH
63523: DOUBLE
63524: LD_INT 1
63526: DEC
63527: ST_TO_ADDR
63528: LD_EXP 99
63532: PUSH
63533: FOR_TO
63534: IFFALSE 63687
// begin if not mc_build_list [ i ] then
63536: LD_EXP 104
63540: PUSH
63541: LD_VAR 0 4
63545: ARRAY
63546: NOT
63547: IFFALSE 63551
// continue ;
63549: GO 63533
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63551: LD_VAR 0 6
63555: PUSH
63556: LD_VAR 0 7
63560: PUSH
63561: LD_VAR 0 8
63565: PUSH
63566: LD_VAR 0 9
63570: PUSH
63571: EMPTY
63572: LIST
63573: LIST
63574: LIST
63575: LIST
63576: PPUSH
63577: LD_EXP 104
63581: PUSH
63582: LD_VAR 0 4
63586: ARRAY
63587: PUSH
63588: LD_INT 1
63590: ARRAY
63591: PPUSH
63592: CALL 77368 0 2
63596: IFFALSE 63685
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63598: LD_ADDR_EXP 104
63602: PUSH
63603: LD_EXP 104
63607: PPUSH
63608: LD_VAR 0 4
63612: PPUSH
63613: LD_EXP 104
63617: PUSH
63618: LD_VAR 0 4
63622: ARRAY
63623: PPUSH
63624: LD_INT 1
63626: PPUSH
63627: CALL_OW 3
63631: PPUSH
63632: CALL_OW 1
63636: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63637: LD_ADDR_EXP 106
63641: PUSH
63642: LD_EXP 106
63646: PPUSH
63647: LD_VAR 0 4
63651: PUSH
63652: LD_EXP 106
63656: PUSH
63657: LD_VAR 0 4
63661: ARRAY
63662: PUSH
63663: LD_INT 1
63665: PLUS
63666: PUSH
63667: EMPTY
63668: LIST
63669: LIST
63670: PPUSH
63671: LD_VAR 0 1
63675: PPUSH
63676: CALL 71199 0 3
63680: ST_TO_ADDR
// exit ;
63681: POP
63682: POP
63683: GO 63689
// end ; end ;
63685: GO 63533
63687: POP
63688: POP
// end ;
63689: LD_VAR 0 3
63693: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63694: LD_INT 0
63696: PPUSH
63697: PPUSH
63698: PPUSH
// if not mc_bases or not skirmish then
63699: LD_EXP 99
63703: NOT
63704: PUSH
63705: LD_EXP 97
63709: NOT
63710: OR
63711: IFFALSE 63715
// exit ;
63713: GO 63905
// for i = 1 to mc_bases do
63715: LD_ADDR_VAR 0 4
63719: PUSH
63720: DOUBLE
63721: LD_INT 1
63723: DEC
63724: ST_TO_ADDR
63725: LD_EXP 99
63729: PUSH
63730: FOR_TO
63731: IFFALSE 63818
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63733: LD_VAR 0 1
63737: PUSH
63738: LD_EXP 107
63742: PUSH
63743: LD_VAR 0 4
63747: ARRAY
63748: IN
63749: PUSH
63750: LD_VAR 0 1
63754: PUSH
63755: LD_EXP 108
63759: PUSH
63760: LD_VAR 0 4
63764: ARRAY
63765: IN
63766: NOT
63767: AND
63768: IFFALSE 63816
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63770: LD_ADDR_EXP 108
63774: PUSH
63775: LD_EXP 108
63779: PPUSH
63780: LD_VAR 0 4
63784: PUSH
63785: LD_EXP 108
63789: PUSH
63790: LD_VAR 0 4
63794: ARRAY
63795: PUSH
63796: LD_INT 1
63798: PLUS
63799: PUSH
63800: EMPTY
63801: LIST
63802: LIST
63803: PPUSH
63804: LD_VAR 0 1
63808: PPUSH
63809: CALL 71199 0 3
63813: ST_TO_ADDR
// break ;
63814: GO 63818
// end ; end ;
63816: GO 63730
63818: POP
63819: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
63820: LD_VAR 0 1
63824: PPUSH
63825: CALL_OW 257
63829: PUSH
63830: LD_EXP 125
63834: IN
63835: PUSH
63836: LD_VAR 0 1
63840: PPUSH
63841: CALL_OW 266
63845: PUSH
63846: LD_INT 5
63848: EQUAL
63849: AND
63850: PUSH
63851: LD_VAR 0 2
63855: PPUSH
63856: CALL_OW 110
63860: PUSH
63861: LD_INT 18
63863: NONEQUAL
63864: AND
63865: IFFALSE 63905
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
63867: LD_VAR 0 2
63871: PPUSH
63872: CALL_OW 257
63876: PUSH
63877: LD_INT 5
63879: PUSH
63880: LD_INT 8
63882: PUSH
63883: LD_INT 9
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: LIST
63890: IN
63891: IFFALSE 63905
// SetClass ( unit , 1 ) ;
63893: LD_VAR 0 2
63897: PPUSH
63898: LD_INT 1
63900: PPUSH
63901: CALL_OW 336
// end ;
63905: LD_VAR 0 3
63909: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
63910: LD_INT 0
63912: PPUSH
63913: PPUSH
// if not mc_bases or not skirmish then
63914: LD_EXP 99
63918: NOT
63919: PUSH
63920: LD_EXP 97
63924: NOT
63925: OR
63926: IFFALSE 63930
// exit ;
63928: GO 64046
// if GetLives ( abandoned_vehicle ) > 250 then
63930: LD_VAR 0 2
63934: PPUSH
63935: CALL_OW 256
63939: PUSH
63940: LD_INT 250
63942: GREATER
63943: IFFALSE 63947
// exit ;
63945: GO 64046
// for i = 1 to mc_bases do
63947: LD_ADDR_VAR 0 6
63951: PUSH
63952: DOUBLE
63953: LD_INT 1
63955: DEC
63956: ST_TO_ADDR
63957: LD_EXP 99
63961: PUSH
63962: FOR_TO
63963: IFFALSE 64044
// begin if driver in mc_bases [ i ] then
63965: LD_VAR 0 1
63969: PUSH
63970: LD_EXP 99
63974: PUSH
63975: LD_VAR 0 6
63979: ARRAY
63980: IN
63981: IFFALSE 64042
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
63983: LD_VAR 0 1
63987: PPUSH
63988: LD_EXP 99
63992: PUSH
63993: LD_VAR 0 6
63997: ARRAY
63998: PPUSH
63999: LD_INT 2
64001: PUSH
64002: LD_INT 30
64004: PUSH
64005: LD_INT 0
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PUSH
64012: LD_INT 30
64014: PUSH
64015: LD_INT 1
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: LIST
64026: PPUSH
64027: CALL_OW 72
64031: PUSH
64032: LD_INT 1
64034: ARRAY
64035: PPUSH
64036: CALL_OW 112
// break ;
64040: GO 64044
// end ; end ;
64042: GO 63962
64044: POP
64045: POP
// end ; end_of_file
64046: LD_VAR 0 5
64050: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64051: LD_INT 0
64053: PPUSH
64054: PPUSH
// if exist_mode then
64055: LD_VAR 0 2
64059: IFFALSE 64084
// unit := CreateCharacter ( prefix & ident ) else
64061: LD_ADDR_VAR 0 5
64065: PUSH
64066: LD_VAR 0 3
64070: PUSH
64071: LD_VAR 0 1
64075: STR
64076: PPUSH
64077: CALL_OW 34
64081: ST_TO_ADDR
64082: GO 64099
// unit := NewCharacter ( ident ) ;
64084: LD_ADDR_VAR 0 5
64088: PUSH
64089: LD_VAR 0 1
64093: PPUSH
64094: CALL_OW 25
64098: ST_TO_ADDR
// result := unit ;
64099: LD_ADDR_VAR 0 4
64103: PUSH
64104: LD_VAR 0 5
64108: ST_TO_ADDR
// end ;
64109: LD_VAR 0 4
64113: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64114: LD_INT 0
64116: PPUSH
64117: PPUSH
// if not side or not nation then
64118: LD_VAR 0 1
64122: NOT
64123: PUSH
64124: LD_VAR 0 2
64128: NOT
64129: OR
64130: IFFALSE 64134
// exit ;
64132: GO 64778
// case nation of nation_american :
64134: LD_VAR 0 2
64138: PUSH
64139: LD_INT 1
64141: DOUBLE
64142: EQUAL
64143: IFTRUE 64147
64145: GO 64321
64147: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64148: LD_ADDR_VAR 0 4
64152: PUSH
64153: LD_INT 35
64155: PUSH
64156: LD_INT 45
64158: PUSH
64159: LD_INT 46
64161: PUSH
64162: LD_INT 47
64164: PUSH
64165: LD_INT 1
64167: PUSH
64168: LD_INT 2
64170: PUSH
64171: LD_INT 6
64173: PUSH
64174: LD_INT 15
64176: PUSH
64177: LD_INT 16
64179: PUSH
64180: LD_INT 7
64182: PUSH
64183: LD_INT 12
64185: PUSH
64186: LD_INT 13
64188: PUSH
64189: LD_INT 10
64191: PUSH
64192: LD_INT 14
64194: PUSH
64195: LD_INT 20
64197: PUSH
64198: LD_INT 21
64200: PUSH
64201: LD_INT 22
64203: PUSH
64204: LD_INT 25
64206: PUSH
64207: LD_INT 32
64209: PUSH
64210: LD_INT 27
64212: PUSH
64213: LD_INT 36
64215: PUSH
64216: LD_INT 69
64218: PUSH
64219: LD_INT 39
64221: PUSH
64222: LD_INT 34
64224: PUSH
64225: LD_INT 40
64227: PUSH
64228: LD_INT 48
64230: PUSH
64231: LD_INT 49
64233: PUSH
64234: LD_INT 50
64236: PUSH
64237: LD_INT 51
64239: PUSH
64240: LD_INT 52
64242: PUSH
64243: LD_INT 53
64245: PUSH
64246: LD_INT 54
64248: PUSH
64249: LD_INT 55
64251: PUSH
64252: LD_INT 56
64254: PUSH
64255: LD_INT 57
64257: PUSH
64258: LD_INT 58
64260: PUSH
64261: LD_INT 59
64263: PUSH
64264: LD_INT 60
64266: PUSH
64267: LD_INT 61
64269: PUSH
64270: LD_INT 62
64272: PUSH
64273: LD_INT 80
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: LIST
64280: LIST
64281: LIST
64282: LIST
64283: LIST
64284: LIST
64285: LIST
64286: LIST
64287: LIST
64288: LIST
64289: LIST
64290: LIST
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: ST_TO_ADDR
64319: GO 64702
64321: LD_INT 2
64323: DOUBLE
64324: EQUAL
64325: IFTRUE 64329
64327: GO 64511
64329: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64330: LD_ADDR_VAR 0 4
64334: PUSH
64335: LD_INT 35
64337: PUSH
64338: LD_INT 45
64340: PUSH
64341: LD_INT 46
64343: PUSH
64344: LD_INT 47
64346: PUSH
64347: LD_INT 70
64349: PUSH
64350: LD_INT 1
64352: PUSH
64353: LD_INT 11
64355: PUSH
64356: LD_INT 3
64358: PUSH
64359: LD_INT 4
64361: PUSH
64362: LD_INT 5
64364: PUSH
64365: LD_INT 6
64367: PUSH
64368: LD_INT 15
64370: PUSH
64371: LD_INT 18
64373: PUSH
64374: LD_INT 7
64376: PUSH
64377: LD_INT 17
64379: PUSH
64380: LD_INT 8
64382: PUSH
64383: LD_INT 20
64385: PUSH
64386: LD_INT 21
64388: PUSH
64389: LD_INT 22
64391: PUSH
64392: LD_INT 72
64394: PUSH
64395: LD_INT 26
64397: PUSH
64398: LD_INT 69
64400: PUSH
64401: LD_INT 39
64403: PUSH
64404: LD_INT 40
64406: PUSH
64407: LD_INT 41
64409: PUSH
64410: LD_INT 42
64412: PUSH
64413: LD_INT 43
64415: PUSH
64416: LD_INT 48
64418: PUSH
64419: LD_INT 49
64421: PUSH
64422: LD_INT 50
64424: PUSH
64425: LD_INT 51
64427: PUSH
64428: LD_INT 52
64430: PUSH
64431: LD_INT 53
64433: PUSH
64434: LD_INT 54
64436: PUSH
64437: LD_INT 55
64439: PUSH
64440: LD_INT 56
64442: PUSH
64443: LD_INT 60
64445: PUSH
64446: LD_INT 61
64448: PUSH
64449: LD_INT 62
64451: PUSH
64452: LD_INT 66
64454: PUSH
64455: LD_INT 67
64457: PUSH
64458: LD_INT 68
64460: PUSH
64461: LD_INT 81
64463: PUSH
64464: EMPTY
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: LIST
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: ST_TO_ADDR
64509: GO 64702
64511: LD_INT 3
64513: DOUBLE
64514: EQUAL
64515: IFTRUE 64519
64517: GO 64701
64519: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64520: LD_ADDR_VAR 0 4
64524: PUSH
64525: LD_INT 46
64527: PUSH
64528: LD_INT 47
64530: PUSH
64531: LD_INT 1
64533: PUSH
64534: LD_INT 2
64536: PUSH
64537: LD_INT 11
64539: PUSH
64540: LD_INT 9
64542: PUSH
64543: LD_INT 20
64545: PUSH
64546: LD_INT 19
64548: PUSH
64549: LD_INT 21
64551: PUSH
64552: LD_INT 24
64554: PUSH
64555: LD_INT 22
64557: PUSH
64558: LD_INT 25
64560: PUSH
64561: LD_INT 28
64563: PUSH
64564: LD_INT 29
64566: PUSH
64567: LD_INT 30
64569: PUSH
64570: LD_INT 31
64572: PUSH
64573: LD_INT 37
64575: PUSH
64576: LD_INT 38
64578: PUSH
64579: LD_INT 32
64581: PUSH
64582: LD_INT 27
64584: PUSH
64585: LD_INT 33
64587: PUSH
64588: LD_INT 69
64590: PUSH
64591: LD_INT 39
64593: PUSH
64594: LD_INT 34
64596: PUSH
64597: LD_INT 40
64599: PUSH
64600: LD_INT 71
64602: PUSH
64603: LD_INT 23
64605: PUSH
64606: LD_INT 44
64608: PUSH
64609: LD_INT 48
64611: PUSH
64612: LD_INT 49
64614: PUSH
64615: LD_INT 50
64617: PUSH
64618: LD_INT 51
64620: PUSH
64621: LD_INT 52
64623: PUSH
64624: LD_INT 53
64626: PUSH
64627: LD_INT 54
64629: PUSH
64630: LD_INT 55
64632: PUSH
64633: LD_INT 56
64635: PUSH
64636: LD_INT 57
64638: PUSH
64639: LD_INT 58
64641: PUSH
64642: LD_INT 59
64644: PUSH
64645: LD_INT 63
64647: PUSH
64648: LD_INT 64
64650: PUSH
64651: LD_INT 65
64653: PUSH
64654: EMPTY
64655: LIST
64656: LIST
64657: LIST
64658: LIST
64659: LIST
64660: LIST
64661: LIST
64662: LIST
64663: LIST
64664: LIST
64665: LIST
64666: LIST
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: LIST
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: ST_TO_ADDR
64699: GO 64702
64701: POP
// if state > - 1 and state < 3 then
64702: LD_VAR 0 3
64706: PUSH
64707: LD_INT 1
64709: NEG
64710: GREATER
64711: PUSH
64712: LD_VAR 0 3
64716: PUSH
64717: LD_INT 3
64719: LESS
64720: AND
64721: IFFALSE 64778
// for i in result do
64723: LD_ADDR_VAR 0 5
64727: PUSH
64728: LD_VAR 0 4
64732: PUSH
64733: FOR_IN
64734: IFFALSE 64776
// if GetTech ( i , side ) <> state then
64736: LD_VAR 0 5
64740: PPUSH
64741: LD_VAR 0 1
64745: PPUSH
64746: CALL_OW 321
64750: PUSH
64751: LD_VAR 0 3
64755: NONEQUAL
64756: IFFALSE 64774
// result := result diff i ;
64758: LD_ADDR_VAR 0 4
64762: PUSH
64763: LD_VAR 0 4
64767: PUSH
64768: LD_VAR 0 5
64772: DIFF
64773: ST_TO_ADDR
64774: GO 64733
64776: POP
64777: POP
// end ;
64778: LD_VAR 0 4
64782: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64783: LD_INT 0
64785: PPUSH
64786: PPUSH
64787: PPUSH
// result := true ;
64788: LD_ADDR_VAR 0 3
64792: PUSH
64793: LD_INT 1
64795: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64796: LD_ADDR_VAR 0 5
64800: PUSH
64801: LD_VAR 0 2
64805: PPUSH
64806: CALL_OW 480
64810: ST_TO_ADDR
// if not tmp then
64811: LD_VAR 0 5
64815: NOT
64816: IFFALSE 64820
// exit ;
64818: GO 64869
// for i in tmp do
64820: LD_ADDR_VAR 0 4
64824: PUSH
64825: LD_VAR 0 5
64829: PUSH
64830: FOR_IN
64831: IFFALSE 64867
// if GetTech ( i , side ) <> state_researched then
64833: LD_VAR 0 4
64837: PPUSH
64838: LD_VAR 0 1
64842: PPUSH
64843: CALL_OW 321
64847: PUSH
64848: LD_INT 2
64850: NONEQUAL
64851: IFFALSE 64865
// begin result := false ;
64853: LD_ADDR_VAR 0 3
64857: PUSH
64858: LD_INT 0
64860: ST_TO_ADDR
// exit ;
64861: POP
64862: POP
64863: GO 64869
// end ;
64865: GO 64830
64867: POP
64868: POP
// end ;
64869: LD_VAR 0 3
64873: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64874: LD_INT 0
64876: PPUSH
64877: PPUSH
64878: PPUSH
64879: PPUSH
64880: PPUSH
64881: PPUSH
64882: PPUSH
64883: PPUSH
64884: PPUSH
64885: PPUSH
64886: PPUSH
64887: PPUSH
64888: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64889: LD_VAR 0 1
64893: NOT
64894: PUSH
64895: LD_VAR 0 1
64899: PPUSH
64900: CALL_OW 257
64904: PUSH
64905: LD_INT 9
64907: NONEQUAL
64908: OR
64909: IFFALSE 64913
// exit ;
64911: GO 65486
// side := GetSide ( unit ) ;
64913: LD_ADDR_VAR 0 9
64917: PUSH
64918: LD_VAR 0 1
64922: PPUSH
64923: CALL_OW 255
64927: ST_TO_ADDR
// tech_space := tech_spacanom ;
64928: LD_ADDR_VAR 0 12
64932: PUSH
64933: LD_INT 29
64935: ST_TO_ADDR
// tech_time := tech_taurad ;
64936: LD_ADDR_VAR 0 13
64940: PUSH
64941: LD_INT 28
64943: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64944: LD_ADDR_VAR 0 11
64948: PUSH
64949: LD_VAR 0 1
64953: PPUSH
64954: CALL_OW 310
64958: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64959: LD_VAR 0 11
64963: PPUSH
64964: CALL_OW 247
64968: PUSH
64969: LD_INT 2
64971: EQUAL
64972: IFFALSE 64976
// exit ;
64974: GO 65486
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64976: LD_ADDR_VAR 0 8
64980: PUSH
64981: LD_INT 81
64983: PUSH
64984: LD_VAR 0 9
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: PUSH
64993: LD_INT 3
64995: PUSH
64996: LD_INT 21
64998: PUSH
64999: LD_INT 3
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: EMPTY
65007: LIST
65008: LIST
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PPUSH
65014: CALL_OW 69
65018: ST_TO_ADDR
// if not tmp then
65019: LD_VAR 0 8
65023: NOT
65024: IFFALSE 65028
// exit ;
65026: GO 65486
// if in_unit then
65028: LD_VAR 0 11
65032: IFFALSE 65056
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65034: LD_ADDR_VAR 0 10
65038: PUSH
65039: LD_VAR 0 8
65043: PPUSH
65044: LD_VAR 0 11
65048: PPUSH
65049: CALL_OW 74
65053: ST_TO_ADDR
65054: GO 65076
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65056: LD_ADDR_VAR 0 10
65060: PUSH
65061: LD_VAR 0 8
65065: PPUSH
65066: LD_VAR 0 1
65070: PPUSH
65071: CALL_OW 74
65075: ST_TO_ADDR
// if not enemy then
65076: LD_VAR 0 10
65080: NOT
65081: IFFALSE 65085
// exit ;
65083: GO 65486
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65085: LD_VAR 0 11
65089: PUSH
65090: LD_VAR 0 11
65094: PPUSH
65095: LD_VAR 0 10
65099: PPUSH
65100: CALL_OW 296
65104: PUSH
65105: LD_INT 13
65107: GREATER
65108: AND
65109: PUSH
65110: LD_VAR 0 1
65114: PPUSH
65115: LD_VAR 0 10
65119: PPUSH
65120: CALL_OW 296
65124: PUSH
65125: LD_INT 12
65127: GREATER
65128: OR
65129: IFFALSE 65133
// exit ;
65131: GO 65486
// missile := [ 1 ] ;
65133: LD_ADDR_VAR 0 14
65137: PUSH
65138: LD_INT 1
65140: PUSH
65141: EMPTY
65142: LIST
65143: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65144: LD_VAR 0 9
65148: PPUSH
65149: LD_VAR 0 12
65153: PPUSH
65154: CALL_OW 325
65158: IFFALSE 65187
// missile := Insert ( missile , missile + 1 , 2 ) ;
65160: LD_ADDR_VAR 0 14
65164: PUSH
65165: LD_VAR 0 14
65169: PPUSH
65170: LD_VAR 0 14
65174: PUSH
65175: LD_INT 1
65177: PLUS
65178: PPUSH
65179: LD_INT 2
65181: PPUSH
65182: CALL_OW 2
65186: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65187: LD_VAR 0 9
65191: PPUSH
65192: LD_VAR 0 13
65196: PPUSH
65197: CALL_OW 325
65201: PUSH
65202: LD_VAR 0 10
65206: PPUSH
65207: CALL_OW 255
65211: PPUSH
65212: LD_VAR 0 13
65216: PPUSH
65217: CALL_OW 325
65221: NOT
65222: AND
65223: IFFALSE 65252
// missile := Insert ( missile , missile + 1 , 3 ) ;
65225: LD_ADDR_VAR 0 14
65229: PUSH
65230: LD_VAR 0 14
65234: PPUSH
65235: LD_VAR 0 14
65239: PUSH
65240: LD_INT 1
65242: PLUS
65243: PPUSH
65244: LD_INT 3
65246: PPUSH
65247: CALL_OW 2
65251: ST_TO_ADDR
// if missile < 2 then
65252: LD_VAR 0 14
65256: PUSH
65257: LD_INT 2
65259: LESS
65260: IFFALSE 65264
// exit ;
65262: GO 65486
// x := GetX ( enemy ) ;
65264: LD_ADDR_VAR 0 4
65268: PUSH
65269: LD_VAR 0 10
65273: PPUSH
65274: CALL_OW 250
65278: ST_TO_ADDR
// y := GetY ( enemy ) ;
65279: LD_ADDR_VAR 0 5
65283: PUSH
65284: LD_VAR 0 10
65288: PPUSH
65289: CALL_OW 251
65293: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65294: LD_ADDR_VAR 0 6
65298: PUSH
65299: LD_VAR 0 4
65303: PUSH
65304: LD_INT 1
65306: NEG
65307: PPUSH
65308: LD_INT 1
65310: PPUSH
65311: CALL_OW 12
65315: PLUS
65316: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65317: LD_ADDR_VAR 0 7
65321: PUSH
65322: LD_VAR 0 5
65326: PUSH
65327: LD_INT 1
65329: NEG
65330: PPUSH
65331: LD_INT 1
65333: PPUSH
65334: CALL_OW 12
65338: PLUS
65339: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65340: LD_VAR 0 6
65344: PPUSH
65345: LD_VAR 0 7
65349: PPUSH
65350: CALL_OW 488
65354: NOT
65355: IFFALSE 65377
// begin _x := x ;
65357: LD_ADDR_VAR 0 6
65361: PUSH
65362: LD_VAR 0 4
65366: ST_TO_ADDR
// _y := y ;
65367: LD_ADDR_VAR 0 7
65371: PUSH
65372: LD_VAR 0 5
65376: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65377: LD_ADDR_VAR 0 3
65381: PUSH
65382: LD_INT 1
65384: PPUSH
65385: LD_VAR 0 14
65389: PPUSH
65390: CALL_OW 12
65394: ST_TO_ADDR
// case i of 1 :
65395: LD_VAR 0 3
65399: PUSH
65400: LD_INT 1
65402: DOUBLE
65403: EQUAL
65404: IFTRUE 65408
65406: GO 65425
65408: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65409: LD_VAR 0 1
65413: PPUSH
65414: LD_VAR 0 10
65418: PPUSH
65419: CALL_OW 115
65423: GO 65486
65425: LD_INT 2
65427: DOUBLE
65428: EQUAL
65429: IFTRUE 65433
65431: GO 65455
65433: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65434: LD_VAR 0 1
65438: PPUSH
65439: LD_VAR 0 6
65443: PPUSH
65444: LD_VAR 0 7
65448: PPUSH
65449: CALL_OW 153
65453: GO 65486
65455: LD_INT 3
65457: DOUBLE
65458: EQUAL
65459: IFTRUE 65463
65461: GO 65485
65463: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65464: LD_VAR 0 1
65468: PPUSH
65469: LD_VAR 0 6
65473: PPUSH
65474: LD_VAR 0 7
65478: PPUSH
65479: CALL_OW 154
65483: GO 65486
65485: POP
// end ;
65486: LD_VAR 0 2
65490: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65491: LD_INT 0
65493: PPUSH
65494: PPUSH
65495: PPUSH
65496: PPUSH
65497: PPUSH
65498: PPUSH
// if not unit or not building then
65499: LD_VAR 0 1
65503: NOT
65504: PUSH
65505: LD_VAR 0 2
65509: NOT
65510: OR
65511: IFFALSE 65515
// exit ;
65513: GO 65673
// x := GetX ( building ) ;
65515: LD_ADDR_VAR 0 5
65519: PUSH
65520: LD_VAR 0 2
65524: PPUSH
65525: CALL_OW 250
65529: ST_TO_ADDR
// y := GetY ( building ) ;
65530: LD_ADDR_VAR 0 6
65534: PUSH
65535: LD_VAR 0 2
65539: PPUSH
65540: CALL_OW 251
65544: ST_TO_ADDR
// for i = 0 to 5 do
65545: LD_ADDR_VAR 0 4
65549: PUSH
65550: DOUBLE
65551: LD_INT 0
65553: DEC
65554: ST_TO_ADDR
65555: LD_INT 5
65557: PUSH
65558: FOR_TO
65559: IFFALSE 65671
// begin _x := ShiftX ( x , i , 3 ) ;
65561: LD_ADDR_VAR 0 7
65565: PUSH
65566: LD_VAR 0 5
65570: PPUSH
65571: LD_VAR 0 4
65575: PPUSH
65576: LD_INT 3
65578: PPUSH
65579: CALL_OW 272
65583: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65584: LD_ADDR_VAR 0 8
65588: PUSH
65589: LD_VAR 0 6
65593: PPUSH
65594: LD_VAR 0 4
65598: PPUSH
65599: LD_INT 3
65601: PPUSH
65602: CALL_OW 273
65606: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65607: LD_VAR 0 7
65611: PPUSH
65612: LD_VAR 0 8
65616: PPUSH
65617: CALL_OW 488
65621: NOT
65622: IFFALSE 65626
// continue ;
65624: GO 65558
// if HexInfo ( _x , _y ) = 0 then
65626: LD_VAR 0 7
65630: PPUSH
65631: LD_VAR 0 8
65635: PPUSH
65636: CALL_OW 428
65640: PUSH
65641: LD_INT 0
65643: EQUAL
65644: IFFALSE 65669
// begin ComMoveXY ( unit , _x , _y ) ;
65646: LD_VAR 0 1
65650: PPUSH
65651: LD_VAR 0 7
65655: PPUSH
65656: LD_VAR 0 8
65660: PPUSH
65661: CALL_OW 111
// exit ;
65665: POP
65666: POP
65667: GO 65673
// end ; end ;
65669: GO 65558
65671: POP
65672: POP
// end ;
65673: LD_VAR 0 3
65677: RET
// export function ScanBase ( side , base_area ) ; begin
65678: LD_INT 0
65680: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65681: LD_ADDR_VAR 0 3
65685: PUSH
65686: LD_VAR 0 2
65690: PPUSH
65691: LD_INT 81
65693: PUSH
65694: LD_VAR 0 1
65698: PUSH
65699: EMPTY
65700: LIST
65701: LIST
65702: PPUSH
65703: CALL_OW 70
65707: ST_TO_ADDR
// end ;
65708: LD_VAR 0 3
65712: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65713: LD_INT 0
65715: PPUSH
65716: PPUSH
65717: PPUSH
65718: PPUSH
65719: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65720: LD_VAR 0 1
65724: NOT
65725: PUSH
65726: LD_EXP 99
65730: PUSH
65731: LD_VAR 0 1
65735: ARRAY
65736: NOT
65737: OR
65738: PUSH
65739: LD_VAR 0 2
65743: NOT
65744: OR
65745: PUSH
65746: LD_VAR 0 3
65750: NOT
65751: OR
65752: IFFALSE 65756
// exit ;
65754: GO 66269
// side := mc_sides [ base ] ;
65756: LD_ADDR_VAR 0 6
65760: PUSH
65761: LD_EXP 125
65765: PUSH
65766: LD_VAR 0 1
65770: ARRAY
65771: ST_TO_ADDR
// if not side then
65772: LD_VAR 0 6
65776: NOT
65777: IFFALSE 65781
// exit ;
65779: GO 66269
// for i in solds do
65781: LD_ADDR_VAR 0 7
65785: PUSH
65786: LD_VAR 0 2
65790: PUSH
65791: FOR_IN
65792: IFFALSE 65853
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
65794: LD_VAR 0 7
65798: PPUSH
65799: CALL_OW 310
65803: PPUSH
65804: CALL_OW 266
65808: PUSH
65809: LD_INT 32
65811: PUSH
65812: LD_INT 31
65814: PUSH
65815: EMPTY
65816: LIST
65817: LIST
65818: IN
65819: IFFALSE 65839
// solds := solds diff i else
65821: LD_ADDR_VAR 0 2
65825: PUSH
65826: LD_VAR 0 2
65830: PUSH
65831: LD_VAR 0 7
65835: DIFF
65836: ST_TO_ADDR
65837: GO 65851
// SetTag ( i , 18 ) ;
65839: LD_VAR 0 7
65843: PPUSH
65844: LD_INT 18
65846: PPUSH
65847: CALL_OW 109
65851: GO 65791
65853: POP
65854: POP
// if not solds then
65855: LD_VAR 0 2
65859: NOT
65860: IFFALSE 65864
// exit ;
65862: GO 66269
// repeat wait ( 0 0$1 ) ;
65864: LD_INT 35
65866: PPUSH
65867: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
65871: LD_ADDR_VAR 0 5
65875: PUSH
65876: LD_VAR 0 6
65880: PPUSH
65881: LD_VAR 0 3
65885: PPUSH
65886: CALL 65678 0 2
65890: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
65891: LD_EXP 99
65895: PUSH
65896: LD_VAR 0 1
65900: ARRAY
65901: NOT
65902: PUSH
65903: LD_EXP 99
65907: PUSH
65908: LD_VAR 0 1
65912: ARRAY
65913: PUSH
65914: EMPTY
65915: EQUAL
65916: OR
65917: IFFALSE 65954
// begin for i in solds do
65919: LD_ADDR_VAR 0 7
65923: PUSH
65924: LD_VAR 0 2
65928: PUSH
65929: FOR_IN
65930: IFFALSE 65943
// ComStop ( i ) ;
65932: LD_VAR 0 7
65936: PPUSH
65937: CALL_OW 141
65941: GO 65929
65943: POP
65944: POP
// solds := [ ] ;
65945: LD_ADDR_VAR 0 2
65949: PUSH
65950: EMPTY
65951: ST_TO_ADDR
// exit ;
65952: GO 66269
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
65954: LD_VAR 0 5
65958: NOT
65959: PUSH
65960: LD_VAR 0 5
65964: PUSH
65965: LD_INT 3
65967: GREATER
65968: OR
65969: PUSH
65970: LD_EXP 121
65974: PUSH
65975: LD_VAR 0 1
65979: ARRAY
65980: OR
65981: IFFALSE 66022
// begin for i in solds do
65983: LD_ADDR_VAR 0 7
65987: PUSH
65988: LD_VAR 0 2
65992: PUSH
65993: FOR_IN
65994: IFFALSE 66018
// if HasTask ( i ) then
65996: LD_VAR 0 7
66000: PPUSH
66001: CALL_OW 314
66005: IFFALSE 66016
// ComStop ( i ) ;
66007: LD_VAR 0 7
66011: PPUSH
66012: CALL_OW 141
66016: GO 65993
66018: POP
66019: POP
// break ;
66020: GO 66257
// end ; for i in solds do
66022: LD_ADDR_VAR 0 7
66026: PUSH
66027: LD_VAR 0 2
66031: PUSH
66032: FOR_IN
66033: IFFALSE 66249
// begin if IsInUnit ( i ) then
66035: LD_VAR 0 7
66039: PPUSH
66040: CALL_OW 310
66044: IFFALSE 66055
// ComExitBuilding ( i ) ;
66046: LD_VAR 0 7
66050: PPUSH
66051: CALL_OW 122
// if GetLives ( i ) > 333 then
66055: LD_VAR 0 7
66059: PPUSH
66060: CALL_OW 256
66064: PUSH
66065: LD_INT 333
66067: GREATER
66068: IFFALSE 66096
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66070: LD_VAR 0 7
66074: PPUSH
66075: LD_VAR 0 5
66079: PPUSH
66080: LD_VAR 0 7
66084: PPUSH
66085: CALL_OW 74
66089: PPUSH
66090: CALL_OW 115
66094: GO 66247
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66096: LD_ADDR_VAR 0 8
66100: PUSH
66101: LD_EXP 99
66105: PUSH
66106: LD_VAR 0 1
66110: ARRAY
66111: PPUSH
66112: LD_INT 2
66114: PUSH
66115: LD_INT 30
66117: PUSH
66118: LD_INT 0
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PUSH
66125: LD_INT 30
66127: PUSH
66128: LD_INT 1
66130: PUSH
66131: EMPTY
66132: LIST
66133: LIST
66134: PUSH
66135: LD_INT 30
66137: PUSH
66138: LD_INT 6
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: PPUSH
66151: CALL_OW 72
66155: PPUSH
66156: LD_VAR 0 7
66160: PPUSH
66161: CALL_OW 74
66165: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66166: LD_VAR 0 7
66170: PPUSH
66171: LD_VAR 0 8
66175: PPUSH
66176: CALL_OW 250
66180: PPUSH
66181: LD_INT 3
66183: PPUSH
66184: LD_INT 5
66186: PPUSH
66187: CALL_OW 272
66191: PPUSH
66192: LD_VAR 0 8
66196: PPUSH
66197: CALL_OW 251
66201: PPUSH
66202: LD_INT 3
66204: PPUSH
66205: LD_INT 5
66207: PPUSH
66208: CALL_OW 273
66212: PPUSH
66213: CALL_OW 111
// SetTag ( i , 0 ) ;
66217: LD_VAR 0 7
66221: PPUSH
66222: LD_INT 0
66224: PPUSH
66225: CALL_OW 109
// solds := solds diff i ;
66229: LD_ADDR_VAR 0 2
66233: PUSH
66234: LD_VAR 0 2
66238: PUSH
66239: LD_VAR 0 7
66243: DIFF
66244: ST_TO_ADDR
// continue ;
66245: GO 66032
// end ; end ;
66247: GO 66032
66249: POP
66250: POP
// until solds ;
66251: LD_VAR 0 2
66255: IFFALSE 65864
// MC_Reset ( base , 18 ) ;
66257: LD_VAR 0 1
66261: PPUSH
66262: LD_INT 18
66264: PPUSH
66265: CALL 37986 0 2
// end ;
66269: LD_VAR 0 4
66273: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66274: LD_INT 0
66276: PPUSH
66277: PPUSH
66278: PPUSH
66279: PPUSH
66280: PPUSH
66281: PPUSH
66282: PPUSH
66283: PPUSH
66284: PPUSH
66285: PPUSH
66286: PPUSH
66287: PPUSH
66288: PPUSH
66289: PPUSH
66290: PPUSH
66291: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66292: LD_ADDR_VAR 0 12
66296: PUSH
66297: LD_EXP 99
66301: PUSH
66302: LD_VAR 0 1
66306: ARRAY
66307: PPUSH
66308: LD_INT 25
66310: PUSH
66311: LD_INT 3
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PPUSH
66318: CALL_OW 72
66322: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66323: LD_EXP 139
66327: PUSH
66328: LD_VAR 0 1
66332: ARRAY
66333: IFFALSE 66357
// mechs := mechs diff mc_remote_driver [ base ] ;
66335: LD_ADDR_VAR 0 12
66339: PUSH
66340: LD_VAR 0 12
66344: PUSH
66345: LD_EXP 139
66349: PUSH
66350: LD_VAR 0 1
66354: ARRAY
66355: DIFF
66356: ST_TO_ADDR
// for i in mechs do
66357: LD_ADDR_VAR 0 5
66361: PUSH
66362: LD_VAR 0 12
66366: PUSH
66367: FOR_IN
66368: IFFALSE 66403
// if GetTag ( i ) > 0 then
66370: LD_VAR 0 5
66374: PPUSH
66375: CALL_OW 110
66379: PUSH
66380: LD_INT 0
66382: GREATER
66383: IFFALSE 66401
// mechs := mechs diff i ;
66385: LD_ADDR_VAR 0 12
66389: PUSH
66390: LD_VAR 0 12
66394: PUSH
66395: LD_VAR 0 5
66399: DIFF
66400: ST_TO_ADDR
66401: GO 66367
66403: POP
66404: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66405: LD_ADDR_VAR 0 8
66409: PUSH
66410: LD_EXP 99
66414: PUSH
66415: LD_VAR 0 1
66419: ARRAY
66420: PPUSH
66421: LD_INT 2
66423: PUSH
66424: LD_INT 25
66426: PUSH
66427: LD_INT 1
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 25
66436: PUSH
66437: LD_INT 5
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 25
66446: PUSH
66447: LD_INT 8
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 25
66456: PUSH
66457: LD_INT 9
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: LIST
66468: LIST
66469: LIST
66470: PPUSH
66471: CALL_OW 72
66475: ST_TO_ADDR
// if not defenders and not solds then
66476: LD_VAR 0 2
66480: NOT
66481: PUSH
66482: LD_VAR 0 8
66486: NOT
66487: AND
66488: IFFALSE 66492
// exit ;
66490: GO 68030
// depot_under_attack := false ;
66492: LD_ADDR_VAR 0 16
66496: PUSH
66497: LD_INT 0
66499: ST_TO_ADDR
// sold_defenders := [ ] ;
66500: LD_ADDR_VAR 0 17
66504: PUSH
66505: EMPTY
66506: ST_TO_ADDR
// if mechs then
66507: LD_VAR 0 12
66511: IFFALSE 66640
// for i in defenders do
66513: LD_ADDR_VAR 0 5
66517: PUSH
66518: LD_VAR 0 2
66522: PUSH
66523: FOR_IN
66524: IFFALSE 66638
// begin SetTag ( i , 20 ) ;
66526: LD_VAR 0 5
66530: PPUSH
66531: LD_INT 20
66533: PPUSH
66534: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66538: LD_VAR 0 5
66542: PPUSH
66543: CALL_OW 263
66547: PUSH
66548: LD_INT 1
66550: EQUAL
66551: PUSH
66552: LD_VAR 0 5
66556: PPUSH
66557: CALL_OW 311
66561: NOT
66562: AND
66563: PUSH
66564: LD_VAR 0 12
66568: AND
66569: IFFALSE 66636
// begin un := mechs [ 1 ] ;
66571: LD_ADDR_VAR 0 10
66575: PUSH
66576: LD_VAR 0 12
66580: PUSH
66581: LD_INT 1
66583: ARRAY
66584: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66585: LD_VAR 0 10
66589: PPUSH
66590: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66594: LD_VAR 0 10
66598: PPUSH
66599: LD_VAR 0 5
66603: PPUSH
66604: CALL_OW 180
// SetTag ( un , 19 ) ;
66608: LD_VAR 0 10
66612: PPUSH
66613: LD_INT 19
66615: PPUSH
66616: CALL_OW 109
// mechs := mechs diff un ;
66620: LD_ADDR_VAR 0 12
66624: PUSH
66625: LD_VAR 0 12
66629: PUSH
66630: LD_VAR 0 10
66634: DIFF
66635: ST_TO_ADDR
// end ; end ;
66636: GO 66523
66638: POP
66639: POP
// if solds then
66640: LD_VAR 0 8
66644: IFFALSE 66703
// for i in solds do
66646: LD_ADDR_VAR 0 5
66650: PUSH
66651: LD_VAR 0 8
66655: PUSH
66656: FOR_IN
66657: IFFALSE 66701
// if not GetTag ( i ) then
66659: LD_VAR 0 5
66663: PPUSH
66664: CALL_OW 110
66668: NOT
66669: IFFALSE 66699
// begin defenders := defenders union i ;
66671: LD_ADDR_VAR 0 2
66675: PUSH
66676: LD_VAR 0 2
66680: PUSH
66681: LD_VAR 0 5
66685: UNION
66686: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66687: LD_VAR 0 5
66691: PPUSH
66692: LD_INT 18
66694: PPUSH
66695: CALL_OW 109
// end ;
66699: GO 66656
66701: POP
66702: POP
// repeat wait ( 0 0$1 ) ;
66703: LD_INT 35
66705: PPUSH
66706: CALL_OW 67
// enemy := mc_scan [ base ] ;
66710: LD_ADDR_VAR 0 3
66714: PUSH
66715: LD_EXP 122
66719: PUSH
66720: LD_VAR 0 1
66724: ARRAY
66725: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66726: LD_EXP 99
66730: PUSH
66731: LD_VAR 0 1
66735: ARRAY
66736: NOT
66737: PUSH
66738: LD_EXP 99
66742: PUSH
66743: LD_VAR 0 1
66747: ARRAY
66748: PUSH
66749: EMPTY
66750: EQUAL
66751: OR
66752: IFFALSE 66789
// begin for i in defenders do
66754: LD_ADDR_VAR 0 5
66758: PUSH
66759: LD_VAR 0 2
66763: PUSH
66764: FOR_IN
66765: IFFALSE 66778
// ComStop ( i ) ;
66767: LD_VAR 0 5
66771: PPUSH
66772: CALL_OW 141
66776: GO 66764
66778: POP
66779: POP
// defenders := [ ] ;
66780: LD_ADDR_VAR 0 2
66784: PUSH
66785: EMPTY
66786: ST_TO_ADDR
// exit ;
66787: GO 68030
// end ; for i in defenders do
66789: LD_ADDR_VAR 0 5
66793: PUSH
66794: LD_VAR 0 2
66798: PUSH
66799: FOR_IN
66800: IFFALSE 67530
// begin e := NearestUnitToUnit ( enemy , i ) ;
66802: LD_ADDR_VAR 0 13
66806: PUSH
66807: LD_VAR 0 3
66811: PPUSH
66812: LD_VAR 0 5
66816: PPUSH
66817: CALL_OW 74
66821: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
66822: LD_ADDR_VAR 0 16
66826: PUSH
66827: LD_EXP 99
66831: PUSH
66832: LD_VAR 0 1
66836: ARRAY
66837: PPUSH
66838: LD_INT 2
66840: PUSH
66841: LD_INT 30
66843: PUSH
66844: LD_INT 0
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 30
66853: PUSH
66854: LD_INT 1
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: LIST
66865: PPUSH
66866: CALL_OW 72
66870: NOT
66871: PUSH
66872: LD_EXP 99
66876: PUSH
66877: LD_VAR 0 1
66881: ARRAY
66882: PPUSH
66883: LD_INT 2
66885: PUSH
66886: LD_INT 30
66888: PUSH
66889: LD_INT 0
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 30
66898: PUSH
66899: LD_INT 1
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: LIST
66910: PPUSH
66911: CALL_OW 72
66915: PPUSH
66916: CALL_OW 256
66920: PUSH
66921: LD_INT 600
66923: LESS
66924: OR
66925: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
66926: LD_VAR 0 5
66930: PPUSH
66931: CALL_OW 247
66935: PUSH
66936: LD_INT 2
66938: DOUBLE
66939: EQUAL
66940: IFTRUE 66944
66942: GO 67236
66944: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
66945: LD_VAR 0 5
66949: PPUSH
66950: CALL_OW 256
66954: PUSH
66955: LD_INT 650
66957: GREATER
66958: PUSH
66959: LD_VAR 0 5
66963: PPUSH
66964: LD_VAR 0 13
66968: PPUSH
66969: CALL_OW 296
66973: PUSH
66974: LD_INT 40
66976: LESS
66977: PUSH
66978: LD_VAR 0 13
66982: PPUSH
66983: LD_EXP 124
66987: PUSH
66988: LD_VAR 0 1
66992: ARRAY
66993: PPUSH
66994: CALL_OW 308
66998: OR
66999: AND
67000: IFFALSE 67018
// ComAttackUnit ( i , e ) else
67002: LD_VAR 0 5
67006: PPUSH
67007: LD_VAR 0 13
67011: PPUSH
67012: CALL_OW 115
67016: GO 67119
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67018: LD_VAR 0 13
67022: PPUSH
67023: LD_EXP 124
67027: PUSH
67028: LD_VAR 0 1
67032: ARRAY
67033: PPUSH
67034: CALL_OW 308
67038: NOT
67039: PUSH
67040: LD_VAR 0 5
67044: PPUSH
67045: LD_VAR 0 13
67049: PPUSH
67050: CALL_OW 296
67054: PUSH
67055: LD_INT 40
67057: GREATEREQUAL
67058: AND
67059: PUSH
67060: LD_VAR 0 5
67064: PPUSH
67065: CALL_OW 256
67069: PUSH
67070: LD_INT 650
67072: LESSEQUAL
67073: OR
67074: PUSH
67075: LD_VAR 0 5
67079: PPUSH
67080: LD_EXP 123
67084: PUSH
67085: LD_VAR 0 1
67089: ARRAY
67090: PPUSH
67091: CALL_OW 308
67095: NOT
67096: AND
67097: IFFALSE 67119
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67099: LD_VAR 0 5
67103: PPUSH
67104: LD_EXP 123
67108: PUSH
67109: LD_VAR 0 1
67113: ARRAY
67114: PPUSH
67115: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67119: LD_VAR 0 5
67123: PPUSH
67124: CALL_OW 256
67128: PUSH
67129: LD_INT 998
67131: LESS
67132: PUSH
67133: LD_VAR 0 5
67137: PPUSH
67138: CALL_OW 263
67142: PUSH
67143: LD_INT 1
67145: EQUAL
67146: AND
67147: PUSH
67148: LD_VAR 0 5
67152: PPUSH
67153: CALL_OW 311
67157: AND
67158: PUSH
67159: LD_VAR 0 5
67163: PPUSH
67164: LD_EXP 123
67168: PUSH
67169: LD_VAR 0 1
67173: ARRAY
67174: PPUSH
67175: CALL_OW 308
67179: AND
67180: IFFALSE 67234
// begin mech := IsDrivenBy ( i ) ;
67182: LD_ADDR_VAR 0 9
67186: PUSH
67187: LD_VAR 0 5
67191: PPUSH
67192: CALL_OW 311
67196: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67197: LD_VAR 0 9
67201: PPUSH
67202: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67206: LD_VAR 0 9
67210: PPUSH
67211: LD_VAR 0 5
67215: PPUSH
67216: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67220: LD_VAR 0 9
67224: PPUSH
67225: LD_VAR 0 5
67229: PPUSH
67230: CALL_OW 180
// end ; end ; unit_human :
67234: GO 67501
67236: LD_INT 1
67238: DOUBLE
67239: EQUAL
67240: IFTRUE 67244
67242: GO 67500
67244: POP
// begin b := IsInUnit ( i ) ;
67245: LD_ADDR_VAR 0 18
67249: PUSH
67250: LD_VAR 0 5
67254: PPUSH
67255: CALL_OW 310
67259: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67260: LD_ADDR_VAR 0 19
67264: PUSH
67265: LD_VAR 0 18
67269: NOT
67270: PUSH
67271: LD_VAR 0 18
67275: PPUSH
67276: CALL_OW 266
67280: PUSH
67281: LD_INT 32
67283: PUSH
67284: LD_INT 31
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: IN
67291: OR
67292: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67293: LD_VAR 0 16
67297: PUSH
67298: LD_VAR 0 2
67302: PPUSH
67303: LD_INT 21
67305: PUSH
67306: LD_INT 2
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PPUSH
67313: CALL_OW 72
67317: PUSH
67318: LD_INT 1
67320: LESSEQUAL
67321: OR
67322: PUSH
67323: LD_VAR 0 19
67327: AND
67328: PUSH
67329: LD_VAR 0 5
67333: PUSH
67334: LD_VAR 0 17
67338: IN
67339: NOT
67340: AND
67341: IFFALSE 67434
// begin if b then
67343: LD_VAR 0 18
67347: IFFALSE 67396
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67349: LD_VAR 0 18
67353: PPUSH
67354: LD_VAR 0 3
67358: PPUSH
67359: LD_VAR 0 18
67363: PPUSH
67364: CALL_OW 74
67368: PPUSH
67369: CALL_OW 296
67373: PUSH
67374: LD_INT 10
67376: LESS
67377: PUSH
67378: LD_VAR 0 18
67382: PPUSH
67383: CALL_OW 461
67387: PUSH
67388: LD_INT 7
67390: NONEQUAL
67391: AND
67392: IFFALSE 67396
// continue ;
67394: GO 66799
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67396: LD_ADDR_VAR 0 17
67400: PUSH
67401: LD_VAR 0 17
67405: PPUSH
67406: LD_VAR 0 17
67410: PUSH
67411: LD_INT 1
67413: PLUS
67414: PPUSH
67415: LD_VAR 0 5
67419: PPUSH
67420: CALL_OW 1
67424: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67425: LD_VAR 0 5
67429: PPUSH
67430: CALL_OW 122
// end ; if sold_defenders then
67434: LD_VAR 0 17
67438: IFFALSE 67498
// if i in sold_defenders then
67440: LD_VAR 0 5
67444: PUSH
67445: LD_VAR 0 17
67449: IN
67450: IFFALSE 67498
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67452: LD_VAR 0 5
67456: PPUSH
67457: CALL_OW 314
67461: NOT
67462: PUSH
67463: LD_VAR 0 5
67467: PPUSH
67468: LD_VAR 0 13
67472: PPUSH
67473: CALL_OW 296
67477: PUSH
67478: LD_INT 30
67480: LESS
67481: AND
67482: IFFALSE 67498
// ComAttackUnit ( i , e ) ;
67484: LD_VAR 0 5
67488: PPUSH
67489: LD_VAR 0 13
67493: PPUSH
67494: CALL_OW 115
// end ; end ; end ;
67498: GO 67501
67500: POP
// if IsDead ( i ) then
67501: LD_VAR 0 5
67505: PPUSH
67506: CALL_OW 301
67510: IFFALSE 67528
// defenders := defenders diff i ;
67512: LD_ADDR_VAR 0 2
67516: PUSH
67517: LD_VAR 0 2
67521: PUSH
67522: LD_VAR 0 5
67526: DIFF
67527: ST_TO_ADDR
// end ;
67528: GO 66799
67530: POP
67531: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67532: LD_VAR 0 3
67536: NOT
67537: PUSH
67538: LD_VAR 0 2
67542: NOT
67543: OR
67544: PUSH
67545: LD_EXP 99
67549: PUSH
67550: LD_VAR 0 1
67554: ARRAY
67555: NOT
67556: OR
67557: IFFALSE 66703
// MC_Reset ( base , 18 ) ;
67559: LD_VAR 0 1
67563: PPUSH
67564: LD_INT 18
67566: PPUSH
67567: CALL 37986 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67571: LD_ADDR_VAR 0 2
67575: PUSH
67576: LD_VAR 0 2
67580: PUSH
67581: LD_VAR 0 2
67585: PPUSH
67586: LD_INT 2
67588: PUSH
67589: LD_INT 25
67591: PUSH
67592: LD_INT 1
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: LD_INT 25
67601: PUSH
67602: LD_INT 5
67604: PUSH
67605: EMPTY
67606: LIST
67607: LIST
67608: PUSH
67609: LD_INT 25
67611: PUSH
67612: LD_INT 8
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 25
67621: PUSH
67622: LD_INT 9
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: PPUSH
67636: CALL_OW 72
67640: DIFF
67641: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67642: LD_VAR 0 3
67646: NOT
67647: PUSH
67648: LD_VAR 0 2
67652: PPUSH
67653: LD_INT 21
67655: PUSH
67656: LD_INT 2
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PPUSH
67663: CALL_OW 72
67667: AND
67668: IFFALSE 68006
// begin tmp := FilterByTag ( defenders , 19 ) ;
67670: LD_ADDR_VAR 0 11
67674: PUSH
67675: LD_VAR 0 2
67679: PPUSH
67680: LD_INT 19
67682: PPUSH
67683: CALL 104459 0 2
67687: ST_TO_ADDR
// if tmp then
67688: LD_VAR 0 11
67692: IFFALSE 67762
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
67694: LD_ADDR_VAR 0 11
67698: PUSH
67699: LD_VAR 0 11
67703: PPUSH
67704: LD_INT 25
67706: PUSH
67707: LD_INT 3
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PPUSH
67714: CALL_OW 72
67718: ST_TO_ADDR
// if tmp then
67719: LD_VAR 0 11
67723: IFFALSE 67762
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
67725: LD_ADDR_EXP 111
67729: PUSH
67730: LD_EXP 111
67734: PPUSH
67735: LD_VAR 0 1
67739: PPUSH
67740: LD_EXP 111
67744: PUSH
67745: LD_VAR 0 1
67749: ARRAY
67750: PUSH
67751: LD_VAR 0 11
67755: UNION
67756: PPUSH
67757: CALL_OW 1
67761: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
67762: LD_VAR 0 1
67766: PPUSH
67767: LD_INT 19
67769: PPUSH
67770: CALL 37986 0 2
// repeat wait ( 0 0$1 ) ;
67774: LD_INT 35
67776: PPUSH
67777: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67781: LD_EXP 99
67785: PUSH
67786: LD_VAR 0 1
67790: ARRAY
67791: NOT
67792: PUSH
67793: LD_EXP 99
67797: PUSH
67798: LD_VAR 0 1
67802: ARRAY
67803: PUSH
67804: EMPTY
67805: EQUAL
67806: OR
67807: IFFALSE 67844
// begin for i in defenders do
67809: LD_ADDR_VAR 0 5
67813: PUSH
67814: LD_VAR 0 2
67818: PUSH
67819: FOR_IN
67820: IFFALSE 67833
// ComStop ( i ) ;
67822: LD_VAR 0 5
67826: PPUSH
67827: CALL_OW 141
67831: GO 67819
67833: POP
67834: POP
// defenders := [ ] ;
67835: LD_ADDR_VAR 0 2
67839: PUSH
67840: EMPTY
67841: ST_TO_ADDR
// exit ;
67842: GO 68030
// end ; for i in defenders do
67844: LD_ADDR_VAR 0 5
67848: PUSH
67849: LD_VAR 0 2
67853: PUSH
67854: FOR_IN
67855: IFFALSE 67944
// begin if not IsInArea ( i , mc_parking [ base ] ) then
67857: LD_VAR 0 5
67861: PPUSH
67862: LD_EXP 123
67866: PUSH
67867: LD_VAR 0 1
67871: ARRAY
67872: PPUSH
67873: CALL_OW 308
67877: NOT
67878: IFFALSE 67902
// ComMoveToArea ( i , mc_parking [ base ] ) else
67880: LD_VAR 0 5
67884: PPUSH
67885: LD_EXP 123
67889: PUSH
67890: LD_VAR 0 1
67894: ARRAY
67895: PPUSH
67896: CALL_OW 113
67900: GO 67942
// if GetControl ( i ) = control_manual then
67902: LD_VAR 0 5
67906: PPUSH
67907: CALL_OW 263
67911: PUSH
67912: LD_INT 1
67914: EQUAL
67915: IFFALSE 67942
// if IsDrivenBy ( i ) then
67917: LD_VAR 0 5
67921: PPUSH
67922: CALL_OW 311
67926: IFFALSE 67942
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
67928: LD_VAR 0 5
67932: PPUSH
67933: CALL_OW 311
67937: PPUSH
67938: CALL_OW 121
// end ;
67942: GO 67854
67944: POP
67945: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
67946: LD_VAR 0 2
67950: PPUSH
67951: LD_INT 95
67953: PUSH
67954: LD_EXP 123
67958: PUSH
67959: LD_VAR 0 1
67963: ARRAY
67964: PUSH
67965: EMPTY
67966: LIST
67967: LIST
67968: PPUSH
67969: CALL_OW 72
67973: PUSH
67974: LD_VAR 0 2
67978: EQUAL
67979: PUSH
67980: LD_EXP 122
67984: PUSH
67985: LD_VAR 0 1
67989: ARRAY
67990: OR
67991: PUSH
67992: LD_EXP 99
67996: PUSH
67997: LD_VAR 0 1
68001: ARRAY
68002: NOT
68003: OR
68004: IFFALSE 67774
// end ; MC_Reset ( base , 19 ) ;
68006: LD_VAR 0 1
68010: PPUSH
68011: LD_INT 19
68013: PPUSH
68014: CALL 37986 0 2
// MC_Reset ( base , 20 ) ;
68018: LD_VAR 0 1
68022: PPUSH
68023: LD_INT 20
68025: PPUSH
68026: CALL 37986 0 2
// end ;
68030: LD_VAR 0 4
68034: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68035: LD_INT 0
68037: PPUSH
68038: PPUSH
68039: PPUSH
68040: PPUSH
// result := false ;
68041: LD_ADDR_VAR 0 2
68045: PUSH
68046: LD_INT 0
68048: ST_TO_ADDR
// side := GetSide ( unit ) ;
68049: LD_ADDR_VAR 0 3
68053: PUSH
68054: LD_VAR 0 1
68058: PPUSH
68059: CALL_OW 255
68063: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68064: LD_ADDR_VAR 0 4
68068: PUSH
68069: LD_VAR 0 1
68073: PPUSH
68074: CALL_OW 248
68078: ST_TO_ADDR
// case nat of 1 :
68079: LD_VAR 0 4
68083: PUSH
68084: LD_INT 1
68086: DOUBLE
68087: EQUAL
68088: IFTRUE 68092
68090: GO 68103
68092: POP
// tech := tech_lassight ; 2 :
68093: LD_ADDR_VAR 0 5
68097: PUSH
68098: LD_INT 12
68100: ST_TO_ADDR
68101: GO 68142
68103: LD_INT 2
68105: DOUBLE
68106: EQUAL
68107: IFTRUE 68111
68109: GO 68122
68111: POP
// tech := tech_mortar ; 3 :
68112: LD_ADDR_VAR 0 5
68116: PUSH
68117: LD_INT 41
68119: ST_TO_ADDR
68120: GO 68142
68122: LD_INT 3
68124: DOUBLE
68125: EQUAL
68126: IFTRUE 68130
68128: GO 68141
68130: POP
// tech := tech_bazooka ; end ;
68131: LD_ADDR_VAR 0 5
68135: PUSH
68136: LD_INT 44
68138: ST_TO_ADDR
68139: GO 68142
68141: POP
// if Researched ( side , tech ) then
68142: LD_VAR 0 3
68146: PPUSH
68147: LD_VAR 0 5
68151: PPUSH
68152: CALL_OW 325
68156: IFFALSE 68183
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68158: LD_ADDR_VAR 0 2
68162: PUSH
68163: LD_INT 5
68165: PUSH
68166: LD_INT 8
68168: PUSH
68169: LD_INT 9
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: LIST
68176: PUSH
68177: LD_VAR 0 4
68181: ARRAY
68182: ST_TO_ADDR
// end ;
68183: LD_VAR 0 2
68187: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68188: LD_INT 0
68190: PPUSH
68191: PPUSH
68192: PPUSH
// if not mines then
68193: LD_VAR 0 2
68197: NOT
68198: IFFALSE 68202
// exit ;
68200: GO 68346
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68202: LD_ADDR_VAR 0 5
68206: PUSH
68207: LD_INT 81
68209: PUSH
68210: LD_VAR 0 1
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PUSH
68219: LD_INT 3
68221: PUSH
68222: LD_INT 21
68224: PUSH
68225: LD_INT 3
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: EMPTY
68233: LIST
68234: LIST
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PPUSH
68240: CALL_OW 69
68244: ST_TO_ADDR
// for i in mines do
68245: LD_ADDR_VAR 0 4
68249: PUSH
68250: LD_VAR 0 2
68254: PUSH
68255: FOR_IN
68256: IFFALSE 68344
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68258: LD_VAR 0 4
68262: PUSH
68263: LD_INT 1
68265: ARRAY
68266: PPUSH
68267: LD_VAR 0 4
68271: PUSH
68272: LD_INT 2
68274: ARRAY
68275: PPUSH
68276: CALL_OW 458
68280: NOT
68281: IFFALSE 68285
// continue ;
68283: GO 68255
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68285: LD_VAR 0 4
68289: PUSH
68290: LD_INT 1
68292: ARRAY
68293: PPUSH
68294: LD_VAR 0 4
68298: PUSH
68299: LD_INT 2
68301: ARRAY
68302: PPUSH
68303: CALL_OW 428
68307: PUSH
68308: LD_VAR 0 5
68312: IN
68313: IFFALSE 68342
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68315: LD_VAR 0 4
68319: PUSH
68320: LD_INT 1
68322: ARRAY
68323: PPUSH
68324: LD_VAR 0 4
68328: PUSH
68329: LD_INT 2
68331: ARRAY
68332: PPUSH
68333: LD_VAR 0 1
68337: PPUSH
68338: CALL_OW 456
// end ;
68342: GO 68255
68344: POP
68345: POP
// end ;
68346: LD_VAR 0 3
68350: RET
// export function Count ( array ) ; var i ; begin
68351: LD_INT 0
68353: PPUSH
68354: PPUSH
// result := 0 ;
68355: LD_ADDR_VAR 0 2
68359: PUSH
68360: LD_INT 0
68362: ST_TO_ADDR
// for i in array do
68363: LD_ADDR_VAR 0 3
68367: PUSH
68368: LD_VAR 0 1
68372: PUSH
68373: FOR_IN
68374: IFFALSE 68398
// if i then
68376: LD_VAR 0 3
68380: IFFALSE 68396
// result := result + 1 ;
68382: LD_ADDR_VAR 0 2
68386: PUSH
68387: LD_VAR 0 2
68391: PUSH
68392: LD_INT 1
68394: PLUS
68395: ST_TO_ADDR
68396: GO 68373
68398: POP
68399: POP
// end ;
68400: LD_VAR 0 2
68404: RET
// export function IsEmpty ( building ) ; begin
68405: LD_INT 0
68407: PPUSH
// if not building then
68408: LD_VAR 0 1
68412: NOT
68413: IFFALSE 68417
// exit ;
68415: GO 68460
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68417: LD_ADDR_VAR 0 2
68421: PUSH
68422: LD_VAR 0 1
68426: PUSH
68427: LD_INT 22
68429: PUSH
68430: LD_VAR 0 1
68434: PPUSH
68435: CALL_OW 255
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: LD_INT 58
68446: PUSH
68447: EMPTY
68448: LIST
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PPUSH
68454: CALL_OW 69
68458: IN
68459: ST_TO_ADDR
// end ;
68460: LD_VAR 0 2
68464: RET
// export function IsNotFull ( building ) ; begin
68465: LD_INT 0
68467: PPUSH
// if not building then
68468: LD_VAR 0 1
68472: NOT
68473: IFFALSE 68477
// exit ;
68475: GO 68496
// result := UnitsInside ( building ) < 6 ;
68477: LD_ADDR_VAR 0 2
68481: PUSH
68482: LD_VAR 0 1
68486: PPUSH
68487: CALL_OW 313
68491: PUSH
68492: LD_INT 6
68494: LESS
68495: ST_TO_ADDR
// end ;
68496: LD_VAR 0 2
68500: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68501: LD_INT 0
68503: PPUSH
68504: PPUSH
68505: PPUSH
68506: PPUSH
// tmp := [ ] ;
68507: LD_ADDR_VAR 0 3
68511: PUSH
68512: EMPTY
68513: ST_TO_ADDR
// list := [ ] ;
68514: LD_ADDR_VAR 0 5
68518: PUSH
68519: EMPTY
68520: ST_TO_ADDR
// for i = 16 to 25 do
68521: LD_ADDR_VAR 0 4
68525: PUSH
68526: DOUBLE
68527: LD_INT 16
68529: DEC
68530: ST_TO_ADDR
68531: LD_INT 25
68533: PUSH
68534: FOR_TO
68535: IFFALSE 68608
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68537: LD_ADDR_VAR 0 3
68541: PUSH
68542: LD_VAR 0 3
68546: PUSH
68547: LD_INT 22
68549: PUSH
68550: LD_VAR 0 1
68554: PPUSH
68555: CALL_OW 255
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 91
68566: PUSH
68567: LD_VAR 0 1
68571: PUSH
68572: LD_INT 6
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: LIST
68579: PUSH
68580: LD_INT 30
68582: PUSH
68583: LD_VAR 0 4
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: LIST
68596: PUSH
68597: EMPTY
68598: LIST
68599: PPUSH
68600: CALL_OW 69
68604: ADD
68605: ST_TO_ADDR
68606: GO 68534
68608: POP
68609: POP
// for i = 1 to tmp do
68610: LD_ADDR_VAR 0 4
68614: PUSH
68615: DOUBLE
68616: LD_INT 1
68618: DEC
68619: ST_TO_ADDR
68620: LD_VAR 0 3
68624: PUSH
68625: FOR_TO
68626: IFFALSE 68714
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68628: LD_ADDR_VAR 0 5
68632: PUSH
68633: LD_VAR 0 5
68637: PUSH
68638: LD_VAR 0 3
68642: PUSH
68643: LD_VAR 0 4
68647: ARRAY
68648: PPUSH
68649: CALL_OW 266
68653: PUSH
68654: LD_VAR 0 3
68658: PUSH
68659: LD_VAR 0 4
68663: ARRAY
68664: PPUSH
68665: CALL_OW 250
68669: PUSH
68670: LD_VAR 0 3
68674: PUSH
68675: LD_VAR 0 4
68679: ARRAY
68680: PPUSH
68681: CALL_OW 251
68685: PUSH
68686: LD_VAR 0 3
68690: PUSH
68691: LD_VAR 0 4
68695: ARRAY
68696: PPUSH
68697: CALL_OW 254
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: PUSH
68708: EMPTY
68709: LIST
68710: ADD
68711: ST_TO_ADDR
68712: GO 68625
68714: POP
68715: POP
// result := list ;
68716: LD_ADDR_VAR 0 2
68720: PUSH
68721: LD_VAR 0 5
68725: ST_TO_ADDR
// end ;
68726: LD_VAR 0 2
68730: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68731: LD_INT 0
68733: PPUSH
68734: PPUSH
68735: PPUSH
68736: PPUSH
68737: PPUSH
68738: PPUSH
68739: PPUSH
// if not factory then
68740: LD_VAR 0 1
68744: NOT
68745: IFFALSE 68749
// exit ;
68747: GO 69342
// if control = control_apeman then
68749: LD_VAR 0 4
68753: PUSH
68754: LD_INT 5
68756: EQUAL
68757: IFFALSE 68866
// begin tmp := UnitsInside ( factory ) ;
68759: LD_ADDR_VAR 0 8
68763: PUSH
68764: LD_VAR 0 1
68768: PPUSH
68769: CALL_OW 313
68773: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68774: LD_VAR 0 8
68778: PPUSH
68779: LD_INT 25
68781: PUSH
68782: LD_INT 12
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PPUSH
68789: CALL_OW 72
68793: NOT
68794: IFFALSE 68804
// control := control_manual ;
68796: LD_ADDR_VAR 0 4
68800: PUSH
68801: LD_INT 1
68803: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68804: LD_ADDR_VAR 0 8
68808: PUSH
68809: LD_VAR 0 1
68813: PPUSH
68814: CALL 68501 0 1
68818: ST_TO_ADDR
// if tmp then
68819: LD_VAR 0 8
68823: IFFALSE 68866
// begin for i in tmp do
68825: LD_ADDR_VAR 0 7
68829: PUSH
68830: LD_VAR 0 8
68834: PUSH
68835: FOR_IN
68836: IFFALSE 68864
// if i [ 1 ] = b_ext_radio then
68838: LD_VAR 0 7
68842: PUSH
68843: LD_INT 1
68845: ARRAY
68846: PUSH
68847: LD_INT 22
68849: EQUAL
68850: IFFALSE 68862
// begin control := control_remote ;
68852: LD_ADDR_VAR 0 4
68856: PUSH
68857: LD_INT 2
68859: ST_TO_ADDR
// break ;
68860: GO 68864
// end ;
68862: GO 68835
68864: POP
68865: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68866: LD_VAR 0 1
68870: PPUSH
68871: LD_VAR 0 2
68875: PPUSH
68876: LD_VAR 0 3
68880: PPUSH
68881: LD_VAR 0 4
68885: PPUSH
68886: LD_VAR 0 5
68890: PPUSH
68891: CALL_OW 448
68895: IFFALSE 68930
// begin result := [ chassis , engine , control , weapon ] ;
68897: LD_ADDR_VAR 0 6
68901: PUSH
68902: LD_VAR 0 2
68906: PUSH
68907: LD_VAR 0 3
68911: PUSH
68912: LD_VAR 0 4
68916: PUSH
68917: LD_VAR 0 5
68921: PUSH
68922: EMPTY
68923: LIST
68924: LIST
68925: LIST
68926: LIST
68927: ST_TO_ADDR
// exit ;
68928: GO 69342
// end ; _chassis := AvailableChassisList ( factory ) ;
68930: LD_ADDR_VAR 0 9
68934: PUSH
68935: LD_VAR 0 1
68939: PPUSH
68940: CALL_OW 475
68944: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68945: LD_ADDR_VAR 0 11
68949: PUSH
68950: LD_VAR 0 1
68954: PPUSH
68955: CALL_OW 476
68959: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68960: LD_ADDR_VAR 0 12
68964: PUSH
68965: LD_VAR 0 1
68969: PPUSH
68970: CALL_OW 477
68974: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68975: LD_ADDR_VAR 0 10
68979: PUSH
68980: LD_VAR 0 1
68984: PPUSH
68985: CALL_OW 478
68989: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68990: LD_VAR 0 9
68994: NOT
68995: PUSH
68996: LD_VAR 0 11
69000: NOT
69001: OR
69002: PUSH
69003: LD_VAR 0 12
69007: NOT
69008: OR
69009: PUSH
69010: LD_VAR 0 10
69014: NOT
69015: OR
69016: IFFALSE 69051
// begin result := [ chassis , engine , control , weapon ] ;
69018: LD_ADDR_VAR 0 6
69022: PUSH
69023: LD_VAR 0 2
69027: PUSH
69028: LD_VAR 0 3
69032: PUSH
69033: LD_VAR 0 4
69037: PUSH
69038: LD_VAR 0 5
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: ST_TO_ADDR
// exit ;
69049: GO 69342
// end ; if not chassis in _chassis then
69051: LD_VAR 0 2
69055: PUSH
69056: LD_VAR 0 9
69060: IN
69061: NOT
69062: IFFALSE 69088
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69064: LD_ADDR_VAR 0 2
69068: PUSH
69069: LD_VAR 0 9
69073: PUSH
69074: LD_INT 1
69076: PPUSH
69077: LD_VAR 0 9
69081: PPUSH
69082: CALL_OW 12
69086: ARRAY
69087: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69088: LD_VAR 0 2
69092: PPUSH
69093: LD_VAR 0 3
69097: PPUSH
69098: CALL 69347 0 2
69102: NOT
69103: IFFALSE 69162
// repeat engine := _engine [ 1 ] ;
69105: LD_ADDR_VAR 0 3
69109: PUSH
69110: LD_VAR 0 11
69114: PUSH
69115: LD_INT 1
69117: ARRAY
69118: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69119: LD_ADDR_VAR 0 11
69123: PUSH
69124: LD_VAR 0 11
69128: PPUSH
69129: LD_INT 1
69131: PPUSH
69132: CALL_OW 3
69136: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69137: LD_VAR 0 2
69141: PPUSH
69142: LD_VAR 0 3
69146: PPUSH
69147: CALL 69347 0 2
69151: PUSH
69152: LD_VAR 0 11
69156: PUSH
69157: EMPTY
69158: EQUAL
69159: OR
69160: IFFALSE 69105
// if not control in _control then
69162: LD_VAR 0 4
69166: PUSH
69167: LD_VAR 0 12
69171: IN
69172: NOT
69173: IFFALSE 69199
// control := _control [ rand ( 1 , _control ) ] ;
69175: LD_ADDR_VAR 0 4
69179: PUSH
69180: LD_VAR 0 12
69184: PUSH
69185: LD_INT 1
69187: PPUSH
69188: LD_VAR 0 12
69192: PPUSH
69193: CALL_OW 12
69197: ARRAY
69198: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69199: LD_VAR 0 2
69203: PPUSH
69204: LD_VAR 0 5
69208: PPUSH
69209: CALL 69567 0 2
69213: NOT
69214: IFFALSE 69273
// repeat weapon := _weapon [ 1 ] ;
69216: LD_ADDR_VAR 0 5
69220: PUSH
69221: LD_VAR 0 10
69225: PUSH
69226: LD_INT 1
69228: ARRAY
69229: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69230: LD_ADDR_VAR 0 10
69234: PUSH
69235: LD_VAR 0 10
69239: PPUSH
69240: LD_INT 1
69242: PPUSH
69243: CALL_OW 3
69247: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69248: LD_VAR 0 2
69252: PPUSH
69253: LD_VAR 0 5
69257: PPUSH
69258: CALL 69567 0 2
69262: PUSH
69263: LD_VAR 0 10
69267: PUSH
69268: EMPTY
69269: EQUAL
69270: OR
69271: IFFALSE 69216
// result := [ ] ;
69273: LD_ADDR_VAR 0 6
69277: PUSH
69278: EMPTY
69279: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69280: LD_VAR 0 1
69284: PPUSH
69285: LD_VAR 0 2
69289: PPUSH
69290: LD_VAR 0 3
69294: PPUSH
69295: LD_VAR 0 4
69299: PPUSH
69300: LD_VAR 0 5
69304: PPUSH
69305: CALL_OW 448
69309: IFFALSE 69342
// result := [ chassis , engine , control , weapon ] ;
69311: LD_ADDR_VAR 0 6
69315: PUSH
69316: LD_VAR 0 2
69320: PUSH
69321: LD_VAR 0 3
69325: PUSH
69326: LD_VAR 0 4
69330: PUSH
69331: LD_VAR 0 5
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: ST_TO_ADDR
// end ;
69342: LD_VAR 0 6
69346: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69347: LD_INT 0
69349: PPUSH
// if not chassis or not engine then
69350: LD_VAR 0 1
69354: NOT
69355: PUSH
69356: LD_VAR 0 2
69360: NOT
69361: OR
69362: IFFALSE 69366
// exit ;
69364: GO 69562
// case engine of engine_solar :
69366: LD_VAR 0 2
69370: PUSH
69371: LD_INT 2
69373: DOUBLE
69374: EQUAL
69375: IFTRUE 69379
69377: GO 69417
69379: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69380: LD_ADDR_VAR 0 3
69384: PUSH
69385: LD_INT 11
69387: PUSH
69388: LD_INT 12
69390: PUSH
69391: LD_INT 13
69393: PUSH
69394: LD_INT 14
69396: PUSH
69397: LD_INT 1
69399: PUSH
69400: LD_INT 2
69402: PUSH
69403: LD_INT 3
69405: PUSH
69406: EMPTY
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: ST_TO_ADDR
69415: GO 69546
69417: LD_INT 1
69419: DOUBLE
69420: EQUAL
69421: IFTRUE 69425
69423: GO 69487
69425: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69426: LD_ADDR_VAR 0 3
69430: PUSH
69431: LD_INT 11
69433: PUSH
69434: LD_INT 12
69436: PUSH
69437: LD_INT 13
69439: PUSH
69440: LD_INT 14
69442: PUSH
69443: LD_INT 1
69445: PUSH
69446: LD_INT 2
69448: PUSH
69449: LD_INT 3
69451: PUSH
69452: LD_INT 4
69454: PUSH
69455: LD_INT 5
69457: PUSH
69458: LD_INT 21
69460: PUSH
69461: LD_INT 23
69463: PUSH
69464: LD_INT 22
69466: PUSH
69467: LD_INT 24
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: LIST
69478: LIST
69479: LIST
69480: LIST
69481: LIST
69482: LIST
69483: LIST
69484: ST_TO_ADDR
69485: GO 69546
69487: LD_INT 3
69489: DOUBLE
69490: EQUAL
69491: IFTRUE 69495
69493: GO 69545
69495: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69496: LD_ADDR_VAR 0 3
69500: PUSH
69501: LD_INT 13
69503: PUSH
69504: LD_INT 14
69506: PUSH
69507: LD_INT 2
69509: PUSH
69510: LD_INT 3
69512: PUSH
69513: LD_INT 4
69515: PUSH
69516: LD_INT 5
69518: PUSH
69519: LD_INT 21
69521: PUSH
69522: LD_INT 22
69524: PUSH
69525: LD_INT 23
69527: PUSH
69528: LD_INT 24
69530: PUSH
69531: EMPTY
69532: LIST
69533: LIST
69534: LIST
69535: LIST
69536: LIST
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: ST_TO_ADDR
69543: GO 69546
69545: POP
// result := ( chassis in result ) ;
69546: LD_ADDR_VAR 0 3
69550: PUSH
69551: LD_VAR 0 1
69555: PUSH
69556: LD_VAR 0 3
69560: IN
69561: ST_TO_ADDR
// end ;
69562: LD_VAR 0 3
69566: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69567: LD_INT 0
69569: PPUSH
// if not chassis or not weapon then
69570: LD_VAR 0 1
69574: NOT
69575: PUSH
69576: LD_VAR 0 2
69580: NOT
69581: OR
69582: IFFALSE 69586
// exit ;
69584: GO 70612
// case weapon of us_machine_gun :
69586: LD_VAR 0 2
69590: PUSH
69591: LD_INT 2
69593: DOUBLE
69594: EQUAL
69595: IFTRUE 69599
69597: GO 69629
69599: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69600: LD_ADDR_VAR 0 3
69604: PUSH
69605: LD_INT 1
69607: PUSH
69608: LD_INT 2
69610: PUSH
69611: LD_INT 3
69613: PUSH
69614: LD_INT 4
69616: PUSH
69617: LD_INT 5
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: ST_TO_ADDR
69627: GO 70596
69629: LD_INT 3
69631: DOUBLE
69632: EQUAL
69633: IFTRUE 69637
69635: GO 69667
69637: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69638: LD_ADDR_VAR 0 3
69642: PUSH
69643: LD_INT 1
69645: PUSH
69646: LD_INT 2
69648: PUSH
69649: LD_INT 3
69651: PUSH
69652: LD_INT 4
69654: PUSH
69655: LD_INT 5
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: LIST
69662: LIST
69663: LIST
69664: ST_TO_ADDR
69665: GO 70596
69667: LD_INT 11
69669: DOUBLE
69670: EQUAL
69671: IFTRUE 69675
69673: GO 69705
69675: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69676: LD_ADDR_VAR 0 3
69680: PUSH
69681: LD_INT 1
69683: PUSH
69684: LD_INT 2
69686: PUSH
69687: LD_INT 3
69689: PUSH
69690: LD_INT 4
69692: PUSH
69693: LD_INT 5
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: ST_TO_ADDR
69703: GO 70596
69705: LD_INT 4
69707: DOUBLE
69708: EQUAL
69709: IFTRUE 69713
69711: GO 69739
69713: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69714: LD_ADDR_VAR 0 3
69718: PUSH
69719: LD_INT 2
69721: PUSH
69722: LD_INT 3
69724: PUSH
69725: LD_INT 4
69727: PUSH
69728: LD_INT 5
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: ST_TO_ADDR
69737: GO 70596
69739: LD_INT 5
69741: DOUBLE
69742: EQUAL
69743: IFTRUE 69747
69745: GO 69773
69747: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69748: LD_ADDR_VAR 0 3
69752: PUSH
69753: LD_INT 2
69755: PUSH
69756: LD_INT 3
69758: PUSH
69759: LD_INT 4
69761: PUSH
69762: LD_INT 5
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: LIST
69769: LIST
69770: ST_TO_ADDR
69771: GO 70596
69773: LD_INT 9
69775: DOUBLE
69776: EQUAL
69777: IFTRUE 69781
69779: GO 69807
69781: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69782: LD_ADDR_VAR 0 3
69786: PUSH
69787: LD_INT 2
69789: PUSH
69790: LD_INT 3
69792: PUSH
69793: LD_INT 4
69795: PUSH
69796: LD_INT 5
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: LIST
69803: LIST
69804: ST_TO_ADDR
69805: GO 70596
69807: LD_INT 7
69809: DOUBLE
69810: EQUAL
69811: IFTRUE 69815
69813: GO 69841
69815: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69816: LD_ADDR_VAR 0 3
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: LD_INT 3
69826: PUSH
69827: LD_INT 4
69829: PUSH
69830: LD_INT 5
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: LIST
69837: LIST
69838: ST_TO_ADDR
69839: GO 70596
69841: LD_INT 12
69843: DOUBLE
69844: EQUAL
69845: IFTRUE 69849
69847: GO 69875
69849: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69850: LD_ADDR_VAR 0 3
69854: PUSH
69855: LD_INT 2
69857: PUSH
69858: LD_INT 3
69860: PUSH
69861: LD_INT 4
69863: PUSH
69864: LD_INT 5
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: ST_TO_ADDR
69873: GO 70596
69875: LD_INT 13
69877: DOUBLE
69878: EQUAL
69879: IFTRUE 69883
69881: GO 69909
69883: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69884: LD_ADDR_VAR 0 3
69888: PUSH
69889: LD_INT 2
69891: PUSH
69892: LD_INT 3
69894: PUSH
69895: LD_INT 4
69897: PUSH
69898: LD_INT 5
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: LIST
69905: LIST
69906: ST_TO_ADDR
69907: GO 70596
69909: LD_INT 14
69911: DOUBLE
69912: EQUAL
69913: IFTRUE 69917
69915: GO 69935
69917: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69918: LD_ADDR_VAR 0 3
69922: PUSH
69923: LD_INT 4
69925: PUSH
69926: LD_INT 5
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: ST_TO_ADDR
69933: GO 70596
69935: LD_INT 6
69937: DOUBLE
69938: EQUAL
69939: IFTRUE 69943
69941: GO 69961
69943: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69944: LD_ADDR_VAR 0 3
69948: PUSH
69949: LD_INT 4
69951: PUSH
69952: LD_INT 5
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: ST_TO_ADDR
69959: GO 70596
69961: LD_INT 10
69963: DOUBLE
69964: EQUAL
69965: IFTRUE 69969
69967: GO 69987
69969: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69970: LD_ADDR_VAR 0 3
69974: PUSH
69975: LD_INT 4
69977: PUSH
69978: LD_INT 5
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: ST_TO_ADDR
69985: GO 70596
69987: LD_INT 22
69989: DOUBLE
69990: EQUAL
69991: IFTRUE 69995
69993: GO 70021
69995: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69996: LD_ADDR_VAR 0 3
70000: PUSH
70001: LD_INT 11
70003: PUSH
70004: LD_INT 12
70006: PUSH
70007: LD_INT 13
70009: PUSH
70010: LD_INT 14
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: ST_TO_ADDR
70019: GO 70596
70021: LD_INT 23
70023: DOUBLE
70024: EQUAL
70025: IFTRUE 70029
70027: GO 70055
70029: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70030: LD_ADDR_VAR 0 3
70034: PUSH
70035: LD_INT 11
70037: PUSH
70038: LD_INT 12
70040: PUSH
70041: LD_INT 13
70043: PUSH
70044: LD_INT 14
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: ST_TO_ADDR
70053: GO 70596
70055: LD_INT 24
70057: DOUBLE
70058: EQUAL
70059: IFTRUE 70063
70061: GO 70089
70063: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70064: LD_ADDR_VAR 0 3
70068: PUSH
70069: LD_INT 11
70071: PUSH
70072: LD_INT 12
70074: PUSH
70075: LD_INT 13
70077: PUSH
70078: LD_INT 14
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: ST_TO_ADDR
70087: GO 70596
70089: LD_INT 30
70091: DOUBLE
70092: EQUAL
70093: IFTRUE 70097
70095: GO 70123
70097: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70098: LD_ADDR_VAR 0 3
70102: PUSH
70103: LD_INT 11
70105: PUSH
70106: LD_INT 12
70108: PUSH
70109: LD_INT 13
70111: PUSH
70112: LD_INT 14
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: LIST
70119: LIST
70120: ST_TO_ADDR
70121: GO 70596
70123: LD_INT 25
70125: DOUBLE
70126: EQUAL
70127: IFTRUE 70131
70129: GO 70149
70131: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70132: LD_ADDR_VAR 0 3
70136: PUSH
70137: LD_INT 13
70139: PUSH
70140: LD_INT 14
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: ST_TO_ADDR
70147: GO 70596
70149: LD_INT 27
70151: DOUBLE
70152: EQUAL
70153: IFTRUE 70157
70155: GO 70175
70157: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70158: LD_ADDR_VAR 0 3
70162: PUSH
70163: LD_INT 13
70165: PUSH
70166: LD_INT 14
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: ST_TO_ADDR
70173: GO 70596
70175: LD_INT 28
70177: DOUBLE
70178: EQUAL
70179: IFTRUE 70183
70181: GO 70201
70183: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70184: LD_ADDR_VAR 0 3
70188: PUSH
70189: LD_INT 13
70191: PUSH
70192: LD_INT 14
70194: PUSH
70195: EMPTY
70196: LIST
70197: LIST
70198: ST_TO_ADDR
70199: GO 70596
70201: LD_INT 29
70203: DOUBLE
70204: EQUAL
70205: IFTRUE 70209
70207: GO 70227
70209: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70210: LD_ADDR_VAR 0 3
70214: PUSH
70215: LD_INT 13
70217: PUSH
70218: LD_INT 14
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: ST_TO_ADDR
70225: GO 70596
70227: LD_INT 31
70229: DOUBLE
70230: EQUAL
70231: IFTRUE 70235
70233: GO 70253
70235: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70236: LD_ADDR_VAR 0 3
70240: PUSH
70241: LD_INT 13
70243: PUSH
70244: LD_INT 14
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: ST_TO_ADDR
70251: GO 70596
70253: LD_INT 26
70255: DOUBLE
70256: EQUAL
70257: IFTRUE 70261
70259: GO 70279
70261: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70262: LD_ADDR_VAR 0 3
70266: PUSH
70267: LD_INT 13
70269: PUSH
70270: LD_INT 14
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: ST_TO_ADDR
70277: GO 70596
70279: LD_INT 42
70281: DOUBLE
70282: EQUAL
70283: IFTRUE 70287
70285: GO 70313
70287: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70288: LD_ADDR_VAR 0 3
70292: PUSH
70293: LD_INT 21
70295: PUSH
70296: LD_INT 22
70298: PUSH
70299: LD_INT 23
70301: PUSH
70302: LD_INT 24
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: ST_TO_ADDR
70311: GO 70596
70313: LD_INT 43
70315: DOUBLE
70316: EQUAL
70317: IFTRUE 70321
70319: GO 70347
70321: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70322: LD_ADDR_VAR 0 3
70326: PUSH
70327: LD_INT 21
70329: PUSH
70330: LD_INT 22
70332: PUSH
70333: LD_INT 23
70335: PUSH
70336: LD_INT 24
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: LIST
70343: LIST
70344: ST_TO_ADDR
70345: GO 70596
70347: LD_INT 44
70349: DOUBLE
70350: EQUAL
70351: IFTRUE 70355
70353: GO 70381
70355: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70356: LD_ADDR_VAR 0 3
70360: PUSH
70361: LD_INT 21
70363: PUSH
70364: LD_INT 22
70366: PUSH
70367: LD_INT 23
70369: PUSH
70370: LD_INT 24
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: LIST
70377: LIST
70378: ST_TO_ADDR
70379: GO 70596
70381: LD_INT 45
70383: DOUBLE
70384: EQUAL
70385: IFTRUE 70389
70387: GO 70415
70389: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70390: LD_ADDR_VAR 0 3
70394: PUSH
70395: LD_INT 21
70397: PUSH
70398: LD_INT 22
70400: PUSH
70401: LD_INT 23
70403: PUSH
70404: LD_INT 24
70406: PUSH
70407: EMPTY
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: ST_TO_ADDR
70413: GO 70596
70415: LD_INT 49
70417: DOUBLE
70418: EQUAL
70419: IFTRUE 70423
70421: GO 70449
70423: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70424: LD_ADDR_VAR 0 3
70428: PUSH
70429: LD_INT 21
70431: PUSH
70432: LD_INT 22
70434: PUSH
70435: LD_INT 23
70437: PUSH
70438: LD_INT 24
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: ST_TO_ADDR
70447: GO 70596
70449: LD_INT 51
70451: DOUBLE
70452: EQUAL
70453: IFTRUE 70457
70455: GO 70483
70457: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70458: LD_ADDR_VAR 0 3
70462: PUSH
70463: LD_INT 21
70465: PUSH
70466: LD_INT 22
70468: PUSH
70469: LD_INT 23
70471: PUSH
70472: LD_INT 24
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: ST_TO_ADDR
70481: GO 70596
70483: LD_INT 52
70485: DOUBLE
70486: EQUAL
70487: IFTRUE 70491
70489: GO 70517
70491: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70492: LD_ADDR_VAR 0 3
70496: PUSH
70497: LD_INT 21
70499: PUSH
70500: LD_INT 22
70502: PUSH
70503: LD_INT 23
70505: PUSH
70506: LD_INT 24
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: LIST
70513: LIST
70514: ST_TO_ADDR
70515: GO 70596
70517: LD_INT 53
70519: DOUBLE
70520: EQUAL
70521: IFTRUE 70525
70523: GO 70543
70525: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70526: LD_ADDR_VAR 0 3
70530: PUSH
70531: LD_INT 23
70533: PUSH
70534: LD_INT 24
70536: PUSH
70537: EMPTY
70538: LIST
70539: LIST
70540: ST_TO_ADDR
70541: GO 70596
70543: LD_INT 46
70545: DOUBLE
70546: EQUAL
70547: IFTRUE 70551
70549: GO 70569
70551: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70552: LD_ADDR_VAR 0 3
70556: PUSH
70557: LD_INT 23
70559: PUSH
70560: LD_INT 24
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: ST_TO_ADDR
70567: GO 70596
70569: LD_INT 47
70571: DOUBLE
70572: EQUAL
70573: IFTRUE 70577
70575: GO 70595
70577: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70578: LD_ADDR_VAR 0 3
70582: PUSH
70583: LD_INT 23
70585: PUSH
70586: LD_INT 24
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: ST_TO_ADDR
70593: GO 70596
70595: POP
// result := ( chassis in result ) ;
70596: LD_ADDR_VAR 0 3
70600: PUSH
70601: LD_VAR 0 1
70605: PUSH
70606: LD_VAR 0 3
70610: IN
70611: ST_TO_ADDR
// end ;
70612: LD_VAR 0 3
70616: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70617: LD_INT 0
70619: PPUSH
70620: PPUSH
70621: PPUSH
70622: PPUSH
70623: PPUSH
70624: PPUSH
70625: PPUSH
// result := array ;
70626: LD_ADDR_VAR 0 5
70630: PUSH
70631: LD_VAR 0 1
70635: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70636: LD_VAR 0 1
70640: NOT
70641: PUSH
70642: LD_VAR 0 2
70646: NOT
70647: OR
70648: PUSH
70649: LD_VAR 0 3
70653: NOT
70654: OR
70655: PUSH
70656: LD_VAR 0 2
70660: PUSH
70661: LD_VAR 0 1
70665: GREATER
70666: OR
70667: PUSH
70668: LD_VAR 0 3
70672: PUSH
70673: LD_VAR 0 1
70677: GREATER
70678: OR
70679: IFFALSE 70683
// exit ;
70681: GO 70979
// if direction then
70683: LD_VAR 0 4
70687: IFFALSE 70751
// begin d := 1 ;
70689: LD_ADDR_VAR 0 9
70693: PUSH
70694: LD_INT 1
70696: ST_TO_ADDR
// if i_from > i_to then
70697: LD_VAR 0 2
70701: PUSH
70702: LD_VAR 0 3
70706: GREATER
70707: IFFALSE 70733
// length := ( array - i_from ) + i_to else
70709: LD_ADDR_VAR 0 11
70713: PUSH
70714: LD_VAR 0 1
70718: PUSH
70719: LD_VAR 0 2
70723: MINUS
70724: PUSH
70725: LD_VAR 0 3
70729: PLUS
70730: ST_TO_ADDR
70731: GO 70749
// length := i_to - i_from ;
70733: LD_ADDR_VAR 0 11
70737: PUSH
70738: LD_VAR 0 3
70742: PUSH
70743: LD_VAR 0 2
70747: MINUS
70748: ST_TO_ADDR
// end else
70749: GO 70812
// begin d := - 1 ;
70751: LD_ADDR_VAR 0 9
70755: PUSH
70756: LD_INT 1
70758: NEG
70759: ST_TO_ADDR
// if i_from > i_to then
70760: LD_VAR 0 2
70764: PUSH
70765: LD_VAR 0 3
70769: GREATER
70770: IFFALSE 70790
// length := i_from - i_to else
70772: LD_ADDR_VAR 0 11
70776: PUSH
70777: LD_VAR 0 2
70781: PUSH
70782: LD_VAR 0 3
70786: MINUS
70787: ST_TO_ADDR
70788: GO 70812
// length := ( array - i_to ) + i_from ;
70790: LD_ADDR_VAR 0 11
70794: PUSH
70795: LD_VAR 0 1
70799: PUSH
70800: LD_VAR 0 3
70804: MINUS
70805: PUSH
70806: LD_VAR 0 2
70810: PLUS
70811: ST_TO_ADDR
// end ; if not length then
70812: LD_VAR 0 11
70816: NOT
70817: IFFALSE 70821
// exit ;
70819: GO 70979
// tmp := array ;
70821: LD_ADDR_VAR 0 10
70825: PUSH
70826: LD_VAR 0 1
70830: ST_TO_ADDR
// for i = 1 to length do
70831: LD_ADDR_VAR 0 6
70835: PUSH
70836: DOUBLE
70837: LD_INT 1
70839: DEC
70840: ST_TO_ADDR
70841: LD_VAR 0 11
70845: PUSH
70846: FOR_TO
70847: IFFALSE 70967
// begin for j = 1 to array do
70849: LD_ADDR_VAR 0 7
70853: PUSH
70854: DOUBLE
70855: LD_INT 1
70857: DEC
70858: ST_TO_ADDR
70859: LD_VAR 0 1
70863: PUSH
70864: FOR_TO
70865: IFFALSE 70953
// begin k := j + d ;
70867: LD_ADDR_VAR 0 8
70871: PUSH
70872: LD_VAR 0 7
70876: PUSH
70877: LD_VAR 0 9
70881: PLUS
70882: ST_TO_ADDR
// if k > array then
70883: LD_VAR 0 8
70887: PUSH
70888: LD_VAR 0 1
70892: GREATER
70893: IFFALSE 70903
// k := 1 ;
70895: LD_ADDR_VAR 0 8
70899: PUSH
70900: LD_INT 1
70902: ST_TO_ADDR
// if not k then
70903: LD_VAR 0 8
70907: NOT
70908: IFFALSE 70920
// k := array ;
70910: LD_ADDR_VAR 0 8
70914: PUSH
70915: LD_VAR 0 1
70919: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70920: LD_ADDR_VAR 0 10
70924: PUSH
70925: LD_VAR 0 10
70929: PPUSH
70930: LD_VAR 0 8
70934: PPUSH
70935: LD_VAR 0 1
70939: PUSH
70940: LD_VAR 0 7
70944: ARRAY
70945: PPUSH
70946: CALL_OW 1
70950: ST_TO_ADDR
// end ;
70951: GO 70864
70953: POP
70954: POP
// array := tmp ;
70955: LD_ADDR_VAR 0 1
70959: PUSH
70960: LD_VAR 0 10
70964: ST_TO_ADDR
// end ;
70965: GO 70846
70967: POP
70968: POP
// result := array ;
70969: LD_ADDR_VAR 0 5
70973: PUSH
70974: LD_VAR 0 1
70978: ST_TO_ADDR
// end ;
70979: LD_VAR 0 5
70983: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70984: LD_INT 0
70986: PPUSH
70987: PPUSH
// result := 0 ;
70988: LD_ADDR_VAR 0 3
70992: PUSH
70993: LD_INT 0
70995: ST_TO_ADDR
// if not array or not value in array then
70996: LD_VAR 0 1
71000: NOT
71001: PUSH
71002: LD_VAR 0 2
71006: PUSH
71007: LD_VAR 0 1
71011: IN
71012: NOT
71013: OR
71014: IFFALSE 71018
// exit ;
71016: GO 71072
// for i = 1 to array do
71018: LD_ADDR_VAR 0 4
71022: PUSH
71023: DOUBLE
71024: LD_INT 1
71026: DEC
71027: ST_TO_ADDR
71028: LD_VAR 0 1
71032: PUSH
71033: FOR_TO
71034: IFFALSE 71070
// if value = array [ i ] then
71036: LD_VAR 0 2
71040: PUSH
71041: LD_VAR 0 1
71045: PUSH
71046: LD_VAR 0 4
71050: ARRAY
71051: EQUAL
71052: IFFALSE 71068
// begin result := i ;
71054: LD_ADDR_VAR 0 3
71058: PUSH
71059: LD_VAR 0 4
71063: ST_TO_ADDR
// exit ;
71064: POP
71065: POP
71066: GO 71072
// end ;
71068: GO 71033
71070: POP
71071: POP
// end ;
71072: LD_VAR 0 3
71076: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71077: LD_INT 0
71079: PPUSH
// vc_chassis := chassis ;
71080: LD_ADDR_OWVAR 37
71084: PUSH
71085: LD_VAR 0 1
71089: ST_TO_ADDR
// vc_engine := engine ;
71090: LD_ADDR_OWVAR 39
71094: PUSH
71095: LD_VAR 0 2
71099: ST_TO_ADDR
// vc_control := control ;
71100: LD_ADDR_OWVAR 38
71104: PUSH
71105: LD_VAR 0 3
71109: ST_TO_ADDR
// vc_weapon := weapon ;
71110: LD_ADDR_OWVAR 40
71114: PUSH
71115: LD_VAR 0 4
71119: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71120: LD_ADDR_OWVAR 41
71124: PUSH
71125: LD_VAR 0 5
71129: ST_TO_ADDR
// end ;
71130: LD_VAR 0 6
71134: RET
// export function WantPlant ( unit ) ; var task ; begin
71135: LD_INT 0
71137: PPUSH
71138: PPUSH
// result := false ;
71139: LD_ADDR_VAR 0 2
71143: PUSH
71144: LD_INT 0
71146: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71147: LD_ADDR_VAR 0 3
71151: PUSH
71152: LD_VAR 0 1
71156: PPUSH
71157: CALL_OW 437
71161: ST_TO_ADDR
// if task then
71162: LD_VAR 0 3
71166: IFFALSE 71194
// if task [ 1 ] [ 1 ] = p then
71168: LD_VAR 0 3
71172: PUSH
71173: LD_INT 1
71175: ARRAY
71176: PUSH
71177: LD_INT 1
71179: ARRAY
71180: PUSH
71181: LD_STRING p
71183: EQUAL
71184: IFFALSE 71194
// result := true ;
71186: LD_ADDR_VAR 0 2
71190: PUSH
71191: LD_INT 1
71193: ST_TO_ADDR
// end ;
71194: LD_VAR 0 2
71198: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71199: LD_INT 0
71201: PPUSH
71202: PPUSH
71203: PPUSH
71204: PPUSH
// if pos < 1 then
71205: LD_VAR 0 2
71209: PUSH
71210: LD_INT 1
71212: LESS
71213: IFFALSE 71217
// exit ;
71215: GO 71520
// if pos = 1 then
71217: LD_VAR 0 2
71221: PUSH
71222: LD_INT 1
71224: EQUAL
71225: IFFALSE 71258
// result := Replace ( arr , pos [ 1 ] , value ) else
71227: LD_ADDR_VAR 0 4
71231: PUSH
71232: LD_VAR 0 1
71236: PPUSH
71237: LD_VAR 0 2
71241: PUSH
71242: LD_INT 1
71244: ARRAY
71245: PPUSH
71246: LD_VAR 0 3
71250: PPUSH
71251: CALL_OW 1
71255: ST_TO_ADDR
71256: GO 71520
// begin tmp := arr ;
71258: LD_ADDR_VAR 0 6
71262: PUSH
71263: LD_VAR 0 1
71267: ST_TO_ADDR
// s_arr := [ tmp ] ;
71268: LD_ADDR_VAR 0 7
71272: PUSH
71273: LD_VAR 0 6
71277: PUSH
71278: EMPTY
71279: LIST
71280: ST_TO_ADDR
// for i = 1 to pos - 1 do
71281: LD_ADDR_VAR 0 5
71285: PUSH
71286: DOUBLE
71287: LD_INT 1
71289: DEC
71290: ST_TO_ADDR
71291: LD_VAR 0 2
71295: PUSH
71296: LD_INT 1
71298: MINUS
71299: PUSH
71300: FOR_TO
71301: IFFALSE 71346
// begin tmp := tmp [ pos [ i ] ] ;
71303: LD_ADDR_VAR 0 6
71307: PUSH
71308: LD_VAR 0 6
71312: PUSH
71313: LD_VAR 0 2
71317: PUSH
71318: LD_VAR 0 5
71322: ARRAY
71323: ARRAY
71324: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71325: LD_ADDR_VAR 0 7
71329: PUSH
71330: LD_VAR 0 7
71334: PUSH
71335: LD_VAR 0 6
71339: PUSH
71340: EMPTY
71341: LIST
71342: ADD
71343: ST_TO_ADDR
// end ;
71344: GO 71300
71346: POP
71347: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71348: LD_ADDR_VAR 0 6
71352: PUSH
71353: LD_VAR 0 6
71357: PPUSH
71358: LD_VAR 0 2
71362: PUSH
71363: LD_VAR 0 2
71367: ARRAY
71368: PPUSH
71369: LD_VAR 0 3
71373: PPUSH
71374: CALL_OW 1
71378: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71379: LD_ADDR_VAR 0 7
71383: PUSH
71384: LD_VAR 0 7
71388: PPUSH
71389: LD_VAR 0 7
71393: PPUSH
71394: LD_VAR 0 6
71398: PPUSH
71399: CALL_OW 1
71403: ST_TO_ADDR
// for i = s_arr downto 2 do
71404: LD_ADDR_VAR 0 5
71408: PUSH
71409: DOUBLE
71410: LD_VAR 0 7
71414: INC
71415: ST_TO_ADDR
71416: LD_INT 2
71418: PUSH
71419: FOR_DOWNTO
71420: IFFALSE 71504
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71422: LD_ADDR_VAR 0 6
71426: PUSH
71427: LD_VAR 0 7
71431: PUSH
71432: LD_VAR 0 5
71436: PUSH
71437: LD_INT 1
71439: MINUS
71440: ARRAY
71441: PPUSH
71442: LD_VAR 0 2
71446: PUSH
71447: LD_VAR 0 5
71451: PUSH
71452: LD_INT 1
71454: MINUS
71455: ARRAY
71456: PPUSH
71457: LD_VAR 0 7
71461: PUSH
71462: LD_VAR 0 5
71466: ARRAY
71467: PPUSH
71468: CALL_OW 1
71472: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71473: LD_ADDR_VAR 0 7
71477: PUSH
71478: LD_VAR 0 7
71482: PPUSH
71483: LD_VAR 0 5
71487: PUSH
71488: LD_INT 1
71490: MINUS
71491: PPUSH
71492: LD_VAR 0 6
71496: PPUSH
71497: CALL_OW 1
71501: ST_TO_ADDR
// end ;
71502: GO 71419
71504: POP
71505: POP
// result := s_arr [ 1 ] ;
71506: LD_ADDR_VAR 0 4
71510: PUSH
71511: LD_VAR 0 7
71515: PUSH
71516: LD_INT 1
71518: ARRAY
71519: ST_TO_ADDR
// end ; end ;
71520: LD_VAR 0 4
71524: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71525: LD_INT 0
71527: PPUSH
71528: PPUSH
// if not list then
71529: LD_VAR 0 1
71533: NOT
71534: IFFALSE 71538
// exit ;
71536: GO 71629
// i := list [ pos1 ] ;
71538: LD_ADDR_VAR 0 5
71542: PUSH
71543: LD_VAR 0 1
71547: PUSH
71548: LD_VAR 0 2
71552: ARRAY
71553: ST_TO_ADDR
// if not i then
71554: LD_VAR 0 5
71558: NOT
71559: IFFALSE 71563
// exit ;
71561: GO 71629
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71563: LD_ADDR_VAR 0 1
71567: PUSH
71568: LD_VAR 0 1
71572: PPUSH
71573: LD_VAR 0 2
71577: PPUSH
71578: LD_VAR 0 1
71582: PUSH
71583: LD_VAR 0 3
71587: ARRAY
71588: PPUSH
71589: CALL_OW 1
71593: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71594: LD_ADDR_VAR 0 1
71598: PUSH
71599: LD_VAR 0 1
71603: PPUSH
71604: LD_VAR 0 3
71608: PPUSH
71609: LD_VAR 0 5
71613: PPUSH
71614: CALL_OW 1
71618: ST_TO_ADDR
// result := list ;
71619: LD_ADDR_VAR 0 4
71623: PUSH
71624: LD_VAR 0 1
71628: ST_TO_ADDR
// end ;
71629: LD_VAR 0 4
71633: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71634: LD_INT 0
71636: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71637: LD_ADDR_VAR 0 5
71641: PUSH
71642: LD_VAR 0 1
71646: PPUSH
71647: CALL_OW 250
71651: PPUSH
71652: LD_VAR 0 1
71656: PPUSH
71657: CALL_OW 251
71661: PPUSH
71662: LD_VAR 0 2
71666: PPUSH
71667: LD_VAR 0 3
71671: PPUSH
71672: LD_VAR 0 4
71676: PPUSH
71677: CALL 71687 0 5
71681: ST_TO_ADDR
// end ;
71682: LD_VAR 0 5
71686: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71687: LD_INT 0
71689: PPUSH
71690: PPUSH
71691: PPUSH
71692: PPUSH
// if not list then
71693: LD_VAR 0 3
71697: NOT
71698: IFFALSE 71702
// exit ;
71700: GO 72090
// result := [ ] ;
71702: LD_ADDR_VAR 0 6
71706: PUSH
71707: EMPTY
71708: ST_TO_ADDR
// for i in list do
71709: LD_ADDR_VAR 0 7
71713: PUSH
71714: LD_VAR 0 3
71718: PUSH
71719: FOR_IN
71720: IFFALSE 71922
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71722: LD_ADDR_VAR 0 9
71726: PUSH
71727: LD_VAR 0 7
71731: PPUSH
71732: LD_VAR 0 1
71736: PPUSH
71737: LD_VAR 0 2
71741: PPUSH
71742: CALL_OW 297
71746: ST_TO_ADDR
// if not result then
71747: LD_VAR 0 6
71751: NOT
71752: IFFALSE 71778
// result := [ [ i , tmp ] ] else
71754: LD_ADDR_VAR 0 6
71758: PUSH
71759: LD_VAR 0 7
71763: PUSH
71764: LD_VAR 0 9
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: EMPTY
71774: LIST
71775: ST_TO_ADDR
71776: GO 71920
// begin if result [ result ] [ 2 ] < tmp then
71778: LD_VAR 0 6
71782: PUSH
71783: LD_VAR 0 6
71787: ARRAY
71788: PUSH
71789: LD_INT 2
71791: ARRAY
71792: PUSH
71793: LD_VAR 0 9
71797: LESS
71798: IFFALSE 71840
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71800: LD_ADDR_VAR 0 6
71804: PUSH
71805: LD_VAR 0 6
71809: PPUSH
71810: LD_VAR 0 6
71814: PUSH
71815: LD_INT 1
71817: PLUS
71818: PPUSH
71819: LD_VAR 0 7
71823: PUSH
71824: LD_VAR 0 9
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PPUSH
71833: CALL_OW 2
71837: ST_TO_ADDR
71838: GO 71920
// for j = 1 to result do
71840: LD_ADDR_VAR 0 8
71844: PUSH
71845: DOUBLE
71846: LD_INT 1
71848: DEC
71849: ST_TO_ADDR
71850: LD_VAR 0 6
71854: PUSH
71855: FOR_TO
71856: IFFALSE 71918
// begin if tmp < result [ j ] [ 2 ] then
71858: LD_VAR 0 9
71862: PUSH
71863: LD_VAR 0 6
71867: PUSH
71868: LD_VAR 0 8
71872: ARRAY
71873: PUSH
71874: LD_INT 2
71876: ARRAY
71877: LESS
71878: IFFALSE 71916
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71880: LD_ADDR_VAR 0 6
71884: PUSH
71885: LD_VAR 0 6
71889: PPUSH
71890: LD_VAR 0 8
71894: PPUSH
71895: LD_VAR 0 7
71899: PUSH
71900: LD_VAR 0 9
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: PPUSH
71909: CALL_OW 2
71913: ST_TO_ADDR
// break ;
71914: GO 71918
// end ; end ;
71916: GO 71855
71918: POP
71919: POP
// end ; end ;
71920: GO 71719
71922: POP
71923: POP
// if result and not asc then
71924: LD_VAR 0 6
71928: PUSH
71929: LD_VAR 0 4
71933: NOT
71934: AND
71935: IFFALSE 72010
// begin tmp := result ;
71937: LD_ADDR_VAR 0 9
71941: PUSH
71942: LD_VAR 0 6
71946: ST_TO_ADDR
// for i = tmp downto 1 do
71947: LD_ADDR_VAR 0 7
71951: PUSH
71952: DOUBLE
71953: LD_VAR 0 9
71957: INC
71958: ST_TO_ADDR
71959: LD_INT 1
71961: PUSH
71962: FOR_DOWNTO
71963: IFFALSE 72008
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71965: LD_ADDR_VAR 0 6
71969: PUSH
71970: LD_VAR 0 6
71974: PPUSH
71975: LD_VAR 0 9
71979: PUSH
71980: LD_VAR 0 7
71984: MINUS
71985: PUSH
71986: LD_INT 1
71988: PLUS
71989: PPUSH
71990: LD_VAR 0 9
71994: PUSH
71995: LD_VAR 0 7
71999: ARRAY
72000: PPUSH
72001: CALL_OW 1
72005: ST_TO_ADDR
72006: GO 71962
72008: POP
72009: POP
// end ; tmp := [ ] ;
72010: LD_ADDR_VAR 0 9
72014: PUSH
72015: EMPTY
72016: ST_TO_ADDR
// if mode then
72017: LD_VAR 0 5
72021: IFFALSE 72090
// begin for i = 1 to result do
72023: LD_ADDR_VAR 0 7
72027: PUSH
72028: DOUBLE
72029: LD_INT 1
72031: DEC
72032: ST_TO_ADDR
72033: LD_VAR 0 6
72037: PUSH
72038: FOR_TO
72039: IFFALSE 72078
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72041: LD_ADDR_VAR 0 9
72045: PUSH
72046: LD_VAR 0 9
72050: PPUSH
72051: LD_VAR 0 7
72055: PPUSH
72056: LD_VAR 0 6
72060: PUSH
72061: LD_VAR 0 7
72065: ARRAY
72066: PUSH
72067: LD_INT 1
72069: ARRAY
72070: PPUSH
72071: CALL_OW 1
72075: ST_TO_ADDR
72076: GO 72038
72078: POP
72079: POP
// result := tmp ;
72080: LD_ADDR_VAR 0 6
72084: PUSH
72085: LD_VAR 0 9
72089: ST_TO_ADDR
// end ; end ;
72090: LD_VAR 0 6
72094: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72095: LD_INT 0
72097: PPUSH
72098: PPUSH
72099: PPUSH
72100: PPUSH
72101: PPUSH
72102: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72103: LD_ADDR_VAR 0 5
72107: PUSH
72108: LD_INT 0
72110: PUSH
72111: LD_INT 0
72113: PUSH
72114: LD_INT 0
72116: PUSH
72117: EMPTY
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: LIST
72123: LIST
72124: ST_TO_ADDR
// if not x or not y then
72125: LD_VAR 0 2
72129: NOT
72130: PUSH
72131: LD_VAR 0 3
72135: NOT
72136: OR
72137: IFFALSE 72141
// exit ;
72139: GO 73787
// if not range then
72141: LD_VAR 0 4
72145: NOT
72146: IFFALSE 72156
// range := 10 ;
72148: LD_ADDR_VAR 0 4
72152: PUSH
72153: LD_INT 10
72155: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72156: LD_ADDR_VAR 0 8
72160: PUSH
72161: LD_INT 81
72163: PUSH
72164: LD_VAR 0 1
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PUSH
72173: LD_INT 92
72175: PUSH
72176: LD_VAR 0 2
72180: PUSH
72181: LD_VAR 0 3
72185: PUSH
72186: LD_VAR 0 4
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 3
72199: PUSH
72200: LD_INT 21
72202: PUSH
72203: LD_INT 3
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: LIST
72218: PPUSH
72219: CALL_OW 69
72223: ST_TO_ADDR
// if not tmp then
72224: LD_VAR 0 8
72228: NOT
72229: IFFALSE 72233
// exit ;
72231: GO 73787
// for i in tmp do
72233: LD_ADDR_VAR 0 6
72237: PUSH
72238: LD_VAR 0 8
72242: PUSH
72243: FOR_IN
72244: IFFALSE 73762
// begin points := [ 0 , 0 , 0 ] ;
72246: LD_ADDR_VAR 0 9
72250: PUSH
72251: LD_INT 0
72253: PUSH
72254: LD_INT 0
72256: PUSH
72257: LD_INT 0
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: LIST
72264: ST_TO_ADDR
// bpoints := 1 ;
72265: LD_ADDR_VAR 0 10
72269: PUSH
72270: LD_INT 1
72272: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72273: LD_VAR 0 6
72277: PPUSH
72278: CALL_OW 247
72282: PUSH
72283: LD_INT 1
72285: DOUBLE
72286: EQUAL
72287: IFTRUE 72291
72289: GO 72869
72291: POP
// begin if GetClass ( i ) = 1 then
72292: LD_VAR 0 6
72296: PPUSH
72297: CALL_OW 257
72301: PUSH
72302: LD_INT 1
72304: EQUAL
72305: IFFALSE 72326
// points := [ 10 , 5 , 3 ] ;
72307: LD_ADDR_VAR 0 9
72311: PUSH
72312: LD_INT 10
72314: PUSH
72315: LD_INT 5
72317: PUSH
72318: LD_INT 3
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: LIST
72325: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72326: LD_VAR 0 6
72330: PPUSH
72331: CALL_OW 257
72335: PUSH
72336: LD_INT 2
72338: PUSH
72339: LD_INT 3
72341: PUSH
72342: LD_INT 4
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: LIST
72349: IN
72350: IFFALSE 72371
// points := [ 3 , 2 , 1 ] ;
72352: LD_ADDR_VAR 0 9
72356: PUSH
72357: LD_INT 3
72359: PUSH
72360: LD_INT 2
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: LIST
72370: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72371: LD_VAR 0 6
72375: PPUSH
72376: CALL_OW 257
72380: PUSH
72381: LD_INT 5
72383: EQUAL
72384: IFFALSE 72405
// points := [ 130 , 5 , 2 ] ;
72386: LD_ADDR_VAR 0 9
72390: PUSH
72391: LD_INT 130
72393: PUSH
72394: LD_INT 5
72396: PUSH
72397: LD_INT 2
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: LIST
72404: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72405: LD_VAR 0 6
72409: PPUSH
72410: CALL_OW 257
72414: PUSH
72415: LD_INT 8
72417: EQUAL
72418: IFFALSE 72439
// points := [ 35 , 35 , 30 ] ;
72420: LD_ADDR_VAR 0 9
72424: PUSH
72425: LD_INT 35
72427: PUSH
72428: LD_INT 35
72430: PUSH
72431: LD_INT 30
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: LIST
72438: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72439: LD_VAR 0 6
72443: PPUSH
72444: CALL_OW 257
72448: PUSH
72449: LD_INT 9
72451: EQUAL
72452: IFFALSE 72473
// points := [ 20 , 55 , 40 ] ;
72454: LD_ADDR_VAR 0 9
72458: PUSH
72459: LD_INT 20
72461: PUSH
72462: LD_INT 55
72464: PUSH
72465: LD_INT 40
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: LIST
72472: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72473: LD_VAR 0 6
72477: PPUSH
72478: CALL_OW 257
72482: PUSH
72483: LD_INT 12
72485: PUSH
72486: LD_INT 16
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: IN
72493: IFFALSE 72514
// points := [ 5 , 3 , 2 ] ;
72495: LD_ADDR_VAR 0 9
72499: PUSH
72500: LD_INT 5
72502: PUSH
72503: LD_INT 3
72505: PUSH
72506: LD_INT 2
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: LIST
72513: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72514: LD_VAR 0 6
72518: PPUSH
72519: CALL_OW 257
72523: PUSH
72524: LD_INT 17
72526: EQUAL
72527: IFFALSE 72548
// points := [ 100 , 50 , 75 ] ;
72529: LD_ADDR_VAR 0 9
72533: PUSH
72534: LD_INT 100
72536: PUSH
72537: LD_INT 50
72539: PUSH
72540: LD_INT 75
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: LIST
72547: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72548: LD_VAR 0 6
72552: PPUSH
72553: CALL_OW 257
72557: PUSH
72558: LD_INT 15
72560: EQUAL
72561: IFFALSE 72582
// points := [ 10 , 5 , 3 ] ;
72563: LD_ADDR_VAR 0 9
72567: PUSH
72568: LD_INT 10
72570: PUSH
72571: LD_INT 5
72573: PUSH
72574: LD_INT 3
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: LIST
72581: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72582: LD_VAR 0 6
72586: PPUSH
72587: CALL_OW 257
72591: PUSH
72592: LD_INT 14
72594: EQUAL
72595: IFFALSE 72616
// points := [ 10 , 0 , 0 ] ;
72597: LD_ADDR_VAR 0 9
72601: PUSH
72602: LD_INT 10
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: LD_INT 0
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: LIST
72615: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72616: LD_VAR 0 6
72620: PPUSH
72621: CALL_OW 257
72625: PUSH
72626: LD_INT 11
72628: EQUAL
72629: IFFALSE 72650
// points := [ 30 , 10 , 5 ] ;
72631: LD_ADDR_VAR 0 9
72635: PUSH
72636: LD_INT 30
72638: PUSH
72639: LD_INT 10
72641: PUSH
72642: LD_INT 5
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: LIST
72649: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72650: LD_VAR 0 1
72654: PPUSH
72655: LD_INT 5
72657: PPUSH
72658: CALL_OW 321
72662: PUSH
72663: LD_INT 2
72665: EQUAL
72666: IFFALSE 72683
// bpoints := bpoints * 1.8 ;
72668: LD_ADDR_VAR 0 10
72672: PUSH
72673: LD_VAR 0 10
72677: PUSH
72678: LD_REAL  1.80000000000000E+0000
72681: MUL
72682: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72683: LD_VAR 0 6
72687: PPUSH
72688: CALL_OW 257
72692: PUSH
72693: LD_INT 1
72695: PUSH
72696: LD_INT 2
72698: PUSH
72699: LD_INT 3
72701: PUSH
72702: LD_INT 4
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: IN
72711: PUSH
72712: LD_VAR 0 1
72716: PPUSH
72717: LD_INT 51
72719: PPUSH
72720: CALL_OW 321
72724: PUSH
72725: LD_INT 2
72727: EQUAL
72728: AND
72729: IFFALSE 72746
// bpoints := bpoints * 1.2 ;
72731: LD_ADDR_VAR 0 10
72735: PUSH
72736: LD_VAR 0 10
72740: PUSH
72741: LD_REAL  1.20000000000000E+0000
72744: MUL
72745: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72746: LD_VAR 0 6
72750: PPUSH
72751: CALL_OW 257
72755: PUSH
72756: LD_INT 5
72758: PUSH
72759: LD_INT 7
72761: PUSH
72762: LD_INT 9
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: LIST
72769: IN
72770: PUSH
72771: LD_VAR 0 1
72775: PPUSH
72776: LD_INT 52
72778: PPUSH
72779: CALL_OW 321
72783: PUSH
72784: LD_INT 2
72786: EQUAL
72787: AND
72788: IFFALSE 72805
// bpoints := bpoints * 1.5 ;
72790: LD_ADDR_VAR 0 10
72794: PUSH
72795: LD_VAR 0 10
72799: PUSH
72800: LD_REAL  1.50000000000000E+0000
72803: MUL
72804: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72805: LD_VAR 0 1
72809: PPUSH
72810: LD_INT 66
72812: PPUSH
72813: CALL_OW 321
72817: PUSH
72818: LD_INT 2
72820: EQUAL
72821: IFFALSE 72838
// bpoints := bpoints * 1.1 ;
72823: LD_ADDR_VAR 0 10
72827: PUSH
72828: LD_VAR 0 10
72832: PUSH
72833: LD_REAL  1.10000000000000E+0000
72836: MUL
72837: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72838: LD_ADDR_VAR 0 10
72842: PUSH
72843: LD_VAR 0 10
72847: PUSH
72848: LD_VAR 0 6
72852: PPUSH
72853: LD_INT 1
72855: PPUSH
72856: CALL_OW 259
72860: PUSH
72861: LD_REAL  1.15000000000000E+0000
72864: MUL
72865: MUL
72866: ST_TO_ADDR
// end ; unit_vehicle :
72867: GO 73691
72869: LD_INT 2
72871: DOUBLE
72872: EQUAL
72873: IFTRUE 72877
72875: GO 73679
72877: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72878: LD_VAR 0 6
72882: PPUSH
72883: CALL_OW 264
72887: PUSH
72888: LD_INT 2
72890: PUSH
72891: LD_INT 42
72893: PUSH
72894: LD_INT 24
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: LIST
72901: IN
72902: IFFALSE 72923
// points := [ 25 , 5 , 3 ] ;
72904: LD_ADDR_VAR 0 9
72908: PUSH
72909: LD_INT 25
72911: PUSH
72912: LD_INT 5
72914: PUSH
72915: LD_INT 3
72917: PUSH
72918: EMPTY
72919: LIST
72920: LIST
72921: LIST
72922: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72923: LD_VAR 0 6
72927: PPUSH
72928: CALL_OW 264
72932: PUSH
72933: LD_INT 4
72935: PUSH
72936: LD_INT 43
72938: PUSH
72939: LD_INT 25
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: LIST
72946: IN
72947: IFFALSE 72968
// points := [ 40 , 15 , 5 ] ;
72949: LD_ADDR_VAR 0 9
72953: PUSH
72954: LD_INT 40
72956: PUSH
72957: LD_INT 15
72959: PUSH
72960: LD_INT 5
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: LIST
72967: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72968: LD_VAR 0 6
72972: PPUSH
72973: CALL_OW 264
72977: PUSH
72978: LD_INT 3
72980: PUSH
72981: LD_INT 23
72983: PUSH
72984: EMPTY
72985: LIST
72986: LIST
72987: IN
72988: IFFALSE 73009
// points := [ 7 , 25 , 8 ] ;
72990: LD_ADDR_VAR 0 9
72994: PUSH
72995: LD_INT 7
72997: PUSH
72998: LD_INT 25
73000: PUSH
73001: LD_INT 8
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: LIST
73008: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73009: LD_VAR 0 6
73013: PPUSH
73014: CALL_OW 264
73018: PUSH
73019: LD_INT 5
73021: PUSH
73022: LD_INT 27
73024: PUSH
73025: LD_INT 44
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: LIST
73032: IN
73033: IFFALSE 73054
// points := [ 14 , 50 , 16 ] ;
73035: LD_ADDR_VAR 0 9
73039: PUSH
73040: LD_INT 14
73042: PUSH
73043: LD_INT 50
73045: PUSH
73046: LD_INT 16
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: LIST
73053: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73054: LD_VAR 0 6
73058: PPUSH
73059: CALL_OW 264
73063: PUSH
73064: LD_INT 6
73066: PUSH
73067: LD_INT 46
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: IN
73074: IFFALSE 73095
// points := [ 32 , 120 , 70 ] ;
73076: LD_ADDR_VAR 0 9
73080: PUSH
73081: LD_INT 32
73083: PUSH
73084: LD_INT 120
73086: PUSH
73087: LD_INT 70
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: LIST
73094: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73095: LD_VAR 0 6
73099: PPUSH
73100: CALL_OW 264
73104: PUSH
73105: LD_INT 7
73107: PUSH
73108: LD_INT 28
73110: PUSH
73111: LD_INT 45
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: LIST
73118: IN
73119: IFFALSE 73140
// points := [ 35 , 20 , 45 ] ;
73121: LD_ADDR_VAR 0 9
73125: PUSH
73126: LD_INT 35
73128: PUSH
73129: LD_INT 20
73131: PUSH
73132: LD_INT 45
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: LIST
73139: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73140: LD_VAR 0 6
73144: PPUSH
73145: CALL_OW 264
73149: PUSH
73150: LD_INT 47
73152: PUSH
73153: EMPTY
73154: LIST
73155: IN
73156: IFFALSE 73177
// points := [ 67 , 45 , 75 ] ;
73158: LD_ADDR_VAR 0 9
73162: PUSH
73163: LD_INT 67
73165: PUSH
73166: LD_INT 45
73168: PUSH
73169: LD_INT 75
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: LIST
73176: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73177: LD_VAR 0 6
73181: PPUSH
73182: CALL_OW 264
73186: PUSH
73187: LD_INT 26
73189: PUSH
73190: EMPTY
73191: LIST
73192: IN
73193: IFFALSE 73214
// points := [ 120 , 30 , 80 ] ;
73195: LD_ADDR_VAR 0 9
73199: PUSH
73200: LD_INT 120
73202: PUSH
73203: LD_INT 30
73205: PUSH
73206: LD_INT 80
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: LIST
73213: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73214: LD_VAR 0 6
73218: PPUSH
73219: CALL_OW 264
73223: PUSH
73224: LD_INT 22
73226: PUSH
73227: EMPTY
73228: LIST
73229: IN
73230: IFFALSE 73251
// points := [ 40 , 1 , 1 ] ;
73232: LD_ADDR_VAR 0 9
73236: PUSH
73237: LD_INT 40
73239: PUSH
73240: LD_INT 1
73242: PUSH
73243: LD_INT 1
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: LIST
73250: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73251: LD_VAR 0 6
73255: PPUSH
73256: CALL_OW 264
73260: PUSH
73261: LD_INT 29
73263: PUSH
73264: EMPTY
73265: LIST
73266: IN
73267: IFFALSE 73288
// points := [ 70 , 200 , 400 ] ;
73269: LD_ADDR_VAR 0 9
73273: PUSH
73274: LD_INT 70
73276: PUSH
73277: LD_INT 200
73279: PUSH
73280: LD_INT 400
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: LIST
73287: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73288: LD_VAR 0 6
73292: PPUSH
73293: CALL_OW 264
73297: PUSH
73298: LD_INT 14
73300: PUSH
73301: LD_INT 53
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: IN
73308: IFFALSE 73329
// points := [ 40 , 10 , 20 ] ;
73310: LD_ADDR_VAR 0 9
73314: PUSH
73315: LD_INT 40
73317: PUSH
73318: LD_INT 10
73320: PUSH
73321: LD_INT 20
73323: PUSH
73324: EMPTY
73325: LIST
73326: LIST
73327: LIST
73328: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73329: LD_VAR 0 6
73333: PPUSH
73334: CALL_OW 264
73338: PUSH
73339: LD_INT 9
73341: PUSH
73342: EMPTY
73343: LIST
73344: IN
73345: IFFALSE 73366
// points := [ 5 , 70 , 20 ] ;
73347: LD_ADDR_VAR 0 9
73351: PUSH
73352: LD_INT 5
73354: PUSH
73355: LD_INT 70
73357: PUSH
73358: LD_INT 20
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: LIST
73365: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73366: LD_VAR 0 6
73370: PPUSH
73371: CALL_OW 264
73375: PUSH
73376: LD_INT 10
73378: PUSH
73379: EMPTY
73380: LIST
73381: IN
73382: IFFALSE 73403
// points := [ 35 , 110 , 70 ] ;
73384: LD_ADDR_VAR 0 9
73388: PUSH
73389: LD_INT 35
73391: PUSH
73392: LD_INT 110
73394: PUSH
73395: LD_INT 70
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: LIST
73402: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73403: LD_VAR 0 6
73407: PPUSH
73408: CALL_OW 265
73412: PUSH
73413: LD_INT 25
73415: EQUAL
73416: IFFALSE 73437
// points := [ 80 , 65 , 100 ] ;
73418: LD_ADDR_VAR 0 9
73422: PUSH
73423: LD_INT 80
73425: PUSH
73426: LD_INT 65
73428: PUSH
73429: LD_INT 100
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: LIST
73436: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73437: LD_VAR 0 6
73441: PPUSH
73442: CALL_OW 263
73446: PUSH
73447: LD_INT 1
73449: EQUAL
73450: IFFALSE 73485
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73452: LD_ADDR_VAR 0 10
73456: PUSH
73457: LD_VAR 0 10
73461: PUSH
73462: LD_VAR 0 6
73466: PPUSH
73467: CALL_OW 311
73471: PPUSH
73472: LD_INT 3
73474: PPUSH
73475: CALL_OW 259
73479: PUSH
73480: LD_INT 4
73482: MUL
73483: MUL
73484: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73485: LD_VAR 0 6
73489: PPUSH
73490: CALL_OW 263
73494: PUSH
73495: LD_INT 2
73497: EQUAL
73498: IFFALSE 73549
// begin j := IsControledBy ( i ) ;
73500: LD_ADDR_VAR 0 7
73504: PUSH
73505: LD_VAR 0 6
73509: PPUSH
73510: CALL_OW 312
73514: ST_TO_ADDR
// if j then
73515: LD_VAR 0 7
73519: IFFALSE 73549
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73521: LD_ADDR_VAR 0 10
73525: PUSH
73526: LD_VAR 0 10
73530: PUSH
73531: LD_VAR 0 7
73535: PPUSH
73536: LD_INT 3
73538: PPUSH
73539: CALL_OW 259
73543: PUSH
73544: LD_INT 3
73546: MUL
73547: MUL
73548: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73549: LD_VAR 0 6
73553: PPUSH
73554: CALL_OW 264
73558: PUSH
73559: LD_INT 5
73561: PUSH
73562: LD_INT 6
73564: PUSH
73565: LD_INT 46
73567: PUSH
73568: LD_INT 44
73570: PUSH
73571: LD_INT 47
73573: PUSH
73574: LD_INT 45
73576: PUSH
73577: LD_INT 28
73579: PUSH
73580: LD_INT 7
73582: PUSH
73583: LD_INT 27
73585: PUSH
73586: LD_INT 29
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: LIST
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: IN
73601: PUSH
73602: LD_VAR 0 1
73606: PPUSH
73607: LD_INT 52
73609: PPUSH
73610: CALL_OW 321
73614: PUSH
73615: LD_INT 2
73617: EQUAL
73618: AND
73619: IFFALSE 73636
// bpoints := bpoints * 1.2 ;
73621: LD_ADDR_VAR 0 10
73625: PUSH
73626: LD_VAR 0 10
73630: PUSH
73631: LD_REAL  1.20000000000000E+0000
73634: MUL
73635: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73636: LD_VAR 0 6
73640: PPUSH
73641: CALL_OW 264
73645: PUSH
73646: LD_INT 6
73648: PUSH
73649: LD_INT 46
73651: PUSH
73652: LD_INT 47
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: LIST
73659: IN
73660: IFFALSE 73677
// bpoints := bpoints * 1.2 ;
73662: LD_ADDR_VAR 0 10
73666: PUSH
73667: LD_VAR 0 10
73671: PUSH
73672: LD_REAL  1.20000000000000E+0000
73675: MUL
73676: ST_TO_ADDR
// end ; unit_building :
73677: GO 73691
73679: LD_INT 3
73681: DOUBLE
73682: EQUAL
73683: IFTRUE 73687
73685: GO 73690
73687: POP
// ; end ;
73688: GO 73691
73690: POP
// for j = 1 to 3 do
73691: LD_ADDR_VAR 0 7
73695: PUSH
73696: DOUBLE
73697: LD_INT 1
73699: DEC
73700: ST_TO_ADDR
73701: LD_INT 3
73703: PUSH
73704: FOR_TO
73705: IFFALSE 73758
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73707: LD_ADDR_VAR 0 5
73711: PUSH
73712: LD_VAR 0 5
73716: PPUSH
73717: LD_VAR 0 7
73721: PPUSH
73722: LD_VAR 0 5
73726: PUSH
73727: LD_VAR 0 7
73731: ARRAY
73732: PUSH
73733: LD_VAR 0 9
73737: PUSH
73738: LD_VAR 0 7
73742: ARRAY
73743: PUSH
73744: LD_VAR 0 10
73748: MUL
73749: PLUS
73750: PPUSH
73751: CALL_OW 1
73755: ST_TO_ADDR
73756: GO 73704
73758: POP
73759: POP
// end ;
73760: GO 72243
73762: POP
73763: POP
// result := Replace ( result , 4 , tmp ) ;
73764: LD_ADDR_VAR 0 5
73768: PUSH
73769: LD_VAR 0 5
73773: PPUSH
73774: LD_INT 4
73776: PPUSH
73777: LD_VAR 0 8
73781: PPUSH
73782: CALL_OW 1
73786: ST_TO_ADDR
// end ;
73787: LD_VAR 0 5
73791: RET
// export function DangerAtRange ( unit , range ) ; begin
73792: LD_INT 0
73794: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73795: LD_ADDR_VAR 0 3
73799: PUSH
73800: LD_VAR 0 1
73804: PPUSH
73805: CALL_OW 255
73809: PPUSH
73810: LD_VAR 0 1
73814: PPUSH
73815: CALL_OW 250
73819: PPUSH
73820: LD_VAR 0 1
73824: PPUSH
73825: CALL_OW 251
73829: PPUSH
73830: LD_VAR 0 2
73834: PPUSH
73835: CALL 72095 0 4
73839: ST_TO_ADDR
// end ;
73840: LD_VAR 0 3
73844: RET
// export function DangerInArea ( side , area ) ; begin
73845: LD_INT 0
73847: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73848: LD_ADDR_VAR 0 3
73852: PUSH
73853: LD_VAR 0 2
73857: PPUSH
73858: LD_INT 81
73860: PUSH
73861: LD_VAR 0 1
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PPUSH
73870: CALL_OW 70
73874: ST_TO_ADDR
// end ;
73875: LD_VAR 0 3
73879: RET
// export function IsExtension ( b ) ; begin
73880: LD_INT 0
73882: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73883: LD_ADDR_VAR 0 2
73887: PUSH
73888: LD_VAR 0 1
73892: PUSH
73893: LD_INT 23
73895: PUSH
73896: LD_INT 20
73898: PUSH
73899: LD_INT 22
73901: PUSH
73902: LD_INT 17
73904: PUSH
73905: LD_INT 24
73907: PUSH
73908: LD_INT 21
73910: PUSH
73911: LD_INT 19
73913: PUSH
73914: LD_INT 16
73916: PUSH
73917: LD_INT 25
73919: PUSH
73920: LD_INT 18
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: IN
73935: ST_TO_ADDR
// end ;
73936: LD_VAR 0 2
73940: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
73941: LD_INT 0
73943: PPUSH
73944: PPUSH
73945: PPUSH
// result := [ ] ;
73946: LD_ADDR_VAR 0 3
73950: PUSH
73951: EMPTY
73952: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73953: LD_ADDR_VAR 0 4
73957: PUSH
73958: LD_VAR 0 2
73962: PPUSH
73963: LD_INT 21
73965: PUSH
73966: LD_INT 3
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PPUSH
73973: CALL_OW 70
73977: ST_TO_ADDR
// if not tmp then
73978: LD_VAR 0 4
73982: NOT
73983: IFFALSE 73987
// exit ;
73985: GO 74045
// for i in tmp do
73987: LD_ADDR_VAR 0 5
73991: PUSH
73992: LD_VAR 0 4
73996: PUSH
73997: FOR_IN
73998: IFFALSE 74033
// if GetBase ( i ) <> base then
74000: LD_VAR 0 5
74004: PPUSH
74005: CALL_OW 274
74009: PUSH
74010: LD_VAR 0 1
74014: NONEQUAL
74015: IFFALSE 74031
// ComLinkToBase ( base , i ) ;
74017: LD_VAR 0 1
74021: PPUSH
74022: LD_VAR 0 5
74026: PPUSH
74027: CALL_OW 169
74031: GO 73997
74033: POP
74034: POP
// result := tmp ;
74035: LD_ADDR_VAR 0 3
74039: PUSH
74040: LD_VAR 0 4
74044: ST_TO_ADDR
// end ;
74045: LD_VAR 0 3
74049: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74050: LD_INT 0
74052: PPUSH
74053: PPUSH
// if BuildingStatus ( b ) = bs_build then
74054: LD_VAR 0 2
74058: PPUSH
74059: CALL_OW 461
74063: PUSH
74064: LD_INT 1
74066: EQUAL
74067: IFFALSE 74127
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74069: LD_VAR 0 1
74073: PPUSH
74074: LD_STRING h
74076: PUSH
74077: LD_VAR 0 2
74081: PPUSH
74082: CALL_OW 250
74086: PUSH
74087: LD_VAR 0 2
74091: PPUSH
74092: CALL_OW 251
74096: PUSH
74097: LD_VAR 0 2
74101: PUSH
74102: LD_INT 0
74104: PUSH
74105: LD_INT 0
74107: PUSH
74108: LD_INT 0
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: LIST
74115: LIST
74116: LIST
74117: LIST
74118: LIST
74119: PUSH
74120: EMPTY
74121: LIST
74122: PPUSH
74123: CALL_OW 446
// end ;
74127: LD_VAR 0 3
74131: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74132: LD_INT 0
74134: PPUSH
74135: PPUSH
74136: PPUSH
74137: PPUSH
74138: PPUSH
74139: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74140: LD_VAR 0 1
74144: NOT
74145: PUSH
74146: LD_VAR 0 1
74150: PPUSH
74151: CALL_OW 263
74155: PUSH
74156: LD_INT 2
74158: EQUAL
74159: NOT
74160: OR
74161: IFFALSE 74165
// exit ;
74163: GO 74481
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74165: LD_ADDR_VAR 0 6
74169: PUSH
74170: LD_INT 22
74172: PUSH
74173: LD_VAR 0 1
74177: PPUSH
74178: CALL_OW 255
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 2
74189: PUSH
74190: LD_INT 30
74192: PUSH
74193: LD_INT 36
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 34
74202: PUSH
74203: LD_INT 31
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: LIST
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PPUSH
74219: CALL_OW 69
74223: ST_TO_ADDR
// if not tmp then
74224: LD_VAR 0 6
74228: NOT
74229: IFFALSE 74233
// exit ;
74231: GO 74481
// result := [ ] ;
74233: LD_ADDR_VAR 0 2
74237: PUSH
74238: EMPTY
74239: ST_TO_ADDR
// for i in tmp do
74240: LD_ADDR_VAR 0 3
74244: PUSH
74245: LD_VAR 0 6
74249: PUSH
74250: FOR_IN
74251: IFFALSE 74322
// begin t := UnitsInside ( i ) ;
74253: LD_ADDR_VAR 0 4
74257: PUSH
74258: LD_VAR 0 3
74262: PPUSH
74263: CALL_OW 313
74267: ST_TO_ADDR
// if t then
74268: LD_VAR 0 4
74272: IFFALSE 74320
// for j in t do
74274: LD_ADDR_VAR 0 7
74278: PUSH
74279: LD_VAR 0 4
74283: PUSH
74284: FOR_IN
74285: IFFALSE 74318
// result := Insert ( result , result + 1 , j ) ;
74287: LD_ADDR_VAR 0 2
74291: PUSH
74292: LD_VAR 0 2
74296: PPUSH
74297: LD_VAR 0 2
74301: PUSH
74302: LD_INT 1
74304: PLUS
74305: PPUSH
74306: LD_VAR 0 7
74310: PPUSH
74311: CALL_OW 2
74315: ST_TO_ADDR
74316: GO 74284
74318: POP
74319: POP
// end ;
74320: GO 74250
74322: POP
74323: POP
// if not result then
74324: LD_VAR 0 2
74328: NOT
74329: IFFALSE 74333
// exit ;
74331: GO 74481
// mech := result [ 1 ] ;
74333: LD_ADDR_VAR 0 5
74337: PUSH
74338: LD_VAR 0 2
74342: PUSH
74343: LD_INT 1
74345: ARRAY
74346: ST_TO_ADDR
// if result > 1 then
74347: LD_VAR 0 2
74351: PUSH
74352: LD_INT 1
74354: GREATER
74355: IFFALSE 74467
// for i = 2 to result do
74357: LD_ADDR_VAR 0 3
74361: PUSH
74362: DOUBLE
74363: LD_INT 2
74365: DEC
74366: ST_TO_ADDR
74367: LD_VAR 0 2
74371: PUSH
74372: FOR_TO
74373: IFFALSE 74465
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74375: LD_ADDR_VAR 0 4
74379: PUSH
74380: LD_VAR 0 2
74384: PUSH
74385: LD_VAR 0 3
74389: ARRAY
74390: PPUSH
74391: LD_INT 3
74393: PPUSH
74394: CALL_OW 259
74398: PUSH
74399: LD_VAR 0 2
74403: PUSH
74404: LD_VAR 0 3
74408: ARRAY
74409: PPUSH
74410: CALL_OW 432
74414: MINUS
74415: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74416: LD_VAR 0 4
74420: PUSH
74421: LD_VAR 0 5
74425: PPUSH
74426: LD_INT 3
74428: PPUSH
74429: CALL_OW 259
74433: PUSH
74434: LD_VAR 0 5
74438: PPUSH
74439: CALL_OW 432
74443: MINUS
74444: GREATEREQUAL
74445: IFFALSE 74463
// mech := result [ i ] ;
74447: LD_ADDR_VAR 0 5
74451: PUSH
74452: LD_VAR 0 2
74456: PUSH
74457: LD_VAR 0 3
74461: ARRAY
74462: ST_TO_ADDR
// end ;
74463: GO 74372
74465: POP
74466: POP
// ComLinkTo ( vehicle , mech ) ;
74467: LD_VAR 0 1
74471: PPUSH
74472: LD_VAR 0 5
74476: PPUSH
74477: CALL_OW 135
// end ;
74481: LD_VAR 0 2
74485: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74486: LD_INT 0
74488: PPUSH
74489: PPUSH
74490: PPUSH
74491: PPUSH
74492: PPUSH
74493: PPUSH
74494: PPUSH
74495: PPUSH
74496: PPUSH
74497: PPUSH
74498: PPUSH
74499: PPUSH
74500: PPUSH
// result := [ ] ;
74501: LD_ADDR_VAR 0 7
74505: PUSH
74506: EMPTY
74507: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74508: LD_VAR 0 1
74512: PPUSH
74513: CALL_OW 266
74517: PUSH
74518: LD_INT 0
74520: PUSH
74521: LD_INT 1
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: IN
74528: NOT
74529: IFFALSE 74533
// exit ;
74531: GO 76164
// if name then
74533: LD_VAR 0 3
74537: IFFALSE 74553
// SetBName ( base_dep , name ) ;
74539: LD_VAR 0 1
74543: PPUSH
74544: LD_VAR 0 3
74548: PPUSH
74549: CALL_OW 500
// base := GetBase ( base_dep ) ;
74553: LD_ADDR_VAR 0 15
74557: PUSH
74558: LD_VAR 0 1
74562: PPUSH
74563: CALL_OW 274
74567: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74568: LD_ADDR_VAR 0 16
74572: PUSH
74573: LD_VAR 0 1
74577: PPUSH
74578: CALL_OW 255
74582: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74583: LD_ADDR_VAR 0 17
74587: PUSH
74588: LD_VAR 0 1
74592: PPUSH
74593: CALL_OW 248
74597: ST_TO_ADDR
// if sources then
74598: LD_VAR 0 5
74602: IFFALSE 74649
// for i = 1 to 3 do
74604: LD_ADDR_VAR 0 8
74608: PUSH
74609: DOUBLE
74610: LD_INT 1
74612: DEC
74613: ST_TO_ADDR
74614: LD_INT 3
74616: PUSH
74617: FOR_TO
74618: IFFALSE 74647
// AddResourceType ( base , i , sources [ i ] ) ;
74620: LD_VAR 0 15
74624: PPUSH
74625: LD_VAR 0 8
74629: PPUSH
74630: LD_VAR 0 5
74634: PUSH
74635: LD_VAR 0 8
74639: ARRAY
74640: PPUSH
74641: CALL_OW 276
74645: GO 74617
74647: POP
74648: POP
// buildings := GetBaseBuildings ( base , area ) ;
74649: LD_ADDR_VAR 0 18
74653: PUSH
74654: LD_VAR 0 15
74658: PPUSH
74659: LD_VAR 0 2
74663: PPUSH
74664: CALL 73941 0 2
74668: ST_TO_ADDR
// InitHc ;
74669: CALL_OW 19
// InitUc ;
74673: CALL_OW 18
// uc_side := side ;
74677: LD_ADDR_OWVAR 20
74681: PUSH
74682: LD_VAR 0 16
74686: ST_TO_ADDR
// uc_nation := nation ;
74687: LD_ADDR_OWVAR 21
74691: PUSH
74692: LD_VAR 0 17
74696: ST_TO_ADDR
// if buildings then
74697: LD_VAR 0 18
74701: IFFALSE 76023
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74703: LD_ADDR_VAR 0 19
74707: PUSH
74708: LD_VAR 0 18
74712: PPUSH
74713: LD_INT 2
74715: PUSH
74716: LD_INT 30
74718: PUSH
74719: LD_INT 29
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: LD_INT 30
74728: PUSH
74729: LD_INT 30
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: LIST
74740: PPUSH
74741: CALL_OW 72
74745: ST_TO_ADDR
// if tmp then
74746: LD_VAR 0 19
74750: IFFALSE 74798
// for i in tmp do
74752: LD_ADDR_VAR 0 8
74756: PUSH
74757: LD_VAR 0 19
74761: PUSH
74762: FOR_IN
74763: IFFALSE 74796
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74765: LD_VAR 0 8
74769: PPUSH
74770: CALL_OW 250
74774: PPUSH
74775: LD_VAR 0 8
74779: PPUSH
74780: CALL_OW 251
74784: PPUSH
74785: LD_VAR 0 16
74789: PPUSH
74790: CALL_OW 441
74794: GO 74762
74796: POP
74797: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74798: LD_VAR 0 18
74802: PPUSH
74803: LD_INT 2
74805: PUSH
74806: LD_INT 30
74808: PUSH
74809: LD_INT 32
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 30
74818: PUSH
74819: LD_INT 33
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: LIST
74830: PPUSH
74831: CALL_OW 72
74835: IFFALSE 74923
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74837: LD_ADDR_VAR 0 8
74841: PUSH
74842: LD_VAR 0 18
74846: PPUSH
74847: LD_INT 2
74849: PUSH
74850: LD_INT 30
74852: PUSH
74853: LD_INT 32
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: PUSH
74860: LD_INT 30
74862: PUSH
74863: LD_INT 33
74865: PUSH
74866: EMPTY
74867: LIST
74868: LIST
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: LIST
74874: PPUSH
74875: CALL_OW 72
74879: PUSH
74880: FOR_IN
74881: IFFALSE 74921
// begin if not GetBWeapon ( i ) then
74883: LD_VAR 0 8
74887: PPUSH
74888: CALL_OW 269
74892: NOT
74893: IFFALSE 74919
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74895: LD_VAR 0 8
74899: PPUSH
74900: LD_VAR 0 8
74904: PPUSH
74905: LD_VAR 0 2
74909: PPUSH
74910: CALL 76169 0 2
74914: PPUSH
74915: CALL_OW 431
// end ;
74919: GO 74880
74921: POP
74922: POP
// end ; for i = 1 to personel do
74923: LD_ADDR_VAR 0 8
74927: PUSH
74928: DOUBLE
74929: LD_INT 1
74931: DEC
74932: ST_TO_ADDR
74933: LD_VAR 0 6
74937: PUSH
74938: FOR_TO
74939: IFFALSE 76003
// begin if i > 4 then
74941: LD_VAR 0 8
74945: PUSH
74946: LD_INT 4
74948: GREATER
74949: IFFALSE 74953
// break ;
74951: GO 76003
// case i of 1 :
74953: LD_VAR 0 8
74957: PUSH
74958: LD_INT 1
74960: DOUBLE
74961: EQUAL
74962: IFTRUE 74966
74964: GO 75046
74966: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74967: LD_ADDR_VAR 0 12
74971: PUSH
74972: LD_VAR 0 18
74976: PPUSH
74977: LD_INT 22
74979: PUSH
74980: LD_VAR 0 16
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 58
74991: PUSH
74992: EMPTY
74993: LIST
74994: PUSH
74995: LD_INT 2
74997: PUSH
74998: LD_INT 30
75000: PUSH
75001: LD_INT 32
75003: PUSH
75004: EMPTY
75005: LIST
75006: LIST
75007: PUSH
75008: LD_INT 30
75010: PUSH
75011: LD_INT 4
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: LD_INT 30
75020: PUSH
75021: LD_INT 5
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: LIST
75038: PPUSH
75039: CALL_OW 72
75043: ST_TO_ADDR
75044: GO 75268
75046: LD_INT 2
75048: DOUBLE
75049: EQUAL
75050: IFTRUE 75054
75052: GO 75116
75054: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75055: LD_ADDR_VAR 0 12
75059: PUSH
75060: LD_VAR 0 18
75064: PPUSH
75065: LD_INT 22
75067: PUSH
75068: LD_VAR 0 16
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 2
75079: PUSH
75080: LD_INT 30
75082: PUSH
75083: LD_INT 0
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 30
75092: PUSH
75093: LD_INT 1
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: LIST
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: PPUSH
75109: CALL_OW 72
75113: ST_TO_ADDR
75114: GO 75268
75116: LD_INT 3
75118: DOUBLE
75119: EQUAL
75120: IFTRUE 75124
75122: GO 75186
75124: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75125: LD_ADDR_VAR 0 12
75129: PUSH
75130: LD_VAR 0 18
75134: PPUSH
75135: LD_INT 22
75137: PUSH
75138: LD_VAR 0 16
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: PUSH
75147: LD_INT 2
75149: PUSH
75150: LD_INT 30
75152: PUSH
75153: LD_INT 2
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 30
75162: PUSH
75163: LD_INT 3
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: LIST
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PPUSH
75179: CALL_OW 72
75183: ST_TO_ADDR
75184: GO 75268
75186: LD_INT 4
75188: DOUBLE
75189: EQUAL
75190: IFTRUE 75194
75192: GO 75267
75194: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75195: LD_ADDR_VAR 0 12
75199: PUSH
75200: LD_VAR 0 18
75204: PPUSH
75205: LD_INT 22
75207: PUSH
75208: LD_VAR 0 16
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: PUSH
75217: LD_INT 2
75219: PUSH
75220: LD_INT 30
75222: PUSH
75223: LD_INT 6
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: LD_INT 30
75232: PUSH
75233: LD_INT 7
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 30
75242: PUSH
75243: LD_INT 8
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: LIST
75254: LIST
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PPUSH
75260: CALL_OW 72
75264: ST_TO_ADDR
75265: GO 75268
75267: POP
// if i = 1 then
75268: LD_VAR 0 8
75272: PUSH
75273: LD_INT 1
75275: EQUAL
75276: IFFALSE 75387
// begin tmp := [ ] ;
75278: LD_ADDR_VAR 0 19
75282: PUSH
75283: EMPTY
75284: ST_TO_ADDR
// for j in f do
75285: LD_ADDR_VAR 0 9
75289: PUSH
75290: LD_VAR 0 12
75294: PUSH
75295: FOR_IN
75296: IFFALSE 75369
// if GetBType ( j ) = b_bunker then
75298: LD_VAR 0 9
75302: PPUSH
75303: CALL_OW 266
75307: PUSH
75308: LD_INT 32
75310: EQUAL
75311: IFFALSE 75338
// tmp := Insert ( tmp , 1 , j ) else
75313: LD_ADDR_VAR 0 19
75317: PUSH
75318: LD_VAR 0 19
75322: PPUSH
75323: LD_INT 1
75325: PPUSH
75326: LD_VAR 0 9
75330: PPUSH
75331: CALL_OW 2
75335: ST_TO_ADDR
75336: GO 75367
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75338: LD_ADDR_VAR 0 19
75342: PUSH
75343: LD_VAR 0 19
75347: PPUSH
75348: LD_VAR 0 19
75352: PUSH
75353: LD_INT 1
75355: PLUS
75356: PPUSH
75357: LD_VAR 0 9
75361: PPUSH
75362: CALL_OW 2
75366: ST_TO_ADDR
75367: GO 75295
75369: POP
75370: POP
// if tmp then
75371: LD_VAR 0 19
75375: IFFALSE 75387
// f := tmp ;
75377: LD_ADDR_VAR 0 12
75381: PUSH
75382: LD_VAR 0 19
75386: ST_TO_ADDR
// end ; x := personel [ i ] ;
75387: LD_ADDR_VAR 0 13
75391: PUSH
75392: LD_VAR 0 6
75396: PUSH
75397: LD_VAR 0 8
75401: ARRAY
75402: ST_TO_ADDR
// if x = - 1 then
75403: LD_VAR 0 13
75407: PUSH
75408: LD_INT 1
75410: NEG
75411: EQUAL
75412: IFFALSE 75621
// begin for j in f do
75414: LD_ADDR_VAR 0 9
75418: PUSH
75419: LD_VAR 0 12
75423: PUSH
75424: FOR_IN
75425: IFFALSE 75617
// repeat InitHc ;
75427: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75431: LD_VAR 0 9
75435: PPUSH
75436: CALL_OW 266
75440: PUSH
75441: LD_INT 5
75443: EQUAL
75444: IFFALSE 75514
// begin if UnitsInside ( j ) < 3 then
75446: LD_VAR 0 9
75450: PPUSH
75451: CALL_OW 313
75455: PUSH
75456: LD_INT 3
75458: LESS
75459: IFFALSE 75495
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75461: LD_INT 0
75463: PPUSH
75464: LD_INT 5
75466: PUSH
75467: LD_INT 8
75469: PUSH
75470: LD_INT 9
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: LIST
75477: PUSH
75478: LD_VAR 0 17
75482: ARRAY
75483: PPUSH
75484: LD_VAR 0 4
75488: PPUSH
75489: CALL_OW 380
75493: GO 75512
// PrepareHuman ( false , i , skill ) ;
75495: LD_INT 0
75497: PPUSH
75498: LD_VAR 0 8
75502: PPUSH
75503: LD_VAR 0 4
75507: PPUSH
75508: CALL_OW 380
// end else
75512: GO 75531
// PrepareHuman ( false , i , skill ) ;
75514: LD_INT 0
75516: PPUSH
75517: LD_VAR 0 8
75521: PPUSH
75522: LD_VAR 0 4
75526: PPUSH
75527: CALL_OW 380
// un := CreateHuman ;
75531: LD_ADDR_VAR 0 14
75535: PUSH
75536: CALL_OW 44
75540: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75541: LD_ADDR_VAR 0 7
75545: PUSH
75546: LD_VAR 0 7
75550: PPUSH
75551: LD_INT 1
75553: PPUSH
75554: LD_VAR 0 14
75558: PPUSH
75559: CALL_OW 2
75563: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75564: LD_VAR 0 14
75568: PPUSH
75569: LD_VAR 0 9
75573: PPUSH
75574: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75578: LD_VAR 0 9
75582: PPUSH
75583: CALL_OW 313
75587: PUSH
75588: LD_INT 6
75590: EQUAL
75591: PUSH
75592: LD_VAR 0 9
75596: PPUSH
75597: CALL_OW 266
75601: PUSH
75602: LD_INT 32
75604: PUSH
75605: LD_INT 31
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: IN
75612: OR
75613: IFFALSE 75427
75615: GO 75424
75617: POP
75618: POP
// end else
75619: GO 76001
// for j = 1 to x do
75621: LD_ADDR_VAR 0 9
75625: PUSH
75626: DOUBLE
75627: LD_INT 1
75629: DEC
75630: ST_TO_ADDR
75631: LD_VAR 0 13
75635: PUSH
75636: FOR_TO
75637: IFFALSE 75999
// begin InitHc ;
75639: CALL_OW 19
// if not f then
75643: LD_VAR 0 12
75647: NOT
75648: IFFALSE 75737
// begin PrepareHuman ( false , i , skill ) ;
75650: LD_INT 0
75652: PPUSH
75653: LD_VAR 0 8
75657: PPUSH
75658: LD_VAR 0 4
75662: PPUSH
75663: CALL_OW 380
// un := CreateHuman ;
75667: LD_ADDR_VAR 0 14
75671: PUSH
75672: CALL_OW 44
75676: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75677: LD_ADDR_VAR 0 7
75681: PUSH
75682: LD_VAR 0 7
75686: PPUSH
75687: LD_INT 1
75689: PPUSH
75690: LD_VAR 0 14
75694: PPUSH
75695: CALL_OW 2
75699: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75700: LD_VAR 0 14
75704: PPUSH
75705: LD_VAR 0 1
75709: PPUSH
75710: CALL_OW 250
75714: PPUSH
75715: LD_VAR 0 1
75719: PPUSH
75720: CALL_OW 251
75724: PPUSH
75725: LD_INT 10
75727: PPUSH
75728: LD_INT 0
75730: PPUSH
75731: CALL_OW 50
// continue ;
75735: GO 75636
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75737: LD_VAR 0 12
75741: PUSH
75742: LD_INT 1
75744: ARRAY
75745: PPUSH
75746: CALL_OW 313
75750: PUSH
75751: LD_VAR 0 12
75755: PUSH
75756: LD_INT 1
75758: ARRAY
75759: PPUSH
75760: CALL_OW 266
75764: PUSH
75765: LD_INT 32
75767: PUSH
75768: LD_INT 31
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: IN
75775: AND
75776: PUSH
75777: LD_VAR 0 12
75781: PUSH
75782: LD_INT 1
75784: ARRAY
75785: PPUSH
75786: CALL_OW 313
75790: PUSH
75791: LD_INT 6
75793: EQUAL
75794: OR
75795: IFFALSE 75815
// f := Delete ( f , 1 ) ;
75797: LD_ADDR_VAR 0 12
75801: PUSH
75802: LD_VAR 0 12
75806: PPUSH
75807: LD_INT 1
75809: PPUSH
75810: CALL_OW 3
75814: ST_TO_ADDR
// if not f then
75815: LD_VAR 0 12
75819: NOT
75820: IFFALSE 75838
// begin x := x + 2 ;
75822: LD_ADDR_VAR 0 13
75826: PUSH
75827: LD_VAR 0 13
75831: PUSH
75832: LD_INT 2
75834: PLUS
75835: ST_TO_ADDR
// continue ;
75836: GO 75636
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75838: LD_VAR 0 12
75842: PUSH
75843: LD_INT 1
75845: ARRAY
75846: PPUSH
75847: CALL_OW 266
75851: PUSH
75852: LD_INT 5
75854: EQUAL
75855: IFFALSE 75929
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75857: LD_VAR 0 12
75861: PUSH
75862: LD_INT 1
75864: ARRAY
75865: PPUSH
75866: CALL_OW 313
75870: PUSH
75871: LD_INT 3
75873: LESS
75874: IFFALSE 75910
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75876: LD_INT 0
75878: PPUSH
75879: LD_INT 5
75881: PUSH
75882: LD_INT 8
75884: PUSH
75885: LD_INT 9
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: LIST
75892: PUSH
75893: LD_VAR 0 17
75897: ARRAY
75898: PPUSH
75899: LD_VAR 0 4
75903: PPUSH
75904: CALL_OW 380
75908: GO 75927
// PrepareHuman ( false , i , skill ) ;
75910: LD_INT 0
75912: PPUSH
75913: LD_VAR 0 8
75917: PPUSH
75918: LD_VAR 0 4
75922: PPUSH
75923: CALL_OW 380
// end else
75927: GO 75946
// PrepareHuman ( false , i , skill ) ;
75929: LD_INT 0
75931: PPUSH
75932: LD_VAR 0 8
75936: PPUSH
75937: LD_VAR 0 4
75941: PPUSH
75942: CALL_OW 380
// un := CreateHuman ;
75946: LD_ADDR_VAR 0 14
75950: PUSH
75951: CALL_OW 44
75955: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75956: LD_ADDR_VAR 0 7
75960: PUSH
75961: LD_VAR 0 7
75965: PPUSH
75966: LD_INT 1
75968: PPUSH
75969: LD_VAR 0 14
75973: PPUSH
75974: CALL_OW 2
75978: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75979: LD_VAR 0 14
75983: PPUSH
75984: LD_VAR 0 12
75988: PUSH
75989: LD_INT 1
75991: ARRAY
75992: PPUSH
75993: CALL_OW 52
// end ;
75997: GO 75636
75999: POP
76000: POP
// end ;
76001: GO 74938
76003: POP
76004: POP
// result := result ^ buildings ;
76005: LD_ADDR_VAR 0 7
76009: PUSH
76010: LD_VAR 0 7
76014: PUSH
76015: LD_VAR 0 18
76019: ADD
76020: ST_TO_ADDR
// end else
76021: GO 76164
// begin for i = 1 to personel do
76023: LD_ADDR_VAR 0 8
76027: PUSH
76028: DOUBLE
76029: LD_INT 1
76031: DEC
76032: ST_TO_ADDR
76033: LD_VAR 0 6
76037: PUSH
76038: FOR_TO
76039: IFFALSE 76162
// begin if i > 4 then
76041: LD_VAR 0 8
76045: PUSH
76046: LD_INT 4
76048: GREATER
76049: IFFALSE 76053
// break ;
76051: GO 76162
// x := personel [ i ] ;
76053: LD_ADDR_VAR 0 13
76057: PUSH
76058: LD_VAR 0 6
76062: PUSH
76063: LD_VAR 0 8
76067: ARRAY
76068: ST_TO_ADDR
// if x = - 1 then
76069: LD_VAR 0 13
76073: PUSH
76074: LD_INT 1
76076: NEG
76077: EQUAL
76078: IFFALSE 76082
// continue ;
76080: GO 76038
// PrepareHuman ( false , i , skill ) ;
76082: LD_INT 0
76084: PPUSH
76085: LD_VAR 0 8
76089: PPUSH
76090: LD_VAR 0 4
76094: PPUSH
76095: CALL_OW 380
// un := CreateHuman ;
76099: LD_ADDR_VAR 0 14
76103: PUSH
76104: CALL_OW 44
76108: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76109: LD_VAR 0 14
76113: PPUSH
76114: LD_VAR 0 1
76118: PPUSH
76119: CALL_OW 250
76123: PPUSH
76124: LD_VAR 0 1
76128: PPUSH
76129: CALL_OW 251
76133: PPUSH
76134: LD_INT 10
76136: PPUSH
76137: LD_INT 0
76139: PPUSH
76140: CALL_OW 50
// result := result ^ un ;
76144: LD_ADDR_VAR 0 7
76148: PUSH
76149: LD_VAR 0 7
76153: PUSH
76154: LD_VAR 0 14
76158: ADD
76159: ST_TO_ADDR
// end ;
76160: GO 76038
76162: POP
76163: POP
// end ; end ;
76164: LD_VAR 0 7
76168: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76169: LD_INT 0
76171: PPUSH
76172: PPUSH
76173: PPUSH
76174: PPUSH
76175: PPUSH
76176: PPUSH
76177: PPUSH
76178: PPUSH
76179: PPUSH
76180: PPUSH
76181: PPUSH
76182: PPUSH
76183: PPUSH
76184: PPUSH
76185: PPUSH
76186: PPUSH
// result := false ;
76187: LD_ADDR_VAR 0 3
76191: PUSH
76192: LD_INT 0
76194: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76195: LD_VAR 0 1
76199: NOT
76200: PUSH
76201: LD_VAR 0 1
76205: PPUSH
76206: CALL_OW 266
76210: PUSH
76211: LD_INT 32
76213: PUSH
76214: LD_INT 33
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: IN
76221: NOT
76222: OR
76223: IFFALSE 76227
// exit ;
76225: GO 77363
// nat := GetNation ( tower ) ;
76227: LD_ADDR_VAR 0 12
76231: PUSH
76232: LD_VAR 0 1
76236: PPUSH
76237: CALL_OW 248
76241: ST_TO_ADDR
// side := GetSide ( tower ) ;
76242: LD_ADDR_VAR 0 16
76246: PUSH
76247: LD_VAR 0 1
76251: PPUSH
76252: CALL_OW 255
76256: ST_TO_ADDR
// x := GetX ( tower ) ;
76257: LD_ADDR_VAR 0 10
76261: PUSH
76262: LD_VAR 0 1
76266: PPUSH
76267: CALL_OW 250
76271: ST_TO_ADDR
// y := GetY ( tower ) ;
76272: LD_ADDR_VAR 0 11
76276: PUSH
76277: LD_VAR 0 1
76281: PPUSH
76282: CALL_OW 251
76286: ST_TO_ADDR
// if not x or not y then
76287: LD_VAR 0 10
76291: NOT
76292: PUSH
76293: LD_VAR 0 11
76297: NOT
76298: OR
76299: IFFALSE 76303
// exit ;
76301: GO 77363
// weapon := 0 ;
76303: LD_ADDR_VAR 0 18
76307: PUSH
76308: LD_INT 0
76310: ST_TO_ADDR
// fac_list := [ ] ;
76311: LD_ADDR_VAR 0 17
76315: PUSH
76316: EMPTY
76317: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76318: LD_ADDR_VAR 0 6
76322: PUSH
76323: LD_VAR 0 1
76327: PPUSH
76328: CALL_OW 274
76332: PPUSH
76333: LD_VAR 0 2
76337: PPUSH
76338: CALL 73941 0 2
76342: PPUSH
76343: LD_INT 30
76345: PUSH
76346: LD_INT 3
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PPUSH
76353: CALL_OW 72
76357: ST_TO_ADDR
// if not factories then
76358: LD_VAR 0 6
76362: NOT
76363: IFFALSE 76367
// exit ;
76365: GO 77363
// for i in factories do
76367: LD_ADDR_VAR 0 8
76371: PUSH
76372: LD_VAR 0 6
76376: PUSH
76377: FOR_IN
76378: IFFALSE 76403
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76380: LD_ADDR_VAR 0 17
76384: PUSH
76385: LD_VAR 0 17
76389: PUSH
76390: LD_VAR 0 8
76394: PPUSH
76395: CALL_OW 478
76399: UNION
76400: ST_TO_ADDR
76401: GO 76377
76403: POP
76404: POP
// if not fac_list then
76405: LD_VAR 0 17
76409: NOT
76410: IFFALSE 76414
// exit ;
76412: GO 77363
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76414: LD_ADDR_VAR 0 5
76418: PUSH
76419: LD_INT 4
76421: PUSH
76422: LD_INT 5
76424: PUSH
76425: LD_INT 9
76427: PUSH
76428: LD_INT 10
76430: PUSH
76431: LD_INT 6
76433: PUSH
76434: LD_INT 7
76436: PUSH
76437: LD_INT 11
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 27
76451: PUSH
76452: LD_INT 28
76454: PUSH
76455: LD_INT 26
76457: PUSH
76458: LD_INT 30
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 43
76469: PUSH
76470: LD_INT 44
76472: PUSH
76473: LD_INT 46
76475: PUSH
76476: LD_INT 45
76478: PUSH
76479: LD_INT 47
76481: PUSH
76482: LD_INT 49
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: LIST
76497: PUSH
76498: LD_VAR 0 12
76502: ARRAY
76503: ST_TO_ADDR
// for i in list do
76504: LD_ADDR_VAR 0 8
76508: PUSH
76509: LD_VAR 0 5
76513: PUSH
76514: FOR_IN
76515: IFFALSE 76548
// if not i in fac_list then
76517: LD_VAR 0 8
76521: PUSH
76522: LD_VAR 0 17
76526: IN
76527: NOT
76528: IFFALSE 76546
// list := list diff i ;
76530: LD_ADDR_VAR 0 5
76534: PUSH
76535: LD_VAR 0 5
76539: PUSH
76540: LD_VAR 0 8
76544: DIFF
76545: ST_TO_ADDR
76546: GO 76514
76548: POP
76549: POP
// if not list then
76550: LD_VAR 0 5
76554: NOT
76555: IFFALSE 76559
// exit ;
76557: GO 77363
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76559: LD_VAR 0 12
76563: PUSH
76564: LD_INT 3
76566: EQUAL
76567: PUSH
76568: LD_INT 49
76570: PUSH
76571: LD_VAR 0 5
76575: IN
76576: AND
76577: PUSH
76578: LD_INT 31
76580: PPUSH
76581: LD_VAR 0 16
76585: PPUSH
76586: CALL_OW 321
76590: PUSH
76591: LD_INT 2
76593: EQUAL
76594: AND
76595: IFFALSE 76655
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76597: LD_INT 22
76599: PUSH
76600: LD_VAR 0 16
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 35
76611: PUSH
76612: LD_INT 49
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: LD_INT 91
76621: PUSH
76622: LD_VAR 0 1
76626: PUSH
76627: LD_INT 10
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: LIST
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: LIST
76639: PPUSH
76640: CALL_OW 69
76644: NOT
76645: IFFALSE 76655
// weapon := ru_time_lapser ;
76647: LD_ADDR_VAR 0 18
76651: PUSH
76652: LD_INT 49
76654: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76655: LD_VAR 0 12
76659: PUSH
76660: LD_INT 1
76662: PUSH
76663: LD_INT 2
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: IN
76670: PUSH
76671: LD_INT 11
76673: PUSH
76674: LD_VAR 0 5
76678: IN
76679: PUSH
76680: LD_INT 30
76682: PUSH
76683: LD_VAR 0 5
76687: IN
76688: OR
76689: AND
76690: PUSH
76691: LD_INT 6
76693: PPUSH
76694: LD_VAR 0 16
76698: PPUSH
76699: CALL_OW 321
76703: PUSH
76704: LD_INT 2
76706: EQUAL
76707: AND
76708: IFFALSE 76873
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76710: LD_INT 22
76712: PUSH
76713: LD_VAR 0 16
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 2
76724: PUSH
76725: LD_INT 35
76727: PUSH
76728: LD_INT 11
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 35
76737: PUSH
76738: LD_INT 30
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 91
76752: PUSH
76753: LD_VAR 0 1
76757: PUSH
76758: LD_INT 18
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: LIST
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: LIST
76770: PPUSH
76771: CALL_OW 69
76775: NOT
76776: PUSH
76777: LD_INT 22
76779: PUSH
76780: LD_VAR 0 16
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: PUSH
76789: LD_INT 2
76791: PUSH
76792: LD_INT 30
76794: PUSH
76795: LD_INT 32
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: PUSH
76802: LD_INT 30
76804: PUSH
76805: LD_INT 33
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: LIST
76816: PUSH
76817: LD_INT 91
76819: PUSH
76820: LD_VAR 0 1
76824: PUSH
76825: LD_INT 12
76827: PUSH
76828: EMPTY
76829: LIST
76830: LIST
76831: LIST
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: LIST
76837: PUSH
76838: EMPTY
76839: LIST
76840: PPUSH
76841: CALL_OW 69
76845: PUSH
76846: LD_INT 2
76848: GREATER
76849: AND
76850: IFFALSE 76873
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76852: LD_ADDR_VAR 0 18
76856: PUSH
76857: LD_INT 11
76859: PUSH
76860: LD_INT 30
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_VAR 0 12
76871: ARRAY
76872: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76873: LD_VAR 0 18
76877: NOT
76878: PUSH
76879: LD_INT 40
76881: PPUSH
76882: LD_VAR 0 16
76886: PPUSH
76887: CALL_OW 321
76891: PUSH
76892: LD_INT 2
76894: EQUAL
76895: AND
76896: PUSH
76897: LD_INT 7
76899: PUSH
76900: LD_VAR 0 5
76904: IN
76905: PUSH
76906: LD_INT 28
76908: PUSH
76909: LD_VAR 0 5
76913: IN
76914: OR
76915: PUSH
76916: LD_INT 45
76918: PUSH
76919: LD_VAR 0 5
76923: IN
76924: OR
76925: AND
76926: IFFALSE 77180
// begin hex := GetHexInfo ( x , y ) ;
76928: LD_ADDR_VAR 0 4
76932: PUSH
76933: LD_VAR 0 10
76937: PPUSH
76938: LD_VAR 0 11
76942: PPUSH
76943: CALL_OW 546
76947: ST_TO_ADDR
// if hex [ 1 ] then
76948: LD_VAR 0 4
76952: PUSH
76953: LD_INT 1
76955: ARRAY
76956: IFFALSE 76960
// exit ;
76958: GO 77363
// height := hex [ 2 ] ;
76960: LD_ADDR_VAR 0 15
76964: PUSH
76965: LD_VAR 0 4
76969: PUSH
76970: LD_INT 2
76972: ARRAY
76973: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76974: LD_ADDR_VAR 0 14
76978: PUSH
76979: LD_INT 0
76981: PUSH
76982: LD_INT 2
76984: PUSH
76985: LD_INT 3
76987: PUSH
76988: LD_INT 5
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: LIST
76995: LIST
76996: ST_TO_ADDR
// for i in tmp do
76997: LD_ADDR_VAR 0 8
77001: PUSH
77002: LD_VAR 0 14
77006: PUSH
77007: FOR_IN
77008: IFFALSE 77178
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77010: LD_ADDR_VAR 0 9
77014: PUSH
77015: LD_VAR 0 10
77019: PPUSH
77020: LD_VAR 0 8
77024: PPUSH
77025: LD_INT 5
77027: PPUSH
77028: CALL_OW 272
77032: PUSH
77033: LD_VAR 0 11
77037: PPUSH
77038: LD_VAR 0 8
77042: PPUSH
77043: LD_INT 5
77045: PPUSH
77046: CALL_OW 273
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77055: LD_VAR 0 9
77059: PUSH
77060: LD_INT 1
77062: ARRAY
77063: PPUSH
77064: LD_VAR 0 9
77068: PUSH
77069: LD_INT 2
77071: ARRAY
77072: PPUSH
77073: CALL_OW 488
77077: IFFALSE 77176
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77079: LD_ADDR_VAR 0 4
77083: PUSH
77084: LD_VAR 0 9
77088: PUSH
77089: LD_INT 1
77091: ARRAY
77092: PPUSH
77093: LD_VAR 0 9
77097: PUSH
77098: LD_INT 2
77100: ARRAY
77101: PPUSH
77102: CALL_OW 546
77106: ST_TO_ADDR
// if hex [ 1 ] then
77107: LD_VAR 0 4
77111: PUSH
77112: LD_INT 1
77114: ARRAY
77115: IFFALSE 77119
// continue ;
77117: GO 77007
// h := hex [ 2 ] ;
77119: LD_ADDR_VAR 0 13
77123: PUSH
77124: LD_VAR 0 4
77128: PUSH
77129: LD_INT 2
77131: ARRAY
77132: ST_TO_ADDR
// if h + 7 < height then
77133: LD_VAR 0 13
77137: PUSH
77138: LD_INT 7
77140: PLUS
77141: PUSH
77142: LD_VAR 0 15
77146: LESS
77147: IFFALSE 77176
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77149: LD_ADDR_VAR 0 18
77153: PUSH
77154: LD_INT 7
77156: PUSH
77157: LD_INT 28
77159: PUSH
77160: LD_INT 45
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: LIST
77167: PUSH
77168: LD_VAR 0 12
77172: ARRAY
77173: ST_TO_ADDR
// break ;
77174: GO 77178
// end ; end ; end ;
77176: GO 77007
77178: POP
77179: POP
// end ; if not weapon then
77180: LD_VAR 0 18
77184: NOT
77185: IFFALSE 77245
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77187: LD_ADDR_VAR 0 5
77191: PUSH
77192: LD_VAR 0 5
77196: PUSH
77197: LD_INT 11
77199: PUSH
77200: LD_INT 30
77202: PUSH
77203: LD_INT 49
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: LIST
77210: DIFF
77211: ST_TO_ADDR
// if not list then
77212: LD_VAR 0 5
77216: NOT
77217: IFFALSE 77221
// exit ;
77219: GO 77363
// weapon := list [ rand ( 1 , list ) ] ;
77221: LD_ADDR_VAR 0 18
77225: PUSH
77226: LD_VAR 0 5
77230: PUSH
77231: LD_INT 1
77233: PPUSH
77234: LD_VAR 0 5
77238: PPUSH
77239: CALL_OW 12
77243: ARRAY
77244: ST_TO_ADDR
// end ; if weapon then
77245: LD_VAR 0 18
77249: IFFALSE 77363
// begin tmp := CostOfWeapon ( weapon ) ;
77251: LD_ADDR_VAR 0 14
77255: PUSH
77256: LD_VAR 0 18
77260: PPUSH
77261: CALL_OW 451
77265: ST_TO_ADDR
// j := GetBase ( tower ) ;
77266: LD_ADDR_VAR 0 9
77270: PUSH
77271: LD_VAR 0 1
77275: PPUSH
77276: CALL_OW 274
77280: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77281: LD_VAR 0 9
77285: PPUSH
77286: LD_INT 1
77288: PPUSH
77289: CALL_OW 275
77293: PUSH
77294: LD_VAR 0 14
77298: PUSH
77299: LD_INT 1
77301: ARRAY
77302: GREATEREQUAL
77303: PUSH
77304: LD_VAR 0 9
77308: PPUSH
77309: LD_INT 2
77311: PPUSH
77312: CALL_OW 275
77316: PUSH
77317: LD_VAR 0 14
77321: PUSH
77322: LD_INT 2
77324: ARRAY
77325: GREATEREQUAL
77326: AND
77327: PUSH
77328: LD_VAR 0 9
77332: PPUSH
77333: LD_INT 3
77335: PPUSH
77336: CALL_OW 275
77340: PUSH
77341: LD_VAR 0 14
77345: PUSH
77346: LD_INT 3
77348: ARRAY
77349: GREATEREQUAL
77350: AND
77351: IFFALSE 77363
// result := weapon ;
77353: LD_ADDR_VAR 0 3
77357: PUSH
77358: LD_VAR 0 18
77362: ST_TO_ADDR
// end ; end ;
77363: LD_VAR 0 3
77367: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77368: LD_INT 0
77370: PPUSH
77371: PPUSH
// result := true ;
77372: LD_ADDR_VAR 0 3
77376: PUSH
77377: LD_INT 1
77379: ST_TO_ADDR
// if array1 = array2 then
77380: LD_VAR 0 1
77384: PUSH
77385: LD_VAR 0 2
77389: EQUAL
77390: IFFALSE 77450
// begin for i = 1 to array1 do
77392: LD_ADDR_VAR 0 4
77396: PUSH
77397: DOUBLE
77398: LD_INT 1
77400: DEC
77401: ST_TO_ADDR
77402: LD_VAR 0 1
77406: PUSH
77407: FOR_TO
77408: IFFALSE 77446
// if array1 [ i ] <> array2 [ i ] then
77410: LD_VAR 0 1
77414: PUSH
77415: LD_VAR 0 4
77419: ARRAY
77420: PUSH
77421: LD_VAR 0 2
77425: PUSH
77426: LD_VAR 0 4
77430: ARRAY
77431: NONEQUAL
77432: IFFALSE 77444
// begin result := false ;
77434: LD_ADDR_VAR 0 3
77438: PUSH
77439: LD_INT 0
77441: ST_TO_ADDR
// break ;
77442: GO 77446
// end ;
77444: GO 77407
77446: POP
77447: POP
// end else
77448: GO 77458
// result := false ;
77450: LD_ADDR_VAR 0 3
77454: PUSH
77455: LD_INT 0
77457: ST_TO_ADDR
// end ;
77458: LD_VAR 0 3
77462: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77463: LD_INT 0
77465: PPUSH
77466: PPUSH
77467: PPUSH
// pom := GetBase ( fac ) ;
77468: LD_ADDR_VAR 0 5
77472: PUSH
77473: LD_VAR 0 1
77477: PPUSH
77478: CALL_OW 274
77482: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77483: LD_ADDR_VAR 0 4
77487: PUSH
77488: LD_VAR 0 2
77492: PUSH
77493: LD_INT 1
77495: ARRAY
77496: PPUSH
77497: LD_VAR 0 2
77501: PUSH
77502: LD_INT 2
77504: ARRAY
77505: PPUSH
77506: LD_VAR 0 2
77510: PUSH
77511: LD_INT 3
77513: ARRAY
77514: PPUSH
77515: LD_VAR 0 2
77519: PUSH
77520: LD_INT 4
77522: ARRAY
77523: PPUSH
77524: CALL_OW 449
77528: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77529: LD_ADDR_VAR 0 3
77533: PUSH
77534: LD_VAR 0 5
77538: PPUSH
77539: LD_INT 1
77541: PPUSH
77542: CALL_OW 275
77546: PUSH
77547: LD_VAR 0 4
77551: PUSH
77552: LD_INT 1
77554: ARRAY
77555: GREATEREQUAL
77556: PUSH
77557: LD_VAR 0 5
77561: PPUSH
77562: LD_INT 2
77564: PPUSH
77565: CALL_OW 275
77569: PUSH
77570: LD_VAR 0 4
77574: PUSH
77575: LD_INT 2
77577: ARRAY
77578: GREATEREQUAL
77579: AND
77580: PUSH
77581: LD_VAR 0 5
77585: PPUSH
77586: LD_INT 3
77588: PPUSH
77589: CALL_OW 275
77593: PUSH
77594: LD_VAR 0 4
77598: PUSH
77599: LD_INT 3
77601: ARRAY
77602: GREATEREQUAL
77603: AND
77604: ST_TO_ADDR
// end ;
77605: LD_VAR 0 3
77609: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77610: LD_INT 0
77612: PPUSH
77613: PPUSH
77614: PPUSH
77615: PPUSH
// pom := GetBase ( building ) ;
77616: LD_ADDR_VAR 0 3
77620: PUSH
77621: LD_VAR 0 1
77625: PPUSH
77626: CALL_OW 274
77630: ST_TO_ADDR
// if not pom then
77631: LD_VAR 0 3
77635: NOT
77636: IFFALSE 77640
// exit ;
77638: GO 77810
// btype := GetBType ( building ) ;
77640: LD_ADDR_VAR 0 5
77644: PUSH
77645: LD_VAR 0 1
77649: PPUSH
77650: CALL_OW 266
77654: ST_TO_ADDR
// if btype = b_armoury then
77655: LD_VAR 0 5
77659: PUSH
77660: LD_INT 4
77662: EQUAL
77663: IFFALSE 77673
// btype := b_barracks ;
77665: LD_ADDR_VAR 0 5
77669: PUSH
77670: LD_INT 5
77672: ST_TO_ADDR
// if btype = b_depot then
77673: LD_VAR 0 5
77677: PUSH
77678: LD_INT 0
77680: EQUAL
77681: IFFALSE 77691
// btype := b_warehouse ;
77683: LD_ADDR_VAR 0 5
77687: PUSH
77688: LD_INT 1
77690: ST_TO_ADDR
// if btype = b_workshop then
77691: LD_VAR 0 5
77695: PUSH
77696: LD_INT 2
77698: EQUAL
77699: IFFALSE 77709
// btype := b_factory ;
77701: LD_ADDR_VAR 0 5
77705: PUSH
77706: LD_INT 3
77708: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77709: LD_ADDR_VAR 0 4
77713: PUSH
77714: LD_VAR 0 5
77718: PPUSH
77719: LD_VAR 0 1
77723: PPUSH
77724: CALL_OW 248
77728: PPUSH
77729: CALL_OW 450
77733: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77734: LD_ADDR_VAR 0 2
77738: PUSH
77739: LD_VAR 0 3
77743: PPUSH
77744: LD_INT 1
77746: PPUSH
77747: CALL_OW 275
77751: PUSH
77752: LD_VAR 0 4
77756: PUSH
77757: LD_INT 1
77759: ARRAY
77760: GREATEREQUAL
77761: PUSH
77762: LD_VAR 0 3
77766: PPUSH
77767: LD_INT 2
77769: PPUSH
77770: CALL_OW 275
77774: PUSH
77775: LD_VAR 0 4
77779: PUSH
77780: LD_INT 2
77782: ARRAY
77783: GREATEREQUAL
77784: AND
77785: PUSH
77786: LD_VAR 0 3
77790: PPUSH
77791: LD_INT 3
77793: PPUSH
77794: CALL_OW 275
77798: PUSH
77799: LD_VAR 0 4
77803: PUSH
77804: LD_INT 3
77806: ARRAY
77807: GREATEREQUAL
77808: AND
77809: ST_TO_ADDR
// end ;
77810: LD_VAR 0 2
77814: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77815: LD_INT 0
77817: PPUSH
77818: PPUSH
77819: PPUSH
// pom := GetBase ( building ) ;
77820: LD_ADDR_VAR 0 4
77824: PUSH
77825: LD_VAR 0 1
77829: PPUSH
77830: CALL_OW 274
77834: ST_TO_ADDR
// if not pom then
77835: LD_VAR 0 4
77839: NOT
77840: IFFALSE 77844
// exit ;
77842: GO 77945
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77844: LD_ADDR_VAR 0 5
77848: PUSH
77849: LD_VAR 0 2
77853: PPUSH
77854: LD_VAR 0 1
77858: PPUSH
77859: CALL_OW 248
77863: PPUSH
77864: CALL_OW 450
77868: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77869: LD_ADDR_VAR 0 3
77873: PUSH
77874: LD_VAR 0 4
77878: PPUSH
77879: LD_INT 1
77881: PPUSH
77882: CALL_OW 275
77886: PUSH
77887: LD_VAR 0 5
77891: PUSH
77892: LD_INT 1
77894: ARRAY
77895: GREATEREQUAL
77896: PUSH
77897: LD_VAR 0 4
77901: PPUSH
77902: LD_INT 2
77904: PPUSH
77905: CALL_OW 275
77909: PUSH
77910: LD_VAR 0 5
77914: PUSH
77915: LD_INT 2
77917: ARRAY
77918: GREATEREQUAL
77919: AND
77920: PUSH
77921: LD_VAR 0 4
77925: PPUSH
77926: LD_INT 3
77928: PPUSH
77929: CALL_OW 275
77933: PUSH
77934: LD_VAR 0 5
77938: PUSH
77939: LD_INT 3
77941: ARRAY
77942: GREATEREQUAL
77943: AND
77944: ST_TO_ADDR
// end ;
77945: LD_VAR 0 3
77949: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
77950: LD_INT 0
77952: PPUSH
77953: PPUSH
77954: PPUSH
77955: PPUSH
77956: PPUSH
77957: PPUSH
77958: PPUSH
77959: PPUSH
77960: PPUSH
77961: PPUSH
// result := false ;
77962: LD_ADDR_VAR 0 6
77966: PUSH
77967: LD_INT 0
77969: ST_TO_ADDR
// if not base or not btype or not x or not y then
77970: LD_VAR 0 1
77974: NOT
77975: PUSH
77976: LD_VAR 0 2
77980: NOT
77981: OR
77982: PUSH
77983: LD_VAR 0 3
77987: NOT
77988: OR
77989: PUSH
77990: LD_VAR 0 4
77994: NOT
77995: OR
77996: IFFALSE 78000
// exit ;
77998: GO 78609
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78000: LD_ADDR_VAR 0 12
78004: PUSH
78005: LD_VAR 0 2
78009: PPUSH
78010: LD_VAR 0 3
78014: PPUSH
78015: LD_VAR 0 4
78019: PPUSH
78020: LD_VAR 0 5
78024: PPUSH
78025: LD_VAR 0 1
78029: PUSH
78030: LD_INT 1
78032: ARRAY
78033: PPUSH
78034: CALL_OW 248
78038: PPUSH
78039: LD_INT 0
78041: PPUSH
78042: CALL 79446 0 6
78046: ST_TO_ADDR
// if not hexes then
78047: LD_VAR 0 12
78051: NOT
78052: IFFALSE 78056
// exit ;
78054: GO 78609
// for i = 1 to hexes do
78056: LD_ADDR_VAR 0 7
78060: PUSH
78061: DOUBLE
78062: LD_INT 1
78064: DEC
78065: ST_TO_ADDR
78066: LD_VAR 0 12
78070: PUSH
78071: FOR_TO
78072: IFFALSE 78607
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78074: LD_ADDR_VAR 0 11
78078: PUSH
78079: LD_VAR 0 12
78083: PUSH
78084: LD_VAR 0 7
78088: ARRAY
78089: PUSH
78090: LD_INT 1
78092: ARRAY
78093: PPUSH
78094: LD_VAR 0 12
78098: PUSH
78099: LD_VAR 0 7
78103: ARRAY
78104: PUSH
78105: LD_INT 2
78107: ARRAY
78108: PPUSH
78109: CALL_OW 428
78113: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78114: LD_VAR 0 12
78118: PUSH
78119: LD_VAR 0 7
78123: ARRAY
78124: PUSH
78125: LD_INT 1
78127: ARRAY
78128: PPUSH
78129: LD_VAR 0 12
78133: PUSH
78134: LD_VAR 0 7
78138: ARRAY
78139: PUSH
78140: LD_INT 2
78142: ARRAY
78143: PPUSH
78144: CALL_OW 351
78148: PUSH
78149: LD_VAR 0 12
78153: PUSH
78154: LD_VAR 0 7
78158: ARRAY
78159: PUSH
78160: LD_INT 1
78162: ARRAY
78163: PPUSH
78164: LD_VAR 0 12
78168: PUSH
78169: LD_VAR 0 7
78173: ARRAY
78174: PUSH
78175: LD_INT 2
78177: ARRAY
78178: PPUSH
78179: CALL_OW 488
78183: NOT
78184: OR
78185: PUSH
78186: LD_VAR 0 11
78190: PPUSH
78191: CALL_OW 247
78195: PUSH
78196: LD_INT 3
78198: EQUAL
78199: OR
78200: IFFALSE 78206
// exit ;
78202: POP
78203: POP
78204: GO 78609
// if not tmp or not tmp in base then
78206: LD_VAR 0 11
78210: NOT
78211: PUSH
78212: LD_VAR 0 11
78216: PUSH
78217: LD_VAR 0 1
78221: IN
78222: NOT
78223: OR
78224: IFFALSE 78228
// continue ;
78226: GO 78071
// result := true ;
78228: LD_ADDR_VAR 0 6
78232: PUSH
78233: LD_INT 1
78235: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78236: LD_ADDR_VAR 0 15
78240: PUSH
78241: LD_VAR 0 1
78245: PPUSH
78246: LD_INT 22
78248: PUSH
78249: LD_VAR 0 11
78253: PPUSH
78254: CALL_OW 255
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 2
78265: PUSH
78266: LD_INT 30
78268: PUSH
78269: LD_INT 0
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 30
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: LIST
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PPUSH
78295: CALL_OW 72
78299: ST_TO_ADDR
// if dep then
78300: LD_VAR 0 15
78304: IFFALSE 78440
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78306: LD_ADDR_VAR 0 14
78310: PUSH
78311: LD_VAR 0 15
78315: PUSH
78316: LD_INT 1
78318: ARRAY
78319: PPUSH
78320: CALL_OW 250
78324: PPUSH
78325: LD_VAR 0 15
78329: PUSH
78330: LD_INT 1
78332: ARRAY
78333: PPUSH
78334: CALL_OW 254
78338: PPUSH
78339: LD_INT 5
78341: PPUSH
78342: CALL_OW 272
78346: PUSH
78347: LD_VAR 0 15
78351: PUSH
78352: LD_INT 1
78354: ARRAY
78355: PPUSH
78356: CALL_OW 251
78360: PPUSH
78361: LD_VAR 0 15
78365: PUSH
78366: LD_INT 1
78368: ARRAY
78369: PPUSH
78370: CALL_OW 254
78374: PPUSH
78375: LD_INT 5
78377: PPUSH
78378: CALL_OW 273
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78387: LD_VAR 0 14
78391: PUSH
78392: LD_INT 1
78394: ARRAY
78395: PPUSH
78396: LD_VAR 0 14
78400: PUSH
78401: LD_INT 2
78403: ARRAY
78404: PPUSH
78405: CALL_OW 488
78409: IFFALSE 78440
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78411: LD_VAR 0 11
78415: PPUSH
78416: LD_VAR 0 14
78420: PUSH
78421: LD_INT 1
78423: ARRAY
78424: PPUSH
78425: LD_VAR 0 14
78429: PUSH
78430: LD_INT 2
78432: ARRAY
78433: PPUSH
78434: CALL_OW 111
// continue ;
78438: GO 78071
// end ; end ; r := GetDir ( tmp ) ;
78440: LD_ADDR_VAR 0 13
78444: PUSH
78445: LD_VAR 0 11
78449: PPUSH
78450: CALL_OW 254
78454: ST_TO_ADDR
// if r = 5 then
78455: LD_VAR 0 13
78459: PUSH
78460: LD_INT 5
78462: EQUAL
78463: IFFALSE 78473
// r := 0 ;
78465: LD_ADDR_VAR 0 13
78469: PUSH
78470: LD_INT 0
78472: ST_TO_ADDR
// for j = r to 5 do
78473: LD_ADDR_VAR 0 8
78477: PUSH
78478: DOUBLE
78479: LD_VAR 0 13
78483: DEC
78484: ST_TO_ADDR
78485: LD_INT 5
78487: PUSH
78488: FOR_TO
78489: IFFALSE 78603
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78491: LD_ADDR_VAR 0 9
78495: PUSH
78496: LD_VAR 0 11
78500: PPUSH
78501: CALL_OW 250
78505: PPUSH
78506: LD_VAR 0 8
78510: PPUSH
78511: LD_INT 2
78513: PPUSH
78514: CALL_OW 272
78518: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78519: LD_ADDR_VAR 0 10
78523: PUSH
78524: LD_VAR 0 11
78528: PPUSH
78529: CALL_OW 251
78533: PPUSH
78534: LD_VAR 0 8
78538: PPUSH
78539: LD_INT 2
78541: PPUSH
78542: CALL_OW 273
78546: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78547: LD_VAR 0 9
78551: PPUSH
78552: LD_VAR 0 10
78556: PPUSH
78557: CALL_OW 488
78561: PUSH
78562: LD_VAR 0 9
78566: PPUSH
78567: LD_VAR 0 10
78571: PPUSH
78572: CALL_OW 428
78576: NOT
78577: AND
78578: IFFALSE 78601
// begin ComMoveXY ( tmp , _x , _y ) ;
78580: LD_VAR 0 11
78584: PPUSH
78585: LD_VAR 0 9
78589: PPUSH
78590: LD_VAR 0 10
78594: PPUSH
78595: CALL_OW 111
// break ;
78599: GO 78603
// end ; end ;
78601: GO 78488
78603: POP
78604: POP
// end ;
78605: GO 78071
78607: POP
78608: POP
// end ;
78609: LD_VAR 0 6
78613: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78614: LD_INT 0
78616: PPUSH
78617: PPUSH
78618: PPUSH
78619: PPUSH
78620: PPUSH
78621: PPUSH
78622: PPUSH
78623: PPUSH
78624: PPUSH
78625: PPUSH
// result := false ;
78626: LD_ADDR_VAR 0 6
78630: PUSH
78631: LD_INT 0
78633: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78634: LD_VAR 0 1
78638: NOT
78639: PUSH
78640: LD_VAR 0 1
78644: PPUSH
78645: CALL_OW 266
78649: PUSH
78650: LD_INT 0
78652: PUSH
78653: LD_INT 1
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: IN
78660: NOT
78661: OR
78662: PUSH
78663: LD_VAR 0 2
78667: NOT
78668: OR
78669: PUSH
78670: LD_VAR 0 5
78674: PUSH
78675: LD_INT 0
78677: PUSH
78678: LD_INT 1
78680: PUSH
78681: LD_INT 2
78683: PUSH
78684: LD_INT 3
78686: PUSH
78687: LD_INT 4
78689: PUSH
78690: LD_INT 5
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: IN
78701: NOT
78702: OR
78703: PUSH
78704: LD_VAR 0 3
78708: PPUSH
78709: LD_VAR 0 4
78713: PPUSH
78714: CALL_OW 488
78718: NOT
78719: OR
78720: IFFALSE 78724
// exit ;
78722: GO 79441
// pom := GetBase ( depot ) ;
78724: LD_ADDR_VAR 0 10
78728: PUSH
78729: LD_VAR 0 1
78733: PPUSH
78734: CALL_OW 274
78738: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78739: LD_ADDR_VAR 0 11
78743: PUSH
78744: LD_VAR 0 2
78748: PPUSH
78749: LD_VAR 0 1
78753: PPUSH
78754: CALL_OW 248
78758: PPUSH
78759: CALL_OW 450
78763: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78764: LD_VAR 0 10
78768: PPUSH
78769: LD_INT 1
78771: PPUSH
78772: CALL_OW 275
78776: PUSH
78777: LD_VAR 0 11
78781: PUSH
78782: LD_INT 1
78784: ARRAY
78785: GREATEREQUAL
78786: PUSH
78787: LD_VAR 0 10
78791: PPUSH
78792: LD_INT 2
78794: PPUSH
78795: CALL_OW 275
78799: PUSH
78800: LD_VAR 0 11
78804: PUSH
78805: LD_INT 2
78807: ARRAY
78808: GREATEREQUAL
78809: AND
78810: PUSH
78811: LD_VAR 0 10
78815: PPUSH
78816: LD_INT 3
78818: PPUSH
78819: CALL_OW 275
78823: PUSH
78824: LD_VAR 0 11
78828: PUSH
78829: LD_INT 3
78831: ARRAY
78832: GREATEREQUAL
78833: AND
78834: NOT
78835: IFFALSE 78839
// exit ;
78837: GO 79441
// if GetBType ( depot ) = b_depot then
78839: LD_VAR 0 1
78843: PPUSH
78844: CALL_OW 266
78848: PUSH
78849: LD_INT 0
78851: EQUAL
78852: IFFALSE 78864
// dist := 28 else
78854: LD_ADDR_VAR 0 14
78858: PUSH
78859: LD_INT 28
78861: ST_TO_ADDR
78862: GO 78872
// dist := 36 ;
78864: LD_ADDR_VAR 0 14
78868: PUSH
78869: LD_INT 36
78871: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78872: LD_VAR 0 1
78876: PPUSH
78877: LD_VAR 0 3
78881: PPUSH
78882: LD_VAR 0 4
78886: PPUSH
78887: CALL_OW 297
78891: PUSH
78892: LD_VAR 0 14
78896: GREATER
78897: IFFALSE 78901
// exit ;
78899: GO 79441
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78901: LD_ADDR_VAR 0 12
78905: PUSH
78906: LD_VAR 0 2
78910: PPUSH
78911: LD_VAR 0 3
78915: PPUSH
78916: LD_VAR 0 4
78920: PPUSH
78921: LD_VAR 0 5
78925: PPUSH
78926: LD_VAR 0 1
78930: PPUSH
78931: CALL_OW 248
78935: PPUSH
78936: LD_INT 0
78938: PPUSH
78939: CALL 79446 0 6
78943: ST_TO_ADDR
// if not hexes then
78944: LD_VAR 0 12
78948: NOT
78949: IFFALSE 78953
// exit ;
78951: GO 79441
// hex := GetHexInfo ( x , y ) ;
78953: LD_ADDR_VAR 0 15
78957: PUSH
78958: LD_VAR 0 3
78962: PPUSH
78963: LD_VAR 0 4
78967: PPUSH
78968: CALL_OW 546
78972: ST_TO_ADDR
// if hex [ 1 ] then
78973: LD_VAR 0 15
78977: PUSH
78978: LD_INT 1
78980: ARRAY
78981: IFFALSE 78985
// exit ;
78983: GO 79441
// height := hex [ 2 ] ;
78985: LD_ADDR_VAR 0 13
78989: PUSH
78990: LD_VAR 0 15
78994: PUSH
78995: LD_INT 2
78997: ARRAY
78998: ST_TO_ADDR
// for i = 1 to hexes do
78999: LD_ADDR_VAR 0 7
79003: PUSH
79004: DOUBLE
79005: LD_INT 1
79007: DEC
79008: ST_TO_ADDR
79009: LD_VAR 0 12
79013: PUSH
79014: FOR_TO
79015: IFFALSE 79345
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79017: LD_VAR 0 12
79021: PUSH
79022: LD_VAR 0 7
79026: ARRAY
79027: PUSH
79028: LD_INT 1
79030: ARRAY
79031: PPUSH
79032: LD_VAR 0 12
79036: PUSH
79037: LD_VAR 0 7
79041: ARRAY
79042: PUSH
79043: LD_INT 2
79045: ARRAY
79046: PPUSH
79047: CALL_OW 488
79051: NOT
79052: PUSH
79053: LD_VAR 0 12
79057: PUSH
79058: LD_VAR 0 7
79062: ARRAY
79063: PUSH
79064: LD_INT 1
79066: ARRAY
79067: PPUSH
79068: LD_VAR 0 12
79072: PUSH
79073: LD_VAR 0 7
79077: ARRAY
79078: PUSH
79079: LD_INT 2
79081: ARRAY
79082: PPUSH
79083: CALL_OW 428
79087: PUSH
79088: LD_INT 0
79090: GREATER
79091: OR
79092: PUSH
79093: LD_VAR 0 12
79097: PUSH
79098: LD_VAR 0 7
79102: ARRAY
79103: PUSH
79104: LD_INT 1
79106: ARRAY
79107: PPUSH
79108: LD_VAR 0 12
79112: PUSH
79113: LD_VAR 0 7
79117: ARRAY
79118: PUSH
79119: LD_INT 2
79121: ARRAY
79122: PPUSH
79123: CALL_OW 351
79127: OR
79128: IFFALSE 79134
// exit ;
79130: POP
79131: POP
79132: GO 79441
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79134: LD_ADDR_VAR 0 8
79138: PUSH
79139: LD_VAR 0 12
79143: PUSH
79144: LD_VAR 0 7
79148: ARRAY
79149: PUSH
79150: LD_INT 1
79152: ARRAY
79153: PPUSH
79154: LD_VAR 0 12
79158: PUSH
79159: LD_VAR 0 7
79163: ARRAY
79164: PUSH
79165: LD_INT 2
79167: ARRAY
79168: PPUSH
79169: CALL_OW 546
79173: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79174: LD_VAR 0 8
79178: PUSH
79179: LD_INT 1
79181: ARRAY
79182: PUSH
79183: LD_VAR 0 8
79187: PUSH
79188: LD_INT 2
79190: ARRAY
79191: PUSH
79192: LD_VAR 0 13
79196: PUSH
79197: LD_INT 2
79199: PLUS
79200: GREATER
79201: OR
79202: PUSH
79203: LD_VAR 0 8
79207: PUSH
79208: LD_INT 2
79210: ARRAY
79211: PUSH
79212: LD_VAR 0 13
79216: PUSH
79217: LD_INT 2
79219: MINUS
79220: LESS
79221: OR
79222: PUSH
79223: LD_VAR 0 8
79227: PUSH
79228: LD_INT 3
79230: ARRAY
79231: PUSH
79232: LD_INT 0
79234: PUSH
79235: LD_INT 8
79237: PUSH
79238: LD_INT 9
79240: PUSH
79241: LD_INT 10
79243: PUSH
79244: LD_INT 11
79246: PUSH
79247: LD_INT 12
79249: PUSH
79250: LD_INT 13
79252: PUSH
79253: LD_INT 16
79255: PUSH
79256: LD_INT 17
79258: PUSH
79259: LD_INT 18
79261: PUSH
79262: LD_INT 19
79264: PUSH
79265: LD_INT 20
79267: PUSH
79268: LD_INT 21
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: LIST
79275: LIST
79276: LIST
79277: LIST
79278: LIST
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: LIST
79285: IN
79286: NOT
79287: OR
79288: PUSH
79289: LD_VAR 0 8
79293: PUSH
79294: LD_INT 5
79296: ARRAY
79297: NOT
79298: OR
79299: PUSH
79300: LD_VAR 0 8
79304: PUSH
79305: LD_INT 6
79307: ARRAY
79308: PUSH
79309: LD_INT 1
79311: PUSH
79312: LD_INT 2
79314: PUSH
79315: LD_INT 7
79317: PUSH
79318: LD_INT 9
79320: PUSH
79321: LD_INT 10
79323: PUSH
79324: LD_INT 11
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: IN
79335: NOT
79336: OR
79337: IFFALSE 79343
// exit ;
79339: POP
79340: POP
79341: GO 79441
// end ;
79343: GO 79014
79345: POP
79346: POP
// side := GetSide ( depot ) ;
79347: LD_ADDR_VAR 0 9
79351: PUSH
79352: LD_VAR 0 1
79356: PPUSH
79357: CALL_OW 255
79361: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79362: LD_VAR 0 9
79366: PPUSH
79367: LD_VAR 0 3
79371: PPUSH
79372: LD_VAR 0 4
79376: PPUSH
79377: LD_INT 20
79379: PPUSH
79380: CALL 72095 0 4
79384: PUSH
79385: LD_INT 4
79387: ARRAY
79388: IFFALSE 79392
// exit ;
79390: GO 79441
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79392: LD_VAR 0 2
79396: PUSH
79397: LD_INT 29
79399: PUSH
79400: LD_INT 30
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: IN
79407: PUSH
79408: LD_VAR 0 3
79412: PPUSH
79413: LD_VAR 0 4
79417: PPUSH
79418: LD_VAR 0 9
79422: PPUSH
79423: CALL_OW 440
79427: NOT
79428: AND
79429: IFFALSE 79433
// exit ;
79431: GO 79441
// result := true ;
79433: LD_ADDR_VAR 0 6
79437: PUSH
79438: LD_INT 1
79440: ST_TO_ADDR
// end ;
79441: LD_VAR 0 6
79445: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79446: LD_INT 0
79448: PPUSH
79449: PPUSH
79450: PPUSH
79451: PPUSH
79452: PPUSH
79453: PPUSH
79454: PPUSH
79455: PPUSH
79456: PPUSH
79457: PPUSH
79458: PPUSH
79459: PPUSH
79460: PPUSH
79461: PPUSH
79462: PPUSH
79463: PPUSH
79464: PPUSH
79465: PPUSH
79466: PPUSH
79467: PPUSH
79468: PPUSH
79469: PPUSH
79470: PPUSH
79471: PPUSH
79472: PPUSH
79473: PPUSH
79474: PPUSH
79475: PPUSH
79476: PPUSH
79477: PPUSH
79478: PPUSH
79479: PPUSH
79480: PPUSH
79481: PPUSH
79482: PPUSH
79483: PPUSH
79484: PPUSH
79485: PPUSH
79486: PPUSH
79487: PPUSH
79488: PPUSH
79489: PPUSH
79490: PPUSH
79491: PPUSH
79492: PPUSH
79493: PPUSH
79494: PPUSH
79495: PPUSH
79496: PPUSH
79497: PPUSH
79498: PPUSH
79499: PPUSH
79500: PPUSH
79501: PPUSH
79502: PPUSH
79503: PPUSH
79504: PPUSH
79505: PPUSH
// result = [ ] ;
79506: LD_ADDR_VAR 0 7
79510: PUSH
79511: EMPTY
79512: ST_TO_ADDR
// temp_list = [ ] ;
79513: LD_ADDR_VAR 0 9
79517: PUSH
79518: EMPTY
79519: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79520: LD_VAR 0 4
79524: PUSH
79525: LD_INT 0
79527: PUSH
79528: LD_INT 1
79530: PUSH
79531: LD_INT 2
79533: PUSH
79534: LD_INT 3
79536: PUSH
79537: LD_INT 4
79539: PUSH
79540: LD_INT 5
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: IN
79551: NOT
79552: PUSH
79553: LD_VAR 0 1
79557: PUSH
79558: LD_INT 0
79560: PUSH
79561: LD_INT 1
79563: PUSH
79564: EMPTY
79565: LIST
79566: LIST
79567: IN
79568: PUSH
79569: LD_VAR 0 5
79573: PUSH
79574: LD_INT 1
79576: PUSH
79577: LD_INT 2
79579: PUSH
79580: LD_INT 3
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: LIST
79587: IN
79588: NOT
79589: AND
79590: OR
79591: IFFALSE 79595
// exit ;
79593: GO 97986
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79595: LD_VAR 0 1
79599: PUSH
79600: LD_INT 6
79602: PUSH
79603: LD_INT 7
79605: PUSH
79606: LD_INT 8
79608: PUSH
79609: LD_INT 13
79611: PUSH
79612: LD_INT 12
79614: PUSH
79615: LD_INT 15
79617: PUSH
79618: LD_INT 11
79620: PUSH
79621: LD_INT 14
79623: PUSH
79624: LD_INT 10
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: IN
79638: IFFALSE 79648
// btype = b_lab ;
79640: LD_ADDR_VAR 0 1
79644: PUSH
79645: LD_INT 6
79647: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79648: LD_VAR 0 6
79652: PUSH
79653: LD_INT 0
79655: PUSH
79656: LD_INT 1
79658: PUSH
79659: LD_INT 2
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: LIST
79666: IN
79667: NOT
79668: PUSH
79669: LD_VAR 0 1
79673: PUSH
79674: LD_INT 0
79676: PUSH
79677: LD_INT 1
79679: PUSH
79680: LD_INT 2
79682: PUSH
79683: LD_INT 3
79685: PUSH
79686: LD_INT 6
79688: PUSH
79689: LD_INT 36
79691: PUSH
79692: LD_INT 4
79694: PUSH
79695: LD_INT 5
79697: PUSH
79698: LD_INT 31
79700: PUSH
79701: LD_INT 32
79703: PUSH
79704: LD_INT 33
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: IN
79720: NOT
79721: PUSH
79722: LD_VAR 0 6
79726: PUSH
79727: LD_INT 1
79729: EQUAL
79730: AND
79731: OR
79732: PUSH
79733: LD_VAR 0 1
79737: PUSH
79738: LD_INT 2
79740: PUSH
79741: LD_INT 3
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: IN
79748: NOT
79749: PUSH
79750: LD_VAR 0 6
79754: PUSH
79755: LD_INT 2
79757: EQUAL
79758: AND
79759: OR
79760: IFFALSE 79770
// mode = 0 ;
79762: LD_ADDR_VAR 0 6
79766: PUSH
79767: LD_INT 0
79769: ST_TO_ADDR
// case mode of 0 :
79770: LD_VAR 0 6
79774: PUSH
79775: LD_INT 0
79777: DOUBLE
79778: EQUAL
79779: IFTRUE 79783
79781: GO 91236
79783: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79784: LD_ADDR_VAR 0 11
79788: PUSH
79789: LD_INT 0
79791: PUSH
79792: LD_INT 0
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 0
79801: PUSH
79802: LD_INT 1
79804: NEG
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 1
79812: PUSH
79813: LD_INT 0
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 1
79822: PUSH
79823: LD_INT 1
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 0
79832: PUSH
79833: LD_INT 1
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 1
79842: NEG
79843: PUSH
79844: LD_INT 0
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 1
79853: NEG
79854: PUSH
79855: LD_INT 1
79857: NEG
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: LD_INT 1
79865: NEG
79866: PUSH
79867: LD_INT 2
79869: NEG
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 0
79877: PUSH
79878: LD_INT 2
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 1
79888: PUSH
79889: LD_INT 1
79891: NEG
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 1
79899: PUSH
79900: LD_INT 2
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 0
79909: PUSH
79910: LD_INT 2
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PUSH
79917: LD_INT 1
79919: NEG
79920: PUSH
79921: LD_INT 1
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 1
79930: PUSH
79931: LD_INT 3
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: LD_INT 3
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 1
79950: NEG
79951: PUSH
79952: LD_INT 2
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: LIST
79963: LIST
79964: LIST
79965: LIST
79966: LIST
79967: LIST
79968: LIST
79969: LIST
79970: LIST
79971: LIST
79972: LIST
79973: LIST
79974: LIST
79975: LIST
79976: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79977: LD_ADDR_VAR 0 12
79981: PUSH
79982: LD_INT 0
79984: PUSH
79985: LD_INT 0
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PUSH
79992: LD_INT 0
79994: PUSH
79995: LD_INT 1
79997: NEG
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 1
80005: PUSH
80006: LD_INT 0
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 1
80015: PUSH
80016: LD_INT 1
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 0
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 1
80035: NEG
80036: PUSH
80037: LD_INT 0
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 1
80046: NEG
80047: PUSH
80048: LD_INT 1
80050: NEG
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 1
80058: PUSH
80059: LD_INT 1
80061: NEG
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 2
80069: PUSH
80070: LD_INT 0
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 2
80079: PUSH
80080: LD_INT 1
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 1
80089: NEG
80090: PUSH
80091: LD_INT 1
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 2
80100: NEG
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 2
80111: NEG
80112: PUSH
80113: LD_INT 1
80115: NEG
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 2
80123: NEG
80124: PUSH
80125: LD_INT 1
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: LD_INT 3
80134: NEG
80135: PUSH
80136: LD_INT 0
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 3
80145: NEG
80146: PUSH
80147: LD_INT 1
80149: NEG
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80173: LD_ADDR_VAR 0 13
80177: PUSH
80178: LD_INT 0
80180: PUSH
80181: LD_INT 0
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 1
80193: NEG
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 1
80201: PUSH
80202: LD_INT 0
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 1
80211: PUSH
80212: LD_INT 1
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 0
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 1
80231: NEG
80232: PUSH
80233: LD_INT 0
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: LD_INT 1
80246: NEG
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 1
80254: NEG
80255: PUSH
80256: LD_INT 2
80258: NEG
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: PUSH
80264: LD_INT 2
80266: PUSH
80267: LD_INT 1
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 2
80276: PUSH
80277: LD_INT 2
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: LD_INT 2
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 2
80296: NEG
80297: PUSH
80298: LD_INT 1
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 2
80308: NEG
80309: PUSH
80310: LD_INT 2
80312: NEG
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 2
80320: NEG
80321: PUSH
80322: LD_INT 3
80324: NEG
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 3
80332: NEG
80333: PUSH
80334: LD_INT 2
80336: NEG
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: LD_INT 3
80344: NEG
80345: PUSH
80346: LD_INT 3
80348: NEG
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80372: LD_ADDR_VAR 0 14
80376: PUSH
80377: LD_INT 0
80379: PUSH
80380: LD_INT 0
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 0
80389: PUSH
80390: LD_INT 1
80392: NEG
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 1
80400: PUSH
80401: LD_INT 0
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 1
80410: PUSH
80411: LD_INT 1
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 0
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 1
80430: NEG
80431: PUSH
80432: LD_INT 0
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 1
80441: NEG
80442: PUSH
80443: LD_INT 1
80445: NEG
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 1
80453: NEG
80454: PUSH
80455: LD_INT 2
80457: NEG
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 0
80465: PUSH
80466: LD_INT 2
80468: NEG
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 1
80476: PUSH
80477: LD_INT 1
80479: NEG
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 1
80487: PUSH
80488: LD_INT 2
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 0
80497: PUSH
80498: LD_INT 2
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 1
80507: NEG
80508: PUSH
80509: LD_INT 1
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 1
80518: NEG
80519: PUSH
80520: LD_INT 3
80522: NEG
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 0
80530: PUSH
80531: LD_INT 3
80533: NEG
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 1
80541: PUSH
80542: LD_INT 2
80544: NEG
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: LIST
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80568: LD_ADDR_VAR 0 15
80572: PUSH
80573: LD_INT 0
80575: PUSH
80576: LD_INT 0
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 0
80585: PUSH
80586: LD_INT 1
80588: NEG
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 1
80596: PUSH
80597: LD_INT 0
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 1
80606: PUSH
80607: LD_INT 1
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 0
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 1
80626: NEG
80627: PUSH
80628: LD_INT 0
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 1
80641: NEG
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 1
80649: PUSH
80650: LD_INT 1
80652: NEG
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 2
80660: PUSH
80661: LD_INT 0
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 2
80670: PUSH
80671: LD_INT 1
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 1
80680: NEG
80681: PUSH
80682: LD_INT 1
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 2
80691: NEG
80692: PUSH
80693: LD_INT 0
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 2
80702: NEG
80703: PUSH
80704: LD_INT 1
80706: NEG
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 2
80714: PUSH
80715: LD_INT 1
80717: NEG
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 3
80725: PUSH
80726: LD_INT 0
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_INT 3
80735: PUSH
80736: LD_INT 1
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: LIST
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80761: LD_ADDR_VAR 0 16
80765: PUSH
80766: LD_INT 0
80768: PUSH
80769: LD_INT 0
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 0
80778: PUSH
80779: LD_INT 1
80781: NEG
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 1
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 1
80799: PUSH
80800: LD_INT 1
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 0
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 1
80819: NEG
80820: PUSH
80821: LD_INT 0
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 1
80830: NEG
80831: PUSH
80832: LD_INT 1
80834: NEG
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 1
80842: NEG
80843: PUSH
80844: LD_INT 2
80846: NEG
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 2
80854: PUSH
80855: LD_INT 1
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 2
80864: PUSH
80865: LD_INT 2
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 1
80874: PUSH
80875: LD_INT 2
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 2
80884: NEG
80885: PUSH
80886: LD_INT 1
80888: NEG
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 2
80896: NEG
80897: PUSH
80898: LD_INT 2
80900: NEG
80901: PUSH
80902: EMPTY
80903: LIST
80904: LIST
80905: PUSH
80906: LD_INT 3
80908: PUSH
80909: LD_INT 2
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 3
80918: PUSH
80919: LD_INT 3
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 2
80928: PUSH
80929: LD_INT 3
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80954: LD_ADDR_VAR 0 17
80958: PUSH
80959: LD_INT 0
80961: PUSH
80962: LD_INT 0
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 0
80971: PUSH
80972: LD_INT 1
80974: NEG
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 1
80982: PUSH
80983: LD_INT 0
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PUSH
80990: LD_INT 1
80992: PUSH
80993: LD_INT 1
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 0
81002: PUSH
81003: LD_INT 1
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 1
81012: NEG
81013: PUSH
81014: LD_INT 0
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 1
81023: NEG
81024: PUSH
81025: LD_INT 1
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 1
81035: NEG
81036: PUSH
81037: LD_INT 2
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 0
81047: PUSH
81048: LD_INT 2
81050: NEG
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 1
81058: PUSH
81059: LD_INT 1
81061: NEG
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 2
81069: PUSH
81070: LD_INT 0
81072: PUSH
81073: EMPTY
81074: LIST
81075: LIST
81076: PUSH
81077: LD_INT 2
81079: PUSH
81080: LD_INT 1
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 2
81089: PUSH
81090: LD_INT 2
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 1
81099: PUSH
81100: LD_INT 2
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 0
81109: PUSH
81110: LD_INT 2
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 1
81119: NEG
81120: PUSH
81121: LD_INT 1
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 2
81130: NEG
81131: PUSH
81132: LD_INT 0
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 2
81141: NEG
81142: PUSH
81143: LD_INT 1
81145: NEG
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 2
81153: NEG
81154: PUSH
81155: LD_INT 2
81157: NEG
81158: PUSH
81159: EMPTY
81160: LIST
81161: LIST
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81184: LD_ADDR_VAR 0 18
81188: PUSH
81189: LD_INT 0
81191: PUSH
81192: LD_INT 0
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PUSH
81199: LD_INT 0
81201: PUSH
81202: LD_INT 1
81204: NEG
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 1
81212: PUSH
81213: LD_INT 0
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 1
81222: PUSH
81223: LD_INT 1
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 0
81232: PUSH
81233: LD_INT 1
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 1
81242: NEG
81243: PUSH
81244: LD_INT 0
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 1
81253: NEG
81254: PUSH
81255: LD_INT 1
81257: NEG
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 1
81265: NEG
81266: PUSH
81267: LD_INT 2
81269: NEG
81270: PUSH
81271: EMPTY
81272: LIST
81273: LIST
81274: PUSH
81275: LD_INT 0
81277: PUSH
81278: LD_INT 2
81280: NEG
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 1
81288: PUSH
81289: LD_INT 1
81291: NEG
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 2
81299: PUSH
81300: LD_INT 0
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 2
81309: PUSH
81310: LD_INT 1
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 2
81319: PUSH
81320: LD_INT 2
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 1
81329: PUSH
81330: LD_INT 2
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 0
81339: PUSH
81340: LD_INT 2
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 1
81349: NEG
81350: PUSH
81351: LD_INT 1
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 2
81360: NEG
81361: PUSH
81362: LD_INT 0
81364: PUSH
81365: EMPTY
81366: LIST
81367: LIST
81368: PUSH
81369: LD_INT 2
81371: NEG
81372: PUSH
81373: LD_INT 1
81375: NEG
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 2
81383: NEG
81384: PUSH
81385: LD_INT 2
81387: NEG
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: LIST
81397: LIST
81398: LIST
81399: LIST
81400: LIST
81401: LIST
81402: LIST
81403: LIST
81404: LIST
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81414: LD_ADDR_VAR 0 19
81418: PUSH
81419: LD_INT 0
81421: PUSH
81422: LD_INT 0
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 0
81431: PUSH
81432: LD_INT 1
81434: NEG
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_INT 1
81442: PUSH
81443: LD_INT 0
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 1
81452: PUSH
81453: LD_INT 1
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 0
81462: PUSH
81463: LD_INT 1
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 1
81472: NEG
81473: PUSH
81474: LD_INT 0
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 1
81483: NEG
81484: PUSH
81485: LD_INT 1
81487: NEG
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 1
81495: NEG
81496: PUSH
81497: LD_INT 2
81499: NEG
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: LD_INT 0
81507: PUSH
81508: LD_INT 2
81510: NEG
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 1
81518: PUSH
81519: LD_INT 1
81521: NEG
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: LD_INT 2
81529: PUSH
81530: LD_INT 0
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 2
81539: PUSH
81540: LD_INT 1
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 2
81549: PUSH
81550: LD_INT 2
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 1
81559: PUSH
81560: LD_INT 2
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 0
81569: PUSH
81570: LD_INT 2
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 1
81579: NEG
81580: PUSH
81581: LD_INT 1
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: LD_INT 2
81590: NEG
81591: PUSH
81592: LD_INT 0
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 2
81601: NEG
81602: PUSH
81603: LD_INT 1
81605: NEG
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 2
81613: NEG
81614: PUSH
81615: LD_INT 2
81617: NEG
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81644: LD_ADDR_VAR 0 20
81648: PUSH
81649: LD_INT 0
81651: PUSH
81652: LD_INT 0
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 0
81661: PUSH
81662: LD_INT 1
81664: NEG
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 1
81672: PUSH
81673: LD_INT 0
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: LD_INT 1
81682: PUSH
81683: LD_INT 1
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: PUSH
81690: LD_INT 0
81692: PUSH
81693: LD_INT 1
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: LD_INT 1
81702: NEG
81703: PUSH
81704: LD_INT 0
81706: PUSH
81707: EMPTY
81708: LIST
81709: LIST
81710: PUSH
81711: LD_INT 1
81713: NEG
81714: PUSH
81715: LD_INT 1
81717: NEG
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: PUSH
81723: LD_INT 1
81725: NEG
81726: PUSH
81727: LD_INT 2
81729: NEG
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 0
81737: PUSH
81738: LD_INT 2
81740: NEG
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 1
81748: PUSH
81749: LD_INT 1
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 2
81759: PUSH
81760: LD_INT 0
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 2
81769: PUSH
81770: LD_INT 1
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 2
81779: PUSH
81780: LD_INT 2
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 1
81789: PUSH
81790: LD_INT 2
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 0
81799: PUSH
81800: LD_INT 2
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 1
81809: NEG
81810: PUSH
81811: LD_INT 1
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 2
81820: NEG
81821: PUSH
81822: LD_INT 0
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 2
81831: NEG
81832: PUSH
81833: LD_INT 1
81835: NEG
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 2
81843: NEG
81844: PUSH
81845: LD_INT 2
81847: NEG
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: LIST
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81874: LD_ADDR_VAR 0 21
81878: PUSH
81879: LD_INT 0
81881: PUSH
81882: LD_INT 0
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PUSH
81889: LD_INT 0
81891: PUSH
81892: LD_INT 1
81894: NEG
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: LD_INT 1
81902: PUSH
81903: LD_INT 0
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 1
81912: PUSH
81913: LD_INT 1
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 0
81922: PUSH
81923: LD_INT 1
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 1
81932: NEG
81933: PUSH
81934: LD_INT 0
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 1
81943: NEG
81944: PUSH
81945: LD_INT 1
81947: NEG
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 1
81955: NEG
81956: PUSH
81957: LD_INT 2
81959: NEG
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 0
81967: PUSH
81968: LD_INT 2
81970: NEG
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 1
81978: PUSH
81979: LD_INT 1
81981: NEG
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 2
81989: PUSH
81990: LD_INT 0
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: LD_INT 2
81999: PUSH
82000: LD_INT 1
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 2
82009: PUSH
82010: LD_INT 2
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 1
82019: PUSH
82020: LD_INT 2
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 0
82029: PUSH
82030: LD_INT 2
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 1
82039: NEG
82040: PUSH
82041: LD_INT 1
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 2
82050: NEG
82051: PUSH
82052: LD_INT 0
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 2
82061: NEG
82062: PUSH
82063: LD_INT 1
82065: NEG
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 2
82073: NEG
82074: PUSH
82075: LD_INT 2
82077: NEG
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: LIST
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82104: LD_ADDR_VAR 0 22
82108: PUSH
82109: LD_INT 0
82111: PUSH
82112: LD_INT 0
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 0
82121: PUSH
82122: LD_INT 1
82124: NEG
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 1
82132: PUSH
82133: LD_INT 0
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 1
82142: PUSH
82143: LD_INT 1
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 0
82152: PUSH
82153: LD_INT 1
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 1
82162: NEG
82163: PUSH
82164: LD_INT 0
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: LD_INT 1
82177: NEG
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: PUSH
82183: LD_INT 1
82185: NEG
82186: PUSH
82187: LD_INT 2
82189: NEG
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 0
82197: PUSH
82198: LD_INT 2
82200: NEG
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 1
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 2
82219: PUSH
82220: LD_INT 0
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 2
82229: PUSH
82230: LD_INT 1
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 2
82239: PUSH
82240: LD_INT 2
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: LD_INT 2
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: PUSH
82257: LD_INT 0
82259: PUSH
82260: LD_INT 2
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: PUSH
82267: LD_INT 1
82269: NEG
82270: PUSH
82271: LD_INT 1
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 2
82280: NEG
82281: PUSH
82282: LD_INT 0
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 2
82291: NEG
82292: PUSH
82293: LD_INT 1
82295: NEG
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: LD_INT 2
82303: NEG
82304: PUSH
82305: LD_INT 2
82307: NEG
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: LIST
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82334: LD_ADDR_VAR 0 23
82338: PUSH
82339: LD_INT 0
82341: PUSH
82342: LD_INT 0
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 0
82351: PUSH
82352: LD_INT 1
82354: NEG
82355: PUSH
82356: EMPTY
82357: LIST
82358: LIST
82359: PUSH
82360: LD_INT 1
82362: PUSH
82363: LD_INT 0
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 1
82372: PUSH
82373: LD_INT 1
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: PUSH
82380: LD_INT 0
82382: PUSH
82383: LD_INT 1
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 1
82392: NEG
82393: PUSH
82394: LD_INT 0
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PUSH
82401: LD_INT 1
82403: NEG
82404: PUSH
82405: LD_INT 1
82407: NEG
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 1
82415: NEG
82416: PUSH
82417: LD_INT 2
82419: NEG
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 0
82427: PUSH
82428: LD_INT 2
82430: NEG
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 1
82438: PUSH
82439: LD_INT 1
82441: NEG
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 2
82449: PUSH
82450: LD_INT 0
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 2
82459: PUSH
82460: LD_INT 1
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 2
82469: PUSH
82470: LD_INT 2
82472: PUSH
82473: EMPTY
82474: LIST
82475: LIST
82476: PUSH
82477: LD_INT 1
82479: PUSH
82480: LD_INT 2
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 0
82489: PUSH
82490: LD_INT 2
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 1
82499: NEG
82500: PUSH
82501: LD_INT 1
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 2
82510: NEG
82511: PUSH
82512: LD_INT 0
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 2
82521: NEG
82522: PUSH
82523: LD_INT 1
82525: NEG
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 2
82533: NEG
82534: PUSH
82535: LD_INT 2
82537: NEG
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 2
82545: NEG
82546: PUSH
82547: LD_INT 3
82549: NEG
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 1
82557: NEG
82558: PUSH
82559: LD_INT 3
82561: NEG
82562: PUSH
82563: EMPTY
82564: LIST
82565: LIST
82566: PUSH
82567: LD_INT 1
82569: PUSH
82570: LD_INT 2
82572: NEG
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 2
82580: PUSH
82581: LD_INT 1
82583: NEG
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: LIST
82601: LIST
82602: LIST
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: LIST
82608: LIST
82609: LIST
82610: LIST
82611: LIST
82612: LIST
82613: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82614: LD_ADDR_VAR 0 24
82618: PUSH
82619: LD_INT 0
82621: PUSH
82622: LD_INT 0
82624: PUSH
82625: EMPTY
82626: LIST
82627: LIST
82628: PUSH
82629: LD_INT 0
82631: PUSH
82632: LD_INT 1
82634: NEG
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 1
82642: PUSH
82643: LD_INT 0
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 1
82652: PUSH
82653: LD_INT 1
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 0
82662: PUSH
82663: LD_INT 1
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 1
82672: NEG
82673: PUSH
82674: LD_INT 0
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 1
82683: NEG
82684: PUSH
82685: LD_INT 1
82687: NEG
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 1
82695: NEG
82696: PUSH
82697: LD_INT 2
82699: NEG
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 0
82707: PUSH
82708: LD_INT 2
82710: NEG
82711: PUSH
82712: EMPTY
82713: LIST
82714: LIST
82715: PUSH
82716: LD_INT 1
82718: PUSH
82719: LD_INT 1
82721: NEG
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 2
82729: PUSH
82730: LD_INT 0
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 2
82739: PUSH
82740: LD_INT 1
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PUSH
82747: LD_INT 2
82749: PUSH
82750: LD_INT 2
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: LD_INT 1
82759: PUSH
82760: LD_INT 2
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 0
82769: PUSH
82770: LD_INT 2
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 1
82779: NEG
82780: PUSH
82781: LD_INT 1
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 2
82790: NEG
82791: PUSH
82792: LD_INT 0
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 2
82801: NEG
82802: PUSH
82803: LD_INT 1
82805: NEG
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 2
82813: NEG
82814: PUSH
82815: LD_INT 2
82817: NEG
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 1
82825: PUSH
82826: LD_INT 2
82828: NEG
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 2
82836: PUSH
82837: LD_INT 1
82839: NEG
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 3
82847: PUSH
82848: LD_INT 1
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 3
82857: PUSH
82858: LD_INT 2
82860: PUSH
82861: EMPTY
82862: LIST
82863: LIST
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: LIST
82888: LIST
82889: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82890: LD_ADDR_VAR 0 25
82894: PUSH
82895: LD_INT 0
82897: PUSH
82898: LD_INT 0
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 0
82907: PUSH
82908: LD_INT 1
82910: NEG
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 1
82918: PUSH
82919: LD_INT 0
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 1
82928: PUSH
82929: LD_INT 1
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: LD_INT 0
82938: PUSH
82939: LD_INT 1
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 1
82948: NEG
82949: PUSH
82950: LD_INT 0
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 1
82959: NEG
82960: PUSH
82961: LD_INT 1
82963: NEG
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 1
82971: NEG
82972: PUSH
82973: LD_INT 2
82975: NEG
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 0
82983: PUSH
82984: LD_INT 2
82986: NEG
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: LD_INT 1
82994: PUSH
82995: LD_INT 1
82997: NEG
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 2
83005: PUSH
83006: LD_INT 0
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: PUSH
83013: LD_INT 2
83015: PUSH
83016: LD_INT 1
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: PUSH
83023: LD_INT 2
83025: PUSH
83026: LD_INT 2
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: LD_INT 2
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 0
83045: PUSH
83046: LD_INT 2
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 1
83055: NEG
83056: PUSH
83057: LD_INT 1
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 2
83066: NEG
83067: PUSH
83068: LD_INT 0
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 2
83077: NEG
83078: PUSH
83079: LD_INT 1
83081: NEG
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 2
83089: NEG
83090: PUSH
83091: LD_INT 2
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 3
83101: PUSH
83102: LD_INT 1
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 3
83111: PUSH
83112: LD_INT 2
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 2
83121: PUSH
83122: LD_INT 3
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 1
83131: PUSH
83132: LD_INT 3
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83164: LD_ADDR_VAR 0 26
83168: PUSH
83169: LD_INT 0
83171: PUSH
83172: LD_INT 0
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 0
83181: PUSH
83182: LD_INT 1
83184: NEG
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: PUSH
83190: LD_INT 1
83192: PUSH
83193: LD_INT 0
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 1
83202: PUSH
83203: LD_INT 1
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 0
83212: PUSH
83213: LD_INT 1
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 1
83222: NEG
83223: PUSH
83224: LD_INT 0
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 1
83233: NEG
83234: PUSH
83235: LD_INT 1
83237: NEG
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 1
83245: NEG
83246: PUSH
83247: LD_INT 2
83249: NEG
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 0
83257: PUSH
83258: LD_INT 2
83260: NEG
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: PUSH
83266: LD_INT 1
83268: PUSH
83269: LD_INT 1
83271: NEG
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 2
83279: PUSH
83280: LD_INT 0
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 2
83289: PUSH
83290: LD_INT 1
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 2
83299: PUSH
83300: LD_INT 2
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 1
83309: PUSH
83310: LD_INT 2
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 0
83319: PUSH
83320: LD_INT 2
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 1
83329: NEG
83330: PUSH
83331: LD_INT 1
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: PUSH
83338: LD_INT 2
83340: NEG
83341: PUSH
83342: LD_INT 0
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 2
83351: NEG
83352: PUSH
83353: LD_INT 1
83355: NEG
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 2
83363: NEG
83364: PUSH
83365: LD_INT 2
83367: NEG
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: LD_INT 2
83375: PUSH
83376: LD_INT 3
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 1
83385: PUSH
83386: LD_INT 3
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: LD_INT 1
83395: NEG
83396: PUSH
83397: LD_INT 2
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 2
83406: NEG
83407: PUSH
83408: LD_INT 1
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83440: LD_ADDR_VAR 0 27
83444: PUSH
83445: LD_INT 0
83447: PUSH
83448: LD_INT 0
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 0
83457: PUSH
83458: LD_INT 1
83460: NEG
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 1
83468: PUSH
83469: LD_INT 0
83471: PUSH
83472: EMPTY
83473: LIST
83474: LIST
83475: PUSH
83476: LD_INT 1
83478: PUSH
83479: LD_INT 1
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 0
83488: PUSH
83489: LD_INT 1
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 1
83498: NEG
83499: PUSH
83500: LD_INT 0
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 1
83509: NEG
83510: PUSH
83511: LD_INT 1
83513: NEG
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 1
83521: NEG
83522: PUSH
83523: LD_INT 2
83525: NEG
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 0
83533: PUSH
83534: LD_INT 2
83536: NEG
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 1
83544: PUSH
83545: LD_INT 1
83547: NEG
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 2
83555: PUSH
83556: LD_INT 0
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 2
83565: PUSH
83566: LD_INT 1
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 2
83575: PUSH
83576: LD_INT 2
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 1
83585: PUSH
83586: LD_INT 2
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 0
83595: PUSH
83596: LD_INT 2
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 1
83605: NEG
83606: PUSH
83607: LD_INT 1
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PUSH
83614: LD_INT 2
83616: NEG
83617: PUSH
83618: LD_INT 0
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: LD_INT 2
83627: NEG
83628: PUSH
83629: LD_INT 1
83631: NEG
83632: PUSH
83633: EMPTY
83634: LIST
83635: LIST
83636: PUSH
83637: LD_INT 2
83639: NEG
83640: PUSH
83641: LD_INT 2
83643: NEG
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 1
83651: NEG
83652: PUSH
83653: LD_INT 2
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 2
83662: NEG
83663: PUSH
83664: LD_INT 1
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: LD_INT 3
83673: NEG
83674: PUSH
83675: LD_INT 1
83677: NEG
83678: PUSH
83679: EMPTY
83680: LIST
83681: LIST
83682: PUSH
83683: LD_INT 3
83685: NEG
83686: PUSH
83687: LD_INT 2
83689: NEG
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83720: LD_ADDR_VAR 0 28
83724: PUSH
83725: LD_INT 0
83727: PUSH
83728: LD_INT 0
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: LD_INT 0
83737: PUSH
83738: LD_INT 1
83740: NEG
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 1
83748: PUSH
83749: LD_INT 0
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 1
83758: PUSH
83759: LD_INT 1
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 0
83768: PUSH
83769: LD_INT 1
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 1
83778: NEG
83779: PUSH
83780: LD_INT 0
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 1
83789: NEG
83790: PUSH
83791: LD_INT 1
83793: NEG
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 1
83801: NEG
83802: PUSH
83803: LD_INT 2
83805: NEG
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: PUSH
83811: LD_INT 0
83813: PUSH
83814: LD_INT 2
83816: NEG
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: LD_INT 1
83824: PUSH
83825: LD_INT 1
83827: NEG
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: PUSH
83833: LD_INT 2
83835: PUSH
83836: LD_INT 0
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 2
83845: PUSH
83846: LD_INT 1
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: PUSH
83853: LD_INT 2
83855: PUSH
83856: LD_INT 2
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: PUSH
83863: LD_INT 1
83865: PUSH
83866: LD_INT 2
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 0
83875: PUSH
83876: LD_INT 2
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 1
83885: NEG
83886: PUSH
83887: LD_INT 1
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 2
83896: NEG
83897: PUSH
83898: LD_INT 0
83900: PUSH
83901: EMPTY
83902: LIST
83903: LIST
83904: PUSH
83905: LD_INT 2
83907: NEG
83908: PUSH
83909: LD_INT 1
83911: NEG
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 2
83919: NEG
83920: PUSH
83921: LD_INT 2
83923: NEG
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: LD_INT 2
83931: NEG
83932: PUSH
83933: LD_INT 3
83935: NEG
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 1
83943: NEG
83944: PUSH
83945: LD_INT 3
83947: NEG
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 3
83955: NEG
83956: PUSH
83957: LD_INT 1
83959: NEG
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 3
83967: NEG
83968: PUSH
83969: LD_INT 2
83971: NEG
83972: PUSH
83973: EMPTY
83974: LIST
83975: LIST
83976: PUSH
83977: EMPTY
83978: LIST
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84002: LD_ADDR_VAR 0 29
84006: PUSH
84007: LD_INT 0
84009: PUSH
84010: LD_INT 0
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 0
84019: PUSH
84020: LD_INT 1
84022: NEG
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: LD_INT 1
84030: PUSH
84031: LD_INT 0
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PUSH
84038: LD_INT 1
84040: PUSH
84041: LD_INT 1
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: PUSH
84048: LD_INT 0
84050: PUSH
84051: LD_INT 1
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: LD_INT 1
84060: NEG
84061: PUSH
84062: LD_INT 0
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 1
84071: NEG
84072: PUSH
84073: LD_INT 1
84075: NEG
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 1
84083: NEG
84084: PUSH
84085: LD_INT 2
84087: NEG
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 0
84095: PUSH
84096: LD_INT 2
84098: NEG
84099: PUSH
84100: EMPTY
84101: LIST
84102: LIST
84103: PUSH
84104: LD_INT 1
84106: PUSH
84107: LD_INT 1
84109: NEG
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 2
84117: PUSH
84118: LD_INT 0
84120: PUSH
84121: EMPTY
84122: LIST
84123: LIST
84124: PUSH
84125: LD_INT 2
84127: PUSH
84128: LD_INT 1
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: PUSH
84135: LD_INT 1
84137: PUSH
84138: LD_INT 2
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 0
84147: PUSH
84148: LD_INT 2
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: PUSH
84155: LD_INT 1
84157: NEG
84158: PUSH
84159: LD_INT 1
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 2
84168: NEG
84169: PUSH
84170: LD_INT 1
84172: NEG
84173: PUSH
84174: EMPTY
84175: LIST
84176: LIST
84177: PUSH
84178: LD_INT 2
84180: NEG
84181: PUSH
84182: LD_INT 2
84184: NEG
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: PUSH
84190: LD_INT 2
84192: NEG
84193: PUSH
84194: LD_INT 3
84196: NEG
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 2
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 3
84215: PUSH
84216: LD_INT 1
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 1
84225: PUSH
84226: LD_INT 3
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 1
84235: NEG
84236: PUSH
84237: LD_INT 2
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 3
84246: NEG
84247: PUSH
84248: LD_INT 2
84250: NEG
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: LIST
84260: LIST
84261: LIST
84262: LIST
84263: LIST
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84281: LD_ADDR_VAR 0 30
84285: PUSH
84286: LD_INT 0
84288: PUSH
84289: LD_INT 0
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: PUSH
84296: LD_INT 0
84298: PUSH
84299: LD_INT 1
84301: NEG
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: LD_INT 1
84309: PUSH
84310: LD_INT 0
84312: PUSH
84313: EMPTY
84314: LIST
84315: LIST
84316: PUSH
84317: LD_INT 1
84319: PUSH
84320: LD_INT 1
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 0
84329: PUSH
84330: LD_INT 1
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 1
84339: NEG
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: LD_INT 1
84354: NEG
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 1
84362: NEG
84363: PUSH
84364: LD_INT 2
84366: NEG
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 0
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 1
84385: PUSH
84386: LD_INT 1
84388: NEG
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 2
84396: PUSH
84397: LD_INT 0
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 2
84406: PUSH
84407: LD_INT 1
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 2
84416: PUSH
84417: LD_INT 2
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 1
84426: PUSH
84427: LD_INT 2
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 1
84436: NEG
84437: PUSH
84438: LD_INT 1
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 2
84447: NEG
84448: PUSH
84449: LD_INT 0
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 2
84458: NEG
84459: PUSH
84460: LD_INT 1
84462: NEG
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 1
84470: NEG
84471: PUSH
84472: LD_INT 3
84474: NEG
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 1
84482: PUSH
84483: LD_INT 2
84485: NEG
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 3
84493: PUSH
84494: LD_INT 2
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 2
84503: PUSH
84504: LD_INT 3
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 2
84513: NEG
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 3
84524: NEG
84525: PUSH
84526: LD_INT 1
84528: NEG
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: LIST
84556: LIST
84557: LIST
84558: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84559: LD_ADDR_VAR 0 31
84563: PUSH
84564: LD_INT 0
84566: PUSH
84567: LD_INT 0
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 0
84576: PUSH
84577: LD_INT 1
84579: NEG
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 1
84587: PUSH
84588: LD_INT 0
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 1
84597: PUSH
84598: LD_INT 1
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 0
84607: PUSH
84608: LD_INT 1
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: PUSH
84615: LD_INT 1
84617: NEG
84618: PUSH
84619: LD_INT 0
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: LD_INT 1
84632: NEG
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 1
84640: NEG
84641: PUSH
84642: LD_INT 2
84644: NEG
84645: PUSH
84646: EMPTY
84647: LIST
84648: LIST
84649: PUSH
84650: LD_INT 1
84652: PUSH
84653: LD_INT 1
84655: NEG
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 2
84663: PUSH
84664: LD_INT 0
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 2
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 2
84683: PUSH
84684: LD_INT 2
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 1
84693: PUSH
84694: LD_INT 2
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 0
84703: PUSH
84704: LD_INT 2
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: PUSH
84711: LD_INT 1
84713: NEG
84714: PUSH
84715: LD_INT 1
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 2
84724: NEG
84725: PUSH
84726: LD_INT 1
84728: NEG
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: PUSH
84734: LD_INT 2
84736: NEG
84737: PUSH
84738: LD_INT 2
84740: NEG
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: PUSH
84746: LD_INT 2
84748: NEG
84749: PUSH
84750: LD_INT 3
84752: NEG
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: PUSH
84758: LD_INT 2
84760: PUSH
84761: LD_INT 1
84763: NEG
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PUSH
84769: LD_INT 3
84771: PUSH
84772: LD_INT 1
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 1
84781: PUSH
84782: LD_INT 3
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 1
84791: NEG
84792: PUSH
84793: LD_INT 2
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 3
84802: NEG
84803: PUSH
84804: LD_INT 2
84806: NEG
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84837: LD_ADDR_VAR 0 32
84841: PUSH
84842: LD_INT 0
84844: PUSH
84845: LD_INT 0
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: PUSH
84852: LD_INT 0
84854: PUSH
84855: LD_INT 1
84857: NEG
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 1
84865: PUSH
84866: LD_INT 0
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 1
84875: PUSH
84876: LD_INT 1
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 0
84885: PUSH
84886: LD_INT 1
84888: PUSH
84889: EMPTY
84890: LIST
84891: LIST
84892: PUSH
84893: LD_INT 1
84895: NEG
84896: PUSH
84897: LD_INT 0
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 1
84906: NEG
84907: PUSH
84908: LD_INT 1
84910: NEG
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: NEG
84919: PUSH
84920: LD_INT 2
84922: NEG
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 0
84930: PUSH
84931: LD_INT 2
84933: NEG
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: PUSH
84942: LD_INT 1
84944: NEG
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 2
84952: PUSH
84953: LD_INT 1
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 2
84962: PUSH
84963: LD_INT 2
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 1
84972: PUSH
84973: LD_INT 2
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 0
84982: PUSH
84983: LD_INT 2
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 1
84992: NEG
84993: PUSH
84994: LD_INT 1
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 2
85003: NEG
85004: PUSH
85005: LD_INT 0
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 2
85014: NEG
85015: PUSH
85016: LD_INT 1
85018: NEG
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: LD_INT 1
85026: NEG
85027: PUSH
85028: LD_INT 3
85030: NEG
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 1
85038: PUSH
85039: LD_INT 2
85041: NEG
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 3
85049: PUSH
85050: LD_INT 2
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 2
85059: PUSH
85060: LD_INT 3
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 2
85069: NEG
85070: PUSH
85071: LD_INT 1
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 3
85080: NEG
85081: PUSH
85082: LD_INT 1
85084: NEG
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85115: LD_ADDR_VAR 0 33
85119: PUSH
85120: LD_INT 0
85122: PUSH
85123: LD_INT 0
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 0
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 1
85143: PUSH
85144: LD_INT 0
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: LD_INT 1
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 0
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 1
85173: NEG
85174: PUSH
85175: LD_INT 0
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 1
85184: NEG
85185: PUSH
85186: LD_INT 1
85188: NEG
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: LD_INT 1
85196: NEG
85197: PUSH
85198: LD_INT 2
85200: NEG
85201: PUSH
85202: EMPTY
85203: LIST
85204: LIST
85205: PUSH
85206: LD_INT 1
85208: PUSH
85209: LD_INT 1
85211: NEG
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: PUSH
85217: LD_INT 2
85219: PUSH
85220: LD_INT 0
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 2
85229: PUSH
85230: LD_INT 1
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 1
85239: PUSH
85240: LD_INT 2
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 0
85249: PUSH
85250: LD_INT 2
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_INT 1
85259: NEG
85260: PUSH
85261: LD_INT 1
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: PUSH
85268: LD_INT 2
85270: NEG
85271: PUSH
85272: LD_INT 0
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 2
85281: NEG
85282: PUSH
85283: LD_INT 1
85285: NEG
85286: PUSH
85287: EMPTY
85288: LIST
85289: LIST
85290: PUSH
85291: LD_INT 2
85293: NEG
85294: PUSH
85295: LD_INT 2
85297: NEG
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: PUSH
85303: LD_INT 2
85305: NEG
85306: PUSH
85307: LD_INT 3
85309: NEG
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: LD_INT 2
85317: PUSH
85318: LD_INT 1
85320: NEG
85321: PUSH
85322: EMPTY
85323: LIST
85324: LIST
85325: PUSH
85326: LD_INT 3
85328: PUSH
85329: LD_INT 1
85331: PUSH
85332: EMPTY
85333: LIST
85334: LIST
85335: PUSH
85336: LD_INT 1
85338: PUSH
85339: LD_INT 3
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 1
85348: NEG
85349: PUSH
85350: LD_INT 2
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: PUSH
85357: LD_INT 3
85359: NEG
85360: PUSH
85361: LD_INT 2
85363: NEG
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: LIST
85393: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85394: LD_ADDR_VAR 0 34
85398: PUSH
85399: LD_INT 0
85401: PUSH
85402: LD_INT 0
85404: PUSH
85405: EMPTY
85406: LIST
85407: LIST
85408: PUSH
85409: LD_INT 0
85411: PUSH
85412: LD_INT 1
85414: NEG
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 1
85422: PUSH
85423: LD_INT 0
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 1
85432: PUSH
85433: LD_INT 1
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 0
85442: PUSH
85443: LD_INT 1
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 1
85452: NEG
85453: PUSH
85454: LD_INT 0
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 1
85463: NEG
85464: PUSH
85465: LD_INT 1
85467: NEG
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 1
85475: NEG
85476: PUSH
85477: LD_INT 2
85479: NEG
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 0
85487: PUSH
85488: LD_INT 2
85490: NEG
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: LD_INT 1
85498: PUSH
85499: LD_INT 1
85501: NEG
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: PUSH
85507: LD_INT 2
85509: PUSH
85510: LD_INT 1
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 2
85519: PUSH
85520: LD_INT 2
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 1
85529: PUSH
85530: LD_INT 2
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 1
85539: NEG
85540: PUSH
85541: LD_INT 1
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 2
85550: NEG
85551: PUSH
85552: LD_INT 0
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 2
85561: NEG
85562: PUSH
85563: LD_INT 1
85565: NEG
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: PUSH
85571: LD_INT 2
85573: NEG
85574: PUSH
85575: LD_INT 2
85577: NEG
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 1
85585: NEG
85586: PUSH
85587: LD_INT 3
85589: NEG
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: PUSH
85595: LD_INT 1
85597: PUSH
85598: LD_INT 2
85600: NEG
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 3
85608: PUSH
85609: LD_INT 2
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: LD_INT 2
85618: PUSH
85619: LD_INT 3
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 2
85628: NEG
85629: PUSH
85630: LD_INT 1
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 3
85639: NEG
85640: PUSH
85641: LD_INT 1
85643: NEG
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: LIST
85657: LIST
85658: LIST
85659: LIST
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85674: LD_ADDR_VAR 0 35
85678: PUSH
85679: LD_INT 0
85681: PUSH
85682: LD_INT 0
85684: PUSH
85685: EMPTY
85686: LIST
85687: LIST
85688: PUSH
85689: LD_INT 0
85691: PUSH
85692: LD_INT 1
85694: NEG
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 1
85702: PUSH
85703: LD_INT 0
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 1
85712: PUSH
85713: LD_INT 1
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: LD_INT 0
85722: PUSH
85723: LD_INT 1
85725: PUSH
85726: EMPTY
85727: LIST
85728: LIST
85729: PUSH
85730: LD_INT 1
85732: NEG
85733: PUSH
85734: LD_INT 0
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: PUSH
85741: LD_INT 1
85743: NEG
85744: PUSH
85745: LD_INT 1
85747: NEG
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 2
85755: PUSH
85756: LD_INT 1
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: PUSH
85763: LD_INT 2
85765: NEG
85766: PUSH
85767: LD_INT 1
85769: NEG
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85786: LD_ADDR_VAR 0 36
85790: PUSH
85791: LD_INT 0
85793: PUSH
85794: LD_INT 0
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: LD_INT 0
85803: PUSH
85804: LD_INT 1
85806: NEG
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 1
85814: PUSH
85815: LD_INT 0
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: PUSH
85825: LD_INT 1
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: PUSH
85832: LD_INT 0
85834: PUSH
85835: LD_INT 1
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 1
85844: NEG
85845: PUSH
85846: LD_INT 0
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: PUSH
85853: LD_INT 1
85855: NEG
85856: PUSH
85857: LD_INT 1
85859: NEG
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 1
85867: NEG
85868: PUSH
85869: LD_INT 2
85871: NEG
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 1
85879: PUSH
85880: LD_INT 2
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85898: LD_ADDR_VAR 0 37
85902: PUSH
85903: LD_INT 0
85905: PUSH
85906: LD_INT 0
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: LD_INT 1
85918: NEG
85919: PUSH
85920: EMPTY
85921: LIST
85922: LIST
85923: PUSH
85924: LD_INT 1
85926: PUSH
85927: LD_INT 0
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 1
85936: PUSH
85937: LD_INT 1
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 0
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 1
85956: NEG
85957: PUSH
85958: LD_INT 0
85960: PUSH
85961: EMPTY
85962: LIST
85963: LIST
85964: PUSH
85965: LD_INT 1
85967: NEG
85968: PUSH
85969: LD_INT 1
85971: NEG
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: PUSH
85977: LD_INT 1
85979: PUSH
85980: LD_INT 1
85982: NEG
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 1
85990: NEG
85991: PUSH
85992: LD_INT 1
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: LIST
86003: LIST
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86010: LD_ADDR_VAR 0 38
86014: PUSH
86015: LD_INT 0
86017: PUSH
86018: LD_INT 0
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 0
86027: PUSH
86028: LD_INT 1
86030: NEG
86031: PUSH
86032: EMPTY
86033: LIST
86034: LIST
86035: PUSH
86036: LD_INT 1
86038: PUSH
86039: LD_INT 0
86041: PUSH
86042: EMPTY
86043: LIST
86044: LIST
86045: PUSH
86046: LD_INT 1
86048: PUSH
86049: LD_INT 1
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 0
86058: PUSH
86059: LD_INT 1
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 1
86068: NEG
86069: PUSH
86070: LD_INT 0
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: PUSH
86077: LD_INT 1
86079: NEG
86080: PUSH
86081: LD_INT 1
86083: NEG
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 2
86091: PUSH
86092: LD_INT 1
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 2
86101: NEG
86102: PUSH
86103: LD_INT 1
86105: NEG
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86122: LD_ADDR_VAR 0 39
86126: PUSH
86127: LD_INT 0
86129: PUSH
86130: LD_INT 0
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 0
86139: PUSH
86140: LD_INT 1
86142: NEG
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: PUSH
86148: LD_INT 1
86150: PUSH
86151: LD_INT 0
86153: PUSH
86154: EMPTY
86155: LIST
86156: LIST
86157: PUSH
86158: LD_INT 1
86160: PUSH
86161: LD_INT 1
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 0
86170: PUSH
86171: LD_INT 1
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: LD_INT 1
86180: NEG
86181: PUSH
86182: LD_INT 0
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: PUSH
86189: LD_INT 1
86191: NEG
86192: PUSH
86193: LD_INT 1
86195: NEG
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 1
86203: NEG
86204: PUSH
86205: LD_INT 2
86207: NEG
86208: PUSH
86209: EMPTY
86210: LIST
86211: LIST
86212: PUSH
86213: LD_INT 1
86215: PUSH
86216: LD_INT 2
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86234: LD_ADDR_VAR 0 40
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: LD_INT 0
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 0
86251: PUSH
86252: LD_INT 1
86254: NEG
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 1
86262: PUSH
86263: LD_INT 0
86265: PUSH
86266: EMPTY
86267: LIST
86268: LIST
86269: PUSH
86270: LD_INT 1
86272: PUSH
86273: LD_INT 1
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 0
86282: PUSH
86283: LD_INT 1
86285: PUSH
86286: EMPTY
86287: LIST
86288: LIST
86289: PUSH
86290: LD_INT 1
86292: NEG
86293: PUSH
86294: LD_INT 0
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 1
86303: NEG
86304: PUSH
86305: LD_INT 1
86307: NEG
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: PUSH
86313: LD_INT 1
86315: PUSH
86316: LD_INT 1
86318: NEG
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: PUSH
86328: LD_INT 1
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86346: LD_ADDR_VAR 0 41
86350: PUSH
86351: LD_INT 0
86353: PUSH
86354: LD_INT 0
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PUSH
86361: LD_INT 0
86363: PUSH
86364: LD_INT 1
86366: NEG
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: PUSH
86372: LD_INT 1
86374: PUSH
86375: LD_INT 0
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 1
86384: PUSH
86385: LD_INT 1
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: PUSH
86392: LD_INT 0
86394: PUSH
86395: LD_INT 1
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: LD_INT 1
86404: NEG
86405: PUSH
86406: LD_INT 0
86408: PUSH
86409: EMPTY
86410: LIST
86411: LIST
86412: PUSH
86413: LD_INT 1
86415: NEG
86416: PUSH
86417: LD_INT 1
86419: NEG
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: PUSH
86425: LD_INT 1
86427: NEG
86428: PUSH
86429: LD_INT 2
86431: NEG
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: PUSH
86437: LD_INT 1
86439: PUSH
86440: LD_INT 1
86442: NEG
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PUSH
86448: LD_INT 2
86450: PUSH
86451: LD_INT 0
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 2
86460: PUSH
86461: LD_INT 1
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 2
86470: PUSH
86471: LD_INT 2
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 1
86480: PUSH
86481: LD_INT 2
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 1
86490: NEG
86491: PUSH
86492: LD_INT 1
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 2
86501: NEG
86502: PUSH
86503: LD_INT 0
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 2
86512: NEG
86513: PUSH
86514: LD_INT 1
86516: NEG
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: PUSH
86522: LD_INT 2
86524: NEG
86525: PUSH
86526: LD_INT 2
86528: NEG
86529: PUSH
86530: EMPTY
86531: LIST
86532: LIST
86533: PUSH
86534: LD_INT 2
86536: NEG
86537: PUSH
86538: LD_INT 3
86540: NEG
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: PUSH
86546: LD_INT 2
86548: PUSH
86549: LD_INT 1
86551: NEG
86552: PUSH
86553: EMPTY
86554: LIST
86555: LIST
86556: PUSH
86557: LD_INT 3
86559: PUSH
86560: LD_INT 0
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: LD_INT 3
86569: PUSH
86570: LD_INT 1
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 3
86579: PUSH
86580: LD_INT 2
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 3
86589: PUSH
86590: LD_INT 3
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 2
86599: PUSH
86600: LD_INT 3
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 2
86609: NEG
86610: PUSH
86611: LD_INT 1
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 3
86620: NEG
86621: PUSH
86622: LD_INT 0
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 3
86631: NEG
86632: PUSH
86633: LD_INT 1
86635: NEG
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: PUSH
86641: LD_INT 3
86643: NEG
86644: PUSH
86645: LD_INT 2
86647: NEG
86648: PUSH
86649: EMPTY
86650: LIST
86651: LIST
86652: PUSH
86653: LD_INT 3
86655: NEG
86656: PUSH
86657: LD_INT 3
86659: NEG
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86696: LD_ADDR_VAR 0 42
86700: PUSH
86701: LD_INT 0
86703: PUSH
86704: LD_INT 0
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: PUSH
86711: LD_INT 0
86713: PUSH
86714: LD_INT 1
86716: NEG
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: LD_INT 1
86724: PUSH
86725: LD_INT 0
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PUSH
86732: LD_INT 1
86734: PUSH
86735: LD_INT 1
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PUSH
86742: LD_INT 0
86744: PUSH
86745: LD_INT 1
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PUSH
86752: LD_INT 1
86754: NEG
86755: PUSH
86756: LD_INT 0
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 1
86765: NEG
86766: PUSH
86767: LD_INT 1
86769: NEG
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 1
86777: NEG
86778: PUSH
86779: LD_INT 2
86781: NEG
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 0
86789: PUSH
86790: LD_INT 2
86792: NEG
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: PUSH
86798: LD_INT 1
86800: PUSH
86801: LD_INT 1
86803: NEG
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 2
86811: PUSH
86812: LD_INT 1
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PUSH
86819: LD_INT 2
86821: PUSH
86822: LD_INT 2
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 1
86831: PUSH
86832: LD_INT 2
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PUSH
86839: LD_INT 0
86841: PUSH
86842: LD_INT 2
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 1
86851: NEG
86852: PUSH
86853: LD_INT 1
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: PUSH
86860: LD_INT 2
86862: NEG
86863: PUSH
86864: LD_INT 1
86866: NEG
86867: PUSH
86868: EMPTY
86869: LIST
86870: LIST
86871: PUSH
86872: LD_INT 2
86874: NEG
86875: PUSH
86876: LD_INT 2
86878: NEG
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PUSH
86884: LD_INT 2
86886: NEG
86887: PUSH
86888: LD_INT 3
86890: NEG
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PUSH
86896: LD_INT 1
86898: NEG
86899: PUSH
86900: LD_INT 3
86902: NEG
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 0
86910: PUSH
86911: LD_INT 3
86913: NEG
86914: PUSH
86915: EMPTY
86916: LIST
86917: LIST
86918: PUSH
86919: LD_INT 1
86921: PUSH
86922: LD_INT 2
86924: NEG
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PUSH
86930: LD_INT 3
86932: PUSH
86933: LD_INT 2
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 3
86942: PUSH
86943: LD_INT 3
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 2
86952: PUSH
86953: LD_INT 3
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 1
86962: PUSH
86963: LD_INT 3
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 0
86972: PUSH
86973: LD_INT 3
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 1
86982: NEG
86983: PUSH
86984: LD_INT 2
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: LD_INT 3
86993: NEG
86994: PUSH
86995: LD_INT 2
86997: NEG
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: PUSH
87003: LD_INT 3
87005: NEG
87006: PUSH
87007: LD_INT 3
87009: NEG
87010: PUSH
87011: EMPTY
87012: LIST
87013: LIST
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87046: LD_ADDR_VAR 0 43
87050: PUSH
87051: LD_INT 0
87053: PUSH
87054: LD_INT 0
87056: PUSH
87057: EMPTY
87058: LIST
87059: LIST
87060: PUSH
87061: LD_INT 0
87063: PUSH
87064: LD_INT 1
87066: NEG
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: PUSH
87072: LD_INT 1
87074: PUSH
87075: LD_INT 0
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 1
87084: PUSH
87085: LD_INT 1
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 0
87094: PUSH
87095: LD_INT 1
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 1
87104: NEG
87105: PUSH
87106: LD_INT 0
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 1
87115: NEG
87116: PUSH
87117: LD_INT 1
87119: NEG
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: LD_INT 1
87127: NEG
87128: PUSH
87129: LD_INT 2
87131: NEG
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: PUSH
87137: LD_INT 0
87139: PUSH
87140: LD_INT 2
87142: NEG
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: LD_INT 1
87150: PUSH
87151: LD_INT 1
87153: NEG
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 2
87161: PUSH
87162: LD_INT 0
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 2
87171: PUSH
87172: LD_INT 1
87174: PUSH
87175: EMPTY
87176: LIST
87177: LIST
87178: PUSH
87179: LD_INT 1
87181: PUSH
87182: LD_INT 2
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 0
87191: PUSH
87192: LD_INT 2
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: LD_INT 1
87201: NEG
87202: PUSH
87203: LD_INT 1
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: PUSH
87210: LD_INT 2
87212: NEG
87213: PUSH
87214: LD_INT 0
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 2
87223: NEG
87224: PUSH
87225: LD_INT 1
87227: NEG
87228: PUSH
87229: EMPTY
87230: LIST
87231: LIST
87232: PUSH
87233: LD_INT 1
87235: NEG
87236: PUSH
87237: LD_INT 3
87239: NEG
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 0
87247: PUSH
87248: LD_INT 3
87250: NEG
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PUSH
87256: LD_INT 1
87258: PUSH
87259: LD_INT 2
87261: NEG
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: LD_INT 2
87269: PUSH
87270: LD_INT 1
87272: NEG
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 3
87280: PUSH
87281: LD_INT 0
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 3
87290: PUSH
87291: LD_INT 1
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: LD_INT 3
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 0
87310: PUSH
87311: LD_INT 3
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 1
87320: NEG
87321: PUSH
87322: LD_INT 2
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 2
87331: NEG
87332: PUSH
87333: LD_INT 1
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 3
87342: NEG
87343: PUSH
87344: LD_INT 0
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: LD_INT 3
87353: NEG
87354: PUSH
87355: LD_INT 1
87357: NEG
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PUSH
87363: EMPTY
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: LIST
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87394: LD_ADDR_VAR 0 44
87398: PUSH
87399: LD_INT 0
87401: PUSH
87402: LD_INT 0
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: PUSH
87409: LD_INT 0
87411: PUSH
87412: LD_INT 1
87414: NEG
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 1
87422: PUSH
87423: LD_INT 0
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 1
87432: PUSH
87433: LD_INT 1
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 0
87442: PUSH
87443: LD_INT 1
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 1
87452: NEG
87453: PUSH
87454: LD_INT 0
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 1
87463: NEG
87464: PUSH
87465: LD_INT 1
87467: NEG
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: LD_INT 1
87475: NEG
87476: PUSH
87477: LD_INT 2
87479: NEG
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: LD_INT 1
87490: NEG
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 2
87498: PUSH
87499: LD_INT 0
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 2
87508: PUSH
87509: LD_INT 1
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 2
87518: PUSH
87519: LD_INT 2
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 1
87528: PUSH
87529: LD_INT 2
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: PUSH
87536: LD_INT 1
87538: NEG
87539: PUSH
87540: LD_INT 1
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 2
87549: NEG
87550: PUSH
87551: LD_INT 0
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 2
87560: NEG
87561: PUSH
87562: LD_INT 1
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 2
87572: NEG
87573: PUSH
87574: LD_INT 2
87576: NEG
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 2
87584: NEG
87585: PUSH
87586: LD_INT 3
87588: NEG
87589: PUSH
87590: EMPTY
87591: LIST
87592: LIST
87593: PUSH
87594: LD_INT 2
87596: PUSH
87597: LD_INT 1
87599: NEG
87600: PUSH
87601: EMPTY
87602: LIST
87603: LIST
87604: PUSH
87605: LD_INT 3
87607: PUSH
87608: LD_INT 0
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: LD_INT 3
87617: PUSH
87618: LD_INT 1
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 3
87627: PUSH
87628: LD_INT 2
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 3
87637: PUSH
87638: LD_INT 3
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 2
87647: PUSH
87648: LD_INT 3
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 2
87657: NEG
87658: PUSH
87659: LD_INT 1
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 3
87668: NEG
87669: PUSH
87670: LD_INT 0
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: LD_INT 3
87679: NEG
87680: PUSH
87681: LD_INT 1
87683: NEG
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 3
87691: NEG
87692: PUSH
87693: LD_INT 2
87695: NEG
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 3
87703: NEG
87704: PUSH
87705: LD_INT 3
87707: NEG
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: PUSH
87713: EMPTY
87714: LIST
87715: LIST
87716: LIST
87717: LIST
87718: LIST
87719: LIST
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87744: LD_ADDR_VAR 0 45
87748: PUSH
87749: LD_INT 0
87751: PUSH
87752: LD_INT 0
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 0
87761: PUSH
87762: LD_INT 1
87764: NEG
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 1
87772: PUSH
87773: LD_INT 0
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 1
87782: PUSH
87783: LD_INT 1
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 0
87792: PUSH
87793: LD_INT 1
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: NEG
87803: PUSH
87804: LD_INT 0
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: LD_INT 1
87817: NEG
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 1
87825: NEG
87826: PUSH
87827: LD_INT 2
87829: NEG
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 0
87837: PUSH
87838: LD_INT 2
87840: NEG
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 1
87848: PUSH
87849: LD_INT 1
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 2
87859: PUSH
87860: LD_INT 1
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 2
87869: PUSH
87870: LD_INT 2
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 1
87879: PUSH
87880: LD_INT 2
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 0
87889: PUSH
87890: LD_INT 2
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 1
87899: NEG
87900: PUSH
87901: LD_INT 1
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 2
87910: NEG
87911: PUSH
87912: LD_INT 1
87914: NEG
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: PUSH
87920: LD_INT 2
87922: NEG
87923: PUSH
87924: LD_INT 2
87926: NEG
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 2
87934: NEG
87935: PUSH
87936: LD_INT 3
87938: NEG
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 1
87946: NEG
87947: PUSH
87948: LD_INT 3
87950: NEG
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 0
87958: PUSH
87959: LD_INT 3
87961: NEG
87962: PUSH
87963: EMPTY
87964: LIST
87965: LIST
87966: PUSH
87967: LD_INT 1
87969: PUSH
87970: LD_INT 2
87972: NEG
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 3
87980: PUSH
87981: LD_INT 2
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 3
87990: PUSH
87991: LD_INT 3
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 2
88000: PUSH
88001: LD_INT 3
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 1
88010: PUSH
88011: LD_INT 3
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 0
88020: PUSH
88021: LD_INT 3
88023: PUSH
88024: EMPTY
88025: LIST
88026: LIST
88027: PUSH
88028: LD_INT 1
88030: NEG
88031: PUSH
88032: LD_INT 2
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: LD_INT 3
88041: NEG
88042: PUSH
88043: LD_INT 2
88045: NEG
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PUSH
88051: LD_INT 3
88053: NEG
88054: PUSH
88055: LD_INT 3
88057: NEG
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: LIST
88072: LIST
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88094: LD_ADDR_VAR 0 46
88098: PUSH
88099: LD_INT 0
88101: PUSH
88102: LD_INT 0
88104: PUSH
88105: EMPTY
88106: LIST
88107: LIST
88108: PUSH
88109: LD_INT 0
88111: PUSH
88112: LD_INT 1
88114: NEG
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: LD_INT 1
88122: PUSH
88123: LD_INT 0
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 1
88132: PUSH
88133: LD_INT 1
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PUSH
88140: LD_INT 0
88142: PUSH
88143: LD_INT 1
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 1
88152: NEG
88153: PUSH
88154: LD_INT 0
88156: PUSH
88157: EMPTY
88158: LIST
88159: LIST
88160: PUSH
88161: LD_INT 1
88163: NEG
88164: PUSH
88165: LD_INT 1
88167: NEG
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PUSH
88173: LD_INT 1
88175: NEG
88176: PUSH
88177: LD_INT 2
88179: NEG
88180: PUSH
88181: EMPTY
88182: LIST
88183: LIST
88184: PUSH
88185: LD_INT 0
88187: PUSH
88188: LD_INT 2
88190: NEG
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: PUSH
88196: LD_INT 1
88198: PUSH
88199: LD_INT 1
88201: NEG
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 2
88209: PUSH
88210: LD_INT 0
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 2
88219: PUSH
88220: LD_INT 1
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 1
88229: PUSH
88230: LD_INT 2
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 0
88239: PUSH
88240: LD_INT 2
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 1
88249: NEG
88250: PUSH
88251: LD_INT 1
88253: PUSH
88254: EMPTY
88255: LIST
88256: LIST
88257: PUSH
88258: LD_INT 2
88260: NEG
88261: PUSH
88262: LD_INT 0
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 2
88271: NEG
88272: PUSH
88273: LD_INT 1
88275: NEG
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 1
88283: NEG
88284: PUSH
88285: LD_INT 3
88287: NEG
88288: PUSH
88289: EMPTY
88290: LIST
88291: LIST
88292: PUSH
88293: LD_INT 0
88295: PUSH
88296: LD_INT 3
88298: NEG
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: LD_INT 1
88306: PUSH
88307: LD_INT 2
88309: NEG
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 2
88317: PUSH
88318: LD_INT 1
88320: NEG
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 3
88328: PUSH
88329: LD_INT 0
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 3
88338: PUSH
88339: LD_INT 1
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: LD_INT 1
88348: PUSH
88349: LD_INT 3
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 0
88358: PUSH
88359: LD_INT 3
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: LD_INT 1
88368: NEG
88369: PUSH
88370: LD_INT 2
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 2
88379: NEG
88380: PUSH
88381: LD_INT 1
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 3
88390: NEG
88391: PUSH
88392: LD_INT 0
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 3
88401: NEG
88402: PUSH
88403: LD_INT 1
88405: NEG
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88442: LD_ADDR_VAR 0 47
88446: PUSH
88447: LD_INT 0
88449: PUSH
88450: LD_INT 0
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 0
88459: PUSH
88460: LD_INT 1
88462: NEG
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PUSH
88468: LD_INT 1
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 1
88480: PUSH
88481: LD_INT 1
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 0
88490: PUSH
88491: LD_INT 1
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 1
88500: NEG
88501: PUSH
88502: LD_INT 0
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 1
88511: NEG
88512: PUSH
88513: LD_INT 1
88515: NEG
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 1
88523: NEG
88524: PUSH
88525: LD_INT 2
88527: NEG
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: LD_INT 2
88538: NEG
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: PUSH
88544: LD_INT 1
88546: PUSH
88547: LD_INT 1
88549: NEG
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: PUSH
88555: LD_INT 2
88557: NEG
88558: PUSH
88559: LD_INT 1
88561: NEG
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: PUSH
88567: LD_INT 2
88569: NEG
88570: PUSH
88571: LD_INT 2
88573: NEG
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: EMPTY
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88593: LD_ADDR_VAR 0 48
88597: PUSH
88598: LD_INT 0
88600: PUSH
88601: LD_INT 0
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PUSH
88608: LD_INT 0
88610: PUSH
88611: LD_INT 1
88613: NEG
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 1
88621: PUSH
88622: LD_INT 0
88624: PUSH
88625: EMPTY
88626: LIST
88627: LIST
88628: PUSH
88629: LD_INT 1
88631: PUSH
88632: LD_INT 1
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 0
88641: PUSH
88642: LD_INT 1
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 1
88651: NEG
88652: PUSH
88653: LD_INT 0
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 1
88662: NEG
88663: PUSH
88664: LD_INT 1
88666: NEG
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 1
88674: NEG
88675: PUSH
88676: LD_INT 2
88678: NEG
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 0
88686: PUSH
88687: LD_INT 2
88689: NEG
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: PUSH
88695: LD_INT 1
88697: PUSH
88698: LD_INT 1
88700: NEG
88701: PUSH
88702: EMPTY
88703: LIST
88704: LIST
88705: PUSH
88706: LD_INT 2
88708: PUSH
88709: LD_INT 0
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: LD_INT 2
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88740: LD_ADDR_VAR 0 49
88744: PUSH
88745: LD_INT 0
88747: PUSH
88748: LD_INT 0
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 0
88757: PUSH
88758: LD_INT 1
88760: NEG
88761: PUSH
88762: EMPTY
88763: LIST
88764: LIST
88765: PUSH
88766: LD_INT 1
88768: PUSH
88769: LD_INT 0
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 1
88778: PUSH
88779: LD_INT 1
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: LD_INT 1
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 1
88798: NEG
88799: PUSH
88800: LD_INT 0
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: LD_INT 1
88809: NEG
88810: PUSH
88811: LD_INT 1
88813: NEG
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: LD_INT 1
88821: PUSH
88822: LD_INT 1
88824: NEG
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: PUSH
88830: LD_INT 2
88832: PUSH
88833: LD_INT 0
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 2
88842: PUSH
88843: LD_INT 1
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 2
88852: PUSH
88853: LD_INT 2
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 1
88862: PUSH
88863: LD_INT 2
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: EMPTY
88871: LIST
88872: LIST
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: LIST
88878: LIST
88879: LIST
88880: LIST
88881: LIST
88882: LIST
88883: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88884: LD_ADDR_VAR 0 50
88888: PUSH
88889: LD_INT 0
88891: PUSH
88892: LD_INT 0
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 0
88901: PUSH
88902: LD_INT 1
88904: NEG
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 1
88912: PUSH
88913: LD_INT 0
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 1
88922: PUSH
88923: LD_INT 1
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: LD_INT 0
88932: PUSH
88933: LD_INT 1
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 1
88942: NEG
88943: PUSH
88944: LD_INT 0
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: LD_INT 1
88953: NEG
88954: PUSH
88955: LD_INT 1
88957: NEG
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: PUSH
88963: LD_INT 2
88965: PUSH
88966: LD_INT 1
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: PUSH
88973: LD_INT 2
88975: PUSH
88976: LD_INT 2
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 1
88985: PUSH
88986: LD_INT 2
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 0
88995: PUSH
88996: LD_INT 2
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 1
89005: NEG
89006: PUSH
89007: LD_INT 1
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89028: LD_ADDR_VAR 0 51
89032: PUSH
89033: LD_INT 0
89035: PUSH
89036: LD_INT 0
89038: PUSH
89039: EMPTY
89040: LIST
89041: LIST
89042: PUSH
89043: LD_INT 0
89045: PUSH
89046: LD_INT 1
89048: NEG
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: PUSH
89054: LD_INT 1
89056: PUSH
89057: LD_INT 0
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 1
89066: PUSH
89067: LD_INT 1
89069: PUSH
89070: EMPTY
89071: LIST
89072: LIST
89073: PUSH
89074: LD_INT 0
89076: PUSH
89077: LD_INT 1
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 1
89086: NEG
89087: PUSH
89088: LD_INT 0
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: NEG
89098: PUSH
89099: LD_INT 1
89101: NEG
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: PUSH
89107: LD_INT 1
89109: PUSH
89110: LD_INT 2
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 0
89119: PUSH
89120: LD_INT 2
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 1
89129: NEG
89130: PUSH
89131: LD_INT 1
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 2
89140: NEG
89141: PUSH
89142: LD_INT 0
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: PUSH
89149: LD_INT 2
89151: NEG
89152: PUSH
89153: LD_INT 1
89155: NEG
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89175: LD_ADDR_VAR 0 52
89179: PUSH
89180: LD_INT 0
89182: PUSH
89183: LD_INT 0
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 0
89192: PUSH
89193: LD_INT 1
89195: NEG
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PUSH
89201: LD_INT 1
89203: PUSH
89204: LD_INT 0
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: PUSH
89214: LD_INT 1
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: PUSH
89221: LD_INT 0
89223: PUSH
89224: LD_INT 1
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: LD_INT 1
89233: NEG
89234: PUSH
89235: LD_INT 0
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: LD_INT 1
89244: NEG
89245: PUSH
89246: LD_INT 1
89248: NEG
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 1
89256: NEG
89257: PUSH
89258: LD_INT 2
89260: NEG
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: PUSH
89266: LD_INT 1
89268: NEG
89269: PUSH
89270: LD_INT 1
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PUSH
89277: LD_INT 2
89279: NEG
89280: PUSH
89281: LD_INT 0
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 2
89290: NEG
89291: PUSH
89292: LD_INT 1
89294: NEG
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 2
89302: NEG
89303: PUSH
89304: LD_INT 2
89306: NEG
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89326: LD_ADDR_VAR 0 53
89330: PUSH
89331: LD_INT 0
89333: PUSH
89334: LD_INT 0
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: LD_INT 0
89343: PUSH
89344: LD_INT 1
89346: NEG
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: PUSH
89352: LD_INT 1
89354: PUSH
89355: LD_INT 0
89357: PUSH
89358: EMPTY
89359: LIST
89360: LIST
89361: PUSH
89362: LD_INT 1
89364: PUSH
89365: LD_INT 1
89367: PUSH
89368: EMPTY
89369: LIST
89370: LIST
89371: PUSH
89372: LD_INT 0
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 1
89384: NEG
89385: PUSH
89386: LD_INT 0
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PUSH
89393: LD_INT 1
89395: NEG
89396: PUSH
89397: LD_INT 1
89399: NEG
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 1
89407: NEG
89408: PUSH
89409: LD_INT 2
89411: NEG
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: LD_INT 0
89419: PUSH
89420: LD_INT 2
89422: NEG
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 1
89430: PUSH
89431: LD_INT 1
89433: NEG
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: PUSH
89439: LD_INT 2
89441: PUSH
89442: LD_INT 0
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 2
89451: PUSH
89452: LD_INT 1
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 2
89461: PUSH
89462: LD_INT 2
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 1
89471: PUSH
89472: LD_INT 2
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 0
89481: PUSH
89482: LD_INT 2
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 1
89491: NEG
89492: PUSH
89493: LD_INT 1
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 2
89502: NEG
89503: PUSH
89504: LD_INT 0
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 2
89513: NEG
89514: PUSH
89515: LD_INT 1
89517: NEG
89518: PUSH
89519: EMPTY
89520: LIST
89521: LIST
89522: PUSH
89523: LD_INT 2
89525: NEG
89526: PUSH
89527: LD_INT 2
89529: NEG
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89556: LD_ADDR_VAR 0 54
89560: PUSH
89561: LD_INT 0
89563: PUSH
89564: LD_INT 0
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: LD_INT 0
89573: PUSH
89574: LD_INT 1
89576: NEG
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 1
89584: PUSH
89585: LD_INT 0
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: PUSH
89592: LD_INT 1
89594: PUSH
89595: LD_INT 1
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 0
89604: PUSH
89605: LD_INT 1
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 1
89614: NEG
89615: PUSH
89616: LD_INT 0
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: PUSH
89623: LD_INT 1
89625: NEG
89626: PUSH
89627: LD_INT 1
89629: NEG
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 1
89637: NEG
89638: PUSH
89639: LD_INT 2
89641: NEG
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: PUSH
89647: LD_INT 0
89649: PUSH
89650: LD_INT 2
89652: NEG
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: LD_INT 1
89660: PUSH
89661: LD_INT 1
89663: NEG
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: PUSH
89669: LD_INT 2
89671: PUSH
89672: LD_INT 0
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: PUSH
89679: LD_INT 2
89681: PUSH
89682: LD_INT 1
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: LD_INT 2
89691: PUSH
89692: LD_INT 2
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 1
89701: PUSH
89702: LD_INT 2
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 0
89711: PUSH
89712: LD_INT 2
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 1
89721: NEG
89722: PUSH
89723: LD_INT 1
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 2
89732: NEG
89733: PUSH
89734: LD_INT 0
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 2
89743: NEG
89744: PUSH
89745: LD_INT 1
89747: NEG
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 2
89755: NEG
89756: PUSH
89757: LD_INT 2
89759: NEG
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89786: LD_ADDR_VAR 0 55
89790: PUSH
89791: LD_INT 0
89793: PUSH
89794: LD_INT 0
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 0
89803: PUSH
89804: LD_INT 1
89806: NEG
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 1
89814: PUSH
89815: LD_INT 0
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 1
89824: PUSH
89825: LD_INT 1
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: PUSH
89832: LD_INT 0
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 1
89844: NEG
89845: PUSH
89846: LD_INT 0
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 1
89855: NEG
89856: PUSH
89857: LD_INT 1
89859: NEG
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 1
89867: NEG
89868: PUSH
89869: LD_INT 2
89871: NEG
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 0
89879: PUSH
89880: LD_INT 2
89882: NEG
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 1
89890: PUSH
89891: LD_INT 1
89893: NEG
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 2
89901: PUSH
89902: LD_INT 0
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: LD_INT 2
89911: PUSH
89912: LD_INT 1
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PUSH
89919: LD_INT 2
89921: PUSH
89922: LD_INT 2
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 1
89931: PUSH
89932: LD_INT 2
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: PUSH
89939: LD_INT 0
89941: PUSH
89942: LD_INT 2
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: LD_INT 1
89951: NEG
89952: PUSH
89953: LD_INT 1
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: PUSH
89960: LD_INT 2
89962: NEG
89963: PUSH
89964: LD_INT 0
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 2
89973: NEG
89974: PUSH
89975: LD_INT 1
89977: NEG
89978: PUSH
89979: EMPTY
89980: LIST
89981: LIST
89982: PUSH
89983: LD_INT 2
89985: NEG
89986: PUSH
89987: LD_INT 2
89989: NEG
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90016: LD_ADDR_VAR 0 56
90020: PUSH
90021: LD_INT 0
90023: PUSH
90024: LD_INT 0
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 0
90033: PUSH
90034: LD_INT 1
90036: NEG
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: LD_INT 1
90044: PUSH
90045: LD_INT 0
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 1
90054: PUSH
90055: LD_INT 1
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 0
90064: PUSH
90065: LD_INT 1
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 1
90074: NEG
90075: PUSH
90076: LD_INT 0
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 1
90085: NEG
90086: PUSH
90087: LD_INT 1
90089: NEG
90090: PUSH
90091: EMPTY
90092: LIST
90093: LIST
90094: PUSH
90095: LD_INT 1
90097: NEG
90098: PUSH
90099: LD_INT 2
90101: NEG
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 0
90109: PUSH
90110: LD_INT 2
90112: NEG
90113: PUSH
90114: EMPTY
90115: LIST
90116: LIST
90117: PUSH
90118: LD_INT 1
90120: PUSH
90121: LD_INT 1
90123: NEG
90124: PUSH
90125: EMPTY
90126: LIST
90127: LIST
90128: PUSH
90129: LD_INT 2
90131: PUSH
90132: LD_INT 0
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: PUSH
90139: LD_INT 2
90141: PUSH
90142: LD_INT 1
90144: PUSH
90145: EMPTY
90146: LIST
90147: LIST
90148: PUSH
90149: LD_INT 2
90151: PUSH
90152: LD_INT 2
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PUSH
90159: LD_INT 1
90161: PUSH
90162: LD_INT 2
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 0
90171: PUSH
90172: LD_INT 2
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 1
90181: NEG
90182: PUSH
90183: LD_INT 1
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: LD_INT 2
90192: NEG
90193: PUSH
90194: LD_INT 0
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 2
90203: NEG
90204: PUSH
90205: LD_INT 1
90207: NEG
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: PUSH
90213: LD_INT 2
90215: NEG
90216: PUSH
90217: LD_INT 2
90219: NEG
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90246: LD_ADDR_VAR 0 57
90250: PUSH
90251: LD_INT 0
90253: PUSH
90254: LD_INT 0
90256: PUSH
90257: EMPTY
90258: LIST
90259: LIST
90260: PUSH
90261: LD_INT 0
90263: PUSH
90264: LD_INT 1
90266: NEG
90267: PUSH
90268: EMPTY
90269: LIST
90270: LIST
90271: PUSH
90272: LD_INT 1
90274: PUSH
90275: LD_INT 0
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: PUSH
90282: LD_INT 1
90284: PUSH
90285: LD_INT 1
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PUSH
90292: LD_INT 0
90294: PUSH
90295: LD_INT 1
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 1
90304: NEG
90305: PUSH
90306: LD_INT 0
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: LD_INT 1
90315: NEG
90316: PUSH
90317: LD_INT 1
90319: NEG
90320: PUSH
90321: EMPTY
90322: LIST
90323: LIST
90324: PUSH
90325: LD_INT 1
90327: NEG
90328: PUSH
90329: LD_INT 2
90331: NEG
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 0
90339: PUSH
90340: LD_INT 2
90342: NEG
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 1
90350: PUSH
90351: LD_INT 1
90353: NEG
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 2
90361: PUSH
90362: LD_INT 0
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: PUSH
90369: LD_INT 2
90371: PUSH
90372: LD_INT 1
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: PUSH
90379: LD_INT 2
90381: PUSH
90382: LD_INT 2
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: PUSH
90389: LD_INT 1
90391: PUSH
90392: LD_INT 2
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 0
90401: PUSH
90402: LD_INT 2
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: PUSH
90409: LD_INT 1
90411: NEG
90412: PUSH
90413: LD_INT 1
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 2
90422: NEG
90423: PUSH
90424: LD_INT 0
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 2
90433: NEG
90434: PUSH
90435: LD_INT 1
90437: NEG
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: LD_INT 2
90445: NEG
90446: PUSH
90447: LD_INT 2
90449: NEG
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90476: LD_ADDR_VAR 0 58
90480: PUSH
90481: LD_INT 0
90483: PUSH
90484: LD_INT 0
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: LD_INT 0
90493: PUSH
90494: LD_INT 1
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 1
90504: PUSH
90505: LD_INT 0
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 1
90514: PUSH
90515: LD_INT 1
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 0
90524: PUSH
90525: LD_INT 1
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 1
90534: NEG
90535: PUSH
90536: LD_INT 0
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 1
90545: NEG
90546: PUSH
90547: LD_INT 1
90549: NEG
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: PUSH
90555: LD_INT 1
90557: NEG
90558: PUSH
90559: LD_INT 2
90561: NEG
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 0
90569: PUSH
90570: LD_INT 2
90572: NEG
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 1
90580: PUSH
90581: LD_INT 1
90583: NEG
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 2
90591: PUSH
90592: LD_INT 0
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 2
90601: PUSH
90602: LD_INT 1
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: PUSH
90609: LD_INT 2
90611: PUSH
90612: LD_INT 2
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 1
90621: PUSH
90622: LD_INT 2
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 0
90631: PUSH
90632: LD_INT 2
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: LD_INT 1
90641: NEG
90642: PUSH
90643: LD_INT 1
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 2
90652: NEG
90653: PUSH
90654: LD_INT 0
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 2
90663: NEG
90664: PUSH
90665: LD_INT 1
90667: NEG
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: PUSH
90673: LD_INT 2
90675: NEG
90676: PUSH
90677: LD_INT 2
90679: NEG
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90706: LD_ADDR_VAR 0 59
90710: PUSH
90711: LD_INT 0
90713: PUSH
90714: LD_INT 0
90716: PUSH
90717: EMPTY
90718: LIST
90719: LIST
90720: PUSH
90721: LD_INT 0
90723: PUSH
90724: LD_INT 1
90726: NEG
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: PUSH
90732: LD_INT 1
90734: PUSH
90735: LD_INT 0
90737: PUSH
90738: EMPTY
90739: LIST
90740: LIST
90741: PUSH
90742: LD_INT 1
90744: PUSH
90745: LD_INT 1
90747: PUSH
90748: EMPTY
90749: LIST
90750: LIST
90751: PUSH
90752: LD_INT 0
90754: PUSH
90755: LD_INT 1
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 1
90764: NEG
90765: PUSH
90766: LD_INT 0
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: PUSH
90773: LD_INT 1
90775: NEG
90776: PUSH
90777: LD_INT 1
90779: NEG
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90794: LD_ADDR_VAR 0 60
90798: PUSH
90799: LD_INT 0
90801: PUSH
90802: LD_INT 0
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 0
90811: PUSH
90812: LD_INT 1
90814: NEG
90815: PUSH
90816: EMPTY
90817: LIST
90818: LIST
90819: PUSH
90820: LD_INT 1
90822: PUSH
90823: LD_INT 0
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 1
90832: PUSH
90833: LD_INT 1
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 0
90842: PUSH
90843: LD_INT 1
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 1
90852: NEG
90853: PUSH
90854: LD_INT 0
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 1
90863: NEG
90864: PUSH
90865: LD_INT 1
90867: NEG
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90882: LD_ADDR_VAR 0 61
90886: PUSH
90887: LD_INT 0
90889: PUSH
90890: LD_INT 0
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 0
90899: PUSH
90900: LD_INT 1
90902: NEG
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: PUSH
90908: LD_INT 1
90910: PUSH
90911: LD_INT 0
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: LD_INT 1
90920: PUSH
90921: LD_INT 1
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 0
90930: PUSH
90931: LD_INT 1
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 1
90940: NEG
90941: PUSH
90942: LD_INT 0
90944: PUSH
90945: EMPTY
90946: LIST
90947: LIST
90948: PUSH
90949: LD_INT 1
90951: NEG
90952: PUSH
90953: LD_INT 1
90955: NEG
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: LIST
90965: LIST
90966: LIST
90967: LIST
90968: LIST
90969: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90970: LD_ADDR_VAR 0 62
90974: PUSH
90975: LD_INT 0
90977: PUSH
90978: LD_INT 0
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 0
90987: PUSH
90988: LD_INT 1
90990: NEG
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: LD_INT 1
90998: PUSH
90999: LD_INT 0
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 1
91008: PUSH
91009: LD_INT 1
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: PUSH
91016: LD_INT 0
91018: PUSH
91019: LD_INT 1
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 1
91028: NEG
91029: PUSH
91030: LD_INT 0
91032: PUSH
91033: EMPTY
91034: LIST
91035: LIST
91036: PUSH
91037: LD_INT 1
91039: NEG
91040: PUSH
91041: LD_INT 1
91043: NEG
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91058: LD_ADDR_VAR 0 63
91062: PUSH
91063: LD_INT 0
91065: PUSH
91066: LD_INT 0
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: PUSH
91073: LD_INT 0
91075: PUSH
91076: LD_INT 1
91078: NEG
91079: PUSH
91080: EMPTY
91081: LIST
91082: LIST
91083: PUSH
91084: LD_INT 1
91086: PUSH
91087: LD_INT 0
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: LD_INT 1
91096: PUSH
91097: LD_INT 1
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 0
91106: PUSH
91107: LD_INT 1
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PUSH
91114: LD_INT 1
91116: NEG
91117: PUSH
91118: LD_INT 0
91120: PUSH
91121: EMPTY
91122: LIST
91123: LIST
91124: PUSH
91125: LD_INT 1
91127: NEG
91128: PUSH
91129: LD_INT 1
91131: NEG
91132: PUSH
91133: EMPTY
91134: LIST
91135: LIST
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: LIST
91144: LIST
91145: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91146: LD_ADDR_VAR 0 64
91150: PUSH
91151: LD_INT 0
91153: PUSH
91154: LD_INT 0
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PUSH
91161: LD_INT 0
91163: PUSH
91164: LD_INT 1
91166: NEG
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PUSH
91172: LD_INT 1
91174: PUSH
91175: LD_INT 0
91177: PUSH
91178: EMPTY
91179: LIST
91180: LIST
91181: PUSH
91182: LD_INT 1
91184: PUSH
91185: LD_INT 1
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PUSH
91192: LD_INT 0
91194: PUSH
91195: LD_INT 1
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: LD_INT 1
91204: NEG
91205: PUSH
91206: LD_INT 0
91208: PUSH
91209: EMPTY
91210: LIST
91211: LIST
91212: PUSH
91213: LD_INT 1
91215: NEG
91216: PUSH
91217: LD_INT 1
91219: NEG
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: ST_TO_ADDR
// end ; 1 :
91234: GO 97131
91236: LD_INT 1
91238: DOUBLE
91239: EQUAL
91240: IFTRUE 91244
91242: GO 93867
91244: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91245: LD_ADDR_VAR 0 11
91249: PUSH
91250: LD_INT 1
91252: NEG
91253: PUSH
91254: LD_INT 3
91256: NEG
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 0
91264: PUSH
91265: LD_INT 3
91267: NEG
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: PUSH
91273: LD_INT 1
91275: PUSH
91276: LD_INT 2
91278: NEG
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: LIST
91288: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91289: LD_ADDR_VAR 0 12
91293: PUSH
91294: LD_INT 2
91296: PUSH
91297: LD_INT 1
91299: NEG
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: PUSH
91305: LD_INT 3
91307: PUSH
91308: LD_INT 0
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 3
91317: PUSH
91318: LD_INT 1
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: LIST
91329: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91330: LD_ADDR_VAR 0 13
91334: PUSH
91335: LD_INT 3
91337: PUSH
91338: LD_INT 2
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: PUSH
91345: LD_INT 3
91347: PUSH
91348: LD_INT 3
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: LD_INT 2
91357: PUSH
91358: LD_INT 3
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: EMPTY
91366: LIST
91367: LIST
91368: LIST
91369: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91370: LD_ADDR_VAR 0 14
91374: PUSH
91375: LD_INT 1
91377: PUSH
91378: LD_INT 3
91380: PUSH
91381: EMPTY
91382: LIST
91383: LIST
91384: PUSH
91385: LD_INT 0
91387: PUSH
91388: LD_INT 3
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 1
91397: NEG
91398: PUSH
91399: LD_INT 2
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: LIST
91410: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91411: LD_ADDR_VAR 0 15
91415: PUSH
91416: LD_INT 2
91418: NEG
91419: PUSH
91420: LD_INT 1
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: LD_INT 3
91429: NEG
91430: PUSH
91431: LD_INT 0
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: LD_INT 3
91440: NEG
91441: PUSH
91442: LD_INT 1
91444: NEG
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: LIST
91454: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91455: LD_ADDR_VAR 0 16
91459: PUSH
91460: LD_INT 2
91462: NEG
91463: PUSH
91464: LD_INT 3
91466: NEG
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 3
91474: NEG
91475: PUSH
91476: LD_INT 2
91478: NEG
91479: PUSH
91480: EMPTY
91481: LIST
91482: LIST
91483: PUSH
91484: LD_INT 3
91486: NEG
91487: PUSH
91488: LD_INT 3
91490: NEG
91491: PUSH
91492: EMPTY
91493: LIST
91494: LIST
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: LIST
91500: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91501: LD_ADDR_VAR 0 17
91505: PUSH
91506: LD_INT 1
91508: NEG
91509: PUSH
91510: LD_INT 3
91512: NEG
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PUSH
91518: LD_INT 0
91520: PUSH
91521: LD_INT 3
91523: NEG
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: LD_INT 1
91531: PUSH
91532: LD_INT 2
91534: NEG
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: LIST
91544: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91545: LD_ADDR_VAR 0 18
91549: PUSH
91550: LD_INT 2
91552: PUSH
91553: LD_INT 1
91555: NEG
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 3
91563: PUSH
91564: LD_INT 0
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 3
91573: PUSH
91574: LD_INT 1
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: LIST
91585: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91586: LD_ADDR_VAR 0 19
91590: PUSH
91591: LD_INT 3
91593: PUSH
91594: LD_INT 2
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 3
91603: PUSH
91604: LD_INT 3
91606: PUSH
91607: EMPTY
91608: LIST
91609: LIST
91610: PUSH
91611: LD_INT 2
91613: PUSH
91614: LD_INT 3
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: LIST
91625: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91626: LD_ADDR_VAR 0 20
91630: PUSH
91631: LD_INT 1
91633: PUSH
91634: LD_INT 3
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: LD_INT 0
91643: PUSH
91644: LD_INT 3
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 1
91653: NEG
91654: PUSH
91655: LD_INT 2
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: LIST
91666: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91667: LD_ADDR_VAR 0 21
91671: PUSH
91672: LD_INT 2
91674: NEG
91675: PUSH
91676: LD_INT 1
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: PUSH
91683: LD_INT 3
91685: NEG
91686: PUSH
91687: LD_INT 0
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 3
91696: NEG
91697: PUSH
91698: LD_INT 1
91700: NEG
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: LIST
91710: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91711: LD_ADDR_VAR 0 22
91715: PUSH
91716: LD_INT 2
91718: NEG
91719: PUSH
91720: LD_INT 3
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 3
91730: NEG
91731: PUSH
91732: LD_INT 2
91734: NEG
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 3
91742: NEG
91743: PUSH
91744: LD_INT 3
91746: NEG
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: LIST
91756: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91757: LD_ADDR_VAR 0 23
91761: PUSH
91762: LD_INT 0
91764: PUSH
91765: LD_INT 3
91767: NEG
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 1
91775: NEG
91776: PUSH
91777: LD_INT 4
91779: NEG
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: PUSH
91785: LD_INT 1
91787: PUSH
91788: LD_INT 3
91790: NEG
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: LIST
91800: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91801: LD_ADDR_VAR 0 24
91805: PUSH
91806: LD_INT 3
91808: PUSH
91809: LD_INT 0
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 3
91818: PUSH
91819: LD_INT 1
91821: NEG
91822: PUSH
91823: EMPTY
91824: LIST
91825: LIST
91826: PUSH
91827: LD_INT 4
91829: PUSH
91830: LD_INT 1
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: PUSH
91837: EMPTY
91838: LIST
91839: LIST
91840: LIST
91841: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91842: LD_ADDR_VAR 0 25
91846: PUSH
91847: LD_INT 3
91849: PUSH
91850: LD_INT 3
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 4
91859: PUSH
91860: LD_INT 3
91862: PUSH
91863: EMPTY
91864: LIST
91865: LIST
91866: PUSH
91867: LD_INT 3
91869: PUSH
91870: LD_INT 4
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: EMPTY
91878: LIST
91879: LIST
91880: LIST
91881: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91882: LD_ADDR_VAR 0 26
91886: PUSH
91887: LD_INT 0
91889: PUSH
91890: LD_INT 3
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: PUSH
91897: LD_INT 1
91899: PUSH
91900: LD_INT 4
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 1
91909: NEG
91910: PUSH
91911: LD_INT 3
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: LIST
91922: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91923: LD_ADDR_VAR 0 27
91927: PUSH
91928: LD_INT 3
91930: NEG
91931: PUSH
91932: LD_INT 0
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: LD_INT 3
91941: NEG
91942: PUSH
91943: LD_INT 1
91945: PUSH
91946: EMPTY
91947: LIST
91948: LIST
91949: PUSH
91950: LD_INT 4
91952: NEG
91953: PUSH
91954: LD_INT 1
91956: NEG
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: LIST
91966: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
91967: LD_ADDR_VAR 0 28
91971: PUSH
91972: LD_INT 3
91974: NEG
91975: PUSH
91976: LD_INT 3
91978: NEG
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: LD_INT 3
91986: NEG
91987: PUSH
91988: LD_INT 4
91990: NEG
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: LD_INT 4
91998: NEG
91999: PUSH
92000: LD_INT 3
92002: NEG
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: LIST
92012: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92013: LD_ADDR_VAR 0 29
92017: PUSH
92018: LD_INT 1
92020: NEG
92021: PUSH
92022: LD_INT 3
92024: NEG
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 0
92032: PUSH
92033: LD_INT 3
92035: NEG
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 1
92043: PUSH
92044: LD_INT 2
92046: NEG
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 1
92054: NEG
92055: PUSH
92056: LD_INT 4
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 0
92066: PUSH
92067: LD_INT 4
92069: NEG
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 1
92077: PUSH
92078: LD_INT 3
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 1
92088: NEG
92089: PUSH
92090: LD_INT 5
92092: NEG
92093: PUSH
92094: EMPTY
92095: LIST
92096: LIST
92097: PUSH
92098: LD_INT 0
92100: PUSH
92101: LD_INT 5
92103: NEG
92104: PUSH
92105: EMPTY
92106: LIST
92107: LIST
92108: PUSH
92109: LD_INT 1
92111: PUSH
92112: LD_INT 4
92114: NEG
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: LD_INT 1
92122: NEG
92123: PUSH
92124: LD_INT 6
92126: NEG
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: PUSH
92132: LD_INT 0
92134: PUSH
92135: LD_INT 6
92137: NEG
92138: PUSH
92139: EMPTY
92140: LIST
92141: LIST
92142: PUSH
92143: LD_INT 1
92145: PUSH
92146: LD_INT 5
92148: NEG
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: LIST
92166: LIST
92167: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92168: LD_ADDR_VAR 0 30
92172: PUSH
92173: LD_INT 2
92175: PUSH
92176: LD_INT 1
92178: NEG
92179: PUSH
92180: EMPTY
92181: LIST
92182: LIST
92183: PUSH
92184: LD_INT 3
92186: PUSH
92187: LD_INT 0
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 3
92196: PUSH
92197: LD_INT 1
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 3
92206: PUSH
92207: LD_INT 1
92209: NEG
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 4
92217: PUSH
92218: LD_INT 0
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 4
92227: PUSH
92228: LD_INT 1
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 4
92237: PUSH
92238: LD_INT 1
92240: NEG
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 5
92248: PUSH
92249: LD_INT 0
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: LD_INT 5
92258: PUSH
92259: LD_INT 1
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 5
92268: PUSH
92269: LD_INT 1
92271: NEG
92272: PUSH
92273: EMPTY
92274: LIST
92275: LIST
92276: PUSH
92277: LD_INT 6
92279: PUSH
92280: LD_INT 0
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 6
92289: PUSH
92290: LD_INT 1
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PUSH
92297: EMPTY
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92311: LD_ADDR_VAR 0 31
92315: PUSH
92316: LD_INT 3
92318: PUSH
92319: LD_INT 2
92321: PUSH
92322: EMPTY
92323: LIST
92324: LIST
92325: PUSH
92326: LD_INT 3
92328: PUSH
92329: LD_INT 3
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: PUSH
92336: LD_INT 2
92338: PUSH
92339: LD_INT 3
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PUSH
92346: LD_INT 4
92348: PUSH
92349: LD_INT 3
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: PUSH
92356: LD_INT 4
92358: PUSH
92359: LD_INT 4
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: PUSH
92366: LD_INT 3
92368: PUSH
92369: LD_INT 4
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 5
92378: PUSH
92379: LD_INT 4
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: PUSH
92386: LD_INT 5
92388: PUSH
92389: LD_INT 5
92391: PUSH
92392: EMPTY
92393: LIST
92394: LIST
92395: PUSH
92396: LD_INT 4
92398: PUSH
92399: LD_INT 5
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: LD_INT 6
92408: PUSH
92409: LD_INT 5
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: LD_INT 6
92418: PUSH
92419: LD_INT 6
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 5
92428: PUSH
92429: LD_INT 6
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: EMPTY
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92450: LD_ADDR_VAR 0 32
92454: PUSH
92455: LD_INT 1
92457: PUSH
92458: LD_INT 3
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 0
92467: PUSH
92468: LD_INT 3
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 1
92477: NEG
92478: PUSH
92479: LD_INT 2
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 1
92488: PUSH
92489: LD_INT 4
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 0
92498: PUSH
92499: LD_INT 4
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: PUSH
92506: LD_INT 1
92508: NEG
92509: PUSH
92510: LD_INT 3
92512: PUSH
92513: EMPTY
92514: LIST
92515: LIST
92516: PUSH
92517: LD_INT 1
92519: PUSH
92520: LD_INT 5
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: PUSH
92527: LD_INT 0
92529: PUSH
92530: LD_INT 5
92532: PUSH
92533: EMPTY
92534: LIST
92535: LIST
92536: PUSH
92537: LD_INT 1
92539: NEG
92540: PUSH
92541: LD_INT 4
92543: PUSH
92544: EMPTY
92545: LIST
92546: LIST
92547: PUSH
92548: LD_INT 1
92550: PUSH
92551: LD_INT 6
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: PUSH
92558: LD_INT 0
92560: PUSH
92561: LD_INT 6
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 1
92570: NEG
92571: PUSH
92572: LD_INT 5
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92593: LD_ADDR_VAR 0 33
92597: PUSH
92598: LD_INT 2
92600: NEG
92601: PUSH
92602: LD_INT 1
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 3
92611: NEG
92612: PUSH
92613: LD_INT 0
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: LD_INT 3
92622: NEG
92623: PUSH
92624: LD_INT 1
92626: NEG
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 3
92634: NEG
92635: PUSH
92636: LD_INT 1
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: PUSH
92643: LD_INT 4
92645: NEG
92646: PUSH
92647: LD_INT 0
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: LD_INT 4
92656: NEG
92657: PUSH
92658: LD_INT 1
92660: NEG
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: PUSH
92666: LD_INT 4
92668: NEG
92669: PUSH
92670: LD_INT 1
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 5
92679: NEG
92680: PUSH
92681: LD_INT 0
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 5
92690: NEG
92691: PUSH
92692: LD_INT 1
92694: NEG
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 5
92702: NEG
92703: PUSH
92704: LD_INT 1
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 6
92713: NEG
92714: PUSH
92715: LD_INT 0
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 6
92724: NEG
92725: PUSH
92726: LD_INT 1
92728: NEG
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92748: LD_ADDR_VAR 0 34
92752: PUSH
92753: LD_INT 2
92755: NEG
92756: PUSH
92757: LD_INT 3
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 3
92767: NEG
92768: PUSH
92769: LD_INT 2
92771: NEG
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 3
92779: NEG
92780: PUSH
92781: LD_INT 3
92783: NEG
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 3
92791: NEG
92792: PUSH
92793: LD_INT 4
92795: NEG
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: PUSH
92801: LD_INT 4
92803: NEG
92804: PUSH
92805: LD_INT 3
92807: NEG
92808: PUSH
92809: EMPTY
92810: LIST
92811: LIST
92812: PUSH
92813: LD_INT 4
92815: NEG
92816: PUSH
92817: LD_INT 4
92819: NEG
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 4
92827: NEG
92828: PUSH
92829: LD_INT 5
92831: NEG
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 5
92839: NEG
92840: PUSH
92841: LD_INT 4
92843: NEG
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 5
92851: NEG
92852: PUSH
92853: LD_INT 5
92855: NEG
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 5
92863: NEG
92864: PUSH
92865: LD_INT 6
92867: NEG
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 6
92875: NEG
92876: PUSH
92877: LD_INT 5
92879: NEG
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 6
92887: NEG
92888: PUSH
92889: LD_INT 6
92891: NEG
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: EMPTY
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92911: LD_ADDR_VAR 0 41
92915: PUSH
92916: LD_INT 0
92918: PUSH
92919: LD_INT 2
92921: NEG
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 1
92929: NEG
92930: PUSH
92931: LD_INT 3
92933: NEG
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: PUSH
92939: LD_INT 1
92941: PUSH
92942: LD_INT 2
92944: NEG
92945: PUSH
92946: EMPTY
92947: LIST
92948: LIST
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: LIST
92954: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
92955: LD_ADDR_VAR 0 42
92959: PUSH
92960: LD_INT 2
92962: PUSH
92963: LD_INT 0
92965: PUSH
92966: EMPTY
92967: LIST
92968: LIST
92969: PUSH
92970: LD_INT 2
92972: PUSH
92973: LD_INT 1
92975: NEG
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: PUSH
92981: LD_INT 3
92983: PUSH
92984: LD_INT 1
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: LIST
92995: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
92996: LD_ADDR_VAR 0 43
93000: PUSH
93001: LD_INT 2
93003: PUSH
93004: LD_INT 2
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 3
93013: PUSH
93014: LD_INT 2
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 2
93023: PUSH
93024: LD_INT 3
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: LIST
93035: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93036: LD_ADDR_VAR 0 44
93040: PUSH
93041: LD_INT 0
93043: PUSH
93044: LD_INT 2
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 1
93053: PUSH
93054: LD_INT 3
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 1
93063: NEG
93064: PUSH
93065: LD_INT 2
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: LIST
93076: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93077: LD_ADDR_VAR 0 45
93081: PUSH
93082: LD_INT 2
93084: NEG
93085: PUSH
93086: LD_INT 0
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PUSH
93093: LD_INT 2
93095: NEG
93096: PUSH
93097: LD_INT 1
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: LD_INT 3
93106: NEG
93107: PUSH
93108: LD_INT 1
93110: NEG
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: LIST
93120: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93121: LD_ADDR_VAR 0 46
93125: PUSH
93126: LD_INT 2
93128: NEG
93129: PUSH
93130: LD_INT 2
93132: NEG
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 2
93140: NEG
93141: PUSH
93142: LD_INT 3
93144: NEG
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: PUSH
93150: LD_INT 3
93152: NEG
93153: PUSH
93154: LD_INT 2
93156: NEG
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: LIST
93166: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93167: LD_ADDR_VAR 0 47
93171: PUSH
93172: LD_INT 2
93174: NEG
93175: PUSH
93176: LD_INT 3
93178: NEG
93179: PUSH
93180: EMPTY
93181: LIST
93182: LIST
93183: PUSH
93184: LD_INT 1
93186: NEG
93187: PUSH
93188: LD_INT 3
93190: NEG
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93200: LD_ADDR_VAR 0 48
93204: PUSH
93205: LD_INT 1
93207: PUSH
93208: LD_INT 2
93210: NEG
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 2
93218: PUSH
93219: LD_INT 1
93221: NEG
93222: PUSH
93223: EMPTY
93224: LIST
93225: LIST
93226: PUSH
93227: EMPTY
93228: LIST
93229: LIST
93230: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93231: LD_ADDR_VAR 0 49
93235: PUSH
93236: LD_INT 3
93238: PUSH
93239: LD_INT 1
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 3
93248: PUSH
93249: LD_INT 2
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93260: LD_ADDR_VAR 0 50
93264: PUSH
93265: LD_INT 2
93267: PUSH
93268: LD_INT 3
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PUSH
93275: LD_INT 1
93277: PUSH
93278: LD_INT 3
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93289: LD_ADDR_VAR 0 51
93293: PUSH
93294: LD_INT 1
93296: NEG
93297: PUSH
93298: LD_INT 2
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 2
93307: NEG
93308: PUSH
93309: LD_INT 1
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93320: LD_ADDR_VAR 0 52
93324: PUSH
93325: LD_INT 3
93327: NEG
93328: PUSH
93329: LD_INT 1
93331: NEG
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 3
93339: NEG
93340: PUSH
93341: LD_INT 2
93343: NEG
93344: PUSH
93345: EMPTY
93346: LIST
93347: LIST
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93353: LD_ADDR_VAR 0 53
93357: PUSH
93358: LD_INT 1
93360: NEG
93361: PUSH
93362: LD_INT 3
93364: NEG
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 0
93372: PUSH
93373: LD_INT 3
93375: NEG
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 1
93383: PUSH
93384: LD_INT 2
93386: NEG
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: LIST
93396: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93397: LD_ADDR_VAR 0 54
93401: PUSH
93402: LD_INT 2
93404: PUSH
93405: LD_INT 1
93407: NEG
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: PUSH
93413: LD_INT 3
93415: PUSH
93416: LD_INT 0
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: PUSH
93423: LD_INT 3
93425: PUSH
93426: LD_INT 1
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: LIST
93437: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93438: LD_ADDR_VAR 0 55
93442: PUSH
93443: LD_INT 3
93445: PUSH
93446: LD_INT 2
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PUSH
93453: LD_INT 3
93455: PUSH
93456: LD_INT 3
93458: PUSH
93459: EMPTY
93460: LIST
93461: LIST
93462: PUSH
93463: LD_INT 2
93465: PUSH
93466: LD_INT 3
93468: PUSH
93469: EMPTY
93470: LIST
93471: LIST
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: LIST
93477: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93478: LD_ADDR_VAR 0 56
93482: PUSH
93483: LD_INT 1
93485: PUSH
93486: LD_INT 3
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: PUSH
93493: LD_INT 0
93495: PUSH
93496: LD_INT 3
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: LD_INT 1
93505: NEG
93506: PUSH
93507: LD_INT 2
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: LIST
93518: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93519: LD_ADDR_VAR 0 57
93523: PUSH
93524: LD_INT 2
93526: NEG
93527: PUSH
93528: LD_INT 1
93530: PUSH
93531: EMPTY
93532: LIST
93533: LIST
93534: PUSH
93535: LD_INT 3
93537: NEG
93538: PUSH
93539: LD_INT 0
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: LD_INT 3
93548: NEG
93549: PUSH
93550: LD_INT 1
93552: NEG
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: PUSH
93558: EMPTY
93559: LIST
93560: LIST
93561: LIST
93562: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93563: LD_ADDR_VAR 0 58
93567: PUSH
93568: LD_INT 2
93570: NEG
93571: PUSH
93572: LD_INT 3
93574: NEG
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: PUSH
93580: LD_INT 3
93582: NEG
93583: PUSH
93584: LD_INT 2
93586: NEG
93587: PUSH
93588: EMPTY
93589: LIST
93590: LIST
93591: PUSH
93592: LD_INT 3
93594: NEG
93595: PUSH
93596: LD_INT 3
93598: NEG
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: LIST
93608: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93609: LD_ADDR_VAR 0 59
93613: PUSH
93614: LD_INT 1
93616: NEG
93617: PUSH
93618: LD_INT 2
93620: NEG
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: LD_INT 0
93628: PUSH
93629: LD_INT 2
93631: NEG
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: PUSH
93637: LD_INT 1
93639: PUSH
93640: LD_INT 1
93642: NEG
93643: PUSH
93644: EMPTY
93645: LIST
93646: LIST
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: LIST
93652: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93653: LD_ADDR_VAR 0 60
93657: PUSH
93658: LD_INT 1
93660: PUSH
93661: LD_INT 1
93663: NEG
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 2
93671: PUSH
93672: LD_INT 0
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: PUSH
93679: LD_INT 2
93681: PUSH
93682: LD_INT 1
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: PUSH
93689: EMPTY
93690: LIST
93691: LIST
93692: LIST
93693: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93694: LD_ADDR_VAR 0 61
93698: PUSH
93699: LD_INT 2
93701: PUSH
93702: LD_INT 1
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: LD_INT 2
93711: PUSH
93712: LD_INT 2
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: PUSH
93719: LD_INT 1
93721: PUSH
93722: LD_INT 2
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: LIST
93733: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93734: LD_ADDR_VAR 0 62
93738: PUSH
93739: LD_INT 1
93741: PUSH
93742: LD_INT 2
93744: PUSH
93745: EMPTY
93746: LIST
93747: LIST
93748: PUSH
93749: LD_INT 0
93751: PUSH
93752: LD_INT 2
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PUSH
93759: LD_INT 1
93761: NEG
93762: PUSH
93763: LD_INT 1
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: LIST
93774: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93775: LD_ADDR_VAR 0 63
93779: PUSH
93780: LD_INT 1
93782: NEG
93783: PUSH
93784: LD_INT 1
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: PUSH
93791: LD_INT 2
93793: NEG
93794: PUSH
93795: LD_INT 0
93797: PUSH
93798: EMPTY
93799: LIST
93800: LIST
93801: PUSH
93802: LD_INT 2
93804: NEG
93805: PUSH
93806: LD_INT 1
93808: NEG
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: PUSH
93814: EMPTY
93815: LIST
93816: LIST
93817: LIST
93818: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93819: LD_ADDR_VAR 0 64
93823: PUSH
93824: LD_INT 1
93826: NEG
93827: PUSH
93828: LD_INT 2
93830: NEG
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PUSH
93836: LD_INT 2
93838: NEG
93839: PUSH
93840: LD_INT 1
93842: NEG
93843: PUSH
93844: EMPTY
93845: LIST
93846: LIST
93847: PUSH
93848: LD_INT 2
93850: NEG
93851: PUSH
93852: LD_INT 2
93854: NEG
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: EMPTY
93861: LIST
93862: LIST
93863: LIST
93864: ST_TO_ADDR
// end ; 2 :
93865: GO 97131
93867: LD_INT 2
93869: DOUBLE
93870: EQUAL
93871: IFTRUE 93875
93873: GO 97130
93875: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93876: LD_ADDR_VAR 0 29
93880: PUSH
93881: LD_INT 4
93883: PUSH
93884: LD_INT 0
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: PUSH
93891: LD_INT 4
93893: PUSH
93894: LD_INT 1
93896: NEG
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: LD_INT 5
93904: PUSH
93905: LD_INT 0
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: PUSH
93912: LD_INT 5
93914: PUSH
93915: LD_INT 1
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: LD_INT 4
93924: PUSH
93925: LD_INT 1
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 3
93934: PUSH
93935: LD_INT 0
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 3
93944: PUSH
93945: LD_INT 1
93947: NEG
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 3
93955: PUSH
93956: LD_INT 2
93958: NEG
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: LD_INT 5
93966: PUSH
93967: LD_INT 2
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 3
93976: PUSH
93977: LD_INT 3
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 3
93986: PUSH
93987: LD_INT 2
93989: PUSH
93990: EMPTY
93991: LIST
93992: LIST
93993: PUSH
93994: LD_INT 4
93996: PUSH
93997: LD_INT 3
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: LD_INT 4
94006: PUSH
94007: LD_INT 4
94009: PUSH
94010: EMPTY
94011: LIST
94012: LIST
94013: PUSH
94014: LD_INT 3
94016: PUSH
94017: LD_INT 4
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: LD_INT 2
94026: PUSH
94027: LD_INT 3
94029: PUSH
94030: EMPTY
94031: LIST
94032: LIST
94033: PUSH
94034: LD_INT 2
94036: PUSH
94037: LD_INT 2
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 4
94046: PUSH
94047: LD_INT 2
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 2
94056: PUSH
94057: LD_INT 4
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: LD_INT 0
94066: PUSH
94067: LD_INT 4
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 0
94076: PUSH
94077: LD_INT 3
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 1
94086: PUSH
94087: LD_INT 4
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: PUSH
94094: LD_INT 1
94096: PUSH
94097: LD_INT 5
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 0
94106: PUSH
94107: LD_INT 5
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 1
94116: NEG
94117: PUSH
94118: LD_INT 4
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 1
94127: NEG
94128: PUSH
94129: LD_INT 3
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 2
94138: PUSH
94139: LD_INT 5
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 2
94148: NEG
94149: PUSH
94150: LD_INT 3
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: PUSH
94157: LD_INT 3
94159: NEG
94160: PUSH
94161: LD_INT 0
94163: PUSH
94164: EMPTY
94165: LIST
94166: LIST
94167: PUSH
94168: LD_INT 3
94170: NEG
94171: PUSH
94172: LD_INT 1
94174: NEG
94175: PUSH
94176: EMPTY
94177: LIST
94178: LIST
94179: PUSH
94180: LD_INT 2
94182: NEG
94183: PUSH
94184: LD_INT 0
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: LD_INT 2
94193: NEG
94194: PUSH
94195: LD_INT 1
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 3
94204: NEG
94205: PUSH
94206: LD_INT 1
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: LD_INT 4
94215: NEG
94216: PUSH
94217: LD_INT 0
94219: PUSH
94220: EMPTY
94221: LIST
94222: LIST
94223: PUSH
94224: LD_INT 4
94226: NEG
94227: PUSH
94228: LD_INT 1
94230: NEG
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: PUSH
94236: LD_INT 4
94238: NEG
94239: PUSH
94240: LD_INT 2
94242: NEG
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: LD_INT 2
94250: NEG
94251: PUSH
94252: LD_INT 2
94254: PUSH
94255: EMPTY
94256: LIST
94257: LIST
94258: PUSH
94259: LD_INT 4
94261: NEG
94262: PUSH
94263: LD_INT 4
94265: NEG
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 4
94273: NEG
94274: PUSH
94275: LD_INT 5
94277: NEG
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 3
94285: NEG
94286: PUSH
94287: LD_INT 4
94289: NEG
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 3
94297: NEG
94298: PUSH
94299: LD_INT 3
94301: NEG
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: PUSH
94307: LD_INT 4
94309: NEG
94310: PUSH
94311: LD_INT 3
94313: NEG
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 5
94321: NEG
94322: PUSH
94323: LD_INT 4
94325: NEG
94326: PUSH
94327: EMPTY
94328: LIST
94329: LIST
94330: PUSH
94331: LD_INT 5
94333: NEG
94334: PUSH
94335: LD_INT 5
94337: NEG
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: LD_INT 3
94345: NEG
94346: PUSH
94347: LD_INT 5
94349: NEG
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 5
94357: NEG
94358: PUSH
94359: LD_INT 3
94361: NEG
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94414: LD_ADDR_VAR 0 30
94418: PUSH
94419: LD_INT 4
94421: PUSH
94422: LD_INT 4
94424: PUSH
94425: EMPTY
94426: LIST
94427: LIST
94428: PUSH
94429: LD_INT 4
94431: PUSH
94432: LD_INT 3
94434: PUSH
94435: EMPTY
94436: LIST
94437: LIST
94438: PUSH
94439: LD_INT 5
94441: PUSH
94442: LD_INT 4
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: LD_INT 5
94451: PUSH
94452: LD_INT 5
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: PUSH
94459: LD_INT 4
94461: PUSH
94462: LD_INT 5
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 3
94471: PUSH
94472: LD_INT 4
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PUSH
94479: LD_INT 3
94481: PUSH
94482: LD_INT 3
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 5
94491: PUSH
94492: LD_INT 3
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 3
94501: PUSH
94502: LD_INT 5
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 0
94511: PUSH
94512: LD_INT 3
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: LD_INT 0
94521: PUSH
94522: LD_INT 2
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 1
94531: PUSH
94532: LD_INT 3
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: PUSH
94539: LD_INT 1
94541: PUSH
94542: LD_INT 4
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 0
94551: PUSH
94552: LD_INT 4
94554: PUSH
94555: EMPTY
94556: LIST
94557: LIST
94558: PUSH
94559: LD_INT 1
94561: NEG
94562: PUSH
94563: LD_INT 3
94565: PUSH
94566: EMPTY
94567: LIST
94568: LIST
94569: PUSH
94570: LD_INT 1
94572: NEG
94573: PUSH
94574: LD_INT 2
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 2
94583: PUSH
94584: LD_INT 4
94586: PUSH
94587: EMPTY
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 2
94593: NEG
94594: PUSH
94595: LD_INT 2
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 4
94604: NEG
94605: PUSH
94606: LD_INT 0
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 4
94615: NEG
94616: PUSH
94617: LD_INT 1
94619: NEG
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: PUSH
94625: LD_INT 3
94627: NEG
94628: PUSH
94629: LD_INT 0
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 3
94638: NEG
94639: PUSH
94640: LD_INT 1
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: LD_INT 4
94649: NEG
94650: PUSH
94651: LD_INT 1
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: PUSH
94658: LD_INT 5
94660: NEG
94661: PUSH
94662: LD_INT 0
94664: PUSH
94665: EMPTY
94666: LIST
94667: LIST
94668: PUSH
94669: LD_INT 5
94671: NEG
94672: PUSH
94673: LD_INT 1
94675: NEG
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: PUSH
94681: LD_INT 5
94683: NEG
94684: PUSH
94685: LD_INT 2
94687: NEG
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 3
94695: NEG
94696: PUSH
94697: LD_INT 2
94699: PUSH
94700: EMPTY
94701: LIST
94702: LIST
94703: PUSH
94704: LD_INT 3
94706: NEG
94707: PUSH
94708: LD_INT 3
94710: NEG
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PUSH
94716: LD_INT 3
94718: NEG
94719: PUSH
94720: LD_INT 4
94722: NEG
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 2
94730: NEG
94731: PUSH
94732: LD_INT 3
94734: NEG
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 2
94742: NEG
94743: PUSH
94744: LD_INT 2
94746: NEG
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 3
94754: NEG
94755: PUSH
94756: LD_INT 2
94758: NEG
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: LD_INT 4
94766: NEG
94767: PUSH
94768: LD_INT 3
94770: NEG
94771: PUSH
94772: EMPTY
94773: LIST
94774: LIST
94775: PUSH
94776: LD_INT 4
94778: NEG
94779: PUSH
94780: LD_INT 4
94782: NEG
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 2
94790: NEG
94791: PUSH
94792: LD_INT 4
94794: NEG
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 4
94802: NEG
94803: PUSH
94804: LD_INT 2
94806: NEG
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: PUSH
94812: LD_INT 0
94814: PUSH
94815: LD_INT 4
94817: NEG
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 0
94825: PUSH
94826: LD_INT 5
94828: NEG
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 1
94836: PUSH
94837: LD_INT 4
94839: NEG
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 1
94847: PUSH
94848: LD_INT 3
94850: NEG
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: PUSH
94856: LD_INT 0
94858: PUSH
94859: LD_INT 3
94861: NEG
94862: PUSH
94863: EMPTY
94864: LIST
94865: LIST
94866: PUSH
94867: LD_INT 1
94869: NEG
94870: PUSH
94871: LD_INT 4
94873: NEG
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: LD_INT 1
94881: NEG
94882: PUSH
94883: LD_INT 5
94885: NEG
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: PUSH
94891: LD_INT 2
94893: PUSH
94894: LD_INT 3
94896: NEG
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: LD_INT 2
94904: NEG
94905: PUSH
94906: LD_INT 5
94908: NEG
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: EMPTY
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
94961: LD_ADDR_VAR 0 31
94965: PUSH
94966: LD_INT 0
94968: PUSH
94969: LD_INT 4
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 0
94978: PUSH
94979: LD_INT 3
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 1
94988: PUSH
94989: LD_INT 4
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 1
94998: PUSH
94999: LD_INT 5
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 0
95008: PUSH
95009: LD_INT 5
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 1
95018: NEG
95019: PUSH
95020: LD_INT 4
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 1
95029: NEG
95030: PUSH
95031: LD_INT 3
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 2
95040: PUSH
95041: LD_INT 5
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: PUSH
95048: LD_INT 2
95050: NEG
95051: PUSH
95052: LD_INT 3
95054: PUSH
95055: EMPTY
95056: LIST
95057: LIST
95058: PUSH
95059: LD_INT 3
95061: NEG
95062: PUSH
95063: LD_INT 0
95065: PUSH
95066: EMPTY
95067: LIST
95068: LIST
95069: PUSH
95070: LD_INT 3
95072: NEG
95073: PUSH
95074: LD_INT 1
95076: NEG
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: PUSH
95082: LD_INT 2
95084: NEG
95085: PUSH
95086: LD_INT 0
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: LD_INT 2
95095: NEG
95096: PUSH
95097: LD_INT 1
95099: PUSH
95100: EMPTY
95101: LIST
95102: LIST
95103: PUSH
95104: LD_INT 3
95106: NEG
95107: PUSH
95108: LD_INT 1
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 4
95117: NEG
95118: PUSH
95119: LD_INT 0
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: LD_INT 4
95128: NEG
95129: PUSH
95130: LD_INT 1
95132: NEG
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: PUSH
95138: LD_INT 4
95140: NEG
95141: PUSH
95142: LD_INT 2
95144: NEG
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: PUSH
95150: LD_INT 2
95152: NEG
95153: PUSH
95154: LD_INT 2
95156: PUSH
95157: EMPTY
95158: LIST
95159: LIST
95160: PUSH
95161: LD_INT 4
95163: NEG
95164: PUSH
95165: LD_INT 4
95167: NEG
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: LD_INT 4
95175: NEG
95176: PUSH
95177: LD_INT 5
95179: NEG
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: PUSH
95185: LD_INT 3
95187: NEG
95188: PUSH
95189: LD_INT 4
95191: NEG
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: PUSH
95197: LD_INT 3
95199: NEG
95200: PUSH
95201: LD_INT 3
95203: NEG
95204: PUSH
95205: EMPTY
95206: LIST
95207: LIST
95208: PUSH
95209: LD_INT 4
95211: NEG
95212: PUSH
95213: LD_INT 3
95215: NEG
95216: PUSH
95217: EMPTY
95218: LIST
95219: LIST
95220: PUSH
95221: LD_INT 5
95223: NEG
95224: PUSH
95225: LD_INT 4
95227: NEG
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 5
95235: NEG
95236: PUSH
95237: LD_INT 5
95239: NEG
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: LD_INT 3
95247: NEG
95248: PUSH
95249: LD_INT 5
95251: NEG
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 5
95259: NEG
95260: PUSH
95261: LD_INT 3
95263: NEG
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: PUSH
95269: LD_INT 0
95271: PUSH
95272: LD_INT 3
95274: NEG
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: PUSH
95280: LD_INT 0
95282: PUSH
95283: LD_INT 4
95285: NEG
95286: PUSH
95287: EMPTY
95288: LIST
95289: LIST
95290: PUSH
95291: LD_INT 1
95293: PUSH
95294: LD_INT 3
95296: NEG
95297: PUSH
95298: EMPTY
95299: LIST
95300: LIST
95301: PUSH
95302: LD_INT 1
95304: PUSH
95305: LD_INT 2
95307: NEG
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 0
95315: PUSH
95316: LD_INT 2
95318: NEG
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 1
95326: NEG
95327: PUSH
95328: LD_INT 3
95330: NEG
95331: PUSH
95332: EMPTY
95333: LIST
95334: LIST
95335: PUSH
95336: LD_INT 1
95338: NEG
95339: PUSH
95340: LD_INT 4
95342: NEG
95343: PUSH
95344: EMPTY
95345: LIST
95346: LIST
95347: PUSH
95348: LD_INT 2
95350: PUSH
95351: LD_INT 2
95353: NEG
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: LD_INT 2
95361: NEG
95362: PUSH
95363: LD_INT 4
95365: NEG
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: PUSH
95371: LD_INT 4
95373: PUSH
95374: LD_INT 0
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 4
95383: PUSH
95384: LD_INT 1
95386: NEG
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 5
95394: PUSH
95395: LD_INT 0
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: PUSH
95402: LD_INT 5
95404: PUSH
95405: LD_INT 1
95407: PUSH
95408: EMPTY
95409: LIST
95410: LIST
95411: PUSH
95412: LD_INT 4
95414: PUSH
95415: LD_INT 1
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: PUSH
95422: LD_INT 3
95424: PUSH
95425: LD_INT 0
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: LD_INT 3
95434: PUSH
95435: LD_INT 1
95437: NEG
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PUSH
95443: LD_INT 3
95445: PUSH
95446: LD_INT 2
95448: NEG
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 5
95456: PUSH
95457: LD_INT 2
95459: PUSH
95460: EMPTY
95461: LIST
95462: LIST
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95511: LD_ADDR_VAR 0 32
95515: PUSH
95516: LD_INT 4
95518: NEG
95519: PUSH
95520: LD_INT 0
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: PUSH
95527: LD_INT 4
95529: NEG
95530: PUSH
95531: LD_INT 1
95533: NEG
95534: PUSH
95535: EMPTY
95536: LIST
95537: LIST
95538: PUSH
95539: LD_INT 3
95541: NEG
95542: PUSH
95543: LD_INT 0
95545: PUSH
95546: EMPTY
95547: LIST
95548: LIST
95549: PUSH
95550: LD_INT 3
95552: NEG
95553: PUSH
95554: LD_INT 1
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PUSH
95561: LD_INT 4
95563: NEG
95564: PUSH
95565: LD_INT 1
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 5
95574: NEG
95575: PUSH
95576: LD_INT 0
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 5
95585: NEG
95586: PUSH
95587: LD_INT 1
95589: NEG
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: LD_INT 5
95597: NEG
95598: PUSH
95599: LD_INT 2
95601: NEG
95602: PUSH
95603: EMPTY
95604: LIST
95605: LIST
95606: PUSH
95607: LD_INT 3
95609: NEG
95610: PUSH
95611: LD_INT 2
95613: PUSH
95614: EMPTY
95615: LIST
95616: LIST
95617: PUSH
95618: LD_INT 3
95620: NEG
95621: PUSH
95622: LD_INT 3
95624: NEG
95625: PUSH
95626: EMPTY
95627: LIST
95628: LIST
95629: PUSH
95630: LD_INT 3
95632: NEG
95633: PUSH
95634: LD_INT 4
95636: NEG
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: PUSH
95642: LD_INT 2
95644: NEG
95645: PUSH
95646: LD_INT 3
95648: NEG
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 2
95656: NEG
95657: PUSH
95658: LD_INT 2
95660: NEG
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: PUSH
95666: LD_INT 3
95668: NEG
95669: PUSH
95670: LD_INT 2
95672: NEG
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: PUSH
95678: LD_INT 4
95680: NEG
95681: PUSH
95682: LD_INT 3
95684: NEG
95685: PUSH
95686: EMPTY
95687: LIST
95688: LIST
95689: PUSH
95690: LD_INT 4
95692: NEG
95693: PUSH
95694: LD_INT 4
95696: NEG
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: PUSH
95702: LD_INT 2
95704: NEG
95705: PUSH
95706: LD_INT 4
95708: NEG
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: PUSH
95714: LD_INT 4
95716: NEG
95717: PUSH
95718: LD_INT 2
95720: NEG
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 0
95728: PUSH
95729: LD_INT 4
95731: NEG
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: LD_INT 0
95739: PUSH
95740: LD_INT 5
95742: NEG
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: PUSH
95748: LD_INT 1
95750: PUSH
95751: LD_INT 4
95753: NEG
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 1
95761: PUSH
95762: LD_INT 3
95764: NEG
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: PUSH
95770: LD_INT 0
95772: PUSH
95773: LD_INT 3
95775: NEG
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 1
95783: NEG
95784: PUSH
95785: LD_INT 4
95787: NEG
95788: PUSH
95789: EMPTY
95790: LIST
95791: LIST
95792: PUSH
95793: LD_INT 1
95795: NEG
95796: PUSH
95797: LD_INT 5
95799: NEG
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: LD_INT 2
95807: PUSH
95808: LD_INT 3
95810: NEG
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: LD_INT 2
95818: NEG
95819: PUSH
95820: LD_INT 5
95822: NEG
95823: PUSH
95824: EMPTY
95825: LIST
95826: LIST
95827: PUSH
95828: LD_INT 3
95830: PUSH
95831: LD_INT 0
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 3
95840: PUSH
95841: LD_INT 1
95843: NEG
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: PUSH
95849: LD_INT 4
95851: PUSH
95852: LD_INT 0
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 4
95861: PUSH
95862: LD_INT 1
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: PUSH
95869: LD_INT 3
95871: PUSH
95872: LD_INT 1
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: PUSH
95879: LD_INT 2
95881: PUSH
95882: LD_INT 0
95884: PUSH
95885: EMPTY
95886: LIST
95887: LIST
95888: PUSH
95889: LD_INT 2
95891: PUSH
95892: LD_INT 1
95894: NEG
95895: PUSH
95896: EMPTY
95897: LIST
95898: LIST
95899: PUSH
95900: LD_INT 2
95902: PUSH
95903: LD_INT 2
95905: NEG
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 4
95913: PUSH
95914: LD_INT 2
95916: PUSH
95917: EMPTY
95918: LIST
95919: LIST
95920: PUSH
95921: LD_INT 4
95923: PUSH
95924: LD_INT 4
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 4
95933: PUSH
95934: LD_INT 3
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 5
95943: PUSH
95944: LD_INT 4
95946: PUSH
95947: EMPTY
95948: LIST
95949: LIST
95950: PUSH
95951: LD_INT 5
95953: PUSH
95954: LD_INT 5
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: LD_INT 4
95963: PUSH
95964: LD_INT 5
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: LD_INT 3
95973: PUSH
95974: LD_INT 4
95976: PUSH
95977: EMPTY
95978: LIST
95979: LIST
95980: PUSH
95981: LD_INT 3
95983: PUSH
95984: LD_INT 3
95986: PUSH
95987: EMPTY
95988: LIST
95989: LIST
95990: PUSH
95991: LD_INT 5
95993: PUSH
95994: LD_INT 3
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PUSH
96001: LD_INT 3
96003: PUSH
96004: LD_INT 5
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96058: LD_ADDR_VAR 0 33
96062: PUSH
96063: LD_INT 4
96065: NEG
96066: PUSH
96067: LD_INT 4
96069: NEG
96070: PUSH
96071: EMPTY
96072: LIST
96073: LIST
96074: PUSH
96075: LD_INT 4
96077: NEG
96078: PUSH
96079: LD_INT 5
96081: NEG
96082: PUSH
96083: EMPTY
96084: LIST
96085: LIST
96086: PUSH
96087: LD_INT 3
96089: NEG
96090: PUSH
96091: LD_INT 4
96093: NEG
96094: PUSH
96095: EMPTY
96096: LIST
96097: LIST
96098: PUSH
96099: LD_INT 3
96101: NEG
96102: PUSH
96103: LD_INT 3
96105: NEG
96106: PUSH
96107: EMPTY
96108: LIST
96109: LIST
96110: PUSH
96111: LD_INT 4
96113: NEG
96114: PUSH
96115: LD_INT 3
96117: NEG
96118: PUSH
96119: EMPTY
96120: LIST
96121: LIST
96122: PUSH
96123: LD_INT 5
96125: NEG
96126: PUSH
96127: LD_INT 4
96129: NEG
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: PUSH
96135: LD_INT 5
96137: NEG
96138: PUSH
96139: LD_INT 5
96141: NEG
96142: PUSH
96143: EMPTY
96144: LIST
96145: LIST
96146: PUSH
96147: LD_INT 3
96149: NEG
96150: PUSH
96151: LD_INT 5
96153: NEG
96154: PUSH
96155: EMPTY
96156: LIST
96157: LIST
96158: PUSH
96159: LD_INT 5
96161: NEG
96162: PUSH
96163: LD_INT 3
96165: NEG
96166: PUSH
96167: EMPTY
96168: LIST
96169: LIST
96170: PUSH
96171: LD_INT 0
96173: PUSH
96174: LD_INT 3
96176: NEG
96177: PUSH
96178: EMPTY
96179: LIST
96180: LIST
96181: PUSH
96182: LD_INT 0
96184: PUSH
96185: LD_INT 4
96187: NEG
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: PUSH
96193: LD_INT 1
96195: PUSH
96196: LD_INT 3
96198: NEG
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 1
96206: PUSH
96207: LD_INT 2
96209: NEG
96210: PUSH
96211: EMPTY
96212: LIST
96213: LIST
96214: PUSH
96215: LD_INT 0
96217: PUSH
96218: LD_INT 2
96220: NEG
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PUSH
96226: LD_INT 1
96228: NEG
96229: PUSH
96230: LD_INT 3
96232: NEG
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 1
96240: NEG
96241: PUSH
96242: LD_INT 4
96244: NEG
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: PUSH
96250: LD_INT 2
96252: PUSH
96253: LD_INT 2
96255: NEG
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: PUSH
96261: LD_INT 2
96263: NEG
96264: PUSH
96265: LD_INT 4
96267: NEG
96268: PUSH
96269: EMPTY
96270: LIST
96271: LIST
96272: PUSH
96273: LD_INT 4
96275: PUSH
96276: LD_INT 0
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: PUSH
96283: LD_INT 4
96285: PUSH
96286: LD_INT 1
96288: NEG
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PUSH
96294: LD_INT 5
96296: PUSH
96297: LD_INT 0
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: PUSH
96304: LD_INT 5
96306: PUSH
96307: LD_INT 1
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: PUSH
96314: LD_INT 4
96316: PUSH
96317: LD_INT 1
96319: PUSH
96320: EMPTY
96321: LIST
96322: LIST
96323: PUSH
96324: LD_INT 3
96326: PUSH
96327: LD_INT 0
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 3
96336: PUSH
96337: LD_INT 1
96339: NEG
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: PUSH
96345: LD_INT 3
96347: PUSH
96348: LD_INT 2
96350: NEG
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 5
96358: PUSH
96359: LD_INT 2
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: PUSH
96366: LD_INT 3
96368: PUSH
96369: LD_INT 3
96371: PUSH
96372: EMPTY
96373: LIST
96374: LIST
96375: PUSH
96376: LD_INT 3
96378: PUSH
96379: LD_INT 2
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 4
96388: PUSH
96389: LD_INT 3
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: PUSH
96396: LD_INT 4
96398: PUSH
96399: LD_INT 4
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: LD_INT 3
96408: PUSH
96409: LD_INT 4
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 2
96418: PUSH
96419: LD_INT 3
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 2
96428: PUSH
96429: LD_INT 2
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: PUSH
96436: LD_INT 4
96438: PUSH
96439: LD_INT 2
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 2
96448: PUSH
96449: LD_INT 4
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: LD_INT 0
96458: PUSH
96459: LD_INT 4
96461: PUSH
96462: EMPTY
96463: LIST
96464: LIST
96465: PUSH
96466: LD_INT 0
96468: PUSH
96469: LD_INT 3
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: PUSH
96476: LD_INT 1
96478: PUSH
96479: LD_INT 4
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PUSH
96486: LD_INT 1
96488: PUSH
96489: LD_INT 5
96491: PUSH
96492: EMPTY
96493: LIST
96494: LIST
96495: PUSH
96496: LD_INT 0
96498: PUSH
96499: LD_INT 5
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: PUSH
96506: LD_INT 1
96508: NEG
96509: PUSH
96510: LD_INT 4
96512: PUSH
96513: EMPTY
96514: LIST
96515: LIST
96516: PUSH
96517: LD_INT 1
96519: NEG
96520: PUSH
96521: LD_INT 3
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 2
96530: PUSH
96531: LD_INT 5
96533: PUSH
96534: EMPTY
96535: LIST
96536: LIST
96537: PUSH
96538: LD_INT 2
96540: NEG
96541: PUSH
96542: LD_INT 3
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96596: LD_ADDR_VAR 0 34
96600: PUSH
96601: LD_INT 0
96603: PUSH
96604: LD_INT 4
96606: NEG
96607: PUSH
96608: EMPTY
96609: LIST
96610: LIST
96611: PUSH
96612: LD_INT 0
96614: PUSH
96615: LD_INT 5
96617: NEG
96618: PUSH
96619: EMPTY
96620: LIST
96621: LIST
96622: PUSH
96623: LD_INT 1
96625: PUSH
96626: LD_INT 4
96628: NEG
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: LD_INT 1
96636: PUSH
96637: LD_INT 3
96639: NEG
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 0
96647: PUSH
96648: LD_INT 3
96650: NEG
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: PUSH
96656: LD_INT 1
96658: NEG
96659: PUSH
96660: LD_INT 4
96662: NEG
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 1
96670: NEG
96671: PUSH
96672: LD_INT 5
96674: NEG
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 2
96682: PUSH
96683: LD_INT 3
96685: NEG
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 2
96693: NEG
96694: PUSH
96695: LD_INT 5
96697: NEG
96698: PUSH
96699: EMPTY
96700: LIST
96701: LIST
96702: PUSH
96703: LD_INT 3
96705: PUSH
96706: LD_INT 0
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 3
96715: PUSH
96716: LD_INT 1
96718: NEG
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: PUSH
96724: LD_INT 4
96726: PUSH
96727: LD_INT 0
96729: PUSH
96730: EMPTY
96731: LIST
96732: LIST
96733: PUSH
96734: LD_INT 4
96736: PUSH
96737: LD_INT 1
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: PUSH
96744: LD_INT 3
96746: PUSH
96747: LD_INT 1
96749: PUSH
96750: EMPTY
96751: LIST
96752: LIST
96753: PUSH
96754: LD_INT 2
96756: PUSH
96757: LD_INT 0
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: PUSH
96764: LD_INT 2
96766: PUSH
96767: LD_INT 1
96769: NEG
96770: PUSH
96771: EMPTY
96772: LIST
96773: LIST
96774: PUSH
96775: LD_INT 2
96777: PUSH
96778: LD_INT 2
96780: NEG
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: LD_INT 4
96788: PUSH
96789: LD_INT 2
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: LD_INT 4
96798: PUSH
96799: LD_INT 4
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: LD_INT 4
96808: PUSH
96809: LD_INT 3
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 5
96818: PUSH
96819: LD_INT 4
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: LD_INT 5
96828: PUSH
96829: LD_INT 5
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: LD_INT 4
96838: PUSH
96839: LD_INT 5
96841: PUSH
96842: EMPTY
96843: LIST
96844: LIST
96845: PUSH
96846: LD_INT 3
96848: PUSH
96849: LD_INT 4
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 3
96858: PUSH
96859: LD_INT 3
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 5
96868: PUSH
96869: LD_INT 3
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 3
96878: PUSH
96879: LD_INT 5
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 0
96888: PUSH
96889: LD_INT 3
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: PUSH
96896: LD_INT 0
96898: PUSH
96899: LD_INT 2
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: LD_INT 1
96908: PUSH
96909: LD_INT 3
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: PUSH
96916: LD_INT 1
96918: PUSH
96919: LD_INT 4
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: LD_INT 0
96928: PUSH
96929: LD_INT 4
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 1
96938: NEG
96939: PUSH
96940: LD_INT 3
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: PUSH
96947: LD_INT 1
96949: NEG
96950: PUSH
96951: LD_INT 2
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 2
96960: PUSH
96961: LD_INT 4
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: PUSH
96968: LD_INT 2
96970: NEG
96971: PUSH
96972: LD_INT 2
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PUSH
96979: LD_INT 4
96981: NEG
96982: PUSH
96983: LD_INT 0
96985: PUSH
96986: EMPTY
96987: LIST
96988: LIST
96989: PUSH
96990: LD_INT 4
96992: NEG
96993: PUSH
96994: LD_INT 1
96996: NEG
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: PUSH
97002: LD_INT 3
97004: NEG
97005: PUSH
97006: LD_INT 0
97008: PUSH
97009: EMPTY
97010: LIST
97011: LIST
97012: PUSH
97013: LD_INT 3
97015: NEG
97016: PUSH
97017: LD_INT 1
97019: PUSH
97020: EMPTY
97021: LIST
97022: LIST
97023: PUSH
97024: LD_INT 4
97026: NEG
97027: PUSH
97028: LD_INT 1
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: PUSH
97035: LD_INT 5
97037: NEG
97038: PUSH
97039: LD_INT 0
97041: PUSH
97042: EMPTY
97043: LIST
97044: LIST
97045: PUSH
97046: LD_INT 5
97048: NEG
97049: PUSH
97050: LD_INT 1
97052: NEG
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PUSH
97058: LD_INT 5
97060: NEG
97061: PUSH
97062: LD_INT 2
97064: NEG
97065: PUSH
97066: EMPTY
97067: LIST
97068: LIST
97069: PUSH
97070: LD_INT 3
97072: NEG
97073: PUSH
97074: LD_INT 2
97076: PUSH
97077: EMPTY
97078: LIST
97079: LIST
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: ST_TO_ADDR
// end ; end ;
97128: GO 97131
97130: POP
// case btype of b_depot , b_warehouse :
97131: LD_VAR 0 1
97135: PUSH
97136: LD_INT 0
97138: DOUBLE
97139: EQUAL
97140: IFTRUE 97150
97142: LD_INT 1
97144: DOUBLE
97145: EQUAL
97146: IFTRUE 97150
97148: GO 97351
97150: POP
// case nation of nation_american :
97151: LD_VAR 0 5
97155: PUSH
97156: LD_INT 1
97158: DOUBLE
97159: EQUAL
97160: IFTRUE 97164
97162: GO 97220
97164: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97165: LD_ADDR_VAR 0 9
97169: PUSH
97170: LD_VAR 0 11
97174: PUSH
97175: LD_VAR 0 12
97179: PUSH
97180: LD_VAR 0 13
97184: PUSH
97185: LD_VAR 0 14
97189: PUSH
97190: LD_VAR 0 15
97194: PUSH
97195: LD_VAR 0 16
97199: PUSH
97200: EMPTY
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: PUSH
97208: LD_VAR 0 4
97212: PUSH
97213: LD_INT 1
97215: PLUS
97216: ARRAY
97217: ST_TO_ADDR
97218: GO 97349
97220: LD_INT 2
97222: DOUBLE
97223: EQUAL
97224: IFTRUE 97228
97226: GO 97284
97228: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97229: LD_ADDR_VAR 0 9
97233: PUSH
97234: LD_VAR 0 17
97238: PUSH
97239: LD_VAR 0 18
97243: PUSH
97244: LD_VAR 0 19
97248: PUSH
97249: LD_VAR 0 20
97253: PUSH
97254: LD_VAR 0 21
97258: PUSH
97259: LD_VAR 0 22
97263: PUSH
97264: EMPTY
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: PUSH
97272: LD_VAR 0 4
97276: PUSH
97277: LD_INT 1
97279: PLUS
97280: ARRAY
97281: ST_TO_ADDR
97282: GO 97349
97284: LD_INT 3
97286: DOUBLE
97287: EQUAL
97288: IFTRUE 97292
97290: GO 97348
97292: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97293: LD_ADDR_VAR 0 9
97297: PUSH
97298: LD_VAR 0 23
97302: PUSH
97303: LD_VAR 0 24
97307: PUSH
97308: LD_VAR 0 25
97312: PUSH
97313: LD_VAR 0 26
97317: PUSH
97318: LD_VAR 0 27
97322: PUSH
97323: LD_VAR 0 28
97327: PUSH
97328: EMPTY
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: PUSH
97336: LD_VAR 0 4
97340: PUSH
97341: LD_INT 1
97343: PLUS
97344: ARRAY
97345: ST_TO_ADDR
97346: GO 97349
97348: POP
97349: GO 97904
97351: LD_INT 2
97353: DOUBLE
97354: EQUAL
97355: IFTRUE 97365
97357: LD_INT 3
97359: DOUBLE
97360: EQUAL
97361: IFTRUE 97365
97363: GO 97421
97365: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97366: LD_ADDR_VAR 0 9
97370: PUSH
97371: LD_VAR 0 29
97375: PUSH
97376: LD_VAR 0 30
97380: PUSH
97381: LD_VAR 0 31
97385: PUSH
97386: LD_VAR 0 32
97390: PUSH
97391: LD_VAR 0 33
97395: PUSH
97396: LD_VAR 0 34
97400: PUSH
97401: EMPTY
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: PUSH
97409: LD_VAR 0 4
97413: PUSH
97414: LD_INT 1
97416: PLUS
97417: ARRAY
97418: ST_TO_ADDR
97419: GO 97904
97421: LD_INT 16
97423: DOUBLE
97424: EQUAL
97425: IFTRUE 97483
97427: LD_INT 17
97429: DOUBLE
97430: EQUAL
97431: IFTRUE 97483
97433: LD_INT 18
97435: DOUBLE
97436: EQUAL
97437: IFTRUE 97483
97439: LD_INT 19
97441: DOUBLE
97442: EQUAL
97443: IFTRUE 97483
97445: LD_INT 22
97447: DOUBLE
97448: EQUAL
97449: IFTRUE 97483
97451: LD_INT 20
97453: DOUBLE
97454: EQUAL
97455: IFTRUE 97483
97457: LD_INT 21
97459: DOUBLE
97460: EQUAL
97461: IFTRUE 97483
97463: LD_INT 23
97465: DOUBLE
97466: EQUAL
97467: IFTRUE 97483
97469: LD_INT 24
97471: DOUBLE
97472: EQUAL
97473: IFTRUE 97483
97475: LD_INT 25
97477: DOUBLE
97478: EQUAL
97479: IFTRUE 97483
97481: GO 97539
97483: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97484: LD_ADDR_VAR 0 9
97488: PUSH
97489: LD_VAR 0 35
97493: PUSH
97494: LD_VAR 0 36
97498: PUSH
97499: LD_VAR 0 37
97503: PUSH
97504: LD_VAR 0 38
97508: PUSH
97509: LD_VAR 0 39
97513: PUSH
97514: LD_VAR 0 40
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: PUSH
97527: LD_VAR 0 4
97531: PUSH
97532: LD_INT 1
97534: PLUS
97535: ARRAY
97536: ST_TO_ADDR
97537: GO 97904
97539: LD_INT 6
97541: DOUBLE
97542: EQUAL
97543: IFTRUE 97595
97545: LD_INT 7
97547: DOUBLE
97548: EQUAL
97549: IFTRUE 97595
97551: LD_INT 8
97553: DOUBLE
97554: EQUAL
97555: IFTRUE 97595
97557: LD_INT 13
97559: DOUBLE
97560: EQUAL
97561: IFTRUE 97595
97563: LD_INT 12
97565: DOUBLE
97566: EQUAL
97567: IFTRUE 97595
97569: LD_INT 15
97571: DOUBLE
97572: EQUAL
97573: IFTRUE 97595
97575: LD_INT 11
97577: DOUBLE
97578: EQUAL
97579: IFTRUE 97595
97581: LD_INT 14
97583: DOUBLE
97584: EQUAL
97585: IFTRUE 97595
97587: LD_INT 10
97589: DOUBLE
97590: EQUAL
97591: IFTRUE 97595
97593: GO 97651
97595: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97596: LD_ADDR_VAR 0 9
97600: PUSH
97601: LD_VAR 0 41
97605: PUSH
97606: LD_VAR 0 42
97610: PUSH
97611: LD_VAR 0 43
97615: PUSH
97616: LD_VAR 0 44
97620: PUSH
97621: LD_VAR 0 45
97625: PUSH
97626: LD_VAR 0 46
97630: PUSH
97631: EMPTY
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: PUSH
97639: LD_VAR 0 4
97643: PUSH
97644: LD_INT 1
97646: PLUS
97647: ARRAY
97648: ST_TO_ADDR
97649: GO 97904
97651: LD_INT 36
97653: DOUBLE
97654: EQUAL
97655: IFTRUE 97659
97657: GO 97715
97659: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97660: LD_ADDR_VAR 0 9
97664: PUSH
97665: LD_VAR 0 47
97669: PUSH
97670: LD_VAR 0 48
97674: PUSH
97675: LD_VAR 0 49
97679: PUSH
97680: LD_VAR 0 50
97684: PUSH
97685: LD_VAR 0 51
97689: PUSH
97690: LD_VAR 0 52
97694: PUSH
97695: EMPTY
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: PUSH
97703: LD_VAR 0 4
97707: PUSH
97708: LD_INT 1
97710: PLUS
97711: ARRAY
97712: ST_TO_ADDR
97713: GO 97904
97715: LD_INT 4
97717: DOUBLE
97718: EQUAL
97719: IFTRUE 97741
97721: LD_INT 5
97723: DOUBLE
97724: EQUAL
97725: IFTRUE 97741
97727: LD_INT 34
97729: DOUBLE
97730: EQUAL
97731: IFTRUE 97741
97733: LD_INT 37
97735: DOUBLE
97736: EQUAL
97737: IFTRUE 97741
97739: GO 97797
97741: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97742: LD_ADDR_VAR 0 9
97746: PUSH
97747: LD_VAR 0 53
97751: PUSH
97752: LD_VAR 0 54
97756: PUSH
97757: LD_VAR 0 55
97761: PUSH
97762: LD_VAR 0 56
97766: PUSH
97767: LD_VAR 0 57
97771: PUSH
97772: LD_VAR 0 58
97776: PUSH
97777: EMPTY
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: PUSH
97785: LD_VAR 0 4
97789: PUSH
97790: LD_INT 1
97792: PLUS
97793: ARRAY
97794: ST_TO_ADDR
97795: GO 97904
97797: LD_INT 31
97799: DOUBLE
97800: EQUAL
97801: IFTRUE 97847
97803: LD_INT 32
97805: DOUBLE
97806: EQUAL
97807: IFTRUE 97847
97809: LD_INT 33
97811: DOUBLE
97812: EQUAL
97813: IFTRUE 97847
97815: LD_INT 27
97817: DOUBLE
97818: EQUAL
97819: IFTRUE 97847
97821: LD_INT 26
97823: DOUBLE
97824: EQUAL
97825: IFTRUE 97847
97827: LD_INT 28
97829: DOUBLE
97830: EQUAL
97831: IFTRUE 97847
97833: LD_INT 29
97835: DOUBLE
97836: EQUAL
97837: IFTRUE 97847
97839: LD_INT 30
97841: DOUBLE
97842: EQUAL
97843: IFTRUE 97847
97845: GO 97903
97847: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
97848: LD_ADDR_VAR 0 9
97852: PUSH
97853: LD_VAR 0 59
97857: PUSH
97858: LD_VAR 0 60
97862: PUSH
97863: LD_VAR 0 61
97867: PUSH
97868: LD_VAR 0 62
97872: PUSH
97873: LD_VAR 0 63
97877: PUSH
97878: LD_VAR 0 64
97882: PUSH
97883: EMPTY
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: PUSH
97891: LD_VAR 0 4
97895: PUSH
97896: LD_INT 1
97898: PLUS
97899: ARRAY
97900: ST_TO_ADDR
97901: GO 97904
97903: POP
// temp_list2 = [ ] ;
97904: LD_ADDR_VAR 0 10
97908: PUSH
97909: EMPTY
97910: ST_TO_ADDR
// for i in temp_list do
97911: LD_ADDR_VAR 0 8
97915: PUSH
97916: LD_VAR 0 9
97920: PUSH
97921: FOR_IN
97922: IFFALSE 97974
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97924: LD_ADDR_VAR 0 10
97928: PUSH
97929: LD_VAR 0 10
97933: PUSH
97934: LD_VAR 0 8
97938: PUSH
97939: LD_INT 1
97941: ARRAY
97942: PUSH
97943: LD_VAR 0 2
97947: PLUS
97948: PUSH
97949: LD_VAR 0 8
97953: PUSH
97954: LD_INT 2
97956: ARRAY
97957: PUSH
97958: LD_VAR 0 3
97962: PLUS
97963: PUSH
97964: EMPTY
97965: LIST
97966: LIST
97967: PUSH
97968: EMPTY
97969: LIST
97970: ADD
97971: ST_TO_ADDR
97972: GO 97921
97974: POP
97975: POP
// result = temp_list2 ;
97976: LD_ADDR_VAR 0 7
97980: PUSH
97981: LD_VAR 0 10
97985: ST_TO_ADDR
// end ;
97986: LD_VAR 0 7
97990: RET
// export function EnemyInRange ( unit , dist ) ; begin
97991: LD_INT 0
97993: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
97994: LD_ADDR_VAR 0 3
97998: PUSH
97999: LD_VAR 0 1
98003: PPUSH
98004: CALL_OW 255
98008: PPUSH
98009: LD_VAR 0 1
98013: PPUSH
98014: CALL_OW 250
98018: PPUSH
98019: LD_VAR 0 1
98023: PPUSH
98024: CALL_OW 251
98028: PPUSH
98029: LD_VAR 0 2
98033: PPUSH
98034: CALL 72095 0 4
98038: PUSH
98039: LD_INT 4
98041: ARRAY
98042: ST_TO_ADDR
// end ;
98043: LD_VAR 0 3
98047: RET
// export function PlayerSeeMe ( unit ) ; begin
98048: LD_INT 0
98050: PPUSH
// result := See ( your_side , unit ) ;
98051: LD_ADDR_VAR 0 2
98055: PUSH
98056: LD_OWVAR 2
98060: PPUSH
98061: LD_VAR 0 1
98065: PPUSH
98066: CALL_OW 292
98070: ST_TO_ADDR
// end ;
98071: LD_VAR 0 2
98075: RET
// export function ReverseDir ( unit ) ; begin
98076: LD_INT 0
98078: PPUSH
// if not unit then
98079: LD_VAR 0 1
98083: NOT
98084: IFFALSE 98088
// exit ;
98086: GO 98134
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
98088: LD_ADDR_VAR 0 2
98092: PUSH
98093: LD_INT 3
98095: PUSH
98096: LD_INT 4
98098: PUSH
98099: LD_INT 5
98101: PUSH
98102: LD_INT 0
98104: PUSH
98105: LD_INT 1
98107: PUSH
98108: LD_INT 2
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: PUSH
98119: LD_VAR 0 1
98123: PPUSH
98124: CALL_OW 254
98128: PUSH
98129: LD_INT 1
98131: PLUS
98132: ARRAY
98133: ST_TO_ADDR
// end ;
98134: LD_VAR 0 2
98138: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98139: LD_INT 0
98141: PPUSH
98142: PPUSH
98143: PPUSH
98144: PPUSH
98145: PPUSH
// if not hexes then
98146: LD_VAR 0 2
98150: NOT
98151: IFFALSE 98155
// exit ;
98153: GO 98303
// dist := 9999 ;
98155: LD_ADDR_VAR 0 5
98159: PUSH
98160: LD_INT 9999
98162: ST_TO_ADDR
// for i = 1 to hexes do
98163: LD_ADDR_VAR 0 4
98167: PUSH
98168: DOUBLE
98169: LD_INT 1
98171: DEC
98172: ST_TO_ADDR
98173: LD_VAR 0 2
98177: PUSH
98178: FOR_TO
98179: IFFALSE 98291
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98181: LD_VAR 0 1
98185: PPUSH
98186: LD_VAR 0 2
98190: PUSH
98191: LD_VAR 0 4
98195: ARRAY
98196: PUSH
98197: LD_INT 1
98199: ARRAY
98200: PPUSH
98201: LD_VAR 0 2
98205: PUSH
98206: LD_VAR 0 4
98210: ARRAY
98211: PUSH
98212: LD_INT 2
98214: ARRAY
98215: PPUSH
98216: CALL_OW 297
98220: PUSH
98221: LD_VAR 0 5
98225: LESS
98226: IFFALSE 98289
// begin hex := hexes [ i ] ;
98228: LD_ADDR_VAR 0 7
98232: PUSH
98233: LD_VAR 0 2
98237: PUSH
98238: LD_VAR 0 4
98242: ARRAY
98243: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98244: LD_ADDR_VAR 0 5
98248: PUSH
98249: LD_VAR 0 1
98253: PPUSH
98254: LD_VAR 0 2
98258: PUSH
98259: LD_VAR 0 4
98263: ARRAY
98264: PUSH
98265: LD_INT 1
98267: ARRAY
98268: PPUSH
98269: LD_VAR 0 2
98273: PUSH
98274: LD_VAR 0 4
98278: ARRAY
98279: PUSH
98280: LD_INT 2
98282: ARRAY
98283: PPUSH
98284: CALL_OW 297
98288: ST_TO_ADDR
// end ; end ;
98289: GO 98178
98291: POP
98292: POP
// result := hex ;
98293: LD_ADDR_VAR 0 3
98297: PUSH
98298: LD_VAR 0 7
98302: ST_TO_ADDR
// end ;
98303: LD_VAR 0 3
98307: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98308: LD_INT 0
98310: PPUSH
98311: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98312: LD_VAR 0 1
98316: NOT
98317: PUSH
98318: LD_VAR 0 1
98322: PUSH
98323: LD_INT 21
98325: PUSH
98326: LD_INT 2
98328: PUSH
98329: EMPTY
98330: LIST
98331: LIST
98332: PUSH
98333: LD_INT 23
98335: PUSH
98336: LD_INT 2
98338: PUSH
98339: EMPTY
98340: LIST
98341: LIST
98342: PUSH
98343: EMPTY
98344: LIST
98345: LIST
98346: PPUSH
98347: CALL_OW 69
98351: IN
98352: NOT
98353: OR
98354: IFFALSE 98358
// exit ;
98356: GO 98405
// for i = 1 to 3 do
98358: LD_ADDR_VAR 0 3
98362: PUSH
98363: DOUBLE
98364: LD_INT 1
98366: DEC
98367: ST_TO_ADDR
98368: LD_INT 3
98370: PUSH
98371: FOR_TO
98372: IFFALSE 98403
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98374: LD_VAR 0 1
98378: PPUSH
98379: CALL_OW 250
98383: PPUSH
98384: LD_VAR 0 1
98388: PPUSH
98389: CALL_OW 251
98393: PPUSH
98394: LD_INT 1
98396: PPUSH
98397: CALL_OW 453
98401: GO 98371
98403: POP
98404: POP
// end ;
98405: LD_VAR 0 2
98409: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98410: LD_INT 0
98412: PPUSH
98413: PPUSH
98414: PPUSH
98415: PPUSH
98416: PPUSH
98417: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98418: LD_VAR 0 1
98422: NOT
98423: PUSH
98424: LD_VAR 0 2
98428: NOT
98429: OR
98430: PUSH
98431: LD_VAR 0 1
98435: PPUSH
98436: CALL_OW 314
98440: OR
98441: IFFALSE 98445
// exit ;
98443: GO 98886
// x := GetX ( enemy_unit ) ;
98445: LD_ADDR_VAR 0 7
98449: PUSH
98450: LD_VAR 0 2
98454: PPUSH
98455: CALL_OW 250
98459: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98460: LD_ADDR_VAR 0 8
98464: PUSH
98465: LD_VAR 0 2
98469: PPUSH
98470: CALL_OW 251
98474: ST_TO_ADDR
// if not x or not y then
98475: LD_VAR 0 7
98479: NOT
98480: PUSH
98481: LD_VAR 0 8
98485: NOT
98486: OR
98487: IFFALSE 98491
// exit ;
98489: GO 98886
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98491: LD_ADDR_VAR 0 6
98495: PUSH
98496: LD_VAR 0 7
98500: PPUSH
98501: LD_INT 0
98503: PPUSH
98504: LD_INT 4
98506: PPUSH
98507: CALL_OW 272
98511: PUSH
98512: LD_VAR 0 8
98516: PPUSH
98517: LD_INT 0
98519: PPUSH
98520: LD_INT 4
98522: PPUSH
98523: CALL_OW 273
98527: PUSH
98528: EMPTY
98529: LIST
98530: LIST
98531: PUSH
98532: LD_VAR 0 7
98536: PPUSH
98537: LD_INT 1
98539: PPUSH
98540: LD_INT 4
98542: PPUSH
98543: CALL_OW 272
98547: PUSH
98548: LD_VAR 0 8
98552: PPUSH
98553: LD_INT 1
98555: PPUSH
98556: LD_INT 4
98558: PPUSH
98559: CALL_OW 273
98563: PUSH
98564: EMPTY
98565: LIST
98566: LIST
98567: PUSH
98568: LD_VAR 0 7
98572: PPUSH
98573: LD_INT 2
98575: PPUSH
98576: LD_INT 4
98578: PPUSH
98579: CALL_OW 272
98583: PUSH
98584: LD_VAR 0 8
98588: PPUSH
98589: LD_INT 2
98591: PPUSH
98592: LD_INT 4
98594: PPUSH
98595: CALL_OW 273
98599: PUSH
98600: EMPTY
98601: LIST
98602: LIST
98603: PUSH
98604: LD_VAR 0 7
98608: PPUSH
98609: LD_INT 3
98611: PPUSH
98612: LD_INT 4
98614: PPUSH
98615: CALL_OW 272
98619: PUSH
98620: LD_VAR 0 8
98624: PPUSH
98625: LD_INT 3
98627: PPUSH
98628: LD_INT 4
98630: PPUSH
98631: CALL_OW 273
98635: PUSH
98636: EMPTY
98637: LIST
98638: LIST
98639: PUSH
98640: LD_VAR 0 7
98644: PPUSH
98645: LD_INT 4
98647: PPUSH
98648: LD_INT 4
98650: PPUSH
98651: CALL_OW 272
98655: PUSH
98656: LD_VAR 0 8
98660: PPUSH
98661: LD_INT 4
98663: PPUSH
98664: LD_INT 4
98666: PPUSH
98667: CALL_OW 273
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PUSH
98676: LD_VAR 0 7
98680: PPUSH
98681: LD_INT 5
98683: PPUSH
98684: LD_INT 4
98686: PPUSH
98687: CALL_OW 272
98691: PUSH
98692: LD_VAR 0 8
98696: PPUSH
98697: LD_INT 5
98699: PPUSH
98700: LD_INT 4
98702: PPUSH
98703: CALL_OW 273
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: EMPTY
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: ST_TO_ADDR
// for i = tmp downto 1 do
98720: LD_ADDR_VAR 0 4
98724: PUSH
98725: DOUBLE
98726: LD_VAR 0 6
98730: INC
98731: ST_TO_ADDR
98732: LD_INT 1
98734: PUSH
98735: FOR_DOWNTO
98736: IFFALSE 98837
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98738: LD_VAR 0 6
98742: PUSH
98743: LD_VAR 0 4
98747: ARRAY
98748: PUSH
98749: LD_INT 1
98751: ARRAY
98752: PPUSH
98753: LD_VAR 0 6
98757: PUSH
98758: LD_VAR 0 4
98762: ARRAY
98763: PUSH
98764: LD_INT 2
98766: ARRAY
98767: PPUSH
98768: CALL_OW 488
98772: NOT
98773: PUSH
98774: LD_VAR 0 6
98778: PUSH
98779: LD_VAR 0 4
98783: ARRAY
98784: PUSH
98785: LD_INT 1
98787: ARRAY
98788: PPUSH
98789: LD_VAR 0 6
98793: PUSH
98794: LD_VAR 0 4
98798: ARRAY
98799: PUSH
98800: LD_INT 2
98802: ARRAY
98803: PPUSH
98804: CALL_OW 428
98808: PUSH
98809: LD_INT 0
98811: NONEQUAL
98812: OR
98813: IFFALSE 98835
// tmp := Delete ( tmp , i ) ;
98815: LD_ADDR_VAR 0 6
98819: PUSH
98820: LD_VAR 0 6
98824: PPUSH
98825: LD_VAR 0 4
98829: PPUSH
98830: CALL_OW 3
98834: ST_TO_ADDR
98835: GO 98735
98837: POP
98838: POP
// j := GetClosestHex ( unit , tmp ) ;
98839: LD_ADDR_VAR 0 5
98843: PUSH
98844: LD_VAR 0 1
98848: PPUSH
98849: LD_VAR 0 6
98853: PPUSH
98854: CALL 98139 0 2
98858: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98859: LD_VAR 0 1
98863: PPUSH
98864: LD_VAR 0 5
98868: PUSH
98869: LD_INT 1
98871: ARRAY
98872: PPUSH
98873: LD_VAR 0 5
98877: PUSH
98878: LD_INT 2
98880: ARRAY
98881: PPUSH
98882: CALL_OW 111
// end ;
98886: LD_VAR 0 3
98890: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98891: LD_INT 0
98893: PPUSH
98894: PPUSH
98895: PPUSH
// uc_side = 0 ;
98896: LD_ADDR_OWVAR 20
98900: PUSH
98901: LD_INT 0
98903: ST_TO_ADDR
// uc_nation = 0 ;
98904: LD_ADDR_OWVAR 21
98908: PUSH
98909: LD_INT 0
98911: ST_TO_ADDR
// InitHc ;
98912: CALL_OW 19
// InitVc ;
98916: CALL_OW 20
// if mastodonts then
98920: LD_VAR 0 6
98924: IFFALSE 98991
// for i = 1 to mastodonts do
98926: LD_ADDR_VAR 0 11
98930: PUSH
98931: DOUBLE
98932: LD_INT 1
98934: DEC
98935: ST_TO_ADDR
98936: LD_VAR 0 6
98940: PUSH
98941: FOR_TO
98942: IFFALSE 98989
// begin vc_chassis := 31 ;
98944: LD_ADDR_OWVAR 37
98948: PUSH
98949: LD_INT 31
98951: ST_TO_ADDR
// vc_control := control_rider ;
98952: LD_ADDR_OWVAR 38
98956: PUSH
98957: LD_INT 4
98959: ST_TO_ADDR
// animal := CreateVehicle ;
98960: LD_ADDR_VAR 0 12
98964: PUSH
98965: CALL_OW 45
98969: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98970: LD_VAR 0 12
98974: PPUSH
98975: LD_VAR 0 8
98979: PPUSH
98980: LD_INT 0
98982: PPUSH
98983: CALL 105736 0 3
// end ;
98987: GO 98941
98989: POP
98990: POP
// if horses then
98991: LD_VAR 0 5
98995: IFFALSE 99062
// for i = 1 to horses do
98997: LD_ADDR_VAR 0 11
99001: PUSH
99002: DOUBLE
99003: LD_INT 1
99005: DEC
99006: ST_TO_ADDR
99007: LD_VAR 0 5
99011: PUSH
99012: FOR_TO
99013: IFFALSE 99060
// begin hc_class := 21 ;
99015: LD_ADDR_OWVAR 28
99019: PUSH
99020: LD_INT 21
99022: ST_TO_ADDR
// hc_gallery :=  ;
99023: LD_ADDR_OWVAR 33
99027: PUSH
99028: LD_STRING 
99030: ST_TO_ADDR
// animal := CreateHuman ;
99031: LD_ADDR_VAR 0 12
99035: PUSH
99036: CALL_OW 44
99040: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99041: LD_VAR 0 12
99045: PPUSH
99046: LD_VAR 0 8
99050: PPUSH
99051: LD_INT 0
99053: PPUSH
99054: CALL 105736 0 3
// end ;
99058: GO 99012
99060: POP
99061: POP
// if birds then
99062: LD_VAR 0 1
99066: IFFALSE 99133
// for i = 1 to birds do
99068: LD_ADDR_VAR 0 11
99072: PUSH
99073: DOUBLE
99074: LD_INT 1
99076: DEC
99077: ST_TO_ADDR
99078: LD_VAR 0 1
99082: PUSH
99083: FOR_TO
99084: IFFALSE 99131
// begin hc_class = 18 ;
99086: LD_ADDR_OWVAR 28
99090: PUSH
99091: LD_INT 18
99093: ST_TO_ADDR
// hc_gallery =  ;
99094: LD_ADDR_OWVAR 33
99098: PUSH
99099: LD_STRING 
99101: ST_TO_ADDR
// animal := CreateHuman ;
99102: LD_ADDR_VAR 0 12
99106: PUSH
99107: CALL_OW 44
99111: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99112: LD_VAR 0 12
99116: PPUSH
99117: LD_VAR 0 8
99121: PPUSH
99122: LD_INT 0
99124: PPUSH
99125: CALL 105736 0 3
// end ;
99129: GO 99083
99131: POP
99132: POP
// if tigers then
99133: LD_VAR 0 2
99137: IFFALSE 99221
// for i = 1 to tigers do
99139: LD_ADDR_VAR 0 11
99143: PUSH
99144: DOUBLE
99145: LD_INT 1
99147: DEC
99148: ST_TO_ADDR
99149: LD_VAR 0 2
99153: PUSH
99154: FOR_TO
99155: IFFALSE 99219
// begin hc_class = class_tiger ;
99157: LD_ADDR_OWVAR 28
99161: PUSH
99162: LD_INT 14
99164: ST_TO_ADDR
// hc_gallery =  ;
99165: LD_ADDR_OWVAR 33
99169: PUSH
99170: LD_STRING 
99172: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99173: LD_ADDR_OWVAR 35
99177: PUSH
99178: LD_INT 7
99180: NEG
99181: PPUSH
99182: LD_INT 7
99184: PPUSH
99185: CALL_OW 12
99189: ST_TO_ADDR
// animal := CreateHuman ;
99190: LD_ADDR_VAR 0 12
99194: PUSH
99195: CALL_OW 44
99199: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99200: LD_VAR 0 12
99204: PPUSH
99205: LD_VAR 0 8
99209: PPUSH
99210: LD_INT 0
99212: PPUSH
99213: CALL 105736 0 3
// end ;
99217: GO 99154
99219: POP
99220: POP
// if apemans then
99221: LD_VAR 0 3
99225: IFFALSE 99348
// for i = 1 to apemans do
99227: LD_ADDR_VAR 0 11
99231: PUSH
99232: DOUBLE
99233: LD_INT 1
99235: DEC
99236: ST_TO_ADDR
99237: LD_VAR 0 3
99241: PUSH
99242: FOR_TO
99243: IFFALSE 99346
// begin hc_class = class_apeman ;
99245: LD_ADDR_OWVAR 28
99249: PUSH
99250: LD_INT 12
99252: ST_TO_ADDR
// hc_gallery =  ;
99253: LD_ADDR_OWVAR 33
99257: PUSH
99258: LD_STRING 
99260: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99261: LD_ADDR_OWVAR 35
99265: PUSH
99266: LD_INT 5
99268: NEG
99269: PPUSH
99270: LD_INT 5
99272: PPUSH
99273: CALL_OW 12
99277: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99278: LD_ADDR_OWVAR 31
99282: PUSH
99283: LD_INT 1
99285: PPUSH
99286: LD_INT 3
99288: PPUSH
99289: CALL_OW 12
99293: PUSH
99294: LD_INT 1
99296: PPUSH
99297: LD_INT 3
99299: PPUSH
99300: CALL_OW 12
99304: PUSH
99305: LD_INT 0
99307: PUSH
99308: LD_INT 0
99310: PUSH
99311: EMPTY
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: ST_TO_ADDR
// animal := CreateHuman ;
99317: LD_ADDR_VAR 0 12
99321: PUSH
99322: CALL_OW 44
99326: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99327: LD_VAR 0 12
99331: PPUSH
99332: LD_VAR 0 8
99336: PPUSH
99337: LD_INT 0
99339: PPUSH
99340: CALL 105736 0 3
// end ;
99344: GO 99242
99346: POP
99347: POP
// if enchidnas then
99348: LD_VAR 0 4
99352: IFFALSE 99419
// for i = 1 to enchidnas do
99354: LD_ADDR_VAR 0 11
99358: PUSH
99359: DOUBLE
99360: LD_INT 1
99362: DEC
99363: ST_TO_ADDR
99364: LD_VAR 0 4
99368: PUSH
99369: FOR_TO
99370: IFFALSE 99417
// begin hc_class = 13 ;
99372: LD_ADDR_OWVAR 28
99376: PUSH
99377: LD_INT 13
99379: ST_TO_ADDR
// hc_gallery =  ;
99380: LD_ADDR_OWVAR 33
99384: PUSH
99385: LD_STRING 
99387: ST_TO_ADDR
// animal := CreateHuman ;
99388: LD_ADDR_VAR 0 12
99392: PUSH
99393: CALL_OW 44
99397: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99398: LD_VAR 0 12
99402: PPUSH
99403: LD_VAR 0 8
99407: PPUSH
99408: LD_INT 0
99410: PPUSH
99411: CALL 105736 0 3
// end ;
99415: GO 99369
99417: POP
99418: POP
// if fishes then
99419: LD_VAR 0 7
99423: IFFALSE 99490
// for i = 1 to fishes do
99425: LD_ADDR_VAR 0 11
99429: PUSH
99430: DOUBLE
99431: LD_INT 1
99433: DEC
99434: ST_TO_ADDR
99435: LD_VAR 0 7
99439: PUSH
99440: FOR_TO
99441: IFFALSE 99488
// begin hc_class = 20 ;
99443: LD_ADDR_OWVAR 28
99447: PUSH
99448: LD_INT 20
99450: ST_TO_ADDR
// hc_gallery =  ;
99451: LD_ADDR_OWVAR 33
99455: PUSH
99456: LD_STRING 
99458: ST_TO_ADDR
// animal := CreateHuman ;
99459: LD_ADDR_VAR 0 12
99463: PUSH
99464: CALL_OW 44
99468: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99469: LD_VAR 0 12
99473: PPUSH
99474: LD_VAR 0 9
99478: PPUSH
99479: LD_INT 0
99481: PPUSH
99482: CALL 105736 0 3
// end ;
99486: GO 99440
99488: POP
99489: POP
// end ;
99490: LD_VAR 0 10
99494: RET
// export function WantHeal ( sci , unit ) ; begin
99495: LD_INT 0
99497: PPUSH
// if GetTaskList ( sci ) > 0 then
99498: LD_VAR 0 1
99502: PPUSH
99503: CALL_OW 437
99507: PUSH
99508: LD_INT 0
99510: GREATER
99511: IFFALSE 99581
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99513: LD_VAR 0 1
99517: PPUSH
99518: CALL_OW 437
99522: PUSH
99523: LD_INT 1
99525: ARRAY
99526: PUSH
99527: LD_INT 1
99529: ARRAY
99530: PUSH
99531: LD_STRING l
99533: EQUAL
99534: PUSH
99535: LD_VAR 0 1
99539: PPUSH
99540: CALL_OW 437
99544: PUSH
99545: LD_INT 1
99547: ARRAY
99548: PUSH
99549: LD_INT 4
99551: ARRAY
99552: PUSH
99553: LD_VAR 0 2
99557: EQUAL
99558: AND
99559: IFFALSE 99571
// result := true else
99561: LD_ADDR_VAR 0 3
99565: PUSH
99566: LD_INT 1
99568: ST_TO_ADDR
99569: GO 99579
// result := false ;
99571: LD_ADDR_VAR 0 3
99575: PUSH
99576: LD_INT 0
99578: ST_TO_ADDR
// end else
99579: GO 99589
// result := false ;
99581: LD_ADDR_VAR 0 3
99585: PUSH
99586: LD_INT 0
99588: ST_TO_ADDR
// end ;
99589: LD_VAR 0 3
99593: RET
// export function HealTarget ( sci ) ; begin
99594: LD_INT 0
99596: PPUSH
// if not sci then
99597: LD_VAR 0 1
99601: NOT
99602: IFFALSE 99606
// exit ;
99604: GO 99671
// result := 0 ;
99606: LD_ADDR_VAR 0 2
99610: PUSH
99611: LD_INT 0
99613: ST_TO_ADDR
// if GetTaskList ( sci ) then
99614: LD_VAR 0 1
99618: PPUSH
99619: CALL_OW 437
99623: IFFALSE 99671
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99625: LD_VAR 0 1
99629: PPUSH
99630: CALL_OW 437
99634: PUSH
99635: LD_INT 1
99637: ARRAY
99638: PUSH
99639: LD_INT 1
99641: ARRAY
99642: PUSH
99643: LD_STRING l
99645: EQUAL
99646: IFFALSE 99671
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99648: LD_ADDR_VAR 0 2
99652: PUSH
99653: LD_VAR 0 1
99657: PPUSH
99658: CALL_OW 437
99662: PUSH
99663: LD_INT 1
99665: ARRAY
99666: PUSH
99667: LD_INT 4
99669: ARRAY
99670: ST_TO_ADDR
// end ;
99671: LD_VAR 0 2
99675: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99676: LD_INT 0
99678: PPUSH
99679: PPUSH
99680: PPUSH
99681: PPUSH
99682: PPUSH
99683: PPUSH
99684: PPUSH
99685: PPUSH
99686: PPUSH
99687: PPUSH
99688: PPUSH
99689: PPUSH
99690: PPUSH
99691: PPUSH
99692: PPUSH
99693: PPUSH
99694: PPUSH
99695: PPUSH
99696: PPUSH
99697: PPUSH
99698: PPUSH
99699: PPUSH
99700: PPUSH
99701: PPUSH
99702: PPUSH
99703: PPUSH
99704: PPUSH
99705: PPUSH
99706: PPUSH
99707: PPUSH
99708: PPUSH
99709: PPUSH
99710: PPUSH
99711: PPUSH
// if not list then
99712: LD_VAR 0 1
99716: NOT
99717: IFFALSE 99721
// exit ;
99719: GO 104347
// base := list [ 1 ] ;
99721: LD_ADDR_VAR 0 3
99725: PUSH
99726: LD_VAR 0 1
99730: PUSH
99731: LD_INT 1
99733: ARRAY
99734: ST_TO_ADDR
// group := list [ 2 ] ;
99735: LD_ADDR_VAR 0 4
99739: PUSH
99740: LD_VAR 0 1
99744: PUSH
99745: LD_INT 2
99747: ARRAY
99748: ST_TO_ADDR
// path := list [ 3 ] ;
99749: LD_ADDR_VAR 0 5
99753: PUSH
99754: LD_VAR 0 1
99758: PUSH
99759: LD_INT 3
99761: ARRAY
99762: ST_TO_ADDR
// flags := list [ 4 ] ;
99763: LD_ADDR_VAR 0 6
99767: PUSH
99768: LD_VAR 0 1
99772: PUSH
99773: LD_INT 4
99775: ARRAY
99776: ST_TO_ADDR
// mined := [ ] ;
99777: LD_ADDR_VAR 0 27
99781: PUSH
99782: EMPTY
99783: ST_TO_ADDR
// bombed := [ ] ;
99784: LD_ADDR_VAR 0 28
99788: PUSH
99789: EMPTY
99790: ST_TO_ADDR
// healers := [ ] ;
99791: LD_ADDR_VAR 0 31
99795: PUSH
99796: EMPTY
99797: ST_TO_ADDR
// to_heal := [ ] ;
99798: LD_ADDR_VAR 0 30
99802: PUSH
99803: EMPTY
99804: ST_TO_ADDR
// repairs := [ ] ;
99805: LD_ADDR_VAR 0 33
99809: PUSH
99810: EMPTY
99811: ST_TO_ADDR
// to_repair := [ ] ;
99812: LD_ADDR_VAR 0 32
99816: PUSH
99817: EMPTY
99818: ST_TO_ADDR
// if not group or not path then
99819: LD_VAR 0 4
99823: NOT
99824: PUSH
99825: LD_VAR 0 5
99829: NOT
99830: OR
99831: IFFALSE 99835
// exit ;
99833: GO 104347
// side := GetSide ( group [ 1 ] ) ;
99835: LD_ADDR_VAR 0 35
99839: PUSH
99840: LD_VAR 0 4
99844: PUSH
99845: LD_INT 1
99847: ARRAY
99848: PPUSH
99849: CALL_OW 255
99853: ST_TO_ADDR
// if flags then
99854: LD_VAR 0 6
99858: IFFALSE 100002
// begin f_ignore_area := flags [ 1 ] ;
99860: LD_ADDR_VAR 0 17
99864: PUSH
99865: LD_VAR 0 6
99869: PUSH
99870: LD_INT 1
99872: ARRAY
99873: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99874: LD_ADDR_VAR 0 18
99878: PUSH
99879: LD_VAR 0 6
99883: PUSH
99884: LD_INT 2
99886: ARRAY
99887: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99888: LD_ADDR_VAR 0 19
99892: PUSH
99893: LD_VAR 0 6
99897: PUSH
99898: LD_INT 3
99900: ARRAY
99901: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99902: LD_ADDR_VAR 0 20
99906: PUSH
99907: LD_VAR 0 6
99911: PUSH
99912: LD_INT 4
99914: ARRAY
99915: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99916: LD_ADDR_VAR 0 21
99920: PUSH
99921: LD_VAR 0 6
99925: PUSH
99926: LD_INT 5
99928: ARRAY
99929: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99930: LD_ADDR_VAR 0 22
99934: PUSH
99935: LD_VAR 0 6
99939: PUSH
99940: LD_INT 6
99942: ARRAY
99943: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99944: LD_ADDR_VAR 0 23
99948: PUSH
99949: LD_VAR 0 6
99953: PUSH
99954: LD_INT 7
99956: ARRAY
99957: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99958: LD_ADDR_VAR 0 24
99962: PUSH
99963: LD_VAR 0 6
99967: PUSH
99968: LD_INT 8
99970: ARRAY
99971: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99972: LD_ADDR_VAR 0 25
99976: PUSH
99977: LD_VAR 0 6
99981: PUSH
99982: LD_INT 9
99984: ARRAY
99985: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99986: LD_ADDR_VAR 0 26
99990: PUSH
99991: LD_VAR 0 6
99995: PUSH
99996: LD_INT 10
99998: ARRAY
99999: ST_TO_ADDR
// end else
100000: GO 100082
// begin f_ignore_area := false ;
100002: LD_ADDR_VAR 0 17
100006: PUSH
100007: LD_INT 0
100009: ST_TO_ADDR
// f_capture := false ;
100010: LD_ADDR_VAR 0 18
100014: PUSH
100015: LD_INT 0
100017: ST_TO_ADDR
// f_ignore_civ := false ;
100018: LD_ADDR_VAR 0 19
100022: PUSH
100023: LD_INT 0
100025: ST_TO_ADDR
// f_murder := false ;
100026: LD_ADDR_VAR 0 20
100030: PUSH
100031: LD_INT 0
100033: ST_TO_ADDR
// f_mines := false ;
100034: LD_ADDR_VAR 0 21
100038: PUSH
100039: LD_INT 0
100041: ST_TO_ADDR
// f_repair := false ;
100042: LD_ADDR_VAR 0 22
100046: PUSH
100047: LD_INT 0
100049: ST_TO_ADDR
// f_heal := false ;
100050: LD_ADDR_VAR 0 23
100054: PUSH
100055: LD_INT 0
100057: ST_TO_ADDR
// f_spacetime := false ;
100058: LD_ADDR_VAR 0 24
100062: PUSH
100063: LD_INT 0
100065: ST_TO_ADDR
// f_attack_depot := false ;
100066: LD_ADDR_VAR 0 25
100070: PUSH
100071: LD_INT 0
100073: ST_TO_ADDR
// f_crawl := false ;
100074: LD_ADDR_VAR 0 26
100078: PUSH
100079: LD_INT 0
100081: ST_TO_ADDR
// end ; if f_heal then
100082: LD_VAR 0 23
100086: IFFALSE 100113
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100088: LD_ADDR_VAR 0 31
100092: PUSH
100093: LD_VAR 0 4
100097: PPUSH
100098: LD_INT 25
100100: PUSH
100101: LD_INT 4
100103: PUSH
100104: EMPTY
100105: LIST
100106: LIST
100107: PPUSH
100108: CALL_OW 72
100112: ST_TO_ADDR
// if f_repair then
100113: LD_VAR 0 22
100117: IFFALSE 100144
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100119: LD_ADDR_VAR 0 33
100123: PUSH
100124: LD_VAR 0 4
100128: PPUSH
100129: LD_INT 25
100131: PUSH
100132: LD_INT 3
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: PPUSH
100139: CALL_OW 72
100143: ST_TO_ADDR
// units_path := [ ] ;
100144: LD_ADDR_VAR 0 16
100148: PUSH
100149: EMPTY
100150: ST_TO_ADDR
// for i = 1 to group do
100151: LD_ADDR_VAR 0 7
100155: PUSH
100156: DOUBLE
100157: LD_INT 1
100159: DEC
100160: ST_TO_ADDR
100161: LD_VAR 0 4
100165: PUSH
100166: FOR_TO
100167: IFFALSE 100196
// units_path := Replace ( units_path , i , path ) ;
100169: LD_ADDR_VAR 0 16
100173: PUSH
100174: LD_VAR 0 16
100178: PPUSH
100179: LD_VAR 0 7
100183: PPUSH
100184: LD_VAR 0 5
100188: PPUSH
100189: CALL_OW 1
100193: ST_TO_ADDR
100194: GO 100166
100196: POP
100197: POP
// repeat for i = group downto 1 do
100198: LD_ADDR_VAR 0 7
100202: PUSH
100203: DOUBLE
100204: LD_VAR 0 4
100208: INC
100209: ST_TO_ADDR
100210: LD_INT 1
100212: PUSH
100213: FOR_DOWNTO
100214: IFFALSE 104310
// begin wait ( 5 ) ;
100216: LD_INT 5
100218: PPUSH
100219: CALL_OW 67
// tmp := [ ] ;
100223: LD_ADDR_VAR 0 14
100227: PUSH
100228: EMPTY
100229: ST_TO_ADDR
// attacking := false ;
100230: LD_ADDR_VAR 0 29
100234: PUSH
100235: LD_INT 0
100237: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100238: LD_VAR 0 4
100242: PUSH
100243: LD_VAR 0 7
100247: ARRAY
100248: PPUSH
100249: CALL_OW 301
100253: PUSH
100254: LD_VAR 0 4
100258: PUSH
100259: LD_VAR 0 7
100263: ARRAY
100264: NOT
100265: OR
100266: IFFALSE 100375
// begin if GetType ( group [ i ] ) = unit_human then
100268: LD_VAR 0 4
100272: PUSH
100273: LD_VAR 0 7
100277: ARRAY
100278: PPUSH
100279: CALL_OW 247
100283: PUSH
100284: LD_INT 1
100286: EQUAL
100287: IFFALSE 100333
// begin to_heal := to_heal diff group [ i ] ;
100289: LD_ADDR_VAR 0 30
100293: PUSH
100294: LD_VAR 0 30
100298: PUSH
100299: LD_VAR 0 4
100303: PUSH
100304: LD_VAR 0 7
100308: ARRAY
100309: DIFF
100310: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100311: LD_ADDR_VAR 0 31
100315: PUSH
100316: LD_VAR 0 31
100320: PUSH
100321: LD_VAR 0 4
100325: PUSH
100326: LD_VAR 0 7
100330: ARRAY
100331: DIFF
100332: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100333: LD_ADDR_VAR 0 4
100337: PUSH
100338: LD_VAR 0 4
100342: PPUSH
100343: LD_VAR 0 7
100347: PPUSH
100348: CALL_OW 3
100352: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100353: LD_ADDR_VAR 0 16
100357: PUSH
100358: LD_VAR 0 16
100362: PPUSH
100363: LD_VAR 0 7
100367: PPUSH
100368: CALL_OW 3
100372: ST_TO_ADDR
// continue ;
100373: GO 100213
// end ; if f_repair then
100375: LD_VAR 0 22
100379: IFFALSE 100868
// begin if GetType ( group [ i ] ) = unit_vehicle then
100381: LD_VAR 0 4
100385: PUSH
100386: LD_VAR 0 7
100390: ARRAY
100391: PPUSH
100392: CALL_OW 247
100396: PUSH
100397: LD_INT 2
100399: EQUAL
100400: IFFALSE 100590
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100402: LD_VAR 0 4
100406: PUSH
100407: LD_VAR 0 7
100411: ARRAY
100412: PPUSH
100413: CALL_OW 256
100417: PUSH
100418: LD_INT 700
100420: LESS
100421: PUSH
100422: LD_VAR 0 4
100426: PUSH
100427: LD_VAR 0 7
100431: ARRAY
100432: PUSH
100433: LD_VAR 0 32
100437: IN
100438: NOT
100439: AND
100440: IFFALSE 100464
// to_repair := to_repair union group [ i ] ;
100442: LD_ADDR_VAR 0 32
100446: PUSH
100447: LD_VAR 0 32
100451: PUSH
100452: LD_VAR 0 4
100456: PUSH
100457: LD_VAR 0 7
100461: ARRAY
100462: UNION
100463: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100464: LD_VAR 0 4
100468: PUSH
100469: LD_VAR 0 7
100473: ARRAY
100474: PPUSH
100475: CALL_OW 256
100479: PUSH
100480: LD_INT 1000
100482: EQUAL
100483: PUSH
100484: LD_VAR 0 4
100488: PUSH
100489: LD_VAR 0 7
100493: ARRAY
100494: PUSH
100495: LD_VAR 0 32
100499: IN
100500: AND
100501: IFFALSE 100525
// to_repair := to_repair diff group [ i ] ;
100503: LD_ADDR_VAR 0 32
100507: PUSH
100508: LD_VAR 0 32
100512: PUSH
100513: LD_VAR 0 4
100517: PUSH
100518: LD_VAR 0 7
100522: ARRAY
100523: DIFF
100524: ST_TO_ADDR
// if group [ i ] in to_repair then
100525: LD_VAR 0 4
100529: PUSH
100530: LD_VAR 0 7
100534: ARRAY
100535: PUSH
100536: LD_VAR 0 32
100540: IN
100541: IFFALSE 100588
// begin if not IsInArea ( group [ i ] , f_repair ) then
100543: LD_VAR 0 4
100547: PUSH
100548: LD_VAR 0 7
100552: ARRAY
100553: PPUSH
100554: LD_VAR 0 22
100558: PPUSH
100559: CALL_OW 308
100563: NOT
100564: IFFALSE 100586
// ComMoveToArea ( group [ i ] , f_repair ) ;
100566: LD_VAR 0 4
100570: PUSH
100571: LD_VAR 0 7
100575: ARRAY
100576: PPUSH
100577: LD_VAR 0 22
100581: PPUSH
100582: CALL_OW 113
// continue ;
100586: GO 100213
// end ; end else
100588: GO 100868
// if group [ i ] in repairs then
100590: LD_VAR 0 4
100594: PUSH
100595: LD_VAR 0 7
100599: ARRAY
100600: PUSH
100601: LD_VAR 0 33
100605: IN
100606: IFFALSE 100868
// begin if IsInUnit ( group [ i ] ) then
100608: LD_VAR 0 4
100612: PUSH
100613: LD_VAR 0 7
100617: ARRAY
100618: PPUSH
100619: CALL_OW 310
100623: IFFALSE 100691
// begin z := IsInUnit ( group [ i ] ) ;
100625: LD_ADDR_VAR 0 13
100629: PUSH
100630: LD_VAR 0 4
100634: PUSH
100635: LD_VAR 0 7
100639: ARRAY
100640: PPUSH
100641: CALL_OW 310
100645: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100646: LD_VAR 0 13
100650: PUSH
100651: LD_VAR 0 32
100655: IN
100656: PUSH
100657: LD_VAR 0 13
100661: PPUSH
100662: LD_VAR 0 22
100666: PPUSH
100667: CALL_OW 308
100671: AND
100672: IFFALSE 100689
// ComExitVehicle ( group [ i ] ) ;
100674: LD_VAR 0 4
100678: PUSH
100679: LD_VAR 0 7
100683: ARRAY
100684: PPUSH
100685: CALL_OW 121
// end else
100689: GO 100868
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100691: LD_ADDR_VAR 0 13
100695: PUSH
100696: LD_VAR 0 4
100700: PPUSH
100701: LD_INT 95
100703: PUSH
100704: LD_VAR 0 22
100708: PUSH
100709: EMPTY
100710: LIST
100711: LIST
100712: PUSH
100713: LD_INT 58
100715: PUSH
100716: EMPTY
100717: LIST
100718: PUSH
100719: EMPTY
100720: LIST
100721: LIST
100722: PPUSH
100723: CALL_OW 72
100727: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100728: LD_VAR 0 4
100732: PUSH
100733: LD_VAR 0 7
100737: ARRAY
100738: PPUSH
100739: CALL_OW 314
100743: NOT
100744: IFFALSE 100866
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100746: LD_ADDR_VAR 0 10
100750: PUSH
100751: LD_VAR 0 13
100755: PPUSH
100756: LD_VAR 0 4
100760: PUSH
100761: LD_VAR 0 7
100765: ARRAY
100766: PPUSH
100767: CALL_OW 74
100771: ST_TO_ADDR
// if not x then
100772: LD_VAR 0 10
100776: NOT
100777: IFFALSE 100781
// continue ;
100779: GO 100213
// if GetLives ( x ) < 1000 then
100781: LD_VAR 0 10
100785: PPUSH
100786: CALL_OW 256
100790: PUSH
100791: LD_INT 1000
100793: LESS
100794: IFFALSE 100818
// ComRepairVehicle ( group [ i ] , x ) else
100796: LD_VAR 0 4
100800: PUSH
100801: LD_VAR 0 7
100805: ARRAY
100806: PPUSH
100807: LD_VAR 0 10
100811: PPUSH
100812: CALL_OW 129
100816: GO 100866
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100818: LD_VAR 0 23
100822: PUSH
100823: LD_VAR 0 4
100827: PUSH
100828: LD_VAR 0 7
100832: ARRAY
100833: PPUSH
100834: CALL_OW 256
100838: PUSH
100839: LD_INT 1000
100841: LESS
100842: AND
100843: NOT
100844: IFFALSE 100866
// ComEnterUnit ( group [ i ] , x ) ;
100846: LD_VAR 0 4
100850: PUSH
100851: LD_VAR 0 7
100855: ARRAY
100856: PPUSH
100857: LD_VAR 0 10
100861: PPUSH
100862: CALL_OW 120
// end ; continue ;
100866: GO 100213
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100868: LD_VAR 0 23
100872: PUSH
100873: LD_VAR 0 4
100877: PUSH
100878: LD_VAR 0 7
100882: ARRAY
100883: PPUSH
100884: CALL_OW 247
100888: PUSH
100889: LD_INT 1
100891: EQUAL
100892: AND
100893: IFFALSE 101371
// begin if group [ i ] in healers then
100895: LD_VAR 0 4
100899: PUSH
100900: LD_VAR 0 7
100904: ARRAY
100905: PUSH
100906: LD_VAR 0 31
100910: IN
100911: IFFALSE 101184
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100913: LD_VAR 0 4
100917: PUSH
100918: LD_VAR 0 7
100922: ARRAY
100923: PPUSH
100924: LD_VAR 0 23
100928: PPUSH
100929: CALL_OW 308
100933: NOT
100934: PUSH
100935: LD_VAR 0 4
100939: PUSH
100940: LD_VAR 0 7
100944: ARRAY
100945: PPUSH
100946: CALL_OW 314
100950: NOT
100951: AND
100952: IFFALSE 100976
// ComMoveToArea ( group [ i ] , f_heal ) else
100954: LD_VAR 0 4
100958: PUSH
100959: LD_VAR 0 7
100963: ARRAY
100964: PPUSH
100965: LD_VAR 0 23
100969: PPUSH
100970: CALL_OW 113
100974: GO 101182
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100976: LD_VAR 0 4
100980: PUSH
100981: LD_VAR 0 7
100985: ARRAY
100986: PPUSH
100987: CALL 99594 0 1
100991: PPUSH
100992: CALL_OW 256
100996: PUSH
100997: LD_INT 1000
100999: EQUAL
101000: IFFALSE 101019
// ComStop ( group [ i ] ) else
101002: LD_VAR 0 4
101006: PUSH
101007: LD_VAR 0 7
101011: ARRAY
101012: PPUSH
101013: CALL_OW 141
101017: GO 101182
// if not HasTask ( group [ i ] ) and to_heal then
101019: LD_VAR 0 4
101023: PUSH
101024: LD_VAR 0 7
101028: ARRAY
101029: PPUSH
101030: CALL_OW 314
101034: NOT
101035: PUSH
101036: LD_VAR 0 30
101040: AND
101041: IFFALSE 101182
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101043: LD_ADDR_VAR 0 13
101047: PUSH
101048: LD_VAR 0 30
101052: PPUSH
101053: LD_INT 3
101055: PUSH
101056: LD_INT 54
101058: PUSH
101059: EMPTY
101060: LIST
101061: PUSH
101062: EMPTY
101063: LIST
101064: LIST
101065: PPUSH
101066: CALL_OW 72
101070: PPUSH
101071: LD_VAR 0 4
101075: PUSH
101076: LD_VAR 0 7
101080: ARRAY
101081: PPUSH
101082: CALL_OW 74
101086: ST_TO_ADDR
// if z then
101087: LD_VAR 0 13
101091: IFFALSE 101182
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101093: LD_INT 91
101095: PUSH
101096: LD_VAR 0 13
101100: PUSH
101101: LD_INT 10
101103: PUSH
101104: EMPTY
101105: LIST
101106: LIST
101107: LIST
101108: PUSH
101109: LD_INT 81
101111: PUSH
101112: LD_VAR 0 13
101116: PPUSH
101117: CALL_OW 255
101121: PUSH
101122: EMPTY
101123: LIST
101124: LIST
101125: PUSH
101126: EMPTY
101127: LIST
101128: LIST
101129: PPUSH
101130: CALL_OW 69
101134: PUSH
101135: LD_INT 0
101137: EQUAL
101138: IFFALSE 101162
// ComHeal ( group [ i ] , z ) else
101140: LD_VAR 0 4
101144: PUSH
101145: LD_VAR 0 7
101149: ARRAY
101150: PPUSH
101151: LD_VAR 0 13
101155: PPUSH
101156: CALL_OW 128
101160: GO 101182
// ComMoveToArea ( group [ i ] , f_heal ) ;
101162: LD_VAR 0 4
101166: PUSH
101167: LD_VAR 0 7
101171: ARRAY
101172: PPUSH
101173: LD_VAR 0 23
101177: PPUSH
101178: CALL_OW 113
// end ; continue ;
101182: GO 100213
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101184: LD_VAR 0 4
101188: PUSH
101189: LD_VAR 0 7
101193: ARRAY
101194: PPUSH
101195: CALL_OW 256
101199: PUSH
101200: LD_INT 700
101202: LESS
101203: PUSH
101204: LD_VAR 0 4
101208: PUSH
101209: LD_VAR 0 7
101213: ARRAY
101214: PUSH
101215: LD_VAR 0 30
101219: IN
101220: NOT
101221: AND
101222: IFFALSE 101246
// to_heal := to_heal union group [ i ] ;
101224: LD_ADDR_VAR 0 30
101228: PUSH
101229: LD_VAR 0 30
101233: PUSH
101234: LD_VAR 0 4
101238: PUSH
101239: LD_VAR 0 7
101243: ARRAY
101244: UNION
101245: ST_TO_ADDR
// if group [ i ] in to_heal then
101246: LD_VAR 0 4
101250: PUSH
101251: LD_VAR 0 7
101255: ARRAY
101256: PUSH
101257: LD_VAR 0 30
101261: IN
101262: IFFALSE 101371
// begin if GetLives ( group [ i ] ) = 1000 then
101264: LD_VAR 0 4
101268: PUSH
101269: LD_VAR 0 7
101273: ARRAY
101274: PPUSH
101275: CALL_OW 256
101279: PUSH
101280: LD_INT 1000
101282: EQUAL
101283: IFFALSE 101309
// to_heal := to_heal diff group [ i ] else
101285: LD_ADDR_VAR 0 30
101289: PUSH
101290: LD_VAR 0 30
101294: PUSH
101295: LD_VAR 0 4
101299: PUSH
101300: LD_VAR 0 7
101304: ARRAY
101305: DIFF
101306: ST_TO_ADDR
101307: GO 101371
// begin if not IsInArea ( group [ i ] , to_heal ) then
101309: LD_VAR 0 4
101313: PUSH
101314: LD_VAR 0 7
101318: ARRAY
101319: PPUSH
101320: LD_VAR 0 30
101324: PPUSH
101325: CALL_OW 308
101329: NOT
101330: IFFALSE 101354
// ComMoveToArea ( group [ i ] , f_heal ) else
101332: LD_VAR 0 4
101336: PUSH
101337: LD_VAR 0 7
101341: ARRAY
101342: PPUSH
101343: LD_VAR 0 23
101347: PPUSH
101348: CALL_OW 113
101352: GO 101369
// ComHold ( group [ i ] ) ;
101354: LD_VAR 0 4
101358: PUSH
101359: LD_VAR 0 7
101363: ARRAY
101364: PPUSH
101365: CALL_OW 140
// continue ;
101369: GO 100213
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101371: LD_VAR 0 4
101375: PUSH
101376: LD_VAR 0 7
101380: ARRAY
101381: PPUSH
101382: LD_INT 10
101384: PPUSH
101385: CALL 97991 0 2
101389: NOT
101390: PUSH
101391: LD_VAR 0 16
101395: PUSH
101396: LD_VAR 0 7
101400: ARRAY
101401: PUSH
101402: EMPTY
101403: EQUAL
101404: NOT
101405: AND
101406: IFFALSE 101672
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101408: LD_VAR 0 4
101412: PUSH
101413: LD_VAR 0 7
101417: ARRAY
101418: PPUSH
101419: CALL_OW 262
101423: PUSH
101424: LD_INT 1
101426: PUSH
101427: LD_INT 2
101429: PUSH
101430: EMPTY
101431: LIST
101432: LIST
101433: IN
101434: IFFALSE 101475
// if GetFuel ( group [ i ] ) < 10 then
101436: LD_VAR 0 4
101440: PUSH
101441: LD_VAR 0 7
101445: ARRAY
101446: PPUSH
101447: CALL_OW 261
101451: PUSH
101452: LD_INT 10
101454: LESS
101455: IFFALSE 101475
// SetFuel ( group [ i ] , 12 ) ;
101457: LD_VAR 0 4
101461: PUSH
101462: LD_VAR 0 7
101466: ARRAY
101467: PPUSH
101468: LD_INT 12
101470: PPUSH
101471: CALL_OW 240
// if units_path [ i ] then
101475: LD_VAR 0 16
101479: PUSH
101480: LD_VAR 0 7
101484: ARRAY
101485: IFFALSE 101670
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101487: LD_VAR 0 4
101491: PUSH
101492: LD_VAR 0 7
101496: ARRAY
101497: PPUSH
101498: LD_VAR 0 16
101502: PUSH
101503: LD_VAR 0 7
101507: ARRAY
101508: PUSH
101509: LD_INT 1
101511: ARRAY
101512: PUSH
101513: LD_INT 1
101515: ARRAY
101516: PPUSH
101517: LD_VAR 0 16
101521: PUSH
101522: LD_VAR 0 7
101526: ARRAY
101527: PUSH
101528: LD_INT 1
101530: ARRAY
101531: PUSH
101532: LD_INT 2
101534: ARRAY
101535: PPUSH
101536: CALL_OW 297
101540: PUSH
101541: LD_INT 6
101543: GREATER
101544: IFFALSE 101619
// begin if not HasTask ( group [ i ] ) then
101546: LD_VAR 0 4
101550: PUSH
101551: LD_VAR 0 7
101555: ARRAY
101556: PPUSH
101557: CALL_OW 314
101561: NOT
101562: IFFALSE 101617
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101564: LD_VAR 0 4
101568: PUSH
101569: LD_VAR 0 7
101573: ARRAY
101574: PPUSH
101575: LD_VAR 0 16
101579: PUSH
101580: LD_VAR 0 7
101584: ARRAY
101585: PUSH
101586: LD_INT 1
101588: ARRAY
101589: PUSH
101590: LD_INT 1
101592: ARRAY
101593: PPUSH
101594: LD_VAR 0 16
101598: PUSH
101599: LD_VAR 0 7
101603: ARRAY
101604: PUSH
101605: LD_INT 1
101607: ARRAY
101608: PUSH
101609: LD_INT 2
101611: ARRAY
101612: PPUSH
101613: CALL_OW 114
// end else
101617: GO 101670
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101619: LD_ADDR_VAR 0 15
101623: PUSH
101624: LD_VAR 0 16
101628: PUSH
101629: LD_VAR 0 7
101633: ARRAY
101634: PPUSH
101635: LD_INT 1
101637: PPUSH
101638: CALL_OW 3
101642: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101643: LD_ADDR_VAR 0 16
101647: PUSH
101648: LD_VAR 0 16
101652: PPUSH
101653: LD_VAR 0 7
101657: PPUSH
101658: LD_VAR 0 15
101662: PPUSH
101663: CALL_OW 1
101667: ST_TO_ADDR
// continue ;
101668: GO 100213
// end ; end ; end else
101670: GO 104308
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101672: LD_ADDR_VAR 0 14
101676: PUSH
101677: LD_INT 81
101679: PUSH
101680: LD_VAR 0 4
101684: PUSH
101685: LD_VAR 0 7
101689: ARRAY
101690: PPUSH
101691: CALL_OW 255
101695: PUSH
101696: EMPTY
101697: LIST
101698: LIST
101699: PPUSH
101700: CALL_OW 69
101704: ST_TO_ADDR
// if not tmp then
101705: LD_VAR 0 14
101709: NOT
101710: IFFALSE 101714
// continue ;
101712: GO 100213
// if f_ignore_area then
101714: LD_VAR 0 17
101718: IFFALSE 101806
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101720: LD_ADDR_VAR 0 15
101724: PUSH
101725: LD_VAR 0 14
101729: PPUSH
101730: LD_INT 3
101732: PUSH
101733: LD_INT 92
101735: PUSH
101736: LD_VAR 0 17
101740: PUSH
101741: LD_INT 1
101743: ARRAY
101744: PUSH
101745: LD_VAR 0 17
101749: PUSH
101750: LD_INT 2
101752: ARRAY
101753: PUSH
101754: LD_VAR 0 17
101758: PUSH
101759: LD_INT 3
101761: ARRAY
101762: PUSH
101763: EMPTY
101764: LIST
101765: LIST
101766: LIST
101767: LIST
101768: PUSH
101769: EMPTY
101770: LIST
101771: LIST
101772: PPUSH
101773: CALL_OW 72
101777: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101778: LD_VAR 0 14
101782: PUSH
101783: LD_VAR 0 15
101787: DIFF
101788: IFFALSE 101806
// tmp := tmp diff tmp2 ;
101790: LD_ADDR_VAR 0 14
101794: PUSH
101795: LD_VAR 0 14
101799: PUSH
101800: LD_VAR 0 15
101804: DIFF
101805: ST_TO_ADDR
// end ; if not f_murder then
101806: LD_VAR 0 20
101810: NOT
101811: IFFALSE 101869
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101813: LD_ADDR_VAR 0 15
101817: PUSH
101818: LD_VAR 0 14
101822: PPUSH
101823: LD_INT 3
101825: PUSH
101826: LD_INT 50
101828: PUSH
101829: EMPTY
101830: LIST
101831: PUSH
101832: EMPTY
101833: LIST
101834: LIST
101835: PPUSH
101836: CALL_OW 72
101840: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101841: LD_VAR 0 14
101845: PUSH
101846: LD_VAR 0 15
101850: DIFF
101851: IFFALSE 101869
// tmp := tmp diff tmp2 ;
101853: LD_ADDR_VAR 0 14
101857: PUSH
101858: LD_VAR 0 14
101862: PUSH
101863: LD_VAR 0 15
101867: DIFF
101868: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101869: LD_ADDR_VAR 0 14
101873: PUSH
101874: LD_VAR 0 4
101878: PUSH
101879: LD_VAR 0 7
101883: ARRAY
101884: PPUSH
101885: LD_VAR 0 14
101889: PPUSH
101890: LD_INT 1
101892: PPUSH
101893: LD_INT 1
101895: PPUSH
101896: CALL 71634 0 4
101900: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101901: LD_VAR 0 4
101905: PUSH
101906: LD_VAR 0 7
101910: ARRAY
101911: PPUSH
101912: CALL_OW 257
101916: PUSH
101917: LD_INT 1
101919: EQUAL
101920: IFFALSE 102368
// begin if WantPlant ( group [ i ] ) then
101922: LD_VAR 0 4
101926: PUSH
101927: LD_VAR 0 7
101931: ARRAY
101932: PPUSH
101933: CALL 71135 0 1
101937: IFFALSE 101941
// continue ;
101939: GO 100213
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101941: LD_VAR 0 18
101945: PUSH
101946: LD_VAR 0 4
101950: PUSH
101951: LD_VAR 0 7
101955: ARRAY
101956: PPUSH
101957: CALL_OW 310
101961: NOT
101962: AND
101963: PUSH
101964: LD_VAR 0 14
101968: PUSH
101969: LD_INT 1
101971: ARRAY
101972: PUSH
101973: LD_VAR 0 14
101977: PPUSH
101978: LD_INT 21
101980: PUSH
101981: LD_INT 2
101983: PUSH
101984: EMPTY
101985: LIST
101986: LIST
101987: PUSH
101988: LD_INT 58
101990: PUSH
101991: EMPTY
101992: LIST
101993: PUSH
101994: EMPTY
101995: LIST
101996: LIST
101997: PPUSH
101998: CALL_OW 72
102002: IN
102003: AND
102004: IFFALSE 102040
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102006: LD_VAR 0 4
102010: PUSH
102011: LD_VAR 0 7
102015: ARRAY
102016: PPUSH
102017: LD_VAR 0 14
102021: PUSH
102022: LD_INT 1
102024: ARRAY
102025: PPUSH
102026: CALL_OW 120
// attacking := true ;
102030: LD_ADDR_VAR 0 29
102034: PUSH
102035: LD_INT 1
102037: ST_TO_ADDR
// continue ;
102038: GO 100213
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102040: LD_VAR 0 26
102044: PUSH
102045: LD_VAR 0 4
102049: PUSH
102050: LD_VAR 0 7
102054: ARRAY
102055: PPUSH
102056: CALL_OW 257
102060: PUSH
102061: LD_INT 1
102063: EQUAL
102064: AND
102065: PUSH
102066: LD_VAR 0 4
102070: PUSH
102071: LD_VAR 0 7
102075: ARRAY
102076: PPUSH
102077: CALL_OW 256
102081: PUSH
102082: LD_INT 800
102084: LESS
102085: AND
102086: PUSH
102087: LD_VAR 0 4
102091: PUSH
102092: LD_VAR 0 7
102096: ARRAY
102097: PPUSH
102098: CALL_OW 318
102102: NOT
102103: AND
102104: IFFALSE 102121
// ComCrawl ( group [ i ] ) ;
102106: LD_VAR 0 4
102110: PUSH
102111: LD_VAR 0 7
102115: ARRAY
102116: PPUSH
102117: CALL_OW 137
// if f_mines then
102121: LD_VAR 0 21
102125: IFFALSE 102368
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102127: LD_VAR 0 14
102131: PUSH
102132: LD_INT 1
102134: ARRAY
102135: PPUSH
102136: CALL_OW 247
102140: PUSH
102141: LD_INT 3
102143: EQUAL
102144: PUSH
102145: LD_VAR 0 14
102149: PUSH
102150: LD_INT 1
102152: ARRAY
102153: PUSH
102154: LD_VAR 0 27
102158: IN
102159: NOT
102160: AND
102161: IFFALSE 102368
// begin x := GetX ( tmp [ 1 ] ) ;
102163: LD_ADDR_VAR 0 10
102167: PUSH
102168: LD_VAR 0 14
102172: PUSH
102173: LD_INT 1
102175: ARRAY
102176: PPUSH
102177: CALL_OW 250
102181: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102182: LD_ADDR_VAR 0 11
102186: PUSH
102187: LD_VAR 0 14
102191: PUSH
102192: LD_INT 1
102194: ARRAY
102195: PPUSH
102196: CALL_OW 251
102200: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102201: LD_ADDR_VAR 0 12
102205: PUSH
102206: LD_VAR 0 4
102210: PUSH
102211: LD_VAR 0 7
102215: ARRAY
102216: PPUSH
102217: CALL 98076 0 1
102221: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102222: LD_VAR 0 4
102226: PUSH
102227: LD_VAR 0 7
102231: ARRAY
102232: PPUSH
102233: LD_VAR 0 10
102237: PPUSH
102238: LD_VAR 0 11
102242: PPUSH
102243: LD_VAR 0 14
102247: PUSH
102248: LD_INT 1
102250: ARRAY
102251: PPUSH
102252: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102256: LD_VAR 0 4
102260: PUSH
102261: LD_VAR 0 7
102265: ARRAY
102266: PPUSH
102267: LD_VAR 0 10
102271: PPUSH
102272: LD_VAR 0 12
102276: PPUSH
102277: LD_INT 7
102279: PPUSH
102280: CALL_OW 272
102284: PPUSH
102285: LD_VAR 0 11
102289: PPUSH
102290: LD_VAR 0 12
102294: PPUSH
102295: LD_INT 7
102297: PPUSH
102298: CALL_OW 273
102302: PPUSH
102303: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102307: LD_VAR 0 4
102311: PUSH
102312: LD_VAR 0 7
102316: ARRAY
102317: PPUSH
102318: LD_INT 71
102320: PPUSH
102321: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102325: LD_ADDR_VAR 0 27
102329: PUSH
102330: LD_VAR 0 27
102334: PPUSH
102335: LD_VAR 0 27
102339: PUSH
102340: LD_INT 1
102342: PLUS
102343: PPUSH
102344: LD_VAR 0 14
102348: PUSH
102349: LD_INT 1
102351: ARRAY
102352: PPUSH
102353: CALL_OW 1
102357: ST_TO_ADDR
// attacking := true ;
102358: LD_ADDR_VAR 0 29
102362: PUSH
102363: LD_INT 1
102365: ST_TO_ADDR
// continue ;
102366: GO 100213
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102368: LD_VAR 0 4
102372: PUSH
102373: LD_VAR 0 7
102377: ARRAY
102378: PPUSH
102379: CALL_OW 257
102383: PUSH
102384: LD_INT 17
102386: EQUAL
102387: PUSH
102388: LD_VAR 0 4
102392: PUSH
102393: LD_VAR 0 7
102397: ARRAY
102398: PPUSH
102399: CALL_OW 110
102403: PUSH
102404: LD_INT 71
102406: EQUAL
102407: NOT
102408: AND
102409: IFFALSE 102555
// begin attacking := false ;
102411: LD_ADDR_VAR 0 29
102415: PUSH
102416: LD_INT 0
102418: ST_TO_ADDR
// k := 5 ;
102419: LD_ADDR_VAR 0 9
102423: PUSH
102424: LD_INT 5
102426: ST_TO_ADDR
// if tmp < k then
102427: LD_VAR 0 14
102431: PUSH
102432: LD_VAR 0 9
102436: LESS
102437: IFFALSE 102449
// k := tmp ;
102439: LD_ADDR_VAR 0 9
102443: PUSH
102444: LD_VAR 0 14
102448: ST_TO_ADDR
// for j = 1 to k do
102449: LD_ADDR_VAR 0 8
102453: PUSH
102454: DOUBLE
102455: LD_INT 1
102457: DEC
102458: ST_TO_ADDR
102459: LD_VAR 0 9
102463: PUSH
102464: FOR_TO
102465: IFFALSE 102553
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102467: LD_VAR 0 14
102471: PUSH
102472: LD_VAR 0 8
102476: ARRAY
102477: PUSH
102478: LD_VAR 0 14
102482: PPUSH
102483: LD_INT 58
102485: PUSH
102486: EMPTY
102487: LIST
102488: PPUSH
102489: CALL_OW 72
102493: IN
102494: NOT
102495: IFFALSE 102551
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102497: LD_VAR 0 4
102501: PUSH
102502: LD_VAR 0 7
102506: ARRAY
102507: PPUSH
102508: LD_VAR 0 14
102512: PUSH
102513: LD_VAR 0 8
102517: ARRAY
102518: PPUSH
102519: CALL_OW 115
// attacking := true ;
102523: LD_ADDR_VAR 0 29
102527: PUSH
102528: LD_INT 1
102530: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102531: LD_VAR 0 4
102535: PUSH
102536: LD_VAR 0 7
102540: ARRAY
102541: PPUSH
102542: LD_INT 71
102544: PPUSH
102545: CALL_OW 109
// continue ;
102549: GO 102464
// end ; end ;
102551: GO 102464
102553: POP
102554: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102555: LD_VAR 0 4
102559: PUSH
102560: LD_VAR 0 7
102564: ARRAY
102565: PPUSH
102566: CALL_OW 257
102570: PUSH
102571: LD_INT 8
102573: EQUAL
102574: PUSH
102575: LD_VAR 0 4
102579: PUSH
102580: LD_VAR 0 7
102584: ARRAY
102585: PPUSH
102586: CALL_OW 264
102590: PUSH
102591: LD_INT 28
102593: PUSH
102594: LD_INT 45
102596: PUSH
102597: LD_INT 7
102599: PUSH
102600: LD_INT 47
102602: PUSH
102603: EMPTY
102604: LIST
102605: LIST
102606: LIST
102607: LIST
102608: IN
102609: OR
102610: IFFALSE 102840
// begin attacking := false ;
102612: LD_ADDR_VAR 0 29
102616: PUSH
102617: LD_INT 0
102619: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102620: LD_VAR 0 14
102624: PUSH
102625: LD_INT 1
102627: ARRAY
102628: PPUSH
102629: CALL_OW 266
102633: PUSH
102634: LD_INT 32
102636: PUSH
102637: LD_INT 31
102639: PUSH
102640: LD_INT 33
102642: PUSH
102643: LD_INT 4
102645: PUSH
102646: LD_INT 5
102648: PUSH
102649: EMPTY
102650: LIST
102651: LIST
102652: LIST
102653: LIST
102654: LIST
102655: IN
102656: IFFALSE 102840
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102658: LD_ADDR_VAR 0 9
102662: PUSH
102663: LD_VAR 0 14
102667: PUSH
102668: LD_INT 1
102670: ARRAY
102671: PPUSH
102672: CALL_OW 266
102676: PPUSH
102677: LD_VAR 0 14
102681: PUSH
102682: LD_INT 1
102684: ARRAY
102685: PPUSH
102686: CALL_OW 250
102690: PPUSH
102691: LD_VAR 0 14
102695: PUSH
102696: LD_INT 1
102698: ARRAY
102699: PPUSH
102700: CALL_OW 251
102704: PPUSH
102705: LD_VAR 0 14
102709: PUSH
102710: LD_INT 1
102712: ARRAY
102713: PPUSH
102714: CALL_OW 254
102718: PPUSH
102719: LD_VAR 0 14
102723: PUSH
102724: LD_INT 1
102726: ARRAY
102727: PPUSH
102728: CALL_OW 248
102732: PPUSH
102733: LD_INT 0
102735: PPUSH
102736: CALL 79446 0 6
102740: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102741: LD_ADDR_VAR 0 8
102745: PUSH
102746: LD_VAR 0 4
102750: PUSH
102751: LD_VAR 0 7
102755: ARRAY
102756: PPUSH
102757: LD_VAR 0 9
102761: PPUSH
102762: CALL 98139 0 2
102766: ST_TO_ADDR
// if j then
102767: LD_VAR 0 8
102771: IFFALSE 102840
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102773: LD_VAR 0 8
102777: PUSH
102778: LD_INT 1
102780: ARRAY
102781: PPUSH
102782: LD_VAR 0 8
102786: PUSH
102787: LD_INT 2
102789: ARRAY
102790: PPUSH
102791: CALL_OW 488
102795: IFFALSE 102840
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102797: LD_VAR 0 4
102801: PUSH
102802: LD_VAR 0 7
102806: ARRAY
102807: PPUSH
102808: LD_VAR 0 8
102812: PUSH
102813: LD_INT 1
102815: ARRAY
102816: PPUSH
102817: LD_VAR 0 8
102821: PUSH
102822: LD_INT 2
102824: ARRAY
102825: PPUSH
102826: CALL_OW 116
// attacking := true ;
102830: LD_ADDR_VAR 0 29
102834: PUSH
102835: LD_INT 1
102837: ST_TO_ADDR
// continue ;
102838: GO 100213
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102840: LD_VAR 0 4
102844: PUSH
102845: LD_VAR 0 7
102849: ARRAY
102850: PPUSH
102851: CALL_OW 265
102855: PUSH
102856: LD_INT 11
102858: EQUAL
102859: IFFALSE 103137
// begin k := 10 ;
102861: LD_ADDR_VAR 0 9
102865: PUSH
102866: LD_INT 10
102868: ST_TO_ADDR
// x := 0 ;
102869: LD_ADDR_VAR 0 10
102873: PUSH
102874: LD_INT 0
102876: ST_TO_ADDR
// if tmp < k then
102877: LD_VAR 0 14
102881: PUSH
102882: LD_VAR 0 9
102886: LESS
102887: IFFALSE 102899
// k := tmp ;
102889: LD_ADDR_VAR 0 9
102893: PUSH
102894: LD_VAR 0 14
102898: ST_TO_ADDR
// for j = k downto 1 do
102899: LD_ADDR_VAR 0 8
102903: PUSH
102904: DOUBLE
102905: LD_VAR 0 9
102909: INC
102910: ST_TO_ADDR
102911: LD_INT 1
102913: PUSH
102914: FOR_DOWNTO
102915: IFFALSE 102990
// begin if GetType ( tmp [ j ] ) = unit_human then
102917: LD_VAR 0 14
102921: PUSH
102922: LD_VAR 0 8
102926: ARRAY
102927: PPUSH
102928: CALL_OW 247
102932: PUSH
102933: LD_INT 1
102935: EQUAL
102936: IFFALSE 102988
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102938: LD_VAR 0 4
102942: PUSH
102943: LD_VAR 0 7
102947: ARRAY
102948: PPUSH
102949: LD_VAR 0 14
102953: PUSH
102954: LD_VAR 0 8
102958: ARRAY
102959: PPUSH
102960: CALL 98410 0 2
// x := tmp [ j ] ;
102964: LD_ADDR_VAR 0 10
102968: PUSH
102969: LD_VAR 0 14
102973: PUSH
102974: LD_VAR 0 8
102978: ARRAY
102979: ST_TO_ADDR
// attacking := true ;
102980: LD_ADDR_VAR 0 29
102984: PUSH
102985: LD_INT 1
102987: ST_TO_ADDR
// end ; end ;
102988: GO 102914
102990: POP
102991: POP
// if not x then
102992: LD_VAR 0 10
102996: NOT
102997: IFFALSE 103137
// begin attacking := true ;
102999: LD_ADDR_VAR 0 29
103003: PUSH
103004: LD_INT 1
103006: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103007: LD_VAR 0 4
103011: PUSH
103012: LD_VAR 0 7
103016: ARRAY
103017: PPUSH
103018: CALL_OW 250
103022: PPUSH
103023: LD_VAR 0 4
103027: PUSH
103028: LD_VAR 0 7
103032: ARRAY
103033: PPUSH
103034: CALL_OW 251
103038: PPUSH
103039: CALL_OW 546
103043: PUSH
103044: LD_INT 2
103046: ARRAY
103047: PUSH
103048: LD_VAR 0 14
103052: PUSH
103053: LD_INT 1
103055: ARRAY
103056: PPUSH
103057: CALL_OW 250
103061: PPUSH
103062: LD_VAR 0 14
103066: PUSH
103067: LD_INT 1
103069: ARRAY
103070: PPUSH
103071: CALL_OW 251
103075: PPUSH
103076: CALL_OW 546
103080: PUSH
103081: LD_INT 2
103083: ARRAY
103084: EQUAL
103085: IFFALSE 103113
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103087: LD_VAR 0 4
103091: PUSH
103092: LD_VAR 0 7
103096: ARRAY
103097: PPUSH
103098: LD_VAR 0 14
103102: PUSH
103103: LD_INT 1
103105: ARRAY
103106: PPUSH
103107: CALL 98410 0 2
103111: GO 103137
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103113: LD_VAR 0 4
103117: PUSH
103118: LD_VAR 0 7
103122: ARRAY
103123: PPUSH
103124: LD_VAR 0 14
103128: PUSH
103129: LD_INT 1
103131: ARRAY
103132: PPUSH
103133: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103137: LD_VAR 0 4
103141: PUSH
103142: LD_VAR 0 7
103146: ARRAY
103147: PPUSH
103148: CALL_OW 264
103152: PUSH
103153: LD_INT 29
103155: EQUAL
103156: IFFALSE 103522
// begin if WantsToAttack ( group [ i ] ) in bombed then
103158: LD_VAR 0 4
103162: PUSH
103163: LD_VAR 0 7
103167: ARRAY
103168: PPUSH
103169: CALL_OW 319
103173: PUSH
103174: LD_VAR 0 28
103178: IN
103179: IFFALSE 103183
// continue ;
103181: GO 100213
// k := 8 ;
103183: LD_ADDR_VAR 0 9
103187: PUSH
103188: LD_INT 8
103190: ST_TO_ADDR
// x := 0 ;
103191: LD_ADDR_VAR 0 10
103195: PUSH
103196: LD_INT 0
103198: ST_TO_ADDR
// if tmp < k then
103199: LD_VAR 0 14
103203: PUSH
103204: LD_VAR 0 9
103208: LESS
103209: IFFALSE 103221
// k := tmp ;
103211: LD_ADDR_VAR 0 9
103215: PUSH
103216: LD_VAR 0 14
103220: ST_TO_ADDR
// for j = 1 to k do
103221: LD_ADDR_VAR 0 8
103225: PUSH
103226: DOUBLE
103227: LD_INT 1
103229: DEC
103230: ST_TO_ADDR
103231: LD_VAR 0 9
103235: PUSH
103236: FOR_TO
103237: IFFALSE 103369
// begin if GetType ( tmp [ j ] ) = unit_building then
103239: LD_VAR 0 14
103243: PUSH
103244: LD_VAR 0 8
103248: ARRAY
103249: PPUSH
103250: CALL_OW 247
103254: PUSH
103255: LD_INT 3
103257: EQUAL
103258: IFFALSE 103367
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103260: LD_VAR 0 14
103264: PUSH
103265: LD_VAR 0 8
103269: ARRAY
103270: PUSH
103271: LD_VAR 0 28
103275: IN
103276: NOT
103277: PUSH
103278: LD_VAR 0 14
103282: PUSH
103283: LD_VAR 0 8
103287: ARRAY
103288: PPUSH
103289: CALL_OW 313
103293: AND
103294: IFFALSE 103367
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103296: LD_VAR 0 4
103300: PUSH
103301: LD_VAR 0 7
103305: ARRAY
103306: PPUSH
103307: LD_VAR 0 14
103311: PUSH
103312: LD_VAR 0 8
103316: ARRAY
103317: PPUSH
103318: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103322: LD_ADDR_VAR 0 28
103326: PUSH
103327: LD_VAR 0 28
103331: PPUSH
103332: LD_VAR 0 28
103336: PUSH
103337: LD_INT 1
103339: PLUS
103340: PPUSH
103341: LD_VAR 0 14
103345: PUSH
103346: LD_VAR 0 8
103350: ARRAY
103351: PPUSH
103352: CALL_OW 1
103356: ST_TO_ADDR
// attacking := true ;
103357: LD_ADDR_VAR 0 29
103361: PUSH
103362: LD_INT 1
103364: ST_TO_ADDR
// break ;
103365: GO 103369
// end ; end ;
103367: GO 103236
103369: POP
103370: POP
// if not attacking and f_attack_depot then
103371: LD_VAR 0 29
103375: NOT
103376: PUSH
103377: LD_VAR 0 25
103381: AND
103382: IFFALSE 103477
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103384: LD_ADDR_VAR 0 13
103388: PUSH
103389: LD_VAR 0 14
103393: PPUSH
103394: LD_INT 2
103396: PUSH
103397: LD_INT 30
103399: PUSH
103400: LD_INT 0
103402: PUSH
103403: EMPTY
103404: LIST
103405: LIST
103406: PUSH
103407: LD_INT 30
103409: PUSH
103410: LD_INT 1
103412: PUSH
103413: EMPTY
103414: LIST
103415: LIST
103416: PUSH
103417: EMPTY
103418: LIST
103419: LIST
103420: LIST
103421: PPUSH
103422: CALL_OW 72
103426: ST_TO_ADDR
// if z then
103427: LD_VAR 0 13
103431: IFFALSE 103477
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103433: LD_VAR 0 4
103437: PUSH
103438: LD_VAR 0 7
103442: ARRAY
103443: PPUSH
103444: LD_VAR 0 13
103448: PPUSH
103449: LD_VAR 0 4
103453: PUSH
103454: LD_VAR 0 7
103458: ARRAY
103459: PPUSH
103460: CALL_OW 74
103464: PPUSH
103465: CALL_OW 115
// attacking := true ;
103469: LD_ADDR_VAR 0 29
103473: PUSH
103474: LD_INT 1
103476: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103477: LD_VAR 0 4
103481: PUSH
103482: LD_VAR 0 7
103486: ARRAY
103487: PPUSH
103488: CALL_OW 256
103492: PUSH
103493: LD_INT 500
103495: LESS
103496: IFFALSE 103522
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103498: LD_VAR 0 4
103502: PUSH
103503: LD_VAR 0 7
103507: ARRAY
103508: PPUSH
103509: LD_VAR 0 14
103513: PUSH
103514: LD_INT 1
103516: ARRAY
103517: PPUSH
103518: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103522: LD_VAR 0 4
103526: PUSH
103527: LD_VAR 0 7
103531: ARRAY
103532: PPUSH
103533: CALL_OW 264
103537: PUSH
103538: LD_INT 49
103540: EQUAL
103541: IFFALSE 103662
// begin if not HasTask ( group [ i ] ) then
103543: LD_VAR 0 4
103547: PUSH
103548: LD_VAR 0 7
103552: ARRAY
103553: PPUSH
103554: CALL_OW 314
103558: NOT
103559: IFFALSE 103662
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103561: LD_ADDR_VAR 0 9
103565: PUSH
103566: LD_INT 81
103568: PUSH
103569: LD_VAR 0 4
103573: PUSH
103574: LD_VAR 0 7
103578: ARRAY
103579: PPUSH
103580: CALL_OW 255
103584: PUSH
103585: EMPTY
103586: LIST
103587: LIST
103588: PPUSH
103589: CALL_OW 69
103593: PPUSH
103594: LD_VAR 0 4
103598: PUSH
103599: LD_VAR 0 7
103603: ARRAY
103604: PPUSH
103605: CALL_OW 74
103609: ST_TO_ADDR
// if k then
103610: LD_VAR 0 9
103614: IFFALSE 103662
// if GetDistUnits ( group [ i ] , k ) > 10 then
103616: LD_VAR 0 4
103620: PUSH
103621: LD_VAR 0 7
103625: ARRAY
103626: PPUSH
103627: LD_VAR 0 9
103631: PPUSH
103632: CALL_OW 296
103636: PUSH
103637: LD_INT 10
103639: GREATER
103640: IFFALSE 103662
// ComMoveUnit ( group [ i ] , k ) ;
103642: LD_VAR 0 4
103646: PUSH
103647: LD_VAR 0 7
103651: ARRAY
103652: PPUSH
103653: LD_VAR 0 9
103657: PPUSH
103658: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103662: LD_VAR 0 4
103666: PUSH
103667: LD_VAR 0 7
103671: ARRAY
103672: PPUSH
103673: CALL_OW 256
103677: PUSH
103678: LD_INT 250
103680: LESS
103681: PUSH
103682: LD_VAR 0 4
103686: PUSH
103687: LD_VAR 0 7
103691: ARRAY
103692: PUSH
103693: LD_INT 21
103695: PUSH
103696: LD_INT 2
103698: PUSH
103699: EMPTY
103700: LIST
103701: LIST
103702: PUSH
103703: LD_INT 23
103705: PUSH
103706: LD_INT 2
103708: PUSH
103709: EMPTY
103710: LIST
103711: LIST
103712: PUSH
103713: EMPTY
103714: LIST
103715: LIST
103716: PPUSH
103717: CALL_OW 69
103721: IN
103722: AND
103723: IFFALSE 103848
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103725: LD_ADDR_VAR 0 9
103729: PUSH
103730: LD_OWVAR 3
103734: PUSH
103735: LD_VAR 0 4
103739: PUSH
103740: LD_VAR 0 7
103744: ARRAY
103745: DIFF
103746: PPUSH
103747: LD_VAR 0 4
103751: PUSH
103752: LD_VAR 0 7
103756: ARRAY
103757: PPUSH
103758: CALL_OW 74
103762: ST_TO_ADDR
// if not k then
103763: LD_VAR 0 9
103767: NOT
103768: IFFALSE 103772
// continue ;
103770: GO 100213
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103772: LD_VAR 0 9
103776: PUSH
103777: LD_INT 81
103779: PUSH
103780: LD_VAR 0 4
103784: PUSH
103785: LD_VAR 0 7
103789: ARRAY
103790: PPUSH
103791: CALL_OW 255
103795: PUSH
103796: EMPTY
103797: LIST
103798: LIST
103799: PPUSH
103800: CALL_OW 69
103804: IN
103805: PUSH
103806: LD_VAR 0 9
103810: PPUSH
103811: LD_VAR 0 4
103815: PUSH
103816: LD_VAR 0 7
103820: ARRAY
103821: PPUSH
103822: CALL_OW 296
103826: PUSH
103827: LD_INT 5
103829: LESS
103830: AND
103831: IFFALSE 103848
// ComAutodestruct ( group [ i ] ) ;
103833: LD_VAR 0 4
103837: PUSH
103838: LD_VAR 0 7
103842: ARRAY
103843: PPUSH
103844: CALL 98308 0 1
// end ; if f_attack_depot then
103848: LD_VAR 0 25
103852: IFFALSE 103964
// begin k := 6 ;
103854: LD_ADDR_VAR 0 9
103858: PUSH
103859: LD_INT 6
103861: ST_TO_ADDR
// if tmp < k then
103862: LD_VAR 0 14
103866: PUSH
103867: LD_VAR 0 9
103871: LESS
103872: IFFALSE 103884
// k := tmp ;
103874: LD_ADDR_VAR 0 9
103878: PUSH
103879: LD_VAR 0 14
103883: ST_TO_ADDR
// for j = 1 to k do
103884: LD_ADDR_VAR 0 8
103888: PUSH
103889: DOUBLE
103890: LD_INT 1
103892: DEC
103893: ST_TO_ADDR
103894: LD_VAR 0 9
103898: PUSH
103899: FOR_TO
103900: IFFALSE 103962
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103902: LD_VAR 0 8
103906: PPUSH
103907: CALL_OW 266
103911: PUSH
103912: LD_INT 0
103914: PUSH
103915: LD_INT 1
103917: PUSH
103918: EMPTY
103919: LIST
103920: LIST
103921: IN
103922: IFFALSE 103960
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103924: LD_VAR 0 4
103928: PUSH
103929: LD_VAR 0 7
103933: ARRAY
103934: PPUSH
103935: LD_VAR 0 14
103939: PUSH
103940: LD_VAR 0 8
103944: ARRAY
103945: PPUSH
103946: CALL_OW 115
// attacking := true ;
103950: LD_ADDR_VAR 0 29
103954: PUSH
103955: LD_INT 1
103957: ST_TO_ADDR
// break ;
103958: GO 103962
// end ;
103960: GO 103899
103962: POP
103963: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103964: LD_VAR 0 4
103968: PUSH
103969: LD_VAR 0 7
103973: ARRAY
103974: PPUSH
103975: CALL_OW 302
103979: PUSH
103980: LD_VAR 0 29
103984: NOT
103985: AND
103986: IFFALSE 104308
// begin if GetTag ( group [ i ] ) = 71 then
103988: LD_VAR 0 4
103992: PUSH
103993: LD_VAR 0 7
103997: ARRAY
103998: PPUSH
103999: CALL_OW 110
104003: PUSH
104004: LD_INT 71
104006: EQUAL
104007: IFFALSE 104048
// begin if HasTask ( group [ i ] ) then
104009: LD_VAR 0 4
104013: PUSH
104014: LD_VAR 0 7
104018: ARRAY
104019: PPUSH
104020: CALL_OW 314
104024: IFFALSE 104030
// continue else
104026: GO 100213
104028: GO 104048
// SetTag ( group [ i ] , 0 ) ;
104030: LD_VAR 0 4
104034: PUSH
104035: LD_VAR 0 7
104039: ARRAY
104040: PPUSH
104041: LD_INT 0
104043: PPUSH
104044: CALL_OW 109
// end ; k := 8 ;
104048: LD_ADDR_VAR 0 9
104052: PUSH
104053: LD_INT 8
104055: ST_TO_ADDR
// x := 0 ;
104056: LD_ADDR_VAR 0 10
104060: PUSH
104061: LD_INT 0
104063: ST_TO_ADDR
// if tmp < k then
104064: LD_VAR 0 14
104068: PUSH
104069: LD_VAR 0 9
104073: LESS
104074: IFFALSE 104086
// k := tmp ;
104076: LD_ADDR_VAR 0 9
104080: PUSH
104081: LD_VAR 0 14
104085: ST_TO_ADDR
// for j = 1 to k do
104086: LD_ADDR_VAR 0 8
104090: PUSH
104091: DOUBLE
104092: LD_INT 1
104094: DEC
104095: ST_TO_ADDR
104096: LD_VAR 0 9
104100: PUSH
104101: FOR_TO
104102: IFFALSE 104200
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104104: LD_VAR 0 14
104108: PUSH
104109: LD_VAR 0 8
104113: ARRAY
104114: PPUSH
104115: CALL_OW 247
104119: PUSH
104120: LD_INT 1
104122: EQUAL
104123: PUSH
104124: LD_VAR 0 14
104128: PUSH
104129: LD_VAR 0 8
104133: ARRAY
104134: PPUSH
104135: CALL_OW 256
104139: PUSH
104140: LD_INT 250
104142: LESS
104143: PUSH
104144: LD_VAR 0 20
104148: AND
104149: PUSH
104150: LD_VAR 0 20
104154: NOT
104155: PUSH
104156: LD_VAR 0 14
104160: PUSH
104161: LD_VAR 0 8
104165: ARRAY
104166: PPUSH
104167: CALL_OW 256
104171: PUSH
104172: LD_INT 250
104174: GREATEREQUAL
104175: AND
104176: OR
104177: AND
104178: IFFALSE 104198
// begin x := tmp [ j ] ;
104180: LD_ADDR_VAR 0 10
104184: PUSH
104185: LD_VAR 0 14
104189: PUSH
104190: LD_VAR 0 8
104194: ARRAY
104195: ST_TO_ADDR
// break ;
104196: GO 104200
// end ;
104198: GO 104101
104200: POP
104201: POP
// if x then
104202: LD_VAR 0 10
104206: IFFALSE 104230
// ComAttackUnit ( group [ i ] , x ) else
104208: LD_VAR 0 4
104212: PUSH
104213: LD_VAR 0 7
104217: ARRAY
104218: PPUSH
104219: LD_VAR 0 10
104223: PPUSH
104224: CALL_OW 115
104228: GO 104254
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104230: LD_VAR 0 4
104234: PUSH
104235: LD_VAR 0 7
104239: ARRAY
104240: PPUSH
104241: LD_VAR 0 14
104245: PUSH
104246: LD_INT 1
104248: ARRAY
104249: PPUSH
104250: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104254: LD_VAR 0 4
104258: PUSH
104259: LD_VAR 0 7
104263: ARRAY
104264: PPUSH
104265: CALL_OW 314
104269: NOT
104270: IFFALSE 104308
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104272: LD_VAR 0 4
104276: PUSH
104277: LD_VAR 0 7
104281: ARRAY
104282: PPUSH
104283: LD_VAR 0 14
104287: PPUSH
104288: LD_VAR 0 4
104292: PUSH
104293: LD_VAR 0 7
104297: ARRAY
104298: PPUSH
104299: CALL_OW 74
104303: PPUSH
104304: CALL_OW 115
// end ; end ; end ;
104308: GO 100213
104310: POP
104311: POP
// wait ( 0 0$1 ) ;
104312: LD_INT 35
104314: PPUSH
104315: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104319: LD_VAR 0 4
104323: PUSH
104324: EMPTY
104325: EQUAL
104326: PUSH
104327: LD_INT 81
104329: PUSH
104330: LD_VAR 0 35
104334: PUSH
104335: EMPTY
104336: LIST
104337: LIST
104338: PPUSH
104339: CALL_OW 69
104343: NOT
104344: OR
104345: IFFALSE 100198
// end ;
104347: LD_VAR 0 2
104351: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104352: LD_INT 0
104354: PPUSH
104355: PPUSH
104356: PPUSH
104357: PPUSH
// if not base_units then
104358: LD_VAR 0 1
104362: NOT
104363: IFFALSE 104367
// exit ;
104365: GO 104454
// result := false ;
104367: LD_ADDR_VAR 0 2
104371: PUSH
104372: LD_INT 0
104374: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104375: LD_ADDR_VAR 0 5
104379: PUSH
104380: LD_VAR 0 1
104384: PPUSH
104385: LD_INT 21
104387: PUSH
104388: LD_INT 3
104390: PUSH
104391: EMPTY
104392: LIST
104393: LIST
104394: PPUSH
104395: CALL_OW 72
104399: ST_TO_ADDR
// if not tmp then
104400: LD_VAR 0 5
104404: NOT
104405: IFFALSE 104409
// exit ;
104407: GO 104454
// for i in tmp do
104409: LD_ADDR_VAR 0 3
104413: PUSH
104414: LD_VAR 0 5
104418: PUSH
104419: FOR_IN
104420: IFFALSE 104452
// begin result := EnemyInRange ( i , 22 ) ;
104422: LD_ADDR_VAR 0 2
104426: PUSH
104427: LD_VAR 0 3
104431: PPUSH
104432: LD_INT 22
104434: PPUSH
104435: CALL 97991 0 2
104439: ST_TO_ADDR
// if result then
104440: LD_VAR 0 2
104444: IFFALSE 104450
// exit ;
104446: POP
104447: POP
104448: GO 104454
// end ;
104450: GO 104419
104452: POP
104453: POP
// end ;
104454: LD_VAR 0 2
104458: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104459: LD_INT 0
104461: PPUSH
104462: PPUSH
// if not units then
104463: LD_VAR 0 1
104467: NOT
104468: IFFALSE 104472
// exit ;
104470: GO 104542
// result := [ ] ;
104472: LD_ADDR_VAR 0 3
104476: PUSH
104477: EMPTY
104478: ST_TO_ADDR
// for i in units do
104479: LD_ADDR_VAR 0 4
104483: PUSH
104484: LD_VAR 0 1
104488: PUSH
104489: FOR_IN
104490: IFFALSE 104540
// if GetTag ( i ) = tag then
104492: LD_VAR 0 4
104496: PPUSH
104497: CALL_OW 110
104501: PUSH
104502: LD_VAR 0 2
104506: EQUAL
104507: IFFALSE 104538
// result := Insert ( result , result + 1 , i ) ;
104509: LD_ADDR_VAR 0 3
104513: PUSH
104514: LD_VAR 0 3
104518: PPUSH
104519: LD_VAR 0 3
104523: PUSH
104524: LD_INT 1
104526: PLUS
104527: PPUSH
104528: LD_VAR 0 4
104532: PPUSH
104533: CALL_OW 2
104537: ST_TO_ADDR
104538: GO 104489
104540: POP
104541: POP
// end ;
104542: LD_VAR 0 3
104546: RET
// export function IsDriver ( un ) ; begin
104547: LD_INT 0
104549: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104550: LD_ADDR_VAR 0 2
104554: PUSH
104555: LD_VAR 0 1
104559: PUSH
104560: LD_INT 55
104562: PUSH
104563: EMPTY
104564: LIST
104565: PPUSH
104566: CALL_OW 69
104570: IN
104571: ST_TO_ADDR
// end ;
104572: LD_VAR 0 2
104576: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104577: LD_INT 0
104579: PPUSH
104580: PPUSH
// list := [ ] ;
104581: LD_ADDR_VAR 0 5
104585: PUSH
104586: EMPTY
104587: ST_TO_ADDR
// case d of 0 :
104588: LD_VAR 0 3
104592: PUSH
104593: LD_INT 0
104595: DOUBLE
104596: EQUAL
104597: IFTRUE 104601
104599: GO 104734
104601: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104602: LD_ADDR_VAR 0 5
104606: PUSH
104607: LD_VAR 0 1
104611: PUSH
104612: LD_INT 4
104614: MINUS
104615: PUSH
104616: LD_VAR 0 2
104620: PUSH
104621: LD_INT 4
104623: MINUS
104624: PUSH
104625: LD_INT 2
104627: PUSH
104628: EMPTY
104629: LIST
104630: LIST
104631: LIST
104632: PUSH
104633: LD_VAR 0 1
104637: PUSH
104638: LD_INT 3
104640: MINUS
104641: PUSH
104642: LD_VAR 0 2
104646: PUSH
104647: LD_INT 1
104649: PUSH
104650: EMPTY
104651: LIST
104652: LIST
104653: LIST
104654: PUSH
104655: LD_VAR 0 1
104659: PUSH
104660: LD_INT 4
104662: PLUS
104663: PUSH
104664: LD_VAR 0 2
104668: PUSH
104669: LD_INT 4
104671: PUSH
104672: EMPTY
104673: LIST
104674: LIST
104675: LIST
104676: PUSH
104677: LD_VAR 0 1
104681: PUSH
104682: LD_INT 3
104684: PLUS
104685: PUSH
104686: LD_VAR 0 2
104690: PUSH
104691: LD_INT 3
104693: PLUS
104694: PUSH
104695: LD_INT 5
104697: PUSH
104698: EMPTY
104699: LIST
104700: LIST
104701: LIST
104702: PUSH
104703: LD_VAR 0 1
104707: PUSH
104708: LD_VAR 0 2
104712: PUSH
104713: LD_INT 4
104715: PLUS
104716: PUSH
104717: LD_INT 0
104719: PUSH
104720: EMPTY
104721: LIST
104722: LIST
104723: LIST
104724: PUSH
104725: EMPTY
104726: LIST
104727: LIST
104728: LIST
104729: LIST
104730: LIST
104731: ST_TO_ADDR
// end ; 1 :
104732: GO 105432
104734: LD_INT 1
104736: DOUBLE
104737: EQUAL
104738: IFTRUE 104742
104740: GO 104875
104742: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104743: LD_ADDR_VAR 0 5
104747: PUSH
104748: LD_VAR 0 1
104752: PUSH
104753: LD_VAR 0 2
104757: PUSH
104758: LD_INT 4
104760: MINUS
104761: PUSH
104762: LD_INT 3
104764: PUSH
104765: EMPTY
104766: LIST
104767: LIST
104768: LIST
104769: PUSH
104770: LD_VAR 0 1
104774: PUSH
104775: LD_INT 3
104777: MINUS
104778: PUSH
104779: LD_VAR 0 2
104783: PUSH
104784: LD_INT 3
104786: MINUS
104787: PUSH
104788: LD_INT 2
104790: PUSH
104791: EMPTY
104792: LIST
104793: LIST
104794: LIST
104795: PUSH
104796: LD_VAR 0 1
104800: PUSH
104801: LD_INT 4
104803: MINUS
104804: PUSH
104805: LD_VAR 0 2
104809: PUSH
104810: LD_INT 1
104812: PUSH
104813: EMPTY
104814: LIST
104815: LIST
104816: LIST
104817: PUSH
104818: LD_VAR 0 1
104822: PUSH
104823: LD_VAR 0 2
104827: PUSH
104828: LD_INT 3
104830: PLUS
104831: PUSH
104832: LD_INT 0
104834: PUSH
104835: EMPTY
104836: LIST
104837: LIST
104838: LIST
104839: PUSH
104840: LD_VAR 0 1
104844: PUSH
104845: LD_INT 4
104847: PLUS
104848: PUSH
104849: LD_VAR 0 2
104853: PUSH
104854: LD_INT 4
104856: PLUS
104857: PUSH
104858: LD_INT 5
104860: PUSH
104861: EMPTY
104862: LIST
104863: LIST
104864: LIST
104865: PUSH
104866: EMPTY
104867: LIST
104868: LIST
104869: LIST
104870: LIST
104871: LIST
104872: ST_TO_ADDR
// end ; 2 :
104873: GO 105432
104875: LD_INT 2
104877: DOUBLE
104878: EQUAL
104879: IFTRUE 104883
104881: GO 105012
104883: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104884: LD_ADDR_VAR 0 5
104888: PUSH
104889: LD_VAR 0 1
104893: PUSH
104894: LD_VAR 0 2
104898: PUSH
104899: LD_INT 3
104901: MINUS
104902: PUSH
104903: LD_INT 3
104905: PUSH
104906: EMPTY
104907: LIST
104908: LIST
104909: LIST
104910: PUSH
104911: LD_VAR 0 1
104915: PUSH
104916: LD_INT 4
104918: PLUS
104919: PUSH
104920: LD_VAR 0 2
104924: PUSH
104925: LD_INT 4
104927: PUSH
104928: EMPTY
104929: LIST
104930: LIST
104931: LIST
104932: PUSH
104933: LD_VAR 0 1
104937: PUSH
104938: LD_VAR 0 2
104942: PUSH
104943: LD_INT 4
104945: PLUS
104946: PUSH
104947: LD_INT 0
104949: PUSH
104950: EMPTY
104951: LIST
104952: LIST
104953: LIST
104954: PUSH
104955: LD_VAR 0 1
104959: PUSH
104960: LD_INT 3
104962: MINUS
104963: PUSH
104964: LD_VAR 0 2
104968: PUSH
104969: LD_INT 1
104971: PUSH
104972: EMPTY
104973: LIST
104974: LIST
104975: LIST
104976: PUSH
104977: LD_VAR 0 1
104981: PUSH
104982: LD_INT 4
104984: MINUS
104985: PUSH
104986: LD_VAR 0 2
104990: PUSH
104991: LD_INT 4
104993: MINUS
104994: PUSH
104995: LD_INT 2
104997: PUSH
104998: EMPTY
104999: LIST
105000: LIST
105001: LIST
105002: PUSH
105003: EMPTY
105004: LIST
105005: LIST
105006: LIST
105007: LIST
105008: LIST
105009: ST_TO_ADDR
// end ; 3 :
105010: GO 105432
105012: LD_INT 3
105014: DOUBLE
105015: EQUAL
105016: IFTRUE 105020
105018: GO 105153
105020: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105021: LD_ADDR_VAR 0 5
105025: PUSH
105026: LD_VAR 0 1
105030: PUSH
105031: LD_INT 3
105033: PLUS
105034: PUSH
105035: LD_VAR 0 2
105039: PUSH
105040: LD_INT 4
105042: PUSH
105043: EMPTY
105044: LIST
105045: LIST
105046: LIST
105047: PUSH
105048: LD_VAR 0 1
105052: PUSH
105053: LD_INT 4
105055: PLUS
105056: PUSH
105057: LD_VAR 0 2
105061: PUSH
105062: LD_INT 4
105064: PLUS
105065: PUSH
105066: LD_INT 5
105068: PUSH
105069: EMPTY
105070: LIST
105071: LIST
105072: LIST
105073: PUSH
105074: LD_VAR 0 1
105078: PUSH
105079: LD_INT 4
105081: MINUS
105082: PUSH
105083: LD_VAR 0 2
105087: PUSH
105088: LD_INT 1
105090: PUSH
105091: EMPTY
105092: LIST
105093: LIST
105094: LIST
105095: PUSH
105096: LD_VAR 0 1
105100: PUSH
105101: LD_VAR 0 2
105105: PUSH
105106: LD_INT 4
105108: MINUS
105109: PUSH
105110: LD_INT 3
105112: PUSH
105113: EMPTY
105114: LIST
105115: LIST
105116: LIST
105117: PUSH
105118: LD_VAR 0 1
105122: PUSH
105123: LD_INT 3
105125: MINUS
105126: PUSH
105127: LD_VAR 0 2
105131: PUSH
105132: LD_INT 3
105134: MINUS
105135: PUSH
105136: LD_INT 2
105138: PUSH
105139: EMPTY
105140: LIST
105141: LIST
105142: LIST
105143: PUSH
105144: EMPTY
105145: LIST
105146: LIST
105147: LIST
105148: LIST
105149: LIST
105150: ST_TO_ADDR
// end ; 4 :
105151: GO 105432
105153: LD_INT 4
105155: DOUBLE
105156: EQUAL
105157: IFTRUE 105161
105159: GO 105294
105161: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105162: LD_ADDR_VAR 0 5
105166: PUSH
105167: LD_VAR 0 1
105171: PUSH
105172: LD_VAR 0 2
105176: PUSH
105177: LD_INT 4
105179: PLUS
105180: PUSH
105181: LD_INT 0
105183: PUSH
105184: EMPTY
105185: LIST
105186: LIST
105187: LIST
105188: PUSH
105189: LD_VAR 0 1
105193: PUSH
105194: LD_INT 3
105196: PLUS
105197: PUSH
105198: LD_VAR 0 2
105202: PUSH
105203: LD_INT 3
105205: PLUS
105206: PUSH
105207: LD_INT 5
105209: PUSH
105210: EMPTY
105211: LIST
105212: LIST
105213: LIST
105214: PUSH
105215: LD_VAR 0 1
105219: PUSH
105220: LD_INT 4
105222: PLUS
105223: PUSH
105224: LD_VAR 0 2
105228: PUSH
105229: LD_INT 4
105231: PUSH
105232: EMPTY
105233: LIST
105234: LIST
105235: LIST
105236: PUSH
105237: LD_VAR 0 1
105241: PUSH
105242: LD_VAR 0 2
105246: PUSH
105247: LD_INT 3
105249: MINUS
105250: PUSH
105251: LD_INT 3
105253: PUSH
105254: EMPTY
105255: LIST
105256: LIST
105257: LIST
105258: PUSH
105259: LD_VAR 0 1
105263: PUSH
105264: LD_INT 4
105266: MINUS
105267: PUSH
105268: LD_VAR 0 2
105272: PUSH
105273: LD_INT 4
105275: MINUS
105276: PUSH
105277: LD_INT 2
105279: PUSH
105280: EMPTY
105281: LIST
105282: LIST
105283: LIST
105284: PUSH
105285: EMPTY
105286: LIST
105287: LIST
105288: LIST
105289: LIST
105290: LIST
105291: ST_TO_ADDR
// end ; 5 :
105292: GO 105432
105294: LD_INT 5
105296: DOUBLE
105297: EQUAL
105298: IFTRUE 105302
105300: GO 105431
105302: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105303: LD_ADDR_VAR 0 5
105307: PUSH
105308: LD_VAR 0 1
105312: PUSH
105313: LD_INT 4
105315: MINUS
105316: PUSH
105317: LD_VAR 0 2
105321: PUSH
105322: LD_INT 1
105324: PUSH
105325: EMPTY
105326: LIST
105327: LIST
105328: LIST
105329: PUSH
105330: LD_VAR 0 1
105334: PUSH
105335: LD_VAR 0 2
105339: PUSH
105340: LD_INT 4
105342: MINUS
105343: PUSH
105344: LD_INT 3
105346: PUSH
105347: EMPTY
105348: LIST
105349: LIST
105350: LIST
105351: PUSH
105352: LD_VAR 0 1
105356: PUSH
105357: LD_INT 4
105359: PLUS
105360: PUSH
105361: LD_VAR 0 2
105365: PUSH
105366: LD_INT 4
105368: PLUS
105369: PUSH
105370: LD_INT 5
105372: PUSH
105373: EMPTY
105374: LIST
105375: LIST
105376: LIST
105377: PUSH
105378: LD_VAR 0 1
105382: PUSH
105383: LD_INT 3
105385: PLUS
105386: PUSH
105387: LD_VAR 0 2
105391: PUSH
105392: LD_INT 4
105394: PUSH
105395: EMPTY
105396: LIST
105397: LIST
105398: LIST
105399: PUSH
105400: LD_VAR 0 1
105404: PUSH
105405: LD_VAR 0 2
105409: PUSH
105410: LD_INT 3
105412: PLUS
105413: PUSH
105414: LD_INT 0
105416: PUSH
105417: EMPTY
105418: LIST
105419: LIST
105420: LIST
105421: PUSH
105422: EMPTY
105423: LIST
105424: LIST
105425: LIST
105426: LIST
105427: LIST
105428: ST_TO_ADDR
// end ; end ;
105429: GO 105432
105431: POP
// result := list ;
105432: LD_ADDR_VAR 0 4
105436: PUSH
105437: LD_VAR 0 5
105441: ST_TO_ADDR
// end ;
105442: LD_VAR 0 4
105446: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105447: LD_INT 0
105449: PPUSH
105450: PPUSH
105451: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105452: LD_VAR 0 1
105456: NOT
105457: PUSH
105458: LD_VAR 0 2
105462: PUSH
105463: LD_INT 1
105465: PUSH
105466: LD_INT 2
105468: PUSH
105469: LD_INT 3
105471: PUSH
105472: LD_INT 4
105474: PUSH
105475: EMPTY
105476: LIST
105477: LIST
105478: LIST
105479: LIST
105480: IN
105481: NOT
105482: OR
105483: IFFALSE 105487
// exit ;
105485: GO 105579
// tmp := [ ] ;
105487: LD_ADDR_VAR 0 5
105491: PUSH
105492: EMPTY
105493: ST_TO_ADDR
// for i in units do
105494: LD_ADDR_VAR 0 4
105498: PUSH
105499: LD_VAR 0 1
105503: PUSH
105504: FOR_IN
105505: IFFALSE 105548
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105507: LD_ADDR_VAR 0 5
105511: PUSH
105512: LD_VAR 0 5
105516: PPUSH
105517: LD_VAR 0 5
105521: PUSH
105522: LD_INT 1
105524: PLUS
105525: PPUSH
105526: LD_VAR 0 4
105530: PPUSH
105531: LD_VAR 0 2
105535: PPUSH
105536: CALL_OW 259
105540: PPUSH
105541: CALL_OW 2
105545: ST_TO_ADDR
105546: GO 105504
105548: POP
105549: POP
// if not tmp then
105550: LD_VAR 0 5
105554: NOT
105555: IFFALSE 105559
// exit ;
105557: GO 105579
// result := SortListByListDesc ( units , tmp ) ;
105559: LD_ADDR_VAR 0 3
105563: PUSH
105564: LD_VAR 0 1
105568: PPUSH
105569: LD_VAR 0 5
105573: PPUSH
105574: CALL_OW 77
105578: ST_TO_ADDR
// end ;
105579: LD_VAR 0 3
105583: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105584: LD_INT 0
105586: PPUSH
105587: PPUSH
105588: PPUSH
// x := GetX ( building ) ;
105589: LD_ADDR_VAR 0 4
105593: PUSH
105594: LD_VAR 0 2
105598: PPUSH
105599: CALL_OW 250
105603: ST_TO_ADDR
// y := GetY ( building ) ;
105604: LD_ADDR_VAR 0 5
105608: PUSH
105609: LD_VAR 0 2
105613: PPUSH
105614: CALL_OW 251
105618: ST_TO_ADDR
// if GetTaskList ( unit ) then
105619: LD_VAR 0 1
105623: PPUSH
105624: CALL_OW 437
105628: IFFALSE 105723
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105630: LD_STRING e
105632: PUSH
105633: LD_VAR 0 1
105637: PPUSH
105638: CALL_OW 437
105642: PUSH
105643: LD_INT 1
105645: ARRAY
105646: PUSH
105647: LD_INT 1
105649: ARRAY
105650: EQUAL
105651: PUSH
105652: LD_VAR 0 4
105656: PUSH
105657: LD_VAR 0 1
105661: PPUSH
105662: CALL_OW 437
105666: PUSH
105667: LD_INT 1
105669: ARRAY
105670: PUSH
105671: LD_INT 2
105673: ARRAY
105674: EQUAL
105675: AND
105676: PUSH
105677: LD_VAR 0 5
105681: PUSH
105682: LD_VAR 0 1
105686: PPUSH
105687: CALL_OW 437
105691: PUSH
105692: LD_INT 1
105694: ARRAY
105695: PUSH
105696: LD_INT 3
105698: ARRAY
105699: EQUAL
105700: AND
105701: IFFALSE 105713
// result := true else
105703: LD_ADDR_VAR 0 3
105707: PUSH
105708: LD_INT 1
105710: ST_TO_ADDR
105711: GO 105721
// result := false ;
105713: LD_ADDR_VAR 0 3
105717: PUSH
105718: LD_INT 0
105720: ST_TO_ADDR
// end else
105721: GO 105731
// result := false ;
105723: LD_ADDR_VAR 0 3
105727: PUSH
105728: LD_INT 0
105730: ST_TO_ADDR
// end ;
105731: LD_VAR 0 3
105735: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105736: LD_INT 0
105738: PPUSH
105739: PPUSH
105740: PPUSH
105741: PPUSH
// if not unit or not area then
105742: LD_VAR 0 1
105746: NOT
105747: PUSH
105748: LD_VAR 0 2
105752: NOT
105753: OR
105754: IFFALSE 105758
// exit ;
105756: GO 105922
// tmp := AreaToList ( area , i ) ;
105758: LD_ADDR_VAR 0 6
105762: PUSH
105763: LD_VAR 0 2
105767: PPUSH
105768: LD_VAR 0 5
105772: PPUSH
105773: CALL_OW 517
105777: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105778: LD_ADDR_VAR 0 5
105782: PUSH
105783: DOUBLE
105784: LD_INT 1
105786: DEC
105787: ST_TO_ADDR
105788: LD_VAR 0 6
105792: PUSH
105793: LD_INT 1
105795: ARRAY
105796: PUSH
105797: FOR_TO
105798: IFFALSE 105920
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105800: LD_ADDR_VAR 0 7
105804: PUSH
105805: LD_VAR 0 6
105809: PUSH
105810: LD_INT 1
105812: ARRAY
105813: PUSH
105814: LD_VAR 0 5
105818: ARRAY
105819: PUSH
105820: LD_VAR 0 6
105824: PUSH
105825: LD_INT 2
105827: ARRAY
105828: PUSH
105829: LD_VAR 0 5
105833: ARRAY
105834: PUSH
105835: EMPTY
105836: LIST
105837: LIST
105838: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
105839: LD_VAR 0 7
105843: PUSH
105844: LD_INT 1
105846: ARRAY
105847: PPUSH
105848: LD_VAR 0 7
105852: PUSH
105853: LD_INT 2
105855: ARRAY
105856: PPUSH
105857: CALL_OW 428
105861: PUSH
105862: LD_INT 0
105864: EQUAL
105865: IFFALSE 105918
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
105867: LD_VAR 0 1
105871: PPUSH
105872: LD_VAR 0 7
105876: PUSH
105877: LD_INT 1
105879: ARRAY
105880: PPUSH
105881: LD_VAR 0 7
105885: PUSH
105886: LD_INT 2
105888: ARRAY
105889: PPUSH
105890: LD_VAR 0 3
105894: PPUSH
105895: CALL_OW 48
// result := IsPlaced ( unit ) ;
105899: LD_ADDR_VAR 0 4
105903: PUSH
105904: LD_VAR 0 1
105908: PPUSH
105909: CALL_OW 305
105913: ST_TO_ADDR
// exit ;
105914: POP
105915: POP
105916: GO 105922
// end ; end ;
105918: GO 105797
105920: POP
105921: POP
// end ;
105922: LD_VAR 0 4
105926: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105927: LD_INT 0
105929: PPUSH
105930: PPUSH
105931: PPUSH
// if not side or side > 8 then
105932: LD_VAR 0 1
105936: NOT
105937: PUSH
105938: LD_VAR 0 1
105942: PUSH
105943: LD_INT 8
105945: GREATER
105946: OR
105947: IFFALSE 105951
// exit ;
105949: GO 106138
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105951: LD_ADDR_VAR 0 4
105955: PUSH
105956: LD_INT 22
105958: PUSH
105959: LD_VAR 0 1
105963: PUSH
105964: EMPTY
105965: LIST
105966: LIST
105967: PUSH
105968: LD_INT 21
105970: PUSH
105971: LD_INT 3
105973: PUSH
105974: EMPTY
105975: LIST
105976: LIST
105977: PUSH
105978: EMPTY
105979: LIST
105980: LIST
105981: PPUSH
105982: CALL_OW 69
105986: ST_TO_ADDR
// if not tmp then
105987: LD_VAR 0 4
105991: NOT
105992: IFFALSE 105996
// exit ;
105994: GO 106138
// enable_addtolog := true ;
105996: LD_ADDR_OWVAR 81
106000: PUSH
106001: LD_INT 1
106003: ST_TO_ADDR
// AddToLog ( [ ) ;
106004: LD_STRING [
106006: PPUSH
106007: CALL_OW 561
// for i in tmp do
106011: LD_ADDR_VAR 0 3
106015: PUSH
106016: LD_VAR 0 4
106020: PUSH
106021: FOR_IN
106022: IFFALSE 106129
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106024: LD_STRING [
106026: PUSH
106027: LD_VAR 0 3
106031: PPUSH
106032: CALL_OW 266
106036: STR
106037: PUSH
106038: LD_STRING , 
106040: STR
106041: PUSH
106042: LD_VAR 0 3
106046: PPUSH
106047: CALL_OW 250
106051: STR
106052: PUSH
106053: LD_STRING , 
106055: STR
106056: PUSH
106057: LD_VAR 0 3
106061: PPUSH
106062: CALL_OW 251
106066: STR
106067: PUSH
106068: LD_STRING , 
106070: STR
106071: PUSH
106072: LD_VAR 0 3
106076: PPUSH
106077: CALL_OW 254
106081: STR
106082: PUSH
106083: LD_STRING , 
106085: STR
106086: PUSH
106087: LD_VAR 0 3
106091: PPUSH
106092: LD_INT 1
106094: PPUSH
106095: CALL_OW 268
106099: STR
106100: PUSH
106101: LD_STRING , 
106103: STR
106104: PUSH
106105: LD_VAR 0 3
106109: PPUSH
106110: LD_INT 2
106112: PPUSH
106113: CALL_OW 268
106117: STR
106118: PUSH
106119: LD_STRING ],
106121: STR
106122: PPUSH
106123: CALL_OW 561
// end ;
106127: GO 106021
106129: POP
106130: POP
// AddToLog ( ]; ) ;
106131: LD_STRING ];
106133: PPUSH
106134: CALL_OW 561
// end ;
106138: LD_VAR 0 2
106142: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106143: LD_INT 0
106145: PPUSH
106146: PPUSH
106147: PPUSH
106148: PPUSH
106149: PPUSH
// if not area or not rate or not max then
106150: LD_VAR 0 1
106154: NOT
106155: PUSH
106156: LD_VAR 0 2
106160: NOT
106161: OR
106162: PUSH
106163: LD_VAR 0 4
106167: NOT
106168: OR
106169: IFFALSE 106173
// exit ;
106171: GO 106365
// while 1 do
106173: LD_INT 1
106175: IFFALSE 106365
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106177: LD_ADDR_VAR 0 9
106181: PUSH
106182: LD_VAR 0 1
106186: PPUSH
106187: LD_INT 1
106189: PPUSH
106190: CALL_OW 287
106194: PUSH
106195: LD_INT 10
106197: MUL
106198: ST_TO_ADDR
// r := rate / 10 ;
106199: LD_ADDR_VAR 0 7
106203: PUSH
106204: LD_VAR 0 2
106208: PUSH
106209: LD_INT 10
106211: DIVREAL
106212: ST_TO_ADDR
// time := 1 1$00 ;
106213: LD_ADDR_VAR 0 8
106217: PUSH
106218: LD_INT 2100
106220: ST_TO_ADDR
// if amount < min then
106221: LD_VAR 0 9
106225: PUSH
106226: LD_VAR 0 3
106230: LESS
106231: IFFALSE 106249
// r := r * 2 else
106233: LD_ADDR_VAR 0 7
106237: PUSH
106238: LD_VAR 0 7
106242: PUSH
106243: LD_INT 2
106245: MUL
106246: ST_TO_ADDR
106247: GO 106275
// if amount > max then
106249: LD_VAR 0 9
106253: PUSH
106254: LD_VAR 0 4
106258: GREATER
106259: IFFALSE 106275
// r := r / 2 ;
106261: LD_ADDR_VAR 0 7
106265: PUSH
106266: LD_VAR 0 7
106270: PUSH
106271: LD_INT 2
106273: DIVREAL
106274: ST_TO_ADDR
// time := time / r ;
106275: LD_ADDR_VAR 0 8
106279: PUSH
106280: LD_VAR 0 8
106284: PUSH
106285: LD_VAR 0 7
106289: DIVREAL
106290: ST_TO_ADDR
// if time < 0 then
106291: LD_VAR 0 8
106295: PUSH
106296: LD_INT 0
106298: LESS
106299: IFFALSE 106316
// time := time * - 1 ;
106301: LD_ADDR_VAR 0 8
106305: PUSH
106306: LD_VAR 0 8
106310: PUSH
106311: LD_INT 1
106313: NEG
106314: MUL
106315: ST_TO_ADDR
// wait ( time ) ;
106316: LD_VAR 0 8
106320: PPUSH
106321: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106325: LD_INT 35
106327: PPUSH
106328: LD_INT 875
106330: PPUSH
106331: CALL_OW 12
106335: PPUSH
106336: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106340: LD_INT 1
106342: PPUSH
106343: LD_INT 5
106345: PPUSH
106346: CALL_OW 12
106350: PPUSH
106351: LD_VAR 0 1
106355: PPUSH
106356: LD_INT 1
106358: PPUSH
106359: CALL_OW 55
// end ;
106363: GO 106173
// end ;
106365: LD_VAR 0 5
106369: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106370: LD_INT 0
106372: PPUSH
106373: PPUSH
106374: PPUSH
106375: PPUSH
106376: PPUSH
106377: PPUSH
106378: PPUSH
106379: PPUSH
// if not turrets or not factories then
106380: LD_VAR 0 1
106384: NOT
106385: PUSH
106386: LD_VAR 0 2
106390: NOT
106391: OR
106392: IFFALSE 106396
// exit ;
106394: GO 106703
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106396: LD_ADDR_VAR 0 10
106400: PUSH
106401: LD_INT 5
106403: PUSH
106404: LD_INT 6
106406: PUSH
106407: EMPTY
106408: LIST
106409: LIST
106410: PUSH
106411: LD_INT 2
106413: PUSH
106414: LD_INT 4
106416: PUSH
106417: EMPTY
106418: LIST
106419: LIST
106420: PUSH
106421: LD_INT 3
106423: PUSH
106424: LD_INT 5
106426: PUSH
106427: EMPTY
106428: LIST
106429: LIST
106430: PUSH
106431: EMPTY
106432: LIST
106433: LIST
106434: LIST
106435: PUSH
106436: LD_INT 24
106438: PUSH
106439: LD_INT 25
106441: PUSH
106442: EMPTY
106443: LIST
106444: LIST
106445: PUSH
106446: LD_INT 23
106448: PUSH
106449: LD_INT 27
106451: PUSH
106452: EMPTY
106453: LIST
106454: LIST
106455: PUSH
106456: EMPTY
106457: LIST
106458: LIST
106459: PUSH
106460: LD_INT 42
106462: PUSH
106463: LD_INT 43
106465: PUSH
106466: EMPTY
106467: LIST
106468: LIST
106469: PUSH
106470: LD_INT 44
106472: PUSH
106473: LD_INT 46
106475: PUSH
106476: EMPTY
106477: LIST
106478: LIST
106479: PUSH
106480: LD_INT 45
106482: PUSH
106483: LD_INT 47
106485: PUSH
106486: EMPTY
106487: LIST
106488: LIST
106489: PUSH
106490: EMPTY
106491: LIST
106492: LIST
106493: LIST
106494: PUSH
106495: EMPTY
106496: LIST
106497: LIST
106498: LIST
106499: ST_TO_ADDR
// result := [ ] ;
106500: LD_ADDR_VAR 0 3
106504: PUSH
106505: EMPTY
106506: ST_TO_ADDR
// for i in turrets do
106507: LD_ADDR_VAR 0 4
106511: PUSH
106512: LD_VAR 0 1
106516: PUSH
106517: FOR_IN
106518: IFFALSE 106701
// begin nat := GetNation ( i ) ;
106520: LD_ADDR_VAR 0 7
106524: PUSH
106525: LD_VAR 0 4
106529: PPUSH
106530: CALL_OW 248
106534: ST_TO_ADDR
// weapon := 0 ;
106535: LD_ADDR_VAR 0 8
106539: PUSH
106540: LD_INT 0
106542: ST_TO_ADDR
// if not nat then
106543: LD_VAR 0 7
106547: NOT
106548: IFFALSE 106552
// continue ;
106550: GO 106517
// for j in list [ nat ] do
106552: LD_ADDR_VAR 0 5
106556: PUSH
106557: LD_VAR 0 10
106561: PUSH
106562: LD_VAR 0 7
106566: ARRAY
106567: PUSH
106568: FOR_IN
106569: IFFALSE 106610
// if GetBWeapon ( i ) = j [ 1 ] then
106571: LD_VAR 0 4
106575: PPUSH
106576: CALL_OW 269
106580: PUSH
106581: LD_VAR 0 5
106585: PUSH
106586: LD_INT 1
106588: ARRAY
106589: EQUAL
106590: IFFALSE 106608
// begin weapon := j [ 2 ] ;
106592: LD_ADDR_VAR 0 8
106596: PUSH
106597: LD_VAR 0 5
106601: PUSH
106602: LD_INT 2
106604: ARRAY
106605: ST_TO_ADDR
// break ;
106606: GO 106610
// end ;
106608: GO 106568
106610: POP
106611: POP
// if not weapon then
106612: LD_VAR 0 8
106616: NOT
106617: IFFALSE 106621
// continue ;
106619: GO 106517
// for k in factories do
106621: LD_ADDR_VAR 0 6
106625: PUSH
106626: LD_VAR 0 2
106630: PUSH
106631: FOR_IN
106632: IFFALSE 106697
// begin weapons := AvailableWeaponList ( k ) ;
106634: LD_ADDR_VAR 0 9
106638: PUSH
106639: LD_VAR 0 6
106643: PPUSH
106644: CALL_OW 478
106648: ST_TO_ADDR
// if not weapons then
106649: LD_VAR 0 9
106653: NOT
106654: IFFALSE 106658
// continue ;
106656: GO 106631
// if weapon in weapons then
106658: LD_VAR 0 8
106662: PUSH
106663: LD_VAR 0 9
106667: IN
106668: IFFALSE 106695
// begin result := [ i , weapon ] ;
106670: LD_ADDR_VAR 0 3
106674: PUSH
106675: LD_VAR 0 4
106679: PUSH
106680: LD_VAR 0 8
106684: PUSH
106685: EMPTY
106686: LIST
106687: LIST
106688: ST_TO_ADDR
// exit ;
106689: POP
106690: POP
106691: POP
106692: POP
106693: GO 106703
// end ; end ;
106695: GO 106631
106697: POP
106698: POP
// end ;
106699: GO 106517
106701: POP
106702: POP
// end ;
106703: LD_VAR 0 3
106707: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106708: LD_INT 0
106710: PPUSH
// if not side or side > 8 then
106711: LD_VAR 0 3
106715: NOT
106716: PUSH
106717: LD_VAR 0 3
106721: PUSH
106722: LD_INT 8
106724: GREATER
106725: OR
106726: IFFALSE 106730
// exit ;
106728: GO 106789
// if not range then
106730: LD_VAR 0 4
106734: NOT
106735: IFFALSE 106746
// range := - 12 ;
106737: LD_ADDR_VAR 0 4
106741: PUSH
106742: LD_INT 12
106744: NEG
106745: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106746: LD_VAR 0 1
106750: PPUSH
106751: LD_VAR 0 2
106755: PPUSH
106756: LD_VAR 0 3
106760: PPUSH
106761: LD_VAR 0 4
106765: PPUSH
106766: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106770: LD_VAR 0 1
106774: PPUSH
106775: LD_VAR 0 2
106779: PPUSH
106780: LD_VAR 0 3
106784: PPUSH
106785: CALL_OW 331
// end ;
106789: LD_VAR 0 5
106793: RET
// export function Video ( mode ) ; begin
106794: LD_INT 0
106796: PPUSH
// ingame_video = mode ;
106797: LD_ADDR_OWVAR 52
106801: PUSH
106802: LD_VAR 0 1
106806: ST_TO_ADDR
// interface_hidden = mode ;
106807: LD_ADDR_OWVAR 54
106811: PUSH
106812: LD_VAR 0 1
106816: ST_TO_ADDR
// end ;
106817: LD_VAR 0 2
106821: RET
// export function Join ( array , element ) ; begin
106822: LD_INT 0
106824: PPUSH
// result := array ^ element ;
106825: LD_ADDR_VAR 0 3
106829: PUSH
106830: LD_VAR 0 1
106834: PUSH
106835: LD_VAR 0 2
106839: ADD
106840: ST_TO_ADDR
// end ;
106841: LD_VAR 0 3
106845: RET
// export function JoinUnion ( array , element ) ; begin
106846: LD_INT 0
106848: PPUSH
// result := array union element ;
106849: LD_ADDR_VAR 0 3
106853: PUSH
106854: LD_VAR 0 1
106858: PUSH
106859: LD_VAR 0 2
106863: UNION
106864: ST_TO_ADDR
// end ;
106865: LD_VAR 0 3
106869: RET
// export function GetBehemoths ( side ) ; begin
106870: LD_INT 0
106872: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
106873: LD_ADDR_VAR 0 2
106877: PUSH
106878: LD_INT 22
106880: PUSH
106881: LD_VAR 0 1
106885: PUSH
106886: EMPTY
106887: LIST
106888: LIST
106889: PUSH
106890: LD_INT 31
106892: PUSH
106893: LD_INT 25
106895: PUSH
106896: EMPTY
106897: LIST
106898: LIST
106899: PUSH
106900: EMPTY
106901: LIST
106902: LIST
106903: PPUSH
106904: CALL_OW 69
106908: ST_TO_ADDR
// end ;
106909: LD_VAR 0 2
106913: RET
// export function Shuffle ( array ) ; var i , index ; begin
106914: LD_INT 0
106916: PPUSH
106917: PPUSH
106918: PPUSH
// result := [ ] ;
106919: LD_ADDR_VAR 0 2
106923: PUSH
106924: EMPTY
106925: ST_TO_ADDR
// if not array then
106926: LD_VAR 0 1
106930: NOT
106931: IFFALSE 106935
// exit ;
106933: GO 107034
// Randomize ;
106935: CALL_OW 10
// for i = array downto 1 do
106939: LD_ADDR_VAR 0 3
106943: PUSH
106944: DOUBLE
106945: LD_VAR 0 1
106949: INC
106950: ST_TO_ADDR
106951: LD_INT 1
106953: PUSH
106954: FOR_DOWNTO
106955: IFFALSE 107032
// begin index := rand ( 1 , array ) ;
106957: LD_ADDR_VAR 0 4
106961: PUSH
106962: LD_INT 1
106964: PPUSH
106965: LD_VAR 0 1
106969: PPUSH
106970: CALL_OW 12
106974: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106975: LD_ADDR_VAR 0 2
106979: PUSH
106980: LD_VAR 0 2
106984: PPUSH
106985: LD_VAR 0 2
106989: PUSH
106990: LD_INT 1
106992: PLUS
106993: PPUSH
106994: LD_VAR 0 1
106998: PUSH
106999: LD_VAR 0 4
107003: ARRAY
107004: PPUSH
107005: CALL_OW 2
107009: ST_TO_ADDR
// array := Delete ( array , index ) ;
107010: LD_ADDR_VAR 0 1
107014: PUSH
107015: LD_VAR 0 1
107019: PPUSH
107020: LD_VAR 0 4
107024: PPUSH
107025: CALL_OW 3
107029: ST_TO_ADDR
// end ;
107030: GO 106954
107032: POP
107033: POP
// end ;
107034: LD_VAR 0 2
107038: RET
// export function GetBaseMaterials ( base ) ; begin
107039: LD_INT 0
107041: PPUSH
// result := [ 0 , 0 , 0 ] ;
107042: LD_ADDR_VAR 0 2
107046: PUSH
107047: LD_INT 0
107049: PUSH
107050: LD_INT 0
107052: PUSH
107053: LD_INT 0
107055: PUSH
107056: EMPTY
107057: LIST
107058: LIST
107059: LIST
107060: ST_TO_ADDR
// if not base then
107061: LD_VAR 0 1
107065: NOT
107066: IFFALSE 107070
// exit ;
107068: GO 107119
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107070: LD_ADDR_VAR 0 2
107074: PUSH
107075: LD_VAR 0 1
107079: PPUSH
107080: LD_INT 1
107082: PPUSH
107083: CALL_OW 275
107087: PUSH
107088: LD_VAR 0 1
107092: PPUSH
107093: LD_INT 2
107095: PPUSH
107096: CALL_OW 275
107100: PUSH
107101: LD_VAR 0 1
107105: PPUSH
107106: LD_INT 3
107108: PPUSH
107109: CALL_OW 275
107113: PUSH
107114: EMPTY
107115: LIST
107116: LIST
107117: LIST
107118: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107119: LD_VAR 0 2
107123: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107124: LD_INT 0
107126: PPUSH
107127: PPUSH
107128: PPUSH
107129: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107130: LD_VAR 0 1
107134: PPUSH
107135: CALL_OW 264
107139: PUSH
107140: LD_EXP 96
107144: EQUAL
107145: IFFALSE 107217
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107147: LD_INT 68
107149: PPUSH
107150: LD_VAR 0 1
107154: PPUSH
107155: CALL_OW 255
107159: PPUSH
107160: CALL_OW 321
107164: PUSH
107165: LD_INT 2
107167: EQUAL
107168: IFFALSE 107180
// eff := 70 else
107170: LD_ADDR_VAR 0 6
107174: PUSH
107175: LD_INT 70
107177: ST_TO_ADDR
107178: GO 107188
// eff := 30 ;
107180: LD_ADDR_VAR 0 6
107184: PUSH
107185: LD_INT 30
107187: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107188: LD_VAR 0 1
107192: PPUSH
107193: CALL_OW 250
107197: PPUSH
107198: LD_VAR 0 1
107202: PPUSH
107203: CALL_OW 251
107207: PPUSH
107208: LD_VAR 0 6
107212: PPUSH
107213: CALL_OW 495
// end ; end ;
107217: LD_VAR 0 4
107221: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107222: LD_INT 0
107224: PPUSH
107225: PPUSH
107226: PPUSH
107227: PPUSH
107228: PPUSH
107229: PPUSH
// if cmd = 124 then
107230: LD_VAR 0 1
107234: PUSH
107235: LD_INT 124
107237: EQUAL
107238: IFFALSE 107444
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107240: LD_ADDR_VAR 0 5
107244: PUSH
107245: LD_INT 2
107247: PUSH
107248: LD_INT 34
107250: PUSH
107251: LD_INT 53
107253: PUSH
107254: EMPTY
107255: LIST
107256: LIST
107257: PUSH
107258: LD_INT 34
107260: PUSH
107261: LD_INT 14
107263: PUSH
107264: EMPTY
107265: LIST
107266: LIST
107267: PUSH
107268: EMPTY
107269: LIST
107270: LIST
107271: LIST
107272: PPUSH
107273: CALL_OW 69
107277: ST_TO_ADDR
// if not tmp then
107278: LD_VAR 0 5
107282: NOT
107283: IFFALSE 107287
// exit ;
107285: GO 107444
// for i in tmp do
107287: LD_ADDR_VAR 0 3
107291: PUSH
107292: LD_VAR 0 5
107296: PUSH
107297: FOR_IN
107298: IFFALSE 107442
// begin taskList := GetTaskList ( i ) ;
107300: LD_ADDR_VAR 0 6
107304: PUSH
107305: LD_VAR 0 3
107309: PPUSH
107310: CALL_OW 437
107314: ST_TO_ADDR
// if not taskList then
107315: LD_VAR 0 6
107319: NOT
107320: IFFALSE 107324
// continue ;
107322: GO 107297
// for j = 1 to taskList do
107324: LD_ADDR_VAR 0 4
107328: PUSH
107329: DOUBLE
107330: LD_INT 1
107332: DEC
107333: ST_TO_ADDR
107334: LD_VAR 0 6
107338: PUSH
107339: FOR_TO
107340: IFFALSE 107438
// if taskList [ j ] [ 1 ] = | then
107342: LD_VAR 0 6
107346: PUSH
107347: LD_VAR 0 4
107351: ARRAY
107352: PUSH
107353: LD_INT 1
107355: ARRAY
107356: PUSH
107357: LD_STRING |
107359: EQUAL
107360: IFFALSE 107436
// begin _taskList := Delete ( taskList , 1 ) ;
107362: LD_ADDR_VAR 0 7
107366: PUSH
107367: LD_VAR 0 6
107371: PPUSH
107372: LD_INT 1
107374: PPUSH
107375: CALL_OW 3
107379: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107380: LD_VAR 0 3
107384: PPUSH
107385: LD_VAR 0 7
107389: PPUSH
107390: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107394: LD_VAR 0 3
107398: PPUSH
107399: LD_VAR 0 6
107403: PUSH
107404: LD_VAR 0 4
107408: ARRAY
107409: PUSH
107410: LD_INT 2
107412: ARRAY
107413: PPUSH
107414: LD_VAR 0 6
107418: PUSH
107419: LD_VAR 0 4
107423: ARRAY
107424: PUSH
107425: LD_INT 3
107427: ARRAY
107428: PPUSH
107429: LD_INT 8
107431: PPUSH
107432: CALL 107449 0 4
// end ;
107436: GO 107339
107438: POP
107439: POP
// end ;
107440: GO 107297
107442: POP
107443: POP
// end ; end ;
107444: LD_VAR 0 2
107448: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107449: LD_INT 0
107451: PPUSH
107452: PPUSH
107453: PPUSH
107454: PPUSH
107455: PPUSH
107456: PPUSH
107457: PPUSH
107458: PPUSH
107459: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107460: LD_VAR 0 1
107464: NOT
107465: PUSH
107466: LD_VAR 0 2
107470: PPUSH
107471: LD_VAR 0 3
107475: PPUSH
107476: CALL_OW 488
107480: NOT
107481: OR
107482: PUSH
107483: LD_VAR 0 4
107487: NOT
107488: OR
107489: IFFALSE 107493
// exit ;
107491: GO 107833
// list := [ ] ;
107493: LD_ADDR_VAR 0 13
107497: PUSH
107498: EMPTY
107499: ST_TO_ADDR
// if x - r < 0 then
107500: LD_VAR 0 2
107504: PUSH
107505: LD_VAR 0 4
107509: MINUS
107510: PUSH
107511: LD_INT 0
107513: LESS
107514: IFFALSE 107526
// min_x := 0 else
107516: LD_ADDR_VAR 0 7
107520: PUSH
107521: LD_INT 0
107523: ST_TO_ADDR
107524: GO 107542
// min_x := x - r ;
107526: LD_ADDR_VAR 0 7
107530: PUSH
107531: LD_VAR 0 2
107535: PUSH
107536: LD_VAR 0 4
107540: MINUS
107541: ST_TO_ADDR
// if y - r < 0 then
107542: LD_VAR 0 3
107546: PUSH
107547: LD_VAR 0 4
107551: MINUS
107552: PUSH
107553: LD_INT 0
107555: LESS
107556: IFFALSE 107568
// min_y := 0 else
107558: LD_ADDR_VAR 0 8
107562: PUSH
107563: LD_INT 0
107565: ST_TO_ADDR
107566: GO 107584
// min_y := y - r ;
107568: LD_ADDR_VAR 0 8
107572: PUSH
107573: LD_VAR 0 3
107577: PUSH
107578: LD_VAR 0 4
107582: MINUS
107583: ST_TO_ADDR
// max_x := x + r ;
107584: LD_ADDR_VAR 0 9
107588: PUSH
107589: LD_VAR 0 2
107593: PUSH
107594: LD_VAR 0 4
107598: PLUS
107599: ST_TO_ADDR
// max_y := y + r ;
107600: LD_ADDR_VAR 0 10
107604: PUSH
107605: LD_VAR 0 3
107609: PUSH
107610: LD_VAR 0 4
107614: PLUS
107615: ST_TO_ADDR
// for _x = min_x to max_x do
107616: LD_ADDR_VAR 0 11
107620: PUSH
107621: DOUBLE
107622: LD_VAR 0 7
107626: DEC
107627: ST_TO_ADDR
107628: LD_VAR 0 9
107632: PUSH
107633: FOR_TO
107634: IFFALSE 107751
// for _y = min_y to max_y do
107636: LD_ADDR_VAR 0 12
107640: PUSH
107641: DOUBLE
107642: LD_VAR 0 8
107646: DEC
107647: ST_TO_ADDR
107648: LD_VAR 0 10
107652: PUSH
107653: FOR_TO
107654: IFFALSE 107747
// begin if not ValidHex ( _x , _y ) then
107656: LD_VAR 0 11
107660: PPUSH
107661: LD_VAR 0 12
107665: PPUSH
107666: CALL_OW 488
107670: NOT
107671: IFFALSE 107675
// continue ;
107673: GO 107653
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107675: LD_VAR 0 11
107679: PPUSH
107680: LD_VAR 0 12
107684: PPUSH
107685: CALL_OW 351
107689: PUSH
107690: LD_VAR 0 11
107694: PPUSH
107695: LD_VAR 0 12
107699: PPUSH
107700: CALL_OW 554
107704: AND
107705: IFFALSE 107745
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107707: LD_ADDR_VAR 0 13
107711: PUSH
107712: LD_VAR 0 13
107716: PPUSH
107717: LD_VAR 0 13
107721: PUSH
107722: LD_INT 1
107724: PLUS
107725: PPUSH
107726: LD_VAR 0 11
107730: PUSH
107731: LD_VAR 0 12
107735: PUSH
107736: EMPTY
107737: LIST
107738: LIST
107739: PPUSH
107740: CALL_OW 2
107744: ST_TO_ADDR
// end ;
107745: GO 107653
107747: POP
107748: POP
107749: GO 107633
107751: POP
107752: POP
// if not list then
107753: LD_VAR 0 13
107757: NOT
107758: IFFALSE 107762
// exit ;
107760: GO 107833
// for i in list do
107762: LD_ADDR_VAR 0 6
107766: PUSH
107767: LD_VAR 0 13
107771: PUSH
107772: FOR_IN
107773: IFFALSE 107831
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107775: LD_VAR 0 1
107779: PPUSH
107780: LD_STRING M
107782: PUSH
107783: LD_VAR 0 6
107787: PUSH
107788: LD_INT 1
107790: ARRAY
107791: PUSH
107792: LD_VAR 0 6
107796: PUSH
107797: LD_INT 2
107799: ARRAY
107800: PUSH
107801: LD_INT 0
107803: PUSH
107804: LD_INT 0
107806: PUSH
107807: LD_INT 0
107809: PUSH
107810: LD_INT 0
107812: PUSH
107813: EMPTY
107814: LIST
107815: LIST
107816: LIST
107817: LIST
107818: LIST
107819: LIST
107820: LIST
107821: PUSH
107822: EMPTY
107823: LIST
107824: PPUSH
107825: CALL_OW 447
107829: GO 107772
107831: POP
107832: POP
// end ;
107833: LD_VAR 0 5
107837: RET
