// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33745 0 0
// InitNature ;
  19: CALL 33569 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10843 0 0
// PrepareRussian ;
  40: CALL 6836 0 0
// PrepareLegion ;
  44: CALL 4076 0 0
// PreparePowell ;
  48: CALL 2830 0 0
// PrepareAmerican ;
  52: CALL 1602 0 0
// Action ;
  56: CALL 14750 0 0
// MC_Start ( ) ;
  60: CALL 35857 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 57597 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 57690 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57103 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 56918 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 57597 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 57690 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 24
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 47
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 24
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 47
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: LIST
 796: LIST
 797: PPUSH
 798: CALL 56918 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 802: LD_INT 2
 804: PPUSH
 805: LD_INT 5
 807: PPUSH
 808: CALL 57103 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 812: LD_INT 2
 814: PPUSH
 815: LD_INT 0
 817: PPUSH
 818: CALL 57470 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 822: LD_INT 3
 824: PPUSH
 825: LD_INT 10
 827: PUSH
 828: LD_INT 12
 830: PUSH
 831: LD_INT 15
 833: PUSH
 834: EMPTY
 835: LIST
 836: LIST
 837: LIST
 838: PUSH
 839: LD_OWVAR 67
 843: ARRAY
 844: PPUSH
 845: LD_INT 27
 847: PPUSH
 848: CALL 56600 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 852: LD_INT 3
 854: PPUSH
 855: LD_INT 10
 857: PUSH
 858: LD_INT 11
 860: PUSH
 861: LD_INT 13
 863: PUSH
 864: LD_INT 15
 866: PUSH
 867: EMPTY
 868: LIST
 869: LIST
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL 57597 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 877: LD_INT 3
 879: PPUSH
 880: LD_INT 15
 882: PUSH
 883: EMPTY
 884: LIST
 885: PPUSH
 886: CALL 57690 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 890: LD_ADDR_EXP 128
 894: PUSH
 895: LD_EXP 128
 899: PPUSH
 900: LD_INT 3
 902: PPUSH
 903: LD_INT 22
 905: PUSH
 906: LD_INT 8
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 25
 915: PUSH
 916: LD_INT 15
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL_OW 69
 931: PPUSH
 932: CALL_OW 1
 936: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 13
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 31
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PUSH
 958: LD_INT 13
 960: PUSH
 961: LD_INT 2
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 31
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 13
 978: PUSH
 979: LD_INT 3
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: LD_INT 32
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: LIST
 992: LIST
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: PPUSH
 999: CALL 56918 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1003: LD_INT 4
1005: PPUSH
1006: LD_INT 10
1008: PUSH
1009: LD_INT 12
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: PPUSH
1016: CALL 57597 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1020: LD_INT 4
1022: PPUSH
1023: LD_INT 9
1025: PUSH
1026: EMPTY
1027: LIST
1028: PPUSH
1029: CALL 57690 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1033: LD_INT 4
1035: PPUSH
1036: LD_INT 26
1038: PUSH
1039: LD_INT 74
1041: PUSH
1042: LD_INT 107
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: LD_INT 77
1059: PUSH
1060: LD_INT 101
1062: PUSH
1063: LD_INT 4
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: PUSH
1072: LD_INT 32
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 86
1080: PUSH
1081: LD_INT 4
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: PUSH
1090: LD_INT 27
1092: PUSH
1093: LD_INT 77
1095: PUSH
1096: LD_INT 110
1098: PUSH
1099: LD_INT 3
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 27
1110: PUSH
1111: LD_INT 42
1113: PUSH
1114: LD_INT 79
1116: PUSH
1117: LD_INT 5
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 29
1128: PUSH
1129: LD_INT 86
1131: PUSH
1132: LD_INT 105
1134: PUSH
1135: LD_INT 2
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 30
1146: PUSH
1147: LD_INT 40
1149: PUSH
1150: LD_INT 75
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 80
1167: PUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 32
1182: PUSH
1183: LD_INT 75
1185: PUSH
1186: LD_INT 114
1188: PUSH
1189: LD_INT 5
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 32
1200: PUSH
1201: LD_INT 82
1203: PUSH
1204: LD_INT 110
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 62
1221: PUSH
1222: LD_INT 78
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 4
1236: PUSH
1237: LD_INT 39
1239: PUSH
1240: LD_INT 61
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 56810 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 5
1275: PUSH
1276: LD_INT 6
1278: PUSH
1279: LD_INT 7
1281: PUSH
1282: LD_INT 9
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: PPUSH
1291: CALL 58008 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 40
1300: PUSH
1301: LD_INT 75
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_INT 86
1314: PUSH
1315: LD_INT 105
1317: PUSH
1318: LD_INT 0
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: LIST
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: PPUSH
1330: CALL 57242 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1334: LD_INT 4
1336: PPUSH
1337: LD_INT 2
1339: PPUSH
1340: CALL 57470 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1344: LD_INT 4
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 57470 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1354: LD_INT 4
1356: PPUSH
1357: LD_INT 54
1359: PPUSH
1360: LD_INT 85
1362: PPUSH
1363: LD_INT 2
1365: PPUSH
1366: LD_INT 19
1368: PUSH
1369: LD_INT 16
1371: PUSH
1372: LD_INT 17
1374: PUSH
1375: LD_INT 18
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 57802 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 3
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 5
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: PUSH
1409: LD_INT 4
1411: PUSH
1412: LD_INT 1
1414: PUSH
1415: LD_INT 1
1417: PUSH
1418: LD_INT 6
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_INT 4
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 1
1435: PUSH
1436: LD_INT 7
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PUSH
1445: LD_INT 4
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 6
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: PPUSH
1469: CALL 56918 0 2
// MC_SetTame ( 4 , powellApe ) ;
1473: LD_INT 4
1475: PPUSH
1476: LD_INT 13
1478: PPUSH
1479: CALL 57421 0 2
// end ;
1483: LD_VAR 0 1
1487: RET
// every 0 0$1 trigger debug do var i , tmp ;
1488: LD_EXP 1
1492: IFFALSE 1599
1494: GO 1496
1496: DISABLE
1497: LD_INT 0
1499: PPUSH
1500: PPUSH
// begin enable ;
1501: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1502: LD_ADDR_VAR 0 2
1506: PUSH
1507: LD_INT 22
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: LD_INT 21
1522: PUSH
1523: LD_INT 3
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: LD_INT 3
1536: PUSH
1537: LD_INT 24
1539: PUSH
1540: LD_INT 999
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: LIST
1555: PPUSH
1556: CALL_OW 69
1560: ST_TO_ADDR
// if not tmp then
1561: LD_VAR 0 2
1565: NOT
1566: IFFALSE 1570
// exit ;
1568: GO 1599
// for i in tmp do
1570: LD_ADDR_VAR 0 1
1574: PUSH
1575: LD_VAR 0 2
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1597
// SetLives ( i , 1000 ) ;
1583: LD_VAR 0 1
1587: PPUSH
1588: LD_INT 1000
1590: PPUSH
1591: CALL_OW 234
1595: GO 1580
1597: POP
1598: POP
// end ; end_of_file
1599: PPOPN 2
1601: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1602: LD_INT 0
1604: PPUSH
// uc_side := 1 ;
1605: LD_ADDR_OWVAR 20
1609: PUSH
1610: LD_INT 1
1612: ST_TO_ADDR
// uc_nation := 1 ;
1613: LD_ADDR_OWVAR 21
1617: PUSH
1618: LD_INT 1
1620: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1621: LD_ADDR_EXP 36
1625: PUSH
1626: LD_STRING JMM
1628: PPUSH
1629: LD_EXP 1
1633: NOT
1634: PPUSH
1635: LD_STRING 14_
1637: PPUSH
1638: CALL 62968 0 3
1642: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1643: LD_EXP 4
1647: NOT
1648: PUSH
1649: LD_EXP 4
1653: PUSH
1654: LD_INT 1
1656: ARRAY
1657: PUSH
1658: LD_INT 1
1660: ARRAY
1661: NOT
1662: OR
1663: IFFALSE 1686
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1665: LD_INT 3
1667: PPUSH
1668: LD_INT 3
1670: PPUSH
1671: LD_INT 1
1673: PPUSH
1674: LD_INT 5
1676: PPUSH
1677: LD_INT 100
1679: PPUSH
1680: CALL 69579 0 5
1684: GO 1745
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1686: LD_EXP 4
1690: PUSH
1691: LD_INT 1
1693: ARRAY
1694: PUSH
1695: LD_INT 1
1697: ARRAY
1698: PPUSH
1699: LD_EXP 4
1703: PUSH
1704: LD_INT 2
1706: ARRAY
1707: PUSH
1708: LD_INT 1
1710: ARRAY
1711: PPUSH
1712: LD_EXP 4
1716: PUSH
1717: LD_INT 3
1719: ARRAY
1720: PUSH
1721: LD_INT 1
1723: ARRAY
1724: PPUSH
1725: LD_EXP 4
1729: PUSH
1730: LD_INT 4
1732: ARRAY
1733: PUSH
1734: LD_INT 1
1736: ARRAY
1737: PPUSH
1738: LD_INT 30
1740: PPUSH
1741: CALL 69579 0 5
// JMMNewVeh := CreateVehicle ;
1745: LD_ADDR_EXP 53
1749: PUSH
1750: CALL_OW 45
1754: ST_TO_ADDR
// if not JMMNewVeh then
1755: LD_EXP 53
1759: NOT
1760: IFFALSE 1791
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1762: LD_INT 3
1764: PPUSH
1765: LD_INT 3
1767: PPUSH
1768: LD_INT 1
1770: PPUSH
1771: LD_INT 5
1773: PPUSH
1774: LD_INT 100
1776: PPUSH
1777: CALL 69579 0 5
// JMMNewVeh := CreateVehicle ;
1781: LD_ADDR_EXP 53
1785: PUSH
1786: CALL_OW 45
1790: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1791: LD_EXP 53
1795: PPUSH
1796: LD_INT 4
1798: PPUSH
1799: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1803: LD_EXP 53
1807: PPUSH
1808: LD_INT 79
1810: PPUSH
1811: LD_INT 91
1813: PPUSH
1814: LD_INT 0
1816: PPUSH
1817: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1821: LD_EXP 36
1825: PPUSH
1826: LD_EXP 53
1830: PPUSH
1831: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1835: LD_EXP 6
1839: PUSH
1840: LD_EXP 2
1844: NOT
1845: AND
1846: IFFALSE 2104
// begin if not JMMGirlVeh then
1848: LD_EXP 5
1852: NOT
1853: IFFALSE 1876
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1855: LD_INT 3
1857: PPUSH
1858: LD_INT 3
1860: PPUSH
1861: LD_INT 1
1863: PPUSH
1864: LD_INT 9
1866: PPUSH
1867: LD_INT 100
1869: PPUSH
1870: CALL 69579 0 5
1874: GO 1935
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1876: LD_EXP 5
1880: PUSH
1881: LD_INT 1
1883: ARRAY
1884: PUSH
1885: LD_INT 1
1887: ARRAY
1888: PPUSH
1889: LD_EXP 5
1893: PUSH
1894: LD_INT 2
1896: ARRAY
1897: PUSH
1898: LD_INT 1
1900: ARRAY
1901: PPUSH
1902: LD_EXP 5
1906: PUSH
1907: LD_INT 3
1909: ARRAY
1910: PUSH
1911: LD_INT 1
1913: ARRAY
1914: PPUSH
1915: LD_EXP 5
1919: PUSH
1920: LD_INT 4
1922: ARRAY
1923: PUSH
1924: LD_INT 1
1926: ARRAY
1927: PPUSH
1928: LD_INT 30
1930: PPUSH
1931: CALL 69579 0 5
// GirlNewVeh := CreateVehicle ;
1935: LD_ADDR_EXP 54
1939: PUSH
1940: CALL_OW 45
1944: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1945: LD_EXP 54
1949: PPUSH
1950: LD_INT 4
1952: PPUSH
1953: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1957: LD_EXP 54
1961: PPUSH
1962: LD_INT 82
1964: PPUSH
1965: LD_INT 96
1967: PPUSH
1968: LD_INT 0
1970: PPUSH
1971: CALL_OW 48
// if JMMGirl = 1 then
1975: LD_EXP 7
1979: PUSH
1980: LD_INT 1
1982: EQUAL
1983: IFFALSE 2018
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1985: LD_ADDR_EXP 37
1989: PUSH
1990: LD_STRING Joan
1992: PPUSH
1993: LD_INT 1
1995: PPUSH
1996: LD_STRING 14_
1998: PPUSH
1999: CALL 62968 0 3
2003: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2004: LD_EXP 37
2008: PPUSH
2009: LD_EXP 54
2013: PPUSH
2014: CALL_OW 52
// end ; if JMMGirl = 2 then
2018: LD_EXP 7
2022: PUSH
2023: LD_INT 2
2025: EQUAL
2026: IFFALSE 2061
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2028: LD_ADDR_EXP 39
2032: PUSH
2033: LD_STRING Lisa
2035: PPUSH
2036: LD_INT 1
2038: PPUSH
2039: LD_STRING 14_
2041: PPUSH
2042: CALL 62968 0 3
2046: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2047: LD_EXP 39
2051: PPUSH
2052: LD_EXP 54
2056: PPUSH
2057: CALL_OW 52
// end ; if JMMGirl = 3 then
2061: LD_EXP 7
2065: PUSH
2066: LD_INT 3
2068: EQUAL
2069: IFFALSE 2104
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2071: LD_ADDR_EXP 51
2075: PUSH
2076: LD_STRING Connie
2078: PPUSH
2079: LD_INT 1
2081: PPUSH
2082: LD_STRING 14_
2084: PPUSH
2085: CALL 62968 0 3
2089: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2090: LD_EXP 51
2094: PPUSH
2095: LD_EXP 54
2099: PPUSH
2100: CALL_OW 52
// end ; end ; end ;
2104: LD_VAR 0 1
2108: RET
// export function PrepareStevensSquad ; var tmp ; begin
2109: LD_INT 0
2111: PPUSH
2112: PPUSH
// uc_side := 1 ;
2113: LD_ADDR_OWVAR 20
2117: PUSH
2118: LD_INT 1
2120: ST_TO_ADDR
// uc_nation := 1 ;
2121: LD_ADDR_OWVAR 21
2125: PUSH
2126: LD_INT 1
2128: ST_TO_ADDR
// tmp := [ ] ;
2129: LD_ADDR_VAR 0 2
2133: PUSH
2134: EMPTY
2135: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2136: LD_ADDR_EXP 38
2140: PUSH
2141: LD_STRING Stevens
2143: PPUSH
2144: LD_EXP 1
2148: NOT
2149: PPUSH
2150: LD_STRING 13f_
2152: PPUSH
2153: CALL 62968 0 3
2157: ST_TO_ADDR
// if not Stevens then
2158: LD_EXP 38
2162: NOT
2163: IFFALSE 2219
// begin hc_name = Baker Smith ;
2165: LD_ADDR_OWVAR 26
2169: PUSH
2170: LD_STRING Baker Smith
2172: ST_TO_ADDR
// hc_gallery =  ;
2173: LD_ADDR_OWVAR 33
2177: PUSH
2178: LD_STRING 
2180: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2181: LD_INT 1
2183: PPUSH
2184: LD_INT 10
2186: PPUSH
2187: CALL_OW 384
// Baker = CreateHuman ;
2191: LD_ADDR_EXP 52
2195: PUSH
2196: CALL_OW 44
2200: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2201: LD_ADDR_VAR 0 2
2205: PUSH
2206: LD_VAR 0 2
2210: PUSH
2211: LD_EXP 52
2215: ADD
2216: ST_TO_ADDR
// end else
2217: GO 2235
// tmp := tmp ^ Stevens ;
2219: LD_ADDR_VAR 0 2
2223: PUSH
2224: LD_VAR 0 2
2228: PUSH
2229: LD_EXP 38
2233: ADD
2234: ST_TO_ADDR
// if not Lisa then
2235: LD_EXP 39
2239: NOT
2240: IFFALSE 2286
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2242: LD_ADDR_EXP 39
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_EXP 1
2254: NOT
2255: PPUSH
2256: LD_STRING 13f_
2258: PPUSH
2259: CALL 62968 0 3
2263: ST_TO_ADDR
// if Lisa then
2264: LD_EXP 39
2268: IFFALSE 2286
// tmp := tmp ^ Lisa ;
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: LD_VAR 0 2
2279: PUSH
2280: LD_EXP 39
2284: ADD
2285: ST_TO_ADDR
// end ; if not Donaldson then
2286: LD_EXP 40
2290: NOT
2291: IFFALSE 2337
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2293: LD_ADDR_EXP 40
2297: PUSH
2298: LD_STRING Donaldson
2300: PPUSH
2301: LD_EXP 1
2305: NOT
2306: PPUSH
2307: LD_STRING 13f_
2309: PPUSH
2310: CALL 62968 0 3
2314: ST_TO_ADDR
// if Donaldson then
2315: LD_EXP 40
2319: IFFALSE 2337
// tmp := tmp ^ Donaldson ;
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: LD_VAR 0 2
2330: PUSH
2331: LD_EXP 40
2335: ADD
2336: ST_TO_ADDR
// end ; if not Bobby then
2337: LD_EXP 41
2341: NOT
2342: IFFALSE 2388
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2344: LD_ADDR_EXP 41
2348: PUSH
2349: LD_STRING Bobby
2351: PPUSH
2352: LD_EXP 1
2356: NOT
2357: PPUSH
2358: LD_STRING 13f_
2360: PPUSH
2361: CALL 62968 0 3
2365: ST_TO_ADDR
// if Bobby then
2366: LD_EXP 41
2370: IFFALSE 2388
// tmp := tmp ^ Bobby ;
2372: LD_ADDR_VAR 0 2
2376: PUSH
2377: LD_VAR 0 2
2381: PUSH
2382: LD_EXP 41
2386: ADD
2387: ST_TO_ADDR
// end ; if not Cyrus then
2388: LD_EXP 42
2392: NOT
2393: IFFALSE 2439
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2395: LD_ADDR_EXP 42
2399: PUSH
2400: LD_STRING Cyrus
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_STRING 13f_
2411: PPUSH
2412: CALL 62968 0 3
2416: ST_TO_ADDR
// if Cyrus then
2417: LD_EXP 42
2421: IFFALSE 2439
// tmp := tmp ^ Cyrus ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 42
2437: ADD
2438: ST_TO_ADDR
// end ; if not Brown then
2439: LD_EXP 44
2443: NOT
2444: IFFALSE 2490
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2446: LD_ADDR_EXP 44
2450: PUSH
2451: LD_STRING Brown
2453: PPUSH
2454: LD_EXP 1
2458: NOT
2459: PPUSH
2460: LD_STRING 13f_
2462: PPUSH
2463: CALL 62968 0 3
2467: ST_TO_ADDR
// if Brown then
2468: LD_EXP 44
2472: IFFALSE 2490
// tmp := tmp ^ Brown ;
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 2
2483: PUSH
2484: LD_EXP 44
2488: ADD
2489: ST_TO_ADDR
// end ; if not Gladstone then
2490: LD_EXP 45
2494: NOT
2495: IFFALSE 2541
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2497: LD_ADDR_EXP 45
2501: PUSH
2502: LD_STRING Gladstone
2504: PPUSH
2505: LD_EXP 1
2509: NOT
2510: PPUSH
2511: LD_STRING 13f_
2513: PPUSH
2514: CALL 62968 0 3
2518: ST_TO_ADDR
// if Gladstone then
2519: LD_EXP 45
2523: IFFALSE 2541
// tmp := tmp ^ Gladstone ;
2525: LD_ADDR_VAR 0 2
2529: PUSH
2530: LD_VAR 0 2
2534: PUSH
2535: LD_EXP 45
2539: ADD
2540: ST_TO_ADDR
// end ; if not Houten then
2541: LD_EXP 46
2545: NOT
2546: IFFALSE 2592
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2548: LD_ADDR_EXP 46
2552: PUSH
2553: LD_STRING Houten
2555: PPUSH
2556: LD_EXP 1
2560: NOT
2561: PPUSH
2562: LD_STRING 13f_
2564: PPUSH
2565: CALL 62968 0 3
2569: ST_TO_ADDR
// if Houten then
2570: LD_EXP 46
2574: IFFALSE 2592
// tmp := tmp ^ Houten ;
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: LD_VAR 0 2
2585: PUSH
2586: LD_EXP 46
2590: ADD
2591: ST_TO_ADDR
// end ; if not Cornel then
2592: LD_EXP 47
2596: NOT
2597: IFFALSE 2643
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2599: LD_ADDR_EXP 47
2603: PUSH
2604: LD_STRING Cornel
2606: PPUSH
2607: LD_EXP 1
2611: NOT
2612: PPUSH
2613: LD_STRING 13f_
2615: PPUSH
2616: CALL 62968 0 3
2620: ST_TO_ADDR
// if Cornel then
2621: LD_EXP 47
2625: IFFALSE 2643
// tmp := tmp ^ Cornel ;
2627: LD_ADDR_VAR 0 2
2631: PUSH
2632: LD_VAR 0 2
2636: PUSH
2637: LD_EXP 47
2641: ADD
2642: ST_TO_ADDR
// end ; if not Gary then
2643: LD_EXP 48
2647: NOT
2648: IFFALSE 2694
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2650: LD_ADDR_EXP 48
2654: PUSH
2655: LD_STRING Gary
2657: PPUSH
2658: LD_EXP 1
2662: NOT
2663: PPUSH
2664: LD_STRING 13f_
2666: PPUSH
2667: CALL 62968 0 3
2671: ST_TO_ADDR
// if Gary then
2672: LD_EXP 48
2676: IFFALSE 2694
// tmp := tmp ^ Gary ;
2678: LD_ADDR_VAR 0 2
2682: PUSH
2683: LD_VAR 0 2
2687: PUSH
2688: LD_EXP 48
2692: ADD
2693: ST_TO_ADDR
// end ; if not Frank then
2694: LD_EXP 49
2698: NOT
2699: IFFALSE 2745
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2701: LD_ADDR_EXP 49
2705: PUSH
2706: LD_STRING Frank
2708: PPUSH
2709: LD_EXP 1
2713: NOT
2714: PPUSH
2715: LD_STRING 13f_
2717: PPUSH
2718: CALL 62968 0 3
2722: ST_TO_ADDR
// if Frank then
2723: LD_EXP 49
2727: IFFALSE 2745
// tmp := tmp ^ Frank ;
2729: LD_ADDR_VAR 0 2
2733: PUSH
2734: LD_VAR 0 2
2738: PUSH
2739: LD_EXP 49
2743: ADD
2744: ST_TO_ADDR
// end ; if not Kikuchi then
2745: LD_EXP 50
2749: NOT
2750: IFFALSE 2796
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2752: LD_ADDR_EXP 50
2756: PUSH
2757: LD_STRING Kikuchi
2759: PPUSH
2760: LD_EXP 1
2764: NOT
2765: PPUSH
2766: LD_STRING 13f_
2768: PPUSH
2769: CALL 62968 0 3
2773: ST_TO_ADDR
// if Kikuchi then
2774: LD_EXP 50
2778: IFFALSE 2796
// tmp := tmp ^ Kikuchi ;
2780: LD_ADDR_VAR 0 2
2784: PUSH
2785: LD_VAR 0 2
2789: PUSH
2790: LD_EXP 50
2794: ADD
2795: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2796: LD_ADDR_VAR 0 2
2800: PUSH
2801: LD_VAR 0 2
2805: PUSH
2806: LD_STRING 13_other_survivors
2808: PPUSH
2809: CALL_OW 31
2813: UNION
2814: ST_TO_ADDR
// result := tmp ;
2815: LD_ADDR_VAR 0 1
2819: PUSH
2820: LD_VAR 0 2
2824: ST_TO_ADDR
// end ; end_of_file
2825: LD_VAR 0 1
2829: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2830: LD_INT 0
2832: PPUSH
2833: PPUSH
2834: PPUSH
2835: PPUSH
2836: PPUSH
2837: PPUSH
2838: PPUSH
2839: PPUSH
2840: PPUSH
2841: PPUSH
// uc_side := 4 ;
2842: LD_ADDR_OWVAR 20
2846: PUSH
2847: LD_INT 4
2849: ST_TO_ADDR
// uc_nation := 1 ;
2850: LD_ADDR_OWVAR 21
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2858: LD_INT 387
2860: PPUSH
2861: CALL_OW 274
2865: PPUSH
2866: LD_INT 1
2868: PPUSH
2869: LD_INT 2500
2871: PPUSH
2872: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2876: LD_INT 387
2878: PPUSH
2879: CALL_OW 274
2883: PPUSH
2884: LD_INT 2
2886: PPUSH
2887: LD_INT 400
2889: PPUSH
2890: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2894: LD_INT 387
2896: PPUSH
2897: CALL_OW 274
2901: PPUSH
2902: LD_INT 3
2904: PPUSH
2905: LD_INT 10
2907: PPUSH
2908: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2912: LD_ADDR_EXP 55
2916: PUSH
2917: LD_STRING Powell
2919: PPUSH
2920: CALL_OW 25
2924: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2925: LD_EXP 55
2929: PPUSH
2930: LD_INT 57
2932: PPUSH
2933: LD_INT 94
2935: PPUSH
2936: LD_INT 0
2938: PPUSH
2939: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2943: LD_EXP 55
2947: PPUSH
2948: LD_INT 58
2950: PPUSH
2951: LD_INT 94
2953: PPUSH
2954: CALL_OW 118
// vip := [ ] ;
2958: LD_ADDR_EXP 56
2962: PUSH
2963: EMPTY
2964: ST_TO_ADDR
// tmp := [ ] ;
2965: LD_ADDR_VAR 0 6
2969: PUSH
2970: EMPTY
2971: ST_TO_ADDR
// if JMMGirl <> 2 then
2972: LD_EXP 7
2976: PUSH
2977: LD_INT 2
2979: NONEQUAL
2980: IFFALSE 3004
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2982: LD_ADDR_EXP 39
2986: PUSH
2987: LD_STRING Lisa
2989: PPUSH
2990: LD_EXP 1
2994: NOT
2995: PPUSH
2996: LD_STRING 13s_
2998: PPUSH
2999: CALL 62968 0 3
3003: ST_TO_ADDR
// if Lisa then
3004: LD_EXP 39
3008: IFFALSE 3026
// tmp := tmp ^ Lisa ;
3010: LD_ADDR_VAR 0 6
3014: PUSH
3015: LD_VAR 0 6
3019: PUSH
3020: LD_EXP 39
3024: ADD
3025: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3026: LD_ADDR_EXP 40
3030: PUSH
3031: LD_STRING Donaldson
3033: PPUSH
3034: LD_EXP 1
3038: NOT
3039: PPUSH
3040: LD_STRING 13s_
3042: PPUSH
3043: CALL 62968 0 3
3047: ST_TO_ADDR
// if Donaldson then
3048: LD_EXP 40
3052: IFFALSE 3070
// tmp := tmp ^ Donaldson ;
3054: LD_ADDR_VAR 0 6
3058: PUSH
3059: LD_VAR 0 6
3063: PUSH
3064: LD_EXP 40
3068: ADD
3069: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3070: LD_ADDR_EXP 41
3074: PUSH
3075: LD_STRING Bobby
3077: PPUSH
3078: LD_EXP 1
3082: NOT
3083: PPUSH
3084: LD_STRING 13s_
3086: PPUSH
3087: CALL 62968 0 3
3091: ST_TO_ADDR
// if Bobby then
3092: LD_EXP 41
3096: IFFALSE 3114
// tmp := tmp ^ Bobby ;
3098: LD_ADDR_VAR 0 6
3102: PUSH
3103: LD_VAR 0 6
3107: PUSH
3108: LD_EXP 41
3112: ADD
3113: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3114: LD_ADDR_EXP 42
3118: PUSH
3119: LD_STRING Cyrus
3121: PPUSH
3122: LD_EXP 1
3126: NOT
3127: PPUSH
3128: LD_STRING 13s_
3130: PPUSH
3131: CALL 62968 0 3
3135: ST_TO_ADDR
// if Cyrus then
3136: LD_EXP 42
3140: IFFALSE 3158
// tmp := tmp ^ Cyrus ;
3142: LD_ADDR_VAR 0 6
3146: PUSH
3147: LD_VAR 0 6
3151: PUSH
3152: LD_EXP 42
3156: ADD
3157: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3158: LD_ADDR_EXP 43
3162: PUSH
3163: LD_STRING Denis
3165: PPUSH
3166: LD_EXP 1
3170: NOT
3171: PPUSH
3172: LD_STRING 13s_
3174: PPUSH
3175: CALL 62968 0 3
3179: ST_TO_ADDR
// if not Denis then
3180: LD_EXP 43
3184: NOT
3185: IFFALSE 3209
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3187: LD_ADDR_EXP 43
3191: PUSH
3192: LD_STRING Denis
3194: PPUSH
3195: LD_EXP 1
3199: NOT
3200: PPUSH
3201: LD_STRING 13f_
3203: PPUSH
3204: CALL 62968 0 3
3208: ST_TO_ADDR
// if Denis then
3209: LD_EXP 43
3213: IFFALSE 3231
// tmp := tmp ^ Denis ;
3215: LD_ADDR_VAR 0 6
3219: PUSH
3220: LD_VAR 0 6
3224: PUSH
3225: LD_EXP 43
3229: ADD
3230: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3231: LD_ADDR_EXP 44
3235: PUSH
3236: LD_STRING Brown
3238: PPUSH
3239: LD_EXP 1
3243: NOT
3244: PPUSH
3245: LD_STRING 13s_
3247: PPUSH
3248: CALL 62968 0 3
3252: ST_TO_ADDR
// if Brown then
3253: LD_EXP 44
3257: IFFALSE 3275
// tmp := tmp ^ Brown ;
3259: LD_ADDR_VAR 0 6
3263: PUSH
3264: LD_VAR 0 6
3268: PUSH
3269: LD_EXP 44
3273: ADD
3274: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3275: LD_ADDR_EXP 45
3279: PUSH
3280: LD_STRING Gladstone
3282: PPUSH
3283: LD_EXP 1
3287: NOT
3288: PPUSH
3289: LD_STRING 13s_
3291: PPUSH
3292: CALL 62968 0 3
3296: ST_TO_ADDR
// if Gladstone then
3297: LD_EXP 45
3301: IFFALSE 3319
// tmp := tmp ^ Gladstone ;
3303: LD_ADDR_VAR 0 6
3307: PUSH
3308: LD_VAR 0 6
3312: PUSH
3313: LD_EXP 45
3317: ADD
3318: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3319: LD_ADDR_EXP 46
3323: PUSH
3324: LD_STRING Houten
3326: PPUSH
3327: LD_EXP 1
3331: NOT
3332: PPUSH
3333: LD_STRING 13s_
3335: PPUSH
3336: CALL 62968 0 3
3340: ST_TO_ADDR
// if Houten then
3341: LD_EXP 46
3345: IFFALSE 3363
// tmp := tmp ^ Houten ;
3347: LD_ADDR_VAR 0 6
3351: PUSH
3352: LD_VAR 0 6
3356: PUSH
3357: LD_EXP 46
3361: ADD
3362: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3363: LD_ADDR_EXP 47
3367: PUSH
3368: LD_STRING Cornel
3370: PPUSH
3371: LD_EXP 1
3375: NOT
3376: PPUSH
3377: LD_STRING 13s_
3379: PPUSH
3380: CALL 62968 0 3
3384: ST_TO_ADDR
// if Cornel then
3385: LD_EXP 47
3389: IFFALSE 3407
// tmp := tmp ^ Cornel ;
3391: LD_ADDR_VAR 0 6
3395: PUSH
3396: LD_VAR 0 6
3400: PUSH
3401: LD_EXP 47
3405: ADD
3406: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3407: LD_ADDR_EXP 48
3411: PUSH
3412: LD_STRING Gary
3414: PPUSH
3415: LD_EXP 1
3419: NOT
3420: PPUSH
3421: LD_STRING 13s_
3423: PPUSH
3424: CALL 62968 0 3
3428: ST_TO_ADDR
// if Gary then
3429: LD_EXP 48
3433: IFFALSE 3451
// tmp := tmp ^ Gary ;
3435: LD_ADDR_VAR 0 6
3439: PUSH
3440: LD_VAR 0 6
3444: PUSH
3445: LD_EXP 48
3449: ADD
3450: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3451: LD_ADDR_EXP 49
3455: PUSH
3456: LD_STRING Frank
3458: PPUSH
3459: LD_EXP 1
3463: NOT
3464: PPUSH
3465: LD_STRING 13s_
3467: PPUSH
3468: CALL 62968 0 3
3472: ST_TO_ADDR
// if Frank then
3473: LD_EXP 49
3477: IFFALSE 3495
// tmp := tmp ^ Frank ;
3479: LD_ADDR_VAR 0 6
3483: PUSH
3484: LD_VAR 0 6
3488: PUSH
3489: LD_EXP 49
3493: ADD
3494: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3495: LD_ADDR_EXP 50
3499: PUSH
3500: LD_STRING Kikuchi
3502: PPUSH
3503: LD_EXP 1
3507: NOT
3508: PPUSH
3509: LD_STRING 13s_
3511: PPUSH
3512: CALL 62968 0 3
3516: ST_TO_ADDR
// if Kikuchi then
3517: LD_EXP 50
3521: IFFALSE 3539
// tmp := tmp ^ Kikuchi ;
3523: LD_ADDR_VAR 0 6
3527: PUSH
3528: LD_VAR 0 6
3532: PUSH
3533: LD_EXP 50
3537: ADD
3538: ST_TO_ADDR
// vip := tmp ;
3539: LD_ADDR_EXP 56
3543: PUSH
3544: LD_VAR 0 6
3548: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3549: LD_ADDR_VAR 0 6
3553: PUSH
3554: LD_VAR 0 6
3558: PUSH
3559: LD_STRING 13s_others
3561: PPUSH
3562: CALL_OW 31
3566: UNION
3567: ST_TO_ADDR
// if tmp < 20 then
3568: LD_VAR 0 6
3572: PUSH
3573: LD_INT 20
3575: LESS
3576: IFFALSE 3643
// for i = 1 to 20 - tmp do
3578: LD_ADDR_VAR 0 2
3582: PUSH
3583: DOUBLE
3584: LD_INT 1
3586: DEC
3587: ST_TO_ADDR
3588: LD_INT 20
3590: PUSH
3591: LD_VAR 0 6
3595: MINUS
3596: PUSH
3597: FOR_TO
3598: IFFALSE 3641
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3600: LD_INT 1
3602: PPUSH
3603: LD_VAR 0 2
3607: PUSH
3608: LD_INT 4
3610: MOD
3611: PUSH
3612: LD_INT 1
3614: PLUS
3615: PPUSH
3616: LD_INT 5
3618: PPUSH
3619: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3623: LD_ADDR_VAR 0 6
3627: PUSH
3628: LD_VAR 0 6
3632: PUSH
3633: CALL_OW 44
3637: ADD
3638: ST_TO_ADDR
// end ;
3639: GO 3597
3641: POP
3642: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3643: LD_ADDR_VAR 0 7
3647: PUSH
3648: LD_INT 22
3650: PUSH
3651: LD_INT 4
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: PUSH
3658: LD_INT 30
3660: PUSH
3661: LD_INT 0
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: PUSH
3668: EMPTY
3669: LIST
3670: LIST
3671: PPUSH
3672: CALL_OW 69
3676: PUSH
3677: LD_INT 1
3679: ARRAY
3680: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 8
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 6
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 9
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 4
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 10
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 2
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// for i in tmp do
3795: LD_ADDR_VAR 0 2
3799: PUSH
3800: LD_VAR 0 6
3804: PUSH
3805: FOR_IN
3806: IFFALSE 3932
// begin cl := GetClass ( i ) ;
3808: LD_ADDR_VAR 0 5
3812: PUSH
3813: LD_VAR 0 2
3817: PPUSH
3818: CALL_OW 257
3822: ST_TO_ADDR
// if cl > 4 then
3823: LD_VAR 0 5
3827: PUSH
3828: LD_INT 4
3830: GREATER
3831: IFFALSE 3841
// cl := 1 ;
3833: LD_ADDR_VAR 0 5
3837: PUSH
3838: LD_INT 1
3840: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3841: LD_ADDR_VAR 0 3
3845: PUSH
3846: LD_VAR 0 9
3850: PUSH
3851: LD_VAR 0 7
3855: PUSH
3856: LD_VAR 0 10
3860: PUSH
3861: LD_VAR 0 8
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: PUSH
3872: LD_VAR 0 5
3876: ARRAY
3877: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3878: LD_VAR 0 3
3882: PPUSH
3883: CALL_OW 313
3887: PUSH
3888: LD_INT 5
3890: LESS
3891: IFFALSE 3909
// PlaceHumanInUnit ( i , b ) else
3893: LD_VAR 0 2
3897: PPUSH
3898: LD_VAR 0 3
3902: PPUSH
3903: CALL_OW 52
3907: GO 3930
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3909: LD_VAR 0 2
3913: PPUSH
3914: LD_INT 58
3916: PPUSH
3917: LD_INT 91
3919: PPUSH
3920: LD_INT 6
3922: PPUSH
3923: LD_INT 0
3925: PPUSH
3926: CALL_OW 50
// end ;
3930: GO 3805
3932: POP
3933: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3934: LD_INT 2
3936: PPUSH
3937: LD_INT 1
3939: PPUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_INT 12
3945: PPUSH
3946: LD_INT 100
3948: PPUSH
3949: CALL 69579 0 5
// veh := CreateVehicle ;
3953: LD_ADDR_VAR 0 4
3957: PUSH
3958: CALL_OW 45
3962: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3963: LD_VAR 0 4
3967: PPUSH
3968: LD_INT 4
3970: PPUSH
3971: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3975: LD_VAR 0 4
3979: PPUSH
3980: LD_INT 49
3982: PPUSH
3983: LD_INT 88
3985: PPUSH
3986: LD_INT 0
3988: PPUSH
3989: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3993: LD_VAR 0 4
3997: PPUSH
3998: LD_INT 1
4000: PPUSH
4001: LD_INT 100
4003: PPUSH
4004: CALL_OW 290
// uc_side := 0 ;
4008: LD_ADDR_OWVAR 20
4012: PUSH
4013: LD_INT 0
4015: ST_TO_ADDR
// uc_nation := 0 ;
4016: LD_ADDR_OWVAR 21
4020: PUSH
4021: LD_INT 0
4023: ST_TO_ADDR
// for i = 1 to 4 do
4024: LD_ADDR_VAR 0 2
4028: PUSH
4029: DOUBLE
4030: LD_INT 1
4032: DEC
4033: ST_TO_ADDR
4034: LD_INT 4
4036: PUSH
4037: FOR_TO
4038: IFFALSE 4069
// begin InitHc ;
4040: CALL_OW 19
// hc_class := class_apeman ;
4044: LD_ADDR_OWVAR 28
4048: PUSH
4049: LD_INT 12
4051: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4052: CALL_OW 44
4056: PPUSH
4057: LD_INT 13
4059: PPUSH
4060: LD_INT 0
4062: PPUSH
4063: CALL_OW 49
// end ;
4067: GO 4037
4069: POP
4070: POP
// end ; end_of_file
4071: LD_VAR 0 1
4075: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4076: LD_INT 0
4078: PPUSH
4079: PPUSH
4080: PPUSH
4081: PPUSH
4082: PPUSH
// side := 8 ;
4083: LD_ADDR_VAR 0 3
4087: PUSH
4088: LD_INT 8
4090: ST_TO_ADDR
// uc_side := side ;
4091: LD_ADDR_OWVAR 20
4095: PUSH
4096: LD_VAR 0 3
4100: ST_TO_ADDR
// uc_nation := 2 ;
4101: LD_ADDR_OWVAR 21
4105: PUSH
4106: LD_INT 2
4108: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4109: LD_ADDR_VAR 0 2
4113: PUSH
4114: LD_INT 22
4116: PUSH
4117: LD_VAR 0 3
4121: PUSH
4122: EMPTY
4123: LIST
4124: LIST
4125: PUSH
4126: LD_INT 21
4128: PUSH
4129: LD_INT 3
4131: PUSH
4132: EMPTY
4133: LIST
4134: LIST
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: PPUSH
4140: CALL_OW 69
4144: PUSH
4145: FOR_IN
4146: IFFALSE 4162
// SetBLevel ( i , 10 ) ;
4148: LD_VAR 0 2
4152: PPUSH
4153: LD_INT 10
4155: PPUSH
4156: CALL_OW 241
4160: GO 4145
4162: POP
4163: POP
// if KurtStatus then
4164: LD_EXP 3
4168: IFFALSE 4191
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4170: LD_ADDR_EXP 57
4174: PUSH
4175: LD_STRING Kurt
4177: PPUSH
4178: LD_INT 0
4180: PPUSH
4181: LD_STRING 
4183: PPUSH
4184: CALL 62968 0 3
4188: ST_TO_ADDR
4189: GO 4213
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4191: LD_ADDR_EXP 57
4195: PUSH
4196: LD_STRING AltKurt
4198: PPUSH
4199: LD_EXP 1
4203: NOT
4204: PPUSH
4205: LD_STRING 
4207: PPUSH
4208: CALL 62968 0 3
4212: ST_TO_ADDR
// if not Kurt then
4213: LD_EXP 57
4217: NOT
4218: IFFALSE 4244
// begin InitHc ;
4220: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4224: LD_INT 1
4226: PPUSH
4227: LD_INT 10
4229: PPUSH
4230: CALL_OW 381
// Kurt := CreateHuman ;
4234: LD_ADDR_EXP 57
4238: PUSH
4239: CALL_OW 44
4243: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4244: LD_EXP 57
4248: PPUSH
4249: LD_INT 324
4251: PPUSH
4252: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4256: LD_ADDR_EXP 58
4260: PUSH
4261: LD_STRING Kozlov
4263: PPUSH
4264: LD_INT 0
4266: PPUSH
4267: LD_STRING 
4269: PPUSH
4270: CALL 62968 0 3
4274: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4275: LD_EXP 58
4279: PPUSH
4280: LD_INT 22
4282: PUSH
4283: LD_INT 8
4285: PUSH
4286: EMPTY
4287: LIST
4288: LIST
4289: PUSH
4290: LD_INT 23
4292: PUSH
4293: LD_INT 3
4295: PUSH
4296: EMPTY
4297: LIST
4298: LIST
4299: PUSH
4300: LD_INT 30
4302: PUSH
4303: LD_INT 8
4305: PUSH
4306: EMPTY
4307: LIST
4308: LIST
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: LIST
4314: PPUSH
4315: CALL_OW 69
4319: PUSH
4320: LD_INT 1
4322: ARRAY
4323: PPUSH
4324: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4328: LD_EXP 58
4332: PPUSH
4333: LD_INT 3
4335: PPUSH
4336: LD_INT 10
4338: PPUSH
4339: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4343: LD_ADDR_VAR 0 5
4347: PUSH
4348: LD_INT 22
4350: PUSH
4351: LD_VAR 0 3
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 30
4362: PUSH
4363: LD_INT 32
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: LD_INT 58
4372: PUSH
4373: EMPTY
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: LIST
4380: PPUSH
4381: CALL_OW 69
4385: ST_TO_ADDR
// for i = 1 to 10 do
4386: LD_ADDR_VAR 0 2
4390: PUSH
4391: DOUBLE
4392: LD_INT 1
4394: DEC
4395: ST_TO_ADDR
4396: LD_INT 10
4398: PUSH
4399: FOR_TO
4400: IFFALSE 4472
// begin uc_nation := nation_nature ;
4402: LD_ADDR_OWVAR 21
4406: PUSH
4407: LD_INT 0
4409: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4410: LD_ADDR_OWVAR 28
4414: PUSH
4415: LD_INT 15
4417: ST_TO_ADDR
// hc_gallery :=  ;
4418: LD_ADDR_OWVAR 33
4422: PUSH
4423: LD_STRING 
4425: ST_TO_ADDR
// hc_name :=  ;
4426: LD_ADDR_OWVAR 26
4430: PUSH
4431: LD_STRING 
4433: ST_TO_ADDR
// un := CreateHuman ;
4434: LD_ADDR_VAR 0 4
4438: PUSH
4439: CALL_OW 44
4443: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4444: LD_VAR 0 4
4448: PPUSH
4449: LD_VAR 0 5
4453: PUSH
4454: LD_VAR 0 5
4458: PUSH
4459: LD_VAR 0 2
4463: MINUS
4464: ARRAY
4465: PPUSH
4466: CALL_OW 52
// end ;
4470: GO 4399
4472: POP
4473: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4474: LD_ADDR_VAR 0 5
4478: PUSH
4479: LD_STRING 12_kurt_squad
4481: PPUSH
4482: CALL_OW 31
4486: ST_TO_ADDR
// if tmp then
4487: LD_VAR 0 5
4491: IFFALSE 4525
// for i in tmp do
4493: LD_ADDR_VAR 0 2
4497: PUSH
4498: LD_VAR 0 5
4502: PUSH
4503: FOR_IN
4504: IFFALSE 4523
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4506: LD_VAR 0 2
4510: PPUSH
4511: LD_INT 5
4513: PPUSH
4514: LD_INT 0
4516: PPUSH
4517: CALL_OW 49
4521: GO 4503
4523: POP
4524: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4525: LD_INT 324
4527: PPUSH
4528: LD_INT 5
4530: PPUSH
4531: LD_STRING 
4533: PPUSH
4534: LD_INT 8
4536: PUSH
4537: LD_INT 9
4539: PUSH
4540: LD_INT 10
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: LIST
4547: PUSH
4548: LD_OWVAR 67
4552: ARRAY
4553: PPUSH
4554: LD_INT 3000
4556: PUSH
4557: LD_INT 500
4559: PUSH
4560: LD_INT 150
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: LIST
4567: PPUSH
4568: LD_INT 16
4570: PUSH
4571: LD_INT 6
4573: PUSH
4574: LD_INT 6
4576: PUSH
4577: LD_INT 8
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: LIST
4584: LIST
4585: PPUSH
4586: CALL 72988 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4590: LD_ADDR_EXP 99
4594: PUSH
4595: LD_EXP 99
4599: PPUSH
4600: LD_INT 3
4602: PPUSH
4603: LD_INT 22
4605: PUSH
4606: LD_VAR 0 3
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: PUSH
4615: LD_INT 23
4617: PUSH
4618: LD_INT 2
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: PUSH
4625: LD_INT 3
4627: PUSH
4628: LD_INT 21
4630: PUSH
4631: LD_INT 2
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: PUSH
4638: EMPTY
4639: LIST
4640: LIST
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: LIST
4646: PPUSH
4647: CALL_OW 69
4651: PUSH
4652: LD_EXP 57
4656: DIFF
4657: PPUSH
4658: CALL_OW 1
4662: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4663: LD_INT 1
4665: PPUSH
4666: LD_INT 7
4668: PPUSH
4669: CALL_OW 383
// Friend := CreateHuman ;
4673: LD_ADDR_EXP 59
4677: PUSH
4678: CALL_OW 44
4682: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4683: LD_INT 14
4685: PPUSH
4686: LD_INT 3
4688: PPUSH
4689: LD_INT 1
4691: PPUSH
4692: LD_INT 29
4694: PPUSH
4695: LD_INT 100
4697: PPUSH
4698: CALL 69579 0 5
// powellBomb := CreateVehicle ;
4702: LD_ADDR_EXP 60
4706: PUSH
4707: CALL_OW 45
4711: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4712: LD_EXP 60
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: LD_INT 51
4722: PPUSH
4723: LD_INT 0
4725: PPUSH
4726: CALL_OW 48
// end ;
4730: LD_VAR 0 1
4734: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4735: LD_INT 0
4737: PPUSH
4738: PPUSH
4739: PPUSH
// if IsLive ( kozlov_fac ) then
4740: LD_INT 332
4742: PPUSH
4743: CALL_OW 300
4747: IFFALSE 4751
// exit ;
4749: GO 5318
// ComExitBuilding ( Kozlov ) ;
4751: LD_EXP 58
4755: PPUSH
4756: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4760: LD_EXP 58
4764: PPUSH
4765: CALL_OW 257
4769: PUSH
4770: LD_INT 2
4772: NONEQUAL
4773: IFFALSE 4808
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4775: LD_EXP 58
4779: PPUSH
4780: LD_INT 324
4782: PPUSH
4783: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4787: LD_EXP 58
4791: PPUSH
4792: LD_INT 2
4794: PPUSH
4795: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4799: LD_EXP 58
4803: PPUSH
4804: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4808: LD_EXP 58
4812: PPUSH
4813: LD_INT 2
4815: PPUSH
4816: LD_INT 93
4818: PPUSH
4819: LD_INT 32
4821: PPUSH
4822: LD_INT 3
4824: PPUSH
4825: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4829: LD_INT 35
4831: PPUSH
4832: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4836: LD_INT 22
4838: PUSH
4839: LD_INT 8
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: PUSH
4846: LD_INT 30
4848: PUSH
4849: LD_INT 3
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PUSH
4856: LD_INT 23
4858: PUSH
4859: LD_INT 3
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 57
4868: PUSH
4869: EMPTY
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: IFFALSE 4829
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4884: LD_ADDR_VAR 0 2
4888: PUSH
4889: LD_INT 22
4891: PUSH
4892: LD_INT 8
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PUSH
4899: LD_INT 30
4901: PUSH
4902: LD_INT 3
4904: PUSH
4905: EMPTY
4906: LIST
4907: LIST
4908: PUSH
4909: LD_INT 23
4911: PUSH
4912: LD_INT 3
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: PUSH
4919: LD_INT 57
4921: PUSH
4922: EMPTY
4923: LIST
4924: PUSH
4925: EMPTY
4926: LIST
4927: LIST
4928: LIST
4929: LIST
4930: PPUSH
4931: CALL_OW 69
4935: PUSH
4936: LD_INT 1
4938: ARRAY
4939: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4940: LD_INT 22
4942: PUSH
4943: LD_INT 8
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: PUSH
4950: LD_INT 23
4952: PUSH
4953: LD_INT 3
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PUSH
4960: LD_INT 30
4962: PUSH
4963: LD_INT 21
4965: PUSH
4966: EMPTY
4967: LIST
4968: LIST
4969: PUSH
4970: EMPTY
4971: LIST
4972: LIST
4973: LIST
4974: PPUSH
4975: CALL_OW 69
4979: NOT
4980: IFFALSE 5058
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4982: LD_EXP 58
4986: PPUSH
4987: LD_INT 21
4989: PPUSH
4990: LD_INT 97
4992: PPUSH
4993: LD_INT 36
4995: PPUSH
4996: LD_INT 5
4998: PPUSH
4999: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5003: LD_INT 35
5005: PPUSH
5006: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5010: LD_INT 22
5012: PUSH
5013: LD_INT 8
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PUSH
5020: LD_INT 23
5022: PUSH
5023: LD_INT 3
5025: PUSH
5026: EMPTY
5027: LIST
5028: LIST
5029: PUSH
5030: LD_INT 30
5032: PUSH
5033: LD_INT 21
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PUSH
5040: LD_INT 57
5042: PUSH
5043: EMPTY
5044: LIST
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: LIST
5050: LIST
5051: PPUSH
5052: CALL_OW 69
5056: IFFALSE 5003
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5058: LD_INT 22
5060: PUSH
5061: LD_INT 8
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 23
5070: PUSH
5071: LD_INT 3
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 30
5080: PUSH
5081: LD_INT 18
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: PUSH
5088: EMPTY
5089: LIST
5090: LIST
5091: LIST
5092: PPUSH
5093: CALL_OW 69
5097: NOT
5098: IFFALSE 5176
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5100: LD_EXP 58
5104: PPUSH
5105: LD_INT 18
5107: PPUSH
5108: LD_INT 89
5110: PPUSH
5111: LD_INT 32
5113: PPUSH
5114: LD_INT 1
5116: PPUSH
5117: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5121: LD_INT 35
5123: PPUSH
5124: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5128: LD_INT 22
5130: PUSH
5131: LD_INT 8
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PUSH
5138: LD_INT 23
5140: PUSH
5141: LD_INT 3
5143: PUSH
5144: EMPTY
5145: LIST
5146: LIST
5147: PUSH
5148: LD_INT 30
5150: PUSH
5151: LD_INT 18
5153: PUSH
5154: EMPTY
5155: LIST
5156: LIST
5157: PUSH
5158: LD_INT 57
5160: PUSH
5161: EMPTY
5162: LIST
5163: PUSH
5164: EMPTY
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: PPUSH
5170: CALL_OW 69
5174: IFFALSE 5121
// end ; lab := kozlov_lab ;
5176: LD_ADDR_VAR 0 3
5180: PUSH
5181: LD_INT 336
5183: ST_TO_ADDR
// if not lab then
5184: LD_VAR 0 3
5188: NOT
5189: IFFALSE 5193
// exit ;
5191: GO 5318
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5193: LD_EXP 58
5197: PPUSH
5198: LD_VAR 0 3
5202: PUSH
5203: LD_INT 1
5205: ARRAY
5206: PPUSH
5207: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5211: LD_EXP 58
5215: PPUSH
5216: LD_INT 4
5218: PPUSH
5219: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5223: LD_VAR 0 3
5227: PUSH
5228: LD_INT 1
5230: ARRAY
5231: PPUSH
5232: LD_INT 25
5234: PPUSH
5235: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5239: LD_INT 35
5241: PPUSH
5242: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5246: LD_INT 25
5248: PPUSH
5249: LD_INT 8
5251: PPUSH
5252: CALL_OW 321
5256: PUSH
5257: LD_INT 2
5259: EQUAL
5260: IFFALSE 5239
// ComExitBuilding ( Kozlov ) ;
5262: LD_EXP 58
5266: PPUSH
5267: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5271: LD_EXP 58
5275: PPUSH
5276: LD_VAR 0 2
5280: PPUSH
5281: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5285: LD_EXP 58
5289: PPUSH
5290: LD_INT 3
5292: PPUSH
5293: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5297: LD_VAR 0 2
5301: PPUSH
5302: LD_INT 23
5304: PPUSH
5305: LD_INT 3
5307: PPUSH
5308: LD_INT 1
5310: PPUSH
5311: LD_INT 48
5313: PPUSH
5314: CALL_OW 125
// end ;
5318: LD_VAR 0 1
5322: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5323: LD_EXP 22
5327: NOT
5328: PUSH
5329: LD_EXP 15
5333: PUSH
5334: LD_INT 6
5336: GREATEREQUAL
5337: AND
5338: IFFALSE 5419
5340: GO 5342
5342: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 3
5348: PPUSH
5349: CALL 57103 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 14
5358: PUSH
5359: LD_INT 1
5361: PUSH
5362: LD_INT 1
5364: PUSH
5365: LD_INT 28
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: LIST
5372: LIST
5373: PUSH
5374: LD_INT 14
5376: PUSH
5377: LD_INT 1
5379: PUSH
5380: LD_INT 1
5382: PUSH
5383: LD_INT 28
5385: PUSH
5386: EMPTY
5387: LIST
5388: LIST
5389: LIST
5390: LIST
5391: PUSH
5392: LD_INT 14
5394: PUSH
5395: LD_INT 1
5397: PUSH
5398: LD_INT 1
5400: PUSH
5401: LD_INT 28
5403: PUSH
5404: EMPTY
5405: LIST
5406: LIST
5407: LIST
5408: LIST
5409: PUSH
5410: EMPTY
5411: LIST
5412: LIST
5413: LIST
5414: PPUSH
5415: CALL 56966 0 2
// end ;
5419: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5420: LD_EXP 22
5424: NOT
5425: PUSH
5426: LD_EXP 15
5430: PUSH
5431: LD_INT 6
5433: GREATEREQUAL
5434: AND
5435: PUSH
5436: LD_INT 3
5438: PPUSH
5439: LD_INT 1
5441: PPUSH
5442: CALL 58321 0 2
5446: NOT
5447: AND
5448: IFFALSE 6288
5450: GO 5452
5452: DISABLE
5453: LD_INT 0
5455: PPUSH
5456: PPUSH
5457: PPUSH
// begin enable ;
5458: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5459: LD_INT 22
5461: PUSH
5462: LD_INT 8
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 23
5471: PUSH
5472: LD_INT 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 30
5481: PUSH
5482: LD_INT 3
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: LIST
5493: PPUSH
5494: CALL_OW 69
5498: NOT
5499: IFFALSE 5503
// exit ;
5501: GO 6288
// if Prob ( 40 ) then
5503: LD_INT 40
5505: PPUSH
5506: CALL_OW 13
5510: IFFALSE 5637
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5512: LD_INT 3
5514: PPUSH
5515: LD_INT 14
5517: PUSH
5518: LD_INT 1
5520: PUSH
5521: LD_INT 2
5523: PUSH
5524: LD_INT 28
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: LIST
5532: PUSH
5533: LD_INT 14
5535: PUSH
5536: LD_INT 1
5538: PUSH
5539: LD_INT 2
5541: PUSH
5542: LD_INT 28
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: LIST
5549: LIST
5550: PUSH
5551: LD_INT 14
5553: PUSH
5554: LD_INT 1
5556: PUSH
5557: LD_INT 2
5559: PUSH
5560: LD_INT 28
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: PUSH
5569: LD_INT 14
5571: PUSH
5572: LD_INT 1
5574: PUSH
5575: LD_INT 2
5577: PUSH
5578: LD_INT 28
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: LIST
5586: PUSH
5587: LD_INT 14
5589: PUSH
5590: LD_INT 1
5592: PUSH
5593: LD_INT 2
5595: PUSH
5596: LD_INT 28
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 14
5607: PUSH
5608: LD_INT 1
5610: PUSH
5611: LD_INT 2
5613: PUSH
5614: LD_INT 26
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: LIST
5621: LIST
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: PPUSH
5631: CALL 56966 0 2
// end else
5635: GO 5828
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5637: LD_INT 3
5639: PPUSH
5640: LD_INT 14
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 27
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: LD_INT 26
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: LIST
5662: PUSH
5663: LD_OWVAR 67
5667: ARRAY
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 14
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: LD_INT 2
5683: PUSH
5684: LD_INT 27
5686: PUSH
5687: LD_INT 26
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: EMPTY
5694: LIST
5695: LIST
5696: LIST
5697: PUSH
5698: LD_OWVAR 67
5702: ARRAY
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: LD_INT 26
5724: PUSH
5725: LD_INT 29
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: PUSH
5733: LD_OWVAR 67
5737: ARRAY
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: PUSH
5745: LD_INT 13
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 26
5756: PUSH
5757: LD_INT 29
5759: PUSH
5760: LD_INT 29
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 13
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 29
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 14
5800: PUSH
5801: LD_INT 1
5803: PUSH
5804: LD_INT 2
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: EMPTY
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PPUSH
5824: CALL 56966 0 2
// end ; repeat wait ( 0 0$1 ) ;
5828: LD_INT 35
5830: PPUSH
5831: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5835: LD_INT 3
5837: PPUSH
5838: LD_INT 1
5840: PPUSH
5841: CALL 58321 0 2
5845: PUSH
5846: LD_INT 6
5848: GREATEREQUAL
5849: IFFALSE 5828
// wait ( 0 0$30 ) ;
5851: LD_INT 1050
5853: PPUSH
5854: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5858: LD_ADDR_VAR 0 2
5862: PUSH
5863: LD_INT 3
5865: PPUSH
5866: LD_INT 1
5868: PPUSH
5869: CALL 58321 0 2
5873: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5874: LD_ADDR_EXP 118
5878: PUSH
5879: LD_EXP 118
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: LD_EXP 118
5891: PUSH
5892: LD_INT 3
5894: ARRAY
5895: PUSH
5896: LD_VAR 0 2
5900: DIFF
5901: PPUSH
5902: CALL_OW 1
5906: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5907: LD_ADDR_VAR 0 3
5911: PUSH
5912: LD_INT 0
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: CALL_OW 12
5922: ST_TO_ADDR
// if target then
5923: LD_VAR 0 3
5927: IFFALSE 6055
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5929: LD_ADDR_VAR 0 2
5933: PUSH
5934: LD_VAR 0 2
5938: PPUSH
5939: LD_INT 24
5941: PUSH
5942: LD_INT 250
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: PPUSH
5949: CALL_OW 72
5953: ST_TO_ADDR
// for i in tmp do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: LD_VAR 0 2
5963: PUSH
5964: FOR_IN
5965: IFFALSE 6005
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
5967: LD_VAR 0 1
5971: PPUSH
5972: LD_INT 89
5974: PPUSH
5975: LD_INT 71
5977: PPUSH
5978: CALL_OW 297
5982: PUSH
5983: LD_INT 9
5985: GREATER
5986: IFFALSE 6003
// ComMoveXY ( i , 89 , 71 ) ;
5988: LD_VAR 0 1
5992: PPUSH
5993: LD_INT 89
5995: PPUSH
5996: LD_INT 71
5998: PPUSH
5999: CALL_OW 111
6003: GO 5964
6005: POP
6006: POP
// wait ( 0 0$1 ) ;
6007: LD_INT 35
6009: PPUSH
6010: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6014: LD_VAR 0 2
6018: PPUSH
6019: LD_INT 92
6021: PUSH
6022: LD_INT 89
6024: PUSH
6025: LD_INT 71
6027: PUSH
6028: LD_INT 9
6030: PUSH
6031: EMPTY
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: PPUSH
6037: CALL_OW 72
6041: PUSH
6042: LD_VAR 0 2
6046: PUSH
6047: LD_INT 1
6049: MINUS
6050: GREATEREQUAL
6051: IFFALSE 5929
// end else
6053: GO 6179
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6055: LD_ADDR_VAR 0 2
6059: PUSH
6060: LD_VAR 0 2
6064: PPUSH
6065: LD_INT 24
6067: PUSH
6068: LD_INT 250
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: ST_TO_ADDR
// for i in tmp do
6080: LD_ADDR_VAR 0 1
6084: PUSH
6085: LD_VAR 0 2
6089: PUSH
6090: FOR_IN
6091: IFFALSE 6131
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 125
6100: PPUSH
6101: LD_INT 129
6103: PPUSH
6104: CALL_OW 297
6108: PUSH
6109: LD_INT 9
6111: GREATER
6112: IFFALSE 6129
// ComMoveXY ( i , 125 , 129 ) ;
6114: LD_VAR 0 1
6118: PPUSH
6119: LD_INT 125
6121: PPUSH
6122: LD_INT 129
6124: PPUSH
6125: CALL_OW 111
6129: GO 6090
6131: POP
6132: POP
// wait ( 0 0$1 ) ;
6133: LD_INT 35
6135: PPUSH
6136: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6140: LD_VAR 0 2
6144: PPUSH
6145: LD_INT 92
6147: PUSH
6148: LD_INT 125
6150: PUSH
6151: LD_INT 129
6153: PUSH
6154: LD_INT 9
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: PPUSH
6163: CALL_OW 72
6167: PUSH
6168: LD_VAR 0 2
6172: PUSH
6173: LD_INT 1
6175: MINUS
6176: GREATEREQUAL
6177: IFFALSE 6055
// end ; repeat wait ( 0 0$1 ) ;
6179: LD_INT 35
6181: PPUSH
6182: CALL_OW 67
// for i in tmp do
6186: LD_ADDR_VAR 0 1
6190: PUSH
6191: LD_VAR 0 2
6195: PUSH
6196: FOR_IN
6197: IFFALSE 6279
// begin if GetLives ( i ) > 251 then
6199: LD_VAR 0 1
6203: PPUSH
6204: CALL_OW 256
6208: PUSH
6209: LD_INT 251
6211: GREATER
6212: IFFALSE 6250
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6214: LD_VAR 0 1
6218: PPUSH
6219: LD_INT 81
6221: PUSH
6222: LD_INT 8
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: PPUSH
6229: CALL_OW 69
6233: PPUSH
6234: LD_VAR 0 1
6238: PPUSH
6239: CALL_OW 74
6243: PPUSH
6244: CALL_OW 115
6248: GO 6277
// if IsDead ( i ) then
6250: LD_VAR 0 1
6254: PPUSH
6255: CALL_OW 301
6259: IFFALSE 6277
// tmp := tmp diff i ;
6261: LD_ADDR_VAR 0 2
6265: PUSH
6266: LD_VAR 0 2
6270: PUSH
6271: LD_VAR 0 1
6275: DIFF
6276: ST_TO_ADDR
// end ;
6277: GO 6196
6279: POP
6280: POP
// until not tmp ;
6281: LD_VAR 0 2
6285: NOT
6286: IFFALSE 6179
// end ;
6288: PPOPN 3
6290: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6291: LD_EXP 22
6295: NOT
6296: PUSH
6297: LD_EXP 15
6301: PUSH
6302: LD_INT 6
6304: GREATEREQUAL
6305: AND
6306: PUSH
6307: LD_OWVAR 67
6311: PUSH
6312: LD_INT 1
6314: GREATER
6315: AND
6316: IFFALSE 6833
6318: GO 6320
6320: DISABLE
6321: LD_INT 0
6323: PPUSH
6324: PPUSH
6325: PPUSH
// begin enable ;
6326: ENABLE
// tmp := [ ] ;
6327: LD_ADDR_VAR 0 3
6331: PUSH
6332: EMPTY
6333: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6334: LD_ADDR_VAR 0 1
6338: PUSH
6339: DOUBLE
6340: LD_INT 1
6342: DEC
6343: ST_TO_ADDR
6344: LD_INT 4
6346: PUSH
6347: LD_INT 6
6349: PUSH
6350: LD_INT 7
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: LD_OWVAR 67
6362: ARRAY
6363: PUSH
6364: FOR_TO
6365: IFFALSE 6525
// begin uc_side := 8 ;
6367: LD_ADDR_OWVAR 20
6371: PUSH
6372: LD_INT 8
6374: ST_TO_ADDR
// uc_nation := 2 ;
6375: LD_ADDR_OWVAR 21
6379: PUSH
6380: LD_INT 2
6382: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6383: LD_INT 13
6385: PUSH
6386: LD_INT 14
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: PUSH
6393: LD_INT 1
6395: PPUSH
6396: LD_INT 2
6398: PPUSH
6399: CALL_OW 12
6403: ARRAY
6404: PPUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 5
6410: PPUSH
6411: LD_INT 27
6413: PUSH
6414: LD_INT 28
6416: PUSH
6417: LD_INT 26
6419: PUSH
6420: LD_INT 25
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: PUSH
6429: LD_INT 1
6431: PPUSH
6432: LD_INT 4
6434: PPUSH
6435: CALL_OW 12
6439: ARRAY
6440: PPUSH
6441: LD_INT 88
6443: PPUSH
6444: CALL 69579 0 5
// un := CreateVehicle ;
6448: LD_ADDR_VAR 0 2
6452: PUSH
6453: CALL_OW 45
6457: ST_TO_ADDR
// tmp := tmp ^ un ;
6458: LD_ADDR_VAR 0 3
6462: PUSH
6463: LD_VAR 0 3
6467: PUSH
6468: LD_VAR 0 2
6472: ADD
6473: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6474: LD_VAR 0 2
6478: PPUSH
6479: LD_INT 3
6481: PPUSH
6482: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6486: LD_VAR 0 2
6490: PPUSH
6491: LD_INT 30
6493: PPUSH
6494: LD_INT 0
6496: PPUSH
6497: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6501: LD_VAR 0 2
6505: PPUSH
6506: LD_INT 16
6508: PPUSH
6509: LD_INT 11
6511: PPUSH
6512: CALL_OW 111
// wait ( 0 0$2 ) ;
6516: LD_INT 70
6518: PPUSH
6519: CALL_OW 67
// end ;
6523: GO 6364
6525: POP
6526: POP
// for i = 1 to Difficulty do
6527: LD_ADDR_VAR 0 1
6531: PUSH
6532: DOUBLE
6533: LD_INT 1
6535: DEC
6536: ST_TO_ADDR
6537: LD_OWVAR 67
6541: PUSH
6542: FOR_TO
6543: IFFALSE 6668
// begin uc_side := 8 ;
6545: LD_ADDR_OWVAR 20
6549: PUSH
6550: LD_INT 8
6552: ST_TO_ADDR
// uc_nation := 2 ;
6553: LD_ADDR_OWVAR 21
6557: PUSH
6558: LD_INT 2
6560: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6561: LD_INT 0
6563: PPUSH
6564: LD_INT 8
6566: PPUSH
6567: LD_INT 8
6569: PUSH
6570: LD_INT 8
6572: PUSH
6573: LD_INT 9
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: LIST
6580: PUSH
6581: LD_OWVAR 67
6585: ARRAY
6586: PPUSH
6587: CALL_OW 380
// un := CreateHuman ;
6591: LD_ADDR_VAR 0 2
6595: PUSH
6596: CALL_OW 44
6600: ST_TO_ADDR
// tmp := tmp ^ un ;
6601: LD_ADDR_VAR 0 3
6605: PUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_VAR 0 2
6615: ADD
6616: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6617: LD_VAR 0 2
6621: PPUSH
6622: LD_INT 3
6624: PPUSH
6625: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6629: LD_VAR 0 2
6633: PPUSH
6634: LD_INT 30
6636: PPUSH
6637: LD_INT 0
6639: PPUSH
6640: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6644: LD_VAR 0 2
6648: PPUSH
6649: LD_INT 16
6651: PPUSH
6652: LD_INT 11
6654: PPUSH
6655: CALL_OW 111
// wait ( 0 0$2 ) ;
6659: LD_INT 70
6661: PPUSH
6662: CALL_OW 67
// end ;
6666: GO 6542
6668: POP
6669: POP
// repeat wait ( 0 0$1 ) ;
6670: LD_INT 35
6672: PPUSH
6673: CALL_OW 67
// for i in tmp do
6677: LD_ADDR_VAR 0 1
6681: PUSH
6682: LD_VAR 0 3
6686: PUSH
6687: FOR_IN
6688: IFFALSE 6824
// begin if GetLives ( i ) > 250 then
6690: LD_VAR 0 1
6694: PPUSH
6695: CALL_OW 256
6699: PUSH
6700: LD_INT 250
6702: GREATER
6703: IFFALSE 6795
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6705: LD_INT 81
6707: PUSH
6708: LD_INT 8
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: PUSH
6715: LD_INT 91
6717: PUSH
6718: LD_VAR 0 1
6722: PUSH
6723: LD_INT 10
6725: PUSH
6726: EMPTY
6727: LIST
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PPUSH
6735: CALL_OW 69
6739: NOT
6740: IFFALSE 6759
// ComAgressiveMove ( i , 67 , 110 ) else
6742: LD_VAR 0 1
6746: PPUSH
6747: LD_INT 67
6749: PPUSH
6750: LD_INT 110
6752: PPUSH
6753: CALL_OW 114
6757: GO 6793
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6759: LD_VAR 0 1
6763: PPUSH
6764: LD_INT 81
6766: PUSH
6767: LD_INT 8
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: PPUSH
6774: CALL_OW 69
6778: PPUSH
6779: LD_VAR 0 1
6783: PPUSH
6784: CALL_OW 74
6788: PPUSH
6789: CALL_OW 115
// end else
6793: GO 6822
// if IsDead ( i ) then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 301
6804: IFFALSE 6822
// tmp := tmp diff i ;
6806: LD_ADDR_VAR 0 3
6810: PUSH
6811: LD_VAR 0 3
6815: PUSH
6816: LD_VAR 0 1
6820: DIFF
6821: ST_TO_ADDR
// end ;
6822: GO 6687
6824: POP
6825: POP
// until not tmp ;
6826: LD_VAR 0 3
6830: NOT
6831: IFFALSE 6670
// end ; end_of_file
6833: PPOPN 3
6835: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6836: LD_INT 0
6838: PPUSH
6839: PPUSH
6840: PPUSH
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
6846: PPUSH
// side := 3 ;
6847: LD_ADDR_VAR 0 6
6851: PUSH
6852: LD_INT 3
6854: ST_TO_ADDR
// uc_side := side ;
6855: LD_ADDR_OWVAR 20
6859: PUSH
6860: LD_VAR 0 6
6864: ST_TO_ADDR
// uc_nation := 3 ;
6865: LD_ADDR_OWVAR 21
6869: PUSH
6870: LD_INT 3
6872: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6873: LD_ADDR_VAR 0 2
6877: PUSH
6878: LD_INT 22
6880: PUSH
6881: LD_VAR 0 6
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PUSH
6890: LD_INT 21
6892: PUSH
6893: LD_INT 3
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PPUSH
6904: CALL_OW 69
6908: PUSH
6909: FOR_IN
6910: IFFALSE 6926
// SetBLevel ( i , 10 ) ;
6912: LD_VAR 0 2
6916: PPUSH
6917: LD_INT 10
6919: PPUSH
6920: CALL_OW 241
6924: GO 6909
6926: POP
6927: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6928: LD_ADDR_VAR 0 9
6932: PUSH
6933: LD_INT 22
6935: PUSH
6936: LD_VAR 0 6
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PUSH
6945: LD_INT 30
6947: PUSH
6948: LD_INT 34
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PPUSH
6959: CALL_OW 69
6963: ST_TO_ADDR
// if teleport then
6964: LD_VAR 0 9
6968: IFFALSE 6989
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6970: LD_VAR 0 9
6974: PUSH
6975: LD_INT 1
6977: ARRAY
6978: PPUSH
6979: LD_INT 123
6981: PPUSH
6982: LD_INT 122
6984: PPUSH
6985: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6989: LD_ADDR_EXP 61
6993: PUSH
6994: LD_STRING Platonov
6996: PPUSH
6997: CALL_OW 25
7001: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7002: LD_ADDR_EXP 62
7006: PUSH
7007: LD_STRING Kovalyuk
7009: PPUSH
7010: CALL_OW 25
7014: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7015: LD_ADDR_EXP 64
7019: PUSH
7020: LD_STRING Yakotich
7022: PPUSH
7023: CALL_OW 25
7027: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7028: LD_ADDR_EXP 63
7032: PUSH
7033: LD_STRING Bystrov
7035: PPUSH
7036: CALL_OW 25
7040: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7041: LD_ADDR_EXP 65
7045: PUSH
7046: LD_STRING Gleb
7048: PPUSH
7049: CALL_OW 25
7053: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7054: LD_STRING 03_Cornel
7056: PPUSH
7057: CALL_OW 28
7061: IFFALSE 7109
// begin Bierezov := NewCharacter ( Mikhail ) ;
7063: LD_ADDR_EXP 66
7067: PUSH
7068: LD_STRING Mikhail
7070: PPUSH
7071: CALL_OW 25
7075: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7076: LD_EXP 66
7080: PPUSH
7081: LD_INT 197
7083: PPUSH
7084: LD_INT 111
7086: PPUSH
7087: LD_INT 9
7089: PPUSH
7090: LD_INT 0
7092: PPUSH
7093: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7097: LD_EXP 66
7101: PPUSH
7102: LD_INT 3
7104: PPUSH
7105: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7109: LD_EXP 61
7113: PPUSH
7114: LD_INT 126
7116: PPUSH
7117: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7121: LD_EXP 62
7125: PPUSH
7126: LD_INT 134
7128: PPUSH
7129: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7133: LD_EXP 64
7137: PPUSH
7138: LD_INT 197
7140: PPUSH
7141: LD_INT 111
7143: PPUSH
7144: LD_INT 9
7146: PPUSH
7147: LD_INT 0
7149: PPUSH
7150: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7154: LD_EXP 63
7158: PPUSH
7159: LD_INT 197
7161: PPUSH
7162: LD_INT 111
7164: PPUSH
7165: LD_INT 9
7167: PPUSH
7168: LD_INT 0
7170: PPUSH
7171: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7175: LD_EXP 65
7179: PPUSH
7180: LD_INT 197
7182: PPUSH
7183: LD_INT 111
7185: PPUSH
7186: LD_INT 9
7188: PPUSH
7189: LD_INT 0
7191: PPUSH
7192: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7196: LD_ADDR_VAR 0 5
7200: PUSH
7201: LD_INT 126
7203: PPUSH
7204: LD_INT 4
7206: PPUSH
7207: LD_STRING zhukov
7209: PPUSH
7210: LD_INT 9
7212: PUSH
7213: LD_INT 10
7215: PUSH
7216: LD_INT 10
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_OWVAR 67
7228: ARRAY
7229: PPUSH
7230: LD_INT 99999
7232: PUSH
7233: LD_INT 1000
7235: PUSH
7236: LD_INT 300
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: LIST
7243: PPUSH
7244: LD_INT 12
7246: PUSH
7247: LD_INT 8
7249: PUSH
7250: LD_INT 13
7252: PUSH
7253: LD_INT 8
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PPUSH
7262: CALL 72988 0 6
7266: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7267: LD_ADDR_VAR 0 4
7271: PUSH
7272: LD_INT 267
7274: PPUSH
7275: CALL_OW 274
7279: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7280: LD_VAR 0 4
7284: PPUSH
7285: LD_INT 1
7287: PPUSH
7288: LD_INT 5000
7290: PPUSH
7291: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7295: LD_VAR 0 4
7299: PPUSH
7300: LD_INT 2
7302: PPUSH
7303: LD_INT 200
7305: PPUSH
7306: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7310: LD_VAR 0 4
7314: PPUSH
7315: LD_INT 3
7317: PPUSH
7318: LD_INT 200
7320: PPUSH
7321: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7325: LD_ADDR_EXP 99
7329: PUSH
7330: LD_EXP 99
7334: PPUSH
7335: LD_INT 2
7337: PPUSH
7338: LD_VAR 0 5
7342: PUSH
7343: LD_INT 22
7345: PUSH
7346: LD_VAR 0 6
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 21
7360: PUSH
7361: LD_INT 2
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: PPUSH
7376: CALL_OW 69
7380: UNION
7381: PUSH
7382: LD_EXP 61
7386: DIFF
7387: PPUSH
7388: CALL_OW 1
7392: ST_TO_ADDR
// behemoths := [ ] ;
7393: LD_ADDR_EXP 69
7397: PUSH
7398: EMPTY
7399: ST_TO_ADDR
// behemothBuilders := [ ] ;
7400: LD_ADDR_EXP 70
7404: PUSH
7405: EMPTY
7406: ST_TO_ADDR
// if Kovalyuk then
7407: LD_EXP 62
7411: IFFALSE 7433
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7413: LD_ADDR_EXP 70
7417: PUSH
7418: LD_EXP 70
7422: PPUSH
7423: LD_EXP 62
7427: PPUSH
7428: CALL 105324 0 2
7432: ST_TO_ADDR
// j := 3 ;
7433: LD_ADDR_VAR 0 3
7437: PUSH
7438: LD_INT 3
7440: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7441: LD_ADDR_VAR 0 2
7445: PUSH
7446: LD_INT 22
7448: PUSH
7449: LD_INT 3
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: LD_INT 25
7458: PUSH
7459: LD_INT 3
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: PPUSH
7470: CALL_OW 69
7474: PUSH
7475: LD_EXP 62
7479: DIFF
7480: PUSH
7481: FOR_IN
7482: IFFALSE 7532
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7484: LD_ADDR_EXP 70
7488: PUSH
7489: LD_EXP 70
7493: PPUSH
7494: LD_VAR 0 2
7498: PPUSH
7499: CALL 105324 0 2
7503: ST_TO_ADDR
// j := j - 1 ;
7504: LD_ADDR_VAR 0 3
7508: PUSH
7509: LD_VAR 0 3
7513: PUSH
7514: LD_INT 1
7516: MINUS
7517: ST_TO_ADDR
// if j = 0 then
7518: LD_VAR 0 3
7522: PUSH
7523: LD_INT 0
7525: EQUAL
7526: IFFALSE 7530
// break ;
7528: GO 7532
// end ;
7530: GO 7481
7532: POP
7533: POP
// end ;
7534: LD_VAR 0 1
7538: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7539: LD_INT 0
7541: PPUSH
7542: PPUSH
7543: PPUSH
7544: PPUSH
7545: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7546: LD_ADDR_VAR 0 4
7550: PUSH
7551: LD_INT 209
7553: PUSH
7554: LD_INT 149
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 219
7563: PUSH
7564: LD_INT 154
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 223
7573: PUSH
7574: LD_INT 149
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 232
7583: PUSH
7584: LD_INT 155
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: ST_TO_ADDR
// if not behemothBuilders then
7597: LD_EXP 70
7601: NOT
7602: IFFALSE 7606
// exit ;
7604: GO 7710
// j := 1 ;
7606: LD_ADDR_VAR 0 3
7610: PUSH
7611: LD_INT 1
7613: ST_TO_ADDR
// for i in behemothBuilders do
7614: LD_ADDR_VAR 0 2
7618: PUSH
7619: LD_EXP 70
7623: PUSH
7624: FOR_IN
7625: IFFALSE 7708
// begin if IsInUnit ( i ) then
7627: LD_VAR 0 2
7631: PPUSH
7632: CALL_OW 310
7636: IFFALSE 7647
// ComExitBuilding ( i ) ;
7638: LD_VAR 0 2
7642: PPUSH
7643: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7647: LD_VAR 0 2
7651: PPUSH
7652: LD_INT 37
7654: PPUSH
7655: LD_VAR 0 4
7659: PUSH
7660: LD_VAR 0 3
7664: ARRAY
7665: PUSH
7666: LD_INT 1
7668: ARRAY
7669: PPUSH
7670: LD_VAR 0 4
7674: PUSH
7675: LD_VAR 0 3
7679: ARRAY
7680: PUSH
7681: LD_INT 2
7683: ARRAY
7684: PPUSH
7685: LD_INT 0
7687: PPUSH
7688: CALL_OW 230
// j := j + 1 ;
7692: LD_ADDR_VAR 0 3
7696: PUSH
7697: LD_VAR 0 3
7701: PUSH
7702: LD_INT 1
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7624
7708: POP
7709: POP
// end ;
7710: LD_VAR 0 1
7714: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7715: LD_INT 24
7717: PPUSH
7718: LD_INT 30
7720: PUSH
7721: LD_INT 37
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PPUSH
7728: CALL_OW 70
7732: IFFALSE 7745
7734: GO 7736
7736: DISABLE
// behemothUnderConstruct := true ;
7737: LD_ADDR_EXP 26
7741: PUSH
7742: LD_INT 1
7744: ST_TO_ADDR
7745: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7746: LD_INT 3
7748: PPUSH
7749: CALL 105372 0 1
7753: PUSH
7754: LD_INT 22
7756: PUSH
7757: LD_INT 3
7759: PUSH
7760: EMPTY
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 30
7766: PUSH
7767: LD_INT 37
7769: PUSH
7770: EMPTY
7771: LIST
7772: LIST
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: PPUSH
7778: CALL_OW 69
7782: NOT
7783: AND
7784: IFFALSE 7970
7786: GO 7788
7788: DISABLE
7789: LD_INT 0
7791: PPUSH
7792: PPUSH
// begin enable ;
7793: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7794: LD_ADDR_VAR 0 2
7798: PUSH
7799: LD_INT 3
7801: PPUSH
7802: CALL 105372 0 1
7806: ST_TO_ADDR
// for i in tmp do
7807: LD_ADDR_VAR 0 1
7811: PUSH
7812: LD_VAR 0 2
7816: PUSH
7817: FOR_IN
7818: IFFALSE 7968
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7820: LD_VAR 0 1
7824: PPUSH
7825: LD_INT 9
7827: PPUSH
7828: CALL_OW 308
7832: PUSH
7833: LD_VAR 0 1
7837: PPUSH
7838: CALL_OW 110
7842: PUSH
7843: LD_INT 2
7845: EQUAL
7846: NOT
7847: AND
7848: IFFALSE 7862
// SetTag ( i , 2 ) ;
7850: LD_VAR 0 1
7854: PPUSH
7855: LD_INT 2
7857: PPUSH
7858: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7862: LD_INT 81
7864: PUSH
7865: LD_INT 3
7867: PUSH
7868: EMPTY
7869: LIST
7870: LIST
7871: PUSH
7872: LD_INT 91
7874: PUSH
7875: LD_VAR 0 1
7879: PUSH
7880: LD_INT 12
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL_OW 69
7896: NOT
7897: PUSH
7898: LD_VAR 0 1
7902: PPUSH
7903: CALL_OW 110
7907: PUSH
7908: LD_INT 2
7910: EQUAL
7911: NOT
7912: AND
7913: IFFALSE 7932
// ComAgressiveMove ( i , 64 , 93 ) else
7915: LD_VAR 0 1
7919: PPUSH
7920: LD_INT 64
7922: PPUSH
7923: LD_INT 93
7925: PPUSH
7926: CALL_OW 114
7930: GO 7966
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7932: LD_VAR 0 1
7936: PPUSH
7937: LD_INT 81
7939: PUSH
7940: LD_INT 3
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: PPUSH
7947: CALL_OW 69
7951: PPUSH
7952: LD_VAR 0 1
7956: PPUSH
7957: CALL_OW 74
7961: PPUSH
7962: CALL_OW 115
// end ;
7966: GO 7817
7968: POP
7969: POP
// end ;
7970: PPOPN 2
7972: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
7973: LD_INT 0
7975: PPUSH
7976: PPUSH
7977: PPUSH
// result := [ ] ;
7978: LD_ADDR_VAR 0 2
7982: PUSH
7983: EMPTY
7984: ST_TO_ADDR
// uc_side := 6 ;
7985: LD_ADDR_OWVAR 20
7989: PUSH
7990: LD_INT 6
7992: ST_TO_ADDR
// uc_nation := 3 ;
7993: LD_ADDR_OWVAR 21
7997: PUSH
7998: LD_INT 3
8000: ST_TO_ADDR
// case strength of 1 :
8001: LD_VAR 0 1
8005: PUSH
8006: LD_INT 1
8008: DOUBLE
8009: EQUAL
8010: IFTRUE 8014
8012: GO 8152
8014: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8015: LD_ADDR_VAR 0 3
8019: PUSH
8020: DOUBLE
8021: LD_INT 1
8023: DEC
8024: ST_TO_ADDR
8025: LD_INT 4
8027: PUSH
8028: LD_INT 5
8030: PUSH
8031: LD_INT 6
8033: PUSH
8034: EMPTY
8035: LIST
8036: LIST
8037: LIST
8038: PUSH
8039: LD_OWVAR 67
8043: ARRAY
8044: PUSH
8045: FOR_TO
8046: IFFALSE 8148
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8048: LD_INT 22
8050: PUSH
8051: LD_INT 24
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: PUSH
8058: LD_VAR 0 3
8062: PUSH
8063: LD_INT 2
8065: MOD
8066: PUSH
8067: LD_INT 1
8069: PLUS
8070: ARRAY
8071: PPUSH
8072: LD_INT 1
8074: PUSH
8075: LD_INT 3
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: LD_INT 1
8084: PPUSH
8085: LD_INT 2
8087: PPUSH
8088: CALL_OW 12
8092: ARRAY
8093: PPUSH
8094: LD_INT 3
8096: PPUSH
8097: LD_INT 43
8099: PUSH
8100: LD_INT 44
8102: PUSH
8103: LD_INT 45
8105: PUSH
8106: EMPTY
8107: LIST
8108: LIST
8109: LIST
8110: PUSH
8111: LD_INT 1
8113: PPUSH
8114: LD_INT 3
8116: PPUSH
8117: CALL_OW 12
8121: ARRAY
8122: PPUSH
8123: LD_INT 80
8125: PPUSH
8126: CALL 69579 0 5
// result := result union CreateVehicle ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_VAR 0 2
8139: PUSH
8140: CALL_OW 45
8144: UNION
8145: ST_TO_ADDR
// end ;
8146: GO 8045
8148: POP
8149: POP
// end ; 2 :
8150: GO 9096
8152: LD_INT 2
8154: DOUBLE
8155: EQUAL
8156: IFTRUE 8160
8158: GO 8316
8160: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8161: LD_ADDR_VAR 0 3
8165: PUSH
8166: DOUBLE
8167: LD_INT 1
8169: DEC
8170: ST_TO_ADDR
8171: LD_INT 6
8173: PUSH
8174: LD_INT 6
8176: PUSH
8177: LD_INT 7
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: LIST
8184: PUSH
8185: LD_OWVAR 67
8189: ARRAY
8190: PUSH
8191: FOR_TO
8192: IFFALSE 8312
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8194: LD_INT 22
8196: PUSH
8197: LD_INT 24
8199: PUSH
8200: LD_INT 24
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: LIST
8207: PUSH
8208: LD_VAR 0 3
8212: PUSH
8213: LD_INT 3
8215: MOD
8216: PUSH
8217: LD_INT 1
8219: PLUS
8220: ARRAY
8221: PPUSH
8222: LD_INT 1
8224: PUSH
8225: LD_INT 3
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 1
8234: PPUSH
8235: LD_INT 2
8237: PPUSH
8238: CALL_OW 12
8242: ARRAY
8243: PPUSH
8244: LD_INT 3
8246: PPUSH
8247: LD_INT 43
8249: PUSH
8250: LD_INT 44
8252: PUSH
8253: LD_INT 45
8255: PUSH
8256: LD_INT 44
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: LD_INT 46
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: PUSH
8273: LD_VAR 0 3
8277: PUSH
8278: LD_INT 6
8280: MOD
8281: PUSH
8282: LD_INT 1
8284: PLUS
8285: ARRAY
8286: PPUSH
8287: LD_INT 80
8289: PPUSH
8290: CALL 69579 0 5
// result := result union CreateVehicle ;
8294: LD_ADDR_VAR 0 2
8298: PUSH
8299: LD_VAR 0 2
8303: PUSH
8304: CALL_OW 45
8308: UNION
8309: ST_TO_ADDR
// end ;
8310: GO 8191
8312: POP
8313: POP
// end ; 3 :
8314: GO 9096
8316: LD_INT 3
8318: DOUBLE
8319: EQUAL
8320: IFTRUE 8324
8322: GO 8480
8324: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8325: LD_ADDR_VAR 0 3
8329: PUSH
8330: DOUBLE
8331: LD_INT 1
8333: DEC
8334: ST_TO_ADDR
8335: LD_INT 6
8337: PUSH
8338: LD_INT 7
8340: PUSH
8341: LD_INT 8
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: LIST
8348: PUSH
8349: LD_OWVAR 67
8353: ARRAY
8354: PUSH
8355: FOR_TO
8356: IFFALSE 8476
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8358: LD_INT 22
8360: PUSH
8361: LD_INT 24
8363: PUSH
8364: LD_INT 24
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: LIST
8371: PUSH
8372: LD_VAR 0 3
8376: PUSH
8377: LD_INT 3
8379: MOD
8380: PUSH
8381: LD_INT 1
8383: PLUS
8384: ARRAY
8385: PPUSH
8386: LD_INT 1
8388: PUSH
8389: LD_INT 3
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: PUSH
8396: LD_INT 1
8398: PPUSH
8399: LD_INT 2
8401: PPUSH
8402: CALL_OW 12
8406: ARRAY
8407: PPUSH
8408: LD_INT 3
8410: PPUSH
8411: LD_INT 43
8413: PUSH
8414: LD_INT 47
8416: PUSH
8417: LD_INT 45
8419: PUSH
8420: LD_INT 45
8422: PUSH
8423: LD_INT 46
8425: PUSH
8426: LD_INT 46
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: LIST
8435: LIST
8436: PUSH
8437: LD_VAR 0 3
8441: PUSH
8442: LD_INT 6
8444: MOD
8445: PUSH
8446: LD_INT 1
8448: PLUS
8449: ARRAY
8450: PPUSH
8451: LD_INT 80
8453: PPUSH
8454: CALL 69579 0 5
// result := result union CreateVehicle ;
8458: LD_ADDR_VAR 0 2
8462: PUSH
8463: LD_VAR 0 2
8467: PUSH
8468: CALL_OW 45
8472: UNION
8473: ST_TO_ADDR
// end ;
8474: GO 8355
8476: POP
8477: POP
// end ; 4 :
8478: GO 9096
8480: LD_INT 4
8482: DOUBLE
8483: EQUAL
8484: IFTRUE 8488
8486: GO 9095
8488: POP
// begin uc_nation := 3 ;
8489: LD_ADDR_OWVAR 21
8493: PUSH
8494: LD_INT 3
8496: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8497: LD_ADDR_VAR 0 3
8501: PUSH
8502: DOUBLE
8503: LD_INT 1
8505: DEC
8506: ST_TO_ADDR
8507: LD_INT 7
8509: PUSH
8510: LD_INT 8
8512: PUSH
8513: LD_INT 9
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: LIST
8520: PUSH
8521: LD_OWVAR 67
8525: ARRAY
8526: PUSH
8527: FOR_TO
8528: IFFALSE 8648
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8530: LD_INT 22
8532: PUSH
8533: LD_INT 24
8535: PUSH
8536: LD_INT 24
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PUSH
8544: LD_VAR 0 3
8548: PUSH
8549: LD_INT 3
8551: MOD
8552: PUSH
8553: LD_INT 1
8555: PLUS
8556: ARRAY
8557: PPUSH
8558: LD_INT 1
8560: PUSH
8561: LD_INT 3
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: PUSH
8568: LD_INT 1
8570: PPUSH
8571: LD_INT 2
8573: PPUSH
8574: CALL_OW 12
8578: ARRAY
8579: PPUSH
8580: LD_INT 3
8582: PPUSH
8583: LD_INT 45
8585: PUSH
8586: LD_INT 47
8588: PUSH
8589: LD_INT 47
8591: PUSH
8592: LD_INT 45
8594: PUSH
8595: LD_INT 46
8597: PUSH
8598: LD_INT 46
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: PUSH
8609: LD_VAR 0 3
8613: PUSH
8614: LD_INT 6
8616: MOD
8617: PUSH
8618: LD_INT 1
8620: PLUS
8621: ARRAY
8622: PPUSH
8623: LD_INT 80
8625: PPUSH
8626: CALL 69579 0 5
// result := result union CreateVehicle ;
8630: LD_ADDR_VAR 0 2
8634: PUSH
8635: LD_VAR 0 2
8639: PUSH
8640: CALL_OW 45
8644: UNION
8645: ST_TO_ADDR
// end ;
8646: GO 8527
8648: POP
8649: POP
// if not KappaStatus then
8650: LD_EXP 2
8654: NOT
8655: IFFALSE 8890
// begin uc_nation := 1 ;
8657: LD_ADDR_OWVAR 21
8661: PUSH
8662: LD_INT 1
8664: ST_TO_ADDR
// for i = 1 to 3 do
8665: LD_ADDR_VAR 0 3
8669: PUSH
8670: DOUBLE
8671: LD_INT 1
8673: DEC
8674: ST_TO_ADDR
8675: LD_INT 3
8677: PUSH
8678: FOR_TO
8679: IFFALSE 8815
// begin j := rand ( 0 , 1 ) ;
8681: LD_ADDR_VAR 0 4
8685: PUSH
8686: LD_INT 0
8688: PPUSH
8689: LD_INT 1
8691: PPUSH
8692: CALL_OW 12
8696: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8697: LD_INT 3
8699: PUSH
8700: LD_INT 5
8702: PUSH
8703: LD_INT 5
8705: PUSH
8706: LD_INT 4
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: PUSH
8715: LD_VAR 0 4
8719: PUSH
8720: LD_INT 1
8722: PPUSH
8723: LD_INT 3
8725: PPUSH
8726: CALL_OW 12
8730: PLUS
8731: ARRAY
8732: PPUSH
8733: LD_INT 1
8735: PUSH
8736: LD_INT 3
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: PUSH
8743: LD_INT 1
8745: PPUSH
8746: LD_INT 2
8748: PPUSH
8749: CALL_OW 12
8753: ARRAY
8754: PPUSH
8755: LD_INT 3
8757: PPUSH
8758: LD_INT 9
8760: PUSH
8761: LD_INT 7
8763: PUSH
8764: LD_INT 6
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: LIST
8771: PUSH
8772: LD_VAR 0 4
8776: PUSH
8777: LD_INT 1
8779: PPUSH
8780: LD_INT 2
8782: PPUSH
8783: CALL_OW 12
8787: PLUS
8788: ARRAY
8789: PPUSH
8790: LD_INT 85
8792: PPUSH
8793: CALL 69579 0 5
// result := result union CreateVehicle ;
8797: LD_ADDR_VAR 0 2
8801: PUSH
8802: LD_VAR 0 2
8806: PUSH
8807: CALL_OW 45
8811: UNION
8812: ST_TO_ADDR
// end ;
8813: GO 8678
8815: POP
8816: POP
// if vsevolodFirstAttack then
8817: LD_EXP 24
8821: IFFALSE 8888
// begin vsevolodFirstAttack := false ;
8823: LD_ADDR_EXP 24
8827: PUSH
8828: LD_INT 0
8830: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8831: LD_INT 5
8833: PPUSH
8834: LD_INT 3
8836: PPUSH
8837: LD_INT 1
8839: PPUSH
8840: LD_INT 6
8842: PPUSH
8843: LD_INT 100
8845: PPUSH
8846: CALL 69579 0 5
// sewiVeh := CreateVehicle ;
8850: LD_ADDR_EXP 68
8854: PUSH
8855: CALL_OW 45
8859: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8860: LD_EXP 68
8864: PPUSH
8865: LD_INT 1
8867: PPUSH
8868: CALL_OW 242
// result := result union sewiVeh ;
8872: LD_ADDR_VAR 0 2
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: LD_EXP 68
8886: UNION
8887: ST_TO_ADDR
// end ; end else
8888: GO 9093
// if vsevolodFirstAttack then
8890: LD_EXP 24
8894: IFFALSE 9093
// begin vsevolodFirstAttack := false ;
8896: LD_ADDR_EXP 24
8900: PUSH
8901: LD_INT 0
8903: ST_TO_ADDR
// uc_nation := 3 ;
8904: LD_ADDR_OWVAR 21
8908: PUSH
8909: LD_INT 3
8911: ST_TO_ADDR
// for i = 1 to 3 do
8912: LD_ADDR_VAR 0 3
8916: PUSH
8917: DOUBLE
8918: LD_INT 1
8920: DEC
8921: ST_TO_ADDR
8922: LD_INT 3
8924: PUSH
8925: FOR_TO
8926: IFFALSE 9034
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8928: LD_INT 22
8930: PUSH
8931: LD_INT 24
8933: PUSH
8934: LD_INT 24
8936: PUSH
8937: EMPTY
8938: LIST
8939: LIST
8940: LIST
8941: PUSH
8942: LD_VAR 0 3
8946: PUSH
8947: LD_INT 3
8949: MOD
8950: PUSH
8951: LD_INT 1
8953: PLUS
8954: ARRAY
8955: PPUSH
8956: LD_INT 1
8958: PUSH
8959: LD_INT 3
8961: PUSH
8962: EMPTY
8963: LIST
8964: LIST
8965: PUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_INT 2
8971: PPUSH
8972: CALL_OW 12
8976: ARRAY
8977: PPUSH
8978: LD_INT 3
8980: PPUSH
8981: LD_INT 45
8983: PUSH
8984: LD_INT 47
8986: PUSH
8987: LD_INT 47
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: LIST
8994: PUSH
8995: LD_VAR 0 3
8999: PUSH
9000: LD_INT 3
9002: MOD
9003: PUSH
9004: LD_INT 1
9006: PLUS
9007: ARRAY
9008: PPUSH
9009: LD_INT 80
9011: PPUSH
9012: CALL 69579 0 5
// result := result union CreateVehicle ;
9016: LD_ADDR_VAR 0 2
9020: PUSH
9021: LD_VAR 0 2
9025: PUSH
9026: CALL_OW 45
9030: UNION
9031: ST_TO_ADDR
// end ;
9032: GO 8925
9034: POP
9035: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9036: LD_INT 24
9038: PPUSH
9039: LD_INT 3
9041: PPUSH
9042: LD_INT 1
9044: PPUSH
9045: LD_INT 47
9047: PPUSH
9048: LD_INT 100
9050: PPUSH
9051: CALL 69579 0 5
// sewiVeh := CreateVehicle ;
9055: LD_ADDR_EXP 68
9059: PUSH
9060: CALL_OW 45
9064: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9065: LD_EXP 68
9069: PPUSH
9070: LD_INT 1
9072: PPUSH
9073: CALL_OW 242
// result := result union sewiVeh ;
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_VAR 0 2
9086: PUSH
9087: LD_EXP 68
9091: UNION
9092: ST_TO_ADDR
// end ; end ; end ;
9093: GO 9096
9095: POP
// end ;
9096: LD_VAR 0 2
9100: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9101: LD_EXP 16
9105: IFFALSE 9853
9107: GO 9109
9109: DISABLE
9110: LD_INT 0
9112: PPUSH
9113: PPUSH
9114: PPUSH
9115: PPUSH
9116: PPUSH
9117: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9118: LD_ADDR_VAR 0 4
9122: PUSH
9123: LD_INT 11
9125: PUSH
9126: LD_INT 12
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9133: LD_ADDR_VAR 0 3
9137: PUSH
9138: LD_INT 8400
9140: PUSH
9141: LD_INT 7350
9143: PUSH
9144: LD_INT 6650
9146: PUSH
9147: EMPTY
9148: LIST
9149: LIST
9150: LIST
9151: PUSH
9152: LD_OWVAR 67
9156: ARRAY
9157: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9158: LD_ADDR_VAR 0 6
9162: PUSH
9163: LD_INT 70
9165: PUSH
9166: LD_INT 118
9168: PUSH
9169: EMPTY
9170: LIST
9171: LIST
9172: PUSH
9173: LD_INT 78
9175: PUSH
9176: LD_INT 31
9178: PUSH
9179: EMPTY
9180: LIST
9181: LIST
9182: PUSH
9183: EMPTY
9184: LIST
9185: LIST
9186: ST_TO_ADDR
// repeat if missionStage = 2 then
9187: LD_EXP 15
9191: PUSH
9192: LD_INT 2
9194: EQUAL
9195: IFFALSE 9206
// wait ( 1 1$30 ) else
9197: LD_INT 3150
9199: PPUSH
9200: CALL_OW 67
9204: GO 9215
// wait ( time ) ;
9206: LD_VAR 0 3
9210: PPUSH
9211: CALL_OW 67
// if missionStage = 6 then
9215: LD_EXP 15
9219: PUSH
9220: LD_INT 6
9222: EQUAL
9223: IFFALSE 9251
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9225: LD_INT 51
9227: PPUSH
9228: LD_INT 6
9230: PPUSH
9231: LD_INT 2
9233: PPUSH
9234: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9238: LD_INT 57
9240: PPUSH
9241: LD_INT 6
9243: PPUSH
9244: LD_INT 2
9246: PPUSH
9247: CALL_OW 322
// end ; if missionStage = 8 then
9251: LD_EXP 15
9255: PUSH
9256: LD_INT 8
9258: EQUAL
9259: IFFALSE 9287
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9261: LD_INT 52
9263: PPUSH
9264: LD_INT 6
9266: PPUSH
9267: LD_INT 2
9269: PPUSH
9270: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9274: LD_INT 58
9276: PPUSH
9277: LD_INT 6
9279: PPUSH
9280: LD_INT 2
9282: PPUSH
9283: CALL_OW 322
// end ; if missionStage = 10 then
9287: LD_EXP 15
9291: PUSH
9292: LD_INT 10
9294: EQUAL
9295: IFFALSE 9323
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9297: LD_INT 53
9299: PPUSH
9300: LD_INT 6
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9310: LD_INT 59
9312: PPUSH
9313: LD_INT 6
9315: PPUSH
9316: LD_INT 2
9318: PPUSH
9319: CALL_OW 322
// end ; if activeAttacks then
9323: LD_EXP 16
9327: IFFALSE 9847
// begin if missionStage = 2 then
9329: LD_EXP 15
9333: PUSH
9334: LD_INT 2
9336: EQUAL
9337: IFFALSE 9347
// strength := 1 ;
9339: LD_ADDR_VAR 0 5
9343: PUSH
9344: LD_INT 1
9346: ST_TO_ADDR
// if missionStage > 2 then
9347: LD_EXP 15
9351: PUSH
9352: LD_INT 2
9354: GREATER
9355: IFFALSE 9365
// strength := 2 ;
9357: LD_ADDR_VAR 0 5
9361: PUSH
9362: LD_INT 2
9364: ST_TO_ADDR
// if missionStage > 6 then
9365: LD_EXP 15
9369: PUSH
9370: LD_INT 6
9372: GREATER
9373: IFFALSE 9383
// strength := 3 ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_INT 3
9382: ST_TO_ADDR
// if missionStage > 10 then
9383: LD_EXP 15
9387: PUSH
9388: LD_INT 10
9390: GREATER
9391: IFFALSE 9401
// strength := 4 ;
9393: LD_ADDR_VAR 0 5
9397: PUSH
9398: LD_INT 4
9400: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9401: LD_ADDR_VAR 0 2
9405: PUSH
9406: LD_VAR 0 5
9410: PPUSH
9411: CALL 7973 0 1
9415: ST_TO_ADDR
// for i in tmp do
9416: LD_ADDR_VAR 0 1
9420: PUSH
9421: LD_VAR 0 2
9425: PUSH
9426: FOR_IN
9427: IFFALSE 9527
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9429: LD_VAR 0 1
9433: PPUSH
9434: LD_VAR 0 4
9438: PUSH
9439: LD_INT 1
9441: PPUSH
9442: LD_INT 2
9444: PPUSH
9445: CALL_OW 12
9449: ARRAY
9450: PPUSH
9451: LD_INT 0
9453: PPUSH
9454: CALL_OW 49
// if i = sewiVeh then
9458: LD_VAR 0 1
9462: PUSH
9463: LD_EXP 68
9467: EQUAL
9468: IFFALSE 9503
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9470: LD_ADDR_EXP 67
9474: PUSH
9475: LD_STRING Vsevolod
9477: PPUSH
9478: LD_INT 0
9480: PPUSH
9481: LD_STRING 
9483: PPUSH
9484: CALL 62968 0 3
9488: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9489: LD_EXP 67
9493: PPUSH
9494: LD_VAR 0 1
9498: PPUSH
9499: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9503: LD_VAR 0 1
9507: PPUSH
9508: LD_INT 111
9510: PPUSH
9511: LD_INT 197
9513: PPUSH
9514: CALL_OW 111
// wait ( 0 0$2 ) ;
9518: LD_INT 70
9520: PPUSH
9521: CALL_OW 67
// end ;
9525: GO 9426
9527: POP
9528: POP
// repeat wait ( 0 0$1 ) ;
9529: LD_INT 35
9531: PPUSH
9532: CALL_OW 67
// for i in tmp do
9536: LD_ADDR_VAR 0 1
9540: PUSH
9541: LD_VAR 0 2
9545: PUSH
9546: FOR_IN
9547: IFFALSE 9828
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9549: LD_INT 81
9551: PUSH
9552: LD_INT 6
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: LD_INT 91
9561: PUSH
9562: LD_VAR 0 1
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: PPUSH
9579: CALL_OW 69
9583: IFFALSE 9641
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9585: LD_VAR 0 1
9589: PPUSH
9590: LD_INT 81
9592: PUSH
9593: LD_INT 6
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: LD_INT 91
9602: PUSH
9603: LD_VAR 0 1
9607: PUSH
9608: LD_INT 12
9610: PUSH
9611: EMPTY
9612: LIST
9613: LIST
9614: LIST
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: PPUSH
9620: CALL_OW 69
9624: PPUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 74
9634: PPUSH
9635: CALL_OW 115
9639: GO 9826
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9641: LD_INT 9
9643: PPUSH
9644: LD_INT 81
9646: PUSH
9647: LD_INT 6
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PPUSH
9654: CALL_OW 70
9658: IFFALSE 9792
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9660: LD_VAR 0 1
9664: PPUSH
9665: LD_VAR 0 6
9669: PUSH
9670: LD_INT 1
9672: ARRAY
9673: PUSH
9674: LD_INT 1
9676: ARRAY
9677: PPUSH
9678: LD_VAR 0 6
9682: PUSH
9683: LD_INT 1
9685: ARRAY
9686: PUSH
9687: LD_INT 2
9689: ARRAY
9690: PPUSH
9691: CALL_OW 297
9695: PUSH
9696: LD_INT 10
9698: GREATER
9699: PUSH
9700: LD_VAR 0 1
9704: PPUSH
9705: LD_INT 9
9707: PPUSH
9708: CALL_OW 308
9712: NOT
9713: AND
9714: IFFALSE 9753
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9716: LD_VAR 0 1
9720: PPUSH
9721: LD_VAR 0 6
9725: PUSH
9726: LD_INT 1
9728: ARRAY
9729: PUSH
9730: LD_INT 1
9732: ARRAY
9733: PPUSH
9734: LD_VAR 0 6
9738: PUSH
9739: LD_INT 1
9741: ARRAY
9742: PUSH
9743: LD_INT 2
9745: ARRAY
9746: PPUSH
9747: CALL_OW 114
9751: GO 9790
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9753: LD_VAR 0 1
9757: PPUSH
9758: LD_INT 9
9760: PPUSH
9761: LD_INT 81
9763: PUSH
9764: LD_INT 6
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PPUSH
9771: CALL_OW 70
9775: PPUSH
9776: LD_VAR 0 1
9780: PPUSH
9781: CALL_OW 74
9785: PPUSH
9786: CALL_OW 115
// end else
9790: GO 9826
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9792: LD_VAR 0 1
9796: PPUSH
9797: LD_INT 81
9799: PUSH
9800: LD_INT 6
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: PPUSH
9807: CALL_OW 69
9811: PPUSH
9812: LD_VAR 0 1
9816: PPUSH
9817: CALL_OW 74
9821: PPUSH
9822: CALL_OW 115
// end ;
9826: GO 9546
9828: POP
9829: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9830: LD_INT 22
9832: PUSH
9833: LD_INT 6
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: PPUSH
9840: CALL_OW 69
9844: NOT
9845: IFFALSE 9529
// end ; until russianDestroyed ;
9847: LD_EXP 21
9851: IFFALSE 9187
// end ;
9853: PPOPN 6
9855: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9856: LD_EXP 21
9860: NOT
9861: PUSH
9862: LD_EXP 15
9866: PUSH
9867: LD_INT 6
9869: GREATEREQUAL
9870: AND
9871: PUSH
9872: LD_INT 2
9874: PPUSH
9875: LD_INT 1
9877: PPUSH
9878: CALL 58321 0 2
9882: NOT
9883: AND
9884: IFFALSE 10840
9886: GO 9888
9888: DISABLE
9889: LD_INT 0
9891: PPUSH
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin enable ;
9895: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9896: LD_INT 22
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: PUSH
9906: LD_INT 30
9908: PUSH
9909: LD_INT 3
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: PUSH
9916: EMPTY
9917: LIST
9918: LIST
9919: PPUSH
9920: CALL_OW 69
9924: NOT
9925: IFFALSE 9929
// exit ;
9927: GO 10840
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9929: LD_ADDR_VAR 0 4
9933: PUSH
9934: LD_INT 22
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: LD_INT 30
9946: PUSH
9947: LD_INT 34
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PPUSH
9958: CALL_OW 69
9962: ST_TO_ADDR
// if Prob ( 40 ) then
9963: LD_INT 40
9965: PPUSH
9966: CALL_OW 13
9970: IFFALSE 10097
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9972: LD_INT 2
9974: PPUSH
9975: LD_INT 22
9977: PUSH
9978: LD_INT 3
9980: PUSH
9981: LD_INT 3
9983: PUSH
9984: LD_INT 49
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: PUSH
9993: LD_INT 22
9995: PUSH
9996: LD_INT 3
9998: PUSH
9999: LD_INT 3
10001: PUSH
10002: LD_INT 49
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: PUSH
10011: LD_INT 22
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: LD_INT 3
10019: PUSH
10020: LD_INT 49
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: PUSH
10029: LD_INT 24
10031: PUSH
10032: LD_INT 3
10034: PUSH
10035: LD_INT 3
10037: PUSH
10038: LD_INT 46
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 24
10049: PUSH
10050: LD_INT 3
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: LD_INT 46
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: PUSH
10065: LD_INT 24
10067: PUSH
10068: LD_INT 3
10070: PUSH
10071: LD_INT 3
10073: PUSH
10074: LD_INT 46
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: PPUSH
10091: CALL 56966 0 2
// end else
10095: GO 10220
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10097: LD_INT 2
10099: PPUSH
10100: LD_INT 24
10102: PUSH
10103: LD_INT 3
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 47
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: PUSH
10118: LD_INT 24
10120: PUSH
10121: LD_INT 3
10123: PUSH
10124: LD_INT 3
10126: PUSH
10127: LD_INT 47
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: PUSH
10136: LD_INT 24
10138: PUSH
10139: LD_INT 3
10141: PUSH
10142: LD_INT 3
10144: PUSH
10145: LD_INT 47
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 24
10156: PUSH
10157: LD_INT 3
10159: PUSH
10160: LD_INT 3
10162: PUSH
10163: LD_INT 46
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: PUSH
10172: LD_INT 24
10174: PUSH
10175: LD_INT 3
10177: PUSH
10178: LD_INT 3
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: PUSH
10190: LD_INT 24
10192: PUSH
10193: LD_INT 3
10195: PUSH
10196: LD_INT 3
10198: PUSH
10199: LD_INT 46
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: PPUSH
10216: CALL 56966 0 2
// end ; if Difficulty > 1 then
10220: LD_OWVAR 67
10224: PUSH
10225: LD_INT 1
10227: GREATER
10228: IFFALSE 10258
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10230: LD_INT 2
10232: PPUSH
10233: LD_INT 24
10235: PUSH
10236: LD_INT 3
10238: PUSH
10239: LD_INT 3
10241: PUSH
10242: LD_INT 47
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: LIST
10249: LIST
10250: PUSH
10251: EMPTY
10252: LIST
10253: PPUSH
10254: CALL 56966 0 2
// repeat wait ( 0 0$1 ) ;
10258: LD_INT 35
10260: PPUSH
10261: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10265: LD_INT 2
10267: PPUSH
10268: LD_INT 1
10270: PPUSH
10271: CALL 58321 0 2
10275: PUSH
10276: LD_INT 6
10278: PUSH
10279: LD_INT 7
10281: PUSH
10282: LD_INT 7
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: LIST
10289: PUSH
10290: LD_OWVAR 67
10294: ARRAY
10295: GREATEREQUAL
10296: IFFALSE 10258
// wait ( 0 0$30 ) ;
10298: LD_INT 1050
10300: PPUSH
10301: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10305: LD_ADDR_VAR 0 2
10309: PUSH
10310: LD_INT 2
10312: PPUSH
10313: LD_INT 1
10315: PPUSH
10316: CALL 58321 0 2
10320: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10321: LD_ADDR_EXP 118
10325: PUSH
10326: LD_EXP 118
10330: PPUSH
10331: LD_INT 2
10333: PPUSH
10334: LD_EXP 118
10338: PUSH
10339: LD_INT 2
10341: ARRAY
10342: PUSH
10343: LD_VAR 0 2
10347: DIFF
10348: PPUSH
10349: CALL_OW 1
10353: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10354: LD_ADDR_VAR 0 3
10358: PUSH
10359: LD_INT 0
10361: PPUSH
10362: LD_INT 1
10364: PPUSH
10365: CALL_OW 12
10369: ST_TO_ADDR
// if target then
10370: LD_VAR 0 3
10374: IFFALSE 10502
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10376: LD_ADDR_VAR 0 2
10380: PUSH
10381: LD_VAR 0 2
10385: PPUSH
10386: LD_INT 24
10388: PUSH
10389: LD_INT 250
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: PPUSH
10396: CALL_OW 72
10400: ST_TO_ADDR
// for i in tmp do
10401: LD_ADDR_VAR 0 1
10405: PUSH
10406: LD_VAR 0 2
10410: PUSH
10411: FOR_IN
10412: IFFALSE 10452
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10414: LD_VAR 0 1
10418: PPUSH
10419: LD_INT 139
10421: PPUSH
10422: LD_INT 89
10424: PPUSH
10425: CALL_OW 297
10429: PUSH
10430: LD_INT 9
10432: GREATER
10433: IFFALSE 10450
// ComMoveXY ( i , 139 , 89 ) ;
10435: LD_VAR 0 1
10439: PPUSH
10440: LD_INT 139
10442: PPUSH
10443: LD_INT 89
10445: PPUSH
10446: CALL_OW 111
10450: GO 10411
10452: POP
10453: POP
// wait ( 0 0$1 ) ;
10454: LD_INT 35
10456: PPUSH
10457: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10461: LD_VAR 0 2
10465: PPUSH
10466: LD_INT 92
10468: PUSH
10469: LD_INT 139
10471: PUSH
10472: LD_INT 89
10474: PUSH
10475: LD_INT 9
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: PPUSH
10484: CALL_OW 72
10488: PUSH
10489: LD_VAR 0 2
10493: PUSH
10494: LD_INT 1
10496: MINUS
10497: GREATEREQUAL
10498: IFFALSE 10376
// end else
10500: GO 10644
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10502: LD_VAR 0 2
10506: PPUSH
10507: LD_VAR 0 4
10511: PUSH
10512: LD_INT 1
10514: ARRAY
10515: PPUSH
10516: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10520: LD_ADDR_VAR 0 2
10524: PUSH
10525: LD_VAR 0 2
10529: PPUSH
10530: LD_INT 24
10532: PUSH
10533: LD_INT 250
10535: PUSH
10536: EMPTY
10537: LIST
10538: LIST
10539: PPUSH
10540: CALL_OW 72
10544: ST_TO_ADDR
// for i in tmp do
10545: LD_ADDR_VAR 0 1
10549: PUSH
10550: LD_VAR 0 2
10554: PUSH
10555: FOR_IN
10556: IFFALSE 10596
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10558: LD_VAR 0 1
10562: PPUSH
10563: LD_INT 124
10565: PPUSH
10566: LD_INT 139
10568: PPUSH
10569: CALL_OW 297
10573: PUSH
10574: LD_INT 9
10576: GREATER
10577: IFFALSE 10594
// ComMoveXY ( i , 124 , 139 ) ;
10579: LD_VAR 0 1
10583: PPUSH
10584: LD_INT 124
10586: PPUSH
10587: LD_INT 139
10589: PPUSH
10590: CALL_OW 111
10594: GO 10555
10596: POP
10597: POP
// wait ( 0 0$1 ) ;
10598: LD_INT 35
10600: PPUSH
10601: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10605: LD_VAR 0 2
10609: PPUSH
10610: LD_INT 92
10612: PUSH
10613: LD_INT 124
10615: PUSH
10616: LD_INT 139
10618: PUSH
10619: LD_INT 9
10621: PUSH
10622: EMPTY
10623: LIST
10624: LIST
10625: LIST
10626: LIST
10627: PPUSH
10628: CALL_OW 72
10632: PUSH
10633: LD_VAR 0 2
10637: PUSH
10638: LD_INT 1
10640: MINUS
10641: GREATEREQUAL
10642: IFFALSE 10520
// end ; repeat wait ( 0 0$1 ) ;
10644: LD_INT 35
10646: PPUSH
10647: CALL_OW 67
// for i in tmp do
10651: LD_ADDR_VAR 0 1
10655: PUSH
10656: LD_VAR 0 2
10660: PUSH
10661: FOR_IN
10662: IFFALSE 10831
// begin if GetLives ( i ) > 251 then
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 256
10673: PUSH
10674: LD_INT 251
10676: GREATER
10677: IFFALSE 10802
// begin if GetWeapon ( i ) = ru_time_lapser then
10679: LD_VAR 0 1
10683: PPUSH
10684: CALL_OW 264
10688: PUSH
10689: LD_INT 49
10691: EQUAL
10692: IFFALSE 10748
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10694: LD_VAR 0 1
10698: PPUSH
10699: LD_INT 2
10701: PUSH
10702: LD_INT 22
10704: PUSH
10705: LD_INT 1
10707: PUSH
10708: EMPTY
10709: LIST
10710: LIST
10711: PUSH
10712: LD_INT 22
10714: PUSH
10715: LD_INT 8
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: LIST
10726: PPUSH
10727: CALL_OW 69
10731: PPUSH
10732: LD_VAR 0 1
10736: PPUSH
10737: CALL_OW 74
10741: PPUSH
10742: CALL_OW 112
10746: GO 10800
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10748: LD_VAR 0 1
10752: PPUSH
10753: LD_INT 2
10755: PUSH
10756: LD_INT 22
10758: PUSH
10759: LD_INT 1
10761: PUSH
10762: EMPTY
10763: LIST
10764: LIST
10765: PUSH
10766: LD_INT 22
10768: PUSH
10769: LD_INT 8
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: LIST
10780: PPUSH
10781: CALL_OW 69
10785: PPUSH
10786: LD_VAR 0 1
10790: PPUSH
10791: CALL_OW 74
10795: PPUSH
10796: CALL_OW 115
// end else
10800: GO 10829
// if IsDead ( i ) then
10802: LD_VAR 0 1
10806: PPUSH
10807: CALL_OW 301
10811: IFFALSE 10829
// tmp := tmp diff i ;
10813: LD_ADDR_VAR 0 2
10817: PUSH
10818: LD_VAR 0 2
10822: PUSH
10823: LD_VAR 0 1
10827: DIFF
10828: ST_TO_ADDR
// end ;
10829: GO 10661
10831: POP
10832: POP
// until not tmp ;
10833: LD_VAR 0 2
10837: NOT
10838: IFFALSE 10644
// end ; end_of_file
10840: PPOPN 4
10842: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10843: LD_INT 0
10845: PPUSH
10846: PPUSH
10847: PPUSH
10848: PPUSH
10849: PPUSH
10850: PPUSH
// side := 7 ;
10851: LD_ADDR_VAR 0 5
10855: PUSH
10856: LD_INT 7
10858: ST_TO_ADDR
// uc_side := side ;
10859: LD_ADDR_OWVAR 20
10863: PUSH
10864: LD_VAR 0 5
10868: ST_TO_ADDR
// uc_nation := 1 ;
10869: LD_ADDR_OWVAR 21
10873: PUSH
10874: LD_INT 1
10876: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10877: LD_ADDR_VAR 0 2
10881: PUSH
10882: LD_INT 22
10884: PUSH
10885: LD_VAR 0 5
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: PUSH
10894: LD_INT 21
10896: PUSH
10897: LD_INT 3
10899: PUSH
10900: EMPTY
10901: LIST
10902: LIST
10903: PUSH
10904: EMPTY
10905: LIST
10906: LIST
10907: PPUSH
10908: CALL_OW 69
10912: PUSH
10913: FOR_IN
10914: IFFALSE 10930
// SetBLevel ( i , 10 ) ;
10916: LD_VAR 0 2
10920: PPUSH
10921: LD_INT 10
10923: PPUSH
10924: CALL_OW 241
10928: GO 10913
10930: POP
10931: POP
// base := GetBase ( al_depot ) ;
10932: LD_ADDR_VAR 0 4
10936: PUSH
10937: LD_INT 2
10939: PPUSH
10940: CALL_OW 274
10944: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10945: LD_ADDR_VAR 0 6
10949: PUSH
10950: LD_INT 22
10952: PUSH
10953: LD_VAR 0 5
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: PUSH
10962: LD_INT 30
10964: PUSH
10965: LD_INT 34
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PPUSH
10976: CALL_OW 69
10980: ST_TO_ADDR
// if teleport then
10981: LD_VAR 0 6
10985: IFFALSE 11006
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10987: LD_VAR 0 6
10991: PUSH
10992: LD_INT 1
10994: ARRAY
10995: PPUSH
10996: LD_INT 262
10998: PPUSH
10999: LD_INT 119
11001: PPUSH
11002: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11006: LD_VAR 0 4
11010: PPUSH
11011: LD_INT 1
11013: PPUSH
11014: LD_INT 19500
11016: PPUSH
11017: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11021: LD_VAR 0 4
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: LD_INT 200
11031: PPUSH
11032: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11036: LD_VAR 0 4
11040: PPUSH
11041: LD_INT 3
11043: PPUSH
11044: LD_INT 650
11046: PPUSH
11047: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11051: LD_ADDR_EXP 71
11055: PUSH
11056: LD_STRING Roth
11058: PPUSH
11059: CALL_OW 25
11063: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11064: LD_ADDR_EXP 72
11068: PUSH
11069: LD_STRING Simms
11071: PPUSH
11072: LD_EXP 1
11076: NOT
11077: PPUSH
11078: LD_STRING 10c_
11080: PPUSH
11081: CALL 62968 0 3
11085: ST_TO_ADDR
// if not Simms then
11086: LD_EXP 72
11090: NOT
11091: IFFALSE 11121
// begin uc_nation := 1 ;
11093: LD_ADDR_OWVAR 21
11097: PUSH
11098: LD_INT 1
11100: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11101: LD_INT 2
11103: PPUSH
11104: LD_INT 10
11106: PPUSH
11107: CALL_OW 384
// Simms := CreateHuman ;
11111: LD_ADDR_EXP 72
11115: PUSH
11116: CALL_OW 44
11120: ST_TO_ADDR
// end ; uc_nation := 3 ;
11121: LD_ADDR_OWVAR 21
11125: PUSH
11126: LD_INT 3
11128: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11129: LD_ADDR_EXP 73
11133: PUSH
11134: LD_STRING Kirilenkova
11136: PPUSH
11137: CALL_OW 25
11141: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11142: LD_ADDR_EXP 87
11146: PUSH
11147: LD_STRING Oblukov
11149: PPUSH
11150: CALL_OW 25
11154: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11155: LD_ADDR_EXP 74
11159: PUSH
11160: LD_STRING Dolgov
11162: PPUSH
11163: CALL_OW 25
11167: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11168: LD_ADDR_EXP 75
11172: PUSH
11173: LD_STRING Petrosyan
11175: PPUSH
11176: CALL_OW 25
11180: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11181: LD_ADDR_EXP 86
11185: PUSH
11186: LD_STRING Scholtze
11188: PPUSH
11189: CALL_OW 25
11193: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11194: LD_ADDR_EXP 85
11198: PUSH
11199: LD_STRING Kapitsova
11201: PPUSH
11202: CALL_OW 25
11206: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11207: LD_ADDR_EXP 76
11211: PUSH
11212: LD_STRING Petrovova
11214: PPUSH
11215: CALL_OW 25
11219: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11220: LD_ADDR_EXP 77
11224: PUSH
11225: LD_STRING Kuzmov
11227: PPUSH
11228: CALL_OW 25
11232: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11233: LD_ADDR_EXP 84
11237: PUSH
11238: LD_STRING Karamazov
11240: PPUSH
11241: CALL_OW 25
11245: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11246: LD_STRING 13_Lipshchin_1
11248: PPUSH
11249: LD_INT 0
11251: PPUSH
11252: CALL_OW 30
11256: IFFALSE 11271
// Lipshchin := NewCharacter ( Lipshchin ) ;
11258: LD_ADDR_EXP 78
11262: PUSH
11263: LD_STRING Lipshchin
11265: PPUSH
11266: CALL_OW 25
11270: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11271: LD_STRING 13_Titov_1
11273: PPUSH
11274: LD_INT 0
11276: PPUSH
11277: CALL_OW 30
11281: IFFALSE 11296
// Titov := NewCharacter ( Titov ) ;
11283: LD_ADDR_EXP 80
11287: PUSH
11288: LD_STRING Titov
11290: PPUSH
11291: CALL_OW 25
11295: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11296: LD_STRING 13_Gnyevko_1
11298: PPUSH
11299: LD_INT 0
11301: PPUSH
11302: CALL_OW 30
11306: IFFALSE 11321
// Gnyevko := NewCharacter ( Gnyevko ) ;
11308: LD_ADDR_EXP 79
11312: PUSH
11313: LD_STRING Gnyevko
11315: PPUSH
11316: CALL_OW 25
11320: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11321: LD_STRING 13_Xavier_1
11323: PPUSH
11324: LD_INT 0
11326: PPUSH
11327: CALL_OW 30
11331: IFFALSE 11346
// Xavier := NewCharacter ( Xavier2 ) ;
11333: LD_ADDR_EXP 81
11337: PUSH
11338: LD_STRING Xavier2
11340: PPUSH
11341: CALL_OW 25
11345: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11346: LD_STRING 13_Belkov_1
11348: PPUSH
11349: LD_INT 0
11351: PPUSH
11352: CALL_OW 30
11356: IFFALSE 11371
// Belkov := NewCharacter ( Belkov ) ;
11358: LD_ADDR_EXP 82
11362: PUSH
11363: LD_STRING Belkov
11365: PPUSH
11366: CALL_OW 25
11370: ST_TO_ADDR
// if not BurlakStatus then
11371: LD_EXP 9
11375: NOT
11376: IFFALSE 11391
// Burlak = NewCharacter ( Burlak ) ;
11378: LD_ADDR_EXP 83
11382: PUSH
11383: LD_STRING Burlak
11385: PPUSH
11386: CALL_OW 25
11390: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11391: LD_ADDR_VAR 0 3
11395: PUSH
11396: LD_EXP 71
11400: PUSH
11401: LD_EXP 73
11405: PUSH
11406: LD_EXP 87
11410: PUSH
11411: LD_EXP 74
11415: PUSH
11416: LD_EXP 75
11420: PUSH
11421: LD_EXP 86
11425: PUSH
11426: LD_EXP 85
11430: PUSH
11431: LD_EXP 76
11435: PUSH
11436: LD_EXP 77
11440: PUSH
11441: LD_EXP 84
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: LIST
11456: LIST
11457: ST_TO_ADDR
// if Simms then
11458: LD_EXP 72
11462: IFFALSE 11480
// tmp := tmp ^ Simms ;
11464: LD_ADDR_VAR 0 3
11468: PUSH
11469: LD_VAR 0 3
11473: PUSH
11474: LD_EXP 72
11478: ADD
11479: ST_TO_ADDR
// if Titov then
11480: LD_EXP 80
11484: IFFALSE 11502
// tmp := tmp ^ Titov ;
11486: LD_ADDR_VAR 0 3
11490: PUSH
11491: LD_VAR 0 3
11495: PUSH
11496: LD_EXP 80
11500: ADD
11501: ST_TO_ADDR
// if Lipshchin then
11502: LD_EXP 78
11506: IFFALSE 11524
// tmp := tmp ^ Lipshchin ;
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: LD_VAR 0 3
11517: PUSH
11518: LD_EXP 78
11522: ADD
11523: ST_TO_ADDR
// if Gnyevko then
11524: LD_EXP 79
11528: IFFALSE 11546
// tmp := tmp ^ Gnyevko ;
11530: LD_ADDR_VAR 0 3
11534: PUSH
11535: LD_VAR 0 3
11539: PUSH
11540: LD_EXP 79
11544: ADD
11545: ST_TO_ADDR
// if Xavier then
11546: LD_EXP 81
11550: IFFALSE 11568
// tmp := tmp ^ Xavier ;
11552: LD_ADDR_VAR 0 3
11556: PUSH
11557: LD_VAR 0 3
11561: PUSH
11562: LD_EXP 81
11566: ADD
11567: ST_TO_ADDR
// if Belkov then
11568: LD_EXP 82
11572: IFFALSE 11590
// tmp := tmp ^ Belkov ;
11574: LD_ADDR_VAR 0 3
11578: PUSH
11579: LD_VAR 0 3
11583: PUSH
11584: LD_EXP 82
11588: ADD
11589: ST_TO_ADDR
// if Burlak then
11590: LD_EXP 83
11594: IFFALSE 11612
// tmp := tmp ^ Burlak ;
11596: LD_ADDR_VAR 0 3
11600: PUSH
11601: LD_VAR 0 3
11605: PUSH
11606: LD_EXP 83
11610: ADD
11611: ST_TO_ADDR
// for i = 1 to 8 do
11612: LD_ADDR_VAR 0 2
11616: PUSH
11617: DOUBLE
11618: LD_INT 1
11620: DEC
11621: ST_TO_ADDR
11622: LD_INT 8
11624: PUSH
11625: FOR_TO
11626: IFFALSE 11692
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11628: LD_ADDR_OWVAR 21
11632: PUSH
11633: LD_INT 1
11635: PUSH
11636: LD_INT 3
11638: PUSH
11639: EMPTY
11640: LIST
11641: LIST
11642: PUSH
11643: LD_INT 1
11645: PPUSH
11646: LD_INT 2
11648: PPUSH
11649: CALL_OW 12
11653: ARRAY
11654: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11655: LD_INT 0
11657: PPUSH
11658: LD_VAR 0 2
11662: PUSH
11663: LD_INT 2
11665: DIV
11666: PPUSH
11667: LD_INT 10
11669: PPUSH
11670: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11674: LD_ADDR_VAR 0 3
11678: PUSH
11679: LD_VAR 0 3
11683: PUSH
11684: CALL_OW 44
11688: ADD
11689: ST_TO_ADDR
// end ;
11690: GO 11625
11692: POP
11693: POP
// for i in tmp do
11694: LD_ADDR_VAR 0 2
11698: PUSH
11699: LD_VAR 0 3
11703: PUSH
11704: FOR_IN
11705: IFFALSE 11730
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11707: LD_VAR 0 2
11711: PPUSH
11712: LD_INT 260
11714: PPUSH
11715: LD_INT 235
11717: PPUSH
11718: LD_INT 8
11720: PPUSH
11721: LD_INT 0
11723: PPUSH
11724: CALL_OW 50
11728: GO 11704
11730: POP
11731: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11732: LD_ADDR_EXP 99
11736: PUSH
11737: LD_EXP 99
11741: PPUSH
11742: LD_INT 1
11744: PPUSH
11745: LD_INT 22
11747: PUSH
11748: LD_VAR 0 5
11752: PUSH
11753: EMPTY
11754: LIST
11755: LIST
11756: PUSH
11757: LD_INT 3
11759: PUSH
11760: LD_INT 21
11762: PUSH
11763: LD_INT 2
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: PPUSH
11778: CALL_OW 69
11782: PUSH
11783: LD_EXP 71
11787: PUSH
11788: LD_EXP 72
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: DIFF
11797: PPUSH
11798: CALL_OW 1
11802: ST_TO_ADDR
// uc_side := 0 ;
11803: LD_ADDR_OWVAR 20
11807: PUSH
11808: LD_INT 0
11810: ST_TO_ADDR
// uc_nation := 0 ;
11811: LD_ADDR_OWVAR 21
11815: PUSH
11816: LD_INT 0
11818: ST_TO_ADDR
// for i = 1 to 5 do
11819: LD_ADDR_VAR 0 2
11823: PUSH
11824: DOUBLE
11825: LD_INT 1
11827: DEC
11828: ST_TO_ADDR
11829: LD_INT 5
11831: PUSH
11832: FOR_TO
11833: IFFALSE 11870
// begin InitHc ;
11835: CALL_OW 19
// hc_class := class_apeman ;
11839: LD_ADDR_OWVAR 28
11843: PUSH
11844: LD_INT 12
11846: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11847: CALL_OW 44
11851: PPUSH
11852: LD_INT 299
11854: PPUSH
11855: LD_INT 229
11857: PPUSH
11858: LD_INT 10
11860: PPUSH
11861: LD_INT 0
11863: PPUSH
11864: CALL_OW 50
// end ;
11868: GO 11832
11870: POP
11871: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11872: LD_EXP 71
11876: PPUSH
11877: LD_INT 259
11879: PPUSH
11880: LD_INT 235
11882: PPUSH
11883: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11887: LD_EXP 71
11891: PPUSH
11892: LD_INT 262
11894: PPUSH
11895: LD_INT 235
11897: PPUSH
11898: CALL_OW 178
// if Simms then
11902: LD_EXP 72
11906: IFFALSE 11937
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11908: LD_EXP 72
11912: PPUSH
11913: LD_INT 262
11915: PPUSH
11916: LD_INT 235
11918: PPUSH
11919: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11923: LD_EXP 72
11927: PPUSH
11928: LD_EXP 71
11932: PPUSH
11933: CALL_OW 179
// end ; end ;
11937: LD_VAR 0 1
11941: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11942: LD_EXP 31
11946: PUSH
11947: LD_EXP 23
11951: NOT
11952: AND
11953: IFFALSE 12129
11955: GO 11957
11957: DISABLE
11958: LD_INT 0
11960: PPUSH
11961: PPUSH
11962: PPUSH
// begin enable ;
11963: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11964: LD_ADDR_VAR 0 2
11968: PUSH
11969: LD_INT 81
11971: PUSH
11972: LD_INT 7
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: PUSH
11979: LD_INT 2
11981: PUSH
11982: LD_INT 32
11984: PUSH
11985: LD_INT 3
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 30
11994: PUSH
11995: LD_INT 30
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: LD_INT 30
12004: PUSH
12005: LD_INT 28
12007: PUSH
12008: EMPTY
12009: LIST
12010: LIST
12011: PUSH
12012: LD_INT 34
12014: PUSH
12015: LD_INT 49
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: PUSH
12022: LD_INT 34
12024: PUSH
12025: LD_INT 10
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: LD_INT 34
12034: PUSH
12035: LD_INT 8
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: LIST
12048: LIST
12049: LIST
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: ST_TO_ADDR
// if not tmp then
12060: LD_VAR 0 2
12064: NOT
12065: IFFALSE 12069
// exit ;
12067: GO 12129
// target := tmp [ rand ( 1 , tmp ) ] ;
12069: LD_ADDR_VAR 0 3
12073: PUSH
12074: LD_VAR 0 2
12078: PUSH
12079: LD_INT 1
12081: PPUSH
12082: LD_VAR 0 2
12086: PPUSH
12087: CALL_OW 12
12091: ARRAY
12092: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12093: LD_VAR 0 3
12097: PPUSH
12098: CALL_OW 255
12102: PUSH
12103: LD_INT 1
12105: EQUAL
12106: IFFALSE 12117
// CenterNowOnUnits ( target ) ;
12108: LD_VAR 0 3
12112: PPUSH
12113: CALL_OW 87
// SetLives ( target , 0 ) ;
12117: LD_VAR 0 3
12121: PPUSH
12122: LD_INT 0
12124: PPUSH
12125: CALL_OW 234
// end ;
12129: PPOPN 3
12131: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12132: LD_EXP 23
12136: NOT
12137: PUSH
12138: LD_EXP 31
12142: AND
12143: IFFALSE 12665
12145: GO 12147
12147: DISABLE
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
// begin uc_side := 7 ;
12153: LD_ADDR_OWVAR 20
12157: PUSH
12158: LD_INT 7
12160: ST_TO_ADDR
// uc_nation := 1 ;
12161: LD_ADDR_OWVAR 21
12165: PUSH
12166: LD_INT 1
12168: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12169: LD_ADDR_VAR 0 3
12173: PUSH
12174: LD_INT 125
12176: PUSH
12177: LD_INT 163
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PUSH
12184: LD_INT 185
12186: PUSH
12187: LD_INT 168
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: LD_INT 111
12196: PUSH
12197: LD_INT 97
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL 105416 0 1
12213: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12214: LD_ADDR_EXP 88
12218: PUSH
12219: EMPTY
12220: ST_TO_ADDR
// for i = 1 to Difficulty do
12221: LD_ADDR_VAR 0 1
12225: PUSH
12226: DOUBLE
12227: LD_INT 1
12229: DEC
12230: ST_TO_ADDR
12231: LD_OWVAR 67
12235: PUSH
12236: FOR_TO
12237: IFFALSE 12395
// begin InitHc ;
12239: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12243: LD_INT 0
12245: PPUSH
12246: LD_INT 8
12248: PPUSH
12249: CALL_OW 381
// un := CreateHuman ;
12253: LD_ADDR_VAR 0 2
12257: PUSH
12258: CALL_OW 44
12262: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12263: LD_VAR 0 2
12267: PPUSH
12268: LD_INT 258
12270: PPUSH
12271: LD_INT 267
12273: PPUSH
12274: LD_INT 4
12276: PPUSH
12277: LD_INT 0
12279: PPUSH
12280: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12284: LD_ADDR_EXP 88
12288: PUSH
12289: LD_EXP 88
12293: PUSH
12294: LD_VAR 0 2
12298: UNION
12299: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12300: LD_VAR 0 2
12304: PPUSH
12305: LD_VAR 0 3
12309: PUSH
12310: LD_VAR 0 1
12314: ARRAY
12315: PUSH
12316: LD_INT 1
12318: ARRAY
12319: PPUSH
12320: LD_VAR 0 3
12324: PUSH
12325: LD_VAR 0 1
12329: ARRAY
12330: PUSH
12331: LD_INT 2
12333: ARRAY
12334: PPUSH
12335: LD_INT 4
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12345: LD_VAR 0 2
12349: PPUSH
12350: LD_VAR 0 3
12354: PUSH
12355: LD_VAR 0 1
12359: ARRAY
12360: PUSH
12361: LD_INT 1
12363: ARRAY
12364: PPUSH
12365: LD_VAR 0 3
12369: PUSH
12370: LD_VAR 0 1
12374: ARRAY
12375: PUSH
12376: LD_INT 2
12378: ARRAY
12379: PPUSH
12380: CALL_OW 171
// AddComInvisible ( un ) ;
12384: LD_VAR 0 2
12388: PPUSH
12389: CALL_OW 212
// end ;
12393: GO 12236
12395: POP
12396: POP
// repeat wait ( 0 0$20 ) ;
12397: LD_INT 700
12399: PPUSH
12400: CALL_OW 67
// for i in allianceSpecialForce do
12404: LD_ADDR_VAR 0 1
12408: PUSH
12409: LD_EXP 88
12413: PUSH
12414: FOR_IN
12415: IFFALSE 12650
// begin if IsInvisible ( i ) then
12417: LD_VAR 0 1
12421: PPUSH
12422: CALL_OW 571
12426: IFFALSE 12619
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12428: LD_ADDR_VAR 0 3
12432: PUSH
12433: LD_INT 22
12435: PUSH
12436: LD_INT 1
12438: PUSH
12439: EMPTY
12440: LIST
12441: LIST
12442: PUSH
12443: LD_INT 50
12445: PUSH
12446: EMPTY
12447: LIST
12448: PUSH
12449: LD_INT 56
12451: PUSH
12452: EMPTY
12453: LIST
12454: PUSH
12455: LD_INT 91
12457: PUSH
12458: LD_VAR 0 1
12462: PUSH
12463: LD_INT 25
12465: PUSH
12466: LD_INT 30
12468: PUSH
12469: LD_INT 35
12471: PUSH
12472: EMPTY
12473: LIST
12474: LIST
12475: LIST
12476: PUSH
12477: LD_OWVAR 67
12481: ARRAY
12482: PUSH
12483: EMPTY
12484: LIST
12485: LIST
12486: LIST
12487: PUSH
12488: LD_INT 2
12490: PUSH
12491: LD_INT 25
12493: PUSH
12494: LD_INT 1
12496: PUSH
12497: EMPTY
12498: LIST
12499: LIST
12500: PUSH
12501: LD_INT 25
12503: PUSH
12504: LD_INT 2
12506: PUSH
12507: EMPTY
12508: LIST
12509: LIST
12510: PUSH
12511: LD_INT 25
12513: PUSH
12514: LD_INT 3
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: PUSH
12521: LD_INT 25
12523: PUSH
12524: LD_INT 4
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: PUSH
12531: LD_INT 25
12533: PUSH
12534: LD_INT 5
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PUSH
12541: LD_INT 25
12543: PUSH
12544: LD_INT 8
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PUSH
12551: EMPTY
12552: LIST
12553: LIST
12554: LIST
12555: LIST
12556: LIST
12557: LIST
12558: LIST
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PPUSH
12567: CALL_OW 69
12571: ST_TO_ADDR
// if not tmp then
12572: LD_VAR 0 3
12576: NOT
12577: IFFALSE 12581
// continue ;
12579: GO 12414
// if Prob ( 30 * Difficulty ) then
12581: LD_INT 30
12583: PUSH
12584: LD_OWVAR 67
12588: MUL
12589: PPUSH
12590: CALL_OW 13
12594: IFFALSE 12619
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12596: LD_VAR 0 3
12600: PUSH
12601: LD_INT 1
12603: PPUSH
12604: LD_VAR 0 3
12608: PPUSH
12609: CALL_OW 12
12613: ARRAY
12614: PPUSH
12615: CALL 30076 0 1
// end ; if IsDead ( i ) then
12619: LD_VAR 0 1
12623: PPUSH
12624: CALL_OW 301
12628: IFFALSE 12648
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12630: LD_ADDR_EXP 88
12634: PUSH
12635: LD_EXP 88
12639: PUSH
12640: LD_VAR 0 1
12644: DIFF
12645: ST_TO_ADDR
// continue ;
12646: GO 12414
// end ; end ;
12648: GO 12414
12650: POP
12651: POP
// until allianceDestroyed or not allianceSpecialForce ;
12652: LD_EXP 23
12656: PUSH
12657: LD_EXP 88
12661: NOT
12662: OR
12663: IFFALSE 12397
// end ;
12665: PPOPN 3
12667: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12668: LD_EXP 23
12672: NOT
12673: PUSH
12674: LD_EXP 31
12678: AND
12679: PUSH
12680: LD_INT 1
12682: PPUSH
12683: LD_INT 1
12685: PPUSH
12686: CALL 58321 0 2
12690: NOT
12691: AND
12692: IFFALSE 13659
12694: GO 12696
12696: DISABLE
12697: LD_INT 0
12699: PPUSH
12700: PPUSH
12701: PPUSH
12702: PPUSH
// begin enable ;
12703: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12704: LD_INT 22
12706: PUSH
12707: LD_INT 7
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: PUSH
12714: LD_INT 30
12716: PUSH
12717: LD_INT 3
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: PUSH
12724: EMPTY
12725: LIST
12726: LIST
12727: PPUSH
12728: CALL_OW 69
12732: NOT
12733: IFFALSE 12737
// exit ;
12735: GO 13659
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12737: LD_ADDR_VAR 0 4
12741: PUSH
12742: LD_INT 22
12744: PUSH
12745: LD_INT 7
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: LD_INT 30
12754: PUSH
12755: LD_INT 34
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PPUSH
12766: CALL_OW 69
12770: ST_TO_ADDR
// if Prob ( 40 ) then
12771: LD_INT 40
12773: PPUSH
12774: CALL_OW 13
12778: IFFALSE 12905
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12780: LD_INT 1
12782: PPUSH
12783: LD_INT 5
12785: PUSH
12786: LD_INT 3
12788: PUSH
12789: LD_INT 2
12791: PUSH
12792: LD_INT 6
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: PUSH
12801: LD_INT 5
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 2
12809: PUSH
12810: LD_INT 6
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: PUSH
12819: LD_INT 5
12821: PUSH
12822: LD_INT 3
12824: PUSH
12825: LD_INT 2
12827: PUSH
12828: LD_INT 6
12830: PUSH
12831: EMPTY
12832: LIST
12833: LIST
12834: LIST
12835: LIST
12836: PUSH
12837: LD_INT 24
12839: PUSH
12840: LD_INT 3
12842: PUSH
12843: LD_INT 3
12845: PUSH
12846: LD_INT 45
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: LIST
12853: LIST
12854: PUSH
12855: LD_INT 24
12857: PUSH
12858: LD_INT 3
12860: PUSH
12861: LD_INT 3
12863: PUSH
12864: LD_INT 47
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PUSH
12873: LD_INT 24
12875: PUSH
12876: LD_INT 3
12878: PUSH
12879: LD_INT 3
12881: PUSH
12882: LD_INT 45
12884: PUSH
12885: EMPTY
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: LIST
12897: LIST
12898: PPUSH
12899: CALL 56966 0 2
// end else
12903: GO 13028
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12905: LD_INT 1
12907: PPUSH
12908: LD_INT 24
12910: PUSH
12911: LD_INT 3
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 47
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 24
12928: PUSH
12929: LD_INT 3
12931: PUSH
12932: LD_INT 3
12934: PUSH
12935: LD_INT 47
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: PUSH
12944: LD_INT 5
12946: PUSH
12947: LD_INT 3
12949: PUSH
12950: LD_INT 2
12952: PUSH
12953: LD_INT 9
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: PUSH
12962: LD_INT 5
12964: PUSH
12965: LD_INT 3
12967: PUSH
12968: LD_INT 2
12970: PUSH
12971: LD_INT 9
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: LIST
12978: LIST
12979: PUSH
12980: LD_INT 24
12982: PUSH
12983: LD_INT 1
12985: PUSH
12986: LD_INT 3
12988: PUSH
12989: LD_INT 45
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: PUSH
12998: LD_INT 24
13000: PUSH
13001: LD_INT 1
13003: PUSH
13004: LD_INT 3
13006: PUSH
13007: LD_INT 45
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: PPUSH
13024: CALL 56966 0 2
// end ; if Difficulty > 1 then
13028: LD_OWVAR 67
13032: PUSH
13033: LD_INT 1
13035: GREATER
13036: IFFALSE 13066
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13038: LD_INT 1
13040: PPUSH
13041: LD_INT 24
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 47
13052: PUSH
13053: EMPTY
13054: LIST
13055: LIST
13056: LIST
13057: LIST
13058: PUSH
13059: EMPTY
13060: LIST
13061: PPUSH
13062: CALL 56966 0 2
// repeat wait ( 0 0$1 ) ;
13066: LD_INT 35
13068: PPUSH
13069: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13073: LD_INT 1
13075: PPUSH
13076: LD_INT 1
13078: PPUSH
13079: CALL 58321 0 2
13083: PUSH
13084: LD_INT 6
13086: PUSH
13087: LD_INT 7
13089: PUSH
13090: LD_INT 7
13092: PUSH
13093: EMPTY
13094: LIST
13095: LIST
13096: LIST
13097: PUSH
13098: LD_OWVAR 67
13102: ARRAY
13103: GREATEREQUAL
13104: IFFALSE 13066
// wait ( 0 0$40 ) ;
13106: LD_INT 1400
13108: PPUSH
13109: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13113: LD_ADDR_VAR 0 2
13117: PUSH
13118: LD_INT 1
13120: PPUSH
13121: LD_INT 1
13123: PPUSH
13124: CALL 58321 0 2
13128: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13129: LD_ADDR_EXP 118
13133: PUSH
13134: LD_EXP 118
13138: PPUSH
13139: LD_INT 1
13141: PPUSH
13142: LD_EXP 118
13146: PUSH
13147: LD_INT 1
13149: ARRAY
13150: PUSH
13151: LD_VAR 0 2
13155: DIFF
13156: PPUSH
13157: CALL_OW 1
13161: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13162: LD_ADDR_VAR 0 3
13166: PUSH
13167: LD_INT 0
13169: PPUSH
13170: LD_INT 1
13172: PPUSH
13173: CALL_OW 12
13177: ST_TO_ADDR
// if target then
13178: LD_VAR 0 3
13182: IFFALSE 13348
// begin for i in tmp do
13184: LD_ADDR_VAR 0 1
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: FOR_IN
13195: IFFALSE 13220
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13197: LD_VAR 0 1
13201: PPUSH
13202: LD_INT 179
13204: PPUSH
13205: LD_INT 209
13207: PPUSH
13208: LD_INT 8
13210: PPUSH
13211: LD_INT 1
13213: PPUSH
13214: CALL_OW 483
13218: GO 13194
13220: POP
13221: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13222: LD_ADDR_VAR 0 2
13226: PUSH
13227: LD_VAR 0 2
13231: PPUSH
13232: LD_INT 24
13234: PUSH
13235: LD_INT 250
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PPUSH
13242: CALL_OW 72
13246: ST_TO_ADDR
// for i in tmp do
13247: LD_ADDR_VAR 0 1
13251: PUSH
13252: LD_VAR 0 2
13256: PUSH
13257: FOR_IN
13258: IFFALSE 13298
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13260: LD_VAR 0 1
13264: PPUSH
13265: LD_INT 179
13267: PPUSH
13268: LD_INT 209
13270: PPUSH
13271: CALL_OW 297
13275: PUSH
13276: LD_INT 9
13278: GREATER
13279: IFFALSE 13296
// ComMoveXY ( i , 179 , 209 ) ;
13281: LD_VAR 0 1
13285: PPUSH
13286: LD_INT 179
13288: PPUSH
13289: LD_INT 209
13291: PPUSH
13292: CALL_OW 111
13296: GO 13257
13298: POP
13299: POP
// wait ( 0 0$1 ) ;
13300: LD_INT 35
13302: PPUSH
13303: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13307: LD_VAR 0 2
13311: PPUSH
13312: LD_INT 92
13314: PUSH
13315: LD_INT 179
13317: PUSH
13318: LD_INT 209
13320: PUSH
13321: LD_INT 9
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: LIST
13328: LIST
13329: PPUSH
13330: CALL_OW 72
13334: PUSH
13335: LD_VAR 0 2
13339: PUSH
13340: LD_INT 1
13342: MINUS
13343: GREATEREQUAL
13344: IFFALSE 13222
// end else
13346: GO 13510
// begin for i in tmp do
13348: LD_ADDR_VAR 0 1
13352: PUSH
13353: LD_VAR 0 2
13357: PUSH
13358: FOR_IN
13359: IFFALSE 13384
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13361: LD_VAR 0 1
13365: PPUSH
13366: LD_INT 285
13368: PPUSH
13369: LD_INT 163
13371: PPUSH
13372: LD_INT 8
13374: PPUSH
13375: LD_INT 1
13377: PPUSH
13378: CALL_OW 483
13382: GO 13358
13384: POP
13385: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13386: LD_ADDR_VAR 0 2
13390: PUSH
13391: LD_VAR 0 2
13395: PPUSH
13396: LD_INT 24
13398: PUSH
13399: LD_INT 250
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PPUSH
13406: CALL_OW 72
13410: ST_TO_ADDR
// for i in tmp do
13411: LD_ADDR_VAR 0 1
13415: PUSH
13416: LD_VAR 0 2
13420: PUSH
13421: FOR_IN
13422: IFFALSE 13462
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13424: LD_VAR 0 1
13428: PPUSH
13429: LD_INT 285
13431: PPUSH
13432: LD_INT 163
13434: PPUSH
13435: CALL_OW 297
13439: PUSH
13440: LD_INT 9
13442: GREATER
13443: IFFALSE 13460
// ComMoveXY ( i , 285 , 163 ) ;
13445: LD_VAR 0 1
13449: PPUSH
13450: LD_INT 285
13452: PPUSH
13453: LD_INT 163
13455: PPUSH
13456: CALL_OW 111
13460: GO 13421
13462: POP
13463: POP
// wait ( 0 0$1 ) ;
13464: LD_INT 35
13466: PPUSH
13467: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13471: LD_VAR 0 2
13475: PPUSH
13476: LD_INT 92
13478: PUSH
13479: LD_INT 285
13481: PUSH
13482: LD_INT 163
13484: PUSH
13485: LD_INT 9
13487: PUSH
13488: EMPTY
13489: LIST
13490: LIST
13491: LIST
13492: LIST
13493: PPUSH
13494: CALL_OW 72
13498: PUSH
13499: LD_VAR 0 2
13503: PUSH
13504: LD_INT 1
13506: MINUS
13507: GREATEREQUAL
13508: IFFALSE 13386
// end ; repeat wait ( 0 0$1 ) ;
13510: LD_INT 35
13512: PPUSH
13513: CALL_OW 67
// for i in tmp do
13517: LD_ADDR_VAR 0 1
13521: PUSH
13522: LD_VAR 0 2
13526: PUSH
13527: FOR_IN
13528: IFFALSE 13650
// if GetLives ( i ) > 251 then
13530: LD_VAR 0 1
13534: PPUSH
13535: CALL_OW 256
13539: PUSH
13540: LD_INT 251
13542: GREATER
13543: IFFALSE 13632
// begin if GetWeapon ( i ) = ru_time_lapser then
13545: LD_VAR 0 1
13549: PPUSH
13550: CALL_OW 264
13554: PUSH
13555: LD_INT 49
13557: EQUAL
13558: IFFALSE 13596
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13560: LD_VAR 0 1
13564: PPUSH
13565: LD_INT 81
13567: PUSH
13568: LD_INT 7
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: PPUSH
13580: LD_VAR 0 1
13584: PPUSH
13585: CALL_OW 74
13589: PPUSH
13590: CALL_OW 112
13594: GO 13630
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13596: LD_VAR 0 1
13600: PPUSH
13601: LD_INT 81
13603: PUSH
13604: LD_INT 7
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PPUSH
13611: CALL_OW 69
13615: PPUSH
13616: LD_VAR 0 1
13620: PPUSH
13621: CALL_OW 74
13625: PPUSH
13626: CALL_OW 115
// end else
13630: GO 13648
// tmp := tmp diff i ;
13632: LD_ADDR_VAR 0 2
13636: PUSH
13637: LD_VAR 0 2
13641: PUSH
13642: LD_VAR 0 1
13646: DIFF
13647: ST_TO_ADDR
13648: GO 13527
13650: POP
13651: POP
// until not tmp ;
13652: LD_VAR 0 2
13656: NOT
13657: IFFALSE 13510
// end ; end_of_file
13659: PPOPN 4
13661: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13662: LD_INT 0
13664: PPUSH
13665: PPUSH
13666: PPUSH
13667: PPUSH
// missionStage := 13 ;
13668: LD_ADDR_EXP 15
13672: PUSH
13673: LD_INT 13
13675: ST_TO_ADDR
// uc_side := 2 ;
13676: LD_ADDR_OWVAR 20
13680: PUSH
13681: LD_INT 2
13683: ST_TO_ADDR
// uc_nation := 2 ;
13684: LD_ADDR_OWVAR 21
13688: PUSH
13689: LD_INT 2
13691: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13692: LD_ADDR_EXP 89
13696: PUSH
13697: LD_STRING Omar
13699: PPUSH
13700: CALL_OW 25
13704: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13705: LD_EXP 89
13709: PPUSH
13710: LD_INT 4
13712: PPUSH
13713: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13717: LD_EXP 89
13721: PPUSH
13722: LD_INT 242
13724: PPUSH
13725: LD_INT 75
13727: PPUSH
13728: LD_INT 0
13730: PPUSH
13731: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13735: LD_ADDR_EXP 90
13739: PUSH
13740: LD_STRING Heike
13742: PPUSH
13743: CALL_OW 25
13747: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13748: LD_INT 14
13750: PPUSH
13751: LD_INT 3
13753: PPUSH
13754: LD_INT 1
13756: PPUSH
13757: LD_INT 27
13759: PPUSH
13760: LD_INT 100
13762: PPUSH
13763: CALL 69579 0 5
// veh := CreateVehicle ;
13767: LD_ADDR_VAR 0 3
13771: PUSH
13772: CALL_OW 45
13776: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13777: LD_VAR 0 3
13781: PPUSH
13782: LD_INT 1
13784: PPUSH
13785: CALL_OW 242
// SetDir ( veh , 4 ) ;
13789: LD_VAR 0 3
13793: PPUSH
13794: LD_INT 4
13796: PPUSH
13797: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13801: LD_VAR 0 3
13805: PPUSH
13806: LD_INT 241
13808: PPUSH
13809: LD_INT 72
13811: PPUSH
13812: LD_INT 0
13814: PPUSH
13815: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13819: LD_EXP 90
13823: PPUSH
13824: LD_VAR 0 3
13828: PPUSH
13829: CALL_OW 52
// if KhatamStatus then
13833: LD_EXP 8
13837: IFFALSE 13888
// begin Khatam := NewCharacter ( Khatam ) ;
13839: LD_ADDR_EXP 91
13843: PUSH
13844: LD_STRING Khatam
13846: PPUSH
13847: CALL_OW 25
13851: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13852: LD_EXP 91
13856: PPUSH
13857: LD_INT 245
13859: PPUSH
13860: LD_INT 78
13862: PPUSH
13863: LD_INT 3
13865: PPUSH
13866: LD_INT 0
13868: PPUSH
13869: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13873: LD_EXP 91
13877: PPUSH
13878: LD_INT 4
13880: PPUSH
13881: LD_INT 10
13883: PPUSH
13884: CALL_OW 237
// end ; for i = 1 to Difficulty do
13888: LD_ADDR_VAR 0 2
13892: PUSH
13893: DOUBLE
13894: LD_INT 1
13896: DEC
13897: ST_TO_ADDR
13898: LD_OWVAR 67
13902: PUSH
13903: FOR_TO
13904: IFFALSE 13970
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13906: LD_INT 0
13908: PPUSH
13909: LD_INT 7
13911: PUSH
13912: LD_OWVAR 67
13916: PLUS
13917: PPUSH
13918: CALL_OW 384
// un := CreateHuman ;
13922: LD_ADDR_VAR 0 4
13926: PUSH
13927: CALL_OW 44
13931: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13932: LD_VAR 0 4
13936: PPUSH
13937: LD_INT 28
13939: PUSH
13940: LD_INT 29
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: PUSH
13947: LD_VAR 0 2
13951: PUSH
13952: LD_INT 2
13954: MOD
13955: PUSH
13956: LD_INT 1
13958: PLUS
13959: ARRAY
13960: PPUSH
13961: LD_INT 0
13963: PPUSH
13964: CALL_OW 49
// end ;
13968: GO 13903
13970: POP
13971: POP
// for i = 1 to 6 do
13972: LD_ADDR_VAR 0 2
13976: PUSH
13977: DOUBLE
13978: LD_INT 1
13980: DEC
13981: ST_TO_ADDR
13982: LD_INT 6
13984: PUSH
13985: FOR_TO
13986: IFFALSE 14031
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13988: LD_INT 0
13990: PPUSH
13991: LD_INT 7
13993: PUSH
13994: LD_OWVAR 67
13998: PLUS
13999: PPUSH
14000: CALL_OW 381
// un := CreateHuman ;
14004: LD_ADDR_VAR 0 4
14008: PUSH
14009: CALL_OW 44
14013: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14014: LD_VAR 0 4
14018: PPUSH
14019: LD_INT 28
14021: PPUSH
14022: LD_INT 0
14024: PPUSH
14025: CALL_OW 49
// end ;
14029: GO 13985
14031: POP
14032: POP
// for i = 1 to 3 do
14033: LD_ADDR_VAR 0 2
14037: PUSH
14038: DOUBLE
14039: LD_INT 1
14041: DEC
14042: ST_TO_ADDR
14043: LD_INT 3
14045: PUSH
14046: FOR_TO
14047: IFFALSE 14095
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14049: LD_INT 0
14051: PPUSH
14052: LD_INT 8
14054: PPUSH
14055: LD_INT 7
14057: PUSH
14058: LD_OWVAR 67
14062: PLUS
14063: PPUSH
14064: CALL_OW 380
// un := CreateHuman ;
14068: LD_ADDR_VAR 0 4
14072: PUSH
14073: CALL_OW 44
14077: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14078: LD_VAR 0 4
14082: PPUSH
14083: LD_INT 28
14085: PPUSH
14086: LD_INT 0
14088: PPUSH
14089: CALL_OW 49
// end ;
14093: GO 14046
14095: POP
14096: POP
// for i = 1 to 3 do
14097: LD_ADDR_VAR 0 2
14101: PUSH
14102: DOUBLE
14103: LD_INT 1
14105: DEC
14106: ST_TO_ADDR
14107: LD_INT 3
14109: PUSH
14110: FOR_TO
14111: IFFALSE 14201
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14113: LD_INT 14
14115: PPUSH
14116: LD_INT 2
14118: PPUSH
14119: LD_INT 1
14121: PPUSH
14122: LD_INT 28
14124: PPUSH
14125: LD_INT 80
14127: PPUSH
14128: CALL 69579 0 5
// veh := CreateVehicle ;
14132: LD_ADDR_VAR 0 3
14136: PUSH
14137: CALL_OW 45
14141: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14142: LD_VAR 0 3
14146: PPUSH
14147: LD_INT 3
14149: PPUSH
14150: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14154: LD_VAR 0 3
14158: PPUSH
14159: LD_INT 29
14161: PPUSH
14162: LD_INT 0
14164: PPUSH
14165: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14169: LD_INT 0
14171: PPUSH
14172: LD_INT 7
14174: PUSH
14175: LD_OWVAR 67
14179: PLUS
14180: PPUSH
14181: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14185: CALL_OW 44
14189: PPUSH
14190: LD_VAR 0 3
14194: PPUSH
14195: CALL_OW 52
// end ;
14199: GO 14110
14201: POP
14202: POP
// for i = 1 to 5 + Difficulty do
14203: LD_ADDR_VAR 0 2
14207: PUSH
14208: DOUBLE
14209: LD_INT 1
14211: DEC
14212: ST_TO_ADDR
14213: LD_INT 5
14215: PUSH
14216: LD_OWVAR 67
14220: PLUS
14221: PUSH
14222: FOR_TO
14223: IFFALSE 14350
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14225: LD_INT 14
14227: PPUSH
14228: LD_INT 1
14230: PPUSH
14231: LD_INT 3
14233: PPUSH
14234: CALL_OW 12
14238: PPUSH
14239: LD_INT 1
14241: PPUSH
14242: LD_INT 28
14244: PUSH
14245: LD_INT 26
14247: PUSH
14248: LD_INT 27
14250: PUSH
14251: LD_INT 25
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: LIST
14258: LIST
14259: PUSH
14260: LD_VAR 0 2
14264: PUSH
14265: LD_INT 4
14267: MOD
14268: PUSH
14269: LD_INT 1
14271: PLUS
14272: ARRAY
14273: PPUSH
14274: LD_INT 80
14276: PPUSH
14277: CALL 69579 0 5
// veh := CreateVehicle ;
14281: LD_ADDR_VAR 0 3
14285: PUSH
14286: CALL_OW 45
14290: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14291: LD_VAR 0 3
14295: PPUSH
14296: LD_INT 4
14298: PPUSH
14299: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14303: LD_VAR 0 3
14307: PPUSH
14308: LD_INT 28
14310: PPUSH
14311: LD_INT 0
14313: PPUSH
14314: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14318: LD_INT 0
14320: PPUSH
14321: LD_INT 7
14323: PUSH
14324: LD_OWVAR 67
14328: PLUS
14329: PPUSH
14330: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14334: CALL_OW 44
14338: PPUSH
14339: LD_VAR 0 3
14343: PPUSH
14344: CALL_OW 52
// end ;
14348: GO 14222
14350: POP
14351: POP
// for i = 1 to 3 do
14352: LD_ADDR_VAR 0 2
14356: PUSH
14357: DOUBLE
14358: LD_INT 1
14360: DEC
14361: ST_TO_ADDR
14362: LD_INT 3
14364: PUSH
14365: FOR_TO
14366: IFFALSE 14426
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14368: LD_INT 14
14370: PPUSH
14371: LD_INT 3
14373: PPUSH
14374: LD_INT 5
14376: PPUSH
14377: LD_INT 29
14379: PPUSH
14380: LD_INT 80
14382: PPUSH
14383: CALL 69579 0 5
// veh := CreateVehicle ;
14387: LD_ADDR_VAR 0 3
14391: PUSH
14392: CALL_OW 45
14396: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14397: LD_VAR 0 3
14401: PPUSH
14402: LD_INT 4
14404: PPUSH
14405: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14409: LD_VAR 0 3
14413: PPUSH
14414: LD_INT 28
14416: PPUSH
14417: LD_INT 0
14419: PPUSH
14420: CALL_OW 49
// end ;
14424: GO 14365
14426: POP
14427: POP
// end ;
14428: LD_VAR 0 1
14432: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14433: LD_INT 22
14435: PUSH
14436: LD_INT 2
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PPUSH
14443: CALL_OW 69
14447: IFFALSE 14747
14449: GO 14451
14451: DISABLE
14452: LD_INT 0
14454: PPUSH
14455: PPUSH
14456: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14457: LD_ADDR_VAR 0 3
14461: PUSH
14462: LD_INT 22
14464: PUSH
14465: LD_INT 2
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: PUSH
14472: LD_INT 25
14474: PUSH
14475: LD_INT 4
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: PPUSH
14486: CALL_OW 69
14490: PUSH
14491: LD_EXP 91
14495: DIFF
14496: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14497: LD_ADDR_VAR 0 2
14501: PUSH
14502: LD_INT 22
14504: PUSH
14505: LD_INT 2
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PPUSH
14512: CALL_OW 69
14516: PUSH
14517: LD_EXP 91
14521: PUSH
14522: LD_VAR 0 3
14526: UNION
14527: DIFF
14528: ST_TO_ADDR
// if Khatam then
14529: LD_EXP 91
14533: IFFALSE 14550
// ComMoveXY ( Khatam , 211 , 92 ) ;
14535: LD_EXP 91
14539: PPUSH
14540: LD_INT 211
14542: PPUSH
14543: LD_INT 92
14545: PPUSH
14546: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14550: LD_INT 197
14552: PPUSH
14553: LD_INT 80
14555: PPUSH
14556: LD_INT 2
14558: PPUSH
14559: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14563: LD_INT 213
14565: PPUSH
14566: LD_INT 90
14568: PPUSH
14569: LD_INT 2
14571: PPUSH
14572: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14576: LD_INT 215
14578: PPUSH
14579: LD_INT 129
14581: PPUSH
14582: LD_INT 2
14584: PPUSH
14585: CALL_OW 441
// if sci then
14589: LD_VAR 0 3
14593: IFFALSE 14614
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14595: LD_VAR 0 3
14599: PUSH
14600: LD_INT 1
14602: ARRAY
14603: PPUSH
14604: LD_INT 197
14606: PPUSH
14607: LD_INT 80
14609: PPUSH
14610: CALL_OW 158
// if sci > 1 then
14614: LD_VAR 0 3
14618: PUSH
14619: LD_INT 1
14621: GREATER
14622: IFFALSE 14643
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14624: LD_VAR 0 3
14628: PUSH
14629: LD_INT 2
14631: ARRAY
14632: PPUSH
14633: LD_INT 213
14635: PPUSH
14636: LD_INT 90
14638: PPUSH
14639: CALL_OW 158
// if sci > 2 then
14643: LD_VAR 0 3
14647: PUSH
14648: LD_INT 2
14650: GREATER
14651: IFFALSE 14672
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14653: LD_VAR 0 3
14657: PUSH
14658: LD_INT 3
14660: ARRAY
14661: PPUSH
14662: LD_INT 215
14664: PPUSH
14665: LD_INT 129
14667: PPUSH
14668: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14672: LD_INT 35
14674: PPUSH
14675: CALL_OW 67
// for i in tmp do
14679: LD_ADDR_VAR 0 1
14683: PUSH
14684: LD_VAR 0 2
14688: PUSH
14689: FOR_IN
14690: IFFALSE 14728
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14692: LD_VAR 0 1
14696: PPUSH
14697: LD_INT 81
14699: PUSH
14700: LD_INT 2
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: PPUSH
14707: CALL_OW 69
14711: PPUSH
14712: LD_VAR 0 1
14716: PPUSH
14717: CALL_OW 74
14721: PPUSH
14722: CALL_OW 115
14726: GO 14689
14728: POP
14729: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14730: LD_INT 22
14732: PUSH
14733: LD_INT 2
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: PPUSH
14740: CALL_OW 69
14744: NOT
14745: IFFALSE 14672
// end ; end_of_file
14747: PPOPN 3
14749: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14750: LD_INT 0
14752: PPUSH
14753: PPUSH
14754: PPUSH
14755: PPUSH
14756: PPUSH
14757: PPUSH
14758: PPUSH
14759: PPUSH
14760: PPUSH
// Video ( true ) ;
14761: LD_INT 1
14763: PPUSH
14764: CALL 105296 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14768: LD_ADDR_VAR 0 5
14772: PUSH
14773: LD_INT 7
14775: PPUSH
14776: LD_INT 0
14778: PPUSH
14779: CALL_OW 517
14783: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14784: LD_ADDR_VAR 0 2
14788: PUSH
14789: DOUBLE
14790: LD_INT 1
14792: DEC
14793: ST_TO_ADDR
14794: LD_VAR 0 5
14798: PUSH
14799: LD_INT 1
14801: ARRAY
14802: PUSH
14803: FOR_TO
14804: IFFALSE 14849
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14806: LD_VAR 0 5
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: PUSH
14815: LD_VAR 0 2
14819: ARRAY
14820: PPUSH
14821: LD_VAR 0 5
14825: PUSH
14826: LD_INT 2
14828: ARRAY
14829: PUSH
14830: LD_VAR 0 2
14834: ARRAY
14835: PPUSH
14836: LD_INT 1
14838: PPUSH
14839: LD_INT 15
14841: NEG
14842: PPUSH
14843: CALL 105210 0 4
14847: GO 14803
14849: POP
14850: POP
// CenterNowOnUnits ( Powell ) ;
14851: LD_EXP 55
14855: PPUSH
14856: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14860: LD_ADDR_VAR 0 5
14864: PUSH
14865: LD_EXP 53
14869: PUSH
14870: EMPTY
14871: LIST
14872: ST_TO_ADDR
// if GirlNewVeh then
14873: LD_EXP 54
14877: IFFALSE 14895
// tmp := tmp ^ GirlNewVeh ;
14879: LD_ADDR_VAR 0 5
14883: PUSH
14884: LD_VAR 0 5
14888: PUSH
14889: LD_EXP 54
14893: ADD
14894: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14895: LD_VAR 0 5
14899: PPUSH
14900: LD_INT 60
14902: PPUSH
14903: LD_INT 109
14905: PPUSH
14906: CALL_OW 111
// if KappaStatus then
14910: LD_EXP 2
14914: IFFALSE 14966
// begin Say ( JMM , D1nT-JMM-1 ) ;
14916: LD_EXP 36
14920: PPUSH
14921: LD_STRING D1nT-JMM-1
14923: PPUSH
14924: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14928: LD_EXP 55
14932: PPUSH
14933: LD_STRING D1T-Pow-1
14935: PPUSH
14936: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14940: LD_EXP 36
14944: PPUSH
14945: LD_STRING D1T-JMM-2
14947: PPUSH
14948: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14952: LD_EXP 55
14956: PPUSH
14957: LD_STRING D1T-Pow-2
14959: PPUSH
14960: CALL_OW 88
// end else
14964: GO 15172
// if JMMGirlStatus then
14966: LD_EXP 6
14970: IFFALSE 15115
// begin Say ( JMM , D1T-JMM-1 ) ;
14972: LD_EXP 36
14976: PPUSH
14977: LD_STRING D1T-JMM-1
14979: PPUSH
14980: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14984: LD_EXP 55
14988: PPUSH
14989: LD_STRING D1T-Pow-1
14991: PPUSH
14992: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
14996: LD_EXP 36
15000: PPUSH
15001: LD_STRING D1T-JMM-3
15003: PPUSH
15004: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15008: LD_EXP 55
15012: PPUSH
15013: LD_STRING D1T-Pow-3
15015: PPUSH
15016: CALL_OW 88
// if JMMGirl then
15020: LD_EXP 7
15024: IFFALSE 15113
// begin case JMMGirl of 1 :
15026: LD_EXP 7
15030: PUSH
15031: LD_INT 1
15033: DOUBLE
15034: EQUAL
15035: IFTRUE 15039
15037: GO 15054
15039: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15040: LD_EXP 37
15044: PPUSH
15045: LD_STRING D1T-Joan-3
15047: PPUSH
15048: CALL_OW 88
15052: GO 15101
15054: LD_INT 2
15056: DOUBLE
15057: EQUAL
15058: IFTRUE 15062
15060: GO 15077
15062: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15063: LD_EXP 39
15067: PPUSH
15068: LD_STRING D1T-Lisa-3
15070: PPUSH
15071: CALL_OW 88
15075: GO 15101
15077: LD_INT 3
15079: DOUBLE
15080: EQUAL
15081: IFTRUE 15085
15083: GO 15100
15085: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15086: LD_EXP 51
15090: PPUSH
15091: LD_STRING D1T-Con-3
15093: PPUSH
15094: CALL_OW 88
15098: GO 15101
15100: POP
// Say ( Powell , D1T-Pow-4 ) ;
15101: LD_EXP 55
15105: PPUSH
15106: LD_STRING D1T-Pow-4
15108: PPUSH
15109: CALL_OW 88
// end ; end else
15113: GO 15172
// if not FastEnd then
15115: LD_EXP 11
15119: NOT
15120: IFFALSE 15148
// begin Say ( JMM , D1T-JMM-4 ) ;
15122: LD_EXP 36
15126: PPUSH
15127: LD_STRING D1T-JMM-4
15129: PPUSH
15130: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15134: LD_EXP 55
15138: PPUSH
15139: LD_STRING D1T-Pow-5
15141: PPUSH
15142: CALL_OW 88
// end else
15146: GO 15172
// begin Say ( JMM , D1nT-JMM-1 ) ;
15148: LD_EXP 36
15152: PPUSH
15153: LD_STRING D1nT-JMM-1
15155: PPUSH
15156: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15160: LD_EXP 55
15164: PPUSH
15165: LD_STRING D1nT-Pow-1
15167: PPUSH
15168: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15172: LD_INT 35
15174: PPUSH
15175: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15179: LD_EXP 53
15183: PPUSH
15184: CALL_OW 314
15188: NOT
15189: IFFALSE 15172
// ComExitVehicle ( JMM ) ;
15191: LD_EXP 36
15195: PPUSH
15196: CALL_OW 121
// wait ( 3 ) ;
15200: LD_INT 3
15202: PPUSH
15203: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15207: LD_EXP 36
15211: PPUSH
15212: LD_INT 60
15214: PPUSH
15215: LD_INT 94
15217: PPUSH
15218: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15222: LD_EXP 36
15226: PPUSH
15227: LD_EXP 55
15231: PPUSH
15232: CALL_OW 179
// if Joan then
15236: LD_EXP 37
15240: IFFALSE 15294
// begin ComExitVehicle ( Joan ) ;
15242: LD_EXP 37
15246: PPUSH
15247: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15251: LD_EXP 37
15255: PPUSH
15256: LD_INT 35
15258: PPUSH
15259: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15263: LD_EXP 37
15267: PPUSH
15268: LD_INT 65
15270: PPUSH
15271: LD_INT 104
15273: PPUSH
15274: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15278: LD_EXP 37
15282: PPUSH
15283: LD_EXP 36
15287: PPUSH
15288: CALL_OW 179
// end else
15292: GO 15428
// if Lisa and JMMGirl = 2 then
15294: LD_EXP 39
15298: PUSH
15299: LD_EXP 7
15303: PUSH
15304: LD_INT 2
15306: EQUAL
15307: AND
15308: IFFALSE 15362
// begin ComExitVehicle ( Lisa ) ;
15310: LD_EXP 39
15314: PPUSH
15315: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15319: LD_EXP 39
15323: PPUSH
15324: LD_INT 35
15326: PPUSH
15327: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15331: LD_EXP 39
15335: PPUSH
15336: LD_INT 65
15338: PPUSH
15339: LD_INT 104
15341: PPUSH
15342: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15346: LD_EXP 39
15350: PPUSH
15351: LD_EXP 36
15355: PPUSH
15356: CALL_OW 179
// end else
15360: GO 15428
// if Connie and JMMGirl = 3 then
15362: LD_EXP 51
15366: PUSH
15367: LD_EXP 7
15371: PUSH
15372: LD_INT 3
15374: EQUAL
15375: AND
15376: IFFALSE 15428
// begin ComExitVehicle ( Connie ) ;
15378: LD_EXP 51
15382: PPUSH
15383: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15387: LD_EXP 51
15391: PPUSH
15392: LD_INT 35
15394: PPUSH
15395: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15399: LD_EXP 51
15403: PPUSH
15404: LD_INT 65
15406: PPUSH
15407: LD_INT 104
15409: PPUSH
15410: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15414: LD_EXP 51
15418: PPUSH
15419: LD_EXP 36
15423: PPUSH
15424: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15428: LD_INT 35
15430: PPUSH
15431: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15435: LD_EXP 36
15439: PPUSH
15440: LD_EXP 55
15444: PPUSH
15445: CALL_OW 296
15449: PUSH
15450: LD_INT 6
15452: LESS
15453: IFFALSE 15428
// wait ( 0 0$0.5 ) ;
15455: LD_INT 18
15457: PPUSH
15458: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15462: LD_EXP 36
15466: PPUSH
15467: LD_STRING D1-JMM-1
15469: PPUSH
15470: CALL_OW 88
// async ;
15474: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15475: LD_EXP 55
15479: PPUSH
15480: LD_STRING D1-Pow-1
15482: PPUSH
15483: CALL_OW 88
// if not dialogue_skipped then
15487: LD_OWVAR 59
15491: NOT
15492: IFFALSE 15501
// wait ( 0 0$2 ) ;
15494: LD_INT 70
15496: PPUSH
15497: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15501: LD_INT 170
15503: PPUSH
15504: LD_INT 99
15506: PPUSH
15507: LD_INT 1
15509: PPUSH
15510: LD_INT 6
15512: NEG
15513: PPUSH
15514: CALL 105210 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15518: LD_INT 174
15520: PPUSH
15521: LD_INT 115
15523: PPUSH
15524: LD_INT 1
15526: PPUSH
15527: LD_INT 6
15529: NEG
15530: PPUSH
15531: CALL 105210 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15535: LD_INT 169
15537: PPUSH
15538: LD_INT 71
15540: PPUSH
15541: LD_INT 1
15543: PPUSH
15544: LD_INT 6
15546: NEG
15547: PPUSH
15548: CALL 105210 0 4
// if not dialogue_skipped then
15552: LD_OWVAR 59
15556: NOT
15557: IFFALSE 15576
// begin CenterOnXY ( 170 , 99 ) ;
15559: LD_INT 170
15561: PPUSH
15562: LD_INT 99
15564: PPUSH
15565: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15569: LD_INT 80
15571: PPUSH
15572: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15576: LD_INT 75
15578: PPUSH
15579: LD_INT 53
15581: PPUSH
15582: LD_INT 1
15584: PPUSH
15585: LD_INT 9
15587: NEG
15588: PPUSH
15589: CALL 105210 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15593: LD_INT 54
15595: PPUSH
15596: LD_INT 42
15598: PPUSH
15599: LD_INT 1
15601: PPUSH
15602: LD_INT 9
15604: NEG
15605: PPUSH
15606: CALL 105210 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15610: LD_INT 62
15612: PPUSH
15613: LD_INT 51
15615: PPUSH
15616: LD_INT 1
15618: PPUSH
15619: LD_INT 9
15621: NEG
15622: PPUSH
15623: CALL 105210 0 4
// if not dialogue_skipped then
15627: LD_OWVAR 59
15631: NOT
15632: IFFALSE 15651
// begin CenterOnXY ( 75 , 53 ) ;
15634: LD_INT 75
15636: PPUSH
15637: LD_INT 53
15639: PPUSH
15640: CALL_OW 84
// wait ( 0 0$4 ) ;
15644: LD_INT 140
15646: PPUSH
15647: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15651: LD_EXP 55
15655: PPUSH
15656: CALL_OW 87
// if not dialogue_skipped then
15660: LD_OWVAR 59
15664: NOT
15665: IFFALSE 15674
// wait ( 0 0$2 ) ;
15667: LD_INT 70
15669: PPUSH
15670: CALL_OW 67
// sync ;
15674: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15675: LD_EXP 36
15679: PPUSH
15680: LD_STRING D1-JMM-2
15682: PPUSH
15683: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15687: LD_EXP 55
15691: PPUSH
15692: LD_STRING D1-Pow-2
15694: PPUSH
15695: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15699: LD_EXP 36
15703: PPUSH
15704: LD_STRING D1-JMM-3
15706: PPUSH
15707: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15711: LD_EXP 55
15715: PPUSH
15716: LD_STRING D1-Pow-3
15718: PPUSH
15719: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15723: LD_EXP 36
15727: PPUSH
15728: LD_STRING D1-JMM-4
15730: PPUSH
15731: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15735: LD_EXP 55
15739: PPUSH
15740: LD_STRING D1-Pow-4
15742: PPUSH
15743: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15747: LD_EXP 36
15751: PPUSH
15752: LD_STRING D1-JMM-5
15754: PPUSH
15755: CALL_OW 88
// async ;
15759: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15760: LD_EXP 55
15764: PPUSH
15765: LD_STRING D1-Pow-5
15767: PPUSH
15768: CALL_OW 88
// if not dialogue_skipped then
15772: LD_OWVAR 59
15776: NOT
15777: IFFALSE 15786
// wait ( 0 0$3.6 ) ;
15779: LD_INT 126
15781: PPUSH
15782: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15786: LD_INT 134
15788: PPUSH
15789: LD_INT 210
15791: PPUSH
15792: LD_INT 1
15794: PPUSH
15795: LD_INT 11
15797: NEG
15798: PPUSH
15799: CALL 105210 0 4
// if not dialogue_skipped then
15803: LD_OWVAR 59
15807: NOT
15808: IFFALSE 15827
// begin CenterOnXY ( 134 , 210 ) ;
15810: LD_INT 134
15812: PPUSH
15813: LD_INT 210
15815: PPUSH
15816: CALL_OW 84
// wait ( 0 0$2 ) ;
15820: LD_INT 70
15822: PPUSH
15823: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15827: LD_INT 101
15829: PPUSH
15830: LD_INT 159
15832: PPUSH
15833: LD_INT 1
15835: PPUSH
15836: LD_INT 10
15838: NEG
15839: PPUSH
15840: CALL 105210 0 4
// if not dialogue_skipped then
15844: LD_OWVAR 59
15848: NOT
15849: IFFALSE 15868
// begin CenterOnXY ( 101 , 159 ) ;
15851: LD_INT 101
15853: PPUSH
15854: LD_INT 159
15856: PPUSH
15857: CALL_OW 84
// wait ( 0 0$2 ) ;
15861: LD_INT 70
15863: PPUSH
15864: CALL_OW 67
// end ; sync ;
15868: SYNC
// CenterNowOnUnits ( Powell ) ;
15869: LD_EXP 55
15873: PPUSH
15874: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15878: LD_ADDR_VAR 0 6
15882: PUSH
15883: LD_INT 1
15885: PUSH
15886: LD_INT 2
15888: PUSH
15889: LD_INT 3
15891: PUSH
15892: LD_INT 4
15894: PUSH
15895: LD_INT 5
15897: PUSH
15898: LD_INT 6
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: LIST
15905: LIST
15906: LIST
15907: LIST
15908: ST_TO_ADDR
// if not dialogue_skipped then
15909: LD_OWVAR 59
15913: NOT
15914: IFFALSE 16083
// begin game_speed := 4 ;
15916: LD_ADDR_OWVAR 65
15920: PUSH
15921: LD_INT 4
15923: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15924: LD_INT 210
15926: PPUSH
15927: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15931: LD_ADDR_VAR 0 7
15935: PUSH
15936: LD_STRING Q1
15938: PPUSH
15939: LD_VAR 0 6
15943: PPUSH
15944: CALL_OW 98
15948: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15949: LD_ADDR_VAR 0 7
15953: PUSH
15954: LD_STRING Q1
15956: PPUSH
15957: LD_VAR 0 6
15961: PPUSH
15962: CALL_OW 98
15966: ST_TO_ADDR
// options = options diff dec ;
15967: LD_ADDR_VAR 0 6
15971: PUSH
15972: LD_VAR 0 6
15976: PUSH
15977: LD_VAR 0 7
15981: DIFF
15982: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15983: LD_VAR 0 7
15987: PPUSH
15988: LD_VAR 0 6
15992: PPUSH
15993: CALL 17386 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
15997: LD_VAR 0 7
16001: PUSH
16002: LD_INT 5
16004: PUSH
16005: LD_INT 6
16007: PUSH
16008: EMPTY
16009: LIST
16010: LIST
16011: IN
16012: PUSH
16013: LD_VAR 0 6
16017: PUSH
16018: LD_INT 2
16020: EQUAL
16021: OR
16022: IFFALSE 15949
// if not ( dec in [ 5 , 6 ] ) then
16024: LD_VAR 0 7
16028: PUSH
16029: LD_INT 5
16031: PUSH
16032: LD_INT 6
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: IN
16039: NOT
16040: IFFALSE 16083
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16042: LD_ADDR_VAR 0 7
16046: PUSH
16047: LD_STRING Q1a
16049: PPUSH
16050: LD_INT 1
16052: PUSH
16053: LD_INT 2
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: PPUSH
16060: CALL_OW 98
16064: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16065: LD_VAR 0 7
16069: PUSH
16070: LD_INT 4
16072: PLUS
16073: PPUSH
16074: LD_VAR 0 6
16078: PPUSH
16079: CALL 17386 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16083: LD_INT 81
16085: PPUSH
16086: LD_INT 127
16088: PPUSH
16089: CALL_OW 84
// amount := 5 ;
16093: LD_ADDR_VAR 0 8
16097: PUSH
16098: LD_INT 5
16100: ST_TO_ADDR
// macmilan_squad := [ ] ;
16101: LD_ADDR_VAR 0 9
16105: PUSH
16106: EMPTY
16107: ST_TO_ADDR
// if vip < amount then
16108: LD_EXP 56
16112: PUSH
16113: LD_VAR 0 8
16117: LESS
16118: IFFALSE 16162
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16120: LD_ADDR_VAR 0 5
16124: PUSH
16125: LD_EXP 56
16129: PUSH
16130: LD_INT 22
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: PUSH
16140: LD_INT 21
16142: PUSH
16143: LD_INT 1
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: PPUSH
16154: CALL_OW 69
16158: UNION
16159: ST_TO_ADDR
16160: GO 16172
// tmp := vip ;
16162: LD_ADDR_VAR 0 5
16166: PUSH
16167: LD_EXP 56
16171: ST_TO_ADDR
// tmp := tmp diff Powell ;
16172: LD_ADDR_VAR 0 5
16176: PUSH
16177: LD_VAR 0 5
16181: PUSH
16182: LD_EXP 55
16186: DIFF
16187: ST_TO_ADDR
// if tmp < amount then
16188: LD_VAR 0 5
16192: PUSH
16193: LD_VAR 0 8
16197: LESS
16198: IFFALSE 16210
// amount := tmp ;
16200: LD_ADDR_VAR 0 8
16204: PUSH
16205: LD_VAR 0 5
16209: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16210: LD_VAR 0 5
16214: PUSH
16215: LD_INT 1
16217: ARRAY
16218: PPUSH
16219: CALL_OW 257
16223: PUSH
16224: LD_INT 2
16226: NONEQUAL
16227: IFFALSE 16289
// begin if IsInUnit ( tmp [ 1 ] ) then
16229: LD_VAR 0 5
16233: PUSH
16234: LD_INT 1
16236: ARRAY
16237: PPUSH
16238: CALL_OW 310
16242: IFFALSE 16257
// ComExitBuilding ( tmp [ 1 ] ) ;
16244: LD_VAR 0 5
16248: PUSH
16249: LD_INT 1
16251: ARRAY
16252: PPUSH
16253: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16257: LD_VAR 0 5
16261: PUSH
16262: LD_INT 1
16264: ARRAY
16265: PPUSH
16266: LD_INT 387
16268: PPUSH
16269: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16273: LD_VAR 0 5
16277: PUSH
16278: LD_INT 1
16280: ARRAY
16281: PPUSH
16282: LD_INT 2
16284: PPUSH
16285: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16289: LD_EXP 36
16293: PPUSH
16294: LD_INT 82
16296: PPUSH
16297: LD_INT 129
16299: PPUSH
16300: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16304: LD_EXP 36
16308: PPUSH
16309: LD_EXP 55
16313: PPUSH
16314: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16318: LD_INT 22
16320: PUSH
16321: LD_INT 1
16323: PUSH
16324: EMPTY
16325: LIST
16326: LIST
16327: PPUSH
16328: CALL_OW 69
16332: PUSH
16333: LD_EXP 36
16337: DIFF
16338: PPUSH
16339: LD_INT 84
16341: PPUSH
16342: LD_INT 128
16344: PPUSH
16345: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16349: LD_INT 22
16351: PUSH
16352: LD_INT 1
16354: PUSH
16355: EMPTY
16356: LIST
16357: LIST
16358: PPUSH
16359: CALL_OW 69
16363: PUSH
16364: LD_EXP 36
16368: DIFF
16369: PPUSH
16370: LD_EXP 36
16374: PPUSH
16375: CALL_OW 179
// for i = 1 to amount do
16379: LD_ADDR_VAR 0 2
16383: PUSH
16384: DOUBLE
16385: LD_INT 1
16387: DEC
16388: ST_TO_ADDR
16389: LD_VAR 0 8
16393: PUSH
16394: FOR_TO
16395: IFFALSE 16563
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16397: LD_ADDR_VAR 0 9
16401: PUSH
16402: LD_VAR 0 9
16406: PUSH
16407: LD_VAR 0 5
16411: PUSH
16412: LD_VAR 0 2
16416: ARRAY
16417: ADD
16418: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16419: LD_VAR 0 5
16423: PUSH
16424: LD_VAR 0 2
16428: ARRAY
16429: PPUSH
16430: CALL_OW 310
16434: IFFALSE 16451
// AddComExitBuilding ( tmp [ i ] ) ;
16436: LD_VAR 0 5
16440: PUSH
16441: LD_VAR 0 2
16445: ARRAY
16446: PPUSH
16447: CALL_OW 182
// if i = 2 and JMMNewVeh then
16451: LD_VAR 0 2
16455: PUSH
16456: LD_INT 2
16458: EQUAL
16459: PUSH
16460: LD_EXP 53
16464: AND
16465: IFFALSE 16523
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16467: LD_VAR 0 5
16471: PUSH
16472: LD_VAR 0 2
16476: ARRAY
16477: PPUSH
16478: LD_EXP 53
16482: PPUSH
16483: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16487: LD_VAR 0 5
16491: PUSH
16492: LD_VAR 0 2
16496: ARRAY
16497: PPUSH
16498: LD_INT 86
16500: PPUSH
16501: LD_INT 133
16503: PPUSH
16504: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16508: LD_VAR 0 5
16512: PUSH
16513: LD_VAR 0 2
16517: ARRAY
16518: PPUSH
16519: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16523: LD_VAR 0 5
16527: PUSH
16528: LD_VAR 0 2
16532: ARRAY
16533: PPUSH
16534: LD_INT 8
16536: PPUSH
16537: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16541: LD_VAR 0 5
16545: PUSH
16546: LD_VAR 0 2
16550: ARRAY
16551: PPUSH
16552: LD_EXP 36
16556: PPUSH
16557: CALL_OW 179
// end ;
16561: GO 16394
16563: POP
16564: POP
// if GirlNewVeh then
16565: LD_EXP 54
16569: IFFALSE 16583
// SetSide ( GirlNewVeh , 4 ) ;
16571: LD_EXP 54
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16583: LD_INT 35
16585: PPUSH
16586: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16590: LD_VAR 0 9
16594: PPUSH
16595: LD_INT 95
16597: PUSH
16598: LD_INT 9
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: PPUSH
16605: CALL_OW 72
16609: PUSH
16610: LD_INT 0
16612: EQUAL
16613: PUSH
16614: LD_EXP 36
16618: PPUSH
16619: LD_INT 9
16621: PPUSH
16622: CALL_OW 308
16626: NOT
16627: AND
16628: IFFALSE 16583
// wait ( 0 0$2 ) ;
16630: LD_INT 70
16632: PPUSH
16633: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16637: LD_VAR 0 9
16641: PPUSH
16642: LD_INT 1
16644: PPUSH
16645: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16649: LD_INT 21
16651: PUSH
16652: LD_INT 2
16654: PUSH
16655: EMPTY
16656: LIST
16657: LIST
16658: PUSH
16659: LD_INT 92
16661: PUSH
16662: LD_INT 83
16664: PUSH
16665: LD_INT 130
16667: PUSH
16668: LD_INT 10
16670: PUSH
16671: EMPTY
16672: LIST
16673: LIST
16674: LIST
16675: LIST
16676: PUSH
16677: EMPTY
16678: LIST
16679: LIST
16680: PPUSH
16681: CALL_OW 69
16685: PPUSH
16686: LD_INT 1
16688: PPUSH
16689: CALL_OW 235
// Video ( false ) ;
16693: LD_INT 0
16695: PPUSH
16696: CALL 105296 0 1
// ChangeMissionObjectives ( M1 ) ;
16700: LD_STRING M1
16702: PPUSH
16703: CALL_OW 337
// SaveForQuickRestart ;
16707: CALL_OW 22
// missionStart := true ;
16711: LD_ADDR_EXP 13
16715: PUSH
16716: LD_INT 1
16718: ST_TO_ADDR
// missionStage := 2 ;
16719: LD_ADDR_EXP 15
16723: PUSH
16724: LD_INT 2
16726: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16727: LD_INT 105
16729: PPUSH
16730: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16734: LD_ADDR_VAR 0 5
16738: PUSH
16739: LD_INT 22
16741: PUSH
16742: LD_INT 4
16744: PUSH
16745: EMPTY
16746: LIST
16747: LIST
16748: PUSH
16749: LD_INT 21
16751: PUSH
16752: LD_INT 1
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: PPUSH
16763: CALL_OW 69
16767: PUSH
16768: LD_EXP 55
16772: DIFF
16773: ST_TO_ADDR
// if not tmp then
16774: LD_VAR 0 5
16778: NOT
16779: IFFALSE 16794
// tmp := [ Powell ] ;
16781: LD_ADDR_VAR 0 5
16785: PUSH
16786: LD_EXP 55
16790: PUSH
16791: EMPTY
16792: LIST
16793: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16794: LD_ADDR_EXP 99
16798: PUSH
16799: LD_EXP 99
16803: PPUSH
16804: LD_INT 4
16806: PPUSH
16807: LD_INT 22
16809: PUSH
16810: LD_INT 4
16812: PUSH
16813: EMPTY
16814: LIST
16815: LIST
16816: PUSH
16817: LD_INT 23
16819: PUSH
16820: LD_INT 1
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: PUSH
16827: LD_INT 3
16829: PUSH
16830: LD_INT 21
16832: PUSH
16833: LD_INT 2
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: LIST
16848: PPUSH
16849: CALL_OW 69
16853: PUSH
16854: LD_EXP 55
16858: DIFF
16859: PPUSH
16860: CALL_OW 1
16864: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16865: LD_ADDR_VAR 0 4
16869: PUSH
16870: LD_INT 22
16872: PUSH
16873: LD_INT 4
16875: PUSH
16876: EMPTY
16877: LIST
16878: LIST
16879: PUSH
16880: LD_INT 34
16882: PUSH
16883: LD_INT 12
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PPUSH
16894: CALL_OW 69
16898: PUSH
16899: LD_INT 1
16901: ARRAY
16902: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16903: LD_VAR 0 5
16907: PUSH
16908: LD_INT 1
16910: ARRAY
16911: PPUSH
16912: CALL_OW 310
16916: IFFALSE 16931
// ComExitBuilding ( tmp [ 1 ] ) ;
16918: LD_VAR 0 5
16922: PUSH
16923: LD_INT 1
16925: ARRAY
16926: PPUSH
16927: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16931: LD_VAR 0 5
16935: PUSH
16936: LD_INT 1
16938: ARRAY
16939: PPUSH
16940: LD_VAR 0 4
16944: PPUSH
16945: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16949: LD_VAR 0 5
16953: PUSH
16954: LD_INT 1
16956: ARRAY
16957: PPUSH
16958: LD_INT 80
16960: PPUSH
16961: LD_INT 136
16963: PPUSH
16964: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16968: LD_VAR 0 5
16972: PUSH
16973: LD_INT 1
16975: ARRAY
16976: PPUSH
16977: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16981: LD_VAR 0 5
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: PPUSH
16990: LD_INT 59
16992: PPUSH
16993: LD_INT 112
16995: PPUSH
16996: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17000: LD_VAR 0 5
17004: PUSH
17005: LD_INT 1
17007: ARRAY
17008: PPUSH
17009: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17013: LD_EXP 39
17017: PUSH
17018: LD_EXP 56
17022: IN
17023: PUSH
17024: LD_EXP 39
17028: PPUSH
17029: CALL_OW 255
17033: PUSH
17034: LD_INT 1
17036: EQUAL
17037: AND
17038: IFFALSE 17054
// Say ( Lisa , D3nW-Lisa-1 ) else
17040: LD_EXP 39
17044: PPUSH
17045: LD_STRING D3nW-Lisa-1
17047: PPUSH
17048: CALL_OW 88
17052: GO 17298
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17054: LD_EXP 42
17058: PUSH
17059: LD_EXP 56
17063: IN
17064: PUSH
17065: LD_EXP 42
17069: PPUSH
17070: CALL_OW 255
17074: PUSH
17075: LD_INT 1
17077: EQUAL
17078: AND
17079: IFFALSE 17095
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17081: LD_EXP 42
17085: PPUSH
17086: LD_STRING D3nW-Cyrus-1
17088: PPUSH
17089: CALL_OW 88
17093: GO 17298
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17095: LD_EXP 41
17099: PUSH
17100: LD_EXP 56
17104: IN
17105: PUSH
17106: LD_EXP 41
17110: PPUSH
17111: CALL_OW 255
17115: PUSH
17116: LD_INT 1
17118: EQUAL
17119: AND
17120: IFFALSE 17136
// Say ( Bobby , D3nW-Bobby-1 ) else
17122: LD_EXP 41
17126: PPUSH
17127: LD_STRING D3nW-Bobby-1
17129: PPUSH
17130: CALL_OW 88
17134: GO 17298
// if Gary in vip and GetSide ( Gary ) = 1 then
17136: LD_EXP 48
17140: PUSH
17141: LD_EXP 56
17145: IN
17146: PUSH
17147: LD_EXP 48
17151: PPUSH
17152: CALL_OW 255
17156: PUSH
17157: LD_INT 1
17159: EQUAL
17160: AND
17161: IFFALSE 17177
// Say ( Gary , D3nW-Gary-1 ) else
17163: LD_EXP 48
17167: PPUSH
17168: LD_STRING D3nW-Gary-1
17170: PPUSH
17171: CALL_OW 88
17175: GO 17298
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17177: LD_EXP 40
17181: PUSH
17182: LD_EXP 56
17186: IN
17187: PUSH
17188: LD_EXP 40
17192: PPUSH
17193: CALL_OW 255
17197: PUSH
17198: LD_INT 1
17200: EQUAL
17201: AND
17202: IFFALSE 17218
// Say ( Donaldson , D3nW-Don-1 ) else
17204: LD_EXP 40
17208: PPUSH
17209: LD_STRING D3nW-Don-1
17211: PPUSH
17212: CALL_OW 88
17216: GO 17298
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17218: LD_EXP 47
17222: PUSH
17223: LD_EXP 56
17227: IN
17228: PUSH
17229: LD_EXP 47
17233: PPUSH
17234: CALL_OW 255
17238: PUSH
17239: LD_INT 1
17241: EQUAL
17242: AND
17243: IFFALSE 17259
// Say ( Cornel , D3nW-Corn-1 ) else
17245: LD_EXP 47
17249: PPUSH
17250: LD_STRING D3nW-Corn-1
17252: PPUSH
17253: CALL_OW 88
17257: GO 17298
// if Frank in vip and GetSide ( Frank ) = 1 then
17259: LD_EXP 49
17263: PUSH
17264: LD_EXP 56
17268: IN
17269: PUSH
17270: LD_EXP 49
17274: PPUSH
17275: CALL_OW 255
17279: PUSH
17280: LD_INT 1
17282: EQUAL
17283: AND
17284: IFFALSE 17298
// Say ( Frank , D3nW-Frank-1 ) ;
17286: LD_EXP 49
17290: PPUSH
17291: LD_STRING D3nW-Frank-1
17293: PPUSH
17294: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17298: LD_EXP 36
17302: PPUSH
17303: LD_STRING D3nW-JMM-1
17305: PPUSH
17306: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17310: LD_EXP 36
17314: PPUSH
17315: LD_STRING D3nW-JMM-1a
17317: PPUSH
17318: CALL_OW 88
// t := 0 0$00 ;
17322: LD_ADDR_VAR 0 3
17326: PUSH
17327: LD_INT 0
17329: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17330: LD_INT 35
17332: PPUSH
17333: CALL_OW 67
// t := t + 0 0$1 ;
17337: LD_ADDR_VAR 0 3
17341: PUSH
17342: LD_VAR 0 3
17346: PUSH
17347: LD_INT 35
17349: PLUS
17350: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17351: LD_INT 59
17353: PPUSH
17354: LD_INT 112
17356: PPUSH
17357: CALL_OW 428
17361: PUSH
17362: LD_VAR 0 3
17366: PUSH
17367: LD_INT 2100
17369: GREATER
17370: OR
17371: IFFALSE 17330
// activeAttacks := true ;
17373: LD_ADDR_EXP 16
17377: PUSH
17378: LD_INT 1
17380: ST_TO_ADDR
// end ;
17381: LD_VAR 0 1
17385: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17386: LD_INT 0
17388: PPUSH
// case question of 1 :
17389: LD_VAR 0 1
17393: PUSH
17394: LD_INT 1
17396: DOUBLE
17397: EQUAL
17398: IFTRUE 17402
17400: GO 17453
17402: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17403: LD_EXP 36
17407: PPUSH
17408: LD_STRING D2Mot-JMM-1
17410: PPUSH
17411: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17415: LD_EXP 55
17419: PPUSH
17420: LD_STRING D2Mot-Pow-1
17422: PPUSH
17423: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17427: LD_EXP 36
17431: PPUSH
17432: LD_STRING D2Mot-JMM-2
17434: PPUSH
17435: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17439: LD_EXP 55
17443: PPUSH
17444: LD_STRING D2Mot-Pow-2
17446: PPUSH
17447: CALL_OW 88
// end ; 2 :
17451: GO 17796
17453: LD_INT 2
17455: DOUBLE
17456: EQUAL
17457: IFTRUE 17461
17459: GO 17537
17461: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17462: LD_EXP 36
17466: PPUSH
17467: LD_STRING D2Rus-JMM-1
17469: PPUSH
17470: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17474: LD_EXP 55
17478: PPUSH
17479: LD_STRING D2Rus-Pow-1
17481: PPUSH
17482: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17486: LD_EXP 36
17490: PPUSH
17491: LD_STRING D2Rus-JMM-2
17493: PPUSH
17494: CALL_OW 88
// if not ( 3 in list_of_q ) then
17498: LD_INT 3
17500: PUSH
17501: LD_VAR 0 2
17505: IN
17506: NOT
17507: IFFALSE 17523
// Say ( Powell , D2Rus-Pow-2 ) else
17509: LD_EXP 55
17513: PPUSH
17514: LD_STRING D2Rus-Pow-2
17516: PPUSH
17517: CALL_OW 88
17521: GO 17535
// Say ( Powell , D2Rus-Pow-2a ) ;
17523: LD_EXP 55
17527: PPUSH
17528: LD_STRING D2Rus-Pow-2a
17530: PPUSH
17531: CALL_OW 88
// end ; 3 :
17535: GO 17796
17537: LD_INT 3
17539: DOUBLE
17540: EQUAL
17541: IFTRUE 17545
17543: GO 17630
17545: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17546: LD_EXP 36
17550: PPUSH
17551: LD_STRING D2Leg-JMM-1
17553: PPUSH
17554: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17558: LD_EXP 55
17562: PPUSH
17563: LD_STRING D2Leg-Pow-1
17565: PPUSH
17566: CALL_OW 88
// if 2 in list_of_q then
17570: LD_INT 2
17572: PUSH
17573: LD_VAR 0 2
17577: IN
17578: IFFALSE 17604
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17580: LD_EXP 36
17584: PPUSH
17585: LD_STRING D2Leg-JMM-2
17587: PPUSH
17588: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17592: LD_EXP 55
17596: PPUSH
17597: LD_STRING D2Leg-Pow-2
17599: PPUSH
17600: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17604: LD_EXP 36
17608: PPUSH
17609: LD_STRING D2Leg-JMM-3
17611: PPUSH
17612: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17616: LD_EXP 55
17620: PPUSH
17621: LD_STRING D2Leg-Pow-3
17623: PPUSH
17624: CALL_OW 88
// end ; 4 :
17628: GO 17796
17630: LD_INT 4
17632: DOUBLE
17633: EQUAL
17634: IFTRUE 17638
17636: GO 17713
17638: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17639: LD_EXP 36
17643: PPUSH
17644: LD_STRING D2Ar-JMM-1
17646: PPUSH
17647: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17651: LD_EXP 55
17655: PPUSH
17656: LD_STRING D2Ar-Pow-1
17658: PPUSH
17659: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17663: LD_EXP 36
17667: PPUSH
17668: LD_STRING D2Ar-JMM-2
17670: PPUSH
17671: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17675: LD_EXP 55
17679: PPUSH
17680: LD_STRING D2Ar-Pow-2
17682: PPUSH
17683: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17687: LD_EXP 36
17691: PPUSH
17692: LD_STRING D2Ar-JMM-3
17694: PPUSH
17695: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17699: LD_EXP 55
17703: PPUSH
17704: LD_STRING D2Ar-Pow-3
17706: PPUSH
17707: CALL_OW 88
// end ; 5 :
17711: GO 17796
17713: LD_INT 5
17715: DOUBLE
17716: EQUAL
17717: IFTRUE 17721
17719: GO 17736
17721: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17722: LD_EXP 36
17726: PPUSH
17727: LD_STRING D2Conf-JMM-1
17729: PPUSH
17730: CALL_OW 88
17734: GO 17796
17736: LD_INT 6
17738: DOUBLE
17739: EQUAL
17740: IFTRUE 17744
17742: GO 17795
17744: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17745: LD_EXP 36
17749: PPUSH
17750: LD_STRING D2Com-JMM-1
17752: PPUSH
17753: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17757: LD_EXP 55
17761: PPUSH
17762: LD_STRING D2Com-Pow-1
17764: PPUSH
17765: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17769: LD_EXP 36
17773: PPUSH
17774: LD_STRING D2Com-JMM-2
17776: PPUSH
17777: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17781: LD_EXP 55
17785: PPUSH
17786: LD_STRING D2Com-Pow-2
17788: PPUSH
17789: CALL_OW 88
// end ; end ;
17793: GO 17796
17795: POP
// end ;
17796: LD_VAR 0 3
17800: RET
// every 0 0$5 trigger missionStart do var tmp ;
17801: LD_EXP 13
17805: IFFALSE 18088
17807: GO 17809
17809: DISABLE
17810: LD_INT 0
17812: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17813: LD_INT 35
17815: PPUSH
17816: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17820: LD_INT 14
17822: PPUSH
17823: LD_INT 22
17825: PUSH
17826: LD_INT 1
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: PPUSH
17833: CALL_OW 70
17837: PUSH
17838: LD_EXP 15
17842: PUSH
17843: LD_INT 2
17845: PUSH
17846: LD_INT 3
17848: PUSH
17849: LD_INT 4
17851: PUSH
17852: LD_INT 5
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: LIST
17859: LIST
17860: IN
17861: AND
17862: IFFALSE 18078
// begin powellAnger := powellAnger + 1 ;
17864: LD_ADDR_EXP 17
17868: PUSH
17869: LD_EXP 17
17873: PUSH
17874: LD_INT 1
17876: PLUS
17877: ST_TO_ADDR
// Video ( true ) ;
17878: LD_INT 1
17880: PPUSH
17881: CALL 105296 0 1
// CenterNowOnUnits ( tmp ) ;
17885: LD_VAR 0 1
17889: PPUSH
17890: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17894: LD_INT 14
17896: PPUSH
17897: LD_INT 22
17899: PUSH
17900: LD_INT 1
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PPUSH
17907: CALL_OW 70
17911: PPUSH
17912: LD_INT 86
17914: PPUSH
17915: LD_INT 133
17917: PPUSH
17918: CALL_OW 111
// async ;
17922: ASYNC
// case powellAnger of 1 :
17923: LD_EXP 17
17927: PUSH
17928: LD_INT 1
17930: DOUBLE
17931: EQUAL
17932: IFTRUE 17936
17934: GO 17951
17936: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17937: LD_EXP 55
17941: PPUSH
17942: LD_STRING DBack1-Pow-1
17944: PPUSH
17945: CALL_OW 88
17949: GO 17998
17951: LD_INT 2
17953: DOUBLE
17954: EQUAL
17955: IFTRUE 17959
17957: GO 17974
17959: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17960: LD_EXP 55
17964: PPUSH
17965: LD_STRING DBack2-Pow-1
17967: PPUSH
17968: CALL_OW 88
17972: GO 17998
17974: LD_INT 3
17976: DOUBLE
17977: EQUAL
17978: IFTRUE 17982
17980: GO 17997
17982: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17983: LD_EXP 55
17987: PPUSH
17988: LD_STRING DBack3-Pow-1
17990: PPUSH
17991: CALL_OW 88
17995: GO 17998
17997: POP
// sync ;
17998: SYNC
// repeat wait ( 0 0$1 ) ;
17999: LD_INT 35
18001: PPUSH
18002: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18006: LD_INT 14
18008: PPUSH
18009: LD_INT 22
18011: PUSH
18012: LD_INT 1
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PPUSH
18019: CALL_OW 70
18023: PPUSH
18024: LD_INT 86
18026: PPUSH
18027: LD_INT 133
18029: PPUSH
18030: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18034: LD_INT 14
18036: PPUSH
18037: LD_INT 22
18039: PUSH
18040: LD_INT 1
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: PPUSH
18047: CALL_OW 70
18051: NOT
18052: IFFALSE 17999
// if powellAnger >= 3 then
18054: LD_EXP 17
18058: PUSH
18059: LD_INT 3
18061: GREATEREQUAL
18062: IFFALSE 18071
// YouLost ( Dismissed ) ;
18064: LD_STRING Dismissed
18066: PPUSH
18067: CALL_OW 104
// Video ( false ) ;
18071: LD_INT 0
18073: PPUSH
18074: CALL 105296 0 1
// end ; until missionStage > 5 ;
18078: LD_EXP 15
18082: PUSH
18083: LD_INT 5
18085: GREATER
18086: IFFALSE 17813
// end ;
18088: PPOPN 1
18090: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18091: LD_EXP 13
18095: PUSH
18096: LD_INT 22
18098: PUSH
18099: LD_INT 4
18101: PUSH
18102: EMPTY
18103: LIST
18104: LIST
18105: PUSH
18106: LD_INT 21
18108: PUSH
18109: LD_INT 2
18111: PUSH
18112: EMPTY
18113: LIST
18114: LIST
18115: PUSH
18116: EMPTY
18117: LIST
18118: LIST
18119: PPUSH
18120: CALL_OW 69
18124: PUSH
18125: LD_INT 4
18127: GREATEREQUAL
18128: AND
18129: PUSH
18130: LD_EXP 15
18134: PUSH
18135: LD_INT 2
18137: EQUAL
18138: AND
18139: IFFALSE 19962
18141: GO 18143
18143: DISABLE
18144: LD_INT 0
18146: PPUSH
18147: PPUSH
18148: PPUSH
18149: PPUSH
18150: PPUSH
18151: PPUSH
18152: PPUSH
18153: PPUSH
// begin missionStage := 3 ;
18154: LD_ADDR_EXP 15
18158: PUSH
18159: LD_INT 3
18161: ST_TO_ADDR
// retreat := false ;
18162: LD_ADDR_VAR 0 4
18166: PUSH
18167: LD_INT 0
18169: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18170: LD_ADDR_VAR 0 5
18174: PUSH
18175: LD_INT 22
18177: PUSH
18178: LD_INT 4
18180: PUSH
18181: EMPTY
18182: LIST
18183: LIST
18184: PUSH
18185: LD_INT 30
18187: PUSH
18188: LD_INT 4
18190: PUSH
18191: EMPTY
18192: LIST
18193: LIST
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: PPUSH
18199: CALL_OW 69
18203: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18204: LD_ADDR_VAR 0 6
18208: PUSH
18209: LD_INT 22
18211: PUSH
18212: LD_INT 4
18214: PUSH
18215: EMPTY
18216: LIST
18217: LIST
18218: PUSH
18219: LD_INT 30
18221: PUSH
18222: LD_INT 5
18224: PUSH
18225: EMPTY
18226: LIST
18227: LIST
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PPUSH
18233: CALL_OW 69
18237: ST_TO_ADDR
// if not bar then
18238: LD_VAR 0 6
18242: NOT
18243: IFFALSE 18296
// begin repeat wait ( 0 0$1 ) ;
18245: LD_INT 35
18247: PPUSH
18248: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18252: LD_INT 22
18254: PUSH
18255: LD_INT 4
18257: PUSH
18258: EMPTY
18259: LIST
18260: LIST
18261: PUSH
18262: LD_INT 3
18264: PUSH
18265: LD_INT 57
18267: PUSH
18268: EMPTY
18269: LIST
18270: PUSH
18271: EMPTY
18272: LIST
18273: LIST
18274: PUSH
18275: LD_INT 30
18277: PUSH
18278: LD_INT 5
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: PUSH
18285: EMPTY
18286: LIST
18287: LIST
18288: LIST
18289: PPUSH
18290: CALL_OW 69
18294: IFFALSE 18245
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18296: LD_ADDR_VAR 0 6
18300: PUSH
18301: LD_INT 22
18303: PUSH
18304: LD_INT 4
18306: PUSH
18307: EMPTY
18308: LIST
18309: LIST
18310: PUSH
18311: LD_INT 30
18313: PUSH
18314: LD_INT 5
18316: PUSH
18317: EMPTY
18318: LIST
18319: LIST
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 69
18329: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18330: LD_INT 35
18332: PPUSH
18333: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18337: LD_EXP 118
18341: PUSH
18342: LD_INT 4
18344: ARRAY
18345: PUSH
18346: LD_INT 4
18348: GREATEREQUAL
18349: IFFALSE 18330
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18351: LD_ADDR_VAR 0 2
18355: PUSH
18356: LD_INT 22
18358: PUSH
18359: LD_INT 4
18361: PUSH
18362: EMPTY
18363: LIST
18364: LIST
18365: PUSH
18366: LD_INT 2
18368: PUSH
18369: LD_INT 25
18371: PUSH
18372: LD_INT 1
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: PUSH
18379: LD_INT 25
18381: PUSH
18382: LD_INT 2
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: PUSH
18389: LD_INT 25
18391: PUSH
18392: LD_INT 3
18394: PUSH
18395: EMPTY
18396: LIST
18397: LIST
18398: PUSH
18399: LD_INT 25
18401: PUSH
18402: LD_INT 4
18404: PUSH
18405: EMPTY
18406: LIST
18407: LIST
18408: PUSH
18409: LD_INT 25
18411: PUSH
18412: LD_INT 5
18414: PUSH
18415: EMPTY
18416: LIST
18417: LIST
18418: PUSH
18419: EMPTY
18420: LIST
18421: LIST
18422: LIST
18423: LIST
18424: LIST
18425: LIST
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: PPUSH
18431: CALL_OW 69
18435: PUSH
18436: LD_EXP 55
18440: PUSH
18441: LD_EXP 56
18445: ADD
18446: DIFF
18447: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18448: LD_ADDR_VAR 0 3
18452: PUSH
18453: LD_VAR 0 2
18457: PPUSH
18458: LD_INT 26
18460: PUSH
18461: LD_INT 1
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PPUSH
18468: CALL_OW 72
18472: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18473: LD_ADDR_VAR 0 2
18477: PUSH
18478: LD_VAR 0 2
18482: PUSH
18483: LD_VAR 0 3
18487: DIFF
18488: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18489: LD_ADDR_VAR 0 2
18493: PUSH
18494: LD_VAR 0 2
18498: PPUSH
18499: LD_INT 1
18501: PPUSH
18502: CALL 103949 0 2
18506: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18507: LD_ADDR_VAR 0 3
18511: PUSH
18512: LD_VAR 0 3
18516: PPUSH
18517: LD_INT 1
18519: PPUSH
18520: CALL 103949 0 2
18524: ST_TO_ADDR
// for i = 1 to 4 do
18525: LD_ADDR_VAR 0 1
18529: PUSH
18530: DOUBLE
18531: LD_INT 1
18533: DEC
18534: ST_TO_ADDR
18535: LD_INT 4
18537: PUSH
18538: FOR_TO
18539: IFFALSE 18705
// begin if tmp2 then
18541: LD_VAR 0 3
18545: IFFALSE 18626
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18547: LD_ADDR_EXP 18
18551: PUSH
18552: LD_EXP 18
18556: PPUSH
18557: LD_INT 1
18559: PPUSH
18560: LD_EXP 18
18564: PUSH
18565: LD_INT 1
18567: ARRAY
18568: PUSH
18569: LD_VAR 0 3
18573: PUSH
18574: LD_VAR 0 3
18578: ARRAY
18579: ADD
18580: PPUSH
18581: CALL_OW 1
18585: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18586: LD_VAR 0 3
18590: PUSH
18591: LD_VAR 0 3
18595: ARRAY
18596: PPUSH
18597: LD_INT 1
18599: PPUSH
18600: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18604: LD_ADDR_VAR 0 3
18608: PUSH
18609: LD_VAR 0 3
18613: PPUSH
18614: LD_VAR 0 3
18618: PPUSH
18619: CALL_OW 3
18623: ST_TO_ADDR
// end else
18624: GO 18703
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18626: LD_ADDR_EXP 18
18630: PUSH
18631: LD_EXP 18
18635: PPUSH
18636: LD_INT 1
18638: PPUSH
18639: LD_EXP 18
18643: PUSH
18644: LD_INT 1
18646: ARRAY
18647: PUSH
18648: LD_VAR 0 2
18652: PUSH
18653: LD_VAR 0 2
18657: ARRAY
18658: ADD
18659: PPUSH
18660: CALL_OW 1
18664: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18665: LD_VAR 0 2
18669: PUSH
18670: LD_VAR 0 2
18674: ARRAY
18675: PPUSH
18676: LD_INT 1
18678: PPUSH
18679: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18683: LD_ADDR_VAR 0 2
18687: PUSH
18688: LD_VAR 0 2
18692: PPUSH
18693: LD_VAR 0 2
18697: PPUSH
18698: CALL_OW 3
18702: ST_TO_ADDR
// end ; end ;
18703: GO 18538
18705: POP
18706: POP
// if tmp2 then
18707: LD_VAR 0 3
18711: IFFALSE 18729
// tmp := tmp union tmp2 ;
18713: LD_ADDR_VAR 0 2
18717: PUSH
18718: LD_VAR 0 2
18722: PUSH
18723: LD_VAR 0 3
18727: UNION
18728: ST_TO_ADDR
// for i = 1 to 4 do
18729: LD_ADDR_VAR 0 1
18733: PUSH
18734: DOUBLE
18735: LD_INT 1
18737: DEC
18738: ST_TO_ADDR
18739: LD_INT 4
18741: PUSH
18742: FOR_TO
18743: IFFALSE 18792
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18745: LD_ADDR_EXP 18
18749: PUSH
18750: LD_EXP 18
18754: PPUSH
18755: LD_INT 2
18757: PPUSH
18758: LD_EXP 18
18762: PUSH
18763: LD_INT 2
18765: ARRAY
18766: PUSH
18767: LD_VAR 0 2
18771: PUSH
18772: LD_VAR 0 2
18776: PUSH
18777: LD_VAR 0 1
18781: MINUS
18782: ARRAY
18783: ADD
18784: PPUSH
18785: CALL_OW 1
18789: ST_TO_ADDR
18790: GO 18742
18792: POP
18793: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18794: LD_ADDR_EXP 99
18798: PUSH
18799: LD_EXP 99
18803: PPUSH
18804: LD_INT 4
18806: PPUSH
18807: LD_EXP 99
18811: PUSH
18812: LD_INT 4
18814: ARRAY
18815: PUSH
18816: LD_EXP 18
18820: PUSH
18821: LD_INT 1
18823: ARRAY
18824: DIFF
18825: PPUSH
18826: CALL_OW 1
18830: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18831: LD_VAR 0 5
18835: PUSH
18836: LD_INT 1
18838: ARRAY
18839: PPUSH
18840: CALL_OW 313
18844: IFFALSE 18899
// begin for i in UnitsInside ( arm [ 1 ] ) do
18846: LD_ADDR_VAR 0 1
18850: PUSH
18851: LD_VAR 0 5
18855: PUSH
18856: LD_INT 1
18858: ARRAY
18859: PPUSH
18860: CALL_OW 313
18864: PUSH
18865: FOR_IN
18866: IFFALSE 18897
// begin ComExitBuilding ( i ) ;
18868: LD_VAR 0 1
18872: PPUSH
18873: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18877: LD_VAR 0 1
18881: PPUSH
18882: LD_VAR 0 6
18886: PUSH
18887: LD_INT 1
18889: ARRAY
18890: PPUSH
18891: CALL_OW 180
// end ;
18895: GO 18865
18897: POP
18898: POP
// end ; wait ( 0 0$3 ) ;
18899: LD_INT 105
18901: PPUSH
18902: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18906: LD_ADDR_VAR 0 1
18910: PUSH
18911: LD_EXP 18
18915: PUSH
18916: LD_INT 1
18918: ARRAY
18919: PUSH
18920: FOR_IN
18921: IFFALSE 19028
// begin if IsInUnit ( i ) then
18923: LD_VAR 0 1
18927: PPUSH
18928: CALL_OW 310
18932: IFFALSE 18943
// ComExitBuilding ( i ) ;
18934: LD_VAR 0 1
18938: PPUSH
18939: CALL_OW 122
// if GetClass ( i ) <> 1 then
18943: LD_VAR 0 1
18947: PPUSH
18948: CALL_OW 257
18952: PUSH
18953: LD_INT 1
18955: NONEQUAL
18956: IFFALSE 18997
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18958: LD_VAR 0 1
18962: PPUSH
18963: LD_VAR 0 5
18967: PUSH
18968: LD_INT 1
18970: ARRAY
18971: PPUSH
18972: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18976: LD_VAR 0 1
18980: PPUSH
18981: LD_INT 1
18983: PPUSH
18984: CALL_OW 183
// AddComExitBuilding ( i ) ;
18988: LD_VAR 0 1
18992: PPUSH
18993: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
18997: LD_VAR 0 1
19001: PPUSH
19002: LD_INT 60
19004: PPUSH
19005: LD_INT 94
19007: PPUSH
19008: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19012: LD_VAR 0 1
19016: PPUSH
19017: LD_EXP 55
19021: PPUSH
19022: CALL_OW 179
// end ;
19026: GO 18920
19028: POP
19029: POP
// wait ( 0 0$15 ) ;
19030: LD_INT 525
19032: PPUSH
19033: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19037: LD_EXP 55
19041: PPUSH
19042: LD_STRING D4-Pow-1
19044: PPUSH
19045: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19049: LD_ADDR_VAR 0 2
19053: PUSH
19054: LD_EXP 18
19058: PUSH
19059: LD_INT 1
19061: ARRAY
19062: PPUSH
19063: LD_INT 26
19065: PUSH
19066: LD_INT 1
19068: PUSH
19069: EMPTY
19070: LIST
19071: LIST
19072: PPUSH
19073: CALL_OW 72
19077: ST_TO_ADDR
// if tmp then
19078: LD_VAR 0 2
19082: IFFALSE 19100
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19084: LD_VAR 0 2
19088: PUSH
19089: LD_INT 1
19091: ARRAY
19092: PPUSH
19093: LD_STRING D4-Sol1-1
19095: PPUSH
19096: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19100: LD_EXP 55
19104: PPUSH
19105: LD_STRING D4-Pow-2
19107: PPUSH
19108: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19112: LD_ADDR_VAR 0 1
19116: PUSH
19117: DOUBLE
19118: LD_INT 1
19120: DEC
19121: ST_TO_ADDR
19122: LD_EXP 18
19126: PUSH
19127: LD_INT 1
19129: ARRAY
19130: PUSH
19131: FOR_TO
19132: IFFALSE 19225
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19134: LD_EXP 18
19138: PUSH
19139: LD_INT 1
19141: ARRAY
19142: PUSH
19143: LD_VAR 0 1
19147: ARRAY
19148: PPUSH
19149: LD_EXP 118
19153: PUSH
19154: LD_INT 4
19156: ARRAY
19157: PUSH
19158: LD_INT 1
19160: ARRAY
19161: PPUSH
19162: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19166: LD_ADDR_EXP 118
19170: PUSH
19171: LD_EXP 118
19175: PPUSH
19176: LD_INT 4
19178: PPUSH
19179: LD_EXP 118
19183: PUSH
19184: LD_INT 4
19186: ARRAY
19187: PPUSH
19188: LD_INT 1
19190: PPUSH
19191: CALL_OW 3
19195: PPUSH
19196: CALL_OW 1
19200: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19201: LD_INT 8
19203: PPUSH
19204: LD_EXP 18
19208: PUSH
19209: LD_INT 1
19211: ARRAY
19212: PUSH
19213: LD_VAR 0 1
19217: ARRAY
19218: PPUSH
19219: CALL_OW 471
// end ;
19223: GO 19131
19225: POP
19226: POP
// repeat wait ( 0 0$1 ) ;
19227: LD_INT 35
19229: PPUSH
19230: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PPUSH
19243: LD_INT 55
19245: PUSH
19246: EMPTY
19247: LIST
19248: PPUSH
19249: CALL_OW 72
19253: PUSH
19254: LD_INT 4
19256: GREATEREQUAL
19257: IFFALSE 19227
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19259: LD_EXP 18
19263: PUSH
19264: LD_INT 1
19266: ARRAY
19267: PPUSH
19268: LD_INT 69
19270: PPUSH
19271: LD_INT 94
19273: PPUSH
19274: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19278: LD_EXP 18
19282: PUSH
19283: LD_INT 1
19285: ARRAY
19286: PPUSH
19287: LD_INT 82
19289: PPUSH
19290: LD_INT 83
19292: PPUSH
19293: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19297: LD_EXP 18
19301: PUSH
19302: LD_INT 1
19304: ARRAY
19305: PPUSH
19306: LD_INT 77
19308: PPUSH
19309: LD_INT 69
19311: PPUSH
19312: CALL_OW 174
// repeat wait ( 3 ) ;
19316: LD_INT 3
19318: PPUSH
19319: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19323: LD_ADDR_VAR 0 1
19327: PUSH
19328: LD_EXP 18
19332: PUSH
19333: LD_INT 1
19335: ARRAY
19336: PUSH
19337: FOR_IN
19338: IFFALSE 19474
// begin if GetLives ( i ) < 990 then
19340: LD_VAR 0 1
19344: PPUSH
19345: CALL_OW 256
19349: PUSH
19350: LD_INT 990
19352: LESS
19353: IFFALSE 19367
// SetLives ( i , 1000 ) ;
19355: LD_VAR 0 1
19359: PPUSH
19360: LD_INT 1000
19362: PPUSH
19363: CALL_OW 234
// if not IsInUnit ( i ) then
19367: LD_VAR 0 1
19371: PPUSH
19372: CALL_OW 310
19376: NOT
19377: IFFALSE 19472
// begin if not HasTask ( i ) then
19379: LD_VAR 0 1
19383: PPUSH
19384: CALL_OW 314
19388: NOT
19389: IFFALSE 19406
// ComMoveXY ( i , 64 , 93 ) ;
19391: LD_VAR 0 1
19395: PPUSH
19396: LD_INT 64
19398: PPUSH
19399: LD_INT 93
19401: PPUSH
19402: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19406: LD_VAR 0 4
19410: NOT
19411: PUSH
19412: LD_VAR 0 1
19416: PPUSH
19417: CALL_OW 258
19421: PUSH
19422: LD_INT 1
19424: EQUAL
19425: AND
19426: IFFALSE 19472
// begin retreat := true ;
19428: LD_ADDR_VAR 0 4
19432: PUSH
19433: LD_INT 1
19435: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19436: LD_VAR 0 1
19440: PPUSH
19441: LD_INT 2
19443: PPUSH
19444: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19448: LD_VAR 0 1
19452: PPUSH
19453: LD_STRING D4a-Sol1-1
19455: PPUSH
19456: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19460: LD_EXP 55
19464: PPUSH
19465: LD_STRING D4a-Pow-1
19467: PPUSH
19468: CALL_OW 88
// end ; end ; end ;
19472: GO 19337
19474: POP
19475: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19476: LD_EXP 18
19480: PUSH
19481: LD_INT 1
19483: ARRAY
19484: PPUSH
19485: LD_INT 95
19487: PUSH
19488: LD_INT 9
19490: PUSH
19491: EMPTY
19492: LIST
19493: LIST
19494: PUSH
19495: LD_INT 3
19497: PUSH
19498: LD_INT 55
19500: PUSH
19501: EMPTY
19502: LIST
19503: PUSH
19504: EMPTY
19505: LIST
19506: LIST
19507: PUSH
19508: EMPTY
19509: LIST
19510: LIST
19511: PPUSH
19512: CALL_OW 72
19516: PUSH
19517: LD_INT 4
19519: GREATEREQUAL
19520: IFFALSE 19316
// for i in powellSquadAttack [ 1 ] do
19522: LD_ADDR_VAR 0 1
19526: PUSH
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PUSH
19536: FOR_IN
19537: IFFALSE 19673
// begin if GetTag ( i ) = 2 then
19539: LD_VAR 0 1
19543: PPUSH
19544: CALL_OW 110
19548: PUSH
19549: LD_INT 2
19551: EQUAL
19552: IFFALSE 19614
// begin ComMoveXY ( i , 60 , 94 ) ;
19554: LD_VAR 0 1
19558: PPUSH
19559: LD_INT 60
19561: PPUSH
19562: LD_INT 94
19564: PPUSH
19565: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19569: LD_VAR 0 1
19573: PPUSH
19574: LD_EXP 55
19578: PPUSH
19579: CALL_OW 179
// wait ( 0 0$3 ) ;
19583: LD_INT 105
19585: PPUSH
19586: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19590: LD_VAR 0 1
19594: PPUSH
19595: LD_STRING D4a-Sol1-2
19597: PPUSH
19598: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19602: LD_EXP 55
19606: PPUSH
19607: LD_STRING D4a-Pow-2
19609: PPUSH
19610: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19614: LD_VAR 0 1
19618: PPUSH
19619: LD_INT 0
19621: PPUSH
19622: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19626: LD_ADDR_EXP 99
19630: PUSH
19631: LD_EXP 99
19635: PPUSH
19636: LD_INT 4
19638: PPUSH
19639: LD_EXP 99
19643: PUSH
19644: LD_INT 4
19646: ARRAY
19647: PUSH
19648: LD_VAR 0 1
19652: UNION
19653: PPUSH
19654: CALL_OW 1
19658: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19659: LD_INT 8
19661: PPUSH
19662: LD_VAR 0 1
19666: PPUSH
19667: CALL_OW 472
// end ;
19671: GO 19536
19673: POP
19674: POP
// wait ( 4 4$00 ) ;
19675: LD_INT 8400
19677: PPUSH
19678: CALL_OW 67
// uc_side := 6 ;
19682: LD_ADDR_OWVAR 20
19686: PUSH
19687: LD_INT 6
19689: ST_TO_ADDR
// uc_nation := 3 ;
19690: LD_ADDR_OWVAR 21
19694: PUSH
19695: LD_INT 3
19697: ST_TO_ADDR
// ru := [ ] ;
19698: LD_ADDR_VAR 0 7
19702: PUSH
19703: EMPTY
19704: ST_TO_ADDR
// for i = 1 to 4 do
19705: LD_ADDR_VAR 0 1
19709: PUSH
19710: DOUBLE
19711: LD_INT 1
19713: DEC
19714: ST_TO_ADDR
19715: LD_INT 4
19717: PUSH
19718: FOR_TO
19719: IFFALSE 19820
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19721: LD_INT 22
19723: PPUSH
19724: LD_INT 1
19726: PPUSH
19727: LD_INT 3
19729: PPUSH
19730: LD_INT 43
19732: PUSH
19733: LD_INT 44
19735: PUSH
19736: EMPTY
19737: LIST
19738: LIST
19739: PUSH
19740: LD_INT 1
19742: PPUSH
19743: LD_INT 2
19745: PPUSH
19746: CALL_OW 12
19750: ARRAY
19751: PPUSH
19752: LD_INT 89
19754: PPUSH
19755: CALL 69579 0 5
// un := CreateVehicle ;
19759: LD_ADDR_VAR 0 8
19763: PUSH
19764: CALL_OW 45
19768: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19769: LD_VAR 0 8
19773: PPUSH
19774: LD_INT 4
19776: PPUSH
19777: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19781: LD_VAR 0 8
19785: PPUSH
19786: LD_INT 136
19788: PPUSH
19789: LD_INT 90
19791: PPUSH
19792: LD_INT 8
19794: PPUSH
19795: LD_INT 0
19797: PPUSH
19798: CALL_OW 50
// ru := ru ^ un ;
19802: LD_ADDR_VAR 0 7
19806: PUSH
19807: LD_VAR 0 7
19811: PUSH
19812: LD_VAR 0 8
19816: ADD
19817: ST_TO_ADDR
// end ;
19818: GO 19718
19820: POP
19821: POP
// if ru then
19822: LD_VAR 0 7
19826: IFFALSE 19843
// ComAgressiveMove ( ru , 80 , 92 ) ;
19828: LD_VAR 0 7
19832: PPUSH
19833: LD_INT 80
19835: PPUSH
19836: LD_INT 92
19838: PPUSH
19839: CALL_OW 114
// wait ( 8 8$00 ) ;
19843: LD_INT 16800
19845: PPUSH
19846: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19850: LD_INT 4
19852: PPUSH
19853: LD_INT 3
19855: PUSH
19856: LD_INT 1
19858: PUSH
19859: LD_INT 1
19861: PUSH
19862: LD_INT 5
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: PUSH
19871: LD_INT 4
19873: PUSH
19874: LD_INT 1
19876: PUSH
19877: LD_INT 1
19879: PUSH
19880: LD_INT 6
19882: PUSH
19883: EMPTY
19884: LIST
19885: LIST
19886: LIST
19887: LIST
19888: PUSH
19889: LD_INT 4
19891: PUSH
19892: LD_INT 1
19894: PUSH
19895: LD_INT 1
19897: PUSH
19898: LD_INT 7
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: LIST
19905: LIST
19906: PUSH
19907: LD_INT 3
19909: PUSH
19910: LD_INT 1
19912: PUSH
19913: LD_INT 1
19915: PUSH
19916: LD_INT 7
19918: PUSH
19919: EMPTY
19920: LIST
19921: LIST
19922: LIST
19923: LIST
19924: PUSH
19925: LD_INT 3
19927: PUSH
19928: LD_INT 1
19930: PUSH
19931: LD_INT 1
19933: PUSH
19934: LD_INT 5
19936: PUSH
19937: EMPTY
19938: LIST
19939: LIST
19940: LIST
19941: LIST
19942: PUSH
19943: EMPTY
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: PPUSH
19950: CALL 56918 0 2
// missionStage := 4 ;
19954: LD_ADDR_EXP 15
19958: PUSH
19959: LD_INT 4
19961: ST_TO_ADDR
// end ;
19962: PPOPN 8
19964: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19965: LD_EXP 15
19969: PUSH
19970: LD_INT 4
19972: EQUAL
19973: PUSH
19974: LD_INT 22
19976: PUSH
19977: LD_INT 4
19979: PUSH
19980: EMPTY
19981: LIST
19982: LIST
19983: PUSH
19984: LD_INT 21
19986: PUSH
19987: LD_INT 2
19989: PUSH
19990: EMPTY
19991: LIST
19992: LIST
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: PPUSH
19998: CALL_OW 69
20002: PUSH
20003: LD_INT 5
20005: GREATEREQUAL
20006: AND
20007: IFFALSE 24100
20009: GO 20011
20011: DISABLE
20012: LD_INT 0
20014: PPUSH
20015: PPUSH
20016: PPUSH
20017: PPUSH
20018: PPUSH
20019: PPUSH
20020: PPUSH
20021: PPUSH
20022: PPUSH
20023: PPUSH
20024: PPUSH
20025: PPUSH
20026: PPUSH
// begin missionStage := 5 ;
20027: LD_ADDR_EXP 15
20031: PUSH
20032: LD_INT 5
20034: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20035: LD_ADDR_VAR 0 10
20039: PUSH
20040: LD_INT 22
20042: PUSH
20043: LD_INT 4
20045: PUSH
20046: EMPTY
20047: LIST
20048: LIST
20049: PUSH
20050: LD_INT 2
20052: PUSH
20053: LD_INT 30
20055: PUSH
20056: LD_INT 4
20058: PUSH
20059: EMPTY
20060: LIST
20061: LIST
20062: PUSH
20063: LD_INT 30
20065: PUSH
20066: LD_INT 5
20068: PUSH
20069: EMPTY
20070: LIST
20071: LIST
20072: PUSH
20073: EMPTY
20074: LIST
20075: LIST
20076: LIST
20077: PUSH
20078: EMPTY
20079: LIST
20080: LIST
20081: PPUSH
20082: CALL_OW 69
20086: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20087: LD_ADDR_VAR 0 6
20091: PUSH
20092: LD_INT 22
20094: PUSH
20095: LD_INT 4
20097: PUSH
20098: EMPTY
20099: LIST
20100: LIST
20101: PUSH
20102: LD_INT 21
20104: PUSH
20105: LD_INT 1
20107: PUSH
20108: EMPTY
20109: LIST
20110: LIST
20111: PUSH
20112: LD_INT 3
20114: PUSH
20115: LD_INT 25
20117: PUSH
20118: LD_INT 16
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: PUSH
20125: EMPTY
20126: LIST
20127: LIST
20128: PUSH
20129: LD_INT 3
20131: PUSH
20132: LD_INT 25
20134: PUSH
20135: LD_INT 12
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PUSH
20142: EMPTY
20143: LIST
20144: LIST
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: PPUSH
20152: CALL_OW 69
20156: PUSH
20157: LD_EXP 55
20161: DIFF
20162: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20163: LD_ADDR_VAR 0 9
20167: PUSH
20168: LD_INT 22
20170: PUSH
20171: LD_INT 4
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PUSH
20178: LD_INT 30
20180: PUSH
20181: LD_INT 3
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: PUSH
20188: EMPTY
20189: LIST
20190: LIST
20191: PPUSH
20192: CALL_OW 69
20196: PUSH
20197: LD_INT 1
20199: ARRAY
20200: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20201: LD_INT 35
20203: PPUSH
20204: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20208: LD_EXP 118
20212: PUSH
20213: LD_INT 4
20215: ARRAY
20216: PUSH
20217: LD_INT 5
20219: GREATEREQUAL
20220: PUSH
20221: LD_EXP 118
20225: PUSH
20226: LD_INT 4
20228: ARRAY
20229: PPUSH
20230: LD_INT 58
20232: PUSH
20233: EMPTY
20234: LIST
20235: PPUSH
20236: CALL_OW 72
20240: PUSH
20241: LD_INT 5
20243: GREATEREQUAL
20244: AND
20245: IFFALSE 20201
// powellAllowRetreat := false ;
20247: LD_ADDR_EXP 19
20251: PUSH
20252: LD_INT 0
20254: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20255: LD_INT 700
20257: PPUSH
20258: CALL_OW 67
// activeAttacks := false ;
20262: LD_ADDR_EXP 16
20266: PUSH
20267: LD_INT 0
20269: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20270: LD_INT 35
20272: PPUSH
20273: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20277: LD_INT 22
20279: PUSH
20280: LD_INT 6
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: PPUSH
20287: CALL_OW 69
20291: PUSH
20292: LD_INT 0
20294: EQUAL
20295: IFFALSE 20270
// tmp := mc_vehicles [ 4 ] ;
20297: LD_ADDR_VAR 0 3
20301: PUSH
20302: LD_EXP 118
20306: PUSH
20307: LD_INT 4
20309: ARRAY
20310: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20311: LD_ADDR_VAR 0 1
20315: PUSH
20316: DOUBLE
20317: LD_INT 1
20319: DEC
20320: ST_TO_ADDR
20321: LD_EXP 18
20325: PUSH
20326: FOR_TO
20327: IFFALSE 20588
// begin for j in powellSquadAttack [ i ] do
20329: LD_ADDR_VAR 0 2
20333: PUSH
20334: LD_EXP 18
20338: PUSH
20339: LD_VAR 0 1
20343: ARRAY
20344: PUSH
20345: FOR_IN
20346: IFFALSE 20584
// begin forces := forces diff j ;
20348: LD_ADDR_VAR 0 6
20352: PUSH
20353: LD_VAR 0 6
20357: PUSH
20358: LD_VAR 0 2
20362: DIFF
20363: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20364: LD_VAR 0 2
20368: PPUSH
20369: LD_INT 1
20371: PPUSH
20372: CALL_OW 109
// wait ( 0 0$2 ) ;
20376: LD_INT 70
20378: PPUSH
20379: CALL_OW 67
// if IsInUnit ( j ) then
20383: LD_VAR 0 2
20387: PPUSH
20388: CALL_OW 310
20392: IFFALSE 20403
// ComExitBuilding ( j ) ;
20394: LD_VAR 0 2
20398: PPUSH
20399: CALL_OW 122
// if GetClass ( j ) <> 1 then
20403: LD_VAR 0 2
20407: PPUSH
20408: CALL_OW 257
20412: PUSH
20413: LD_INT 1
20415: NONEQUAL
20416: IFFALSE 20496
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20418: LD_VAR 0 10
20422: PUSH
20423: LD_INT 1
20425: ARRAY
20426: PPUSH
20427: CALL_OW 313
20431: PUSH
20432: LD_INT 5
20434: GREATEREQUAL
20435: IFFALSE 20457
// AddComEnterUnit ( j , arm [ 2 ] ) else
20437: LD_VAR 0 2
20441: PPUSH
20442: LD_VAR 0 10
20446: PUSH
20447: LD_INT 2
20449: ARRAY
20450: PPUSH
20451: CALL_OW 180
20455: GO 20475
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20457: LD_VAR 0 2
20461: PPUSH
20462: LD_VAR 0 10
20466: PUSH
20467: LD_INT 1
20469: ARRAY
20470: PPUSH
20471: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20475: LD_VAR 0 2
20479: PPUSH
20480: LD_INT 1
20482: PPUSH
20483: CALL_OW 183
// AddComExitBuilding ( j ) ;
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL_OW 182
// end ; if i = 2 then
20496: LD_VAR 0 1
20500: PUSH
20501: LD_INT 2
20503: EQUAL
20504: IFFALSE 20521
// AddComMoveXY ( j , 61 , 93 ) ;
20506: LD_VAR 0 2
20510: PPUSH
20511: LD_INT 61
20513: PPUSH
20514: LD_INT 93
20516: PPUSH
20517: CALL_OW 171
// if i = 1 then
20521: LD_VAR 0 1
20525: PUSH
20526: LD_INT 1
20528: EQUAL
20529: IFFALSE 20582
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20531: LD_VAR 0 2
20535: PPUSH
20536: LD_VAR 0 3
20540: PUSH
20541: LD_INT 1
20543: ARRAY
20544: PPUSH
20545: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20549: LD_ADDR_VAR 0 3
20553: PUSH
20554: LD_VAR 0 3
20558: PPUSH
20559: LD_INT 1
20561: PPUSH
20562: CALL_OW 3
20566: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20567: LD_VAR 0 2
20571: PPUSH
20572: LD_INT 69
20574: PPUSH
20575: LD_INT 94
20577: PPUSH
20578: CALL_OW 171
// end ; end ;
20582: GO 20345
20584: POP
20585: POP
// end ;
20586: GO 20326
20588: POP
20589: POP
// wait ( 0 0$55 ) ;
20590: LD_INT 1925
20592: PPUSH
20593: CALL_OW 67
// MC_Kill ( 4 ) ;
20597: LD_INT 4
20599: PPUSH
20600: CALL 33980 0 1
// tmp := UnitsInside ( fac ) ;
20604: LD_ADDR_VAR 0 3
20608: PUSH
20609: LD_VAR 0 9
20613: PPUSH
20614: CALL_OW 313
20618: ST_TO_ADDR
// if tmp then
20619: LD_VAR 0 3
20623: IFFALSE 20744
// for i in tmp do
20625: LD_ADDR_VAR 0 1
20629: PUSH
20630: LD_VAR 0 3
20634: PUSH
20635: FOR_IN
20636: IFFALSE 20742
// begin ComExitBuilding ( i ) ;
20638: LD_VAR 0 1
20642: PPUSH
20643: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20647: LD_VAR 0 10
20651: PUSH
20652: LD_INT 2
20654: ARRAY
20655: PPUSH
20656: CALL_OW 313
20660: PUSH
20661: LD_INT 6
20663: LESS
20664: IFFALSE 20686
// AddComEnterUnit ( i , arm [ 2 ] ) else
20666: LD_VAR 0 1
20670: PPUSH
20671: LD_VAR 0 10
20675: PUSH
20676: LD_INT 2
20678: ARRAY
20679: PPUSH
20680: CALL_OW 180
20684: GO 20740
// if UnitsInside ( arm [ 1 ] ) < 6 then
20686: LD_VAR 0 10
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: CALL_OW 313
20699: PUSH
20700: LD_INT 6
20702: LESS
20703: IFFALSE 20725
// AddComEnterUnit ( i , arm [ 1 ] ) else
20705: LD_VAR 0 1
20709: PPUSH
20710: LD_VAR 0 10
20714: PUSH
20715: LD_INT 1
20717: ARRAY
20718: PPUSH
20719: CALL_OW 180
20723: GO 20740
// AddComMoveXY ( i , 37 , 68 ) ;
20725: LD_VAR 0 1
20729: PPUSH
20730: LD_INT 37
20732: PPUSH
20733: LD_INT 68
20735: PPUSH
20736: CALL_OW 171
// end ;
20740: GO 20635
20742: POP
20743: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20744: LD_ADDR_VAR 0 11
20748: PUSH
20749: LD_VAR 0 6
20753: PPUSH
20754: LD_INT 26
20756: PUSH
20757: LD_INT 1
20759: PUSH
20760: EMPTY
20761: LIST
20762: LIST
20763: PPUSH
20764: CALL_OW 72
20768: PUSH
20769: LD_EXP 56
20773: DIFF
20774: ST_TO_ADDR
// if not speaker then
20775: LD_VAR 0 11
20779: NOT
20780: IFFALSE 20807
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20782: LD_ADDR_VAR 0 11
20786: PUSH
20787: LD_VAR 0 6
20791: PPUSH
20792: LD_INT 26
20794: PUSH
20795: LD_INT 1
20797: PUSH
20798: EMPTY
20799: LIST
20800: LIST
20801: PPUSH
20802: CALL_OW 72
20806: ST_TO_ADDR
// if speaker then
20807: LD_VAR 0 11
20811: IFFALSE 20827
// speaker := speaker [ 1 ] ;
20813: LD_ADDR_VAR 0 11
20817: PUSH
20818: LD_VAR 0 11
20822: PUSH
20823: LD_INT 1
20825: ARRAY
20826: ST_TO_ADDR
// Video ( true ) ;
20827: LD_INT 1
20829: PPUSH
20830: CALL 105296 0 1
// CenterNowOnUnits ( Powell ) ;
20834: LD_EXP 55
20838: PPUSH
20839: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20843: LD_ADDR_VAR 0 3
20847: PUSH
20848: LD_VAR 0 6
20852: PPUSH
20853: LD_INT 3
20855: PUSH
20856: LD_INT 25
20858: PUSH
20859: LD_INT 1
20861: PUSH
20862: EMPTY
20863: LIST
20864: LIST
20865: PUSH
20866: EMPTY
20867: LIST
20868: LIST
20869: PPUSH
20870: CALL_OW 72
20874: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20875: LD_ADDR_VAR 0 12
20879: PUSH
20880: LD_INT 22
20882: PUSH
20883: LD_INT 4
20885: PUSH
20886: EMPTY
20887: LIST
20888: LIST
20889: PUSH
20890: LD_INT 30
20892: PUSH
20893: LD_INT 32
20895: PUSH
20896: EMPTY
20897: LIST
20898: LIST
20899: PUSH
20900: LD_INT 58
20902: PUSH
20903: EMPTY
20904: LIST
20905: PUSH
20906: EMPTY
20907: LIST
20908: LIST
20909: LIST
20910: PPUSH
20911: CALL_OW 69
20915: ST_TO_ADDR
// for i = 1 to 6 do
20916: LD_ADDR_VAR 0 1
20920: PUSH
20921: DOUBLE
20922: LD_INT 1
20924: DEC
20925: ST_TO_ADDR
20926: LD_INT 6
20928: PUSH
20929: FOR_TO
20930: IFFALSE 21071
// begin if IsInUnit ( tmp [ i ] ) then
20932: LD_VAR 0 3
20936: PUSH
20937: LD_VAR 0 1
20941: ARRAY
20942: PPUSH
20943: CALL_OW 310
20947: IFFALSE 20964
// ComExitBuilding ( tmp [ i ] ) ;
20949: LD_VAR 0 3
20953: PUSH
20954: LD_VAR 0 1
20958: ARRAY
20959: PPUSH
20960: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20964: LD_VAR 0 3
20968: PUSH
20969: LD_VAR 0 1
20973: ARRAY
20974: PPUSH
20975: LD_VAR 0 10
20979: PUSH
20980: LD_INT 1
20982: ARRAY
20983: PPUSH
20984: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20988: LD_VAR 0 3
20992: PUSH
20993: LD_VAR 0 1
20997: ARRAY
20998: PPUSH
20999: LD_INT 1
21001: PPUSH
21002: CALL_OW 183
// if emp_towers then
21006: LD_VAR 0 12
21010: IFFALSE 21069
// begin AddComExitBuilding ( tmp [ i ] ) ;
21012: LD_VAR 0 3
21016: PUSH
21017: LD_VAR 0 1
21021: ARRAY
21022: PPUSH
21023: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21027: LD_VAR 0 3
21031: PUSH
21032: LD_VAR 0 1
21036: ARRAY
21037: PPUSH
21038: LD_VAR 0 12
21042: PUSH
21043: LD_INT 1
21045: ARRAY
21046: PPUSH
21047: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21051: LD_ADDR_VAR 0 12
21055: PUSH
21056: LD_VAR 0 12
21060: PPUSH
21061: LD_INT 1
21063: PPUSH
21064: CALL_OW 3
21068: ST_TO_ADDR
// end ; end ;
21069: GO 20929
21071: POP
21072: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21073: LD_ADDR_VAR 0 3
21077: PUSH
21078: LD_EXP 18
21082: PUSH
21083: LD_INT 1
21085: ARRAY
21086: PUSH
21087: LD_EXP 18
21091: PUSH
21092: LD_INT 2
21094: ARRAY
21095: ADD
21096: PPUSH
21097: LD_INT 26
21099: PUSH
21100: LD_INT 1
21102: PUSH
21103: EMPTY
21104: LIST
21105: LIST
21106: PPUSH
21107: CALL_OW 72
21111: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21112: LD_ADDR_VAR 0 1
21116: PUSH
21117: LD_EXP 18
21121: PUSH
21122: LD_INT 2
21124: ARRAY
21125: PUSH
21126: FOR_IN
21127: IFFALSE 21145
// ComTurnUnit ( i , Powell ) ;
21129: LD_VAR 0 1
21133: PPUSH
21134: LD_EXP 55
21138: PPUSH
21139: CALL_OW 119
21143: GO 21126
21145: POP
21146: POP
// Say ( Powell , D5-Pow-1 ) ;
21147: LD_EXP 55
21151: PPUSH
21152: LD_STRING D5-Pow-1
21154: PPUSH
21155: CALL_OW 88
// if tmp then
21159: LD_VAR 0 3
21163: IFFALSE 21181
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21165: LD_VAR 0 3
21169: PUSH
21170: LD_INT 1
21172: ARRAY
21173: PPUSH
21174: LD_STRING D5-Sol2-1
21176: PPUSH
21177: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21181: LD_EXP 55
21185: PPUSH
21186: LD_STRING D5-Pow-2
21188: PPUSH
21189: CALL_OW 88
// if tmp > 1 then
21193: LD_VAR 0 3
21197: PUSH
21198: LD_INT 1
21200: GREATER
21201: IFFALSE 21219
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21203: LD_VAR 0 3
21207: PUSH
21208: LD_INT 2
21210: ARRAY
21211: PPUSH
21212: LD_STRING D5-Sol2-2
21214: PPUSH
21215: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21219: LD_EXP 55
21223: PPUSH
21224: LD_STRING D5-Pow-3
21226: PPUSH
21227: CALL_OW 88
// wait ( 0 0$1 ) ;
21231: LD_INT 35
21233: PPUSH
21234: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21238: LD_ADDR_VAR 0 3
21242: PUSH
21243: LD_EXP 18
21247: PUSH
21248: LD_INT 1
21250: ARRAY
21251: PUSH
21252: LD_EXP 18
21256: PUSH
21257: LD_INT 2
21259: ARRAY
21260: UNION
21261: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21262: LD_VAR 0 3
21266: PPUSH
21267: LD_INT 80
21269: PPUSH
21270: LD_INT 67
21272: PPUSH
21273: CALL_OW 114
// wait ( 0 0$2 ) ;
21277: LD_INT 70
21279: PPUSH
21280: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21284: LD_INT 79
21286: PPUSH
21287: LD_INT 72
21289: PPUSH
21290: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21294: LD_INT 35
21296: PPUSH
21297: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21301: LD_VAR 0 3
21305: PPUSH
21306: LD_INT 3
21308: PUSH
21309: LD_INT 24
21311: PUSH
21312: LD_INT 1000
21314: PUSH
21315: EMPTY
21316: LIST
21317: LIST
21318: PUSH
21319: EMPTY
21320: LIST
21321: LIST
21322: PPUSH
21323: CALL_OW 72
21327: IFFALSE 21294
// Say ( Powell , D5a-Pow-1 ) ;
21329: LD_EXP 55
21333: PPUSH
21334: LD_STRING D5a-Pow-1
21336: PPUSH
21337: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21341: LD_EXP 55
21345: PPUSH
21346: LD_STRING D5a-Pow-1a
21348: PPUSH
21349: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21353: LD_INT 10
21355: PPUSH
21356: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21360: LD_EXP 55
21364: PPUSH
21365: LD_STRING D5a-Pow-1b
21367: PPUSH
21368: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21372: LD_EXP 55
21376: PPUSH
21377: LD_STRING D5a-Pow-1c
21379: PPUSH
21380: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21384: LD_EXP 55
21388: PPUSH
21389: LD_STRING D5a-Pow-1d
21391: PPUSH
21392: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21396: LD_INT 35
21398: PPUSH
21399: CALL_OW 67
// if not HasTask ( tmp ) then
21403: LD_VAR 0 3
21407: PPUSH
21408: CALL_OW 314
21412: NOT
21413: IFFALSE 21430
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21415: LD_VAR 0 3
21419: PPUSH
21420: LD_INT 80
21422: PPUSH
21423: LD_INT 67
21425: PPUSH
21426: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21430: LD_VAR 0 3
21434: PPUSH
21435: LD_INT 24
21437: PUSH
21438: LD_INT 1
21440: PUSH
21441: EMPTY
21442: LIST
21443: LIST
21444: PPUSH
21445: CALL_OW 72
21449: NOT
21450: IFFALSE 21396
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21452: LD_ADDR_VAR 0 3
21456: PUSH
21457: LD_INT 22
21459: PUSH
21460: LD_INT 4
21462: PUSH
21463: EMPTY
21464: LIST
21465: LIST
21466: PUSH
21467: LD_INT 92
21469: PUSH
21470: LD_INT 60
21472: PUSH
21473: LD_INT 93
21475: PUSH
21476: LD_INT 10
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: LIST
21483: LIST
21484: PUSH
21485: LD_INT 3
21487: PUSH
21488: LD_INT 54
21490: PUSH
21491: EMPTY
21492: LIST
21493: PUSH
21494: EMPTY
21495: LIST
21496: LIST
21497: PUSH
21498: EMPTY
21499: LIST
21500: LIST
21501: LIST
21502: PPUSH
21503: CALL_OW 69
21507: PUSH
21508: LD_EXP 55
21512: DIFF
21513: ST_TO_ADDR
// if tmp then
21514: LD_VAR 0 3
21518: IFFALSE 21552
// for i in tmp do
21520: LD_ADDR_VAR 0 1
21524: PUSH
21525: LD_VAR 0 3
21529: PUSH
21530: FOR_IN
21531: IFFALSE 21550
// ComMoveXY ( i , 36 , 67 ) ;
21533: LD_VAR 0 1
21537: PPUSH
21538: LD_INT 36
21540: PPUSH
21541: LD_INT 67
21543: PPUSH
21544: CALL_OW 111
21548: GO 21530
21550: POP
21551: POP
// wait ( 0 0$3 ) ;
21552: LD_INT 105
21554: PPUSH
21555: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21559: LD_VAR 0 11
21563: PPUSH
21564: LD_STRING D6-Sol3-1
21566: PPUSH
21567: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21571: LD_EXP 55
21575: PPUSH
21576: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21580: LD_EXP 55
21584: PPUSH
21585: LD_STRING D6-Pow-1
21587: PPUSH
21588: CALL_OW 88
// tmp := [ ] ;
21592: LD_ADDR_VAR 0 3
21596: PUSH
21597: EMPTY
21598: ST_TO_ADDR
// for i = 1 to 2 do
21599: LD_ADDR_VAR 0 1
21603: PUSH
21604: DOUBLE
21605: LD_INT 1
21607: DEC
21608: ST_TO_ADDR
21609: LD_INT 2
21611: PUSH
21612: FOR_TO
21613: IFFALSE 21727
// begin uc_side := 8 ;
21615: LD_ADDR_OWVAR 20
21619: PUSH
21620: LD_INT 8
21622: ST_TO_ADDR
// uc_nation := 2 ;
21623: LD_ADDR_OWVAR 21
21627: PUSH
21628: LD_INT 2
21630: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21631: LD_INT 14
21633: PPUSH
21634: LD_INT 3
21636: PPUSH
21637: LD_INT 2
21639: PPUSH
21640: LD_INT 29
21642: PPUSH
21643: LD_INT 100
21645: PPUSH
21646: CALL 69579 0 5
// veh := CreateVehicle ;
21650: LD_ADDR_VAR 0 13
21654: PUSH
21655: CALL_OW 45
21659: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21660: LD_VAR 0 13
21664: PPUSH
21665: LD_INT 4
21667: PPUSH
21668: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21672: LD_VAR 0 13
21676: PPUSH
21677: LD_INT 99
21679: PPUSH
21680: LD_INT 83
21682: PPUSH
21683: LD_INT 6
21685: PPUSH
21686: LD_INT 0
21688: PPUSH
21689: CALL_OW 50
// wait ( 3 ) ;
21693: LD_INT 3
21695: PPUSH
21696: CALL_OW 67
// Connect ( veh ) ;
21700: LD_VAR 0 13
21704: PPUSH
21705: CALL 72634 0 1
// tmp := tmp ^ veh ;
21709: LD_ADDR_VAR 0 3
21713: PUSH
21714: LD_VAR 0 3
21718: PUSH
21719: LD_VAR 0 13
21723: ADD
21724: ST_TO_ADDR
// end ;
21725: GO 21612
21727: POP
21728: POP
// wait ( 0 0$1 ) ;
21729: LD_INT 35
21731: PPUSH
21732: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21736: LD_INT 99
21738: PPUSH
21739: LD_INT 83
21741: PPUSH
21742: LD_INT 1
21744: PPUSH
21745: LD_INT 10
21747: PPUSH
21748: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21752: LD_INT 99
21754: PPUSH
21755: LD_INT 83
21757: PPUSH
21758: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21762: LD_VAR 0 11
21766: PPUSH
21767: LD_STRING D6-Sol3-2
21769: PPUSH
21770: CALL_OW 88
// async ;
21774: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21775: LD_EXP 55
21779: PPUSH
21780: LD_STRING D6-Pow-2
21782: PPUSH
21783: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21787: LD_VAR 0 3
21791: PUSH
21792: LD_INT 1
21794: ARRAY
21795: PPUSH
21796: LD_VAR 0 9
21800: PPUSH
21801: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21805: LD_VAR 0 3
21809: PUSH
21810: LD_INT 2
21812: ARRAY
21813: PPUSH
21814: LD_INT 22
21816: PUSH
21817: LD_INT 4
21819: PUSH
21820: EMPTY
21821: LIST
21822: LIST
21823: PUSH
21824: LD_INT 21
21826: PUSH
21827: LD_INT 3
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PPUSH
21838: CALL_OW 69
21842: PPUSH
21843: LD_VAR 0 3
21847: PUSH
21848: LD_INT 2
21850: ARRAY
21851: PPUSH
21852: CALL_OW 74
21856: PPUSH
21857: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21861: LD_EXP 55
21865: PPUSH
21866: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21870: LD_INT 99
21872: PPUSH
21873: LD_INT 83
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: CALL_OW 331
// repeat wait ( 4 ) ;
21883: LD_INT 4
21885: PPUSH
21886: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21890: LD_VAR 0 3
21894: PUSH
21895: LD_INT 1
21897: ARRAY
21898: PPUSH
21899: CALL_OW 256
21903: PUSH
21904: LD_INT 1000
21906: LESS
21907: IFFALSE 21925
// SetLives ( tmp [ 1 ] , 1000 ) ;
21909: LD_VAR 0 3
21913: PUSH
21914: LD_INT 1
21916: ARRAY
21917: PPUSH
21918: LD_INT 1000
21920: PPUSH
21921: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21925: LD_INT 22
21927: PUSH
21928: LD_INT 4
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: PUSH
21935: LD_INT 30
21937: PUSH
21938: LD_INT 3
21940: PUSH
21941: EMPTY
21942: LIST
21943: LIST
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: PPUSH
21949: CALL_OW 69
21953: PUSH
21954: LD_INT 0
21956: EQUAL
21957: IFFALSE 21883
// sync ;
21959: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21960: LD_EXP 55
21964: PPUSH
21965: LD_STRING D6a-Pow-1
21967: PPUSH
21968: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21972: LD_VAR 0 11
21976: PPUSH
21977: LD_STRING D6a-Sol3-1
21979: PPUSH
21980: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21984: LD_EXP 55
21988: PPUSH
21989: LD_STRING D6a-Pow-2
21991: PPUSH
21992: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
21996: LD_VAR 0 11
22000: PPUSH
22001: LD_STRING D6a-Sol3-2
22003: PPUSH
22004: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22008: LD_EXP 55
22012: PPUSH
22013: LD_STRING D6a-Pow-3
22015: PPUSH
22016: CALL_OW 88
// powellCenterCameraMode := true ;
22020: LD_ADDR_EXP 20
22024: PUSH
22025: LD_INT 1
22027: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22028: LD_ADDR_VAR 0 1
22032: PUSH
22033: LD_INT 22
22035: PUSH
22036: LD_INT 8
22038: PUSH
22039: EMPTY
22040: LIST
22041: LIST
22042: PUSH
22043: LD_INT 25
22045: PUSH
22046: LD_INT 2
22048: PUSH
22049: EMPTY
22050: LIST
22051: LIST
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PPUSH
22057: CALL_OW 69
22061: PUSH
22062: FOR_IN
22063: IFFALSE 22118
// begin SetTag ( i , 1 ) ;
22065: LD_VAR 0 1
22069: PPUSH
22070: LD_INT 1
22072: PPUSH
22073: CALL_OW 109
// ComExitBuilding ( i ) ;
22077: LD_VAR 0 1
22081: PPUSH
22082: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22086: LD_VAR 0 1
22090: PPUSH
22091: LD_INT 35
22093: PPUSH
22094: LD_INT 6
22096: PPUSH
22097: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22101: LD_VAR 0 1
22105: PPUSH
22106: LD_INT 53
22108: PPUSH
22109: LD_INT 4
22111: PPUSH
22112: CALL_OW 171
// end ;
22116: GO 22062
22118: POP
22119: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22120: LD_ADDR_VAR 0 3
22124: PUSH
22125: LD_INT 22
22127: PUSH
22128: LD_INT 4
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: PUSH
22135: LD_INT 21
22137: PUSH
22138: LD_INT 2
22140: PUSH
22141: EMPTY
22142: LIST
22143: LIST
22144: PUSH
22145: LD_INT 3
22147: PUSH
22148: LD_INT 34
22150: PUSH
22151: LD_INT 12
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: PUSH
22162: EMPTY
22163: LIST
22164: LIST
22165: LIST
22166: PPUSH
22167: CALL_OW 69
22171: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22172: LD_EXP 55
22176: PPUSH
22177: LD_VAR 0 3
22181: PPUSH
22182: LD_EXP 55
22186: PPUSH
22187: CALL_OW 74
22191: PPUSH
22192: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22196: LD_EXP 55
22200: PPUSH
22201: LD_INT 100
22203: PPUSH
22204: LD_INT 88
22206: PPUSH
22207: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22211: LD_EXP 55
22215: PPUSH
22216: LD_INT 100
22218: PPUSH
22219: LD_INT 75
22221: PPUSH
22222: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22226: LD_EXP 55
22230: PPUSH
22231: LD_INT 88
22233: PPUSH
22234: LD_INT 53
22236: PPUSH
22237: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22241: LD_INT 8
22243: PPUSH
22244: LD_EXP 55
22248: PPUSH
22249: CALL_OW 471
// repeat wait ( 3 ) ;
22253: LD_INT 3
22255: PPUSH
22256: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22260: LD_INT 22
22262: PUSH
22263: LD_INT 4
22265: PUSH
22266: EMPTY
22267: LIST
22268: LIST
22269: PUSH
22270: LD_INT 92
22272: PUSH
22273: LD_INT 100
22275: PUSH
22276: LD_INT 75
22278: PUSH
22279: LD_INT 6
22281: PUSH
22282: EMPTY
22283: LIST
22284: LIST
22285: LIST
22286: LIST
22287: PUSH
22288: EMPTY
22289: LIST
22290: LIST
22291: PPUSH
22292: CALL_OW 69
22296: IFFALSE 22253
// async ;
22298: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22299: LD_EXP 55
22303: PPUSH
22304: LD_STRING D6b-Pow-1
22306: PPUSH
22307: CALL_OW 88
// repeat wait ( 3 ) ;
22311: LD_INT 3
22313: PPUSH
22314: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22318: LD_EXP 55
22322: PPUSH
22323: CALL_OW 310
22327: PPUSH
22328: CALL_OW 256
22332: PUSH
22333: LD_INT 1000
22335: LESS
22336: IFFALSE 22355
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22338: LD_EXP 55
22342: PPUSH
22343: CALL_OW 310
22347: PPUSH
22348: LD_INT 1000
22350: PPUSH
22351: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22355: LD_EXP 55
22359: PPUSH
22360: CALL_OW 256
22364: PUSH
22365: LD_INT 1000
22367: LESS
22368: IFFALSE 22382
// SetLives ( Powell , 1000 ) ;
22370: LD_EXP 55
22374: PPUSH
22375: LD_INT 1000
22377: PPUSH
22378: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22382: LD_EXP 55
22386: PPUSH
22387: LD_EXP 60
22391: PPUSH
22392: CALL_OW 296
22396: PUSH
22397: LD_INT 5
22399: LESS
22400: PUSH
22401: LD_EXP 55
22405: PPUSH
22406: CALL_OW 310
22410: PPUSH
22411: LD_EXP 60
22415: PPUSH
22416: CALL_OW 296
22420: PUSH
22421: LD_INT 5
22423: LESS
22424: OR
22425: IFFALSE 22444
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22427: LD_EXP 55
22431: PPUSH
22432: CALL_OW 310
22436: PPUSH
22437: LD_INT 100
22439: PPUSH
22440: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22444: LD_EXP 55
22448: PPUSH
22449: CALL_OW 310
22453: NOT
22454: IFFALSE 22311
// game_speed := 4 ;
22456: LD_ADDR_OWVAR 65
22460: PUSH
22461: LD_INT 4
22463: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22464: LD_EXP 55
22468: PPUSH
22469: LD_STRING D6b-Pow-1a
22471: PPUSH
22472: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22476: LD_EXP 55
22480: PPUSH
22481: LD_EXP 60
22485: PPUSH
22486: CALL_OW 180
// sync ;
22490: SYNC
// repeat wait ( 0 0$1 ) ;
22491: LD_INT 35
22493: PPUSH
22494: CALL_OW 67
// until IsInUnit ( Powell ) ;
22498: LD_EXP 55
22502: PPUSH
22503: CALL_OW 310
22507: IFFALSE 22491
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22509: LD_INT 8
22511: PPUSH
22512: LD_EXP 55
22516: PPUSH
22517: CALL_OW 310
22521: PPUSH
22522: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22526: LD_EXP 55
22530: PPUSH
22531: LD_INT 91
22533: PPUSH
22534: LD_INT 44
22536: PPUSH
22537: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22541: LD_EXP 55
22545: PPUSH
22546: LD_INT 96
22548: PPUSH
22549: LD_INT 44
22551: PPUSH
22552: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22556: LD_EXP 55
22560: PPUSH
22561: LD_INT 96
22563: PPUSH
22564: LD_INT 41
22566: PPUSH
22567: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22571: LD_EXP 55
22575: PPUSH
22576: LD_INT 92
22578: PPUSH
22579: LD_INT 39
22581: PPUSH
22582: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22586: LD_EXP 55
22590: PPUSH
22591: LD_INT 88
22593: PPUSH
22594: LD_INT 41
22596: PPUSH
22597: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22601: LD_EXP 55
22605: PPUSH
22606: LD_INT 91
22608: PPUSH
22609: LD_INT 44
22611: PPUSH
22612: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22616: LD_EXP 55
22620: PPUSH
22621: LD_INT 96
22623: PPUSH
22624: LD_INT 44
22626: PPUSH
22627: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22631: LD_EXP 55
22635: PPUSH
22636: LD_INT 96
22638: PPUSH
22639: LD_INT 41
22641: PPUSH
22642: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22646: LD_EXP 55
22650: PPUSH
22651: LD_INT 92
22653: PPUSH
22654: LD_INT 39
22656: PPUSH
22657: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22661: LD_EXP 55
22665: PPUSH
22666: LD_INT 88
22668: PPUSH
22669: LD_INT 41
22671: PPUSH
22672: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22676: LD_EXP 55
22680: PPUSH
22681: LD_INT 91
22683: PPUSH
22684: LD_INT 44
22686: PPUSH
22687: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22691: LD_EXP 55
22695: PPUSH
22696: LD_INT 93
22698: PPUSH
22699: LD_INT 39
22701: PPUSH
22702: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22706: LD_EXP 55
22710: PPUSH
22711: LD_INT 93
22713: PPUSH
22714: LD_INT 36
22716: PPUSH
22717: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22721: LD_INT 122
22723: PPUSH
22724: CALL_OW 67
// game_speed := 4 ;
22728: LD_ADDR_OWVAR 65
22732: PUSH
22733: LD_INT 4
22735: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22736: LD_EXP 55
22740: PPUSH
22741: LD_STRING D6b-Pow-1b
22743: PPUSH
22744: CALL_OW 88
// tmp := [ ] ;
22748: LD_ADDR_VAR 0 3
22752: PUSH
22753: EMPTY
22754: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22755: LD_ADDR_VAR 0 5
22759: PUSH
22760: LD_INT 78
22762: PUSH
22763: LD_INT 47
22765: PUSH
22766: EMPTY
22767: LIST
22768: LIST
22769: PUSH
22770: LD_INT 106
22772: PUSH
22773: LD_INT 53
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22784: LD_ADDR_VAR 0 1
22788: PUSH
22789: LD_INT 22
22791: PUSH
22792: LD_INT 8
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: PUSH
22799: LD_INT 21
22801: PUSH
22802: LD_INT 3
22804: PUSH
22805: EMPTY
22806: LIST
22807: LIST
22808: PUSH
22809: LD_INT 92
22811: PUSH
22812: LD_INT 90
22814: PUSH
22815: LD_INT 52
22817: PUSH
22818: LD_INT 12
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: LIST
22825: LIST
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: LIST
22831: PPUSH
22832: CALL_OW 69
22836: PUSH
22837: FOR_IN
22838: IFFALSE 22863
// tmp := tmp ^ UnitsInside ( i ) ;
22840: LD_ADDR_VAR 0 3
22844: PUSH
22845: LD_VAR 0 3
22849: PUSH
22850: LD_VAR 0 1
22854: PPUSH
22855: CALL_OW 313
22859: ADD
22860: ST_TO_ADDR
22861: GO 22837
22863: POP
22864: POP
// for i in tmp do
22865: LD_ADDR_VAR 0 1
22869: PUSH
22870: LD_VAR 0 3
22874: PUSH
22875: FOR_IN
22876: IFFALSE 23038
// begin dist := 9999 ;
22878: LD_ADDR_VAR 0 8
22882: PUSH
22883: LD_INT 9999
22885: ST_TO_ADDR
// _xy := [ ] ;
22886: LD_ADDR_VAR 0 7
22890: PUSH
22891: EMPTY
22892: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22893: LD_VAR 0 1
22897: PPUSH
22898: LD_INT 1
22900: PPUSH
22901: CALL_OW 109
// ComExitBuilding ( i ) ;
22905: LD_VAR 0 1
22909: PPUSH
22910: CALL_OW 122
// for j in xy do
22914: LD_ADDR_VAR 0 2
22918: PUSH
22919: LD_VAR 0 5
22923: PUSH
22924: FOR_IN
22925: IFFALSE 23007
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22927: LD_VAR 0 1
22931: PPUSH
22932: LD_VAR 0 2
22936: PUSH
22937: LD_INT 1
22939: ARRAY
22940: PPUSH
22941: LD_VAR 0 2
22945: PUSH
22946: LD_INT 2
22948: ARRAY
22949: PPUSH
22950: CALL_OW 297
22954: PUSH
22955: LD_VAR 0 8
22959: LESS
22960: IFFALSE 23005
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22962: LD_ADDR_VAR 0 8
22966: PUSH
22967: LD_VAR 0 1
22971: PPUSH
22972: LD_VAR 0 2
22976: PUSH
22977: LD_INT 1
22979: ARRAY
22980: PPUSH
22981: LD_VAR 0 2
22985: PUSH
22986: LD_INT 2
22988: ARRAY
22989: PPUSH
22990: CALL_OW 297
22994: ST_TO_ADDR
// _xy := j ;
22995: LD_ADDR_VAR 0 7
22999: PUSH
23000: LD_VAR 0 2
23004: ST_TO_ADDR
// end ;
23005: GO 22924
23007: POP
23008: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23009: LD_VAR 0 1
23013: PPUSH
23014: LD_VAR 0 7
23018: PUSH
23019: LD_INT 1
23021: ARRAY
23022: PPUSH
23023: LD_VAR 0 7
23027: PUSH
23028: LD_INT 2
23030: ARRAY
23031: PPUSH
23032: CALL_OW 171
// end ;
23036: GO 22875
23038: POP
23039: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23040: LD_ADDR_VAR 0 4
23044: PUSH
23045: LD_VAR 0 3
23049: PPUSH
23050: LD_INT 26
23052: PUSH
23053: LD_INT 1
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PUSH
23060: LD_INT 25
23062: PUSH
23063: LD_INT 1
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: PUSH
23070: EMPTY
23071: LIST
23072: LIST
23073: PPUSH
23074: CALL_OW 72
23078: ST_TO_ADDR
// if tmp2 < 2 then
23079: LD_VAR 0 4
23083: PUSH
23084: LD_INT 2
23086: LESS
23087: IFFALSE 23156
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23089: LD_ADDR_VAR 0 4
23093: PUSH
23094: LD_INT 22
23096: PUSH
23097: LD_INT 8
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: PUSH
23104: LD_INT 26
23106: PUSH
23107: LD_INT 1
23109: PUSH
23110: EMPTY
23111: LIST
23112: LIST
23113: PUSH
23114: LD_INT 3
23116: PUSH
23117: LD_INT 25
23119: PUSH
23120: LD_INT 15
23122: PUSH
23123: EMPTY
23124: LIST
23125: LIST
23126: PUSH
23127: EMPTY
23128: LIST
23129: LIST
23130: PUSH
23131: EMPTY
23132: LIST
23133: LIST
23134: LIST
23135: PPUSH
23136: CALL_OW 69
23140: PUSH
23141: LD_EXP 57
23145: PUSH
23146: LD_EXP 58
23150: PUSH
23151: EMPTY
23152: LIST
23153: LIST
23154: DIFF
23155: ST_TO_ADDR
// if tmp2 then
23156: LD_VAR 0 4
23160: IFFALSE 23178
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23162: LD_VAR 0 4
23166: PUSH
23167: LD_INT 1
23169: ARRAY
23170: PPUSH
23171: LD_STRING D6b-ArSol1-1
23173: PPUSH
23174: CALL_OW 88
// async ;
23178: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23179: LD_EXP 55
23183: PPUSH
23184: LD_STRING D6b-Pow-2
23186: PPUSH
23187: CALL_OW 88
// wait ( 0 0$1 ) ;
23191: LD_INT 35
23193: PPUSH
23194: CALL_OW 67
// if tmp2 > 1 then
23198: LD_VAR 0 4
23202: PUSH
23203: LD_INT 1
23205: GREATER
23206: IFFALSE 23224
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23208: LD_VAR 0 4
23212: PUSH
23213: LD_INT 2
23215: ARRAY
23216: PPUSH
23217: LD_STRING D6b-ArSol2-1
23219: PPUSH
23220: CALL_OW 88
// sync ;
23224: SYNC
// repeat wait ( 5 ) ;
23225: LD_INT 5
23227: PPUSH
23228: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23232: LD_INT 93
23234: PPUSH
23235: LD_INT 36
23237: PPUSH
23238: CALL_OW 428
23242: PPUSH
23243: CALL_OW 255
23247: PUSH
23248: LD_INT 4
23250: EQUAL
23251: IFFALSE 23225
// DialogueOn ;
23253: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23257: LD_INT 10
23259: PPUSH
23260: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23264: LD_EXP 55
23268: PPUSH
23269: LD_STRING D6b-Pow-2a
23271: PPUSH
23272: CALL_OW 88
// DialogueOff ;
23276: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23280: LD_EXP 55
23284: PPUSH
23285: CALL_OW 310
23289: PPUSH
23290: LD_INT 332
23292: PPUSH
23293: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23297: LD_INT 93
23299: PPUSH
23300: LD_INT 35
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: LD_INT 6
23308: NEG
23309: PPUSH
23310: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23314: LD_INT 35
23316: PPUSH
23317: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23321: LD_INT 332
23323: PPUSH
23324: CALL_OW 256
23328: PUSH
23329: LD_INT 1000
23331: LESS
23332: PUSH
23333: LD_INT 332
23335: PPUSH
23336: CALL_OW 300
23340: AND
23341: IFFALSE 23353
// SetLives ( kozlov_fac , 0 ) ;
23343: LD_INT 332
23345: PPUSH
23346: LD_INT 0
23348: PPUSH
23349: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23353: LD_INT 332
23355: PPUSH
23356: CALL_OW 301
23360: PUSH
23361: LD_EXP 55
23365: PPUSH
23366: CALL_OW 301
23370: OR
23371: IFFALSE 23314
// game_speed := 4 ;
23373: LD_ADDR_OWVAR 65
23377: PUSH
23378: LD_INT 4
23380: ST_TO_ADDR
// powellCenterCameraMode := false ;
23381: LD_ADDR_EXP 20
23385: PUSH
23386: LD_INT 0
23388: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23389: LD_ADDR_VAR 0 1
23393: PUSH
23394: LD_VAR 0 3
23398: PUSH
23399: LD_INT 22
23401: PUSH
23402: LD_INT 8
23404: PUSH
23405: EMPTY
23406: LIST
23407: LIST
23408: PUSH
23409: LD_INT 25
23411: PUSH
23412: LD_INT 2
23414: PUSH
23415: EMPTY
23416: LIST
23417: LIST
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: PPUSH
23423: CALL_OW 69
23427: UNION
23428: PUSH
23429: FOR_IN
23430: IFFALSE 23446
// SetTag ( i , 0 ) ;
23432: LD_VAR 0 1
23436: PPUSH
23437: LD_INT 0
23439: PPUSH
23440: CALL_OW 109
23444: GO 23429
23446: POP
23447: POP
// wait ( 0 0$3 ) ;
23448: LD_INT 105
23450: PPUSH
23451: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23455: LD_INT 93
23457: PPUSH
23458: LD_INT 35
23460: PPUSH
23461: LD_INT 1
23463: PPUSH
23464: CALL_OW 331
// DialogueOn ;
23468: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23472: LD_VAR 0 11
23476: PPUSH
23477: LD_STRING D6c-Sol3-1
23479: PPUSH
23480: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23484: LD_INT 10
23486: PPUSH
23487: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23491: LD_EXP 36
23495: PPUSH
23496: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23500: LD_EXP 36
23504: PPUSH
23505: LD_STRING D6c-JMM-1
23507: PPUSH
23508: CALL_OW 88
// if Cyrus then
23512: LD_EXP 42
23516: IFFALSE 23530
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23518: LD_EXP 42
23522: PPUSH
23523: LD_STRING D6c-Cyrus-1
23525: PPUSH
23526: CALL_OW 88
// if Bobby then
23530: LD_EXP 41
23534: IFFALSE 23548
// Say ( Bobby , D6c-Bobby-1 ) ;
23536: LD_EXP 41
23540: PPUSH
23541: LD_STRING D6c-Bobby-1
23543: PPUSH
23544: CALL_OW 88
// if Cornel then
23548: LD_EXP 47
23552: IFFALSE 23566
// Say ( Cornel , D6c-Corn-1 ) ;
23554: LD_EXP 47
23558: PPUSH
23559: LD_STRING D6c-Corn-1
23561: PPUSH
23562: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23566: LD_ADDR_VAR 0 4
23570: PUSH
23571: LD_INT 2
23573: PUSH
23574: LD_INT 22
23576: PUSH
23577: LD_INT 1
23579: PUSH
23580: EMPTY
23581: LIST
23582: LIST
23583: PUSH
23584: LD_INT 22
23586: PUSH
23587: LD_INT 4
23589: PUSH
23590: EMPTY
23591: LIST
23592: LIST
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: LIST
23598: PUSH
23599: LD_INT 26
23601: PUSH
23602: LD_INT 1
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: PUSH
23609: LD_INT 3
23611: PUSH
23612: LD_INT 25
23614: PUSH
23615: LD_INT 16
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 25
23624: PUSH
23625: LD_INT 12
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: PUSH
23637: EMPTY
23638: LIST
23639: LIST
23640: LIST
23641: PPUSH
23642: CALL_OW 69
23646: PUSH
23647: LD_VAR 0 11
23651: PUSH
23652: LD_EXP 36
23656: UNION
23657: PUSH
23658: LD_EXP 56
23662: UNION
23663: PUSH
23664: EMPTY
23665: LIST
23666: DIFF
23667: ST_TO_ADDR
// if tmp2 then
23668: LD_VAR 0 4
23672: IFFALSE 23690
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23674: LD_VAR 0 4
23678: PUSH
23679: LD_INT 1
23681: ARRAY
23682: PPUSH
23683: LD_STRING D6c-Sol1-1
23685: PPUSH
23686: CALL_OW 88
// if Lisa then
23690: LD_EXP 39
23694: IFFALSE 23708
// Say ( Lisa , D6c-Lisa-1 ) ;
23696: LD_EXP 39
23700: PPUSH
23701: LD_STRING D6c-Lisa-1
23703: PPUSH
23704: CALL_OW 88
// if Gary then
23708: LD_EXP 48
23712: IFFALSE 23726
// Say ( Gary , D6c-Gary-1 ) ;
23714: LD_EXP 48
23718: PPUSH
23719: LD_STRING D6c-Gary-1
23721: PPUSH
23722: CALL_OW 88
// if Donaldson then
23726: LD_EXP 40
23730: IFFALSE 23744
// Say ( Donaldson , D6c-Don-1 ) ;
23732: LD_EXP 40
23736: PPUSH
23737: LD_STRING D6c-Don-1
23739: PPUSH
23740: CALL_OW 88
// if tmp2 > 1 then
23744: LD_VAR 0 4
23748: PUSH
23749: LD_INT 1
23751: GREATER
23752: IFFALSE 23770
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23754: LD_VAR 0 4
23758: PUSH
23759: LD_INT 2
23761: ARRAY
23762: PPUSH
23763: LD_STRING D6c-Sol2-1
23765: PPUSH
23766: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23770: LD_VAR 0 11
23774: PPUSH
23775: LD_STRING D6c-Sol3-2
23777: PPUSH
23778: CALL_OW 88
// dwait ( 0 0$1 ) ;
23782: LD_INT 35
23784: PPUSH
23785: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23789: LD_EXP 36
23793: PPUSH
23794: LD_STRING D6c-JMM-2
23796: PPUSH
23797: CALL_OW 88
// DialogueOff ;
23801: CALL_OW 7
// Video ( false ) ;
23805: LD_INT 0
23807: PPUSH
23808: CALL 105296 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23812: LD_INT 22
23814: PUSH
23815: LD_INT 4
23817: PUSH
23818: EMPTY
23819: LIST
23820: LIST
23821: PPUSH
23822: CALL_OW 69
23826: PPUSH
23827: LD_INT 1
23829: PPUSH
23830: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23834: LD_INT 4
23836: PPUSH
23837: LD_INT 4
23839: PPUSH
23840: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23844: LD_ADDR_VAR 0 1
23848: PUSH
23849: LD_INT 4
23851: PPUSH
23852: LD_INT 1
23854: PPUSH
23855: LD_INT 2
23857: PPUSH
23858: CALL 63031 0 3
23862: PUSH
23863: FOR_IN
23864: IFFALSE 23901
// if GetTech ( i , 1 ) <> state_researched then
23866: LD_VAR 0 1
23870: PPUSH
23871: LD_INT 1
23873: PPUSH
23874: CALL_OW 321
23878: PUSH
23879: LD_INT 2
23881: NONEQUAL
23882: IFFALSE 23899
// SetTech ( i , 1 , state_researched ) ;
23884: LD_VAR 0 1
23888: PPUSH
23889: LD_INT 1
23891: PPUSH
23892: LD_INT 2
23894: PPUSH
23895: CALL_OW 322
23899: GO 23863
23901: POP
23902: POP
// missionStage := 6 ;
23903: LD_ADDR_EXP 15
23907: PUSH
23908: LD_INT 6
23910: ST_TO_ADDR
// activeAttacks := true ;
23911: LD_ADDR_EXP 16
23915: PUSH
23916: LD_INT 1
23918: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23919: LD_STRING M2
23921: PPUSH
23922: CALL_OW 337
// SaveForQuickRestart ;
23926: CALL_OW 22
// wait ( 0 0$40 ) ;
23930: LD_INT 1400
23932: PPUSH
23933: CALL_OW 67
// DialogueOn ;
23937: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23941: LD_EXP 59
23945: PPUSH
23946: LD_STRING D7-Friend-1
23948: PPUSH
23949: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23953: LD_EXP 36
23957: PPUSH
23958: LD_STRING D7-JMM-1
23960: PPUSH
23961: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23965: LD_EXP 59
23969: PPUSH
23970: LD_STRING D7-Friend-2
23972: PPUSH
23973: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23977: LD_EXP 36
23981: PPUSH
23982: LD_STRING D7-JMM-2
23984: PPUSH
23985: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23989: LD_EXP 59
23993: PPUSH
23994: LD_STRING D7-Friend-3
23996: PPUSH
23997: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24001: LD_EXP 36
24005: PPUSH
24006: LD_STRING D7-JMM-3
24008: PPUSH
24009: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24013: LD_EXP 59
24017: PPUSH
24018: LD_STRING D7-Friend-4
24020: PPUSH
24021: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24025: LD_EXP 36
24029: PPUSH
24030: LD_STRING D7-JMM-4
24032: PPUSH
24033: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24037: LD_EXP 59
24041: PPUSH
24042: LD_STRING D7-Friend-5
24044: PPUSH
24045: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24049: LD_EXP 36
24053: PPUSH
24054: LD_STRING D7-JMM-5
24056: PPUSH
24057: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24061: LD_EXP 59
24065: PPUSH
24066: LD_STRING D7-Friend-6
24068: PPUSH
24069: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24073: LD_EXP 36
24077: PPUSH
24078: LD_STRING D7-JMM-6
24080: PPUSH
24081: CALL_OW 88
// DialogueOff ;
24085: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24089: LD_STRING Mlegion
24091: PPUSH
24092: CALL_OW 337
// RebuildKozlovFactory ;
24096: CALL 4735 0 0
// end ;
24100: PPOPN 13
24102: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24103: LD_EXP 20
24107: PUSH
24108: LD_EXP 55
24112: PPUSH
24113: CALL_OW 300
24117: AND
24118: IFFALSE 24160
24120: GO 24122
24122: DISABLE
// begin enable ;
24123: ENABLE
// if IsInUnit ( Powell ) then
24124: LD_EXP 55
24128: PPUSH
24129: CALL_OW 310
24133: IFFALSE 24151
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24135: LD_EXP 55
24139: PPUSH
24140: CALL_OW 310
24144: PPUSH
24145: CALL_OW 85
24149: GO 24160
// CenterOnUnits ( Powell ) ;
24151: LD_EXP 55
24155: PPUSH
24156: CALL_OW 85
// end ;
24160: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24161: LD_INT 22
24163: PUSH
24164: LD_INT 8
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: LD_INT 34
24173: PUSH
24174: LD_INT 48
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: PUSH
24181: EMPTY
24182: LIST
24183: LIST
24184: PPUSH
24185: CALL_OW 69
24189: IFFALSE 24452
24191: GO 24193
24193: DISABLE
24194: LD_INT 0
24196: PPUSH
24197: PPUSH
// begin if missionStage < 9 then
24198: LD_EXP 15
24202: PUSH
24203: LD_INT 9
24205: LESS
24206: IFFALSE 24216
// missionStage := 9 ;
24208: LD_ADDR_EXP 15
24212: PUSH
24213: LD_INT 9
24215: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24216: LD_ADDR_VAR 0 1
24220: PUSH
24221: LD_INT 22
24223: PUSH
24224: LD_INT 8
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: PUSH
24231: LD_INT 34
24233: PUSH
24234: LD_INT 48
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: PPUSH
24245: CALL_OW 69
24249: PUSH
24250: LD_INT 1
24252: ARRAY
24253: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24254: LD_INT 175
24256: PPUSH
24257: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24261: LD_EXP 12
24265: PUSH
24266: LD_EXP 3
24270: PUSH
24271: LD_INT 0
24273: PUSH
24274: LD_INT 2
24276: PUSH
24277: EMPTY
24278: LIST
24279: LIST
24280: IN
24281: OR
24282: IFFALSE 24305
// target := [ 68 , 108 , 1 ] else
24284: LD_ADDR_VAR 0 2
24288: PUSH
24289: LD_INT 68
24291: PUSH
24292: LD_INT 108
24294: PUSH
24295: LD_INT 1
24297: PUSH
24298: EMPTY
24299: LIST
24300: LIST
24301: LIST
24302: ST_TO_ADDR
24303: GO 24324
// target := [ 181 , 88 , 2 ] ;
24305: LD_ADDR_VAR 0 2
24309: PUSH
24310: LD_INT 181
24312: PUSH
24313: LD_INT 88
24315: PUSH
24316: LD_INT 2
24318: PUSH
24319: EMPTY
24320: LIST
24321: LIST
24322: LIST
24323: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24324: LD_VAR 0 1
24328: PPUSH
24329: LD_VAR 0 2
24333: PUSH
24334: LD_INT 1
24336: ARRAY
24337: PPUSH
24338: LD_VAR 0 2
24342: PUSH
24343: LD_INT 2
24345: ARRAY
24346: PPUSH
24347: CALL_OW 176
// if target [ 3 ] = 1 then
24351: LD_VAR 0 2
24355: PUSH
24356: LD_INT 3
24358: ARRAY
24359: PUSH
24360: LD_INT 1
24362: EQUAL
24363: IFFALSE 24379
// SayRadio ( Kurt , D12-Kurt-1 ) else
24365: LD_EXP 57
24369: PPUSH
24370: LD_STRING D12-Kurt-1
24372: PPUSH
24373: CALL_OW 94
24377: GO 24403
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24379: LD_EXP 57
24383: PPUSH
24384: LD_STRING D12a-Kurt-1
24386: PPUSH
24387: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24391: LD_EXP 71
24395: PPUSH
24396: LD_STRING D12a-Roth-1
24398: PPUSH
24399: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24403: LD_INT 350
24405: PPUSH
24406: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24410: LD_VAR 0 1
24414: PPUSH
24415: LD_INT 22
24417: PUSH
24418: LD_INT 8
24420: PUSH
24421: EMPTY
24422: LIST
24423: LIST
24424: PUSH
24425: LD_INT 30
24427: PUSH
24428: LD_INT 3
24430: PUSH
24431: EMPTY
24432: LIST
24433: LIST
24434: PUSH
24435: EMPTY
24436: LIST
24437: LIST
24438: PPUSH
24439: CALL_OW 69
24443: PUSH
24444: LD_INT 1
24446: ARRAY
24447: PPUSH
24448: CALL_OW 228
// end ;
24452: PPOPN 2
24454: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24455: LD_INT 22
24457: PUSH
24458: LD_INT 8
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PUSH
24465: LD_INT 21
24467: PUSH
24468: LD_INT 1
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PUSH
24475: LD_INT 23
24477: PUSH
24478: LD_INT 2
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: EMPTY
24486: LIST
24487: LIST
24488: LIST
24489: PPUSH
24490: CALL_OW 69
24494: PUSH
24495: LD_INT 8
24497: PUSH
24498: LD_INT 7
24500: PUSH
24501: LD_INT 6
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: LIST
24508: PUSH
24509: LD_OWVAR 67
24513: ARRAY
24514: LESSEQUAL
24515: PUSH
24516: LD_INT 22
24518: PUSH
24519: LD_INT 8
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 34
24528: PUSH
24529: LD_INT 48
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: PUSH
24536: EMPTY
24537: LIST
24538: LIST
24539: PPUSH
24540: CALL_OW 69
24544: NOT
24545: AND
24546: PUSH
24547: LD_EXP 57
24551: PPUSH
24552: CALL_OW 302
24556: AND
24557: IFFALSE 24874
24559: GO 24561
24561: DISABLE
// begin DialogueOn ;
24562: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24566: LD_EXP 36
24570: PPUSH
24571: LD_STRING D13-JMM-1
24573: PPUSH
24574: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24578: LD_EXP 57
24582: PPUSH
24583: LD_STRING D13-Kurt-1
24585: PPUSH
24586: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24590: LD_EXP 36
24594: PPUSH
24595: LD_STRING D13-JMM-2
24597: PPUSH
24598: CALL_OW 88
// if FakeInfo then
24602: LD_EXP 12
24606: IFFALSE 24626
// begin Say ( Kurt , D13-Kurt-2 ) ;
24608: LD_EXP 57
24612: PPUSH
24613: LD_STRING D13-Kurt-2
24615: PPUSH
24616: CALL_OW 88
// DialogueOff ;
24620: CALL_OW 7
// exit ;
24624: GO 24874
// end ; if not KurtStatus then
24626: LD_EXP 3
24630: NOT
24631: IFFALSE 24647
// Say ( Kurt , D13-Kurt-2b ) else
24633: LD_EXP 57
24637: PPUSH
24638: LD_STRING D13-Kurt-2b
24640: PPUSH
24641: CALL_OW 88
24645: GO 24659
// Say ( Kurt , D13-Kurt-2a ) ;
24647: LD_EXP 57
24651: PPUSH
24652: LD_STRING D13-Kurt-2a
24654: PPUSH
24655: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24659: LD_EXP 57
24663: PPUSH
24664: LD_STRING D13-Kurt-2a
24666: PPUSH
24667: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24671: LD_EXP 36
24675: PPUSH
24676: LD_STRING D13-JMM-3
24678: PPUSH
24679: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24683: LD_EXP 57
24687: PPUSH
24688: LD_STRING D13-Kurt-3
24690: PPUSH
24691: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24695: LD_EXP 36
24699: PPUSH
24700: LD_STRING D13-JMM-4
24702: PPUSH
24703: CALL_OW 88
// DialogueOff ;
24707: CALL_OW 7
// MC_Kill ( 3 ) ;
24711: LD_INT 3
24713: PPUSH
24714: CALL 33980 0 1
// KillUnit ( Kozlov ) ;
24718: LD_EXP 58
24722: PPUSH
24723: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24727: LD_INT 22
24729: PUSH
24730: LD_INT 8
24732: PUSH
24733: EMPTY
24734: LIST
24735: LIST
24736: PUSH
24737: LD_INT 21
24739: PUSH
24740: LD_INT 3
24742: PUSH
24743: EMPTY
24744: LIST
24745: LIST
24746: PUSH
24747: LD_INT 23
24749: PUSH
24750: LD_INT 3
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PUSH
24757: LD_INT 30
24759: PUSH
24760: LD_INT 3
24762: PUSH
24763: EMPTY
24764: LIST
24765: LIST
24766: PUSH
24767: EMPTY
24768: LIST
24769: LIST
24770: LIST
24771: LIST
24772: PPUSH
24773: CALL_OW 69
24777: PUSH
24778: LD_INT 1
24780: ARRAY
24781: PPUSH
24782: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24786: LD_INT 8
24788: PPUSH
24789: LD_INT 1
24791: PPUSH
24792: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24796: LD_INT 22
24798: PUSH
24799: LD_INT 8
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PPUSH
24806: CALL_OW 69
24810: PPUSH
24811: LD_INT 1
24813: PPUSH
24814: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24818: LD_INT 8
24820: PPUSH
24821: LD_INT 1
24823: PPUSH
24824: LD_INT 1
24826: PPUSH
24827: LD_INT 1
24829: PPUSH
24830: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24834: LD_EXP 59
24838: PPUSH
24839: LD_INT 37
24841: PPUSH
24842: LD_INT 1
24844: PPUSH
24845: LD_INT 0
24847: PPUSH
24848: CALL_OW 48
// wait ( 0 0$1 ) ;
24852: LD_INT 35
24854: PPUSH
24855: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24859: LD_EXP 59
24863: PPUSH
24864: LD_INT 60
24866: PPUSH
24867: LD_INT 95
24869: PPUSH
24870: CALL_OW 111
// end ;
24874: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24875: LD_INT 22
24877: PUSH
24878: LD_INT 8
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: LD_INT 21
24887: PUSH
24888: LD_INT 1
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: PUSH
24895: EMPTY
24896: LIST
24897: LIST
24898: PPUSH
24899: CALL_OW 69
24903: PUSH
24904: LD_INT 0
24906: EQUAL
24907: IFFALSE 24927
24909: GO 24911
24911: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24912: LD_STRING MlegionOut
24914: PPUSH
24915: CALL_OW 337
// legionDestroyed := true ;
24919: LD_ADDR_EXP 22
24923: PUSH
24924: LD_INT 1
24926: ST_TO_ADDR
// end ;
24927: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24928: LD_INT 1
24930: PPUSH
24931: LD_EXP 59
24935: PPUSH
24936: CALL_OW 292
24940: IFFALSE 25240
24942: GO 24944
24944: DISABLE
24945: LD_INT 0
24947: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24948: LD_EXP 59
24952: PPUSH
24953: CALL_OW 87
// DialogueOn ;
24957: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24961: LD_EXP 36
24965: PPUSH
24966: LD_STRING D14-JMM-1
24968: PPUSH
24969: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24973: LD_EXP 59
24977: PPUSH
24978: LD_STRING D14-Friend-1
24980: PPUSH
24981: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24985: LD_EXP 36
24989: PPUSH
24990: LD_STRING D14-JMM-2
24992: PPUSH
24993: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
24997: LD_EXP 59
25001: PPUSH
25002: LD_STRING D14-Friend-2
25004: PPUSH
25005: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25009: LD_EXP 36
25013: PPUSH
25014: LD_STRING D14-JMM-3
25016: PPUSH
25017: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25021: LD_EXP 59
25025: PPUSH
25026: LD_STRING D14-Friend-3
25028: PPUSH
25029: CALL_OW 88
// DialogueOff ;
25033: CALL_OW 7
// dec = Query ( Q14 ) ;
25037: LD_ADDR_VAR 0 1
25041: PUSH
25042: LD_STRING Q14
25044: PPUSH
25045: CALL_OW 97
25049: ST_TO_ADDR
// if dec = 1 then
25050: LD_VAR 0 1
25054: PUSH
25055: LD_INT 1
25057: EQUAL
25058: IFFALSE 25092
// begin DialogueOn ;
25060: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25064: LD_EXP 36
25068: PPUSH
25069: LD_STRING D14a-JMM-1
25071: PPUSH
25072: CALL_OW 88
// DialogueOff ;
25076: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25080: LD_EXP 59
25084: PPUSH
25085: LD_INT 1
25087: PPUSH
25088: CALL_OW 235
// end ; if dec = 2 then
25092: LD_VAR 0 1
25096: PUSH
25097: LD_INT 2
25099: EQUAL
25100: IFFALSE 25146
// begin DialogueOn ;
25102: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25106: LD_EXP 36
25110: PPUSH
25111: LD_STRING D14b-JMM-1
25113: PPUSH
25114: CALL_OW 88
// DialogueOff ;
25118: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25122: LD_EXP 59
25126: PPUSH
25127: LD_INT 9
25129: PPUSH
25130: LD_INT 2
25132: PPUSH
25133: CALL_OW 111
// AddComHold ( Friend ) ;
25137: LD_EXP 59
25141: PPUSH
25142: CALL_OW 200
// end ; if dec = 3 then
25146: LD_VAR 0 1
25150: PUSH
25151: LD_INT 3
25153: EQUAL
25154: IFFALSE 25240
// begin DialogueOn ;
25156: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25160: LD_EXP 36
25164: PPUSH
25165: LD_STRING D14c-JMM-1
25167: PPUSH
25168: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25172: LD_EXP 59
25176: PPUSH
25177: LD_STRING D14c-Friend-1
25179: PPUSH
25180: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25184: LD_EXP 36
25188: PPUSH
25189: LD_STRING D14c-JMM-2
25191: PPUSH
25192: CALL_OW 88
// DialogueOff ;
25196: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25200: LD_INT 8
25202: PPUSH
25203: LD_INT 1
25205: PPUSH
25206: LD_INT 2
25208: PPUSH
25209: LD_INT 1
25211: PPUSH
25212: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25216: LD_EXP 59
25220: PPUSH
25221: LD_INT 9
25223: PPUSH
25224: LD_INT 2
25226: PPUSH
25227: CALL_OW 111
// AddComHold ( Friend ) ;
25231: LD_EXP 59
25235: PPUSH
25236: CALL_OW 200
// end ; end ;
25240: PPOPN 1
25242: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25243: LD_INT 9
25245: PPUSH
25246: LD_INT 2
25248: PPUSH
25249: CALL_OW 428
25253: PUSH
25254: LD_EXP 59
25258: EQUAL
25259: PUSH
25260: LD_EXP 59
25264: PPUSH
25265: CALL_OW 255
25269: PUSH
25270: LD_INT 8
25272: EQUAL
25273: AND
25274: IFFALSE 25288
25276: GO 25278
25278: DISABLE
// RemoveUnit ( Friend ) ;
25279: LD_EXP 59
25283: PPUSH
25284: CALL_OW 64
25288: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25289: LD_EXP 14
25293: PUSH
25294: LD_INT 31500
25296: GREATEREQUAL
25297: PUSH
25298: LD_EXP 7
25302: AND
25303: PUSH
25304: LD_EXP 2
25308: AND
25309: IFFALSE 25739
25311: GO 25313
25313: DISABLE
25314: LD_INT 0
25316: PPUSH
25317: PPUSH
25318: PPUSH
// begin missionStage := 7 ;
25319: LD_ADDR_EXP 15
25323: PUSH
25324: LD_INT 7
25326: ST_TO_ADDR
// uc_side = 1 ;
25327: LD_ADDR_OWVAR 20
25331: PUSH
25332: LD_INT 1
25334: ST_TO_ADDR
// uc_nation = 1 ;
25335: LD_ADDR_OWVAR 21
25339: PUSH
25340: LD_INT 1
25342: ST_TO_ADDR
// for i = 1 to 5 do
25343: LD_ADDR_VAR 0 1
25347: PUSH
25348: DOUBLE
25349: LD_INT 1
25351: DEC
25352: ST_TO_ADDR
25353: LD_INT 5
25355: PUSH
25356: FOR_TO
25357: IFFALSE 25453
// begin vc_engine = 3 ;
25359: LD_ADDR_OWVAR 39
25363: PUSH
25364: LD_INT 3
25366: ST_TO_ADDR
// vc_control = 3 ;
25367: LD_ADDR_OWVAR 38
25371: PUSH
25372: LD_INT 3
25374: ST_TO_ADDR
// vc_chassis = 3 ;
25375: LD_ADDR_OWVAR 37
25379: PUSH
25380: LD_INT 3
25382: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25383: LD_ADDR_OWVAR 40
25387: PUSH
25388: LD_INT 5
25390: PUSH
25391: LD_INT 9
25393: PUSH
25394: LD_INT 7
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: LIST
25401: PUSH
25402: LD_INT 1
25404: PPUSH
25405: LD_INT 3
25407: PPUSH
25408: CALL_OW 12
25412: ARRAY
25413: ST_TO_ADDR
// veh = CreateVehicle ;
25414: LD_ADDR_VAR 0 2
25418: PUSH
25419: CALL_OW 45
25423: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25424: LD_VAR 0 2
25428: PPUSH
25429: LD_INT 1
25431: PPUSH
25432: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25436: LD_VAR 0 2
25440: PPUSH
25441: LD_INT 19
25443: PPUSH
25444: LD_INT 0
25446: PPUSH
25447: CALL_OW 49
// end ;
25451: GO 25356
25453: POP
25454: POP
// vc_engine = 3 ;
25455: LD_ADDR_OWVAR 39
25459: PUSH
25460: LD_INT 3
25462: ST_TO_ADDR
// vc_control = 1 ;
25463: LD_ADDR_OWVAR 38
25467: PUSH
25468: LD_INT 1
25470: ST_TO_ADDR
// vc_chassis = 3 ;
25471: LD_ADDR_OWVAR 37
25475: PUSH
25476: LD_INT 3
25478: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25479: LD_ADDR_OWVAR 40
25483: PUSH
25484: LD_INT 5
25486: PUSH
25487: LD_INT 9
25489: PUSH
25490: LD_INT 7
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: LIST
25497: PUSH
25498: LD_INT 1
25500: PPUSH
25501: LD_INT 3
25503: PPUSH
25504: CALL_OW 12
25508: ARRAY
25509: ST_TO_ADDR
// vehG = CreateVehicle ;
25510: LD_ADDR_VAR 0 3
25514: PUSH
25515: CALL_OW 45
25519: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25520: LD_VAR 0 3
25524: PPUSH
25525: LD_INT 1
25527: PPUSH
25528: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25532: LD_VAR 0 3
25536: PPUSH
25537: LD_INT 19
25539: PPUSH
25540: LD_INT 0
25542: PPUSH
25543: CALL_OW 49
// if JMMGirl = 1 then
25547: LD_EXP 7
25551: PUSH
25552: LD_INT 1
25554: EQUAL
25555: IFFALSE 25611
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25557: LD_ADDR_EXP 37
25561: PUSH
25562: LD_STRING Joan
25564: PPUSH
25565: LD_INT 1
25567: PPUSH
25568: LD_STRING 14_
25570: PPUSH
25571: CALL 62968 0 3
25575: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25576: LD_EXP 37
25580: PPUSH
25581: LD_VAR 0 3
25585: PPUSH
25586: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25590: LD_VAR 0 3
25594: PPUSH
25595: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25599: LD_EXP 37
25603: PPUSH
25604: LD_STRING D10BW-Joan-1
25606: PPUSH
25607: CALL_OW 94
// end ; if JMMGirl = 2 then
25611: LD_EXP 7
25615: PUSH
25616: LD_INT 2
25618: EQUAL
25619: IFFALSE 25675
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25621: LD_ADDR_EXP 39
25625: PUSH
25626: LD_STRING Lisa
25628: PPUSH
25629: LD_INT 1
25631: PPUSH
25632: LD_STRING 14_
25634: PPUSH
25635: CALL 62968 0 3
25639: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25640: LD_EXP 39
25644: PPUSH
25645: LD_VAR 0 3
25649: PPUSH
25650: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25654: LD_VAR 0 3
25658: PPUSH
25659: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25663: LD_EXP 39
25667: PPUSH
25668: LD_STRING D10BW-Lisa-1
25670: PPUSH
25671: CALL_OW 94
// end ; if JMMGirl = 3 then
25675: LD_EXP 7
25679: PUSH
25680: LD_INT 3
25682: EQUAL
25683: IFFALSE 25739
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25685: LD_ADDR_EXP 51
25689: PUSH
25690: LD_STRING Connie
25692: PPUSH
25693: LD_INT 1
25695: PPUSH
25696: LD_STRING 14_
25698: PPUSH
25699: CALL 62968 0 3
25703: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25704: LD_EXP 51
25708: PPUSH
25709: LD_VAR 0 3
25713: PPUSH
25714: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25718: LD_VAR 0 3
25722: PPUSH
25723: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25727: LD_EXP 39
25731: PPUSH
25732: LD_STRING D10BW-Con-1
25734: PPUSH
25735: CALL_OW 94
// end ; end ;
25739: PPOPN 3
25741: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25742: LD_EXP 14
25746: PUSH
25747: LD_INT 94500
25749: GREATEREQUAL
25750: IFFALSE 26162
25752: GO 25754
25754: DISABLE
25755: LD_INT 0
25757: PPUSH
25758: PPUSH
25759: PPUSH
// begin tmp := PrepareStevensSquad ;
25760: LD_ADDR_VAR 0 3
25764: PUSH
25765: CALL 2109 0 0
25769: ST_TO_ADDR
// if not tmp then
25770: LD_VAR 0 3
25774: NOT
25775: IFFALSE 25779
// exit ;
25777: GO 26162
// uc_side := 1 ;
25779: LD_ADDR_OWVAR 20
25783: PUSH
25784: LD_INT 1
25786: ST_TO_ADDR
// uc_nation := 1 ;
25787: LD_ADDR_OWVAR 21
25791: PUSH
25792: LD_INT 1
25794: ST_TO_ADDR
// for i in tmp do
25795: LD_ADDR_VAR 0 1
25799: PUSH
25800: LD_VAR 0 3
25804: PUSH
25805: FOR_IN
25806: IFFALSE 25903
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25808: LD_INT 3
25810: PPUSH
25811: LD_INT 3
25813: PPUSH
25814: LD_INT 1
25816: PPUSH
25817: LD_INT 5
25819: PUSH
25820: LD_INT 9
25822: PUSH
25823: LD_INT 7
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: LIST
25830: PUSH
25831: LD_INT 1
25833: PPUSH
25834: LD_INT 3
25836: PPUSH
25837: CALL_OW 12
25841: ARRAY
25842: PPUSH
25843: LD_INT 40
25845: PPUSH
25846: CALL 69579 0 5
// veh := CreateVehicle ;
25850: LD_ADDR_VAR 0 2
25854: PUSH
25855: CALL_OW 45
25859: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25860: LD_VAR 0 2
25864: PPUSH
25865: LD_INT 1
25867: PPUSH
25868: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25872: LD_VAR 0 2
25876: PPUSH
25877: LD_INT 19
25879: PPUSH
25880: LD_INT 0
25882: PPUSH
25883: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25887: LD_VAR 0 1
25891: PPUSH
25892: LD_VAR 0 2
25896: PPUSH
25897: CALL_OW 52
// end ;
25901: GO 25805
25903: POP
25904: POP
// missionStage := 8 ;
25905: LD_ADDR_EXP 15
25909: PUSH
25910: LD_INT 8
25912: ST_TO_ADDR
// DialogueOn ;
25913: CALL_OW 6
// if Stevens then
25917: LD_EXP 38
25921: IFFALSE 26035
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25923: LD_EXP 38
25927: PPUSH
25928: CALL_OW 310
25932: PPUSH
25933: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25937: LD_EXP 38
25941: PPUSH
25942: LD_STRING D8-Huck-1
25944: PPUSH
25945: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25949: LD_EXP 36
25953: PPUSH
25954: LD_STRING D8-JMM-1
25956: PPUSH
25957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25961: LD_EXP 38
25965: PPUSH
25966: LD_STRING D8-Huck-2
25968: PPUSH
25969: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25973: LD_EXP 36
25977: PPUSH
25978: LD_STRING D8-JMM-2
25980: PPUSH
25981: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25985: LD_EXP 38
25989: PPUSH
25990: LD_STRING D8-Huck-3
25992: PPUSH
25993: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25997: LD_EXP 36
26001: PPUSH
26002: LD_STRING D8-JMM-3
26004: PPUSH
26005: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26009: LD_EXP 38
26013: PPUSH
26014: LD_STRING D8-Huck-4
26016: PPUSH
26017: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26021: LD_EXP 36
26025: PPUSH
26026: LD_STRING D8-JMM-4
26028: PPUSH
26029: CALL_OW 88
// end else
26033: GO 26145
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26035: LD_EXP 52
26039: PPUSH
26040: CALL_OW 310
26044: PPUSH
26045: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26049: LD_EXP 52
26053: PPUSH
26054: LD_STRING D8-Huck-1
26056: PPUSH
26057: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26061: LD_EXP 36
26065: PPUSH
26066: LD_STRING D8-JMM-1a
26068: PPUSH
26069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26073: LD_EXP 52
26077: PPUSH
26078: LD_STRING D8-Huck-2
26080: PPUSH
26081: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26085: LD_EXP 36
26089: PPUSH
26090: LD_STRING D8-JMM-2
26092: PPUSH
26093: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26097: LD_EXP 52
26101: PPUSH
26102: LD_STRING D8-Huck-3
26104: PPUSH
26105: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26109: LD_EXP 36
26113: PPUSH
26114: LD_STRING D8-JMM-3
26116: PPUSH
26117: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26121: LD_EXP 52
26125: PPUSH
26126: LD_STRING D8-Huck-4
26128: PPUSH
26129: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26133: LD_EXP 36
26137: PPUSH
26138: LD_STRING D8-JMM-4
26140: PPUSH
26141: CALL_OW 88
// end ; DialogueOff ;
26145: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26149: LD_INT 25
26151: PPUSH
26152: LD_INT 1
26154: PPUSH
26155: LD_INT 1
26157: PPUSH
26158: CALL_OW 322
// end ;
26162: PPOPN 3
26164: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26165: LD_INT 1
26167: PPUSH
26168: LD_EXP 68
26172: PPUSH
26173: CALL_OW 292
26177: IFFALSE 26428
26179: GO 26181
26181: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26182: LD_EXP 68
26186: PPUSH
26187: CALL_OW 87
// DialogueOn ;
26191: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26195: LD_EXP 36
26199: PPUSH
26200: LD_STRING D10nB-JMM-1
26202: PPUSH
26203: CALL_OW 88
// if BurlakStatus = 1 then
26207: LD_EXP 9
26211: PUSH
26212: LD_INT 1
26214: EQUAL
26215: IFFALSE 26229
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26217: LD_EXP 67
26221: PPUSH
26222: LD_STRING D10nB-Vse-1a
26224: PPUSH
26225: CALL_OW 94
// end ; if BurlakStatus = 0 then
26229: LD_EXP 9
26233: PUSH
26234: LD_INT 0
26236: EQUAL
26237: IFFALSE 26251
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26239: LD_EXP 67
26243: PPUSH
26244: LD_STRING D10nB-Vse-1
26246: PPUSH
26247: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26251: LD_EXP 36
26255: PPUSH
26256: LD_STRING D10nB-JMM-2
26258: PPUSH
26259: CALL_OW 88
// if KappaStatus then
26263: LD_EXP 2
26267: IFFALSE 26281
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26269: LD_EXP 67
26273: PPUSH
26274: LD_STRING D10nB-Vse-5a
26276: PPUSH
26277: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26281: LD_EXP 2
26285: NOT
26286: PUSH
26287: LD_EXP 6
26291: PUSH
26292: LD_INT 0
26294: EQUAL
26295: AND
26296: IFFALSE 26424
// begin if JMMGirl = 1 then
26298: LD_EXP 7
26302: PUSH
26303: LD_INT 1
26305: EQUAL
26306: IFFALSE 26356
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26308: LD_EXP 67
26312: PPUSH
26313: LD_STRING D10nB-Vse-2
26315: PPUSH
26316: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26320: LD_EXP 36
26324: PPUSH
26325: LD_STRING D10nB-JMM-3
26327: PPUSH
26328: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26332: LD_EXP 67
26336: PPUSH
26337: LD_STRING D10nB-Vse-3
26339: PPUSH
26340: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26344: LD_EXP 36
26348: PPUSH
26349: LD_STRING D10nB-JMM-4
26351: PPUSH
26352: CALL_OW 88
// end ; if JMMGirl = 2 then
26356: LD_EXP 7
26360: PUSH
26361: LD_INT 2
26363: EQUAL
26364: IFFALSE 26390
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26366: LD_EXP 67
26370: PPUSH
26371: LD_STRING D10nB-Vse-4
26373: PPUSH
26374: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26378: LD_EXP 36
26382: PPUSH
26383: LD_STRING D10nB-JMM-5
26385: PPUSH
26386: CALL_OW 88
// end ; if JMMGirl = 3 then
26390: LD_EXP 7
26394: PUSH
26395: LD_INT 3
26397: EQUAL
26398: IFFALSE 26424
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26400: LD_EXP 67
26404: PPUSH
26405: LD_STRING D10nB-Vse-5
26407: PPUSH
26408: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26412: LD_EXP 36
26416: PPUSH
26417: LD_STRING D10nB-JMM-6
26419: PPUSH
26420: CALL_OW 88
// end ; end ; DialogueOff ;
26424: CALL_OW 7
// end ;
26428: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26429: LD_EXP 14
26433: PUSH
26434: LD_INT 115500
26436: GREATEREQUAL
26437: IFFALSE 26796
26439: GO 26441
26441: DISABLE
26442: LD_INT 0
26444: PPUSH
// begin missionStage := 10 ;
26445: LD_ADDR_EXP 15
26449: PUSH
26450: LD_INT 10
26452: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26453: LD_ADDR_VAR 0 1
26457: PUSH
26458: LD_INT 22
26460: PUSH
26461: LD_INT 1
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: LD_INT 26
26470: PUSH
26471: LD_INT 1
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: PUSH
26478: LD_INT 3
26480: PUSH
26481: LD_INT 25
26483: PUSH
26484: LD_INT 12
26486: PUSH
26487: EMPTY
26488: LIST
26489: LIST
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: PUSH
26495: LD_INT 3
26497: PUSH
26498: LD_INT 25
26500: PUSH
26501: LD_INT 16
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: LIST
26516: LIST
26517: PPUSH
26518: CALL_OW 69
26522: PUSH
26523: LD_EXP 36
26527: PUSH
26528: LD_EXP 38
26532: PUSH
26533: LD_EXP 52
26537: PUSH
26538: LD_EXP 39
26542: PUSH
26543: LD_EXP 40
26547: PUSH
26548: LD_EXP 41
26552: PUSH
26553: LD_EXP 42
26557: PUSH
26558: LD_EXP 43
26562: PUSH
26563: LD_EXP 44
26567: PUSH
26568: LD_EXP 45
26572: PUSH
26573: LD_EXP 46
26577: PUSH
26578: LD_EXP 47
26582: PUSH
26583: LD_EXP 48
26587: PUSH
26588: LD_EXP 49
26592: PUSH
26593: LD_EXP 50
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: LIST
26602: LIST
26603: LIST
26604: LIST
26605: LIST
26606: LIST
26607: LIST
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: LIST
26613: LIST
26614: DIFF
26615: ST_TO_ADDR
// if not tmp and Brown then
26616: LD_VAR 0 1
26620: NOT
26621: PUSH
26622: LD_EXP 44
26626: AND
26627: IFFALSE 26642
// tmp := [ Brown ] ;
26629: LD_ADDR_VAR 0 1
26633: PUSH
26634: LD_EXP 44
26638: PUSH
26639: EMPTY
26640: LIST
26641: ST_TO_ADDR
// DialogueOn ;
26642: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26646: LD_VAR 0 1
26650: PUSH
26651: LD_INT 1
26653: ARRAY
26654: PPUSH
26655: LD_STRING D11-Sol1-1
26657: PPUSH
26658: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26662: LD_EXP 61
26666: PPUSH
26667: LD_STRING D11-Pla-1
26669: PPUSH
26670: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26674: LD_EXP 62
26678: PPUSH
26679: LD_STRING D11-Kov-1
26681: PPUSH
26682: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26686: LD_EXP 61
26690: PPUSH
26691: LD_STRING D11-Pla-2
26693: PPUSH
26694: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26698: LD_VAR 0 1
26702: PUSH
26703: LD_INT 1
26705: ARRAY
26706: PPUSH
26707: LD_STRING D11-Sol1-2
26709: PPUSH
26710: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26714: LD_EXP 36
26718: PPUSH
26719: LD_STRING D11-JMM-2
26721: PPUSH
26722: CALL_OW 88
// DialogueOff ;
26726: CALL_OW 7
// allowBehemothConstruct := true ;
26730: LD_ADDR_EXP 25
26734: PUSH
26735: LD_INT 1
26737: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26738: LD_STRING M4
26740: PPUSH
26741: CALL_OW 337
// BuildBehemoths ;
26745: CALL 7539 0 0
// repeat wait ( 15 15$00 ) ;
26749: LD_INT 31500
26751: PPUSH
26752: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26756: LD_EXP 27
26760: IFFALSE 26764
// break ;
26762: GO 26796
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26764: LD_INT 267
26766: PPUSH
26767: CALL_OW 274
26771: PPUSH
26772: LD_INT 1
26774: PPUSH
26775: CALL_OW 275
26779: PUSH
26780: LD_INT 1000
26782: GREATEREQUAL
26783: IFFALSE 26789
// BuildBehemoths ;
26785: CALL 7539 0 0
// until not behemothBuilders ;
26789: LD_EXP 70
26793: NOT
26794: IFFALSE 26749
// end ;
26796: PPOPN 1
26798: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26799: LD_EXP 70
26803: NOT
26804: PUSH
26805: LD_EXP 28
26809: NOT
26810: AND
26811: PUSH
26812: LD_EXP 25
26816: AND
26817: IFFALSE 26837
26819: GO 26821
26821: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26822: LD_STRING M4a
26824: PPUSH
26825: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26829: LD_ADDR_EXP 27
26833: PUSH
26834: LD_INT 1
26836: ST_TO_ADDR
// end ;
26837: END
// every 0 0$1 trigger behemothDone do
26838: LD_EXP 28
26842: IFFALSE 26854
26844: GO 26846
26846: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26847: LD_STRING M4b
26849: PPUSH
26850: CALL_OW 337
26854: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26855: LD_EXP 29
26859: NOT
26860: IFFALSE 27056
26862: GO 26864
26864: DISABLE
26865: LD_INT 0
26867: PPUSH
26868: PPUSH
// begin enable ;
26869: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26870: LD_ADDR_VAR 0 1
26874: PUSH
26875: LD_INT 3
26877: PPUSH
26878: CALL 105372 0 1
26882: ST_TO_ADDR
// if not tmp and not behemothDone then
26883: LD_VAR 0 1
26887: NOT
26888: PUSH
26889: LD_EXP 28
26893: NOT
26894: AND
26895: IFFALSE 26931
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26897: LD_ADDR_VAR 0 1
26901: PUSH
26902: LD_INT 22
26904: PUSH
26905: LD_INT 3
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 30
26914: PUSH
26915: LD_INT 37
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: PPUSH
26926: CALL_OW 69
26930: ST_TO_ADDR
// if not tmp then
26931: LD_VAR 0 1
26935: NOT
26936: IFFALSE 26940
// exit ;
26938: GO 27056
// for i in tmp do
26940: LD_ADDR_VAR 0 2
26944: PUSH
26945: LD_VAR 0 1
26949: PUSH
26950: FOR_IN
26951: IFFALSE 27054
// if See ( 1 , i ) then
26953: LD_INT 1
26955: PPUSH
26956: LD_VAR 0 2
26960: PPUSH
26961: CALL_OW 292
26965: IFFALSE 27052
// begin if GetType ( i ) = unit_building then
26967: LD_VAR 0 2
26971: PPUSH
26972: CALL_OW 247
26976: PUSH
26977: LD_INT 3
26979: EQUAL
26980: IFFALSE 27018
// begin CenterNowOnUnits ( i ) ;
26982: LD_VAR 0 2
26986: PPUSH
26987: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26991: LD_EXP 36
26995: PPUSH
26996: LD_STRING D17a-JMM-1
26998: PPUSH
26999: CALL_OW 88
// seeBehemoth := true ;
27003: LD_ADDR_EXP 29
27007: PUSH
27008: LD_INT 1
27010: ST_TO_ADDR
// disable ;
27011: DISABLE
// exit ;
27012: POP
27013: POP
27014: GO 27056
// end else
27016: GO 27052
// begin CenterNowOnUnits ( i ) ;
27018: LD_VAR 0 2
27022: PPUSH
27023: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27027: LD_EXP 36
27031: PPUSH
27032: LD_STRING D17b-JMM-1
27034: PPUSH
27035: CALL_OW 88
// seeBehemoth := true ;
27039: LD_ADDR_EXP 29
27043: PUSH
27044: LD_INT 1
27046: ST_TO_ADDR
// disable ;
27047: DISABLE
// exit ;
27048: POP
27049: POP
27050: GO 27056
// end ; end ;
27052: GO 26950
27054: POP
27055: POP
// end ;
27056: PPOPN 2
27058: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27059: LD_EXP 14
27063: PUSH
27064: LD_INT 116550
27066: GREATEREQUAL
27067: IFFALSE 28243
27069: GO 27071
27071: DISABLE
27072: LD_INT 0
27074: PPUSH
27075: PPUSH
27076: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27077: LD_INT 2
27079: PPUSH
27080: LD_INT 23
27082: PUSH
27083: LD_INT 3
27085: PUSH
27086: LD_INT 3
27088: PUSH
27089: LD_INT 48
27091: PUSH
27092: EMPTY
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: PUSH
27098: EMPTY
27099: LIST
27100: PPUSH
27101: CALL 56966 0 2
// repeat wait ( 0 0$1 ) ;
27105: LD_INT 35
27107: PPUSH
27108: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27112: LD_INT 22
27114: PUSH
27115: LD_INT 3
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: LD_INT 34
27124: PUSH
27125: LD_INT 48
27127: PUSH
27128: EMPTY
27129: LIST
27130: LIST
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: PPUSH
27136: CALL_OW 69
27140: IFFALSE 27105
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27142: LD_ADDR_VAR 0 1
27146: PUSH
27147: LD_INT 22
27149: PUSH
27150: LD_INT 3
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: PUSH
27157: LD_INT 34
27159: PUSH
27160: LD_INT 48
27162: PUSH
27163: EMPTY
27164: LIST
27165: LIST
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PPUSH
27171: CALL_OW 69
27175: PUSH
27176: LD_INT 1
27178: ARRAY
27179: ST_TO_ADDR
// missionStage := 12 ;
27180: LD_ADDR_EXP 15
27184: PUSH
27185: LD_INT 12
27187: ST_TO_ADDR
// platonovHasBomb := true ;
27188: LD_ADDR_EXP 30
27192: PUSH
27193: LD_INT 1
27195: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27196: LD_VAR 0 1
27200: PPUSH
27201: LD_INT 181
27203: PPUSH
27204: LD_INT 86
27206: PPUSH
27207: CALL_OW 171
// AddComHold ( bomb ) ;
27211: LD_VAR 0 1
27215: PPUSH
27216: CALL_OW 200
// wait ( 0 0$10 ) ;
27220: LD_INT 350
27222: PPUSH
27223: CALL_OW 67
// DialogueOn ;
27227: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27231: LD_EXP 61
27235: PPUSH
27236: LD_STRING D15-Pla-1
27238: PPUSH
27239: CALL_OW 94
// dec = Query ( Q15a ) ;
27243: LD_ADDR_VAR 0 2
27247: PUSH
27248: LD_STRING Q15a
27250: PPUSH
27251: CALL_OW 97
27255: ST_TO_ADDR
// if dec = 1 then
27256: LD_VAR 0 2
27260: PUSH
27261: LD_INT 1
27263: EQUAL
27264: IFFALSE 27287
// begin Say ( JMM , D15a-JMM-1 ) ;
27266: LD_EXP 36
27270: PPUSH
27271: LD_STRING D15a-JMM-1
27273: PPUSH
27274: CALL_OW 88
// YouLost ( Surrender ) ;
27278: LD_STRING Surrender
27280: PPUSH
27281: CALL_OW 104
// exit ;
27285: GO 28243
// end ; if dec = 2 then
27287: LD_VAR 0 2
27291: PUSH
27292: LD_INT 2
27294: EQUAL
27295: IFFALSE 27364
// begin Say ( JMM , D15b-JMM-1 ) ;
27297: LD_EXP 36
27301: PPUSH
27302: LD_STRING D15b-JMM-1
27304: PPUSH
27305: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27309: LD_EXP 61
27313: PPUSH
27314: LD_STRING D15b-Pla-1
27316: PPUSH
27317: CALL_OW 94
// DialogueOff ;
27321: CALL_OW 7
// wait ( 3 3$00 ) ;
27325: LD_INT 6300
27327: PPUSH
27328: CALL_OW 67
// DialogueOn ;
27332: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27336: LD_EXP 36
27340: PPUSH
27341: LD_STRING D15d-JMM-1a
27343: PPUSH
27344: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27348: LD_EXP 61
27352: PPUSH
27353: LD_STRING D15d-Pla-1
27355: PPUSH
27356: CALL_OW 94
// DialogueOff ;
27360: CALL_OW 7
// end ; if dec = 3 then
27364: LD_VAR 0 2
27368: PUSH
27369: LD_INT 3
27371: EQUAL
27372: IFFALSE 27426
// begin Say ( JMM , D15c-JMM-1 ) ;
27374: LD_EXP 36
27378: PPUSH
27379: LD_STRING D15c-JMM-1
27381: PPUSH
27382: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27386: LD_EXP 61
27390: PPUSH
27391: LD_STRING D15c-Pla-1
27393: PPUSH
27394: CALL_OW 94
// DialogueOff ;
27398: CALL_OW 7
// wait ( 0 0$15 ) ;
27402: LD_INT 525
27404: PPUSH
27405: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27409: LD_VAR 0 1
27413: PPUSH
27414: LD_INT 60
27416: PPUSH
27417: LD_INT 95
27419: PPUSH
27420: CALL_OW 116
// exit ;
27424: GO 28243
// end ; if dec = 4 then
27426: LD_VAR 0 2
27430: PUSH
27431: LD_INT 4
27433: EQUAL
27434: IFFALSE 27464
// begin Say ( JMM , D15d-JMM-1 ) ;
27436: LD_EXP 36
27440: PPUSH
27441: LD_STRING D15d-JMM-1
27443: PPUSH
27444: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27448: LD_EXP 61
27452: PPUSH
27453: LD_STRING D15d-Pla-1
27455: PPUSH
27456: CALL_OW 94
// DialogueOff ;
27460: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27464: LD_EXP 59
27468: PPUSH
27469: CALL_OW 302
27473: PUSH
27474: LD_EXP 59
27478: PPUSH
27479: CALL_OW 255
27483: PUSH
27484: LD_INT 1
27486: EQUAL
27487: AND
27488: PUSH
27489: LD_INT 22
27491: PUSH
27492: LD_INT 1
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: PUSH
27499: LD_INT 34
27501: PUSH
27502: LD_INT 8
27504: PUSH
27505: EMPTY
27506: LIST
27507: LIST
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: PPUSH
27513: CALL_OW 69
27517: NOT
27518: AND
27519: IFFALSE 28144
// begin SetSide ( Friend , 8 ) ;
27521: LD_EXP 59
27525: PPUSH
27526: LD_INT 8
27528: PPUSH
27529: CALL_OW 235
// if IsInUnit ( Friend ) then
27533: LD_EXP 59
27537: PPUSH
27538: CALL_OW 310
27542: IFFALSE 27553
// ComExitBuilding ( Friend ) ;
27544: LD_EXP 59
27548: PPUSH
27549: CALL_OW 122
// if IsDriver ( Friend ) then
27553: LD_EXP 59
27557: PPUSH
27558: CALL 103049 0 1
27562: IFFALSE 27573
// ComExitVehicle ( Friend ) ;
27564: LD_EXP 59
27568: PPUSH
27569: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27573: LD_EXP 59
27577: PPUSH
27578: LD_INT 9
27580: PPUSH
27581: LD_INT 2
27583: PPUSH
27584: CALL_OW 171
// wait ( 0 0$05 ) ;
27588: LD_INT 175
27590: PPUSH
27591: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27595: LD_EXP 59
27599: PPUSH
27600: CALL_OW 87
// DialogueOn ;
27604: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27608: LD_EXP 36
27612: PPUSH
27613: LD_STRING D16-JMM-1
27615: PPUSH
27616: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27620: LD_EXP 59
27624: PPUSH
27625: LD_STRING D16-Friend-1
27627: PPUSH
27628: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27632: LD_EXP 36
27636: PPUSH
27637: LD_STRING D16-JMM-2
27639: PPUSH
27640: CALL_OW 88
// DialogueOff ;
27644: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27648: LD_EXP 59
27652: PPUSH
27653: LD_INT 1
27655: PPUSH
27656: CALL_OW 235
// ComHold ( Friend ) ;
27660: LD_EXP 59
27664: PPUSH
27665: CALL_OW 140
// wait ( 0 0$20 ) ;
27669: LD_INT 700
27671: PPUSH
27672: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27676: LD_EXP 59
27680: PPUSH
27681: LD_INT 9
27683: PPUSH
27684: LD_INT 2
27686: PPUSH
27687: CALL_OW 297
27691: PUSH
27692: LD_INT 30
27694: LESS
27695: IFFALSE 27764
// begin SetSide ( Friend , 8 ) ;
27697: LD_EXP 59
27701: PPUSH
27702: LD_INT 8
27704: PPUSH
27705: CALL_OW 235
// if IsInUnit ( Friend ) then
27709: LD_EXP 59
27713: PPUSH
27714: CALL_OW 310
27718: IFFALSE 27729
// ComExitBuilding ( Friend ) ;
27720: LD_EXP 59
27724: PPUSH
27725: CALL_OW 122
// if IsDriver ( Friend ) then
27729: LD_EXP 59
27733: PPUSH
27734: CALL 103049 0 1
27738: IFFALSE 27749
// ComExitVehicle ( Friend ) ;
27740: LD_EXP 59
27744: PPUSH
27745: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27749: LD_EXP 59
27753: PPUSH
27754: LD_INT 9
27756: PPUSH
27757: LD_INT 2
27759: PPUSH
27760: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27764: LD_INT 1050
27766: PPUSH
27767: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27771: LD_INT 22
27773: PUSH
27774: LD_INT 1
27776: PUSH
27777: EMPTY
27778: LIST
27779: LIST
27780: PUSH
27781: LD_INT 34
27783: PUSH
27784: LD_INT 8
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PPUSH
27795: CALL_OW 69
27799: NOT
27800: IFFALSE 28122
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27802: LD_ADDR_VAR 0 3
27806: PUSH
27807: LD_INT 22
27809: PUSH
27810: LD_INT 1
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: PUSH
27817: LD_INT 26
27819: PUSH
27820: LD_INT 1
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 3
27829: PUSH
27830: LD_INT 25
27832: PUSH
27833: LD_INT 12
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: LD_INT 25
27842: PUSH
27843: LD_INT 16
27845: PUSH
27846: EMPTY
27847: LIST
27848: LIST
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: LIST
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: LIST
27859: PPUSH
27860: CALL_OW 69
27864: PUSH
27865: LD_EXP 36
27869: PUSH
27870: LD_EXP 38
27874: PUSH
27875: LD_EXP 52
27879: PUSH
27880: LD_EXP 39
27884: PUSH
27885: LD_EXP 40
27889: PUSH
27890: LD_EXP 41
27894: PUSH
27895: LD_EXP 42
27899: PUSH
27900: LD_EXP 43
27904: PUSH
27905: LD_EXP 44
27909: PUSH
27910: LD_EXP 45
27914: PUSH
27915: LD_EXP 46
27919: PUSH
27920: LD_EXP 47
27924: PUSH
27925: LD_EXP 48
27929: PUSH
27930: LD_EXP 49
27934: PUSH
27935: LD_EXP 50
27939: PUSH
27940: EMPTY
27941: LIST
27942: LIST
27943: LIST
27944: LIST
27945: LIST
27946: LIST
27947: LIST
27948: LIST
27949: LIST
27950: LIST
27951: LIST
27952: LIST
27953: LIST
27954: LIST
27955: LIST
27956: DIFF
27957: ST_TO_ADDR
// DialogueOn ;
27958: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27962: LD_EXP 61
27966: PPUSH
27967: LD_STRING D16a-Pla-1
27969: PPUSH
27970: CALL_OW 94
// if Stevens then
27974: LD_EXP 38
27978: IFFALSE 27994
// Say ( Stevens , D16a-Huck-1 ) else
27980: LD_EXP 38
27984: PPUSH
27985: LD_STRING D16a-Huck-1
27987: PPUSH
27988: CALL_OW 88
27992: GO 28036
// if Baker then
27994: LD_EXP 52
27998: IFFALSE 28014
// Say ( Baker , D16a-Huck-1 ) else
28000: LD_EXP 52
28004: PPUSH
28005: LD_STRING D16a-Huck-1
28007: PPUSH
28008: CALL_OW 88
28012: GO 28036
// if tmp then
28014: LD_VAR 0 3
28018: IFFALSE 28036
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28020: LD_VAR 0 3
28024: PUSH
28025: LD_INT 1
28027: ARRAY
28028: PPUSH
28029: LD_STRING D16a-Sol1-1
28031: PPUSH
28032: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28036: LD_EXP 59
28040: PPUSH
28041: CALL_OW 255
28045: PUSH
28046: LD_INT 8
28048: EQUAL
28049: IFFALSE 28065
// Say ( JMM , D16a-JMM-1 ) else
28051: LD_EXP 36
28055: PPUSH
28056: LD_STRING D16a-JMM-1
28058: PPUSH
28059: CALL_OW 88
28063: GO 28101
// begin Say ( JMM , D16a-JMM-1a ) ;
28065: LD_EXP 36
28069: PPUSH
28070: LD_STRING D16a-JMM-1a
28072: PPUSH
28073: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28077: LD_EXP 59
28081: PPUSH
28082: LD_STRING D16a-Friend-1
28084: PPUSH
28085: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28089: LD_EXP 59
28093: PPUSH
28094: LD_INT 3
28096: PPUSH
28097: CALL_OW 235
// end ; DialogueOff ;
28101: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28105: LD_VAR 0 1
28109: PPUSH
28110: LD_INT 60
28112: PPUSH
28113: LD_INT 95
28115: PPUSH
28116: CALL_OW 116
// end else
28120: GO 28142
// begin DialogueOn ;
28122: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28126: LD_EXP 61
28130: PPUSH
28131: LD_STRING D16c-Pla-
28133: PPUSH
28134: CALL_OW 94
// DialogueOff ;
28138: CALL_OW 7
// end ; end else
28142: GO 28243
// begin wait ( 3 3$00 ) ;
28144: LD_INT 6300
28146: PPUSH
28147: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28151: LD_INT 22
28153: PUSH
28154: LD_INT 1
28156: PUSH
28157: EMPTY
28158: LIST
28159: LIST
28160: PUSH
28161: LD_INT 34
28163: PUSH
28164: LD_INT 8
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: PUSH
28171: EMPTY
28172: LIST
28173: LIST
28174: PPUSH
28175: CALL_OW 69
28179: NOT
28180: IFFALSE 28223
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28182: LD_EXP 61
28186: PPUSH
28187: LD_STRING D16b-Pla-1
28189: PPUSH
28190: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28194: LD_EXP 36
28198: PPUSH
28199: LD_STRING D16b-JMM-
28201: PPUSH
28202: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28206: LD_VAR 0 1
28210: PPUSH
28211: LD_INT 60
28213: PPUSH
28214: LD_INT 95
28216: PPUSH
28217: CALL_OW 116
// end else
28221: GO 28243
// begin DialogueOn ;
28223: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28227: LD_EXP 61
28231: PPUSH
28232: LD_STRING D16c-Pla-
28234: PPUSH
28235: CALL_OW 94
// DialogueOff ;
28239: CALL_OW 7
// end ; end ; end ;
28243: PPOPN 3
28245: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28246: LD_EXP 14
28250: PUSH
28251: LD_INT 126000
28253: GREATEREQUAL
28254: PUSH
28255: LD_EXP 23
28259: NOT
28260: AND
28261: PUSH
28262: LD_EXP 71
28266: PPUSH
28267: CALL_OW 302
28271: AND
28272: IFFALSE 28630
28274: GO 28276
28276: DISABLE
28277: LD_INT 0
28279: PPUSH
// begin missionStage = 11 ;
28280: LD_ADDR_EXP 15
28284: PUSH
28285: LD_INT 11
28287: ST_TO_ADDR
// DialogueOn ;
28288: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28292: LD_EXP 71
28296: PPUSH
28297: LD_STRING D9-Roth-1
28299: PPUSH
28300: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28304: LD_EXP 36
28308: PPUSH
28309: LD_STRING D9-JMM-1
28311: PPUSH
28312: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28316: LD_EXP 71
28320: PPUSH
28321: LD_STRING D9-Roth-2
28323: PPUSH
28324: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28328: LD_EXP 71
28332: PPUSH
28333: LD_STRING D9-Roth-2a
28335: PPUSH
28336: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28340: LD_EXP 61
28344: PPUSH
28345: LD_STRING D9-Pla-2
28347: PPUSH
28348: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28352: LD_EXP 71
28356: PPUSH
28357: LD_STRING D9-Roth-3
28359: PPUSH
28360: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28364: LD_EXP 61
28368: PPUSH
28369: LD_STRING D9-Pla-3
28371: PPUSH
28372: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28376: LD_EXP 71
28380: PPUSH
28381: LD_STRING D9-Roth-4
28383: PPUSH
28384: CALL_OW 94
// dec = Query ( Q9 ) ;
28388: LD_ADDR_VAR 0 1
28392: PUSH
28393: LD_STRING Q9
28395: PPUSH
28396: CALL_OW 97
28400: ST_TO_ADDR
// if dec = 1 then
28401: LD_VAR 0 1
28405: PUSH
28406: LD_INT 1
28408: EQUAL
28409: IFFALSE 28423
// SayRadio ( Roth , D9a-Roth-1 ) ;
28411: LD_EXP 71
28415: PPUSH
28416: LD_STRING D9a-Roth-1
28418: PPUSH
28419: CALL_OW 94
// if dec = 2 then
28423: LD_VAR 0 1
28427: PUSH
28428: LD_INT 2
28430: EQUAL
28431: IFFALSE 28457
// begin Say ( JMM , D9b-JMM-1 ) ;
28433: LD_EXP 36
28437: PPUSH
28438: LD_STRING D9b-JMM-1
28440: PPUSH
28441: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28445: LD_EXP 71
28449: PPUSH
28450: LD_STRING D9b-Roth-1
28452: PPUSH
28453: CALL_OW 94
// end ; if dec = 3 then
28457: LD_VAR 0 1
28461: PUSH
28462: LD_INT 3
28464: EQUAL
28465: IFFALSE 28527
// begin Say ( JMM , D9c-JMM-1 ) ;
28467: LD_EXP 36
28471: PPUSH
28472: LD_STRING D9c-JMM-1
28474: PPUSH
28475: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28479: LD_EXP 71
28483: PPUSH
28484: LD_STRING D9c-Roth-1
28486: PPUSH
28487: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28491: LD_EXP 36
28495: PPUSH
28496: LD_STRING D9c-JMM-2
28498: PPUSH
28499: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28503: LD_EXP 71
28507: PPUSH
28508: LD_STRING D9c-Roth-2
28510: PPUSH
28511: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28515: LD_EXP 36
28519: PPUSH
28520: LD_STRING D9c-JMM-3
28522: PPUSH
28523: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28527: LD_EXP 71
28531: PPUSH
28532: LD_STRING D9c-Roth-3
28534: PPUSH
28535: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28539: LD_EXP 71
28543: PPUSH
28544: LD_STRING D9cont-Roth-1
28546: PPUSH
28547: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28551: LD_EXP 36
28555: PPUSH
28556: LD_STRING D9cont-JMM-1
28558: PPUSH
28559: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28563: LD_EXP 71
28567: PPUSH
28568: LD_STRING D9cont-Roth-2
28570: PPUSH
28571: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28575: LD_EXP 36
28579: PPUSH
28580: LD_STRING D9cont-JMM-2
28582: PPUSH
28583: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28587: LD_EXP 71
28591: PPUSH
28592: LD_STRING D9cont-Roth-3
28594: PPUSH
28595: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28599: LD_EXP 36
28603: PPUSH
28604: LD_STRING D9cont-JMM-3
28606: PPUSH
28607: CALL_OW 88
// DialogueOff ;
28611: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28615: LD_STRING M3
28617: PPUSH
28618: CALL_OW 337
// allianceActive := true ;
28622: LD_ADDR_EXP 31
28626: PUSH
28627: LD_INT 1
28629: ST_TO_ADDR
// end ;
28630: PPOPN 1
28632: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28633: LD_EXP 61
28637: PPUSH
28638: CALL_OW 301
28642: PUSH
28643: LD_EXP 64
28647: PPUSH
28648: CALL_OW 301
28652: AND
28653: PUSH
28654: LD_INT 22
28656: PUSH
28657: LD_INT 3
28659: PUSH
28660: EMPTY
28661: LIST
28662: LIST
28663: PUSH
28664: LD_INT 21
28666: PUSH
28667: LD_INT 1
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PUSH
28674: LD_INT 50
28676: PUSH
28677: EMPTY
28678: LIST
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: LIST
28684: PPUSH
28685: CALL_OW 69
28689: PUSH
28690: LD_INT 7
28692: PUSH
28693: LD_INT 8
28695: PUSH
28696: LD_INT 9
28698: PUSH
28699: EMPTY
28700: LIST
28701: LIST
28702: LIST
28703: PUSH
28704: LD_OWVAR 67
28708: ARRAY
28709: LESS
28710: AND
28711: IFFALSE 29482
28713: GO 28715
28715: DISABLE
28716: LD_INT 0
28718: PPUSH
28719: PPUSH
28720: PPUSH
28721: PPUSH
// begin MC_Kill ( 1 ) ;
28722: LD_INT 1
28724: PPUSH
28725: CALL 33980 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28729: LD_INT 1
28731: PPUSH
28732: LD_INT 3
28734: PPUSH
28735: LD_INT 1
28737: PPUSH
28738: LD_INT 1
28740: PPUSH
28741: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28745: LD_ADDR_VAR 0 1
28749: PUSH
28750: LD_INT 22
28752: PUSH
28753: LD_INT 3
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: LD_INT 21
28762: PUSH
28763: LD_INT 1
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: PUSH
28770: LD_INT 24
28772: PUSH
28773: LD_INT 900
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: LIST
28784: PPUSH
28785: CALL_OW 69
28789: PUSH
28790: FOR_IN
28791: IFFALSE 28822
// if GetSex ( i ) = sex_male then
28793: LD_VAR 0 1
28797: PPUSH
28798: CALL_OW 258
28802: PUSH
28803: LD_INT 1
28805: EQUAL
28806: IFFALSE 28820
// begin tmp = i ;
28808: LD_ADDR_VAR 0 2
28812: PUSH
28813: LD_VAR 0 1
28817: ST_TO_ADDR
// break ;
28818: GO 28822
// end ;
28820: GO 28790
28822: POP
28823: POP
// if tmp = 0 then
28824: LD_VAR 0 2
28828: PUSH
28829: LD_INT 0
28831: EQUAL
28832: IFFALSE 28886
// begin uc_side = 3 ;
28834: LD_ADDR_OWVAR 20
28838: PUSH
28839: LD_INT 3
28841: ST_TO_ADDR
// uc_nation = 3 ;
28842: LD_ADDR_OWVAR 21
28846: PUSH
28847: LD_INT 3
28849: ST_TO_ADDR
// hc_name =  ;
28850: LD_ADDR_OWVAR 26
28854: PUSH
28855: LD_STRING 
28857: ST_TO_ADDR
// hc_gallery =  ;
28858: LD_ADDR_OWVAR 33
28862: PUSH
28863: LD_STRING 
28865: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28866: LD_INT 1
28868: PPUSH
28869: LD_INT 10
28871: PPUSH
28872: CALL_OW 381
// tmp = CreateHuman ;
28876: LD_ADDR_VAR 0 2
28880: PUSH
28881: CALL_OW 44
28885: ST_TO_ADDR
// end ; DialogueOn ;
28886: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28890: LD_VAR 0 2
28894: PPUSH
28895: LD_STRING DSurrenderRussians-RSol1-1a
28897: PPUSH
28898: CALL_OW 88
// DialogueOff ;
28902: CALL_OW 7
// russianDestroyed := true ;
28906: LD_ADDR_EXP 21
28910: PUSH
28911: LD_INT 1
28913: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28914: LD_INT 22
28916: PUSH
28917: LD_INT 3
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: LD_INT 21
28926: PUSH
28927: LD_INT 1
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PPUSH
28938: CALL_OW 69
28942: PPUSH
28943: CALL_OW 122
// wait ( 0 0$1 ) ;
28947: LD_INT 35
28949: PPUSH
28950: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28954: LD_INT 22
28956: PUSH
28957: LD_INT 3
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: PUSH
28964: LD_INT 21
28966: PUSH
28967: LD_INT 1
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PPUSH
28978: CALL_OW 69
28982: PPUSH
28983: LD_INT 25
28985: PPUSH
28986: CALL_OW 173
// wait ( 0 0$10 ) ;
28990: LD_INT 350
28992: PPUSH
28993: CALL_OW 67
// PrepareOmarInvasion ;
28997: CALL 13662 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29001: LD_ADDR_VAR 0 2
29005: PUSH
29006: LD_EXP 89
29010: PPUSH
29011: CALL_OW 250
29015: PUSH
29016: LD_EXP 89
29020: PPUSH
29021: CALL_OW 251
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29030: LD_VAR 0 2
29034: PUSH
29035: LD_INT 1
29037: ARRAY
29038: PPUSH
29039: LD_VAR 0 2
29043: PUSH
29044: LD_INT 2
29046: ARRAY
29047: PPUSH
29048: LD_INT 1
29050: PPUSH
29051: LD_INT 8
29053: NEG
29054: PPUSH
29055: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29059: LD_EXP 89
29063: PPUSH
29064: CALL_OW 87
// DialogueOn ;
29068: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29072: LD_EXP 36
29076: PPUSH
29077: LD_STRING D19-JMM-1
29079: PPUSH
29080: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29084: LD_ADDR_VAR 0 3
29088: PUSH
29089: LD_INT 22
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 26
29101: PUSH
29102: LD_INT 1
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 2
29111: PUSH
29112: LD_INT 25
29114: PUSH
29115: LD_INT 1
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 25
29124: PUSH
29125: LD_INT 2
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 25
29134: PUSH
29135: LD_INT 3
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 25
29144: PUSH
29145: LD_INT 4
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PUSH
29152: LD_INT 25
29154: PUSH
29155: LD_INT 5
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 25
29164: PUSH
29165: LD_INT 8
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: LIST
29176: LIST
29177: LIST
29178: LIST
29179: LIST
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: LIST
29185: PPUSH
29186: CALL_OW 69
29190: PUSH
29191: LD_EXP 36
29195: PUSH
29196: LD_EXP 37
29200: PUSH
29201: LD_EXP 38
29205: PUSH
29206: LD_EXP 39
29210: PUSH
29211: LD_EXP 40
29215: PUSH
29216: LD_EXP 41
29220: PUSH
29221: LD_EXP 42
29225: PUSH
29226: LD_EXP 43
29230: PUSH
29231: LD_EXP 44
29235: PUSH
29236: LD_EXP 45
29240: PUSH
29241: LD_EXP 46
29245: PUSH
29246: LD_EXP 47
29250: PUSH
29251: LD_EXP 48
29255: PUSH
29256: LD_EXP 49
29260: PUSH
29261: LD_EXP 50
29265: PUSH
29266: LD_EXP 51
29270: PUSH
29271: LD_EXP 52
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: LIST
29293: LIST
29294: DIFF
29295: ST_TO_ADDR
// if tmp2 then
29296: LD_VAR 0 3
29300: IFFALSE 29318
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29302: LD_VAR 0 3
29306: PUSH
29307: LD_INT 1
29309: ARRAY
29310: PPUSH
29311: LD_STRING D19-Sol1-1
29313: PPUSH
29314: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29318: LD_EXP 36
29322: PPUSH
29323: LD_STRING D19-JMM-2
29325: PPUSH
29326: CALL_OW 88
// DialogueOff ;
29330: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29334: LD_VAR 0 2
29338: PUSH
29339: LD_INT 1
29341: ARRAY
29342: PPUSH
29343: LD_VAR 0 2
29347: PUSH
29348: LD_INT 2
29350: ARRAY
29351: PPUSH
29352: LD_INT 1
29354: PPUSH
29355: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29359: LD_STRING M5
29361: PPUSH
29362: CALL_OW 337
// omarOnMotherLode := false ;
29366: LD_ADDR_VAR 0 4
29370: PUSH
29371: LD_INT 0
29373: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29374: LD_INT 35
29376: PPUSH
29377: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29381: LD_EXP 89
29385: PPUSH
29386: LD_INT 215
29388: PPUSH
29389: LD_INT 100
29391: PPUSH
29392: CALL_OW 297
29396: PUSH
29397: LD_INT 10
29399: LESS
29400: PUSH
29401: LD_VAR 0 4
29405: NOT
29406: AND
29407: IFFALSE 29441
// begin omarOnMotherLode := true ;
29409: LD_ADDR_VAR 0 4
29413: PUSH
29414: LD_INT 1
29416: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29417: LD_EXP 36
29421: PPUSH
29422: LD_STRING D19b-JMM-1
29424: PPUSH
29425: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29429: LD_EXP 89
29433: PPUSH
29434: LD_STRING DOmarContam-Omar-1
29436: PPUSH
29437: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29441: LD_EXP 89
29445: PPUSH
29446: CALL_OW 301
29450: IFFALSE 29374
// Say ( JMM , D19a-JMM-1 ) ;
29452: LD_EXP 36
29456: PPUSH
29457: LD_STRING D19a-JMM-1
29459: PPUSH
29460: CALL_OW 88
// if Heike then
29464: LD_EXP 90
29468: IFFALSE 29482
// Say ( Heike , D19a-Hke-1 ) ;
29470: LD_EXP 90
29474: PPUSH
29475: LD_STRING D19a-Hke-1
29477: PPUSH
29478: CALL_OW 88
// end ;
29482: PPOPN 4
29484: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29485: LD_INT 22
29487: PUSH
29488: LD_INT 3
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: PUSH
29495: LD_INT 21
29497: PUSH
29498: LD_INT 1
29500: PUSH
29501: EMPTY
29502: LIST
29503: LIST
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PPUSH
29509: CALL_OW 69
29513: PUSH
29514: LD_EXP 21
29518: AND
29519: IFFALSE 29587
29521: GO 29523
29523: DISABLE
29524: LD_INT 0
29526: PPUSH
29527: PPUSH
// begin enable ;
29528: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29529: LD_ADDR_VAR 0 2
29533: PUSH
29534: LD_INT 25
29536: PPUSH
29537: LD_INT 22
29539: PUSH
29540: LD_INT 3
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL_OW 70
29551: ST_TO_ADDR
// if not tmp then
29552: LD_VAR 0 2
29556: NOT
29557: IFFALSE 29561
// exit ;
29559: GO 29587
// for i in tmp do
29561: LD_ADDR_VAR 0 1
29565: PUSH
29566: LD_VAR 0 2
29570: PUSH
29571: FOR_IN
29572: IFFALSE 29585
// RemoveUnit ( i ) ;
29574: LD_VAR 0 1
29578: PPUSH
29579: CALL_OW 64
29583: GO 29571
29585: POP
29586: POP
// end ;
29587: PPOPN 2
29589: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29590: LD_INT 22
29592: PUSH
29593: LD_INT 7
29595: PUSH
29596: EMPTY
29597: LIST
29598: LIST
29599: PUSH
29600: LD_INT 21
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL_OW 69
29618: PUSH
29619: LD_INT 6
29621: LESS
29622: IFFALSE 30073
29624: GO 29626
29626: DISABLE
29627: LD_INT 0
29629: PPUSH
29630: PPUSH
// begin MC_Kill ( 1 ) ;
29631: LD_INT 1
29633: PPUSH
29634: CALL 33980 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29638: LD_INT 7
29640: PPUSH
29641: LD_INT 1
29643: PPUSH
29644: LD_INT 1
29646: PPUSH
29647: LD_INT 1
29649: PPUSH
29650: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29654: LD_ADDR_VAR 0 1
29658: PUSH
29659: LD_INT 22
29661: PUSH
29662: LD_INT 7
29664: PUSH
29665: EMPTY
29666: LIST
29667: LIST
29668: PUSH
29669: LD_INT 26
29671: PUSH
29672: LD_INT 1
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: EMPTY
29680: LIST
29681: LIST
29682: PPUSH
29683: CALL_OW 69
29687: PUSH
29688: LD_EXP 71
29692: DIFF
29693: ST_TO_ADDR
// if tmp then
29694: LD_VAR 0 1
29698: IFFALSE 29716
// tmp := tmp [ 1 ] else
29700: LD_ADDR_VAR 0 1
29704: PUSH
29705: LD_VAR 0 1
29709: PUSH
29710: LD_INT 1
29712: ARRAY
29713: ST_TO_ADDR
29714: GO 29752
// begin uc_side := 7 ;
29716: LD_ADDR_OWVAR 20
29720: PUSH
29721: LD_INT 7
29723: ST_TO_ADDR
// uc_nation := 1 ;
29724: LD_ADDR_OWVAR 21
29728: PUSH
29729: LD_INT 1
29731: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29732: LD_INT 1
29734: PPUSH
29735: LD_INT 8
29737: PPUSH
29738: CALL_OW 384
// tmp := CreateHuman ;
29742: LD_ADDR_VAR 0 1
29746: PUSH
29747: CALL_OW 44
29751: ST_TO_ADDR
// end ; DialogueOn ;
29752: CALL_OW 6
// if IsOK ( Roth ) then
29756: LD_EXP 71
29760: PPUSH
29761: CALL_OW 302
29765: IFFALSE 29779
// Say ( JMM , DAb-JMM-1 ) ;
29767: LD_EXP 36
29771: PPUSH
29772: LD_STRING DAb-JMM-1
29774: PPUSH
29775: CALL_OW 88
// if IsOK ( Roth ) then
29779: LD_EXP 71
29783: PPUSH
29784: CALL_OW 302
29788: IFFALSE 29812
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29790: LD_EXP 71
29794: PPUSH
29795: LD_STRING DSurrenderAlliance-Roth-1
29797: PPUSH
29798: CALL_OW 88
// RothCaptured := true ;
29802: LD_ADDR_EXP 33
29806: PUSH
29807: LD_INT 1
29809: ST_TO_ADDR
// end else
29810: GO 29824
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29812: LD_VAR 0 1
29816: PPUSH
29817: LD_STRING DSurrenderAlliance-Sci1-1
29819: PPUSH
29820: CALL_OW 88
// DialogueOff ;
29824: CALL_OW 7
// allianceDestroyed := true ;
29828: LD_ADDR_EXP 23
29832: PUSH
29833: LD_INT 1
29835: ST_TO_ADDR
// if trueAmericans then
29836: LD_EXP 35
29840: IFFALSE 29916
// begin if trueAmericans = 1 then
29842: LD_EXP 35
29846: PUSH
29847: LD_INT 1
29849: EQUAL
29850: IFFALSE 29866
// Say ( JMM , DAb-JMM-1a ) else
29852: LD_EXP 36
29856: PPUSH
29857: LD_STRING DAb-JMM-1a
29859: PPUSH
29860: CALL_OW 88
29864: GO 29878
// Say ( JMM , DAb-JMM-1b ) ;
29866: LD_EXP 36
29870: PPUSH
29871: LD_STRING DAb-JMM-1b
29873: PPUSH
29874: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29878: LD_EXP 35
29882: PPUSH
29883: CALL_OW 87
// for i in trueAmericans do
29887: LD_ADDR_VAR 0 2
29891: PUSH
29892: LD_EXP 35
29896: PUSH
29897: FOR_IN
29898: IFFALSE 29914
// SetSide ( i , 1 ) ;
29900: LD_VAR 0 2
29904: PPUSH
29905: LD_INT 1
29907: PPUSH
29908: CALL_OW 235
29912: GO 29897
29914: POP
29915: POP
// end ; repeat wait ( 0 0$1 ) ;
29916: LD_INT 35
29918: PPUSH
29919: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29923: LD_ADDR_VAR 0 2
29927: PUSH
29928: LD_INT 22
29930: PUSH
29931: LD_INT 7
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 21
29940: PUSH
29941: LD_INT 1
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PPUSH
29952: CALL_OW 69
29956: PUSH
29957: FOR_IN
29958: IFFALSE 30040
// begin if IsInUnit ( i ) then
29960: LD_VAR 0 2
29964: PPUSH
29965: CALL_OW 310
29969: IFFALSE 29980
// ComExitBuilding ( i ) ;
29971: LD_VAR 0 2
29975: PPUSH
29976: CALL_OW 122
// if IsDriver ( i ) then
29980: LD_VAR 0 2
29984: PPUSH
29985: CALL 103049 0 1
29989: IFFALSE 30000
// ComExitVehicle ( i ) ;
29991: LD_VAR 0 2
29995: PPUSH
29996: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30000: LD_VAR 0 2
30004: PPUSH
30005: LD_INT 26
30007: PPUSH
30008: CALL_OW 308
30012: NOT
30013: IFFALSE 30029
// AddComMoveToArea ( i , allianceEscapeArea ) else
30015: LD_VAR 0 2
30019: PPUSH
30020: LD_INT 26
30022: PPUSH
30023: CALL_OW 173
30027: GO 30038
// RemoveUnit ( i ) ;
30029: LD_VAR 0 2
30033: PPUSH
30034: CALL_OW 64
// end ;
30038: GO 29957
30040: POP
30041: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30042: LD_INT 22
30044: PUSH
30045: LD_INT 7
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 21
30054: PUSH
30055: LD_INT 1
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PPUSH
30066: CALL_OW 69
30070: NOT
30071: IFFALSE 29916
// end ;
30073: PPOPN 2
30075: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30076: LD_INT 0
30078: PPUSH
30079: PPUSH
// if not unit then
30080: LD_VAR 0 1
30084: NOT
30085: IFFALSE 30089
// exit ;
30087: GO 31587
// DoNotAttack ( 7 , unit ) ;
30089: LD_INT 7
30091: PPUSH
30092: LD_VAR 0 1
30096: PPUSH
30097: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30101: LD_VAR 0 1
30105: PPUSH
30106: LD_INT 260
30108: PPUSH
30109: LD_INT 235
30111: PPUSH
30112: LD_INT 3
30114: PPUSH
30115: LD_INT 1
30117: PPUSH
30118: CALL_OW 483
// SetSide ( unit , 4 ) ;
30122: LD_VAR 0 1
30126: PPUSH
30127: LD_INT 4
30129: PPUSH
30130: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30134: LD_ADDR_EXP 34
30138: PUSH
30139: LD_EXP 34
30143: PUSH
30144: LD_INT 1
30146: PLUS
30147: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30148: LD_INT 70
30150: PPUSH
30151: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30155: LD_INT 260
30157: PPUSH
30158: LD_INT 235
30160: PPUSH
30161: LD_INT 1
30163: PPUSH
30164: LD_INT 8
30166: NEG
30167: PPUSH
30168: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30172: LD_VAR 0 1
30176: PPUSH
30177: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30181: LD_VAR 0 1
30185: PPUSH
30186: LD_EXP 71
30190: PPUSH
30191: CALL_OW 119
// DialogueOn ;
30195: CALL_OW 6
// case unit of JMM :
30199: LD_VAR 0 1
30203: PUSH
30204: LD_EXP 36
30208: DOUBLE
30209: EQUAL
30210: IFTRUE 30214
30212: GO 30229
30214: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30215: LD_EXP 36
30219: PPUSH
30220: LD_STRING DA1-JMM-1
30222: PPUSH
30223: CALL_OW 91
30227: GO 30671
30229: LD_EXP 37
30233: DOUBLE
30234: EQUAL
30235: IFTRUE 30239
30237: GO 30254
30239: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30240: LD_EXP 37
30244: PPUSH
30245: LD_STRING DA1-Joan-1
30247: PPUSH
30248: CALL_OW 91
30252: GO 30671
30254: LD_EXP 39
30258: DOUBLE
30259: EQUAL
30260: IFTRUE 30264
30262: GO 30279
30264: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30265: LD_EXP 39
30269: PPUSH
30270: LD_STRING DA1-Lisa-1
30272: PPUSH
30273: CALL_OW 91
30277: GO 30671
30279: LD_EXP 40
30283: DOUBLE
30284: EQUAL
30285: IFTRUE 30289
30287: GO 30304
30289: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30290: LD_EXP 40
30294: PPUSH
30295: LD_STRING DA1-Don-1
30297: PPUSH
30298: CALL_OW 91
30302: GO 30671
30304: LD_EXP 47
30308: DOUBLE
30309: EQUAL
30310: IFTRUE 30314
30312: GO 30329
30314: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30315: LD_EXP 47
30319: PPUSH
30320: LD_STRING DA1-Corn-1
30322: PPUSH
30323: CALL_OW 91
30327: GO 30671
30329: LD_EXP 43
30333: DOUBLE
30334: EQUAL
30335: IFTRUE 30339
30337: GO 30354
30339: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30340: LD_EXP 43
30344: PPUSH
30345: LD_STRING DA1-Den-1
30347: PPUSH
30348: CALL_OW 91
30352: GO 30671
30354: LD_EXP 41
30358: DOUBLE
30359: EQUAL
30360: IFTRUE 30364
30362: GO 30379
30364: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30365: LD_EXP 41
30369: PPUSH
30370: LD_STRING DA1-Bobby-1
30372: PPUSH
30373: CALL_OW 91
30377: GO 30671
30379: LD_EXP 45
30383: DOUBLE
30384: EQUAL
30385: IFTRUE 30389
30387: GO 30404
30389: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30390: LD_EXP 45
30394: PPUSH
30395: LD_STRING DA1-Glad-1
30397: PPUSH
30398: CALL_OW 91
30402: GO 30671
30404: LD_EXP 42
30408: DOUBLE
30409: EQUAL
30410: IFTRUE 30414
30412: GO 30429
30414: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30415: LD_EXP 42
30419: PPUSH
30420: LD_STRING DA1-Cyrus-1
30422: PPUSH
30423: CALL_OW 91
30427: GO 30671
30429: LD_EXP 38
30433: DOUBLE
30434: EQUAL
30435: IFTRUE 30439
30437: GO 30454
30439: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30440: LD_EXP 38
30444: PPUSH
30445: LD_STRING DA1-Huck-1
30447: PPUSH
30448: CALL_OW 91
30452: GO 30671
30454: LD_EXP 52
30458: DOUBLE
30459: EQUAL
30460: IFTRUE 30464
30462: GO 30479
30464: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30465: LD_EXP 52
30469: PPUSH
30470: LD_STRING DA1-Huck-1
30472: PPUSH
30473: CALL_OW 91
30477: GO 30671
30479: LD_EXP 44
30483: DOUBLE
30484: EQUAL
30485: IFTRUE 30489
30487: GO 30504
30489: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30490: LD_EXP 44
30494: PPUSH
30495: LD_STRING DA1-Brown-1
30497: PPUSH
30498: CALL_OW 91
30502: GO 30671
30504: LD_EXP 48
30508: DOUBLE
30509: EQUAL
30510: IFTRUE 30514
30512: GO 30529
30514: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30515: LD_EXP 48
30519: PPUSH
30520: LD_STRING DA1-Gary-1
30522: PPUSH
30523: CALL_OW 91
30527: GO 30671
30529: LD_EXP 51
30533: DOUBLE
30534: EQUAL
30535: IFTRUE 30539
30537: GO 30554
30539: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30540: LD_EXP 51
30544: PPUSH
30545: LD_STRING DA1-Con-1
30547: PPUSH
30548: CALL_OW 91
30552: GO 30671
30554: LD_EXP 57
30558: DOUBLE
30559: EQUAL
30560: IFTRUE 30564
30562: GO 30579
30564: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30565: LD_EXP 57
30569: PPUSH
30570: LD_STRING DA1-Kurt-1
30572: PPUSH
30573: CALL_OW 91
30577: GO 30671
30579: LD_EXP 50
30583: DOUBLE
30584: EQUAL
30585: IFTRUE 30589
30587: GO 30604
30589: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30590: LD_EXP 50
30594: PPUSH
30595: LD_STRING DA1-Yam-1
30597: PPUSH
30598: CALL_OW 91
30602: GO 30671
30604: LD_EXP 49
30608: DOUBLE
30609: EQUAL
30610: IFTRUE 30614
30612: GO 30629
30614: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30615: LD_EXP 49
30619: PPUSH
30620: LD_STRING DA1-Frank-1
30622: PPUSH
30623: CALL_OW 91
30627: GO 30671
30629: POP
// begin if GetSex ( unit ) = sex_male then
30630: LD_VAR 0 1
30634: PPUSH
30635: CALL_OW 258
30639: PUSH
30640: LD_INT 1
30642: EQUAL
30643: IFFALSE 30659
// ForceSay ( unit , DA1-Sol1-1 ) else
30645: LD_VAR 0 1
30649: PPUSH
30650: LD_STRING DA1-Sol1-1
30652: PPUSH
30653: CALL_OW 91
30657: GO 30671
// ForceSay ( unit , DA1-FSol1-1 ) ;
30659: LD_VAR 0 1
30663: PPUSH
30664: LD_STRING DA1-FSol1-1
30666: PPUSH
30667: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30671: LD_EXP 71
30675: PPUSH
30676: LD_STRING DA-Roth-1
30678: PPUSH
30679: CALL_OW 88
// if capturedUnit = 1 then
30683: LD_EXP 34
30687: PUSH
30688: LD_INT 1
30690: EQUAL
30691: IFFALSE 30719
// begin Say ( Simms , DA-Sim-1 ) ;
30693: LD_EXP 72
30697: PPUSH
30698: LD_STRING DA-Sim-1
30700: PPUSH
30701: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30705: LD_EXP 71
30709: PPUSH
30710: LD_STRING DA-Roth-2
30712: PPUSH
30713: CALL_OW 88
// end else
30717: GO 30731
// Say ( Simms , DA-Sim-2 ) ;
30719: LD_EXP 72
30723: PPUSH
30724: LD_STRING DA-Sim-2
30726: PPUSH
30727: CALL_OW 88
// case unit of JMM :
30731: LD_VAR 0 1
30735: PUSH
30736: LD_EXP 36
30740: DOUBLE
30741: EQUAL
30742: IFTRUE 30746
30744: GO 30761
30746: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30747: LD_EXP 36
30751: PPUSH
30752: LD_STRING DA1-JMM-1a
30754: PPUSH
30755: CALL_OW 91
30759: GO 31268
30761: LD_EXP 37
30765: DOUBLE
30766: EQUAL
30767: IFTRUE 30771
30769: GO 30786
30771: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30772: LD_EXP 37
30776: PPUSH
30777: LD_STRING DA1-Joan-1a
30779: PPUSH
30780: CALL_OW 91
30784: GO 31268
30786: LD_EXP 39
30790: DOUBLE
30791: EQUAL
30792: IFTRUE 30796
30794: GO 30811
30796: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30797: LD_EXP 39
30801: PPUSH
30802: LD_STRING DA1-Lisa-1a
30804: PPUSH
30805: CALL_OW 91
30809: GO 31268
30811: LD_EXP 40
30815: DOUBLE
30816: EQUAL
30817: IFTRUE 30821
30819: GO 30836
30821: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30822: LD_EXP 40
30826: PPUSH
30827: LD_STRING DA1-Don-1a
30829: PPUSH
30830: CALL_OW 91
30834: GO 31268
30836: LD_EXP 47
30840: DOUBLE
30841: EQUAL
30842: IFTRUE 30846
30844: GO 30861
30846: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30847: LD_EXP 47
30851: PPUSH
30852: LD_STRING DA1-Corn-1a
30854: PPUSH
30855: CALL_OW 91
30859: GO 31268
30861: LD_EXP 43
30865: DOUBLE
30866: EQUAL
30867: IFTRUE 30871
30869: GO 30886
30871: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30872: LD_EXP 43
30876: PPUSH
30877: LD_STRING DA1-Den-1a
30879: PPUSH
30880: CALL_OW 91
30884: GO 31268
30886: LD_EXP 41
30890: DOUBLE
30891: EQUAL
30892: IFTRUE 30896
30894: GO 30911
30896: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30897: LD_EXP 41
30901: PPUSH
30902: LD_STRING DA1-Bobby-1a
30904: PPUSH
30905: CALL_OW 91
30909: GO 31268
30911: LD_EXP 45
30915: DOUBLE
30916: EQUAL
30917: IFTRUE 30921
30919: GO 30936
30921: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30922: LD_EXP 45
30926: PPUSH
30927: LD_STRING DA1-Glad-1a
30929: PPUSH
30930: CALL_OW 91
30934: GO 31268
30936: LD_EXP 42
30940: DOUBLE
30941: EQUAL
30942: IFTRUE 30946
30944: GO 30961
30946: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30947: LD_EXP 42
30951: PPUSH
30952: LD_STRING DA1-Cyrus-1a
30954: PPUSH
30955: CALL_OW 91
30959: GO 31268
30961: LD_EXP 38
30965: DOUBLE
30966: EQUAL
30967: IFTRUE 30971
30969: GO 30986
30971: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30972: LD_EXP 38
30976: PPUSH
30977: LD_STRING DA1-Huck-1a
30979: PPUSH
30980: CALL_OW 91
30984: GO 31268
30986: LD_EXP 52
30990: DOUBLE
30991: EQUAL
30992: IFTRUE 30996
30994: GO 31011
30996: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
30997: LD_EXP 52
31001: PPUSH
31002: LD_STRING DA1-Huck-1a
31004: PPUSH
31005: CALL_OW 91
31009: GO 31268
31011: LD_EXP 44
31015: DOUBLE
31016: EQUAL
31017: IFTRUE 31021
31019: GO 31036
31021: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31022: LD_EXP 44
31026: PPUSH
31027: LD_STRING DA1-Brown-1a
31029: PPUSH
31030: CALL_OW 91
31034: GO 31268
31036: LD_EXP 48
31040: DOUBLE
31041: EQUAL
31042: IFTRUE 31046
31044: GO 31061
31046: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31047: LD_EXP 48
31051: PPUSH
31052: LD_STRING DA1-Gary-1a
31054: PPUSH
31055: CALL_OW 91
31059: GO 31268
31061: LD_EXP 51
31065: DOUBLE
31066: EQUAL
31067: IFTRUE 31071
31069: GO 31086
31071: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31072: LD_EXP 51
31076: PPUSH
31077: LD_STRING DA1-Con-1a
31079: PPUSH
31080: CALL_OW 91
31084: GO 31268
31086: LD_EXP 57
31090: DOUBLE
31091: EQUAL
31092: IFTRUE 31096
31094: GO 31111
31096: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31097: LD_EXP 57
31101: PPUSH
31102: LD_STRING DA1-Kurt-1a
31104: PPUSH
31105: CALL_OW 91
31109: GO 31268
31111: LD_EXP 50
31115: DOUBLE
31116: EQUAL
31117: IFTRUE 31121
31119: GO 31136
31121: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31122: LD_EXP 50
31126: PPUSH
31127: LD_STRING DA1-Yam-1a
31129: PPUSH
31130: CALL_OW 91
31134: GO 31268
31136: LD_EXP 49
31140: DOUBLE
31141: EQUAL
31142: IFTRUE 31146
31144: GO 31161
31146: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31147: LD_EXP 49
31151: PPUSH
31152: LD_STRING DA1-Frank-1a
31154: PPUSH
31155: CALL_OW 91
31159: GO 31268
31161: POP
// begin join := rand ( 0 , 1 ) ;
31162: LD_ADDR_VAR 0 3
31166: PUSH
31167: LD_INT 0
31169: PPUSH
31170: LD_INT 1
31172: PPUSH
31173: CALL_OW 12
31177: ST_TO_ADDR
// if join then
31178: LD_VAR 0 3
31182: IFFALSE 31227
// begin if GetSex ( unit ) = sex_male then
31184: LD_VAR 0 1
31188: PPUSH
31189: CALL_OW 258
31193: PUSH
31194: LD_INT 1
31196: EQUAL
31197: IFFALSE 31213
// ForceSay ( unit , DA1-Sol1-1b ) else
31199: LD_VAR 0 1
31203: PPUSH
31204: LD_STRING DA1-Sol1-1b
31206: PPUSH
31207: CALL_OW 91
31211: GO 31225
// ForceSay ( unit , DA1-FSol1-1b ) ;
31213: LD_VAR 0 1
31217: PPUSH
31218: LD_STRING DA1-FSol1-1b
31220: PPUSH
31221: CALL_OW 91
// end else
31225: GO 31268
// begin if GetSex ( unit ) = sex_male then
31227: LD_VAR 0 1
31231: PPUSH
31232: CALL_OW 258
31236: PUSH
31237: LD_INT 1
31239: EQUAL
31240: IFFALSE 31256
// ForceSay ( unit , DA1-Sol1-1a ) else
31242: LD_VAR 0 1
31246: PPUSH
31247: LD_STRING DA1-Sol1-1a
31249: PPUSH
31250: CALL_OW 91
31254: GO 31268
// ForceSay ( unit , DA1-FSol1-1a ) ;
31256: LD_VAR 0 1
31260: PPUSH
31261: LD_STRING DA1-FSol1-1a
31263: PPUSH
31264: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31268: LD_VAR 0 1
31272: PUSH
31273: LD_EXP 36
31277: EQUAL
31278: IFFALSE 31289
// begin YouLost ( JMMCaptured ) ;
31280: LD_STRING JMMCaptured
31282: PPUSH
31283: CALL_OW 104
// exit ;
31287: GO 31587
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 40
31298: PUSH
31299: LD_EXP 43
31303: PUSH
31304: LD_EXP 41
31308: PUSH
31309: LD_EXP 38
31313: PUSH
31314: LD_EXP 52
31318: PUSH
31319: LD_EXP 44
31323: PUSH
31324: LD_EXP 50
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: IN
31338: PUSH
31339: LD_VAR 0 3
31343: OR
31344: IFFALSE 31443
// begin Say ( Roth , DA-Roth-3 ) ;
31346: LD_EXP 71
31350: PPUSH
31351: LD_STRING DA-Roth-3
31353: PPUSH
31354: CALL_OW 88
// SetSide ( unit , 7 ) ;
31358: LD_VAR 0 1
31362: PPUSH
31363: LD_INT 7
31365: PPUSH
31366: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31370: LD_ADDR_EXP 99
31374: PUSH
31375: LD_EXP 99
31379: PPUSH
31380: LD_INT 1
31382: PPUSH
31383: LD_EXP 99
31387: PUSH
31388: LD_INT 1
31390: ARRAY
31391: PUSH
31392: LD_VAR 0 1
31396: ADD
31397: PPUSH
31398: CALL_OW 1
31402: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31403: LD_INT 260
31405: PPUSH
31406: LD_INT 235
31408: PPUSH
31409: LD_INT 1
31411: PPUSH
31412: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31416: LD_VAR 0 1
31420: PPUSH
31421: LD_INT 1000
31423: PPUSH
31424: CALL_OW 234
// DialogueOff ;
31428: CALL_OW 7
// ComFree ( unit ) ;
31432: LD_VAR 0 1
31436: PPUSH
31437: CALL_OW 139
// end else
31441: GO 31524
// begin Say ( Roth , DA-Roth-3a ) ;
31443: LD_EXP 71
31447: PPUSH
31448: LD_STRING DA-Roth-3a
31450: PPUSH
31451: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31455: LD_ADDR_EXP 35
31459: PUSH
31460: LD_EXP 35
31464: PUSH
31465: LD_VAR 0 1
31469: ADD
31470: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31471: LD_INT 260
31473: PPUSH
31474: LD_INT 235
31476: PPUSH
31477: LD_INT 1
31479: PPUSH
31480: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31484: LD_VAR 0 1
31488: PPUSH
31489: LD_INT 1000
31491: PPUSH
31492: CALL_OW 234
// DialogueOff ;
31496: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31500: LD_VAR 0 1
31504: PPUSH
31505: LD_INT 272
31507: PPUSH
31508: LD_INT 254
31510: PPUSH
31511: CALL_OW 111
// AddComHold ( unit ) ;
31515: LD_VAR 0 1
31519: PPUSH
31520: CALL_OW 200
// end ; if capturedUnit = 1 then
31524: LD_EXP 34
31528: PUSH
31529: LD_INT 1
31531: EQUAL
31532: IFFALSE 31587
// begin DialogueOn ;
31534: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31538: LD_EXP 36
31542: PPUSH
31543: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31547: LD_EXP 36
31551: PPUSH
31552: LD_STRING DAa-JMM-1
31554: PPUSH
31555: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31559: LD_EXP 36
31563: PPUSH
31564: LD_STRING DAa-JMM-1a
31566: PPUSH
31567: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31571: LD_EXP 36
31575: PPUSH
31576: LD_STRING DAa-JMM-1b
31578: PPUSH
31579: CALL_OW 88
// DialogueOff ;
31583: CALL_OW 7
// end ; end ;
31587: LD_VAR 0 2
31591: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31592: LD_EXP 15
31596: PUSH
31597: LD_INT 13
31599: GREATEREQUAL
31600: PUSH
31601: LD_INT 22
31603: PUSH
31604: LD_INT 2
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 21
31613: PUSH
31614: LD_INT 1
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: EMPTY
31622: LIST
31623: LIST
31624: PPUSH
31625: CALL_OW 69
31629: PUSH
31630: LD_INT 0
31632: EQUAL
31633: AND
31634: PUSH
31635: LD_INT 22
31637: PUSH
31638: LD_INT 2
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: LD_INT 21
31647: PUSH
31648: LD_INT 2
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: PUSH
31655: LD_INT 50
31657: PUSH
31658: EMPTY
31659: LIST
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: LIST
31665: PPUSH
31666: CALL_OW 69
31670: PUSH
31671: LD_INT 0
31673: EQUAL
31674: AND
31675: PUSH
31676: LD_EXP 21
31680: AND
31681: PUSH
31682: LD_EXP 22
31686: AND
31687: PUSH
31688: LD_EXP 23
31692: AND
31693: IFFALSE 32174
31695: GO 31697
31697: DISABLE
// begin DialogueOn ;
31698: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31702: LD_EXP 36
31706: PPUSH
31707: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31711: LD_EXP 36
31715: PPUSH
31716: LD_STRING D20-JMM-1
31718: PPUSH
31719: CALL_OW 88
// if IsOK ( Joan ) then
31723: LD_EXP 37
31727: PPUSH
31728: CALL_OW 302
31732: IFFALSE 31746
// Say ( Joan , D20-Joan-1 ) ;
31734: LD_EXP 37
31738: PPUSH
31739: LD_STRING D20-Joan-1
31741: PPUSH
31742: CALL_OW 88
// if IsOk ( Lisa ) then
31746: LD_EXP 39
31750: PPUSH
31751: CALL_OW 302
31755: IFFALSE 31769
// Say ( Lisa , D20-Lisa-1 ) ;
31757: LD_EXP 39
31761: PPUSH
31762: LD_STRING D20-Lisa-1
31764: PPUSH
31765: CALL_OW 88
// if IsOk ( Donaldson ) then
31769: LD_EXP 40
31773: PPUSH
31774: CALL_OW 302
31778: IFFALSE 31792
// Say ( Donaldson , D20-Don-1 ) ;
31780: LD_EXP 40
31784: PPUSH
31785: LD_STRING D20-Don-1
31787: PPUSH
31788: CALL_OW 88
// if IsOK ( Cornel ) then
31792: LD_EXP 47
31796: PPUSH
31797: CALL_OW 302
31801: IFFALSE 31815
// Say ( Cornel , D20-Corn-1 ) ;
31803: LD_EXP 47
31807: PPUSH
31808: LD_STRING D20-Corn-1
31810: PPUSH
31811: CALL_OW 88
// if IsOk ( Denis ) then
31815: LD_EXP 43
31819: PPUSH
31820: CALL_OW 302
31824: IFFALSE 31838
// Say ( Denis , D20-Den-1 ) ;
31826: LD_EXP 43
31830: PPUSH
31831: LD_STRING D20-Den-1
31833: PPUSH
31834: CALL_OW 88
// if IsOk ( Bobby ) then
31838: LD_EXP 41
31842: PPUSH
31843: CALL_OW 302
31847: IFFALSE 31861
// Say ( Bobby , D20-Bobby-1 ) ;
31849: LD_EXP 41
31853: PPUSH
31854: LD_STRING D20-Bobby-1
31856: PPUSH
31857: CALL_OW 88
// if IsOk ( Gladstone ) then
31861: LD_EXP 45
31865: PPUSH
31866: CALL_OW 302
31870: IFFALSE 31884
// Say ( Gladstone , D20-Glad-1 ) ;
31872: LD_EXP 45
31876: PPUSH
31877: LD_STRING D20-Glad-1
31879: PPUSH
31880: CALL_OW 88
// if IsOk ( Cyrus ) then
31884: LD_EXP 42
31888: PPUSH
31889: CALL_OW 302
31893: IFFALSE 31907
// Say ( Cyrus , D20-Cyrus-1 ) ;
31895: LD_EXP 42
31899: PPUSH
31900: LD_STRING D20-Cyrus-1
31902: PPUSH
31903: CALL_OW 88
// if IsOk ( Stevens ) then
31907: LD_EXP 38
31911: PPUSH
31912: CALL_OW 302
31916: IFFALSE 31930
// Say ( Stevens , D20-Huck-1 ) ;
31918: LD_EXP 38
31922: PPUSH
31923: LD_STRING D20-Huck-1
31925: PPUSH
31926: CALL_OW 88
// if IsOk ( Brown ) then
31930: LD_EXP 44
31934: PPUSH
31935: CALL_OW 302
31939: IFFALSE 31953
// Say ( Brown , D20-Brown-1 ) ;
31941: LD_EXP 44
31945: PPUSH
31946: LD_STRING D20-Brown-1
31948: PPUSH
31949: CALL_OW 88
// if IsOk ( Gary ) then
31953: LD_EXP 48
31957: PPUSH
31958: CALL_OW 302
31962: IFFALSE 31976
// Say ( Gary , D20-Gary-1 ) ;
31964: LD_EXP 48
31968: PPUSH
31969: LD_STRING D20-Gary-1
31971: PPUSH
31972: CALL_OW 88
// if IsOk ( Connie ) then
31976: LD_EXP 51
31980: PPUSH
31981: CALL_OW 302
31985: IFFALSE 31999
// Say ( Connie , D20-Con-1 ) ;
31987: LD_EXP 51
31991: PPUSH
31992: LD_STRING D20-Con-1
31994: PPUSH
31995: CALL_OW 88
// if IsOk ( Kurt ) then
31999: LD_EXP 57
32003: PPUSH
32004: CALL_OW 302
32008: IFFALSE 32022
// Say ( Kurt , D20-Kurt-1 ) ;
32010: LD_EXP 57
32014: PPUSH
32015: LD_STRING D20-Kurt-1
32017: PPUSH
32018: CALL_OW 88
// if IsOk ( Kikuchi ) then
32022: LD_EXP 50
32026: PPUSH
32027: CALL_OW 302
32031: IFFALSE 32045
// Say ( Kikuchi , D20-Yam-1 ) ;
32033: LD_EXP 50
32037: PPUSH
32038: LD_STRING D20-Yam-1
32040: PPUSH
32041: CALL_OW 88
// if IsOk ( Frank ) then
32045: LD_EXP 49
32049: PPUSH
32050: CALL_OW 302
32054: IFFALSE 32068
// Say ( Frank , D20-Frank-1 ) ;
32056: LD_EXP 49
32060: PPUSH
32061: LD_STRING D20-Frank-1
32063: PPUSH
32064: CALL_OW 88
// DialogueOff ;
32068: CALL_OW 7
// if RothCaptured then
32072: LD_EXP 33
32076: IFFALSE 32090
// AddMedal ( Roth , 1 ) else
32078: LD_STRING Roth
32080: PPUSH
32081: LD_INT 1
32083: PPUSH
32084: CALL_OW 101
32088: GO 32101
// AddMedal ( Roth , - 1 ) ;
32090: LD_STRING Roth
32092: PPUSH
32093: LD_INT 1
32095: NEG
32096: PPUSH
32097: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32101: LD_EXP 27
32105: IFFALSE 32119
// AddMedal ( Project , 1 ) else
32107: LD_STRING Project
32109: PPUSH
32110: LD_INT 1
32112: PPUSH
32113: CALL_OW 101
32117: GO 32130
// AddMedal ( Project , - 1 ) ;
32119: LD_STRING Project
32121: PPUSH
32122: LD_INT 1
32124: NEG
32125: PPUSH
32126: CALL_OW 101
// if lostCounter = 0 then
32130: LD_EXP 32
32134: PUSH
32135: LD_INT 0
32137: EQUAL
32138: IFFALSE 32152
// AddMedal ( NoLosses , 1 ) else
32140: LD_STRING NoLosses
32142: PPUSH
32143: LD_INT 1
32145: PPUSH
32146: CALL_OW 101
32150: GO 32163
// AddMedal ( NoLosses , - 1 ) ;
32152: LD_STRING NoLosses
32154: PPUSH
32155: LD_INT 1
32157: NEG
32158: PPUSH
32159: CALL_OW 101
// GiveMedals ( MAIN ) ;
32163: LD_STRING MAIN
32165: PPUSH
32166: CALL_OW 102
// YouWin ;
32170: CALL_OW 103
// end ; end_of_file
32174: END
// export function CustomEvent ( event ) ; begin
32175: LD_INT 0
32177: PPUSH
// end ;
32178: LD_VAR 0 2
32182: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32183: LD_VAR 0 1
32187: PUSH
32188: LD_INT 1
32190: EQUAL
32191: PUSH
32192: LD_VAR 0 2
32196: PUSH
32197: LD_INT 4
32199: EQUAL
32200: AND
32201: PUSH
32202: LD_EXP 55
32206: PPUSH
32207: CALL_OW 300
32211: AND
32212: IFFALSE 32228
// begin wait ( 0 0$2 ) ;
32214: LD_INT 70
32216: PPUSH
32217: CALL_OW 67
// YouLost ( Dismissed ) ;
32221: LD_STRING Dismissed
32223: PPUSH
32224: CALL_OW 104
// end ; end ;
32228: PPOPN 2
32230: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32231: LD_VAR 0 2
32235: PPUSH
32236: LD_VAR 0 3
32240: PPUSH
32241: LD_INT 18
32243: PPUSH
32244: CALL_OW 309
32248: IFFALSE 32257
// YouLost ( Motherlode3 ) ;
32250: LD_STRING Motherlode3
32252: PPUSH
32253: CALL_OW 104
// end ;
32257: PPOPN 3
32259: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32260: LD_EXP 27
32264: NOT
32265: IFFALSE 32275
// behemothDone := true ;
32267: LD_ADDR_EXP 28
32271: PUSH
32272: LD_INT 1
32274: ST_TO_ADDR
// end ;
32275: PPOPN 1
32277: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32278: LD_VAR 0 1
32282: PPUSH
32283: CALL_OW 255
32287: PUSH
32288: LD_INT 1
32290: EQUAL
32291: PUSH
32292: LD_EXP 30
32296: AND
32297: PUSH
32298: LD_INT 22
32300: PUSH
32301: LD_INT 3
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 34
32310: PUSH
32311: LD_INT 48
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PPUSH
32322: CALL_OW 69
32326: AND
32327: PUSH
32328: LD_INT 22
32330: PUSH
32331: LD_INT 1
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 34
32340: PUSH
32341: LD_INT 8
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PPUSH
32352: CALL_OW 69
32356: NOT
32357: AND
32358: IFFALSE 32410
// begin wait ( 0 0$5 ) ;
32360: LD_INT 175
32362: PPUSH
32363: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32367: LD_INT 22
32369: PUSH
32370: LD_INT 3
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 34
32379: PUSH
32380: LD_INT 48
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PPUSH
32391: CALL_OW 69
32395: PUSH
32396: LD_INT 1
32398: ARRAY
32399: PPUSH
32400: LD_INT 60
32402: PPUSH
32403: LD_INT 95
32405: PPUSH
32406: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32410: LD_VAR 0 2
32414: PPUSH
32415: LD_VAR 0 3
32419: PPUSH
32420: LD_INT 18
32422: PPUSH
32423: CALL_OW 309
32427: IFFALSE 32487
// begin if GetSide ( unit ) = 1 then
32429: LD_VAR 0 1
32433: PPUSH
32434: CALL_OW 255
32438: PUSH
32439: LD_INT 1
32441: EQUAL
32442: IFFALSE 32458
// begin wait ( 0 0$6 ) ;
32444: LD_INT 210
32446: PPUSH
32447: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32451: LD_STRING Motherlode2
32453: PPUSH
32454: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32458: LD_VAR 0 1
32462: PPUSH
32463: CALL_OW 255
32467: PUSH
32468: LD_INT 8
32470: EQUAL
32471: IFFALSE 32487
// begin wait ( 0 0$6 ) ;
32473: LD_INT 210
32475: PPUSH
32476: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32480: LD_STRING Motherlode1
32482: PPUSH
32483: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32487: LD_VAR 0 1
32491: PPUSH
32492: CALL_OW 255
32496: PUSH
32497: LD_INT 3
32499: EQUAL
32500: IFFALSE 32521
// begin wait ( 0 0$5 ) ;
32502: LD_INT 175
32504: PPUSH
32505: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32509: LD_EXP 61
32513: PPUSH
32514: LD_STRING D18-Pla-1
32516: PPUSH
32517: CALL_OW 94
// end ; end ;
32521: PPOPN 3
32523: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32524: LD_VAR 0 1
32528: PUSH
32529: LD_EXP 70
32533: IN
32534: IFFALSE 32554
// begin behemothBuilders := behemothBuilders diff un ;
32536: LD_ADDR_EXP 70
32540: PUSH
32541: LD_EXP 70
32545: PUSH
32546: LD_VAR 0 1
32550: DIFF
32551: ST_TO_ADDR
// exit ;
32552: GO 32652
// end ; if un = JMM then
32554: LD_VAR 0 1
32558: PUSH
32559: LD_EXP 36
32563: EQUAL
32564: IFFALSE 32575
// begin YouLost ( JMM ) ;
32566: LD_STRING JMM
32568: PPUSH
32569: CALL_OW 104
// exit ;
32573: GO 32652
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32575: LD_VAR 0 1
32579: PUSH
32580: LD_INT 22
32582: PUSH
32583: LD_INT 1
32585: PUSH
32586: EMPTY
32587: LIST
32588: LIST
32589: PUSH
32590: LD_INT 3
32592: PUSH
32593: LD_INT 25
32595: PUSH
32596: LD_INT 16
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 25
32605: PUSH
32606: LD_INT 12
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: LIST
32617: PUSH
32618: EMPTY
32619: LIST
32620: LIST
32621: PPUSH
32622: CALL_OW 69
32626: IN
32627: IFFALSE 32643
// lostCounter := lostCounter + 1 ;
32629: LD_ADDR_EXP 32
32633: PUSH
32634: LD_EXP 32
32638: PUSH
32639: LD_INT 1
32641: PLUS
32642: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32643: LD_VAR 0 1
32647: PPUSH
32648: CALL 60295 0 1
// end ;
32652: PPOPN 1
32654: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32655: LD_VAR 0 1
32659: PPUSH
32660: LD_VAR 0 2
32664: PPUSH
32665: CALL 62350 0 2
// end ;
32669: PPOPN 2
32671: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32672: LD_VAR 0 1
32676: PPUSH
32677: CALL 61418 0 1
// end ;
32681: PPOPN 1
32683: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32684: LD_VAR 0 1
32688: PUSH
32689: LD_INT 22
32691: PUSH
32692: LD_INT 8
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 30
32701: PUSH
32702: LD_INT 2
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 23
32711: PUSH
32712: LD_INT 3
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: LIST
32723: PPUSH
32724: CALL_OW 69
32728: IN
32729: IFFALSE 32756
// begin ComUpgrade ( building ) ;
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32740: LD_EXP 58
32744: PPUSH
32745: LD_VAR 0 1
32749: PPUSH
32750: CALL 72552 0 2
// exit ;
32754: GO 32765
// end ; MCE_BuildingComplete ( building ) ;
32756: LD_VAR 0 1
32760: PPUSH
32761: CALL 61659 0 1
// end ;
32765: PPOPN 1
32767: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32768: LD_VAR 0 1
32772: PPUSH
32773: LD_VAR 0 2
32777: PPUSH
32778: CALL 59991 0 2
// end ;
32782: PPOPN 2
32784: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32785: LD_VAR 0 1
32789: PPUSH
32790: LD_VAR 0 2
32794: PPUSH
32795: LD_VAR 0 3
32799: PPUSH
32800: LD_VAR 0 4
32804: PPUSH
32805: LD_VAR 0 5
32809: PPUSH
32810: CALL 59611 0 5
// end ;
32814: PPOPN 5
32816: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32817: LD_VAR 0 1
32821: PPUSH
32822: LD_VAR 0 2
32826: PPUSH
32827: CALL 59207 0 2
// end ;
32831: PPOPN 2
32833: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32834: LD_VAR 0 1
32838: PPUSH
32839: LD_VAR 0 2
32843: PPUSH
32844: LD_VAR 0 3
32848: PPUSH
32849: LD_VAR 0 4
32853: PPUSH
32854: CALL 59045 0 4
// end ;
32858: PPOPN 4
32860: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32861: LD_VAR 0 1
32865: PPUSH
32866: LD_VAR 0 2
32870: PPUSH
32871: LD_VAR 0 3
32875: PPUSH
32876: CALL 58820 0 3
// end ;
32880: PPOPN 3
32882: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32883: LD_VAR 0 1
32887: PPUSH
32888: LD_VAR 0 2
32892: PPUSH
32893: CALL 58705 0 2
// end ;
32897: PPOPN 2
32899: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32900: LD_VAR 0 1
32904: PPUSH
32905: LD_VAR 0 2
32909: PPUSH
32910: CALL 62611 0 2
// end ;
32914: PPOPN 2
32916: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32917: LD_VAR 0 1
32921: PPUSH
32922: CALL_OW 255
32926: PUSH
32927: LD_INT 4
32929: EQUAL
32930: PUSH
32931: LD_VAR 0 1
32935: PUSH
32936: LD_EXP 18
32940: PUSH
32941: LD_INT 1
32943: ARRAY
32944: IN
32945: AND
32946: PUSH
32947: LD_EXP 19
32951: AND
32952: IFFALSE 32971
// begin ComMoveXY ( driver , 61 , 93 ) ;
32954: LD_VAR 0 1
32958: PPUSH
32959: LD_INT 61
32961: PPUSH
32962: LD_INT 93
32964: PPUSH
32965: CALL_OW 111
// exit ;
32969: GO 32995
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32971: LD_VAR 0 1
32975: PPUSH
32976: LD_VAR 0 2
32980: PPUSH
32981: LD_VAR 0 3
32985: PPUSH
32986: LD_VAR 0 4
32990: PPUSH
32991: CALL 62827 0 4
// end ;
32995: PPOPN 4
32997: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
32998: LD_VAR 0 1
33002: PPUSH
33003: LD_VAR 0 2
33007: PPUSH
33008: CALL 58514 0 2
// end ;
33012: PPOPN 2
33014: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33015: LD_VAR 0 1
33019: PPUSH
33020: CALL 105639 0 1
// end ; end_of_file
33024: PPOPN 1
33026: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33027: LD_EXP 15
33031: PUSH
33032: LD_INT 2
33034: EQUAL
33035: IFFALSE 33514
33037: GO 33039
33039: DISABLE
33040: LD_INT 0
33042: PPUSH
// begin time := 0 0$40 ;
33043: LD_ADDR_VAR 0 1
33047: PUSH
33048: LD_INT 1400
33050: ST_TO_ADDR
// repeat wait ( time ) ;
33051: LD_VAR 0 1
33055: PPUSH
33056: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33060: LD_INT 1
33062: PPUSH
33063: LD_INT 5
33065: PPUSH
33066: CALL_OW 12
33070: PPUSH
33071: LD_INT 106
33073: PPUSH
33074: LD_INT 150
33076: PPUSH
33077: LD_INT 19
33079: PPUSH
33080: LD_INT 1
33082: PPUSH
33083: CALL_OW 56
// time := time + 0 0$9 ;
33087: LD_ADDR_VAR 0 1
33091: PUSH
33092: LD_VAR 0 1
33096: PUSH
33097: LD_INT 315
33099: PLUS
33100: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33101: LD_INT 455
33103: PPUSH
33104: LD_INT 840
33106: PPUSH
33107: CALL_OW 12
33111: PPUSH
33112: CALL_OW 67
// if Prob ( 50 ) then
33116: LD_INT 50
33118: PPUSH
33119: CALL_OW 13
33123: IFFALSE 33152
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33125: LD_INT 1
33127: PPUSH
33128: LD_INT 5
33130: PPUSH
33131: CALL_OW 12
33135: PPUSH
33136: LD_INT 62
33138: PPUSH
33139: LD_INT 108
33141: PPUSH
33142: LD_INT 10
33144: PPUSH
33145: LD_INT 1
33147: PPUSH
33148: CALL_OW 56
// until missionStage > 4 ;
33152: LD_EXP 15
33156: PUSH
33157: LD_INT 4
33159: GREATER
33160: IFFALSE 33051
// repeat wait ( 0 0$1 ) ;
33162: LD_INT 35
33164: PPUSH
33165: CALL_OW 67
// until missionStage = 6 ;
33169: LD_EXP 15
33173: PUSH
33174: LD_INT 6
33176: EQUAL
33177: IFFALSE 33162
// time := 0 0$50 ;
33179: LD_ADDR_VAR 0 1
33183: PUSH
33184: LD_INT 1750
33186: ST_TO_ADDR
// repeat wait ( time ) ;
33187: LD_VAR 0 1
33191: PPUSH
33192: CALL_OW 67
// if Prob ( 50 ) then
33196: LD_INT 50
33198: PPUSH
33199: CALL_OW 13
33203: IFFALSE 33232
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33205: LD_INT 1
33207: PPUSH
33208: LD_INT 5
33210: PPUSH
33211: CALL_OW 12
33215: PPUSH
33216: LD_INT 106
33218: PPUSH
33219: LD_INT 89
33221: PPUSH
33222: LD_INT 45
33224: PPUSH
33225: LD_INT 1
33227: PPUSH
33228: CALL_OW 56
// time := time + 0 0$3 ;
33232: LD_ADDR_VAR 0 1
33236: PUSH
33237: LD_VAR 0 1
33241: PUSH
33242: LD_INT 105
33244: PLUS
33245: ST_TO_ADDR
// if Prob ( 30 ) then
33246: LD_INT 30
33248: PPUSH
33249: CALL_OW 13
33253: IFFALSE 33299
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33255: LD_INT 525
33257: PPUSH
33258: LD_INT 735
33260: PPUSH
33261: CALL_OW 12
33265: PPUSH
33266: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33270: LD_INT 1
33272: PPUSH
33273: LD_INT 5
33275: PPUSH
33276: CALL_OW 12
33280: PPUSH
33281: LD_INT 21
33283: PPUSH
33284: LD_INT 26
33286: PPUSH
33287: LD_INT 12
33289: PPUSH
33290: LD_INT 1
33292: PPUSH
33293: CALL_OW 56
// end else
33297: GO 33335
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33299: LD_INT 700
33301: PPUSH
33302: LD_INT 1225
33304: PPUSH
33305: CALL_OW 12
33309: PPUSH
33310: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33314: LD_INT 1
33316: PPUSH
33317: LD_INT 5
33319: PPUSH
33320: CALL_OW 12
33324: PPUSH
33325: LD_INT 16
33327: PPUSH
33328: LD_INT 1
33330: PPUSH
33331: CALL_OW 55
// end ; if Prob ( 50 ) then
33335: LD_INT 50
33337: PPUSH
33338: CALL_OW 13
33342: IFFALSE 33388
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33344: LD_INT 700
33346: PPUSH
33347: LD_INT 1050
33349: PPUSH
33350: CALL_OW 12
33354: PPUSH
33355: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33359: LD_INT 1
33361: PPUSH
33362: LD_INT 5
33364: PPUSH
33365: CALL_OW 12
33369: PPUSH
33370: LD_INT 181
33372: PPUSH
33373: LD_INT 218
33375: PPUSH
33376: LD_INT 16
33378: PPUSH
33379: LD_INT 1
33381: PPUSH
33382: CALL_OW 56
// end else
33386: GO 33424
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33388: LD_INT 350
33390: PPUSH
33391: LD_INT 525
33393: PPUSH
33394: CALL_OW 12
33398: PPUSH
33399: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33403: LD_INT 1
33405: PPUSH
33406: LD_INT 5
33408: PPUSH
33409: CALL_OW 12
33413: PPUSH
33414: LD_INT 15
33416: PPUSH
33417: LD_INT 1
33419: PPUSH
33420: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33424: LD_INT 45
33426: PUSH
33427: LD_INT 32
33429: PUSH
33430: LD_INT 25
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: LIST
33437: PUSH
33438: LD_OWVAR 67
33442: ARRAY
33443: PPUSH
33444: CALL_OW 13
33448: IFFALSE 33492
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33450: LD_INT 525
33452: PPUSH
33453: LD_INT 875
33455: PPUSH
33456: CALL_OW 12
33460: PPUSH
33461: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33465: LD_INT 1
33467: PPUSH
33468: LD_INT 5
33470: PPUSH
33471: CALL_OW 12
33475: PPUSH
33476: LD_INT 103
33478: PPUSH
33479: LD_INT 140
33481: PPUSH
33482: LD_INT 20
33484: PPUSH
33485: LD_INT 1
33487: PPUSH
33488: CALL_OW 56
// end ; if time > 2 2$20 then
33492: LD_VAR 0 1
33496: PUSH
33497: LD_INT 4900
33499: GREATER
33500: IFFALSE 33510
// time := 0 0$50 ;
33502: LD_ADDR_VAR 0 1
33506: PUSH
33507: LD_INT 1750
33509: ST_TO_ADDR
// until false ;
33510: LD_INT 0
33512: IFFALSE 33187
// end ; end_of_file
33514: PPOPN 1
33516: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33517: LD_EXP 13
33521: PUSH
33522: LD_EXP 15
33526: PUSH
33527: LD_INT 6
33529: GREATEREQUAL
33530: AND
33531: IFFALSE 33568
33533: GO 33535
33535: DISABLE
// begin enable ;
33536: ENABLE
// missionTime := missionTime + 0 0$1 ;
33537: LD_ADDR_EXP 14
33541: PUSH
33542: LD_EXP 14
33546: PUSH
33547: LD_INT 35
33549: PLUS
33550: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33551: LD_ADDR_OWVAR 47
33555: PUSH
33556: LD_STRING #Am15-1
33558: PUSH
33559: LD_EXP 14
33563: PUSH
33564: EMPTY
33565: LIST
33566: LIST
33567: ST_TO_ADDR
// end ; end_of_file
33568: END
// export function InitNature ; begin
33569: LD_INT 0
33571: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33572: LD_INT 3
33574: PPUSH
33575: LD_INT 3
33577: PPUSH
33578: LD_INT 2
33580: PPUSH
33581: LD_INT 1
33583: PPUSH
33584: LD_INT 1
33586: PPUSH
33587: LD_INT 0
33589: PPUSH
33590: LD_INT 0
33592: PPUSH
33593: LD_INT 20
33595: PPUSH
33596: LD_INT 0
33598: PPUSH
33599: CALL 97393 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33603: LD_INT 2
33605: PPUSH
33606: LD_INT 1
33608: PPUSH
33609: LD_INT 1
33611: PPUSH
33612: LD_INT 1
33614: PPUSH
33615: LD_INT 1
33617: PPUSH
33618: LD_INT 0
33620: PPUSH
33621: LD_INT 0
33623: PPUSH
33624: LD_INT 21
33626: PPUSH
33627: LD_INT 0
33629: PPUSH
33630: CALL 97393 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33634: LD_INT 4
33636: PPUSH
33637: LD_INT 1
33639: PPUSH
33640: LD_INT 2
33642: PPUSH
33643: LD_INT 4
33645: PPUSH
33646: LD_INT 2
33648: PPUSH
33649: LD_INT 1
33651: PPUSH
33652: LD_INT 0
33654: PPUSH
33655: LD_INT 22
33657: PPUSH
33658: LD_INT 0
33660: PPUSH
33661: CALL 97393 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33665: LD_INT 0
33667: PPUSH
33668: LD_INT 0
33670: PPUSH
33671: LD_INT 0
33673: PPUSH
33674: LD_INT 0
33676: PPUSH
33677: LD_INT 0
33679: PPUSH
33680: LD_INT 0
33682: PPUSH
33683: LD_INT 9
33685: PPUSH
33686: LD_INT 0
33688: PPUSH
33689: LD_INT 23
33691: PPUSH
33692: CALL 97393 0 9
// end ; end_of_file
33696: LD_VAR 0 1
33700: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33701: GO 33703
33703: DISABLE
// begin ru_radar := 98 ;
33704: LD_ADDR_EXP 92
33708: PUSH
33709: LD_INT 98
33711: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33712: LD_ADDR_EXP 93
33716: PUSH
33717: LD_INT 89
33719: ST_TO_ADDR
// us_hack := 99 ;
33720: LD_ADDR_EXP 94
33724: PUSH
33725: LD_INT 99
33727: ST_TO_ADDR
// us_artillery := 97 ;
33728: LD_ADDR_EXP 95
33732: PUSH
33733: LD_INT 97
33735: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33736: LD_ADDR_EXP 96
33740: PUSH
33741: LD_INT 91
33743: ST_TO_ADDR
// end ; end_of_file
33744: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33745: LD_INT 0
33747: PPUSH
33748: PPUSH
// skirmish := false ;
33749: LD_ADDR_EXP 97
33753: PUSH
33754: LD_INT 0
33756: ST_TO_ADDR
// debug_mc := false ;
33757: LD_ADDR_EXP 98
33761: PUSH
33762: LD_INT 0
33764: ST_TO_ADDR
// mc_bases := [ ] ;
33765: LD_ADDR_EXP 99
33769: PUSH
33770: EMPTY
33771: ST_TO_ADDR
// mc_sides := [ ] ;
33772: LD_ADDR_EXP 125
33776: PUSH
33777: EMPTY
33778: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33779: LD_ADDR_EXP 100
33783: PUSH
33784: EMPTY
33785: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33786: LD_ADDR_EXP 101
33790: PUSH
33791: EMPTY
33792: ST_TO_ADDR
// mc_need_heal := [ ] ;
33793: LD_ADDR_EXP 102
33797: PUSH
33798: EMPTY
33799: ST_TO_ADDR
// mc_healers := [ ] ;
33800: LD_ADDR_EXP 103
33804: PUSH
33805: EMPTY
33806: ST_TO_ADDR
// mc_build_list := [ ] ;
33807: LD_ADDR_EXP 104
33811: PUSH
33812: EMPTY
33813: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33814: LD_ADDR_EXP 131
33818: PUSH
33819: EMPTY
33820: ST_TO_ADDR
// mc_builders := [ ] ;
33821: LD_ADDR_EXP 105
33825: PUSH
33826: EMPTY
33827: ST_TO_ADDR
// mc_construct_list := [ ] ;
33828: LD_ADDR_EXP 106
33832: PUSH
33833: EMPTY
33834: ST_TO_ADDR
// mc_turret_list := [ ] ;
33835: LD_ADDR_EXP 107
33839: PUSH
33840: EMPTY
33841: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33842: LD_ADDR_EXP 108
33846: PUSH
33847: EMPTY
33848: ST_TO_ADDR
// mc_miners := [ ] ;
33849: LD_ADDR_EXP 113
33853: PUSH
33854: EMPTY
33855: ST_TO_ADDR
// mc_mines := [ ] ;
33856: LD_ADDR_EXP 112
33860: PUSH
33861: EMPTY
33862: ST_TO_ADDR
// mc_minefields := [ ] ;
33863: LD_ADDR_EXP 114
33867: PUSH
33868: EMPTY
33869: ST_TO_ADDR
// mc_crates := [ ] ;
33870: LD_ADDR_EXP 115
33874: PUSH
33875: EMPTY
33876: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33877: LD_ADDR_EXP 116
33881: PUSH
33882: EMPTY
33883: ST_TO_ADDR
// mc_crates_area := [ ] ;
33884: LD_ADDR_EXP 117
33888: PUSH
33889: EMPTY
33890: ST_TO_ADDR
// mc_vehicles := [ ] ;
33891: LD_ADDR_EXP 118
33895: PUSH
33896: EMPTY
33897: ST_TO_ADDR
// mc_attack := [ ] ;
33898: LD_ADDR_EXP 119
33902: PUSH
33903: EMPTY
33904: ST_TO_ADDR
// mc_produce := [ ] ;
33905: LD_ADDR_EXP 120
33909: PUSH
33910: EMPTY
33911: ST_TO_ADDR
// mc_defender := [ ] ;
33912: LD_ADDR_EXP 121
33916: PUSH
33917: EMPTY
33918: ST_TO_ADDR
// mc_parking := [ ] ;
33919: LD_ADDR_EXP 123
33923: PUSH
33924: EMPTY
33925: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33926: LD_ADDR_EXP 109
33930: PUSH
33931: EMPTY
33932: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33933: LD_ADDR_EXP 111
33937: PUSH
33938: EMPTY
33939: ST_TO_ADDR
// mc_scan := [ ] ;
33940: LD_ADDR_EXP 122
33944: PUSH
33945: EMPTY
33946: ST_TO_ADDR
// mc_scan_area := [ ] ;
33947: LD_ADDR_EXP 124
33951: PUSH
33952: EMPTY
33953: ST_TO_ADDR
// mc_tech := [ ] ;
33954: LD_ADDR_EXP 126
33958: PUSH
33959: EMPTY
33960: ST_TO_ADDR
// mc_class := [ ] ;
33961: LD_ADDR_EXP 140
33965: PUSH
33966: EMPTY
33967: ST_TO_ADDR
// mc_class_case_use := [ ] ;
33968: LD_ADDR_EXP 141
33972: PUSH
33973: EMPTY
33974: ST_TO_ADDR
// end ;
33975: LD_VAR 0 1
33979: RET
// export function MC_Kill ( base ) ; begin
33980: LD_INT 0
33982: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33983: LD_ADDR_EXP 99
33987: PUSH
33988: LD_EXP 99
33992: PPUSH
33993: LD_VAR 0 1
33997: PPUSH
33998: EMPTY
33999: PPUSH
34000: CALL_OW 1
34004: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34005: LD_ADDR_EXP 100
34009: PUSH
34010: LD_EXP 100
34014: PPUSH
34015: LD_VAR 0 1
34019: PPUSH
34020: EMPTY
34021: PPUSH
34022: CALL_OW 1
34026: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34027: LD_ADDR_EXP 101
34031: PUSH
34032: LD_EXP 101
34036: PPUSH
34037: LD_VAR 0 1
34041: PPUSH
34042: EMPTY
34043: PPUSH
34044: CALL_OW 1
34048: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34049: LD_ADDR_EXP 102
34053: PUSH
34054: LD_EXP 102
34058: PPUSH
34059: LD_VAR 0 1
34063: PPUSH
34064: EMPTY
34065: PPUSH
34066: CALL_OW 1
34070: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34071: LD_ADDR_EXP 103
34075: PUSH
34076: LD_EXP 103
34080: PPUSH
34081: LD_VAR 0 1
34085: PPUSH
34086: EMPTY
34087: PPUSH
34088: CALL_OW 1
34092: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34093: LD_ADDR_EXP 104
34097: PUSH
34098: LD_EXP 104
34102: PPUSH
34103: LD_VAR 0 1
34107: PPUSH
34108: EMPTY
34109: PPUSH
34110: CALL_OW 1
34114: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34115: LD_ADDR_EXP 105
34119: PUSH
34120: LD_EXP 105
34124: PPUSH
34125: LD_VAR 0 1
34129: PPUSH
34130: EMPTY
34131: PPUSH
34132: CALL_OW 1
34136: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34137: LD_ADDR_EXP 106
34141: PUSH
34142: LD_EXP 106
34146: PPUSH
34147: LD_VAR 0 1
34151: PPUSH
34152: EMPTY
34153: PPUSH
34154: CALL_OW 1
34158: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34159: LD_ADDR_EXP 107
34163: PUSH
34164: LD_EXP 107
34168: PPUSH
34169: LD_VAR 0 1
34173: PPUSH
34174: EMPTY
34175: PPUSH
34176: CALL_OW 1
34180: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34181: LD_ADDR_EXP 108
34185: PUSH
34186: LD_EXP 108
34190: PPUSH
34191: LD_VAR 0 1
34195: PPUSH
34196: EMPTY
34197: PPUSH
34198: CALL_OW 1
34202: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34203: LD_ADDR_EXP 109
34207: PUSH
34208: LD_EXP 109
34212: PPUSH
34213: LD_VAR 0 1
34217: PPUSH
34218: EMPTY
34219: PPUSH
34220: CALL_OW 1
34224: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34225: LD_ADDR_EXP 110
34229: PUSH
34230: LD_EXP 110
34234: PPUSH
34235: LD_VAR 0 1
34239: PPUSH
34240: LD_INT 0
34242: PPUSH
34243: CALL_OW 1
34247: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34248: LD_ADDR_EXP 111
34252: PUSH
34253: LD_EXP 111
34257: PPUSH
34258: LD_VAR 0 1
34262: PPUSH
34263: EMPTY
34264: PPUSH
34265: CALL_OW 1
34269: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34270: LD_ADDR_EXP 112
34274: PUSH
34275: LD_EXP 112
34279: PPUSH
34280: LD_VAR 0 1
34284: PPUSH
34285: EMPTY
34286: PPUSH
34287: CALL_OW 1
34291: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34292: LD_ADDR_EXP 113
34296: PUSH
34297: LD_EXP 113
34301: PPUSH
34302: LD_VAR 0 1
34306: PPUSH
34307: EMPTY
34308: PPUSH
34309: CALL_OW 1
34313: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34314: LD_ADDR_EXP 114
34318: PUSH
34319: LD_EXP 114
34323: PPUSH
34324: LD_VAR 0 1
34328: PPUSH
34329: EMPTY
34330: PPUSH
34331: CALL_OW 1
34335: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34336: LD_ADDR_EXP 115
34340: PUSH
34341: LD_EXP 115
34345: PPUSH
34346: LD_VAR 0 1
34350: PPUSH
34351: EMPTY
34352: PPUSH
34353: CALL_OW 1
34357: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34358: LD_ADDR_EXP 116
34362: PUSH
34363: LD_EXP 116
34367: PPUSH
34368: LD_VAR 0 1
34372: PPUSH
34373: EMPTY
34374: PPUSH
34375: CALL_OW 1
34379: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34380: LD_ADDR_EXP 117
34384: PUSH
34385: LD_EXP 117
34389: PPUSH
34390: LD_VAR 0 1
34394: PPUSH
34395: EMPTY
34396: PPUSH
34397: CALL_OW 1
34401: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34402: LD_ADDR_EXP 118
34406: PUSH
34407: LD_EXP 118
34411: PPUSH
34412: LD_VAR 0 1
34416: PPUSH
34417: EMPTY
34418: PPUSH
34419: CALL_OW 1
34423: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34424: LD_ADDR_EXP 119
34428: PUSH
34429: LD_EXP 119
34433: PPUSH
34434: LD_VAR 0 1
34438: PPUSH
34439: EMPTY
34440: PPUSH
34441: CALL_OW 1
34445: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34446: LD_ADDR_EXP 120
34450: PUSH
34451: LD_EXP 120
34455: PPUSH
34456: LD_VAR 0 1
34460: PPUSH
34461: EMPTY
34462: PPUSH
34463: CALL_OW 1
34467: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34468: LD_ADDR_EXP 121
34472: PUSH
34473: LD_EXP 121
34477: PPUSH
34478: LD_VAR 0 1
34482: PPUSH
34483: EMPTY
34484: PPUSH
34485: CALL_OW 1
34489: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34490: LD_ADDR_EXP 122
34494: PUSH
34495: LD_EXP 122
34499: PPUSH
34500: LD_VAR 0 1
34504: PPUSH
34505: EMPTY
34506: PPUSH
34507: CALL_OW 1
34511: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34512: LD_ADDR_EXP 123
34516: PUSH
34517: LD_EXP 123
34521: PPUSH
34522: LD_VAR 0 1
34526: PPUSH
34527: EMPTY
34528: PPUSH
34529: CALL_OW 1
34533: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34534: LD_ADDR_EXP 124
34538: PUSH
34539: LD_EXP 124
34543: PPUSH
34544: LD_VAR 0 1
34548: PPUSH
34549: EMPTY
34550: PPUSH
34551: CALL_OW 1
34555: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34556: LD_ADDR_EXP 126
34560: PUSH
34561: LD_EXP 126
34565: PPUSH
34566: LD_VAR 0 1
34570: PPUSH
34571: EMPTY
34572: PPUSH
34573: CALL_OW 1
34577: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34578: LD_ADDR_EXP 128
34582: PUSH
34583: LD_EXP 128
34587: PPUSH
34588: LD_VAR 0 1
34592: PPUSH
34593: EMPTY
34594: PPUSH
34595: CALL_OW 1
34599: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34600: LD_ADDR_EXP 129
34604: PUSH
34605: LD_EXP 129
34609: PPUSH
34610: LD_VAR 0 1
34614: PPUSH
34615: EMPTY
34616: PPUSH
34617: CALL_OW 1
34621: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34622: LD_ADDR_EXP 130
34626: PUSH
34627: LD_EXP 130
34631: PPUSH
34632: LD_VAR 0 1
34636: PPUSH
34637: EMPTY
34638: PPUSH
34639: CALL_OW 1
34643: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34644: LD_ADDR_EXP 131
34648: PUSH
34649: LD_EXP 131
34653: PPUSH
34654: LD_VAR 0 1
34658: PPUSH
34659: EMPTY
34660: PPUSH
34661: CALL_OW 1
34665: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34666: LD_ADDR_EXP 132
34670: PUSH
34671: LD_EXP 132
34675: PPUSH
34676: LD_VAR 0 1
34680: PPUSH
34681: EMPTY
34682: PPUSH
34683: CALL_OW 1
34687: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34688: LD_ADDR_EXP 133
34692: PUSH
34693: LD_EXP 133
34697: PPUSH
34698: LD_VAR 0 1
34702: PPUSH
34703: EMPTY
34704: PPUSH
34705: CALL_OW 1
34709: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34710: LD_ADDR_EXP 134
34714: PUSH
34715: LD_EXP 134
34719: PPUSH
34720: LD_VAR 0 1
34724: PPUSH
34725: EMPTY
34726: PPUSH
34727: CALL_OW 1
34731: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34732: LD_ADDR_EXP 135
34736: PUSH
34737: LD_EXP 135
34741: PPUSH
34742: LD_VAR 0 1
34746: PPUSH
34747: EMPTY
34748: PPUSH
34749: CALL_OW 1
34753: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34754: LD_ADDR_EXP 136
34758: PUSH
34759: LD_EXP 136
34763: PPUSH
34764: LD_VAR 0 1
34768: PPUSH
34769: EMPTY
34770: PPUSH
34771: CALL_OW 1
34775: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34776: LD_ADDR_EXP 137
34780: PUSH
34781: LD_EXP 137
34785: PPUSH
34786: LD_VAR 0 1
34790: PPUSH
34791: EMPTY
34792: PPUSH
34793: CALL_OW 1
34797: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34798: LD_ADDR_EXP 138
34802: PUSH
34803: LD_EXP 138
34807: PPUSH
34808: LD_VAR 0 1
34812: PPUSH
34813: EMPTY
34814: PPUSH
34815: CALL_OW 1
34819: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34820: LD_ADDR_EXP 139
34824: PUSH
34825: LD_EXP 139
34829: PPUSH
34830: LD_VAR 0 1
34834: PPUSH
34835: EMPTY
34836: PPUSH
34837: CALL_OW 1
34841: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34842: LD_ADDR_EXP 140
34846: PUSH
34847: LD_EXP 140
34851: PPUSH
34852: LD_VAR 0 1
34856: PPUSH
34857: EMPTY
34858: PPUSH
34859: CALL_OW 1
34863: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34864: LD_ADDR_EXP 141
34868: PUSH
34869: LD_EXP 141
34873: PPUSH
34874: LD_VAR 0 1
34878: PPUSH
34879: LD_INT 0
34881: PPUSH
34882: CALL_OW 1
34886: ST_TO_ADDR
// end ;
34887: LD_VAR 0 2
34891: RET
// export function MC_Add ( side , units ) ; var base ; begin
34892: LD_INT 0
34894: PPUSH
34895: PPUSH
// base := mc_bases + 1 ;
34896: LD_ADDR_VAR 0 4
34900: PUSH
34901: LD_EXP 99
34905: PUSH
34906: LD_INT 1
34908: PLUS
34909: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
34910: LD_ADDR_EXP 125
34914: PUSH
34915: LD_EXP 125
34919: PPUSH
34920: LD_VAR 0 4
34924: PPUSH
34925: LD_VAR 0 1
34929: PPUSH
34930: CALL_OW 1
34934: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
34935: LD_ADDR_EXP 99
34939: PUSH
34940: LD_EXP 99
34944: PPUSH
34945: LD_VAR 0 4
34949: PPUSH
34950: LD_VAR 0 2
34954: PPUSH
34955: CALL_OW 1
34959: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34960: LD_ADDR_EXP 100
34964: PUSH
34965: LD_EXP 100
34969: PPUSH
34970: LD_VAR 0 4
34974: PPUSH
34975: EMPTY
34976: PPUSH
34977: CALL_OW 1
34981: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34982: LD_ADDR_EXP 101
34986: PUSH
34987: LD_EXP 101
34991: PPUSH
34992: LD_VAR 0 4
34996: PPUSH
34997: EMPTY
34998: PPUSH
34999: CALL_OW 1
35003: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35004: LD_ADDR_EXP 102
35008: PUSH
35009: LD_EXP 102
35013: PPUSH
35014: LD_VAR 0 4
35018: PPUSH
35019: EMPTY
35020: PPUSH
35021: CALL_OW 1
35025: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35026: LD_ADDR_EXP 103
35030: PUSH
35031: LD_EXP 103
35035: PPUSH
35036: LD_VAR 0 4
35040: PPUSH
35041: EMPTY
35042: PPUSH
35043: CALL_OW 1
35047: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35048: LD_ADDR_EXP 104
35052: PUSH
35053: LD_EXP 104
35057: PPUSH
35058: LD_VAR 0 4
35062: PPUSH
35063: EMPTY
35064: PPUSH
35065: CALL_OW 1
35069: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35070: LD_ADDR_EXP 105
35074: PUSH
35075: LD_EXP 105
35079: PPUSH
35080: LD_VAR 0 4
35084: PPUSH
35085: EMPTY
35086: PPUSH
35087: CALL_OW 1
35091: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35092: LD_ADDR_EXP 106
35096: PUSH
35097: LD_EXP 106
35101: PPUSH
35102: LD_VAR 0 4
35106: PPUSH
35107: EMPTY
35108: PPUSH
35109: CALL_OW 1
35113: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35114: LD_ADDR_EXP 107
35118: PUSH
35119: LD_EXP 107
35123: PPUSH
35124: LD_VAR 0 4
35128: PPUSH
35129: EMPTY
35130: PPUSH
35131: CALL_OW 1
35135: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35136: LD_ADDR_EXP 108
35140: PUSH
35141: LD_EXP 108
35145: PPUSH
35146: LD_VAR 0 4
35150: PPUSH
35151: EMPTY
35152: PPUSH
35153: CALL_OW 1
35157: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35158: LD_ADDR_EXP 109
35162: PUSH
35163: LD_EXP 109
35167: PPUSH
35168: LD_VAR 0 4
35172: PPUSH
35173: EMPTY
35174: PPUSH
35175: CALL_OW 1
35179: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35180: LD_ADDR_EXP 110
35184: PUSH
35185: LD_EXP 110
35189: PPUSH
35190: LD_VAR 0 4
35194: PPUSH
35195: LD_INT 0
35197: PPUSH
35198: CALL_OW 1
35202: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35203: LD_ADDR_EXP 111
35207: PUSH
35208: LD_EXP 111
35212: PPUSH
35213: LD_VAR 0 4
35217: PPUSH
35218: EMPTY
35219: PPUSH
35220: CALL_OW 1
35224: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35225: LD_ADDR_EXP 112
35229: PUSH
35230: LD_EXP 112
35234: PPUSH
35235: LD_VAR 0 4
35239: PPUSH
35240: EMPTY
35241: PPUSH
35242: CALL_OW 1
35246: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35247: LD_ADDR_EXP 113
35251: PUSH
35252: LD_EXP 113
35256: PPUSH
35257: LD_VAR 0 4
35261: PPUSH
35262: EMPTY
35263: PPUSH
35264: CALL_OW 1
35268: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35269: LD_ADDR_EXP 114
35273: PUSH
35274: LD_EXP 114
35278: PPUSH
35279: LD_VAR 0 4
35283: PPUSH
35284: EMPTY
35285: PPUSH
35286: CALL_OW 1
35290: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35291: LD_ADDR_EXP 115
35295: PUSH
35296: LD_EXP 115
35300: PPUSH
35301: LD_VAR 0 4
35305: PPUSH
35306: EMPTY
35307: PPUSH
35308: CALL_OW 1
35312: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35313: LD_ADDR_EXP 116
35317: PUSH
35318: LD_EXP 116
35322: PPUSH
35323: LD_VAR 0 4
35327: PPUSH
35328: EMPTY
35329: PPUSH
35330: CALL_OW 1
35334: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35335: LD_ADDR_EXP 117
35339: PUSH
35340: LD_EXP 117
35344: PPUSH
35345: LD_VAR 0 4
35349: PPUSH
35350: EMPTY
35351: PPUSH
35352: CALL_OW 1
35356: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35357: LD_ADDR_EXP 118
35361: PUSH
35362: LD_EXP 118
35366: PPUSH
35367: LD_VAR 0 4
35371: PPUSH
35372: EMPTY
35373: PPUSH
35374: CALL_OW 1
35378: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35379: LD_ADDR_EXP 119
35383: PUSH
35384: LD_EXP 119
35388: PPUSH
35389: LD_VAR 0 4
35393: PPUSH
35394: EMPTY
35395: PPUSH
35396: CALL_OW 1
35400: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35401: LD_ADDR_EXP 120
35405: PUSH
35406: LD_EXP 120
35410: PPUSH
35411: LD_VAR 0 4
35415: PPUSH
35416: EMPTY
35417: PPUSH
35418: CALL_OW 1
35422: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35423: LD_ADDR_EXP 121
35427: PUSH
35428: LD_EXP 121
35432: PPUSH
35433: LD_VAR 0 4
35437: PPUSH
35438: EMPTY
35439: PPUSH
35440: CALL_OW 1
35444: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35445: LD_ADDR_EXP 122
35449: PUSH
35450: LD_EXP 122
35454: PPUSH
35455: LD_VAR 0 4
35459: PPUSH
35460: EMPTY
35461: PPUSH
35462: CALL_OW 1
35466: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35467: LD_ADDR_EXP 123
35471: PUSH
35472: LD_EXP 123
35476: PPUSH
35477: LD_VAR 0 4
35481: PPUSH
35482: EMPTY
35483: PPUSH
35484: CALL_OW 1
35488: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35489: LD_ADDR_EXP 124
35493: PUSH
35494: LD_EXP 124
35498: PPUSH
35499: LD_VAR 0 4
35503: PPUSH
35504: EMPTY
35505: PPUSH
35506: CALL_OW 1
35510: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35511: LD_ADDR_EXP 126
35515: PUSH
35516: LD_EXP 126
35520: PPUSH
35521: LD_VAR 0 4
35525: PPUSH
35526: EMPTY
35527: PPUSH
35528: CALL_OW 1
35532: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35533: LD_ADDR_EXP 128
35537: PUSH
35538: LD_EXP 128
35542: PPUSH
35543: LD_VAR 0 4
35547: PPUSH
35548: EMPTY
35549: PPUSH
35550: CALL_OW 1
35554: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35555: LD_ADDR_EXP 129
35559: PUSH
35560: LD_EXP 129
35564: PPUSH
35565: LD_VAR 0 4
35569: PPUSH
35570: EMPTY
35571: PPUSH
35572: CALL_OW 1
35576: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35577: LD_ADDR_EXP 130
35581: PUSH
35582: LD_EXP 130
35586: PPUSH
35587: LD_VAR 0 4
35591: PPUSH
35592: EMPTY
35593: PPUSH
35594: CALL_OW 1
35598: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35599: LD_ADDR_EXP 131
35603: PUSH
35604: LD_EXP 131
35608: PPUSH
35609: LD_VAR 0 4
35613: PPUSH
35614: EMPTY
35615: PPUSH
35616: CALL_OW 1
35620: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35621: LD_ADDR_EXP 132
35625: PUSH
35626: LD_EXP 132
35630: PPUSH
35631: LD_VAR 0 4
35635: PPUSH
35636: EMPTY
35637: PPUSH
35638: CALL_OW 1
35642: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35643: LD_ADDR_EXP 133
35647: PUSH
35648: LD_EXP 133
35652: PPUSH
35653: LD_VAR 0 4
35657: PPUSH
35658: EMPTY
35659: PPUSH
35660: CALL_OW 1
35664: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35665: LD_ADDR_EXP 134
35669: PUSH
35670: LD_EXP 134
35674: PPUSH
35675: LD_VAR 0 4
35679: PPUSH
35680: EMPTY
35681: PPUSH
35682: CALL_OW 1
35686: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35687: LD_ADDR_EXP 135
35691: PUSH
35692: LD_EXP 135
35696: PPUSH
35697: LD_VAR 0 4
35701: PPUSH
35702: EMPTY
35703: PPUSH
35704: CALL_OW 1
35708: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35709: LD_ADDR_EXP 136
35713: PUSH
35714: LD_EXP 136
35718: PPUSH
35719: LD_VAR 0 4
35723: PPUSH
35724: EMPTY
35725: PPUSH
35726: CALL_OW 1
35730: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35731: LD_ADDR_EXP 137
35735: PUSH
35736: LD_EXP 137
35740: PPUSH
35741: LD_VAR 0 4
35745: PPUSH
35746: EMPTY
35747: PPUSH
35748: CALL_OW 1
35752: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35753: LD_ADDR_EXP 138
35757: PUSH
35758: LD_EXP 138
35762: PPUSH
35763: LD_VAR 0 4
35767: PPUSH
35768: EMPTY
35769: PPUSH
35770: CALL_OW 1
35774: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35775: LD_ADDR_EXP 139
35779: PUSH
35780: LD_EXP 139
35784: PPUSH
35785: LD_VAR 0 4
35789: PPUSH
35790: EMPTY
35791: PPUSH
35792: CALL_OW 1
35796: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35797: LD_ADDR_EXP 140
35801: PUSH
35802: LD_EXP 140
35806: PPUSH
35807: LD_VAR 0 4
35811: PPUSH
35812: EMPTY
35813: PPUSH
35814: CALL_OW 1
35818: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35819: LD_ADDR_EXP 141
35823: PUSH
35824: LD_EXP 141
35828: PPUSH
35829: LD_VAR 0 4
35833: PPUSH
35834: LD_INT 0
35836: PPUSH
35837: CALL_OW 1
35841: ST_TO_ADDR
// result := base ;
35842: LD_ADDR_VAR 0 3
35846: PUSH
35847: LD_VAR 0 4
35851: ST_TO_ADDR
// end ;
35852: LD_VAR 0 3
35856: RET
// export function MC_Start ( ) ; var i ; begin
35857: LD_INT 0
35859: PPUSH
35860: PPUSH
// for i = 1 to mc_bases do
35861: LD_ADDR_VAR 0 2
35865: PUSH
35866: DOUBLE
35867: LD_INT 1
35869: DEC
35870: ST_TO_ADDR
35871: LD_EXP 99
35875: PUSH
35876: FOR_TO
35877: IFFALSE 36954
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
35879: LD_ADDR_EXP 99
35883: PUSH
35884: LD_EXP 99
35888: PPUSH
35889: LD_VAR 0 2
35893: PPUSH
35894: LD_EXP 99
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PUSH
35905: LD_INT 0
35907: DIFF
35908: PPUSH
35909: CALL_OW 1
35913: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
35914: LD_ADDR_EXP 100
35918: PUSH
35919: LD_EXP 100
35923: PPUSH
35924: LD_VAR 0 2
35928: PPUSH
35929: EMPTY
35930: PPUSH
35931: CALL_OW 1
35935: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
35936: LD_ADDR_EXP 101
35940: PUSH
35941: LD_EXP 101
35945: PPUSH
35946: LD_VAR 0 2
35950: PPUSH
35951: EMPTY
35952: PPUSH
35953: CALL_OW 1
35957: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
35958: LD_ADDR_EXP 102
35962: PUSH
35963: LD_EXP 102
35967: PPUSH
35968: LD_VAR 0 2
35972: PPUSH
35973: EMPTY
35974: PPUSH
35975: CALL_OW 1
35979: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
35980: LD_ADDR_EXP 103
35984: PUSH
35985: LD_EXP 103
35989: PPUSH
35990: LD_VAR 0 2
35994: PPUSH
35995: EMPTY
35996: PUSH
35997: EMPTY
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PPUSH
36003: CALL_OW 1
36007: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36008: LD_ADDR_EXP 104
36012: PUSH
36013: LD_EXP 104
36017: PPUSH
36018: LD_VAR 0 2
36022: PPUSH
36023: EMPTY
36024: PPUSH
36025: CALL_OW 1
36029: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36030: LD_ADDR_EXP 131
36034: PUSH
36035: LD_EXP 131
36039: PPUSH
36040: LD_VAR 0 2
36044: PPUSH
36045: EMPTY
36046: PPUSH
36047: CALL_OW 1
36051: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36052: LD_ADDR_EXP 105
36056: PUSH
36057: LD_EXP 105
36061: PPUSH
36062: LD_VAR 0 2
36066: PPUSH
36067: EMPTY
36068: PPUSH
36069: CALL_OW 1
36073: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36074: LD_ADDR_EXP 106
36078: PUSH
36079: LD_EXP 106
36083: PPUSH
36084: LD_VAR 0 2
36088: PPUSH
36089: EMPTY
36090: PPUSH
36091: CALL_OW 1
36095: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36096: LD_ADDR_EXP 107
36100: PUSH
36101: LD_EXP 107
36105: PPUSH
36106: LD_VAR 0 2
36110: PPUSH
36111: LD_EXP 99
36115: PUSH
36116: LD_VAR 0 2
36120: ARRAY
36121: PPUSH
36122: LD_INT 2
36124: PUSH
36125: LD_INT 30
36127: PUSH
36128: LD_INT 32
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 30
36137: PUSH
36138: LD_INT 33
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: LIST
36149: PPUSH
36150: CALL_OW 72
36154: PPUSH
36155: CALL_OW 1
36159: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36160: LD_ADDR_EXP 108
36164: PUSH
36165: LD_EXP 108
36169: PPUSH
36170: LD_VAR 0 2
36174: PPUSH
36175: LD_EXP 99
36179: PUSH
36180: LD_VAR 0 2
36184: ARRAY
36185: PPUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 30
36191: PUSH
36192: LD_INT 32
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 30
36201: PUSH
36202: LD_INT 31
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 58
36216: PUSH
36217: EMPTY
36218: LIST
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PPUSH
36224: CALL_OW 72
36228: PPUSH
36229: CALL_OW 1
36233: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36234: LD_ADDR_EXP 109
36238: PUSH
36239: LD_EXP 109
36243: PPUSH
36244: LD_VAR 0 2
36248: PPUSH
36249: EMPTY
36250: PPUSH
36251: CALL_OW 1
36255: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36256: LD_ADDR_EXP 113
36260: PUSH
36261: LD_EXP 113
36265: PPUSH
36266: LD_VAR 0 2
36270: PPUSH
36271: EMPTY
36272: PPUSH
36273: CALL_OW 1
36277: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36278: LD_ADDR_EXP 112
36282: PUSH
36283: LD_EXP 112
36287: PPUSH
36288: LD_VAR 0 2
36292: PPUSH
36293: EMPTY
36294: PPUSH
36295: CALL_OW 1
36299: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36300: LD_ADDR_EXP 114
36304: PUSH
36305: LD_EXP 114
36309: PPUSH
36310: LD_VAR 0 2
36314: PPUSH
36315: EMPTY
36316: PPUSH
36317: CALL_OW 1
36321: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36322: LD_ADDR_EXP 115
36326: PUSH
36327: LD_EXP 115
36331: PPUSH
36332: LD_VAR 0 2
36336: PPUSH
36337: EMPTY
36338: PPUSH
36339: CALL_OW 1
36343: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36344: LD_ADDR_EXP 116
36348: PUSH
36349: LD_EXP 116
36353: PPUSH
36354: LD_VAR 0 2
36358: PPUSH
36359: EMPTY
36360: PPUSH
36361: CALL_OW 1
36365: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36366: LD_ADDR_EXP 117
36370: PUSH
36371: LD_EXP 117
36375: PPUSH
36376: LD_VAR 0 2
36380: PPUSH
36381: EMPTY
36382: PPUSH
36383: CALL_OW 1
36387: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36388: LD_ADDR_EXP 118
36392: PUSH
36393: LD_EXP 118
36397: PPUSH
36398: LD_VAR 0 2
36402: PPUSH
36403: EMPTY
36404: PPUSH
36405: CALL_OW 1
36409: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36410: LD_ADDR_EXP 119
36414: PUSH
36415: LD_EXP 119
36419: PPUSH
36420: LD_VAR 0 2
36424: PPUSH
36425: EMPTY
36426: PPUSH
36427: CALL_OW 1
36431: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36432: LD_ADDR_EXP 120
36436: PUSH
36437: LD_EXP 120
36441: PPUSH
36442: LD_VAR 0 2
36446: PPUSH
36447: EMPTY
36448: PPUSH
36449: CALL_OW 1
36453: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36454: LD_ADDR_EXP 121
36458: PUSH
36459: LD_EXP 121
36463: PPUSH
36464: LD_VAR 0 2
36468: PPUSH
36469: EMPTY
36470: PPUSH
36471: CALL_OW 1
36475: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36476: LD_ADDR_EXP 110
36480: PUSH
36481: LD_EXP 110
36485: PPUSH
36486: LD_VAR 0 2
36490: PPUSH
36491: LD_INT 0
36493: PPUSH
36494: CALL_OW 1
36498: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36499: LD_ADDR_EXP 123
36503: PUSH
36504: LD_EXP 123
36508: PPUSH
36509: LD_VAR 0 2
36513: PPUSH
36514: LD_INT 0
36516: PPUSH
36517: CALL_OW 1
36521: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36522: LD_ADDR_EXP 111
36526: PUSH
36527: LD_EXP 111
36531: PPUSH
36532: LD_VAR 0 2
36536: PPUSH
36537: EMPTY
36538: PPUSH
36539: CALL_OW 1
36543: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36544: LD_ADDR_EXP 122
36548: PUSH
36549: LD_EXP 122
36553: PPUSH
36554: LD_VAR 0 2
36558: PPUSH
36559: LD_INT 0
36561: PPUSH
36562: CALL_OW 1
36566: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36567: LD_ADDR_EXP 124
36571: PUSH
36572: LD_EXP 124
36576: PPUSH
36577: LD_VAR 0 2
36581: PPUSH
36582: EMPTY
36583: PPUSH
36584: CALL_OW 1
36588: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36589: LD_ADDR_EXP 127
36593: PUSH
36594: LD_EXP 127
36598: PPUSH
36599: LD_VAR 0 2
36603: PPUSH
36604: LD_INT 0
36606: PPUSH
36607: CALL_OW 1
36611: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36612: LD_ADDR_EXP 128
36616: PUSH
36617: LD_EXP 128
36621: PPUSH
36622: LD_VAR 0 2
36626: PPUSH
36627: EMPTY
36628: PPUSH
36629: CALL_OW 1
36633: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36634: LD_ADDR_EXP 129
36638: PUSH
36639: LD_EXP 129
36643: PPUSH
36644: LD_VAR 0 2
36648: PPUSH
36649: EMPTY
36650: PPUSH
36651: CALL_OW 1
36655: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36656: LD_ADDR_EXP 130
36660: PUSH
36661: LD_EXP 130
36665: PPUSH
36666: LD_VAR 0 2
36670: PPUSH
36671: EMPTY
36672: PPUSH
36673: CALL_OW 1
36677: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36678: LD_ADDR_EXP 132
36682: PUSH
36683: LD_EXP 132
36687: PPUSH
36688: LD_VAR 0 2
36692: PPUSH
36693: LD_EXP 99
36697: PUSH
36698: LD_VAR 0 2
36702: ARRAY
36703: PPUSH
36704: LD_INT 2
36706: PUSH
36707: LD_INT 30
36709: PUSH
36710: LD_INT 6
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 30
36719: PUSH
36720: LD_INT 7
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 30
36729: PUSH
36730: LD_INT 8
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: LIST
36741: LIST
36742: PPUSH
36743: CALL_OW 72
36747: PPUSH
36748: CALL_OW 1
36752: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36753: LD_ADDR_EXP 133
36757: PUSH
36758: LD_EXP 133
36762: PPUSH
36763: LD_VAR 0 2
36767: PPUSH
36768: EMPTY
36769: PPUSH
36770: CALL_OW 1
36774: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36775: LD_ADDR_EXP 134
36779: PUSH
36780: LD_EXP 134
36784: PPUSH
36785: LD_VAR 0 2
36789: PPUSH
36790: EMPTY
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36797: LD_ADDR_EXP 135
36801: PUSH
36802: LD_EXP 135
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36819: LD_ADDR_EXP 136
36823: PUSH
36824: LD_EXP 136
36828: PPUSH
36829: LD_VAR 0 2
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36841: LD_ADDR_EXP 137
36845: PUSH
36846: LD_EXP 137
36850: PPUSH
36851: LD_VAR 0 2
36855: PPUSH
36856: EMPTY
36857: PPUSH
36858: CALL_OW 1
36862: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
36863: LD_ADDR_EXP 138
36867: PUSH
36868: LD_EXP 138
36872: PPUSH
36873: LD_VAR 0 2
36877: PPUSH
36878: EMPTY
36879: PPUSH
36880: CALL_OW 1
36884: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
36885: LD_ADDR_EXP 139
36889: PUSH
36890: LD_EXP 139
36894: PPUSH
36895: LD_VAR 0 2
36899: PPUSH
36900: EMPTY
36901: PPUSH
36902: CALL_OW 1
36906: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
36907: LD_ADDR_EXP 140
36911: PUSH
36912: LD_EXP 140
36916: PPUSH
36917: LD_VAR 0 2
36921: PPUSH
36922: EMPTY
36923: PPUSH
36924: CALL_OW 1
36928: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
36929: LD_ADDR_EXP 141
36933: PUSH
36934: LD_EXP 141
36938: PPUSH
36939: LD_VAR 0 2
36943: PPUSH
36944: LD_INT 0
36946: PPUSH
36947: CALL_OW 1
36951: ST_TO_ADDR
// end ;
36952: GO 35876
36954: POP
36955: POP
// MC_InitSides ( ) ;
36956: CALL 37242 0 0
// MC_InitResearch ( ) ;
36960: CALL 36981 0 0
// CustomInitMacro ( ) ;
36964: CALL 444 0 0
// skirmish := true ;
36968: LD_ADDR_EXP 97
36972: PUSH
36973: LD_INT 1
36975: ST_TO_ADDR
// end ;
36976: LD_VAR 0 1
36980: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
36981: LD_INT 0
36983: PPUSH
36984: PPUSH
36985: PPUSH
36986: PPUSH
36987: PPUSH
36988: PPUSH
// if not mc_bases then
36989: LD_EXP 99
36993: NOT
36994: IFFALSE 36998
// exit ;
36996: GO 37237
// for i = 1 to 8 do
36998: LD_ADDR_VAR 0 2
37002: PUSH
37003: DOUBLE
37004: LD_INT 1
37006: DEC
37007: ST_TO_ADDR
37008: LD_INT 8
37010: PUSH
37011: FOR_TO
37012: IFFALSE 37038
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37014: LD_ADDR_EXP 126
37018: PUSH
37019: LD_EXP 126
37023: PPUSH
37024: LD_VAR 0 2
37028: PPUSH
37029: EMPTY
37030: PPUSH
37031: CALL_OW 1
37035: ST_TO_ADDR
37036: GO 37011
37038: POP
37039: POP
// tmp := [ ] ;
37040: LD_ADDR_VAR 0 5
37044: PUSH
37045: EMPTY
37046: ST_TO_ADDR
// for i = 1 to mc_sides do
37047: LD_ADDR_VAR 0 2
37051: PUSH
37052: DOUBLE
37053: LD_INT 1
37055: DEC
37056: ST_TO_ADDR
37057: LD_EXP 125
37061: PUSH
37062: FOR_TO
37063: IFFALSE 37121
// if not mc_sides [ i ] in tmp then
37065: LD_EXP 125
37069: PUSH
37070: LD_VAR 0 2
37074: ARRAY
37075: PUSH
37076: LD_VAR 0 5
37080: IN
37081: NOT
37082: IFFALSE 37119
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37084: LD_ADDR_VAR 0 5
37088: PUSH
37089: LD_VAR 0 5
37093: PPUSH
37094: LD_VAR 0 5
37098: PUSH
37099: LD_INT 1
37101: PLUS
37102: PPUSH
37103: LD_EXP 125
37107: PUSH
37108: LD_VAR 0 2
37112: ARRAY
37113: PPUSH
37114: CALL_OW 2
37118: ST_TO_ADDR
37119: GO 37062
37121: POP
37122: POP
// if not tmp then
37123: LD_VAR 0 5
37127: NOT
37128: IFFALSE 37132
// exit ;
37130: GO 37237
// for j in tmp do
37132: LD_ADDR_VAR 0 3
37136: PUSH
37137: LD_VAR 0 5
37141: PUSH
37142: FOR_IN
37143: IFFALSE 37235
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37145: LD_ADDR_VAR 0 6
37149: PUSH
37150: LD_INT 22
37152: PUSH
37153: LD_VAR 0 3
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PPUSH
37162: CALL_OW 69
37166: ST_TO_ADDR
// if not un then
37167: LD_VAR 0 6
37171: NOT
37172: IFFALSE 37176
// continue ;
37174: GO 37142
// nation := GetNation ( un [ 1 ] ) ;
37176: LD_ADDR_VAR 0 4
37180: PUSH
37181: LD_VAR 0 6
37185: PUSH
37186: LD_INT 1
37188: ARRAY
37189: PPUSH
37190: CALL_OW 248
37194: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37195: LD_ADDR_EXP 126
37199: PUSH
37200: LD_EXP 126
37204: PPUSH
37205: LD_VAR 0 3
37209: PPUSH
37210: LD_VAR 0 3
37214: PPUSH
37215: LD_VAR 0 4
37219: PPUSH
37220: LD_INT 1
37222: PPUSH
37223: CALL 63031 0 3
37227: PPUSH
37228: CALL_OW 1
37232: ST_TO_ADDR
// end ;
37233: GO 37142
37235: POP
37236: POP
// end ;
37237: LD_VAR 0 1
37241: RET
// export function MC_InitSides ( ) ; var i ; begin
37242: LD_INT 0
37244: PPUSH
37245: PPUSH
// if not mc_bases then
37246: LD_EXP 99
37250: NOT
37251: IFFALSE 37255
// exit ;
37253: GO 37329
// for i = 1 to mc_bases do
37255: LD_ADDR_VAR 0 2
37259: PUSH
37260: DOUBLE
37261: LD_INT 1
37263: DEC
37264: ST_TO_ADDR
37265: LD_EXP 99
37269: PUSH
37270: FOR_TO
37271: IFFALSE 37327
// if mc_bases [ i ] then
37273: LD_EXP 99
37277: PUSH
37278: LD_VAR 0 2
37282: ARRAY
37283: IFFALSE 37325
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37285: LD_ADDR_EXP 125
37289: PUSH
37290: LD_EXP 125
37294: PPUSH
37295: LD_VAR 0 2
37299: PPUSH
37300: LD_EXP 99
37304: PUSH
37305: LD_VAR 0 2
37309: ARRAY
37310: PUSH
37311: LD_INT 1
37313: ARRAY
37314: PPUSH
37315: CALL_OW 255
37319: PPUSH
37320: CALL_OW 1
37324: ST_TO_ADDR
37325: GO 37270
37327: POP
37328: POP
// end ;
37329: LD_VAR 0 1
37333: RET
// every 0 0$01 trigger skirmish do
37334: LD_EXP 97
37338: IFFALSE 37492
37340: GO 37342
37342: DISABLE
// begin enable ;
37343: ENABLE
// MC_CheckBuildings ( ) ;
37344: CALL 41981 0 0
// MC_CheckPeopleLife ( ) ;
37348: CALL 42106 0 0
// RaiseSailEvent ( 100 ) ;
37352: LD_INT 100
37354: PPUSH
37355: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37359: LD_INT 103
37361: PPUSH
37362: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37366: LD_INT 104
37368: PPUSH
37369: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37373: LD_INT 105
37375: PPUSH
37376: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37380: LD_INT 106
37382: PPUSH
37383: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37387: LD_INT 107
37389: PPUSH
37390: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37394: LD_INT 108
37396: PPUSH
37397: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37401: LD_INT 109
37403: PPUSH
37404: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37408: LD_INT 110
37410: PPUSH
37411: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37415: LD_INT 111
37417: PPUSH
37418: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37422: LD_INT 112
37424: PPUSH
37425: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37429: LD_INT 113
37431: PPUSH
37432: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37436: LD_INT 120
37438: PPUSH
37439: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37443: LD_INT 121
37445: PPUSH
37446: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37450: LD_INT 122
37452: PPUSH
37453: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37457: LD_INT 123
37459: PPUSH
37460: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37464: LD_INT 124
37466: PPUSH
37467: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37471: LD_INT 125
37473: PPUSH
37474: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37478: LD_INT 126
37480: PPUSH
37481: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37485: LD_INT 200
37487: PPUSH
37488: CALL_OW 427
// end ;
37492: END
// on SailEvent ( event ) do begin if event < 100 then
37493: LD_VAR 0 1
37497: PUSH
37498: LD_INT 100
37500: LESS
37501: IFFALSE 37512
// CustomEvent ( event ) ;
37503: LD_VAR 0 1
37507: PPUSH
37508: CALL 32175 0 1
// if event = 100 then
37512: LD_VAR 0 1
37516: PUSH
37517: LD_INT 100
37519: EQUAL
37520: IFFALSE 37526
// MC_ClassManager ( ) ;
37522: CALL 37918 0 0
// if event = 101 then
37526: LD_VAR 0 1
37530: PUSH
37531: LD_INT 101
37533: EQUAL
37534: IFFALSE 37540
// MC_RepairBuildings ( ) ;
37536: CALL 42702 0 0
// if event = 102 then
37540: LD_VAR 0 1
37544: PUSH
37545: LD_INT 102
37547: EQUAL
37548: IFFALSE 37554
// MC_Heal ( ) ;
37550: CALL 43108 0 0
// if event = 103 then
37554: LD_VAR 0 1
37558: PUSH
37559: LD_INT 103
37561: EQUAL
37562: IFFALSE 37568
// MC_Build ( ) ;
37564: CALL 43530 0 0
// if event = 104 then
37568: LD_VAR 0 1
37572: PUSH
37573: LD_INT 104
37575: EQUAL
37576: IFFALSE 37582
// MC_TurretWeapon ( ) ;
37578: CALL 45143 0 0
// if event = 105 then
37582: LD_VAR 0 1
37586: PUSH
37587: LD_INT 105
37589: EQUAL
37590: IFFALSE 37596
// MC_BuildUpgrade ( ) ;
37592: CALL 44694 0 0
// if event = 106 then
37596: LD_VAR 0 1
37600: PUSH
37601: LD_INT 106
37603: EQUAL
37604: IFFALSE 37610
// MC_PlantMines ( ) ;
37606: CALL 45573 0 0
// if event = 107 then
37610: LD_VAR 0 1
37614: PUSH
37615: LD_INT 107
37617: EQUAL
37618: IFFALSE 37624
// MC_CollectCrates ( ) ;
37620: CALL 46607 0 0
// if event = 108 then
37624: LD_VAR 0 1
37628: PUSH
37629: LD_INT 108
37631: EQUAL
37632: IFFALSE 37638
// MC_LinkRemoteControl ( ) ;
37634: CALL 48364 0 0
// if event = 109 then
37638: LD_VAR 0 1
37642: PUSH
37643: LD_INT 109
37645: EQUAL
37646: IFFALSE 37652
// MC_ProduceVehicle ( ) ;
37648: CALL 48545 0 0
// if event = 110 then
37652: LD_VAR 0 1
37656: PUSH
37657: LD_INT 110
37659: EQUAL
37660: IFFALSE 37666
// MC_SendAttack ( ) ;
37662: CALL 49026 0 0
// if event = 111 then
37666: LD_VAR 0 1
37670: PUSH
37671: LD_INT 111
37673: EQUAL
37674: IFFALSE 37680
// MC_Defend ( ) ;
37676: CALL 49134 0 0
// if event = 112 then
37680: LD_VAR 0 1
37684: PUSH
37685: LD_INT 112
37687: EQUAL
37688: IFFALSE 37694
// MC_Research ( ) ;
37690: CALL 49739 0 0
// if event = 113 then
37694: LD_VAR 0 1
37698: PUSH
37699: LD_INT 113
37701: EQUAL
37702: IFFALSE 37708
// MC_MinesTrigger ( ) ;
37704: CALL 50853 0 0
// if event = 120 then
37708: LD_VAR 0 1
37712: PUSH
37713: LD_INT 120
37715: EQUAL
37716: IFFALSE 37722
// MC_RepairVehicle ( ) ;
37718: CALL 50952 0 0
// if event = 121 then
37722: LD_VAR 0 1
37726: PUSH
37727: LD_INT 121
37729: EQUAL
37730: IFFALSE 37736
// MC_TameApe ( ) ;
37732: CALL 51659 0 0
// if event = 122 then
37736: LD_VAR 0 1
37740: PUSH
37741: LD_INT 122
37743: EQUAL
37744: IFFALSE 37750
// MC_ChangeApeClass ( ) ;
37746: CALL 52488 0 0
// if event = 123 then
37750: LD_VAR 0 1
37754: PUSH
37755: LD_INT 123
37757: EQUAL
37758: IFFALSE 37764
// MC_Bazooka ( ) ;
37760: CALL 53138 0 0
// if event = 124 then
37764: LD_VAR 0 1
37768: PUSH
37769: LD_INT 124
37771: EQUAL
37772: IFFALSE 37778
// MC_TeleportExit ( ) ;
37774: CALL 53336 0 0
// if event = 125 then
37778: LD_VAR 0 1
37782: PUSH
37783: LD_INT 125
37785: EQUAL
37786: IFFALSE 37792
// MC_Deposits ( ) ;
37788: CALL 53983 0 0
// if event = 126 then
37792: LD_VAR 0 1
37796: PUSH
37797: LD_INT 126
37799: EQUAL
37800: IFFALSE 37806
// MC_RemoteDriver ( ) ;
37802: CALL 54608 0 0
// if event = 200 then
37806: LD_VAR 0 1
37810: PUSH
37811: LD_INT 200
37813: EQUAL
37814: IFFALSE 37820
// MC_Idle ( ) ;
37816: CALL 56341 0 0
// end ;
37820: PPOPN 1
37822: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37823: LD_INT 0
37825: PPUSH
37826: PPUSH
// if not mc_bases [ base ] or not tag then
37827: LD_EXP 99
37831: PUSH
37832: LD_VAR 0 1
37836: ARRAY
37837: NOT
37838: PUSH
37839: LD_VAR 0 2
37843: NOT
37844: OR
37845: IFFALSE 37849
// exit ;
37847: GO 37913
// for i in mc_bases [ base ] union mc_ape [ base ] do
37849: LD_ADDR_VAR 0 4
37853: PUSH
37854: LD_EXP 99
37858: PUSH
37859: LD_VAR 0 1
37863: ARRAY
37864: PUSH
37865: LD_EXP 128
37869: PUSH
37870: LD_VAR 0 1
37874: ARRAY
37875: UNION
37876: PUSH
37877: FOR_IN
37878: IFFALSE 37911
// if GetTag ( i ) = tag then
37880: LD_VAR 0 4
37884: PPUSH
37885: CALL_OW 110
37889: PUSH
37890: LD_VAR 0 2
37894: EQUAL
37895: IFFALSE 37909
// SetTag ( i , 0 ) ;
37897: LD_VAR 0 4
37901: PPUSH
37902: LD_INT 0
37904: PPUSH
37905: CALL_OW 109
37909: GO 37877
37911: POP
37912: POP
// end ;
37913: LD_VAR 0 3
37917: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
37918: LD_INT 0
37920: PPUSH
37921: PPUSH
37922: PPUSH
37923: PPUSH
37924: PPUSH
37925: PPUSH
37926: PPUSH
37927: PPUSH
// if not mc_bases then
37928: LD_EXP 99
37932: NOT
37933: IFFALSE 37937
// exit ;
37935: GO 38395
// for i = 1 to mc_bases do
37937: LD_ADDR_VAR 0 2
37941: PUSH
37942: DOUBLE
37943: LD_INT 1
37945: DEC
37946: ST_TO_ADDR
37947: LD_EXP 99
37951: PUSH
37952: FOR_TO
37953: IFFALSE 38393
// begin tmp := MC_ClassCheckReq ( i ) ;
37955: LD_ADDR_VAR 0 4
37959: PUSH
37960: LD_VAR 0 2
37964: PPUSH
37965: CALL 38400 0 1
37969: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
37970: LD_ADDR_EXP 140
37974: PUSH
37975: LD_EXP 140
37979: PPUSH
37980: LD_VAR 0 2
37984: PPUSH
37985: LD_VAR 0 4
37989: PPUSH
37990: CALL_OW 1
37994: ST_TO_ADDR
// if not tmp then
37995: LD_VAR 0 4
37999: NOT
38000: IFFALSE 38004
// continue ;
38002: GO 37952
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38004: LD_ADDR_VAR 0 6
38008: PUSH
38009: LD_EXP 99
38013: PUSH
38014: LD_VAR 0 2
38018: ARRAY
38019: PPUSH
38020: LD_INT 2
38022: PUSH
38023: LD_INT 30
38025: PUSH
38026: LD_INT 4
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 30
38035: PUSH
38036: LD_INT 5
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: LIST
38047: PPUSH
38048: CALL_OW 72
38052: PUSH
38053: LD_EXP 99
38057: PUSH
38058: LD_VAR 0 2
38062: ARRAY
38063: PPUSH
38064: LD_INT 2
38066: PUSH
38067: LD_INT 30
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 30
38079: PUSH
38080: LD_INT 1
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: LIST
38091: PPUSH
38092: CALL_OW 72
38096: PUSH
38097: LD_EXP 99
38101: PUSH
38102: LD_VAR 0 2
38106: ARRAY
38107: PPUSH
38108: LD_INT 30
38110: PUSH
38111: LD_INT 3
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: PPUSH
38118: CALL_OW 72
38122: PUSH
38123: LD_EXP 99
38127: PUSH
38128: LD_VAR 0 2
38132: ARRAY
38133: PPUSH
38134: LD_INT 2
38136: PUSH
38137: LD_INT 30
38139: PUSH
38140: LD_INT 6
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 30
38149: PUSH
38150: LD_INT 7
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 30
38159: PUSH
38160: LD_INT 8
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: LIST
38171: LIST
38172: PPUSH
38173: CALL_OW 72
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: LIST
38182: LIST
38183: ST_TO_ADDR
// for j = 1 to 4 do
38184: LD_ADDR_VAR 0 3
38188: PUSH
38189: DOUBLE
38190: LD_INT 1
38192: DEC
38193: ST_TO_ADDR
38194: LD_INT 4
38196: PUSH
38197: FOR_TO
38198: IFFALSE 38389
// begin if not tmp [ j ] then
38200: LD_VAR 0 4
38204: PUSH
38205: LD_VAR 0 3
38209: ARRAY
38210: NOT
38211: IFFALSE 38215
// continue ;
38213: GO 38197
// for p in tmp [ j ] do
38215: LD_ADDR_VAR 0 5
38219: PUSH
38220: LD_VAR 0 4
38224: PUSH
38225: LD_VAR 0 3
38229: ARRAY
38230: PUSH
38231: FOR_IN
38232: IFFALSE 38385
// begin if not b [ j ] then
38234: LD_VAR 0 6
38238: PUSH
38239: LD_VAR 0 3
38243: ARRAY
38244: NOT
38245: IFFALSE 38249
// break ;
38247: GO 38385
// e := 0 ;
38249: LD_ADDR_VAR 0 7
38253: PUSH
38254: LD_INT 0
38256: ST_TO_ADDR
// for k in b [ j ] do
38257: LD_ADDR_VAR 0 8
38261: PUSH
38262: LD_VAR 0 6
38266: PUSH
38267: LD_VAR 0 3
38271: ARRAY
38272: PUSH
38273: FOR_IN
38274: IFFALSE 38301
// if IsNotFull ( k ) then
38276: LD_VAR 0 8
38280: PPUSH
38281: CALL 67028 0 1
38285: IFFALSE 38299
// begin e := k ;
38287: LD_ADDR_VAR 0 7
38291: PUSH
38292: LD_VAR 0 8
38296: ST_TO_ADDR
// break ;
38297: GO 38301
// end ;
38299: GO 38273
38301: POP
38302: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38303: LD_VAR 0 7
38307: PUSH
38308: LD_VAR 0 5
38312: PPUSH
38313: LD_VAR 0 7
38317: PPUSH
38318: CALL 104086 0 2
38322: NOT
38323: AND
38324: IFFALSE 38383
// begin if IsInUnit ( p ) then
38326: LD_VAR 0 5
38330: PPUSH
38331: CALL_OW 310
38335: IFFALSE 38346
// ComExitBuilding ( p ) ;
38337: LD_VAR 0 5
38341: PPUSH
38342: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38346: LD_VAR 0 5
38350: PPUSH
38351: LD_VAR 0 7
38355: PPUSH
38356: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38360: LD_VAR 0 5
38364: PPUSH
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 183
// AddComExitBuilding ( p ) ;
38374: LD_VAR 0 5
38378: PPUSH
38379: CALL_OW 182
// end ; end ;
38383: GO 38231
38385: POP
38386: POP
// end ;
38387: GO 38197
38389: POP
38390: POP
// end ;
38391: GO 37952
38393: POP
38394: POP
// end ;
38395: LD_VAR 0 1
38399: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38400: LD_INT 0
38402: PPUSH
38403: PPUSH
38404: PPUSH
38405: PPUSH
38406: PPUSH
38407: PPUSH
38408: PPUSH
38409: PPUSH
38410: PPUSH
38411: PPUSH
38412: PPUSH
38413: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38414: LD_VAR 0 1
38418: NOT
38419: PUSH
38420: LD_EXP 99
38424: PUSH
38425: LD_VAR 0 1
38429: ARRAY
38430: NOT
38431: OR
38432: PUSH
38433: LD_EXP 99
38437: PUSH
38438: LD_VAR 0 1
38442: ARRAY
38443: PPUSH
38444: LD_INT 2
38446: PUSH
38447: LD_INT 30
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 30
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: LIST
38471: PPUSH
38472: CALL_OW 72
38476: NOT
38477: OR
38478: IFFALSE 38482
// exit ;
38480: GO 41976
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38482: LD_ADDR_VAR 0 4
38486: PUSH
38487: LD_EXP 99
38491: PUSH
38492: LD_VAR 0 1
38496: ARRAY
38497: PPUSH
38498: LD_INT 2
38500: PUSH
38501: LD_INT 25
38503: PUSH
38504: LD_INT 1
38506: PUSH
38507: EMPTY
38508: LIST
38509: LIST
38510: PUSH
38511: LD_INT 25
38513: PUSH
38514: LD_INT 2
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 25
38523: PUSH
38524: LD_INT 3
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 25
38533: PUSH
38534: LD_INT 4
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 25
38543: PUSH
38544: LD_INT 5
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 25
38553: PUSH
38554: LD_INT 8
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 25
38563: PUSH
38564: LD_INT 9
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: LIST
38575: LIST
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: PPUSH
38581: CALL_OW 72
38585: ST_TO_ADDR
// for i in tmp do
38586: LD_ADDR_VAR 0 3
38590: PUSH
38591: LD_VAR 0 4
38595: PUSH
38596: FOR_IN
38597: IFFALSE 38628
// if GetTag ( i ) then
38599: LD_VAR 0 3
38603: PPUSH
38604: CALL_OW 110
38608: IFFALSE 38626
// tmp := tmp diff i ;
38610: LD_ADDR_VAR 0 4
38614: PUSH
38615: LD_VAR 0 4
38619: PUSH
38620: LD_VAR 0 3
38624: DIFF
38625: ST_TO_ADDR
38626: GO 38596
38628: POP
38629: POP
// if not tmp then
38630: LD_VAR 0 4
38634: NOT
38635: IFFALSE 38639
// exit ;
38637: GO 41976
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38639: LD_ADDR_VAR 0 5
38643: PUSH
38644: LD_EXP 99
38648: PUSH
38649: LD_VAR 0 1
38653: ARRAY
38654: PPUSH
38655: LD_INT 2
38657: PUSH
38658: LD_INT 25
38660: PUSH
38661: LD_INT 1
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 25
38670: PUSH
38671: LD_INT 5
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 25
38680: PUSH
38681: LD_INT 8
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 25
38690: PUSH
38691: LD_INT 9
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: LIST
38702: LIST
38703: LIST
38704: PPUSH
38705: CALL_OW 72
38709: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38710: LD_ADDR_VAR 0 6
38714: PUSH
38715: LD_EXP 99
38719: PUSH
38720: LD_VAR 0 1
38724: ARRAY
38725: PPUSH
38726: LD_INT 25
38728: PUSH
38729: LD_INT 2
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PPUSH
38736: CALL_OW 72
38740: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38741: LD_ADDR_VAR 0 7
38745: PUSH
38746: LD_EXP 99
38750: PUSH
38751: LD_VAR 0 1
38755: ARRAY
38756: PPUSH
38757: LD_INT 25
38759: PUSH
38760: LD_INT 3
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PPUSH
38767: CALL_OW 72
38771: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38772: LD_ADDR_VAR 0 8
38776: PUSH
38777: LD_EXP 99
38781: PUSH
38782: LD_VAR 0 1
38786: ARRAY
38787: PPUSH
38788: LD_INT 25
38790: PUSH
38791: LD_INT 4
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 24
38800: PUSH
38801: LD_INT 251
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PPUSH
38812: CALL_OW 72
38816: ST_TO_ADDR
// if mc_scan [ base ] then
38817: LD_EXP 122
38821: PUSH
38822: LD_VAR 0 1
38826: ARRAY
38827: IFFALSE 39288
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
38829: LD_ADDR_EXP 141
38833: PUSH
38834: LD_EXP 141
38838: PPUSH
38839: LD_VAR 0 1
38843: PPUSH
38844: LD_INT 4
38846: PPUSH
38847: CALL_OW 1
38851: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38852: LD_ADDR_VAR 0 12
38856: PUSH
38857: LD_EXP 99
38861: PUSH
38862: LD_VAR 0 1
38866: ARRAY
38867: PPUSH
38868: LD_INT 2
38870: PUSH
38871: LD_INT 30
38873: PUSH
38874: LD_INT 4
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 30
38883: PUSH
38884: LD_INT 5
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: LIST
38895: PPUSH
38896: CALL_OW 72
38900: ST_TO_ADDR
// if not b then
38901: LD_VAR 0 12
38905: NOT
38906: IFFALSE 38910
// exit ;
38908: GO 41976
// p := [ ] ;
38910: LD_ADDR_VAR 0 11
38914: PUSH
38915: EMPTY
38916: ST_TO_ADDR
// if sci >= 2 then
38917: LD_VAR 0 8
38921: PUSH
38922: LD_INT 2
38924: GREATEREQUAL
38925: IFFALSE 38956
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
38927: LD_ADDR_VAR 0 8
38931: PUSH
38932: LD_VAR 0 8
38936: PUSH
38937: LD_INT 1
38939: ARRAY
38940: PUSH
38941: LD_VAR 0 8
38945: PUSH
38946: LD_INT 2
38948: ARRAY
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: ST_TO_ADDR
38954: GO 39017
// if sci = 1 then
38956: LD_VAR 0 8
38960: PUSH
38961: LD_INT 1
38963: EQUAL
38964: IFFALSE 38985
// sci := [ sci [ 1 ] ] else
38966: LD_ADDR_VAR 0 8
38970: PUSH
38971: LD_VAR 0 8
38975: PUSH
38976: LD_INT 1
38978: ARRAY
38979: PUSH
38980: EMPTY
38981: LIST
38982: ST_TO_ADDR
38983: GO 39017
// if sci = 0 then
38985: LD_VAR 0 8
38989: PUSH
38990: LD_INT 0
38992: EQUAL
38993: IFFALSE 39017
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
38995: LD_ADDR_VAR 0 11
38999: PUSH
39000: LD_VAR 0 4
39004: PPUSH
39005: LD_INT 4
39007: PPUSH
39008: CALL 103949 0 2
39012: PUSH
39013: LD_INT 1
39015: ARRAY
39016: ST_TO_ADDR
// if eng > 4 then
39017: LD_VAR 0 6
39021: PUSH
39022: LD_INT 4
39024: GREATER
39025: IFFALSE 39071
// for i = eng downto 4 do
39027: LD_ADDR_VAR 0 3
39031: PUSH
39032: DOUBLE
39033: LD_VAR 0 6
39037: INC
39038: ST_TO_ADDR
39039: LD_INT 4
39041: PUSH
39042: FOR_DOWNTO
39043: IFFALSE 39069
// eng := eng diff eng [ i ] ;
39045: LD_ADDR_VAR 0 6
39049: PUSH
39050: LD_VAR 0 6
39054: PUSH
39055: LD_VAR 0 6
39059: PUSH
39060: LD_VAR 0 3
39064: ARRAY
39065: DIFF
39066: ST_TO_ADDR
39067: GO 39042
39069: POP
39070: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39071: LD_ADDR_VAR 0 4
39075: PUSH
39076: LD_VAR 0 4
39080: PUSH
39081: LD_VAR 0 5
39085: PUSH
39086: LD_VAR 0 6
39090: UNION
39091: PUSH
39092: LD_VAR 0 7
39096: UNION
39097: PUSH
39098: LD_VAR 0 8
39102: UNION
39103: DIFF
39104: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39105: LD_ADDR_VAR 0 13
39109: PUSH
39110: LD_EXP 99
39114: PUSH
39115: LD_VAR 0 1
39119: ARRAY
39120: PPUSH
39121: LD_INT 2
39123: PUSH
39124: LD_INT 30
39126: PUSH
39127: LD_INT 32
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 30
39136: PUSH
39137: LD_INT 31
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: LIST
39148: PPUSH
39149: CALL_OW 72
39153: PUSH
39154: LD_EXP 99
39158: PUSH
39159: LD_VAR 0 1
39163: ARRAY
39164: PPUSH
39165: LD_INT 2
39167: PUSH
39168: LD_INT 30
39170: PUSH
39171: LD_INT 4
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 30
39180: PUSH
39181: LD_INT 5
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: LIST
39192: PPUSH
39193: CALL_OW 72
39197: PUSH
39198: LD_INT 6
39200: MUL
39201: PLUS
39202: ST_TO_ADDR
// if bcount < tmp then
39203: LD_VAR 0 13
39207: PUSH
39208: LD_VAR 0 4
39212: LESS
39213: IFFALSE 39259
// for i = tmp downto bcount do
39215: LD_ADDR_VAR 0 3
39219: PUSH
39220: DOUBLE
39221: LD_VAR 0 4
39225: INC
39226: ST_TO_ADDR
39227: LD_VAR 0 13
39231: PUSH
39232: FOR_DOWNTO
39233: IFFALSE 39257
// tmp := Delete ( tmp , tmp ) ;
39235: LD_ADDR_VAR 0 4
39239: PUSH
39240: LD_VAR 0 4
39244: PPUSH
39245: LD_VAR 0 4
39249: PPUSH
39250: CALL_OW 3
39254: ST_TO_ADDR
39255: GO 39232
39257: POP
39258: POP
// result := [ tmp , 0 , 0 , p ] ;
39259: LD_ADDR_VAR 0 2
39263: PUSH
39264: LD_VAR 0 4
39268: PUSH
39269: LD_INT 0
39271: PUSH
39272: LD_INT 0
39274: PUSH
39275: LD_VAR 0 11
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: ST_TO_ADDR
// exit ;
39286: GO 41976
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39288: LD_EXP 99
39292: PUSH
39293: LD_VAR 0 1
39297: ARRAY
39298: PPUSH
39299: LD_INT 2
39301: PUSH
39302: LD_INT 30
39304: PUSH
39305: LD_INT 6
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 30
39314: PUSH
39315: LD_INT 7
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 30
39324: PUSH
39325: LD_INT 8
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: LIST
39336: LIST
39337: PPUSH
39338: CALL_OW 72
39342: NOT
39343: PUSH
39344: LD_EXP 99
39348: PUSH
39349: LD_VAR 0 1
39353: ARRAY
39354: PPUSH
39355: LD_INT 30
39357: PUSH
39358: LD_INT 3
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PPUSH
39365: CALL_OW 72
39369: NOT
39370: AND
39371: IFFALSE 39443
// begin if eng = tmp then
39373: LD_VAR 0 6
39377: PUSH
39378: LD_VAR 0 4
39382: EQUAL
39383: IFFALSE 39387
// exit ;
39385: GO 41976
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39387: LD_ADDR_EXP 141
39391: PUSH
39392: LD_EXP 141
39396: PPUSH
39397: LD_VAR 0 1
39401: PPUSH
39402: LD_INT 1
39404: PPUSH
39405: CALL_OW 1
39409: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39410: LD_ADDR_VAR 0 2
39414: PUSH
39415: LD_INT 0
39417: PUSH
39418: LD_VAR 0 4
39422: PUSH
39423: LD_VAR 0 6
39427: DIFF
39428: PUSH
39429: LD_INT 0
39431: PUSH
39432: LD_INT 0
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: ST_TO_ADDR
// exit ;
39441: GO 41976
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39443: LD_EXP 126
39447: PUSH
39448: LD_EXP 125
39452: PUSH
39453: LD_VAR 0 1
39457: ARRAY
39458: ARRAY
39459: PUSH
39460: LD_EXP 99
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: LD_INT 2
39473: PUSH
39474: LD_INT 30
39476: PUSH
39477: LD_INT 6
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 30
39486: PUSH
39487: LD_INT 7
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 30
39496: PUSH
39497: LD_INT 8
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: LIST
39508: LIST
39509: PPUSH
39510: CALL_OW 72
39514: AND
39515: PUSH
39516: LD_EXP 99
39520: PUSH
39521: LD_VAR 0 1
39525: ARRAY
39526: PPUSH
39527: LD_INT 30
39529: PUSH
39530: LD_INT 3
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PPUSH
39537: CALL_OW 72
39541: NOT
39542: AND
39543: IFFALSE 39757
// begin if sci >= 6 then
39545: LD_VAR 0 8
39549: PUSH
39550: LD_INT 6
39552: GREATEREQUAL
39553: IFFALSE 39557
// exit ;
39555: GO 41976
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39557: LD_ADDR_EXP 141
39561: PUSH
39562: LD_EXP 141
39566: PPUSH
39567: LD_VAR 0 1
39571: PPUSH
39572: LD_INT 2
39574: PPUSH
39575: CALL_OW 1
39579: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39580: LD_ADDR_VAR 0 9
39584: PUSH
39585: LD_VAR 0 4
39589: PUSH
39590: LD_VAR 0 8
39594: DIFF
39595: PPUSH
39596: LD_INT 4
39598: PPUSH
39599: CALL 103949 0 2
39603: ST_TO_ADDR
// p := [ ] ;
39604: LD_ADDR_VAR 0 11
39608: PUSH
39609: EMPTY
39610: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39611: LD_VAR 0 8
39615: PUSH
39616: LD_INT 6
39618: LESS
39619: PUSH
39620: LD_VAR 0 9
39624: PUSH
39625: LD_INT 6
39627: GREATER
39628: AND
39629: IFFALSE 39710
// begin for i = 1 to 6 - sci do
39631: LD_ADDR_VAR 0 3
39635: PUSH
39636: DOUBLE
39637: LD_INT 1
39639: DEC
39640: ST_TO_ADDR
39641: LD_INT 6
39643: PUSH
39644: LD_VAR 0 8
39648: MINUS
39649: PUSH
39650: FOR_TO
39651: IFFALSE 39706
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39653: LD_ADDR_VAR 0 11
39657: PUSH
39658: LD_VAR 0 11
39662: PPUSH
39663: LD_VAR 0 11
39667: PUSH
39668: LD_INT 1
39670: PLUS
39671: PPUSH
39672: LD_VAR 0 9
39676: PUSH
39677: LD_INT 1
39679: ARRAY
39680: PPUSH
39681: CALL_OW 2
39685: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39686: LD_ADDR_VAR 0 9
39690: PUSH
39691: LD_VAR 0 9
39695: PPUSH
39696: LD_INT 1
39698: PPUSH
39699: CALL_OW 3
39703: ST_TO_ADDR
// end ;
39704: GO 39650
39706: POP
39707: POP
// end else
39708: GO 39730
// if sort then
39710: LD_VAR 0 9
39714: IFFALSE 39730
// p := sort [ 1 ] ;
39716: LD_ADDR_VAR 0 11
39720: PUSH
39721: LD_VAR 0 9
39725: PUSH
39726: LD_INT 1
39728: ARRAY
39729: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39730: LD_ADDR_VAR 0 2
39734: PUSH
39735: LD_INT 0
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: LD_INT 0
39743: PUSH
39744: LD_VAR 0 11
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: ST_TO_ADDR
// exit ;
39755: GO 41976
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39757: LD_EXP 126
39761: PUSH
39762: LD_EXP 125
39766: PUSH
39767: LD_VAR 0 1
39771: ARRAY
39772: ARRAY
39773: PUSH
39774: LD_EXP 99
39778: PUSH
39779: LD_VAR 0 1
39783: ARRAY
39784: PPUSH
39785: LD_INT 2
39787: PUSH
39788: LD_INT 30
39790: PUSH
39791: LD_INT 6
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: LD_INT 30
39800: PUSH
39801: LD_INT 7
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 30
39810: PUSH
39811: LD_INT 8
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: PPUSH
39824: CALL_OW 72
39828: AND
39829: PUSH
39830: LD_EXP 99
39834: PUSH
39835: LD_VAR 0 1
39839: ARRAY
39840: PPUSH
39841: LD_INT 30
39843: PUSH
39844: LD_INT 3
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PPUSH
39851: CALL_OW 72
39855: AND
39856: IFFALSE 40590
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
39858: LD_ADDR_EXP 141
39862: PUSH
39863: LD_EXP 141
39867: PPUSH
39868: LD_VAR 0 1
39872: PPUSH
39873: LD_INT 3
39875: PPUSH
39876: CALL_OW 1
39880: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39881: LD_ADDR_VAR 0 2
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: LD_INT 0
39891: PUSH
39892: LD_INT 0
39894: PUSH
39895: LD_INT 0
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: ST_TO_ADDR
// if not eng then
39904: LD_VAR 0 6
39908: NOT
39909: IFFALSE 39972
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
39911: LD_ADDR_VAR 0 11
39915: PUSH
39916: LD_VAR 0 4
39920: PPUSH
39921: LD_INT 2
39923: PPUSH
39924: CALL 103949 0 2
39928: PUSH
39929: LD_INT 1
39931: ARRAY
39932: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
39933: LD_ADDR_VAR 0 2
39937: PUSH
39938: LD_VAR 0 2
39942: PPUSH
39943: LD_INT 2
39945: PPUSH
39946: LD_VAR 0 11
39950: PPUSH
39951: CALL_OW 1
39955: ST_TO_ADDR
// tmp := tmp diff p ;
39956: LD_ADDR_VAR 0 4
39960: PUSH
39961: LD_VAR 0 4
39965: PUSH
39966: LD_VAR 0 11
39970: DIFF
39971: ST_TO_ADDR
// end ; if tmp and sci < 6 then
39972: LD_VAR 0 4
39976: PUSH
39977: LD_VAR 0 8
39981: PUSH
39982: LD_INT 6
39984: LESS
39985: AND
39986: IFFALSE 40174
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
39988: LD_ADDR_VAR 0 9
39992: PUSH
39993: LD_VAR 0 4
39997: PUSH
39998: LD_VAR 0 8
40002: PUSH
40003: LD_VAR 0 7
40007: UNION
40008: DIFF
40009: PPUSH
40010: LD_INT 4
40012: PPUSH
40013: CALL 103949 0 2
40017: ST_TO_ADDR
// p := [ ] ;
40018: LD_ADDR_VAR 0 11
40022: PUSH
40023: EMPTY
40024: ST_TO_ADDR
// if sort then
40025: LD_VAR 0 9
40029: IFFALSE 40145
// for i = 1 to 6 - sci do
40031: LD_ADDR_VAR 0 3
40035: PUSH
40036: DOUBLE
40037: LD_INT 1
40039: DEC
40040: ST_TO_ADDR
40041: LD_INT 6
40043: PUSH
40044: LD_VAR 0 8
40048: MINUS
40049: PUSH
40050: FOR_TO
40051: IFFALSE 40143
// begin if i = sort then
40053: LD_VAR 0 3
40057: PUSH
40058: LD_VAR 0 9
40062: EQUAL
40063: IFFALSE 40067
// break ;
40065: GO 40143
// if GetClass ( i ) = 4 then
40067: LD_VAR 0 3
40071: PPUSH
40072: CALL_OW 257
40076: PUSH
40077: LD_INT 4
40079: EQUAL
40080: IFFALSE 40084
// continue ;
40082: GO 40050
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40084: LD_ADDR_VAR 0 11
40088: PUSH
40089: LD_VAR 0 11
40093: PPUSH
40094: LD_VAR 0 11
40098: PUSH
40099: LD_INT 1
40101: PLUS
40102: PPUSH
40103: LD_VAR 0 9
40107: PUSH
40108: LD_VAR 0 3
40112: ARRAY
40113: PPUSH
40114: CALL_OW 2
40118: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40119: LD_ADDR_VAR 0 4
40123: PUSH
40124: LD_VAR 0 4
40128: PUSH
40129: LD_VAR 0 9
40133: PUSH
40134: LD_VAR 0 3
40138: ARRAY
40139: DIFF
40140: ST_TO_ADDR
// end ;
40141: GO 40050
40143: POP
40144: POP
// if p then
40145: LD_VAR 0 11
40149: IFFALSE 40174
// result := Replace ( result , 4 , p ) ;
40151: LD_ADDR_VAR 0 2
40155: PUSH
40156: LD_VAR 0 2
40160: PPUSH
40161: LD_INT 4
40163: PPUSH
40164: LD_VAR 0 11
40168: PPUSH
40169: CALL_OW 1
40173: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40174: LD_VAR 0 4
40178: PUSH
40179: LD_VAR 0 7
40183: PUSH
40184: LD_INT 6
40186: LESS
40187: AND
40188: IFFALSE 40376
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40190: LD_ADDR_VAR 0 9
40194: PUSH
40195: LD_VAR 0 4
40199: PUSH
40200: LD_VAR 0 8
40204: PUSH
40205: LD_VAR 0 7
40209: UNION
40210: DIFF
40211: PPUSH
40212: LD_INT 3
40214: PPUSH
40215: CALL 103949 0 2
40219: ST_TO_ADDR
// p := [ ] ;
40220: LD_ADDR_VAR 0 11
40224: PUSH
40225: EMPTY
40226: ST_TO_ADDR
// if sort then
40227: LD_VAR 0 9
40231: IFFALSE 40347
// for i = 1 to 6 - mech do
40233: LD_ADDR_VAR 0 3
40237: PUSH
40238: DOUBLE
40239: LD_INT 1
40241: DEC
40242: ST_TO_ADDR
40243: LD_INT 6
40245: PUSH
40246: LD_VAR 0 7
40250: MINUS
40251: PUSH
40252: FOR_TO
40253: IFFALSE 40345
// begin if i = sort then
40255: LD_VAR 0 3
40259: PUSH
40260: LD_VAR 0 9
40264: EQUAL
40265: IFFALSE 40269
// break ;
40267: GO 40345
// if GetClass ( i ) = 3 then
40269: LD_VAR 0 3
40273: PPUSH
40274: CALL_OW 257
40278: PUSH
40279: LD_INT 3
40281: EQUAL
40282: IFFALSE 40286
// continue ;
40284: GO 40252
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40286: LD_ADDR_VAR 0 11
40290: PUSH
40291: LD_VAR 0 11
40295: PPUSH
40296: LD_VAR 0 11
40300: PUSH
40301: LD_INT 1
40303: PLUS
40304: PPUSH
40305: LD_VAR 0 9
40309: PUSH
40310: LD_VAR 0 3
40314: ARRAY
40315: PPUSH
40316: CALL_OW 2
40320: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40321: LD_ADDR_VAR 0 4
40325: PUSH
40326: LD_VAR 0 4
40330: PUSH
40331: LD_VAR 0 9
40335: PUSH
40336: LD_VAR 0 3
40340: ARRAY
40341: DIFF
40342: ST_TO_ADDR
// end ;
40343: GO 40252
40345: POP
40346: POP
// if p then
40347: LD_VAR 0 11
40351: IFFALSE 40376
// result := Replace ( result , 3 , p ) ;
40353: LD_ADDR_VAR 0 2
40357: PUSH
40358: LD_VAR 0 2
40362: PPUSH
40363: LD_INT 3
40365: PPUSH
40366: LD_VAR 0 11
40370: PPUSH
40371: CALL_OW 1
40375: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40376: LD_VAR 0 4
40380: PUSH
40381: LD_INT 6
40383: GREATER
40384: PUSH
40385: LD_VAR 0 6
40389: PUSH
40390: LD_INT 6
40392: LESS
40393: AND
40394: IFFALSE 40588
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40396: LD_ADDR_VAR 0 9
40400: PUSH
40401: LD_VAR 0 4
40405: PUSH
40406: LD_VAR 0 8
40410: PUSH
40411: LD_VAR 0 7
40415: UNION
40416: PUSH
40417: LD_VAR 0 6
40421: UNION
40422: DIFF
40423: PPUSH
40424: LD_INT 2
40426: PPUSH
40427: CALL 103949 0 2
40431: ST_TO_ADDR
// p := [ ] ;
40432: LD_ADDR_VAR 0 11
40436: PUSH
40437: EMPTY
40438: ST_TO_ADDR
// if sort then
40439: LD_VAR 0 9
40443: IFFALSE 40559
// for i = 1 to 6 - eng do
40445: LD_ADDR_VAR 0 3
40449: PUSH
40450: DOUBLE
40451: LD_INT 1
40453: DEC
40454: ST_TO_ADDR
40455: LD_INT 6
40457: PUSH
40458: LD_VAR 0 6
40462: MINUS
40463: PUSH
40464: FOR_TO
40465: IFFALSE 40557
// begin if i = sort then
40467: LD_VAR 0 3
40471: PUSH
40472: LD_VAR 0 9
40476: EQUAL
40477: IFFALSE 40481
// break ;
40479: GO 40557
// if GetClass ( i ) = 2 then
40481: LD_VAR 0 3
40485: PPUSH
40486: CALL_OW 257
40490: PUSH
40491: LD_INT 2
40493: EQUAL
40494: IFFALSE 40498
// continue ;
40496: GO 40464
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40498: LD_ADDR_VAR 0 11
40502: PUSH
40503: LD_VAR 0 11
40507: PPUSH
40508: LD_VAR 0 11
40512: PUSH
40513: LD_INT 1
40515: PLUS
40516: PPUSH
40517: LD_VAR 0 9
40521: PUSH
40522: LD_VAR 0 3
40526: ARRAY
40527: PPUSH
40528: CALL_OW 2
40532: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40533: LD_ADDR_VAR 0 4
40537: PUSH
40538: LD_VAR 0 4
40542: PUSH
40543: LD_VAR 0 9
40547: PUSH
40548: LD_VAR 0 3
40552: ARRAY
40553: DIFF
40554: ST_TO_ADDR
// end ;
40555: GO 40464
40557: POP
40558: POP
// if p then
40559: LD_VAR 0 11
40563: IFFALSE 40588
// result := Replace ( result , 2 , p ) ;
40565: LD_ADDR_VAR 0 2
40569: PUSH
40570: LD_VAR 0 2
40574: PPUSH
40575: LD_INT 2
40577: PPUSH
40578: LD_VAR 0 11
40582: PPUSH
40583: CALL_OW 1
40587: ST_TO_ADDR
// end ; exit ;
40588: GO 41976
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40590: LD_EXP 126
40594: PUSH
40595: LD_EXP 125
40599: PUSH
40600: LD_VAR 0 1
40604: ARRAY
40605: ARRAY
40606: NOT
40607: PUSH
40608: LD_EXP 99
40612: PUSH
40613: LD_VAR 0 1
40617: ARRAY
40618: PPUSH
40619: LD_INT 30
40621: PUSH
40622: LD_INT 3
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PPUSH
40629: CALL_OW 72
40633: AND
40634: PUSH
40635: LD_EXP 104
40639: PUSH
40640: LD_VAR 0 1
40644: ARRAY
40645: AND
40646: IFFALSE 41254
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40648: LD_ADDR_EXP 141
40652: PUSH
40653: LD_EXP 141
40657: PPUSH
40658: LD_VAR 0 1
40662: PPUSH
40663: LD_INT 5
40665: PPUSH
40666: CALL_OW 1
40670: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40671: LD_ADDR_VAR 0 2
40675: PUSH
40676: LD_INT 0
40678: PUSH
40679: LD_INT 0
40681: PUSH
40682: LD_INT 0
40684: PUSH
40685: LD_INT 0
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: ST_TO_ADDR
// if sci > 1 then
40694: LD_VAR 0 8
40698: PUSH
40699: LD_INT 1
40701: GREATER
40702: IFFALSE 40730
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40704: LD_ADDR_VAR 0 4
40708: PUSH
40709: LD_VAR 0 4
40713: PUSH
40714: LD_VAR 0 8
40718: PUSH
40719: LD_VAR 0 8
40723: PUSH
40724: LD_INT 1
40726: ARRAY
40727: DIFF
40728: DIFF
40729: ST_TO_ADDR
// if tmp and not sci then
40730: LD_VAR 0 4
40734: PUSH
40735: LD_VAR 0 8
40739: NOT
40740: AND
40741: IFFALSE 40810
// begin sort := SortBySkill ( tmp , 4 ) ;
40743: LD_ADDR_VAR 0 9
40747: PUSH
40748: LD_VAR 0 4
40752: PPUSH
40753: LD_INT 4
40755: PPUSH
40756: CALL 103949 0 2
40760: ST_TO_ADDR
// if sort then
40761: LD_VAR 0 9
40765: IFFALSE 40781
// p := sort [ 1 ] ;
40767: LD_ADDR_VAR 0 11
40771: PUSH
40772: LD_VAR 0 9
40776: PUSH
40777: LD_INT 1
40779: ARRAY
40780: ST_TO_ADDR
// if p then
40781: LD_VAR 0 11
40785: IFFALSE 40810
// result := Replace ( result , 4 , p ) ;
40787: LD_ADDR_VAR 0 2
40791: PUSH
40792: LD_VAR 0 2
40796: PPUSH
40797: LD_INT 4
40799: PPUSH
40800: LD_VAR 0 11
40804: PPUSH
40805: CALL_OW 1
40809: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40810: LD_ADDR_VAR 0 4
40814: PUSH
40815: LD_VAR 0 4
40819: PUSH
40820: LD_VAR 0 7
40824: DIFF
40825: ST_TO_ADDR
// if tmp and mech < 6 then
40826: LD_VAR 0 4
40830: PUSH
40831: LD_VAR 0 7
40835: PUSH
40836: LD_INT 6
40838: LESS
40839: AND
40840: IFFALSE 41028
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40842: LD_ADDR_VAR 0 9
40846: PUSH
40847: LD_VAR 0 4
40851: PUSH
40852: LD_VAR 0 8
40856: PUSH
40857: LD_VAR 0 7
40861: UNION
40862: DIFF
40863: PPUSH
40864: LD_INT 3
40866: PPUSH
40867: CALL 103949 0 2
40871: ST_TO_ADDR
// p := [ ] ;
40872: LD_ADDR_VAR 0 11
40876: PUSH
40877: EMPTY
40878: ST_TO_ADDR
// if sort then
40879: LD_VAR 0 9
40883: IFFALSE 40999
// for i = 1 to 6 - mech do
40885: LD_ADDR_VAR 0 3
40889: PUSH
40890: DOUBLE
40891: LD_INT 1
40893: DEC
40894: ST_TO_ADDR
40895: LD_INT 6
40897: PUSH
40898: LD_VAR 0 7
40902: MINUS
40903: PUSH
40904: FOR_TO
40905: IFFALSE 40997
// begin if i = sort then
40907: LD_VAR 0 3
40911: PUSH
40912: LD_VAR 0 9
40916: EQUAL
40917: IFFALSE 40921
// break ;
40919: GO 40997
// if GetClass ( i ) = 3 then
40921: LD_VAR 0 3
40925: PPUSH
40926: CALL_OW 257
40930: PUSH
40931: LD_INT 3
40933: EQUAL
40934: IFFALSE 40938
// continue ;
40936: GO 40904
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40938: LD_ADDR_VAR 0 11
40942: PUSH
40943: LD_VAR 0 11
40947: PPUSH
40948: LD_VAR 0 11
40952: PUSH
40953: LD_INT 1
40955: PLUS
40956: PPUSH
40957: LD_VAR 0 9
40961: PUSH
40962: LD_VAR 0 3
40966: ARRAY
40967: PPUSH
40968: CALL_OW 2
40972: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40973: LD_ADDR_VAR 0 4
40977: PUSH
40978: LD_VAR 0 4
40982: PUSH
40983: LD_VAR 0 9
40987: PUSH
40988: LD_VAR 0 3
40992: ARRAY
40993: DIFF
40994: ST_TO_ADDR
// end ;
40995: GO 40904
40997: POP
40998: POP
// if p then
40999: LD_VAR 0 11
41003: IFFALSE 41028
// result := Replace ( result , 3 , p ) ;
41005: LD_ADDR_VAR 0 2
41009: PUSH
41010: LD_VAR 0 2
41014: PPUSH
41015: LD_INT 3
41017: PPUSH
41018: LD_VAR 0 11
41022: PPUSH
41023: CALL_OW 1
41027: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41028: LD_ADDR_VAR 0 4
41032: PUSH
41033: LD_VAR 0 4
41037: PUSH
41038: LD_VAR 0 6
41042: DIFF
41043: ST_TO_ADDR
// if tmp and eng < 6 then
41044: LD_VAR 0 4
41048: PUSH
41049: LD_VAR 0 6
41053: PUSH
41054: LD_INT 6
41056: LESS
41057: AND
41058: IFFALSE 41252
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41060: LD_ADDR_VAR 0 9
41064: PUSH
41065: LD_VAR 0 4
41069: PUSH
41070: LD_VAR 0 8
41074: PUSH
41075: LD_VAR 0 7
41079: UNION
41080: PUSH
41081: LD_VAR 0 6
41085: UNION
41086: DIFF
41087: PPUSH
41088: LD_INT 2
41090: PPUSH
41091: CALL 103949 0 2
41095: ST_TO_ADDR
// p := [ ] ;
41096: LD_ADDR_VAR 0 11
41100: PUSH
41101: EMPTY
41102: ST_TO_ADDR
// if sort then
41103: LD_VAR 0 9
41107: IFFALSE 41223
// for i = 1 to 6 - eng do
41109: LD_ADDR_VAR 0 3
41113: PUSH
41114: DOUBLE
41115: LD_INT 1
41117: DEC
41118: ST_TO_ADDR
41119: LD_INT 6
41121: PUSH
41122: LD_VAR 0 6
41126: MINUS
41127: PUSH
41128: FOR_TO
41129: IFFALSE 41221
// begin if i = sort then
41131: LD_VAR 0 3
41135: PUSH
41136: LD_VAR 0 9
41140: EQUAL
41141: IFFALSE 41145
// break ;
41143: GO 41221
// if GetClass ( i ) = 2 then
41145: LD_VAR 0 3
41149: PPUSH
41150: CALL_OW 257
41154: PUSH
41155: LD_INT 2
41157: EQUAL
41158: IFFALSE 41162
// continue ;
41160: GO 41128
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41162: LD_ADDR_VAR 0 11
41166: PUSH
41167: LD_VAR 0 11
41171: PPUSH
41172: LD_VAR 0 11
41176: PUSH
41177: LD_INT 1
41179: PLUS
41180: PPUSH
41181: LD_VAR 0 9
41185: PUSH
41186: LD_VAR 0 3
41190: ARRAY
41191: PPUSH
41192: CALL_OW 2
41196: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41197: LD_ADDR_VAR 0 4
41201: PUSH
41202: LD_VAR 0 4
41206: PUSH
41207: LD_VAR 0 9
41211: PUSH
41212: LD_VAR 0 3
41216: ARRAY
41217: DIFF
41218: ST_TO_ADDR
// end ;
41219: GO 41128
41221: POP
41222: POP
// if p then
41223: LD_VAR 0 11
41227: IFFALSE 41252
// result := Replace ( result , 2 , p ) ;
41229: LD_ADDR_VAR 0 2
41233: PUSH
41234: LD_VAR 0 2
41238: PPUSH
41239: LD_INT 2
41241: PPUSH
41242: LD_VAR 0 11
41246: PPUSH
41247: CALL_OW 1
41251: ST_TO_ADDR
// end ; exit ;
41252: GO 41976
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41254: LD_EXP 126
41258: PUSH
41259: LD_EXP 125
41263: PUSH
41264: LD_VAR 0 1
41268: ARRAY
41269: ARRAY
41270: NOT
41271: PUSH
41272: LD_EXP 99
41276: PUSH
41277: LD_VAR 0 1
41281: ARRAY
41282: PPUSH
41283: LD_INT 30
41285: PUSH
41286: LD_INT 3
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PPUSH
41293: CALL_OW 72
41297: AND
41298: PUSH
41299: LD_EXP 104
41303: PUSH
41304: LD_VAR 0 1
41308: ARRAY
41309: NOT
41310: AND
41311: IFFALSE 41976
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41313: LD_ADDR_EXP 141
41317: PUSH
41318: LD_EXP 141
41322: PPUSH
41323: LD_VAR 0 1
41327: PPUSH
41328: LD_INT 6
41330: PPUSH
41331: CALL_OW 1
41335: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41336: LD_ADDR_VAR 0 2
41340: PUSH
41341: LD_INT 0
41343: PUSH
41344: LD_INT 0
41346: PUSH
41347: LD_INT 0
41349: PUSH
41350: LD_INT 0
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: LIST
41357: LIST
41358: ST_TO_ADDR
// if sci >= 1 then
41359: LD_VAR 0 8
41363: PUSH
41364: LD_INT 1
41366: GREATEREQUAL
41367: IFFALSE 41389
// tmp := tmp diff sci [ 1 ] ;
41369: LD_ADDR_VAR 0 4
41373: PUSH
41374: LD_VAR 0 4
41378: PUSH
41379: LD_VAR 0 8
41383: PUSH
41384: LD_INT 1
41386: ARRAY
41387: DIFF
41388: ST_TO_ADDR
// if tmp and not sci then
41389: LD_VAR 0 4
41393: PUSH
41394: LD_VAR 0 8
41398: NOT
41399: AND
41400: IFFALSE 41469
// begin sort := SortBySkill ( tmp , 4 ) ;
41402: LD_ADDR_VAR 0 9
41406: PUSH
41407: LD_VAR 0 4
41411: PPUSH
41412: LD_INT 4
41414: PPUSH
41415: CALL 103949 0 2
41419: ST_TO_ADDR
// if sort then
41420: LD_VAR 0 9
41424: IFFALSE 41440
// p := sort [ 1 ] ;
41426: LD_ADDR_VAR 0 11
41430: PUSH
41431: LD_VAR 0 9
41435: PUSH
41436: LD_INT 1
41438: ARRAY
41439: ST_TO_ADDR
// if p then
41440: LD_VAR 0 11
41444: IFFALSE 41469
// result := Replace ( result , 4 , p ) ;
41446: LD_ADDR_VAR 0 2
41450: PUSH
41451: LD_VAR 0 2
41455: PPUSH
41456: LD_INT 4
41458: PPUSH
41459: LD_VAR 0 11
41463: PPUSH
41464: CALL_OW 1
41468: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41469: LD_ADDR_VAR 0 4
41473: PUSH
41474: LD_VAR 0 4
41478: PUSH
41479: LD_VAR 0 7
41483: DIFF
41484: ST_TO_ADDR
// if tmp and mech < 6 then
41485: LD_VAR 0 4
41489: PUSH
41490: LD_VAR 0 7
41494: PUSH
41495: LD_INT 6
41497: LESS
41498: AND
41499: IFFALSE 41681
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41501: LD_ADDR_VAR 0 9
41505: PUSH
41506: LD_VAR 0 4
41510: PUSH
41511: LD_VAR 0 7
41515: DIFF
41516: PPUSH
41517: LD_INT 3
41519: PPUSH
41520: CALL 103949 0 2
41524: ST_TO_ADDR
// p := [ ] ;
41525: LD_ADDR_VAR 0 11
41529: PUSH
41530: EMPTY
41531: ST_TO_ADDR
// if sort then
41532: LD_VAR 0 9
41536: IFFALSE 41652
// for i = 1 to 6 - mech do
41538: LD_ADDR_VAR 0 3
41542: PUSH
41543: DOUBLE
41544: LD_INT 1
41546: DEC
41547: ST_TO_ADDR
41548: LD_INT 6
41550: PUSH
41551: LD_VAR 0 7
41555: MINUS
41556: PUSH
41557: FOR_TO
41558: IFFALSE 41650
// begin if i = sort then
41560: LD_VAR 0 3
41564: PUSH
41565: LD_VAR 0 9
41569: EQUAL
41570: IFFALSE 41574
// break ;
41572: GO 41650
// if GetClass ( i ) = 3 then
41574: LD_VAR 0 3
41578: PPUSH
41579: CALL_OW 257
41583: PUSH
41584: LD_INT 3
41586: EQUAL
41587: IFFALSE 41591
// continue ;
41589: GO 41557
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41591: LD_ADDR_VAR 0 11
41595: PUSH
41596: LD_VAR 0 11
41600: PPUSH
41601: LD_VAR 0 11
41605: PUSH
41606: LD_INT 1
41608: PLUS
41609: PPUSH
41610: LD_VAR 0 9
41614: PUSH
41615: LD_VAR 0 3
41619: ARRAY
41620: PPUSH
41621: CALL_OW 2
41625: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41626: LD_ADDR_VAR 0 4
41630: PUSH
41631: LD_VAR 0 4
41635: PUSH
41636: LD_VAR 0 9
41640: PUSH
41641: LD_VAR 0 3
41645: ARRAY
41646: DIFF
41647: ST_TO_ADDR
// end ;
41648: GO 41557
41650: POP
41651: POP
// if p then
41652: LD_VAR 0 11
41656: IFFALSE 41681
// result := Replace ( result , 3 , p ) ;
41658: LD_ADDR_VAR 0 2
41662: PUSH
41663: LD_VAR 0 2
41667: PPUSH
41668: LD_INT 3
41670: PPUSH
41671: LD_VAR 0 11
41675: PPUSH
41676: CALL_OW 1
41680: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41681: LD_ADDR_VAR 0 4
41685: PUSH
41686: LD_VAR 0 4
41690: PUSH
41691: LD_VAR 0 6
41695: DIFF
41696: ST_TO_ADDR
// if tmp and eng < 4 then
41697: LD_VAR 0 4
41701: PUSH
41702: LD_VAR 0 6
41706: PUSH
41707: LD_INT 4
41709: LESS
41710: AND
41711: IFFALSE 41901
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41713: LD_ADDR_VAR 0 9
41717: PUSH
41718: LD_VAR 0 4
41722: PUSH
41723: LD_VAR 0 7
41727: PUSH
41728: LD_VAR 0 6
41732: UNION
41733: DIFF
41734: PPUSH
41735: LD_INT 2
41737: PPUSH
41738: CALL 103949 0 2
41742: ST_TO_ADDR
// p := [ ] ;
41743: LD_ADDR_VAR 0 11
41747: PUSH
41748: EMPTY
41749: ST_TO_ADDR
// if sort then
41750: LD_VAR 0 9
41754: IFFALSE 41870
// for i = 1 to 4 - eng do
41756: LD_ADDR_VAR 0 3
41760: PUSH
41761: DOUBLE
41762: LD_INT 1
41764: DEC
41765: ST_TO_ADDR
41766: LD_INT 4
41768: PUSH
41769: LD_VAR 0 6
41773: MINUS
41774: PUSH
41775: FOR_TO
41776: IFFALSE 41868
// begin if i = sort then
41778: LD_VAR 0 3
41782: PUSH
41783: LD_VAR 0 9
41787: EQUAL
41788: IFFALSE 41792
// break ;
41790: GO 41868
// if GetClass ( i ) = 2 then
41792: LD_VAR 0 3
41796: PPUSH
41797: CALL_OW 257
41801: PUSH
41802: LD_INT 2
41804: EQUAL
41805: IFFALSE 41809
// continue ;
41807: GO 41775
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41809: LD_ADDR_VAR 0 11
41813: PUSH
41814: LD_VAR 0 11
41818: PPUSH
41819: LD_VAR 0 11
41823: PUSH
41824: LD_INT 1
41826: PLUS
41827: PPUSH
41828: LD_VAR 0 9
41832: PUSH
41833: LD_VAR 0 3
41837: ARRAY
41838: PPUSH
41839: CALL_OW 2
41843: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41844: LD_ADDR_VAR 0 4
41848: PUSH
41849: LD_VAR 0 4
41853: PUSH
41854: LD_VAR 0 9
41858: PUSH
41859: LD_VAR 0 3
41863: ARRAY
41864: DIFF
41865: ST_TO_ADDR
// end ;
41866: GO 41775
41868: POP
41869: POP
// if p then
41870: LD_VAR 0 11
41874: IFFALSE 41899
// result := Replace ( result , 2 , p ) ;
41876: LD_ADDR_VAR 0 2
41880: PUSH
41881: LD_VAR 0 2
41885: PPUSH
41886: LD_INT 2
41888: PPUSH
41889: LD_VAR 0 11
41893: PPUSH
41894: CALL_OW 1
41898: ST_TO_ADDR
// end else
41899: GO 41945
// for i = eng downto 5 do
41901: LD_ADDR_VAR 0 3
41905: PUSH
41906: DOUBLE
41907: LD_VAR 0 6
41911: INC
41912: ST_TO_ADDR
41913: LD_INT 5
41915: PUSH
41916: FOR_DOWNTO
41917: IFFALSE 41943
// tmp := tmp union eng [ i ] ;
41919: LD_ADDR_VAR 0 4
41923: PUSH
41924: LD_VAR 0 4
41928: PUSH
41929: LD_VAR 0 6
41933: PUSH
41934: LD_VAR 0 3
41938: ARRAY
41939: UNION
41940: ST_TO_ADDR
41941: GO 41916
41943: POP
41944: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
41945: LD_ADDR_VAR 0 2
41949: PUSH
41950: LD_VAR 0 2
41954: PPUSH
41955: LD_INT 1
41957: PPUSH
41958: LD_VAR 0 4
41962: PUSH
41963: LD_VAR 0 5
41967: DIFF
41968: PPUSH
41969: CALL_OW 1
41973: ST_TO_ADDR
// exit ;
41974: GO 41976
// end ; end ;
41976: LD_VAR 0 2
41980: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
41981: LD_INT 0
41983: PPUSH
41984: PPUSH
41985: PPUSH
// if not mc_bases then
41986: LD_EXP 99
41990: NOT
41991: IFFALSE 41995
// exit ;
41993: GO 42101
// for i = 1 to mc_bases do
41995: LD_ADDR_VAR 0 2
41999: PUSH
42000: DOUBLE
42001: LD_INT 1
42003: DEC
42004: ST_TO_ADDR
42005: LD_EXP 99
42009: PUSH
42010: FOR_TO
42011: IFFALSE 42092
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42013: LD_ADDR_VAR 0 3
42017: PUSH
42018: LD_EXP 99
42022: PUSH
42023: LD_VAR 0 2
42027: ARRAY
42028: PPUSH
42029: LD_INT 21
42031: PUSH
42032: LD_INT 3
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 3
42041: PUSH
42042: LD_INT 24
42044: PUSH
42045: LD_INT 1000
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: PUSH
42052: EMPTY
42053: LIST
42054: LIST
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PPUSH
42060: CALL_OW 72
42064: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42065: LD_ADDR_EXP 100
42069: PUSH
42070: LD_EXP 100
42074: PPUSH
42075: LD_VAR 0 2
42079: PPUSH
42080: LD_VAR 0 3
42084: PPUSH
42085: CALL_OW 1
42089: ST_TO_ADDR
// end ;
42090: GO 42010
42092: POP
42093: POP
// RaiseSailEvent ( 101 ) ;
42094: LD_INT 101
42096: PPUSH
42097: CALL_OW 427
// end ;
42101: LD_VAR 0 1
42105: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42106: LD_INT 0
42108: PPUSH
42109: PPUSH
42110: PPUSH
42111: PPUSH
42112: PPUSH
42113: PPUSH
42114: PPUSH
// if not mc_bases then
42115: LD_EXP 99
42119: NOT
42120: IFFALSE 42124
// exit ;
42122: GO 42697
// for i = 1 to mc_bases do
42124: LD_ADDR_VAR 0 2
42128: PUSH
42129: DOUBLE
42130: LD_INT 1
42132: DEC
42133: ST_TO_ADDR
42134: LD_EXP 99
42138: PUSH
42139: FOR_TO
42140: IFFALSE 42688
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42142: LD_ADDR_VAR 0 5
42146: PUSH
42147: LD_EXP 99
42151: PUSH
42152: LD_VAR 0 2
42156: ARRAY
42157: PUSH
42158: LD_EXP 128
42162: PUSH
42163: LD_VAR 0 2
42167: ARRAY
42168: UNION
42169: PPUSH
42170: LD_INT 21
42172: PUSH
42173: LD_INT 1
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 1
42182: PUSH
42183: LD_INT 3
42185: PUSH
42186: LD_INT 54
42188: PUSH
42189: EMPTY
42190: LIST
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 3
42198: PUSH
42199: LD_INT 24
42201: PUSH
42202: LD_INT 800
42204: PUSH
42205: EMPTY
42206: LIST
42207: LIST
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: LIST
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PPUSH
42222: CALL_OW 72
42226: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42227: LD_ADDR_VAR 0 6
42231: PUSH
42232: LD_EXP 99
42236: PUSH
42237: LD_VAR 0 2
42241: ARRAY
42242: PPUSH
42243: LD_INT 21
42245: PUSH
42246: LD_INT 1
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 1
42255: PUSH
42256: LD_INT 3
42258: PUSH
42259: LD_INT 54
42261: PUSH
42262: EMPTY
42263: LIST
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 3
42271: PUSH
42272: LD_INT 24
42274: PUSH
42275: LD_INT 250
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: LIST
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PPUSH
42295: CALL_OW 72
42299: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42300: LD_ADDR_VAR 0 7
42304: PUSH
42305: LD_VAR 0 5
42309: PUSH
42310: LD_VAR 0 6
42314: DIFF
42315: ST_TO_ADDR
// if not need_heal_1 then
42316: LD_VAR 0 6
42320: NOT
42321: IFFALSE 42354
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42323: LD_ADDR_EXP 102
42327: PUSH
42328: LD_EXP 102
42332: PPUSH
42333: LD_VAR 0 2
42337: PUSH
42338: LD_INT 1
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PPUSH
42345: EMPTY
42346: PPUSH
42347: CALL 69701 0 3
42351: ST_TO_ADDR
42352: GO 42424
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42354: LD_ADDR_EXP 102
42358: PUSH
42359: LD_EXP 102
42363: PPUSH
42364: LD_VAR 0 2
42368: PUSH
42369: LD_INT 1
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PPUSH
42376: LD_EXP 102
42380: PUSH
42381: LD_VAR 0 2
42385: ARRAY
42386: PUSH
42387: LD_INT 1
42389: ARRAY
42390: PPUSH
42391: LD_INT 3
42393: PUSH
42394: LD_INT 24
42396: PUSH
42397: LD_INT 1000
42399: PUSH
42400: EMPTY
42401: LIST
42402: LIST
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PPUSH
42408: CALL_OW 72
42412: PUSH
42413: LD_VAR 0 6
42417: UNION
42418: PPUSH
42419: CALL 69701 0 3
42423: ST_TO_ADDR
// if not need_heal_2 then
42424: LD_VAR 0 7
42428: NOT
42429: IFFALSE 42462
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42431: LD_ADDR_EXP 102
42435: PUSH
42436: LD_EXP 102
42440: PPUSH
42441: LD_VAR 0 2
42445: PUSH
42446: LD_INT 2
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PPUSH
42453: EMPTY
42454: PPUSH
42455: CALL 69701 0 3
42459: ST_TO_ADDR
42460: GO 42494
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42462: LD_ADDR_EXP 102
42466: PUSH
42467: LD_EXP 102
42471: PPUSH
42472: LD_VAR 0 2
42476: PUSH
42477: LD_INT 2
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PPUSH
42484: LD_VAR 0 7
42488: PPUSH
42489: CALL 69701 0 3
42493: ST_TO_ADDR
// if need_heal_2 then
42494: LD_VAR 0 7
42498: IFFALSE 42670
// for j in need_heal_2 do
42500: LD_ADDR_VAR 0 3
42504: PUSH
42505: LD_VAR 0 7
42509: PUSH
42510: FOR_IN
42511: IFFALSE 42668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42513: LD_ADDR_VAR 0 5
42517: PUSH
42518: LD_EXP 99
42522: PUSH
42523: LD_VAR 0 2
42527: ARRAY
42528: PPUSH
42529: LD_INT 2
42531: PUSH
42532: LD_INT 30
42534: PUSH
42535: LD_INT 6
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 30
42544: PUSH
42545: LD_INT 7
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 30
42554: PUSH
42555: LD_INT 8
42557: PUSH
42558: EMPTY
42559: LIST
42560: LIST
42561: PUSH
42562: LD_INT 30
42564: PUSH
42565: LD_INT 0
42567: PUSH
42568: EMPTY
42569: LIST
42570: LIST
42571: PUSH
42572: LD_INT 30
42574: PUSH
42575: LD_INT 1
42577: PUSH
42578: EMPTY
42579: LIST
42580: LIST
42581: PUSH
42582: LD_INT 25
42584: PUSH
42585: LD_INT 4
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: PPUSH
42601: CALL_OW 72
42605: ST_TO_ADDR
// if tmp then
42606: LD_VAR 0 5
42610: IFFALSE 42666
// begin k := NearestUnitToUnit ( tmp , j ) ;
42612: LD_ADDR_VAR 0 4
42616: PUSH
42617: LD_VAR 0 5
42621: PPUSH
42622: LD_VAR 0 3
42626: PPUSH
42627: CALL_OW 74
42631: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42632: LD_VAR 0 3
42636: PPUSH
42637: LD_VAR 0 4
42641: PPUSH
42642: CALL_OW 296
42646: PUSH
42647: LD_INT 7
42649: GREATER
42650: IFFALSE 42666
// ComMoveUnit ( j , k ) ;
42652: LD_VAR 0 3
42656: PPUSH
42657: LD_VAR 0 4
42661: PPUSH
42662: CALL_OW 112
// end ; end ;
42666: GO 42510
42668: POP
42669: POP
// if not need_heal_1 and not need_heal_2 then
42670: LD_VAR 0 6
42674: NOT
42675: PUSH
42676: LD_VAR 0 7
42680: NOT
42681: AND
42682: IFFALSE 42686
// continue ;
42684: GO 42139
// end ;
42686: GO 42139
42688: POP
42689: POP
// RaiseSailEvent ( 102 ) ;
42690: LD_INT 102
42692: PPUSH
42693: CALL_OW 427
// end ;
42697: LD_VAR 0 1
42701: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
42702: LD_INT 0
42704: PPUSH
42705: PPUSH
42706: PPUSH
42707: PPUSH
42708: PPUSH
// if not mc_bases then
42709: LD_EXP 99
42713: NOT
42714: IFFALSE 42718
// exit ;
42716: GO 43103
// for i = 1 to mc_bases do
42718: LD_ADDR_VAR 0 2
42722: PUSH
42723: DOUBLE
42724: LD_INT 1
42726: DEC
42727: ST_TO_ADDR
42728: LD_EXP 99
42732: PUSH
42733: FOR_TO
42734: IFFALSE 43101
// begin if not mc_building_need_repair [ i ] then
42736: LD_EXP 100
42740: PUSH
42741: LD_VAR 0 2
42745: ARRAY
42746: NOT
42747: IFFALSE 42785
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42749: LD_ADDR_EXP 101
42753: PUSH
42754: LD_EXP 101
42758: PPUSH
42759: LD_VAR 0 2
42763: PPUSH
42764: EMPTY
42765: PPUSH
42766: CALL_OW 1
42770: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
42771: LD_VAR 0 2
42775: PPUSH
42776: LD_INT 101
42778: PPUSH
42779: CALL 37823 0 2
// continue ;
42783: GO 42733
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
42785: LD_ADDR_EXP 105
42789: PUSH
42790: LD_EXP 105
42794: PPUSH
42795: LD_VAR 0 2
42799: PPUSH
42800: EMPTY
42801: PPUSH
42802: CALL_OW 1
42806: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42807: LD_VAR 0 2
42811: PPUSH
42812: LD_INT 103
42814: PPUSH
42815: CALL 37823 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
42819: LD_ADDR_VAR 0 5
42823: PUSH
42824: LD_EXP 99
42828: PUSH
42829: LD_VAR 0 2
42833: ARRAY
42834: PUSH
42835: LD_EXP 128
42839: PUSH
42840: LD_VAR 0 2
42844: ARRAY
42845: UNION
42846: PPUSH
42847: LD_INT 2
42849: PUSH
42850: LD_INT 25
42852: PUSH
42853: LD_INT 2
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: LD_INT 25
42862: PUSH
42863: LD_INT 16
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: EMPTY
42871: LIST
42872: LIST
42873: LIST
42874: PUSH
42875: EMPTY
42876: LIST
42877: PPUSH
42878: CALL_OW 72
42882: ST_TO_ADDR
// if not tmp then
42883: LD_VAR 0 5
42887: NOT
42888: IFFALSE 42892
// continue ;
42890: GO 42733
// for j in tmp do
42892: LD_ADDR_VAR 0 3
42896: PUSH
42897: LD_VAR 0 5
42901: PUSH
42902: FOR_IN
42903: IFFALSE 43097
// begin if mc_need_heal [ i ] then
42905: LD_EXP 102
42909: PUSH
42910: LD_VAR 0 2
42914: ARRAY
42915: IFFALSE 42963
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
42917: LD_VAR 0 3
42921: PUSH
42922: LD_EXP 102
42926: PUSH
42927: LD_VAR 0 2
42931: ARRAY
42932: PUSH
42933: LD_INT 1
42935: ARRAY
42936: IN
42937: PUSH
42938: LD_VAR 0 3
42942: PUSH
42943: LD_EXP 102
42947: PUSH
42948: LD_VAR 0 2
42952: ARRAY
42953: PUSH
42954: LD_INT 2
42956: ARRAY
42957: IN
42958: OR
42959: IFFALSE 42963
// continue ;
42961: GO 42902
// if IsInUnit ( j ) then
42963: LD_VAR 0 3
42967: PPUSH
42968: CALL_OW 310
42972: IFFALSE 42983
// ComExitBuilding ( j ) ;
42974: LD_VAR 0 3
42978: PPUSH
42979: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
42983: LD_VAR 0 3
42987: PUSH
42988: LD_EXP 101
42992: PUSH
42993: LD_VAR 0 2
42997: ARRAY
42998: IN
42999: NOT
43000: IFFALSE 43058
// begin SetTag ( j , 101 ) ;
43002: LD_VAR 0 3
43006: PPUSH
43007: LD_INT 101
43009: PPUSH
43010: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43014: LD_ADDR_EXP 101
43018: PUSH
43019: LD_EXP 101
43023: PPUSH
43024: LD_VAR 0 2
43028: PUSH
43029: LD_EXP 101
43033: PUSH
43034: LD_VAR 0 2
43038: ARRAY
43039: PUSH
43040: LD_INT 1
43042: PLUS
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PPUSH
43048: LD_VAR 0 3
43052: PPUSH
43053: CALL 69701 0 3
43057: ST_TO_ADDR
// end ; wait ( 1 ) ;
43058: LD_INT 1
43060: PPUSH
43061: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43065: LD_VAR 0 3
43069: PPUSH
43070: LD_EXP 100
43074: PUSH
43075: LD_VAR 0 2
43079: ARRAY
43080: PPUSH
43081: LD_VAR 0 3
43085: PPUSH
43086: CALL_OW 74
43090: PPUSH
43091: CALL_OW 130
// end ;
43095: GO 42902
43097: POP
43098: POP
// end ;
43099: GO 42733
43101: POP
43102: POP
// end ;
43103: LD_VAR 0 1
43107: RET
// export function MC_Heal ; var i , j , tmp ; begin
43108: LD_INT 0
43110: PPUSH
43111: PPUSH
43112: PPUSH
43113: PPUSH
// if not mc_bases then
43114: LD_EXP 99
43118: NOT
43119: IFFALSE 43123
// exit ;
43121: GO 43525
// for i = 1 to mc_bases do
43123: LD_ADDR_VAR 0 2
43127: PUSH
43128: DOUBLE
43129: LD_INT 1
43131: DEC
43132: ST_TO_ADDR
43133: LD_EXP 99
43137: PUSH
43138: FOR_TO
43139: IFFALSE 43523
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43141: LD_EXP 102
43145: PUSH
43146: LD_VAR 0 2
43150: ARRAY
43151: PUSH
43152: LD_INT 1
43154: ARRAY
43155: NOT
43156: PUSH
43157: LD_EXP 102
43161: PUSH
43162: LD_VAR 0 2
43166: ARRAY
43167: PUSH
43168: LD_INT 2
43170: ARRAY
43171: NOT
43172: AND
43173: IFFALSE 43211
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43175: LD_ADDR_EXP 103
43179: PUSH
43180: LD_EXP 103
43184: PPUSH
43185: LD_VAR 0 2
43189: PPUSH
43190: EMPTY
43191: PPUSH
43192: CALL_OW 1
43196: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43197: LD_VAR 0 2
43201: PPUSH
43202: LD_INT 102
43204: PPUSH
43205: CALL 37823 0 2
// continue ;
43209: GO 43138
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43211: LD_ADDR_VAR 0 4
43215: PUSH
43216: LD_EXP 99
43220: PUSH
43221: LD_VAR 0 2
43225: ARRAY
43226: PPUSH
43227: LD_INT 25
43229: PUSH
43230: LD_INT 4
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PPUSH
43237: CALL_OW 72
43241: ST_TO_ADDR
// if not tmp then
43242: LD_VAR 0 4
43246: NOT
43247: IFFALSE 43251
// continue ;
43249: GO 43138
// if mc_taming [ i ] then
43251: LD_EXP 130
43255: PUSH
43256: LD_VAR 0 2
43260: ARRAY
43261: IFFALSE 43285
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43263: LD_ADDR_EXP 130
43267: PUSH
43268: LD_EXP 130
43272: PPUSH
43273: LD_VAR 0 2
43277: PPUSH
43278: EMPTY
43279: PPUSH
43280: CALL_OW 1
43284: ST_TO_ADDR
// for j in tmp do
43285: LD_ADDR_VAR 0 3
43289: PUSH
43290: LD_VAR 0 4
43294: PUSH
43295: FOR_IN
43296: IFFALSE 43519
// begin if IsInUnit ( j ) then
43298: LD_VAR 0 3
43302: PPUSH
43303: CALL_OW 310
43307: IFFALSE 43318
// ComExitBuilding ( j ) ;
43309: LD_VAR 0 3
43313: PPUSH
43314: CALL_OW 122
// if not j in mc_healers [ i ] then
43318: LD_VAR 0 3
43322: PUSH
43323: LD_EXP 103
43327: PUSH
43328: LD_VAR 0 2
43332: ARRAY
43333: IN
43334: NOT
43335: IFFALSE 43381
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43337: LD_ADDR_EXP 103
43341: PUSH
43342: LD_EXP 103
43346: PPUSH
43347: LD_VAR 0 2
43351: PUSH
43352: LD_EXP 103
43356: PUSH
43357: LD_VAR 0 2
43361: ARRAY
43362: PUSH
43363: LD_INT 1
43365: PLUS
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PPUSH
43371: LD_VAR 0 3
43375: PPUSH
43376: CALL 69701 0 3
43380: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43381: LD_VAR 0 3
43385: PPUSH
43386: CALL_OW 110
43390: PUSH
43391: LD_INT 102
43393: NONEQUAL
43394: IFFALSE 43408
// SetTag ( j , 102 ) ;
43396: LD_VAR 0 3
43400: PPUSH
43401: LD_INT 102
43403: PPUSH
43404: CALL_OW 109
// Wait ( 3 ) ;
43408: LD_INT 3
43410: PPUSH
43411: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43415: LD_EXP 102
43419: PUSH
43420: LD_VAR 0 2
43424: ARRAY
43425: PUSH
43426: LD_INT 1
43428: ARRAY
43429: IFFALSE 43461
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43431: LD_VAR 0 3
43435: PPUSH
43436: LD_EXP 102
43440: PUSH
43441: LD_VAR 0 2
43445: ARRAY
43446: PUSH
43447: LD_INT 1
43449: ARRAY
43450: PUSH
43451: LD_INT 1
43453: ARRAY
43454: PPUSH
43455: CALL_OW 128
43459: GO 43517
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43461: LD_VAR 0 3
43465: PPUSH
43466: CALL_OW 314
43470: NOT
43471: PUSH
43472: LD_EXP 102
43476: PUSH
43477: LD_VAR 0 2
43481: ARRAY
43482: PUSH
43483: LD_INT 2
43485: ARRAY
43486: AND
43487: IFFALSE 43517
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43489: LD_VAR 0 3
43493: PPUSH
43494: LD_EXP 102
43498: PUSH
43499: LD_VAR 0 2
43503: ARRAY
43504: PUSH
43505: LD_INT 2
43507: ARRAY
43508: PUSH
43509: LD_INT 1
43511: ARRAY
43512: PPUSH
43513: CALL_OW 128
// end ;
43517: GO 43295
43519: POP
43520: POP
// end ;
43521: GO 43138
43523: POP
43524: POP
// end ;
43525: LD_VAR 0 1
43529: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
43530: LD_INT 0
43532: PPUSH
43533: PPUSH
43534: PPUSH
43535: PPUSH
43536: PPUSH
// if not mc_bases then
43537: LD_EXP 99
43541: NOT
43542: IFFALSE 43546
// exit ;
43544: GO 44689
// for i = 1 to mc_bases do
43546: LD_ADDR_VAR 0 2
43550: PUSH
43551: DOUBLE
43552: LD_INT 1
43554: DEC
43555: ST_TO_ADDR
43556: LD_EXP 99
43560: PUSH
43561: FOR_TO
43562: IFFALSE 44687
// begin if mc_scan [ i ] then
43564: LD_EXP 122
43568: PUSH
43569: LD_VAR 0 2
43573: ARRAY
43574: IFFALSE 43578
// continue ;
43576: GO 43561
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
43578: LD_EXP 104
43582: PUSH
43583: LD_VAR 0 2
43587: ARRAY
43588: NOT
43589: PUSH
43590: LD_EXP 106
43594: PUSH
43595: LD_VAR 0 2
43599: ARRAY
43600: NOT
43601: AND
43602: PUSH
43603: LD_EXP 105
43607: PUSH
43608: LD_VAR 0 2
43612: ARRAY
43613: AND
43614: IFFALSE 43652
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
43616: LD_ADDR_EXP 105
43620: PUSH
43621: LD_EXP 105
43625: PPUSH
43626: LD_VAR 0 2
43630: PPUSH
43631: EMPTY
43632: PPUSH
43633: CALL_OW 1
43637: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43638: LD_VAR 0 2
43642: PPUSH
43643: LD_INT 103
43645: PPUSH
43646: CALL 37823 0 2
// continue ;
43650: GO 43561
// end ; if mc_construct_list [ i ] then
43652: LD_EXP 106
43656: PUSH
43657: LD_VAR 0 2
43661: ARRAY
43662: IFFALSE 43882
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
43664: LD_ADDR_VAR 0 4
43668: PUSH
43669: LD_EXP 99
43673: PUSH
43674: LD_VAR 0 2
43678: ARRAY
43679: PPUSH
43680: LD_INT 25
43682: PUSH
43683: LD_INT 2
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PPUSH
43690: CALL_OW 72
43694: PUSH
43695: LD_EXP 101
43699: PUSH
43700: LD_VAR 0 2
43704: ARRAY
43705: DIFF
43706: ST_TO_ADDR
// if not tmp then
43707: LD_VAR 0 4
43711: NOT
43712: IFFALSE 43716
// continue ;
43714: GO 43561
// for j in tmp do
43716: LD_ADDR_VAR 0 3
43720: PUSH
43721: LD_VAR 0 4
43725: PUSH
43726: FOR_IN
43727: IFFALSE 43878
// begin if not mc_builders [ i ] then
43729: LD_EXP 105
43733: PUSH
43734: LD_VAR 0 2
43738: ARRAY
43739: NOT
43740: IFFALSE 43798
// begin SetTag ( j , 103 ) ;
43742: LD_VAR 0 3
43746: PPUSH
43747: LD_INT 103
43749: PPUSH
43750: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
43754: LD_ADDR_EXP 105
43758: PUSH
43759: LD_EXP 105
43763: PPUSH
43764: LD_VAR 0 2
43768: PUSH
43769: LD_EXP 105
43773: PUSH
43774: LD_VAR 0 2
43778: ARRAY
43779: PUSH
43780: LD_INT 1
43782: PLUS
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PPUSH
43788: LD_VAR 0 3
43792: PPUSH
43793: CALL 69701 0 3
43797: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
43798: LD_VAR 0 3
43802: PPUSH
43803: CALL_OW 310
43807: IFFALSE 43818
// ComExitBuilding ( j ) ;
43809: LD_VAR 0 3
43813: PPUSH
43814: CALL_OW 122
// wait ( 3 ) ;
43818: LD_INT 3
43820: PPUSH
43821: CALL_OW 67
// if not mc_construct_list [ i ] then
43825: LD_EXP 106
43829: PUSH
43830: LD_VAR 0 2
43834: ARRAY
43835: NOT
43836: IFFALSE 43840
// break ;
43838: GO 43878
// if not HasTask ( j ) then
43840: LD_VAR 0 3
43844: PPUSH
43845: CALL_OW 314
43849: NOT
43850: IFFALSE 43876
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
43852: LD_VAR 0 3
43856: PPUSH
43857: LD_EXP 106
43861: PUSH
43862: LD_VAR 0 2
43866: ARRAY
43867: PUSH
43868: LD_INT 1
43870: ARRAY
43871: PPUSH
43872: CALL 72552 0 2
// end ;
43876: GO 43726
43878: POP
43879: POP
// end else
43880: GO 44685
// if mc_build_list [ i ] then
43882: LD_EXP 104
43886: PUSH
43887: LD_VAR 0 2
43891: ARRAY
43892: IFFALSE 44685
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43894: LD_ADDR_VAR 0 5
43898: PUSH
43899: LD_EXP 99
43903: PUSH
43904: LD_VAR 0 2
43908: ARRAY
43909: PPUSH
43910: LD_INT 2
43912: PUSH
43913: LD_INT 30
43915: PUSH
43916: LD_INT 0
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 30
43925: PUSH
43926: LD_INT 1
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: LIST
43937: PPUSH
43938: CALL_OW 72
43942: ST_TO_ADDR
// if depot then
43943: LD_VAR 0 5
43947: IFFALSE 43965
// depot := depot [ 1 ] else
43949: LD_ADDR_VAR 0 5
43953: PUSH
43954: LD_VAR 0 5
43958: PUSH
43959: LD_INT 1
43961: ARRAY
43962: ST_TO_ADDR
43963: GO 43973
// depot := 0 ;
43965: LD_ADDR_VAR 0 5
43969: PUSH
43970: LD_INT 0
43972: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
43973: LD_EXP 104
43977: PUSH
43978: LD_VAR 0 2
43982: ARRAY
43983: PUSH
43984: LD_INT 1
43986: ARRAY
43987: PUSH
43988: LD_INT 1
43990: ARRAY
43991: PPUSH
43992: CALL 72382 0 1
43996: PUSH
43997: LD_EXP 99
44001: PUSH
44002: LD_VAR 0 2
44006: ARRAY
44007: PPUSH
44008: LD_INT 2
44010: PUSH
44011: LD_INT 30
44013: PUSH
44014: LD_INT 2
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 30
44023: PUSH
44024: LD_INT 3
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: LIST
44035: PPUSH
44036: CALL_OW 72
44040: NOT
44041: AND
44042: IFFALSE 44147
// begin for j = 1 to mc_build_list [ i ] do
44044: LD_ADDR_VAR 0 3
44048: PUSH
44049: DOUBLE
44050: LD_INT 1
44052: DEC
44053: ST_TO_ADDR
44054: LD_EXP 104
44058: PUSH
44059: LD_VAR 0 2
44063: ARRAY
44064: PUSH
44065: FOR_TO
44066: IFFALSE 44145
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44068: LD_EXP 104
44072: PUSH
44073: LD_VAR 0 2
44077: ARRAY
44078: PUSH
44079: LD_VAR 0 3
44083: ARRAY
44084: PUSH
44085: LD_INT 1
44087: ARRAY
44088: PUSH
44089: LD_INT 2
44091: EQUAL
44092: IFFALSE 44143
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44094: LD_ADDR_EXP 104
44098: PUSH
44099: LD_EXP 104
44103: PPUSH
44104: LD_VAR 0 2
44108: PPUSH
44109: LD_EXP 104
44113: PUSH
44114: LD_VAR 0 2
44118: ARRAY
44119: PPUSH
44120: LD_VAR 0 3
44124: PPUSH
44125: LD_INT 1
44127: PPUSH
44128: LD_INT 0
44130: PPUSH
44131: CALL 69119 0 4
44135: PPUSH
44136: CALL_OW 1
44140: ST_TO_ADDR
// break ;
44141: GO 44145
// end ;
44143: GO 44065
44145: POP
44146: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44147: LD_EXP 104
44151: PUSH
44152: LD_VAR 0 2
44156: ARRAY
44157: PUSH
44158: LD_INT 1
44160: ARRAY
44161: PUSH
44162: LD_INT 1
44164: ARRAY
44165: PUSH
44166: LD_INT 0
44168: EQUAL
44169: PUSH
44170: LD_VAR 0 5
44174: PUSH
44175: LD_VAR 0 5
44179: PPUSH
44180: LD_EXP 104
44184: PUSH
44185: LD_VAR 0 2
44189: ARRAY
44190: PUSH
44191: LD_INT 1
44193: ARRAY
44194: PUSH
44195: LD_INT 1
44197: ARRAY
44198: PPUSH
44199: LD_EXP 104
44203: PUSH
44204: LD_VAR 0 2
44208: ARRAY
44209: PUSH
44210: LD_INT 1
44212: ARRAY
44213: PUSH
44214: LD_INT 2
44216: ARRAY
44217: PPUSH
44218: LD_EXP 104
44222: PUSH
44223: LD_VAR 0 2
44227: ARRAY
44228: PUSH
44229: LD_INT 1
44231: ARRAY
44232: PUSH
44233: LD_INT 3
44235: ARRAY
44236: PPUSH
44237: LD_EXP 104
44241: PUSH
44242: LD_VAR 0 2
44246: ARRAY
44247: PUSH
44248: LD_INT 1
44250: ARRAY
44251: PUSH
44252: LD_INT 4
44254: ARRAY
44255: PPUSH
44256: CALL 77116 0 5
44260: AND
44261: OR
44262: IFFALSE 44543
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44264: LD_ADDR_VAR 0 4
44268: PUSH
44269: LD_EXP 99
44273: PUSH
44274: LD_VAR 0 2
44278: ARRAY
44279: PPUSH
44280: LD_INT 25
44282: PUSH
44283: LD_INT 2
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PPUSH
44290: CALL_OW 72
44294: PUSH
44295: LD_EXP 101
44299: PUSH
44300: LD_VAR 0 2
44304: ARRAY
44305: DIFF
44306: ST_TO_ADDR
// if not tmp then
44307: LD_VAR 0 4
44311: NOT
44312: IFFALSE 44316
// continue ;
44314: GO 43561
// for j in tmp do
44316: LD_ADDR_VAR 0 3
44320: PUSH
44321: LD_VAR 0 4
44325: PUSH
44326: FOR_IN
44327: IFFALSE 44539
// begin if not mc_builders [ i ] then
44329: LD_EXP 105
44333: PUSH
44334: LD_VAR 0 2
44338: ARRAY
44339: NOT
44340: IFFALSE 44398
// begin SetTag ( j , 103 ) ;
44342: LD_VAR 0 3
44346: PPUSH
44347: LD_INT 103
44349: PPUSH
44350: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44354: LD_ADDR_EXP 105
44358: PUSH
44359: LD_EXP 105
44363: PPUSH
44364: LD_VAR 0 2
44368: PUSH
44369: LD_EXP 105
44373: PUSH
44374: LD_VAR 0 2
44378: ARRAY
44379: PUSH
44380: LD_INT 1
44382: PLUS
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PPUSH
44388: LD_VAR 0 3
44392: PPUSH
44393: CALL 69701 0 3
44397: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44398: LD_VAR 0 3
44402: PPUSH
44403: CALL_OW 310
44407: IFFALSE 44418
// ComExitBuilding ( j ) ;
44409: LD_VAR 0 3
44413: PPUSH
44414: CALL_OW 122
// wait ( 3 ) ;
44418: LD_INT 3
44420: PPUSH
44421: CALL_OW 67
// if not mc_build_list [ i ] then
44425: LD_EXP 104
44429: PUSH
44430: LD_VAR 0 2
44434: ARRAY
44435: NOT
44436: IFFALSE 44440
// break ;
44438: GO 44539
// if not HasTask ( j ) then
44440: LD_VAR 0 3
44444: PPUSH
44445: CALL_OW 314
44449: NOT
44450: IFFALSE 44537
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44452: LD_VAR 0 3
44456: PPUSH
44457: LD_EXP 104
44461: PUSH
44462: LD_VAR 0 2
44466: ARRAY
44467: PUSH
44468: LD_INT 1
44470: ARRAY
44471: PUSH
44472: LD_INT 1
44474: ARRAY
44475: PPUSH
44476: LD_EXP 104
44480: PUSH
44481: LD_VAR 0 2
44485: ARRAY
44486: PUSH
44487: LD_INT 1
44489: ARRAY
44490: PUSH
44491: LD_INT 2
44493: ARRAY
44494: PPUSH
44495: LD_EXP 104
44499: PUSH
44500: LD_VAR 0 2
44504: ARRAY
44505: PUSH
44506: LD_INT 1
44508: ARRAY
44509: PUSH
44510: LD_INT 3
44512: ARRAY
44513: PPUSH
44514: LD_EXP 104
44518: PUSH
44519: LD_VAR 0 2
44523: ARRAY
44524: PUSH
44525: LD_INT 1
44527: ARRAY
44528: PUSH
44529: LD_INT 4
44531: ARRAY
44532: PPUSH
44533: CALL_OW 145
// end ;
44537: GO 44326
44539: POP
44540: POP
// end else
44541: GO 44685
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
44543: LD_EXP 99
44547: PUSH
44548: LD_VAR 0 2
44552: ARRAY
44553: PPUSH
44554: LD_EXP 104
44558: PUSH
44559: LD_VAR 0 2
44563: ARRAY
44564: PUSH
44565: LD_INT 1
44567: ARRAY
44568: PUSH
44569: LD_INT 1
44571: ARRAY
44572: PPUSH
44573: LD_EXP 104
44577: PUSH
44578: LD_VAR 0 2
44582: ARRAY
44583: PUSH
44584: LD_INT 1
44586: ARRAY
44587: PUSH
44588: LD_INT 2
44590: ARRAY
44591: PPUSH
44592: LD_EXP 104
44596: PUSH
44597: LD_VAR 0 2
44601: ARRAY
44602: PUSH
44603: LD_INT 1
44605: ARRAY
44606: PUSH
44607: LD_INT 3
44609: ARRAY
44610: PPUSH
44611: LD_EXP 104
44615: PUSH
44616: LD_VAR 0 2
44620: ARRAY
44621: PUSH
44622: LD_INT 1
44624: ARRAY
44625: PUSH
44626: LD_INT 4
44628: ARRAY
44629: PPUSH
44630: CALL 76452 0 5
44634: NOT
44635: IFFALSE 44685
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
44637: LD_ADDR_EXP 104
44641: PUSH
44642: LD_EXP 104
44646: PPUSH
44647: LD_VAR 0 2
44651: PPUSH
44652: LD_EXP 104
44656: PUSH
44657: LD_VAR 0 2
44661: ARRAY
44662: PPUSH
44663: LD_INT 1
44665: PPUSH
44666: LD_INT 1
44668: NEG
44669: PPUSH
44670: LD_INT 0
44672: PPUSH
44673: CALL 69119 0 4
44677: PPUSH
44678: CALL_OW 1
44682: ST_TO_ADDR
// continue ;
44683: GO 43561
// end ; end ; end ;
44685: GO 43561
44687: POP
44688: POP
// end ;
44689: LD_VAR 0 1
44693: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
44694: LD_INT 0
44696: PPUSH
44697: PPUSH
44698: PPUSH
44699: PPUSH
44700: PPUSH
44701: PPUSH
// if not mc_bases then
44702: LD_EXP 99
44706: NOT
44707: IFFALSE 44711
// exit ;
44709: GO 45138
// for i = 1 to mc_bases do
44711: LD_ADDR_VAR 0 2
44715: PUSH
44716: DOUBLE
44717: LD_INT 1
44719: DEC
44720: ST_TO_ADDR
44721: LD_EXP 99
44725: PUSH
44726: FOR_TO
44727: IFFALSE 45136
// begin tmp := mc_build_upgrade [ i ] ;
44729: LD_ADDR_VAR 0 4
44733: PUSH
44734: LD_EXP 131
44738: PUSH
44739: LD_VAR 0 2
44743: ARRAY
44744: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
44745: LD_ADDR_VAR 0 6
44749: PUSH
44750: LD_EXP 132
44754: PUSH
44755: LD_VAR 0 2
44759: ARRAY
44760: PPUSH
44761: LD_INT 2
44763: PUSH
44764: LD_INT 30
44766: PUSH
44767: LD_INT 6
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: LD_INT 30
44776: PUSH
44777: LD_INT 7
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: LIST
44788: PPUSH
44789: CALL_OW 72
44793: ST_TO_ADDR
// if not tmp and not lab then
44794: LD_VAR 0 4
44798: NOT
44799: PUSH
44800: LD_VAR 0 6
44804: NOT
44805: AND
44806: IFFALSE 44810
// continue ;
44808: GO 44726
// if tmp then
44810: LD_VAR 0 4
44814: IFFALSE 44934
// for j in tmp do
44816: LD_ADDR_VAR 0 3
44820: PUSH
44821: LD_VAR 0 4
44825: PUSH
44826: FOR_IN
44827: IFFALSE 44932
// begin if UpgradeCost ( j ) then
44829: LD_VAR 0 3
44833: PPUSH
44834: CALL 76112 0 1
44838: IFFALSE 44930
// begin ComUpgrade ( j ) ;
44840: LD_VAR 0 3
44844: PPUSH
44845: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
44849: LD_ADDR_EXP 131
44853: PUSH
44854: LD_EXP 131
44858: PPUSH
44859: LD_VAR 0 2
44863: PPUSH
44864: LD_EXP 131
44868: PUSH
44869: LD_VAR 0 2
44873: ARRAY
44874: PUSH
44875: LD_VAR 0 3
44879: DIFF
44880: PPUSH
44881: CALL_OW 1
44885: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
44886: LD_ADDR_EXP 106
44890: PUSH
44891: LD_EXP 106
44895: PPUSH
44896: LD_VAR 0 2
44900: PUSH
44901: LD_EXP 106
44905: PUSH
44906: LD_VAR 0 2
44910: ARRAY
44911: PUSH
44912: LD_INT 1
44914: PLUS
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PPUSH
44920: LD_VAR 0 3
44924: PPUSH
44925: CALL 69701 0 3
44929: ST_TO_ADDR
// end ; end ;
44930: GO 44826
44932: POP
44933: POP
// if not lab or not mc_lab_upgrade [ i ] then
44934: LD_VAR 0 6
44938: NOT
44939: PUSH
44940: LD_EXP 133
44944: PUSH
44945: LD_VAR 0 2
44949: ARRAY
44950: NOT
44951: OR
44952: IFFALSE 44956
// continue ;
44954: GO 44726
// for j in lab do
44956: LD_ADDR_VAR 0 3
44960: PUSH
44961: LD_VAR 0 6
44965: PUSH
44966: FOR_IN
44967: IFFALSE 45132
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
44969: LD_VAR 0 3
44973: PPUSH
44974: CALL_OW 266
44978: PUSH
44979: LD_INT 6
44981: PUSH
44982: LD_INT 7
44984: PUSH
44985: EMPTY
44986: LIST
44987: LIST
44988: IN
44989: PUSH
44990: LD_VAR 0 3
44994: PPUSH
44995: CALL_OW 461
44999: PUSH
45000: LD_INT 1
45002: NONEQUAL
45003: AND
45004: IFFALSE 45130
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45006: LD_VAR 0 3
45010: PPUSH
45011: LD_EXP 133
45015: PUSH
45016: LD_VAR 0 2
45020: ARRAY
45021: PUSH
45022: LD_INT 1
45024: ARRAY
45025: PPUSH
45026: CALL 76317 0 2
45030: IFFALSE 45130
// begin ComCancel ( j ) ;
45032: LD_VAR 0 3
45036: PPUSH
45037: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45041: LD_VAR 0 3
45045: PPUSH
45046: LD_EXP 133
45050: PUSH
45051: LD_VAR 0 2
45055: ARRAY
45056: PUSH
45057: LD_INT 1
45059: ARRAY
45060: PPUSH
45061: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45065: LD_VAR 0 3
45069: PUSH
45070: LD_EXP 106
45074: PUSH
45075: LD_VAR 0 2
45079: ARRAY
45080: IN
45081: NOT
45082: IFFALSE 45128
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45084: LD_ADDR_EXP 106
45088: PUSH
45089: LD_EXP 106
45093: PPUSH
45094: LD_VAR 0 2
45098: PUSH
45099: LD_EXP 106
45103: PUSH
45104: LD_VAR 0 2
45108: ARRAY
45109: PUSH
45110: LD_INT 1
45112: PLUS
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PPUSH
45118: LD_VAR 0 3
45122: PPUSH
45123: CALL 69701 0 3
45127: ST_TO_ADDR
// break ;
45128: GO 45132
// end ; end ; end ;
45130: GO 44966
45132: POP
45133: POP
// end ;
45134: GO 44726
45136: POP
45137: POP
// end ;
45138: LD_VAR 0 1
45142: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45143: LD_INT 0
45145: PPUSH
45146: PPUSH
45147: PPUSH
45148: PPUSH
45149: PPUSH
45150: PPUSH
45151: PPUSH
45152: PPUSH
45153: PPUSH
// if not mc_bases then
45154: LD_EXP 99
45158: NOT
45159: IFFALSE 45163
// exit ;
45161: GO 45568
// for i = 1 to mc_bases do
45163: LD_ADDR_VAR 0 2
45167: PUSH
45168: DOUBLE
45169: LD_INT 1
45171: DEC
45172: ST_TO_ADDR
45173: LD_EXP 99
45177: PUSH
45178: FOR_TO
45179: IFFALSE 45566
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45181: LD_EXP 107
45185: PUSH
45186: LD_VAR 0 2
45190: ARRAY
45191: NOT
45192: PUSH
45193: LD_EXP 99
45197: PUSH
45198: LD_VAR 0 2
45202: ARRAY
45203: PPUSH
45204: LD_INT 30
45206: PUSH
45207: LD_INT 3
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PPUSH
45214: CALL_OW 72
45218: NOT
45219: OR
45220: IFFALSE 45224
// continue ;
45222: GO 45178
// busy := false ;
45224: LD_ADDR_VAR 0 8
45228: PUSH
45229: LD_INT 0
45231: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45232: LD_ADDR_VAR 0 4
45236: PUSH
45237: LD_EXP 99
45241: PUSH
45242: LD_VAR 0 2
45246: ARRAY
45247: PPUSH
45248: LD_INT 30
45250: PUSH
45251: LD_INT 3
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PPUSH
45258: CALL_OW 72
45262: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45263: LD_ADDR_VAR 0 6
45267: PUSH
45268: LD_EXP 107
45272: PUSH
45273: LD_VAR 0 2
45277: ARRAY
45278: PPUSH
45279: LD_INT 2
45281: PUSH
45282: LD_INT 30
45284: PUSH
45285: LD_INT 32
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 30
45294: PUSH
45295: LD_INT 33
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: LIST
45306: PPUSH
45307: CALL_OW 72
45311: ST_TO_ADDR
// if not t then
45312: LD_VAR 0 6
45316: NOT
45317: IFFALSE 45321
// continue ;
45319: GO 45178
// for j in tmp do
45321: LD_ADDR_VAR 0 3
45325: PUSH
45326: LD_VAR 0 4
45330: PUSH
45331: FOR_IN
45332: IFFALSE 45362
// if not BuildingStatus ( j ) = bs_idle then
45334: LD_VAR 0 3
45338: PPUSH
45339: CALL_OW 461
45343: PUSH
45344: LD_INT 2
45346: EQUAL
45347: NOT
45348: IFFALSE 45360
// begin busy := true ;
45350: LD_ADDR_VAR 0 8
45354: PUSH
45355: LD_INT 1
45357: ST_TO_ADDR
// break ;
45358: GO 45362
// end ;
45360: GO 45331
45362: POP
45363: POP
// if busy then
45364: LD_VAR 0 8
45368: IFFALSE 45372
// continue ;
45370: GO 45178
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45372: LD_ADDR_VAR 0 7
45376: PUSH
45377: LD_VAR 0 6
45381: PPUSH
45382: LD_INT 35
45384: PUSH
45385: LD_INT 0
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: PPUSH
45392: CALL_OW 72
45396: ST_TO_ADDR
// if tw then
45397: LD_VAR 0 7
45401: IFFALSE 45478
// begin tw := tw [ 1 ] ;
45403: LD_ADDR_VAR 0 7
45407: PUSH
45408: LD_VAR 0 7
45412: PUSH
45413: LD_INT 1
45415: ARRAY
45416: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45417: LD_ADDR_VAR 0 9
45421: PUSH
45422: LD_VAR 0 7
45426: PPUSH
45427: LD_EXP 124
45431: PUSH
45432: LD_VAR 0 2
45436: ARRAY
45437: PPUSH
45438: CALL 74671 0 2
45442: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45443: LD_EXP 138
45447: PUSH
45448: LD_VAR 0 2
45452: ARRAY
45453: IFFALSE 45476
// if not weapon in mc_allowed_tower_weapons [ i ] then
45455: LD_VAR 0 9
45459: PUSH
45460: LD_EXP 138
45464: PUSH
45465: LD_VAR 0 2
45469: ARRAY
45470: IN
45471: NOT
45472: IFFALSE 45476
// continue ;
45474: GO 45178
// end else
45476: GO 45541
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45478: LD_ADDR_VAR 0 5
45482: PUSH
45483: LD_EXP 107
45487: PUSH
45488: LD_VAR 0 2
45492: ARRAY
45493: PPUSH
45494: LD_VAR 0 4
45498: PPUSH
45499: CALL 104872 0 2
45503: ST_TO_ADDR
// if not tmp2 then
45504: LD_VAR 0 5
45508: NOT
45509: IFFALSE 45513
// continue ;
45511: GO 45178
// tw := tmp2 [ 1 ] ;
45513: LD_ADDR_VAR 0 7
45517: PUSH
45518: LD_VAR 0 5
45522: PUSH
45523: LD_INT 1
45525: ARRAY
45526: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
45527: LD_ADDR_VAR 0 9
45531: PUSH
45532: LD_VAR 0 5
45536: PUSH
45537: LD_INT 2
45539: ARRAY
45540: ST_TO_ADDR
// end ; if not weapon then
45541: LD_VAR 0 9
45545: NOT
45546: IFFALSE 45550
// continue ;
45548: GO 45178
// ComPlaceWeapon ( tw , weapon ) ;
45550: LD_VAR 0 7
45554: PPUSH
45555: LD_VAR 0 9
45559: PPUSH
45560: CALL_OW 148
// end ;
45564: GO 45178
45566: POP
45567: POP
// end ;
45568: LD_VAR 0 1
45572: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
45573: LD_INT 0
45575: PPUSH
45576: PPUSH
45577: PPUSH
45578: PPUSH
45579: PPUSH
45580: PPUSH
// if not mc_bases then
45581: LD_EXP 99
45585: NOT
45586: IFFALSE 45590
// exit ;
45588: GO 46602
// for i = 1 to mc_bases do
45590: LD_ADDR_VAR 0 2
45594: PUSH
45595: DOUBLE
45596: LD_INT 1
45598: DEC
45599: ST_TO_ADDR
45600: LD_EXP 99
45604: PUSH
45605: FOR_TO
45606: IFFALSE 46600
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
45608: LD_EXP 112
45612: PUSH
45613: LD_VAR 0 2
45617: ARRAY
45618: NOT
45619: PUSH
45620: LD_EXP 112
45624: PUSH
45625: LD_VAR 0 2
45629: ARRAY
45630: PUSH
45631: LD_EXP 113
45635: PUSH
45636: LD_VAR 0 2
45640: ARRAY
45641: EQUAL
45642: OR
45643: IFFALSE 45647
// continue ;
45645: GO 45605
// if mc_miners [ i ] then
45647: LD_EXP 113
45651: PUSH
45652: LD_VAR 0 2
45656: ARRAY
45657: IFFALSE 46287
// begin k := 1 ;
45659: LD_ADDR_VAR 0 4
45663: PUSH
45664: LD_INT 1
45666: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
45667: LD_ADDR_VAR 0 3
45671: PUSH
45672: DOUBLE
45673: LD_EXP 113
45677: PUSH
45678: LD_VAR 0 2
45682: ARRAY
45683: INC
45684: ST_TO_ADDR
45685: LD_INT 1
45687: PUSH
45688: FOR_DOWNTO
45689: IFFALSE 46285
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
45691: LD_EXP 113
45695: PUSH
45696: LD_VAR 0 2
45700: ARRAY
45701: PUSH
45702: LD_VAR 0 3
45706: ARRAY
45707: PPUSH
45708: CALL_OW 301
45712: PUSH
45713: LD_EXP 113
45717: PUSH
45718: LD_VAR 0 2
45722: ARRAY
45723: PUSH
45724: LD_VAR 0 3
45728: ARRAY
45729: PPUSH
45730: CALL_OW 257
45734: PUSH
45735: LD_INT 1
45737: NONEQUAL
45738: OR
45739: IFFALSE 45802
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
45741: LD_ADDR_VAR 0 5
45745: PUSH
45746: LD_EXP 113
45750: PUSH
45751: LD_VAR 0 2
45755: ARRAY
45756: PUSH
45757: LD_EXP 113
45761: PUSH
45762: LD_VAR 0 2
45766: ARRAY
45767: PUSH
45768: LD_VAR 0 3
45772: ARRAY
45773: DIFF
45774: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
45775: LD_ADDR_EXP 113
45779: PUSH
45780: LD_EXP 113
45784: PPUSH
45785: LD_VAR 0 2
45789: PPUSH
45790: LD_VAR 0 5
45794: PPUSH
45795: CALL_OW 1
45799: ST_TO_ADDR
// continue ;
45800: GO 45688
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
45802: LD_EXP 113
45806: PUSH
45807: LD_VAR 0 2
45811: ARRAY
45812: PUSH
45813: LD_VAR 0 3
45817: ARRAY
45818: PPUSH
45819: CALL 69637 0 1
45823: PUSH
45824: LD_EXP 113
45828: PUSH
45829: LD_VAR 0 2
45833: ARRAY
45834: PUSH
45835: LD_VAR 0 3
45839: ARRAY
45840: PPUSH
45841: CALL_OW 255
45845: PPUSH
45846: LD_EXP 112
45850: PUSH
45851: LD_VAR 0 2
45855: ARRAY
45856: PUSH
45857: LD_VAR 0 4
45861: ARRAY
45862: PUSH
45863: LD_INT 1
45865: ARRAY
45866: PPUSH
45867: LD_EXP 112
45871: PUSH
45872: LD_VAR 0 2
45876: ARRAY
45877: PUSH
45878: LD_VAR 0 4
45882: ARRAY
45883: PUSH
45884: LD_INT 2
45886: ARRAY
45887: PPUSH
45888: LD_INT 15
45890: PPUSH
45891: CALL 70597 0 4
45895: PUSH
45896: LD_INT 4
45898: ARRAY
45899: PUSH
45900: LD_EXP 113
45904: PUSH
45905: LD_VAR 0 2
45909: ARRAY
45910: PUSH
45911: LD_VAR 0 3
45915: ARRAY
45916: PPUSH
45917: LD_INT 10
45919: PPUSH
45920: CALL 72294 0 2
45924: PUSH
45925: LD_INT 4
45927: ARRAY
45928: OR
45929: AND
45930: IFFALSE 45953
// ComStop ( mc_miners [ i ] [ j ] ) ;
45932: LD_EXP 113
45936: PUSH
45937: LD_VAR 0 2
45941: ARRAY
45942: PUSH
45943: LD_VAR 0 3
45947: ARRAY
45948: PPUSH
45949: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
45953: LD_EXP 113
45957: PUSH
45958: LD_VAR 0 2
45962: ARRAY
45963: PUSH
45964: LD_VAR 0 3
45968: ARRAY
45969: PPUSH
45970: CALL_OW 257
45974: PUSH
45975: LD_INT 1
45977: EQUAL
45978: PUSH
45979: LD_EXP 113
45983: PUSH
45984: LD_VAR 0 2
45988: ARRAY
45989: PUSH
45990: LD_VAR 0 3
45994: ARRAY
45995: PPUSH
45996: CALL_OW 459
46000: NOT
46001: AND
46002: PUSH
46003: LD_EXP 113
46007: PUSH
46008: LD_VAR 0 2
46012: ARRAY
46013: PUSH
46014: LD_VAR 0 3
46018: ARRAY
46019: PPUSH
46020: CALL_OW 255
46024: PPUSH
46025: LD_EXP 112
46029: PUSH
46030: LD_VAR 0 2
46034: ARRAY
46035: PUSH
46036: LD_VAR 0 4
46040: ARRAY
46041: PUSH
46042: LD_INT 1
46044: ARRAY
46045: PPUSH
46046: LD_EXP 112
46050: PUSH
46051: LD_VAR 0 2
46055: ARRAY
46056: PUSH
46057: LD_VAR 0 4
46061: ARRAY
46062: PUSH
46063: LD_INT 2
46065: ARRAY
46066: PPUSH
46067: LD_INT 15
46069: PPUSH
46070: CALL 70597 0 4
46074: PUSH
46075: LD_INT 4
46077: ARRAY
46078: PUSH
46079: LD_INT 0
46081: EQUAL
46082: AND
46083: PUSH
46084: LD_EXP 113
46088: PUSH
46089: LD_VAR 0 2
46093: ARRAY
46094: PUSH
46095: LD_VAR 0 3
46099: ARRAY
46100: PPUSH
46101: CALL_OW 314
46105: NOT
46106: AND
46107: IFFALSE 46283
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46109: LD_EXP 113
46113: PUSH
46114: LD_VAR 0 2
46118: ARRAY
46119: PUSH
46120: LD_VAR 0 3
46124: ARRAY
46125: PPUSH
46126: CALL_OW 310
46130: IFFALSE 46153
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46132: LD_EXP 113
46136: PUSH
46137: LD_VAR 0 2
46141: ARRAY
46142: PUSH
46143: LD_VAR 0 3
46147: ARRAY
46148: PPUSH
46149: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46153: LD_EXP 113
46157: PUSH
46158: LD_VAR 0 2
46162: ARRAY
46163: PUSH
46164: LD_VAR 0 3
46168: ARRAY
46169: PPUSH
46170: CALL_OW 314
46174: NOT
46175: IFFALSE 46243
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46177: LD_EXP 113
46181: PUSH
46182: LD_VAR 0 2
46186: ARRAY
46187: PUSH
46188: LD_VAR 0 3
46192: ARRAY
46193: PPUSH
46194: LD_EXP 112
46198: PUSH
46199: LD_VAR 0 2
46203: ARRAY
46204: PUSH
46205: LD_VAR 0 4
46209: ARRAY
46210: PUSH
46211: LD_INT 1
46213: ARRAY
46214: PPUSH
46215: LD_EXP 112
46219: PUSH
46220: LD_VAR 0 2
46224: ARRAY
46225: PUSH
46226: LD_VAR 0 4
46230: ARRAY
46231: PUSH
46232: LD_INT 2
46234: ARRAY
46235: PPUSH
46236: LD_INT 0
46238: PPUSH
46239: CALL_OW 193
// k := k + 1 ;
46243: LD_ADDR_VAR 0 4
46247: PUSH
46248: LD_VAR 0 4
46252: PUSH
46253: LD_INT 1
46255: PLUS
46256: ST_TO_ADDR
// if k > mc_mines [ i ] then
46257: LD_VAR 0 4
46261: PUSH
46262: LD_EXP 112
46266: PUSH
46267: LD_VAR 0 2
46271: ARRAY
46272: GREATER
46273: IFFALSE 46283
// k := 1 ;
46275: LD_ADDR_VAR 0 4
46279: PUSH
46280: LD_INT 1
46282: ST_TO_ADDR
// end ; end ;
46283: GO 45688
46285: POP
46286: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46287: LD_ADDR_VAR 0 5
46291: PUSH
46292: LD_EXP 99
46296: PUSH
46297: LD_VAR 0 2
46301: ARRAY
46302: PPUSH
46303: LD_INT 2
46305: PUSH
46306: LD_INT 30
46308: PUSH
46309: LD_INT 4
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: LD_INT 30
46318: PUSH
46319: LD_INT 5
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: PUSH
46326: LD_INT 30
46328: PUSH
46329: LD_INT 32
46331: PUSH
46332: EMPTY
46333: LIST
46334: LIST
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: LIST
46340: LIST
46341: PPUSH
46342: CALL_OW 72
46346: ST_TO_ADDR
// if not tmp then
46347: LD_VAR 0 5
46351: NOT
46352: IFFALSE 46356
// continue ;
46354: GO 45605
// list := [ ] ;
46356: LD_ADDR_VAR 0 6
46360: PUSH
46361: EMPTY
46362: ST_TO_ADDR
// for j in tmp do
46363: LD_ADDR_VAR 0 3
46367: PUSH
46368: LD_VAR 0 5
46372: PUSH
46373: FOR_IN
46374: IFFALSE 46443
// begin for k in UnitsInside ( j ) do
46376: LD_ADDR_VAR 0 4
46380: PUSH
46381: LD_VAR 0 3
46385: PPUSH
46386: CALL_OW 313
46390: PUSH
46391: FOR_IN
46392: IFFALSE 46439
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46394: LD_VAR 0 4
46398: PPUSH
46399: CALL_OW 257
46403: PUSH
46404: LD_INT 1
46406: EQUAL
46407: PUSH
46408: LD_VAR 0 4
46412: PPUSH
46413: CALL_OW 459
46417: NOT
46418: AND
46419: IFFALSE 46437
// list := list ^ k ;
46421: LD_ADDR_VAR 0 6
46425: PUSH
46426: LD_VAR 0 6
46430: PUSH
46431: LD_VAR 0 4
46435: ADD
46436: ST_TO_ADDR
46437: GO 46391
46439: POP
46440: POP
// end ;
46441: GO 46373
46443: POP
46444: POP
// list := list diff mc_miners [ i ] ;
46445: LD_ADDR_VAR 0 6
46449: PUSH
46450: LD_VAR 0 6
46454: PUSH
46455: LD_EXP 113
46459: PUSH
46460: LD_VAR 0 2
46464: ARRAY
46465: DIFF
46466: ST_TO_ADDR
// if not list then
46467: LD_VAR 0 6
46471: NOT
46472: IFFALSE 46476
// continue ;
46474: GO 45605
// k := mc_mines [ i ] - mc_miners [ i ] ;
46476: LD_ADDR_VAR 0 4
46480: PUSH
46481: LD_EXP 112
46485: PUSH
46486: LD_VAR 0 2
46490: ARRAY
46491: PUSH
46492: LD_EXP 113
46496: PUSH
46497: LD_VAR 0 2
46501: ARRAY
46502: MINUS
46503: ST_TO_ADDR
// if k > list then
46504: LD_VAR 0 4
46508: PUSH
46509: LD_VAR 0 6
46513: GREATER
46514: IFFALSE 46526
// k := list ;
46516: LD_ADDR_VAR 0 4
46520: PUSH
46521: LD_VAR 0 6
46525: ST_TO_ADDR
// for j = 1 to k do
46526: LD_ADDR_VAR 0 3
46530: PUSH
46531: DOUBLE
46532: LD_INT 1
46534: DEC
46535: ST_TO_ADDR
46536: LD_VAR 0 4
46540: PUSH
46541: FOR_TO
46542: IFFALSE 46596
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
46544: LD_ADDR_EXP 113
46548: PUSH
46549: LD_EXP 113
46553: PPUSH
46554: LD_VAR 0 2
46558: PUSH
46559: LD_EXP 113
46563: PUSH
46564: LD_VAR 0 2
46568: ARRAY
46569: PUSH
46570: LD_INT 1
46572: PLUS
46573: PUSH
46574: EMPTY
46575: LIST
46576: LIST
46577: PPUSH
46578: LD_VAR 0 6
46582: PUSH
46583: LD_VAR 0 3
46587: ARRAY
46588: PPUSH
46589: CALL 69701 0 3
46593: ST_TO_ADDR
46594: GO 46541
46596: POP
46597: POP
// end ;
46598: GO 45605
46600: POP
46601: POP
// end ;
46602: LD_VAR 0 1
46606: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
46607: LD_INT 0
46609: PPUSH
46610: PPUSH
46611: PPUSH
46612: PPUSH
46613: PPUSH
46614: PPUSH
46615: PPUSH
46616: PPUSH
46617: PPUSH
46618: PPUSH
// if not mc_bases then
46619: LD_EXP 99
46623: NOT
46624: IFFALSE 46628
// exit ;
46626: GO 48359
// for i = 1 to mc_bases do
46628: LD_ADDR_VAR 0 2
46632: PUSH
46633: DOUBLE
46634: LD_INT 1
46636: DEC
46637: ST_TO_ADDR
46638: LD_EXP 99
46642: PUSH
46643: FOR_TO
46644: IFFALSE 48357
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
46646: LD_EXP 99
46650: PUSH
46651: LD_VAR 0 2
46655: ARRAY
46656: NOT
46657: PUSH
46658: LD_EXP 106
46662: PUSH
46663: LD_VAR 0 2
46667: ARRAY
46668: OR
46669: IFFALSE 46673
// continue ;
46671: GO 46643
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
46673: LD_EXP 115
46677: PUSH
46678: LD_VAR 0 2
46682: ARRAY
46683: NOT
46684: PUSH
46685: LD_EXP 116
46689: PUSH
46690: LD_VAR 0 2
46694: ARRAY
46695: AND
46696: IFFALSE 46734
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
46698: LD_ADDR_EXP 116
46702: PUSH
46703: LD_EXP 116
46707: PPUSH
46708: LD_VAR 0 2
46712: PPUSH
46713: EMPTY
46714: PPUSH
46715: CALL_OW 1
46719: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
46720: LD_VAR 0 2
46724: PPUSH
46725: LD_INT 107
46727: PPUSH
46728: CALL 37823 0 2
// continue ;
46732: GO 46643
// end ; target := [ ] ;
46734: LD_ADDR_VAR 0 6
46738: PUSH
46739: EMPTY
46740: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
46741: LD_ADDR_VAR 0 3
46745: PUSH
46746: DOUBLE
46747: LD_EXP 115
46751: PUSH
46752: LD_VAR 0 2
46756: ARRAY
46757: INC
46758: ST_TO_ADDR
46759: LD_INT 1
46761: PUSH
46762: FOR_DOWNTO
46763: IFFALSE 47023
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
46765: LD_EXP 115
46769: PUSH
46770: LD_VAR 0 2
46774: ARRAY
46775: PUSH
46776: LD_VAR 0 3
46780: ARRAY
46781: PUSH
46782: LD_INT 2
46784: ARRAY
46785: PPUSH
46786: LD_EXP 115
46790: PUSH
46791: LD_VAR 0 2
46795: ARRAY
46796: PUSH
46797: LD_VAR 0 3
46801: ARRAY
46802: PUSH
46803: LD_INT 3
46805: ARRAY
46806: PPUSH
46807: CALL_OW 488
46811: PUSH
46812: LD_EXP 115
46816: PUSH
46817: LD_VAR 0 2
46821: ARRAY
46822: PUSH
46823: LD_VAR 0 3
46827: ARRAY
46828: PUSH
46829: LD_INT 2
46831: ARRAY
46832: PPUSH
46833: LD_EXP 115
46837: PUSH
46838: LD_VAR 0 2
46842: ARRAY
46843: PUSH
46844: LD_VAR 0 3
46848: ARRAY
46849: PUSH
46850: LD_INT 3
46852: ARRAY
46853: PPUSH
46854: CALL_OW 284
46858: PUSH
46859: LD_INT 0
46861: EQUAL
46862: AND
46863: IFFALSE 46918
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
46865: LD_ADDR_VAR 0 5
46869: PUSH
46870: LD_EXP 115
46874: PUSH
46875: LD_VAR 0 2
46879: ARRAY
46880: PPUSH
46881: LD_VAR 0 3
46885: PPUSH
46886: CALL_OW 3
46890: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
46891: LD_ADDR_EXP 115
46895: PUSH
46896: LD_EXP 115
46900: PPUSH
46901: LD_VAR 0 2
46905: PPUSH
46906: LD_VAR 0 5
46910: PPUSH
46911: CALL_OW 1
46915: ST_TO_ADDR
// continue ;
46916: GO 46762
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
46918: LD_EXP 99
46922: PUSH
46923: LD_VAR 0 2
46927: ARRAY
46928: PUSH
46929: LD_INT 1
46931: ARRAY
46932: PPUSH
46933: CALL_OW 255
46937: PPUSH
46938: LD_EXP 115
46942: PUSH
46943: LD_VAR 0 2
46947: ARRAY
46948: PUSH
46949: LD_VAR 0 3
46953: ARRAY
46954: PUSH
46955: LD_INT 2
46957: ARRAY
46958: PPUSH
46959: LD_EXP 115
46963: PUSH
46964: LD_VAR 0 2
46968: ARRAY
46969: PUSH
46970: LD_VAR 0 3
46974: ARRAY
46975: PUSH
46976: LD_INT 3
46978: ARRAY
46979: PPUSH
46980: LD_INT 30
46982: PPUSH
46983: CALL 70597 0 4
46987: PUSH
46988: LD_INT 4
46990: ARRAY
46991: PUSH
46992: LD_INT 0
46994: EQUAL
46995: IFFALSE 47021
// begin target := mc_crates [ i ] [ j ] ;
46997: LD_ADDR_VAR 0 6
47001: PUSH
47002: LD_EXP 115
47006: PUSH
47007: LD_VAR 0 2
47011: ARRAY
47012: PUSH
47013: LD_VAR 0 3
47017: ARRAY
47018: ST_TO_ADDR
// break ;
47019: GO 47023
// end ; end ;
47021: GO 46762
47023: POP
47024: POP
// if not target then
47025: LD_VAR 0 6
47029: NOT
47030: IFFALSE 47034
// continue ;
47032: GO 46643
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47034: LD_ADDR_VAR 0 7
47038: PUSH
47039: LD_EXP 118
47043: PUSH
47044: LD_VAR 0 2
47048: ARRAY
47049: PPUSH
47050: LD_INT 2
47052: PUSH
47053: LD_INT 3
47055: PUSH
47056: LD_INT 58
47058: PUSH
47059: EMPTY
47060: LIST
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 61
47068: PUSH
47069: EMPTY
47070: LIST
47071: PUSH
47072: LD_INT 33
47074: PUSH
47075: LD_INT 5
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PUSH
47082: LD_INT 33
47084: PUSH
47085: LD_INT 3
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PUSH
47092: EMPTY
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: PUSH
47099: LD_INT 2
47101: PUSH
47102: LD_INT 34
47104: PUSH
47105: LD_INT 32
47107: PUSH
47108: EMPTY
47109: LIST
47110: LIST
47111: PUSH
47112: LD_INT 34
47114: PUSH
47115: LD_INT 51
47117: PUSH
47118: EMPTY
47119: LIST
47120: LIST
47121: PUSH
47122: LD_INT 34
47124: PUSH
47125: LD_INT 12
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: EMPTY
47133: LIST
47134: LIST
47135: LIST
47136: LIST
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PPUSH
47142: CALL_OW 72
47146: ST_TO_ADDR
// if not cargo then
47147: LD_VAR 0 7
47151: NOT
47152: IFFALSE 47795
// begin if mc_crates_collector [ i ] < 5 then
47154: LD_EXP 116
47158: PUSH
47159: LD_VAR 0 2
47163: ARRAY
47164: PUSH
47165: LD_INT 5
47167: LESS
47168: IFFALSE 47534
// begin if mc_ape [ i ] then
47170: LD_EXP 128
47174: PUSH
47175: LD_VAR 0 2
47179: ARRAY
47180: IFFALSE 47227
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47182: LD_ADDR_VAR 0 5
47186: PUSH
47187: LD_EXP 128
47191: PUSH
47192: LD_VAR 0 2
47196: ARRAY
47197: PPUSH
47198: LD_INT 25
47200: PUSH
47201: LD_INT 16
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 24
47210: PUSH
47211: LD_INT 750
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PPUSH
47222: CALL_OW 72
47226: ST_TO_ADDR
// if not tmp then
47227: LD_VAR 0 5
47231: NOT
47232: IFFALSE 47279
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47234: LD_ADDR_VAR 0 5
47238: PUSH
47239: LD_EXP 99
47243: PUSH
47244: LD_VAR 0 2
47248: ARRAY
47249: PPUSH
47250: LD_INT 25
47252: PUSH
47253: LD_INT 2
47255: PUSH
47256: EMPTY
47257: LIST
47258: LIST
47259: PUSH
47260: LD_INT 24
47262: PUSH
47263: LD_INT 750
47265: PUSH
47266: EMPTY
47267: LIST
47268: LIST
47269: PUSH
47270: EMPTY
47271: LIST
47272: LIST
47273: PPUSH
47274: CALL_OW 72
47278: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47279: LD_EXP 128
47283: PUSH
47284: LD_VAR 0 2
47288: ARRAY
47289: PUSH
47290: LD_EXP 99
47294: PUSH
47295: LD_VAR 0 2
47299: ARRAY
47300: PPUSH
47301: LD_INT 25
47303: PUSH
47304: LD_INT 2
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 24
47313: PUSH
47314: LD_INT 750
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: PPUSH
47325: CALL_OW 72
47329: AND
47330: PUSH
47331: LD_VAR 0 5
47335: PUSH
47336: LD_INT 5
47338: LESS
47339: AND
47340: IFFALSE 47422
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47342: LD_ADDR_VAR 0 3
47346: PUSH
47347: LD_EXP 99
47351: PUSH
47352: LD_VAR 0 2
47356: ARRAY
47357: PPUSH
47358: LD_INT 25
47360: PUSH
47361: LD_INT 2
47363: PUSH
47364: EMPTY
47365: LIST
47366: LIST
47367: PUSH
47368: LD_INT 24
47370: PUSH
47371: LD_INT 750
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: PPUSH
47382: CALL_OW 72
47386: PUSH
47387: FOR_IN
47388: IFFALSE 47420
// begin tmp := tmp union j ;
47390: LD_ADDR_VAR 0 5
47394: PUSH
47395: LD_VAR 0 5
47399: PUSH
47400: LD_VAR 0 3
47404: UNION
47405: ST_TO_ADDR
// if tmp >= 5 then
47406: LD_VAR 0 5
47410: PUSH
47411: LD_INT 5
47413: GREATEREQUAL
47414: IFFALSE 47418
// break ;
47416: GO 47420
// end ;
47418: GO 47387
47420: POP
47421: POP
// end ; if not tmp then
47422: LD_VAR 0 5
47426: NOT
47427: IFFALSE 47431
// continue ;
47429: GO 46643
// for j in tmp do
47431: LD_ADDR_VAR 0 3
47435: PUSH
47436: LD_VAR 0 5
47440: PUSH
47441: FOR_IN
47442: IFFALSE 47532
// if not GetTag ( j ) then
47444: LD_VAR 0 3
47448: PPUSH
47449: CALL_OW 110
47453: NOT
47454: IFFALSE 47530
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47456: LD_ADDR_EXP 116
47460: PUSH
47461: LD_EXP 116
47465: PPUSH
47466: LD_VAR 0 2
47470: PUSH
47471: LD_EXP 116
47475: PUSH
47476: LD_VAR 0 2
47480: ARRAY
47481: PUSH
47482: LD_INT 1
47484: PLUS
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PPUSH
47490: LD_VAR 0 3
47494: PPUSH
47495: CALL 69701 0 3
47499: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47500: LD_VAR 0 3
47504: PPUSH
47505: LD_INT 107
47507: PPUSH
47508: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
47512: LD_EXP 116
47516: PUSH
47517: LD_VAR 0 2
47521: ARRAY
47522: PUSH
47523: LD_INT 5
47525: GREATEREQUAL
47526: IFFALSE 47530
// break ;
47528: GO 47532
// end ;
47530: GO 47441
47532: POP
47533: POP
// end ; if mc_crates_collector [ i ] and target then
47534: LD_EXP 116
47538: PUSH
47539: LD_VAR 0 2
47543: ARRAY
47544: PUSH
47545: LD_VAR 0 6
47549: AND
47550: IFFALSE 47793
// begin if mc_crates_collector [ i ] < target [ 1 ] then
47552: LD_EXP 116
47556: PUSH
47557: LD_VAR 0 2
47561: ARRAY
47562: PUSH
47563: LD_VAR 0 6
47567: PUSH
47568: LD_INT 1
47570: ARRAY
47571: LESS
47572: IFFALSE 47592
// tmp := mc_crates_collector [ i ] else
47574: LD_ADDR_VAR 0 5
47578: PUSH
47579: LD_EXP 116
47583: PUSH
47584: LD_VAR 0 2
47588: ARRAY
47589: ST_TO_ADDR
47590: GO 47606
// tmp := target [ 1 ] ;
47592: LD_ADDR_VAR 0 5
47596: PUSH
47597: LD_VAR 0 6
47601: PUSH
47602: LD_INT 1
47604: ARRAY
47605: ST_TO_ADDR
// k := 0 ;
47606: LD_ADDR_VAR 0 4
47610: PUSH
47611: LD_INT 0
47613: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
47614: LD_ADDR_VAR 0 3
47618: PUSH
47619: LD_EXP 116
47623: PUSH
47624: LD_VAR 0 2
47628: ARRAY
47629: PUSH
47630: FOR_IN
47631: IFFALSE 47791
// begin k := k + 1 ;
47633: LD_ADDR_VAR 0 4
47637: PUSH
47638: LD_VAR 0 4
47642: PUSH
47643: LD_INT 1
47645: PLUS
47646: ST_TO_ADDR
// if k > tmp then
47647: LD_VAR 0 4
47651: PUSH
47652: LD_VAR 0 5
47656: GREATER
47657: IFFALSE 47661
// break ;
47659: GO 47791
// if not GetClass ( j ) in [ 2 , 16 ] then
47661: LD_VAR 0 3
47665: PPUSH
47666: CALL_OW 257
47670: PUSH
47671: LD_INT 2
47673: PUSH
47674: LD_INT 16
47676: PUSH
47677: EMPTY
47678: LIST
47679: LIST
47680: IN
47681: NOT
47682: IFFALSE 47735
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
47684: LD_ADDR_EXP 116
47688: PUSH
47689: LD_EXP 116
47693: PPUSH
47694: LD_VAR 0 2
47698: PPUSH
47699: LD_EXP 116
47703: PUSH
47704: LD_VAR 0 2
47708: ARRAY
47709: PUSH
47710: LD_VAR 0 3
47714: DIFF
47715: PPUSH
47716: CALL_OW 1
47720: ST_TO_ADDR
// SetTag ( j , 0 ) ;
47721: LD_VAR 0 3
47725: PPUSH
47726: LD_INT 0
47728: PPUSH
47729: CALL_OW 109
// continue ;
47733: GO 47630
// end ; if IsInUnit ( j ) then
47735: LD_VAR 0 3
47739: PPUSH
47740: CALL_OW 310
47744: IFFALSE 47755
// ComExitBuilding ( j ) ;
47746: LD_VAR 0 3
47750: PPUSH
47751: CALL_OW 122
// wait ( 3 ) ;
47755: LD_INT 3
47757: PPUSH
47758: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
47762: LD_VAR 0 3
47766: PPUSH
47767: LD_VAR 0 6
47771: PUSH
47772: LD_INT 2
47774: ARRAY
47775: PPUSH
47776: LD_VAR 0 6
47780: PUSH
47781: LD_INT 3
47783: ARRAY
47784: PPUSH
47785: CALL_OW 117
// end ;
47789: GO 47630
47791: POP
47792: POP
// end ; end else
47793: GO 48355
// begin for j in cargo do
47795: LD_ADDR_VAR 0 3
47799: PUSH
47800: LD_VAR 0 7
47804: PUSH
47805: FOR_IN
47806: IFFALSE 48353
// begin if GetTag ( j ) <> 0 then
47808: LD_VAR 0 3
47812: PPUSH
47813: CALL_OW 110
47817: PUSH
47818: LD_INT 0
47820: NONEQUAL
47821: IFFALSE 47825
// continue ;
47823: GO 47805
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
47825: LD_VAR 0 3
47829: PPUSH
47830: CALL_OW 256
47834: PUSH
47835: LD_INT 1000
47837: LESS
47838: PUSH
47839: LD_VAR 0 3
47843: PPUSH
47844: LD_EXP 123
47848: PUSH
47849: LD_VAR 0 2
47853: ARRAY
47854: PPUSH
47855: CALL_OW 308
47859: NOT
47860: AND
47861: IFFALSE 47883
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47863: LD_VAR 0 3
47867: PPUSH
47868: LD_EXP 123
47872: PUSH
47873: LD_VAR 0 2
47877: ARRAY
47878: PPUSH
47879: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
47883: LD_VAR 0 3
47887: PPUSH
47888: CALL_OW 256
47892: PUSH
47893: LD_INT 1000
47895: LESS
47896: PUSH
47897: LD_VAR 0 3
47901: PPUSH
47902: LD_EXP 123
47906: PUSH
47907: LD_VAR 0 2
47911: ARRAY
47912: PPUSH
47913: CALL_OW 308
47917: AND
47918: IFFALSE 47922
// continue ;
47920: GO 47805
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
47922: LD_VAR 0 3
47926: PPUSH
47927: CALL_OW 262
47931: PUSH
47932: LD_INT 2
47934: EQUAL
47935: PUSH
47936: LD_VAR 0 3
47940: PPUSH
47941: CALL_OW 261
47945: PUSH
47946: LD_INT 15
47948: LESS
47949: AND
47950: IFFALSE 47954
// continue ;
47952: GO 47805
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
47954: LD_VAR 0 3
47958: PPUSH
47959: CALL_OW 262
47963: PUSH
47964: LD_INT 1
47966: EQUAL
47967: PUSH
47968: LD_VAR 0 3
47972: PPUSH
47973: CALL_OW 261
47977: PUSH
47978: LD_INT 10
47980: LESS
47981: AND
47982: IFFALSE 48292
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47984: LD_ADDR_VAR 0 8
47988: PUSH
47989: LD_EXP 99
47993: PUSH
47994: LD_VAR 0 2
47998: ARRAY
47999: PPUSH
48000: LD_INT 2
48002: PUSH
48003: LD_INT 30
48005: PUSH
48006: LD_INT 0
48008: PUSH
48009: EMPTY
48010: LIST
48011: LIST
48012: PUSH
48013: LD_INT 30
48015: PUSH
48016: LD_INT 1
48018: PUSH
48019: EMPTY
48020: LIST
48021: LIST
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: LIST
48027: PPUSH
48028: CALL_OW 72
48032: ST_TO_ADDR
// if not depot then
48033: LD_VAR 0 8
48037: NOT
48038: IFFALSE 48042
// continue ;
48040: GO 47805
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48042: LD_VAR 0 3
48046: PPUSH
48047: LD_VAR 0 8
48051: PPUSH
48052: LD_VAR 0 3
48056: PPUSH
48057: CALL_OW 74
48061: PPUSH
48062: CALL_OW 296
48066: PUSH
48067: LD_INT 6
48069: LESS
48070: IFFALSE 48086
// SetFuel ( j , 100 ) else
48072: LD_VAR 0 3
48076: PPUSH
48077: LD_INT 100
48079: PPUSH
48080: CALL_OW 240
48084: GO 48292
// if GetFuel ( j ) = 0 then
48086: LD_VAR 0 3
48090: PPUSH
48091: CALL_OW 261
48095: PUSH
48096: LD_INT 0
48098: EQUAL
48099: IFFALSE 48292
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48101: LD_ADDR_EXP 118
48105: PUSH
48106: LD_EXP 118
48110: PPUSH
48111: LD_VAR 0 2
48115: PPUSH
48116: LD_EXP 118
48120: PUSH
48121: LD_VAR 0 2
48125: ARRAY
48126: PUSH
48127: LD_VAR 0 3
48131: DIFF
48132: PPUSH
48133: CALL_OW 1
48137: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48138: LD_VAR 0 3
48142: PPUSH
48143: CALL_OW 263
48147: PUSH
48148: LD_INT 1
48150: EQUAL
48151: IFFALSE 48167
// ComExitVehicle ( IsInUnit ( j ) ) ;
48153: LD_VAR 0 3
48157: PPUSH
48158: CALL_OW 310
48162: PPUSH
48163: CALL_OW 121
// if GetControl ( j ) = control_remote then
48167: LD_VAR 0 3
48171: PPUSH
48172: CALL_OW 263
48176: PUSH
48177: LD_INT 2
48179: EQUAL
48180: IFFALSE 48191
// ComUnlink ( j ) ;
48182: LD_VAR 0 3
48186: PPUSH
48187: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
48191: LD_ADDR_VAR 0 9
48195: PUSH
48196: LD_VAR 0 2
48200: PPUSH
48201: LD_INT 3
48203: PPUSH
48204: CALL 57338 0 2
48208: ST_TO_ADDR
// if fac then
48209: LD_VAR 0 9
48213: IFFALSE 48290
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48215: LD_ADDR_VAR 0 10
48219: PUSH
48220: LD_VAR 0 9
48224: PPUSH
48225: LD_VAR 0 3
48229: PPUSH
48230: CALL_OW 265
48234: PPUSH
48235: LD_VAR 0 3
48239: PPUSH
48240: CALL_OW 262
48244: PPUSH
48245: LD_VAR 0 3
48249: PPUSH
48250: CALL_OW 263
48254: PPUSH
48255: LD_VAR 0 3
48259: PPUSH
48260: CALL_OW 264
48264: PPUSH
48265: CALL 67294 0 5
48269: ST_TO_ADDR
// if components then
48270: LD_VAR 0 10
48274: IFFALSE 48290
// MC_InsertProduceList ( i , components ) ;
48276: LD_VAR 0 2
48280: PPUSH
48281: LD_VAR 0 10
48285: PPUSH
48286: CALL 56966 0 2
// end ; continue ;
48290: GO 47805
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48292: LD_VAR 0 3
48296: PPUSH
48297: LD_INT 1
48299: PPUSH
48300: CALL_OW 289
48304: PUSH
48305: LD_INT 100
48307: LESS
48308: PUSH
48309: LD_VAR 0 3
48313: PPUSH
48314: CALL_OW 314
48318: NOT
48319: AND
48320: IFFALSE 48349
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48322: LD_VAR 0 3
48326: PPUSH
48327: LD_VAR 0 6
48331: PUSH
48332: LD_INT 2
48334: ARRAY
48335: PPUSH
48336: LD_VAR 0 6
48340: PUSH
48341: LD_INT 3
48343: ARRAY
48344: PPUSH
48345: CALL_OW 117
// break ;
48349: GO 48353
// end ;
48351: GO 47805
48353: POP
48354: POP
// end ; end ;
48355: GO 46643
48357: POP
48358: POP
// end ;
48359: LD_VAR 0 1
48363: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48364: LD_INT 0
48366: PPUSH
48367: PPUSH
48368: PPUSH
48369: PPUSH
// if not mc_bases then
48370: LD_EXP 99
48374: NOT
48375: IFFALSE 48379
// exit ;
48377: GO 48540
// for i = 1 to mc_bases do
48379: LD_ADDR_VAR 0 2
48383: PUSH
48384: DOUBLE
48385: LD_INT 1
48387: DEC
48388: ST_TO_ADDR
48389: LD_EXP 99
48393: PUSH
48394: FOR_TO
48395: IFFALSE 48538
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48397: LD_ADDR_VAR 0 4
48401: PUSH
48402: LD_EXP 118
48406: PUSH
48407: LD_VAR 0 2
48411: ARRAY
48412: PUSH
48413: LD_EXP 121
48417: PUSH
48418: LD_VAR 0 2
48422: ARRAY
48423: UNION
48424: PPUSH
48425: LD_INT 33
48427: PUSH
48428: LD_INT 2
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PPUSH
48435: CALL_OW 72
48439: ST_TO_ADDR
// if tmp then
48440: LD_VAR 0 4
48444: IFFALSE 48536
// for j in tmp do
48446: LD_ADDR_VAR 0 3
48450: PUSH
48451: LD_VAR 0 4
48455: PUSH
48456: FOR_IN
48457: IFFALSE 48534
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48459: LD_VAR 0 3
48463: PPUSH
48464: CALL_OW 312
48468: NOT
48469: PUSH
48470: LD_VAR 0 3
48474: PPUSH
48475: CALL_OW 256
48479: PUSH
48480: LD_INT 250
48482: GREATEREQUAL
48483: AND
48484: IFFALSE 48497
// Connect ( j ) else
48486: LD_VAR 0 3
48490: PPUSH
48491: CALL 72634 0 1
48495: GO 48532
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
48497: LD_VAR 0 3
48501: PPUSH
48502: CALL_OW 256
48506: PUSH
48507: LD_INT 250
48509: LESS
48510: PUSH
48511: LD_VAR 0 3
48515: PPUSH
48516: CALL_OW 312
48520: AND
48521: IFFALSE 48532
// ComUnlink ( j ) ;
48523: LD_VAR 0 3
48527: PPUSH
48528: CALL_OW 136
48532: GO 48456
48534: POP
48535: POP
// end ;
48536: GO 48394
48538: POP
48539: POP
// end ;
48540: LD_VAR 0 1
48544: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
48545: LD_INT 0
48547: PPUSH
48548: PPUSH
48549: PPUSH
48550: PPUSH
48551: PPUSH
// if not mc_bases then
48552: LD_EXP 99
48556: NOT
48557: IFFALSE 48561
// exit ;
48559: GO 49021
// for i = 1 to mc_bases do
48561: LD_ADDR_VAR 0 2
48565: PUSH
48566: DOUBLE
48567: LD_INT 1
48569: DEC
48570: ST_TO_ADDR
48571: LD_EXP 99
48575: PUSH
48576: FOR_TO
48577: IFFALSE 49019
// begin if not mc_produce [ i ] then
48579: LD_EXP 120
48583: PUSH
48584: LD_VAR 0 2
48588: ARRAY
48589: NOT
48590: IFFALSE 48594
// continue ;
48592: GO 48576
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48594: LD_ADDR_VAR 0 5
48598: PUSH
48599: LD_EXP 99
48603: PUSH
48604: LD_VAR 0 2
48608: ARRAY
48609: PPUSH
48610: LD_INT 30
48612: PUSH
48613: LD_INT 3
48615: PUSH
48616: EMPTY
48617: LIST
48618: LIST
48619: PPUSH
48620: CALL_OW 72
48624: ST_TO_ADDR
// if not fac then
48625: LD_VAR 0 5
48629: NOT
48630: IFFALSE 48634
// continue ;
48632: GO 48576
// for j in fac do
48634: LD_ADDR_VAR 0 3
48638: PUSH
48639: LD_VAR 0 5
48643: PUSH
48644: FOR_IN
48645: IFFALSE 49015
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
48647: LD_VAR 0 3
48651: PPUSH
48652: CALL_OW 461
48656: PUSH
48657: LD_INT 2
48659: NONEQUAL
48660: PUSH
48661: LD_VAR 0 3
48665: PPUSH
48666: LD_INT 15
48668: PPUSH
48669: CALL 72294 0 2
48673: PUSH
48674: LD_INT 4
48676: ARRAY
48677: OR
48678: PUSH
48679: LD_VAR 0 3
48683: PPUSH
48684: CALL_OW 313
48688: PUSH
48689: LD_INT 0
48691: EQUAL
48692: OR
48693: IFFALSE 48697
// continue ;
48695: GO 48644
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
48697: LD_VAR 0 3
48701: PPUSH
48702: LD_EXP 120
48706: PUSH
48707: LD_VAR 0 2
48711: ARRAY
48712: PUSH
48713: LD_INT 1
48715: ARRAY
48716: PUSH
48717: LD_INT 1
48719: ARRAY
48720: PPUSH
48721: LD_EXP 120
48725: PUSH
48726: LD_VAR 0 2
48730: ARRAY
48731: PUSH
48732: LD_INT 1
48734: ARRAY
48735: PUSH
48736: LD_INT 2
48738: ARRAY
48739: PPUSH
48740: LD_EXP 120
48744: PUSH
48745: LD_VAR 0 2
48749: ARRAY
48750: PUSH
48751: LD_INT 1
48753: ARRAY
48754: PUSH
48755: LD_INT 3
48757: ARRAY
48758: PPUSH
48759: LD_EXP 120
48763: PUSH
48764: LD_VAR 0 2
48768: ARRAY
48769: PUSH
48770: LD_INT 1
48772: ARRAY
48773: PUSH
48774: LD_INT 4
48776: ARRAY
48777: PPUSH
48778: CALL_OW 448
48782: PUSH
48783: LD_VAR 0 3
48787: PPUSH
48788: LD_EXP 120
48792: PUSH
48793: LD_VAR 0 2
48797: ARRAY
48798: PUSH
48799: LD_INT 1
48801: ARRAY
48802: PUSH
48803: LD_INT 1
48805: ARRAY
48806: PUSH
48807: LD_EXP 120
48811: PUSH
48812: LD_VAR 0 2
48816: ARRAY
48817: PUSH
48818: LD_INT 1
48820: ARRAY
48821: PUSH
48822: LD_INT 2
48824: ARRAY
48825: PUSH
48826: LD_EXP 120
48830: PUSH
48831: LD_VAR 0 2
48835: ARRAY
48836: PUSH
48837: LD_INT 1
48839: ARRAY
48840: PUSH
48841: LD_INT 3
48843: ARRAY
48844: PUSH
48845: LD_EXP 120
48849: PUSH
48850: LD_VAR 0 2
48854: ARRAY
48855: PUSH
48856: LD_INT 1
48858: ARRAY
48859: PUSH
48860: LD_INT 4
48862: ARRAY
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: LIST
48868: LIST
48869: PPUSH
48870: CALL 75965 0 2
48874: AND
48875: IFFALSE 49013
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
48877: LD_VAR 0 3
48881: PPUSH
48882: LD_EXP 120
48886: PUSH
48887: LD_VAR 0 2
48891: ARRAY
48892: PUSH
48893: LD_INT 1
48895: ARRAY
48896: PUSH
48897: LD_INT 1
48899: ARRAY
48900: PPUSH
48901: LD_EXP 120
48905: PUSH
48906: LD_VAR 0 2
48910: ARRAY
48911: PUSH
48912: LD_INT 1
48914: ARRAY
48915: PUSH
48916: LD_INT 2
48918: ARRAY
48919: PPUSH
48920: LD_EXP 120
48924: PUSH
48925: LD_VAR 0 2
48929: ARRAY
48930: PUSH
48931: LD_INT 1
48933: ARRAY
48934: PUSH
48935: LD_INT 3
48937: ARRAY
48938: PPUSH
48939: LD_EXP 120
48943: PUSH
48944: LD_VAR 0 2
48948: ARRAY
48949: PUSH
48950: LD_INT 1
48952: ARRAY
48953: PUSH
48954: LD_INT 4
48956: ARRAY
48957: PPUSH
48958: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
48962: LD_ADDR_VAR 0 4
48966: PUSH
48967: LD_EXP 120
48971: PUSH
48972: LD_VAR 0 2
48976: ARRAY
48977: PPUSH
48978: LD_INT 1
48980: PPUSH
48981: CALL_OW 3
48985: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48986: LD_ADDR_EXP 120
48990: PUSH
48991: LD_EXP 120
48995: PPUSH
48996: LD_VAR 0 2
49000: PPUSH
49001: LD_VAR 0 4
49005: PPUSH
49006: CALL_OW 1
49010: ST_TO_ADDR
// break ;
49011: GO 49015
// end ; end ;
49013: GO 48644
49015: POP
49016: POP
// end ;
49017: GO 48576
49019: POP
49020: POP
// end ;
49021: LD_VAR 0 1
49025: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49026: LD_INT 0
49028: PPUSH
49029: PPUSH
49030: PPUSH
// if not mc_bases then
49031: LD_EXP 99
49035: NOT
49036: IFFALSE 49040
// exit ;
49038: GO 49129
// for i = 1 to mc_bases do
49040: LD_ADDR_VAR 0 2
49044: PUSH
49045: DOUBLE
49046: LD_INT 1
49048: DEC
49049: ST_TO_ADDR
49050: LD_EXP 99
49054: PUSH
49055: FOR_TO
49056: IFFALSE 49127
// begin if mc_attack [ i ] then
49058: LD_EXP 119
49062: PUSH
49063: LD_VAR 0 2
49067: ARRAY
49068: IFFALSE 49125
// begin tmp := mc_attack [ i ] [ 1 ] ;
49070: LD_ADDR_VAR 0 3
49074: PUSH
49075: LD_EXP 119
49079: PUSH
49080: LD_VAR 0 2
49084: ARRAY
49085: PUSH
49086: LD_INT 1
49088: ARRAY
49089: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49090: LD_ADDR_EXP 119
49094: PUSH
49095: LD_EXP 119
49099: PPUSH
49100: LD_VAR 0 2
49104: PPUSH
49105: EMPTY
49106: PPUSH
49107: CALL_OW 1
49111: ST_TO_ADDR
// Attack ( tmp ) ;
49112: LD_VAR 0 3
49116: PPUSH
49117: CALL 98178 0 1
// exit ;
49121: POP
49122: POP
49123: GO 49129
// end ; end ;
49125: GO 49055
49127: POP
49128: POP
// end ;
49129: LD_VAR 0 1
49133: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49134: LD_INT 0
49136: PPUSH
49137: PPUSH
49138: PPUSH
49139: PPUSH
49140: PPUSH
49141: PPUSH
49142: PPUSH
// if not mc_bases then
49143: LD_EXP 99
49147: NOT
49148: IFFALSE 49152
// exit ;
49150: GO 49734
// for i = 1 to mc_bases do
49152: LD_ADDR_VAR 0 2
49156: PUSH
49157: DOUBLE
49158: LD_INT 1
49160: DEC
49161: ST_TO_ADDR
49162: LD_EXP 99
49166: PUSH
49167: FOR_TO
49168: IFFALSE 49732
// begin if not mc_bases [ i ] then
49170: LD_EXP 99
49174: PUSH
49175: LD_VAR 0 2
49179: ARRAY
49180: NOT
49181: IFFALSE 49185
// continue ;
49183: GO 49167
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49185: LD_ADDR_VAR 0 7
49189: PUSH
49190: LD_EXP 99
49194: PUSH
49195: LD_VAR 0 2
49199: ARRAY
49200: PUSH
49201: LD_INT 1
49203: ARRAY
49204: PPUSH
49205: CALL 66598 0 1
49209: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49210: LD_ADDR_EXP 122
49214: PUSH
49215: LD_EXP 122
49219: PPUSH
49220: LD_VAR 0 2
49224: PPUSH
49225: LD_EXP 99
49229: PUSH
49230: LD_VAR 0 2
49234: ARRAY
49235: PUSH
49236: LD_INT 1
49238: ARRAY
49239: PPUSH
49240: CALL_OW 255
49244: PPUSH
49245: LD_EXP 124
49249: PUSH
49250: LD_VAR 0 2
49254: ARRAY
49255: PPUSH
49256: CALL 64595 0 2
49260: PPUSH
49261: CALL_OW 1
49265: ST_TO_ADDR
// if not mc_scan [ i ] then
49266: LD_EXP 122
49270: PUSH
49271: LD_VAR 0 2
49275: ARRAY
49276: NOT
49277: IFFALSE 49432
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49279: LD_ADDR_VAR 0 4
49283: PUSH
49284: LD_EXP 99
49288: PUSH
49289: LD_VAR 0 2
49293: ARRAY
49294: PPUSH
49295: LD_INT 2
49297: PUSH
49298: LD_INT 25
49300: PUSH
49301: LD_INT 5
49303: PUSH
49304: EMPTY
49305: LIST
49306: LIST
49307: PUSH
49308: LD_INT 25
49310: PUSH
49311: LD_INT 8
49313: PUSH
49314: EMPTY
49315: LIST
49316: LIST
49317: PUSH
49318: LD_INT 25
49320: PUSH
49321: LD_INT 9
49323: PUSH
49324: EMPTY
49325: LIST
49326: LIST
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: PPUSH
49334: CALL_OW 72
49338: ST_TO_ADDR
// if not tmp then
49339: LD_VAR 0 4
49343: NOT
49344: IFFALSE 49348
// continue ;
49346: GO 49167
// for j in tmp do
49348: LD_ADDR_VAR 0 3
49352: PUSH
49353: LD_VAR 0 4
49357: PUSH
49358: FOR_IN
49359: IFFALSE 49430
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49361: LD_VAR 0 3
49365: PPUSH
49366: CALL_OW 310
49370: PPUSH
49371: CALL_OW 266
49375: PUSH
49376: LD_INT 5
49378: EQUAL
49379: PUSH
49380: LD_VAR 0 3
49384: PPUSH
49385: CALL_OW 257
49389: PUSH
49390: LD_INT 1
49392: EQUAL
49393: AND
49394: PUSH
49395: LD_VAR 0 3
49399: PPUSH
49400: CALL_OW 459
49404: NOT
49405: AND
49406: PUSH
49407: LD_VAR 0 7
49411: AND
49412: IFFALSE 49428
// ComChangeProfession ( j , class ) ;
49414: LD_VAR 0 3
49418: PPUSH
49419: LD_VAR 0 7
49423: PPUSH
49424: CALL_OW 123
49428: GO 49358
49430: POP
49431: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49432: LD_EXP 122
49436: PUSH
49437: LD_VAR 0 2
49441: ARRAY
49442: PUSH
49443: LD_EXP 121
49447: PUSH
49448: LD_VAR 0 2
49452: ARRAY
49453: NOT
49454: AND
49455: PUSH
49456: LD_EXP 99
49460: PUSH
49461: LD_VAR 0 2
49465: ARRAY
49466: PPUSH
49467: LD_INT 30
49469: PUSH
49470: LD_INT 32
49472: PUSH
49473: EMPTY
49474: LIST
49475: LIST
49476: PPUSH
49477: CALL_OW 72
49481: NOT
49482: AND
49483: PUSH
49484: LD_EXP 99
49488: PUSH
49489: LD_VAR 0 2
49493: ARRAY
49494: PPUSH
49495: LD_INT 2
49497: PUSH
49498: LD_INT 30
49500: PUSH
49501: LD_INT 4
49503: PUSH
49504: EMPTY
49505: LIST
49506: LIST
49507: PUSH
49508: LD_INT 30
49510: PUSH
49511: LD_INT 5
49513: PUSH
49514: EMPTY
49515: LIST
49516: LIST
49517: PUSH
49518: EMPTY
49519: LIST
49520: LIST
49521: LIST
49522: PPUSH
49523: CALL_OW 72
49527: NOT
49528: AND
49529: IFFALSE 49661
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49531: LD_ADDR_VAR 0 4
49535: PUSH
49536: LD_EXP 99
49540: PUSH
49541: LD_VAR 0 2
49545: ARRAY
49546: PPUSH
49547: LD_INT 2
49549: PUSH
49550: LD_INT 25
49552: PUSH
49553: LD_INT 1
49555: PUSH
49556: EMPTY
49557: LIST
49558: LIST
49559: PUSH
49560: LD_INT 25
49562: PUSH
49563: LD_INT 5
49565: PUSH
49566: EMPTY
49567: LIST
49568: LIST
49569: PUSH
49570: LD_INT 25
49572: PUSH
49573: LD_INT 8
49575: PUSH
49576: EMPTY
49577: LIST
49578: LIST
49579: PUSH
49580: LD_INT 25
49582: PUSH
49583: LD_INT 9
49585: PUSH
49586: EMPTY
49587: LIST
49588: LIST
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: PPUSH
49597: CALL_OW 72
49601: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
49602: LD_ADDR_VAR 0 4
49606: PUSH
49607: LD_VAR 0 4
49611: PUSH
49612: LD_VAR 0 4
49616: PPUSH
49617: LD_INT 18
49619: PPUSH
49620: CALL 102961 0 2
49624: DIFF
49625: ST_TO_ADDR
// if tmp then
49626: LD_VAR 0 4
49630: IFFALSE 49661
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
49632: LD_VAR 0 2
49636: PPUSH
49637: LD_VAR 0 4
49641: PPUSH
49642: LD_EXP 124
49646: PUSH
49647: LD_VAR 0 2
49651: ARRAY
49652: PPUSH
49653: CALL 64630 0 3
// exit ;
49657: POP
49658: POP
49659: GO 49734
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
49661: LD_EXP 122
49665: PUSH
49666: LD_VAR 0 2
49670: ARRAY
49671: PUSH
49672: LD_EXP 121
49676: PUSH
49677: LD_VAR 0 2
49681: ARRAY
49682: AND
49683: IFFALSE 49730
// begin tmp := mc_defender [ i ] ;
49685: LD_ADDR_VAR 0 4
49689: PUSH
49690: LD_EXP 121
49694: PUSH
49695: LD_VAR 0 2
49699: ARRAY
49700: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
49701: LD_VAR 0 2
49705: PPUSH
49706: LD_VAR 0 4
49710: PPUSH
49711: LD_EXP 122
49715: PUSH
49716: LD_VAR 0 2
49720: ARRAY
49721: PPUSH
49722: CALL 65128 0 3
// exit ;
49726: POP
49727: POP
49728: GO 49734
// end ; end ;
49730: GO 49167
49732: POP
49733: POP
// end ;
49734: LD_VAR 0 1
49738: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
49739: LD_INT 0
49741: PPUSH
49742: PPUSH
49743: PPUSH
49744: PPUSH
49745: PPUSH
49746: PPUSH
49747: PPUSH
49748: PPUSH
49749: PPUSH
49750: PPUSH
49751: PPUSH
// if not mc_bases then
49752: LD_EXP 99
49756: NOT
49757: IFFALSE 49761
// exit ;
49759: GO 50848
// for i = 1 to mc_bases do
49761: LD_ADDR_VAR 0 2
49765: PUSH
49766: DOUBLE
49767: LD_INT 1
49769: DEC
49770: ST_TO_ADDR
49771: LD_EXP 99
49775: PUSH
49776: FOR_TO
49777: IFFALSE 50846
// begin tmp := mc_lab [ i ] ;
49779: LD_ADDR_VAR 0 6
49783: PUSH
49784: LD_EXP 132
49788: PUSH
49789: LD_VAR 0 2
49793: ARRAY
49794: ST_TO_ADDR
// if not tmp then
49795: LD_VAR 0 6
49799: NOT
49800: IFFALSE 49804
// continue ;
49802: GO 49776
// idle_lab := 0 ;
49804: LD_ADDR_VAR 0 11
49808: PUSH
49809: LD_INT 0
49811: ST_TO_ADDR
// for j in tmp do
49812: LD_ADDR_VAR 0 3
49816: PUSH
49817: LD_VAR 0 6
49821: PUSH
49822: FOR_IN
49823: IFFALSE 50842
// begin researching := false ;
49825: LD_ADDR_VAR 0 10
49829: PUSH
49830: LD_INT 0
49832: ST_TO_ADDR
// side := GetSide ( j ) ;
49833: LD_ADDR_VAR 0 4
49837: PUSH
49838: LD_VAR 0 3
49842: PPUSH
49843: CALL_OW 255
49847: ST_TO_ADDR
// if not mc_tech [ side ] then
49848: LD_EXP 126
49852: PUSH
49853: LD_VAR 0 4
49857: ARRAY
49858: NOT
49859: IFFALSE 49863
// continue ;
49861: GO 49822
// if BuildingStatus ( j ) = bs_idle then
49863: LD_VAR 0 3
49867: PPUSH
49868: CALL_OW 461
49872: PUSH
49873: LD_INT 2
49875: EQUAL
49876: IFFALSE 50064
// begin if idle_lab and UnitsInside ( j ) < 6 then
49878: LD_VAR 0 11
49882: PUSH
49883: LD_VAR 0 3
49887: PPUSH
49888: CALL_OW 313
49892: PUSH
49893: LD_INT 6
49895: LESS
49896: AND
49897: IFFALSE 49968
// begin tmp2 := UnitsInside ( idle_lab ) ;
49899: LD_ADDR_VAR 0 9
49903: PUSH
49904: LD_VAR 0 11
49908: PPUSH
49909: CALL_OW 313
49913: ST_TO_ADDR
// if tmp2 then
49914: LD_VAR 0 9
49918: IFFALSE 49960
// for x in tmp2 do
49920: LD_ADDR_VAR 0 7
49924: PUSH
49925: LD_VAR 0 9
49929: PUSH
49930: FOR_IN
49931: IFFALSE 49958
// begin ComExitBuilding ( x ) ;
49933: LD_VAR 0 7
49937: PPUSH
49938: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
49942: LD_VAR 0 7
49946: PPUSH
49947: LD_VAR 0 3
49951: PPUSH
49952: CALL_OW 180
// end ;
49956: GO 49930
49958: POP
49959: POP
// idle_lab := 0 ;
49960: LD_ADDR_VAR 0 11
49964: PUSH
49965: LD_INT 0
49967: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
49968: LD_ADDR_VAR 0 5
49972: PUSH
49973: LD_EXP 126
49977: PUSH
49978: LD_VAR 0 4
49982: ARRAY
49983: PUSH
49984: FOR_IN
49985: IFFALSE 50045
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
49987: LD_VAR 0 3
49991: PPUSH
49992: LD_VAR 0 5
49996: PPUSH
49997: CALL_OW 430
50001: PUSH
50002: LD_VAR 0 4
50006: PPUSH
50007: LD_VAR 0 5
50011: PPUSH
50012: CALL 63700 0 2
50016: AND
50017: IFFALSE 50043
// begin researching := true ;
50019: LD_ADDR_VAR 0 10
50023: PUSH
50024: LD_INT 1
50026: ST_TO_ADDR
// ComResearch ( j , t ) ;
50027: LD_VAR 0 3
50031: PPUSH
50032: LD_VAR 0 5
50036: PPUSH
50037: CALL_OW 124
// break ;
50041: GO 50045
// end ;
50043: GO 49984
50045: POP
50046: POP
// if not researching then
50047: LD_VAR 0 10
50051: NOT
50052: IFFALSE 50064
// idle_lab := j ;
50054: LD_ADDR_VAR 0 11
50058: PUSH
50059: LD_VAR 0 3
50063: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50064: LD_VAR 0 3
50068: PPUSH
50069: CALL_OW 461
50073: PUSH
50074: LD_INT 10
50076: EQUAL
50077: IFFALSE 50665
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50079: LD_EXP 128
50083: PUSH
50084: LD_VAR 0 2
50088: ARRAY
50089: NOT
50090: PUSH
50091: LD_EXP 129
50095: PUSH
50096: LD_VAR 0 2
50100: ARRAY
50101: NOT
50102: AND
50103: PUSH
50104: LD_EXP 126
50108: PUSH
50109: LD_VAR 0 4
50113: ARRAY
50114: PUSH
50115: LD_INT 1
50117: GREATER
50118: AND
50119: IFFALSE 50250
// begin ComCancel ( j ) ;
50121: LD_VAR 0 3
50125: PPUSH
50126: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50130: LD_ADDR_EXP 126
50134: PUSH
50135: LD_EXP 126
50139: PPUSH
50140: LD_VAR 0 4
50144: PPUSH
50145: LD_EXP 126
50149: PUSH
50150: LD_VAR 0 4
50154: ARRAY
50155: PPUSH
50156: LD_EXP 126
50160: PUSH
50161: LD_VAR 0 4
50165: ARRAY
50166: PUSH
50167: LD_INT 1
50169: MINUS
50170: PPUSH
50171: LD_EXP 126
50175: PUSH
50176: LD_VAR 0 4
50180: ARRAY
50181: PPUSH
50182: LD_INT 0
50184: PPUSH
50185: CALL 69119 0 4
50189: PPUSH
50190: CALL_OW 1
50194: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50195: LD_ADDR_EXP 126
50199: PUSH
50200: LD_EXP 126
50204: PPUSH
50205: LD_VAR 0 4
50209: PPUSH
50210: LD_EXP 126
50214: PUSH
50215: LD_VAR 0 4
50219: ARRAY
50220: PPUSH
50221: LD_EXP 126
50225: PUSH
50226: LD_VAR 0 4
50230: ARRAY
50231: PPUSH
50232: LD_INT 1
50234: PPUSH
50235: LD_INT 0
50237: PPUSH
50238: CALL 69119 0 4
50242: PPUSH
50243: CALL_OW 1
50247: ST_TO_ADDR
// continue ;
50248: GO 49822
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50250: LD_EXP 128
50254: PUSH
50255: LD_VAR 0 2
50259: ARRAY
50260: PUSH
50261: LD_EXP 129
50265: PUSH
50266: LD_VAR 0 2
50270: ARRAY
50271: NOT
50272: AND
50273: IFFALSE 50400
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50275: LD_ADDR_EXP 129
50279: PUSH
50280: LD_EXP 129
50284: PPUSH
50285: LD_VAR 0 2
50289: PUSH
50290: LD_EXP 129
50294: PUSH
50295: LD_VAR 0 2
50299: ARRAY
50300: PUSH
50301: LD_INT 1
50303: PLUS
50304: PUSH
50305: EMPTY
50306: LIST
50307: LIST
50308: PPUSH
50309: LD_EXP 128
50313: PUSH
50314: LD_VAR 0 2
50318: ARRAY
50319: PUSH
50320: LD_INT 1
50322: ARRAY
50323: PPUSH
50324: CALL 69701 0 3
50328: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50329: LD_EXP 128
50333: PUSH
50334: LD_VAR 0 2
50338: ARRAY
50339: PUSH
50340: LD_INT 1
50342: ARRAY
50343: PPUSH
50344: LD_INT 112
50346: PPUSH
50347: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50351: LD_ADDR_VAR 0 9
50355: PUSH
50356: LD_EXP 128
50360: PUSH
50361: LD_VAR 0 2
50365: ARRAY
50366: PPUSH
50367: LD_INT 1
50369: PPUSH
50370: CALL_OW 3
50374: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50375: LD_ADDR_EXP 128
50379: PUSH
50380: LD_EXP 128
50384: PPUSH
50385: LD_VAR 0 2
50389: PPUSH
50390: LD_VAR 0 9
50394: PPUSH
50395: CALL_OW 1
50399: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50400: LD_EXP 128
50404: PUSH
50405: LD_VAR 0 2
50409: ARRAY
50410: PUSH
50411: LD_EXP 129
50415: PUSH
50416: LD_VAR 0 2
50420: ARRAY
50421: AND
50422: PUSH
50423: LD_EXP 129
50427: PUSH
50428: LD_VAR 0 2
50432: ARRAY
50433: PUSH
50434: LD_INT 1
50436: ARRAY
50437: PPUSH
50438: CALL_OW 310
50442: NOT
50443: AND
50444: PUSH
50445: LD_VAR 0 3
50449: PPUSH
50450: CALL_OW 313
50454: PUSH
50455: LD_INT 6
50457: EQUAL
50458: AND
50459: IFFALSE 50515
// begin tmp2 := UnitsInside ( j ) ;
50461: LD_ADDR_VAR 0 9
50465: PUSH
50466: LD_VAR 0 3
50470: PPUSH
50471: CALL_OW 313
50475: ST_TO_ADDR
// if tmp2 = 6 then
50476: LD_VAR 0 9
50480: PUSH
50481: LD_INT 6
50483: EQUAL
50484: IFFALSE 50515
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50486: LD_VAR 0 9
50490: PUSH
50491: LD_INT 1
50493: ARRAY
50494: PPUSH
50495: LD_INT 112
50497: PPUSH
50498: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
50502: LD_VAR 0 9
50506: PUSH
50507: LD_INT 1
50509: ARRAY
50510: PPUSH
50511: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
50515: LD_EXP 129
50519: PUSH
50520: LD_VAR 0 2
50524: ARRAY
50525: PUSH
50526: LD_EXP 129
50530: PUSH
50531: LD_VAR 0 2
50535: ARRAY
50536: PUSH
50537: LD_INT 1
50539: ARRAY
50540: PPUSH
50541: CALL_OW 314
50545: NOT
50546: AND
50547: PUSH
50548: LD_EXP 129
50552: PUSH
50553: LD_VAR 0 2
50557: ARRAY
50558: PUSH
50559: LD_INT 1
50561: ARRAY
50562: PPUSH
50563: CALL_OW 310
50567: NOT
50568: AND
50569: IFFALSE 50595
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
50571: LD_EXP 129
50575: PUSH
50576: LD_VAR 0 2
50580: ARRAY
50581: PUSH
50582: LD_INT 1
50584: ARRAY
50585: PPUSH
50586: LD_VAR 0 3
50590: PPUSH
50591: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
50595: LD_EXP 129
50599: PUSH
50600: LD_VAR 0 2
50604: ARRAY
50605: PUSH
50606: LD_INT 1
50608: ARRAY
50609: PPUSH
50610: CALL_OW 310
50614: PUSH
50615: LD_EXP 129
50619: PUSH
50620: LD_VAR 0 2
50624: ARRAY
50625: PUSH
50626: LD_INT 1
50628: ARRAY
50629: PPUSH
50630: CALL_OW 310
50634: PPUSH
50635: CALL_OW 461
50639: PUSH
50640: LD_INT 3
50642: NONEQUAL
50643: AND
50644: IFFALSE 50665
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
50646: LD_EXP 129
50650: PUSH
50651: LD_VAR 0 2
50655: ARRAY
50656: PUSH
50657: LD_INT 1
50659: ARRAY
50660: PPUSH
50661: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
50665: LD_VAR 0 3
50669: PPUSH
50670: CALL_OW 461
50674: PUSH
50675: LD_INT 6
50677: EQUAL
50678: PUSH
50679: LD_VAR 0 6
50683: PUSH
50684: LD_INT 1
50686: GREATER
50687: AND
50688: IFFALSE 50840
// begin sci := [ ] ;
50690: LD_ADDR_VAR 0 8
50694: PUSH
50695: EMPTY
50696: ST_TO_ADDR
// for x in ( tmp diff j ) do
50697: LD_ADDR_VAR 0 7
50701: PUSH
50702: LD_VAR 0 6
50706: PUSH
50707: LD_VAR 0 3
50711: DIFF
50712: PUSH
50713: FOR_IN
50714: IFFALSE 50766
// begin if sci = 6 then
50716: LD_VAR 0 8
50720: PUSH
50721: LD_INT 6
50723: EQUAL
50724: IFFALSE 50728
// break ;
50726: GO 50766
// if BuildingStatus ( x ) = bs_idle then
50728: LD_VAR 0 7
50732: PPUSH
50733: CALL_OW 461
50737: PUSH
50738: LD_INT 2
50740: EQUAL
50741: IFFALSE 50764
// sci := sci ^ UnitsInside ( x ) ;
50743: LD_ADDR_VAR 0 8
50747: PUSH
50748: LD_VAR 0 8
50752: PUSH
50753: LD_VAR 0 7
50757: PPUSH
50758: CALL_OW 313
50762: ADD
50763: ST_TO_ADDR
// end ;
50764: GO 50713
50766: POP
50767: POP
// if not sci then
50768: LD_VAR 0 8
50772: NOT
50773: IFFALSE 50777
// continue ;
50775: GO 49822
// for x in sci do
50777: LD_ADDR_VAR 0 7
50781: PUSH
50782: LD_VAR 0 8
50786: PUSH
50787: FOR_IN
50788: IFFALSE 50838
// if IsInUnit ( x ) and not HasTask ( x ) then
50790: LD_VAR 0 7
50794: PPUSH
50795: CALL_OW 310
50799: PUSH
50800: LD_VAR 0 7
50804: PPUSH
50805: CALL_OW 314
50809: NOT
50810: AND
50811: IFFALSE 50836
// begin ComExitBuilding ( x ) ;
50813: LD_VAR 0 7
50817: PPUSH
50818: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50822: LD_VAR 0 7
50826: PPUSH
50827: LD_VAR 0 3
50831: PPUSH
50832: CALL_OW 180
// end ;
50836: GO 50787
50838: POP
50839: POP
// end ; end ;
50840: GO 49822
50842: POP
50843: POP
// end ;
50844: GO 49776
50846: POP
50847: POP
// end ;
50848: LD_VAR 0 1
50852: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
50853: LD_INT 0
50855: PPUSH
50856: PPUSH
// if not mc_bases then
50857: LD_EXP 99
50861: NOT
50862: IFFALSE 50866
// exit ;
50864: GO 50947
// for i = 1 to mc_bases do
50866: LD_ADDR_VAR 0 2
50870: PUSH
50871: DOUBLE
50872: LD_INT 1
50874: DEC
50875: ST_TO_ADDR
50876: LD_EXP 99
50880: PUSH
50881: FOR_TO
50882: IFFALSE 50945
// if mc_mines [ i ] and mc_miners [ i ] then
50884: LD_EXP 112
50888: PUSH
50889: LD_VAR 0 2
50893: ARRAY
50894: PUSH
50895: LD_EXP 113
50899: PUSH
50900: LD_VAR 0 2
50904: ARRAY
50905: AND
50906: IFFALSE 50943
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
50908: LD_EXP 113
50912: PUSH
50913: LD_VAR 0 2
50917: ARRAY
50918: PUSH
50919: LD_INT 1
50921: ARRAY
50922: PPUSH
50923: CALL_OW 255
50927: PPUSH
50928: LD_EXP 112
50932: PUSH
50933: LD_VAR 0 2
50937: ARRAY
50938: PPUSH
50939: CALL 66751 0 2
50943: GO 50881
50945: POP
50946: POP
// end ;
50947: LD_VAR 0 1
50951: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
50952: LD_INT 0
50954: PPUSH
50955: PPUSH
50956: PPUSH
50957: PPUSH
50958: PPUSH
50959: PPUSH
50960: PPUSH
50961: PPUSH
// if not mc_bases or not mc_parking then
50962: LD_EXP 99
50966: NOT
50967: PUSH
50968: LD_EXP 123
50972: NOT
50973: OR
50974: IFFALSE 50978
// exit ;
50976: GO 51654
// for i = 1 to mc_bases do
50978: LD_ADDR_VAR 0 2
50982: PUSH
50983: DOUBLE
50984: LD_INT 1
50986: DEC
50987: ST_TO_ADDR
50988: LD_EXP 99
50992: PUSH
50993: FOR_TO
50994: IFFALSE 51652
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
50996: LD_EXP 99
51000: PUSH
51001: LD_VAR 0 2
51005: ARRAY
51006: NOT
51007: PUSH
51008: LD_EXP 123
51012: PUSH
51013: LD_VAR 0 2
51017: ARRAY
51018: NOT
51019: OR
51020: IFFALSE 51024
// continue ;
51022: GO 50993
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51024: LD_ADDR_VAR 0 5
51028: PUSH
51029: LD_EXP 99
51033: PUSH
51034: LD_VAR 0 2
51038: ARRAY
51039: PUSH
51040: LD_INT 1
51042: ARRAY
51043: PPUSH
51044: CALL_OW 255
51048: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51049: LD_ADDR_VAR 0 6
51053: PUSH
51054: LD_EXP 99
51058: PUSH
51059: LD_VAR 0 2
51063: ARRAY
51064: PPUSH
51065: LD_INT 30
51067: PUSH
51068: LD_INT 3
51070: PUSH
51071: EMPTY
51072: LIST
51073: LIST
51074: PPUSH
51075: CALL_OW 72
51079: ST_TO_ADDR
// if not fac then
51080: LD_VAR 0 6
51084: NOT
51085: IFFALSE 51136
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51087: LD_ADDR_VAR 0 6
51091: PUSH
51092: LD_EXP 99
51096: PUSH
51097: LD_VAR 0 2
51101: ARRAY
51102: PPUSH
51103: LD_INT 2
51105: PUSH
51106: LD_INT 30
51108: PUSH
51109: LD_INT 0
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: PUSH
51116: LD_INT 30
51118: PUSH
51119: LD_INT 1
51121: PUSH
51122: EMPTY
51123: LIST
51124: LIST
51125: PUSH
51126: EMPTY
51127: LIST
51128: LIST
51129: LIST
51130: PPUSH
51131: CALL_OW 72
51135: ST_TO_ADDR
// if not fac then
51136: LD_VAR 0 6
51140: NOT
51141: IFFALSE 51145
// continue ;
51143: GO 50993
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51145: LD_ADDR_VAR 0 7
51149: PUSH
51150: LD_EXP 123
51154: PUSH
51155: LD_VAR 0 2
51159: ARRAY
51160: PPUSH
51161: LD_INT 22
51163: PUSH
51164: LD_VAR 0 5
51168: PUSH
51169: EMPTY
51170: LIST
51171: LIST
51172: PUSH
51173: LD_INT 21
51175: PUSH
51176: LD_INT 2
51178: PUSH
51179: EMPTY
51180: LIST
51181: LIST
51182: PUSH
51183: LD_INT 3
51185: PUSH
51186: LD_INT 24
51188: PUSH
51189: LD_INT 1000
51191: PUSH
51192: EMPTY
51193: LIST
51194: LIST
51195: PUSH
51196: EMPTY
51197: LIST
51198: LIST
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: LIST
51204: PPUSH
51205: CALL_OW 70
51209: PUSH
51210: LD_INT 22
51212: PUSH
51213: LD_VAR 0 5
51217: PUSH
51218: EMPTY
51219: LIST
51220: LIST
51221: PUSH
51222: LD_INT 91
51224: PUSH
51225: LD_VAR 0 6
51229: PUSH
51230: LD_INT 1
51232: ARRAY
51233: PUSH
51234: LD_INT 25
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: LIST
51241: PUSH
51242: LD_INT 21
51244: PUSH
51245: LD_INT 2
51247: PUSH
51248: EMPTY
51249: LIST
51250: LIST
51251: PUSH
51252: LD_INT 3
51254: PUSH
51255: LD_INT 24
51257: PUSH
51258: LD_INT 1000
51260: PUSH
51261: EMPTY
51262: LIST
51263: LIST
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: PUSH
51269: EMPTY
51270: LIST
51271: LIST
51272: LIST
51273: LIST
51274: PPUSH
51275: CALL_OW 69
51279: UNION
51280: ST_TO_ADDR
// if not vehs then
51281: LD_VAR 0 7
51285: NOT
51286: IFFALSE 51312
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51288: LD_ADDR_EXP 111
51292: PUSH
51293: LD_EXP 111
51297: PPUSH
51298: LD_VAR 0 2
51302: PPUSH
51303: EMPTY
51304: PPUSH
51305: CALL_OW 1
51309: ST_TO_ADDR
// continue ;
51310: GO 50993
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51312: LD_ADDR_VAR 0 8
51316: PUSH
51317: LD_EXP 99
51321: PUSH
51322: LD_VAR 0 2
51326: ARRAY
51327: PPUSH
51328: LD_INT 30
51330: PUSH
51331: LD_INT 3
51333: PUSH
51334: EMPTY
51335: LIST
51336: LIST
51337: PPUSH
51338: CALL_OW 72
51342: ST_TO_ADDR
// if tmp then
51343: LD_VAR 0 8
51347: IFFALSE 51450
// begin for j in tmp do
51349: LD_ADDR_VAR 0 3
51353: PUSH
51354: LD_VAR 0 8
51358: PUSH
51359: FOR_IN
51360: IFFALSE 51448
// for k in UnitsInside ( j ) do
51362: LD_ADDR_VAR 0 4
51366: PUSH
51367: LD_VAR 0 3
51371: PPUSH
51372: CALL_OW 313
51376: PUSH
51377: FOR_IN
51378: IFFALSE 51444
// if k then
51380: LD_VAR 0 4
51384: IFFALSE 51442
// if not k in mc_repair_vehicle [ i ] then
51386: LD_VAR 0 4
51390: PUSH
51391: LD_EXP 111
51395: PUSH
51396: LD_VAR 0 2
51400: ARRAY
51401: IN
51402: NOT
51403: IFFALSE 51442
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51405: LD_ADDR_EXP 111
51409: PUSH
51410: LD_EXP 111
51414: PPUSH
51415: LD_VAR 0 2
51419: PPUSH
51420: LD_EXP 111
51424: PUSH
51425: LD_VAR 0 2
51429: ARRAY
51430: PUSH
51431: LD_VAR 0 4
51435: UNION
51436: PPUSH
51437: CALL_OW 1
51441: ST_TO_ADDR
51442: GO 51377
51444: POP
51445: POP
51446: GO 51359
51448: POP
51449: POP
// end ; if not mc_repair_vehicle [ i ] then
51450: LD_EXP 111
51454: PUSH
51455: LD_VAR 0 2
51459: ARRAY
51460: NOT
51461: IFFALSE 51465
// continue ;
51463: GO 50993
// for j in mc_repair_vehicle [ i ] do
51465: LD_ADDR_VAR 0 3
51469: PUSH
51470: LD_EXP 111
51474: PUSH
51475: LD_VAR 0 2
51479: ARRAY
51480: PUSH
51481: FOR_IN
51482: IFFALSE 51648
// begin if GetClass ( j ) <> 3 then
51484: LD_VAR 0 3
51488: PPUSH
51489: CALL_OW 257
51493: PUSH
51494: LD_INT 3
51496: NONEQUAL
51497: IFFALSE 51538
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
51499: LD_ADDR_EXP 111
51503: PUSH
51504: LD_EXP 111
51508: PPUSH
51509: LD_VAR 0 2
51513: PPUSH
51514: LD_EXP 111
51518: PUSH
51519: LD_VAR 0 2
51523: ARRAY
51524: PUSH
51525: LD_VAR 0 3
51529: DIFF
51530: PPUSH
51531: CALL_OW 1
51535: ST_TO_ADDR
// continue ;
51536: GO 51481
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51538: LD_VAR 0 3
51542: PPUSH
51543: CALL_OW 311
51547: NOT
51548: PUSH
51549: LD_VAR 0 3
51553: PUSH
51554: LD_EXP 102
51558: PUSH
51559: LD_VAR 0 2
51563: ARRAY
51564: PUSH
51565: LD_INT 1
51567: ARRAY
51568: IN
51569: NOT
51570: AND
51571: PUSH
51572: LD_VAR 0 3
51576: PUSH
51577: LD_EXP 102
51581: PUSH
51582: LD_VAR 0 2
51586: ARRAY
51587: PUSH
51588: LD_INT 2
51590: ARRAY
51591: IN
51592: NOT
51593: AND
51594: IFFALSE 51646
// begin if IsInUnit ( j ) then
51596: LD_VAR 0 3
51600: PPUSH
51601: CALL_OW 310
51605: IFFALSE 51616
// ComExitBuilding ( j ) ;
51607: LD_VAR 0 3
51611: PPUSH
51612: CALL_OW 122
// if not HasTask ( j ) then
51616: LD_VAR 0 3
51620: PPUSH
51621: CALL_OW 314
51625: NOT
51626: IFFALSE 51646
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
51628: LD_VAR 0 3
51632: PPUSH
51633: LD_VAR 0 7
51637: PUSH
51638: LD_INT 1
51640: ARRAY
51641: PPUSH
51642: CALL_OW 189
// end ; end ;
51646: GO 51481
51648: POP
51649: POP
// end ;
51650: GO 50993
51652: POP
51653: POP
// end ;
51654: LD_VAR 0 1
51658: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
51659: LD_INT 0
51661: PPUSH
51662: PPUSH
51663: PPUSH
51664: PPUSH
51665: PPUSH
51666: PPUSH
51667: PPUSH
51668: PPUSH
51669: PPUSH
51670: PPUSH
51671: PPUSH
// if not mc_bases then
51672: LD_EXP 99
51676: NOT
51677: IFFALSE 51681
// exit ;
51679: GO 52483
// for i = 1 to mc_bases do
51681: LD_ADDR_VAR 0 2
51685: PUSH
51686: DOUBLE
51687: LD_INT 1
51689: DEC
51690: ST_TO_ADDR
51691: LD_EXP 99
51695: PUSH
51696: FOR_TO
51697: IFFALSE 52481
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
51699: LD_EXP 127
51703: PUSH
51704: LD_VAR 0 2
51708: ARRAY
51709: NOT
51710: PUSH
51711: LD_EXP 102
51715: PUSH
51716: LD_VAR 0 2
51720: ARRAY
51721: PUSH
51722: LD_INT 1
51724: ARRAY
51725: OR
51726: PUSH
51727: LD_EXP 102
51731: PUSH
51732: LD_VAR 0 2
51736: ARRAY
51737: PUSH
51738: LD_INT 2
51740: ARRAY
51741: OR
51742: PUSH
51743: LD_EXP 125
51747: PUSH
51748: LD_VAR 0 2
51752: ARRAY
51753: PPUSH
51754: LD_INT 1
51756: PPUSH
51757: CALL_OW 325
51761: NOT
51762: OR
51763: PUSH
51764: LD_EXP 122
51768: PUSH
51769: LD_VAR 0 2
51773: ARRAY
51774: OR
51775: IFFALSE 51779
// continue ;
51777: GO 51696
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
51779: LD_ADDR_VAR 0 8
51783: PUSH
51784: LD_EXP 99
51788: PUSH
51789: LD_VAR 0 2
51793: ARRAY
51794: PPUSH
51795: LD_INT 25
51797: PUSH
51798: LD_INT 4
51800: PUSH
51801: EMPTY
51802: LIST
51803: LIST
51804: PUSH
51805: LD_INT 50
51807: PUSH
51808: EMPTY
51809: LIST
51810: PUSH
51811: LD_INT 3
51813: PUSH
51814: LD_INT 60
51816: PUSH
51817: EMPTY
51818: LIST
51819: PUSH
51820: EMPTY
51821: LIST
51822: LIST
51823: PUSH
51824: EMPTY
51825: LIST
51826: LIST
51827: LIST
51828: PPUSH
51829: CALL_OW 72
51833: PUSH
51834: LD_EXP 103
51838: PUSH
51839: LD_VAR 0 2
51843: ARRAY
51844: DIFF
51845: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51846: LD_ADDR_VAR 0 9
51850: PUSH
51851: LD_EXP 99
51855: PUSH
51856: LD_VAR 0 2
51860: ARRAY
51861: PPUSH
51862: LD_INT 2
51864: PUSH
51865: LD_INT 30
51867: PUSH
51868: LD_INT 0
51870: PUSH
51871: EMPTY
51872: LIST
51873: LIST
51874: PUSH
51875: LD_INT 30
51877: PUSH
51878: LD_INT 1
51880: PUSH
51881: EMPTY
51882: LIST
51883: LIST
51884: PUSH
51885: EMPTY
51886: LIST
51887: LIST
51888: LIST
51889: PPUSH
51890: CALL_OW 72
51894: ST_TO_ADDR
// if not tmp or not dep then
51895: LD_VAR 0 8
51899: NOT
51900: PUSH
51901: LD_VAR 0 9
51905: NOT
51906: OR
51907: IFFALSE 51911
// continue ;
51909: GO 51696
// side := GetSide ( tmp [ 1 ] ) ;
51911: LD_ADDR_VAR 0 11
51915: PUSH
51916: LD_VAR 0 8
51920: PUSH
51921: LD_INT 1
51923: ARRAY
51924: PPUSH
51925: CALL_OW 255
51929: ST_TO_ADDR
// dep := dep [ 1 ] ;
51930: LD_ADDR_VAR 0 9
51934: PUSH
51935: LD_VAR 0 9
51939: PUSH
51940: LD_INT 1
51942: ARRAY
51943: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
51944: LD_ADDR_VAR 0 7
51948: PUSH
51949: LD_EXP 127
51953: PUSH
51954: LD_VAR 0 2
51958: ARRAY
51959: PPUSH
51960: LD_INT 22
51962: PUSH
51963: LD_INT 0
51965: PUSH
51966: EMPTY
51967: LIST
51968: LIST
51969: PUSH
51970: LD_INT 25
51972: PUSH
51973: LD_INT 12
51975: PUSH
51976: EMPTY
51977: LIST
51978: LIST
51979: PUSH
51980: EMPTY
51981: LIST
51982: LIST
51983: PPUSH
51984: CALL_OW 70
51988: PUSH
51989: LD_INT 22
51991: PUSH
51992: LD_INT 0
51994: PUSH
51995: EMPTY
51996: LIST
51997: LIST
51998: PUSH
51999: LD_INT 25
52001: PUSH
52002: LD_INT 12
52004: PUSH
52005: EMPTY
52006: LIST
52007: LIST
52008: PUSH
52009: LD_INT 91
52011: PUSH
52012: LD_VAR 0 9
52016: PUSH
52017: LD_INT 20
52019: PUSH
52020: EMPTY
52021: LIST
52022: LIST
52023: LIST
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: LIST
52029: PPUSH
52030: CALL_OW 69
52034: UNION
52035: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52036: LD_ADDR_VAR 0 10
52040: PUSH
52041: LD_EXP 127
52045: PUSH
52046: LD_VAR 0 2
52050: ARRAY
52051: PPUSH
52052: LD_INT 81
52054: PUSH
52055: LD_VAR 0 11
52059: PUSH
52060: EMPTY
52061: LIST
52062: LIST
52063: PPUSH
52064: CALL_OW 70
52068: ST_TO_ADDR
// if not apes or danger_at_area then
52069: LD_VAR 0 7
52073: NOT
52074: PUSH
52075: LD_VAR 0 10
52079: OR
52080: IFFALSE 52130
// begin if mc_taming [ i ] then
52082: LD_EXP 130
52086: PUSH
52087: LD_VAR 0 2
52091: ARRAY
52092: IFFALSE 52128
// begin MC_Reset ( i , 121 ) ;
52094: LD_VAR 0 2
52098: PPUSH
52099: LD_INT 121
52101: PPUSH
52102: CALL 37823 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52106: LD_ADDR_EXP 130
52110: PUSH
52111: LD_EXP 130
52115: PPUSH
52116: LD_VAR 0 2
52120: PPUSH
52121: EMPTY
52122: PPUSH
52123: CALL_OW 1
52127: ST_TO_ADDR
// end ; continue ;
52128: GO 51696
// end ; for j in tmp do
52130: LD_ADDR_VAR 0 3
52134: PUSH
52135: LD_VAR 0 8
52139: PUSH
52140: FOR_IN
52141: IFFALSE 52477
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52143: LD_VAR 0 3
52147: PUSH
52148: LD_EXP 130
52152: PUSH
52153: LD_VAR 0 2
52157: ARRAY
52158: IN
52159: NOT
52160: PUSH
52161: LD_EXP 130
52165: PUSH
52166: LD_VAR 0 2
52170: ARRAY
52171: PUSH
52172: LD_INT 3
52174: LESS
52175: AND
52176: IFFALSE 52234
// begin SetTag ( j , 121 ) ;
52178: LD_VAR 0 3
52182: PPUSH
52183: LD_INT 121
52185: PPUSH
52186: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52190: LD_ADDR_EXP 130
52194: PUSH
52195: LD_EXP 130
52199: PPUSH
52200: LD_VAR 0 2
52204: PUSH
52205: LD_EXP 130
52209: PUSH
52210: LD_VAR 0 2
52214: ARRAY
52215: PUSH
52216: LD_INT 1
52218: PLUS
52219: PUSH
52220: EMPTY
52221: LIST
52222: LIST
52223: PPUSH
52224: LD_VAR 0 3
52228: PPUSH
52229: CALL 69701 0 3
52233: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52234: LD_VAR 0 3
52238: PUSH
52239: LD_EXP 130
52243: PUSH
52244: LD_VAR 0 2
52248: ARRAY
52249: IN
52250: IFFALSE 52475
// begin if GetClass ( j ) <> 4 then
52252: LD_VAR 0 3
52256: PPUSH
52257: CALL_OW 257
52261: PUSH
52262: LD_INT 4
52264: NONEQUAL
52265: IFFALSE 52318
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52267: LD_ADDR_EXP 130
52271: PUSH
52272: LD_EXP 130
52276: PPUSH
52277: LD_VAR 0 2
52281: PPUSH
52282: LD_EXP 130
52286: PUSH
52287: LD_VAR 0 2
52291: ARRAY
52292: PUSH
52293: LD_VAR 0 3
52297: DIFF
52298: PPUSH
52299: CALL_OW 1
52303: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52304: LD_VAR 0 3
52308: PPUSH
52309: LD_INT 0
52311: PPUSH
52312: CALL_OW 109
// continue ;
52316: GO 52140
// end ; if IsInUnit ( j ) then
52318: LD_VAR 0 3
52322: PPUSH
52323: CALL_OW 310
52327: IFFALSE 52338
// ComExitBuilding ( j ) ;
52329: LD_VAR 0 3
52333: PPUSH
52334: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52338: LD_ADDR_VAR 0 6
52342: PUSH
52343: LD_VAR 0 7
52347: PPUSH
52348: LD_VAR 0 3
52352: PPUSH
52353: CALL_OW 74
52357: ST_TO_ADDR
// if not ape then
52358: LD_VAR 0 6
52362: NOT
52363: IFFALSE 52367
// break ;
52365: GO 52477
// x := GetX ( ape ) ;
52367: LD_ADDR_VAR 0 4
52371: PUSH
52372: LD_VAR 0 6
52376: PPUSH
52377: CALL_OW 250
52381: ST_TO_ADDR
// y := GetY ( ape ) ;
52382: LD_ADDR_VAR 0 5
52386: PUSH
52387: LD_VAR 0 6
52391: PPUSH
52392: CALL_OW 251
52396: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52397: LD_VAR 0 4
52401: PPUSH
52402: LD_VAR 0 5
52406: PPUSH
52407: CALL_OW 488
52411: NOT
52412: PUSH
52413: LD_VAR 0 11
52417: PPUSH
52418: LD_VAR 0 4
52422: PPUSH
52423: LD_VAR 0 5
52427: PPUSH
52428: LD_INT 20
52430: PPUSH
52431: CALL 70597 0 4
52435: PUSH
52436: LD_INT 4
52438: ARRAY
52439: OR
52440: IFFALSE 52444
// break ;
52442: GO 52477
// if not HasTask ( j ) then
52444: LD_VAR 0 3
52448: PPUSH
52449: CALL_OW 314
52453: NOT
52454: IFFALSE 52475
// ComTameXY ( j , x , y ) ;
52456: LD_VAR 0 3
52460: PPUSH
52461: LD_VAR 0 4
52465: PPUSH
52466: LD_VAR 0 5
52470: PPUSH
52471: CALL_OW 131
// end ; end ;
52475: GO 52140
52477: POP
52478: POP
// end ;
52479: GO 51696
52481: POP
52482: POP
// end ;
52483: LD_VAR 0 1
52487: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
52488: LD_INT 0
52490: PPUSH
52491: PPUSH
52492: PPUSH
52493: PPUSH
52494: PPUSH
52495: PPUSH
52496: PPUSH
52497: PPUSH
// if not mc_bases then
52498: LD_EXP 99
52502: NOT
52503: IFFALSE 52507
// exit ;
52505: GO 53133
// for i = 1 to mc_bases do
52507: LD_ADDR_VAR 0 2
52511: PUSH
52512: DOUBLE
52513: LD_INT 1
52515: DEC
52516: ST_TO_ADDR
52517: LD_EXP 99
52521: PUSH
52522: FOR_TO
52523: IFFALSE 53131
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
52525: LD_EXP 128
52529: PUSH
52530: LD_VAR 0 2
52534: ARRAY
52535: NOT
52536: PUSH
52537: LD_EXP 128
52541: PUSH
52542: LD_VAR 0 2
52546: ARRAY
52547: PPUSH
52548: LD_INT 25
52550: PUSH
52551: LD_INT 12
52553: PUSH
52554: EMPTY
52555: LIST
52556: LIST
52557: PPUSH
52558: CALL_OW 72
52562: NOT
52563: OR
52564: IFFALSE 52568
// continue ;
52566: GO 52522
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
52568: LD_ADDR_VAR 0 5
52572: PUSH
52573: LD_EXP 128
52577: PUSH
52578: LD_VAR 0 2
52582: ARRAY
52583: PUSH
52584: LD_INT 1
52586: ARRAY
52587: PPUSH
52588: CALL_OW 255
52592: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
52593: LD_VAR 0 5
52597: PPUSH
52598: LD_INT 2
52600: PPUSH
52601: CALL_OW 325
52605: IFFALSE 52858
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52607: LD_ADDR_VAR 0 4
52611: PUSH
52612: LD_EXP 128
52616: PUSH
52617: LD_VAR 0 2
52621: ARRAY
52622: PPUSH
52623: LD_INT 25
52625: PUSH
52626: LD_INT 16
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: PPUSH
52633: CALL_OW 72
52637: ST_TO_ADDR
// if tmp < 6 then
52638: LD_VAR 0 4
52642: PUSH
52643: LD_INT 6
52645: LESS
52646: IFFALSE 52858
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52648: LD_ADDR_VAR 0 6
52652: PUSH
52653: LD_EXP 99
52657: PUSH
52658: LD_VAR 0 2
52662: ARRAY
52663: PPUSH
52664: LD_INT 2
52666: PUSH
52667: LD_INT 30
52669: PUSH
52670: LD_INT 0
52672: PUSH
52673: EMPTY
52674: LIST
52675: LIST
52676: PUSH
52677: LD_INT 30
52679: PUSH
52680: LD_INT 1
52682: PUSH
52683: EMPTY
52684: LIST
52685: LIST
52686: PUSH
52687: EMPTY
52688: LIST
52689: LIST
52690: LIST
52691: PPUSH
52692: CALL_OW 72
52696: ST_TO_ADDR
// if depot then
52697: LD_VAR 0 6
52701: IFFALSE 52858
// begin selected := 0 ;
52703: LD_ADDR_VAR 0 7
52707: PUSH
52708: LD_INT 0
52710: ST_TO_ADDR
// for j in depot do
52711: LD_ADDR_VAR 0 3
52715: PUSH
52716: LD_VAR 0 6
52720: PUSH
52721: FOR_IN
52722: IFFALSE 52753
// begin if UnitsInside ( j ) < 6 then
52724: LD_VAR 0 3
52728: PPUSH
52729: CALL_OW 313
52733: PUSH
52734: LD_INT 6
52736: LESS
52737: IFFALSE 52751
// begin selected := j ;
52739: LD_ADDR_VAR 0 7
52743: PUSH
52744: LD_VAR 0 3
52748: ST_TO_ADDR
// break ;
52749: GO 52753
// end ; end ;
52751: GO 52721
52753: POP
52754: POP
// if selected then
52755: LD_VAR 0 7
52759: IFFALSE 52858
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
52761: LD_ADDR_VAR 0 3
52765: PUSH
52766: LD_EXP 128
52770: PUSH
52771: LD_VAR 0 2
52775: ARRAY
52776: PPUSH
52777: LD_INT 25
52779: PUSH
52780: LD_INT 12
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: PPUSH
52787: CALL_OW 72
52791: PUSH
52792: FOR_IN
52793: IFFALSE 52856
// if not HasTask ( j ) then
52795: LD_VAR 0 3
52799: PPUSH
52800: CALL_OW 314
52804: NOT
52805: IFFALSE 52854
// begin if not IsInUnit ( j ) then
52807: LD_VAR 0 3
52811: PPUSH
52812: CALL_OW 310
52816: NOT
52817: IFFALSE 52833
// ComEnterUnit ( j , selected ) ;
52819: LD_VAR 0 3
52823: PPUSH
52824: LD_VAR 0 7
52828: PPUSH
52829: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
52833: LD_VAR 0 3
52837: PPUSH
52838: LD_INT 16
52840: PPUSH
52841: CALL_OW 183
// AddComExitBuilding ( j ) ;
52845: LD_VAR 0 3
52849: PPUSH
52850: CALL_OW 182
// end ;
52854: GO 52792
52856: POP
52857: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
52858: LD_VAR 0 5
52862: PPUSH
52863: LD_INT 11
52865: PPUSH
52866: CALL_OW 325
52870: IFFALSE 53129
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52872: LD_ADDR_VAR 0 4
52876: PUSH
52877: LD_EXP 128
52881: PUSH
52882: LD_VAR 0 2
52886: ARRAY
52887: PPUSH
52888: LD_INT 25
52890: PUSH
52891: LD_INT 16
52893: PUSH
52894: EMPTY
52895: LIST
52896: LIST
52897: PPUSH
52898: CALL_OW 72
52902: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
52903: LD_VAR 0 4
52907: PUSH
52908: LD_INT 6
52910: GREATEREQUAL
52911: PUSH
52912: LD_VAR 0 5
52916: PPUSH
52917: LD_INT 2
52919: PPUSH
52920: CALL_OW 325
52924: NOT
52925: OR
52926: IFFALSE 53129
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52928: LD_ADDR_VAR 0 8
52932: PUSH
52933: LD_EXP 99
52937: PUSH
52938: LD_VAR 0 2
52942: ARRAY
52943: PPUSH
52944: LD_INT 2
52946: PUSH
52947: LD_INT 30
52949: PUSH
52950: LD_INT 4
52952: PUSH
52953: EMPTY
52954: LIST
52955: LIST
52956: PUSH
52957: LD_INT 30
52959: PUSH
52960: LD_INT 5
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: PUSH
52967: EMPTY
52968: LIST
52969: LIST
52970: LIST
52971: PPUSH
52972: CALL_OW 72
52976: ST_TO_ADDR
// if barracks then
52977: LD_VAR 0 8
52981: IFFALSE 53129
// begin selected := 0 ;
52983: LD_ADDR_VAR 0 7
52987: PUSH
52988: LD_INT 0
52990: ST_TO_ADDR
// for j in barracks do
52991: LD_ADDR_VAR 0 3
52995: PUSH
52996: LD_VAR 0 8
53000: PUSH
53001: FOR_IN
53002: IFFALSE 53033
// begin if UnitsInside ( j ) < 6 then
53004: LD_VAR 0 3
53008: PPUSH
53009: CALL_OW 313
53013: PUSH
53014: LD_INT 6
53016: LESS
53017: IFFALSE 53031
// begin selected := j ;
53019: LD_ADDR_VAR 0 7
53023: PUSH
53024: LD_VAR 0 3
53028: ST_TO_ADDR
// break ;
53029: GO 53033
// end ; end ;
53031: GO 53001
53033: POP
53034: POP
// if selected then
53035: LD_VAR 0 7
53039: IFFALSE 53129
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53041: LD_ADDR_VAR 0 3
53045: PUSH
53046: LD_EXP 128
53050: PUSH
53051: LD_VAR 0 2
53055: ARRAY
53056: PPUSH
53057: LD_INT 25
53059: PUSH
53060: LD_INT 12
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: PPUSH
53067: CALL_OW 72
53071: PUSH
53072: FOR_IN
53073: IFFALSE 53127
// if not IsInUnit ( j ) and not HasTask ( j ) then
53075: LD_VAR 0 3
53079: PPUSH
53080: CALL_OW 310
53084: NOT
53085: PUSH
53086: LD_VAR 0 3
53090: PPUSH
53091: CALL_OW 314
53095: NOT
53096: AND
53097: IFFALSE 53125
// begin ComEnterUnit ( j , selected ) ;
53099: LD_VAR 0 3
53103: PPUSH
53104: LD_VAR 0 7
53108: PPUSH
53109: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53113: LD_VAR 0 3
53117: PPUSH
53118: LD_INT 15
53120: PPUSH
53121: CALL_OW 183
// end ;
53125: GO 53072
53127: POP
53128: POP
// end ; end ; end ; end ; end ;
53129: GO 52522
53131: POP
53132: POP
// end ;
53133: LD_VAR 0 1
53137: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53138: LD_INT 0
53140: PPUSH
53141: PPUSH
53142: PPUSH
53143: PPUSH
// if not mc_bases then
53144: LD_EXP 99
53148: NOT
53149: IFFALSE 53153
// exit ;
53151: GO 53331
// for i = 1 to mc_bases do
53153: LD_ADDR_VAR 0 2
53157: PUSH
53158: DOUBLE
53159: LD_INT 1
53161: DEC
53162: ST_TO_ADDR
53163: LD_EXP 99
53167: PUSH
53168: FOR_TO
53169: IFFALSE 53329
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53171: LD_ADDR_VAR 0 4
53175: PUSH
53176: LD_EXP 99
53180: PUSH
53181: LD_VAR 0 2
53185: ARRAY
53186: PPUSH
53187: LD_INT 25
53189: PUSH
53190: LD_INT 9
53192: PUSH
53193: EMPTY
53194: LIST
53195: LIST
53196: PPUSH
53197: CALL_OW 72
53201: ST_TO_ADDR
// if not tmp then
53202: LD_VAR 0 4
53206: NOT
53207: IFFALSE 53211
// continue ;
53209: GO 53168
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53211: LD_EXP 125
53215: PUSH
53216: LD_VAR 0 2
53220: ARRAY
53221: PPUSH
53222: LD_INT 29
53224: PPUSH
53225: CALL_OW 325
53229: NOT
53230: PUSH
53231: LD_EXP 125
53235: PUSH
53236: LD_VAR 0 2
53240: ARRAY
53241: PPUSH
53242: LD_INT 28
53244: PPUSH
53245: CALL_OW 325
53249: NOT
53250: AND
53251: IFFALSE 53255
// continue ;
53253: GO 53168
// for j in tmp do
53255: LD_ADDR_VAR 0 3
53259: PUSH
53260: LD_VAR 0 4
53264: PUSH
53265: FOR_IN
53266: IFFALSE 53325
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53268: LD_VAR 0 3
53272: PUSH
53273: LD_EXP 102
53277: PUSH
53278: LD_VAR 0 2
53282: ARRAY
53283: PUSH
53284: LD_INT 1
53286: ARRAY
53287: IN
53288: NOT
53289: PUSH
53290: LD_VAR 0 3
53294: PUSH
53295: LD_EXP 102
53299: PUSH
53300: LD_VAR 0 2
53304: ARRAY
53305: PUSH
53306: LD_INT 2
53308: ARRAY
53309: IN
53310: NOT
53311: AND
53312: IFFALSE 53323
// ComSpaceTimeShoot ( j ) ;
53314: LD_VAR 0 3
53318: PPUSH
53319: CALL 63791 0 1
53323: GO 53265
53325: POP
53326: POP
// end ;
53327: GO 53168
53329: POP
53330: POP
// end ;
53331: LD_VAR 0 1
53335: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53336: LD_INT 0
53338: PPUSH
53339: PPUSH
53340: PPUSH
53341: PPUSH
53342: PPUSH
53343: PPUSH
53344: PPUSH
53345: PPUSH
53346: PPUSH
// if not mc_bases then
53347: LD_EXP 99
53351: NOT
53352: IFFALSE 53356
// exit ;
53354: GO 53978
// for i = 1 to mc_bases do
53356: LD_ADDR_VAR 0 2
53360: PUSH
53361: DOUBLE
53362: LD_INT 1
53364: DEC
53365: ST_TO_ADDR
53366: LD_EXP 99
53370: PUSH
53371: FOR_TO
53372: IFFALSE 53976
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53374: LD_EXP 134
53378: PUSH
53379: LD_VAR 0 2
53383: ARRAY
53384: NOT
53385: PUSH
53386: LD_INT 38
53388: PPUSH
53389: LD_EXP 125
53393: PUSH
53394: LD_VAR 0 2
53398: ARRAY
53399: PPUSH
53400: CALL_OW 321
53404: PUSH
53405: LD_INT 2
53407: NONEQUAL
53408: OR
53409: IFFALSE 53413
// continue ;
53411: GO 53371
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53413: LD_ADDR_VAR 0 8
53417: PUSH
53418: LD_EXP 99
53422: PUSH
53423: LD_VAR 0 2
53427: ARRAY
53428: PPUSH
53429: LD_INT 30
53431: PUSH
53432: LD_INT 34
53434: PUSH
53435: EMPTY
53436: LIST
53437: LIST
53438: PPUSH
53439: CALL_OW 72
53443: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53444: LD_ADDR_VAR 0 9
53448: PUSH
53449: LD_EXP 99
53453: PUSH
53454: LD_VAR 0 2
53458: ARRAY
53459: PPUSH
53460: LD_INT 25
53462: PUSH
53463: LD_INT 4
53465: PUSH
53466: EMPTY
53467: LIST
53468: LIST
53469: PPUSH
53470: CALL_OW 72
53474: PPUSH
53475: LD_INT 0
53477: PPUSH
53478: CALL 102961 0 2
53482: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
53483: LD_VAR 0 9
53487: NOT
53488: PUSH
53489: LD_VAR 0 8
53493: NOT
53494: OR
53495: PUSH
53496: LD_EXP 99
53500: PUSH
53501: LD_VAR 0 2
53505: ARRAY
53506: PPUSH
53507: LD_INT 124
53509: PPUSH
53510: CALL 102961 0 2
53514: OR
53515: IFFALSE 53519
// continue ;
53517: GO 53371
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
53519: LD_EXP 135
53523: PUSH
53524: LD_VAR 0 2
53528: ARRAY
53529: PUSH
53530: LD_EXP 134
53534: PUSH
53535: LD_VAR 0 2
53539: ARRAY
53540: LESS
53541: PUSH
53542: LD_EXP 135
53546: PUSH
53547: LD_VAR 0 2
53551: ARRAY
53552: PUSH
53553: LD_VAR 0 8
53557: LESS
53558: AND
53559: IFFALSE 53974
// begin tmp := sci [ 1 ] ;
53561: LD_ADDR_VAR 0 7
53565: PUSH
53566: LD_VAR 0 9
53570: PUSH
53571: LD_INT 1
53573: ARRAY
53574: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
53575: LD_VAR 0 7
53579: PPUSH
53580: LD_INT 124
53582: PPUSH
53583: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
53587: LD_ADDR_VAR 0 3
53591: PUSH
53592: DOUBLE
53593: LD_EXP 134
53597: PUSH
53598: LD_VAR 0 2
53602: ARRAY
53603: INC
53604: ST_TO_ADDR
53605: LD_EXP 134
53609: PUSH
53610: LD_VAR 0 2
53614: ARRAY
53615: PUSH
53616: FOR_DOWNTO
53617: IFFALSE 53960
// begin if IsInUnit ( tmp ) then
53619: LD_VAR 0 7
53623: PPUSH
53624: CALL_OW 310
53628: IFFALSE 53639
// ComExitBuilding ( tmp ) ;
53630: LD_VAR 0 7
53634: PPUSH
53635: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
53639: LD_INT 35
53641: PPUSH
53642: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
53646: LD_VAR 0 7
53650: PPUSH
53651: CALL_OW 310
53655: NOT
53656: PUSH
53657: LD_VAR 0 7
53661: PPUSH
53662: CALL_OW 314
53666: NOT
53667: AND
53668: IFFALSE 53639
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
53670: LD_ADDR_VAR 0 6
53674: PUSH
53675: LD_VAR 0 7
53679: PPUSH
53680: CALL_OW 250
53684: PUSH
53685: LD_VAR 0 7
53689: PPUSH
53690: CALL_OW 251
53694: PUSH
53695: EMPTY
53696: LIST
53697: LIST
53698: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53699: LD_INT 35
53701: PPUSH
53702: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
53706: LD_ADDR_VAR 0 4
53710: PUSH
53711: LD_EXP 134
53715: PUSH
53716: LD_VAR 0 2
53720: ARRAY
53721: PUSH
53722: LD_VAR 0 3
53726: ARRAY
53727: PUSH
53728: LD_INT 1
53730: ARRAY
53731: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
53732: LD_ADDR_VAR 0 5
53736: PUSH
53737: LD_EXP 134
53741: PUSH
53742: LD_VAR 0 2
53746: ARRAY
53747: PUSH
53748: LD_VAR 0 3
53752: ARRAY
53753: PUSH
53754: LD_INT 2
53756: ARRAY
53757: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
53758: LD_VAR 0 7
53762: PPUSH
53763: LD_INT 10
53765: PPUSH
53766: CALL 72294 0 2
53770: PUSH
53771: LD_INT 4
53773: ARRAY
53774: IFFALSE 53812
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
53776: LD_VAR 0 7
53780: PPUSH
53781: LD_VAR 0 6
53785: PUSH
53786: LD_INT 1
53788: ARRAY
53789: PPUSH
53790: LD_VAR 0 6
53794: PUSH
53795: LD_INT 2
53797: ARRAY
53798: PPUSH
53799: CALL_OW 111
// wait ( 0 0$10 ) ;
53803: LD_INT 350
53805: PPUSH
53806: CALL_OW 67
// end else
53810: GO 53838
// begin ComMoveXY ( tmp , x , y ) ;
53812: LD_VAR 0 7
53816: PPUSH
53817: LD_VAR 0 4
53821: PPUSH
53822: LD_VAR 0 5
53826: PPUSH
53827: CALL_OW 111
// wait ( 0 0$3 ) ;
53831: LD_INT 105
53833: PPUSH
53834: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
53838: LD_VAR 0 7
53842: PPUSH
53843: LD_VAR 0 4
53847: PPUSH
53848: LD_VAR 0 5
53852: PPUSH
53853: CALL_OW 307
53857: IFFALSE 53699
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
53859: LD_VAR 0 7
53863: PPUSH
53864: LD_VAR 0 4
53868: PPUSH
53869: LD_VAR 0 5
53873: PPUSH
53874: LD_VAR 0 8
53878: PUSH
53879: LD_VAR 0 3
53883: ARRAY
53884: PPUSH
53885: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
53889: LD_INT 35
53891: PPUSH
53892: CALL_OW 67
// until not HasTask ( tmp ) ;
53896: LD_VAR 0 7
53900: PPUSH
53901: CALL_OW 314
53905: NOT
53906: IFFALSE 53889
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
53908: LD_ADDR_EXP 135
53912: PUSH
53913: LD_EXP 135
53917: PPUSH
53918: LD_VAR 0 2
53922: PUSH
53923: LD_EXP 135
53927: PUSH
53928: LD_VAR 0 2
53932: ARRAY
53933: PUSH
53934: LD_INT 1
53936: PLUS
53937: PUSH
53938: EMPTY
53939: LIST
53940: LIST
53941: PPUSH
53942: LD_VAR 0 8
53946: PUSH
53947: LD_VAR 0 3
53951: ARRAY
53952: PPUSH
53953: CALL 69701 0 3
53957: ST_TO_ADDR
// end ;
53958: GO 53616
53960: POP
53961: POP
// MC_Reset ( i , 124 ) ;
53962: LD_VAR 0 2
53966: PPUSH
53967: LD_INT 124
53969: PPUSH
53970: CALL 37823 0 2
// end ; end ;
53974: GO 53371
53976: POP
53977: POP
// end ;
53978: LD_VAR 0 1
53982: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
53983: LD_INT 0
53985: PPUSH
53986: PPUSH
53987: PPUSH
// if not mc_bases then
53988: LD_EXP 99
53992: NOT
53993: IFFALSE 53997
// exit ;
53995: GO 54603
// for i = 1 to mc_bases do
53997: LD_ADDR_VAR 0 2
54001: PUSH
54002: DOUBLE
54003: LD_INT 1
54005: DEC
54006: ST_TO_ADDR
54007: LD_EXP 99
54011: PUSH
54012: FOR_TO
54013: IFFALSE 54601
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54015: LD_ADDR_VAR 0 3
54019: PUSH
54020: LD_EXP 99
54024: PUSH
54025: LD_VAR 0 2
54029: ARRAY
54030: PPUSH
54031: LD_INT 25
54033: PUSH
54034: LD_INT 4
54036: PUSH
54037: EMPTY
54038: LIST
54039: LIST
54040: PPUSH
54041: CALL_OW 72
54045: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54046: LD_VAR 0 3
54050: NOT
54051: PUSH
54052: LD_EXP 136
54056: PUSH
54057: LD_VAR 0 2
54061: ARRAY
54062: NOT
54063: OR
54064: PUSH
54065: LD_EXP 99
54069: PUSH
54070: LD_VAR 0 2
54074: ARRAY
54075: PPUSH
54076: LD_INT 2
54078: PUSH
54079: LD_INT 30
54081: PUSH
54082: LD_INT 0
54084: PUSH
54085: EMPTY
54086: LIST
54087: LIST
54088: PUSH
54089: LD_INT 30
54091: PUSH
54092: LD_INT 1
54094: PUSH
54095: EMPTY
54096: LIST
54097: LIST
54098: PUSH
54099: EMPTY
54100: LIST
54101: LIST
54102: LIST
54103: PPUSH
54104: CALL_OW 72
54108: NOT
54109: OR
54110: IFFALSE 54160
// begin if mc_deposits_finder [ i ] then
54112: LD_EXP 137
54116: PUSH
54117: LD_VAR 0 2
54121: ARRAY
54122: IFFALSE 54158
// begin MC_Reset ( i , 125 ) ;
54124: LD_VAR 0 2
54128: PPUSH
54129: LD_INT 125
54131: PPUSH
54132: CALL 37823 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54136: LD_ADDR_EXP 137
54140: PUSH
54141: LD_EXP 137
54145: PPUSH
54146: LD_VAR 0 2
54150: PPUSH
54151: EMPTY
54152: PPUSH
54153: CALL_OW 1
54157: ST_TO_ADDR
// end ; continue ;
54158: GO 54012
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54160: LD_EXP 136
54164: PUSH
54165: LD_VAR 0 2
54169: ARRAY
54170: PUSH
54171: LD_INT 1
54173: ARRAY
54174: PUSH
54175: LD_INT 3
54177: ARRAY
54178: PUSH
54179: LD_INT 1
54181: EQUAL
54182: PUSH
54183: LD_INT 20
54185: PPUSH
54186: LD_EXP 125
54190: PUSH
54191: LD_VAR 0 2
54195: ARRAY
54196: PPUSH
54197: CALL_OW 321
54201: PUSH
54202: LD_INT 2
54204: NONEQUAL
54205: AND
54206: IFFALSE 54256
// begin if mc_deposits_finder [ i ] then
54208: LD_EXP 137
54212: PUSH
54213: LD_VAR 0 2
54217: ARRAY
54218: IFFALSE 54254
// begin MC_Reset ( i , 125 ) ;
54220: LD_VAR 0 2
54224: PPUSH
54225: LD_INT 125
54227: PPUSH
54228: CALL 37823 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54232: LD_ADDR_EXP 137
54236: PUSH
54237: LD_EXP 137
54241: PPUSH
54242: LD_VAR 0 2
54246: PPUSH
54247: EMPTY
54248: PPUSH
54249: CALL_OW 1
54253: ST_TO_ADDR
// end ; continue ;
54254: GO 54012
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54256: LD_EXP 136
54260: PUSH
54261: LD_VAR 0 2
54265: ARRAY
54266: PUSH
54267: LD_INT 1
54269: ARRAY
54270: PUSH
54271: LD_INT 1
54273: ARRAY
54274: PPUSH
54275: LD_EXP 136
54279: PUSH
54280: LD_VAR 0 2
54284: ARRAY
54285: PUSH
54286: LD_INT 1
54288: ARRAY
54289: PUSH
54290: LD_INT 2
54292: ARRAY
54293: PPUSH
54294: LD_EXP 125
54298: PUSH
54299: LD_VAR 0 2
54303: ARRAY
54304: PPUSH
54305: CALL_OW 440
54309: IFFALSE 54352
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54311: LD_ADDR_EXP 136
54315: PUSH
54316: LD_EXP 136
54320: PPUSH
54321: LD_VAR 0 2
54325: PPUSH
54326: LD_EXP 136
54330: PUSH
54331: LD_VAR 0 2
54335: ARRAY
54336: PPUSH
54337: LD_INT 1
54339: PPUSH
54340: CALL_OW 3
54344: PPUSH
54345: CALL_OW 1
54349: ST_TO_ADDR
54350: GO 54599
// begin if not mc_deposits_finder [ i ] then
54352: LD_EXP 137
54356: PUSH
54357: LD_VAR 0 2
54361: ARRAY
54362: NOT
54363: IFFALSE 54415
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54365: LD_ADDR_EXP 137
54369: PUSH
54370: LD_EXP 137
54374: PPUSH
54375: LD_VAR 0 2
54379: PPUSH
54380: LD_VAR 0 3
54384: PUSH
54385: LD_INT 1
54387: ARRAY
54388: PUSH
54389: EMPTY
54390: LIST
54391: PPUSH
54392: CALL_OW 1
54396: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54397: LD_VAR 0 3
54401: PUSH
54402: LD_INT 1
54404: ARRAY
54405: PPUSH
54406: LD_INT 125
54408: PPUSH
54409: CALL_OW 109
// end else
54413: GO 54599
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54415: LD_EXP 137
54419: PUSH
54420: LD_VAR 0 2
54424: ARRAY
54425: PUSH
54426: LD_INT 1
54428: ARRAY
54429: PPUSH
54430: CALL_OW 310
54434: IFFALSE 54457
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54436: LD_EXP 137
54440: PUSH
54441: LD_VAR 0 2
54445: ARRAY
54446: PUSH
54447: LD_INT 1
54449: ARRAY
54450: PPUSH
54451: CALL_OW 122
54455: GO 54599
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54457: LD_EXP 137
54461: PUSH
54462: LD_VAR 0 2
54466: ARRAY
54467: PUSH
54468: LD_INT 1
54470: ARRAY
54471: PPUSH
54472: CALL_OW 314
54476: NOT
54477: PUSH
54478: LD_EXP 137
54482: PUSH
54483: LD_VAR 0 2
54487: ARRAY
54488: PUSH
54489: LD_INT 1
54491: ARRAY
54492: PPUSH
54493: LD_EXP 136
54497: PUSH
54498: LD_VAR 0 2
54502: ARRAY
54503: PUSH
54504: LD_INT 1
54506: ARRAY
54507: PUSH
54508: LD_INT 1
54510: ARRAY
54511: PPUSH
54512: LD_EXP 136
54516: PUSH
54517: LD_VAR 0 2
54521: ARRAY
54522: PUSH
54523: LD_INT 1
54525: ARRAY
54526: PUSH
54527: LD_INT 2
54529: ARRAY
54530: PPUSH
54531: CALL_OW 297
54535: PUSH
54536: LD_INT 6
54538: GREATER
54539: AND
54540: IFFALSE 54599
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
54542: LD_EXP 137
54546: PUSH
54547: LD_VAR 0 2
54551: ARRAY
54552: PUSH
54553: LD_INT 1
54555: ARRAY
54556: PPUSH
54557: LD_EXP 136
54561: PUSH
54562: LD_VAR 0 2
54566: ARRAY
54567: PUSH
54568: LD_INT 1
54570: ARRAY
54571: PUSH
54572: LD_INT 1
54574: ARRAY
54575: PPUSH
54576: LD_EXP 136
54580: PUSH
54581: LD_VAR 0 2
54585: ARRAY
54586: PUSH
54587: LD_INT 1
54589: ARRAY
54590: PUSH
54591: LD_INT 2
54593: ARRAY
54594: PPUSH
54595: CALL_OW 111
// end ; end ; end ;
54599: GO 54012
54601: POP
54602: POP
// end ;
54603: LD_VAR 0 1
54607: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
54608: LD_INT 0
54610: PPUSH
54611: PPUSH
54612: PPUSH
54613: PPUSH
54614: PPUSH
54615: PPUSH
54616: PPUSH
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
// if not mc_bases then
54621: LD_EXP 99
54625: NOT
54626: IFFALSE 54630
// exit ;
54628: GO 55354
// for i = 1 to mc_bases do
54630: LD_ADDR_VAR 0 2
54634: PUSH
54635: DOUBLE
54636: LD_INT 1
54638: DEC
54639: ST_TO_ADDR
54640: LD_EXP 99
54644: PUSH
54645: FOR_TO
54646: IFFALSE 55352
// begin if not mc_bases [ i ] then
54648: LD_EXP 99
54652: PUSH
54653: LD_VAR 0 2
54657: ARRAY
54658: NOT
54659: IFFALSE 54663
// continue ;
54661: GO 54645
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
54663: LD_ADDR_VAR 0 7
54667: PUSH
54668: LD_EXP 99
54672: PUSH
54673: LD_VAR 0 2
54677: ARRAY
54678: PUSH
54679: LD_INT 1
54681: ARRAY
54682: PPUSH
54683: CALL_OW 248
54687: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
54688: LD_VAR 0 7
54692: PUSH
54693: LD_INT 3
54695: EQUAL
54696: PUSH
54697: LD_EXP 118
54701: PUSH
54702: LD_VAR 0 2
54706: ARRAY
54707: PUSH
54708: LD_EXP 121
54712: PUSH
54713: LD_VAR 0 2
54717: ARRAY
54718: UNION
54719: PPUSH
54720: LD_INT 33
54722: PUSH
54723: LD_INT 2
54725: PUSH
54726: EMPTY
54727: LIST
54728: LIST
54729: PPUSH
54730: CALL_OW 72
54734: NOT
54735: OR
54736: IFFALSE 54740
// continue ;
54738: GO 54645
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
54740: LD_ADDR_VAR 0 9
54744: PUSH
54745: LD_EXP 99
54749: PUSH
54750: LD_VAR 0 2
54754: ARRAY
54755: PPUSH
54756: LD_INT 30
54758: PUSH
54759: LD_INT 36
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: PPUSH
54766: CALL_OW 72
54770: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
54771: LD_ADDR_VAR 0 10
54775: PUSH
54776: LD_EXP 118
54780: PUSH
54781: LD_VAR 0 2
54785: ARRAY
54786: PPUSH
54787: LD_INT 34
54789: PUSH
54790: LD_INT 31
54792: PUSH
54793: EMPTY
54794: LIST
54795: LIST
54796: PPUSH
54797: CALL_OW 72
54801: ST_TO_ADDR
// if not cts and not mcts then
54802: LD_VAR 0 9
54806: NOT
54807: PUSH
54808: LD_VAR 0 10
54812: NOT
54813: AND
54814: IFFALSE 54818
// continue ;
54816: GO 54645
// x := cts ;
54818: LD_ADDR_VAR 0 11
54822: PUSH
54823: LD_VAR 0 9
54827: ST_TO_ADDR
// if not x then
54828: LD_VAR 0 11
54832: NOT
54833: IFFALSE 54845
// x := mcts ;
54835: LD_ADDR_VAR 0 11
54839: PUSH
54840: LD_VAR 0 10
54844: ST_TO_ADDR
// if mc_remote_driver [ i ] then
54845: LD_EXP 139
54849: PUSH
54850: LD_VAR 0 2
54854: ARRAY
54855: IFFALSE 55124
// for j in mc_remote_driver [ i ] do
54857: LD_ADDR_VAR 0 3
54861: PUSH
54862: LD_EXP 139
54866: PUSH
54867: LD_VAR 0 2
54871: ARRAY
54872: PUSH
54873: FOR_IN
54874: IFFALSE 55122
// begin if GetClass ( j ) <> 3 then
54876: LD_VAR 0 3
54880: PPUSH
54881: CALL_OW 257
54885: PUSH
54886: LD_INT 3
54888: NONEQUAL
54889: IFFALSE 54942
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
54891: LD_ADDR_EXP 139
54895: PUSH
54896: LD_EXP 139
54900: PPUSH
54901: LD_VAR 0 2
54905: PPUSH
54906: LD_EXP 139
54910: PUSH
54911: LD_VAR 0 2
54915: ARRAY
54916: PUSH
54917: LD_VAR 0 3
54921: DIFF
54922: PPUSH
54923: CALL_OW 1
54927: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54928: LD_VAR 0 3
54932: PPUSH
54933: LD_INT 0
54935: PPUSH
54936: CALL_OW 109
// continue ;
54940: GO 54873
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
54942: LD_VAR 0 3
54946: PPUSH
54947: CALL_OW 310
54951: NOT
54952: PUSH
54953: LD_VAR 0 3
54957: PPUSH
54958: CALL_OW 310
54962: PPUSH
54963: CALL_OW 266
54967: PUSH
54968: LD_INT 36
54970: NONEQUAL
54971: PUSH
54972: LD_VAR 0 3
54976: PPUSH
54977: CALL 103049 0 1
54981: NOT
54982: AND
54983: OR
54984: IFFALSE 55120
// begin if IsInUnit ( j ) then
54986: LD_VAR 0 3
54990: PPUSH
54991: CALL_OW 310
54995: IFFALSE 55006
// ComExitBuilding ( j ) ;
54997: LD_VAR 0 3
55001: PPUSH
55002: CALL_OW 122
// ct := 0 ;
55006: LD_ADDR_VAR 0 8
55010: PUSH
55011: LD_INT 0
55013: ST_TO_ADDR
// for k in x do
55014: LD_ADDR_VAR 0 4
55018: PUSH
55019: LD_VAR 0 11
55023: PUSH
55024: FOR_IN
55025: IFFALSE 55098
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55027: LD_VAR 0 4
55031: PPUSH
55032: CALL_OW 264
55036: PUSH
55037: LD_INT 31
55039: EQUAL
55040: PUSH
55041: LD_VAR 0 4
55045: PPUSH
55046: CALL_OW 311
55050: NOT
55051: AND
55052: PUSH
55053: LD_VAR 0 4
55057: PPUSH
55058: CALL_OW 266
55062: PUSH
55063: LD_INT 36
55065: EQUAL
55066: PUSH
55067: LD_VAR 0 4
55071: PPUSH
55072: CALL_OW 313
55076: PUSH
55077: LD_INT 3
55079: LESS
55080: AND
55081: OR
55082: IFFALSE 55096
// begin ct := k ;
55084: LD_ADDR_VAR 0 8
55088: PUSH
55089: LD_VAR 0 4
55093: ST_TO_ADDR
// break ;
55094: GO 55098
// end ;
55096: GO 55024
55098: POP
55099: POP
// if ct then
55100: LD_VAR 0 8
55104: IFFALSE 55120
// ComEnterUnit ( j , ct ) ;
55106: LD_VAR 0 3
55110: PPUSH
55111: LD_VAR 0 8
55115: PPUSH
55116: CALL_OW 120
// end ; end ;
55120: GO 54873
55122: POP
55123: POP
// places := 0 ;
55124: LD_ADDR_VAR 0 5
55128: PUSH
55129: LD_INT 0
55131: ST_TO_ADDR
// for j = 1 to x do
55132: LD_ADDR_VAR 0 3
55136: PUSH
55137: DOUBLE
55138: LD_INT 1
55140: DEC
55141: ST_TO_ADDR
55142: LD_VAR 0 11
55146: PUSH
55147: FOR_TO
55148: IFFALSE 55203
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55150: LD_VAR 0 11
55154: PUSH
55155: LD_VAR 0 3
55159: ARRAY
55160: PPUSH
55161: CALL_OW 264
55165: PUSH
55166: LD_INT 31
55168: EQUAL
55169: IFFALSE 55187
// places := places + 1 else
55171: LD_ADDR_VAR 0 5
55175: PUSH
55176: LD_VAR 0 5
55180: PUSH
55181: LD_INT 1
55183: PLUS
55184: ST_TO_ADDR
55185: GO 55201
// places := places + 3 ;
55187: LD_ADDR_VAR 0 5
55191: PUSH
55192: LD_VAR 0 5
55196: PUSH
55197: LD_INT 3
55199: PLUS
55200: ST_TO_ADDR
55201: GO 55147
55203: POP
55204: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55205: LD_ADDR_VAR 0 6
55209: PUSH
55210: LD_EXP 99
55214: PUSH
55215: LD_VAR 0 2
55219: ARRAY
55220: PPUSH
55221: LD_INT 25
55223: PUSH
55224: LD_INT 3
55226: PUSH
55227: EMPTY
55228: LIST
55229: LIST
55230: PPUSH
55231: CALL_OW 72
55235: PUSH
55236: LD_EXP 139
55240: PUSH
55241: LD_VAR 0 2
55245: ARRAY
55246: DIFF
55247: PPUSH
55248: LD_INT 3
55250: PPUSH
55251: CALL 103949 0 2
55255: ST_TO_ADDR
// if not tmp then
55256: LD_VAR 0 6
55260: NOT
55261: IFFALSE 55265
// continue ;
55263: GO 54645
// places := places - mc_remote_driver [ i ] ;
55265: LD_ADDR_VAR 0 5
55269: PUSH
55270: LD_VAR 0 5
55274: PUSH
55275: LD_EXP 139
55279: PUSH
55280: LD_VAR 0 2
55284: ARRAY
55285: MINUS
55286: ST_TO_ADDR
// if places then
55287: LD_VAR 0 5
55291: IFFALSE 55350
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
55293: LD_ADDR_EXP 139
55297: PUSH
55298: LD_EXP 139
55302: PPUSH
55303: LD_VAR 0 2
55307: PPUSH
55308: LD_EXP 139
55312: PUSH
55313: LD_VAR 0 2
55317: ARRAY
55318: PUSH
55319: LD_VAR 0 6
55323: PUSH
55324: LD_INT 1
55326: ARRAY
55327: UNION
55328: PPUSH
55329: CALL_OW 1
55333: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
55334: LD_VAR 0 6
55338: PUSH
55339: LD_INT 1
55341: ARRAY
55342: PPUSH
55343: LD_INT 126
55345: PPUSH
55346: CALL_OW 109
// end ; end ;
55350: GO 54645
55352: POP
55353: POP
// end ;
55354: LD_VAR 0 1
55358: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
55359: LD_INT 0
55361: PPUSH
55362: PPUSH
55363: PPUSH
55364: PPUSH
55365: PPUSH
55366: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
55367: LD_VAR 0 1
55371: NOT
55372: PUSH
55373: LD_VAR 0 2
55377: NOT
55378: OR
55379: PUSH
55380: LD_VAR 0 3
55384: NOT
55385: OR
55386: PUSH
55387: LD_VAR 0 4
55391: PUSH
55392: LD_INT 1
55394: PUSH
55395: LD_INT 2
55397: PUSH
55398: LD_INT 3
55400: PUSH
55401: LD_INT 4
55403: PUSH
55404: LD_INT 5
55406: PUSH
55407: LD_INT 8
55409: PUSH
55410: LD_INT 9
55412: PUSH
55413: LD_INT 15
55415: PUSH
55416: LD_INT 16
55418: PUSH
55419: EMPTY
55420: LIST
55421: LIST
55422: LIST
55423: LIST
55424: LIST
55425: LIST
55426: LIST
55427: LIST
55428: LIST
55429: IN
55430: NOT
55431: OR
55432: IFFALSE 55436
// exit ;
55434: GO 56336
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
55436: LD_ADDR_VAR 0 2
55440: PUSH
55441: LD_VAR 0 2
55445: PPUSH
55446: LD_INT 21
55448: PUSH
55449: LD_INT 3
55451: PUSH
55452: EMPTY
55453: LIST
55454: LIST
55455: PUSH
55456: LD_INT 24
55458: PUSH
55459: LD_INT 250
55461: PUSH
55462: EMPTY
55463: LIST
55464: LIST
55465: PUSH
55466: EMPTY
55467: LIST
55468: LIST
55469: PPUSH
55470: CALL_OW 72
55474: ST_TO_ADDR
// case class of 1 , 15 :
55475: LD_VAR 0 4
55479: PUSH
55480: LD_INT 1
55482: DOUBLE
55483: EQUAL
55484: IFTRUE 55494
55486: LD_INT 15
55488: DOUBLE
55489: EQUAL
55490: IFTRUE 55494
55492: GO 55579
55494: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
55495: LD_ADDR_VAR 0 8
55499: PUSH
55500: LD_VAR 0 2
55504: PPUSH
55505: LD_INT 2
55507: PUSH
55508: LD_INT 30
55510: PUSH
55511: LD_INT 32
55513: PUSH
55514: EMPTY
55515: LIST
55516: LIST
55517: PUSH
55518: LD_INT 30
55520: PUSH
55521: LD_INT 31
55523: PUSH
55524: EMPTY
55525: LIST
55526: LIST
55527: PUSH
55528: EMPTY
55529: LIST
55530: LIST
55531: LIST
55532: PPUSH
55533: CALL_OW 72
55537: PUSH
55538: LD_VAR 0 2
55542: PPUSH
55543: LD_INT 2
55545: PUSH
55546: LD_INT 30
55548: PUSH
55549: LD_INT 4
55551: PUSH
55552: EMPTY
55553: LIST
55554: LIST
55555: PUSH
55556: LD_INT 30
55558: PUSH
55559: LD_INT 5
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: LIST
55570: PPUSH
55571: CALL_OW 72
55575: ADD
55576: ST_TO_ADDR
55577: GO 55825
55579: LD_INT 2
55581: DOUBLE
55582: EQUAL
55583: IFTRUE 55593
55585: LD_INT 16
55587: DOUBLE
55588: EQUAL
55589: IFTRUE 55593
55591: GO 55639
55593: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
55594: LD_ADDR_VAR 0 8
55598: PUSH
55599: LD_VAR 0 2
55603: PPUSH
55604: LD_INT 2
55606: PUSH
55607: LD_INT 30
55609: PUSH
55610: LD_INT 0
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: PUSH
55617: LD_INT 30
55619: PUSH
55620: LD_INT 1
55622: PUSH
55623: EMPTY
55624: LIST
55625: LIST
55626: PUSH
55627: EMPTY
55628: LIST
55629: LIST
55630: LIST
55631: PPUSH
55632: CALL_OW 72
55636: ST_TO_ADDR
55637: GO 55825
55639: LD_INT 3
55641: DOUBLE
55642: EQUAL
55643: IFTRUE 55647
55645: GO 55693
55647: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
55648: LD_ADDR_VAR 0 8
55652: PUSH
55653: LD_VAR 0 2
55657: PPUSH
55658: LD_INT 2
55660: PUSH
55661: LD_INT 30
55663: PUSH
55664: LD_INT 2
55666: PUSH
55667: EMPTY
55668: LIST
55669: LIST
55670: PUSH
55671: LD_INT 30
55673: PUSH
55674: LD_INT 3
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: PUSH
55681: EMPTY
55682: LIST
55683: LIST
55684: LIST
55685: PPUSH
55686: CALL_OW 72
55690: ST_TO_ADDR
55691: GO 55825
55693: LD_INT 4
55695: DOUBLE
55696: EQUAL
55697: IFTRUE 55701
55699: GO 55758
55701: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
55702: LD_ADDR_VAR 0 8
55706: PUSH
55707: LD_VAR 0 2
55711: PPUSH
55712: LD_INT 2
55714: PUSH
55715: LD_INT 30
55717: PUSH
55718: LD_INT 6
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: PUSH
55725: LD_INT 30
55727: PUSH
55728: LD_INT 7
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: PUSH
55735: LD_INT 30
55737: PUSH
55738: LD_INT 8
55740: PUSH
55741: EMPTY
55742: LIST
55743: LIST
55744: PUSH
55745: EMPTY
55746: LIST
55747: LIST
55748: LIST
55749: LIST
55750: PPUSH
55751: CALL_OW 72
55755: ST_TO_ADDR
55756: GO 55825
55758: LD_INT 5
55760: DOUBLE
55761: EQUAL
55762: IFTRUE 55778
55764: LD_INT 8
55766: DOUBLE
55767: EQUAL
55768: IFTRUE 55778
55770: LD_INT 9
55772: DOUBLE
55773: EQUAL
55774: IFTRUE 55778
55776: GO 55824
55778: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
55779: LD_ADDR_VAR 0 8
55783: PUSH
55784: LD_VAR 0 2
55788: PPUSH
55789: LD_INT 2
55791: PUSH
55792: LD_INT 30
55794: PUSH
55795: LD_INT 4
55797: PUSH
55798: EMPTY
55799: LIST
55800: LIST
55801: PUSH
55802: LD_INT 30
55804: PUSH
55805: LD_INT 5
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: PUSH
55812: EMPTY
55813: LIST
55814: LIST
55815: LIST
55816: PPUSH
55817: CALL_OW 72
55821: ST_TO_ADDR
55822: GO 55825
55824: POP
// if not tmp then
55825: LD_VAR 0 8
55829: NOT
55830: IFFALSE 55834
// exit ;
55832: GO 56336
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
55834: LD_VAR 0 4
55838: PUSH
55839: LD_INT 1
55841: PUSH
55842: LD_INT 15
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: IN
55849: PUSH
55850: LD_EXP 108
55854: PUSH
55855: LD_VAR 0 1
55859: ARRAY
55860: AND
55861: IFFALSE 56017
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
55863: LD_ADDR_VAR 0 9
55867: PUSH
55868: LD_EXP 108
55872: PUSH
55873: LD_VAR 0 1
55877: ARRAY
55878: PUSH
55879: LD_INT 1
55881: ARRAY
55882: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
55883: LD_VAR 0 9
55887: PUSH
55888: LD_EXP 109
55892: PUSH
55893: LD_VAR 0 1
55897: ARRAY
55898: IN
55899: NOT
55900: IFFALSE 56015
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
55902: LD_ADDR_EXP 109
55906: PUSH
55907: LD_EXP 109
55911: PPUSH
55912: LD_VAR 0 1
55916: PUSH
55917: LD_EXP 109
55921: PUSH
55922: LD_VAR 0 1
55926: ARRAY
55927: PUSH
55928: LD_INT 1
55930: PLUS
55931: PUSH
55932: EMPTY
55933: LIST
55934: LIST
55935: PPUSH
55936: LD_VAR 0 9
55940: PPUSH
55941: CALL 69701 0 3
55945: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
55946: LD_ADDR_EXP 108
55950: PUSH
55951: LD_EXP 108
55955: PPUSH
55956: LD_VAR 0 1
55960: PPUSH
55961: LD_EXP 108
55965: PUSH
55966: LD_VAR 0 1
55970: ARRAY
55971: PUSH
55972: LD_VAR 0 9
55976: DIFF
55977: PPUSH
55978: CALL_OW 1
55982: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
55983: LD_VAR 0 3
55987: PPUSH
55988: LD_EXP 109
55992: PUSH
55993: LD_VAR 0 1
55997: ARRAY
55998: PUSH
55999: LD_EXP 109
56003: PUSH
56004: LD_VAR 0 1
56008: ARRAY
56009: ARRAY
56010: PPUSH
56011: CALL_OW 120
// end ; exit ;
56015: GO 56336
// end ; if tmp > 1 then
56017: LD_VAR 0 8
56021: PUSH
56022: LD_INT 1
56024: GREATER
56025: IFFALSE 56129
// for i = 2 to tmp do
56027: LD_ADDR_VAR 0 6
56031: PUSH
56032: DOUBLE
56033: LD_INT 2
56035: DEC
56036: ST_TO_ADDR
56037: LD_VAR 0 8
56041: PUSH
56042: FOR_TO
56043: IFFALSE 56127
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56045: LD_VAR 0 8
56049: PUSH
56050: LD_VAR 0 6
56054: ARRAY
56055: PPUSH
56056: CALL_OW 461
56060: PUSH
56061: LD_INT 6
56063: EQUAL
56064: IFFALSE 56125
// begin x := tmp [ i ] ;
56066: LD_ADDR_VAR 0 9
56070: PUSH
56071: LD_VAR 0 8
56075: PUSH
56076: LD_VAR 0 6
56080: ARRAY
56081: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56082: LD_ADDR_VAR 0 8
56086: PUSH
56087: LD_VAR 0 8
56091: PPUSH
56092: LD_VAR 0 6
56096: PPUSH
56097: CALL_OW 3
56101: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56102: LD_ADDR_VAR 0 8
56106: PUSH
56107: LD_VAR 0 8
56111: PPUSH
56112: LD_INT 1
56114: PPUSH
56115: LD_VAR 0 9
56119: PPUSH
56120: CALL_OW 2
56124: ST_TO_ADDR
// end ;
56125: GO 56042
56127: POP
56128: POP
// for i in tmp do
56129: LD_ADDR_VAR 0 6
56133: PUSH
56134: LD_VAR 0 8
56138: PUSH
56139: FOR_IN
56140: IFFALSE 56209
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56142: LD_VAR 0 6
56146: PPUSH
56147: CALL_OW 313
56151: PUSH
56152: LD_INT 6
56154: LESS
56155: PUSH
56156: LD_VAR 0 6
56160: PPUSH
56161: CALL_OW 266
56165: PUSH
56166: LD_INT 31
56168: PUSH
56169: LD_INT 32
56171: PUSH
56172: EMPTY
56173: LIST
56174: LIST
56175: IN
56176: NOT
56177: AND
56178: PUSH
56179: LD_VAR 0 6
56183: PPUSH
56184: CALL_OW 313
56188: PUSH
56189: LD_INT 0
56191: EQUAL
56192: OR
56193: IFFALSE 56207
// begin j := i ;
56195: LD_ADDR_VAR 0 7
56199: PUSH
56200: LD_VAR 0 6
56204: ST_TO_ADDR
// break ;
56205: GO 56209
// end ; end ;
56207: GO 56139
56209: POP
56210: POP
// if j then
56211: LD_VAR 0 7
56215: IFFALSE 56233
// ComEnterUnit ( unit , j ) else
56217: LD_VAR 0 3
56221: PPUSH
56222: LD_VAR 0 7
56226: PPUSH
56227: CALL_OW 120
56231: GO 56336
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56233: LD_ADDR_VAR 0 10
56237: PUSH
56238: LD_VAR 0 2
56242: PPUSH
56243: LD_INT 2
56245: PUSH
56246: LD_INT 30
56248: PUSH
56249: LD_INT 0
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: PUSH
56256: LD_INT 30
56258: PUSH
56259: LD_INT 1
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: PUSH
56266: EMPTY
56267: LIST
56268: LIST
56269: LIST
56270: PPUSH
56271: CALL_OW 72
56275: ST_TO_ADDR
// if depot then
56276: LD_VAR 0 10
56280: IFFALSE 56336
// begin depot := NearestUnitToUnit ( depot , unit ) ;
56282: LD_ADDR_VAR 0 10
56286: PUSH
56287: LD_VAR 0 10
56291: PPUSH
56292: LD_VAR 0 3
56296: PPUSH
56297: CALL_OW 74
56301: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
56302: LD_VAR 0 3
56306: PPUSH
56307: LD_VAR 0 10
56311: PPUSH
56312: CALL_OW 296
56316: PUSH
56317: LD_INT 10
56319: GREATER
56320: IFFALSE 56336
// ComStandNearbyBuilding ( unit , depot ) ;
56322: LD_VAR 0 3
56326: PPUSH
56327: LD_VAR 0 10
56331: PPUSH
56332: CALL 64408 0 2
// end ; end ; end ;
56336: LD_VAR 0 5
56340: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
56341: LD_INT 0
56343: PPUSH
56344: PPUSH
56345: PPUSH
56346: PPUSH
// if not mc_bases then
56347: LD_EXP 99
56351: NOT
56352: IFFALSE 56356
// exit ;
56354: GO 56595
// for i = 1 to mc_bases do
56356: LD_ADDR_VAR 0 2
56360: PUSH
56361: DOUBLE
56362: LD_INT 1
56364: DEC
56365: ST_TO_ADDR
56366: LD_EXP 99
56370: PUSH
56371: FOR_TO
56372: IFFALSE 56593
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
56374: LD_ADDR_VAR 0 4
56378: PUSH
56379: LD_EXP 99
56383: PUSH
56384: LD_VAR 0 2
56388: ARRAY
56389: PPUSH
56390: LD_INT 21
56392: PUSH
56393: LD_INT 1
56395: PUSH
56396: EMPTY
56397: LIST
56398: LIST
56399: PPUSH
56400: CALL_OW 72
56404: PUSH
56405: LD_EXP 128
56409: PUSH
56410: LD_VAR 0 2
56414: ARRAY
56415: UNION
56416: ST_TO_ADDR
// if not tmp then
56417: LD_VAR 0 4
56421: NOT
56422: IFFALSE 56426
// continue ;
56424: GO 56371
// for j in tmp do
56426: LD_ADDR_VAR 0 3
56430: PUSH
56431: LD_VAR 0 4
56435: PUSH
56436: FOR_IN
56437: IFFALSE 56589
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
56439: LD_VAR 0 3
56443: PPUSH
56444: CALL_OW 110
56448: NOT
56449: PUSH
56450: LD_VAR 0 3
56454: PPUSH
56455: CALL_OW 314
56459: NOT
56460: AND
56461: PUSH
56462: LD_VAR 0 3
56466: PPUSH
56467: CALL_OW 311
56471: NOT
56472: AND
56473: PUSH
56474: LD_VAR 0 3
56478: PPUSH
56479: CALL_OW 310
56483: NOT
56484: AND
56485: PUSH
56486: LD_VAR 0 3
56490: PUSH
56491: LD_EXP 102
56495: PUSH
56496: LD_VAR 0 2
56500: ARRAY
56501: PUSH
56502: LD_INT 1
56504: ARRAY
56505: IN
56506: NOT
56507: AND
56508: PUSH
56509: LD_VAR 0 3
56513: PUSH
56514: LD_EXP 102
56518: PUSH
56519: LD_VAR 0 2
56523: ARRAY
56524: PUSH
56525: LD_INT 2
56527: ARRAY
56528: IN
56529: NOT
56530: AND
56531: PUSH
56532: LD_VAR 0 3
56536: PUSH
56537: LD_EXP 111
56541: PUSH
56542: LD_VAR 0 2
56546: ARRAY
56547: IN
56548: NOT
56549: AND
56550: IFFALSE 56587
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
56552: LD_VAR 0 2
56556: PPUSH
56557: LD_EXP 99
56561: PUSH
56562: LD_VAR 0 2
56566: ARRAY
56567: PPUSH
56568: LD_VAR 0 3
56572: PPUSH
56573: LD_VAR 0 3
56577: PPUSH
56578: CALL_OW 257
56582: PPUSH
56583: CALL 55359 0 4
// end ;
56587: GO 56436
56589: POP
56590: POP
// end ;
56591: GO 56371
56593: POP
56594: POP
// end ;
56595: LD_VAR 0 1
56599: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
56600: LD_INT 0
56602: PPUSH
56603: PPUSH
56604: PPUSH
56605: PPUSH
56606: PPUSH
56607: PPUSH
// if not mc_bases [ base ] then
56608: LD_EXP 99
56612: PUSH
56613: LD_VAR 0 1
56617: ARRAY
56618: NOT
56619: IFFALSE 56623
// exit ;
56621: GO 56805
// tmp := [ ] ;
56623: LD_ADDR_VAR 0 6
56627: PUSH
56628: EMPTY
56629: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
56630: LD_ADDR_VAR 0 7
56634: PUSH
56635: LD_VAR 0 3
56639: PPUSH
56640: LD_INT 0
56642: PPUSH
56643: CALL_OW 517
56647: ST_TO_ADDR
// if not list then
56648: LD_VAR 0 7
56652: NOT
56653: IFFALSE 56657
// exit ;
56655: GO 56805
// for i = 1 to amount do
56657: LD_ADDR_VAR 0 5
56661: PUSH
56662: DOUBLE
56663: LD_INT 1
56665: DEC
56666: ST_TO_ADDR
56667: LD_VAR 0 2
56671: PUSH
56672: FOR_TO
56673: IFFALSE 56753
// begin x := rand ( 1 , list [ 1 ] ) ;
56675: LD_ADDR_VAR 0 8
56679: PUSH
56680: LD_INT 1
56682: PPUSH
56683: LD_VAR 0 7
56687: PUSH
56688: LD_INT 1
56690: ARRAY
56691: PPUSH
56692: CALL_OW 12
56696: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
56697: LD_ADDR_VAR 0 6
56701: PUSH
56702: LD_VAR 0 6
56706: PPUSH
56707: LD_VAR 0 5
56711: PPUSH
56712: LD_VAR 0 7
56716: PUSH
56717: LD_INT 1
56719: ARRAY
56720: PUSH
56721: LD_VAR 0 8
56725: ARRAY
56726: PUSH
56727: LD_VAR 0 7
56731: PUSH
56732: LD_INT 2
56734: ARRAY
56735: PUSH
56736: LD_VAR 0 8
56740: ARRAY
56741: PUSH
56742: EMPTY
56743: LIST
56744: LIST
56745: PPUSH
56746: CALL_OW 1
56750: ST_TO_ADDR
// end ;
56751: GO 56672
56753: POP
56754: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
56755: LD_ADDR_EXP 112
56759: PUSH
56760: LD_EXP 112
56764: PPUSH
56765: LD_VAR 0 1
56769: PPUSH
56770: LD_VAR 0 6
56774: PPUSH
56775: CALL_OW 1
56779: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
56780: LD_ADDR_EXP 114
56784: PUSH
56785: LD_EXP 114
56789: PPUSH
56790: LD_VAR 0 1
56794: PPUSH
56795: LD_VAR 0 3
56799: PPUSH
56800: CALL_OW 1
56804: ST_TO_ADDR
// end ;
56805: LD_VAR 0 4
56809: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
56810: LD_INT 0
56812: PPUSH
// if not mc_bases [ base ] then
56813: LD_EXP 99
56817: PUSH
56818: LD_VAR 0 1
56822: ARRAY
56823: NOT
56824: IFFALSE 56828
// exit ;
56826: GO 56853
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
56828: LD_ADDR_EXP 104
56832: PUSH
56833: LD_EXP 104
56837: PPUSH
56838: LD_VAR 0 1
56842: PPUSH
56843: LD_VAR 0 2
56847: PPUSH
56848: CALL_OW 1
56852: ST_TO_ADDR
// end ;
56853: LD_VAR 0 3
56857: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
56858: LD_INT 0
56860: PPUSH
// if not mc_bases [ base ] then
56861: LD_EXP 99
56865: PUSH
56866: LD_VAR 0 1
56870: ARRAY
56871: NOT
56872: IFFALSE 56876
// exit ;
56874: GO 56913
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
56876: LD_ADDR_EXP 104
56880: PUSH
56881: LD_EXP 104
56885: PPUSH
56886: LD_VAR 0 1
56890: PPUSH
56891: LD_EXP 104
56895: PUSH
56896: LD_VAR 0 1
56900: ARRAY
56901: PUSH
56902: LD_VAR 0 2
56906: UNION
56907: PPUSH
56908: CALL_OW 1
56912: ST_TO_ADDR
// end ;
56913: LD_VAR 0 3
56917: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
56918: LD_INT 0
56920: PPUSH
// if not mc_bases [ base ] then
56921: LD_EXP 99
56925: PUSH
56926: LD_VAR 0 1
56930: ARRAY
56931: NOT
56932: IFFALSE 56936
// exit ;
56934: GO 56961
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
56936: LD_ADDR_EXP 120
56940: PUSH
56941: LD_EXP 120
56945: PPUSH
56946: LD_VAR 0 1
56950: PPUSH
56951: LD_VAR 0 2
56955: PPUSH
56956: CALL_OW 1
56960: ST_TO_ADDR
// end ;
56961: LD_VAR 0 3
56965: RET
// export function MC_InsertProduceList ( base , components ) ; begin
56966: LD_INT 0
56968: PPUSH
// if not mc_bases [ base ] then
56969: LD_EXP 99
56973: PUSH
56974: LD_VAR 0 1
56978: ARRAY
56979: NOT
56980: IFFALSE 56984
// exit ;
56982: GO 57021
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
56984: LD_ADDR_EXP 120
56988: PUSH
56989: LD_EXP 120
56993: PPUSH
56994: LD_VAR 0 1
56998: PPUSH
56999: LD_EXP 120
57003: PUSH
57004: LD_VAR 0 1
57008: ARRAY
57009: PUSH
57010: LD_VAR 0 2
57014: ADD
57015: PPUSH
57016: CALL_OW 1
57020: ST_TO_ADDR
// end ;
57021: LD_VAR 0 3
57025: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57026: LD_INT 0
57028: PPUSH
// if not mc_bases [ base ] then
57029: LD_EXP 99
57033: PUSH
57034: LD_VAR 0 1
57038: ARRAY
57039: NOT
57040: IFFALSE 57044
// exit ;
57042: GO 57098
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57044: LD_ADDR_EXP 121
57048: PUSH
57049: LD_EXP 121
57053: PPUSH
57054: LD_VAR 0 1
57058: PPUSH
57059: LD_VAR 0 2
57063: PPUSH
57064: CALL_OW 1
57068: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57069: LD_ADDR_EXP 110
57073: PUSH
57074: LD_EXP 110
57078: PPUSH
57079: LD_VAR 0 1
57083: PPUSH
57084: LD_VAR 0 2
57088: PUSH
57089: LD_INT 0
57091: PLUS
57092: PPUSH
57093: CALL_OW 1
57097: ST_TO_ADDR
// end ;
57098: LD_VAR 0 3
57102: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57103: LD_INT 0
57105: PPUSH
// if not mc_bases [ base ] then
57106: LD_EXP 99
57110: PUSH
57111: LD_VAR 0 1
57115: ARRAY
57116: NOT
57117: IFFALSE 57121
// exit ;
57119: GO 57146
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57121: LD_ADDR_EXP 110
57125: PUSH
57126: LD_EXP 110
57130: PPUSH
57131: LD_VAR 0 1
57135: PPUSH
57136: LD_VAR 0 2
57140: PPUSH
57141: CALL_OW 1
57145: ST_TO_ADDR
// end ;
57146: LD_VAR 0 3
57150: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57151: LD_INT 0
57153: PPUSH
57154: PPUSH
57155: PPUSH
57156: PPUSH
// if not mc_bases [ base ] then
57157: LD_EXP 99
57161: PUSH
57162: LD_VAR 0 1
57166: ARRAY
57167: NOT
57168: IFFALSE 57172
// exit ;
57170: GO 57237
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57172: LD_ADDR_EXP 119
57176: PUSH
57177: LD_EXP 119
57181: PPUSH
57182: LD_VAR 0 1
57186: PUSH
57187: LD_EXP 119
57191: PUSH
57192: LD_VAR 0 1
57196: ARRAY
57197: PUSH
57198: LD_INT 1
57200: PLUS
57201: PUSH
57202: EMPTY
57203: LIST
57204: LIST
57205: PPUSH
57206: LD_VAR 0 1
57210: PUSH
57211: LD_VAR 0 2
57215: PUSH
57216: LD_VAR 0 3
57220: PUSH
57221: LD_VAR 0 4
57225: PUSH
57226: EMPTY
57227: LIST
57228: LIST
57229: LIST
57230: LIST
57231: PPUSH
57232: CALL 69701 0 3
57236: ST_TO_ADDR
// end ;
57237: LD_VAR 0 5
57241: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57242: LD_INT 0
57244: PPUSH
// if not mc_bases [ base ] then
57245: LD_EXP 99
57249: PUSH
57250: LD_VAR 0 1
57254: ARRAY
57255: NOT
57256: IFFALSE 57260
// exit ;
57258: GO 57285
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
57260: LD_ADDR_EXP 136
57264: PUSH
57265: LD_EXP 136
57269: PPUSH
57270: LD_VAR 0 1
57274: PPUSH
57275: LD_VAR 0 2
57279: PPUSH
57280: CALL_OW 1
57284: ST_TO_ADDR
// end ;
57285: LD_VAR 0 3
57289: RET
// export function MC_GetMinesField ( base ) ; begin
57290: LD_INT 0
57292: PPUSH
// result := mc_mines [ base ] ;
57293: LD_ADDR_VAR 0 2
57297: PUSH
57298: LD_EXP 112
57302: PUSH
57303: LD_VAR 0 1
57307: ARRAY
57308: ST_TO_ADDR
// end ;
57309: LD_VAR 0 2
57313: RET
// export function MC_GetProduceList ( base ) ; begin
57314: LD_INT 0
57316: PPUSH
// result := mc_produce [ base ] ;
57317: LD_ADDR_VAR 0 2
57321: PUSH
57322: LD_EXP 120
57326: PUSH
57327: LD_VAR 0 1
57331: ARRAY
57332: ST_TO_ADDR
// end ;
57333: LD_VAR 0 2
57337: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
57338: LD_INT 0
57340: PPUSH
57341: PPUSH
// if not mc_bases then
57342: LD_EXP 99
57346: NOT
57347: IFFALSE 57351
// exit ;
57349: GO 57416
// if mc_bases [ base ] then
57351: LD_EXP 99
57355: PUSH
57356: LD_VAR 0 1
57360: ARRAY
57361: IFFALSE 57416
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57363: LD_ADDR_VAR 0 3
57367: PUSH
57368: LD_EXP 99
57372: PUSH
57373: LD_VAR 0 1
57377: ARRAY
57378: PPUSH
57379: LD_INT 30
57381: PUSH
57382: LD_VAR 0 2
57386: PUSH
57387: EMPTY
57388: LIST
57389: LIST
57390: PPUSH
57391: CALL_OW 72
57395: ST_TO_ADDR
// if result then
57396: LD_VAR 0 3
57400: IFFALSE 57416
// result := result [ 1 ] ;
57402: LD_ADDR_VAR 0 3
57406: PUSH
57407: LD_VAR 0 3
57411: PUSH
57412: LD_INT 1
57414: ARRAY
57415: ST_TO_ADDR
// end ; end ;
57416: LD_VAR 0 3
57420: RET
// export function MC_SetTame ( base , area ) ; begin
57421: LD_INT 0
57423: PPUSH
// if not mc_bases or not base then
57424: LD_EXP 99
57428: NOT
57429: PUSH
57430: LD_VAR 0 1
57434: NOT
57435: OR
57436: IFFALSE 57440
// exit ;
57438: GO 57465
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
57440: LD_ADDR_EXP 127
57444: PUSH
57445: LD_EXP 127
57449: PPUSH
57450: LD_VAR 0 1
57454: PPUSH
57455: LD_VAR 0 2
57459: PPUSH
57460: CALL_OW 1
57464: ST_TO_ADDR
// end ;
57465: LD_VAR 0 3
57469: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
57470: LD_INT 0
57472: PPUSH
57473: PPUSH
// if not mc_bases or not base then
57474: LD_EXP 99
57478: NOT
57479: PUSH
57480: LD_VAR 0 1
57484: NOT
57485: OR
57486: IFFALSE 57490
// exit ;
57488: GO 57592
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57490: LD_ADDR_VAR 0 4
57494: PUSH
57495: LD_EXP 99
57499: PUSH
57500: LD_VAR 0 1
57504: ARRAY
57505: PPUSH
57506: LD_INT 30
57508: PUSH
57509: LD_VAR 0 2
57513: PUSH
57514: EMPTY
57515: LIST
57516: LIST
57517: PPUSH
57518: CALL_OW 72
57522: ST_TO_ADDR
// if not tmp then
57523: LD_VAR 0 4
57527: NOT
57528: IFFALSE 57532
// exit ;
57530: GO 57592
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
57532: LD_ADDR_EXP 131
57536: PUSH
57537: LD_EXP 131
57541: PPUSH
57542: LD_VAR 0 1
57546: PPUSH
57547: LD_EXP 131
57551: PUSH
57552: LD_VAR 0 1
57556: ARRAY
57557: PPUSH
57558: LD_EXP 131
57562: PUSH
57563: LD_VAR 0 1
57567: ARRAY
57568: PUSH
57569: LD_INT 1
57571: PLUS
57572: PPUSH
57573: LD_VAR 0 4
57577: PUSH
57578: LD_INT 1
57580: ARRAY
57581: PPUSH
57582: CALL_OW 2
57586: PPUSH
57587: CALL_OW 1
57591: ST_TO_ADDR
// end ;
57592: LD_VAR 0 3
57596: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
57597: LD_INT 0
57599: PPUSH
57600: PPUSH
// if not mc_bases or not base or not kinds then
57601: LD_EXP 99
57605: NOT
57606: PUSH
57607: LD_VAR 0 1
57611: NOT
57612: OR
57613: PUSH
57614: LD_VAR 0 2
57618: NOT
57619: OR
57620: IFFALSE 57624
// exit ;
57622: GO 57685
// for i in kinds do
57624: LD_ADDR_VAR 0 4
57628: PUSH
57629: LD_VAR 0 2
57633: PUSH
57634: FOR_IN
57635: IFFALSE 57683
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
57637: LD_ADDR_EXP 133
57641: PUSH
57642: LD_EXP 133
57646: PPUSH
57647: LD_VAR 0 1
57651: PUSH
57652: LD_EXP 133
57656: PUSH
57657: LD_VAR 0 1
57661: ARRAY
57662: PUSH
57663: LD_INT 1
57665: PLUS
57666: PUSH
57667: EMPTY
57668: LIST
57669: LIST
57670: PPUSH
57671: LD_VAR 0 4
57675: PPUSH
57676: CALL 69701 0 3
57680: ST_TO_ADDR
57681: GO 57634
57683: POP
57684: POP
// end ;
57685: LD_VAR 0 3
57689: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
57690: LD_INT 0
57692: PPUSH
// if not mc_bases or not base or not areas then
57693: LD_EXP 99
57697: NOT
57698: PUSH
57699: LD_VAR 0 1
57703: NOT
57704: OR
57705: PUSH
57706: LD_VAR 0 2
57710: NOT
57711: OR
57712: IFFALSE 57716
// exit ;
57714: GO 57741
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
57716: LD_ADDR_EXP 117
57720: PUSH
57721: LD_EXP 117
57725: PPUSH
57726: LD_VAR 0 1
57730: PPUSH
57731: LD_VAR 0 2
57735: PPUSH
57736: CALL_OW 1
57740: ST_TO_ADDR
// end ;
57741: LD_VAR 0 3
57745: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
57746: LD_INT 0
57748: PPUSH
// if not mc_bases or not base or not teleports_exit then
57749: LD_EXP 99
57753: NOT
57754: PUSH
57755: LD_VAR 0 1
57759: NOT
57760: OR
57761: PUSH
57762: LD_VAR 0 2
57766: NOT
57767: OR
57768: IFFALSE 57772
// exit ;
57770: GO 57797
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
57772: LD_ADDR_EXP 134
57776: PUSH
57777: LD_EXP 134
57781: PPUSH
57782: LD_VAR 0 1
57786: PPUSH
57787: LD_VAR 0 2
57791: PPUSH
57792: CALL_OW 1
57796: ST_TO_ADDR
// end ;
57797: LD_VAR 0 3
57801: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
57802: LD_INT 0
57804: PPUSH
57805: PPUSH
57806: PPUSH
// if not mc_bases or not base or not ext_list then
57807: LD_EXP 99
57811: NOT
57812: PUSH
57813: LD_VAR 0 1
57817: NOT
57818: OR
57819: PUSH
57820: LD_VAR 0 5
57824: NOT
57825: OR
57826: IFFALSE 57830
// exit ;
57828: GO 58003
// tmp := GetFacExtXYD ( x , y , d ) ;
57830: LD_ADDR_VAR 0 8
57834: PUSH
57835: LD_VAR 0 2
57839: PPUSH
57840: LD_VAR 0 3
57844: PPUSH
57845: LD_VAR 0 4
57849: PPUSH
57850: CALL 103079 0 3
57854: ST_TO_ADDR
// if not tmp then
57855: LD_VAR 0 8
57859: NOT
57860: IFFALSE 57864
// exit ;
57862: GO 58003
// for i in tmp do
57864: LD_ADDR_VAR 0 7
57868: PUSH
57869: LD_VAR 0 8
57873: PUSH
57874: FOR_IN
57875: IFFALSE 58001
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
57877: LD_ADDR_EXP 104
57881: PUSH
57882: LD_EXP 104
57886: PPUSH
57887: LD_VAR 0 1
57891: PPUSH
57892: LD_EXP 104
57896: PUSH
57897: LD_VAR 0 1
57901: ARRAY
57902: PPUSH
57903: LD_EXP 104
57907: PUSH
57908: LD_VAR 0 1
57912: ARRAY
57913: PUSH
57914: LD_INT 1
57916: PLUS
57917: PPUSH
57918: LD_VAR 0 5
57922: PUSH
57923: LD_INT 1
57925: ARRAY
57926: PUSH
57927: LD_VAR 0 7
57931: PUSH
57932: LD_INT 1
57934: ARRAY
57935: PUSH
57936: LD_VAR 0 7
57940: PUSH
57941: LD_INT 2
57943: ARRAY
57944: PUSH
57945: LD_VAR 0 7
57949: PUSH
57950: LD_INT 3
57952: ARRAY
57953: PUSH
57954: EMPTY
57955: LIST
57956: LIST
57957: LIST
57958: LIST
57959: PPUSH
57960: CALL_OW 2
57964: PPUSH
57965: CALL_OW 1
57969: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
57970: LD_ADDR_VAR 0 5
57974: PUSH
57975: LD_VAR 0 5
57979: PPUSH
57980: LD_INT 1
57982: PPUSH
57983: CALL_OW 3
57987: ST_TO_ADDR
// if not ext_list then
57988: LD_VAR 0 5
57992: NOT
57993: IFFALSE 57999
// exit ;
57995: POP
57996: POP
57997: GO 58003
// end ;
57999: GO 57874
58001: POP
58002: POP
// end ;
58003: LD_VAR 0 6
58007: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58008: LD_INT 0
58010: PPUSH
// if not mc_bases or not base or not weapon_list then
58011: LD_EXP 99
58015: NOT
58016: PUSH
58017: LD_VAR 0 1
58021: NOT
58022: OR
58023: PUSH
58024: LD_VAR 0 2
58028: NOT
58029: OR
58030: IFFALSE 58034
// exit ;
58032: GO 58059
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58034: LD_ADDR_EXP 138
58038: PUSH
58039: LD_EXP 138
58043: PPUSH
58044: LD_VAR 0 1
58048: PPUSH
58049: LD_VAR 0 2
58053: PPUSH
58054: CALL_OW 1
58058: ST_TO_ADDR
// end ;
58059: LD_VAR 0 3
58063: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58064: LD_INT 0
58066: PPUSH
// if not mc_bases or not base or not tech_list then
58067: LD_EXP 99
58071: NOT
58072: PUSH
58073: LD_VAR 0 1
58077: NOT
58078: OR
58079: PUSH
58080: LD_VAR 0 2
58084: NOT
58085: OR
58086: IFFALSE 58090
// exit ;
58088: GO 58115
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58090: LD_ADDR_EXP 126
58094: PUSH
58095: LD_EXP 126
58099: PPUSH
58100: LD_VAR 0 1
58104: PPUSH
58105: LD_VAR 0 2
58109: PPUSH
58110: CALL_OW 1
58114: ST_TO_ADDR
// end ;
58115: LD_VAR 0 3
58119: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58120: LD_INT 0
58122: PPUSH
// if not mc_bases or not parking_area or not base then
58123: LD_EXP 99
58127: NOT
58128: PUSH
58129: LD_VAR 0 2
58133: NOT
58134: OR
58135: PUSH
58136: LD_VAR 0 1
58140: NOT
58141: OR
58142: IFFALSE 58146
// exit ;
58144: GO 58171
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58146: LD_ADDR_EXP 123
58150: PUSH
58151: LD_EXP 123
58155: PPUSH
58156: LD_VAR 0 1
58160: PPUSH
58161: LD_VAR 0 2
58165: PPUSH
58166: CALL_OW 1
58170: ST_TO_ADDR
// end ;
58171: LD_VAR 0 3
58175: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58176: LD_INT 0
58178: PPUSH
// if not mc_bases or not base or not scan_area then
58179: LD_EXP 99
58183: NOT
58184: PUSH
58185: LD_VAR 0 1
58189: NOT
58190: OR
58191: PUSH
58192: LD_VAR 0 2
58196: NOT
58197: OR
58198: IFFALSE 58202
// exit ;
58200: GO 58227
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
58202: LD_ADDR_EXP 124
58206: PUSH
58207: LD_EXP 124
58211: PPUSH
58212: LD_VAR 0 1
58216: PPUSH
58217: LD_VAR 0 2
58221: PPUSH
58222: CALL_OW 1
58226: ST_TO_ADDR
// end ;
58227: LD_VAR 0 3
58231: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
58232: LD_INT 0
58234: PPUSH
58235: PPUSH
// if not mc_bases or not base then
58236: LD_EXP 99
58240: NOT
58241: PUSH
58242: LD_VAR 0 1
58246: NOT
58247: OR
58248: IFFALSE 58252
// exit ;
58250: GO 58316
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
58252: LD_ADDR_VAR 0 3
58256: PUSH
58257: LD_INT 1
58259: PUSH
58260: LD_INT 2
58262: PUSH
58263: LD_INT 3
58265: PUSH
58266: LD_INT 4
58268: PUSH
58269: LD_INT 11
58271: PUSH
58272: EMPTY
58273: LIST
58274: LIST
58275: LIST
58276: LIST
58277: LIST
58278: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
58279: LD_ADDR_EXP 126
58283: PUSH
58284: LD_EXP 126
58288: PPUSH
58289: LD_VAR 0 1
58293: PPUSH
58294: LD_EXP 126
58298: PUSH
58299: LD_VAR 0 1
58303: ARRAY
58304: PUSH
58305: LD_VAR 0 3
58309: DIFF
58310: PPUSH
58311: CALL_OW 1
58315: ST_TO_ADDR
// end ;
58316: LD_VAR 0 2
58320: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
58321: LD_INT 0
58323: PPUSH
// result := mc_vehicles [ base ] ;
58324: LD_ADDR_VAR 0 3
58328: PUSH
58329: LD_EXP 118
58333: PUSH
58334: LD_VAR 0 1
58338: ARRAY
58339: ST_TO_ADDR
// if onlyCombat then
58340: LD_VAR 0 2
58344: IFFALSE 58509
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
58346: LD_ADDR_VAR 0 3
58350: PUSH
58351: LD_VAR 0 3
58355: PUSH
58356: LD_VAR 0 3
58360: PPUSH
58361: LD_INT 2
58363: PUSH
58364: LD_INT 34
58366: PUSH
58367: LD_INT 12
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: PUSH
58374: LD_INT 34
58376: PUSH
58377: LD_INT 51
58379: PUSH
58380: EMPTY
58381: LIST
58382: LIST
58383: PUSH
58384: LD_INT 34
58386: PUSH
58387: LD_EXP 93
58391: PUSH
58392: EMPTY
58393: LIST
58394: LIST
58395: PUSH
58396: LD_INT 34
58398: PUSH
58399: LD_INT 32
58401: PUSH
58402: EMPTY
58403: LIST
58404: LIST
58405: PUSH
58406: LD_INT 34
58408: PUSH
58409: LD_INT 13
58411: PUSH
58412: EMPTY
58413: LIST
58414: LIST
58415: PUSH
58416: LD_INT 34
58418: PUSH
58419: LD_INT 52
58421: PUSH
58422: EMPTY
58423: LIST
58424: LIST
58425: PUSH
58426: LD_INT 34
58428: PUSH
58429: LD_INT 14
58431: PUSH
58432: EMPTY
58433: LIST
58434: LIST
58435: PUSH
58436: LD_INT 34
58438: PUSH
58439: LD_INT 53
58441: PUSH
58442: EMPTY
58443: LIST
58444: LIST
58445: PUSH
58446: LD_INT 34
58448: PUSH
58449: LD_EXP 92
58453: PUSH
58454: EMPTY
58455: LIST
58456: LIST
58457: PUSH
58458: LD_INT 34
58460: PUSH
58461: LD_INT 31
58463: PUSH
58464: EMPTY
58465: LIST
58466: LIST
58467: PUSH
58468: LD_INT 34
58470: PUSH
58471: LD_INT 48
58473: PUSH
58474: EMPTY
58475: LIST
58476: LIST
58477: PUSH
58478: LD_INT 34
58480: PUSH
58481: LD_INT 8
58483: PUSH
58484: EMPTY
58485: LIST
58486: LIST
58487: PUSH
58488: EMPTY
58489: LIST
58490: LIST
58491: LIST
58492: LIST
58493: LIST
58494: LIST
58495: LIST
58496: LIST
58497: LIST
58498: LIST
58499: LIST
58500: LIST
58501: LIST
58502: PPUSH
58503: CALL_OW 72
58507: DIFF
58508: ST_TO_ADDR
// end ; end_of_file
58509: LD_VAR 0 3
58513: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
58514: LD_INT 0
58516: PPUSH
58517: PPUSH
58518: PPUSH
// if not mc_bases or not skirmish then
58519: LD_EXP 99
58523: NOT
58524: PUSH
58525: LD_EXP 97
58529: NOT
58530: OR
58531: IFFALSE 58535
// exit ;
58533: GO 58700
// for i = 1 to mc_bases do
58535: LD_ADDR_VAR 0 4
58539: PUSH
58540: DOUBLE
58541: LD_INT 1
58543: DEC
58544: ST_TO_ADDR
58545: LD_EXP 99
58549: PUSH
58550: FOR_TO
58551: IFFALSE 58698
// begin if sci in mc_bases [ i ] then
58553: LD_VAR 0 2
58557: PUSH
58558: LD_EXP 99
58562: PUSH
58563: LD_VAR 0 4
58567: ARRAY
58568: IN
58569: IFFALSE 58696
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
58571: LD_ADDR_EXP 128
58575: PUSH
58576: LD_EXP 128
58580: PPUSH
58581: LD_VAR 0 4
58585: PUSH
58586: LD_EXP 128
58590: PUSH
58591: LD_VAR 0 4
58595: ARRAY
58596: PUSH
58597: LD_INT 1
58599: PLUS
58600: PUSH
58601: EMPTY
58602: LIST
58603: LIST
58604: PPUSH
58605: LD_VAR 0 1
58609: PPUSH
58610: CALL 69701 0 3
58614: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
58615: LD_ADDR_VAR 0 5
58619: PUSH
58620: LD_EXP 99
58624: PUSH
58625: LD_VAR 0 4
58629: ARRAY
58630: PPUSH
58631: LD_INT 2
58633: PUSH
58634: LD_INT 30
58636: PUSH
58637: LD_INT 0
58639: PUSH
58640: EMPTY
58641: LIST
58642: LIST
58643: PUSH
58644: LD_INT 30
58646: PUSH
58647: LD_INT 1
58649: PUSH
58650: EMPTY
58651: LIST
58652: LIST
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: LIST
58658: PPUSH
58659: CALL_OW 72
58663: PPUSH
58664: LD_VAR 0 1
58668: PPUSH
58669: CALL_OW 74
58673: ST_TO_ADDR
// if tmp then
58674: LD_VAR 0 5
58678: IFFALSE 58694
// ComStandNearbyBuilding ( ape , tmp ) ;
58680: LD_VAR 0 1
58684: PPUSH
58685: LD_VAR 0 5
58689: PPUSH
58690: CALL 64408 0 2
// break ;
58694: GO 58698
// end ; end ;
58696: GO 58550
58698: POP
58699: POP
// end ;
58700: LD_VAR 0 3
58704: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
58705: LD_INT 0
58707: PPUSH
58708: PPUSH
58709: PPUSH
// if not mc_bases or not skirmish then
58710: LD_EXP 99
58714: NOT
58715: PUSH
58716: LD_EXP 97
58720: NOT
58721: OR
58722: IFFALSE 58726
// exit ;
58724: GO 58815
// for i = 1 to mc_bases do
58726: LD_ADDR_VAR 0 4
58730: PUSH
58731: DOUBLE
58732: LD_INT 1
58734: DEC
58735: ST_TO_ADDR
58736: LD_EXP 99
58740: PUSH
58741: FOR_TO
58742: IFFALSE 58813
// begin if building in mc_busy_turret_list [ i ] then
58744: LD_VAR 0 1
58748: PUSH
58749: LD_EXP 109
58753: PUSH
58754: LD_VAR 0 4
58758: ARRAY
58759: IN
58760: IFFALSE 58811
// begin tmp := mc_busy_turret_list [ i ] diff building ;
58762: LD_ADDR_VAR 0 5
58766: PUSH
58767: LD_EXP 109
58771: PUSH
58772: LD_VAR 0 4
58776: ARRAY
58777: PUSH
58778: LD_VAR 0 1
58782: DIFF
58783: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
58784: LD_ADDR_EXP 109
58788: PUSH
58789: LD_EXP 109
58793: PPUSH
58794: LD_VAR 0 4
58798: PPUSH
58799: LD_VAR 0 5
58803: PPUSH
58804: CALL_OW 1
58808: ST_TO_ADDR
// break ;
58809: GO 58813
// end ; end ;
58811: GO 58741
58813: POP
58814: POP
// end ;
58815: LD_VAR 0 3
58819: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
58820: LD_INT 0
58822: PPUSH
58823: PPUSH
58824: PPUSH
// if not mc_bases or not skirmish then
58825: LD_EXP 99
58829: NOT
58830: PUSH
58831: LD_EXP 97
58835: NOT
58836: OR
58837: IFFALSE 58841
// exit ;
58839: GO 59040
// for i = 1 to mc_bases do
58841: LD_ADDR_VAR 0 5
58845: PUSH
58846: DOUBLE
58847: LD_INT 1
58849: DEC
58850: ST_TO_ADDR
58851: LD_EXP 99
58855: PUSH
58856: FOR_TO
58857: IFFALSE 59038
// if building in mc_bases [ i ] then
58859: LD_VAR 0 1
58863: PUSH
58864: LD_EXP 99
58868: PUSH
58869: LD_VAR 0 5
58873: ARRAY
58874: IN
58875: IFFALSE 59036
// begin tmp := mc_bases [ i ] diff building ;
58877: LD_ADDR_VAR 0 6
58881: PUSH
58882: LD_EXP 99
58886: PUSH
58887: LD_VAR 0 5
58891: ARRAY
58892: PUSH
58893: LD_VAR 0 1
58897: DIFF
58898: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
58899: LD_ADDR_EXP 99
58903: PUSH
58904: LD_EXP 99
58908: PPUSH
58909: LD_VAR 0 5
58913: PPUSH
58914: LD_VAR 0 6
58918: PPUSH
58919: CALL_OW 1
58923: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
58924: LD_VAR 0 1
58928: PUSH
58929: LD_EXP 107
58933: PUSH
58934: LD_VAR 0 5
58938: ARRAY
58939: IN
58940: IFFALSE 58979
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
58942: LD_ADDR_EXP 107
58946: PUSH
58947: LD_EXP 107
58951: PPUSH
58952: LD_VAR 0 5
58956: PPUSH
58957: LD_EXP 107
58961: PUSH
58962: LD_VAR 0 5
58966: ARRAY
58967: PUSH
58968: LD_VAR 0 1
58972: DIFF
58973: PPUSH
58974: CALL_OW 1
58978: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
58979: LD_VAR 0 1
58983: PUSH
58984: LD_EXP 108
58988: PUSH
58989: LD_VAR 0 5
58993: ARRAY
58994: IN
58995: IFFALSE 59034
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
58997: LD_ADDR_EXP 108
59001: PUSH
59002: LD_EXP 108
59006: PPUSH
59007: LD_VAR 0 5
59011: PPUSH
59012: LD_EXP 108
59016: PUSH
59017: LD_VAR 0 5
59021: ARRAY
59022: PUSH
59023: LD_VAR 0 1
59027: DIFF
59028: PPUSH
59029: CALL_OW 1
59033: ST_TO_ADDR
// break ;
59034: GO 59038
// end ;
59036: GO 58856
59038: POP
59039: POP
// end ;
59040: LD_VAR 0 4
59044: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59045: LD_INT 0
59047: PPUSH
59048: PPUSH
59049: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59050: LD_EXP 99
59054: NOT
59055: PUSH
59056: LD_EXP 97
59060: NOT
59061: OR
59062: PUSH
59063: LD_VAR 0 3
59067: PUSH
59068: LD_EXP 125
59072: IN
59073: NOT
59074: OR
59075: IFFALSE 59079
// exit ;
59077: GO 59202
// for i = 1 to mc_vehicles do
59079: LD_ADDR_VAR 0 6
59083: PUSH
59084: DOUBLE
59085: LD_INT 1
59087: DEC
59088: ST_TO_ADDR
59089: LD_EXP 118
59093: PUSH
59094: FOR_TO
59095: IFFALSE 59200
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59097: LD_VAR 0 2
59101: PUSH
59102: LD_EXP 118
59106: PUSH
59107: LD_VAR 0 6
59111: ARRAY
59112: IN
59113: PUSH
59114: LD_VAR 0 1
59118: PUSH
59119: LD_EXP 118
59123: PUSH
59124: LD_VAR 0 6
59128: ARRAY
59129: IN
59130: OR
59131: IFFALSE 59198
// begin tmp := mc_vehicles [ i ] diff old ;
59133: LD_ADDR_VAR 0 7
59137: PUSH
59138: LD_EXP 118
59142: PUSH
59143: LD_VAR 0 6
59147: ARRAY
59148: PUSH
59149: LD_VAR 0 2
59153: DIFF
59154: ST_TO_ADDR
// tmp := tmp diff new ;
59155: LD_ADDR_VAR 0 7
59159: PUSH
59160: LD_VAR 0 7
59164: PUSH
59165: LD_VAR 0 1
59169: DIFF
59170: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59171: LD_ADDR_EXP 118
59175: PUSH
59176: LD_EXP 118
59180: PPUSH
59181: LD_VAR 0 6
59185: PPUSH
59186: LD_VAR 0 7
59190: PPUSH
59191: CALL_OW 1
59195: ST_TO_ADDR
// break ;
59196: GO 59200
// end ;
59198: GO 59094
59200: POP
59201: POP
// end ;
59202: LD_VAR 0 5
59206: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
59207: LD_INT 0
59209: PPUSH
59210: PPUSH
59211: PPUSH
59212: PPUSH
// if not mc_bases or not skirmish then
59213: LD_EXP 99
59217: NOT
59218: PUSH
59219: LD_EXP 97
59223: NOT
59224: OR
59225: IFFALSE 59229
// exit ;
59227: GO 59606
// side := GetSide ( vehicle ) ;
59229: LD_ADDR_VAR 0 5
59233: PUSH
59234: LD_VAR 0 1
59238: PPUSH
59239: CALL_OW 255
59243: ST_TO_ADDR
// for i = 1 to mc_bases do
59244: LD_ADDR_VAR 0 4
59248: PUSH
59249: DOUBLE
59250: LD_INT 1
59252: DEC
59253: ST_TO_ADDR
59254: LD_EXP 99
59258: PUSH
59259: FOR_TO
59260: IFFALSE 59604
// begin if factory in mc_bases [ i ] then
59262: LD_VAR 0 2
59266: PUSH
59267: LD_EXP 99
59271: PUSH
59272: LD_VAR 0 4
59276: ARRAY
59277: IN
59278: IFFALSE 59602
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
59280: LD_EXP 121
59284: PUSH
59285: LD_VAR 0 4
59289: ARRAY
59290: PUSH
59291: LD_EXP 110
59295: PUSH
59296: LD_VAR 0 4
59300: ARRAY
59301: LESS
59302: PUSH
59303: LD_VAR 0 1
59307: PPUSH
59308: CALL_OW 264
59312: PUSH
59313: LD_INT 31
59315: PUSH
59316: LD_INT 32
59318: PUSH
59319: LD_INT 51
59321: PUSH
59322: LD_EXP 93
59326: PUSH
59327: LD_INT 12
59329: PUSH
59330: LD_INT 30
59332: PUSH
59333: LD_EXP 92
59337: PUSH
59338: LD_INT 11
59340: PUSH
59341: LD_INT 53
59343: PUSH
59344: LD_INT 14
59346: PUSH
59347: LD_EXP 96
59351: PUSH
59352: LD_INT 29
59354: PUSH
59355: LD_EXP 94
59359: PUSH
59360: LD_INT 13
59362: PUSH
59363: LD_INT 52
59365: PUSH
59366: LD_INT 48
59368: PUSH
59369: LD_INT 8
59371: PUSH
59372: EMPTY
59373: LIST
59374: LIST
59375: LIST
59376: LIST
59377: LIST
59378: LIST
59379: LIST
59380: LIST
59381: LIST
59382: LIST
59383: LIST
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: IN
59391: NOT
59392: AND
59393: IFFALSE 59441
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
59395: LD_ADDR_EXP 121
59399: PUSH
59400: LD_EXP 121
59404: PPUSH
59405: LD_VAR 0 4
59409: PUSH
59410: LD_EXP 121
59414: PUSH
59415: LD_VAR 0 4
59419: ARRAY
59420: PUSH
59421: LD_INT 1
59423: PLUS
59424: PUSH
59425: EMPTY
59426: LIST
59427: LIST
59428: PPUSH
59429: LD_VAR 0 1
59433: PPUSH
59434: CALL 69701 0 3
59438: ST_TO_ADDR
59439: GO 59485
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
59441: LD_ADDR_EXP 118
59445: PUSH
59446: LD_EXP 118
59450: PPUSH
59451: LD_VAR 0 4
59455: PUSH
59456: LD_EXP 118
59460: PUSH
59461: LD_VAR 0 4
59465: ARRAY
59466: PUSH
59467: LD_INT 1
59469: PLUS
59470: PUSH
59471: EMPTY
59472: LIST
59473: LIST
59474: PPUSH
59475: LD_VAR 0 1
59479: PPUSH
59480: CALL 69701 0 3
59484: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
59485: LD_VAR 0 1
59489: PPUSH
59490: CALL_OW 263
59494: PUSH
59495: LD_INT 2
59497: EQUAL
59498: IFFALSE 59518
// begin repeat wait ( 0 0$1 ) ;
59500: LD_INT 35
59502: PPUSH
59503: CALL_OW 67
// until IsControledBy ( vehicle ) ;
59507: LD_VAR 0 1
59511: PPUSH
59512: CALL_OW 312
59516: IFFALSE 59500
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
59518: LD_VAR 0 1
59522: PPUSH
59523: LD_EXP 123
59527: PUSH
59528: LD_VAR 0 4
59532: ARRAY
59533: PPUSH
59534: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
59538: LD_VAR 0 1
59542: PPUSH
59543: CALL_OW 263
59547: PUSH
59548: LD_INT 1
59550: NONEQUAL
59551: IFFALSE 59555
// break ;
59553: GO 59604
// repeat wait ( 0 0$1 ) ;
59555: LD_INT 35
59557: PPUSH
59558: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
59562: LD_VAR 0 1
59566: PPUSH
59567: LD_EXP 123
59571: PUSH
59572: LD_VAR 0 4
59576: ARRAY
59577: PPUSH
59578: CALL_OW 308
59582: IFFALSE 59555
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
59584: LD_VAR 0 1
59588: PPUSH
59589: CALL_OW 311
59593: PPUSH
59594: CALL_OW 121
// exit ;
59598: POP
59599: POP
59600: GO 59606
// end ; end ;
59602: GO 59259
59604: POP
59605: POP
// end ;
59606: LD_VAR 0 3
59610: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
59611: LD_INT 0
59613: PPUSH
59614: PPUSH
59615: PPUSH
59616: PPUSH
// if not mc_bases or not skirmish then
59617: LD_EXP 99
59621: NOT
59622: PUSH
59623: LD_EXP 97
59627: NOT
59628: OR
59629: IFFALSE 59633
// exit ;
59631: GO 59986
// repeat wait ( 0 0$1 ) ;
59633: LD_INT 35
59635: PPUSH
59636: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
59640: LD_VAR 0 2
59644: PPUSH
59645: LD_VAR 0 3
59649: PPUSH
59650: CALL_OW 284
59654: IFFALSE 59633
// if GetResourceTypeXY ( x , y ) = mat_artefact then
59656: LD_VAR 0 2
59660: PPUSH
59661: LD_VAR 0 3
59665: PPUSH
59666: CALL_OW 283
59670: PUSH
59671: LD_INT 4
59673: EQUAL
59674: IFFALSE 59678
// exit ;
59676: GO 59986
// for i = 1 to mc_bases do
59678: LD_ADDR_VAR 0 7
59682: PUSH
59683: DOUBLE
59684: LD_INT 1
59686: DEC
59687: ST_TO_ADDR
59688: LD_EXP 99
59692: PUSH
59693: FOR_TO
59694: IFFALSE 59984
// begin if mc_crates_area [ i ] then
59696: LD_EXP 117
59700: PUSH
59701: LD_VAR 0 7
59705: ARRAY
59706: IFFALSE 59817
// for j in mc_crates_area [ i ] do
59708: LD_ADDR_VAR 0 8
59712: PUSH
59713: LD_EXP 117
59717: PUSH
59718: LD_VAR 0 7
59722: ARRAY
59723: PUSH
59724: FOR_IN
59725: IFFALSE 59815
// if InArea ( x , y , j ) then
59727: LD_VAR 0 2
59731: PPUSH
59732: LD_VAR 0 3
59736: PPUSH
59737: LD_VAR 0 8
59741: PPUSH
59742: CALL_OW 309
59746: IFFALSE 59813
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59748: LD_ADDR_EXP 115
59752: PUSH
59753: LD_EXP 115
59757: PPUSH
59758: LD_VAR 0 7
59762: PUSH
59763: LD_EXP 115
59767: PUSH
59768: LD_VAR 0 7
59772: ARRAY
59773: PUSH
59774: LD_INT 1
59776: PLUS
59777: PUSH
59778: EMPTY
59779: LIST
59780: LIST
59781: PPUSH
59782: LD_VAR 0 4
59786: PUSH
59787: LD_VAR 0 2
59791: PUSH
59792: LD_VAR 0 3
59796: PUSH
59797: EMPTY
59798: LIST
59799: LIST
59800: LIST
59801: PPUSH
59802: CALL 69701 0 3
59806: ST_TO_ADDR
// exit ;
59807: POP
59808: POP
59809: POP
59810: POP
59811: GO 59986
// end ;
59813: GO 59724
59815: POP
59816: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59817: LD_ADDR_VAR 0 9
59821: PUSH
59822: LD_EXP 99
59826: PUSH
59827: LD_VAR 0 7
59831: ARRAY
59832: PPUSH
59833: LD_INT 2
59835: PUSH
59836: LD_INT 30
59838: PUSH
59839: LD_INT 0
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PUSH
59846: LD_INT 30
59848: PUSH
59849: LD_INT 1
59851: PUSH
59852: EMPTY
59853: LIST
59854: LIST
59855: PUSH
59856: EMPTY
59857: LIST
59858: LIST
59859: LIST
59860: PPUSH
59861: CALL_OW 72
59865: ST_TO_ADDR
// if not depot then
59866: LD_VAR 0 9
59870: NOT
59871: IFFALSE 59875
// continue ;
59873: GO 59693
// for j in depot do
59875: LD_ADDR_VAR 0 8
59879: PUSH
59880: LD_VAR 0 9
59884: PUSH
59885: FOR_IN
59886: IFFALSE 59980
// if GetDistUnitXY ( j , x , y ) < 30 then
59888: LD_VAR 0 8
59892: PPUSH
59893: LD_VAR 0 2
59897: PPUSH
59898: LD_VAR 0 3
59902: PPUSH
59903: CALL_OW 297
59907: PUSH
59908: LD_INT 30
59910: LESS
59911: IFFALSE 59978
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59913: LD_ADDR_EXP 115
59917: PUSH
59918: LD_EXP 115
59922: PPUSH
59923: LD_VAR 0 7
59927: PUSH
59928: LD_EXP 115
59932: PUSH
59933: LD_VAR 0 7
59937: ARRAY
59938: PUSH
59939: LD_INT 1
59941: PLUS
59942: PUSH
59943: EMPTY
59944: LIST
59945: LIST
59946: PPUSH
59947: LD_VAR 0 4
59951: PUSH
59952: LD_VAR 0 2
59956: PUSH
59957: LD_VAR 0 3
59961: PUSH
59962: EMPTY
59963: LIST
59964: LIST
59965: LIST
59966: PPUSH
59967: CALL 69701 0 3
59971: ST_TO_ADDR
// exit ;
59972: POP
59973: POP
59974: POP
59975: POP
59976: GO 59986
// end ;
59978: GO 59885
59980: POP
59981: POP
// end ;
59982: GO 59693
59984: POP
59985: POP
// end ;
59986: LD_VAR 0 6
59990: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
59991: LD_INT 0
59993: PPUSH
59994: PPUSH
59995: PPUSH
59996: PPUSH
// if not mc_bases or not skirmish then
59997: LD_EXP 99
60001: NOT
60002: PUSH
60003: LD_EXP 97
60007: NOT
60008: OR
60009: IFFALSE 60013
// exit ;
60011: GO 60290
// side := GetSide ( lab ) ;
60013: LD_ADDR_VAR 0 4
60017: PUSH
60018: LD_VAR 0 2
60022: PPUSH
60023: CALL_OW 255
60027: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60028: LD_VAR 0 4
60032: PUSH
60033: LD_EXP 125
60037: IN
60038: NOT
60039: PUSH
60040: LD_EXP 126
60044: NOT
60045: OR
60046: PUSH
60047: LD_EXP 99
60051: NOT
60052: OR
60053: IFFALSE 60057
// exit ;
60055: GO 60290
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60057: LD_ADDR_EXP 126
60061: PUSH
60062: LD_EXP 126
60066: PPUSH
60067: LD_VAR 0 4
60071: PPUSH
60072: LD_EXP 126
60076: PUSH
60077: LD_VAR 0 4
60081: ARRAY
60082: PUSH
60083: LD_VAR 0 1
60087: DIFF
60088: PPUSH
60089: CALL_OW 1
60093: ST_TO_ADDR
// for i = 1 to mc_bases do
60094: LD_ADDR_VAR 0 5
60098: PUSH
60099: DOUBLE
60100: LD_INT 1
60102: DEC
60103: ST_TO_ADDR
60104: LD_EXP 99
60108: PUSH
60109: FOR_TO
60110: IFFALSE 60288
// begin if lab in mc_bases [ i ] then
60112: LD_VAR 0 2
60116: PUSH
60117: LD_EXP 99
60121: PUSH
60122: LD_VAR 0 5
60126: ARRAY
60127: IN
60128: IFFALSE 60286
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60130: LD_VAR 0 1
60134: PUSH
60135: LD_INT 11
60137: PUSH
60138: LD_INT 4
60140: PUSH
60141: LD_INT 3
60143: PUSH
60144: LD_INT 2
60146: PUSH
60147: EMPTY
60148: LIST
60149: LIST
60150: LIST
60151: LIST
60152: IN
60153: PUSH
60154: LD_EXP 129
60158: PUSH
60159: LD_VAR 0 5
60163: ARRAY
60164: AND
60165: IFFALSE 60286
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60167: LD_ADDR_VAR 0 6
60171: PUSH
60172: LD_EXP 129
60176: PUSH
60177: LD_VAR 0 5
60181: ARRAY
60182: PUSH
60183: LD_INT 1
60185: ARRAY
60186: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60187: LD_ADDR_EXP 129
60191: PUSH
60192: LD_EXP 129
60196: PPUSH
60197: LD_VAR 0 5
60201: PPUSH
60202: EMPTY
60203: PPUSH
60204: CALL_OW 1
60208: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
60209: LD_VAR 0 6
60213: PPUSH
60214: LD_INT 0
60216: PPUSH
60217: CALL_OW 109
// ComExitBuilding ( tmp ) ;
60221: LD_VAR 0 6
60225: PPUSH
60226: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
60230: LD_ADDR_EXP 128
60234: PUSH
60235: LD_EXP 128
60239: PPUSH
60240: LD_VAR 0 5
60244: PPUSH
60245: LD_EXP 128
60249: PUSH
60250: LD_VAR 0 5
60254: ARRAY
60255: PPUSH
60256: LD_INT 1
60258: PPUSH
60259: LD_VAR 0 6
60263: PPUSH
60264: CALL_OW 2
60268: PPUSH
60269: CALL_OW 1
60273: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
60274: LD_VAR 0 5
60278: PPUSH
60279: LD_INT 112
60281: PPUSH
60282: CALL 37823 0 2
// end ; end ; end ;
60286: GO 60109
60288: POP
60289: POP
// end ;
60290: LD_VAR 0 3
60294: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
60295: LD_INT 0
60297: PPUSH
60298: PPUSH
60299: PPUSH
60300: PPUSH
60301: PPUSH
60302: PPUSH
60303: PPUSH
60304: PPUSH
// if not mc_bases or not skirmish then
60305: LD_EXP 99
60309: NOT
60310: PUSH
60311: LD_EXP 97
60315: NOT
60316: OR
60317: IFFALSE 60321
// exit ;
60319: GO 61413
// for i = 1 to mc_bases do
60321: LD_ADDR_VAR 0 3
60325: PUSH
60326: DOUBLE
60327: LD_INT 1
60329: DEC
60330: ST_TO_ADDR
60331: LD_EXP 99
60335: PUSH
60336: FOR_TO
60337: IFFALSE 61411
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
60339: LD_VAR 0 1
60343: PUSH
60344: LD_EXP 99
60348: PUSH
60349: LD_VAR 0 3
60353: ARRAY
60354: IN
60355: PUSH
60356: LD_VAR 0 1
60360: PUSH
60361: LD_EXP 106
60365: PUSH
60366: LD_VAR 0 3
60370: ARRAY
60371: IN
60372: OR
60373: PUSH
60374: LD_VAR 0 1
60378: PUSH
60379: LD_EXP 121
60383: PUSH
60384: LD_VAR 0 3
60388: ARRAY
60389: IN
60390: OR
60391: PUSH
60392: LD_VAR 0 1
60396: PUSH
60397: LD_EXP 118
60401: PUSH
60402: LD_VAR 0 3
60406: ARRAY
60407: IN
60408: OR
60409: PUSH
60410: LD_VAR 0 1
60414: PUSH
60415: LD_EXP 128
60419: PUSH
60420: LD_VAR 0 3
60424: ARRAY
60425: IN
60426: OR
60427: PUSH
60428: LD_VAR 0 1
60432: PUSH
60433: LD_EXP 129
60437: PUSH
60438: LD_VAR 0 3
60442: ARRAY
60443: IN
60444: OR
60445: IFFALSE 61409
// begin if un in mc_ape [ i ] then
60447: LD_VAR 0 1
60451: PUSH
60452: LD_EXP 128
60456: PUSH
60457: LD_VAR 0 3
60461: ARRAY
60462: IN
60463: IFFALSE 60502
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
60465: LD_ADDR_EXP 128
60469: PUSH
60470: LD_EXP 128
60474: PPUSH
60475: LD_VAR 0 3
60479: PPUSH
60480: LD_EXP 128
60484: PUSH
60485: LD_VAR 0 3
60489: ARRAY
60490: PUSH
60491: LD_VAR 0 1
60495: DIFF
60496: PPUSH
60497: CALL_OW 1
60501: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
60502: LD_VAR 0 1
60506: PUSH
60507: LD_EXP 129
60511: PUSH
60512: LD_VAR 0 3
60516: ARRAY
60517: IN
60518: IFFALSE 60542
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60520: LD_ADDR_EXP 129
60524: PUSH
60525: LD_EXP 129
60529: PPUSH
60530: LD_VAR 0 3
60534: PPUSH
60535: EMPTY
60536: PPUSH
60537: CALL_OW 1
60541: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
60542: LD_VAR 0 1
60546: PPUSH
60547: CALL_OW 247
60551: PUSH
60552: LD_INT 2
60554: EQUAL
60555: PUSH
60556: LD_VAR 0 1
60560: PPUSH
60561: CALL_OW 110
60565: PUSH
60566: LD_INT 20
60568: EQUAL
60569: PUSH
60570: LD_VAR 0 1
60574: PUSH
60575: LD_EXP 121
60579: PUSH
60580: LD_VAR 0 3
60584: ARRAY
60585: IN
60586: OR
60587: AND
60588: IFFALSE 60749
// begin if un in mc_defender [ i ] then
60590: LD_VAR 0 1
60594: PUSH
60595: LD_EXP 121
60599: PUSH
60600: LD_VAR 0 3
60604: ARRAY
60605: IN
60606: IFFALSE 60645
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
60608: LD_ADDR_EXP 121
60612: PUSH
60613: LD_EXP 121
60617: PPUSH
60618: LD_VAR 0 3
60622: PPUSH
60623: LD_EXP 121
60627: PUSH
60628: LD_VAR 0 3
60632: ARRAY
60633: PUSH
60634: LD_VAR 0 1
60638: DIFF
60639: PPUSH
60640: CALL_OW 1
60644: ST_TO_ADDR
// fac := MC_GetBuilding ( i , b_factory ) ;
60645: LD_ADDR_VAR 0 8
60649: PUSH
60650: LD_VAR 0 3
60654: PPUSH
60655: LD_INT 3
60657: PPUSH
60658: CALL 57338 0 2
60662: ST_TO_ADDR
// if fac then
60663: LD_VAR 0 8
60667: IFFALSE 60749
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
60669: LD_ADDR_VAR 0 9
60673: PUSH
60674: LD_VAR 0 8
60678: PPUSH
60679: LD_VAR 0 1
60683: PPUSH
60684: CALL_OW 265
60688: PPUSH
60689: LD_VAR 0 1
60693: PPUSH
60694: CALL_OW 262
60698: PPUSH
60699: LD_VAR 0 1
60703: PPUSH
60704: CALL_OW 263
60708: PPUSH
60709: LD_VAR 0 1
60713: PPUSH
60714: CALL_OW 264
60718: PPUSH
60719: CALL 67294 0 5
60723: ST_TO_ADDR
// if components then
60724: LD_VAR 0 9
60728: IFFALSE 60747
// MC_InsertProduceList ( i , [ components ] ) ;
60730: LD_VAR 0 3
60734: PPUSH
60735: LD_VAR 0 9
60739: PUSH
60740: EMPTY
60741: LIST
60742: PPUSH
60743: CALL 56966 0 2
// break ;
60747: GO 61411
// end ; end ; if GetType ( un ) = unit_building then
60749: LD_VAR 0 1
60753: PPUSH
60754: CALL_OW 247
60758: PUSH
60759: LD_INT 3
60761: EQUAL
60762: IFFALSE 61077
// begin btype := GetBType ( un ) ;
60764: LD_ADDR_VAR 0 5
60768: PUSH
60769: LD_VAR 0 1
60773: PPUSH
60774: CALL_OW 266
60778: ST_TO_ADDR
// if btype = b_warehouse then
60779: LD_VAR 0 5
60783: PUSH
60784: LD_INT 1
60786: EQUAL
60787: IFFALSE 60805
// begin btype := b_depot ;
60789: LD_ADDR_VAR 0 5
60793: PUSH
60794: LD_INT 0
60796: ST_TO_ADDR
// pos := 1 ;
60797: LD_ADDR_VAR 0 6
60801: PUSH
60802: LD_INT 1
60804: ST_TO_ADDR
// end ; if btype = b_factory then
60805: LD_VAR 0 5
60809: PUSH
60810: LD_INT 3
60812: EQUAL
60813: IFFALSE 60831
// begin btype := b_workshop ;
60815: LD_ADDR_VAR 0 5
60819: PUSH
60820: LD_INT 2
60822: ST_TO_ADDR
// pos := 1 ;
60823: LD_ADDR_VAR 0 6
60827: PUSH
60828: LD_INT 1
60830: ST_TO_ADDR
// end ; if btype = b_barracks then
60831: LD_VAR 0 5
60835: PUSH
60836: LD_INT 5
60838: EQUAL
60839: IFFALSE 60849
// btype := b_armoury ;
60841: LD_ADDR_VAR 0 5
60845: PUSH
60846: LD_INT 4
60848: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
60849: LD_VAR 0 5
60853: PUSH
60854: LD_INT 7
60856: PUSH
60857: LD_INT 8
60859: PUSH
60860: EMPTY
60861: LIST
60862: LIST
60863: IN
60864: IFFALSE 60874
// btype := b_lab ;
60866: LD_ADDR_VAR 0 5
60870: PUSH
60871: LD_INT 6
60873: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
60874: LD_ADDR_EXP 104
60878: PUSH
60879: LD_EXP 104
60883: PPUSH
60884: LD_VAR 0 3
60888: PUSH
60889: LD_EXP 104
60893: PUSH
60894: LD_VAR 0 3
60898: ARRAY
60899: PUSH
60900: LD_INT 1
60902: PLUS
60903: PUSH
60904: EMPTY
60905: LIST
60906: LIST
60907: PPUSH
60908: LD_VAR 0 5
60912: PUSH
60913: LD_VAR 0 1
60917: PPUSH
60918: CALL_OW 250
60922: PUSH
60923: LD_VAR 0 1
60927: PPUSH
60928: CALL_OW 251
60932: PUSH
60933: LD_VAR 0 1
60937: PPUSH
60938: CALL_OW 254
60942: PUSH
60943: EMPTY
60944: LIST
60945: LIST
60946: LIST
60947: LIST
60948: PPUSH
60949: CALL 69701 0 3
60953: ST_TO_ADDR
// if pos = 1 then
60954: LD_VAR 0 6
60958: PUSH
60959: LD_INT 1
60961: EQUAL
60962: IFFALSE 61077
// begin tmp := mc_build_list [ i ] ;
60964: LD_ADDR_VAR 0 7
60968: PUSH
60969: LD_EXP 104
60973: PUSH
60974: LD_VAR 0 3
60978: ARRAY
60979: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60980: LD_VAR 0 7
60984: PPUSH
60985: LD_INT 2
60987: PUSH
60988: LD_INT 30
60990: PUSH
60991: LD_INT 0
60993: PUSH
60994: EMPTY
60995: LIST
60996: LIST
60997: PUSH
60998: LD_INT 30
61000: PUSH
61001: LD_INT 1
61003: PUSH
61004: EMPTY
61005: LIST
61006: LIST
61007: PUSH
61008: EMPTY
61009: LIST
61010: LIST
61011: LIST
61012: PPUSH
61013: CALL_OW 72
61017: IFFALSE 61027
// pos := 2 ;
61019: LD_ADDR_VAR 0 6
61023: PUSH
61024: LD_INT 2
61026: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
61027: LD_ADDR_VAR 0 7
61031: PUSH
61032: LD_VAR 0 7
61036: PPUSH
61037: LD_VAR 0 6
61041: PPUSH
61042: LD_VAR 0 7
61046: PPUSH
61047: CALL 70027 0 3
61051: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
61052: LD_ADDR_EXP 104
61056: PUSH
61057: LD_EXP 104
61061: PPUSH
61062: LD_VAR 0 3
61066: PPUSH
61067: LD_VAR 0 7
61071: PPUSH
61072: CALL_OW 1
61076: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
61077: LD_VAR 0 1
61081: PUSH
61082: LD_EXP 99
61086: PUSH
61087: LD_VAR 0 3
61091: ARRAY
61092: IN
61093: IFFALSE 61132
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
61095: LD_ADDR_EXP 99
61099: PUSH
61100: LD_EXP 99
61104: PPUSH
61105: LD_VAR 0 3
61109: PPUSH
61110: LD_EXP 99
61114: PUSH
61115: LD_VAR 0 3
61119: ARRAY
61120: PUSH
61121: LD_VAR 0 1
61125: DIFF
61126: PPUSH
61127: CALL_OW 1
61131: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
61132: LD_VAR 0 1
61136: PUSH
61137: LD_EXP 106
61141: PUSH
61142: LD_VAR 0 3
61146: ARRAY
61147: IN
61148: IFFALSE 61187
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
61150: LD_ADDR_EXP 106
61154: PUSH
61155: LD_EXP 106
61159: PPUSH
61160: LD_VAR 0 3
61164: PPUSH
61165: LD_EXP 106
61169: PUSH
61170: LD_VAR 0 3
61174: ARRAY
61175: PUSH
61176: LD_VAR 0 1
61180: DIFF
61181: PPUSH
61182: CALL_OW 1
61186: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
61187: LD_VAR 0 1
61191: PUSH
61192: LD_EXP 118
61196: PUSH
61197: LD_VAR 0 3
61201: ARRAY
61202: IN
61203: IFFALSE 61242
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
61205: LD_ADDR_EXP 118
61209: PUSH
61210: LD_EXP 118
61214: PPUSH
61215: LD_VAR 0 3
61219: PPUSH
61220: LD_EXP 118
61224: PUSH
61225: LD_VAR 0 3
61229: ARRAY
61230: PUSH
61231: LD_VAR 0 1
61235: DIFF
61236: PPUSH
61237: CALL_OW 1
61241: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
61242: LD_VAR 0 1
61246: PUSH
61247: LD_EXP 121
61251: PUSH
61252: LD_VAR 0 3
61256: ARRAY
61257: IN
61258: IFFALSE 61297
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61260: LD_ADDR_EXP 121
61264: PUSH
61265: LD_EXP 121
61269: PPUSH
61270: LD_VAR 0 3
61274: PPUSH
61275: LD_EXP 121
61279: PUSH
61280: LD_VAR 0 3
61284: ARRAY
61285: PUSH
61286: LD_VAR 0 1
61290: DIFF
61291: PPUSH
61292: CALL_OW 1
61296: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
61297: LD_VAR 0 1
61301: PUSH
61302: LD_EXP 108
61306: PUSH
61307: LD_VAR 0 3
61311: ARRAY
61312: IN
61313: IFFALSE 61352
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
61315: LD_ADDR_EXP 108
61319: PUSH
61320: LD_EXP 108
61324: PPUSH
61325: LD_VAR 0 3
61329: PPUSH
61330: LD_EXP 108
61334: PUSH
61335: LD_VAR 0 3
61339: ARRAY
61340: PUSH
61341: LD_VAR 0 1
61345: DIFF
61346: PPUSH
61347: CALL_OW 1
61351: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
61352: LD_VAR 0 1
61356: PUSH
61357: LD_EXP 107
61361: PUSH
61362: LD_VAR 0 3
61366: ARRAY
61367: IN
61368: IFFALSE 61407
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
61370: LD_ADDR_EXP 107
61374: PUSH
61375: LD_EXP 107
61379: PPUSH
61380: LD_VAR 0 3
61384: PPUSH
61385: LD_EXP 107
61389: PUSH
61390: LD_VAR 0 3
61394: ARRAY
61395: PUSH
61396: LD_VAR 0 1
61400: DIFF
61401: PPUSH
61402: CALL_OW 1
61406: ST_TO_ADDR
// end ; break ;
61407: GO 61411
// end ;
61409: GO 60336
61411: POP
61412: POP
// end ;
61413: LD_VAR 0 2
61417: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
61418: LD_INT 0
61420: PPUSH
61421: PPUSH
61422: PPUSH
// if not mc_bases or not skirmish then
61423: LD_EXP 99
61427: NOT
61428: PUSH
61429: LD_EXP 97
61433: NOT
61434: OR
61435: IFFALSE 61439
// exit ;
61437: GO 61654
// for i = 1 to mc_bases do
61439: LD_ADDR_VAR 0 3
61443: PUSH
61444: DOUBLE
61445: LD_INT 1
61447: DEC
61448: ST_TO_ADDR
61449: LD_EXP 99
61453: PUSH
61454: FOR_TO
61455: IFFALSE 61652
// begin if building in mc_construct_list [ i ] then
61457: LD_VAR 0 1
61461: PUSH
61462: LD_EXP 106
61466: PUSH
61467: LD_VAR 0 3
61471: ARRAY
61472: IN
61473: IFFALSE 61650
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61475: LD_ADDR_EXP 106
61479: PUSH
61480: LD_EXP 106
61484: PPUSH
61485: LD_VAR 0 3
61489: PPUSH
61490: LD_EXP 106
61494: PUSH
61495: LD_VAR 0 3
61499: ARRAY
61500: PUSH
61501: LD_VAR 0 1
61505: DIFF
61506: PPUSH
61507: CALL_OW 1
61511: ST_TO_ADDR
// if building in mc_lab [ i ] then
61512: LD_VAR 0 1
61516: PUSH
61517: LD_EXP 132
61521: PUSH
61522: LD_VAR 0 3
61526: ARRAY
61527: IN
61528: IFFALSE 61583
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
61530: LD_ADDR_EXP 133
61534: PUSH
61535: LD_EXP 133
61539: PPUSH
61540: LD_VAR 0 3
61544: PPUSH
61545: LD_EXP 133
61549: PUSH
61550: LD_VAR 0 3
61554: ARRAY
61555: PPUSH
61556: LD_INT 1
61558: PPUSH
61559: LD_EXP 133
61563: PUSH
61564: LD_VAR 0 3
61568: ARRAY
61569: PPUSH
61570: LD_INT 0
61572: PPUSH
61573: CALL 69119 0 4
61577: PPUSH
61578: CALL_OW 1
61582: ST_TO_ADDR
// if not building in mc_bases [ i ] then
61583: LD_VAR 0 1
61587: PUSH
61588: LD_EXP 99
61592: PUSH
61593: LD_VAR 0 3
61597: ARRAY
61598: IN
61599: NOT
61600: IFFALSE 61646
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61602: LD_ADDR_EXP 99
61606: PUSH
61607: LD_EXP 99
61611: PPUSH
61612: LD_VAR 0 3
61616: PUSH
61617: LD_EXP 99
61621: PUSH
61622: LD_VAR 0 3
61626: ARRAY
61627: PUSH
61628: LD_INT 1
61630: PLUS
61631: PUSH
61632: EMPTY
61633: LIST
61634: LIST
61635: PPUSH
61636: LD_VAR 0 1
61640: PPUSH
61641: CALL 69701 0 3
61645: ST_TO_ADDR
// exit ;
61646: POP
61647: POP
61648: GO 61654
// end ; end ;
61650: GO 61454
61652: POP
61653: POP
// end ;
61654: LD_VAR 0 2
61658: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
61659: LD_INT 0
61661: PPUSH
61662: PPUSH
61663: PPUSH
61664: PPUSH
61665: PPUSH
61666: PPUSH
61667: PPUSH
// if not mc_bases or not skirmish then
61668: LD_EXP 99
61672: NOT
61673: PUSH
61674: LD_EXP 97
61678: NOT
61679: OR
61680: IFFALSE 61684
// exit ;
61682: GO 62345
// for i = 1 to mc_bases do
61684: LD_ADDR_VAR 0 3
61688: PUSH
61689: DOUBLE
61690: LD_INT 1
61692: DEC
61693: ST_TO_ADDR
61694: LD_EXP 99
61698: PUSH
61699: FOR_TO
61700: IFFALSE 62343
// begin if building in mc_construct_list [ i ] then
61702: LD_VAR 0 1
61706: PUSH
61707: LD_EXP 106
61711: PUSH
61712: LD_VAR 0 3
61716: ARRAY
61717: IN
61718: IFFALSE 62341
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61720: LD_ADDR_EXP 106
61724: PUSH
61725: LD_EXP 106
61729: PPUSH
61730: LD_VAR 0 3
61734: PPUSH
61735: LD_EXP 106
61739: PUSH
61740: LD_VAR 0 3
61744: ARRAY
61745: PUSH
61746: LD_VAR 0 1
61750: DIFF
61751: PPUSH
61752: CALL_OW 1
61756: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61757: LD_ADDR_EXP 99
61761: PUSH
61762: LD_EXP 99
61766: PPUSH
61767: LD_VAR 0 3
61771: PUSH
61772: LD_EXP 99
61776: PUSH
61777: LD_VAR 0 3
61781: ARRAY
61782: PUSH
61783: LD_INT 1
61785: PLUS
61786: PUSH
61787: EMPTY
61788: LIST
61789: LIST
61790: PPUSH
61791: LD_VAR 0 1
61795: PPUSH
61796: CALL 69701 0 3
61800: ST_TO_ADDR
// btype := GetBType ( building ) ;
61801: LD_ADDR_VAR 0 5
61805: PUSH
61806: LD_VAR 0 1
61810: PPUSH
61811: CALL_OW 266
61815: ST_TO_ADDR
// side := GetSide ( building ) ;
61816: LD_ADDR_VAR 0 8
61820: PUSH
61821: LD_VAR 0 1
61825: PPUSH
61826: CALL_OW 255
61830: ST_TO_ADDR
// if btype = b_lab then
61831: LD_VAR 0 5
61835: PUSH
61836: LD_INT 6
61838: EQUAL
61839: IFFALSE 61889
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
61841: LD_ADDR_EXP 132
61845: PUSH
61846: LD_EXP 132
61850: PPUSH
61851: LD_VAR 0 3
61855: PUSH
61856: LD_EXP 132
61860: PUSH
61861: LD_VAR 0 3
61865: ARRAY
61866: PUSH
61867: LD_INT 1
61869: PLUS
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: PPUSH
61875: LD_VAR 0 1
61879: PPUSH
61880: CALL 69701 0 3
61884: ST_TO_ADDR
// exit ;
61885: POP
61886: POP
61887: GO 62345
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
61889: LD_VAR 0 5
61893: PUSH
61894: LD_INT 0
61896: PUSH
61897: LD_INT 2
61899: PUSH
61900: LD_INT 4
61902: PUSH
61903: EMPTY
61904: LIST
61905: LIST
61906: LIST
61907: IN
61908: IFFALSE 62032
// begin if btype = b_armoury then
61910: LD_VAR 0 5
61914: PUSH
61915: LD_INT 4
61917: EQUAL
61918: IFFALSE 61928
// btype := b_barracks ;
61920: LD_ADDR_VAR 0 5
61924: PUSH
61925: LD_INT 5
61927: ST_TO_ADDR
// if btype = b_depot then
61928: LD_VAR 0 5
61932: PUSH
61933: LD_INT 0
61935: EQUAL
61936: IFFALSE 61946
// btype := b_warehouse ;
61938: LD_ADDR_VAR 0 5
61942: PUSH
61943: LD_INT 1
61945: ST_TO_ADDR
// if btype = b_workshop then
61946: LD_VAR 0 5
61950: PUSH
61951: LD_INT 2
61953: EQUAL
61954: IFFALSE 61964
// btype := b_factory ;
61956: LD_ADDR_VAR 0 5
61960: PUSH
61961: LD_INT 3
61963: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
61964: LD_VAR 0 5
61968: PPUSH
61969: LD_VAR 0 8
61973: PPUSH
61974: CALL_OW 323
61978: PUSH
61979: LD_INT 1
61981: EQUAL
61982: IFFALSE 62028
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
61984: LD_ADDR_EXP 131
61988: PUSH
61989: LD_EXP 131
61993: PPUSH
61994: LD_VAR 0 3
61998: PUSH
61999: LD_EXP 131
62003: PUSH
62004: LD_VAR 0 3
62008: ARRAY
62009: PUSH
62010: LD_INT 1
62012: PLUS
62013: PUSH
62014: EMPTY
62015: LIST
62016: LIST
62017: PPUSH
62018: LD_VAR 0 1
62022: PPUSH
62023: CALL 69701 0 3
62027: ST_TO_ADDR
// exit ;
62028: POP
62029: POP
62030: GO 62345
// end ; if btype in [ b_bunker , b_turret ] then
62032: LD_VAR 0 5
62036: PUSH
62037: LD_INT 32
62039: PUSH
62040: LD_INT 33
62042: PUSH
62043: EMPTY
62044: LIST
62045: LIST
62046: IN
62047: IFFALSE 62337
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
62049: LD_ADDR_EXP 107
62053: PUSH
62054: LD_EXP 107
62058: PPUSH
62059: LD_VAR 0 3
62063: PUSH
62064: LD_EXP 107
62068: PUSH
62069: LD_VAR 0 3
62073: ARRAY
62074: PUSH
62075: LD_INT 1
62077: PLUS
62078: PUSH
62079: EMPTY
62080: LIST
62081: LIST
62082: PPUSH
62083: LD_VAR 0 1
62087: PPUSH
62088: CALL 69701 0 3
62092: ST_TO_ADDR
// if btype = b_bunker then
62093: LD_VAR 0 5
62097: PUSH
62098: LD_INT 32
62100: EQUAL
62101: IFFALSE 62337
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62103: LD_ADDR_EXP 108
62107: PUSH
62108: LD_EXP 108
62112: PPUSH
62113: LD_VAR 0 3
62117: PUSH
62118: LD_EXP 108
62122: PUSH
62123: LD_VAR 0 3
62127: ARRAY
62128: PUSH
62129: LD_INT 1
62131: PLUS
62132: PUSH
62133: EMPTY
62134: LIST
62135: LIST
62136: PPUSH
62137: LD_VAR 0 1
62141: PPUSH
62142: CALL 69701 0 3
62146: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
62147: LD_ADDR_VAR 0 6
62151: PUSH
62152: LD_EXP 99
62156: PUSH
62157: LD_VAR 0 3
62161: ARRAY
62162: PPUSH
62163: LD_INT 25
62165: PUSH
62166: LD_INT 1
62168: PUSH
62169: EMPTY
62170: LIST
62171: LIST
62172: PUSH
62173: LD_INT 3
62175: PUSH
62176: LD_INT 54
62178: PUSH
62179: EMPTY
62180: LIST
62181: PUSH
62182: EMPTY
62183: LIST
62184: LIST
62185: PUSH
62186: EMPTY
62187: LIST
62188: LIST
62189: PPUSH
62190: CALL_OW 72
62194: ST_TO_ADDR
// if tmp then
62195: LD_VAR 0 6
62199: IFFALSE 62205
// exit ;
62201: POP
62202: POP
62203: GO 62345
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62205: LD_ADDR_VAR 0 6
62209: PUSH
62210: LD_EXP 99
62214: PUSH
62215: LD_VAR 0 3
62219: ARRAY
62220: PPUSH
62221: LD_INT 2
62223: PUSH
62224: LD_INT 30
62226: PUSH
62227: LD_INT 4
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: PUSH
62234: LD_INT 30
62236: PUSH
62237: LD_INT 5
62239: PUSH
62240: EMPTY
62241: LIST
62242: LIST
62243: PUSH
62244: EMPTY
62245: LIST
62246: LIST
62247: LIST
62248: PPUSH
62249: CALL_OW 72
62253: ST_TO_ADDR
// if not tmp then
62254: LD_VAR 0 6
62258: NOT
62259: IFFALSE 62265
// exit ;
62261: POP
62262: POP
62263: GO 62345
// for j in tmp do
62265: LD_ADDR_VAR 0 4
62269: PUSH
62270: LD_VAR 0 6
62274: PUSH
62275: FOR_IN
62276: IFFALSE 62335
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
62278: LD_ADDR_VAR 0 7
62282: PUSH
62283: LD_VAR 0 4
62287: PPUSH
62288: CALL_OW 313
62292: PPUSH
62293: LD_INT 25
62295: PUSH
62296: LD_INT 1
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: PPUSH
62303: CALL_OW 72
62307: ST_TO_ADDR
// if units then
62308: LD_VAR 0 7
62312: IFFALSE 62333
// begin ComExitBuilding ( units [ 1 ] ) ;
62314: LD_VAR 0 7
62318: PUSH
62319: LD_INT 1
62321: ARRAY
62322: PPUSH
62323: CALL_OW 122
// exit ;
62327: POP
62328: POP
62329: POP
62330: POP
62331: GO 62345
// end ; end ;
62333: GO 62275
62335: POP
62336: POP
// end ; end ; exit ;
62337: POP
62338: POP
62339: GO 62345
// end ; end ;
62341: GO 61699
62343: POP
62344: POP
// end ;
62345: LD_VAR 0 2
62349: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
62350: LD_INT 0
62352: PPUSH
62353: PPUSH
62354: PPUSH
62355: PPUSH
62356: PPUSH
62357: PPUSH
62358: PPUSH
// if not mc_bases or not skirmish then
62359: LD_EXP 99
62363: NOT
62364: PUSH
62365: LD_EXP 97
62369: NOT
62370: OR
62371: IFFALSE 62375
// exit ;
62373: GO 62606
// btype := GetBType ( building ) ;
62375: LD_ADDR_VAR 0 6
62379: PUSH
62380: LD_VAR 0 1
62384: PPUSH
62385: CALL_OW 266
62389: ST_TO_ADDR
// x := GetX ( building ) ;
62390: LD_ADDR_VAR 0 7
62394: PUSH
62395: LD_VAR 0 1
62399: PPUSH
62400: CALL_OW 250
62404: ST_TO_ADDR
// y := GetY ( building ) ;
62405: LD_ADDR_VAR 0 8
62409: PUSH
62410: LD_VAR 0 1
62414: PPUSH
62415: CALL_OW 251
62419: ST_TO_ADDR
// d := GetDir ( building ) ;
62420: LD_ADDR_VAR 0 9
62424: PUSH
62425: LD_VAR 0 1
62429: PPUSH
62430: CALL_OW 254
62434: ST_TO_ADDR
// for i = 1 to mc_bases do
62435: LD_ADDR_VAR 0 4
62439: PUSH
62440: DOUBLE
62441: LD_INT 1
62443: DEC
62444: ST_TO_ADDR
62445: LD_EXP 99
62449: PUSH
62450: FOR_TO
62451: IFFALSE 62604
// begin if not mc_build_list [ i ] then
62453: LD_EXP 104
62457: PUSH
62458: LD_VAR 0 4
62462: ARRAY
62463: NOT
62464: IFFALSE 62468
// continue ;
62466: GO 62450
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
62468: LD_VAR 0 6
62472: PUSH
62473: LD_VAR 0 7
62477: PUSH
62478: LD_VAR 0 8
62482: PUSH
62483: LD_VAR 0 9
62487: PUSH
62488: EMPTY
62489: LIST
62490: LIST
62491: LIST
62492: LIST
62493: PPUSH
62494: LD_EXP 104
62498: PUSH
62499: LD_VAR 0 4
62503: ARRAY
62504: PUSH
62505: LD_INT 1
62507: ARRAY
62508: PPUSH
62509: CALL 75870 0 2
62513: IFFALSE 62602
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
62515: LD_ADDR_EXP 104
62519: PUSH
62520: LD_EXP 104
62524: PPUSH
62525: LD_VAR 0 4
62529: PPUSH
62530: LD_EXP 104
62534: PUSH
62535: LD_VAR 0 4
62539: ARRAY
62540: PPUSH
62541: LD_INT 1
62543: PPUSH
62544: CALL_OW 3
62548: PPUSH
62549: CALL_OW 1
62553: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
62554: LD_ADDR_EXP 106
62558: PUSH
62559: LD_EXP 106
62563: PPUSH
62564: LD_VAR 0 4
62568: PUSH
62569: LD_EXP 106
62573: PUSH
62574: LD_VAR 0 4
62578: ARRAY
62579: PUSH
62580: LD_INT 1
62582: PLUS
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: PPUSH
62588: LD_VAR 0 1
62592: PPUSH
62593: CALL 69701 0 3
62597: ST_TO_ADDR
// exit ;
62598: POP
62599: POP
62600: GO 62606
// end ; end ;
62602: GO 62450
62604: POP
62605: POP
// end ;
62606: LD_VAR 0 3
62610: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
62611: LD_INT 0
62613: PPUSH
62614: PPUSH
62615: PPUSH
// if not mc_bases or not skirmish then
62616: LD_EXP 99
62620: NOT
62621: PUSH
62622: LD_EXP 97
62626: NOT
62627: OR
62628: IFFALSE 62632
// exit ;
62630: GO 62822
// for i = 1 to mc_bases do
62632: LD_ADDR_VAR 0 4
62636: PUSH
62637: DOUBLE
62638: LD_INT 1
62640: DEC
62641: ST_TO_ADDR
62642: LD_EXP 99
62646: PUSH
62647: FOR_TO
62648: IFFALSE 62735
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
62650: LD_VAR 0 1
62654: PUSH
62655: LD_EXP 107
62659: PUSH
62660: LD_VAR 0 4
62664: ARRAY
62665: IN
62666: PUSH
62667: LD_VAR 0 1
62671: PUSH
62672: LD_EXP 108
62676: PUSH
62677: LD_VAR 0 4
62681: ARRAY
62682: IN
62683: NOT
62684: AND
62685: IFFALSE 62733
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62687: LD_ADDR_EXP 108
62691: PUSH
62692: LD_EXP 108
62696: PPUSH
62697: LD_VAR 0 4
62701: PUSH
62702: LD_EXP 108
62706: PUSH
62707: LD_VAR 0 4
62711: ARRAY
62712: PUSH
62713: LD_INT 1
62715: PLUS
62716: PUSH
62717: EMPTY
62718: LIST
62719: LIST
62720: PPUSH
62721: LD_VAR 0 1
62725: PPUSH
62726: CALL 69701 0 3
62730: ST_TO_ADDR
// break ;
62731: GO 62735
// end ; end ;
62733: GO 62647
62735: POP
62736: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
62737: LD_VAR 0 1
62741: PPUSH
62742: CALL_OW 257
62746: PUSH
62747: LD_EXP 125
62751: IN
62752: PUSH
62753: LD_VAR 0 1
62757: PPUSH
62758: CALL_OW 266
62762: PUSH
62763: LD_INT 5
62765: EQUAL
62766: AND
62767: PUSH
62768: LD_VAR 0 2
62772: PPUSH
62773: CALL_OW 110
62777: PUSH
62778: LD_INT 18
62780: NONEQUAL
62781: AND
62782: IFFALSE 62822
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
62784: LD_VAR 0 2
62788: PPUSH
62789: CALL_OW 257
62793: PUSH
62794: LD_INT 5
62796: PUSH
62797: LD_INT 8
62799: PUSH
62800: LD_INT 9
62802: PUSH
62803: EMPTY
62804: LIST
62805: LIST
62806: LIST
62807: IN
62808: IFFALSE 62822
// SetClass ( unit , 1 ) ;
62810: LD_VAR 0 2
62814: PPUSH
62815: LD_INT 1
62817: PPUSH
62818: CALL_OW 336
// end ;
62822: LD_VAR 0 3
62826: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
62827: LD_INT 0
62829: PPUSH
62830: PPUSH
// if not mc_bases or not skirmish then
62831: LD_EXP 99
62835: NOT
62836: PUSH
62837: LD_EXP 97
62841: NOT
62842: OR
62843: IFFALSE 62847
// exit ;
62845: GO 62963
// if GetLives ( abandoned_vehicle ) > 250 then
62847: LD_VAR 0 2
62851: PPUSH
62852: CALL_OW 256
62856: PUSH
62857: LD_INT 250
62859: GREATER
62860: IFFALSE 62864
// exit ;
62862: GO 62963
// for i = 1 to mc_bases do
62864: LD_ADDR_VAR 0 6
62868: PUSH
62869: DOUBLE
62870: LD_INT 1
62872: DEC
62873: ST_TO_ADDR
62874: LD_EXP 99
62878: PUSH
62879: FOR_TO
62880: IFFALSE 62961
// begin if driver in mc_bases [ i ] then
62882: LD_VAR 0 1
62886: PUSH
62887: LD_EXP 99
62891: PUSH
62892: LD_VAR 0 6
62896: ARRAY
62897: IN
62898: IFFALSE 62959
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
62900: LD_VAR 0 1
62904: PPUSH
62905: LD_EXP 99
62909: PUSH
62910: LD_VAR 0 6
62914: ARRAY
62915: PPUSH
62916: LD_INT 2
62918: PUSH
62919: LD_INT 30
62921: PUSH
62922: LD_INT 0
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: PUSH
62929: LD_INT 30
62931: PUSH
62932: LD_INT 1
62934: PUSH
62935: EMPTY
62936: LIST
62937: LIST
62938: PUSH
62939: EMPTY
62940: LIST
62941: LIST
62942: LIST
62943: PPUSH
62944: CALL_OW 72
62948: PUSH
62949: LD_INT 1
62951: ARRAY
62952: PPUSH
62953: CALL_OW 112
// break ;
62957: GO 62961
// end ; end ;
62959: GO 62879
62961: POP
62962: POP
// end ; end_of_file
62963: LD_VAR 0 5
62967: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
62968: LD_INT 0
62970: PPUSH
62971: PPUSH
// if exist_mode then
62972: LD_VAR 0 2
62976: IFFALSE 63001
// unit := CreateCharacter ( prefix & ident ) else
62978: LD_ADDR_VAR 0 5
62982: PUSH
62983: LD_VAR 0 3
62987: PUSH
62988: LD_VAR 0 1
62992: STR
62993: PPUSH
62994: CALL_OW 34
62998: ST_TO_ADDR
62999: GO 63016
// unit := NewCharacter ( ident ) ;
63001: LD_ADDR_VAR 0 5
63005: PUSH
63006: LD_VAR 0 1
63010: PPUSH
63011: CALL_OW 25
63015: ST_TO_ADDR
// result := unit ;
63016: LD_ADDR_VAR 0 4
63020: PUSH
63021: LD_VAR 0 5
63025: ST_TO_ADDR
// end ;
63026: LD_VAR 0 4
63030: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63031: LD_INT 0
63033: PPUSH
63034: PPUSH
// if not side or not nation then
63035: LD_VAR 0 1
63039: NOT
63040: PUSH
63041: LD_VAR 0 2
63045: NOT
63046: OR
63047: IFFALSE 63051
// exit ;
63049: GO 63695
// case nation of nation_american :
63051: LD_VAR 0 2
63055: PUSH
63056: LD_INT 1
63058: DOUBLE
63059: EQUAL
63060: IFTRUE 63064
63062: GO 63238
63064: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
63065: LD_ADDR_VAR 0 4
63069: PUSH
63070: LD_INT 35
63072: PUSH
63073: LD_INT 45
63075: PUSH
63076: LD_INT 46
63078: PUSH
63079: LD_INT 47
63081: PUSH
63082: LD_INT 1
63084: PUSH
63085: LD_INT 2
63087: PUSH
63088: LD_INT 6
63090: PUSH
63091: LD_INT 15
63093: PUSH
63094: LD_INT 16
63096: PUSH
63097: LD_INT 7
63099: PUSH
63100: LD_INT 12
63102: PUSH
63103: LD_INT 13
63105: PUSH
63106: LD_INT 10
63108: PUSH
63109: LD_INT 14
63111: PUSH
63112: LD_INT 20
63114: PUSH
63115: LD_INT 21
63117: PUSH
63118: LD_INT 22
63120: PUSH
63121: LD_INT 25
63123: PUSH
63124: LD_INT 32
63126: PUSH
63127: LD_INT 27
63129: PUSH
63130: LD_INT 36
63132: PUSH
63133: LD_INT 69
63135: PUSH
63136: LD_INT 39
63138: PUSH
63139: LD_INT 34
63141: PUSH
63142: LD_INT 40
63144: PUSH
63145: LD_INT 48
63147: PUSH
63148: LD_INT 49
63150: PUSH
63151: LD_INT 50
63153: PUSH
63154: LD_INT 51
63156: PUSH
63157: LD_INT 52
63159: PUSH
63160: LD_INT 53
63162: PUSH
63163: LD_INT 54
63165: PUSH
63166: LD_INT 55
63168: PUSH
63169: LD_INT 56
63171: PUSH
63172: LD_INT 57
63174: PUSH
63175: LD_INT 58
63177: PUSH
63178: LD_INT 59
63180: PUSH
63181: LD_INT 60
63183: PUSH
63184: LD_INT 61
63186: PUSH
63187: LD_INT 62
63189: PUSH
63190: LD_INT 80
63192: PUSH
63193: EMPTY
63194: LIST
63195: LIST
63196: LIST
63197: LIST
63198: LIST
63199: LIST
63200: LIST
63201: LIST
63202: LIST
63203: LIST
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: LIST
63224: LIST
63225: LIST
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: ST_TO_ADDR
63236: GO 63619
63238: LD_INT 2
63240: DOUBLE
63241: EQUAL
63242: IFTRUE 63246
63244: GO 63428
63246: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
63247: LD_ADDR_VAR 0 4
63251: PUSH
63252: LD_INT 35
63254: PUSH
63255: LD_INT 45
63257: PUSH
63258: LD_INT 46
63260: PUSH
63261: LD_INT 47
63263: PUSH
63264: LD_INT 70
63266: PUSH
63267: LD_INT 1
63269: PUSH
63270: LD_INT 11
63272: PUSH
63273: LD_INT 3
63275: PUSH
63276: LD_INT 4
63278: PUSH
63279: LD_INT 5
63281: PUSH
63282: LD_INT 6
63284: PUSH
63285: LD_INT 15
63287: PUSH
63288: LD_INT 18
63290: PUSH
63291: LD_INT 7
63293: PUSH
63294: LD_INT 17
63296: PUSH
63297: LD_INT 8
63299: PUSH
63300: LD_INT 20
63302: PUSH
63303: LD_INT 21
63305: PUSH
63306: LD_INT 22
63308: PUSH
63309: LD_INT 72
63311: PUSH
63312: LD_INT 26
63314: PUSH
63315: LD_INT 69
63317: PUSH
63318: LD_INT 39
63320: PUSH
63321: LD_INT 40
63323: PUSH
63324: LD_INT 41
63326: PUSH
63327: LD_INT 42
63329: PUSH
63330: LD_INT 43
63332: PUSH
63333: LD_INT 48
63335: PUSH
63336: LD_INT 49
63338: PUSH
63339: LD_INT 50
63341: PUSH
63342: LD_INT 51
63344: PUSH
63345: LD_INT 52
63347: PUSH
63348: LD_INT 53
63350: PUSH
63351: LD_INT 54
63353: PUSH
63354: LD_INT 55
63356: PUSH
63357: LD_INT 56
63359: PUSH
63360: LD_INT 60
63362: PUSH
63363: LD_INT 61
63365: PUSH
63366: LD_INT 62
63368: PUSH
63369: LD_INT 66
63371: PUSH
63372: LD_INT 67
63374: PUSH
63375: LD_INT 68
63377: PUSH
63378: LD_INT 81
63380: PUSH
63381: EMPTY
63382: LIST
63383: LIST
63384: LIST
63385: LIST
63386: LIST
63387: LIST
63388: LIST
63389: LIST
63390: LIST
63391: LIST
63392: LIST
63393: LIST
63394: LIST
63395: LIST
63396: LIST
63397: LIST
63398: LIST
63399: LIST
63400: LIST
63401: LIST
63402: LIST
63403: LIST
63404: LIST
63405: LIST
63406: LIST
63407: LIST
63408: LIST
63409: LIST
63410: LIST
63411: LIST
63412: LIST
63413: LIST
63414: LIST
63415: LIST
63416: LIST
63417: LIST
63418: LIST
63419: LIST
63420: LIST
63421: LIST
63422: LIST
63423: LIST
63424: LIST
63425: ST_TO_ADDR
63426: GO 63619
63428: LD_INT 3
63430: DOUBLE
63431: EQUAL
63432: IFTRUE 63436
63434: GO 63618
63436: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
63437: LD_ADDR_VAR 0 4
63441: PUSH
63442: LD_INT 46
63444: PUSH
63445: LD_INT 47
63447: PUSH
63448: LD_INT 1
63450: PUSH
63451: LD_INT 2
63453: PUSH
63454: LD_INT 11
63456: PUSH
63457: LD_INT 9
63459: PUSH
63460: LD_INT 20
63462: PUSH
63463: LD_INT 19
63465: PUSH
63466: LD_INT 21
63468: PUSH
63469: LD_INT 24
63471: PUSH
63472: LD_INT 22
63474: PUSH
63475: LD_INT 25
63477: PUSH
63478: LD_INT 28
63480: PUSH
63481: LD_INT 29
63483: PUSH
63484: LD_INT 30
63486: PUSH
63487: LD_INT 31
63489: PUSH
63490: LD_INT 37
63492: PUSH
63493: LD_INT 38
63495: PUSH
63496: LD_INT 32
63498: PUSH
63499: LD_INT 27
63501: PUSH
63502: LD_INT 33
63504: PUSH
63505: LD_INT 69
63507: PUSH
63508: LD_INT 39
63510: PUSH
63511: LD_INT 34
63513: PUSH
63514: LD_INT 40
63516: PUSH
63517: LD_INT 71
63519: PUSH
63520: LD_INT 23
63522: PUSH
63523: LD_INT 44
63525: PUSH
63526: LD_INT 48
63528: PUSH
63529: LD_INT 49
63531: PUSH
63532: LD_INT 50
63534: PUSH
63535: LD_INT 51
63537: PUSH
63538: LD_INT 52
63540: PUSH
63541: LD_INT 53
63543: PUSH
63544: LD_INT 54
63546: PUSH
63547: LD_INT 55
63549: PUSH
63550: LD_INT 56
63552: PUSH
63553: LD_INT 57
63555: PUSH
63556: LD_INT 58
63558: PUSH
63559: LD_INT 59
63561: PUSH
63562: LD_INT 63
63564: PUSH
63565: LD_INT 64
63567: PUSH
63568: LD_INT 65
63570: PUSH
63571: EMPTY
63572: LIST
63573: LIST
63574: LIST
63575: LIST
63576: LIST
63577: LIST
63578: LIST
63579: LIST
63580: LIST
63581: LIST
63582: LIST
63583: LIST
63584: LIST
63585: LIST
63586: LIST
63587: LIST
63588: LIST
63589: LIST
63590: LIST
63591: LIST
63592: LIST
63593: LIST
63594: LIST
63595: LIST
63596: LIST
63597: LIST
63598: LIST
63599: LIST
63600: LIST
63601: LIST
63602: LIST
63603: LIST
63604: LIST
63605: LIST
63606: LIST
63607: LIST
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: ST_TO_ADDR
63616: GO 63619
63618: POP
// if state > - 1 and state < 3 then
63619: LD_VAR 0 3
63623: PUSH
63624: LD_INT 1
63626: NEG
63627: GREATER
63628: PUSH
63629: LD_VAR 0 3
63633: PUSH
63634: LD_INT 3
63636: LESS
63637: AND
63638: IFFALSE 63695
// for i in result do
63640: LD_ADDR_VAR 0 5
63644: PUSH
63645: LD_VAR 0 4
63649: PUSH
63650: FOR_IN
63651: IFFALSE 63693
// if GetTech ( i , side ) <> state then
63653: LD_VAR 0 5
63657: PPUSH
63658: LD_VAR 0 1
63662: PPUSH
63663: CALL_OW 321
63667: PUSH
63668: LD_VAR 0 3
63672: NONEQUAL
63673: IFFALSE 63691
// result := result diff i ;
63675: LD_ADDR_VAR 0 4
63679: PUSH
63680: LD_VAR 0 4
63684: PUSH
63685: LD_VAR 0 5
63689: DIFF
63690: ST_TO_ADDR
63691: GO 63650
63693: POP
63694: POP
// end ;
63695: LD_VAR 0 4
63699: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
63700: LD_INT 0
63702: PPUSH
63703: PPUSH
63704: PPUSH
// result := true ;
63705: LD_ADDR_VAR 0 3
63709: PUSH
63710: LD_INT 1
63712: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
63713: LD_ADDR_VAR 0 5
63717: PUSH
63718: LD_VAR 0 2
63722: PPUSH
63723: CALL_OW 480
63727: ST_TO_ADDR
// if not tmp then
63728: LD_VAR 0 5
63732: NOT
63733: IFFALSE 63737
// exit ;
63735: GO 63786
// for i in tmp do
63737: LD_ADDR_VAR 0 4
63741: PUSH
63742: LD_VAR 0 5
63746: PUSH
63747: FOR_IN
63748: IFFALSE 63784
// if GetTech ( i , side ) <> state_researched then
63750: LD_VAR 0 4
63754: PPUSH
63755: LD_VAR 0 1
63759: PPUSH
63760: CALL_OW 321
63764: PUSH
63765: LD_INT 2
63767: NONEQUAL
63768: IFFALSE 63782
// begin result := false ;
63770: LD_ADDR_VAR 0 3
63774: PUSH
63775: LD_INT 0
63777: ST_TO_ADDR
// exit ;
63778: POP
63779: POP
63780: GO 63786
// end ;
63782: GO 63747
63784: POP
63785: POP
// end ;
63786: LD_VAR 0 3
63790: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
63791: LD_INT 0
63793: PPUSH
63794: PPUSH
63795: PPUSH
63796: PPUSH
63797: PPUSH
63798: PPUSH
63799: PPUSH
63800: PPUSH
63801: PPUSH
63802: PPUSH
63803: PPUSH
63804: PPUSH
63805: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
63806: LD_VAR 0 1
63810: NOT
63811: PUSH
63812: LD_VAR 0 1
63816: PPUSH
63817: CALL_OW 257
63821: PUSH
63822: LD_INT 9
63824: NONEQUAL
63825: OR
63826: IFFALSE 63830
// exit ;
63828: GO 64403
// side := GetSide ( unit ) ;
63830: LD_ADDR_VAR 0 9
63834: PUSH
63835: LD_VAR 0 1
63839: PPUSH
63840: CALL_OW 255
63844: ST_TO_ADDR
// tech_space := tech_spacanom ;
63845: LD_ADDR_VAR 0 12
63849: PUSH
63850: LD_INT 29
63852: ST_TO_ADDR
// tech_time := tech_taurad ;
63853: LD_ADDR_VAR 0 13
63857: PUSH
63858: LD_INT 28
63860: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
63861: LD_ADDR_VAR 0 11
63865: PUSH
63866: LD_VAR 0 1
63870: PPUSH
63871: CALL_OW 310
63875: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
63876: LD_VAR 0 11
63880: PPUSH
63881: CALL_OW 247
63885: PUSH
63886: LD_INT 2
63888: EQUAL
63889: IFFALSE 63893
// exit ;
63891: GO 64403
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63893: LD_ADDR_VAR 0 8
63897: PUSH
63898: LD_INT 81
63900: PUSH
63901: LD_VAR 0 9
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PUSH
63910: LD_INT 3
63912: PUSH
63913: LD_INT 21
63915: PUSH
63916: LD_INT 3
63918: PUSH
63919: EMPTY
63920: LIST
63921: LIST
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PUSH
63927: EMPTY
63928: LIST
63929: LIST
63930: PPUSH
63931: CALL_OW 69
63935: ST_TO_ADDR
// if not tmp then
63936: LD_VAR 0 8
63940: NOT
63941: IFFALSE 63945
// exit ;
63943: GO 64403
// if in_unit then
63945: LD_VAR 0 11
63949: IFFALSE 63973
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
63951: LD_ADDR_VAR 0 10
63955: PUSH
63956: LD_VAR 0 8
63960: PPUSH
63961: LD_VAR 0 11
63965: PPUSH
63966: CALL_OW 74
63970: ST_TO_ADDR
63971: GO 63993
// enemy := NearestUnitToUnit ( tmp , unit ) ;
63973: LD_ADDR_VAR 0 10
63977: PUSH
63978: LD_VAR 0 8
63982: PPUSH
63983: LD_VAR 0 1
63987: PPUSH
63988: CALL_OW 74
63992: ST_TO_ADDR
// if not enemy then
63993: LD_VAR 0 10
63997: NOT
63998: IFFALSE 64002
// exit ;
64000: GO 64403
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64002: LD_VAR 0 11
64006: PUSH
64007: LD_VAR 0 11
64011: PPUSH
64012: LD_VAR 0 10
64016: PPUSH
64017: CALL_OW 296
64021: PUSH
64022: LD_INT 13
64024: GREATER
64025: AND
64026: PUSH
64027: LD_VAR 0 1
64031: PPUSH
64032: LD_VAR 0 10
64036: PPUSH
64037: CALL_OW 296
64041: PUSH
64042: LD_INT 12
64044: GREATER
64045: OR
64046: IFFALSE 64050
// exit ;
64048: GO 64403
// missile := [ 1 ] ;
64050: LD_ADDR_VAR 0 14
64054: PUSH
64055: LD_INT 1
64057: PUSH
64058: EMPTY
64059: LIST
64060: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64061: LD_VAR 0 9
64065: PPUSH
64066: LD_VAR 0 12
64070: PPUSH
64071: CALL_OW 325
64075: IFFALSE 64104
// missile := Insert ( missile , missile + 1 , 2 ) ;
64077: LD_ADDR_VAR 0 14
64081: PUSH
64082: LD_VAR 0 14
64086: PPUSH
64087: LD_VAR 0 14
64091: PUSH
64092: LD_INT 1
64094: PLUS
64095: PPUSH
64096: LD_INT 2
64098: PPUSH
64099: CALL_OW 2
64103: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64104: LD_VAR 0 9
64108: PPUSH
64109: LD_VAR 0 13
64113: PPUSH
64114: CALL_OW 325
64118: PUSH
64119: LD_VAR 0 10
64123: PPUSH
64124: CALL_OW 255
64128: PPUSH
64129: LD_VAR 0 13
64133: PPUSH
64134: CALL_OW 325
64138: NOT
64139: AND
64140: IFFALSE 64169
// missile := Insert ( missile , missile + 1 , 3 ) ;
64142: LD_ADDR_VAR 0 14
64146: PUSH
64147: LD_VAR 0 14
64151: PPUSH
64152: LD_VAR 0 14
64156: PUSH
64157: LD_INT 1
64159: PLUS
64160: PPUSH
64161: LD_INT 3
64163: PPUSH
64164: CALL_OW 2
64168: ST_TO_ADDR
// if missile < 2 then
64169: LD_VAR 0 14
64173: PUSH
64174: LD_INT 2
64176: LESS
64177: IFFALSE 64181
// exit ;
64179: GO 64403
// x := GetX ( enemy ) ;
64181: LD_ADDR_VAR 0 4
64185: PUSH
64186: LD_VAR 0 10
64190: PPUSH
64191: CALL_OW 250
64195: ST_TO_ADDR
// y := GetY ( enemy ) ;
64196: LD_ADDR_VAR 0 5
64200: PUSH
64201: LD_VAR 0 10
64205: PPUSH
64206: CALL_OW 251
64210: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64211: LD_ADDR_VAR 0 6
64215: PUSH
64216: LD_VAR 0 4
64220: PUSH
64221: LD_INT 1
64223: NEG
64224: PPUSH
64225: LD_INT 1
64227: PPUSH
64228: CALL_OW 12
64232: PLUS
64233: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64234: LD_ADDR_VAR 0 7
64238: PUSH
64239: LD_VAR 0 5
64243: PUSH
64244: LD_INT 1
64246: NEG
64247: PPUSH
64248: LD_INT 1
64250: PPUSH
64251: CALL_OW 12
64255: PLUS
64256: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64257: LD_VAR 0 6
64261: PPUSH
64262: LD_VAR 0 7
64266: PPUSH
64267: CALL_OW 488
64271: NOT
64272: IFFALSE 64294
// begin _x := x ;
64274: LD_ADDR_VAR 0 6
64278: PUSH
64279: LD_VAR 0 4
64283: ST_TO_ADDR
// _y := y ;
64284: LD_ADDR_VAR 0 7
64288: PUSH
64289: LD_VAR 0 5
64293: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64294: LD_ADDR_VAR 0 3
64298: PUSH
64299: LD_INT 1
64301: PPUSH
64302: LD_VAR 0 14
64306: PPUSH
64307: CALL_OW 12
64311: ST_TO_ADDR
// case i of 1 :
64312: LD_VAR 0 3
64316: PUSH
64317: LD_INT 1
64319: DOUBLE
64320: EQUAL
64321: IFTRUE 64325
64323: GO 64342
64325: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64326: LD_VAR 0 1
64330: PPUSH
64331: LD_VAR 0 10
64335: PPUSH
64336: CALL_OW 115
64340: GO 64403
64342: LD_INT 2
64344: DOUBLE
64345: EQUAL
64346: IFTRUE 64350
64348: GO 64372
64350: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64351: LD_VAR 0 1
64355: PPUSH
64356: LD_VAR 0 6
64360: PPUSH
64361: LD_VAR 0 7
64365: PPUSH
64366: CALL_OW 153
64370: GO 64403
64372: LD_INT 3
64374: DOUBLE
64375: EQUAL
64376: IFTRUE 64380
64378: GO 64402
64380: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64381: LD_VAR 0 1
64385: PPUSH
64386: LD_VAR 0 6
64390: PPUSH
64391: LD_VAR 0 7
64395: PPUSH
64396: CALL_OW 154
64400: GO 64403
64402: POP
// end ;
64403: LD_VAR 0 2
64407: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64408: LD_INT 0
64410: PPUSH
64411: PPUSH
64412: PPUSH
64413: PPUSH
64414: PPUSH
64415: PPUSH
// if not unit or not building then
64416: LD_VAR 0 1
64420: NOT
64421: PUSH
64422: LD_VAR 0 2
64426: NOT
64427: OR
64428: IFFALSE 64432
// exit ;
64430: GO 64590
// x := GetX ( building ) ;
64432: LD_ADDR_VAR 0 5
64436: PUSH
64437: LD_VAR 0 2
64441: PPUSH
64442: CALL_OW 250
64446: ST_TO_ADDR
// y := GetY ( building ) ;
64447: LD_ADDR_VAR 0 6
64451: PUSH
64452: LD_VAR 0 2
64456: PPUSH
64457: CALL_OW 251
64461: ST_TO_ADDR
// for i = 0 to 5 do
64462: LD_ADDR_VAR 0 4
64466: PUSH
64467: DOUBLE
64468: LD_INT 0
64470: DEC
64471: ST_TO_ADDR
64472: LD_INT 5
64474: PUSH
64475: FOR_TO
64476: IFFALSE 64588
// begin _x := ShiftX ( x , i , 3 ) ;
64478: LD_ADDR_VAR 0 7
64482: PUSH
64483: LD_VAR 0 5
64487: PPUSH
64488: LD_VAR 0 4
64492: PPUSH
64493: LD_INT 3
64495: PPUSH
64496: CALL_OW 272
64500: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64501: LD_ADDR_VAR 0 8
64505: PUSH
64506: LD_VAR 0 6
64510: PPUSH
64511: LD_VAR 0 4
64515: PPUSH
64516: LD_INT 3
64518: PPUSH
64519: CALL_OW 273
64523: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64524: LD_VAR 0 7
64528: PPUSH
64529: LD_VAR 0 8
64533: PPUSH
64534: CALL_OW 488
64538: NOT
64539: IFFALSE 64543
// continue ;
64541: GO 64475
// if HexInfo ( _x , _y ) = 0 then
64543: LD_VAR 0 7
64547: PPUSH
64548: LD_VAR 0 8
64552: PPUSH
64553: CALL_OW 428
64557: PUSH
64558: LD_INT 0
64560: EQUAL
64561: IFFALSE 64586
// begin ComMoveXY ( unit , _x , _y ) ;
64563: LD_VAR 0 1
64567: PPUSH
64568: LD_VAR 0 7
64572: PPUSH
64573: LD_VAR 0 8
64577: PPUSH
64578: CALL_OW 111
// exit ;
64582: POP
64583: POP
64584: GO 64590
// end ; end ;
64586: GO 64475
64588: POP
64589: POP
// end ;
64590: LD_VAR 0 3
64594: RET
// export function ScanBase ( side , base_area ) ; begin
64595: LD_INT 0
64597: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64598: LD_ADDR_VAR 0 3
64602: PUSH
64603: LD_VAR 0 2
64607: PPUSH
64608: LD_INT 81
64610: PUSH
64611: LD_VAR 0 1
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PPUSH
64620: CALL_OW 70
64624: ST_TO_ADDR
// end ;
64625: LD_VAR 0 3
64629: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
64630: LD_INT 0
64632: PPUSH
64633: PPUSH
64634: PPUSH
64635: PPUSH
64636: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
64637: LD_VAR 0 1
64641: NOT
64642: PUSH
64643: LD_EXP 99
64647: PUSH
64648: LD_VAR 0 1
64652: ARRAY
64653: NOT
64654: OR
64655: PUSH
64656: LD_VAR 0 2
64660: NOT
64661: OR
64662: PUSH
64663: LD_VAR 0 3
64667: NOT
64668: OR
64669: IFFALSE 64673
// exit ;
64671: GO 65123
// side := mc_sides [ base ] ;
64673: LD_ADDR_VAR 0 6
64677: PUSH
64678: LD_EXP 125
64682: PUSH
64683: LD_VAR 0 1
64687: ARRAY
64688: ST_TO_ADDR
// if not side then
64689: LD_VAR 0 6
64693: NOT
64694: IFFALSE 64698
// exit ;
64696: GO 65123
// for i in solds do
64698: LD_ADDR_VAR 0 7
64702: PUSH
64703: LD_VAR 0 2
64707: PUSH
64708: FOR_IN
64709: IFFALSE 64770
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
64711: LD_VAR 0 7
64715: PPUSH
64716: CALL_OW 310
64720: PPUSH
64721: CALL_OW 266
64725: PUSH
64726: LD_INT 32
64728: PUSH
64729: LD_INT 31
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: IN
64736: IFFALSE 64756
// solds := solds diff i else
64738: LD_ADDR_VAR 0 2
64742: PUSH
64743: LD_VAR 0 2
64747: PUSH
64748: LD_VAR 0 7
64752: DIFF
64753: ST_TO_ADDR
64754: GO 64768
// SetTag ( i , 18 ) ;
64756: LD_VAR 0 7
64760: PPUSH
64761: LD_INT 18
64763: PPUSH
64764: CALL_OW 109
64768: GO 64708
64770: POP
64771: POP
// if not solds then
64772: LD_VAR 0 2
64776: NOT
64777: IFFALSE 64781
// exit ;
64779: GO 65123
// repeat wait ( 0 0$1 ) ;
64781: LD_INT 35
64783: PPUSH
64784: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
64788: LD_ADDR_VAR 0 5
64792: PUSH
64793: LD_VAR 0 6
64797: PPUSH
64798: LD_VAR 0 3
64802: PPUSH
64803: CALL 64595 0 2
64807: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
64808: LD_VAR 0 5
64812: NOT
64813: PUSH
64814: LD_VAR 0 5
64818: PUSH
64819: LD_INT 3
64821: GREATER
64822: OR
64823: PUSH
64824: LD_EXP 121
64828: PUSH
64829: LD_VAR 0 1
64833: ARRAY
64834: OR
64835: IFFALSE 64876
// begin for i in solds do
64837: LD_ADDR_VAR 0 7
64841: PUSH
64842: LD_VAR 0 2
64846: PUSH
64847: FOR_IN
64848: IFFALSE 64872
// if HasTask ( i ) then
64850: LD_VAR 0 7
64854: PPUSH
64855: CALL_OW 314
64859: IFFALSE 64870
// ComStop ( i ) ;
64861: LD_VAR 0 7
64865: PPUSH
64866: CALL_OW 141
64870: GO 64847
64872: POP
64873: POP
// break ;
64874: GO 65111
// end ; for i in solds do
64876: LD_ADDR_VAR 0 7
64880: PUSH
64881: LD_VAR 0 2
64885: PUSH
64886: FOR_IN
64887: IFFALSE 65103
// begin if IsInUnit ( i ) then
64889: LD_VAR 0 7
64893: PPUSH
64894: CALL_OW 310
64898: IFFALSE 64909
// ComExitBuilding ( i ) ;
64900: LD_VAR 0 7
64904: PPUSH
64905: CALL_OW 122
// if GetLives ( i ) > 333 then
64909: LD_VAR 0 7
64913: PPUSH
64914: CALL_OW 256
64918: PUSH
64919: LD_INT 333
64921: GREATER
64922: IFFALSE 64950
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
64924: LD_VAR 0 7
64928: PPUSH
64929: LD_VAR 0 5
64933: PPUSH
64934: LD_VAR 0 7
64938: PPUSH
64939: CALL_OW 74
64943: PPUSH
64944: CALL_OW 115
64948: GO 65101
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
64950: LD_ADDR_VAR 0 8
64954: PUSH
64955: LD_EXP 99
64959: PUSH
64960: LD_VAR 0 1
64964: ARRAY
64965: PPUSH
64966: LD_INT 2
64968: PUSH
64969: LD_INT 30
64971: PUSH
64972: LD_INT 0
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: PUSH
64979: LD_INT 30
64981: PUSH
64982: LD_INT 1
64984: PUSH
64985: EMPTY
64986: LIST
64987: LIST
64988: PUSH
64989: LD_INT 30
64991: PUSH
64992: LD_INT 6
64994: PUSH
64995: EMPTY
64996: LIST
64997: LIST
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: PPUSH
65005: CALL_OW 72
65009: PPUSH
65010: LD_VAR 0 7
65014: PPUSH
65015: CALL_OW 74
65019: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
65020: LD_VAR 0 7
65024: PPUSH
65025: LD_VAR 0 8
65029: PPUSH
65030: CALL_OW 250
65034: PPUSH
65035: LD_INT 3
65037: PPUSH
65038: LD_INT 5
65040: PPUSH
65041: CALL_OW 272
65045: PPUSH
65046: LD_VAR 0 8
65050: PPUSH
65051: CALL_OW 251
65055: PPUSH
65056: LD_INT 3
65058: PPUSH
65059: LD_INT 5
65061: PPUSH
65062: CALL_OW 273
65066: PPUSH
65067: CALL_OW 111
// SetTag ( i , 0 ) ;
65071: LD_VAR 0 7
65075: PPUSH
65076: LD_INT 0
65078: PPUSH
65079: CALL_OW 109
// solds := solds diff i ;
65083: LD_ADDR_VAR 0 2
65087: PUSH
65088: LD_VAR 0 2
65092: PUSH
65093: LD_VAR 0 7
65097: DIFF
65098: ST_TO_ADDR
// continue ;
65099: GO 64886
// end ; end ;
65101: GO 64886
65103: POP
65104: POP
// until solds ;
65105: LD_VAR 0 2
65109: IFFALSE 64781
// MC_Reset ( base , 18 ) ;
65111: LD_VAR 0 1
65115: PPUSH
65116: LD_INT 18
65118: PPUSH
65119: CALL 37823 0 2
// end ;
65123: LD_VAR 0 4
65127: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
65128: LD_INT 0
65130: PPUSH
65131: PPUSH
65132: PPUSH
65133: PPUSH
65134: PPUSH
65135: PPUSH
65136: PPUSH
65137: PPUSH
65138: PPUSH
65139: PPUSH
65140: PPUSH
65141: PPUSH
65142: PPUSH
65143: PPUSH
65144: PPUSH
65145: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65146: LD_ADDR_VAR 0 12
65150: PUSH
65151: LD_EXP 99
65155: PUSH
65156: LD_VAR 0 1
65160: ARRAY
65161: PPUSH
65162: LD_INT 25
65164: PUSH
65165: LD_INT 3
65167: PUSH
65168: EMPTY
65169: LIST
65170: LIST
65171: PPUSH
65172: CALL_OW 72
65176: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65177: LD_ADDR_VAR 0 8
65181: PUSH
65182: LD_EXP 99
65186: PUSH
65187: LD_VAR 0 1
65191: ARRAY
65192: PPUSH
65193: LD_INT 2
65195: PUSH
65196: LD_INT 25
65198: PUSH
65199: LD_INT 1
65201: PUSH
65202: EMPTY
65203: LIST
65204: LIST
65205: PUSH
65206: LD_INT 25
65208: PUSH
65209: LD_INT 5
65211: PUSH
65212: EMPTY
65213: LIST
65214: LIST
65215: PUSH
65216: LD_INT 25
65218: PUSH
65219: LD_INT 8
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: PUSH
65226: LD_INT 25
65228: PUSH
65229: LD_INT 9
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: PPUSH
65243: CALL_OW 72
65247: ST_TO_ADDR
// if not defenders and not solds then
65248: LD_VAR 0 2
65252: NOT
65253: PUSH
65254: LD_VAR 0 8
65258: NOT
65259: AND
65260: IFFALSE 65264
// exit ;
65262: GO 66593
// depot_under_attack := false ;
65264: LD_ADDR_VAR 0 16
65268: PUSH
65269: LD_INT 0
65271: ST_TO_ADDR
// sold_defenders := [ ] ;
65272: LD_ADDR_VAR 0 17
65276: PUSH
65277: EMPTY
65278: ST_TO_ADDR
// if mechs then
65279: LD_VAR 0 12
65283: IFFALSE 65412
// for i in defenders do
65285: LD_ADDR_VAR 0 5
65289: PUSH
65290: LD_VAR 0 2
65294: PUSH
65295: FOR_IN
65296: IFFALSE 65410
// begin SetTag ( i , 20 ) ;
65298: LD_VAR 0 5
65302: PPUSH
65303: LD_INT 20
65305: PPUSH
65306: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
65310: LD_VAR 0 5
65314: PPUSH
65315: CALL_OW 263
65319: PUSH
65320: LD_INT 1
65322: EQUAL
65323: PUSH
65324: LD_VAR 0 5
65328: PPUSH
65329: CALL_OW 311
65333: NOT
65334: AND
65335: PUSH
65336: LD_VAR 0 12
65340: AND
65341: IFFALSE 65408
// begin un := mechs [ 1 ] ;
65343: LD_ADDR_VAR 0 10
65347: PUSH
65348: LD_VAR 0 12
65352: PUSH
65353: LD_INT 1
65355: ARRAY
65356: ST_TO_ADDR
// ComExitBuilding ( un ) ;
65357: LD_VAR 0 10
65361: PPUSH
65362: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
65366: LD_VAR 0 10
65370: PPUSH
65371: LD_VAR 0 5
65375: PPUSH
65376: CALL_OW 180
// SetTag ( un , 19 ) ;
65380: LD_VAR 0 10
65384: PPUSH
65385: LD_INT 19
65387: PPUSH
65388: CALL_OW 109
// mechs := mechs diff un ;
65392: LD_ADDR_VAR 0 12
65396: PUSH
65397: LD_VAR 0 12
65401: PUSH
65402: LD_VAR 0 10
65406: DIFF
65407: ST_TO_ADDR
// end ; end ;
65408: GO 65295
65410: POP
65411: POP
// if solds then
65412: LD_VAR 0 8
65416: IFFALSE 65475
// for i in solds do
65418: LD_ADDR_VAR 0 5
65422: PUSH
65423: LD_VAR 0 8
65427: PUSH
65428: FOR_IN
65429: IFFALSE 65473
// if not GetTag ( i ) then
65431: LD_VAR 0 5
65435: PPUSH
65436: CALL_OW 110
65440: NOT
65441: IFFALSE 65471
// begin defenders := defenders union i ;
65443: LD_ADDR_VAR 0 2
65447: PUSH
65448: LD_VAR 0 2
65452: PUSH
65453: LD_VAR 0 5
65457: UNION
65458: ST_TO_ADDR
// SetTag ( i , 18 ) ;
65459: LD_VAR 0 5
65463: PPUSH
65464: LD_INT 18
65466: PPUSH
65467: CALL_OW 109
// end ;
65471: GO 65428
65473: POP
65474: POP
// repeat wait ( 0 0$1 ) ;
65475: LD_INT 35
65477: PPUSH
65478: CALL_OW 67
// enemy := mc_scan [ base ] ;
65482: LD_ADDR_VAR 0 3
65486: PUSH
65487: LD_EXP 122
65491: PUSH
65492: LD_VAR 0 1
65496: ARRAY
65497: ST_TO_ADDR
// for i in defenders do
65498: LD_ADDR_VAR 0 5
65502: PUSH
65503: LD_VAR 0 2
65507: PUSH
65508: FOR_IN
65509: IFFALSE 66194
// begin e := NearestUnitToUnit ( enemy , i ) ;
65511: LD_ADDR_VAR 0 13
65515: PUSH
65516: LD_VAR 0 3
65520: PPUSH
65521: LD_VAR 0 5
65525: PPUSH
65526: CALL_OW 74
65530: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
65531: LD_ADDR_VAR 0 16
65535: PUSH
65536: LD_EXP 99
65540: PUSH
65541: LD_VAR 0 1
65545: ARRAY
65546: PPUSH
65547: LD_INT 2
65549: PUSH
65550: LD_INT 30
65552: PUSH
65553: LD_INT 0
65555: PUSH
65556: EMPTY
65557: LIST
65558: LIST
65559: PUSH
65560: LD_INT 30
65562: PUSH
65563: LD_INT 1
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PUSH
65570: EMPTY
65571: LIST
65572: LIST
65573: LIST
65574: PPUSH
65575: CALL_OW 72
65579: NOT
65580: PUSH
65581: LD_EXP 99
65585: PUSH
65586: LD_VAR 0 1
65590: ARRAY
65591: PPUSH
65592: LD_INT 2
65594: PUSH
65595: LD_INT 30
65597: PUSH
65598: LD_INT 0
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 30
65607: PUSH
65608: LD_INT 1
65610: PUSH
65611: EMPTY
65612: LIST
65613: LIST
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: LIST
65619: PPUSH
65620: CALL_OW 72
65624: PPUSH
65625: CALL_OW 256
65629: PUSH
65630: LD_INT 600
65632: LESS
65633: OR
65634: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
65635: LD_VAR 0 5
65639: PPUSH
65640: CALL_OW 247
65644: PUSH
65645: LD_INT 2
65647: DOUBLE
65648: EQUAL
65649: IFTRUE 65653
65651: GO 65900
65653: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
65654: LD_VAR 0 5
65658: PPUSH
65659: CALL_OW 256
65663: PUSH
65664: LD_INT 650
65666: GREATER
65667: PUSH
65668: LD_VAR 0 5
65672: PPUSH
65673: LD_VAR 0 13
65677: PPUSH
65678: CALL_OW 296
65682: PUSH
65683: LD_INT 40
65685: LESS
65686: AND
65687: IFFALSE 65705
// ComAttackUnit ( i , e ) else
65689: LD_VAR 0 5
65693: PPUSH
65694: LD_VAR 0 13
65698: PPUSH
65699: CALL_OW 115
65703: GO 65783
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
65705: LD_VAR 0 5
65709: PPUSH
65710: LD_VAR 0 13
65714: PPUSH
65715: CALL_OW 296
65719: PUSH
65720: LD_INT 30
65722: GREATEREQUAL
65723: PUSH
65724: LD_VAR 0 5
65728: PPUSH
65729: CALL_OW 256
65733: PUSH
65734: LD_INT 650
65736: LESSEQUAL
65737: OR
65738: PUSH
65739: LD_VAR 0 5
65743: PPUSH
65744: LD_EXP 123
65748: PUSH
65749: LD_VAR 0 1
65753: ARRAY
65754: PPUSH
65755: CALL_OW 308
65759: NOT
65760: AND
65761: IFFALSE 65783
// ComMoveToArea ( i , mc_parking [ base ] ) ;
65763: LD_VAR 0 5
65767: PPUSH
65768: LD_EXP 123
65772: PUSH
65773: LD_VAR 0 1
65777: ARRAY
65778: PPUSH
65779: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
65783: LD_VAR 0 5
65787: PPUSH
65788: CALL_OW 256
65792: PUSH
65793: LD_INT 998
65795: LESS
65796: PUSH
65797: LD_VAR 0 5
65801: PPUSH
65802: CALL_OW 263
65806: PUSH
65807: LD_INT 1
65809: EQUAL
65810: AND
65811: PUSH
65812: LD_VAR 0 5
65816: PPUSH
65817: CALL_OW 311
65821: AND
65822: PUSH
65823: LD_VAR 0 5
65827: PPUSH
65828: LD_EXP 123
65832: PUSH
65833: LD_VAR 0 1
65837: ARRAY
65838: PPUSH
65839: CALL_OW 308
65843: AND
65844: IFFALSE 65898
// begin mech := IsDrivenBy ( i ) ;
65846: LD_ADDR_VAR 0 9
65850: PUSH
65851: LD_VAR 0 5
65855: PPUSH
65856: CALL_OW 311
65860: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
65861: LD_VAR 0 9
65865: PPUSH
65866: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
65870: LD_VAR 0 9
65874: PPUSH
65875: LD_VAR 0 5
65879: PPUSH
65880: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
65884: LD_VAR 0 9
65888: PPUSH
65889: LD_VAR 0 5
65893: PPUSH
65894: CALL_OW 180
// end ; end ; unit_human :
65898: GO 66165
65900: LD_INT 1
65902: DOUBLE
65903: EQUAL
65904: IFTRUE 65908
65906: GO 66164
65908: POP
// begin b := IsInUnit ( i ) ;
65909: LD_ADDR_VAR 0 18
65913: PUSH
65914: LD_VAR 0 5
65918: PPUSH
65919: CALL_OW 310
65923: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
65924: LD_ADDR_VAR 0 19
65928: PUSH
65929: LD_VAR 0 18
65933: NOT
65934: PUSH
65935: LD_VAR 0 18
65939: PPUSH
65940: CALL_OW 266
65944: PUSH
65945: LD_INT 32
65947: PUSH
65948: LD_INT 31
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: IN
65955: OR
65956: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
65957: LD_VAR 0 16
65961: PUSH
65962: LD_VAR 0 2
65966: PPUSH
65967: LD_INT 21
65969: PUSH
65970: LD_INT 2
65972: PUSH
65973: EMPTY
65974: LIST
65975: LIST
65976: PPUSH
65977: CALL_OW 72
65981: PUSH
65982: LD_INT 1
65984: LESSEQUAL
65985: OR
65986: PUSH
65987: LD_VAR 0 19
65991: AND
65992: PUSH
65993: LD_VAR 0 5
65997: PUSH
65998: LD_VAR 0 17
66002: IN
66003: NOT
66004: AND
66005: IFFALSE 66098
// begin if b then
66007: LD_VAR 0 18
66011: IFFALSE 66060
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
66013: LD_VAR 0 18
66017: PPUSH
66018: LD_VAR 0 3
66022: PPUSH
66023: LD_VAR 0 18
66027: PPUSH
66028: CALL_OW 74
66032: PPUSH
66033: CALL_OW 296
66037: PUSH
66038: LD_INT 10
66040: LESS
66041: PUSH
66042: LD_VAR 0 18
66046: PPUSH
66047: CALL_OW 461
66051: PUSH
66052: LD_INT 7
66054: NONEQUAL
66055: AND
66056: IFFALSE 66060
// continue ;
66058: GO 65508
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
66060: LD_ADDR_VAR 0 17
66064: PUSH
66065: LD_VAR 0 17
66069: PPUSH
66070: LD_VAR 0 17
66074: PUSH
66075: LD_INT 1
66077: PLUS
66078: PPUSH
66079: LD_VAR 0 5
66083: PPUSH
66084: CALL_OW 1
66088: ST_TO_ADDR
// ComExitBuilding ( i ) ;
66089: LD_VAR 0 5
66093: PPUSH
66094: CALL_OW 122
// end ; if sold_defenders then
66098: LD_VAR 0 17
66102: IFFALSE 66162
// if i in sold_defenders then
66104: LD_VAR 0 5
66108: PUSH
66109: LD_VAR 0 17
66113: IN
66114: IFFALSE 66162
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
66116: LD_VAR 0 5
66120: PPUSH
66121: CALL_OW 314
66125: NOT
66126: PUSH
66127: LD_VAR 0 5
66131: PPUSH
66132: LD_VAR 0 13
66136: PPUSH
66137: CALL_OW 296
66141: PUSH
66142: LD_INT 30
66144: LESS
66145: AND
66146: IFFALSE 66162
// ComAttackUnit ( i , e ) ;
66148: LD_VAR 0 5
66152: PPUSH
66153: LD_VAR 0 13
66157: PPUSH
66158: CALL_OW 115
// end ; end ; end ;
66162: GO 66165
66164: POP
// if IsDead ( i ) then
66165: LD_VAR 0 5
66169: PPUSH
66170: CALL_OW 301
66174: IFFALSE 66192
// defenders := defenders diff i ;
66176: LD_ADDR_VAR 0 2
66180: PUSH
66181: LD_VAR 0 2
66185: PUSH
66186: LD_VAR 0 5
66190: DIFF
66191: ST_TO_ADDR
// end ;
66192: GO 65508
66194: POP
66195: POP
// until not enemy or not defenders ;
66196: LD_VAR 0 3
66200: NOT
66201: PUSH
66202: LD_VAR 0 2
66206: NOT
66207: OR
66208: IFFALSE 65475
// MC_Reset ( base , 18 ) ;
66210: LD_VAR 0 1
66214: PPUSH
66215: LD_INT 18
66217: PPUSH
66218: CALL 37823 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66222: LD_ADDR_VAR 0 2
66226: PUSH
66227: LD_VAR 0 2
66231: PUSH
66232: LD_VAR 0 2
66236: PPUSH
66237: LD_INT 2
66239: PUSH
66240: LD_INT 25
66242: PUSH
66243: LD_INT 1
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 25
66252: PUSH
66253: LD_INT 5
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: PUSH
66260: LD_INT 25
66262: PUSH
66263: LD_INT 8
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 25
66272: PUSH
66273: LD_INT 9
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: PPUSH
66287: CALL_OW 72
66291: DIFF
66292: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
66293: LD_VAR 0 3
66297: NOT
66298: PUSH
66299: LD_VAR 0 2
66303: PPUSH
66304: LD_INT 21
66306: PUSH
66307: LD_INT 2
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PPUSH
66314: CALL_OW 72
66318: AND
66319: IFFALSE 66581
// begin tmp := FilterByTag ( defenders , 19 ) ;
66321: LD_ADDR_VAR 0 11
66325: PUSH
66326: LD_VAR 0 2
66330: PPUSH
66331: LD_INT 19
66333: PPUSH
66334: CALL 102961 0 2
66338: ST_TO_ADDR
// if tmp then
66339: LD_VAR 0 11
66343: IFFALSE 66413
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
66345: LD_ADDR_VAR 0 11
66349: PUSH
66350: LD_VAR 0 11
66354: PPUSH
66355: LD_INT 25
66357: PUSH
66358: LD_INT 3
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: PPUSH
66365: CALL_OW 72
66369: ST_TO_ADDR
// if tmp then
66370: LD_VAR 0 11
66374: IFFALSE 66413
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
66376: LD_ADDR_EXP 111
66380: PUSH
66381: LD_EXP 111
66385: PPUSH
66386: LD_VAR 0 1
66390: PPUSH
66391: LD_EXP 111
66395: PUSH
66396: LD_VAR 0 1
66400: ARRAY
66401: PUSH
66402: LD_VAR 0 11
66406: UNION
66407: PPUSH
66408: CALL_OW 1
66412: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
66413: LD_VAR 0 1
66417: PPUSH
66418: LD_INT 19
66420: PPUSH
66421: CALL 37823 0 2
// repeat wait ( 0 0$1 ) ;
66425: LD_INT 35
66427: PPUSH
66428: CALL_OW 67
// for i in defenders do
66432: LD_ADDR_VAR 0 5
66436: PUSH
66437: LD_VAR 0 2
66441: PUSH
66442: FOR_IN
66443: IFFALSE 66532
// begin if not IsInArea ( i , mc_parking [ base ] ) then
66445: LD_VAR 0 5
66449: PPUSH
66450: LD_EXP 123
66454: PUSH
66455: LD_VAR 0 1
66459: ARRAY
66460: PPUSH
66461: CALL_OW 308
66465: NOT
66466: IFFALSE 66490
// ComMoveToArea ( i , mc_parking [ base ] ) else
66468: LD_VAR 0 5
66472: PPUSH
66473: LD_EXP 123
66477: PUSH
66478: LD_VAR 0 1
66482: ARRAY
66483: PPUSH
66484: CALL_OW 113
66488: GO 66530
// if GetControl ( i ) = control_manual then
66490: LD_VAR 0 5
66494: PPUSH
66495: CALL_OW 263
66499: PUSH
66500: LD_INT 1
66502: EQUAL
66503: IFFALSE 66530
// if IsDrivenBy ( i ) then
66505: LD_VAR 0 5
66509: PPUSH
66510: CALL_OW 311
66514: IFFALSE 66530
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
66516: LD_VAR 0 5
66520: PPUSH
66521: CALL_OW 311
66525: PPUSH
66526: CALL_OW 121
// end ;
66530: GO 66442
66532: POP
66533: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
66534: LD_VAR 0 2
66538: PPUSH
66539: LD_INT 95
66541: PUSH
66542: LD_EXP 123
66546: PUSH
66547: LD_VAR 0 1
66551: ARRAY
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PPUSH
66557: CALL_OW 72
66561: PUSH
66562: LD_VAR 0 2
66566: EQUAL
66567: PUSH
66568: LD_EXP 122
66572: PUSH
66573: LD_VAR 0 1
66577: ARRAY
66578: OR
66579: IFFALSE 66425
// end ; MC_Reset ( base , 20 ) ;
66581: LD_VAR 0 1
66585: PPUSH
66586: LD_INT 20
66588: PPUSH
66589: CALL 37823 0 2
// end ;
66593: LD_VAR 0 4
66597: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66598: LD_INT 0
66600: PPUSH
66601: PPUSH
66602: PPUSH
66603: PPUSH
// result := false ;
66604: LD_ADDR_VAR 0 2
66608: PUSH
66609: LD_INT 0
66611: ST_TO_ADDR
// side := GetSide ( unit ) ;
66612: LD_ADDR_VAR 0 3
66616: PUSH
66617: LD_VAR 0 1
66621: PPUSH
66622: CALL_OW 255
66626: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66627: LD_ADDR_VAR 0 4
66631: PUSH
66632: LD_VAR 0 1
66636: PPUSH
66637: CALL_OW 248
66641: ST_TO_ADDR
// case nat of 1 :
66642: LD_VAR 0 4
66646: PUSH
66647: LD_INT 1
66649: DOUBLE
66650: EQUAL
66651: IFTRUE 66655
66653: GO 66666
66655: POP
// tech := tech_lassight ; 2 :
66656: LD_ADDR_VAR 0 5
66660: PUSH
66661: LD_INT 12
66663: ST_TO_ADDR
66664: GO 66705
66666: LD_INT 2
66668: DOUBLE
66669: EQUAL
66670: IFTRUE 66674
66672: GO 66685
66674: POP
// tech := tech_mortar ; 3 :
66675: LD_ADDR_VAR 0 5
66679: PUSH
66680: LD_INT 41
66682: ST_TO_ADDR
66683: GO 66705
66685: LD_INT 3
66687: DOUBLE
66688: EQUAL
66689: IFTRUE 66693
66691: GO 66704
66693: POP
// tech := tech_bazooka ; end ;
66694: LD_ADDR_VAR 0 5
66698: PUSH
66699: LD_INT 44
66701: ST_TO_ADDR
66702: GO 66705
66704: POP
// if Researched ( side , tech ) then
66705: LD_VAR 0 3
66709: PPUSH
66710: LD_VAR 0 5
66714: PPUSH
66715: CALL_OW 325
66719: IFFALSE 66746
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66721: LD_ADDR_VAR 0 2
66725: PUSH
66726: LD_INT 5
66728: PUSH
66729: LD_INT 8
66731: PUSH
66732: LD_INT 9
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: LIST
66739: PUSH
66740: LD_VAR 0 4
66744: ARRAY
66745: ST_TO_ADDR
// end ;
66746: LD_VAR 0 2
66750: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
66751: LD_INT 0
66753: PPUSH
66754: PPUSH
66755: PPUSH
// if not mines then
66756: LD_VAR 0 2
66760: NOT
66761: IFFALSE 66765
// exit ;
66763: GO 66909
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66765: LD_ADDR_VAR 0 5
66769: PUSH
66770: LD_INT 81
66772: PUSH
66773: LD_VAR 0 1
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 3
66784: PUSH
66785: LD_INT 21
66787: PUSH
66788: LD_INT 3
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PPUSH
66803: CALL_OW 69
66807: ST_TO_ADDR
// for i in mines do
66808: LD_ADDR_VAR 0 4
66812: PUSH
66813: LD_VAR 0 2
66817: PUSH
66818: FOR_IN
66819: IFFALSE 66907
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
66821: LD_VAR 0 4
66825: PUSH
66826: LD_INT 1
66828: ARRAY
66829: PPUSH
66830: LD_VAR 0 4
66834: PUSH
66835: LD_INT 2
66837: ARRAY
66838: PPUSH
66839: CALL_OW 458
66843: NOT
66844: IFFALSE 66848
// continue ;
66846: GO 66818
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
66848: LD_VAR 0 4
66852: PUSH
66853: LD_INT 1
66855: ARRAY
66856: PPUSH
66857: LD_VAR 0 4
66861: PUSH
66862: LD_INT 2
66864: ARRAY
66865: PPUSH
66866: CALL_OW 428
66870: PUSH
66871: LD_VAR 0 5
66875: IN
66876: IFFALSE 66905
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
66878: LD_VAR 0 4
66882: PUSH
66883: LD_INT 1
66885: ARRAY
66886: PPUSH
66887: LD_VAR 0 4
66891: PUSH
66892: LD_INT 2
66894: ARRAY
66895: PPUSH
66896: LD_VAR 0 1
66900: PPUSH
66901: CALL_OW 456
// end ;
66905: GO 66818
66907: POP
66908: POP
// end ;
66909: LD_VAR 0 3
66913: RET
// export function Count ( array ) ; var i ; begin
66914: LD_INT 0
66916: PPUSH
66917: PPUSH
// result := 0 ;
66918: LD_ADDR_VAR 0 2
66922: PUSH
66923: LD_INT 0
66925: ST_TO_ADDR
// for i in array do
66926: LD_ADDR_VAR 0 3
66930: PUSH
66931: LD_VAR 0 1
66935: PUSH
66936: FOR_IN
66937: IFFALSE 66961
// if i then
66939: LD_VAR 0 3
66943: IFFALSE 66959
// result := result + 1 ;
66945: LD_ADDR_VAR 0 2
66949: PUSH
66950: LD_VAR 0 2
66954: PUSH
66955: LD_INT 1
66957: PLUS
66958: ST_TO_ADDR
66959: GO 66936
66961: POP
66962: POP
// end ;
66963: LD_VAR 0 2
66967: RET
// export function IsEmpty ( building ) ; begin
66968: LD_INT 0
66970: PPUSH
// if not building then
66971: LD_VAR 0 1
66975: NOT
66976: IFFALSE 66980
// exit ;
66978: GO 67023
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
66980: LD_ADDR_VAR 0 2
66984: PUSH
66985: LD_VAR 0 1
66989: PUSH
66990: LD_INT 22
66992: PUSH
66993: LD_VAR 0 1
66997: PPUSH
66998: CALL_OW 255
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: PUSH
67007: LD_INT 58
67009: PUSH
67010: EMPTY
67011: LIST
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PPUSH
67017: CALL_OW 69
67021: IN
67022: ST_TO_ADDR
// end ;
67023: LD_VAR 0 2
67027: RET
// export function IsNotFull ( building ) ; begin
67028: LD_INT 0
67030: PPUSH
// if not building then
67031: LD_VAR 0 1
67035: NOT
67036: IFFALSE 67040
// exit ;
67038: GO 67059
// result := UnitsInside ( building ) < 6 ;
67040: LD_ADDR_VAR 0 2
67044: PUSH
67045: LD_VAR 0 1
67049: PPUSH
67050: CALL_OW 313
67054: PUSH
67055: LD_INT 6
67057: LESS
67058: ST_TO_ADDR
// end ;
67059: LD_VAR 0 2
67063: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67064: LD_INT 0
67066: PPUSH
67067: PPUSH
67068: PPUSH
67069: PPUSH
// tmp := [ ] ;
67070: LD_ADDR_VAR 0 3
67074: PUSH
67075: EMPTY
67076: ST_TO_ADDR
// list := [ ] ;
67077: LD_ADDR_VAR 0 5
67081: PUSH
67082: EMPTY
67083: ST_TO_ADDR
// for i = 16 to 25 do
67084: LD_ADDR_VAR 0 4
67088: PUSH
67089: DOUBLE
67090: LD_INT 16
67092: DEC
67093: ST_TO_ADDR
67094: LD_INT 25
67096: PUSH
67097: FOR_TO
67098: IFFALSE 67171
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67100: LD_ADDR_VAR 0 3
67104: PUSH
67105: LD_VAR 0 3
67109: PUSH
67110: LD_INT 22
67112: PUSH
67113: LD_VAR 0 1
67117: PPUSH
67118: CALL_OW 255
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: PUSH
67127: LD_INT 91
67129: PUSH
67130: LD_VAR 0 1
67134: PUSH
67135: LD_INT 6
67137: PUSH
67138: EMPTY
67139: LIST
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 30
67145: PUSH
67146: LD_VAR 0 4
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: EMPTY
67156: LIST
67157: LIST
67158: LIST
67159: PUSH
67160: EMPTY
67161: LIST
67162: PPUSH
67163: CALL_OW 69
67167: ADD
67168: ST_TO_ADDR
67169: GO 67097
67171: POP
67172: POP
// for i = 1 to tmp do
67173: LD_ADDR_VAR 0 4
67177: PUSH
67178: DOUBLE
67179: LD_INT 1
67181: DEC
67182: ST_TO_ADDR
67183: LD_VAR 0 3
67187: PUSH
67188: FOR_TO
67189: IFFALSE 67277
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67191: LD_ADDR_VAR 0 5
67195: PUSH
67196: LD_VAR 0 5
67200: PUSH
67201: LD_VAR 0 3
67205: PUSH
67206: LD_VAR 0 4
67210: ARRAY
67211: PPUSH
67212: CALL_OW 266
67216: PUSH
67217: LD_VAR 0 3
67221: PUSH
67222: LD_VAR 0 4
67226: ARRAY
67227: PPUSH
67228: CALL_OW 250
67232: PUSH
67233: LD_VAR 0 3
67237: PUSH
67238: LD_VAR 0 4
67242: ARRAY
67243: PPUSH
67244: CALL_OW 251
67248: PUSH
67249: LD_VAR 0 3
67253: PUSH
67254: LD_VAR 0 4
67258: ARRAY
67259: PPUSH
67260: CALL_OW 254
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: LIST
67269: LIST
67270: PUSH
67271: EMPTY
67272: LIST
67273: ADD
67274: ST_TO_ADDR
67275: GO 67188
67277: POP
67278: POP
// result := list ;
67279: LD_ADDR_VAR 0 2
67283: PUSH
67284: LD_VAR 0 5
67288: ST_TO_ADDR
// end ;
67289: LD_VAR 0 2
67293: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67294: LD_INT 0
67296: PPUSH
67297: PPUSH
67298: PPUSH
67299: PPUSH
67300: PPUSH
67301: PPUSH
67302: PPUSH
// if not factory then
67303: LD_VAR 0 1
67307: NOT
67308: IFFALSE 67312
// exit ;
67310: GO 67844
// if control = control_apeman then
67312: LD_VAR 0 4
67316: PUSH
67317: LD_INT 5
67319: EQUAL
67320: IFFALSE 67429
// begin tmp := UnitsInside ( factory ) ;
67322: LD_ADDR_VAR 0 8
67326: PUSH
67327: LD_VAR 0 1
67331: PPUSH
67332: CALL_OW 313
67336: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67337: LD_VAR 0 8
67341: PPUSH
67342: LD_INT 25
67344: PUSH
67345: LD_INT 12
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PPUSH
67352: CALL_OW 72
67356: NOT
67357: IFFALSE 67367
// control := control_manual ;
67359: LD_ADDR_VAR 0 4
67363: PUSH
67364: LD_INT 1
67366: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67367: LD_ADDR_VAR 0 8
67371: PUSH
67372: LD_VAR 0 1
67376: PPUSH
67377: CALL 67064 0 1
67381: ST_TO_ADDR
// if tmp then
67382: LD_VAR 0 8
67386: IFFALSE 67429
// begin for i in tmp do
67388: LD_ADDR_VAR 0 7
67392: PUSH
67393: LD_VAR 0 8
67397: PUSH
67398: FOR_IN
67399: IFFALSE 67427
// if i [ 1 ] = b_ext_radio then
67401: LD_VAR 0 7
67405: PUSH
67406: LD_INT 1
67408: ARRAY
67409: PUSH
67410: LD_INT 22
67412: EQUAL
67413: IFFALSE 67425
// begin control := control_remote ;
67415: LD_ADDR_VAR 0 4
67419: PUSH
67420: LD_INT 2
67422: ST_TO_ADDR
// break ;
67423: GO 67427
// end ;
67425: GO 67398
67427: POP
67428: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67429: LD_VAR 0 1
67433: PPUSH
67434: LD_VAR 0 2
67438: PPUSH
67439: LD_VAR 0 3
67443: PPUSH
67444: LD_VAR 0 4
67448: PPUSH
67449: LD_VAR 0 5
67453: PPUSH
67454: CALL_OW 448
67458: IFFALSE 67493
// begin result := [ chassis , engine , control , weapon ] ;
67460: LD_ADDR_VAR 0 6
67464: PUSH
67465: LD_VAR 0 2
67469: PUSH
67470: LD_VAR 0 3
67474: PUSH
67475: LD_VAR 0 4
67479: PUSH
67480: LD_VAR 0 5
67484: PUSH
67485: EMPTY
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: ST_TO_ADDR
// exit ;
67491: GO 67844
// end ; _chassis := AvailableChassisList ( factory ) ;
67493: LD_ADDR_VAR 0 9
67497: PUSH
67498: LD_VAR 0 1
67502: PPUSH
67503: CALL_OW 475
67507: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67508: LD_ADDR_VAR 0 11
67512: PUSH
67513: LD_VAR 0 1
67517: PPUSH
67518: CALL_OW 476
67522: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67523: LD_ADDR_VAR 0 12
67527: PUSH
67528: LD_VAR 0 1
67532: PPUSH
67533: CALL_OW 477
67537: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67538: LD_ADDR_VAR 0 10
67542: PUSH
67543: LD_VAR 0 1
67547: PPUSH
67548: CALL_OW 478
67552: ST_TO_ADDR
// if not chassis in _chassis then
67553: LD_VAR 0 2
67557: PUSH
67558: LD_VAR 0 9
67562: IN
67563: NOT
67564: IFFALSE 67590
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67566: LD_ADDR_VAR 0 2
67570: PUSH
67571: LD_VAR 0 9
67575: PUSH
67576: LD_INT 1
67578: PPUSH
67579: LD_VAR 0 9
67583: PPUSH
67584: CALL_OW 12
67588: ARRAY
67589: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67590: LD_VAR 0 2
67594: PPUSH
67595: LD_VAR 0 3
67599: PPUSH
67600: CALL 67849 0 2
67604: NOT
67605: IFFALSE 67664
// repeat engine := _engine [ 1 ] ;
67607: LD_ADDR_VAR 0 3
67611: PUSH
67612: LD_VAR 0 11
67616: PUSH
67617: LD_INT 1
67619: ARRAY
67620: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67621: LD_ADDR_VAR 0 11
67625: PUSH
67626: LD_VAR 0 11
67630: PPUSH
67631: LD_INT 1
67633: PPUSH
67634: CALL_OW 3
67638: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67639: LD_VAR 0 2
67643: PPUSH
67644: LD_VAR 0 3
67648: PPUSH
67649: CALL 67849 0 2
67653: PUSH
67654: LD_VAR 0 11
67658: PUSH
67659: EMPTY
67660: EQUAL
67661: OR
67662: IFFALSE 67607
// if not control in _control then
67664: LD_VAR 0 4
67668: PUSH
67669: LD_VAR 0 12
67673: IN
67674: NOT
67675: IFFALSE 67701
// control := _control [ rand ( 1 , _control ) ] ;
67677: LD_ADDR_VAR 0 4
67681: PUSH
67682: LD_VAR 0 12
67686: PUSH
67687: LD_INT 1
67689: PPUSH
67690: LD_VAR 0 12
67694: PPUSH
67695: CALL_OW 12
67699: ARRAY
67700: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
67701: LD_VAR 0 2
67705: PPUSH
67706: LD_VAR 0 5
67710: PPUSH
67711: CALL 68069 0 2
67715: NOT
67716: IFFALSE 67775
// repeat weapon := _weapon [ 1 ] ;
67718: LD_ADDR_VAR 0 5
67722: PUSH
67723: LD_VAR 0 10
67727: PUSH
67728: LD_INT 1
67730: ARRAY
67731: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
67732: LD_ADDR_VAR 0 10
67736: PUSH
67737: LD_VAR 0 10
67741: PPUSH
67742: LD_INT 1
67744: PPUSH
67745: CALL_OW 3
67749: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
67750: LD_VAR 0 2
67754: PPUSH
67755: LD_VAR 0 5
67759: PPUSH
67760: CALL 68069 0 2
67764: PUSH
67765: LD_VAR 0 10
67769: PUSH
67770: EMPTY
67771: EQUAL
67772: OR
67773: IFFALSE 67718
// result := [ ] ;
67775: LD_ADDR_VAR 0 6
67779: PUSH
67780: EMPTY
67781: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67782: LD_VAR 0 1
67786: PPUSH
67787: LD_VAR 0 2
67791: PPUSH
67792: LD_VAR 0 3
67796: PPUSH
67797: LD_VAR 0 4
67801: PPUSH
67802: LD_VAR 0 5
67806: PPUSH
67807: CALL_OW 448
67811: IFFALSE 67844
// result := [ chassis , engine , control , weapon ] ;
67813: LD_ADDR_VAR 0 6
67817: PUSH
67818: LD_VAR 0 2
67822: PUSH
67823: LD_VAR 0 3
67827: PUSH
67828: LD_VAR 0 4
67832: PUSH
67833: LD_VAR 0 5
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: ST_TO_ADDR
// end ;
67844: LD_VAR 0 6
67848: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
67849: LD_INT 0
67851: PPUSH
// if not chassis or not engine then
67852: LD_VAR 0 1
67856: NOT
67857: PUSH
67858: LD_VAR 0 2
67862: NOT
67863: OR
67864: IFFALSE 67868
// exit ;
67866: GO 68064
// case engine of engine_solar :
67868: LD_VAR 0 2
67872: PUSH
67873: LD_INT 2
67875: DOUBLE
67876: EQUAL
67877: IFTRUE 67881
67879: GO 67919
67881: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
67882: LD_ADDR_VAR 0 3
67886: PUSH
67887: LD_INT 11
67889: PUSH
67890: LD_INT 12
67892: PUSH
67893: LD_INT 13
67895: PUSH
67896: LD_INT 14
67898: PUSH
67899: LD_INT 1
67901: PUSH
67902: LD_INT 2
67904: PUSH
67905: LD_INT 3
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: ST_TO_ADDR
67917: GO 68048
67919: LD_INT 1
67921: DOUBLE
67922: EQUAL
67923: IFTRUE 67927
67925: GO 67989
67927: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
67928: LD_ADDR_VAR 0 3
67932: PUSH
67933: LD_INT 11
67935: PUSH
67936: LD_INT 12
67938: PUSH
67939: LD_INT 13
67941: PUSH
67942: LD_INT 14
67944: PUSH
67945: LD_INT 1
67947: PUSH
67948: LD_INT 2
67950: PUSH
67951: LD_INT 3
67953: PUSH
67954: LD_INT 4
67956: PUSH
67957: LD_INT 5
67959: PUSH
67960: LD_INT 21
67962: PUSH
67963: LD_INT 23
67965: PUSH
67966: LD_INT 22
67968: PUSH
67969: LD_INT 24
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: ST_TO_ADDR
67987: GO 68048
67989: LD_INT 3
67991: DOUBLE
67992: EQUAL
67993: IFTRUE 67997
67995: GO 68047
67997: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67998: LD_ADDR_VAR 0 3
68002: PUSH
68003: LD_INT 13
68005: PUSH
68006: LD_INT 14
68008: PUSH
68009: LD_INT 2
68011: PUSH
68012: LD_INT 3
68014: PUSH
68015: LD_INT 4
68017: PUSH
68018: LD_INT 5
68020: PUSH
68021: LD_INT 21
68023: PUSH
68024: LD_INT 22
68026: PUSH
68027: LD_INT 23
68029: PUSH
68030: LD_INT 24
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: ST_TO_ADDR
68045: GO 68048
68047: POP
// result := ( chassis in result ) ;
68048: LD_ADDR_VAR 0 3
68052: PUSH
68053: LD_VAR 0 1
68057: PUSH
68058: LD_VAR 0 3
68062: IN
68063: ST_TO_ADDR
// end ;
68064: LD_VAR 0 3
68068: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68069: LD_INT 0
68071: PPUSH
// if not chassis or not weapon then
68072: LD_VAR 0 1
68076: NOT
68077: PUSH
68078: LD_VAR 0 2
68082: NOT
68083: OR
68084: IFFALSE 68088
// exit ;
68086: GO 69114
// case weapon of us_machine_gun :
68088: LD_VAR 0 2
68092: PUSH
68093: LD_INT 2
68095: DOUBLE
68096: EQUAL
68097: IFTRUE 68101
68099: GO 68131
68101: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68102: LD_ADDR_VAR 0 3
68106: PUSH
68107: LD_INT 1
68109: PUSH
68110: LD_INT 2
68112: PUSH
68113: LD_INT 3
68115: PUSH
68116: LD_INT 4
68118: PUSH
68119: LD_INT 5
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: ST_TO_ADDR
68129: GO 69098
68131: LD_INT 3
68133: DOUBLE
68134: EQUAL
68135: IFTRUE 68139
68137: GO 68169
68139: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68140: LD_ADDR_VAR 0 3
68144: PUSH
68145: LD_INT 1
68147: PUSH
68148: LD_INT 2
68150: PUSH
68151: LD_INT 3
68153: PUSH
68154: LD_INT 4
68156: PUSH
68157: LD_INT 5
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: ST_TO_ADDR
68167: GO 69098
68169: LD_INT 11
68171: DOUBLE
68172: EQUAL
68173: IFTRUE 68177
68175: GO 68207
68177: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68178: LD_ADDR_VAR 0 3
68182: PUSH
68183: LD_INT 1
68185: PUSH
68186: LD_INT 2
68188: PUSH
68189: LD_INT 3
68191: PUSH
68192: LD_INT 4
68194: PUSH
68195: LD_INT 5
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: ST_TO_ADDR
68205: GO 69098
68207: LD_INT 4
68209: DOUBLE
68210: EQUAL
68211: IFTRUE 68215
68213: GO 68241
68215: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68216: LD_ADDR_VAR 0 3
68220: PUSH
68221: LD_INT 2
68223: PUSH
68224: LD_INT 3
68226: PUSH
68227: LD_INT 4
68229: PUSH
68230: LD_INT 5
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: LIST
68237: LIST
68238: ST_TO_ADDR
68239: GO 69098
68241: LD_INT 5
68243: DOUBLE
68244: EQUAL
68245: IFTRUE 68249
68247: GO 68275
68249: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68250: LD_ADDR_VAR 0 3
68254: PUSH
68255: LD_INT 2
68257: PUSH
68258: LD_INT 3
68260: PUSH
68261: LD_INT 4
68263: PUSH
68264: LD_INT 5
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: ST_TO_ADDR
68273: GO 69098
68275: LD_INT 9
68277: DOUBLE
68278: EQUAL
68279: IFTRUE 68283
68281: GO 68309
68283: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68284: LD_ADDR_VAR 0 3
68288: PUSH
68289: LD_INT 2
68291: PUSH
68292: LD_INT 3
68294: PUSH
68295: LD_INT 4
68297: PUSH
68298: LD_INT 5
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: ST_TO_ADDR
68307: GO 69098
68309: LD_INT 7
68311: DOUBLE
68312: EQUAL
68313: IFTRUE 68317
68315: GO 68343
68317: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68318: LD_ADDR_VAR 0 3
68322: PUSH
68323: LD_INT 2
68325: PUSH
68326: LD_INT 3
68328: PUSH
68329: LD_INT 4
68331: PUSH
68332: LD_INT 5
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: ST_TO_ADDR
68341: GO 69098
68343: LD_INT 12
68345: DOUBLE
68346: EQUAL
68347: IFTRUE 68351
68349: GO 68377
68351: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68352: LD_ADDR_VAR 0 3
68356: PUSH
68357: LD_INT 2
68359: PUSH
68360: LD_INT 3
68362: PUSH
68363: LD_INT 4
68365: PUSH
68366: LD_INT 5
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: LIST
68373: LIST
68374: ST_TO_ADDR
68375: GO 69098
68377: LD_INT 13
68379: DOUBLE
68380: EQUAL
68381: IFTRUE 68385
68383: GO 68411
68385: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68386: LD_ADDR_VAR 0 3
68390: PUSH
68391: LD_INT 2
68393: PUSH
68394: LD_INT 3
68396: PUSH
68397: LD_INT 4
68399: PUSH
68400: LD_INT 5
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: ST_TO_ADDR
68409: GO 69098
68411: LD_INT 14
68413: DOUBLE
68414: EQUAL
68415: IFTRUE 68419
68417: GO 68437
68419: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68420: LD_ADDR_VAR 0 3
68424: PUSH
68425: LD_INT 4
68427: PUSH
68428: LD_INT 5
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: ST_TO_ADDR
68435: GO 69098
68437: LD_INT 6
68439: DOUBLE
68440: EQUAL
68441: IFTRUE 68445
68443: GO 68463
68445: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68446: LD_ADDR_VAR 0 3
68450: PUSH
68451: LD_INT 4
68453: PUSH
68454: LD_INT 5
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: ST_TO_ADDR
68461: GO 69098
68463: LD_INT 10
68465: DOUBLE
68466: EQUAL
68467: IFTRUE 68471
68469: GO 68489
68471: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68472: LD_ADDR_VAR 0 3
68476: PUSH
68477: LD_INT 4
68479: PUSH
68480: LD_INT 5
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: ST_TO_ADDR
68487: GO 69098
68489: LD_INT 22
68491: DOUBLE
68492: EQUAL
68493: IFTRUE 68497
68495: GO 68523
68497: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68498: LD_ADDR_VAR 0 3
68502: PUSH
68503: LD_INT 11
68505: PUSH
68506: LD_INT 12
68508: PUSH
68509: LD_INT 13
68511: PUSH
68512: LD_INT 14
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: ST_TO_ADDR
68521: GO 69098
68523: LD_INT 23
68525: DOUBLE
68526: EQUAL
68527: IFTRUE 68531
68529: GO 68557
68531: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68532: LD_ADDR_VAR 0 3
68536: PUSH
68537: LD_INT 11
68539: PUSH
68540: LD_INT 12
68542: PUSH
68543: LD_INT 13
68545: PUSH
68546: LD_INT 14
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: ST_TO_ADDR
68555: GO 69098
68557: LD_INT 24
68559: DOUBLE
68560: EQUAL
68561: IFTRUE 68565
68563: GO 68591
68565: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68566: LD_ADDR_VAR 0 3
68570: PUSH
68571: LD_INT 11
68573: PUSH
68574: LD_INT 12
68576: PUSH
68577: LD_INT 13
68579: PUSH
68580: LD_INT 14
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: ST_TO_ADDR
68589: GO 69098
68591: LD_INT 30
68593: DOUBLE
68594: EQUAL
68595: IFTRUE 68599
68597: GO 68625
68599: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68600: LD_ADDR_VAR 0 3
68604: PUSH
68605: LD_INT 11
68607: PUSH
68608: LD_INT 12
68610: PUSH
68611: LD_INT 13
68613: PUSH
68614: LD_INT 14
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: ST_TO_ADDR
68623: GO 69098
68625: LD_INT 25
68627: DOUBLE
68628: EQUAL
68629: IFTRUE 68633
68631: GO 68651
68633: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68634: LD_ADDR_VAR 0 3
68638: PUSH
68639: LD_INT 13
68641: PUSH
68642: LD_INT 14
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: ST_TO_ADDR
68649: GO 69098
68651: LD_INT 27
68653: DOUBLE
68654: EQUAL
68655: IFTRUE 68659
68657: GO 68677
68659: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68660: LD_ADDR_VAR 0 3
68664: PUSH
68665: LD_INT 13
68667: PUSH
68668: LD_INT 14
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: ST_TO_ADDR
68675: GO 69098
68677: LD_INT 28
68679: DOUBLE
68680: EQUAL
68681: IFTRUE 68685
68683: GO 68703
68685: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
68686: LD_ADDR_VAR 0 3
68690: PUSH
68691: LD_INT 13
68693: PUSH
68694: LD_INT 14
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: ST_TO_ADDR
68701: GO 69098
68703: LD_INT 29
68705: DOUBLE
68706: EQUAL
68707: IFTRUE 68711
68709: GO 68729
68711: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
68712: LD_ADDR_VAR 0 3
68716: PUSH
68717: LD_INT 13
68719: PUSH
68720: LD_INT 14
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: ST_TO_ADDR
68727: GO 69098
68729: LD_INT 31
68731: DOUBLE
68732: EQUAL
68733: IFTRUE 68737
68735: GO 68755
68737: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
68738: LD_ADDR_VAR 0 3
68742: PUSH
68743: LD_INT 13
68745: PUSH
68746: LD_INT 14
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: ST_TO_ADDR
68753: GO 69098
68755: LD_INT 26
68757: DOUBLE
68758: EQUAL
68759: IFTRUE 68763
68761: GO 68781
68763: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
68764: LD_ADDR_VAR 0 3
68768: PUSH
68769: LD_INT 13
68771: PUSH
68772: LD_INT 14
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: ST_TO_ADDR
68779: GO 69098
68781: LD_INT 42
68783: DOUBLE
68784: EQUAL
68785: IFTRUE 68789
68787: GO 68815
68789: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
68790: LD_ADDR_VAR 0 3
68794: PUSH
68795: LD_INT 21
68797: PUSH
68798: LD_INT 22
68800: PUSH
68801: LD_INT 23
68803: PUSH
68804: LD_INT 24
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: LIST
68811: LIST
68812: ST_TO_ADDR
68813: GO 69098
68815: LD_INT 43
68817: DOUBLE
68818: EQUAL
68819: IFTRUE 68823
68821: GO 68849
68823: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
68824: LD_ADDR_VAR 0 3
68828: PUSH
68829: LD_INT 21
68831: PUSH
68832: LD_INT 22
68834: PUSH
68835: LD_INT 23
68837: PUSH
68838: LD_INT 24
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: ST_TO_ADDR
68847: GO 69098
68849: LD_INT 44
68851: DOUBLE
68852: EQUAL
68853: IFTRUE 68857
68855: GO 68883
68857: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
68858: LD_ADDR_VAR 0 3
68862: PUSH
68863: LD_INT 21
68865: PUSH
68866: LD_INT 22
68868: PUSH
68869: LD_INT 23
68871: PUSH
68872: LD_INT 24
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: ST_TO_ADDR
68881: GO 69098
68883: LD_INT 45
68885: DOUBLE
68886: EQUAL
68887: IFTRUE 68891
68889: GO 68917
68891: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
68892: LD_ADDR_VAR 0 3
68896: PUSH
68897: LD_INT 21
68899: PUSH
68900: LD_INT 22
68902: PUSH
68903: LD_INT 23
68905: PUSH
68906: LD_INT 24
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: ST_TO_ADDR
68915: GO 69098
68917: LD_INT 49
68919: DOUBLE
68920: EQUAL
68921: IFTRUE 68925
68923: GO 68951
68925: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
68926: LD_ADDR_VAR 0 3
68930: PUSH
68931: LD_INT 21
68933: PUSH
68934: LD_INT 22
68936: PUSH
68937: LD_INT 23
68939: PUSH
68940: LD_INT 24
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: ST_TO_ADDR
68949: GO 69098
68951: LD_INT 51
68953: DOUBLE
68954: EQUAL
68955: IFTRUE 68959
68957: GO 68985
68959: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
68960: LD_ADDR_VAR 0 3
68964: PUSH
68965: LD_INT 21
68967: PUSH
68968: LD_INT 22
68970: PUSH
68971: LD_INT 23
68973: PUSH
68974: LD_INT 24
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: LIST
68981: LIST
68982: ST_TO_ADDR
68983: GO 69098
68985: LD_INT 52
68987: DOUBLE
68988: EQUAL
68989: IFTRUE 68993
68991: GO 69019
68993: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
68994: LD_ADDR_VAR 0 3
68998: PUSH
68999: LD_INT 21
69001: PUSH
69002: LD_INT 22
69004: PUSH
69005: LD_INT 23
69007: PUSH
69008: LD_INT 24
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: ST_TO_ADDR
69017: GO 69098
69019: LD_INT 53
69021: DOUBLE
69022: EQUAL
69023: IFTRUE 69027
69025: GO 69045
69027: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69028: LD_ADDR_VAR 0 3
69032: PUSH
69033: LD_INT 23
69035: PUSH
69036: LD_INT 24
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: ST_TO_ADDR
69043: GO 69098
69045: LD_INT 46
69047: DOUBLE
69048: EQUAL
69049: IFTRUE 69053
69051: GO 69071
69053: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69054: LD_ADDR_VAR 0 3
69058: PUSH
69059: LD_INT 23
69061: PUSH
69062: LD_INT 24
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: ST_TO_ADDR
69069: GO 69098
69071: LD_INT 47
69073: DOUBLE
69074: EQUAL
69075: IFTRUE 69079
69077: GO 69097
69079: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69080: LD_ADDR_VAR 0 3
69084: PUSH
69085: LD_INT 23
69087: PUSH
69088: LD_INT 24
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: ST_TO_ADDR
69095: GO 69098
69097: POP
// result := ( chassis in result ) ;
69098: LD_ADDR_VAR 0 3
69102: PUSH
69103: LD_VAR 0 1
69107: PUSH
69108: LD_VAR 0 3
69112: IN
69113: ST_TO_ADDR
// end ;
69114: LD_VAR 0 3
69118: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69119: LD_INT 0
69121: PPUSH
69122: PPUSH
69123: PPUSH
69124: PPUSH
69125: PPUSH
69126: PPUSH
69127: PPUSH
// result := array ;
69128: LD_ADDR_VAR 0 5
69132: PUSH
69133: LD_VAR 0 1
69137: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69138: LD_VAR 0 1
69142: NOT
69143: PUSH
69144: LD_VAR 0 2
69148: NOT
69149: OR
69150: PUSH
69151: LD_VAR 0 3
69155: NOT
69156: OR
69157: PUSH
69158: LD_VAR 0 2
69162: PUSH
69163: LD_VAR 0 1
69167: GREATER
69168: OR
69169: PUSH
69170: LD_VAR 0 3
69174: PUSH
69175: LD_VAR 0 1
69179: GREATER
69180: OR
69181: IFFALSE 69185
// exit ;
69183: GO 69481
// if direction then
69185: LD_VAR 0 4
69189: IFFALSE 69253
// begin d := 1 ;
69191: LD_ADDR_VAR 0 9
69195: PUSH
69196: LD_INT 1
69198: ST_TO_ADDR
// if i_from > i_to then
69199: LD_VAR 0 2
69203: PUSH
69204: LD_VAR 0 3
69208: GREATER
69209: IFFALSE 69235
// length := ( array - i_from ) + i_to else
69211: LD_ADDR_VAR 0 11
69215: PUSH
69216: LD_VAR 0 1
69220: PUSH
69221: LD_VAR 0 2
69225: MINUS
69226: PUSH
69227: LD_VAR 0 3
69231: PLUS
69232: ST_TO_ADDR
69233: GO 69251
// length := i_to - i_from ;
69235: LD_ADDR_VAR 0 11
69239: PUSH
69240: LD_VAR 0 3
69244: PUSH
69245: LD_VAR 0 2
69249: MINUS
69250: ST_TO_ADDR
// end else
69251: GO 69314
// begin d := - 1 ;
69253: LD_ADDR_VAR 0 9
69257: PUSH
69258: LD_INT 1
69260: NEG
69261: ST_TO_ADDR
// if i_from > i_to then
69262: LD_VAR 0 2
69266: PUSH
69267: LD_VAR 0 3
69271: GREATER
69272: IFFALSE 69292
// length := i_from - i_to else
69274: LD_ADDR_VAR 0 11
69278: PUSH
69279: LD_VAR 0 2
69283: PUSH
69284: LD_VAR 0 3
69288: MINUS
69289: ST_TO_ADDR
69290: GO 69314
// length := ( array - i_to ) + i_from ;
69292: LD_ADDR_VAR 0 11
69296: PUSH
69297: LD_VAR 0 1
69301: PUSH
69302: LD_VAR 0 3
69306: MINUS
69307: PUSH
69308: LD_VAR 0 2
69312: PLUS
69313: ST_TO_ADDR
// end ; if not length then
69314: LD_VAR 0 11
69318: NOT
69319: IFFALSE 69323
// exit ;
69321: GO 69481
// tmp := array ;
69323: LD_ADDR_VAR 0 10
69327: PUSH
69328: LD_VAR 0 1
69332: ST_TO_ADDR
// for i = 1 to length do
69333: LD_ADDR_VAR 0 6
69337: PUSH
69338: DOUBLE
69339: LD_INT 1
69341: DEC
69342: ST_TO_ADDR
69343: LD_VAR 0 11
69347: PUSH
69348: FOR_TO
69349: IFFALSE 69469
// begin for j = 1 to array do
69351: LD_ADDR_VAR 0 7
69355: PUSH
69356: DOUBLE
69357: LD_INT 1
69359: DEC
69360: ST_TO_ADDR
69361: LD_VAR 0 1
69365: PUSH
69366: FOR_TO
69367: IFFALSE 69455
// begin k := j + d ;
69369: LD_ADDR_VAR 0 8
69373: PUSH
69374: LD_VAR 0 7
69378: PUSH
69379: LD_VAR 0 9
69383: PLUS
69384: ST_TO_ADDR
// if k > array then
69385: LD_VAR 0 8
69389: PUSH
69390: LD_VAR 0 1
69394: GREATER
69395: IFFALSE 69405
// k := 1 ;
69397: LD_ADDR_VAR 0 8
69401: PUSH
69402: LD_INT 1
69404: ST_TO_ADDR
// if not k then
69405: LD_VAR 0 8
69409: NOT
69410: IFFALSE 69422
// k := array ;
69412: LD_ADDR_VAR 0 8
69416: PUSH
69417: LD_VAR 0 1
69421: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69422: LD_ADDR_VAR 0 10
69426: PUSH
69427: LD_VAR 0 10
69431: PPUSH
69432: LD_VAR 0 8
69436: PPUSH
69437: LD_VAR 0 1
69441: PUSH
69442: LD_VAR 0 7
69446: ARRAY
69447: PPUSH
69448: CALL_OW 1
69452: ST_TO_ADDR
// end ;
69453: GO 69366
69455: POP
69456: POP
// array := tmp ;
69457: LD_ADDR_VAR 0 1
69461: PUSH
69462: LD_VAR 0 10
69466: ST_TO_ADDR
// end ;
69467: GO 69348
69469: POP
69470: POP
// result := array ;
69471: LD_ADDR_VAR 0 5
69475: PUSH
69476: LD_VAR 0 1
69480: ST_TO_ADDR
// end ;
69481: LD_VAR 0 5
69485: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69486: LD_INT 0
69488: PPUSH
69489: PPUSH
// result := 0 ;
69490: LD_ADDR_VAR 0 3
69494: PUSH
69495: LD_INT 0
69497: ST_TO_ADDR
// if not array or not value in array then
69498: LD_VAR 0 1
69502: NOT
69503: PUSH
69504: LD_VAR 0 2
69508: PUSH
69509: LD_VAR 0 1
69513: IN
69514: NOT
69515: OR
69516: IFFALSE 69520
// exit ;
69518: GO 69574
// for i = 1 to array do
69520: LD_ADDR_VAR 0 4
69524: PUSH
69525: DOUBLE
69526: LD_INT 1
69528: DEC
69529: ST_TO_ADDR
69530: LD_VAR 0 1
69534: PUSH
69535: FOR_TO
69536: IFFALSE 69572
// if value = array [ i ] then
69538: LD_VAR 0 2
69542: PUSH
69543: LD_VAR 0 1
69547: PUSH
69548: LD_VAR 0 4
69552: ARRAY
69553: EQUAL
69554: IFFALSE 69570
// begin result := i ;
69556: LD_ADDR_VAR 0 3
69560: PUSH
69561: LD_VAR 0 4
69565: ST_TO_ADDR
// exit ;
69566: POP
69567: POP
69568: GO 69574
// end ;
69570: GO 69535
69572: POP
69573: POP
// end ;
69574: LD_VAR 0 3
69578: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69579: LD_INT 0
69581: PPUSH
// vc_chassis := chassis ;
69582: LD_ADDR_OWVAR 37
69586: PUSH
69587: LD_VAR 0 1
69591: ST_TO_ADDR
// vc_engine := engine ;
69592: LD_ADDR_OWVAR 39
69596: PUSH
69597: LD_VAR 0 2
69601: ST_TO_ADDR
// vc_control := control ;
69602: LD_ADDR_OWVAR 38
69606: PUSH
69607: LD_VAR 0 3
69611: ST_TO_ADDR
// vc_weapon := weapon ;
69612: LD_ADDR_OWVAR 40
69616: PUSH
69617: LD_VAR 0 4
69621: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69622: LD_ADDR_OWVAR 41
69626: PUSH
69627: LD_VAR 0 5
69631: ST_TO_ADDR
// end ;
69632: LD_VAR 0 6
69636: RET
// export function WantPlant ( unit ) ; var task ; begin
69637: LD_INT 0
69639: PPUSH
69640: PPUSH
// result := false ;
69641: LD_ADDR_VAR 0 2
69645: PUSH
69646: LD_INT 0
69648: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69649: LD_ADDR_VAR 0 3
69653: PUSH
69654: LD_VAR 0 1
69658: PPUSH
69659: CALL_OW 437
69663: ST_TO_ADDR
// if task then
69664: LD_VAR 0 3
69668: IFFALSE 69696
// if task [ 1 ] [ 1 ] = p then
69670: LD_VAR 0 3
69674: PUSH
69675: LD_INT 1
69677: ARRAY
69678: PUSH
69679: LD_INT 1
69681: ARRAY
69682: PUSH
69683: LD_STRING p
69685: EQUAL
69686: IFFALSE 69696
// result := true ;
69688: LD_ADDR_VAR 0 2
69692: PUSH
69693: LD_INT 1
69695: ST_TO_ADDR
// end ;
69696: LD_VAR 0 2
69700: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
69701: LD_INT 0
69703: PPUSH
69704: PPUSH
69705: PPUSH
69706: PPUSH
// if pos < 1 then
69707: LD_VAR 0 2
69711: PUSH
69712: LD_INT 1
69714: LESS
69715: IFFALSE 69719
// exit ;
69717: GO 70022
// if pos = 1 then
69719: LD_VAR 0 2
69723: PUSH
69724: LD_INT 1
69726: EQUAL
69727: IFFALSE 69760
// result := Replace ( arr , pos [ 1 ] , value ) else
69729: LD_ADDR_VAR 0 4
69733: PUSH
69734: LD_VAR 0 1
69738: PPUSH
69739: LD_VAR 0 2
69743: PUSH
69744: LD_INT 1
69746: ARRAY
69747: PPUSH
69748: LD_VAR 0 3
69752: PPUSH
69753: CALL_OW 1
69757: ST_TO_ADDR
69758: GO 70022
// begin tmp := arr ;
69760: LD_ADDR_VAR 0 6
69764: PUSH
69765: LD_VAR 0 1
69769: ST_TO_ADDR
// s_arr := [ tmp ] ;
69770: LD_ADDR_VAR 0 7
69774: PUSH
69775: LD_VAR 0 6
69779: PUSH
69780: EMPTY
69781: LIST
69782: ST_TO_ADDR
// for i = 1 to pos - 1 do
69783: LD_ADDR_VAR 0 5
69787: PUSH
69788: DOUBLE
69789: LD_INT 1
69791: DEC
69792: ST_TO_ADDR
69793: LD_VAR 0 2
69797: PUSH
69798: LD_INT 1
69800: MINUS
69801: PUSH
69802: FOR_TO
69803: IFFALSE 69848
// begin tmp := tmp [ pos [ i ] ] ;
69805: LD_ADDR_VAR 0 6
69809: PUSH
69810: LD_VAR 0 6
69814: PUSH
69815: LD_VAR 0 2
69819: PUSH
69820: LD_VAR 0 5
69824: ARRAY
69825: ARRAY
69826: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
69827: LD_ADDR_VAR 0 7
69831: PUSH
69832: LD_VAR 0 7
69836: PUSH
69837: LD_VAR 0 6
69841: PUSH
69842: EMPTY
69843: LIST
69844: ADD
69845: ST_TO_ADDR
// end ;
69846: GO 69802
69848: POP
69849: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
69850: LD_ADDR_VAR 0 6
69854: PUSH
69855: LD_VAR 0 6
69859: PPUSH
69860: LD_VAR 0 2
69864: PUSH
69865: LD_VAR 0 2
69869: ARRAY
69870: PPUSH
69871: LD_VAR 0 3
69875: PPUSH
69876: CALL_OW 1
69880: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
69881: LD_ADDR_VAR 0 7
69885: PUSH
69886: LD_VAR 0 7
69890: PPUSH
69891: LD_VAR 0 7
69895: PPUSH
69896: LD_VAR 0 6
69900: PPUSH
69901: CALL_OW 1
69905: ST_TO_ADDR
// for i = s_arr downto 2 do
69906: LD_ADDR_VAR 0 5
69910: PUSH
69911: DOUBLE
69912: LD_VAR 0 7
69916: INC
69917: ST_TO_ADDR
69918: LD_INT 2
69920: PUSH
69921: FOR_DOWNTO
69922: IFFALSE 70006
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
69924: LD_ADDR_VAR 0 6
69928: PUSH
69929: LD_VAR 0 7
69933: PUSH
69934: LD_VAR 0 5
69938: PUSH
69939: LD_INT 1
69941: MINUS
69942: ARRAY
69943: PPUSH
69944: LD_VAR 0 2
69948: PUSH
69949: LD_VAR 0 5
69953: PUSH
69954: LD_INT 1
69956: MINUS
69957: ARRAY
69958: PPUSH
69959: LD_VAR 0 7
69963: PUSH
69964: LD_VAR 0 5
69968: ARRAY
69969: PPUSH
69970: CALL_OW 1
69974: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
69975: LD_ADDR_VAR 0 7
69979: PUSH
69980: LD_VAR 0 7
69984: PPUSH
69985: LD_VAR 0 5
69989: PUSH
69990: LD_INT 1
69992: MINUS
69993: PPUSH
69994: LD_VAR 0 6
69998: PPUSH
69999: CALL_OW 1
70003: ST_TO_ADDR
// end ;
70004: GO 69921
70006: POP
70007: POP
// result := s_arr [ 1 ] ;
70008: LD_ADDR_VAR 0 4
70012: PUSH
70013: LD_VAR 0 7
70017: PUSH
70018: LD_INT 1
70020: ARRAY
70021: ST_TO_ADDR
// end ; end ;
70022: LD_VAR 0 4
70026: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70027: LD_INT 0
70029: PPUSH
70030: PPUSH
// if not list then
70031: LD_VAR 0 1
70035: NOT
70036: IFFALSE 70040
// exit ;
70038: GO 70131
// i := list [ pos1 ] ;
70040: LD_ADDR_VAR 0 5
70044: PUSH
70045: LD_VAR 0 1
70049: PUSH
70050: LD_VAR 0 2
70054: ARRAY
70055: ST_TO_ADDR
// if not i then
70056: LD_VAR 0 5
70060: NOT
70061: IFFALSE 70065
// exit ;
70063: GO 70131
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70065: LD_ADDR_VAR 0 1
70069: PUSH
70070: LD_VAR 0 1
70074: PPUSH
70075: LD_VAR 0 2
70079: PPUSH
70080: LD_VAR 0 1
70084: PUSH
70085: LD_VAR 0 3
70089: ARRAY
70090: PPUSH
70091: CALL_OW 1
70095: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70096: LD_ADDR_VAR 0 1
70100: PUSH
70101: LD_VAR 0 1
70105: PPUSH
70106: LD_VAR 0 3
70110: PPUSH
70111: LD_VAR 0 5
70115: PPUSH
70116: CALL_OW 1
70120: ST_TO_ADDR
// result := list ;
70121: LD_ADDR_VAR 0 4
70125: PUSH
70126: LD_VAR 0 1
70130: ST_TO_ADDR
// end ;
70131: LD_VAR 0 4
70135: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70136: LD_INT 0
70138: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70139: LD_ADDR_VAR 0 5
70143: PUSH
70144: LD_VAR 0 1
70148: PPUSH
70149: CALL_OW 250
70153: PPUSH
70154: LD_VAR 0 1
70158: PPUSH
70159: CALL_OW 251
70163: PPUSH
70164: LD_VAR 0 2
70168: PPUSH
70169: LD_VAR 0 3
70173: PPUSH
70174: LD_VAR 0 4
70178: PPUSH
70179: CALL 70189 0 5
70183: ST_TO_ADDR
// end ;
70184: LD_VAR 0 5
70188: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70189: LD_INT 0
70191: PPUSH
70192: PPUSH
70193: PPUSH
70194: PPUSH
// if not list then
70195: LD_VAR 0 3
70199: NOT
70200: IFFALSE 70204
// exit ;
70202: GO 70592
// result := [ ] ;
70204: LD_ADDR_VAR 0 6
70208: PUSH
70209: EMPTY
70210: ST_TO_ADDR
// for i in list do
70211: LD_ADDR_VAR 0 7
70215: PUSH
70216: LD_VAR 0 3
70220: PUSH
70221: FOR_IN
70222: IFFALSE 70424
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70224: LD_ADDR_VAR 0 9
70228: PUSH
70229: LD_VAR 0 7
70233: PPUSH
70234: LD_VAR 0 1
70238: PPUSH
70239: LD_VAR 0 2
70243: PPUSH
70244: CALL_OW 297
70248: ST_TO_ADDR
// if not result then
70249: LD_VAR 0 6
70253: NOT
70254: IFFALSE 70280
// result := [ [ i , tmp ] ] else
70256: LD_ADDR_VAR 0 6
70260: PUSH
70261: LD_VAR 0 7
70265: PUSH
70266: LD_VAR 0 9
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: EMPTY
70276: LIST
70277: ST_TO_ADDR
70278: GO 70422
// begin if result [ result ] [ 2 ] < tmp then
70280: LD_VAR 0 6
70284: PUSH
70285: LD_VAR 0 6
70289: ARRAY
70290: PUSH
70291: LD_INT 2
70293: ARRAY
70294: PUSH
70295: LD_VAR 0 9
70299: LESS
70300: IFFALSE 70342
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70302: LD_ADDR_VAR 0 6
70306: PUSH
70307: LD_VAR 0 6
70311: PPUSH
70312: LD_VAR 0 6
70316: PUSH
70317: LD_INT 1
70319: PLUS
70320: PPUSH
70321: LD_VAR 0 7
70325: PUSH
70326: LD_VAR 0 9
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PPUSH
70335: CALL_OW 2
70339: ST_TO_ADDR
70340: GO 70422
// for j = 1 to result do
70342: LD_ADDR_VAR 0 8
70346: PUSH
70347: DOUBLE
70348: LD_INT 1
70350: DEC
70351: ST_TO_ADDR
70352: LD_VAR 0 6
70356: PUSH
70357: FOR_TO
70358: IFFALSE 70420
// begin if tmp < result [ j ] [ 2 ] then
70360: LD_VAR 0 9
70364: PUSH
70365: LD_VAR 0 6
70369: PUSH
70370: LD_VAR 0 8
70374: ARRAY
70375: PUSH
70376: LD_INT 2
70378: ARRAY
70379: LESS
70380: IFFALSE 70418
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70382: LD_ADDR_VAR 0 6
70386: PUSH
70387: LD_VAR 0 6
70391: PPUSH
70392: LD_VAR 0 8
70396: PPUSH
70397: LD_VAR 0 7
70401: PUSH
70402: LD_VAR 0 9
70406: PUSH
70407: EMPTY
70408: LIST
70409: LIST
70410: PPUSH
70411: CALL_OW 2
70415: ST_TO_ADDR
// break ;
70416: GO 70420
// end ; end ;
70418: GO 70357
70420: POP
70421: POP
// end ; end ;
70422: GO 70221
70424: POP
70425: POP
// if result and not asc then
70426: LD_VAR 0 6
70430: PUSH
70431: LD_VAR 0 4
70435: NOT
70436: AND
70437: IFFALSE 70512
// begin tmp := result ;
70439: LD_ADDR_VAR 0 9
70443: PUSH
70444: LD_VAR 0 6
70448: ST_TO_ADDR
// for i = tmp downto 1 do
70449: LD_ADDR_VAR 0 7
70453: PUSH
70454: DOUBLE
70455: LD_VAR 0 9
70459: INC
70460: ST_TO_ADDR
70461: LD_INT 1
70463: PUSH
70464: FOR_DOWNTO
70465: IFFALSE 70510
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70467: LD_ADDR_VAR 0 6
70471: PUSH
70472: LD_VAR 0 6
70476: PPUSH
70477: LD_VAR 0 9
70481: PUSH
70482: LD_VAR 0 7
70486: MINUS
70487: PUSH
70488: LD_INT 1
70490: PLUS
70491: PPUSH
70492: LD_VAR 0 9
70496: PUSH
70497: LD_VAR 0 7
70501: ARRAY
70502: PPUSH
70503: CALL_OW 1
70507: ST_TO_ADDR
70508: GO 70464
70510: POP
70511: POP
// end ; tmp := [ ] ;
70512: LD_ADDR_VAR 0 9
70516: PUSH
70517: EMPTY
70518: ST_TO_ADDR
// if mode then
70519: LD_VAR 0 5
70523: IFFALSE 70592
// begin for i = 1 to result do
70525: LD_ADDR_VAR 0 7
70529: PUSH
70530: DOUBLE
70531: LD_INT 1
70533: DEC
70534: ST_TO_ADDR
70535: LD_VAR 0 6
70539: PUSH
70540: FOR_TO
70541: IFFALSE 70580
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70543: LD_ADDR_VAR 0 9
70547: PUSH
70548: LD_VAR 0 9
70552: PPUSH
70553: LD_VAR 0 7
70557: PPUSH
70558: LD_VAR 0 6
70562: PUSH
70563: LD_VAR 0 7
70567: ARRAY
70568: PUSH
70569: LD_INT 1
70571: ARRAY
70572: PPUSH
70573: CALL_OW 1
70577: ST_TO_ADDR
70578: GO 70540
70580: POP
70581: POP
// result := tmp ;
70582: LD_ADDR_VAR 0 6
70586: PUSH
70587: LD_VAR 0 9
70591: ST_TO_ADDR
// end ; end ;
70592: LD_VAR 0 6
70596: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70597: LD_INT 0
70599: PPUSH
70600: PPUSH
70601: PPUSH
70602: PPUSH
70603: PPUSH
70604: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70605: LD_ADDR_VAR 0 5
70609: PUSH
70610: LD_INT 0
70612: PUSH
70613: LD_INT 0
70615: PUSH
70616: LD_INT 0
70618: PUSH
70619: EMPTY
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: ST_TO_ADDR
// if not x or not y then
70627: LD_VAR 0 2
70631: NOT
70632: PUSH
70633: LD_VAR 0 3
70637: NOT
70638: OR
70639: IFFALSE 70643
// exit ;
70641: GO 72289
// if not range then
70643: LD_VAR 0 4
70647: NOT
70648: IFFALSE 70658
// range := 10 ;
70650: LD_ADDR_VAR 0 4
70654: PUSH
70655: LD_INT 10
70657: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70658: LD_ADDR_VAR 0 8
70662: PUSH
70663: LD_INT 81
70665: PUSH
70666: LD_VAR 0 1
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: LD_INT 92
70677: PUSH
70678: LD_VAR 0 2
70682: PUSH
70683: LD_VAR 0 3
70687: PUSH
70688: LD_VAR 0 4
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 3
70701: PUSH
70702: LD_INT 21
70704: PUSH
70705: LD_INT 3
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: LIST
70720: PPUSH
70721: CALL_OW 69
70725: ST_TO_ADDR
// if not tmp then
70726: LD_VAR 0 8
70730: NOT
70731: IFFALSE 70735
// exit ;
70733: GO 72289
// for i in tmp do
70735: LD_ADDR_VAR 0 6
70739: PUSH
70740: LD_VAR 0 8
70744: PUSH
70745: FOR_IN
70746: IFFALSE 72264
// begin points := [ 0 , 0 , 0 ] ;
70748: LD_ADDR_VAR 0 9
70752: PUSH
70753: LD_INT 0
70755: PUSH
70756: LD_INT 0
70758: PUSH
70759: LD_INT 0
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: LIST
70766: ST_TO_ADDR
// bpoints := 1 ;
70767: LD_ADDR_VAR 0 10
70771: PUSH
70772: LD_INT 1
70774: ST_TO_ADDR
// case GetType ( i ) of unit_human :
70775: LD_VAR 0 6
70779: PPUSH
70780: CALL_OW 247
70784: PUSH
70785: LD_INT 1
70787: DOUBLE
70788: EQUAL
70789: IFTRUE 70793
70791: GO 71371
70793: POP
// begin if GetClass ( i ) = 1 then
70794: LD_VAR 0 6
70798: PPUSH
70799: CALL_OW 257
70803: PUSH
70804: LD_INT 1
70806: EQUAL
70807: IFFALSE 70828
// points := [ 10 , 5 , 3 ] ;
70809: LD_ADDR_VAR 0 9
70813: PUSH
70814: LD_INT 10
70816: PUSH
70817: LD_INT 5
70819: PUSH
70820: LD_INT 3
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: LIST
70827: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
70828: LD_VAR 0 6
70832: PPUSH
70833: CALL_OW 257
70837: PUSH
70838: LD_INT 2
70840: PUSH
70841: LD_INT 3
70843: PUSH
70844: LD_INT 4
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: LIST
70851: IN
70852: IFFALSE 70873
// points := [ 3 , 2 , 1 ] ;
70854: LD_ADDR_VAR 0 9
70858: PUSH
70859: LD_INT 3
70861: PUSH
70862: LD_INT 2
70864: PUSH
70865: LD_INT 1
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: LIST
70872: ST_TO_ADDR
// if GetClass ( i ) = 5 then
70873: LD_VAR 0 6
70877: PPUSH
70878: CALL_OW 257
70882: PUSH
70883: LD_INT 5
70885: EQUAL
70886: IFFALSE 70907
// points := [ 130 , 5 , 2 ] ;
70888: LD_ADDR_VAR 0 9
70892: PUSH
70893: LD_INT 130
70895: PUSH
70896: LD_INT 5
70898: PUSH
70899: LD_INT 2
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: LIST
70906: ST_TO_ADDR
// if GetClass ( i ) = 8 then
70907: LD_VAR 0 6
70911: PPUSH
70912: CALL_OW 257
70916: PUSH
70917: LD_INT 8
70919: EQUAL
70920: IFFALSE 70941
// points := [ 35 , 35 , 30 ] ;
70922: LD_ADDR_VAR 0 9
70926: PUSH
70927: LD_INT 35
70929: PUSH
70930: LD_INT 35
70932: PUSH
70933: LD_INT 30
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: LIST
70940: ST_TO_ADDR
// if GetClass ( i ) = 9 then
70941: LD_VAR 0 6
70945: PPUSH
70946: CALL_OW 257
70950: PUSH
70951: LD_INT 9
70953: EQUAL
70954: IFFALSE 70975
// points := [ 20 , 55 , 40 ] ;
70956: LD_ADDR_VAR 0 9
70960: PUSH
70961: LD_INT 20
70963: PUSH
70964: LD_INT 55
70966: PUSH
70967: LD_INT 40
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: LIST
70974: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
70975: LD_VAR 0 6
70979: PPUSH
70980: CALL_OW 257
70984: PUSH
70985: LD_INT 12
70987: PUSH
70988: LD_INT 16
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: IN
70995: IFFALSE 71016
// points := [ 5 , 3 , 2 ] ;
70997: LD_ADDR_VAR 0 9
71001: PUSH
71002: LD_INT 5
71004: PUSH
71005: LD_INT 3
71007: PUSH
71008: LD_INT 2
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: LIST
71015: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71016: LD_VAR 0 6
71020: PPUSH
71021: CALL_OW 257
71025: PUSH
71026: LD_INT 17
71028: EQUAL
71029: IFFALSE 71050
// points := [ 100 , 50 , 75 ] ;
71031: LD_ADDR_VAR 0 9
71035: PUSH
71036: LD_INT 100
71038: PUSH
71039: LD_INT 50
71041: PUSH
71042: LD_INT 75
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: LIST
71049: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71050: LD_VAR 0 6
71054: PPUSH
71055: CALL_OW 257
71059: PUSH
71060: LD_INT 15
71062: EQUAL
71063: IFFALSE 71084
// points := [ 10 , 5 , 3 ] ;
71065: LD_ADDR_VAR 0 9
71069: PUSH
71070: LD_INT 10
71072: PUSH
71073: LD_INT 5
71075: PUSH
71076: LD_INT 3
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: LIST
71083: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71084: LD_VAR 0 6
71088: PPUSH
71089: CALL_OW 257
71093: PUSH
71094: LD_INT 14
71096: EQUAL
71097: IFFALSE 71118
// points := [ 10 , 0 , 0 ] ;
71099: LD_ADDR_VAR 0 9
71103: PUSH
71104: LD_INT 10
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: LD_INT 0
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: LIST
71117: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71118: LD_VAR 0 6
71122: PPUSH
71123: CALL_OW 257
71127: PUSH
71128: LD_INT 11
71130: EQUAL
71131: IFFALSE 71152
// points := [ 30 , 10 , 5 ] ;
71133: LD_ADDR_VAR 0 9
71137: PUSH
71138: LD_INT 30
71140: PUSH
71141: LD_INT 10
71143: PUSH
71144: LD_INT 5
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: LIST
71151: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71152: LD_VAR 0 1
71156: PPUSH
71157: LD_INT 5
71159: PPUSH
71160: CALL_OW 321
71164: PUSH
71165: LD_INT 2
71167: EQUAL
71168: IFFALSE 71185
// bpoints := bpoints * 1.8 ;
71170: LD_ADDR_VAR 0 10
71174: PUSH
71175: LD_VAR 0 10
71179: PUSH
71180: LD_REAL  1.80000000000000E+0000
71183: MUL
71184: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71185: LD_VAR 0 6
71189: PPUSH
71190: CALL_OW 257
71194: PUSH
71195: LD_INT 1
71197: PUSH
71198: LD_INT 2
71200: PUSH
71201: LD_INT 3
71203: PUSH
71204: LD_INT 4
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: LIST
71211: LIST
71212: IN
71213: PUSH
71214: LD_VAR 0 1
71218: PPUSH
71219: LD_INT 51
71221: PPUSH
71222: CALL_OW 321
71226: PUSH
71227: LD_INT 2
71229: EQUAL
71230: AND
71231: IFFALSE 71248
// bpoints := bpoints * 1.2 ;
71233: LD_ADDR_VAR 0 10
71237: PUSH
71238: LD_VAR 0 10
71242: PUSH
71243: LD_REAL  1.20000000000000E+0000
71246: MUL
71247: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71248: LD_VAR 0 6
71252: PPUSH
71253: CALL_OW 257
71257: PUSH
71258: LD_INT 5
71260: PUSH
71261: LD_INT 7
71263: PUSH
71264: LD_INT 9
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: LIST
71271: IN
71272: PUSH
71273: LD_VAR 0 1
71277: PPUSH
71278: LD_INT 52
71280: PPUSH
71281: CALL_OW 321
71285: PUSH
71286: LD_INT 2
71288: EQUAL
71289: AND
71290: IFFALSE 71307
// bpoints := bpoints * 1.5 ;
71292: LD_ADDR_VAR 0 10
71296: PUSH
71297: LD_VAR 0 10
71301: PUSH
71302: LD_REAL  1.50000000000000E+0000
71305: MUL
71306: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71307: LD_VAR 0 1
71311: PPUSH
71312: LD_INT 66
71314: PPUSH
71315: CALL_OW 321
71319: PUSH
71320: LD_INT 2
71322: EQUAL
71323: IFFALSE 71340
// bpoints := bpoints * 1.1 ;
71325: LD_ADDR_VAR 0 10
71329: PUSH
71330: LD_VAR 0 10
71334: PUSH
71335: LD_REAL  1.10000000000000E+0000
71338: MUL
71339: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71340: LD_ADDR_VAR 0 10
71344: PUSH
71345: LD_VAR 0 10
71349: PUSH
71350: LD_VAR 0 6
71354: PPUSH
71355: LD_INT 1
71357: PPUSH
71358: CALL_OW 259
71362: PUSH
71363: LD_REAL  1.15000000000000E+0000
71366: MUL
71367: MUL
71368: ST_TO_ADDR
// end ; unit_vehicle :
71369: GO 72193
71371: LD_INT 2
71373: DOUBLE
71374: EQUAL
71375: IFTRUE 71379
71377: GO 72181
71379: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71380: LD_VAR 0 6
71384: PPUSH
71385: CALL_OW 264
71389: PUSH
71390: LD_INT 2
71392: PUSH
71393: LD_INT 42
71395: PUSH
71396: LD_INT 24
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: LIST
71403: IN
71404: IFFALSE 71425
// points := [ 25 , 5 , 3 ] ;
71406: LD_ADDR_VAR 0 9
71410: PUSH
71411: LD_INT 25
71413: PUSH
71414: LD_INT 5
71416: PUSH
71417: LD_INT 3
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: LIST
71424: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71425: LD_VAR 0 6
71429: PPUSH
71430: CALL_OW 264
71434: PUSH
71435: LD_INT 4
71437: PUSH
71438: LD_INT 43
71440: PUSH
71441: LD_INT 25
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: LIST
71448: IN
71449: IFFALSE 71470
// points := [ 40 , 15 , 5 ] ;
71451: LD_ADDR_VAR 0 9
71455: PUSH
71456: LD_INT 40
71458: PUSH
71459: LD_INT 15
71461: PUSH
71462: LD_INT 5
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: LIST
71469: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71470: LD_VAR 0 6
71474: PPUSH
71475: CALL_OW 264
71479: PUSH
71480: LD_INT 3
71482: PUSH
71483: LD_INT 23
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: IN
71490: IFFALSE 71511
// points := [ 7 , 25 , 8 ] ;
71492: LD_ADDR_VAR 0 9
71496: PUSH
71497: LD_INT 7
71499: PUSH
71500: LD_INT 25
71502: PUSH
71503: LD_INT 8
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: LIST
71510: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71511: LD_VAR 0 6
71515: PPUSH
71516: CALL_OW 264
71520: PUSH
71521: LD_INT 5
71523: PUSH
71524: LD_INT 27
71526: PUSH
71527: LD_INT 44
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: LIST
71534: IN
71535: IFFALSE 71556
// points := [ 14 , 50 , 16 ] ;
71537: LD_ADDR_VAR 0 9
71541: PUSH
71542: LD_INT 14
71544: PUSH
71545: LD_INT 50
71547: PUSH
71548: LD_INT 16
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: LIST
71555: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71556: LD_VAR 0 6
71560: PPUSH
71561: CALL_OW 264
71565: PUSH
71566: LD_INT 6
71568: PUSH
71569: LD_INT 46
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: IN
71576: IFFALSE 71597
// points := [ 32 , 120 , 70 ] ;
71578: LD_ADDR_VAR 0 9
71582: PUSH
71583: LD_INT 32
71585: PUSH
71586: LD_INT 120
71588: PUSH
71589: LD_INT 70
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: LIST
71596: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71597: LD_VAR 0 6
71601: PPUSH
71602: CALL_OW 264
71606: PUSH
71607: LD_INT 7
71609: PUSH
71610: LD_INT 28
71612: PUSH
71613: LD_INT 45
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: LIST
71620: IN
71621: IFFALSE 71642
// points := [ 35 , 20 , 45 ] ;
71623: LD_ADDR_VAR 0 9
71627: PUSH
71628: LD_INT 35
71630: PUSH
71631: LD_INT 20
71633: PUSH
71634: LD_INT 45
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: LIST
71641: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71642: LD_VAR 0 6
71646: PPUSH
71647: CALL_OW 264
71651: PUSH
71652: LD_INT 47
71654: PUSH
71655: EMPTY
71656: LIST
71657: IN
71658: IFFALSE 71679
// points := [ 67 , 45 , 75 ] ;
71660: LD_ADDR_VAR 0 9
71664: PUSH
71665: LD_INT 67
71667: PUSH
71668: LD_INT 45
71670: PUSH
71671: LD_INT 75
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: LIST
71678: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71679: LD_VAR 0 6
71683: PPUSH
71684: CALL_OW 264
71688: PUSH
71689: LD_INT 26
71691: PUSH
71692: EMPTY
71693: LIST
71694: IN
71695: IFFALSE 71716
// points := [ 120 , 30 , 80 ] ;
71697: LD_ADDR_VAR 0 9
71701: PUSH
71702: LD_INT 120
71704: PUSH
71705: LD_INT 30
71707: PUSH
71708: LD_INT 80
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: LIST
71715: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
71716: LD_VAR 0 6
71720: PPUSH
71721: CALL_OW 264
71725: PUSH
71726: LD_INT 22
71728: PUSH
71729: EMPTY
71730: LIST
71731: IN
71732: IFFALSE 71753
// points := [ 40 , 1 , 1 ] ;
71734: LD_ADDR_VAR 0 9
71738: PUSH
71739: LD_INT 40
71741: PUSH
71742: LD_INT 1
71744: PUSH
71745: LD_INT 1
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: LIST
71752: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
71753: LD_VAR 0 6
71757: PPUSH
71758: CALL_OW 264
71762: PUSH
71763: LD_INT 29
71765: PUSH
71766: EMPTY
71767: LIST
71768: IN
71769: IFFALSE 71790
// points := [ 70 , 200 , 400 ] ;
71771: LD_ADDR_VAR 0 9
71775: PUSH
71776: LD_INT 70
71778: PUSH
71779: LD_INT 200
71781: PUSH
71782: LD_INT 400
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: LIST
71789: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
71790: LD_VAR 0 6
71794: PPUSH
71795: CALL_OW 264
71799: PUSH
71800: LD_INT 14
71802: PUSH
71803: LD_INT 53
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: IN
71810: IFFALSE 71831
// points := [ 40 , 10 , 20 ] ;
71812: LD_ADDR_VAR 0 9
71816: PUSH
71817: LD_INT 40
71819: PUSH
71820: LD_INT 10
71822: PUSH
71823: LD_INT 20
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: LIST
71830: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
71831: LD_VAR 0 6
71835: PPUSH
71836: CALL_OW 264
71840: PUSH
71841: LD_INT 9
71843: PUSH
71844: EMPTY
71845: LIST
71846: IN
71847: IFFALSE 71868
// points := [ 5 , 70 , 20 ] ;
71849: LD_ADDR_VAR 0 9
71853: PUSH
71854: LD_INT 5
71856: PUSH
71857: LD_INT 70
71859: PUSH
71860: LD_INT 20
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: LIST
71867: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
71868: LD_VAR 0 6
71872: PPUSH
71873: CALL_OW 264
71877: PUSH
71878: LD_INT 10
71880: PUSH
71881: EMPTY
71882: LIST
71883: IN
71884: IFFALSE 71905
// points := [ 35 , 110 , 70 ] ;
71886: LD_ADDR_VAR 0 9
71890: PUSH
71891: LD_INT 35
71893: PUSH
71894: LD_INT 110
71896: PUSH
71897: LD_INT 70
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: LIST
71904: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
71905: LD_VAR 0 6
71909: PPUSH
71910: CALL_OW 265
71914: PUSH
71915: LD_INT 25
71917: EQUAL
71918: IFFALSE 71939
// points := [ 80 , 65 , 100 ] ;
71920: LD_ADDR_VAR 0 9
71924: PUSH
71925: LD_INT 80
71927: PUSH
71928: LD_INT 65
71930: PUSH
71931: LD_INT 100
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: LIST
71938: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
71939: LD_VAR 0 6
71943: PPUSH
71944: CALL_OW 263
71948: PUSH
71949: LD_INT 1
71951: EQUAL
71952: IFFALSE 71987
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
71954: LD_ADDR_VAR 0 10
71958: PUSH
71959: LD_VAR 0 10
71963: PUSH
71964: LD_VAR 0 6
71968: PPUSH
71969: CALL_OW 311
71973: PPUSH
71974: LD_INT 3
71976: PPUSH
71977: CALL_OW 259
71981: PUSH
71982: LD_INT 4
71984: MUL
71985: MUL
71986: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
71987: LD_VAR 0 6
71991: PPUSH
71992: CALL_OW 263
71996: PUSH
71997: LD_INT 2
71999: EQUAL
72000: IFFALSE 72051
// begin j := IsControledBy ( i ) ;
72002: LD_ADDR_VAR 0 7
72006: PUSH
72007: LD_VAR 0 6
72011: PPUSH
72012: CALL_OW 312
72016: ST_TO_ADDR
// if j then
72017: LD_VAR 0 7
72021: IFFALSE 72051
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72023: LD_ADDR_VAR 0 10
72027: PUSH
72028: LD_VAR 0 10
72032: PUSH
72033: LD_VAR 0 7
72037: PPUSH
72038: LD_INT 3
72040: PPUSH
72041: CALL_OW 259
72045: PUSH
72046: LD_INT 3
72048: MUL
72049: MUL
72050: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72051: LD_VAR 0 6
72055: PPUSH
72056: CALL_OW 264
72060: PUSH
72061: LD_INT 5
72063: PUSH
72064: LD_INT 6
72066: PUSH
72067: LD_INT 46
72069: PUSH
72070: LD_INT 44
72072: PUSH
72073: LD_INT 47
72075: PUSH
72076: LD_INT 45
72078: PUSH
72079: LD_INT 28
72081: PUSH
72082: LD_INT 7
72084: PUSH
72085: LD_INT 27
72087: PUSH
72088: LD_INT 29
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: IN
72103: PUSH
72104: LD_VAR 0 1
72108: PPUSH
72109: LD_INT 52
72111: PPUSH
72112: CALL_OW 321
72116: PUSH
72117: LD_INT 2
72119: EQUAL
72120: AND
72121: IFFALSE 72138
// bpoints := bpoints * 1.2 ;
72123: LD_ADDR_VAR 0 10
72127: PUSH
72128: LD_VAR 0 10
72132: PUSH
72133: LD_REAL  1.20000000000000E+0000
72136: MUL
72137: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72138: LD_VAR 0 6
72142: PPUSH
72143: CALL_OW 264
72147: PUSH
72148: LD_INT 6
72150: PUSH
72151: LD_INT 46
72153: PUSH
72154: LD_INT 47
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: LIST
72161: IN
72162: IFFALSE 72179
// bpoints := bpoints * 1.2 ;
72164: LD_ADDR_VAR 0 10
72168: PUSH
72169: LD_VAR 0 10
72173: PUSH
72174: LD_REAL  1.20000000000000E+0000
72177: MUL
72178: ST_TO_ADDR
// end ; unit_building :
72179: GO 72193
72181: LD_INT 3
72183: DOUBLE
72184: EQUAL
72185: IFTRUE 72189
72187: GO 72192
72189: POP
// ; end ;
72190: GO 72193
72192: POP
// for j = 1 to 3 do
72193: LD_ADDR_VAR 0 7
72197: PUSH
72198: DOUBLE
72199: LD_INT 1
72201: DEC
72202: ST_TO_ADDR
72203: LD_INT 3
72205: PUSH
72206: FOR_TO
72207: IFFALSE 72260
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72209: LD_ADDR_VAR 0 5
72213: PUSH
72214: LD_VAR 0 5
72218: PPUSH
72219: LD_VAR 0 7
72223: PPUSH
72224: LD_VAR 0 5
72228: PUSH
72229: LD_VAR 0 7
72233: ARRAY
72234: PUSH
72235: LD_VAR 0 9
72239: PUSH
72240: LD_VAR 0 7
72244: ARRAY
72245: PUSH
72246: LD_VAR 0 10
72250: MUL
72251: PLUS
72252: PPUSH
72253: CALL_OW 1
72257: ST_TO_ADDR
72258: GO 72206
72260: POP
72261: POP
// end ;
72262: GO 70745
72264: POP
72265: POP
// result := Replace ( result , 4 , tmp ) ;
72266: LD_ADDR_VAR 0 5
72270: PUSH
72271: LD_VAR 0 5
72275: PPUSH
72276: LD_INT 4
72278: PPUSH
72279: LD_VAR 0 8
72283: PPUSH
72284: CALL_OW 1
72288: ST_TO_ADDR
// end ;
72289: LD_VAR 0 5
72293: RET
// export function DangerAtRange ( unit , range ) ; begin
72294: LD_INT 0
72296: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72297: LD_ADDR_VAR 0 3
72301: PUSH
72302: LD_VAR 0 1
72306: PPUSH
72307: CALL_OW 255
72311: PPUSH
72312: LD_VAR 0 1
72316: PPUSH
72317: CALL_OW 250
72321: PPUSH
72322: LD_VAR 0 1
72326: PPUSH
72327: CALL_OW 251
72331: PPUSH
72332: LD_VAR 0 2
72336: PPUSH
72337: CALL 70597 0 4
72341: ST_TO_ADDR
// end ;
72342: LD_VAR 0 3
72346: RET
// export function DangerInArea ( side , area ) ; begin
72347: LD_INT 0
72349: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72350: LD_ADDR_VAR 0 3
72354: PUSH
72355: LD_VAR 0 2
72359: PPUSH
72360: LD_INT 81
72362: PUSH
72363: LD_VAR 0 1
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PPUSH
72372: CALL_OW 70
72376: ST_TO_ADDR
// end ;
72377: LD_VAR 0 3
72381: RET
// export function IsExtension ( b ) ; begin
72382: LD_INT 0
72384: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72385: LD_ADDR_VAR 0 2
72389: PUSH
72390: LD_VAR 0 1
72394: PUSH
72395: LD_INT 23
72397: PUSH
72398: LD_INT 20
72400: PUSH
72401: LD_INT 22
72403: PUSH
72404: LD_INT 17
72406: PUSH
72407: LD_INT 24
72409: PUSH
72410: LD_INT 21
72412: PUSH
72413: LD_INT 19
72415: PUSH
72416: LD_INT 16
72418: PUSH
72419: LD_INT 25
72421: PUSH
72422: LD_INT 18
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: IN
72437: ST_TO_ADDR
// end ;
72438: LD_VAR 0 2
72442: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72443: LD_INT 0
72445: PPUSH
72446: PPUSH
72447: PPUSH
// result := [ ] ;
72448: LD_ADDR_VAR 0 3
72452: PUSH
72453: EMPTY
72454: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72455: LD_ADDR_VAR 0 4
72459: PUSH
72460: LD_VAR 0 2
72464: PPUSH
72465: LD_INT 21
72467: PUSH
72468: LD_INT 3
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: PPUSH
72475: CALL_OW 70
72479: ST_TO_ADDR
// if not tmp then
72480: LD_VAR 0 4
72484: NOT
72485: IFFALSE 72489
// exit ;
72487: GO 72547
// for i in tmp do
72489: LD_ADDR_VAR 0 5
72493: PUSH
72494: LD_VAR 0 4
72498: PUSH
72499: FOR_IN
72500: IFFALSE 72535
// if GetBase ( i ) <> base then
72502: LD_VAR 0 5
72506: PPUSH
72507: CALL_OW 274
72511: PUSH
72512: LD_VAR 0 1
72516: NONEQUAL
72517: IFFALSE 72533
// ComLinkToBase ( base , i ) ;
72519: LD_VAR 0 1
72523: PPUSH
72524: LD_VAR 0 5
72528: PPUSH
72529: CALL_OW 169
72533: GO 72499
72535: POP
72536: POP
// result := tmp ;
72537: LD_ADDR_VAR 0 3
72541: PUSH
72542: LD_VAR 0 4
72546: ST_TO_ADDR
// end ;
72547: LD_VAR 0 3
72551: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72552: LD_INT 0
72554: PPUSH
72555: PPUSH
// if BuildingStatus ( b ) = bs_build then
72556: LD_VAR 0 2
72560: PPUSH
72561: CALL_OW 461
72565: PUSH
72566: LD_INT 1
72568: EQUAL
72569: IFFALSE 72629
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72571: LD_VAR 0 1
72575: PPUSH
72576: LD_STRING h
72578: PUSH
72579: LD_VAR 0 2
72583: PPUSH
72584: CALL_OW 250
72588: PUSH
72589: LD_VAR 0 2
72593: PPUSH
72594: CALL_OW 251
72598: PUSH
72599: LD_VAR 0 2
72603: PUSH
72604: LD_INT 0
72606: PUSH
72607: LD_INT 0
72609: PUSH
72610: LD_INT 0
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: PUSH
72622: EMPTY
72623: LIST
72624: PPUSH
72625: CALL_OW 446
// end ;
72629: LD_VAR 0 3
72633: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72634: LD_INT 0
72636: PPUSH
72637: PPUSH
72638: PPUSH
72639: PPUSH
72640: PPUSH
72641: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72642: LD_VAR 0 1
72646: NOT
72647: PUSH
72648: LD_VAR 0 1
72652: PPUSH
72653: CALL_OW 263
72657: PUSH
72658: LD_INT 2
72660: EQUAL
72661: NOT
72662: OR
72663: IFFALSE 72667
// exit ;
72665: GO 72983
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72667: LD_ADDR_VAR 0 6
72671: PUSH
72672: LD_INT 22
72674: PUSH
72675: LD_VAR 0 1
72679: PPUSH
72680: CALL_OW 255
72684: PUSH
72685: EMPTY
72686: LIST
72687: LIST
72688: PUSH
72689: LD_INT 2
72691: PUSH
72692: LD_INT 30
72694: PUSH
72695: LD_INT 36
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 34
72704: PUSH
72705: LD_INT 31
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: LIST
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PPUSH
72721: CALL_OW 69
72725: ST_TO_ADDR
// if not tmp then
72726: LD_VAR 0 6
72730: NOT
72731: IFFALSE 72735
// exit ;
72733: GO 72983
// result := [ ] ;
72735: LD_ADDR_VAR 0 2
72739: PUSH
72740: EMPTY
72741: ST_TO_ADDR
// for i in tmp do
72742: LD_ADDR_VAR 0 3
72746: PUSH
72747: LD_VAR 0 6
72751: PUSH
72752: FOR_IN
72753: IFFALSE 72824
// begin t := UnitsInside ( i ) ;
72755: LD_ADDR_VAR 0 4
72759: PUSH
72760: LD_VAR 0 3
72764: PPUSH
72765: CALL_OW 313
72769: ST_TO_ADDR
// if t then
72770: LD_VAR 0 4
72774: IFFALSE 72822
// for j in t do
72776: LD_ADDR_VAR 0 7
72780: PUSH
72781: LD_VAR 0 4
72785: PUSH
72786: FOR_IN
72787: IFFALSE 72820
// result := Insert ( result , result + 1 , j ) ;
72789: LD_ADDR_VAR 0 2
72793: PUSH
72794: LD_VAR 0 2
72798: PPUSH
72799: LD_VAR 0 2
72803: PUSH
72804: LD_INT 1
72806: PLUS
72807: PPUSH
72808: LD_VAR 0 7
72812: PPUSH
72813: CALL_OW 2
72817: ST_TO_ADDR
72818: GO 72786
72820: POP
72821: POP
// end ;
72822: GO 72752
72824: POP
72825: POP
// if not result then
72826: LD_VAR 0 2
72830: NOT
72831: IFFALSE 72835
// exit ;
72833: GO 72983
// mech := result [ 1 ] ;
72835: LD_ADDR_VAR 0 5
72839: PUSH
72840: LD_VAR 0 2
72844: PUSH
72845: LD_INT 1
72847: ARRAY
72848: ST_TO_ADDR
// if result > 1 then
72849: LD_VAR 0 2
72853: PUSH
72854: LD_INT 1
72856: GREATER
72857: IFFALSE 72969
// for i = 2 to result do
72859: LD_ADDR_VAR 0 3
72863: PUSH
72864: DOUBLE
72865: LD_INT 2
72867: DEC
72868: ST_TO_ADDR
72869: LD_VAR 0 2
72873: PUSH
72874: FOR_TO
72875: IFFALSE 72967
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
72877: LD_ADDR_VAR 0 4
72881: PUSH
72882: LD_VAR 0 2
72886: PUSH
72887: LD_VAR 0 3
72891: ARRAY
72892: PPUSH
72893: LD_INT 3
72895: PPUSH
72896: CALL_OW 259
72900: PUSH
72901: LD_VAR 0 2
72905: PUSH
72906: LD_VAR 0 3
72910: ARRAY
72911: PPUSH
72912: CALL_OW 432
72916: MINUS
72917: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
72918: LD_VAR 0 4
72922: PUSH
72923: LD_VAR 0 5
72927: PPUSH
72928: LD_INT 3
72930: PPUSH
72931: CALL_OW 259
72935: PUSH
72936: LD_VAR 0 5
72940: PPUSH
72941: CALL_OW 432
72945: MINUS
72946: GREATEREQUAL
72947: IFFALSE 72965
// mech := result [ i ] ;
72949: LD_ADDR_VAR 0 5
72953: PUSH
72954: LD_VAR 0 2
72958: PUSH
72959: LD_VAR 0 3
72963: ARRAY
72964: ST_TO_ADDR
// end ;
72965: GO 72874
72967: POP
72968: POP
// ComLinkTo ( vehicle , mech ) ;
72969: LD_VAR 0 1
72973: PPUSH
72974: LD_VAR 0 5
72978: PPUSH
72979: CALL_OW 135
// end ;
72983: LD_VAR 0 2
72987: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
72988: LD_INT 0
72990: PPUSH
72991: PPUSH
72992: PPUSH
72993: PPUSH
72994: PPUSH
72995: PPUSH
72996: PPUSH
72997: PPUSH
72998: PPUSH
72999: PPUSH
73000: PPUSH
73001: PPUSH
73002: PPUSH
// result := [ ] ;
73003: LD_ADDR_VAR 0 7
73007: PUSH
73008: EMPTY
73009: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73010: LD_VAR 0 1
73014: PPUSH
73015: CALL_OW 266
73019: PUSH
73020: LD_INT 0
73022: PUSH
73023: LD_INT 1
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: IN
73030: NOT
73031: IFFALSE 73035
// exit ;
73033: GO 74666
// if name then
73035: LD_VAR 0 3
73039: IFFALSE 73055
// SetBName ( base_dep , name ) ;
73041: LD_VAR 0 1
73045: PPUSH
73046: LD_VAR 0 3
73050: PPUSH
73051: CALL_OW 500
// base := GetBase ( base_dep ) ;
73055: LD_ADDR_VAR 0 15
73059: PUSH
73060: LD_VAR 0 1
73064: PPUSH
73065: CALL_OW 274
73069: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73070: LD_ADDR_VAR 0 16
73074: PUSH
73075: LD_VAR 0 1
73079: PPUSH
73080: CALL_OW 255
73084: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73085: LD_ADDR_VAR 0 17
73089: PUSH
73090: LD_VAR 0 1
73094: PPUSH
73095: CALL_OW 248
73099: ST_TO_ADDR
// if sources then
73100: LD_VAR 0 5
73104: IFFALSE 73151
// for i = 1 to 3 do
73106: LD_ADDR_VAR 0 8
73110: PUSH
73111: DOUBLE
73112: LD_INT 1
73114: DEC
73115: ST_TO_ADDR
73116: LD_INT 3
73118: PUSH
73119: FOR_TO
73120: IFFALSE 73149
// AddResourceType ( base , i , sources [ i ] ) ;
73122: LD_VAR 0 15
73126: PPUSH
73127: LD_VAR 0 8
73131: PPUSH
73132: LD_VAR 0 5
73136: PUSH
73137: LD_VAR 0 8
73141: ARRAY
73142: PPUSH
73143: CALL_OW 276
73147: GO 73119
73149: POP
73150: POP
// buildings := GetBaseBuildings ( base , area ) ;
73151: LD_ADDR_VAR 0 18
73155: PUSH
73156: LD_VAR 0 15
73160: PPUSH
73161: LD_VAR 0 2
73165: PPUSH
73166: CALL 72443 0 2
73170: ST_TO_ADDR
// InitHc ;
73171: CALL_OW 19
// InitUc ;
73175: CALL_OW 18
// uc_side := side ;
73179: LD_ADDR_OWVAR 20
73183: PUSH
73184: LD_VAR 0 16
73188: ST_TO_ADDR
// uc_nation := nation ;
73189: LD_ADDR_OWVAR 21
73193: PUSH
73194: LD_VAR 0 17
73198: ST_TO_ADDR
// if buildings then
73199: LD_VAR 0 18
73203: IFFALSE 74525
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73205: LD_ADDR_VAR 0 19
73209: PUSH
73210: LD_VAR 0 18
73214: PPUSH
73215: LD_INT 2
73217: PUSH
73218: LD_INT 30
73220: PUSH
73221: LD_INT 29
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 30
73230: PUSH
73231: LD_INT 30
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: LIST
73242: PPUSH
73243: CALL_OW 72
73247: ST_TO_ADDR
// if tmp then
73248: LD_VAR 0 19
73252: IFFALSE 73300
// for i in tmp do
73254: LD_ADDR_VAR 0 8
73258: PUSH
73259: LD_VAR 0 19
73263: PUSH
73264: FOR_IN
73265: IFFALSE 73298
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73267: LD_VAR 0 8
73271: PPUSH
73272: CALL_OW 250
73276: PPUSH
73277: LD_VAR 0 8
73281: PPUSH
73282: CALL_OW 251
73286: PPUSH
73287: LD_VAR 0 16
73291: PPUSH
73292: CALL_OW 441
73296: GO 73264
73298: POP
73299: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73300: LD_VAR 0 18
73304: PPUSH
73305: LD_INT 2
73307: PUSH
73308: LD_INT 30
73310: PUSH
73311: LD_INT 32
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PUSH
73318: LD_INT 30
73320: PUSH
73321: LD_INT 33
73323: PUSH
73324: EMPTY
73325: LIST
73326: LIST
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: LIST
73332: PPUSH
73333: CALL_OW 72
73337: IFFALSE 73425
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73339: LD_ADDR_VAR 0 8
73343: PUSH
73344: LD_VAR 0 18
73348: PPUSH
73349: LD_INT 2
73351: PUSH
73352: LD_INT 30
73354: PUSH
73355: LD_INT 32
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 30
73364: PUSH
73365: LD_INT 33
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: LIST
73376: PPUSH
73377: CALL_OW 72
73381: PUSH
73382: FOR_IN
73383: IFFALSE 73423
// begin if not GetBWeapon ( i ) then
73385: LD_VAR 0 8
73389: PPUSH
73390: CALL_OW 269
73394: NOT
73395: IFFALSE 73421
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73397: LD_VAR 0 8
73401: PPUSH
73402: LD_VAR 0 8
73406: PPUSH
73407: LD_VAR 0 2
73411: PPUSH
73412: CALL 74671 0 2
73416: PPUSH
73417: CALL_OW 431
// end ;
73421: GO 73382
73423: POP
73424: POP
// end ; for i = 1 to personel do
73425: LD_ADDR_VAR 0 8
73429: PUSH
73430: DOUBLE
73431: LD_INT 1
73433: DEC
73434: ST_TO_ADDR
73435: LD_VAR 0 6
73439: PUSH
73440: FOR_TO
73441: IFFALSE 74505
// begin if i > 4 then
73443: LD_VAR 0 8
73447: PUSH
73448: LD_INT 4
73450: GREATER
73451: IFFALSE 73455
// break ;
73453: GO 74505
// case i of 1 :
73455: LD_VAR 0 8
73459: PUSH
73460: LD_INT 1
73462: DOUBLE
73463: EQUAL
73464: IFTRUE 73468
73466: GO 73548
73468: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73469: LD_ADDR_VAR 0 12
73473: PUSH
73474: LD_VAR 0 18
73478: PPUSH
73479: LD_INT 22
73481: PUSH
73482: LD_VAR 0 16
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 58
73493: PUSH
73494: EMPTY
73495: LIST
73496: PUSH
73497: LD_INT 2
73499: PUSH
73500: LD_INT 30
73502: PUSH
73503: LD_INT 32
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: LD_INT 30
73512: PUSH
73513: LD_INT 4
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: PUSH
73520: LD_INT 30
73522: PUSH
73523: LD_INT 5
73525: PUSH
73526: EMPTY
73527: LIST
73528: LIST
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: LIST
73540: PPUSH
73541: CALL_OW 72
73545: ST_TO_ADDR
73546: GO 73770
73548: LD_INT 2
73550: DOUBLE
73551: EQUAL
73552: IFTRUE 73556
73554: GO 73618
73556: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73557: LD_ADDR_VAR 0 12
73561: PUSH
73562: LD_VAR 0 18
73566: PPUSH
73567: LD_INT 22
73569: PUSH
73570: LD_VAR 0 16
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 2
73581: PUSH
73582: LD_INT 30
73584: PUSH
73585: LD_INT 0
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: PUSH
73592: LD_INT 30
73594: PUSH
73595: LD_INT 1
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: LIST
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PPUSH
73611: CALL_OW 72
73615: ST_TO_ADDR
73616: GO 73770
73618: LD_INT 3
73620: DOUBLE
73621: EQUAL
73622: IFTRUE 73626
73624: GO 73688
73626: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73627: LD_ADDR_VAR 0 12
73631: PUSH
73632: LD_VAR 0 18
73636: PPUSH
73637: LD_INT 22
73639: PUSH
73640: LD_VAR 0 16
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 2
73651: PUSH
73652: LD_INT 30
73654: PUSH
73655: LD_INT 2
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: LD_INT 30
73664: PUSH
73665: LD_INT 3
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: LIST
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PPUSH
73681: CALL_OW 72
73685: ST_TO_ADDR
73686: GO 73770
73688: LD_INT 4
73690: DOUBLE
73691: EQUAL
73692: IFTRUE 73696
73694: GO 73769
73696: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
73697: LD_ADDR_VAR 0 12
73701: PUSH
73702: LD_VAR 0 18
73706: PPUSH
73707: LD_INT 22
73709: PUSH
73710: LD_VAR 0 16
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: PUSH
73719: LD_INT 2
73721: PUSH
73722: LD_INT 30
73724: PUSH
73725: LD_INT 6
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: PUSH
73732: LD_INT 30
73734: PUSH
73735: LD_INT 7
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 30
73744: PUSH
73745: LD_INT 8
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: PUSH
73752: EMPTY
73753: LIST
73754: LIST
73755: LIST
73756: LIST
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: PPUSH
73762: CALL_OW 72
73766: ST_TO_ADDR
73767: GO 73770
73769: POP
// if i = 1 then
73770: LD_VAR 0 8
73774: PUSH
73775: LD_INT 1
73777: EQUAL
73778: IFFALSE 73889
// begin tmp := [ ] ;
73780: LD_ADDR_VAR 0 19
73784: PUSH
73785: EMPTY
73786: ST_TO_ADDR
// for j in f do
73787: LD_ADDR_VAR 0 9
73791: PUSH
73792: LD_VAR 0 12
73796: PUSH
73797: FOR_IN
73798: IFFALSE 73871
// if GetBType ( j ) = b_bunker then
73800: LD_VAR 0 9
73804: PPUSH
73805: CALL_OW 266
73809: PUSH
73810: LD_INT 32
73812: EQUAL
73813: IFFALSE 73840
// tmp := Insert ( tmp , 1 , j ) else
73815: LD_ADDR_VAR 0 19
73819: PUSH
73820: LD_VAR 0 19
73824: PPUSH
73825: LD_INT 1
73827: PPUSH
73828: LD_VAR 0 9
73832: PPUSH
73833: CALL_OW 2
73837: ST_TO_ADDR
73838: GO 73869
// tmp := Insert ( tmp , tmp + 1 , j ) ;
73840: LD_ADDR_VAR 0 19
73844: PUSH
73845: LD_VAR 0 19
73849: PPUSH
73850: LD_VAR 0 19
73854: PUSH
73855: LD_INT 1
73857: PLUS
73858: PPUSH
73859: LD_VAR 0 9
73863: PPUSH
73864: CALL_OW 2
73868: ST_TO_ADDR
73869: GO 73797
73871: POP
73872: POP
// if tmp then
73873: LD_VAR 0 19
73877: IFFALSE 73889
// f := tmp ;
73879: LD_ADDR_VAR 0 12
73883: PUSH
73884: LD_VAR 0 19
73888: ST_TO_ADDR
// end ; x := personel [ i ] ;
73889: LD_ADDR_VAR 0 13
73893: PUSH
73894: LD_VAR 0 6
73898: PUSH
73899: LD_VAR 0 8
73903: ARRAY
73904: ST_TO_ADDR
// if x = - 1 then
73905: LD_VAR 0 13
73909: PUSH
73910: LD_INT 1
73912: NEG
73913: EQUAL
73914: IFFALSE 74123
// begin for j in f do
73916: LD_ADDR_VAR 0 9
73920: PUSH
73921: LD_VAR 0 12
73925: PUSH
73926: FOR_IN
73927: IFFALSE 74119
// repeat InitHc ;
73929: CALL_OW 19
// if GetBType ( j ) = b_barracks then
73933: LD_VAR 0 9
73937: PPUSH
73938: CALL_OW 266
73942: PUSH
73943: LD_INT 5
73945: EQUAL
73946: IFFALSE 74016
// begin if UnitsInside ( j ) < 3 then
73948: LD_VAR 0 9
73952: PPUSH
73953: CALL_OW 313
73957: PUSH
73958: LD_INT 3
73960: LESS
73961: IFFALSE 73997
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73963: LD_INT 0
73965: PPUSH
73966: LD_INT 5
73968: PUSH
73969: LD_INT 8
73971: PUSH
73972: LD_INT 9
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: LIST
73979: PUSH
73980: LD_VAR 0 17
73984: ARRAY
73985: PPUSH
73986: LD_VAR 0 4
73990: PPUSH
73991: CALL_OW 380
73995: GO 74014
// PrepareHuman ( false , i , skill ) ;
73997: LD_INT 0
73999: PPUSH
74000: LD_VAR 0 8
74004: PPUSH
74005: LD_VAR 0 4
74009: PPUSH
74010: CALL_OW 380
// end else
74014: GO 74033
// PrepareHuman ( false , i , skill ) ;
74016: LD_INT 0
74018: PPUSH
74019: LD_VAR 0 8
74023: PPUSH
74024: LD_VAR 0 4
74028: PPUSH
74029: CALL_OW 380
// un := CreateHuman ;
74033: LD_ADDR_VAR 0 14
74037: PUSH
74038: CALL_OW 44
74042: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74043: LD_ADDR_VAR 0 7
74047: PUSH
74048: LD_VAR 0 7
74052: PPUSH
74053: LD_INT 1
74055: PPUSH
74056: LD_VAR 0 14
74060: PPUSH
74061: CALL_OW 2
74065: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74066: LD_VAR 0 14
74070: PPUSH
74071: LD_VAR 0 9
74075: PPUSH
74076: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74080: LD_VAR 0 9
74084: PPUSH
74085: CALL_OW 313
74089: PUSH
74090: LD_INT 6
74092: EQUAL
74093: PUSH
74094: LD_VAR 0 9
74098: PPUSH
74099: CALL_OW 266
74103: PUSH
74104: LD_INT 32
74106: PUSH
74107: LD_INT 31
74109: PUSH
74110: EMPTY
74111: LIST
74112: LIST
74113: IN
74114: OR
74115: IFFALSE 73929
74117: GO 73926
74119: POP
74120: POP
// end else
74121: GO 74503
// for j = 1 to x do
74123: LD_ADDR_VAR 0 9
74127: PUSH
74128: DOUBLE
74129: LD_INT 1
74131: DEC
74132: ST_TO_ADDR
74133: LD_VAR 0 13
74137: PUSH
74138: FOR_TO
74139: IFFALSE 74501
// begin InitHc ;
74141: CALL_OW 19
// if not f then
74145: LD_VAR 0 12
74149: NOT
74150: IFFALSE 74239
// begin PrepareHuman ( false , i , skill ) ;
74152: LD_INT 0
74154: PPUSH
74155: LD_VAR 0 8
74159: PPUSH
74160: LD_VAR 0 4
74164: PPUSH
74165: CALL_OW 380
// un := CreateHuman ;
74169: LD_ADDR_VAR 0 14
74173: PUSH
74174: CALL_OW 44
74178: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74179: LD_ADDR_VAR 0 7
74183: PUSH
74184: LD_VAR 0 7
74188: PPUSH
74189: LD_INT 1
74191: PPUSH
74192: LD_VAR 0 14
74196: PPUSH
74197: CALL_OW 2
74201: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74202: LD_VAR 0 14
74206: PPUSH
74207: LD_VAR 0 1
74211: PPUSH
74212: CALL_OW 250
74216: PPUSH
74217: LD_VAR 0 1
74221: PPUSH
74222: CALL_OW 251
74226: PPUSH
74227: LD_INT 10
74229: PPUSH
74230: LD_INT 0
74232: PPUSH
74233: CALL_OW 50
// continue ;
74237: GO 74138
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74239: LD_VAR 0 12
74243: PUSH
74244: LD_INT 1
74246: ARRAY
74247: PPUSH
74248: CALL_OW 313
74252: PUSH
74253: LD_VAR 0 12
74257: PUSH
74258: LD_INT 1
74260: ARRAY
74261: PPUSH
74262: CALL_OW 266
74266: PUSH
74267: LD_INT 32
74269: PUSH
74270: LD_INT 31
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: IN
74277: AND
74278: PUSH
74279: LD_VAR 0 12
74283: PUSH
74284: LD_INT 1
74286: ARRAY
74287: PPUSH
74288: CALL_OW 313
74292: PUSH
74293: LD_INT 6
74295: EQUAL
74296: OR
74297: IFFALSE 74317
// f := Delete ( f , 1 ) ;
74299: LD_ADDR_VAR 0 12
74303: PUSH
74304: LD_VAR 0 12
74308: PPUSH
74309: LD_INT 1
74311: PPUSH
74312: CALL_OW 3
74316: ST_TO_ADDR
// if not f then
74317: LD_VAR 0 12
74321: NOT
74322: IFFALSE 74340
// begin x := x + 2 ;
74324: LD_ADDR_VAR 0 13
74328: PUSH
74329: LD_VAR 0 13
74333: PUSH
74334: LD_INT 2
74336: PLUS
74337: ST_TO_ADDR
// continue ;
74338: GO 74138
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74340: LD_VAR 0 12
74344: PUSH
74345: LD_INT 1
74347: ARRAY
74348: PPUSH
74349: CALL_OW 266
74353: PUSH
74354: LD_INT 5
74356: EQUAL
74357: IFFALSE 74431
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74359: LD_VAR 0 12
74363: PUSH
74364: LD_INT 1
74366: ARRAY
74367: PPUSH
74368: CALL_OW 313
74372: PUSH
74373: LD_INT 3
74375: LESS
74376: IFFALSE 74412
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74378: LD_INT 0
74380: PPUSH
74381: LD_INT 5
74383: PUSH
74384: LD_INT 8
74386: PUSH
74387: LD_INT 9
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: LIST
74394: PUSH
74395: LD_VAR 0 17
74399: ARRAY
74400: PPUSH
74401: LD_VAR 0 4
74405: PPUSH
74406: CALL_OW 380
74410: GO 74429
// PrepareHuman ( false , i , skill ) ;
74412: LD_INT 0
74414: PPUSH
74415: LD_VAR 0 8
74419: PPUSH
74420: LD_VAR 0 4
74424: PPUSH
74425: CALL_OW 380
// end else
74429: GO 74448
// PrepareHuman ( false , i , skill ) ;
74431: LD_INT 0
74433: PPUSH
74434: LD_VAR 0 8
74438: PPUSH
74439: LD_VAR 0 4
74443: PPUSH
74444: CALL_OW 380
// un := CreateHuman ;
74448: LD_ADDR_VAR 0 14
74452: PUSH
74453: CALL_OW 44
74457: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74458: LD_ADDR_VAR 0 7
74462: PUSH
74463: LD_VAR 0 7
74467: PPUSH
74468: LD_INT 1
74470: PPUSH
74471: LD_VAR 0 14
74475: PPUSH
74476: CALL_OW 2
74480: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74481: LD_VAR 0 14
74485: PPUSH
74486: LD_VAR 0 12
74490: PUSH
74491: LD_INT 1
74493: ARRAY
74494: PPUSH
74495: CALL_OW 52
// end ;
74499: GO 74138
74501: POP
74502: POP
// end ;
74503: GO 73440
74505: POP
74506: POP
// result := result ^ buildings ;
74507: LD_ADDR_VAR 0 7
74511: PUSH
74512: LD_VAR 0 7
74516: PUSH
74517: LD_VAR 0 18
74521: ADD
74522: ST_TO_ADDR
// end else
74523: GO 74666
// begin for i = 1 to personel do
74525: LD_ADDR_VAR 0 8
74529: PUSH
74530: DOUBLE
74531: LD_INT 1
74533: DEC
74534: ST_TO_ADDR
74535: LD_VAR 0 6
74539: PUSH
74540: FOR_TO
74541: IFFALSE 74664
// begin if i > 4 then
74543: LD_VAR 0 8
74547: PUSH
74548: LD_INT 4
74550: GREATER
74551: IFFALSE 74555
// break ;
74553: GO 74664
// x := personel [ i ] ;
74555: LD_ADDR_VAR 0 13
74559: PUSH
74560: LD_VAR 0 6
74564: PUSH
74565: LD_VAR 0 8
74569: ARRAY
74570: ST_TO_ADDR
// if x = - 1 then
74571: LD_VAR 0 13
74575: PUSH
74576: LD_INT 1
74578: NEG
74579: EQUAL
74580: IFFALSE 74584
// continue ;
74582: GO 74540
// PrepareHuman ( false , i , skill ) ;
74584: LD_INT 0
74586: PPUSH
74587: LD_VAR 0 8
74591: PPUSH
74592: LD_VAR 0 4
74596: PPUSH
74597: CALL_OW 380
// un := CreateHuman ;
74601: LD_ADDR_VAR 0 14
74605: PUSH
74606: CALL_OW 44
74610: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74611: LD_VAR 0 14
74615: PPUSH
74616: LD_VAR 0 1
74620: PPUSH
74621: CALL_OW 250
74625: PPUSH
74626: LD_VAR 0 1
74630: PPUSH
74631: CALL_OW 251
74635: PPUSH
74636: LD_INT 10
74638: PPUSH
74639: LD_INT 0
74641: PPUSH
74642: CALL_OW 50
// result := result ^ un ;
74646: LD_ADDR_VAR 0 7
74650: PUSH
74651: LD_VAR 0 7
74655: PUSH
74656: LD_VAR 0 14
74660: ADD
74661: ST_TO_ADDR
// end ;
74662: GO 74540
74664: POP
74665: POP
// end ; end ;
74666: LD_VAR 0 7
74670: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74671: LD_INT 0
74673: PPUSH
74674: PPUSH
74675: PPUSH
74676: PPUSH
74677: PPUSH
74678: PPUSH
74679: PPUSH
74680: PPUSH
74681: PPUSH
74682: PPUSH
74683: PPUSH
74684: PPUSH
74685: PPUSH
74686: PPUSH
74687: PPUSH
74688: PPUSH
// result := false ;
74689: LD_ADDR_VAR 0 3
74693: PUSH
74694: LD_INT 0
74696: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
74697: LD_VAR 0 1
74701: NOT
74702: PUSH
74703: LD_VAR 0 1
74707: PPUSH
74708: CALL_OW 266
74712: PUSH
74713: LD_INT 32
74715: PUSH
74716: LD_INT 33
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: IN
74723: NOT
74724: OR
74725: IFFALSE 74729
// exit ;
74727: GO 75865
// nat := GetNation ( tower ) ;
74729: LD_ADDR_VAR 0 12
74733: PUSH
74734: LD_VAR 0 1
74738: PPUSH
74739: CALL_OW 248
74743: ST_TO_ADDR
// side := GetSide ( tower ) ;
74744: LD_ADDR_VAR 0 16
74748: PUSH
74749: LD_VAR 0 1
74753: PPUSH
74754: CALL_OW 255
74758: ST_TO_ADDR
// x := GetX ( tower ) ;
74759: LD_ADDR_VAR 0 10
74763: PUSH
74764: LD_VAR 0 1
74768: PPUSH
74769: CALL_OW 250
74773: ST_TO_ADDR
// y := GetY ( tower ) ;
74774: LD_ADDR_VAR 0 11
74778: PUSH
74779: LD_VAR 0 1
74783: PPUSH
74784: CALL_OW 251
74788: ST_TO_ADDR
// if not x or not y then
74789: LD_VAR 0 10
74793: NOT
74794: PUSH
74795: LD_VAR 0 11
74799: NOT
74800: OR
74801: IFFALSE 74805
// exit ;
74803: GO 75865
// weapon := 0 ;
74805: LD_ADDR_VAR 0 18
74809: PUSH
74810: LD_INT 0
74812: ST_TO_ADDR
// fac_list := [ ] ;
74813: LD_ADDR_VAR 0 17
74817: PUSH
74818: EMPTY
74819: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
74820: LD_ADDR_VAR 0 6
74824: PUSH
74825: LD_VAR 0 1
74829: PPUSH
74830: CALL_OW 274
74834: PPUSH
74835: LD_VAR 0 2
74839: PPUSH
74840: CALL 72443 0 2
74844: PPUSH
74845: LD_INT 30
74847: PUSH
74848: LD_INT 3
74850: PUSH
74851: EMPTY
74852: LIST
74853: LIST
74854: PPUSH
74855: CALL_OW 72
74859: ST_TO_ADDR
// if not factories then
74860: LD_VAR 0 6
74864: NOT
74865: IFFALSE 74869
// exit ;
74867: GO 75865
// for i in factories do
74869: LD_ADDR_VAR 0 8
74873: PUSH
74874: LD_VAR 0 6
74878: PUSH
74879: FOR_IN
74880: IFFALSE 74905
// fac_list := fac_list union AvailableWeaponList ( i ) ;
74882: LD_ADDR_VAR 0 17
74886: PUSH
74887: LD_VAR 0 17
74891: PUSH
74892: LD_VAR 0 8
74896: PPUSH
74897: CALL_OW 478
74901: UNION
74902: ST_TO_ADDR
74903: GO 74879
74905: POP
74906: POP
// if not fac_list then
74907: LD_VAR 0 17
74911: NOT
74912: IFFALSE 74916
// exit ;
74914: GO 75865
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
74916: LD_ADDR_VAR 0 5
74920: PUSH
74921: LD_INT 4
74923: PUSH
74924: LD_INT 5
74926: PUSH
74927: LD_INT 9
74929: PUSH
74930: LD_INT 10
74932: PUSH
74933: LD_INT 6
74935: PUSH
74936: LD_INT 7
74938: PUSH
74939: LD_INT 11
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: LIST
74950: PUSH
74951: LD_INT 27
74953: PUSH
74954: LD_INT 28
74956: PUSH
74957: LD_INT 26
74959: PUSH
74960: LD_INT 30
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: PUSH
74969: LD_INT 43
74971: PUSH
74972: LD_INT 44
74974: PUSH
74975: LD_INT 46
74977: PUSH
74978: LD_INT 45
74980: PUSH
74981: LD_INT 47
74983: PUSH
74984: LD_INT 49
74986: PUSH
74987: EMPTY
74988: LIST
74989: LIST
74990: LIST
74991: LIST
74992: LIST
74993: LIST
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: LIST
74999: PUSH
75000: LD_VAR 0 12
75004: ARRAY
75005: ST_TO_ADDR
// for i in list do
75006: LD_ADDR_VAR 0 8
75010: PUSH
75011: LD_VAR 0 5
75015: PUSH
75016: FOR_IN
75017: IFFALSE 75050
// if not i in fac_list then
75019: LD_VAR 0 8
75023: PUSH
75024: LD_VAR 0 17
75028: IN
75029: NOT
75030: IFFALSE 75048
// list := list diff i ;
75032: LD_ADDR_VAR 0 5
75036: PUSH
75037: LD_VAR 0 5
75041: PUSH
75042: LD_VAR 0 8
75046: DIFF
75047: ST_TO_ADDR
75048: GO 75016
75050: POP
75051: POP
// if not list then
75052: LD_VAR 0 5
75056: NOT
75057: IFFALSE 75061
// exit ;
75059: GO 75865
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75061: LD_VAR 0 12
75065: PUSH
75066: LD_INT 3
75068: EQUAL
75069: PUSH
75070: LD_INT 49
75072: PUSH
75073: LD_VAR 0 5
75077: IN
75078: AND
75079: PUSH
75080: LD_INT 31
75082: PPUSH
75083: LD_VAR 0 16
75087: PPUSH
75088: CALL_OW 321
75092: PUSH
75093: LD_INT 2
75095: EQUAL
75096: AND
75097: IFFALSE 75157
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75099: LD_INT 22
75101: PUSH
75102: LD_VAR 0 16
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: LD_INT 35
75113: PUSH
75114: LD_INT 49
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: LD_INT 91
75123: PUSH
75124: LD_VAR 0 1
75128: PUSH
75129: LD_INT 10
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: LIST
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: LIST
75141: PPUSH
75142: CALL_OW 69
75146: NOT
75147: IFFALSE 75157
// weapon := ru_time_lapser ;
75149: LD_ADDR_VAR 0 18
75153: PUSH
75154: LD_INT 49
75156: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75157: LD_VAR 0 12
75161: PUSH
75162: LD_INT 1
75164: PUSH
75165: LD_INT 2
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: IN
75172: PUSH
75173: LD_INT 11
75175: PUSH
75176: LD_VAR 0 5
75180: IN
75181: PUSH
75182: LD_INT 30
75184: PUSH
75185: LD_VAR 0 5
75189: IN
75190: OR
75191: AND
75192: PUSH
75193: LD_INT 6
75195: PPUSH
75196: LD_VAR 0 16
75200: PPUSH
75201: CALL_OW 321
75205: PUSH
75206: LD_INT 2
75208: EQUAL
75209: AND
75210: IFFALSE 75375
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75212: LD_INT 22
75214: PUSH
75215: LD_VAR 0 16
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: PUSH
75224: LD_INT 2
75226: PUSH
75227: LD_INT 35
75229: PUSH
75230: LD_INT 11
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 35
75239: PUSH
75240: LD_INT 30
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 91
75254: PUSH
75255: LD_VAR 0 1
75259: PUSH
75260: LD_INT 18
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: LIST
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: LIST
75272: PPUSH
75273: CALL_OW 69
75277: NOT
75278: PUSH
75279: LD_INT 22
75281: PUSH
75282: LD_VAR 0 16
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 2
75293: PUSH
75294: LD_INT 30
75296: PUSH
75297: LD_INT 32
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PUSH
75304: LD_INT 30
75306: PUSH
75307: LD_INT 33
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: LIST
75318: PUSH
75319: LD_INT 91
75321: PUSH
75322: LD_VAR 0 1
75326: PUSH
75327: LD_INT 12
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: LIST
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: LIST
75339: PUSH
75340: EMPTY
75341: LIST
75342: PPUSH
75343: CALL_OW 69
75347: PUSH
75348: LD_INT 2
75350: GREATER
75351: AND
75352: IFFALSE 75375
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75354: LD_ADDR_VAR 0 18
75358: PUSH
75359: LD_INT 11
75361: PUSH
75362: LD_INT 30
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: PUSH
75369: LD_VAR 0 12
75373: ARRAY
75374: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75375: LD_VAR 0 18
75379: NOT
75380: PUSH
75381: LD_INT 40
75383: PPUSH
75384: LD_VAR 0 16
75388: PPUSH
75389: CALL_OW 321
75393: PUSH
75394: LD_INT 2
75396: EQUAL
75397: AND
75398: PUSH
75399: LD_INT 7
75401: PUSH
75402: LD_VAR 0 5
75406: IN
75407: PUSH
75408: LD_INT 28
75410: PUSH
75411: LD_VAR 0 5
75415: IN
75416: OR
75417: PUSH
75418: LD_INT 45
75420: PUSH
75421: LD_VAR 0 5
75425: IN
75426: OR
75427: AND
75428: IFFALSE 75682
// begin hex := GetHexInfo ( x , y ) ;
75430: LD_ADDR_VAR 0 4
75434: PUSH
75435: LD_VAR 0 10
75439: PPUSH
75440: LD_VAR 0 11
75444: PPUSH
75445: CALL_OW 546
75449: ST_TO_ADDR
// if hex [ 1 ] then
75450: LD_VAR 0 4
75454: PUSH
75455: LD_INT 1
75457: ARRAY
75458: IFFALSE 75462
// exit ;
75460: GO 75865
// height := hex [ 2 ] ;
75462: LD_ADDR_VAR 0 15
75466: PUSH
75467: LD_VAR 0 4
75471: PUSH
75472: LD_INT 2
75474: ARRAY
75475: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75476: LD_ADDR_VAR 0 14
75480: PUSH
75481: LD_INT 0
75483: PUSH
75484: LD_INT 2
75486: PUSH
75487: LD_INT 3
75489: PUSH
75490: LD_INT 5
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: ST_TO_ADDR
// for i in tmp do
75499: LD_ADDR_VAR 0 8
75503: PUSH
75504: LD_VAR 0 14
75508: PUSH
75509: FOR_IN
75510: IFFALSE 75680
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75512: LD_ADDR_VAR 0 9
75516: PUSH
75517: LD_VAR 0 10
75521: PPUSH
75522: LD_VAR 0 8
75526: PPUSH
75527: LD_INT 5
75529: PPUSH
75530: CALL_OW 272
75534: PUSH
75535: LD_VAR 0 11
75539: PPUSH
75540: LD_VAR 0 8
75544: PPUSH
75545: LD_INT 5
75547: PPUSH
75548: CALL_OW 273
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75557: LD_VAR 0 9
75561: PUSH
75562: LD_INT 1
75564: ARRAY
75565: PPUSH
75566: LD_VAR 0 9
75570: PUSH
75571: LD_INT 2
75573: ARRAY
75574: PPUSH
75575: CALL_OW 488
75579: IFFALSE 75678
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75581: LD_ADDR_VAR 0 4
75585: PUSH
75586: LD_VAR 0 9
75590: PUSH
75591: LD_INT 1
75593: ARRAY
75594: PPUSH
75595: LD_VAR 0 9
75599: PUSH
75600: LD_INT 2
75602: ARRAY
75603: PPUSH
75604: CALL_OW 546
75608: ST_TO_ADDR
// if hex [ 1 ] then
75609: LD_VAR 0 4
75613: PUSH
75614: LD_INT 1
75616: ARRAY
75617: IFFALSE 75621
// continue ;
75619: GO 75509
// h := hex [ 2 ] ;
75621: LD_ADDR_VAR 0 13
75625: PUSH
75626: LD_VAR 0 4
75630: PUSH
75631: LD_INT 2
75633: ARRAY
75634: ST_TO_ADDR
// if h + 7 < height then
75635: LD_VAR 0 13
75639: PUSH
75640: LD_INT 7
75642: PLUS
75643: PUSH
75644: LD_VAR 0 15
75648: LESS
75649: IFFALSE 75678
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75651: LD_ADDR_VAR 0 18
75655: PUSH
75656: LD_INT 7
75658: PUSH
75659: LD_INT 28
75661: PUSH
75662: LD_INT 45
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: LIST
75669: PUSH
75670: LD_VAR 0 12
75674: ARRAY
75675: ST_TO_ADDR
// break ;
75676: GO 75680
// end ; end ; end ;
75678: GO 75509
75680: POP
75681: POP
// end ; if not weapon then
75682: LD_VAR 0 18
75686: NOT
75687: IFFALSE 75747
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75689: LD_ADDR_VAR 0 5
75693: PUSH
75694: LD_VAR 0 5
75698: PUSH
75699: LD_INT 11
75701: PUSH
75702: LD_INT 30
75704: PUSH
75705: LD_INT 49
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: LIST
75712: DIFF
75713: ST_TO_ADDR
// if not list then
75714: LD_VAR 0 5
75718: NOT
75719: IFFALSE 75723
// exit ;
75721: GO 75865
// weapon := list [ rand ( 1 , list ) ] ;
75723: LD_ADDR_VAR 0 18
75727: PUSH
75728: LD_VAR 0 5
75732: PUSH
75733: LD_INT 1
75735: PPUSH
75736: LD_VAR 0 5
75740: PPUSH
75741: CALL_OW 12
75745: ARRAY
75746: ST_TO_ADDR
// end ; if weapon then
75747: LD_VAR 0 18
75751: IFFALSE 75865
// begin tmp := CostOfWeapon ( weapon ) ;
75753: LD_ADDR_VAR 0 14
75757: PUSH
75758: LD_VAR 0 18
75762: PPUSH
75763: CALL_OW 451
75767: ST_TO_ADDR
// j := GetBase ( tower ) ;
75768: LD_ADDR_VAR 0 9
75772: PUSH
75773: LD_VAR 0 1
75777: PPUSH
75778: CALL_OW 274
75782: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
75783: LD_VAR 0 9
75787: PPUSH
75788: LD_INT 1
75790: PPUSH
75791: CALL_OW 275
75795: PUSH
75796: LD_VAR 0 14
75800: PUSH
75801: LD_INT 1
75803: ARRAY
75804: GREATEREQUAL
75805: PUSH
75806: LD_VAR 0 9
75810: PPUSH
75811: LD_INT 2
75813: PPUSH
75814: CALL_OW 275
75818: PUSH
75819: LD_VAR 0 14
75823: PUSH
75824: LD_INT 2
75826: ARRAY
75827: GREATEREQUAL
75828: AND
75829: PUSH
75830: LD_VAR 0 9
75834: PPUSH
75835: LD_INT 3
75837: PPUSH
75838: CALL_OW 275
75842: PUSH
75843: LD_VAR 0 14
75847: PUSH
75848: LD_INT 3
75850: ARRAY
75851: GREATEREQUAL
75852: AND
75853: IFFALSE 75865
// result := weapon ;
75855: LD_ADDR_VAR 0 3
75859: PUSH
75860: LD_VAR 0 18
75864: ST_TO_ADDR
// end ; end ;
75865: LD_VAR 0 3
75869: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
75870: LD_INT 0
75872: PPUSH
75873: PPUSH
// result := true ;
75874: LD_ADDR_VAR 0 3
75878: PUSH
75879: LD_INT 1
75881: ST_TO_ADDR
// if array1 = array2 then
75882: LD_VAR 0 1
75886: PUSH
75887: LD_VAR 0 2
75891: EQUAL
75892: IFFALSE 75952
// begin for i = 1 to array1 do
75894: LD_ADDR_VAR 0 4
75898: PUSH
75899: DOUBLE
75900: LD_INT 1
75902: DEC
75903: ST_TO_ADDR
75904: LD_VAR 0 1
75908: PUSH
75909: FOR_TO
75910: IFFALSE 75948
// if array1 [ i ] <> array2 [ i ] then
75912: LD_VAR 0 1
75916: PUSH
75917: LD_VAR 0 4
75921: ARRAY
75922: PUSH
75923: LD_VAR 0 2
75927: PUSH
75928: LD_VAR 0 4
75932: ARRAY
75933: NONEQUAL
75934: IFFALSE 75946
// begin result := false ;
75936: LD_ADDR_VAR 0 3
75940: PUSH
75941: LD_INT 0
75943: ST_TO_ADDR
// break ;
75944: GO 75948
// end ;
75946: GO 75909
75948: POP
75949: POP
// end else
75950: GO 75960
// result := false ;
75952: LD_ADDR_VAR 0 3
75956: PUSH
75957: LD_INT 0
75959: ST_TO_ADDR
// end ;
75960: LD_VAR 0 3
75964: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
75965: LD_INT 0
75967: PPUSH
75968: PPUSH
75969: PPUSH
// pom := GetBase ( fac ) ;
75970: LD_ADDR_VAR 0 5
75974: PUSH
75975: LD_VAR 0 1
75979: PPUSH
75980: CALL_OW 274
75984: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
75985: LD_ADDR_VAR 0 4
75989: PUSH
75990: LD_VAR 0 2
75994: PUSH
75995: LD_INT 1
75997: ARRAY
75998: PPUSH
75999: LD_VAR 0 2
76003: PUSH
76004: LD_INT 2
76006: ARRAY
76007: PPUSH
76008: LD_VAR 0 2
76012: PUSH
76013: LD_INT 3
76015: ARRAY
76016: PPUSH
76017: LD_VAR 0 2
76021: PUSH
76022: LD_INT 4
76024: ARRAY
76025: PPUSH
76026: CALL_OW 449
76030: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76031: LD_ADDR_VAR 0 3
76035: PUSH
76036: LD_VAR 0 5
76040: PPUSH
76041: LD_INT 1
76043: PPUSH
76044: CALL_OW 275
76048: PUSH
76049: LD_VAR 0 4
76053: PUSH
76054: LD_INT 1
76056: ARRAY
76057: GREATEREQUAL
76058: PUSH
76059: LD_VAR 0 5
76063: PPUSH
76064: LD_INT 2
76066: PPUSH
76067: CALL_OW 275
76071: PUSH
76072: LD_VAR 0 4
76076: PUSH
76077: LD_INT 2
76079: ARRAY
76080: GREATEREQUAL
76081: AND
76082: PUSH
76083: LD_VAR 0 5
76087: PPUSH
76088: LD_INT 3
76090: PPUSH
76091: CALL_OW 275
76095: PUSH
76096: LD_VAR 0 4
76100: PUSH
76101: LD_INT 3
76103: ARRAY
76104: GREATEREQUAL
76105: AND
76106: ST_TO_ADDR
// end ;
76107: LD_VAR 0 3
76111: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76112: LD_INT 0
76114: PPUSH
76115: PPUSH
76116: PPUSH
76117: PPUSH
// pom := GetBase ( building ) ;
76118: LD_ADDR_VAR 0 3
76122: PUSH
76123: LD_VAR 0 1
76127: PPUSH
76128: CALL_OW 274
76132: ST_TO_ADDR
// if not pom then
76133: LD_VAR 0 3
76137: NOT
76138: IFFALSE 76142
// exit ;
76140: GO 76312
// btype := GetBType ( building ) ;
76142: LD_ADDR_VAR 0 5
76146: PUSH
76147: LD_VAR 0 1
76151: PPUSH
76152: CALL_OW 266
76156: ST_TO_ADDR
// if btype = b_armoury then
76157: LD_VAR 0 5
76161: PUSH
76162: LD_INT 4
76164: EQUAL
76165: IFFALSE 76175
// btype := b_barracks ;
76167: LD_ADDR_VAR 0 5
76171: PUSH
76172: LD_INT 5
76174: ST_TO_ADDR
// if btype = b_depot then
76175: LD_VAR 0 5
76179: PUSH
76180: LD_INT 0
76182: EQUAL
76183: IFFALSE 76193
// btype := b_warehouse ;
76185: LD_ADDR_VAR 0 5
76189: PUSH
76190: LD_INT 1
76192: ST_TO_ADDR
// if btype = b_workshop then
76193: LD_VAR 0 5
76197: PUSH
76198: LD_INT 2
76200: EQUAL
76201: IFFALSE 76211
// btype := b_factory ;
76203: LD_ADDR_VAR 0 5
76207: PUSH
76208: LD_INT 3
76210: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76211: LD_ADDR_VAR 0 4
76215: PUSH
76216: LD_VAR 0 5
76220: PPUSH
76221: LD_VAR 0 1
76225: PPUSH
76226: CALL_OW 248
76230: PPUSH
76231: CALL_OW 450
76235: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76236: LD_ADDR_VAR 0 2
76240: PUSH
76241: LD_VAR 0 3
76245: PPUSH
76246: LD_INT 1
76248: PPUSH
76249: CALL_OW 275
76253: PUSH
76254: LD_VAR 0 4
76258: PUSH
76259: LD_INT 1
76261: ARRAY
76262: GREATEREQUAL
76263: PUSH
76264: LD_VAR 0 3
76268: PPUSH
76269: LD_INT 2
76271: PPUSH
76272: CALL_OW 275
76276: PUSH
76277: LD_VAR 0 4
76281: PUSH
76282: LD_INT 2
76284: ARRAY
76285: GREATEREQUAL
76286: AND
76287: PUSH
76288: LD_VAR 0 3
76292: PPUSH
76293: LD_INT 3
76295: PPUSH
76296: CALL_OW 275
76300: PUSH
76301: LD_VAR 0 4
76305: PUSH
76306: LD_INT 3
76308: ARRAY
76309: GREATEREQUAL
76310: AND
76311: ST_TO_ADDR
// end ;
76312: LD_VAR 0 2
76316: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76317: LD_INT 0
76319: PPUSH
76320: PPUSH
76321: PPUSH
// pom := GetBase ( building ) ;
76322: LD_ADDR_VAR 0 4
76326: PUSH
76327: LD_VAR 0 1
76331: PPUSH
76332: CALL_OW 274
76336: ST_TO_ADDR
// if not pom then
76337: LD_VAR 0 4
76341: NOT
76342: IFFALSE 76346
// exit ;
76344: GO 76447
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76346: LD_ADDR_VAR 0 5
76350: PUSH
76351: LD_VAR 0 2
76355: PPUSH
76356: LD_VAR 0 1
76360: PPUSH
76361: CALL_OW 248
76365: PPUSH
76366: CALL_OW 450
76370: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76371: LD_ADDR_VAR 0 3
76375: PUSH
76376: LD_VAR 0 4
76380: PPUSH
76381: LD_INT 1
76383: PPUSH
76384: CALL_OW 275
76388: PUSH
76389: LD_VAR 0 5
76393: PUSH
76394: LD_INT 1
76396: ARRAY
76397: GREATEREQUAL
76398: PUSH
76399: LD_VAR 0 4
76403: PPUSH
76404: LD_INT 2
76406: PPUSH
76407: CALL_OW 275
76411: PUSH
76412: LD_VAR 0 5
76416: PUSH
76417: LD_INT 2
76419: ARRAY
76420: GREATEREQUAL
76421: AND
76422: PUSH
76423: LD_VAR 0 4
76427: PPUSH
76428: LD_INT 3
76430: PPUSH
76431: CALL_OW 275
76435: PUSH
76436: LD_VAR 0 5
76440: PUSH
76441: LD_INT 3
76443: ARRAY
76444: GREATEREQUAL
76445: AND
76446: ST_TO_ADDR
// end ;
76447: LD_VAR 0 3
76451: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76452: LD_INT 0
76454: PPUSH
76455: PPUSH
76456: PPUSH
76457: PPUSH
76458: PPUSH
76459: PPUSH
76460: PPUSH
76461: PPUSH
76462: PPUSH
76463: PPUSH
// result := false ;
76464: LD_ADDR_VAR 0 6
76468: PUSH
76469: LD_INT 0
76471: ST_TO_ADDR
// if not base or not btype or not x or not y then
76472: LD_VAR 0 1
76476: NOT
76477: PUSH
76478: LD_VAR 0 2
76482: NOT
76483: OR
76484: PUSH
76485: LD_VAR 0 3
76489: NOT
76490: OR
76491: PUSH
76492: LD_VAR 0 4
76496: NOT
76497: OR
76498: IFFALSE 76502
// exit ;
76500: GO 77111
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76502: LD_ADDR_VAR 0 12
76506: PUSH
76507: LD_VAR 0 2
76511: PPUSH
76512: LD_VAR 0 3
76516: PPUSH
76517: LD_VAR 0 4
76521: PPUSH
76522: LD_VAR 0 5
76526: PPUSH
76527: LD_VAR 0 1
76531: PUSH
76532: LD_INT 1
76534: ARRAY
76535: PPUSH
76536: CALL_OW 248
76540: PPUSH
76541: LD_INT 0
76543: PPUSH
76544: CALL 77948 0 6
76548: ST_TO_ADDR
// if not hexes then
76549: LD_VAR 0 12
76553: NOT
76554: IFFALSE 76558
// exit ;
76556: GO 77111
// for i = 1 to hexes do
76558: LD_ADDR_VAR 0 7
76562: PUSH
76563: DOUBLE
76564: LD_INT 1
76566: DEC
76567: ST_TO_ADDR
76568: LD_VAR 0 12
76572: PUSH
76573: FOR_TO
76574: IFFALSE 77109
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76576: LD_ADDR_VAR 0 11
76580: PUSH
76581: LD_VAR 0 12
76585: PUSH
76586: LD_VAR 0 7
76590: ARRAY
76591: PUSH
76592: LD_INT 1
76594: ARRAY
76595: PPUSH
76596: LD_VAR 0 12
76600: PUSH
76601: LD_VAR 0 7
76605: ARRAY
76606: PUSH
76607: LD_INT 2
76609: ARRAY
76610: PPUSH
76611: CALL_OW 428
76615: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76616: LD_VAR 0 12
76620: PUSH
76621: LD_VAR 0 7
76625: ARRAY
76626: PUSH
76627: LD_INT 1
76629: ARRAY
76630: PPUSH
76631: LD_VAR 0 12
76635: PUSH
76636: LD_VAR 0 7
76640: ARRAY
76641: PUSH
76642: LD_INT 2
76644: ARRAY
76645: PPUSH
76646: CALL_OW 351
76650: PUSH
76651: LD_VAR 0 12
76655: PUSH
76656: LD_VAR 0 7
76660: ARRAY
76661: PUSH
76662: LD_INT 1
76664: ARRAY
76665: PPUSH
76666: LD_VAR 0 12
76670: PUSH
76671: LD_VAR 0 7
76675: ARRAY
76676: PUSH
76677: LD_INT 2
76679: ARRAY
76680: PPUSH
76681: CALL_OW 488
76685: NOT
76686: OR
76687: PUSH
76688: LD_VAR 0 11
76692: PPUSH
76693: CALL_OW 247
76697: PUSH
76698: LD_INT 3
76700: EQUAL
76701: OR
76702: IFFALSE 76708
// exit ;
76704: POP
76705: POP
76706: GO 77111
// if not tmp or not tmp in base then
76708: LD_VAR 0 11
76712: NOT
76713: PUSH
76714: LD_VAR 0 11
76718: PUSH
76719: LD_VAR 0 1
76723: IN
76724: NOT
76725: OR
76726: IFFALSE 76730
// continue ;
76728: GO 76573
// result := true ;
76730: LD_ADDR_VAR 0 6
76734: PUSH
76735: LD_INT 1
76737: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76738: LD_ADDR_VAR 0 15
76742: PUSH
76743: LD_VAR 0 1
76747: PPUSH
76748: LD_INT 22
76750: PUSH
76751: LD_VAR 0 11
76755: PPUSH
76756: CALL_OW 255
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: LD_INT 2
76767: PUSH
76768: LD_INT 30
76770: PUSH
76771: LD_INT 0
76773: PUSH
76774: EMPTY
76775: LIST
76776: LIST
76777: PUSH
76778: LD_INT 30
76780: PUSH
76781: LD_INT 1
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: LIST
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PPUSH
76797: CALL_OW 72
76801: ST_TO_ADDR
// if dep then
76802: LD_VAR 0 15
76806: IFFALSE 76942
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
76808: LD_ADDR_VAR 0 14
76812: PUSH
76813: LD_VAR 0 15
76817: PUSH
76818: LD_INT 1
76820: ARRAY
76821: PPUSH
76822: CALL_OW 250
76826: PPUSH
76827: LD_VAR 0 15
76831: PUSH
76832: LD_INT 1
76834: ARRAY
76835: PPUSH
76836: CALL_OW 254
76840: PPUSH
76841: LD_INT 5
76843: PPUSH
76844: CALL_OW 272
76848: PUSH
76849: LD_VAR 0 15
76853: PUSH
76854: LD_INT 1
76856: ARRAY
76857: PPUSH
76858: CALL_OW 251
76862: PPUSH
76863: LD_VAR 0 15
76867: PUSH
76868: LD_INT 1
76870: ARRAY
76871: PPUSH
76872: CALL_OW 254
76876: PPUSH
76877: LD_INT 5
76879: PPUSH
76880: CALL_OW 273
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
76889: LD_VAR 0 14
76893: PUSH
76894: LD_INT 1
76896: ARRAY
76897: PPUSH
76898: LD_VAR 0 14
76902: PUSH
76903: LD_INT 2
76905: ARRAY
76906: PPUSH
76907: CALL_OW 488
76911: IFFALSE 76942
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76913: LD_VAR 0 11
76917: PPUSH
76918: LD_VAR 0 14
76922: PUSH
76923: LD_INT 1
76925: ARRAY
76926: PPUSH
76927: LD_VAR 0 14
76931: PUSH
76932: LD_INT 2
76934: ARRAY
76935: PPUSH
76936: CALL_OW 111
// continue ;
76940: GO 76573
// end ; end ; r := GetDir ( tmp ) ;
76942: LD_ADDR_VAR 0 13
76946: PUSH
76947: LD_VAR 0 11
76951: PPUSH
76952: CALL_OW 254
76956: ST_TO_ADDR
// if r = 5 then
76957: LD_VAR 0 13
76961: PUSH
76962: LD_INT 5
76964: EQUAL
76965: IFFALSE 76975
// r := 0 ;
76967: LD_ADDR_VAR 0 13
76971: PUSH
76972: LD_INT 0
76974: ST_TO_ADDR
// for j = r to 5 do
76975: LD_ADDR_VAR 0 8
76979: PUSH
76980: DOUBLE
76981: LD_VAR 0 13
76985: DEC
76986: ST_TO_ADDR
76987: LD_INT 5
76989: PUSH
76990: FOR_TO
76991: IFFALSE 77105
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76993: LD_ADDR_VAR 0 9
76997: PUSH
76998: LD_VAR 0 11
77002: PPUSH
77003: CALL_OW 250
77007: PPUSH
77008: LD_VAR 0 8
77012: PPUSH
77013: LD_INT 2
77015: PPUSH
77016: CALL_OW 272
77020: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77021: LD_ADDR_VAR 0 10
77025: PUSH
77026: LD_VAR 0 11
77030: PPUSH
77031: CALL_OW 251
77035: PPUSH
77036: LD_VAR 0 8
77040: PPUSH
77041: LD_INT 2
77043: PPUSH
77044: CALL_OW 273
77048: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77049: LD_VAR 0 9
77053: PPUSH
77054: LD_VAR 0 10
77058: PPUSH
77059: CALL_OW 488
77063: PUSH
77064: LD_VAR 0 9
77068: PPUSH
77069: LD_VAR 0 10
77073: PPUSH
77074: CALL_OW 428
77078: NOT
77079: AND
77080: IFFALSE 77103
// begin ComMoveXY ( tmp , _x , _y ) ;
77082: LD_VAR 0 11
77086: PPUSH
77087: LD_VAR 0 9
77091: PPUSH
77092: LD_VAR 0 10
77096: PPUSH
77097: CALL_OW 111
// break ;
77101: GO 77105
// end ; end ;
77103: GO 76990
77105: POP
77106: POP
// end ;
77107: GO 76573
77109: POP
77110: POP
// end ;
77111: LD_VAR 0 6
77115: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77116: LD_INT 0
77118: PPUSH
77119: PPUSH
77120: PPUSH
77121: PPUSH
77122: PPUSH
77123: PPUSH
77124: PPUSH
77125: PPUSH
77126: PPUSH
77127: PPUSH
// result := false ;
77128: LD_ADDR_VAR 0 6
77132: PUSH
77133: LD_INT 0
77135: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77136: LD_VAR 0 1
77140: NOT
77141: PUSH
77142: LD_VAR 0 1
77146: PPUSH
77147: CALL_OW 266
77151: PUSH
77152: LD_INT 0
77154: PUSH
77155: LD_INT 1
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: IN
77162: NOT
77163: OR
77164: PUSH
77165: LD_VAR 0 2
77169: NOT
77170: OR
77171: PUSH
77172: LD_VAR 0 5
77176: PUSH
77177: LD_INT 0
77179: PUSH
77180: LD_INT 1
77182: PUSH
77183: LD_INT 2
77185: PUSH
77186: LD_INT 3
77188: PUSH
77189: LD_INT 4
77191: PUSH
77192: LD_INT 5
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: LIST
77199: LIST
77200: LIST
77201: LIST
77202: IN
77203: NOT
77204: OR
77205: PUSH
77206: LD_VAR 0 3
77210: PPUSH
77211: LD_VAR 0 4
77215: PPUSH
77216: CALL_OW 488
77220: NOT
77221: OR
77222: IFFALSE 77226
// exit ;
77224: GO 77943
// pom := GetBase ( depot ) ;
77226: LD_ADDR_VAR 0 10
77230: PUSH
77231: LD_VAR 0 1
77235: PPUSH
77236: CALL_OW 274
77240: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77241: LD_ADDR_VAR 0 11
77245: PUSH
77246: LD_VAR 0 2
77250: PPUSH
77251: LD_VAR 0 1
77255: PPUSH
77256: CALL_OW 248
77260: PPUSH
77261: CALL_OW 450
77265: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77266: LD_VAR 0 10
77270: PPUSH
77271: LD_INT 1
77273: PPUSH
77274: CALL_OW 275
77278: PUSH
77279: LD_VAR 0 11
77283: PUSH
77284: LD_INT 1
77286: ARRAY
77287: GREATEREQUAL
77288: PUSH
77289: LD_VAR 0 10
77293: PPUSH
77294: LD_INT 2
77296: PPUSH
77297: CALL_OW 275
77301: PUSH
77302: LD_VAR 0 11
77306: PUSH
77307: LD_INT 2
77309: ARRAY
77310: GREATEREQUAL
77311: AND
77312: PUSH
77313: LD_VAR 0 10
77317: PPUSH
77318: LD_INT 3
77320: PPUSH
77321: CALL_OW 275
77325: PUSH
77326: LD_VAR 0 11
77330: PUSH
77331: LD_INT 3
77333: ARRAY
77334: GREATEREQUAL
77335: AND
77336: NOT
77337: IFFALSE 77341
// exit ;
77339: GO 77943
// if GetBType ( depot ) = b_depot then
77341: LD_VAR 0 1
77345: PPUSH
77346: CALL_OW 266
77350: PUSH
77351: LD_INT 0
77353: EQUAL
77354: IFFALSE 77366
// dist := 28 else
77356: LD_ADDR_VAR 0 14
77360: PUSH
77361: LD_INT 28
77363: ST_TO_ADDR
77364: GO 77374
// dist := 36 ;
77366: LD_ADDR_VAR 0 14
77370: PUSH
77371: LD_INT 36
77373: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77374: LD_VAR 0 1
77378: PPUSH
77379: LD_VAR 0 3
77383: PPUSH
77384: LD_VAR 0 4
77388: PPUSH
77389: CALL_OW 297
77393: PUSH
77394: LD_VAR 0 14
77398: GREATER
77399: IFFALSE 77403
// exit ;
77401: GO 77943
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77403: LD_ADDR_VAR 0 12
77407: PUSH
77408: LD_VAR 0 2
77412: PPUSH
77413: LD_VAR 0 3
77417: PPUSH
77418: LD_VAR 0 4
77422: PPUSH
77423: LD_VAR 0 5
77427: PPUSH
77428: LD_VAR 0 1
77432: PPUSH
77433: CALL_OW 248
77437: PPUSH
77438: LD_INT 0
77440: PPUSH
77441: CALL 77948 0 6
77445: ST_TO_ADDR
// if not hexes then
77446: LD_VAR 0 12
77450: NOT
77451: IFFALSE 77455
// exit ;
77453: GO 77943
// hex := GetHexInfo ( x , y ) ;
77455: LD_ADDR_VAR 0 15
77459: PUSH
77460: LD_VAR 0 3
77464: PPUSH
77465: LD_VAR 0 4
77469: PPUSH
77470: CALL_OW 546
77474: ST_TO_ADDR
// if hex [ 1 ] then
77475: LD_VAR 0 15
77479: PUSH
77480: LD_INT 1
77482: ARRAY
77483: IFFALSE 77487
// exit ;
77485: GO 77943
// height := hex [ 2 ] ;
77487: LD_ADDR_VAR 0 13
77491: PUSH
77492: LD_VAR 0 15
77496: PUSH
77497: LD_INT 2
77499: ARRAY
77500: ST_TO_ADDR
// for i = 1 to hexes do
77501: LD_ADDR_VAR 0 7
77505: PUSH
77506: DOUBLE
77507: LD_INT 1
77509: DEC
77510: ST_TO_ADDR
77511: LD_VAR 0 12
77515: PUSH
77516: FOR_TO
77517: IFFALSE 77847
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77519: LD_VAR 0 12
77523: PUSH
77524: LD_VAR 0 7
77528: ARRAY
77529: PUSH
77530: LD_INT 1
77532: ARRAY
77533: PPUSH
77534: LD_VAR 0 12
77538: PUSH
77539: LD_VAR 0 7
77543: ARRAY
77544: PUSH
77545: LD_INT 2
77547: ARRAY
77548: PPUSH
77549: CALL_OW 488
77553: NOT
77554: PUSH
77555: LD_VAR 0 12
77559: PUSH
77560: LD_VAR 0 7
77564: ARRAY
77565: PUSH
77566: LD_INT 1
77568: ARRAY
77569: PPUSH
77570: LD_VAR 0 12
77574: PUSH
77575: LD_VAR 0 7
77579: ARRAY
77580: PUSH
77581: LD_INT 2
77583: ARRAY
77584: PPUSH
77585: CALL_OW 428
77589: PUSH
77590: LD_INT 0
77592: GREATER
77593: OR
77594: PUSH
77595: LD_VAR 0 12
77599: PUSH
77600: LD_VAR 0 7
77604: ARRAY
77605: PUSH
77606: LD_INT 1
77608: ARRAY
77609: PPUSH
77610: LD_VAR 0 12
77614: PUSH
77615: LD_VAR 0 7
77619: ARRAY
77620: PUSH
77621: LD_INT 2
77623: ARRAY
77624: PPUSH
77625: CALL_OW 351
77629: OR
77630: IFFALSE 77636
// exit ;
77632: POP
77633: POP
77634: GO 77943
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77636: LD_ADDR_VAR 0 8
77640: PUSH
77641: LD_VAR 0 12
77645: PUSH
77646: LD_VAR 0 7
77650: ARRAY
77651: PUSH
77652: LD_INT 1
77654: ARRAY
77655: PPUSH
77656: LD_VAR 0 12
77660: PUSH
77661: LD_VAR 0 7
77665: ARRAY
77666: PUSH
77667: LD_INT 2
77669: ARRAY
77670: PPUSH
77671: CALL_OW 546
77675: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77676: LD_VAR 0 8
77680: PUSH
77681: LD_INT 1
77683: ARRAY
77684: PUSH
77685: LD_VAR 0 8
77689: PUSH
77690: LD_INT 2
77692: ARRAY
77693: PUSH
77694: LD_VAR 0 13
77698: PUSH
77699: LD_INT 2
77701: PLUS
77702: GREATER
77703: OR
77704: PUSH
77705: LD_VAR 0 8
77709: PUSH
77710: LD_INT 2
77712: ARRAY
77713: PUSH
77714: LD_VAR 0 13
77718: PUSH
77719: LD_INT 2
77721: MINUS
77722: LESS
77723: OR
77724: PUSH
77725: LD_VAR 0 8
77729: PUSH
77730: LD_INT 3
77732: ARRAY
77733: PUSH
77734: LD_INT 0
77736: PUSH
77737: LD_INT 8
77739: PUSH
77740: LD_INT 9
77742: PUSH
77743: LD_INT 10
77745: PUSH
77746: LD_INT 11
77748: PUSH
77749: LD_INT 12
77751: PUSH
77752: LD_INT 13
77754: PUSH
77755: LD_INT 16
77757: PUSH
77758: LD_INT 17
77760: PUSH
77761: LD_INT 18
77763: PUSH
77764: LD_INT 19
77766: PUSH
77767: LD_INT 20
77769: PUSH
77770: LD_INT 21
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: LIST
77782: LIST
77783: LIST
77784: LIST
77785: LIST
77786: LIST
77787: IN
77788: NOT
77789: OR
77790: PUSH
77791: LD_VAR 0 8
77795: PUSH
77796: LD_INT 5
77798: ARRAY
77799: NOT
77800: OR
77801: PUSH
77802: LD_VAR 0 8
77806: PUSH
77807: LD_INT 6
77809: ARRAY
77810: PUSH
77811: LD_INT 1
77813: PUSH
77814: LD_INT 2
77816: PUSH
77817: LD_INT 7
77819: PUSH
77820: LD_INT 9
77822: PUSH
77823: LD_INT 10
77825: PUSH
77826: LD_INT 11
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: LIST
77833: LIST
77834: LIST
77835: LIST
77836: IN
77837: NOT
77838: OR
77839: IFFALSE 77845
// exit ;
77841: POP
77842: POP
77843: GO 77943
// end ;
77845: GO 77516
77847: POP
77848: POP
// side := GetSide ( depot ) ;
77849: LD_ADDR_VAR 0 9
77853: PUSH
77854: LD_VAR 0 1
77858: PPUSH
77859: CALL_OW 255
77863: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77864: LD_VAR 0 9
77868: PPUSH
77869: LD_VAR 0 3
77873: PPUSH
77874: LD_VAR 0 4
77878: PPUSH
77879: LD_INT 20
77881: PPUSH
77882: CALL 70597 0 4
77886: PUSH
77887: LD_INT 4
77889: ARRAY
77890: IFFALSE 77894
// exit ;
77892: GO 77943
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77894: LD_VAR 0 2
77898: PUSH
77899: LD_INT 29
77901: PUSH
77902: LD_INT 30
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: IN
77909: PUSH
77910: LD_VAR 0 3
77914: PPUSH
77915: LD_VAR 0 4
77919: PPUSH
77920: LD_VAR 0 9
77924: PPUSH
77925: CALL_OW 440
77929: NOT
77930: AND
77931: IFFALSE 77935
// exit ;
77933: GO 77943
// result := true ;
77935: LD_ADDR_VAR 0 6
77939: PUSH
77940: LD_INT 1
77942: ST_TO_ADDR
// end ;
77943: LD_VAR 0 6
77947: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
77948: LD_INT 0
77950: PPUSH
77951: PPUSH
77952: PPUSH
77953: PPUSH
77954: PPUSH
77955: PPUSH
77956: PPUSH
77957: PPUSH
77958: PPUSH
77959: PPUSH
77960: PPUSH
77961: PPUSH
77962: PPUSH
77963: PPUSH
77964: PPUSH
77965: PPUSH
77966: PPUSH
77967: PPUSH
77968: PPUSH
77969: PPUSH
77970: PPUSH
77971: PPUSH
77972: PPUSH
77973: PPUSH
77974: PPUSH
77975: PPUSH
77976: PPUSH
77977: PPUSH
77978: PPUSH
77979: PPUSH
77980: PPUSH
77981: PPUSH
77982: PPUSH
77983: PPUSH
77984: PPUSH
77985: PPUSH
77986: PPUSH
77987: PPUSH
77988: PPUSH
77989: PPUSH
77990: PPUSH
77991: PPUSH
77992: PPUSH
77993: PPUSH
77994: PPUSH
77995: PPUSH
77996: PPUSH
77997: PPUSH
77998: PPUSH
77999: PPUSH
78000: PPUSH
78001: PPUSH
78002: PPUSH
78003: PPUSH
78004: PPUSH
78005: PPUSH
78006: PPUSH
78007: PPUSH
// result = [ ] ;
78008: LD_ADDR_VAR 0 7
78012: PUSH
78013: EMPTY
78014: ST_TO_ADDR
// temp_list = [ ] ;
78015: LD_ADDR_VAR 0 9
78019: PUSH
78020: EMPTY
78021: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78022: LD_VAR 0 4
78026: PUSH
78027: LD_INT 0
78029: PUSH
78030: LD_INT 1
78032: PUSH
78033: LD_INT 2
78035: PUSH
78036: LD_INT 3
78038: PUSH
78039: LD_INT 4
78041: PUSH
78042: LD_INT 5
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: LIST
78049: LIST
78050: LIST
78051: LIST
78052: IN
78053: NOT
78054: PUSH
78055: LD_VAR 0 1
78059: PUSH
78060: LD_INT 0
78062: PUSH
78063: LD_INT 1
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: IN
78070: PUSH
78071: LD_VAR 0 5
78075: PUSH
78076: LD_INT 1
78078: PUSH
78079: LD_INT 2
78081: PUSH
78082: LD_INT 3
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: LIST
78089: IN
78090: NOT
78091: AND
78092: OR
78093: IFFALSE 78097
// exit ;
78095: GO 96488
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78097: LD_VAR 0 1
78101: PUSH
78102: LD_INT 6
78104: PUSH
78105: LD_INT 7
78107: PUSH
78108: LD_INT 8
78110: PUSH
78111: LD_INT 13
78113: PUSH
78114: LD_INT 12
78116: PUSH
78117: LD_INT 15
78119: PUSH
78120: LD_INT 11
78122: PUSH
78123: LD_INT 14
78125: PUSH
78126: LD_INT 10
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: IN
78140: IFFALSE 78150
// btype = b_lab ;
78142: LD_ADDR_VAR 0 1
78146: PUSH
78147: LD_INT 6
78149: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78150: LD_VAR 0 6
78154: PUSH
78155: LD_INT 0
78157: PUSH
78158: LD_INT 1
78160: PUSH
78161: LD_INT 2
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: LIST
78168: IN
78169: NOT
78170: PUSH
78171: LD_VAR 0 1
78175: PUSH
78176: LD_INT 0
78178: PUSH
78179: LD_INT 1
78181: PUSH
78182: LD_INT 2
78184: PUSH
78185: LD_INT 3
78187: PUSH
78188: LD_INT 6
78190: PUSH
78191: LD_INT 36
78193: PUSH
78194: LD_INT 4
78196: PUSH
78197: LD_INT 5
78199: PUSH
78200: LD_INT 31
78202: PUSH
78203: LD_INT 32
78205: PUSH
78206: LD_INT 33
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: IN
78222: NOT
78223: PUSH
78224: LD_VAR 0 6
78228: PUSH
78229: LD_INT 1
78231: EQUAL
78232: AND
78233: OR
78234: PUSH
78235: LD_VAR 0 1
78239: PUSH
78240: LD_INT 2
78242: PUSH
78243: LD_INT 3
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: IN
78250: NOT
78251: PUSH
78252: LD_VAR 0 6
78256: PUSH
78257: LD_INT 2
78259: EQUAL
78260: AND
78261: OR
78262: IFFALSE 78272
// mode = 0 ;
78264: LD_ADDR_VAR 0 6
78268: PUSH
78269: LD_INT 0
78271: ST_TO_ADDR
// case mode of 0 :
78272: LD_VAR 0 6
78276: PUSH
78277: LD_INT 0
78279: DOUBLE
78280: EQUAL
78281: IFTRUE 78285
78283: GO 89738
78285: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78286: LD_ADDR_VAR 0 11
78290: PUSH
78291: LD_INT 0
78293: PUSH
78294: LD_INT 0
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 0
78303: PUSH
78304: LD_INT 1
78306: NEG
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 1
78314: PUSH
78315: LD_INT 0
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 1
78324: PUSH
78325: LD_INT 1
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: LD_INT 1
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: NEG
78345: PUSH
78346: LD_INT 0
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 1
78355: NEG
78356: PUSH
78357: LD_INT 1
78359: NEG
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: PUSH
78365: LD_INT 1
78367: NEG
78368: PUSH
78369: LD_INT 2
78371: NEG
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: PUSH
78377: LD_INT 0
78379: PUSH
78380: LD_INT 2
78382: NEG
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 1
78390: PUSH
78391: LD_INT 1
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 1
78401: PUSH
78402: LD_INT 2
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 0
78411: PUSH
78412: LD_INT 2
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 1
78421: NEG
78422: PUSH
78423: LD_INT 1
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 1
78432: PUSH
78433: LD_INT 3
78435: PUSH
78436: EMPTY
78437: LIST
78438: LIST
78439: PUSH
78440: LD_INT 0
78442: PUSH
78443: LD_INT 3
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 1
78452: NEG
78453: PUSH
78454: LD_INT 2
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: LIST
78468: LIST
78469: LIST
78470: LIST
78471: LIST
78472: LIST
78473: LIST
78474: LIST
78475: LIST
78476: LIST
78477: LIST
78478: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78479: LD_ADDR_VAR 0 12
78483: PUSH
78484: LD_INT 0
78486: PUSH
78487: LD_INT 0
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 0
78496: PUSH
78497: LD_INT 1
78499: NEG
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 1
78507: PUSH
78508: LD_INT 0
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 1
78517: PUSH
78518: LD_INT 1
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 0
78527: PUSH
78528: LD_INT 1
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: PUSH
78535: LD_INT 1
78537: NEG
78538: PUSH
78539: LD_INT 0
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 1
78548: NEG
78549: PUSH
78550: LD_INT 1
78552: NEG
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 1
78560: PUSH
78561: LD_INT 1
78563: NEG
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 2
78571: PUSH
78572: LD_INT 0
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: LD_INT 2
78581: PUSH
78582: LD_INT 1
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 1
78591: NEG
78592: PUSH
78593: LD_INT 1
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 2
78602: NEG
78603: PUSH
78604: LD_INT 0
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 2
78613: NEG
78614: PUSH
78615: LD_INT 1
78617: NEG
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: PUSH
78623: LD_INT 2
78625: NEG
78626: PUSH
78627: LD_INT 1
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 3
78636: NEG
78637: PUSH
78638: LD_INT 0
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 3
78647: NEG
78648: PUSH
78649: LD_INT 1
78651: NEG
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: LIST
78661: LIST
78662: LIST
78663: LIST
78664: LIST
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: LIST
78671: LIST
78672: LIST
78673: LIST
78674: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78675: LD_ADDR_VAR 0 13
78679: PUSH
78680: LD_INT 0
78682: PUSH
78683: LD_INT 0
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 0
78692: PUSH
78693: LD_INT 1
78695: NEG
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: PUSH
78701: LD_INT 1
78703: PUSH
78704: LD_INT 0
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 1
78713: PUSH
78714: LD_INT 1
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 0
78723: PUSH
78724: LD_INT 1
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 1
78733: NEG
78734: PUSH
78735: LD_INT 0
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 1
78744: NEG
78745: PUSH
78746: LD_INT 1
78748: NEG
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 1
78756: NEG
78757: PUSH
78758: LD_INT 2
78760: NEG
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: LD_INT 2
78768: PUSH
78769: LD_INT 1
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 2
78778: PUSH
78779: LD_INT 2
78781: PUSH
78782: EMPTY
78783: LIST
78784: LIST
78785: PUSH
78786: LD_INT 1
78788: PUSH
78789: LD_INT 2
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 2
78798: NEG
78799: PUSH
78800: LD_INT 1
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 2
78810: NEG
78811: PUSH
78812: LD_INT 2
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 2
78822: NEG
78823: PUSH
78824: LD_INT 3
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 3
78834: NEG
78835: PUSH
78836: LD_INT 2
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 3
78846: NEG
78847: PUSH
78848: LD_INT 3
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78874: LD_ADDR_VAR 0 14
78878: PUSH
78879: LD_INT 0
78881: PUSH
78882: LD_INT 0
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 0
78891: PUSH
78892: LD_INT 1
78894: NEG
78895: PUSH
78896: EMPTY
78897: LIST
78898: LIST
78899: PUSH
78900: LD_INT 1
78902: PUSH
78903: LD_INT 0
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 1
78912: PUSH
78913: LD_INT 1
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 0
78922: PUSH
78923: LD_INT 1
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 1
78932: NEG
78933: PUSH
78934: LD_INT 0
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 1
78943: NEG
78944: PUSH
78945: LD_INT 1
78947: NEG
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 1
78955: NEG
78956: PUSH
78957: LD_INT 2
78959: NEG
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: PUSH
78965: LD_INT 0
78967: PUSH
78968: LD_INT 2
78970: NEG
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 1
78978: PUSH
78979: LD_INT 1
78981: NEG
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PUSH
78987: LD_INT 1
78989: PUSH
78990: LD_INT 2
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 0
78999: PUSH
79000: LD_INT 2
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 1
79009: NEG
79010: PUSH
79011: LD_INT 1
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: LD_INT 1
79020: NEG
79021: PUSH
79022: LD_INT 3
79024: NEG
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_INT 0
79032: PUSH
79033: LD_INT 3
79035: NEG
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: LD_INT 2
79046: NEG
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: EMPTY
79053: LIST
79054: LIST
79055: LIST
79056: LIST
79057: LIST
79058: LIST
79059: LIST
79060: LIST
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79070: LD_ADDR_VAR 0 15
79074: PUSH
79075: LD_INT 0
79077: PUSH
79078: LD_INT 0
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 0
79087: PUSH
79088: LD_INT 1
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 1
79098: PUSH
79099: LD_INT 0
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 1
79108: PUSH
79109: LD_INT 1
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 0
79118: PUSH
79119: LD_INT 1
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 1
79128: NEG
79129: PUSH
79130: LD_INT 0
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 1
79139: NEG
79140: PUSH
79141: LD_INT 1
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 1
79151: PUSH
79152: LD_INT 1
79154: NEG
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 2
79162: PUSH
79163: LD_INT 0
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: LD_INT 2
79172: PUSH
79173: LD_INT 1
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 1
79182: NEG
79183: PUSH
79184: LD_INT 1
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: LD_INT 2
79193: NEG
79194: PUSH
79195: LD_INT 0
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 2
79204: NEG
79205: PUSH
79206: LD_INT 1
79208: NEG
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 2
79216: PUSH
79217: LD_INT 1
79219: NEG
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 3
79227: PUSH
79228: LD_INT 0
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 3
79237: PUSH
79238: LD_INT 1
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: LIST
79249: LIST
79250: LIST
79251: LIST
79252: LIST
79253: LIST
79254: LIST
79255: LIST
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79263: LD_ADDR_VAR 0 16
79267: PUSH
79268: LD_INT 0
79270: PUSH
79271: LD_INT 0
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 0
79280: PUSH
79281: LD_INT 1
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 1
79291: PUSH
79292: LD_INT 0
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 1
79301: PUSH
79302: LD_INT 1
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 0
79311: PUSH
79312: LD_INT 1
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 1
79321: NEG
79322: PUSH
79323: LD_INT 0
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 1
79332: NEG
79333: PUSH
79334: LD_INT 1
79336: NEG
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: PUSH
79342: LD_INT 1
79344: NEG
79345: PUSH
79346: LD_INT 2
79348: NEG
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 2
79356: PUSH
79357: LD_INT 1
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 2
79366: PUSH
79367: LD_INT 2
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 1
79376: PUSH
79377: LD_INT 2
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 2
79386: NEG
79387: PUSH
79388: LD_INT 1
79390: NEG
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 2
79398: NEG
79399: PUSH
79400: LD_INT 2
79402: NEG
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: LD_INT 3
79410: PUSH
79411: LD_INT 2
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 3
79420: PUSH
79421: LD_INT 3
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 2
79430: PUSH
79431: LD_INT 3
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79456: LD_ADDR_VAR 0 17
79460: PUSH
79461: LD_INT 0
79463: PUSH
79464: LD_INT 0
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 0
79473: PUSH
79474: LD_INT 1
79476: NEG
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: PUSH
79482: LD_INT 1
79484: PUSH
79485: LD_INT 0
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 1
79494: PUSH
79495: LD_INT 1
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: LD_INT 0
79504: PUSH
79505: LD_INT 1
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 1
79514: NEG
79515: PUSH
79516: LD_INT 0
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 1
79525: NEG
79526: PUSH
79527: LD_INT 1
79529: NEG
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 1
79537: NEG
79538: PUSH
79539: LD_INT 2
79541: NEG
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 0
79549: PUSH
79550: LD_INT 2
79552: NEG
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: PUSH
79558: LD_INT 1
79560: PUSH
79561: LD_INT 1
79563: NEG
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 2
79571: PUSH
79572: LD_INT 0
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 2
79581: PUSH
79582: LD_INT 1
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 2
79591: PUSH
79592: LD_INT 2
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: LD_INT 2
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 0
79611: PUSH
79612: LD_INT 2
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 1
79621: NEG
79622: PUSH
79623: LD_INT 1
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 2
79632: NEG
79633: PUSH
79634: LD_INT 0
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 2
79643: NEG
79644: PUSH
79645: LD_INT 1
79647: NEG
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 2
79655: NEG
79656: PUSH
79657: LD_INT 2
79659: NEG
79660: PUSH
79661: EMPTY
79662: LIST
79663: LIST
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: LIST
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79686: LD_ADDR_VAR 0 18
79690: PUSH
79691: LD_INT 0
79693: PUSH
79694: LD_INT 0
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 0
79703: PUSH
79704: LD_INT 1
79706: NEG
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: LD_INT 0
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 1
79724: PUSH
79725: LD_INT 1
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 0
79734: PUSH
79735: LD_INT 1
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 1
79744: NEG
79745: PUSH
79746: LD_INT 0
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 1
79755: NEG
79756: PUSH
79757: LD_INT 1
79759: NEG
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 1
79767: NEG
79768: PUSH
79769: LD_INT 2
79771: NEG
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PUSH
79777: LD_INT 0
79779: PUSH
79780: LD_INT 2
79782: NEG
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 1
79790: PUSH
79791: LD_INT 1
79793: NEG
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 2
79801: PUSH
79802: LD_INT 0
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 2
79811: PUSH
79812: LD_INT 1
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 2
79821: PUSH
79822: LD_INT 2
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 1
79831: PUSH
79832: LD_INT 2
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 0
79841: PUSH
79842: LD_INT 2
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 1
79851: NEG
79852: PUSH
79853: LD_INT 1
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 2
79862: NEG
79863: PUSH
79864: LD_INT 0
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: PUSH
79871: LD_INT 2
79873: NEG
79874: PUSH
79875: LD_INT 1
79877: NEG
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: LD_INT 2
79885: NEG
79886: PUSH
79887: LD_INT 2
79889: NEG
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: EMPTY
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79916: LD_ADDR_VAR 0 19
79920: PUSH
79921: LD_INT 0
79923: PUSH
79924: LD_INT 0
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 0
79933: PUSH
79934: LD_INT 1
79936: NEG
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: LD_INT 1
79944: PUSH
79945: LD_INT 0
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: LD_INT 1
79954: PUSH
79955: LD_INT 1
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: LD_INT 0
79964: PUSH
79965: LD_INT 1
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 1
79974: NEG
79975: PUSH
79976: LD_INT 0
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: PUSH
79983: LD_INT 1
79985: NEG
79986: PUSH
79987: LD_INT 1
79989: NEG
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 1
79997: NEG
79998: PUSH
79999: LD_INT 2
80001: NEG
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 0
80009: PUSH
80010: LD_INT 2
80012: NEG
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 1
80020: PUSH
80021: LD_INT 1
80023: NEG
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 2
80031: PUSH
80032: LD_INT 0
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 2
80041: PUSH
80042: LD_INT 1
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 2
80051: PUSH
80052: LD_INT 2
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 1
80061: PUSH
80062: LD_INT 2
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 0
80071: PUSH
80072: LD_INT 2
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 1
80081: NEG
80082: PUSH
80083: LD_INT 1
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 2
80092: NEG
80093: PUSH
80094: LD_INT 0
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 2
80103: NEG
80104: PUSH
80105: LD_INT 1
80107: NEG
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 2
80115: NEG
80116: PUSH
80117: LD_INT 2
80119: NEG
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: LIST
80141: LIST
80142: LIST
80143: LIST
80144: LIST
80145: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80146: LD_ADDR_VAR 0 20
80150: PUSH
80151: LD_INT 0
80153: PUSH
80154: LD_INT 0
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 0
80163: PUSH
80164: LD_INT 1
80166: NEG
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 1
80174: PUSH
80175: LD_INT 0
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 1
80184: PUSH
80185: LD_INT 1
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 0
80194: PUSH
80195: LD_INT 1
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 1
80204: NEG
80205: PUSH
80206: LD_INT 0
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: PUSH
80213: LD_INT 1
80215: NEG
80216: PUSH
80217: LD_INT 1
80219: NEG
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 1
80227: NEG
80228: PUSH
80229: LD_INT 2
80231: NEG
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 0
80239: PUSH
80240: LD_INT 2
80242: NEG
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 1
80250: PUSH
80251: LD_INT 1
80253: NEG
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 2
80261: PUSH
80262: LD_INT 0
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 2
80271: PUSH
80272: LD_INT 1
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 2
80281: PUSH
80282: LD_INT 2
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 1
80291: PUSH
80292: LD_INT 2
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 0
80301: PUSH
80302: LD_INT 2
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 1
80311: NEG
80312: PUSH
80313: LD_INT 1
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: LD_INT 0
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: LD_INT 2
80333: NEG
80334: PUSH
80335: LD_INT 1
80337: NEG
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 2
80345: NEG
80346: PUSH
80347: LD_INT 2
80349: NEG
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80376: LD_ADDR_VAR 0 21
80380: PUSH
80381: LD_INT 0
80383: PUSH
80384: LD_INT 0
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 0
80393: PUSH
80394: LD_INT 1
80396: NEG
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 1
80404: PUSH
80405: LD_INT 0
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 1
80414: PUSH
80415: LD_INT 1
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 0
80424: PUSH
80425: LD_INT 1
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 1
80434: NEG
80435: PUSH
80436: LD_INT 0
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 1
80445: NEG
80446: PUSH
80447: LD_INT 1
80449: NEG
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 1
80457: NEG
80458: PUSH
80459: LD_INT 2
80461: NEG
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 0
80469: PUSH
80470: LD_INT 2
80472: NEG
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 1
80480: PUSH
80481: LD_INT 1
80483: NEG
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 2
80491: PUSH
80492: LD_INT 0
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 2
80501: PUSH
80502: LD_INT 1
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 2
80511: PUSH
80512: LD_INT 2
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 1
80521: PUSH
80522: LD_INT 2
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 0
80531: PUSH
80532: LD_INT 2
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 1
80541: NEG
80542: PUSH
80543: LD_INT 1
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: LD_INT 0
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: PUSH
80561: LD_INT 2
80563: NEG
80564: PUSH
80565: LD_INT 1
80567: NEG
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 2
80575: NEG
80576: PUSH
80577: LD_INT 2
80579: NEG
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80606: LD_ADDR_VAR 0 22
80610: PUSH
80611: LD_INT 0
80613: PUSH
80614: LD_INT 0
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 0
80623: PUSH
80624: LD_INT 1
80626: NEG
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 1
80634: PUSH
80635: LD_INT 0
80637: PUSH
80638: EMPTY
80639: LIST
80640: LIST
80641: PUSH
80642: LD_INT 1
80644: PUSH
80645: LD_INT 1
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: LD_INT 1
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 1
80664: NEG
80665: PUSH
80666: LD_INT 0
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: LD_INT 1
80679: NEG
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 1
80687: NEG
80688: PUSH
80689: LD_INT 2
80691: NEG
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 0
80699: PUSH
80700: LD_INT 2
80702: NEG
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: LD_INT 1
80710: PUSH
80711: LD_INT 1
80713: NEG
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PUSH
80719: LD_INT 2
80721: PUSH
80722: LD_INT 0
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 2
80731: PUSH
80732: LD_INT 1
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 2
80741: PUSH
80742: LD_INT 2
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: PUSH
80749: LD_INT 1
80751: PUSH
80752: LD_INT 2
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 0
80761: PUSH
80762: LD_INT 2
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 1
80771: NEG
80772: PUSH
80773: LD_INT 1
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 2
80782: NEG
80783: PUSH
80784: LD_INT 0
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: LD_INT 2
80793: NEG
80794: PUSH
80795: LD_INT 1
80797: NEG
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 2
80805: NEG
80806: PUSH
80807: LD_INT 2
80809: NEG
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: LIST
80835: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80836: LD_ADDR_VAR 0 23
80840: PUSH
80841: LD_INT 0
80843: PUSH
80844: LD_INT 0
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: PUSH
80865: LD_INT 0
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 1
80874: PUSH
80875: LD_INT 1
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 0
80884: PUSH
80885: LD_INT 1
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: NEG
80895: PUSH
80896: LD_INT 0
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: LD_INT 1
80909: NEG
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 1
80917: NEG
80918: PUSH
80919: LD_INT 2
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 0
80929: PUSH
80930: LD_INT 2
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 1
80940: PUSH
80941: LD_INT 1
80943: NEG
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 2
80951: PUSH
80952: LD_INT 0
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 2
80961: PUSH
80962: LD_INT 1
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 2
80971: PUSH
80972: LD_INT 2
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: LD_INT 2
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 0
80991: PUSH
80992: LD_INT 2
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 1
81001: NEG
81002: PUSH
81003: LD_INT 1
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 2
81012: NEG
81013: PUSH
81014: LD_INT 0
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 2
81023: NEG
81024: PUSH
81025: LD_INT 1
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 2
81035: NEG
81036: PUSH
81037: LD_INT 2
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 2
81047: NEG
81048: PUSH
81049: LD_INT 3
81051: NEG
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 1
81059: NEG
81060: PUSH
81061: LD_INT 3
81063: NEG
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 1
81071: PUSH
81072: LD_INT 2
81074: NEG
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 2
81082: PUSH
81083: LD_INT 1
81085: NEG
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: LIST
81105: LIST
81106: LIST
81107: LIST
81108: LIST
81109: LIST
81110: LIST
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81116: LD_ADDR_VAR 0 24
81120: PUSH
81121: LD_INT 0
81123: PUSH
81124: LD_INT 0
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 0
81133: PUSH
81134: LD_INT 1
81136: NEG
81137: PUSH
81138: EMPTY
81139: LIST
81140: LIST
81141: PUSH
81142: LD_INT 1
81144: PUSH
81145: LD_INT 0
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PUSH
81152: LD_INT 1
81154: PUSH
81155: LD_INT 1
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 0
81164: PUSH
81165: LD_INT 1
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 1
81174: NEG
81175: PUSH
81176: LD_INT 0
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 1
81185: NEG
81186: PUSH
81187: LD_INT 1
81189: NEG
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 1
81197: NEG
81198: PUSH
81199: LD_INT 2
81201: NEG
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 0
81209: PUSH
81210: LD_INT 2
81212: NEG
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 1
81220: PUSH
81221: LD_INT 1
81223: NEG
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: PUSH
81229: LD_INT 2
81231: PUSH
81232: LD_INT 0
81234: PUSH
81235: EMPTY
81236: LIST
81237: LIST
81238: PUSH
81239: LD_INT 2
81241: PUSH
81242: LD_INT 1
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 2
81251: PUSH
81252: LD_INT 2
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 1
81261: PUSH
81262: LD_INT 2
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 0
81271: PUSH
81272: LD_INT 2
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 1
81281: NEG
81282: PUSH
81283: LD_INT 1
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 2
81292: NEG
81293: PUSH
81294: LD_INT 0
81296: PUSH
81297: EMPTY
81298: LIST
81299: LIST
81300: PUSH
81301: LD_INT 2
81303: NEG
81304: PUSH
81305: LD_INT 1
81307: NEG
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: PUSH
81313: LD_INT 2
81315: NEG
81316: PUSH
81317: LD_INT 2
81319: NEG
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 1
81327: PUSH
81328: LD_INT 2
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 2
81338: PUSH
81339: LD_INT 1
81341: NEG
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 3
81349: PUSH
81350: LD_INT 1
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 3
81359: PUSH
81360: LD_INT 2
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: LIST
81386: LIST
81387: LIST
81388: LIST
81389: LIST
81390: LIST
81391: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81392: LD_ADDR_VAR 0 25
81396: PUSH
81397: LD_INT 0
81399: PUSH
81400: LD_INT 0
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 0
81409: PUSH
81410: LD_INT 1
81412: NEG
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 1
81420: PUSH
81421: LD_INT 0
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 1
81430: PUSH
81431: LD_INT 1
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 0
81440: PUSH
81441: LD_INT 1
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 1
81450: NEG
81451: PUSH
81452: LD_INT 0
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 1
81461: NEG
81462: PUSH
81463: LD_INT 1
81465: NEG
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 1
81473: NEG
81474: PUSH
81475: LD_INT 2
81477: NEG
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 0
81485: PUSH
81486: LD_INT 2
81488: NEG
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 1
81496: PUSH
81497: LD_INT 1
81499: NEG
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: LD_INT 2
81507: PUSH
81508: LD_INT 0
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 2
81517: PUSH
81518: LD_INT 1
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 2
81527: PUSH
81528: LD_INT 2
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 1
81537: PUSH
81538: LD_INT 2
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 0
81547: PUSH
81548: LD_INT 2
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 1
81557: NEG
81558: PUSH
81559: LD_INT 1
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 2
81568: NEG
81569: PUSH
81570: LD_INT 0
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 2
81579: NEG
81580: PUSH
81581: LD_INT 1
81583: NEG
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 2
81591: NEG
81592: PUSH
81593: LD_INT 2
81595: NEG
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 3
81603: PUSH
81604: LD_INT 1
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 3
81613: PUSH
81614: LD_INT 2
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 2
81623: PUSH
81624: LD_INT 3
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_INT 1
81633: PUSH
81634: LD_INT 3
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: LIST
81661: LIST
81662: LIST
81663: LIST
81664: LIST
81665: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81666: LD_ADDR_VAR 0 26
81670: PUSH
81671: LD_INT 0
81673: PUSH
81674: LD_INT 0
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 0
81683: PUSH
81684: LD_INT 1
81686: NEG
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 1
81694: PUSH
81695: LD_INT 0
81697: PUSH
81698: EMPTY
81699: LIST
81700: LIST
81701: PUSH
81702: LD_INT 1
81704: PUSH
81705: LD_INT 1
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: PUSH
81712: LD_INT 0
81714: PUSH
81715: LD_INT 1
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: LD_INT 1
81724: NEG
81725: PUSH
81726: LD_INT 0
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 1
81735: NEG
81736: PUSH
81737: LD_INT 1
81739: NEG
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 1
81747: NEG
81748: PUSH
81749: LD_INT 2
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 0
81759: PUSH
81760: LD_INT 2
81762: NEG
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 1
81770: PUSH
81771: LD_INT 1
81773: NEG
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 2
81781: PUSH
81782: LD_INT 0
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 2
81791: PUSH
81792: LD_INT 1
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: PUSH
81802: LD_INT 2
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 1
81811: PUSH
81812: LD_INT 2
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: LD_INT 0
81821: PUSH
81822: LD_INT 2
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 1
81831: NEG
81832: PUSH
81833: LD_INT 1
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 2
81842: NEG
81843: PUSH
81844: LD_INT 0
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 2
81853: NEG
81854: PUSH
81855: LD_INT 1
81857: NEG
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 2
81865: NEG
81866: PUSH
81867: LD_INT 2
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 2
81877: PUSH
81878: LD_INT 3
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 1
81887: PUSH
81888: LD_INT 3
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 1
81897: NEG
81898: PUSH
81899: LD_INT 2
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 2
81908: NEG
81909: PUSH
81910: LD_INT 1
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: LIST
81921: LIST
81922: LIST
81923: LIST
81924: LIST
81925: LIST
81926: LIST
81927: LIST
81928: LIST
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81942: LD_ADDR_VAR 0 27
81946: PUSH
81947: LD_INT 0
81949: PUSH
81950: LD_INT 0
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 0
81959: PUSH
81960: LD_INT 1
81962: NEG
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 1
81970: PUSH
81971: LD_INT 0
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 1
81980: PUSH
81981: LD_INT 1
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 0
81990: PUSH
81991: LD_INT 1
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 1
82000: NEG
82001: PUSH
82002: LD_INT 0
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 1
82011: NEG
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 1
82023: NEG
82024: PUSH
82025: LD_INT 2
82027: NEG
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 0
82035: PUSH
82036: LD_INT 2
82038: NEG
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 1
82046: PUSH
82047: LD_INT 1
82049: NEG
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 2
82057: PUSH
82058: LD_INT 0
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 2
82067: PUSH
82068: LD_INT 1
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 2
82077: PUSH
82078: LD_INT 2
82080: PUSH
82081: EMPTY
82082: LIST
82083: LIST
82084: PUSH
82085: LD_INT 1
82087: PUSH
82088: LD_INT 2
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: LD_INT 0
82097: PUSH
82098: LD_INT 2
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: PUSH
82105: LD_INT 1
82107: NEG
82108: PUSH
82109: LD_INT 1
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 2
82118: NEG
82119: PUSH
82120: LD_INT 0
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 2
82129: NEG
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 2
82141: NEG
82142: PUSH
82143: LD_INT 2
82145: NEG
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 1
82153: NEG
82154: PUSH
82155: LD_INT 2
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 2
82164: NEG
82165: PUSH
82166: LD_INT 1
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: LD_INT 3
82175: NEG
82176: PUSH
82177: LD_INT 1
82179: NEG
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 3
82187: NEG
82188: PUSH
82189: LD_INT 2
82191: NEG
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82222: LD_ADDR_VAR 0 28
82226: PUSH
82227: LD_INT 0
82229: PUSH
82230: LD_INT 0
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 0
82239: PUSH
82240: LD_INT 1
82242: NEG
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 1
82250: PUSH
82251: LD_INT 0
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 1
82260: PUSH
82261: LD_INT 1
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 0
82270: PUSH
82271: LD_INT 1
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 1
82280: NEG
82281: PUSH
82282: LD_INT 0
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 1
82291: NEG
82292: PUSH
82293: LD_INT 1
82295: NEG
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: LD_INT 1
82303: NEG
82304: PUSH
82305: LD_INT 2
82307: NEG
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 0
82315: PUSH
82316: LD_INT 2
82318: NEG
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 1
82326: PUSH
82327: LD_INT 1
82329: NEG
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: PUSH
82335: LD_INT 2
82337: PUSH
82338: LD_INT 0
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: PUSH
82345: LD_INT 2
82347: PUSH
82348: LD_INT 1
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 2
82357: PUSH
82358: LD_INT 2
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: PUSH
82365: LD_INT 1
82367: PUSH
82368: LD_INT 2
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 0
82377: PUSH
82378: LD_INT 2
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: LD_INT 1
82387: NEG
82388: PUSH
82389: LD_INT 1
82391: PUSH
82392: EMPTY
82393: LIST
82394: LIST
82395: PUSH
82396: LD_INT 2
82398: NEG
82399: PUSH
82400: LD_INT 0
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: LD_INT 2
82409: NEG
82410: PUSH
82411: LD_INT 1
82413: NEG
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: PUSH
82419: LD_INT 2
82421: NEG
82422: PUSH
82423: LD_INT 2
82425: NEG
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: PUSH
82431: LD_INT 2
82433: NEG
82434: PUSH
82435: LD_INT 3
82437: NEG
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 1
82445: NEG
82446: PUSH
82447: LD_INT 3
82449: NEG
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 3
82457: NEG
82458: PUSH
82459: LD_INT 1
82461: NEG
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 3
82469: NEG
82470: PUSH
82471: LD_INT 2
82473: NEG
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: LIST
82486: LIST
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82504: LD_ADDR_VAR 0 29
82508: PUSH
82509: LD_INT 0
82511: PUSH
82512: LD_INT 0
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: LD_INT 1
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 1
82532: PUSH
82533: LD_INT 0
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 1
82542: PUSH
82543: LD_INT 1
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PUSH
82550: LD_INT 0
82552: PUSH
82553: LD_INT 1
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 1
82562: NEG
82563: PUSH
82564: LD_INT 0
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 1
82573: NEG
82574: PUSH
82575: LD_INT 1
82577: NEG
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 1
82585: NEG
82586: PUSH
82587: LD_INT 2
82589: NEG
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 0
82597: PUSH
82598: LD_INT 2
82600: NEG
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 1
82608: PUSH
82609: LD_INT 1
82611: NEG
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 2
82619: PUSH
82620: LD_INT 0
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 2
82629: PUSH
82630: LD_INT 1
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 1
82639: PUSH
82640: LD_INT 2
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 0
82649: PUSH
82650: LD_INT 2
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 1
82659: NEG
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 2
82670: NEG
82671: PUSH
82672: LD_INT 1
82674: NEG
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 2
82682: NEG
82683: PUSH
82684: LD_INT 2
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 2
82694: NEG
82695: PUSH
82696: LD_INT 3
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 2
82706: PUSH
82707: LD_INT 1
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 3
82717: PUSH
82718: LD_INT 1
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: LD_INT 3
82730: PUSH
82731: EMPTY
82732: LIST
82733: LIST
82734: PUSH
82735: LD_INT 1
82737: NEG
82738: PUSH
82739: LD_INT 2
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 3
82748: NEG
82749: PUSH
82750: LD_INT 2
82752: NEG
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82783: LD_ADDR_VAR 0 30
82787: PUSH
82788: LD_INT 0
82790: PUSH
82791: LD_INT 0
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 0
82800: PUSH
82801: LD_INT 1
82803: NEG
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 1
82811: PUSH
82812: LD_INT 0
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 1
82821: PUSH
82822: LD_INT 1
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 0
82831: PUSH
82832: LD_INT 1
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 1
82841: NEG
82842: PUSH
82843: LD_INT 0
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 1
82852: NEG
82853: PUSH
82854: LD_INT 1
82856: NEG
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 1
82864: NEG
82865: PUSH
82866: LD_INT 2
82868: NEG
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 0
82876: PUSH
82877: LD_INT 2
82879: NEG
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 1
82887: PUSH
82888: LD_INT 1
82890: NEG
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: PUSH
82896: LD_INT 2
82898: PUSH
82899: LD_INT 0
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 2
82908: PUSH
82909: LD_INT 1
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 2
82918: PUSH
82919: LD_INT 2
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 1
82928: PUSH
82929: LD_INT 2
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: LD_INT 1
82938: NEG
82939: PUSH
82940: LD_INT 1
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 2
82949: NEG
82950: PUSH
82951: LD_INT 0
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 2
82960: NEG
82961: PUSH
82962: LD_INT 1
82964: NEG
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: LD_INT 1
82972: NEG
82973: PUSH
82974: LD_INT 3
82976: NEG
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: PUSH
82982: LD_INT 1
82984: PUSH
82985: LD_INT 2
82987: NEG
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 3
82995: PUSH
82996: LD_INT 2
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 2
83005: PUSH
83006: LD_INT 3
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: PUSH
83013: LD_INT 2
83015: NEG
83016: PUSH
83017: LD_INT 1
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: PUSH
83024: LD_INT 3
83026: NEG
83027: PUSH
83028: LD_INT 1
83030: NEG
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83061: LD_ADDR_VAR 0 31
83065: PUSH
83066: LD_INT 0
83068: PUSH
83069: LD_INT 0
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 0
83078: PUSH
83079: LD_INT 1
83081: NEG
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 1
83089: PUSH
83090: LD_INT 0
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 1
83099: PUSH
83100: LD_INT 1
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 0
83109: PUSH
83110: LD_INT 1
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 1
83119: NEG
83120: PUSH
83121: LD_INT 0
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 1
83130: NEG
83131: PUSH
83132: LD_INT 1
83134: NEG
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 1
83142: NEG
83143: PUSH
83144: LD_INT 2
83146: NEG
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: PUSH
83152: LD_INT 1
83154: PUSH
83155: LD_INT 1
83157: NEG
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 2
83165: PUSH
83166: LD_INT 0
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: PUSH
83173: LD_INT 2
83175: PUSH
83176: LD_INT 1
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 2
83185: PUSH
83186: LD_INT 2
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 1
83195: PUSH
83196: LD_INT 2
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 0
83205: PUSH
83206: LD_INT 2
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 1
83215: NEG
83216: PUSH
83217: LD_INT 1
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 2
83226: NEG
83227: PUSH
83228: LD_INT 1
83230: NEG
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 2
83238: NEG
83239: PUSH
83240: LD_INT 2
83242: NEG
83243: PUSH
83244: EMPTY
83245: LIST
83246: LIST
83247: PUSH
83248: LD_INT 2
83250: NEG
83251: PUSH
83252: LD_INT 3
83254: NEG
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: PUSH
83260: LD_INT 2
83262: PUSH
83263: LD_INT 1
83265: NEG
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 3
83273: PUSH
83274: LD_INT 1
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: LD_INT 1
83283: PUSH
83284: LD_INT 3
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 1
83293: NEG
83294: PUSH
83295: LD_INT 2
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 3
83304: NEG
83305: PUSH
83306: LD_INT 2
83308: NEG
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: LIST
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: LIST
83335: LIST
83336: LIST
83337: LIST
83338: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83339: LD_ADDR_VAR 0 32
83343: PUSH
83344: LD_INT 0
83346: PUSH
83347: LD_INT 0
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 0
83356: PUSH
83357: LD_INT 1
83359: NEG
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 1
83367: PUSH
83368: LD_INT 0
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 1
83377: PUSH
83378: LD_INT 1
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 0
83387: PUSH
83388: LD_INT 1
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 1
83397: NEG
83398: PUSH
83399: LD_INT 0
83401: PUSH
83402: EMPTY
83403: LIST
83404: LIST
83405: PUSH
83406: LD_INT 1
83408: NEG
83409: PUSH
83410: LD_INT 1
83412: NEG
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: PUSH
83418: LD_INT 1
83420: NEG
83421: PUSH
83422: LD_INT 2
83424: NEG
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 0
83432: PUSH
83433: LD_INT 2
83435: NEG
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: PUSH
83441: LD_INT 1
83443: PUSH
83444: LD_INT 1
83446: NEG
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 2
83454: PUSH
83455: LD_INT 1
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 2
83464: PUSH
83465: LD_INT 2
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 1
83474: PUSH
83475: LD_INT 2
83477: PUSH
83478: EMPTY
83479: LIST
83480: LIST
83481: PUSH
83482: LD_INT 0
83484: PUSH
83485: LD_INT 2
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PUSH
83492: LD_INT 1
83494: NEG
83495: PUSH
83496: LD_INT 1
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 2
83505: NEG
83506: PUSH
83507: LD_INT 0
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_INT 2
83516: NEG
83517: PUSH
83518: LD_INT 1
83520: NEG
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: PUSH
83526: LD_INT 1
83528: NEG
83529: PUSH
83530: LD_INT 3
83532: NEG
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 1
83540: PUSH
83541: LD_INT 2
83543: NEG
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 3
83551: PUSH
83552: LD_INT 2
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 2
83561: PUSH
83562: LD_INT 3
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: LD_INT 2
83571: NEG
83572: PUSH
83573: LD_INT 1
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 3
83582: NEG
83583: PUSH
83584: LD_INT 1
83586: NEG
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83617: LD_ADDR_VAR 0 33
83621: PUSH
83622: LD_INT 0
83624: PUSH
83625: LD_INT 0
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 0
83634: PUSH
83635: LD_INT 1
83637: NEG
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 1
83645: PUSH
83646: LD_INT 0
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PUSH
83653: LD_INT 1
83655: PUSH
83656: LD_INT 1
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: LD_INT 0
83665: PUSH
83666: LD_INT 1
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 1
83675: NEG
83676: PUSH
83677: LD_INT 0
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 1
83686: NEG
83687: PUSH
83688: LD_INT 1
83690: NEG
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: LD_INT 1
83698: NEG
83699: PUSH
83700: LD_INT 2
83702: NEG
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 1
83710: PUSH
83711: LD_INT 1
83713: NEG
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 2
83721: PUSH
83722: LD_INT 0
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 2
83731: PUSH
83732: LD_INT 1
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: LD_INT 1
83741: PUSH
83742: LD_INT 2
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 0
83751: PUSH
83752: LD_INT 2
83754: PUSH
83755: EMPTY
83756: LIST
83757: LIST
83758: PUSH
83759: LD_INT 1
83761: NEG
83762: PUSH
83763: LD_INT 1
83765: PUSH
83766: EMPTY
83767: LIST
83768: LIST
83769: PUSH
83770: LD_INT 2
83772: NEG
83773: PUSH
83774: LD_INT 0
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: LD_INT 2
83783: NEG
83784: PUSH
83785: LD_INT 1
83787: NEG
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: LD_INT 2
83795: NEG
83796: PUSH
83797: LD_INT 2
83799: NEG
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: PUSH
83805: LD_INT 2
83807: NEG
83808: PUSH
83809: LD_INT 3
83811: NEG
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: LD_INT 2
83819: PUSH
83820: LD_INT 1
83822: NEG
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: PUSH
83828: LD_INT 3
83830: PUSH
83831: LD_INT 1
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 1
83840: PUSH
83841: LD_INT 3
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: NEG
83851: PUSH
83852: LD_INT 2
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 3
83861: NEG
83862: PUSH
83863: LD_INT 2
83865: NEG
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: EMPTY
83872: LIST
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83896: LD_ADDR_VAR 0 34
83900: PUSH
83901: LD_INT 0
83903: PUSH
83904: LD_INT 0
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: LD_INT 1
83916: NEG
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 1
83924: PUSH
83925: LD_INT 0
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: PUSH
83932: LD_INT 1
83934: PUSH
83935: LD_INT 1
83937: PUSH
83938: EMPTY
83939: LIST
83940: LIST
83941: PUSH
83942: LD_INT 0
83944: PUSH
83945: LD_INT 1
83947: PUSH
83948: EMPTY
83949: LIST
83950: LIST
83951: PUSH
83952: LD_INT 1
83954: NEG
83955: PUSH
83956: LD_INT 0
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 1
83965: NEG
83966: PUSH
83967: LD_INT 1
83969: NEG
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: LD_INT 2
83981: NEG
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 0
83989: PUSH
83990: LD_INT 2
83992: NEG
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: LD_INT 1
84000: PUSH
84001: LD_INT 1
84003: NEG
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 2
84011: PUSH
84012: LD_INT 1
84014: PUSH
84015: EMPTY
84016: LIST
84017: LIST
84018: PUSH
84019: LD_INT 2
84021: PUSH
84022: LD_INT 2
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 1
84031: PUSH
84032: LD_INT 2
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: LD_INT 1
84041: NEG
84042: PUSH
84043: LD_INT 1
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 2
84052: NEG
84053: PUSH
84054: LD_INT 0
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 2
84063: NEG
84064: PUSH
84065: LD_INT 1
84067: NEG
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: PUSH
84073: LD_INT 2
84075: NEG
84076: PUSH
84077: LD_INT 2
84079: NEG
84080: PUSH
84081: EMPTY
84082: LIST
84083: LIST
84084: PUSH
84085: LD_INT 1
84087: NEG
84088: PUSH
84089: LD_INT 3
84091: NEG
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 1
84099: PUSH
84100: LD_INT 2
84102: NEG
84103: PUSH
84104: EMPTY
84105: LIST
84106: LIST
84107: PUSH
84108: LD_INT 3
84110: PUSH
84111: LD_INT 2
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 2
84120: PUSH
84121: LD_INT 3
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: PUSH
84128: LD_INT 2
84130: NEG
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 3
84141: NEG
84142: PUSH
84143: LD_INT 1
84145: NEG
84146: PUSH
84147: EMPTY
84148: LIST
84149: LIST
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84176: LD_ADDR_VAR 0 35
84180: PUSH
84181: LD_INT 0
84183: PUSH
84184: LD_INT 0
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: LD_INT 1
84196: NEG
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 1
84204: PUSH
84205: LD_INT 0
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 1
84214: PUSH
84215: LD_INT 1
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: PUSH
84222: LD_INT 0
84224: PUSH
84225: LD_INT 1
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 1
84234: NEG
84235: PUSH
84236: LD_INT 0
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: LD_INT 1
84245: NEG
84246: PUSH
84247: LD_INT 1
84249: NEG
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 2
84257: PUSH
84258: LD_INT 1
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: PUSH
84265: LD_INT 2
84267: NEG
84268: PUSH
84269: LD_INT 1
84271: NEG
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84288: LD_ADDR_VAR 0 36
84292: PUSH
84293: LD_INT 0
84295: PUSH
84296: LD_INT 0
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 0
84305: PUSH
84306: LD_INT 1
84308: NEG
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: PUSH
84314: LD_INT 1
84316: PUSH
84317: LD_INT 0
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 1
84326: PUSH
84327: LD_INT 1
84329: PUSH
84330: EMPTY
84331: LIST
84332: LIST
84333: PUSH
84334: LD_INT 0
84336: PUSH
84337: LD_INT 1
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: PUSH
84344: LD_INT 1
84346: NEG
84347: PUSH
84348: LD_INT 0
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: PUSH
84355: LD_INT 1
84357: NEG
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 1
84369: NEG
84370: PUSH
84371: LD_INT 2
84373: NEG
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 1
84381: PUSH
84382: LD_INT 2
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84400: LD_ADDR_VAR 0 37
84404: PUSH
84405: LD_INT 0
84407: PUSH
84408: LD_INT 0
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 0
84417: PUSH
84418: LD_INT 1
84420: NEG
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 1
84428: PUSH
84429: LD_INT 0
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 1
84438: PUSH
84439: LD_INT 1
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 0
84448: PUSH
84449: LD_INT 1
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 1
84458: NEG
84459: PUSH
84460: LD_INT 0
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: PUSH
84467: LD_INT 1
84469: NEG
84470: PUSH
84471: LD_INT 1
84473: NEG
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: LD_INT 1
84481: PUSH
84482: LD_INT 1
84484: NEG
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 1
84492: NEG
84493: PUSH
84494: LD_INT 1
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84512: LD_ADDR_VAR 0 38
84516: PUSH
84517: LD_INT 0
84519: PUSH
84520: LD_INT 0
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 0
84529: PUSH
84530: LD_INT 1
84532: NEG
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 1
84540: PUSH
84541: LD_INT 0
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PUSH
84548: LD_INT 1
84550: PUSH
84551: LD_INT 1
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 0
84560: PUSH
84561: LD_INT 1
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: PUSH
84568: LD_INT 1
84570: NEG
84571: PUSH
84572: LD_INT 0
84574: PUSH
84575: EMPTY
84576: LIST
84577: LIST
84578: PUSH
84579: LD_INT 1
84581: NEG
84582: PUSH
84583: LD_INT 1
84585: NEG
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PUSH
84591: LD_INT 2
84593: PUSH
84594: LD_INT 1
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 2
84603: NEG
84604: PUSH
84605: LD_INT 1
84607: NEG
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84624: LD_ADDR_VAR 0 39
84628: PUSH
84629: LD_INT 0
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 0
84641: PUSH
84642: LD_INT 1
84644: NEG
84645: PUSH
84646: EMPTY
84647: LIST
84648: LIST
84649: PUSH
84650: LD_INT 1
84652: PUSH
84653: LD_INT 0
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: LD_INT 1
84662: PUSH
84663: LD_INT 1
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: PUSH
84670: LD_INT 0
84672: PUSH
84673: LD_INT 1
84675: PUSH
84676: EMPTY
84677: LIST
84678: LIST
84679: PUSH
84680: LD_INT 1
84682: NEG
84683: PUSH
84684: LD_INT 0
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 1
84693: NEG
84694: PUSH
84695: LD_INT 1
84697: NEG
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 1
84705: NEG
84706: PUSH
84707: LD_INT 2
84709: NEG
84710: PUSH
84711: EMPTY
84712: LIST
84713: LIST
84714: PUSH
84715: LD_INT 1
84717: PUSH
84718: LD_INT 2
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84736: LD_ADDR_VAR 0 40
84740: PUSH
84741: LD_INT 0
84743: PUSH
84744: LD_INT 0
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 0
84753: PUSH
84754: LD_INT 1
84756: NEG
84757: PUSH
84758: EMPTY
84759: LIST
84760: LIST
84761: PUSH
84762: LD_INT 1
84764: PUSH
84765: LD_INT 0
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 1
84774: PUSH
84775: LD_INT 1
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 0
84784: PUSH
84785: LD_INT 1
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 1
84794: NEG
84795: PUSH
84796: LD_INT 0
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 1
84805: NEG
84806: PUSH
84807: LD_INT 1
84809: NEG
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 1
84817: PUSH
84818: LD_INT 1
84820: NEG
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 1
84828: NEG
84829: PUSH
84830: LD_INT 1
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84848: LD_ADDR_VAR 0 41
84852: PUSH
84853: LD_INT 0
84855: PUSH
84856: LD_INT 0
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 0
84865: PUSH
84866: LD_INT 1
84868: NEG
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 1
84876: PUSH
84877: LD_INT 0
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 1
84886: PUSH
84887: LD_INT 1
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 0
84896: PUSH
84897: LD_INT 1
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 1
84906: NEG
84907: PUSH
84908: LD_INT 0
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 1
84917: NEG
84918: PUSH
84919: LD_INT 1
84921: NEG
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 1
84929: NEG
84930: PUSH
84931: LD_INT 2
84933: NEG
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: PUSH
84942: LD_INT 1
84944: NEG
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 2
84952: PUSH
84953: LD_INT 0
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 2
84962: PUSH
84963: LD_INT 1
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 2
84972: PUSH
84973: LD_INT 2
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 1
84982: PUSH
84983: LD_INT 2
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 1
84992: NEG
84993: PUSH
84994: LD_INT 1
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 2
85003: NEG
85004: PUSH
85005: LD_INT 0
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 2
85014: NEG
85015: PUSH
85016: LD_INT 1
85018: NEG
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: LD_INT 2
85026: NEG
85027: PUSH
85028: LD_INT 2
85030: NEG
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 2
85038: NEG
85039: PUSH
85040: LD_INT 3
85042: NEG
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 2
85050: PUSH
85051: LD_INT 1
85053: NEG
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 3
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 3
85071: PUSH
85072: LD_INT 1
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 3
85081: PUSH
85082: LD_INT 2
85084: PUSH
85085: EMPTY
85086: LIST
85087: LIST
85088: PUSH
85089: LD_INT 3
85091: PUSH
85092: LD_INT 3
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 2
85101: PUSH
85102: LD_INT 3
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 2
85111: NEG
85112: PUSH
85113: LD_INT 1
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: LD_INT 3
85122: NEG
85123: PUSH
85124: LD_INT 0
85126: PUSH
85127: EMPTY
85128: LIST
85129: LIST
85130: PUSH
85131: LD_INT 3
85133: NEG
85134: PUSH
85135: LD_INT 1
85137: NEG
85138: PUSH
85139: EMPTY
85140: LIST
85141: LIST
85142: PUSH
85143: LD_INT 3
85145: NEG
85146: PUSH
85147: LD_INT 2
85149: NEG
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 3
85157: NEG
85158: PUSH
85159: LD_INT 3
85161: NEG
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: LIST
85171: LIST
85172: LIST
85173: LIST
85174: LIST
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85198: LD_ADDR_VAR 0 42
85202: PUSH
85203: LD_INT 0
85205: PUSH
85206: LD_INT 0
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 0
85215: PUSH
85216: LD_INT 1
85218: NEG
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 1
85226: PUSH
85227: LD_INT 0
85229: PUSH
85230: EMPTY
85231: LIST
85232: LIST
85233: PUSH
85234: LD_INT 1
85236: PUSH
85237: LD_INT 1
85239: PUSH
85240: EMPTY
85241: LIST
85242: LIST
85243: PUSH
85244: LD_INT 0
85246: PUSH
85247: LD_INT 1
85249: PUSH
85250: EMPTY
85251: LIST
85252: LIST
85253: PUSH
85254: LD_INT 1
85256: NEG
85257: PUSH
85258: LD_INT 0
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 1
85267: NEG
85268: PUSH
85269: LD_INT 1
85271: NEG
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_INT 1
85279: NEG
85280: PUSH
85281: LD_INT 2
85283: NEG
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 0
85291: PUSH
85292: LD_INT 2
85294: NEG
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 1
85302: PUSH
85303: LD_INT 1
85305: NEG
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 2
85313: PUSH
85314: LD_INT 1
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 2
85323: PUSH
85324: LD_INT 2
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 1
85333: PUSH
85334: LD_INT 2
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: PUSH
85341: LD_INT 0
85343: PUSH
85344: LD_INT 2
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: LD_INT 1
85353: NEG
85354: PUSH
85355: LD_INT 1
85357: PUSH
85358: EMPTY
85359: LIST
85360: LIST
85361: PUSH
85362: LD_INT 2
85364: NEG
85365: PUSH
85366: LD_INT 1
85368: NEG
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 2
85376: NEG
85377: PUSH
85378: LD_INT 2
85380: NEG
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 2
85388: NEG
85389: PUSH
85390: LD_INT 3
85392: NEG
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 1
85400: NEG
85401: PUSH
85402: LD_INT 3
85404: NEG
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 0
85412: PUSH
85413: LD_INT 3
85415: NEG
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: LD_INT 1
85423: PUSH
85424: LD_INT 2
85426: NEG
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 3
85434: PUSH
85435: LD_INT 2
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 3
85444: PUSH
85445: LD_INT 3
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 2
85454: PUSH
85455: LD_INT 3
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 1
85464: PUSH
85465: LD_INT 3
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 0
85474: PUSH
85475: LD_INT 3
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 1
85484: NEG
85485: PUSH
85486: LD_INT 2
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 3
85495: NEG
85496: PUSH
85497: LD_INT 2
85499: NEG
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 3
85507: NEG
85508: PUSH
85509: LD_INT 3
85511: NEG
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85548: LD_ADDR_VAR 0 43
85552: PUSH
85553: LD_INT 0
85555: PUSH
85556: LD_INT 0
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 0
85565: PUSH
85566: LD_INT 1
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 1
85576: PUSH
85577: LD_INT 0
85579: PUSH
85580: EMPTY
85581: LIST
85582: LIST
85583: PUSH
85584: LD_INT 1
85586: PUSH
85587: LD_INT 1
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PUSH
85594: LD_INT 0
85596: PUSH
85597: LD_INT 1
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 1
85606: NEG
85607: PUSH
85608: LD_INT 0
85610: PUSH
85611: EMPTY
85612: LIST
85613: LIST
85614: PUSH
85615: LD_INT 1
85617: NEG
85618: PUSH
85619: LD_INT 1
85621: NEG
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 1
85629: NEG
85630: PUSH
85631: LD_INT 2
85633: NEG
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 0
85641: PUSH
85642: LD_INT 2
85644: NEG
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 1
85652: PUSH
85653: LD_INT 1
85655: NEG
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PUSH
85661: LD_INT 2
85663: PUSH
85664: LD_INT 0
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 2
85673: PUSH
85674: LD_INT 1
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 1
85683: PUSH
85684: LD_INT 2
85686: PUSH
85687: EMPTY
85688: LIST
85689: LIST
85690: PUSH
85691: LD_INT 0
85693: PUSH
85694: LD_INT 2
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PUSH
85701: LD_INT 1
85703: NEG
85704: PUSH
85705: LD_INT 1
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 2
85714: NEG
85715: PUSH
85716: LD_INT 0
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 2
85725: NEG
85726: PUSH
85727: LD_INT 1
85729: NEG
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 1
85737: NEG
85738: PUSH
85739: LD_INT 3
85741: NEG
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 0
85749: PUSH
85750: LD_INT 3
85752: NEG
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 1
85760: PUSH
85761: LD_INT 2
85763: NEG
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 2
85771: PUSH
85772: LD_INT 1
85774: NEG
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 3
85782: PUSH
85783: LD_INT 0
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 3
85792: PUSH
85793: LD_INT 1
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: PUSH
85803: LD_INT 3
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 0
85812: PUSH
85813: LD_INT 3
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 1
85822: NEG
85823: PUSH
85824: LD_INT 2
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 2
85833: NEG
85834: PUSH
85835: LD_INT 1
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 3
85844: NEG
85845: PUSH
85846: LD_INT 0
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: PUSH
85853: LD_INT 3
85855: NEG
85856: PUSH
85857: LD_INT 1
85859: NEG
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85896: LD_ADDR_VAR 0 44
85900: PUSH
85901: LD_INT 0
85903: PUSH
85904: LD_INT 0
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 0
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: EMPTY
85919: LIST
85920: LIST
85921: PUSH
85922: LD_INT 1
85924: PUSH
85925: LD_INT 0
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 1
85934: PUSH
85935: LD_INT 1
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 0
85944: PUSH
85945: LD_INT 1
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 1
85954: NEG
85955: PUSH
85956: LD_INT 0
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: LD_INT 1
85969: NEG
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 1
85977: NEG
85978: PUSH
85979: LD_INT 2
85981: NEG
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 1
85989: PUSH
85990: LD_INT 1
85992: NEG
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 2
86000: PUSH
86001: LD_INT 0
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: LD_INT 2
86010: PUSH
86011: LD_INT 1
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: PUSH
86018: LD_INT 2
86020: PUSH
86021: LD_INT 2
86023: PUSH
86024: EMPTY
86025: LIST
86026: LIST
86027: PUSH
86028: LD_INT 1
86030: PUSH
86031: LD_INT 2
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 1
86040: NEG
86041: PUSH
86042: LD_INT 1
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 2
86051: NEG
86052: PUSH
86053: LD_INT 0
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 2
86062: NEG
86063: PUSH
86064: LD_INT 1
86066: NEG
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 2
86074: NEG
86075: PUSH
86076: LD_INT 2
86078: NEG
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 2
86086: NEG
86087: PUSH
86088: LD_INT 3
86090: NEG
86091: PUSH
86092: EMPTY
86093: LIST
86094: LIST
86095: PUSH
86096: LD_INT 2
86098: PUSH
86099: LD_INT 1
86101: NEG
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 3
86109: PUSH
86110: LD_INT 0
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 3
86119: PUSH
86120: LD_INT 1
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 3
86129: PUSH
86130: LD_INT 2
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 3
86139: PUSH
86140: LD_INT 3
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 2
86149: PUSH
86150: LD_INT 3
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 2
86159: NEG
86160: PUSH
86161: LD_INT 1
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 3
86170: NEG
86171: PUSH
86172: LD_INT 0
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 3
86181: NEG
86182: PUSH
86183: LD_INT 1
86185: NEG
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: LD_INT 3
86193: NEG
86194: PUSH
86195: LD_INT 2
86197: NEG
86198: PUSH
86199: EMPTY
86200: LIST
86201: LIST
86202: PUSH
86203: LD_INT 3
86205: NEG
86206: PUSH
86207: LD_INT 3
86209: NEG
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86246: LD_ADDR_VAR 0 45
86250: PUSH
86251: LD_INT 0
86253: PUSH
86254: LD_INT 0
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 0
86263: PUSH
86264: LD_INT 1
86266: NEG
86267: PUSH
86268: EMPTY
86269: LIST
86270: LIST
86271: PUSH
86272: LD_INT 1
86274: PUSH
86275: LD_INT 0
86277: PUSH
86278: EMPTY
86279: LIST
86280: LIST
86281: PUSH
86282: LD_INT 1
86284: PUSH
86285: LD_INT 1
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PUSH
86292: LD_INT 0
86294: PUSH
86295: LD_INT 1
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: PUSH
86302: LD_INT 1
86304: NEG
86305: PUSH
86306: LD_INT 0
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: PUSH
86313: LD_INT 1
86315: NEG
86316: PUSH
86317: LD_INT 1
86319: NEG
86320: PUSH
86321: EMPTY
86322: LIST
86323: LIST
86324: PUSH
86325: LD_INT 1
86327: NEG
86328: PUSH
86329: LD_INT 2
86331: NEG
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 0
86339: PUSH
86340: LD_INT 2
86342: NEG
86343: PUSH
86344: EMPTY
86345: LIST
86346: LIST
86347: PUSH
86348: LD_INT 1
86350: PUSH
86351: LD_INT 1
86353: NEG
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 2
86361: PUSH
86362: LD_INT 1
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 2
86371: PUSH
86372: LD_INT 2
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 1
86381: PUSH
86382: LD_INT 2
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: LD_INT 0
86391: PUSH
86392: LD_INT 2
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 1
86401: NEG
86402: PUSH
86403: LD_INT 1
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: LD_INT 2
86412: NEG
86413: PUSH
86414: LD_INT 1
86416: NEG
86417: PUSH
86418: EMPTY
86419: LIST
86420: LIST
86421: PUSH
86422: LD_INT 2
86424: NEG
86425: PUSH
86426: LD_INT 2
86428: NEG
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: PUSH
86434: LD_INT 2
86436: NEG
86437: PUSH
86438: LD_INT 3
86440: NEG
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 1
86448: NEG
86449: PUSH
86450: LD_INT 3
86452: NEG
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 0
86460: PUSH
86461: LD_INT 3
86463: NEG
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: LD_INT 2
86474: NEG
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 3
86482: PUSH
86483: LD_INT 2
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 3
86492: PUSH
86493: LD_INT 3
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 2
86502: PUSH
86503: LD_INT 3
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: PUSH
86513: LD_INT 3
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 0
86522: PUSH
86523: LD_INT 3
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: NEG
86533: PUSH
86534: LD_INT 2
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 3
86543: NEG
86544: PUSH
86545: LD_INT 2
86547: NEG
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 3
86555: NEG
86556: PUSH
86557: LD_INT 3
86559: NEG
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: LIST
86591: LIST
86592: LIST
86593: LIST
86594: LIST
86595: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86596: LD_ADDR_VAR 0 46
86600: PUSH
86601: LD_INT 0
86603: PUSH
86604: LD_INT 0
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: LD_INT 1
86616: NEG
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: PUSH
86622: LD_INT 1
86624: PUSH
86625: LD_INT 0
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: LD_INT 1
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 0
86644: PUSH
86645: LD_INT 1
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 1
86654: NEG
86655: PUSH
86656: LD_INT 0
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: LD_INT 1
86665: NEG
86666: PUSH
86667: LD_INT 1
86669: NEG
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: PUSH
86675: LD_INT 1
86677: NEG
86678: PUSH
86679: LD_INT 2
86681: NEG
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: LD_INT 2
86692: NEG
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 1
86700: PUSH
86701: LD_INT 1
86703: NEG
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 2
86711: PUSH
86712: LD_INT 0
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 2
86721: PUSH
86722: LD_INT 1
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: LD_INT 1
86731: PUSH
86732: LD_INT 2
86734: PUSH
86735: EMPTY
86736: LIST
86737: LIST
86738: PUSH
86739: LD_INT 0
86741: PUSH
86742: LD_INT 2
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: PUSH
86749: LD_INT 1
86751: NEG
86752: PUSH
86753: LD_INT 1
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: PUSH
86760: LD_INT 2
86762: NEG
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 2
86773: NEG
86774: PUSH
86775: LD_INT 1
86777: NEG
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 1
86785: NEG
86786: PUSH
86787: LD_INT 3
86789: NEG
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: LD_INT 3
86800: NEG
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 1
86808: PUSH
86809: LD_INT 2
86811: NEG
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 2
86819: PUSH
86820: LD_INT 1
86822: NEG
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 3
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 3
86840: PUSH
86841: LD_INT 1
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 1
86850: PUSH
86851: LD_INT 3
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 0
86860: PUSH
86861: LD_INT 3
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 1
86870: NEG
86871: PUSH
86872: LD_INT 2
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 2
86881: NEG
86882: PUSH
86883: LD_INT 1
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 3
86892: NEG
86893: PUSH
86894: LD_INT 0
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 3
86903: NEG
86904: PUSH
86905: LD_INT 1
86907: NEG
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86944: LD_ADDR_VAR 0 47
86948: PUSH
86949: LD_INT 0
86951: PUSH
86952: LD_INT 0
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 0
86961: PUSH
86962: LD_INT 1
86964: NEG
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 1
86972: PUSH
86973: LD_INT 0
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 1
86982: PUSH
86983: LD_INT 1
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 0
86992: PUSH
86993: LD_INT 1
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: PUSH
87000: LD_INT 1
87002: NEG
87003: PUSH
87004: LD_INT 0
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 1
87013: NEG
87014: PUSH
87015: LD_INT 1
87017: NEG
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: PUSH
87023: LD_INT 1
87025: NEG
87026: PUSH
87027: LD_INT 2
87029: NEG
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 0
87037: PUSH
87038: LD_INT 2
87040: NEG
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 1
87048: PUSH
87049: LD_INT 1
87051: NEG
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 2
87059: NEG
87060: PUSH
87061: LD_INT 1
87063: NEG
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 2
87071: NEG
87072: PUSH
87073: LD_INT 2
87075: NEG
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87095: LD_ADDR_VAR 0 48
87099: PUSH
87100: LD_INT 0
87102: PUSH
87103: LD_INT 0
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 0
87112: PUSH
87113: LD_INT 1
87115: NEG
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: LD_INT 1
87123: PUSH
87124: LD_INT 0
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 1
87133: PUSH
87134: LD_INT 1
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: PUSH
87141: LD_INT 0
87143: PUSH
87144: LD_INT 1
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 1
87153: NEG
87154: PUSH
87155: LD_INT 0
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 1
87164: NEG
87165: PUSH
87166: LD_INT 1
87168: NEG
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 1
87176: NEG
87177: PUSH
87178: LD_INT 2
87180: NEG
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 0
87188: PUSH
87189: LD_INT 2
87191: NEG
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 1
87199: PUSH
87200: LD_INT 1
87202: NEG
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 2
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 2
87220: PUSH
87221: LD_INT 1
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87242: LD_ADDR_VAR 0 49
87246: PUSH
87247: LD_INT 0
87249: PUSH
87250: LD_INT 0
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 0
87259: PUSH
87260: LD_INT 1
87262: NEG
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PUSH
87268: LD_INT 1
87270: PUSH
87271: LD_INT 0
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 1
87280: PUSH
87281: LD_INT 1
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 0
87290: PUSH
87291: LD_INT 1
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: NEG
87301: PUSH
87302: LD_INT 0
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: PUSH
87309: LD_INT 1
87311: NEG
87312: PUSH
87313: LD_INT 1
87315: NEG
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 1
87323: PUSH
87324: LD_INT 1
87326: NEG
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 2
87334: PUSH
87335: LD_INT 0
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 2
87344: PUSH
87345: LD_INT 1
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 2
87354: PUSH
87355: LD_INT 2
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 1
87364: PUSH
87365: LD_INT 2
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87386: LD_ADDR_VAR 0 50
87390: PUSH
87391: LD_INT 0
87393: PUSH
87394: LD_INT 0
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: LD_INT 1
87406: NEG
87407: PUSH
87408: EMPTY
87409: LIST
87410: LIST
87411: PUSH
87412: LD_INT 1
87414: PUSH
87415: LD_INT 0
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 1
87424: PUSH
87425: LD_INT 1
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: PUSH
87432: LD_INT 0
87434: PUSH
87435: LD_INT 1
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 1
87444: NEG
87445: PUSH
87446: LD_INT 0
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: PUSH
87453: LD_INT 1
87455: NEG
87456: PUSH
87457: LD_INT 1
87459: NEG
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: LD_INT 2
87467: PUSH
87468: LD_INT 1
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: PUSH
87475: LD_INT 2
87477: PUSH
87478: LD_INT 2
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: LD_INT 2
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 0
87497: PUSH
87498: LD_INT 2
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 1
87507: NEG
87508: PUSH
87509: LD_INT 1
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: EMPTY
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87530: LD_ADDR_VAR 0 51
87534: PUSH
87535: LD_INT 0
87537: PUSH
87538: LD_INT 0
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 0
87547: PUSH
87548: LD_INT 1
87550: NEG
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: LD_INT 1
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PUSH
87566: LD_INT 1
87568: PUSH
87569: LD_INT 1
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: PUSH
87576: LD_INT 0
87578: PUSH
87579: LD_INT 1
87581: PUSH
87582: EMPTY
87583: LIST
87584: LIST
87585: PUSH
87586: LD_INT 1
87588: NEG
87589: PUSH
87590: LD_INT 0
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: LD_INT 1
87599: NEG
87600: PUSH
87601: LD_INT 1
87603: NEG
87604: PUSH
87605: EMPTY
87606: LIST
87607: LIST
87608: PUSH
87609: LD_INT 1
87611: PUSH
87612: LD_INT 2
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 0
87621: PUSH
87622: LD_INT 2
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: PUSH
87629: LD_INT 1
87631: NEG
87632: PUSH
87633: LD_INT 1
87635: PUSH
87636: EMPTY
87637: LIST
87638: LIST
87639: PUSH
87640: LD_INT 2
87642: NEG
87643: PUSH
87644: LD_INT 0
87646: PUSH
87647: EMPTY
87648: LIST
87649: LIST
87650: PUSH
87651: LD_INT 2
87653: NEG
87654: PUSH
87655: LD_INT 1
87657: NEG
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87677: LD_ADDR_VAR 0 52
87681: PUSH
87682: LD_INT 0
87684: PUSH
87685: LD_INT 0
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: LD_INT 1
87697: NEG
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: PUSH
87703: LD_INT 1
87705: PUSH
87706: LD_INT 0
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: PUSH
87713: LD_INT 1
87715: PUSH
87716: LD_INT 1
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: LD_INT 0
87725: PUSH
87726: LD_INT 1
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: PUSH
87733: LD_INT 1
87735: NEG
87736: PUSH
87737: LD_INT 0
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: LD_INT 1
87746: NEG
87747: PUSH
87748: LD_INT 1
87750: NEG
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 1
87758: NEG
87759: PUSH
87760: LD_INT 2
87762: NEG
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 1
87770: NEG
87771: PUSH
87772: LD_INT 1
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 2
87781: NEG
87782: PUSH
87783: LD_INT 0
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 2
87792: NEG
87793: PUSH
87794: LD_INT 1
87796: NEG
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: NEG
87805: PUSH
87806: LD_INT 2
87808: NEG
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87828: LD_ADDR_VAR 0 53
87832: PUSH
87833: LD_INT 0
87835: PUSH
87836: LD_INT 0
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 0
87845: PUSH
87846: LD_INT 1
87848: NEG
87849: PUSH
87850: EMPTY
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 1
87856: PUSH
87857: LD_INT 0
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 1
87866: PUSH
87867: LD_INT 1
87869: PUSH
87870: EMPTY
87871: LIST
87872: LIST
87873: PUSH
87874: LD_INT 0
87876: PUSH
87877: LD_INT 1
87879: PUSH
87880: EMPTY
87881: LIST
87882: LIST
87883: PUSH
87884: LD_INT 1
87886: NEG
87887: PUSH
87888: LD_INT 0
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: PUSH
87895: LD_INT 1
87897: NEG
87898: PUSH
87899: LD_INT 1
87901: NEG
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 1
87909: NEG
87910: PUSH
87911: LD_INT 2
87913: NEG
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 0
87921: PUSH
87922: LD_INT 2
87924: NEG
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 1
87932: PUSH
87933: LD_INT 1
87935: NEG
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 2
87943: PUSH
87944: LD_INT 0
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 2
87953: PUSH
87954: LD_INT 1
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 2
87963: PUSH
87964: LD_INT 2
87966: PUSH
87967: EMPTY
87968: LIST
87969: LIST
87970: PUSH
87971: LD_INT 1
87973: PUSH
87974: LD_INT 2
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 0
87983: PUSH
87984: LD_INT 2
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: PUSH
87991: LD_INT 1
87993: NEG
87994: PUSH
87995: LD_INT 1
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 2
88004: NEG
88005: PUSH
88006: LD_INT 0
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 2
88015: NEG
88016: PUSH
88017: LD_INT 1
88019: NEG
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 2
88027: NEG
88028: PUSH
88029: LD_INT 2
88031: NEG
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88058: LD_ADDR_VAR 0 54
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: LD_INT 0
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: LD_INT 1
88078: NEG
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 1
88086: PUSH
88087: LD_INT 0
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 1
88096: PUSH
88097: LD_INT 1
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 0
88106: PUSH
88107: LD_INT 1
88109: PUSH
88110: EMPTY
88111: LIST
88112: LIST
88113: PUSH
88114: LD_INT 1
88116: NEG
88117: PUSH
88118: LD_INT 0
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 1
88127: NEG
88128: PUSH
88129: LD_INT 1
88131: NEG
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PUSH
88137: LD_INT 1
88139: NEG
88140: PUSH
88141: LD_INT 2
88143: NEG
88144: PUSH
88145: EMPTY
88146: LIST
88147: LIST
88148: PUSH
88149: LD_INT 0
88151: PUSH
88152: LD_INT 2
88154: NEG
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 1
88162: PUSH
88163: LD_INT 1
88165: NEG
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 2
88173: PUSH
88174: LD_INT 0
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: PUSH
88181: LD_INT 2
88183: PUSH
88184: LD_INT 1
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 2
88193: PUSH
88194: LD_INT 2
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: LD_INT 1
88203: PUSH
88204: LD_INT 2
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 0
88213: PUSH
88214: LD_INT 2
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: LD_INT 1
88227: PUSH
88228: EMPTY
88229: LIST
88230: LIST
88231: PUSH
88232: LD_INT 2
88234: NEG
88235: PUSH
88236: LD_INT 0
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: PUSH
88243: LD_INT 2
88245: NEG
88246: PUSH
88247: LD_INT 1
88249: NEG
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: LD_INT 2
88257: NEG
88258: PUSH
88259: LD_INT 2
88261: NEG
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88288: LD_ADDR_VAR 0 55
88292: PUSH
88293: LD_INT 0
88295: PUSH
88296: LD_INT 0
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: LD_INT 1
88308: NEG
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: PUSH
88314: LD_INT 1
88316: PUSH
88317: LD_INT 0
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 1
88326: PUSH
88327: LD_INT 1
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 0
88336: PUSH
88337: LD_INT 1
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 1
88346: NEG
88347: PUSH
88348: LD_INT 0
88350: PUSH
88351: EMPTY
88352: LIST
88353: LIST
88354: PUSH
88355: LD_INT 1
88357: NEG
88358: PUSH
88359: LD_INT 1
88361: NEG
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 1
88369: NEG
88370: PUSH
88371: LD_INT 2
88373: NEG
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: LD_INT 0
88381: PUSH
88382: LD_INT 2
88384: NEG
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 1
88392: PUSH
88393: LD_INT 1
88395: NEG
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 2
88403: PUSH
88404: LD_INT 0
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 2
88413: PUSH
88414: LD_INT 1
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 2
88423: PUSH
88424: LD_INT 2
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 1
88433: PUSH
88434: LD_INT 2
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 0
88443: PUSH
88444: LD_INT 2
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 1
88453: NEG
88454: PUSH
88455: LD_INT 1
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 2
88464: NEG
88465: PUSH
88466: LD_INT 0
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 2
88475: NEG
88476: PUSH
88477: LD_INT 1
88479: NEG
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 2
88487: NEG
88488: PUSH
88489: LD_INT 2
88491: NEG
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88518: LD_ADDR_VAR 0 56
88522: PUSH
88523: LD_INT 0
88525: PUSH
88526: LD_INT 0
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: LD_INT 1
88538: NEG
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: PUSH
88544: LD_INT 1
88546: PUSH
88547: LD_INT 0
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PUSH
88554: LD_INT 1
88556: PUSH
88557: LD_INT 1
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: LD_INT 0
88566: PUSH
88567: LD_INT 1
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 1
88576: NEG
88577: PUSH
88578: LD_INT 0
88580: PUSH
88581: EMPTY
88582: LIST
88583: LIST
88584: PUSH
88585: LD_INT 1
88587: NEG
88588: PUSH
88589: LD_INT 1
88591: NEG
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 1
88599: NEG
88600: PUSH
88601: LD_INT 2
88603: NEG
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 0
88611: PUSH
88612: LD_INT 2
88614: NEG
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 1
88622: PUSH
88623: LD_INT 1
88625: NEG
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 2
88633: PUSH
88634: LD_INT 0
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 2
88643: PUSH
88644: LD_INT 1
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 2
88653: PUSH
88654: LD_INT 2
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 1
88663: PUSH
88664: LD_INT 2
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 0
88673: PUSH
88674: LD_INT 2
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 1
88683: NEG
88684: PUSH
88685: LD_INT 1
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: LD_INT 2
88694: NEG
88695: PUSH
88696: LD_INT 0
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 2
88705: NEG
88706: PUSH
88707: LD_INT 1
88709: NEG
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: PUSH
88715: LD_INT 2
88717: NEG
88718: PUSH
88719: LD_INT 2
88721: NEG
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88748: LD_ADDR_VAR 0 57
88752: PUSH
88753: LD_INT 0
88755: PUSH
88756: LD_INT 0
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 0
88765: PUSH
88766: LD_INT 1
88768: NEG
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 1
88776: PUSH
88777: LD_INT 0
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: LD_INT 1
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 0
88796: PUSH
88797: LD_INT 1
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 1
88806: NEG
88807: PUSH
88808: LD_INT 0
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 1
88817: NEG
88818: PUSH
88819: LD_INT 1
88821: NEG
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 1
88829: NEG
88830: PUSH
88831: LD_INT 2
88833: NEG
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: LD_INT 0
88841: PUSH
88842: LD_INT 2
88844: NEG
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 1
88852: PUSH
88853: LD_INT 1
88855: NEG
88856: PUSH
88857: EMPTY
88858: LIST
88859: LIST
88860: PUSH
88861: LD_INT 2
88863: PUSH
88864: LD_INT 0
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PUSH
88871: LD_INT 2
88873: PUSH
88874: LD_INT 1
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 2
88883: PUSH
88884: LD_INT 2
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 1
88893: PUSH
88894: LD_INT 2
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 0
88903: PUSH
88904: LD_INT 2
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 1
88913: NEG
88914: PUSH
88915: LD_INT 1
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: PUSH
88922: LD_INT 2
88924: NEG
88925: PUSH
88926: LD_INT 0
88928: PUSH
88929: EMPTY
88930: LIST
88931: LIST
88932: PUSH
88933: LD_INT 2
88935: NEG
88936: PUSH
88937: LD_INT 1
88939: NEG
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: LD_INT 2
88947: NEG
88948: PUSH
88949: LD_INT 2
88951: NEG
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88978: LD_ADDR_VAR 0 58
88982: PUSH
88983: LD_INT 0
88985: PUSH
88986: LD_INT 0
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 0
88995: PUSH
88996: LD_INT 1
88998: NEG
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: PUSH
89004: LD_INT 1
89006: PUSH
89007: LD_INT 0
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 1
89016: PUSH
89017: LD_INT 1
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 0
89026: PUSH
89027: LD_INT 1
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 1
89036: NEG
89037: PUSH
89038: LD_INT 0
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: PUSH
89045: LD_INT 1
89047: NEG
89048: PUSH
89049: LD_INT 1
89051: NEG
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 1
89059: NEG
89060: PUSH
89061: LD_INT 2
89063: NEG
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 0
89071: PUSH
89072: LD_INT 2
89074: NEG
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: LD_INT 1
89082: PUSH
89083: LD_INT 1
89085: NEG
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 2
89093: PUSH
89094: LD_INT 0
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 2
89103: PUSH
89104: LD_INT 1
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 2
89113: PUSH
89114: LD_INT 2
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: LD_INT 1
89123: PUSH
89124: LD_INT 2
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 0
89133: PUSH
89134: LD_INT 2
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 1
89143: NEG
89144: PUSH
89145: LD_INT 1
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 2
89154: NEG
89155: PUSH
89156: LD_INT 0
89158: PUSH
89159: EMPTY
89160: LIST
89161: LIST
89162: PUSH
89163: LD_INT 2
89165: NEG
89166: PUSH
89167: LD_INT 1
89169: NEG
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 2
89177: NEG
89178: PUSH
89179: LD_INT 2
89181: NEG
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89208: LD_ADDR_VAR 0 59
89212: PUSH
89213: LD_INT 0
89215: PUSH
89216: LD_INT 0
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 0
89225: PUSH
89226: LD_INT 1
89228: NEG
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 1
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 1
89246: PUSH
89247: LD_INT 1
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 0
89256: PUSH
89257: LD_INT 1
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 1
89266: NEG
89267: PUSH
89268: LD_INT 0
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: PUSH
89275: LD_INT 1
89277: NEG
89278: PUSH
89279: LD_INT 1
89281: NEG
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: EMPTY
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89296: LD_ADDR_VAR 0 60
89300: PUSH
89301: LD_INT 0
89303: PUSH
89304: LD_INT 0
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 0
89313: PUSH
89314: LD_INT 1
89316: NEG
89317: PUSH
89318: EMPTY
89319: LIST
89320: LIST
89321: PUSH
89322: LD_INT 1
89324: PUSH
89325: LD_INT 0
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: PUSH
89332: LD_INT 1
89334: PUSH
89335: LD_INT 1
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: PUSH
89342: LD_INT 0
89344: PUSH
89345: LD_INT 1
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: PUSH
89352: LD_INT 1
89354: NEG
89355: PUSH
89356: LD_INT 0
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: NEG
89366: PUSH
89367: LD_INT 1
89369: NEG
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: LIST
89382: LIST
89383: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89384: LD_ADDR_VAR 0 61
89388: PUSH
89389: LD_INT 0
89391: PUSH
89392: LD_INT 0
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: LD_INT 0
89401: PUSH
89402: LD_INT 1
89404: NEG
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: LD_INT 1
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 1
89422: PUSH
89423: LD_INT 1
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 0
89432: PUSH
89433: LD_INT 1
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: PUSH
89440: LD_INT 1
89442: NEG
89443: PUSH
89444: LD_INT 0
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 1
89453: NEG
89454: PUSH
89455: LD_INT 1
89457: NEG
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89472: LD_ADDR_VAR 0 62
89476: PUSH
89477: LD_INT 0
89479: PUSH
89480: LD_INT 0
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 0
89489: PUSH
89490: LD_INT 1
89492: NEG
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 1
89500: PUSH
89501: LD_INT 0
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: PUSH
89508: LD_INT 1
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 0
89520: PUSH
89521: LD_INT 1
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PUSH
89528: LD_INT 1
89530: NEG
89531: PUSH
89532: LD_INT 0
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: LD_INT 1
89541: NEG
89542: PUSH
89543: LD_INT 1
89545: NEG
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89560: LD_ADDR_VAR 0 63
89564: PUSH
89565: LD_INT 0
89567: PUSH
89568: LD_INT 0
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 0
89577: PUSH
89578: LD_INT 1
89580: NEG
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 1
89588: PUSH
89589: LD_INT 0
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 1
89598: PUSH
89599: LD_INT 1
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 0
89608: PUSH
89609: LD_INT 1
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 1
89618: NEG
89619: PUSH
89620: LD_INT 0
89622: PUSH
89623: EMPTY
89624: LIST
89625: LIST
89626: PUSH
89627: LD_INT 1
89629: NEG
89630: PUSH
89631: LD_INT 1
89633: NEG
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89648: LD_ADDR_VAR 0 64
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: LD_INT 0
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 0
89665: PUSH
89666: LD_INT 1
89668: NEG
89669: PUSH
89670: EMPTY
89671: LIST
89672: LIST
89673: PUSH
89674: LD_INT 1
89676: PUSH
89677: LD_INT 0
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: PUSH
89684: LD_INT 1
89686: PUSH
89687: LD_INT 1
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: PUSH
89694: LD_INT 0
89696: PUSH
89697: LD_INT 1
89699: PUSH
89700: EMPTY
89701: LIST
89702: LIST
89703: PUSH
89704: LD_INT 1
89706: NEG
89707: PUSH
89708: LD_INT 0
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: PUSH
89715: LD_INT 1
89717: NEG
89718: PUSH
89719: LD_INT 1
89721: NEG
89722: PUSH
89723: EMPTY
89724: LIST
89725: LIST
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: ST_TO_ADDR
// end ; 1 :
89736: GO 95633
89738: LD_INT 1
89740: DOUBLE
89741: EQUAL
89742: IFTRUE 89746
89744: GO 92369
89746: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89747: LD_ADDR_VAR 0 11
89751: PUSH
89752: LD_INT 1
89754: NEG
89755: PUSH
89756: LD_INT 3
89758: NEG
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 0
89766: PUSH
89767: LD_INT 3
89769: NEG
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 1
89777: PUSH
89778: LD_INT 2
89780: NEG
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: LIST
89790: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89791: LD_ADDR_VAR 0 12
89795: PUSH
89796: LD_INT 2
89798: PUSH
89799: LD_INT 1
89801: NEG
89802: PUSH
89803: EMPTY
89804: LIST
89805: LIST
89806: PUSH
89807: LD_INT 3
89809: PUSH
89810: LD_INT 0
89812: PUSH
89813: EMPTY
89814: LIST
89815: LIST
89816: PUSH
89817: LD_INT 3
89819: PUSH
89820: LD_INT 1
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: LIST
89831: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89832: LD_ADDR_VAR 0 13
89836: PUSH
89837: LD_INT 3
89839: PUSH
89840: LD_INT 2
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 3
89849: PUSH
89850: LD_INT 3
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 2
89859: PUSH
89860: LD_INT 3
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: EMPTY
89868: LIST
89869: LIST
89870: LIST
89871: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89872: LD_ADDR_VAR 0 14
89876: PUSH
89877: LD_INT 1
89879: PUSH
89880: LD_INT 3
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 0
89889: PUSH
89890: LD_INT 3
89892: PUSH
89893: EMPTY
89894: LIST
89895: LIST
89896: PUSH
89897: LD_INT 1
89899: NEG
89900: PUSH
89901: LD_INT 2
89903: PUSH
89904: EMPTY
89905: LIST
89906: LIST
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: LIST
89912: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89913: LD_ADDR_VAR 0 15
89917: PUSH
89918: LD_INT 2
89920: NEG
89921: PUSH
89922: LD_INT 1
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 3
89931: NEG
89932: PUSH
89933: LD_INT 0
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 3
89942: NEG
89943: PUSH
89944: LD_INT 1
89946: NEG
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: LIST
89956: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89957: LD_ADDR_VAR 0 16
89961: PUSH
89962: LD_INT 2
89964: NEG
89965: PUSH
89966: LD_INT 3
89968: NEG
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 3
89976: NEG
89977: PUSH
89978: LD_INT 2
89980: NEG
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 3
89988: NEG
89989: PUSH
89990: LD_INT 3
89992: NEG
89993: PUSH
89994: EMPTY
89995: LIST
89996: LIST
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: LIST
90002: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90003: LD_ADDR_VAR 0 17
90007: PUSH
90008: LD_INT 1
90010: NEG
90011: PUSH
90012: LD_INT 3
90014: NEG
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 0
90022: PUSH
90023: LD_INT 3
90025: NEG
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 1
90033: PUSH
90034: LD_INT 2
90036: NEG
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: LIST
90046: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90047: LD_ADDR_VAR 0 18
90051: PUSH
90052: LD_INT 2
90054: PUSH
90055: LD_INT 1
90057: NEG
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PUSH
90063: LD_INT 3
90065: PUSH
90066: LD_INT 0
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: PUSH
90073: LD_INT 3
90075: PUSH
90076: LD_INT 1
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: EMPTY
90084: LIST
90085: LIST
90086: LIST
90087: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90088: LD_ADDR_VAR 0 19
90092: PUSH
90093: LD_INT 3
90095: PUSH
90096: LD_INT 2
90098: PUSH
90099: EMPTY
90100: LIST
90101: LIST
90102: PUSH
90103: LD_INT 3
90105: PUSH
90106: LD_INT 3
90108: PUSH
90109: EMPTY
90110: LIST
90111: LIST
90112: PUSH
90113: LD_INT 2
90115: PUSH
90116: LD_INT 3
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: LIST
90127: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90128: LD_ADDR_VAR 0 20
90132: PUSH
90133: LD_INT 1
90135: PUSH
90136: LD_INT 3
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 0
90145: PUSH
90146: LD_INT 3
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 1
90155: NEG
90156: PUSH
90157: LD_INT 2
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: LIST
90168: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90169: LD_ADDR_VAR 0 21
90173: PUSH
90174: LD_INT 2
90176: NEG
90177: PUSH
90178: LD_INT 1
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: PUSH
90185: LD_INT 3
90187: NEG
90188: PUSH
90189: LD_INT 0
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 3
90198: NEG
90199: PUSH
90200: LD_INT 1
90202: NEG
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: LIST
90212: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90213: LD_ADDR_VAR 0 22
90217: PUSH
90218: LD_INT 2
90220: NEG
90221: PUSH
90222: LD_INT 3
90224: NEG
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PUSH
90230: LD_INT 3
90232: NEG
90233: PUSH
90234: LD_INT 2
90236: NEG
90237: PUSH
90238: EMPTY
90239: LIST
90240: LIST
90241: PUSH
90242: LD_INT 3
90244: NEG
90245: PUSH
90246: LD_INT 3
90248: NEG
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: LIST
90258: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90259: LD_ADDR_VAR 0 23
90263: PUSH
90264: LD_INT 0
90266: PUSH
90267: LD_INT 3
90269: NEG
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: LD_INT 1
90277: NEG
90278: PUSH
90279: LD_INT 4
90281: NEG
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: LD_INT 1
90289: PUSH
90290: LD_INT 3
90292: NEG
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: LIST
90302: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90303: LD_ADDR_VAR 0 24
90307: PUSH
90308: LD_INT 3
90310: PUSH
90311: LD_INT 0
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 3
90320: PUSH
90321: LD_INT 1
90323: NEG
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: PUSH
90329: LD_INT 4
90331: PUSH
90332: LD_INT 1
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: LIST
90343: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90344: LD_ADDR_VAR 0 25
90348: PUSH
90349: LD_INT 3
90351: PUSH
90352: LD_INT 3
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 4
90361: PUSH
90362: LD_INT 3
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: PUSH
90369: LD_INT 3
90371: PUSH
90372: LD_INT 4
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: LIST
90383: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90384: LD_ADDR_VAR 0 26
90388: PUSH
90389: LD_INT 0
90391: PUSH
90392: LD_INT 3
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 1
90401: PUSH
90402: LD_INT 4
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: PUSH
90409: LD_INT 1
90411: NEG
90412: PUSH
90413: LD_INT 3
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: LIST
90424: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90425: LD_ADDR_VAR 0 27
90429: PUSH
90430: LD_INT 3
90432: NEG
90433: PUSH
90434: LD_INT 0
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 3
90443: NEG
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 4
90454: NEG
90455: PUSH
90456: LD_INT 1
90458: NEG
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: PUSH
90464: EMPTY
90465: LIST
90466: LIST
90467: LIST
90468: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90469: LD_ADDR_VAR 0 28
90473: PUSH
90474: LD_INT 3
90476: NEG
90477: PUSH
90478: LD_INT 3
90480: NEG
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: PUSH
90486: LD_INT 3
90488: NEG
90489: PUSH
90490: LD_INT 4
90492: NEG
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 4
90500: NEG
90501: PUSH
90502: LD_INT 3
90504: NEG
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: LIST
90514: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90515: LD_ADDR_VAR 0 29
90519: PUSH
90520: LD_INT 1
90522: NEG
90523: PUSH
90524: LD_INT 3
90526: NEG
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 0
90534: PUSH
90535: LD_INT 3
90537: NEG
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 1
90545: PUSH
90546: LD_INT 2
90548: NEG
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 1
90556: NEG
90557: PUSH
90558: LD_INT 4
90560: NEG
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PUSH
90566: LD_INT 0
90568: PUSH
90569: LD_INT 4
90571: NEG
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 1
90579: PUSH
90580: LD_INT 3
90582: NEG
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 1
90590: NEG
90591: PUSH
90592: LD_INT 5
90594: NEG
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: LD_INT 0
90602: PUSH
90603: LD_INT 5
90605: NEG
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 1
90613: PUSH
90614: LD_INT 4
90616: NEG
90617: PUSH
90618: EMPTY
90619: LIST
90620: LIST
90621: PUSH
90622: LD_INT 1
90624: NEG
90625: PUSH
90626: LD_INT 6
90628: NEG
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 0
90636: PUSH
90637: LD_INT 6
90639: NEG
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PUSH
90645: LD_INT 1
90647: PUSH
90648: LD_INT 5
90650: NEG
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90670: LD_ADDR_VAR 0 30
90674: PUSH
90675: LD_INT 2
90677: PUSH
90678: LD_INT 1
90680: NEG
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 3
90688: PUSH
90689: LD_INT 0
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: LD_INT 3
90698: PUSH
90699: LD_INT 1
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 3
90708: PUSH
90709: LD_INT 1
90711: NEG
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 4
90719: PUSH
90720: LD_INT 0
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 4
90729: PUSH
90730: LD_INT 1
90732: PUSH
90733: EMPTY
90734: LIST
90735: LIST
90736: PUSH
90737: LD_INT 4
90739: PUSH
90740: LD_INT 1
90742: NEG
90743: PUSH
90744: EMPTY
90745: LIST
90746: LIST
90747: PUSH
90748: LD_INT 5
90750: PUSH
90751: LD_INT 0
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 5
90760: PUSH
90761: LD_INT 1
90763: PUSH
90764: EMPTY
90765: LIST
90766: LIST
90767: PUSH
90768: LD_INT 5
90770: PUSH
90771: LD_INT 1
90773: NEG
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 6
90781: PUSH
90782: LD_INT 0
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 6
90791: PUSH
90792: LD_INT 1
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90813: LD_ADDR_VAR 0 31
90817: PUSH
90818: LD_INT 3
90820: PUSH
90821: LD_INT 2
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: LD_INT 3
90830: PUSH
90831: LD_INT 3
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: PUSH
90838: LD_INT 2
90840: PUSH
90841: LD_INT 3
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 4
90850: PUSH
90851: LD_INT 3
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: LD_INT 4
90860: PUSH
90861: LD_INT 4
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: PUSH
90868: LD_INT 3
90870: PUSH
90871: LD_INT 4
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: LD_INT 5
90880: PUSH
90881: LD_INT 4
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PUSH
90888: LD_INT 5
90890: PUSH
90891: LD_INT 5
90893: PUSH
90894: EMPTY
90895: LIST
90896: LIST
90897: PUSH
90898: LD_INT 4
90900: PUSH
90901: LD_INT 5
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: PUSH
90908: LD_INT 6
90910: PUSH
90911: LD_INT 5
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: LD_INT 6
90920: PUSH
90921: LD_INT 6
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 5
90930: PUSH
90931: LD_INT 6
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: LIST
90949: LIST
90950: LIST
90951: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90952: LD_ADDR_VAR 0 32
90956: PUSH
90957: LD_INT 1
90959: PUSH
90960: LD_INT 3
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 0
90969: PUSH
90970: LD_INT 3
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 1
90979: NEG
90980: PUSH
90981: LD_INT 2
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 1
90990: PUSH
90991: LD_INT 4
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 0
91000: PUSH
91001: LD_INT 4
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 1
91010: NEG
91011: PUSH
91012: LD_INT 3
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 1
91021: PUSH
91022: LD_INT 5
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 0
91031: PUSH
91032: LD_INT 5
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 1
91041: NEG
91042: PUSH
91043: LD_INT 4
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: PUSH
91050: LD_INT 1
91052: PUSH
91053: LD_INT 6
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: LD_INT 0
91062: PUSH
91063: LD_INT 6
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 1
91072: NEG
91073: PUSH
91074: LD_INT 5
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91095: LD_ADDR_VAR 0 33
91099: PUSH
91100: LD_INT 2
91102: NEG
91103: PUSH
91104: LD_INT 1
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 3
91113: NEG
91114: PUSH
91115: LD_INT 0
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 3
91124: NEG
91125: PUSH
91126: LD_INT 1
91128: NEG
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: LD_INT 3
91136: NEG
91137: PUSH
91138: LD_INT 1
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 4
91147: NEG
91148: PUSH
91149: LD_INT 0
91151: PUSH
91152: EMPTY
91153: LIST
91154: LIST
91155: PUSH
91156: LD_INT 4
91158: NEG
91159: PUSH
91160: LD_INT 1
91162: NEG
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: PUSH
91168: LD_INT 4
91170: NEG
91171: PUSH
91172: LD_INT 1
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: LD_INT 5
91181: NEG
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 5
91192: NEG
91193: PUSH
91194: LD_INT 1
91196: NEG
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: LD_INT 5
91204: NEG
91205: PUSH
91206: LD_INT 1
91208: PUSH
91209: EMPTY
91210: LIST
91211: LIST
91212: PUSH
91213: LD_INT 6
91215: NEG
91216: PUSH
91217: LD_INT 0
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PUSH
91224: LD_INT 6
91226: NEG
91227: PUSH
91228: LD_INT 1
91230: NEG
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91250: LD_ADDR_VAR 0 34
91254: PUSH
91255: LD_INT 2
91257: NEG
91258: PUSH
91259: LD_INT 3
91261: NEG
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 3
91269: NEG
91270: PUSH
91271: LD_INT 2
91273: NEG
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: PUSH
91279: LD_INT 3
91281: NEG
91282: PUSH
91283: LD_INT 3
91285: NEG
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 3
91293: NEG
91294: PUSH
91295: LD_INT 4
91297: NEG
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 4
91305: NEG
91306: PUSH
91307: LD_INT 3
91309: NEG
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 4
91317: NEG
91318: PUSH
91319: LD_INT 4
91321: NEG
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 4
91329: NEG
91330: PUSH
91331: LD_INT 5
91333: NEG
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 5
91341: NEG
91342: PUSH
91343: LD_INT 4
91345: NEG
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 5
91353: NEG
91354: PUSH
91355: LD_INT 5
91357: NEG
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: LD_INT 5
91365: NEG
91366: PUSH
91367: LD_INT 6
91369: NEG
91370: PUSH
91371: EMPTY
91372: LIST
91373: LIST
91374: PUSH
91375: LD_INT 6
91377: NEG
91378: PUSH
91379: LD_INT 5
91381: NEG
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 6
91389: NEG
91390: PUSH
91391: LD_INT 6
91393: NEG
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91413: LD_ADDR_VAR 0 41
91417: PUSH
91418: LD_INT 0
91420: PUSH
91421: LD_INT 2
91423: NEG
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 1
91431: NEG
91432: PUSH
91433: LD_INT 3
91435: NEG
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: PUSH
91441: LD_INT 1
91443: PUSH
91444: LD_INT 2
91446: NEG
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: LIST
91456: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91457: LD_ADDR_VAR 0 42
91461: PUSH
91462: LD_INT 2
91464: PUSH
91465: LD_INT 0
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 2
91474: PUSH
91475: LD_INT 1
91477: NEG
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 3
91485: PUSH
91486: LD_INT 1
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: LIST
91497: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91498: LD_ADDR_VAR 0 43
91502: PUSH
91503: LD_INT 2
91505: PUSH
91506: LD_INT 2
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 3
91515: PUSH
91516: LD_INT 2
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 2
91525: PUSH
91526: LD_INT 3
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: LIST
91537: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91538: LD_ADDR_VAR 0 44
91542: PUSH
91543: LD_INT 0
91545: PUSH
91546: LD_INT 2
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 1
91555: PUSH
91556: LD_INT 3
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: PUSH
91563: LD_INT 1
91565: NEG
91566: PUSH
91567: LD_INT 2
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: LIST
91578: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91579: LD_ADDR_VAR 0 45
91583: PUSH
91584: LD_INT 2
91586: NEG
91587: PUSH
91588: LD_INT 0
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: PUSH
91595: LD_INT 2
91597: NEG
91598: PUSH
91599: LD_INT 1
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: PUSH
91606: LD_INT 3
91608: NEG
91609: PUSH
91610: LD_INT 1
91612: NEG
91613: PUSH
91614: EMPTY
91615: LIST
91616: LIST
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: LIST
91622: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91623: LD_ADDR_VAR 0 46
91627: PUSH
91628: LD_INT 2
91630: NEG
91631: PUSH
91632: LD_INT 2
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 2
91642: NEG
91643: PUSH
91644: LD_INT 3
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 3
91654: NEG
91655: PUSH
91656: LD_INT 2
91658: NEG
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: LIST
91668: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91669: LD_ADDR_VAR 0 47
91673: PUSH
91674: LD_INT 2
91676: NEG
91677: PUSH
91678: LD_INT 3
91680: NEG
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: LD_INT 1
91688: NEG
91689: PUSH
91690: LD_INT 3
91692: NEG
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91702: LD_ADDR_VAR 0 48
91706: PUSH
91707: LD_INT 1
91709: PUSH
91710: LD_INT 2
91712: NEG
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: PUSH
91718: LD_INT 2
91720: PUSH
91721: LD_INT 1
91723: NEG
91724: PUSH
91725: EMPTY
91726: LIST
91727: LIST
91728: PUSH
91729: EMPTY
91730: LIST
91731: LIST
91732: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91733: LD_ADDR_VAR 0 49
91737: PUSH
91738: LD_INT 3
91740: PUSH
91741: LD_INT 1
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: PUSH
91748: LD_INT 3
91750: PUSH
91751: LD_INT 2
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91762: LD_ADDR_VAR 0 50
91766: PUSH
91767: LD_INT 2
91769: PUSH
91770: LD_INT 3
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 1
91779: PUSH
91780: LD_INT 3
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91791: LD_ADDR_VAR 0 51
91795: PUSH
91796: LD_INT 1
91798: NEG
91799: PUSH
91800: LD_INT 2
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 2
91809: NEG
91810: PUSH
91811: LD_INT 1
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91822: LD_ADDR_VAR 0 52
91826: PUSH
91827: LD_INT 3
91829: NEG
91830: PUSH
91831: LD_INT 1
91833: NEG
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PUSH
91839: LD_INT 3
91841: NEG
91842: PUSH
91843: LD_INT 2
91845: NEG
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91855: LD_ADDR_VAR 0 53
91859: PUSH
91860: LD_INT 1
91862: NEG
91863: PUSH
91864: LD_INT 3
91866: NEG
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 0
91874: PUSH
91875: LD_INT 3
91877: NEG
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 1
91885: PUSH
91886: LD_INT 2
91888: NEG
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: LIST
91898: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91899: LD_ADDR_VAR 0 54
91903: PUSH
91904: LD_INT 2
91906: PUSH
91907: LD_INT 1
91909: NEG
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: PUSH
91915: LD_INT 3
91917: PUSH
91918: LD_INT 0
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PUSH
91925: LD_INT 3
91927: PUSH
91928: LD_INT 1
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: LIST
91939: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91940: LD_ADDR_VAR 0 55
91944: PUSH
91945: LD_INT 3
91947: PUSH
91948: LD_INT 2
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: PUSH
91955: LD_INT 3
91957: PUSH
91958: LD_INT 3
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: PUSH
91965: LD_INT 2
91967: PUSH
91968: LD_INT 3
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: EMPTY
91976: LIST
91977: LIST
91978: LIST
91979: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91980: LD_ADDR_VAR 0 56
91984: PUSH
91985: LD_INT 1
91987: PUSH
91988: LD_INT 3
91990: PUSH
91991: EMPTY
91992: LIST
91993: LIST
91994: PUSH
91995: LD_INT 0
91997: PUSH
91998: LD_INT 3
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 1
92007: NEG
92008: PUSH
92009: LD_INT 2
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: LIST
92020: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92021: LD_ADDR_VAR 0 57
92025: PUSH
92026: LD_INT 2
92028: NEG
92029: PUSH
92030: LD_INT 1
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 3
92039: NEG
92040: PUSH
92041: LD_INT 0
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: LD_INT 3
92050: NEG
92051: PUSH
92052: LD_INT 1
92054: NEG
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: LIST
92064: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92065: LD_ADDR_VAR 0 58
92069: PUSH
92070: LD_INT 2
92072: NEG
92073: PUSH
92074: LD_INT 3
92076: NEG
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: PUSH
92082: LD_INT 3
92084: NEG
92085: PUSH
92086: LD_INT 2
92088: NEG
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 3
92096: NEG
92097: PUSH
92098: LD_INT 3
92100: NEG
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: LIST
92110: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92111: LD_ADDR_VAR 0 59
92115: PUSH
92116: LD_INT 1
92118: NEG
92119: PUSH
92120: LD_INT 2
92122: NEG
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 0
92130: PUSH
92131: LD_INT 2
92133: NEG
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 1
92141: PUSH
92142: LD_INT 1
92144: NEG
92145: PUSH
92146: EMPTY
92147: LIST
92148: LIST
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: LIST
92154: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92155: LD_ADDR_VAR 0 60
92159: PUSH
92160: LD_INT 1
92162: PUSH
92163: LD_INT 1
92165: NEG
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: PUSH
92171: LD_INT 2
92173: PUSH
92174: LD_INT 0
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 2
92183: PUSH
92184: LD_INT 1
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: LIST
92195: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92196: LD_ADDR_VAR 0 61
92200: PUSH
92201: LD_INT 2
92203: PUSH
92204: LD_INT 1
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 2
92213: PUSH
92214: LD_INT 2
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: PUSH
92221: LD_INT 1
92223: PUSH
92224: LD_INT 2
92226: PUSH
92227: EMPTY
92228: LIST
92229: LIST
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: LIST
92235: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92236: LD_ADDR_VAR 0 62
92240: PUSH
92241: LD_INT 1
92243: PUSH
92244: LD_INT 2
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: LD_INT 0
92253: PUSH
92254: LD_INT 2
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PUSH
92261: LD_INT 1
92263: NEG
92264: PUSH
92265: LD_INT 1
92267: PUSH
92268: EMPTY
92269: LIST
92270: LIST
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: LIST
92276: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92277: LD_ADDR_VAR 0 63
92281: PUSH
92282: LD_INT 1
92284: NEG
92285: PUSH
92286: LD_INT 1
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: PUSH
92293: LD_INT 2
92295: NEG
92296: PUSH
92297: LD_INT 0
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 2
92306: NEG
92307: PUSH
92308: LD_INT 1
92310: NEG
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: LIST
92320: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92321: LD_ADDR_VAR 0 64
92325: PUSH
92326: LD_INT 1
92328: NEG
92329: PUSH
92330: LD_INT 2
92332: NEG
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: PUSH
92338: LD_INT 2
92340: NEG
92341: PUSH
92342: LD_INT 1
92344: NEG
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: LD_INT 2
92352: NEG
92353: PUSH
92354: LD_INT 2
92356: NEG
92357: PUSH
92358: EMPTY
92359: LIST
92360: LIST
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: LIST
92366: ST_TO_ADDR
// end ; 2 :
92367: GO 95633
92369: LD_INT 2
92371: DOUBLE
92372: EQUAL
92373: IFTRUE 92377
92375: GO 95632
92377: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92378: LD_ADDR_VAR 0 29
92382: PUSH
92383: LD_INT 4
92385: PUSH
92386: LD_INT 0
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: PUSH
92393: LD_INT 4
92395: PUSH
92396: LD_INT 1
92398: NEG
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 5
92406: PUSH
92407: LD_INT 0
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: PUSH
92414: LD_INT 5
92416: PUSH
92417: LD_INT 1
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 4
92426: PUSH
92427: LD_INT 1
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: PUSH
92434: LD_INT 3
92436: PUSH
92437: LD_INT 0
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 3
92446: PUSH
92447: LD_INT 1
92449: NEG
92450: PUSH
92451: EMPTY
92452: LIST
92453: LIST
92454: PUSH
92455: LD_INT 3
92457: PUSH
92458: LD_INT 2
92460: NEG
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: PUSH
92466: LD_INT 5
92468: PUSH
92469: LD_INT 2
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PUSH
92476: LD_INT 3
92478: PUSH
92479: LD_INT 3
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 3
92488: PUSH
92489: LD_INT 2
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 4
92498: PUSH
92499: LD_INT 3
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: PUSH
92506: LD_INT 4
92508: PUSH
92509: LD_INT 4
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 3
92518: PUSH
92519: LD_INT 4
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: LD_INT 2
92528: PUSH
92529: LD_INT 3
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 2
92538: PUSH
92539: LD_INT 2
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: PUSH
92546: LD_INT 4
92548: PUSH
92549: LD_INT 2
92551: PUSH
92552: EMPTY
92553: LIST
92554: LIST
92555: PUSH
92556: LD_INT 2
92558: PUSH
92559: LD_INT 4
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: PUSH
92566: LD_INT 0
92568: PUSH
92569: LD_INT 4
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 0
92578: PUSH
92579: LD_INT 3
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: PUSH
92586: LD_INT 1
92588: PUSH
92589: LD_INT 4
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: LD_INT 1
92598: PUSH
92599: LD_INT 5
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 0
92608: PUSH
92609: LD_INT 5
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: LD_INT 1
92618: NEG
92619: PUSH
92620: LD_INT 4
92622: PUSH
92623: EMPTY
92624: LIST
92625: LIST
92626: PUSH
92627: LD_INT 1
92629: NEG
92630: PUSH
92631: LD_INT 3
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: PUSH
92638: LD_INT 2
92640: PUSH
92641: LD_INT 5
92643: PUSH
92644: EMPTY
92645: LIST
92646: LIST
92647: PUSH
92648: LD_INT 2
92650: NEG
92651: PUSH
92652: LD_INT 3
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: LD_INT 3
92661: NEG
92662: PUSH
92663: LD_INT 0
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 3
92672: NEG
92673: PUSH
92674: LD_INT 1
92676: NEG
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 2
92684: NEG
92685: PUSH
92686: LD_INT 0
92688: PUSH
92689: EMPTY
92690: LIST
92691: LIST
92692: PUSH
92693: LD_INT 2
92695: NEG
92696: PUSH
92697: LD_INT 1
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: PUSH
92704: LD_INT 3
92706: NEG
92707: PUSH
92708: LD_INT 1
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 4
92717: NEG
92718: PUSH
92719: LD_INT 0
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PUSH
92726: LD_INT 4
92728: NEG
92729: PUSH
92730: LD_INT 1
92732: NEG
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PUSH
92738: LD_INT 4
92740: NEG
92741: PUSH
92742: LD_INT 2
92744: NEG
92745: PUSH
92746: EMPTY
92747: LIST
92748: LIST
92749: PUSH
92750: LD_INT 2
92752: NEG
92753: PUSH
92754: LD_INT 2
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: PUSH
92761: LD_INT 4
92763: NEG
92764: PUSH
92765: LD_INT 4
92767: NEG
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: PUSH
92773: LD_INT 4
92775: NEG
92776: PUSH
92777: LD_INT 5
92779: NEG
92780: PUSH
92781: EMPTY
92782: LIST
92783: LIST
92784: PUSH
92785: LD_INT 3
92787: NEG
92788: PUSH
92789: LD_INT 4
92791: NEG
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: LD_INT 3
92799: NEG
92800: PUSH
92801: LD_INT 3
92803: NEG
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: LD_INT 4
92811: NEG
92812: PUSH
92813: LD_INT 3
92815: NEG
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 5
92823: NEG
92824: PUSH
92825: LD_INT 4
92827: NEG
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: PUSH
92833: LD_INT 5
92835: NEG
92836: PUSH
92837: LD_INT 5
92839: NEG
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 3
92847: NEG
92848: PUSH
92849: LD_INT 5
92851: NEG
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 5
92859: NEG
92860: PUSH
92861: LD_INT 3
92863: NEG
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92916: LD_ADDR_VAR 0 30
92920: PUSH
92921: LD_INT 4
92923: PUSH
92924: LD_INT 4
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 4
92933: PUSH
92934: LD_INT 3
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 5
92943: PUSH
92944: LD_INT 4
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 5
92953: PUSH
92954: LD_INT 5
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: PUSH
92961: LD_INT 4
92963: PUSH
92964: LD_INT 5
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: PUSH
92971: LD_INT 3
92973: PUSH
92974: LD_INT 4
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: PUSH
92981: LD_INT 3
92983: PUSH
92984: LD_INT 3
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PUSH
92991: LD_INT 5
92993: PUSH
92994: LD_INT 3
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 3
93003: PUSH
93004: LD_INT 5
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 0
93013: PUSH
93014: LD_INT 3
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 0
93023: PUSH
93024: LD_INT 2
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 1
93033: PUSH
93034: LD_INT 3
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 1
93043: PUSH
93044: LD_INT 4
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 0
93053: PUSH
93054: LD_INT 4
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 1
93063: NEG
93064: PUSH
93065: LD_INT 3
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 1
93074: NEG
93075: PUSH
93076: LD_INT 2
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 2
93085: PUSH
93086: LD_INT 4
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PUSH
93093: LD_INT 2
93095: NEG
93096: PUSH
93097: LD_INT 2
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: LD_INT 4
93106: NEG
93107: PUSH
93108: LD_INT 0
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: LD_INT 4
93117: NEG
93118: PUSH
93119: LD_INT 1
93121: NEG
93122: PUSH
93123: EMPTY
93124: LIST
93125: LIST
93126: PUSH
93127: LD_INT 3
93129: NEG
93130: PUSH
93131: LD_INT 0
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 3
93140: NEG
93141: PUSH
93142: LD_INT 1
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: LD_INT 4
93151: NEG
93152: PUSH
93153: LD_INT 1
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 5
93162: NEG
93163: PUSH
93164: LD_INT 0
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 5
93173: NEG
93174: PUSH
93175: LD_INT 1
93177: NEG
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: PUSH
93183: LD_INT 5
93185: NEG
93186: PUSH
93187: LD_INT 2
93189: NEG
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: LD_INT 3
93197: NEG
93198: PUSH
93199: LD_INT 2
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 3
93208: NEG
93209: PUSH
93210: LD_INT 3
93212: NEG
93213: PUSH
93214: EMPTY
93215: LIST
93216: LIST
93217: PUSH
93218: LD_INT 3
93220: NEG
93221: PUSH
93222: LD_INT 4
93224: NEG
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PUSH
93230: LD_INT 2
93232: NEG
93233: PUSH
93234: LD_INT 3
93236: NEG
93237: PUSH
93238: EMPTY
93239: LIST
93240: LIST
93241: PUSH
93242: LD_INT 2
93244: NEG
93245: PUSH
93246: LD_INT 2
93248: NEG
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: PUSH
93254: LD_INT 3
93256: NEG
93257: PUSH
93258: LD_INT 2
93260: NEG
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: PUSH
93266: LD_INT 4
93268: NEG
93269: PUSH
93270: LD_INT 3
93272: NEG
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: PUSH
93278: LD_INT 4
93280: NEG
93281: PUSH
93282: LD_INT 4
93284: NEG
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 2
93292: NEG
93293: PUSH
93294: LD_INT 4
93296: NEG
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 4
93304: NEG
93305: PUSH
93306: LD_INT 2
93308: NEG
93309: PUSH
93310: EMPTY
93311: LIST
93312: LIST
93313: PUSH
93314: LD_INT 0
93316: PUSH
93317: LD_INT 4
93319: NEG
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PUSH
93325: LD_INT 0
93327: PUSH
93328: LD_INT 5
93330: NEG
93331: PUSH
93332: EMPTY
93333: LIST
93334: LIST
93335: PUSH
93336: LD_INT 1
93338: PUSH
93339: LD_INT 4
93341: NEG
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 1
93349: PUSH
93350: LD_INT 3
93352: NEG
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 0
93360: PUSH
93361: LD_INT 3
93363: NEG
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: PUSH
93369: LD_INT 1
93371: NEG
93372: PUSH
93373: LD_INT 4
93375: NEG
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 1
93383: NEG
93384: PUSH
93385: LD_INT 5
93387: NEG
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 2
93395: PUSH
93396: LD_INT 3
93398: NEG
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 2
93406: NEG
93407: PUSH
93408: LD_INT 5
93410: NEG
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93463: LD_ADDR_VAR 0 31
93467: PUSH
93468: LD_INT 0
93470: PUSH
93471: LD_INT 4
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: PUSH
93478: LD_INT 0
93480: PUSH
93481: LD_INT 3
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 1
93490: PUSH
93491: LD_INT 4
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PUSH
93498: LD_INT 1
93500: PUSH
93501: LD_INT 5
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: LD_INT 0
93510: PUSH
93511: LD_INT 5
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: LD_INT 1
93520: NEG
93521: PUSH
93522: LD_INT 4
93524: PUSH
93525: EMPTY
93526: LIST
93527: LIST
93528: PUSH
93529: LD_INT 1
93531: NEG
93532: PUSH
93533: LD_INT 3
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 2
93542: PUSH
93543: LD_INT 5
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PUSH
93550: LD_INT 2
93552: NEG
93553: PUSH
93554: LD_INT 3
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: LD_INT 3
93563: NEG
93564: PUSH
93565: LD_INT 0
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: PUSH
93572: LD_INT 3
93574: NEG
93575: PUSH
93576: LD_INT 1
93578: NEG
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: PUSH
93584: LD_INT 2
93586: NEG
93587: PUSH
93588: LD_INT 0
93590: PUSH
93591: EMPTY
93592: LIST
93593: LIST
93594: PUSH
93595: LD_INT 2
93597: NEG
93598: PUSH
93599: LD_INT 1
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: PUSH
93606: LD_INT 3
93608: NEG
93609: PUSH
93610: LD_INT 1
93612: PUSH
93613: EMPTY
93614: LIST
93615: LIST
93616: PUSH
93617: LD_INT 4
93619: NEG
93620: PUSH
93621: LD_INT 0
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: PUSH
93628: LD_INT 4
93630: NEG
93631: PUSH
93632: LD_INT 1
93634: NEG
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PUSH
93640: LD_INT 4
93642: NEG
93643: PUSH
93644: LD_INT 2
93646: NEG
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: PUSH
93652: LD_INT 2
93654: NEG
93655: PUSH
93656: LD_INT 2
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 4
93665: NEG
93666: PUSH
93667: LD_INT 4
93669: NEG
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: LD_INT 4
93677: NEG
93678: PUSH
93679: LD_INT 5
93681: NEG
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: PUSH
93687: LD_INT 3
93689: NEG
93690: PUSH
93691: LD_INT 4
93693: NEG
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: PUSH
93699: LD_INT 3
93701: NEG
93702: PUSH
93703: LD_INT 3
93705: NEG
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 4
93713: NEG
93714: PUSH
93715: LD_INT 3
93717: NEG
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: LD_INT 5
93725: NEG
93726: PUSH
93727: LD_INT 4
93729: NEG
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: PUSH
93735: LD_INT 5
93737: NEG
93738: PUSH
93739: LD_INT 5
93741: NEG
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 3
93749: NEG
93750: PUSH
93751: LD_INT 5
93753: NEG
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PUSH
93759: LD_INT 5
93761: NEG
93762: PUSH
93763: LD_INT 3
93765: NEG
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: PUSH
93771: LD_INT 0
93773: PUSH
93774: LD_INT 3
93776: NEG
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: PUSH
93782: LD_INT 0
93784: PUSH
93785: LD_INT 4
93787: NEG
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 1
93795: PUSH
93796: LD_INT 3
93798: NEG
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 1
93806: PUSH
93807: LD_INT 2
93809: NEG
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 0
93817: PUSH
93818: LD_INT 2
93820: NEG
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PUSH
93826: LD_INT 1
93828: NEG
93829: PUSH
93830: LD_INT 3
93832: NEG
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: PUSH
93838: LD_INT 1
93840: NEG
93841: PUSH
93842: LD_INT 4
93844: NEG
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 2
93852: PUSH
93853: LD_INT 2
93855: NEG
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: PUSH
93861: LD_INT 2
93863: NEG
93864: PUSH
93865: LD_INT 4
93867: NEG
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 4
93875: PUSH
93876: LD_INT 0
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 4
93885: PUSH
93886: LD_INT 1
93888: NEG
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PUSH
93894: LD_INT 5
93896: PUSH
93897: LD_INT 0
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 5
93906: PUSH
93907: LD_INT 1
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PUSH
93914: LD_INT 4
93916: PUSH
93917: LD_INT 1
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: PUSH
93924: LD_INT 3
93926: PUSH
93927: LD_INT 0
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: PUSH
93934: LD_INT 3
93936: PUSH
93937: LD_INT 1
93939: NEG
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: PUSH
93945: LD_INT 3
93947: PUSH
93948: LD_INT 2
93950: NEG
93951: PUSH
93952: EMPTY
93953: LIST
93954: LIST
93955: PUSH
93956: LD_INT 5
93958: PUSH
93959: LD_INT 2
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: EMPTY
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94013: LD_ADDR_VAR 0 32
94017: PUSH
94018: LD_INT 4
94020: NEG
94021: PUSH
94022: LD_INT 0
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 4
94031: NEG
94032: PUSH
94033: LD_INT 1
94035: NEG
94036: PUSH
94037: EMPTY
94038: LIST
94039: LIST
94040: PUSH
94041: LD_INT 3
94043: NEG
94044: PUSH
94045: LD_INT 0
94047: PUSH
94048: EMPTY
94049: LIST
94050: LIST
94051: PUSH
94052: LD_INT 3
94054: NEG
94055: PUSH
94056: LD_INT 1
94058: PUSH
94059: EMPTY
94060: LIST
94061: LIST
94062: PUSH
94063: LD_INT 4
94065: NEG
94066: PUSH
94067: LD_INT 1
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 5
94076: NEG
94077: PUSH
94078: LD_INT 0
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: PUSH
94085: LD_INT 5
94087: NEG
94088: PUSH
94089: LD_INT 1
94091: NEG
94092: PUSH
94093: EMPTY
94094: LIST
94095: LIST
94096: PUSH
94097: LD_INT 5
94099: NEG
94100: PUSH
94101: LD_INT 2
94103: NEG
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PUSH
94109: LD_INT 3
94111: NEG
94112: PUSH
94113: LD_INT 2
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: PUSH
94120: LD_INT 3
94122: NEG
94123: PUSH
94124: LD_INT 3
94126: NEG
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: LD_INT 3
94134: NEG
94135: PUSH
94136: LD_INT 4
94138: NEG
94139: PUSH
94140: EMPTY
94141: LIST
94142: LIST
94143: PUSH
94144: LD_INT 2
94146: NEG
94147: PUSH
94148: LD_INT 3
94150: NEG
94151: PUSH
94152: EMPTY
94153: LIST
94154: LIST
94155: PUSH
94156: LD_INT 2
94158: NEG
94159: PUSH
94160: LD_INT 2
94162: NEG
94163: PUSH
94164: EMPTY
94165: LIST
94166: LIST
94167: PUSH
94168: LD_INT 3
94170: NEG
94171: PUSH
94172: LD_INT 2
94174: NEG
94175: PUSH
94176: EMPTY
94177: LIST
94178: LIST
94179: PUSH
94180: LD_INT 4
94182: NEG
94183: PUSH
94184: LD_INT 3
94186: NEG
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: PUSH
94192: LD_INT 4
94194: NEG
94195: PUSH
94196: LD_INT 4
94198: NEG
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: PUSH
94204: LD_INT 2
94206: NEG
94207: PUSH
94208: LD_INT 4
94210: NEG
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: PUSH
94216: LD_INT 4
94218: NEG
94219: PUSH
94220: LD_INT 2
94222: NEG
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 0
94230: PUSH
94231: LD_INT 4
94233: NEG
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 0
94241: PUSH
94242: LD_INT 5
94244: NEG
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: PUSH
94250: LD_INT 1
94252: PUSH
94253: LD_INT 4
94255: NEG
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: PUSH
94261: LD_INT 1
94263: PUSH
94264: LD_INT 3
94266: NEG
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: PUSH
94272: LD_INT 0
94274: PUSH
94275: LD_INT 3
94277: NEG
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 1
94285: NEG
94286: PUSH
94287: LD_INT 4
94289: NEG
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 1
94297: NEG
94298: PUSH
94299: LD_INT 5
94301: NEG
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: PUSH
94307: LD_INT 2
94309: PUSH
94310: LD_INT 3
94312: NEG
94313: PUSH
94314: EMPTY
94315: LIST
94316: LIST
94317: PUSH
94318: LD_INT 2
94320: NEG
94321: PUSH
94322: LD_INT 5
94324: NEG
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 3
94332: PUSH
94333: LD_INT 0
94335: PUSH
94336: EMPTY
94337: LIST
94338: LIST
94339: PUSH
94340: LD_INT 3
94342: PUSH
94343: LD_INT 1
94345: NEG
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: LD_INT 4
94353: PUSH
94354: LD_INT 0
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: PUSH
94361: LD_INT 4
94363: PUSH
94364: LD_INT 1
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: PUSH
94371: LD_INT 3
94373: PUSH
94374: LD_INT 1
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: PUSH
94381: LD_INT 2
94383: PUSH
94384: LD_INT 0
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 2
94393: PUSH
94394: LD_INT 1
94396: NEG
94397: PUSH
94398: EMPTY
94399: LIST
94400: LIST
94401: PUSH
94402: LD_INT 2
94404: PUSH
94405: LD_INT 2
94407: NEG
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 4
94415: PUSH
94416: LD_INT 2
94418: PUSH
94419: EMPTY
94420: LIST
94421: LIST
94422: PUSH
94423: LD_INT 4
94425: PUSH
94426: LD_INT 4
94428: PUSH
94429: EMPTY
94430: LIST
94431: LIST
94432: PUSH
94433: LD_INT 4
94435: PUSH
94436: LD_INT 3
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 5
94445: PUSH
94446: LD_INT 4
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 5
94455: PUSH
94456: LD_INT 5
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 4
94465: PUSH
94466: LD_INT 5
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 3
94475: PUSH
94476: LD_INT 4
94478: PUSH
94479: EMPTY
94480: LIST
94481: LIST
94482: PUSH
94483: LD_INT 3
94485: PUSH
94486: LD_INT 3
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 5
94495: PUSH
94496: LD_INT 3
94498: PUSH
94499: EMPTY
94500: LIST
94501: LIST
94502: PUSH
94503: LD_INT 3
94505: PUSH
94506: LD_INT 5
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94560: LD_ADDR_VAR 0 33
94564: PUSH
94565: LD_INT 4
94567: NEG
94568: PUSH
94569: LD_INT 4
94571: NEG
94572: PUSH
94573: EMPTY
94574: LIST
94575: LIST
94576: PUSH
94577: LD_INT 4
94579: NEG
94580: PUSH
94581: LD_INT 5
94583: NEG
94584: PUSH
94585: EMPTY
94586: LIST
94587: LIST
94588: PUSH
94589: LD_INT 3
94591: NEG
94592: PUSH
94593: LD_INT 4
94595: NEG
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 3
94603: NEG
94604: PUSH
94605: LD_INT 3
94607: NEG
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 4
94615: NEG
94616: PUSH
94617: LD_INT 3
94619: NEG
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: PUSH
94625: LD_INT 5
94627: NEG
94628: PUSH
94629: LD_INT 4
94631: NEG
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 5
94639: NEG
94640: PUSH
94641: LD_INT 5
94643: NEG
94644: PUSH
94645: EMPTY
94646: LIST
94647: LIST
94648: PUSH
94649: LD_INT 3
94651: NEG
94652: PUSH
94653: LD_INT 5
94655: NEG
94656: PUSH
94657: EMPTY
94658: LIST
94659: LIST
94660: PUSH
94661: LD_INT 5
94663: NEG
94664: PUSH
94665: LD_INT 3
94667: NEG
94668: PUSH
94669: EMPTY
94670: LIST
94671: LIST
94672: PUSH
94673: LD_INT 0
94675: PUSH
94676: LD_INT 3
94678: NEG
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 0
94686: PUSH
94687: LD_INT 4
94689: NEG
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: PUSH
94695: LD_INT 1
94697: PUSH
94698: LD_INT 3
94700: NEG
94701: PUSH
94702: EMPTY
94703: LIST
94704: LIST
94705: PUSH
94706: LD_INT 1
94708: PUSH
94709: LD_INT 2
94711: NEG
94712: PUSH
94713: EMPTY
94714: LIST
94715: LIST
94716: PUSH
94717: LD_INT 0
94719: PUSH
94720: LD_INT 2
94722: NEG
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 1
94730: NEG
94731: PUSH
94732: LD_INT 3
94734: NEG
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 1
94742: NEG
94743: PUSH
94744: LD_INT 4
94746: NEG
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 2
94754: PUSH
94755: LD_INT 2
94757: NEG
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 2
94765: NEG
94766: PUSH
94767: LD_INT 4
94769: NEG
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 4
94777: PUSH
94778: LD_INT 0
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: PUSH
94785: LD_INT 4
94787: PUSH
94788: LD_INT 1
94790: NEG
94791: PUSH
94792: EMPTY
94793: LIST
94794: LIST
94795: PUSH
94796: LD_INT 5
94798: PUSH
94799: LD_INT 0
94801: PUSH
94802: EMPTY
94803: LIST
94804: LIST
94805: PUSH
94806: LD_INT 5
94808: PUSH
94809: LD_INT 1
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 4
94818: PUSH
94819: LD_INT 1
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: PUSH
94826: LD_INT 3
94828: PUSH
94829: LD_INT 0
94831: PUSH
94832: EMPTY
94833: LIST
94834: LIST
94835: PUSH
94836: LD_INT 3
94838: PUSH
94839: LD_INT 1
94841: NEG
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 3
94849: PUSH
94850: LD_INT 2
94852: NEG
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 5
94860: PUSH
94861: LD_INT 2
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: PUSH
94868: LD_INT 3
94870: PUSH
94871: LD_INT 3
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: PUSH
94878: LD_INT 3
94880: PUSH
94881: LD_INT 2
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: PUSH
94888: LD_INT 4
94890: PUSH
94891: LD_INT 3
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PUSH
94898: LD_INT 4
94900: PUSH
94901: LD_INT 4
94903: PUSH
94904: EMPTY
94905: LIST
94906: LIST
94907: PUSH
94908: LD_INT 3
94910: PUSH
94911: LD_INT 4
94913: PUSH
94914: EMPTY
94915: LIST
94916: LIST
94917: PUSH
94918: LD_INT 2
94920: PUSH
94921: LD_INT 3
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: PUSH
94928: LD_INT 2
94930: PUSH
94931: LD_INT 2
94933: PUSH
94934: EMPTY
94935: LIST
94936: LIST
94937: PUSH
94938: LD_INT 4
94940: PUSH
94941: LD_INT 2
94943: PUSH
94944: EMPTY
94945: LIST
94946: LIST
94947: PUSH
94948: LD_INT 2
94950: PUSH
94951: LD_INT 4
94953: PUSH
94954: EMPTY
94955: LIST
94956: LIST
94957: PUSH
94958: LD_INT 0
94960: PUSH
94961: LD_INT 4
94963: PUSH
94964: EMPTY
94965: LIST
94966: LIST
94967: PUSH
94968: LD_INT 0
94970: PUSH
94971: LD_INT 3
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: LD_INT 1
94980: PUSH
94981: LD_INT 4
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 1
94990: PUSH
94991: LD_INT 5
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PUSH
94998: LD_INT 0
95000: PUSH
95001: LD_INT 5
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 1
95010: NEG
95011: PUSH
95012: LD_INT 4
95014: PUSH
95015: EMPTY
95016: LIST
95017: LIST
95018: PUSH
95019: LD_INT 1
95021: NEG
95022: PUSH
95023: LD_INT 3
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PUSH
95030: LD_INT 2
95032: PUSH
95033: LD_INT 5
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: PUSH
95040: LD_INT 2
95042: NEG
95043: PUSH
95044: LD_INT 3
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: PUSH
95051: EMPTY
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95098: LD_ADDR_VAR 0 34
95102: PUSH
95103: LD_INT 0
95105: PUSH
95106: LD_INT 4
95108: NEG
95109: PUSH
95110: EMPTY
95111: LIST
95112: LIST
95113: PUSH
95114: LD_INT 0
95116: PUSH
95117: LD_INT 5
95119: NEG
95120: PUSH
95121: EMPTY
95122: LIST
95123: LIST
95124: PUSH
95125: LD_INT 1
95127: PUSH
95128: LD_INT 4
95130: NEG
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 1
95138: PUSH
95139: LD_INT 3
95141: NEG
95142: PUSH
95143: EMPTY
95144: LIST
95145: LIST
95146: PUSH
95147: LD_INT 0
95149: PUSH
95150: LD_INT 3
95152: NEG
95153: PUSH
95154: EMPTY
95155: LIST
95156: LIST
95157: PUSH
95158: LD_INT 1
95160: NEG
95161: PUSH
95162: LD_INT 4
95164: NEG
95165: PUSH
95166: EMPTY
95167: LIST
95168: LIST
95169: PUSH
95170: LD_INT 1
95172: NEG
95173: PUSH
95174: LD_INT 5
95176: NEG
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 2
95184: PUSH
95185: LD_INT 3
95187: NEG
95188: PUSH
95189: EMPTY
95190: LIST
95191: LIST
95192: PUSH
95193: LD_INT 2
95195: NEG
95196: PUSH
95197: LD_INT 5
95199: NEG
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 3
95207: PUSH
95208: LD_INT 0
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 3
95217: PUSH
95218: LD_INT 1
95220: NEG
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: PUSH
95226: LD_INT 4
95228: PUSH
95229: LD_INT 0
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: PUSH
95236: LD_INT 4
95238: PUSH
95239: LD_INT 1
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: PUSH
95246: LD_INT 3
95248: PUSH
95249: LD_INT 1
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PUSH
95256: LD_INT 2
95258: PUSH
95259: LD_INT 0
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: PUSH
95266: LD_INT 2
95268: PUSH
95269: LD_INT 1
95271: NEG
95272: PUSH
95273: EMPTY
95274: LIST
95275: LIST
95276: PUSH
95277: LD_INT 2
95279: PUSH
95280: LD_INT 2
95282: NEG
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 4
95290: PUSH
95291: LD_INT 2
95293: PUSH
95294: EMPTY
95295: LIST
95296: LIST
95297: PUSH
95298: LD_INT 4
95300: PUSH
95301: LD_INT 4
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: PUSH
95308: LD_INT 4
95310: PUSH
95311: LD_INT 3
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: PUSH
95318: LD_INT 5
95320: PUSH
95321: LD_INT 4
95323: PUSH
95324: EMPTY
95325: LIST
95326: LIST
95327: PUSH
95328: LD_INT 5
95330: PUSH
95331: LD_INT 5
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: LD_INT 4
95340: PUSH
95341: LD_INT 5
95343: PUSH
95344: EMPTY
95345: LIST
95346: LIST
95347: PUSH
95348: LD_INT 3
95350: PUSH
95351: LD_INT 4
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 3
95360: PUSH
95361: LD_INT 3
95363: PUSH
95364: EMPTY
95365: LIST
95366: LIST
95367: PUSH
95368: LD_INT 5
95370: PUSH
95371: LD_INT 3
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: PUSH
95378: LD_INT 3
95380: PUSH
95381: LD_INT 5
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 0
95390: PUSH
95391: LD_INT 3
95393: PUSH
95394: EMPTY
95395: LIST
95396: LIST
95397: PUSH
95398: LD_INT 0
95400: PUSH
95401: LD_INT 2
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: LD_INT 1
95410: PUSH
95411: LD_INT 3
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 1
95420: PUSH
95421: LD_INT 4
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 0
95430: PUSH
95431: LD_INT 4
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 1
95440: NEG
95441: PUSH
95442: LD_INT 3
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: LD_INT 1
95451: NEG
95452: PUSH
95453: LD_INT 2
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: PUSH
95460: LD_INT 2
95462: PUSH
95463: LD_INT 4
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PUSH
95470: LD_INT 2
95472: NEG
95473: PUSH
95474: LD_INT 2
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 4
95483: NEG
95484: PUSH
95485: LD_INT 0
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: LD_INT 4
95494: NEG
95495: PUSH
95496: LD_INT 1
95498: NEG
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: PUSH
95504: LD_INT 3
95506: NEG
95507: PUSH
95508: LD_INT 0
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: PUSH
95515: LD_INT 3
95517: NEG
95518: PUSH
95519: LD_INT 1
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: PUSH
95526: LD_INT 4
95528: NEG
95529: PUSH
95530: LD_INT 1
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PUSH
95537: LD_INT 5
95539: NEG
95540: PUSH
95541: LD_INT 0
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 5
95550: NEG
95551: PUSH
95552: LD_INT 1
95554: NEG
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: PUSH
95560: LD_INT 5
95562: NEG
95563: PUSH
95564: LD_INT 2
95566: NEG
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 3
95574: NEG
95575: PUSH
95576: LD_INT 2
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: EMPTY
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: ST_TO_ADDR
// end ; end ;
95630: GO 95633
95632: POP
// case btype of b_depot , b_warehouse :
95633: LD_VAR 0 1
95637: PUSH
95638: LD_INT 0
95640: DOUBLE
95641: EQUAL
95642: IFTRUE 95652
95644: LD_INT 1
95646: DOUBLE
95647: EQUAL
95648: IFTRUE 95652
95650: GO 95853
95652: POP
// case nation of nation_american :
95653: LD_VAR 0 5
95657: PUSH
95658: LD_INT 1
95660: DOUBLE
95661: EQUAL
95662: IFTRUE 95666
95664: GO 95722
95666: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95667: LD_ADDR_VAR 0 9
95671: PUSH
95672: LD_VAR 0 11
95676: PUSH
95677: LD_VAR 0 12
95681: PUSH
95682: LD_VAR 0 13
95686: PUSH
95687: LD_VAR 0 14
95691: PUSH
95692: LD_VAR 0 15
95696: PUSH
95697: LD_VAR 0 16
95701: PUSH
95702: EMPTY
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: PUSH
95710: LD_VAR 0 4
95714: PUSH
95715: LD_INT 1
95717: PLUS
95718: ARRAY
95719: ST_TO_ADDR
95720: GO 95851
95722: LD_INT 2
95724: DOUBLE
95725: EQUAL
95726: IFTRUE 95730
95728: GO 95786
95730: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
95731: LD_ADDR_VAR 0 9
95735: PUSH
95736: LD_VAR 0 17
95740: PUSH
95741: LD_VAR 0 18
95745: PUSH
95746: LD_VAR 0 19
95750: PUSH
95751: LD_VAR 0 20
95755: PUSH
95756: LD_VAR 0 21
95760: PUSH
95761: LD_VAR 0 22
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: PUSH
95774: LD_VAR 0 4
95778: PUSH
95779: LD_INT 1
95781: PLUS
95782: ARRAY
95783: ST_TO_ADDR
95784: GO 95851
95786: LD_INT 3
95788: DOUBLE
95789: EQUAL
95790: IFTRUE 95794
95792: GO 95850
95794: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95795: LD_ADDR_VAR 0 9
95799: PUSH
95800: LD_VAR 0 23
95804: PUSH
95805: LD_VAR 0 24
95809: PUSH
95810: LD_VAR 0 25
95814: PUSH
95815: LD_VAR 0 26
95819: PUSH
95820: LD_VAR 0 27
95824: PUSH
95825: LD_VAR 0 28
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: PUSH
95838: LD_VAR 0 4
95842: PUSH
95843: LD_INT 1
95845: PLUS
95846: ARRAY
95847: ST_TO_ADDR
95848: GO 95851
95850: POP
95851: GO 96406
95853: LD_INT 2
95855: DOUBLE
95856: EQUAL
95857: IFTRUE 95867
95859: LD_INT 3
95861: DOUBLE
95862: EQUAL
95863: IFTRUE 95867
95865: GO 95923
95867: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95868: LD_ADDR_VAR 0 9
95872: PUSH
95873: LD_VAR 0 29
95877: PUSH
95878: LD_VAR 0 30
95882: PUSH
95883: LD_VAR 0 31
95887: PUSH
95888: LD_VAR 0 32
95892: PUSH
95893: LD_VAR 0 33
95897: PUSH
95898: LD_VAR 0 34
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: PUSH
95911: LD_VAR 0 4
95915: PUSH
95916: LD_INT 1
95918: PLUS
95919: ARRAY
95920: ST_TO_ADDR
95921: GO 96406
95923: LD_INT 16
95925: DOUBLE
95926: EQUAL
95927: IFTRUE 95985
95929: LD_INT 17
95931: DOUBLE
95932: EQUAL
95933: IFTRUE 95985
95935: LD_INT 18
95937: DOUBLE
95938: EQUAL
95939: IFTRUE 95985
95941: LD_INT 19
95943: DOUBLE
95944: EQUAL
95945: IFTRUE 95985
95947: LD_INT 22
95949: DOUBLE
95950: EQUAL
95951: IFTRUE 95985
95953: LD_INT 20
95955: DOUBLE
95956: EQUAL
95957: IFTRUE 95985
95959: LD_INT 21
95961: DOUBLE
95962: EQUAL
95963: IFTRUE 95985
95965: LD_INT 23
95967: DOUBLE
95968: EQUAL
95969: IFTRUE 95985
95971: LD_INT 24
95973: DOUBLE
95974: EQUAL
95975: IFTRUE 95985
95977: LD_INT 25
95979: DOUBLE
95980: EQUAL
95981: IFTRUE 95985
95983: GO 96041
95985: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95986: LD_ADDR_VAR 0 9
95990: PUSH
95991: LD_VAR 0 35
95995: PUSH
95996: LD_VAR 0 36
96000: PUSH
96001: LD_VAR 0 37
96005: PUSH
96006: LD_VAR 0 38
96010: PUSH
96011: LD_VAR 0 39
96015: PUSH
96016: LD_VAR 0 40
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: PUSH
96029: LD_VAR 0 4
96033: PUSH
96034: LD_INT 1
96036: PLUS
96037: ARRAY
96038: ST_TO_ADDR
96039: GO 96406
96041: LD_INT 6
96043: DOUBLE
96044: EQUAL
96045: IFTRUE 96097
96047: LD_INT 7
96049: DOUBLE
96050: EQUAL
96051: IFTRUE 96097
96053: LD_INT 8
96055: DOUBLE
96056: EQUAL
96057: IFTRUE 96097
96059: LD_INT 13
96061: DOUBLE
96062: EQUAL
96063: IFTRUE 96097
96065: LD_INT 12
96067: DOUBLE
96068: EQUAL
96069: IFTRUE 96097
96071: LD_INT 15
96073: DOUBLE
96074: EQUAL
96075: IFTRUE 96097
96077: LD_INT 11
96079: DOUBLE
96080: EQUAL
96081: IFTRUE 96097
96083: LD_INT 14
96085: DOUBLE
96086: EQUAL
96087: IFTRUE 96097
96089: LD_INT 10
96091: DOUBLE
96092: EQUAL
96093: IFTRUE 96097
96095: GO 96153
96097: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96098: LD_ADDR_VAR 0 9
96102: PUSH
96103: LD_VAR 0 41
96107: PUSH
96108: LD_VAR 0 42
96112: PUSH
96113: LD_VAR 0 43
96117: PUSH
96118: LD_VAR 0 44
96122: PUSH
96123: LD_VAR 0 45
96127: PUSH
96128: LD_VAR 0 46
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: PUSH
96141: LD_VAR 0 4
96145: PUSH
96146: LD_INT 1
96148: PLUS
96149: ARRAY
96150: ST_TO_ADDR
96151: GO 96406
96153: LD_INT 36
96155: DOUBLE
96156: EQUAL
96157: IFTRUE 96161
96159: GO 96217
96161: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96162: LD_ADDR_VAR 0 9
96166: PUSH
96167: LD_VAR 0 47
96171: PUSH
96172: LD_VAR 0 48
96176: PUSH
96177: LD_VAR 0 49
96181: PUSH
96182: LD_VAR 0 50
96186: PUSH
96187: LD_VAR 0 51
96191: PUSH
96192: LD_VAR 0 52
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: PUSH
96205: LD_VAR 0 4
96209: PUSH
96210: LD_INT 1
96212: PLUS
96213: ARRAY
96214: ST_TO_ADDR
96215: GO 96406
96217: LD_INT 4
96219: DOUBLE
96220: EQUAL
96221: IFTRUE 96243
96223: LD_INT 5
96225: DOUBLE
96226: EQUAL
96227: IFTRUE 96243
96229: LD_INT 34
96231: DOUBLE
96232: EQUAL
96233: IFTRUE 96243
96235: LD_INT 37
96237: DOUBLE
96238: EQUAL
96239: IFTRUE 96243
96241: GO 96299
96243: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96244: LD_ADDR_VAR 0 9
96248: PUSH
96249: LD_VAR 0 53
96253: PUSH
96254: LD_VAR 0 54
96258: PUSH
96259: LD_VAR 0 55
96263: PUSH
96264: LD_VAR 0 56
96268: PUSH
96269: LD_VAR 0 57
96273: PUSH
96274: LD_VAR 0 58
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: PUSH
96287: LD_VAR 0 4
96291: PUSH
96292: LD_INT 1
96294: PLUS
96295: ARRAY
96296: ST_TO_ADDR
96297: GO 96406
96299: LD_INT 31
96301: DOUBLE
96302: EQUAL
96303: IFTRUE 96349
96305: LD_INT 32
96307: DOUBLE
96308: EQUAL
96309: IFTRUE 96349
96311: LD_INT 33
96313: DOUBLE
96314: EQUAL
96315: IFTRUE 96349
96317: LD_INT 27
96319: DOUBLE
96320: EQUAL
96321: IFTRUE 96349
96323: LD_INT 26
96325: DOUBLE
96326: EQUAL
96327: IFTRUE 96349
96329: LD_INT 28
96331: DOUBLE
96332: EQUAL
96333: IFTRUE 96349
96335: LD_INT 29
96337: DOUBLE
96338: EQUAL
96339: IFTRUE 96349
96341: LD_INT 30
96343: DOUBLE
96344: EQUAL
96345: IFTRUE 96349
96347: GO 96405
96349: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96350: LD_ADDR_VAR 0 9
96354: PUSH
96355: LD_VAR 0 59
96359: PUSH
96360: LD_VAR 0 60
96364: PUSH
96365: LD_VAR 0 61
96369: PUSH
96370: LD_VAR 0 62
96374: PUSH
96375: LD_VAR 0 63
96379: PUSH
96380: LD_VAR 0 64
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: PUSH
96393: LD_VAR 0 4
96397: PUSH
96398: LD_INT 1
96400: PLUS
96401: ARRAY
96402: ST_TO_ADDR
96403: GO 96406
96405: POP
// temp_list2 = [ ] ;
96406: LD_ADDR_VAR 0 10
96410: PUSH
96411: EMPTY
96412: ST_TO_ADDR
// for i in temp_list do
96413: LD_ADDR_VAR 0 8
96417: PUSH
96418: LD_VAR 0 9
96422: PUSH
96423: FOR_IN
96424: IFFALSE 96476
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96426: LD_ADDR_VAR 0 10
96430: PUSH
96431: LD_VAR 0 10
96435: PUSH
96436: LD_VAR 0 8
96440: PUSH
96441: LD_INT 1
96443: ARRAY
96444: PUSH
96445: LD_VAR 0 2
96449: PLUS
96450: PUSH
96451: LD_VAR 0 8
96455: PUSH
96456: LD_INT 2
96458: ARRAY
96459: PUSH
96460: LD_VAR 0 3
96464: PLUS
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: EMPTY
96471: LIST
96472: ADD
96473: ST_TO_ADDR
96474: GO 96423
96476: POP
96477: POP
// result = temp_list2 ;
96478: LD_ADDR_VAR 0 7
96482: PUSH
96483: LD_VAR 0 10
96487: ST_TO_ADDR
// end ;
96488: LD_VAR 0 7
96492: RET
// export function EnemyInRange ( unit , dist ) ; begin
96493: LD_INT 0
96495: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96496: LD_ADDR_VAR 0 3
96500: PUSH
96501: LD_VAR 0 1
96505: PPUSH
96506: CALL_OW 255
96510: PPUSH
96511: LD_VAR 0 1
96515: PPUSH
96516: CALL_OW 250
96520: PPUSH
96521: LD_VAR 0 1
96525: PPUSH
96526: CALL_OW 251
96530: PPUSH
96531: LD_VAR 0 2
96535: PPUSH
96536: CALL 70597 0 4
96540: PUSH
96541: LD_INT 4
96543: ARRAY
96544: ST_TO_ADDR
// end ;
96545: LD_VAR 0 3
96549: RET
// export function PlayerSeeMe ( unit ) ; begin
96550: LD_INT 0
96552: PPUSH
// result := See ( your_side , unit ) ;
96553: LD_ADDR_VAR 0 2
96557: PUSH
96558: LD_OWVAR 2
96562: PPUSH
96563: LD_VAR 0 1
96567: PPUSH
96568: CALL_OW 292
96572: ST_TO_ADDR
// end ;
96573: LD_VAR 0 2
96577: RET
// export function ReverseDir ( unit ) ; begin
96578: LD_INT 0
96580: PPUSH
// if not unit then
96581: LD_VAR 0 1
96585: NOT
96586: IFFALSE 96590
// exit ;
96588: GO 96636
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
96590: LD_ADDR_VAR 0 2
96594: PUSH
96595: LD_INT 3
96597: PUSH
96598: LD_INT 4
96600: PUSH
96601: LD_INT 5
96603: PUSH
96604: LD_INT 0
96606: PUSH
96607: LD_INT 1
96609: PUSH
96610: LD_INT 2
96612: PUSH
96613: EMPTY
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: PUSH
96621: LD_VAR 0 1
96625: PPUSH
96626: CALL_OW 254
96630: PUSH
96631: LD_INT 1
96633: PLUS
96634: ARRAY
96635: ST_TO_ADDR
// end ;
96636: LD_VAR 0 2
96640: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96641: LD_INT 0
96643: PPUSH
96644: PPUSH
96645: PPUSH
96646: PPUSH
96647: PPUSH
// if not hexes then
96648: LD_VAR 0 2
96652: NOT
96653: IFFALSE 96657
// exit ;
96655: GO 96805
// dist := 9999 ;
96657: LD_ADDR_VAR 0 5
96661: PUSH
96662: LD_INT 9999
96664: ST_TO_ADDR
// for i = 1 to hexes do
96665: LD_ADDR_VAR 0 4
96669: PUSH
96670: DOUBLE
96671: LD_INT 1
96673: DEC
96674: ST_TO_ADDR
96675: LD_VAR 0 2
96679: PUSH
96680: FOR_TO
96681: IFFALSE 96793
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96683: LD_VAR 0 1
96687: PPUSH
96688: LD_VAR 0 2
96692: PUSH
96693: LD_VAR 0 4
96697: ARRAY
96698: PUSH
96699: LD_INT 1
96701: ARRAY
96702: PPUSH
96703: LD_VAR 0 2
96707: PUSH
96708: LD_VAR 0 4
96712: ARRAY
96713: PUSH
96714: LD_INT 2
96716: ARRAY
96717: PPUSH
96718: CALL_OW 297
96722: PUSH
96723: LD_VAR 0 5
96727: LESS
96728: IFFALSE 96791
// begin hex := hexes [ i ] ;
96730: LD_ADDR_VAR 0 7
96734: PUSH
96735: LD_VAR 0 2
96739: PUSH
96740: LD_VAR 0 4
96744: ARRAY
96745: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96746: LD_ADDR_VAR 0 5
96750: PUSH
96751: LD_VAR 0 1
96755: PPUSH
96756: LD_VAR 0 2
96760: PUSH
96761: LD_VAR 0 4
96765: ARRAY
96766: PUSH
96767: LD_INT 1
96769: ARRAY
96770: PPUSH
96771: LD_VAR 0 2
96775: PUSH
96776: LD_VAR 0 4
96780: ARRAY
96781: PUSH
96782: LD_INT 2
96784: ARRAY
96785: PPUSH
96786: CALL_OW 297
96790: ST_TO_ADDR
// end ; end ;
96791: GO 96680
96793: POP
96794: POP
// result := hex ;
96795: LD_ADDR_VAR 0 3
96799: PUSH
96800: LD_VAR 0 7
96804: ST_TO_ADDR
// end ;
96805: LD_VAR 0 3
96809: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96810: LD_INT 0
96812: PPUSH
96813: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96814: LD_VAR 0 1
96818: NOT
96819: PUSH
96820: LD_VAR 0 1
96824: PUSH
96825: LD_INT 21
96827: PUSH
96828: LD_INT 2
96830: PUSH
96831: EMPTY
96832: LIST
96833: LIST
96834: PUSH
96835: LD_INT 23
96837: PUSH
96838: LD_INT 2
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: PPUSH
96849: CALL_OW 69
96853: IN
96854: NOT
96855: OR
96856: IFFALSE 96860
// exit ;
96858: GO 96907
// for i = 1 to 3 do
96860: LD_ADDR_VAR 0 3
96864: PUSH
96865: DOUBLE
96866: LD_INT 1
96868: DEC
96869: ST_TO_ADDR
96870: LD_INT 3
96872: PUSH
96873: FOR_TO
96874: IFFALSE 96905
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96876: LD_VAR 0 1
96880: PPUSH
96881: CALL_OW 250
96885: PPUSH
96886: LD_VAR 0 1
96890: PPUSH
96891: CALL_OW 251
96895: PPUSH
96896: LD_INT 1
96898: PPUSH
96899: CALL_OW 453
96903: GO 96873
96905: POP
96906: POP
// end ;
96907: LD_VAR 0 2
96911: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96912: LD_INT 0
96914: PPUSH
96915: PPUSH
96916: PPUSH
96917: PPUSH
96918: PPUSH
96919: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96920: LD_VAR 0 1
96924: NOT
96925: PUSH
96926: LD_VAR 0 2
96930: NOT
96931: OR
96932: PUSH
96933: LD_VAR 0 1
96937: PPUSH
96938: CALL_OW 314
96942: OR
96943: IFFALSE 96947
// exit ;
96945: GO 97388
// x := GetX ( enemy_unit ) ;
96947: LD_ADDR_VAR 0 7
96951: PUSH
96952: LD_VAR 0 2
96956: PPUSH
96957: CALL_OW 250
96961: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96962: LD_ADDR_VAR 0 8
96966: PUSH
96967: LD_VAR 0 2
96971: PPUSH
96972: CALL_OW 251
96976: ST_TO_ADDR
// if not x or not y then
96977: LD_VAR 0 7
96981: NOT
96982: PUSH
96983: LD_VAR 0 8
96987: NOT
96988: OR
96989: IFFALSE 96993
// exit ;
96991: GO 97388
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96993: LD_ADDR_VAR 0 6
96997: PUSH
96998: LD_VAR 0 7
97002: PPUSH
97003: LD_INT 0
97005: PPUSH
97006: LD_INT 4
97008: PPUSH
97009: CALL_OW 272
97013: PUSH
97014: LD_VAR 0 8
97018: PPUSH
97019: LD_INT 0
97021: PPUSH
97022: LD_INT 4
97024: PPUSH
97025: CALL_OW 273
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: PUSH
97034: LD_VAR 0 7
97038: PPUSH
97039: LD_INT 1
97041: PPUSH
97042: LD_INT 4
97044: PPUSH
97045: CALL_OW 272
97049: PUSH
97050: LD_VAR 0 8
97054: PPUSH
97055: LD_INT 1
97057: PPUSH
97058: LD_INT 4
97060: PPUSH
97061: CALL_OW 273
97065: PUSH
97066: EMPTY
97067: LIST
97068: LIST
97069: PUSH
97070: LD_VAR 0 7
97074: PPUSH
97075: LD_INT 2
97077: PPUSH
97078: LD_INT 4
97080: PPUSH
97081: CALL_OW 272
97085: PUSH
97086: LD_VAR 0 8
97090: PPUSH
97091: LD_INT 2
97093: PPUSH
97094: LD_INT 4
97096: PPUSH
97097: CALL_OW 273
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: LD_VAR 0 7
97110: PPUSH
97111: LD_INT 3
97113: PPUSH
97114: LD_INT 4
97116: PPUSH
97117: CALL_OW 272
97121: PUSH
97122: LD_VAR 0 8
97126: PPUSH
97127: LD_INT 3
97129: PPUSH
97130: LD_INT 4
97132: PPUSH
97133: CALL_OW 273
97137: PUSH
97138: EMPTY
97139: LIST
97140: LIST
97141: PUSH
97142: LD_VAR 0 7
97146: PPUSH
97147: LD_INT 4
97149: PPUSH
97150: LD_INT 4
97152: PPUSH
97153: CALL_OW 272
97157: PUSH
97158: LD_VAR 0 8
97162: PPUSH
97163: LD_INT 4
97165: PPUSH
97166: LD_INT 4
97168: PPUSH
97169: CALL_OW 273
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: PUSH
97178: LD_VAR 0 7
97182: PPUSH
97183: LD_INT 5
97185: PPUSH
97186: LD_INT 4
97188: PPUSH
97189: CALL_OW 272
97193: PUSH
97194: LD_VAR 0 8
97198: PPUSH
97199: LD_INT 5
97201: PPUSH
97202: LD_INT 4
97204: PPUSH
97205: CALL_OW 273
97209: PUSH
97210: EMPTY
97211: LIST
97212: LIST
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: ST_TO_ADDR
// for i = tmp downto 1 do
97222: LD_ADDR_VAR 0 4
97226: PUSH
97227: DOUBLE
97228: LD_VAR 0 6
97232: INC
97233: ST_TO_ADDR
97234: LD_INT 1
97236: PUSH
97237: FOR_DOWNTO
97238: IFFALSE 97339
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97240: LD_VAR 0 6
97244: PUSH
97245: LD_VAR 0 4
97249: ARRAY
97250: PUSH
97251: LD_INT 1
97253: ARRAY
97254: PPUSH
97255: LD_VAR 0 6
97259: PUSH
97260: LD_VAR 0 4
97264: ARRAY
97265: PUSH
97266: LD_INT 2
97268: ARRAY
97269: PPUSH
97270: CALL_OW 488
97274: NOT
97275: PUSH
97276: LD_VAR 0 6
97280: PUSH
97281: LD_VAR 0 4
97285: ARRAY
97286: PUSH
97287: LD_INT 1
97289: ARRAY
97290: PPUSH
97291: LD_VAR 0 6
97295: PUSH
97296: LD_VAR 0 4
97300: ARRAY
97301: PUSH
97302: LD_INT 2
97304: ARRAY
97305: PPUSH
97306: CALL_OW 428
97310: PUSH
97311: LD_INT 0
97313: NONEQUAL
97314: OR
97315: IFFALSE 97337
// tmp := Delete ( tmp , i ) ;
97317: LD_ADDR_VAR 0 6
97321: PUSH
97322: LD_VAR 0 6
97326: PPUSH
97327: LD_VAR 0 4
97331: PPUSH
97332: CALL_OW 3
97336: ST_TO_ADDR
97337: GO 97237
97339: POP
97340: POP
// j := GetClosestHex ( unit , tmp ) ;
97341: LD_ADDR_VAR 0 5
97345: PUSH
97346: LD_VAR 0 1
97350: PPUSH
97351: LD_VAR 0 6
97355: PPUSH
97356: CALL 96641 0 2
97360: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97361: LD_VAR 0 1
97365: PPUSH
97366: LD_VAR 0 5
97370: PUSH
97371: LD_INT 1
97373: ARRAY
97374: PPUSH
97375: LD_VAR 0 5
97379: PUSH
97380: LD_INT 2
97382: ARRAY
97383: PPUSH
97384: CALL_OW 111
// end ;
97388: LD_VAR 0 3
97392: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97393: LD_INT 0
97395: PPUSH
97396: PPUSH
97397: PPUSH
// uc_side = 0 ;
97398: LD_ADDR_OWVAR 20
97402: PUSH
97403: LD_INT 0
97405: ST_TO_ADDR
// uc_nation = 0 ;
97406: LD_ADDR_OWVAR 21
97410: PUSH
97411: LD_INT 0
97413: ST_TO_ADDR
// InitHc ;
97414: CALL_OW 19
// InitVc ;
97418: CALL_OW 20
// if mastodonts then
97422: LD_VAR 0 6
97426: IFFALSE 97493
// for i = 1 to mastodonts do
97428: LD_ADDR_VAR 0 11
97432: PUSH
97433: DOUBLE
97434: LD_INT 1
97436: DEC
97437: ST_TO_ADDR
97438: LD_VAR 0 6
97442: PUSH
97443: FOR_TO
97444: IFFALSE 97491
// begin vc_chassis := 31 ;
97446: LD_ADDR_OWVAR 37
97450: PUSH
97451: LD_INT 31
97453: ST_TO_ADDR
// vc_control := control_rider ;
97454: LD_ADDR_OWVAR 38
97458: PUSH
97459: LD_INT 4
97461: ST_TO_ADDR
// animal := CreateVehicle ;
97462: LD_ADDR_VAR 0 12
97466: PUSH
97467: CALL_OW 45
97471: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97472: LD_VAR 0 12
97476: PPUSH
97477: LD_VAR 0 8
97481: PPUSH
97482: LD_INT 0
97484: PPUSH
97485: CALL 104238 0 3
// end ;
97489: GO 97443
97491: POP
97492: POP
// if horses then
97493: LD_VAR 0 5
97497: IFFALSE 97564
// for i = 1 to horses do
97499: LD_ADDR_VAR 0 11
97503: PUSH
97504: DOUBLE
97505: LD_INT 1
97507: DEC
97508: ST_TO_ADDR
97509: LD_VAR 0 5
97513: PUSH
97514: FOR_TO
97515: IFFALSE 97562
// begin hc_class := 21 ;
97517: LD_ADDR_OWVAR 28
97521: PUSH
97522: LD_INT 21
97524: ST_TO_ADDR
// hc_gallery :=  ;
97525: LD_ADDR_OWVAR 33
97529: PUSH
97530: LD_STRING 
97532: ST_TO_ADDR
// animal := CreateHuman ;
97533: LD_ADDR_VAR 0 12
97537: PUSH
97538: CALL_OW 44
97542: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97543: LD_VAR 0 12
97547: PPUSH
97548: LD_VAR 0 8
97552: PPUSH
97553: LD_INT 0
97555: PPUSH
97556: CALL 104238 0 3
// end ;
97560: GO 97514
97562: POP
97563: POP
// if birds then
97564: LD_VAR 0 1
97568: IFFALSE 97635
// for i = 1 to birds do
97570: LD_ADDR_VAR 0 11
97574: PUSH
97575: DOUBLE
97576: LD_INT 1
97578: DEC
97579: ST_TO_ADDR
97580: LD_VAR 0 1
97584: PUSH
97585: FOR_TO
97586: IFFALSE 97633
// begin hc_class = 18 ;
97588: LD_ADDR_OWVAR 28
97592: PUSH
97593: LD_INT 18
97595: ST_TO_ADDR
// hc_gallery =  ;
97596: LD_ADDR_OWVAR 33
97600: PUSH
97601: LD_STRING 
97603: ST_TO_ADDR
// animal := CreateHuman ;
97604: LD_ADDR_VAR 0 12
97608: PUSH
97609: CALL_OW 44
97613: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97614: LD_VAR 0 12
97618: PPUSH
97619: LD_VAR 0 8
97623: PPUSH
97624: LD_INT 0
97626: PPUSH
97627: CALL 104238 0 3
// end ;
97631: GO 97585
97633: POP
97634: POP
// if tigers then
97635: LD_VAR 0 2
97639: IFFALSE 97723
// for i = 1 to tigers do
97641: LD_ADDR_VAR 0 11
97645: PUSH
97646: DOUBLE
97647: LD_INT 1
97649: DEC
97650: ST_TO_ADDR
97651: LD_VAR 0 2
97655: PUSH
97656: FOR_TO
97657: IFFALSE 97721
// begin hc_class = class_tiger ;
97659: LD_ADDR_OWVAR 28
97663: PUSH
97664: LD_INT 14
97666: ST_TO_ADDR
// hc_gallery =  ;
97667: LD_ADDR_OWVAR 33
97671: PUSH
97672: LD_STRING 
97674: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97675: LD_ADDR_OWVAR 35
97679: PUSH
97680: LD_INT 7
97682: NEG
97683: PPUSH
97684: LD_INT 7
97686: PPUSH
97687: CALL_OW 12
97691: ST_TO_ADDR
// animal := CreateHuman ;
97692: LD_ADDR_VAR 0 12
97696: PUSH
97697: CALL_OW 44
97701: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97702: LD_VAR 0 12
97706: PPUSH
97707: LD_VAR 0 8
97711: PPUSH
97712: LD_INT 0
97714: PPUSH
97715: CALL 104238 0 3
// end ;
97719: GO 97656
97721: POP
97722: POP
// if apemans then
97723: LD_VAR 0 3
97727: IFFALSE 97850
// for i = 1 to apemans do
97729: LD_ADDR_VAR 0 11
97733: PUSH
97734: DOUBLE
97735: LD_INT 1
97737: DEC
97738: ST_TO_ADDR
97739: LD_VAR 0 3
97743: PUSH
97744: FOR_TO
97745: IFFALSE 97848
// begin hc_class = class_apeman ;
97747: LD_ADDR_OWVAR 28
97751: PUSH
97752: LD_INT 12
97754: ST_TO_ADDR
// hc_gallery =  ;
97755: LD_ADDR_OWVAR 33
97759: PUSH
97760: LD_STRING 
97762: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
97763: LD_ADDR_OWVAR 35
97767: PUSH
97768: LD_INT 5
97770: NEG
97771: PPUSH
97772: LD_INT 5
97774: PPUSH
97775: CALL_OW 12
97779: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97780: LD_ADDR_OWVAR 31
97784: PUSH
97785: LD_INT 1
97787: PPUSH
97788: LD_INT 3
97790: PPUSH
97791: CALL_OW 12
97795: PUSH
97796: LD_INT 1
97798: PPUSH
97799: LD_INT 3
97801: PPUSH
97802: CALL_OW 12
97806: PUSH
97807: LD_INT 0
97809: PUSH
97810: LD_INT 0
97812: PUSH
97813: EMPTY
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: ST_TO_ADDR
// animal := CreateHuman ;
97819: LD_ADDR_VAR 0 12
97823: PUSH
97824: CALL_OW 44
97828: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97829: LD_VAR 0 12
97833: PPUSH
97834: LD_VAR 0 8
97838: PPUSH
97839: LD_INT 0
97841: PPUSH
97842: CALL 104238 0 3
// end ;
97846: GO 97744
97848: POP
97849: POP
// if enchidnas then
97850: LD_VAR 0 4
97854: IFFALSE 97921
// for i = 1 to enchidnas do
97856: LD_ADDR_VAR 0 11
97860: PUSH
97861: DOUBLE
97862: LD_INT 1
97864: DEC
97865: ST_TO_ADDR
97866: LD_VAR 0 4
97870: PUSH
97871: FOR_TO
97872: IFFALSE 97919
// begin hc_class = 13 ;
97874: LD_ADDR_OWVAR 28
97878: PUSH
97879: LD_INT 13
97881: ST_TO_ADDR
// hc_gallery =  ;
97882: LD_ADDR_OWVAR 33
97886: PUSH
97887: LD_STRING 
97889: ST_TO_ADDR
// animal := CreateHuman ;
97890: LD_ADDR_VAR 0 12
97894: PUSH
97895: CALL_OW 44
97899: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97900: LD_VAR 0 12
97904: PPUSH
97905: LD_VAR 0 8
97909: PPUSH
97910: LD_INT 0
97912: PPUSH
97913: CALL 104238 0 3
// end ;
97917: GO 97871
97919: POP
97920: POP
// if fishes then
97921: LD_VAR 0 7
97925: IFFALSE 97992
// for i = 1 to fishes do
97927: LD_ADDR_VAR 0 11
97931: PUSH
97932: DOUBLE
97933: LD_INT 1
97935: DEC
97936: ST_TO_ADDR
97937: LD_VAR 0 7
97941: PUSH
97942: FOR_TO
97943: IFFALSE 97990
// begin hc_class = 20 ;
97945: LD_ADDR_OWVAR 28
97949: PUSH
97950: LD_INT 20
97952: ST_TO_ADDR
// hc_gallery =  ;
97953: LD_ADDR_OWVAR 33
97957: PUSH
97958: LD_STRING 
97960: ST_TO_ADDR
// animal := CreateHuman ;
97961: LD_ADDR_VAR 0 12
97965: PUSH
97966: CALL_OW 44
97970: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
97971: LD_VAR 0 12
97975: PPUSH
97976: LD_VAR 0 9
97980: PPUSH
97981: LD_INT 0
97983: PPUSH
97984: CALL 104238 0 3
// end ;
97988: GO 97942
97990: POP
97991: POP
// end ;
97992: LD_VAR 0 10
97996: RET
// export function WantHeal ( sci , unit ) ; begin
97997: LD_INT 0
97999: PPUSH
// if GetTaskList ( sci ) > 0 then
98000: LD_VAR 0 1
98004: PPUSH
98005: CALL_OW 437
98009: PUSH
98010: LD_INT 0
98012: GREATER
98013: IFFALSE 98083
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98015: LD_VAR 0 1
98019: PPUSH
98020: CALL_OW 437
98024: PUSH
98025: LD_INT 1
98027: ARRAY
98028: PUSH
98029: LD_INT 1
98031: ARRAY
98032: PUSH
98033: LD_STRING l
98035: EQUAL
98036: PUSH
98037: LD_VAR 0 1
98041: PPUSH
98042: CALL_OW 437
98046: PUSH
98047: LD_INT 1
98049: ARRAY
98050: PUSH
98051: LD_INT 4
98053: ARRAY
98054: PUSH
98055: LD_VAR 0 2
98059: EQUAL
98060: AND
98061: IFFALSE 98073
// result := true else
98063: LD_ADDR_VAR 0 3
98067: PUSH
98068: LD_INT 1
98070: ST_TO_ADDR
98071: GO 98081
// result := false ;
98073: LD_ADDR_VAR 0 3
98077: PUSH
98078: LD_INT 0
98080: ST_TO_ADDR
// end else
98081: GO 98091
// result := false ;
98083: LD_ADDR_VAR 0 3
98087: PUSH
98088: LD_INT 0
98090: ST_TO_ADDR
// end ;
98091: LD_VAR 0 3
98095: RET
// export function HealTarget ( sci ) ; begin
98096: LD_INT 0
98098: PPUSH
// if not sci then
98099: LD_VAR 0 1
98103: NOT
98104: IFFALSE 98108
// exit ;
98106: GO 98173
// result := 0 ;
98108: LD_ADDR_VAR 0 2
98112: PUSH
98113: LD_INT 0
98115: ST_TO_ADDR
// if GetTaskList ( sci ) then
98116: LD_VAR 0 1
98120: PPUSH
98121: CALL_OW 437
98125: IFFALSE 98173
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98127: LD_VAR 0 1
98131: PPUSH
98132: CALL_OW 437
98136: PUSH
98137: LD_INT 1
98139: ARRAY
98140: PUSH
98141: LD_INT 1
98143: ARRAY
98144: PUSH
98145: LD_STRING l
98147: EQUAL
98148: IFFALSE 98173
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98150: LD_ADDR_VAR 0 2
98154: PUSH
98155: LD_VAR 0 1
98159: PPUSH
98160: CALL_OW 437
98164: PUSH
98165: LD_INT 1
98167: ARRAY
98168: PUSH
98169: LD_INT 4
98171: ARRAY
98172: ST_TO_ADDR
// end ;
98173: LD_VAR 0 2
98177: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98178: LD_INT 0
98180: PPUSH
98181: PPUSH
98182: PPUSH
98183: PPUSH
98184: PPUSH
98185: PPUSH
98186: PPUSH
98187: PPUSH
98188: PPUSH
98189: PPUSH
98190: PPUSH
98191: PPUSH
98192: PPUSH
98193: PPUSH
98194: PPUSH
98195: PPUSH
98196: PPUSH
98197: PPUSH
98198: PPUSH
98199: PPUSH
98200: PPUSH
98201: PPUSH
98202: PPUSH
98203: PPUSH
98204: PPUSH
98205: PPUSH
98206: PPUSH
98207: PPUSH
98208: PPUSH
98209: PPUSH
98210: PPUSH
98211: PPUSH
98212: PPUSH
98213: PPUSH
// if not list then
98214: LD_VAR 0 1
98218: NOT
98219: IFFALSE 98223
// exit ;
98221: GO 102849
// base := list [ 1 ] ;
98223: LD_ADDR_VAR 0 3
98227: PUSH
98228: LD_VAR 0 1
98232: PUSH
98233: LD_INT 1
98235: ARRAY
98236: ST_TO_ADDR
// group := list [ 2 ] ;
98237: LD_ADDR_VAR 0 4
98241: PUSH
98242: LD_VAR 0 1
98246: PUSH
98247: LD_INT 2
98249: ARRAY
98250: ST_TO_ADDR
// path := list [ 3 ] ;
98251: LD_ADDR_VAR 0 5
98255: PUSH
98256: LD_VAR 0 1
98260: PUSH
98261: LD_INT 3
98263: ARRAY
98264: ST_TO_ADDR
// flags := list [ 4 ] ;
98265: LD_ADDR_VAR 0 6
98269: PUSH
98270: LD_VAR 0 1
98274: PUSH
98275: LD_INT 4
98277: ARRAY
98278: ST_TO_ADDR
// mined := [ ] ;
98279: LD_ADDR_VAR 0 27
98283: PUSH
98284: EMPTY
98285: ST_TO_ADDR
// bombed := [ ] ;
98286: LD_ADDR_VAR 0 28
98290: PUSH
98291: EMPTY
98292: ST_TO_ADDR
// healers := [ ] ;
98293: LD_ADDR_VAR 0 31
98297: PUSH
98298: EMPTY
98299: ST_TO_ADDR
// to_heal := [ ] ;
98300: LD_ADDR_VAR 0 30
98304: PUSH
98305: EMPTY
98306: ST_TO_ADDR
// repairs := [ ] ;
98307: LD_ADDR_VAR 0 33
98311: PUSH
98312: EMPTY
98313: ST_TO_ADDR
// to_repair := [ ] ;
98314: LD_ADDR_VAR 0 32
98318: PUSH
98319: EMPTY
98320: ST_TO_ADDR
// if not group or not path then
98321: LD_VAR 0 4
98325: NOT
98326: PUSH
98327: LD_VAR 0 5
98331: NOT
98332: OR
98333: IFFALSE 98337
// exit ;
98335: GO 102849
// side := GetSide ( group [ 1 ] ) ;
98337: LD_ADDR_VAR 0 35
98341: PUSH
98342: LD_VAR 0 4
98346: PUSH
98347: LD_INT 1
98349: ARRAY
98350: PPUSH
98351: CALL_OW 255
98355: ST_TO_ADDR
// if flags then
98356: LD_VAR 0 6
98360: IFFALSE 98504
// begin f_ignore_area := flags [ 1 ] ;
98362: LD_ADDR_VAR 0 17
98366: PUSH
98367: LD_VAR 0 6
98371: PUSH
98372: LD_INT 1
98374: ARRAY
98375: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98376: LD_ADDR_VAR 0 18
98380: PUSH
98381: LD_VAR 0 6
98385: PUSH
98386: LD_INT 2
98388: ARRAY
98389: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98390: LD_ADDR_VAR 0 19
98394: PUSH
98395: LD_VAR 0 6
98399: PUSH
98400: LD_INT 3
98402: ARRAY
98403: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98404: LD_ADDR_VAR 0 20
98408: PUSH
98409: LD_VAR 0 6
98413: PUSH
98414: LD_INT 4
98416: ARRAY
98417: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98418: LD_ADDR_VAR 0 21
98422: PUSH
98423: LD_VAR 0 6
98427: PUSH
98428: LD_INT 5
98430: ARRAY
98431: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98432: LD_ADDR_VAR 0 22
98436: PUSH
98437: LD_VAR 0 6
98441: PUSH
98442: LD_INT 6
98444: ARRAY
98445: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98446: LD_ADDR_VAR 0 23
98450: PUSH
98451: LD_VAR 0 6
98455: PUSH
98456: LD_INT 7
98458: ARRAY
98459: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98460: LD_ADDR_VAR 0 24
98464: PUSH
98465: LD_VAR 0 6
98469: PUSH
98470: LD_INT 8
98472: ARRAY
98473: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98474: LD_ADDR_VAR 0 25
98478: PUSH
98479: LD_VAR 0 6
98483: PUSH
98484: LD_INT 9
98486: ARRAY
98487: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98488: LD_ADDR_VAR 0 26
98492: PUSH
98493: LD_VAR 0 6
98497: PUSH
98498: LD_INT 10
98500: ARRAY
98501: ST_TO_ADDR
// end else
98502: GO 98584
// begin f_ignore_area := false ;
98504: LD_ADDR_VAR 0 17
98508: PUSH
98509: LD_INT 0
98511: ST_TO_ADDR
// f_capture := false ;
98512: LD_ADDR_VAR 0 18
98516: PUSH
98517: LD_INT 0
98519: ST_TO_ADDR
// f_ignore_civ := false ;
98520: LD_ADDR_VAR 0 19
98524: PUSH
98525: LD_INT 0
98527: ST_TO_ADDR
// f_murder := false ;
98528: LD_ADDR_VAR 0 20
98532: PUSH
98533: LD_INT 0
98535: ST_TO_ADDR
// f_mines := false ;
98536: LD_ADDR_VAR 0 21
98540: PUSH
98541: LD_INT 0
98543: ST_TO_ADDR
// f_repair := false ;
98544: LD_ADDR_VAR 0 22
98548: PUSH
98549: LD_INT 0
98551: ST_TO_ADDR
// f_heal := false ;
98552: LD_ADDR_VAR 0 23
98556: PUSH
98557: LD_INT 0
98559: ST_TO_ADDR
// f_spacetime := false ;
98560: LD_ADDR_VAR 0 24
98564: PUSH
98565: LD_INT 0
98567: ST_TO_ADDR
// f_attack_depot := false ;
98568: LD_ADDR_VAR 0 25
98572: PUSH
98573: LD_INT 0
98575: ST_TO_ADDR
// f_crawl := false ;
98576: LD_ADDR_VAR 0 26
98580: PUSH
98581: LD_INT 0
98583: ST_TO_ADDR
// end ; if f_heal then
98584: LD_VAR 0 23
98588: IFFALSE 98615
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98590: LD_ADDR_VAR 0 31
98594: PUSH
98595: LD_VAR 0 4
98599: PPUSH
98600: LD_INT 25
98602: PUSH
98603: LD_INT 4
98605: PUSH
98606: EMPTY
98607: LIST
98608: LIST
98609: PPUSH
98610: CALL_OW 72
98614: ST_TO_ADDR
// if f_repair then
98615: LD_VAR 0 22
98619: IFFALSE 98646
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98621: LD_ADDR_VAR 0 33
98625: PUSH
98626: LD_VAR 0 4
98630: PPUSH
98631: LD_INT 25
98633: PUSH
98634: LD_INT 3
98636: PUSH
98637: EMPTY
98638: LIST
98639: LIST
98640: PPUSH
98641: CALL_OW 72
98645: ST_TO_ADDR
// units_path := [ ] ;
98646: LD_ADDR_VAR 0 16
98650: PUSH
98651: EMPTY
98652: ST_TO_ADDR
// for i = 1 to group do
98653: LD_ADDR_VAR 0 7
98657: PUSH
98658: DOUBLE
98659: LD_INT 1
98661: DEC
98662: ST_TO_ADDR
98663: LD_VAR 0 4
98667: PUSH
98668: FOR_TO
98669: IFFALSE 98698
// units_path := Replace ( units_path , i , path ) ;
98671: LD_ADDR_VAR 0 16
98675: PUSH
98676: LD_VAR 0 16
98680: PPUSH
98681: LD_VAR 0 7
98685: PPUSH
98686: LD_VAR 0 5
98690: PPUSH
98691: CALL_OW 1
98695: ST_TO_ADDR
98696: GO 98668
98698: POP
98699: POP
// repeat for i = group downto 1 do
98700: LD_ADDR_VAR 0 7
98704: PUSH
98705: DOUBLE
98706: LD_VAR 0 4
98710: INC
98711: ST_TO_ADDR
98712: LD_INT 1
98714: PUSH
98715: FOR_DOWNTO
98716: IFFALSE 102812
// begin wait ( 5 ) ;
98718: LD_INT 5
98720: PPUSH
98721: CALL_OW 67
// tmp := [ ] ;
98725: LD_ADDR_VAR 0 14
98729: PUSH
98730: EMPTY
98731: ST_TO_ADDR
// attacking := false ;
98732: LD_ADDR_VAR 0 29
98736: PUSH
98737: LD_INT 0
98739: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98740: LD_VAR 0 4
98744: PUSH
98745: LD_VAR 0 7
98749: ARRAY
98750: PPUSH
98751: CALL_OW 301
98755: PUSH
98756: LD_VAR 0 4
98760: PUSH
98761: LD_VAR 0 7
98765: ARRAY
98766: NOT
98767: OR
98768: IFFALSE 98877
// begin if GetType ( group [ i ] ) = unit_human then
98770: LD_VAR 0 4
98774: PUSH
98775: LD_VAR 0 7
98779: ARRAY
98780: PPUSH
98781: CALL_OW 247
98785: PUSH
98786: LD_INT 1
98788: EQUAL
98789: IFFALSE 98835
// begin to_heal := to_heal diff group [ i ] ;
98791: LD_ADDR_VAR 0 30
98795: PUSH
98796: LD_VAR 0 30
98800: PUSH
98801: LD_VAR 0 4
98805: PUSH
98806: LD_VAR 0 7
98810: ARRAY
98811: DIFF
98812: ST_TO_ADDR
// healers := healers diff group [ i ] ;
98813: LD_ADDR_VAR 0 31
98817: PUSH
98818: LD_VAR 0 31
98822: PUSH
98823: LD_VAR 0 4
98827: PUSH
98828: LD_VAR 0 7
98832: ARRAY
98833: DIFF
98834: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
98835: LD_ADDR_VAR 0 4
98839: PUSH
98840: LD_VAR 0 4
98844: PPUSH
98845: LD_VAR 0 7
98849: PPUSH
98850: CALL_OW 3
98854: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
98855: LD_ADDR_VAR 0 16
98859: PUSH
98860: LD_VAR 0 16
98864: PPUSH
98865: LD_VAR 0 7
98869: PPUSH
98870: CALL_OW 3
98874: ST_TO_ADDR
// continue ;
98875: GO 98715
// end ; if f_repair then
98877: LD_VAR 0 22
98881: IFFALSE 99370
// begin if GetType ( group [ i ] ) = unit_vehicle then
98883: LD_VAR 0 4
98887: PUSH
98888: LD_VAR 0 7
98892: ARRAY
98893: PPUSH
98894: CALL_OW 247
98898: PUSH
98899: LD_INT 2
98901: EQUAL
98902: IFFALSE 99092
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
98904: LD_VAR 0 4
98908: PUSH
98909: LD_VAR 0 7
98913: ARRAY
98914: PPUSH
98915: CALL_OW 256
98919: PUSH
98920: LD_INT 700
98922: LESS
98923: PUSH
98924: LD_VAR 0 4
98928: PUSH
98929: LD_VAR 0 7
98933: ARRAY
98934: PUSH
98935: LD_VAR 0 32
98939: IN
98940: NOT
98941: AND
98942: IFFALSE 98966
// to_repair := to_repair union group [ i ] ;
98944: LD_ADDR_VAR 0 32
98948: PUSH
98949: LD_VAR 0 32
98953: PUSH
98954: LD_VAR 0 4
98958: PUSH
98959: LD_VAR 0 7
98963: ARRAY
98964: UNION
98965: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
98966: LD_VAR 0 4
98970: PUSH
98971: LD_VAR 0 7
98975: ARRAY
98976: PPUSH
98977: CALL_OW 256
98981: PUSH
98982: LD_INT 1000
98984: EQUAL
98985: PUSH
98986: LD_VAR 0 4
98990: PUSH
98991: LD_VAR 0 7
98995: ARRAY
98996: PUSH
98997: LD_VAR 0 32
99001: IN
99002: AND
99003: IFFALSE 99027
// to_repair := to_repair diff group [ i ] ;
99005: LD_ADDR_VAR 0 32
99009: PUSH
99010: LD_VAR 0 32
99014: PUSH
99015: LD_VAR 0 4
99019: PUSH
99020: LD_VAR 0 7
99024: ARRAY
99025: DIFF
99026: ST_TO_ADDR
// if group [ i ] in to_repair then
99027: LD_VAR 0 4
99031: PUSH
99032: LD_VAR 0 7
99036: ARRAY
99037: PUSH
99038: LD_VAR 0 32
99042: IN
99043: IFFALSE 99090
// begin if not IsInArea ( group [ i ] , f_repair ) then
99045: LD_VAR 0 4
99049: PUSH
99050: LD_VAR 0 7
99054: ARRAY
99055: PPUSH
99056: LD_VAR 0 22
99060: PPUSH
99061: CALL_OW 308
99065: NOT
99066: IFFALSE 99088
// ComMoveToArea ( group [ i ] , f_repair ) ;
99068: LD_VAR 0 4
99072: PUSH
99073: LD_VAR 0 7
99077: ARRAY
99078: PPUSH
99079: LD_VAR 0 22
99083: PPUSH
99084: CALL_OW 113
// continue ;
99088: GO 98715
// end ; end else
99090: GO 99370
// if group [ i ] in repairs then
99092: LD_VAR 0 4
99096: PUSH
99097: LD_VAR 0 7
99101: ARRAY
99102: PUSH
99103: LD_VAR 0 33
99107: IN
99108: IFFALSE 99370
// begin if IsInUnit ( group [ i ] ) then
99110: LD_VAR 0 4
99114: PUSH
99115: LD_VAR 0 7
99119: ARRAY
99120: PPUSH
99121: CALL_OW 310
99125: IFFALSE 99193
// begin z := IsInUnit ( group [ i ] ) ;
99127: LD_ADDR_VAR 0 13
99131: PUSH
99132: LD_VAR 0 4
99136: PUSH
99137: LD_VAR 0 7
99141: ARRAY
99142: PPUSH
99143: CALL_OW 310
99147: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99148: LD_VAR 0 13
99152: PUSH
99153: LD_VAR 0 32
99157: IN
99158: PUSH
99159: LD_VAR 0 13
99163: PPUSH
99164: LD_VAR 0 22
99168: PPUSH
99169: CALL_OW 308
99173: AND
99174: IFFALSE 99191
// ComExitVehicle ( group [ i ] ) ;
99176: LD_VAR 0 4
99180: PUSH
99181: LD_VAR 0 7
99185: ARRAY
99186: PPUSH
99187: CALL_OW 121
// end else
99191: GO 99370
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99193: LD_ADDR_VAR 0 13
99197: PUSH
99198: LD_VAR 0 4
99202: PPUSH
99203: LD_INT 95
99205: PUSH
99206: LD_VAR 0 22
99210: PUSH
99211: EMPTY
99212: LIST
99213: LIST
99214: PUSH
99215: LD_INT 58
99217: PUSH
99218: EMPTY
99219: LIST
99220: PUSH
99221: EMPTY
99222: LIST
99223: LIST
99224: PPUSH
99225: CALL_OW 72
99229: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99230: LD_VAR 0 4
99234: PUSH
99235: LD_VAR 0 7
99239: ARRAY
99240: PPUSH
99241: CALL_OW 314
99245: NOT
99246: IFFALSE 99368
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99248: LD_ADDR_VAR 0 10
99252: PUSH
99253: LD_VAR 0 13
99257: PPUSH
99258: LD_VAR 0 4
99262: PUSH
99263: LD_VAR 0 7
99267: ARRAY
99268: PPUSH
99269: CALL_OW 74
99273: ST_TO_ADDR
// if not x then
99274: LD_VAR 0 10
99278: NOT
99279: IFFALSE 99283
// continue ;
99281: GO 98715
// if GetLives ( x ) < 1000 then
99283: LD_VAR 0 10
99287: PPUSH
99288: CALL_OW 256
99292: PUSH
99293: LD_INT 1000
99295: LESS
99296: IFFALSE 99320
// ComRepairVehicle ( group [ i ] , x ) else
99298: LD_VAR 0 4
99302: PUSH
99303: LD_VAR 0 7
99307: ARRAY
99308: PPUSH
99309: LD_VAR 0 10
99313: PPUSH
99314: CALL_OW 129
99318: GO 99368
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99320: LD_VAR 0 23
99324: PUSH
99325: LD_VAR 0 4
99329: PUSH
99330: LD_VAR 0 7
99334: ARRAY
99335: PPUSH
99336: CALL_OW 256
99340: PUSH
99341: LD_INT 1000
99343: LESS
99344: AND
99345: NOT
99346: IFFALSE 99368
// ComEnterUnit ( group [ i ] , x ) ;
99348: LD_VAR 0 4
99352: PUSH
99353: LD_VAR 0 7
99357: ARRAY
99358: PPUSH
99359: LD_VAR 0 10
99363: PPUSH
99364: CALL_OW 120
// end ; continue ;
99368: GO 98715
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99370: LD_VAR 0 23
99374: PUSH
99375: LD_VAR 0 4
99379: PUSH
99380: LD_VAR 0 7
99384: ARRAY
99385: PPUSH
99386: CALL_OW 247
99390: PUSH
99391: LD_INT 1
99393: EQUAL
99394: AND
99395: IFFALSE 99873
// begin if group [ i ] in healers then
99397: LD_VAR 0 4
99401: PUSH
99402: LD_VAR 0 7
99406: ARRAY
99407: PUSH
99408: LD_VAR 0 31
99412: IN
99413: IFFALSE 99686
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99415: LD_VAR 0 4
99419: PUSH
99420: LD_VAR 0 7
99424: ARRAY
99425: PPUSH
99426: LD_VAR 0 23
99430: PPUSH
99431: CALL_OW 308
99435: NOT
99436: PUSH
99437: LD_VAR 0 4
99441: PUSH
99442: LD_VAR 0 7
99446: ARRAY
99447: PPUSH
99448: CALL_OW 314
99452: NOT
99453: AND
99454: IFFALSE 99478
// ComMoveToArea ( group [ i ] , f_heal ) else
99456: LD_VAR 0 4
99460: PUSH
99461: LD_VAR 0 7
99465: ARRAY
99466: PPUSH
99467: LD_VAR 0 23
99471: PPUSH
99472: CALL_OW 113
99476: GO 99684
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99478: LD_VAR 0 4
99482: PUSH
99483: LD_VAR 0 7
99487: ARRAY
99488: PPUSH
99489: CALL 98096 0 1
99493: PPUSH
99494: CALL_OW 256
99498: PUSH
99499: LD_INT 1000
99501: EQUAL
99502: IFFALSE 99521
// ComStop ( group [ i ] ) else
99504: LD_VAR 0 4
99508: PUSH
99509: LD_VAR 0 7
99513: ARRAY
99514: PPUSH
99515: CALL_OW 141
99519: GO 99684
// if not HasTask ( group [ i ] ) and to_heal then
99521: LD_VAR 0 4
99525: PUSH
99526: LD_VAR 0 7
99530: ARRAY
99531: PPUSH
99532: CALL_OW 314
99536: NOT
99537: PUSH
99538: LD_VAR 0 30
99542: AND
99543: IFFALSE 99684
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99545: LD_ADDR_VAR 0 13
99549: PUSH
99550: LD_VAR 0 30
99554: PPUSH
99555: LD_INT 3
99557: PUSH
99558: LD_INT 54
99560: PUSH
99561: EMPTY
99562: LIST
99563: PUSH
99564: EMPTY
99565: LIST
99566: LIST
99567: PPUSH
99568: CALL_OW 72
99572: PPUSH
99573: LD_VAR 0 4
99577: PUSH
99578: LD_VAR 0 7
99582: ARRAY
99583: PPUSH
99584: CALL_OW 74
99588: ST_TO_ADDR
// if z then
99589: LD_VAR 0 13
99593: IFFALSE 99684
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99595: LD_INT 91
99597: PUSH
99598: LD_VAR 0 13
99602: PUSH
99603: LD_INT 10
99605: PUSH
99606: EMPTY
99607: LIST
99608: LIST
99609: LIST
99610: PUSH
99611: LD_INT 81
99613: PUSH
99614: LD_VAR 0 13
99618: PPUSH
99619: CALL_OW 255
99623: PUSH
99624: EMPTY
99625: LIST
99626: LIST
99627: PUSH
99628: EMPTY
99629: LIST
99630: LIST
99631: PPUSH
99632: CALL_OW 69
99636: PUSH
99637: LD_INT 0
99639: EQUAL
99640: IFFALSE 99664
// ComHeal ( group [ i ] , z ) else
99642: LD_VAR 0 4
99646: PUSH
99647: LD_VAR 0 7
99651: ARRAY
99652: PPUSH
99653: LD_VAR 0 13
99657: PPUSH
99658: CALL_OW 128
99662: GO 99684
// ComMoveToArea ( group [ i ] , f_heal ) ;
99664: LD_VAR 0 4
99668: PUSH
99669: LD_VAR 0 7
99673: ARRAY
99674: PPUSH
99675: LD_VAR 0 23
99679: PPUSH
99680: CALL_OW 113
// end ; continue ;
99684: GO 98715
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99686: LD_VAR 0 4
99690: PUSH
99691: LD_VAR 0 7
99695: ARRAY
99696: PPUSH
99697: CALL_OW 256
99701: PUSH
99702: LD_INT 700
99704: LESS
99705: PUSH
99706: LD_VAR 0 4
99710: PUSH
99711: LD_VAR 0 7
99715: ARRAY
99716: PUSH
99717: LD_VAR 0 30
99721: IN
99722: NOT
99723: AND
99724: IFFALSE 99748
// to_heal := to_heal union group [ i ] ;
99726: LD_ADDR_VAR 0 30
99730: PUSH
99731: LD_VAR 0 30
99735: PUSH
99736: LD_VAR 0 4
99740: PUSH
99741: LD_VAR 0 7
99745: ARRAY
99746: UNION
99747: ST_TO_ADDR
// if group [ i ] in to_heal then
99748: LD_VAR 0 4
99752: PUSH
99753: LD_VAR 0 7
99757: ARRAY
99758: PUSH
99759: LD_VAR 0 30
99763: IN
99764: IFFALSE 99873
// begin if GetLives ( group [ i ] ) = 1000 then
99766: LD_VAR 0 4
99770: PUSH
99771: LD_VAR 0 7
99775: ARRAY
99776: PPUSH
99777: CALL_OW 256
99781: PUSH
99782: LD_INT 1000
99784: EQUAL
99785: IFFALSE 99811
// to_heal := to_heal diff group [ i ] else
99787: LD_ADDR_VAR 0 30
99791: PUSH
99792: LD_VAR 0 30
99796: PUSH
99797: LD_VAR 0 4
99801: PUSH
99802: LD_VAR 0 7
99806: ARRAY
99807: DIFF
99808: ST_TO_ADDR
99809: GO 99873
// begin if not IsInArea ( group [ i ] , to_heal ) then
99811: LD_VAR 0 4
99815: PUSH
99816: LD_VAR 0 7
99820: ARRAY
99821: PPUSH
99822: LD_VAR 0 30
99826: PPUSH
99827: CALL_OW 308
99831: NOT
99832: IFFALSE 99856
// ComMoveToArea ( group [ i ] , f_heal ) else
99834: LD_VAR 0 4
99838: PUSH
99839: LD_VAR 0 7
99843: ARRAY
99844: PPUSH
99845: LD_VAR 0 23
99849: PPUSH
99850: CALL_OW 113
99854: GO 99871
// ComHold ( group [ i ] ) ;
99856: LD_VAR 0 4
99860: PUSH
99861: LD_VAR 0 7
99865: ARRAY
99866: PPUSH
99867: CALL_OW 140
// continue ;
99871: GO 98715
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
99873: LD_VAR 0 4
99877: PUSH
99878: LD_VAR 0 7
99882: ARRAY
99883: PPUSH
99884: LD_INT 10
99886: PPUSH
99887: CALL 96493 0 2
99891: NOT
99892: PUSH
99893: LD_VAR 0 16
99897: PUSH
99898: LD_VAR 0 7
99902: ARRAY
99903: PUSH
99904: EMPTY
99905: EQUAL
99906: NOT
99907: AND
99908: IFFALSE 100174
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
99910: LD_VAR 0 4
99914: PUSH
99915: LD_VAR 0 7
99919: ARRAY
99920: PPUSH
99921: CALL_OW 262
99925: PUSH
99926: LD_INT 1
99928: PUSH
99929: LD_INT 2
99931: PUSH
99932: EMPTY
99933: LIST
99934: LIST
99935: IN
99936: IFFALSE 99977
// if GetFuel ( group [ i ] ) < 10 then
99938: LD_VAR 0 4
99942: PUSH
99943: LD_VAR 0 7
99947: ARRAY
99948: PPUSH
99949: CALL_OW 261
99953: PUSH
99954: LD_INT 10
99956: LESS
99957: IFFALSE 99977
// SetFuel ( group [ i ] , 12 ) ;
99959: LD_VAR 0 4
99963: PUSH
99964: LD_VAR 0 7
99968: ARRAY
99969: PPUSH
99970: LD_INT 12
99972: PPUSH
99973: CALL_OW 240
// if units_path [ i ] then
99977: LD_VAR 0 16
99981: PUSH
99982: LD_VAR 0 7
99986: ARRAY
99987: IFFALSE 100172
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
99989: LD_VAR 0 4
99993: PUSH
99994: LD_VAR 0 7
99998: ARRAY
99999: PPUSH
100000: LD_VAR 0 16
100004: PUSH
100005: LD_VAR 0 7
100009: ARRAY
100010: PUSH
100011: LD_INT 1
100013: ARRAY
100014: PUSH
100015: LD_INT 1
100017: ARRAY
100018: PPUSH
100019: LD_VAR 0 16
100023: PUSH
100024: LD_VAR 0 7
100028: ARRAY
100029: PUSH
100030: LD_INT 1
100032: ARRAY
100033: PUSH
100034: LD_INT 2
100036: ARRAY
100037: PPUSH
100038: CALL_OW 297
100042: PUSH
100043: LD_INT 6
100045: GREATER
100046: IFFALSE 100121
// begin if not HasTask ( group [ i ] ) then
100048: LD_VAR 0 4
100052: PUSH
100053: LD_VAR 0 7
100057: ARRAY
100058: PPUSH
100059: CALL_OW 314
100063: NOT
100064: IFFALSE 100119
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100066: LD_VAR 0 4
100070: PUSH
100071: LD_VAR 0 7
100075: ARRAY
100076: PPUSH
100077: LD_VAR 0 16
100081: PUSH
100082: LD_VAR 0 7
100086: ARRAY
100087: PUSH
100088: LD_INT 1
100090: ARRAY
100091: PUSH
100092: LD_INT 1
100094: ARRAY
100095: PPUSH
100096: LD_VAR 0 16
100100: PUSH
100101: LD_VAR 0 7
100105: ARRAY
100106: PUSH
100107: LD_INT 1
100109: ARRAY
100110: PUSH
100111: LD_INT 2
100113: ARRAY
100114: PPUSH
100115: CALL_OW 114
// end else
100119: GO 100172
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100121: LD_ADDR_VAR 0 15
100125: PUSH
100126: LD_VAR 0 16
100130: PUSH
100131: LD_VAR 0 7
100135: ARRAY
100136: PPUSH
100137: LD_INT 1
100139: PPUSH
100140: CALL_OW 3
100144: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100145: LD_ADDR_VAR 0 16
100149: PUSH
100150: LD_VAR 0 16
100154: PPUSH
100155: LD_VAR 0 7
100159: PPUSH
100160: LD_VAR 0 15
100164: PPUSH
100165: CALL_OW 1
100169: ST_TO_ADDR
// continue ;
100170: GO 98715
// end ; end ; end else
100172: GO 102810
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100174: LD_ADDR_VAR 0 14
100178: PUSH
100179: LD_INT 81
100181: PUSH
100182: LD_VAR 0 4
100186: PUSH
100187: LD_VAR 0 7
100191: ARRAY
100192: PPUSH
100193: CALL_OW 255
100197: PUSH
100198: EMPTY
100199: LIST
100200: LIST
100201: PPUSH
100202: CALL_OW 69
100206: ST_TO_ADDR
// if not tmp then
100207: LD_VAR 0 14
100211: NOT
100212: IFFALSE 100216
// continue ;
100214: GO 98715
// if f_ignore_area then
100216: LD_VAR 0 17
100220: IFFALSE 100308
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100222: LD_ADDR_VAR 0 15
100226: PUSH
100227: LD_VAR 0 14
100231: PPUSH
100232: LD_INT 3
100234: PUSH
100235: LD_INT 92
100237: PUSH
100238: LD_VAR 0 17
100242: PUSH
100243: LD_INT 1
100245: ARRAY
100246: PUSH
100247: LD_VAR 0 17
100251: PUSH
100252: LD_INT 2
100254: ARRAY
100255: PUSH
100256: LD_VAR 0 17
100260: PUSH
100261: LD_INT 3
100263: ARRAY
100264: PUSH
100265: EMPTY
100266: LIST
100267: LIST
100268: LIST
100269: LIST
100270: PUSH
100271: EMPTY
100272: LIST
100273: LIST
100274: PPUSH
100275: CALL_OW 72
100279: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100280: LD_VAR 0 14
100284: PUSH
100285: LD_VAR 0 15
100289: DIFF
100290: IFFALSE 100308
// tmp := tmp diff tmp2 ;
100292: LD_ADDR_VAR 0 14
100296: PUSH
100297: LD_VAR 0 14
100301: PUSH
100302: LD_VAR 0 15
100306: DIFF
100307: ST_TO_ADDR
// end ; if not f_murder then
100308: LD_VAR 0 20
100312: NOT
100313: IFFALSE 100371
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100315: LD_ADDR_VAR 0 15
100319: PUSH
100320: LD_VAR 0 14
100324: PPUSH
100325: LD_INT 3
100327: PUSH
100328: LD_INT 50
100330: PUSH
100331: EMPTY
100332: LIST
100333: PUSH
100334: EMPTY
100335: LIST
100336: LIST
100337: PPUSH
100338: CALL_OW 72
100342: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100343: LD_VAR 0 14
100347: PUSH
100348: LD_VAR 0 15
100352: DIFF
100353: IFFALSE 100371
// tmp := tmp diff tmp2 ;
100355: LD_ADDR_VAR 0 14
100359: PUSH
100360: LD_VAR 0 14
100364: PUSH
100365: LD_VAR 0 15
100369: DIFF
100370: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100371: LD_ADDR_VAR 0 14
100375: PUSH
100376: LD_VAR 0 4
100380: PUSH
100381: LD_VAR 0 7
100385: ARRAY
100386: PPUSH
100387: LD_VAR 0 14
100391: PPUSH
100392: LD_INT 1
100394: PPUSH
100395: LD_INT 1
100397: PPUSH
100398: CALL 70136 0 4
100402: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100403: LD_VAR 0 4
100407: PUSH
100408: LD_VAR 0 7
100412: ARRAY
100413: PPUSH
100414: CALL_OW 257
100418: PUSH
100419: LD_INT 1
100421: EQUAL
100422: IFFALSE 100870
// begin if WantPlant ( group [ i ] ) then
100424: LD_VAR 0 4
100428: PUSH
100429: LD_VAR 0 7
100433: ARRAY
100434: PPUSH
100435: CALL 69637 0 1
100439: IFFALSE 100443
// continue ;
100441: GO 98715
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100443: LD_VAR 0 18
100447: PUSH
100448: LD_VAR 0 4
100452: PUSH
100453: LD_VAR 0 7
100457: ARRAY
100458: PPUSH
100459: CALL_OW 310
100463: NOT
100464: AND
100465: PUSH
100466: LD_VAR 0 14
100470: PUSH
100471: LD_INT 1
100473: ARRAY
100474: PUSH
100475: LD_VAR 0 14
100479: PPUSH
100480: LD_INT 21
100482: PUSH
100483: LD_INT 2
100485: PUSH
100486: EMPTY
100487: LIST
100488: LIST
100489: PUSH
100490: LD_INT 58
100492: PUSH
100493: EMPTY
100494: LIST
100495: PUSH
100496: EMPTY
100497: LIST
100498: LIST
100499: PPUSH
100500: CALL_OW 72
100504: IN
100505: AND
100506: IFFALSE 100542
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100508: LD_VAR 0 4
100512: PUSH
100513: LD_VAR 0 7
100517: ARRAY
100518: PPUSH
100519: LD_VAR 0 14
100523: PUSH
100524: LD_INT 1
100526: ARRAY
100527: PPUSH
100528: CALL_OW 120
// attacking := true ;
100532: LD_ADDR_VAR 0 29
100536: PUSH
100537: LD_INT 1
100539: ST_TO_ADDR
// continue ;
100540: GO 98715
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100542: LD_VAR 0 26
100546: PUSH
100547: LD_VAR 0 4
100551: PUSH
100552: LD_VAR 0 7
100556: ARRAY
100557: PPUSH
100558: CALL_OW 257
100562: PUSH
100563: LD_INT 1
100565: EQUAL
100566: AND
100567: PUSH
100568: LD_VAR 0 4
100572: PUSH
100573: LD_VAR 0 7
100577: ARRAY
100578: PPUSH
100579: CALL_OW 256
100583: PUSH
100584: LD_INT 800
100586: LESS
100587: AND
100588: PUSH
100589: LD_VAR 0 4
100593: PUSH
100594: LD_VAR 0 7
100598: ARRAY
100599: PPUSH
100600: CALL_OW 318
100604: NOT
100605: AND
100606: IFFALSE 100623
// ComCrawl ( group [ i ] ) ;
100608: LD_VAR 0 4
100612: PUSH
100613: LD_VAR 0 7
100617: ARRAY
100618: PPUSH
100619: CALL_OW 137
// if f_mines then
100623: LD_VAR 0 21
100627: IFFALSE 100870
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100629: LD_VAR 0 14
100633: PUSH
100634: LD_INT 1
100636: ARRAY
100637: PPUSH
100638: CALL_OW 247
100642: PUSH
100643: LD_INT 3
100645: EQUAL
100646: PUSH
100647: LD_VAR 0 14
100651: PUSH
100652: LD_INT 1
100654: ARRAY
100655: PUSH
100656: LD_VAR 0 27
100660: IN
100661: NOT
100662: AND
100663: IFFALSE 100870
// begin x := GetX ( tmp [ 1 ] ) ;
100665: LD_ADDR_VAR 0 10
100669: PUSH
100670: LD_VAR 0 14
100674: PUSH
100675: LD_INT 1
100677: ARRAY
100678: PPUSH
100679: CALL_OW 250
100683: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100684: LD_ADDR_VAR 0 11
100688: PUSH
100689: LD_VAR 0 14
100693: PUSH
100694: LD_INT 1
100696: ARRAY
100697: PPUSH
100698: CALL_OW 251
100702: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100703: LD_ADDR_VAR 0 12
100707: PUSH
100708: LD_VAR 0 4
100712: PUSH
100713: LD_VAR 0 7
100717: ARRAY
100718: PPUSH
100719: CALL 96578 0 1
100723: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100724: LD_VAR 0 4
100728: PUSH
100729: LD_VAR 0 7
100733: ARRAY
100734: PPUSH
100735: LD_VAR 0 10
100739: PPUSH
100740: LD_VAR 0 11
100744: PPUSH
100745: LD_VAR 0 14
100749: PUSH
100750: LD_INT 1
100752: ARRAY
100753: PPUSH
100754: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
100758: LD_VAR 0 4
100762: PUSH
100763: LD_VAR 0 7
100767: ARRAY
100768: PPUSH
100769: LD_VAR 0 10
100773: PPUSH
100774: LD_VAR 0 12
100778: PPUSH
100779: LD_INT 7
100781: PPUSH
100782: CALL_OW 272
100786: PPUSH
100787: LD_VAR 0 11
100791: PPUSH
100792: LD_VAR 0 12
100796: PPUSH
100797: LD_INT 7
100799: PPUSH
100800: CALL_OW 273
100804: PPUSH
100805: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
100809: LD_VAR 0 4
100813: PUSH
100814: LD_VAR 0 7
100818: ARRAY
100819: PPUSH
100820: LD_INT 71
100822: PPUSH
100823: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
100827: LD_ADDR_VAR 0 27
100831: PUSH
100832: LD_VAR 0 27
100836: PPUSH
100837: LD_VAR 0 27
100841: PUSH
100842: LD_INT 1
100844: PLUS
100845: PPUSH
100846: LD_VAR 0 14
100850: PUSH
100851: LD_INT 1
100853: ARRAY
100854: PPUSH
100855: CALL_OW 1
100859: ST_TO_ADDR
// attacking := true ;
100860: LD_ADDR_VAR 0 29
100864: PUSH
100865: LD_INT 1
100867: ST_TO_ADDR
// continue ;
100868: GO 98715
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
100870: LD_VAR 0 4
100874: PUSH
100875: LD_VAR 0 7
100879: ARRAY
100880: PPUSH
100881: CALL_OW 257
100885: PUSH
100886: LD_INT 17
100888: EQUAL
100889: PUSH
100890: LD_VAR 0 4
100894: PUSH
100895: LD_VAR 0 7
100899: ARRAY
100900: PPUSH
100901: CALL_OW 110
100905: PUSH
100906: LD_INT 71
100908: EQUAL
100909: NOT
100910: AND
100911: IFFALSE 101057
// begin attacking := false ;
100913: LD_ADDR_VAR 0 29
100917: PUSH
100918: LD_INT 0
100920: ST_TO_ADDR
// k := 5 ;
100921: LD_ADDR_VAR 0 9
100925: PUSH
100926: LD_INT 5
100928: ST_TO_ADDR
// if tmp < k then
100929: LD_VAR 0 14
100933: PUSH
100934: LD_VAR 0 9
100938: LESS
100939: IFFALSE 100951
// k := tmp ;
100941: LD_ADDR_VAR 0 9
100945: PUSH
100946: LD_VAR 0 14
100950: ST_TO_ADDR
// for j = 1 to k do
100951: LD_ADDR_VAR 0 8
100955: PUSH
100956: DOUBLE
100957: LD_INT 1
100959: DEC
100960: ST_TO_ADDR
100961: LD_VAR 0 9
100965: PUSH
100966: FOR_TO
100967: IFFALSE 101055
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
100969: LD_VAR 0 14
100973: PUSH
100974: LD_VAR 0 8
100978: ARRAY
100979: PUSH
100980: LD_VAR 0 14
100984: PPUSH
100985: LD_INT 58
100987: PUSH
100988: EMPTY
100989: LIST
100990: PPUSH
100991: CALL_OW 72
100995: IN
100996: NOT
100997: IFFALSE 101053
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100999: LD_VAR 0 4
101003: PUSH
101004: LD_VAR 0 7
101008: ARRAY
101009: PPUSH
101010: LD_VAR 0 14
101014: PUSH
101015: LD_VAR 0 8
101019: ARRAY
101020: PPUSH
101021: CALL_OW 115
// attacking := true ;
101025: LD_ADDR_VAR 0 29
101029: PUSH
101030: LD_INT 1
101032: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101033: LD_VAR 0 4
101037: PUSH
101038: LD_VAR 0 7
101042: ARRAY
101043: PPUSH
101044: LD_INT 71
101046: PPUSH
101047: CALL_OW 109
// continue ;
101051: GO 100966
// end ; end ;
101053: GO 100966
101055: POP
101056: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101057: LD_VAR 0 4
101061: PUSH
101062: LD_VAR 0 7
101066: ARRAY
101067: PPUSH
101068: CALL_OW 257
101072: PUSH
101073: LD_INT 8
101075: EQUAL
101076: PUSH
101077: LD_VAR 0 4
101081: PUSH
101082: LD_VAR 0 7
101086: ARRAY
101087: PPUSH
101088: CALL_OW 264
101092: PUSH
101093: LD_INT 28
101095: PUSH
101096: LD_INT 45
101098: PUSH
101099: LD_INT 7
101101: PUSH
101102: LD_INT 47
101104: PUSH
101105: EMPTY
101106: LIST
101107: LIST
101108: LIST
101109: LIST
101110: IN
101111: OR
101112: IFFALSE 101342
// begin attacking := false ;
101114: LD_ADDR_VAR 0 29
101118: PUSH
101119: LD_INT 0
101121: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101122: LD_VAR 0 14
101126: PUSH
101127: LD_INT 1
101129: ARRAY
101130: PPUSH
101131: CALL_OW 266
101135: PUSH
101136: LD_INT 32
101138: PUSH
101139: LD_INT 31
101141: PUSH
101142: LD_INT 33
101144: PUSH
101145: LD_INT 4
101147: PUSH
101148: LD_INT 5
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: LIST
101155: LIST
101156: LIST
101157: IN
101158: IFFALSE 101342
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101160: LD_ADDR_VAR 0 9
101164: PUSH
101165: LD_VAR 0 14
101169: PUSH
101170: LD_INT 1
101172: ARRAY
101173: PPUSH
101174: CALL_OW 266
101178: PPUSH
101179: LD_VAR 0 14
101183: PUSH
101184: LD_INT 1
101186: ARRAY
101187: PPUSH
101188: CALL_OW 250
101192: PPUSH
101193: LD_VAR 0 14
101197: PUSH
101198: LD_INT 1
101200: ARRAY
101201: PPUSH
101202: CALL_OW 251
101206: PPUSH
101207: LD_VAR 0 14
101211: PUSH
101212: LD_INT 1
101214: ARRAY
101215: PPUSH
101216: CALL_OW 254
101220: PPUSH
101221: LD_VAR 0 14
101225: PUSH
101226: LD_INT 1
101228: ARRAY
101229: PPUSH
101230: CALL_OW 248
101234: PPUSH
101235: LD_INT 0
101237: PPUSH
101238: CALL 77948 0 6
101242: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101243: LD_ADDR_VAR 0 8
101247: PUSH
101248: LD_VAR 0 4
101252: PUSH
101253: LD_VAR 0 7
101257: ARRAY
101258: PPUSH
101259: LD_VAR 0 9
101263: PPUSH
101264: CALL 96641 0 2
101268: ST_TO_ADDR
// if j then
101269: LD_VAR 0 8
101273: IFFALSE 101342
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101275: LD_VAR 0 8
101279: PUSH
101280: LD_INT 1
101282: ARRAY
101283: PPUSH
101284: LD_VAR 0 8
101288: PUSH
101289: LD_INT 2
101291: ARRAY
101292: PPUSH
101293: CALL_OW 488
101297: IFFALSE 101342
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101299: LD_VAR 0 4
101303: PUSH
101304: LD_VAR 0 7
101308: ARRAY
101309: PPUSH
101310: LD_VAR 0 8
101314: PUSH
101315: LD_INT 1
101317: ARRAY
101318: PPUSH
101319: LD_VAR 0 8
101323: PUSH
101324: LD_INT 2
101326: ARRAY
101327: PPUSH
101328: CALL_OW 116
// attacking := true ;
101332: LD_ADDR_VAR 0 29
101336: PUSH
101337: LD_INT 1
101339: ST_TO_ADDR
// continue ;
101340: GO 98715
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101342: LD_VAR 0 4
101346: PUSH
101347: LD_VAR 0 7
101351: ARRAY
101352: PPUSH
101353: CALL_OW 265
101357: PUSH
101358: LD_INT 11
101360: EQUAL
101361: IFFALSE 101639
// begin k := 10 ;
101363: LD_ADDR_VAR 0 9
101367: PUSH
101368: LD_INT 10
101370: ST_TO_ADDR
// x := 0 ;
101371: LD_ADDR_VAR 0 10
101375: PUSH
101376: LD_INT 0
101378: ST_TO_ADDR
// if tmp < k then
101379: LD_VAR 0 14
101383: PUSH
101384: LD_VAR 0 9
101388: LESS
101389: IFFALSE 101401
// k := tmp ;
101391: LD_ADDR_VAR 0 9
101395: PUSH
101396: LD_VAR 0 14
101400: ST_TO_ADDR
// for j = k downto 1 do
101401: LD_ADDR_VAR 0 8
101405: PUSH
101406: DOUBLE
101407: LD_VAR 0 9
101411: INC
101412: ST_TO_ADDR
101413: LD_INT 1
101415: PUSH
101416: FOR_DOWNTO
101417: IFFALSE 101492
// begin if GetType ( tmp [ j ] ) = unit_human then
101419: LD_VAR 0 14
101423: PUSH
101424: LD_VAR 0 8
101428: ARRAY
101429: PPUSH
101430: CALL_OW 247
101434: PUSH
101435: LD_INT 1
101437: EQUAL
101438: IFFALSE 101490
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101440: LD_VAR 0 4
101444: PUSH
101445: LD_VAR 0 7
101449: ARRAY
101450: PPUSH
101451: LD_VAR 0 14
101455: PUSH
101456: LD_VAR 0 8
101460: ARRAY
101461: PPUSH
101462: CALL 96912 0 2
// x := tmp [ j ] ;
101466: LD_ADDR_VAR 0 10
101470: PUSH
101471: LD_VAR 0 14
101475: PUSH
101476: LD_VAR 0 8
101480: ARRAY
101481: ST_TO_ADDR
// attacking := true ;
101482: LD_ADDR_VAR 0 29
101486: PUSH
101487: LD_INT 1
101489: ST_TO_ADDR
// end ; end ;
101490: GO 101416
101492: POP
101493: POP
// if not x then
101494: LD_VAR 0 10
101498: NOT
101499: IFFALSE 101639
// begin attacking := true ;
101501: LD_ADDR_VAR 0 29
101505: PUSH
101506: LD_INT 1
101508: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101509: LD_VAR 0 4
101513: PUSH
101514: LD_VAR 0 7
101518: ARRAY
101519: PPUSH
101520: CALL_OW 250
101524: PPUSH
101525: LD_VAR 0 4
101529: PUSH
101530: LD_VAR 0 7
101534: ARRAY
101535: PPUSH
101536: CALL_OW 251
101540: PPUSH
101541: CALL_OW 546
101545: PUSH
101546: LD_INT 2
101548: ARRAY
101549: PUSH
101550: LD_VAR 0 14
101554: PUSH
101555: LD_INT 1
101557: ARRAY
101558: PPUSH
101559: CALL_OW 250
101563: PPUSH
101564: LD_VAR 0 14
101568: PUSH
101569: LD_INT 1
101571: ARRAY
101572: PPUSH
101573: CALL_OW 251
101577: PPUSH
101578: CALL_OW 546
101582: PUSH
101583: LD_INT 2
101585: ARRAY
101586: EQUAL
101587: IFFALSE 101615
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101589: LD_VAR 0 4
101593: PUSH
101594: LD_VAR 0 7
101598: ARRAY
101599: PPUSH
101600: LD_VAR 0 14
101604: PUSH
101605: LD_INT 1
101607: ARRAY
101608: PPUSH
101609: CALL 96912 0 2
101613: GO 101639
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101615: LD_VAR 0 4
101619: PUSH
101620: LD_VAR 0 7
101624: ARRAY
101625: PPUSH
101626: LD_VAR 0 14
101630: PUSH
101631: LD_INT 1
101633: ARRAY
101634: PPUSH
101635: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101639: LD_VAR 0 4
101643: PUSH
101644: LD_VAR 0 7
101648: ARRAY
101649: PPUSH
101650: CALL_OW 264
101654: PUSH
101655: LD_INT 29
101657: EQUAL
101658: IFFALSE 102024
// begin if WantsToAttack ( group [ i ] ) in bombed then
101660: LD_VAR 0 4
101664: PUSH
101665: LD_VAR 0 7
101669: ARRAY
101670: PPUSH
101671: CALL_OW 319
101675: PUSH
101676: LD_VAR 0 28
101680: IN
101681: IFFALSE 101685
// continue ;
101683: GO 98715
// k := 8 ;
101685: LD_ADDR_VAR 0 9
101689: PUSH
101690: LD_INT 8
101692: ST_TO_ADDR
// x := 0 ;
101693: LD_ADDR_VAR 0 10
101697: PUSH
101698: LD_INT 0
101700: ST_TO_ADDR
// if tmp < k then
101701: LD_VAR 0 14
101705: PUSH
101706: LD_VAR 0 9
101710: LESS
101711: IFFALSE 101723
// k := tmp ;
101713: LD_ADDR_VAR 0 9
101717: PUSH
101718: LD_VAR 0 14
101722: ST_TO_ADDR
// for j = 1 to k do
101723: LD_ADDR_VAR 0 8
101727: PUSH
101728: DOUBLE
101729: LD_INT 1
101731: DEC
101732: ST_TO_ADDR
101733: LD_VAR 0 9
101737: PUSH
101738: FOR_TO
101739: IFFALSE 101871
// begin if GetType ( tmp [ j ] ) = unit_building then
101741: LD_VAR 0 14
101745: PUSH
101746: LD_VAR 0 8
101750: ARRAY
101751: PPUSH
101752: CALL_OW 247
101756: PUSH
101757: LD_INT 3
101759: EQUAL
101760: IFFALSE 101869
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
101762: LD_VAR 0 14
101766: PUSH
101767: LD_VAR 0 8
101771: ARRAY
101772: PUSH
101773: LD_VAR 0 28
101777: IN
101778: NOT
101779: PUSH
101780: LD_VAR 0 14
101784: PUSH
101785: LD_VAR 0 8
101789: ARRAY
101790: PPUSH
101791: CALL_OW 313
101795: AND
101796: IFFALSE 101869
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101798: LD_VAR 0 4
101802: PUSH
101803: LD_VAR 0 7
101807: ARRAY
101808: PPUSH
101809: LD_VAR 0 14
101813: PUSH
101814: LD_VAR 0 8
101818: ARRAY
101819: PPUSH
101820: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
101824: LD_ADDR_VAR 0 28
101828: PUSH
101829: LD_VAR 0 28
101833: PPUSH
101834: LD_VAR 0 28
101838: PUSH
101839: LD_INT 1
101841: PLUS
101842: PPUSH
101843: LD_VAR 0 14
101847: PUSH
101848: LD_VAR 0 8
101852: ARRAY
101853: PPUSH
101854: CALL_OW 1
101858: ST_TO_ADDR
// attacking := true ;
101859: LD_ADDR_VAR 0 29
101863: PUSH
101864: LD_INT 1
101866: ST_TO_ADDR
// break ;
101867: GO 101871
// end ; end ;
101869: GO 101738
101871: POP
101872: POP
// if not attacking and f_attack_depot then
101873: LD_VAR 0 29
101877: NOT
101878: PUSH
101879: LD_VAR 0 25
101883: AND
101884: IFFALSE 101979
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101886: LD_ADDR_VAR 0 13
101890: PUSH
101891: LD_VAR 0 14
101895: PPUSH
101896: LD_INT 2
101898: PUSH
101899: LD_INT 30
101901: PUSH
101902: LD_INT 0
101904: PUSH
101905: EMPTY
101906: LIST
101907: LIST
101908: PUSH
101909: LD_INT 30
101911: PUSH
101912: LD_INT 1
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: LIST
101923: PPUSH
101924: CALL_OW 72
101928: ST_TO_ADDR
// if z then
101929: LD_VAR 0 13
101933: IFFALSE 101979
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
101935: LD_VAR 0 4
101939: PUSH
101940: LD_VAR 0 7
101944: ARRAY
101945: PPUSH
101946: LD_VAR 0 13
101950: PPUSH
101951: LD_VAR 0 4
101955: PUSH
101956: LD_VAR 0 7
101960: ARRAY
101961: PPUSH
101962: CALL_OW 74
101966: PPUSH
101967: CALL_OW 115
// attacking := true ;
101971: LD_ADDR_VAR 0 29
101975: PUSH
101976: LD_INT 1
101978: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
101979: LD_VAR 0 4
101983: PUSH
101984: LD_VAR 0 7
101988: ARRAY
101989: PPUSH
101990: CALL_OW 256
101994: PUSH
101995: LD_INT 500
101997: LESS
101998: IFFALSE 102024
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102000: LD_VAR 0 4
102004: PUSH
102005: LD_VAR 0 7
102009: ARRAY
102010: PPUSH
102011: LD_VAR 0 14
102015: PUSH
102016: LD_INT 1
102018: ARRAY
102019: PPUSH
102020: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102024: LD_VAR 0 4
102028: PUSH
102029: LD_VAR 0 7
102033: ARRAY
102034: PPUSH
102035: CALL_OW 264
102039: PUSH
102040: LD_INT 49
102042: EQUAL
102043: IFFALSE 102164
// begin if not HasTask ( group [ i ] ) then
102045: LD_VAR 0 4
102049: PUSH
102050: LD_VAR 0 7
102054: ARRAY
102055: PPUSH
102056: CALL_OW 314
102060: NOT
102061: IFFALSE 102164
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102063: LD_ADDR_VAR 0 9
102067: PUSH
102068: LD_INT 81
102070: PUSH
102071: LD_VAR 0 4
102075: PUSH
102076: LD_VAR 0 7
102080: ARRAY
102081: PPUSH
102082: CALL_OW 255
102086: PUSH
102087: EMPTY
102088: LIST
102089: LIST
102090: PPUSH
102091: CALL_OW 69
102095: PPUSH
102096: LD_VAR 0 4
102100: PUSH
102101: LD_VAR 0 7
102105: ARRAY
102106: PPUSH
102107: CALL_OW 74
102111: ST_TO_ADDR
// if k then
102112: LD_VAR 0 9
102116: IFFALSE 102164
// if GetDistUnits ( group [ i ] , k ) > 10 then
102118: LD_VAR 0 4
102122: PUSH
102123: LD_VAR 0 7
102127: ARRAY
102128: PPUSH
102129: LD_VAR 0 9
102133: PPUSH
102134: CALL_OW 296
102138: PUSH
102139: LD_INT 10
102141: GREATER
102142: IFFALSE 102164
// ComMoveUnit ( group [ i ] , k ) ;
102144: LD_VAR 0 4
102148: PUSH
102149: LD_VAR 0 7
102153: ARRAY
102154: PPUSH
102155: LD_VAR 0 9
102159: PPUSH
102160: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102164: LD_VAR 0 4
102168: PUSH
102169: LD_VAR 0 7
102173: ARRAY
102174: PPUSH
102175: CALL_OW 256
102179: PUSH
102180: LD_INT 250
102182: LESS
102183: PUSH
102184: LD_VAR 0 4
102188: PUSH
102189: LD_VAR 0 7
102193: ARRAY
102194: PUSH
102195: LD_INT 21
102197: PUSH
102198: LD_INT 2
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: PUSH
102205: LD_INT 23
102207: PUSH
102208: LD_INT 2
102210: PUSH
102211: EMPTY
102212: LIST
102213: LIST
102214: PUSH
102215: EMPTY
102216: LIST
102217: LIST
102218: PPUSH
102219: CALL_OW 69
102223: IN
102224: AND
102225: IFFALSE 102350
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102227: LD_ADDR_VAR 0 9
102231: PUSH
102232: LD_OWVAR 3
102236: PUSH
102237: LD_VAR 0 4
102241: PUSH
102242: LD_VAR 0 7
102246: ARRAY
102247: DIFF
102248: PPUSH
102249: LD_VAR 0 4
102253: PUSH
102254: LD_VAR 0 7
102258: ARRAY
102259: PPUSH
102260: CALL_OW 74
102264: ST_TO_ADDR
// if not k then
102265: LD_VAR 0 9
102269: NOT
102270: IFFALSE 102274
// continue ;
102272: GO 98715
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102274: LD_VAR 0 9
102278: PUSH
102279: LD_INT 81
102281: PUSH
102282: LD_VAR 0 4
102286: PUSH
102287: LD_VAR 0 7
102291: ARRAY
102292: PPUSH
102293: CALL_OW 255
102297: PUSH
102298: EMPTY
102299: LIST
102300: LIST
102301: PPUSH
102302: CALL_OW 69
102306: IN
102307: PUSH
102308: LD_VAR 0 9
102312: PPUSH
102313: LD_VAR 0 4
102317: PUSH
102318: LD_VAR 0 7
102322: ARRAY
102323: PPUSH
102324: CALL_OW 296
102328: PUSH
102329: LD_INT 5
102331: LESS
102332: AND
102333: IFFALSE 102350
// ComAutodestruct ( group [ i ] ) ;
102335: LD_VAR 0 4
102339: PUSH
102340: LD_VAR 0 7
102344: ARRAY
102345: PPUSH
102346: CALL 96810 0 1
// end ; if f_attack_depot then
102350: LD_VAR 0 25
102354: IFFALSE 102466
// begin k := 6 ;
102356: LD_ADDR_VAR 0 9
102360: PUSH
102361: LD_INT 6
102363: ST_TO_ADDR
// if tmp < k then
102364: LD_VAR 0 14
102368: PUSH
102369: LD_VAR 0 9
102373: LESS
102374: IFFALSE 102386
// k := tmp ;
102376: LD_ADDR_VAR 0 9
102380: PUSH
102381: LD_VAR 0 14
102385: ST_TO_ADDR
// for j = 1 to k do
102386: LD_ADDR_VAR 0 8
102390: PUSH
102391: DOUBLE
102392: LD_INT 1
102394: DEC
102395: ST_TO_ADDR
102396: LD_VAR 0 9
102400: PUSH
102401: FOR_TO
102402: IFFALSE 102464
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102404: LD_VAR 0 8
102408: PPUSH
102409: CALL_OW 266
102413: PUSH
102414: LD_INT 0
102416: PUSH
102417: LD_INT 1
102419: PUSH
102420: EMPTY
102421: LIST
102422: LIST
102423: IN
102424: IFFALSE 102462
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102426: LD_VAR 0 4
102430: PUSH
102431: LD_VAR 0 7
102435: ARRAY
102436: PPUSH
102437: LD_VAR 0 14
102441: PUSH
102442: LD_VAR 0 8
102446: ARRAY
102447: PPUSH
102448: CALL_OW 115
// attacking := true ;
102452: LD_ADDR_VAR 0 29
102456: PUSH
102457: LD_INT 1
102459: ST_TO_ADDR
// break ;
102460: GO 102464
// end ;
102462: GO 102401
102464: POP
102465: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102466: LD_VAR 0 4
102470: PUSH
102471: LD_VAR 0 7
102475: ARRAY
102476: PPUSH
102477: CALL_OW 302
102481: PUSH
102482: LD_VAR 0 29
102486: NOT
102487: AND
102488: IFFALSE 102810
// begin if GetTag ( group [ i ] ) = 71 then
102490: LD_VAR 0 4
102494: PUSH
102495: LD_VAR 0 7
102499: ARRAY
102500: PPUSH
102501: CALL_OW 110
102505: PUSH
102506: LD_INT 71
102508: EQUAL
102509: IFFALSE 102550
// begin if HasTask ( group [ i ] ) then
102511: LD_VAR 0 4
102515: PUSH
102516: LD_VAR 0 7
102520: ARRAY
102521: PPUSH
102522: CALL_OW 314
102526: IFFALSE 102532
// continue else
102528: GO 98715
102530: GO 102550
// SetTag ( group [ i ] , 0 ) ;
102532: LD_VAR 0 4
102536: PUSH
102537: LD_VAR 0 7
102541: ARRAY
102542: PPUSH
102543: LD_INT 0
102545: PPUSH
102546: CALL_OW 109
// end ; k := 8 ;
102550: LD_ADDR_VAR 0 9
102554: PUSH
102555: LD_INT 8
102557: ST_TO_ADDR
// x := 0 ;
102558: LD_ADDR_VAR 0 10
102562: PUSH
102563: LD_INT 0
102565: ST_TO_ADDR
// if tmp < k then
102566: LD_VAR 0 14
102570: PUSH
102571: LD_VAR 0 9
102575: LESS
102576: IFFALSE 102588
// k := tmp ;
102578: LD_ADDR_VAR 0 9
102582: PUSH
102583: LD_VAR 0 14
102587: ST_TO_ADDR
// for j = 1 to k do
102588: LD_ADDR_VAR 0 8
102592: PUSH
102593: DOUBLE
102594: LD_INT 1
102596: DEC
102597: ST_TO_ADDR
102598: LD_VAR 0 9
102602: PUSH
102603: FOR_TO
102604: IFFALSE 102702
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102606: LD_VAR 0 14
102610: PUSH
102611: LD_VAR 0 8
102615: ARRAY
102616: PPUSH
102617: CALL_OW 247
102621: PUSH
102622: LD_INT 1
102624: EQUAL
102625: PUSH
102626: LD_VAR 0 14
102630: PUSH
102631: LD_VAR 0 8
102635: ARRAY
102636: PPUSH
102637: CALL_OW 256
102641: PUSH
102642: LD_INT 250
102644: LESS
102645: PUSH
102646: LD_VAR 0 20
102650: AND
102651: PUSH
102652: LD_VAR 0 20
102656: NOT
102657: PUSH
102658: LD_VAR 0 14
102662: PUSH
102663: LD_VAR 0 8
102667: ARRAY
102668: PPUSH
102669: CALL_OW 256
102673: PUSH
102674: LD_INT 250
102676: GREATEREQUAL
102677: AND
102678: OR
102679: AND
102680: IFFALSE 102700
// begin x := tmp [ j ] ;
102682: LD_ADDR_VAR 0 10
102686: PUSH
102687: LD_VAR 0 14
102691: PUSH
102692: LD_VAR 0 8
102696: ARRAY
102697: ST_TO_ADDR
// break ;
102698: GO 102702
// end ;
102700: GO 102603
102702: POP
102703: POP
// if x then
102704: LD_VAR 0 10
102708: IFFALSE 102732
// ComAttackUnit ( group [ i ] , x ) else
102710: LD_VAR 0 4
102714: PUSH
102715: LD_VAR 0 7
102719: ARRAY
102720: PPUSH
102721: LD_VAR 0 10
102725: PPUSH
102726: CALL_OW 115
102730: GO 102756
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102732: LD_VAR 0 4
102736: PUSH
102737: LD_VAR 0 7
102741: ARRAY
102742: PPUSH
102743: LD_VAR 0 14
102747: PUSH
102748: LD_INT 1
102750: ARRAY
102751: PPUSH
102752: CALL_OW 115
// if not HasTask ( group [ i ] ) then
102756: LD_VAR 0 4
102760: PUSH
102761: LD_VAR 0 7
102765: ARRAY
102766: PPUSH
102767: CALL_OW 314
102771: NOT
102772: IFFALSE 102810
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
102774: LD_VAR 0 4
102778: PUSH
102779: LD_VAR 0 7
102783: ARRAY
102784: PPUSH
102785: LD_VAR 0 14
102789: PPUSH
102790: LD_VAR 0 4
102794: PUSH
102795: LD_VAR 0 7
102799: ARRAY
102800: PPUSH
102801: CALL_OW 74
102805: PPUSH
102806: CALL_OW 115
// end ; end ; end ;
102810: GO 98715
102812: POP
102813: POP
// wait ( 0 0$1 ) ;
102814: LD_INT 35
102816: PPUSH
102817: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
102821: LD_VAR 0 4
102825: PUSH
102826: EMPTY
102827: EQUAL
102828: PUSH
102829: LD_INT 81
102831: PUSH
102832: LD_VAR 0 35
102836: PUSH
102837: EMPTY
102838: LIST
102839: LIST
102840: PPUSH
102841: CALL_OW 69
102845: NOT
102846: OR
102847: IFFALSE 98700
// end ;
102849: LD_VAR 0 2
102853: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102854: LD_INT 0
102856: PPUSH
102857: PPUSH
102858: PPUSH
102859: PPUSH
// if not base_units then
102860: LD_VAR 0 1
102864: NOT
102865: IFFALSE 102869
// exit ;
102867: GO 102956
// result := false ;
102869: LD_ADDR_VAR 0 2
102873: PUSH
102874: LD_INT 0
102876: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102877: LD_ADDR_VAR 0 5
102881: PUSH
102882: LD_VAR 0 1
102886: PPUSH
102887: LD_INT 21
102889: PUSH
102890: LD_INT 3
102892: PUSH
102893: EMPTY
102894: LIST
102895: LIST
102896: PPUSH
102897: CALL_OW 72
102901: ST_TO_ADDR
// if not tmp then
102902: LD_VAR 0 5
102906: NOT
102907: IFFALSE 102911
// exit ;
102909: GO 102956
// for i in tmp do
102911: LD_ADDR_VAR 0 3
102915: PUSH
102916: LD_VAR 0 5
102920: PUSH
102921: FOR_IN
102922: IFFALSE 102954
// begin result := EnemyInRange ( i , 22 ) ;
102924: LD_ADDR_VAR 0 2
102928: PUSH
102929: LD_VAR 0 3
102933: PPUSH
102934: LD_INT 22
102936: PPUSH
102937: CALL 96493 0 2
102941: ST_TO_ADDR
// if result then
102942: LD_VAR 0 2
102946: IFFALSE 102952
// exit ;
102948: POP
102949: POP
102950: GO 102956
// end ;
102952: GO 102921
102954: POP
102955: POP
// end ;
102956: LD_VAR 0 2
102960: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
102961: LD_INT 0
102963: PPUSH
102964: PPUSH
// if not units then
102965: LD_VAR 0 1
102969: NOT
102970: IFFALSE 102974
// exit ;
102972: GO 103044
// result := [ ] ;
102974: LD_ADDR_VAR 0 3
102978: PUSH
102979: EMPTY
102980: ST_TO_ADDR
// for i in units do
102981: LD_ADDR_VAR 0 4
102985: PUSH
102986: LD_VAR 0 1
102990: PUSH
102991: FOR_IN
102992: IFFALSE 103042
// if GetTag ( i ) = tag then
102994: LD_VAR 0 4
102998: PPUSH
102999: CALL_OW 110
103003: PUSH
103004: LD_VAR 0 2
103008: EQUAL
103009: IFFALSE 103040
// result := Insert ( result , result + 1 , i ) ;
103011: LD_ADDR_VAR 0 3
103015: PUSH
103016: LD_VAR 0 3
103020: PPUSH
103021: LD_VAR 0 3
103025: PUSH
103026: LD_INT 1
103028: PLUS
103029: PPUSH
103030: LD_VAR 0 4
103034: PPUSH
103035: CALL_OW 2
103039: ST_TO_ADDR
103040: GO 102991
103042: POP
103043: POP
// end ;
103044: LD_VAR 0 3
103048: RET
// export function IsDriver ( un ) ; begin
103049: LD_INT 0
103051: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
103052: LD_ADDR_VAR 0 2
103056: PUSH
103057: LD_VAR 0 1
103061: PUSH
103062: LD_INT 55
103064: PUSH
103065: EMPTY
103066: LIST
103067: PPUSH
103068: CALL_OW 69
103072: IN
103073: ST_TO_ADDR
// end ;
103074: LD_VAR 0 2
103078: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103079: LD_INT 0
103081: PPUSH
103082: PPUSH
// list := [ ] ;
103083: LD_ADDR_VAR 0 5
103087: PUSH
103088: EMPTY
103089: ST_TO_ADDR
// case d of 0 :
103090: LD_VAR 0 3
103094: PUSH
103095: LD_INT 0
103097: DOUBLE
103098: EQUAL
103099: IFTRUE 103103
103101: GO 103236
103103: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103104: LD_ADDR_VAR 0 5
103108: PUSH
103109: LD_VAR 0 1
103113: PUSH
103114: LD_INT 4
103116: MINUS
103117: PUSH
103118: LD_VAR 0 2
103122: PUSH
103123: LD_INT 4
103125: MINUS
103126: PUSH
103127: LD_INT 2
103129: PUSH
103130: EMPTY
103131: LIST
103132: LIST
103133: LIST
103134: PUSH
103135: LD_VAR 0 1
103139: PUSH
103140: LD_INT 3
103142: MINUS
103143: PUSH
103144: LD_VAR 0 2
103148: PUSH
103149: LD_INT 1
103151: PUSH
103152: EMPTY
103153: LIST
103154: LIST
103155: LIST
103156: PUSH
103157: LD_VAR 0 1
103161: PUSH
103162: LD_INT 4
103164: PLUS
103165: PUSH
103166: LD_VAR 0 2
103170: PUSH
103171: LD_INT 4
103173: PUSH
103174: EMPTY
103175: LIST
103176: LIST
103177: LIST
103178: PUSH
103179: LD_VAR 0 1
103183: PUSH
103184: LD_INT 3
103186: PLUS
103187: PUSH
103188: LD_VAR 0 2
103192: PUSH
103193: LD_INT 3
103195: PLUS
103196: PUSH
103197: LD_INT 5
103199: PUSH
103200: EMPTY
103201: LIST
103202: LIST
103203: LIST
103204: PUSH
103205: LD_VAR 0 1
103209: PUSH
103210: LD_VAR 0 2
103214: PUSH
103215: LD_INT 4
103217: PLUS
103218: PUSH
103219: LD_INT 0
103221: PUSH
103222: EMPTY
103223: LIST
103224: LIST
103225: LIST
103226: PUSH
103227: EMPTY
103228: LIST
103229: LIST
103230: LIST
103231: LIST
103232: LIST
103233: ST_TO_ADDR
// end ; 1 :
103234: GO 103934
103236: LD_INT 1
103238: DOUBLE
103239: EQUAL
103240: IFTRUE 103244
103242: GO 103377
103244: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103245: LD_ADDR_VAR 0 5
103249: PUSH
103250: LD_VAR 0 1
103254: PUSH
103255: LD_VAR 0 2
103259: PUSH
103260: LD_INT 4
103262: MINUS
103263: PUSH
103264: LD_INT 3
103266: PUSH
103267: EMPTY
103268: LIST
103269: LIST
103270: LIST
103271: PUSH
103272: LD_VAR 0 1
103276: PUSH
103277: LD_INT 3
103279: MINUS
103280: PUSH
103281: LD_VAR 0 2
103285: PUSH
103286: LD_INT 3
103288: MINUS
103289: PUSH
103290: LD_INT 2
103292: PUSH
103293: EMPTY
103294: LIST
103295: LIST
103296: LIST
103297: PUSH
103298: LD_VAR 0 1
103302: PUSH
103303: LD_INT 4
103305: MINUS
103306: PUSH
103307: LD_VAR 0 2
103311: PUSH
103312: LD_INT 1
103314: PUSH
103315: EMPTY
103316: LIST
103317: LIST
103318: LIST
103319: PUSH
103320: LD_VAR 0 1
103324: PUSH
103325: LD_VAR 0 2
103329: PUSH
103330: LD_INT 3
103332: PLUS
103333: PUSH
103334: LD_INT 0
103336: PUSH
103337: EMPTY
103338: LIST
103339: LIST
103340: LIST
103341: PUSH
103342: LD_VAR 0 1
103346: PUSH
103347: LD_INT 4
103349: PLUS
103350: PUSH
103351: LD_VAR 0 2
103355: PUSH
103356: LD_INT 4
103358: PLUS
103359: PUSH
103360: LD_INT 5
103362: PUSH
103363: EMPTY
103364: LIST
103365: LIST
103366: LIST
103367: PUSH
103368: EMPTY
103369: LIST
103370: LIST
103371: LIST
103372: LIST
103373: LIST
103374: ST_TO_ADDR
// end ; 2 :
103375: GO 103934
103377: LD_INT 2
103379: DOUBLE
103380: EQUAL
103381: IFTRUE 103385
103383: GO 103514
103385: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
103386: LD_ADDR_VAR 0 5
103390: PUSH
103391: LD_VAR 0 1
103395: PUSH
103396: LD_VAR 0 2
103400: PUSH
103401: LD_INT 3
103403: MINUS
103404: PUSH
103405: LD_INT 3
103407: PUSH
103408: EMPTY
103409: LIST
103410: LIST
103411: LIST
103412: PUSH
103413: LD_VAR 0 1
103417: PUSH
103418: LD_INT 4
103420: PLUS
103421: PUSH
103422: LD_VAR 0 2
103426: PUSH
103427: LD_INT 4
103429: PUSH
103430: EMPTY
103431: LIST
103432: LIST
103433: LIST
103434: PUSH
103435: LD_VAR 0 1
103439: PUSH
103440: LD_VAR 0 2
103444: PUSH
103445: LD_INT 4
103447: PLUS
103448: PUSH
103449: LD_INT 0
103451: PUSH
103452: EMPTY
103453: LIST
103454: LIST
103455: LIST
103456: PUSH
103457: LD_VAR 0 1
103461: PUSH
103462: LD_INT 3
103464: MINUS
103465: PUSH
103466: LD_VAR 0 2
103470: PUSH
103471: LD_INT 1
103473: PUSH
103474: EMPTY
103475: LIST
103476: LIST
103477: LIST
103478: PUSH
103479: LD_VAR 0 1
103483: PUSH
103484: LD_INT 4
103486: MINUS
103487: PUSH
103488: LD_VAR 0 2
103492: PUSH
103493: LD_INT 4
103495: MINUS
103496: PUSH
103497: LD_INT 2
103499: PUSH
103500: EMPTY
103501: LIST
103502: LIST
103503: LIST
103504: PUSH
103505: EMPTY
103506: LIST
103507: LIST
103508: LIST
103509: LIST
103510: LIST
103511: ST_TO_ADDR
// end ; 3 :
103512: GO 103934
103514: LD_INT 3
103516: DOUBLE
103517: EQUAL
103518: IFTRUE 103522
103520: GO 103655
103522: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103523: LD_ADDR_VAR 0 5
103527: PUSH
103528: LD_VAR 0 1
103532: PUSH
103533: LD_INT 3
103535: PLUS
103536: PUSH
103537: LD_VAR 0 2
103541: PUSH
103542: LD_INT 4
103544: PUSH
103545: EMPTY
103546: LIST
103547: LIST
103548: LIST
103549: PUSH
103550: LD_VAR 0 1
103554: PUSH
103555: LD_INT 4
103557: PLUS
103558: PUSH
103559: LD_VAR 0 2
103563: PUSH
103564: LD_INT 4
103566: PLUS
103567: PUSH
103568: LD_INT 5
103570: PUSH
103571: EMPTY
103572: LIST
103573: LIST
103574: LIST
103575: PUSH
103576: LD_VAR 0 1
103580: PUSH
103581: LD_INT 4
103583: MINUS
103584: PUSH
103585: LD_VAR 0 2
103589: PUSH
103590: LD_INT 1
103592: PUSH
103593: EMPTY
103594: LIST
103595: LIST
103596: LIST
103597: PUSH
103598: LD_VAR 0 1
103602: PUSH
103603: LD_VAR 0 2
103607: PUSH
103608: LD_INT 4
103610: MINUS
103611: PUSH
103612: LD_INT 3
103614: PUSH
103615: EMPTY
103616: LIST
103617: LIST
103618: LIST
103619: PUSH
103620: LD_VAR 0 1
103624: PUSH
103625: LD_INT 3
103627: MINUS
103628: PUSH
103629: LD_VAR 0 2
103633: PUSH
103634: LD_INT 3
103636: MINUS
103637: PUSH
103638: LD_INT 2
103640: PUSH
103641: EMPTY
103642: LIST
103643: LIST
103644: LIST
103645: PUSH
103646: EMPTY
103647: LIST
103648: LIST
103649: LIST
103650: LIST
103651: LIST
103652: ST_TO_ADDR
// end ; 4 :
103653: GO 103934
103655: LD_INT 4
103657: DOUBLE
103658: EQUAL
103659: IFTRUE 103663
103661: GO 103796
103663: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103664: LD_ADDR_VAR 0 5
103668: PUSH
103669: LD_VAR 0 1
103673: PUSH
103674: LD_VAR 0 2
103678: PUSH
103679: LD_INT 4
103681: PLUS
103682: PUSH
103683: LD_INT 0
103685: PUSH
103686: EMPTY
103687: LIST
103688: LIST
103689: LIST
103690: PUSH
103691: LD_VAR 0 1
103695: PUSH
103696: LD_INT 3
103698: PLUS
103699: PUSH
103700: LD_VAR 0 2
103704: PUSH
103705: LD_INT 3
103707: PLUS
103708: PUSH
103709: LD_INT 5
103711: PUSH
103712: EMPTY
103713: LIST
103714: LIST
103715: LIST
103716: PUSH
103717: LD_VAR 0 1
103721: PUSH
103722: LD_INT 4
103724: PLUS
103725: PUSH
103726: LD_VAR 0 2
103730: PUSH
103731: LD_INT 4
103733: PUSH
103734: EMPTY
103735: LIST
103736: LIST
103737: LIST
103738: PUSH
103739: LD_VAR 0 1
103743: PUSH
103744: LD_VAR 0 2
103748: PUSH
103749: LD_INT 3
103751: MINUS
103752: PUSH
103753: LD_INT 3
103755: PUSH
103756: EMPTY
103757: LIST
103758: LIST
103759: LIST
103760: PUSH
103761: LD_VAR 0 1
103765: PUSH
103766: LD_INT 4
103768: MINUS
103769: PUSH
103770: LD_VAR 0 2
103774: PUSH
103775: LD_INT 4
103777: MINUS
103778: PUSH
103779: LD_INT 2
103781: PUSH
103782: EMPTY
103783: LIST
103784: LIST
103785: LIST
103786: PUSH
103787: EMPTY
103788: LIST
103789: LIST
103790: LIST
103791: LIST
103792: LIST
103793: ST_TO_ADDR
// end ; 5 :
103794: GO 103934
103796: LD_INT 5
103798: DOUBLE
103799: EQUAL
103800: IFTRUE 103804
103802: GO 103933
103804: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103805: LD_ADDR_VAR 0 5
103809: PUSH
103810: LD_VAR 0 1
103814: PUSH
103815: LD_INT 4
103817: MINUS
103818: PUSH
103819: LD_VAR 0 2
103823: PUSH
103824: LD_INT 1
103826: PUSH
103827: EMPTY
103828: LIST
103829: LIST
103830: LIST
103831: PUSH
103832: LD_VAR 0 1
103836: PUSH
103837: LD_VAR 0 2
103841: PUSH
103842: LD_INT 4
103844: MINUS
103845: PUSH
103846: LD_INT 3
103848: PUSH
103849: EMPTY
103850: LIST
103851: LIST
103852: LIST
103853: PUSH
103854: LD_VAR 0 1
103858: PUSH
103859: LD_INT 4
103861: PLUS
103862: PUSH
103863: LD_VAR 0 2
103867: PUSH
103868: LD_INT 4
103870: PLUS
103871: PUSH
103872: LD_INT 5
103874: PUSH
103875: EMPTY
103876: LIST
103877: LIST
103878: LIST
103879: PUSH
103880: LD_VAR 0 1
103884: PUSH
103885: LD_INT 3
103887: PLUS
103888: PUSH
103889: LD_VAR 0 2
103893: PUSH
103894: LD_INT 4
103896: PUSH
103897: EMPTY
103898: LIST
103899: LIST
103900: LIST
103901: PUSH
103902: LD_VAR 0 1
103906: PUSH
103907: LD_VAR 0 2
103911: PUSH
103912: LD_INT 3
103914: PLUS
103915: PUSH
103916: LD_INT 0
103918: PUSH
103919: EMPTY
103920: LIST
103921: LIST
103922: LIST
103923: PUSH
103924: EMPTY
103925: LIST
103926: LIST
103927: LIST
103928: LIST
103929: LIST
103930: ST_TO_ADDR
// end ; end ;
103931: GO 103934
103933: POP
// result := list ;
103934: LD_ADDR_VAR 0 4
103938: PUSH
103939: LD_VAR 0 5
103943: ST_TO_ADDR
// end ;
103944: LD_VAR 0 4
103948: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103949: LD_INT 0
103951: PPUSH
103952: PPUSH
103953: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103954: LD_VAR 0 1
103958: NOT
103959: PUSH
103960: LD_VAR 0 2
103964: PUSH
103965: LD_INT 1
103967: PUSH
103968: LD_INT 2
103970: PUSH
103971: LD_INT 3
103973: PUSH
103974: LD_INT 4
103976: PUSH
103977: EMPTY
103978: LIST
103979: LIST
103980: LIST
103981: LIST
103982: IN
103983: NOT
103984: OR
103985: IFFALSE 103989
// exit ;
103987: GO 104081
// tmp := [ ] ;
103989: LD_ADDR_VAR 0 5
103993: PUSH
103994: EMPTY
103995: ST_TO_ADDR
// for i in units do
103996: LD_ADDR_VAR 0 4
104000: PUSH
104001: LD_VAR 0 1
104005: PUSH
104006: FOR_IN
104007: IFFALSE 104050
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
104009: LD_ADDR_VAR 0 5
104013: PUSH
104014: LD_VAR 0 5
104018: PPUSH
104019: LD_VAR 0 5
104023: PUSH
104024: LD_INT 1
104026: PLUS
104027: PPUSH
104028: LD_VAR 0 4
104032: PPUSH
104033: LD_VAR 0 2
104037: PPUSH
104038: CALL_OW 259
104042: PPUSH
104043: CALL_OW 2
104047: ST_TO_ADDR
104048: GO 104006
104050: POP
104051: POP
// if not tmp then
104052: LD_VAR 0 5
104056: NOT
104057: IFFALSE 104061
// exit ;
104059: GO 104081
// result := SortListByListDesc ( units , tmp ) ;
104061: LD_ADDR_VAR 0 3
104065: PUSH
104066: LD_VAR 0 1
104070: PPUSH
104071: LD_VAR 0 5
104075: PPUSH
104076: CALL_OW 77
104080: ST_TO_ADDR
// end ;
104081: LD_VAR 0 3
104085: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104086: LD_INT 0
104088: PPUSH
104089: PPUSH
104090: PPUSH
// x := GetX ( building ) ;
104091: LD_ADDR_VAR 0 4
104095: PUSH
104096: LD_VAR 0 2
104100: PPUSH
104101: CALL_OW 250
104105: ST_TO_ADDR
// y := GetY ( building ) ;
104106: LD_ADDR_VAR 0 5
104110: PUSH
104111: LD_VAR 0 2
104115: PPUSH
104116: CALL_OW 251
104120: ST_TO_ADDR
// if GetTaskList ( unit ) then
104121: LD_VAR 0 1
104125: PPUSH
104126: CALL_OW 437
104130: IFFALSE 104225
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104132: LD_STRING e
104134: PUSH
104135: LD_VAR 0 1
104139: PPUSH
104140: CALL_OW 437
104144: PUSH
104145: LD_INT 1
104147: ARRAY
104148: PUSH
104149: LD_INT 1
104151: ARRAY
104152: EQUAL
104153: PUSH
104154: LD_VAR 0 4
104158: PUSH
104159: LD_VAR 0 1
104163: PPUSH
104164: CALL_OW 437
104168: PUSH
104169: LD_INT 1
104171: ARRAY
104172: PUSH
104173: LD_INT 2
104175: ARRAY
104176: EQUAL
104177: AND
104178: PUSH
104179: LD_VAR 0 5
104183: PUSH
104184: LD_VAR 0 1
104188: PPUSH
104189: CALL_OW 437
104193: PUSH
104194: LD_INT 1
104196: ARRAY
104197: PUSH
104198: LD_INT 3
104200: ARRAY
104201: EQUAL
104202: AND
104203: IFFALSE 104215
// result := true else
104205: LD_ADDR_VAR 0 3
104209: PUSH
104210: LD_INT 1
104212: ST_TO_ADDR
104213: GO 104223
// result := false ;
104215: LD_ADDR_VAR 0 3
104219: PUSH
104220: LD_INT 0
104222: ST_TO_ADDR
// end else
104223: GO 104233
// result := false ;
104225: LD_ADDR_VAR 0 3
104229: PUSH
104230: LD_INT 0
104232: ST_TO_ADDR
// end ;
104233: LD_VAR 0 3
104237: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
104238: LD_INT 0
104240: PPUSH
104241: PPUSH
104242: PPUSH
104243: PPUSH
// if not unit or not area then
104244: LD_VAR 0 1
104248: NOT
104249: PUSH
104250: LD_VAR 0 2
104254: NOT
104255: OR
104256: IFFALSE 104260
// exit ;
104258: GO 104424
// tmp := AreaToList ( area , i ) ;
104260: LD_ADDR_VAR 0 6
104264: PUSH
104265: LD_VAR 0 2
104269: PPUSH
104270: LD_VAR 0 5
104274: PPUSH
104275: CALL_OW 517
104279: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104280: LD_ADDR_VAR 0 5
104284: PUSH
104285: DOUBLE
104286: LD_INT 1
104288: DEC
104289: ST_TO_ADDR
104290: LD_VAR 0 6
104294: PUSH
104295: LD_INT 1
104297: ARRAY
104298: PUSH
104299: FOR_TO
104300: IFFALSE 104422
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104302: LD_ADDR_VAR 0 7
104306: PUSH
104307: LD_VAR 0 6
104311: PUSH
104312: LD_INT 1
104314: ARRAY
104315: PUSH
104316: LD_VAR 0 5
104320: ARRAY
104321: PUSH
104322: LD_VAR 0 6
104326: PUSH
104327: LD_INT 2
104329: ARRAY
104330: PUSH
104331: LD_VAR 0 5
104335: ARRAY
104336: PUSH
104337: EMPTY
104338: LIST
104339: LIST
104340: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
104341: LD_VAR 0 7
104345: PUSH
104346: LD_INT 1
104348: ARRAY
104349: PPUSH
104350: LD_VAR 0 7
104354: PUSH
104355: LD_INT 2
104357: ARRAY
104358: PPUSH
104359: CALL_OW 428
104363: PUSH
104364: LD_INT 0
104366: EQUAL
104367: IFFALSE 104420
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104369: LD_VAR 0 1
104373: PPUSH
104374: LD_VAR 0 7
104378: PUSH
104379: LD_INT 1
104381: ARRAY
104382: PPUSH
104383: LD_VAR 0 7
104387: PUSH
104388: LD_INT 2
104390: ARRAY
104391: PPUSH
104392: LD_VAR 0 3
104396: PPUSH
104397: CALL_OW 48
// result := IsPlaced ( unit ) ;
104401: LD_ADDR_VAR 0 4
104405: PUSH
104406: LD_VAR 0 1
104410: PPUSH
104411: CALL_OW 305
104415: ST_TO_ADDR
// exit ;
104416: POP
104417: POP
104418: GO 104424
// end ; end ;
104420: GO 104299
104422: POP
104423: POP
// end ;
104424: LD_VAR 0 4
104428: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104429: LD_INT 0
104431: PPUSH
104432: PPUSH
104433: PPUSH
// if not side or side > 8 then
104434: LD_VAR 0 1
104438: NOT
104439: PUSH
104440: LD_VAR 0 1
104444: PUSH
104445: LD_INT 8
104447: GREATER
104448: OR
104449: IFFALSE 104453
// exit ;
104451: GO 104640
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104453: LD_ADDR_VAR 0 4
104457: PUSH
104458: LD_INT 22
104460: PUSH
104461: LD_VAR 0 1
104465: PUSH
104466: EMPTY
104467: LIST
104468: LIST
104469: PUSH
104470: LD_INT 21
104472: PUSH
104473: LD_INT 3
104475: PUSH
104476: EMPTY
104477: LIST
104478: LIST
104479: PUSH
104480: EMPTY
104481: LIST
104482: LIST
104483: PPUSH
104484: CALL_OW 69
104488: ST_TO_ADDR
// if not tmp then
104489: LD_VAR 0 4
104493: NOT
104494: IFFALSE 104498
// exit ;
104496: GO 104640
// enable_addtolog := true ;
104498: LD_ADDR_OWVAR 81
104502: PUSH
104503: LD_INT 1
104505: ST_TO_ADDR
// AddToLog ( [ ) ;
104506: LD_STRING [
104508: PPUSH
104509: CALL_OW 561
// for i in tmp do
104513: LD_ADDR_VAR 0 3
104517: PUSH
104518: LD_VAR 0 4
104522: PUSH
104523: FOR_IN
104524: IFFALSE 104631
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104526: LD_STRING [
104528: PUSH
104529: LD_VAR 0 3
104533: PPUSH
104534: CALL_OW 266
104538: STR
104539: PUSH
104540: LD_STRING , 
104542: STR
104543: PUSH
104544: LD_VAR 0 3
104548: PPUSH
104549: CALL_OW 250
104553: STR
104554: PUSH
104555: LD_STRING , 
104557: STR
104558: PUSH
104559: LD_VAR 0 3
104563: PPUSH
104564: CALL_OW 251
104568: STR
104569: PUSH
104570: LD_STRING , 
104572: STR
104573: PUSH
104574: LD_VAR 0 3
104578: PPUSH
104579: CALL_OW 254
104583: STR
104584: PUSH
104585: LD_STRING , 
104587: STR
104588: PUSH
104589: LD_VAR 0 3
104593: PPUSH
104594: LD_INT 1
104596: PPUSH
104597: CALL_OW 268
104601: STR
104602: PUSH
104603: LD_STRING , 
104605: STR
104606: PUSH
104607: LD_VAR 0 3
104611: PPUSH
104612: LD_INT 2
104614: PPUSH
104615: CALL_OW 268
104619: STR
104620: PUSH
104621: LD_STRING ],
104623: STR
104624: PPUSH
104625: CALL_OW 561
// end ;
104629: GO 104523
104631: POP
104632: POP
// AddToLog ( ]; ) ;
104633: LD_STRING ];
104635: PPUSH
104636: CALL_OW 561
// end ;
104640: LD_VAR 0 2
104644: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104645: LD_INT 0
104647: PPUSH
104648: PPUSH
104649: PPUSH
104650: PPUSH
104651: PPUSH
// if not area or not rate or not max then
104652: LD_VAR 0 1
104656: NOT
104657: PUSH
104658: LD_VAR 0 2
104662: NOT
104663: OR
104664: PUSH
104665: LD_VAR 0 4
104669: NOT
104670: OR
104671: IFFALSE 104675
// exit ;
104673: GO 104867
// while 1 do
104675: LD_INT 1
104677: IFFALSE 104867
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104679: LD_ADDR_VAR 0 9
104683: PUSH
104684: LD_VAR 0 1
104688: PPUSH
104689: LD_INT 1
104691: PPUSH
104692: CALL_OW 287
104696: PUSH
104697: LD_INT 10
104699: MUL
104700: ST_TO_ADDR
// r := rate / 10 ;
104701: LD_ADDR_VAR 0 7
104705: PUSH
104706: LD_VAR 0 2
104710: PUSH
104711: LD_INT 10
104713: DIVREAL
104714: ST_TO_ADDR
// time := 1 1$00 ;
104715: LD_ADDR_VAR 0 8
104719: PUSH
104720: LD_INT 2100
104722: ST_TO_ADDR
// if amount < min then
104723: LD_VAR 0 9
104727: PUSH
104728: LD_VAR 0 3
104732: LESS
104733: IFFALSE 104751
// r := r * 2 else
104735: LD_ADDR_VAR 0 7
104739: PUSH
104740: LD_VAR 0 7
104744: PUSH
104745: LD_INT 2
104747: MUL
104748: ST_TO_ADDR
104749: GO 104777
// if amount > max then
104751: LD_VAR 0 9
104755: PUSH
104756: LD_VAR 0 4
104760: GREATER
104761: IFFALSE 104777
// r := r / 2 ;
104763: LD_ADDR_VAR 0 7
104767: PUSH
104768: LD_VAR 0 7
104772: PUSH
104773: LD_INT 2
104775: DIVREAL
104776: ST_TO_ADDR
// time := time / r ;
104777: LD_ADDR_VAR 0 8
104781: PUSH
104782: LD_VAR 0 8
104786: PUSH
104787: LD_VAR 0 7
104791: DIVREAL
104792: ST_TO_ADDR
// if time < 0 then
104793: LD_VAR 0 8
104797: PUSH
104798: LD_INT 0
104800: LESS
104801: IFFALSE 104818
// time := time * - 1 ;
104803: LD_ADDR_VAR 0 8
104807: PUSH
104808: LD_VAR 0 8
104812: PUSH
104813: LD_INT 1
104815: NEG
104816: MUL
104817: ST_TO_ADDR
// wait ( time ) ;
104818: LD_VAR 0 8
104822: PPUSH
104823: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
104827: LD_INT 35
104829: PPUSH
104830: LD_INT 875
104832: PPUSH
104833: CALL_OW 12
104837: PPUSH
104838: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104842: LD_INT 1
104844: PPUSH
104845: LD_INT 5
104847: PPUSH
104848: CALL_OW 12
104852: PPUSH
104853: LD_VAR 0 1
104857: PPUSH
104858: LD_INT 1
104860: PPUSH
104861: CALL_OW 55
// end ;
104865: GO 104675
// end ;
104867: LD_VAR 0 5
104871: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104872: LD_INT 0
104874: PPUSH
104875: PPUSH
104876: PPUSH
104877: PPUSH
104878: PPUSH
104879: PPUSH
104880: PPUSH
104881: PPUSH
// if not turrets or not factories then
104882: LD_VAR 0 1
104886: NOT
104887: PUSH
104888: LD_VAR 0 2
104892: NOT
104893: OR
104894: IFFALSE 104898
// exit ;
104896: GO 105205
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104898: LD_ADDR_VAR 0 10
104902: PUSH
104903: LD_INT 5
104905: PUSH
104906: LD_INT 6
104908: PUSH
104909: EMPTY
104910: LIST
104911: LIST
104912: PUSH
104913: LD_INT 2
104915: PUSH
104916: LD_INT 4
104918: PUSH
104919: EMPTY
104920: LIST
104921: LIST
104922: PUSH
104923: LD_INT 3
104925: PUSH
104926: LD_INT 5
104928: PUSH
104929: EMPTY
104930: LIST
104931: LIST
104932: PUSH
104933: EMPTY
104934: LIST
104935: LIST
104936: LIST
104937: PUSH
104938: LD_INT 24
104940: PUSH
104941: LD_INT 25
104943: PUSH
104944: EMPTY
104945: LIST
104946: LIST
104947: PUSH
104948: LD_INT 23
104950: PUSH
104951: LD_INT 27
104953: PUSH
104954: EMPTY
104955: LIST
104956: LIST
104957: PUSH
104958: EMPTY
104959: LIST
104960: LIST
104961: PUSH
104962: LD_INT 42
104964: PUSH
104965: LD_INT 43
104967: PUSH
104968: EMPTY
104969: LIST
104970: LIST
104971: PUSH
104972: LD_INT 44
104974: PUSH
104975: LD_INT 46
104977: PUSH
104978: EMPTY
104979: LIST
104980: LIST
104981: PUSH
104982: LD_INT 45
104984: PUSH
104985: LD_INT 47
104987: PUSH
104988: EMPTY
104989: LIST
104990: LIST
104991: PUSH
104992: EMPTY
104993: LIST
104994: LIST
104995: LIST
104996: PUSH
104997: EMPTY
104998: LIST
104999: LIST
105000: LIST
105001: ST_TO_ADDR
// result := [ ] ;
105002: LD_ADDR_VAR 0 3
105006: PUSH
105007: EMPTY
105008: ST_TO_ADDR
// for i in turrets do
105009: LD_ADDR_VAR 0 4
105013: PUSH
105014: LD_VAR 0 1
105018: PUSH
105019: FOR_IN
105020: IFFALSE 105203
// begin nat := GetNation ( i ) ;
105022: LD_ADDR_VAR 0 7
105026: PUSH
105027: LD_VAR 0 4
105031: PPUSH
105032: CALL_OW 248
105036: ST_TO_ADDR
// weapon := 0 ;
105037: LD_ADDR_VAR 0 8
105041: PUSH
105042: LD_INT 0
105044: ST_TO_ADDR
// if not nat then
105045: LD_VAR 0 7
105049: NOT
105050: IFFALSE 105054
// continue ;
105052: GO 105019
// for j in list [ nat ] do
105054: LD_ADDR_VAR 0 5
105058: PUSH
105059: LD_VAR 0 10
105063: PUSH
105064: LD_VAR 0 7
105068: ARRAY
105069: PUSH
105070: FOR_IN
105071: IFFALSE 105112
// if GetBWeapon ( i ) = j [ 1 ] then
105073: LD_VAR 0 4
105077: PPUSH
105078: CALL_OW 269
105082: PUSH
105083: LD_VAR 0 5
105087: PUSH
105088: LD_INT 1
105090: ARRAY
105091: EQUAL
105092: IFFALSE 105110
// begin weapon := j [ 2 ] ;
105094: LD_ADDR_VAR 0 8
105098: PUSH
105099: LD_VAR 0 5
105103: PUSH
105104: LD_INT 2
105106: ARRAY
105107: ST_TO_ADDR
// break ;
105108: GO 105112
// end ;
105110: GO 105070
105112: POP
105113: POP
// if not weapon then
105114: LD_VAR 0 8
105118: NOT
105119: IFFALSE 105123
// continue ;
105121: GO 105019
// for k in factories do
105123: LD_ADDR_VAR 0 6
105127: PUSH
105128: LD_VAR 0 2
105132: PUSH
105133: FOR_IN
105134: IFFALSE 105199
// begin weapons := AvailableWeaponList ( k ) ;
105136: LD_ADDR_VAR 0 9
105140: PUSH
105141: LD_VAR 0 6
105145: PPUSH
105146: CALL_OW 478
105150: ST_TO_ADDR
// if not weapons then
105151: LD_VAR 0 9
105155: NOT
105156: IFFALSE 105160
// continue ;
105158: GO 105133
// if weapon in weapons then
105160: LD_VAR 0 8
105164: PUSH
105165: LD_VAR 0 9
105169: IN
105170: IFFALSE 105197
// begin result := [ i , weapon ] ;
105172: LD_ADDR_VAR 0 3
105176: PUSH
105177: LD_VAR 0 4
105181: PUSH
105182: LD_VAR 0 8
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: ST_TO_ADDR
// exit ;
105191: POP
105192: POP
105193: POP
105194: POP
105195: GO 105205
// end ; end ;
105197: GO 105133
105199: POP
105200: POP
// end ;
105201: GO 105019
105203: POP
105204: POP
// end ;
105205: LD_VAR 0 3
105209: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105210: LD_INT 0
105212: PPUSH
// if not side or side > 8 then
105213: LD_VAR 0 3
105217: NOT
105218: PUSH
105219: LD_VAR 0 3
105223: PUSH
105224: LD_INT 8
105226: GREATER
105227: OR
105228: IFFALSE 105232
// exit ;
105230: GO 105291
// if not range then
105232: LD_VAR 0 4
105236: NOT
105237: IFFALSE 105248
// range := - 12 ;
105239: LD_ADDR_VAR 0 4
105243: PUSH
105244: LD_INT 12
105246: NEG
105247: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
105248: LD_VAR 0 1
105252: PPUSH
105253: LD_VAR 0 2
105257: PPUSH
105258: LD_VAR 0 3
105262: PPUSH
105263: LD_VAR 0 4
105267: PPUSH
105268: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
105272: LD_VAR 0 1
105276: PPUSH
105277: LD_VAR 0 2
105281: PPUSH
105282: LD_VAR 0 3
105286: PPUSH
105287: CALL_OW 331
// end ;
105291: LD_VAR 0 5
105295: RET
// export function Video ( mode ) ; begin
105296: LD_INT 0
105298: PPUSH
// ingame_video = mode ;
105299: LD_ADDR_OWVAR 52
105303: PUSH
105304: LD_VAR 0 1
105308: ST_TO_ADDR
// interface_hidden = mode ;
105309: LD_ADDR_OWVAR 54
105313: PUSH
105314: LD_VAR 0 1
105318: ST_TO_ADDR
// end ;
105319: LD_VAR 0 2
105323: RET
// export function Join ( array , element ) ; begin
105324: LD_INT 0
105326: PPUSH
// result := array ^ element ;
105327: LD_ADDR_VAR 0 3
105331: PUSH
105332: LD_VAR 0 1
105336: PUSH
105337: LD_VAR 0 2
105341: ADD
105342: ST_TO_ADDR
// end ;
105343: LD_VAR 0 3
105347: RET
// export function JoinUnion ( array , element ) ; begin
105348: LD_INT 0
105350: PPUSH
// result := array union element ;
105351: LD_ADDR_VAR 0 3
105355: PUSH
105356: LD_VAR 0 1
105360: PUSH
105361: LD_VAR 0 2
105365: UNION
105366: ST_TO_ADDR
// end ;
105367: LD_VAR 0 3
105371: RET
// export function GetBehemoths ( side ) ; begin
105372: LD_INT 0
105374: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
105375: LD_ADDR_VAR 0 2
105379: PUSH
105380: LD_INT 22
105382: PUSH
105383: LD_VAR 0 1
105387: PUSH
105388: EMPTY
105389: LIST
105390: LIST
105391: PUSH
105392: LD_INT 31
105394: PUSH
105395: LD_INT 25
105397: PUSH
105398: EMPTY
105399: LIST
105400: LIST
105401: PUSH
105402: EMPTY
105403: LIST
105404: LIST
105405: PPUSH
105406: CALL_OW 69
105410: ST_TO_ADDR
// end ;
105411: LD_VAR 0 2
105415: RET
// export function Shuffle ( array ) ; var i , index ; begin
105416: LD_INT 0
105418: PPUSH
105419: PPUSH
105420: PPUSH
// result := [ ] ;
105421: LD_ADDR_VAR 0 2
105425: PUSH
105426: EMPTY
105427: ST_TO_ADDR
// if not array then
105428: LD_VAR 0 1
105432: NOT
105433: IFFALSE 105437
// exit ;
105435: GO 105536
// Randomize ;
105437: CALL_OW 10
// for i = array downto 1 do
105441: LD_ADDR_VAR 0 3
105445: PUSH
105446: DOUBLE
105447: LD_VAR 0 1
105451: INC
105452: ST_TO_ADDR
105453: LD_INT 1
105455: PUSH
105456: FOR_DOWNTO
105457: IFFALSE 105534
// begin index := rand ( 1 , array ) ;
105459: LD_ADDR_VAR 0 4
105463: PUSH
105464: LD_INT 1
105466: PPUSH
105467: LD_VAR 0 1
105471: PPUSH
105472: CALL_OW 12
105476: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105477: LD_ADDR_VAR 0 2
105481: PUSH
105482: LD_VAR 0 2
105486: PPUSH
105487: LD_VAR 0 2
105491: PUSH
105492: LD_INT 1
105494: PLUS
105495: PPUSH
105496: LD_VAR 0 1
105500: PUSH
105501: LD_VAR 0 4
105505: ARRAY
105506: PPUSH
105507: CALL_OW 2
105511: ST_TO_ADDR
// array := Delete ( array , index ) ;
105512: LD_ADDR_VAR 0 1
105516: PUSH
105517: LD_VAR 0 1
105521: PPUSH
105522: LD_VAR 0 4
105526: PPUSH
105527: CALL_OW 3
105531: ST_TO_ADDR
// end ;
105532: GO 105456
105534: POP
105535: POP
// end ; end_of_file end_of_file end_of_file
105536: LD_VAR 0 2
105540: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
105541: LD_INT 0
105543: PPUSH
105544: PPUSH
105545: PPUSH
105546: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105547: LD_VAR 0 1
105551: PPUSH
105552: CALL_OW 264
105556: PUSH
105557: LD_EXP 96
105561: EQUAL
105562: IFFALSE 105634
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105564: LD_INT 68
105566: PPUSH
105567: LD_VAR 0 1
105571: PPUSH
105572: CALL_OW 255
105576: PPUSH
105577: CALL_OW 321
105581: PUSH
105582: LD_INT 2
105584: EQUAL
105585: IFFALSE 105597
// eff := 70 else
105587: LD_ADDR_VAR 0 6
105591: PUSH
105592: LD_INT 70
105594: ST_TO_ADDR
105595: GO 105605
// eff := 30 ;
105597: LD_ADDR_VAR 0 6
105601: PUSH
105602: LD_INT 30
105604: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105605: LD_VAR 0 1
105609: PPUSH
105610: CALL_OW 250
105614: PPUSH
105615: LD_VAR 0 1
105619: PPUSH
105620: CALL_OW 251
105624: PPUSH
105625: LD_VAR 0 6
105629: PPUSH
105630: CALL_OW 495
// end ; end ;
105634: LD_VAR 0 4
105638: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
105639: LD_INT 0
105641: PPUSH
105642: PPUSH
105643: PPUSH
105644: PPUSH
105645: PPUSH
105646: PPUSH
// if cmd = 124 then
105647: LD_VAR 0 1
105651: PUSH
105652: LD_INT 124
105654: EQUAL
105655: IFFALSE 105861
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
105657: LD_ADDR_VAR 0 5
105661: PUSH
105662: LD_INT 2
105664: PUSH
105665: LD_INT 34
105667: PUSH
105668: LD_INT 53
105670: PUSH
105671: EMPTY
105672: LIST
105673: LIST
105674: PUSH
105675: LD_INT 34
105677: PUSH
105678: LD_INT 14
105680: PUSH
105681: EMPTY
105682: LIST
105683: LIST
105684: PUSH
105685: EMPTY
105686: LIST
105687: LIST
105688: LIST
105689: PPUSH
105690: CALL_OW 69
105694: ST_TO_ADDR
// if not tmp then
105695: LD_VAR 0 5
105699: NOT
105700: IFFALSE 105704
// exit ;
105702: GO 105861
// for i in tmp do
105704: LD_ADDR_VAR 0 3
105708: PUSH
105709: LD_VAR 0 5
105713: PUSH
105714: FOR_IN
105715: IFFALSE 105859
// begin taskList := GetTaskList ( i ) ;
105717: LD_ADDR_VAR 0 6
105721: PUSH
105722: LD_VAR 0 3
105726: PPUSH
105727: CALL_OW 437
105731: ST_TO_ADDR
// if not taskList then
105732: LD_VAR 0 6
105736: NOT
105737: IFFALSE 105741
// continue ;
105739: GO 105714
// for j = 1 to taskList do
105741: LD_ADDR_VAR 0 4
105745: PUSH
105746: DOUBLE
105747: LD_INT 1
105749: DEC
105750: ST_TO_ADDR
105751: LD_VAR 0 6
105755: PUSH
105756: FOR_TO
105757: IFFALSE 105855
// if taskList [ j ] [ 1 ] = | then
105759: LD_VAR 0 6
105763: PUSH
105764: LD_VAR 0 4
105768: ARRAY
105769: PUSH
105770: LD_INT 1
105772: ARRAY
105773: PUSH
105774: LD_STRING |
105776: EQUAL
105777: IFFALSE 105853
// begin _taskList := Delete ( taskList , 1 ) ;
105779: LD_ADDR_VAR 0 7
105783: PUSH
105784: LD_VAR 0 6
105788: PPUSH
105789: LD_INT 1
105791: PPUSH
105792: CALL_OW 3
105796: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
105797: LD_VAR 0 3
105801: PPUSH
105802: LD_VAR 0 7
105806: PPUSH
105807: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
105811: LD_VAR 0 3
105815: PPUSH
105816: LD_VAR 0 6
105820: PUSH
105821: LD_VAR 0 4
105825: ARRAY
105826: PUSH
105827: LD_INT 2
105829: ARRAY
105830: PPUSH
105831: LD_VAR 0 6
105835: PUSH
105836: LD_VAR 0 4
105840: ARRAY
105841: PUSH
105842: LD_INT 3
105844: ARRAY
105845: PPUSH
105846: LD_INT 8
105848: PPUSH
105849: CALL 105866 0 4
// end ;
105853: GO 105756
105855: POP
105856: POP
// end ;
105857: GO 105714
105859: POP
105860: POP
// end ; end ;
105861: LD_VAR 0 2
105865: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105866: LD_INT 0
105868: PPUSH
105869: PPUSH
105870: PPUSH
105871: PPUSH
105872: PPUSH
105873: PPUSH
105874: PPUSH
105875: PPUSH
105876: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
105877: LD_VAR 0 1
105881: NOT
105882: PUSH
105883: LD_VAR 0 2
105887: PPUSH
105888: LD_VAR 0 3
105892: PPUSH
105893: CALL_OW 488
105897: NOT
105898: OR
105899: PUSH
105900: LD_VAR 0 4
105904: NOT
105905: OR
105906: IFFALSE 105910
// exit ;
105908: GO 106250
// list := [ ] ;
105910: LD_ADDR_VAR 0 13
105914: PUSH
105915: EMPTY
105916: ST_TO_ADDR
// if x - r < 0 then
105917: LD_VAR 0 2
105921: PUSH
105922: LD_VAR 0 4
105926: MINUS
105927: PUSH
105928: LD_INT 0
105930: LESS
105931: IFFALSE 105943
// min_x := 0 else
105933: LD_ADDR_VAR 0 7
105937: PUSH
105938: LD_INT 0
105940: ST_TO_ADDR
105941: GO 105959
// min_x := x - r ;
105943: LD_ADDR_VAR 0 7
105947: PUSH
105948: LD_VAR 0 2
105952: PUSH
105953: LD_VAR 0 4
105957: MINUS
105958: ST_TO_ADDR
// if y - r < 0 then
105959: LD_VAR 0 3
105963: PUSH
105964: LD_VAR 0 4
105968: MINUS
105969: PUSH
105970: LD_INT 0
105972: LESS
105973: IFFALSE 105985
// min_y := 0 else
105975: LD_ADDR_VAR 0 8
105979: PUSH
105980: LD_INT 0
105982: ST_TO_ADDR
105983: GO 106001
// min_y := y - r ;
105985: LD_ADDR_VAR 0 8
105989: PUSH
105990: LD_VAR 0 3
105994: PUSH
105995: LD_VAR 0 4
105999: MINUS
106000: ST_TO_ADDR
// max_x := x + r ;
106001: LD_ADDR_VAR 0 9
106005: PUSH
106006: LD_VAR 0 2
106010: PUSH
106011: LD_VAR 0 4
106015: PLUS
106016: ST_TO_ADDR
// max_y := y + r ;
106017: LD_ADDR_VAR 0 10
106021: PUSH
106022: LD_VAR 0 3
106026: PUSH
106027: LD_VAR 0 4
106031: PLUS
106032: ST_TO_ADDR
// for _x = min_x to max_x do
106033: LD_ADDR_VAR 0 11
106037: PUSH
106038: DOUBLE
106039: LD_VAR 0 7
106043: DEC
106044: ST_TO_ADDR
106045: LD_VAR 0 9
106049: PUSH
106050: FOR_TO
106051: IFFALSE 106168
// for _y = min_y to max_y do
106053: LD_ADDR_VAR 0 12
106057: PUSH
106058: DOUBLE
106059: LD_VAR 0 8
106063: DEC
106064: ST_TO_ADDR
106065: LD_VAR 0 10
106069: PUSH
106070: FOR_TO
106071: IFFALSE 106164
// begin if not ValidHex ( _x , _y ) then
106073: LD_VAR 0 11
106077: PPUSH
106078: LD_VAR 0 12
106082: PPUSH
106083: CALL_OW 488
106087: NOT
106088: IFFALSE 106092
// continue ;
106090: GO 106070
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106092: LD_VAR 0 11
106096: PPUSH
106097: LD_VAR 0 12
106101: PPUSH
106102: CALL_OW 351
106106: PUSH
106107: LD_VAR 0 11
106111: PPUSH
106112: LD_VAR 0 12
106116: PPUSH
106117: CALL_OW 554
106121: AND
106122: IFFALSE 106162
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106124: LD_ADDR_VAR 0 13
106128: PUSH
106129: LD_VAR 0 13
106133: PPUSH
106134: LD_VAR 0 13
106138: PUSH
106139: LD_INT 1
106141: PLUS
106142: PPUSH
106143: LD_VAR 0 11
106147: PUSH
106148: LD_VAR 0 12
106152: PUSH
106153: EMPTY
106154: LIST
106155: LIST
106156: PPUSH
106157: CALL_OW 2
106161: ST_TO_ADDR
// end ;
106162: GO 106070
106164: POP
106165: POP
106166: GO 106050
106168: POP
106169: POP
// if not list then
106170: LD_VAR 0 13
106174: NOT
106175: IFFALSE 106179
// exit ;
106177: GO 106250
// for i in list do
106179: LD_ADDR_VAR 0 6
106183: PUSH
106184: LD_VAR 0 13
106188: PUSH
106189: FOR_IN
106190: IFFALSE 106248
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106192: LD_VAR 0 1
106196: PPUSH
106197: LD_STRING M
106199: PUSH
106200: LD_VAR 0 6
106204: PUSH
106205: LD_INT 1
106207: ARRAY
106208: PUSH
106209: LD_VAR 0 6
106213: PUSH
106214: LD_INT 2
106216: ARRAY
106217: PUSH
106218: LD_INT 0
106220: PUSH
106221: LD_INT 0
106223: PUSH
106224: LD_INT 0
106226: PUSH
106227: LD_INT 0
106229: PUSH
106230: EMPTY
106231: LIST
106232: LIST
106233: LIST
106234: LIST
106235: LIST
106236: LIST
106237: LIST
106238: PUSH
106239: EMPTY
106240: LIST
106241: PPUSH
106242: CALL_OW 447
106246: GO 106189
106248: POP
106249: POP
// end ;
106250: LD_VAR 0 5
106254: RET
