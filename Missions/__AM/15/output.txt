// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 34977 0 0
// InitMacro ;
  19: CALL 35121 0 0
// InitNature ;
  23: CALL 34845 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11097 0 0
// PrepareRussian ;
  44: CALL 6981 0 0
// PrepareLegion ;
  48: CALL 4206 0 0
// PreparePowell ;
  52: CALL 2943 0 0
// PrepareAmerican ;
  56: CALL 1715 0 0
// Action ;
  60: CALL 14991 0 0
// MC_Start ( ) ;
  64: CALL 37233 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 137
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 138
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 59542 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 59635 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 58985 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 58800 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 59542 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 59635 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 58800 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 58985 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59415 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 15
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58482 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 59542 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 59635 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 142
 959: PUSH
 960: LD_EXP 142
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_EXP 101
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PPUSH
1085: CALL 58800 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 10
1094: PUSH
1095: LD_INT 12
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 59542 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 9
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 59635 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 26
1124: PUSH
1125: LD_INT 74
1127: PUSH
1128: LD_INT 107
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 32
1142: PUSH
1143: LD_INT 77
1145: PUSH
1146: LD_INT 101
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 32
1160: PUSH
1161: LD_INT 69
1163: PUSH
1164: LD_INT 86
1166: PUSH
1167: LD_INT 4
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 27
1178: PUSH
1179: LD_INT 77
1181: PUSH
1182: LD_INT 110
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 42
1199: PUSH
1200: LD_INT 79
1202: PUSH
1203: LD_INT 5
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 29
1214: PUSH
1215: LD_INT 86
1217: PUSH
1218: LD_INT 105
1220: PUSH
1221: LD_INT 2
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 30
1232: PUSH
1233: LD_INT 40
1235: PUSH
1236: LD_INT 75
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: LD_INT 80
1253: PUSH
1254: LD_INT 106
1256: PUSH
1257: LD_INT 4
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 32
1268: PUSH
1269: LD_INT 75
1271: PUSH
1272: LD_INT 114
1274: PUSH
1275: LD_INT 5
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PUSH
1284: LD_INT 32
1286: PUSH
1287: LD_INT 82
1289: PUSH
1290: LD_INT 110
1292: PUSH
1293: LD_INT 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: LD_INT 32
1304: PUSH
1305: LD_INT 62
1307: PUSH
1308: LD_INT 78
1310: PUSH
1311: LD_INT 4
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PUSH
1320: LD_INT 4
1322: PUSH
1323: LD_INT 39
1325: PUSH
1326: LD_INT 61
1328: PUSH
1329: LD_INT 3
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 58692 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 5
1361: PUSH
1362: LD_INT 6
1364: PUSH
1365: LD_INT 7
1367: PUSH
1368: LD_INT 9
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 59953 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 40
1386: PUSH
1387: LD_INT 75
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 86
1400: PUSH
1401: LD_INT 105
1403: PUSH
1404: LD_INT 0
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL 59124 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1420: LD_INT 4
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL 59415 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL 59415 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1440: LD_INT 4
1442: PPUSH
1443: LD_INT 54
1445: PPUSH
1446: LD_INT 85
1448: PPUSH
1449: LD_INT 2
1451: PPUSH
1452: LD_INT 19
1454: PUSH
1455: LD_INT 16
1457: PUSH
1458: LD_INT 17
1460: PUSH
1461: LD_INT 18
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL 59747 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1474: LD_INT 4
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 4
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 1
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 58800 0 2
// MC_SetTame ( 4 , powellApe ) ;
1559: LD_INT 4
1561: PPUSH
1562: LD_INT 13
1564: PPUSH
1565: CALL 59366 0 2
// end ;
1569: LD_VAR 0 1
1573: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1574: LD_EXP 36
1578: PUSH
1579: LD_EXP 17
1583: PUSH
1584: LD_INT 2
1586: GREATEREQUAL
1587: AND
1588: IFFALSE 1600
1590: GO 1592
1592: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1593: LD_STRING ACH_POWELL
1595: PPUSH
1596: CALL_OW 543
1600: END
// every 0 0$1 trigger debug do var i , tmp ;
1601: LD_EXP 1
1605: IFFALSE 1712
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
// begin enable ;
1614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: LD_INT 22
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 21
1635: PUSH
1636: LD_INT 3
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 24
1652: PUSH
1653: LD_INT 999
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PPUSH
1669: CALL_OW 69
1673: ST_TO_ADDR
// if not tmp then
1674: LD_VAR 0 2
1678: NOT
1679: IFFALSE 1683
// exit ;
1681: GO 1712
// for i in tmp do
1683: LD_ADDR_VAR 0 1
1687: PUSH
1688: LD_VAR 0 2
1692: PUSH
1693: FOR_IN
1694: IFFALSE 1710
// SetLives ( i , 1000 ) ;
1696: LD_VAR 0 1
1700: PPUSH
1701: LD_INT 1000
1703: PPUSH
1704: CALL_OW 234
1708: GO 1693
1710: POP
1711: POP
// end ; end_of_file
1712: PPOPN 2
1714: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1715: LD_INT 0
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1734: LD_ADDR_EXP 39
1738: PUSH
1739: LD_STRING JMM
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 14_
1750: PPUSH
1751: CALL 65211 0 3
1755: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1756: LD_EXP 4
1760: NOT
1761: PUSH
1762: LD_EXP 4
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: NOT
1775: OR
1776: IFFALSE 1799
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1778: LD_INT 5
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 9
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 70035 0 5
1797: GO 1858
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1799: LD_EXP 4
1803: PUSH
1804: LD_INT 1
1806: ARRAY
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PPUSH
1812: LD_EXP 4
1816: PUSH
1817: LD_INT 2
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_EXP 4
1829: PUSH
1830: LD_INT 3
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 4
1842: PUSH
1843: LD_INT 4
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL 70035 0 5
// JMMNewVeh := CreateVehicle ;
1858: LD_ADDR_EXP 56
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// if not JMMNewVeh then
1868: LD_EXP 56
1872: NOT
1873: IFFALSE 1904
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1875: LD_INT 5
1877: PPUSH
1878: LD_INT 3
1880: PPUSH
1881: LD_INT 1
1883: PPUSH
1884: LD_INT 9
1886: PPUSH
1887: LD_INT 100
1889: PPUSH
1890: CALL 70035 0 5
// JMMNewVeh := CreateVehicle ;
1894: LD_ADDR_EXP 56
1898: PUSH
1899: CALL_OW 45
1903: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1904: LD_EXP 56
1908: PPUSH
1909: LD_INT 4
1911: PPUSH
1912: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1916: LD_EXP 56
1920: PPUSH
1921: LD_INT 79
1923: PPUSH
1924: LD_INT 91
1926: PPUSH
1927: LD_INT 0
1929: PPUSH
1930: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1934: LD_EXP 39
1938: PPUSH
1939: LD_EXP 56
1943: PPUSH
1944: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1948: LD_EXP 6
1952: PUSH
1953: LD_EXP 2
1957: NOT
1958: AND
1959: IFFALSE 2217
// begin if not JMMGirlVeh then
1961: LD_EXP 5
1965: NOT
1966: IFFALSE 1989
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1968: LD_INT 3
1970: PPUSH
1971: LD_INT 3
1973: PPUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 9
1979: PPUSH
1980: LD_INT 100
1982: PPUSH
1983: CALL 70035 0 5
1987: GO 2048
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1989: LD_EXP 5
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PPUSH
2002: LD_EXP 5
2006: PUSH
2007: LD_INT 2
2009: ARRAY
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_EXP 5
2019: PUSH
2020: LD_INT 3
2022: ARRAY
2023: PUSH
2024: LD_INT 1
2026: ARRAY
2027: PPUSH
2028: LD_EXP 5
2032: PUSH
2033: LD_INT 4
2035: ARRAY
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: LD_INT 30
2043: PPUSH
2044: CALL 70035 0 5
// GirlNewVeh := CreateVehicle ;
2048: LD_ADDR_EXP 57
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2058: LD_EXP 57
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2070: LD_EXP 57
2074: PPUSH
2075: LD_INT 82
2077: PPUSH
2078: LD_INT 96
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 48
// if JMMGirl = 1 then
2088: LD_EXP 7
2092: PUSH
2093: LD_INT 1
2095: EQUAL
2096: IFFALSE 2131
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2098: LD_ADDR_EXP 40
2102: PUSH
2103: LD_STRING Joan
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_STRING 14_
2111: PPUSH
2112: CALL 65211 0 3
2116: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2117: LD_EXP 40
2121: PPUSH
2122: LD_EXP 57
2126: PPUSH
2127: CALL_OW 52
// end ; if JMMGirl = 2 then
2131: LD_EXP 7
2135: PUSH
2136: LD_INT 2
2138: EQUAL
2139: IFFALSE 2174
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2141: LD_ADDR_EXP 42
2145: PUSH
2146: LD_STRING Lisa
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_STRING 14_
2154: PPUSH
2155: CALL 65211 0 3
2159: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2160: LD_EXP 42
2164: PPUSH
2165: LD_EXP 57
2169: PPUSH
2170: CALL_OW 52
// end ; if JMMGirl = 3 then
2174: LD_EXP 7
2178: PUSH
2179: LD_INT 3
2181: EQUAL
2182: IFFALSE 2217
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2184: LD_ADDR_EXP 54
2188: PUSH
2189: LD_STRING Connie
2191: PPUSH
2192: LD_INT 1
2194: PPUSH
2195: LD_STRING 14_
2197: PPUSH
2198: CALL 65211 0 3
2202: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2203: LD_EXP 54
2207: PPUSH
2208: LD_EXP 57
2212: PPUSH
2213: CALL_OW 52
// end ; end ; end ;
2217: LD_VAR 0 1
2221: RET
// export function PrepareStevensSquad ; var tmp ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
// uc_side := 1 ;
2226: LD_ADDR_OWVAR 20
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// uc_nation := 1 ;
2234: LD_ADDR_OWVAR 21
2238: PUSH
2239: LD_INT 1
2241: ST_TO_ADDR
// tmp := [ ] ;
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: EMPTY
2248: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2249: LD_ADDR_EXP 41
2253: PUSH
2254: LD_STRING Stevens
2256: PPUSH
2257: LD_EXP 1
2261: NOT
2262: PPUSH
2263: LD_STRING 13f_
2265: PPUSH
2266: CALL 65211 0 3
2270: ST_TO_ADDR
// if not Stevens then
2271: LD_EXP 41
2275: NOT
2276: IFFALSE 2332
// begin hc_name = Baker Smith ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING Baker Smith
2285: ST_TO_ADDR
// hc_gallery =  ;
2286: LD_ADDR_OWVAR 33
2290: PUSH
2291: LD_STRING 
2293: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 10
2299: PPUSH
2300: CALL_OW 384
// Baker = CreateHuman ;
2304: LD_ADDR_EXP 55
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 55
2328: ADD
2329: ST_TO_ADDR
// end else
2330: GO 2348
// tmp := tmp ^ Stevens ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: LD_EXP 41
2346: ADD
2347: ST_TO_ADDR
// if not Lisa then
2348: LD_EXP 42
2352: NOT
2353: IFFALSE 2399
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2355: LD_ADDR_EXP 42
2359: PUSH
2360: LD_STRING Lisa
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_STRING 13f_
2371: PPUSH
2372: CALL 65211 0 3
2376: ST_TO_ADDR
// if Lisa then
2377: LD_EXP 42
2381: IFFALSE 2399
// tmp := tmp ^ Lisa ;
2383: LD_ADDR_VAR 0 2
2387: PUSH
2388: LD_VAR 0 2
2392: PUSH
2393: LD_EXP 42
2397: ADD
2398: ST_TO_ADDR
// end ; if not Donaldson then
2399: LD_EXP 43
2403: NOT
2404: IFFALSE 2450
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2406: LD_ADDR_EXP 43
2410: PUSH
2411: LD_STRING Donaldson
2413: PPUSH
2414: LD_EXP 1
2418: NOT
2419: PPUSH
2420: LD_STRING 13f_
2422: PPUSH
2423: CALL 65211 0 3
2427: ST_TO_ADDR
// if Donaldson then
2428: LD_EXP 43
2432: IFFALSE 2450
// tmp := tmp ^ Donaldson ;
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 2
2443: PUSH
2444: LD_EXP 43
2448: ADD
2449: ST_TO_ADDR
// end ; if not Bobby then
2450: LD_EXP 44
2454: NOT
2455: IFFALSE 2501
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2457: LD_ADDR_EXP 44
2461: PUSH
2462: LD_STRING Bobby
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13f_
2473: PPUSH
2474: CALL 65211 0 3
2478: ST_TO_ADDR
// if Bobby then
2479: LD_EXP 44
2483: IFFALSE 2501
// tmp := tmp ^ Bobby ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 44
2499: ADD
2500: ST_TO_ADDR
// end ; if not Cyrus then
2501: LD_EXP 45
2505: NOT
2506: IFFALSE 2552
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2508: LD_ADDR_EXP 45
2512: PUSH
2513: LD_STRING Cyrus
2515: PPUSH
2516: LD_EXP 1
2520: NOT
2521: PPUSH
2522: LD_STRING 13f_
2524: PPUSH
2525: CALL 65211 0 3
2529: ST_TO_ADDR
// if Cyrus then
2530: LD_EXP 45
2534: IFFALSE 2552
// tmp := tmp ^ Cyrus ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_EXP 45
2550: ADD
2551: ST_TO_ADDR
// end ; if not Brown then
2552: LD_EXP 47
2556: NOT
2557: IFFALSE 2603
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2559: LD_ADDR_EXP 47
2563: PUSH
2564: LD_STRING Brown
2566: PPUSH
2567: LD_EXP 1
2571: NOT
2572: PPUSH
2573: LD_STRING 13f_
2575: PPUSH
2576: CALL 65211 0 3
2580: ST_TO_ADDR
// if Brown then
2581: LD_EXP 47
2585: IFFALSE 2603
// tmp := tmp ^ Brown ;
2587: LD_ADDR_VAR 0 2
2591: PUSH
2592: LD_VAR 0 2
2596: PUSH
2597: LD_EXP 47
2601: ADD
2602: ST_TO_ADDR
// end ; if not Gladstone then
2603: LD_EXP 48
2607: NOT
2608: IFFALSE 2654
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2610: LD_ADDR_EXP 48
2614: PUSH
2615: LD_STRING Gladstone
2617: PPUSH
2618: LD_EXP 1
2622: NOT
2623: PPUSH
2624: LD_STRING 13f_
2626: PPUSH
2627: CALL 65211 0 3
2631: ST_TO_ADDR
// if Gladstone then
2632: LD_EXP 48
2636: IFFALSE 2654
// tmp := tmp ^ Gladstone ;
2638: LD_ADDR_VAR 0 2
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 48
2652: ADD
2653: ST_TO_ADDR
// end ; if not Houten then
2654: LD_EXP 49
2658: NOT
2659: IFFALSE 2705
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2661: LD_ADDR_EXP 49
2665: PUSH
2666: LD_STRING Houten
2668: PPUSH
2669: LD_EXP 1
2673: NOT
2674: PPUSH
2675: LD_STRING 13f_
2677: PPUSH
2678: CALL 65211 0 3
2682: ST_TO_ADDR
// if Houten then
2683: LD_EXP 49
2687: IFFALSE 2705
// tmp := tmp ^ Houten ;
2689: LD_ADDR_VAR 0 2
2693: PUSH
2694: LD_VAR 0 2
2698: PUSH
2699: LD_EXP 49
2703: ADD
2704: ST_TO_ADDR
// end ; if not Cornel then
2705: LD_EXP 50
2709: NOT
2710: IFFALSE 2756
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2712: LD_ADDR_EXP 50
2716: PUSH
2717: LD_STRING Cornell
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13f_
2728: PPUSH
2729: CALL 65211 0 3
2733: ST_TO_ADDR
// if Cornel then
2734: LD_EXP 50
2738: IFFALSE 2756
// tmp := tmp ^ Cornel ;
2740: LD_ADDR_VAR 0 2
2744: PUSH
2745: LD_VAR 0 2
2749: PUSH
2750: LD_EXP 50
2754: ADD
2755: ST_TO_ADDR
// end ; if not Gary then
2756: LD_EXP 51
2760: NOT
2761: IFFALSE 2807
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2763: LD_ADDR_EXP 51
2767: PUSH
2768: LD_STRING Gary
2770: PPUSH
2771: LD_EXP 1
2775: NOT
2776: PPUSH
2777: LD_STRING 13f_
2779: PPUSH
2780: CALL 65211 0 3
2784: ST_TO_ADDR
// if Gary then
2785: LD_EXP 51
2789: IFFALSE 2807
// tmp := tmp ^ Gary ;
2791: LD_ADDR_VAR 0 2
2795: PUSH
2796: LD_VAR 0 2
2800: PUSH
2801: LD_EXP 51
2805: ADD
2806: ST_TO_ADDR
// end ; if not Frank then
2807: LD_EXP 52
2811: NOT
2812: IFFALSE 2858
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2814: LD_ADDR_EXP 52
2818: PUSH
2819: LD_STRING Frank
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_STRING 13f_
2830: PPUSH
2831: CALL 65211 0 3
2835: ST_TO_ADDR
// if Frank then
2836: LD_EXP 52
2840: IFFALSE 2858
// tmp := tmp ^ Frank ;
2842: LD_ADDR_VAR 0 2
2846: PUSH
2847: LD_VAR 0 2
2851: PUSH
2852: LD_EXP 52
2856: ADD
2857: ST_TO_ADDR
// end ; if not Kikuchi then
2858: LD_EXP 53
2862: NOT
2863: IFFALSE 2909
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2865: LD_ADDR_EXP 53
2869: PUSH
2870: LD_STRING Kikuchi
2872: PPUSH
2873: LD_EXP 1
2877: NOT
2878: PPUSH
2879: LD_STRING 13f_
2881: PPUSH
2882: CALL 65211 0 3
2886: ST_TO_ADDR
// if Kikuchi then
2887: LD_EXP 53
2891: IFFALSE 2909
// tmp := tmp ^ Kikuchi ;
2893: LD_ADDR_VAR 0 2
2897: PUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_EXP 53
2907: ADD
2908: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_STRING 13_other_survivors
2921: PPUSH
2922: CALL_OW 31
2926: UNION
2927: ST_TO_ADDR
// result := tmp ;
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_VAR 0 2
2937: ST_TO_ADDR
// end ; end_of_file
2938: LD_VAR 0 1
2942: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2943: LD_INT 0
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
// uc_side := 4 ;
2955: LD_ADDR_OWVAR 20
2959: PUSH
2960: LD_INT 4
2962: ST_TO_ADDR
// uc_nation := 1 ;
2963: LD_ADDR_OWVAR 21
2967: PUSH
2968: LD_INT 1
2970: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2971: LD_INT 387
2973: PPUSH
2974: CALL_OW 274
2978: PPUSH
2979: LD_INT 1
2981: PPUSH
2982: LD_INT 3500
2984: PUSH
2985: LD_INT 3000
2987: PUSH
2988: LD_INT 2500
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_OWVAR 67
3000: ARRAY
3001: PPUSH
3002: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3006: LD_INT 387
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 2
3016: PPUSH
3017: LD_INT 400
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3024: LD_INT 387
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 3
3034: PPUSH
3035: LD_INT 10
3037: PPUSH
3038: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3042: LD_ADDR_EXP 58
3046: PUSH
3047: LD_STRING Powell
3049: PPUSH
3050: CALL_OW 25
3054: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3055: LD_EXP 58
3059: PPUSH
3060: LD_INT 57
3062: PPUSH
3063: LD_INT 94
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3073: LD_EXP 58
3077: PPUSH
3078: LD_INT 58
3080: PPUSH
3081: LD_INT 94
3083: PPUSH
3084: CALL_OW 118
// vip := [ ] ;
3088: LD_ADDR_EXP 59
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// tmp := [ ] ;
3095: LD_ADDR_VAR 0 6
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// if JMMGirl <> 2 then
3102: LD_EXP 7
3106: PUSH
3107: LD_INT 2
3109: NONEQUAL
3110: IFFALSE 3134
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3112: LD_ADDR_EXP 42
3116: PUSH
3117: LD_STRING Lisa
3119: PPUSH
3120: LD_EXP 1
3124: NOT
3125: PPUSH
3126: LD_STRING 13s_
3128: PPUSH
3129: CALL 65211 0 3
3133: ST_TO_ADDR
// if Lisa then
3134: LD_EXP 42
3138: IFFALSE 3156
// tmp := tmp ^ Lisa ;
3140: LD_ADDR_VAR 0 6
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: LD_EXP 42
3154: ADD
3155: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3156: LD_ADDR_EXP 43
3160: PUSH
3161: LD_STRING Donaldson
3163: PPUSH
3164: LD_EXP 1
3168: NOT
3169: PPUSH
3170: LD_STRING 13s_
3172: PPUSH
3173: CALL 65211 0 3
3177: ST_TO_ADDR
// if Donaldson then
3178: LD_EXP 43
3182: IFFALSE 3200
// tmp := tmp ^ Donaldson ;
3184: LD_ADDR_VAR 0 6
3188: PUSH
3189: LD_VAR 0 6
3193: PUSH
3194: LD_EXP 43
3198: ADD
3199: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3200: LD_ADDR_EXP 44
3204: PUSH
3205: LD_STRING Bobby
3207: PPUSH
3208: LD_EXP 1
3212: NOT
3213: PPUSH
3214: LD_STRING 13s_
3216: PPUSH
3217: CALL 65211 0 3
3221: ST_TO_ADDR
// if Bobby then
3222: LD_EXP 44
3226: IFFALSE 3244
// tmp := tmp ^ Bobby ;
3228: LD_ADDR_VAR 0 6
3232: PUSH
3233: LD_VAR 0 6
3237: PUSH
3238: LD_EXP 44
3242: ADD
3243: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3244: LD_ADDR_EXP 45
3248: PUSH
3249: LD_STRING Cyrus
3251: PPUSH
3252: LD_EXP 1
3256: NOT
3257: PPUSH
3258: LD_STRING 13s_
3260: PPUSH
3261: CALL 65211 0 3
3265: ST_TO_ADDR
// if Cyrus then
3266: LD_EXP 45
3270: IFFALSE 3288
// tmp := tmp ^ Cyrus ;
3272: LD_ADDR_VAR 0 6
3276: PUSH
3277: LD_VAR 0 6
3281: PUSH
3282: LD_EXP 45
3286: ADD
3287: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3288: LD_ADDR_EXP 46
3292: PUSH
3293: LD_STRING Denis
3295: PPUSH
3296: LD_EXP 1
3300: NOT
3301: PPUSH
3302: LD_STRING 13s_
3304: PPUSH
3305: CALL 65211 0 3
3309: ST_TO_ADDR
// if not Denis then
3310: LD_EXP 46
3314: NOT
3315: IFFALSE 3339
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3317: LD_ADDR_EXP 46
3321: PUSH
3322: LD_STRING Denis
3324: PPUSH
3325: LD_EXP 1
3329: NOT
3330: PPUSH
3331: LD_STRING 13f_
3333: PPUSH
3334: CALL 65211 0 3
3338: ST_TO_ADDR
// if Denis then
3339: LD_EXP 46
3343: IFFALSE 3361
// tmp := tmp ^ Denis ;
3345: LD_ADDR_VAR 0 6
3349: PUSH
3350: LD_VAR 0 6
3354: PUSH
3355: LD_EXP 46
3359: ADD
3360: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3361: LD_ADDR_EXP 47
3365: PUSH
3366: LD_STRING Brown
3368: PPUSH
3369: LD_EXP 1
3373: NOT
3374: PPUSH
3375: LD_STRING 13s_
3377: PPUSH
3378: CALL 65211 0 3
3382: ST_TO_ADDR
// if Brown then
3383: LD_EXP 47
3387: IFFALSE 3405
// tmp := tmp ^ Brown ;
3389: LD_ADDR_VAR 0 6
3393: PUSH
3394: LD_VAR 0 6
3398: PUSH
3399: LD_EXP 47
3403: ADD
3404: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3405: LD_ADDR_EXP 48
3409: PUSH
3410: LD_STRING Gladstone
3412: PPUSH
3413: LD_EXP 1
3417: NOT
3418: PPUSH
3419: LD_STRING 13s_
3421: PPUSH
3422: CALL 65211 0 3
3426: ST_TO_ADDR
// if Gladstone then
3427: LD_EXP 48
3431: IFFALSE 3449
// tmp := tmp ^ Gladstone ;
3433: LD_ADDR_VAR 0 6
3437: PUSH
3438: LD_VAR 0 6
3442: PUSH
3443: LD_EXP 48
3447: ADD
3448: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3449: LD_ADDR_EXP 49
3453: PUSH
3454: LD_STRING Houten
3456: PPUSH
3457: LD_EXP 1
3461: NOT
3462: PPUSH
3463: LD_STRING 13s_
3465: PPUSH
3466: CALL 65211 0 3
3470: ST_TO_ADDR
// if Houten then
3471: LD_EXP 49
3475: IFFALSE 3493
// tmp := tmp ^ Houten ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_VAR 0 6
3486: PUSH
3487: LD_EXP 49
3491: ADD
3492: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_STRING Cornel
3500: PPUSH
3501: LD_EXP 1
3505: NOT
3506: PPUSH
3507: LD_STRING 13s_
3509: PPUSH
3510: CALL 65211 0 3
3514: ST_TO_ADDR
// if Cornel then
3515: LD_EXP 50
3519: IFFALSE 3537
// tmp := tmp ^ Cornel ;
3521: LD_ADDR_VAR 0 6
3525: PUSH
3526: LD_VAR 0 6
3530: PUSH
3531: LD_EXP 50
3535: ADD
3536: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3537: LD_ADDR_EXP 51
3541: PUSH
3542: LD_STRING Gary
3544: PPUSH
3545: LD_EXP 1
3549: NOT
3550: PPUSH
3551: LD_STRING 13s_
3553: PPUSH
3554: CALL 65211 0 3
3558: ST_TO_ADDR
// if Gary then
3559: LD_EXP 51
3563: IFFALSE 3581
// tmp := tmp ^ Gary ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: LD_EXP 51
3579: ADD
3580: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3581: LD_ADDR_EXP 52
3585: PUSH
3586: LD_STRING Frank
3588: PPUSH
3589: LD_EXP 1
3593: NOT
3594: PPUSH
3595: LD_STRING 13s_
3597: PPUSH
3598: CALL 65211 0 3
3602: ST_TO_ADDR
// if Frank then
3603: LD_EXP 52
3607: IFFALSE 3625
// tmp := tmp ^ Frank ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_VAR 0 6
3618: PUSH
3619: LD_EXP 52
3623: ADD
3624: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3625: LD_ADDR_EXP 53
3629: PUSH
3630: LD_STRING Kikuchi
3632: PPUSH
3633: LD_EXP 1
3637: NOT
3638: PPUSH
3639: LD_STRING 13s_
3641: PPUSH
3642: CALL 65211 0 3
3646: ST_TO_ADDR
// if Kikuchi then
3647: LD_EXP 53
3651: IFFALSE 3669
// tmp := tmp ^ Kikuchi ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_VAR 0 6
3662: PUSH
3663: LD_EXP 53
3667: ADD
3668: ST_TO_ADDR
// vip := tmp ;
3669: LD_ADDR_EXP 59
3673: PUSH
3674: LD_VAR 0 6
3678: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_VAR 0 6
3688: PUSH
3689: LD_STRING 13s_others
3691: PPUSH
3692: CALL_OW 31
3696: UNION
3697: ST_TO_ADDR
// if tmp < 18 then
3698: LD_VAR 0 6
3702: PUSH
3703: LD_INT 18
3705: LESS
3706: IFFALSE 3773
// for i = 1 to 18 - tmp do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 18
3720: PUSH
3721: LD_VAR 0 6
3725: MINUS
3726: PUSH
3727: FOR_TO
3728: IFFALSE 3771
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PUSH
3738: LD_INT 4
3740: MOD
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_INT 5
3748: PPUSH
3749: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3753: LD_ADDR_VAR 0 6
3757: PUSH
3758: LD_VAR 0 6
3762: PUSH
3763: CALL_OW 44
3767: ADD
3768: ST_TO_ADDR
// end ;
3769: GO 3727
3771: POP
3772: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_INT 22
3780: PUSH
3781: LD_INT 4
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 30
3790: PUSH
3791: LD_INT 0
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 4
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 6
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3849: LD_ADDR_VAR 0 9
3853: PUSH
3854: LD_INT 22
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 4
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3887: LD_ADDR_VAR 0 10
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 4
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: ST_TO_ADDR
// for i in tmp do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: LD_VAR 0 6
3934: PUSH
3935: FOR_IN
3936: IFFALSE 4062
// begin cl := GetClass ( i ) ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 257
3952: ST_TO_ADDR
// if cl > 4 then
3953: LD_VAR 0 5
3957: PUSH
3958: LD_INT 4
3960: GREATER
3961: IFFALSE 3971
// cl := 1 ;
3963: LD_ADDR_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 9
3980: PUSH
3981: LD_VAR 0 7
3985: PUSH
3986: LD_VAR 0 10
3990: PUSH
3991: LD_VAR 0 8
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_VAR 0 5
4006: ARRAY
4007: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4008: LD_VAR 0 3
4012: PPUSH
4013: CALL_OW 313
4017: PUSH
4018: LD_INT 6
4020: LESS
4021: IFFALSE 4039
// PlaceHumanInUnit ( i , b ) else
4023: LD_VAR 0 2
4027: PPUSH
4028: LD_VAR 0 3
4032: PPUSH
4033: CALL_OW 52
4037: GO 4060
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4039: LD_VAR 0 2
4043: PPUSH
4044: LD_INT 61
4046: PPUSH
4047: LD_INT 89
4049: PPUSH
4050: LD_INT 6
4052: PPUSH
4053: LD_INT 0
4055: PPUSH
4056: CALL_OW 50
// end ;
4060: GO 3935
4062: POP
4063: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4064: LD_INT 2
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 12
4075: PPUSH
4076: LD_INT 100
4078: PPUSH
4079: CALL 70035 0 5
// veh := CreateVehicle ;
4083: LD_ADDR_VAR 0 4
4087: PUSH
4088: CALL_OW 45
4092: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4105: LD_VAR 0 4
4109: PPUSH
4110: LD_INT 49
4112: PPUSH
4113: LD_INT 88
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4123: LD_VAR 0 4
4127: PPUSH
4128: LD_INT 1
4130: PPUSH
4131: LD_INT 100
4133: PPUSH
4134: CALL_OW 290
// uc_side := 0 ;
4138: LD_ADDR_OWVAR 20
4142: PUSH
4143: LD_INT 0
4145: ST_TO_ADDR
// uc_nation := 0 ;
4146: LD_ADDR_OWVAR 21
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// for i = 1 to 4 do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_INT 4
4166: PUSH
4167: FOR_TO
4168: IFFALSE 4199
// begin InitHc ;
4170: CALL_OW 19
// hc_class := class_apeman ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 12
4181: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4182: CALL_OW 44
4186: PPUSH
4187: LD_INT 13
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 49
// end ;
4197: GO 4167
4199: POP
4200: POP
// end ; end_of_file
4201: LD_VAR 0 1
4205: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4206: LD_INT 0
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
// side := 8 ;
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: LD_INT 8
4220: ST_TO_ADDR
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 3
4230: ST_TO_ADDR
// uc_nation := 2 ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_INT 2
4238: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_VAR 0 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetBLevel ( i , 10 ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 10
4285: PPUSH
4286: CALL_OW 241
4290: GO 4275
4292: POP
4293: POP
// if KurtStatus then
4294: LD_EXP 3
4298: IFFALSE 4321
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4300: LD_ADDR_EXP 60
4304: PUSH
4305: LD_STRING Kurt
4307: PPUSH
4308: LD_INT 0
4310: PPUSH
4311: LD_STRING 
4313: PPUSH
4314: CALL 65211 0 3
4318: ST_TO_ADDR
4319: GO 4343
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4321: LD_ADDR_EXP 60
4325: PUSH
4326: LD_STRING AltKurt
4328: PPUSH
4329: LD_EXP 1
4333: NOT
4334: PPUSH
4335: LD_STRING 
4337: PPUSH
4338: CALL 65211 0 3
4342: ST_TO_ADDR
// if not Kurt then
4343: LD_EXP 60
4347: NOT
4348: IFFALSE 4374
// begin InitHc ;
4350: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 10
4359: PPUSH
4360: CALL_OW 381
// Kurt := CreateHuman ;
4364: LD_ADDR_EXP 60
4368: PUSH
4369: CALL_OW 44
4373: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4374: LD_EXP 60
4378: PPUSH
4379: LD_INT 324
4381: PPUSH
4382: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4386: LD_ADDR_EXP 61
4390: PUSH
4391: LD_STRING Kozlov
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: LD_STRING 
4399: PPUSH
4400: CALL 65211 0 3
4404: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4405: LD_EXP 61
4409: PPUSH
4410: LD_INT 22
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 23
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 30
4432: PUSH
4433: LD_INT 8
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4458: LD_EXP 61
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 10
4468: PPUSH
4469: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 4
4480: PPUSH
4481: LD_INT 10
4483: PPUSH
4484: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: LD_INT 22
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 30
4507: PUSH
4508: LD_INT 32
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 58
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 69
4530: ST_TO_ADDR
// for i = 1 to 10 do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: DOUBLE
4537: LD_INT 1
4539: DEC
4540: ST_TO_ADDR
4541: LD_INT 10
4543: PUSH
4544: FOR_TO
4545: IFFALSE 4617
// begin uc_nation := nation_nature ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 0
4554: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4555: LD_ADDR_OWVAR 28
4559: PUSH
4560: LD_INT 15
4562: ST_TO_ADDR
// hc_gallery :=  ;
4563: LD_ADDR_OWVAR 33
4567: PUSH
4568: LD_STRING 
4570: ST_TO_ADDR
// hc_name :=  ;
4571: LD_ADDR_OWVAR 26
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// un := CreateHuman ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: CALL_OW 44
4588: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_VAR 0 5
4598: PUSH
4599: LD_VAR 0 5
4603: PUSH
4604: LD_VAR 0 2
4608: MINUS
4609: ARRAY
4610: PPUSH
4611: CALL_OW 52
// end ;
4615: GO 4544
4617: POP
4618: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: LD_STRING 12_kurt_squad
4626: PPUSH
4627: CALL_OW 31
4631: ST_TO_ADDR
// if tmp then
4632: LD_VAR 0 5
4636: IFFALSE 4670
// for i in tmp do
4638: LD_ADDR_VAR 0 2
4642: PUSH
4643: LD_VAR 0 5
4647: PUSH
4648: FOR_IN
4649: IFFALSE 4668
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_INT 5
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 49
4666: GO 4648
4668: POP
4669: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4670: LD_INT 324
4672: PPUSH
4673: LD_INT 5
4675: PPUSH
4676: LD_STRING 
4678: PPUSH
4679: LD_INT 8
4681: PUSH
4682: LD_INT 9
4684: PUSH
4685: LD_INT 10
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 3000
4701: PUSH
4702: LD_INT 500
4704: PUSH
4705: LD_INT 150
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 16
4715: PUSH
4716: LD_INT 6
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 8
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 73444 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4735: LD_ADDR_EXP 113
4739: PUSH
4740: LD_EXP 113
4744: PPUSH
4745: LD_INT 3
4747: PPUSH
4748: LD_INT 22
4750: PUSH
4751: LD_VAR 0 3
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 23
4762: PUSH
4763: LD_INT 2
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 21
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL_OW 69
4796: PUSH
4797: LD_EXP 60
4801: DIFF
4802: PPUSH
4803: CALL_OW 1
4807: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 7
4813: PPUSH
4814: CALL_OW 383
// Friend := CreateHuman ;
4818: LD_ADDR_EXP 62
4822: PUSH
4823: CALL_OW 44
4827: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4828: LD_INT 14
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 29
4839: PPUSH
4840: LD_INT 100
4842: PPUSH
4843: CALL 70035 0 5
// powellBomb := CreateVehicle ;
4847: LD_ADDR_EXP 63
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4857: LD_EXP 63
4861: PPUSH
4862: LD_INT 90
4864: PPUSH
4865: LD_INT 51
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// end ;
4875: LD_VAR 0 1
4879: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// if IsLive ( kozlov_fac ) then
4885: LD_INT 332
4887: PPUSH
4888: CALL_OW 300
4892: IFFALSE 4896
// exit ;
4894: GO 5463
// ComExitBuilding ( Kozlov ) ;
4896: LD_EXP 61
4900: PPUSH
4901: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4905: LD_EXP 61
4909: PPUSH
4910: CALL_OW 257
4914: PUSH
4915: LD_INT 2
4917: NONEQUAL
4918: IFFALSE 4953
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4920: LD_EXP 61
4924: PPUSH
4925: LD_INT 324
4927: PPUSH
4928: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 2
4939: PPUSH
4940: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4944: LD_EXP 61
4948: PPUSH
4949: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4953: LD_EXP 61
4957: PPUSH
4958: LD_INT 2
4960: PPUSH
4961: LD_INT 93
4963: PPUSH
4964: LD_INT 32
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4981: LD_INT 22
4983: PUSH
4984: LD_INT 8
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: LD_INT 23
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 57
5013: PUSH
5014: EMPTY
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PPUSH
5023: CALL_OW 69
5027: IFFALSE 4974
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 8
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 3
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 23
5056: PUSH
5057: LD_INT 3
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 57
5066: PUSH
5067: EMPTY
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 69
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5085: LD_INT 22
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 23
5097: PUSH
5098: LD_INT 3
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 30
5107: PUSH
5108: LD_INT 21
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 5203
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5127: LD_EXP 61
5131: PPUSH
5132: LD_INT 21
5134: PPUSH
5135: LD_INT 97
5137: PPUSH
5138: LD_INT 36
5140: PPUSH
5141: LD_INT 5
5143: PPUSH
5144: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5148: LD_INT 35
5150: PPUSH
5151: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5155: LD_INT 22
5157: PUSH
5158: LD_INT 8
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: LD_INT 23
5167: PUSH
5168: LD_INT 3
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 30
5177: PUSH
5178: LD_INT 21
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 57
5187: PUSH
5188: EMPTY
5189: LIST
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: IFFALSE 5148
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5203: LD_INT 22
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 23
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 30
5225: PUSH
5226: LD_INT 18
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 69
5242: NOT
5243: IFFALSE 5321
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5245: LD_EXP 61
5249: PPUSH
5250: LD_INT 18
5252: PPUSH
5253: LD_INT 89
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 23
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 30
5295: PUSH
5296: LD_INT 18
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// end ; lab := kozlov_lab ;
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: LD_INT 336
5328: ST_TO_ADDR
// if not lab then
5329: LD_VAR 0 3
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5463
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5338: LD_EXP 61
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5356: LD_EXP 61
5360: PPUSH
5361: LD_INT 4
5363: PPUSH
5364: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: LD_INT 25
5379: PPUSH
5380: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5384: LD_INT 35
5386: PPUSH
5387: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5391: LD_INT 25
5393: PPUSH
5394: LD_INT 8
5396: PPUSH
5397: CALL_OW 321
5401: PUSH
5402: LD_INT 2
5404: EQUAL
5405: IFFALSE 5384
// ComExitBuilding ( Kozlov ) ;
5407: LD_EXP 61
5411: PPUSH
5412: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5416: LD_EXP 61
5420: PPUSH
5421: LD_VAR 0 2
5425: PPUSH
5426: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5430: LD_EXP 61
5434: PPUSH
5435: LD_INT 3
5437: PPUSH
5438: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_INT 23
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 1
5455: PPUSH
5456: LD_INT 48
5458: PPUSH
5459: CALL_OW 125
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5468: LD_EXP 22
5472: NOT
5473: PUSH
5474: LD_EXP 15
5478: PUSH
5479: LD_INT 6
5481: GREATEREQUAL
5482: AND
5483: IFFALSE 5564
5485: GO 5487
5487: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5488: LD_INT 3
5490: PPUSH
5491: LD_INT 3
5493: PPUSH
5494: CALL 58985 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5498: LD_INT 3
5500: PPUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 14
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 14
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 28
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL 58848 0 2
// end ;
5564: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5565: LD_EXP 22
5569: NOT
5570: PUSH
5571: LD_EXP 15
5575: PUSH
5576: LD_INT 6
5578: GREATEREQUAL
5579: AND
5580: PUSH
5581: LD_INT 3
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: CALL 60266 0 2
5591: NOT
5592: AND
5593: IFFALSE 6433
5595: GO 5597
5597: DISABLE
5598: LD_INT 0
5600: PPUSH
5601: PPUSH
5602: PPUSH
// begin enable ;
5603: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5604: LD_INT 22
5606: PUSH
5607: LD_INT 8
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 23
5616: PUSH
5617: LD_INT 2
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: NOT
5644: IFFALSE 5648
// exit ;
5646: GO 6433
// if Prob ( 40 ) then
5648: LD_INT 40
5650: PPUSH
5651: CALL_OW 13
5655: IFFALSE 5782
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5657: LD_INT 3
5659: PPUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 28
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 14
5734: PUSH
5735: LD_INT 1
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 28
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 14
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 26
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL 58848 0 2
// end else
5780: GO 5973
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5782: LD_INT 3
5784: PPUSH
5785: LD_INT 14
5787: PUSH
5788: LD_INT 1
5790: PUSH
5791: LD_INT 2
5793: PUSH
5794: LD_INT 27
5796: PUSH
5797: LD_INT 26
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 14
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: LD_INT 2
5828: PUSH
5829: LD_INT 27
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_OWVAR 67
5847: ARRAY
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 14
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 26
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: LD_OWVAR 67
5882: ARRAY
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 13
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: LD_INT 26
5901: PUSH
5902: LD_INT 29
5904: PUSH
5905: LD_INT 29
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: PUSH
5913: LD_OWVAR 67
5917: ARRAY
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 13
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 29
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 14
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 26
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PPUSH
5969: CALL 58848 0 2
// end ; repeat wait ( 0 0$1 ) ;
5973: LD_INT 35
5975: PPUSH
5976: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5980: LD_INT 3
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL 60266 0 2
5990: PUSH
5991: LD_INT 6
5993: GREATEREQUAL
5994: IFFALSE 5973
// wait ( 0 0$30 ) ;
5996: LD_INT 1050
5998: PPUSH
5999: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60266 0 2
6018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6019: LD_ADDR_EXP 132
6023: PUSH
6024: LD_EXP 132
6028: PPUSH
6029: LD_INT 3
6031: PPUSH
6032: LD_EXP 132
6036: PUSH
6037: LD_INT 3
6039: ARRAY
6040: PUSH
6041: LD_VAR 0 2
6045: DIFF
6046: PPUSH
6047: CALL_OW 1
6051: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6052: LD_ADDR_VAR 0 3
6056: PUSH
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 2
6062: PPUSH
6063: CALL_OW 12
6067: ST_TO_ADDR
// if target then
6068: LD_VAR 0 3
6072: IFFALSE 6200
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 24
6086: PUSH
6087: LD_INT 250
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL_OW 72
6098: ST_TO_ADDR
// for i in tmp do
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_VAR 0 2
6108: PUSH
6109: FOR_IN
6110: IFFALSE 6150
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6112: LD_VAR 0 1
6116: PPUSH
6117: LD_INT 89
6119: PPUSH
6120: LD_INT 71
6122: PPUSH
6123: CALL_OW 297
6127: PUSH
6128: LD_INT 9
6130: GREATER
6131: IFFALSE 6148
// ComMoveXY ( i , 89 , 71 ) ;
6133: LD_VAR 0 1
6137: PPUSH
6138: LD_INT 89
6140: PPUSH
6141: LD_INT 71
6143: PPUSH
6144: CALL_OW 111
6148: GO 6109
6150: POP
6151: POP
// wait ( 0 0$1 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 92
6166: PUSH
6167: LD_INT 89
6169: PUSH
6170: LD_INT 71
6172: PUSH
6173: LD_INT 9
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_VAR 0 2
6191: PUSH
6192: LD_INT 1
6194: MINUS
6195: GREATEREQUAL
6196: IFFALSE 6074
// end else
6198: GO 6324
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_INT 24
6212: PUSH
6213: LD_INT 250
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: ST_TO_ADDR
// for i in tmp do
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_VAR 0 2
6234: PUSH
6235: FOR_IN
6236: IFFALSE 6276
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6238: LD_VAR 0 1
6242: PPUSH
6243: LD_INT 125
6245: PPUSH
6246: LD_INT 129
6248: PPUSH
6249: CALL_OW 297
6253: PUSH
6254: LD_INT 9
6256: GREATER
6257: IFFALSE 6274
// ComMoveXY ( i , 125 , 129 ) ;
6259: LD_VAR 0 1
6263: PPUSH
6264: LD_INT 125
6266: PPUSH
6267: LD_INT 129
6269: PPUSH
6270: CALL_OW 111
6274: GO 6235
6276: POP
6277: POP
// wait ( 0 0$1 ) ;
6278: LD_INT 35
6280: PPUSH
6281: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 92
6292: PUSH
6293: LD_INT 125
6295: PUSH
6296: LD_INT 129
6298: PUSH
6299: LD_INT 9
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PPUSH
6308: CALL_OW 72
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_INT 1
6320: MINUS
6321: GREATEREQUAL
6322: IFFALSE 6200
// end ; repeat wait ( 0 0$1 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// for i in tmp do
6331: LD_ADDR_VAR 0 1
6335: PUSH
6336: LD_VAR 0 2
6340: PUSH
6341: FOR_IN
6342: IFFALSE 6424
// begin if GetLives ( i ) > 251 then
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 256
6353: PUSH
6354: LD_INT 251
6356: GREATER
6357: IFFALSE 6395
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6359: LD_VAR 0 1
6363: PPUSH
6364: LD_INT 81
6366: PUSH
6367: LD_INT 8
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PPUSH
6374: CALL_OW 69
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: PPUSH
6389: CALL_OW 115
6393: GO 6422
// if IsDead ( i ) then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 301
6404: IFFALSE 6422
// tmp := tmp diff i ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 2
6415: PUSH
6416: LD_VAR 0 1
6420: DIFF
6421: ST_TO_ADDR
// end ;
6422: GO 6341
6424: POP
6425: POP
// until not tmp ;
6426: LD_VAR 0 2
6430: NOT
6431: IFFALSE 6324
// end ;
6433: PPOPN 3
6435: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6436: LD_EXP 22
6440: NOT
6441: PUSH
6442: LD_EXP 15
6446: PUSH
6447: LD_INT 6
6449: GREATEREQUAL
6450: AND
6451: PUSH
6452: LD_OWVAR 67
6456: PUSH
6457: LD_INT 1
6459: GREATER
6460: AND
6461: IFFALSE 6978
6463: GO 6465
6465: DISABLE
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
// begin enable ;
6471: ENABLE
// tmp := [ ] ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6479: LD_ADDR_VAR 0 1
6483: PUSH
6484: DOUBLE
6485: LD_INT 1
6487: DEC
6488: ST_TO_ADDR
6489: LD_INT 4
6491: PUSH
6492: LD_INT 6
6494: PUSH
6495: LD_INT 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_OWVAR 67
6507: ARRAY
6508: PUSH
6509: FOR_TO
6510: IFFALSE 6670
// begin uc_side := 8 ;
6512: LD_ADDR_OWVAR 20
6516: PUSH
6517: LD_INT 8
6519: ST_TO_ADDR
// uc_nation := 2 ;
6520: LD_ADDR_OWVAR 21
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6528: LD_INT 13
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 1
6540: PPUSH
6541: LD_INT 2
6543: PPUSH
6544: CALL_OW 12
6548: ARRAY
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 27
6558: PUSH
6559: LD_INT 28
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 1
6576: PPUSH
6577: LD_INT 4
6579: PPUSH
6580: CALL_OW 12
6584: ARRAY
6585: PPUSH
6586: LD_INT 88
6588: PPUSH
6589: CALL 70035 0 5
// un := CreateVehicle ;
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: CALL_OW 45
6602: ST_TO_ADDR
// tmp := tmp ^ un ;
6603: LD_ADDR_VAR 0 3
6607: PUSH
6608: LD_VAR 0 3
6612: PUSH
6613: LD_VAR 0 2
6617: ADD
6618: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6619: LD_VAR 0 2
6623: PPUSH
6624: LD_INT 3
6626: PPUSH
6627: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_INT 30
6638: PPUSH
6639: LD_INT 0
6641: PPUSH
6642: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6646: LD_VAR 0 2
6650: PPUSH
6651: LD_INT 16
6653: PPUSH
6654: LD_INT 11
6656: PPUSH
6657: CALL_OW 111
// wait ( 0 0$2 ) ;
6661: LD_INT 70
6663: PPUSH
6664: CALL_OW 67
// end ;
6668: GO 6509
6670: POP
6671: POP
// for i = 1 to Difficulty do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_OWVAR 67
6686: PUSH
6687: FOR_TO
6688: IFFALSE 6813
// begin uc_side := 8 ;
6690: LD_ADDR_OWVAR 20
6694: PUSH
6695: LD_INT 8
6697: ST_TO_ADDR
// uc_nation := 2 ;
6698: LD_ADDR_OWVAR 21
6702: PUSH
6703: LD_INT 2
6705: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6706: LD_INT 0
6708: PPUSH
6709: LD_INT 8
6711: PPUSH
6712: LD_INT 8
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: LD_INT 9
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_OWVAR 67
6730: ARRAY
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 2
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// tmp := tmp ^ un ;
6746: LD_ADDR_VAR 0 3
6750: PUSH
6751: LD_VAR 0 3
6755: PUSH
6756: LD_VAR 0 2
6760: ADD
6761: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 3
6769: PPUSH
6770: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 30
6781: PPUSH
6782: LD_INT 0
6784: PPUSH
6785: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 16
6796: PPUSH
6797: LD_INT 11
6799: PPUSH
6800: CALL_OW 111
// wait ( 0 0$2 ) ;
6804: LD_INT 70
6806: PPUSH
6807: CALL_OW 67
// end ;
6811: GO 6687
6813: POP
6814: POP
// repeat wait ( 0 0$1 ) ;
6815: LD_INT 35
6817: PPUSH
6818: CALL_OW 67
// for i in tmp do
6822: LD_ADDR_VAR 0 1
6826: PUSH
6827: LD_VAR 0 3
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6969
// begin if GetLives ( i ) > 250 then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 256
6844: PUSH
6845: LD_INT 250
6847: GREATER
6848: IFFALSE 6940
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6850: LD_INT 81
6852: PUSH
6853: LD_INT 8
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: LD_INT 91
6862: PUSH
6863: LD_VAR 0 1
6867: PUSH
6868: LD_INT 10
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 69
6884: NOT
6885: IFFALSE 6904
// ComAgressiveMove ( i , 67 , 110 ) else
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_INT 67
6894: PPUSH
6895: LD_INT 110
6897: PPUSH
6898: CALL_OW 114
6902: GO 6938
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 81
6911: PUSH
6912: LD_INT 8
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PPUSH
6919: CALL_OW 69
6923: PPUSH
6924: LD_VAR 0 1
6928: PPUSH
6929: CALL_OW 74
6933: PPUSH
6934: CALL_OW 115
// end else
6938: GO 6967
// if IsDead ( i ) then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 301
6949: IFFALSE 6967
// tmp := tmp diff i ;
6951: LD_ADDR_VAR 0 3
6955: PUSH
6956: LD_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: DIFF
6966: ST_TO_ADDR
// end ;
6967: GO 6832
6969: POP
6970: POP
// until not tmp ;
6971: LD_VAR 0 3
6975: NOT
6976: IFFALSE 6815
// end ; end_of_file
6978: PPOPN 3
6980: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6981: LD_INT 0
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
6989: PPUSH
6990: PPUSH
6991: PPUSH
// side := 3 ;
6992: LD_ADDR_VAR 0 6
6996: PUSH
6997: LD_INT 3
6999: ST_TO_ADDR
// uc_side := side ;
7000: LD_ADDR_OWVAR 20
7004: PUSH
7005: LD_VAR 0 6
7009: ST_TO_ADDR
// uc_nation := 3 ;
7010: LD_ADDR_OWVAR 21
7014: PUSH
7015: LD_INT 3
7017: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_VAR 0 6
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: FOR_IN
7055: IFFALSE 7071
// SetBLevel ( i , 10 ) ;
7057: LD_VAR 0 2
7061: PPUSH
7062: LD_INT 10
7064: PPUSH
7065: CALL_OW 241
7069: GO 7054
7071: POP
7072: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7073: LD_ADDR_VAR 0 9
7077: PUSH
7078: LD_INT 22
7080: PUSH
7081: LD_VAR 0 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 34
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: ST_TO_ADDR
// if teleport then
7109: LD_VAR 0 9
7113: IFFALSE 7134
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7115: LD_VAR 0 9
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_INT 123
7126: PPUSH
7127: LD_INT 122
7129: PPUSH
7130: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7134: LD_ADDR_EXP 64
7138: PUSH
7139: LD_STRING Platonov
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7147: LD_ADDR_EXP 65
7151: PUSH
7152: LD_STRING Kovalyuk
7154: PPUSH
7155: CALL_OW 25
7159: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7160: LD_ADDR_EXP 67
7164: PUSH
7165: LD_STRING Yakotich
7167: PPUSH
7168: LD_EXP 1
7172: NOT
7173: PPUSH
7174: LD_STRING 09_
7176: PPUSH
7177: CALL 65211 0 3
7181: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7182: LD_ADDR_EXP 66
7186: PUSH
7187: LD_STRING Bystrov
7189: PPUSH
7190: CALL_OW 25
7194: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7195: LD_ADDR_EXP 68
7199: PUSH
7200: LD_STRING Gleb
7202: PPUSH
7203: CALL_OW 25
7207: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7208: LD_STRING 03_Cornel
7210: PPUSH
7211: CALL_OW 28
7215: IFFALSE 7263
// begin Bierezov := NewCharacter ( Mikhail ) ;
7217: LD_ADDR_EXP 69
7221: PUSH
7222: LD_STRING Mikhail
7224: PPUSH
7225: CALL_OW 25
7229: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7230: LD_EXP 69
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7251: LD_EXP 69
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7263: LD_EXP 64
7267: PPUSH
7268: LD_INT 126
7270: PPUSH
7271: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7275: LD_EXP 65
7279: PPUSH
7280: LD_INT 134
7282: PPUSH
7283: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7287: LD_EXP 67
7291: PPUSH
7292: LD_INT 197
7294: PPUSH
7295: LD_INT 111
7297: PPUSH
7298: LD_INT 9
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7308: LD_EXP 66
7312: PPUSH
7313: LD_INT 197
7315: PPUSH
7316: LD_INT 111
7318: PPUSH
7319: LD_INT 9
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7329: LD_EXP 68
7333: PPUSH
7334: LD_INT 197
7336: PPUSH
7337: LD_INT 111
7339: PPUSH
7340: LD_INT 9
7342: PPUSH
7343: LD_INT 0
7345: PPUSH
7346: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_INT 126
7357: PPUSH
7358: LD_INT 4
7360: PPUSH
7361: LD_STRING zhukov
7363: PPUSH
7364: LD_INT 9
7366: PUSH
7367: LD_INT 10
7369: PUSH
7370: LD_INT 10
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 73444 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 113
7483: PUSH
7484: LD_EXP 113
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 101200 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 101200 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 101261 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 101261 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8306
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_OWVAR 67
8197: ARRAY
8198: PUSH
8199: FOR_TO
8200: IFFALSE 8302
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8202: LD_INT 22
8204: PUSH
8205: LD_INT 24
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: LD_VAR 0 3
8216: PUSH
8217: LD_INT 2
8219: MOD
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ARRAY
8225: PPUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 3
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 1
8238: PPUSH
8239: LD_INT 2
8241: PPUSH
8242: CALL_OW 12
8246: ARRAY
8247: PPUSH
8248: LD_INT 3
8250: PPUSH
8251: LD_INT 43
8253: PUSH
8254: LD_INT 44
8256: PUSH
8257: LD_INT 45
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 12
8275: ARRAY
8276: PPUSH
8277: LD_INT 80
8279: PPUSH
8280: CALL 70035 0 5
// result := result union CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_VAR 0 2
8293: PUSH
8294: CALL_OW 45
8298: UNION
8299: ST_TO_ADDR
// end ;
8300: GO 8199
8302: POP
8303: POP
// end ; 2 :
8304: GO 9257
8306: LD_INT 2
8308: DOUBLE
8309: EQUAL
8310: IFTRUE 8314
8312: GO 8470
8314: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: DOUBLE
8321: LD_INT 1
8323: DEC
8324: ST_TO_ADDR
8325: LD_INT 5
8327: PUSH
8328: LD_INT 6
8330: PUSH
8331: LD_INT 7
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_OWVAR 67
8343: ARRAY
8344: PUSH
8345: FOR_TO
8346: IFFALSE 8466
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 24
8353: PUSH
8354: LD_INT 24
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: PUSH
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 3
8369: MOD
8370: PUSH
8371: LD_INT 1
8373: PLUS
8374: ARRAY
8375: PPUSH
8376: LD_INT 1
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: LD_INT 1
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 12
8396: ARRAY
8397: PPUSH
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 43
8403: PUSH
8404: LD_INT 44
8406: PUSH
8407: LD_INT 45
8409: PUSH
8410: LD_INT 44
8412: PUSH
8413: LD_INT 46
8415: PUSH
8416: LD_INT 46
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: LD_INT 6
8434: MOD
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ARRAY
8440: PPUSH
8441: LD_INT 80
8443: PPUSH
8444: CALL 70035 0 5
// result := result union CreateVehicle ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_VAR 0 2
8457: PUSH
8458: CALL_OW 45
8462: UNION
8463: ST_TO_ADDR
// end ;
8464: GO 8345
8466: POP
8467: POP
// end ; 3 :
8468: GO 9257
8470: LD_INT 3
8472: DOUBLE
8473: EQUAL
8474: IFTRUE 8478
8476: GO 8634
8478: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: DOUBLE
8485: LD_INT 1
8487: DEC
8488: ST_TO_ADDR
8489: LD_INT 5
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 8
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_OWVAR 67
8507: ARRAY
8508: PUSH
8509: FOR_TO
8510: IFFALSE 8630
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8512: LD_INT 22
8514: PUSH
8515: LD_INT 24
8517: PUSH
8518: LD_INT 24
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 3
8530: PUSH
8531: LD_INT 3
8533: MOD
8534: PUSH
8535: LD_INT 1
8537: PLUS
8538: ARRAY
8539: PPUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 12
8560: ARRAY
8561: PPUSH
8562: LD_INT 3
8564: PPUSH
8565: LD_INT 43
8567: PUSH
8568: LD_INT 47
8570: PUSH
8571: LD_INT 45
8573: PUSH
8574: LD_INT 45
8576: PUSH
8577: LD_INT 46
8579: PUSH
8580: LD_INT 46
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 6
8598: MOD
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 80
8607: PPUSH
8608: CALL 70035 0 5
// result := result union CreateVehicle ;
8612: LD_ADDR_VAR 0 2
8616: PUSH
8617: LD_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: UNION
8627: ST_TO_ADDR
// end ;
8628: GO 8509
8630: POP
8631: POP
// end ; 4 :
8632: GO 9257
8634: LD_INT 4
8636: DOUBLE
8637: EQUAL
8638: IFTRUE 8642
8640: GO 9256
8642: POP
// begin uc_nation := 3 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 3
8650: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8651: LD_ADDR_VAR 0 3
8655: PUSH
8656: DOUBLE
8657: LD_INT 1
8659: DEC
8660: ST_TO_ADDR
8661: LD_INT 6
8663: PUSH
8664: LD_INT 8
8666: PUSH
8667: LD_INT 9
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PUSH
8675: LD_OWVAR 67
8679: ARRAY
8680: PUSH
8681: FOR_TO
8682: IFFALSE 8802
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8684: LD_INT 22
8686: PUSH
8687: LD_INT 24
8689: PUSH
8690: LD_INT 24
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_VAR 0 3
8702: PUSH
8703: LD_INT 3
8705: MOD
8706: PUSH
8707: LD_INT 1
8709: PLUS
8710: ARRAY
8711: PPUSH
8712: LD_INT 1
8714: PUSH
8715: LD_INT 3
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 45
8739: PUSH
8740: LD_INT 47
8742: PUSH
8743: LD_INT 47
8745: PUSH
8746: LD_INT 45
8748: PUSH
8749: LD_INT 46
8751: PUSH
8752: LD_INT 46
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_VAR 0 3
8767: PUSH
8768: LD_INT 6
8770: MOD
8771: PUSH
8772: LD_INT 1
8774: PLUS
8775: ARRAY
8776: PPUSH
8777: LD_INT 80
8779: PPUSH
8780: CALL 70035 0 5
// result := result union CreateVehicle ;
8784: LD_ADDR_VAR 0 2
8788: PUSH
8789: LD_VAR 0 2
8793: PUSH
8794: CALL_OW 45
8798: UNION
8799: ST_TO_ADDR
// end ;
8800: GO 8681
8802: POP
8803: POP
// if not KappaStatus then
8804: LD_EXP 2
8808: NOT
8809: IFFALSE 9044
// begin uc_nation := 1 ;
8811: LD_ADDR_OWVAR 21
8815: PUSH
8816: LD_INT 1
8818: ST_TO_ADDR
// for i = 1 to 3 do
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: DOUBLE
8825: LD_INT 1
8827: DEC
8828: ST_TO_ADDR
8829: LD_INT 3
8831: PUSH
8832: FOR_TO
8833: IFFALSE 8969
// begin j := rand ( 0 , 1 ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 0
8842: PPUSH
8843: LD_INT 1
8845: PPUSH
8846: CALL_OW 12
8850: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8851: LD_INT 3
8853: PUSH
8854: LD_INT 5
8856: PUSH
8857: LD_INT 5
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 3
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 1
8889: PUSH
8890: LD_INT 3
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 1
8899: PPUSH
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 12
8907: ARRAY
8908: PPUSH
8909: LD_INT 3
8911: PPUSH
8912: LD_INT 9
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: PPUSH
8934: LD_INT 2
8936: PPUSH
8937: CALL_OW 12
8941: PLUS
8942: ARRAY
8943: PPUSH
8944: LD_INT 85
8946: PPUSH
8947: CALL 70035 0 5
// result := result union CreateVehicle ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 2
8960: PUSH
8961: CALL_OW 45
8965: UNION
8966: ST_TO_ADDR
// end ;
8967: GO 8832
8969: POP
8970: POP
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8985: LD_INT 5
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 6
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 70035 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 71
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 71
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 71
9040: UNION
9041: ST_TO_ADDR
// end ; end else
9042: GO 9254
// if vsevolodFirstAttack then
9044: LD_EXP 24
9048: IFFALSE 9254
// begin vsevolodFirstAttack := false ;
9050: LD_ADDR_EXP 24
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// uc_nation := 3 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 2
9078: PUSH
9079: LD_OWVAR 67
9083: PLUS
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9194
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 24
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_VAR 0 3
9106: PUSH
9107: LD_INT 3
9109: MOD
9110: PUSH
9111: LD_INT 1
9113: PLUS
9114: ARRAY
9115: PPUSH
9116: LD_INT 1
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 1
9128: PPUSH
9129: LD_INT 2
9131: PPUSH
9132: CALL_OW 12
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PPUSH
9141: LD_INT 45
9143: PUSH
9144: LD_INT 47
9146: PUSH
9147: LD_INT 47
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_VAR 0 3
9159: PUSH
9160: LD_INT 3
9162: MOD
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: PPUSH
9169: LD_INT 80
9171: PPUSH
9172: CALL 70035 0 5
// result := result union CreateVehicle ;
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 2
9185: PUSH
9186: CALL_OW 45
9190: UNION
9191: ST_TO_ADDR
// end ;
9192: GO 9085
9194: POP
9195: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9196: LD_INT 24
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 47
9207: PPUSH
9208: LD_INT 100
9210: PPUSH
9211: CALL 70035 0 5
// sewiVeh := CreateVehicle ;
9215: LD_ADDR_EXP 71
9219: PUSH
9220: CALL_OW 45
9224: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9225: LD_EXP 71
9229: PPUSH
9230: LD_INT 6
9232: NEG
9233: PPUSH
9234: CALL_OW 242
// result := result union sewiVeh ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_EXP 71
9252: UNION
9253: ST_TO_ADDR
// end ; end ; end ;
9254: GO 9257
9256: POP
// end ;
9257: LD_VAR 0 2
9261: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9262: LD_EXP 16
9266: IFFALSE 10107
9268: GO 9270
9270: DISABLE
9271: LD_INT 0
9273: PPUSH
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
9278: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9279: LD_ADDR_VAR 0 4
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9294: LD_ADDR_VAR 0 3
9298: PUSH
9299: LD_INT 11550
9301: PUSH
9302: LD_INT 10150
9304: PUSH
9305: LD_INT 9800
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_OWVAR 67
9317: ARRAY
9318: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9319: LD_ADDR_VAR 0 6
9323: PUSH
9324: LD_INT 70
9326: PUSH
9327: LD_INT 118
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 78
9336: PUSH
9337: LD_INT 31
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: ST_TO_ADDR
// repeat if missionStage = 2 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9367
// wait ( 1 1$30 ) else
9358: LD_INT 3150
9360: PPUSH
9361: CALL_OW 67
9365: GO 9376
// wait ( time ) ;
9367: LD_VAR 0 3
9371: PPUSH
9372: CALL_OW 67
// if missionStage = 6 then
9376: LD_EXP 15
9380: PUSH
9381: LD_INT 6
9383: EQUAL
9384: IFFALSE 9412
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9386: LD_INT 51
9388: PPUSH
9389: LD_INT 6
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9399: LD_INT 57
9401: PPUSH
9402: LD_INT 6
9404: PPUSH
9405: LD_INT 2
9407: PPUSH
9408: CALL_OW 322
// end ; if missionStage = 8 then
9412: LD_EXP 15
9416: PUSH
9417: LD_INT 8
9419: EQUAL
9420: IFFALSE 9448
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9422: LD_INT 52
9424: PPUSH
9425: LD_INT 6
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9435: LD_INT 58
9437: PPUSH
9438: LD_INT 6
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9448: LD_EXP 15
9452: PUSH
9453: LD_INT 10
9455: EQUAL
9456: PUSH
9457: LD_OWVAR 67
9461: PUSH
9462: LD_INT 1
9464: GREATER
9465: AND
9466: IFFALSE 9494
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9468: LD_INT 53
9470: PPUSH
9471: LD_INT 6
9473: PPUSH
9474: LD_INT 2
9476: PPUSH
9477: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9481: LD_INT 59
9483: PPUSH
9484: LD_INT 6
9486: PPUSH
9487: LD_INT 2
9489: PPUSH
9490: CALL_OW 322
// end ; if activeAttacks then
9494: LD_EXP 16
9498: IFFALSE 10101
// begin if missionStage = 2 then
9500: LD_EXP 15
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9518
// strength := 1 ;
9510: LD_ADDR_VAR 0 5
9514: PUSH
9515: LD_INT 1
9517: ST_TO_ADDR
// if missionStage > 2 then
9518: LD_EXP 15
9522: PUSH
9523: LD_INT 2
9525: GREATER
9526: IFFALSE 9536
// strength := 2 ;
9528: LD_ADDR_VAR 0 5
9532: PUSH
9533: LD_INT 2
9535: ST_TO_ADDR
// if missionStage > 6 then
9536: LD_EXP 15
9540: PUSH
9541: LD_INT 6
9543: GREATER
9544: IFFALSE 9554
// strength := 3 ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 3
9553: ST_TO_ADDR
// if missionStage > 10 then
9554: LD_EXP 15
9558: PUSH
9559: LD_INT 10
9561: GREATER
9562: IFFALSE 9572
// strength := 4 ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_INT 4
9571: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_VAR 0 5
9581: PPUSH
9582: CALL 8127 0 1
9586: ST_TO_ADDR
// for i in tmp do
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_VAR 0 2
9596: PUSH
9597: FOR_IN
9598: IFFALSE 9781
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 4
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 2
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 49
// if i = sewiVeh then
9629: LD_VAR 0 1
9633: PUSH
9634: LD_EXP 71
9638: EQUAL
9639: IFFALSE 9676
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9641: LD_ADDR_EXP 70
9645: PUSH
9646: LD_STRING Vsevolod
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: LD_STRING 
9654: PPUSH
9655: CALL 65211 0 3
9659: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9660: LD_EXP 70
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 52
// end else
9674: GO 9757
// if GetControl ( i ) = control_manual then
9676: LD_VAR 0 1
9680: PPUSH
9681: CALL_OW 263
9685: PUSH
9686: LD_INT 1
9688: EQUAL
9689: IFFALSE 9757
// begin uc_side := 6 ;
9691: LD_ADDR_OWVAR 20
9695: PUSH
9696: LD_INT 6
9698: ST_TO_ADDR
// uc_nation := 3 ;
9699: LD_ADDR_OWVAR 21
9703: PUSH
9704: LD_INT 3
9706: ST_TO_ADDR
// hc_gallery :=  ;
9707: LD_ADDR_OWVAR 33
9711: PUSH
9712: LD_STRING 
9714: ST_TO_ADDR
// hc_name :=  ;
9715: LD_ADDR_OWVAR 26
9719: PUSH
9720: LD_STRING 
9722: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9723: LD_INT 0
9725: PPUSH
9726: LD_INT 3
9728: PPUSH
9729: LD_INT 10
9731: PPUSH
9732: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9736: CALL_OW 44
9740: PPUSH
9741: LD_VAR 0 1
9745: PPUSH
9746: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9750: LD_INT 10
9752: PPUSH
9753: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9757: LD_VAR 0 1
9761: PPUSH
9762: LD_INT 111
9764: PPUSH
9765: LD_INT 197
9767: PPUSH
9768: CALL_OW 111
// wait ( 0 0$2 ) ;
9772: LD_INT 70
9774: PPUSH
9775: CALL_OW 67
// end ;
9779: GO 9597
9781: POP
9782: POP
// repeat wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// for i in tmp do
9790: LD_ADDR_VAR 0 1
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: FOR_IN
9801: IFFALSE 10082
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9803: LD_INT 81
9805: PUSH
9806: LD_INT 6
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 91
9815: PUSH
9816: LD_VAR 0 1
9820: PUSH
9821: LD_INT 12
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 69
9837: IFFALSE 9895
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 81
9846: PUSH
9847: LD_INT 6
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 91
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 12
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
9893: GO 10080
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9895: LD_INT 9
9897: PPUSH
9898: LD_INT 81
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 70
9912: IFFALSE 10046
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_VAR 0 6
9923: PUSH
9924: LD_INT 1
9926: ARRAY
9927: PUSH
9928: LD_INT 1
9930: ARRAY
9931: PPUSH
9932: LD_VAR 0 6
9936: PUSH
9937: LD_INT 1
9939: ARRAY
9940: PUSH
9941: LD_INT 2
9943: ARRAY
9944: PPUSH
9945: CALL_OW 297
9949: PUSH
9950: LD_INT 10
9952: GREATER
9953: PUSH
9954: LD_VAR 0 1
9958: PPUSH
9959: LD_INT 9
9961: PPUSH
9962: CALL_OW 308
9966: NOT
9967: AND
9968: IFFALSE 10007
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9970: LD_VAR 0 1
9974: PPUSH
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 1
9982: ARRAY
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PPUSH
9988: LD_VAR 0 6
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PUSH
9997: LD_INT 2
9999: ARRAY
10000: PPUSH
10001: CALL_OW 114
10005: GO 10044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: LD_INT 9
10014: PPUSH
10015: LD_INT 81
10017: PUSH
10018: LD_INT 6
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 70
10029: PPUSH
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 74
10039: PPUSH
10040: CALL_OW 115
// end else
10044: GO 10080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_INT 81
10053: PUSH
10054: LD_INT 6
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PPUSH
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 74
10075: PPUSH
10076: CALL_OW 115
// end ;
10080: GO 9800
10082: POP
10083: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 6
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: NOT
10099: IFFALSE 9783
// end ; until russianDestroyed ;
10101: LD_EXP 21
10105: IFFALSE 9348
// end ;
10107: PPOPN 6
10109: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10110: LD_EXP 21
10114: NOT
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: LD_INT 6
10123: GREATEREQUAL
10124: AND
10125: PUSH
10126: LD_INT 2
10128: PPUSH
10129: LD_INT 1
10131: PPUSH
10132: CALL 60266 0 2
10136: NOT
10137: AND
10138: IFFALSE 11094
10140: GO 10142
10142: DISABLE
10143: LD_INT 0
10145: PPUSH
10146: PPUSH
10147: PPUSH
10148: PPUSH
// begin enable ;
10149: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10150: LD_INT 22
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 30
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: NOT
10179: IFFALSE 10183
// exit ;
10181: GO 11094
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10183: LD_ADDR_VAR 0 4
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 30
10200: PUSH
10201: LD_INT 34
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PPUSH
10212: CALL_OW 69
10216: ST_TO_ADDR
// if Prob ( 40 ) then
10217: LD_INT 40
10219: PPUSH
10220: CALL_OW 13
10224: IFFALSE 10351
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10226: LD_INT 2
10228: PPUSH
10229: LD_INT 22
10231: PUSH
10232: LD_INT 3
10234: PUSH
10235: LD_INT 3
10237: PUSH
10238: LD_INT 49
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 3
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: LD_INT 49
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: LD_INT 3
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 24
10285: PUSH
10286: LD_INT 3
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 46
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 24
10303: PUSH
10304: LD_INT 3
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 46
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PUSH
10319: LD_INT 24
10321: PUSH
10322: LD_INT 3
10324: PUSH
10325: LD_INT 3
10327: PUSH
10328: LD_INT 46
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL 58848 0 2
// end else
10349: GO 10474
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10351: LD_INT 2
10353: PPUSH
10354: LD_INT 24
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 3
10362: PUSH
10363: LD_INT 47
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 46
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL 58848 0 2
// end ; if Difficulty > 1 then
10474: LD_OWVAR 67
10478: PUSH
10479: LD_INT 1
10481: GREATER
10482: IFFALSE 10512
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10484: LD_INT 2
10486: PPUSH
10487: LD_INT 24
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 3
10495: PUSH
10496: LD_INT 47
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: PUSH
10505: EMPTY
10506: LIST
10507: PPUSH
10508: CALL 58848 0 2
// repeat wait ( 0 0$1 ) ;
10512: LD_INT 35
10514: PPUSH
10515: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10519: LD_INT 2
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL 60266 0 2
10529: PUSH
10530: LD_INT 6
10532: PUSH
10533: LD_INT 7
10535: PUSH
10536: LD_INT 7
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: LIST
10543: PUSH
10544: LD_OWVAR 67
10548: ARRAY
10549: GREATEREQUAL
10550: IFFALSE 10512
// wait ( 0 0$30 ) ;
10552: LD_INT 1050
10554: PPUSH
10555: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10559: LD_ADDR_VAR 0 2
10563: PUSH
10564: LD_INT 2
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 60266 0 2
10574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10575: LD_ADDR_EXP 132
10579: PUSH
10580: LD_EXP 132
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: LD_EXP 132
10592: PUSH
10593: LD_INT 2
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 2
10601: DIFF
10602: PPUSH
10603: CALL_OW 1
10607: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10608: LD_ADDR_VAR 0 3
10612: PUSH
10613: LD_INT 0
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: CALL_OW 12
10623: ST_TO_ADDR
// if target then
10624: LD_VAR 0 3
10628: IFFALSE 10756
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 250
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 72
10654: ST_TO_ADDR
// for i in tmp do
10655: LD_ADDR_VAR 0 1
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: FOR_IN
10666: IFFALSE 10706
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10668: LD_VAR 0 1
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: LD_INT 89
10678: PPUSH
10679: CALL_OW 297
10683: PUSH
10684: LD_INT 9
10686: GREATER
10687: IFFALSE 10704
// ComMoveXY ( i , 139 , 89 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: LD_INT 89
10699: PPUSH
10700: CALL_OW 111
10704: GO 10665
10706: POP
10707: POP
// wait ( 0 0$1 ) ;
10708: LD_INT 35
10710: PPUSH
10711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10715: LD_VAR 0 2
10719: PPUSH
10720: LD_INT 92
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 89
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: LD_INT 1
10750: MINUS
10751: GREATEREQUAL
10752: IFFALSE 10630
// end else
10754: GO 10898
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10756: LD_VAR 0 2
10760: PPUSH
10761: LD_VAR 0 4
10765: PUSH
10766: LD_INT 1
10768: ARRAY
10769: PPUSH
10770: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 24
10786: PUSH
10787: LD_INT 250
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 72
10798: ST_TO_ADDR
// for i in tmp do
10799: LD_ADDR_VAR 0 1
10803: PUSH
10804: LD_VAR 0 2
10808: PUSH
10809: FOR_IN
10810: IFFALSE 10850
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_INT 124
10819: PPUSH
10820: LD_INT 139
10822: PPUSH
10823: CALL_OW 297
10827: PUSH
10828: LD_INT 9
10830: GREATER
10831: IFFALSE 10848
// ComMoveXY ( i , 124 , 139 ) ;
10833: LD_VAR 0 1
10837: PPUSH
10838: LD_INT 124
10840: PPUSH
10841: LD_INT 139
10843: PPUSH
10844: CALL_OW 111
10848: GO 10809
10850: POP
10851: POP
// wait ( 0 0$1 ) ;
10852: LD_INT 35
10854: PPUSH
10855: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10859: LD_VAR 0 2
10863: PPUSH
10864: LD_INT 92
10866: PUSH
10867: LD_INT 124
10869: PUSH
10870: LD_INT 139
10872: PUSH
10873: LD_INT 9
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_INT 1
10894: MINUS
10895: GREATEREQUAL
10896: IFFALSE 10774
// end ; repeat wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// for i in tmp do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_VAR 0 2
10914: PUSH
10915: FOR_IN
10916: IFFALSE 11085
// begin if GetLives ( i ) > 251 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 256
10927: PUSH
10928: LD_INT 251
10930: GREATER
10931: IFFALSE 11056
// begin if GetWeapon ( i ) = ru_time_lapser then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 49
10945: EQUAL
10946: IFFALSE 11002
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 2
10955: PUSH
10956: LD_INT 22
10958: PUSH
10959: LD_INT 1
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_INT 8
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 112
11000: GO 11054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 2
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 8
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PPUSH
11040: LD_VAR 0 1
11044: PPUSH
11045: CALL_OW 74
11049: PPUSH
11050: CALL_OW 115
// end else
11054: GO 11083
// if IsDead ( i ) then
11056: LD_VAR 0 1
11060: PPUSH
11061: CALL_OW 301
11065: IFFALSE 11083
// tmp := tmp diff i ;
11067: LD_ADDR_VAR 0 2
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_VAR 0 1
11081: DIFF
11082: ST_TO_ADDR
// end ;
11083: GO 10915
11085: POP
11086: POP
// until not tmp ;
11087: LD_VAR 0 2
11091: NOT
11092: IFFALSE 10898
// end ; end_of_file
11094: PPOPN 4
11096: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11097: LD_INT 0
11099: PPUSH
11100: PPUSH
11101: PPUSH
11102: PPUSH
11103: PPUSH
11104: PPUSH
// side := 7 ;
11105: LD_ADDR_VAR 0 5
11109: PUSH
11110: LD_INT 7
11112: ST_TO_ADDR
// uc_side := side ;
11113: LD_ADDR_OWVAR 20
11117: PUSH
11118: LD_VAR 0 5
11122: ST_TO_ADDR
// uc_nation := 1 ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 1
11130: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: EMPTY
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL_OW 69
11166: PUSH
11167: FOR_IN
11168: IFFALSE 11184
// SetBLevel ( i , 10 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_INT 10
11177: PPUSH
11178: CALL_OW 241
11182: GO 11167
11184: POP
11185: POP
// base := GetBase ( al_depot ) ;
11186: LD_ADDR_VAR 0 4
11190: PUSH
11191: LD_INT 2
11193: PPUSH
11194: CALL_OW 274
11198: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11199: LD_ADDR_VAR 0 6
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: LD_INT 30
11218: PUSH
11219: LD_INT 34
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if teleport then
11235: LD_VAR 0 6
11239: IFFALSE 11260
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11241: LD_VAR 0 6
11245: PUSH
11246: LD_INT 1
11248: ARRAY
11249: PPUSH
11250: LD_INT 262
11252: PPUSH
11253: LD_INT 119
11255: PPUSH
11256: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11260: LD_VAR 0 4
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 19500
11270: PPUSH
11271: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11275: LD_VAR 0 4
11279: PPUSH
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 200
11285: PPUSH
11286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11290: LD_VAR 0 4
11294: PPUSH
11295: LD_INT 3
11297: PPUSH
11298: LD_INT 650
11300: PPUSH
11301: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11305: LD_ADDR_EXP 74
11309: PUSH
11310: LD_STRING Roth
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11318: LD_ADDR_EXP 75
11322: PUSH
11323: LD_STRING Simms
11325: PPUSH
11326: LD_EXP 1
11330: NOT
11331: PPUSH
11332: LD_STRING 10c_
11334: PPUSH
11335: CALL 65211 0 3
11339: ST_TO_ADDR
// if not Simms then
11340: LD_EXP 75
11344: NOT
11345: IFFALSE 11375
// begin uc_nation := 1 ;
11347: LD_ADDR_OWVAR 21
11351: PUSH
11352: LD_INT 1
11354: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11355: LD_INT 2
11357: PPUSH
11358: LD_INT 10
11360: PPUSH
11361: CALL_OW 384
// Simms := CreateHuman ;
11365: LD_ADDR_EXP 75
11369: PUSH
11370: CALL_OW 44
11374: ST_TO_ADDR
// end ; uc_nation := 3 ;
11375: LD_ADDR_OWVAR 21
11379: PUSH
11380: LD_INT 3
11382: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11383: LD_ADDR_EXP 76
11387: PUSH
11388: LD_STRING Kirilenkova
11390: PPUSH
11391: CALL_OW 25
11395: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11396: LD_ADDR_EXP 90
11400: PUSH
11401: LD_STRING Oblukov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11409: LD_ADDR_EXP 77
11413: PUSH
11414: LD_STRING Dolgov
11416: PPUSH
11417: CALL_OW 25
11421: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11422: LD_ADDR_EXP 78
11426: PUSH
11427: LD_STRING Petrosyan
11429: PPUSH
11430: CALL_OW 25
11434: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11435: LD_ADDR_EXP 89
11439: PUSH
11440: LD_STRING Scholtze
11442: PPUSH
11443: CALL_OW 25
11447: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11448: LD_ADDR_EXP 88
11452: PUSH
11453: LD_STRING Kapitsova
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11461: LD_ADDR_EXP 79
11465: PUSH
11466: LD_STRING Petrovova
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11474: LD_ADDR_EXP 80
11478: PUSH
11479: LD_STRING Kuzmov
11481: PPUSH
11482: CALL_OW 25
11486: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11487: LD_ADDR_EXP 87
11491: PUSH
11492: LD_STRING Karamazov
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11500: LD_STRING 13_Lipshchin_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Lipshchin := NewCharacter ( Lipshchin ) ;
11512: LD_ADDR_EXP 81
11516: PUSH
11517: LD_STRING Lipshchin
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11525: LD_STRING 13_Titov_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Titov := NewCharacter ( Titov ) ;
11537: LD_ADDR_EXP 83
11541: PUSH
11542: LD_STRING Titov
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11550: LD_STRING 13_Gnyevko_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Gnyevko := NewCharacter ( Gnyevko ) ;
11562: LD_ADDR_EXP 82
11566: PUSH
11567: LD_STRING Gnyevko
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11575: LD_STRING 13_Xavier_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Xavier := NewCharacter ( Xavier2 ) ;
11587: LD_ADDR_EXP 84
11591: PUSH
11592: LD_STRING Xavier2
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11600: LD_STRING 13_Belkov_1
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 30
11610: IFFALSE 11625
// Belkov := NewCharacter ( Belkov ) ;
11612: LD_ADDR_EXP 85
11616: PUSH
11617: LD_STRING Belkov
11619: PPUSH
11620: CALL_OW 25
11624: ST_TO_ADDR
// if not BurlakStatus then
11625: LD_EXP 9
11629: NOT
11630: IFFALSE 11645
// Burlak = NewCharacter ( Burlak ) ;
11632: LD_ADDR_EXP 86
11636: PUSH
11637: LD_STRING Burlak
11639: PPUSH
11640: CALL_OW 25
11644: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_EXP 74
11654: PUSH
11655: LD_EXP 76
11659: PUSH
11660: LD_EXP 90
11664: PUSH
11665: LD_EXP 77
11669: PUSH
11670: LD_EXP 78
11674: PUSH
11675: LD_EXP 89
11679: PUSH
11680: LD_EXP 88
11684: PUSH
11685: LD_EXP 79
11689: PUSH
11690: LD_EXP 80
11694: PUSH
11695: LD_EXP 87
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: ST_TO_ADDR
// if Simms then
11712: LD_EXP 75
11716: IFFALSE 11734
// tmp := tmp ^ Simms ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_EXP 75
11732: ADD
11733: ST_TO_ADDR
// if Titov then
11734: LD_EXP 83
11738: IFFALSE 11756
// tmp := tmp ^ Titov ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_EXP 83
11754: ADD
11755: ST_TO_ADDR
// if Lipshchin then
11756: LD_EXP 81
11760: IFFALSE 11778
// tmp := tmp ^ Lipshchin ;
11762: LD_ADDR_VAR 0 3
11766: PUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_EXP 81
11776: ADD
11777: ST_TO_ADDR
// if Gnyevko then
11778: LD_EXP 82
11782: IFFALSE 11800
// tmp := tmp ^ Gnyevko ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 82
11798: ADD
11799: ST_TO_ADDR
// if Xavier then
11800: LD_EXP 84
11804: IFFALSE 11822
// tmp := tmp ^ Xavier ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 84
11820: ADD
11821: ST_TO_ADDR
// if Belkov then
11822: LD_EXP 85
11826: IFFALSE 11844
// tmp := tmp ^ Belkov ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 85
11842: ADD
11843: ST_TO_ADDR
// if Burlak then
11844: LD_EXP 86
11848: IFFALSE 11866
// tmp := tmp ^ Burlak ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 86
11864: ADD
11865: ST_TO_ADDR
// for i = 1 to 11 do
11866: LD_ADDR_VAR 0 2
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 11
11878: PUSH
11879: FOR_TO
11880: IFFALSE 11946
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11882: LD_ADDR_OWVAR 21
11886: PUSH
11887: LD_INT 1
11889: PUSH
11890: LD_INT 3
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: CALL_OW 12
11907: ARRAY
11908: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11909: LD_INT 0
11911: PPUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 2
11919: DIV
11920: PPUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11928: LD_ADDR_VAR 0 3
11932: PUSH
11933: LD_VAR 0 3
11937: PUSH
11938: CALL_OW 44
11942: ADD
11943: ST_TO_ADDR
// end ;
11944: GO 11879
11946: POP
11947: POP
// for i in tmp do
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 3
11957: PUSH
11958: FOR_IN
11959: IFFALSE 11984
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11961: LD_VAR 0 2
11965: PPUSH
11966: LD_INT 260
11968: PPUSH
11969: LD_INT 235
11971: PPUSH
11972: LD_INT 8
11974: PPUSH
11975: LD_INT 0
11977: PPUSH
11978: CALL_OW 50
11982: GO 11958
11984: POP
11985: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11986: LD_ADDR_EXP 113
11990: PUSH
11991: LD_EXP 113
11995: PPUSH
11996: LD_INT 1
11998: PPUSH
11999: LD_INT 22
12001: PUSH
12002: LD_VAR 0 5
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 69
12036: PUSH
12037: LD_EXP 74
12041: PUSH
12042: LD_EXP 75
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: DIFF
12051: PPUSH
12052: CALL_OW 1
12056: ST_TO_ADDR
// uc_side := 0 ;
12057: LD_ADDR_OWVAR 20
12061: PUSH
12062: LD_INT 0
12064: ST_TO_ADDR
// uc_nation := 0 ;
12065: LD_ADDR_OWVAR 21
12069: PUSH
12070: LD_INT 0
12072: ST_TO_ADDR
// for i = 1 to 5 do
12073: LD_ADDR_VAR 0 2
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_INT 5
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12124
// begin InitHc ;
12089: CALL_OW 19
// hc_class := class_apeman ;
12093: LD_ADDR_OWVAR 28
12097: PUSH
12098: LD_INT 12
12100: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12101: CALL_OW 44
12105: PPUSH
12106: LD_INT 299
12108: PPUSH
12109: LD_INT 229
12111: PPUSH
12112: LD_INT 10
12114: PPUSH
12115: LD_INT 0
12117: PPUSH
12118: CALL_OW 50
// end ;
12122: GO 12086
12124: POP
12125: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12126: LD_EXP 74
12130: PPUSH
12131: LD_INT 259
12133: PPUSH
12134: LD_INT 235
12136: PPUSH
12137: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12141: LD_EXP 74
12145: PPUSH
12146: LD_INT 262
12148: PPUSH
12149: LD_INT 235
12151: PPUSH
12152: CALL_OW 178
// if Simms then
12156: LD_EXP 75
12160: IFFALSE 12191
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12162: LD_EXP 75
12166: PPUSH
12167: LD_INT 262
12169: PPUSH
12170: LD_INT 235
12172: PPUSH
12173: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12177: LD_EXP 75
12181: PPUSH
12182: LD_EXP 74
12186: PPUSH
12187: CALL_OW 179
// end ; end ;
12191: LD_VAR 0 1
12195: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12196: LD_EXP 31
12200: PUSH
12201: LD_EXP 23
12205: NOT
12206: AND
12207: IFFALSE 12383
12209: GO 12211
12211: DISABLE
12212: LD_INT 0
12214: PPUSH
12215: PPUSH
12216: PPUSH
// begin enable ;
12217: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12218: LD_ADDR_VAR 0 2
12222: PUSH
12223: LD_INT 81
12225: PUSH
12226: LD_INT 7
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 3
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 30
12248: PUSH
12249: LD_INT 30
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 30
12258: PUSH
12259: LD_INT 28
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 34
12268: PUSH
12269: LD_INT 49
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 34
12278: PUSH
12279: LD_INT 10
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 34
12288: PUSH
12289: LD_INT 8
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL_OW 69
12313: ST_TO_ADDR
// if not tmp then
12314: LD_VAR 0 2
12318: NOT
12319: IFFALSE 12323
// exit ;
12321: GO 12383
// target := tmp [ rand ( 1 , tmp ) ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 2
12332: PUSH
12333: LD_INT 1
12335: PPUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: CALL_OW 12
12345: ARRAY
12346: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12347: LD_VAR 0 3
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 1
12359: EQUAL
12360: IFFALSE 12371
// CenterNowOnUnits ( target ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 87
// SetLives ( target , 0 ) ;
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 234
// end ;
12383: PPOPN 3
12385: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12386: LD_EXP 23
12390: NOT
12391: PUSH
12392: LD_EXP 31
12396: AND
12397: IFFALSE 12919
12399: GO 12401
12401: DISABLE
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// begin uc_side := 7 ;
12407: LD_ADDR_OWVAR 20
12411: PUSH
12412: LD_INT 7
12414: ST_TO_ADDR
// uc_nation := 1 ;
12415: LD_ADDR_OWVAR 21
12419: PUSH
12420: LD_INT 1
12422: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 125
12430: PUSH
12431: LD_INT 163
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 185
12440: PUSH
12441: LD_INT 168
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 111
12450: PUSH
12451: LD_INT 97
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL 101305 0 1
12467: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to Difficulty do
12475: LD_ADDR_VAR 0 1
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_OWVAR 67
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12649
// begin InitHc ;
12493: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 8
12502: PPUSH
12503: CALL_OW 381
// un := CreateHuman ;
12507: LD_ADDR_VAR 0 2
12511: PUSH
12512: CALL_OW 44
12516: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: LD_INT 258
12524: PPUSH
12525: LD_INT 267
12527: PPUSH
12528: LD_INT 4
12530: PPUSH
12531: LD_INT 0
12533: PPUSH
12534: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12538: LD_ADDR_EXP 91
12542: PUSH
12543: LD_EXP 91
12547: PUSH
12548: LD_VAR 0 2
12552: UNION
12553: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12554: LD_VAR 0 2
12558: PPUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: ARRAY
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 3
12578: PUSH
12579: LD_VAR 0 1
12583: ARRAY
12584: PUSH
12585: LD_INT 2
12587: ARRAY
12588: PPUSH
12589: LD_INT 4
12591: PPUSH
12592: LD_INT 1
12594: PPUSH
12595: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: LD_VAR 0 3
12608: PUSH
12609: LD_VAR 0 1
12613: ARRAY
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: PPUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_VAR 0 1
12628: ARRAY
12629: PUSH
12630: LD_INT 2
12632: ARRAY
12633: PPUSH
12634: CALL_OW 171
// AddComInvisible ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL_OW 212
// end ;
12647: GO 12490
12649: POP
12650: POP
// repeat wait ( 0 0$20 ) ;
12651: LD_INT 700
12653: PPUSH
12654: CALL_OW 67
// for i in allianceSpecialForce do
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_EXP 91
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12904
// begin if IsInvisible ( i ) then
12671: LD_VAR 0 1
12675: PPUSH
12676: CALL_OW 571
12680: IFFALSE 12873
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 50
12699: PUSH
12700: EMPTY
12701: LIST
12702: PUSH
12703: LD_INT 56
12705: PUSH
12706: EMPTY
12707: LIST
12708: PUSH
12709: LD_INT 91
12711: PUSH
12712: LD_VAR 0 1
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 35
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: LD_OWVAR 67
12735: ARRAY
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 2
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 8
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: ST_TO_ADDR
// if not tmp then
12826: LD_VAR 0 3
12830: NOT
12831: IFFALSE 12835
// continue ;
12833: GO 12668
// if Prob ( 30 * Difficulty ) then
12835: LD_INT 30
12837: PUSH
12838: LD_OWVAR 67
12842: MUL
12843: PPUSH
12844: CALL_OW 13
12848: IFFALSE 12873
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12850: LD_VAR 0 3
12854: PUSH
12855: LD_INT 1
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 12
12867: ARRAY
12868: PPUSH
12869: CALL 31166 0 1
// end ; if IsDead ( i ) then
12873: LD_VAR 0 1
12877: PPUSH
12878: CALL_OW 301
12882: IFFALSE 12902
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12884: LD_ADDR_EXP 91
12888: PUSH
12889: LD_EXP 91
12893: PUSH
12894: LD_VAR 0 1
12898: DIFF
12899: ST_TO_ADDR
// continue ;
12900: GO 12668
// end ; end ;
12902: GO 12668
12904: POP
12905: POP
// until allianceDestroyed or not allianceSpecialForce ;
12906: LD_EXP 23
12910: PUSH
12911: LD_EXP 91
12915: NOT
12916: OR
12917: IFFALSE 12651
// end ;
12919: PPOPN 3
12921: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12922: LD_EXP 23
12926: NOT
12927: PUSH
12928: LD_EXP 31
12932: AND
12933: IFFALSE 13900
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
12941: PPUSH
12942: PPUSH
12943: PPUSH
// begin enable ;
12944: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: NOT
12974: IFFALSE 12978
// exit ;
12976: GO 13900
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 7
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 30
12995: PUSH
12996: LD_INT 34
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// if Prob ( 40 ) then
13012: LD_INT 40
13014: PPUSH
13015: CALL_OW 13
13019: IFFALSE 13146
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13021: LD_INT 1
13023: PPUSH
13024: LD_INT 5
13026: PUSH
13027: LD_INT 3
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: PUSH
13042: LD_INT 5
13044: PUSH
13045: LD_INT 3
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 6
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 6
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 24
13080: PUSH
13081: LD_INT 3
13083: PUSH
13084: LD_INT 3
13086: PUSH
13087: LD_INT 45
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 24
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 3
13104: PUSH
13105: LD_INT 47
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 24
13116: PUSH
13117: LD_INT 3
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 45
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PPUSH
13140: CALL 58848 0 2
// end else
13144: GO 13269
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 24
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 3
13157: PUSH
13158: LD_INT 47
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: LD_INT 24
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 47
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 5
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 9
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 3
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: LD_INT 9
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: PUSH
13221: LD_INT 24
13223: PUSH
13224: LD_INT 1
13226: PUSH
13227: LD_INT 3
13229: PUSH
13230: LD_INT 45
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 24
13241: PUSH
13242: LD_INT 1
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 45
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL 58848 0 2
// end ; if Difficulty > 1 then
13269: LD_OWVAR 67
13273: PUSH
13274: LD_INT 1
13276: GREATER
13277: IFFALSE 13307
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13279: LD_INT 1
13281: PPUSH
13282: LD_INT 24
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 3
13290: PUSH
13291: LD_INT 47
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: PPUSH
13303: CALL 58848 0 2
// repeat wait ( 0 0$1 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13314: LD_INT 1
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL 60266 0 2
13324: PUSH
13325: LD_INT 6
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: LD_INT 7
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_OWVAR 67
13343: ARRAY
13344: GREATEREQUAL
13345: IFFALSE 13307
// wait ( 0 0$40 ) ;
13347: LD_INT 1400
13349: PPUSH
13350: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13354: LD_ADDR_VAR 0 2
13358: PUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL 60266 0 2
13369: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13370: LD_ADDR_EXP 132
13374: PUSH
13375: LD_EXP 132
13379: PPUSH
13380: LD_INT 1
13382: PPUSH
13383: LD_EXP 132
13387: PUSH
13388: LD_INT 1
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 2
13396: DIFF
13397: PPUSH
13398: CALL_OW 1
13402: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 0
13410: PPUSH
13411: LD_INT 1
13413: PPUSH
13414: CALL_OW 12
13418: ST_TO_ADDR
// if target then
13419: LD_VAR 0 3
13423: IFFALSE 13589
// begin for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13461
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 179
13445: PPUSH
13446: LD_INT 209
13448: PPUSH
13449: LD_INT 8
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 483
13459: GO 13435
13461: POP
13462: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_INT 24
13475: PUSH
13476: LD_INT 250
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 72
13487: ST_TO_ADDR
// for i in tmp do
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_VAR 0 2
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13539
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 179
13508: PPUSH
13509: LD_INT 209
13511: PPUSH
13512: CALL_OW 297
13516: PUSH
13517: LD_INT 9
13519: GREATER
13520: IFFALSE 13537
// ComMoveXY ( i , 179 , 209 ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 179
13529: PPUSH
13530: LD_INT 209
13532: PPUSH
13533: CALL_OW 111
13537: GO 13498
13539: POP
13540: POP
// wait ( 0 0$1 ) ;
13541: LD_INT 35
13543: PPUSH
13544: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 92
13555: PUSH
13556: LD_INT 179
13558: PUSH
13559: LD_INT 209
13561: PUSH
13562: LD_INT 9
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PPUSH
13571: CALL_OW 72
13575: PUSH
13576: LD_VAR 0 2
13580: PUSH
13581: LD_INT 1
13583: MINUS
13584: GREATEREQUAL
13585: IFFALSE 13463
// end else
13587: GO 13751
// begin for i in tmp do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: LD_VAR 0 2
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 285
13609: PPUSH
13610: LD_INT 163
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
13623: GO 13599
13625: POP
13626: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13627: LD_ADDR_VAR 0 2
13631: PUSH
13632: LD_VAR 0 2
13636: PPUSH
13637: LD_INT 24
13639: PUSH
13640: LD_INT 250
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 72
13651: ST_TO_ADDR
// for i in tmp do
13652: LD_ADDR_VAR 0 1
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: FOR_IN
13663: IFFALSE 13703
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_INT 285
13672: PPUSH
13673: LD_INT 163
13675: PPUSH
13676: CALL_OW 297
13680: PUSH
13681: LD_INT 9
13683: GREATER
13684: IFFALSE 13701
// ComMoveXY ( i , 285 , 163 ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 285
13693: PPUSH
13694: LD_INT 163
13696: PPUSH
13697: CALL_OW 111
13701: GO 13662
13703: POP
13704: POP
// wait ( 0 0$1 ) ;
13705: LD_INT 35
13707: PPUSH
13708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 92
13719: PUSH
13720: LD_INT 285
13722: PUSH
13723: LD_INT 163
13725: PUSH
13726: LD_INT 9
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PUSH
13740: LD_VAR 0 2
13744: PUSH
13745: LD_INT 1
13747: MINUS
13748: GREATEREQUAL
13749: IFFALSE 13627
// end ; repeat wait ( 0 0$1 ) ;
13751: LD_INT 35
13753: PPUSH
13754: CALL_OW 67
// for i in tmp do
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_VAR 0 2
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13891
// if GetLives ( i ) > 251 then
13771: LD_VAR 0 1
13775: PPUSH
13776: CALL_OW 256
13780: PUSH
13781: LD_INT 251
13783: GREATER
13784: IFFALSE 13873
// begin if GetWeapon ( i ) = ru_time_lapser then
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 264
13795: PUSH
13796: LD_INT 49
13798: EQUAL
13799: IFFALSE 13837
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13801: LD_VAR 0 1
13805: PPUSH
13806: LD_INT 81
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PPUSH
13821: LD_VAR 0 1
13825: PPUSH
13826: CALL_OW 74
13830: PPUSH
13831: CALL_OW 112
13835: GO 13871
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_INT 81
13844: PUSH
13845: LD_INT 7
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PPUSH
13852: CALL_OW 69
13856: PPUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 74
13866: PPUSH
13867: CALL_OW 115
// end else
13871: GO 13889
// tmp := tmp diff i ;
13873: LD_ADDR_VAR 0 2
13877: PUSH
13878: LD_VAR 0 2
13882: PUSH
13883: LD_VAR 0 1
13887: DIFF
13888: ST_TO_ADDR
13889: GO 13768
13891: POP
13892: POP
// until not tmp ;
13893: LD_VAR 0 2
13897: NOT
13898: IFFALSE 13751
// end ; end_of_file
13900: PPOPN 4
13902: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
13908: PPUSH
// missionStage := 13 ;
13909: LD_ADDR_EXP 15
13913: PUSH
13914: LD_INT 13
13916: ST_TO_ADDR
// uc_side := 2 ;
13917: LD_ADDR_OWVAR 20
13921: PUSH
13922: LD_INT 2
13924: ST_TO_ADDR
// uc_nation := 2 ;
13925: LD_ADDR_OWVAR 21
13929: PUSH
13930: LD_INT 2
13932: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13933: LD_ADDR_EXP 92
13937: PUSH
13938: LD_STRING Omar
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13946: LD_EXP 92
13950: PPUSH
13951: LD_INT 4
13953: PPUSH
13954: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13958: LD_EXP 92
13962: PPUSH
13963: LD_INT 242
13965: PPUSH
13966: LD_INT 75
13968: PPUSH
13969: LD_INT 0
13971: PPUSH
13972: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13976: LD_ADDR_EXP 93
13980: PUSH
13981: LD_STRING Heike
13983: PPUSH
13984: CALL_OW 25
13988: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13989: LD_INT 14
13991: PPUSH
13992: LD_INT 3
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 27
14000: PPUSH
14001: LD_INT 100
14003: PPUSH
14004: CALL 70035 0 5
// veh := CreateVehicle ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: CALL_OW 45
14017: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 1
14025: PPUSH
14026: CALL_OW 242
// SetDir ( veh , 4 ) ;
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_INT 4
14037: PPUSH
14038: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_INT 241
14049: PPUSH
14050: LD_INT 72
14052: PPUSH
14053: LD_INT 0
14055: PPUSH
14056: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14060: LD_EXP 93
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL_OW 52
// if KhatamStatus then
14074: LD_EXP 8
14078: IFFALSE 14129
// begin Khatam := NewCharacter ( Khatam ) ;
14080: LD_ADDR_EXP 94
14084: PUSH
14085: LD_STRING Khatam
14087: PPUSH
14088: CALL_OW 25
14092: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14093: LD_EXP 94
14097: PPUSH
14098: LD_INT 245
14100: PPUSH
14101: LD_INT 78
14103: PPUSH
14104: LD_INT 3
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14114: LD_EXP 94
14118: PPUSH
14119: LD_INT 4
14121: PPUSH
14122: LD_INT 10
14124: PPUSH
14125: CALL_OW 237
// end ; for i = 1 to Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_OWVAR 67
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14211
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14147: LD_INT 0
14149: PPUSH
14150: LD_INT 7
14152: PUSH
14153: LD_OWVAR 67
14157: PLUS
14158: PPUSH
14159: CALL_OW 384
// un := CreateHuman ;
14163: LD_ADDR_VAR 0 4
14167: PUSH
14168: CALL_OW 44
14172: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14173: LD_VAR 0 4
14177: PPUSH
14178: LD_INT 28
14180: PUSH
14181: LD_INT 29
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_VAR 0 2
14192: PUSH
14193: LD_INT 2
14195: MOD
14196: PUSH
14197: LD_INT 1
14199: PLUS
14200: ARRAY
14201: PPUSH
14202: LD_INT 0
14204: PPUSH
14205: CALL_OW 49
// end ;
14209: GO 14144
14211: POP
14212: POP
// for i = 1 to 6 do
14213: LD_ADDR_VAR 0 2
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_INT 6
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14272
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14229: LD_INT 0
14231: PPUSH
14232: LD_INT 7
14234: PUSH
14235: LD_OWVAR 67
14239: PLUS
14240: PPUSH
14241: CALL_OW 381
// un := CreateHuman ;
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: CALL_OW 44
14254: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14255: LD_VAR 0 4
14259: PPUSH
14260: LD_INT 28
14262: PPUSH
14263: LD_INT 0
14265: PPUSH
14266: CALL_OW 49
// end ;
14270: GO 14226
14272: POP
14273: POP
// for i = 1 to 3 do
14274: LD_ADDR_VAR 0 2
14278: PUSH
14279: DOUBLE
14280: LD_INT 1
14282: DEC
14283: ST_TO_ADDR
14284: LD_INT 3
14286: PUSH
14287: FOR_TO
14288: IFFALSE 14336
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14290: LD_INT 0
14292: PPUSH
14293: LD_INT 8
14295: PPUSH
14296: LD_INT 7
14298: PUSH
14299: LD_OWVAR 67
14303: PLUS
14304: PPUSH
14305: CALL_OW 380
// un := CreateHuman ;
14309: LD_ADDR_VAR 0 4
14313: PUSH
14314: CALL_OW 44
14318: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14319: LD_VAR 0 4
14323: PPUSH
14324: LD_INT 28
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// end ;
14334: GO 14287
14336: POP
14337: POP
// for i = 1 to 3 do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: DOUBLE
14344: LD_INT 1
14346: DEC
14347: ST_TO_ADDR
14348: LD_INT 3
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14442
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14354: LD_INT 14
14356: PPUSH
14357: LD_INT 2
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 80
14368: PPUSH
14369: CALL 70035 0 5
// veh := CreateVehicle ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: CALL_OW 45
14382: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14383: LD_VAR 0 3
14387: PPUSH
14388: LD_INT 3
14390: PPUSH
14391: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14395: LD_VAR 0 3
14399: PPUSH
14400: LD_INT 29
14402: PPUSH
14403: LD_INT 0
14405: PPUSH
14406: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14410: LD_INT 0
14412: PPUSH
14413: LD_INT 7
14415: PUSH
14416: LD_OWVAR 67
14420: PLUS
14421: PPUSH
14422: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14426: CALL_OW 44
14430: PPUSH
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 52
// end ;
14440: GO 14351
14442: POP
14443: POP
// for i = 1 to 5 + Difficulty do
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: DOUBLE
14450: LD_INT 1
14452: DEC
14453: ST_TO_ADDR
14454: LD_INT 5
14456: PUSH
14457: LD_OWVAR 67
14461: PLUS
14462: PUSH
14463: FOR_TO
14464: IFFALSE 14591
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14466: LD_INT 14
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 3
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 28
14485: PUSH
14486: LD_INT 26
14488: PUSH
14489: LD_INT 27
14491: PUSH
14492: LD_INT 25
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: LD_VAR 0 2
14505: PUSH
14506: LD_INT 4
14508: MOD
14509: PUSH
14510: LD_INT 1
14512: PLUS
14513: ARRAY
14514: PPUSH
14515: LD_INT 80
14517: PPUSH
14518: CALL 70035 0 5
// veh := CreateVehicle ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: CALL_OW 45
14531: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 4
14539: PPUSH
14540: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14544: LD_VAR 0 3
14548: PPUSH
14549: LD_INT 28
14551: PPUSH
14552: LD_INT 0
14554: PPUSH
14555: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14559: LD_INT 0
14561: PPUSH
14562: LD_INT 7
14564: PUSH
14565: LD_OWVAR 67
14569: PLUS
14570: PPUSH
14571: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14575: CALL_OW 44
14579: PPUSH
14580: LD_VAR 0 3
14584: PPUSH
14585: CALL_OW 52
// end ;
14589: GO 14463
14591: POP
14592: POP
// for i = 1 to 3 do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 3
14605: PUSH
14606: FOR_TO
14607: IFFALSE 14667
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14609: LD_INT 14
14611: PPUSH
14612: LD_INT 3
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: LD_INT 29
14620: PPUSH
14621: LD_INT 80
14623: PPUSH
14624: CALL 70035 0 5
// veh := CreateVehicle ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: CALL_OW 45
14637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14638: LD_VAR 0 3
14642: PPUSH
14643: LD_INT 4
14645: PPUSH
14646: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14650: LD_VAR 0 3
14654: PPUSH
14655: LD_INT 28
14657: PPUSH
14658: LD_INT 0
14660: PPUSH
14661: CALL_OW 49
// end ;
14665: GO 14606
14667: POP
14668: POP
// end ;
14669: LD_VAR 0 1
14673: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14674: LD_INT 22
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: IFFALSE 14988
14690: GO 14692
14692: DISABLE
14693: LD_INT 0
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 25
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PPUSH
14727: CALL_OW 69
14731: PUSH
14732: LD_EXP 94
14736: DIFF
14737: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 2
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: PUSH
14758: LD_EXP 94
14762: PUSH
14763: LD_VAR 0 3
14767: UNION
14768: DIFF
14769: ST_TO_ADDR
// if Khatam then
14770: LD_EXP 94
14774: IFFALSE 14791
// ComMoveXY ( Khatam , 211 , 92 ) ;
14776: LD_EXP 94
14780: PPUSH
14781: LD_INT 211
14783: PPUSH
14784: LD_INT 92
14786: PPUSH
14787: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14791: LD_INT 197
14793: PPUSH
14794: LD_INT 80
14796: PPUSH
14797: LD_INT 2
14799: PPUSH
14800: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14804: LD_INT 213
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 2
14812: PPUSH
14813: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14817: LD_INT 215
14819: PPUSH
14820: LD_INT 129
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 441
// if sci then
14830: LD_VAR 0 3
14834: IFFALSE 14855
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14836: LD_VAR 0 3
14840: PUSH
14841: LD_INT 1
14843: ARRAY
14844: PPUSH
14845: LD_INT 197
14847: PPUSH
14848: LD_INT 80
14850: PPUSH
14851: CALL_OW 158
// if sci > 1 then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 1
14862: GREATER
14863: IFFALSE 14884
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14865: LD_VAR 0 3
14869: PUSH
14870: LD_INT 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 213
14876: PPUSH
14877: LD_INT 90
14879: PPUSH
14880: CALL_OW 158
// if sci > 2 then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 2
14891: GREATER
14892: IFFALSE 14913
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14894: LD_VAR 0 3
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 215
14905: PPUSH
14906: LD_INT 129
14908: PPUSH
14909: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14913: LD_INT 35
14915: PPUSH
14916: CALL_OW 67
// for i in tmp do
14920: LD_ADDR_VAR 0 1
14924: PUSH
14925: LD_VAR 0 2
14929: PUSH
14930: FOR_IN
14931: IFFALSE 14969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_INT 81
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: PPUSH
14953: LD_VAR 0 1
14957: PPUSH
14958: CALL_OW 74
14962: PPUSH
14963: CALL_OW 115
14967: GO 14930
14969: POP
14970: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14971: LD_INT 22
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PPUSH
14981: CALL_OW 69
14985: NOT
14986: IFFALSE 14913
// end ; end_of_file
14988: PPOPN 3
14990: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14991: LD_INT 0
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// Video ( true ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 101172 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: LD_INT 7
15016: PPUSH
15017: LD_INT 0
15019: PPUSH
15020: CALL_OW 517
15024: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: DOUBLE
15031: LD_INT 1
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 1
15042: ARRAY
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15090
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15047: LD_VAR 0 5
15051: PUSH
15052: LD_INT 1
15054: ARRAY
15055: PUSH
15056: LD_VAR 0 2
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 5
15066: PUSH
15067: LD_INT 2
15069: ARRAY
15070: PUSH
15071: LD_VAR 0 2
15075: ARRAY
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: LD_INT 15
15082: NEG
15083: PPUSH
15084: CALL 101086 0 4
15088: GO 15044
15090: POP
15091: POP
// CenterNowOnUnits ( Powell ) ;
15092: LD_EXP 58
15096: PPUSH
15097: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15101: LD_ADDR_VAR 0 5
15105: PUSH
15106: LD_EXP 56
15110: PUSH
15111: EMPTY
15112: LIST
15113: ST_TO_ADDR
// if GirlNewVeh then
15114: LD_EXP 57
15118: IFFALSE 15136
// tmp := tmp ^ GirlNewVeh ;
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: LD_VAR 0 5
15129: PUSH
15130: LD_EXP 57
15134: ADD
15135: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15136: LD_VAR 0 5
15140: PPUSH
15141: LD_INT 60
15143: PPUSH
15144: LD_INT 109
15146: PPUSH
15147: CALL_OW 111
// if KappaStatus then
15151: LD_EXP 2
15155: IFFALSE 15207
// begin Say ( JMM , D1nT-JMM-1 ) ;
15157: LD_EXP 39
15161: PPUSH
15162: LD_STRING D1nT-JMM-1
15164: PPUSH
15165: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15169: LD_EXP 58
15173: PPUSH
15174: LD_STRING D1T-Pow-1
15176: PPUSH
15177: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15181: LD_EXP 39
15185: PPUSH
15186: LD_STRING D1T-JMM-2
15188: PPUSH
15189: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15193: LD_EXP 58
15197: PPUSH
15198: LD_STRING D1T-Pow-2
15200: PPUSH
15201: CALL_OW 88
// end else
15205: GO 15413
// if JMMGirlStatus then
15207: LD_EXP 6
15211: IFFALSE 15356
// begin Say ( JMM , D1T-JMM-1 ) ;
15213: LD_EXP 39
15217: PPUSH
15218: LD_STRING D1T-JMM-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15225: LD_EXP 58
15229: PPUSH
15230: LD_STRING D1T-Pow-1
15232: PPUSH
15233: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1T-JMM-3
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-3
15256: PPUSH
15257: CALL_OW 88
// if JMMGirl then
15261: LD_EXP 7
15265: IFFALSE 15354
// begin case JMMGirl of 1 :
15267: LD_EXP 7
15271: PUSH
15272: LD_INT 1
15274: DOUBLE
15275: EQUAL
15276: IFTRUE 15280
15278: GO 15295
15280: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15281: LD_EXP 40
15285: PPUSH
15286: LD_STRING D1T-Joan-3
15288: PPUSH
15289: CALL_OW 88
15293: GO 15342
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15318
15303: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15304: LD_EXP 42
15308: PPUSH
15309: LD_STRING D1T-Lisa-3
15311: PPUSH
15312: CALL_OW 88
15316: GO 15342
15318: LD_INT 3
15320: DOUBLE
15321: EQUAL
15322: IFTRUE 15326
15324: GO 15341
15326: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15327: LD_EXP 54
15331: PPUSH
15332: LD_STRING D1T-Con-3
15334: PPUSH
15335: CALL_OW 88
15339: GO 15342
15341: POP
// Say ( Powell , D1T-Pow-4 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-4
15349: PPUSH
15350: CALL_OW 88
// end ; end else
15354: GO 15413
// if not FastEnd then
15356: LD_EXP 11
15360: NOT
15361: IFFALSE 15389
// begin Say ( JMM , D1T-JMM-4 ) ;
15363: LD_EXP 39
15367: PPUSH
15368: LD_STRING D1T-JMM-4
15370: PPUSH
15371: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15375: LD_EXP 58
15379: PPUSH
15380: LD_STRING D1T-Pow-5
15382: PPUSH
15383: CALL_OW 88
// end else
15387: GO 15413
// begin Say ( JMM , D1nT-JMM-1 ) ;
15389: LD_EXP 39
15393: PPUSH
15394: LD_STRING D1nT-JMM-1
15396: PPUSH
15397: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15401: LD_EXP 58
15405: PPUSH
15406: LD_STRING D1nT-Pow-1
15408: PPUSH
15409: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15413: LD_INT 35
15415: PPUSH
15416: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15420: LD_EXP 56
15424: PPUSH
15425: CALL_OW 314
15429: NOT
15430: IFFALSE 15413
// ComExitVehicle ( JMM ) ;
15432: LD_EXP 39
15436: PPUSH
15437: CALL_OW 121
// wait ( 3 ) ;
15441: LD_INT 3
15443: PPUSH
15444: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15448: LD_EXP 39
15452: PPUSH
15453: LD_INT 60
15455: PPUSH
15456: LD_INT 94
15458: PPUSH
15459: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15463: LD_EXP 39
15467: PPUSH
15468: LD_EXP 58
15472: PPUSH
15473: CALL_OW 179
// if Joan then
15477: LD_EXP 40
15481: IFFALSE 15535
// begin ComExitVehicle ( Joan ) ;
15483: LD_EXP 40
15487: PPUSH
15488: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15492: LD_EXP 40
15496: PPUSH
15497: LD_INT 35
15499: PPUSH
15500: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15504: LD_EXP 40
15508: PPUSH
15509: LD_INT 65
15511: PPUSH
15512: LD_INT 104
15514: PPUSH
15515: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15519: LD_EXP 40
15523: PPUSH
15524: LD_EXP 39
15528: PPUSH
15529: CALL_OW 179
// end else
15533: GO 15669
// if Lisa and JMMGirl = 2 then
15535: LD_EXP 42
15539: PUSH
15540: LD_EXP 7
15544: PUSH
15545: LD_INT 2
15547: EQUAL
15548: AND
15549: IFFALSE 15603
// begin ComExitVehicle ( Lisa ) ;
15551: LD_EXP 42
15555: PPUSH
15556: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15560: LD_EXP 42
15564: PPUSH
15565: LD_INT 35
15567: PPUSH
15568: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15572: LD_EXP 42
15576: PPUSH
15577: LD_INT 65
15579: PPUSH
15580: LD_INT 104
15582: PPUSH
15583: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15587: LD_EXP 42
15591: PPUSH
15592: LD_EXP 39
15596: PPUSH
15597: CALL_OW 179
// end else
15601: GO 15669
// if Connie and JMMGirl = 3 then
15603: LD_EXP 54
15607: PUSH
15608: LD_EXP 7
15612: PUSH
15613: LD_INT 3
15615: EQUAL
15616: AND
15617: IFFALSE 15669
// begin ComExitVehicle ( Connie ) ;
15619: LD_EXP 54
15623: PPUSH
15624: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15628: LD_EXP 54
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15640: LD_EXP 54
15644: PPUSH
15645: LD_INT 65
15647: PPUSH
15648: LD_INT 104
15650: PPUSH
15651: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15655: LD_EXP 54
15659: PPUSH
15660: LD_EXP 39
15664: PPUSH
15665: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15669: LD_INT 35
15671: PPUSH
15672: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15676: LD_EXP 39
15680: PPUSH
15681: LD_EXP 58
15685: PPUSH
15686: CALL_OW 296
15690: PUSH
15691: LD_INT 6
15693: LESS
15694: IFFALSE 15669
// wait ( 0 0$0.5 ) ;
15696: LD_INT 18
15698: PPUSH
15699: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15703: LD_EXP 39
15707: PPUSH
15708: LD_STRING D1-JMM-1
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15716: LD_EXP 58
15720: PPUSH
15721: LD_STRING D1-Pow-1
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$2 ) ;
15735: LD_INT 70
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15742: LD_INT 170
15744: PPUSH
15745: LD_INT 99
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 6
15753: NEG
15754: PPUSH
15755: CALL 101086 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15759: LD_INT 174
15761: PPUSH
15762: LD_INT 115
15764: PPUSH
15765: LD_INT 1
15767: PPUSH
15768: LD_INT 6
15770: NEG
15771: PPUSH
15772: CALL 101086 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15776: LD_INT 169
15778: PPUSH
15779: LD_INT 71
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_INT 6
15787: NEG
15788: PPUSH
15789: CALL 101086 0 4
// if not dialogue_skipped then
15793: LD_OWVAR 59
15797: NOT
15798: IFFALSE 15817
// begin CenterOnXY ( 170 , 99 ) ;
15800: LD_INT 170
15802: PPUSH
15803: LD_INT 99
15805: PPUSH
15806: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15810: LD_INT 80
15812: PPUSH
15813: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15817: LD_INT 75
15819: PPUSH
15820: LD_INT 53
15822: PPUSH
15823: LD_INT 1
15825: PPUSH
15826: LD_INT 9
15828: NEG
15829: PPUSH
15830: CALL 101086 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15834: LD_INT 54
15836: PPUSH
15837: LD_INT 42
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 9
15845: NEG
15846: PPUSH
15847: CALL 101086 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15851: LD_INT 62
15853: PPUSH
15854: LD_INT 51
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_INT 9
15862: NEG
15863: PPUSH
15864: CALL 101086 0 4
// if not dialogue_skipped then
15868: LD_OWVAR 59
15872: NOT
15873: IFFALSE 15892
// begin CenterOnXY ( 75 , 53 ) ;
15875: LD_INT 75
15877: PPUSH
15878: LD_INT 53
15880: PPUSH
15881: CALL_OW 84
// wait ( 0 0$4 ) ;
15885: LD_INT 140
15887: PPUSH
15888: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15892: LD_EXP 58
15896: PPUSH
15897: CALL_OW 87
// if not dialogue_skipped then
15901: LD_OWVAR 59
15905: NOT
15906: IFFALSE 15915
// wait ( 0 0$2 ) ;
15908: LD_INT 70
15910: PPUSH
15911: CALL_OW 67
// sync ;
15915: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15916: LD_EXP 39
15920: PPUSH
15921: LD_STRING D1-JMM-2
15923: PPUSH
15924: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15928: LD_EXP 58
15932: PPUSH
15933: LD_STRING D1-Pow-2
15935: PPUSH
15936: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15940: LD_EXP 39
15944: PPUSH
15945: LD_STRING D1-JMM-3
15947: PPUSH
15948: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15952: LD_EXP 58
15956: PPUSH
15957: LD_STRING D1-Pow-3
15959: PPUSH
15960: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15964: LD_EXP 39
15968: PPUSH
15969: LD_STRING D1-JMM-4
15971: PPUSH
15972: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-4
15983: PPUSH
15984: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-5
15995: PPUSH
15996: CALL_OW 88
// async ;
16000: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16001: LD_EXP 58
16005: PPUSH
16006: LD_STRING D1-Pow-5
16008: PPUSH
16009: CALL_OW 88
// if not dialogue_skipped then
16013: LD_OWVAR 59
16017: NOT
16018: IFFALSE 16027
// wait ( 0 0$3.6 ) ;
16020: LD_INT 126
16022: PPUSH
16023: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16027: LD_INT 134
16029: PPUSH
16030: LD_INT 210
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: LD_INT 11
16038: NEG
16039: PPUSH
16040: CALL 101086 0 4
// if not dialogue_skipped then
16044: LD_OWVAR 59
16048: NOT
16049: IFFALSE 16068
// begin CenterOnXY ( 134 , 210 ) ;
16051: LD_INT 134
16053: PPUSH
16054: LD_INT 210
16056: PPUSH
16057: CALL_OW 84
// wait ( 0 0$2 ) ;
16061: LD_INT 70
16063: PPUSH
16064: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16068: LD_INT 101
16070: PPUSH
16071: LD_INT 159
16073: PPUSH
16074: LD_INT 1
16076: PPUSH
16077: LD_INT 10
16079: NEG
16080: PPUSH
16081: CALL 101086 0 4
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16109
// begin CenterOnXY ( 101 , 159 ) ;
16092: LD_INT 101
16094: PPUSH
16095: LD_INT 159
16097: PPUSH
16098: CALL_OW 84
// wait ( 0 0$2 ) ;
16102: LD_INT 70
16104: PPUSH
16105: CALL_OW 67
// end ; sync ;
16109: SYNC
// CenterNowOnUnits ( Powell ) ;
16110: LD_EXP 58
16114: PPUSH
16115: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16119: LD_ADDR_VAR 0 6
16123: PUSH
16124: LD_INT 1
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 5
16138: PUSH
16139: LD_INT 6
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: ST_TO_ADDR
// if not dialogue_skipped then
16150: LD_OWVAR 59
16154: NOT
16155: IFFALSE 16324
// begin game_speed := 4 ;
16157: LD_ADDR_OWVAR 65
16161: PUSH
16162: LD_INT 4
16164: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16165: LD_INT 210
16167: PPUSH
16168: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16172: LD_ADDR_VAR 0 7
16176: PUSH
16177: LD_STRING Q1
16179: PPUSH
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 98
16189: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16190: LD_ADDR_VAR 0 7
16194: PUSH
16195: LD_STRING Q1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: CALL_OW 98
16207: ST_TO_ADDR
// options = options diff dec ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: DIFF
16223: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16224: LD_VAR 0 7
16228: PPUSH
16229: LD_VAR 0 6
16233: PPUSH
16234: CALL 17796 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16238: LD_VAR 0 7
16242: PUSH
16243: LD_INT 5
16245: PUSH
16246: LD_INT 6
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: IN
16253: PUSH
16254: LD_VAR 0 6
16258: PUSH
16259: LD_INT 2
16261: EQUAL
16262: OR
16263: IFFALSE 16190
// if not ( dec in [ 5 , 6 ] ) then
16265: LD_VAR 0 7
16269: PUSH
16270: LD_INT 5
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: IN
16280: NOT
16281: IFFALSE 16324
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1a
16290: PPUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 98
16305: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16306: LD_VAR 0 7
16310: PUSH
16311: LD_INT 4
16313: PLUS
16314: PPUSH
16315: LD_VAR 0 6
16319: PPUSH
16320: CALL 17796 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16324: LD_INT 81
16326: PPUSH
16327: LD_INT 127
16329: PPUSH
16330: CALL_OW 84
// amount := 5 ;
16334: LD_ADDR_VAR 0 8
16338: PUSH
16339: LD_INT 5
16341: ST_TO_ADDR
// macmilan_squad := [ ] ;
16342: LD_ADDR_VAR 0 9
16346: PUSH
16347: EMPTY
16348: ST_TO_ADDR
// if vip < amount then
16349: LD_EXP 59
16353: PUSH
16354: LD_VAR 0 8
16358: LESS
16359: IFFALSE 16403
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: LD_EXP 59
16370: PUSH
16371: LD_INT 22
16373: PUSH
16374: LD_INT 4
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: UNION
16400: ST_TO_ADDR
16401: GO 16413
// tmp := vip ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_EXP 59
16412: ST_TO_ADDR
// tmp := tmp diff Powell ;
16413: LD_ADDR_VAR 0 5
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: LD_EXP 58
16427: DIFF
16428: ST_TO_ADDR
// if tmp < amount then
16429: LD_VAR 0 5
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16451
// amount := tmp ;
16441: LD_ADDR_VAR 0 8
16445: PUSH
16446: LD_VAR 0 5
16450: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16451: LD_VAR 0 5
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 257
16464: PUSH
16465: LD_INT 2
16467: NONEQUAL
16468: IFFALSE 16530
// begin if IsInUnit ( tmp [ 1 ] ) then
16470: LD_VAR 0 5
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: PPUSH
16479: CALL_OW 310
16483: IFFALSE 16498
// ComExitBuilding ( tmp [ 1 ] ) ;
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: ARRAY
16493: PPUSH
16494: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16498: LD_VAR 0 5
16502: PUSH
16503: LD_INT 1
16505: ARRAY
16506: PPUSH
16507: LD_INT 387
16509: PPUSH
16510: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_INT 1
16521: ARRAY
16522: PPUSH
16523: LD_INT 2
16525: PPUSH
16526: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16530: LD_EXP 39
16534: PPUSH
16535: LD_INT 82
16537: PPUSH
16538: LD_INT 129
16540: PPUSH
16541: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16545: LD_EXP 39
16549: PPUSH
16550: LD_EXP 58
16554: PPUSH
16555: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16559: LD_INT 22
16561: PUSH
16562: LD_INT 1
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: PUSH
16574: LD_EXP 39
16578: DIFF
16579: PPUSH
16580: LD_INT 84
16582: PPUSH
16583: LD_INT 128
16585: PPUSH
16586: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16590: LD_INT 22
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: PUSH
16605: LD_EXP 39
16609: DIFF
16610: PPUSH
16611: LD_EXP 39
16615: PPUSH
16616: CALL_OW 179
// for i = 1 to amount do
16620: LD_ADDR_VAR 0 2
16624: PUSH
16625: DOUBLE
16626: LD_INT 1
16628: DEC
16629: ST_TO_ADDR
16630: LD_VAR 0 8
16634: PUSH
16635: FOR_TO
16636: IFFALSE 16804
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16638: LD_ADDR_VAR 0 9
16642: PUSH
16643: LD_VAR 0 9
16647: PUSH
16648: LD_VAR 0 5
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: ADD
16659: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16660: LD_VAR 0 5
16664: PUSH
16665: LD_VAR 0 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 310
16675: IFFALSE 16692
// AddComExitBuilding ( tmp [ i ] ) ;
16677: LD_VAR 0 5
16681: PUSH
16682: LD_VAR 0 2
16686: ARRAY
16687: PPUSH
16688: CALL_OW 182
// if i = 2 and JMMNewVeh then
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: EQUAL
16700: PUSH
16701: LD_EXP 56
16705: AND
16706: IFFALSE 16764
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16708: LD_VAR 0 5
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_EXP 56
16723: PPUSH
16724: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: PPUSH
16739: LD_INT 86
16741: PPUSH
16742: LD_INT 133
16744: PPUSH
16745: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: LD_INT 8
16777: PPUSH
16778: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16782: LD_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: ARRAY
16792: PPUSH
16793: LD_EXP 39
16797: PPUSH
16798: CALL_OW 179
// end ;
16802: GO 16635
16804: POP
16805: POP
// if GirlNewVeh then
16806: LD_EXP 57
16810: IFFALSE 16824
// SetSide ( GirlNewVeh , 4 ) ;
16812: LD_EXP 57
16816: PPUSH
16817: LD_INT 4
16819: PPUSH
16820: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16824: LD_INT 35
16826: PPUSH
16827: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_INT 95
16838: PUSH
16839: LD_INT 9
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 72
16850: PUSH
16851: LD_INT 0
16853: EQUAL
16854: PUSH
16855: LD_EXP 39
16859: PPUSH
16860: LD_INT 9
16862: PPUSH
16863: CALL_OW 308
16867: NOT
16868: AND
16869: IFFALSE 16824
// wait ( 0 0$2 ) ;
16871: LD_INT 70
16873: PPUSH
16874: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16878: LD_VAR 0 9
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16890: LD_INT 21
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 92
16902: PUSH
16903: LD_INT 83
16905: PUSH
16906: LD_INT 130
16908: PUSH
16909: LD_INT 10
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PPUSH
16927: LD_INT 1
16929: PPUSH
16930: CALL_OW 235
// Video ( false ) ;
16934: LD_INT 0
16936: PPUSH
16937: CALL 101172 0 1
// ChangeMissionObjectives ( M1 ) ;
16941: LD_STRING M1
16943: PPUSH
16944: CALL_OW 337
// SaveForQuickRestart ;
16948: CALL_OW 22
// missionStart := true ;
16952: LD_ADDR_EXP 13
16956: PUSH
16957: LD_INT 1
16959: ST_TO_ADDR
// missionStage := 2 ;
16960: LD_ADDR_EXP 15
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16968: LD_INT 105
16970: PPUSH
16971: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16975: LD_ADDR_VAR 0 5
16979: PUSH
16980: LD_INT 22
16982: PUSH
16983: LD_INT 4
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 21
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 69
17008: PUSH
17009: LD_EXP 58
17013: DIFF
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 5
17019: NOT
17020: IFFALSE 17035
// tmp := [ Powell ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_EXP 58
17031: PUSH
17032: EMPTY
17033: LIST
17034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17035: LD_ADDR_EXP 113
17039: PUSH
17040: LD_EXP 113
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 23
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 21
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: PUSH
17095: LD_EXP 58
17099: DIFF
17100: PPUSH
17101: CALL_OW 1
17105: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 34
17123: PUSH
17124: LD_INT 12
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: PUSH
17140: LD_INT 1
17142: ARRAY
17143: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17144: LD_VAR 0 5
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: CALL_OW 310
17157: IFFALSE 17172
// ComExitBuilding ( tmp [ 1 ] ) ;
17159: LD_VAR 0 5
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: PPUSH
17168: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17172: LD_VAR 0 5
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: PPUSH
17181: LD_VAR 0 4
17185: PPUSH
17186: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17190: LD_VAR 0 5
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: LD_INT 80
17201: PPUSH
17202: LD_INT 136
17204: PPUSH
17205: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17209: LD_VAR 0 5
17213: PUSH
17214: LD_INT 1
17216: ARRAY
17217: PPUSH
17218: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17222: LD_VAR 0 5
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_INT 59
17233: PPUSH
17234: LD_INT 112
17236: PPUSH
17237: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17241: LD_VAR 0 5
17245: PUSH
17246: LD_INT 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17254: LD_EXP 40
17258: PUSH
17259: LD_EXP 40
17263: PPUSH
17264: CALL_OW 255
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: AND
17273: IFFALSE 17299
// begin Say ( Joan , D3W-Joan-1 ) ;
17275: LD_EXP 40
17279: PPUSH
17280: LD_STRING D3W-Joan-1
17282: PPUSH
17283: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17287: LD_EXP 39
17291: PPUSH
17292: LD_STRING D3W-JMM-1
17294: PPUSH
17295: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17299: LD_EXP 42
17303: PUSH
17304: LD_EXP 42
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: PUSH
17319: LD_EXP 42
17323: PUSH
17324: LD_EXP 59
17328: IN
17329: NOT
17330: AND
17331: IFFALSE 17357
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17333: LD_EXP 42
17337: PPUSH
17338: LD_STRING D3W-Lisa-1
17340: PPUSH
17341: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17345: LD_EXP 39
17349: PPUSH
17350: LD_STRING D3W-JMM-1
17352: PPUSH
17353: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17357: LD_EXP 54
17361: PUSH
17362: LD_EXP 54
17366: PPUSH
17367: CALL_OW 255
17371: PUSH
17372: LD_INT 1
17374: EQUAL
17375: AND
17376: IFFALSE 17402
// begin Say ( Connie , D3W-Con-1 ) ;
17378: LD_EXP 54
17382: PPUSH
17383: LD_STRING D3W-Con-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17390: LD_EXP 39
17394: PPUSH
17395: LD_STRING D3W-JMM-1
17397: PPUSH
17398: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17402: LD_EXP 42
17406: PUSH
17407: LD_EXP 59
17411: IN
17412: PUSH
17413: LD_EXP 42
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 1
17425: EQUAL
17426: AND
17427: IFFALSE 17443
// Say ( Lisa , D3nW-Lisa-1 ) else
17429: LD_EXP 42
17433: PPUSH
17434: LD_STRING D3nW-Lisa-1
17436: PPUSH
17437: CALL_OW 88
17441: GO 17687
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17443: LD_EXP 45
17447: PUSH
17448: LD_EXP 59
17452: IN
17453: PUSH
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 1
17466: EQUAL
17467: AND
17468: IFFALSE 17484
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17470: LD_EXP 45
17474: PPUSH
17475: LD_STRING D3nW-Cyrus-1
17477: PPUSH
17478: CALL_OW 88
17482: GO 17687
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17484: LD_EXP 44
17488: PUSH
17489: LD_EXP 59
17493: IN
17494: PUSH
17495: LD_EXP 44
17499: PPUSH
17500: CALL_OW 255
17504: PUSH
17505: LD_INT 1
17507: EQUAL
17508: AND
17509: IFFALSE 17525
// Say ( Bobby , D3nW-Bobby-1 ) else
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING D3nW-Bobby-1
17518: PPUSH
17519: CALL_OW 88
17523: GO 17687
// if Gary in vip and GetSide ( Gary ) = 1 then
17525: LD_EXP 51
17529: PUSH
17530: LD_EXP 59
17534: IN
17535: PUSH
17536: LD_EXP 51
17540: PPUSH
17541: CALL_OW 255
17545: PUSH
17546: LD_INT 1
17548: EQUAL
17549: AND
17550: IFFALSE 17566
// Say ( Gary , D3nW-Gary-1 ) else
17552: LD_EXP 51
17556: PPUSH
17557: LD_STRING D3nW-Gary-1
17559: PPUSH
17560: CALL_OW 88
17564: GO 17687
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17566: LD_EXP 43
17570: PUSH
17571: LD_EXP 59
17575: IN
17576: PUSH
17577: LD_EXP 43
17581: PPUSH
17582: CALL_OW 255
17586: PUSH
17587: LD_INT 1
17589: EQUAL
17590: AND
17591: IFFALSE 17607
// Say ( Donaldson , D3nW-Don-1 ) else
17593: LD_EXP 43
17597: PPUSH
17598: LD_STRING D3nW-Don-1
17600: PPUSH
17601: CALL_OW 88
17605: GO 17687
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17607: LD_EXP 50
17611: PUSH
17612: LD_EXP 59
17616: IN
17617: PUSH
17618: LD_EXP 50
17622: PPUSH
17623: CALL_OW 255
17627: PUSH
17628: LD_INT 1
17630: EQUAL
17631: AND
17632: IFFALSE 17648
// Say ( Cornel , D3nW-Corn-1 ) else
17634: LD_EXP 50
17638: PPUSH
17639: LD_STRING D3nW-Corn-1
17641: PPUSH
17642: CALL_OW 88
17646: GO 17687
// if Frank in vip and GetSide ( Frank ) = 1 then
17648: LD_EXP 52
17652: PUSH
17653: LD_EXP 59
17657: IN
17658: PUSH
17659: LD_EXP 52
17663: PPUSH
17664: CALL_OW 255
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: AND
17673: IFFALSE 17687
// Say ( Frank , D3nW-Frank-1 ) ;
17675: LD_EXP 52
17679: PPUSH
17680: LD_STRING D3nW-Frank-1
17682: PPUSH
17683: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17687: LD_EXP 59
17691: PPUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PPUSH
17702: CALL_OW 72
17706: IFFALSE 17732
// begin Say ( JMM , D3nW-JMM-1 ) ;
17708: LD_EXP 39
17712: PPUSH
17713: LD_STRING D3nW-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17720: LD_EXP 39
17724: PPUSH
17725: LD_STRING D3nW-JMM-1a
17727: PPUSH
17728: CALL_OW 88
// end ; t := 0 0$00 ;
17732: LD_ADDR_VAR 0 3
17736: PUSH
17737: LD_INT 0
17739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17740: LD_INT 35
17742: PPUSH
17743: CALL_OW 67
// t := t + 0 0$1 ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 3
17756: PUSH
17757: LD_INT 35
17759: PLUS
17760: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17761: LD_INT 59
17763: PPUSH
17764: LD_INT 112
17766: PPUSH
17767: CALL_OW 428
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 2100
17779: GREATER
17780: OR
17781: IFFALSE 17740
// activeAttacks := true ;
17783: LD_ADDR_EXP 16
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17796: LD_INT 0
17798: PPUSH
// case question of 1 :
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 1
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17863
17812: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D2Mot-JMM-1
17820: PPUSH
17821: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17825: LD_EXP 58
17829: PPUSH
17830: LD_STRING D2Mot-Pow-1
17832: PPUSH
17833: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17837: LD_EXP 39
17841: PPUSH
17842: LD_STRING D2Mot-JMM-2
17844: PPUSH
17845: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17849: LD_EXP 58
17853: PPUSH
17854: LD_STRING D2Mot-Pow-2
17856: PPUSH
17857: CALL_OW 88
// end ; 2 :
17861: GO 18214
17863: LD_INT 2
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17947
17871: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Rus-JMM-1
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Rus-Pow-1
17891: PPUSH
17892: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17896: LD_EXP 39
17900: PPUSH
17901: LD_STRING D2Rus-JMM-2
17903: PPUSH
17904: CALL_OW 88
// if not ( 3 in list_of_q ) then
17908: LD_INT 3
17910: PUSH
17911: LD_VAR 0 2
17915: IN
17916: NOT
17917: IFFALSE 17933
// Say ( Powell , D2Rus-Pow-2 ) else
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-2
17926: PPUSH
17927: CALL_OW 88
17931: GO 17945
// Say ( Powell , D2Rus-Pow-2a ) ;
17933: LD_EXP 58
17937: PPUSH
17938: LD_STRING D2Rus-Pow-2a
17940: PPUSH
17941: CALL_OW 88
// end ; 3 :
17945: GO 18214
17947: LD_INT 3
17949: DOUBLE
17950: EQUAL
17951: IFTRUE 17955
17953: GO 18040
17955: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17956: LD_EXP 39
17960: PPUSH
17961: LD_STRING D2Leg-JMM-1
17963: PPUSH
17964: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Leg-Pow-1
17975: PPUSH
17976: CALL_OW 88
// if 2 in list_of_q then
17980: LD_INT 2
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: IFFALSE 18014
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17990: LD_EXP 39
17994: PPUSH
17995: LD_STRING D2Leg-JMM-2
17997: PPUSH
17998: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18002: LD_EXP 58
18006: PPUSH
18007: LD_STRING D2Leg-Pow-2
18009: PPUSH
18010: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18014: LD_EXP 39
18018: PPUSH
18019: LD_STRING D2Leg-JMM-3
18021: PPUSH
18022: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Leg-Pow-3
18033: PPUSH
18034: CALL_OW 88
// end ; 4 :
18038: GO 18214
18040: LD_INT 4
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18123
18048: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Ar-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Ar-Pow-1
18068: PPUSH
18069: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18073: LD_EXP 39
18077: PPUSH
18078: LD_STRING D2Ar-JMM-2
18080: PPUSH
18081: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18085: LD_EXP 58
18089: PPUSH
18090: LD_STRING D2Ar-Pow-2
18092: PPUSH
18093: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18097: LD_EXP 39
18101: PPUSH
18102: LD_STRING D2Ar-JMM-3
18104: PPUSH
18105: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18109: LD_EXP 58
18113: PPUSH
18114: LD_STRING D2Ar-Pow-3
18116: PPUSH
18117: CALL_OW 88
// end ; 5 :
18121: GO 18214
18123: LD_INT 5
18125: DOUBLE
18126: EQUAL
18127: IFTRUE 18131
18129: GO 18146
18131: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Conf-JMM-1
18139: PPUSH
18140: CALL_OW 88
18144: GO 18214
18146: LD_INT 6
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18213
18154: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18155: LD_EXP 39
18159: PPUSH
18160: LD_STRING D2Com-JMM-1
18162: PPUSH
18163: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18167: LD_EXP 58
18171: PPUSH
18172: LD_STRING D2Com-Pow-1
18174: PPUSH
18175: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18179: LD_EXP 39
18183: PPUSH
18184: LD_STRING D2Com-JMM-2
18186: PPUSH
18187: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18191: LD_EXP 58
18195: PPUSH
18196: LD_STRING D2Com-Pow-2
18198: PPUSH
18199: CALL_OW 88
// powellAngerQuery := true ;
18203: LD_ADDR_EXP 36
18207: PUSH
18208: LD_INT 1
18210: ST_TO_ADDR
// end ; end ;
18211: GO 18214
18213: POP
// end ;
18214: LD_VAR 0 3
18218: RET
// every 0 0$5 trigger missionStart do var tmp ;
18219: LD_EXP 13
18223: IFFALSE 18506
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18231: LD_INT 35
18233: PPUSH
18234: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18238: LD_INT 14
18240: PPUSH
18241: LD_INT 22
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 70
18255: PUSH
18256: LD_EXP 15
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 3
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: AND
18280: IFFALSE 18496
// begin powellAnger := powellAnger + 1 ;
18282: LD_ADDR_EXP 17
18286: PUSH
18287: LD_EXP 17
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// Video ( true ) ;
18296: LD_INT 1
18298: PPUSH
18299: CALL 101172 0 1
// CenterNowOnUnits ( tmp ) ;
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18312: LD_INT 14
18314: PPUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 1
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 70
18329: PPUSH
18330: LD_INT 86
18332: PPUSH
18333: LD_INT 133
18335: PPUSH
18336: CALL_OW 111
// async ;
18340: ASYNC
// case powellAnger of 1 :
18341: LD_EXP 17
18345: PUSH
18346: LD_INT 1
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18369
18354: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18355: LD_EXP 58
18359: PPUSH
18360: LD_STRING DBack1-Pow-1
18362: PPUSH
18363: CALL_OW 88
18367: GO 18416
18369: LD_INT 2
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18392
18377: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18378: LD_EXP 58
18382: PPUSH
18383: LD_STRING DBack2-Pow-1
18385: PPUSH
18386: CALL_OW 88
18390: GO 18416
18392: LD_INT 3
18394: DOUBLE
18395: EQUAL
18396: IFTRUE 18400
18398: GO 18415
18400: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18401: LD_EXP 58
18405: PPUSH
18406: LD_STRING DBack3-Pow-1
18408: PPUSH
18409: CALL_OW 88
18413: GO 18416
18415: POP
// sync ;
18416: SYNC
// repeat wait ( 0 0$1 ) ;
18417: LD_INT 35
18419: PPUSH
18420: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18424: LD_INT 14
18426: PPUSH
18427: LD_INT 22
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL_OW 70
18441: PPUSH
18442: LD_INT 86
18444: PPUSH
18445: LD_INT 133
18447: PPUSH
18448: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18452: LD_INT 14
18454: PPUSH
18455: LD_INT 22
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PPUSH
18465: CALL_OW 70
18469: NOT
18470: IFFALSE 18417
// if powellAnger >= 3 then
18472: LD_EXP 17
18476: PUSH
18477: LD_INT 3
18479: GREATEREQUAL
18480: IFFALSE 18489
// YouLost ( Dismissed ) ;
18482: LD_STRING Dismissed
18484: PPUSH
18485: CALL_OW 104
// Video ( false ) ;
18489: LD_INT 0
18491: PPUSH
18492: CALL 101172 0 1
// end ; until missionStage > 5 ;
18496: LD_EXP 15
18500: PUSH
18501: LD_INT 5
18503: GREATER
18504: IFFALSE 18231
// end ;
18506: PPOPN 1
18508: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18509: LD_EXP 13
18513: PUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 21
18526: PUSH
18527: LD_INT 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PPUSH
18538: CALL_OW 69
18542: PUSH
18543: LD_INT 4
18545: GREATEREQUAL
18546: AND
18547: PUSH
18548: LD_EXP 15
18552: PUSH
18553: LD_INT 2
18555: EQUAL
18556: AND
18557: IFFALSE 20380
18559: GO 18561
18561: DISABLE
18562: LD_INT 0
18564: PPUSH
18565: PPUSH
18566: PPUSH
18567: PPUSH
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// begin missionStage := 3 ;
18572: LD_ADDR_EXP 15
18576: PUSH
18577: LD_INT 3
18579: ST_TO_ADDR
// retreat := false ;
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18588: LD_ADDR_VAR 0 5
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18622: LD_ADDR_VAR 0 6
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 5
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: ST_TO_ADDR
// if not bar then
18656: LD_VAR 0 6
18660: NOT
18661: IFFALSE 18714
// begin repeat wait ( 0 0$1 ) ;
18663: LD_INT 35
18665: PPUSH
18666: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18670: LD_INT 22
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 3
18682: PUSH
18683: LD_INT 57
18685: PUSH
18686: EMPTY
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 30
18695: PUSH
18696: LD_INT 5
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL_OW 69
18712: IFFALSE 18663
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18714: LD_ADDR_VAR 0 6
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 4
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 5
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL_OW 69
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18755: LD_EXP 132
18759: PUSH
18760: LD_INT 4
18762: ARRAY
18763: PUSH
18764: LD_INT 4
18766: GREATEREQUAL
18767: IFFALSE 18748
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18769: LD_ADDR_VAR 0 2
18773: PUSH
18774: LD_INT 22
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: LD_INT 2
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 1
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: LD_INT 25
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: LD_INT 25
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 25
18819: PUSH
18820: LD_INT 4
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 25
18829: PUSH
18830: LD_INT 5
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL_OW 69
18853: PUSH
18854: LD_EXP 58
18858: PUSH
18859: LD_EXP 59
18863: ADD
18864: DIFF
18865: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 2
18875: PPUSH
18876: LD_INT 26
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 72
18890: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_VAR 0 2
18900: PUSH
18901: LD_VAR 0 3
18905: DIFF
18906: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18907: LD_ADDR_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: LD_INT 1
18919: PPUSH
18920: CALL 99706 0 2
18924: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18925: LD_ADDR_VAR 0 3
18929: PUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: CALL 99706 0 2
18942: ST_TO_ADDR
// for i = 1 to 4 do
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: DOUBLE
18949: LD_INT 1
18951: DEC
18952: ST_TO_ADDR
18953: LD_INT 4
18955: PUSH
18956: FOR_TO
18957: IFFALSE 19123
// begin if tmp2 then
18959: LD_VAR 0 3
18963: IFFALSE 19044
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18965: LD_ADDR_EXP 18
18969: PUSH
18970: LD_EXP 18
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: LD_EXP 18
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PUSH
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: ARRAY
18997: ADD
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19004: LD_VAR 0 3
19008: PUSH
19009: LD_VAR 0 3
19013: ARRAY
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_VAR 0 3
19031: PPUSH
19032: LD_VAR 0 3
19036: PPUSH
19037: CALL_OW 3
19041: ST_TO_ADDR
// end else
19042: GO 19121
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19044: LD_ADDR_EXP 18
19048: PUSH
19049: LD_EXP 18
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: LD_EXP 18
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: ADD
19077: PPUSH
19078: CALL_OW 1
19082: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19083: LD_VAR 0 2
19087: PUSH
19088: LD_VAR 0 2
19092: ARRAY
19093: PPUSH
19094: LD_INT 1
19096: PPUSH
19097: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19101: LD_ADDR_VAR 0 2
19105: PUSH
19106: LD_VAR 0 2
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 3
19120: ST_TO_ADDR
// end ; end ;
19121: GO 18956
19123: POP
19124: POP
// if tmp2 then
19125: LD_VAR 0 3
19129: IFFALSE 19147
// tmp := tmp union tmp2 ;
19131: LD_ADDR_VAR 0 2
19135: PUSH
19136: LD_VAR 0 2
19140: PUSH
19141: LD_VAR 0 3
19145: UNION
19146: ST_TO_ADDR
// for i = 1 to 4 do
19147: LD_ADDR_VAR 0 1
19151: PUSH
19152: DOUBLE
19153: LD_INT 1
19155: DEC
19156: ST_TO_ADDR
19157: LD_INT 4
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19210
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19163: LD_ADDR_EXP 18
19167: PUSH
19168: LD_EXP 18
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: LD_EXP 18
19180: PUSH
19181: LD_INT 2
19183: ARRAY
19184: PUSH
19185: LD_VAR 0 2
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 1
19199: MINUS
19200: ARRAY
19201: ADD
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
19208: GO 19160
19210: POP
19211: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19212: LD_ADDR_EXP 113
19216: PUSH
19217: LD_EXP 113
19221: PPUSH
19222: LD_INT 4
19224: PPUSH
19225: LD_EXP 113
19229: PUSH
19230: LD_INT 4
19232: ARRAY
19233: PUSH
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: DIFF
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19249: LD_VAR 0 5
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: CALL_OW 313
19262: IFFALSE 19317
// begin for i in UnitsInside ( arm [ 1 ] ) do
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_VAR 0 5
19273: PUSH
19274: LD_INT 1
19276: ARRAY
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19315
// begin ComExitBuilding ( i ) ;
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 6
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 180
// end ;
19313: GO 19283
19315: POP
19316: POP
// end ; wait ( 0 0$3 ) ;
19317: LD_INT 105
19319: PPUSH
19320: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_EXP 18
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19446
// begin if IsInUnit ( i ) then
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 310
19350: IFFALSE 19361
// ComExitBuilding ( i ) ;
19352: LD_VAR 0 1
19356: PPUSH
19357: CALL_OW 122
// if GetClass ( i ) <> 1 then
19361: LD_VAR 0 1
19365: PPUSH
19366: CALL_OW 257
19370: PUSH
19371: LD_INT 1
19373: NONEQUAL
19374: IFFALSE 19415
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19376: LD_VAR 0 1
19380: PPUSH
19381: LD_VAR 0 5
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19394: LD_VAR 0 1
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 183
// AddComExitBuilding ( i ) ;
19406: LD_VAR 0 1
19410: PPUSH
19411: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19415: LD_VAR 0 1
19419: PPUSH
19420: LD_INT 60
19422: PPUSH
19423: LD_INT 94
19425: PPUSH
19426: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_EXP 58
19439: PPUSH
19440: CALL_OW 179
// end ;
19444: GO 19338
19446: POP
19447: POP
// wait ( 0 0$15 ) ;
19448: LD_INT 525
19450: PPUSH
19451: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19455: LD_EXP 58
19459: PPUSH
19460: LD_STRING D4-Pow-1
19462: PPUSH
19463: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19467: LD_ADDR_VAR 0 2
19471: PUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: LD_INT 26
19483: PUSH
19484: LD_INT 1
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PPUSH
19491: CALL_OW 72
19495: ST_TO_ADDR
// if tmp then
19496: LD_VAR 0 2
19500: IFFALSE 19518
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_STRING D4-Sol1-1
19513: PPUSH
19514: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19518: LD_EXP 58
19522: PPUSH
19523: LD_STRING D4-Pow-2
19525: PPUSH
19526: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19530: LD_ADDR_VAR 0 1
19534: PUSH
19535: DOUBLE
19536: LD_INT 1
19538: DEC
19539: ST_TO_ADDR
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PUSH
19549: FOR_TO
19550: IFFALSE 19643
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PPUSH
19567: LD_EXP 132
19571: PUSH
19572: LD_INT 4
19574: ARRAY
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19584: LD_ADDR_EXP 132
19588: PUSH
19589: LD_EXP 132
19593: PPUSH
19594: LD_INT 4
19596: PPUSH
19597: LD_EXP 132
19601: PUSH
19602: LD_INT 4
19604: ARRAY
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: CALL_OW 3
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19619: LD_INT 8
19621: PPUSH
19622: LD_EXP 18
19626: PUSH
19627: LD_INT 1
19629: ARRAY
19630: PUSH
19631: LD_VAR 0 1
19635: ARRAY
19636: PPUSH
19637: CALL_OW 471
// end ;
19641: GO 19549
19643: POP
19644: POP
// repeat wait ( 0 0$1 ) ;
19645: LD_INT 35
19647: PPUSH
19648: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 55
19663: PUSH
19664: EMPTY
19665: LIST
19666: PPUSH
19667: CALL_OW 72
19671: PUSH
19672: LD_INT 4
19674: GREATEREQUAL
19675: IFFALSE 19645
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19677: LD_EXP 18
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: PPUSH
19686: LD_INT 69
19688: PPUSH
19689: LD_INT 94
19691: PPUSH
19692: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19696: LD_EXP 18
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: LD_INT 82
19707: PPUSH
19708: LD_INT 83
19710: PPUSH
19711: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: LD_INT 77
19726: PPUSH
19727: LD_INT 69
19729: PPUSH
19730: CALL_OW 174
// repeat wait ( 3 ) ;
19734: LD_INT 3
19736: PPUSH
19737: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_EXP 18
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: FOR_IN
19756: IFFALSE 19892
// begin if GetLives ( i ) < 990 then
19758: LD_VAR 0 1
19762: PPUSH
19763: CALL_OW 256
19767: PUSH
19768: LD_INT 990
19770: LESS
19771: IFFALSE 19785
// SetLives ( i , 1000 ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: LD_INT 1000
19780: PPUSH
19781: CALL_OW 234
// if not IsInUnit ( i ) then
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 310
19794: NOT
19795: IFFALSE 19890
// begin if not HasTask ( i ) then
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 314
19806: NOT
19807: IFFALSE 19824
// ComMoveXY ( i , 64 , 93 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 64
19816: PPUSH
19817: LD_INT 93
19819: PPUSH
19820: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19824: LD_VAR 0 4
19828: NOT
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 258
19839: PUSH
19840: LD_INT 1
19842: EQUAL
19843: AND
19844: IFFALSE 19890
// begin retreat := true ;
19846: LD_ADDR_VAR 0 4
19850: PUSH
19851: LD_INT 1
19853: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: LD_INT 2
19861: PPUSH
19862: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_STRING D4a-Sol1-1
19873: PPUSH
19874: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19878: LD_EXP 58
19882: PPUSH
19883: LD_STRING D4a-Pow-1
19885: PPUSH
19886: CALL_OW 88
// end ; end ; end ;
19890: GO 19755
19892: POP
19893: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19894: LD_EXP 18
19898: PUSH
19899: LD_INT 1
19901: ARRAY
19902: PPUSH
19903: LD_INT 95
19905: PUSH
19906: LD_INT 9
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 3
19915: PUSH
19916: LD_INT 55
19918: PUSH
19919: EMPTY
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PPUSH
19930: CALL_OW 72
19934: PUSH
19935: LD_INT 4
19937: GREATEREQUAL
19938: IFFALSE 19734
// for i in powellSquadAttack [ 1 ] do
19940: LD_ADDR_VAR 0 1
19944: PUSH
19945: LD_EXP 18
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20091
// begin if GetTag ( i ) = 2 then
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 110
19966: PUSH
19967: LD_INT 2
19969: EQUAL
19970: IFFALSE 20032
// begin ComMoveXY ( i , 60 , 94 ) ;
19972: LD_VAR 0 1
19976: PPUSH
19977: LD_INT 60
19979: PPUSH
19980: LD_INT 94
19982: PPUSH
19983: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_EXP 58
19996: PPUSH
19997: CALL_OW 179
// wait ( 0 0$3 ) ;
20001: LD_INT 105
20003: PPUSH
20004: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_STRING D4a-Sol1-2
20015: PPUSH
20016: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20020: LD_EXP 58
20024: PPUSH
20025: LD_STRING D4a-Pow-2
20027: PPUSH
20028: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20032: LD_VAR 0 1
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20044: LD_ADDR_EXP 113
20048: PUSH
20049: LD_EXP 113
20053: PPUSH
20054: LD_INT 4
20056: PPUSH
20057: LD_EXP 113
20061: PUSH
20062: LD_INT 4
20064: ARRAY
20065: PUSH
20066: LD_VAR 0 1
20070: UNION
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20077: LD_INT 8
20079: PPUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 472
// end ;
20089: GO 19954
20091: POP
20092: POP
// wait ( 4 4$00 ) ;
20093: LD_INT 8400
20095: PPUSH
20096: CALL_OW 67
// uc_side := 6 ;
20100: LD_ADDR_OWVAR 20
20104: PUSH
20105: LD_INT 6
20107: ST_TO_ADDR
// uc_nation := 3 ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 3
20115: ST_TO_ADDR
// ru := [ ] ;
20116: LD_ADDR_VAR 0 7
20120: PUSH
20121: EMPTY
20122: ST_TO_ADDR
// for i = 1 to 4 do
20123: LD_ADDR_VAR 0 1
20127: PUSH
20128: DOUBLE
20129: LD_INT 1
20131: DEC
20132: ST_TO_ADDR
20133: LD_INT 4
20135: PUSH
20136: FOR_TO
20137: IFFALSE 20238
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20139: LD_INT 22
20141: PPUSH
20142: LD_INT 1
20144: PPUSH
20145: LD_INT 3
20147: PPUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_INT 2
20163: PPUSH
20164: CALL_OW 12
20168: ARRAY
20169: PPUSH
20170: LD_INT 89
20172: PPUSH
20173: CALL 70035 0 5
// un := CreateVehicle ;
20177: LD_ADDR_VAR 0 8
20181: PUSH
20182: CALL_OW 45
20186: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20187: LD_VAR 0 8
20191: PPUSH
20192: LD_INT 4
20194: PPUSH
20195: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20199: LD_VAR 0 8
20203: PPUSH
20204: LD_INT 136
20206: PPUSH
20207: LD_INT 90
20209: PPUSH
20210: LD_INT 8
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL_OW 50
// ru := ru ^ un ;
20220: LD_ADDR_VAR 0 7
20224: PUSH
20225: LD_VAR 0 7
20229: PUSH
20230: LD_VAR 0 8
20234: ADD
20235: ST_TO_ADDR
// end ;
20236: GO 20136
20238: POP
20239: POP
// if ru then
20240: LD_VAR 0 7
20244: IFFALSE 20261
// ComAgressiveMove ( ru , 80 , 92 ) ;
20246: LD_VAR 0 7
20250: PPUSH
20251: LD_INT 80
20253: PPUSH
20254: LD_INT 92
20256: PPUSH
20257: CALL_OW 114
// wait ( 8 8$00 ) ;
20261: LD_INT 16800
20263: PPUSH
20264: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20268: LD_INT 4
20270: PPUSH
20271: LD_INT 3
20273: PUSH
20274: LD_INT 1
20276: PUSH
20277: LD_INT 1
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 4
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 6
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 1
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 3
20327: PUSH
20328: LD_INT 1
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: LD_INT 7
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: PPUSH
20368: CALL 58800 0 2
// missionStage := 4 ;
20372: LD_ADDR_EXP 15
20376: PUSH
20377: LD_INT 4
20379: ST_TO_ADDR
// end ;
20380: PPOPN 8
20382: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20383: LD_EXP 15
20387: PUSH
20388: LD_INT 4
20390: EQUAL
20391: PUSH
20392: LD_INT 22
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 21
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL_OW 69
20420: PUSH
20421: LD_INT 5
20423: GREATEREQUAL
20424: AND
20425: IFFALSE 24530
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
20434: PPUSH
20435: PPUSH
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin missionStage := 5 ;
20445: LD_ADDR_EXP 15
20449: PUSH
20450: LD_INT 5
20452: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20453: LD_ADDR_VAR 0 10
20457: PUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 30
20473: PUSH
20474: LD_INT 4
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 30
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 4
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 21
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PUSH
20530: LD_INT 3
20532: PUSH
20533: LD_INT 25
20535: PUSH
20536: LD_INT 16
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 3
20549: PUSH
20550: LD_INT 25
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 58
20579: DIFF
20580: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 4
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20619: LD_INT 35
20621: PPUSH
20622: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20626: LD_EXP 132
20630: PUSH
20631: LD_INT 4
20633: ARRAY
20634: PUSH
20635: LD_INT 5
20637: GREATEREQUAL
20638: PUSH
20639: LD_EXP 132
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PPUSH
20648: LD_INT 58
20650: PUSH
20651: EMPTY
20652: LIST
20653: PPUSH
20654: CALL_OW 72
20658: PUSH
20659: LD_INT 5
20661: GREATEREQUAL
20662: AND
20663: IFFALSE 20619
// powellAllowRetreat := false ;
20665: LD_ADDR_EXP 19
20669: PUSH
20670: LD_INT 0
20672: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20673: LD_INT 700
20675: PPUSH
20676: CALL_OW 67
// activeAttacks := false ;
20680: LD_ADDR_EXP 16
20684: PUSH
20685: LD_INT 0
20687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20688: LD_INT 35
20690: PPUSH
20691: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20695: LD_INT 22
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: PUSH
20710: LD_INT 0
20712: EQUAL
20713: IFFALSE 20688
// tmp := mc_vehicles [ 4 ] ;
20715: LD_ADDR_VAR 0 3
20719: PUSH
20720: LD_EXP 132
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20729: LD_ADDR_VAR 0 1
20733: PUSH
20734: DOUBLE
20735: LD_INT 1
20737: DEC
20738: ST_TO_ADDR
20739: LD_EXP 18
20743: PUSH
20744: FOR_TO
20745: IFFALSE 21006
// begin for j in powellSquadAttack [ i ] do
20747: LD_ADDR_VAR 0 2
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_VAR 0 1
20761: ARRAY
20762: PUSH
20763: FOR_IN
20764: IFFALSE 21002
// begin forces := forces diff j ;
20766: LD_ADDR_VAR 0 6
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_VAR 0 2
20780: DIFF
20781: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20782: LD_VAR 0 2
20786: PPUSH
20787: LD_INT 1
20789: PPUSH
20790: CALL_OW 109
// wait ( 0 0$2 ) ;
20794: LD_INT 70
20796: PPUSH
20797: CALL_OW 67
// if IsInUnit ( j ) then
20801: LD_VAR 0 2
20805: PPUSH
20806: CALL_OW 310
20810: IFFALSE 20821
// ComExitBuilding ( j ) ;
20812: LD_VAR 0 2
20816: PPUSH
20817: CALL_OW 122
// if GetClass ( j ) <> 1 then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 257
20830: PUSH
20831: LD_INT 1
20833: NONEQUAL
20834: IFFALSE 20914
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20836: LD_VAR 0 10
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: PPUSH
20845: CALL_OW 313
20849: PUSH
20850: LD_INT 5
20852: GREATEREQUAL
20853: IFFALSE 20875
// AddComEnterUnit ( j , arm [ 2 ] ) else
20855: LD_VAR 0 2
20859: PPUSH
20860: LD_VAR 0 10
20864: PUSH
20865: LD_INT 2
20867: ARRAY
20868: PPUSH
20869: CALL_OW 180
20873: GO 20893
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20875: LD_VAR 0 2
20879: PPUSH
20880: LD_VAR 0 10
20884: PUSH
20885: LD_INT 1
20887: ARRAY
20888: PPUSH
20889: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 183
// AddComExitBuilding ( j ) ;
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 182
// end ; if i = 2 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 2
20921: EQUAL
20922: IFFALSE 20939
// AddComMoveXY ( j , 61 , 93 ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 61
20931: PPUSH
20932: LD_INT 93
20934: PPUSH
20935: CALL_OW 171
// if i = 1 then
20939: LD_VAR 0 1
20943: PUSH
20944: LD_INT 1
20946: EQUAL
20947: IFFALSE 21000
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_VAR 0 3
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 3
20984: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: LD_INT 69
20992: PPUSH
20993: LD_INT 94
20995: PPUSH
20996: CALL_OW 171
// end ; end ;
21000: GO 20763
21002: POP
21003: POP
// end ;
21004: GO 20744
21006: POP
21007: POP
// wait ( 0 0$55 ) ;
21008: LD_INT 1925
21010: PPUSH
21011: CALL_OW 67
// MC_Kill ( 4 ) ;
21015: LD_INT 4
21017: PPUSH
21018: CALL 35356 0 1
// tmp := UnitsInside ( fac ) ;
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_VAR 0 9
21031: PPUSH
21032: CALL_OW 313
21036: ST_TO_ADDR
// if tmp then
21037: LD_VAR 0 3
21041: IFFALSE 21162
// for i in tmp do
21043: LD_ADDR_VAR 0 1
21047: PUSH
21048: LD_VAR 0 3
21052: PUSH
21053: FOR_IN
21054: IFFALSE 21160
// begin ComExitBuilding ( i ) ;
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21065: LD_VAR 0 10
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: CALL_OW 313
21078: PUSH
21079: LD_INT 6
21081: LESS
21082: IFFALSE 21104
// AddComEnterUnit ( i , arm [ 2 ] ) else
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 10
21093: PUSH
21094: LD_INT 2
21096: ARRAY
21097: PPUSH
21098: CALL_OW 180
21102: GO 21158
// if UnitsInside ( arm [ 1 ] ) < 6 then
21104: LD_VAR 0 10
21108: PUSH
21109: LD_INT 1
21111: ARRAY
21112: PPUSH
21113: CALL_OW 313
21117: PUSH
21118: LD_INT 6
21120: LESS
21121: IFFALSE 21143
// AddComEnterUnit ( i , arm [ 1 ] ) else
21123: LD_VAR 0 1
21127: PPUSH
21128: LD_VAR 0 10
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: CALL_OW 180
21141: GO 21158
// AddComMoveXY ( i , 37 , 68 ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_INT 37
21150: PPUSH
21151: LD_INT 68
21153: PPUSH
21154: CALL_OW 171
// end ;
21158: GO 21053
21160: POP
21161: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 6
21171: PPUSH
21172: LD_INT 26
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 72
21186: PUSH
21187: LD_EXP 59
21191: DIFF
21192: ST_TO_ADDR
// if not speaker then
21193: LD_VAR 0 11
21197: NOT
21198: IFFALSE 21225
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21200: LD_ADDR_VAR 0 11
21204: PUSH
21205: LD_VAR 0 6
21209: PPUSH
21210: LD_INT 26
21212: PUSH
21213: LD_INT 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 72
21224: ST_TO_ADDR
// if speaker then
21225: LD_VAR 0 11
21229: IFFALSE 21245
// speaker := speaker [ 1 ] ;
21231: LD_ADDR_VAR 0 11
21235: PUSH
21236: LD_VAR 0 11
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: ST_TO_ADDR
// Video ( true ) ;
21245: LD_INT 1
21247: PPUSH
21248: CALL 101172 0 1
// CenterNowOnUnits ( Powell ) ;
21252: LD_EXP 58
21256: PPUSH
21257: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21261: LD_ADDR_VAR 0 3
21265: PUSH
21266: LD_VAR 0 6
21270: PPUSH
21271: LD_INT 3
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 72
21292: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21293: LD_ADDR_VAR 0 12
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_INT 4
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 32
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 58
21320: PUSH
21321: EMPTY
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: PPUSH
21329: CALL_OW 69
21333: ST_TO_ADDR
// for i = 1 to 6 do
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: DOUBLE
21340: LD_INT 1
21342: DEC
21343: ST_TO_ADDR
21344: LD_INT 6
21346: PUSH
21347: FOR_TO
21348: IFFALSE 21489
// begin if IsInUnit ( tmp [ i ] ) then
21350: LD_VAR 0 3
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 310
21365: IFFALSE 21382
// ComExitBuilding ( tmp [ i ] ) ;
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: ARRAY
21377: PPUSH
21378: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21382: LD_VAR 0 3
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 10
21397: PUSH
21398: LD_INT 1
21400: ARRAY
21401: PPUSH
21402: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21406: LD_VAR 0 3
21410: PUSH
21411: LD_VAR 0 1
21415: ARRAY
21416: PPUSH
21417: LD_INT 1
21419: PPUSH
21420: CALL_OW 183
// if emp_towers then
21424: LD_VAR 0 12
21428: IFFALSE 21487
// begin AddComExitBuilding ( tmp [ i ] ) ;
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 1
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 12
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PPUSH
21465: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21469: LD_ADDR_VAR 0 12
21473: PUSH
21474: LD_VAR 0 12
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 3
21486: ST_TO_ADDR
// end ; end ;
21487: GO 21347
21489: POP
21490: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21491: LD_ADDR_VAR 0 3
21495: PUSH
21496: LD_EXP 18
21500: PUSH
21501: LD_INT 1
21503: ARRAY
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 2
21512: ARRAY
21513: ADD
21514: PPUSH
21515: LD_INT 26
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 72
21529: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21530: LD_ADDR_VAR 0 1
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 2
21542: ARRAY
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21563
// ComTurnUnit ( i , Powell ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_EXP 58
21556: PPUSH
21557: CALL_OW 119
21561: GO 21544
21563: POP
21564: POP
// Say ( Powell , D5-Pow-1 ) ;
21565: LD_EXP 58
21569: PPUSH
21570: LD_STRING D5-Pow-1
21572: PPUSH
21573: CALL_OW 88
// if tmp then
21577: LD_VAR 0 3
21581: IFFALSE 21599
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21583: LD_VAR 0 3
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_STRING D5-Sol2-1
21594: PPUSH
21595: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21599: LD_EXP 58
21603: PPUSH
21604: LD_STRING D5-Pow-2
21606: PPUSH
21607: CALL_OW 88
// if tmp > 1 then
21611: LD_VAR 0 3
21615: PUSH
21616: LD_INT 1
21618: GREATER
21619: IFFALSE 21637
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 2
21628: ARRAY
21629: PPUSH
21630: LD_STRING D5-Sol2-2
21632: PPUSH
21633: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-3
21644: PPUSH
21645: CALL_OW 88
// wait ( 0 0$1 ) ;
21649: LD_INT 35
21651: PPUSH
21652: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_EXP 18
21674: PUSH
21675: LD_INT 2
21677: ARRAY
21678: UNION
21679: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21680: LD_VAR 0 3
21684: PPUSH
21685: LD_INT 80
21687: PPUSH
21688: LD_INT 67
21690: PPUSH
21691: CALL_OW 114
// wait ( 0 0$2 ) ;
21695: LD_INT 70
21697: PPUSH
21698: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21702: LD_INT 79
21704: PPUSH
21705: LD_INT 72
21707: PPUSH
21708: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21712: LD_INT 35
21714: PPUSH
21715: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21719: LD_VAR 0 3
21723: PPUSH
21724: LD_INT 3
21726: PUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1000
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: CALL_OW 72
21745: IFFALSE 21712
// Say ( Powell , D5a-Pow-1 ) ;
21747: LD_EXP 58
21751: PPUSH
21752: LD_STRING D5a-Pow-1
21754: PPUSH
21755: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21759: LD_EXP 58
21763: PPUSH
21764: LD_STRING D5a-Pow-1a
21766: PPUSH
21767: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21771: LD_INT 10
21773: PPUSH
21774: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21778: LD_EXP 58
21782: PPUSH
21783: LD_STRING D5a-Pow-1b
21785: PPUSH
21786: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21790: LD_EXP 58
21794: PPUSH
21795: LD_STRING D5a-Pow-1c
21797: PPUSH
21798: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21802: LD_EXP 58
21806: PPUSH
21807: LD_STRING D5a-Pow-1d
21809: PPUSH
21810: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21814: LD_INT 35
21816: PPUSH
21817: CALL_OW 67
// if not HasTask ( tmp ) then
21821: LD_VAR 0 3
21825: PPUSH
21826: CALL_OW 314
21830: NOT
21831: IFFALSE 21848
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 80
21840: PPUSH
21841: LD_INT 67
21843: PPUSH
21844: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21848: LD_VAR 0 3
21852: PPUSH
21853: LD_INT 24
21855: PUSH
21856: LD_INT 1
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 72
21867: NOT
21868: IFFALSE 21814
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_INT 22
21877: PUSH
21878: LD_INT 4
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 92
21887: PUSH
21888: LD_INT 60
21890: PUSH
21891: LD_INT 93
21893: PUSH
21894: LD_INT 10
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 3
21905: PUSH
21906: LD_INT 54
21908: PUSH
21909: EMPTY
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 69
21925: PUSH
21926: LD_EXP 58
21930: DIFF
21931: ST_TO_ADDR
// if tmp then
21932: LD_VAR 0 3
21936: IFFALSE 21970
// for i in tmp do
21938: LD_ADDR_VAR 0 1
21942: PUSH
21943: LD_VAR 0 3
21947: PUSH
21948: FOR_IN
21949: IFFALSE 21968
// ComMoveXY ( i , 36 , 67 ) ;
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 36
21958: PPUSH
21959: LD_INT 67
21961: PPUSH
21962: CALL_OW 111
21966: GO 21948
21968: POP
21969: POP
// wait ( 0 0$3 ) ;
21970: LD_INT 105
21972: PPUSH
21973: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21977: LD_VAR 0 11
21981: PPUSH
21982: LD_STRING D6-Sol3-1
21984: PPUSH
21985: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21989: LD_EXP 58
21993: PPUSH
21994: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21998: LD_EXP 58
22002: PPUSH
22003: LD_STRING D6-Pow-1
22005: PPUSH
22006: CALL_OW 88
// tmp := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// for i = 1 to 2 do
22017: LD_ADDR_VAR 0 1
22021: PUSH
22022: DOUBLE
22023: LD_INT 1
22025: DEC
22026: ST_TO_ADDR
22027: LD_INT 2
22029: PUSH
22030: FOR_TO
22031: IFFALSE 22145
// begin uc_side := 8 ;
22033: LD_ADDR_OWVAR 20
22037: PUSH
22038: LD_INT 8
22040: ST_TO_ADDR
// uc_nation := 2 ;
22041: LD_ADDR_OWVAR 21
22045: PUSH
22046: LD_INT 2
22048: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22049: LD_INT 14
22051: PPUSH
22052: LD_INT 3
22054: PPUSH
22055: LD_INT 2
22057: PPUSH
22058: LD_INT 29
22060: PPUSH
22061: LD_INT 100
22063: PPUSH
22064: CALL 70035 0 5
// veh := CreateVehicle ;
22068: LD_ADDR_VAR 0 13
22072: PUSH
22073: CALL_OW 45
22077: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: LD_INT 4
22085: PPUSH
22086: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22090: LD_VAR 0 13
22094: PPUSH
22095: LD_INT 99
22097: PPUSH
22098: LD_INT 83
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: LD_INT 0
22106: PPUSH
22107: CALL_OW 50
// wait ( 3 ) ;
22111: LD_INT 3
22113: PPUSH
22114: CALL_OW 67
// Connect ( veh ) ;
22118: LD_VAR 0 13
22122: PPUSH
22123: CALL 73090 0 1
// tmp := tmp ^ veh ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_VAR 0 3
22136: PUSH
22137: LD_VAR 0 13
22141: ADD
22142: ST_TO_ADDR
// end ;
22143: GO 22030
22145: POP
22146: POP
// wait ( 0 0$1 ) ;
22147: LD_INT 35
22149: PPUSH
22150: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22154: LD_INT 99
22156: PPUSH
22157: LD_INT 83
22159: PPUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_INT 10
22165: PPUSH
22166: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22170: LD_INT 99
22172: PPUSH
22173: LD_INT 83
22175: PPUSH
22176: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22180: LD_VAR 0 11
22184: PPUSH
22185: LD_STRING D6-Sol3-2
22187: PPUSH
22188: CALL_OW 88
// async ;
22192: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22193: LD_EXP 58
22197: PPUSH
22198: LD_STRING D6-Pow-2
22200: PPUSH
22201: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22205: LD_VAR 0 3
22209: PUSH
22210: LD_INT 1
22212: ARRAY
22213: PPUSH
22214: LD_VAR 0 9
22218: PPUSH
22219: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22223: LD_VAR 0 3
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PPUSH
22232: LD_INT 22
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 21
22244: PUSH
22245: LD_INT 3
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 69
22260: PPUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PPUSH
22270: CALL_OW 74
22274: PPUSH
22275: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22279: LD_EXP 58
22283: PPUSH
22284: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22288: LD_INT 99
22290: PPUSH
22291: LD_INT 83
22293: PPUSH
22294: LD_INT 1
22296: PPUSH
22297: CALL_OW 331
// repeat wait ( 4 ) ;
22301: LD_INT 4
22303: PPUSH
22304: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22308: LD_VAR 0 3
22312: PUSH
22313: LD_INT 1
22315: ARRAY
22316: PPUSH
22317: CALL_OW 256
22321: PUSH
22322: LD_INT 1000
22324: LESS
22325: IFFALSE 22343
// SetLives ( tmp [ 1 ] , 1000 ) ;
22327: LD_VAR 0 3
22331: PUSH
22332: LD_INT 1
22334: ARRAY
22335: PPUSH
22336: LD_INT 1000
22338: PPUSH
22339: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22343: LD_INT 22
22345: PUSH
22346: LD_INT 4
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 69
22371: PUSH
22372: LD_INT 0
22374: EQUAL
22375: IFFALSE 22301
// sync ;
22377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22378: LD_EXP 58
22382: PPUSH
22383: LD_STRING D6a-Pow-1
22385: PPUSH
22386: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22390: LD_VAR 0 11
22394: PPUSH
22395: LD_STRING D6a-Sol3-1
22397: PPUSH
22398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22402: LD_EXP 58
22406: PPUSH
22407: LD_STRING D6a-Pow-2
22409: PPUSH
22410: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_STRING D6a-Sol3-2
22421: PPUSH
22422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22426: LD_EXP 58
22430: PPUSH
22431: LD_STRING D6a-Pow-3
22433: PPUSH
22434: CALL_OW 88
// powellCenterCameraMode := true ;
22438: LD_ADDR_EXP 20
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_INT 8
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 25
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 69
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22536
// begin SetTag ( i , 1 ) ;
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: CALL_OW 109
// ComExitBuilding ( i ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22504: LD_VAR 0 1
22508: PPUSH
22509: LD_INT 35
22511: PPUSH
22512: LD_INT 6
22514: PPUSH
22515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 53
22526: PPUSH
22527: LD_INT 4
22529: PPUSH
22530: CALL_OW 171
// end ;
22534: GO 22480
22536: POP
22537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22538: LD_ADDR_VAR 0 3
22542: PUSH
22543: LD_INT 22
22545: PUSH
22546: LD_INT 4
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 21
22555: PUSH
22556: LD_INT 2
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 12
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22590: LD_EXP 58
22594: PPUSH
22595: LD_VAR 0 3
22599: PPUSH
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 74
22609: PPUSH
22610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22614: LD_EXP 58
22618: PPUSH
22619: LD_INT 100
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22629: LD_EXP 58
22633: PPUSH
22634: LD_INT 100
22636: PPUSH
22637: LD_INT 75
22639: PPUSH
22640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22644: LD_EXP 58
22648: PPUSH
22649: LD_INT 88
22651: PPUSH
22652: LD_INT 53
22654: PPUSH
22655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22659: LD_INT 8
22661: PPUSH
22662: LD_EXP 58
22666: PPUSH
22667: CALL_OW 471
// repeat wait ( 3 ) ;
22671: LD_INT 3
22673: PPUSH
22674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22678: LD_INT 22
22680: PUSH
22681: LD_INT 4
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 92
22690: PUSH
22691: LD_INT 100
22693: PUSH
22694: LD_INT 75
22696: PUSH
22697: LD_INT 6
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PPUSH
22710: CALL_OW 69
22714: IFFALSE 22671
// async ;
22716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_STRING D6b-Pow-1
22724: PPUSH
22725: CALL_OW 88
// repeat wait ( 3 ) ;
22729: LD_INT 3
22731: PPUSH
22732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22736: LD_EXP 58
22740: PPUSH
22741: CALL_OW 310
22745: PPUSH
22746: CALL_OW 256
22750: PUSH
22751: LD_INT 1000
22753: LESS
22754: IFFALSE 22773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22756: LD_EXP 58
22760: PPUSH
22761: CALL_OW 310
22765: PPUSH
22766: LD_INT 1000
22768: PPUSH
22769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22773: LD_EXP 58
22777: PPUSH
22778: CALL_OW 256
22782: PUSH
22783: LD_INT 1000
22785: LESS
22786: IFFALSE 22800
// SetLives ( Powell , 1000 ) ;
22788: LD_EXP 58
22792: PPUSH
22793: LD_INT 1000
22795: PPUSH
22796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22800: LD_EXP 58
22804: PPUSH
22805: LD_EXP 63
22809: PPUSH
22810: CALL_OW 296
22814: PUSH
22815: LD_INT 5
22817: LESS
22818: PUSH
22819: LD_EXP 58
22823: PPUSH
22824: CALL_OW 310
22828: PPUSH
22829: LD_EXP 63
22833: PPUSH
22834: CALL_OW 296
22838: PUSH
22839: LD_INT 5
22841: LESS
22842: OR
22843: IFFALSE 22862
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 310
22854: PPUSH
22855: LD_INT 100
22857: PPUSH
22858: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22862: LD_EXP 58
22866: PPUSH
22867: CALL_OW 310
22871: NOT
22872: IFFALSE 22729
// DoNotAttack ( 8 , powellBomb ) ;
22874: LD_INT 8
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 471
// game_speed := 4 ;
22886: LD_ADDR_OWVAR 65
22890: PUSH
22891: LD_INT 4
22893: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22894: LD_EXP 58
22898: PPUSH
22899: LD_STRING D6b-Pow-1a
22901: PPUSH
22902: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22906: LD_EXP 58
22910: PPUSH
22911: LD_EXP 63
22915: PPUSH
22916: CALL_OW 180
// sync ;
22920: SYNC
// repeat wait ( 0 0$1 ) ;
22921: LD_INT 35
22923: PPUSH
22924: CALL_OW 67
// until IsInUnit ( Powell ) ;
22928: LD_EXP 58
22932: PPUSH
22933: CALL_OW 310
22937: IFFALSE 22921
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22939: LD_INT 8
22941: PPUSH
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: PPUSH
22952: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 58
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22971: LD_EXP 58
22975: PPUSH
22976: LD_INT 96
22978: PPUSH
22979: LD_INT 44
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_INT 96
22993: PPUSH
22994: LD_INT 41
22996: PPUSH
22997: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23001: LD_EXP 58
23005: PPUSH
23006: LD_INT 92
23008: PPUSH
23009: LD_INT 39
23011: PPUSH
23012: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23016: LD_EXP 58
23020: PPUSH
23021: LD_INT 88
23023: PPUSH
23024: LD_INT 41
23026: PPUSH
23027: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23031: LD_EXP 58
23035: PPUSH
23036: LD_INT 91
23038: PPUSH
23039: LD_INT 44
23041: PPUSH
23042: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23046: LD_EXP 58
23050: PPUSH
23051: LD_INT 96
23053: PPUSH
23054: LD_INT 44
23056: PPUSH
23057: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23061: LD_EXP 58
23065: PPUSH
23066: LD_INT 96
23068: PPUSH
23069: LD_INT 41
23071: PPUSH
23072: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23076: LD_EXP 58
23080: PPUSH
23081: LD_INT 92
23083: PPUSH
23084: LD_INT 39
23086: PPUSH
23087: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23091: LD_EXP 58
23095: PPUSH
23096: LD_INT 88
23098: PPUSH
23099: LD_INT 41
23101: PPUSH
23102: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23106: LD_EXP 58
23110: PPUSH
23111: LD_INT 91
23113: PPUSH
23114: LD_INT 44
23116: PPUSH
23117: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23121: LD_EXP 58
23125: PPUSH
23126: LD_INT 93
23128: PPUSH
23129: LD_INT 39
23131: PPUSH
23132: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23136: LD_EXP 58
23140: PPUSH
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 36
23146: PPUSH
23147: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23151: LD_INT 122
23153: PPUSH
23154: CALL_OW 67
// game_speed := 4 ;
23158: LD_ADDR_OWVAR 65
23162: PUSH
23163: LD_INT 4
23165: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23166: LD_EXP 58
23170: PPUSH
23171: LD_STRING D6b-Pow-1b
23173: PPUSH
23174: CALL_OW 88
// tmp := [ ] ;
23178: LD_ADDR_VAR 0 3
23182: PUSH
23183: EMPTY
23184: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23185: LD_ADDR_VAR 0 5
23189: PUSH
23190: LD_INT 78
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 53
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23214: LD_ADDR_VAR 0 1
23218: PUSH
23219: LD_INT 22
23221: PUSH
23222: LD_INT 8
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 21
23231: PUSH
23232: LD_INT 3
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 92
23241: PUSH
23242: LD_INT 90
23244: PUSH
23245: LD_INT 52
23247: PUSH
23248: LD_INT 12
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23293
// tmp := tmp ^ UnitsInside ( i ) ;
23270: LD_ADDR_VAR 0 3
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 313
23289: ADD
23290: ST_TO_ADDR
23291: GO 23267
23293: POP
23294: POP
// for i in tmp do
23295: LD_ADDR_VAR 0 1
23299: PUSH
23300: LD_VAR 0 3
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23468
// begin dist := 9999 ;
23308: LD_ADDR_VAR 0 8
23312: PUSH
23313: LD_INT 9999
23315: ST_TO_ADDR
// _xy := [ ] ;
23316: LD_ADDR_VAR 0 7
23320: PUSH
23321: EMPTY
23322: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 109
// ComExitBuilding ( i ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 122
// for j in xy do
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_VAR 0 5
23353: PUSH
23354: FOR_IN
23355: IFFALSE 23437
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: PUSH
23385: LD_VAR 0 8
23389: LESS
23390: IFFALSE 23435
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23392: LD_ADDR_VAR 0 8
23396: PUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 1
23409: ARRAY
23410: PPUSH
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 2
23418: ARRAY
23419: PPUSH
23420: CALL_OW 297
23424: ST_TO_ADDR
// _xy := j ;
23425: LD_ADDR_VAR 0 7
23429: PUSH
23430: LD_VAR 0 2
23434: ST_TO_ADDR
// end ;
23435: GO 23354
23437: POP
23438: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_VAR 0 7
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 2
23460: ARRAY
23461: PPUSH
23462: CALL_OW 171
// end ;
23466: GO 23305
23468: POP
23469: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23470: LD_ADDR_VAR 0 4
23474: PUSH
23475: LD_VAR 0 3
23479: PPUSH
23480: LD_INT 26
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 1
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: ST_TO_ADDR
// if tmp2 < 2 then
23509: LD_VAR 0 4
23513: PUSH
23514: LD_INT 2
23516: LESS
23517: IFFALSE 23586
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23519: LD_ADDR_VAR 0 4
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 26
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 25
23549: PUSH
23550: LD_INT 15
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 69
23570: PUSH
23571: LD_EXP 60
23575: PUSH
23576: LD_EXP 61
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: DIFF
23585: ST_TO_ADDR
// if tmp2 then
23586: LD_VAR 0 4
23590: IFFALSE 23608
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23592: LD_VAR 0 4
23596: PUSH
23597: LD_INT 1
23599: ARRAY
23600: PPUSH
23601: LD_STRING D6b-ArSol1-1
23603: PPUSH
23604: CALL_OW 88
// async ;
23608: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23609: LD_EXP 58
23613: PPUSH
23614: LD_STRING D6b-Pow-2
23616: PPUSH
23617: CALL_OW 88
// wait ( 0 0$1 ) ;
23621: LD_INT 35
23623: PPUSH
23624: CALL_OW 67
// if tmp2 > 1 then
23628: LD_VAR 0 4
23632: PUSH
23633: LD_INT 1
23635: GREATER
23636: IFFALSE 23654
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23638: LD_VAR 0 4
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: LD_STRING D6b-ArSol2-1
23649: PPUSH
23650: CALL_OW 88
// sync ;
23654: SYNC
// repeat wait ( 5 ) ;
23655: LD_INT 5
23657: PPUSH
23658: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23662: LD_INT 93
23664: PPUSH
23665: LD_INT 36
23667: PPUSH
23668: CALL_OW 428
23672: PPUSH
23673: CALL_OW 255
23677: PUSH
23678: LD_INT 4
23680: EQUAL
23681: IFFALSE 23655
// DialogueOn ;
23683: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23687: LD_INT 10
23689: PPUSH
23690: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23694: LD_EXP 58
23698: PPUSH
23699: LD_STRING D6b-Pow-2a
23701: PPUSH
23702: CALL_OW 88
// DialogueOff ;
23706: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23710: LD_EXP 58
23714: PPUSH
23715: CALL_OW 310
23719: PPUSH
23720: LD_INT 332
23722: PPUSH
23723: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23727: LD_INT 93
23729: PPUSH
23730: LD_INT 35
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: LD_INT 6
23738: NEG
23739: PPUSH
23740: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23744: LD_INT 35
23746: PPUSH
23747: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23751: LD_INT 332
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 1000
23761: LESS
23762: PUSH
23763: LD_INT 332
23765: PPUSH
23766: CALL_OW 300
23770: AND
23771: IFFALSE 23783
// SetLives ( kozlov_fac , 0 ) ;
23773: LD_INT 332
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23783: LD_INT 332
23785: PPUSH
23786: CALL_OW 301
23790: PUSH
23791: LD_EXP 58
23795: PPUSH
23796: CALL_OW 301
23800: OR
23801: IFFALSE 23744
// game_speed := 4 ;
23803: LD_ADDR_OWVAR 65
23807: PUSH
23808: LD_INT 4
23810: ST_TO_ADDR
// powellCenterCameraMode := false ;
23811: LD_ADDR_EXP 20
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: LD_INT 22
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 25
23841: PUSH
23842: LD_INT 2
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: UNION
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23876
// SetTag ( i , 0 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 0
23869: PPUSH
23870: CALL_OW 109
23874: GO 23859
23876: POP
23877: POP
// wait ( 0 0$3 ) ;
23878: LD_INT 105
23880: PPUSH
23881: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23885: LD_INT 93
23887: PPUSH
23888: LD_INT 35
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: CALL_OW 331
// DialogueOn ;
23898: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23902: LD_VAR 0 11
23906: PPUSH
23907: LD_STRING D6c-Sol3-1
23909: PPUSH
23910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23914: LD_INT 10
23916: PPUSH
23917: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23921: LD_EXP 39
23925: PPUSH
23926: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23930: LD_EXP 39
23934: PPUSH
23935: LD_STRING D6c-JMM-1
23937: PPUSH
23938: CALL_OW 88
// if Cyrus then
23942: LD_EXP 45
23946: IFFALSE 23960
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23948: LD_EXP 45
23952: PPUSH
23953: LD_STRING D6c-Cyrus-1
23955: PPUSH
23956: CALL_OW 88
// if Bobby then
23960: LD_EXP 44
23964: IFFALSE 23978
// Say ( Bobby , D6c-Bobby-1 ) ;
23966: LD_EXP 44
23970: PPUSH
23971: LD_STRING D6c-Bobby-1
23973: PPUSH
23974: CALL_OW 88
// if Cornel then
23978: LD_EXP 50
23982: IFFALSE 23996
// Say ( Cornel , D6c-Corn-1 ) ;
23984: LD_EXP 50
23988: PPUSH
23989: LD_STRING D6c-Corn-1
23991: PPUSH
23992: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23996: LD_ADDR_VAR 0 4
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 22
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 26
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 25
24044: PUSH
24045: LD_INT 16
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 12
24057: PUSH
24058: EMPTY
24059: LIST
24060: LIST
24061: PUSH
24062: EMPTY
24063: LIST
24064: LIST
24065: LIST
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: PPUSH
24072: CALL_OW 69
24076: PUSH
24077: LD_VAR 0 11
24081: PUSH
24082: LD_EXP 39
24086: UNION
24087: PUSH
24088: LD_EXP 59
24092: UNION
24093: PUSH
24094: EMPTY
24095: LIST
24096: DIFF
24097: ST_TO_ADDR
// if tmp2 then
24098: LD_VAR 0 4
24102: IFFALSE 24120
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24104: LD_VAR 0 4
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: PPUSH
24113: LD_STRING D6c-Sol1-1
24115: PPUSH
24116: CALL_OW 88
// if Lisa then
24120: LD_EXP 42
24124: IFFALSE 24138
// Say ( Lisa , D6c-Lisa-1 ) ;
24126: LD_EXP 42
24130: PPUSH
24131: LD_STRING D6c-Lisa-1
24133: PPUSH
24134: CALL_OW 88
// if Gary then
24138: LD_EXP 51
24142: IFFALSE 24156
// Say ( Gary , D6c-Gary-1 ) ;
24144: LD_EXP 51
24148: PPUSH
24149: LD_STRING D6c-Gary-1
24151: PPUSH
24152: CALL_OW 88
// if Donaldson then
24156: LD_EXP 43
24160: IFFALSE 24174
// Say ( Donaldson , D6c-Don-1 ) ;
24162: LD_EXP 43
24166: PPUSH
24167: LD_STRING D6c-Don-1
24169: PPUSH
24170: CALL_OW 88
// if tmp2 > 1 then
24174: LD_VAR 0 4
24178: PUSH
24179: LD_INT 1
24181: GREATER
24182: IFFALSE 24200
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 2
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol2-1
24195: PPUSH
24196: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24200: LD_VAR 0 11
24204: PPUSH
24205: LD_STRING D6c-Sol3-2
24207: PPUSH
24208: CALL_OW 88
// dwait ( 0 0$1 ) ;
24212: LD_INT 35
24214: PPUSH
24215: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24219: LD_EXP 39
24223: PPUSH
24224: LD_STRING D6c-JMM-2
24226: PPUSH
24227: CALL_OW 88
// DialogueOff ;
24231: CALL_OW 7
// Video ( false ) ;
24235: LD_INT 0
24237: PPUSH
24238: CALL 101172 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24242: LD_INT 22
24244: PUSH
24245: LD_INT 4
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24264: LD_INT 4
24266: PPUSH
24267: LD_INT 4
24269: PPUSH
24270: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24274: LD_ADDR_VAR 0 1
24278: PUSH
24279: LD_INT 4
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: CALL 65274 0 3
24292: PUSH
24293: FOR_IN
24294: IFFALSE 24331
// if GetTech ( i , 1 ) <> state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 1
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: NONEQUAL
24312: IFFALSE 24329
// SetTech ( i , 1 , state_researched ) ;
24314: LD_VAR 0 1
24318: PPUSH
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 2
24324: PPUSH
24325: CALL_OW 322
24329: GO 24293
24331: POP
24332: POP
// missionStage := 6 ;
24333: LD_ADDR_EXP 15
24337: PUSH
24338: LD_INT 6
24340: ST_TO_ADDR
// activeAttacks := true ;
24341: LD_ADDR_EXP 16
24345: PUSH
24346: LD_INT 1
24348: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24349: LD_STRING M2
24351: PPUSH
24352: CALL_OW 337
// SaveForQuickRestart ;
24356: CALL_OW 22
// wait ( 0 0$40 ) ;
24360: LD_INT 1400
24362: PPUSH
24363: CALL_OW 67
// DialogueOn ;
24367: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24371: LD_EXP 62
24375: PPUSH
24376: LD_STRING D7-Friend-1
24378: PPUSH
24379: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24383: LD_EXP 39
24387: PPUSH
24388: LD_STRING D7-JMM-1
24390: PPUSH
24391: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24395: LD_EXP 62
24399: PPUSH
24400: LD_STRING D7-Friend-2
24402: PPUSH
24403: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24407: LD_EXP 39
24411: PPUSH
24412: LD_STRING D7-JMM-2
24414: PPUSH
24415: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24419: LD_EXP 62
24423: PPUSH
24424: LD_STRING D7-Friend-3
24426: PPUSH
24427: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24431: LD_EXP 39
24435: PPUSH
24436: LD_STRING D7-JMM-3
24438: PPUSH
24439: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-4
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-4
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-5
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-5
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-6
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-6
24510: PPUSH
24511: CALL_OW 88
// DialogueOff ;
24515: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24519: LD_STRING Mlegion
24521: PPUSH
24522: CALL_OW 337
// RebuildKozlovFactory ;
24526: CALL 4880 0 0
// end ;
24530: PPOPN 13
24532: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24533: LD_EXP 20
24537: PUSH
24538: LD_EXP 58
24542: PPUSH
24543: CALL_OW 300
24547: AND
24548: IFFALSE 24590
24550: GO 24552
24552: DISABLE
// begin enable ;
24553: ENABLE
// if IsInUnit ( Powell ) then
24554: LD_EXP 58
24558: PPUSH
24559: CALL_OW 310
24563: IFFALSE 24581
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24565: LD_EXP 58
24569: PPUSH
24570: CALL_OW 310
24574: PPUSH
24575: CALL_OW 85
24579: GO 24590
// CenterOnUnits ( Powell ) ;
24581: LD_EXP 58
24585: PPUSH
24586: CALL_OW 85
// end ;
24590: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24591: LD_INT 22
24593: PUSH
24594: LD_INT 8
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: PUSH
24601: LD_INT 34
24603: PUSH
24604: LD_INT 48
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PPUSH
24615: CALL_OW 69
24619: IFFALSE 24893
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
24627: PPUSH
// begin if missionStage < 9 then
24628: LD_EXP 15
24632: PUSH
24633: LD_INT 9
24635: LESS
24636: IFFALSE 24646
// missionStage := 9 ;
24638: LD_ADDR_EXP 15
24642: PUSH
24643: LD_INT 9
24645: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24684: LD_INT 175
24686: PPUSH
24687: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24691: LD_EXP 12
24695: PUSH
24696: LD_EXP 3
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: IN
24711: OR
24712: IFFALSE 24735
// target := [ 68 , 108 , 1 ] else
24714: LD_ADDR_VAR 0 2
24718: PUSH
24719: LD_INT 68
24721: PUSH
24722: LD_INT 108
24724: PUSH
24725: LD_INT 1
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: ST_TO_ADDR
24733: GO 24754
// target := [ 181 , 88 , 2 ] ;
24735: LD_ADDR_VAR 0 2
24739: PUSH
24740: LD_INT 181
24742: PUSH
24743: LD_INT 88
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_VAR 0 2
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PPUSH
24768: LD_VAR 0 2
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PPUSH
24777: CALL_OW 176
// if target [ 3 ] = 1 then
24781: LD_VAR 0 2
24785: PUSH
24786: LD_INT 3
24788: ARRAY
24789: PUSH
24790: LD_INT 1
24792: EQUAL
24793: IFFALSE 24809
// SayRadio ( Kurt , D12-Kurt-1 ) else
24795: LD_EXP 60
24799: PPUSH
24800: LD_STRING D12-Kurt-1
24802: PPUSH
24803: CALL_OW 94
24807: GO 24833
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24809: LD_EXP 60
24813: PPUSH
24814: LD_STRING D12a-Kurt-1
24816: PPUSH
24817: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24821: LD_EXP 74
24825: PPUSH
24826: LD_STRING D12a-Roth-1
24828: PPUSH
24829: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24833: LD_INT 350
24835: PPUSH
24836: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24840: LD_VAR 0 1
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_INT 8
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PUSH
24855: LD_INT 23
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 3
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: CALL_OW 228
// end ;
24893: PPOPN 2
24895: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24896: LD_EXP 60
24900: PPUSH
24901: CALL_OW 256
24905: PUSH
24906: LD_INT 999
24908: LESS
24909: PUSH
24910: LD_INT 22
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 21
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 23
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 69
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 7
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_OWVAR 67
24968: ARRAY
24969: LESSEQUAL
24970: OR
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 8
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: LD_INT 34
24984: PUSH
24985: LD_INT 48
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: NOT
25001: AND
25002: PUSH
25003: LD_EXP 60
25007: PPUSH
25008: CALL_OW 302
25012: AND
25013: PUSH
25014: LD_INT 5
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 70
25031: AND
25032: IFFALSE 25737
25034: GO 25036
25036: DISABLE
25037: LD_INT 0
25039: PPUSH
25040: PPUSH
25041: PPUSH
// begin DialogueOn ;
25042: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25046: LD_EXP 39
25050: PPUSH
25051: LD_STRING D13-JMM-1
25053: PPUSH
25054: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25058: LD_EXP 60
25062: PPUSH
25063: LD_STRING D13-Kurt-1
25065: PPUSH
25066: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25070: LD_EXP 39
25074: PPUSH
25075: LD_STRING D13-JMM-2
25077: PPUSH
25078: CALL_OW 88
// if FakeInfo then
25082: LD_EXP 12
25086: IFFALSE 25106
// begin Say ( Kurt , D13-Kurt-2 ) ;
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2
25095: PPUSH
25096: CALL_OW 88
// DialogueOff ;
25100: CALL_OW 7
// exit ;
25104: GO 25737
// end ; if not KurtStatus then
25106: LD_EXP 3
25110: NOT
25111: IFFALSE 25127
// Say ( Kurt , D13-Kurt-2b ) else
25113: LD_EXP 60
25117: PPUSH
25118: LD_STRING D13-Kurt-2b
25120: PPUSH
25121: CALL_OW 88
25125: GO 25139
// Say ( Kurt , D13-Kurt-2a ) ;
25127: LD_EXP 60
25131: PPUSH
25132: LD_STRING D13-Kurt-2a
25134: PPUSH
25135: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25139: LD_EXP 39
25143: PPUSH
25144: LD_STRING D13-JMM-3
25146: PPUSH
25147: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_STRING D13-Kurt-3
25158: PPUSH
25159: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25163: LD_EXP 39
25167: PPUSH
25168: LD_STRING D13-JMM-4
25170: PPUSH
25171: CALL_OW 88
// DialogueOff ;
25175: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25179: LD_STRING MlegionOut
25181: PPUSH
25182: CALL_OW 337
// legionDestroyed := true ;
25186: LD_ADDR_EXP 22
25190: PUSH
25191: LD_INT 1
25193: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25194: LD_INT 3
25196: PPUSH
25197: CALL 35356 0 1
// KillUnit ( Kozlov ) ;
25201: LD_EXP 61
25205: PPUSH
25206: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_INT 22
25217: PUSH
25218: LD_INT 8
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 23
25227: PUSH
25228: LD_INT 3
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: LD_INT 21
25240: PUSH
25241: LD_INT 33
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: PUSH
25262: FOR_IN
25263: IFFALSE 25276
// KillUnit ( i ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 66
25274: GO 25262
25276: POP
25277: POP
// ChangeSideFog ( 8 , 1 ) ;
25278: LD_INT 8
25280: PPUSH
25281: LD_INT 1
25283: PPUSH
25284: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25288: LD_ADDR_VAR 0 2
25292: PUSH
25293: LD_INT 22
25295: PUSH
25296: LD_INT 8
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 21
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 69
25321: PUSH
25322: LD_EXP 61
25326: PUSH
25327: LD_EXP 60
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: DIFF
25336: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25337: LD_VAR 0 2
25341: PUSH
25342: LD_INT 6
25344: PUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: LD_OWVAR 67
25360: ARRAY
25361: GREATEREQUAL
25362: IFFALSE 25536
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25364: LD_ADDR_VAR 0 3
25368: PUSH
25369: LD_INT 6
25371: PUSH
25372: LD_INT 5
25374: PUSH
25375: LD_INT 4
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: DOUBLE
25395: LD_VAR 0 2
25399: PUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 1
25407: PLUS
25408: MINUS
25409: INC
25410: ST_TO_ADDR
25411: LD_INT 1
25413: PUSH
25414: FOR_DOWNTO
25415: IFFALSE 25532
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25417: LD_ADDR_EXP 38
25421: PUSH
25422: LD_EXP 38
25426: PUSH
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: ADD
25438: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25439: LD_VAR 0 2
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 310
25454: IFFALSE 25471
// ComExitBuilding ( tmp [ i ] ) ;
25456: LD_VAR 0 2
25460: PUSH
25461: LD_VAR 0 1
25465: ARRAY
25466: PPUSH
25467: CALL_OW 122
// if IsInUnit ( i ) then
25471: LD_VAR 0 1
25475: PPUSH
25476: CALL_OW 310
25480: IFFALSE 25497
// ComExitVehicle ( tmp [ i ] ) ;
25482: LD_VAR 0 2
25486: PUSH
25487: LD_VAR 0 1
25491: ARRAY
25492: PPUSH
25493: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25497: LD_VAR 0 2
25501: PUSH
25502: LD_VAR 0 1
25506: ARRAY
25507: PPUSH
25508: LD_INT 34
25510: PUSH
25511: LD_INT 0
25513: PPUSH
25514: LD_INT 6
25516: PPUSH
25517: CALL_OW 12
25521: PLUS
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 171
// end ;
25530: GO 25414
25532: POP
25533: POP
// end else
25534: GO 25546
// x := tmp ;
25536: LD_ADDR_VAR 0 3
25540: PUSH
25541: LD_VAR 0 2
25545: ST_TO_ADDR
// for i := tmp downto tmp - x do
25546: LD_ADDR_VAR 0 1
25550: PUSH
25551: DOUBLE
25552: LD_VAR 0 2
25556: INC
25557: ST_TO_ADDR
25558: LD_VAR 0 2
25562: PUSH
25563: LD_VAR 0 3
25567: MINUS
25568: PUSH
25569: FOR_DOWNTO
25570: IFFALSE 25624
// begin if IsInUnit ( tmp [ i ] ) then
25572: LD_VAR 0 2
25576: PUSH
25577: LD_VAR 0 1
25581: ARRAY
25582: PPUSH
25583: CALL_OW 310
25587: IFFALSE 25604
// ComExitVehicle ( tmp [ i ] ) ;
25589: LD_VAR 0 2
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: LD_INT 1
25617: PPUSH
25618: CALL_OW 235
// end ;
25622: GO 25569
25624: POP
25625: POP
// SetSide ( Kurt , 1 ) ;
25626: LD_EXP 60
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25638: LD_INT 22
25640: PUSH
25641: LD_INT 8
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 21
25650: PUSH
25651: LD_INT 3
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25674: LD_INT 8
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 1
25685: PPUSH
25686: CALL_OW 80
// wait ( 1 1$20 ) ;
25690: LD_INT 2800
25692: PPUSH
25693: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 37
25704: PPUSH
25705: LD_INT 1
25707: PPUSH
25708: LD_INT 0
25710: PPUSH
25711: CALL_OW 48
// wait ( 0 0$1 ) ;
25715: LD_INT 35
25717: PPUSH
25718: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25722: LD_EXP 62
25726: PPUSH
25727: LD_INT 60
25729: PPUSH
25730: LD_INT 95
25732: PPUSH
25733: CALL_OW 111
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25740: LD_EXP 22
25744: NOT
25745: PUSH
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PUSH
25775: LD_INT 0
25777: EQUAL
25778: AND
25779: IFFALSE 25799
25781: GO 25783
25783: DISABLE
// begin legionDestroyed := true ;
25784: LD_ADDR_EXP 22
25788: PUSH
25789: LD_INT 1
25791: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25792: LD_STRING MlegionOut
25794: PPUSH
25795: CALL_OW 337
// end ;
25799: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25800: LD_EXP 38
25804: IFFALSE 25879
25806: GO 25808
25808: DISABLE
25809: LD_INT 0
25811: PPUSH
// begin enable ;
25812: ENABLE
// for i in legionEscapeUnits do
25813: LD_ADDR_VAR 0 1
25817: PUSH
25818: LD_EXP 38
25822: PUSH
25823: FOR_IN
25824: IFFALSE 25877
// begin if IsInArea ( i , legionEscapeArea ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 31
25833: PPUSH
25834: CALL_OW 308
25838: IFFALSE 25851
// RemoveUnit ( i ) else
25840: LD_VAR 0 1
25844: PPUSH
25845: CALL_OW 64
25849: GO 25875
// if not HasTask ( i ) then
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 314
25860: NOT
25861: IFFALSE 25875
// ComMoveToArea ( i , legionEscapeArea ) ;
25863: LD_VAR 0 1
25867: PPUSH
25868: LD_INT 31
25870: PPUSH
25871: CALL_OW 113
// end ;
25875: GO 25823
25877: POP
25878: POP
// end ;
25879: PPOPN 1
25881: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25882: LD_INT 1
25884: PPUSH
25885: LD_EXP 62
25889: PPUSH
25890: CALL_OW 292
25894: IFFALSE 26192
25896: GO 25898
25898: DISABLE
25899: LD_INT 0
25901: PPUSH
// begin wait ( 0 0$2 ) ;
25902: LD_INT 70
25904: PPUSH
25905: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25909: LD_EXP 62
25913: PPUSH
25914: CALL_OW 87
// DialogueOn ;
25918: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25922: LD_EXP 39
25926: PPUSH
25927: LD_STRING D14-JMM-1
25929: PPUSH
25930: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25934: LD_EXP 62
25938: PPUSH
25939: LD_STRING D14-Friend-1
25941: PPUSH
25942: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25946: LD_EXP 39
25950: PPUSH
25951: LD_STRING D14-JMM-2
25953: PPUSH
25954: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_STRING D14-Friend-2
25965: PPUSH
25966: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25970: LD_EXP 39
25974: PPUSH
25975: LD_STRING D14-JMM-3
25977: PPUSH
25978: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25982: LD_EXP 62
25986: PPUSH
25987: LD_STRING D14-Friend-3
25989: PPUSH
25990: CALL_OW 88
// DialogueOff ;
25994: CALL_OW 7
// dec = Query ( Q14 ) ;
25998: LD_ADDR_VAR 0 1
26002: PUSH
26003: LD_STRING Q14
26005: PPUSH
26006: CALL_OW 97
26010: ST_TO_ADDR
// if dec = 1 then
26011: LD_VAR 0 1
26015: PUSH
26016: LD_INT 1
26018: EQUAL
26019: IFFALSE 26053
// begin DialogueOn ;
26021: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26025: LD_EXP 39
26029: PPUSH
26030: LD_STRING D14a-JMM-1
26032: PPUSH
26033: CALL_OW 88
// DialogueOff ;
26037: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26041: LD_EXP 62
26045: PPUSH
26046: LD_INT 1
26048: PPUSH
26049: CALL_OW 235
// end ; if dec = 2 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: IFFALSE 26114
// begin DialogueOn ;
26063: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26067: LD_EXP 39
26071: PPUSH
26072: LD_STRING D14b-JMM-1
26074: PPUSH
26075: CALL_OW 88
// DialogueOff ;
26079: CALL_OW 7
// wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_INT 9
26097: PPUSH
26098: LD_INT 2
26100: PPUSH
26101: CALL_OW 111
// AddComHold ( Friend ) ;
26105: LD_EXP 62
26109: PPUSH
26110: CALL_OW 200
// end ; if dec = 3 then
26114: LD_VAR 0 1
26118: PUSH
26119: LD_INT 3
26121: EQUAL
26122: IFFALSE 26192
// begin DialogueOn ;
26124: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26128: LD_EXP 39
26132: PPUSH
26133: LD_STRING D14c-JMM-1
26135: PPUSH
26136: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26140: LD_EXP 62
26144: PPUSH
26145: LD_STRING D14c-Friend-1
26147: PPUSH
26148: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26152: LD_EXP 39
26156: PPUSH
26157: LD_STRING D14c-JMM-2
26159: PPUSH
26160: CALL_OW 88
// DialogueOff ;
26164: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26168: LD_EXP 62
26172: PPUSH
26173: LD_INT 9
26175: PPUSH
26176: LD_INT 2
26178: PPUSH
26179: CALL_OW 111
// AddComHold ( Friend ) ;
26183: LD_EXP 62
26187: PPUSH
26188: CALL_OW 200
// end ; end ;
26192: PPOPN 1
26194: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 428
26205: PUSH
26206: LD_EXP 62
26210: EQUAL
26211: PUSH
26212: LD_EXP 62
26216: PPUSH
26217: CALL_OW 255
26221: PUSH
26222: LD_INT 8
26224: EQUAL
26225: AND
26226: IFFALSE 26240
26228: GO 26230
26230: DISABLE
// RemoveUnit ( Friend ) ;
26231: LD_EXP 62
26235: PPUSH
26236: CALL_OW 64
26240: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26241: LD_EXP 14
26245: PUSH
26246: LD_INT 31500
26248: GREATEREQUAL
26249: PUSH
26250: LD_EXP 7
26254: AND
26255: PUSH
26256: LD_EXP 2
26260: AND
26261: IFFALSE 26691
26263: GO 26265
26265: DISABLE
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
26270: PPUSH
// begin missionStage := 7 ;
26271: LD_ADDR_EXP 15
26275: PUSH
26276: LD_INT 7
26278: ST_TO_ADDR
// uc_side = 1 ;
26279: LD_ADDR_OWVAR 20
26283: PUSH
26284: LD_INT 1
26286: ST_TO_ADDR
// uc_nation = 1 ;
26287: LD_ADDR_OWVAR 21
26291: PUSH
26292: LD_INT 1
26294: ST_TO_ADDR
// for i = 1 to 5 do
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_INT 5
26307: PUSH
26308: FOR_TO
26309: IFFALSE 26405
// begin vc_engine = 3 ;
26311: LD_ADDR_OWVAR 39
26315: PUSH
26316: LD_INT 3
26318: ST_TO_ADDR
// vc_control = 3 ;
26319: LD_ADDR_OWVAR 38
26323: PUSH
26324: LD_INT 3
26326: ST_TO_ADDR
// vc_chassis = 3 ;
26327: LD_ADDR_OWVAR 37
26331: PUSH
26332: LD_INT 3
26334: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26335: LD_ADDR_OWVAR 40
26339: PUSH
26340: LD_INT 5
26342: PUSH
26343: LD_INT 9
26345: PUSH
26346: LD_INT 7
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PPUSH
26357: LD_INT 3
26359: PPUSH
26360: CALL_OW 12
26364: ARRAY
26365: ST_TO_ADDR
// veh = CreateVehicle ;
26366: LD_ADDR_VAR 0 2
26370: PUSH
26371: CALL_OW 45
26375: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26376: LD_VAR 0 2
26380: PPUSH
26381: LD_INT 1
26383: PPUSH
26384: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_INT 19
26395: PPUSH
26396: LD_INT 0
26398: PPUSH
26399: CALL_OW 49
// end ;
26403: GO 26308
26405: POP
26406: POP
// vc_engine = 3 ;
26407: LD_ADDR_OWVAR 39
26411: PUSH
26412: LD_INT 3
26414: ST_TO_ADDR
// vc_control = 1 ;
26415: LD_ADDR_OWVAR 38
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// vc_chassis = 3 ;
26423: LD_ADDR_OWVAR 37
26427: PUSH
26428: LD_INT 3
26430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26431: LD_ADDR_OWVAR 40
26435: PUSH
26436: LD_INT 5
26438: PUSH
26439: LD_INT 9
26441: PUSH
26442: LD_INT 7
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 1
26452: PPUSH
26453: LD_INT 3
26455: PPUSH
26456: CALL_OW 12
26460: ARRAY
26461: ST_TO_ADDR
// vehG = CreateVehicle ;
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: CALL_OW 45
26471: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 19
26491: PPUSH
26492: LD_INT 0
26494: PPUSH
26495: CALL_OW 49
// if JMMGirl = 1 then
26499: LD_EXP 7
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26563
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26509: LD_ADDR_EXP 40
26513: PUSH
26514: LD_STRING Joan
26516: PPUSH
26517: LD_INT 1
26519: PPUSH
26520: LD_STRING 14_
26522: PPUSH
26523: CALL 65211 0 3
26527: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26528: LD_EXP 40
26532: PPUSH
26533: LD_VAR 0 3
26537: PPUSH
26538: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26542: LD_VAR 0 3
26546: PPUSH
26547: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26551: LD_EXP 40
26555: PPUSH
26556: LD_STRING D10BW-Joan-1
26558: PPUSH
26559: CALL_OW 94
// end ; if JMMGirl = 2 then
26563: LD_EXP 7
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26627
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26573: LD_ADDR_EXP 42
26577: PUSH
26578: LD_STRING Lisa
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_STRING 14_
26586: PPUSH
26587: CALL 65211 0 3
26591: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26592: LD_EXP 42
26596: PPUSH
26597: LD_VAR 0 3
26601: PPUSH
26602: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26615: LD_EXP 42
26619: PPUSH
26620: LD_STRING D10BW-Lisa-1
26622: PPUSH
26623: CALL_OW 94
// end ; if JMMGirl = 3 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 3
26634: EQUAL
26635: IFFALSE 26691
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26637: LD_ADDR_EXP 54
26641: PUSH
26642: LD_STRING Connie
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65211 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26656: LD_EXP 54
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26679: LD_EXP 54
26683: PPUSH
26684: LD_STRING D10BW-Con-1
26686: PPUSH
26687: CALL_OW 94
// end ; end ;
26691: PPOPN 3
26693: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26694: LD_EXP 14
26698: PUSH
26699: LD_INT 94500
26701: GREATEREQUAL
26702: IFFALSE 27114
26704: GO 26706
26706: DISABLE
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// begin tmp := PrepareStevensSquad ;
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: CALL 2222 0 0
26721: ST_TO_ADDR
// if not tmp then
26722: LD_VAR 0 3
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 27114
// uc_side := 1 ;
26731: LD_ADDR_OWVAR 20
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// uc_nation := 1 ;
26739: LD_ADDR_OWVAR 21
26743: PUSH
26744: LD_INT 1
26746: ST_TO_ADDR
// for i in tmp do
26747: LD_ADDR_VAR 0 1
26751: PUSH
26752: LD_VAR 0 3
26756: PUSH
26757: FOR_IN
26758: IFFALSE 26855
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26760: LD_INT 3
26762: PPUSH
26763: LD_INT 3
26765: PPUSH
26766: LD_INT 1
26768: PPUSH
26769: LD_INT 5
26771: PUSH
26772: LD_INT 9
26774: PUSH
26775: LD_INT 7
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PPUSH
26786: LD_INT 3
26788: PPUSH
26789: CALL_OW 12
26793: ARRAY
26794: PPUSH
26795: LD_INT 40
26797: PPUSH
26798: CALL 70035 0 5
// veh := CreateVehicle ;
26802: LD_ADDR_VAR 0 2
26806: PUSH
26807: CALL_OW 45
26811: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26812: LD_VAR 0 2
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_INT 19
26831: PPUSH
26832: LD_INT 0
26834: PPUSH
26835: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26839: LD_VAR 0 1
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: CALL_OW 52
// end ;
26853: GO 26757
26855: POP
26856: POP
// missionStage := 8 ;
26857: LD_ADDR_EXP 15
26861: PUSH
26862: LD_INT 8
26864: ST_TO_ADDR
// DialogueOn ;
26865: CALL_OW 6
// if Stevens then
26869: LD_EXP 41
26873: IFFALSE 26987
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26875: LD_EXP 41
26879: PPUSH
26880: CALL_OW 310
26884: PPUSH
26885: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26889: LD_EXP 41
26893: PPUSH
26894: LD_STRING D8-Huck-1
26896: PPUSH
26897: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26901: LD_EXP 39
26905: PPUSH
26906: LD_STRING D8-JMM-1
26908: PPUSH
26909: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26913: LD_EXP 41
26917: PPUSH
26918: LD_STRING D8-Huck-2
26920: PPUSH
26921: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26925: LD_EXP 39
26929: PPUSH
26930: LD_STRING D8-JMM-2
26932: PPUSH
26933: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26937: LD_EXP 41
26941: PPUSH
26942: LD_STRING D8-Huck-3
26944: PPUSH
26945: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26949: LD_EXP 39
26953: PPUSH
26954: LD_STRING D8-JMM-3
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26961: LD_EXP 41
26965: PPUSH
26966: LD_STRING D8-Huck-4
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-4
26980: PPUSH
26981: CALL_OW 88
// end else
26985: GO 27097
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26987: LD_EXP 55
26991: PPUSH
26992: CALL_OW 310
26996: PPUSH
26997: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27001: LD_EXP 55
27005: PPUSH
27006: LD_STRING D8-Huck-1
27008: PPUSH
27009: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27013: LD_EXP 39
27017: PPUSH
27018: LD_STRING D8-JMM-1a
27020: PPUSH
27021: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27025: LD_EXP 55
27029: PPUSH
27030: LD_STRING D8-Huck-2
27032: PPUSH
27033: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27037: LD_EXP 39
27041: PPUSH
27042: LD_STRING D8-JMM-2
27044: PPUSH
27045: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27049: LD_EXP 55
27053: PPUSH
27054: LD_STRING D8-Huck-3
27056: PPUSH
27057: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27061: LD_EXP 39
27065: PPUSH
27066: LD_STRING D8-JMM-3
27068: PPUSH
27069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27073: LD_EXP 55
27077: PPUSH
27078: LD_STRING D8-Huck-4
27080: PPUSH
27081: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D8-JMM-4
27092: PPUSH
27093: CALL_OW 88
// end ; DialogueOff ;
27097: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27101: LD_INT 25
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: LD_INT 1
27109: PPUSH
27110: CALL_OW 322
// end ;
27114: PPOPN 3
27116: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27117: LD_INT 1
27119: PPUSH
27120: LD_EXP 71
27124: PPUSH
27125: CALL_OW 292
27129: IFFALSE 27380
27131: GO 27133
27133: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27134: LD_EXP 71
27138: PPUSH
27139: CALL_OW 87
// DialogueOn ;
27143: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27147: LD_EXP 39
27151: PPUSH
27152: LD_STRING D10nB-JMM-1
27154: PPUSH
27155: CALL_OW 88
// if BurlakStatus = 1 then
27159: LD_EXP 9
27163: PUSH
27164: LD_INT 1
27166: EQUAL
27167: IFFALSE 27181
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27169: LD_EXP 70
27173: PPUSH
27174: LD_STRING D10nB-Vse-1a
27176: PPUSH
27177: CALL_OW 94
// end ; if BurlakStatus = 0 then
27181: LD_EXP 9
27185: PUSH
27186: LD_INT 0
27188: EQUAL
27189: IFFALSE 27203
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27191: LD_EXP 70
27195: PPUSH
27196: LD_STRING D10nB-Vse-1
27198: PPUSH
27199: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27203: LD_EXP 39
27207: PPUSH
27208: LD_STRING D10nB-JMM-2
27210: PPUSH
27211: CALL_OW 88
// if KappaStatus then
27215: LD_EXP 2
27219: IFFALSE 27233
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27221: LD_EXP 70
27225: PPUSH
27226: LD_STRING D10nB-Vse-5a
27228: PPUSH
27229: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27233: LD_EXP 2
27237: NOT
27238: PUSH
27239: LD_EXP 6
27243: PUSH
27244: LD_INT 0
27246: EQUAL
27247: AND
27248: IFFALSE 27376
// begin if JMMGirl = 1 then
27250: LD_EXP 7
27254: PUSH
27255: LD_INT 1
27257: EQUAL
27258: IFFALSE 27308
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27260: LD_EXP 70
27264: PPUSH
27265: LD_STRING D10nB-Vse-2
27267: PPUSH
27268: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27272: LD_EXP 39
27276: PPUSH
27277: LD_STRING D10nB-JMM-3
27279: PPUSH
27280: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27284: LD_EXP 70
27288: PPUSH
27289: LD_STRING D10nB-Vse-3
27291: PPUSH
27292: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27296: LD_EXP 39
27300: PPUSH
27301: LD_STRING D10nB-JMM-4
27303: PPUSH
27304: CALL_OW 88
// end ; if JMMGirl = 2 then
27308: LD_EXP 7
27312: PUSH
27313: LD_INT 2
27315: EQUAL
27316: IFFALSE 27342
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27318: LD_EXP 70
27322: PPUSH
27323: LD_STRING D10nB-Vse-4
27325: PPUSH
27326: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27330: LD_EXP 39
27334: PPUSH
27335: LD_STRING D10nB-JMM-5
27337: PPUSH
27338: CALL_OW 88
// end ; if JMMGirl = 3 then
27342: LD_EXP 7
27346: PUSH
27347: LD_INT 3
27349: EQUAL
27350: IFFALSE 27376
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27352: LD_EXP 70
27356: PPUSH
27357: LD_STRING D10nB-Vse-5
27359: PPUSH
27360: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27364: LD_EXP 39
27368: PPUSH
27369: LD_STRING D10nB-JMM-6
27371: PPUSH
27372: CALL_OW 88
// end ; end ; DialogueOff ;
27376: CALL_OW 7
// end ;
27380: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27381: LD_EXP 14
27385: PUSH
27386: LD_INT 115500
27388: GREATEREQUAL
27389: IFFALSE 27765
27391: GO 27393
27393: DISABLE
27394: LD_INT 0
27396: PPUSH
// begin missionStage := 10 ;
27397: LD_ADDR_EXP 15
27401: PUSH
27402: LD_INT 10
27404: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27405: LD_ADDR_VAR 0 1
27409: PUSH
27410: LD_INT 22
27412: PUSH
27413: LD_INT 1
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 23
27422: PUSH
27423: LD_INT 1
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 26
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 3
27442: PUSH
27443: LD_INT 25
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 25
27462: PUSH
27463: LD_INT 16
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: PUSH
27486: LD_EXP 39
27490: PUSH
27491: LD_EXP 60
27495: PUSH
27496: LD_EXP 41
27500: PUSH
27501: LD_EXP 55
27505: PUSH
27506: LD_EXP 42
27510: PUSH
27511: LD_EXP 43
27515: PUSH
27516: LD_EXP 44
27520: PUSH
27521: LD_EXP 45
27525: PUSH
27526: LD_EXP 46
27530: PUSH
27531: LD_EXP 47
27535: PUSH
27536: LD_EXP 48
27540: PUSH
27541: LD_EXP 49
27545: PUSH
27546: LD_EXP 50
27550: PUSH
27551: LD_EXP 51
27555: PUSH
27556: LD_EXP 52
27560: PUSH
27561: LD_EXP 53
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: DIFF
27584: ST_TO_ADDR
// if not tmp and Brown then
27585: LD_VAR 0 1
27589: NOT
27590: PUSH
27591: LD_EXP 47
27595: AND
27596: IFFALSE 27611
// tmp := [ Brown ] ;
27598: LD_ADDR_VAR 0 1
27602: PUSH
27603: LD_EXP 47
27607: PUSH
27608: EMPTY
27609: LIST
27610: ST_TO_ADDR
// DialogueOn ;
27611: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27615: LD_VAR 0 1
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PPUSH
27624: LD_STRING D11-Sol1-1
27626: PPUSH
27627: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27631: LD_EXP 64
27635: PPUSH
27636: LD_STRING D11-Pla-1
27638: PPUSH
27639: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27643: LD_EXP 65
27647: PPUSH
27648: LD_STRING D11-Kov-1
27650: PPUSH
27651: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27655: LD_EXP 64
27659: PPUSH
27660: LD_STRING D11-Pla-2
27662: PPUSH
27663: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27667: LD_VAR 0 1
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_STRING D11-Sol1-2
27678: PPUSH
27679: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27683: LD_EXP 39
27687: PPUSH
27688: LD_STRING D11-JMM-2
27690: PPUSH
27691: CALL_OW 88
// DialogueOff ;
27695: CALL_OW 7
// allowBehemothConstruct := true ;
27699: LD_ADDR_EXP 25
27703: PUSH
27704: LD_INT 1
27706: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27707: LD_STRING M4
27709: PPUSH
27710: CALL_OW 337
// BuildBehemoths ;
27714: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
27718: LD_INT 31500
27720: PPUSH
27721: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27725: LD_EXP 27
27729: IFFALSE 27733
// break ;
27731: GO 27765
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27733: LD_INT 267
27735: PPUSH
27736: CALL_OW 274
27740: PPUSH
27741: LD_INT 1
27743: PPUSH
27744: CALL_OW 275
27748: PUSH
27749: LD_INT 1000
27751: GREATEREQUAL
27752: IFFALSE 27758
// BuildBehemoths ;
27754: CALL 7693 0 0
// until not behemothBuilders ;
27758: LD_EXP 73
27762: NOT
27763: IFFALSE 27718
// end ;
27765: PPOPN 1
27767: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27768: LD_EXP 73
27772: NOT
27773: PUSH
27774: LD_EXP 28
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 25
27785: AND
27786: IFFALSE 27806
27788: GO 27790
27790: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27791: LD_STRING M4a
27793: PPUSH
27794: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27798: LD_ADDR_EXP 27
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// end ;
27806: END
// every 0 0$1 trigger behemothDone do
27807: LD_EXP 28
27811: IFFALSE 27823
27813: GO 27815
27815: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27816: LD_STRING M4b
27818: PPUSH
27819: CALL_OW 337
27823: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27824: LD_EXP 29
27828: NOT
27829: IFFALSE 28025
27831: GO 27833
27833: DISABLE
27834: LD_INT 0
27836: PPUSH
27837: PPUSH
// begin enable ;
27838: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27839: LD_ADDR_VAR 0 1
27843: PUSH
27844: LD_INT 3
27846: PPUSH
27847: CALL 101261 0 1
27851: ST_TO_ADDR
// if not tmp and not behemothDone then
27852: LD_VAR 0 1
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: IFFALSE 27900
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27866: LD_ADDR_VAR 0 1
27870: PUSH
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 37
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: ST_TO_ADDR
// if not tmp then
27900: LD_VAR 0 1
27904: NOT
27905: IFFALSE 27909
// exit ;
27907: GO 28025
// for i in tmp do
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 1
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28023
// if See ( 1 , i ) then
27922: LD_INT 1
27924: PPUSH
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 292
27934: IFFALSE 28021
// begin if GetType ( i ) = unit_building then
27936: LD_VAR 0 2
27940: PPUSH
27941: CALL_OW 247
27945: PUSH
27946: LD_INT 3
27948: EQUAL
27949: IFFALSE 27987
// begin CenterNowOnUnits ( i ) ;
27951: LD_VAR 0 2
27955: PPUSH
27956: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27960: LD_EXP 39
27964: PPUSH
27965: LD_STRING D17a-JMM-1
27967: PPUSH
27968: CALL_OW 88
// seeBehemoth := true ;
27972: LD_ADDR_EXP 29
27976: PUSH
27977: LD_INT 1
27979: ST_TO_ADDR
// disable ;
27980: DISABLE
// exit ;
27981: POP
27982: POP
27983: GO 28025
// end else
27985: GO 28021
// begin CenterNowOnUnits ( i ) ;
27987: LD_VAR 0 2
27991: PPUSH
27992: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27996: LD_EXP 39
28000: PPUSH
28001: LD_STRING D17b-JMM-1
28003: PPUSH
28004: CALL_OW 88
// seeBehemoth := true ;
28008: LD_ADDR_EXP 29
28012: PUSH
28013: LD_INT 1
28015: ST_TO_ADDR
// disable ;
28016: DISABLE
// exit ;
28017: POP
28018: POP
28019: GO 28025
// end ; end ;
28021: GO 27919
28023: POP
28024: POP
// end ;
28025: PPOPN 2
28027: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28028: LD_EXP 14
28032: PUSH
28033: LD_INT 123200
28035: GREATEREQUAL
28036: IFFALSE 29212
28038: GO 28040
28040: DISABLE
28041: LD_INT 0
28043: PPUSH
28044: PPUSH
28045: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28046: LD_INT 2
28048: PPUSH
28049: LD_INT 23
28051: PUSH
28052: LD_INT 3
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: LD_INT 48
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: PPUSH
28070: CALL 58848 0 2
// repeat wait ( 0 0$1 ) ;
28074: LD_INT 35
28076: PPUSH
28077: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28081: LD_INT 22
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 48
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: CALL_OW 69
28109: IFFALSE 28074
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28111: LD_ADDR_VAR 0 1
28115: PUSH
28116: LD_INT 22
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 34
28128: PUSH
28129: LD_INT 48
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 69
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: ST_TO_ADDR
// missionStage := 12 ;
28149: LD_ADDR_EXP 15
28153: PUSH
28154: LD_INT 12
28156: ST_TO_ADDR
// platonovHasBomb := true ;
28157: LD_ADDR_EXP 30
28161: PUSH
28162: LD_INT 1
28164: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 181
28172: PPUSH
28173: LD_INT 86
28175: PPUSH
28176: CALL_OW 171
// AddComHold ( bomb ) ;
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 200
// wait ( 0 0$10 ) ;
28189: LD_INT 350
28191: PPUSH
28192: CALL_OW 67
// DialogueOn ;
28196: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28200: LD_EXP 64
28204: PPUSH
28205: LD_STRING D15-Pla-1
28207: PPUSH
28208: CALL_OW 94
// dec = Query ( Q15a ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_STRING Q15a
28219: PPUSH
28220: CALL_OW 97
28224: ST_TO_ADDR
// if dec = 1 then
28225: LD_VAR 0 2
28229: PUSH
28230: LD_INT 1
28232: EQUAL
28233: IFFALSE 28256
// begin Say ( JMM , D15a-JMM-1 ) ;
28235: LD_EXP 39
28239: PPUSH
28240: LD_STRING D15a-JMM-1
28242: PPUSH
28243: CALL_OW 88
// YouLost ( Surrender ) ;
28247: LD_STRING Surrender
28249: PPUSH
28250: CALL_OW 104
// exit ;
28254: GO 29212
// end ; if dec = 2 then
28256: LD_VAR 0 2
28260: PUSH
28261: LD_INT 2
28263: EQUAL
28264: IFFALSE 28333
// begin Say ( JMM , D15b-JMM-1 ) ;
28266: LD_EXP 39
28270: PPUSH
28271: LD_STRING D15b-JMM-1
28273: PPUSH
28274: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28278: LD_EXP 64
28282: PPUSH
28283: LD_STRING D15b-Pla-1
28285: PPUSH
28286: CALL_OW 94
// DialogueOff ;
28290: CALL_OW 7
// wait ( 3 3$00 ) ;
28294: LD_INT 6300
28296: PPUSH
28297: CALL_OW 67
// DialogueOn ;
28301: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28305: LD_EXP 39
28309: PPUSH
28310: LD_STRING D15d-JMM-1a
28312: PPUSH
28313: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28317: LD_EXP 64
28321: PPUSH
28322: LD_STRING D15d-Pla-1
28324: PPUSH
28325: CALL_OW 94
// DialogueOff ;
28329: CALL_OW 7
// end ; if dec = 3 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 3
28340: EQUAL
28341: IFFALSE 28395
// begin Say ( JMM , D15c-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15c-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15c-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// wait ( 0 0$15 ) ;
28371: LD_INT 525
28373: PPUSH
28374: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28378: LD_VAR 0 1
28382: PPUSH
28383: LD_INT 60
28385: PPUSH
28386: LD_INT 95
28388: PPUSH
28389: CALL_OW 116
// exit ;
28393: GO 29212
// end ; if dec = 4 then
28395: LD_VAR 0 2
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28433
// begin Say ( JMM , D15d-JMM-1 ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28433: LD_EXP 62
28437: PPUSH
28438: CALL_OW 302
28442: PUSH
28443: LD_EXP 62
28447: PPUSH
28448: CALL_OW 255
28452: PUSH
28453: LD_INT 1
28455: EQUAL
28456: AND
28457: PUSH
28458: LD_INT 22
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 34
28470: PUSH
28471: LD_INT 8
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PPUSH
28482: CALL_OW 69
28486: NOT
28487: AND
28488: IFFALSE 29113
// begin SetSide ( Friend , 8 ) ;
28490: LD_EXP 62
28494: PPUSH
28495: LD_INT 8
28497: PPUSH
28498: CALL_OW 235
// if IsInUnit ( Friend ) then
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( Friend ) ;
28513: LD_EXP 62
28517: PPUSH
28518: CALL_OW 122
// if IsDriver ( Friend ) then
28522: LD_EXP 62
28526: PPUSH
28527: CALL 98806 0 1
28531: IFFALSE 28542
// ComExitVehicle ( Friend ) ;
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28542: LD_EXP 62
28546: PPUSH
28547: LD_INT 9
28549: PPUSH
28550: LD_INT 2
28552: PPUSH
28553: CALL_OW 171
// wait ( 0 0$05 ) ;
28557: LD_INT 175
28559: PPUSH
28560: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28564: LD_EXP 62
28568: PPUSH
28569: CALL_OW 87
// DialogueOn ;
28573: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28577: LD_EXP 39
28581: PPUSH
28582: LD_STRING D16-JMM-1
28584: PPUSH
28585: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28589: LD_EXP 62
28593: PPUSH
28594: LD_STRING D16-Friend-1
28596: PPUSH
28597: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28601: LD_EXP 39
28605: PPUSH
28606: LD_STRING D16-JMM-2
28608: PPUSH
28609: CALL_OW 88
// DialogueOff ;
28613: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28617: LD_EXP 62
28621: PPUSH
28622: LD_INT 1
28624: PPUSH
28625: CALL_OW 235
// ComHold ( Friend ) ;
28629: LD_EXP 62
28633: PPUSH
28634: CALL_OW 140
// wait ( 0 0$20 ) ;
28638: LD_INT 700
28640: PPUSH
28641: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28645: LD_EXP 62
28649: PPUSH
28650: LD_INT 9
28652: PPUSH
28653: LD_INT 2
28655: PPUSH
28656: CALL_OW 297
28660: PUSH
28661: LD_INT 30
28663: LESS
28664: IFFALSE 28733
// begin SetSide ( Friend , 8 ) ;
28666: LD_EXP 62
28670: PPUSH
28671: LD_INT 8
28673: PPUSH
28674: CALL_OW 235
// if IsInUnit ( Friend ) then
28678: LD_EXP 62
28682: PPUSH
28683: CALL_OW 310
28687: IFFALSE 28698
// ComExitBuilding ( Friend ) ;
28689: LD_EXP 62
28693: PPUSH
28694: CALL_OW 122
// if IsDriver ( Friend ) then
28698: LD_EXP 62
28702: PPUSH
28703: CALL 98806 0 1
28707: IFFALSE 28718
// ComExitVehicle ( Friend ) ;
28709: LD_EXP 62
28713: PPUSH
28714: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28718: LD_EXP 62
28722: PPUSH
28723: LD_INT 9
28725: PPUSH
28726: LD_INT 2
28728: PPUSH
28729: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28733: LD_INT 1050
28735: PPUSH
28736: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28740: LD_INT 22
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 34
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PPUSH
28764: CALL_OW 69
28768: NOT
28769: IFFALSE 29091
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_INT 22
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 26
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 3
28798: PUSH
28799: LD_INT 25
28801: PUSH
28802: LD_INT 12
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 25
28811: PUSH
28812: LD_INT 16
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: PPUSH
28829: CALL_OW 69
28833: PUSH
28834: LD_EXP 39
28838: PUSH
28839: LD_EXP 41
28843: PUSH
28844: LD_EXP 55
28848: PUSH
28849: LD_EXP 42
28853: PUSH
28854: LD_EXP 43
28858: PUSH
28859: LD_EXP 44
28863: PUSH
28864: LD_EXP 45
28868: PUSH
28869: LD_EXP 46
28873: PUSH
28874: LD_EXP 47
28878: PUSH
28879: LD_EXP 48
28883: PUSH
28884: LD_EXP 49
28888: PUSH
28889: LD_EXP 50
28893: PUSH
28894: LD_EXP 51
28898: PUSH
28899: LD_EXP 52
28903: PUSH
28904: LD_EXP 53
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: DIFF
28926: ST_TO_ADDR
// DialogueOn ;
28927: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28931: LD_EXP 64
28935: PPUSH
28936: LD_STRING D16a-Pla-1
28938: PPUSH
28939: CALL_OW 94
// if Stevens then
28943: LD_EXP 41
28947: IFFALSE 28963
// Say ( Stevens , D16a-Huck-1 ) else
28949: LD_EXP 41
28953: PPUSH
28954: LD_STRING D16a-Huck-1
28956: PPUSH
28957: CALL_OW 88
28961: GO 29005
// if Baker then
28963: LD_EXP 55
28967: IFFALSE 28983
// Say ( Baker , D16a-Huck-1 ) else
28969: LD_EXP 55
28973: PPUSH
28974: LD_STRING D16a-Huck-1
28976: PPUSH
28977: CALL_OW 88
28981: GO 29005
// if tmp then
28983: LD_VAR 0 3
28987: IFFALSE 29005
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28989: LD_VAR 0 3
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_STRING D16a-Sol1-1
29000: PPUSH
29001: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29005: LD_EXP 62
29009: PPUSH
29010: CALL_OW 255
29014: PUSH
29015: LD_INT 8
29017: EQUAL
29018: IFFALSE 29034
// Say ( JMM , D16a-JMM-1 ) else
29020: LD_EXP 39
29024: PPUSH
29025: LD_STRING D16a-JMM-1
29027: PPUSH
29028: CALL_OW 88
29032: GO 29070
// begin Say ( JMM , D16a-JMM-1a ) ;
29034: LD_EXP 39
29038: PPUSH
29039: LD_STRING D16a-JMM-1a
29041: PPUSH
29042: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29046: LD_EXP 62
29050: PPUSH
29051: LD_STRING D16a-Friend-1
29053: PPUSH
29054: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29058: LD_EXP 62
29062: PPUSH
29063: LD_INT 3
29065: PPUSH
29066: CALL_OW 235
// end ; DialogueOff ;
29070: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: LD_INT 60
29081: PPUSH
29082: LD_INT 95
29084: PPUSH
29085: CALL_OW 116
// end else
29089: GO 29111
// begin DialogueOn ;
29091: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29095: LD_EXP 64
29099: PPUSH
29100: LD_STRING D16c-Pla-
29102: PPUSH
29103: CALL_OW 94
// DialogueOff ;
29107: CALL_OW 7
// end ; end else
29111: GO 29212
// begin wait ( 3 3$00 ) ;
29113: LD_INT 6300
29115: PPUSH
29116: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29120: LD_INT 22
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 34
29132: PUSH
29133: LD_INT 8
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PPUSH
29144: CALL_OW 69
29148: NOT
29149: IFFALSE 29192
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29151: LD_EXP 64
29155: PPUSH
29156: LD_STRING D16b-Pla-1
29158: PPUSH
29159: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29163: LD_EXP 39
29167: PPUSH
29168: LD_STRING D16b-JMM-
29170: PPUSH
29171: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 60
29182: PPUSH
29183: LD_INT 95
29185: PPUSH
29186: CALL_OW 116
// end else
29190: GO 29212
// begin DialogueOn ;
29192: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29196: LD_EXP 64
29200: PPUSH
29201: LD_STRING D16c-Pla-
29203: PPUSH
29204: CALL_OW 94
// DialogueOff ;
29208: CALL_OW 7
// end ; end ; end ;
29212: PPOPN 3
29214: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29215: LD_EXP 14
29219: PUSH
29220: LD_INT 126000
29222: GREATEREQUAL
29223: PUSH
29224: LD_EXP 23
29228: NOT
29229: AND
29230: PUSH
29231: LD_EXP 74
29235: PPUSH
29236: CALL_OW 302
29240: AND
29241: IFFALSE 29599
29243: GO 29245
29245: DISABLE
29246: LD_INT 0
29248: PPUSH
// begin missionStage = 11 ;
29249: LD_ADDR_EXP 15
29253: PUSH
29254: LD_INT 11
29256: ST_TO_ADDR
// DialogueOn ;
29257: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29261: LD_EXP 74
29265: PPUSH
29266: LD_STRING D9-Roth-1
29268: PPUSH
29269: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29273: LD_EXP 39
29277: PPUSH
29278: LD_STRING D9-JMM-1
29280: PPUSH
29281: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29285: LD_EXP 74
29289: PPUSH
29290: LD_STRING D9-Roth-2
29292: PPUSH
29293: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29297: LD_EXP 74
29301: PPUSH
29302: LD_STRING D9-Roth-2a
29304: PPUSH
29305: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29309: LD_EXP 64
29313: PPUSH
29314: LD_STRING D9-Pla-2
29316: PPUSH
29317: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29321: LD_EXP 74
29325: PPUSH
29326: LD_STRING D9-Roth-3
29328: PPUSH
29329: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29333: LD_EXP 64
29337: PPUSH
29338: LD_STRING D9-Pla-3
29340: PPUSH
29341: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-4
29352: PPUSH
29353: CALL_OW 94
// dec = Query ( Q9 ) ;
29357: LD_ADDR_VAR 0 1
29361: PUSH
29362: LD_STRING Q9
29364: PPUSH
29365: CALL_OW 97
29369: ST_TO_ADDR
// if dec = 1 then
29370: LD_VAR 0 1
29374: PUSH
29375: LD_INT 1
29377: EQUAL
29378: IFFALSE 29392
// SayRadio ( Roth , D9a-Roth-1 ) ;
29380: LD_EXP 74
29384: PPUSH
29385: LD_STRING D9a-Roth-1
29387: PPUSH
29388: CALL_OW 94
// if dec = 2 then
29392: LD_VAR 0 1
29396: PUSH
29397: LD_INT 2
29399: EQUAL
29400: IFFALSE 29426
// begin Say ( JMM , D9b-JMM-1 ) ;
29402: LD_EXP 39
29406: PPUSH
29407: LD_STRING D9b-JMM-1
29409: PPUSH
29410: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29414: LD_EXP 74
29418: PPUSH
29419: LD_STRING D9b-Roth-1
29421: PPUSH
29422: CALL_OW 94
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29496
// begin Say ( JMM , D9c-JMM-1 ) ;
29436: LD_EXP 39
29440: PPUSH
29441: LD_STRING D9c-JMM-1
29443: PPUSH
29444: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29448: LD_EXP 74
29452: PPUSH
29453: LD_STRING D9c-Roth-1
29455: PPUSH
29456: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29460: LD_EXP 39
29464: PPUSH
29465: LD_STRING D9c-JMM-2
29467: PPUSH
29468: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29472: LD_EXP 74
29476: PPUSH
29477: LD_STRING D9c-Roth-2
29479: PPUSH
29480: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29484: LD_EXP 39
29488: PPUSH
29489: LD_STRING D9c-JMM-3
29491: PPUSH
29492: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29496: LD_EXP 74
29500: PPUSH
29501: LD_STRING D9c-Roth-3
29503: PPUSH
29504: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9cont-Roth-1
29515: PPUSH
29516: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9cont-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9cont-Roth-2
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9cont-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9cont-Roth-3
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9cont-JMM-3
29575: PPUSH
29576: CALL_OW 88
// DialogueOff ;
29580: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29584: LD_STRING M3
29586: PPUSH
29587: CALL_OW 337
// allianceActive := true ;
29591: LD_ADDR_EXP 31
29595: PUSH
29596: LD_INT 1
29598: ST_TO_ADDR
// end ;
29599: PPOPN 1
29601: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29602: LD_INT 1
29604: PPUSH
29605: LD_INT 126
29607: PPUSH
29608: CALL_OW 292
29612: PUSH
29613: LD_EXP 64
29617: PPUSH
29618: CALL_OW 310
29622: AND
29623: IFFALSE 29703
29625: GO 29627
29627: DISABLE
29628: LD_INT 0
29630: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29631: LD_EXP 64
29635: PPUSH
29636: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29640: LD_ADDR_VAR 0 1
29644: PUSH
29645: LD_INT 4
29647: PPUSH
29648: LD_INT 22
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 70
29662: PPUSH
29663: LD_EXP 64
29667: PPUSH
29668: CALL_OW 74
29672: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29673: LD_EXP 64
29677: PPUSH
29678: LD_VAR 0 1
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29691: LD_EXP 64
29695: PPUSH
29696: LD_STRING D18-Pla-1
29698: PPUSH
29699: CALL_OW 88
// end ;
29703: PPOPN 1
29705: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29706: LD_EXP 64
29710: PPUSH
29711: CALL_OW 301
29715: PUSH
29716: LD_EXP 67
29720: PPUSH
29721: CALL_OW 301
29725: AND
29726: PUSH
29727: LD_INT 22
29729: PUSH
29730: LD_INT 3
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 21
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 50
29749: PUSH
29750: EMPTY
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 69
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: LD_INT 8
29768: PUSH
29769: LD_INT 9
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: LD_OWVAR 67
29781: ARRAY
29782: LESS
29783: AND
29784: IFFALSE 30555
29786: GO 29788
29788: DISABLE
29789: LD_INT 0
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
// begin MC_Kill ( 1 ) ;
29795: LD_INT 1
29797: PPUSH
29798: CALL 35356 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 3
29807: PPUSH
29808: LD_INT 1
29810: PPUSH
29811: LD_INT 1
29813: PPUSH
29814: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29818: LD_ADDR_VAR 0 1
29822: PUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 21
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 24
29845: PUSH
29846: LD_INT 900
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: FOR_IN
29864: IFFALSE 29895
// if GetSex ( i ) = sex_male then
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL_OW 258
29875: PUSH
29876: LD_INT 1
29878: EQUAL
29879: IFFALSE 29893
// begin tmp = i ;
29881: LD_ADDR_VAR 0 2
29885: PUSH
29886: LD_VAR 0 1
29890: ST_TO_ADDR
// break ;
29891: GO 29895
// end ;
29893: GO 29863
29895: POP
29896: POP
// if tmp = 0 then
29897: LD_VAR 0 2
29901: PUSH
29902: LD_INT 0
29904: EQUAL
29905: IFFALSE 29959
// begin uc_side = 3 ;
29907: LD_ADDR_OWVAR 20
29911: PUSH
29912: LD_INT 3
29914: ST_TO_ADDR
// uc_nation = 3 ;
29915: LD_ADDR_OWVAR 21
29919: PUSH
29920: LD_INT 3
29922: ST_TO_ADDR
// hc_name =  ;
29923: LD_ADDR_OWVAR 26
29927: PUSH
29928: LD_STRING 
29930: ST_TO_ADDR
// hc_gallery =  ;
29931: LD_ADDR_OWVAR 33
29935: PUSH
29936: LD_STRING 
29938: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 10
29944: PPUSH
29945: CALL_OW 381
// tmp = CreateHuman ;
29949: LD_ADDR_VAR 0 2
29953: PUSH
29954: CALL_OW 44
29958: ST_TO_ADDR
// end ; DialogueOn ;
29959: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_STRING DSurrenderRussians-RSol1-1a
29970: PPUSH
29971: CALL_OW 94
// DialogueOff ;
29975: CALL_OW 7
// russianDestroyed := true ;
29979: LD_ADDR_EXP 21
29983: PUSH
29984: LD_INT 1
29986: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29987: LD_INT 22
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 21
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PPUSH
30011: CALL_OW 69
30015: PPUSH
30016: CALL_OW 122
// wait ( 0 0$1 ) ;
30020: LD_INT 35
30022: PPUSH
30023: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30027: LD_INT 22
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 21
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 69
30055: PPUSH
30056: LD_INT 25
30058: PPUSH
30059: CALL_OW 173
// wait ( 0 0$10 ) ;
30063: LD_INT 350
30065: PPUSH
30066: CALL_OW 67
// PrepareOmarInvasion ;
30070: CALL 13903 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30074: LD_ADDR_VAR 0 2
30078: PUSH
30079: LD_EXP 92
30083: PPUSH
30084: CALL_OW 250
30088: PUSH
30089: LD_EXP 92
30093: PPUSH
30094: CALL_OW 251
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: PPUSH
30121: LD_INT 1
30123: PPUSH
30124: LD_INT 8
30126: NEG
30127: PPUSH
30128: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30132: LD_EXP 92
30136: PPUSH
30137: CALL_OW 87
// DialogueOn ;
30141: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30145: LD_EXP 39
30149: PPUSH
30150: LD_STRING D19-JMM-1
30152: PPUSH
30153: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_INT 22
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 26
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 25
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 25
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 3
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 25
30217: PUSH
30218: LD_INT 4
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 25
30227: PUSH
30228: LD_INT 5
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 25
30237: PUSH
30238: LD_INT 8
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PUSH
30264: LD_EXP 39
30268: PUSH
30269: LD_EXP 40
30273: PUSH
30274: LD_EXP 41
30278: PUSH
30279: LD_EXP 42
30283: PUSH
30284: LD_EXP 43
30288: PUSH
30289: LD_EXP 44
30293: PUSH
30294: LD_EXP 45
30298: PUSH
30299: LD_EXP 46
30303: PUSH
30304: LD_EXP 47
30308: PUSH
30309: LD_EXP 48
30313: PUSH
30314: LD_EXP 49
30318: PUSH
30319: LD_EXP 50
30323: PUSH
30324: LD_EXP 51
30328: PUSH
30329: LD_EXP 52
30333: PUSH
30334: LD_EXP 53
30338: PUSH
30339: LD_EXP 54
30343: PUSH
30344: LD_EXP 55
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: DIFF
30368: ST_TO_ADDR
// if tmp2 then
30369: LD_VAR 0 3
30373: IFFALSE 30391
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30375: LD_VAR 0 3
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: LD_STRING D19-Sol1-1
30386: PPUSH
30387: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30391: LD_EXP 39
30395: PPUSH
30396: LD_STRING D19-JMM-2
30398: PPUSH
30399: CALL_OW 88
// DialogueOff ;
30403: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30407: LD_VAR 0 2
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: LD_VAR 0 2
30420: PUSH
30421: LD_INT 2
30423: ARRAY
30424: PPUSH
30425: LD_INT 1
30427: PPUSH
30428: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30432: LD_STRING M5
30434: PPUSH
30435: CALL_OW 337
// omarOnMotherLode := false ;
30439: LD_ADDR_VAR 0 4
30443: PUSH
30444: LD_INT 0
30446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30447: LD_INT 35
30449: PPUSH
30450: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30454: LD_EXP 92
30458: PPUSH
30459: LD_INT 215
30461: PPUSH
30462: LD_INT 100
30464: PPUSH
30465: CALL_OW 297
30469: PUSH
30470: LD_INT 10
30472: LESS
30473: PUSH
30474: LD_VAR 0 4
30478: NOT
30479: AND
30480: IFFALSE 30514
// begin omarOnMotherLode := true ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_INT 1
30489: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30490: LD_EXP 39
30494: PPUSH
30495: LD_STRING D19b-JMM-1
30497: PPUSH
30498: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30502: LD_EXP 92
30506: PPUSH
30507: LD_STRING DOmarContam-Omar-1
30509: PPUSH
30510: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30514: LD_EXP 92
30518: PPUSH
30519: CALL_OW 301
30523: IFFALSE 30447
// Say ( JMM , D19a-JMM-1 ) ;
30525: LD_EXP 39
30529: PPUSH
30530: LD_STRING D19a-JMM-1
30532: PPUSH
30533: CALL_OW 88
// if Heike then
30537: LD_EXP 93
30541: IFFALSE 30555
// Say ( Heike , D19a-Hke-1 ) ;
30543: LD_EXP 93
30547: PPUSH
30548: LD_STRING D19a-Hke-1
30550: PPUSH
30551: CALL_OW 88
// end ;
30555: PPOPN 4
30557: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30558: LD_INT 22
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 21
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PPUSH
30582: CALL_OW 69
30586: PUSH
30587: LD_EXP 21
30591: AND
30592: IFFALSE 30660
30594: GO 30596
30596: DISABLE
30597: LD_INT 0
30599: PPUSH
30600: PPUSH
// begin enable ;
30601: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: LD_INT 25
30609: PPUSH
30610: LD_INT 22
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PPUSH
30620: CALL_OW 70
30624: ST_TO_ADDR
// if not tmp then
30625: LD_VAR 0 2
30629: NOT
30630: IFFALSE 30634
// exit ;
30632: GO 30660
// for i in tmp do
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_VAR 0 2
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30658
// RemoveUnit ( i ) ;
30647: LD_VAR 0 1
30651: PPUSH
30652: CALL_OW 64
30656: GO 30644
30658: POP
30659: POP
// end ;
30660: PPOPN 2
30662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30663: LD_INT 22
30665: PUSH
30666: LD_INT 7
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 21
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PPUSH
30687: CALL_OW 69
30691: PUSH
30692: LD_INT 6
30694: LESS
30695: IFFALSE 31163
30697: GO 30699
30699: DISABLE
30700: LD_INT 0
30702: PPUSH
30703: PPUSH
// begin MC_Kill ( 1 ) ;
30704: LD_INT 1
30706: PPUSH
30707: CALL 35356 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30711: LD_INT 7
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: LD_INT 1
30722: PPUSH
30723: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30727: LD_ADDR_VAR 0 1
30731: PUSH
30732: LD_INT 22
30734: PUSH
30735: LD_INT 7
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 26
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PPUSH
30756: CALL_OW 69
30760: PUSH
30761: LD_EXP 74
30765: DIFF
30766: ST_TO_ADDR
// if tmp then
30767: LD_VAR 0 1
30771: IFFALSE 30789
// tmp := tmp [ 1 ] else
30773: LD_ADDR_VAR 0 1
30777: PUSH
30778: LD_VAR 0 1
30782: PUSH
30783: LD_INT 1
30785: ARRAY
30786: ST_TO_ADDR
30787: GO 30825
// begin uc_side := 7 ;
30789: LD_ADDR_OWVAR 20
30793: PUSH
30794: LD_INT 7
30796: ST_TO_ADDR
// uc_nation := 1 ;
30797: LD_ADDR_OWVAR 21
30801: PUSH
30802: LD_INT 1
30804: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 8
30810: PPUSH
30811: CALL_OW 384
// tmp := CreateHuman ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: CALL_OW 44
30824: ST_TO_ADDR
// end ; DialogueOn ;
30825: CALL_OW 6
// if IsOK ( Roth ) then
30829: LD_EXP 74
30833: PPUSH
30834: CALL_OW 302
30838: IFFALSE 30852
// Say ( JMM , DAb-JMM-1 ) ;
30840: LD_EXP 39
30844: PPUSH
30845: LD_STRING DAb-JMM-1
30847: PPUSH
30848: CALL_OW 88
// if IsOK ( Roth ) then
30852: LD_EXP 74
30856: PPUSH
30857: CALL_OW 302
30861: IFFALSE 30885
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30863: LD_EXP 74
30867: PPUSH
30868: LD_STRING DSurrenderAlliance-Roth-1
30870: PPUSH
30871: CALL_OW 88
// RothCaptured := true ;
30875: LD_ADDR_EXP 33
30879: PUSH
30880: LD_INT 1
30882: ST_TO_ADDR
// end else
30883: GO 30897
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DSurrenderAlliance-Sci1-1
30892: PPUSH
30893: CALL_OW 88
// DialogueOff ;
30897: CALL_OW 7
// allianceDestroyed := true ;
30901: LD_ADDR_EXP 23
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// if capturedUnit = 0 then
30909: LD_EXP 34
30913: PUSH
30914: LD_INT 0
30916: EQUAL
30917: IFFALSE 30926
// SetAchievement ( ACH_ALLIANCE ) ;
30919: LD_STRING ACH_ALLIANCE
30921: PPUSH
30922: CALL_OW 543
// if trueAmericans then
30926: LD_EXP 35
30930: IFFALSE 31006
// begin if trueAmericans = 1 then
30932: LD_EXP 35
30936: PUSH
30937: LD_INT 1
30939: EQUAL
30940: IFFALSE 30956
// Say ( JMM , DAb-JMM-1a ) else
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING DAb-JMM-1a
30949: PPUSH
30950: CALL_OW 88
30954: GO 30968
// Say ( JMM , DAb-JMM-1b ) ;
30956: LD_EXP 39
30960: PPUSH
30961: LD_STRING DAb-JMM-1b
30963: PPUSH
30964: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30968: LD_EXP 35
30972: PPUSH
30973: CALL_OW 87
// for i in trueAmericans do
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_EXP 35
30986: PUSH
30987: FOR_IN
30988: IFFALSE 31004
// SetSide ( i , 1 ) ;
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_INT 1
30997: PPUSH
30998: CALL_OW 235
31002: GO 30987
31004: POP
31005: POP
// end ; repeat wait ( 0 0$1 ) ;
31006: LD_INT 35
31008: PPUSH
31009: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31013: LD_ADDR_VAR 0 2
31017: PUSH
31018: LD_INT 22
31020: PUSH
31021: LD_INT 7
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 21
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL_OW 69
31046: PUSH
31047: FOR_IN
31048: IFFALSE 31130
// begin if IsInUnit ( i ) then
31050: LD_VAR 0 2
31054: PPUSH
31055: CALL_OW 310
31059: IFFALSE 31070
// ComExitBuilding ( i ) ;
31061: LD_VAR 0 2
31065: PPUSH
31066: CALL_OW 122
// if IsDriver ( i ) then
31070: LD_VAR 0 2
31074: PPUSH
31075: CALL 98806 0 1
31079: IFFALSE 31090
// ComExitVehicle ( i ) ;
31081: LD_VAR 0 2
31085: PPUSH
31086: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31090: LD_VAR 0 2
31094: PPUSH
31095: LD_INT 26
31097: PPUSH
31098: CALL_OW 308
31102: NOT
31103: IFFALSE 31119
// AddComMoveToArea ( i , allianceEscapeArea ) else
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_INT 26
31112: PPUSH
31113: CALL_OW 173
31117: GO 31128
// RemoveUnit ( i ) ;
31119: LD_VAR 0 2
31123: PPUSH
31124: CALL_OW 64
// end ;
31128: GO 31047
31130: POP
31131: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31132: LD_INT 22
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 21
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PPUSH
31156: CALL_OW 69
31160: NOT
31161: IFFALSE 31006
// end ;
31163: PPOPN 2
31165: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31166: LD_INT 0
31168: PPUSH
31169: PPUSH
// if not unit then
31170: LD_VAR 0 1
31174: NOT
31175: IFFALSE 31179
// exit ;
31177: GO 32677
// DoNotAttack ( 7 , unit ) ;
31179: LD_INT 7
31181: PPUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_INT 260
31198: PPUSH
31199: LD_INT 235
31201: PPUSH
31202: LD_INT 3
31204: PPUSH
31205: LD_INT 1
31207: PPUSH
31208: CALL_OW 483
// SetSide ( unit , 4 ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_INT 4
31219: PPUSH
31220: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31224: LD_ADDR_EXP 34
31228: PUSH
31229: LD_EXP 34
31233: PUSH
31234: LD_INT 1
31236: PLUS
31237: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31238: LD_INT 70
31240: PPUSH
31241: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31245: LD_INT 260
31247: PPUSH
31248: LD_INT 235
31250: PPUSH
31251: LD_INT 1
31253: PPUSH
31254: LD_INT 8
31256: NEG
31257: PPUSH
31258: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31262: LD_VAR 0 1
31266: PPUSH
31267: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31271: LD_VAR 0 1
31275: PPUSH
31276: LD_EXP 74
31280: PPUSH
31281: CALL_OW 119
// DialogueOn ;
31285: CALL_OW 6
// case unit of JMM :
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 39
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31305: LD_EXP 39
31309: PPUSH
31310: LD_STRING DA1-JMM-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31761
31319: LD_EXP 40
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31330: LD_EXP 40
31334: PPUSH
31335: LD_STRING DA1-Joan-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31761
31344: LD_EXP 42
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31355: LD_EXP 42
31359: PPUSH
31360: LD_STRING DA1-Lisa-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31761
31369: LD_EXP 43
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31380: LD_EXP 43
31384: PPUSH
31385: LD_STRING DA1-Don-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31761
31394: LD_EXP 50
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31405: LD_EXP 50
31409: PPUSH
31410: LD_STRING DA1-Corn-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31761
31419: LD_EXP 46
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31430: LD_EXP 46
31434: PPUSH
31435: LD_STRING DA1-Den-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31761
31444: LD_EXP 44
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31455: LD_EXP 44
31459: PPUSH
31460: LD_STRING DA1-Bobby-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31761
31469: LD_EXP 48
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31480: LD_EXP 48
31484: PPUSH
31485: LD_STRING DA1-Glad-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31761
31494: LD_EXP 45
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31505: LD_EXP 45
31509: PPUSH
31510: LD_STRING DA1-Cyrus-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31761
31519: LD_EXP 41
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31530: LD_EXP 41
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31761
31544: LD_EXP 55
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31555: LD_EXP 55
31559: PPUSH
31560: LD_STRING DA1-Huck-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31761
31569: LD_EXP 47
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31580: LD_EXP 47
31584: PPUSH
31585: LD_STRING DA1-Brown-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31761
31594: LD_EXP 51
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31605: LD_EXP 51
31609: PPUSH
31610: LD_STRING DA1-Gary-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31761
31619: LD_EXP 54
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31630: LD_EXP 54
31634: PPUSH
31635: LD_STRING DA1-Con-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31761
31644: LD_EXP 60
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31655: LD_EXP 60
31659: PPUSH
31660: LD_STRING DA1-Kurt-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31761
31669: LD_EXP 53
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31680: LD_EXP 53
31684: PPUSH
31685: LD_STRING DA1-Yam-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31761
31694: LD_EXP 52
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31705: LD_EXP 52
31709: PPUSH
31710: LD_STRING DA1-Frank-1
31712: PPUSH
31713: CALL_OW 91
31717: GO 31761
31719: POP
// begin if GetSex ( unit ) = sex_male then
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 258
31729: PUSH
31730: LD_INT 1
31732: EQUAL
31733: IFFALSE 31749
// ForceSay ( unit , DA1-Sol1-1 ) else
31735: LD_VAR 0 1
31739: PPUSH
31740: LD_STRING DA1-Sol1-1
31742: PPUSH
31743: CALL_OW 91
31747: GO 31761
// ForceSay ( unit , DA1-FSol1-1 ) ;
31749: LD_VAR 0 1
31753: PPUSH
31754: LD_STRING DA1-FSol1-1
31756: PPUSH
31757: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31761: LD_EXP 74
31765: PPUSH
31766: LD_STRING DA-Roth-1
31768: PPUSH
31769: CALL_OW 88
// if capturedUnit = 1 then
31773: LD_EXP 34
31777: PUSH
31778: LD_INT 1
31780: EQUAL
31781: IFFALSE 31809
// begin Say ( Simms , DA-Sim-1 ) ;
31783: LD_EXP 75
31787: PPUSH
31788: LD_STRING DA-Sim-1
31790: PPUSH
31791: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31795: LD_EXP 74
31799: PPUSH
31800: LD_STRING DA-Roth-2
31802: PPUSH
31803: CALL_OW 88
// end else
31807: GO 31821
// Say ( Simms , DA-Sim-2 ) ;
31809: LD_EXP 75
31813: PPUSH
31814: LD_STRING DA-Sim-2
31816: PPUSH
31817: CALL_OW 88
// case unit of JMM :
31821: LD_VAR 0 1
31825: PUSH
31826: LD_EXP 39
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31837: LD_EXP 39
31841: PPUSH
31842: LD_STRING DA1-JMM-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32358
31851: LD_EXP 40
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31862: LD_EXP 40
31866: PPUSH
31867: LD_STRING DA1-Joan-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32358
31876: LD_EXP 42
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31887: LD_EXP 42
31891: PPUSH
31892: LD_STRING DA1-Lisa-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32358
31901: LD_EXP 43
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31912: LD_EXP 43
31916: PPUSH
31917: LD_STRING DA1-Don-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32358
31926: LD_EXP 50
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31937: LD_EXP 50
31941: PPUSH
31942: LD_STRING DA1-Corn-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32358
31951: LD_EXP 46
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31962: LD_EXP 46
31966: PPUSH
31967: LD_STRING DA1-Den-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32358
31976: LD_EXP 44
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31987: LD_EXP 44
31991: PPUSH
31992: LD_STRING DA1-Bobby-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32358
32001: LD_EXP 48
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32012: LD_EXP 48
32016: PPUSH
32017: LD_STRING DA1-Glad-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32358
32026: LD_EXP 45
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32037: LD_EXP 45
32041: PPUSH
32042: LD_STRING DA1-Cyrus-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32358
32051: LD_EXP 41
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32062: LD_EXP 41
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32358
32076: LD_EXP 55
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32087: LD_EXP 55
32091: PPUSH
32092: LD_STRING DA1-Huck-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32358
32101: LD_EXP 47
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32112: LD_EXP 47
32116: PPUSH
32117: LD_STRING DA1-Brown-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32358
32126: LD_EXP 51
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32137: LD_EXP 51
32141: PPUSH
32142: LD_STRING DA1-Gary-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32358
32151: LD_EXP 54
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32162: LD_EXP 54
32166: PPUSH
32167: LD_STRING DA1-Con-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32358
32176: LD_EXP 60
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32187: LD_EXP 60
32191: PPUSH
32192: LD_STRING DA1-Kurt-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32358
32201: LD_EXP 53
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32212: LD_EXP 53
32216: PPUSH
32217: LD_STRING DA1-Yam-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32358
32226: LD_EXP 52
32230: DOUBLE
32231: EQUAL
32232: IFTRUE 32236
32234: GO 32251
32236: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32237: LD_EXP 52
32241: PPUSH
32242: LD_STRING DA1-Frank-1a
32244: PPUSH
32245: CALL_OW 91
32249: GO 32358
32251: POP
// begin join := rand ( 0 , 1 ) ;
32252: LD_ADDR_VAR 0 3
32256: PUSH
32257: LD_INT 0
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 12
32267: ST_TO_ADDR
// if join then
32268: LD_VAR 0 3
32272: IFFALSE 32317
// begin if GetSex ( unit ) = sex_male then
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL_OW 258
32283: PUSH
32284: LD_INT 1
32286: EQUAL
32287: IFFALSE 32303
// ForceSay ( unit , DA1-Sol1-1b ) else
32289: LD_VAR 0 1
32293: PPUSH
32294: LD_STRING DA1-Sol1-1b
32296: PPUSH
32297: CALL_OW 91
32301: GO 32315
// ForceSay ( unit , DA1-FSol1-1b ) ;
32303: LD_VAR 0 1
32307: PPUSH
32308: LD_STRING DA1-FSol1-1b
32310: PPUSH
32311: CALL_OW 91
// end else
32315: GO 32358
// begin if GetSex ( unit ) = sex_male then
32317: LD_VAR 0 1
32321: PPUSH
32322: CALL_OW 258
32326: PUSH
32327: LD_INT 1
32329: EQUAL
32330: IFFALSE 32346
// ForceSay ( unit , DA1-Sol1-1a ) else
32332: LD_VAR 0 1
32336: PPUSH
32337: LD_STRING DA1-Sol1-1a
32339: PPUSH
32340: CALL_OW 91
32344: GO 32358
// ForceSay ( unit , DA1-FSol1-1a ) ;
32346: LD_VAR 0 1
32350: PPUSH
32351: LD_STRING DA1-FSol1-1a
32353: PPUSH
32354: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32358: LD_VAR 0 1
32362: PUSH
32363: LD_EXP 39
32367: EQUAL
32368: IFFALSE 32379
// begin YouLost ( JMMCaptured ) ;
32370: LD_STRING JMMCaptured
32372: PPUSH
32373: CALL_OW 104
// exit ;
32377: GO 32677
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32379: LD_VAR 0 1
32383: PUSH
32384: LD_EXP 43
32388: PUSH
32389: LD_EXP 46
32393: PUSH
32394: LD_EXP 44
32398: PUSH
32399: LD_EXP 41
32403: PUSH
32404: LD_EXP 55
32408: PUSH
32409: LD_EXP 47
32413: PUSH
32414: LD_EXP 53
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: IN
32428: PUSH
32429: LD_VAR 0 3
32433: OR
32434: IFFALSE 32533
// begin Say ( Roth , DA-Roth-3 ) ;
32436: LD_EXP 74
32440: PPUSH
32441: LD_STRING DA-Roth-3
32443: PPUSH
32444: CALL_OW 88
// SetSide ( unit , 7 ) ;
32448: LD_VAR 0 1
32452: PPUSH
32453: LD_INT 7
32455: PPUSH
32456: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32460: LD_ADDR_EXP 113
32464: PUSH
32465: LD_EXP 113
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: LD_EXP 113
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 1
32486: ADD
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32493: LD_INT 260
32495: PPUSH
32496: LD_INT 235
32498: PPUSH
32499: LD_INT 1
32501: PPUSH
32502: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32506: LD_VAR 0 1
32510: PPUSH
32511: LD_INT 1000
32513: PPUSH
32514: CALL_OW 234
// DialogueOff ;
32518: CALL_OW 7
// ComFree ( unit ) ;
32522: LD_VAR 0 1
32526: PPUSH
32527: CALL_OW 139
// end else
32531: GO 32614
// begin Say ( Roth , DA-Roth-3a ) ;
32533: LD_EXP 74
32537: PPUSH
32538: LD_STRING DA-Roth-3a
32540: PPUSH
32541: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32545: LD_ADDR_EXP 35
32549: PUSH
32550: LD_EXP 35
32554: PUSH
32555: LD_VAR 0 1
32559: ADD
32560: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32561: LD_INT 260
32563: PPUSH
32564: LD_INT 235
32566: PPUSH
32567: LD_INT 1
32569: PPUSH
32570: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 1000
32581: PPUSH
32582: CALL_OW 234
// DialogueOff ;
32586: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32590: LD_VAR 0 1
32594: PPUSH
32595: LD_INT 272
32597: PPUSH
32598: LD_INT 254
32600: PPUSH
32601: CALL_OW 111
// AddComHold ( unit ) ;
32605: LD_VAR 0 1
32609: PPUSH
32610: CALL_OW 200
// end ; if capturedUnit = 1 then
32614: LD_EXP 34
32618: PUSH
32619: LD_INT 1
32621: EQUAL
32622: IFFALSE 32677
// begin DialogueOn ;
32624: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32628: LD_EXP 39
32632: PPUSH
32633: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32637: LD_EXP 39
32641: PPUSH
32642: LD_STRING DAa-JMM-1
32644: PPUSH
32645: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32649: LD_EXP 39
32653: PPUSH
32654: LD_STRING DAa-JMM-1a
32656: PPUSH
32657: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32661: LD_EXP 39
32665: PPUSH
32666: LD_STRING DAa-JMM-1b
32668: PPUSH
32669: CALL_OW 88
// DialogueOff ;
32673: CALL_OW 7
// end ; end ;
32677: LD_VAR 0 2
32681: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32682: LD_EXP 15
32686: PUSH
32687: LD_INT 13
32689: GREATEREQUAL
32690: PUSH
32691: LD_INT 22
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PPUSH
32715: CALL_OW 69
32719: PUSH
32720: LD_INT 0
32722: EQUAL
32723: AND
32724: PUSH
32725: LD_INT 22
32727: PUSH
32728: LD_INT 2
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 21
32737: PUSH
32738: LD_INT 2
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 50
32747: PUSH
32748: EMPTY
32749: LIST
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: LIST
32755: PPUSH
32756: CALL_OW 69
32760: PUSH
32761: LD_INT 0
32763: EQUAL
32764: AND
32765: PUSH
32766: LD_EXP 21
32770: AND
32771: PUSH
32772: LD_EXP 22
32776: AND
32777: PUSH
32778: LD_EXP 23
32782: AND
32783: IFFALSE 33432
32785: GO 32787
32787: DISABLE
32788: LD_INT 0
32790: PPUSH
32791: PPUSH
32792: PPUSH
// begin m1 := false ;
32793: LD_ADDR_VAR 0 1
32797: PUSH
32798: LD_INT 0
32800: ST_TO_ADDR
// m2 := false ;
32801: LD_ADDR_VAR 0 2
32805: PUSH
32806: LD_INT 0
32808: ST_TO_ADDR
// m3 := false ;
32809: LD_ADDR_VAR 0 3
32813: PUSH
32814: LD_INT 0
32816: ST_TO_ADDR
// if not bombExploded then
32817: LD_EXP 37
32821: NOT
32822: IFFALSE 32831
// SetAchievement ( ACH_SIBROCKET ) ;
32824: LD_STRING ACH_SIBROCKET
32826: PPUSH
32827: CALL_OW 543
// if tick <= 120 120$00 then
32831: LD_OWVAR 1
32835: PUSH
32836: LD_INT 252000
32838: LESSEQUAL
32839: IFFALSE 32855
// begin wait ( 3 ) ;
32841: LD_INT 3
32843: PPUSH
32844: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32848: LD_STRING ACH_ASPEED_15
32850: PPUSH
32851: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32855: LD_EXP 39
32859: PPUSH
32860: CALL_OW 87
// music_class := 5 ;
32864: LD_ADDR_OWVAR 72
32868: PUSH
32869: LD_INT 5
32871: ST_TO_ADDR
// music_nat := 5 ;
32872: LD_ADDR_OWVAR 71
32876: PUSH
32877: LD_INT 5
32879: ST_TO_ADDR
// DialogueOn ;
32880: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32884: LD_EXP 39
32888: PPUSH
32889: LD_STRING D20-JMM-1
32891: PPUSH
32892: CALL_OW 88
// if IsOK ( Joan ) then
32896: LD_EXP 40
32900: PPUSH
32901: CALL_OW 302
32905: IFFALSE 32919
// Say ( Joan , D20-Joan-1 ) ;
32907: LD_EXP 40
32911: PPUSH
32912: LD_STRING D20-Joan-1
32914: PPUSH
32915: CALL_OW 88
// if IsOk ( Lisa ) then
32919: LD_EXP 42
32923: PPUSH
32924: CALL_OW 302
32928: IFFALSE 32942
// Say ( Lisa , D20-Lisa-1 ) ;
32930: LD_EXP 42
32934: PPUSH
32935: LD_STRING D20-Lisa-1
32937: PPUSH
32938: CALL_OW 88
// if IsOk ( Donaldson ) then
32942: LD_EXP 43
32946: PPUSH
32947: CALL_OW 302
32951: IFFALSE 32965
// Say ( Donaldson , D20-Don-1 ) ;
32953: LD_EXP 43
32957: PPUSH
32958: LD_STRING D20-Don-1
32960: PPUSH
32961: CALL_OW 88
// if IsOK ( Cornel ) then
32965: LD_EXP 50
32969: PPUSH
32970: CALL_OW 302
32974: IFFALSE 32988
// Say ( Cornel , D20-Corn-1 ) ;
32976: LD_EXP 50
32980: PPUSH
32981: LD_STRING D20-Corn-1
32983: PPUSH
32984: CALL_OW 88
// if IsOk ( Denis ) then
32988: LD_EXP 46
32992: PPUSH
32993: CALL_OW 302
32997: IFFALSE 33011
// Say ( Denis , D20-Den-1 ) ;
32999: LD_EXP 46
33003: PPUSH
33004: LD_STRING D20-Den-1
33006: PPUSH
33007: CALL_OW 88
// if IsOk ( Bobby ) then
33011: LD_EXP 44
33015: PPUSH
33016: CALL_OW 302
33020: IFFALSE 33034
// Say ( Bobby , D20-Bobby-1 ) ;
33022: LD_EXP 44
33026: PPUSH
33027: LD_STRING D20-Bobby-1
33029: PPUSH
33030: CALL_OW 88
// if IsOk ( Gladstone ) then
33034: LD_EXP 48
33038: PPUSH
33039: CALL_OW 302
33043: IFFALSE 33057
// Say ( Gladstone , D20-Glad-1 ) ;
33045: LD_EXP 48
33049: PPUSH
33050: LD_STRING D20-Glad-1
33052: PPUSH
33053: CALL_OW 88
// if IsOk ( Cyrus ) then
33057: LD_EXP 45
33061: PPUSH
33062: CALL_OW 302
33066: IFFALSE 33080
// Say ( Cyrus , D20-Cyrus-1 ) ;
33068: LD_EXP 45
33072: PPUSH
33073: LD_STRING D20-Cyrus-1
33075: PPUSH
33076: CALL_OW 88
// if IsOk ( Stevens ) then
33080: LD_EXP 41
33084: PPUSH
33085: CALL_OW 302
33089: IFFALSE 33103
// Say ( Stevens , D20-Huck-1 ) ;
33091: LD_EXP 41
33095: PPUSH
33096: LD_STRING D20-Huck-1
33098: PPUSH
33099: CALL_OW 88
// if IsOk ( Brown ) then
33103: LD_EXP 47
33107: PPUSH
33108: CALL_OW 302
33112: IFFALSE 33126
// Say ( Brown , D20-Brown-1 ) ;
33114: LD_EXP 47
33118: PPUSH
33119: LD_STRING D20-Brown-1
33121: PPUSH
33122: CALL_OW 88
// if IsOk ( Gary ) then
33126: LD_EXP 51
33130: PPUSH
33131: CALL_OW 302
33135: IFFALSE 33149
// Say ( Gary , D20-Gary-1 ) ;
33137: LD_EXP 51
33141: PPUSH
33142: LD_STRING D20-Gary-1
33144: PPUSH
33145: CALL_OW 88
// if IsOk ( Connie ) then
33149: LD_EXP 54
33153: PPUSH
33154: CALL_OW 302
33158: IFFALSE 33172
// Say ( Connie , D20-Con-1 ) ;
33160: LD_EXP 54
33164: PPUSH
33165: LD_STRING D20-Con-1
33167: PPUSH
33168: CALL_OW 88
// if IsOk ( Kurt ) then
33172: LD_EXP 60
33176: PPUSH
33177: CALL_OW 302
33181: IFFALSE 33195
// Say ( Kurt , D20-Kurt-1 ) ;
33183: LD_EXP 60
33187: PPUSH
33188: LD_STRING D20-Kurt-1
33190: PPUSH
33191: CALL_OW 88
// if IsOk ( Kikuchi ) then
33195: LD_EXP 53
33199: PPUSH
33200: CALL_OW 302
33204: IFFALSE 33218
// Say ( Kikuchi , D20-Yam-1 ) ;
33206: LD_EXP 53
33210: PPUSH
33211: LD_STRING D20-Yam-1
33213: PPUSH
33214: CALL_OW 88
// if IsOk ( Frank ) then
33218: LD_EXP 52
33222: PPUSH
33223: CALL_OW 302
33227: IFFALSE 33241
// Say ( Frank , D20-Frank-1 ) ;
33229: LD_EXP 52
33233: PPUSH
33234: LD_STRING D20-Frank-1
33236: PPUSH
33237: CALL_OW 88
// DialogueOff ;
33241: CALL_OW 7
// if RothCaptured then
33245: LD_EXP 33
33249: IFFALSE 33271
// begin m1 := true ;
33251: LD_ADDR_VAR 0 1
33255: PUSH
33256: LD_INT 1
33258: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33259: LD_STRING Roth
33261: PPUSH
33262: LD_INT 1
33264: PPUSH
33265: CALL_OW 101
// end else
33269: GO 33282
// AddMedal ( Roth , - 1 ) ;
33271: LD_STRING Roth
33273: PPUSH
33274: LD_INT 1
33276: NEG
33277: PPUSH
33278: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33282: LD_EXP 25
33286: NOT
33287: PUSH
33288: LD_EXP 27
33292: OR
33293: IFFALSE 33315
// begin m2 := true ;
33295: LD_ADDR_VAR 0 2
33299: PUSH
33300: LD_INT 1
33302: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33303: LD_STRING Project
33305: PPUSH
33306: LD_INT 1
33308: PPUSH
33309: CALL_OW 101
// end else
33313: GO 33326
// AddMedal ( Project , - 1 ) ;
33315: LD_STRING Project
33317: PPUSH
33318: LD_INT 1
33320: NEG
33321: PPUSH
33322: CALL_OW 101
// if lostCounter = 0 then
33326: LD_EXP 32
33330: PUSH
33331: LD_INT 0
33333: EQUAL
33334: IFFALSE 33356
// begin m3 := true ;
33336: LD_ADDR_VAR 0 3
33340: PUSH
33341: LD_INT 1
33343: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33344: LD_STRING NoLosses
33346: PPUSH
33347: LD_INT 1
33349: PPUSH
33350: CALL_OW 101
// end else
33354: GO 33367
// AddMedal ( NoLosses , - 1 ) ;
33356: LD_STRING NoLosses
33358: PPUSH
33359: LD_INT 1
33361: NEG
33362: PPUSH
33363: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33367: LD_VAR 0 1
33371: PUSH
33372: LD_VAR 0 2
33376: AND
33377: PUSH
33378: LD_VAR 0 3
33382: AND
33383: PUSH
33384: LD_OWVAR 67
33388: PUSH
33389: LD_INT 3
33391: EQUAL
33392: AND
33393: IFFALSE 33405
// SetAchievementEX ( ACH_AMER , 15 ) ;
33395: LD_STRING ACH_AMER
33397: PPUSH
33398: LD_INT 15
33400: PPUSH
33401: CALL_OW 564
// GiveMedals ( MAIN ) ;
33405: LD_STRING MAIN
33407: PPUSH
33408: CALL_OW 102
// music_class := 4 ;
33412: LD_ADDR_OWVAR 72
33416: PUSH
33417: LD_INT 4
33419: ST_TO_ADDR
// music_nat := 1 ;
33420: LD_ADDR_OWVAR 71
33424: PUSH
33425: LD_INT 1
33427: ST_TO_ADDR
// YouWin ;
33428: CALL_OW 103
// end ; end_of_file
33432: PPOPN 3
33434: END
// export function CustomEvent ( event ) ; begin
33435: LD_INT 0
33437: PPUSH
// end ;
33438: LD_VAR 0 2
33442: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33443: LD_VAR 0 1
33447: PUSH
33448: LD_INT 1
33450: EQUAL
33451: PUSH
33452: LD_VAR 0 2
33456: PUSH
33457: LD_INT 4
33459: EQUAL
33460: AND
33461: PUSH
33462: LD_EXP 58
33466: PPUSH
33467: CALL_OW 300
33471: AND
33472: IFFALSE 33488
// begin wait ( 0 0$2 ) ;
33474: LD_INT 70
33476: PPUSH
33477: CALL_OW 67
// YouLost ( Dismissed ) ;
33481: LD_STRING Dismissed
33483: PPUSH
33484: CALL_OW 104
// end ; end ;
33488: PPOPN 2
33490: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33491: LD_VAR 0 2
33495: PPUSH
33496: LD_VAR 0 3
33500: PPUSH
33501: LD_INT 18
33503: PPUSH
33504: CALL_OW 309
33508: IFFALSE 33517
// YouLost ( Motherlode3 ) ;
33510: LD_STRING Motherlode3
33512: PPUSH
33513: CALL_OW 104
// end ;
33517: PPOPN 3
33519: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33520: LD_EXP 27
33524: NOT
33525: IFFALSE 33535
// behemothDone := true ;
33527: LD_ADDR_EXP 28
33531: PUSH
33532: LD_INT 1
33534: ST_TO_ADDR
// end ;
33535: PPOPN 1
33537: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33538: LD_VAR 0 1
33542: PPUSH
33543: CALL_OW 255
33547: PUSH
33548: LD_INT 1
33550: EQUAL
33551: IFFALSE 33561
// bombExploded := true ;
33553: LD_ADDR_EXP 37
33557: PUSH
33558: LD_INT 1
33560: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33561: LD_VAR 0 1
33565: PPUSH
33566: CALL_OW 255
33570: PUSH
33571: LD_INT 1
33573: EQUAL
33574: PUSH
33575: LD_EXP 30
33579: AND
33580: PUSH
33581: LD_INT 22
33583: PUSH
33584: LD_INT 3
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 34
33593: PUSH
33594: LD_INT 48
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PPUSH
33605: CALL_OW 69
33609: AND
33610: PUSH
33611: LD_INT 22
33613: PUSH
33614: LD_INT 1
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 34
33623: PUSH
33624: LD_INT 8
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PPUSH
33635: CALL_OW 69
33639: NOT
33640: AND
33641: IFFALSE 33693
// begin wait ( 0 0$5 ) ;
33643: LD_INT 175
33645: PPUSH
33646: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33650: LD_INT 22
33652: PUSH
33653: LD_INT 3
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 34
33662: PUSH
33663: LD_INT 48
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PPUSH
33674: CALL_OW 69
33678: PUSH
33679: LD_INT 1
33681: ARRAY
33682: PPUSH
33683: LD_INT 60
33685: PPUSH
33686: LD_INT 95
33688: PPUSH
33689: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33693: LD_VAR 0 2
33697: PPUSH
33698: LD_VAR 0 3
33702: PPUSH
33703: LD_INT 18
33705: PPUSH
33706: CALL_OW 309
33710: IFFALSE 33770
// begin if GetSide ( unit ) = 1 then
33712: LD_VAR 0 1
33716: PPUSH
33717: CALL_OW 255
33721: PUSH
33722: LD_INT 1
33724: EQUAL
33725: IFFALSE 33741
// begin wait ( 0 0$6 ) ;
33727: LD_INT 210
33729: PPUSH
33730: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33734: LD_STRING Motherlode2
33736: PPUSH
33737: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33741: LD_VAR 0 1
33745: PPUSH
33746: CALL_OW 255
33750: PUSH
33751: LD_INT 8
33753: EQUAL
33754: IFFALSE 33770
// begin wait ( 0 0$6 ) ;
33756: LD_INT 210
33758: PPUSH
33759: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33763: LD_STRING Motherlode1
33765: PPUSH
33766: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33770: LD_VAR 0 1
33774: PPUSH
33775: CALL_OW 255
33779: PUSH
33780: LD_INT 3
33782: EQUAL
33783: IFFALSE 33804
// begin wait ( 0 0$5 ) ;
33785: LD_INT 175
33787: PPUSH
33788: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33792: LD_EXP 64
33796: PPUSH
33797: LD_STRING D18-Pla-1
33799: PPUSH
33800: CALL_OW 94
// end ; end ;
33804: PPOPN 3
33806: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33807: LD_VAR 0 1
33811: PUSH
33812: LD_INT 22
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 21
33824: PUSH
33825: LD_INT 1
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 23
33834: PUSH
33835: LD_INT 1
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: LIST
33846: PPUSH
33847: CALL_OW 69
33851: IN
33852: IFFALSE 33868
// lostCounter := lostCounter + 1 ;
33854: LD_ADDR_EXP 32
33858: PUSH
33859: LD_EXP 32
33863: PUSH
33864: LD_INT 1
33866: PLUS
33867: ST_TO_ADDR
// if un in behemothBuilders then
33868: LD_VAR 0 1
33872: PUSH
33873: LD_EXP 73
33877: IN
33878: IFFALSE 33898
// begin behemothBuilders := behemothBuilders diff un ;
33880: LD_ADDR_EXP 73
33884: PUSH
33885: LD_EXP 73
33889: PUSH
33890: LD_VAR 0 1
33894: DIFF
33895: ST_TO_ADDR
// exit ;
33896: GO 33928
// end ; if un = JMM then
33898: LD_VAR 0 1
33902: PUSH
33903: LD_EXP 39
33907: EQUAL
33908: IFFALSE 33919
// begin YouLost ( JMM ) ;
33910: LD_STRING JMM
33912: PPUSH
33913: CALL_OW 104
// exit ;
33917: GO 33928
// end ; MCE_UnitDestroyed ( un ) ;
33919: LD_VAR 0 1
33923: PPUSH
33924: CALL 62259 0 1
// end ;
33928: PPOPN 1
33930: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33931: LD_VAR 0 1
33935: PPUSH
33936: LD_VAR 0 2
33940: PPUSH
33941: CALL 64593 0 2
// end ;
33945: PPOPN 2
33947: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33948: LD_VAR 0 1
33952: PPUSH
33953: CALL 63661 0 1
// end ;
33957: PPOPN 1
33959: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33960: LD_VAR 0 1
33964: PUSH
33965: LD_INT 22
33967: PUSH
33968: LD_INT 8
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 30
33977: PUSH
33978: LD_INT 2
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 23
33987: PUSH
33988: LD_INT 3
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: LIST
33999: PPUSH
34000: CALL_OW 69
34004: IN
34005: IFFALSE 34032
// begin ComUpgrade ( building ) ;
34007: LD_VAR 0 1
34011: PPUSH
34012: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34016: LD_EXP 61
34020: PPUSH
34021: LD_VAR 0 1
34025: PPUSH
34026: CALL 73008 0 2
// exit ;
34030: GO 34041
// end ; MCE_BuildingComplete ( building ) ;
34032: LD_VAR 0 1
34036: PPUSH
34037: CALL 63902 0 1
// end ;
34041: PPOPN 1
34043: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34044: LD_VAR 0 1
34048: PPUSH
34049: LD_VAR 0 2
34053: PPUSH
34054: CALL 61955 0 2
// end ;
34058: PPOPN 2
34060: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34061: LD_VAR 0 1
34065: PPUSH
34066: LD_VAR 0 2
34070: PPUSH
34071: LD_VAR 0 3
34075: PPUSH
34076: LD_VAR 0 4
34080: PPUSH
34081: LD_VAR 0 5
34085: PPUSH
34086: CALL 61575 0 5
// end ;
34090: PPOPN 5
34092: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34093: LD_VAR 0 1
34097: PPUSH
34098: LD_VAR 0 2
34102: PPUSH
34103: CALL 61165 0 2
// end ;
34107: PPOPN 2
34109: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34110: LD_VAR 0 1
34114: PPUSH
34115: LD_VAR 0 2
34119: PPUSH
34120: LD_VAR 0 3
34124: PPUSH
34125: LD_VAR 0 4
34129: PPUSH
34130: CALL 61003 0 4
// end ;
34134: PPOPN 4
34136: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34137: LD_VAR 0 1
34141: PPUSH
34142: LD_VAR 0 2
34146: PPUSH
34147: LD_VAR 0 3
34151: PPUSH
34152: CALL 60778 0 3
// end ;
34156: PPOPN 3
34158: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34159: LD_VAR 0 1
34163: PPUSH
34164: LD_VAR 0 2
34168: PPUSH
34169: CALL 60663 0 2
// end ;
34173: PPOPN 2
34175: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34176: LD_VAR 0 1
34180: PPUSH
34181: LD_VAR 0 2
34185: PPUSH
34186: CALL 64854 0 2
// end ;
34190: PPOPN 2
34192: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34193: LD_VAR 0 1
34197: PPUSH
34198: CALL_OW 255
34202: PUSH
34203: LD_INT 4
34205: EQUAL
34206: PUSH
34207: LD_VAR 0 1
34211: PUSH
34212: LD_EXP 18
34216: PUSH
34217: LD_INT 1
34219: ARRAY
34220: IN
34221: AND
34222: PUSH
34223: LD_EXP 19
34227: AND
34228: IFFALSE 34247
// begin ComMoveXY ( driver , 61 , 93 ) ;
34230: LD_VAR 0 1
34234: PPUSH
34235: LD_INT 61
34237: PPUSH
34238: LD_INT 93
34240: PPUSH
34241: CALL_OW 111
// exit ;
34245: GO 34271
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34247: LD_VAR 0 1
34251: PPUSH
34252: LD_VAR 0 2
34256: PPUSH
34257: LD_VAR 0 3
34261: PPUSH
34262: LD_VAR 0 4
34266: PPUSH
34267: CALL 65070 0 4
// end ;
34271: PPOPN 4
34273: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34274: LD_VAR 0 1
34278: PPUSH
34279: LD_VAR 0 2
34283: PPUSH
34284: CALL 60472 0 2
// end ;
34288: PPOPN 2
34290: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34291: LD_VAR 0 1
34295: PPUSH
34296: CALL 115553 0 1
// end ; end_of_file
34300: PPOPN 1
34302: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34303: LD_EXP 15
34307: PUSH
34308: LD_INT 2
34310: EQUAL
34311: IFFALSE 34790
34313: GO 34315
34315: DISABLE
34316: LD_INT 0
34318: PPUSH
// begin time := 0 0$40 ;
34319: LD_ADDR_VAR 0 1
34323: PUSH
34324: LD_INT 1400
34326: ST_TO_ADDR
// repeat wait ( time ) ;
34327: LD_VAR 0 1
34331: PPUSH
34332: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34336: LD_INT 1
34338: PPUSH
34339: LD_INT 5
34341: PPUSH
34342: CALL_OW 12
34346: PPUSH
34347: LD_INT 106
34349: PPUSH
34350: LD_INT 150
34352: PPUSH
34353: LD_INT 19
34355: PPUSH
34356: LD_INT 1
34358: PPUSH
34359: CALL_OW 56
// time := time + 0 0$9 ;
34363: LD_ADDR_VAR 0 1
34367: PUSH
34368: LD_VAR 0 1
34372: PUSH
34373: LD_INT 315
34375: PLUS
34376: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34377: LD_INT 455
34379: PPUSH
34380: LD_INT 840
34382: PPUSH
34383: CALL_OW 12
34387: PPUSH
34388: CALL_OW 67
// if Prob ( 50 ) then
34392: LD_INT 50
34394: PPUSH
34395: CALL_OW 13
34399: IFFALSE 34428
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34401: LD_INT 1
34403: PPUSH
34404: LD_INT 5
34406: PPUSH
34407: CALL_OW 12
34411: PPUSH
34412: LD_INT 62
34414: PPUSH
34415: LD_INT 108
34417: PPUSH
34418: LD_INT 10
34420: PPUSH
34421: LD_INT 1
34423: PPUSH
34424: CALL_OW 56
// until missionStage > 4 ;
34428: LD_EXP 15
34432: PUSH
34433: LD_INT 4
34435: GREATER
34436: IFFALSE 34327
// repeat wait ( 0 0$1 ) ;
34438: LD_INT 35
34440: PPUSH
34441: CALL_OW 67
// until missionStage = 6 ;
34445: LD_EXP 15
34449: PUSH
34450: LD_INT 6
34452: EQUAL
34453: IFFALSE 34438
// time := 0 0$50 ;
34455: LD_ADDR_VAR 0 1
34459: PUSH
34460: LD_INT 1750
34462: ST_TO_ADDR
// repeat wait ( time ) ;
34463: LD_VAR 0 1
34467: PPUSH
34468: CALL_OW 67
// if Prob ( 50 ) then
34472: LD_INT 50
34474: PPUSH
34475: CALL_OW 13
34479: IFFALSE 34508
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34481: LD_INT 1
34483: PPUSH
34484: LD_INT 5
34486: PPUSH
34487: CALL_OW 12
34491: PPUSH
34492: LD_INT 106
34494: PPUSH
34495: LD_INT 89
34497: PPUSH
34498: LD_INT 45
34500: PPUSH
34501: LD_INT 1
34503: PPUSH
34504: CALL_OW 56
// time := time + 0 0$2 ;
34508: LD_ADDR_VAR 0 1
34512: PUSH
34513: LD_VAR 0 1
34517: PUSH
34518: LD_INT 70
34520: PLUS
34521: ST_TO_ADDR
// if Prob ( 30 ) then
34522: LD_INT 30
34524: PPUSH
34525: CALL_OW 13
34529: IFFALSE 34575
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34531: LD_INT 385
34533: PPUSH
34534: LD_INT 945
34536: PPUSH
34537: CALL_OW 12
34541: PPUSH
34542: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34546: LD_INT 1
34548: PPUSH
34549: LD_INT 5
34551: PPUSH
34552: CALL_OW 12
34556: PPUSH
34557: LD_INT 21
34559: PPUSH
34560: LD_INT 26
34562: PPUSH
34563: LD_INT 12
34565: PPUSH
34566: LD_INT 1
34568: PPUSH
34569: CALL_OW 56
// end else
34573: GO 34611
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34575: LD_INT 700
34577: PPUSH
34578: LD_INT 1225
34580: PPUSH
34581: CALL_OW 12
34585: PPUSH
34586: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34590: LD_INT 1
34592: PPUSH
34593: LD_INT 5
34595: PPUSH
34596: CALL_OW 12
34600: PPUSH
34601: LD_INT 16
34603: PPUSH
34604: LD_INT 1
34606: PPUSH
34607: CALL_OW 55
// end ; if Prob ( 50 ) then
34611: LD_INT 50
34613: PPUSH
34614: CALL_OW 13
34618: IFFALSE 34664
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34620: LD_INT 700
34622: PPUSH
34623: LD_INT 1050
34625: PPUSH
34626: CALL_OW 12
34630: PPUSH
34631: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34635: LD_INT 1
34637: PPUSH
34638: LD_INT 5
34640: PPUSH
34641: CALL_OW 12
34645: PPUSH
34646: LD_INT 181
34648: PPUSH
34649: LD_INT 218
34651: PPUSH
34652: LD_INT 16
34654: PPUSH
34655: LD_INT 1
34657: PPUSH
34658: CALL_OW 56
// end else
34662: GO 34700
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34664: LD_INT 350
34666: PPUSH
34667: LD_INT 525
34669: PPUSH
34670: CALL_OW 12
34674: PPUSH
34675: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34679: LD_INT 1
34681: PPUSH
34682: LD_INT 5
34684: PPUSH
34685: CALL_OW 12
34689: PPUSH
34690: LD_INT 15
34692: PPUSH
34693: LD_INT 1
34695: PPUSH
34696: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34700: LD_INT 45
34702: PUSH
34703: LD_INT 32
34705: PUSH
34706: LD_INT 25
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: LIST
34713: PUSH
34714: LD_OWVAR 67
34718: ARRAY
34719: PPUSH
34720: CALL_OW 13
34724: IFFALSE 34768
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34726: LD_INT 175
34728: PPUSH
34729: LD_INT 315
34731: PPUSH
34732: CALL_OW 12
34736: PPUSH
34737: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34741: LD_INT 1
34743: PPUSH
34744: LD_INT 5
34746: PPUSH
34747: CALL_OW 12
34751: PPUSH
34752: LD_INT 103
34754: PPUSH
34755: LD_INT 140
34757: PPUSH
34758: LD_INT 20
34760: PPUSH
34761: LD_INT 1
34763: PPUSH
34764: CALL_OW 56
// end ; if time > 1 1$20 then
34768: LD_VAR 0 1
34772: PUSH
34773: LD_INT 2800
34775: GREATER
34776: IFFALSE 34786
// time := 0 0$30 ;
34778: LD_ADDR_VAR 0 1
34782: PUSH
34783: LD_INT 1050
34785: ST_TO_ADDR
// until false ;
34786: LD_INT 0
34788: IFFALSE 34463
// end ; end_of_file
34790: PPOPN 1
34792: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34793: LD_EXP 13
34797: PUSH
34798: LD_EXP 15
34802: PUSH
34803: LD_INT 6
34805: GREATEREQUAL
34806: AND
34807: IFFALSE 34844
34809: GO 34811
34811: DISABLE
// begin enable ;
34812: ENABLE
// missionTime := missionTime + 0 0$1 ;
34813: LD_ADDR_EXP 14
34817: PUSH
34818: LD_EXP 14
34822: PUSH
34823: LD_INT 35
34825: PLUS
34826: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34827: LD_ADDR_OWVAR 47
34831: PUSH
34832: LD_STRING #Am15-1
34834: PUSH
34835: LD_EXP 14
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: ST_TO_ADDR
// end ; end_of_file
34844: END
// export function InitNature ; begin
34845: LD_INT 0
34847: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34848: LD_INT 3
34850: PPUSH
34851: LD_INT 3
34853: PPUSH
34854: LD_INT 2
34856: PPUSH
34857: LD_INT 1
34859: PPUSH
34860: LD_INT 1
34862: PPUSH
34863: LD_INT 0
34865: PPUSH
34866: LD_INT 0
34868: PPUSH
34869: LD_INT 20
34871: PPUSH
34872: LD_INT 0
34874: PPUSH
34875: CALL 97826 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34879: LD_INT 2
34881: PPUSH
34882: LD_INT 1
34884: PPUSH
34885: LD_INT 1
34887: PPUSH
34888: LD_INT 1
34890: PPUSH
34891: LD_INT 1
34893: PPUSH
34894: LD_INT 0
34896: PPUSH
34897: LD_INT 0
34899: PPUSH
34900: LD_INT 21
34902: PPUSH
34903: LD_INT 0
34905: PPUSH
34906: CALL 97826 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34910: LD_INT 4
34912: PPUSH
34913: LD_INT 1
34915: PPUSH
34916: LD_INT 2
34918: PPUSH
34919: LD_INT 4
34921: PPUSH
34922: LD_INT 2
34924: PPUSH
34925: LD_INT 1
34927: PPUSH
34928: LD_INT 0
34930: PPUSH
34931: LD_INT 22
34933: PPUSH
34934: LD_INT 0
34936: PPUSH
34937: CALL 97826 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34941: LD_INT 0
34943: PPUSH
34944: LD_INT 0
34946: PPUSH
34947: LD_INT 0
34949: PPUSH
34950: LD_INT 0
34952: PPUSH
34953: LD_INT 0
34955: PPUSH
34956: LD_INT 0
34958: PPUSH
34959: LD_INT 9
34961: PPUSH
34962: LD_INT 0
34964: PPUSH
34965: LD_INT 23
34967: PPUSH
34968: CALL 97826 0 9
// end ; end_of_file
34972: LD_VAR 0 1
34976: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
34977: LD_INT 0
34979: PPUSH
// ar_miner := 81 ;
34980: LD_ADDR_EXP 102
34984: PUSH
34985: LD_INT 81
34987: ST_TO_ADDR
// ar_crane := 88 ;
34988: LD_ADDR_EXP 101
34992: PUSH
34993: LD_INT 88
34995: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34996: LD_ADDR_EXP 96
35000: PUSH
35001: LD_INT 89
35003: ST_TO_ADDR
// us_hack := 99 ;
35004: LD_ADDR_EXP 97
35008: PUSH
35009: LD_INT 99
35011: ST_TO_ADDR
// us_artillery := 97 ;
35012: LD_ADDR_EXP 98
35016: PUSH
35017: LD_INT 97
35019: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35020: LD_ADDR_EXP 99
35024: PUSH
35025: LD_INT 91
35027: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
35028: LD_ADDR_EXP 100
35032: PUSH
35033: LD_INT 92
35035: ST_TO_ADDR
// ru_radar := 98 ;
35036: LD_ADDR_EXP 95
35040: PUSH
35041: LD_INT 98
35043: ST_TO_ADDR
// tech_Artillery := 80 ;
35044: LD_ADDR_EXP 103
35048: PUSH
35049: LD_INT 80
35051: ST_TO_ADDR
// tech_RadMat := 81 ;
35052: LD_ADDR_EXP 104
35056: PUSH
35057: LD_INT 81
35059: ST_TO_ADDR
// tech_BasicTools := 82 ;
35060: LD_ADDR_EXP 105
35064: PUSH
35065: LD_INT 82
35067: ST_TO_ADDR
// tech_Cargo := 83 ;
35068: LD_ADDR_EXP 106
35072: PUSH
35073: LD_INT 83
35075: ST_TO_ADDR
// tech_Track := 84 ;
35076: LD_ADDR_EXP 107
35080: PUSH
35081: LD_INT 84
35083: ST_TO_ADDR
// tech_Crane := 85 ;
35084: LD_ADDR_EXP 108
35088: PUSH
35089: LD_INT 85
35091: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35092: LD_ADDR_EXP 109
35096: PUSH
35097: LD_INT 86
35099: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35100: LD_ADDR_EXP 110
35104: PUSH
35105: LD_INT 87
35107: ST_TO_ADDR
// end ;
35108: LD_VAR 0 1
35112: RET
// every 1 do
35113: GO 35115
35115: DISABLE
// InitGlobalVariables ; end_of_file
35116: CALL 34977 0 0
35120: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35121: LD_INT 0
35123: PPUSH
35124: PPUSH
// skirmish := false ;
35125: LD_ADDR_EXP 111
35129: PUSH
35130: LD_INT 0
35132: ST_TO_ADDR
// debug_mc := false ;
35133: LD_ADDR_EXP 112
35137: PUSH
35138: LD_INT 0
35140: ST_TO_ADDR
// mc_bases := [ ] ;
35141: LD_ADDR_EXP 113
35145: PUSH
35146: EMPTY
35147: ST_TO_ADDR
// mc_sides := [ ] ;
35148: LD_ADDR_EXP 139
35152: PUSH
35153: EMPTY
35154: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35155: LD_ADDR_EXP 114
35159: PUSH
35160: EMPTY
35161: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35162: LD_ADDR_EXP 115
35166: PUSH
35167: EMPTY
35168: ST_TO_ADDR
// mc_need_heal := [ ] ;
35169: LD_ADDR_EXP 116
35173: PUSH
35174: EMPTY
35175: ST_TO_ADDR
// mc_healers := [ ] ;
35176: LD_ADDR_EXP 117
35180: PUSH
35181: EMPTY
35182: ST_TO_ADDR
// mc_build_list := [ ] ;
35183: LD_ADDR_EXP 118
35187: PUSH
35188: EMPTY
35189: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35190: LD_ADDR_EXP 145
35194: PUSH
35195: EMPTY
35196: ST_TO_ADDR
// mc_builders := [ ] ;
35197: LD_ADDR_EXP 119
35201: PUSH
35202: EMPTY
35203: ST_TO_ADDR
// mc_construct_list := [ ] ;
35204: LD_ADDR_EXP 120
35208: PUSH
35209: EMPTY
35210: ST_TO_ADDR
// mc_turret_list := [ ] ;
35211: LD_ADDR_EXP 121
35215: PUSH
35216: EMPTY
35217: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35218: LD_ADDR_EXP 122
35222: PUSH
35223: EMPTY
35224: ST_TO_ADDR
// mc_miners := [ ] ;
35225: LD_ADDR_EXP 127
35229: PUSH
35230: EMPTY
35231: ST_TO_ADDR
// mc_mines := [ ] ;
35232: LD_ADDR_EXP 126
35236: PUSH
35237: EMPTY
35238: ST_TO_ADDR
// mc_minefields := [ ] ;
35239: LD_ADDR_EXP 128
35243: PUSH
35244: EMPTY
35245: ST_TO_ADDR
// mc_crates := [ ] ;
35246: LD_ADDR_EXP 129
35250: PUSH
35251: EMPTY
35252: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35253: LD_ADDR_EXP 130
35257: PUSH
35258: EMPTY
35259: ST_TO_ADDR
// mc_crates_area := [ ] ;
35260: LD_ADDR_EXP 131
35264: PUSH
35265: EMPTY
35266: ST_TO_ADDR
// mc_vehicles := [ ] ;
35267: LD_ADDR_EXP 132
35271: PUSH
35272: EMPTY
35273: ST_TO_ADDR
// mc_attack := [ ] ;
35274: LD_ADDR_EXP 133
35278: PUSH
35279: EMPTY
35280: ST_TO_ADDR
// mc_produce := [ ] ;
35281: LD_ADDR_EXP 134
35285: PUSH
35286: EMPTY
35287: ST_TO_ADDR
// mc_defender := [ ] ;
35288: LD_ADDR_EXP 135
35292: PUSH
35293: EMPTY
35294: ST_TO_ADDR
// mc_parking := [ ] ;
35295: LD_ADDR_EXP 137
35299: PUSH
35300: EMPTY
35301: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35302: LD_ADDR_EXP 123
35306: PUSH
35307: EMPTY
35308: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35309: LD_ADDR_EXP 125
35313: PUSH
35314: EMPTY
35315: ST_TO_ADDR
// mc_scan := [ ] ;
35316: LD_ADDR_EXP 136
35320: PUSH
35321: EMPTY
35322: ST_TO_ADDR
// mc_scan_area := [ ] ;
35323: LD_ADDR_EXP 138
35327: PUSH
35328: EMPTY
35329: ST_TO_ADDR
// mc_tech := [ ] ;
35330: LD_ADDR_EXP 140
35334: PUSH
35335: EMPTY
35336: ST_TO_ADDR
// mc_class := [ ] ;
35337: LD_ADDR_EXP 154
35341: PUSH
35342: EMPTY
35343: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35344: LD_ADDR_EXP 155
35348: PUSH
35349: EMPTY
35350: ST_TO_ADDR
// end ;
35351: LD_VAR 0 1
35355: RET
// export function MC_Kill ( base ) ; begin
35356: LD_INT 0
35358: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35359: LD_ADDR_EXP 113
35363: PUSH
35364: LD_EXP 113
35368: PPUSH
35369: LD_VAR 0 1
35373: PPUSH
35374: EMPTY
35375: PPUSH
35376: CALL_OW 1
35380: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35381: LD_ADDR_EXP 114
35385: PUSH
35386: LD_EXP 114
35390: PPUSH
35391: LD_VAR 0 1
35395: PPUSH
35396: EMPTY
35397: PPUSH
35398: CALL_OW 1
35402: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35403: LD_ADDR_EXP 115
35407: PUSH
35408: LD_EXP 115
35412: PPUSH
35413: LD_VAR 0 1
35417: PPUSH
35418: EMPTY
35419: PPUSH
35420: CALL_OW 1
35424: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35425: LD_ADDR_EXP 116
35429: PUSH
35430: LD_EXP 116
35434: PPUSH
35435: LD_VAR 0 1
35439: PPUSH
35440: EMPTY
35441: PPUSH
35442: CALL_OW 1
35446: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35447: LD_ADDR_EXP 117
35451: PUSH
35452: LD_EXP 117
35456: PPUSH
35457: LD_VAR 0 1
35461: PPUSH
35462: EMPTY
35463: PPUSH
35464: CALL_OW 1
35468: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35469: LD_ADDR_EXP 118
35473: PUSH
35474: LD_EXP 118
35478: PPUSH
35479: LD_VAR 0 1
35483: PPUSH
35484: EMPTY
35485: PPUSH
35486: CALL_OW 1
35490: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35491: LD_ADDR_EXP 119
35495: PUSH
35496: LD_EXP 119
35500: PPUSH
35501: LD_VAR 0 1
35505: PPUSH
35506: EMPTY
35507: PPUSH
35508: CALL_OW 1
35512: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35513: LD_ADDR_EXP 120
35517: PUSH
35518: LD_EXP 120
35522: PPUSH
35523: LD_VAR 0 1
35527: PPUSH
35528: EMPTY
35529: PPUSH
35530: CALL_OW 1
35534: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35535: LD_ADDR_EXP 121
35539: PUSH
35540: LD_EXP 121
35544: PPUSH
35545: LD_VAR 0 1
35549: PPUSH
35550: EMPTY
35551: PPUSH
35552: CALL_OW 1
35556: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35557: LD_ADDR_EXP 122
35561: PUSH
35562: LD_EXP 122
35566: PPUSH
35567: LD_VAR 0 1
35571: PPUSH
35572: EMPTY
35573: PPUSH
35574: CALL_OW 1
35578: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35579: LD_ADDR_EXP 123
35583: PUSH
35584: LD_EXP 123
35588: PPUSH
35589: LD_VAR 0 1
35593: PPUSH
35594: EMPTY
35595: PPUSH
35596: CALL_OW 1
35600: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35601: LD_ADDR_EXP 124
35605: PUSH
35606: LD_EXP 124
35610: PPUSH
35611: LD_VAR 0 1
35615: PPUSH
35616: LD_INT 0
35618: PPUSH
35619: CALL_OW 1
35623: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35624: LD_ADDR_EXP 125
35628: PUSH
35629: LD_EXP 125
35633: PPUSH
35634: LD_VAR 0 1
35638: PPUSH
35639: EMPTY
35640: PPUSH
35641: CALL_OW 1
35645: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35646: LD_ADDR_EXP 126
35650: PUSH
35651: LD_EXP 126
35655: PPUSH
35656: LD_VAR 0 1
35660: PPUSH
35661: EMPTY
35662: PPUSH
35663: CALL_OW 1
35667: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35668: LD_ADDR_EXP 127
35672: PUSH
35673: LD_EXP 127
35677: PPUSH
35678: LD_VAR 0 1
35682: PPUSH
35683: EMPTY
35684: PPUSH
35685: CALL_OW 1
35689: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35690: LD_ADDR_EXP 128
35694: PUSH
35695: LD_EXP 128
35699: PPUSH
35700: LD_VAR 0 1
35704: PPUSH
35705: EMPTY
35706: PPUSH
35707: CALL_OW 1
35711: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35712: LD_ADDR_EXP 129
35716: PUSH
35717: LD_EXP 129
35721: PPUSH
35722: LD_VAR 0 1
35726: PPUSH
35727: EMPTY
35728: PPUSH
35729: CALL_OW 1
35733: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35734: LD_ADDR_EXP 130
35738: PUSH
35739: LD_EXP 130
35743: PPUSH
35744: LD_VAR 0 1
35748: PPUSH
35749: EMPTY
35750: PPUSH
35751: CALL_OW 1
35755: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35756: LD_ADDR_EXP 131
35760: PUSH
35761: LD_EXP 131
35765: PPUSH
35766: LD_VAR 0 1
35770: PPUSH
35771: EMPTY
35772: PPUSH
35773: CALL_OW 1
35777: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35778: LD_ADDR_EXP 132
35782: PUSH
35783: LD_EXP 132
35787: PPUSH
35788: LD_VAR 0 1
35792: PPUSH
35793: EMPTY
35794: PPUSH
35795: CALL_OW 1
35799: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35800: LD_ADDR_EXP 133
35804: PUSH
35805: LD_EXP 133
35809: PPUSH
35810: LD_VAR 0 1
35814: PPUSH
35815: EMPTY
35816: PPUSH
35817: CALL_OW 1
35821: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35822: LD_ADDR_EXP 134
35826: PUSH
35827: LD_EXP 134
35831: PPUSH
35832: LD_VAR 0 1
35836: PPUSH
35837: EMPTY
35838: PPUSH
35839: CALL_OW 1
35843: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35844: LD_ADDR_EXP 135
35848: PUSH
35849: LD_EXP 135
35853: PPUSH
35854: LD_VAR 0 1
35858: PPUSH
35859: EMPTY
35860: PPUSH
35861: CALL_OW 1
35865: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35866: LD_ADDR_EXP 136
35870: PUSH
35871: LD_EXP 136
35875: PPUSH
35876: LD_VAR 0 1
35880: PPUSH
35881: EMPTY
35882: PPUSH
35883: CALL_OW 1
35887: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35888: LD_ADDR_EXP 137
35892: PUSH
35893: LD_EXP 137
35897: PPUSH
35898: LD_VAR 0 1
35902: PPUSH
35903: EMPTY
35904: PPUSH
35905: CALL_OW 1
35909: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35910: LD_ADDR_EXP 138
35914: PUSH
35915: LD_EXP 138
35919: PPUSH
35920: LD_VAR 0 1
35924: PPUSH
35925: EMPTY
35926: PPUSH
35927: CALL_OW 1
35931: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35932: LD_ADDR_EXP 140
35936: PUSH
35937: LD_EXP 140
35941: PPUSH
35942: LD_VAR 0 1
35946: PPUSH
35947: EMPTY
35948: PPUSH
35949: CALL_OW 1
35953: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35954: LD_ADDR_EXP 142
35958: PUSH
35959: LD_EXP 142
35963: PPUSH
35964: LD_VAR 0 1
35968: PPUSH
35969: EMPTY
35970: PPUSH
35971: CALL_OW 1
35975: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35976: LD_ADDR_EXP 143
35980: PUSH
35981: LD_EXP 143
35985: PPUSH
35986: LD_VAR 0 1
35990: PPUSH
35991: EMPTY
35992: PPUSH
35993: CALL_OW 1
35997: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35998: LD_ADDR_EXP 144
36002: PUSH
36003: LD_EXP 144
36007: PPUSH
36008: LD_VAR 0 1
36012: PPUSH
36013: EMPTY
36014: PPUSH
36015: CALL_OW 1
36019: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36020: LD_ADDR_EXP 145
36024: PUSH
36025: LD_EXP 145
36029: PPUSH
36030: LD_VAR 0 1
36034: PPUSH
36035: EMPTY
36036: PPUSH
36037: CALL_OW 1
36041: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36042: LD_ADDR_EXP 146
36046: PUSH
36047: LD_EXP 146
36051: PPUSH
36052: LD_VAR 0 1
36056: PPUSH
36057: EMPTY
36058: PPUSH
36059: CALL_OW 1
36063: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36064: LD_ADDR_EXP 147
36068: PUSH
36069: LD_EXP 147
36073: PPUSH
36074: LD_VAR 0 1
36078: PPUSH
36079: EMPTY
36080: PPUSH
36081: CALL_OW 1
36085: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36086: LD_ADDR_EXP 148
36090: PUSH
36091: LD_EXP 148
36095: PPUSH
36096: LD_VAR 0 1
36100: PPUSH
36101: EMPTY
36102: PPUSH
36103: CALL_OW 1
36107: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36108: LD_ADDR_EXP 149
36112: PUSH
36113: LD_EXP 149
36117: PPUSH
36118: LD_VAR 0 1
36122: PPUSH
36123: EMPTY
36124: PPUSH
36125: CALL_OW 1
36129: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36130: LD_ADDR_EXP 150
36134: PUSH
36135: LD_EXP 150
36139: PPUSH
36140: LD_VAR 0 1
36144: PPUSH
36145: EMPTY
36146: PPUSH
36147: CALL_OW 1
36151: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36152: LD_ADDR_EXP 151
36156: PUSH
36157: LD_EXP 151
36161: PPUSH
36162: LD_VAR 0 1
36166: PPUSH
36167: EMPTY
36168: PPUSH
36169: CALL_OW 1
36173: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36174: LD_ADDR_EXP 152
36178: PUSH
36179: LD_EXP 152
36183: PPUSH
36184: LD_VAR 0 1
36188: PPUSH
36189: EMPTY
36190: PPUSH
36191: CALL_OW 1
36195: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36196: LD_ADDR_EXP 153
36200: PUSH
36201: LD_EXP 153
36205: PPUSH
36206: LD_VAR 0 1
36210: PPUSH
36211: EMPTY
36212: PPUSH
36213: CALL_OW 1
36217: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36218: LD_ADDR_EXP 154
36222: PUSH
36223: LD_EXP 154
36227: PPUSH
36228: LD_VAR 0 1
36232: PPUSH
36233: EMPTY
36234: PPUSH
36235: CALL_OW 1
36239: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36240: LD_ADDR_EXP 155
36244: PUSH
36245: LD_EXP 155
36249: PPUSH
36250: LD_VAR 0 1
36254: PPUSH
36255: LD_INT 0
36257: PPUSH
36258: CALL_OW 1
36262: ST_TO_ADDR
// end ;
36263: LD_VAR 0 2
36267: RET
// export function MC_Add ( side , units ) ; var base ; begin
36268: LD_INT 0
36270: PPUSH
36271: PPUSH
// base := mc_bases + 1 ;
36272: LD_ADDR_VAR 0 4
36276: PUSH
36277: LD_EXP 113
36281: PUSH
36282: LD_INT 1
36284: PLUS
36285: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36286: LD_ADDR_EXP 139
36290: PUSH
36291: LD_EXP 139
36295: PPUSH
36296: LD_VAR 0 4
36300: PPUSH
36301: LD_VAR 0 1
36305: PPUSH
36306: CALL_OW 1
36310: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36311: LD_ADDR_EXP 113
36315: PUSH
36316: LD_EXP 113
36320: PPUSH
36321: LD_VAR 0 4
36325: PPUSH
36326: LD_VAR 0 2
36330: PPUSH
36331: CALL_OW 1
36335: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36336: LD_ADDR_EXP 114
36340: PUSH
36341: LD_EXP 114
36345: PPUSH
36346: LD_VAR 0 4
36350: PPUSH
36351: EMPTY
36352: PPUSH
36353: CALL_OW 1
36357: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36358: LD_ADDR_EXP 115
36362: PUSH
36363: LD_EXP 115
36367: PPUSH
36368: LD_VAR 0 4
36372: PPUSH
36373: EMPTY
36374: PPUSH
36375: CALL_OW 1
36379: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36380: LD_ADDR_EXP 116
36384: PUSH
36385: LD_EXP 116
36389: PPUSH
36390: LD_VAR 0 4
36394: PPUSH
36395: EMPTY
36396: PPUSH
36397: CALL_OW 1
36401: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36402: LD_ADDR_EXP 117
36406: PUSH
36407: LD_EXP 117
36411: PPUSH
36412: LD_VAR 0 4
36416: PPUSH
36417: EMPTY
36418: PPUSH
36419: CALL_OW 1
36423: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36424: LD_ADDR_EXP 118
36428: PUSH
36429: LD_EXP 118
36433: PPUSH
36434: LD_VAR 0 4
36438: PPUSH
36439: EMPTY
36440: PPUSH
36441: CALL_OW 1
36445: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36446: LD_ADDR_EXP 119
36450: PUSH
36451: LD_EXP 119
36455: PPUSH
36456: LD_VAR 0 4
36460: PPUSH
36461: EMPTY
36462: PPUSH
36463: CALL_OW 1
36467: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36468: LD_ADDR_EXP 120
36472: PUSH
36473: LD_EXP 120
36477: PPUSH
36478: LD_VAR 0 4
36482: PPUSH
36483: EMPTY
36484: PPUSH
36485: CALL_OW 1
36489: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36490: LD_ADDR_EXP 121
36494: PUSH
36495: LD_EXP 121
36499: PPUSH
36500: LD_VAR 0 4
36504: PPUSH
36505: EMPTY
36506: PPUSH
36507: CALL_OW 1
36511: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36512: LD_ADDR_EXP 122
36516: PUSH
36517: LD_EXP 122
36521: PPUSH
36522: LD_VAR 0 4
36526: PPUSH
36527: EMPTY
36528: PPUSH
36529: CALL_OW 1
36533: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36534: LD_ADDR_EXP 123
36538: PUSH
36539: LD_EXP 123
36543: PPUSH
36544: LD_VAR 0 4
36548: PPUSH
36549: EMPTY
36550: PPUSH
36551: CALL_OW 1
36555: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36556: LD_ADDR_EXP 124
36560: PUSH
36561: LD_EXP 124
36565: PPUSH
36566: LD_VAR 0 4
36570: PPUSH
36571: LD_INT 0
36573: PPUSH
36574: CALL_OW 1
36578: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36579: LD_ADDR_EXP 125
36583: PUSH
36584: LD_EXP 125
36588: PPUSH
36589: LD_VAR 0 4
36593: PPUSH
36594: EMPTY
36595: PPUSH
36596: CALL_OW 1
36600: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36601: LD_ADDR_EXP 126
36605: PUSH
36606: LD_EXP 126
36610: PPUSH
36611: LD_VAR 0 4
36615: PPUSH
36616: EMPTY
36617: PPUSH
36618: CALL_OW 1
36622: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36623: LD_ADDR_EXP 127
36627: PUSH
36628: LD_EXP 127
36632: PPUSH
36633: LD_VAR 0 4
36637: PPUSH
36638: EMPTY
36639: PPUSH
36640: CALL_OW 1
36644: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36645: LD_ADDR_EXP 128
36649: PUSH
36650: LD_EXP 128
36654: PPUSH
36655: LD_VAR 0 4
36659: PPUSH
36660: EMPTY
36661: PPUSH
36662: CALL_OW 1
36666: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36667: LD_ADDR_EXP 129
36671: PUSH
36672: LD_EXP 129
36676: PPUSH
36677: LD_VAR 0 4
36681: PPUSH
36682: EMPTY
36683: PPUSH
36684: CALL_OW 1
36688: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36689: LD_ADDR_EXP 130
36693: PUSH
36694: LD_EXP 130
36698: PPUSH
36699: LD_VAR 0 4
36703: PPUSH
36704: EMPTY
36705: PPUSH
36706: CALL_OW 1
36710: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36711: LD_ADDR_EXP 131
36715: PUSH
36716: LD_EXP 131
36720: PPUSH
36721: LD_VAR 0 4
36725: PPUSH
36726: EMPTY
36727: PPUSH
36728: CALL_OW 1
36732: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36733: LD_ADDR_EXP 132
36737: PUSH
36738: LD_EXP 132
36742: PPUSH
36743: LD_VAR 0 4
36747: PPUSH
36748: EMPTY
36749: PPUSH
36750: CALL_OW 1
36754: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36755: LD_ADDR_EXP 133
36759: PUSH
36760: LD_EXP 133
36764: PPUSH
36765: LD_VAR 0 4
36769: PPUSH
36770: EMPTY
36771: PPUSH
36772: CALL_OW 1
36776: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36777: LD_ADDR_EXP 134
36781: PUSH
36782: LD_EXP 134
36786: PPUSH
36787: LD_VAR 0 4
36791: PPUSH
36792: EMPTY
36793: PPUSH
36794: CALL_OW 1
36798: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36799: LD_ADDR_EXP 135
36803: PUSH
36804: LD_EXP 135
36808: PPUSH
36809: LD_VAR 0 4
36813: PPUSH
36814: EMPTY
36815: PPUSH
36816: CALL_OW 1
36820: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36821: LD_ADDR_EXP 136
36825: PUSH
36826: LD_EXP 136
36830: PPUSH
36831: LD_VAR 0 4
36835: PPUSH
36836: EMPTY
36837: PPUSH
36838: CALL_OW 1
36842: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36843: LD_ADDR_EXP 137
36847: PUSH
36848: LD_EXP 137
36852: PPUSH
36853: LD_VAR 0 4
36857: PPUSH
36858: EMPTY
36859: PPUSH
36860: CALL_OW 1
36864: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36865: LD_ADDR_EXP 138
36869: PUSH
36870: LD_EXP 138
36874: PPUSH
36875: LD_VAR 0 4
36879: PPUSH
36880: EMPTY
36881: PPUSH
36882: CALL_OW 1
36886: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36887: LD_ADDR_EXP 140
36891: PUSH
36892: LD_EXP 140
36896: PPUSH
36897: LD_VAR 0 4
36901: PPUSH
36902: EMPTY
36903: PPUSH
36904: CALL_OW 1
36908: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36909: LD_ADDR_EXP 142
36913: PUSH
36914: LD_EXP 142
36918: PPUSH
36919: LD_VAR 0 4
36923: PPUSH
36924: EMPTY
36925: PPUSH
36926: CALL_OW 1
36930: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36931: LD_ADDR_EXP 143
36935: PUSH
36936: LD_EXP 143
36940: PPUSH
36941: LD_VAR 0 4
36945: PPUSH
36946: EMPTY
36947: PPUSH
36948: CALL_OW 1
36952: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36953: LD_ADDR_EXP 144
36957: PUSH
36958: LD_EXP 144
36962: PPUSH
36963: LD_VAR 0 4
36967: PPUSH
36968: EMPTY
36969: PPUSH
36970: CALL_OW 1
36974: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36975: LD_ADDR_EXP 145
36979: PUSH
36980: LD_EXP 145
36984: PPUSH
36985: LD_VAR 0 4
36989: PPUSH
36990: EMPTY
36991: PPUSH
36992: CALL_OW 1
36996: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36997: LD_ADDR_EXP 146
37001: PUSH
37002: LD_EXP 146
37006: PPUSH
37007: LD_VAR 0 4
37011: PPUSH
37012: EMPTY
37013: PPUSH
37014: CALL_OW 1
37018: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37019: LD_ADDR_EXP 147
37023: PUSH
37024: LD_EXP 147
37028: PPUSH
37029: LD_VAR 0 4
37033: PPUSH
37034: EMPTY
37035: PPUSH
37036: CALL_OW 1
37040: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37041: LD_ADDR_EXP 148
37045: PUSH
37046: LD_EXP 148
37050: PPUSH
37051: LD_VAR 0 4
37055: PPUSH
37056: EMPTY
37057: PPUSH
37058: CALL_OW 1
37062: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37063: LD_ADDR_EXP 149
37067: PUSH
37068: LD_EXP 149
37072: PPUSH
37073: LD_VAR 0 4
37077: PPUSH
37078: EMPTY
37079: PPUSH
37080: CALL_OW 1
37084: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37085: LD_ADDR_EXP 150
37089: PUSH
37090: LD_EXP 150
37094: PPUSH
37095: LD_VAR 0 4
37099: PPUSH
37100: EMPTY
37101: PPUSH
37102: CALL_OW 1
37106: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37107: LD_ADDR_EXP 151
37111: PUSH
37112: LD_EXP 151
37116: PPUSH
37117: LD_VAR 0 4
37121: PPUSH
37122: EMPTY
37123: PPUSH
37124: CALL_OW 1
37128: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37129: LD_ADDR_EXP 152
37133: PUSH
37134: LD_EXP 152
37138: PPUSH
37139: LD_VAR 0 4
37143: PPUSH
37144: EMPTY
37145: PPUSH
37146: CALL_OW 1
37150: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37151: LD_ADDR_EXP 153
37155: PUSH
37156: LD_EXP 153
37160: PPUSH
37161: LD_VAR 0 4
37165: PPUSH
37166: EMPTY
37167: PPUSH
37168: CALL_OW 1
37172: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37173: LD_ADDR_EXP 154
37177: PUSH
37178: LD_EXP 154
37182: PPUSH
37183: LD_VAR 0 4
37187: PPUSH
37188: EMPTY
37189: PPUSH
37190: CALL_OW 1
37194: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37195: LD_ADDR_EXP 155
37199: PUSH
37200: LD_EXP 155
37204: PPUSH
37205: LD_VAR 0 4
37209: PPUSH
37210: LD_INT 0
37212: PPUSH
37213: CALL_OW 1
37217: ST_TO_ADDR
// result := base ;
37218: LD_ADDR_VAR 0 3
37222: PUSH
37223: LD_VAR 0 4
37227: ST_TO_ADDR
// end ;
37228: LD_VAR 0 3
37232: RET
// export function MC_Start ( ) ; var i ; begin
37233: LD_INT 0
37235: PPUSH
37236: PPUSH
// for i = 1 to mc_bases do
37237: LD_ADDR_VAR 0 2
37241: PUSH
37242: DOUBLE
37243: LD_INT 1
37245: DEC
37246: ST_TO_ADDR
37247: LD_EXP 113
37251: PUSH
37252: FOR_TO
37253: IFFALSE 38330
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37255: LD_ADDR_EXP 113
37259: PUSH
37260: LD_EXP 113
37264: PPUSH
37265: LD_VAR 0 2
37269: PPUSH
37270: LD_EXP 113
37274: PUSH
37275: LD_VAR 0 2
37279: ARRAY
37280: PUSH
37281: LD_INT 0
37283: DIFF
37284: PPUSH
37285: CALL_OW 1
37289: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37290: LD_ADDR_EXP 114
37294: PUSH
37295: LD_EXP 114
37299: PPUSH
37300: LD_VAR 0 2
37304: PPUSH
37305: EMPTY
37306: PPUSH
37307: CALL_OW 1
37311: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37312: LD_ADDR_EXP 115
37316: PUSH
37317: LD_EXP 115
37321: PPUSH
37322: LD_VAR 0 2
37326: PPUSH
37327: EMPTY
37328: PPUSH
37329: CALL_OW 1
37333: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37334: LD_ADDR_EXP 116
37338: PUSH
37339: LD_EXP 116
37343: PPUSH
37344: LD_VAR 0 2
37348: PPUSH
37349: EMPTY
37350: PPUSH
37351: CALL_OW 1
37355: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37356: LD_ADDR_EXP 117
37360: PUSH
37361: LD_EXP 117
37365: PPUSH
37366: LD_VAR 0 2
37370: PPUSH
37371: EMPTY
37372: PUSH
37373: EMPTY
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PPUSH
37379: CALL_OW 1
37383: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37384: LD_ADDR_EXP 118
37388: PUSH
37389: LD_EXP 118
37393: PPUSH
37394: LD_VAR 0 2
37398: PPUSH
37399: EMPTY
37400: PPUSH
37401: CALL_OW 1
37405: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37406: LD_ADDR_EXP 145
37410: PUSH
37411: LD_EXP 145
37415: PPUSH
37416: LD_VAR 0 2
37420: PPUSH
37421: EMPTY
37422: PPUSH
37423: CALL_OW 1
37427: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37428: LD_ADDR_EXP 119
37432: PUSH
37433: LD_EXP 119
37437: PPUSH
37438: LD_VAR 0 2
37442: PPUSH
37443: EMPTY
37444: PPUSH
37445: CALL_OW 1
37449: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37450: LD_ADDR_EXP 120
37454: PUSH
37455: LD_EXP 120
37459: PPUSH
37460: LD_VAR 0 2
37464: PPUSH
37465: EMPTY
37466: PPUSH
37467: CALL_OW 1
37471: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37472: LD_ADDR_EXP 121
37476: PUSH
37477: LD_EXP 121
37481: PPUSH
37482: LD_VAR 0 2
37486: PPUSH
37487: LD_EXP 113
37491: PUSH
37492: LD_VAR 0 2
37496: ARRAY
37497: PPUSH
37498: LD_INT 2
37500: PUSH
37501: LD_INT 30
37503: PUSH
37504: LD_INT 32
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 30
37513: PUSH
37514: LD_INT 33
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: LIST
37525: PPUSH
37526: CALL_OW 72
37530: PPUSH
37531: CALL_OW 1
37535: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37536: LD_ADDR_EXP 122
37540: PUSH
37541: LD_EXP 122
37545: PPUSH
37546: LD_VAR 0 2
37550: PPUSH
37551: LD_EXP 113
37555: PUSH
37556: LD_VAR 0 2
37560: ARRAY
37561: PPUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 30
37567: PUSH
37568: LD_INT 32
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 30
37577: PUSH
37578: LD_INT 31
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: LIST
37589: PUSH
37590: LD_INT 58
37592: PUSH
37593: EMPTY
37594: LIST
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PPUSH
37600: CALL_OW 72
37604: PPUSH
37605: CALL_OW 1
37609: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37610: LD_ADDR_EXP 123
37614: PUSH
37615: LD_EXP 123
37619: PPUSH
37620: LD_VAR 0 2
37624: PPUSH
37625: EMPTY
37626: PPUSH
37627: CALL_OW 1
37631: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37632: LD_ADDR_EXP 127
37636: PUSH
37637: LD_EXP 127
37641: PPUSH
37642: LD_VAR 0 2
37646: PPUSH
37647: EMPTY
37648: PPUSH
37649: CALL_OW 1
37653: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37654: LD_ADDR_EXP 126
37658: PUSH
37659: LD_EXP 126
37663: PPUSH
37664: LD_VAR 0 2
37668: PPUSH
37669: EMPTY
37670: PPUSH
37671: CALL_OW 1
37675: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37676: LD_ADDR_EXP 128
37680: PUSH
37681: LD_EXP 128
37685: PPUSH
37686: LD_VAR 0 2
37690: PPUSH
37691: EMPTY
37692: PPUSH
37693: CALL_OW 1
37697: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37698: LD_ADDR_EXP 129
37702: PUSH
37703: LD_EXP 129
37707: PPUSH
37708: LD_VAR 0 2
37712: PPUSH
37713: EMPTY
37714: PPUSH
37715: CALL_OW 1
37719: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37720: LD_ADDR_EXP 130
37724: PUSH
37725: LD_EXP 130
37729: PPUSH
37730: LD_VAR 0 2
37734: PPUSH
37735: EMPTY
37736: PPUSH
37737: CALL_OW 1
37741: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37742: LD_ADDR_EXP 131
37746: PUSH
37747: LD_EXP 131
37751: PPUSH
37752: LD_VAR 0 2
37756: PPUSH
37757: EMPTY
37758: PPUSH
37759: CALL_OW 1
37763: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37764: LD_ADDR_EXP 132
37768: PUSH
37769: LD_EXP 132
37773: PPUSH
37774: LD_VAR 0 2
37778: PPUSH
37779: EMPTY
37780: PPUSH
37781: CALL_OW 1
37785: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37786: LD_ADDR_EXP 133
37790: PUSH
37791: LD_EXP 133
37795: PPUSH
37796: LD_VAR 0 2
37800: PPUSH
37801: EMPTY
37802: PPUSH
37803: CALL_OW 1
37807: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37808: LD_ADDR_EXP 134
37812: PUSH
37813: LD_EXP 134
37817: PPUSH
37818: LD_VAR 0 2
37822: PPUSH
37823: EMPTY
37824: PPUSH
37825: CALL_OW 1
37829: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37830: LD_ADDR_EXP 135
37834: PUSH
37835: LD_EXP 135
37839: PPUSH
37840: LD_VAR 0 2
37844: PPUSH
37845: EMPTY
37846: PPUSH
37847: CALL_OW 1
37851: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37852: LD_ADDR_EXP 124
37856: PUSH
37857: LD_EXP 124
37861: PPUSH
37862: LD_VAR 0 2
37866: PPUSH
37867: LD_INT 0
37869: PPUSH
37870: CALL_OW 1
37874: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37875: LD_ADDR_EXP 137
37879: PUSH
37880: LD_EXP 137
37884: PPUSH
37885: LD_VAR 0 2
37889: PPUSH
37890: LD_INT 0
37892: PPUSH
37893: CALL_OW 1
37897: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37898: LD_ADDR_EXP 125
37902: PUSH
37903: LD_EXP 125
37907: PPUSH
37908: LD_VAR 0 2
37912: PPUSH
37913: EMPTY
37914: PPUSH
37915: CALL_OW 1
37919: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37920: LD_ADDR_EXP 136
37924: PUSH
37925: LD_EXP 136
37929: PPUSH
37930: LD_VAR 0 2
37934: PPUSH
37935: LD_INT 0
37937: PPUSH
37938: CALL_OW 1
37942: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37943: LD_ADDR_EXP 138
37947: PUSH
37948: LD_EXP 138
37952: PPUSH
37953: LD_VAR 0 2
37957: PPUSH
37958: EMPTY
37959: PPUSH
37960: CALL_OW 1
37964: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37965: LD_ADDR_EXP 141
37969: PUSH
37970: LD_EXP 141
37974: PPUSH
37975: LD_VAR 0 2
37979: PPUSH
37980: LD_INT 0
37982: PPUSH
37983: CALL_OW 1
37987: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37988: LD_ADDR_EXP 142
37992: PUSH
37993: LD_EXP 142
37997: PPUSH
37998: LD_VAR 0 2
38002: PPUSH
38003: EMPTY
38004: PPUSH
38005: CALL_OW 1
38009: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38010: LD_ADDR_EXP 143
38014: PUSH
38015: LD_EXP 143
38019: PPUSH
38020: LD_VAR 0 2
38024: PPUSH
38025: EMPTY
38026: PPUSH
38027: CALL_OW 1
38031: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38032: LD_ADDR_EXP 144
38036: PUSH
38037: LD_EXP 144
38041: PPUSH
38042: LD_VAR 0 2
38046: PPUSH
38047: EMPTY
38048: PPUSH
38049: CALL_OW 1
38053: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38054: LD_ADDR_EXP 146
38058: PUSH
38059: LD_EXP 146
38063: PPUSH
38064: LD_VAR 0 2
38068: PPUSH
38069: LD_EXP 113
38073: PUSH
38074: LD_VAR 0 2
38078: ARRAY
38079: PPUSH
38080: LD_INT 2
38082: PUSH
38083: LD_INT 30
38085: PUSH
38086: LD_INT 6
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: LD_INT 30
38095: PUSH
38096: LD_INT 7
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 30
38105: PUSH
38106: LD_INT 8
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: PPUSH
38119: CALL_OW 72
38123: PPUSH
38124: CALL_OW 1
38128: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38129: LD_ADDR_EXP 147
38133: PUSH
38134: LD_EXP 147
38138: PPUSH
38139: LD_VAR 0 2
38143: PPUSH
38144: EMPTY
38145: PPUSH
38146: CALL_OW 1
38150: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38151: LD_ADDR_EXP 148
38155: PUSH
38156: LD_EXP 148
38160: PPUSH
38161: LD_VAR 0 2
38165: PPUSH
38166: EMPTY
38167: PPUSH
38168: CALL_OW 1
38172: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38173: LD_ADDR_EXP 149
38177: PUSH
38178: LD_EXP 149
38182: PPUSH
38183: LD_VAR 0 2
38187: PPUSH
38188: EMPTY
38189: PPUSH
38190: CALL_OW 1
38194: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38195: LD_ADDR_EXP 150
38199: PUSH
38200: LD_EXP 150
38204: PPUSH
38205: LD_VAR 0 2
38209: PPUSH
38210: EMPTY
38211: PPUSH
38212: CALL_OW 1
38216: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38217: LD_ADDR_EXP 151
38221: PUSH
38222: LD_EXP 151
38226: PPUSH
38227: LD_VAR 0 2
38231: PPUSH
38232: EMPTY
38233: PPUSH
38234: CALL_OW 1
38238: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38239: LD_ADDR_EXP 152
38243: PUSH
38244: LD_EXP 152
38248: PPUSH
38249: LD_VAR 0 2
38253: PPUSH
38254: EMPTY
38255: PPUSH
38256: CALL_OW 1
38260: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38261: LD_ADDR_EXP 153
38265: PUSH
38266: LD_EXP 153
38270: PPUSH
38271: LD_VAR 0 2
38275: PPUSH
38276: EMPTY
38277: PPUSH
38278: CALL_OW 1
38282: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38283: LD_ADDR_EXP 154
38287: PUSH
38288: LD_EXP 154
38292: PPUSH
38293: LD_VAR 0 2
38297: PPUSH
38298: EMPTY
38299: PPUSH
38300: CALL_OW 1
38304: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38305: LD_ADDR_EXP 155
38309: PUSH
38310: LD_EXP 155
38314: PPUSH
38315: LD_VAR 0 2
38319: PPUSH
38320: LD_INT 0
38322: PPUSH
38323: CALL_OW 1
38327: ST_TO_ADDR
// end ;
38328: GO 37252
38330: POP
38331: POP
// MC_InitSides ( ) ;
38332: CALL 38618 0 0
// MC_InitResearch ( ) ;
38336: CALL 38357 0 0
// CustomInitMacro ( ) ;
38340: CALL 471 0 0
// skirmish := true ;
38344: LD_ADDR_EXP 111
38348: PUSH
38349: LD_INT 1
38351: ST_TO_ADDR
// end ;
38352: LD_VAR 0 1
38356: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38357: LD_INT 0
38359: PPUSH
38360: PPUSH
38361: PPUSH
38362: PPUSH
38363: PPUSH
38364: PPUSH
// if not mc_bases then
38365: LD_EXP 113
38369: NOT
38370: IFFALSE 38374
// exit ;
38372: GO 38613
// for i = 1 to 8 do
38374: LD_ADDR_VAR 0 2
38378: PUSH
38379: DOUBLE
38380: LD_INT 1
38382: DEC
38383: ST_TO_ADDR
38384: LD_INT 8
38386: PUSH
38387: FOR_TO
38388: IFFALSE 38414
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38390: LD_ADDR_EXP 140
38394: PUSH
38395: LD_EXP 140
38399: PPUSH
38400: LD_VAR 0 2
38404: PPUSH
38405: EMPTY
38406: PPUSH
38407: CALL_OW 1
38411: ST_TO_ADDR
38412: GO 38387
38414: POP
38415: POP
// tmp := [ ] ;
38416: LD_ADDR_VAR 0 5
38420: PUSH
38421: EMPTY
38422: ST_TO_ADDR
// for i = 1 to mc_sides do
38423: LD_ADDR_VAR 0 2
38427: PUSH
38428: DOUBLE
38429: LD_INT 1
38431: DEC
38432: ST_TO_ADDR
38433: LD_EXP 139
38437: PUSH
38438: FOR_TO
38439: IFFALSE 38497
// if not mc_sides [ i ] in tmp then
38441: LD_EXP 139
38445: PUSH
38446: LD_VAR 0 2
38450: ARRAY
38451: PUSH
38452: LD_VAR 0 5
38456: IN
38457: NOT
38458: IFFALSE 38495
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38460: LD_ADDR_VAR 0 5
38464: PUSH
38465: LD_VAR 0 5
38469: PPUSH
38470: LD_VAR 0 5
38474: PUSH
38475: LD_INT 1
38477: PLUS
38478: PPUSH
38479: LD_EXP 139
38483: PUSH
38484: LD_VAR 0 2
38488: ARRAY
38489: PPUSH
38490: CALL_OW 2
38494: ST_TO_ADDR
38495: GO 38438
38497: POP
38498: POP
// if not tmp then
38499: LD_VAR 0 5
38503: NOT
38504: IFFALSE 38508
// exit ;
38506: GO 38613
// for j in tmp do
38508: LD_ADDR_VAR 0 3
38512: PUSH
38513: LD_VAR 0 5
38517: PUSH
38518: FOR_IN
38519: IFFALSE 38611
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38521: LD_ADDR_VAR 0 6
38525: PUSH
38526: LD_INT 22
38528: PUSH
38529: LD_VAR 0 3
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: PPUSH
38538: CALL_OW 69
38542: ST_TO_ADDR
// if not un then
38543: LD_VAR 0 6
38547: NOT
38548: IFFALSE 38552
// continue ;
38550: GO 38518
// nation := GetNation ( un [ 1 ] ) ;
38552: LD_ADDR_VAR 0 4
38556: PUSH
38557: LD_VAR 0 6
38561: PUSH
38562: LD_INT 1
38564: ARRAY
38565: PPUSH
38566: CALL_OW 248
38570: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38571: LD_ADDR_EXP 140
38575: PUSH
38576: LD_EXP 140
38580: PPUSH
38581: LD_VAR 0 3
38585: PPUSH
38586: LD_VAR 0 3
38590: PPUSH
38591: LD_VAR 0 4
38595: PPUSH
38596: LD_INT 1
38598: PPUSH
38599: CALL 65274 0 3
38603: PPUSH
38604: CALL_OW 1
38608: ST_TO_ADDR
// end ;
38609: GO 38518
38611: POP
38612: POP
// end ;
38613: LD_VAR 0 1
38617: RET
// export function MC_InitSides ( ) ; var i ; begin
38618: LD_INT 0
38620: PPUSH
38621: PPUSH
// if not mc_bases then
38622: LD_EXP 113
38626: NOT
38627: IFFALSE 38631
// exit ;
38629: GO 38705
// for i = 1 to mc_bases do
38631: LD_ADDR_VAR 0 2
38635: PUSH
38636: DOUBLE
38637: LD_INT 1
38639: DEC
38640: ST_TO_ADDR
38641: LD_EXP 113
38645: PUSH
38646: FOR_TO
38647: IFFALSE 38703
// if mc_bases [ i ] then
38649: LD_EXP 113
38653: PUSH
38654: LD_VAR 0 2
38658: ARRAY
38659: IFFALSE 38701
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38661: LD_ADDR_EXP 139
38665: PUSH
38666: LD_EXP 139
38670: PPUSH
38671: LD_VAR 0 2
38675: PPUSH
38676: LD_EXP 113
38680: PUSH
38681: LD_VAR 0 2
38685: ARRAY
38686: PUSH
38687: LD_INT 1
38689: ARRAY
38690: PPUSH
38691: CALL_OW 255
38695: PPUSH
38696: CALL_OW 1
38700: ST_TO_ADDR
38701: GO 38646
38703: POP
38704: POP
// end ;
38705: LD_VAR 0 1
38709: RET
// every 0 0$01 trigger skirmish do
38710: LD_EXP 111
38714: IFFALSE 38868
38716: GO 38718
38718: DISABLE
// begin enable ;
38719: ENABLE
// MC_CheckBuildings ( ) ;
38720: CALL 43366 0 0
// MC_CheckPeopleLife ( ) ;
38724: CALL 43491 0 0
// RaiseSailEvent ( 100 ) ;
38728: LD_INT 100
38730: PPUSH
38731: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38735: LD_INT 103
38737: PPUSH
38738: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38742: LD_INT 104
38744: PPUSH
38745: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38749: LD_INT 105
38751: PPUSH
38752: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38756: LD_INT 106
38758: PPUSH
38759: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38763: LD_INT 107
38765: PPUSH
38766: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38770: LD_INT 108
38772: PPUSH
38773: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38777: LD_INT 109
38779: PPUSH
38780: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38784: LD_INT 110
38786: PPUSH
38787: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38791: LD_INT 111
38793: PPUSH
38794: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38798: LD_INT 112
38800: PPUSH
38801: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38805: LD_INT 113
38807: PPUSH
38808: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38812: LD_INT 120
38814: PPUSH
38815: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38819: LD_INT 121
38821: PPUSH
38822: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38826: LD_INT 122
38828: PPUSH
38829: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38833: LD_INT 123
38835: PPUSH
38836: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38840: LD_INT 124
38842: PPUSH
38843: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38847: LD_INT 125
38849: PPUSH
38850: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38854: LD_INT 126
38856: PPUSH
38857: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38861: LD_INT 200
38863: PPUSH
38864: CALL_OW 427
// end ;
38868: END
// on SailEvent ( event ) do begin if event < 100 then
38869: LD_VAR 0 1
38873: PUSH
38874: LD_INT 100
38876: LESS
38877: IFFALSE 38888
// CustomEvent ( event ) ;
38879: LD_VAR 0 1
38883: PPUSH
38884: CALL 33435 0 1
// if event = 100 then
38888: LD_VAR 0 1
38892: PUSH
38893: LD_INT 100
38895: EQUAL
38896: IFFALSE 38902
// MC_ClassManager ( ) ;
38898: CALL 39294 0 0
// if event = 101 then
38902: LD_VAR 0 1
38906: PUSH
38907: LD_INT 101
38909: EQUAL
38910: IFFALSE 38916
// MC_RepairBuildings ( ) ;
38912: CALL 44076 0 0
// if event = 102 then
38916: LD_VAR 0 1
38920: PUSH
38921: LD_INT 102
38923: EQUAL
38924: IFFALSE 38930
// MC_Heal ( ) ;
38926: CALL 44961 0 0
// if event = 103 then
38930: LD_VAR 0 1
38934: PUSH
38935: LD_INT 103
38937: EQUAL
38938: IFFALSE 38944
// MC_Build ( ) ;
38940: CALL 45383 0 0
// if event = 104 then
38944: LD_VAR 0 1
38948: PUSH
38949: LD_INT 104
38951: EQUAL
38952: IFFALSE 38958
// MC_TurretWeapon ( ) ;
38954: CALL 46996 0 0
// if event = 105 then
38958: LD_VAR 0 1
38962: PUSH
38963: LD_INT 105
38965: EQUAL
38966: IFFALSE 38972
// MC_BuildUpgrade ( ) ;
38968: CALL 46547 0 0
// if event = 106 then
38972: LD_VAR 0 1
38976: PUSH
38977: LD_INT 106
38979: EQUAL
38980: IFFALSE 38986
// MC_PlantMines ( ) ;
38982: CALL 47426 0 0
// if event = 107 then
38986: LD_VAR 0 1
38990: PUSH
38991: LD_INT 107
38993: EQUAL
38994: IFFALSE 39000
// MC_CollectCrates ( ) ;
38996: CALL 48224 0 0
// if event = 108 then
39000: LD_VAR 0 1
39004: PUSH
39005: LD_INT 108
39007: EQUAL
39008: IFFALSE 39014
// MC_LinkRemoteControl ( ) ;
39010: CALL 50000 0 0
// if event = 109 then
39014: LD_VAR 0 1
39018: PUSH
39019: LD_INT 109
39021: EQUAL
39022: IFFALSE 39028
// MC_ProduceVehicle ( ) ;
39024: CALL 50181 0 0
// if event = 110 then
39028: LD_VAR 0 1
39032: PUSH
39033: LD_INT 110
39035: EQUAL
39036: IFFALSE 39042
// MC_SendAttack ( ) ;
39038: CALL 50647 0 0
// if event = 111 then
39042: LD_VAR 0 1
39046: PUSH
39047: LD_INT 111
39049: EQUAL
39050: IFFALSE 39056
// MC_Defend ( ) ;
39052: CALL 50755 0 0
// if event = 112 then
39056: LD_VAR 0 1
39060: PUSH
39061: LD_INT 112
39063: EQUAL
39064: IFFALSE 39070
// MC_Research ( ) ;
39066: CALL 51382 0 0
// if event = 113 then
39070: LD_VAR 0 1
39074: PUSH
39075: LD_INT 113
39077: EQUAL
39078: IFFALSE 39084
// MC_MinesTrigger ( ) ;
39080: CALL 52496 0 0
// if event = 120 then
39084: LD_VAR 0 1
39088: PUSH
39089: LD_INT 120
39091: EQUAL
39092: IFFALSE 39098
// MC_RepairVehicle ( ) ;
39094: CALL 52595 0 0
// if event = 121 then
39098: LD_VAR 0 1
39102: PUSH
39103: LD_INT 121
39105: EQUAL
39106: IFFALSE 39112
// MC_TameApe ( ) ;
39108: CALL 53325 0 0
// if event = 122 then
39112: LD_VAR 0 1
39116: PUSH
39117: LD_INT 122
39119: EQUAL
39120: IFFALSE 39126
// MC_ChangeApeClass ( ) ;
39122: CALL 54154 0 0
// if event = 123 then
39126: LD_VAR 0 1
39130: PUSH
39131: LD_INT 123
39133: EQUAL
39134: IFFALSE 39140
// MC_Bazooka ( ) ;
39136: CALL 54804 0 0
// if event = 124 then
39140: LD_VAR 0 1
39144: PUSH
39145: LD_INT 124
39147: EQUAL
39148: IFFALSE 39154
// MC_TeleportExit ( ) ;
39150: CALL 55002 0 0
// if event = 125 then
39154: LD_VAR 0 1
39158: PUSH
39159: LD_INT 125
39161: EQUAL
39162: IFFALSE 39168
// MC_Deposits ( ) ;
39164: CALL 55649 0 0
// if event = 126 then
39168: LD_VAR 0 1
39172: PUSH
39173: LD_INT 126
39175: EQUAL
39176: IFFALSE 39182
// MC_RemoteDriver ( ) ;
39178: CALL 56274 0 0
// if event = 200 then
39182: LD_VAR 0 1
39186: PUSH
39187: LD_INT 200
39189: EQUAL
39190: IFFALSE 39196
// MC_Idle ( ) ;
39192: CALL 58223 0 0
// end ;
39196: PPOPN 1
39198: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39199: LD_INT 0
39201: PPUSH
39202: PPUSH
// if not mc_bases [ base ] or not tag then
39203: LD_EXP 113
39207: PUSH
39208: LD_VAR 0 1
39212: ARRAY
39213: NOT
39214: PUSH
39215: LD_VAR 0 2
39219: NOT
39220: OR
39221: IFFALSE 39225
// exit ;
39223: GO 39289
// for i in mc_bases [ base ] union mc_ape [ base ] do
39225: LD_ADDR_VAR 0 4
39229: PUSH
39230: LD_EXP 113
39234: PUSH
39235: LD_VAR 0 1
39239: ARRAY
39240: PUSH
39241: LD_EXP 142
39245: PUSH
39246: LD_VAR 0 1
39250: ARRAY
39251: UNION
39252: PUSH
39253: FOR_IN
39254: IFFALSE 39287
// if GetTag ( i ) = tag then
39256: LD_VAR 0 4
39260: PPUSH
39261: CALL_OW 110
39265: PUSH
39266: LD_VAR 0 2
39270: EQUAL
39271: IFFALSE 39285
// SetTag ( i , 0 ) ;
39273: LD_VAR 0 4
39277: PPUSH
39278: LD_INT 0
39280: PPUSH
39281: CALL_OW 109
39285: GO 39253
39287: POP
39288: POP
// end ;
39289: LD_VAR 0 3
39293: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39294: LD_INT 0
39296: PPUSH
39297: PPUSH
39298: PPUSH
39299: PPUSH
39300: PPUSH
39301: PPUSH
39302: PPUSH
39303: PPUSH
// if not mc_bases then
39304: LD_EXP 113
39308: NOT
39309: IFFALSE 39313
// exit ;
39311: GO 39771
// for i = 1 to mc_bases do
39313: LD_ADDR_VAR 0 2
39317: PUSH
39318: DOUBLE
39319: LD_INT 1
39321: DEC
39322: ST_TO_ADDR
39323: LD_EXP 113
39327: PUSH
39328: FOR_TO
39329: IFFALSE 39769
// begin tmp := MC_ClassCheckReq ( i ) ;
39331: LD_ADDR_VAR 0 4
39335: PUSH
39336: LD_VAR 0 2
39340: PPUSH
39341: CALL 39776 0 1
39345: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39346: LD_ADDR_EXP 154
39350: PUSH
39351: LD_EXP 154
39355: PPUSH
39356: LD_VAR 0 2
39360: PPUSH
39361: LD_VAR 0 4
39365: PPUSH
39366: CALL_OW 1
39370: ST_TO_ADDR
// if not tmp then
39371: LD_VAR 0 4
39375: NOT
39376: IFFALSE 39380
// continue ;
39378: GO 39328
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39380: LD_ADDR_VAR 0 6
39384: PUSH
39385: LD_EXP 113
39389: PUSH
39390: LD_VAR 0 2
39394: ARRAY
39395: PPUSH
39396: LD_INT 2
39398: PUSH
39399: LD_INT 30
39401: PUSH
39402: LD_INT 4
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 30
39411: PUSH
39412: LD_INT 5
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: LIST
39423: PPUSH
39424: CALL_OW 72
39428: PUSH
39429: LD_EXP 113
39433: PUSH
39434: LD_VAR 0 2
39438: ARRAY
39439: PPUSH
39440: LD_INT 2
39442: PUSH
39443: LD_INT 30
39445: PUSH
39446: LD_INT 0
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: LD_INT 30
39455: PUSH
39456: LD_INT 1
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: LIST
39467: PPUSH
39468: CALL_OW 72
39472: PUSH
39473: LD_EXP 113
39477: PUSH
39478: LD_VAR 0 2
39482: ARRAY
39483: PPUSH
39484: LD_INT 30
39486: PUSH
39487: LD_INT 3
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PPUSH
39494: CALL_OW 72
39498: PUSH
39499: LD_EXP 113
39503: PUSH
39504: LD_VAR 0 2
39508: ARRAY
39509: PPUSH
39510: LD_INT 2
39512: PUSH
39513: LD_INT 30
39515: PUSH
39516: LD_INT 6
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 30
39525: PUSH
39526: LD_INT 7
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 30
39535: PUSH
39536: LD_INT 8
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: PPUSH
39549: CALL_OW 72
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: LIST
39558: LIST
39559: ST_TO_ADDR
// for j = 1 to 4 do
39560: LD_ADDR_VAR 0 3
39564: PUSH
39565: DOUBLE
39566: LD_INT 1
39568: DEC
39569: ST_TO_ADDR
39570: LD_INT 4
39572: PUSH
39573: FOR_TO
39574: IFFALSE 39765
// begin if not tmp [ j ] then
39576: LD_VAR 0 4
39580: PUSH
39581: LD_VAR 0 3
39585: ARRAY
39586: NOT
39587: IFFALSE 39591
// continue ;
39589: GO 39573
// for p in tmp [ j ] do
39591: LD_ADDR_VAR 0 5
39595: PUSH
39596: LD_VAR 0 4
39600: PUSH
39601: LD_VAR 0 3
39605: ARRAY
39606: PUSH
39607: FOR_IN
39608: IFFALSE 39761
// begin if not b [ j ] then
39610: LD_VAR 0 6
39614: PUSH
39615: LD_VAR 0 3
39619: ARRAY
39620: NOT
39621: IFFALSE 39625
// break ;
39623: GO 39761
// e := 0 ;
39625: LD_ADDR_VAR 0 7
39629: PUSH
39630: LD_INT 0
39632: ST_TO_ADDR
// for k in b [ j ] do
39633: LD_ADDR_VAR 0 8
39637: PUSH
39638: LD_VAR 0 6
39642: PUSH
39643: LD_VAR 0 3
39647: ARRAY
39648: PUSH
39649: FOR_IN
39650: IFFALSE 39677
// if IsNotFull ( k ) then
39652: LD_VAR 0 8
39656: PPUSH
39657: CALL 67423 0 1
39661: IFFALSE 39675
// begin e := k ;
39663: LD_ADDR_VAR 0 7
39667: PUSH
39668: LD_VAR 0 8
39672: ST_TO_ADDR
// break ;
39673: GO 39677
// end ;
39675: GO 39649
39677: POP
39678: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39679: LD_VAR 0 7
39683: PUSH
39684: LD_VAR 0 5
39688: PPUSH
39689: LD_VAR 0 7
39693: PPUSH
39694: CALL 99843 0 2
39698: NOT
39699: AND
39700: IFFALSE 39759
// begin if IsInUnit ( p ) then
39702: LD_VAR 0 5
39706: PPUSH
39707: CALL_OW 310
39711: IFFALSE 39722
// ComExitBuilding ( p ) ;
39713: LD_VAR 0 5
39717: PPUSH
39718: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39722: LD_VAR 0 5
39726: PPUSH
39727: LD_VAR 0 7
39731: PPUSH
39732: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39736: LD_VAR 0 5
39740: PPUSH
39741: LD_VAR 0 3
39745: PPUSH
39746: CALL_OW 183
// AddComExitBuilding ( p ) ;
39750: LD_VAR 0 5
39754: PPUSH
39755: CALL_OW 182
// end ; end ;
39759: GO 39607
39761: POP
39762: POP
// end ;
39763: GO 39573
39765: POP
39766: POP
// end ;
39767: GO 39328
39769: POP
39770: POP
// end ;
39771: LD_VAR 0 1
39775: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39776: LD_INT 0
39778: PPUSH
39779: PPUSH
39780: PPUSH
39781: PPUSH
39782: PPUSH
39783: PPUSH
39784: PPUSH
39785: PPUSH
39786: PPUSH
39787: PPUSH
39788: PPUSH
39789: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39790: LD_VAR 0 1
39794: NOT
39795: PUSH
39796: LD_EXP 113
39800: PUSH
39801: LD_VAR 0 1
39805: ARRAY
39806: NOT
39807: OR
39808: PUSH
39809: LD_EXP 113
39813: PUSH
39814: LD_VAR 0 1
39818: ARRAY
39819: PPUSH
39820: LD_INT 2
39822: PUSH
39823: LD_INT 30
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 30
39835: PUSH
39836: LD_INT 1
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: LIST
39847: PPUSH
39848: CALL_OW 72
39852: NOT
39853: OR
39854: IFFALSE 39858
// exit ;
39856: GO 43361
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39858: LD_ADDR_VAR 0 4
39862: PUSH
39863: LD_EXP 113
39867: PUSH
39868: LD_VAR 0 1
39872: ARRAY
39873: PPUSH
39874: LD_INT 2
39876: PUSH
39877: LD_INT 25
39879: PUSH
39880: LD_INT 1
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 25
39889: PUSH
39890: LD_INT 2
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 25
39899: PUSH
39900: LD_INT 3
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 25
39909: PUSH
39910: LD_INT 4
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 25
39919: PUSH
39920: LD_INT 5
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 25
39929: PUSH
39930: LD_INT 8
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 25
39939: PUSH
39940: LD_INT 9
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: PPUSH
39957: CALL_OW 72
39961: ST_TO_ADDR
// if not tmp then
39962: LD_VAR 0 4
39966: NOT
39967: IFFALSE 39971
// exit ;
39969: GO 43361
// for i in tmp do
39971: LD_ADDR_VAR 0 3
39975: PUSH
39976: LD_VAR 0 4
39980: PUSH
39981: FOR_IN
39982: IFFALSE 40013
// if GetTag ( i ) then
39984: LD_VAR 0 3
39988: PPUSH
39989: CALL_OW 110
39993: IFFALSE 40011
// tmp := tmp diff i ;
39995: LD_ADDR_VAR 0 4
39999: PUSH
40000: LD_VAR 0 4
40004: PUSH
40005: LD_VAR 0 3
40009: DIFF
40010: ST_TO_ADDR
40011: GO 39981
40013: POP
40014: POP
// if not tmp then
40015: LD_VAR 0 4
40019: NOT
40020: IFFALSE 40024
// exit ;
40022: GO 43361
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40024: LD_ADDR_VAR 0 5
40028: PUSH
40029: LD_EXP 113
40033: PUSH
40034: LD_VAR 0 1
40038: ARRAY
40039: PPUSH
40040: LD_INT 2
40042: PUSH
40043: LD_INT 25
40045: PUSH
40046: LD_INT 1
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: LD_INT 25
40055: PUSH
40056: LD_INT 5
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 25
40065: PUSH
40066: LD_INT 8
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 25
40075: PUSH
40076: LD_INT 9
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: PPUSH
40090: CALL_OW 72
40094: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40095: LD_ADDR_VAR 0 6
40099: PUSH
40100: LD_EXP 113
40104: PUSH
40105: LD_VAR 0 1
40109: ARRAY
40110: PPUSH
40111: LD_INT 25
40113: PUSH
40114: LD_INT 2
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PPUSH
40121: CALL_OW 72
40125: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40126: LD_ADDR_VAR 0 7
40130: PUSH
40131: LD_EXP 113
40135: PUSH
40136: LD_VAR 0 1
40140: ARRAY
40141: PPUSH
40142: LD_INT 25
40144: PUSH
40145: LD_INT 3
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PPUSH
40152: CALL_OW 72
40156: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40157: LD_ADDR_VAR 0 8
40161: PUSH
40162: LD_EXP 113
40166: PUSH
40167: LD_VAR 0 1
40171: ARRAY
40172: PPUSH
40173: LD_INT 25
40175: PUSH
40176: LD_INT 4
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 24
40185: PUSH
40186: LD_INT 251
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PPUSH
40197: CALL_OW 72
40201: ST_TO_ADDR
// if mc_scan [ base ] then
40202: LD_EXP 136
40206: PUSH
40207: LD_VAR 0 1
40211: ARRAY
40212: IFFALSE 40673
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40214: LD_ADDR_EXP 155
40218: PUSH
40219: LD_EXP 155
40223: PPUSH
40224: LD_VAR 0 1
40228: PPUSH
40229: LD_INT 4
40231: PPUSH
40232: CALL_OW 1
40236: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40237: LD_ADDR_VAR 0 12
40241: PUSH
40242: LD_EXP 113
40246: PUSH
40247: LD_VAR 0 1
40251: ARRAY
40252: PPUSH
40253: LD_INT 2
40255: PUSH
40256: LD_INT 30
40258: PUSH
40259: LD_INT 4
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 30
40268: PUSH
40269: LD_INT 5
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: LIST
40280: PPUSH
40281: CALL_OW 72
40285: ST_TO_ADDR
// if not b then
40286: LD_VAR 0 12
40290: NOT
40291: IFFALSE 40295
// exit ;
40293: GO 43361
// p := [ ] ;
40295: LD_ADDR_VAR 0 11
40299: PUSH
40300: EMPTY
40301: ST_TO_ADDR
// if sci >= 2 then
40302: LD_VAR 0 8
40306: PUSH
40307: LD_INT 2
40309: GREATEREQUAL
40310: IFFALSE 40341
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40312: LD_ADDR_VAR 0 8
40316: PUSH
40317: LD_VAR 0 8
40321: PUSH
40322: LD_INT 1
40324: ARRAY
40325: PUSH
40326: LD_VAR 0 8
40330: PUSH
40331: LD_INT 2
40333: ARRAY
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: ST_TO_ADDR
40339: GO 40402
// if sci = 1 then
40341: LD_VAR 0 8
40345: PUSH
40346: LD_INT 1
40348: EQUAL
40349: IFFALSE 40370
// sci := [ sci [ 1 ] ] else
40351: LD_ADDR_VAR 0 8
40355: PUSH
40356: LD_VAR 0 8
40360: PUSH
40361: LD_INT 1
40363: ARRAY
40364: PUSH
40365: EMPTY
40366: LIST
40367: ST_TO_ADDR
40368: GO 40402
// if sci = 0 then
40370: LD_VAR 0 8
40374: PUSH
40375: LD_INT 0
40377: EQUAL
40378: IFFALSE 40402
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40380: LD_ADDR_VAR 0 11
40384: PUSH
40385: LD_VAR 0 4
40389: PPUSH
40390: LD_INT 4
40392: PPUSH
40393: CALL 99706 0 2
40397: PUSH
40398: LD_INT 1
40400: ARRAY
40401: ST_TO_ADDR
// if eng > 4 then
40402: LD_VAR 0 6
40406: PUSH
40407: LD_INT 4
40409: GREATER
40410: IFFALSE 40456
// for i = eng downto 4 do
40412: LD_ADDR_VAR 0 3
40416: PUSH
40417: DOUBLE
40418: LD_VAR 0 6
40422: INC
40423: ST_TO_ADDR
40424: LD_INT 4
40426: PUSH
40427: FOR_DOWNTO
40428: IFFALSE 40454
// eng := eng diff eng [ i ] ;
40430: LD_ADDR_VAR 0 6
40434: PUSH
40435: LD_VAR 0 6
40439: PUSH
40440: LD_VAR 0 6
40444: PUSH
40445: LD_VAR 0 3
40449: ARRAY
40450: DIFF
40451: ST_TO_ADDR
40452: GO 40427
40454: POP
40455: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40456: LD_ADDR_VAR 0 4
40460: PUSH
40461: LD_VAR 0 4
40465: PUSH
40466: LD_VAR 0 5
40470: PUSH
40471: LD_VAR 0 6
40475: UNION
40476: PUSH
40477: LD_VAR 0 7
40481: UNION
40482: PUSH
40483: LD_VAR 0 8
40487: UNION
40488: DIFF
40489: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40490: LD_ADDR_VAR 0 13
40494: PUSH
40495: LD_EXP 113
40499: PUSH
40500: LD_VAR 0 1
40504: ARRAY
40505: PPUSH
40506: LD_INT 2
40508: PUSH
40509: LD_INT 30
40511: PUSH
40512: LD_INT 32
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 30
40521: PUSH
40522: LD_INT 31
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: LIST
40533: PPUSH
40534: CALL_OW 72
40538: PUSH
40539: LD_EXP 113
40543: PUSH
40544: LD_VAR 0 1
40548: ARRAY
40549: PPUSH
40550: LD_INT 2
40552: PUSH
40553: LD_INT 30
40555: PUSH
40556: LD_INT 4
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 30
40565: PUSH
40566: LD_INT 5
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: EMPTY
40574: LIST
40575: LIST
40576: LIST
40577: PPUSH
40578: CALL_OW 72
40582: PUSH
40583: LD_INT 6
40585: MUL
40586: PLUS
40587: ST_TO_ADDR
// if bcount < tmp then
40588: LD_VAR 0 13
40592: PUSH
40593: LD_VAR 0 4
40597: LESS
40598: IFFALSE 40644
// for i = tmp downto bcount do
40600: LD_ADDR_VAR 0 3
40604: PUSH
40605: DOUBLE
40606: LD_VAR 0 4
40610: INC
40611: ST_TO_ADDR
40612: LD_VAR 0 13
40616: PUSH
40617: FOR_DOWNTO
40618: IFFALSE 40642
// tmp := Delete ( tmp , tmp ) ;
40620: LD_ADDR_VAR 0 4
40624: PUSH
40625: LD_VAR 0 4
40629: PPUSH
40630: LD_VAR 0 4
40634: PPUSH
40635: CALL_OW 3
40639: ST_TO_ADDR
40640: GO 40617
40642: POP
40643: POP
// result := [ tmp , 0 , 0 , p ] ;
40644: LD_ADDR_VAR 0 2
40648: PUSH
40649: LD_VAR 0 4
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: LD_INT 0
40659: PUSH
40660: LD_VAR 0 11
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: LIST
40669: LIST
40670: ST_TO_ADDR
// exit ;
40671: GO 43361
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40673: LD_EXP 113
40677: PUSH
40678: LD_VAR 0 1
40682: ARRAY
40683: PPUSH
40684: LD_INT 2
40686: PUSH
40687: LD_INT 30
40689: PUSH
40690: LD_INT 6
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 30
40699: PUSH
40700: LD_INT 7
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 30
40709: PUSH
40710: LD_INT 8
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: PPUSH
40723: CALL_OW 72
40727: NOT
40728: PUSH
40729: LD_EXP 113
40733: PUSH
40734: LD_VAR 0 1
40738: ARRAY
40739: PPUSH
40740: LD_INT 30
40742: PUSH
40743: LD_INT 3
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PPUSH
40750: CALL_OW 72
40754: NOT
40755: AND
40756: IFFALSE 40828
// begin if eng = tmp then
40758: LD_VAR 0 6
40762: PUSH
40763: LD_VAR 0 4
40767: EQUAL
40768: IFFALSE 40772
// exit ;
40770: GO 43361
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40772: LD_ADDR_EXP 155
40776: PUSH
40777: LD_EXP 155
40781: PPUSH
40782: LD_VAR 0 1
40786: PPUSH
40787: LD_INT 1
40789: PPUSH
40790: CALL_OW 1
40794: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40795: LD_ADDR_VAR 0 2
40799: PUSH
40800: LD_INT 0
40802: PUSH
40803: LD_VAR 0 4
40807: PUSH
40808: LD_VAR 0 6
40812: DIFF
40813: PUSH
40814: LD_INT 0
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: LIST
40824: LIST
40825: ST_TO_ADDR
// exit ;
40826: GO 43361
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40828: LD_EXP 140
40832: PUSH
40833: LD_EXP 139
40837: PUSH
40838: LD_VAR 0 1
40842: ARRAY
40843: ARRAY
40844: PUSH
40845: LD_EXP 113
40849: PUSH
40850: LD_VAR 0 1
40854: ARRAY
40855: PPUSH
40856: LD_INT 2
40858: PUSH
40859: LD_INT 30
40861: PUSH
40862: LD_INT 6
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 30
40871: PUSH
40872: LD_INT 7
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 30
40881: PUSH
40882: LD_INT 8
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: PPUSH
40895: CALL_OW 72
40899: AND
40900: PUSH
40901: LD_EXP 113
40905: PUSH
40906: LD_VAR 0 1
40910: ARRAY
40911: PPUSH
40912: LD_INT 30
40914: PUSH
40915: LD_INT 3
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PPUSH
40922: CALL_OW 72
40926: NOT
40927: AND
40928: IFFALSE 41142
// begin if sci >= 6 then
40930: LD_VAR 0 8
40934: PUSH
40935: LD_INT 6
40937: GREATEREQUAL
40938: IFFALSE 40942
// exit ;
40940: GO 43361
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40942: LD_ADDR_EXP 155
40946: PUSH
40947: LD_EXP 155
40951: PPUSH
40952: LD_VAR 0 1
40956: PPUSH
40957: LD_INT 2
40959: PPUSH
40960: CALL_OW 1
40964: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40965: LD_ADDR_VAR 0 9
40969: PUSH
40970: LD_VAR 0 4
40974: PUSH
40975: LD_VAR 0 8
40979: DIFF
40980: PPUSH
40981: LD_INT 4
40983: PPUSH
40984: CALL 99706 0 2
40988: ST_TO_ADDR
// p := [ ] ;
40989: LD_ADDR_VAR 0 11
40993: PUSH
40994: EMPTY
40995: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40996: LD_VAR 0 8
41000: PUSH
41001: LD_INT 6
41003: LESS
41004: PUSH
41005: LD_VAR 0 9
41009: PUSH
41010: LD_INT 6
41012: GREATER
41013: AND
41014: IFFALSE 41095
// begin for i = 1 to 6 - sci do
41016: LD_ADDR_VAR 0 3
41020: PUSH
41021: DOUBLE
41022: LD_INT 1
41024: DEC
41025: ST_TO_ADDR
41026: LD_INT 6
41028: PUSH
41029: LD_VAR 0 8
41033: MINUS
41034: PUSH
41035: FOR_TO
41036: IFFALSE 41091
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41038: LD_ADDR_VAR 0 11
41042: PUSH
41043: LD_VAR 0 11
41047: PPUSH
41048: LD_VAR 0 11
41052: PUSH
41053: LD_INT 1
41055: PLUS
41056: PPUSH
41057: LD_VAR 0 9
41061: PUSH
41062: LD_INT 1
41064: ARRAY
41065: PPUSH
41066: CALL_OW 2
41070: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41071: LD_ADDR_VAR 0 9
41075: PUSH
41076: LD_VAR 0 9
41080: PPUSH
41081: LD_INT 1
41083: PPUSH
41084: CALL_OW 3
41088: ST_TO_ADDR
// end ;
41089: GO 41035
41091: POP
41092: POP
// end else
41093: GO 41115
// if sort then
41095: LD_VAR 0 9
41099: IFFALSE 41115
// p := sort [ 1 ] ;
41101: LD_ADDR_VAR 0 11
41105: PUSH
41106: LD_VAR 0 9
41110: PUSH
41111: LD_INT 1
41113: ARRAY
41114: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41115: LD_ADDR_VAR 0 2
41119: PUSH
41120: LD_INT 0
41122: PUSH
41123: LD_INT 0
41125: PUSH
41126: LD_INT 0
41128: PUSH
41129: LD_VAR 0 11
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: ST_TO_ADDR
// exit ;
41140: GO 43361
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41142: LD_EXP 140
41146: PUSH
41147: LD_EXP 139
41151: PUSH
41152: LD_VAR 0 1
41156: ARRAY
41157: ARRAY
41158: PUSH
41159: LD_EXP 113
41163: PUSH
41164: LD_VAR 0 1
41168: ARRAY
41169: PPUSH
41170: LD_INT 2
41172: PUSH
41173: LD_INT 30
41175: PUSH
41176: LD_INT 6
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 30
41185: PUSH
41186: LD_INT 7
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 30
41195: PUSH
41196: LD_INT 8
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: PPUSH
41209: CALL_OW 72
41213: AND
41214: PUSH
41215: LD_EXP 113
41219: PUSH
41220: LD_VAR 0 1
41224: ARRAY
41225: PPUSH
41226: LD_INT 30
41228: PUSH
41229: LD_INT 3
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PPUSH
41236: CALL_OW 72
41240: AND
41241: IFFALSE 41975
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41243: LD_ADDR_EXP 155
41247: PUSH
41248: LD_EXP 155
41252: PPUSH
41253: LD_VAR 0 1
41257: PPUSH
41258: LD_INT 3
41260: PPUSH
41261: CALL_OW 1
41265: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41266: LD_ADDR_VAR 0 2
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: LD_INT 0
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: LIST
41287: LIST
41288: ST_TO_ADDR
// if not eng then
41289: LD_VAR 0 6
41293: NOT
41294: IFFALSE 41357
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41296: LD_ADDR_VAR 0 11
41300: PUSH
41301: LD_VAR 0 4
41305: PPUSH
41306: LD_INT 2
41308: PPUSH
41309: CALL 99706 0 2
41313: PUSH
41314: LD_INT 1
41316: ARRAY
41317: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41318: LD_ADDR_VAR 0 2
41322: PUSH
41323: LD_VAR 0 2
41327: PPUSH
41328: LD_INT 2
41330: PPUSH
41331: LD_VAR 0 11
41335: PPUSH
41336: CALL_OW 1
41340: ST_TO_ADDR
// tmp := tmp diff p ;
41341: LD_ADDR_VAR 0 4
41345: PUSH
41346: LD_VAR 0 4
41350: PUSH
41351: LD_VAR 0 11
41355: DIFF
41356: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41357: LD_VAR 0 4
41361: PUSH
41362: LD_VAR 0 8
41366: PUSH
41367: LD_INT 6
41369: LESS
41370: AND
41371: IFFALSE 41559
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41373: LD_ADDR_VAR 0 9
41377: PUSH
41378: LD_VAR 0 4
41382: PUSH
41383: LD_VAR 0 8
41387: PUSH
41388: LD_VAR 0 7
41392: UNION
41393: DIFF
41394: PPUSH
41395: LD_INT 4
41397: PPUSH
41398: CALL 99706 0 2
41402: ST_TO_ADDR
// p := [ ] ;
41403: LD_ADDR_VAR 0 11
41407: PUSH
41408: EMPTY
41409: ST_TO_ADDR
// if sort then
41410: LD_VAR 0 9
41414: IFFALSE 41530
// for i = 1 to 6 - sci do
41416: LD_ADDR_VAR 0 3
41420: PUSH
41421: DOUBLE
41422: LD_INT 1
41424: DEC
41425: ST_TO_ADDR
41426: LD_INT 6
41428: PUSH
41429: LD_VAR 0 8
41433: MINUS
41434: PUSH
41435: FOR_TO
41436: IFFALSE 41528
// begin if i = sort then
41438: LD_VAR 0 3
41442: PUSH
41443: LD_VAR 0 9
41447: EQUAL
41448: IFFALSE 41452
// break ;
41450: GO 41528
// if GetClass ( i ) = 4 then
41452: LD_VAR 0 3
41456: PPUSH
41457: CALL_OW 257
41461: PUSH
41462: LD_INT 4
41464: EQUAL
41465: IFFALSE 41469
// continue ;
41467: GO 41435
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41469: LD_ADDR_VAR 0 11
41473: PUSH
41474: LD_VAR 0 11
41478: PPUSH
41479: LD_VAR 0 11
41483: PUSH
41484: LD_INT 1
41486: PLUS
41487: PPUSH
41488: LD_VAR 0 9
41492: PUSH
41493: LD_VAR 0 3
41497: ARRAY
41498: PPUSH
41499: CALL_OW 2
41503: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41504: LD_ADDR_VAR 0 4
41508: PUSH
41509: LD_VAR 0 4
41513: PUSH
41514: LD_VAR 0 9
41518: PUSH
41519: LD_VAR 0 3
41523: ARRAY
41524: DIFF
41525: ST_TO_ADDR
// end ;
41526: GO 41435
41528: POP
41529: POP
// if p then
41530: LD_VAR 0 11
41534: IFFALSE 41559
// result := Replace ( result , 4 , p ) ;
41536: LD_ADDR_VAR 0 2
41540: PUSH
41541: LD_VAR 0 2
41545: PPUSH
41546: LD_INT 4
41548: PPUSH
41549: LD_VAR 0 11
41553: PPUSH
41554: CALL_OW 1
41558: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41559: LD_VAR 0 4
41563: PUSH
41564: LD_VAR 0 7
41568: PUSH
41569: LD_INT 6
41571: LESS
41572: AND
41573: IFFALSE 41761
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41575: LD_ADDR_VAR 0 9
41579: PUSH
41580: LD_VAR 0 4
41584: PUSH
41585: LD_VAR 0 8
41589: PUSH
41590: LD_VAR 0 7
41594: UNION
41595: DIFF
41596: PPUSH
41597: LD_INT 3
41599: PPUSH
41600: CALL 99706 0 2
41604: ST_TO_ADDR
// p := [ ] ;
41605: LD_ADDR_VAR 0 11
41609: PUSH
41610: EMPTY
41611: ST_TO_ADDR
// if sort then
41612: LD_VAR 0 9
41616: IFFALSE 41732
// for i = 1 to 6 - mech do
41618: LD_ADDR_VAR 0 3
41622: PUSH
41623: DOUBLE
41624: LD_INT 1
41626: DEC
41627: ST_TO_ADDR
41628: LD_INT 6
41630: PUSH
41631: LD_VAR 0 7
41635: MINUS
41636: PUSH
41637: FOR_TO
41638: IFFALSE 41730
// begin if i = sort then
41640: LD_VAR 0 3
41644: PUSH
41645: LD_VAR 0 9
41649: EQUAL
41650: IFFALSE 41654
// break ;
41652: GO 41730
// if GetClass ( i ) = 3 then
41654: LD_VAR 0 3
41658: PPUSH
41659: CALL_OW 257
41663: PUSH
41664: LD_INT 3
41666: EQUAL
41667: IFFALSE 41671
// continue ;
41669: GO 41637
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41671: LD_ADDR_VAR 0 11
41675: PUSH
41676: LD_VAR 0 11
41680: PPUSH
41681: LD_VAR 0 11
41685: PUSH
41686: LD_INT 1
41688: PLUS
41689: PPUSH
41690: LD_VAR 0 9
41694: PUSH
41695: LD_VAR 0 3
41699: ARRAY
41700: PPUSH
41701: CALL_OW 2
41705: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41706: LD_ADDR_VAR 0 4
41710: PUSH
41711: LD_VAR 0 4
41715: PUSH
41716: LD_VAR 0 9
41720: PUSH
41721: LD_VAR 0 3
41725: ARRAY
41726: DIFF
41727: ST_TO_ADDR
// end ;
41728: GO 41637
41730: POP
41731: POP
// if p then
41732: LD_VAR 0 11
41736: IFFALSE 41761
// result := Replace ( result , 3 , p ) ;
41738: LD_ADDR_VAR 0 2
41742: PUSH
41743: LD_VAR 0 2
41747: PPUSH
41748: LD_INT 3
41750: PPUSH
41751: LD_VAR 0 11
41755: PPUSH
41756: CALL_OW 1
41760: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41761: LD_VAR 0 4
41765: PUSH
41766: LD_INT 6
41768: GREATER
41769: PUSH
41770: LD_VAR 0 6
41774: PUSH
41775: LD_INT 6
41777: LESS
41778: AND
41779: IFFALSE 41973
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41781: LD_ADDR_VAR 0 9
41785: PUSH
41786: LD_VAR 0 4
41790: PUSH
41791: LD_VAR 0 8
41795: PUSH
41796: LD_VAR 0 7
41800: UNION
41801: PUSH
41802: LD_VAR 0 6
41806: UNION
41807: DIFF
41808: PPUSH
41809: LD_INT 2
41811: PPUSH
41812: CALL 99706 0 2
41816: ST_TO_ADDR
// p := [ ] ;
41817: LD_ADDR_VAR 0 11
41821: PUSH
41822: EMPTY
41823: ST_TO_ADDR
// if sort then
41824: LD_VAR 0 9
41828: IFFALSE 41944
// for i = 1 to 6 - eng do
41830: LD_ADDR_VAR 0 3
41834: PUSH
41835: DOUBLE
41836: LD_INT 1
41838: DEC
41839: ST_TO_ADDR
41840: LD_INT 6
41842: PUSH
41843: LD_VAR 0 6
41847: MINUS
41848: PUSH
41849: FOR_TO
41850: IFFALSE 41942
// begin if i = sort then
41852: LD_VAR 0 3
41856: PUSH
41857: LD_VAR 0 9
41861: EQUAL
41862: IFFALSE 41866
// break ;
41864: GO 41942
// if GetClass ( i ) = 2 then
41866: LD_VAR 0 3
41870: PPUSH
41871: CALL_OW 257
41875: PUSH
41876: LD_INT 2
41878: EQUAL
41879: IFFALSE 41883
// continue ;
41881: GO 41849
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41883: LD_ADDR_VAR 0 11
41887: PUSH
41888: LD_VAR 0 11
41892: PPUSH
41893: LD_VAR 0 11
41897: PUSH
41898: LD_INT 1
41900: PLUS
41901: PPUSH
41902: LD_VAR 0 9
41906: PUSH
41907: LD_VAR 0 3
41911: ARRAY
41912: PPUSH
41913: CALL_OW 2
41917: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41918: LD_ADDR_VAR 0 4
41922: PUSH
41923: LD_VAR 0 4
41927: PUSH
41928: LD_VAR 0 9
41932: PUSH
41933: LD_VAR 0 3
41937: ARRAY
41938: DIFF
41939: ST_TO_ADDR
// end ;
41940: GO 41849
41942: POP
41943: POP
// if p then
41944: LD_VAR 0 11
41948: IFFALSE 41973
// result := Replace ( result , 2 , p ) ;
41950: LD_ADDR_VAR 0 2
41954: PUSH
41955: LD_VAR 0 2
41959: PPUSH
41960: LD_INT 2
41962: PPUSH
41963: LD_VAR 0 11
41967: PPUSH
41968: CALL_OW 1
41972: ST_TO_ADDR
// end ; exit ;
41973: GO 43361
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41975: LD_EXP 140
41979: PUSH
41980: LD_EXP 139
41984: PUSH
41985: LD_VAR 0 1
41989: ARRAY
41990: ARRAY
41991: NOT
41992: PUSH
41993: LD_EXP 113
41997: PUSH
41998: LD_VAR 0 1
42002: ARRAY
42003: PPUSH
42004: LD_INT 30
42006: PUSH
42007: LD_INT 3
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PPUSH
42014: CALL_OW 72
42018: AND
42019: PUSH
42020: LD_EXP 118
42024: PUSH
42025: LD_VAR 0 1
42029: ARRAY
42030: AND
42031: IFFALSE 42639
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42033: LD_ADDR_EXP 155
42037: PUSH
42038: LD_EXP 155
42042: PPUSH
42043: LD_VAR 0 1
42047: PPUSH
42048: LD_INT 5
42050: PPUSH
42051: CALL_OW 1
42055: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42056: LD_ADDR_VAR 0 2
42060: PUSH
42061: LD_INT 0
42063: PUSH
42064: LD_INT 0
42066: PUSH
42067: LD_INT 0
42069: PUSH
42070: LD_INT 0
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: ST_TO_ADDR
// if sci > 1 then
42079: LD_VAR 0 8
42083: PUSH
42084: LD_INT 1
42086: GREATER
42087: IFFALSE 42115
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42089: LD_ADDR_VAR 0 4
42093: PUSH
42094: LD_VAR 0 4
42098: PUSH
42099: LD_VAR 0 8
42103: PUSH
42104: LD_VAR 0 8
42108: PUSH
42109: LD_INT 1
42111: ARRAY
42112: DIFF
42113: DIFF
42114: ST_TO_ADDR
// if tmp and not sci then
42115: LD_VAR 0 4
42119: PUSH
42120: LD_VAR 0 8
42124: NOT
42125: AND
42126: IFFALSE 42195
// begin sort := SortBySkill ( tmp , 4 ) ;
42128: LD_ADDR_VAR 0 9
42132: PUSH
42133: LD_VAR 0 4
42137: PPUSH
42138: LD_INT 4
42140: PPUSH
42141: CALL 99706 0 2
42145: ST_TO_ADDR
// if sort then
42146: LD_VAR 0 9
42150: IFFALSE 42166
// p := sort [ 1 ] ;
42152: LD_ADDR_VAR 0 11
42156: PUSH
42157: LD_VAR 0 9
42161: PUSH
42162: LD_INT 1
42164: ARRAY
42165: ST_TO_ADDR
// if p then
42166: LD_VAR 0 11
42170: IFFALSE 42195
// result := Replace ( result , 4 , p ) ;
42172: LD_ADDR_VAR 0 2
42176: PUSH
42177: LD_VAR 0 2
42181: PPUSH
42182: LD_INT 4
42184: PPUSH
42185: LD_VAR 0 11
42189: PPUSH
42190: CALL_OW 1
42194: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42195: LD_ADDR_VAR 0 4
42199: PUSH
42200: LD_VAR 0 4
42204: PUSH
42205: LD_VAR 0 7
42209: DIFF
42210: ST_TO_ADDR
// if tmp and mech < 6 then
42211: LD_VAR 0 4
42215: PUSH
42216: LD_VAR 0 7
42220: PUSH
42221: LD_INT 6
42223: LESS
42224: AND
42225: IFFALSE 42413
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42227: LD_ADDR_VAR 0 9
42231: PUSH
42232: LD_VAR 0 4
42236: PUSH
42237: LD_VAR 0 8
42241: PUSH
42242: LD_VAR 0 7
42246: UNION
42247: DIFF
42248: PPUSH
42249: LD_INT 3
42251: PPUSH
42252: CALL 99706 0 2
42256: ST_TO_ADDR
// p := [ ] ;
42257: LD_ADDR_VAR 0 11
42261: PUSH
42262: EMPTY
42263: ST_TO_ADDR
// if sort then
42264: LD_VAR 0 9
42268: IFFALSE 42384
// for i = 1 to 6 - mech do
42270: LD_ADDR_VAR 0 3
42274: PUSH
42275: DOUBLE
42276: LD_INT 1
42278: DEC
42279: ST_TO_ADDR
42280: LD_INT 6
42282: PUSH
42283: LD_VAR 0 7
42287: MINUS
42288: PUSH
42289: FOR_TO
42290: IFFALSE 42382
// begin if i = sort then
42292: LD_VAR 0 3
42296: PUSH
42297: LD_VAR 0 9
42301: EQUAL
42302: IFFALSE 42306
// break ;
42304: GO 42382
// if GetClass ( i ) = 3 then
42306: LD_VAR 0 3
42310: PPUSH
42311: CALL_OW 257
42315: PUSH
42316: LD_INT 3
42318: EQUAL
42319: IFFALSE 42323
// continue ;
42321: GO 42289
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42323: LD_ADDR_VAR 0 11
42327: PUSH
42328: LD_VAR 0 11
42332: PPUSH
42333: LD_VAR 0 11
42337: PUSH
42338: LD_INT 1
42340: PLUS
42341: PPUSH
42342: LD_VAR 0 9
42346: PUSH
42347: LD_VAR 0 3
42351: ARRAY
42352: PPUSH
42353: CALL_OW 2
42357: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42358: LD_ADDR_VAR 0 4
42362: PUSH
42363: LD_VAR 0 4
42367: PUSH
42368: LD_VAR 0 9
42372: PUSH
42373: LD_VAR 0 3
42377: ARRAY
42378: DIFF
42379: ST_TO_ADDR
// end ;
42380: GO 42289
42382: POP
42383: POP
// if p then
42384: LD_VAR 0 11
42388: IFFALSE 42413
// result := Replace ( result , 3 , p ) ;
42390: LD_ADDR_VAR 0 2
42394: PUSH
42395: LD_VAR 0 2
42399: PPUSH
42400: LD_INT 3
42402: PPUSH
42403: LD_VAR 0 11
42407: PPUSH
42408: CALL_OW 1
42412: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42413: LD_ADDR_VAR 0 4
42417: PUSH
42418: LD_VAR 0 4
42422: PUSH
42423: LD_VAR 0 6
42427: DIFF
42428: ST_TO_ADDR
// if tmp and eng < 6 then
42429: LD_VAR 0 4
42433: PUSH
42434: LD_VAR 0 6
42438: PUSH
42439: LD_INT 6
42441: LESS
42442: AND
42443: IFFALSE 42637
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42445: LD_ADDR_VAR 0 9
42449: PUSH
42450: LD_VAR 0 4
42454: PUSH
42455: LD_VAR 0 8
42459: PUSH
42460: LD_VAR 0 7
42464: UNION
42465: PUSH
42466: LD_VAR 0 6
42470: UNION
42471: DIFF
42472: PPUSH
42473: LD_INT 2
42475: PPUSH
42476: CALL 99706 0 2
42480: ST_TO_ADDR
// p := [ ] ;
42481: LD_ADDR_VAR 0 11
42485: PUSH
42486: EMPTY
42487: ST_TO_ADDR
// if sort then
42488: LD_VAR 0 9
42492: IFFALSE 42608
// for i = 1 to 6 - eng do
42494: LD_ADDR_VAR 0 3
42498: PUSH
42499: DOUBLE
42500: LD_INT 1
42502: DEC
42503: ST_TO_ADDR
42504: LD_INT 6
42506: PUSH
42507: LD_VAR 0 6
42511: MINUS
42512: PUSH
42513: FOR_TO
42514: IFFALSE 42606
// begin if i = sort then
42516: LD_VAR 0 3
42520: PUSH
42521: LD_VAR 0 9
42525: EQUAL
42526: IFFALSE 42530
// break ;
42528: GO 42606
// if GetClass ( i ) = 2 then
42530: LD_VAR 0 3
42534: PPUSH
42535: CALL_OW 257
42539: PUSH
42540: LD_INT 2
42542: EQUAL
42543: IFFALSE 42547
// continue ;
42545: GO 42513
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42547: LD_ADDR_VAR 0 11
42551: PUSH
42552: LD_VAR 0 11
42556: PPUSH
42557: LD_VAR 0 11
42561: PUSH
42562: LD_INT 1
42564: PLUS
42565: PPUSH
42566: LD_VAR 0 9
42570: PUSH
42571: LD_VAR 0 3
42575: ARRAY
42576: PPUSH
42577: CALL_OW 2
42581: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42582: LD_ADDR_VAR 0 4
42586: PUSH
42587: LD_VAR 0 4
42591: PUSH
42592: LD_VAR 0 9
42596: PUSH
42597: LD_VAR 0 3
42601: ARRAY
42602: DIFF
42603: ST_TO_ADDR
// end ;
42604: GO 42513
42606: POP
42607: POP
// if p then
42608: LD_VAR 0 11
42612: IFFALSE 42637
// result := Replace ( result , 2 , p ) ;
42614: LD_ADDR_VAR 0 2
42618: PUSH
42619: LD_VAR 0 2
42623: PPUSH
42624: LD_INT 2
42626: PPUSH
42627: LD_VAR 0 11
42631: PPUSH
42632: CALL_OW 1
42636: ST_TO_ADDR
// end ; exit ;
42637: GO 43361
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42639: LD_EXP 140
42643: PUSH
42644: LD_EXP 139
42648: PUSH
42649: LD_VAR 0 1
42653: ARRAY
42654: ARRAY
42655: NOT
42656: PUSH
42657: LD_EXP 113
42661: PUSH
42662: LD_VAR 0 1
42666: ARRAY
42667: PPUSH
42668: LD_INT 30
42670: PUSH
42671: LD_INT 3
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PPUSH
42678: CALL_OW 72
42682: AND
42683: PUSH
42684: LD_EXP 118
42688: PUSH
42689: LD_VAR 0 1
42693: ARRAY
42694: NOT
42695: AND
42696: IFFALSE 43361
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42698: LD_ADDR_EXP 155
42702: PUSH
42703: LD_EXP 155
42707: PPUSH
42708: LD_VAR 0 1
42712: PPUSH
42713: LD_INT 6
42715: PPUSH
42716: CALL_OW 1
42720: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42721: LD_ADDR_VAR 0 2
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: LD_INT 0
42731: PUSH
42732: LD_INT 0
42734: PUSH
42735: LD_INT 0
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: ST_TO_ADDR
// if sci >= 1 then
42744: LD_VAR 0 8
42748: PUSH
42749: LD_INT 1
42751: GREATEREQUAL
42752: IFFALSE 42774
// tmp := tmp diff sci [ 1 ] ;
42754: LD_ADDR_VAR 0 4
42758: PUSH
42759: LD_VAR 0 4
42763: PUSH
42764: LD_VAR 0 8
42768: PUSH
42769: LD_INT 1
42771: ARRAY
42772: DIFF
42773: ST_TO_ADDR
// if tmp and not sci then
42774: LD_VAR 0 4
42778: PUSH
42779: LD_VAR 0 8
42783: NOT
42784: AND
42785: IFFALSE 42854
// begin sort := SortBySkill ( tmp , 4 ) ;
42787: LD_ADDR_VAR 0 9
42791: PUSH
42792: LD_VAR 0 4
42796: PPUSH
42797: LD_INT 4
42799: PPUSH
42800: CALL 99706 0 2
42804: ST_TO_ADDR
// if sort then
42805: LD_VAR 0 9
42809: IFFALSE 42825
// p := sort [ 1 ] ;
42811: LD_ADDR_VAR 0 11
42815: PUSH
42816: LD_VAR 0 9
42820: PUSH
42821: LD_INT 1
42823: ARRAY
42824: ST_TO_ADDR
// if p then
42825: LD_VAR 0 11
42829: IFFALSE 42854
// result := Replace ( result , 4 , p ) ;
42831: LD_ADDR_VAR 0 2
42835: PUSH
42836: LD_VAR 0 2
42840: PPUSH
42841: LD_INT 4
42843: PPUSH
42844: LD_VAR 0 11
42848: PPUSH
42849: CALL_OW 1
42853: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42854: LD_ADDR_VAR 0 4
42858: PUSH
42859: LD_VAR 0 4
42863: PUSH
42864: LD_VAR 0 7
42868: DIFF
42869: ST_TO_ADDR
// if tmp and mech < 6 then
42870: LD_VAR 0 4
42874: PUSH
42875: LD_VAR 0 7
42879: PUSH
42880: LD_INT 6
42882: LESS
42883: AND
42884: IFFALSE 43066
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42886: LD_ADDR_VAR 0 9
42890: PUSH
42891: LD_VAR 0 4
42895: PUSH
42896: LD_VAR 0 7
42900: DIFF
42901: PPUSH
42902: LD_INT 3
42904: PPUSH
42905: CALL 99706 0 2
42909: ST_TO_ADDR
// p := [ ] ;
42910: LD_ADDR_VAR 0 11
42914: PUSH
42915: EMPTY
42916: ST_TO_ADDR
// if sort then
42917: LD_VAR 0 9
42921: IFFALSE 43037
// for i = 1 to 6 - mech do
42923: LD_ADDR_VAR 0 3
42927: PUSH
42928: DOUBLE
42929: LD_INT 1
42931: DEC
42932: ST_TO_ADDR
42933: LD_INT 6
42935: PUSH
42936: LD_VAR 0 7
42940: MINUS
42941: PUSH
42942: FOR_TO
42943: IFFALSE 43035
// begin if i = sort then
42945: LD_VAR 0 3
42949: PUSH
42950: LD_VAR 0 9
42954: EQUAL
42955: IFFALSE 42959
// break ;
42957: GO 43035
// if GetClass ( i ) = 3 then
42959: LD_VAR 0 3
42963: PPUSH
42964: CALL_OW 257
42968: PUSH
42969: LD_INT 3
42971: EQUAL
42972: IFFALSE 42976
// continue ;
42974: GO 42942
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42976: LD_ADDR_VAR 0 11
42980: PUSH
42981: LD_VAR 0 11
42985: PPUSH
42986: LD_VAR 0 11
42990: PUSH
42991: LD_INT 1
42993: PLUS
42994: PPUSH
42995: LD_VAR 0 9
42999: PUSH
43000: LD_VAR 0 3
43004: ARRAY
43005: PPUSH
43006: CALL_OW 2
43010: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43011: LD_ADDR_VAR 0 4
43015: PUSH
43016: LD_VAR 0 4
43020: PUSH
43021: LD_VAR 0 9
43025: PUSH
43026: LD_VAR 0 3
43030: ARRAY
43031: DIFF
43032: ST_TO_ADDR
// end ;
43033: GO 42942
43035: POP
43036: POP
// if p then
43037: LD_VAR 0 11
43041: IFFALSE 43066
// result := Replace ( result , 3 , p ) ;
43043: LD_ADDR_VAR 0 2
43047: PUSH
43048: LD_VAR 0 2
43052: PPUSH
43053: LD_INT 3
43055: PPUSH
43056: LD_VAR 0 11
43060: PPUSH
43061: CALL_OW 1
43065: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43066: LD_ADDR_VAR 0 4
43070: PUSH
43071: LD_VAR 0 4
43075: PUSH
43076: LD_VAR 0 6
43080: DIFF
43081: ST_TO_ADDR
// if tmp and eng < 4 then
43082: LD_VAR 0 4
43086: PUSH
43087: LD_VAR 0 6
43091: PUSH
43092: LD_INT 4
43094: LESS
43095: AND
43096: IFFALSE 43286
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43098: LD_ADDR_VAR 0 9
43102: PUSH
43103: LD_VAR 0 4
43107: PUSH
43108: LD_VAR 0 7
43112: PUSH
43113: LD_VAR 0 6
43117: UNION
43118: DIFF
43119: PPUSH
43120: LD_INT 2
43122: PPUSH
43123: CALL 99706 0 2
43127: ST_TO_ADDR
// p := [ ] ;
43128: LD_ADDR_VAR 0 11
43132: PUSH
43133: EMPTY
43134: ST_TO_ADDR
// if sort then
43135: LD_VAR 0 9
43139: IFFALSE 43255
// for i = 1 to 4 - eng do
43141: LD_ADDR_VAR 0 3
43145: PUSH
43146: DOUBLE
43147: LD_INT 1
43149: DEC
43150: ST_TO_ADDR
43151: LD_INT 4
43153: PUSH
43154: LD_VAR 0 6
43158: MINUS
43159: PUSH
43160: FOR_TO
43161: IFFALSE 43253
// begin if i = sort then
43163: LD_VAR 0 3
43167: PUSH
43168: LD_VAR 0 9
43172: EQUAL
43173: IFFALSE 43177
// break ;
43175: GO 43253
// if GetClass ( i ) = 2 then
43177: LD_VAR 0 3
43181: PPUSH
43182: CALL_OW 257
43186: PUSH
43187: LD_INT 2
43189: EQUAL
43190: IFFALSE 43194
// continue ;
43192: GO 43160
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43194: LD_ADDR_VAR 0 11
43198: PUSH
43199: LD_VAR 0 11
43203: PPUSH
43204: LD_VAR 0 11
43208: PUSH
43209: LD_INT 1
43211: PLUS
43212: PPUSH
43213: LD_VAR 0 9
43217: PUSH
43218: LD_VAR 0 3
43222: ARRAY
43223: PPUSH
43224: CALL_OW 2
43228: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43229: LD_ADDR_VAR 0 4
43233: PUSH
43234: LD_VAR 0 4
43238: PUSH
43239: LD_VAR 0 9
43243: PUSH
43244: LD_VAR 0 3
43248: ARRAY
43249: DIFF
43250: ST_TO_ADDR
// end ;
43251: GO 43160
43253: POP
43254: POP
// if p then
43255: LD_VAR 0 11
43259: IFFALSE 43284
// result := Replace ( result , 2 , p ) ;
43261: LD_ADDR_VAR 0 2
43265: PUSH
43266: LD_VAR 0 2
43270: PPUSH
43271: LD_INT 2
43273: PPUSH
43274: LD_VAR 0 11
43278: PPUSH
43279: CALL_OW 1
43283: ST_TO_ADDR
// end else
43284: GO 43330
// for i = eng downto 5 do
43286: LD_ADDR_VAR 0 3
43290: PUSH
43291: DOUBLE
43292: LD_VAR 0 6
43296: INC
43297: ST_TO_ADDR
43298: LD_INT 5
43300: PUSH
43301: FOR_DOWNTO
43302: IFFALSE 43328
// tmp := tmp union eng [ i ] ;
43304: LD_ADDR_VAR 0 4
43308: PUSH
43309: LD_VAR 0 4
43313: PUSH
43314: LD_VAR 0 6
43318: PUSH
43319: LD_VAR 0 3
43323: ARRAY
43324: UNION
43325: ST_TO_ADDR
43326: GO 43301
43328: POP
43329: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43330: LD_ADDR_VAR 0 2
43334: PUSH
43335: LD_VAR 0 2
43339: PPUSH
43340: LD_INT 1
43342: PPUSH
43343: LD_VAR 0 4
43347: PUSH
43348: LD_VAR 0 5
43352: DIFF
43353: PPUSH
43354: CALL_OW 1
43358: ST_TO_ADDR
// exit ;
43359: GO 43361
// end ; end ;
43361: LD_VAR 0 2
43365: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43366: LD_INT 0
43368: PPUSH
43369: PPUSH
43370: PPUSH
// if not mc_bases then
43371: LD_EXP 113
43375: NOT
43376: IFFALSE 43380
// exit ;
43378: GO 43486
// for i = 1 to mc_bases do
43380: LD_ADDR_VAR 0 2
43384: PUSH
43385: DOUBLE
43386: LD_INT 1
43388: DEC
43389: ST_TO_ADDR
43390: LD_EXP 113
43394: PUSH
43395: FOR_TO
43396: IFFALSE 43477
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43398: LD_ADDR_VAR 0 3
43402: PUSH
43403: LD_EXP 113
43407: PUSH
43408: LD_VAR 0 2
43412: ARRAY
43413: PPUSH
43414: LD_INT 21
43416: PUSH
43417: LD_INT 3
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 3
43426: PUSH
43427: LD_INT 24
43429: PUSH
43430: LD_INT 1000
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PPUSH
43445: CALL_OW 72
43449: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43450: LD_ADDR_EXP 114
43454: PUSH
43455: LD_EXP 114
43459: PPUSH
43460: LD_VAR 0 2
43464: PPUSH
43465: LD_VAR 0 3
43469: PPUSH
43470: CALL_OW 1
43474: ST_TO_ADDR
// end ;
43475: GO 43395
43477: POP
43478: POP
// RaiseSailEvent ( 101 ) ;
43479: LD_INT 101
43481: PPUSH
43482: CALL_OW 427
// end ;
43486: LD_VAR 0 1
43490: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43491: LD_INT 0
43493: PPUSH
43494: PPUSH
43495: PPUSH
43496: PPUSH
43497: PPUSH
43498: PPUSH
43499: PPUSH
// if not mc_bases then
43500: LD_EXP 113
43504: NOT
43505: IFFALSE 43509
// exit ;
43507: GO 44071
// for i = 1 to mc_bases do
43509: LD_ADDR_VAR 0 2
43513: PUSH
43514: DOUBLE
43515: LD_INT 1
43517: DEC
43518: ST_TO_ADDR
43519: LD_EXP 113
43523: PUSH
43524: FOR_TO
43525: IFFALSE 44062
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43527: LD_ADDR_VAR 0 5
43531: PUSH
43532: LD_EXP 113
43536: PUSH
43537: LD_VAR 0 2
43541: ARRAY
43542: PUSH
43543: LD_EXP 142
43547: PUSH
43548: LD_VAR 0 2
43552: ARRAY
43553: UNION
43554: PPUSH
43555: LD_INT 21
43557: PUSH
43558: LD_INT 1
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 1
43567: PUSH
43568: LD_INT 3
43570: PUSH
43571: LD_INT 54
43573: PUSH
43574: EMPTY
43575: LIST
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 3
43583: PUSH
43584: LD_INT 24
43586: PUSH
43587: LD_INT 800
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: LIST
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PPUSH
43607: CALL_OW 72
43611: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43612: LD_ADDR_VAR 0 6
43616: PUSH
43617: LD_EXP 113
43621: PUSH
43622: LD_VAR 0 2
43626: ARRAY
43627: PPUSH
43628: LD_INT 21
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 1
43640: PUSH
43641: LD_INT 3
43643: PUSH
43644: LD_INT 54
43646: PUSH
43647: EMPTY
43648: LIST
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 3
43656: PUSH
43657: LD_INT 24
43659: PUSH
43660: LD_INT 250
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: LIST
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: PPUSH
43680: CALL_OW 72
43684: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43685: LD_ADDR_VAR 0 7
43689: PUSH
43690: LD_VAR 0 5
43694: PUSH
43695: LD_VAR 0 6
43699: DIFF
43700: ST_TO_ADDR
// if not need_heal_1 then
43701: LD_VAR 0 6
43705: NOT
43706: IFFALSE 43739
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43708: LD_ADDR_EXP 116
43712: PUSH
43713: LD_EXP 116
43717: PPUSH
43718: LD_VAR 0 2
43722: PUSH
43723: LD_INT 1
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PPUSH
43730: EMPTY
43731: PPUSH
43732: CALL 70157 0 3
43736: ST_TO_ADDR
43737: GO 43809
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43739: LD_ADDR_EXP 116
43743: PUSH
43744: LD_EXP 116
43748: PPUSH
43749: LD_VAR 0 2
43753: PUSH
43754: LD_INT 1
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PPUSH
43761: LD_EXP 116
43765: PUSH
43766: LD_VAR 0 2
43770: ARRAY
43771: PUSH
43772: LD_INT 1
43774: ARRAY
43775: PPUSH
43776: LD_INT 3
43778: PUSH
43779: LD_INT 24
43781: PUSH
43782: LD_INT 1000
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PPUSH
43793: CALL_OW 72
43797: PUSH
43798: LD_VAR 0 6
43802: UNION
43803: PPUSH
43804: CALL 70157 0 3
43808: ST_TO_ADDR
// if not need_heal_2 then
43809: LD_VAR 0 7
43813: NOT
43814: IFFALSE 43847
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43816: LD_ADDR_EXP 116
43820: PUSH
43821: LD_EXP 116
43825: PPUSH
43826: LD_VAR 0 2
43830: PUSH
43831: LD_INT 2
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PPUSH
43838: EMPTY
43839: PPUSH
43840: CALL 70157 0 3
43844: ST_TO_ADDR
43845: GO 43879
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43847: LD_ADDR_EXP 116
43851: PUSH
43852: LD_EXP 116
43856: PPUSH
43857: LD_VAR 0 2
43861: PUSH
43862: LD_INT 2
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PPUSH
43869: LD_VAR 0 7
43873: PPUSH
43874: CALL 70157 0 3
43878: ST_TO_ADDR
// if need_heal_2 then
43879: LD_VAR 0 7
43883: IFFALSE 44044
// for j in need_heal_2 do
43885: LD_ADDR_VAR 0 3
43889: PUSH
43890: LD_VAR 0 7
43894: PUSH
43895: FOR_IN
43896: IFFALSE 44042
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43898: LD_ADDR_VAR 0 5
43902: PUSH
43903: LD_EXP 113
43907: PUSH
43908: LD_VAR 0 2
43912: ARRAY
43913: PPUSH
43914: LD_INT 2
43916: PUSH
43917: LD_INT 30
43919: PUSH
43920: LD_INT 6
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 30
43929: PUSH
43930: LD_INT 7
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: LD_INT 30
43939: PUSH
43940: LD_INT 8
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 30
43949: PUSH
43950: LD_INT 0
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 30
43959: PUSH
43960: LD_INT 1
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: PPUSH
43975: CALL_OW 72
43979: ST_TO_ADDR
// if tmp then
43980: LD_VAR 0 5
43984: IFFALSE 44040
// begin k := NearestUnitToUnit ( tmp , j ) ;
43986: LD_ADDR_VAR 0 4
43990: PUSH
43991: LD_VAR 0 5
43995: PPUSH
43996: LD_VAR 0 3
44000: PPUSH
44001: CALL_OW 74
44005: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44006: LD_VAR 0 3
44010: PPUSH
44011: LD_VAR 0 4
44015: PPUSH
44016: CALL_OW 296
44020: PUSH
44021: LD_INT 5
44023: GREATER
44024: IFFALSE 44040
// ComMoveToNearbyEntrance ( j , k ) ;
44026: LD_VAR 0 3
44030: PPUSH
44031: LD_VAR 0 4
44035: PPUSH
44036: CALL 102023 0 2
// end ; end ;
44040: GO 43895
44042: POP
44043: POP
// if not need_heal_1 and not need_heal_2 then
44044: LD_VAR 0 6
44048: NOT
44049: PUSH
44050: LD_VAR 0 7
44054: NOT
44055: AND
44056: IFFALSE 44060
// continue ;
44058: GO 43524
// end ;
44060: GO 43524
44062: POP
44063: POP
// RaiseSailEvent ( 102 ) ;
44064: LD_INT 102
44066: PPUSH
44067: CALL_OW 427
// end ;
44071: LD_VAR 0 1
44075: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44076: LD_INT 0
44078: PPUSH
44079: PPUSH
44080: PPUSH
44081: PPUSH
44082: PPUSH
44083: PPUSH
44084: PPUSH
44085: PPUSH
// if not mc_bases then
44086: LD_EXP 113
44090: NOT
44091: IFFALSE 44095
// exit ;
44093: GO 44956
// for i = 1 to mc_bases do
44095: LD_ADDR_VAR 0 2
44099: PUSH
44100: DOUBLE
44101: LD_INT 1
44103: DEC
44104: ST_TO_ADDR
44105: LD_EXP 113
44109: PUSH
44110: FOR_TO
44111: IFFALSE 44954
// begin if not mc_building_need_repair [ i ] then
44113: LD_EXP 114
44117: PUSH
44118: LD_VAR 0 2
44122: ARRAY
44123: NOT
44124: IFFALSE 44311
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44126: LD_ADDR_VAR 0 6
44130: PUSH
44131: LD_EXP 132
44135: PUSH
44136: LD_VAR 0 2
44140: ARRAY
44141: PPUSH
44142: LD_INT 3
44144: PUSH
44145: LD_INT 24
44147: PUSH
44148: LD_INT 1000
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 2
44161: PUSH
44162: LD_INT 34
44164: PUSH
44165: LD_INT 13
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 34
44174: PUSH
44175: LD_INT 52
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 34
44184: PUSH
44185: LD_EXP 101
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PPUSH
44204: CALL_OW 72
44208: ST_TO_ADDR
// if cranes then
44209: LD_VAR 0 6
44213: IFFALSE 44275
// for j in cranes do
44215: LD_ADDR_VAR 0 3
44219: PUSH
44220: LD_VAR 0 6
44224: PUSH
44225: FOR_IN
44226: IFFALSE 44273
// if not IsInArea ( j , mc_parking [ i ] ) then
44228: LD_VAR 0 3
44232: PPUSH
44233: LD_EXP 137
44237: PUSH
44238: LD_VAR 0 2
44242: ARRAY
44243: PPUSH
44244: CALL_OW 308
44248: NOT
44249: IFFALSE 44271
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44251: LD_VAR 0 3
44255: PPUSH
44256: LD_EXP 137
44260: PUSH
44261: LD_VAR 0 2
44265: ARRAY
44266: PPUSH
44267: CALL_OW 113
44271: GO 44225
44273: POP
44274: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44275: LD_ADDR_EXP 115
44279: PUSH
44280: LD_EXP 115
44284: PPUSH
44285: LD_VAR 0 2
44289: PPUSH
44290: EMPTY
44291: PPUSH
44292: CALL_OW 1
44296: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44297: LD_VAR 0 2
44301: PPUSH
44302: LD_INT 101
44304: PPUSH
44305: CALL 39199 0 2
// continue ;
44309: GO 44110
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44311: LD_ADDR_EXP 119
44315: PUSH
44316: LD_EXP 119
44320: PPUSH
44321: LD_VAR 0 2
44325: PPUSH
44326: EMPTY
44327: PPUSH
44328: CALL_OW 1
44332: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44333: LD_VAR 0 2
44337: PPUSH
44338: LD_INT 103
44340: PPUSH
44341: CALL 39199 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44345: LD_ADDR_VAR 0 5
44349: PUSH
44350: LD_EXP 113
44354: PUSH
44355: LD_VAR 0 2
44359: ARRAY
44360: PUSH
44361: LD_EXP 142
44365: PUSH
44366: LD_VAR 0 2
44370: ARRAY
44371: UNION
44372: PPUSH
44373: LD_INT 2
44375: PUSH
44376: LD_INT 25
44378: PUSH
44379: LD_INT 2
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 25
44388: PUSH
44389: LD_INT 16
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: LIST
44400: PUSH
44401: EMPTY
44402: LIST
44403: PPUSH
44404: CALL_OW 72
44408: PUSH
44409: LD_EXP 116
44413: PUSH
44414: LD_VAR 0 2
44418: ARRAY
44419: PUSH
44420: LD_INT 1
44422: ARRAY
44423: PUSH
44424: LD_EXP 116
44428: PUSH
44429: LD_VAR 0 2
44433: ARRAY
44434: PUSH
44435: LD_INT 2
44437: ARRAY
44438: UNION
44439: DIFF
44440: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44441: LD_ADDR_VAR 0 6
44445: PUSH
44446: LD_EXP 132
44450: PUSH
44451: LD_VAR 0 2
44455: ARRAY
44456: PPUSH
44457: LD_INT 2
44459: PUSH
44460: LD_INT 34
44462: PUSH
44463: LD_INT 13
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 34
44472: PUSH
44473: LD_INT 52
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 34
44482: PUSH
44483: LD_EXP 101
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: LIST
44496: LIST
44497: PPUSH
44498: CALL_OW 72
44502: ST_TO_ADDR
// if cranes then
44503: LD_VAR 0 6
44507: IFFALSE 44643
// begin for j in cranes do
44509: LD_ADDR_VAR 0 3
44513: PUSH
44514: LD_VAR 0 6
44518: PUSH
44519: FOR_IN
44520: IFFALSE 44641
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44522: LD_VAR 0 3
44526: PPUSH
44527: CALL_OW 256
44531: PUSH
44532: LD_INT 1000
44534: EQUAL
44535: PUSH
44536: LD_VAR 0 3
44540: PPUSH
44541: CALL_OW 314
44545: NOT
44546: AND
44547: IFFALSE 44581
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44549: LD_VAR 0 3
44553: PPUSH
44554: LD_EXP 114
44558: PUSH
44559: LD_VAR 0 2
44563: ARRAY
44564: PPUSH
44565: LD_VAR 0 3
44569: PPUSH
44570: CALL_OW 74
44574: PPUSH
44575: CALL_OW 130
44579: GO 44639
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44581: LD_VAR 0 3
44585: PPUSH
44586: CALL_OW 256
44590: PUSH
44591: LD_INT 500
44593: LESS
44594: PUSH
44595: LD_VAR 0 3
44599: PPUSH
44600: LD_EXP 137
44604: PUSH
44605: LD_VAR 0 2
44609: ARRAY
44610: PPUSH
44611: CALL_OW 308
44615: NOT
44616: AND
44617: IFFALSE 44639
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44619: LD_VAR 0 3
44623: PPUSH
44624: LD_EXP 137
44628: PUSH
44629: LD_VAR 0 2
44633: ARRAY
44634: PPUSH
44635: CALL_OW 113
// end ;
44639: GO 44519
44641: POP
44642: POP
// end ; if tmp > 3 then
44643: LD_VAR 0 5
44647: PUSH
44648: LD_INT 3
44650: GREATER
44651: IFFALSE 44671
// tmp := ShrinkArray ( tmp , 4 ) ;
44653: LD_ADDR_VAR 0 5
44657: PUSH
44658: LD_VAR 0 5
44662: PPUSH
44663: LD_INT 4
44665: PPUSH
44666: CALL 101515 0 2
44670: ST_TO_ADDR
// if not tmp then
44671: LD_VAR 0 5
44675: NOT
44676: IFFALSE 44680
// continue ;
44678: GO 44110
// for j in tmp do
44680: LD_ADDR_VAR 0 3
44684: PUSH
44685: LD_VAR 0 5
44689: PUSH
44690: FOR_IN
44691: IFFALSE 44950
// begin if IsInUnit ( j ) then
44693: LD_VAR 0 3
44697: PPUSH
44698: CALL_OW 310
44702: IFFALSE 44713
// ComExitBuilding ( j ) ;
44704: LD_VAR 0 3
44708: PPUSH
44709: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44713: LD_VAR 0 3
44717: PUSH
44718: LD_EXP 115
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: IN
44729: NOT
44730: IFFALSE 44788
// begin SetTag ( j , 101 ) ;
44732: LD_VAR 0 3
44736: PPUSH
44737: LD_INT 101
44739: PPUSH
44740: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44744: LD_ADDR_EXP 115
44748: PUSH
44749: LD_EXP 115
44753: PPUSH
44754: LD_VAR 0 2
44758: PUSH
44759: LD_EXP 115
44763: PUSH
44764: LD_VAR 0 2
44768: ARRAY
44769: PUSH
44770: LD_INT 1
44772: PLUS
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: PPUSH
44778: LD_VAR 0 3
44782: PPUSH
44783: CALL 70157 0 3
44787: ST_TO_ADDR
// end ; wait ( 1 ) ;
44788: LD_INT 1
44790: PPUSH
44791: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44795: LD_ADDR_VAR 0 7
44799: PUSH
44800: LD_EXP 114
44804: PUSH
44805: LD_VAR 0 2
44809: ARRAY
44810: ST_TO_ADDR
// if mc_scan [ i ] then
44811: LD_EXP 136
44815: PUSH
44816: LD_VAR 0 2
44820: ARRAY
44821: IFFALSE 44883
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44823: LD_ADDR_VAR 0 7
44827: PUSH
44828: LD_EXP 114
44832: PUSH
44833: LD_VAR 0 2
44837: ARRAY
44838: PPUSH
44839: LD_INT 3
44841: PUSH
44842: LD_INT 30
44844: PUSH
44845: LD_INT 32
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: PUSH
44852: LD_INT 30
44854: PUSH
44855: LD_INT 33
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PUSH
44862: LD_INT 30
44864: PUSH
44865: LD_INT 31
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: EMPTY
44873: LIST
44874: LIST
44875: LIST
44876: LIST
44877: PPUSH
44878: CALL_OW 72
44882: ST_TO_ADDR
// if not to_repair_tmp then
44883: LD_VAR 0 7
44887: NOT
44888: IFFALSE 44892
// continue ;
44890: GO 44690
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44892: LD_ADDR_VAR 0 8
44896: PUSH
44897: LD_VAR 0 7
44901: PPUSH
44902: LD_VAR 0 3
44906: PPUSH
44907: CALL_OW 74
44911: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
44912: LD_VAR 0 8
44916: PPUSH
44917: LD_INT 16
44919: PPUSH
44920: CALL 72750 0 2
44924: PUSH
44925: LD_INT 4
44927: ARRAY
44928: PUSH
44929: LD_INT 10
44931: LESS
44932: IFFALSE 44948
// ComRepairBuilding ( j , to_repair ) ;
44934: LD_VAR 0 3
44938: PPUSH
44939: LD_VAR 0 8
44943: PPUSH
44944: CALL_OW 130
// end ;
44948: GO 44690
44950: POP
44951: POP
// end ;
44952: GO 44110
44954: POP
44955: POP
// end ;
44956: LD_VAR 0 1
44960: RET
// export function MC_Heal ; var i , j , tmp ; begin
44961: LD_INT 0
44963: PPUSH
44964: PPUSH
44965: PPUSH
44966: PPUSH
// if not mc_bases then
44967: LD_EXP 113
44971: NOT
44972: IFFALSE 44976
// exit ;
44974: GO 45378
// for i = 1 to mc_bases do
44976: LD_ADDR_VAR 0 2
44980: PUSH
44981: DOUBLE
44982: LD_INT 1
44984: DEC
44985: ST_TO_ADDR
44986: LD_EXP 113
44990: PUSH
44991: FOR_TO
44992: IFFALSE 45376
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44994: LD_EXP 116
44998: PUSH
44999: LD_VAR 0 2
45003: ARRAY
45004: PUSH
45005: LD_INT 1
45007: ARRAY
45008: NOT
45009: PUSH
45010: LD_EXP 116
45014: PUSH
45015: LD_VAR 0 2
45019: ARRAY
45020: PUSH
45021: LD_INT 2
45023: ARRAY
45024: NOT
45025: AND
45026: IFFALSE 45064
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45028: LD_ADDR_EXP 117
45032: PUSH
45033: LD_EXP 117
45037: PPUSH
45038: LD_VAR 0 2
45042: PPUSH
45043: EMPTY
45044: PPUSH
45045: CALL_OW 1
45049: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45050: LD_VAR 0 2
45054: PPUSH
45055: LD_INT 102
45057: PPUSH
45058: CALL 39199 0 2
// continue ;
45062: GO 44991
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45064: LD_ADDR_VAR 0 4
45068: PUSH
45069: LD_EXP 113
45073: PUSH
45074: LD_VAR 0 2
45078: ARRAY
45079: PPUSH
45080: LD_INT 25
45082: PUSH
45083: LD_INT 4
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PPUSH
45090: CALL_OW 72
45094: ST_TO_ADDR
// if not tmp then
45095: LD_VAR 0 4
45099: NOT
45100: IFFALSE 45104
// continue ;
45102: GO 44991
// if mc_taming [ i ] then
45104: LD_EXP 144
45108: PUSH
45109: LD_VAR 0 2
45113: ARRAY
45114: IFFALSE 45138
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45116: LD_ADDR_EXP 144
45120: PUSH
45121: LD_EXP 144
45125: PPUSH
45126: LD_VAR 0 2
45130: PPUSH
45131: EMPTY
45132: PPUSH
45133: CALL_OW 1
45137: ST_TO_ADDR
// for j in tmp do
45138: LD_ADDR_VAR 0 3
45142: PUSH
45143: LD_VAR 0 4
45147: PUSH
45148: FOR_IN
45149: IFFALSE 45372
// begin if IsInUnit ( j ) then
45151: LD_VAR 0 3
45155: PPUSH
45156: CALL_OW 310
45160: IFFALSE 45171
// ComExitBuilding ( j ) ;
45162: LD_VAR 0 3
45166: PPUSH
45167: CALL_OW 122
// if not j in mc_healers [ i ] then
45171: LD_VAR 0 3
45175: PUSH
45176: LD_EXP 117
45180: PUSH
45181: LD_VAR 0 2
45185: ARRAY
45186: IN
45187: NOT
45188: IFFALSE 45234
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45190: LD_ADDR_EXP 117
45194: PUSH
45195: LD_EXP 117
45199: PPUSH
45200: LD_VAR 0 2
45204: PUSH
45205: LD_EXP 117
45209: PUSH
45210: LD_VAR 0 2
45214: ARRAY
45215: PUSH
45216: LD_INT 1
45218: PLUS
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PPUSH
45224: LD_VAR 0 3
45228: PPUSH
45229: CALL 70157 0 3
45233: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45234: LD_VAR 0 3
45238: PPUSH
45239: CALL_OW 110
45243: PUSH
45244: LD_INT 102
45246: NONEQUAL
45247: IFFALSE 45261
// SetTag ( j , 102 ) ;
45249: LD_VAR 0 3
45253: PPUSH
45254: LD_INT 102
45256: PPUSH
45257: CALL_OW 109
// Wait ( 3 ) ;
45261: LD_INT 3
45263: PPUSH
45264: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45268: LD_EXP 116
45272: PUSH
45273: LD_VAR 0 2
45277: ARRAY
45278: PUSH
45279: LD_INT 1
45281: ARRAY
45282: IFFALSE 45314
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45284: LD_VAR 0 3
45288: PPUSH
45289: LD_EXP 116
45293: PUSH
45294: LD_VAR 0 2
45298: ARRAY
45299: PUSH
45300: LD_INT 1
45302: ARRAY
45303: PUSH
45304: LD_INT 1
45306: ARRAY
45307: PPUSH
45308: CALL_OW 128
45312: GO 45370
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45314: LD_VAR 0 3
45318: PPUSH
45319: CALL_OW 314
45323: NOT
45324: PUSH
45325: LD_EXP 116
45329: PUSH
45330: LD_VAR 0 2
45334: ARRAY
45335: PUSH
45336: LD_INT 2
45338: ARRAY
45339: AND
45340: IFFALSE 45370
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45342: LD_VAR 0 3
45346: PPUSH
45347: LD_EXP 116
45351: PUSH
45352: LD_VAR 0 2
45356: ARRAY
45357: PUSH
45358: LD_INT 2
45360: ARRAY
45361: PUSH
45362: LD_INT 1
45364: ARRAY
45365: PPUSH
45366: CALL_OW 128
// end ;
45370: GO 45148
45372: POP
45373: POP
// end ;
45374: GO 44991
45376: POP
45377: POP
// end ;
45378: LD_VAR 0 1
45382: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45383: LD_INT 0
45385: PPUSH
45386: PPUSH
45387: PPUSH
45388: PPUSH
45389: PPUSH
// if not mc_bases then
45390: LD_EXP 113
45394: NOT
45395: IFFALSE 45399
// exit ;
45397: GO 46542
// for i = 1 to mc_bases do
45399: LD_ADDR_VAR 0 2
45403: PUSH
45404: DOUBLE
45405: LD_INT 1
45407: DEC
45408: ST_TO_ADDR
45409: LD_EXP 113
45413: PUSH
45414: FOR_TO
45415: IFFALSE 46540
// begin if mc_scan [ i ] then
45417: LD_EXP 136
45421: PUSH
45422: LD_VAR 0 2
45426: ARRAY
45427: IFFALSE 45431
// continue ;
45429: GO 45414
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45431: LD_EXP 118
45435: PUSH
45436: LD_VAR 0 2
45440: ARRAY
45441: NOT
45442: PUSH
45443: LD_EXP 120
45447: PUSH
45448: LD_VAR 0 2
45452: ARRAY
45453: NOT
45454: AND
45455: PUSH
45456: LD_EXP 119
45460: PUSH
45461: LD_VAR 0 2
45465: ARRAY
45466: AND
45467: IFFALSE 45505
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45469: LD_ADDR_EXP 119
45473: PUSH
45474: LD_EXP 119
45478: PPUSH
45479: LD_VAR 0 2
45483: PPUSH
45484: EMPTY
45485: PPUSH
45486: CALL_OW 1
45490: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45491: LD_VAR 0 2
45495: PPUSH
45496: LD_INT 103
45498: PPUSH
45499: CALL 39199 0 2
// continue ;
45503: GO 45414
// end ; if mc_construct_list [ i ] then
45505: LD_EXP 120
45509: PUSH
45510: LD_VAR 0 2
45514: ARRAY
45515: IFFALSE 45735
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45517: LD_ADDR_VAR 0 4
45521: PUSH
45522: LD_EXP 113
45526: PUSH
45527: LD_VAR 0 2
45531: ARRAY
45532: PPUSH
45533: LD_INT 25
45535: PUSH
45536: LD_INT 2
45538: PUSH
45539: EMPTY
45540: LIST
45541: LIST
45542: PPUSH
45543: CALL_OW 72
45547: PUSH
45548: LD_EXP 115
45552: PUSH
45553: LD_VAR 0 2
45557: ARRAY
45558: DIFF
45559: ST_TO_ADDR
// if not tmp then
45560: LD_VAR 0 4
45564: NOT
45565: IFFALSE 45569
// continue ;
45567: GO 45414
// for j in tmp do
45569: LD_ADDR_VAR 0 3
45573: PUSH
45574: LD_VAR 0 4
45578: PUSH
45579: FOR_IN
45580: IFFALSE 45731
// begin if not mc_builders [ i ] then
45582: LD_EXP 119
45586: PUSH
45587: LD_VAR 0 2
45591: ARRAY
45592: NOT
45593: IFFALSE 45651
// begin SetTag ( j , 103 ) ;
45595: LD_VAR 0 3
45599: PPUSH
45600: LD_INT 103
45602: PPUSH
45603: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45607: LD_ADDR_EXP 119
45611: PUSH
45612: LD_EXP 119
45616: PPUSH
45617: LD_VAR 0 2
45621: PUSH
45622: LD_EXP 119
45626: PUSH
45627: LD_VAR 0 2
45631: ARRAY
45632: PUSH
45633: LD_INT 1
45635: PLUS
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PPUSH
45641: LD_VAR 0 3
45645: PPUSH
45646: CALL 70157 0 3
45650: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45651: LD_VAR 0 3
45655: PPUSH
45656: CALL_OW 310
45660: IFFALSE 45671
// ComExitBuilding ( j ) ;
45662: LD_VAR 0 3
45666: PPUSH
45667: CALL_OW 122
// wait ( 3 ) ;
45671: LD_INT 3
45673: PPUSH
45674: CALL_OW 67
// if not mc_construct_list [ i ] then
45678: LD_EXP 120
45682: PUSH
45683: LD_VAR 0 2
45687: ARRAY
45688: NOT
45689: IFFALSE 45693
// break ;
45691: GO 45731
// if not HasTask ( j ) then
45693: LD_VAR 0 3
45697: PPUSH
45698: CALL_OW 314
45702: NOT
45703: IFFALSE 45729
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45705: LD_VAR 0 3
45709: PPUSH
45710: LD_EXP 120
45714: PUSH
45715: LD_VAR 0 2
45719: ARRAY
45720: PUSH
45721: LD_INT 1
45723: ARRAY
45724: PPUSH
45725: CALL 73008 0 2
// end ;
45729: GO 45579
45731: POP
45732: POP
// end else
45733: GO 46538
// if mc_build_list [ i ] then
45735: LD_EXP 118
45739: PUSH
45740: LD_VAR 0 2
45744: ARRAY
45745: IFFALSE 46538
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45747: LD_ADDR_VAR 0 5
45751: PUSH
45752: LD_EXP 113
45756: PUSH
45757: LD_VAR 0 2
45761: ARRAY
45762: PPUSH
45763: LD_INT 2
45765: PUSH
45766: LD_INT 30
45768: PUSH
45769: LD_INT 0
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 30
45778: PUSH
45779: LD_INT 1
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: LIST
45790: PPUSH
45791: CALL_OW 72
45795: ST_TO_ADDR
// if depot then
45796: LD_VAR 0 5
45800: IFFALSE 45818
// depot := depot [ 1 ] else
45802: LD_ADDR_VAR 0 5
45806: PUSH
45807: LD_VAR 0 5
45811: PUSH
45812: LD_INT 1
45814: ARRAY
45815: ST_TO_ADDR
45816: GO 45826
// depot := 0 ;
45818: LD_ADDR_VAR 0 5
45822: PUSH
45823: LD_INT 0
45825: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45826: LD_EXP 118
45830: PUSH
45831: LD_VAR 0 2
45835: ARRAY
45836: PUSH
45837: LD_INT 1
45839: ARRAY
45840: PUSH
45841: LD_INT 1
45843: ARRAY
45844: PPUSH
45845: CALL 72838 0 1
45849: PUSH
45850: LD_EXP 113
45854: PUSH
45855: LD_VAR 0 2
45859: ARRAY
45860: PPUSH
45861: LD_INT 2
45863: PUSH
45864: LD_INT 30
45866: PUSH
45867: LD_INT 2
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 30
45876: PUSH
45877: LD_INT 3
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: LIST
45888: PPUSH
45889: CALL_OW 72
45893: NOT
45894: AND
45895: IFFALSE 46000
// begin for j = 1 to mc_build_list [ i ] do
45897: LD_ADDR_VAR 0 3
45901: PUSH
45902: DOUBLE
45903: LD_INT 1
45905: DEC
45906: ST_TO_ADDR
45907: LD_EXP 118
45911: PUSH
45912: LD_VAR 0 2
45916: ARRAY
45917: PUSH
45918: FOR_TO
45919: IFFALSE 45998
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45921: LD_EXP 118
45925: PUSH
45926: LD_VAR 0 2
45930: ARRAY
45931: PUSH
45932: LD_VAR 0 3
45936: ARRAY
45937: PUSH
45938: LD_INT 1
45940: ARRAY
45941: PUSH
45942: LD_INT 2
45944: EQUAL
45945: IFFALSE 45996
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45947: LD_ADDR_EXP 118
45951: PUSH
45952: LD_EXP 118
45956: PPUSH
45957: LD_VAR 0 2
45961: PPUSH
45962: LD_EXP 118
45966: PUSH
45967: LD_VAR 0 2
45971: ARRAY
45972: PPUSH
45973: LD_VAR 0 3
45977: PPUSH
45978: LD_INT 1
45980: PPUSH
45981: LD_INT 0
45983: PPUSH
45984: CALL 69575 0 4
45988: PPUSH
45989: CALL_OW 1
45993: ST_TO_ADDR
// break ;
45994: GO 45998
// end ;
45996: GO 45918
45998: POP
45999: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46000: LD_EXP 118
46004: PUSH
46005: LD_VAR 0 2
46009: ARRAY
46010: PUSH
46011: LD_INT 1
46013: ARRAY
46014: PUSH
46015: LD_INT 1
46017: ARRAY
46018: PUSH
46019: LD_INT 0
46021: EQUAL
46022: PUSH
46023: LD_VAR 0 5
46027: PUSH
46028: LD_VAR 0 5
46032: PPUSH
46033: LD_EXP 118
46037: PUSH
46038: LD_VAR 0 2
46042: ARRAY
46043: PUSH
46044: LD_INT 1
46046: ARRAY
46047: PUSH
46048: LD_INT 1
46050: ARRAY
46051: PPUSH
46052: LD_EXP 118
46056: PUSH
46057: LD_VAR 0 2
46061: ARRAY
46062: PUSH
46063: LD_INT 1
46065: ARRAY
46066: PUSH
46067: LD_INT 2
46069: ARRAY
46070: PPUSH
46071: LD_EXP 118
46075: PUSH
46076: LD_VAR 0 2
46080: ARRAY
46081: PUSH
46082: LD_INT 1
46084: ARRAY
46085: PUSH
46086: LD_INT 3
46088: ARRAY
46089: PPUSH
46090: LD_EXP 118
46094: PUSH
46095: LD_VAR 0 2
46099: ARRAY
46100: PUSH
46101: LD_INT 1
46103: ARRAY
46104: PUSH
46105: LD_INT 4
46107: ARRAY
46108: PPUSH
46109: CALL 77572 0 5
46113: AND
46114: OR
46115: IFFALSE 46396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46117: LD_ADDR_VAR 0 4
46121: PUSH
46122: LD_EXP 113
46126: PUSH
46127: LD_VAR 0 2
46131: ARRAY
46132: PPUSH
46133: LD_INT 25
46135: PUSH
46136: LD_INT 2
46138: PUSH
46139: EMPTY
46140: LIST
46141: LIST
46142: PPUSH
46143: CALL_OW 72
46147: PUSH
46148: LD_EXP 115
46152: PUSH
46153: LD_VAR 0 2
46157: ARRAY
46158: DIFF
46159: ST_TO_ADDR
// if not tmp then
46160: LD_VAR 0 4
46164: NOT
46165: IFFALSE 46169
// continue ;
46167: GO 45414
// for j in tmp do
46169: LD_ADDR_VAR 0 3
46173: PUSH
46174: LD_VAR 0 4
46178: PUSH
46179: FOR_IN
46180: IFFALSE 46392
// begin if not mc_builders [ i ] then
46182: LD_EXP 119
46186: PUSH
46187: LD_VAR 0 2
46191: ARRAY
46192: NOT
46193: IFFALSE 46251
// begin SetTag ( j , 103 ) ;
46195: LD_VAR 0 3
46199: PPUSH
46200: LD_INT 103
46202: PPUSH
46203: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46207: LD_ADDR_EXP 119
46211: PUSH
46212: LD_EXP 119
46216: PPUSH
46217: LD_VAR 0 2
46221: PUSH
46222: LD_EXP 119
46226: PUSH
46227: LD_VAR 0 2
46231: ARRAY
46232: PUSH
46233: LD_INT 1
46235: PLUS
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PPUSH
46241: LD_VAR 0 3
46245: PPUSH
46246: CALL 70157 0 3
46250: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46251: LD_VAR 0 3
46255: PPUSH
46256: CALL_OW 310
46260: IFFALSE 46271
// ComExitBuilding ( j ) ;
46262: LD_VAR 0 3
46266: PPUSH
46267: CALL_OW 122
// wait ( 3 ) ;
46271: LD_INT 3
46273: PPUSH
46274: CALL_OW 67
// if not mc_build_list [ i ] then
46278: LD_EXP 118
46282: PUSH
46283: LD_VAR 0 2
46287: ARRAY
46288: NOT
46289: IFFALSE 46293
// break ;
46291: GO 46392
// if not HasTask ( j ) then
46293: LD_VAR 0 3
46297: PPUSH
46298: CALL_OW 314
46302: NOT
46303: IFFALSE 46390
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46305: LD_VAR 0 3
46309: PPUSH
46310: LD_EXP 118
46314: PUSH
46315: LD_VAR 0 2
46319: ARRAY
46320: PUSH
46321: LD_INT 1
46323: ARRAY
46324: PUSH
46325: LD_INT 1
46327: ARRAY
46328: PPUSH
46329: LD_EXP 118
46333: PUSH
46334: LD_VAR 0 2
46338: ARRAY
46339: PUSH
46340: LD_INT 1
46342: ARRAY
46343: PUSH
46344: LD_INT 2
46346: ARRAY
46347: PPUSH
46348: LD_EXP 118
46352: PUSH
46353: LD_VAR 0 2
46357: ARRAY
46358: PUSH
46359: LD_INT 1
46361: ARRAY
46362: PUSH
46363: LD_INT 3
46365: ARRAY
46366: PPUSH
46367: LD_EXP 118
46371: PUSH
46372: LD_VAR 0 2
46376: ARRAY
46377: PUSH
46378: LD_INT 1
46380: ARRAY
46381: PUSH
46382: LD_INT 4
46384: ARRAY
46385: PPUSH
46386: CALL_OW 145
// end ;
46390: GO 46179
46392: POP
46393: POP
// end else
46394: GO 46538
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46396: LD_EXP 113
46400: PUSH
46401: LD_VAR 0 2
46405: ARRAY
46406: PPUSH
46407: LD_EXP 118
46411: PUSH
46412: LD_VAR 0 2
46416: ARRAY
46417: PUSH
46418: LD_INT 1
46420: ARRAY
46421: PUSH
46422: LD_INT 1
46424: ARRAY
46425: PPUSH
46426: LD_EXP 118
46430: PUSH
46431: LD_VAR 0 2
46435: ARRAY
46436: PUSH
46437: LD_INT 1
46439: ARRAY
46440: PUSH
46441: LD_INT 2
46443: ARRAY
46444: PPUSH
46445: LD_EXP 118
46449: PUSH
46450: LD_VAR 0 2
46454: ARRAY
46455: PUSH
46456: LD_INT 1
46458: ARRAY
46459: PUSH
46460: LD_INT 3
46462: ARRAY
46463: PPUSH
46464: LD_EXP 118
46468: PUSH
46469: LD_VAR 0 2
46473: ARRAY
46474: PUSH
46475: LD_INT 1
46477: ARRAY
46478: PUSH
46479: LD_INT 4
46481: ARRAY
46482: PPUSH
46483: CALL 76908 0 5
46487: NOT
46488: IFFALSE 46538
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46490: LD_ADDR_EXP 118
46494: PUSH
46495: LD_EXP 118
46499: PPUSH
46500: LD_VAR 0 2
46504: PPUSH
46505: LD_EXP 118
46509: PUSH
46510: LD_VAR 0 2
46514: ARRAY
46515: PPUSH
46516: LD_INT 1
46518: PPUSH
46519: LD_INT 1
46521: NEG
46522: PPUSH
46523: LD_INT 0
46525: PPUSH
46526: CALL 69575 0 4
46530: PPUSH
46531: CALL_OW 1
46535: ST_TO_ADDR
// continue ;
46536: GO 45414
// end ; end ; end ;
46538: GO 45414
46540: POP
46541: POP
// end ;
46542: LD_VAR 0 1
46546: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46547: LD_INT 0
46549: PPUSH
46550: PPUSH
46551: PPUSH
46552: PPUSH
46553: PPUSH
46554: PPUSH
// if not mc_bases then
46555: LD_EXP 113
46559: NOT
46560: IFFALSE 46564
// exit ;
46562: GO 46991
// for i = 1 to mc_bases do
46564: LD_ADDR_VAR 0 2
46568: PUSH
46569: DOUBLE
46570: LD_INT 1
46572: DEC
46573: ST_TO_ADDR
46574: LD_EXP 113
46578: PUSH
46579: FOR_TO
46580: IFFALSE 46989
// begin tmp := mc_build_upgrade [ i ] ;
46582: LD_ADDR_VAR 0 4
46586: PUSH
46587: LD_EXP 145
46591: PUSH
46592: LD_VAR 0 2
46596: ARRAY
46597: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46598: LD_ADDR_VAR 0 6
46602: PUSH
46603: LD_EXP 146
46607: PUSH
46608: LD_VAR 0 2
46612: ARRAY
46613: PPUSH
46614: LD_INT 2
46616: PUSH
46617: LD_INT 30
46619: PUSH
46620: LD_INT 6
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PUSH
46627: LD_INT 30
46629: PUSH
46630: LD_INT 7
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: LIST
46641: PPUSH
46642: CALL_OW 72
46646: ST_TO_ADDR
// if not tmp and not lab then
46647: LD_VAR 0 4
46651: NOT
46652: PUSH
46653: LD_VAR 0 6
46657: NOT
46658: AND
46659: IFFALSE 46663
// continue ;
46661: GO 46579
// if tmp then
46663: LD_VAR 0 4
46667: IFFALSE 46787
// for j in tmp do
46669: LD_ADDR_VAR 0 3
46673: PUSH
46674: LD_VAR 0 4
46678: PUSH
46679: FOR_IN
46680: IFFALSE 46785
// begin if UpgradeCost ( j ) then
46682: LD_VAR 0 3
46686: PPUSH
46687: CALL 76568 0 1
46691: IFFALSE 46783
// begin ComUpgrade ( j ) ;
46693: LD_VAR 0 3
46697: PPUSH
46698: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46702: LD_ADDR_EXP 145
46706: PUSH
46707: LD_EXP 145
46711: PPUSH
46712: LD_VAR 0 2
46716: PPUSH
46717: LD_EXP 145
46721: PUSH
46722: LD_VAR 0 2
46726: ARRAY
46727: PUSH
46728: LD_VAR 0 3
46732: DIFF
46733: PPUSH
46734: CALL_OW 1
46738: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46739: LD_ADDR_EXP 120
46743: PUSH
46744: LD_EXP 120
46748: PPUSH
46749: LD_VAR 0 2
46753: PUSH
46754: LD_EXP 120
46758: PUSH
46759: LD_VAR 0 2
46763: ARRAY
46764: PUSH
46765: LD_INT 1
46767: PLUS
46768: PUSH
46769: EMPTY
46770: LIST
46771: LIST
46772: PPUSH
46773: LD_VAR 0 3
46777: PPUSH
46778: CALL 70157 0 3
46782: ST_TO_ADDR
// end ; end ;
46783: GO 46679
46785: POP
46786: POP
// if not lab or not mc_lab_upgrade [ i ] then
46787: LD_VAR 0 6
46791: NOT
46792: PUSH
46793: LD_EXP 147
46797: PUSH
46798: LD_VAR 0 2
46802: ARRAY
46803: NOT
46804: OR
46805: IFFALSE 46809
// continue ;
46807: GO 46579
// for j in lab do
46809: LD_ADDR_VAR 0 3
46813: PUSH
46814: LD_VAR 0 6
46818: PUSH
46819: FOR_IN
46820: IFFALSE 46985
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46822: LD_VAR 0 3
46826: PPUSH
46827: CALL_OW 266
46831: PUSH
46832: LD_INT 6
46834: PUSH
46835: LD_INT 7
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: IN
46842: PUSH
46843: LD_VAR 0 3
46847: PPUSH
46848: CALL_OW 461
46852: PUSH
46853: LD_INT 1
46855: NONEQUAL
46856: AND
46857: IFFALSE 46983
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46859: LD_VAR 0 3
46863: PPUSH
46864: LD_EXP 147
46868: PUSH
46869: LD_VAR 0 2
46873: ARRAY
46874: PUSH
46875: LD_INT 1
46877: ARRAY
46878: PPUSH
46879: CALL 76773 0 2
46883: IFFALSE 46983
// begin ComCancel ( j ) ;
46885: LD_VAR 0 3
46889: PPUSH
46890: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46894: LD_VAR 0 3
46898: PPUSH
46899: LD_EXP 147
46903: PUSH
46904: LD_VAR 0 2
46908: ARRAY
46909: PUSH
46910: LD_INT 1
46912: ARRAY
46913: PPUSH
46914: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46918: LD_VAR 0 3
46922: PUSH
46923: LD_EXP 120
46927: PUSH
46928: LD_VAR 0 2
46932: ARRAY
46933: IN
46934: NOT
46935: IFFALSE 46981
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46937: LD_ADDR_EXP 120
46941: PUSH
46942: LD_EXP 120
46946: PPUSH
46947: LD_VAR 0 2
46951: PUSH
46952: LD_EXP 120
46956: PUSH
46957: LD_VAR 0 2
46961: ARRAY
46962: PUSH
46963: LD_INT 1
46965: PLUS
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PPUSH
46971: LD_VAR 0 3
46975: PPUSH
46976: CALL 70157 0 3
46980: ST_TO_ADDR
// break ;
46981: GO 46985
// end ; end ; end ;
46983: GO 46819
46985: POP
46986: POP
// end ;
46987: GO 46579
46989: POP
46990: POP
// end ;
46991: LD_VAR 0 1
46995: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46996: LD_INT 0
46998: PPUSH
46999: PPUSH
47000: PPUSH
47001: PPUSH
47002: PPUSH
47003: PPUSH
47004: PPUSH
47005: PPUSH
47006: PPUSH
// if not mc_bases then
47007: LD_EXP 113
47011: NOT
47012: IFFALSE 47016
// exit ;
47014: GO 47421
// for i = 1 to mc_bases do
47016: LD_ADDR_VAR 0 2
47020: PUSH
47021: DOUBLE
47022: LD_INT 1
47024: DEC
47025: ST_TO_ADDR
47026: LD_EXP 113
47030: PUSH
47031: FOR_TO
47032: IFFALSE 47419
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47034: LD_EXP 121
47038: PUSH
47039: LD_VAR 0 2
47043: ARRAY
47044: NOT
47045: PUSH
47046: LD_EXP 113
47050: PUSH
47051: LD_VAR 0 2
47055: ARRAY
47056: PPUSH
47057: LD_INT 30
47059: PUSH
47060: LD_INT 3
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PPUSH
47067: CALL_OW 72
47071: NOT
47072: OR
47073: IFFALSE 47077
// continue ;
47075: GO 47031
// busy := false ;
47077: LD_ADDR_VAR 0 8
47081: PUSH
47082: LD_INT 0
47084: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47085: LD_ADDR_VAR 0 4
47089: PUSH
47090: LD_EXP 113
47094: PUSH
47095: LD_VAR 0 2
47099: ARRAY
47100: PPUSH
47101: LD_INT 30
47103: PUSH
47104: LD_INT 3
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PPUSH
47111: CALL_OW 72
47115: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47116: LD_ADDR_VAR 0 6
47120: PUSH
47121: LD_EXP 121
47125: PUSH
47126: LD_VAR 0 2
47130: ARRAY
47131: PPUSH
47132: LD_INT 2
47134: PUSH
47135: LD_INT 30
47137: PUSH
47138: LD_INT 32
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 30
47147: PUSH
47148: LD_INT 33
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: LIST
47159: PPUSH
47160: CALL_OW 72
47164: ST_TO_ADDR
// if not t then
47165: LD_VAR 0 6
47169: NOT
47170: IFFALSE 47174
// continue ;
47172: GO 47031
// for j in tmp do
47174: LD_ADDR_VAR 0 3
47178: PUSH
47179: LD_VAR 0 4
47183: PUSH
47184: FOR_IN
47185: IFFALSE 47215
// if not BuildingStatus ( j ) = bs_idle then
47187: LD_VAR 0 3
47191: PPUSH
47192: CALL_OW 461
47196: PUSH
47197: LD_INT 2
47199: EQUAL
47200: NOT
47201: IFFALSE 47213
// begin busy := true ;
47203: LD_ADDR_VAR 0 8
47207: PUSH
47208: LD_INT 1
47210: ST_TO_ADDR
// break ;
47211: GO 47215
// end ;
47213: GO 47184
47215: POP
47216: POP
// if busy then
47217: LD_VAR 0 8
47221: IFFALSE 47225
// continue ;
47223: GO 47031
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47225: LD_ADDR_VAR 0 7
47229: PUSH
47230: LD_VAR 0 6
47234: PPUSH
47235: LD_INT 35
47237: PUSH
47238: LD_INT 0
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PPUSH
47245: CALL_OW 72
47249: ST_TO_ADDR
// if tw then
47250: LD_VAR 0 7
47254: IFFALSE 47331
// begin tw := tw [ 1 ] ;
47256: LD_ADDR_VAR 0 7
47260: PUSH
47261: LD_VAR 0 7
47265: PUSH
47266: LD_INT 1
47268: ARRAY
47269: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47270: LD_ADDR_VAR 0 9
47274: PUSH
47275: LD_VAR 0 7
47279: PPUSH
47280: LD_EXP 138
47284: PUSH
47285: LD_VAR 0 2
47289: ARRAY
47290: PPUSH
47291: CALL 75127 0 2
47295: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47296: LD_EXP 152
47300: PUSH
47301: LD_VAR 0 2
47305: ARRAY
47306: IFFALSE 47329
// if not weapon in mc_allowed_tower_weapons [ i ] then
47308: LD_VAR 0 9
47312: PUSH
47313: LD_EXP 152
47317: PUSH
47318: LD_VAR 0 2
47322: ARRAY
47323: IN
47324: NOT
47325: IFFALSE 47329
// continue ;
47327: GO 47031
// end else
47329: GO 47394
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47331: LD_ADDR_VAR 0 5
47335: PUSH
47336: LD_EXP 121
47340: PUSH
47341: LD_VAR 0 2
47345: ARRAY
47346: PPUSH
47347: LD_VAR 0 4
47351: PPUSH
47352: CALL 100748 0 2
47356: ST_TO_ADDR
// if not tmp2 then
47357: LD_VAR 0 5
47361: NOT
47362: IFFALSE 47366
// continue ;
47364: GO 47031
// tw := tmp2 [ 1 ] ;
47366: LD_ADDR_VAR 0 7
47370: PUSH
47371: LD_VAR 0 5
47375: PUSH
47376: LD_INT 1
47378: ARRAY
47379: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47380: LD_ADDR_VAR 0 9
47384: PUSH
47385: LD_VAR 0 5
47389: PUSH
47390: LD_INT 2
47392: ARRAY
47393: ST_TO_ADDR
// end ; if not weapon then
47394: LD_VAR 0 9
47398: NOT
47399: IFFALSE 47403
// continue ;
47401: GO 47031
// ComPlaceWeapon ( tw , weapon ) ;
47403: LD_VAR 0 7
47407: PPUSH
47408: LD_VAR 0 9
47412: PPUSH
47413: CALL_OW 148
// end ;
47417: GO 47031
47419: POP
47420: POP
// end ;
47421: LD_VAR 0 1
47425: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47426: LD_INT 0
47428: PPUSH
47429: PPUSH
47430: PPUSH
47431: PPUSH
47432: PPUSH
47433: PPUSH
// if not mc_bases then
47434: LD_EXP 113
47438: NOT
47439: IFFALSE 47443
// exit ;
47441: GO 48219
// for i = 1 to mc_bases do
47443: LD_ADDR_VAR 0 2
47447: PUSH
47448: DOUBLE
47449: LD_INT 1
47451: DEC
47452: ST_TO_ADDR
47453: LD_EXP 113
47457: PUSH
47458: FOR_TO
47459: IFFALSE 48217
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47461: LD_EXP 126
47465: PUSH
47466: LD_VAR 0 2
47470: ARRAY
47471: NOT
47472: PUSH
47473: LD_EXP 126
47477: PUSH
47478: LD_VAR 0 2
47482: ARRAY
47483: PUSH
47484: LD_EXP 127
47488: PUSH
47489: LD_VAR 0 2
47493: ARRAY
47494: EQUAL
47495: OR
47496: PUSH
47497: LD_EXP 136
47501: PUSH
47502: LD_VAR 0 2
47506: ARRAY
47507: OR
47508: IFFALSE 47512
// continue ;
47510: GO 47458
// if mc_miners [ i ] then
47512: LD_EXP 127
47516: PUSH
47517: LD_VAR 0 2
47521: ARRAY
47522: IFFALSE 47904
// begin for j = mc_miners [ i ] downto 1 do
47524: LD_ADDR_VAR 0 3
47528: PUSH
47529: DOUBLE
47530: LD_EXP 127
47534: PUSH
47535: LD_VAR 0 2
47539: ARRAY
47540: INC
47541: ST_TO_ADDR
47542: LD_INT 1
47544: PUSH
47545: FOR_DOWNTO
47546: IFFALSE 47902
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47548: LD_EXP 127
47552: PUSH
47553: LD_VAR 0 2
47557: ARRAY
47558: PUSH
47559: LD_VAR 0 3
47563: ARRAY
47564: PPUSH
47565: CALL_OW 301
47569: PUSH
47570: LD_EXP 127
47574: PUSH
47575: LD_VAR 0 2
47579: ARRAY
47580: PUSH
47581: LD_VAR 0 3
47585: ARRAY
47586: PPUSH
47587: CALL_OW 257
47591: PUSH
47592: LD_INT 1
47594: NONEQUAL
47595: OR
47596: IFFALSE 47659
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47598: LD_ADDR_VAR 0 5
47602: PUSH
47603: LD_EXP 127
47607: PUSH
47608: LD_VAR 0 2
47612: ARRAY
47613: PUSH
47614: LD_EXP 127
47618: PUSH
47619: LD_VAR 0 2
47623: ARRAY
47624: PUSH
47625: LD_VAR 0 3
47629: ARRAY
47630: DIFF
47631: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47632: LD_ADDR_EXP 127
47636: PUSH
47637: LD_EXP 127
47641: PPUSH
47642: LD_VAR 0 2
47646: PPUSH
47647: LD_VAR 0 5
47651: PPUSH
47652: CALL_OW 1
47656: ST_TO_ADDR
// continue ;
47657: GO 47545
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47659: LD_EXP 127
47663: PUSH
47664: LD_VAR 0 2
47668: ARRAY
47669: PUSH
47670: LD_VAR 0 3
47674: ARRAY
47675: PPUSH
47676: CALL_OW 257
47680: PUSH
47681: LD_INT 1
47683: EQUAL
47684: PUSH
47685: LD_EXP 127
47689: PUSH
47690: LD_VAR 0 2
47694: ARRAY
47695: PUSH
47696: LD_VAR 0 3
47700: ARRAY
47701: PPUSH
47702: CALL_OW 459
47706: NOT
47707: AND
47708: PUSH
47709: LD_EXP 127
47713: PUSH
47714: LD_VAR 0 2
47718: ARRAY
47719: PUSH
47720: LD_VAR 0 3
47724: ARRAY
47725: PPUSH
47726: CALL_OW 314
47730: NOT
47731: AND
47732: IFFALSE 47900
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47734: LD_EXP 127
47738: PUSH
47739: LD_VAR 0 2
47743: ARRAY
47744: PUSH
47745: LD_VAR 0 3
47749: ARRAY
47750: PPUSH
47751: CALL_OW 310
47755: IFFALSE 47778
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47757: LD_EXP 127
47761: PUSH
47762: LD_VAR 0 2
47766: ARRAY
47767: PUSH
47768: LD_VAR 0 3
47772: ARRAY
47773: PPUSH
47774: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47778: LD_EXP 127
47782: PUSH
47783: LD_VAR 0 2
47787: ARRAY
47788: PUSH
47789: LD_VAR 0 3
47793: ARRAY
47794: PPUSH
47795: CALL_OW 314
47799: NOT
47800: IFFALSE 47900
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47802: LD_EXP 127
47806: PUSH
47807: LD_VAR 0 2
47811: ARRAY
47812: PUSH
47813: LD_VAR 0 3
47817: ARRAY
47818: PPUSH
47819: LD_EXP 126
47823: PUSH
47824: LD_VAR 0 2
47828: ARRAY
47829: PUSH
47830: LD_VAR 0 3
47834: PUSH
47835: LD_EXP 126
47839: PUSH
47840: LD_VAR 0 2
47844: ARRAY
47845: MOD
47846: PUSH
47847: LD_INT 1
47849: PLUS
47850: ARRAY
47851: PUSH
47852: LD_INT 1
47854: ARRAY
47855: PPUSH
47856: LD_EXP 126
47860: PUSH
47861: LD_VAR 0 2
47865: ARRAY
47866: PUSH
47867: LD_VAR 0 3
47871: PUSH
47872: LD_EXP 126
47876: PUSH
47877: LD_VAR 0 2
47881: ARRAY
47882: MOD
47883: PUSH
47884: LD_INT 1
47886: PLUS
47887: ARRAY
47888: PUSH
47889: LD_INT 2
47891: ARRAY
47892: PPUSH
47893: LD_INT 0
47895: PPUSH
47896: CALL_OW 193
// end ; end ;
47900: GO 47545
47902: POP
47903: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47904: LD_ADDR_VAR 0 5
47908: PUSH
47909: LD_EXP 113
47913: PUSH
47914: LD_VAR 0 2
47918: ARRAY
47919: PPUSH
47920: LD_INT 2
47922: PUSH
47923: LD_INT 30
47925: PUSH
47926: LD_INT 4
47928: PUSH
47929: EMPTY
47930: LIST
47931: LIST
47932: PUSH
47933: LD_INT 30
47935: PUSH
47936: LD_INT 5
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PUSH
47943: LD_INT 30
47945: PUSH
47946: LD_INT 32
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: PPUSH
47959: CALL_OW 72
47963: ST_TO_ADDR
// if not tmp then
47964: LD_VAR 0 5
47968: NOT
47969: IFFALSE 47973
// continue ;
47971: GO 47458
// list := [ ] ;
47973: LD_ADDR_VAR 0 6
47977: PUSH
47978: EMPTY
47979: ST_TO_ADDR
// for j in tmp do
47980: LD_ADDR_VAR 0 3
47984: PUSH
47985: LD_VAR 0 5
47989: PUSH
47990: FOR_IN
47991: IFFALSE 48060
// begin for k in UnitsInside ( j ) do
47993: LD_ADDR_VAR 0 4
47997: PUSH
47998: LD_VAR 0 3
48002: PPUSH
48003: CALL_OW 313
48007: PUSH
48008: FOR_IN
48009: IFFALSE 48056
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48011: LD_VAR 0 4
48015: PPUSH
48016: CALL_OW 257
48020: PUSH
48021: LD_INT 1
48023: EQUAL
48024: PUSH
48025: LD_VAR 0 4
48029: PPUSH
48030: CALL_OW 459
48034: NOT
48035: AND
48036: IFFALSE 48054
// list := list ^ k ;
48038: LD_ADDR_VAR 0 6
48042: PUSH
48043: LD_VAR 0 6
48047: PUSH
48048: LD_VAR 0 4
48052: ADD
48053: ST_TO_ADDR
48054: GO 48008
48056: POP
48057: POP
// end ;
48058: GO 47990
48060: POP
48061: POP
// list := list diff mc_miners [ i ] ;
48062: LD_ADDR_VAR 0 6
48066: PUSH
48067: LD_VAR 0 6
48071: PUSH
48072: LD_EXP 127
48076: PUSH
48077: LD_VAR 0 2
48081: ARRAY
48082: DIFF
48083: ST_TO_ADDR
// if not list then
48084: LD_VAR 0 6
48088: NOT
48089: IFFALSE 48093
// continue ;
48091: GO 47458
// k := mc_mines [ i ] - mc_miners [ i ] ;
48093: LD_ADDR_VAR 0 4
48097: PUSH
48098: LD_EXP 126
48102: PUSH
48103: LD_VAR 0 2
48107: ARRAY
48108: PUSH
48109: LD_EXP 127
48113: PUSH
48114: LD_VAR 0 2
48118: ARRAY
48119: MINUS
48120: ST_TO_ADDR
// if k > list then
48121: LD_VAR 0 4
48125: PUSH
48126: LD_VAR 0 6
48130: GREATER
48131: IFFALSE 48143
// k := list ;
48133: LD_ADDR_VAR 0 4
48137: PUSH
48138: LD_VAR 0 6
48142: ST_TO_ADDR
// for j = 1 to k do
48143: LD_ADDR_VAR 0 3
48147: PUSH
48148: DOUBLE
48149: LD_INT 1
48151: DEC
48152: ST_TO_ADDR
48153: LD_VAR 0 4
48157: PUSH
48158: FOR_TO
48159: IFFALSE 48213
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48161: LD_ADDR_EXP 127
48165: PUSH
48166: LD_EXP 127
48170: PPUSH
48171: LD_VAR 0 2
48175: PUSH
48176: LD_EXP 127
48180: PUSH
48181: LD_VAR 0 2
48185: ARRAY
48186: PUSH
48187: LD_INT 1
48189: PLUS
48190: PUSH
48191: EMPTY
48192: LIST
48193: LIST
48194: PPUSH
48195: LD_VAR 0 6
48199: PUSH
48200: LD_VAR 0 3
48204: ARRAY
48205: PPUSH
48206: CALL 70157 0 3
48210: ST_TO_ADDR
48211: GO 48158
48213: POP
48214: POP
// end ;
48215: GO 47458
48217: POP
48218: POP
// end ;
48219: LD_VAR 0 1
48223: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48224: LD_INT 0
48226: PPUSH
48227: PPUSH
48228: PPUSH
48229: PPUSH
48230: PPUSH
48231: PPUSH
48232: PPUSH
48233: PPUSH
48234: PPUSH
48235: PPUSH
// if not mc_bases then
48236: LD_EXP 113
48240: NOT
48241: IFFALSE 48245
// exit ;
48243: GO 49995
// for i = 1 to mc_bases do
48245: LD_ADDR_VAR 0 2
48249: PUSH
48250: DOUBLE
48251: LD_INT 1
48253: DEC
48254: ST_TO_ADDR
48255: LD_EXP 113
48259: PUSH
48260: FOR_TO
48261: IFFALSE 49993
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48263: LD_EXP 113
48267: PUSH
48268: LD_VAR 0 2
48272: ARRAY
48273: NOT
48274: PUSH
48275: LD_EXP 120
48279: PUSH
48280: LD_VAR 0 2
48284: ARRAY
48285: OR
48286: IFFALSE 48290
// continue ;
48288: GO 48260
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48290: LD_EXP 129
48294: PUSH
48295: LD_VAR 0 2
48299: ARRAY
48300: NOT
48301: PUSH
48302: LD_EXP 130
48306: PUSH
48307: LD_VAR 0 2
48311: ARRAY
48312: AND
48313: IFFALSE 48351
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48315: LD_ADDR_EXP 130
48319: PUSH
48320: LD_EXP 130
48324: PPUSH
48325: LD_VAR 0 2
48329: PPUSH
48330: EMPTY
48331: PPUSH
48332: CALL_OW 1
48336: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48337: LD_VAR 0 2
48341: PPUSH
48342: LD_INT 107
48344: PPUSH
48345: CALL 39199 0 2
// continue ;
48349: GO 48260
// end ; target := [ ] ;
48351: LD_ADDR_VAR 0 6
48355: PUSH
48356: EMPTY
48357: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48358: LD_ADDR_VAR 0 3
48362: PUSH
48363: DOUBLE
48364: LD_EXP 129
48368: PUSH
48369: LD_VAR 0 2
48373: ARRAY
48374: INC
48375: ST_TO_ADDR
48376: LD_INT 1
48378: PUSH
48379: FOR_DOWNTO
48380: IFFALSE 48640
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48382: LD_EXP 129
48386: PUSH
48387: LD_VAR 0 2
48391: ARRAY
48392: PUSH
48393: LD_VAR 0 3
48397: ARRAY
48398: PUSH
48399: LD_INT 2
48401: ARRAY
48402: PPUSH
48403: LD_EXP 129
48407: PUSH
48408: LD_VAR 0 2
48412: ARRAY
48413: PUSH
48414: LD_VAR 0 3
48418: ARRAY
48419: PUSH
48420: LD_INT 3
48422: ARRAY
48423: PPUSH
48424: CALL_OW 488
48428: PUSH
48429: LD_EXP 129
48433: PUSH
48434: LD_VAR 0 2
48438: ARRAY
48439: PUSH
48440: LD_VAR 0 3
48444: ARRAY
48445: PUSH
48446: LD_INT 2
48448: ARRAY
48449: PPUSH
48450: LD_EXP 129
48454: PUSH
48455: LD_VAR 0 2
48459: ARRAY
48460: PUSH
48461: LD_VAR 0 3
48465: ARRAY
48466: PUSH
48467: LD_INT 3
48469: ARRAY
48470: PPUSH
48471: CALL_OW 284
48475: PUSH
48476: LD_INT 0
48478: EQUAL
48479: AND
48480: IFFALSE 48535
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48482: LD_ADDR_VAR 0 5
48486: PUSH
48487: LD_EXP 129
48491: PUSH
48492: LD_VAR 0 2
48496: ARRAY
48497: PPUSH
48498: LD_VAR 0 3
48502: PPUSH
48503: CALL_OW 3
48507: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48508: LD_ADDR_EXP 129
48512: PUSH
48513: LD_EXP 129
48517: PPUSH
48518: LD_VAR 0 2
48522: PPUSH
48523: LD_VAR 0 5
48527: PPUSH
48528: CALL_OW 1
48532: ST_TO_ADDR
// continue ;
48533: GO 48379
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48535: LD_EXP 113
48539: PUSH
48540: LD_VAR 0 2
48544: ARRAY
48545: PUSH
48546: LD_INT 1
48548: ARRAY
48549: PPUSH
48550: CALL_OW 255
48554: PPUSH
48555: LD_EXP 129
48559: PUSH
48560: LD_VAR 0 2
48564: ARRAY
48565: PUSH
48566: LD_VAR 0 3
48570: ARRAY
48571: PUSH
48572: LD_INT 2
48574: ARRAY
48575: PPUSH
48576: LD_EXP 129
48580: PUSH
48581: LD_VAR 0 2
48585: ARRAY
48586: PUSH
48587: LD_VAR 0 3
48591: ARRAY
48592: PUSH
48593: LD_INT 3
48595: ARRAY
48596: PPUSH
48597: LD_INT 30
48599: PPUSH
48600: CALL 71053 0 4
48604: PUSH
48605: LD_INT 4
48607: ARRAY
48608: PUSH
48609: LD_INT 0
48611: EQUAL
48612: IFFALSE 48638
// begin target := mc_crates [ i ] [ j ] ;
48614: LD_ADDR_VAR 0 6
48618: PUSH
48619: LD_EXP 129
48623: PUSH
48624: LD_VAR 0 2
48628: ARRAY
48629: PUSH
48630: LD_VAR 0 3
48634: ARRAY
48635: ST_TO_ADDR
// break ;
48636: GO 48640
// end ; end ;
48638: GO 48379
48640: POP
48641: POP
// if not target then
48642: LD_VAR 0 6
48646: NOT
48647: IFFALSE 48651
// continue ;
48649: GO 48260
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48651: LD_ADDR_VAR 0 7
48655: PUSH
48656: LD_EXP 132
48660: PUSH
48661: LD_VAR 0 2
48665: ARRAY
48666: PPUSH
48667: LD_INT 2
48669: PUSH
48670: LD_INT 3
48672: PUSH
48673: LD_INT 58
48675: PUSH
48676: EMPTY
48677: LIST
48678: PUSH
48679: EMPTY
48680: LIST
48681: LIST
48682: PUSH
48683: LD_INT 61
48685: PUSH
48686: EMPTY
48687: LIST
48688: PUSH
48689: LD_INT 33
48691: PUSH
48692: LD_INT 5
48694: PUSH
48695: EMPTY
48696: LIST
48697: LIST
48698: PUSH
48699: LD_INT 33
48701: PUSH
48702: LD_INT 3
48704: PUSH
48705: EMPTY
48706: LIST
48707: LIST
48708: PUSH
48709: EMPTY
48710: LIST
48711: LIST
48712: LIST
48713: LIST
48714: LIST
48715: PUSH
48716: LD_INT 2
48718: PUSH
48719: LD_INT 34
48721: PUSH
48722: LD_INT 32
48724: PUSH
48725: EMPTY
48726: LIST
48727: LIST
48728: PUSH
48729: LD_INT 34
48731: PUSH
48732: LD_INT 51
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PUSH
48739: LD_INT 34
48741: PUSH
48742: LD_INT 12
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: PUSH
48749: EMPTY
48750: LIST
48751: LIST
48752: LIST
48753: LIST
48754: PUSH
48755: EMPTY
48756: LIST
48757: LIST
48758: PPUSH
48759: CALL_OW 72
48763: ST_TO_ADDR
// if not cargo then
48764: LD_VAR 0 7
48768: NOT
48769: IFFALSE 49412
// begin if mc_crates_collector [ i ] < 5 then
48771: LD_EXP 130
48775: PUSH
48776: LD_VAR 0 2
48780: ARRAY
48781: PUSH
48782: LD_INT 5
48784: LESS
48785: IFFALSE 49151
// begin if mc_ape [ i ] then
48787: LD_EXP 142
48791: PUSH
48792: LD_VAR 0 2
48796: ARRAY
48797: IFFALSE 48844
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48799: LD_ADDR_VAR 0 5
48803: PUSH
48804: LD_EXP 142
48808: PUSH
48809: LD_VAR 0 2
48813: ARRAY
48814: PPUSH
48815: LD_INT 25
48817: PUSH
48818: LD_INT 16
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: PUSH
48825: LD_INT 24
48827: PUSH
48828: LD_INT 750
48830: PUSH
48831: EMPTY
48832: LIST
48833: LIST
48834: PUSH
48835: EMPTY
48836: LIST
48837: LIST
48838: PPUSH
48839: CALL_OW 72
48843: ST_TO_ADDR
// if not tmp then
48844: LD_VAR 0 5
48848: NOT
48849: IFFALSE 48896
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48851: LD_ADDR_VAR 0 5
48855: PUSH
48856: LD_EXP 113
48860: PUSH
48861: LD_VAR 0 2
48865: ARRAY
48866: PPUSH
48867: LD_INT 25
48869: PUSH
48870: LD_INT 2
48872: PUSH
48873: EMPTY
48874: LIST
48875: LIST
48876: PUSH
48877: LD_INT 24
48879: PUSH
48880: LD_INT 750
48882: PUSH
48883: EMPTY
48884: LIST
48885: LIST
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PPUSH
48891: CALL_OW 72
48895: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48896: LD_EXP 142
48900: PUSH
48901: LD_VAR 0 2
48905: ARRAY
48906: PUSH
48907: LD_EXP 113
48911: PUSH
48912: LD_VAR 0 2
48916: ARRAY
48917: PPUSH
48918: LD_INT 25
48920: PUSH
48921: LD_INT 2
48923: PUSH
48924: EMPTY
48925: LIST
48926: LIST
48927: PUSH
48928: LD_INT 24
48930: PUSH
48931: LD_INT 750
48933: PUSH
48934: EMPTY
48935: LIST
48936: LIST
48937: PUSH
48938: EMPTY
48939: LIST
48940: LIST
48941: PPUSH
48942: CALL_OW 72
48946: AND
48947: PUSH
48948: LD_VAR 0 5
48952: PUSH
48953: LD_INT 5
48955: LESS
48956: AND
48957: IFFALSE 49039
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48959: LD_ADDR_VAR 0 3
48963: PUSH
48964: LD_EXP 113
48968: PUSH
48969: LD_VAR 0 2
48973: ARRAY
48974: PPUSH
48975: LD_INT 25
48977: PUSH
48978: LD_INT 2
48980: PUSH
48981: EMPTY
48982: LIST
48983: LIST
48984: PUSH
48985: LD_INT 24
48987: PUSH
48988: LD_INT 750
48990: PUSH
48991: EMPTY
48992: LIST
48993: LIST
48994: PUSH
48995: EMPTY
48996: LIST
48997: LIST
48998: PPUSH
48999: CALL_OW 72
49003: PUSH
49004: FOR_IN
49005: IFFALSE 49037
// begin tmp := tmp union j ;
49007: LD_ADDR_VAR 0 5
49011: PUSH
49012: LD_VAR 0 5
49016: PUSH
49017: LD_VAR 0 3
49021: UNION
49022: ST_TO_ADDR
// if tmp >= 5 then
49023: LD_VAR 0 5
49027: PUSH
49028: LD_INT 5
49030: GREATEREQUAL
49031: IFFALSE 49035
// break ;
49033: GO 49037
// end ;
49035: GO 49004
49037: POP
49038: POP
// end ; if not tmp then
49039: LD_VAR 0 5
49043: NOT
49044: IFFALSE 49048
// continue ;
49046: GO 48260
// for j in tmp do
49048: LD_ADDR_VAR 0 3
49052: PUSH
49053: LD_VAR 0 5
49057: PUSH
49058: FOR_IN
49059: IFFALSE 49149
// if not GetTag ( j ) then
49061: LD_VAR 0 3
49065: PPUSH
49066: CALL_OW 110
49070: NOT
49071: IFFALSE 49147
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49073: LD_ADDR_EXP 130
49077: PUSH
49078: LD_EXP 130
49082: PPUSH
49083: LD_VAR 0 2
49087: PUSH
49088: LD_EXP 130
49092: PUSH
49093: LD_VAR 0 2
49097: ARRAY
49098: PUSH
49099: LD_INT 1
49101: PLUS
49102: PUSH
49103: EMPTY
49104: LIST
49105: LIST
49106: PPUSH
49107: LD_VAR 0 3
49111: PPUSH
49112: CALL 70157 0 3
49116: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49117: LD_VAR 0 3
49121: PPUSH
49122: LD_INT 107
49124: PPUSH
49125: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49129: LD_EXP 130
49133: PUSH
49134: LD_VAR 0 2
49138: ARRAY
49139: PUSH
49140: LD_INT 5
49142: GREATEREQUAL
49143: IFFALSE 49147
// break ;
49145: GO 49149
// end ;
49147: GO 49058
49149: POP
49150: POP
// end ; if mc_crates_collector [ i ] and target then
49151: LD_EXP 130
49155: PUSH
49156: LD_VAR 0 2
49160: ARRAY
49161: PUSH
49162: LD_VAR 0 6
49166: AND
49167: IFFALSE 49410
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49169: LD_EXP 130
49173: PUSH
49174: LD_VAR 0 2
49178: ARRAY
49179: PUSH
49180: LD_VAR 0 6
49184: PUSH
49185: LD_INT 1
49187: ARRAY
49188: LESS
49189: IFFALSE 49209
// tmp := mc_crates_collector [ i ] else
49191: LD_ADDR_VAR 0 5
49195: PUSH
49196: LD_EXP 130
49200: PUSH
49201: LD_VAR 0 2
49205: ARRAY
49206: ST_TO_ADDR
49207: GO 49223
// tmp := target [ 1 ] ;
49209: LD_ADDR_VAR 0 5
49213: PUSH
49214: LD_VAR 0 6
49218: PUSH
49219: LD_INT 1
49221: ARRAY
49222: ST_TO_ADDR
// k := 0 ;
49223: LD_ADDR_VAR 0 4
49227: PUSH
49228: LD_INT 0
49230: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49231: LD_ADDR_VAR 0 3
49235: PUSH
49236: LD_EXP 130
49240: PUSH
49241: LD_VAR 0 2
49245: ARRAY
49246: PUSH
49247: FOR_IN
49248: IFFALSE 49408
// begin k := k + 1 ;
49250: LD_ADDR_VAR 0 4
49254: PUSH
49255: LD_VAR 0 4
49259: PUSH
49260: LD_INT 1
49262: PLUS
49263: ST_TO_ADDR
// if k > tmp then
49264: LD_VAR 0 4
49268: PUSH
49269: LD_VAR 0 5
49273: GREATER
49274: IFFALSE 49278
// break ;
49276: GO 49408
// if not GetClass ( j ) in [ 2 , 16 ] then
49278: LD_VAR 0 3
49282: PPUSH
49283: CALL_OW 257
49287: PUSH
49288: LD_INT 2
49290: PUSH
49291: LD_INT 16
49293: PUSH
49294: EMPTY
49295: LIST
49296: LIST
49297: IN
49298: NOT
49299: IFFALSE 49352
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49301: LD_ADDR_EXP 130
49305: PUSH
49306: LD_EXP 130
49310: PPUSH
49311: LD_VAR 0 2
49315: PPUSH
49316: LD_EXP 130
49320: PUSH
49321: LD_VAR 0 2
49325: ARRAY
49326: PUSH
49327: LD_VAR 0 3
49331: DIFF
49332: PPUSH
49333: CALL_OW 1
49337: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49338: LD_VAR 0 3
49342: PPUSH
49343: LD_INT 0
49345: PPUSH
49346: CALL_OW 109
// continue ;
49350: GO 49247
// end ; if IsInUnit ( j ) then
49352: LD_VAR 0 3
49356: PPUSH
49357: CALL_OW 310
49361: IFFALSE 49372
// ComExitBuilding ( j ) ;
49363: LD_VAR 0 3
49367: PPUSH
49368: CALL_OW 122
// wait ( 3 ) ;
49372: LD_INT 3
49374: PPUSH
49375: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49379: LD_VAR 0 3
49383: PPUSH
49384: LD_VAR 0 6
49388: PUSH
49389: LD_INT 2
49391: ARRAY
49392: PPUSH
49393: LD_VAR 0 6
49397: PUSH
49398: LD_INT 3
49400: ARRAY
49401: PPUSH
49402: CALL_OW 117
// end ;
49406: GO 49247
49408: POP
49409: POP
// end ; end else
49410: GO 49991
// begin for j in cargo do
49412: LD_ADDR_VAR 0 3
49416: PUSH
49417: LD_VAR 0 7
49421: PUSH
49422: FOR_IN
49423: IFFALSE 49989
// begin if GetTag ( j ) <> 0 then
49425: LD_VAR 0 3
49429: PPUSH
49430: CALL_OW 110
49434: PUSH
49435: LD_INT 0
49437: NONEQUAL
49438: IFFALSE 49442
// continue ;
49440: GO 49422
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49442: LD_VAR 0 3
49446: PPUSH
49447: CALL_OW 256
49451: PUSH
49452: LD_INT 1000
49454: LESS
49455: PUSH
49456: LD_VAR 0 3
49460: PPUSH
49461: LD_EXP 137
49465: PUSH
49466: LD_VAR 0 2
49470: ARRAY
49471: PPUSH
49472: CALL_OW 308
49476: NOT
49477: AND
49478: IFFALSE 49500
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49480: LD_VAR 0 3
49484: PPUSH
49485: LD_EXP 137
49489: PUSH
49490: LD_VAR 0 2
49494: ARRAY
49495: PPUSH
49496: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49500: LD_VAR 0 3
49504: PPUSH
49505: CALL_OW 256
49509: PUSH
49510: LD_INT 1000
49512: LESS
49513: PUSH
49514: LD_VAR 0 3
49518: PPUSH
49519: LD_EXP 137
49523: PUSH
49524: LD_VAR 0 2
49528: ARRAY
49529: PPUSH
49530: CALL_OW 308
49534: AND
49535: IFFALSE 49539
// continue ;
49537: GO 49422
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49539: LD_VAR 0 3
49543: PPUSH
49544: CALL_OW 262
49548: PUSH
49549: LD_INT 2
49551: EQUAL
49552: PUSH
49553: LD_VAR 0 3
49557: PPUSH
49558: CALL_OW 261
49562: PUSH
49563: LD_INT 15
49565: LESS
49566: AND
49567: IFFALSE 49571
// continue ;
49569: GO 49422
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49571: LD_VAR 0 3
49575: PPUSH
49576: CALL_OW 262
49580: PUSH
49581: LD_INT 1
49583: EQUAL
49584: PUSH
49585: LD_VAR 0 3
49589: PPUSH
49590: CALL_OW 261
49594: PUSH
49595: LD_INT 10
49597: LESS
49598: AND
49599: IFFALSE 49928
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49601: LD_ADDR_VAR 0 8
49605: PUSH
49606: LD_EXP 113
49610: PUSH
49611: LD_VAR 0 2
49615: ARRAY
49616: PPUSH
49617: LD_INT 2
49619: PUSH
49620: LD_INT 30
49622: PUSH
49623: LD_INT 0
49625: PUSH
49626: EMPTY
49627: LIST
49628: LIST
49629: PUSH
49630: LD_INT 30
49632: PUSH
49633: LD_INT 1
49635: PUSH
49636: EMPTY
49637: LIST
49638: LIST
49639: PUSH
49640: EMPTY
49641: LIST
49642: LIST
49643: LIST
49644: PPUSH
49645: CALL_OW 72
49649: ST_TO_ADDR
// if not depot then
49650: LD_VAR 0 8
49654: NOT
49655: IFFALSE 49659
// continue ;
49657: GO 49422
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49659: LD_VAR 0 3
49663: PPUSH
49664: LD_VAR 0 8
49668: PPUSH
49669: LD_VAR 0 3
49673: PPUSH
49674: CALL_OW 74
49678: PPUSH
49679: CALL_OW 296
49683: PUSH
49684: LD_INT 6
49686: LESS
49687: IFFALSE 49703
// SetFuel ( j , 100 ) else
49689: LD_VAR 0 3
49693: PPUSH
49694: LD_INT 100
49696: PPUSH
49697: CALL_OW 240
49701: GO 49928
// if GetFuel ( j ) = 0 then
49703: LD_VAR 0 3
49707: PPUSH
49708: CALL_OW 261
49712: PUSH
49713: LD_INT 0
49715: EQUAL
49716: IFFALSE 49928
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49718: LD_ADDR_EXP 132
49722: PUSH
49723: LD_EXP 132
49727: PPUSH
49728: LD_VAR 0 2
49732: PPUSH
49733: LD_EXP 132
49737: PUSH
49738: LD_VAR 0 2
49742: ARRAY
49743: PUSH
49744: LD_VAR 0 3
49748: DIFF
49749: PPUSH
49750: CALL_OW 1
49754: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49755: LD_VAR 0 3
49759: PPUSH
49760: CALL_OW 263
49764: PUSH
49765: LD_INT 1
49767: EQUAL
49768: IFFALSE 49784
// ComExitVehicle ( IsInUnit ( j ) ) ;
49770: LD_VAR 0 3
49774: PPUSH
49775: CALL_OW 310
49779: PPUSH
49780: CALL_OW 121
// if GetControl ( j ) = control_remote then
49784: LD_VAR 0 3
49788: PPUSH
49789: CALL_OW 263
49793: PUSH
49794: LD_INT 2
49796: EQUAL
49797: IFFALSE 49808
// ComUnlink ( j ) ;
49799: LD_VAR 0 3
49803: PPUSH
49804: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49808: LD_ADDR_VAR 0 9
49812: PUSH
49813: LD_VAR 0 2
49817: PPUSH
49818: LD_INT 3
49820: PPUSH
49821: CALL 59303 0 2
49825: ST_TO_ADDR
// if fac then
49826: LD_VAR 0 9
49830: IFFALSE 49926
// begin for k in fac do
49832: LD_ADDR_VAR 0 4
49836: PUSH
49837: LD_VAR 0 9
49841: PUSH
49842: FOR_IN
49843: IFFALSE 49924
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49845: LD_ADDR_VAR 0 10
49849: PUSH
49850: LD_VAR 0 9
49854: PPUSH
49855: LD_VAR 0 3
49859: PPUSH
49860: CALL_OW 265
49864: PPUSH
49865: LD_VAR 0 3
49869: PPUSH
49870: CALL_OW 262
49874: PPUSH
49875: LD_VAR 0 3
49879: PPUSH
49880: CALL_OW 263
49884: PPUSH
49885: LD_VAR 0 3
49889: PPUSH
49890: CALL_OW 264
49894: PPUSH
49895: CALL 67689 0 5
49899: ST_TO_ADDR
// if components then
49900: LD_VAR 0 10
49904: IFFALSE 49922
// begin MC_InsertProduceList ( i , components ) ;
49906: LD_VAR 0 2
49910: PPUSH
49911: LD_VAR 0 10
49915: PPUSH
49916: CALL 58848 0 2
// break ;
49920: GO 49924
// end ; end ;
49922: GO 49842
49924: POP
49925: POP
// end ; continue ;
49926: GO 49422
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49928: LD_VAR 0 3
49932: PPUSH
49933: LD_INT 1
49935: PPUSH
49936: CALL_OW 289
49940: PUSH
49941: LD_INT 100
49943: LESS
49944: PUSH
49945: LD_VAR 0 3
49949: PPUSH
49950: CALL_OW 314
49954: NOT
49955: AND
49956: IFFALSE 49985
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49958: LD_VAR 0 3
49962: PPUSH
49963: LD_VAR 0 6
49967: PUSH
49968: LD_INT 2
49970: ARRAY
49971: PPUSH
49972: LD_VAR 0 6
49976: PUSH
49977: LD_INT 3
49979: ARRAY
49980: PPUSH
49981: CALL_OW 117
// break ;
49985: GO 49989
// end ;
49987: GO 49422
49989: POP
49990: POP
// end ; end ;
49991: GO 48260
49993: POP
49994: POP
// end ;
49995: LD_VAR 0 1
49999: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50000: LD_INT 0
50002: PPUSH
50003: PPUSH
50004: PPUSH
50005: PPUSH
// if not mc_bases then
50006: LD_EXP 113
50010: NOT
50011: IFFALSE 50015
// exit ;
50013: GO 50176
// for i = 1 to mc_bases do
50015: LD_ADDR_VAR 0 2
50019: PUSH
50020: DOUBLE
50021: LD_INT 1
50023: DEC
50024: ST_TO_ADDR
50025: LD_EXP 113
50029: PUSH
50030: FOR_TO
50031: IFFALSE 50174
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50033: LD_ADDR_VAR 0 4
50037: PUSH
50038: LD_EXP 132
50042: PUSH
50043: LD_VAR 0 2
50047: ARRAY
50048: PUSH
50049: LD_EXP 135
50053: PUSH
50054: LD_VAR 0 2
50058: ARRAY
50059: UNION
50060: PPUSH
50061: LD_INT 33
50063: PUSH
50064: LD_INT 2
50066: PUSH
50067: EMPTY
50068: LIST
50069: LIST
50070: PPUSH
50071: CALL_OW 72
50075: ST_TO_ADDR
// if tmp then
50076: LD_VAR 0 4
50080: IFFALSE 50172
// for j in tmp do
50082: LD_ADDR_VAR 0 3
50086: PUSH
50087: LD_VAR 0 4
50091: PUSH
50092: FOR_IN
50093: IFFALSE 50170
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50095: LD_VAR 0 3
50099: PPUSH
50100: CALL_OW 312
50104: NOT
50105: PUSH
50106: LD_VAR 0 3
50110: PPUSH
50111: CALL_OW 256
50115: PUSH
50116: LD_INT 250
50118: GREATEREQUAL
50119: AND
50120: IFFALSE 50133
// Connect ( j ) else
50122: LD_VAR 0 3
50126: PPUSH
50127: CALL 73090 0 1
50131: GO 50168
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50133: LD_VAR 0 3
50137: PPUSH
50138: CALL_OW 256
50142: PUSH
50143: LD_INT 250
50145: LESS
50146: PUSH
50147: LD_VAR 0 3
50151: PPUSH
50152: CALL_OW 312
50156: AND
50157: IFFALSE 50168
// ComUnlink ( j ) ;
50159: LD_VAR 0 3
50163: PPUSH
50164: CALL_OW 136
50168: GO 50092
50170: POP
50171: POP
// end ;
50172: GO 50030
50174: POP
50175: POP
// end ;
50176: LD_VAR 0 1
50180: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50181: LD_INT 0
50183: PPUSH
50184: PPUSH
50185: PPUSH
50186: PPUSH
50187: PPUSH
// if not mc_bases then
50188: LD_EXP 113
50192: NOT
50193: IFFALSE 50197
// exit ;
50195: GO 50642
// for i = 1 to mc_bases do
50197: LD_ADDR_VAR 0 2
50201: PUSH
50202: DOUBLE
50203: LD_INT 1
50205: DEC
50206: ST_TO_ADDR
50207: LD_EXP 113
50211: PUSH
50212: FOR_TO
50213: IFFALSE 50640
// begin if not mc_produce [ i ] then
50215: LD_EXP 134
50219: PUSH
50220: LD_VAR 0 2
50224: ARRAY
50225: NOT
50226: IFFALSE 50230
// continue ;
50228: GO 50212
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50230: LD_ADDR_VAR 0 5
50234: PUSH
50235: LD_EXP 113
50239: PUSH
50240: LD_VAR 0 2
50244: ARRAY
50245: PPUSH
50246: LD_INT 30
50248: PUSH
50249: LD_INT 3
50251: PUSH
50252: EMPTY
50253: LIST
50254: LIST
50255: PPUSH
50256: CALL_OW 72
50260: ST_TO_ADDR
// if not fac then
50261: LD_VAR 0 5
50265: NOT
50266: IFFALSE 50270
// continue ;
50268: GO 50212
// for j in fac do
50270: LD_ADDR_VAR 0 3
50274: PUSH
50275: LD_VAR 0 5
50279: PUSH
50280: FOR_IN
50281: IFFALSE 50636
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50283: LD_VAR 0 3
50287: PPUSH
50288: CALL_OW 461
50292: PUSH
50293: LD_INT 2
50295: NONEQUAL
50296: PUSH
50297: LD_VAR 0 3
50301: PPUSH
50302: LD_INT 15
50304: PPUSH
50305: CALL 72750 0 2
50309: PUSH
50310: LD_INT 4
50312: ARRAY
50313: OR
50314: IFFALSE 50318
// continue ;
50316: GO 50280
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50318: LD_VAR 0 3
50322: PPUSH
50323: LD_EXP 134
50327: PUSH
50328: LD_VAR 0 2
50332: ARRAY
50333: PUSH
50334: LD_INT 1
50336: ARRAY
50337: PUSH
50338: LD_INT 1
50340: ARRAY
50341: PPUSH
50342: LD_EXP 134
50346: PUSH
50347: LD_VAR 0 2
50351: ARRAY
50352: PUSH
50353: LD_INT 1
50355: ARRAY
50356: PUSH
50357: LD_INT 2
50359: ARRAY
50360: PPUSH
50361: LD_EXP 134
50365: PUSH
50366: LD_VAR 0 2
50370: ARRAY
50371: PUSH
50372: LD_INT 1
50374: ARRAY
50375: PUSH
50376: LD_INT 3
50378: ARRAY
50379: PPUSH
50380: LD_EXP 134
50384: PUSH
50385: LD_VAR 0 2
50389: ARRAY
50390: PUSH
50391: LD_INT 1
50393: ARRAY
50394: PUSH
50395: LD_INT 4
50397: ARRAY
50398: PPUSH
50399: CALL_OW 448
50403: PUSH
50404: LD_VAR 0 3
50408: PPUSH
50409: LD_EXP 134
50413: PUSH
50414: LD_VAR 0 2
50418: ARRAY
50419: PUSH
50420: LD_INT 1
50422: ARRAY
50423: PUSH
50424: LD_INT 1
50426: ARRAY
50427: PUSH
50428: LD_EXP 134
50432: PUSH
50433: LD_VAR 0 2
50437: ARRAY
50438: PUSH
50439: LD_INT 1
50441: ARRAY
50442: PUSH
50443: LD_INT 2
50445: ARRAY
50446: PUSH
50447: LD_EXP 134
50451: PUSH
50452: LD_VAR 0 2
50456: ARRAY
50457: PUSH
50458: LD_INT 1
50460: ARRAY
50461: PUSH
50462: LD_INT 3
50464: ARRAY
50465: PUSH
50466: LD_EXP 134
50470: PUSH
50471: LD_VAR 0 2
50475: ARRAY
50476: PUSH
50477: LD_INT 1
50479: ARRAY
50480: PUSH
50481: LD_INT 4
50483: ARRAY
50484: PUSH
50485: EMPTY
50486: LIST
50487: LIST
50488: LIST
50489: LIST
50490: PPUSH
50491: CALL 76421 0 2
50495: AND
50496: IFFALSE 50634
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50498: LD_VAR 0 3
50502: PPUSH
50503: LD_EXP 134
50507: PUSH
50508: LD_VAR 0 2
50512: ARRAY
50513: PUSH
50514: LD_INT 1
50516: ARRAY
50517: PUSH
50518: LD_INT 1
50520: ARRAY
50521: PPUSH
50522: LD_EXP 134
50526: PUSH
50527: LD_VAR 0 2
50531: ARRAY
50532: PUSH
50533: LD_INT 1
50535: ARRAY
50536: PUSH
50537: LD_INT 2
50539: ARRAY
50540: PPUSH
50541: LD_EXP 134
50545: PUSH
50546: LD_VAR 0 2
50550: ARRAY
50551: PUSH
50552: LD_INT 1
50554: ARRAY
50555: PUSH
50556: LD_INT 3
50558: ARRAY
50559: PPUSH
50560: LD_EXP 134
50564: PUSH
50565: LD_VAR 0 2
50569: ARRAY
50570: PUSH
50571: LD_INT 1
50573: ARRAY
50574: PUSH
50575: LD_INT 4
50577: ARRAY
50578: PPUSH
50579: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50583: LD_ADDR_VAR 0 4
50587: PUSH
50588: LD_EXP 134
50592: PUSH
50593: LD_VAR 0 2
50597: ARRAY
50598: PPUSH
50599: LD_INT 1
50601: PPUSH
50602: CALL_OW 3
50606: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50607: LD_ADDR_EXP 134
50611: PUSH
50612: LD_EXP 134
50616: PPUSH
50617: LD_VAR 0 2
50621: PPUSH
50622: LD_VAR 0 4
50626: PPUSH
50627: CALL_OW 1
50631: ST_TO_ADDR
// break ;
50632: GO 50636
// end ; end ;
50634: GO 50280
50636: POP
50637: POP
// end ;
50638: GO 50212
50640: POP
50641: POP
// end ;
50642: LD_VAR 0 1
50646: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50647: LD_INT 0
50649: PPUSH
50650: PPUSH
50651: PPUSH
// if not mc_bases then
50652: LD_EXP 113
50656: NOT
50657: IFFALSE 50661
// exit ;
50659: GO 50750
// for i = 1 to mc_bases do
50661: LD_ADDR_VAR 0 2
50665: PUSH
50666: DOUBLE
50667: LD_INT 1
50669: DEC
50670: ST_TO_ADDR
50671: LD_EXP 113
50675: PUSH
50676: FOR_TO
50677: IFFALSE 50748
// begin if mc_attack [ i ] then
50679: LD_EXP 133
50683: PUSH
50684: LD_VAR 0 2
50688: ARRAY
50689: IFFALSE 50746
// begin tmp := mc_attack [ i ] [ 1 ] ;
50691: LD_ADDR_VAR 0 3
50695: PUSH
50696: LD_EXP 133
50700: PUSH
50701: LD_VAR 0 2
50705: ARRAY
50706: PUSH
50707: LD_INT 1
50709: ARRAY
50710: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50711: LD_ADDR_EXP 133
50715: PUSH
50716: LD_EXP 133
50720: PPUSH
50721: LD_VAR 0 2
50725: PPUSH
50726: EMPTY
50727: PPUSH
50728: CALL_OW 1
50732: ST_TO_ADDR
// Attack ( tmp ) ;
50733: LD_VAR 0 3
50737: PPUSH
50738: CALL 119436 0 1
// exit ;
50742: POP
50743: POP
50744: GO 50750
// end ; end ;
50746: GO 50676
50748: POP
50749: POP
// end ;
50750: LD_VAR 0 1
50754: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50755: LD_INT 0
50757: PPUSH
50758: PPUSH
50759: PPUSH
50760: PPUSH
50761: PPUSH
50762: PPUSH
50763: PPUSH
// if not mc_bases then
50764: LD_EXP 113
50768: NOT
50769: IFFALSE 50773
// exit ;
50771: GO 51377
// for i = 1 to mc_bases do
50773: LD_ADDR_VAR 0 2
50777: PUSH
50778: DOUBLE
50779: LD_INT 1
50781: DEC
50782: ST_TO_ADDR
50783: LD_EXP 113
50787: PUSH
50788: FOR_TO
50789: IFFALSE 51375
// begin if not mc_bases [ i ] then
50791: LD_EXP 113
50795: PUSH
50796: LD_VAR 0 2
50800: ARRAY
50801: NOT
50802: IFFALSE 50806
// continue ;
50804: GO 50788
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50806: LD_ADDR_VAR 0 7
50810: PUSH
50811: LD_EXP 113
50815: PUSH
50816: LD_VAR 0 2
50820: ARRAY
50821: PUSH
50822: LD_INT 1
50824: ARRAY
50825: PPUSH
50826: CALL 66993 0 1
50830: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50831: LD_ADDR_EXP 136
50835: PUSH
50836: LD_EXP 136
50840: PPUSH
50841: LD_VAR 0 2
50845: PPUSH
50846: LD_EXP 113
50850: PUSH
50851: LD_VAR 0 2
50855: ARRAY
50856: PUSH
50857: LD_INT 1
50859: ARRAY
50860: PPUSH
50861: CALL_OW 255
50865: PPUSH
50866: LD_EXP 138
50870: PUSH
50871: LD_VAR 0 2
50875: ARRAY
50876: PPUSH
50877: CALL 66958 0 2
50881: PPUSH
50882: CALL_OW 1
50886: ST_TO_ADDR
// if not mc_scan [ i ] then
50887: LD_EXP 136
50891: PUSH
50892: LD_VAR 0 2
50896: ARRAY
50897: NOT
50898: IFFALSE 51053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50900: LD_ADDR_VAR 0 4
50904: PUSH
50905: LD_EXP 113
50909: PUSH
50910: LD_VAR 0 2
50914: ARRAY
50915: PPUSH
50916: LD_INT 2
50918: PUSH
50919: LD_INT 25
50921: PUSH
50922: LD_INT 5
50924: PUSH
50925: EMPTY
50926: LIST
50927: LIST
50928: PUSH
50929: LD_INT 25
50931: PUSH
50932: LD_INT 8
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: PUSH
50939: LD_INT 25
50941: PUSH
50942: LD_INT 9
50944: PUSH
50945: EMPTY
50946: LIST
50947: LIST
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: PPUSH
50955: CALL_OW 72
50959: ST_TO_ADDR
// if not tmp then
50960: LD_VAR 0 4
50964: NOT
50965: IFFALSE 50969
// continue ;
50967: GO 50788
// for j in tmp do
50969: LD_ADDR_VAR 0 3
50973: PUSH
50974: LD_VAR 0 4
50978: PUSH
50979: FOR_IN
50980: IFFALSE 51051
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50982: LD_VAR 0 3
50986: PPUSH
50987: CALL_OW 310
50991: PPUSH
50992: CALL_OW 266
50996: PUSH
50997: LD_INT 5
50999: EQUAL
51000: PUSH
51001: LD_VAR 0 3
51005: PPUSH
51006: CALL_OW 257
51010: PUSH
51011: LD_INT 1
51013: EQUAL
51014: AND
51015: PUSH
51016: LD_VAR 0 3
51020: PPUSH
51021: CALL_OW 459
51025: NOT
51026: AND
51027: PUSH
51028: LD_VAR 0 7
51032: AND
51033: IFFALSE 51049
// ComChangeProfession ( j , class ) ;
51035: LD_VAR 0 3
51039: PPUSH
51040: LD_VAR 0 7
51044: PPUSH
51045: CALL_OW 123
51049: GO 50979
51051: POP
51052: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51053: LD_EXP 136
51057: PUSH
51058: LD_VAR 0 2
51062: ARRAY
51063: PUSH
51064: LD_EXP 135
51068: PUSH
51069: LD_VAR 0 2
51073: ARRAY
51074: NOT
51075: AND
51076: PUSH
51077: LD_EXP 113
51081: PUSH
51082: LD_VAR 0 2
51086: ARRAY
51087: PPUSH
51088: LD_INT 30
51090: PUSH
51091: LD_INT 32
51093: PUSH
51094: EMPTY
51095: LIST
51096: LIST
51097: PPUSH
51098: CALL_OW 72
51102: NOT
51103: AND
51104: PUSH
51105: LD_EXP 113
51109: PUSH
51110: LD_VAR 0 2
51114: ARRAY
51115: PPUSH
51116: LD_INT 2
51118: PUSH
51119: LD_INT 30
51121: PUSH
51122: LD_INT 4
51124: PUSH
51125: EMPTY
51126: LIST
51127: LIST
51128: PUSH
51129: LD_INT 30
51131: PUSH
51132: LD_INT 5
51134: PUSH
51135: EMPTY
51136: LIST
51137: LIST
51138: PUSH
51139: EMPTY
51140: LIST
51141: LIST
51142: LIST
51143: PPUSH
51144: CALL_OW 72
51148: NOT
51149: AND
51150: IFFALSE 51282
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51152: LD_ADDR_VAR 0 4
51156: PUSH
51157: LD_EXP 113
51161: PUSH
51162: LD_VAR 0 2
51166: ARRAY
51167: PPUSH
51168: LD_INT 2
51170: PUSH
51171: LD_INT 25
51173: PUSH
51174: LD_INT 1
51176: PUSH
51177: EMPTY
51178: LIST
51179: LIST
51180: PUSH
51181: LD_INT 25
51183: PUSH
51184: LD_INT 5
51186: PUSH
51187: EMPTY
51188: LIST
51189: LIST
51190: PUSH
51191: LD_INT 25
51193: PUSH
51194: LD_INT 8
51196: PUSH
51197: EMPTY
51198: LIST
51199: LIST
51200: PUSH
51201: LD_INT 25
51203: PUSH
51204: LD_INT 9
51206: PUSH
51207: EMPTY
51208: LIST
51209: LIST
51210: PUSH
51211: EMPTY
51212: LIST
51213: LIST
51214: LIST
51215: LIST
51216: LIST
51217: PPUSH
51218: CALL_OW 72
51222: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51223: LD_ADDR_VAR 0 4
51227: PUSH
51228: LD_VAR 0 4
51232: PUSH
51233: LD_VAR 0 4
51237: PPUSH
51238: LD_INT 18
51240: PPUSH
51241: CALL 98718 0 2
51245: DIFF
51246: ST_TO_ADDR
// if tmp then
51247: LD_VAR 0 4
51251: IFFALSE 51282
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51253: LD_VAR 0 2
51257: PPUSH
51258: LD_VAR 0 4
51262: PPUSH
51263: LD_EXP 138
51267: PUSH
51268: LD_VAR 0 2
51272: ARRAY
51273: PPUSH
51274: CALL 124145 0 3
// exit ;
51278: POP
51279: POP
51280: GO 51377
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51282: LD_EXP 136
51286: PUSH
51287: LD_VAR 0 2
51291: ARRAY
51292: PUSH
51293: LD_EXP 135
51297: PUSH
51298: LD_VAR 0 2
51302: ARRAY
51303: AND
51304: IFFALSE 51373
// begin tmp := mc_defender [ i ] ;
51306: LD_ADDR_VAR 0 4
51310: PUSH
51311: LD_EXP 135
51315: PUSH
51316: LD_VAR 0 2
51320: ARRAY
51321: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51322: LD_ADDR_EXP 135
51326: PUSH
51327: LD_EXP 135
51331: PPUSH
51332: LD_VAR 0 2
51336: PPUSH
51337: EMPTY
51338: PPUSH
51339: CALL_OW 1
51343: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51344: LD_VAR 0 2
51348: PPUSH
51349: LD_VAR 0 4
51353: PPUSH
51354: LD_EXP 136
51358: PUSH
51359: LD_VAR 0 2
51363: ARRAY
51364: PPUSH
51365: CALL 124706 0 3
// exit ;
51369: POP
51370: POP
51371: GO 51377
// end ; end ;
51373: GO 50788
51375: POP
51376: POP
// end ;
51377: LD_VAR 0 1
51381: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51382: LD_INT 0
51384: PPUSH
51385: PPUSH
51386: PPUSH
51387: PPUSH
51388: PPUSH
51389: PPUSH
51390: PPUSH
51391: PPUSH
51392: PPUSH
51393: PPUSH
51394: PPUSH
// if not mc_bases then
51395: LD_EXP 113
51399: NOT
51400: IFFALSE 51404
// exit ;
51402: GO 52491
// for i = 1 to mc_bases do
51404: LD_ADDR_VAR 0 2
51408: PUSH
51409: DOUBLE
51410: LD_INT 1
51412: DEC
51413: ST_TO_ADDR
51414: LD_EXP 113
51418: PUSH
51419: FOR_TO
51420: IFFALSE 52489
// begin tmp := mc_lab [ i ] ;
51422: LD_ADDR_VAR 0 6
51426: PUSH
51427: LD_EXP 146
51431: PUSH
51432: LD_VAR 0 2
51436: ARRAY
51437: ST_TO_ADDR
// if not tmp then
51438: LD_VAR 0 6
51442: NOT
51443: IFFALSE 51447
// continue ;
51445: GO 51419
// idle_lab := 0 ;
51447: LD_ADDR_VAR 0 11
51451: PUSH
51452: LD_INT 0
51454: ST_TO_ADDR
// for j in tmp do
51455: LD_ADDR_VAR 0 3
51459: PUSH
51460: LD_VAR 0 6
51464: PUSH
51465: FOR_IN
51466: IFFALSE 52485
// begin researching := false ;
51468: LD_ADDR_VAR 0 10
51472: PUSH
51473: LD_INT 0
51475: ST_TO_ADDR
// side := GetSide ( j ) ;
51476: LD_ADDR_VAR 0 4
51480: PUSH
51481: LD_VAR 0 3
51485: PPUSH
51486: CALL_OW 255
51490: ST_TO_ADDR
// if not mc_tech [ side ] then
51491: LD_EXP 140
51495: PUSH
51496: LD_VAR 0 4
51500: ARRAY
51501: NOT
51502: IFFALSE 51506
// continue ;
51504: GO 51465
// if BuildingStatus ( j ) = bs_idle then
51506: LD_VAR 0 3
51510: PPUSH
51511: CALL_OW 461
51515: PUSH
51516: LD_INT 2
51518: EQUAL
51519: IFFALSE 51707
// begin if idle_lab and UnitsInside ( j ) < 6 then
51521: LD_VAR 0 11
51525: PUSH
51526: LD_VAR 0 3
51530: PPUSH
51531: CALL_OW 313
51535: PUSH
51536: LD_INT 6
51538: LESS
51539: AND
51540: IFFALSE 51611
// begin tmp2 := UnitsInside ( idle_lab ) ;
51542: LD_ADDR_VAR 0 9
51546: PUSH
51547: LD_VAR 0 11
51551: PPUSH
51552: CALL_OW 313
51556: ST_TO_ADDR
// if tmp2 then
51557: LD_VAR 0 9
51561: IFFALSE 51603
// for x in tmp2 do
51563: LD_ADDR_VAR 0 7
51567: PUSH
51568: LD_VAR 0 9
51572: PUSH
51573: FOR_IN
51574: IFFALSE 51601
// begin ComExitBuilding ( x ) ;
51576: LD_VAR 0 7
51580: PPUSH
51581: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51585: LD_VAR 0 7
51589: PPUSH
51590: LD_VAR 0 3
51594: PPUSH
51595: CALL_OW 180
// end ;
51599: GO 51573
51601: POP
51602: POP
// idle_lab := 0 ;
51603: LD_ADDR_VAR 0 11
51607: PUSH
51608: LD_INT 0
51610: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51611: LD_ADDR_VAR 0 5
51615: PUSH
51616: LD_EXP 140
51620: PUSH
51621: LD_VAR 0 4
51625: ARRAY
51626: PUSH
51627: FOR_IN
51628: IFFALSE 51688
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51630: LD_VAR 0 3
51634: PPUSH
51635: LD_VAR 0 5
51639: PPUSH
51640: CALL_OW 430
51644: PUSH
51645: LD_VAR 0 4
51649: PPUSH
51650: LD_VAR 0 5
51654: PPUSH
51655: CALL 66063 0 2
51659: AND
51660: IFFALSE 51686
// begin researching := true ;
51662: LD_ADDR_VAR 0 10
51666: PUSH
51667: LD_INT 1
51669: ST_TO_ADDR
// ComResearch ( j , t ) ;
51670: LD_VAR 0 3
51674: PPUSH
51675: LD_VAR 0 5
51679: PPUSH
51680: CALL_OW 124
// break ;
51684: GO 51688
// end ;
51686: GO 51627
51688: POP
51689: POP
// if not researching then
51690: LD_VAR 0 10
51694: NOT
51695: IFFALSE 51707
// idle_lab := j ;
51697: LD_ADDR_VAR 0 11
51701: PUSH
51702: LD_VAR 0 3
51706: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51707: LD_VAR 0 3
51711: PPUSH
51712: CALL_OW 461
51716: PUSH
51717: LD_INT 10
51719: EQUAL
51720: IFFALSE 52308
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51722: LD_EXP 142
51726: PUSH
51727: LD_VAR 0 2
51731: ARRAY
51732: NOT
51733: PUSH
51734: LD_EXP 143
51738: PUSH
51739: LD_VAR 0 2
51743: ARRAY
51744: NOT
51745: AND
51746: PUSH
51747: LD_EXP 140
51751: PUSH
51752: LD_VAR 0 4
51756: ARRAY
51757: PUSH
51758: LD_INT 1
51760: GREATER
51761: AND
51762: IFFALSE 51893
// begin ComCancel ( j ) ;
51764: LD_VAR 0 3
51768: PPUSH
51769: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51773: LD_ADDR_EXP 140
51777: PUSH
51778: LD_EXP 140
51782: PPUSH
51783: LD_VAR 0 4
51787: PPUSH
51788: LD_EXP 140
51792: PUSH
51793: LD_VAR 0 4
51797: ARRAY
51798: PPUSH
51799: LD_EXP 140
51803: PUSH
51804: LD_VAR 0 4
51808: ARRAY
51809: PUSH
51810: LD_INT 1
51812: MINUS
51813: PPUSH
51814: LD_EXP 140
51818: PUSH
51819: LD_VAR 0 4
51823: ARRAY
51824: PPUSH
51825: LD_INT 0
51827: PPUSH
51828: CALL 69575 0 4
51832: PPUSH
51833: CALL_OW 1
51837: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51838: LD_ADDR_EXP 140
51842: PUSH
51843: LD_EXP 140
51847: PPUSH
51848: LD_VAR 0 4
51852: PPUSH
51853: LD_EXP 140
51857: PUSH
51858: LD_VAR 0 4
51862: ARRAY
51863: PPUSH
51864: LD_EXP 140
51868: PUSH
51869: LD_VAR 0 4
51873: ARRAY
51874: PPUSH
51875: LD_INT 1
51877: PPUSH
51878: LD_INT 0
51880: PPUSH
51881: CALL 69575 0 4
51885: PPUSH
51886: CALL_OW 1
51890: ST_TO_ADDR
// continue ;
51891: GO 51465
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51893: LD_EXP 142
51897: PUSH
51898: LD_VAR 0 2
51902: ARRAY
51903: PUSH
51904: LD_EXP 143
51908: PUSH
51909: LD_VAR 0 2
51913: ARRAY
51914: NOT
51915: AND
51916: IFFALSE 52043
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51918: LD_ADDR_EXP 143
51922: PUSH
51923: LD_EXP 143
51927: PPUSH
51928: LD_VAR 0 2
51932: PUSH
51933: LD_EXP 143
51937: PUSH
51938: LD_VAR 0 2
51942: ARRAY
51943: PUSH
51944: LD_INT 1
51946: PLUS
51947: PUSH
51948: EMPTY
51949: LIST
51950: LIST
51951: PPUSH
51952: LD_EXP 142
51956: PUSH
51957: LD_VAR 0 2
51961: ARRAY
51962: PUSH
51963: LD_INT 1
51965: ARRAY
51966: PPUSH
51967: CALL 70157 0 3
51971: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51972: LD_EXP 142
51976: PUSH
51977: LD_VAR 0 2
51981: ARRAY
51982: PUSH
51983: LD_INT 1
51985: ARRAY
51986: PPUSH
51987: LD_INT 112
51989: PPUSH
51990: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51994: LD_ADDR_VAR 0 9
51998: PUSH
51999: LD_EXP 142
52003: PUSH
52004: LD_VAR 0 2
52008: ARRAY
52009: PPUSH
52010: LD_INT 1
52012: PPUSH
52013: CALL_OW 3
52017: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52018: LD_ADDR_EXP 142
52022: PUSH
52023: LD_EXP 142
52027: PPUSH
52028: LD_VAR 0 2
52032: PPUSH
52033: LD_VAR 0 9
52037: PPUSH
52038: CALL_OW 1
52042: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52043: LD_EXP 142
52047: PUSH
52048: LD_VAR 0 2
52052: ARRAY
52053: PUSH
52054: LD_EXP 143
52058: PUSH
52059: LD_VAR 0 2
52063: ARRAY
52064: AND
52065: PUSH
52066: LD_EXP 143
52070: PUSH
52071: LD_VAR 0 2
52075: ARRAY
52076: PUSH
52077: LD_INT 1
52079: ARRAY
52080: PPUSH
52081: CALL_OW 310
52085: NOT
52086: AND
52087: PUSH
52088: LD_VAR 0 3
52092: PPUSH
52093: CALL_OW 313
52097: PUSH
52098: LD_INT 6
52100: EQUAL
52101: AND
52102: IFFALSE 52158
// begin tmp2 := UnitsInside ( j ) ;
52104: LD_ADDR_VAR 0 9
52108: PUSH
52109: LD_VAR 0 3
52113: PPUSH
52114: CALL_OW 313
52118: ST_TO_ADDR
// if tmp2 = 6 then
52119: LD_VAR 0 9
52123: PUSH
52124: LD_INT 6
52126: EQUAL
52127: IFFALSE 52158
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52129: LD_VAR 0 9
52133: PUSH
52134: LD_INT 1
52136: ARRAY
52137: PPUSH
52138: LD_INT 112
52140: PPUSH
52141: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52145: LD_VAR 0 9
52149: PUSH
52150: LD_INT 1
52152: ARRAY
52153: PPUSH
52154: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52158: LD_EXP 143
52162: PUSH
52163: LD_VAR 0 2
52167: ARRAY
52168: PUSH
52169: LD_EXP 143
52173: PUSH
52174: LD_VAR 0 2
52178: ARRAY
52179: PUSH
52180: LD_INT 1
52182: ARRAY
52183: PPUSH
52184: CALL_OW 314
52188: NOT
52189: AND
52190: PUSH
52191: LD_EXP 143
52195: PUSH
52196: LD_VAR 0 2
52200: ARRAY
52201: PUSH
52202: LD_INT 1
52204: ARRAY
52205: PPUSH
52206: CALL_OW 310
52210: NOT
52211: AND
52212: IFFALSE 52238
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52214: LD_EXP 143
52218: PUSH
52219: LD_VAR 0 2
52223: ARRAY
52224: PUSH
52225: LD_INT 1
52227: ARRAY
52228: PPUSH
52229: LD_VAR 0 3
52233: PPUSH
52234: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52238: LD_EXP 143
52242: PUSH
52243: LD_VAR 0 2
52247: ARRAY
52248: PUSH
52249: LD_INT 1
52251: ARRAY
52252: PPUSH
52253: CALL_OW 310
52257: PUSH
52258: LD_EXP 143
52262: PUSH
52263: LD_VAR 0 2
52267: ARRAY
52268: PUSH
52269: LD_INT 1
52271: ARRAY
52272: PPUSH
52273: CALL_OW 310
52277: PPUSH
52278: CALL_OW 461
52282: PUSH
52283: LD_INT 3
52285: NONEQUAL
52286: AND
52287: IFFALSE 52308
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52289: LD_EXP 143
52293: PUSH
52294: LD_VAR 0 2
52298: ARRAY
52299: PUSH
52300: LD_INT 1
52302: ARRAY
52303: PPUSH
52304: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52308: LD_VAR 0 3
52312: PPUSH
52313: CALL_OW 461
52317: PUSH
52318: LD_INT 6
52320: EQUAL
52321: PUSH
52322: LD_VAR 0 6
52326: PUSH
52327: LD_INT 1
52329: GREATER
52330: AND
52331: IFFALSE 52483
// begin sci := [ ] ;
52333: LD_ADDR_VAR 0 8
52337: PUSH
52338: EMPTY
52339: ST_TO_ADDR
// for x in ( tmp diff j ) do
52340: LD_ADDR_VAR 0 7
52344: PUSH
52345: LD_VAR 0 6
52349: PUSH
52350: LD_VAR 0 3
52354: DIFF
52355: PUSH
52356: FOR_IN
52357: IFFALSE 52409
// begin if sci = 6 then
52359: LD_VAR 0 8
52363: PUSH
52364: LD_INT 6
52366: EQUAL
52367: IFFALSE 52371
// break ;
52369: GO 52409
// if BuildingStatus ( x ) = bs_idle then
52371: LD_VAR 0 7
52375: PPUSH
52376: CALL_OW 461
52380: PUSH
52381: LD_INT 2
52383: EQUAL
52384: IFFALSE 52407
// sci := sci ^ UnitsInside ( x ) ;
52386: LD_ADDR_VAR 0 8
52390: PUSH
52391: LD_VAR 0 8
52395: PUSH
52396: LD_VAR 0 7
52400: PPUSH
52401: CALL_OW 313
52405: ADD
52406: ST_TO_ADDR
// end ;
52407: GO 52356
52409: POP
52410: POP
// if not sci then
52411: LD_VAR 0 8
52415: NOT
52416: IFFALSE 52420
// continue ;
52418: GO 51465
// for x in sci do
52420: LD_ADDR_VAR 0 7
52424: PUSH
52425: LD_VAR 0 8
52429: PUSH
52430: FOR_IN
52431: IFFALSE 52481
// if IsInUnit ( x ) and not HasTask ( x ) then
52433: LD_VAR 0 7
52437: PPUSH
52438: CALL_OW 310
52442: PUSH
52443: LD_VAR 0 7
52447: PPUSH
52448: CALL_OW 314
52452: NOT
52453: AND
52454: IFFALSE 52479
// begin ComExitBuilding ( x ) ;
52456: LD_VAR 0 7
52460: PPUSH
52461: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52465: LD_VAR 0 7
52469: PPUSH
52470: LD_VAR 0 3
52474: PPUSH
52475: CALL_OW 180
// end ;
52479: GO 52430
52481: POP
52482: POP
// end ; end ;
52483: GO 51465
52485: POP
52486: POP
// end ;
52487: GO 51419
52489: POP
52490: POP
// end ;
52491: LD_VAR 0 1
52495: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52496: LD_INT 0
52498: PPUSH
52499: PPUSH
// if not mc_bases then
52500: LD_EXP 113
52504: NOT
52505: IFFALSE 52509
// exit ;
52507: GO 52590
// for i = 1 to mc_bases do
52509: LD_ADDR_VAR 0 2
52513: PUSH
52514: DOUBLE
52515: LD_INT 1
52517: DEC
52518: ST_TO_ADDR
52519: LD_EXP 113
52523: PUSH
52524: FOR_TO
52525: IFFALSE 52588
// if mc_mines [ i ] and mc_miners [ i ] then
52527: LD_EXP 126
52531: PUSH
52532: LD_VAR 0 2
52536: ARRAY
52537: PUSH
52538: LD_EXP 127
52542: PUSH
52543: LD_VAR 0 2
52547: ARRAY
52548: AND
52549: IFFALSE 52586
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52551: LD_EXP 127
52555: PUSH
52556: LD_VAR 0 2
52560: ARRAY
52561: PUSH
52562: LD_INT 1
52564: ARRAY
52565: PPUSH
52566: CALL_OW 255
52570: PPUSH
52571: LD_EXP 126
52575: PUSH
52576: LD_VAR 0 2
52580: ARRAY
52581: PPUSH
52582: CALL 67146 0 2
52586: GO 52524
52588: POP
52589: POP
// end ;
52590: LD_VAR 0 1
52594: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52595: LD_INT 0
52597: PPUSH
52598: PPUSH
52599: PPUSH
52600: PPUSH
52601: PPUSH
52602: PPUSH
52603: PPUSH
52604: PPUSH
// if not mc_bases or not mc_parking then
52605: LD_EXP 113
52609: NOT
52610: PUSH
52611: LD_EXP 137
52615: NOT
52616: OR
52617: IFFALSE 52621
// exit ;
52619: GO 53320
// for i = 1 to mc_bases do
52621: LD_ADDR_VAR 0 2
52625: PUSH
52626: DOUBLE
52627: LD_INT 1
52629: DEC
52630: ST_TO_ADDR
52631: LD_EXP 113
52635: PUSH
52636: FOR_TO
52637: IFFALSE 53318
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52639: LD_EXP 113
52643: PUSH
52644: LD_VAR 0 2
52648: ARRAY
52649: NOT
52650: PUSH
52651: LD_EXP 137
52655: PUSH
52656: LD_VAR 0 2
52660: ARRAY
52661: NOT
52662: OR
52663: IFFALSE 52667
// continue ;
52665: GO 52636
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52667: LD_ADDR_VAR 0 5
52671: PUSH
52672: LD_EXP 113
52676: PUSH
52677: LD_VAR 0 2
52681: ARRAY
52682: PUSH
52683: LD_INT 1
52685: ARRAY
52686: PPUSH
52687: CALL_OW 255
52691: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52692: LD_ADDR_VAR 0 6
52696: PUSH
52697: LD_EXP 113
52701: PUSH
52702: LD_VAR 0 2
52706: ARRAY
52707: PPUSH
52708: LD_INT 30
52710: PUSH
52711: LD_INT 3
52713: PUSH
52714: EMPTY
52715: LIST
52716: LIST
52717: PPUSH
52718: CALL_OW 72
52722: ST_TO_ADDR
// if not fac then
52723: LD_VAR 0 6
52727: NOT
52728: IFFALSE 52779
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52730: LD_ADDR_VAR 0 6
52734: PUSH
52735: LD_EXP 113
52739: PUSH
52740: LD_VAR 0 2
52744: ARRAY
52745: PPUSH
52746: LD_INT 2
52748: PUSH
52749: LD_INT 30
52751: PUSH
52752: LD_INT 0
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: PUSH
52759: LD_INT 30
52761: PUSH
52762: LD_INT 1
52764: PUSH
52765: EMPTY
52766: LIST
52767: LIST
52768: PUSH
52769: EMPTY
52770: LIST
52771: LIST
52772: LIST
52773: PPUSH
52774: CALL_OW 72
52778: ST_TO_ADDR
// if not fac then
52779: LD_VAR 0 6
52783: NOT
52784: IFFALSE 52788
// continue ;
52786: GO 52636
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52788: LD_ADDR_VAR 0 7
52792: PUSH
52793: LD_EXP 137
52797: PUSH
52798: LD_VAR 0 2
52802: ARRAY
52803: PPUSH
52804: LD_INT 22
52806: PUSH
52807: LD_VAR 0 5
52811: PUSH
52812: EMPTY
52813: LIST
52814: LIST
52815: PUSH
52816: LD_INT 21
52818: PUSH
52819: LD_INT 2
52821: PUSH
52822: EMPTY
52823: LIST
52824: LIST
52825: PUSH
52826: LD_INT 3
52828: PUSH
52829: LD_INT 24
52831: PUSH
52832: LD_INT 1000
52834: PUSH
52835: EMPTY
52836: LIST
52837: LIST
52838: PUSH
52839: EMPTY
52840: LIST
52841: LIST
52842: PUSH
52843: EMPTY
52844: LIST
52845: LIST
52846: LIST
52847: PPUSH
52848: CALL_OW 70
52852: ST_TO_ADDR
// for j in fac do
52853: LD_ADDR_VAR 0 3
52857: PUSH
52858: LD_VAR 0 6
52862: PUSH
52863: FOR_IN
52864: IFFALSE 52945
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52866: LD_ADDR_VAR 0 7
52870: PUSH
52871: LD_VAR 0 7
52875: PUSH
52876: LD_INT 22
52878: PUSH
52879: LD_VAR 0 5
52883: PUSH
52884: EMPTY
52885: LIST
52886: LIST
52887: PUSH
52888: LD_INT 91
52890: PUSH
52891: LD_VAR 0 3
52895: PUSH
52896: LD_INT 15
52898: PUSH
52899: EMPTY
52900: LIST
52901: LIST
52902: LIST
52903: PUSH
52904: LD_INT 21
52906: PUSH
52907: LD_INT 2
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: PUSH
52914: LD_INT 3
52916: PUSH
52917: LD_INT 24
52919: PUSH
52920: LD_INT 1000
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: PUSH
52927: EMPTY
52928: LIST
52929: LIST
52930: PUSH
52931: EMPTY
52932: LIST
52933: LIST
52934: LIST
52935: LIST
52936: PPUSH
52937: CALL_OW 69
52941: UNION
52942: ST_TO_ADDR
52943: GO 52863
52945: POP
52946: POP
// if not vehs then
52947: LD_VAR 0 7
52951: NOT
52952: IFFALSE 52978
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52954: LD_ADDR_EXP 125
52958: PUSH
52959: LD_EXP 125
52963: PPUSH
52964: LD_VAR 0 2
52968: PPUSH
52969: EMPTY
52970: PPUSH
52971: CALL_OW 1
52975: ST_TO_ADDR
// continue ;
52976: GO 52636
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52978: LD_ADDR_VAR 0 8
52982: PUSH
52983: LD_EXP 113
52987: PUSH
52988: LD_VAR 0 2
52992: ARRAY
52993: PPUSH
52994: LD_INT 30
52996: PUSH
52997: LD_INT 3
52999: PUSH
53000: EMPTY
53001: LIST
53002: LIST
53003: PPUSH
53004: CALL_OW 72
53008: ST_TO_ADDR
// if tmp then
53009: LD_VAR 0 8
53013: IFFALSE 53116
// begin for j in tmp do
53015: LD_ADDR_VAR 0 3
53019: PUSH
53020: LD_VAR 0 8
53024: PUSH
53025: FOR_IN
53026: IFFALSE 53114
// for k in UnitsInside ( j ) do
53028: LD_ADDR_VAR 0 4
53032: PUSH
53033: LD_VAR 0 3
53037: PPUSH
53038: CALL_OW 313
53042: PUSH
53043: FOR_IN
53044: IFFALSE 53110
// if k then
53046: LD_VAR 0 4
53050: IFFALSE 53108
// if not k in mc_repair_vehicle [ i ] then
53052: LD_VAR 0 4
53056: PUSH
53057: LD_EXP 125
53061: PUSH
53062: LD_VAR 0 2
53066: ARRAY
53067: IN
53068: NOT
53069: IFFALSE 53108
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53071: LD_ADDR_EXP 125
53075: PUSH
53076: LD_EXP 125
53080: PPUSH
53081: LD_VAR 0 2
53085: PPUSH
53086: LD_EXP 125
53090: PUSH
53091: LD_VAR 0 2
53095: ARRAY
53096: PUSH
53097: LD_VAR 0 4
53101: UNION
53102: PPUSH
53103: CALL_OW 1
53107: ST_TO_ADDR
53108: GO 53043
53110: POP
53111: POP
53112: GO 53025
53114: POP
53115: POP
// end ; if not mc_repair_vehicle [ i ] then
53116: LD_EXP 125
53120: PUSH
53121: LD_VAR 0 2
53125: ARRAY
53126: NOT
53127: IFFALSE 53131
// continue ;
53129: GO 52636
// for j in mc_repair_vehicle [ i ] do
53131: LD_ADDR_VAR 0 3
53135: PUSH
53136: LD_EXP 125
53140: PUSH
53141: LD_VAR 0 2
53145: ARRAY
53146: PUSH
53147: FOR_IN
53148: IFFALSE 53314
// begin if GetClass ( j ) <> 3 then
53150: LD_VAR 0 3
53154: PPUSH
53155: CALL_OW 257
53159: PUSH
53160: LD_INT 3
53162: NONEQUAL
53163: IFFALSE 53204
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53165: LD_ADDR_EXP 125
53169: PUSH
53170: LD_EXP 125
53174: PPUSH
53175: LD_VAR 0 2
53179: PPUSH
53180: LD_EXP 125
53184: PUSH
53185: LD_VAR 0 2
53189: ARRAY
53190: PUSH
53191: LD_VAR 0 3
53195: DIFF
53196: PPUSH
53197: CALL_OW 1
53201: ST_TO_ADDR
// continue ;
53202: GO 53147
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53204: LD_VAR 0 3
53208: PPUSH
53209: CALL_OW 311
53213: NOT
53214: PUSH
53215: LD_VAR 0 3
53219: PUSH
53220: LD_EXP 116
53224: PUSH
53225: LD_VAR 0 2
53229: ARRAY
53230: PUSH
53231: LD_INT 1
53233: ARRAY
53234: IN
53235: NOT
53236: AND
53237: PUSH
53238: LD_VAR 0 3
53242: PUSH
53243: LD_EXP 116
53247: PUSH
53248: LD_VAR 0 2
53252: ARRAY
53253: PUSH
53254: LD_INT 2
53256: ARRAY
53257: IN
53258: NOT
53259: AND
53260: IFFALSE 53312
// begin if IsInUnit ( j ) then
53262: LD_VAR 0 3
53266: PPUSH
53267: CALL_OW 310
53271: IFFALSE 53282
// ComExitBuilding ( j ) ;
53273: LD_VAR 0 3
53277: PPUSH
53278: CALL_OW 122
// if not HasTask ( j ) then
53282: LD_VAR 0 3
53286: PPUSH
53287: CALL_OW 314
53291: NOT
53292: IFFALSE 53312
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53294: LD_VAR 0 3
53298: PPUSH
53299: LD_VAR 0 7
53303: PUSH
53304: LD_INT 1
53306: ARRAY
53307: PPUSH
53308: CALL_OW 189
// end ; end ;
53312: GO 53147
53314: POP
53315: POP
// end ;
53316: GO 52636
53318: POP
53319: POP
// end ;
53320: LD_VAR 0 1
53324: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53325: LD_INT 0
53327: PPUSH
53328: PPUSH
53329: PPUSH
53330: PPUSH
53331: PPUSH
53332: PPUSH
53333: PPUSH
53334: PPUSH
53335: PPUSH
53336: PPUSH
53337: PPUSH
// if not mc_bases then
53338: LD_EXP 113
53342: NOT
53343: IFFALSE 53347
// exit ;
53345: GO 54149
// for i = 1 to mc_bases do
53347: LD_ADDR_VAR 0 2
53351: PUSH
53352: DOUBLE
53353: LD_INT 1
53355: DEC
53356: ST_TO_ADDR
53357: LD_EXP 113
53361: PUSH
53362: FOR_TO
53363: IFFALSE 54147
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53365: LD_EXP 141
53369: PUSH
53370: LD_VAR 0 2
53374: ARRAY
53375: NOT
53376: PUSH
53377: LD_EXP 116
53381: PUSH
53382: LD_VAR 0 2
53386: ARRAY
53387: PUSH
53388: LD_INT 1
53390: ARRAY
53391: OR
53392: PUSH
53393: LD_EXP 116
53397: PUSH
53398: LD_VAR 0 2
53402: ARRAY
53403: PUSH
53404: LD_INT 2
53406: ARRAY
53407: OR
53408: PUSH
53409: LD_EXP 139
53413: PUSH
53414: LD_VAR 0 2
53418: ARRAY
53419: PPUSH
53420: LD_INT 1
53422: PPUSH
53423: CALL_OW 325
53427: NOT
53428: OR
53429: PUSH
53430: LD_EXP 136
53434: PUSH
53435: LD_VAR 0 2
53439: ARRAY
53440: OR
53441: IFFALSE 53445
// continue ;
53443: GO 53362
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53445: LD_ADDR_VAR 0 8
53449: PUSH
53450: LD_EXP 113
53454: PUSH
53455: LD_VAR 0 2
53459: ARRAY
53460: PPUSH
53461: LD_INT 25
53463: PUSH
53464: LD_INT 4
53466: PUSH
53467: EMPTY
53468: LIST
53469: LIST
53470: PUSH
53471: LD_INT 50
53473: PUSH
53474: EMPTY
53475: LIST
53476: PUSH
53477: LD_INT 3
53479: PUSH
53480: LD_INT 60
53482: PUSH
53483: EMPTY
53484: LIST
53485: PUSH
53486: EMPTY
53487: LIST
53488: LIST
53489: PUSH
53490: EMPTY
53491: LIST
53492: LIST
53493: LIST
53494: PPUSH
53495: CALL_OW 72
53499: PUSH
53500: LD_EXP 117
53504: PUSH
53505: LD_VAR 0 2
53509: ARRAY
53510: DIFF
53511: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53512: LD_ADDR_VAR 0 9
53516: PUSH
53517: LD_EXP 113
53521: PUSH
53522: LD_VAR 0 2
53526: ARRAY
53527: PPUSH
53528: LD_INT 2
53530: PUSH
53531: LD_INT 30
53533: PUSH
53534: LD_INT 0
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: PUSH
53541: LD_INT 30
53543: PUSH
53544: LD_INT 1
53546: PUSH
53547: EMPTY
53548: LIST
53549: LIST
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: LIST
53555: PPUSH
53556: CALL_OW 72
53560: ST_TO_ADDR
// if not tmp or not dep then
53561: LD_VAR 0 8
53565: NOT
53566: PUSH
53567: LD_VAR 0 9
53571: NOT
53572: OR
53573: IFFALSE 53577
// continue ;
53575: GO 53362
// side := GetSide ( tmp [ 1 ] ) ;
53577: LD_ADDR_VAR 0 11
53581: PUSH
53582: LD_VAR 0 8
53586: PUSH
53587: LD_INT 1
53589: ARRAY
53590: PPUSH
53591: CALL_OW 255
53595: ST_TO_ADDR
// dep := dep [ 1 ] ;
53596: LD_ADDR_VAR 0 9
53600: PUSH
53601: LD_VAR 0 9
53605: PUSH
53606: LD_INT 1
53608: ARRAY
53609: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53610: LD_ADDR_VAR 0 7
53614: PUSH
53615: LD_EXP 141
53619: PUSH
53620: LD_VAR 0 2
53624: ARRAY
53625: PPUSH
53626: LD_INT 22
53628: PUSH
53629: LD_INT 0
53631: PUSH
53632: EMPTY
53633: LIST
53634: LIST
53635: PUSH
53636: LD_INT 25
53638: PUSH
53639: LD_INT 12
53641: PUSH
53642: EMPTY
53643: LIST
53644: LIST
53645: PUSH
53646: EMPTY
53647: LIST
53648: LIST
53649: PPUSH
53650: CALL_OW 70
53654: PUSH
53655: LD_INT 22
53657: PUSH
53658: LD_INT 0
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: PUSH
53665: LD_INT 25
53667: PUSH
53668: LD_INT 12
53670: PUSH
53671: EMPTY
53672: LIST
53673: LIST
53674: PUSH
53675: LD_INT 91
53677: PUSH
53678: LD_VAR 0 9
53682: PUSH
53683: LD_INT 20
53685: PUSH
53686: EMPTY
53687: LIST
53688: LIST
53689: LIST
53690: PUSH
53691: EMPTY
53692: LIST
53693: LIST
53694: LIST
53695: PPUSH
53696: CALL_OW 69
53700: UNION
53701: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53702: LD_ADDR_VAR 0 10
53706: PUSH
53707: LD_EXP 141
53711: PUSH
53712: LD_VAR 0 2
53716: ARRAY
53717: PPUSH
53718: LD_INT 81
53720: PUSH
53721: LD_VAR 0 11
53725: PUSH
53726: EMPTY
53727: LIST
53728: LIST
53729: PPUSH
53730: CALL_OW 70
53734: ST_TO_ADDR
// if not apes or danger_at_area then
53735: LD_VAR 0 7
53739: NOT
53740: PUSH
53741: LD_VAR 0 10
53745: OR
53746: IFFALSE 53796
// begin if mc_taming [ i ] then
53748: LD_EXP 144
53752: PUSH
53753: LD_VAR 0 2
53757: ARRAY
53758: IFFALSE 53794
// begin MC_Reset ( i , 121 ) ;
53760: LD_VAR 0 2
53764: PPUSH
53765: LD_INT 121
53767: PPUSH
53768: CALL 39199 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53772: LD_ADDR_EXP 144
53776: PUSH
53777: LD_EXP 144
53781: PPUSH
53782: LD_VAR 0 2
53786: PPUSH
53787: EMPTY
53788: PPUSH
53789: CALL_OW 1
53793: ST_TO_ADDR
// end ; continue ;
53794: GO 53362
// end ; for j in tmp do
53796: LD_ADDR_VAR 0 3
53800: PUSH
53801: LD_VAR 0 8
53805: PUSH
53806: FOR_IN
53807: IFFALSE 54143
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53809: LD_VAR 0 3
53813: PUSH
53814: LD_EXP 144
53818: PUSH
53819: LD_VAR 0 2
53823: ARRAY
53824: IN
53825: NOT
53826: PUSH
53827: LD_EXP 144
53831: PUSH
53832: LD_VAR 0 2
53836: ARRAY
53837: PUSH
53838: LD_INT 3
53840: LESS
53841: AND
53842: IFFALSE 53900
// begin SetTag ( j , 121 ) ;
53844: LD_VAR 0 3
53848: PPUSH
53849: LD_INT 121
53851: PPUSH
53852: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53856: LD_ADDR_EXP 144
53860: PUSH
53861: LD_EXP 144
53865: PPUSH
53866: LD_VAR 0 2
53870: PUSH
53871: LD_EXP 144
53875: PUSH
53876: LD_VAR 0 2
53880: ARRAY
53881: PUSH
53882: LD_INT 1
53884: PLUS
53885: PUSH
53886: EMPTY
53887: LIST
53888: LIST
53889: PPUSH
53890: LD_VAR 0 3
53894: PPUSH
53895: CALL 70157 0 3
53899: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53900: LD_VAR 0 3
53904: PUSH
53905: LD_EXP 144
53909: PUSH
53910: LD_VAR 0 2
53914: ARRAY
53915: IN
53916: IFFALSE 54141
// begin if GetClass ( j ) <> 4 then
53918: LD_VAR 0 3
53922: PPUSH
53923: CALL_OW 257
53927: PUSH
53928: LD_INT 4
53930: NONEQUAL
53931: IFFALSE 53984
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53933: LD_ADDR_EXP 144
53937: PUSH
53938: LD_EXP 144
53942: PPUSH
53943: LD_VAR 0 2
53947: PPUSH
53948: LD_EXP 144
53952: PUSH
53953: LD_VAR 0 2
53957: ARRAY
53958: PUSH
53959: LD_VAR 0 3
53963: DIFF
53964: PPUSH
53965: CALL_OW 1
53969: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53970: LD_VAR 0 3
53974: PPUSH
53975: LD_INT 0
53977: PPUSH
53978: CALL_OW 109
// continue ;
53982: GO 53806
// end ; if IsInUnit ( j ) then
53984: LD_VAR 0 3
53988: PPUSH
53989: CALL_OW 310
53993: IFFALSE 54004
// ComExitBuilding ( j ) ;
53995: LD_VAR 0 3
53999: PPUSH
54000: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54004: LD_ADDR_VAR 0 6
54008: PUSH
54009: LD_VAR 0 7
54013: PPUSH
54014: LD_VAR 0 3
54018: PPUSH
54019: CALL_OW 74
54023: ST_TO_ADDR
// if not ape then
54024: LD_VAR 0 6
54028: NOT
54029: IFFALSE 54033
// break ;
54031: GO 54143
// x := GetX ( ape ) ;
54033: LD_ADDR_VAR 0 4
54037: PUSH
54038: LD_VAR 0 6
54042: PPUSH
54043: CALL_OW 250
54047: ST_TO_ADDR
// y := GetY ( ape ) ;
54048: LD_ADDR_VAR 0 5
54052: PUSH
54053: LD_VAR 0 6
54057: PPUSH
54058: CALL_OW 251
54062: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54063: LD_VAR 0 4
54067: PPUSH
54068: LD_VAR 0 5
54072: PPUSH
54073: CALL_OW 488
54077: NOT
54078: PUSH
54079: LD_VAR 0 11
54083: PPUSH
54084: LD_VAR 0 4
54088: PPUSH
54089: LD_VAR 0 5
54093: PPUSH
54094: LD_INT 20
54096: PPUSH
54097: CALL 71053 0 4
54101: PUSH
54102: LD_INT 4
54104: ARRAY
54105: OR
54106: IFFALSE 54110
// break ;
54108: GO 54143
// if not HasTask ( j ) then
54110: LD_VAR 0 3
54114: PPUSH
54115: CALL_OW 314
54119: NOT
54120: IFFALSE 54141
// ComTameXY ( j , x , y ) ;
54122: LD_VAR 0 3
54126: PPUSH
54127: LD_VAR 0 4
54131: PPUSH
54132: LD_VAR 0 5
54136: PPUSH
54137: CALL_OW 131
// end ; end ;
54141: GO 53806
54143: POP
54144: POP
// end ;
54145: GO 53362
54147: POP
54148: POP
// end ;
54149: LD_VAR 0 1
54153: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54154: LD_INT 0
54156: PPUSH
54157: PPUSH
54158: PPUSH
54159: PPUSH
54160: PPUSH
54161: PPUSH
54162: PPUSH
54163: PPUSH
// if not mc_bases then
54164: LD_EXP 113
54168: NOT
54169: IFFALSE 54173
// exit ;
54171: GO 54799
// for i = 1 to mc_bases do
54173: LD_ADDR_VAR 0 2
54177: PUSH
54178: DOUBLE
54179: LD_INT 1
54181: DEC
54182: ST_TO_ADDR
54183: LD_EXP 113
54187: PUSH
54188: FOR_TO
54189: IFFALSE 54797
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54191: LD_EXP 142
54195: PUSH
54196: LD_VAR 0 2
54200: ARRAY
54201: NOT
54202: PUSH
54203: LD_EXP 142
54207: PUSH
54208: LD_VAR 0 2
54212: ARRAY
54213: PPUSH
54214: LD_INT 25
54216: PUSH
54217: LD_INT 12
54219: PUSH
54220: EMPTY
54221: LIST
54222: LIST
54223: PPUSH
54224: CALL_OW 72
54228: NOT
54229: OR
54230: IFFALSE 54234
// continue ;
54232: GO 54188
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54234: LD_ADDR_VAR 0 5
54238: PUSH
54239: LD_EXP 142
54243: PUSH
54244: LD_VAR 0 2
54248: ARRAY
54249: PUSH
54250: LD_INT 1
54252: ARRAY
54253: PPUSH
54254: CALL_OW 255
54258: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54259: LD_VAR 0 5
54263: PPUSH
54264: LD_INT 2
54266: PPUSH
54267: CALL_OW 325
54271: IFFALSE 54524
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54273: LD_ADDR_VAR 0 4
54277: PUSH
54278: LD_EXP 142
54282: PUSH
54283: LD_VAR 0 2
54287: ARRAY
54288: PPUSH
54289: LD_INT 25
54291: PUSH
54292: LD_INT 16
54294: PUSH
54295: EMPTY
54296: LIST
54297: LIST
54298: PPUSH
54299: CALL_OW 72
54303: ST_TO_ADDR
// if tmp < 6 then
54304: LD_VAR 0 4
54308: PUSH
54309: LD_INT 6
54311: LESS
54312: IFFALSE 54524
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54314: LD_ADDR_VAR 0 6
54318: PUSH
54319: LD_EXP 113
54323: PUSH
54324: LD_VAR 0 2
54328: ARRAY
54329: PPUSH
54330: LD_INT 2
54332: PUSH
54333: LD_INT 30
54335: PUSH
54336: LD_INT 0
54338: PUSH
54339: EMPTY
54340: LIST
54341: LIST
54342: PUSH
54343: LD_INT 30
54345: PUSH
54346: LD_INT 1
54348: PUSH
54349: EMPTY
54350: LIST
54351: LIST
54352: PUSH
54353: EMPTY
54354: LIST
54355: LIST
54356: LIST
54357: PPUSH
54358: CALL_OW 72
54362: ST_TO_ADDR
// if depot then
54363: LD_VAR 0 6
54367: IFFALSE 54524
// begin selected := 0 ;
54369: LD_ADDR_VAR 0 7
54373: PUSH
54374: LD_INT 0
54376: ST_TO_ADDR
// for j in depot do
54377: LD_ADDR_VAR 0 3
54381: PUSH
54382: LD_VAR 0 6
54386: PUSH
54387: FOR_IN
54388: IFFALSE 54419
// begin if UnitsInside ( j ) < 6 then
54390: LD_VAR 0 3
54394: PPUSH
54395: CALL_OW 313
54399: PUSH
54400: LD_INT 6
54402: LESS
54403: IFFALSE 54417
// begin selected := j ;
54405: LD_ADDR_VAR 0 7
54409: PUSH
54410: LD_VAR 0 3
54414: ST_TO_ADDR
// break ;
54415: GO 54419
// end ; end ;
54417: GO 54387
54419: POP
54420: POP
// if selected then
54421: LD_VAR 0 7
54425: IFFALSE 54524
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54427: LD_ADDR_VAR 0 3
54431: PUSH
54432: LD_EXP 142
54436: PUSH
54437: LD_VAR 0 2
54441: ARRAY
54442: PPUSH
54443: LD_INT 25
54445: PUSH
54446: LD_INT 12
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: PPUSH
54453: CALL_OW 72
54457: PUSH
54458: FOR_IN
54459: IFFALSE 54522
// if not HasTask ( j ) then
54461: LD_VAR 0 3
54465: PPUSH
54466: CALL_OW 314
54470: NOT
54471: IFFALSE 54520
// begin if not IsInUnit ( j ) then
54473: LD_VAR 0 3
54477: PPUSH
54478: CALL_OW 310
54482: NOT
54483: IFFALSE 54499
// ComEnterUnit ( j , selected ) ;
54485: LD_VAR 0 3
54489: PPUSH
54490: LD_VAR 0 7
54494: PPUSH
54495: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54499: LD_VAR 0 3
54503: PPUSH
54504: LD_INT 16
54506: PPUSH
54507: CALL_OW 183
// AddComExitBuilding ( j ) ;
54511: LD_VAR 0 3
54515: PPUSH
54516: CALL_OW 182
// end ;
54520: GO 54458
54522: POP
54523: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54524: LD_VAR 0 5
54528: PPUSH
54529: LD_INT 11
54531: PPUSH
54532: CALL_OW 325
54536: IFFALSE 54795
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54538: LD_ADDR_VAR 0 4
54542: PUSH
54543: LD_EXP 142
54547: PUSH
54548: LD_VAR 0 2
54552: ARRAY
54553: PPUSH
54554: LD_INT 25
54556: PUSH
54557: LD_INT 16
54559: PUSH
54560: EMPTY
54561: LIST
54562: LIST
54563: PPUSH
54564: CALL_OW 72
54568: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54569: LD_VAR 0 4
54573: PUSH
54574: LD_INT 6
54576: GREATEREQUAL
54577: PUSH
54578: LD_VAR 0 5
54582: PPUSH
54583: LD_INT 2
54585: PPUSH
54586: CALL_OW 325
54590: NOT
54591: OR
54592: IFFALSE 54795
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54594: LD_ADDR_VAR 0 8
54598: PUSH
54599: LD_EXP 113
54603: PUSH
54604: LD_VAR 0 2
54608: ARRAY
54609: PPUSH
54610: LD_INT 2
54612: PUSH
54613: LD_INT 30
54615: PUSH
54616: LD_INT 4
54618: PUSH
54619: EMPTY
54620: LIST
54621: LIST
54622: PUSH
54623: LD_INT 30
54625: PUSH
54626: LD_INT 5
54628: PUSH
54629: EMPTY
54630: LIST
54631: LIST
54632: PUSH
54633: EMPTY
54634: LIST
54635: LIST
54636: LIST
54637: PPUSH
54638: CALL_OW 72
54642: ST_TO_ADDR
// if barracks then
54643: LD_VAR 0 8
54647: IFFALSE 54795
// begin selected := 0 ;
54649: LD_ADDR_VAR 0 7
54653: PUSH
54654: LD_INT 0
54656: ST_TO_ADDR
// for j in barracks do
54657: LD_ADDR_VAR 0 3
54661: PUSH
54662: LD_VAR 0 8
54666: PUSH
54667: FOR_IN
54668: IFFALSE 54699
// begin if UnitsInside ( j ) < 6 then
54670: LD_VAR 0 3
54674: PPUSH
54675: CALL_OW 313
54679: PUSH
54680: LD_INT 6
54682: LESS
54683: IFFALSE 54697
// begin selected := j ;
54685: LD_ADDR_VAR 0 7
54689: PUSH
54690: LD_VAR 0 3
54694: ST_TO_ADDR
// break ;
54695: GO 54699
// end ; end ;
54697: GO 54667
54699: POP
54700: POP
// if selected then
54701: LD_VAR 0 7
54705: IFFALSE 54795
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54707: LD_ADDR_VAR 0 3
54711: PUSH
54712: LD_EXP 142
54716: PUSH
54717: LD_VAR 0 2
54721: ARRAY
54722: PPUSH
54723: LD_INT 25
54725: PUSH
54726: LD_INT 12
54728: PUSH
54729: EMPTY
54730: LIST
54731: LIST
54732: PPUSH
54733: CALL_OW 72
54737: PUSH
54738: FOR_IN
54739: IFFALSE 54793
// if not IsInUnit ( j ) and not HasTask ( j ) then
54741: LD_VAR 0 3
54745: PPUSH
54746: CALL_OW 310
54750: NOT
54751: PUSH
54752: LD_VAR 0 3
54756: PPUSH
54757: CALL_OW 314
54761: NOT
54762: AND
54763: IFFALSE 54791
// begin ComEnterUnit ( j , selected ) ;
54765: LD_VAR 0 3
54769: PPUSH
54770: LD_VAR 0 7
54774: PPUSH
54775: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54779: LD_VAR 0 3
54783: PPUSH
54784: LD_INT 15
54786: PPUSH
54787: CALL_OW 183
// end ;
54791: GO 54738
54793: POP
54794: POP
// end ; end ; end ; end ; end ;
54795: GO 54188
54797: POP
54798: POP
// end ;
54799: LD_VAR 0 1
54803: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54804: LD_INT 0
54806: PPUSH
54807: PPUSH
54808: PPUSH
54809: PPUSH
// if not mc_bases then
54810: LD_EXP 113
54814: NOT
54815: IFFALSE 54819
// exit ;
54817: GO 54997
// for i = 1 to mc_bases do
54819: LD_ADDR_VAR 0 2
54823: PUSH
54824: DOUBLE
54825: LD_INT 1
54827: DEC
54828: ST_TO_ADDR
54829: LD_EXP 113
54833: PUSH
54834: FOR_TO
54835: IFFALSE 54995
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54837: LD_ADDR_VAR 0 4
54841: PUSH
54842: LD_EXP 113
54846: PUSH
54847: LD_VAR 0 2
54851: ARRAY
54852: PPUSH
54853: LD_INT 25
54855: PUSH
54856: LD_INT 9
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: PPUSH
54863: CALL_OW 72
54867: ST_TO_ADDR
// if not tmp then
54868: LD_VAR 0 4
54872: NOT
54873: IFFALSE 54877
// continue ;
54875: GO 54834
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54877: LD_EXP 139
54881: PUSH
54882: LD_VAR 0 2
54886: ARRAY
54887: PPUSH
54888: LD_INT 29
54890: PPUSH
54891: CALL_OW 325
54895: NOT
54896: PUSH
54897: LD_EXP 139
54901: PUSH
54902: LD_VAR 0 2
54906: ARRAY
54907: PPUSH
54908: LD_INT 28
54910: PPUSH
54911: CALL_OW 325
54915: NOT
54916: AND
54917: IFFALSE 54921
// continue ;
54919: GO 54834
// for j in tmp do
54921: LD_ADDR_VAR 0 3
54925: PUSH
54926: LD_VAR 0 4
54930: PUSH
54931: FOR_IN
54932: IFFALSE 54991
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54934: LD_VAR 0 3
54938: PUSH
54939: LD_EXP 116
54943: PUSH
54944: LD_VAR 0 2
54948: ARRAY
54949: PUSH
54950: LD_INT 1
54952: ARRAY
54953: IN
54954: NOT
54955: PUSH
54956: LD_VAR 0 3
54960: PUSH
54961: LD_EXP 116
54965: PUSH
54966: LD_VAR 0 2
54970: ARRAY
54971: PUSH
54972: LD_INT 2
54974: ARRAY
54975: IN
54976: NOT
54977: AND
54978: IFFALSE 54989
// ComSpaceTimeShoot ( j ) ;
54980: LD_VAR 0 3
54984: PPUSH
54985: CALL 66154 0 1
54989: GO 54931
54991: POP
54992: POP
// end ;
54993: GO 54834
54995: POP
54996: POP
// end ;
54997: LD_VAR 0 1
55001: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55002: LD_INT 0
55004: PPUSH
55005: PPUSH
55006: PPUSH
55007: PPUSH
55008: PPUSH
55009: PPUSH
55010: PPUSH
55011: PPUSH
55012: PPUSH
// if not mc_bases then
55013: LD_EXP 113
55017: NOT
55018: IFFALSE 55022
// exit ;
55020: GO 55644
// for i = 1 to mc_bases do
55022: LD_ADDR_VAR 0 2
55026: PUSH
55027: DOUBLE
55028: LD_INT 1
55030: DEC
55031: ST_TO_ADDR
55032: LD_EXP 113
55036: PUSH
55037: FOR_TO
55038: IFFALSE 55642
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55040: LD_EXP 148
55044: PUSH
55045: LD_VAR 0 2
55049: ARRAY
55050: NOT
55051: PUSH
55052: LD_INT 38
55054: PPUSH
55055: LD_EXP 139
55059: PUSH
55060: LD_VAR 0 2
55064: ARRAY
55065: PPUSH
55066: CALL_OW 321
55070: PUSH
55071: LD_INT 2
55073: NONEQUAL
55074: OR
55075: IFFALSE 55079
// continue ;
55077: GO 55037
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55079: LD_ADDR_VAR 0 8
55083: PUSH
55084: LD_EXP 113
55088: PUSH
55089: LD_VAR 0 2
55093: ARRAY
55094: PPUSH
55095: LD_INT 30
55097: PUSH
55098: LD_INT 34
55100: PUSH
55101: EMPTY
55102: LIST
55103: LIST
55104: PPUSH
55105: CALL_OW 72
55109: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55110: LD_ADDR_VAR 0 9
55114: PUSH
55115: LD_EXP 113
55119: PUSH
55120: LD_VAR 0 2
55124: ARRAY
55125: PPUSH
55126: LD_INT 25
55128: PUSH
55129: LD_INT 4
55131: PUSH
55132: EMPTY
55133: LIST
55134: LIST
55135: PPUSH
55136: CALL_OW 72
55140: PPUSH
55141: LD_INT 0
55143: PPUSH
55144: CALL 98718 0 2
55148: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55149: LD_VAR 0 9
55153: NOT
55154: PUSH
55155: LD_VAR 0 8
55159: NOT
55160: OR
55161: PUSH
55162: LD_EXP 113
55166: PUSH
55167: LD_VAR 0 2
55171: ARRAY
55172: PPUSH
55173: LD_INT 124
55175: PPUSH
55176: CALL 98718 0 2
55180: OR
55181: IFFALSE 55185
// continue ;
55183: GO 55037
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55185: LD_EXP 149
55189: PUSH
55190: LD_VAR 0 2
55194: ARRAY
55195: PUSH
55196: LD_EXP 148
55200: PUSH
55201: LD_VAR 0 2
55205: ARRAY
55206: LESS
55207: PUSH
55208: LD_EXP 149
55212: PUSH
55213: LD_VAR 0 2
55217: ARRAY
55218: PUSH
55219: LD_VAR 0 8
55223: LESS
55224: AND
55225: IFFALSE 55640
// begin tmp := sci [ 1 ] ;
55227: LD_ADDR_VAR 0 7
55231: PUSH
55232: LD_VAR 0 9
55236: PUSH
55237: LD_INT 1
55239: ARRAY
55240: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55241: LD_VAR 0 7
55245: PPUSH
55246: LD_INT 124
55248: PPUSH
55249: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55253: LD_ADDR_VAR 0 3
55257: PUSH
55258: DOUBLE
55259: LD_EXP 148
55263: PUSH
55264: LD_VAR 0 2
55268: ARRAY
55269: INC
55270: ST_TO_ADDR
55271: LD_EXP 148
55275: PUSH
55276: LD_VAR 0 2
55280: ARRAY
55281: PUSH
55282: FOR_DOWNTO
55283: IFFALSE 55626
// begin if IsInUnit ( tmp ) then
55285: LD_VAR 0 7
55289: PPUSH
55290: CALL_OW 310
55294: IFFALSE 55305
// ComExitBuilding ( tmp ) ;
55296: LD_VAR 0 7
55300: PPUSH
55301: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55305: LD_INT 35
55307: PPUSH
55308: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55312: LD_VAR 0 7
55316: PPUSH
55317: CALL_OW 310
55321: NOT
55322: PUSH
55323: LD_VAR 0 7
55327: PPUSH
55328: CALL_OW 314
55332: NOT
55333: AND
55334: IFFALSE 55305
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55336: LD_ADDR_VAR 0 6
55340: PUSH
55341: LD_VAR 0 7
55345: PPUSH
55346: CALL_OW 250
55350: PUSH
55351: LD_VAR 0 7
55355: PPUSH
55356: CALL_OW 251
55360: PUSH
55361: EMPTY
55362: LIST
55363: LIST
55364: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55365: LD_INT 35
55367: PPUSH
55368: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55372: LD_ADDR_VAR 0 4
55376: PUSH
55377: LD_EXP 148
55381: PUSH
55382: LD_VAR 0 2
55386: ARRAY
55387: PUSH
55388: LD_VAR 0 3
55392: ARRAY
55393: PUSH
55394: LD_INT 1
55396: ARRAY
55397: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55398: LD_ADDR_VAR 0 5
55402: PUSH
55403: LD_EXP 148
55407: PUSH
55408: LD_VAR 0 2
55412: ARRAY
55413: PUSH
55414: LD_VAR 0 3
55418: ARRAY
55419: PUSH
55420: LD_INT 2
55422: ARRAY
55423: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55424: LD_VAR 0 7
55428: PPUSH
55429: LD_INT 10
55431: PPUSH
55432: CALL 72750 0 2
55436: PUSH
55437: LD_INT 4
55439: ARRAY
55440: IFFALSE 55478
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55442: LD_VAR 0 7
55446: PPUSH
55447: LD_VAR 0 6
55451: PUSH
55452: LD_INT 1
55454: ARRAY
55455: PPUSH
55456: LD_VAR 0 6
55460: PUSH
55461: LD_INT 2
55463: ARRAY
55464: PPUSH
55465: CALL_OW 111
// wait ( 0 0$10 ) ;
55469: LD_INT 350
55471: PPUSH
55472: CALL_OW 67
// end else
55476: GO 55504
// begin ComMoveXY ( tmp , x , y ) ;
55478: LD_VAR 0 7
55482: PPUSH
55483: LD_VAR 0 4
55487: PPUSH
55488: LD_VAR 0 5
55492: PPUSH
55493: CALL_OW 111
// wait ( 0 0$3 ) ;
55497: LD_INT 105
55499: PPUSH
55500: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55504: LD_VAR 0 7
55508: PPUSH
55509: LD_VAR 0 4
55513: PPUSH
55514: LD_VAR 0 5
55518: PPUSH
55519: CALL_OW 307
55523: IFFALSE 55365
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55525: LD_VAR 0 7
55529: PPUSH
55530: LD_VAR 0 4
55534: PPUSH
55535: LD_VAR 0 5
55539: PPUSH
55540: LD_VAR 0 8
55544: PUSH
55545: LD_VAR 0 3
55549: ARRAY
55550: PPUSH
55551: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55555: LD_INT 35
55557: PPUSH
55558: CALL_OW 67
// until not HasTask ( tmp ) ;
55562: LD_VAR 0 7
55566: PPUSH
55567: CALL_OW 314
55571: NOT
55572: IFFALSE 55555
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55574: LD_ADDR_EXP 149
55578: PUSH
55579: LD_EXP 149
55583: PPUSH
55584: LD_VAR 0 2
55588: PUSH
55589: LD_EXP 149
55593: PUSH
55594: LD_VAR 0 2
55598: ARRAY
55599: PUSH
55600: LD_INT 1
55602: PLUS
55603: PUSH
55604: EMPTY
55605: LIST
55606: LIST
55607: PPUSH
55608: LD_VAR 0 8
55612: PUSH
55613: LD_VAR 0 3
55617: ARRAY
55618: PPUSH
55619: CALL 70157 0 3
55623: ST_TO_ADDR
// end ;
55624: GO 55282
55626: POP
55627: POP
// MC_Reset ( i , 124 ) ;
55628: LD_VAR 0 2
55632: PPUSH
55633: LD_INT 124
55635: PPUSH
55636: CALL 39199 0 2
// end ; end ;
55640: GO 55037
55642: POP
55643: POP
// end ;
55644: LD_VAR 0 1
55648: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55649: LD_INT 0
55651: PPUSH
55652: PPUSH
55653: PPUSH
// if not mc_bases then
55654: LD_EXP 113
55658: NOT
55659: IFFALSE 55663
// exit ;
55661: GO 56269
// for i = 1 to mc_bases do
55663: LD_ADDR_VAR 0 2
55667: PUSH
55668: DOUBLE
55669: LD_INT 1
55671: DEC
55672: ST_TO_ADDR
55673: LD_EXP 113
55677: PUSH
55678: FOR_TO
55679: IFFALSE 56267
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55681: LD_ADDR_VAR 0 3
55685: PUSH
55686: LD_EXP 113
55690: PUSH
55691: LD_VAR 0 2
55695: ARRAY
55696: PPUSH
55697: LD_INT 25
55699: PUSH
55700: LD_INT 4
55702: PUSH
55703: EMPTY
55704: LIST
55705: LIST
55706: PPUSH
55707: CALL_OW 72
55711: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55712: LD_VAR 0 3
55716: NOT
55717: PUSH
55718: LD_EXP 150
55722: PUSH
55723: LD_VAR 0 2
55727: ARRAY
55728: NOT
55729: OR
55730: PUSH
55731: LD_EXP 113
55735: PUSH
55736: LD_VAR 0 2
55740: ARRAY
55741: PPUSH
55742: LD_INT 2
55744: PUSH
55745: LD_INT 30
55747: PUSH
55748: LD_INT 0
55750: PUSH
55751: EMPTY
55752: LIST
55753: LIST
55754: PUSH
55755: LD_INT 30
55757: PUSH
55758: LD_INT 1
55760: PUSH
55761: EMPTY
55762: LIST
55763: LIST
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: PPUSH
55770: CALL_OW 72
55774: NOT
55775: OR
55776: IFFALSE 55826
// begin if mc_deposits_finder [ i ] then
55778: LD_EXP 151
55782: PUSH
55783: LD_VAR 0 2
55787: ARRAY
55788: IFFALSE 55824
// begin MC_Reset ( i , 125 ) ;
55790: LD_VAR 0 2
55794: PPUSH
55795: LD_INT 125
55797: PPUSH
55798: CALL 39199 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55802: LD_ADDR_EXP 151
55806: PUSH
55807: LD_EXP 151
55811: PPUSH
55812: LD_VAR 0 2
55816: PPUSH
55817: EMPTY
55818: PPUSH
55819: CALL_OW 1
55823: ST_TO_ADDR
// end ; continue ;
55824: GO 55678
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55826: LD_EXP 150
55830: PUSH
55831: LD_VAR 0 2
55835: ARRAY
55836: PUSH
55837: LD_INT 1
55839: ARRAY
55840: PUSH
55841: LD_INT 3
55843: ARRAY
55844: PUSH
55845: LD_INT 1
55847: EQUAL
55848: PUSH
55849: LD_INT 20
55851: PPUSH
55852: LD_EXP 139
55856: PUSH
55857: LD_VAR 0 2
55861: ARRAY
55862: PPUSH
55863: CALL_OW 321
55867: PUSH
55868: LD_INT 2
55870: NONEQUAL
55871: AND
55872: IFFALSE 55922
// begin if mc_deposits_finder [ i ] then
55874: LD_EXP 151
55878: PUSH
55879: LD_VAR 0 2
55883: ARRAY
55884: IFFALSE 55920
// begin MC_Reset ( i , 125 ) ;
55886: LD_VAR 0 2
55890: PPUSH
55891: LD_INT 125
55893: PPUSH
55894: CALL 39199 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55898: LD_ADDR_EXP 151
55902: PUSH
55903: LD_EXP 151
55907: PPUSH
55908: LD_VAR 0 2
55912: PPUSH
55913: EMPTY
55914: PPUSH
55915: CALL_OW 1
55919: ST_TO_ADDR
// end ; continue ;
55920: GO 55678
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55922: LD_EXP 150
55926: PUSH
55927: LD_VAR 0 2
55931: ARRAY
55932: PUSH
55933: LD_INT 1
55935: ARRAY
55936: PUSH
55937: LD_INT 1
55939: ARRAY
55940: PPUSH
55941: LD_EXP 150
55945: PUSH
55946: LD_VAR 0 2
55950: ARRAY
55951: PUSH
55952: LD_INT 1
55954: ARRAY
55955: PUSH
55956: LD_INT 2
55958: ARRAY
55959: PPUSH
55960: LD_EXP 139
55964: PUSH
55965: LD_VAR 0 2
55969: ARRAY
55970: PPUSH
55971: CALL_OW 440
55975: IFFALSE 56018
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55977: LD_ADDR_EXP 150
55981: PUSH
55982: LD_EXP 150
55986: PPUSH
55987: LD_VAR 0 2
55991: PPUSH
55992: LD_EXP 150
55996: PUSH
55997: LD_VAR 0 2
56001: ARRAY
56002: PPUSH
56003: LD_INT 1
56005: PPUSH
56006: CALL_OW 3
56010: PPUSH
56011: CALL_OW 1
56015: ST_TO_ADDR
56016: GO 56265
// begin if not mc_deposits_finder [ i ] then
56018: LD_EXP 151
56022: PUSH
56023: LD_VAR 0 2
56027: ARRAY
56028: NOT
56029: IFFALSE 56081
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56031: LD_ADDR_EXP 151
56035: PUSH
56036: LD_EXP 151
56040: PPUSH
56041: LD_VAR 0 2
56045: PPUSH
56046: LD_VAR 0 3
56050: PUSH
56051: LD_INT 1
56053: ARRAY
56054: PUSH
56055: EMPTY
56056: LIST
56057: PPUSH
56058: CALL_OW 1
56062: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56063: LD_VAR 0 3
56067: PUSH
56068: LD_INT 1
56070: ARRAY
56071: PPUSH
56072: LD_INT 125
56074: PPUSH
56075: CALL_OW 109
// end else
56079: GO 56265
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56081: LD_EXP 151
56085: PUSH
56086: LD_VAR 0 2
56090: ARRAY
56091: PUSH
56092: LD_INT 1
56094: ARRAY
56095: PPUSH
56096: CALL_OW 310
56100: IFFALSE 56123
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56102: LD_EXP 151
56106: PUSH
56107: LD_VAR 0 2
56111: ARRAY
56112: PUSH
56113: LD_INT 1
56115: ARRAY
56116: PPUSH
56117: CALL_OW 122
56121: GO 56265
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56123: LD_EXP 151
56127: PUSH
56128: LD_VAR 0 2
56132: ARRAY
56133: PUSH
56134: LD_INT 1
56136: ARRAY
56137: PPUSH
56138: CALL_OW 314
56142: NOT
56143: PUSH
56144: LD_EXP 151
56148: PUSH
56149: LD_VAR 0 2
56153: ARRAY
56154: PUSH
56155: LD_INT 1
56157: ARRAY
56158: PPUSH
56159: LD_EXP 150
56163: PUSH
56164: LD_VAR 0 2
56168: ARRAY
56169: PUSH
56170: LD_INT 1
56172: ARRAY
56173: PUSH
56174: LD_INT 1
56176: ARRAY
56177: PPUSH
56178: LD_EXP 150
56182: PUSH
56183: LD_VAR 0 2
56187: ARRAY
56188: PUSH
56189: LD_INT 1
56191: ARRAY
56192: PUSH
56193: LD_INT 2
56195: ARRAY
56196: PPUSH
56197: CALL_OW 297
56201: PUSH
56202: LD_INT 6
56204: GREATER
56205: AND
56206: IFFALSE 56265
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56208: LD_EXP 151
56212: PUSH
56213: LD_VAR 0 2
56217: ARRAY
56218: PUSH
56219: LD_INT 1
56221: ARRAY
56222: PPUSH
56223: LD_EXP 150
56227: PUSH
56228: LD_VAR 0 2
56232: ARRAY
56233: PUSH
56234: LD_INT 1
56236: ARRAY
56237: PUSH
56238: LD_INT 1
56240: ARRAY
56241: PPUSH
56242: LD_EXP 150
56246: PUSH
56247: LD_VAR 0 2
56251: ARRAY
56252: PUSH
56253: LD_INT 1
56255: ARRAY
56256: PUSH
56257: LD_INT 2
56259: ARRAY
56260: PPUSH
56261: CALL_OW 111
// end ; end ; end ;
56265: GO 55678
56267: POP
56268: POP
// end ;
56269: LD_VAR 0 1
56273: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56274: LD_INT 0
56276: PPUSH
56277: PPUSH
56278: PPUSH
56279: PPUSH
56280: PPUSH
56281: PPUSH
56282: PPUSH
56283: PPUSH
56284: PPUSH
56285: PPUSH
56286: PPUSH
// if not mc_bases then
56287: LD_EXP 113
56291: NOT
56292: IFFALSE 56296
// exit ;
56294: GO 57236
// for i = 1 to mc_bases do
56296: LD_ADDR_VAR 0 2
56300: PUSH
56301: DOUBLE
56302: LD_INT 1
56304: DEC
56305: ST_TO_ADDR
56306: LD_EXP 113
56310: PUSH
56311: FOR_TO
56312: IFFALSE 57234
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56314: LD_EXP 113
56318: PUSH
56319: LD_VAR 0 2
56323: ARRAY
56324: NOT
56325: PUSH
56326: LD_EXP 136
56330: PUSH
56331: LD_VAR 0 2
56335: ARRAY
56336: OR
56337: IFFALSE 56341
// continue ;
56339: GO 56311
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56341: LD_ADDR_VAR 0 7
56345: PUSH
56346: LD_EXP 113
56350: PUSH
56351: LD_VAR 0 2
56355: ARRAY
56356: PUSH
56357: LD_INT 1
56359: ARRAY
56360: PPUSH
56361: CALL_OW 248
56365: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56366: LD_VAR 0 7
56370: PUSH
56371: LD_INT 3
56373: EQUAL
56374: PUSH
56375: LD_EXP 132
56379: PUSH
56380: LD_VAR 0 2
56384: ARRAY
56385: PUSH
56386: LD_EXP 135
56390: PUSH
56391: LD_VAR 0 2
56395: ARRAY
56396: UNION
56397: PPUSH
56398: LD_INT 33
56400: PUSH
56401: LD_INT 2
56403: PUSH
56404: EMPTY
56405: LIST
56406: LIST
56407: PPUSH
56408: CALL_OW 72
56412: NOT
56413: OR
56414: IFFALSE 56418
// continue ;
56416: GO 56311
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56418: LD_ADDR_VAR 0 9
56422: PUSH
56423: LD_EXP 113
56427: PUSH
56428: LD_VAR 0 2
56432: ARRAY
56433: PPUSH
56434: LD_INT 30
56436: PUSH
56437: LD_INT 36
56439: PUSH
56440: EMPTY
56441: LIST
56442: LIST
56443: PPUSH
56444: CALL_OW 72
56448: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56449: LD_ADDR_VAR 0 10
56453: PUSH
56454: LD_EXP 132
56458: PUSH
56459: LD_VAR 0 2
56463: ARRAY
56464: PPUSH
56465: LD_INT 34
56467: PUSH
56468: LD_INT 31
56470: PUSH
56471: EMPTY
56472: LIST
56473: LIST
56474: PPUSH
56475: CALL_OW 72
56479: ST_TO_ADDR
// if not cts and not mcts then
56480: LD_VAR 0 9
56484: NOT
56485: PUSH
56486: LD_VAR 0 10
56490: NOT
56491: AND
56492: IFFALSE 56496
// continue ;
56494: GO 56311
// x := cts ;
56496: LD_ADDR_VAR 0 11
56500: PUSH
56501: LD_VAR 0 9
56505: ST_TO_ADDR
// if not x then
56506: LD_VAR 0 11
56510: NOT
56511: IFFALSE 56523
// x := mcts ;
56513: LD_ADDR_VAR 0 11
56517: PUSH
56518: LD_VAR 0 10
56522: ST_TO_ADDR
// if not x then
56523: LD_VAR 0 11
56527: NOT
56528: IFFALSE 56532
// continue ;
56530: GO 56311
// if mc_remote_driver [ i ] then
56532: LD_EXP 153
56536: PUSH
56537: LD_VAR 0 2
56541: ARRAY
56542: IFFALSE 56929
// for j in mc_remote_driver [ i ] do
56544: LD_ADDR_VAR 0 3
56548: PUSH
56549: LD_EXP 153
56553: PUSH
56554: LD_VAR 0 2
56558: ARRAY
56559: PUSH
56560: FOR_IN
56561: IFFALSE 56927
// begin if GetClass ( j ) <> 3 then
56563: LD_VAR 0 3
56567: PPUSH
56568: CALL_OW 257
56572: PUSH
56573: LD_INT 3
56575: NONEQUAL
56576: IFFALSE 56629
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56578: LD_ADDR_EXP 153
56582: PUSH
56583: LD_EXP 153
56587: PPUSH
56588: LD_VAR 0 2
56592: PPUSH
56593: LD_EXP 153
56597: PUSH
56598: LD_VAR 0 2
56602: ARRAY
56603: PUSH
56604: LD_VAR 0 3
56608: DIFF
56609: PPUSH
56610: CALL_OW 1
56614: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56615: LD_VAR 0 3
56619: PPUSH
56620: LD_INT 0
56622: PPUSH
56623: CALL_OW 109
// continue ;
56627: GO 56560
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56629: LD_EXP 132
56633: PUSH
56634: LD_VAR 0 2
56638: ARRAY
56639: PPUSH
56640: LD_INT 34
56642: PUSH
56643: LD_INT 31
56645: PUSH
56646: EMPTY
56647: LIST
56648: LIST
56649: PUSH
56650: LD_INT 58
56652: PUSH
56653: EMPTY
56654: LIST
56655: PUSH
56656: EMPTY
56657: LIST
56658: LIST
56659: PPUSH
56660: CALL_OW 72
56664: PUSH
56665: LD_VAR 0 3
56669: PPUSH
56670: CALL 98806 0 1
56674: NOT
56675: AND
56676: IFFALSE 56747
// begin if IsInUnit ( j ) then
56678: LD_VAR 0 3
56682: PPUSH
56683: CALL_OW 310
56687: IFFALSE 56698
// ComExitBuilding ( j ) ;
56689: LD_VAR 0 3
56693: PPUSH
56694: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56698: LD_VAR 0 3
56702: PPUSH
56703: LD_EXP 132
56707: PUSH
56708: LD_VAR 0 2
56712: ARRAY
56713: PPUSH
56714: LD_INT 34
56716: PUSH
56717: LD_INT 31
56719: PUSH
56720: EMPTY
56721: LIST
56722: LIST
56723: PUSH
56724: LD_INT 58
56726: PUSH
56727: EMPTY
56728: LIST
56729: PUSH
56730: EMPTY
56731: LIST
56732: LIST
56733: PPUSH
56734: CALL_OW 72
56738: PUSH
56739: LD_INT 1
56741: ARRAY
56742: PPUSH
56743: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56747: LD_VAR 0 3
56751: PPUSH
56752: CALL_OW 310
56756: NOT
56757: PUSH
56758: LD_VAR 0 3
56762: PPUSH
56763: CALL_OW 310
56767: PPUSH
56768: CALL_OW 266
56772: PUSH
56773: LD_INT 36
56775: NONEQUAL
56776: PUSH
56777: LD_VAR 0 3
56781: PPUSH
56782: CALL 98806 0 1
56786: NOT
56787: AND
56788: OR
56789: IFFALSE 56925
// begin if IsInUnit ( j ) then
56791: LD_VAR 0 3
56795: PPUSH
56796: CALL_OW 310
56800: IFFALSE 56811
// ComExitBuilding ( j ) ;
56802: LD_VAR 0 3
56806: PPUSH
56807: CALL_OW 122
// ct := 0 ;
56811: LD_ADDR_VAR 0 8
56815: PUSH
56816: LD_INT 0
56818: ST_TO_ADDR
// for k in x do
56819: LD_ADDR_VAR 0 4
56823: PUSH
56824: LD_VAR 0 11
56828: PUSH
56829: FOR_IN
56830: IFFALSE 56903
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56832: LD_VAR 0 4
56836: PPUSH
56837: CALL_OW 264
56841: PUSH
56842: LD_INT 31
56844: EQUAL
56845: PUSH
56846: LD_VAR 0 4
56850: PPUSH
56851: CALL_OW 311
56855: NOT
56856: AND
56857: PUSH
56858: LD_VAR 0 4
56862: PPUSH
56863: CALL_OW 266
56867: PUSH
56868: LD_INT 36
56870: EQUAL
56871: PUSH
56872: LD_VAR 0 4
56876: PPUSH
56877: CALL_OW 313
56881: PUSH
56882: LD_INT 3
56884: LESS
56885: AND
56886: OR
56887: IFFALSE 56901
// begin ct := k ;
56889: LD_ADDR_VAR 0 8
56893: PUSH
56894: LD_VAR 0 4
56898: ST_TO_ADDR
// break ;
56899: GO 56903
// end ;
56901: GO 56829
56903: POP
56904: POP
// if ct then
56905: LD_VAR 0 8
56909: IFFALSE 56925
// ComEnterUnit ( j , ct ) ;
56911: LD_VAR 0 3
56915: PPUSH
56916: LD_VAR 0 8
56920: PPUSH
56921: CALL_OW 120
// end ; end ;
56925: GO 56560
56927: POP
56928: POP
// places := 0 ;
56929: LD_ADDR_VAR 0 5
56933: PUSH
56934: LD_INT 0
56936: ST_TO_ADDR
// for j = 1 to x do
56937: LD_ADDR_VAR 0 3
56941: PUSH
56942: DOUBLE
56943: LD_INT 1
56945: DEC
56946: ST_TO_ADDR
56947: LD_VAR 0 11
56951: PUSH
56952: FOR_TO
56953: IFFALSE 57029
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56955: LD_VAR 0 11
56959: PUSH
56960: LD_VAR 0 3
56964: ARRAY
56965: PPUSH
56966: CALL_OW 264
56970: PUSH
56971: LD_INT 31
56973: EQUAL
56974: IFFALSE 56992
// places := places + 1 else
56976: LD_ADDR_VAR 0 5
56980: PUSH
56981: LD_VAR 0 5
56985: PUSH
56986: LD_INT 1
56988: PLUS
56989: ST_TO_ADDR
56990: GO 57027
// if GetBType ( x [ j ] ) = b_control_tower then
56992: LD_VAR 0 11
56996: PUSH
56997: LD_VAR 0 3
57001: ARRAY
57002: PPUSH
57003: CALL_OW 266
57007: PUSH
57008: LD_INT 36
57010: EQUAL
57011: IFFALSE 57027
// places := places + 3 ;
57013: LD_ADDR_VAR 0 5
57017: PUSH
57018: LD_VAR 0 5
57022: PUSH
57023: LD_INT 3
57025: PLUS
57026: ST_TO_ADDR
57027: GO 56952
57029: POP
57030: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57031: LD_VAR 0 5
57035: PUSH
57036: LD_INT 0
57038: EQUAL
57039: PUSH
57040: LD_VAR 0 5
57044: PUSH
57045: LD_EXP 153
57049: PUSH
57050: LD_VAR 0 2
57054: ARRAY
57055: LESSEQUAL
57056: OR
57057: IFFALSE 57061
// continue ;
57059: GO 56311
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57061: LD_ADDR_VAR 0 6
57065: PUSH
57066: LD_EXP 113
57070: PUSH
57071: LD_VAR 0 2
57075: ARRAY
57076: PPUSH
57077: LD_INT 25
57079: PUSH
57080: LD_INT 3
57082: PUSH
57083: EMPTY
57084: LIST
57085: LIST
57086: PPUSH
57087: CALL_OW 72
57091: PUSH
57092: LD_EXP 153
57096: PUSH
57097: LD_VAR 0 2
57101: ARRAY
57102: DIFF
57103: PPUSH
57104: LD_INT 3
57106: PPUSH
57107: CALL 99706 0 2
57111: ST_TO_ADDR
// for j in tmp do
57112: LD_ADDR_VAR 0 3
57116: PUSH
57117: LD_VAR 0 6
57121: PUSH
57122: FOR_IN
57123: IFFALSE 57158
// if GetTag ( j ) > 0 then
57125: LD_VAR 0 3
57129: PPUSH
57130: CALL_OW 110
57134: PUSH
57135: LD_INT 0
57137: GREATER
57138: IFFALSE 57156
// tmp := tmp diff j ;
57140: LD_ADDR_VAR 0 6
57144: PUSH
57145: LD_VAR 0 6
57149: PUSH
57150: LD_VAR 0 3
57154: DIFF
57155: ST_TO_ADDR
57156: GO 57122
57158: POP
57159: POP
// if not tmp then
57160: LD_VAR 0 6
57164: NOT
57165: IFFALSE 57169
// continue ;
57167: GO 56311
// if places then
57169: LD_VAR 0 5
57173: IFFALSE 57232
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57175: LD_ADDR_EXP 153
57179: PUSH
57180: LD_EXP 153
57184: PPUSH
57185: LD_VAR 0 2
57189: PPUSH
57190: LD_EXP 153
57194: PUSH
57195: LD_VAR 0 2
57199: ARRAY
57200: PUSH
57201: LD_VAR 0 6
57205: PUSH
57206: LD_INT 1
57208: ARRAY
57209: UNION
57210: PPUSH
57211: CALL_OW 1
57215: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57216: LD_VAR 0 6
57220: PUSH
57221: LD_INT 1
57223: ARRAY
57224: PPUSH
57225: LD_INT 126
57227: PPUSH
57228: CALL_OW 109
// end ; end ;
57232: GO 56311
57234: POP
57235: POP
// end ;
57236: LD_VAR 0 1
57240: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57241: LD_INT 0
57243: PPUSH
57244: PPUSH
57245: PPUSH
57246: PPUSH
57247: PPUSH
57248: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57249: LD_VAR 0 1
57253: NOT
57254: PUSH
57255: LD_VAR 0 2
57259: NOT
57260: OR
57261: PUSH
57262: LD_VAR 0 3
57266: NOT
57267: OR
57268: PUSH
57269: LD_VAR 0 4
57273: PUSH
57274: LD_INT 1
57276: PUSH
57277: LD_INT 2
57279: PUSH
57280: LD_INT 3
57282: PUSH
57283: LD_INT 4
57285: PUSH
57286: LD_INT 5
57288: PUSH
57289: LD_INT 8
57291: PUSH
57292: LD_INT 9
57294: PUSH
57295: LD_INT 15
57297: PUSH
57298: LD_INT 16
57300: PUSH
57301: EMPTY
57302: LIST
57303: LIST
57304: LIST
57305: LIST
57306: LIST
57307: LIST
57308: LIST
57309: LIST
57310: LIST
57311: IN
57312: NOT
57313: OR
57314: IFFALSE 57318
// exit ;
57316: GO 58218
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57318: LD_ADDR_VAR 0 2
57322: PUSH
57323: LD_VAR 0 2
57327: PPUSH
57328: LD_INT 21
57330: PUSH
57331: LD_INT 3
57333: PUSH
57334: EMPTY
57335: LIST
57336: LIST
57337: PUSH
57338: LD_INT 24
57340: PUSH
57341: LD_INT 250
57343: PUSH
57344: EMPTY
57345: LIST
57346: LIST
57347: PUSH
57348: EMPTY
57349: LIST
57350: LIST
57351: PPUSH
57352: CALL_OW 72
57356: ST_TO_ADDR
// case class of 1 , 15 :
57357: LD_VAR 0 4
57361: PUSH
57362: LD_INT 1
57364: DOUBLE
57365: EQUAL
57366: IFTRUE 57376
57368: LD_INT 15
57370: DOUBLE
57371: EQUAL
57372: IFTRUE 57376
57374: GO 57461
57376: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57377: LD_ADDR_VAR 0 8
57381: PUSH
57382: LD_VAR 0 2
57386: PPUSH
57387: LD_INT 2
57389: PUSH
57390: LD_INT 30
57392: PUSH
57393: LD_INT 32
57395: PUSH
57396: EMPTY
57397: LIST
57398: LIST
57399: PUSH
57400: LD_INT 30
57402: PUSH
57403: LD_INT 31
57405: PUSH
57406: EMPTY
57407: LIST
57408: LIST
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: LIST
57414: PPUSH
57415: CALL_OW 72
57419: PUSH
57420: LD_VAR 0 2
57424: PPUSH
57425: LD_INT 2
57427: PUSH
57428: LD_INT 30
57430: PUSH
57431: LD_INT 4
57433: PUSH
57434: EMPTY
57435: LIST
57436: LIST
57437: PUSH
57438: LD_INT 30
57440: PUSH
57441: LD_INT 5
57443: PUSH
57444: EMPTY
57445: LIST
57446: LIST
57447: PUSH
57448: EMPTY
57449: LIST
57450: LIST
57451: LIST
57452: PPUSH
57453: CALL_OW 72
57457: ADD
57458: ST_TO_ADDR
57459: GO 57707
57461: LD_INT 2
57463: DOUBLE
57464: EQUAL
57465: IFTRUE 57475
57467: LD_INT 16
57469: DOUBLE
57470: EQUAL
57471: IFTRUE 57475
57473: GO 57521
57475: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57476: LD_ADDR_VAR 0 8
57480: PUSH
57481: LD_VAR 0 2
57485: PPUSH
57486: LD_INT 2
57488: PUSH
57489: LD_INT 30
57491: PUSH
57492: LD_INT 0
57494: PUSH
57495: EMPTY
57496: LIST
57497: LIST
57498: PUSH
57499: LD_INT 30
57501: PUSH
57502: LD_INT 1
57504: PUSH
57505: EMPTY
57506: LIST
57507: LIST
57508: PUSH
57509: EMPTY
57510: LIST
57511: LIST
57512: LIST
57513: PPUSH
57514: CALL_OW 72
57518: ST_TO_ADDR
57519: GO 57707
57521: LD_INT 3
57523: DOUBLE
57524: EQUAL
57525: IFTRUE 57529
57527: GO 57575
57529: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57530: LD_ADDR_VAR 0 8
57534: PUSH
57535: LD_VAR 0 2
57539: PPUSH
57540: LD_INT 2
57542: PUSH
57543: LD_INT 30
57545: PUSH
57546: LD_INT 2
57548: PUSH
57549: EMPTY
57550: LIST
57551: LIST
57552: PUSH
57553: LD_INT 30
57555: PUSH
57556: LD_INT 3
57558: PUSH
57559: EMPTY
57560: LIST
57561: LIST
57562: PUSH
57563: EMPTY
57564: LIST
57565: LIST
57566: LIST
57567: PPUSH
57568: CALL_OW 72
57572: ST_TO_ADDR
57573: GO 57707
57575: LD_INT 4
57577: DOUBLE
57578: EQUAL
57579: IFTRUE 57583
57581: GO 57640
57583: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57584: LD_ADDR_VAR 0 8
57588: PUSH
57589: LD_VAR 0 2
57593: PPUSH
57594: LD_INT 2
57596: PUSH
57597: LD_INT 30
57599: PUSH
57600: LD_INT 6
57602: PUSH
57603: EMPTY
57604: LIST
57605: LIST
57606: PUSH
57607: LD_INT 30
57609: PUSH
57610: LD_INT 7
57612: PUSH
57613: EMPTY
57614: LIST
57615: LIST
57616: PUSH
57617: LD_INT 30
57619: PUSH
57620: LD_INT 8
57622: PUSH
57623: EMPTY
57624: LIST
57625: LIST
57626: PUSH
57627: EMPTY
57628: LIST
57629: LIST
57630: LIST
57631: LIST
57632: PPUSH
57633: CALL_OW 72
57637: ST_TO_ADDR
57638: GO 57707
57640: LD_INT 5
57642: DOUBLE
57643: EQUAL
57644: IFTRUE 57660
57646: LD_INT 8
57648: DOUBLE
57649: EQUAL
57650: IFTRUE 57660
57652: LD_INT 9
57654: DOUBLE
57655: EQUAL
57656: IFTRUE 57660
57658: GO 57706
57660: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57661: LD_ADDR_VAR 0 8
57665: PUSH
57666: LD_VAR 0 2
57670: PPUSH
57671: LD_INT 2
57673: PUSH
57674: LD_INT 30
57676: PUSH
57677: LD_INT 4
57679: PUSH
57680: EMPTY
57681: LIST
57682: LIST
57683: PUSH
57684: LD_INT 30
57686: PUSH
57687: LD_INT 5
57689: PUSH
57690: EMPTY
57691: LIST
57692: LIST
57693: PUSH
57694: EMPTY
57695: LIST
57696: LIST
57697: LIST
57698: PPUSH
57699: CALL_OW 72
57703: ST_TO_ADDR
57704: GO 57707
57706: POP
// if not tmp then
57707: LD_VAR 0 8
57711: NOT
57712: IFFALSE 57716
// exit ;
57714: GO 58218
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57716: LD_VAR 0 4
57720: PUSH
57721: LD_INT 1
57723: PUSH
57724: LD_INT 15
57726: PUSH
57727: EMPTY
57728: LIST
57729: LIST
57730: IN
57731: PUSH
57732: LD_EXP 122
57736: PUSH
57737: LD_VAR 0 1
57741: ARRAY
57742: AND
57743: IFFALSE 57899
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57745: LD_ADDR_VAR 0 9
57749: PUSH
57750: LD_EXP 122
57754: PUSH
57755: LD_VAR 0 1
57759: ARRAY
57760: PUSH
57761: LD_INT 1
57763: ARRAY
57764: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57765: LD_VAR 0 9
57769: PUSH
57770: LD_EXP 123
57774: PUSH
57775: LD_VAR 0 1
57779: ARRAY
57780: IN
57781: NOT
57782: IFFALSE 57897
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57784: LD_ADDR_EXP 123
57788: PUSH
57789: LD_EXP 123
57793: PPUSH
57794: LD_VAR 0 1
57798: PUSH
57799: LD_EXP 123
57803: PUSH
57804: LD_VAR 0 1
57808: ARRAY
57809: PUSH
57810: LD_INT 1
57812: PLUS
57813: PUSH
57814: EMPTY
57815: LIST
57816: LIST
57817: PPUSH
57818: LD_VAR 0 9
57822: PPUSH
57823: CALL 70157 0 3
57827: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57828: LD_ADDR_EXP 122
57832: PUSH
57833: LD_EXP 122
57837: PPUSH
57838: LD_VAR 0 1
57842: PPUSH
57843: LD_EXP 122
57847: PUSH
57848: LD_VAR 0 1
57852: ARRAY
57853: PUSH
57854: LD_VAR 0 9
57858: DIFF
57859: PPUSH
57860: CALL_OW 1
57864: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57865: LD_VAR 0 3
57869: PPUSH
57870: LD_EXP 123
57874: PUSH
57875: LD_VAR 0 1
57879: ARRAY
57880: PUSH
57881: LD_EXP 123
57885: PUSH
57886: LD_VAR 0 1
57890: ARRAY
57891: ARRAY
57892: PPUSH
57893: CALL_OW 120
// end ; exit ;
57897: GO 58218
// end ; if tmp > 1 then
57899: LD_VAR 0 8
57903: PUSH
57904: LD_INT 1
57906: GREATER
57907: IFFALSE 58011
// for i = 2 to tmp do
57909: LD_ADDR_VAR 0 6
57913: PUSH
57914: DOUBLE
57915: LD_INT 2
57917: DEC
57918: ST_TO_ADDR
57919: LD_VAR 0 8
57923: PUSH
57924: FOR_TO
57925: IFFALSE 58009
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57927: LD_VAR 0 8
57931: PUSH
57932: LD_VAR 0 6
57936: ARRAY
57937: PPUSH
57938: CALL_OW 461
57942: PUSH
57943: LD_INT 6
57945: EQUAL
57946: IFFALSE 58007
// begin x := tmp [ i ] ;
57948: LD_ADDR_VAR 0 9
57952: PUSH
57953: LD_VAR 0 8
57957: PUSH
57958: LD_VAR 0 6
57962: ARRAY
57963: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57964: LD_ADDR_VAR 0 8
57968: PUSH
57969: LD_VAR 0 8
57973: PPUSH
57974: LD_VAR 0 6
57978: PPUSH
57979: CALL_OW 3
57983: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57984: LD_ADDR_VAR 0 8
57988: PUSH
57989: LD_VAR 0 8
57993: PPUSH
57994: LD_INT 1
57996: PPUSH
57997: LD_VAR 0 9
58001: PPUSH
58002: CALL_OW 2
58006: ST_TO_ADDR
// end ;
58007: GO 57924
58009: POP
58010: POP
// for i in tmp do
58011: LD_ADDR_VAR 0 6
58015: PUSH
58016: LD_VAR 0 8
58020: PUSH
58021: FOR_IN
58022: IFFALSE 58091
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58024: LD_VAR 0 6
58028: PPUSH
58029: CALL_OW 313
58033: PUSH
58034: LD_INT 6
58036: LESS
58037: PUSH
58038: LD_VAR 0 6
58042: PPUSH
58043: CALL_OW 266
58047: PUSH
58048: LD_INT 31
58050: PUSH
58051: LD_INT 32
58053: PUSH
58054: EMPTY
58055: LIST
58056: LIST
58057: IN
58058: NOT
58059: AND
58060: PUSH
58061: LD_VAR 0 6
58065: PPUSH
58066: CALL_OW 313
58070: PUSH
58071: LD_INT 0
58073: EQUAL
58074: OR
58075: IFFALSE 58089
// begin j := i ;
58077: LD_ADDR_VAR 0 7
58081: PUSH
58082: LD_VAR 0 6
58086: ST_TO_ADDR
// break ;
58087: GO 58091
// end ; end ;
58089: GO 58021
58091: POP
58092: POP
// if j then
58093: LD_VAR 0 7
58097: IFFALSE 58115
// ComEnterUnit ( unit , j ) else
58099: LD_VAR 0 3
58103: PPUSH
58104: LD_VAR 0 7
58108: PPUSH
58109: CALL_OW 120
58113: GO 58218
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58115: LD_ADDR_VAR 0 10
58119: PUSH
58120: LD_VAR 0 2
58124: PPUSH
58125: LD_INT 2
58127: PUSH
58128: LD_INT 30
58130: PUSH
58131: LD_INT 0
58133: PUSH
58134: EMPTY
58135: LIST
58136: LIST
58137: PUSH
58138: LD_INT 30
58140: PUSH
58141: LD_INT 1
58143: PUSH
58144: EMPTY
58145: LIST
58146: LIST
58147: PUSH
58148: EMPTY
58149: LIST
58150: LIST
58151: LIST
58152: PPUSH
58153: CALL_OW 72
58157: ST_TO_ADDR
// if depot then
58158: LD_VAR 0 10
58162: IFFALSE 58218
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58164: LD_ADDR_VAR 0 10
58168: PUSH
58169: LD_VAR 0 10
58173: PPUSH
58174: LD_VAR 0 3
58178: PPUSH
58179: CALL_OW 74
58183: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58184: LD_VAR 0 3
58188: PPUSH
58189: LD_VAR 0 10
58193: PPUSH
58194: CALL_OW 296
58198: PUSH
58199: LD_INT 10
58201: GREATER
58202: IFFALSE 58218
// ComStandNearbyBuilding ( unit , depot ) ;
58204: LD_VAR 0 3
58208: PPUSH
58209: LD_VAR 0 10
58213: PPUSH
58214: CALL 66771 0 2
// end ; end ; end ;
58218: LD_VAR 0 5
58222: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58223: LD_INT 0
58225: PPUSH
58226: PPUSH
58227: PPUSH
58228: PPUSH
// if not mc_bases then
58229: LD_EXP 113
58233: NOT
58234: IFFALSE 58238
// exit ;
58236: GO 58477
// for i = 1 to mc_bases do
58238: LD_ADDR_VAR 0 2
58242: PUSH
58243: DOUBLE
58244: LD_INT 1
58246: DEC
58247: ST_TO_ADDR
58248: LD_EXP 113
58252: PUSH
58253: FOR_TO
58254: IFFALSE 58475
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58256: LD_ADDR_VAR 0 4
58260: PUSH
58261: LD_EXP 113
58265: PUSH
58266: LD_VAR 0 2
58270: ARRAY
58271: PPUSH
58272: LD_INT 21
58274: PUSH
58275: LD_INT 1
58277: PUSH
58278: EMPTY
58279: LIST
58280: LIST
58281: PPUSH
58282: CALL_OW 72
58286: PUSH
58287: LD_EXP 142
58291: PUSH
58292: LD_VAR 0 2
58296: ARRAY
58297: UNION
58298: ST_TO_ADDR
// if not tmp then
58299: LD_VAR 0 4
58303: NOT
58304: IFFALSE 58308
// continue ;
58306: GO 58253
// for j in tmp do
58308: LD_ADDR_VAR 0 3
58312: PUSH
58313: LD_VAR 0 4
58317: PUSH
58318: FOR_IN
58319: IFFALSE 58471
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58321: LD_VAR 0 3
58325: PPUSH
58326: CALL_OW 110
58330: NOT
58331: PUSH
58332: LD_VAR 0 3
58336: PPUSH
58337: CALL_OW 314
58341: NOT
58342: AND
58343: PUSH
58344: LD_VAR 0 3
58348: PPUSH
58349: CALL_OW 311
58353: NOT
58354: AND
58355: PUSH
58356: LD_VAR 0 3
58360: PPUSH
58361: CALL_OW 310
58365: NOT
58366: AND
58367: PUSH
58368: LD_VAR 0 3
58372: PUSH
58373: LD_EXP 116
58377: PUSH
58378: LD_VAR 0 2
58382: ARRAY
58383: PUSH
58384: LD_INT 1
58386: ARRAY
58387: IN
58388: NOT
58389: AND
58390: PUSH
58391: LD_VAR 0 3
58395: PUSH
58396: LD_EXP 116
58400: PUSH
58401: LD_VAR 0 2
58405: ARRAY
58406: PUSH
58407: LD_INT 2
58409: ARRAY
58410: IN
58411: NOT
58412: AND
58413: PUSH
58414: LD_VAR 0 3
58418: PUSH
58419: LD_EXP 125
58423: PUSH
58424: LD_VAR 0 2
58428: ARRAY
58429: IN
58430: NOT
58431: AND
58432: IFFALSE 58469
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58434: LD_VAR 0 2
58438: PPUSH
58439: LD_EXP 113
58443: PUSH
58444: LD_VAR 0 2
58448: ARRAY
58449: PPUSH
58450: LD_VAR 0 3
58454: PPUSH
58455: LD_VAR 0 3
58459: PPUSH
58460: CALL_OW 257
58464: PPUSH
58465: CALL 57241 0 4
// end ;
58469: GO 58318
58471: POP
58472: POP
// end ;
58473: GO 58253
58475: POP
58476: POP
// end ;
58477: LD_VAR 0 1
58481: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58482: LD_INT 0
58484: PPUSH
58485: PPUSH
58486: PPUSH
58487: PPUSH
58488: PPUSH
58489: PPUSH
// if not mc_bases [ base ] then
58490: LD_EXP 113
58494: PUSH
58495: LD_VAR 0 1
58499: ARRAY
58500: NOT
58501: IFFALSE 58505
// exit ;
58503: GO 58687
// tmp := [ ] ;
58505: LD_ADDR_VAR 0 6
58509: PUSH
58510: EMPTY
58511: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58512: LD_ADDR_VAR 0 7
58516: PUSH
58517: LD_VAR 0 3
58521: PPUSH
58522: LD_INT 0
58524: PPUSH
58525: CALL_OW 517
58529: ST_TO_ADDR
// if not list then
58530: LD_VAR 0 7
58534: NOT
58535: IFFALSE 58539
// exit ;
58537: GO 58687
// for i = 1 to amount do
58539: LD_ADDR_VAR 0 5
58543: PUSH
58544: DOUBLE
58545: LD_INT 1
58547: DEC
58548: ST_TO_ADDR
58549: LD_VAR 0 2
58553: PUSH
58554: FOR_TO
58555: IFFALSE 58635
// begin x := rand ( 1 , list [ 1 ] ) ;
58557: LD_ADDR_VAR 0 8
58561: PUSH
58562: LD_INT 1
58564: PPUSH
58565: LD_VAR 0 7
58569: PUSH
58570: LD_INT 1
58572: ARRAY
58573: PPUSH
58574: CALL_OW 12
58578: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58579: LD_ADDR_VAR 0 6
58583: PUSH
58584: LD_VAR 0 6
58588: PPUSH
58589: LD_VAR 0 5
58593: PPUSH
58594: LD_VAR 0 7
58598: PUSH
58599: LD_INT 1
58601: ARRAY
58602: PUSH
58603: LD_VAR 0 8
58607: ARRAY
58608: PUSH
58609: LD_VAR 0 7
58613: PUSH
58614: LD_INT 2
58616: ARRAY
58617: PUSH
58618: LD_VAR 0 8
58622: ARRAY
58623: PUSH
58624: EMPTY
58625: LIST
58626: LIST
58627: PPUSH
58628: CALL_OW 1
58632: ST_TO_ADDR
// end ;
58633: GO 58554
58635: POP
58636: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58637: LD_ADDR_EXP 126
58641: PUSH
58642: LD_EXP 126
58646: PPUSH
58647: LD_VAR 0 1
58651: PPUSH
58652: LD_VAR 0 6
58656: PPUSH
58657: CALL_OW 1
58661: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58662: LD_ADDR_EXP 128
58666: PUSH
58667: LD_EXP 128
58671: PPUSH
58672: LD_VAR 0 1
58676: PPUSH
58677: LD_VAR 0 3
58681: PPUSH
58682: CALL_OW 1
58686: ST_TO_ADDR
// end ;
58687: LD_VAR 0 4
58691: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58692: LD_INT 0
58694: PPUSH
// if not mc_bases [ base ] then
58695: LD_EXP 113
58699: PUSH
58700: LD_VAR 0 1
58704: ARRAY
58705: NOT
58706: IFFALSE 58710
// exit ;
58708: GO 58735
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58710: LD_ADDR_EXP 118
58714: PUSH
58715: LD_EXP 118
58719: PPUSH
58720: LD_VAR 0 1
58724: PPUSH
58725: LD_VAR 0 2
58729: PPUSH
58730: CALL_OW 1
58734: ST_TO_ADDR
// end ;
58735: LD_VAR 0 3
58739: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58740: LD_INT 0
58742: PPUSH
// if not mc_bases [ base ] then
58743: LD_EXP 113
58747: PUSH
58748: LD_VAR 0 1
58752: ARRAY
58753: NOT
58754: IFFALSE 58758
// exit ;
58756: GO 58795
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58758: LD_ADDR_EXP 118
58762: PUSH
58763: LD_EXP 118
58767: PPUSH
58768: LD_VAR 0 1
58772: PPUSH
58773: LD_EXP 118
58777: PUSH
58778: LD_VAR 0 1
58782: ARRAY
58783: PUSH
58784: LD_VAR 0 2
58788: UNION
58789: PPUSH
58790: CALL_OW 1
58794: ST_TO_ADDR
// end ;
58795: LD_VAR 0 3
58799: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58800: LD_INT 0
58802: PPUSH
// if not mc_bases [ base ] then
58803: LD_EXP 113
58807: PUSH
58808: LD_VAR 0 1
58812: ARRAY
58813: NOT
58814: IFFALSE 58818
// exit ;
58816: GO 58843
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58818: LD_ADDR_EXP 134
58822: PUSH
58823: LD_EXP 134
58827: PPUSH
58828: LD_VAR 0 1
58832: PPUSH
58833: LD_VAR 0 2
58837: PPUSH
58838: CALL_OW 1
58842: ST_TO_ADDR
// end ;
58843: LD_VAR 0 3
58847: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58848: LD_INT 0
58850: PPUSH
// if not mc_bases [ base ] then
58851: LD_EXP 113
58855: PUSH
58856: LD_VAR 0 1
58860: ARRAY
58861: NOT
58862: IFFALSE 58866
// exit ;
58864: GO 58903
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58866: LD_ADDR_EXP 134
58870: PUSH
58871: LD_EXP 134
58875: PPUSH
58876: LD_VAR 0 1
58880: PPUSH
58881: LD_EXP 134
58885: PUSH
58886: LD_VAR 0 1
58890: ARRAY
58891: PUSH
58892: LD_VAR 0 2
58896: ADD
58897: PPUSH
58898: CALL_OW 1
58902: ST_TO_ADDR
// end ;
58903: LD_VAR 0 3
58907: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58908: LD_INT 0
58910: PPUSH
// if not mc_bases [ base ] then
58911: LD_EXP 113
58915: PUSH
58916: LD_VAR 0 1
58920: ARRAY
58921: NOT
58922: IFFALSE 58926
// exit ;
58924: GO 58980
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58926: LD_ADDR_EXP 135
58930: PUSH
58931: LD_EXP 135
58935: PPUSH
58936: LD_VAR 0 1
58940: PPUSH
58941: LD_VAR 0 2
58945: PPUSH
58946: CALL_OW 1
58950: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58951: LD_ADDR_EXP 124
58955: PUSH
58956: LD_EXP 124
58960: PPUSH
58961: LD_VAR 0 1
58965: PPUSH
58966: LD_VAR 0 2
58970: PUSH
58971: LD_INT 0
58973: PLUS
58974: PPUSH
58975: CALL_OW 1
58979: ST_TO_ADDR
// end ;
58980: LD_VAR 0 3
58984: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58985: LD_INT 0
58987: PPUSH
// if not mc_bases [ base ] then
58988: LD_EXP 113
58992: PUSH
58993: LD_VAR 0 1
58997: ARRAY
58998: NOT
58999: IFFALSE 59003
// exit ;
59001: GO 59028
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59003: LD_ADDR_EXP 124
59007: PUSH
59008: LD_EXP 124
59012: PPUSH
59013: LD_VAR 0 1
59017: PPUSH
59018: LD_VAR 0 2
59022: PPUSH
59023: CALL_OW 1
59027: ST_TO_ADDR
// end ;
59028: LD_VAR 0 3
59032: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59033: LD_INT 0
59035: PPUSH
59036: PPUSH
59037: PPUSH
59038: PPUSH
// if not mc_bases [ base ] then
59039: LD_EXP 113
59043: PUSH
59044: LD_VAR 0 1
59048: ARRAY
59049: NOT
59050: IFFALSE 59054
// exit ;
59052: GO 59119
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59054: LD_ADDR_EXP 133
59058: PUSH
59059: LD_EXP 133
59063: PPUSH
59064: LD_VAR 0 1
59068: PUSH
59069: LD_EXP 133
59073: PUSH
59074: LD_VAR 0 1
59078: ARRAY
59079: PUSH
59080: LD_INT 1
59082: PLUS
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: PPUSH
59088: LD_VAR 0 1
59092: PUSH
59093: LD_VAR 0 2
59097: PUSH
59098: LD_VAR 0 3
59102: PUSH
59103: LD_VAR 0 4
59107: PUSH
59108: EMPTY
59109: LIST
59110: LIST
59111: LIST
59112: LIST
59113: PPUSH
59114: CALL 70157 0 3
59118: ST_TO_ADDR
// end ;
59119: LD_VAR 0 5
59123: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59124: LD_INT 0
59126: PPUSH
// if not mc_bases [ base ] then
59127: LD_EXP 113
59131: PUSH
59132: LD_VAR 0 1
59136: ARRAY
59137: NOT
59138: IFFALSE 59142
// exit ;
59140: GO 59167
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59142: LD_ADDR_EXP 150
59146: PUSH
59147: LD_EXP 150
59151: PPUSH
59152: LD_VAR 0 1
59156: PPUSH
59157: LD_VAR 0 2
59161: PPUSH
59162: CALL_OW 1
59166: ST_TO_ADDR
// end ;
59167: LD_VAR 0 3
59171: RET
// export function MC_GetMinesField ( base ) ; begin
59172: LD_INT 0
59174: PPUSH
// result := mc_mines [ base ] ;
59175: LD_ADDR_VAR 0 2
59179: PUSH
59180: LD_EXP 126
59184: PUSH
59185: LD_VAR 0 1
59189: ARRAY
59190: ST_TO_ADDR
// end ;
59191: LD_VAR 0 2
59195: RET
// export function MC_GetProduceList ( base ) ; begin
59196: LD_INT 0
59198: PPUSH
// result := mc_produce [ base ] ;
59199: LD_ADDR_VAR 0 2
59203: PUSH
59204: LD_EXP 134
59208: PUSH
59209: LD_VAR 0 1
59213: ARRAY
59214: ST_TO_ADDR
// end ;
59215: LD_VAR 0 2
59219: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59220: LD_INT 0
59222: PPUSH
59223: PPUSH
// if not mc_bases then
59224: LD_EXP 113
59228: NOT
59229: IFFALSE 59233
// exit ;
59231: GO 59298
// if mc_bases [ base ] then
59233: LD_EXP 113
59237: PUSH
59238: LD_VAR 0 1
59242: ARRAY
59243: IFFALSE 59298
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59245: LD_ADDR_VAR 0 3
59249: PUSH
59250: LD_EXP 113
59254: PUSH
59255: LD_VAR 0 1
59259: ARRAY
59260: PPUSH
59261: LD_INT 30
59263: PUSH
59264: LD_VAR 0 2
59268: PUSH
59269: EMPTY
59270: LIST
59271: LIST
59272: PPUSH
59273: CALL_OW 72
59277: ST_TO_ADDR
// if result then
59278: LD_VAR 0 3
59282: IFFALSE 59298
// result := result [ 1 ] ;
59284: LD_ADDR_VAR 0 3
59288: PUSH
59289: LD_VAR 0 3
59293: PUSH
59294: LD_INT 1
59296: ARRAY
59297: ST_TO_ADDR
// end ; end ;
59298: LD_VAR 0 3
59302: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59303: LD_INT 0
59305: PPUSH
59306: PPUSH
// if not mc_bases then
59307: LD_EXP 113
59311: NOT
59312: IFFALSE 59316
// exit ;
59314: GO 59361
// if mc_bases [ base ] then
59316: LD_EXP 113
59320: PUSH
59321: LD_VAR 0 1
59325: ARRAY
59326: IFFALSE 59361
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59328: LD_ADDR_VAR 0 3
59332: PUSH
59333: LD_EXP 113
59337: PUSH
59338: LD_VAR 0 1
59342: ARRAY
59343: PPUSH
59344: LD_INT 30
59346: PUSH
59347: LD_VAR 0 2
59351: PUSH
59352: EMPTY
59353: LIST
59354: LIST
59355: PPUSH
59356: CALL_OW 72
59360: ST_TO_ADDR
// end ;
59361: LD_VAR 0 3
59365: RET
// export function MC_SetTame ( base , area ) ; begin
59366: LD_INT 0
59368: PPUSH
// if not mc_bases or not base then
59369: LD_EXP 113
59373: NOT
59374: PUSH
59375: LD_VAR 0 1
59379: NOT
59380: OR
59381: IFFALSE 59385
// exit ;
59383: GO 59410
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59385: LD_ADDR_EXP 141
59389: PUSH
59390: LD_EXP 141
59394: PPUSH
59395: LD_VAR 0 1
59399: PPUSH
59400: LD_VAR 0 2
59404: PPUSH
59405: CALL_OW 1
59409: ST_TO_ADDR
// end ;
59410: LD_VAR 0 3
59414: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59415: LD_INT 0
59417: PPUSH
59418: PPUSH
// if not mc_bases or not base then
59419: LD_EXP 113
59423: NOT
59424: PUSH
59425: LD_VAR 0 1
59429: NOT
59430: OR
59431: IFFALSE 59435
// exit ;
59433: GO 59537
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59435: LD_ADDR_VAR 0 4
59439: PUSH
59440: LD_EXP 113
59444: PUSH
59445: LD_VAR 0 1
59449: ARRAY
59450: PPUSH
59451: LD_INT 30
59453: PUSH
59454: LD_VAR 0 2
59458: PUSH
59459: EMPTY
59460: LIST
59461: LIST
59462: PPUSH
59463: CALL_OW 72
59467: ST_TO_ADDR
// if not tmp then
59468: LD_VAR 0 4
59472: NOT
59473: IFFALSE 59477
// exit ;
59475: GO 59537
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59477: LD_ADDR_EXP 145
59481: PUSH
59482: LD_EXP 145
59486: PPUSH
59487: LD_VAR 0 1
59491: PPUSH
59492: LD_EXP 145
59496: PUSH
59497: LD_VAR 0 1
59501: ARRAY
59502: PPUSH
59503: LD_EXP 145
59507: PUSH
59508: LD_VAR 0 1
59512: ARRAY
59513: PUSH
59514: LD_INT 1
59516: PLUS
59517: PPUSH
59518: LD_VAR 0 4
59522: PUSH
59523: LD_INT 1
59525: ARRAY
59526: PPUSH
59527: CALL_OW 2
59531: PPUSH
59532: CALL_OW 1
59536: ST_TO_ADDR
// end ;
59537: LD_VAR 0 3
59541: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59542: LD_INT 0
59544: PPUSH
59545: PPUSH
// if not mc_bases or not base or not kinds then
59546: LD_EXP 113
59550: NOT
59551: PUSH
59552: LD_VAR 0 1
59556: NOT
59557: OR
59558: PUSH
59559: LD_VAR 0 2
59563: NOT
59564: OR
59565: IFFALSE 59569
// exit ;
59567: GO 59630
// for i in kinds do
59569: LD_ADDR_VAR 0 4
59573: PUSH
59574: LD_VAR 0 2
59578: PUSH
59579: FOR_IN
59580: IFFALSE 59628
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59582: LD_ADDR_EXP 147
59586: PUSH
59587: LD_EXP 147
59591: PPUSH
59592: LD_VAR 0 1
59596: PUSH
59597: LD_EXP 147
59601: PUSH
59602: LD_VAR 0 1
59606: ARRAY
59607: PUSH
59608: LD_INT 1
59610: PLUS
59611: PUSH
59612: EMPTY
59613: LIST
59614: LIST
59615: PPUSH
59616: LD_VAR 0 4
59620: PPUSH
59621: CALL 70157 0 3
59625: ST_TO_ADDR
59626: GO 59579
59628: POP
59629: POP
// end ;
59630: LD_VAR 0 3
59634: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59635: LD_INT 0
59637: PPUSH
// if not mc_bases or not base or not areas then
59638: LD_EXP 113
59642: NOT
59643: PUSH
59644: LD_VAR 0 1
59648: NOT
59649: OR
59650: PUSH
59651: LD_VAR 0 2
59655: NOT
59656: OR
59657: IFFALSE 59661
// exit ;
59659: GO 59686
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59661: LD_ADDR_EXP 131
59665: PUSH
59666: LD_EXP 131
59670: PPUSH
59671: LD_VAR 0 1
59675: PPUSH
59676: LD_VAR 0 2
59680: PPUSH
59681: CALL_OW 1
59685: ST_TO_ADDR
// end ;
59686: LD_VAR 0 3
59690: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59691: LD_INT 0
59693: PPUSH
// if not mc_bases or not base or not teleports_exit then
59694: LD_EXP 113
59698: NOT
59699: PUSH
59700: LD_VAR 0 1
59704: NOT
59705: OR
59706: PUSH
59707: LD_VAR 0 2
59711: NOT
59712: OR
59713: IFFALSE 59717
// exit ;
59715: GO 59742
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59717: LD_ADDR_EXP 148
59721: PUSH
59722: LD_EXP 148
59726: PPUSH
59727: LD_VAR 0 1
59731: PPUSH
59732: LD_VAR 0 2
59736: PPUSH
59737: CALL_OW 1
59741: ST_TO_ADDR
// end ;
59742: LD_VAR 0 3
59746: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59747: LD_INT 0
59749: PPUSH
59750: PPUSH
59751: PPUSH
// if not mc_bases or not base or not ext_list then
59752: LD_EXP 113
59756: NOT
59757: PUSH
59758: LD_VAR 0 1
59762: NOT
59763: OR
59764: PUSH
59765: LD_VAR 0 5
59769: NOT
59770: OR
59771: IFFALSE 59775
// exit ;
59773: GO 59948
// tmp := GetFacExtXYD ( x , y , d ) ;
59775: LD_ADDR_VAR 0 8
59779: PUSH
59780: LD_VAR 0 2
59784: PPUSH
59785: LD_VAR 0 3
59789: PPUSH
59790: LD_VAR 0 4
59794: PPUSH
59795: CALL 98836 0 3
59799: ST_TO_ADDR
// if not tmp then
59800: LD_VAR 0 8
59804: NOT
59805: IFFALSE 59809
// exit ;
59807: GO 59948
// for i in tmp do
59809: LD_ADDR_VAR 0 7
59813: PUSH
59814: LD_VAR 0 8
59818: PUSH
59819: FOR_IN
59820: IFFALSE 59946
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59822: LD_ADDR_EXP 118
59826: PUSH
59827: LD_EXP 118
59831: PPUSH
59832: LD_VAR 0 1
59836: PPUSH
59837: LD_EXP 118
59841: PUSH
59842: LD_VAR 0 1
59846: ARRAY
59847: PPUSH
59848: LD_EXP 118
59852: PUSH
59853: LD_VAR 0 1
59857: ARRAY
59858: PUSH
59859: LD_INT 1
59861: PLUS
59862: PPUSH
59863: LD_VAR 0 5
59867: PUSH
59868: LD_INT 1
59870: ARRAY
59871: PUSH
59872: LD_VAR 0 7
59876: PUSH
59877: LD_INT 1
59879: ARRAY
59880: PUSH
59881: LD_VAR 0 7
59885: PUSH
59886: LD_INT 2
59888: ARRAY
59889: PUSH
59890: LD_VAR 0 7
59894: PUSH
59895: LD_INT 3
59897: ARRAY
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: LIST
59903: LIST
59904: PPUSH
59905: CALL_OW 2
59909: PPUSH
59910: CALL_OW 1
59914: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59915: LD_ADDR_VAR 0 5
59919: PUSH
59920: LD_VAR 0 5
59924: PPUSH
59925: LD_INT 1
59927: PPUSH
59928: CALL_OW 3
59932: ST_TO_ADDR
// if not ext_list then
59933: LD_VAR 0 5
59937: NOT
59938: IFFALSE 59944
// exit ;
59940: POP
59941: POP
59942: GO 59948
// end ;
59944: GO 59819
59946: POP
59947: POP
// end ;
59948: LD_VAR 0 6
59952: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59953: LD_INT 0
59955: PPUSH
// if not mc_bases or not base or not weapon_list then
59956: LD_EXP 113
59960: NOT
59961: PUSH
59962: LD_VAR 0 1
59966: NOT
59967: OR
59968: PUSH
59969: LD_VAR 0 2
59973: NOT
59974: OR
59975: IFFALSE 59979
// exit ;
59977: GO 60004
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59979: LD_ADDR_EXP 152
59983: PUSH
59984: LD_EXP 152
59988: PPUSH
59989: LD_VAR 0 1
59993: PPUSH
59994: LD_VAR 0 2
59998: PPUSH
59999: CALL_OW 1
60003: ST_TO_ADDR
// end ;
60004: LD_VAR 0 3
60008: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60009: LD_INT 0
60011: PPUSH
// if not mc_bases or not base or not tech_list then
60012: LD_EXP 113
60016: NOT
60017: PUSH
60018: LD_VAR 0 1
60022: NOT
60023: OR
60024: PUSH
60025: LD_VAR 0 2
60029: NOT
60030: OR
60031: IFFALSE 60035
// exit ;
60033: GO 60060
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60035: LD_ADDR_EXP 140
60039: PUSH
60040: LD_EXP 140
60044: PPUSH
60045: LD_VAR 0 1
60049: PPUSH
60050: LD_VAR 0 2
60054: PPUSH
60055: CALL_OW 1
60059: ST_TO_ADDR
// end ;
60060: LD_VAR 0 3
60064: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60065: LD_INT 0
60067: PPUSH
// if not mc_bases or not parking_area or not base then
60068: LD_EXP 113
60072: NOT
60073: PUSH
60074: LD_VAR 0 2
60078: NOT
60079: OR
60080: PUSH
60081: LD_VAR 0 1
60085: NOT
60086: OR
60087: IFFALSE 60091
// exit ;
60089: GO 60116
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60091: LD_ADDR_EXP 137
60095: PUSH
60096: LD_EXP 137
60100: PPUSH
60101: LD_VAR 0 1
60105: PPUSH
60106: LD_VAR 0 2
60110: PPUSH
60111: CALL_OW 1
60115: ST_TO_ADDR
// end ;
60116: LD_VAR 0 3
60120: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60121: LD_INT 0
60123: PPUSH
// if not mc_bases or not base or not scan_area then
60124: LD_EXP 113
60128: NOT
60129: PUSH
60130: LD_VAR 0 1
60134: NOT
60135: OR
60136: PUSH
60137: LD_VAR 0 2
60141: NOT
60142: OR
60143: IFFALSE 60147
// exit ;
60145: GO 60172
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60147: LD_ADDR_EXP 138
60151: PUSH
60152: LD_EXP 138
60156: PPUSH
60157: LD_VAR 0 1
60161: PPUSH
60162: LD_VAR 0 2
60166: PPUSH
60167: CALL_OW 1
60171: ST_TO_ADDR
// end ;
60172: LD_VAR 0 3
60176: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60177: LD_INT 0
60179: PPUSH
60180: PPUSH
// if not mc_bases or not base then
60181: LD_EXP 113
60185: NOT
60186: PUSH
60187: LD_VAR 0 1
60191: NOT
60192: OR
60193: IFFALSE 60197
// exit ;
60195: GO 60261
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60197: LD_ADDR_VAR 0 3
60201: PUSH
60202: LD_INT 1
60204: PUSH
60205: LD_INT 2
60207: PUSH
60208: LD_INT 3
60210: PUSH
60211: LD_INT 4
60213: PUSH
60214: LD_INT 11
60216: PUSH
60217: EMPTY
60218: LIST
60219: LIST
60220: LIST
60221: LIST
60222: LIST
60223: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60224: LD_ADDR_EXP 140
60228: PUSH
60229: LD_EXP 140
60233: PPUSH
60234: LD_VAR 0 1
60238: PPUSH
60239: LD_EXP 140
60243: PUSH
60244: LD_VAR 0 1
60248: ARRAY
60249: PUSH
60250: LD_VAR 0 3
60254: DIFF
60255: PPUSH
60256: CALL_OW 1
60260: ST_TO_ADDR
// end ;
60261: LD_VAR 0 2
60265: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60266: LD_INT 0
60268: PPUSH
// result := mc_vehicles [ base ] ;
60269: LD_ADDR_VAR 0 3
60273: PUSH
60274: LD_EXP 132
60278: PUSH
60279: LD_VAR 0 1
60283: ARRAY
60284: ST_TO_ADDR
// if onlyCombat then
60285: LD_VAR 0 2
60289: IFFALSE 60467
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60291: LD_ADDR_VAR 0 3
60295: PUSH
60296: LD_VAR 0 3
60300: PUSH
60301: LD_VAR 0 3
60305: PPUSH
60306: LD_INT 2
60308: PUSH
60309: LD_INT 34
60311: PUSH
60312: LD_INT 12
60314: PUSH
60315: EMPTY
60316: LIST
60317: LIST
60318: PUSH
60319: LD_INT 34
60321: PUSH
60322: LD_INT 51
60324: PUSH
60325: EMPTY
60326: LIST
60327: LIST
60328: PUSH
60329: LD_INT 34
60331: PUSH
60332: LD_EXP 96
60336: PUSH
60337: EMPTY
60338: LIST
60339: LIST
60340: PUSH
60341: LD_INT 34
60343: PUSH
60344: LD_INT 32
60346: PUSH
60347: EMPTY
60348: LIST
60349: LIST
60350: PUSH
60351: LD_INT 34
60353: PUSH
60354: LD_INT 13
60356: PUSH
60357: EMPTY
60358: LIST
60359: LIST
60360: PUSH
60361: LD_INT 34
60363: PUSH
60364: LD_INT 52
60366: PUSH
60367: EMPTY
60368: LIST
60369: LIST
60370: PUSH
60371: LD_INT 34
60373: PUSH
60374: LD_EXP 101
60378: PUSH
60379: EMPTY
60380: LIST
60381: LIST
60382: PUSH
60383: LD_INT 34
60385: PUSH
60386: LD_INT 14
60388: PUSH
60389: EMPTY
60390: LIST
60391: LIST
60392: PUSH
60393: LD_INT 34
60395: PUSH
60396: LD_INT 53
60398: PUSH
60399: EMPTY
60400: LIST
60401: LIST
60402: PUSH
60403: LD_INT 34
60405: PUSH
60406: LD_EXP 95
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: PUSH
60415: LD_INT 34
60417: PUSH
60418: LD_INT 31
60420: PUSH
60421: EMPTY
60422: LIST
60423: LIST
60424: PUSH
60425: LD_INT 34
60427: PUSH
60428: LD_INT 48
60430: PUSH
60431: EMPTY
60432: LIST
60433: LIST
60434: PUSH
60435: LD_INT 34
60437: PUSH
60438: LD_INT 8
60440: PUSH
60441: EMPTY
60442: LIST
60443: LIST
60444: PUSH
60445: EMPTY
60446: LIST
60447: LIST
60448: LIST
60449: LIST
60450: LIST
60451: LIST
60452: LIST
60453: LIST
60454: LIST
60455: LIST
60456: LIST
60457: LIST
60458: LIST
60459: LIST
60460: PPUSH
60461: CALL_OW 72
60465: DIFF
60466: ST_TO_ADDR
// end ; end_of_file
60467: LD_VAR 0 3
60471: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60472: LD_INT 0
60474: PPUSH
60475: PPUSH
60476: PPUSH
// if not mc_bases or not skirmish then
60477: LD_EXP 113
60481: NOT
60482: PUSH
60483: LD_EXP 111
60487: NOT
60488: OR
60489: IFFALSE 60493
// exit ;
60491: GO 60658
// for i = 1 to mc_bases do
60493: LD_ADDR_VAR 0 4
60497: PUSH
60498: DOUBLE
60499: LD_INT 1
60501: DEC
60502: ST_TO_ADDR
60503: LD_EXP 113
60507: PUSH
60508: FOR_TO
60509: IFFALSE 60656
// begin if sci in mc_bases [ i ] then
60511: LD_VAR 0 2
60515: PUSH
60516: LD_EXP 113
60520: PUSH
60521: LD_VAR 0 4
60525: ARRAY
60526: IN
60527: IFFALSE 60654
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60529: LD_ADDR_EXP 142
60533: PUSH
60534: LD_EXP 142
60538: PPUSH
60539: LD_VAR 0 4
60543: PUSH
60544: LD_EXP 142
60548: PUSH
60549: LD_VAR 0 4
60553: ARRAY
60554: PUSH
60555: LD_INT 1
60557: PLUS
60558: PUSH
60559: EMPTY
60560: LIST
60561: LIST
60562: PPUSH
60563: LD_VAR 0 1
60567: PPUSH
60568: CALL 70157 0 3
60572: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60573: LD_ADDR_VAR 0 5
60577: PUSH
60578: LD_EXP 113
60582: PUSH
60583: LD_VAR 0 4
60587: ARRAY
60588: PPUSH
60589: LD_INT 2
60591: PUSH
60592: LD_INT 30
60594: PUSH
60595: LD_INT 0
60597: PUSH
60598: EMPTY
60599: LIST
60600: LIST
60601: PUSH
60602: LD_INT 30
60604: PUSH
60605: LD_INT 1
60607: PUSH
60608: EMPTY
60609: LIST
60610: LIST
60611: PUSH
60612: EMPTY
60613: LIST
60614: LIST
60615: LIST
60616: PPUSH
60617: CALL_OW 72
60621: PPUSH
60622: LD_VAR 0 1
60626: PPUSH
60627: CALL_OW 74
60631: ST_TO_ADDR
// if tmp then
60632: LD_VAR 0 5
60636: IFFALSE 60652
// ComStandNearbyBuilding ( ape , tmp ) ;
60638: LD_VAR 0 1
60642: PPUSH
60643: LD_VAR 0 5
60647: PPUSH
60648: CALL 66771 0 2
// break ;
60652: GO 60656
// end ; end ;
60654: GO 60508
60656: POP
60657: POP
// end ;
60658: LD_VAR 0 3
60662: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60663: LD_INT 0
60665: PPUSH
60666: PPUSH
60667: PPUSH
// if not mc_bases or not skirmish then
60668: LD_EXP 113
60672: NOT
60673: PUSH
60674: LD_EXP 111
60678: NOT
60679: OR
60680: IFFALSE 60684
// exit ;
60682: GO 60773
// for i = 1 to mc_bases do
60684: LD_ADDR_VAR 0 4
60688: PUSH
60689: DOUBLE
60690: LD_INT 1
60692: DEC
60693: ST_TO_ADDR
60694: LD_EXP 113
60698: PUSH
60699: FOR_TO
60700: IFFALSE 60771
// begin if building in mc_busy_turret_list [ i ] then
60702: LD_VAR 0 1
60706: PUSH
60707: LD_EXP 123
60711: PUSH
60712: LD_VAR 0 4
60716: ARRAY
60717: IN
60718: IFFALSE 60769
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60720: LD_ADDR_VAR 0 5
60724: PUSH
60725: LD_EXP 123
60729: PUSH
60730: LD_VAR 0 4
60734: ARRAY
60735: PUSH
60736: LD_VAR 0 1
60740: DIFF
60741: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60742: LD_ADDR_EXP 123
60746: PUSH
60747: LD_EXP 123
60751: PPUSH
60752: LD_VAR 0 4
60756: PPUSH
60757: LD_VAR 0 5
60761: PPUSH
60762: CALL_OW 1
60766: ST_TO_ADDR
// break ;
60767: GO 60771
// end ; end ;
60769: GO 60699
60771: POP
60772: POP
// end ;
60773: LD_VAR 0 3
60777: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60778: LD_INT 0
60780: PPUSH
60781: PPUSH
60782: PPUSH
// if not mc_bases or not skirmish then
60783: LD_EXP 113
60787: NOT
60788: PUSH
60789: LD_EXP 111
60793: NOT
60794: OR
60795: IFFALSE 60799
// exit ;
60797: GO 60998
// for i = 1 to mc_bases do
60799: LD_ADDR_VAR 0 5
60803: PUSH
60804: DOUBLE
60805: LD_INT 1
60807: DEC
60808: ST_TO_ADDR
60809: LD_EXP 113
60813: PUSH
60814: FOR_TO
60815: IFFALSE 60996
// if building in mc_bases [ i ] then
60817: LD_VAR 0 1
60821: PUSH
60822: LD_EXP 113
60826: PUSH
60827: LD_VAR 0 5
60831: ARRAY
60832: IN
60833: IFFALSE 60994
// begin tmp := mc_bases [ i ] diff building ;
60835: LD_ADDR_VAR 0 6
60839: PUSH
60840: LD_EXP 113
60844: PUSH
60845: LD_VAR 0 5
60849: ARRAY
60850: PUSH
60851: LD_VAR 0 1
60855: DIFF
60856: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60857: LD_ADDR_EXP 113
60861: PUSH
60862: LD_EXP 113
60866: PPUSH
60867: LD_VAR 0 5
60871: PPUSH
60872: LD_VAR 0 6
60876: PPUSH
60877: CALL_OW 1
60881: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60882: LD_VAR 0 1
60886: PUSH
60887: LD_EXP 121
60891: PUSH
60892: LD_VAR 0 5
60896: ARRAY
60897: IN
60898: IFFALSE 60937
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60900: LD_ADDR_EXP 121
60904: PUSH
60905: LD_EXP 121
60909: PPUSH
60910: LD_VAR 0 5
60914: PPUSH
60915: LD_EXP 121
60919: PUSH
60920: LD_VAR 0 5
60924: ARRAY
60925: PUSH
60926: LD_VAR 0 1
60930: DIFF
60931: PPUSH
60932: CALL_OW 1
60936: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60937: LD_VAR 0 1
60941: PUSH
60942: LD_EXP 122
60946: PUSH
60947: LD_VAR 0 5
60951: ARRAY
60952: IN
60953: IFFALSE 60992
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60955: LD_ADDR_EXP 122
60959: PUSH
60960: LD_EXP 122
60964: PPUSH
60965: LD_VAR 0 5
60969: PPUSH
60970: LD_EXP 122
60974: PUSH
60975: LD_VAR 0 5
60979: ARRAY
60980: PUSH
60981: LD_VAR 0 1
60985: DIFF
60986: PPUSH
60987: CALL_OW 1
60991: ST_TO_ADDR
// break ;
60992: GO 60996
// end ;
60994: GO 60814
60996: POP
60997: POP
// end ;
60998: LD_VAR 0 4
61002: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61003: LD_INT 0
61005: PPUSH
61006: PPUSH
61007: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61008: LD_EXP 113
61012: NOT
61013: PUSH
61014: LD_EXP 111
61018: NOT
61019: OR
61020: PUSH
61021: LD_VAR 0 3
61025: PUSH
61026: LD_EXP 139
61030: IN
61031: NOT
61032: OR
61033: IFFALSE 61037
// exit ;
61035: GO 61160
// for i = 1 to mc_vehicles do
61037: LD_ADDR_VAR 0 6
61041: PUSH
61042: DOUBLE
61043: LD_INT 1
61045: DEC
61046: ST_TO_ADDR
61047: LD_EXP 132
61051: PUSH
61052: FOR_TO
61053: IFFALSE 61158
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61055: LD_VAR 0 2
61059: PUSH
61060: LD_EXP 132
61064: PUSH
61065: LD_VAR 0 6
61069: ARRAY
61070: IN
61071: PUSH
61072: LD_VAR 0 1
61076: PUSH
61077: LD_EXP 132
61081: PUSH
61082: LD_VAR 0 6
61086: ARRAY
61087: IN
61088: OR
61089: IFFALSE 61156
// begin tmp := mc_vehicles [ i ] diff old ;
61091: LD_ADDR_VAR 0 7
61095: PUSH
61096: LD_EXP 132
61100: PUSH
61101: LD_VAR 0 6
61105: ARRAY
61106: PUSH
61107: LD_VAR 0 2
61111: DIFF
61112: ST_TO_ADDR
// tmp := tmp diff new ;
61113: LD_ADDR_VAR 0 7
61117: PUSH
61118: LD_VAR 0 7
61122: PUSH
61123: LD_VAR 0 1
61127: DIFF
61128: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61129: LD_ADDR_EXP 132
61133: PUSH
61134: LD_EXP 132
61138: PPUSH
61139: LD_VAR 0 6
61143: PPUSH
61144: LD_VAR 0 7
61148: PPUSH
61149: CALL_OW 1
61153: ST_TO_ADDR
// break ;
61154: GO 61158
// end ;
61156: GO 61052
61158: POP
61159: POP
// end ;
61160: LD_VAR 0 5
61164: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61165: LD_INT 0
61167: PPUSH
61168: PPUSH
61169: PPUSH
61170: PPUSH
// if not mc_bases or not skirmish then
61171: LD_EXP 113
61175: NOT
61176: PUSH
61177: LD_EXP 111
61181: NOT
61182: OR
61183: IFFALSE 61187
// exit ;
61185: GO 61570
// side := GetSide ( vehicle ) ;
61187: LD_ADDR_VAR 0 5
61191: PUSH
61192: LD_VAR 0 1
61196: PPUSH
61197: CALL_OW 255
61201: ST_TO_ADDR
// for i = 1 to mc_bases do
61202: LD_ADDR_VAR 0 4
61206: PUSH
61207: DOUBLE
61208: LD_INT 1
61210: DEC
61211: ST_TO_ADDR
61212: LD_EXP 113
61216: PUSH
61217: FOR_TO
61218: IFFALSE 61568
// begin if factory in mc_bases [ i ] then
61220: LD_VAR 0 2
61224: PUSH
61225: LD_EXP 113
61229: PUSH
61230: LD_VAR 0 4
61234: ARRAY
61235: IN
61236: IFFALSE 61566
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61238: LD_EXP 135
61242: PUSH
61243: LD_VAR 0 4
61247: ARRAY
61248: PUSH
61249: LD_EXP 124
61253: PUSH
61254: LD_VAR 0 4
61258: ARRAY
61259: LESS
61260: PUSH
61261: LD_VAR 0 1
61265: PPUSH
61266: CALL_OW 264
61270: PUSH
61271: LD_INT 31
61273: PUSH
61274: LD_INT 32
61276: PUSH
61277: LD_INT 51
61279: PUSH
61280: LD_EXP 96
61284: PUSH
61285: LD_INT 12
61287: PUSH
61288: LD_INT 30
61290: PUSH
61291: LD_EXP 95
61295: PUSH
61296: LD_INT 11
61298: PUSH
61299: LD_INT 53
61301: PUSH
61302: LD_INT 14
61304: PUSH
61305: LD_EXP 99
61309: PUSH
61310: LD_INT 29
61312: PUSH
61313: LD_EXP 97
61317: PUSH
61318: LD_INT 13
61320: PUSH
61321: LD_INT 52
61323: PUSH
61324: LD_EXP 101
61328: PUSH
61329: LD_INT 48
61331: PUSH
61332: LD_INT 8
61334: PUSH
61335: EMPTY
61336: LIST
61337: LIST
61338: LIST
61339: LIST
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: LIST
61345: LIST
61346: LIST
61347: LIST
61348: LIST
61349: LIST
61350: LIST
61351: LIST
61352: LIST
61353: LIST
61354: IN
61355: NOT
61356: AND
61357: IFFALSE 61405
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61359: LD_ADDR_EXP 135
61363: PUSH
61364: LD_EXP 135
61368: PPUSH
61369: LD_VAR 0 4
61373: PUSH
61374: LD_EXP 135
61378: PUSH
61379: LD_VAR 0 4
61383: ARRAY
61384: PUSH
61385: LD_INT 1
61387: PLUS
61388: PUSH
61389: EMPTY
61390: LIST
61391: LIST
61392: PPUSH
61393: LD_VAR 0 1
61397: PPUSH
61398: CALL 70157 0 3
61402: ST_TO_ADDR
61403: GO 61449
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61405: LD_ADDR_EXP 132
61409: PUSH
61410: LD_EXP 132
61414: PPUSH
61415: LD_VAR 0 4
61419: PUSH
61420: LD_EXP 132
61424: PUSH
61425: LD_VAR 0 4
61429: ARRAY
61430: PUSH
61431: LD_INT 1
61433: PLUS
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: PPUSH
61439: LD_VAR 0 1
61443: PPUSH
61444: CALL 70157 0 3
61448: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61449: LD_VAR 0 1
61453: PPUSH
61454: CALL_OW 263
61458: PUSH
61459: LD_INT 2
61461: EQUAL
61462: IFFALSE 61482
// begin repeat wait ( 0 0$1 ) ;
61464: LD_INT 35
61466: PPUSH
61467: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61471: LD_VAR 0 1
61475: PPUSH
61476: CALL_OW 312
61480: IFFALSE 61464
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61482: LD_VAR 0 1
61486: PPUSH
61487: LD_EXP 137
61491: PUSH
61492: LD_VAR 0 4
61496: ARRAY
61497: PPUSH
61498: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61502: LD_VAR 0 1
61506: PPUSH
61507: CALL_OW 263
61511: PUSH
61512: LD_INT 1
61514: NONEQUAL
61515: IFFALSE 61519
// break ;
61517: GO 61568
// repeat wait ( 0 0$1 ) ;
61519: LD_INT 35
61521: PPUSH
61522: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61526: LD_VAR 0 1
61530: PPUSH
61531: LD_EXP 137
61535: PUSH
61536: LD_VAR 0 4
61540: ARRAY
61541: PPUSH
61542: CALL_OW 308
61546: IFFALSE 61519
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61548: LD_VAR 0 1
61552: PPUSH
61553: CALL_OW 311
61557: PPUSH
61558: CALL_OW 121
// exit ;
61562: POP
61563: POP
61564: GO 61570
// end ; end ;
61566: GO 61217
61568: POP
61569: POP
// end ;
61570: LD_VAR 0 3
61574: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61575: LD_INT 0
61577: PPUSH
61578: PPUSH
61579: PPUSH
61580: PPUSH
// if not mc_bases or not skirmish then
61581: LD_EXP 113
61585: NOT
61586: PUSH
61587: LD_EXP 111
61591: NOT
61592: OR
61593: IFFALSE 61597
// exit ;
61595: GO 61950
// repeat wait ( 0 0$1 ) ;
61597: LD_INT 35
61599: PPUSH
61600: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61604: LD_VAR 0 2
61608: PPUSH
61609: LD_VAR 0 3
61613: PPUSH
61614: CALL_OW 284
61618: IFFALSE 61597
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61620: LD_VAR 0 2
61624: PPUSH
61625: LD_VAR 0 3
61629: PPUSH
61630: CALL_OW 283
61634: PUSH
61635: LD_INT 4
61637: EQUAL
61638: IFFALSE 61642
// exit ;
61640: GO 61950
// for i = 1 to mc_bases do
61642: LD_ADDR_VAR 0 7
61646: PUSH
61647: DOUBLE
61648: LD_INT 1
61650: DEC
61651: ST_TO_ADDR
61652: LD_EXP 113
61656: PUSH
61657: FOR_TO
61658: IFFALSE 61948
// begin if mc_crates_area [ i ] then
61660: LD_EXP 131
61664: PUSH
61665: LD_VAR 0 7
61669: ARRAY
61670: IFFALSE 61781
// for j in mc_crates_area [ i ] do
61672: LD_ADDR_VAR 0 8
61676: PUSH
61677: LD_EXP 131
61681: PUSH
61682: LD_VAR 0 7
61686: ARRAY
61687: PUSH
61688: FOR_IN
61689: IFFALSE 61779
// if InArea ( x , y , j ) then
61691: LD_VAR 0 2
61695: PPUSH
61696: LD_VAR 0 3
61700: PPUSH
61701: LD_VAR 0 8
61705: PPUSH
61706: CALL_OW 309
61710: IFFALSE 61777
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61712: LD_ADDR_EXP 129
61716: PUSH
61717: LD_EXP 129
61721: PPUSH
61722: LD_VAR 0 7
61726: PUSH
61727: LD_EXP 129
61731: PUSH
61732: LD_VAR 0 7
61736: ARRAY
61737: PUSH
61738: LD_INT 1
61740: PLUS
61741: PUSH
61742: EMPTY
61743: LIST
61744: LIST
61745: PPUSH
61746: LD_VAR 0 4
61750: PUSH
61751: LD_VAR 0 2
61755: PUSH
61756: LD_VAR 0 3
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: LIST
61765: PPUSH
61766: CALL 70157 0 3
61770: ST_TO_ADDR
// exit ;
61771: POP
61772: POP
61773: POP
61774: POP
61775: GO 61950
// end ;
61777: GO 61688
61779: POP
61780: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61781: LD_ADDR_VAR 0 9
61785: PUSH
61786: LD_EXP 113
61790: PUSH
61791: LD_VAR 0 7
61795: ARRAY
61796: PPUSH
61797: LD_INT 2
61799: PUSH
61800: LD_INT 30
61802: PUSH
61803: LD_INT 0
61805: PUSH
61806: EMPTY
61807: LIST
61808: LIST
61809: PUSH
61810: LD_INT 30
61812: PUSH
61813: LD_INT 1
61815: PUSH
61816: EMPTY
61817: LIST
61818: LIST
61819: PUSH
61820: EMPTY
61821: LIST
61822: LIST
61823: LIST
61824: PPUSH
61825: CALL_OW 72
61829: ST_TO_ADDR
// if not depot then
61830: LD_VAR 0 9
61834: NOT
61835: IFFALSE 61839
// continue ;
61837: GO 61657
// for j in depot do
61839: LD_ADDR_VAR 0 8
61843: PUSH
61844: LD_VAR 0 9
61848: PUSH
61849: FOR_IN
61850: IFFALSE 61944
// if GetDistUnitXY ( j , x , y ) < 30 then
61852: LD_VAR 0 8
61856: PPUSH
61857: LD_VAR 0 2
61861: PPUSH
61862: LD_VAR 0 3
61866: PPUSH
61867: CALL_OW 297
61871: PUSH
61872: LD_INT 30
61874: LESS
61875: IFFALSE 61942
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61877: LD_ADDR_EXP 129
61881: PUSH
61882: LD_EXP 129
61886: PPUSH
61887: LD_VAR 0 7
61891: PUSH
61892: LD_EXP 129
61896: PUSH
61897: LD_VAR 0 7
61901: ARRAY
61902: PUSH
61903: LD_INT 1
61905: PLUS
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: PPUSH
61911: LD_VAR 0 4
61915: PUSH
61916: LD_VAR 0 2
61920: PUSH
61921: LD_VAR 0 3
61925: PUSH
61926: EMPTY
61927: LIST
61928: LIST
61929: LIST
61930: PPUSH
61931: CALL 70157 0 3
61935: ST_TO_ADDR
// exit ;
61936: POP
61937: POP
61938: POP
61939: POP
61940: GO 61950
// end ;
61942: GO 61849
61944: POP
61945: POP
// end ;
61946: GO 61657
61948: POP
61949: POP
// end ;
61950: LD_VAR 0 6
61954: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61955: LD_INT 0
61957: PPUSH
61958: PPUSH
61959: PPUSH
61960: PPUSH
// if not mc_bases or not skirmish then
61961: LD_EXP 113
61965: NOT
61966: PUSH
61967: LD_EXP 111
61971: NOT
61972: OR
61973: IFFALSE 61977
// exit ;
61975: GO 62254
// side := GetSide ( lab ) ;
61977: LD_ADDR_VAR 0 4
61981: PUSH
61982: LD_VAR 0 2
61986: PPUSH
61987: CALL_OW 255
61991: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61992: LD_VAR 0 4
61996: PUSH
61997: LD_EXP 139
62001: IN
62002: NOT
62003: PUSH
62004: LD_EXP 140
62008: NOT
62009: OR
62010: PUSH
62011: LD_EXP 113
62015: NOT
62016: OR
62017: IFFALSE 62021
// exit ;
62019: GO 62254
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62021: LD_ADDR_EXP 140
62025: PUSH
62026: LD_EXP 140
62030: PPUSH
62031: LD_VAR 0 4
62035: PPUSH
62036: LD_EXP 140
62040: PUSH
62041: LD_VAR 0 4
62045: ARRAY
62046: PUSH
62047: LD_VAR 0 1
62051: DIFF
62052: PPUSH
62053: CALL_OW 1
62057: ST_TO_ADDR
// for i = 1 to mc_bases do
62058: LD_ADDR_VAR 0 5
62062: PUSH
62063: DOUBLE
62064: LD_INT 1
62066: DEC
62067: ST_TO_ADDR
62068: LD_EXP 113
62072: PUSH
62073: FOR_TO
62074: IFFALSE 62252
// begin if lab in mc_bases [ i ] then
62076: LD_VAR 0 2
62080: PUSH
62081: LD_EXP 113
62085: PUSH
62086: LD_VAR 0 5
62090: ARRAY
62091: IN
62092: IFFALSE 62250
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62094: LD_VAR 0 1
62098: PUSH
62099: LD_INT 11
62101: PUSH
62102: LD_INT 4
62104: PUSH
62105: LD_INT 3
62107: PUSH
62108: LD_INT 2
62110: PUSH
62111: EMPTY
62112: LIST
62113: LIST
62114: LIST
62115: LIST
62116: IN
62117: PUSH
62118: LD_EXP 143
62122: PUSH
62123: LD_VAR 0 5
62127: ARRAY
62128: AND
62129: IFFALSE 62250
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62131: LD_ADDR_VAR 0 6
62135: PUSH
62136: LD_EXP 143
62140: PUSH
62141: LD_VAR 0 5
62145: ARRAY
62146: PUSH
62147: LD_INT 1
62149: ARRAY
62150: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62151: LD_ADDR_EXP 143
62155: PUSH
62156: LD_EXP 143
62160: PPUSH
62161: LD_VAR 0 5
62165: PPUSH
62166: EMPTY
62167: PPUSH
62168: CALL_OW 1
62172: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62173: LD_VAR 0 6
62177: PPUSH
62178: LD_INT 0
62180: PPUSH
62181: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62185: LD_VAR 0 6
62189: PPUSH
62190: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62194: LD_ADDR_EXP 142
62198: PUSH
62199: LD_EXP 142
62203: PPUSH
62204: LD_VAR 0 5
62208: PPUSH
62209: LD_EXP 142
62213: PUSH
62214: LD_VAR 0 5
62218: ARRAY
62219: PPUSH
62220: LD_INT 1
62222: PPUSH
62223: LD_VAR 0 6
62227: PPUSH
62228: CALL_OW 2
62232: PPUSH
62233: CALL_OW 1
62237: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62238: LD_VAR 0 5
62242: PPUSH
62243: LD_INT 112
62245: PPUSH
62246: CALL 39199 0 2
// end ; end ; end ;
62250: GO 62073
62252: POP
62253: POP
// end ;
62254: LD_VAR 0 3
62258: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62259: LD_INT 0
62261: PPUSH
62262: PPUSH
62263: PPUSH
62264: PPUSH
62265: PPUSH
62266: PPUSH
62267: PPUSH
62268: PPUSH
// if not mc_bases or not skirmish then
62269: LD_EXP 113
62273: NOT
62274: PUSH
62275: LD_EXP 111
62279: NOT
62280: OR
62281: IFFALSE 62285
// exit ;
62283: GO 63656
// for i = 1 to mc_bases do
62285: LD_ADDR_VAR 0 3
62289: PUSH
62290: DOUBLE
62291: LD_INT 1
62293: DEC
62294: ST_TO_ADDR
62295: LD_EXP 113
62299: PUSH
62300: FOR_TO
62301: IFFALSE 63654
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62303: LD_VAR 0 1
62307: PUSH
62308: LD_EXP 113
62312: PUSH
62313: LD_VAR 0 3
62317: ARRAY
62318: IN
62319: PUSH
62320: LD_VAR 0 1
62324: PUSH
62325: LD_EXP 120
62329: PUSH
62330: LD_VAR 0 3
62334: ARRAY
62335: IN
62336: OR
62337: PUSH
62338: LD_VAR 0 1
62342: PUSH
62343: LD_EXP 135
62347: PUSH
62348: LD_VAR 0 3
62352: ARRAY
62353: IN
62354: OR
62355: PUSH
62356: LD_VAR 0 1
62360: PUSH
62361: LD_EXP 132
62365: PUSH
62366: LD_VAR 0 3
62370: ARRAY
62371: IN
62372: OR
62373: PUSH
62374: LD_VAR 0 1
62378: PUSH
62379: LD_EXP 142
62383: PUSH
62384: LD_VAR 0 3
62388: ARRAY
62389: IN
62390: OR
62391: PUSH
62392: LD_VAR 0 1
62396: PUSH
62397: LD_EXP 143
62401: PUSH
62402: LD_VAR 0 3
62406: ARRAY
62407: IN
62408: OR
62409: IFFALSE 63652
// begin if un in mc_ape [ i ] then
62411: LD_VAR 0 1
62415: PUSH
62416: LD_EXP 142
62420: PUSH
62421: LD_VAR 0 3
62425: ARRAY
62426: IN
62427: IFFALSE 62466
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62429: LD_ADDR_EXP 142
62433: PUSH
62434: LD_EXP 142
62438: PPUSH
62439: LD_VAR 0 3
62443: PPUSH
62444: LD_EXP 142
62448: PUSH
62449: LD_VAR 0 3
62453: ARRAY
62454: PUSH
62455: LD_VAR 0 1
62459: DIFF
62460: PPUSH
62461: CALL_OW 1
62465: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62466: LD_VAR 0 1
62470: PUSH
62471: LD_EXP 143
62475: PUSH
62476: LD_VAR 0 3
62480: ARRAY
62481: IN
62482: IFFALSE 62506
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62484: LD_ADDR_EXP 143
62488: PUSH
62489: LD_EXP 143
62493: PPUSH
62494: LD_VAR 0 3
62498: PPUSH
62499: EMPTY
62500: PPUSH
62501: CALL_OW 1
62505: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62506: LD_VAR 0 1
62510: PPUSH
62511: CALL_OW 247
62515: PUSH
62516: LD_INT 2
62518: EQUAL
62519: PUSH
62520: LD_VAR 0 1
62524: PPUSH
62525: CALL_OW 110
62529: PUSH
62530: LD_INT 20
62532: EQUAL
62533: PUSH
62534: LD_VAR 0 1
62538: PUSH
62539: LD_EXP 135
62543: PUSH
62544: LD_VAR 0 3
62548: ARRAY
62549: IN
62550: OR
62551: PUSH
62552: LD_VAR 0 1
62556: PPUSH
62557: CALL_OW 264
62561: PUSH
62562: LD_INT 12
62564: PUSH
62565: LD_INT 51
62567: PUSH
62568: LD_EXP 96
62572: PUSH
62573: LD_INT 32
62575: PUSH
62576: LD_INT 13
62578: PUSH
62579: LD_INT 52
62581: PUSH
62582: LD_INT 31
62584: PUSH
62585: EMPTY
62586: LIST
62587: LIST
62588: LIST
62589: LIST
62590: LIST
62591: LIST
62592: LIST
62593: IN
62594: OR
62595: AND
62596: IFFALSE 62904
// begin if un in mc_defender [ i ] then
62598: LD_VAR 0 1
62602: PUSH
62603: LD_EXP 135
62607: PUSH
62608: LD_VAR 0 3
62612: ARRAY
62613: IN
62614: IFFALSE 62653
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62616: LD_ADDR_EXP 135
62620: PUSH
62621: LD_EXP 135
62625: PPUSH
62626: LD_VAR 0 3
62630: PPUSH
62631: LD_EXP 135
62635: PUSH
62636: LD_VAR 0 3
62640: ARRAY
62641: PUSH
62642: LD_VAR 0 1
62646: DIFF
62647: PPUSH
62648: CALL_OW 1
62652: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62653: LD_ADDR_VAR 0 8
62657: PUSH
62658: LD_VAR 0 3
62662: PPUSH
62663: LD_INT 3
62665: PPUSH
62666: CALL 59303 0 2
62670: ST_TO_ADDR
// if fac then
62671: LD_VAR 0 8
62675: IFFALSE 62904
// begin for j in fac do
62677: LD_ADDR_VAR 0 4
62681: PUSH
62682: LD_VAR 0 8
62686: PUSH
62687: FOR_IN
62688: IFFALSE 62902
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62690: LD_ADDR_VAR 0 9
62694: PUSH
62695: LD_VAR 0 8
62699: PPUSH
62700: LD_VAR 0 1
62704: PPUSH
62705: CALL_OW 265
62709: PPUSH
62710: LD_VAR 0 1
62714: PPUSH
62715: CALL_OW 262
62719: PPUSH
62720: LD_VAR 0 1
62724: PPUSH
62725: CALL_OW 263
62729: PPUSH
62730: LD_VAR 0 1
62734: PPUSH
62735: CALL_OW 264
62739: PPUSH
62740: CALL 67689 0 5
62744: ST_TO_ADDR
// if components then
62745: LD_VAR 0 9
62749: IFFALSE 62900
// begin if GetWeapon ( un ) = ar_control_tower then
62751: LD_VAR 0 1
62755: PPUSH
62756: CALL_OW 264
62760: PUSH
62761: LD_INT 31
62763: EQUAL
62764: IFFALSE 62881
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62766: LD_VAR 0 1
62770: PPUSH
62771: CALL_OW 311
62775: PPUSH
62776: LD_INT 0
62778: PPUSH
62779: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62783: LD_ADDR_EXP 153
62787: PUSH
62788: LD_EXP 153
62792: PPUSH
62793: LD_VAR 0 3
62797: PPUSH
62798: LD_EXP 153
62802: PUSH
62803: LD_VAR 0 3
62807: ARRAY
62808: PUSH
62809: LD_VAR 0 1
62813: PPUSH
62814: CALL_OW 311
62818: DIFF
62819: PPUSH
62820: CALL_OW 1
62824: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62825: LD_ADDR_VAR 0 7
62829: PUSH
62830: LD_EXP 134
62834: PUSH
62835: LD_VAR 0 3
62839: ARRAY
62840: PPUSH
62841: LD_INT 1
62843: PPUSH
62844: LD_VAR 0 9
62848: PPUSH
62849: CALL_OW 2
62853: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62854: LD_ADDR_EXP 134
62858: PUSH
62859: LD_EXP 134
62863: PPUSH
62864: LD_VAR 0 3
62868: PPUSH
62869: LD_VAR 0 7
62873: PPUSH
62874: CALL_OW 1
62878: ST_TO_ADDR
// end else
62879: GO 62898
// MC_InsertProduceList ( i , [ components ] ) ;
62881: LD_VAR 0 3
62885: PPUSH
62886: LD_VAR 0 9
62890: PUSH
62891: EMPTY
62892: LIST
62893: PPUSH
62894: CALL 58848 0 2
// break ;
62898: GO 62902
// end ; end ;
62900: GO 62687
62902: POP
62903: POP
// end ; end ; if GetType ( un ) = unit_building then
62904: LD_VAR 0 1
62908: PPUSH
62909: CALL_OW 247
62913: PUSH
62914: LD_INT 3
62916: EQUAL
62917: IFFALSE 63320
// begin btype := GetBType ( un ) ;
62919: LD_ADDR_VAR 0 5
62923: PUSH
62924: LD_VAR 0 1
62928: PPUSH
62929: CALL_OW 266
62933: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62934: LD_VAR 0 5
62938: PUSH
62939: LD_INT 29
62941: PUSH
62942: LD_INT 30
62944: PUSH
62945: EMPTY
62946: LIST
62947: LIST
62948: IN
62949: IFFALSE 63022
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62951: LD_VAR 0 1
62955: PPUSH
62956: CALL_OW 250
62960: PPUSH
62961: LD_VAR 0 1
62965: PPUSH
62966: CALL_OW 251
62970: PPUSH
62971: LD_VAR 0 1
62975: PPUSH
62976: CALL_OW 255
62980: PPUSH
62981: CALL_OW 440
62985: NOT
62986: IFFALSE 63022
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62988: LD_VAR 0 1
62992: PPUSH
62993: CALL_OW 250
62997: PPUSH
62998: LD_VAR 0 1
63002: PPUSH
63003: CALL_OW 251
63007: PPUSH
63008: LD_VAR 0 1
63012: PPUSH
63013: CALL_OW 255
63017: PPUSH
63018: CALL_OW 441
// end ; if btype = b_warehouse then
63022: LD_VAR 0 5
63026: PUSH
63027: LD_INT 1
63029: EQUAL
63030: IFFALSE 63048
// begin btype := b_depot ;
63032: LD_ADDR_VAR 0 5
63036: PUSH
63037: LD_INT 0
63039: ST_TO_ADDR
// pos := 1 ;
63040: LD_ADDR_VAR 0 6
63044: PUSH
63045: LD_INT 1
63047: ST_TO_ADDR
// end ; if btype = b_factory then
63048: LD_VAR 0 5
63052: PUSH
63053: LD_INT 3
63055: EQUAL
63056: IFFALSE 63074
// begin btype := b_workshop ;
63058: LD_ADDR_VAR 0 5
63062: PUSH
63063: LD_INT 2
63065: ST_TO_ADDR
// pos := 1 ;
63066: LD_ADDR_VAR 0 6
63070: PUSH
63071: LD_INT 1
63073: ST_TO_ADDR
// end ; if btype = b_barracks then
63074: LD_VAR 0 5
63078: PUSH
63079: LD_INT 5
63081: EQUAL
63082: IFFALSE 63092
// btype := b_armoury ;
63084: LD_ADDR_VAR 0 5
63088: PUSH
63089: LD_INT 4
63091: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63092: LD_VAR 0 5
63096: PUSH
63097: LD_INT 7
63099: PUSH
63100: LD_INT 8
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: IN
63107: IFFALSE 63117
// btype := b_lab ;
63109: LD_ADDR_VAR 0 5
63113: PUSH
63114: LD_INT 6
63116: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63117: LD_ADDR_EXP 118
63121: PUSH
63122: LD_EXP 118
63126: PPUSH
63127: LD_VAR 0 3
63131: PUSH
63132: LD_EXP 118
63136: PUSH
63137: LD_VAR 0 3
63141: ARRAY
63142: PUSH
63143: LD_INT 1
63145: PLUS
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PPUSH
63151: LD_VAR 0 5
63155: PUSH
63156: LD_VAR 0 1
63160: PPUSH
63161: CALL_OW 250
63165: PUSH
63166: LD_VAR 0 1
63170: PPUSH
63171: CALL_OW 251
63175: PUSH
63176: LD_VAR 0 1
63180: PPUSH
63181: CALL_OW 254
63185: PUSH
63186: EMPTY
63187: LIST
63188: LIST
63189: LIST
63190: LIST
63191: PPUSH
63192: CALL 70157 0 3
63196: ST_TO_ADDR
// if pos = 1 then
63197: LD_VAR 0 6
63201: PUSH
63202: LD_INT 1
63204: EQUAL
63205: IFFALSE 63320
// begin tmp := mc_build_list [ i ] ;
63207: LD_ADDR_VAR 0 7
63211: PUSH
63212: LD_EXP 118
63216: PUSH
63217: LD_VAR 0 3
63221: ARRAY
63222: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63223: LD_VAR 0 7
63227: PPUSH
63228: LD_INT 2
63230: PUSH
63231: LD_INT 30
63233: PUSH
63234: LD_INT 0
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: PUSH
63241: LD_INT 30
63243: PUSH
63244: LD_INT 1
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: LIST
63255: PPUSH
63256: CALL_OW 72
63260: IFFALSE 63270
// pos := 2 ;
63262: LD_ADDR_VAR 0 6
63266: PUSH
63267: LD_INT 2
63269: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63270: LD_ADDR_VAR 0 7
63274: PUSH
63275: LD_VAR 0 7
63279: PPUSH
63280: LD_VAR 0 6
63284: PPUSH
63285: LD_VAR 0 7
63289: PPUSH
63290: CALL 70483 0 3
63294: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63295: LD_ADDR_EXP 118
63299: PUSH
63300: LD_EXP 118
63304: PPUSH
63305: LD_VAR 0 3
63309: PPUSH
63310: LD_VAR 0 7
63314: PPUSH
63315: CALL_OW 1
63319: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63320: LD_VAR 0 1
63324: PUSH
63325: LD_EXP 113
63329: PUSH
63330: LD_VAR 0 3
63334: ARRAY
63335: IN
63336: IFFALSE 63375
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63338: LD_ADDR_EXP 113
63342: PUSH
63343: LD_EXP 113
63347: PPUSH
63348: LD_VAR 0 3
63352: PPUSH
63353: LD_EXP 113
63357: PUSH
63358: LD_VAR 0 3
63362: ARRAY
63363: PUSH
63364: LD_VAR 0 1
63368: DIFF
63369: PPUSH
63370: CALL_OW 1
63374: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63375: LD_VAR 0 1
63379: PUSH
63380: LD_EXP 120
63384: PUSH
63385: LD_VAR 0 3
63389: ARRAY
63390: IN
63391: IFFALSE 63430
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63393: LD_ADDR_EXP 120
63397: PUSH
63398: LD_EXP 120
63402: PPUSH
63403: LD_VAR 0 3
63407: PPUSH
63408: LD_EXP 120
63412: PUSH
63413: LD_VAR 0 3
63417: ARRAY
63418: PUSH
63419: LD_VAR 0 1
63423: DIFF
63424: PPUSH
63425: CALL_OW 1
63429: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63430: LD_VAR 0 1
63434: PUSH
63435: LD_EXP 132
63439: PUSH
63440: LD_VAR 0 3
63444: ARRAY
63445: IN
63446: IFFALSE 63485
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63448: LD_ADDR_EXP 132
63452: PUSH
63453: LD_EXP 132
63457: PPUSH
63458: LD_VAR 0 3
63462: PPUSH
63463: LD_EXP 132
63467: PUSH
63468: LD_VAR 0 3
63472: ARRAY
63473: PUSH
63474: LD_VAR 0 1
63478: DIFF
63479: PPUSH
63480: CALL_OW 1
63484: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63485: LD_VAR 0 1
63489: PUSH
63490: LD_EXP 135
63494: PUSH
63495: LD_VAR 0 3
63499: ARRAY
63500: IN
63501: IFFALSE 63540
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63503: LD_ADDR_EXP 135
63507: PUSH
63508: LD_EXP 135
63512: PPUSH
63513: LD_VAR 0 3
63517: PPUSH
63518: LD_EXP 135
63522: PUSH
63523: LD_VAR 0 3
63527: ARRAY
63528: PUSH
63529: LD_VAR 0 1
63533: DIFF
63534: PPUSH
63535: CALL_OW 1
63539: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63540: LD_VAR 0 1
63544: PUSH
63545: LD_EXP 122
63549: PUSH
63550: LD_VAR 0 3
63554: ARRAY
63555: IN
63556: IFFALSE 63595
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63558: LD_ADDR_EXP 122
63562: PUSH
63563: LD_EXP 122
63567: PPUSH
63568: LD_VAR 0 3
63572: PPUSH
63573: LD_EXP 122
63577: PUSH
63578: LD_VAR 0 3
63582: ARRAY
63583: PUSH
63584: LD_VAR 0 1
63588: DIFF
63589: PPUSH
63590: CALL_OW 1
63594: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63595: LD_VAR 0 1
63599: PUSH
63600: LD_EXP 121
63604: PUSH
63605: LD_VAR 0 3
63609: ARRAY
63610: IN
63611: IFFALSE 63650
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63613: LD_ADDR_EXP 121
63617: PUSH
63618: LD_EXP 121
63622: PPUSH
63623: LD_VAR 0 3
63627: PPUSH
63628: LD_EXP 121
63632: PUSH
63633: LD_VAR 0 3
63637: ARRAY
63638: PUSH
63639: LD_VAR 0 1
63643: DIFF
63644: PPUSH
63645: CALL_OW 1
63649: ST_TO_ADDR
// end ; break ;
63650: GO 63654
// end ;
63652: GO 62300
63654: POP
63655: POP
// end ;
63656: LD_VAR 0 2
63660: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63661: LD_INT 0
63663: PPUSH
63664: PPUSH
63665: PPUSH
// if not mc_bases or not skirmish then
63666: LD_EXP 113
63670: NOT
63671: PUSH
63672: LD_EXP 111
63676: NOT
63677: OR
63678: IFFALSE 63682
// exit ;
63680: GO 63897
// for i = 1 to mc_bases do
63682: LD_ADDR_VAR 0 3
63686: PUSH
63687: DOUBLE
63688: LD_INT 1
63690: DEC
63691: ST_TO_ADDR
63692: LD_EXP 113
63696: PUSH
63697: FOR_TO
63698: IFFALSE 63895
// begin if building in mc_construct_list [ i ] then
63700: LD_VAR 0 1
63704: PUSH
63705: LD_EXP 120
63709: PUSH
63710: LD_VAR 0 3
63714: ARRAY
63715: IN
63716: IFFALSE 63893
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63718: LD_ADDR_EXP 120
63722: PUSH
63723: LD_EXP 120
63727: PPUSH
63728: LD_VAR 0 3
63732: PPUSH
63733: LD_EXP 120
63737: PUSH
63738: LD_VAR 0 3
63742: ARRAY
63743: PUSH
63744: LD_VAR 0 1
63748: DIFF
63749: PPUSH
63750: CALL_OW 1
63754: ST_TO_ADDR
// if building in mc_lab [ i ] then
63755: LD_VAR 0 1
63759: PUSH
63760: LD_EXP 146
63764: PUSH
63765: LD_VAR 0 3
63769: ARRAY
63770: IN
63771: IFFALSE 63826
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63773: LD_ADDR_EXP 147
63777: PUSH
63778: LD_EXP 147
63782: PPUSH
63783: LD_VAR 0 3
63787: PPUSH
63788: LD_EXP 147
63792: PUSH
63793: LD_VAR 0 3
63797: ARRAY
63798: PPUSH
63799: LD_INT 1
63801: PPUSH
63802: LD_EXP 147
63806: PUSH
63807: LD_VAR 0 3
63811: ARRAY
63812: PPUSH
63813: LD_INT 0
63815: PPUSH
63816: CALL 69575 0 4
63820: PPUSH
63821: CALL_OW 1
63825: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63826: LD_VAR 0 1
63830: PUSH
63831: LD_EXP 113
63835: PUSH
63836: LD_VAR 0 3
63840: ARRAY
63841: IN
63842: NOT
63843: IFFALSE 63889
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63845: LD_ADDR_EXP 113
63849: PUSH
63850: LD_EXP 113
63854: PPUSH
63855: LD_VAR 0 3
63859: PUSH
63860: LD_EXP 113
63864: PUSH
63865: LD_VAR 0 3
63869: ARRAY
63870: PUSH
63871: LD_INT 1
63873: PLUS
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PPUSH
63879: LD_VAR 0 1
63883: PPUSH
63884: CALL 70157 0 3
63888: ST_TO_ADDR
// exit ;
63889: POP
63890: POP
63891: GO 63897
// end ; end ;
63893: GO 63697
63895: POP
63896: POP
// end ;
63897: LD_VAR 0 2
63901: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63902: LD_INT 0
63904: PPUSH
63905: PPUSH
63906: PPUSH
63907: PPUSH
63908: PPUSH
63909: PPUSH
63910: PPUSH
// if not mc_bases or not skirmish then
63911: LD_EXP 113
63915: NOT
63916: PUSH
63917: LD_EXP 111
63921: NOT
63922: OR
63923: IFFALSE 63927
// exit ;
63925: GO 64588
// for i = 1 to mc_bases do
63927: LD_ADDR_VAR 0 3
63931: PUSH
63932: DOUBLE
63933: LD_INT 1
63935: DEC
63936: ST_TO_ADDR
63937: LD_EXP 113
63941: PUSH
63942: FOR_TO
63943: IFFALSE 64586
// begin if building in mc_construct_list [ i ] then
63945: LD_VAR 0 1
63949: PUSH
63950: LD_EXP 120
63954: PUSH
63955: LD_VAR 0 3
63959: ARRAY
63960: IN
63961: IFFALSE 64584
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63963: LD_ADDR_EXP 120
63967: PUSH
63968: LD_EXP 120
63972: PPUSH
63973: LD_VAR 0 3
63977: PPUSH
63978: LD_EXP 120
63982: PUSH
63983: LD_VAR 0 3
63987: ARRAY
63988: PUSH
63989: LD_VAR 0 1
63993: DIFF
63994: PPUSH
63995: CALL_OW 1
63999: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64000: LD_ADDR_EXP 113
64004: PUSH
64005: LD_EXP 113
64009: PPUSH
64010: LD_VAR 0 3
64014: PUSH
64015: LD_EXP 113
64019: PUSH
64020: LD_VAR 0 3
64024: ARRAY
64025: PUSH
64026: LD_INT 1
64028: PLUS
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PPUSH
64034: LD_VAR 0 1
64038: PPUSH
64039: CALL 70157 0 3
64043: ST_TO_ADDR
// btype := GetBType ( building ) ;
64044: LD_ADDR_VAR 0 5
64048: PUSH
64049: LD_VAR 0 1
64053: PPUSH
64054: CALL_OW 266
64058: ST_TO_ADDR
// side := GetSide ( building ) ;
64059: LD_ADDR_VAR 0 8
64063: PUSH
64064: LD_VAR 0 1
64068: PPUSH
64069: CALL_OW 255
64073: ST_TO_ADDR
// if btype = b_lab then
64074: LD_VAR 0 5
64078: PUSH
64079: LD_INT 6
64081: EQUAL
64082: IFFALSE 64132
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64084: LD_ADDR_EXP 146
64088: PUSH
64089: LD_EXP 146
64093: PPUSH
64094: LD_VAR 0 3
64098: PUSH
64099: LD_EXP 146
64103: PUSH
64104: LD_VAR 0 3
64108: ARRAY
64109: PUSH
64110: LD_INT 1
64112: PLUS
64113: PUSH
64114: EMPTY
64115: LIST
64116: LIST
64117: PPUSH
64118: LD_VAR 0 1
64122: PPUSH
64123: CALL 70157 0 3
64127: ST_TO_ADDR
// exit ;
64128: POP
64129: POP
64130: GO 64588
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64132: LD_VAR 0 5
64136: PUSH
64137: LD_INT 0
64139: PUSH
64140: LD_INT 2
64142: PUSH
64143: LD_INT 4
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: LIST
64150: IN
64151: IFFALSE 64275
// begin if btype = b_armoury then
64153: LD_VAR 0 5
64157: PUSH
64158: LD_INT 4
64160: EQUAL
64161: IFFALSE 64171
// btype := b_barracks ;
64163: LD_ADDR_VAR 0 5
64167: PUSH
64168: LD_INT 5
64170: ST_TO_ADDR
// if btype = b_depot then
64171: LD_VAR 0 5
64175: PUSH
64176: LD_INT 0
64178: EQUAL
64179: IFFALSE 64189
// btype := b_warehouse ;
64181: LD_ADDR_VAR 0 5
64185: PUSH
64186: LD_INT 1
64188: ST_TO_ADDR
// if btype = b_workshop then
64189: LD_VAR 0 5
64193: PUSH
64194: LD_INT 2
64196: EQUAL
64197: IFFALSE 64207
// btype := b_factory ;
64199: LD_ADDR_VAR 0 5
64203: PUSH
64204: LD_INT 3
64206: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64207: LD_VAR 0 5
64211: PPUSH
64212: LD_VAR 0 8
64216: PPUSH
64217: CALL_OW 323
64221: PUSH
64222: LD_INT 1
64224: EQUAL
64225: IFFALSE 64271
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64227: LD_ADDR_EXP 145
64231: PUSH
64232: LD_EXP 145
64236: PPUSH
64237: LD_VAR 0 3
64241: PUSH
64242: LD_EXP 145
64246: PUSH
64247: LD_VAR 0 3
64251: ARRAY
64252: PUSH
64253: LD_INT 1
64255: PLUS
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PPUSH
64261: LD_VAR 0 1
64265: PPUSH
64266: CALL 70157 0 3
64270: ST_TO_ADDR
// exit ;
64271: POP
64272: POP
64273: GO 64588
// end ; if btype in [ b_bunker , b_turret ] then
64275: LD_VAR 0 5
64279: PUSH
64280: LD_INT 32
64282: PUSH
64283: LD_INT 33
64285: PUSH
64286: EMPTY
64287: LIST
64288: LIST
64289: IN
64290: IFFALSE 64580
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64292: LD_ADDR_EXP 121
64296: PUSH
64297: LD_EXP 121
64301: PPUSH
64302: LD_VAR 0 3
64306: PUSH
64307: LD_EXP 121
64311: PUSH
64312: LD_VAR 0 3
64316: ARRAY
64317: PUSH
64318: LD_INT 1
64320: PLUS
64321: PUSH
64322: EMPTY
64323: LIST
64324: LIST
64325: PPUSH
64326: LD_VAR 0 1
64330: PPUSH
64331: CALL 70157 0 3
64335: ST_TO_ADDR
// if btype = b_bunker then
64336: LD_VAR 0 5
64340: PUSH
64341: LD_INT 32
64343: EQUAL
64344: IFFALSE 64580
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64346: LD_ADDR_EXP 122
64350: PUSH
64351: LD_EXP 122
64355: PPUSH
64356: LD_VAR 0 3
64360: PUSH
64361: LD_EXP 122
64365: PUSH
64366: LD_VAR 0 3
64370: ARRAY
64371: PUSH
64372: LD_INT 1
64374: PLUS
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PPUSH
64380: LD_VAR 0 1
64384: PPUSH
64385: CALL 70157 0 3
64389: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64390: LD_ADDR_VAR 0 6
64394: PUSH
64395: LD_EXP 113
64399: PUSH
64400: LD_VAR 0 3
64404: ARRAY
64405: PPUSH
64406: LD_INT 25
64408: PUSH
64409: LD_INT 1
64411: PUSH
64412: EMPTY
64413: LIST
64414: LIST
64415: PUSH
64416: LD_INT 3
64418: PUSH
64419: LD_INT 54
64421: PUSH
64422: EMPTY
64423: LIST
64424: PUSH
64425: EMPTY
64426: LIST
64427: LIST
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PPUSH
64433: CALL_OW 72
64437: ST_TO_ADDR
// if tmp then
64438: LD_VAR 0 6
64442: IFFALSE 64448
// exit ;
64444: POP
64445: POP
64446: GO 64588
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64448: LD_ADDR_VAR 0 6
64452: PUSH
64453: LD_EXP 113
64457: PUSH
64458: LD_VAR 0 3
64462: ARRAY
64463: PPUSH
64464: LD_INT 2
64466: PUSH
64467: LD_INT 30
64469: PUSH
64470: LD_INT 4
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: PUSH
64477: LD_INT 30
64479: PUSH
64480: LD_INT 5
64482: PUSH
64483: EMPTY
64484: LIST
64485: LIST
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: LIST
64491: PPUSH
64492: CALL_OW 72
64496: ST_TO_ADDR
// if not tmp then
64497: LD_VAR 0 6
64501: NOT
64502: IFFALSE 64508
// exit ;
64504: POP
64505: POP
64506: GO 64588
// for j in tmp do
64508: LD_ADDR_VAR 0 4
64512: PUSH
64513: LD_VAR 0 6
64517: PUSH
64518: FOR_IN
64519: IFFALSE 64578
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64521: LD_ADDR_VAR 0 7
64525: PUSH
64526: LD_VAR 0 4
64530: PPUSH
64531: CALL_OW 313
64535: PPUSH
64536: LD_INT 25
64538: PUSH
64539: LD_INT 1
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PPUSH
64546: CALL_OW 72
64550: ST_TO_ADDR
// if units then
64551: LD_VAR 0 7
64555: IFFALSE 64576
// begin ComExitBuilding ( units [ 1 ] ) ;
64557: LD_VAR 0 7
64561: PUSH
64562: LD_INT 1
64564: ARRAY
64565: PPUSH
64566: CALL_OW 122
// exit ;
64570: POP
64571: POP
64572: POP
64573: POP
64574: GO 64588
// end ; end ;
64576: GO 64518
64578: POP
64579: POP
// end ; end ; exit ;
64580: POP
64581: POP
64582: GO 64588
// end ; end ;
64584: GO 63942
64586: POP
64587: POP
// end ;
64588: LD_VAR 0 2
64592: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64593: LD_INT 0
64595: PPUSH
64596: PPUSH
64597: PPUSH
64598: PPUSH
64599: PPUSH
64600: PPUSH
64601: PPUSH
// if not mc_bases or not skirmish then
64602: LD_EXP 113
64606: NOT
64607: PUSH
64608: LD_EXP 111
64612: NOT
64613: OR
64614: IFFALSE 64618
// exit ;
64616: GO 64849
// btype := GetBType ( building ) ;
64618: LD_ADDR_VAR 0 6
64622: PUSH
64623: LD_VAR 0 1
64627: PPUSH
64628: CALL_OW 266
64632: ST_TO_ADDR
// x := GetX ( building ) ;
64633: LD_ADDR_VAR 0 7
64637: PUSH
64638: LD_VAR 0 1
64642: PPUSH
64643: CALL_OW 250
64647: ST_TO_ADDR
// y := GetY ( building ) ;
64648: LD_ADDR_VAR 0 8
64652: PUSH
64653: LD_VAR 0 1
64657: PPUSH
64658: CALL_OW 251
64662: ST_TO_ADDR
// d := GetDir ( building ) ;
64663: LD_ADDR_VAR 0 9
64667: PUSH
64668: LD_VAR 0 1
64672: PPUSH
64673: CALL_OW 254
64677: ST_TO_ADDR
// for i = 1 to mc_bases do
64678: LD_ADDR_VAR 0 4
64682: PUSH
64683: DOUBLE
64684: LD_INT 1
64686: DEC
64687: ST_TO_ADDR
64688: LD_EXP 113
64692: PUSH
64693: FOR_TO
64694: IFFALSE 64847
// begin if not mc_build_list [ i ] then
64696: LD_EXP 118
64700: PUSH
64701: LD_VAR 0 4
64705: ARRAY
64706: NOT
64707: IFFALSE 64711
// continue ;
64709: GO 64693
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64711: LD_VAR 0 6
64715: PUSH
64716: LD_VAR 0 7
64720: PUSH
64721: LD_VAR 0 8
64725: PUSH
64726: LD_VAR 0 9
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: LIST
64735: LIST
64736: PPUSH
64737: LD_EXP 118
64741: PUSH
64742: LD_VAR 0 4
64746: ARRAY
64747: PUSH
64748: LD_INT 1
64750: ARRAY
64751: PPUSH
64752: CALL 76326 0 2
64756: IFFALSE 64845
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64758: LD_ADDR_EXP 118
64762: PUSH
64763: LD_EXP 118
64767: PPUSH
64768: LD_VAR 0 4
64772: PPUSH
64773: LD_EXP 118
64777: PUSH
64778: LD_VAR 0 4
64782: ARRAY
64783: PPUSH
64784: LD_INT 1
64786: PPUSH
64787: CALL_OW 3
64791: PPUSH
64792: CALL_OW 1
64796: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64797: LD_ADDR_EXP 120
64801: PUSH
64802: LD_EXP 120
64806: PPUSH
64807: LD_VAR 0 4
64811: PUSH
64812: LD_EXP 120
64816: PUSH
64817: LD_VAR 0 4
64821: ARRAY
64822: PUSH
64823: LD_INT 1
64825: PLUS
64826: PUSH
64827: EMPTY
64828: LIST
64829: LIST
64830: PPUSH
64831: LD_VAR 0 1
64835: PPUSH
64836: CALL 70157 0 3
64840: ST_TO_ADDR
// exit ;
64841: POP
64842: POP
64843: GO 64849
// end ; end ;
64845: GO 64693
64847: POP
64848: POP
// end ;
64849: LD_VAR 0 3
64853: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64854: LD_INT 0
64856: PPUSH
64857: PPUSH
64858: PPUSH
// if not mc_bases or not skirmish then
64859: LD_EXP 113
64863: NOT
64864: PUSH
64865: LD_EXP 111
64869: NOT
64870: OR
64871: IFFALSE 64875
// exit ;
64873: GO 65065
// for i = 1 to mc_bases do
64875: LD_ADDR_VAR 0 4
64879: PUSH
64880: DOUBLE
64881: LD_INT 1
64883: DEC
64884: ST_TO_ADDR
64885: LD_EXP 113
64889: PUSH
64890: FOR_TO
64891: IFFALSE 64978
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64893: LD_VAR 0 1
64897: PUSH
64898: LD_EXP 121
64902: PUSH
64903: LD_VAR 0 4
64907: ARRAY
64908: IN
64909: PUSH
64910: LD_VAR 0 1
64914: PUSH
64915: LD_EXP 122
64919: PUSH
64920: LD_VAR 0 4
64924: ARRAY
64925: IN
64926: NOT
64927: AND
64928: IFFALSE 64976
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64930: LD_ADDR_EXP 122
64934: PUSH
64935: LD_EXP 122
64939: PPUSH
64940: LD_VAR 0 4
64944: PUSH
64945: LD_EXP 122
64949: PUSH
64950: LD_VAR 0 4
64954: ARRAY
64955: PUSH
64956: LD_INT 1
64958: PLUS
64959: PUSH
64960: EMPTY
64961: LIST
64962: LIST
64963: PPUSH
64964: LD_VAR 0 1
64968: PPUSH
64969: CALL 70157 0 3
64973: ST_TO_ADDR
// break ;
64974: GO 64978
// end ; end ;
64976: GO 64890
64978: POP
64979: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64980: LD_VAR 0 1
64984: PPUSH
64985: CALL_OW 257
64989: PUSH
64990: LD_EXP 139
64994: IN
64995: PUSH
64996: LD_VAR 0 1
65000: PPUSH
65001: CALL_OW 266
65005: PUSH
65006: LD_INT 5
65008: EQUAL
65009: AND
65010: PUSH
65011: LD_VAR 0 2
65015: PPUSH
65016: CALL_OW 110
65020: PUSH
65021: LD_INT 18
65023: NONEQUAL
65024: AND
65025: IFFALSE 65065
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65027: LD_VAR 0 2
65031: PPUSH
65032: CALL_OW 257
65036: PUSH
65037: LD_INT 5
65039: PUSH
65040: LD_INT 8
65042: PUSH
65043: LD_INT 9
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: LIST
65050: IN
65051: IFFALSE 65065
// SetClass ( unit , 1 ) ;
65053: LD_VAR 0 2
65057: PPUSH
65058: LD_INT 1
65060: PPUSH
65061: CALL_OW 336
// end ;
65065: LD_VAR 0 3
65069: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65070: LD_INT 0
65072: PPUSH
65073: PPUSH
// if not mc_bases or not skirmish then
65074: LD_EXP 113
65078: NOT
65079: PUSH
65080: LD_EXP 111
65084: NOT
65085: OR
65086: IFFALSE 65090
// exit ;
65088: GO 65206
// if GetLives ( abandoned_vehicle ) > 250 then
65090: LD_VAR 0 2
65094: PPUSH
65095: CALL_OW 256
65099: PUSH
65100: LD_INT 250
65102: GREATER
65103: IFFALSE 65107
// exit ;
65105: GO 65206
// for i = 1 to mc_bases do
65107: LD_ADDR_VAR 0 6
65111: PUSH
65112: DOUBLE
65113: LD_INT 1
65115: DEC
65116: ST_TO_ADDR
65117: LD_EXP 113
65121: PUSH
65122: FOR_TO
65123: IFFALSE 65204
// begin if driver in mc_bases [ i ] then
65125: LD_VAR 0 1
65129: PUSH
65130: LD_EXP 113
65134: PUSH
65135: LD_VAR 0 6
65139: ARRAY
65140: IN
65141: IFFALSE 65202
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65143: LD_VAR 0 1
65147: PPUSH
65148: LD_EXP 113
65152: PUSH
65153: LD_VAR 0 6
65157: ARRAY
65158: PPUSH
65159: LD_INT 2
65161: PUSH
65162: LD_INT 30
65164: PUSH
65165: LD_INT 0
65167: PUSH
65168: EMPTY
65169: LIST
65170: LIST
65171: PUSH
65172: LD_INT 30
65174: PUSH
65175: LD_INT 1
65177: PUSH
65178: EMPTY
65179: LIST
65180: LIST
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: LIST
65186: PPUSH
65187: CALL_OW 72
65191: PUSH
65192: LD_INT 1
65194: ARRAY
65195: PPUSH
65196: CALL 102023 0 2
// break ;
65200: GO 65204
// end ; end ;
65202: GO 65122
65204: POP
65205: POP
// end ; end_of_file
65206: LD_VAR 0 5
65210: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65211: LD_INT 0
65213: PPUSH
65214: PPUSH
// if exist_mode then
65215: LD_VAR 0 2
65219: IFFALSE 65244
// unit := CreateCharacter ( prefix & ident ) else
65221: LD_ADDR_VAR 0 5
65225: PUSH
65226: LD_VAR 0 3
65230: PUSH
65231: LD_VAR 0 1
65235: STR
65236: PPUSH
65237: CALL_OW 34
65241: ST_TO_ADDR
65242: GO 65259
// unit := NewCharacter ( ident ) ;
65244: LD_ADDR_VAR 0 5
65248: PUSH
65249: LD_VAR 0 1
65253: PPUSH
65254: CALL_OW 25
65258: ST_TO_ADDR
// result := unit ;
65259: LD_ADDR_VAR 0 4
65263: PUSH
65264: LD_VAR 0 5
65268: ST_TO_ADDR
// end ;
65269: LD_VAR 0 4
65273: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65274: LD_INT 0
65276: PPUSH
65277: PPUSH
// if not side or not nation then
65278: LD_VAR 0 1
65282: NOT
65283: PUSH
65284: LD_VAR 0 2
65288: NOT
65289: OR
65290: IFFALSE 65294
// exit ;
65292: GO 66058
// case nation of nation_american :
65294: LD_VAR 0 2
65298: PUSH
65299: LD_INT 1
65301: DOUBLE
65302: EQUAL
65303: IFTRUE 65307
65305: GO 65521
65307: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65308: LD_ADDR_VAR 0 4
65312: PUSH
65313: LD_INT 35
65315: PUSH
65316: LD_INT 45
65318: PUSH
65319: LD_INT 46
65321: PUSH
65322: LD_INT 47
65324: PUSH
65325: LD_INT 82
65327: PUSH
65328: LD_INT 83
65330: PUSH
65331: LD_INT 84
65333: PUSH
65334: LD_INT 85
65336: PUSH
65337: LD_INT 86
65339: PUSH
65340: LD_INT 1
65342: PUSH
65343: LD_INT 2
65345: PUSH
65346: LD_INT 6
65348: PUSH
65349: LD_INT 15
65351: PUSH
65352: LD_INT 16
65354: PUSH
65355: LD_INT 7
65357: PUSH
65358: LD_INT 12
65360: PUSH
65361: LD_INT 13
65363: PUSH
65364: LD_INT 10
65366: PUSH
65367: LD_INT 14
65369: PUSH
65370: LD_INT 20
65372: PUSH
65373: LD_INT 21
65375: PUSH
65376: LD_INT 22
65378: PUSH
65379: LD_INT 25
65381: PUSH
65382: LD_INT 32
65384: PUSH
65385: LD_INT 27
65387: PUSH
65388: LD_INT 36
65390: PUSH
65391: LD_INT 69
65393: PUSH
65394: LD_INT 39
65396: PUSH
65397: LD_INT 34
65399: PUSH
65400: LD_INT 40
65402: PUSH
65403: LD_INT 48
65405: PUSH
65406: LD_INT 49
65408: PUSH
65409: LD_INT 50
65411: PUSH
65412: LD_INT 51
65414: PUSH
65415: LD_INT 52
65417: PUSH
65418: LD_INT 53
65420: PUSH
65421: LD_INT 54
65423: PUSH
65424: LD_INT 55
65426: PUSH
65427: LD_INT 56
65429: PUSH
65430: LD_INT 57
65432: PUSH
65433: LD_INT 58
65435: PUSH
65436: LD_INT 59
65438: PUSH
65439: LD_INT 60
65441: PUSH
65442: LD_INT 61
65444: PUSH
65445: LD_INT 62
65447: PUSH
65448: LD_INT 80
65450: PUSH
65451: LD_INT 82
65453: PUSH
65454: LD_INT 83
65456: PUSH
65457: LD_INT 84
65459: PUSH
65460: LD_INT 85
65462: PUSH
65463: LD_INT 86
65465: PUSH
65466: EMPTY
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: ST_TO_ADDR
65519: GO 65982
65521: LD_INT 2
65523: DOUBLE
65524: EQUAL
65525: IFTRUE 65529
65527: GO 65751
65529: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65530: LD_ADDR_VAR 0 4
65534: PUSH
65535: LD_INT 35
65537: PUSH
65538: LD_INT 45
65540: PUSH
65541: LD_INT 46
65543: PUSH
65544: LD_INT 47
65546: PUSH
65547: LD_INT 82
65549: PUSH
65550: LD_INT 83
65552: PUSH
65553: LD_INT 84
65555: PUSH
65556: LD_INT 85
65558: PUSH
65559: LD_INT 87
65561: PUSH
65562: LD_INT 70
65564: PUSH
65565: LD_INT 1
65567: PUSH
65568: LD_INT 11
65570: PUSH
65571: LD_INT 3
65573: PUSH
65574: LD_INT 4
65576: PUSH
65577: LD_INT 5
65579: PUSH
65580: LD_INT 6
65582: PUSH
65583: LD_INT 15
65585: PUSH
65586: LD_INT 18
65588: PUSH
65589: LD_INT 7
65591: PUSH
65592: LD_INT 17
65594: PUSH
65595: LD_INT 8
65597: PUSH
65598: LD_INT 20
65600: PUSH
65601: LD_INT 21
65603: PUSH
65604: LD_INT 22
65606: PUSH
65607: LD_INT 72
65609: PUSH
65610: LD_INT 26
65612: PUSH
65613: LD_INT 69
65615: PUSH
65616: LD_INT 39
65618: PUSH
65619: LD_INT 40
65621: PUSH
65622: LD_INT 41
65624: PUSH
65625: LD_INT 42
65627: PUSH
65628: LD_INT 43
65630: PUSH
65631: LD_INT 48
65633: PUSH
65634: LD_INT 49
65636: PUSH
65637: LD_INT 50
65639: PUSH
65640: LD_INT 51
65642: PUSH
65643: LD_INT 52
65645: PUSH
65646: LD_INT 53
65648: PUSH
65649: LD_INT 54
65651: PUSH
65652: LD_INT 55
65654: PUSH
65655: LD_INT 56
65657: PUSH
65658: LD_INT 60
65660: PUSH
65661: LD_INT 61
65663: PUSH
65664: LD_INT 62
65666: PUSH
65667: LD_INT 66
65669: PUSH
65670: LD_INT 67
65672: PUSH
65673: LD_INT 68
65675: PUSH
65676: LD_INT 81
65678: PUSH
65679: LD_INT 82
65681: PUSH
65682: LD_INT 83
65684: PUSH
65685: LD_INT 84
65687: PUSH
65688: LD_INT 85
65690: PUSH
65691: LD_INT 87
65693: PUSH
65694: EMPTY
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: LIST
65731: LIST
65732: LIST
65733: LIST
65734: LIST
65735: LIST
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: LIST
65748: ST_TO_ADDR
65749: GO 65982
65751: LD_INT 3
65753: DOUBLE
65754: EQUAL
65755: IFTRUE 65759
65757: GO 65981
65759: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65760: LD_ADDR_VAR 0 4
65764: PUSH
65765: LD_INT 46
65767: PUSH
65768: LD_INT 47
65770: PUSH
65771: LD_INT 1
65773: PUSH
65774: LD_INT 2
65776: PUSH
65777: LD_INT 82
65779: PUSH
65780: LD_INT 83
65782: PUSH
65783: LD_INT 84
65785: PUSH
65786: LD_INT 85
65788: PUSH
65789: LD_INT 86
65791: PUSH
65792: LD_INT 11
65794: PUSH
65795: LD_INT 9
65797: PUSH
65798: LD_INT 20
65800: PUSH
65801: LD_INT 19
65803: PUSH
65804: LD_INT 21
65806: PUSH
65807: LD_INT 24
65809: PUSH
65810: LD_INT 22
65812: PUSH
65813: LD_INT 25
65815: PUSH
65816: LD_INT 28
65818: PUSH
65819: LD_INT 29
65821: PUSH
65822: LD_INT 30
65824: PUSH
65825: LD_INT 31
65827: PUSH
65828: LD_INT 37
65830: PUSH
65831: LD_INT 38
65833: PUSH
65834: LD_INT 32
65836: PUSH
65837: LD_INT 27
65839: PUSH
65840: LD_INT 33
65842: PUSH
65843: LD_INT 69
65845: PUSH
65846: LD_INT 39
65848: PUSH
65849: LD_INT 34
65851: PUSH
65852: LD_INT 40
65854: PUSH
65855: LD_INT 71
65857: PUSH
65858: LD_INT 23
65860: PUSH
65861: LD_INT 44
65863: PUSH
65864: LD_INT 48
65866: PUSH
65867: LD_INT 49
65869: PUSH
65870: LD_INT 50
65872: PUSH
65873: LD_INT 51
65875: PUSH
65876: LD_INT 52
65878: PUSH
65879: LD_INT 53
65881: PUSH
65882: LD_INT 54
65884: PUSH
65885: LD_INT 55
65887: PUSH
65888: LD_INT 56
65890: PUSH
65891: LD_INT 57
65893: PUSH
65894: LD_INT 58
65896: PUSH
65897: LD_INT 59
65899: PUSH
65900: LD_INT 63
65902: PUSH
65903: LD_INT 64
65905: PUSH
65906: LD_INT 65
65908: PUSH
65909: LD_INT 82
65911: PUSH
65912: LD_INT 83
65914: PUSH
65915: LD_INT 84
65917: PUSH
65918: LD_INT 85
65920: PUSH
65921: LD_INT 86
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: LIST
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: ST_TO_ADDR
65979: GO 65982
65981: POP
// if state > - 1 and state < 3 then
65982: LD_VAR 0 3
65986: PUSH
65987: LD_INT 1
65989: NEG
65990: GREATER
65991: PUSH
65992: LD_VAR 0 3
65996: PUSH
65997: LD_INT 3
65999: LESS
66000: AND
66001: IFFALSE 66058
// for i in result do
66003: LD_ADDR_VAR 0 5
66007: PUSH
66008: LD_VAR 0 4
66012: PUSH
66013: FOR_IN
66014: IFFALSE 66056
// if GetTech ( i , side ) <> state then
66016: LD_VAR 0 5
66020: PPUSH
66021: LD_VAR 0 1
66025: PPUSH
66026: CALL_OW 321
66030: PUSH
66031: LD_VAR 0 3
66035: NONEQUAL
66036: IFFALSE 66054
// result := result diff i ;
66038: LD_ADDR_VAR 0 4
66042: PUSH
66043: LD_VAR 0 4
66047: PUSH
66048: LD_VAR 0 5
66052: DIFF
66053: ST_TO_ADDR
66054: GO 66013
66056: POP
66057: POP
// end ;
66058: LD_VAR 0 4
66062: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66063: LD_INT 0
66065: PPUSH
66066: PPUSH
66067: PPUSH
// result := true ;
66068: LD_ADDR_VAR 0 3
66072: PUSH
66073: LD_INT 1
66075: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66076: LD_ADDR_VAR 0 5
66080: PUSH
66081: LD_VAR 0 2
66085: PPUSH
66086: CALL_OW 480
66090: ST_TO_ADDR
// if not tmp then
66091: LD_VAR 0 5
66095: NOT
66096: IFFALSE 66100
// exit ;
66098: GO 66149
// for i in tmp do
66100: LD_ADDR_VAR 0 4
66104: PUSH
66105: LD_VAR 0 5
66109: PUSH
66110: FOR_IN
66111: IFFALSE 66147
// if GetTech ( i , side ) <> state_researched then
66113: LD_VAR 0 4
66117: PPUSH
66118: LD_VAR 0 1
66122: PPUSH
66123: CALL_OW 321
66127: PUSH
66128: LD_INT 2
66130: NONEQUAL
66131: IFFALSE 66145
// begin result := false ;
66133: LD_ADDR_VAR 0 3
66137: PUSH
66138: LD_INT 0
66140: ST_TO_ADDR
// exit ;
66141: POP
66142: POP
66143: GO 66149
// end ;
66145: GO 66110
66147: POP
66148: POP
// end ;
66149: LD_VAR 0 3
66153: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66154: LD_INT 0
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
66162: PPUSH
66163: PPUSH
66164: PPUSH
66165: PPUSH
66166: PPUSH
66167: PPUSH
66168: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66169: LD_VAR 0 1
66173: NOT
66174: PUSH
66175: LD_VAR 0 1
66179: PPUSH
66180: CALL_OW 257
66184: PUSH
66185: LD_INT 9
66187: NONEQUAL
66188: OR
66189: IFFALSE 66193
// exit ;
66191: GO 66766
// side := GetSide ( unit ) ;
66193: LD_ADDR_VAR 0 9
66197: PUSH
66198: LD_VAR 0 1
66202: PPUSH
66203: CALL_OW 255
66207: ST_TO_ADDR
// tech_space := tech_spacanom ;
66208: LD_ADDR_VAR 0 12
66212: PUSH
66213: LD_INT 29
66215: ST_TO_ADDR
// tech_time := tech_taurad ;
66216: LD_ADDR_VAR 0 13
66220: PUSH
66221: LD_INT 28
66223: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66224: LD_ADDR_VAR 0 11
66228: PUSH
66229: LD_VAR 0 1
66233: PPUSH
66234: CALL_OW 310
66238: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66239: LD_VAR 0 11
66243: PPUSH
66244: CALL_OW 247
66248: PUSH
66249: LD_INT 2
66251: EQUAL
66252: IFFALSE 66256
// exit ;
66254: GO 66766
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66256: LD_ADDR_VAR 0 8
66260: PUSH
66261: LD_INT 81
66263: PUSH
66264: LD_VAR 0 9
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 3
66275: PUSH
66276: LD_INT 21
66278: PUSH
66279: LD_INT 3
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: EMPTY
66291: LIST
66292: LIST
66293: PPUSH
66294: CALL_OW 69
66298: ST_TO_ADDR
// if not tmp then
66299: LD_VAR 0 8
66303: NOT
66304: IFFALSE 66308
// exit ;
66306: GO 66766
// if in_unit then
66308: LD_VAR 0 11
66312: IFFALSE 66336
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66314: LD_ADDR_VAR 0 10
66318: PUSH
66319: LD_VAR 0 8
66323: PPUSH
66324: LD_VAR 0 11
66328: PPUSH
66329: CALL_OW 74
66333: ST_TO_ADDR
66334: GO 66356
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66336: LD_ADDR_VAR 0 10
66340: PUSH
66341: LD_VAR 0 8
66345: PPUSH
66346: LD_VAR 0 1
66350: PPUSH
66351: CALL_OW 74
66355: ST_TO_ADDR
// if not enemy then
66356: LD_VAR 0 10
66360: NOT
66361: IFFALSE 66365
// exit ;
66363: GO 66766
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66365: LD_VAR 0 11
66369: PUSH
66370: LD_VAR 0 11
66374: PPUSH
66375: LD_VAR 0 10
66379: PPUSH
66380: CALL_OW 296
66384: PUSH
66385: LD_INT 13
66387: GREATER
66388: AND
66389: PUSH
66390: LD_VAR 0 1
66394: PPUSH
66395: LD_VAR 0 10
66399: PPUSH
66400: CALL_OW 296
66404: PUSH
66405: LD_INT 12
66407: GREATER
66408: OR
66409: IFFALSE 66413
// exit ;
66411: GO 66766
// missile := [ 1 ] ;
66413: LD_ADDR_VAR 0 14
66417: PUSH
66418: LD_INT 1
66420: PUSH
66421: EMPTY
66422: LIST
66423: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66424: LD_VAR 0 9
66428: PPUSH
66429: LD_VAR 0 12
66433: PPUSH
66434: CALL_OW 325
66438: IFFALSE 66467
// missile := Insert ( missile , missile + 1 , 2 ) ;
66440: LD_ADDR_VAR 0 14
66444: PUSH
66445: LD_VAR 0 14
66449: PPUSH
66450: LD_VAR 0 14
66454: PUSH
66455: LD_INT 1
66457: PLUS
66458: PPUSH
66459: LD_INT 2
66461: PPUSH
66462: CALL_OW 2
66466: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66467: LD_VAR 0 9
66471: PPUSH
66472: LD_VAR 0 13
66476: PPUSH
66477: CALL_OW 325
66481: PUSH
66482: LD_VAR 0 10
66486: PPUSH
66487: CALL_OW 255
66491: PPUSH
66492: LD_VAR 0 13
66496: PPUSH
66497: CALL_OW 325
66501: NOT
66502: AND
66503: IFFALSE 66532
// missile := Insert ( missile , missile + 1 , 3 ) ;
66505: LD_ADDR_VAR 0 14
66509: PUSH
66510: LD_VAR 0 14
66514: PPUSH
66515: LD_VAR 0 14
66519: PUSH
66520: LD_INT 1
66522: PLUS
66523: PPUSH
66524: LD_INT 3
66526: PPUSH
66527: CALL_OW 2
66531: ST_TO_ADDR
// if missile < 2 then
66532: LD_VAR 0 14
66536: PUSH
66537: LD_INT 2
66539: LESS
66540: IFFALSE 66544
// exit ;
66542: GO 66766
// x := GetX ( enemy ) ;
66544: LD_ADDR_VAR 0 4
66548: PUSH
66549: LD_VAR 0 10
66553: PPUSH
66554: CALL_OW 250
66558: ST_TO_ADDR
// y := GetY ( enemy ) ;
66559: LD_ADDR_VAR 0 5
66563: PUSH
66564: LD_VAR 0 10
66568: PPUSH
66569: CALL_OW 251
66573: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66574: LD_ADDR_VAR 0 6
66578: PUSH
66579: LD_VAR 0 4
66583: PUSH
66584: LD_INT 1
66586: NEG
66587: PPUSH
66588: LD_INT 1
66590: PPUSH
66591: CALL_OW 12
66595: PLUS
66596: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66597: LD_ADDR_VAR 0 7
66601: PUSH
66602: LD_VAR 0 5
66606: PUSH
66607: LD_INT 1
66609: NEG
66610: PPUSH
66611: LD_INT 1
66613: PPUSH
66614: CALL_OW 12
66618: PLUS
66619: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66620: LD_VAR 0 6
66624: PPUSH
66625: LD_VAR 0 7
66629: PPUSH
66630: CALL_OW 488
66634: NOT
66635: IFFALSE 66657
// begin _x := x ;
66637: LD_ADDR_VAR 0 6
66641: PUSH
66642: LD_VAR 0 4
66646: ST_TO_ADDR
// _y := y ;
66647: LD_ADDR_VAR 0 7
66651: PUSH
66652: LD_VAR 0 5
66656: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66657: LD_ADDR_VAR 0 3
66661: PUSH
66662: LD_INT 1
66664: PPUSH
66665: LD_VAR 0 14
66669: PPUSH
66670: CALL_OW 12
66674: ST_TO_ADDR
// case i of 1 :
66675: LD_VAR 0 3
66679: PUSH
66680: LD_INT 1
66682: DOUBLE
66683: EQUAL
66684: IFTRUE 66688
66686: GO 66705
66688: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66689: LD_VAR 0 1
66693: PPUSH
66694: LD_VAR 0 10
66698: PPUSH
66699: CALL_OW 115
66703: GO 66766
66705: LD_INT 2
66707: DOUBLE
66708: EQUAL
66709: IFTRUE 66713
66711: GO 66735
66713: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66714: LD_VAR 0 1
66718: PPUSH
66719: LD_VAR 0 6
66723: PPUSH
66724: LD_VAR 0 7
66728: PPUSH
66729: CALL_OW 153
66733: GO 66766
66735: LD_INT 3
66737: DOUBLE
66738: EQUAL
66739: IFTRUE 66743
66741: GO 66765
66743: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66744: LD_VAR 0 1
66748: PPUSH
66749: LD_VAR 0 6
66753: PPUSH
66754: LD_VAR 0 7
66758: PPUSH
66759: CALL_OW 154
66763: GO 66766
66765: POP
// end ;
66766: LD_VAR 0 2
66770: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66771: LD_INT 0
66773: PPUSH
66774: PPUSH
66775: PPUSH
66776: PPUSH
66777: PPUSH
66778: PPUSH
// if not unit or not building then
66779: LD_VAR 0 1
66783: NOT
66784: PUSH
66785: LD_VAR 0 2
66789: NOT
66790: OR
66791: IFFALSE 66795
// exit ;
66793: GO 66953
// x := GetX ( building ) ;
66795: LD_ADDR_VAR 0 5
66799: PUSH
66800: LD_VAR 0 2
66804: PPUSH
66805: CALL_OW 250
66809: ST_TO_ADDR
// y := GetY ( building ) ;
66810: LD_ADDR_VAR 0 6
66814: PUSH
66815: LD_VAR 0 2
66819: PPUSH
66820: CALL_OW 251
66824: ST_TO_ADDR
// for i = 0 to 5 do
66825: LD_ADDR_VAR 0 4
66829: PUSH
66830: DOUBLE
66831: LD_INT 0
66833: DEC
66834: ST_TO_ADDR
66835: LD_INT 5
66837: PUSH
66838: FOR_TO
66839: IFFALSE 66951
// begin _x := ShiftX ( x , i , 3 ) ;
66841: LD_ADDR_VAR 0 7
66845: PUSH
66846: LD_VAR 0 5
66850: PPUSH
66851: LD_VAR 0 4
66855: PPUSH
66856: LD_INT 3
66858: PPUSH
66859: CALL_OW 272
66863: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66864: LD_ADDR_VAR 0 8
66868: PUSH
66869: LD_VAR 0 6
66873: PPUSH
66874: LD_VAR 0 4
66878: PPUSH
66879: LD_INT 3
66881: PPUSH
66882: CALL_OW 273
66886: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66887: LD_VAR 0 7
66891: PPUSH
66892: LD_VAR 0 8
66896: PPUSH
66897: CALL_OW 488
66901: NOT
66902: IFFALSE 66906
// continue ;
66904: GO 66838
// if HexInfo ( _x , _y ) = 0 then
66906: LD_VAR 0 7
66910: PPUSH
66911: LD_VAR 0 8
66915: PPUSH
66916: CALL_OW 428
66920: PUSH
66921: LD_INT 0
66923: EQUAL
66924: IFFALSE 66949
// begin ComMoveXY ( unit , _x , _y ) ;
66926: LD_VAR 0 1
66930: PPUSH
66931: LD_VAR 0 7
66935: PPUSH
66936: LD_VAR 0 8
66940: PPUSH
66941: CALL_OW 111
// exit ;
66945: POP
66946: POP
66947: GO 66953
// end ; end ;
66949: GO 66838
66951: POP
66952: POP
// end ;
66953: LD_VAR 0 3
66957: RET
// export function ScanBase ( side , base_area ) ; begin
66958: LD_INT 0
66960: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66961: LD_ADDR_VAR 0 3
66965: PUSH
66966: LD_VAR 0 2
66970: PPUSH
66971: LD_INT 81
66973: PUSH
66974: LD_VAR 0 1
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PPUSH
66983: CALL_OW 70
66987: ST_TO_ADDR
// end ;
66988: LD_VAR 0 3
66992: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66993: LD_INT 0
66995: PPUSH
66996: PPUSH
66997: PPUSH
66998: PPUSH
// result := false ;
66999: LD_ADDR_VAR 0 2
67003: PUSH
67004: LD_INT 0
67006: ST_TO_ADDR
// side := GetSide ( unit ) ;
67007: LD_ADDR_VAR 0 3
67011: PUSH
67012: LD_VAR 0 1
67016: PPUSH
67017: CALL_OW 255
67021: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67022: LD_ADDR_VAR 0 4
67026: PUSH
67027: LD_VAR 0 1
67031: PPUSH
67032: CALL_OW 248
67036: ST_TO_ADDR
// case nat of 1 :
67037: LD_VAR 0 4
67041: PUSH
67042: LD_INT 1
67044: DOUBLE
67045: EQUAL
67046: IFTRUE 67050
67048: GO 67061
67050: POP
// tech := tech_lassight ; 2 :
67051: LD_ADDR_VAR 0 5
67055: PUSH
67056: LD_INT 12
67058: ST_TO_ADDR
67059: GO 67100
67061: LD_INT 2
67063: DOUBLE
67064: EQUAL
67065: IFTRUE 67069
67067: GO 67080
67069: POP
// tech := tech_mortar ; 3 :
67070: LD_ADDR_VAR 0 5
67074: PUSH
67075: LD_INT 41
67077: ST_TO_ADDR
67078: GO 67100
67080: LD_INT 3
67082: DOUBLE
67083: EQUAL
67084: IFTRUE 67088
67086: GO 67099
67088: POP
// tech := tech_bazooka ; end ;
67089: LD_ADDR_VAR 0 5
67093: PUSH
67094: LD_INT 44
67096: ST_TO_ADDR
67097: GO 67100
67099: POP
// if Researched ( side , tech ) then
67100: LD_VAR 0 3
67104: PPUSH
67105: LD_VAR 0 5
67109: PPUSH
67110: CALL_OW 325
67114: IFFALSE 67141
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67116: LD_ADDR_VAR 0 2
67120: PUSH
67121: LD_INT 5
67123: PUSH
67124: LD_INT 8
67126: PUSH
67127: LD_INT 9
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: LIST
67134: PUSH
67135: LD_VAR 0 4
67139: ARRAY
67140: ST_TO_ADDR
// end ;
67141: LD_VAR 0 2
67145: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67146: LD_INT 0
67148: PPUSH
67149: PPUSH
67150: PPUSH
// if not mines then
67151: LD_VAR 0 2
67155: NOT
67156: IFFALSE 67160
// exit ;
67158: GO 67304
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67160: LD_ADDR_VAR 0 5
67164: PUSH
67165: LD_INT 81
67167: PUSH
67168: LD_VAR 0 1
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 3
67179: PUSH
67180: LD_INT 21
67182: PUSH
67183: LD_INT 3
67185: PUSH
67186: EMPTY
67187: LIST
67188: LIST
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PPUSH
67198: CALL_OW 69
67202: ST_TO_ADDR
// for i in mines do
67203: LD_ADDR_VAR 0 4
67207: PUSH
67208: LD_VAR 0 2
67212: PUSH
67213: FOR_IN
67214: IFFALSE 67302
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67216: LD_VAR 0 4
67220: PUSH
67221: LD_INT 1
67223: ARRAY
67224: PPUSH
67225: LD_VAR 0 4
67229: PUSH
67230: LD_INT 2
67232: ARRAY
67233: PPUSH
67234: CALL_OW 458
67238: NOT
67239: IFFALSE 67243
// continue ;
67241: GO 67213
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67243: LD_VAR 0 4
67247: PUSH
67248: LD_INT 1
67250: ARRAY
67251: PPUSH
67252: LD_VAR 0 4
67256: PUSH
67257: LD_INT 2
67259: ARRAY
67260: PPUSH
67261: CALL_OW 428
67265: PUSH
67266: LD_VAR 0 5
67270: IN
67271: IFFALSE 67300
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67273: LD_VAR 0 4
67277: PUSH
67278: LD_INT 1
67280: ARRAY
67281: PPUSH
67282: LD_VAR 0 4
67286: PUSH
67287: LD_INT 2
67289: ARRAY
67290: PPUSH
67291: LD_VAR 0 1
67295: PPUSH
67296: CALL_OW 456
// end ;
67300: GO 67213
67302: POP
67303: POP
// end ;
67304: LD_VAR 0 3
67308: RET
// export function Count ( array ) ; var i ; begin
67309: LD_INT 0
67311: PPUSH
67312: PPUSH
// result := 0 ;
67313: LD_ADDR_VAR 0 2
67317: PUSH
67318: LD_INT 0
67320: ST_TO_ADDR
// for i in array do
67321: LD_ADDR_VAR 0 3
67325: PUSH
67326: LD_VAR 0 1
67330: PUSH
67331: FOR_IN
67332: IFFALSE 67356
// if i then
67334: LD_VAR 0 3
67338: IFFALSE 67354
// result := result + 1 ;
67340: LD_ADDR_VAR 0 2
67344: PUSH
67345: LD_VAR 0 2
67349: PUSH
67350: LD_INT 1
67352: PLUS
67353: ST_TO_ADDR
67354: GO 67331
67356: POP
67357: POP
// end ;
67358: LD_VAR 0 2
67362: RET
// export function IsEmpty ( building ) ; begin
67363: LD_INT 0
67365: PPUSH
// if not building then
67366: LD_VAR 0 1
67370: NOT
67371: IFFALSE 67375
// exit ;
67373: GO 67418
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67375: LD_ADDR_VAR 0 2
67379: PUSH
67380: LD_VAR 0 1
67384: PUSH
67385: LD_INT 22
67387: PUSH
67388: LD_VAR 0 1
67392: PPUSH
67393: CALL_OW 255
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: PUSH
67402: LD_INT 58
67404: PUSH
67405: EMPTY
67406: LIST
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PPUSH
67412: CALL_OW 69
67416: IN
67417: ST_TO_ADDR
// end ;
67418: LD_VAR 0 2
67422: RET
// export function IsNotFull ( building ) ; begin
67423: LD_INT 0
67425: PPUSH
// if not building then
67426: LD_VAR 0 1
67430: NOT
67431: IFFALSE 67435
// exit ;
67433: GO 67454
// result := UnitsInside ( building ) < 6 ;
67435: LD_ADDR_VAR 0 2
67439: PUSH
67440: LD_VAR 0 1
67444: PPUSH
67445: CALL_OW 313
67449: PUSH
67450: LD_INT 6
67452: LESS
67453: ST_TO_ADDR
// end ;
67454: LD_VAR 0 2
67458: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67459: LD_INT 0
67461: PPUSH
67462: PPUSH
67463: PPUSH
67464: PPUSH
// tmp := [ ] ;
67465: LD_ADDR_VAR 0 3
67469: PUSH
67470: EMPTY
67471: ST_TO_ADDR
// list := [ ] ;
67472: LD_ADDR_VAR 0 5
67476: PUSH
67477: EMPTY
67478: ST_TO_ADDR
// for i = 16 to 25 do
67479: LD_ADDR_VAR 0 4
67483: PUSH
67484: DOUBLE
67485: LD_INT 16
67487: DEC
67488: ST_TO_ADDR
67489: LD_INT 25
67491: PUSH
67492: FOR_TO
67493: IFFALSE 67566
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67495: LD_ADDR_VAR 0 3
67499: PUSH
67500: LD_VAR 0 3
67504: PUSH
67505: LD_INT 22
67507: PUSH
67508: LD_VAR 0 1
67512: PPUSH
67513: CALL_OW 255
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 91
67524: PUSH
67525: LD_VAR 0 1
67529: PUSH
67530: LD_INT 6
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: LIST
67537: PUSH
67538: LD_INT 30
67540: PUSH
67541: LD_VAR 0 4
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: LIST
67554: PUSH
67555: EMPTY
67556: LIST
67557: PPUSH
67558: CALL_OW 69
67562: ADD
67563: ST_TO_ADDR
67564: GO 67492
67566: POP
67567: POP
// for i = 1 to tmp do
67568: LD_ADDR_VAR 0 4
67572: PUSH
67573: DOUBLE
67574: LD_INT 1
67576: DEC
67577: ST_TO_ADDR
67578: LD_VAR 0 3
67582: PUSH
67583: FOR_TO
67584: IFFALSE 67672
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67586: LD_ADDR_VAR 0 5
67590: PUSH
67591: LD_VAR 0 5
67595: PUSH
67596: LD_VAR 0 3
67600: PUSH
67601: LD_VAR 0 4
67605: ARRAY
67606: PPUSH
67607: CALL_OW 266
67611: PUSH
67612: LD_VAR 0 3
67616: PUSH
67617: LD_VAR 0 4
67621: ARRAY
67622: PPUSH
67623: CALL_OW 250
67627: PUSH
67628: LD_VAR 0 3
67632: PUSH
67633: LD_VAR 0 4
67637: ARRAY
67638: PPUSH
67639: CALL_OW 251
67643: PUSH
67644: LD_VAR 0 3
67648: PUSH
67649: LD_VAR 0 4
67653: ARRAY
67654: PPUSH
67655: CALL_OW 254
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: PUSH
67666: EMPTY
67667: LIST
67668: ADD
67669: ST_TO_ADDR
67670: GO 67583
67672: POP
67673: POP
// result := list ;
67674: LD_ADDR_VAR 0 2
67678: PUSH
67679: LD_VAR 0 5
67683: ST_TO_ADDR
// end ;
67684: LD_VAR 0 2
67688: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67689: LD_INT 0
67691: PPUSH
67692: PPUSH
67693: PPUSH
67694: PPUSH
67695: PPUSH
67696: PPUSH
67697: PPUSH
// if not factory then
67698: LD_VAR 0 1
67702: NOT
67703: IFFALSE 67707
// exit ;
67705: GO 68300
// if control = control_apeman then
67707: LD_VAR 0 4
67711: PUSH
67712: LD_INT 5
67714: EQUAL
67715: IFFALSE 67824
// begin tmp := UnitsInside ( factory ) ;
67717: LD_ADDR_VAR 0 8
67721: PUSH
67722: LD_VAR 0 1
67726: PPUSH
67727: CALL_OW 313
67731: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67732: LD_VAR 0 8
67736: PPUSH
67737: LD_INT 25
67739: PUSH
67740: LD_INT 12
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PPUSH
67747: CALL_OW 72
67751: NOT
67752: IFFALSE 67762
// control := control_manual ;
67754: LD_ADDR_VAR 0 4
67758: PUSH
67759: LD_INT 1
67761: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67762: LD_ADDR_VAR 0 8
67766: PUSH
67767: LD_VAR 0 1
67771: PPUSH
67772: CALL 67459 0 1
67776: ST_TO_ADDR
// if tmp then
67777: LD_VAR 0 8
67781: IFFALSE 67824
// begin for i in tmp do
67783: LD_ADDR_VAR 0 7
67787: PUSH
67788: LD_VAR 0 8
67792: PUSH
67793: FOR_IN
67794: IFFALSE 67822
// if i [ 1 ] = b_ext_radio then
67796: LD_VAR 0 7
67800: PUSH
67801: LD_INT 1
67803: ARRAY
67804: PUSH
67805: LD_INT 22
67807: EQUAL
67808: IFFALSE 67820
// begin control := control_remote ;
67810: LD_ADDR_VAR 0 4
67814: PUSH
67815: LD_INT 2
67817: ST_TO_ADDR
// break ;
67818: GO 67822
// end ;
67820: GO 67793
67822: POP
67823: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67824: LD_VAR 0 1
67828: PPUSH
67829: LD_VAR 0 2
67833: PPUSH
67834: LD_VAR 0 3
67838: PPUSH
67839: LD_VAR 0 4
67843: PPUSH
67844: LD_VAR 0 5
67848: PPUSH
67849: CALL_OW 448
67853: IFFALSE 67888
// begin result := [ chassis , engine , control , weapon ] ;
67855: LD_ADDR_VAR 0 6
67859: PUSH
67860: LD_VAR 0 2
67864: PUSH
67865: LD_VAR 0 3
67869: PUSH
67870: LD_VAR 0 4
67874: PUSH
67875: LD_VAR 0 5
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: ST_TO_ADDR
// exit ;
67886: GO 68300
// end ; _chassis := AvailableChassisList ( factory ) ;
67888: LD_ADDR_VAR 0 9
67892: PUSH
67893: LD_VAR 0 1
67897: PPUSH
67898: CALL_OW 475
67902: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67903: LD_ADDR_VAR 0 11
67907: PUSH
67908: LD_VAR 0 1
67912: PPUSH
67913: CALL_OW 476
67917: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67918: LD_ADDR_VAR 0 12
67922: PUSH
67923: LD_VAR 0 1
67927: PPUSH
67928: CALL_OW 477
67932: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67933: LD_ADDR_VAR 0 10
67937: PUSH
67938: LD_VAR 0 1
67942: PPUSH
67943: CALL_OW 478
67947: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67948: LD_VAR 0 9
67952: NOT
67953: PUSH
67954: LD_VAR 0 11
67958: NOT
67959: OR
67960: PUSH
67961: LD_VAR 0 12
67965: NOT
67966: OR
67967: PUSH
67968: LD_VAR 0 10
67972: NOT
67973: OR
67974: IFFALSE 68009
// begin result := [ chassis , engine , control , weapon ] ;
67976: LD_ADDR_VAR 0 6
67980: PUSH
67981: LD_VAR 0 2
67985: PUSH
67986: LD_VAR 0 3
67990: PUSH
67991: LD_VAR 0 4
67995: PUSH
67996: LD_VAR 0 5
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: ST_TO_ADDR
// exit ;
68007: GO 68300
// end ; if not chassis in _chassis then
68009: LD_VAR 0 2
68013: PUSH
68014: LD_VAR 0 9
68018: IN
68019: NOT
68020: IFFALSE 68046
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68022: LD_ADDR_VAR 0 2
68026: PUSH
68027: LD_VAR 0 9
68031: PUSH
68032: LD_INT 1
68034: PPUSH
68035: LD_VAR 0 9
68039: PPUSH
68040: CALL_OW 12
68044: ARRAY
68045: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68046: LD_VAR 0 2
68050: PPUSH
68051: LD_VAR 0 3
68055: PPUSH
68056: CALL 68305 0 2
68060: NOT
68061: IFFALSE 68120
// repeat engine := _engine [ 1 ] ;
68063: LD_ADDR_VAR 0 3
68067: PUSH
68068: LD_VAR 0 11
68072: PUSH
68073: LD_INT 1
68075: ARRAY
68076: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68077: LD_ADDR_VAR 0 11
68081: PUSH
68082: LD_VAR 0 11
68086: PPUSH
68087: LD_INT 1
68089: PPUSH
68090: CALL_OW 3
68094: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68095: LD_VAR 0 2
68099: PPUSH
68100: LD_VAR 0 3
68104: PPUSH
68105: CALL 68305 0 2
68109: PUSH
68110: LD_VAR 0 11
68114: PUSH
68115: EMPTY
68116: EQUAL
68117: OR
68118: IFFALSE 68063
// if not control in _control then
68120: LD_VAR 0 4
68124: PUSH
68125: LD_VAR 0 12
68129: IN
68130: NOT
68131: IFFALSE 68157
// control := _control [ rand ( 1 , _control ) ] ;
68133: LD_ADDR_VAR 0 4
68137: PUSH
68138: LD_VAR 0 12
68142: PUSH
68143: LD_INT 1
68145: PPUSH
68146: LD_VAR 0 12
68150: PPUSH
68151: CALL_OW 12
68155: ARRAY
68156: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68157: LD_VAR 0 2
68161: PPUSH
68162: LD_VAR 0 5
68166: PPUSH
68167: CALL 68525 0 2
68171: NOT
68172: IFFALSE 68231
// repeat weapon := _weapon [ 1 ] ;
68174: LD_ADDR_VAR 0 5
68178: PUSH
68179: LD_VAR 0 10
68183: PUSH
68184: LD_INT 1
68186: ARRAY
68187: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68188: LD_ADDR_VAR 0 10
68192: PUSH
68193: LD_VAR 0 10
68197: PPUSH
68198: LD_INT 1
68200: PPUSH
68201: CALL_OW 3
68205: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68206: LD_VAR 0 2
68210: PPUSH
68211: LD_VAR 0 5
68215: PPUSH
68216: CALL 68525 0 2
68220: PUSH
68221: LD_VAR 0 10
68225: PUSH
68226: EMPTY
68227: EQUAL
68228: OR
68229: IFFALSE 68174
// result := [ ] ;
68231: LD_ADDR_VAR 0 6
68235: PUSH
68236: EMPTY
68237: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68238: LD_VAR 0 1
68242: PPUSH
68243: LD_VAR 0 2
68247: PPUSH
68248: LD_VAR 0 3
68252: PPUSH
68253: LD_VAR 0 4
68257: PPUSH
68258: LD_VAR 0 5
68262: PPUSH
68263: CALL_OW 448
68267: IFFALSE 68300
// result := [ chassis , engine , control , weapon ] ;
68269: LD_ADDR_VAR 0 6
68273: PUSH
68274: LD_VAR 0 2
68278: PUSH
68279: LD_VAR 0 3
68283: PUSH
68284: LD_VAR 0 4
68288: PUSH
68289: LD_VAR 0 5
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: ST_TO_ADDR
// end ;
68300: LD_VAR 0 6
68304: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68305: LD_INT 0
68307: PPUSH
// if not chassis or not engine then
68308: LD_VAR 0 1
68312: NOT
68313: PUSH
68314: LD_VAR 0 2
68318: NOT
68319: OR
68320: IFFALSE 68324
// exit ;
68322: GO 68520
// case engine of engine_solar :
68324: LD_VAR 0 2
68328: PUSH
68329: LD_INT 2
68331: DOUBLE
68332: EQUAL
68333: IFTRUE 68337
68335: GO 68375
68337: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68338: LD_ADDR_VAR 0 3
68342: PUSH
68343: LD_INT 11
68345: PUSH
68346: LD_INT 12
68348: PUSH
68349: LD_INT 13
68351: PUSH
68352: LD_INT 14
68354: PUSH
68355: LD_INT 1
68357: PUSH
68358: LD_INT 2
68360: PUSH
68361: LD_INT 3
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: LIST
68368: LIST
68369: LIST
68370: LIST
68371: LIST
68372: ST_TO_ADDR
68373: GO 68504
68375: LD_INT 1
68377: DOUBLE
68378: EQUAL
68379: IFTRUE 68383
68381: GO 68445
68383: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68384: LD_ADDR_VAR 0 3
68388: PUSH
68389: LD_INT 11
68391: PUSH
68392: LD_INT 12
68394: PUSH
68395: LD_INT 13
68397: PUSH
68398: LD_INT 14
68400: PUSH
68401: LD_INT 1
68403: PUSH
68404: LD_INT 2
68406: PUSH
68407: LD_INT 3
68409: PUSH
68410: LD_INT 4
68412: PUSH
68413: LD_INT 5
68415: PUSH
68416: LD_INT 21
68418: PUSH
68419: LD_INT 23
68421: PUSH
68422: LD_INT 22
68424: PUSH
68425: LD_INT 24
68427: PUSH
68428: EMPTY
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: LIST
68436: LIST
68437: LIST
68438: LIST
68439: LIST
68440: LIST
68441: LIST
68442: ST_TO_ADDR
68443: GO 68504
68445: LD_INT 3
68447: DOUBLE
68448: EQUAL
68449: IFTRUE 68453
68451: GO 68503
68453: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68454: LD_ADDR_VAR 0 3
68458: PUSH
68459: LD_INT 13
68461: PUSH
68462: LD_INT 14
68464: PUSH
68465: LD_INT 2
68467: PUSH
68468: LD_INT 3
68470: PUSH
68471: LD_INT 4
68473: PUSH
68474: LD_INT 5
68476: PUSH
68477: LD_INT 21
68479: PUSH
68480: LD_INT 22
68482: PUSH
68483: LD_INT 23
68485: PUSH
68486: LD_INT 24
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: LIST
68497: LIST
68498: LIST
68499: LIST
68500: ST_TO_ADDR
68501: GO 68504
68503: POP
// result := ( chassis in result ) ;
68504: LD_ADDR_VAR 0 3
68508: PUSH
68509: LD_VAR 0 1
68513: PUSH
68514: LD_VAR 0 3
68518: IN
68519: ST_TO_ADDR
// end ;
68520: LD_VAR 0 3
68524: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68525: LD_INT 0
68527: PPUSH
// if not chassis or not weapon then
68528: LD_VAR 0 1
68532: NOT
68533: PUSH
68534: LD_VAR 0 2
68538: NOT
68539: OR
68540: IFFALSE 68544
// exit ;
68542: GO 69570
// case weapon of us_machine_gun :
68544: LD_VAR 0 2
68548: PUSH
68549: LD_INT 2
68551: DOUBLE
68552: EQUAL
68553: IFTRUE 68557
68555: GO 68587
68557: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68558: LD_ADDR_VAR 0 3
68562: PUSH
68563: LD_INT 1
68565: PUSH
68566: LD_INT 2
68568: PUSH
68569: LD_INT 3
68571: PUSH
68572: LD_INT 4
68574: PUSH
68575: LD_INT 5
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: ST_TO_ADDR
68585: GO 69554
68587: LD_INT 3
68589: DOUBLE
68590: EQUAL
68591: IFTRUE 68595
68593: GO 68625
68595: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68596: LD_ADDR_VAR 0 3
68600: PUSH
68601: LD_INT 1
68603: PUSH
68604: LD_INT 2
68606: PUSH
68607: LD_INT 3
68609: PUSH
68610: LD_INT 4
68612: PUSH
68613: LD_INT 5
68615: PUSH
68616: EMPTY
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: ST_TO_ADDR
68623: GO 69554
68625: LD_INT 11
68627: DOUBLE
68628: EQUAL
68629: IFTRUE 68633
68631: GO 68663
68633: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68634: LD_ADDR_VAR 0 3
68638: PUSH
68639: LD_INT 1
68641: PUSH
68642: LD_INT 2
68644: PUSH
68645: LD_INT 3
68647: PUSH
68648: LD_INT 4
68650: PUSH
68651: LD_INT 5
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: LIST
68658: LIST
68659: LIST
68660: ST_TO_ADDR
68661: GO 69554
68663: LD_INT 4
68665: DOUBLE
68666: EQUAL
68667: IFTRUE 68671
68669: GO 68697
68671: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68672: LD_ADDR_VAR 0 3
68676: PUSH
68677: LD_INT 2
68679: PUSH
68680: LD_INT 3
68682: PUSH
68683: LD_INT 4
68685: PUSH
68686: LD_INT 5
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: ST_TO_ADDR
68695: GO 69554
68697: LD_INT 5
68699: DOUBLE
68700: EQUAL
68701: IFTRUE 68705
68703: GO 68731
68705: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68706: LD_ADDR_VAR 0 3
68710: PUSH
68711: LD_INT 2
68713: PUSH
68714: LD_INT 3
68716: PUSH
68717: LD_INT 4
68719: PUSH
68720: LD_INT 5
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: ST_TO_ADDR
68729: GO 69554
68731: LD_INT 9
68733: DOUBLE
68734: EQUAL
68735: IFTRUE 68739
68737: GO 68765
68739: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68740: LD_ADDR_VAR 0 3
68744: PUSH
68745: LD_INT 2
68747: PUSH
68748: LD_INT 3
68750: PUSH
68751: LD_INT 4
68753: PUSH
68754: LD_INT 5
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: ST_TO_ADDR
68763: GO 69554
68765: LD_INT 7
68767: DOUBLE
68768: EQUAL
68769: IFTRUE 68773
68771: GO 68799
68773: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68774: LD_ADDR_VAR 0 3
68778: PUSH
68779: LD_INT 2
68781: PUSH
68782: LD_INT 3
68784: PUSH
68785: LD_INT 4
68787: PUSH
68788: LD_INT 5
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: ST_TO_ADDR
68797: GO 69554
68799: LD_INT 12
68801: DOUBLE
68802: EQUAL
68803: IFTRUE 68807
68805: GO 68833
68807: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68808: LD_ADDR_VAR 0 3
68812: PUSH
68813: LD_INT 2
68815: PUSH
68816: LD_INT 3
68818: PUSH
68819: LD_INT 4
68821: PUSH
68822: LD_INT 5
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: ST_TO_ADDR
68831: GO 69554
68833: LD_INT 13
68835: DOUBLE
68836: EQUAL
68837: IFTRUE 68841
68839: GO 68867
68841: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68842: LD_ADDR_VAR 0 3
68846: PUSH
68847: LD_INT 2
68849: PUSH
68850: LD_INT 3
68852: PUSH
68853: LD_INT 4
68855: PUSH
68856: LD_INT 5
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: ST_TO_ADDR
68865: GO 69554
68867: LD_INT 14
68869: DOUBLE
68870: EQUAL
68871: IFTRUE 68875
68873: GO 68893
68875: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68876: LD_ADDR_VAR 0 3
68880: PUSH
68881: LD_INT 4
68883: PUSH
68884: LD_INT 5
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: ST_TO_ADDR
68891: GO 69554
68893: LD_INT 6
68895: DOUBLE
68896: EQUAL
68897: IFTRUE 68901
68899: GO 68919
68901: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68902: LD_ADDR_VAR 0 3
68906: PUSH
68907: LD_INT 4
68909: PUSH
68910: LD_INT 5
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: ST_TO_ADDR
68917: GO 69554
68919: LD_INT 10
68921: DOUBLE
68922: EQUAL
68923: IFTRUE 68927
68925: GO 68945
68927: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68928: LD_ADDR_VAR 0 3
68932: PUSH
68933: LD_INT 4
68935: PUSH
68936: LD_INT 5
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: ST_TO_ADDR
68943: GO 69554
68945: LD_INT 22
68947: DOUBLE
68948: EQUAL
68949: IFTRUE 68953
68951: GO 68979
68953: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68954: LD_ADDR_VAR 0 3
68958: PUSH
68959: LD_INT 11
68961: PUSH
68962: LD_INT 12
68964: PUSH
68965: LD_INT 13
68967: PUSH
68968: LD_INT 14
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: ST_TO_ADDR
68977: GO 69554
68979: LD_INT 23
68981: DOUBLE
68982: EQUAL
68983: IFTRUE 68987
68985: GO 69013
68987: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68988: LD_ADDR_VAR 0 3
68992: PUSH
68993: LD_INT 11
68995: PUSH
68996: LD_INT 12
68998: PUSH
68999: LD_INT 13
69001: PUSH
69002: LD_INT 14
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: ST_TO_ADDR
69011: GO 69554
69013: LD_INT 24
69015: DOUBLE
69016: EQUAL
69017: IFTRUE 69021
69019: GO 69047
69021: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69022: LD_ADDR_VAR 0 3
69026: PUSH
69027: LD_INT 11
69029: PUSH
69030: LD_INT 12
69032: PUSH
69033: LD_INT 13
69035: PUSH
69036: LD_INT 14
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: ST_TO_ADDR
69045: GO 69554
69047: LD_INT 30
69049: DOUBLE
69050: EQUAL
69051: IFTRUE 69055
69053: GO 69081
69055: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69056: LD_ADDR_VAR 0 3
69060: PUSH
69061: LD_INT 11
69063: PUSH
69064: LD_INT 12
69066: PUSH
69067: LD_INT 13
69069: PUSH
69070: LD_INT 14
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: ST_TO_ADDR
69079: GO 69554
69081: LD_INT 25
69083: DOUBLE
69084: EQUAL
69085: IFTRUE 69089
69087: GO 69107
69089: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69090: LD_ADDR_VAR 0 3
69094: PUSH
69095: LD_INT 13
69097: PUSH
69098: LD_INT 14
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: ST_TO_ADDR
69105: GO 69554
69107: LD_INT 27
69109: DOUBLE
69110: EQUAL
69111: IFTRUE 69115
69113: GO 69133
69115: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69116: LD_ADDR_VAR 0 3
69120: PUSH
69121: LD_INT 13
69123: PUSH
69124: LD_INT 14
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: ST_TO_ADDR
69131: GO 69554
69133: LD_INT 28
69135: DOUBLE
69136: EQUAL
69137: IFTRUE 69141
69139: GO 69159
69141: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69142: LD_ADDR_VAR 0 3
69146: PUSH
69147: LD_INT 13
69149: PUSH
69150: LD_INT 14
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: ST_TO_ADDR
69157: GO 69554
69159: LD_INT 29
69161: DOUBLE
69162: EQUAL
69163: IFTRUE 69167
69165: GO 69185
69167: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69168: LD_ADDR_VAR 0 3
69172: PUSH
69173: LD_INT 13
69175: PUSH
69176: LD_INT 14
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: ST_TO_ADDR
69183: GO 69554
69185: LD_INT 31
69187: DOUBLE
69188: EQUAL
69189: IFTRUE 69193
69191: GO 69211
69193: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69194: LD_ADDR_VAR 0 3
69198: PUSH
69199: LD_INT 13
69201: PUSH
69202: LD_INT 14
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: ST_TO_ADDR
69209: GO 69554
69211: LD_INT 26
69213: DOUBLE
69214: EQUAL
69215: IFTRUE 69219
69217: GO 69237
69219: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69220: LD_ADDR_VAR 0 3
69224: PUSH
69225: LD_INT 13
69227: PUSH
69228: LD_INT 14
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: ST_TO_ADDR
69235: GO 69554
69237: LD_INT 42
69239: DOUBLE
69240: EQUAL
69241: IFTRUE 69245
69243: GO 69271
69245: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69246: LD_ADDR_VAR 0 3
69250: PUSH
69251: LD_INT 21
69253: PUSH
69254: LD_INT 22
69256: PUSH
69257: LD_INT 23
69259: PUSH
69260: LD_INT 24
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: ST_TO_ADDR
69269: GO 69554
69271: LD_INT 43
69273: DOUBLE
69274: EQUAL
69275: IFTRUE 69279
69277: GO 69305
69279: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69280: LD_ADDR_VAR 0 3
69284: PUSH
69285: LD_INT 21
69287: PUSH
69288: LD_INT 22
69290: PUSH
69291: LD_INT 23
69293: PUSH
69294: LD_INT 24
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: ST_TO_ADDR
69303: GO 69554
69305: LD_INT 44
69307: DOUBLE
69308: EQUAL
69309: IFTRUE 69313
69311: GO 69339
69313: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69314: LD_ADDR_VAR 0 3
69318: PUSH
69319: LD_INT 21
69321: PUSH
69322: LD_INT 22
69324: PUSH
69325: LD_INT 23
69327: PUSH
69328: LD_INT 24
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: ST_TO_ADDR
69337: GO 69554
69339: LD_INT 45
69341: DOUBLE
69342: EQUAL
69343: IFTRUE 69347
69345: GO 69373
69347: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69348: LD_ADDR_VAR 0 3
69352: PUSH
69353: LD_INT 21
69355: PUSH
69356: LD_INT 22
69358: PUSH
69359: LD_INT 23
69361: PUSH
69362: LD_INT 24
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: LIST
69369: LIST
69370: ST_TO_ADDR
69371: GO 69554
69373: LD_INT 49
69375: DOUBLE
69376: EQUAL
69377: IFTRUE 69381
69379: GO 69407
69381: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69382: LD_ADDR_VAR 0 3
69386: PUSH
69387: LD_INT 21
69389: PUSH
69390: LD_INT 22
69392: PUSH
69393: LD_INT 23
69395: PUSH
69396: LD_INT 24
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: ST_TO_ADDR
69405: GO 69554
69407: LD_INT 51
69409: DOUBLE
69410: EQUAL
69411: IFTRUE 69415
69413: GO 69441
69415: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69416: LD_ADDR_VAR 0 3
69420: PUSH
69421: LD_INT 21
69423: PUSH
69424: LD_INT 22
69426: PUSH
69427: LD_INT 23
69429: PUSH
69430: LD_INT 24
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: LIST
69437: LIST
69438: ST_TO_ADDR
69439: GO 69554
69441: LD_INT 52
69443: DOUBLE
69444: EQUAL
69445: IFTRUE 69449
69447: GO 69475
69449: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69450: LD_ADDR_VAR 0 3
69454: PUSH
69455: LD_INT 21
69457: PUSH
69458: LD_INT 22
69460: PUSH
69461: LD_INT 23
69463: PUSH
69464: LD_INT 24
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: ST_TO_ADDR
69473: GO 69554
69475: LD_INT 53
69477: DOUBLE
69478: EQUAL
69479: IFTRUE 69483
69481: GO 69501
69483: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69484: LD_ADDR_VAR 0 3
69488: PUSH
69489: LD_INT 23
69491: PUSH
69492: LD_INT 24
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: ST_TO_ADDR
69499: GO 69554
69501: LD_INT 46
69503: DOUBLE
69504: EQUAL
69505: IFTRUE 69509
69507: GO 69527
69509: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69510: LD_ADDR_VAR 0 3
69514: PUSH
69515: LD_INT 23
69517: PUSH
69518: LD_INT 24
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: ST_TO_ADDR
69525: GO 69554
69527: LD_INT 47
69529: DOUBLE
69530: EQUAL
69531: IFTRUE 69535
69533: GO 69553
69535: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69536: LD_ADDR_VAR 0 3
69540: PUSH
69541: LD_INT 23
69543: PUSH
69544: LD_INT 24
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: ST_TO_ADDR
69551: GO 69554
69553: POP
// result := ( chassis in result ) ;
69554: LD_ADDR_VAR 0 3
69558: PUSH
69559: LD_VAR 0 1
69563: PUSH
69564: LD_VAR 0 3
69568: IN
69569: ST_TO_ADDR
// end ;
69570: LD_VAR 0 3
69574: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69575: LD_INT 0
69577: PPUSH
69578: PPUSH
69579: PPUSH
69580: PPUSH
69581: PPUSH
69582: PPUSH
69583: PPUSH
// result := array ;
69584: LD_ADDR_VAR 0 5
69588: PUSH
69589: LD_VAR 0 1
69593: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69594: LD_VAR 0 1
69598: NOT
69599: PUSH
69600: LD_VAR 0 2
69604: NOT
69605: OR
69606: PUSH
69607: LD_VAR 0 3
69611: NOT
69612: OR
69613: PUSH
69614: LD_VAR 0 2
69618: PUSH
69619: LD_VAR 0 1
69623: GREATER
69624: OR
69625: PUSH
69626: LD_VAR 0 3
69630: PUSH
69631: LD_VAR 0 1
69635: GREATER
69636: OR
69637: IFFALSE 69641
// exit ;
69639: GO 69937
// if direction then
69641: LD_VAR 0 4
69645: IFFALSE 69709
// begin d := 1 ;
69647: LD_ADDR_VAR 0 9
69651: PUSH
69652: LD_INT 1
69654: ST_TO_ADDR
// if i_from > i_to then
69655: LD_VAR 0 2
69659: PUSH
69660: LD_VAR 0 3
69664: GREATER
69665: IFFALSE 69691
// length := ( array - i_from ) + i_to else
69667: LD_ADDR_VAR 0 11
69671: PUSH
69672: LD_VAR 0 1
69676: PUSH
69677: LD_VAR 0 2
69681: MINUS
69682: PUSH
69683: LD_VAR 0 3
69687: PLUS
69688: ST_TO_ADDR
69689: GO 69707
// length := i_to - i_from ;
69691: LD_ADDR_VAR 0 11
69695: PUSH
69696: LD_VAR 0 3
69700: PUSH
69701: LD_VAR 0 2
69705: MINUS
69706: ST_TO_ADDR
// end else
69707: GO 69770
// begin d := - 1 ;
69709: LD_ADDR_VAR 0 9
69713: PUSH
69714: LD_INT 1
69716: NEG
69717: ST_TO_ADDR
// if i_from > i_to then
69718: LD_VAR 0 2
69722: PUSH
69723: LD_VAR 0 3
69727: GREATER
69728: IFFALSE 69748
// length := i_from - i_to else
69730: LD_ADDR_VAR 0 11
69734: PUSH
69735: LD_VAR 0 2
69739: PUSH
69740: LD_VAR 0 3
69744: MINUS
69745: ST_TO_ADDR
69746: GO 69770
// length := ( array - i_to ) + i_from ;
69748: LD_ADDR_VAR 0 11
69752: PUSH
69753: LD_VAR 0 1
69757: PUSH
69758: LD_VAR 0 3
69762: MINUS
69763: PUSH
69764: LD_VAR 0 2
69768: PLUS
69769: ST_TO_ADDR
// end ; if not length then
69770: LD_VAR 0 11
69774: NOT
69775: IFFALSE 69779
// exit ;
69777: GO 69937
// tmp := array ;
69779: LD_ADDR_VAR 0 10
69783: PUSH
69784: LD_VAR 0 1
69788: ST_TO_ADDR
// for i = 1 to length do
69789: LD_ADDR_VAR 0 6
69793: PUSH
69794: DOUBLE
69795: LD_INT 1
69797: DEC
69798: ST_TO_ADDR
69799: LD_VAR 0 11
69803: PUSH
69804: FOR_TO
69805: IFFALSE 69925
// begin for j = 1 to array do
69807: LD_ADDR_VAR 0 7
69811: PUSH
69812: DOUBLE
69813: LD_INT 1
69815: DEC
69816: ST_TO_ADDR
69817: LD_VAR 0 1
69821: PUSH
69822: FOR_TO
69823: IFFALSE 69911
// begin k := j + d ;
69825: LD_ADDR_VAR 0 8
69829: PUSH
69830: LD_VAR 0 7
69834: PUSH
69835: LD_VAR 0 9
69839: PLUS
69840: ST_TO_ADDR
// if k > array then
69841: LD_VAR 0 8
69845: PUSH
69846: LD_VAR 0 1
69850: GREATER
69851: IFFALSE 69861
// k := 1 ;
69853: LD_ADDR_VAR 0 8
69857: PUSH
69858: LD_INT 1
69860: ST_TO_ADDR
// if not k then
69861: LD_VAR 0 8
69865: NOT
69866: IFFALSE 69878
// k := array ;
69868: LD_ADDR_VAR 0 8
69872: PUSH
69873: LD_VAR 0 1
69877: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69878: LD_ADDR_VAR 0 10
69882: PUSH
69883: LD_VAR 0 10
69887: PPUSH
69888: LD_VAR 0 8
69892: PPUSH
69893: LD_VAR 0 1
69897: PUSH
69898: LD_VAR 0 7
69902: ARRAY
69903: PPUSH
69904: CALL_OW 1
69908: ST_TO_ADDR
// end ;
69909: GO 69822
69911: POP
69912: POP
// array := tmp ;
69913: LD_ADDR_VAR 0 1
69917: PUSH
69918: LD_VAR 0 10
69922: ST_TO_ADDR
// end ;
69923: GO 69804
69925: POP
69926: POP
// result := array ;
69927: LD_ADDR_VAR 0 5
69931: PUSH
69932: LD_VAR 0 1
69936: ST_TO_ADDR
// end ;
69937: LD_VAR 0 5
69941: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69942: LD_INT 0
69944: PPUSH
69945: PPUSH
// result := 0 ;
69946: LD_ADDR_VAR 0 3
69950: PUSH
69951: LD_INT 0
69953: ST_TO_ADDR
// if not array or not value in array then
69954: LD_VAR 0 1
69958: NOT
69959: PUSH
69960: LD_VAR 0 2
69964: PUSH
69965: LD_VAR 0 1
69969: IN
69970: NOT
69971: OR
69972: IFFALSE 69976
// exit ;
69974: GO 70030
// for i = 1 to array do
69976: LD_ADDR_VAR 0 4
69980: PUSH
69981: DOUBLE
69982: LD_INT 1
69984: DEC
69985: ST_TO_ADDR
69986: LD_VAR 0 1
69990: PUSH
69991: FOR_TO
69992: IFFALSE 70028
// if value = array [ i ] then
69994: LD_VAR 0 2
69998: PUSH
69999: LD_VAR 0 1
70003: PUSH
70004: LD_VAR 0 4
70008: ARRAY
70009: EQUAL
70010: IFFALSE 70026
// begin result := i ;
70012: LD_ADDR_VAR 0 3
70016: PUSH
70017: LD_VAR 0 4
70021: ST_TO_ADDR
// exit ;
70022: POP
70023: POP
70024: GO 70030
// end ;
70026: GO 69991
70028: POP
70029: POP
// end ;
70030: LD_VAR 0 3
70034: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70035: LD_INT 0
70037: PPUSH
// vc_chassis := chassis ;
70038: LD_ADDR_OWVAR 37
70042: PUSH
70043: LD_VAR 0 1
70047: ST_TO_ADDR
// vc_engine := engine ;
70048: LD_ADDR_OWVAR 39
70052: PUSH
70053: LD_VAR 0 2
70057: ST_TO_ADDR
// vc_control := control ;
70058: LD_ADDR_OWVAR 38
70062: PUSH
70063: LD_VAR 0 3
70067: ST_TO_ADDR
// vc_weapon := weapon ;
70068: LD_ADDR_OWVAR 40
70072: PUSH
70073: LD_VAR 0 4
70077: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70078: LD_ADDR_OWVAR 41
70082: PUSH
70083: LD_VAR 0 5
70087: ST_TO_ADDR
// end ;
70088: LD_VAR 0 6
70092: RET
// export function WantPlant ( unit ) ; var task ; begin
70093: LD_INT 0
70095: PPUSH
70096: PPUSH
// result := false ;
70097: LD_ADDR_VAR 0 2
70101: PUSH
70102: LD_INT 0
70104: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70105: LD_ADDR_VAR 0 3
70109: PUSH
70110: LD_VAR 0 1
70114: PPUSH
70115: CALL_OW 437
70119: ST_TO_ADDR
// if task then
70120: LD_VAR 0 3
70124: IFFALSE 70152
// if task [ 1 ] [ 1 ] = p then
70126: LD_VAR 0 3
70130: PUSH
70131: LD_INT 1
70133: ARRAY
70134: PUSH
70135: LD_INT 1
70137: ARRAY
70138: PUSH
70139: LD_STRING p
70141: EQUAL
70142: IFFALSE 70152
// result := true ;
70144: LD_ADDR_VAR 0 2
70148: PUSH
70149: LD_INT 1
70151: ST_TO_ADDR
// end ;
70152: LD_VAR 0 2
70156: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70157: LD_INT 0
70159: PPUSH
70160: PPUSH
70161: PPUSH
70162: PPUSH
// if pos < 1 then
70163: LD_VAR 0 2
70167: PUSH
70168: LD_INT 1
70170: LESS
70171: IFFALSE 70175
// exit ;
70173: GO 70478
// if pos = 1 then
70175: LD_VAR 0 2
70179: PUSH
70180: LD_INT 1
70182: EQUAL
70183: IFFALSE 70216
// result := Replace ( arr , pos [ 1 ] , value ) else
70185: LD_ADDR_VAR 0 4
70189: PUSH
70190: LD_VAR 0 1
70194: PPUSH
70195: LD_VAR 0 2
70199: PUSH
70200: LD_INT 1
70202: ARRAY
70203: PPUSH
70204: LD_VAR 0 3
70208: PPUSH
70209: CALL_OW 1
70213: ST_TO_ADDR
70214: GO 70478
// begin tmp := arr ;
70216: LD_ADDR_VAR 0 6
70220: PUSH
70221: LD_VAR 0 1
70225: ST_TO_ADDR
// s_arr := [ tmp ] ;
70226: LD_ADDR_VAR 0 7
70230: PUSH
70231: LD_VAR 0 6
70235: PUSH
70236: EMPTY
70237: LIST
70238: ST_TO_ADDR
// for i = 1 to pos - 1 do
70239: LD_ADDR_VAR 0 5
70243: PUSH
70244: DOUBLE
70245: LD_INT 1
70247: DEC
70248: ST_TO_ADDR
70249: LD_VAR 0 2
70253: PUSH
70254: LD_INT 1
70256: MINUS
70257: PUSH
70258: FOR_TO
70259: IFFALSE 70304
// begin tmp := tmp [ pos [ i ] ] ;
70261: LD_ADDR_VAR 0 6
70265: PUSH
70266: LD_VAR 0 6
70270: PUSH
70271: LD_VAR 0 2
70275: PUSH
70276: LD_VAR 0 5
70280: ARRAY
70281: ARRAY
70282: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70283: LD_ADDR_VAR 0 7
70287: PUSH
70288: LD_VAR 0 7
70292: PUSH
70293: LD_VAR 0 6
70297: PUSH
70298: EMPTY
70299: LIST
70300: ADD
70301: ST_TO_ADDR
// end ;
70302: GO 70258
70304: POP
70305: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70306: LD_ADDR_VAR 0 6
70310: PUSH
70311: LD_VAR 0 6
70315: PPUSH
70316: LD_VAR 0 2
70320: PUSH
70321: LD_VAR 0 2
70325: ARRAY
70326: PPUSH
70327: LD_VAR 0 3
70331: PPUSH
70332: CALL_OW 1
70336: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70337: LD_ADDR_VAR 0 7
70341: PUSH
70342: LD_VAR 0 7
70346: PPUSH
70347: LD_VAR 0 7
70351: PPUSH
70352: LD_VAR 0 6
70356: PPUSH
70357: CALL_OW 1
70361: ST_TO_ADDR
// for i = s_arr downto 2 do
70362: LD_ADDR_VAR 0 5
70366: PUSH
70367: DOUBLE
70368: LD_VAR 0 7
70372: INC
70373: ST_TO_ADDR
70374: LD_INT 2
70376: PUSH
70377: FOR_DOWNTO
70378: IFFALSE 70462
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70380: LD_ADDR_VAR 0 6
70384: PUSH
70385: LD_VAR 0 7
70389: PUSH
70390: LD_VAR 0 5
70394: PUSH
70395: LD_INT 1
70397: MINUS
70398: ARRAY
70399: PPUSH
70400: LD_VAR 0 2
70404: PUSH
70405: LD_VAR 0 5
70409: PUSH
70410: LD_INT 1
70412: MINUS
70413: ARRAY
70414: PPUSH
70415: LD_VAR 0 7
70419: PUSH
70420: LD_VAR 0 5
70424: ARRAY
70425: PPUSH
70426: CALL_OW 1
70430: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70431: LD_ADDR_VAR 0 7
70435: PUSH
70436: LD_VAR 0 7
70440: PPUSH
70441: LD_VAR 0 5
70445: PUSH
70446: LD_INT 1
70448: MINUS
70449: PPUSH
70450: LD_VAR 0 6
70454: PPUSH
70455: CALL_OW 1
70459: ST_TO_ADDR
// end ;
70460: GO 70377
70462: POP
70463: POP
// result := s_arr [ 1 ] ;
70464: LD_ADDR_VAR 0 4
70468: PUSH
70469: LD_VAR 0 7
70473: PUSH
70474: LD_INT 1
70476: ARRAY
70477: ST_TO_ADDR
// end ; end ;
70478: LD_VAR 0 4
70482: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70483: LD_INT 0
70485: PPUSH
70486: PPUSH
// if not list then
70487: LD_VAR 0 1
70491: NOT
70492: IFFALSE 70496
// exit ;
70494: GO 70587
// i := list [ pos1 ] ;
70496: LD_ADDR_VAR 0 5
70500: PUSH
70501: LD_VAR 0 1
70505: PUSH
70506: LD_VAR 0 2
70510: ARRAY
70511: ST_TO_ADDR
// if not i then
70512: LD_VAR 0 5
70516: NOT
70517: IFFALSE 70521
// exit ;
70519: GO 70587
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70521: LD_ADDR_VAR 0 1
70525: PUSH
70526: LD_VAR 0 1
70530: PPUSH
70531: LD_VAR 0 2
70535: PPUSH
70536: LD_VAR 0 1
70540: PUSH
70541: LD_VAR 0 3
70545: ARRAY
70546: PPUSH
70547: CALL_OW 1
70551: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70552: LD_ADDR_VAR 0 1
70556: PUSH
70557: LD_VAR 0 1
70561: PPUSH
70562: LD_VAR 0 3
70566: PPUSH
70567: LD_VAR 0 5
70571: PPUSH
70572: CALL_OW 1
70576: ST_TO_ADDR
// result := list ;
70577: LD_ADDR_VAR 0 4
70581: PUSH
70582: LD_VAR 0 1
70586: ST_TO_ADDR
// end ;
70587: LD_VAR 0 4
70591: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70592: LD_INT 0
70594: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70595: LD_ADDR_VAR 0 5
70599: PUSH
70600: LD_VAR 0 1
70604: PPUSH
70605: CALL_OW 250
70609: PPUSH
70610: LD_VAR 0 1
70614: PPUSH
70615: CALL_OW 251
70619: PPUSH
70620: LD_VAR 0 2
70624: PPUSH
70625: LD_VAR 0 3
70629: PPUSH
70630: LD_VAR 0 4
70634: PPUSH
70635: CALL 70645 0 5
70639: ST_TO_ADDR
// end ;
70640: LD_VAR 0 5
70644: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70645: LD_INT 0
70647: PPUSH
70648: PPUSH
70649: PPUSH
70650: PPUSH
// if not list then
70651: LD_VAR 0 3
70655: NOT
70656: IFFALSE 70660
// exit ;
70658: GO 71048
// result := [ ] ;
70660: LD_ADDR_VAR 0 6
70664: PUSH
70665: EMPTY
70666: ST_TO_ADDR
// for i in list do
70667: LD_ADDR_VAR 0 7
70671: PUSH
70672: LD_VAR 0 3
70676: PUSH
70677: FOR_IN
70678: IFFALSE 70880
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70680: LD_ADDR_VAR 0 9
70684: PUSH
70685: LD_VAR 0 7
70689: PPUSH
70690: LD_VAR 0 1
70694: PPUSH
70695: LD_VAR 0 2
70699: PPUSH
70700: CALL_OW 297
70704: ST_TO_ADDR
// if not result then
70705: LD_VAR 0 6
70709: NOT
70710: IFFALSE 70736
// result := [ [ i , tmp ] ] else
70712: LD_ADDR_VAR 0 6
70716: PUSH
70717: LD_VAR 0 7
70721: PUSH
70722: LD_VAR 0 9
70726: PUSH
70727: EMPTY
70728: LIST
70729: LIST
70730: PUSH
70731: EMPTY
70732: LIST
70733: ST_TO_ADDR
70734: GO 70878
// begin if result [ result ] [ 2 ] < tmp then
70736: LD_VAR 0 6
70740: PUSH
70741: LD_VAR 0 6
70745: ARRAY
70746: PUSH
70747: LD_INT 2
70749: ARRAY
70750: PUSH
70751: LD_VAR 0 9
70755: LESS
70756: IFFALSE 70798
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70758: LD_ADDR_VAR 0 6
70762: PUSH
70763: LD_VAR 0 6
70767: PPUSH
70768: LD_VAR 0 6
70772: PUSH
70773: LD_INT 1
70775: PLUS
70776: PPUSH
70777: LD_VAR 0 7
70781: PUSH
70782: LD_VAR 0 9
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: PPUSH
70791: CALL_OW 2
70795: ST_TO_ADDR
70796: GO 70878
// for j = 1 to result do
70798: LD_ADDR_VAR 0 8
70802: PUSH
70803: DOUBLE
70804: LD_INT 1
70806: DEC
70807: ST_TO_ADDR
70808: LD_VAR 0 6
70812: PUSH
70813: FOR_TO
70814: IFFALSE 70876
// begin if tmp < result [ j ] [ 2 ] then
70816: LD_VAR 0 9
70820: PUSH
70821: LD_VAR 0 6
70825: PUSH
70826: LD_VAR 0 8
70830: ARRAY
70831: PUSH
70832: LD_INT 2
70834: ARRAY
70835: LESS
70836: IFFALSE 70874
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70838: LD_ADDR_VAR 0 6
70842: PUSH
70843: LD_VAR 0 6
70847: PPUSH
70848: LD_VAR 0 8
70852: PPUSH
70853: LD_VAR 0 7
70857: PUSH
70858: LD_VAR 0 9
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PPUSH
70867: CALL_OW 2
70871: ST_TO_ADDR
// break ;
70872: GO 70876
// end ; end ;
70874: GO 70813
70876: POP
70877: POP
// end ; end ;
70878: GO 70677
70880: POP
70881: POP
// if result and not asc then
70882: LD_VAR 0 6
70886: PUSH
70887: LD_VAR 0 4
70891: NOT
70892: AND
70893: IFFALSE 70968
// begin tmp := result ;
70895: LD_ADDR_VAR 0 9
70899: PUSH
70900: LD_VAR 0 6
70904: ST_TO_ADDR
// for i = tmp downto 1 do
70905: LD_ADDR_VAR 0 7
70909: PUSH
70910: DOUBLE
70911: LD_VAR 0 9
70915: INC
70916: ST_TO_ADDR
70917: LD_INT 1
70919: PUSH
70920: FOR_DOWNTO
70921: IFFALSE 70966
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70923: LD_ADDR_VAR 0 6
70927: PUSH
70928: LD_VAR 0 6
70932: PPUSH
70933: LD_VAR 0 9
70937: PUSH
70938: LD_VAR 0 7
70942: MINUS
70943: PUSH
70944: LD_INT 1
70946: PLUS
70947: PPUSH
70948: LD_VAR 0 9
70952: PUSH
70953: LD_VAR 0 7
70957: ARRAY
70958: PPUSH
70959: CALL_OW 1
70963: ST_TO_ADDR
70964: GO 70920
70966: POP
70967: POP
// end ; tmp := [ ] ;
70968: LD_ADDR_VAR 0 9
70972: PUSH
70973: EMPTY
70974: ST_TO_ADDR
// if mode then
70975: LD_VAR 0 5
70979: IFFALSE 71048
// begin for i = 1 to result do
70981: LD_ADDR_VAR 0 7
70985: PUSH
70986: DOUBLE
70987: LD_INT 1
70989: DEC
70990: ST_TO_ADDR
70991: LD_VAR 0 6
70995: PUSH
70996: FOR_TO
70997: IFFALSE 71036
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70999: LD_ADDR_VAR 0 9
71003: PUSH
71004: LD_VAR 0 9
71008: PPUSH
71009: LD_VAR 0 7
71013: PPUSH
71014: LD_VAR 0 6
71018: PUSH
71019: LD_VAR 0 7
71023: ARRAY
71024: PUSH
71025: LD_INT 1
71027: ARRAY
71028: PPUSH
71029: CALL_OW 1
71033: ST_TO_ADDR
71034: GO 70996
71036: POP
71037: POP
// result := tmp ;
71038: LD_ADDR_VAR 0 6
71042: PUSH
71043: LD_VAR 0 9
71047: ST_TO_ADDR
// end ; end ;
71048: LD_VAR 0 6
71052: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71053: LD_INT 0
71055: PPUSH
71056: PPUSH
71057: PPUSH
71058: PPUSH
71059: PPUSH
71060: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71061: LD_ADDR_VAR 0 5
71065: PUSH
71066: LD_INT 0
71068: PUSH
71069: LD_INT 0
71071: PUSH
71072: LD_INT 0
71074: PUSH
71075: EMPTY
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: ST_TO_ADDR
// if not x or not y then
71083: LD_VAR 0 2
71087: NOT
71088: PUSH
71089: LD_VAR 0 3
71093: NOT
71094: OR
71095: IFFALSE 71099
// exit ;
71097: GO 72745
// if not range then
71099: LD_VAR 0 4
71103: NOT
71104: IFFALSE 71114
// range := 10 ;
71106: LD_ADDR_VAR 0 4
71110: PUSH
71111: LD_INT 10
71113: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71114: LD_ADDR_VAR 0 8
71118: PUSH
71119: LD_INT 81
71121: PUSH
71122: LD_VAR 0 1
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: PUSH
71131: LD_INT 92
71133: PUSH
71134: LD_VAR 0 2
71138: PUSH
71139: LD_VAR 0 3
71143: PUSH
71144: LD_VAR 0 4
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 3
71157: PUSH
71158: LD_INT 21
71160: PUSH
71161: LD_INT 3
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: LIST
71176: PPUSH
71177: CALL_OW 69
71181: ST_TO_ADDR
// if not tmp then
71182: LD_VAR 0 8
71186: NOT
71187: IFFALSE 71191
// exit ;
71189: GO 72745
// for i in tmp do
71191: LD_ADDR_VAR 0 6
71195: PUSH
71196: LD_VAR 0 8
71200: PUSH
71201: FOR_IN
71202: IFFALSE 72720
// begin points := [ 0 , 0 , 0 ] ;
71204: LD_ADDR_VAR 0 9
71208: PUSH
71209: LD_INT 0
71211: PUSH
71212: LD_INT 0
71214: PUSH
71215: LD_INT 0
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: LIST
71222: ST_TO_ADDR
// bpoints := 1 ;
71223: LD_ADDR_VAR 0 10
71227: PUSH
71228: LD_INT 1
71230: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71231: LD_VAR 0 6
71235: PPUSH
71236: CALL_OW 247
71240: PUSH
71241: LD_INT 1
71243: DOUBLE
71244: EQUAL
71245: IFTRUE 71249
71247: GO 71827
71249: POP
// begin if GetClass ( i ) = 1 then
71250: LD_VAR 0 6
71254: PPUSH
71255: CALL_OW 257
71259: PUSH
71260: LD_INT 1
71262: EQUAL
71263: IFFALSE 71284
// points := [ 10 , 5 , 3 ] ;
71265: LD_ADDR_VAR 0 9
71269: PUSH
71270: LD_INT 10
71272: PUSH
71273: LD_INT 5
71275: PUSH
71276: LD_INT 3
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: LIST
71283: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71284: LD_VAR 0 6
71288: PPUSH
71289: CALL_OW 257
71293: PUSH
71294: LD_INT 2
71296: PUSH
71297: LD_INT 3
71299: PUSH
71300: LD_INT 4
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: LIST
71307: IN
71308: IFFALSE 71329
// points := [ 3 , 2 , 1 ] ;
71310: LD_ADDR_VAR 0 9
71314: PUSH
71315: LD_INT 3
71317: PUSH
71318: LD_INT 2
71320: PUSH
71321: LD_INT 1
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: LIST
71328: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71329: LD_VAR 0 6
71333: PPUSH
71334: CALL_OW 257
71338: PUSH
71339: LD_INT 5
71341: EQUAL
71342: IFFALSE 71363
// points := [ 130 , 5 , 2 ] ;
71344: LD_ADDR_VAR 0 9
71348: PUSH
71349: LD_INT 130
71351: PUSH
71352: LD_INT 5
71354: PUSH
71355: LD_INT 2
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: LIST
71362: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71363: LD_VAR 0 6
71367: PPUSH
71368: CALL_OW 257
71372: PUSH
71373: LD_INT 8
71375: EQUAL
71376: IFFALSE 71397
// points := [ 35 , 35 , 30 ] ;
71378: LD_ADDR_VAR 0 9
71382: PUSH
71383: LD_INT 35
71385: PUSH
71386: LD_INT 35
71388: PUSH
71389: LD_INT 30
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: LIST
71396: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71397: LD_VAR 0 6
71401: PPUSH
71402: CALL_OW 257
71406: PUSH
71407: LD_INT 9
71409: EQUAL
71410: IFFALSE 71431
// points := [ 20 , 55 , 40 ] ;
71412: LD_ADDR_VAR 0 9
71416: PUSH
71417: LD_INT 20
71419: PUSH
71420: LD_INT 55
71422: PUSH
71423: LD_INT 40
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: LIST
71430: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71431: LD_VAR 0 6
71435: PPUSH
71436: CALL_OW 257
71440: PUSH
71441: LD_INT 12
71443: PUSH
71444: LD_INT 16
71446: PUSH
71447: EMPTY
71448: LIST
71449: LIST
71450: IN
71451: IFFALSE 71472
// points := [ 5 , 3 , 2 ] ;
71453: LD_ADDR_VAR 0 9
71457: PUSH
71458: LD_INT 5
71460: PUSH
71461: LD_INT 3
71463: PUSH
71464: LD_INT 2
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: LIST
71471: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71472: LD_VAR 0 6
71476: PPUSH
71477: CALL_OW 257
71481: PUSH
71482: LD_INT 17
71484: EQUAL
71485: IFFALSE 71506
// points := [ 100 , 50 , 75 ] ;
71487: LD_ADDR_VAR 0 9
71491: PUSH
71492: LD_INT 100
71494: PUSH
71495: LD_INT 50
71497: PUSH
71498: LD_INT 75
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: LIST
71505: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71506: LD_VAR 0 6
71510: PPUSH
71511: CALL_OW 257
71515: PUSH
71516: LD_INT 15
71518: EQUAL
71519: IFFALSE 71540
// points := [ 10 , 5 , 3 ] ;
71521: LD_ADDR_VAR 0 9
71525: PUSH
71526: LD_INT 10
71528: PUSH
71529: LD_INT 5
71531: PUSH
71532: LD_INT 3
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: LIST
71539: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71540: LD_VAR 0 6
71544: PPUSH
71545: CALL_OW 257
71549: PUSH
71550: LD_INT 14
71552: EQUAL
71553: IFFALSE 71574
// points := [ 10 , 0 , 0 ] ;
71555: LD_ADDR_VAR 0 9
71559: PUSH
71560: LD_INT 10
71562: PUSH
71563: LD_INT 0
71565: PUSH
71566: LD_INT 0
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: LIST
71573: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71574: LD_VAR 0 6
71578: PPUSH
71579: CALL_OW 257
71583: PUSH
71584: LD_INT 11
71586: EQUAL
71587: IFFALSE 71608
// points := [ 30 , 10 , 5 ] ;
71589: LD_ADDR_VAR 0 9
71593: PUSH
71594: LD_INT 30
71596: PUSH
71597: LD_INT 10
71599: PUSH
71600: LD_INT 5
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: LIST
71607: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71608: LD_VAR 0 1
71612: PPUSH
71613: LD_INT 5
71615: PPUSH
71616: CALL_OW 321
71620: PUSH
71621: LD_INT 2
71623: EQUAL
71624: IFFALSE 71641
// bpoints := bpoints * 1.8 ;
71626: LD_ADDR_VAR 0 10
71630: PUSH
71631: LD_VAR 0 10
71635: PUSH
71636: LD_REAL  1.80000000000000E+0000
71639: MUL
71640: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71641: LD_VAR 0 6
71645: PPUSH
71646: CALL_OW 257
71650: PUSH
71651: LD_INT 1
71653: PUSH
71654: LD_INT 2
71656: PUSH
71657: LD_INT 3
71659: PUSH
71660: LD_INT 4
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: IN
71669: PUSH
71670: LD_VAR 0 1
71674: PPUSH
71675: LD_INT 51
71677: PPUSH
71678: CALL_OW 321
71682: PUSH
71683: LD_INT 2
71685: EQUAL
71686: AND
71687: IFFALSE 71704
// bpoints := bpoints * 1.2 ;
71689: LD_ADDR_VAR 0 10
71693: PUSH
71694: LD_VAR 0 10
71698: PUSH
71699: LD_REAL  1.20000000000000E+0000
71702: MUL
71703: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71704: LD_VAR 0 6
71708: PPUSH
71709: CALL_OW 257
71713: PUSH
71714: LD_INT 5
71716: PUSH
71717: LD_INT 7
71719: PUSH
71720: LD_INT 9
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: LIST
71727: IN
71728: PUSH
71729: LD_VAR 0 1
71733: PPUSH
71734: LD_INT 52
71736: PPUSH
71737: CALL_OW 321
71741: PUSH
71742: LD_INT 2
71744: EQUAL
71745: AND
71746: IFFALSE 71763
// bpoints := bpoints * 1.5 ;
71748: LD_ADDR_VAR 0 10
71752: PUSH
71753: LD_VAR 0 10
71757: PUSH
71758: LD_REAL  1.50000000000000E+0000
71761: MUL
71762: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71763: LD_VAR 0 1
71767: PPUSH
71768: LD_INT 66
71770: PPUSH
71771: CALL_OW 321
71775: PUSH
71776: LD_INT 2
71778: EQUAL
71779: IFFALSE 71796
// bpoints := bpoints * 1.1 ;
71781: LD_ADDR_VAR 0 10
71785: PUSH
71786: LD_VAR 0 10
71790: PUSH
71791: LD_REAL  1.10000000000000E+0000
71794: MUL
71795: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71796: LD_ADDR_VAR 0 10
71800: PUSH
71801: LD_VAR 0 10
71805: PUSH
71806: LD_VAR 0 6
71810: PPUSH
71811: LD_INT 1
71813: PPUSH
71814: CALL_OW 259
71818: PUSH
71819: LD_REAL  1.15000000000000E+0000
71822: MUL
71823: MUL
71824: ST_TO_ADDR
// end ; unit_vehicle :
71825: GO 72649
71827: LD_INT 2
71829: DOUBLE
71830: EQUAL
71831: IFTRUE 71835
71833: GO 72637
71835: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71836: LD_VAR 0 6
71840: PPUSH
71841: CALL_OW 264
71845: PUSH
71846: LD_INT 2
71848: PUSH
71849: LD_INT 42
71851: PUSH
71852: LD_INT 24
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: LIST
71859: IN
71860: IFFALSE 71881
// points := [ 25 , 5 , 3 ] ;
71862: LD_ADDR_VAR 0 9
71866: PUSH
71867: LD_INT 25
71869: PUSH
71870: LD_INT 5
71872: PUSH
71873: LD_INT 3
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: LIST
71880: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71881: LD_VAR 0 6
71885: PPUSH
71886: CALL_OW 264
71890: PUSH
71891: LD_INT 4
71893: PUSH
71894: LD_INT 43
71896: PUSH
71897: LD_INT 25
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: LIST
71904: IN
71905: IFFALSE 71926
// points := [ 40 , 15 , 5 ] ;
71907: LD_ADDR_VAR 0 9
71911: PUSH
71912: LD_INT 40
71914: PUSH
71915: LD_INT 15
71917: PUSH
71918: LD_INT 5
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: LIST
71925: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71926: LD_VAR 0 6
71930: PPUSH
71931: CALL_OW 264
71935: PUSH
71936: LD_INT 3
71938: PUSH
71939: LD_INT 23
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: IN
71946: IFFALSE 71967
// points := [ 7 , 25 , 8 ] ;
71948: LD_ADDR_VAR 0 9
71952: PUSH
71953: LD_INT 7
71955: PUSH
71956: LD_INT 25
71958: PUSH
71959: LD_INT 8
71961: PUSH
71962: EMPTY
71963: LIST
71964: LIST
71965: LIST
71966: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71967: LD_VAR 0 6
71971: PPUSH
71972: CALL_OW 264
71976: PUSH
71977: LD_INT 5
71979: PUSH
71980: LD_INT 27
71982: PUSH
71983: LD_INT 44
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: LIST
71990: IN
71991: IFFALSE 72012
// points := [ 14 , 50 , 16 ] ;
71993: LD_ADDR_VAR 0 9
71997: PUSH
71998: LD_INT 14
72000: PUSH
72001: LD_INT 50
72003: PUSH
72004: LD_INT 16
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: LIST
72011: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72012: LD_VAR 0 6
72016: PPUSH
72017: CALL_OW 264
72021: PUSH
72022: LD_INT 6
72024: PUSH
72025: LD_INT 46
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: IN
72032: IFFALSE 72053
// points := [ 32 , 120 , 70 ] ;
72034: LD_ADDR_VAR 0 9
72038: PUSH
72039: LD_INT 32
72041: PUSH
72042: LD_INT 120
72044: PUSH
72045: LD_INT 70
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: LIST
72052: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
72053: LD_VAR 0 6
72057: PPUSH
72058: CALL_OW 264
72062: PUSH
72063: LD_INT 7
72065: PUSH
72066: LD_INT 28
72068: PUSH
72069: LD_INT 45
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: LIST
72076: IN
72077: IFFALSE 72098
// points := [ 35 , 20 , 45 ] ;
72079: LD_ADDR_VAR 0 9
72083: PUSH
72084: LD_INT 35
72086: PUSH
72087: LD_INT 20
72089: PUSH
72090: LD_INT 45
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: LIST
72097: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72098: LD_VAR 0 6
72102: PPUSH
72103: CALL_OW 264
72107: PUSH
72108: LD_INT 47
72110: PUSH
72111: EMPTY
72112: LIST
72113: IN
72114: IFFALSE 72135
// points := [ 67 , 45 , 75 ] ;
72116: LD_ADDR_VAR 0 9
72120: PUSH
72121: LD_INT 67
72123: PUSH
72124: LD_INT 45
72126: PUSH
72127: LD_INT 75
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: LIST
72134: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72135: LD_VAR 0 6
72139: PPUSH
72140: CALL_OW 264
72144: PUSH
72145: LD_INT 26
72147: PUSH
72148: EMPTY
72149: LIST
72150: IN
72151: IFFALSE 72172
// points := [ 120 , 30 , 80 ] ;
72153: LD_ADDR_VAR 0 9
72157: PUSH
72158: LD_INT 120
72160: PUSH
72161: LD_INT 30
72163: PUSH
72164: LD_INT 80
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: LIST
72171: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72172: LD_VAR 0 6
72176: PPUSH
72177: CALL_OW 264
72181: PUSH
72182: LD_INT 22
72184: PUSH
72185: EMPTY
72186: LIST
72187: IN
72188: IFFALSE 72209
// points := [ 40 , 1 , 1 ] ;
72190: LD_ADDR_VAR 0 9
72194: PUSH
72195: LD_INT 40
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 1
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: LIST
72208: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72209: LD_VAR 0 6
72213: PPUSH
72214: CALL_OW 264
72218: PUSH
72219: LD_INT 29
72221: PUSH
72222: EMPTY
72223: LIST
72224: IN
72225: IFFALSE 72246
// points := [ 70 , 200 , 400 ] ;
72227: LD_ADDR_VAR 0 9
72231: PUSH
72232: LD_INT 70
72234: PUSH
72235: LD_INT 200
72237: PUSH
72238: LD_INT 400
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: LIST
72245: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72246: LD_VAR 0 6
72250: PPUSH
72251: CALL_OW 264
72255: PUSH
72256: LD_INT 14
72258: PUSH
72259: LD_INT 53
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: IN
72266: IFFALSE 72287
// points := [ 40 , 10 , 20 ] ;
72268: LD_ADDR_VAR 0 9
72272: PUSH
72273: LD_INT 40
72275: PUSH
72276: LD_INT 10
72278: PUSH
72279: LD_INT 20
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: LIST
72286: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72287: LD_VAR 0 6
72291: PPUSH
72292: CALL_OW 264
72296: PUSH
72297: LD_INT 9
72299: PUSH
72300: EMPTY
72301: LIST
72302: IN
72303: IFFALSE 72324
// points := [ 5 , 70 , 20 ] ;
72305: LD_ADDR_VAR 0 9
72309: PUSH
72310: LD_INT 5
72312: PUSH
72313: LD_INT 70
72315: PUSH
72316: LD_INT 20
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: LIST
72323: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72324: LD_VAR 0 6
72328: PPUSH
72329: CALL_OW 264
72333: PUSH
72334: LD_INT 10
72336: PUSH
72337: EMPTY
72338: LIST
72339: IN
72340: IFFALSE 72361
// points := [ 35 , 110 , 70 ] ;
72342: LD_ADDR_VAR 0 9
72346: PUSH
72347: LD_INT 35
72349: PUSH
72350: LD_INT 110
72352: PUSH
72353: LD_INT 70
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: LIST
72360: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72361: LD_VAR 0 6
72365: PPUSH
72366: CALL_OW 265
72370: PUSH
72371: LD_INT 25
72373: EQUAL
72374: IFFALSE 72395
// points := [ 80 , 65 , 100 ] ;
72376: LD_ADDR_VAR 0 9
72380: PUSH
72381: LD_INT 80
72383: PUSH
72384: LD_INT 65
72386: PUSH
72387: LD_INT 100
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: LIST
72394: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72395: LD_VAR 0 6
72399: PPUSH
72400: CALL_OW 263
72404: PUSH
72405: LD_INT 1
72407: EQUAL
72408: IFFALSE 72443
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72410: LD_ADDR_VAR 0 10
72414: PUSH
72415: LD_VAR 0 10
72419: PUSH
72420: LD_VAR 0 6
72424: PPUSH
72425: CALL_OW 311
72429: PPUSH
72430: LD_INT 3
72432: PPUSH
72433: CALL_OW 259
72437: PUSH
72438: LD_INT 4
72440: MUL
72441: MUL
72442: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72443: LD_VAR 0 6
72447: PPUSH
72448: CALL_OW 263
72452: PUSH
72453: LD_INT 2
72455: EQUAL
72456: IFFALSE 72507
// begin j := IsControledBy ( i ) ;
72458: LD_ADDR_VAR 0 7
72462: PUSH
72463: LD_VAR 0 6
72467: PPUSH
72468: CALL_OW 312
72472: ST_TO_ADDR
// if j then
72473: LD_VAR 0 7
72477: IFFALSE 72507
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72479: LD_ADDR_VAR 0 10
72483: PUSH
72484: LD_VAR 0 10
72488: PUSH
72489: LD_VAR 0 7
72493: PPUSH
72494: LD_INT 3
72496: PPUSH
72497: CALL_OW 259
72501: PUSH
72502: LD_INT 3
72504: MUL
72505: MUL
72506: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72507: LD_VAR 0 6
72511: PPUSH
72512: CALL_OW 264
72516: PUSH
72517: LD_INT 5
72519: PUSH
72520: LD_INT 6
72522: PUSH
72523: LD_INT 46
72525: PUSH
72526: LD_INT 44
72528: PUSH
72529: LD_INT 47
72531: PUSH
72532: LD_INT 45
72534: PUSH
72535: LD_INT 28
72537: PUSH
72538: LD_INT 7
72540: PUSH
72541: LD_INT 27
72543: PUSH
72544: LD_INT 29
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: LIST
72558: IN
72559: PUSH
72560: LD_VAR 0 1
72564: PPUSH
72565: LD_INT 52
72567: PPUSH
72568: CALL_OW 321
72572: PUSH
72573: LD_INT 2
72575: EQUAL
72576: AND
72577: IFFALSE 72594
// bpoints := bpoints * 1.2 ;
72579: LD_ADDR_VAR 0 10
72583: PUSH
72584: LD_VAR 0 10
72588: PUSH
72589: LD_REAL  1.20000000000000E+0000
72592: MUL
72593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72594: LD_VAR 0 6
72598: PPUSH
72599: CALL_OW 264
72603: PUSH
72604: LD_INT 6
72606: PUSH
72607: LD_INT 46
72609: PUSH
72610: LD_INT 47
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: LIST
72617: IN
72618: IFFALSE 72635
// bpoints := bpoints * 1.2 ;
72620: LD_ADDR_VAR 0 10
72624: PUSH
72625: LD_VAR 0 10
72629: PUSH
72630: LD_REAL  1.20000000000000E+0000
72633: MUL
72634: ST_TO_ADDR
// end ; unit_building :
72635: GO 72649
72637: LD_INT 3
72639: DOUBLE
72640: EQUAL
72641: IFTRUE 72645
72643: GO 72648
72645: POP
// ; end ;
72646: GO 72649
72648: POP
// for j = 1 to 3 do
72649: LD_ADDR_VAR 0 7
72653: PUSH
72654: DOUBLE
72655: LD_INT 1
72657: DEC
72658: ST_TO_ADDR
72659: LD_INT 3
72661: PUSH
72662: FOR_TO
72663: IFFALSE 72716
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72665: LD_ADDR_VAR 0 5
72669: PUSH
72670: LD_VAR 0 5
72674: PPUSH
72675: LD_VAR 0 7
72679: PPUSH
72680: LD_VAR 0 5
72684: PUSH
72685: LD_VAR 0 7
72689: ARRAY
72690: PUSH
72691: LD_VAR 0 9
72695: PUSH
72696: LD_VAR 0 7
72700: ARRAY
72701: PUSH
72702: LD_VAR 0 10
72706: MUL
72707: PLUS
72708: PPUSH
72709: CALL_OW 1
72713: ST_TO_ADDR
72714: GO 72662
72716: POP
72717: POP
// end ;
72718: GO 71201
72720: POP
72721: POP
// result := Replace ( result , 4 , tmp ) ;
72722: LD_ADDR_VAR 0 5
72726: PUSH
72727: LD_VAR 0 5
72731: PPUSH
72732: LD_INT 4
72734: PPUSH
72735: LD_VAR 0 8
72739: PPUSH
72740: CALL_OW 1
72744: ST_TO_ADDR
// end ;
72745: LD_VAR 0 5
72749: RET
// export function DangerAtRange ( unit , range ) ; begin
72750: LD_INT 0
72752: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72753: LD_ADDR_VAR 0 3
72757: PUSH
72758: LD_VAR 0 1
72762: PPUSH
72763: CALL_OW 255
72767: PPUSH
72768: LD_VAR 0 1
72772: PPUSH
72773: CALL_OW 250
72777: PPUSH
72778: LD_VAR 0 1
72782: PPUSH
72783: CALL_OW 251
72787: PPUSH
72788: LD_VAR 0 2
72792: PPUSH
72793: CALL 71053 0 4
72797: ST_TO_ADDR
// end ;
72798: LD_VAR 0 3
72802: RET
// export function DangerInArea ( side , area ) ; begin
72803: LD_INT 0
72805: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72806: LD_ADDR_VAR 0 3
72810: PUSH
72811: LD_VAR 0 2
72815: PPUSH
72816: LD_INT 81
72818: PUSH
72819: LD_VAR 0 1
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: PPUSH
72828: CALL_OW 70
72832: ST_TO_ADDR
// end ;
72833: LD_VAR 0 3
72837: RET
// export function IsExtension ( b ) ; begin
72838: LD_INT 0
72840: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72841: LD_ADDR_VAR 0 2
72845: PUSH
72846: LD_VAR 0 1
72850: PUSH
72851: LD_INT 23
72853: PUSH
72854: LD_INT 20
72856: PUSH
72857: LD_INT 22
72859: PUSH
72860: LD_INT 17
72862: PUSH
72863: LD_INT 24
72865: PUSH
72866: LD_INT 21
72868: PUSH
72869: LD_INT 19
72871: PUSH
72872: LD_INT 16
72874: PUSH
72875: LD_INT 25
72877: PUSH
72878: LD_INT 18
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: LIST
72890: LIST
72891: LIST
72892: IN
72893: ST_TO_ADDR
// end ;
72894: LD_VAR 0 2
72898: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72899: LD_INT 0
72901: PPUSH
72902: PPUSH
72903: PPUSH
// result := [ ] ;
72904: LD_ADDR_VAR 0 3
72908: PUSH
72909: EMPTY
72910: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72911: LD_ADDR_VAR 0 4
72915: PUSH
72916: LD_VAR 0 2
72920: PPUSH
72921: LD_INT 21
72923: PUSH
72924: LD_INT 3
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PPUSH
72931: CALL_OW 70
72935: ST_TO_ADDR
// if not tmp then
72936: LD_VAR 0 4
72940: NOT
72941: IFFALSE 72945
// exit ;
72943: GO 73003
// for i in tmp do
72945: LD_ADDR_VAR 0 5
72949: PUSH
72950: LD_VAR 0 4
72954: PUSH
72955: FOR_IN
72956: IFFALSE 72991
// if GetBase ( i ) <> base then
72958: LD_VAR 0 5
72962: PPUSH
72963: CALL_OW 274
72967: PUSH
72968: LD_VAR 0 1
72972: NONEQUAL
72973: IFFALSE 72989
// ComLinkToBase ( base , i ) ;
72975: LD_VAR 0 1
72979: PPUSH
72980: LD_VAR 0 5
72984: PPUSH
72985: CALL_OW 169
72989: GO 72955
72991: POP
72992: POP
// result := tmp ;
72993: LD_ADDR_VAR 0 3
72997: PUSH
72998: LD_VAR 0 4
73002: ST_TO_ADDR
// end ;
73003: LD_VAR 0 3
73007: RET
// export function ComComplete ( unit , b ) ; var i ; begin
73008: LD_INT 0
73010: PPUSH
73011: PPUSH
// if BuildingStatus ( b ) = bs_build then
73012: LD_VAR 0 2
73016: PPUSH
73017: CALL_OW 461
73021: PUSH
73022: LD_INT 1
73024: EQUAL
73025: IFFALSE 73085
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73027: LD_VAR 0 1
73031: PPUSH
73032: LD_STRING h
73034: PUSH
73035: LD_VAR 0 2
73039: PPUSH
73040: CALL_OW 250
73044: PUSH
73045: LD_VAR 0 2
73049: PPUSH
73050: CALL_OW 251
73054: PUSH
73055: LD_VAR 0 2
73059: PUSH
73060: LD_INT 0
73062: PUSH
73063: LD_INT 0
73065: PUSH
73066: LD_INT 0
73068: PUSH
73069: EMPTY
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: PUSH
73078: EMPTY
73079: LIST
73080: PPUSH
73081: CALL_OW 446
// end ;
73085: LD_VAR 0 3
73089: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73090: LD_INT 0
73092: PPUSH
73093: PPUSH
73094: PPUSH
73095: PPUSH
73096: PPUSH
73097: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73098: LD_VAR 0 1
73102: NOT
73103: PUSH
73104: LD_VAR 0 1
73108: PPUSH
73109: CALL_OW 263
73113: PUSH
73114: LD_INT 2
73116: EQUAL
73117: NOT
73118: OR
73119: IFFALSE 73123
// exit ;
73121: GO 73439
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73123: LD_ADDR_VAR 0 6
73127: PUSH
73128: LD_INT 22
73130: PUSH
73131: LD_VAR 0 1
73135: PPUSH
73136: CALL_OW 255
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 2
73147: PUSH
73148: LD_INT 30
73150: PUSH
73151: LD_INT 36
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: PUSH
73158: LD_INT 34
73160: PUSH
73161: LD_INT 31
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: LIST
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PPUSH
73177: CALL_OW 69
73181: ST_TO_ADDR
// if not tmp then
73182: LD_VAR 0 6
73186: NOT
73187: IFFALSE 73191
// exit ;
73189: GO 73439
// result := [ ] ;
73191: LD_ADDR_VAR 0 2
73195: PUSH
73196: EMPTY
73197: ST_TO_ADDR
// for i in tmp do
73198: LD_ADDR_VAR 0 3
73202: PUSH
73203: LD_VAR 0 6
73207: PUSH
73208: FOR_IN
73209: IFFALSE 73280
// begin t := UnitsInside ( i ) ;
73211: LD_ADDR_VAR 0 4
73215: PUSH
73216: LD_VAR 0 3
73220: PPUSH
73221: CALL_OW 313
73225: ST_TO_ADDR
// if t then
73226: LD_VAR 0 4
73230: IFFALSE 73278
// for j in t do
73232: LD_ADDR_VAR 0 7
73236: PUSH
73237: LD_VAR 0 4
73241: PUSH
73242: FOR_IN
73243: IFFALSE 73276
// result := Insert ( result , result + 1 , j ) ;
73245: LD_ADDR_VAR 0 2
73249: PUSH
73250: LD_VAR 0 2
73254: PPUSH
73255: LD_VAR 0 2
73259: PUSH
73260: LD_INT 1
73262: PLUS
73263: PPUSH
73264: LD_VAR 0 7
73268: PPUSH
73269: CALL_OW 2
73273: ST_TO_ADDR
73274: GO 73242
73276: POP
73277: POP
// end ;
73278: GO 73208
73280: POP
73281: POP
// if not result then
73282: LD_VAR 0 2
73286: NOT
73287: IFFALSE 73291
// exit ;
73289: GO 73439
// mech := result [ 1 ] ;
73291: LD_ADDR_VAR 0 5
73295: PUSH
73296: LD_VAR 0 2
73300: PUSH
73301: LD_INT 1
73303: ARRAY
73304: ST_TO_ADDR
// if result > 1 then
73305: LD_VAR 0 2
73309: PUSH
73310: LD_INT 1
73312: GREATER
73313: IFFALSE 73425
// for i = 2 to result do
73315: LD_ADDR_VAR 0 3
73319: PUSH
73320: DOUBLE
73321: LD_INT 2
73323: DEC
73324: ST_TO_ADDR
73325: LD_VAR 0 2
73329: PUSH
73330: FOR_TO
73331: IFFALSE 73423
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73333: LD_ADDR_VAR 0 4
73337: PUSH
73338: LD_VAR 0 2
73342: PUSH
73343: LD_VAR 0 3
73347: ARRAY
73348: PPUSH
73349: LD_INT 3
73351: PPUSH
73352: CALL_OW 259
73356: PUSH
73357: LD_VAR 0 2
73361: PUSH
73362: LD_VAR 0 3
73366: ARRAY
73367: PPUSH
73368: CALL_OW 432
73372: MINUS
73373: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73374: LD_VAR 0 4
73378: PUSH
73379: LD_VAR 0 5
73383: PPUSH
73384: LD_INT 3
73386: PPUSH
73387: CALL_OW 259
73391: PUSH
73392: LD_VAR 0 5
73396: PPUSH
73397: CALL_OW 432
73401: MINUS
73402: GREATEREQUAL
73403: IFFALSE 73421
// mech := result [ i ] ;
73405: LD_ADDR_VAR 0 5
73409: PUSH
73410: LD_VAR 0 2
73414: PUSH
73415: LD_VAR 0 3
73419: ARRAY
73420: ST_TO_ADDR
// end ;
73421: GO 73330
73423: POP
73424: POP
// ComLinkTo ( vehicle , mech ) ;
73425: LD_VAR 0 1
73429: PPUSH
73430: LD_VAR 0 5
73434: PPUSH
73435: CALL_OW 135
// end ;
73439: LD_VAR 0 2
73443: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73444: LD_INT 0
73446: PPUSH
73447: PPUSH
73448: PPUSH
73449: PPUSH
73450: PPUSH
73451: PPUSH
73452: PPUSH
73453: PPUSH
73454: PPUSH
73455: PPUSH
73456: PPUSH
73457: PPUSH
73458: PPUSH
// result := [ ] ;
73459: LD_ADDR_VAR 0 7
73463: PUSH
73464: EMPTY
73465: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73466: LD_VAR 0 1
73470: PPUSH
73471: CALL_OW 266
73475: PUSH
73476: LD_INT 0
73478: PUSH
73479: LD_INT 1
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: IN
73486: NOT
73487: IFFALSE 73491
// exit ;
73489: GO 75122
// if name then
73491: LD_VAR 0 3
73495: IFFALSE 73511
// SetBName ( base_dep , name ) ;
73497: LD_VAR 0 1
73501: PPUSH
73502: LD_VAR 0 3
73506: PPUSH
73507: CALL_OW 500
// base := GetBase ( base_dep ) ;
73511: LD_ADDR_VAR 0 15
73515: PUSH
73516: LD_VAR 0 1
73520: PPUSH
73521: CALL_OW 274
73525: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73526: LD_ADDR_VAR 0 16
73530: PUSH
73531: LD_VAR 0 1
73535: PPUSH
73536: CALL_OW 255
73540: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73541: LD_ADDR_VAR 0 17
73545: PUSH
73546: LD_VAR 0 1
73550: PPUSH
73551: CALL_OW 248
73555: ST_TO_ADDR
// if sources then
73556: LD_VAR 0 5
73560: IFFALSE 73607
// for i = 1 to 3 do
73562: LD_ADDR_VAR 0 8
73566: PUSH
73567: DOUBLE
73568: LD_INT 1
73570: DEC
73571: ST_TO_ADDR
73572: LD_INT 3
73574: PUSH
73575: FOR_TO
73576: IFFALSE 73605
// AddResourceType ( base , i , sources [ i ] ) ;
73578: LD_VAR 0 15
73582: PPUSH
73583: LD_VAR 0 8
73587: PPUSH
73588: LD_VAR 0 5
73592: PUSH
73593: LD_VAR 0 8
73597: ARRAY
73598: PPUSH
73599: CALL_OW 276
73603: GO 73575
73605: POP
73606: POP
// buildings := GetBaseBuildings ( base , area ) ;
73607: LD_ADDR_VAR 0 18
73611: PUSH
73612: LD_VAR 0 15
73616: PPUSH
73617: LD_VAR 0 2
73621: PPUSH
73622: CALL 72899 0 2
73626: ST_TO_ADDR
// InitHc ;
73627: CALL_OW 19
// InitUc ;
73631: CALL_OW 18
// uc_side := side ;
73635: LD_ADDR_OWVAR 20
73639: PUSH
73640: LD_VAR 0 16
73644: ST_TO_ADDR
// uc_nation := nation ;
73645: LD_ADDR_OWVAR 21
73649: PUSH
73650: LD_VAR 0 17
73654: ST_TO_ADDR
// if buildings then
73655: LD_VAR 0 18
73659: IFFALSE 74981
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73661: LD_ADDR_VAR 0 19
73665: PUSH
73666: LD_VAR 0 18
73670: PPUSH
73671: LD_INT 2
73673: PUSH
73674: LD_INT 30
73676: PUSH
73677: LD_INT 29
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 30
73686: PUSH
73687: LD_INT 30
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: LIST
73698: PPUSH
73699: CALL_OW 72
73703: ST_TO_ADDR
// if tmp then
73704: LD_VAR 0 19
73708: IFFALSE 73756
// for i in tmp do
73710: LD_ADDR_VAR 0 8
73714: PUSH
73715: LD_VAR 0 19
73719: PUSH
73720: FOR_IN
73721: IFFALSE 73754
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73723: LD_VAR 0 8
73727: PPUSH
73728: CALL_OW 250
73732: PPUSH
73733: LD_VAR 0 8
73737: PPUSH
73738: CALL_OW 251
73742: PPUSH
73743: LD_VAR 0 16
73747: PPUSH
73748: CALL_OW 441
73752: GO 73720
73754: POP
73755: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73756: LD_VAR 0 18
73760: PPUSH
73761: LD_INT 2
73763: PUSH
73764: LD_INT 30
73766: PUSH
73767: LD_INT 32
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PUSH
73774: LD_INT 30
73776: PUSH
73777: LD_INT 33
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: LIST
73788: PPUSH
73789: CALL_OW 72
73793: IFFALSE 73881
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73795: LD_ADDR_VAR 0 8
73799: PUSH
73800: LD_VAR 0 18
73804: PPUSH
73805: LD_INT 2
73807: PUSH
73808: LD_INT 30
73810: PUSH
73811: LD_INT 32
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PUSH
73818: LD_INT 30
73820: PUSH
73821: LD_INT 33
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: LIST
73832: PPUSH
73833: CALL_OW 72
73837: PUSH
73838: FOR_IN
73839: IFFALSE 73879
// begin if not GetBWeapon ( i ) then
73841: LD_VAR 0 8
73845: PPUSH
73846: CALL_OW 269
73850: NOT
73851: IFFALSE 73877
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73853: LD_VAR 0 8
73857: PPUSH
73858: LD_VAR 0 8
73862: PPUSH
73863: LD_VAR 0 2
73867: PPUSH
73868: CALL 75127 0 2
73872: PPUSH
73873: CALL_OW 431
// end ;
73877: GO 73838
73879: POP
73880: POP
// end ; for i = 1 to personel do
73881: LD_ADDR_VAR 0 8
73885: PUSH
73886: DOUBLE
73887: LD_INT 1
73889: DEC
73890: ST_TO_ADDR
73891: LD_VAR 0 6
73895: PUSH
73896: FOR_TO
73897: IFFALSE 74961
// begin if i > 4 then
73899: LD_VAR 0 8
73903: PUSH
73904: LD_INT 4
73906: GREATER
73907: IFFALSE 73911
// break ;
73909: GO 74961
// case i of 1 :
73911: LD_VAR 0 8
73915: PUSH
73916: LD_INT 1
73918: DOUBLE
73919: EQUAL
73920: IFTRUE 73924
73922: GO 74004
73924: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73925: LD_ADDR_VAR 0 12
73929: PUSH
73930: LD_VAR 0 18
73934: PPUSH
73935: LD_INT 22
73937: PUSH
73938: LD_VAR 0 16
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 58
73949: PUSH
73950: EMPTY
73951: LIST
73952: PUSH
73953: LD_INT 2
73955: PUSH
73956: LD_INT 30
73958: PUSH
73959: LD_INT 32
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 30
73968: PUSH
73969: LD_INT 4
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 30
73978: PUSH
73979: LD_INT 5
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: LIST
73996: PPUSH
73997: CALL_OW 72
74001: ST_TO_ADDR
74002: GO 74226
74004: LD_INT 2
74006: DOUBLE
74007: EQUAL
74008: IFTRUE 74012
74010: GO 74074
74012: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74013: LD_ADDR_VAR 0 12
74017: PUSH
74018: LD_VAR 0 18
74022: PPUSH
74023: LD_INT 22
74025: PUSH
74026: LD_VAR 0 16
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: LD_INT 2
74037: PUSH
74038: LD_INT 30
74040: PUSH
74041: LD_INT 0
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: PUSH
74048: LD_INT 30
74050: PUSH
74051: LD_INT 1
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: LIST
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: PPUSH
74067: CALL_OW 72
74071: ST_TO_ADDR
74072: GO 74226
74074: LD_INT 3
74076: DOUBLE
74077: EQUAL
74078: IFTRUE 74082
74080: GO 74144
74082: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74083: LD_ADDR_VAR 0 12
74087: PUSH
74088: LD_VAR 0 18
74092: PPUSH
74093: LD_INT 22
74095: PUSH
74096: LD_VAR 0 16
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: PUSH
74105: LD_INT 2
74107: PUSH
74108: LD_INT 30
74110: PUSH
74111: LD_INT 2
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 30
74120: PUSH
74121: LD_INT 3
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: LIST
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PPUSH
74137: CALL_OW 72
74141: ST_TO_ADDR
74142: GO 74226
74144: LD_INT 4
74146: DOUBLE
74147: EQUAL
74148: IFTRUE 74152
74150: GO 74225
74152: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74153: LD_ADDR_VAR 0 12
74157: PUSH
74158: LD_VAR 0 18
74162: PPUSH
74163: LD_INT 22
74165: PUSH
74166: LD_VAR 0 16
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 2
74177: PUSH
74178: LD_INT 30
74180: PUSH
74181: LD_INT 6
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: LD_INT 30
74190: PUSH
74191: LD_INT 7
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 30
74200: PUSH
74201: LD_INT 8
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PPUSH
74218: CALL_OW 72
74222: ST_TO_ADDR
74223: GO 74226
74225: POP
// if i = 1 then
74226: LD_VAR 0 8
74230: PUSH
74231: LD_INT 1
74233: EQUAL
74234: IFFALSE 74345
// begin tmp := [ ] ;
74236: LD_ADDR_VAR 0 19
74240: PUSH
74241: EMPTY
74242: ST_TO_ADDR
// for j in f do
74243: LD_ADDR_VAR 0 9
74247: PUSH
74248: LD_VAR 0 12
74252: PUSH
74253: FOR_IN
74254: IFFALSE 74327
// if GetBType ( j ) = b_bunker then
74256: LD_VAR 0 9
74260: PPUSH
74261: CALL_OW 266
74265: PUSH
74266: LD_INT 32
74268: EQUAL
74269: IFFALSE 74296
// tmp := Insert ( tmp , 1 , j ) else
74271: LD_ADDR_VAR 0 19
74275: PUSH
74276: LD_VAR 0 19
74280: PPUSH
74281: LD_INT 1
74283: PPUSH
74284: LD_VAR 0 9
74288: PPUSH
74289: CALL_OW 2
74293: ST_TO_ADDR
74294: GO 74325
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74296: LD_ADDR_VAR 0 19
74300: PUSH
74301: LD_VAR 0 19
74305: PPUSH
74306: LD_VAR 0 19
74310: PUSH
74311: LD_INT 1
74313: PLUS
74314: PPUSH
74315: LD_VAR 0 9
74319: PPUSH
74320: CALL_OW 2
74324: ST_TO_ADDR
74325: GO 74253
74327: POP
74328: POP
// if tmp then
74329: LD_VAR 0 19
74333: IFFALSE 74345
// f := tmp ;
74335: LD_ADDR_VAR 0 12
74339: PUSH
74340: LD_VAR 0 19
74344: ST_TO_ADDR
// end ; x := personel [ i ] ;
74345: LD_ADDR_VAR 0 13
74349: PUSH
74350: LD_VAR 0 6
74354: PUSH
74355: LD_VAR 0 8
74359: ARRAY
74360: ST_TO_ADDR
// if x = - 1 then
74361: LD_VAR 0 13
74365: PUSH
74366: LD_INT 1
74368: NEG
74369: EQUAL
74370: IFFALSE 74579
// begin for j in f do
74372: LD_ADDR_VAR 0 9
74376: PUSH
74377: LD_VAR 0 12
74381: PUSH
74382: FOR_IN
74383: IFFALSE 74575
// repeat InitHc ;
74385: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74389: LD_VAR 0 9
74393: PPUSH
74394: CALL_OW 266
74398: PUSH
74399: LD_INT 5
74401: EQUAL
74402: IFFALSE 74472
// begin if UnitsInside ( j ) < 3 then
74404: LD_VAR 0 9
74408: PPUSH
74409: CALL_OW 313
74413: PUSH
74414: LD_INT 3
74416: LESS
74417: IFFALSE 74453
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74419: LD_INT 0
74421: PPUSH
74422: LD_INT 5
74424: PUSH
74425: LD_INT 8
74427: PUSH
74428: LD_INT 9
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: LIST
74435: PUSH
74436: LD_VAR 0 17
74440: ARRAY
74441: PPUSH
74442: LD_VAR 0 4
74446: PPUSH
74447: CALL_OW 380
74451: GO 74470
// PrepareHuman ( false , i , skill ) ;
74453: LD_INT 0
74455: PPUSH
74456: LD_VAR 0 8
74460: PPUSH
74461: LD_VAR 0 4
74465: PPUSH
74466: CALL_OW 380
// end else
74470: GO 74489
// PrepareHuman ( false , i , skill ) ;
74472: LD_INT 0
74474: PPUSH
74475: LD_VAR 0 8
74479: PPUSH
74480: LD_VAR 0 4
74484: PPUSH
74485: CALL_OW 380
// un := CreateHuman ;
74489: LD_ADDR_VAR 0 14
74493: PUSH
74494: CALL_OW 44
74498: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74499: LD_ADDR_VAR 0 7
74503: PUSH
74504: LD_VAR 0 7
74508: PPUSH
74509: LD_INT 1
74511: PPUSH
74512: LD_VAR 0 14
74516: PPUSH
74517: CALL_OW 2
74521: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74522: LD_VAR 0 14
74526: PPUSH
74527: LD_VAR 0 9
74531: PPUSH
74532: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74536: LD_VAR 0 9
74540: PPUSH
74541: CALL_OW 313
74545: PUSH
74546: LD_INT 6
74548: EQUAL
74549: PUSH
74550: LD_VAR 0 9
74554: PPUSH
74555: CALL_OW 266
74559: PUSH
74560: LD_INT 32
74562: PUSH
74563: LD_INT 31
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: IN
74570: OR
74571: IFFALSE 74385
74573: GO 74382
74575: POP
74576: POP
// end else
74577: GO 74959
// for j = 1 to x do
74579: LD_ADDR_VAR 0 9
74583: PUSH
74584: DOUBLE
74585: LD_INT 1
74587: DEC
74588: ST_TO_ADDR
74589: LD_VAR 0 13
74593: PUSH
74594: FOR_TO
74595: IFFALSE 74957
// begin InitHc ;
74597: CALL_OW 19
// if not f then
74601: LD_VAR 0 12
74605: NOT
74606: IFFALSE 74695
// begin PrepareHuman ( false , i , skill ) ;
74608: LD_INT 0
74610: PPUSH
74611: LD_VAR 0 8
74615: PPUSH
74616: LD_VAR 0 4
74620: PPUSH
74621: CALL_OW 380
// un := CreateHuman ;
74625: LD_ADDR_VAR 0 14
74629: PUSH
74630: CALL_OW 44
74634: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74635: LD_ADDR_VAR 0 7
74639: PUSH
74640: LD_VAR 0 7
74644: PPUSH
74645: LD_INT 1
74647: PPUSH
74648: LD_VAR 0 14
74652: PPUSH
74653: CALL_OW 2
74657: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74658: LD_VAR 0 14
74662: PPUSH
74663: LD_VAR 0 1
74667: PPUSH
74668: CALL_OW 250
74672: PPUSH
74673: LD_VAR 0 1
74677: PPUSH
74678: CALL_OW 251
74682: PPUSH
74683: LD_INT 10
74685: PPUSH
74686: LD_INT 0
74688: PPUSH
74689: CALL_OW 50
// continue ;
74693: GO 74594
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74695: LD_VAR 0 12
74699: PUSH
74700: LD_INT 1
74702: ARRAY
74703: PPUSH
74704: CALL_OW 313
74708: PUSH
74709: LD_VAR 0 12
74713: PUSH
74714: LD_INT 1
74716: ARRAY
74717: PPUSH
74718: CALL_OW 266
74722: PUSH
74723: LD_INT 32
74725: PUSH
74726: LD_INT 31
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: IN
74733: AND
74734: PUSH
74735: LD_VAR 0 12
74739: PUSH
74740: LD_INT 1
74742: ARRAY
74743: PPUSH
74744: CALL_OW 313
74748: PUSH
74749: LD_INT 6
74751: EQUAL
74752: OR
74753: IFFALSE 74773
// f := Delete ( f , 1 ) ;
74755: LD_ADDR_VAR 0 12
74759: PUSH
74760: LD_VAR 0 12
74764: PPUSH
74765: LD_INT 1
74767: PPUSH
74768: CALL_OW 3
74772: ST_TO_ADDR
// if not f then
74773: LD_VAR 0 12
74777: NOT
74778: IFFALSE 74796
// begin x := x + 2 ;
74780: LD_ADDR_VAR 0 13
74784: PUSH
74785: LD_VAR 0 13
74789: PUSH
74790: LD_INT 2
74792: PLUS
74793: ST_TO_ADDR
// continue ;
74794: GO 74594
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74796: LD_VAR 0 12
74800: PUSH
74801: LD_INT 1
74803: ARRAY
74804: PPUSH
74805: CALL_OW 266
74809: PUSH
74810: LD_INT 5
74812: EQUAL
74813: IFFALSE 74887
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74815: LD_VAR 0 12
74819: PUSH
74820: LD_INT 1
74822: ARRAY
74823: PPUSH
74824: CALL_OW 313
74828: PUSH
74829: LD_INT 3
74831: LESS
74832: IFFALSE 74868
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74834: LD_INT 0
74836: PPUSH
74837: LD_INT 5
74839: PUSH
74840: LD_INT 8
74842: PUSH
74843: LD_INT 9
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: LIST
74850: PUSH
74851: LD_VAR 0 17
74855: ARRAY
74856: PPUSH
74857: LD_VAR 0 4
74861: PPUSH
74862: CALL_OW 380
74866: GO 74885
// PrepareHuman ( false , i , skill ) ;
74868: LD_INT 0
74870: PPUSH
74871: LD_VAR 0 8
74875: PPUSH
74876: LD_VAR 0 4
74880: PPUSH
74881: CALL_OW 380
// end else
74885: GO 74904
// PrepareHuman ( false , i , skill ) ;
74887: LD_INT 0
74889: PPUSH
74890: LD_VAR 0 8
74894: PPUSH
74895: LD_VAR 0 4
74899: PPUSH
74900: CALL_OW 380
// un := CreateHuman ;
74904: LD_ADDR_VAR 0 14
74908: PUSH
74909: CALL_OW 44
74913: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74914: LD_ADDR_VAR 0 7
74918: PUSH
74919: LD_VAR 0 7
74923: PPUSH
74924: LD_INT 1
74926: PPUSH
74927: LD_VAR 0 14
74931: PPUSH
74932: CALL_OW 2
74936: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74937: LD_VAR 0 14
74941: PPUSH
74942: LD_VAR 0 12
74946: PUSH
74947: LD_INT 1
74949: ARRAY
74950: PPUSH
74951: CALL_OW 52
// end ;
74955: GO 74594
74957: POP
74958: POP
// end ;
74959: GO 73896
74961: POP
74962: POP
// result := result ^ buildings ;
74963: LD_ADDR_VAR 0 7
74967: PUSH
74968: LD_VAR 0 7
74972: PUSH
74973: LD_VAR 0 18
74977: ADD
74978: ST_TO_ADDR
// end else
74979: GO 75122
// begin for i = 1 to personel do
74981: LD_ADDR_VAR 0 8
74985: PUSH
74986: DOUBLE
74987: LD_INT 1
74989: DEC
74990: ST_TO_ADDR
74991: LD_VAR 0 6
74995: PUSH
74996: FOR_TO
74997: IFFALSE 75120
// begin if i > 4 then
74999: LD_VAR 0 8
75003: PUSH
75004: LD_INT 4
75006: GREATER
75007: IFFALSE 75011
// break ;
75009: GO 75120
// x := personel [ i ] ;
75011: LD_ADDR_VAR 0 13
75015: PUSH
75016: LD_VAR 0 6
75020: PUSH
75021: LD_VAR 0 8
75025: ARRAY
75026: ST_TO_ADDR
// if x = - 1 then
75027: LD_VAR 0 13
75031: PUSH
75032: LD_INT 1
75034: NEG
75035: EQUAL
75036: IFFALSE 75040
// continue ;
75038: GO 74996
// PrepareHuman ( false , i , skill ) ;
75040: LD_INT 0
75042: PPUSH
75043: LD_VAR 0 8
75047: PPUSH
75048: LD_VAR 0 4
75052: PPUSH
75053: CALL_OW 380
// un := CreateHuman ;
75057: LD_ADDR_VAR 0 14
75061: PUSH
75062: CALL_OW 44
75066: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75067: LD_VAR 0 14
75071: PPUSH
75072: LD_VAR 0 1
75076: PPUSH
75077: CALL_OW 250
75081: PPUSH
75082: LD_VAR 0 1
75086: PPUSH
75087: CALL_OW 251
75091: PPUSH
75092: LD_INT 10
75094: PPUSH
75095: LD_INT 0
75097: PPUSH
75098: CALL_OW 50
// result := result ^ un ;
75102: LD_ADDR_VAR 0 7
75106: PUSH
75107: LD_VAR 0 7
75111: PUSH
75112: LD_VAR 0 14
75116: ADD
75117: ST_TO_ADDR
// end ;
75118: GO 74996
75120: POP
75121: POP
// end ; end ;
75122: LD_VAR 0 7
75126: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75127: LD_INT 0
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
75135: PPUSH
75136: PPUSH
75137: PPUSH
75138: PPUSH
75139: PPUSH
75140: PPUSH
75141: PPUSH
75142: PPUSH
75143: PPUSH
75144: PPUSH
// result := false ;
75145: LD_ADDR_VAR 0 3
75149: PUSH
75150: LD_INT 0
75152: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75153: LD_VAR 0 1
75157: NOT
75158: PUSH
75159: LD_VAR 0 1
75163: PPUSH
75164: CALL_OW 266
75168: PUSH
75169: LD_INT 32
75171: PUSH
75172: LD_INT 33
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: IN
75179: NOT
75180: OR
75181: IFFALSE 75185
// exit ;
75183: GO 76321
// nat := GetNation ( tower ) ;
75185: LD_ADDR_VAR 0 12
75189: PUSH
75190: LD_VAR 0 1
75194: PPUSH
75195: CALL_OW 248
75199: ST_TO_ADDR
// side := GetSide ( tower ) ;
75200: LD_ADDR_VAR 0 16
75204: PUSH
75205: LD_VAR 0 1
75209: PPUSH
75210: CALL_OW 255
75214: ST_TO_ADDR
// x := GetX ( tower ) ;
75215: LD_ADDR_VAR 0 10
75219: PUSH
75220: LD_VAR 0 1
75224: PPUSH
75225: CALL_OW 250
75229: ST_TO_ADDR
// y := GetY ( tower ) ;
75230: LD_ADDR_VAR 0 11
75234: PUSH
75235: LD_VAR 0 1
75239: PPUSH
75240: CALL_OW 251
75244: ST_TO_ADDR
// if not x or not y then
75245: LD_VAR 0 10
75249: NOT
75250: PUSH
75251: LD_VAR 0 11
75255: NOT
75256: OR
75257: IFFALSE 75261
// exit ;
75259: GO 76321
// weapon := 0 ;
75261: LD_ADDR_VAR 0 18
75265: PUSH
75266: LD_INT 0
75268: ST_TO_ADDR
// fac_list := [ ] ;
75269: LD_ADDR_VAR 0 17
75273: PUSH
75274: EMPTY
75275: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75276: LD_ADDR_VAR 0 6
75280: PUSH
75281: LD_VAR 0 1
75285: PPUSH
75286: CALL_OW 274
75290: PPUSH
75291: LD_VAR 0 2
75295: PPUSH
75296: CALL 72899 0 2
75300: PPUSH
75301: LD_INT 30
75303: PUSH
75304: LD_INT 3
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PPUSH
75311: CALL_OW 72
75315: ST_TO_ADDR
// if not factories then
75316: LD_VAR 0 6
75320: NOT
75321: IFFALSE 75325
// exit ;
75323: GO 76321
// for i in factories do
75325: LD_ADDR_VAR 0 8
75329: PUSH
75330: LD_VAR 0 6
75334: PUSH
75335: FOR_IN
75336: IFFALSE 75361
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75338: LD_ADDR_VAR 0 17
75342: PUSH
75343: LD_VAR 0 17
75347: PUSH
75348: LD_VAR 0 8
75352: PPUSH
75353: CALL_OW 478
75357: UNION
75358: ST_TO_ADDR
75359: GO 75335
75361: POP
75362: POP
// if not fac_list then
75363: LD_VAR 0 17
75367: NOT
75368: IFFALSE 75372
// exit ;
75370: GO 76321
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75372: LD_ADDR_VAR 0 5
75376: PUSH
75377: LD_INT 4
75379: PUSH
75380: LD_INT 5
75382: PUSH
75383: LD_INT 9
75385: PUSH
75386: LD_INT 10
75388: PUSH
75389: LD_INT 6
75391: PUSH
75392: LD_INT 7
75394: PUSH
75395: LD_INT 11
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 27
75409: PUSH
75410: LD_INT 28
75412: PUSH
75413: LD_INT 26
75415: PUSH
75416: LD_INT 30
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: PUSH
75425: LD_INT 43
75427: PUSH
75428: LD_INT 44
75430: PUSH
75431: LD_INT 46
75433: PUSH
75434: LD_INT 45
75436: PUSH
75437: LD_INT 47
75439: PUSH
75440: LD_INT 49
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: LIST
75447: LIST
75448: LIST
75449: LIST
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: LIST
75455: PUSH
75456: LD_VAR 0 12
75460: ARRAY
75461: ST_TO_ADDR
// for i in list do
75462: LD_ADDR_VAR 0 8
75466: PUSH
75467: LD_VAR 0 5
75471: PUSH
75472: FOR_IN
75473: IFFALSE 75506
// if not i in fac_list then
75475: LD_VAR 0 8
75479: PUSH
75480: LD_VAR 0 17
75484: IN
75485: NOT
75486: IFFALSE 75504
// list := list diff i ;
75488: LD_ADDR_VAR 0 5
75492: PUSH
75493: LD_VAR 0 5
75497: PUSH
75498: LD_VAR 0 8
75502: DIFF
75503: ST_TO_ADDR
75504: GO 75472
75506: POP
75507: POP
// if not list then
75508: LD_VAR 0 5
75512: NOT
75513: IFFALSE 75517
// exit ;
75515: GO 76321
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75517: LD_VAR 0 12
75521: PUSH
75522: LD_INT 3
75524: EQUAL
75525: PUSH
75526: LD_INT 49
75528: PUSH
75529: LD_VAR 0 5
75533: IN
75534: AND
75535: PUSH
75536: LD_INT 31
75538: PPUSH
75539: LD_VAR 0 16
75543: PPUSH
75544: CALL_OW 321
75548: PUSH
75549: LD_INT 2
75551: EQUAL
75552: AND
75553: IFFALSE 75613
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75555: LD_INT 22
75557: PUSH
75558: LD_VAR 0 16
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 35
75569: PUSH
75570: LD_INT 49
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 91
75579: PUSH
75580: LD_VAR 0 1
75584: PUSH
75585: LD_INT 10
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: LIST
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: LIST
75597: PPUSH
75598: CALL_OW 69
75602: NOT
75603: IFFALSE 75613
// weapon := ru_time_lapser ;
75605: LD_ADDR_VAR 0 18
75609: PUSH
75610: LD_INT 49
75612: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75613: LD_VAR 0 12
75617: PUSH
75618: LD_INT 1
75620: PUSH
75621: LD_INT 2
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: IN
75628: PUSH
75629: LD_INT 11
75631: PUSH
75632: LD_VAR 0 5
75636: IN
75637: PUSH
75638: LD_INT 30
75640: PUSH
75641: LD_VAR 0 5
75645: IN
75646: OR
75647: AND
75648: PUSH
75649: LD_INT 6
75651: PPUSH
75652: LD_VAR 0 16
75656: PPUSH
75657: CALL_OW 321
75661: PUSH
75662: LD_INT 2
75664: EQUAL
75665: AND
75666: IFFALSE 75831
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75668: LD_INT 22
75670: PUSH
75671: LD_VAR 0 16
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 2
75682: PUSH
75683: LD_INT 35
75685: PUSH
75686: LD_INT 11
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 35
75695: PUSH
75696: LD_INT 30
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 91
75710: PUSH
75711: LD_VAR 0 1
75715: PUSH
75716: LD_INT 18
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: LIST
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: LIST
75728: PPUSH
75729: CALL_OW 69
75733: NOT
75734: PUSH
75735: LD_INT 22
75737: PUSH
75738: LD_VAR 0 16
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: PUSH
75747: LD_INT 2
75749: PUSH
75750: LD_INT 30
75752: PUSH
75753: LD_INT 32
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 30
75762: PUSH
75763: LD_INT 33
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 91
75777: PUSH
75778: LD_VAR 0 1
75782: PUSH
75783: LD_INT 12
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: LIST
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: LIST
75795: PUSH
75796: EMPTY
75797: LIST
75798: PPUSH
75799: CALL_OW 69
75803: PUSH
75804: LD_INT 2
75806: GREATER
75807: AND
75808: IFFALSE 75831
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75810: LD_ADDR_VAR 0 18
75814: PUSH
75815: LD_INT 11
75817: PUSH
75818: LD_INT 30
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_VAR 0 12
75829: ARRAY
75830: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75831: LD_VAR 0 18
75835: NOT
75836: PUSH
75837: LD_INT 40
75839: PPUSH
75840: LD_VAR 0 16
75844: PPUSH
75845: CALL_OW 321
75849: PUSH
75850: LD_INT 2
75852: EQUAL
75853: AND
75854: PUSH
75855: LD_INT 7
75857: PUSH
75858: LD_VAR 0 5
75862: IN
75863: PUSH
75864: LD_INT 28
75866: PUSH
75867: LD_VAR 0 5
75871: IN
75872: OR
75873: PUSH
75874: LD_INT 45
75876: PUSH
75877: LD_VAR 0 5
75881: IN
75882: OR
75883: AND
75884: IFFALSE 76138
// begin hex := GetHexInfo ( x , y ) ;
75886: LD_ADDR_VAR 0 4
75890: PUSH
75891: LD_VAR 0 10
75895: PPUSH
75896: LD_VAR 0 11
75900: PPUSH
75901: CALL_OW 546
75905: ST_TO_ADDR
// if hex [ 1 ] then
75906: LD_VAR 0 4
75910: PUSH
75911: LD_INT 1
75913: ARRAY
75914: IFFALSE 75918
// exit ;
75916: GO 76321
// height := hex [ 2 ] ;
75918: LD_ADDR_VAR 0 15
75922: PUSH
75923: LD_VAR 0 4
75927: PUSH
75928: LD_INT 2
75930: ARRAY
75931: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75932: LD_ADDR_VAR 0 14
75936: PUSH
75937: LD_INT 0
75939: PUSH
75940: LD_INT 2
75942: PUSH
75943: LD_INT 3
75945: PUSH
75946: LD_INT 5
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: LIST
75953: LIST
75954: ST_TO_ADDR
// for i in tmp do
75955: LD_ADDR_VAR 0 8
75959: PUSH
75960: LD_VAR 0 14
75964: PUSH
75965: FOR_IN
75966: IFFALSE 76136
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75968: LD_ADDR_VAR 0 9
75972: PUSH
75973: LD_VAR 0 10
75977: PPUSH
75978: LD_VAR 0 8
75982: PPUSH
75983: LD_INT 5
75985: PPUSH
75986: CALL_OW 272
75990: PUSH
75991: LD_VAR 0 11
75995: PPUSH
75996: LD_VAR 0 8
76000: PPUSH
76001: LD_INT 5
76003: PPUSH
76004: CALL_OW 273
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76013: LD_VAR 0 9
76017: PUSH
76018: LD_INT 1
76020: ARRAY
76021: PPUSH
76022: LD_VAR 0 9
76026: PUSH
76027: LD_INT 2
76029: ARRAY
76030: PPUSH
76031: CALL_OW 488
76035: IFFALSE 76134
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76037: LD_ADDR_VAR 0 4
76041: PUSH
76042: LD_VAR 0 9
76046: PUSH
76047: LD_INT 1
76049: ARRAY
76050: PPUSH
76051: LD_VAR 0 9
76055: PUSH
76056: LD_INT 2
76058: ARRAY
76059: PPUSH
76060: CALL_OW 546
76064: ST_TO_ADDR
// if hex [ 1 ] then
76065: LD_VAR 0 4
76069: PUSH
76070: LD_INT 1
76072: ARRAY
76073: IFFALSE 76077
// continue ;
76075: GO 75965
// h := hex [ 2 ] ;
76077: LD_ADDR_VAR 0 13
76081: PUSH
76082: LD_VAR 0 4
76086: PUSH
76087: LD_INT 2
76089: ARRAY
76090: ST_TO_ADDR
// if h + 7 < height then
76091: LD_VAR 0 13
76095: PUSH
76096: LD_INT 7
76098: PLUS
76099: PUSH
76100: LD_VAR 0 15
76104: LESS
76105: IFFALSE 76134
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76107: LD_ADDR_VAR 0 18
76111: PUSH
76112: LD_INT 7
76114: PUSH
76115: LD_INT 28
76117: PUSH
76118: LD_INT 45
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: LIST
76125: PUSH
76126: LD_VAR 0 12
76130: ARRAY
76131: ST_TO_ADDR
// break ;
76132: GO 76136
// end ; end ; end ;
76134: GO 75965
76136: POP
76137: POP
// end ; if not weapon then
76138: LD_VAR 0 18
76142: NOT
76143: IFFALSE 76203
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76145: LD_ADDR_VAR 0 5
76149: PUSH
76150: LD_VAR 0 5
76154: PUSH
76155: LD_INT 11
76157: PUSH
76158: LD_INT 30
76160: PUSH
76161: LD_INT 49
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: LIST
76168: DIFF
76169: ST_TO_ADDR
// if not list then
76170: LD_VAR 0 5
76174: NOT
76175: IFFALSE 76179
// exit ;
76177: GO 76321
// weapon := list [ rand ( 1 , list ) ] ;
76179: LD_ADDR_VAR 0 18
76183: PUSH
76184: LD_VAR 0 5
76188: PUSH
76189: LD_INT 1
76191: PPUSH
76192: LD_VAR 0 5
76196: PPUSH
76197: CALL_OW 12
76201: ARRAY
76202: ST_TO_ADDR
// end ; if weapon then
76203: LD_VAR 0 18
76207: IFFALSE 76321
// begin tmp := CostOfWeapon ( weapon ) ;
76209: LD_ADDR_VAR 0 14
76213: PUSH
76214: LD_VAR 0 18
76218: PPUSH
76219: CALL_OW 451
76223: ST_TO_ADDR
// j := GetBase ( tower ) ;
76224: LD_ADDR_VAR 0 9
76228: PUSH
76229: LD_VAR 0 1
76233: PPUSH
76234: CALL_OW 274
76238: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76239: LD_VAR 0 9
76243: PPUSH
76244: LD_INT 1
76246: PPUSH
76247: CALL_OW 275
76251: PUSH
76252: LD_VAR 0 14
76256: PUSH
76257: LD_INT 1
76259: ARRAY
76260: GREATEREQUAL
76261: PUSH
76262: LD_VAR 0 9
76266: PPUSH
76267: LD_INT 2
76269: PPUSH
76270: CALL_OW 275
76274: PUSH
76275: LD_VAR 0 14
76279: PUSH
76280: LD_INT 2
76282: ARRAY
76283: GREATEREQUAL
76284: AND
76285: PUSH
76286: LD_VAR 0 9
76290: PPUSH
76291: LD_INT 3
76293: PPUSH
76294: CALL_OW 275
76298: PUSH
76299: LD_VAR 0 14
76303: PUSH
76304: LD_INT 3
76306: ARRAY
76307: GREATEREQUAL
76308: AND
76309: IFFALSE 76321
// result := weapon ;
76311: LD_ADDR_VAR 0 3
76315: PUSH
76316: LD_VAR 0 18
76320: ST_TO_ADDR
// end ; end ;
76321: LD_VAR 0 3
76325: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76326: LD_INT 0
76328: PPUSH
76329: PPUSH
// result := true ;
76330: LD_ADDR_VAR 0 3
76334: PUSH
76335: LD_INT 1
76337: ST_TO_ADDR
// if array1 = array2 then
76338: LD_VAR 0 1
76342: PUSH
76343: LD_VAR 0 2
76347: EQUAL
76348: IFFALSE 76408
// begin for i = 1 to array1 do
76350: LD_ADDR_VAR 0 4
76354: PUSH
76355: DOUBLE
76356: LD_INT 1
76358: DEC
76359: ST_TO_ADDR
76360: LD_VAR 0 1
76364: PUSH
76365: FOR_TO
76366: IFFALSE 76404
// if array1 [ i ] <> array2 [ i ] then
76368: LD_VAR 0 1
76372: PUSH
76373: LD_VAR 0 4
76377: ARRAY
76378: PUSH
76379: LD_VAR 0 2
76383: PUSH
76384: LD_VAR 0 4
76388: ARRAY
76389: NONEQUAL
76390: IFFALSE 76402
// begin result := false ;
76392: LD_ADDR_VAR 0 3
76396: PUSH
76397: LD_INT 0
76399: ST_TO_ADDR
// break ;
76400: GO 76404
// end ;
76402: GO 76365
76404: POP
76405: POP
// end else
76406: GO 76416
// result := false ;
76408: LD_ADDR_VAR 0 3
76412: PUSH
76413: LD_INT 0
76415: ST_TO_ADDR
// end ;
76416: LD_VAR 0 3
76420: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76421: LD_INT 0
76423: PPUSH
76424: PPUSH
76425: PPUSH
// pom := GetBase ( fac ) ;
76426: LD_ADDR_VAR 0 5
76430: PUSH
76431: LD_VAR 0 1
76435: PPUSH
76436: CALL_OW 274
76440: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76441: LD_ADDR_VAR 0 4
76445: PUSH
76446: LD_VAR 0 2
76450: PUSH
76451: LD_INT 1
76453: ARRAY
76454: PPUSH
76455: LD_VAR 0 2
76459: PUSH
76460: LD_INT 2
76462: ARRAY
76463: PPUSH
76464: LD_VAR 0 2
76468: PUSH
76469: LD_INT 3
76471: ARRAY
76472: PPUSH
76473: LD_VAR 0 2
76477: PUSH
76478: LD_INT 4
76480: ARRAY
76481: PPUSH
76482: CALL_OW 449
76486: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76487: LD_ADDR_VAR 0 3
76491: PUSH
76492: LD_VAR 0 5
76496: PPUSH
76497: LD_INT 1
76499: PPUSH
76500: CALL_OW 275
76504: PUSH
76505: LD_VAR 0 4
76509: PUSH
76510: LD_INT 1
76512: ARRAY
76513: GREATEREQUAL
76514: PUSH
76515: LD_VAR 0 5
76519: PPUSH
76520: LD_INT 2
76522: PPUSH
76523: CALL_OW 275
76527: PUSH
76528: LD_VAR 0 4
76532: PUSH
76533: LD_INT 2
76535: ARRAY
76536: GREATEREQUAL
76537: AND
76538: PUSH
76539: LD_VAR 0 5
76543: PPUSH
76544: LD_INT 3
76546: PPUSH
76547: CALL_OW 275
76551: PUSH
76552: LD_VAR 0 4
76556: PUSH
76557: LD_INT 3
76559: ARRAY
76560: GREATEREQUAL
76561: AND
76562: ST_TO_ADDR
// end ;
76563: LD_VAR 0 3
76567: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76568: LD_INT 0
76570: PPUSH
76571: PPUSH
76572: PPUSH
76573: PPUSH
// pom := GetBase ( building ) ;
76574: LD_ADDR_VAR 0 3
76578: PUSH
76579: LD_VAR 0 1
76583: PPUSH
76584: CALL_OW 274
76588: ST_TO_ADDR
// if not pom then
76589: LD_VAR 0 3
76593: NOT
76594: IFFALSE 76598
// exit ;
76596: GO 76768
// btype := GetBType ( building ) ;
76598: LD_ADDR_VAR 0 5
76602: PUSH
76603: LD_VAR 0 1
76607: PPUSH
76608: CALL_OW 266
76612: ST_TO_ADDR
// if btype = b_armoury then
76613: LD_VAR 0 5
76617: PUSH
76618: LD_INT 4
76620: EQUAL
76621: IFFALSE 76631
// btype := b_barracks ;
76623: LD_ADDR_VAR 0 5
76627: PUSH
76628: LD_INT 5
76630: ST_TO_ADDR
// if btype = b_depot then
76631: LD_VAR 0 5
76635: PUSH
76636: LD_INT 0
76638: EQUAL
76639: IFFALSE 76649
// btype := b_warehouse ;
76641: LD_ADDR_VAR 0 5
76645: PUSH
76646: LD_INT 1
76648: ST_TO_ADDR
// if btype = b_workshop then
76649: LD_VAR 0 5
76653: PUSH
76654: LD_INT 2
76656: EQUAL
76657: IFFALSE 76667
// btype := b_factory ;
76659: LD_ADDR_VAR 0 5
76663: PUSH
76664: LD_INT 3
76666: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76667: LD_ADDR_VAR 0 4
76671: PUSH
76672: LD_VAR 0 5
76676: PPUSH
76677: LD_VAR 0 1
76681: PPUSH
76682: CALL_OW 248
76686: PPUSH
76687: CALL_OW 450
76691: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76692: LD_ADDR_VAR 0 2
76696: PUSH
76697: LD_VAR 0 3
76701: PPUSH
76702: LD_INT 1
76704: PPUSH
76705: CALL_OW 275
76709: PUSH
76710: LD_VAR 0 4
76714: PUSH
76715: LD_INT 1
76717: ARRAY
76718: GREATEREQUAL
76719: PUSH
76720: LD_VAR 0 3
76724: PPUSH
76725: LD_INT 2
76727: PPUSH
76728: CALL_OW 275
76732: PUSH
76733: LD_VAR 0 4
76737: PUSH
76738: LD_INT 2
76740: ARRAY
76741: GREATEREQUAL
76742: AND
76743: PUSH
76744: LD_VAR 0 3
76748: PPUSH
76749: LD_INT 3
76751: PPUSH
76752: CALL_OW 275
76756: PUSH
76757: LD_VAR 0 4
76761: PUSH
76762: LD_INT 3
76764: ARRAY
76765: GREATEREQUAL
76766: AND
76767: ST_TO_ADDR
// end ;
76768: LD_VAR 0 2
76772: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76773: LD_INT 0
76775: PPUSH
76776: PPUSH
76777: PPUSH
// pom := GetBase ( building ) ;
76778: LD_ADDR_VAR 0 4
76782: PUSH
76783: LD_VAR 0 1
76787: PPUSH
76788: CALL_OW 274
76792: ST_TO_ADDR
// if not pom then
76793: LD_VAR 0 4
76797: NOT
76798: IFFALSE 76802
// exit ;
76800: GO 76903
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76802: LD_ADDR_VAR 0 5
76806: PUSH
76807: LD_VAR 0 2
76811: PPUSH
76812: LD_VAR 0 1
76816: PPUSH
76817: CALL_OW 248
76821: PPUSH
76822: CALL_OW 450
76826: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76827: LD_ADDR_VAR 0 3
76831: PUSH
76832: LD_VAR 0 4
76836: PPUSH
76837: LD_INT 1
76839: PPUSH
76840: CALL_OW 275
76844: PUSH
76845: LD_VAR 0 5
76849: PUSH
76850: LD_INT 1
76852: ARRAY
76853: GREATEREQUAL
76854: PUSH
76855: LD_VAR 0 4
76859: PPUSH
76860: LD_INT 2
76862: PPUSH
76863: CALL_OW 275
76867: PUSH
76868: LD_VAR 0 5
76872: PUSH
76873: LD_INT 2
76875: ARRAY
76876: GREATEREQUAL
76877: AND
76878: PUSH
76879: LD_VAR 0 4
76883: PPUSH
76884: LD_INT 3
76886: PPUSH
76887: CALL_OW 275
76891: PUSH
76892: LD_VAR 0 5
76896: PUSH
76897: LD_INT 3
76899: ARRAY
76900: GREATEREQUAL
76901: AND
76902: ST_TO_ADDR
// end ;
76903: LD_VAR 0 3
76907: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76908: LD_INT 0
76910: PPUSH
76911: PPUSH
76912: PPUSH
76913: PPUSH
76914: PPUSH
76915: PPUSH
76916: PPUSH
76917: PPUSH
76918: PPUSH
76919: PPUSH
// result := false ;
76920: LD_ADDR_VAR 0 6
76924: PUSH
76925: LD_INT 0
76927: ST_TO_ADDR
// if not base or not btype or not x or not y then
76928: LD_VAR 0 1
76932: NOT
76933: PUSH
76934: LD_VAR 0 2
76938: NOT
76939: OR
76940: PUSH
76941: LD_VAR 0 3
76945: NOT
76946: OR
76947: PUSH
76948: LD_VAR 0 4
76952: NOT
76953: OR
76954: IFFALSE 76958
// exit ;
76956: GO 77567
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76958: LD_ADDR_VAR 0 12
76962: PUSH
76963: LD_VAR 0 2
76967: PPUSH
76968: LD_VAR 0 3
76972: PPUSH
76973: LD_VAR 0 4
76977: PPUSH
76978: LD_VAR 0 5
76982: PPUSH
76983: LD_VAR 0 1
76987: PUSH
76988: LD_INT 1
76990: ARRAY
76991: PPUSH
76992: CALL_OW 248
76996: PPUSH
76997: LD_INT 0
76999: PPUSH
77000: CALL 78404 0 6
77004: ST_TO_ADDR
// if not hexes then
77005: LD_VAR 0 12
77009: NOT
77010: IFFALSE 77014
// exit ;
77012: GO 77567
// for i = 1 to hexes do
77014: LD_ADDR_VAR 0 7
77018: PUSH
77019: DOUBLE
77020: LD_INT 1
77022: DEC
77023: ST_TO_ADDR
77024: LD_VAR 0 12
77028: PUSH
77029: FOR_TO
77030: IFFALSE 77565
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77032: LD_ADDR_VAR 0 11
77036: PUSH
77037: LD_VAR 0 12
77041: PUSH
77042: LD_VAR 0 7
77046: ARRAY
77047: PUSH
77048: LD_INT 1
77050: ARRAY
77051: PPUSH
77052: LD_VAR 0 12
77056: PUSH
77057: LD_VAR 0 7
77061: ARRAY
77062: PUSH
77063: LD_INT 2
77065: ARRAY
77066: PPUSH
77067: CALL_OW 428
77071: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77072: LD_VAR 0 12
77076: PUSH
77077: LD_VAR 0 7
77081: ARRAY
77082: PUSH
77083: LD_INT 1
77085: ARRAY
77086: PPUSH
77087: LD_VAR 0 12
77091: PUSH
77092: LD_VAR 0 7
77096: ARRAY
77097: PUSH
77098: LD_INT 2
77100: ARRAY
77101: PPUSH
77102: CALL_OW 351
77106: PUSH
77107: LD_VAR 0 12
77111: PUSH
77112: LD_VAR 0 7
77116: ARRAY
77117: PUSH
77118: LD_INT 1
77120: ARRAY
77121: PPUSH
77122: LD_VAR 0 12
77126: PUSH
77127: LD_VAR 0 7
77131: ARRAY
77132: PUSH
77133: LD_INT 2
77135: ARRAY
77136: PPUSH
77137: CALL_OW 488
77141: NOT
77142: OR
77143: PUSH
77144: LD_VAR 0 11
77148: PPUSH
77149: CALL_OW 247
77153: PUSH
77154: LD_INT 3
77156: EQUAL
77157: OR
77158: IFFALSE 77164
// exit ;
77160: POP
77161: POP
77162: GO 77567
// if not tmp or not tmp in base then
77164: LD_VAR 0 11
77168: NOT
77169: PUSH
77170: LD_VAR 0 11
77174: PUSH
77175: LD_VAR 0 1
77179: IN
77180: NOT
77181: OR
77182: IFFALSE 77186
// continue ;
77184: GO 77029
// result := true ;
77186: LD_ADDR_VAR 0 6
77190: PUSH
77191: LD_INT 1
77193: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77194: LD_ADDR_VAR 0 15
77198: PUSH
77199: LD_VAR 0 1
77203: PPUSH
77204: LD_INT 22
77206: PUSH
77207: LD_VAR 0 11
77211: PPUSH
77212: CALL_OW 255
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 2
77223: PUSH
77224: LD_INT 30
77226: PUSH
77227: LD_INT 0
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 30
77236: PUSH
77237: LD_INT 1
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: LIST
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PPUSH
77253: CALL_OW 72
77257: ST_TO_ADDR
// if dep then
77258: LD_VAR 0 15
77262: IFFALSE 77398
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77264: LD_ADDR_VAR 0 14
77268: PUSH
77269: LD_VAR 0 15
77273: PUSH
77274: LD_INT 1
77276: ARRAY
77277: PPUSH
77278: CALL_OW 250
77282: PPUSH
77283: LD_VAR 0 15
77287: PUSH
77288: LD_INT 1
77290: ARRAY
77291: PPUSH
77292: CALL_OW 254
77296: PPUSH
77297: LD_INT 5
77299: PPUSH
77300: CALL_OW 272
77304: PUSH
77305: LD_VAR 0 15
77309: PUSH
77310: LD_INT 1
77312: ARRAY
77313: PPUSH
77314: CALL_OW 251
77318: PPUSH
77319: LD_VAR 0 15
77323: PUSH
77324: LD_INT 1
77326: ARRAY
77327: PPUSH
77328: CALL_OW 254
77332: PPUSH
77333: LD_INT 5
77335: PPUSH
77336: CALL_OW 273
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77345: LD_VAR 0 14
77349: PUSH
77350: LD_INT 1
77352: ARRAY
77353: PPUSH
77354: LD_VAR 0 14
77358: PUSH
77359: LD_INT 2
77361: ARRAY
77362: PPUSH
77363: CALL_OW 488
77367: IFFALSE 77398
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77369: LD_VAR 0 11
77373: PPUSH
77374: LD_VAR 0 14
77378: PUSH
77379: LD_INT 1
77381: ARRAY
77382: PPUSH
77383: LD_VAR 0 14
77387: PUSH
77388: LD_INT 2
77390: ARRAY
77391: PPUSH
77392: CALL_OW 111
// continue ;
77396: GO 77029
// end ; end ; r := GetDir ( tmp ) ;
77398: LD_ADDR_VAR 0 13
77402: PUSH
77403: LD_VAR 0 11
77407: PPUSH
77408: CALL_OW 254
77412: ST_TO_ADDR
// if r = 5 then
77413: LD_VAR 0 13
77417: PUSH
77418: LD_INT 5
77420: EQUAL
77421: IFFALSE 77431
// r := 0 ;
77423: LD_ADDR_VAR 0 13
77427: PUSH
77428: LD_INT 0
77430: ST_TO_ADDR
// for j = r to 5 do
77431: LD_ADDR_VAR 0 8
77435: PUSH
77436: DOUBLE
77437: LD_VAR 0 13
77441: DEC
77442: ST_TO_ADDR
77443: LD_INT 5
77445: PUSH
77446: FOR_TO
77447: IFFALSE 77561
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77449: LD_ADDR_VAR 0 9
77453: PUSH
77454: LD_VAR 0 11
77458: PPUSH
77459: CALL_OW 250
77463: PPUSH
77464: LD_VAR 0 8
77468: PPUSH
77469: LD_INT 2
77471: PPUSH
77472: CALL_OW 272
77476: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77477: LD_ADDR_VAR 0 10
77481: PUSH
77482: LD_VAR 0 11
77486: PPUSH
77487: CALL_OW 251
77491: PPUSH
77492: LD_VAR 0 8
77496: PPUSH
77497: LD_INT 2
77499: PPUSH
77500: CALL_OW 273
77504: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77505: LD_VAR 0 9
77509: PPUSH
77510: LD_VAR 0 10
77514: PPUSH
77515: CALL_OW 488
77519: PUSH
77520: LD_VAR 0 9
77524: PPUSH
77525: LD_VAR 0 10
77529: PPUSH
77530: CALL_OW 428
77534: NOT
77535: AND
77536: IFFALSE 77559
// begin ComMoveXY ( tmp , _x , _y ) ;
77538: LD_VAR 0 11
77542: PPUSH
77543: LD_VAR 0 9
77547: PPUSH
77548: LD_VAR 0 10
77552: PPUSH
77553: CALL_OW 111
// break ;
77557: GO 77561
// end ; end ;
77559: GO 77446
77561: POP
77562: POP
// end ;
77563: GO 77029
77565: POP
77566: POP
// end ;
77567: LD_VAR 0 6
77571: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77572: LD_INT 0
77574: PPUSH
77575: PPUSH
77576: PPUSH
77577: PPUSH
77578: PPUSH
77579: PPUSH
77580: PPUSH
77581: PPUSH
77582: PPUSH
77583: PPUSH
// result := false ;
77584: LD_ADDR_VAR 0 6
77588: PUSH
77589: LD_INT 0
77591: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77592: LD_VAR 0 1
77596: NOT
77597: PUSH
77598: LD_VAR 0 1
77602: PPUSH
77603: CALL_OW 266
77607: PUSH
77608: LD_INT 0
77610: PUSH
77611: LD_INT 1
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: IN
77618: NOT
77619: OR
77620: PUSH
77621: LD_VAR 0 2
77625: NOT
77626: OR
77627: PUSH
77628: LD_VAR 0 5
77632: PUSH
77633: LD_INT 0
77635: PUSH
77636: LD_INT 1
77638: PUSH
77639: LD_INT 2
77641: PUSH
77642: LD_INT 3
77644: PUSH
77645: LD_INT 4
77647: PUSH
77648: LD_INT 5
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: IN
77659: NOT
77660: OR
77661: PUSH
77662: LD_VAR 0 3
77666: PPUSH
77667: LD_VAR 0 4
77671: PPUSH
77672: CALL_OW 488
77676: NOT
77677: OR
77678: IFFALSE 77682
// exit ;
77680: GO 78399
// pom := GetBase ( depot ) ;
77682: LD_ADDR_VAR 0 10
77686: PUSH
77687: LD_VAR 0 1
77691: PPUSH
77692: CALL_OW 274
77696: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77697: LD_ADDR_VAR 0 11
77701: PUSH
77702: LD_VAR 0 2
77706: PPUSH
77707: LD_VAR 0 1
77711: PPUSH
77712: CALL_OW 248
77716: PPUSH
77717: CALL_OW 450
77721: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77722: LD_VAR 0 10
77726: PPUSH
77727: LD_INT 1
77729: PPUSH
77730: CALL_OW 275
77734: PUSH
77735: LD_VAR 0 11
77739: PUSH
77740: LD_INT 1
77742: ARRAY
77743: GREATEREQUAL
77744: PUSH
77745: LD_VAR 0 10
77749: PPUSH
77750: LD_INT 2
77752: PPUSH
77753: CALL_OW 275
77757: PUSH
77758: LD_VAR 0 11
77762: PUSH
77763: LD_INT 2
77765: ARRAY
77766: GREATEREQUAL
77767: AND
77768: PUSH
77769: LD_VAR 0 10
77773: PPUSH
77774: LD_INT 3
77776: PPUSH
77777: CALL_OW 275
77781: PUSH
77782: LD_VAR 0 11
77786: PUSH
77787: LD_INT 3
77789: ARRAY
77790: GREATEREQUAL
77791: AND
77792: NOT
77793: IFFALSE 77797
// exit ;
77795: GO 78399
// if GetBType ( depot ) = b_depot then
77797: LD_VAR 0 1
77801: PPUSH
77802: CALL_OW 266
77806: PUSH
77807: LD_INT 0
77809: EQUAL
77810: IFFALSE 77822
// dist := 28 else
77812: LD_ADDR_VAR 0 14
77816: PUSH
77817: LD_INT 28
77819: ST_TO_ADDR
77820: GO 77830
// dist := 36 ;
77822: LD_ADDR_VAR 0 14
77826: PUSH
77827: LD_INT 36
77829: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77830: LD_VAR 0 1
77834: PPUSH
77835: LD_VAR 0 3
77839: PPUSH
77840: LD_VAR 0 4
77844: PPUSH
77845: CALL_OW 297
77849: PUSH
77850: LD_VAR 0 14
77854: GREATER
77855: IFFALSE 77859
// exit ;
77857: GO 78399
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77859: LD_ADDR_VAR 0 12
77863: PUSH
77864: LD_VAR 0 2
77868: PPUSH
77869: LD_VAR 0 3
77873: PPUSH
77874: LD_VAR 0 4
77878: PPUSH
77879: LD_VAR 0 5
77883: PPUSH
77884: LD_VAR 0 1
77888: PPUSH
77889: CALL_OW 248
77893: PPUSH
77894: LD_INT 0
77896: PPUSH
77897: CALL 78404 0 6
77901: ST_TO_ADDR
// if not hexes then
77902: LD_VAR 0 12
77906: NOT
77907: IFFALSE 77911
// exit ;
77909: GO 78399
// hex := GetHexInfo ( x , y ) ;
77911: LD_ADDR_VAR 0 15
77915: PUSH
77916: LD_VAR 0 3
77920: PPUSH
77921: LD_VAR 0 4
77925: PPUSH
77926: CALL_OW 546
77930: ST_TO_ADDR
// if hex [ 1 ] then
77931: LD_VAR 0 15
77935: PUSH
77936: LD_INT 1
77938: ARRAY
77939: IFFALSE 77943
// exit ;
77941: GO 78399
// height := hex [ 2 ] ;
77943: LD_ADDR_VAR 0 13
77947: PUSH
77948: LD_VAR 0 15
77952: PUSH
77953: LD_INT 2
77955: ARRAY
77956: ST_TO_ADDR
// for i = 1 to hexes do
77957: LD_ADDR_VAR 0 7
77961: PUSH
77962: DOUBLE
77963: LD_INT 1
77965: DEC
77966: ST_TO_ADDR
77967: LD_VAR 0 12
77971: PUSH
77972: FOR_TO
77973: IFFALSE 78303
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77975: LD_VAR 0 12
77979: PUSH
77980: LD_VAR 0 7
77984: ARRAY
77985: PUSH
77986: LD_INT 1
77988: ARRAY
77989: PPUSH
77990: LD_VAR 0 12
77994: PUSH
77995: LD_VAR 0 7
77999: ARRAY
78000: PUSH
78001: LD_INT 2
78003: ARRAY
78004: PPUSH
78005: CALL_OW 488
78009: NOT
78010: PUSH
78011: LD_VAR 0 12
78015: PUSH
78016: LD_VAR 0 7
78020: ARRAY
78021: PUSH
78022: LD_INT 1
78024: ARRAY
78025: PPUSH
78026: LD_VAR 0 12
78030: PUSH
78031: LD_VAR 0 7
78035: ARRAY
78036: PUSH
78037: LD_INT 2
78039: ARRAY
78040: PPUSH
78041: CALL_OW 428
78045: PUSH
78046: LD_INT 0
78048: GREATER
78049: OR
78050: PUSH
78051: LD_VAR 0 12
78055: PUSH
78056: LD_VAR 0 7
78060: ARRAY
78061: PUSH
78062: LD_INT 1
78064: ARRAY
78065: PPUSH
78066: LD_VAR 0 12
78070: PUSH
78071: LD_VAR 0 7
78075: ARRAY
78076: PUSH
78077: LD_INT 2
78079: ARRAY
78080: PPUSH
78081: CALL_OW 351
78085: OR
78086: IFFALSE 78092
// exit ;
78088: POP
78089: POP
78090: GO 78399
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78092: LD_ADDR_VAR 0 8
78096: PUSH
78097: LD_VAR 0 12
78101: PUSH
78102: LD_VAR 0 7
78106: ARRAY
78107: PUSH
78108: LD_INT 1
78110: ARRAY
78111: PPUSH
78112: LD_VAR 0 12
78116: PUSH
78117: LD_VAR 0 7
78121: ARRAY
78122: PUSH
78123: LD_INT 2
78125: ARRAY
78126: PPUSH
78127: CALL_OW 546
78131: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78132: LD_VAR 0 8
78136: PUSH
78137: LD_INT 1
78139: ARRAY
78140: PUSH
78141: LD_VAR 0 8
78145: PUSH
78146: LD_INT 2
78148: ARRAY
78149: PUSH
78150: LD_VAR 0 13
78154: PUSH
78155: LD_INT 2
78157: PLUS
78158: GREATER
78159: OR
78160: PUSH
78161: LD_VAR 0 8
78165: PUSH
78166: LD_INT 2
78168: ARRAY
78169: PUSH
78170: LD_VAR 0 13
78174: PUSH
78175: LD_INT 2
78177: MINUS
78178: LESS
78179: OR
78180: PUSH
78181: LD_VAR 0 8
78185: PUSH
78186: LD_INT 3
78188: ARRAY
78189: PUSH
78190: LD_INT 0
78192: PUSH
78193: LD_INT 8
78195: PUSH
78196: LD_INT 9
78198: PUSH
78199: LD_INT 10
78201: PUSH
78202: LD_INT 11
78204: PUSH
78205: LD_INT 12
78207: PUSH
78208: LD_INT 13
78210: PUSH
78211: LD_INT 16
78213: PUSH
78214: LD_INT 17
78216: PUSH
78217: LD_INT 18
78219: PUSH
78220: LD_INT 19
78222: PUSH
78223: LD_INT 20
78225: PUSH
78226: LD_INT 21
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: IN
78244: NOT
78245: OR
78246: PUSH
78247: LD_VAR 0 8
78251: PUSH
78252: LD_INT 5
78254: ARRAY
78255: NOT
78256: OR
78257: PUSH
78258: LD_VAR 0 8
78262: PUSH
78263: LD_INT 6
78265: ARRAY
78266: PUSH
78267: LD_INT 1
78269: PUSH
78270: LD_INT 2
78272: PUSH
78273: LD_INT 7
78275: PUSH
78276: LD_INT 9
78278: PUSH
78279: LD_INT 10
78281: PUSH
78282: LD_INT 11
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: IN
78293: NOT
78294: OR
78295: IFFALSE 78301
// exit ;
78297: POP
78298: POP
78299: GO 78399
// end ;
78301: GO 77972
78303: POP
78304: POP
// side := GetSide ( depot ) ;
78305: LD_ADDR_VAR 0 9
78309: PUSH
78310: LD_VAR 0 1
78314: PPUSH
78315: CALL_OW 255
78319: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78320: LD_VAR 0 9
78324: PPUSH
78325: LD_VAR 0 3
78329: PPUSH
78330: LD_VAR 0 4
78334: PPUSH
78335: LD_INT 20
78337: PPUSH
78338: CALL 71053 0 4
78342: PUSH
78343: LD_INT 4
78345: ARRAY
78346: IFFALSE 78350
// exit ;
78348: GO 78399
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78350: LD_VAR 0 2
78354: PUSH
78355: LD_INT 29
78357: PUSH
78358: LD_INT 30
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: IN
78365: PUSH
78366: LD_VAR 0 3
78370: PPUSH
78371: LD_VAR 0 4
78375: PPUSH
78376: LD_VAR 0 9
78380: PPUSH
78381: CALL_OW 440
78385: NOT
78386: AND
78387: IFFALSE 78391
// exit ;
78389: GO 78399
// result := true ;
78391: LD_ADDR_VAR 0 6
78395: PUSH
78396: LD_INT 1
78398: ST_TO_ADDR
// end ;
78399: LD_VAR 0 6
78403: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78404: LD_INT 0
78406: PPUSH
78407: PPUSH
78408: PPUSH
78409: PPUSH
78410: PPUSH
78411: PPUSH
78412: PPUSH
78413: PPUSH
78414: PPUSH
78415: PPUSH
78416: PPUSH
78417: PPUSH
78418: PPUSH
78419: PPUSH
78420: PPUSH
78421: PPUSH
78422: PPUSH
78423: PPUSH
78424: PPUSH
78425: PPUSH
78426: PPUSH
78427: PPUSH
78428: PPUSH
78429: PPUSH
78430: PPUSH
78431: PPUSH
78432: PPUSH
78433: PPUSH
78434: PPUSH
78435: PPUSH
78436: PPUSH
78437: PPUSH
78438: PPUSH
78439: PPUSH
78440: PPUSH
78441: PPUSH
78442: PPUSH
78443: PPUSH
78444: PPUSH
78445: PPUSH
78446: PPUSH
78447: PPUSH
78448: PPUSH
78449: PPUSH
78450: PPUSH
78451: PPUSH
78452: PPUSH
78453: PPUSH
78454: PPUSH
78455: PPUSH
78456: PPUSH
78457: PPUSH
78458: PPUSH
78459: PPUSH
78460: PPUSH
78461: PPUSH
78462: PPUSH
78463: PPUSH
// result = [ ] ;
78464: LD_ADDR_VAR 0 7
78468: PUSH
78469: EMPTY
78470: ST_TO_ADDR
// temp_list = [ ] ;
78471: LD_ADDR_VAR 0 9
78475: PUSH
78476: EMPTY
78477: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78478: LD_VAR 0 4
78482: PUSH
78483: LD_INT 0
78485: PUSH
78486: LD_INT 1
78488: PUSH
78489: LD_INT 2
78491: PUSH
78492: LD_INT 3
78494: PUSH
78495: LD_INT 4
78497: PUSH
78498: LD_INT 5
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: LIST
78508: IN
78509: NOT
78510: PUSH
78511: LD_VAR 0 1
78515: PUSH
78516: LD_INT 0
78518: PUSH
78519: LD_INT 1
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: IN
78526: PUSH
78527: LD_VAR 0 5
78531: PUSH
78532: LD_INT 1
78534: PUSH
78535: LD_INT 2
78537: PUSH
78538: LD_INT 3
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: LIST
78545: IN
78546: NOT
78547: AND
78548: OR
78549: IFFALSE 78553
// exit ;
78551: GO 96944
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78553: LD_VAR 0 1
78557: PUSH
78558: LD_INT 6
78560: PUSH
78561: LD_INT 7
78563: PUSH
78564: LD_INT 8
78566: PUSH
78567: LD_INT 13
78569: PUSH
78570: LD_INT 12
78572: PUSH
78573: LD_INT 15
78575: PUSH
78576: LD_INT 11
78578: PUSH
78579: LD_INT 14
78581: PUSH
78582: LD_INT 10
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: IN
78596: IFFALSE 78606
// btype = b_lab ;
78598: LD_ADDR_VAR 0 1
78602: PUSH
78603: LD_INT 6
78605: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78606: LD_VAR 0 6
78610: PUSH
78611: LD_INT 0
78613: PUSH
78614: LD_INT 1
78616: PUSH
78617: LD_INT 2
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: LIST
78624: IN
78625: NOT
78626: PUSH
78627: LD_VAR 0 1
78631: PUSH
78632: LD_INT 0
78634: PUSH
78635: LD_INT 1
78637: PUSH
78638: LD_INT 2
78640: PUSH
78641: LD_INT 3
78643: PUSH
78644: LD_INT 6
78646: PUSH
78647: LD_INT 36
78649: PUSH
78650: LD_INT 4
78652: PUSH
78653: LD_INT 5
78655: PUSH
78656: LD_INT 31
78658: PUSH
78659: LD_INT 32
78661: PUSH
78662: LD_INT 33
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: LIST
78671: LIST
78672: LIST
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: IN
78678: NOT
78679: PUSH
78680: LD_VAR 0 6
78684: PUSH
78685: LD_INT 1
78687: EQUAL
78688: AND
78689: OR
78690: PUSH
78691: LD_VAR 0 1
78695: PUSH
78696: LD_INT 2
78698: PUSH
78699: LD_INT 3
78701: PUSH
78702: EMPTY
78703: LIST
78704: LIST
78705: IN
78706: NOT
78707: PUSH
78708: LD_VAR 0 6
78712: PUSH
78713: LD_INT 2
78715: EQUAL
78716: AND
78717: OR
78718: IFFALSE 78728
// mode = 0 ;
78720: LD_ADDR_VAR 0 6
78724: PUSH
78725: LD_INT 0
78727: ST_TO_ADDR
// case mode of 0 :
78728: LD_VAR 0 6
78732: PUSH
78733: LD_INT 0
78735: DOUBLE
78736: EQUAL
78737: IFTRUE 78741
78739: GO 90194
78741: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78742: LD_ADDR_VAR 0 11
78746: PUSH
78747: LD_INT 0
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: EMPTY
78754: LIST
78755: LIST
78756: PUSH
78757: LD_INT 0
78759: PUSH
78760: LD_INT 1
78762: NEG
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 1
78770: PUSH
78771: LD_INT 0
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: LD_INT 1
78780: PUSH
78781: LD_INT 1
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 0
78790: PUSH
78791: LD_INT 1
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 1
78800: NEG
78801: PUSH
78802: LD_INT 0
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 1
78811: NEG
78812: PUSH
78813: LD_INT 1
78815: NEG
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 1
78823: NEG
78824: PUSH
78825: LD_INT 2
78827: NEG
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 0
78835: PUSH
78836: LD_INT 2
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 1
78846: PUSH
78847: LD_INT 1
78849: NEG
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: PUSH
78855: LD_INT 1
78857: PUSH
78858: LD_INT 2
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: PUSH
78865: LD_INT 0
78867: PUSH
78868: LD_INT 2
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 1
78877: NEG
78878: PUSH
78879: LD_INT 1
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: PUSH
78886: LD_INT 1
78888: PUSH
78889: LD_INT 3
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: LD_INT 0
78898: PUSH
78899: LD_INT 3
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 1
78908: NEG
78909: PUSH
78910: LD_INT 2
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78935: LD_ADDR_VAR 0 12
78939: PUSH
78940: LD_INT 0
78942: PUSH
78943: LD_INT 0
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 0
78952: PUSH
78953: LD_INT 1
78955: NEG
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 1
78963: PUSH
78964: LD_INT 0
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 1
78973: PUSH
78974: LD_INT 1
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 0
78983: PUSH
78984: LD_INT 1
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 1
78993: NEG
78994: PUSH
78995: LD_INT 0
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 1
79004: NEG
79005: PUSH
79006: LD_INT 1
79008: NEG
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 1
79016: PUSH
79017: LD_INT 1
79019: NEG
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: PUSH
79025: LD_INT 2
79027: PUSH
79028: LD_INT 0
79030: PUSH
79031: EMPTY
79032: LIST
79033: LIST
79034: PUSH
79035: LD_INT 2
79037: PUSH
79038: LD_INT 1
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PUSH
79045: LD_INT 1
79047: NEG
79048: PUSH
79049: LD_INT 1
79051: PUSH
79052: EMPTY
79053: LIST
79054: LIST
79055: PUSH
79056: LD_INT 2
79058: NEG
79059: PUSH
79060: LD_INT 0
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: LD_INT 2
79069: NEG
79070: PUSH
79071: LD_INT 1
79073: NEG
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 2
79081: NEG
79082: PUSH
79083: LD_INT 1
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 3
79092: NEG
79093: PUSH
79094: LD_INT 0
79096: PUSH
79097: EMPTY
79098: LIST
79099: LIST
79100: PUSH
79101: LD_INT 3
79103: NEG
79104: PUSH
79105: LD_INT 1
79107: NEG
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: LIST
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79131: LD_ADDR_VAR 0 13
79135: PUSH
79136: LD_INT 0
79138: PUSH
79139: LD_INT 0
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 0
79148: PUSH
79149: LD_INT 1
79151: NEG
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 1
79159: PUSH
79160: LD_INT 0
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 1
79169: PUSH
79170: LD_INT 1
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 0
79179: PUSH
79180: LD_INT 1
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 1
79189: NEG
79190: PUSH
79191: LD_INT 0
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 1
79200: NEG
79201: PUSH
79202: LD_INT 1
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 1
79212: NEG
79213: PUSH
79214: LD_INT 2
79216: NEG
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 2
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 2
79234: PUSH
79235: LD_INT 2
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 1
79244: PUSH
79245: LD_INT 2
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 2
79254: NEG
79255: PUSH
79256: LD_INT 1
79258: NEG
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: LD_INT 2
79266: NEG
79267: PUSH
79268: LD_INT 2
79270: NEG
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: LD_INT 2
79278: NEG
79279: PUSH
79280: LD_INT 3
79282: NEG
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 3
79290: NEG
79291: PUSH
79292: LD_INT 2
79294: NEG
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 3
79302: NEG
79303: PUSH
79304: LD_INT 3
79306: NEG
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79330: LD_ADDR_VAR 0 14
79334: PUSH
79335: LD_INT 0
79337: PUSH
79338: LD_INT 0
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 0
79347: PUSH
79348: LD_INT 1
79350: NEG
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 1
79358: PUSH
79359: LD_INT 0
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: PUSH
79366: LD_INT 1
79368: PUSH
79369: LD_INT 1
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: PUSH
79376: LD_INT 0
79378: PUSH
79379: LD_INT 1
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 1
79388: NEG
79389: PUSH
79390: LD_INT 0
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 1
79399: NEG
79400: PUSH
79401: LD_INT 1
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 1
79411: NEG
79412: PUSH
79413: LD_INT 2
79415: NEG
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: LD_INT 0
79423: PUSH
79424: LD_INT 2
79426: NEG
79427: PUSH
79428: EMPTY
79429: LIST
79430: LIST
79431: PUSH
79432: LD_INT 1
79434: PUSH
79435: LD_INT 1
79437: NEG
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: LD_INT 1
79445: PUSH
79446: LD_INT 2
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 0
79455: PUSH
79456: LD_INT 2
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 1
79465: NEG
79466: PUSH
79467: LD_INT 1
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: LD_INT 1
79476: NEG
79477: PUSH
79478: LD_INT 3
79480: NEG
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 0
79488: PUSH
79489: LD_INT 3
79491: NEG
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 1
79499: PUSH
79500: LD_INT 2
79502: NEG
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79526: LD_ADDR_VAR 0 15
79530: PUSH
79531: LD_INT 0
79533: PUSH
79534: LD_INT 0
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 0
79543: PUSH
79544: LD_INT 1
79546: NEG
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 1
79554: PUSH
79555: LD_INT 0
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 1
79564: PUSH
79565: LD_INT 1
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 0
79574: PUSH
79575: LD_INT 1
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: LD_INT 0
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 1
79595: NEG
79596: PUSH
79597: LD_INT 1
79599: NEG
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PUSH
79605: LD_INT 1
79607: PUSH
79608: LD_INT 1
79610: NEG
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 2
79618: PUSH
79619: LD_INT 0
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 2
79628: PUSH
79629: LD_INT 1
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 1
79638: NEG
79639: PUSH
79640: LD_INT 1
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 2
79649: NEG
79650: PUSH
79651: LD_INT 0
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 2
79660: NEG
79661: PUSH
79662: LD_INT 1
79664: NEG
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 2
79672: PUSH
79673: LD_INT 1
79675: NEG
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 3
79683: PUSH
79684: LD_INT 0
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 3
79693: PUSH
79694: LD_INT 1
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79719: LD_ADDR_VAR 0 16
79723: PUSH
79724: LD_INT 0
79726: PUSH
79727: LD_INT 0
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 0
79736: PUSH
79737: LD_INT 1
79739: NEG
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 1
79747: PUSH
79748: LD_INT 0
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 1
79757: PUSH
79758: LD_INT 1
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 0
79767: PUSH
79768: LD_INT 1
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 1
79777: NEG
79778: PUSH
79779: LD_INT 0
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 1
79788: NEG
79789: PUSH
79790: LD_INT 1
79792: NEG
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 1
79800: NEG
79801: PUSH
79802: LD_INT 2
79804: NEG
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 2
79812: PUSH
79813: LD_INT 1
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 2
79822: PUSH
79823: LD_INT 2
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 1
79832: PUSH
79833: LD_INT 2
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 2
79842: NEG
79843: PUSH
79844: LD_INT 1
79846: NEG
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 2
79854: NEG
79855: PUSH
79856: LD_INT 2
79858: NEG
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 3
79866: PUSH
79867: LD_INT 2
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 3
79876: PUSH
79877: LD_INT 3
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 2
79886: PUSH
79887: LD_INT 3
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79912: LD_ADDR_VAR 0 17
79916: PUSH
79917: LD_INT 0
79919: PUSH
79920: LD_INT 0
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: PUSH
79927: LD_INT 0
79929: PUSH
79930: LD_INT 1
79932: NEG
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 1
79940: PUSH
79941: LD_INT 0
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 1
79950: PUSH
79951: LD_INT 1
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: LD_INT 0
79960: PUSH
79961: LD_INT 1
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 1
79970: NEG
79971: PUSH
79972: LD_INT 0
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 1
79981: NEG
79982: PUSH
79983: LD_INT 1
79985: NEG
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 1
79993: NEG
79994: PUSH
79995: LD_INT 2
79997: NEG
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 0
80005: PUSH
80006: LD_INT 2
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 1
80016: PUSH
80017: LD_INT 1
80019: NEG
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 2
80027: PUSH
80028: LD_INT 0
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 2
80037: PUSH
80038: LD_INT 1
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 2
80047: PUSH
80048: LD_INT 2
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 1
80057: PUSH
80058: LD_INT 2
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 0
80067: PUSH
80068: LD_INT 2
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 1
80077: NEG
80078: PUSH
80079: LD_INT 1
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 2
80088: NEG
80089: PUSH
80090: LD_INT 0
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 2
80099: NEG
80100: PUSH
80101: LD_INT 1
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 2
80111: NEG
80112: PUSH
80113: LD_INT 2
80115: NEG
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: LIST
80141: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80142: LD_ADDR_VAR 0 18
80146: PUSH
80147: LD_INT 0
80149: PUSH
80150: LD_INT 0
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 0
80159: PUSH
80160: LD_INT 1
80162: NEG
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 1
80170: PUSH
80171: LD_INT 0
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 1
80180: PUSH
80181: LD_INT 1
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 1
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 1
80200: NEG
80201: PUSH
80202: LD_INT 0
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 1
80211: NEG
80212: PUSH
80213: LD_INT 1
80215: NEG
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: NEG
80224: PUSH
80225: LD_INT 2
80227: NEG
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 0
80235: PUSH
80236: LD_INT 2
80238: NEG
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 1
80246: PUSH
80247: LD_INT 1
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 2
80257: PUSH
80258: LD_INT 0
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: PUSH
80265: LD_INT 2
80267: PUSH
80268: LD_INT 1
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 2
80277: PUSH
80278: LD_INT 2
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 1
80287: PUSH
80288: LD_INT 2
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 0
80297: PUSH
80298: LD_INT 2
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 1
80307: NEG
80308: PUSH
80309: LD_INT 1
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 2
80318: NEG
80319: PUSH
80320: LD_INT 0
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 2
80329: NEG
80330: PUSH
80331: LD_INT 1
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 2
80341: NEG
80342: PUSH
80343: LD_INT 2
80345: NEG
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80372: LD_ADDR_VAR 0 19
80376: PUSH
80377: LD_INT 0
80379: PUSH
80380: LD_INT 0
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 0
80389: PUSH
80390: LD_INT 1
80392: NEG
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 1
80400: PUSH
80401: LD_INT 0
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 1
80410: PUSH
80411: LD_INT 1
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 0
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 1
80430: NEG
80431: PUSH
80432: LD_INT 0
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 1
80441: NEG
80442: PUSH
80443: LD_INT 1
80445: NEG
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 1
80453: NEG
80454: PUSH
80455: LD_INT 2
80457: NEG
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 0
80465: PUSH
80466: LD_INT 2
80468: NEG
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 1
80476: PUSH
80477: LD_INT 1
80479: NEG
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 2
80487: PUSH
80488: LD_INT 0
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 2
80497: PUSH
80498: LD_INT 1
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 2
80507: PUSH
80508: LD_INT 2
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 1
80517: PUSH
80518: LD_INT 2
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 0
80527: PUSH
80528: LD_INT 2
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 1
80537: NEG
80538: PUSH
80539: LD_INT 1
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 2
80548: NEG
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 2
80559: NEG
80560: PUSH
80561: LD_INT 1
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 2
80571: NEG
80572: PUSH
80573: LD_INT 2
80575: NEG
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80602: LD_ADDR_VAR 0 20
80606: PUSH
80607: LD_INT 0
80609: PUSH
80610: LD_INT 0
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 0
80619: PUSH
80620: LD_INT 1
80622: NEG
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 1
80630: PUSH
80631: LD_INT 0
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 1
80640: PUSH
80641: LD_INT 1
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 1
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 1
80660: NEG
80661: PUSH
80662: LD_INT 0
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 1
80671: NEG
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 1
80683: NEG
80684: PUSH
80685: LD_INT 2
80687: NEG
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 0
80695: PUSH
80696: LD_INT 2
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 1
80706: PUSH
80707: LD_INT 1
80709: NEG
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 2
80717: PUSH
80718: LD_INT 0
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: PUSH
80725: LD_INT 2
80727: PUSH
80728: LD_INT 1
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 2
80737: PUSH
80738: LD_INT 2
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 1
80747: PUSH
80748: LD_INT 2
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 0
80757: PUSH
80758: LD_INT 2
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: LD_INT 1
80767: NEG
80768: PUSH
80769: LD_INT 1
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 2
80778: NEG
80779: PUSH
80780: LD_INT 0
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 2
80789: NEG
80790: PUSH
80791: LD_INT 1
80793: NEG
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 2
80801: NEG
80802: PUSH
80803: LD_INT 2
80805: NEG
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80832: LD_ADDR_VAR 0 21
80836: PUSH
80837: LD_INT 0
80839: PUSH
80840: LD_INT 0
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 0
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 1
80860: PUSH
80861: LD_INT 0
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 1
80870: PUSH
80871: LD_INT 1
80873: PUSH
80874: EMPTY
80875: LIST
80876: LIST
80877: PUSH
80878: LD_INT 0
80880: PUSH
80881: LD_INT 1
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 1
80890: NEG
80891: PUSH
80892: LD_INT 0
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 1
80901: NEG
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: LD_INT 1
80913: NEG
80914: PUSH
80915: LD_INT 2
80917: NEG
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: PUSH
80923: LD_INT 0
80925: PUSH
80926: LD_INT 2
80928: NEG
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 1
80936: PUSH
80937: LD_INT 1
80939: NEG
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 2
80947: PUSH
80948: LD_INT 0
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 2
80957: PUSH
80958: LD_INT 1
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 2
80967: PUSH
80968: LD_INT 2
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 1
80977: PUSH
80978: LD_INT 2
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 0
80987: PUSH
80988: LD_INT 2
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: LD_INT 1
80997: NEG
80998: PUSH
80999: LD_INT 1
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 2
81008: NEG
81009: PUSH
81010: LD_INT 0
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 2
81019: NEG
81020: PUSH
81021: LD_INT 1
81023: NEG
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 2
81031: NEG
81032: PUSH
81033: LD_INT 2
81035: NEG
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81062: LD_ADDR_VAR 0 22
81066: PUSH
81067: LD_INT 0
81069: PUSH
81070: LD_INT 0
81072: PUSH
81073: EMPTY
81074: LIST
81075: LIST
81076: PUSH
81077: LD_INT 0
81079: PUSH
81080: LD_INT 1
81082: NEG
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 1
81090: PUSH
81091: LD_INT 0
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 1
81100: PUSH
81101: LD_INT 1
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PUSH
81108: LD_INT 0
81110: PUSH
81111: LD_INT 1
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: LD_INT 0
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: LD_INT 1
81131: NEG
81132: PUSH
81133: LD_INT 1
81135: NEG
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 1
81143: NEG
81144: PUSH
81145: LD_INT 2
81147: NEG
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 0
81155: PUSH
81156: LD_INT 2
81158: NEG
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 1
81166: PUSH
81167: LD_INT 1
81169: NEG
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 2
81177: PUSH
81178: LD_INT 0
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 2
81187: PUSH
81188: LD_INT 1
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 2
81197: PUSH
81198: LD_INT 2
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 1
81207: PUSH
81208: LD_INT 2
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 0
81217: PUSH
81218: LD_INT 2
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 1
81227: NEG
81228: PUSH
81229: LD_INT 1
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 2
81238: NEG
81239: PUSH
81240: LD_INT 0
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 2
81249: NEG
81250: PUSH
81251: LD_INT 1
81253: NEG
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 2
81261: NEG
81262: PUSH
81263: LD_INT 2
81265: NEG
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: PUSH
81271: EMPTY
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: LIST
81289: LIST
81290: LIST
81291: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81292: LD_ADDR_VAR 0 23
81296: PUSH
81297: LD_INT 0
81299: PUSH
81300: LD_INT 0
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 0
81309: PUSH
81310: LD_INT 1
81312: NEG
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 1
81320: PUSH
81321: LD_INT 0
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 1
81330: PUSH
81331: LD_INT 1
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 0
81340: PUSH
81341: LD_INT 1
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 1
81350: NEG
81351: PUSH
81352: LD_INT 0
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: LD_INT 1
81361: NEG
81362: PUSH
81363: LD_INT 1
81365: NEG
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 1
81373: NEG
81374: PUSH
81375: LD_INT 2
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 0
81385: PUSH
81386: LD_INT 2
81388: NEG
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: PUSH
81394: LD_INT 1
81396: PUSH
81397: LD_INT 1
81399: NEG
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 2
81407: PUSH
81408: LD_INT 0
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 2
81417: PUSH
81418: LD_INT 1
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 2
81427: PUSH
81428: LD_INT 2
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: PUSH
81435: LD_INT 1
81437: PUSH
81438: LD_INT 2
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 0
81447: PUSH
81448: LD_INT 2
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: LD_INT 1
81457: NEG
81458: PUSH
81459: LD_INT 1
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 2
81468: NEG
81469: PUSH
81470: LD_INT 0
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: PUSH
81477: LD_INT 2
81479: NEG
81480: PUSH
81481: LD_INT 1
81483: NEG
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 2
81491: NEG
81492: PUSH
81493: LD_INT 2
81495: NEG
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 2
81503: NEG
81504: PUSH
81505: LD_INT 3
81507: NEG
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 1
81515: NEG
81516: PUSH
81517: LD_INT 3
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 1
81527: PUSH
81528: LD_INT 2
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 2
81538: PUSH
81539: LD_INT 1
81541: NEG
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: EMPTY
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: LIST
81562: LIST
81563: LIST
81564: LIST
81565: LIST
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81572: LD_ADDR_VAR 0 24
81576: PUSH
81577: LD_INT 0
81579: PUSH
81580: LD_INT 0
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 0
81589: PUSH
81590: LD_INT 1
81592: NEG
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 1
81600: PUSH
81601: LD_INT 0
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 1
81610: PUSH
81611: LD_INT 1
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 0
81620: PUSH
81621: LD_INT 1
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 1
81630: NEG
81631: PUSH
81632: LD_INT 0
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 1
81641: NEG
81642: PUSH
81643: LD_INT 1
81645: NEG
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 1
81653: NEG
81654: PUSH
81655: LD_INT 2
81657: NEG
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 0
81665: PUSH
81666: LD_INT 2
81668: NEG
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 1
81676: PUSH
81677: LD_INT 1
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 2
81687: PUSH
81688: LD_INT 0
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 2
81697: PUSH
81698: LD_INT 1
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 2
81707: PUSH
81708: LD_INT 2
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 1
81717: PUSH
81718: LD_INT 2
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 0
81727: PUSH
81728: LD_INT 2
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 1
81737: NEG
81738: PUSH
81739: LD_INT 1
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 2
81748: NEG
81749: PUSH
81750: LD_INT 0
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 2
81759: NEG
81760: PUSH
81761: LD_INT 1
81763: NEG
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 2
81771: NEG
81772: PUSH
81773: LD_INT 2
81775: NEG
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 1
81783: PUSH
81784: LD_INT 2
81786: NEG
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 2
81794: PUSH
81795: LD_INT 1
81797: NEG
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 3
81805: PUSH
81806: LD_INT 1
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PUSH
81813: LD_INT 3
81815: PUSH
81816: LD_INT 2
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: LIST
81844: LIST
81845: LIST
81846: LIST
81847: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81848: LD_ADDR_VAR 0 25
81852: PUSH
81853: LD_INT 0
81855: PUSH
81856: LD_INT 0
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 0
81865: PUSH
81866: LD_INT 1
81868: NEG
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 1
81876: PUSH
81877: LD_INT 0
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PUSH
81884: LD_INT 1
81886: PUSH
81887: LD_INT 1
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 0
81896: PUSH
81897: LD_INT 1
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 1
81906: NEG
81907: PUSH
81908: LD_INT 0
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 1
81917: NEG
81918: PUSH
81919: LD_INT 1
81921: NEG
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 1
81929: NEG
81930: PUSH
81931: LD_INT 2
81933: NEG
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: LD_INT 2
81944: NEG
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 1
81952: PUSH
81953: LD_INT 1
81955: NEG
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_INT 2
81963: PUSH
81964: LD_INT 0
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 2
81973: PUSH
81974: LD_INT 1
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: PUSH
81981: LD_INT 2
81983: PUSH
81984: LD_INT 2
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 1
81993: PUSH
81994: LD_INT 2
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 0
82003: PUSH
82004: LD_INT 2
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 1
82013: NEG
82014: PUSH
82015: LD_INT 1
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 2
82024: NEG
82025: PUSH
82026: LD_INT 0
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 2
82035: NEG
82036: PUSH
82037: LD_INT 1
82039: NEG
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: LD_INT 2
82047: NEG
82048: PUSH
82049: LD_INT 2
82051: NEG
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PUSH
82057: LD_INT 3
82059: PUSH
82060: LD_INT 1
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 3
82069: PUSH
82070: LD_INT 2
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 2
82079: PUSH
82080: LD_INT 3
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 1
82089: PUSH
82090: LD_INT 3
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: LIST
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82122: LD_ADDR_VAR 0 26
82126: PUSH
82127: LD_INT 0
82129: PUSH
82130: LD_INT 0
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 0
82139: PUSH
82140: LD_INT 1
82142: NEG
82143: PUSH
82144: EMPTY
82145: LIST
82146: LIST
82147: PUSH
82148: LD_INT 1
82150: PUSH
82151: LD_INT 0
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 1
82160: PUSH
82161: LD_INT 1
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: LD_INT 1
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 1
82180: NEG
82181: PUSH
82182: LD_INT 0
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 1
82191: NEG
82192: PUSH
82193: LD_INT 1
82195: NEG
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 1
82203: NEG
82204: PUSH
82205: LD_INT 2
82207: NEG
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: LD_INT 2
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 1
82226: PUSH
82227: LD_INT 1
82229: NEG
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 2
82237: PUSH
82238: LD_INT 0
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: LD_INT 2
82247: PUSH
82248: LD_INT 1
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 2
82257: PUSH
82258: LD_INT 2
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 1
82267: PUSH
82268: LD_INT 2
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 0
82277: PUSH
82278: LD_INT 2
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 1
82287: NEG
82288: PUSH
82289: LD_INT 1
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 2
82298: NEG
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 2
82309: NEG
82310: PUSH
82311: LD_INT 1
82313: NEG
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 2
82321: NEG
82322: PUSH
82323: LD_INT 2
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 2
82333: PUSH
82334: LD_INT 3
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: LD_INT 3
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: LD_INT 2
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 2
82364: NEG
82365: PUSH
82366: LD_INT 1
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82398: LD_ADDR_VAR 0 27
82402: PUSH
82403: LD_INT 0
82405: PUSH
82406: LD_INT 0
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 0
82415: PUSH
82416: LD_INT 1
82418: NEG
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 1
82426: PUSH
82427: LD_INT 0
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 1
82436: PUSH
82437: LD_INT 1
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 0
82446: PUSH
82447: LD_INT 1
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 1
82456: NEG
82457: PUSH
82458: LD_INT 0
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 1
82467: NEG
82468: PUSH
82469: LD_INT 1
82471: NEG
82472: PUSH
82473: EMPTY
82474: LIST
82475: LIST
82476: PUSH
82477: LD_INT 1
82479: NEG
82480: PUSH
82481: LD_INT 2
82483: NEG
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 0
82491: PUSH
82492: LD_INT 2
82494: NEG
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 1
82502: PUSH
82503: LD_INT 1
82505: NEG
82506: PUSH
82507: EMPTY
82508: LIST
82509: LIST
82510: PUSH
82511: LD_INT 2
82513: PUSH
82514: LD_INT 0
82516: PUSH
82517: EMPTY
82518: LIST
82519: LIST
82520: PUSH
82521: LD_INT 2
82523: PUSH
82524: LD_INT 1
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 2
82533: PUSH
82534: LD_INT 2
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 1
82543: PUSH
82544: LD_INT 2
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: LD_INT 2
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 1
82563: NEG
82564: PUSH
82565: LD_INT 1
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 2
82574: NEG
82575: PUSH
82576: LD_INT 0
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 2
82585: NEG
82586: PUSH
82587: LD_INT 1
82589: NEG
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 2
82597: NEG
82598: PUSH
82599: LD_INT 2
82601: NEG
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 1
82609: NEG
82610: PUSH
82611: LD_INT 2
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 2
82620: NEG
82621: PUSH
82622: LD_INT 1
82624: PUSH
82625: EMPTY
82626: LIST
82627: LIST
82628: PUSH
82629: LD_INT 3
82631: NEG
82632: PUSH
82633: LD_INT 1
82635: NEG
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: PUSH
82641: LD_INT 3
82643: NEG
82644: PUSH
82645: LD_INT 2
82647: NEG
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82678: LD_ADDR_VAR 0 28
82682: PUSH
82683: LD_INT 0
82685: PUSH
82686: LD_INT 0
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 0
82695: PUSH
82696: LD_INT 1
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 1
82706: PUSH
82707: LD_INT 0
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: PUSH
82717: LD_INT 1
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PUSH
82724: LD_INT 0
82726: PUSH
82727: LD_INT 1
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 1
82736: NEG
82737: PUSH
82738: LD_INT 0
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 1
82747: NEG
82748: PUSH
82749: LD_INT 1
82751: NEG
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: LD_INT 1
82759: NEG
82760: PUSH
82761: LD_INT 2
82763: NEG
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 0
82771: PUSH
82772: LD_INT 2
82774: NEG
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 1
82782: PUSH
82783: LD_INT 1
82785: NEG
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 2
82793: PUSH
82794: LD_INT 0
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 2
82803: PUSH
82804: LD_INT 1
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 2
82813: PUSH
82814: LD_INT 2
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: PUSH
82824: LD_INT 2
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: LD_INT 0
82833: PUSH
82834: LD_INT 2
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PUSH
82841: LD_INT 1
82843: NEG
82844: PUSH
82845: LD_INT 1
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 2
82854: NEG
82855: PUSH
82856: LD_INT 0
82858: PUSH
82859: EMPTY
82860: LIST
82861: LIST
82862: PUSH
82863: LD_INT 2
82865: NEG
82866: PUSH
82867: LD_INT 1
82869: NEG
82870: PUSH
82871: EMPTY
82872: LIST
82873: LIST
82874: PUSH
82875: LD_INT 2
82877: NEG
82878: PUSH
82879: LD_INT 2
82881: NEG
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 2
82889: NEG
82890: PUSH
82891: LD_INT 3
82893: NEG
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 1
82901: NEG
82902: PUSH
82903: LD_INT 3
82905: NEG
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 3
82913: NEG
82914: PUSH
82915: LD_INT 1
82917: NEG
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 3
82925: NEG
82926: PUSH
82927: LD_INT 2
82929: NEG
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: LIST
82939: LIST
82940: LIST
82941: LIST
82942: LIST
82943: LIST
82944: LIST
82945: LIST
82946: LIST
82947: LIST
82948: LIST
82949: LIST
82950: LIST
82951: LIST
82952: LIST
82953: LIST
82954: LIST
82955: LIST
82956: LIST
82957: LIST
82958: LIST
82959: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82960: LD_ADDR_VAR 0 29
82964: PUSH
82965: LD_INT 0
82967: PUSH
82968: LD_INT 0
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 0
82977: PUSH
82978: LD_INT 1
82980: NEG
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 1
82988: PUSH
82989: LD_INT 0
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 1
82998: PUSH
82999: LD_INT 1
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 0
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 1
83018: NEG
83019: PUSH
83020: LD_INT 0
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_INT 1
83029: NEG
83030: PUSH
83031: LD_INT 1
83033: NEG
83034: PUSH
83035: EMPTY
83036: LIST
83037: LIST
83038: PUSH
83039: LD_INT 1
83041: NEG
83042: PUSH
83043: LD_INT 2
83045: NEG
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 0
83053: PUSH
83054: LD_INT 2
83056: NEG
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 1
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 2
83075: PUSH
83076: LD_INT 0
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_INT 2
83085: PUSH
83086: LD_INT 1
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: PUSH
83093: LD_INT 1
83095: PUSH
83096: LD_INT 2
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 0
83105: PUSH
83106: LD_INT 2
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 1
83115: NEG
83116: PUSH
83117: LD_INT 1
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_INT 2
83126: NEG
83127: PUSH
83128: LD_INT 1
83130: NEG
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 2
83138: NEG
83139: PUSH
83140: LD_INT 2
83142: NEG
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 2
83150: NEG
83151: PUSH
83152: LD_INT 3
83154: NEG
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 2
83162: PUSH
83163: LD_INT 1
83165: NEG
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 3
83173: PUSH
83174: LD_INT 1
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: LD_INT 1
83183: PUSH
83184: LD_INT 3
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 1
83193: NEG
83194: PUSH
83195: LD_INT 2
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: LD_INT 3
83204: NEG
83205: PUSH
83206: LD_INT 2
83208: NEG
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83239: LD_ADDR_VAR 0 30
83243: PUSH
83244: LD_INT 0
83246: PUSH
83247: LD_INT 0
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PUSH
83254: LD_INT 0
83256: PUSH
83257: LD_INT 1
83259: NEG
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 1
83267: PUSH
83268: LD_INT 0
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: PUSH
83275: LD_INT 1
83277: PUSH
83278: LD_INT 1
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 0
83287: PUSH
83288: LD_INT 1
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 1
83297: NEG
83298: PUSH
83299: LD_INT 0
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 1
83308: NEG
83309: PUSH
83310: LD_INT 1
83312: NEG
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 1
83320: NEG
83321: PUSH
83322: LD_INT 2
83324: NEG
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: PUSH
83330: LD_INT 0
83332: PUSH
83333: LD_INT 2
83335: NEG
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 1
83343: PUSH
83344: LD_INT 1
83346: NEG
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 2
83354: PUSH
83355: LD_INT 0
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 2
83364: PUSH
83365: LD_INT 1
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 2
83374: PUSH
83375: LD_INT 2
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 1
83384: PUSH
83385: LD_INT 2
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 1
83394: NEG
83395: PUSH
83396: LD_INT 1
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 2
83405: NEG
83406: PUSH
83407: LD_INT 0
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 2
83416: NEG
83417: PUSH
83418: LD_INT 1
83420: NEG
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 1
83428: NEG
83429: PUSH
83430: LD_INT 3
83432: NEG
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: LD_INT 1
83440: PUSH
83441: LD_INT 2
83443: NEG
83444: PUSH
83445: EMPTY
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 3
83451: PUSH
83452: LD_INT 2
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 2
83461: PUSH
83462: LD_INT 3
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PUSH
83469: LD_INT 2
83471: NEG
83472: PUSH
83473: LD_INT 1
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: LD_INT 3
83482: NEG
83483: PUSH
83484: LD_INT 1
83486: NEG
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: LIST
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: LIST
83510: LIST
83511: LIST
83512: LIST
83513: LIST
83514: LIST
83515: LIST
83516: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83517: LD_ADDR_VAR 0 31
83521: PUSH
83522: LD_INT 0
83524: PUSH
83525: LD_INT 0
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 0
83534: PUSH
83535: LD_INT 1
83537: NEG
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 1
83545: PUSH
83546: LD_INT 0
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 1
83555: PUSH
83556: LD_INT 1
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 0
83565: PUSH
83566: LD_INT 1
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 1
83575: NEG
83576: PUSH
83577: LD_INT 0
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: PUSH
83584: LD_INT 1
83586: NEG
83587: PUSH
83588: LD_INT 1
83590: NEG
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PUSH
83596: LD_INT 1
83598: NEG
83599: PUSH
83600: LD_INT 2
83602: NEG
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 1
83610: PUSH
83611: LD_INT 1
83613: NEG
83614: PUSH
83615: EMPTY
83616: LIST
83617: LIST
83618: PUSH
83619: LD_INT 2
83621: PUSH
83622: LD_INT 0
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: LD_INT 2
83631: PUSH
83632: LD_INT 1
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 2
83641: PUSH
83642: LD_INT 2
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 1
83651: PUSH
83652: LD_INT 2
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 0
83661: PUSH
83662: LD_INT 2
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 1
83671: NEG
83672: PUSH
83673: LD_INT 1
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 2
83682: NEG
83683: PUSH
83684: LD_INT 1
83686: NEG
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 2
83694: NEG
83695: PUSH
83696: LD_INT 2
83698: NEG
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 2
83706: NEG
83707: PUSH
83708: LD_INT 3
83710: NEG
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PUSH
83716: LD_INT 2
83718: PUSH
83719: LD_INT 1
83721: NEG
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 3
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 1
83739: PUSH
83740: LD_INT 3
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 1
83749: NEG
83750: PUSH
83751: LD_INT 2
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: PUSH
83758: LD_INT 3
83760: NEG
83761: PUSH
83762: LD_INT 2
83764: NEG
83765: PUSH
83766: EMPTY
83767: LIST
83768: LIST
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83795: LD_ADDR_VAR 0 32
83799: PUSH
83800: LD_INT 0
83802: PUSH
83803: LD_INT 0
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 0
83812: PUSH
83813: LD_INT 1
83815: NEG
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PUSH
83821: LD_INT 1
83823: PUSH
83824: LD_INT 0
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: LD_INT 1
83833: PUSH
83834: LD_INT 1
83836: PUSH
83837: EMPTY
83838: LIST
83839: LIST
83840: PUSH
83841: LD_INT 0
83843: PUSH
83844: LD_INT 1
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: LD_INT 1
83853: NEG
83854: PUSH
83855: LD_INT 0
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 1
83864: NEG
83865: PUSH
83866: LD_INT 1
83868: NEG
83869: PUSH
83870: EMPTY
83871: LIST
83872: LIST
83873: PUSH
83874: LD_INT 1
83876: NEG
83877: PUSH
83878: LD_INT 2
83880: NEG
83881: PUSH
83882: EMPTY
83883: LIST
83884: LIST
83885: PUSH
83886: LD_INT 0
83888: PUSH
83889: LD_INT 2
83891: NEG
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: PUSH
83897: LD_INT 1
83899: PUSH
83900: LD_INT 1
83902: NEG
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: PUSH
83908: LD_INT 2
83910: PUSH
83911: LD_INT 1
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 2
83920: PUSH
83921: LD_INT 2
83923: PUSH
83924: EMPTY
83925: LIST
83926: LIST
83927: PUSH
83928: LD_INT 1
83930: PUSH
83931: LD_INT 2
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 0
83940: PUSH
83941: LD_INT 2
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: PUSH
83948: LD_INT 1
83950: NEG
83951: PUSH
83952: LD_INT 1
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: LD_INT 2
83961: NEG
83962: PUSH
83963: LD_INT 0
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 2
83972: NEG
83973: PUSH
83974: LD_INT 1
83976: NEG
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 1
83984: NEG
83985: PUSH
83986: LD_INT 3
83988: NEG
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 1
83996: PUSH
83997: LD_INT 2
83999: NEG
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 3
84007: PUSH
84008: LD_INT 2
84010: PUSH
84011: EMPTY
84012: LIST
84013: LIST
84014: PUSH
84015: LD_INT 2
84017: PUSH
84018: LD_INT 3
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: PUSH
84025: LD_INT 2
84027: NEG
84028: PUSH
84029: LD_INT 1
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: PUSH
84036: LD_INT 3
84038: NEG
84039: PUSH
84040: LD_INT 1
84042: NEG
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: LIST
84052: LIST
84053: LIST
84054: LIST
84055: LIST
84056: LIST
84057: LIST
84058: LIST
84059: LIST
84060: LIST
84061: LIST
84062: LIST
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84073: LD_ADDR_VAR 0 33
84077: PUSH
84078: LD_INT 0
84080: PUSH
84081: LD_INT 0
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: PUSH
84088: LD_INT 0
84090: PUSH
84091: LD_INT 1
84093: NEG
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 1
84101: PUSH
84102: LD_INT 0
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: PUSH
84109: LD_INT 1
84111: PUSH
84112: LD_INT 1
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 0
84121: PUSH
84122: LD_INT 1
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 1
84131: NEG
84132: PUSH
84133: LD_INT 0
84135: PUSH
84136: EMPTY
84137: LIST
84138: LIST
84139: PUSH
84140: LD_INT 1
84142: NEG
84143: PUSH
84144: LD_INT 1
84146: NEG
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 1
84154: NEG
84155: PUSH
84156: LD_INT 2
84158: NEG
84159: PUSH
84160: EMPTY
84161: LIST
84162: LIST
84163: PUSH
84164: LD_INT 1
84166: PUSH
84167: LD_INT 1
84169: NEG
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 2
84177: PUSH
84178: LD_INT 0
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: PUSH
84185: LD_INT 2
84187: PUSH
84188: LD_INT 1
84190: PUSH
84191: EMPTY
84192: LIST
84193: LIST
84194: PUSH
84195: LD_INT 1
84197: PUSH
84198: LD_INT 2
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 0
84207: PUSH
84208: LD_INT 2
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 1
84217: NEG
84218: PUSH
84219: LD_INT 1
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: PUSH
84226: LD_INT 2
84228: NEG
84229: PUSH
84230: LD_INT 0
84232: PUSH
84233: EMPTY
84234: LIST
84235: LIST
84236: PUSH
84237: LD_INT 2
84239: NEG
84240: PUSH
84241: LD_INT 1
84243: NEG
84244: PUSH
84245: EMPTY
84246: LIST
84247: LIST
84248: PUSH
84249: LD_INT 2
84251: NEG
84252: PUSH
84253: LD_INT 2
84255: NEG
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: LD_INT 2
84263: NEG
84264: PUSH
84265: LD_INT 3
84267: NEG
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 2
84275: PUSH
84276: LD_INT 1
84278: NEG
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: PUSH
84284: LD_INT 3
84286: PUSH
84287: LD_INT 1
84289: PUSH
84290: EMPTY
84291: LIST
84292: LIST
84293: PUSH
84294: LD_INT 1
84296: PUSH
84297: LD_INT 3
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PUSH
84304: LD_INT 1
84306: NEG
84307: PUSH
84308: LD_INT 2
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 3
84317: NEG
84318: PUSH
84319: LD_INT 2
84321: NEG
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: LIST
84347: LIST
84348: LIST
84349: LIST
84350: LIST
84351: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84352: LD_ADDR_VAR 0 34
84356: PUSH
84357: LD_INT 0
84359: PUSH
84360: LD_INT 0
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 0
84369: PUSH
84370: LD_INT 1
84372: NEG
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: PUSH
84378: LD_INT 1
84380: PUSH
84381: LD_INT 0
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: PUSH
84388: LD_INT 1
84390: PUSH
84391: LD_INT 1
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 0
84400: PUSH
84401: LD_INT 1
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 1
84410: NEG
84411: PUSH
84412: LD_INT 0
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 1
84421: NEG
84422: PUSH
84423: LD_INT 1
84425: NEG
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: LD_INT 1
84433: NEG
84434: PUSH
84435: LD_INT 2
84437: NEG
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: PUSH
84443: LD_INT 0
84445: PUSH
84446: LD_INT 2
84448: NEG
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 1
84456: PUSH
84457: LD_INT 1
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 2
84467: PUSH
84468: LD_INT 1
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 2
84477: PUSH
84478: LD_INT 2
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: LD_INT 2
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: PUSH
84495: LD_INT 1
84497: NEG
84498: PUSH
84499: LD_INT 1
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: PUSH
84506: LD_INT 2
84508: NEG
84509: PUSH
84510: LD_INT 0
84512: PUSH
84513: EMPTY
84514: LIST
84515: LIST
84516: PUSH
84517: LD_INT 2
84519: NEG
84520: PUSH
84521: LD_INT 1
84523: NEG
84524: PUSH
84525: EMPTY
84526: LIST
84527: LIST
84528: PUSH
84529: LD_INT 2
84531: NEG
84532: PUSH
84533: LD_INT 2
84535: NEG
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: PUSH
84541: LD_INT 1
84543: NEG
84544: PUSH
84545: LD_INT 3
84547: NEG
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 1
84555: PUSH
84556: LD_INT 2
84558: NEG
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: LD_INT 3
84566: PUSH
84567: LD_INT 2
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 2
84576: PUSH
84577: LD_INT 3
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: PUSH
84584: LD_INT 2
84586: NEG
84587: PUSH
84588: LD_INT 1
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 3
84597: NEG
84598: PUSH
84599: LD_INT 1
84601: NEG
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: EMPTY
84608: LIST
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: LIST
84626: LIST
84627: LIST
84628: LIST
84629: LIST
84630: LIST
84631: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84632: LD_ADDR_VAR 0 35
84636: PUSH
84637: LD_INT 0
84639: PUSH
84640: LD_INT 0
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 0
84649: PUSH
84650: LD_INT 1
84652: NEG
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: LD_INT 1
84660: PUSH
84661: LD_INT 0
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 1
84670: PUSH
84671: LD_INT 1
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 0
84680: PUSH
84681: LD_INT 1
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: PUSH
84688: LD_INT 1
84690: NEG
84691: PUSH
84692: LD_INT 0
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 1
84701: NEG
84702: PUSH
84703: LD_INT 1
84705: NEG
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: PUSH
84711: LD_INT 2
84713: PUSH
84714: LD_INT 1
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 2
84723: NEG
84724: PUSH
84725: LD_INT 1
84727: NEG
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84744: LD_ADDR_VAR 0 36
84748: PUSH
84749: LD_INT 0
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: EMPTY
84756: LIST
84757: LIST
84758: PUSH
84759: LD_INT 0
84761: PUSH
84762: LD_INT 1
84764: NEG
84765: PUSH
84766: EMPTY
84767: LIST
84768: LIST
84769: PUSH
84770: LD_INT 1
84772: PUSH
84773: LD_INT 0
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: LD_INT 1
84782: PUSH
84783: LD_INT 1
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: PUSH
84790: LD_INT 0
84792: PUSH
84793: LD_INT 1
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 1
84802: NEG
84803: PUSH
84804: LD_INT 0
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 1
84813: NEG
84814: PUSH
84815: LD_INT 1
84817: NEG
84818: PUSH
84819: EMPTY
84820: LIST
84821: LIST
84822: PUSH
84823: LD_INT 1
84825: NEG
84826: PUSH
84827: LD_INT 2
84829: NEG
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 1
84837: PUSH
84838: LD_INT 2
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84856: LD_ADDR_VAR 0 37
84860: PUSH
84861: LD_INT 0
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 0
84873: PUSH
84874: LD_INT 1
84876: NEG
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PUSH
84882: LD_INT 1
84884: PUSH
84885: LD_INT 0
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 1
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: LD_INT 0
84904: PUSH
84905: LD_INT 1
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: PUSH
84912: LD_INT 1
84914: NEG
84915: PUSH
84916: LD_INT 0
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: PUSH
84923: LD_INT 1
84925: NEG
84926: PUSH
84927: LD_INT 1
84929: NEG
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: LD_INT 1
84937: PUSH
84938: LD_INT 1
84940: NEG
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 1
84948: NEG
84949: PUSH
84950: LD_INT 1
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84968: LD_ADDR_VAR 0 38
84972: PUSH
84973: LD_INT 0
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 0
84985: PUSH
84986: LD_INT 1
84988: NEG
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: PUSH
84994: LD_INT 1
84996: PUSH
84997: LD_INT 0
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: PUSH
85004: LD_INT 1
85006: PUSH
85007: LD_INT 1
85009: PUSH
85010: EMPTY
85011: LIST
85012: LIST
85013: PUSH
85014: LD_INT 0
85016: PUSH
85017: LD_INT 1
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: LD_INT 1
85026: NEG
85027: PUSH
85028: LD_INT 0
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 1
85037: NEG
85038: PUSH
85039: LD_INT 1
85041: NEG
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 2
85049: PUSH
85050: LD_INT 1
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 2
85059: NEG
85060: PUSH
85061: LD_INT 1
85063: NEG
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: EMPTY
85070: LIST
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85080: LD_ADDR_VAR 0 39
85084: PUSH
85085: LD_INT 0
85087: PUSH
85088: LD_INT 0
85090: PUSH
85091: EMPTY
85092: LIST
85093: LIST
85094: PUSH
85095: LD_INT 0
85097: PUSH
85098: LD_INT 1
85100: NEG
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 1
85108: PUSH
85109: LD_INT 0
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 1
85118: PUSH
85119: LD_INT 1
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: PUSH
85126: LD_INT 0
85128: PUSH
85129: LD_INT 1
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 1
85138: NEG
85139: PUSH
85140: LD_INT 0
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: NEG
85150: PUSH
85151: LD_INT 1
85153: NEG
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 1
85161: NEG
85162: PUSH
85163: LD_INT 2
85165: NEG
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 1
85173: PUSH
85174: LD_INT 2
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: LIST
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85192: LD_ADDR_VAR 0 40
85196: PUSH
85197: LD_INT 0
85199: PUSH
85200: LD_INT 0
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PUSH
85207: LD_INT 0
85209: PUSH
85210: LD_INT 1
85212: NEG
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: PUSH
85218: LD_INT 1
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 1
85230: PUSH
85231: LD_INT 1
85233: PUSH
85234: EMPTY
85235: LIST
85236: LIST
85237: PUSH
85238: LD_INT 0
85240: PUSH
85241: LD_INT 1
85243: PUSH
85244: EMPTY
85245: LIST
85246: LIST
85247: PUSH
85248: LD_INT 1
85250: NEG
85251: PUSH
85252: LD_INT 0
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 1
85261: NEG
85262: PUSH
85263: LD_INT 1
85265: NEG
85266: PUSH
85267: EMPTY
85268: LIST
85269: LIST
85270: PUSH
85271: LD_INT 1
85273: PUSH
85274: LD_INT 1
85276: NEG
85277: PUSH
85278: EMPTY
85279: LIST
85280: LIST
85281: PUSH
85282: LD_INT 1
85284: NEG
85285: PUSH
85286: LD_INT 1
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85304: LD_ADDR_VAR 0 41
85308: PUSH
85309: LD_INT 0
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 0
85321: PUSH
85322: LD_INT 1
85324: NEG
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 1
85332: PUSH
85333: LD_INT 0
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 1
85342: PUSH
85343: LD_INT 1
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 0
85352: PUSH
85353: LD_INT 1
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 1
85362: NEG
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 1
85373: NEG
85374: PUSH
85375: LD_INT 1
85377: NEG
85378: PUSH
85379: EMPTY
85380: LIST
85381: LIST
85382: PUSH
85383: LD_INT 1
85385: NEG
85386: PUSH
85387: LD_INT 2
85389: NEG
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: PUSH
85395: LD_INT 1
85397: PUSH
85398: LD_INT 1
85400: NEG
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: PUSH
85406: LD_INT 2
85408: PUSH
85409: LD_INT 0
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 2
85418: PUSH
85419: LD_INT 1
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: PUSH
85426: LD_INT 2
85428: PUSH
85429: LD_INT 2
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PUSH
85436: LD_INT 1
85438: PUSH
85439: LD_INT 2
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: PUSH
85446: LD_INT 1
85448: NEG
85449: PUSH
85450: LD_INT 1
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 2
85459: NEG
85460: PUSH
85461: LD_INT 0
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: PUSH
85468: LD_INT 2
85470: NEG
85471: PUSH
85472: LD_INT 1
85474: NEG
85475: PUSH
85476: EMPTY
85477: LIST
85478: LIST
85479: PUSH
85480: LD_INT 2
85482: NEG
85483: PUSH
85484: LD_INT 2
85486: NEG
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: PUSH
85492: LD_INT 2
85494: NEG
85495: PUSH
85496: LD_INT 3
85498: NEG
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: PUSH
85504: LD_INT 2
85506: PUSH
85507: LD_INT 1
85509: NEG
85510: PUSH
85511: EMPTY
85512: LIST
85513: LIST
85514: PUSH
85515: LD_INT 3
85517: PUSH
85518: LD_INT 0
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 3
85527: PUSH
85528: LD_INT 1
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: PUSH
85535: LD_INT 3
85537: PUSH
85538: LD_INT 2
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: PUSH
85545: LD_INT 3
85547: PUSH
85548: LD_INT 3
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PUSH
85555: LD_INT 2
85557: PUSH
85558: LD_INT 3
85560: PUSH
85561: EMPTY
85562: LIST
85563: LIST
85564: PUSH
85565: LD_INT 2
85567: NEG
85568: PUSH
85569: LD_INT 1
85571: PUSH
85572: EMPTY
85573: LIST
85574: LIST
85575: PUSH
85576: LD_INT 3
85578: NEG
85579: PUSH
85580: LD_INT 0
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 3
85589: NEG
85590: PUSH
85591: LD_INT 1
85593: NEG
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 3
85601: NEG
85602: PUSH
85603: LD_INT 2
85605: NEG
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: PUSH
85611: LD_INT 3
85613: NEG
85614: PUSH
85615: LD_INT 3
85617: NEG
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: LIST
85652: LIST
85653: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85654: LD_ADDR_VAR 0 42
85658: PUSH
85659: LD_INT 0
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: PUSH
85669: LD_INT 0
85671: PUSH
85672: LD_INT 1
85674: NEG
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: PUSH
85680: LD_INT 1
85682: PUSH
85683: LD_INT 0
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 1
85692: PUSH
85693: LD_INT 1
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 0
85702: PUSH
85703: LD_INT 1
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 1
85712: NEG
85713: PUSH
85714: LD_INT 0
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 1
85723: NEG
85724: PUSH
85725: LD_INT 1
85727: NEG
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 1
85735: NEG
85736: PUSH
85737: LD_INT 2
85739: NEG
85740: PUSH
85741: EMPTY
85742: LIST
85743: LIST
85744: PUSH
85745: LD_INT 0
85747: PUSH
85748: LD_INT 2
85750: NEG
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 1
85758: PUSH
85759: LD_INT 1
85761: NEG
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 2
85769: PUSH
85770: LD_INT 1
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: PUSH
85777: LD_INT 2
85779: PUSH
85780: LD_INT 2
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: PUSH
85787: LD_INT 1
85789: PUSH
85790: LD_INT 2
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 0
85799: PUSH
85800: LD_INT 2
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PUSH
85807: LD_INT 1
85809: NEG
85810: PUSH
85811: LD_INT 1
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: PUSH
85818: LD_INT 2
85820: NEG
85821: PUSH
85822: LD_INT 1
85824: NEG
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 2
85832: NEG
85833: PUSH
85834: LD_INT 2
85836: NEG
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 2
85844: NEG
85845: PUSH
85846: LD_INT 3
85848: NEG
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 1
85856: NEG
85857: PUSH
85858: LD_INT 3
85860: NEG
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: PUSH
85866: LD_INT 0
85868: PUSH
85869: LD_INT 3
85871: NEG
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 1
85879: PUSH
85880: LD_INT 2
85882: NEG
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 3
85890: PUSH
85891: LD_INT 2
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 3
85900: PUSH
85901: LD_INT 3
85903: PUSH
85904: EMPTY
85905: LIST
85906: LIST
85907: PUSH
85908: LD_INT 2
85910: PUSH
85911: LD_INT 3
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 1
85920: PUSH
85921: LD_INT 3
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 0
85930: PUSH
85931: LD_INT 3
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 1
85940: NEG
85941: PUSH
85942: LD_INT 2
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PUSH
85949: LD_INT 3
85951: NEG
85952: PUSH
85953: LD_INT 2
85955: NEG
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 3
85963: NEG
85964: PUSH
85965: LD_INT 3
85967: NEG
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: LIST
85999: LIST
86000: LIST
86001: LIST
86002: LIST
86003: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86004: LD_ADDR_VAR 0 43
86008: PUSH
86009: LD_INT 0
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 0
86021: PUSH
86022: LD_INT 1
86024: NEG
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 1
86032: PUSH
86033: LD_INT 0
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 1
86042: PUSH
86043: LD_INT 1
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 0
86052: PUSH
86053: LD_INT 1
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 1
86062: NEG
86063: PUSH
86064: LD_INT 0
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: LD_INT 1
86073: NEG
86074: PUSH
86075: LD_INT 1
86077: NEG
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 1
86085: NEG
86086: PUSH
86087: LD_INT 2
86089: NEG
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: LD_INT 2
86100: NEG
86101: PUSH
86102: EMPTY
86103: LIST
86104: LIST
86105: PUSH
86106: LD_INT 1
86108: PUSH
86109: LD_INT 1
86111: NEG
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 2
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 2
86129: PUSH
86130: LD_INT 1
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 1
86139: PUSH
86140: LD_INT 2
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: LD_INT 2
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 1
86159: NEG
86160: PUSH
86161: LD_INT 1
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 2
86170: NEG
86171: PUSH
86172: LD_INT 0
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 2
86181: NEG
86182: PUSH
86183: LD_INT 1
86185: NEG
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: LD_INT 1
86193: NEG
86194: PUSH
86195: LD_INT 3
86197: NEG
86198: PUSH
86199: EMPTY
86200: LIST
86201: LIST
86202: PUSH
86203: LD_INT 0
86205: PUSH
86206: LD_INT 3
86208: NEG
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: LD_INT 2
86219: NEG
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 2
86227: PUSH
86228: LD_INT 1
86230: NEG
86231: PUSH
86232: EMPTY
86233: LIST
86234: LIST
86235: PUSH
86236: LD_INT 3
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: PUSH
86246: LD_INT 3
86248: PUSH
86249: LD_INT 1
86251: PUSH
86252: EMPTY
86253: LIST
86254: LIST
86255: PUSH
86256: LD_INT 1
86258: PUSH
86259: LD_INT 3
86261: PUSH
86262: EMPTY
86263: LIST
86264: LIST
86265: PUSH
86266: LD_INT 0
86268: PUSH
86269: LD_INT 3
86271: PUSH
86272: EMPTY
86273: LIST
86274: LIST
86275: PUSH
86276: LD_INT 1
86278: NEG
86279: PUSH
86280: LD_INT 2
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 2
86289: NEG
86290: PUSH
86291: LD_INT 1
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 3
86300: NEG
86301: PUSH
86302: LD_INT 0
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 3
86311: NEG
86312: PUSH
86313: LD_INT 1
86315: NEG
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: EMPTY
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: LIST
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: LIST
86351: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86352: LD_ADDR_VAR 0 44
86356: PUSH
86357: LD_INT 0
86359: PUSH
86360: LD_INT 0
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 0
86369: PUSH
86370: LD_INT 1
86372: NEG
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: PUSH
86378: LD_INT 1
86380: PUSH
86381: LD_INT 0
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: PUSH
86388: LD_INT 1
86390: PUSH
86391: LD_INT 1
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 0
86400: PUSH
86401: LD_INT 1
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 1
86410: NEG
86411: PUSH
86412: LD_INT 0
86414: PUSH
86415: EMPTY
86416: LIST
86417: LIST
86418: PUSH
86419: LD_INT 1
86421: NEG
86422: PUSH
86423: LD_INT 1
86425: NEG
86426: PUSH
86427: EMPTY
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 1
86433: NEG
86434: PUSH
86435: LD_INT 2
86437: NEG
86438: PUSH
86439: EMPTY
86440: LIST
86441: LIST
86442: PUSH
86443: LD_INT 1
86445: PUSH
86446: LD_INT 1
86448: NEG
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: PUSH
86454: LD_INT 2
86456: PUSH
86457: LD_INT 0
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 2
86466: PUSH
86467: LD_INT 1
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: PUSH
86474: LD_INT 2
86476: PUSH
86477: LD_INT 2
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 1
86486: PUSH
86487: LD_INT 2
86489: PUSH
86490: EMPTY
86491: LIST
86492: LIST
86493: PUSH
86494: LD_INT 1
86496: NEG
86497: PUSH
86498: LD_INT 1
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PUSH
86505: LD_INT 2
86507: NEG
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PUSH
86516: LD_INT 2
86518: NEG
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 2
86530: NEG
86531: PUSH
86532: LD_INT 2
86534: NEG
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 2
86542: NEG
86543: PUSH
86544: LD_INT 3
86546: NEG
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: PUSH
86552: LD_INT 2
86554: PUSH
86555: LD_INT 1
86557: NEG
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: LD_INT 3
86565: PUSH
86566: LD_INT 0
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 3
86575: PUSH
86576: LD_INT 1
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: PUSH
86583: LD_INT 3
86585: PUSH
86586: LD_INT 2
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 3
86595: PUSH
86596: LD_INT 3
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: PUSH
86603: LD_INT 2
86605: PUSH
86606: LD_INT 3
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 2
86615: NEG
86616: PUSH
86617: LD_INT 1
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 3
86626: NEG
86627: PUSH
86628: LD_INT 0
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 3
86637: NEG
86638: PUSH
86639: LD_INT 1
86641: NEG
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 3
86649: NEG
86650: PUSH
86651: LD_INT 2
86653: NEG
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 3
86661: NEG
86662: PUSH
86663: LD_INT 3
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86702: LD_ADDR_VAR 0 45
86706: PUSH
86707: LD_INT 0
86709: PUSH
86710: LD_INT 0
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: PUSH
86717: LD_INT 0
86719: PUSH
86720: LD_INT 1
86722: NEG
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 1
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: LD_INT 1
86740: PUSH
86741: LD_INT 1
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PUSH
86748: LD_INT 0
86750: PUSH
86751: LD_INT 1
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 1
86760: NEG
86761: PUSH
86762: LD_INT 0
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 1
86771: NEG
86772: PUSH
86773: LD_INT 1
86775: NEG
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: NEG
86784: PUSH
86785: LD_INT 2
86787: NEG
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 0
86795: PUSH
86796: LD_INT 2
86798: NEG
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 1
86806: PUSH
86807: LD_INT 1
86809: NEG
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 2
86817: PUSH
86818: LD_INT 1
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 2
86827: PUSH
86828: LD_INT 2
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 1
86837: PUSH
86838: LD_INT 2
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 0
86847: PUSH
86848: LD_INT 2
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_INT 1
86857: NEG
86858: PUSH
86859: LD_INT 1
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 2
86868: NEG
86869: PUSH
86870: LD_INT 1
86872: NEG
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 2
86880: NEG
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 2
86892: NEG
86893: PUSH
86894: LD_INT 3
86896: NEG
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 1
86904: NEG
86905: PUSH
86906: LD_INT 3
86908: NEG
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 0
86916: PUSH
86917: LD_INT 3
86919: NEG
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PUSH
86925: LD_INT 1
86927: PUSH
86928: LD_INT 2
86930: NEG
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: PUSH
86936: LD_INT 3
86938: PUSH
86939: LD_INT 2
86941: PUSH
86942: EMPTY
86943: LIST
86944: LIST
86945: PUSH
86946: LD_INT 3
86948: PUSH
86949: LD_INT 3
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_INT 2
86958: PUSH
86959: LD_INT 3
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 1
86968: PUSH
86969: LD_INT 3
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 0
86978: PUSH
86979: LD_INT 3
86981: PUSH
86982: EMPTY
86983: LIST
86984: LIST
86985: PUSH
86986: LD_INT 1
86988: NEG
86989: PUSH
86990: LD_INT 2
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 3
86999: NEG
87000: PUSH
87001: LD_INT 2
87003: NEG
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 3
87011: NEG
87012: PUSH
87013: LD_INT 3
87015: NEG
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87052: LD_ADDR_VAR 0 46
87056: PUSH
87057: LD_INT 0
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 0
87069: PUSH
87070: LD_INT 1
87072: NEG
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 1
87080: PUSH
87081: LD_INT 0
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 1
87090: PUSH
87091: LD_INT 1
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 0
87100: PUSH
87101: LD_INT 1
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 1
87110: NEG
87111: PUSH
87112: LD_INT 0
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: LD_INT 1
87121: NEG
87122: PUSH
87123: LD_INT 1
87125: NEG
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 1
87133: NEG
87134: PUSH
87135: LD_INT 2
87137: NEG
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 0
87145: PUSH
87146: LD_INT 2
87148: NEG
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 1
87156: PUSH
87157: LD_INT 1
87159: NEG
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 2
87167: PUSH
87168: LD_INT 0
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 2
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 1
87187: PUSH
87188: LD_INT 2
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 0
87197: PUSH
87198: LD_INT 2
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 1
87207: NEG
87208: PUSH
87209: LD_INT 1
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 2
87218: NEG
87219: PUSH
87220: LD_INT 0
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: PUSH
87227: LD_INT 2
87229: NEG
87230: PUSH
87231: LD_INT 1
87233: NEG
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: PUSH
87239: LD_INT 1
87241: NEG
87242: PUSH
87243: LD_INT 3
87245: NEG
87246: PUSH
87247: EMPTY
87248: LIST
87249: LIST
87250: PUSH
87251: LD_INT 0
87253: PUSH
87254: LD_INT 3
87256: NEG
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 1
87264: PUSH
87265: LD_INT 2
87267: NEG
87268: PUSH
87269: EMPTY
87270: LIST
87271: LIST
87272: PUSH
87273: LD_INT 2
87275: PUSH
87276: LD_INT 1
87278: NEG
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 3
87286: PUSH
87287: LD_INT 0
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 3
87296: PUSH
87297: LD_INT 1
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: PUSH
87307: LD_INT 3
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: LD_INT 0
87316: PUSH
87317: LD_INT 3
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 1
87326: NEG
87327: PUSH
87328: LD_INT 2
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: PUSH
87335: LD_INT 2
87337: NEG
87338: PUSH
87339: LD_INT 1
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: PUSH
87346: LD_INT 3
87348: NEG
87349: PUSH
87350: LD_INT 0
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 3
87359: NEG
87360: PUSH
87361: LD_INT 1
87363: NEG
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: LIST
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87400: LD_ADDR_VAR 0 47
87404: PUSH
87405: LD_INT 0
87407: PUSH
87408: LD_INT 0
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 0
87417: PUSH
87418: LD_INT 1
87420: NEG
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 1
87428: PUSH
87429: LD_INT 0
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: PUSH
87436: LD_INT 1
87438: PUSH
87439: LD_INT 1
87441: PUSH
87442: EMPTY
87443: LIST
87444: LIST
87445: PUSH
87446: LD_INT 0
87448: PUSH
87449: LD_INT 1
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 1
87458: NEG
87459: PUSH
87460: LD_INT 0
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 1
87469: NEG
87470: PUSH
87471: LD_INT 1
87473: NEG
87474: PUSH
87475: EMPTY
87476: LIST
87477: LIST
87478: PUSH
87479: LD_INT 1
87481: NEG
87482: PUSH
87483: LD_INT 2
87485: NEG
87486: PUSH
87487: EMPTY
87488: LIST
87489: LIST
87490: PUSH
87491: LD_INT 0
87493: PUSH
87494: LD_INT 2
87496: NEG
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: LD_INT 1
87507: NEG
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 2
87515: NEG
87516: PUSH
87517: LD_INT 1
87519: NEG
87520: PUSH
87521: EMPTY
87522: LIST
87523: LIST
87524: PUSH
87525: LD_INT 2
87527: NEG
87528: PUSH
87529: LD_INT 2
87531: NEG
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: EMPTY
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87551: LD_ADDR_VAR 0 48
87555: PUSH
87556: LD_INT 0
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PUSH
87566: LD_INT 0
87568: PUSH
87569: LD_INT 1
87571: NEG
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 1
87579: PUSH
87580: LD_INT 0
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: LD_INT 1
87589: PUSH
87590: LD_INT 1
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: LD_INT 0
87599: PUSH
87600: LD_INT 1
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 1
87609: NEG
87610: PUSH
87611: LD_INT 0
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: PUSH
87618: LD_INT 1
87620: NEG
87621: PUSH
87622: LD_INT 1
87624: NEG
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: PUSH
87630: LD_INT 1
87632: NEG
87633: PUSH
87634: LD_INT 2
87636: NEG
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 0
87644: PUSH
87645: LD_INT 2
87647: NEG
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 1
87655: PUSH
87656: LD_INT 1
87658: NEG
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 2
87666: PUSH
87667: LD_INT 0
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 2
87676: PUSH
87677: LD_INT 1
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: EMPTY
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87698: LD_ADDR_VAR 0 49
87702: PUSH
87703: LD_INT 0
87705: PUSH
87706: LD_INT 0
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: PUSH
87713: LD_INT 0
87715: PUSH
87716: LD_INT 1
87718: NEG
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 1
87726: PUSH
87727: LD_INT 0
87729: PUSH
87730: EMPTY
87731: LIST
87732: LIST
87733: PUSH
87734: LD_INT 1
87736: PUSH
87737: LD_INT 1
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: LD_INT 0
87746: PUSH
87747: LD_INT 1
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: PUSH
87754: LD_INT 1
87756: NEG
87757: PUSH
87758: LD_INT 0
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: PUSH
87765: LD_INT 1
87767: NEG
87768: PUSH
87769: LD_INT 1
87771: NEG
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: PUSH
87777: LD_INT 1
87779: PUSH
87780: LD_INT 1
87782: NEG
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: PUSH
87788: LD_INT 2
87790: PUSH
87791: LD_INT 0
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: PUSH
87798: LD_INT 2
87800: PUSH
87801: LD_INT 1
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: LD_INT 2
87810: PUSH
87811: LD_INT 2
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: PUSH
87818: LD_INT 1
87820: PUSH
87821: LD_INT 2
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87842: LD_ADDR_VAR 0 50
87846: PUSH
87847: LD_INT 0
87849: PUSH
87850: LD_INT 0
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 0
87859: PUSH
87860: LD_INT 1
87862: NEG
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: PUSH
87868: LD_INT 1
87870: PUSH
87871: LD_INT 0
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: LD_INT 1
87880: PUSH
87881: LD_INT 1
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 0
87890: PUSH
87891: LD_INT 1
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 1
87900: NEG
87901: PUSH
87902: LD_INT 0
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 1
87911: NEG
87912: PUSH
87913: LD_INT 1
87915: NEG
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: LD_INT 2
87923: PUSH
87924: LD_INT 1
87926: PUSH
87927: EMPTY
87928: LIST
87929: LIST
87930: PUSH
87931: LD_INT 2
87933: PUSH
87934: LD_INT 2
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 1
87943: PUSH
87944: LD_INT 2
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 0
87953: PUSH
87954: LD_INT 2
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 1
87963: NEG
87964: PUSH
87965: LD_INT 1
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87986: LD_ADDR_VAR 0 51
87990: PUSH
87991: LD_INT 0
87993: PUSH
87994: LD_INT 0
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: LD_INT 0
88003: PUSH
88004: LD_INT 1
88006: NEG
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 1
88014: PUSH
88015: LD_INT 0
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: PUSH
88022: LD_INT 1
88024: PUSH
88025: LD_INT 1
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 0
88034: PUSH
88035: LD_INT 1
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: LD_INT 1
88044: NEG
88045: PUSH
88046: LD_INT 0
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 1
88055: NEG
88056: PUSH
88057: LD_INT 1
88059: NEG
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 1
88067: PUSH
88068: LD_INT 2
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 0
88077: PUSH
88078: LD_INT 2
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 1
88087: NEG
88088: PUSH
88089: LD_INT 1
88091: PUSH
88092: EMPTY
88093: LIST
88094: LIST
88095: PUSH
88096: LD_INT 2
88098: NEG
88099: PUSH
88100: LD_INT 0
88102: PUSH
88103: EMPTY
88104: LIST
88105: LIST
88106: PUSH
88107: LD_INT 2
88109: NEG
88110: PUSH
88111: LD_INT 1
88113: NEG
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88133: LD_ADDR_VAR 0 52
88137: PUSH
88138: LD_INT 0
88140: PUSH
88141: LD_INT 0
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PUSH
88148: LD_INT 0
88150: PUSH
88151: LD_INT 1
88153: NEG
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 1
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 1
88171: PUSH
88172: LD_INT 1
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 0
88181: PUSH
88182: LD_INT 1
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: PUSH
88189: LD_INT 1
88191: NEG
88192: PUSH
88193: LD_INT 0
88195: PUSH
88196: EMPTY
88197: LIST
88198: LIST
88199: PUSH
88200: LD_INT 1
88202: NEG
88203: PUSH
88204: LD_INT 1
88206: NEG
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: PUSH
88212: LD_INT 1
88214: NEG
88215: PUSH
88216: LD_INT 2
88218: NEG
88219: PUSH
88220: EMPTY
88221: LIST
88222: LIST
88223: PUSH
88224: LD_INT 1
88226: NEG
88227: PUSH
88228: LD_INT 1
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: PUSH
88235: LD_INT 2
88237: NEG
88238: PUSH
88239: LD_INT 0
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: PUSH
88246: LD_INT 2
88248: NEG
88249: PUSH
88250: LD_INT 1
88252: NEG
88253: PUSH
88254: EMPTY
88255: LIST
88256: LIST
88257: PUSH
88258: LD_INT 2
88260: NEG
88261: PUSH
88262: LD_INT 2
88264: NEG
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: EMPTY
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88284: LD_ADDR_VAR 0 53
88288: PUSH
88289: LD_INT 0
88291: PUSH
88292: LD_INT 0
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: PUSH
88299: LD_INT 0
88301: PUSH
88302: LD_INT 1
88304: NEG
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: PUSH
88310: LD_INT 1
88312: PUSH
88313: LD_INT 0
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PUSH
88320: LD_INT 1
88322: PUSH
88323: LD_INT 1
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: PUSH
88330: LD_INT 0
88332: PUSH
88333: LD_INT 1
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: PUSH
88340: LD_INT 1
88342: NEG
88343: PUSH
88344: LD_INT 0
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 1
88353: NEG
88354: PUSH
88355: LD_INT 1
88357: NEG
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 1
88365: NEG
88366: PUSH
88367: LD_INT 2
88369: NEG
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 0
88377: PUSH
88378: LD_INT 2
88380: NEG
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 1
88388: PUSH
88389: LD_INT 1
88391: NEG
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: LD_INT 2
88399: PUSH
88400: LD_INT 0
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PUSH
88407: LD_INT 2
88409: PUSH
88410: LD_INT 1
88412: PUSH
88413: EMPTY
88414: LIST
88415: LIST
88416: PUSH
88417: LD_INT 2
88419: PUSH
88420: LD_INT 2
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: LD_INT 1
88429: PUSH
88430: LD_INT 2
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: PUSH
88437: LD_INT 0
88439: PUSH
88440: LD_INT 2
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: PUSH
88447: LD_INT 1
88449: NEG
88450: PUSH
88451: LD_INT 1
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PUSH
88458: LD_INT 2
88460: NEG
88461: PUSH
88462: LD_INT 0
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: PUSH
88469: LD_INT 2
88471: NEG
88472: PUSH
88473: LD_INT 1
88475: NEG
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 2
88483: NEG
88484: PUSH
88485: LD_INT 2
88487: NEG
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88514: LD_ADDR_VAR 0 54
88518: PUSH
88519: LD_INT 0
88521: PUSH
88522: LD_INT 0
88524: PUSH
88525: EMPTY
88526: LIST
88527: LIST
88528: PUSH
88529: LD_INT 0
88531: PUSH
88532: LD_INT 1
88534: NEG
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 1
88542: PUSH
88543: LD_INT 0
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 1
88552: PUSH
88553: LD_INT 1
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: LD_INT 0
88562: PUSH
88563: LD_INT 1
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 1
88572: NEG
88573: PUSH
88574: LD_INT 0
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 1
88583: NEG
88584: PUSH
88585: LD_INT 1
88587: NEG
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 1
88595: NEG
88596: PUSH
88597: LD_INT 2
88599: NEG
88600: PUSH
88601: EMPTY
88602: LIST
88603: LIST
88604: PUSH
88605: LD_INT 0
88607: PUSH
88608: LD_INT 2
88610: NEG
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 1
88618: PUSH
88619: LD_INT 1
88621: NEG
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 2
88629: PUSH
88630: LD_INT 0
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PUSH
88637: LD_INT 2
88639: PUSH
88640: LD_INT 1
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 2
88649: PUSH
88650: LD_INT 2
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: LD_INT 1
88659: PUSH
88660: LD_INT 2
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: PUSH
88667: LD_INT 0
88669: PUSH
88670: LD_INT 2
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 1
88679: NEG
88680: PUSH
88681: LD_INT 1
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 2
88690: NEG
88691: PUSH
88692: LD_INT 0
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 2
88701: NEG
88702: PUSH
88703: LD_INT 1
88705: NEG
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 2
88713: NEG
88714: PUSH
88715: LD_INT 2
88717: NEG
88718: PUSH
88719: EMPTY
88720: LIST
88721: LIST
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88744: LD_ADDR_VAR 0 55
88748: PUSH
88749: LD_INT 0
88751: PUSH
88752: LD_INT 0
88754: PUSH
88755: EMPTY
88756: LIST
88757: LIST
88758: PUSH
88759: LD_INT 0
88761: PUSH
88762: LD_INT 1
88764: NEG
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 1
88772: PUSH
88773: LD_INT 0
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 1
88782: PUSH
88783: LD_INT 1
88785: PUSH
88786: EMPTY
88787: LIST
88788: LIST
88789: PUSH
88790: LD_INT 0
88792: PUSH
88793: LD_INT 1
88795: PUSH
88796: EMPTY
88797: LIST
88798: LIST
88799: PUSH
88800: LD_INT 1
88802: NEG
88803: PUSH
88804: LD_INT 0
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: PUSH
88811: LD_INT 1
88813: NEG
88814: PUSH
88815: LD_INT 1
88817: NEG
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: PUSH
88823: LD_INT 1
88825: NEG
88826: PUSH
88827: LD_INT 2
88829: NEG
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 0
88837: PUSH
88838: LD_INT 2
88840: NEG
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PUSH
88846: LD_INT 1
88848: PUSH
88849: LD_INT 1
88851: NEG
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: LD_INT 2
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: LD_INT 2
88869: PUSH
88870: LD_INT 1
88872: PUSH
88873: EMPTY
88874: LIST
88875: LIST
88876: PUSH
88877: LD_INT 2
88879: PUSH
88880: LD_INT 2
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 1
88889: PUSH
88890: LD_INT 2
88892: PUSH
88893: EMPTY
88894: LIST
88895: LIST
88896: PUSH
88897: LD_INT 0
88899: PUSH
88900: LD_INT 2
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: PUSH
88907: LD_INT 1
88909: NEG
88910: PUSH
88911: LD_INT 1
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 2
88920: NEG
88921: PUSH
88922: LD_INT 0
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 2
88931: NEG
88932: PUSH
88933: LD_INT 1
88935: NEG
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: PUSH
88941: LD_INT 2
88943: NEG
88944: PUSH
88945: LD_INT 2
88947: NEG
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88974: LD_ADDR_VAR 0 56
88978: PUSH
88979: LD_INT 0
88981: PUSH
88982: LD_INT 0
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: LD_INT 0
88991: PUSH
88992: LD_INT 1
88994: NEG
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 1
89002: PUSH
89003: LD_INT 0
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 1
89012: PUSH
89013: LD_INT 1
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: PUSH
89020: LD_INT 0
89022: PUSH
89023: LD_INT 1
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 1
89032: NEG
89033: PUSH
89034: LD_INT 0
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 1
89043: NEG
89044: PUSH
89045: LD_INT 1
89047: NEG
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 1
89055: NEG
89056: PUSH
89057: LD_INT 2
89059: NEG
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: PUSH
89065: LD_INT 0
89067: PUSH
89068: LD_INT 2
89070: NEG
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: PUSH
89076: LD_INT 1
89078: PUSH
89079: LD_INT 1
89081: NEG
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 2
89089: PUSH
89090: LD_INT 0
89092: PUSH
89093: EMPTY
89094: LIST
89095: LIST
89096: PUSH
89097: LD_INT 2
89099: PUSH
89100: LD_INT 1
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: PUSH
89107: LD_INT 2
89109: PUSH
89110: LD_INT 2
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 1
89119: PUSH
89120: LD_INT 2
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 0
89129: PUSH
89130: LD_INT 2
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: PUSH
89137: LD_INT 1
89139: NEG
89140: PUSH
89141: LD_INT 1
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 2
89150: NEG
89151: PUSH
89152: LD_INT 0
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 2
89161: NEG
89162: PUSH
89163: LD_INT 1
89165: NEG
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 2
89173: NEG
89174: PUSH
89175: LD_INT 2
89177: NEG
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89204: LD_ADDR_VAR 0 57
89208: PUSH
89209: LD_INT 0
89211: PUSH
89212: LD_INT 0
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: LD_INT 0
89221: PUSH
89222: LD_INT 1
89224: NEG
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 1
89232: PUSH
89233: LD_INT 0
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 1
89242: PUSH
89243: LD_INT 1
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: LD_INT 0
89252: PUSH
89253: LD_INT 1
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: PUSH
89260: LD_INT 1
89262: NEG
89263: PUSH
89264: LD_INT 0
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 1
89273: NEG
89274: PUSH
89275: LD_INT 1
89277: NEG
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: PUSH
89283: LD_INT 1
89285: NEG
89286: PUSH
89287: LD_INT 2
89289: NEG
89290: PUSH
89291: EMPTY
89292: LIST
89293: LIST
89294: PUSH
89295: LD_INT 0
89297: PUSH
89298: LD_INT 2
89300: NEG
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: PUSH
89306: LD_INT 1
89308: PUSH
89309: LD_INT 1
89311: NEG
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: LD_INT 2
89319: PUSH
89320: LD_INT 0
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: PUSH
89327: LD_INT 2
89329: PUSH
89330: LD_INT 1
89332: PUSH
89333: EMPTY
89334: LIST
89335: LIST
89336: PUSH
89337: LD_INT 2
89339: PUSH
89340: LD_INT 2
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 1
89349: PUSH
89350: LD_INT 2
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: LD_INT 0
89359: PUSH
89360: LD_INT 2
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 1
89369: NEG
89370: PUSH
89371: LD_INT 1
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 2
89380: NEG
89381: PUSH
89382: LD_INT 0
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: LD_INT 2
89391: NEG
89392: PUSH
89393: LD_INT 1
89395: NEG
89396: PUSH
89397: EMPTY
89398: LIST
89399: LIST
89400: PUSH
89401: LD_INT 2
89403: NEG
89404: PUSH
89405: LD_INT 2
89407: NEG
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89434: LD_ADDR_VAR 0 58
89438: PUSH
89439: LD_INT 0
89441: PUSH
89442: LD_INT 0
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 0
89451: PUSH
89452: LD_INT 1
89454: NEG
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 1
89462: PUSH
89463: LD_INT 0
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: LD_INT 1
89472: PUSH
89473: LD_INT 1
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 0
89482: PUSH
89483: LD_INT 1
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 1
89492: NEG
89493: PUSH
89494: LD_INT 0
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: PUSH
89501: LD_INT 1
89503: NEG
89504: PUSH
89505: LD_INT 1
89507: NEG
89508: PUSH
89509: EMPTY
89510: LIST
89511: LIST
89512: PUSH
89513: LD_INT 1
89515: NEG
89516: PUSH
89517: LD_INT 2
89519: NEG
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: PUSH
89525: LD_INT 0
89527: PUSH
89528: LD_INT 2
89530: NEG
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: PUSH
89536: LD_INT 1
89538: PUSH
89539: LD_INT 1
89541: NEG
89542: PUSH
89543: EMPTY
89544: LIST
89545: LIST
89546: PUSH
89547: LD_INT 2
89549: PUSH
89550: LD_INT 0
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: PUSH
89557: LD_INT 2
89559: PUSH
89560: LD_INT 1
89562: PUSH
89563: EMPTY
89564: LIST
89565: LIST
89566: PUSH
89567: LD_INT 2
89569: PUSH
89570: LD_INT 2
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: PUSH
89577: LD_INT 1
89579: PUSH
89580: LD_INT 2
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: LD_INT 0
89589: PUSH
89590: LD_INT 2
89592: PUSH
89593: EMPTY
89594: LIST
89595: LIST
89596: PUSH
89597: LD_INT 1
89599: NEG
89600: PUSH
89601: LD_INT 1
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: PUSH
89608: LD_INT 2
89610: NEG
89611: PUSH
89612: LD_INT 0
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: LD_INT 2
89621: NEG
89622: PUSH
89623: LD_INT 1
89625: NEG
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: LD_INT 2
89633: NEG
89634: PUSH
89635: LD_INT 2
89637: NEG
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89664: LD_ADDR_VAR 0 59
89668: PUSH
89669: LD_INT 0
89671: PUSH
89672: LD_INT 0
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: PUSH
89679: LD_INT 0
89681: PUSH
89682: LD_INT 1
89684: NEG
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: PUSH
89690: LD_INT 1
89692: PUSH
89693: LD_INT 0
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 1
89702: PUSH
89703: LD_INT 1
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 0
89712: PUSH
89713: LD_INT 1
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 1
89722: NEG
89723: PUSH
89724: LD_INT 0
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: PUSH
89731: LD_INT 1
89733: NEG
89734: PUSH
89735: LD_INT 1
89737: NEG
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: EMPTY
89744: LIST
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89752: LD_ADDR_VAR 0 60
89756: PUSH
89757: LD_INT 0
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 0
89769: PUSH
89770: LD_INT 1
89772: NEG
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: PUSH
89778: LD_INT 1
89780: PUSH
89781: LD_INT 0
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PUSH
89788: LD_INT 1
89790: PUSH
89791: LD_INT 1
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: LD_INT 0
89800: PUSH
89801: LD_INT 1
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 1
89810: NEG
89811: PUSH
89812: LD_INT 0
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: PUSH
89819: LD_INT 1
89821: NEG
89822: PUSH
89823: LD_INT 1
89825: NEG
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: LIST
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89840: LD_ADDR_VAR 0 61
89844: PUSH
89845: LD_INT 0
89847: PUSH
89848: LD_INT 0
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PUSH
89855: LD_INT 0
89857: PUSH
89858: LD_INT 1
89860: NEG
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: LD_INT 1
89868: PUSH
89869: LD_INT 0
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: PUSH
89876: LD_INT 1
89878: PUSH
89879: LD_INT 1
89881: PUSH
89882: EMPTY
89883: LIST
89884: LIST
89885: PUSH
89886: LD_INT 0
89888: PUSH
89889: LD_INT 1
89891: PUSH
89892: EMPTY
89893: LIST
89894: LIST
89895: PUSH
89896: LD_INT 1
89898: NEG
89899: PUSH
89900: LD_INT 0
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 1
89909: NEG
89910: PUSH
89911: LD_INT 1
89913: NEG
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89928: LD_ADDR_VAR 0 62
89932: PUSH
89933: LD_INT 0
89935: PUSH
89936: LD_INT 0
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 0
89945: PUSH
89946: LD_INT 1
89948: NEG
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: LD_INT 1
89956: PUSH
89957: LD_INT 0
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: PUSH
89964: LD_INT 1
89966: PUSH
89967: LD_INT 1
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: LD_INT 1
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 1
89986: NEG
89987: PUSH
89988: LD_INT 0
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: LD_INT 1
89997: NEG
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90016: LD_ADDR_VAR 0 63
90020: PUSH
90021: LD_INT 0
90023: PUSH
90024: LD_INT 0
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 0
90033: PUSH
90034: LD_INT 1
90036: NEG
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: LD_INT 1
90044: PUSH
90045: LD_INT 0
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 1
90054: PUSH
90055: LD_INT 1
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 0
90064: PUSH
90065: LD_INT 1
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 1
90074: NEG
90075: PUSH
90076: LD_INT 0
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 1
90085: NEG
90086: PUSH
90087: LD_INT 1
90089: NEG
90090: PUSH
90091: EMPTY
90092: LIST
90093: LIST
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90104: LD_ADDR_VAR 0 64
90108: PUSH
90109: LD_INT 0
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 0
90121: PUSH
90122: LD_INT 1
90124: NEG
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PUSH
90130: LD_INT 1
90132: PUSH
90133: LD_INT 0
90135: PUSH
90136: EMPTY
90137: LIST
90138: LIST
90139: PUSH
90140: LD_INT 1
90142: PUSH
90143: LD_INT 1
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: PUSH
90150: LD_INT 0
90152: PUSH
90153: LD_INT 1
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PUSH
90160: LD_INT 1
90162: NEG
90163: PUSH
90164: LD_INT 0
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: LD_INT 1
90173: NEG
90174: PUSH
90175: LD_INT 1
90177: NEG
90178: PUSH
90179: EMPTY
90180: LIST
90181: LIST
90182: PUSH
90183: EMPTY
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: ST_TO_ADDR
// end ; 1 :
90192: GO 96089
90194: LD_INT 1
90196: DOUBLE
90197: EQUAL
90198: IFTRUE 90202
90200: GO 92825
90202: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90203: LD_ADDR_VAR 0 11
90207: PUSH
90208: LD_INT 1
90210: NEG
90211: PUSH
90212: LD_INT 3
90214: NEG
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 0
90222: PUSH
90223: LD_INT 3
90225: NEG
90226: PUSH
90227: EMPTY
90228: LIST
90229: LIST
90230: PUSH
90231: LD_INT 1
90233: PUSH
90234: LD_INT 2
90236: NEG
90237: PUSH
90238: EMPTY
90239: LIST
90240: LIST
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: LIST
90246: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90247: LD_ADDR_VAR 0 12
90251: PUSH
90252: LD_INT 2
90254: PUSH
90255: LD_INT 1
90257: NEG
90258: PUSH
90259: EMPTY
90260: LIST
90261: LIST
90262: PUSH
90263: LD_INT 3
90265: PUSH
90266: LD_INT 0
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: LD_INT 3
90275: PUSH
90276: LD_INT 1
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: LIST
90287: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90288: LD_ADDR_VAR 0 13
90292: PUSH
90293: LD_INT 3
90295: PUSH
90296: LD_INT 2
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: LD_INT 3
90305: PUSH
90306: LD_INT 3
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: LD_INT 2
90315: PUSH
90316: LD_INT 3
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: LIST
90327: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90328: LD_ADDR_VAR 0 14
90332: PUSH
90333: LD_INT 1
90335: PUSH
90336: LD_INT 3
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 0
90345: PUSH
90346: LD_INT 3
90348: PUSH
90349: EMPTY
90350: LIST
90351: LIST
90352: PUSH
90353: LD_INT 1
90355: NEG
90356: PUSH
90357: LD_INT 2
90359: PUSH
90360: EMPTY
90361: LIST
90362: LIST
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: LIST
90368: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90369: LD_ADDR_VAR 0 15
90373: PUSH
90374: LD_INT 2
90376: NEG
90377: PUSH
90378: LD_INT 1
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 3
90387: NEG
90388: PUSH
90389: LD_INT 0
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: PUSH
90396: LD_INT 3
90398: NEG
90399: PUSH
90400: LD_INT 1
90402: NEG
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: LIST
90412: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90413: LD_ADDR_VAR 0 16
90417: PUSH
90418: LD_INT 2
90420: NEG
90421: PUSH
90422: LD_INT 3
90424: NEG
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 3
90432: NEG
90433: PUSH
90434: LD_INT 2
90436: NEG
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 3
90444: NEG
90445: PUSH
90446: LD_INT 3
90448: NEG
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: LIST
90458: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90459: LD_ADDR_VAR 0 17
90463: PUSH
90464: LD_INT 1
90466: NEG
90467: PUSH
90468: LD_INT 3
90470: NEG
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PUSH
90476: LD_INT 0
90478: PUSH
90479: LD_INT 3
90481: NEG
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: PUSH
90487: LD_INT 1
90489: PUSH
90490: LD_INT 2
90492: NEG
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: LIST
90502: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90503: LD_ADDR_VAR 0 18
90507: PUSH
90508: LD_INT 2
90510: PUSH
90511: LD_INT 1
90513: NEG
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 3
90521: PUSH
90522: LD_INT 0
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 3
90531: PUSH
90532: LD_INT 1
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: LIST
90543: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90544: LD_ADDR_VAR 0 19
90548: PUSH
90549: LD_INT 3
90551: PUSH
90552: LD_INT 2
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 3
90561: PUSH
90562: LD_INT 3
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: PUSH
90569: LD_INT 2
90571: PUSH
90572: LD_INT 3
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: LIST
90583: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90584: LD_ADDR_VAR 0 20
90588: PUSH
90589: LD_INT 1
90591: PUSH
90592: LD_INT 3
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 0
90601: PUSH
90602: LD_INT 3
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: PUSH
90609: LD_INT 1
90611: NEG
90612: PUSH
90613: LD_INT 2
90615: PUSH
90616: EMPTY
90617: LIST
90618: LIST
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: LIST
90624: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90625: LD_ADDR_VAR 0 21
90629: PUSH
90630: LD_INT 2
90632: NEG
90633: PUSH
90634: LD_INT 1
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 3
90643: NEG
90644: PUSH
90645: LD_INT 0
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 3
90654: NEG
90655: PUSH
90656: LD_INT 1
90658: NEG
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: EMPTY
90665: LIST
90666: LIST
90667: LIST
90668: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90669: LD_ADDR_VAR 0 22
90673: PUSH
90674: LD_INT 2
90676: NEG
90677: PUSH
90678: LD_INT 3
90680: NEG
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 3
90688: NEG
90689: PUSH
90690: LD_INT 2
90692: NEG
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 3
90700: NEG
90701: PUSH
90702: LD_INT 3
90704: NEG
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: LIST
90714: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90715: LD_ADDR_VAR 0 23
90719: PUSH
90720: LD_INT 0
90722: PUSH
90723: LD_INT 3
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 1
90733: NEG
90734: PUSH
90735: LD_INT 4
90737: NEG
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 1
90745: PUSH
90746: LD_INT 3
90748: NEG
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: LIST
90758: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90759: LD_ADDR_VAR 0 24
90763: PUSH
90764: LD_INT 3
90766: PUSH
90767: LD_INT 0
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: LD_INT 3
90776: PUSH
90777: LD_INT 1
90779: NEG
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: PUSH
90785: LD_INT 4
90787: PUSH
90788: LD_INT 1
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: LIST
90799: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90800: LD_ADDR_VAR 0 25
90804: PUSH
90805: LD_INT 3
90807: PUSH
90808: LD_INT 3
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 4
90817: PUSH
90818: LD_INT 3
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 3
90827: PUSH
90828: LD_INT 4
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: LIST
90839: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90840: LD_ADDR_VAR 0 26
90844: PUSH
90845: LD_INT 0
90847: PUSH
90848: LD_INT 3
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: PUSH
90855: LD_INT 1
90857: PUSH
90858: LD_INT 4
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 1
90867: NEG
90868: PUSH
90869: LD_INT 3
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: LIST
90880: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90881: LD_ADDR_VAR 0 27
90885: PUSH
90886: LD_INT 3
90888: NEG
90889: PUSH
90890: LD_INT 0
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 3
90899: NEG
90900: PUSH
90901: LD_INT 1
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: PUSH
90908: LD_INT 4
90910: NEG
90911: PUSH
90912: LD_INT 1
90914: NEG
90915: PUSH
90916: EMPTY
90917: LIST
90918: LIST
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: LIST
90924: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90925: LD_ADDR_VAR 0 28
90929: PUSH
90930: LD_INT 3
90932: NEG
90933: PUSH
90934: LD_INT 3
90936: NEG
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 3
90944: NEG
90945: PUSH
90946: LD_INT 4
90948: NEG
90949: PUSH
90950: EMPTY
90951: LIST
90952: LIST
90953: PUSH
90954: LD_INT 4
90956: NEG
90957: PUSH
90958: LD_INT 3
90960: NEG
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: EMPTY
90967: LIST
90968: LIST
90969: LIST
90970: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90971: LD_ADDR_VAR 0 29
90975: PUSH
90976: LD_INT 1
90978: NEG
90979: PUSH
90980: LD_INT 3
90982: NEG
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 0
90990: PUSH
90991: LD_INT 3
90993: NEG
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 1
91001: PUSH
91002: LD_INT 2
91004: NEG
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 1
91012: NEG
91013: PUSH
91014: LD_INT 4
91016: NEG
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: PUSH
91022: LD_INT 0
91024: PUSH
91025: LD_INT 4
91027: NEG
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 1
91035: PUSH
91036: LD_INT 3
91038: NEG
91039: PUSH
91040: EMPTY
91041: LIST
91042: LIST
91043: PUSH
91044: LD_INT 1
91046: NEG
91047: PUSH
91048: LD_INT 5
91050: NEG
91051: PUSH
91052: EMPTY
91053: LIST
91054: LIST
91055: PUSH
91056: LD_INT 0
91058: PUSH
91059: LD_INT 5
91061: NEG
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: PUSH
91067: LD_INT 1
91069: PUSH
91070: LD_INT 4
91072: NEG
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 1
91080: NEG
91081: PUSH
91082: LD_INT 6
91084: NEG
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 0
91092: PUSH
91093: LD_INT 6
91095: NEG
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 1
91103: PUSH
91104: LD_INT 5
91106: NEG
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: LIST
91119: LIST
91120: LIST
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91126: LD_ADDR_VAR 0 30
91130: PUSH
91131: LD_INT 2
91133: PUSH
91134: LD_INT 1
91136: NEG
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 3
91144: PUSH
91145: LD_INT 0
91147: PUSH
91148: EMPTY
91149: LIST
91150: LIST
91151: PUSH
91152: LD_INT 3
91154: PUSH
91155: LD_INT 1
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 3
91164: PUSH
91165: LD_INT 1
91167: NEG
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 4
91175: PUSH
91176: LD_INT 0
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 4
91185: PUSH
91186: LD_INT 1
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 4
91195: PUSH
91196: LD_INT 1
91198: NEG
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 5
91206: PUSH
91207: LD_INT 0
91209: PUSH
91210: EMPTY
91211: LIST
91212: LIST
91213: PUSH
91214: LD_INT 5
91216: PUSH
91217: LD_INT 1
91219: PUSH
91220: EMPTY
91221: LIST
91222: LIST
91223: PUSH
91224: LD_INT 5
91226: PUSH
91227: LD_INT 1
91229: NEG
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: LD_INT 6
91237: PUSH
91238: LD_INT 0
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: LD_INT 6
91247: PUSH
91248: LD_INT 1
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: EMPTY
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91269: LD_ADDR_VAR 0 31
91273: PUSH
91274: LD_INT 3
91276: PUSH
91277: LD_INT 2
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 3
91286: PUSH
91287: LD_INT 3
91289: PUSH
91290: EMPTY
91291: LIST
91292: LIST
91293: PUSH
91294: LD_INT 2
91296: PUSH
91297: LD_INT 3
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: PUSH
91304: LD_INT 4
91306: PUSH
91307: LD_INT 3
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 4
91316: PUSH
91317: LD_INT 4
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: LD_INT 3
91326: PUSH
91327: LD_INT 4
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: PUSH
91334: LD_INT 5
91336: PUSH
91337: LD_INT 4
91339: PUSH
91340: EMPTY
91341: LIST
91342: LIST
91343: PUSH
91344: LD_INT 5
91346: PUSH
91347: LD_INT 5
91349: PUSH
91350: EMPTY
91351: LIST
91352: LIST
91353: PUSH
91354: LD_INT 4
91356: PUSH
91357: LD_INT 5
91359: PUSH
91360: EMPTY
91361: LIST
91362: LIST
91363: PUSH
91364: LD_INT 6
91366: PUSH
91367: LD_INT 5
91369: PUSH
91370: EMPTY
91371: LIST
91372: LIST
91373: PUSH
91374: LD_INT 6
91376: PUSH
91377: LD_INT 6
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: PUSH
91384: LD_INT 5
91386: PUSH
91387: LD_INT 6
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91408: LD_ADDR_VAR 0 32
91412: PUSH
91413: LD_INT 1
91415: PUSH
91416: LD_INT 3
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 0
91425: PUSH
91426: LD_INT 3
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 1
91435: NEG
91436: PUSH
91437: LD_INT 2
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: PUSH
91444: LD_INT 1
91446: PUSH
91447: LD_INT 4
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: PUSH
91454: LD_INT 0
91456: PUSH
91457: LD_INT 4
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 1
91466: NEG
91467: PUSH
91468: LD_INT 3
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 1
91477: PUSH
91478: LD_INT 5
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: PUSH
91485: LD_INT 0
91487: PUSH
91488: LD_INT 5
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: LD_INT 1
91497: NEG
91498: PUSH
91499: LD_INT 4
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: LD_INT 1
91508: PUSH
91509: LD_INT 6
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 0
91518: PUSH
91519: LD_INT 6
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: PUSH
91526: LD_INT 1
91528: NEG
91529: PUSH
91530: LD_INT 5
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91551: LD_ADDR_VAR 0 33
91555: PUSH
91556: LD_INT 2
91558: NEG
91559: PUSH
91560: LD_INT 1
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: LD_INT 3
91569: NEG
91570: PUSH
91571: LD_INT 0
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: LD_INT 3
91580: NEG
91581: PUSH
91582: LD_INT 1
91584: NEG
91585: PUSH
91586: EMPTY
91587: LIST
91588: LIST
91589: PUSH
91590: LD_INT 3
91592: NEG
91593: PUSH
91594: LD_INT 1
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 4
91603: NEG
91604: PUSH
91605: LD_INT 0
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 4
91614: NEG
91615: PUSH
91616: LD_INT 1
91618: NEG
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 4
91626: NEG
91627: PUSH
91628: LD_INT 1
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: LD_INT 5
91637: NEG
91638: PUSH
91639: LD_INT 0
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: PUSH
91646: LD_INT 5
91648: NEG
91649: PUSH
91650: LD_INT 1
91652: NEG
91653: PUSH
91654: EMPTY
91655: LIST
91656: LIST
91657: PUSH
91658: LD_INT 5
91660: NEG
91661: PUSH
91662: LD_INT 1
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: PUSH
91669: LD_INT 6
91671: NEG
91672: PUSH
91673: LD_INT 0
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: PUSH
91680: LD_INT 6
91682: NEG
91683: PUSH
91684: LD_INT 1
91686: NEG
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91706: LD_ADDR_VAR 0 34
91710: PUSH
91711: LD_INT 2
91713: NEG
91714: PUSH
91715: LD_INT 3
91717: NEG
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: PUSH
91723: LD_INT 3
91725: NEG
91726: PUSH
91727: LD_INT 2
91729: NEG
91730: PUSH
91731: EMPTY
91732: LIST
91733: LIST
91734: PUSH
91735: LD_INT 3
91737: NEG
91738: PUSH
91739: LD_INT 3
91741: NEG
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 3
91749: NEG
91750: PUSH
91751: LD_INT 4
91753: NEG
91754: PUSH
91755: EMPTY
91756: LIST
91757: LIST
91758: PUSH
91759: LD_INT 4
91761: NEG
91762: PUSH
91763: LD_INT 3
91765: NEG
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: PUSH
91771: LD_INT 4
91773: NEG
91774: PUSH
91775: LD_INT 4
91777: NEG
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: PUSH
91783: LD_INT 4
91785: NEG
91786: PUSH
91787: LD_INT 5
91789: NEG
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 5
91797: NEG
91798: PUSH
91799: LD_INT 4
91801: NEG
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 5
91809: NEG
91810: PUSH
91811: LD_INT 5
91813: NEG
91814: PUSH
91815: EMPTY
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 5
91821: NEG
91822: PUSH
91823: LD_INT 6
91825: NEG
91826: PUSH
91827: EMPTY
91828: LIST
91829: LIST
91830: PUSH
91831: LD_INT 6
91833: NEG
91834: PUSH
91835: LD_INT 5
91837: NEG
91838: PUSH
91839: EMPTY
91840: LIST
91841: LIST
91842: PUSH
91843: LD_INT 6
91845: NEG
91846: PUSH
91847: LD_INT 6
91849: NEG
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: PUSH
91855: EMPTY
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91869: LD_ADDR_VAR 0 41
91873: PUSH
91874: LD_INT 0
91876: PUSH
91877: LD_INT 2
91879: NEG
91880: PUSH
91881: EMPTY
91882: LIST
91883: LIST
91884: PUSH
91885: LD_INT 1
91887: NEG
91888: PUSH
91889: LD_INT 3
91891: NEG
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: PUSH
91897: LD_INT 1
91899: PUSH
91900: LD_INT 2
91902: NEG
91903: PUSH
91904: EMPTY
91905: LIST
91906: LIST
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: LIST
91912: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91913: LD_ADDR_VAR 0 42
91917: PUSH
91918: LD_INT 2
91920: PUSH
91921: LD_INT 0
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 2
91930: PUSH
91931: LD_INT 1
91933: NEG
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: LD_INT 3
91941: PUSH
91942: LD_INT 1
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: LIST
91953: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91954: LD_ADDR_VAR 0 43
91958: PUSH
91959: LD_INT 2
91961: PUSH
91962: LD_INT 2
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 3
91971: PUSH
91972: LD_INT 2
91974: PUSH
91975: EMPTY
91976: LIST
91977: LIST
91978: PUSH
91979: LD_INT 2
91981: PUSH
91982: LD_INT 3
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: LIST
91993: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91994: LD_ADDR_VAR 0 44
91998: PUSH
91999: LD_INT 0
92001: PUSH
92002: LD_INT 2
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: PUSH
92009: LD_INT 1
92011: PUSH
92012: LD_INT 3
92014: PUSH
92015: EMPTY
92016: LIST
92017: LIST
92018: PUSH
92019: LD_INT 1
92021: NEG
92022: PUSH
92023: LD_INT 2
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: LIST
92034: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
92035: LD_ADDR_VAR 0 45
92039: PUSH
92040: LD_INT 2
92042: NEG
92043: PUSH
92044: LD_INT 0
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 2
92053: NEG
92054: PUSH
92055: LD_INT 1
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: PUSH
92062: LD_INT 3
92064: NEG
92065: PUSH
92066: LD_INT 1
92068: NEG
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: LIST
92078: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
92079: LD_ADDR_VAR 0 46
92083: PUSH
92084: LD_INT 2
92086: NEG
92087: PUSH
92088: LD_INT 2
92090: NEG
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 2
92098: NEG
92099: PUSH
92100: LD_INT 3
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 3
92110: NEG
92111: PUSH
92112: LD_INT 2
92114: NEG
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: LIST
92124: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92125: LD_ADDR_VAR 0 47
92129: PUSH
92130: LD_INT 2
92132: NEG
92133: PUSH
92134: LD_INT 3
92136: NEG
92137: PUSH
92138: EMPTY
92139: LIST
92140: LIST
92141: PUSH
92142: LD_INT 1
92144: NEG
92145: PUSH
92146: LD_INT 3
92148: NEG
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92158: LD_ADDR_VAR 0 48
92162: PUSH
92163: LD_INT 1
92165: PUSH
92166: LD_INT 2
92168: NEG
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: PUSH
92174: LD_INT 2
92176: PUSH
92177: LD_INT 1
92179: NEG
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92189: LD_ADDR_VAR 0 49
92193: PUSH
92194: LD_INT 3
92196: PUSH
92197: LD_INT 1
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 3
92206: PUSH
92207: LD_INT 2
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92218: LD_ADDR_VAR 0 50
92222: PUSH
92223: LD_INT 2
92225: PUSH
92226: LD_INT 3
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 1
92235: PUSH
92236: LD_INT 3
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92247: LD_ADDR_VAR 0 51
92251: PUSH
92252: LD_INT 1
92254: NEG
92255: PUSH
92256: LD_INT 2
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 2
92265: NEG
92266: PUSH
92267: LD_INT 1
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92278: LD_ADDR_VAR 0 52
92282: PUSH
92283: LD_INT 3
92285: NEG
92286: PUSH
92287: LD_INT 1
92289: NEG
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PUSH
92295: LD_INT 3
92297: NEG
92298: PUSH
92299: LD_INT 2
92301: NEG
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92311: LD_ADDR_VAR 0 53
92315: PUSH
92316: LD_INT 1
92318: NEG
92319: PUSH
92320: LD_INT 3
92322: NEG
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: PUSH
92328: LD_INT 0
92330: PUSH
92331: LD_INT 3
92333: NEG
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: LD_INT 1
92341: PUSH
92342: LD_INT 2
92344: NEG
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: LIST
92354: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92355: LD_ADDR_VAR 0 54
92359: PUSH
92360: LD_INT 2
92362: PUSH
92363: LD_INT 1
92365: NEG
92366: PUSH
92367: EMPTY
92368: LIST
92369: LIST
92370: PUSH
92371: LD_INT 3
92373: PUSH
92374: LD_INT 0
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: PUSH
92381: LD_INT 3
92383: PUSH
92384: LD_INT 1
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: LIST
92395: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92396: LD_ADDR_VAR 0 55
92400: PUSH
92401: LD_INT 3
92403: PUSH
92404: LD_INT 2
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 3
92413: PUSH
92414: LD_INT 3
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 2
92423: PUSH
92424: LD_INT 3
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: LIST
92435: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92436: LD_ADDR_VAR 0 56
92440: PUSH
92441: LD_INT 1
92443: PUSH
92444: LD_INT 3
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 0
92453: PUSH
92454: LD_INT 3
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 1
92463: NEG
92464: PUSH
92465: LD_INT 2
92467: PUSH
92468: EMPTY
92469: LIST
92470: LIST
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: LIST
92476: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92477: LD_ADDR_VAR 0 57
92481: PUSH
92482: LD_INT 2
92484: NEG
92485: PUSH
92486: LD_INT 1
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 3
92495: NEG
92496: PUSH
92497: LD_INT 0
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 3
92506: NEG
92507: PUSH
92508: LD_INT 1
92510: NEG
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: LIST
92520: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92521: LD_ADDR_VAR 0 58
92525: PUSH
92526: LD_INT 2
92528: NEG
92529: PUSH
92530: LD_INT 3
92532: NEG
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: PUSH
92538: LD_INT 3
92540: NEG
92541: PUSH
92542: LD_INT 2
92544: NEG
92545: PUSH
92546: EMPTY
92547: LIST
92548: LIST
92549: PUSH
92550: LD_INT 3
92552: NEG
92553: PUSH
92554: LD_INT 3
92556: NEG
92557: PUSH
92558: EMPTY
92559: LIST
92560: LIST
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: LIST
92566: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92567: LD_ADDR_VAR 0 59
92571: PUSH
92572: LD_INT 1
92574: NEG
92575: PUSH
92576: LD_INT 2
92578: NEG
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 0
92586: PUSH
92587: LD_INT 2
92589: NEG
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 1
92597: PUSH
92598: LD_INT 1
92600: NEG
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: LIST
92610: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92611: LD_ADDR_VAR 0 60
92615: PUSH
92616: LD_INT 1
92618: PUSH
92619: LD_INT 1
92621: NEG
92622: PUSH
92623: EMPTY
92624: LIST
92625: LIST
92626: PUSH
92627: LD_INT 2
92629: PUSH
92630: LD_INT 0
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: LD_INT 2
92639: PUSH
92640: LD_INT 1
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: LIST
92651: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92652: LD_ADDR_VAR 0 61
92656: PUSH
92657: LD_INT 2
92659: PUSH
92660: LD_INT 1
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 2
92669: PUSH
92670: LD_INT 2
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 1
92679: PUSH
92680: LD_INT 2
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: LIST
92691: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92692: LD_ADDR_VAR 0 62
92696: PUSH
92697: LD_INT 1
92699: PUSH
92700: LD_INT 2
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: PUSH
92707: LD_INT 0
92709: PUSH
92710: LD_INT 2
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PUSH
92717: LD_INT 1
92719: NEG
92720: PUSH
92721: LD_INT 1
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: LIST
92732: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92733: LD_ADDR_VAR 0 63
92737: PUSH
92738: LD_INT 1
92740: NEG
92741: PUSH
92742: LD_INT 1
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 2
92751: NEG
92752: PUSH
92753: LD_INT 0
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 2
92762: NEG
92763: PUSH
92764: LD_INT 1
92766: NEG
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: LIST
92776: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92777: LD_ADDR_VAR 0 64
92781: PUSH
92782: LD_INT 1
92784: NEG
92785: PUSH
92786: LD_INT 2
92788: NEG
92789: PUSH
92790: EMPTY
92791: LIST
92792: LIST
92793: PUSH
92794: LD_INT 2
92796: NEG
92797: PUSH
92798: LD_INT 1
92800: NEG
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 2
92808: NEG
92809: PUSH
92810: LD_INT 2
92812: NEG
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: PUSH
92818: EMPTY
92819: LIST
92820: LIST
92821: LIST
92822: ST_TO_ADDR
// end ; 2 :
92823: GO 96089
92825: LD_INT 2
92827: DOUBLE
92828: EQUAL
92829: IFTRUE 92833
92831: GO 96088
92833: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92834: LD_ADDR_VAR 0 29
92838: PUSH
92839: LD_INT 4
92841: PUSH
92842: LD_INT 0
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 4
92851: PUSH
92852: LD_INT 1
92854: NEG
92855: PUSH
92856: EMPTY
92857: LIST
92858: LIST
92859: PUSH
92860: LD_INT 5
92862: PUSH
92863: LD_INT 0
92865: PUSH
92866: EMPTY
92867: LIST
92868: LIST
92869: PUSH
92870: LD_INT 5
92872: PUSH
92873: LD_INT 1
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: PUSH
92880: LD_INT 4
92882: PUSH
92883: LD_INT 1
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: PUSH
92890: LD_INT 3
92892: PUSH
92893: LD_INT 0
92895: PUSH
92896: EMPTY
92897: LIST
92898: LIST
92899: PUSH
92900: LD_INT 3
92902: PUSH
92903: LD_INT 1
92905: NEG
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: PUSH
92911: LD_INT 3
92913: PUSH
92914: LD_INT 2
92916: NEG
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: PUSH
92922: LD_INT 5
92924: PUSH
92925: LD_INT 2
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: PUSH
92932: LD_INT 3
92934: PUSH
92935: LD_INT 3
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: PUSH
92942: LD_INT 3
92944: PUSH
92945: LD_INT 2
92947: PUSH
92948: EMPTY
92949: LIST
92950: LIST
92951: PUSH
92952: LD_INT 4
92954: PUSH
92955: LD_INT 3
92957: PUSH
92958: EMPTY
92959: LIST
92960: LIST
92961: PUSH
92962: LD_INT 4
92964: PUSH
92965: LD_INT 4
92967: PUSH
92968: EMPTY
92969: LIST
92970: LIST
92971: PUSH
92972: LD_INT 3
92974: PUSH
92975: LD_INT 4
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: PUSH
92982: LD_INT 2
92984: PUSH
92985: LD_INT 3
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: LD_INT 2
92994: PUSH
92995: LD_INT 2
92997: PUSH
92998: EMPTY
92999: LIST
93000: LIST
93001: PUSH
93002: LD_INT 4
93004: PUSH
93005: LD_INT 2
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 2
93014: PUSH
93015: LD_INT 4
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 0
93024: PUSH
93025: LD_INT 4
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PUSH
93032: LD_INT 0
93034: PUSH
93035: LD_INT 3
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 1
93044: PUSH
93045: LD_INT 4
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 1
93054: PUSH
93055: LD_INT 5
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: LD_INT 0
93064: PUSH
93065: LD_INT 5
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 1
93074: NEG
93075: PUSH
93076: LD_INT 4
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 1
93085: NEG
93086: PUSH
93087: LD_INT 3
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 2
93096: PUSH
93097: LD_INT 5
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: LD_INT 2
93106: NEG
93107: PUSH
93108: LD_INT 3
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: LD_INT 3
93117: NEG
93118: PUSH
93119: LD_INT 0
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 3
93128: NEG
93129: PUSH
93130: LD_INT 1
93132: NEG
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 2
93140: NEG
93141: PUSH
93142: LD_INT 0
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: LD_INT 2
93151: NEG
93152: PUSH
93153: LD_INT 1
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 3
93162: NEG
93163: PUSH
93164: LD_INT 1
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 4
93173: NEG
93174: PUSH
93175: LD_INT 0
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 4
93184: NEG
93185: PUSH
93186: LD_INT 1
93188: NEG
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_INT 4
93196: NEG
93197: PUSH
93198: LD_INT 2
93200: NEG
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 2
93208: NEG
93209: PUSH
93210: LD_INT 2
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: PUSH
93217: LD_INT 4
93219: NEG
93220: PUSH
93221: LD_INT 4
93223: NEG
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: LD_INT 4
93231: NEG
93232: PUSH
93233: LD_INT 5
93235: NEG
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: PUSH
93241: LD_INT 3
93243: NEG
93244: PUSH
93245: LD_INT 4
93247: NEG
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: LD_INT 3
93255: NEG
93256: PUSH
93257: LD_INT 3
93259: NEG
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: PUSH
93265: LD_INT 4
93267: NEG
93268: PUSH
93269: LD_INT 3
93271: NEG
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: PUSH
93277: LD_INT 5
93279: NEG
93280: PUSH
93281: LD_INT 4
93283: NEG
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: LD_INT 5
93291: NEG
93292: PUSH
93293: LD_INT 5
93295: NEG
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 3
93303: NEG
93304: PUSH
93305: LD_INT 5
93307: NEG
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: LD_INT 5
93315: NEG
93316: PUSH
93317: LD_INT 3
93319: NEG
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93372: LD_ADDR_VAR 0 30
93376: PUSH
93377: LD_INT 4
93379: PUSH
93380: LD_INT 4
93382: PUSH
93383: EMPTY
93384: LIST
93385: LIST
93386: PUSH
93387: LD_INT 4
93389: PUSH
93390: LD_INT 3
93392: PUSH
93393: EMPTY
93394: LIST
93395: LIST
93396: PUSH
93397: LD_INT 5
93399: PUSH
93400: LD_INT 4
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: PUSH
93407: LD_INT 5
93409: PUSH
93410: LD_INT 5
93412: PUSH
93413: EMPTY
93414: LIST
93415: LIST
93416: PUSH
93417: LD_INT 4
93419: PUSH
93420: LD_INT 5
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: PUSH
93427: LD_INT 3
93429: PUSH
93430: LD_INT 4
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 3
93439: PUSH
93440: LD_INT 3
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: LD_INT 5
93449: PUSH
93450: LD_INT 3
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: PUSH
93457: LD_INT 3
93459: PUSH
93460: LD_INT 5
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 0
93469: PUSH
93470: LD_INT 3
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: PUSH
93477: LD_INT 0
93479: PUSH
93480: LD_INT 2
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: PUSH
93487: LD_INT 1
93489: PUSH
93490: LD_INT 3
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: LD_INT 1
93499: PUSH
93500: LD_INT 4
93502: PUSH
93503: EMPTY
93504: LIST
93505: LIST
93506: PUSH
93507: LD_INT 0
93509: PUSH
93510: LD_INT 4
93512: PUSH
93513: EMPTY
93514: LIST
93515: LIST
93516: PUSH
93517: LD_INT 1
93519: NEG
93520: PUSH
93521: LD_INT 3
93523: PUSH
93524: EMPTY
93525: LIST
93526: LIST
93527: PUSH
93528: LD_INT 1
93530: NEG
93531: PUSH
93532: LD_INT 2
93534: PUSH
93535: EMPTY
93536: LIST
93537: LIST
93538: PUSH
93539: LD_INT 2
93541: PUSH
93542: LD_INT 4
93544: PUSH
93545: EMPTY
93546: LIST
93547: LIST
93548: PUSH
93549: LD_INT 2
93551: NEG
93552: PUSH
93553: LD_INT 2
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: PUSH
93560: LD_INT 4
93562: NEG
93563: PUSH
93564: LD_INT 0
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: LD_INT 4
93573: NEG
93574: PUSH
93575: LD_INT 1
93577: NEG
93578: PUSH
93579: EMPTY
93580: LIST
93581: LIST
93582: PUSH
93583: LD_INT 3
93585: NEG
93586: PUSH
93587: LD_INT 0
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: LD_INT 3
93596: NEG
93597: PUSH
93598: LD_INT 1
93600: PUSH
93601: EMPTY
93602: LIST
93603: LIST
93604: PUSH
93605: LD_INT 4
93607: NEG
93608: PUSH
93609: LD_INT 1
93611: PUSH
93612: EMPTY
93613: LIST
93614: LIST
93615: PUSH
93616: LD_INT 5
93618: NEG
93619: PUSH
93620: LD_INT 0
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 5
93629: NEG
93630: PUSH
93631: LD_INT 1
93633: NEG
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 5
93641: NEG
93642: PUSH
93643: LD_INT 2
93645: NEG
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 3
93653: NEG
93654: PUSH
93655: LD_INT 2
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PUSH
93662: LD_INT 3
93664: NEG
93665: PUSH
93666: LD_INT 3
93668: NEG
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: PUSH
93674: LD_INT 3
93676: NEG
93677: PUSH
93678: LD_INT 4
93680: NEG
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: LD_INT 2
93688: NEG
93689: PUSH
93690: LD_INT 3
93692: NEG
93693: PUSH
93694: EMPTY
93695: LIST
93696: LIST
93697: PUSH
93698: LD_INT 2
93700: NEG
93701: PUSH
93702: LD_INT 2
93704: NEG
93705: PUSH
93706: EMPTY
93707: LIST
93708: LIST
93709: PUSH
93710: LD_INT 3
93712: NEG
93713: PUSH
93714: LD_INT 2
93716: NEG
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: PUSH
93722: LD_INT 4
93724: NEG
93725: PUSH
93726: LD_INT 3
93728: NEG
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: LD_INT 4
93736: NEG
93737: PUSH
93738: LD_INT 4
93740: NEG
93741: PUSH
93742: EMPTY
93743: LIST
93744: LIST
93745: PUSH
93746: LD_INT 2
93748: NEG
93749: PUSH
93750: LD_INT 4
93752: NEG
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 4
93760: NEG
93761: PUSH
93762: LD_INT 2
93764: NEG
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 0
93772: PUSH
93773: LD_INT 4
93775: NEG
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 0
93783: PUSH
93784: LD_INT 5
93786: NEG
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: LD_INT 1
93794: PUSH
93795: LD_INT 4
93797: NEG
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 1
93805: PUSH
93806: LD_INT 3
93808: NEG
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: PUSH
93814: LD_INT 0
93816: PUSH
93817: LD_INT 3
93819: NEG
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 1
93827: NEG
93828: PUSH
93829: LD_INT 4
93831: NEG
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 1
93839: NEG
93840: PUSH
93841: LD_INT 5
93843: NEG
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: PUSH
93849: LD_INT 2
93851: PUSH
93852: LD_INT 3
93854: NEG
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: LD_INT 2
93862: NEG
93863: PUSH
93864: LD_INT 5
93866: NEG
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93919: LD_ADDR_VAR 0 31
93923: PUSH
93924: LD_INT 0
93926: PUSH
93927: LD_INT 4
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: PUSH
93934: LD_INT 0
93936: PUSH
93937: LD_INT 3
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PUSH
93944: LD_INT 1
93946: PUSH
93947: LD_INT 4
93949: PUSH
93950: EMPTY
93951: LIST
93952: LIST
93953: PUSH
93954: LD_INT 1
93956: PUSH
93957: LD_INT 5
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: LD_INT 0
93966: PUSH
93967: LD_INT 5
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 1
93976: NEG
93977: PUSH
93978: LD_INT 4
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: PUSH
93985: LD_INT 1
93987: NEG
93988: PUSH
93989: LD_INT 3
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: PUSH
93996: LD_INT 2
93998: PUSH
93999: LD_INT 5
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: PUSH
94006: LD_INT 2
94008: NEG
94009: PUSH
94010: LD_INT 3
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PUSH
94017: LD_INT 3
94019: NEG
94020: PUSH
94021: LD_INT 0
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: LD_INT 3
94030: NEG
94031: PUSH
94032: LD_INT 1
94034: NEG
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: LD_INT 2
94042: NEG
94043: PUSH
94044: LD_INT 0
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 2
94053: NEG
94054: PUSH
94055: LD_INT 1
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: PUSH
94062: LD_INT 3
94064: NEG
94065: PUSH
94066: LD_INT 1
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 4
94075: NEG
94076: PUSH
94077: LD_INT 0
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 4
94086: NEG
94087: PUSH
94088: LD_INT 1
94090: NEG
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 4
94098: NEG
94099: PUSH
94100: LD_INT 2
94102: NEG
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 2
94110: NEG
94111: PUSH
94112: LD_INT 2
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 4
94121: NEG
94122: PUSH
94123: LD_INT 4
94125: NEG
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 4
94133: NEG
94134: PUSH
94135: LD_INT 5
94137: NEG
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: PUSH
94143: LD_INT 3
94145: NEG
94146: PUSH
94147: LD_INT 4
94149: NEG
94150: PUSH
94151: EMPTY
94152: LIST
94153: LIST
94154: PUSH
94155: LD_INT 3
94157: NEG
94158: PUSH
94159: LD_INT 3
94161: NEG
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: PUSH
94167: LD_INT 4
94169: NEG
94170: PUSH
94171: LD_INT 3
94173: NEG
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 5
94181: NEG
94182: PUSH
94183: LD_INT 4
94185: NEG
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: LD_INT 5
94193: NEG
94194: PUSH
94195: LD_INT 5
94197: NEG
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 3
94205: NEG
94206: PUSH
94207: LD_INT 5
94209: NEG
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 5
94217: NEG
94218: PUSH
94219: LD_INT 3
94221: NEG
94222: PUSH
94223: EMPTY
94224: LIST
94225: LIST
94226: PUSH
94227: LD_INT 0
94229: PUSH
94230: LD_INT 3
94232: NEG
94233: PUSH
94234: EMPTY
94235: LIST
94236: LIST
94237: PUSH
94238: LD_INT 0
94240: PUSH
94241: LD_INT 4
94243: NEG
94244: PUSH
94245: EMPTY
94246: LIST
94247: LIST
94248: PUSH
94249: LD_INT 1
94251: PUSH
94252: LD_INT 3
94254: NEG
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: PUSH
94260: LD_INT 1
94262: PUSH
94263: LD_INT 2
94265: NEG
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 0
94273: PUSH
94274: LD_INT 2
94276: NEG
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 1
94284: NEG
94285: PUSH
94286: LD_INT 3
94288: NEG
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 1
94296: NEG
94297: PUSH
94298: LD_INT 4
94300: NEG
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 2
94308: PUSH
94309: LD_INT 2
94311: NEG
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: PUSH
94317: LD_INT 2
94319: NEG
94320: PUSH
94321: LD_INT 4
94323: NEG
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 4
94331: PUSH
94332: LD_INT 0
94334: PUSH
94335: EMPTY
94336: LIST
94337: LIST
94338: PUSH
94339: LD_INT 4
94341: PUSH
94342: LD_INT 1
94344: NEG
94345: PUSH
94346: EMPTY
94347: LIST
94348: LIST
94349: PUSH
94350: LD_INT 5
94352: PUSH
94353: LD_INT 0
94355: PUSH
94356: EMPTY
94357: LIST
94358: LIST
94359: PUSH
94360: LD_INT 5
94362: PUSH
94363: LD_INT 1
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 4
94372: PUSH
94373: LD_INT 1
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 3
94382: PUSH
94383: LD_INT 0
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: PUSH
94390: LD_INT 3
94392: PUSH
94393: LD_INT 1
94395: NEG
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 3
94403: PUSH
94404: LD_INT 2
94406: NEG
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 5
94414: PUSH
94415: LD_INT 2
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94469: LD_ADDR_VAR 0 32
94473: PUSH
94474: LD_INT 4
94476: NEG
94477: PUSH
94478: LD_INT 0
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: LD_INT 4
94487: NEG
94488: PUSH
94489: LD_INT 1
94491: NEG
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 3
94499: NEG
94500: PUSH
94501: LD_INT 0
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: LD_INT 3
94510: NEG
94511: PUSH
94512: LD_INT 1
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: LD_INT 4
94521: NEG
94522: PUSH
94523: LD_INT 1
94525: PUSH
94526: EMPTY
94527: LIST
94528: LIST
94529: PUSH
94530: LD_INT 5
94532: NEG
94533: PUSH
94534: LD_INT 0
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: PUSH
94541: LD_INT 5
94543: NEG
94544: PUSH
94545: LD_INT 1
94547: NEG
94548: PUSH
94549: EMPTY
94550: LIST
94551: LIST
94552: PUSH
94553: LD_INT 5
94555: NEG
94556: PUSH
94557: LD_INT 2
94559: NEG
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 3
94567: NEG
94568: PUSH
94569: LD_INT 2
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 3
94578: NEG
94579: PUSH
94580: LD_INT 3
94582: NEG
94583: PUSH
94584: EMPTY
94585: LIST
94586: LIST
94587: PUSH
94588: LD_INT 3
94590: NEG
94591: PUSH
94592: LD_INT 4
94594: NEG
94595: PUSH
94596: EMPTY
94597: LIST
94598: LIST
94599: PUSH
94600: LD_INT 2
94602: NEG
94603: PUSH
94604: LD_INT 3
94606: NEG
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 2
94614: NEG
94615: PUSH
94616: LD_INT 2
94618: NEG
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 3
94626: NEG
94627: PUSH
94628: LD_INT 2
94630: NEG
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 4
94638: NEG
94639: PUSH
94640: LD_INT 3
94642: NEG
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 4
94650: NEG
94651: PUSH
94652: LD_INT 4
94654: NEG
94655: PUSH
94656: EMPTY
94657: LIST
94658: LIST
94659: PUSH
94660: LD_INT 2
94662: NEG
94663: PUSH
94664: LD_INT 4
94666: NEG
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 4
94674: NEG
94675: PUSH
94676: LD_INT 2
94678: NEG
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 0
94686: PUSH
94687: LD_INT 4
94689: NEG
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: PUSH
94695: LD_INT 0
94697: PUSH
94698: LD_INT 5
94700: NEG
94701: PUSH
94702: EMPTY
94703: LIST
94704: LIST
94705: PUSH
94706: LD_INT 1
94708: PUSH
94709: LD_INT 4
94711: NEG
94712: PUSH
94713: EMPTY
94714: LIST
94715: LIST
94716: PUSH
94717: LD_INT 1
94719: PUSH
94720: LD_INT 3
94722: NEG
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 0
94730: PUSH
94731: LD_INT 3
94733: NEG
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: PUSH
94739: LD_INT 1
94741: NEG
94742: PUSH
94743: LD_INT 4
94745: NEG
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: LD_INT 1
94753: NEG
94754: PUSH
94755: LD_INT 5
94757: NEG
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 2
94765: PUSH
94766: LD_INT 3
94768: NEG
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 2
94776: NEG
94777: PUSH
94778: LD_INT 5
94780: NEG
94781: PUSH
94782: EMPTY
94783: LIST
94784: LIST
94785: PUSH
94786: LD_INT 3
94788: PUSH
94789: LD_INT 0
94791: PUSH
94792: EMPTY
94793: LIST
94794: LIST
94795: PUSH
94796: LD_INT 3
94798: PUSH
94799: LD_INT 1
94801: NEG
94802: PUSH
94803: EMPTY
94804: LIST
94805: LIST
94806: PUSH
94807: LD_INT 4
94809: PUSH
94810: LD_INT 0
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: PUSH
94817: LD_INT 4
94819: PUSH
94820: LD_INT 1
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: PUSH
94827: LD_INT 3
94829: PUSH
94830: LD_INT 1
94832: PUSH
94833: EMPTY
94834: LIST
94835: LIST
94836: PUSH
94837: LD_INT 2
94839: PUSH
94840: LD_INT 0
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 2
94849: PUSH
94850: LD_INT 1
94852: NEG
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 2
94860: PUSH
94861: LD_INT 2
94863: NEG
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 4
94871: PUSH
94872: LD_INT 2
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: LD_INT 4
94881: PUSH
94882: LD_INT 4
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 4
94891: PUSH
94892: LD_INT 3
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 5
94901: PUSH
94902: LD_INT 4
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 5
94911: PUSH
94912: LD_INT 5
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 4
94921: PUSH
94922: LD_INT 5
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 3
94931: PUSH
94932: LD_INT 4
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 3
94941: PUSH
94942: LD_INT 3
94944: PUSH
94945: EMPTY
94946: LIST
94947: LIST
94948: PUSH
94949: LD_INT 5
94951: PUSH
94952: LD_INT 3
94954: PUSH
94955: EMPTY
94956: LIST
94957: LIST
94958: PUSH
94959: LD_INT 3
94961: PUSH
94962: LD_INT 5
94964: PUSH
94965: EMPTY
94966: LIST
94967: LIST
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
95016: LD_ADDR_VAR 0 33
95020: PUSH
95021: LD_INT 4
95023: NEG
95024: PUSH
95025: LD_INT 4
95027: NEG
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 4
95035: NEG
95036: PUSH
95037: LD_INT 5
95039: NEG
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PUSH
95045: LD_INT 3
95047: NEG
95048: PUSH
95049: LD_INT 4
95051: NEG
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: LD_INT 3
95059: NEG
95060: PUSH
95061: LD_INT 3
95063: NEG
95064: PUSH
95065: EMPTY
95066: LIST
95067: LIST
95068: PUSH
95069: LD_INT 4
95071: NEG
95072: PUSH
95073: LD_INT 3
95075: NEG
95076: PUSH
95077: EMPTY
95078: LIST
95079: LIST
95080: PUSH
95081: LD_INT 5
95083: NEG
95084: PUSH
95085: LD_INT 4
95087: NEG
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: LD_INT 5
95095: NEG
95096: PUSH
95097: LD_INT 5
95099: NEG
95100: PUSH
95101: EMPTY
95102: LIST
95103: LIST
95104: PUSH
95105: LD_INT 3
95107: NEG
95108: PUSH
95109: LD_INT 5
95111: NEG
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: LD_INT 5
95119: NEG
95120: PUSH
95121: LD_INT 3
95123: NEG
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 0
95131: PUSH
95132: LD_INT 3
95134: NEG
95135: PUSH
95136: EMPTY
95137: LIST
95138: LIST
95139: PUSH
95140: LD_INT 0
95142: PUSH
95143: LD_INT 4
95145: NEG
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: LD_INT 1
95153: PUSH
95154: LD_INT 3
95156: NEG
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 1
95164: PUSH
95165: LD_INT 2
95167: NEG
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: LD_INT 0
95175: PUSH
95176: LD_INT 2
95178: NEG
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: PUSH
95184: LD_INT 1
95186: NEG
95187: PUSH
95188: LD_INT 3
95190: NEG
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: PUSH
95196: LD_INT 1
95198: NEG
95199: PUSH
95200: LD_INT 4
95202: NEG
95203: PUSH
95204: EMPTY
95205: LIST
95206: LIST
95207: PUSH
95208: LD_INT 2
95210: PUSH
95211: LD_INT 2
95213: NEG
95214: PUSH
95215: EMPTY
95216: LIST
95217: LIST
95218: PUSH
95219: LD_INT 2
95221: NEG
95222: PUSH
95223: LD_INT 4
95225: NEG
95226: PUSH
95227: EMPTY
95228: LIST
95229: LIST
95230: PUSH
95231: LD_INT 4
95233: PUSH
95234: LD_INT 0
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: PUSH
95241: LD_INT 4
95243: PUSH
95244: LD_INT 1
95246: NEG
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: PUSH
95252: LD_INT 5
95254: PUSH
95255: LD_INT 0
95257: PUSH
95258: EMPTY
95259: LIST
95260: LIST
95261: PUSH
95262: LD_INT 5
95264: PUSH
95265: LD_INT 1
95267: PUSH
95268: EMPTY
95269: LIST
95270: LIST
95271: PUSH
95272: LD_INT 4
95274: PUSH
95275: LD_INT 1
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: PUSH
95282: LD_INT 3
95284: PUSH
95285: LD_INT 0
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: PUSH
95292: LD_INT 3
95294: PUSH
95295: LD_INT 1
95297: NEG
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PUSH
95303: LD_INT 3
95305: PUSH
95306: LD_INT 2
95308: NEG
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 5
95316: PUSH
95317: LD_INT 2
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 3
95326: PUSH
95327: LD_INT 3
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 3
95336: PUSH
95337: LD_INT 2
95339: PUSH
95340: EMPTY
95341: LIST
95342: LIST
95343: PUSH
95344: LD_INT 4
95346: PUSH
95347: LD_INT 3
95349: PUSH
95350: EMPTY
95351: LIST
95352: LIST
95353: PUSH
95354: LD_INT 4
95356: PUSH
95357: LD_INT 4
95359: PUSH
95360: EMPTY
95361: LIST
95362: LIST
95363: PUSH
95364: LD_INT 3
95366: PUSH
95367: LD_INT 4
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: PUSH
95374: LD_INT 2
95376: PUSH
95377: LD_INT 3
95379: PUSH
95380: EMPTY
95381: LIST
95382: LIST
95383: PUSH
95384: LD_INT 2
95386: PUSH
95387: LD_INT 2
95389: PUSH
95390: EMPTY
95391: LIST
95392: LIST
95393: PUSH
95394: LD_INT 4
95396: PUSH
95397: LD_INT 2
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: PUSH
95404: LD_INT 2
95406: PUSH
95407: LD_INT 4
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PUSH
95414: LD_INT 0
95416: PUSH
95417: LD_INT 4
95419: PUSH
95420: EMPTY
95421: LIST
95422: LIST
95423: PUSH
95424: LD_INT 0
95426: PUSH
95427: LD_INT 3
95429: PUSH
95430: EMPTY
95431: LIST
95432: LIST
95433: PUSH
95434: LD_INT 1
95436: PUSH
95437: LD_INT 4
95439: PUSH
95440: EMPTY
95441: LIST
95442: LIST
95443: PUSH
95444: LD_INT 1
95446: PUSH
95447: LD_INT 5
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 0
95456: PUSH
95457: LD_INT 5
95459: PUSH
95460: EMPTY
95461: LIST
95462: LIST
95463: PUSH
95464: LD_INT 1
95466: NEG
95467: PUSH
95468: LD_INT 4
95470: PUSH
95471: EMPTY
95472: LIST
95473: LIST
95474: PUSH
95475: LD_INT 1
95477: NEG
95478: PUSH
95479: LD_INT 3
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 2
95488: PUSH
95489: LD_INT 5
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 2
95498: NEG
95499: PUSH
95500: LD_INT 3
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95554: LD_ADDR_VAR 0 34
95558: PUSH
95559: LD_INT 0
95561: PUSH
95562: LD_INT 4
95564: NEG
95565: PUSH
95566: EMPTY
95567: LIST
95568: LIST
95569: PUSH
95570: LD_INT 0
95572: PUSH
95573: LD_INT 5
95575: NEG
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: LD_INT 1
95583: PUSH
95584: LD_INT 4
95586: NEG
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 1
95594: PUSH
95595: LD_INT 3
95597: NEG
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 0
95605: PUSH
95606: LD_INT 3
95608: NEG
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 1
95616: NEG
95617: PUSH
95618: LD_INT 4
95620: NEG
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: LD_INT 1
95628: NEG
95629: PUSH
95630: LD_INT 5
95632: NEG
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: PUSH
95638: LD_INT 2
95640: PUSH
95641: LD_INT 3
95643: NEG
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: LD_INT 2
95651: NEG
95652: PUSH
95653: LD_INT 5
95655: NEG
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 3
95663: PUSH
95664: LD_INT 0
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PUSH
95671: LD_INT 3
95673: PUSH
95674: LD_INT 1
95676: NEG
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: PUSH
95682: LD_INT 4
95684: PUSH
95685: LD_INT 0
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: PUSH
95692: LD_INT 4
95694: PUSH
95695: LD_INT 1
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: PUSH
95702: LD_INT 3
95704: PUSH
95705: LD_INT 1
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: LD_INT 2
95714: PUSH
95715: LD_INT 0
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 2
95724: PUSH
95725: LD_INT 1
95727: NEG
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 2
95735: PUSH
95736: LD_INT 2
95738: NEG
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 4
95746: PUSH
95747: LD_INT 2
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: LD_INT 4
95756: PUSH
95757: LD_INT 4
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: LD_INT 4
95766: PUSH
95767: LD_INT 3
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 5
95776: PUSH
95777: LD_INT 4
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 5
95786: PUSH
95787: LD_INT 5
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PUSH
95794: LD_INT 4
95796: PUSH
95797: LD_INT 5
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: PUSH
95804: LD_INT 3
95806: PUSH
95807: LD_INT 4
95809: PUSH
95810: EMPTY
95811: LIST
95812: LIST
95813: PUSH
95814: LD_INT 3
95816: PUSH
95817: LD_INT 3
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: PUSH
95824: LD_INT 5
95826: PUSH
95827: LD_INT 3
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: PUSH
95834: LD_INT 3
95836: PUSH
95837: LD_INT 5
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: PUSH
95844: LD_INT 0
95846: PUSH
95847: LD_INT 3
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 0
95856: PUSH
95857: LD_INT 2
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: LD_INT 1
95866: PUSH
95867: LD_INT 3
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: PUSH
95874: LD_INT 1
95876: PUSH
95877: LD_INT 4
95879: PUSH
95880: EMPTY
95881: LIST
95882: LIST
95883: PUSH
95884: LD_INT 0
95886: PUSH
95887: LD_INT 4
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 1
95896: NEG
95897: PUSH
95898: LD_INT 3
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: LD_INT 1
95907: NEG
95908: PUSH
95909: LD_INT 2
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: PUSH
95916: LD_INT 2
95918: PUSH
95919: LD_INT 4
95921: PUSH
95922: EMPTY
95923: LIST
95924: LIST
95925: PUSH
95926: LD_INT 2
95928: NEG
95929: PUSH
95930: LD_INT 2
95932: PUSH
95933: EMPTY
95934: LIST
95935: LIST
95936: PUSH
95937: LD_INT 4
95939: NEG
95940: PUSH
95941: LD_INT 0
95943: PUSH
95944: EMPTY
95945: LIST
95946: LIST
95947: PUSH
95948: LD_INT 4
95950: NEG
95951: PUSH
95952: LD_INT 1
95954: NEG
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: PUSH
95960: LD_INT 3
95962: NEG
95963: PUSH
95964: LD_INT 0
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: LD_INT 3
95973: NEG
95974: PUSH
95975: LD_INT 1
95977: PUSH
95978: EMPTY
95979: LIST
95980: LIST
95981: PUSH
95982: LD_INT 4
95984: NEG
95985: PUSH
95986: LD_INT 1
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 5
95995: NEG
95996: PUSH
95997: LD_INT 0
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: LD_INT 5
96006: NEG
96007: PUSH
96008: LD_INT 1
96010: NEG
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: PUSH
96016: LD_INT 5
96018: NEG
96019: PUSH
96020: LD_INT 2
96022: NEG
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: LD_INT 3
96030: NEG
96031: PUSH
96032: LD_INT 2
96034: PUSH
96035: EMPTY
96036: LIST
96037: LIST
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: ST_TO_ADDR
// end ; end ;
96086: GO 96089
96088: POP
// case btype of b_depot , b_warehouse :
96089: LD_VAR 0 1
96093: PUSH
96094: LD_INT 0
96096: DOUBLE
96097: EQUAL
96098: IFTRUE 96108
96100: LD_INT 1
96102: DOUBLE
96103: EQUAL
96104: IFTRUE 96108
96106: GO 96309
96108: POP
// case nation of nation_american :
96109: LD_VAR 0 5
96113: PUSH
96114: LD_INT 1
96116: DOUBLE
96117: EQUAL
96118: IFTRUE 96122
96120: GO 96178
96122: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
96123: LD_ADDR_VAR 0 9
96127: PUSH
96128: LD_VAR 0 11
96132: PUSH
96133: LD_VAR 0 12
96137: PUSH
96138: LD_VAR 0 13
96142: PUSH
96143: LD_VAR 0 14
96147: PUSH
96148: LD_VAR 0 15
96152: PUSH
96153: LD_VAR 0 16
96157: PUSH
96158: EMPTY
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: PUSH
96166: LD_VAR 0 4
96170: PUSH
96171: LD_INT 1
96173: PLUS
96174: ARRAY
96175: ST_TO_ADDR
96176: GO 96307
96178: LD_INT 2
96180: DOUBLE
96181: EQUAL
96182: IFTRUE 96186
96184: GO 96242
96186: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
96187: LD_ADDR_VAR 0 9
96191: PUSH
96192: LD_VAR 0 17
96196: PUSH
96197: LD_VAR 0 18
96201: PUSH
96202: LD_VAR 0 19
96206: PUSH
96207: LD_VAR 0 20
96211: PUSH
96212: LD_VAR 0 21
96216: PUSH
96217: LD_VAR 0 22
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: PUSH
96230: LD_VAR 0 4
96234: PUSH
96235: LD_INT 1
96237: PLUS
96238: ARRAY
96239: ST_TO_ADDR
96240: GO 96307
96242: LD_INT 3
96244: DOUBLE
96245: EQUAL
96246: IFTRUE 96250
96248: GO 96306
96250: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96251: LD_ADDR_VAR 0 9
96255: PUSH
96256: LD_VAR 0 23
96260: PUSH
96261: LD_VAR 0 24
96265: PUSH
96266: LD_VAR 0 25
96270: PUSH
96271: LD_VAR 0 26
96275: PUSH
96276: LD_VAR 0 27
96280: PUSH
96281: LD_VAR 0 28
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: PUSH
96294: LD_VAR 0 4
96298: PUSH
96299: LD_INT 1
96301: PLUS
96302: ARRAY
96303: ST_TO_ADDR
96304: GO 96307
96306: POP
96307: GO 96862
96309: LD_INT 2
96311: DOUBLE
96312: EQUAL
96313: IFTRUE 96323
96315: LD_INT 3
96317: DOUBLE
96318: EQUAL
96319: IFTRUE 96323
96321: GO 96379
96323: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96324: LD_ADDR_VAR 0 9
96328: PUSH
96329: LD_VAR 0 29
96333: PUSH
96334: LD_VAR 0 30
96338: PUSH
96339: LD_VAR 0 31
96343: PUSH
96344: LD_VAR 0 32
96348: PUSH
96349: LD_VAR 0 33
96353: PUSH
96354: LD_VAR 0 34
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: PUSH
96367: LD_VAR 0 4
96371: PUSH
96372: LD_INT 1
96374: PLUS
96375: ARRAY
96376: ST_TO_ADDR
96377: GO 96862
96379: LD_INT 16
96381: DOUBLE
96382: EQUAL
96383: IFTRUE 96441
96385: LD_INT 17
96387: DOUBLE
96388: EQUAL
96389: IFTRUE 96441
96391: LD_INT 18
96393: DOUBLE
96394: EQUAL
96395: IFTRUE 96441
96397: LD_INT 19
96399: DOUBLE
96400: EQUAL
96401: IFTRUE 96441
96403: LD_INT 22
96405: DOUBLE
96406: EQUAL
96407: IFTRUE 96441
96409: LD_INT 20
96411: DOUBLE
96412: EQUAL
96413: IFTRUE 96441
96415: LD_INT 21
96417: DOUBLE
96418: EQUAL
96419: IFTRUE 96441
96421: LD_INT 23
96423: DOUBLE
96424: EQUAL
96425: IFTRUE 96441
96427: LD_INT 24
96429: DOUBLE
96430: EQUAL
96431: IFTRUE 96441
96433: LD_INT 25
96435: DOUBLE
96436: EQUAL
96437: IFTRUE 96441
96439: GO 96497
96441: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96442: LD_ADDR_VAR 0 9
96446: PUSH
96447: LD_VAR 0 35
96451: PUSH
96452: LD_VAR 0 36
96456: PUSH
96457: LD_VAR 0 37
96461: PUSH
96462: LD_VAR 0 38
96466: PUSH
96467: LD_VAR 0 39
96471: PUSH
96472: LD_VAR 0 40
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: PUSH
96485: LD_VAR 0 4
96489: PUSH
96490: LD_INT 1
96492: PLUS
96493: ARRAY
96494: ST_TO_ADDR
96495: GO 96862
96497: LD_INT 6
96499: DOUBLE
96500: EQUAL
96501: IFTRUE 96553
96503: LD_INT 7
96505: DOUBLE
96506: EQUAL
96507: IFTRUE 96553
96509: LD_INT 8
96511: DOUBLE
96512: EQUAL
96513: IFTRUE 96553
96515: LD_INT 13
96517: DOUBLE
96518: EQUAL
96519: IFTRUE 96553
96521: LD_INT 12
96523: DOUBLE
96524: EQUAL
96525: IFTRUE 96553
96527: LD_INT 15
96529: DOUBLE
96530: EQUAL
96531: IFTRUE 96553
96533: LD_INT 11
96535: DOUBLE
96536: EQUAL
96537: IFTRUE 96553
96539: LD_INT 14
96541: DOUBLE
96542: EQUAL
96543: IFTRUE 96553
96545: LD_INT 10
96547: DOUBLE
96548: EQUAL
96549: IFTRUE 96553
96551: GO 96609
96553: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
96554: LD_ADDR_VAR 0 9
96558: PUSH
96559: LD_VAR 0 41
96563: PUSH
96564: LD_VAR 0 42
96568: PUSH
96569: LD_VAR 0 43
96573: PUSH
96574: LD_VAR 0 44
96578: PUSH
96579: LD_VAR 0 45
96583: PUSH
96584: LD_VAR 0 46
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: PUSH
96597: LD_VAR 0 4
96601: PUSH
96602: LD_INT 1
96604: PLUS
96605: ARRAY
96606: ST_TO_ADDR
96607: GO 96862
96609: LD_INT 36
96611: DOUBLE
96612: EQUAL
96613: IFTRUE 96617
96615: GO 96673
96617: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96618: LD_ADDR_VAR 0 9
96622: PUSH
96623: LD_VAR 0 47
96627: PUSH
96628: LD_VAR 0 48
96632: PUSH
96633: LD_VAR 0 49
96637: PUSH
96638: LD_VAR 0 50
96642: PUSH
96643: LD_VAR 0 51
96647: PUSH
96648: LD_VAR 0 52
96652: PUSH
96653: EMPTY
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: PUSH
96661: LD_VAR 0 4
96665: PUSH
96666: LD_INT 1
96668: PLUS
96669: ARRAY
96670: ST_TO_ADDR
96671: GO 96862
96673: LD_INT 4
96675: DOUBLE
96676: EQUAL
96677: IFTRUE 96699
96679: LD_INT 5
96681: DOUBLE
96682: EQUAL
96683: IFTRUE 96699
96685: LD_INT 34
96687: DOUBLE
96688: EQUAL
96689: IFTRUE 96699
96691: LD_INT 37
96693: DOUBLE
96694: EQUAL
96695: IFTRUE 96699
96697: GO 96755
96699: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96700: LD_ADDR_VAR 0 9
96704: PUSH
96705: LD_VAR 0 53
96709: PUSH
96710: LD_VAR 0 54
96714: PUSH
96715: LD_VAR 0 55
96719: PUSH
96720: LD_VAR 0 56
96724: PUSH
96725: LD_VAR 0 57
96729: PUSH
96730: LD_VAR 0 58
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: PUSH
96743: LD_VAR 0 4
96747: PUSH
96748: LD_INT 1
96750: PLUS
96751: ARRAY
96752: ST_TO_ADDR
96753: GO 96862
96755: LD_INT 31
96757: DOUBLE
96758: EQUAL
96759: IFTRUE 96805
96761: LD_INT 32
96763: DOUBLE
96764: EQUAL
96765: IFTRUE 96805
96767: LD_INT 33
96769: DOUBLE
96770: EQUAL
96771: IFTRUE 96805
96773: LD_INT 27
96775: DOUBLE
96776: EQUAL
96777: IFTRUE 96805
96779: LD_INT 26
96781: DOUBLE
96782: EQUAL
96783: IFTRUE 96805
96785: LD_INT 28
96787: DOUBLE
96788: EQUAL
96789: IFTRUE 96805
96791: LD_INT 29
96793: DOUBLE
96794: EQUAL
96795: IFTRUE 96805
96797: LD_INT 30
96799: DOUBLE
96800: EQUAL
96801: IFTRUE 96805
96803: GO 96861
96805: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
96806: LD_ADDR_VAR 0 9
96810: PUSH
96811: LD_VAR 0 59
96815: PUSH
96816: LD_VAR 0 60
96820: PUSH
96821: LD_VAR 0 61
96825: PUSH
96826: LD_VAR 0 62
96830: PUSH
96831: LD_VAR 0 63
96835: PUSH
96836: LD_VAR 0 64
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: PUSH
96849: LD_VAR 0 4
96853: PUSH
96854: LD_INT 1
96856: PLUS
96857: ARRAY
96858: ST_TO_ADDR
96859: GO 96862
96861: POP
// temp_list2 = [ ] ;
96862: LD_ADDR_VAR 0 10
96866: PUSH
96867: EMPTY
96868: ST_TO_ADDR
// for i in temp_list do
96869: LD_ADDR_VAR 0 8
96873: PUSH
96874: LD_VAR 0 9
96878: PUSH
96879: FOR_IN
96880: IFFALSE 96932
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96882: LD_ADDR_VAR 0 10
96886: PUSH
96887: LD_VAR 0 10
96891: PUSH
96892: LD_VAR 0 8
96896: PUSH
96897: LD_INT 1
96899: ARRAY
96900: PUSH
96901: LD_VAR 0 2
96905: PLUS
96906: PUSH
96907: LD_VAR 0 8
96911: PUSH
96912: LD_INT 2
96914: ARRAY
96915: PUSH
96916: LD_VAR 0 3
96920: PLUS
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: EMPTY
96927: LIST
96928: ADD
96929: ST_TO_ADDR
96930: GO 96879
96932: POP
96933: POP
// result = temp_list2 ;
96934: LD_ADDR_VAR 0 7
96938: PUSH
96939: LD_VAR 0 10
96943: ST_TO_ADDR
// end ;
96944: LD_VAR 0 7
96948: RET
// export function EnemyInRange ( unit , dist ) ; begin
96949: LD_INT 0
96951: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96952: LD_ADDR_VAR 0 3
96956: PUSH
96957: LD_VAR 0 1
96961: PPUSH
96962: CALL_OW 255
96966: PPUSH
96967: LD_VAR 0 1
96971: PPUSH
96972: CALL_OW 250
96976: PPUSH
96977: LD_VAR 0 1
96981: PPUSH
96982: CALL_OW 251
96986: PPUSH
96987: LD_VAR 0 2
96991: PPUSH
96992: CALL 71053 0 4
96996: PUSH
96997: LD_INT 4
96999: ARRAY
97000: ST_TO_ADDR
// end ;
97001: LD_VAR 0 3
97005: RET
// export function PlayerSeeMe ( unit ) ; begin
97006: LD_INT 0
97008: PPUSH
// result := See ( your_side , unit ) ;
97009: LD_ADDR_VAR 0 2
97013: PUSH
97014: LD_OWVAR 2
97018: PPUSH
97019: LD_VAR 0 1
97023: PPUSH
97024: CALL_OW 292
97028: ST_TO_ADDR
// end ;
97029: LD_VAR 0 2
97033: RET
// export function ReverseDir ( unit ) ; begin
97034: LD_INT 0
97036: PPUSH
// if not unit then
97037: LD_VAR 0 1
97041: NOT
97042: IFFALSE 97046
// exit ;
97044: GO 97069
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
97046: LD_ADDR_VAR 0 2
97050: PUSH
97051: LD_VAR 0 1
97055: PPUSH
97056: CALL_OW 254
97060: PUSH
97061: LD_INT 3
97063: PLUS
97064: PUSH
97065: LD_INT 6
97067: MOD
97068: ST_TO_ADDR
// end ;
97069: LD_VAR 0 2
97073: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
97074: LD_INT 0
97076: PPUSH
97077: PPUSH
97078: PPUSH
97079: PPUSH
97080: PPUSH
// if not hexes then
97081: LD_VAR 0 2
97085: NOT
97086: IFFALSE 97090
// exit ;
97088: GO 97238
// dist := 9999 ;
97090: LD_ADDR_VAR 0 5
97094: PUSH
97095: LD_INT 9999
97097: ST_TO_ADDR
// for i = 1 to hexes do
97098: LD_ADDR_VAR 0 4
97102: PUSH
97103: DOUBLE
97104: LD_INT 1
97106: DEC
97107: ST_TO_ADDR
97108: LD_VAR 0 2
97112: PUSH
97113: FOR_TO
97114: IFFALSE 97226
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97116: LD_VAR 0 1
97120: PPUSH
97121: LD_VAR 0 2
97125: PUSH
97126: LD_VAR 0 4
97130: ARRAY
97131: PUSH
97132: LD_INT 1
97134: ARRAY
97135: PPUSH
97136: LD_VAR 0 2
97140: PUSH
97141: LD_VAR 0 4
97145: ARRAY
97146: PUSH
97147: LD_INT 2
97149: ARRAY
97150: PPUSH
97151: CALL_OW 297
97155: PUSH
97156: LD_VAR 0 5
97160: LESS
97161: IFFALSE 97224
// begin hex := hexes [ i ] ;
97163: LD_ADDR_VAR 0 7
97167: PUSH
97168: LD_VAR 0 2
97172: PUSH
97173: LD_VAR 0 4
97177: ARRAY
97178: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97179: LD_ADDR_VAR 0 5
97183: PUSH
97184: LD_VAR 0 1
97188: PPUSH
97189: LD_VAR 0 2
97193: PUSH
97194: LD_VAR 0 4
97198: ARRAY
97199: PUSH
97200: LD_INT 1
97202: ARRAY
97203: PPUSH
97204: LD_VAR 0 2
97208: PUSH
97209: LD_VAR 0 4
97213: ARRAY
97214: PUSH
97215: LD_INT 2
97217: ARRAY
97218: PPUSH
97219: CALL_OW 297
97223: ST_TO_ADDR
// end ; end ;
97224: GO 97113
97226: POP
97227: POP
// result := hex ;
97228: LD_ADDR_VAR 0 3
97232: PUSH
97233: LD_VAR 0 7
97237: ST_TO_ADDR
// end ;
97238: LD_VAR 0 3
97242: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97243: LD_INT 0
97245: PPUSH
97246: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97247: LD_VAR 0 1
97251: NOT
97252: PUSH
97253: LD_VAR 0 1
97257: PUSH
97258: LD_INT 21
97260: PUSH
97261: LD_INT 2
97263: PUSH
97264: EMPTY
97265: LIST
97266: LIST
97267: PUSH
97268: LD_INT 23
97270: PUSH
97271: LD_INT 2
97273: PUSH
97274: EMPTY
97275: LIST
97276: LIST
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: PPUSH
97282: CALL_OW 69
97286: IN
97287: NOT
97288: OR
97289: IFFALSE 97293
// exit ;
97291: GO 97340
// for i = 1 to 3 do
97293: LD_ADDR_VAR 0 3
97297: PUSH
97298: DOUBLE
97299: LD_INT 1
97301: DEC
97302: ST_TO_ADDR
97303: LD_INT 3
97305: PUSH
97306: FOR_TO
97307: IFFALSE 97338
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97309: LD_VAR 0 1
97313: PPUSH
97314: CALL_OW 250
97318: PPUSH
97319: LD_VAR 0 1
97323: PPUSH
97324: CALL_OW 251
97328: PPUSH
97329: LD_INT 1
97331: PPUSH
97332: CALL_OW 453
97336: GO 97306
97338: POP
97339: POP
// end ;
97340: LD_VAR 0 2
97344: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97345: LD_INT 0
97347: PPUSH
97348: PPUSH
97349: PPUSH
97350: PPUSH
97351: PPUSH
97352: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97353: LD_VAR 0 1
97357: NOT
97358: PUSH
97359: LD_VAR 0 2
97363: NOT
97364: OR
97365: PUSH
97366: LD_VAR 0 1
97370: PPUSH
97371: CALL_OW 314
97375: OR
97376: IFFALSE 97380
// exit ;
97378: GO 97821
// x := GetX ( enemy_unit ) ;
97380: LD_ADDR_VAR 0 7
97384: PUSH
97385: LD_VAR 0 2
97389: PPUSH
97390: CALL_OW 250
97394: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97395: LD_ADDR_VAR 0 8
97399: PUSH
97400: LD_VAR 0 2
97404: PPUSH
97405: CALL_OW 251
97409: ST_TO_ADDR
// if not x or not y then
97410: LD_VAR 0 7
97414: NOT
97415: PUSH
97416: LD_VAR 0 8
97420: NOT
97421: OR
97422: IFFALSE 97426
// exit ;
97424: GO 97821
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97426: LD_ADDR_VAR 0 6
97430: PUSH
97431: LD_VAR 0 7
97435: PPUSH
97436: LD_INT 0
97438: PPUSH
97439: LD_INT 4
97441: PPUSH
97442: CALL_OW 272
97446: PUSH
97447: LD_VAR 0 8
97451: PPUSH
97452: LD_INT 0
97454: PPUSH
97455: LD_INT 4
97457: PPUSH
97458: CALL_OW 273
97462: PUSH
97463: EMPTY
97464: LIST
97465: LIST
97466: PUSH
97467: LD_VAR 0 7
97471: PPUSH
97472: LD_INT 1
97474: PPUSH
97475: LD_INT 4
97477: PPUSH
97478: CALL_OW 272
97482: PUSH
97483: LD_VAR 0 8
97487: PPUSH
97488: LD_INT 1
97490: PPUSH
97491: LD_INT 4
97493: PPUSH
97494: CALL_OW 273
97498: PUSH
97499: EMPTY
97500: LIST
97501: LIST
97502: PUSH
97503: LD_VAR 0 7
97507: PPUSH
97508: LD_INT 2
97510: PPUSH
97511: LD_INT 4
97513: PPUSH
97514: CALL_OW 272
97518: PUSH
97519: LD_VAR 0 8
97523: PPUSH
97524: LD_INT 2
97526: PPUSH
97527: LD_INT 4
97529: PPUSH
97530: CALL_OW 273
97534: PUSH
97535: EMPTY
97536: LIST
97537: LIST
97538: PUSH
97539: LD_VAR 0 7
97543: PPUSH
97544: LD_INT 3
97546: PPUSH
97547: LD_INT 4
97549: PPUSH
97550: CALL_OW 272
97554: PUSH
97555: LD_VAR 0 8
97559: PPUSH
97560: LD_INT 3
97562: PPUSH
97563: LD_INT 4
97565: PPUSH
97566: CALL_OW 273
97570: PUSH
97571: EMPTY
97572: LIST
97573: LIST
97574: PUSH
97575: LD_VAR 0 7
97579: PPUSH
97580: LD_INT 4
97582: PPUSH
97583: LD_INT 4
97585: PPUSH
97586: CALL_OW 272
97590: PUSH
97591: LD_VAR 0 8
97595: PPUSH
97596: LD_INT 4
97598: PPUSH
97599: LD_INT 4
97601: PPUSH
97602: CALL_OW 273
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: PUSH
97611: LD_VAR 0 7
97615: PPUSH
97616: LD_INT 5
97618: PPUSH
97619: LD_INT 4
97621: PPUSH
97622: CALL_OW 272
97626: PUSH
97627: LD_VAR 0 8
97631: PPUSH
97632: LD_INT 5
97634: PPUSH
97635: LD_INT 4
97637: PPUSH
97638: CALL_OW 273
97642: PUSH
97643: EMPTY
97644: LIST
97645: LIST
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: ST_TO_ADDR
// for i = tmp downto 1 do
97655: LD_ADDR_VAR 0 4
97659: PUSH
97660: DOUBLE
97661: LD_VAR 0 6
97665: INC
97666: ST_TO_ADDR
97667: LD_INT 1
97669: PUSH
97670: FOR_DOWNTO
97671: IFFALSE 97772
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97673: LD_VAR 0 6
97677: PUSH
97678: LD_VAR 0 4
97682: ARRAY
97683: PUSH
97684: LD_INT 1
97686: ARRAY
97687: PPUSH
97688: LD_VAR 0 6
97692: PUSH
97693: LD_VAR 0 4
97697: ARRAY
97698: PUSH
97699: LD_INT 2
97701: ARRAY
97702: PPUSH
97703: CALL_OW 488
97707: NOT
97708: PUSH
97709: LD_VAR 0 6
97713: PUSH
97714: LD_VAR 0 4
97718: ARRAY
97719: PUSH
97720: LD_INT 1
97722: ARRAY
97723: PPUSH
97724: LD_VAR 0 6
97728: PUSH
97729: LD_VAR 0 4
97733: ARRAY
97734: PUSH
97735: LD_INT 2
97737: ARRAY
97738: PPUSH
97739: CALL_OW 428
97743: PUSH
97744: LD_INT 0
97746: NONEQUAL
97747: OR
97748: IFFALSE 97770
// tmp := Delete ( tmp , i ) ;
97750: LD_ADDR_VAR 0 6
97754: PUSH
97755: LD_VAR 0 6
97759: PPUSH
97760: LD_VAR 0 4
97764: PPUSH
97765: CALL_OW 3
97769: ST_TO_ADDR
97770: GO 97670
97772: POP
97773: POP
// j := GetClosestHex ( unit , tmp ) ;
97774: LD_ADDR_VAR 0 5
97778: PUSH
97779: LD_VAR 0 1
97783: PPUSH
97784: LD_VAR 0 6
97788: PPUSH
97789: CALL 97074 0 2
97793: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97794: LD_VAR 0 1
97798: PPUSH
97799: LD_VAR 0 5
97803: PUSH
97804: LD_INT 1
97806: ARRAY
97807: PPUSH
97808: LD_VAR 0 5
97812: PUSH
97813: LD_INT 2
97815: ARRAY
97816: PPUSH
97817: CALL_OW 111
// end ;
97821: LD_VAR 0 3
97825: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97826: LD_INT 0
97828: PPUSH
97829: PPUSH
97830: PPUSH
// uc_side = 0 ;
97831: LD_ADDR_OWVAR 20
97835: PUSH
97836: LD_INT 0
97838: ST_TO_ADDR
// uc_nation = 0 ;
97839: LD_ADDR_OWVAR 21
97843: PUSH
97844: LD_INT 0
97846: ST_TO_ADDR
// InitHc_All ( ) ;
97847: CALL_OW 584
// InitVc ;
97851: CALL_OW 20
// if mastodonts then
97855: LD_VAR 0 6
97859: IFFALSE 97926
// for i = 1 to mastodonts do
97861: LD_ADDR_VAR 0 11
97865: PUSH
97866: DOUBLE
97867: LD_INT 1
97869: DEC
97870: ST_TO_ADDR
97871: LD_VAR 0 6
97875: PUSH
97876: FOR_TO
97877: IFFALSE 97924
// begin vc_chassis := 31 ;
97879: LD_ADDR_OWVAR 37
97883: PUSH
97884: LD_INT 31
97886: ST_TO_ADDR
// vc_control := control_rider ;
97887: LD_ADDR_OWVAR 38
97891: PUSH
97892: LD_INT 4
97894: ST_TO_ADDR
// animal := CreateVehicle ;
97895: LD_ADDR_VAR 0 12
97899: PUSH
97900: CALL_OW 45
97904: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97905: LD_VAR 0 12
97909: PPUSH
97910: LD_VAR 0 8
97914: PPUSH
97915: LD_INT 0
97917: PPUSH
97918: CALL 100114 0 3
// end ;
97922: GO 97876
97924: POP
97925: POP
// if horses then
97926: LD_VAR 0 5
97930: IFFALSE 97997
// for i = 1 to horses do
97932: LD_ADDR_VAR 0 11
97936: PUSH
97937: DOUBLE
97938: LD_INT 1
97940: DEC
97941: ST_TO_ADDR
97942: LD_VAR 0 5
97946: PUSH
97947: FOR_TO
97948: IFFALSE 97995
// begin hc_class := 21 ;
97950: LD_ADDR_OWVAR 28
97954: PUSH
97955: LD_INT 21
97957: ST_TO_ADDR
// hc_gallery :=  ;
97958: LD_ADDR_OWVAR 33
97962: PUSH
97963: LD_STRING 
97965: ST_TO_ADDR
// animal := CreateHuman ;
97966: LD_ADDR_VAR 0 12
97970: PUSH
97971: CALL_OW 44
97975: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97976: LD_VAR 0 12
97980: PPUSH
97981: LD_VAR 0 8
97985: PPUSH
97986: LD_INT 0
97988: PPUSH
97989: CALL 100114 0 3
// end ;
97993: GO 97947
97995: POP
97996: POP
// if birds then
97997: LD_VAR 0 1
98001: IFFALSE 98068
// for i = 1 to birds do
98003: LD_ADDR_VAR 0 11
98007: PUSH
98008: DOUBLE
98009: LD_INT 1
98011: DEC
98012: ST_TO_ADDR
98013: LD_VAR 0 1
98017: PUSH
98018: FOR_TO
98019: IFFALSE 98066
// begin hc_class = 18 ;
98021: LD_ADDR_OWVAR 28
98025: PUSH
98026: LD_INT 18
98028: ST_TO_ADDR
// hc_gallery =  ;
98029: LD_ADDR_OWVAR 33
98033: PUSH
98034: LD_STRING 
98036: ST_TO_ADDR
// animal := CreateHuman ;
98037: LD_ADDR_VAR 0 12
98041: PUSH
98042: CALL_OW 44
98046: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98047: LD_VAR 0 12
98051: PPUSH
98052: LD_VAR 0 8
98056: PPUSH
98057: LD_INT 0
98059: PPUSH
98060: CALL 100114 0 3
// end ;
98064: GO 98018
98066: POP
98067: POP
// if tigers then
98068: LD_VAR 0 2
98072: IFFALSE 98156
// for i = 1 to tigers do
98074: LD_ADDR_VAR 0 11
98078: PUSH
98079: DOUBLE
98080: LD_INT 1
98082: DEC
98083: ST_TO_ADDR
98084: LD_VAR 0 2
98088: PUSH
98089: FOR_TO
98090: IFFALSE 98154
// begin hc_class = class_tiger ;
98092: LD_ADDR_OWVAR 28
98096: PUSH
98097: LD_INT 14
98099: ST_TO_ADDR
// hc_gallery =  ;
98100: LD_ADDR_OWVAR 33
98104: PUSH
98105: LD_STRING 
98107: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98108: LD_ADDR_OWVAR 35
98112: PUSH
98113: LD_INT 7
98115: NEG
98116: PPUSH
98117: LD_INT 7
98119: PPUSH
98120: CALL_OW 12
98124: ST_TO_ADDR
// animal := CreateHuman ;
98125: LD_ADDR_VAR 0 12
98129: PUSH
98130: CALL_OW 44
98134: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98135: LD_VAR 0 12
98139: PPUSH
98140: LD_VAR 0 8
98144: PPUSH
98145: LD_INT 0
98147: PPUSH
98148: CALL 100114 0 3
// end ;
98152: GO 98089
98154: POP
98155: POP
// if apemans then
98156: LD_VAR 0 3
98160: IFFALSE 98283
// for i = 1 to apemans do
98162: LD_ADDR_VAR 0 11
98166: PUSH
98167: DOUBLE
98168: LD_INT 1
98170: DEC
98171: ST_TO_ADDR
98172: LD_VAR 0 3
98176: PUSH
98177: FOR_TO
98178: IFFALSE 98281
// begin hc_class = class_apeman ;
98180: LD_ADDR_OWVAR 28
98184: PUSH
98185: LD_INT 12
98187: ST_TO_ADDR
// hc_gallery =  ;
98188: LD_ADDR_OWVAR 33
98192: PUSH
98193: LD_STRING 
98195: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98196: LD_ADDR_OWVAR 35
98200: PUSH
98201: LD_INT 5
98203: NEG
98204: PPUSH
98205: LD_INT 5
98207: PPUSH
98208: CALL_OW 12
98212: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98213: LD_ADDR_OWVAR 31
98217: PUSH
98218: LD_INT 1
98220: PPUSH
98221: LD_INT 3
98223: PPUSH
98224: CALL_OW 12
98228: PUSH
98229: LD_INT 1
98231: PPUSH
98232: LD_INT 3
98234: PPUSH
98235: CALL_OW 12
98239: PUSH
98240: LD_INT 0
98242: PUSH
98243: LD_INT 0
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: ST_TO_ADDR
// animal := CreateHuman ;
98252: LD_ADDR_VAR 0 12
98256: PUSH
98257: CALL_OW 44
98261: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98262: LD_VAR 0 12
98266: PPUSH
98267: LD_VAR 0 8
98271: PPUSH
98272: LD_INT 0
98274: PPUSH
98275: CALL 100114 0 3
// end ;
98279: GO 98177
98281: POP
98282: POP
// if enchidnas then
98283: LD_VAR 0 4
98287: IFFALSE 98354
// for i = 1 to enchidnas do
98289: LD_ADDR_VAR 0 11
98293: PUSH
98294: DOUBLE
98295: LD_INT 1
98297: DEC
98298: ST_TO_ADDR
98299: LD_VAR 0 4
98303: PUSH
98304: FOR_TO
98305: IFFALSE 98352
// begin hc_class = 13 ;
98307: LD_ADDR_OWVAR 28
98311: PUSH
98312: LD_INT 13
98314: ST_TO_ADDR
// hc_gallery =  ;
98315: LD_ADDR_OWVAR 33
98319: PUSH
98320: LD_STRING 
98322: ST_TO_ADDR
// animal := CreateHuman ;
98323: LD_ADDR_VAR 0 12
98327: PUSH
98328: CALL_OW 44
98332: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98333: LD_VAR 0 12
98337: PPUSH
98338: LD_VAR 0 8
98342: PPUSH
98343: LD_INT 0
98345: PPUSH
98346: CALL 100114 0 3
// end ;
98350: GO 98304
98352: POP
98353: POP
// if fishes then
98354: LD_VAR 0 7
98358: IFFALSE 98425
// for i = 1 to fishes do
98360: LD_ADDR_VAR 0 11
98364: PUSH
98365: DOUBLE
98366: LD_INT 1
98368: DEC
98369: ST_TO_ADDR
98370: LD_VAR 0 7
98374: PUSH
98375: FOR_TO
98376: IFFALSE 98423
// begin hc_class = 20 ;
98378: LD_ADDR_OWVAR 28
98382: PUSH
98383: LD_INT 20
98385: ST_TO_ADDR
// hc_gallery =  ;
98386: LD_ADDR_OWVAR 33
98390: PUSH
98391: LD_STRING 
98393: ST_TO_ADDR
// animal := CreateHuman ;
98394: LD_ADDR_VAR 0 12
98398: PUSH
98399: CALL_OW 44
98403: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98404: LD_VAR 0 12
98408: PPUSH
98409: LD_VAR 0 9
98413: PPUSH
98414: LD_INT 0
98416: PPUSH
98417: CALL 100114 0 3
// end ;
98421: GO 98375
98423: POP
98424: POP
// end ;
98425: LD_VAR 0 10
98429: RET
// export function WantHeal ( sci , unit ) ; begin
98430: LD_INT 0
98432: PPUSH
// if GetTaskList ( sci ) > 0 then
98433: LD_VAR 0 1
98437: PPUSH
98438: CALL_OW 437
98442: PUSH
98443: LD_INT 0
98445: GREATER
98446: IFFALSE 98516
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98448: LD_VAR 0 1
98452: PPUSH
98453: CALL_OW 437
98457: PUSH
98458: LD_INT 1
98460: ARRAY
98461: PUSH
98462: LD_INT 1
98464: ARRAY
98465: PUSH
98466: LD_STRING l
98468: EQUAL
98469: PUSH
98470: LD_VAR 0 1
98474: PPUSH
98475: CALL_OW 437
98479: PUSH
98480: LD_INT 1
98482: ARRAY
98483: PUSH
98484: LD_INT 4
98486: ARRAY
98487: PUSH
98488: LD_VAR 0 2
98492: EQUAL
98493: AND
98494: IFFALSE 98506
// result := true else
98496: LD_ADDR_VAR 0 3
98500: PUSH
98501: LD_INT 1
98503: ST_TO_ADDR
98504: GO 98514
// result := false ;
98506: LD_ADDR_VAR 0 3
98510: PUSH
98511: LD_INT 0
98513: ST_TO_ADDR
// end else
98514: GO 98524
// result := false ;
98516: LD_ADDR_VAR 0 3
98520: PUSH
98521: LD_INT 0
98523: ST_TO_ADDR
// end ;
98524: LD_VAR 0 3
98528: RET
// export function HealTarget ( sci ) ; begin
98529: LD_INT 0
98531: PPUSH
// if not sci then
98532: LD_VAR 0 1
98536: NOT
98537: IFFALSE 98541
// exit ;
98539: GO 98606
// result := 0 ;
98541: LD_ADDR_VAR 0 2
98545: PUSH
98546: LD_INT 0
98548: ST_TO_ADDR
// if GetTaskList ( sci ) then
98549: LD_VAR 0 1
98553: PPUSH
98554: CALL_OW 437
98558: IFFALSE 98606
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98560: LD_VAR 0 1
98564: PPUSH
98565: CALL_OW 437
98569: PUSH
98570: LD_INT 1
98572: ARRAY
98573: PUSH
98574: LD_INT 1
98576: ARRAY
98577: PUSH
98578: LD_STRING l
98580: EQUAL
98581: IFFALSE 98606
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98583: LD_ADDR_VAR 0 2
98587: PUSH
98588: LD_VAR 0 1
98592: PPUSH
98593: CALL_OW 437
98597: PUSH
98598: LD_INT 1
98600: ARRAY
98601: PUSH
98602: LD_INT 4
98604: ARRAY
98605: ST_TO_ADDR
// end ;
98606: LD_VAR 0 2
98610: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98611: LD_INT 0
98613: PPUSH
98614: PPUSH
98615: PPUSH
98616: PPUSH
// if not base_units then
98617: LD_VAR 0 1
98621: NOT
98622: IFFALSE 98626
// exit ;
98624: GO 98713
// result := false ;
98626: LD_ADDR_VAR 0 2
98630: PUSH
98631: LD_INT 0
98633: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98634: LD_ADDR_VAR 0 5
98638: PUSH
98639: LD_VAR 0 1
98643: PPUSH
98644: LD_INT 21
98646: PUSH
98647: LD_INT 3
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PPUSH
98654: CALL_OW 72
98658: ST_TO_ADDR
// if not tmp then
98659: LD_VAR 0 5
98663: NOT
98664: IFFALSE 98668
// exit ;
98666: GO 98713
// for i in tmp do
98668: LD_ADDR_VAR 0 3
98672: PUSH
98673: LD_VAR 0 5
98677: PUSH
98678: FOR_IN
98679: IFFALSE 98711
// begin result := EnemyInRange ( i , 22 ) ;
98681: LD_ADDR_VAR 0 2
98685: PUSH
98686: LD_VAR 0 3
98690: PPUSH
98691: LD_INT 22
98693: PPUSH
98694: CALL 96949 0 2
98698: ST_TO_ADDR
// if result then
98699: LD_VAR 0 2
98703: IFFALSE 98709
// exit ;
98705: POP
98706: POP
98707: GO 98713
// end ;
98709: GO 98678
98711: POP
98712: POP
// end ;
98713: LD_VAR 0 2
98717: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98718: LD_INT 0
98720: PPUSH
98721: PPUSH
// if not units then
98722: LD_VAR 0 1
98726: NOT
98727: IFFALSE 98731
// exit ;
98729: GO 98801
// result := [ ] ;
98731: LD_ADDR_VAR 0 3
98735: PUSH
98736: EMPTY
98737: ST_TO_ADDR
// for i in units do
98738: LD_ADDR_VAR 0 4
98742: PUSH
98743: LD_VAR 0 1
98747: PUSH
98748: FOR_IN
98749: IFFALSE 98799
// if GetTag ( i ) = tag then
98751: LD_VAR 0 4
98755: PPUSH
98756: CALL_OW 110
98760: PUSH
98761: LD_VAR 0 2
98765: EQUAL
98766: IFFALSE 98797
// result := Insert ( result , result + 1 , i ) ;
98768: LD_ADDR_VAR 0 3
98772: PUSH
98773: LD_VAR 0 3
98777: PPUSH
98778: LD_VAR 0 3
98782: PUSH
98783: LD_INT 1
98785: PLUS
98786: PPUSH
98787: LD_VAR 0 4
98791: PPUSH
98792: CALL_OW 2
98796: ST_TO_ADDR
98797: GO 98748
98799: POP
98800: POP
// end ;
98801: LD_VAR 0 3
98805: RET
// export function IsDriver ( un ) ; begin
98806: LD_INT 0
98808: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98809: LD_ADDR_VAR 0 2
98813: PUSH
98814: LD_VAR 0 1
98818: PUSH
98819: LD_INT 55
98821: PUSH
98822: EMPTY
98823: LIST
98824: PPUSH
98825: CALL_OW 69
98829: IN
98830: ST_TO_ADDR
// end ;
98831: LD_VAR 0 2
98835: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98836: LD_INT 0
98838: PPUSH
98839: PPUSH
// list := [ ] ;
98840: LD_ADDR_VAR 0 5
98844: PUSH
98845: EMPTY
98846: ST_TO_ADDR
// case d of 0 :
98847: LD_VAR 0 3
98851: PUSH
98852: LD_INT 0
98854: DOUBLE
98855: EQUAL
98856: IFTRUE 98860
98858: GO 98993
98860: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98861: LD_ADDR_VAR 0 5
98865: PUSH
98866: LD_VAR 0 1
98870: PUSH
98871: LD_INT 4
98873: MINUS
98874: PUSH
98875: LD_VAR 0 2
98879: PUSH
98880: LD_INT 4
98882: MINUS
98883: PUSH
98884: LD_INT 2
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: LIST
98891: PUSH
98892: LD_VAR 0 1
98896: PUSH
98897: LD_INT 3
98899: MINUS
98900: PUSH
98901: LD_VAR 0 2
98905: PUSH
98906: LD_INT 1
98908: PUSH
98909: EMPTY
98910: LIST
98911: LIST
98912: LIST
98913: PUSH
98914: LD_VAR 0 1
98918: PUSH
98919: LD_INT 4
98921: PLUS
98922: PUSH
98923: LD_VAR 0 2
98927: PUSH
98928: LD_INT 4
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: LIST
98935: PUSH
98936: LD_VAR 0 1
98940: PUSH
98941: LD_INT 3
98943: PLUS
98944: PUSH
98945: LD_VAR 0 2
98949: PUSH
98950: LD_INT 3
98952: PLUS
98953: PUSH
98954: LD_INT 5
98956: PUSH
98957: EMPTY
98958: LIST
98959: LIST
98960: LIST
98961: PUSH
98962: LD_VAR 0 1
98966: PUSH
98967: LD_VAR 0 2
98971: PUSH
98972: LD_INT 4
98974: PLUS
98975: PUSH
98976: LD_INT 0
98978: PUSH
98979: EMPTY
98980: LIST
98981: LIST
98982: LIST
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: ST_TO_ADDR
// end ; 1 :
98991: GO 99691
98993: LD_INT 1
98995: DOUBLE
98996: EQUAL
98997: IFTRUE 99001
98999: GO 99134
99001: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
99002: LD_ADDR_VAR 0 5
99006: PUSH
99007: LD_VAR 0 1
99011: PUSH
99012: LD_VAR 0 2
99016: PUSH
99017: LD_INT 4
99019: MINUS
99020: PUSH
99021: LD_INT 3
99023: PUSH
99024: EMPTY
99025: LIST
99026: LIST
99027: LIST
99028: PUSH
99029: LD_VAR 0 1
99033: PUSH
99034: LD_INT 3
99036: MINUS
99037: PUSH
99038: LD_VAR 0 2
99042: PUSH
99043: LD_INT 3
99045: MINUS
99046: PUSH
99047: LD_INT 2
99049: PUSH
99050: EMPTY
99051: LIST
99052: LIST
99053: LIST
99054: PUSH
99055: LD_VAR 0 1
99059: PUSH
99060: LD_INT 4
99062: MINUS
99063: PUSH
99064: LD_VAR 0 2
99068: PUSH
99069: LD_INT 1
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: LIST
99076: PUSH
99077: LD_VAR 0 1
99081: PUSH
99082: LD_VAR 0 2
99086: PUSH
99087: LD_INT 3
99089: PLUS
99090: PUSH
99091: LD_INT 0
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: LIST
99098: PUSH
99099: LD_VAR 0 1
99103: PUSH
99104: LD_INT 4
99106: PLUS
99107: PUSH
99108: LD_VAR 0 2
99112: PUSH
99113: LD_INT 4
99115: PLUS
99116: PUSH
99117: LD_INT 5
99119: PUSH
99120: EMPTY
99121: LIST
99122: LIST
99123: LIST
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: LIST
99129: LIST
99130: LIST
99131: ST_TO_ADDR
// end ; 2 :
99132: GO 99691
99134: LD_INT 2
99136: DOUBLE
99137: EQUAL
99138: IFTRUE 99142
99140: GO 99271
99142: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99143: LD_ADDR_VAR 0 5
99147: PUSH
99148: LD_VAR 0 1
99152: PUSH
99153: LD_VAR 0 2
99157: PUSH
99158: LD_INT 3
99160: MINUS
99161: PUSH
99162: LD_INT 3
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: LIST
99169: PUSH
99170: LD_VAR 0 1
99174: PUSH
99175: LD_INT 4
99177: PLUS
99178: PUSH
99179: LD_VAR 0 2
99183: PUSH
99184: LD_INT 4
99186: PUSH
99187: EMPTY
99188: LIST
99189: LIST
99190: LIST
99191: PUSH
99192: LD_VAR 0 1
99196: PUSH
99197: LD_VAR 0 2
99201: PUSH
99202: LD_INT 4
99204: PLUS
99205: PUSH
99206: LD_INT 0
99208: PUSH
99209: EMPTY
99210: LIST
99211: LIST
99212: LIST
99213: PUSH
99214: LD_VAR 0 1
99218: PUSH
99219: LD_INT 3
99221: MINUS
99222: PUSH
99223: LD_VAR 0 2
99227: PUSH
99228: LD_INT 1
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: LIST
99235: PUSH
99236: LD_VAR 0 1
99240: PUSH
99241: LD_INT 4
99243: MINUS
99244: PUSH
99245: LD_VAR 0 2
99249: PUSH
99250: LD_INT 4
99252: MINUS
99253: PUSH
99254: LD_INT 2
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: LIST
99261: PUSH
99262: EMPTY
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: ST_TO_ADDR
// end ; 3 :
99269: GO 99691
99271: LD_INT 3
99273: DOUBLE
99274: EQUAL
99275: IFTRUE 99279
99277: GO 99412
99279: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99280: LD_ADDR_VAR 0 5
99284: PUSH
99285: LD_VAR 0 1
99289: PUSH
99290: LD_INT 3
99292: PLUS
99293: PUSH
99294: LD_VAR 0 2
99298: PUSH
99299: LD_INT 4
99301: PUSH
99302: EMPTY
99303: LIST
99304: LIST
99305: LIST
99306: PUSH
99307: LD_VAR 0 1
99311: PUSH
99312: LD_INT 4
99314: PLUS
99315: PUSH
99316: LD_VAR 0 2
99320: PUSH
99321: LD_INT 4
99323: PLUS
99324: PUSH
99325: LD_INT 5
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: LIST
99332: PUSH
99333: LD_VAR 0 1
99337: PUSH
99338: LD_INT 4
99340: MINUS
99341: PUSH
99342: LD_VAR 0 2
99346: PUSH
99347: LD_INT 1
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: LIST
99354: PUSH
99355: LD_VAR 0 1
99359: PUSH
99360: LD_VAR 0 2
99364: PUSH
99365: LD_INT 4
99367: MINUS
99368: PUSH
99369: LD_INT 3
99371: PUSH
99372: EMPTY
99373: LIST
99374: LIST
99375: LIST
99376: PUSH
99377: LD_VAR 0 1
99381: PUSH
99382: LD_INT 3
99384: MINUS
99385: PUSH
99386: LD_VAR 0 2
99390: PUSH
99391: LD_INT 3
99393: MINUS
99394: PUSH
99395: LD_INT 2
99397: PUSH
99398: EMPTY
99399: LIST
99400: LIST
99401: LIST
99402: PUSH
99403: EMPTY
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: ST_TO_ADDR
// end ; 4 :
99410: GO 99691
99412: LD_INT 4
99414: DOUBLE
99415: EQUAL
99416: IFTRUE 99420
99418: GO 99553
99420: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99421: LD_ADDR_VAR 0 5
99425: PUSH
99426: LD_VAR 0 1
99430: PUSH
99431: LD_VAR 0 2
99435: PUSH
99436: LD_INT 4
99438: PLUS
99439: PUSH
99440: LD_INT 0
99442: PUSH
99443: EMPTY
99444: LIST
99445: LIST
99446: LIST
99447: PUSH
99448: LD_VAR 0 1
99452: PUSH
99453: LD_INT 3
99455: PLUS
99456: PUSH
99457: LD_VAR 0 2
99461: PUSH
99462: LD_INT 3
99464: PLUS
99465: PUSH
99466: LD_INT 5
99468: PUSH
99469: EMPTY
99470: LIST
99471: LIST
99472: LIST
99473: PUSH
99474: LD_VAR 0 1
99478: PUSH
99479: LD_INT 4
99481: PLUS
99482: PUSH
99483: LD_VAR 0 2
99487: PUSH
99488: LD_INT 4
99490: PUSH
99491: EMPTY
99492: LIST
99493: LIST
99494: LIST
99495: PUSH
99496: LD_VAR 0 1
99500: PUSH
99501: LD_VAR 0 2
99505: PUSH
99506: LD_INT 3
99508: MINUS
99509: PUSH
99510: LD_INT 3
99512: PUSH
99513: EMPTY
99514: LIST
99515: LIST
99516: LIST
99517: PUSH
99518: LD_VAR 0 1
99522: PUSH
99523: LD_INT 4
99525: MINUS
99526: PUSH
99527: LD_VAR 0 2
99531: PUSH
99532: LD_INT 4
99534: MINUS
99535: PUSH
99536: LD_INT 2
99538: PUSH
99539: EMPTY
99540: LIST
99541: LIST
99542: LIST
99543: PUSH
99544: EMPTY
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: ST_TO_ADDR
// end ; 5 :
99551: GO 99691
99553: LD_INT 5
99555: DOUBLE
99556: EQUAL
99557: IFTRUE 99561
99559: GO 99690
99561: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99562: LD_ADDR_VAR 0 5
99566: PUSH
99567: LD_VAR 0 1
99571: PUSH
99572: LD_INT 4
99574: MINUS
99575: PUSH
99576: LD_VAR 0 2
99580: PUSH
99581: LD_INT 1
99583: PUSH
99584: EMPTY
99585: LIST
99586: LIST
99587: LIST
99588: PUSH
99589: LD_VAR 0 1
99593: PUSH
99594: LD_VAR 0 2
99598: PUSH
99599: LD_INT 4
99601: MINUS
99602: PUSH
99603: LD_INT 3
99605: PUSH
99606: EMPTY
99607: LIST
99608: LIST
99609: LIST
99610: PUSH
99611: LD_VAR 0 1
99615: PUSH
99616: LD_INT 4
99618: PLUS
99619: PUSH
99620: LD_VAR 0 2
99624: PUSH
99625: LD_INT 4
99627: PLUS
99628: PUSH
99629: LD_INT 5
99631: PUSH
99632: EMPTY
99633: LIST
99634: LIST
99635: LIST
99636: PUSH
99637: LD_VAR 0 1
99641: PUSH
99642: LD_INT 3
99644: PLUS
99645: PUSH
99646: LD_VAR 0 2
99650: PUSH
99651: LD_INT 4
99653: PUSH
99654: EMPTY
99655: LIST
99656: LIST
99657: LIST
99658: PUSH
99659: LD_VAR 0 1
99663: PUSH
99664: LD_VAR 0 2
99668: PUSH
99669: LD_INT 3
99671: PLUS
99672: PUSH
99673: LD_INT 0
99675: PUSH
99676: EMPTY
99677: LIST
99678: LIST
99679: LIST
99680: PUSH
99681: EMPTY
99682: LIST
99683: LIST
99684: LIST
99685: LIST
99686: LIST
99687: ST_TO_ADDR
// end ; end ;
99688: GO 99691
99690: POP
// result := list ;
99691: LD_ADDR_VAR 0 4
99695: PUSH
99696: LD_VAR 0 5
99700: ST_TO_ADDR
// end ;
99701: LD_VAR 0 4
99705: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99706: LD_INT 0
99708: PPUSH
99709: PPUSH
99710: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99711: LD_VAR 0 1
99715: NOT
99716: PUSH
99717: LD_VAR 0 2
99721: PUSH
99722: LD_INT 1
99724: PUSH
99725: LD_INT 2
99727: PUSH
99728: LD_INT 3
99730: PUSH
99731: LD_INT 4
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: LIST
99738: LIST
99739: IN
99740: NOT
99741: OR
99742: IFFALSE 99746
// exit ;
99744: GO 99838
// tmp := [ ] ;
99746: LD_ADDR_VAR 0 5
99750: PUSH
99751: EMPTY
99752: ST_TO_ADDR
// for i in units do
99753: LD_ADDR_VAR 0 4
99757: PUSH
99758: LD_VAR 0 1
99762: PUSH
99763: FOR_IN
99764: IFFALSE 99807
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99766: LD_ADDR_VAR 0 5
99770: PUSH
99771: LD_VAR 0 5
99775: PPUSH
99776: LD_VAR 0 5
99780: PUSH
99781: LD_INT 1
99783: PLUS
99784: PPUSH
99785: LD_VAR 0 4
99789: PPUSH
99790: LD_VAR 0 2
99794: PPUSH
99795: CALL_OW 259
99799: PPUSH
99800: CALL_OW 2
99804: ST_TO_ADDR
99805: GO 99763
99807: POP
99808: POP
// if not tmp then
99809: LD_VAR 0 5
99813: NOT
99814: IFFALSE 99818
// exit ;
99816: GO 99838
// result := SortListByListDesc ( units , tmp ) ;
99818: LD_ADDR_VAR 0 3
99822: PUSH
99823: LD_VAR 0 1
99827: PPUSH
99828: LD_VAR 0 5
99832: PPUSH
99833: CALL_OW 77
99837: ST_TO_ADDR
// end ;
99838: LD_VAR 0 3
99842: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99843: LD_INT 0
99845: PPUSH
99846: PPUSH
99847: PPUSH
// result := false ;
99848: LD_ADDR_VAR 0 3
99852: PUSH
99853: LD_INT 0
99855: ST_TO_ADDR
// x := GetX ( building ) ;
99856: LD_ADDR_VAR 0 4
99860: PUSH
99861: LD_VAR 0 2
99865: PPUSH
99866: CALL_OW 250
99870: ST_TO_ADDR
// y := GetY ( building ) ;
99871: LD_ADDR_VAR 0 5
99875: PUSH
99876: LD_VAR 0 2
99880: PPUSH
99881: CALL_OW 251
99885: ST_TO_ADDR
// if not building or not x or not y then
99886: LD_VAR 0 2
99890: NOT
99891: PUSH
99892: LD_VAR 0 4
99896: NOT
99897: OR
99898: PUSH
99899: LD_VAR 0 5
99903: NOT
99904: OR
99905: IFFALSE 99909
// exit ;
99907: GO 100001
// if GetTaskList ( unit ) then
99909: LD_VAR 0 1
99913: PPUSH
99914: CALL_OW 437
99918: IFFALSE 100001
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99920: LD_STRING e
99922: PUSH
99923: LD_VAR 0 1
99927: PPUSH
99928: CALL_OW 437
99932: PUSH
99933: LD_INT 1
99935: ARRAY
99936: PUSH
99937: LD_INT 1
99939: ARRAY
99940: EQUAL
99941: PUSH
99942: LD_VAR 0 4
99946: PUSH
99947: LD_VAR 0 1
99951: PPUSH
99952: CALL_OW 437
99956: PUSH
99957: LD_INT 1
99959: ARRAY
99960: PUSH
99961: LD_INT 2
99963: ARRAY
99964: EQUAL
99965: AND
99966: PUSH
99967: LD_VAR 0 5
99971: PUSH
99972: LD_VAR 0 1
99976: PPUSH
99977: CALL_OW 437
99981: PUSH
99982: LD_INT 1
99984: ARRAY
99985: PUSH
99986: LD_INT 3
99988: ARRAY
99989: EQUAL
99990: AND
99991: IFFALSE 100001
// result := true end ;
99993: LD_ADDR_VAR 0 3
99997: PUSH
99998: LD_INT 1
100000: ST_TO_ADDR
// end ;
100001: LD_VAR 0 3
100005: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
100006: LD_INT 0
100008: PPUSH
// result := false ;
100009: LD_ADDR_VAR 0 4
100013: PUSH
100014: LD_INT 0
100016: ST_TO_ADDR
// if GetTaskList ( unit ) then
100017: LD_VAR 0 1
100021: PPUSH
100022: CALL_OW 437
100026: IFFALSE 100109
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100028: LD_STRING M
100030: PUSH
100031: LD_VAR 0 1
100035: PPUSH
100036: CALL_OW 437
100040: PUSH
100041: LD_INT 1
100043: ARRAY
100044: PUSH
100045: LD_INT 1
100047: ARRAY
100048: EQUAL
100049: PUSH
100050: LD_VAR 0 2
100054: PUSH
100055: LD_VAR 0 1
100059: PPUSH
100060: CALL_OW 437
100064: PUSH
100065: LD_INT 1
100067: ARRAY
100068: PUSH
100069: LD_INT 2
100071: ARRAY
100072: EQUAL
100073: AND
100074: PUSH
100075: LD_VAR 0 3
100079: PUSH
100080: LD_VAR 0 1
100084: PPUSH
100085: CALL_OW 437
100089: PUSH
100090: LD_INT 1
100092: ARRAY
100093: PUSH
100094: LD_INT 3
100096: ARRAY
100097: EQUAL
100098: AND
100099: IFFALSE 100109
// result := true ;
100101: LD_ADDR_VAR 0 4
100105: PUSH
100106: LD_INT 1
100108: ST_TO_ADDR
// end ; end ;
100109: LD_VAR 0 4
100113: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100114: LD_INT 0
100116: PPUSH
100117: PPUSH
100118: PPUSH
100119: PPUSH
// if not unit or not area then
100120: LD_VAR 0 1
100124: NOT
100125: PUSH
100126: LD_VAR 0 2
100130: NOT
100131: OR
100132: IFFALSE 100136
// exit ;
100134: GO 100300
// tmp := AreaToList ( area , i ) ;
100136: LD_ADDR_VAR 0 6
100140: PUSH
100141: LD_VAR 0 2
100145: PPUSH
100146: LD_VAR 0 5
100150: PPUSH
100151: CALL_OW 517
100155: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100156: LD_ADDR_VAR 0 5
100160: PUSH
100161: DOUBLE
100162: LD_INT 1
100164: DEC
100165: ST_TO_ADDR
100166: LD_VAR 0 6
100170: PUSH
100171: LD_INT 1
100173: ARRAY
100174: PUSH
100175: FOR_TO
100176: IFFALSE 100298
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100178: LD_ADDR_VAR 0 7
100182: PUSH
100183: LD_VAR 0 6
100187: PUSH
100188: LD_INT 1
100190: ARRAY
100191: PUSH
100192: LD_VAR 0 5
100196: ARRAY
100197: PUSH
100198: LD_VAR 0 6
100202: PUSH
100203: LD_INT 2
100205: ARRAY
100206: PUSH
100207: LD_VAR 0 5
100211: ARRAY
100212: PUSH
100213: EMPTY
100214: LIST
100215: LIST
100216: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
100217: LD_VAR 0 7
100221: PUSH
100222: LD_INT 1
100224: ARRAY
100225: PPUSH
100226: LD_VAR 0 7
100230: PUSH
100231: LD_INT 2
100233: ARRAY
100234: PPUSH
100235: CALL_OW 428
100239: PUSH
100240: LD_INT 0
100242: EQUAL
100243: IFFALSE 100296
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100245: LD_VAR 0 1
100249: PPUSH
100250: LD_VAR 0 7
100254: PUSH
100255: LD_INT 1
100257: ARRAY
100258: PPUSH
100259: LD_VAR 0 7
100263: PUSH
100264: LD_INT 2
100266: ARRAY
100267: PPUSH
100268: LD_VAR 0 3
100272: PPUSH
100273: CALL_OW 48
// result := IsPlaced ( unit ) ;
100277: LD_ADDR_VAR 0 4
100281: PUSH
100282: LD_VAR 0 1
100286: PPUSH
100287: CALL_OW 305
100291: ST_TO_ADDR
// exit ;
100292: POP
100293: POP
100294: GO 100300
// end ; end ;
100296: GO 100175
100298: POP
100299: POP
// end ;
100300: LD_VAR 0 4
100304: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100305: LD_INT 0
100307: PPUSH
100308: PPUSH
100309: PPUSH
// if not side or side > 8 then
100310: LD_VAR 0 1
100314: NOT
100315: PUSH
100316: LD_VAR 0 1
100320: PUSH
100321: LD_INT 8
100323: GREATER
100324: OR
100325: IFFALSE 100329
// exit ;
100327: GO 100516
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100329: LD_ADDR_VAR 0 4
100333: PUSH
100334: LD_INT 22
100336: PUSH
100337: LD_VAR 0 1
100341: PUSH
100342: EMPTY
100343: LIST
100344: LIST
100345: PUSH
100346: LD_INT 21
100348: PUSH
100349: LD_INT 3
100351: PUSH
100352: EMPTY
100353: LIST
100354: LIST
100355: PUSH
100356: EMPTY
100357: LIST
100358: LIST
100359: PPUSH
100360: CALL_OW 69
100364: ST_TO_ADDR
// if not tmp then
100365: LD_VAR 0 4
100369: NOT
100370: IFFALSE 100374
// exit ;
100372: GO 100516
// enable_addtolog := true ;
100374: LD_ADDR_OWVAR 81
100378: PUSH
100379: LD_INT 1
100381: ST_TO_ADDR
// AddToLog ( [ ) ;
100382: LD_STRING [
100384: PPUSH
100385: CALL_OW 561
// for i in tmp do
100389: LD_ADDR_VAR 0 3
100393: PUSH
100394: LD_VAR 0 4
100398: PUSH
100399: FOR_IN
100400: IFFALSE 100507
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100402: LD_STRING [
100404: PUSH
100405: LD_VAR 0 3
100409: PPUSH
100410: CALL_OW 266
100414: STR
100415: PUSH
100416: LD_STRING , 
100418: STR
100419: PUSH
100420: LD_VAR 0 3
100424: PPUSH
100425: CALL_OW 250
100429: STR
100430: PUSH
100431: LD_STRING , 
100433: STR
100434: PUSH
100435: LD_VAR 0 3
100439: PPUSH
100440: CALL_OW 251
100444: STR
100445: PUSH
100446: LD_STRING , 
100448: STR
100449: PUSH
100450: LD_VAR 0 3
100454: PPUSH
100455: CALL_OW 254
100459: STR
100460: PUSH
100461: LD_STRING , 
100463: STR
100464: PUSH
100465: LD_VAR 0 3
100469: PPUSH
100470: LD_INT 1
100472: PPUSH
100473: CALL_OW 268
100477: STR
100478: PUSH
100479: LD_STRING , 
100481: STR
100482: PUSH
100483: LD_VAR 0 3
100487: PPUSH
100488: LD_INT 2
100490: PPUSH
100491: CALL_OW 268
100495: STR
100496: PUSH
100497: LD_STRING ],
100499: STR
100500: PPUSH
100501: CALL_OW 561
// end ;
100505: GO 100399
100507: POP
100508: POP
// AddToLog ( ]; ) ;
100509: LD_STRING ];
100511: PPUSH
100512: CALL_OW 561
// end ;
100516: LD_VAR 0 2
100520: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100521: LD_INT 0
100523: PPUSH
100524: PPUSH
100525: PPUSH
100526: PPUSH
100527: PPUSH
// if not area or not rate or not max then
100528: LD_VAR 0 1
100532: NOT
100533: PUSH
100534: LD_VAR 0 2
100538: NOT
100539: OR
100540: PUSH
100541: LD_VAR 0 4
100545: NOT
100546: OR
100547: IFFALSE 100551
// exit ;
100549: GO 100743
// while 1 do
100551: LD_INT 1
100553: IFFALSE 100743
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100555: LD_ADDR_VAR 0 9
100559: PUSH
100560: LD_VAR 0 1
100564: PPUSH
100565: LD_INT 1
100567: PPUSH
100568: CALL_OW 287
100572: PUSH
100573: LD_INT 10
100575: MUL
100576: ST_TO_ADDR
// r := rate / 10 ;
100577: LD_ADDR_VAR 0 7
100581: PUSH
100582: LD_VAR 0 2
100586: PUSH
100587: LD_INT 10
100589: DIVREAL
100590: ST_TO_ADDR
// time := 1 1$00 ;
100591: LD_ADDR_VAR 0 8
100595: PUSH
100596: LD_INT 2100
100598: ST_TO_ADDR
// if amount < min then
100599: LD_VAR 0 9
100603: PUSH
100604: LD_VAR 0 3
100608: LESS
100609: IFFALSE 100627
// r := r * 2 else
100611: LD_ADDR_VAR 0 7
100615: PUSH
100616: LD_VAR 0 7
100620: PUSH
100621: LD_INT 2
100623: MUL
100624: ST_TO_ADDR
100625: GO 100653
// if amount > max then
100627: LD_VAR 0 9
100631: PUSH
100632: LD_VAR 0 4
100636: GREATER
100637: IFFALSE 100653
// r := r / 2 ;
100639: LD_ADDR_VAR 0 7
100643: PUSH
100644: LD_VAR 0 7
100648: PUSH
100649: LD_INT 2
100651: DIVREAL
100652: ST_TO_ADDR
// time := time / r ;
100653: LD_ADDR_VAR 0 8
100657: PUSH
100658: LD_VAR 0 8
100662: PUSH
100663: LD_VAR 0 7
100667: DIVREAL
100668: ST_TO_ADDR
// if time < 0 then
100669: LD_VAR 0 8
100673: PUSH
100674: LD_INT 0
100676: LESS
100677: IFFALSE 100694
// time := time * - 1 ;
100679: LD_ADDR_VAR 0 8
100683: PUSH
100684: LD_VAR 0 8
100688: PUSH
100689: LD_INT 1
100691: NEG
100692: MUL
100693: ST_TO_ADDR
// wait ( time ) ;
100694: LD_VAR 0 8
100698: PPUSH
100699: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100703: LD_INT 35
100705: PPUSH
100706: LD_INT 875
100708: PPUSH
100709: CALL_OW 12
100713: PPUSH
100714: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100718: LD_INT 1
100720: PPUSH
100721: LD_INT 5
100723: PPUSH
100724: CALL_OW 12
100728: PPUSH
100729: LD_VAR 0 1
100733: PPUSH
100734: LD_INT 1
100736: PPUSH
100737: CALL_OW 55
// end ;
100741: GO 100551
// end ;
100743: LD_VAR 0 5
100747: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100748: LD_INT 0
100750: PPUSH
100751: PPUSH
100752: PPUSH
100753: PPUSH
100754: PPUSH
100755: PPUSH
100756: PPUSH
100757: PPUSH
// if not turrets or not factories then
100758: LD_VAR 0 1
100762: NOT
100763: PUSH
100764: LD_VAR 0 2
100768: NOT
100769: OR
100770: IFFALSE 100774
// exit ;
100772: GO 101081
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100774: LD_ADDR_VAR 0 10
100778: PUSH
100779: LD_INT 5
100781: PUSH
100782: LD_INT 6
100784: PUSH
100785: EMPTY
100786: LIST
100787: LIST
100788: PUSH
100789: LD_INT 2
100791: PUSH
100792: LD_INT 4
100794: PUSH
100795: EMPTY
100796: LIST
100797: LIST
100798: PUSH
100799: LD_INT 3
100801: PUSH
100802: LD_INT 5
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: PUSH
100809: EMPTY
100810: LIST
100811: LIST
100812: LIST
100813: PUSH
100814: LD_INT 24
100816: PUSH
100817: LD_INT 25
100819: PUSH
100820: EMPTY
100821: LIST
100822: LIST
100823: PUSH
100824: LD_INT 23
100826: PUSH
100827: LD_INT 27
100829: PUSH
100830: EMPTY
100831: LIST
100832: LIST
100833: PUSH
100834: EMPTY
100835: LIST
100836: LIST
100837: PUSH
100838: LD_INT 42
100840: PUSH
100841: LD_INT 43
100843: PUSH
100844: EMPTY
100845: LIST
100846: LIST
100847: PUSH
100848: LD_INT 44
100850: PUSH
100851: LD_INT 46
100853: PUSH
100854: EMPTY
100855: LIST
100856: LIST
100857: PUSH
100858: LD_INT 45
100860: PUSH
100861: LD_INT 47
100863: PUSH
100864: EMPTY
100865: LIST
100866: LIST
100867: PUSH
100868: EMPTY
100869: LIST
100870: LIST
100871: LIST
100872: PUSH
100873: EMPTY
100874: LIST
100875: LIST
100876: LIST
100877: ST_TO_ADDR
// result := [ ] ;
100878: LD_ADDR_VAR 0 3
100882: PUSH
100883: EMPTY
100884: ST_TO_ADDR
// for i in turrets do
100885: LD_ADDR_VAR 0 4
100889: PUSH
100890: LD_VAR 0 1
100894: PUSH
100895: FOR_IN
100896: IFFALSE 101079
// begin nat := GetNation ( i ) ;
100898: LD_ADDR_VAR 0 7
100902: PUSH
100903: LD_VAR 0 4
100907: PPUSH
100908: CALL_OW 248
100912: ST_TO_ADDR
// weapon := 0 ;
100913: LD_ADDR_VAR 0 8
100917: PUSH
100918: LD_INT 0
100920: ST_TO_ADDR
// if not nat then
100921: LD_VAR 0 7
100925: NOT
100926: IFFALSE 100930
// continue ;
100928: GO 100895
// for j in list [ nat ] do
100930: LD_ADDR_VAR 0 5
100934: PUSH
100935: LD_VAR 0 10
100939: PUSH
100940: LD_VAR 0 7
100944: ARRAY
100945: PUSH
100946: FOR_IN
100947: IFFALSE 100988
// if GetBWeapon ( i ) = j [ 1 ] then
100949: LD_VAR 0 4
100953: PPUSH
100954: CALL_OW 269
100958: PUSH
100959: LD_VAR 0 5
100963: PUSH
100964: LD_INT 1
100966: ARRAY
100967: EQUAL
100968: IFFALSE 100986
// begin weapon := j [ 2 ] ;
100970: LD_ADDR_VAR 0 8
100974: PUSH
100975: LD_VAR 0 5
100979: PUSH
100980: LD_INT 2
100982: ARRAY
100983: ST_TO_ADDR
// break ;
100984: GO 100988
// end ;
100986: GO 100946
100988: POP
100989: POP
// if not weapon then
100990: LD_VAR 0 8
100994: NOT
100995: IFFALSE 100999
// continue ;
100997: GO 100895
// for k in factories do
100999: LD_ADDR_VAR 0 6
101003: PUSH
101004: LD_VAR 0 2
101008: PUSH
101009: FOR_IN
101010: IFFALSE 101075
// begin weapons := AvailableWeaponList ( k ) ;
101012: LD_ADDR_VAR 0 9
101016: PUSH
101017: LD_VAR 0 6
101021: PPUSH
101022: CALL_OW 478
101026: ST_TO_ADDR
// if not weapons then
101027: LD_VAR 0 9
101031: NOT
101032: IFFALSE 101036
// continue ;
101034: GO 101009
// if weapon in weapons then
101036: LD_VAR 0 8
101040: PUSH
101041: LD_VAR 0 9
101045: IN
101046: IFFALSE 101073
// begin result := [ i , weapon ] ;
101048: LD_ADDR_VAR 0 3
101052: PUSH
101053: LD_VAR 0 4
101057: PUSH
101058: LD_VAR 0 8
101062: PUSH
101063: EMPTY
101064: LIST
101065: LIST
101066: ST_TO_ADDR
// exit ;
101067: POP
101068: POP
101069: POP
101070: POP
101071: GO 101081
// end ; end ;
101073: GO 101009
101075: POP
101076: POP
// end ;
101077: GO 100895
101079: POP
101080: POP
// end ;
101081: LD_VAR 0 3
101085: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
101086: LD_INT 0
101088: PPUSH
// if not side or side > 8 then
101089: LD_VAR 0 3
101093: NOT
101094: PUSH
101095: LD_VAR 0 3
101099: PUSH
101100: LD_INT 8
101102: GREATER
101103: OR
101104: IFFALSE 101108
// exit ;
101106: GO 101167
// if not range then
101108: LD_VAR 0 4
101112: NOT
101113: IFFALSE 101124
// range := - 12 ;
101115: LD_ADDR_VAR 0 4
101119: PUSH
101120: LD_INT 12
101122: NEG
101123: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101124: LD_VAR 0 1
101128: PPUSH
101129: LD_VAR 0 2
101133: PPUSH
101134: LD_VAR 0 3
101138: PPUSH
101139: LD_VAR 0 4
101143: PPUSH
101144: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101148: LD_VAR 0 1
101152: PPUSH
101153: LD_VAR 0 2
101157: PPUSH
101158: LD_VAR 0 3
101162: PPUSH
101163: CALL_OW 331
// end ;
101167: LD_VAR 0 5
101171: RET
// export function Video ( mode ) ; begin
101172: LD_INT 0
101174: PPUSH
// ingame_video = mode ;
101175: LD_ADDR_OWVAR 52
101179: PUSH
101180: LD_VAR 0 1
101184: ST_TO_ADDR
// interface_hidden = mode ;
101185: LD_ADDR_OWVAR 54
101189: PUSH
101190: LD_VAR 0 1
101194: ST_TO_ADDR
// end ;
101195: LD_VAR 0 2
101199: RET
// export function Join ( array , element ) ; begin
101200: LD_INT 0
101202: PPUSH
// result := Replace ( array , array + 1 , element ) ;
101203: LD_ADDR_VAR 0 3
101207: PUSH
101208: LD_VAR 0 1
101212: PPUSH
101213: LD_VAR 0 1
101217: PUSH
101218: LD_INT 1
101220: PLUS
101221: PPUSH
101222: LD_VAR 0 2
101226: PPUSH
101227: CALL_OW 1
101231: ST_TO_ADDR
// end ;
101232: LD_VAR 0 3
101236: RET
// export function JoinUnion ( array , element ) ; begin
101237: LD_INT 0
101239: PPUSH
// result := array union element ;
101240: LD_ADDR_VAR 0 3
101244: PUSH
101245: LD_VAR 0 1
101249: PUSH
101250: LD_VAR 0 2
101254: UNION
101255: ST_TO_ADDR
// end ;
101256: LD_VAR 0 3
101260: RET
// export function GetBehemoths ( side ) ; begin
101261: LD_INT 0
101263: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101264: LD_ADDR_VAR 0 2
101268: PUSH
101269: LD_INT 22
101271: PUSH
101272: LD_VAR 0 1
101276: PUSH
101277: EMPTY
101278: LIST
101279: LIST
101280: PUSH
101281: LD_INT 31
101283: PUSH
101284: LD_INT 25
101286: PUSH
101287: EMPTY
101288: LIST
101289: LIST
101290: PUSH
101291: EMPTY
101292: LIST
101293: LIST
101294: PPUSH
101295: CALL_OW 69
101299: ST_TO_ADDR
// end ;
101300: LD_VAR 0 2
101304: RET
// export function Shuffle ( array ) ; var i , index ; begin
101305: LD_INT 0
101307: PPUSH
101308: PPUSH
101309: PPUSH
// result := [ ] ;
101310: LD_ADDR_VAR 0 2
101314: PUSH
101315: EMPTY
101316: ST_TO_ADDR
// if not array then
101317: LD_VAR 0 1
101321: NOT
101322: IFFALSE 101326
// exit ;
101324: GO 101425
// Randomize ;
101326: CALL_OW 10
// for i = array downto 1 do
101330: LD_ADDR_VAR 0 3
101334: PUSH
101335: DOUBLE
101336: LD_VAR 0 1
101340: INC
101341: ST_TO_ADDR
101342: LD_INT 1
101344: PUSH
101345: FOR_DOWNTO
101346: IFFALSE 101423
// begin index := rand ( 1 , array ) ;
101348: LD_ADDR_VAR 0 4
101352: PUSH
101353: LD_INT 1
101355: PPUSH
101356: LD_VAR 0 1
101360: PPUSH
101361: CALL_OW 12
101365: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101366: LD_ADDR_VAR 0 2
101370: PUSH
101371: LD_VAR 0 2
101375: PPUSH
101376: LD_VAR 0 2
101380: PUSH
101381: LD_INT 1
101383: PLUS
101384: PPUSH
101385: LD_VAR 0 1
101389: PUSH
101390: LD_VAR 0 4
101394: ARRAY
101395: PPUSH
101396: CALL_OW 2
101400: ST_TO_ADDR
// array := Delete ( array , index ) ;
101401: LD_ADDR_VAR 0 1
101405: PUSH
101406: LD_VAR 0 1
101410: PPUSH
101411: LD_VAR 0 4
101415: PPUSH
101416: CALL_OW 3
101420: ST_TO_ADDR
// end ;
101421: GO 101345
101423: POP
101424: POP
// end ;
101425: LD_VAR 0 2
101429: RET
// export function GetBaseMaterials ( base ) ; begin
101430: LD_INT 0
101432: PPUSH
// result := [ 0 , 0 , 0 ] ;
101433: LD_ADDR_VAR 0 2
101437: PUSH
101438: LD_INT 0
101440: PUSH
101441: LD_INT 0
101443: PUSH
101444: LD_INT 0
101446: PUSH
101447: EMPTY
101448: LIST
101449: LIST
101450: LIST
101451: ST_TO_ADDR
// if not base then
101452: LD_VAR 0 1
101456: NOT
101457: IFFALSE 101461
// exit ;
101459: GO 101510
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101461: LD_ADDR_VAR 0 2
101465: PUSH
101466: LD_VAR 0 1
101470: PPUSH
101471: LD_INT 1
101473: PPUSH
101474: CALL_OW 275
101478: PUSH
101479: LD_VAR 0 1
101483: PPUSH
101484: LD_INT 2
101486: PPUSH
101487: CALL_OW 275
101491: PUSH
101492: LD_VAR 0 1
101496: PPUSH
101497: LD_INT 3
101499: PPUSH
101500: CALL_OW 275
101504: PUSH
101505: EMPTY
101506: LIST
101507: LIST
101508: LIST
101509: ST_TO_ADDR
// end ;
101510: LD_VAR 0 2
101514: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101515: LD_INT 0
101517: PPUSH
101518: PPUSH
// result := array ;
101519: LD_ADDR_VAR 0 3
101523: PUSH
101524: LD_VAR 0 1
101528: ST_TO_ADDR
// if size > 0 then
101529: LD_VAR 0 2
101533: PUSH
101534: LD_INT 0
101536: GREATER
101537: IFFALSE 101583
// for i := array downto size do
101539: LD_ADDR_VAR 0 4
101543: PUSH
101544: DOUBLE
101545: LD_VAR 0 1
101549: INC
101550: ST_TO_ADDR
101551: LD_VAR 0 2
101555: PUSH
101556: FOR_DOWNTO
101557: IFFALSE 101581
// result := Delete ( result , result ) ;
101559: LD_ADDR_VAR 0 3
101563: PUSH
101564: LD_VAR 0 3
101568: PPUSH
101569: LD_VAR 0 3
101573: PPUSH
101574: CALL_OW 3
101578: ST_TO_ADDR
101579: GO 101556
101581: POP
101582: POP
// end ;
101583: LD_VAR 0 3
101587: RET
// export function ComExit ( unit ) ; var tmp ; begin
101588: LD_INT 0
101590: PPUSH
101591: PPUSH
// if not IsInUnit ( unit ) then
101592: LD_VAR 0 1
101596: PPUSH
101597: CALL_OW 310
101601: NOT
101602: IFFALSE 101606
// exit ;
101604: GO 101666
// tmp := IsInUnit ( unit ) ;
101606: LD_ADDR_VAR 0 3
101610: PUSH
101611: LD_VAR 0 1
101615: PPUSH
101616: CALL_OW 310
101620: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101621: LD_VAR 0 3
101625: PPUSH
101626: CALL_OW 247
101630: PUSH
101631: LD_INT 2
101633: EQUAL
101634: IFFALSE 101647
// ComExitVehicle ( unit ) else
101636: LD_VAR 0 1
101640: PPUSH
101641: CALL_OW 121
101645: GO 101656
// ComExitBuilding ( unit ) ;
101647: LD_VAR 0 1
101651: PPUSH
101652: CALL_OW 122
// result := tmp ;
101656: LD_ADDR_VAR 0 2
101660: PUSH
101661: LD_VAR 0 3
101665: ST_TO_ADDR
// end ;
101666: LD_VAR 0 2
101670: RET
// export function ResetHc ; begin
101671: LD_INT 0
101673: PPUSH
// InitHc ;
101674: CALL_OW 19
// hc_importance := 0 ;
101678: LD_ADDR_OWVAR 32
101682: PUSH
101683: LD_INT 0
101685: ST_TO_ADDR
// end ;
101686: LD_VAR 0 1
101690: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101691: LD_INT 0
101693: PPUSH
101694: PPUSH
101695: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101696: LD_ADDR_VAR 0 6
101700: PUSH
101701: LD_VAR 0 1
101705: PUSH
101706: LD_VAR 0 3
101710: PLUS
101711: PUSH
101712: LD_INT 2
101714: DIV
101715: ST_TO_ADDR
// if _x < 0 then
101716: LD_VAR 0 6
101720: PUSH
101721: LD_INT 0
101723: LESS
101724: IFFALSE 101741
// _x := _x * - 1 ;
101726: LD_ADDR_VAR 0 6
101730: PUSH
101731: LD_VAR 0 6
101735: PUSH
101736: LD_INT 1
101738: NEG
101739: MUL
101740: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101741: LD_ADDR_VAR 0 7
101745: PUSH
101746: LD_VAR 0 2
101750: PUSH
101751: LD_VAR 0 4
101755: PLUS
101756: PUSH
101757: LD_INT 2
101759: DIV
101760: ST_TO_ADDR
// if _y < 0 then
101761: LD_VAR 0 7
101765: PUSH
101766: LD_INT 0
101768: LESS
101769: IFFALSE 101786
// _y := _y * - 1 ;
101771: LD_ADDR_VAR 0 7
101775: PUSH
101776: LD_VAR 0 7
101780: PUSH
101781: LD_INT 1
101783: NEG
101784: MUL
101785: ST_TO_ADDR
// result := [ _x , _y ] ;
101786: LD_ADDR_VAR 0 5
101790: PUSH
101791: LD_VAR 0 6
101795: PUSH
101796: LD_VAR 0 7
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: ST_TO_ADDR
// end ;
101805: LD_VAR 0 5
101809: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101810: LD_INT 0
101812: PPUSH
101813: PPUSH
101814: PPUSH
101815: PPUSH
// task := GetTaskList ( unit ) ;
101816: LD_ADDR_VAR 0 7
101820: PUSH
101821: LD_VAR 0 1
101825: PPUSH
101826: CALL_OW 437
101830: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101831: LD_VAR 0 7
101835: NOT
101836: PUSH
101837: LD_VAR 0 1
101841: PPUSH
101842: LD_VAR 0 2
101846: PPUSH
101847: CALL_OW 308
101851: NOT
101852: AND
101853: IFFALSE 101857
// exit ;
101855: GO 101975
// if IsInArea ( unit , area ) then
101857: LD_VAR 0 1
101861: PPUSH
101862: LD_VAR 0 2
101866: PPUSH
101867: CALL_OW 308
101871: IFFALSE 101889
// begin ComMoveToArea ( unit , goAway ) ;
101873: LD_VAR 0 1
101877: PPUSH
101878: LD_VAR 0 3
101882: PPUSH
101883: CALL_OW 113
// exit ;
101887: GO 101975
// end ; if task [ 1 ] [ 1 ] <> M then
101889: LD_VAR 0 7
101893: PUSH
101894: LD_INT 1
101896: ARRAY
101897: PUSH
101898: LD_INT 1
101900: ARRAY
101901: PUSH
101902: LD_STRING M
101904: NONEQUAL
101905: IFFALSE 101909
// exit ;
101907: GO 101975
// x := task [ 1 ] [ 2 ] ;
101909: LD_ADDR_VAR 0 5
101913: PUSH
101914: LD_VAR 0 7
101918: PUSH
101919: LD_INT 1
101921: ARRAY
101922: PUSH
101923: LD_INT 2
101925: ARRAY
101926: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101927: LD_ADDR_VAR 0 6
101931: PUSH
101932: LD_VAR 0 7
101936: PUSH
101937: LD_INT 1
101939: ARRAY
101940: PUSH
101941: LD_INT 3
101943: ARRAY
101944: ST_TO_ADDR
// if InArea ( x , y , area ) then
101945: LD_VAR 0 5
101949: PPUSH
101950: LD_VAR 0 6
101954: PPUSH
101955: LD_VAR 0 2
101959: PPUSH
101960: CALL_OW 309
101964: IFFALSE 101975
// ComStop ( unit ) ;
101966: LD_VAR 0 1
101970: PPUSH
101971: CALL_OW 141
// end ;
101975: LD_VAR 0 4
101979: RET
// export function Abs ( value ) ; begin
101980: LD_INT 0
101982: PPUSH
// result := value ;
101983: LD_ADDR_VAR 0 2
101987: PUSH
101988: LD_VAR 0 1
101992: ST_TO_ADDR
// if value < 0 then
101993: LD_VAR 0 1
101997: PUSH
101998: LD_INT 0
102000: LESS
102001: IFFALSE 102018
// result := value * - 1 ;
102003: LD_ADDR_VAR 0 2
102007: PUSH
102008: LD_VAR 0 1
102012: PUSH
102013: LD_INT 1
102015: NEG
102016: MUL
102017: ST_TO_ADDR
// end ;
102018: LD_VAR 0 2
102022: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
102023: LD_INT 0
102025: PPUSH
102026: PPUSH
102027: PPUSH
102028: PPUSH
102029: PPUSH
102030: PPUSH
102031: PPUSH
102032: PPUSH
// if not unit or not building then
102033: LD_VAR 0 1
102037: NOT
102038: PUSH
102039: LD_VAR 0 2
102043: NOT
102044: OR
102045: IFFALSE 102049
// exit ;
102047: GO 102275
// x := GetX ( building ) ;
102049: LD_ADDR_VAR 0 4
102053: PUSH
102054: LD_VAR 0 2
102058: PPUSH
102059: CALL_OW 250
102063: ST_TO_ADDR
// y := GetY ( building ) ;
102064: LD_ADDR_VAR 0 6
102068: PUSH
102069: LD_VAR 0 2
102073: PPUSH
102074: CALL_OW 251
102078: ST_TO_ADDR
// d := GetDir ( building ) ;
102079: LD_ADDR_VAR 0 8
102083: PUSH
102084: LD_VAR 0 2
102088: PPUSH
102089: CALL_OW 254
102093: ST_TO_ADDR
// r := 4 ;
102094: LD_ADDR_VAR 0 9
102098: PUSH
102099: LD_INT 4
102101: ST_TO_ADDR
// for i := 1 to 5 do
102102: LD_ADDR_VAR 0 10
102106: PUSH
102107: DOUBLE
102108: LD_INT 1
102110: DEC
102111: ST_TO_ADDR
102112: LD_INT 5
102114: PUSH
102115: FOR_TO
102116: IFFALSE 102273
// begin _x := ShiftX ( x , d , r + i ) ;
102118: LD_ADDR_VAR 0 5
102122: PUSH
102123: LD_VAR 0 4
102127: PPUSH
102128: LD_VAR 0 8
102132: PPUSH
102133: LD_VAR 0 9
102137: PUSH
102138: LD_VAR 0 10
102142: PLUS
102143: PPUSH
102144: CALL_OW 272
102148: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
102149: LD_ADDR_VAR 0 7
102153: PUSH
102154: LD_VAR 0 6
102158: PPUSH
102159: LD_VAR 0 8
102163: PPUSH
102164: LD_VAR 0 9
102168: PUSH
102169: LD_VAR 0 10
102173: PLUS
102174: PPUSH
102175: CALL_OW 273
102179: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
102180: LD_VAR 0 5
102184: PPUSH
102185: LD_VAR 0 7
102189: PPUSH
102190: CALL_OW 488
102194: PUSH
102195: LD_VAR 0 5
102199: PPUSH
102200: LD_VAR 0 7
102204: PPUSH
102205: CALL_OW 428
102209: PPUSH
102210: CALL_OW 247
102214: PUSH
102215: LD_INT 3
102217: PUSH
102218: LD_INT 2
102220: PUSH
102221: EMPTY
102222: LIST
102223: LIST
102224: IN
102225: NOT
102226: AND
102227: IFFALSE 102271
// begin ComMoveXY ( unit , _x , _y ) ;
102229: LD_VAR 0 1
102233: PPUSH
102234: LD_VAR 0 5
102238: PPUSH
102239: LD_VAR 0 7
102243: PPUSH
102244: CALL_OW 111
// result := [ _x , _y ] ;
102248: LD_ADDR_VAR 0 3
102252: PUSH
102253: LD_VAR 0 5
102257: PUSH
102258: LD_VAR 0 7
102262: PUSH
102263: EMPTY
102264: LIST
102265: LIST
102266: ST_TO_ADDR
// exit ;
102267: POP
102268: POP
102269: GO 102275
// end ; end ;
102271: GO 102115
102273: POP
102274: POP
// end ; end_of_file end_of_file
102275: LD_VAR 0 3
102279: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
102280: LD_VAR 0 2
102284: PUSH
102285: LD_INT 100
102287: EQUAL
102288: IFFALSE 103237
// begin if not StreamModeActive then
102290: LD_EXP 156
102294: NOT
102295: IFFALSE 102305
// StreamModeActive := true ;
102297: LD_ADDR_EXP 156
102301: PUSH
102302: LD_INT 1
102304: ST_TO_ADDR
// if p3 = 0 then
102305: LD_VAR 0 3
102309: PUSH
102310: LD_INT 0
102312: EQUAL
102313: IFFALSE 102319
// InitStreamMode ;
102315: CALL 103395 0 0
// if p3 = 1 then
102319: LD_VAR 0 3
102323: PUSH
102324: LD_INT 1
102326: EQUAL
102327: IFFALSE 102337
// sRocket := true ;
102329: LD_ADDR_EXP 161
102333: PUSH
102334: LD_INT 1
102336: ST_TO_ADDR
// if p3 = 2 then
102337: LD_VAR 0 3
102341: PUSH
102342: LD_INT 2
102344: EQUAL
102345: IFFALSE 102355
// sSpeed := true ;
102347: LD_ADDR_EXP 160
102351: PUSH
102352: LD_INT 1
102354: ST_TO_ADDR
// if p3 = 3 then
102355: LD_VAR 0 3
102359: PUSH
102360: LD_INT 3
102362: EQUAL
102363: IFFALSE 102373
// sEngine := true ;
102365: LD_ADDR_EXP 162
102369: PUSH
102370: LD_INT 1
102372: ST_TO_ADDR
// if p3 = 4 then
102373: LD_VAR 0 3
102377: PUSH
102378: LD_INT 4
102380: EQUAL
102381: IFFALSE 102391
// sSpec := true ;
102383: LD_ADDR_EXP 159
102387: PUSH
102388: LD_INT 1
102390: ST_TO_ADDR
// if p3 = 5 then
102391: LD_VAR 0 3
102395: PUSH
102396: LD_INT 5
102398: EQUAL
102399: IFFALSE 102409
// sLevel := true ;
102401: LD_ADDR_EXP 163
102405: PUSH
102406: LD_INT 1
102408: ST_TO_ADDR
// if p3 = 6 then
102409: LD_VAR 0 3
102413: PUSH
102414: LD_INT 6
102416: EQUAL
102417: IFFALSE 102427
// sArmoury := true ;
102419: LD_ADDR_EXP 164
102423: PUSH
102424: LD_INT 1
102426: ST_TO_ADDR
// if p3 = 7 then
102427: LD_VAR 0 3
102431: PUSH
102432: LD_INT 7
102434: EQUAL
102435: IFFALSE 102445
// sRadar := true ;
102437: LD_ADDR_EXP 165
102441: PUSH
102442: LD_INT 1
102444: ST_TO_ADDR
// if p3 = 8 then
102445: LD_VAR 0 3
102449: PUSH
102450: LD_INT 8
102452: EQUAL
102453: IFFALSE 102463
// sBunker := true ;
102455: LD_ADDR_EXP 166
102459: PUSH
102460: LD_INT 1
102462: ST_TO_ADDR
// if p3 = 9 then
102463: LD_VAR 0 3
102467: PUSH
102468: LD_INT 9
102470: EQUAL
102471: IFFALSE 102481
// sHack := true ;
102473: LD_ADDR_EXP 167
102477: PUSH
102478: LD_INT 1
102480: ST_TO_ADDR
// if p3 = 10 then
102481: LD_VAR 0 3
102485: PUSH
102486: LD_INT 10
102488: EQUAL
102489: IFFALSE 102499
// sFire := true ;
102491: LD_ADDR_EXP 168
102495: PUSH
102496: LD_INT 1
102498: ST_TO_ADDR
// if p3 = 11 then
102499: LD_VAR 0 3
102503: PUSH
102504: LD_INT 11
102506: EQUAL
102507: IFFALSE 102517
// sRefresh := true ;
102509: LD_ADDR_EXP 169
102513: PUSH
102514: LD_INT 1
102516: ST_TO_ADDR
// if p3 = 12 then
102517: LD_VAR 0 3
102521: PUSH
102522: LD_INT 12
102524: EQUAL
102525: IFFALSE 102535
// sExp := true ;
102527: LD_ADDR_EXP 170
102531: PUSH
102532: LD_INT 1
102534: ST_TO_ADDR
// if p3 = 13 then
102535: LD_VAR 0 3
102539: PUSH
102540: LD_INT 13
102542: EQUAL
102543: IFFALSE 102553
// sDepot := true ;
102545: LD_ADDR_EXP 171
102549: PUSH
102550: LD_INT 1
102552: ST_TO_ADDR
// if p3 = 14 then
102553: LD_VAR 0 3
102557: PUSH
102558: LD_INT 14
102560: EQUAL
102561: IFFALSE 102571
// sFlag := true ;
102563: LD_ADDR_EXP 172
102567: PUSH
102568: LD_INT 1
102570: ST_TO_ADDR
// if p3 = 15 then
102571: LD_VAR 0 3
102575: PUSH
102576: LD_INT 15
102578: EQUAL
102579: IFFALSE 102589
// sKamikadze := true ;
102581: LD_ADDR_EXP 180
102585: PUSH
102586: LD_INT 1
102588: ST_TO_ADDR
// if p3 = 16 then
102589: LD_VAR 0 3
102593: PUSH
102594: LD_INT 16
102596: EQUAL
102597: IFFALSE 102607
// sTroll := true ;
102599: LD_ADDR_EXP 181
102603: PUSH
102604: LD_INT 1
102606: ST_TO_ADDR
// if p3 = 17 then
102607: LD_VAR 0 3
102611: PUSH
102612: LD_INT 17
102614: EQUAL
102615: IFFALSE 102625
// sSlow := true ;
102617: LD_ADDR_EXP 182
102621: PUSH
102622: LD_INT 1
102624: ST_TO_ADDR
// if p3 = 18 then
102625: LD_VAR 0 3
102629: PUSH
102630: LD_INT 18
102632: EQUAL
102633: IFFALSE 102643
// sLack := true ;
102635: LD_ADDR_EXP 183
102639: PUSH
102640: LD_INT 1
102642: ST_TO_ADDR
// if p3 = 19 then
102643: LD_VAR 0 3
102647: PUSH
102648: LD_INT 19
102650: EQUAL
102651: IFFALSE 102661
// sTank := true ;
102653: LD_ADDR_EXP 185
102657: PUSH
102658: LD_INT 1
102660: ST_TO_ADDR
// if p3 = 20 then
102661: LD_VAR 0 3
102665: PUSH
102666: LD_INT 20
102668: EQUAL
102669: IFFALSE 102679
// sRemote := true ;
102671: LD_ADDR_EXP 186
102675: PUSH
102676: LD_INT 1
102678: ST_TO_ADDR
// if p3 = 21 then
102679: LD_VAR 0 3
102683: PUSH
102684: LD_INT 21
102686: EQUAL
102687: IFFALSE 102697
// sPowell := true ;
102689: LD_ADDR_EXP 187
102693: PUSH
102694: LD_INT 1
102696: ST_TO_ADDR
// if p3 = 22 then
102697: LD_VAR 0 3
102701: PUSH
102702: LD_INT 22
102704: EQUAL
102705: IFFALSE 102715
// sTeleport := true ;
102707: LD_ADDR_EXP 190
102711: PUSH
102712: LD_INT 1
102714: ST_TO_ADDR
// if p3 = 23 then
102715: LD_VAR 0 3
102719: PUSH
102720: LD_INT 23
102722: EQUAL
102723: IFFALSE 102733
// sOilTower := true ;
102725: LD_ADDR_EXP 192
102729: PUSH
102730: LD_INT 1
102732: ST_TO_ADDR
// if p3 = 24 then
102733: LD_VAR 0 3
102737: PUSH
102738: LD_INT 24
102740: EQUAL
102741: IFFALSE 102751
// sShovel := true ;
102743: LD_ADDR_EXP 193
102747: PUSH
102748: LD_INT 1
102750: ST_TO_ADDR
// if p3 = 25 then
102751: LD_VAR 0 3
102755: PUSH
102756: LD_INT 25
102758: EQUAL
102759: IFFALSE 102769
// sSheik := true ;
102761: LD_ADDR_EXP 194
102765: PUSH
102766: LD_INT 1
102768: ST_TO_ADDR
// if p3 = 26 then
102769: LD_VAR 0 3
102773: PUSH
102774: LD_INT 26
102776: EQUAL
102777: IFFALSE 102787
// sEarthquake := true ;
102779: LD_ADDR_EXP 196
102783: PUSH
102784: LD_INT 1
102786: ST_TO_ADDR
// if p3 = 27 then
102787: LD_VAR 0 3
102791: PUSH
102792: LD_INT 27
102794: EQUAL
102795: IFFALSE 102805
// sAI := true ;
102797: LD_ADDR_EXP 197
102801: PUSH
102802: LD_INT 1
102804: ST_TO_ADDR
// if p3 = 28 then
102805: LD_VAR 0 3
102809: PUSH
102810: LD_INT 28
102812: EQUAL
102813: IFFALSE 102823
// sCargo := true ;
102815: LD_ADDR_EXP 200
102819: PUSH
102820: LD_INT 1
102822: ST_TO_ADDR
// if p3 = 29 then
102823: LD_VAR 0 3
102827: PUSH
102828: LD_INT 29
102830: EQUAL
102831: IFFALSE 102841
// sDLaser := true ;
102833: LD_ADDR_EXP 201
102837: PUSH
102838: LD_INT 1
102840: ST_TO_ADDR
// if p3 = 30 then
102841: LD_VAR 0 3
102845: PUSH
102846: LD_INT 30
102848: EQUAL
102849: IFFALSE 102859
// sExchange := true ;
102851: LD_ADDR_EXP 202
102855: PUSH
102856: LD_INT 1
102858: ST_TO_ADDR
// if p3 = 31 then
102859: LD_VAR 0 3
102863: PUSH
102864: LD_INT 31
102866: EQUAL
102867: IFFALSE 102877
// sFac := true ;
102869: LD_ADDR_EXP 203
102873: PUSH
102874: LD_INT 1
102876: ST_TO_ADDR
// if p3 = 32 then
102877: LD_VAR 0 3
102881: PUSH
102882: LD_INT 32
102884: EQUAL
102885: IFFALSE 102895
// sPower := true ;
102887: LD_ADDR_EXP 204
102891: PUSH
102892: LD_INT 1
102894: ST_TO_ADDR
// if p3 = 33 then
102895: LD_VAR 0 3
102899: PUSH
102900: LD_INT 33
102902: EQUAL
102903: IFFALSE 102913
// sRandom := true ;
102905: LD_ADDR_EXP 205
102909: PUSH
102910: LD_INT 1
102912: ST_TO_ADDR
// if p3 = 34 then
102913: LD_VAR 0 3
102917: PUSH
102918: LD_INT 34
102920: EQUAL
102921: IFFALSE 102931
// sShield := true ;
102923: LD_ADDR_EXP 206
102927: PUSH
102928: LD_INT 1
102930: ST_TO_ADDR
// if p3 = 35 then
102931: LD_VAR 0 3
102935: PUSH
102936: LD_INT 35
102938: EQUAL
102939: IFFALSE 102949
// sTime := true ;
102941: LD_ADDR_EXP 207
102945: PUSH
102946: LD_INT 1
102948: ST_TO_ADDR
// if p3 = 36 then
102949: LD_VAR 0 3
102953: PUSH
102954: LD_INT 36
102956: EQUAL
102957: IFFALSE 102967
// sTools := true ;
102959: LD_ADDR_EXP 208
102963: PUSH
102964: LD_INT 1
102966: ST_TO_ADDR
// if p3 = 101 then
102967: LD_VAR 0 3
102971: PUSH
102972: LD_INT 101
102974: EQUAL
102975: IFFALSE 102985
// sSold := true ;
102977: LD_ADDR_EXP 173
102981: PUSH
102982: LD_INT 1
102984: ST_TO_ADDR
// if p3 = 102 then
102985: LD_VAR 0 3
102989: PUSH
102990: LD_INT 102
102992: EQUAL
102993: IFFALSE 103003
// sDiff := true ;
102995: LD_ADDR_EXP 174
102999: PUSH
103000: LD_INT 1
103002: ST_TO_ADDR
// if p3 = 103 then
103003: LD_VAR 0 3
103007: PUSH
103008: LD_INT 103
103010: EQUAL
103011: IFFALSE 103021
// sFog := true ;
103013: LD_ADDR_EXP 177
103017: PUSH
103018: LD_INT 1
103020: ST_TO_ADDR
// if p3 = 104 then
103021: LD_VAR 0 3
103025: PUSH
103026: LD_INT 104
103028: EQUAL
103029: IFFALSE 103039
// sReset := true ;
103031: LD_ADDR_EXP 178
103035: PUSH
103036: LD_INT 1
103038: ST_TO_ADDR
// if p3 = 105 then
103039: LD_VAR 0 3
103043: PUSH
103044: LD_INT 105
103046: EQUAL
103047: IFFALSE 103057
// sSun := true ;
103049: LD_ADDR_EXP 179
103053: PUSH
103054: LD_INT 1
103056: ST_TO_ADDR
// if p3 = 106 then
103057: LD_VAR 0 3
103061: PUSH
103062: LD_INT 106
103064: EQUAL
103065: IFFALSE 103075
// sTiger := true ;
103067: LD_ADDR_EXP 175
103071: PUSH
103072: LD_INT 1
103074: ST_TO_ADDR
// if p3 = 107 then
103075: LD_VAR 0 3
103079: PUSH
103080: LD_INT 107
103082: EQUAL
103083: IFFALSE 103093
// sBomb := true ;
103085: LD_ADDR_EXP 176
103089: PUSH
103090: LD_INT 1
103092: ST_TO_ADDR
// if p3 = 108 then
103093: LD_VAR 0 3
103097: PUSH
103098: LD_INT 108
103100: EQUAL
103101: IFFALSE 103111
// sWound := true ;
103103: LD_ADDR_EXP 184
103107: PUSH
103108: LD_INT 1
103110: ST_TO_ADDR
// if p3 = 109 then
103111: LD_VAR 0 3
103115: PUSH
103116: LD_INT 109
103118: EQUAL
103119: IFFALSE 103129
// sBetray := true ;
103121: LD_ADDR_EXP 188
103125: PUSH
103126: LD_INT 1
103128: ST_TO_ADDR
// if p3 = 110 then
103129: LD_VAR 0 3
103133: PUSH
103134: LD_INT 110
103136: EQUAL
103137: IFFALSE 103147
// sContamin := true ;
103139: LD_ADDR_EXP 189
103143: PUSH
103144: LD_INT 1
103146: ST_TO_ADDR
// if p3 = 111 then
103147: LD_VAR 0 3
103151: PUSH
103152: LD_INT 111
103154: EQUAL
103155: IFFALSE 103165
// sOil := true ;
103157: LD_ADDR_EXP 191
103161: PUSH
103162: LD_INT 1
103164: ST_TO_ADDR
// if p3 = 112 then
103165: LD_VAR 0 3
103169: PUSH
103170: LD_INT 112
103172: EQUAL
103173: IFFALSE 103183
// sStu := true ;
103175: LD_ADDR_EXP 195
103179: PUSH
103180: LD_INT 1
103182: ST_TO_ADDR
// if p3 = 113 then
103183: LD_VAR 0 3
103187: PUSH
103188: LD_INT 113
103190: EQUAL
103191: IFFALSE 103201
// sBazooka := true ;
103193: LD_ADDR_EXP 198
103197: PUSH
103198: LD_INT 1
103200: ST_TO_ADDR
// if p3 = 114 then
103201: LD_VAR 0 3
103205: PUSH
103206: LD_INT 114
103208: EQUAL
103209: IFFALSE 103219
// sMortar := true ;
103211: LD_ADDR_EXP 199
103215: PUSH
103216: LD_INT 1
103218: ST_TO_ADDR
// if p3 = 115 then
103219: LD_VAR 0 3
103223: PUSH
103224: LD_INT 115
103226: EQUAL
103227: IFFALSE 103237
// sRanger := true ;
103229: LD_ADDR_EXP 209
103233: PUSH
103234: LD_INT 1
103236: ST_TO_ADDR
// end ; if p2 = 101 then
103237: LD_VAR 0 2
103241: PUSH
103242: LD_INT 101
103244: EQUAL
103245: IFFALSE 103373
// begin case p3 of 1 :
103247: LD_VAR 0 3
103251: PUSH
103252: LD_INT 1
103254: DOUBLE
103255: EQUAL
103256: IFTRUE 103260
103258: GO 103267
103260: POP
// hHackUnlimitedResources ; 2 :
103261: CALL 114408 0 0
103265: GO 103373
103267: LD_INT 2
103269: DOUBLE
103270: EQUAL
103271: IFTRUE 103275
103273: GO 103282
103275: POP
// hHackSetLevel10 ; 3 :
103276: CALL 114541 0 0
103280: GO 103373
103282: LD_INT 3
103284: DOUBLE
103285: EQUAL
103286: IFTRUE 103290
103288: GO 103297
103290: POP
// hHackSetLevel10YourUnits ; 4 :
103291: CALL 114626 0 0
103295: GO 103373
103297: LD_INT 4
103299: DOUBLE
103300: EQUAL
103301: IFTRUE 103305
103303: GO 103312
103305: POP
// hHackInvincible ; 5 :
103306: CALL 115074 0 0
103310: GO 103373
103312: LD_INT 5
103314: DOUBLE
103315: EQUAL
103316: IFTRUE 103320
103318: GO 103327
103320: POP
// hHackInvisible ; 6 :
103321: CALL 115185 0 0
103325: GO 103373
103327: LD_INT 6
103329: DOUBLE
103330: EQUAL
103331: IFTRUE 103335
103333: GO 103342
103335: POP
// hHackChangeYourSide ; 7 :
103336: CALL 115242 0 0
103340: GO 103373
103342: LD_INT 7
103344: DOUBLE
103345: EQUAL
103346: IFTRUE 103350
103348: GO 103357
103350: POP
// hHackChangeUnitSide ; 8 :
103351: CALL 115284 0 0
103355: GO 103373
103357: LD_INT 8
103359: DOUBLE
103360: EQUAL
103361: IFTRUE 103365
103363: GO 103372
103365: POP
// hHackFog ; end ;
103366: CALL 115385 0 0
103370: GO 103373
103372: POP
// end ; end ;
103373: PPOPN 6
103375: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
103376: GO 103378
103378: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
103379: LD_STRING initStreamRollete();
103381: PPUSH
103382: CALL_OW 559
// InitStreamMode ;
103386: CALL 103395 0 0
// DefineStreamItems ( ) ;
103390: CALL 103835 0 0
// end ;
103394: END
// function InitStreamMode ; begin
103395: LD_INT 0
103397: PPUSH
// streamModeActive := false ;
103398: LD_ADDR_EXP 156
103402: PUSH
103403: LD_INT 0
103405: ST_TO_ADDR
// normalCounter := 36 ;
103406: LD_ADDR_EXP 157
103410: PUSH
103411: LD_INT 36
103413: ST_TO_ADDR
// hardcoreCounter := 16 ;
103414: LD_ADDR_EXP 158
103418: PUSH
103419: LD_INT 16
103421: ST_TO_ADDR
// sRocket := false ;
103422: LD_ADDR_EXP 161
103426: PUSH
103427: LD_INT 0
103429: ST_TO_ADDR
// sSpeed := false ;
103430: LD_ADDR_EXP 160
103434: PUSH
103435: LD_INT 0
103437: ST_TO_ADDR
// sEngine := false ;
103438: LD_ADDR_EXP 162
103442: PUSH
103443: LD_INT 0
103445: ST_TO_ADDR
// sSpec := false ;
103446: LD_ADDR_EXP 159
103450: PUSH
103451: LD_INT 0
103453: ST_TO_ADDR
// sLevel := false ;
103454: LD_ADDR_EXP 163
103458: PUSH
103459: LD_INT 0
103461: ST_TO_ADDR
// sArmoury := false ;
103462: LD_ADDR_EXP 164
103466: PUSH
103467: LD_INT 0
103469: ST_TO_ADDR
// sRadar := false ;
103470: LD_ADDR_EXP 165
103474: PUSH
103475: LD_INT 0
103477: ST_TO_ADDR
// sBunker := false ;
103478: LD_ADDR_EXP 166
103482: PUSH
103483: LD_INT 0
103485: ST_TO_ADDR
// sHack := false ;
103486: LD_ADDR_EXP 167
103490: PUSH
103491: LD_INT 0
103493: ST_TO_ADDR
// sFire := false ;
103494: LD_ADDR_EXP 168
103498: PUSH
103499: LD_INT 0
103501: ST_TO_ADDR
// sRefresh := false ;
103502: LD_ADDR_EXP 169
103506: PUSH
103507: LD_INT 0
103509: ST_TO_ADDR
// sExp := false ;
103510: LD_ADDR_EXP 170
103514: PUSH
103515: LD_INT 0
103517: ST_TO_ADDR
// sDepot := false ;
103518: LD_ADDR_EXP 171
103522: PUSH
103523: LD_INT 0
103525: ST_TO_ADDR
// sFlag := false ;
103526: LD_ADDR_EXP 172
103530: PUSH
103531: LD_INT 0
103533: ST_TO_ADDR
// sKamikadze := false ;
103534: LD_ADDR_EXP 180
103538: PUSH
103539: LD_INT 0
103541: ST_TO_ADDR
// sTroll := false ;
103542: LD_ADDR_EXP 181
103546: PUSH
103547: LD_INT 0
103549: ST_TO_ADDR
// sSlow := false ;
103550: LD_ADDR_EXP 182
103554: PUSH
103555: LD_INT 0
103557: ST_TO_ADDR
// sLack := false ;
103558: LD_ADDR_EXP 183
103562: PUSH
103563: LD_INT 0
103565: ST_TO_ADDR
// sTank := false ;
103566: LD_ADDR_EXP 185
103570: PUSH
103571: LD_INT 0
103573: ST_TO_ADDR
// sRemote := false ;
103574: LD_ADDR_EXP 186
103578: PUSH
103579: LD_INT 0
103581: ST_TO_ADDR
// sPowell := false ;
103582: LD_ADDR_EXP 187
103586: PUSH
103587: LD_INT 0
103589: ST_TO_ADDR
// sTeleport := false ;
103590: LD_ADDR_EXP 190
103594: PUSH
103595: LD_INT 0
103597: ST_TO_ADDR
// sOilTower := false ;
103598: LD_ADDR_EXP 192
103602: PUSH
103603: LD_INT 0
103605: ST_TO_ADDR
// sShovel := false ;
103606: LD_ADDR_EXP 193
103610: PUSH
103611: LD_INT 0
103613: ST_TO_ADDR
// sSheik := false ;
103614: LD_ADDR_EXP 194
103618: PUSH
103619: LD_INT 0
103621: ST_TO_ADDR
// sEarthquake := false ;
103622: LD_ADDR_EXP 196
103626: PUSH
103627: LD_INT 0
103629: ST_TO_ADDR
// sAI := false ;
103630: LD_ADDR_EXP 197
103634: PUSH
103635: LD_INT 0
103637: ST_TO_ADDR
// sCargo := false ;
103638: LD_ADDR_EXP 200
103642: PUSH
103643: LD_INT 0
103645: ST_TO_ADDR
// sDLaser := false ;
103646: LD_ADDR_EXP 201
103650: PUSH
103651: LD_INT 0
103653: ST_TO_ADDR
// sExchange := false ;
103654: LD_ADDR_EXP 202
103658: PUSH
103659: LD_INT 0
103661: ST_TO_ADDR
// sFac := false ;
103662: LD_ADDR_EXP 203
103666: PUSH
103667: LD_INT 0
103669: ST_TO_ADDR
// sPower := false ;
103670: LD_ADDR_EXP 204
103674: PUSH
103675: LD_INT 0
103677: ST_TO_ADDR
// sRandom := false ;
103678: LD_ADDR_EXP 205
103682: PUSH
103683: LD_INT 0
103685: ST_TO_ADDR
// sShield := false ;
103686: LD_ADDR_EXP 206
103690: PUSH
103691: LD_INT 0
103693: ST_TO_ADDR
// sTime := false ;
103694: LD_ADDR_EXP 207
103698: PUSH
103699: LD_INT 0
103701: ST_TO_ADDR
// sTools := false ;
103702: LD_ADDR_EXP 208
103706: PUSH
103707: LD_INT 0
103709: ST_TO_ADDR
// sSold := false ;
103710: LD_ADDR_EXP 173
103714: PUSH
103715: LD_INT 0
103717: ST_TO_ADDR
// sDiff := false ;
103718: LD_ADDR_EXP 174
103722: PUSH
103723: LD_INT 0
103725: ST_TO_ADDR
// sFog := false ;
103726: LD_ADDR_EXP 177
103730: PUSH
103731: LD_INT 0
103733: ST_TO_ADDR
// sReset := false ;
103734: LD_ADDR_EXP 178
103738: PUSH
103739: LD_INT 0
103741: ST_TO_ADDR
// sSun := false ;
103742: LD_ADDR_EXP 179
103746: PUSH
103747: LD_INT 0
103749: ST_TO_ADDR
// sTiger := false ;
103750: LD_ADDR_EXP 175
103754: PUSH
103755: LD_INT 0
103757: ST_TO_ADDR
// sBomb := false ;
103758: LD_ADDR_EXP 176
103762: PUSH
103763: LD_INT 0
103765: ST_TO_ADDR
// sWound := false ;
103766: LD_ADDR_EXP 184
103770: PUSH
103771: LD_INT 0
103773: ST_TO_ADDR
// sBetray := false ;
103774: LD_ADDR_EXP 188
103778: PUSH
103779: LD_INT 0
103781: ST_TO_ADDR
// sContamin := false ;
103782: LD_ADDR_EXP 189
103786: PUSH
103787: LD_INT 0
103789: ST_TO_ADDR
// sOil := false ;
103790: LD_ADDR_EXP 191
103794: PUSH
103795: LD_INT 0
103797: ST_TO_ADDR
// sStu := false ;
103798: LD_ADDR_EXP 195
103802: PUSH
103803: LD_INT 0
103805: ST_TO_ADDR
// sBazooka := false ;
103806: LD_ADDR_EXP 198
103810: PUSH
103811: LD_INT 0
103813: ST_TO_ADDR
// sMortar := false ;
103814: LD_ADDR_EXP 199
103818: PUSH
103819: LD_INT 0
103821: ST_TO_ADDR
// sRanger := false ;
103822: LD_ADDR_EXP 209
103826: PUSH
103827: LD_INT 0
103829: ST_TO_ADDR
// end ;
103830: LD_VAR 0 1
103834: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
103835: LD_INT 0
103837: PPUSH
103838: PPUSH
103839: PPUSH
103840: PPUSH
103841: PPUSH
// result := [ ] ;
103842: LD_ADDR_VAR 0 1
103846: PUSH
103847: EMPTY
103848: ST_TO_ADDR
// if campaign_id = 1 then
103849: LD_OWVAR 69
103853: PUSH
103854: LD_INT 1
103856: EQUAL
103857: IFFALSE 106795
// begin case mission_number of 1 :
103859: LD_OWVAR 70
103863: PUSH
103864: LD_INT 1
103866: DOUBLE
103867: EQUAL
103868: IFTRUE 103872
103870: GO 103936
103872: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
103873: LD_ADDR_VAR 0 1
103877: PUSH
103878: LD_INT 2
103880: PUSH
103881: LD_INT 4
103883: PUSH
103884: LD_INT 11
103886: PUSH
103887: LD_INT 12
103889: PUSH
103890: LD_INT 15
103892: PUSH
103893: LD_INT 16
103895: PUSH
103896: LD_INT 22
103898: PUSH
103899: LD_INT 23
103901: PUSH
103902: LD_INT 26
103904: PUSH
103905: EMPTY
103906: LIST
103907: LIST
103908: LIST
103909: LIST
103910: LIST
103911: LIST
103912: LIST
103913: LIST
103914: LIST
103915: PUSH
103916: LD_INT 101
103918: PUSH
103919: LD_INT 102
103921: PUSH
103922: LD_INT 106
103924: PUSH
103925: EMPTY
103926: LIST
103927: LIST
103928: LIST
103929: PUSH
103930: EMPTY
103931: LIST
103932: LIST
103933: ST_TO_ADDR
103934: GO 106793
103936: LD_INT 2
103938: DOUBLE
103939: EQUAL
103940: IFTRUE 103944
103942: GO 104016
103944: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
103945: LD_ADDR_VAR 0 1
103949: PUSH
103950: LD_INT 2
103952: PUSH
103953: LD_INT 4
103955: PUSH
103956: LD_INT 11
103958: PUSH
103959: LD_INT 12
103961: PUSH
103962: LD_INT 15
103964: PUSH
103965: LD_INT 16
103967: PUSH
103968: LD_INT 22
103970: PUSH
103971: LD_INT 23
103973: PUSH
103974: LD_INT 26
103976: PUSH
103977: EMPTY
103978: LIST
103979: LIST
103980: LIST
103981: LIST
103982: LIST
103983: LIST
103984: LIST
103985: LIST
103986: LIST
103987: PUSH
103988: LD_INT 101
103990: PUSH
103991: LD_INT 102
103993: PUSH
103994: LD_INT 105
103996: PUSH
103997: LD_INT 106
103999: PUSH
104000: LD_INT 108
104002: PUSH
104003: EMPTY
104004: LIST
104005: LIST
104006: LIST
104007: LIST
104008: LIST
104009: PUSH
104010: EMPTY
104011: LIST
104012: LIST
104013: ST_TO_ADDR
104014: GO 106793
104016: LD_INT 3
104018: DOUBLE
104019: EQUAL
104020: IFTRUE 104024
104022: GO 104100
104024: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
104025: LD_ADDR_VAR 0 1
104029: PUSH
104030: LD_INT 2
104032: PUSH
104033: LD_INT 4
104035: PUSH
104036: LD_INT 5
104038: PUSH
104039: LD_INT 11
104041: PUSH
104042: LD_INT 12
104044: PUSH
104045: LD_INT 15
104047: PUSH
104048: LD_INT 16
104050: PUSH
104051: LD_INT 22
104053: PUSH
104054: LD_INT 26
104056: PUSH
104057: LD_INT 36
104059: PUSH
104060: EMPTY
104061: LIST
104062: LIST
104063: LIST
104064: LIST
104065: LIST
104066: LIST
104067: LIST
104068: LIST
104069: LIST
104070: LIST
104071: PUSH
104072: LD_INT 101
104074: PUSH
104075: LD_INT 102
104077: PUSH
104078: LD_INT 105
104080: PUSH
104081: LD_INT 106
104083: PUSH
104084: LD_INT 108
104086: PUSH
104087: EMPTY
104088: LIST
104089: LIST
104090: LIST
104091: LIST
104092: LIST
104093: PUSH
104094: EMPTY
104095: LIST
104096: LIST
104097: ST_TO_ADDR
104098: GO 106793
104100: LD_INT 4
104102: DOUBLE
104103: EQUAL
104104: IFTRUE 104108
104106: GO 104192
104108: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
104109: LD_ADDR_VAR 0 1
104113: PUSH
104114: LD_INT 2
104116: PUSH
104117: LD_INT 4
104119: PUSH
104120: LD_INT 5
104122: PUSH
104123: LD_INT 8
104125: PUSH
104126: LD_INT 11
104128: PUSH
104129: LD_INT 12
104131: PUSH
104132: LD_INT 15
104134: PUSH
104135: LD_INT 16
104137: PUSH
104138: LD_INT 22
104140: PUSH
104141: LD_INT 23
104143: PUSH
104144: LD_INT 26
104146: PUSH
104147: LD_INT 36
104149: PUSH
104150: EMPTY
104151: LIST
104152: LIST
104153: LIST
104154: LIST
104155: LIST
104156: LIST
104157: LIST
104158: LIST
104159: LIST
104160: LIST
104161: LIST
104162: LIST
104163: PUSH
104164: LD_INT 101
104166: PUSH
104167: LD_INT 102
104169: PUSH
104170: LD_INT 105
104172: PUSH
104173: LD_INT 106
104175: PUSH
104176: LD_INT 108
104178: PUSH
104179: EMPTY
104180: LIST
104181: LIST
104182: LIST
104183: LIST
104184: LIST
104185: PUSH
104186: EMPTY
104187: LIST
104188: LIST
104189: ST_TO_ADDR
104190: GO 106793
104192: LD_INT 5
104194: DOUBLE
104195: EQUAL
104196: IFTRUE 104200
104198: GO 104300
104200: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
104201: LD_ADDR_VAR 0 1
104205: PUSH
104206: LD_INT 2
104208: PUSH
104209: LD_INT 4
104211: PUSH
104212: LD_INT 5
104214: PUSH
104215: LD_INT 6
104217: PUSH
104218: LD_INT 8
104220: PUSH
104221: LD_INT 11
104223: PUSH
104224: LD_INT 12
104226: PUSH
104227: LD_INT 15
104229: PUSH
104230: LD_INT 16
104232: PUSH
104233: LD_INT 22
104235: PUSH
104236: LD_INT 23
104238: PUSH
104239: LD_INT 25
104241: PUSH
104242: LD_INT 26
104244: PUSH
104245: LD_INT 36
104247: PUSH
104248: EMPTY
104249: LIST
104250: LIST
104251: LIST
104252: LIST
104253: LIST
104254: LIST
104255: LIST
104256: LIST
104257: LIST
104258: LIST
104259: LIST
104260: LIST
104261: LIST
104262: LIST
104263: PUSH
104264: LD_INT 101
104266: PUSH
104267: LD_INT 102
104269: PUSH
104270: LD_INT 105
104272: PUSH
104273: LD_INT 106
104275: PUSH
104276: LD_INT 108
104278: PUSH
104279: LD_INT 109
104281: PUSH
104282: LD_INT 112
104284: PUSH
104285: EMPTY
104286: LIST
104287: LIST
104288: LIST
104289: LIST
104290: LIST
104291: LIST
104292: LIST
104293: PUSH
104294: EMPTY
104295: LIST
104296: LIST
104297: ST_TO_ADDR
104298: GO 106793
104300: LD_INT 6
104302: DOUBLE
104303: EQUAL
104304: IFTRUE 104308
104306: GO 104428
104308: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
104309: LD_ADDR_VAR 0 1
104313: PUSH
104314: LD_INT 2
104316: PUSH
104317: LD_INT 4
104319: PUSH
104320: LD_INT 5
104322: PUSH
104323: LD_INT 6
104325: PUSH
104326: LD_INT 8
104328: PUSH
104329: LD_INT 11
104331: PUSH
104332: LD_INT 12
104334: PUSH
104335: LD_INT 15
104337: PUSH
104338: LD_INT 16
104340: PUSH
104341: LD_INT 20
104343: PUSH
104344: LD_INT 21
104346: PUSH
104347: LD_INT 22
104349: PUSH
104350: LD_INT 23
104352: PUSH
104353: LD_INT 25
104355: PUSH
104356: LD_INT 26
104358: PUSH
104359: LD_INT 30
104361: PUSH
104362: LD_INT 31
104364: PUSH
104365: LD_INT 32
104367: PUSH
104368: LD_INT 36
104370: PUSH
104371: EMPTY
104372: LIST
104373: LIST
104374: LIST
104375: LIST
104376: LIST
104377: LIST
104378: LIST
104379: LIST
104380: LIST
104381: LIST
104382: LIST
104383: LIST
104384: LIST
104385: LIST
104386: LIST
104387: LIST
104388: LIST
104389: LIST
104390: LIST
104391: PUSH
104392: LD_INT 101
104394: PUSH
104395: LD_INT 102
104397: PUSH
104398: LD_INT 105
104400: PUSH
104401: LD_INT 106
104403: PUSH
104404: LD_INT 108
104406: PUSH
104407: LD_INT 109
104409: PUSH
104410: LD_INT 112
104412: PUSH
104413: EMPTY
104414: LIST
104415: LIST
104416: LIST
104417: LIST
104418: LIST
104419: LIST
104420: LIST
104421: PUSH
104422: EMPTY
104423: LIST
104424: LIST
104425: ST_TO_ADDR
104426: GO 106793
104428: LD_INT 7
104430: DOUBLE
104431: EQUAL
104432: IFTRUE 104436
104434: GO 104536
104436: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
104437: LD_ADDR_VAR 0 1
104441: PUSH
104442: LD_INT 2
104444: PUSH
104445: LD_INT 4
104447: PUSH
104448: LD_INT 5
104450: PUSH
104451: LD_INT 7
104453: PUSH
104454: LD_INT 11
104456: PUSH
104457: LD_INT 12
104459: PUSH
104460: LD_INT 15
104462: PUSH
104463: LD_INT 16
104465: PUSH
104466: LD_INT 20
104468: PUSH
104469: LD_INT 21
104471: PUSH
104472: LD_INT 22
104474: PUSH
104475: LD_INT 23
104477: PUSH
104478: LD_INT 25
104480: PUSH
104481: LD_INT 26
104483: PUSH
104484: EMPTY
104485: LIST
104486: LIST
104487: LIST
104488: LIST
104489: LIST
104490: LIST
104491: LIST
104492: LIST
104493: LIST
104494: LIST
104495: LIST
104496: LIST
104497: LIST
104498: LIST
104499: PUSH
104500: LD_INT 101
104502: PUSH
104503: LD_INT 102
104505: PUSH
104506: LD_INT 103
104508: PUSH
104509: LD_INT 105
104511: PUSH
104512: LD_INT 106
104514: PUSH
104515: LD_INT 108
104517: PUSH
104518: LD_INT 112
104520: PUSH
104521: EMPTY
104522: LIST
104523: LIST
104524: LIST
104525: LIST
104526: LIST
104527: LIST
104528: LIST
104529: PUSH
104530: EMPTY
104531: LIST
104532: LIST
104533: ST_TO_ADDR
104534: GO 106793
104536: LD_INT 8
104538: DOUBLE
104539: EQUAL
104540: IFTRUE 104544
104542: GO 104672
104544: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
104545: LD_ADDR_VAR 0 1
104549: PUSH
104550: LD_INT 2
104552: PUSH
104553: LD_INT 4
104555: PUSH
104556: LD_INT 5
104558: PUSH
104559: LD_INT 6
104561: PUSH
104562: LD_INT 7
104564: PUSH
104565: LD_INT 8
104567: PUSH
104568: LD_INT 11
104570: PUSH
104571: LD_INT 12
104573: PUSH
104574: LD_INT 15
104576: PUSH
104577: LD_INT 16
104579: PUSH
104580: LD_INT 20
104582: PUSH
104583: LD_INT 21
104585: PUSH
104586: LD_INT 22
104588: PUSH
104589: LD_INT 23
104591: PUSH
104592: LD_INT 25
104594: PUSH
104595: LD_INT 26
104597: PUSH
104598: LD_INT 30
104600: PUSH
104601: LD_INT 31
104603: PUSH
104604: LD_INT 32
104606: PUSH
104607: LD_INT 36
104609: PUSH
104610: EMPTY
104611: LIST
104612: LIST
104613: LIST
104614: LIST
104615: LIST
104616: LIST
104617: LIST
104618: LIST
104619: LIST
104620: LIST
104621: LIST
104622: LIST
104623: LIST
104624: LIST
104625: LIST
104626: LIST
104627: LIST
104628: LIST
104629: LIST
104630: LIST
104631: PUSH
104632: LD_INT 101
104634: PUSH
104635: LD_INT 102
104637: PUSH
104638: LD_INT 103
104640: PUSH
104641: LD_INT 105
104643: PUSH
104644: LD_INT 106
104646: PUSH
104647: LD_INT 108
104649: PUSH
104650: LD_INT 109
104652: PUSH
104653: LD_INT 112
104655: PUSH
104656: EMPTY
104657: LIST
104658: LIST
104659: LIST
104660: LIST
104661: LIST
104662: LIST
104663: LIST
104664: LIST
104665: PUSH
104666: EMPTY
104667: LIST
104668: LIST
104669: ST_TO_ADDR
104670: GO 106793
104672: LD_INT 9
104674: DOUBLE
104675: EQUAL
104676: IFTRUE 104680
104678: GO 104816
104680: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
104681: LD_ADDR_VAR 0 1
104685: PUSH
104686: LD_INT 2
104688: PUSH
104689: LD_INT 4
104691: PUSH
104692: LD_INT 5
104694: PUSH
104695: LD_INT 6
104697: PUSH
104698: LD_INT 7
104700: PUSH
104701: LD_INT 8
104703: PUSH
104704: LD_INT 11
104706: PUSH
104707: LD_INT 12
104709: PUSH
104710: LD_INT 15
104712: PUSH
104713: LD_INT 16
104715: PUSH
104716: LD_INT 20
104718: PUSH
104719: LD_INT 21
104721: PUSH
104722: LD_INT 22
104724: PUSH
104725: LD_INT 23
104727: PUSH
104728: LD_INT 25
104730: PUSH
104731: LD_INT 26
104733: PUSH
104734: LD_INT 28
104736: PUSH
104737: LD_INT 30
104739: PUSH
104740: LD_INT 31
104742: PUSH
104743: LD_INT 32
104745: PUSH
104746: LD_INT 36
104748: PUSH
104749: EMPTY
104750: LIST
104751: LIST
104752: LIST
104753: LIST
104754: LIST
104755: LIST
104756: LIST
104757: LIST
104758: LIST
104759: LIST
104760: LIST
104761: LIST
104762: LIST
104763: LIST
104764: LIST
104765: LIST
104766: LIST
104767: LIST
104768: LIST
104769: LIST
104770: LIST
104771: PUSH
104772: LD_INT 101
104774: PUSH
104775: LD_INT 102
104777: PUSH
104778: LD_INT 103
104780: PUSH
104781: LD_INT 105
104783: PUSH
104784: LD_INT 106
104786: PUSH
104787: LD_INT 108
104789: PUSH
104790: LD_INT 109
104792: PUSH
104793: LD_INT 112
104795: PUSH
104796: LD_INT 114
104798: PUSH
104799: EMPTY
104800: LIST
104801: LIST
104802: LIST
104803: LIST
104804: LIST
104805: LIST
104806: LIST
104807: LIST
104808: LIST
104809: PUSH
104810: EMPTY
104811: LIST
104812: LIST
104813: ST_TO_ADDR
104814: GO 106793
104816: LD_INT 10
104818: DOUBLE
104819: EQUAL
104820: IFTRUE 104824
104822: GO 105008
104824: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
104825: LD_ADDR_VAR 0 1
104829: PUSH
104830: LD_INT 2
104832: PUSH
104833: LD_INT 4
104835: PUSH
104836: LD_INT 5
104838: PUSH
104839: LD_INT 6
104841: PUSH
104842: LD_INT 7
104844: PUSH
104845: LD_INT 8
104847: PUSH
104848: LD_INT 9
104850: PUSH
104851: LD_INT 10
104853: PUSH
104854: LD_INT 11
104856: PUSH
104857: LD_INT 12
104859: PUSH
104860: LD_INT 13
104862: PUSH
104863: LD_INT 14
104865: PUSH
104866: LD_INT 15
104868: PUSH
104869: LD_INT 16
104871: PUSH
104872: LD_INT 17
104874: PUSH
104875: LD_INT 18
104877: PUSH
104878: LD_INT 19
104880: PUSH
104881: LD_INT 20
104883: PUSH
104884: LD_INT 21
104886: PUSH
104887: LD_INT 22
104889: PUSH
104890: LD_INT 23
104892: PUSH
104893: LD_INT 24
104895: PUSH
104896: LD_INT 25
104898: PUSH
104899: LD_INT 26
104901: PUSH
104902: LD_INT 28
104904: PUSH
104905: LD_INT 30
104907: PUSH
104908: LD_INT 31
104910: PUSH
104911: LD_INT 32
104913: PUSH
104914: LD_INT 36
104916: PUSH
104917: EMPTY
104918: LIST
104919: LIST
104920: LIST
104921: LIST
104922: LIST
104923: LIST
104924: LIST
104925: LIST
104926: LIST
104927: LIST
104928: LIST
104929: LIST
104930: LIST
104931: LIST
104932: LIST
104933: LIST
104934: LIST
104935: LIST
104936: LIST
104937: LIST
104938: LIST
104939: LIST
104940: LIST
104941: LIST
104942: LIST
104943: LIST
104944: LIST
104945: LIST
104946: LIST
104947: PUSH
104948: LD_INT 101
104950: PUSH
104951: LD_INT 102
104953: PUSH
104954: LD_INT 103
104956: PUSH
104957: LD_INT 104
104959: PUSH
104960: LD_INT 105
104962: PUSH
104963: LD_INT 106
104965: PUSH
104966: LD_INT 107
104968: PUSH
104969: LD_INT 108
104971: PUSH
104972: LD_INT 109
104974: PUSH
104975: LD_INT 110
104977: PUSH
104978: LD_INT 111
104980: PUSH
104981: LD_INT 112
104983: PUSH
104984: LD_INT 114
104986: PUSH
104987: EMPTY
104988: LIST
104989: LIST
104990: LIST
104991: LIST
104992: LIST
104993: LIST
104994: LIST
104995: LIST
104996: LIST
104997: LIST
104998: LIST
104999: LIST
105000: LIST
105001: PUSH
105002: EMPTY
105003: LIST
105004: LIST
105005: ST_TO_ADDR
105006: GO 106793
105008: LD_INT 11
105010: DOUBLE
105011: EQUAL
105012: IFTRUE 105016
105014: GO 105208
105016: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
105017: LD_ADDR_VAR 0 1
105021: PUSH
105022: LD_INT 2
105024: PUSH
105025: LD_INT 3
105027: PUSH
105028: LD_INT 4
105030: PUSH
105031: LD_INT 5
105033: PUSH
105034: LD_INT 6
105036: PUSH
105037: LD_INT 7
105039: PUSH
105040: LD_INT 8
105042: PUSH
105043: LD_INT 9
105045: PUSH
105046: LD_INT 10
105048: PUSH
105049: LD_INT 11
105051: PUSH
105052: LD_INT 12
105054: PUSH
105055: LD_INT 13
105057: PUSH
105058: LD_INT 14
105060: PUSH
105061: LD_INT 15
105063: PUSH
105064: LD_INT 16
105066: PUSH
105067: LD_INT 17
105069: PUSH
105070: LD_INT 18
105072: PUSH
105073: LD_INT 19
105075: PUSH
105076: LD_INT 20
105078: PUSH
105079: LD_INT 21
105081: PUSH
105082: LD_INT 22
105084: PUSH
105085: LD_INT 23
105087: PUSH
105088: LD_INT 24
105090: PUSH
105091: LD_INT 25
105093: PUSH
105094: LD_INT 26
105096: PUSH
105097: LD_INT 28
105099: PUSH
105100: LD_INT 30
105102: PUSH
105103: LD_INT 31
105105: PUSH
105106: LD_INT 32
105108: PUSH
105109: LD_INT 34
105111: PUSH
105112: LD_INT 36
105114: PUSH
105115: EMPTY
105116: LIST
105117: LIST
105118: LIST
105119: LIST
105120: LIST
105121: LIST
105122: LIST
105123: LIST
105124: LIST
105125: LIST
105126: LIST
105127: LIST
105128: LIST
105129: LIST
105130: LIST
105131: LIST
105132: LIST
105133: LIST
105134: LIST
105135: LIST
105136: LIST
105137: LIST
105138: LIST
105139: LIST
105140: LIST
105141: LIST
105142: LIST
105143: LIST
105144: LIST
105145: LIST
105146: LIST
105147: PUSH
105148: LD_INT 101
105150: PUSH
105151: LD_INT 102
105153: PUSH
105154: LD_INT 103
105156: PUSH
105157: LD_INT 104
105159: PUSH
105160: LD_INT 105
105162: PUSH
105163: LD_INT 106
105165: PUSH
105166: LD_INT 107
105168: PUSH
105169: LD_INT 108
105171: PUSH
105172: LD_INT 109
105174: PUSH
105175: LD_INT 110
105177: PUSH
105178: LD_INT 111
105180: PUSH
105181: LD_INT 112
105183: PUSH
105184: LD_INT 114
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: LIST
105191: LIST
105192: LIST
105193: LIST
105194: LIST
105195: LIST
105196: LIST
105197: LIST
105198: LIST
105199: LIST
105200: LIST
105201: PUSH
105202: EMPTY
105203: LIST
105204: LIST
105205: ST_TO_ADDR
105206: GO 106793
105208: LD_INT 12
105210: DOUBLE
105211: EQUAL
105212: IFTRUE 105216
105214: GO 105424
105216: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
105217: LD_ADDR_VAR 0 1
105221: PUSH
105222: LD_INT 1
105224: PUSH
105225: LD_INT 2
105227: PUSH
105228: LD_INT 3
105230: PUSH
105231: LD_INT 4
105233: PUSH
105234: LD_INT 5
105236: PUSH
105237: LD_INT 6
105239: PUSH
105240: LD_INT 7
105242: PUSH
105243: LD_INT 8
105245: PUSH
105246: LD_INT 9
105248: PUSH
105249: LD_INT 10
105251: PUSH
105252: LD_INT 11
105254: PUSH
105255: LD_INT 12
105257: PUSH
105258: LD_INT 13
105260: PUSH
105261: LD_INT 14
105263: PUSH
105264: LD_INT 15
105266: PUSH
105267: LD_INT 16
105269: PUSH
105270: LD_INT 17
105272: PUSH
105273: LD_INT 18
105275: PUSH
105276: LD_INT 19
105278: PUSH
105279: LD_INT 20
105281: PUSH
105282: LD_INT 21
105284: PUSH
105285: LD_INT 22
105287: PUSH
105288: LD_INT 23
105290: PUSH
105291: LD_INT 24
105293: PUSH
105294: LD_INT 25
105296: PUSH
105297: LD_INT 26
105299: PUSH
105300: LD_INT 27
105302: PUSH
105303: LD_INT 28
105305: PUSH
105306: LD_INT 30
105308: PUSH
105309: LD_INT 31
105311: PUSH
105312: LD_INT 32
105314: PUSH
105315: LD_INT 33
105317: PUSH
105318: LD_INT 34
105320: PUSH
105321: LD_INT 36
105323: PUSH
105324: EMPTY
105325: LIST
105326: LIST
105327: LIST
105328: LIST
105329: LIST
105330: LIST
105331: LIST
105332: LIST
105333: LIST
105334: LIST
105335: LIST
105336: LIST
105337: LIST
105338: LIST
105339: LIST
105340: LIST
105341: LIST
105342: LIST
105343: LIST
105344: LIST
105345: LIST
105346: LIST
105347: LIST
105348: LIST
105349: LIST
105350: LIST
105351: LIST
105352: LIST
105353: LIST
105354: LIST
105355: LIST
105356: LIST
105357: LIST
105358: LIST
105359: PUSH
105360: LD_INT 101
105362: PUSH
105363: LD_INT 102
105365: PUSH
105366: LD_INT 103
105368: PUSH
105369: LD_INT 104
105371: PUSH
105372: LD_INT 105
105374: PUSH
105375: LD_INT 106
105377: PUSH
105378: LD_INT 107
105380: PUSH
105381: LD_INT 108
105383: PUSH
105384: LD_INT 109
105386: PUSH
105387: LD_INT 110
105389: PUSH
105390: LD_INT 111
105392: PUSH
105393: LD_INT 112
105395: PUSH
105396: LD_INT 113
105398: PUSH
105399: LD_INT 114
105401: PUSH
105402: EMPTY
105403: LIST
105404: LIST
105405: LIST
105406: LIST
105407: LIST
105408: LIST
105409: LIST
105410: LIST
105411: LIST
105412: LIST
105413: LIST
105414: LIST
105415: LIST
105416: LIST
105417: PUSH
105418: EMPTY
105419: LIST
105420: LIST
105421: ST_TO_ADDR
105422: GO 106793
105424: LD_INT 13
105426: DOUBLE
105427: EQUAL
105428: IFTRUE 105432
105430: GO 105628
105432: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
105433: LD_ADDR_VAR 0 1
105437: PUSH
105438: LD_INT 1
105440: PUSH
105441: LD_INT 2
105443: PUSH
105444: LD_INT 3
105446: PUSH
105447: LD_INT 4
105449: PUSH
105450: LD_INT 5
105452: PUSH
105453: LD_INT 8
105455: PUSH
105456: LD_INT 9
105458: PUSH
105459: LD_INT 10
105461: PUSH
105462: LD_INT 11
105464: PUSH
105465: LD_INT 12
105467: PUSH
105468: LD_INT 14
105470: PUSH
105471: LD_INT 15
105473: PUSH
105474: LD_INT 16
105476: PUSH
105477: LD_INT 17
105479: PUSH
105480: LD_INT 18
105482: PUSH
105483: LD_INT 19
105485: PUSH
105486: LD_INT 20
105488: PUSH
105489: LD_INT 21
105491: PUSH
105492: LD_INT 22
105494: PUSH
105495: LD_INT 23
105497: PUSH
105498: LD_INT 24
105500: PUSH
105501: LD_INT 25
105503: PUSH
105504: LD_INT 26
105506: PUSH
105507: LD_INT 27
105509: PUSH
105510: LD_INT 28
105512: PUSH
105513: LD_INT 30
105515: PUSH
105516: LD_INT 31
105518: PUSH
105519: LD_INT 32
105521: PUSH
105522: LD_INT 33
105524: PUSH
105525: LD_INT 34
105527: PUSH
105528: LD_INT 36
105530: PUSH
105531: EMPTY
105532: LIST
105533: LIST
105534: LIST
105535: LIST
105536: LIST
105537: LIST
105538: LIST
105539: LIST
105540: LIST
105541: LIST
105542: LIST
105543: LIST
105544: LIST
105545: LIST
105546: LIST
105547: LIST
105548: LIST
105549: LIST
105550: LIST
105551: LIST
105552: LIST
105553: LIST
105554: LIST
105555: LIST
105556: LIST
105557: LIST
105558: LIST
105559: LIST
105560: LIST
105561: LIST
105562: LIST
105563: PUSH
105564: LD_INT 101
105566: PUSH
105567: LD_INT 102
105569: PUSH
105570: LD_INT 103
105572: PUSH
105573: LD_INT 104
105575: PUSH
105576: LD_INT 105
105578: PUSH
105579: LD_INT 106
105581: PUSH
105582: LD_INT 107
105584: PUSH
105585: LD_INT 108
105587: PUSH
105588: LD_INT 109
105590: PUSH
105591: LD_INT 110
105593: PUSH
105594: LD_INT 111
105596: PUSH
105597: LD_INT 112
105599: PUSH
105600: LD_INT 113
105602: PUSH
105603: LD_INT 114
105605: PUSH
105606: EMPTY
105607: LIST
105608: LIST
105609: LIST
105610: LIST
105611: LIST
105612: LIST
105613: LIST
105614: LIST
105615: LIST
105616: LIST
105617: LIST
105618: LIST
105619: LIST
105620: LIST
105621: PUSH
105622: EMPTY
105623: LIST
105624: LIST
105625: ST_TO_ADDR
105626: GO 106793
105628: LD_INT 14
105630: DOUBLE
105631: EQUAL
105632: IFTRUE 105636
105634: GO 105848
105636: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
105637: LD_ADDR_VAR 0 1
105641: PUSH
105642: LD_INT 1
105644: PUSH
105645: LD_INT 2
105647: PUSH
105648: LD_INT 3
105650: PUSH
105651: LD_INT 4
105653: PUSH
105654: LD_INT 5
105656: PUSH
105657: LD_INT 6
105659: PUSH
105660: LD_INT 7
105662: PUSH
105663: LD_INT 8
105665: PUSH
105666: LD_INT 9
105668: PUSH
105669: LD_INT 10
105671: PUSH
105672: LD_INT 11
105674: PUSH
105675: LD_INT 12
105677: PUSH
105678: LD_INT 13
105680: PUSH
105681: LD_INT 14
105683: PUSH
105684: LD_INT 15
105686: PUSH
105687: LD_INT 16
105689: PUSH
105690: LD_INT 17
105692: PUSH
105693: LD_INT 18
105695: PUSH
105696: LD_INT 19
105698: PUSH
105699: LD_INT 20
105701: PUSH
105702: LD_INT 21
105704: PUSH
105705: LD_INT 22
105707: PUSH
105708: LD_INT 23
105710: PUSH
105711: LD_INT 24
105713: PUSH
105714: LD_INT 25
105716: PUSH
105717: LD_INT 26
105719: PUSH
105720: LD_INT 27
105722: PUSH
105723: LD_INT 28
105725: PUSH
105726: LD_INT 29
105728: PUSH
105729: LD_INT 30
105731: PUSH
105732: LD_INT 31
105734: PUSH
105735: LD_INT 32
105737: PUSH
105738: LD_INT 33
105740: PUSH
105741: LD_INT 34
105743: PUSH
105744: LD_INT 36
105746: PUSH
105747: EMPTY
105748: LIST
105749: LIST
105750: LIST
105751: LIST
105752: LIST
105753: LIST
105754: LIST
105755: LIST
105756: LIST
105757: LIST
105758: LIST
105759: LIST
105760: LIST
105761: LIST
105762: LIST
105763: LIST
105764: LIST
105765: LIST
105766: LIST
105767: LIST
105768: LIST
105769: LIST
105770: LIST
105771: LIST
105772: LIST
105773: LIST
105774: LIST
105775: LIST
105776: LIST
105777: LIST
105778: LIST
105779: LIST
105780: LIST
105781: LIST
105782: LIST
105783: PUSH
105784: LD_INT 101
105786: PUSH
105787: LD_INT 102
105789: PUSH
105790: LD_INT 103
105792: PUSH
105793: LD_INT 104
105795: PUSH
105796: LD_INT 105
105798: PUSH
105799: LD_INT 106
105801: PUSH
105802: LD_INT 107
105804: PUSH
105805: LD_INT 108
105807: PUSH
105808: LD_INT 109
105810: PUSH
105811: LD_INT 110
105813: PUSH
105814: LD_INT 111
105816: PUSH
105817: LD_INT 112
105819: PUSH
105820: LD_INT 113
105822: PUSH
105823: LD_INT 114
105825: PUSH
105826: EMPTY
105827: LIST
105828: LIST
105829: LIST
105830: LIST
105831: LIST
105832: LIST
105833: LIST
105834: LIST
105835: LIST
105836: LIST
105837: LIST
105838: LIST
105839: LIST
105840: LIST
105841: PUSH
105842: EMPTY
105843: LIST
105844: LIST
105845: ST_TO_ADDR
105846: GO 106793
105848: LD_INT 15
105850: DOUBLE
105851: EQUAL
105852: IFTRUE 105856
105854: GO 106068
105856: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
105857: LD_ADDR_VAR 0 1
105861: PUSH
105862: LD_INT 1
105864: PUSH
105865: LD_INT 2
105867: PUSH
105868: LD_INT 3
105870: PUSH
105871: LD_INT 4
105873: PUSH
105874: LD_INT 5
105876: PUSH
105877: LD_INT 6
105879: PUSH
105880: LD_INT 7
105882: PUSH
105883: LD_INT 8
105885: PUSH
105886: LD_INT 9
105888: PUSH
105889: LD_INT 10
105891: PUSH
105892: LD_INT 11
105894: PUSH
105895: LD_INT 12
105897: PUSH
105898: LD_INT 13
105900: PUSH
105901: LD_INT 14
105903: PUSH
105904: LD_INT 15
105906: PUSH
105907: LD_INT 16
105909: PUSH
105910: LD_INT 17
105912: PUSH
105913: LD_INT 18
105915: PUSH
105916: LD_INT 19
105918: PUSH
105919: LD_INT 20
105921: PUSH
105922: LD_INT 21
105924: PUSH
105925: LD_INT 22
105927: PUSH
105928: LD_INT 23
105930: PUSH
105931: LD_INT 24
105933: PUSH
105934: LD_INT 25
105936: PUSH
105937: LD_INT 26
105939: PUSH
105940: LD_INT 27
105942: PUSH
105943: LD_INT 28
105945: PUSH
105946: LD_INT 29
105948: PUSH
105949: LD_INT 30
105951: PUSH
105952: LD_INT 31
105954: PUSH
105955: LD_INT 32
105957: PUSH
105958: LD_INT 33
105960: PUSH
105961: LD_INT 34
105963: PUSH
105964: LD_INT 36
105966: PUSH
105967: EMPTY
105968: LIST
105969: LIST
105970: LIST
105971: LIST
105972: LIST
105973: LIST
105974: LIST
105975: LIST
105976: LIST
105977: LIST
105978: LIST
105979: LIST
105980: LIST
105981: LIST
105982: LIST
105983: LIST
105984: LIST
105985: LIST
105986: LIST
105987: LIST
105988: LIST
105989: LIST
105990: LIST
105991: LIST
105992: LIST
105993: LIST
105994: LIST
105995: LIST
105996: LIST
105997: LIST
105998: LIST
105999: LIST
106000: LIST
106001: LIST
106002: LIST
106003: PUSH
106004: LD_INT 101
106006: PUSH
106007: LD_INT 102
106009: PUSH
106010: LD_INT 103
106012: PUSH
106013: LD_INT 104
106015: PUSH
106016: LD_INT 105
106018: PUSH
106019: LD_INT 106
106021: PUSH
106022: LD_INT 107
106024: PUSH
106025: LD_INT 108
106027: PUSH
106028: LD_INT 109
106030: PUSH
106031: LD_INT 110
106033: PUSH
106034: LD_INT 111
106036: PUSH
106037: LD_INT 112
106039: PUSH
106040: LD_INT 113
106042: PUSH
106043: LD_INT 114
106045: PUSH
106046: EMPTY
106047: LIST
106048: LIST
106049: LIST
106050: LIST
106051: LIST
106052: LIST
106053: LIST
106054: LIST
106055: LIST
106056: LIST
106057: LIST
106058: LIST
106059: LIST
106060: LIST
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: ST_TO_ADDR
106066: GO 106793
106068: LD_INT 16
106070: DOUBLE
106071: EQUAL
106072: IFTRUE 106076
106074: GO 106200
106076: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
106077: LD_ADDR_VAR 0 1
106081: PUSH
106082: LD_INT 2
106084: PUSH
106085: LD_INT 4
106087: PUSH
106088: LD_INT 5
106090: PUSH
106091: LD_INT 7
106093: PUSH
106094: LD_INT 11
106096: PUSH
106097: LD_INT 12
106099: PUSH
106100: LD_INT 15
106102: PUSH
106103: LD_INT 16
106105: PUSH
106106: LD_INT 20
106108: PUSH
106109: LD_INT 21
106111: PUSH
106112: LD_INT 22
106114: PUSH
106115: LD_INT 23
106117: PUSH
106118: LD_INT 25
106120: PUSH
106121: LD_INT 26
106123: PUSH
106124: LD_INT 30
106126: PUSH
106127: LD_INT 31
106129: PUSH
106130: LD_INT 32
106132: PUSH
106133: LD_INT 33
106135: PUSH
106136: LD_INT 34
106138: PUSH
106139: EMPTY
106140: LIST
106141: LIST
106142: LIST
106143: LIST
106144: LIST
106145: LIST
106146: LIST
106147: LIST
106148: LIST
106149: LIST
106150: LIST
106151: LIST
106152: LIST
106153: LIST
106154: LIST
106155: LIST
106156: LIST
106157: LIST
106158: LIST
106159: PUSH
106160: LD_INT 101
106162: PUSH
106163: LD_INT 102
106165: PUSH
106166: LD_INT 103
106168: PUSH
106169: LD_INT 106
106171: PUSH
106172: LD_INT 108
106174: PUSH
106175: LD_INT 112
106177: PUSH
106178: LD_INT 113
106180: PUSH
106181: LD_INT 114
106183: PUSH
106184: EMPTY
106185: LIST
106186: LIST
106187: LIST
106188: LIST
106189: LIST
106190: LIST
106191: LIST
106192: LIST
106193: PUSH
106194: EMPTY
106195: LIST
106196: LIST
106197: ST_TO_ADDR
106198: GO 106793
106200: LD_INT 17
106202: DOUBLE
106203: EQUAL
106204: IFTRUE 106208
106206: GO 106420
106208: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
106209: LD_ADDR_VAR 0 1
106213: PUSH
106214: LD_INT 1
106216: PUSH
106217: LD_INT 2
106219: PUSH
106220: LD_INT 3
106222: PUSH
106223: LD_INT 4
106225: PUSH
106226: LD_INT 5
106228: PUSH
106229: LD_INT 6
106231: PUSH
106232: LD_INT 7
106234: PUSH
106235: LD_INT 8
106237: PUSH
106238: LD_INT 9
106240: PUSH
106241: LD_INT 10
106243: PUSH
106244: LD_INT 11
106246: PUSH
106247: LD_INT 12
106249: PUSH
106250: LD_INT 13
106252: PUSH
106253: LD_INT 14
106255: PUSH
106256: LD_INT 15
106258: PUSH
106259: LD_INT 16
106261: PUSH
106262: LD_INT 17
106264: PUSH
106265: LD_INT 18
106267: PUSH
106268: LD_INT 19
106270: PUSH
106271: LD_INT 20
106273: PUSH
106274: LD_INT 21
106276: PUSH
106277: LD_INT 22
106279: PUSH
106280: LD_INT 23
106282: PUSH
106283: LD_INT 24
106285: PUSH
106286: LD_INT 25
106288: PUSH
106289: LD_INT 26
106291: PUSH
106292: LD_INT 27
106294: PUSH
106295: LD_INT 28
106297: PUSH
106298: LD_INT 29
106300: PUSH
106301: LD_INT 30
106303: PUSH
106304: LD_INT 31
106306: PUSH
106307: LD_INT 32
106309: PUSH
106310: LD_INT 33
106312: PUSH
106313: LD_INT 34
106315: PUSH
106316: LD_INT 36
106318: PUSH
106319: EMPTY
106320: LIST
106321: LIST
106322: LIST
106323: LIST
106324: LIST
106325: LIST
106326: LIST
106327: LIST
106328: LIST
106329: LIST
106330: LIST
106331: LIST
106332: LIST
106333: LIST
106334: LIST
106335: LIST
106336: LIST
106337: LIST
106338: LIST
106339: LIST
106340: LIST
106341: LIST
106342: LIST
106343: LIST
106344: LIST
106345: LIST
106346: LIST
106347: LIST
106348: LIST
106349: LIST
106350: LIST
106351: LIST
106352: LIST
106353: LIST
106354: LIST
106355: PUSH
106356: LD_INT 101
106358: PUSH
106359: LD_INT 102
106361: PUSH
106362: LD_INT 103
106364: PUSH
106365: LD_INT 104
106367: PUSH
106368: LD_INT 105
106370: PUSH
106371: LD_INT 106
106373: PUSH
106374: LD_INT 107
106376: PUSH
106377: LD_INT 108
106379: PUSH
106380: LD_INT 109
106382: PUSH
106383: LD_INT 110
106385: PUSH
106386: LD_INT 111
106388: PUSH
106389: LD_INT 112
106391: PUSH
106392: LD_INT 113
106394: PUSH
106395: LD_INT 114
106397: PUSH
106398: EMPTY
106399: LIST
106400: LIST
106401: LIST
106402: LIST
106403: LIST
106404: LIST
106405: LIST
106406: LIST
106407: LIST
106408: LIST
106409: LIST
106410: LIST
106411: LIST
106412: LIST
106413: PUSH
106414: EMPTY
106415: LIST
106416: LIST
106417: ST_TO_ADDR
106418: GO 106793
106420: LD_INT 18
106422: DOUBLE
106423: EQUAL
106424: IFTRUE 106428
106426: GO 106564
106428: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
106429: LD_ADDR_VAR 0 1
106433: PUSH
106434: LD_INT 2
106436: PUSH
106437: LD_INT 4
106439: PUSH
106440: LD_INT 5
106442: PUSH
106443: LD_INT 7
106445: PUSH
106446: LD_INT 11
106448: PUSH
106449: LD_INT 12
106451: PUSH
106452: LD_INT 15
106454: PUSH
106455: LD_INT 16
106457: PUSH
106458: LD_INT 20
106460: PUSH
106461: LD_INT 21
106463: PUSH
106464: LD_INT 22
106466: PUSH
106467: LD_INT 23
106469: PUSH
106470: LD_INT 25
106472: PUSH
106473: LD_INT 26
106475: PUSH
106476: LD_INT 30
106478: PUSH
106479: LD_INT 31
106481: PUSH
106482: LD_INT 32
106484: PUSH
106485: LD_INT 33
106487: PUSH
106488: LD_INT 34
106490: PUSH
106491: LD_INT 35
106493: PUSH
106494: LD_INT 36
106496: PUSH
106497: EMPTY
106498: LIST
106499: LIST
106500: LIST
106501: LIST
106502: LIST
106503: LIST
106504: LIST
106505: LIST
106506: LIST
106507: LIST
106508: LIST
106509: LIST
106510: LIST
106511: LIST
106512: LIST
106513: LIST
106514: LIST
106515: LIST
106516: LIST
106517: LIST
106518: LIST
106519: PUSH
106520: LD_INT 101
106522: PUSH
106523: LD_INT 102
106525: PUSH
106526: LD_INT 103
106528: PUSH
106529: LD_INT 106
106531: PUSH
106532: LD_INT 108
106534: PUSH
106535: LD_INT 112
106537: PUSH
106538: LD_INT 113
106540: PUSH
106541: LD_INT 114
106543: PUSH
106544: LD_INT 115
106546: PUSH
106547: EMPTY
106548: LIST
106549: LIST
106550: LIST
106551: LIST
106552: LIST
106553: LIST
106554: LIST
106555: LIST
106556: LIST
106557: PUSH
106558: EMPTY
106559: LIST
106560: LIST
106561: ST_TO_ADDR
106562: GO 106793
106564: LD_INT 19
106566: DOUBLE
106567: EQUAL
106568: IFTRUE 106572
106570: GO 106792
106572: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
106573: LD_ADDR_VAR 0 1
106577: PUSH
106578: LD_INT 1
106580: PUSH
106581: LD_INT 2
106583: PUSH
106584: LD_INT 3
106586: PUSH
106587: LD_INT 4
106589: PUSH
106590: LD_INT 5
106592: PUSH
106593: LD_INT 6
106595: PUSH
106596: LD_INT 7
106598: PUSH
106599: LD_INT 8
106601: PUSH
106602: LD_INT 9
106604: PUSH
106605: LD_INT 10
106607: PUSH
106608: LD_INT 11
106610: PUSH
106611: LD_INT 12
106613: PUSH
106614: LD_INT 13
106616: PUSH
106617: LD_INT 14
106619: PUSH
106620: LD_INT 15
106622: PUSH
106623: LD_INT 16
106625: PUSH
106626: LD_INT 17
106628: PUSH
106629: LD_INT 18
106631: PUSH
106632: LD_INT 19
106634: PUSH
106635: LD_INT 20
106637: PUSH
106638: LD_INT 21
106640: PUSH
106641: LD_INT 22
106643: PUSH
106644: LD_INT 23
106646: PUSH
106647: LD_INT 24
106649: PUSH
106650: LD_INT 25
106652: PUSH
106653: LD_INT 26
106655: PUSH
106656: LD_INT 27
106658: PUSH
106659: LD_INT 28
106661: PUSH
106662: LD_INT 29
106664: PUSH
106665: LD_INT 30
106667: PUSH
106668: LD_INT 31
106670: PUSH
106671: LD_INT 32
106673: PUSH
106674: LD_INT 33
106676: PUSH
106677: LD_INT 34
106679: PUSH
106680: LD_INT 35
106682: PUSH
106683: LD_INT 36
106685: PUSH
106686: EMPTY
106687: LIST
106688: LIST
106689: LIST
106690: LIST
106691: LIST
106692: LIST
106693: LIST
106694: LIST
106695: LIST
106696: LIST
106697: LIST
106698: LIST
106699: LIST
106700: LIST
106701: LIST
106702: LIST
106703: LIST
106704: LIST
106705: LIST
106706: LIST
106707: LIST
106708: LIST
106709: LIST
106710: LIST
106711: LIST
106712: LIST
106713: LIST
106714: LIST
106715: LIST
106716: LIST
106717: LIST
106718: LIST
106719: LIST
106720: LIST
106721: LIST
106722: LIST
106723: PUSH
106724: LD_INT 101
106726: PUSH
106727: LD_INT 102
106729: PUSH
106730: LD_INT 103
106732: PUSH
106733: LD_INT 104
106735: PUSH
106736: LD_INT 105
106738: PUSH
106739: LD_INT 106
106741: PUSH
106742: LD_INT 107
106744: PUSH
106745: LD_INT 108
106747: PUSH
106748: LD_INT 109
106750: PUSH
106751: LD_INT 110
106753: PUSH
106754: LD_INT 111
106756: PUSH
106757: LD_INT 112
106759: PUSH
106760: LD_INT 113
106762: PUSH
106763: LD_INT 114
106765: PUSH
106766: LD_INT 115
106768: PUSH
106769: EMPTY
106770: LIST
106771: LIST
106772: LIST
106773: LIST
106774: LIST
106775: LIST
106776: LIST
106777: LIST
106778: LIST
106779: LIST
106780: LIST
106781: LIST
106782: LIST
106783: LIST
106784: LIST
106785: PUSH
106786: EMPTY
106787: LIST
106788: LIST
106789: ST_TO_ADDR
106790: GO 106793
106792: POP
// end else
106793: GO 107012
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
106795: LD_ADDR_VAR 0 1
106799: PUSH
106800: LD_INT 1
106802: PUSH
106803: LD_INT 2
106805: PUSH
106806: LD_INT 3
106808: PUSH
106809: LD_INT 4
106811: PUSH
106812: LD_INT 5
106814: PUSH
106815: LD_INT 6
106817: PUSH
106818: LD_INT 7
106820: PUSH
106821: LD_INT 8
106823: PUSH
106824: LD_INT 9
106826: PUSH
106827: LD_INT 10
106829: PUSH
106830: LD_INT 11
106832: PUSH
106833: LD_INT 12
106835: PUSH
106836: LD_INT 13
106838: PUSH
106839: LD_INT 14
106841: PUSH
106842: LD_INT 15
106844: PUSH
106845: LD_INT 16
106847: PUSH
106848: LD_INT 17
106850: PUSH
106851: LD_INT 18
106853: PUSH
106854: LD_INT 19
106856: PUSH
106857: LD_INT 20
106859: PUSH
106860: LD_INT 21
106862: PUSH
106863: LD_INT 22
106865: PUSH
106866: LD_INT 23
106868: PUSH
106869: LD_INT 24
106871: PUSH
106872: LD_INT 25
106874: PUSH
106875: LD_INT 26
106877: PUSH
106878: LD_INT 27
106880: PUSH
106881: LD_INT 28
106883: PUSH
106884: LD_INT 29
106886: PUSH
106887: LD_INT 30
106889: PUSH
106890: LD_INT 31
106892: PUSH
106893: LD_INT 32
106895: PUSH
106896: LD_INT 33
106898: PUSH
106899: LD_INT 34
106901: PUSH
106902: LD_INT 35
106904: PUSH
106905: LD_INT 36
106907: PUSH
106908: EMPTY
106909: LIST
106910: LIST
106911: LIST
106912: LIST
106913: LIST
106914: LIST
106915: LIST
106916: LIST
106917: LIST
106918: LIST
106919: LIST
106920: LIST
106921: LIST
106922: LIST
106923: LIST
106924: LIST
106925: LIST
106926: LIST
106927: LIST
106928: LIST
106929: LIST
106930: LIST
106931: LIST
106932: LIST
106933: LIST
106934: LIST
106935: LIST
106936: LIST
106937: LIST
106938: LIST
106939: LIST
106940: LIST
106941: LIST
106942: LIST
106943: LIST
106944: LIST
106945: PUSH
106946: LD_INT 101
106948: PUSH
106949: LD_INT 102
106951: PUSH
106952: LD_INT 103
106954: PUSH
106955: LD_INT 104
106957: PUSH
106958: LD_INT 105
106960: PUSH
106961: LD_INT 106
106963: PUSH
106964: LD_INT 107
106966: PUSH
106967: LD_INT 108
106969: PUSH
106970: LD_INT 109
106972: PUSH
106973: LD_INT 110
106975: PUSH
106976: LD_INT 111
106978: PUSH
106979: LD_INT 112
106981: PUSH
106982: LD_INT 113
106984: PUSH
106985: LD_INT 114
106987: PUSH
106988: LD_INT 115
106990: PUSH
106991: EMPTY
106992: LIST
106993: LIST
106994: LIST
106995: LIST
106996: LIST
106997: LIST
106998: LIST
106999: LIST
107000: LIST
107001: LIST
107002: LIST
107003: LIST
107004: LIST
107005: LIST
107006: LIST
107007: PUSH
107008: EMPTY
107009: LIST
107010: LIST
107011: ST_TO_ADDR
// if result then
107012: LD_VAR 0 1
107016: IFFALSE 107305
// begin normal :=  ;
107018: LD_ADDR_VAR 0 3
107022: PUSH
107023: LD_STRING 
107025: ST_TO_ADDR
// hardcore :=  ;
107026: LD_ADDR_VAR 0 4
107030: PUSH
107031: LD_STRING 
107033: ST_TO_ADDR
// for i = 1 to normalCounter do
107034: LD_ADDR_VAR 0 5
107038: PUSH
107039: DOUBLE
107040: LD_INT 1
107042: DEC
107043: ST_TO_ADDR
107044: LD_EXP 157
107048: PUSH
107049: FOR_TO
107050: IFFALSE 107151
// begin tmp := 0 ;
107052: LD_ADDR_VAR 0 2
107056: PUSH
107057: LD_STRING 0
107059: ST_TO_ADDR
// if result [ 1 ] then
107060: LD_VAR 0 1
107064: PUSH
107065: LD_INT 1
107067: ARRAY
107068: IFFALSE 107133
// if result [ 1 ] [ 1 ] = i then
107070: LD_VAR 0 1
107074: PUSH
107075: LD_INT 1
107077: ARRAY
107078: PUSH
107079: LD_INT 1
107081: ARRAY
107082: PUSH
107083: LD_VAR 0 5
107087: EQUAL
107088: IFFALSE 107133
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
107090: LD_ADDR_VAR 0 1
107094: PUSH
107095: LD_VAR 0 1
107099: PPUSH
107100: LD_INT 1
107102: PPUSH
107103: LD_VAR 0 1
107107: PUSH
107108: LD_INT 1
107110: ARRAY
107111: PPUSH
107112: LD_INT 1
107114: PPUSH
107115: CALL_OW 3
107119: PPUSH
107120: CALL_OW 1
107124: ST_TO_ADDR
// tmp := 1 ;
107125: LD_ADDR_VAR 0 2
107129: PUSH
107130: LD_STRING 1
107132: ST_TO_ADDR
// end ; normal := normal & tmp ;
107133: LD_ADDR_VAR 0 3
107137: PUSH
107138: LD_VAR 0 3
107142: PUSH
107143: LD_VAR 0 2
107147: STR
107148: ST_TO_ADDR
// end ;
107149: GO 107049
107151: POP
107152: POP
// for i = 1 to hardcoreCounter do
107153: LD_ADDR_VAR 0 5
107157: PUSH
107158: DOUBLE
107159: LD_INT 1
107161: DEC
107162: ST_TO_ADDR
107163: LD_EXP 158
107167: PUSH
107168: FOR_TO
107169: IFFALSE 107274
// begin tmp := 0 ;
107171: LD_ADDR_VAR 0 2
107175: PUSH
107176: LD_STRING 0
107178: ST_TO_ADDR
// if result [ 2 ] then
107179: LD_VAR 0 1
107183: PUSH
107184: LD_INT 2
107186: ARRAY
107187: IFFALSE 107256
// if result [ 2 ] [ 1 ] = 100 + i then
107189: LD_VAR 0 1
107193: PUSH
107194: LD_INT 2
107196: ARRAY
107197: PUSH
107198: LD_INT 1
107200: ARRAY
107201: PUSH
107202: LD_INT 100
107204: PUSH
107205: LD_VAR 0 5
107209: PLUS
107210: EQUAL
107211: IFFALSE 107256
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
107213: LD_ADDR_VAR 0 1
107217: PUSH
107218: LD_VAR 0 1
107222: PPUSH
107223: LD_INT 2
107225: PPUSH
107226: LD_VAR 0 1
107230: PUSH
107231: LD_INT 2
107233: ARRAY
107234: PPUSH
107235: LD_INT 1
107237: PPUSH
107238: CALL_OW 3
107242: PPUSH
107243: CALL_OW 1
107247: ST_TO_ADDR
// tmp := 1 ;
107248: LD_ADDR_VAR 0 2
107252: PUSH
107253: LD_STRING 1
107255: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
107256: LD_ADDR_VAR 0 4
107260: PUSH
107261: LD_VAR 0 4
107265: PUSH
107266: LD_VAR 0 2
107270: STR
107271: ST_TO_ADDR
// end ;
107272: GO 107168
107274: POP
107275: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
107276: LD_STRING getStreamItemsFromMission("
107278: PUSH
107279: LD_VAR 0 3
107283: STR
107284: PUSH
107285: LD_STRING ","
107287: STR
107288: PUSH
107289: LD_VAR 0 4
107293: STR
107294: PUSH
107295: LD_STRING ")
107297: STR
107298: PPUSH
107299: CALL_OW 559
// end else
107303: GO 107312
// ToLua ( getStreamItemsFromMission("","") ) ;
107305: LD_STRING getStreamItemsFromMission("","")
107307: PPUSH
107308: CALL_OW 559
// end ;
107312: LD_VAR 0 1
107316: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
107317: LD_EXP 156
107321: PUSH
107322: LD_EXP 161
107326: AND
107327: IFFALSE 107451
107329: GO 107331
107331: DISABLE
107332: LD_INT 0
107334: PPUSH
107335: PPUSH
// begin enable ;
107336: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
107337: LD_ADDR_VAR 0 2
107341: PUSH
107342: LD_INT 22
107344: PUSH
107345: LD_OWVAR 2
107349: PUSH
107350: EMPTY
107351: LIST
107352: LIST
107353: PUSH
107354: LD_INT 2
107356: PUSH
107357: LD_INT 34
107359: PUSH
107360: LD_INT 7
107362: PUSH
107363: EMPTY
107364: LIST
107365: LIST
107366: PUSH
107367: LD_INT 34
107369: PUSH
107370: LD_INT 45
107372: PUSH
107373: EMPTY
107374: LIST
107375: LIST
107376: PUSH
107377: LD_INT 34
107379: PUSH
107380: LD_INT 28
107382: PUSH
107383: EMPTY
107384: LIST
107385: LIST
107386: PUSH
107387: LD_INT 34
107389: PUSH
107390: LD_INT 47
107392: PUSH
107393: EMPTY
107394: LIST
107395: LIST
107396: PUSH
107397: EMPTY
107398: LIST
107399: LIST
107400: LIST
107401: LIST
107402: LIST
107403: PUSH
107404: EMPTY
107405: LIST
107406: LIST
107407: PPUSH
107408: CALL_OW 69
107412: ST_TO_ADDR
// if not tmp then
107413: LD_VAR 0 2
107417: NOT
107418: IFFALSE 107422
// exit ;
107420: GO 107451
// for i in tmp do
107422: LD_ADDR_VAR 0 1
107426: PUSH
107427: LD_VAR 0 2
107431: PUSH
107432: FOR_IN
107433: IFFALSE 107449
// begin SetLives ( i , 0 ) ;
107435: LD_VAR 0 1
107439: PPUSH
107440: LD_INT 0
107442: PPUSH
107443: CALL_OW 234
// end ;
107447: GO 107432
107449: POP
107450: POP
// end ;
107451: PPOPN 2
107453: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
107454: LD_EXP 156
107458: PUSH
107459: LD_EXP 162
107463: AND
107464: IFFALSE 107548
107466: GO 107468
107468: DISABLE
107469: LD_INT 0
107471: PPUSH
107472: PPUSH
// begin enable ;
107473: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
107474: LD_ADDR_VAR 0 2
107478: PUSH
107479: LD_INT 22
107481: PUSH
107482: LD_OWVAR 2
107486: PUSH
107487: EMPTY
107488: LIST
107489: LIST
107490: PUSH
107491: LD_INT 32
107493: PUSH
107494: LD_INT 3
107496: PUSH
107497: EMPTY
107498: LIST
107499: LIST
107500: PUSH
107501: EMPTY
107502: LIST
107503: LIST
107504: PPUSH
107505: CALL_OW 69
107509: ST_TO_ADDR
// if not tmp then
107510: LD_VAR 0 2
107514: NOT
107515: IFFALSE 107519
// exit ;
107517: GO 107548
// for i in tmp do
107519: LD_ADDR_VAR 0 1
107523: PUSH
107524: LD_VAR 0 2
107528: PUSH
107529: FOR_IN
107530: IFFALSE 107546
// begin SetLives ( i , 0 ) ;
107532: LD_VAR 0 1
107536: PPUSH
107537: LD_INT 0
107539: PPUSH
107540: CALL_OW 234
// end ;
107544: GO 107529
107546: POP
107547: POP
// end ;
107548: PPOPN 2
107550: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
107551: LD_EXP 156
107555: PUSH
107556: LD_EXP 159
107560: AND
107561: IFFALSE 107654
107563: GO 107565
107565: DISABLE
107566: LD_INT 0
107568: PPUSH
// begin enable ;
107569: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
107570: LD_ADDR_VAR 0 1
107574: PUSH
107575: LD_INT 22
107577: PUSH
107578: LD_OWVAR 2
107582: PUSH
107583: EMPTY
107584: LIST
107585: LIST
107586: PUSH
107587: LD_INT 2
107589: PUSH
107590: LD_INT 25
107592: PUSH
107593: LD_INT 5
107595: PUSH
107596: EMPTY
107597: LIST
107598: LIST
107599: PUSH
107600: LD_INT 25
107602: PUSH
107603: LD_INT 9
107605: PUSH
107606: EMPTY
107607: LIST
107608: LIST
107609: PUSH
107610: LD_INT 25
107612: PUSH
107613: LD_INT 8
107615: PUSH
107616: EMPTY
107617: LIST
107618: LIST
107619: PUSH
107620: EMPTY
107621: LIST
107622: LIST
107623: LIST
107624: LIST
107625: PUSH
107626: EMPTY
107627: LIST
107628: LIST
107629: PPUSH
107630: CALL_OW 69
107634: PUSH
107635: FOR_IN
107636: IFFALSE 107652
// begin SetClass ( i , 1 ) ;
107638: LD_VAR 0 1
107642: PPUSH
107643: LD_INT 1
107645: PPUSH
107646: CALL_OW 336
// end ;
107650: GO 107635
107652: POP
107653: POP
// end ;
107654: PPOPN 1
107656: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
107657: LD_EXP 156
107661: PUSH
107662: LD_EXP 160
107666: AND
107667: PUSH
107668: LD_OWVAR 65
107672: PUSH
107673: LD_INT 7
107675: LESS
107676: AND
107677: IFFALSE 107691
107679: GO 107681
107681: DISABLE
// begin enable ;
107682: ENABLE
// game_speed := 7 ;
107683: LD_ADDR_OWVAR 65
107687: PUSH
107688: LD_INT 7
107690: ST_TO_ADDR
// end ;
107691: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
107692: LD_EXP 156
107696: PUSH
107697: LD_EXP 163
107701: AND
107702: IFFALSE 107904
107704: GO 107706
107706: DISABLE
107707: LD_INT 0
107709: PPUSH
107710: PPUSH
107711: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107712: LD_ADDR_VAR 0 3
107716: PUSH
107717: LD_INT 81
107719: PUSH
107720: LD_OWVAR 2
107724: PUSH
107725: EMPTY
107726: LIST
107727: LIST
107728: PUSH
107729: LD_INT 21
107731: PUSH
107732: LD_INT 1
107734: PUSH
107735: EMPTY
107736: LIST
107737: LIST
107738: PUSH
107739: EMPTY
107740: LIST
107741: LIST
107742: PPUSH
107743: CALL_OW 69
107747: ST_TO_ADDR
// if not tmp then
107748: LD_VAR 0 3
107752: NOT
107753: IFFALSE 107757
// exit ;
107755: GO 107904
// if tmp > 5 then
107757: LD_VAR 0 3
107761: PUSH
107762: LD_INT 5
107764: GREATER
107765: IFFALSE 107777
// k := 5 else
107767: LD_ADDR_VAR 0 2
107771: PUSH
107772: LD_INT 5
107774: ST_TO_ADDR
107775: GO 107787
// k := tmp ;
107777: LD_ADDR_VAR 0 2
107781: PUSH
107782: LD_VAR 0 3
107786: ST_TO_ADDR
// for i := 1 to k do
107787: LD_ADDR_VAR 0 1
107791: PUSH
107792: DOUBLE
107793: LD_INT 1
107795: DEC
107796: ST_TO_ADDR
107797: LD_VAR 0 2
107801: PUSH
107802: FOR_TO
107803: IFFALSE 107902
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
107805: LD_VAR 0 3
107809: PUSH
107810: LD_VAR 0 1
107814: ARRAY
107815: PPUSH
107816: LD_VAR 0 1
107820: PUSH
107821: LD_INT 4
107823: MOD
107824: PUSH
107825: LD_INT 1
107827: PLUS
107828: PPUSH
107829: CALL_OW 259
107833: PUSH
107834: LD_INT 10
107836: LESS
107837: IFFALSE 107900
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
107839: LD_VAR 0 3
107843: PUSH
107844: LD_VAR 0 1
107848: ARRAY
107849: PPUSH
107850: LD_VAR 0 1
107854: PUSH
107855: LD_INT 4
107857: MOD
107858: PUSH
107859: LD_INT 1
107861: PLUS
107862: PPUSH
107863: LD_VAR 0 3
107867: PUSH
107868: LD_VAR 0 1
107872: ARRAY
107873: PPUSH
107874: LD_VAR 0 1
107878: PUSH
107879: LD_INT 4
107881: MOD
107882: PUSH
107883: LD_INT 1
107885: PLUS
107886: PPUSH
107887: CALL_OW 259
107891: PUSH
107892: LD_INT 1
107894: PLUS
107895: PPUSH
107896: CALL_OW 237
107900: GO 107802
107902: POP
107903: POP
// end ;
107904: PPOPN 3
107906: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
107907: LD_EXP 156
107911: PUSH
107912: LD_EXP 164
107916: AND
107917: IFFALSE 107937
107919: GO 107921
107921: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
107922: LD_INT 4
107924: PPUSH
107925: LD_OWVAR 2
107929: PPUSH
107930: LD_INT 0
107932: PPUSH
107933: CALL_OW 324
107937: END
// every 0 0$1 trigger StreamModeActive and sShovel do
107938: LD_EXP 156
107942: PUSH
107943: LD_EXP 193
107947: AND
107948: IFFALSE 107968
107950: GO 107952
107952: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
107953: LD_INT 19
107955: PPUSH
107956: LD_OWVAR 2
107960: PPUSH
107961: LD_INT 0
107963: PPUSH
107964: CALL_OW 324
107968: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
107969: LD_EXP 156
107973: PUSH
107974: LD_EXP 165
107978: AND
107979: IFFALSE 108081
107981: GO 107983
107983: DISABLE
107984: LD_INT 0
107986: PPUSH
107987: PPUSH
// begin enable ;
107988: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
107989: LD_ADDR_VAR 0 2
107993: PUSH
107994: LD_INT 22
107996: PUSH
107997: LD_OWVAR 2
108001: PUSH
108002: EMPTY
108003: LIST
108004: LIST
108005: PUSH
108006: LD_INT 2
108008: PUSH
108009: LD_INT 34
108011: PUSH
108012: LD_INT 11
108014: PUSH
108015: EMPTY
108016: LIST
108017: LIST
108018: PUSH
108019: LD_INT 34
108021: PUSH
108022: LD_INT 30
108024: PUSH
108025: EMPTY
108026: LIST
108027: LIST
108028: PUSH
108029: EMPTY
108030: LIST
108031: LIST
108032: LIST
108033: PUSH
108034: EMPTY
108035: LIST
108036: LIST
108037: PPUSH
108038: CALL_OW 69
108042: ST_TO_ADDR
// if not tmp then
108043: LD_VAR 0 2
108047: NOT
108048: IFFALSE 108052
// exit ;
108050: GO 108081
// for i in tmp do
108052: LD_ADDR_VAR 0 1
108056: PUSH
108057: LD_VAR 0 2
108061: PUSH
108062: FOR_IN
108063: IFFALSE 108079
// begin SetLives ( i , 0 ) ;
108065: LD_VAR 0 1
108069: PPUSH
108070: LD_INT 0
108072: PPUSH
108073: CALL_OW 234
// end ;
108077: GO 108062
108079: POP
108080: POP
// end ;
108081: PPOPN 2
108083: END
// every 0 0$1 trigger StreamModeActive and sBunker do
108084: LD_EXP 156
108088: PUSH
108089: LD_EXP 166
108093: AND
108094: IFFALSE 108114
108096: GO 108098
108098: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
108099: LD_INT 32
108101: PPUSH
108102: LD_OWVAR 2
108106: PPUSH
108107: LD_INT 0
108109: PPUSH
108110: CALL_OW 324
108114: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
108115: LD_EXP 156
108119: PUSH
108120: LD_EXP 167
108124: AND
108125: IFFALSE 108306
108127: GO 108129
108129: DISABLE
108130: LD_INT 0
108132: PPUSH
108133: PPUSH
108134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
108135: LD_ADDR_VAR 0 2
108139: PUSH
108140: LD_INT 22
108142: PUSH
108143: LD_OWVAR 2
108147: PUSH
108148: EMPTY
108149: LIST
108150: LIST
108151: PUSH
108152: LD_INT 33
108154: PUSH
108155: LD_INT 3
108157: PUSH
108158: EMPTY
108159: LIST
108160: LIST
108161: PUSH
108162: EMPTY
108163: LIST
108164: LIST
108165: PPUSH
108166: CALL_OW 69
108170: ST_TO_ADDR
// if not tmp then
108171: LD_VAR 0 2
108175: NOT
108176: IFFALSE 108180
// exit ;
108178: GO 108306
// side := 0 ;
108180: LD_ADDR_VAR 0 3
108184: PUSH
108185: LD_INT 0
108187: ST_TO_ADDR
// for i := 1 to 8 do
108188: LD_ADDR_VAR 0 1
108192: PUSH
108193: DOUBLE
108194: LD_INT 1
108196: DEC
108197: ST_TO_ADDR
108198: LD_INT 8
108200: PUSH
108201: FOR_TO
108202: IFFALSE 108250
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
108204: LD_OWVAR 2
108208: PUSH
108209: LD_VAR 0 1
108213: NONEQUAL
108214: PUSH
108215: LD_OWVAR 2
108219: PPUSH
108220: LD_VAR 0 1
108224: PPUSH
108225: CALL_OW 81
108229: PUSH
108230: LD_INT 2
108232: EQUAL
108233: AND
108234: IFFALSE 108248
// begin side := i ;
108236: LD_ADDR_VAR 0 3
108240: PUSH
108241: LD_VAR 0 1
108245: ST_TO_ADDR
// break ;
108246: GO 108250
// end ;
108248: GO 108201
108250: POP
108251: POP
// if not side then
108252: LD_VAR 0 3
108256: NOT
108257: IFFALSE 108261
// exit ;
108259: GO 108306
// for i := 1 to tmp do
108261: LD_ADDR_VAR 0 1
108265: PUSH
108266: DOUBLE
108267: LD_INT 1
108269: DEC
108270: ST_TO_ADDR
108271: LD_VAR 0 2
108275: PUSH
108276: FOR_TO
108277: IFFALSE 108304
// if Prob ( 60 ) then
108279: LD_INT 60
108281: PPUSH
108282: CALL_OW 13
108286: IFFALSE 108302
// SetSide ( i , side ) ;
108288: LD_VAR 0 1
108292: PPUSH
108293: LD_VAR 0 3
108297: PPUSH
108298: CALL_OW 235
108302: GO 108276
108304: POP
108305: POP
// end ;
108306: PPOPN 3
108308: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
108309: LD_EXP 156
108313: PUSH
108314: LD_EXP 169
108318: AND
108319: IFFALSE 108438
108321: GO 108323
108323: DISABLE
108324: LD_INT 0
108326: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
108327: LD_ADDR_VAR 0 1
108331: PUSH
108332: LD_INT 22
108334: PUSH
108335: LD_OWVAR 2
108339: PUSH
108340: EMPTY
108341: LIST
108342: LIST
108343: PUSH
108344: LD_INT 21
108346: PUSH
108347: LD_INT 1
108349: PUSH
108350: EMPTY
108351: LIST
108352: LIST
108353: PUSH
108354: LD_INT 3
108356: PUSH
108357: LD_INT 23
108359: PUSH
108360: LD_INT 0
108362: PUSH
108363: EMPTY
108364: LIST
108365: LIST
108366: PUSH
108367: EMPTY
108368: LIST
108369: LIST
108370: PUSH
108371: EMPTY
108372: LIST
108373: LIST
108374: LIST
108375: PPUSH
108376: CALL_OW 69
108380: PUSH
108381: FOR_IN
108382: IFFALSE 108436
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
108384: LD_VAR 0 1
108388: PPUSH
108389: CALL_OW 257
108393: PUSH
108394: LD_INT 1
108396: PUSH
108397: LD_INT 2
108399: PUSH
108400: LD_INT 3
108402: PUSH
108403: LD_INT 4
108405: PUSH
108406: EMPTY
108407: LIST
108408: LIST
108409: LIST
108410: LIST
108411: IN
108412: IFFALSE 108434
// SetClass ( un , rand ( 1 , 4 ) ) ;
108414: LD_VAR 0 1
108418: PPUSH
108419: LD_INT 1
108421: PPUSH
108422: LD_INT 4
108424: PPUSH
108425: CALL_OW 12
108429: PPUSH
108430: CALL_OW 336
108434: GO 108381
108436: POP
108437: POP
// end ;
108438: PPOPN 1
108440: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
108441: LD_EXP 156
108445: PUSH
108446: LD_EXP 168
108450: AND
108451: IFFALSE 108530
108453: GO 108455
108455: DISABLE
108456: LD_INT 0
108458: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108459: LD_ADDR_VAR 0 1
108463: PUSH
108464: LD_INT 22
108466: PUSH
108467: LD_OWVAR 2
108471: PUSH
108472: EMPTY
108473: LIST
108474: LIST
108475: PUSH
108476: LD_INT 21
108478: PUSH
108479: LD_INT 3
108481: PUSH
108482: EMPTY
108483: LIST
108484: LIST
108485: PUSH
108486: EMPTY
108487: LIST
108488: LIST
108489: PPUSH
108490: CALL_OW 69
108494: ST_TO_ADDR
// if not tmp then
108495: LD_VAR 0 1
108499: NOT
108500: IFFALSE 108504
// exit ;
108502: GO 108530
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
108504: LD_VAR 0 1
108508: PUSH
108509: LD_INT 1
108511: PPUSH
108512: LD_VAR 0 1
108516: PPUSH
108517: CALL_OW 12
108521: ARRAY
108522: PPUSH
108523: LD_INT 100
108525: PPUSH
108526: CALL_OW 234
// end ;
108530: PPOPN 1
108532: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
108533: LD_EXP 156
108537: PUSH
108538: LD_EXP 170
108542: AND
108543: IFFALSE 108641
108545: GO 108547
108547: DISABLE
108548: LD_INT 0
108550: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
108551: LD_ADDR_VAR 0 1
108555: PUSH
108556: LD_INT 22
108558: PUSH
108559: LD_OWVAR 2
108563: PUSH
108564: EMPTY
108565: LIST
108566: LIST
108567: PUSH
108568: LD_INT 21
108570: PUSH
108571: LD_INT 1
108573: PUSH
108574: EMPTY
108575: LIST
108576: LIST
108577: PUSH
108578: EMPTY
108579: LIST
108580: LIST
108581: PPUSH
108582: CALL_OW 69
108586: ST_TO_ADDR
// if not tmp then
108587: LD_VAR 0 1
108591: NOT
108592: IFFALSE 108596
// exit ;
108594: GO 108641
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
108596: LD_VAR 0 1
108600: PUSH
108601: LD_INT 1
108603: PPUSH
108604: LD_VAR 0 1
108608: PPUSH
108609: CALL_OW 12
108613: ARRAY
108614: PPUSH
108615: LD_INT 1
108617: PPUSH
108618: LD_INT 4
108620: PPUSH
108621: CALL_OW 12
108625: PPUSH
108626: LD_INT 3000
108628: PPUSH
108629: LD_INT 9000
108631: PPUSH
108632: CALL_OW 12
108636: PPUSH
108637: CALL_OW 492
// end ;
108641: PPOPN 1
108643: END
// every 0 0$1 trigger StreamModeActive and sDepot do
108644: LD_EXP 156
108648: PUSH
108649: LD_EXP 171
108653: AND
108654: IFFALSE 108674
108656: GO 108658
108658: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
108659: LD_INT 1
108661: PPUSH
108662: LD_OWVAR 2
108666: PPUSH
108667: LD_INT 0
108669: PPUSH
108670: CALL_OW 324
108674: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
108675: LD_EXP 156
108679: PUSH
108680: LD_EXP 172
108684: AND
108685: IFFALSE 108768
108687: GO 108689
108689: DISABLE
108690: LD_INT 0
108692: PPUSH
108693: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
108694: LD_ADDR_VAR 0 2
108698: PUSH
108699: LD_INT 22
108701: PUSH
108702: LD_OWVAR 2
108706: PUSH
108707: EMPTY
108708: LIST
108709: LIST
108710: PUSH
108711: LD_INT 21
108713: PUSH
108714: LD_INT 3
108716: PUSH
108717: EMPTY
108718: LIST
108719: LIST
108720: PUSH
108721: EMPTY
108722: LIST
108723: LIST
108724: PPUSH
108725: CALL_OW 69
108729: ST_TO_ADDR
// if not tmp then
108730: LD_VAR 0 2
108734: NOT
108735: IFFALSE 108739
// exit ;
108737: GO 108768
// for i in tmp do
108739: LD_ADDR_VAR 0 1
108743: PUSH
108744: LD_VAR 0 2
108748: PUSH
108749: FOR_IN
108750: IFFALSE 108766
// SetBLevel ( i , 10 ) ;
108752: LD_VAR 0 1
108756: PPUSH
108757: LD_INT 10
108759: PPUSH
108760: CALL_OW 241
108764: GO 108749
108766: POP
108767: POP
// end ;
108768: PPOPN 2
108770: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
108771: LD_EXP 156
108775: PUSH
108776: LD_EXP 173
108780: AND
108781: IFFALSE 108892
108783: GO 108785
108785: DISABLE
108786: LD_INT 0
108788: PPUSH
108789: PPUSH
108790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108791: LD_ADDR_VAR 0 3
108795: PUSH
108796: LD_INT 22
108798: PUSH
108799: LD_OWVAR 2
108803: PUSH
108804: EMPTY
108805: LIST
108806: LIST
108807: PUSH
108808: LD_INT 25
108810: PUSH
108811: LD_INT 1
108813: PUSH
108814: EMPTY
108815: LIST
108816: LIST
108817: PUSH
108818: EMPTY
108819: LIST
108820: LIST
108821: PPUSH
108822: CALL_OW 69
108826: ST_TO_ADDR
// if not tmp then
108827: LD_VAR 0 3
108831: NOT
108832: IFFALSE 108836
// exit ;
108834: GO 108892
// un := tmp [ rand ( 1 , tmp ) ] ;
108836: LD_ADDR_VAR 0 2
108840: PUSH
108841: LD_VAR 0 3
108845: PUSH
108846: LD_INT 1
108848: PPUSH
108849: LD_VAR 0 3
108853: PPUSH
108854: CALL_OW 12
108858: ARRAY
108859: ST_TO_ADDR
// if Crawls ( un ) then
108860: LD_VAR 0 2
108864: PPUSH
108865: CALL_OW 318
108869: IFFALSE 108880
// ComWalk ( un ) ;
108871: LD_VAR 0 2
108875: PPUSH
108876: CALL_OW 138
// SetClass ( un , class_sniper ) ;
108880: LD_VAR 0 2
108884: PPUSH
108885: LD_INT 5
108887: PPUSH
108888: CALL_OW 336
// end ;
108892: PPOPN 3
108894: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
108895: LD_EXP 156
108899: PUSH
108900: LD_EXP 174
108904: AND
108905: PUSH
108906: LD_OWVAR 67
108910: PUSH
108911: LD_INT 3
108913: LESS
108914: AND
108915: IFFALSE 108934
108917: GO 108919
108919: DISABLE
// Difficulty := Difficulty + 1 ;
108920: LD_ADDR_OWVAR 67
108924: PUSH
108925: LD_OWVAR 67
108929: PUSH
108930: LD_INT 1
108932: PLUS
108933: ST_TO_ADDR
108934: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
108935: LD_EXP 156
108939: PUSH
108940: LD_EXP 175
108944: AND
108945: IFFALSE 109048
108947: GO 108949
108949: DISABLE
108950: LD_INT 0
108952: PPUSH
// begin for i := 1 to 5 do
108953: LD_ADDR_VAR 0 1
108957: PUSH
108958: DOUBLE
108959: LD_INT 1
108961: DEC
108962: ST_TO_ADDR
108963: LD_INT 5
108965: PUSH
108966: FOR_TO
108967: IFFALSE 109046
// begin uc_nation := nation_nature ;
108969: LD_ADDR_OWVAR 21
108973: PUSH
108974: LD_INT 0
108976: ST_TO_ADDR
// uc_side := 0 ;
108977: LD_ADDR_OWVAR 20
108981: PUSH
108982: LD_INT 0
108984: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108985: LD_ADDR_OWVAR 29
108989: PUSH
108990: LD_INT 12
108992: PUSH
108993: LD_INT 12
108995: PUSH
108996: EMPTY
108997: LIST
108998: LIST
108999: ST_TO_ADDR
// hc_agressivity := 20 ;
109000: LD_ADDR_OWVAR 35
109004: PUSH
109005: LD_INT 20
109007: ST_TO_ADDR
// hc_class := class_tiger ;
109008: LD_ADDR_OWVAR 28
109012: PUSH
109013: LD_INT 14
109015: ST_TO_ADDR
// hc_gallery :=  ;
109016: LD_ADDR_OWVAR 33
109020: PUSH
109021: LD_STRING 
109023: ST_TO_ADDR
// hc_name :=  ;
109024: LD_ADDR_OWVAR 26
109028: PUSH
109029: LD_STRING 
109031: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
109032: CALL_OW 44
109036: PPUSH
109037: LD_INT 0
109039: PPUSH
109040: CALL_OW 51
// end ;
109044: GO 108966
109046: POP
109047: POP
// end ;
109048: PPOPN 1
109050: END
// every 0 0$1 trigger StreamModeActive and sBomb do
109051: LD_EXP 156
109055: PUSH
109056: LD_EXP 176
109060: AND
109061: IFFALSE 109070
109063: GO 109065
109065: DISABLE
// StreamSibBomb ;
109066: CALL 109071 0 0
109070: END
// export function StreamSibBomb ; var i , x , y ; begin
109071: LD_INT 0
109073: PPUSH
109074: PPUSH
109075: PPUSH
109076: PPUSH
// result := false ;
109077: LD_ADDR_VAR 0 1
109081: PUSH
109082: LD_INT 0
109084: ST_TO_ADDR
// for i := 1 to 16 do
109085: LD_ADDR_VAR 0 2
109089: PUSH
109090: DOUBLE
109091: LD_INT 1
109093: DEC
109094: ST_TO_ADDR
109095: LD_INT 16
109097: PUSH
109098: FOR_TO
109099: IFFALSE 109298
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109101: LD_ADDR_VAR 0 3
109105: PUSH
109106: LD_INT 10
109108: PUSH
109109: LD_INT 20
109111: PUSH
109112: LD_INT 30
109114: PUSH
109115: LD_INT 40
109117: PUSH
109118: LD_INT 50
109120: PUSH
109121: LD_INT 60
109123: PUSH
109124: LD_INT 70
109126: PUSH
109127: LD_INT 80
109129: PUSH
109130: LD_INT 90
109132: PUSH
109133: LD_INT 100
109135: PUSH
109136: LD_INT 110
109138: PUSH
109139: LD_INT 120
109141: PUSH
109142: LD_INT 130
109144: PUSH
109145: LD_INT 140
109147: PUSH
109148: LD_INT 150
109150: PUSH
109151: EMPTY
109152: LIST
109153: LIST
109154: LIST
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: LIST
109161: LIST
109162: LIST
109163: LIST
109164: LIST
109165: LIST
109166: LIST
109167: PUSH
109168: LD_INT 1
109170: PPUSH
109171: LD_INT 15
109173: PPUSH
109174: CALL_OW 12
109178: ARRAY
109179: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
109180: LD_ADDR_VAR 0 4
109184: PUSH
109185: LD_INT 10
109187: PUSH
109188: LD_INT 20
109190: PUSH
109191: LD_INT 30
109193: PUSH
109194: LD_INT 40
109196: PUSH
109197: LD_INT 50
109199: PUSH
109200: LD_INT 60
109202: PUSH
109203: LD_INT 70
109205: PUSH
109206: LD_INT 80
109208: PUSH
109209: LD_INT 90
109211: PUSH
109212: LD_INT 100
109214: PUSH
109215: LD_INT 110
109217: PUSH
109218: LD_INT 120
109220: PUSH
109221: LD_INT 130
109223: PUSH
109224: LD_INT 140
109226: PUSH
109227: LD_INT 150
109229: PUSH
109230: EMPTY
109231: LIST
109232: LIST
109233: LIST
109234: LIST
109235: LIST
109236: LIST
109237: LIST
109238: LIST
109239: LIST
109240: LIST
109241: LIST
109242: LIST
109243: LIST
109244: LIST
109245: LIST
109246: PUSH
109247: LD_INT 1
109249: PPUSH
109250: LD_INT 15
109252: PPUSH
109253: CALL_OW 12
109257: ARRAY
109258: ST_TO_ADDR
// if ValidHex ( x , y ) then
109259: LD_VAR 0 3
109263: PPUSH
109264: LD_VAR 0 4
109268: PPUSH
109269: CALL_OW 488
109273: IFFALSE 109296
// begin result := [ x , y ] ;
109275: LD_ADDR_VAR 0 1
109279: PUSH
109280: LD_VAR 0 3
109284: PUSH
109285: LD_VAR 0 4
109289: PUSH
109290: EMPTY
109291: LIST
109292: LIST
109293: ST_TO_ADDR
// break ;
109294: GO 109298
// end ; end ;
109296: GO 109098
109298: POP
109299: POP
// if result then
109300: LD_VAR 0 1
109304: IFFALSE 109364
// begin ToLua ( playSibBomb() ) ;
109306: LD_STRING playSibBomb()
109308: PPUSH
109309: CALL_OW 559
// wait ( 0 0$14 ) ;
109313: LD_INT 490
109315: PPUSH
109316: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
109320: LD_VAR 0 1
109324: PUSH
109325: LD_INT 1
109327: ARRAY
109328: PPUSH
109329: LD_VAR 0 1
109333: PUSH
109334: LD_INT 2
109336: ARRAY
109337: PPUSH
109338: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
109342: LD_VAR 0 1
109346: PUSH
109347: LD_INT 1
109349: ARRAY
109350: PPUSH
109351: LD_VAR 0 1
109355: PUSH
109356: LD_INT 2
109358: ARRAY
109359: PPUSH
109360: CALL_OW 429
// end ; end ;
109364: LD_VAR 0 1
109368: RET
// every 0 0$1 trigger StreamModeActive and sReset do
109369: LD_EXP 156
109373: PUSH
109374: LD_EXP 178
109378: AND
109379: IFFALSE 109391
109381: GO 109383
109383: DISABLE
// YouLost (  ) ;
109384: LD_STRING 
109386: PPUSH
109387: CALL_OW 104
109391: END
// every 0 0$1 trigger StreamModeActive and sFog do
109392: LD_EXP 156
109396: PUSH
109397: LD_EXP 177
109401: AND
109402: IFFALSE 109416
109404: GO 109406
109406: DISABLE
// FogOff ( your_side ) ;
109407: LD_OWVAR 2
109411: PPUSH
109412: CALL_OW 344
109416: END
// every 0 0$1 trigger StreamModeActive and sSun do
109417: LD_EXP 156
109421: PUSH
109422: LD_EXP 179
109426: AND
109427: IFFALSE 109455
109429: GO 109431
109431: DISABLE
// begin solar_recharge_percent := 0 ;
109432: LD_ADDR_OWVAR 79
109436: PUSH
109437: LD_INT 0
109439: ST_TO_ADDR
// wait ( 5 5$00 ) ;
109440: LD_INT 10500
109442: PPUSH
109443: CALL_OW 67
// solar_recharge_percent := 100 ;
109447: LD_ADDR_OWVAR 79
109451: PUSH
109452: LD_INT 100
109454: ST_TO_ADDR
// end ;
109455: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
109456: LD_EXP 156
109460: PUSH
109461: LD_EXP 180
109465: AND
109466: IFFALSE 109705
109468: GO 109470
109470: DISABLE
109471: LD_INT 0
109473: PPUSH
109474: PPUSH
109475: PPUSH
// begin tmp := [ ] ;
109476: LD_ADDR_VAR 0 3
109480: PUSH
109481: EMPTY
109482: ST_TO_ADDR
// for i := 1 to 6 do
109483: LD_ADDR_VAR 0 1
109487: PUSH
109488: DOUBLE
109489: LD_INT 1
109491: DEC
109492: ST_TO_ADDR
109493: LD_INT 6
109495: PUSH
109496: FOR_TO
109497: IFFALSE 109602
// begin uc_nation := nation_nature ;
109499: LD_ADDR_OWVAR 21
109503: PUSH
109504: LD_INT 0
109506: ST_TO_ADDR
// uc_side := 0 ;
109507: LD_ADDR_OWVAR 20
109511: PUSH
109512: LD_INT 0
109514: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
109515: LD_ADDR_OWVAR 29
109519: PUSH
109520: LD_INT 12
109522: PUSH
109523: LD_INT 12
109525: PUSH
109526: EMPTY
109527: LIST
109528: LIST
109529: ST_TO_ADDR
// hc_agressivity := 20 ;
109530: LD_ADDR_OWVAR 35
109534: PUSH
109535: LD_INT 20
109537: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
109538: LD_ADDR_OWVAR 28
109542: PUSH
109543: LD_INT 17
109545: ST_TO_ADDR
// hc_gallery :=  ;
109546: LD_ADDR_OWVAR 33
109550: PUSH
109551: LD_STRING 
109553: ST_TO_ADDR
// hc_name :=  ;
109554: LD_ADDR_OWVAR 26
109558: PUSH
109559: LD_STRING 
109561: ST_TO_ADDR
// un := CreateHuman ;
109562: LD_ADDR_VAR 0 2
109566: PUSH
109567: CALL_OW 44
109571: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
109572: LD_VAR 0 2
109576: PPUSH
109577: LD_INT 1
109579: PPUSH
109580: CALL_OW 51
// tmp := tmp ^ un ;
109584: LD_ADDR_VAR 0 3
109588: PUSH
109589: LD_VAR 0 3
109593: PUSH
109594: LD_VAR 0 2
109598: ADD
109599: ST_TO_ADDR
// end ;
109600: GO 109496
109602: POP
109603: POP
// repeat wait ( 0 0$1 ) ;
109604: LD_INT 35
109606: PPUSH
109607: CALL_OW 67
// for un in tmp do
109611: LD_ADDR_VAR 0 2
109615: PUSH
109616: LD_VAR 0 3
109620: PUSH
109621: FOR_IN
109622: IFFALSE 109696
// begin if IsDead ( un ) then
109624: LD_VAR 0 2
109628: PPUSH
109629: CALL_OW 301
109633: IFFALSE 109653
// begin tmp := tmp diff un ;
109635: LD_ADDR_VAR 0 3
109639: PUSH
109640: LD_VAR 0 3
109644: PUSH
109645: LD_VAR 0 2
109649: DIFF
109650: ST_TO_ADDR
// continue ;
109651: GO 109621
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
109653: LD_VAR 0 2
109657: PPUSH
109658: LD_INT 3
109660: PUSH
109661: LD_INT 22
109663: PUSH
109664: LD_INT 0
109666: PUSH
109667: EMPTY
109668: LIST
109669: LIST
109670: PUSH
109671: EMPTY
109672: LIST
109673: LIST
109674: PPUSH
109675: CALL_OW 69
109679: PPUSH
109680: LD_VAR 0 2
109684: PPUSH
109685: CALL_OW 74
109689: PPUSH
109690: CALL_OW 115
// end ;
109694: GO 109621
109696: POP
109697: POP
// until not tmp ;
109698: LD_VAR 0 3
109702: NOT
109703: IFFALSE 109604
// end ;
109705: PPOPN 3
109707: END
// every 0 0$1 trigger StreamModeActive and sTroll do
109708: LD_EXP 156
109712: PUSH
109713: LD_EXP 181
109717: AND
109718: IFFALSE 109772
109720: GO 109722
109722: DISABLE
// begin ToLua ( displayTroll(); ) ;
109723: LD_STRING displayTroll();
109725: PPUSH
109726: CALL_OW 559
// wait ( 3 3$00 ) ;
109730: LD_INT 6300
109732: PPUSH
109733: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109737: LD_STRING hideTroll();
109739: PPUSH
109740: CALL_OW 559
// wait ( 1 1$00 ) ;
109744: LD_INT 2100
109746: PPUSH
109747: CALL_OW 67
// ToLua ( displayTroll(); ) ;
109751: LD_STRING displayTroll();
109753: PPUSH
109754: CALL_OW 559
// wait ( 1 1$00 ) ;
109758: LD_INT 2100
109760: PPUSH
109761: CALL_OW 67
// ToLua ( hideTroll(); ) ;
109765: LD_STRING hideTroll();
109767: PPUSH
109768: CALL_OW 559
// end ;
109772: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
109773: LD_EXP 156
109777: PUSH
109778: LD_EXP 182
109782: AND
109783: IFFALSE 109846
109785: GO 109787
109787: DISABLE
109788: LD_INT 0
109790: PPUSH
// begin p := 0 ;
109791: LD_ADDR_VAR 0 1
109795: PUSH
109796: LD_INT 0
109798: ST_TO_ADDR
// repeat game_speed := 1 ;
109799: LD_ADDR_OWVAR 65
109803: PUSH
109804: LD_INT 1
109806: ST_TO_ADDR
// wait ( 0 0$1 ) ;
109807: LD_INT 35
109809: PPUSH
109810: CALL_OW 67
// p := p + 1 ;
109814: LD_ADDR_VAR 0 1
109818: PUSH
109819: LD_VAR 0 1
109823: PUSH
109824: LD_INT 1
109826: PLUS
109827: ST_TO_ADDR
// until p >= 60 ;
109828: LD_VAR 0 1
109832: PUSH
109833: LD_INT 60
109835: GREATEREQUAL
109836: IFFALSE 109799
// game_speed := 4 ;
109838: LD_ADDR_OWVAR 65
109842: PUSH
109843: LD_INT 4
109845: ST_TO_ADDR
// end ;
109846: PPOPN 1
109848: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
109849: LD_EXP 156
109853: PUSH
109854: LD_EXP 183
109858: AND
109859: IFFALSE 110005
109861: GO 109863
109863: DISABLE
109864: LD_INT 0
109866: PPUSH
109867: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109868: LD_ADDR_VAR 0 1
109872: PUSH
109873: LD_INT 22
109875: PUSH
109876: LD_OWVAR 2
109880: PUSH
109881: EMPTY
109882: LIST
109883: LIST
109884: PUSH
109885: LD_INT 2
109887: PUSH
109888: LD_INT 30
109890: PUSH
109891: LD_INT 0
109893: PUSH
109894: EMPTY
109895: LIST
109896: LIST
109897: PUSH
109898: LD_INT 30
109900: PUSH
109901: LD_INT 1
109903: PUSH
109904: EMPTY
109905: LIST
109906: LIST
109907: PUSH
109908: EMPTY
109909: LIST
109910: LIST
109911: LIST
109912: PUSH
109913: EMPTY
109914: LIST
109915: LIST
109916: PPUSH
109917: CALL_OW 69
109921: ST_TO_ADDR
// if not depot then
109922: LD_VAR 0 1
109926: NOT
109927: IFFALSE 109931
// exit ;
109929: GO 110005
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
109931: LD_ADDR_VAR 0 2
109935: PUSH
109936: LD_VAR 0 1
109940: PUSH
109941: LD_INT 1
109943: PPUSH
109944: LD_VAR 0 1
109948: PPUSH
109949: CALL_OW 12
109953: ARRAY
109954: PPUSH
109955: CALL_OW 274
109959: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
109960: LD_VAR 0 2
109964: PPUSH
109965: LD_INT 1
109967: PPUSH
109968: LD_INT 0
109970: PPUSH
109971: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
109975: LD_VAR 0 2
109979: PPUSH
109980: LD_INT 2
109982: PPUSH
109983: LD_INT 0
109985: PPUSH
109986: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
109990: LD_VAR 0 2
109994: PPUSH
109995: LD_INT 3
109997: PPUSH
109998: LD_INT 0
110000: PPUSH
110001: CALL_OW 277
// end ;
110005: PPOPN 2
110007: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
110008: LD_EXP 156
110012: PUSH
110013: LD_EXP 184
110017: AND
110018: IFFALSE 110115
110020: GO 110022
110022: DISABLE
110023: LD_INT 0
110025: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
110026: LD_ADDR_VAR 0 1
110030: PUSH
110031: LD_INT 22
110033: PUSH
110034: LD_OWVAR 2
110038: PUSH
110039: EMPTY
110040: LIST
110041: LIST
110042: PUSH
110043: LD_INT 21
110045: PUSH
110046: LD_INT 1
110048: PUSH
110049: EMPTY
110050: LIST
110051: LIST
110052: PUSH
110053: LD_INT 3
110055: PUSH
110056: LD_INT 23
110058: PUSH
110059: LD_INT 0
110061: PUSH
110062: EMPTY
110063: LIST
110064: LIST
110065: PUSH
110066: EMPTY
110067: LIST
110068: LIST
110069: PUSH
110070: EMPTY
110071: LIST
110072: LIST
110073: LIST
110074: PPUSH
110075: CALL_OW 69
110079: ST_TO_ADDR
// if not tmp then
110080: LD_VAR 0 1
110084: NOT
110085: IFFALSE 110089
// exit ;
110087: GO 110115
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
110089: LD_VAR 0 1
110093: PUSH
110094: LD_INT 1
110096: PPUSH
110097: LD_VAR 0 1
110101: PPUSH
110102: CALL_OW 12
110106: ARRAY
110107: PPUSH
110108: LD_INT 200
110110: PPUSH
110111: CALL_OW 234
// end ;
110115: PPOPN 1
110117: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
110118: LD_EXP 156
110122: PUSH
110123: LD_EXP 185
110127: AND
110128: IFFALSE 110207
110130: GO 110132
110132: DISABLE
110133: LD_INT 0
110135: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
110136: LD_ADDR_VAR 0 1
110140: PUSH
110141: LD_INT 22
110143: PUSH
110144: LD_OWVAR 2
110148: PUSH
110149: EMPTY
110150: LIST
110151: LIST
110152: PUSH
110153: LD_INT 21
110155: PUSH
110156: LD_INT 2
110158: PUSH
110159: EMPTY
110160: LIST
110161: LIST
110162: PUSH
110163: EMPTY
110164: LIST
110165: LIST
110166: PPUSH
110167: CALL_OW 69
110171: ST_TO_ADDR
// if not tmp then
110172: LD_VAR 0 1
110176: NOT
110177: IFFALSE 110181
// exit ;
110179: GO 110207
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
110181: LD_VAR 0 1
110185: PUSH
110186: LD_INT 1
110188: PPUSH
110189: LD_VAR 0 1
110193: PPUSH
110194: CALL_OW 12
110198: ARRAY
110199: PPUSH
110200: LD_INT 60
110202: PPUSH
110203: CALL_OW 234
// end ;
110207: PPOPN 1
110209: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
110210: LD_EXP 156
110214: PUSH
110215: LD_EXP 186
110219: AND
110220: IFFALSE 110319
110222: GO 110224
110224: DISABLE
110225: LD_INT 0
110227: PPUSH
110228: PPUSH
// begin enable ;
110229: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
110230: LD_ADDR_VAR 0 1
110234: PUSH
110235: LD_INT 22
110237: PUSH
110238: LD_OWVAR 2
110242: PUSH
110243: EMPTY
110244: LIST
110245: LIST
110246: PUSH
110247: LD_INT 61
110249: PUSH
110250: EMPTY
110251: LIST
110252: PUSH
110253: LD_INT 33
110255: PUSH
110256: LD_INT 2
110258: PUSH
110259: EMPTY
110260: LIST
110261: LIST
110262: PUSH
110263: EMPTY
110264: LIST
110265: LIST
110266: LIST
110267: PPUSH
110268: CALL_OW 69
110272: ST_TO_ADDR
// if not tmp then
110273: LD_VAR 0 1
110277: NOT
110278: IFFALSE 110282
// exit ;
110280: GO 110319
// for i in tmp do
110282: LD_ADDR_VAR 0 2
110286: PUSH
110287: LD_VAR 0 1
110291: PUSH
110292: FOR_IN
110293: IFFALSE 110317
// if IsControledBy ( i ) then
110295: LD_VAR 0 2
110299: PPUSH
110300: CALL_OW 312
110304: IFFALSE 110315
// ComUnlink ( i ) ;
110306: LD_VAR 0 2
110310: PPUSH
110311: CALL_OW 136
110315: GO 110292
110317: POP
110318: POP
// end ;
110319: PPOPN 2
110321: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
110322: LD_EXP 156
110326: PUSH
110327: LD_EXP 187
110331: AND
110332: IFFALSE 110472
110334: GO 110336
110336: DISABLE
110337: LD_INT 0
110339: PPUSH
110340: PPUSH
// begin ToLua ( displayPowell(); ) ;
110341: LD_STRING displayPowell();
110343: PPUSH
110344: CALL_OW 559
// uc_side := 0 ;
110348: LD_ADDR_OWVAR 20
110352: PUSH
110353: LD_INT 0
110355: ST_TO_ADDR
// uc_nation := 2 ;
110356: LD_ADDR_OWVAR 21
110360: PUSH
110361: LD_INT 2
110363: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
110364: LD_ADDR_OWVAR 37
110368: PUSH
110369: LD_INT 14
110371: ST_TO_ADDR
// vc_engine := engine_siberite ;
110372: LD_ADDR_OWVAR 39
110376: PUSH
110377: LD_INT 3
110379: ST_TO_ADDR
// vc_control := control_apeman ;
110380: LD_ADDR_OWVAR 38
110384: PUSH
110385: LD_INT 5
110387: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
110388: LD_ADDR_OWVAR 40
110392: PUSH
110393: LD_INT 29
110395: ST_TO_ADDR
// un := CreateVehicle ;
110396: LD_ADDR_VAR 0 2
110400: PUSH
110401: CALL_OW 45
110405: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110406: LD_VAR 0 2
110410: PPUSH
110411: LD_INT 1
110413: PPUSH
110414: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110418: LD_INT 35
110420: PPUSH
110421: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110425: LD_VAR 0 2
110429: PPUSH
110430: LD_INT 22
110432: PUSH
110433: LD_OWVAR 2
110437: PUSH
110438: EMPTY
110439: LIST
110440: LIST
110441: PPUSH
110442: CALL_OW 69
110446: PPUSH
110447: LD_VAR 0 2
110451: PPUSH
110452: CALL_OW 74
110456: PPUSH
110457: CALL_OW 115
// until IsDead ( un ) ;
110461: LD_VAR 0 2
110465: PPUSH
110466: CALL_OW 301
110470: IFFALSE 110418
// end ;
110472: PPOPN 2
110474: END
// every 0 0$1 trigger StreamModeActive and sStu do
110475: LD_EXP 156
110479: PUSH
110480: LD_EXP 195
110484: AND
110485: IFFALSE 110501
110487: GO 110489
110489: DISABLE
// begin ToLua ( displayStucuk(); ) ;
110490: LD_STRING displayStucuk();
110492: PPUSH
110493: CALL_OW 559
// ResetFog ;
110497: CALL_OW 335
// end ;
110501: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
110502: LD_EXP 156
110506: PUSH
110507: LD_EXP 188
110511: AND
110512: IFFALSE 110653
110514: GO 110516
110516: DISABLE
110517: LD_INT 0
110519: PPUSH
110520: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110521: LD_ADDR_VAR 0 2
110525: PUSH
110526: LD_INT 22
110528: PUSH
110529: LD_OWVAR 2
110533: PUSH
110534: EMPTY
110535: LIST
110536: LIST
110537: PUSH
110538: LD_INT 21
110540: PUSH
110541: LD_INT 1
110543: PUSH
110544: EMPTY
110545: LIST
110546: LIST
110547: PUSH
110548: EMPTY
110549: LIST
110550: LIST
110551: PPUSH
110552: CALL_OW 69
110556: ST_TO_ADDR
// if not tmp then
110557: LD_VAR 0 2
110561: NOT
110562: IFFALSE 110566
// exit ;
110564: GO 110653
// un := tmp [ rand ( 1 , tmp ) ] ;
110566: LD_ADDR_VAR 0 1
110570: PUSH
110571: LD_VAR 0 2
110575: PUSH
110576: LD_INT 1
110578: PPUSH
110579: LD_VAR 0 2
110583: PPUSH
110584: CALL_OW 12
110588: ARRAY
110589: ST_TO_ADDR
// SetSide ( un , 0 ) ;
110590: LD_VAR 0 1
110594: PPUSH
110595: LD_INT 0
110597: PPUSH
110598: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
110602: LD_VAR 0 1
110606: PPUSH
110607: LD_OWVAR 3
110611: PUSH
110612: LD_VAR 0 1
110616: DIFF
110617: PPUSH
110618: LD_VAR 0 1
110622: PPUSH
110623: CALL_OW 74
110627: PPUSH
110628: CALL_OW 115
// wait ( 0 0$20 ) ;
110632: LD_INT 700
110634: PPUSH
110635: CALL_OW 67
// SetSide ( un , your_side ) ;
110639: LD_VAR 0 1
110643: PPUSH
110644: LD_OWVAR 2
110648: PPUSH
110649: CALL_OW 235
// end ;
110653: PPOPN 2
110655: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
110656: LD_EXP 156
110660: PUSH
110661: LD_EXP 189
110665: AND
110666: IFFALSE 110772
110668: GO 110670
110670: DISABLE
110671: LD_INT 0
110673: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
110674: LD_ADDR_VAR 0 1
110678: PUSH
110679: LD_INT 22
110681: PUSH
110682: LD_OWVAR 2
110686: PUSH
110687: EMPTY
110688: LIST
110689: LIST
110690: PUSH
110691: LD_INT 2
110693: PUSH
110694: LD_INT 30
110696: PUSH
110697: LD_INT 0
110699: PUSH
110700: EMPTY
110701: LIST
110702: LIST
110703: PUSH
110704: LD_INT 30
110706: PUSH
110707: LD_INT 1
110709: PUSH
110710: EMPTY
110711: LIST
110712: LIST
110713: PUSH
110714: EMPTY
110715: LIST
110716: LIST
110717: LIST
110718: PUSH
110719: EMPTY
110720: LIST
110721: LIST
110722: PPUSH
110723: CALL_OW 69
110727: ST_TO_ADDR
// if not depot then
110728: LD_VAR 0 1
110732: NOT
110733: IFFALSE 110737
// exit ;
110735: GO 110772
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
110737: LD_VAR 0 1
110741: PUSH
110742: LD_INT 1
110744: ARRAY
110745: PPUSH
110746: CALL_OW 250
110750: PPUSH
110751: LD_VAR 0 1
110755: PUSH
110756: LD_INT 1
110758: ARRAY
110759: PPUSH
110760: CALL_OW 251
110764: PPUSH
110765: LD_INT 70
110767: PPUSH
110768: CALL_OW 495
// end ;
110772: PPOPN 1
110774: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
110775: LD_EXP 156
110779: PUSH
110780: LD_EXP 190
110784: AND
110785: IFFALSE 110996
110787: GO 110789
110789: DISABLE
110790: LD_INT 0
110792: PPUSH
110793: PPUSH
110794: PPUSH
110795: PPUSH
110796: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110797: LD_ADDR_VAR 0 5
110801: PUSH
110802: LD_INT 22
110804: PUSH
110805: LD_OWVAR 2
110809: PUSH
110810: EMPTY
110811: LIST
110812: LIST
110813: PUSH
110814: LD_INT 21
110816: PUSH
110817: LD_INT 1
110819: PUSH
110820: EMPTY
110821: LIST
110822: LIST
110823: PUSH
110824: EMPTY
110825: LIST
110826: LIST
110827: PPUSH
110828: CALL_OW 69
110832: ST_TO_ADDR
// if not tmp then
110833: LD_VAR 0 5
110837: NOT
110838: IFFALSE 110842
// exit ;
110840: GO 110996
// for i in tmp do
110842: LD_ADDR_VAR 0 1
110846: PUSH
110847: LD_VAR 0 5
110851: PUSH
110852: FOR_IN
110853: IFFALSE 110994
// begin d := rand ( 0 , 5 ) ;
110855: LD_ADDR_VAR 0 4
110859: PUSH
110860: LD_INT 0
110862: PPUSH
110863: LD_INT 5
110865: PPUSH
110866: CALL_OW 12
110870: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
110871: LD_ADDR_VAR 0 2
110875: PUSH
110876: LD_VAR 0 1
110880: PPUSH
110881: CALL_OW 250
110885: PPUSH
110886: LD_VAR 0 4
110890: PPUSH
110891: LD_INT 3
110893: PPUSH
110894: LD_INT 12
110896: PPUSH
110897: CALL_OW 12
110901: PPUSH
110902: CALL_OW 272
110906: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
110907: LD_ADDR_VAR 0 3
110911: PUSH
110912: LD_VAR 0 1
110916: PPUSH
110917: CALL_OW 251
110921: PPUSH
110922: LD_VAR 0 4
110926: PPUSH
110927: LD_INT 3
110929: PPUSH
110930: LD_INT 12
110932: PPUSH
110933: CALL_OW 12
110937: PPUSH
110938: CALL_OW 273
110942: ST_TO_ADDR
// if ValidHex ( x , y ) then
110943: LD_VAR 0 2
110947: PPUSH
110948: LD_VAR 0 3
110952: PPUSH
110953: CALL_OW 488
110957: IFFALSE 110992
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
110959: LD_VAR 0 1
110963: PPUSH
110964: LD_VAR 0 2
110968: PPUSH
110969: LD_VAR 0 3
110973: PPUSH
110974: LD_INT 3
110976: PPUSH
110977: LD_INT 6
110979: PPUSH
110980: CALL_OW 12
110984: PPUSH
110985: LD_INT 1
110987: PPUSH
110988: CALL_OW 483
// end ;
110992: GO 110852
110994: POP
110995: POP
// end ;
110996: PPOPN 5
110998: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
110999: LD_EXP 156
111003: PUSH
111004: LD_EXP 191
111008: AND
111009: IFFALSE 111103
111011: GO 111013
111013: DISABLE
111014: LD_INT 0
111016: PPUSH
111017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
111018: LD_ADDR_VAR 0 2
111022: PUSH
111023: LD_INT 22
111025: PUSH
111026: LD_OWVAR 2
111030: PUSH
111031: EMPTY
111032: LIST
111033: LIST
111034: PUSH
111035: LD_INT 32
111037: PUSH
111038: LD_INT 1
111040: PUSH
111041: EMPTY
111042: LIST
111043: LIST
111044: PUSH
111045: LD_INT 21
111047: PUSH
111048: LD_INT 2
111050: PUSH
111051: EMPTY
111052: LIST
111053: LIST
111054: PUSH
111055: EMPTY
111056: LIST
111057: LIST
111058: LIST
111059: PPUSH
111060: CALL_OW 69
111064: ST_TO_ADDR
// if not tmp then
111065: LD_VAR 0 2
111069: NOT
111070: IFFALSE 111074
// exit ;
111072: GO 111103
// for i in tmp do
111074: LD_ADDR_VAR 0 1
111078: PUSH
111079: LD_VAR 0 2
111083: PUSH
111084: FOR_IN
111085: IFFALSE 111101
// SetFuel ( i , 0 ) ;
111087: LD_VAR 0 1
111091: PPUSH
111092: LD_INT 0
111094: PPUSH
111095: CALL_OW 240
111099: GO 111084
111101: POP
111102: POP
// end ;
111103: PPOPN 2
111105: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
111106: LD_EXP 156
111110: PUSH
111111: LD_EXP 192
111115: AND
111116: IFFALSE 111182
111118: GO 111120
111120: DISABLE
111121: LD_INT 0
111123: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111124: LD_ADDR_VAR 0 1
111128: PUSH
111129: LD_INT 22
111131: PUSH
111132: LD_OWVAR 2
111136: PUSH
111137: EMPTY
111138: LIST
111139: LIST
111140: PUSH
111141: LD_INT 30
111143: PUSH
111144: LD_INT 29
111146: PUSH
111147: EMPTY
111148: LIST
111149: LIST
111150: PUSH
111151: EMPTY
111152: LIST
111153: LIST
111154: PPUSH
111155: CALL_OW 69
111159: ST_TO_ADDR
// if not tmp then
111160: LD_VAR 0 1
111164: NOT
111165: IFFALSE 111169
// exit ;
111167: GO 111182
// DestroyUnit ( tmp [ 1 ] ) ;
111169: LD_VAR 0 1
111173: PUSH
111174: LD_INT 1
111176: ARRAY
111177: PPUSH
111178: CALL_OW 65
// end ;
111182: PPOPN 1
111184: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
111185: LD_EXP 156
111189: PUSH
111190: LD_EXP 194
111194: AND
111195: IFFALSE 111324
111197: GO 111199
111199: DISABLE
111200: LD_INT 0
111202: PPUSH
// begin uc_side := 0 ;
111203: LD_ADDR_OWVAR 20
111207: PUSH
111208: LD_INT 0
111210: ST_TO_ADDR
// uc_nation := nation_arabian ;
111211: LD_ADDR_OWVAR 21
111215: PUSH
111216: LD_INT 2
111218: ST_TO_ADDR
// hc_gallery :=  ;
111219: LD_ADDR_OWVAR 33
111223: PUSH
111224: LD_STRING 
111226: ST_TO_ADDR
// hc_name :=  ;
111227: LD_ADDR_OWVAR 26
111231: PUSH
111232: LD_STRING 
111234: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
111235: LD_INT 1
111237: PPUSH
111238: LD_INT 11
111240: PPUSH
111241: LD_INT 10
111243: PPUSH
111244: CALL_OW 380
// un := CreateHuman ;
111248: LD_ADDR_VAR 0 1
111252: PUSH
111253: CALL_OW 44
111257: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
111258: LD_VAR 0 1
111262: PPUSH
111263: LD_INT 1
111265: PPUSH
111266: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
111270: LD_INT 35
111272: PPUSH
111273: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
111277: LD_VAR 0 1
111281: PPUSH
111282: LD_INT 22
111284: PUSH
111285: LD_OWVAR 2
111289: PUSH
111290: EMPTY
111291: LIST
111292: LIST
111293: PPUSH
111294: CALL_OW 69
111298: PPUSH
111299: LD_VAR 0 1
111303: PPUSH
111304: CALL_OW 74
111308: PPUSH
111309: CALL_OW 115
// until IsDead ( un ) ;
111313: LD_VAR 0 1
111317: PPUSH
111318: CALL_OW 301
111322: IFFALSE 111270
// end ;
111324: PPOPN 1
111326: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
111327: LD_EXP 156
111331: PUSH
111332: LD_EXP 196
111336: AND
111337: IFFALSE 111349
111339: GO 111341
111341: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
111342: LD_STRING earthquake(getX(game), 0, 32)
111344: PPUSH
111345: CALL_OW 559
111349: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
111350: LD_EXP 156
111354: PUSH
111355: LD_EXP 197
111359: AND
111360: IFFALSE 111451
111362: GO 111364
111364: DISABLE
111365: LD_INT 0
111367: PPUSH
// begin enable ;
111368: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
111369: LD_ADDR_VAR 0 1
111373: PUSH
111374: LD_INT 22
111376: PUSH
111377: LD_OWVAR 2
111381: PUSH
111382: EMPTY
111383: LIST
111384: LIST
111385: PUSH
111386: LD_INT 21
111388: PUSH
111389: LD_INT 2
111391: PUSH
111392: EMPTY
111393: LIST
111394: LIST
111395: PUSH
111396: LD_INT 33
111398: PUSH
111399: LD_INT 3
111401: PUSH
111402: EMPTY
111403: LIST
111404: LIST
111405: PUSH
111406: EMPTY
111407: LIST
111408: LIST
111409: LIST
111410: PPUSH
111411: CALL_OW 69
111415: ST_TO_ADDR
// if not tmp then
111416: LD_VAR 0 1
111420: NOT
111421: IFFALSE 111425
// exit ;
111423: GO 111451
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111425: LD_VAR 0 1
111429: PUSH
111430: LD_INT 1
111432: PPUSH
111433: LD_VAR 0 1
111437: PPUSH
111438: CALL_OW 12
111442: ARRAY
111443: PPUSH
111444: LD_INT 1
111446: PPUSH
111447: CALL_OW 234
// end ;
111451: PPOPN 1
111453: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
111454: LD_EXP 156
111458: PUSH
111459: LD_EXP 198
111463: AND
111464: IFFALSE 111605
111466: GO 111468
111468: DISABLE
111469: LD_INT 0
111471: PPUSH
111472: PPUSH
111473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111474: LD_ADDR_VAR 0 3
111478: PUSH
111479: LD_INT 22
111481: PUSH
111482: LD_OWVAR 2
111486: PUSH
111487: EMPTY
111488: LIST
111489: LIST
111490: PUSH
111491: LD_INT 25
111493: PUSH
111494: LD_INT 1
111496: PUSH
111497: EMPTY
111498: LIST
111499: LIST
111500: PUSH
111501: EMPTY
111502: LIST
111503: LIST
111504: PPUSH
111505: CALL_OW 69
111509: ST_TO_ADDR
// if not tmp then
111510: LD_VAR 0 3
111514: NOT
111515: IFFALSE 111519
// exit ;
111517: GO 111605
// un := tmp [ rand ( 1 , tmp ) ] ;
111519: LD_ADDR_VAR 0 2
111523: PUSH
111524: LD_VAR 0 3
111528: PUSH
111529: LD_INT 1
111531: PPUSH
111532: LD_VAR 0 3
111536: PPUSH
111537: CALL_OW 12
111541: ARRAY
111542: ST_TO_ADDR
// if Crawls ( un ) then
111543: LD_VAR 0 2
111547: PPUSH
111548: CALL_OW 318
111552: IFFALSE 111563
// ComWalk ( un ) ;
111554: LD_VAR 0 2
111558: PPUSH
111559: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
111563: LD_VAR 0 2
111567: PPUSH
111568: LD_INT 9
111570: PPUSH
111571: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
111575: LD_INT 28
111577: PPUSH
111578: LD_OWVAR 2
111582: PPUSH
111583: LD_INT 2
111585: PPUSH
111586: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
111590: LD_INT 29
111592: PPUSH
111593: LD_OWVAR 2
111597: PPUSH
111598: LD_INT 2
111600: PPUSH
111601: CALL_OW 322
// end ;
111605: PPOPN 3
111607: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
111608: LD_EXP 156
111612: PUSH
111613: LD_EXP 199
111617: AND
111618: IFFALSE 111729
111620: GO 111622
111622: DISABLE
111623: LD_INT 0
111625: PPUSH
111626: PPUSH
111627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111628: LD_ADDR_VAR 0 3
111632: PUSH
111633: LD_INT 22
111635: PUSH
111636: LD_OWVAR 2
111640: PUSH
111641: EMPTY
111642: LIST
111643: LIST
111644: PUSH
111645: LD_INT 25
111647: PUSH
111648: LD_INT 1
111650: PUSH
111651: EMPTY
111652: LIST
111653: LIST
111654: PUSH
111655: EMPTY
111656: LIST
111657: LIST
111658: PPUSH
111659: CALL_OW 69
111663: ST_TO_ADDR
// if not tmp then
111664: LD_VAR 0 3
111668: NOT
111669: IFFALSE 111673
// exit ;
111671: GO 111729
// un := tmp [ rand ( 1 , tmp ) ] ;
111673: LD_ADDR_VAR 0 2
111677: PUSH
111678: LD_VAR 0 3
111682: PUSH
111683: LD_INT 1
111685: PPUSH
111686: LD_VAR 0 3
111690: PPUSH
111691: CALL_OW 12
111695: ARRAY
111696: ST_TO_ADDR
// if Crawls ( un ) then
111697: LD_VAR 0 2
111701: PPUSH
111702: CALL_OW 318
111706: IFFALSE 111717
// ComWalk ( un ) ;
111708: LD_VAR 0 2
111712: PPUSH
111713: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111717: LD_VAR 0 2
111721: PPUSH
111722: LD_INT 8
111724: PPUSH
111725: CALL_OW 336
// end ;
111729: PPOPN 3
111731: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
111732: LD_EXP 156
111736: PUSH
111737: LD_EXP 200
111741: AND
111742: IFFALSE 111886
111744: GO 111746
111746: DISABLE
111747: LD_INT 0
111749: PPUSH
111750: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
111751: LD_ADDR_VAR 0 2
111755: PUSH
111756: LD_INT 22
111758: PUSH
111759: LD_OWVAR 2
111763: PUSH
111764: EMPTY
111765: LIST
111766: LIST
111767: PUSH
111768: LD_INT 21
111770: PUSH
111771: LD_INT 2
111773: PUSH
111774: EMPTY
111775: LIST
111776: LIST
111777: PUSH
111778: LD_INT 2
111780: PUSH
111781: LD_INT 34
111783: PUSH
111784: LD_INT 12
111786: PUSH
111787: EMPTY
111788: LIST
111789: LIST
111790: PUSH
111791: LD_INT 34
111793: PUSH
111794: LD_INT 51
111796: PUSH
111797: EMPTY
111798: LIST
111799: LIST
111800: PUSH
111801: LD_INT 34
111803: PUSH
111804: LD_INT 32
111806: PUSH
111807: EMPTY
111808: LIST
111809: LIST
111810: PUSH
111811: EMPTY
111812: LIST
111813: LIST
111814: LIST
111815: LIST
111816: PUSH
111817: EMPTY
111818: LIST
111819: LIST
111820: LIST
111821: PPUSH
111822: CALL_OW 69
111826: ST_TO_ADDR
// if not tmp then
111827: LD_VAR 0 2
111831: NOT
111832: IFFALSE 111836
// exit ;
111834: GO 111886
// for i in tmp do
111836: LD_ADDR_VAR 0 1
111840: PUSH
111841: LD_VAR 0 2
111845: PUSH
111846: FOR_IN
111847: IFFALSE 111884
// if GetCargo ( i , mat_artifact ) = 0 then
111849: LD_VAR 0 1
111853: PPUSH
111854: LD_INT 4
111856: PPUSH
111857: CALL_OW 289
111861: PUSH
111862: LD_INT 0
111864: EQUAL
111865: IFFALSE 111882
// SetCargo ( i , mat_siberit , 100 ) ;
111867: LD_VAR 0 1
111871: PPUSH
111872: LD_INT 3
111874: PPUSH
111875: LD_INT 100
111877: PPUSH
111878: CALL_OW 290
111882: GO 111846
111884: POP
111885: POP
// end ;
111886: PPOPN 2
111888: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
111889: LD_EXP 156
111893: PUSH
111894: LD_EXP 201
111898: AND
111899: IFFALSE 112082
111901: GO 111903
111903: DISABLE
111904: LD_INT 0
111906: PPUSH
111907: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
111908: LD_ADDR_VAR 0 2
111912: PUSH
111913: LD_INT 22
111915: PUSH
111916: LD_OWVAR 2
111920: PUSH
111921: EMPTY
111922: LIST
111923: LIST
111924: PPUSH
111925: CALL_OW 69
111929: ST_TO_ADDR
// if not tmp then
111930: LD_VAR 0 2
111934: NOT
111935: IFFALSE 111939
// exit ;
111937: GO 112082
// for i := 1 to 2 do
111939: LD_ADDR_VAR 0 1
111943: PUSH
111944: DOUBLE
111945: LD_INT 1
111947: DEC
111948: ST_TO_ADDR
111949: LD_INT 2
111951: PUSH
111952: FOR_TO
111953: IFFALSE 112080
// begin uc_side := your_side ;
111955: LD_ADDR_OWVAR 20
111959: PUSH
111960: LD_OWVAR 2
111964: ST_TO_ADDR
// uc_nation := nation_american ;
111965: LD_ADDR_OWVAR 21
111969: PUSH
111970: LD_INT 1
111972: ST_TO_ADDR
// vc_chassis := us_morphling ;
111973: LD_ADDR_OWVAR 37
111977: PUSH
111978: LD_INT 5
111980: ST_TO_ADDR
// vc_engine := engine_siberite ;
111981: LD_ADDR_OWVAR 39
111985: PUSH
111986: LD_INT 3
111988: ST_TO_ADDR
// vc_control := control_computer ;
111989: LD_ADDR_OWVAR 38
111993: PUSH
111994: LD_INT 3
111996: ST_TO_ADDR
// vc_weapon := us_double_laser ;
111997: LD_ADDR_OWVAR 40
112001: PUSH
112002: LD_INT 10
112004: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
112005: LD_VAR 0 2
112009: PUSH
112010: LD_INT 1
112012: ARRAY
112013: PPUSH
112014: CALL_OW 310
112018: NOT
112019: IFFALSE 112066
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
112021: CALL_OW 45
112025: PPUSH
112026: LD_VAR 0 2
112030: PUSH
112031: LD_INT 1
112033: ARRAY
112034: PPUSH
112035: CALL_OW 250
112039: PPUSH
112040: LD_VAR 0 2
112044: PUSH
112045: LD_INT 1
112047: ARRAY
112048: PPUSH
112049: CALL_OW 251
112053: PPUSH
112054: LD_INT 12
112056: PPUSH
112057: LD_INT 1
112059: PPUSH
112060: CALL_OW 50
112064: GO 112078
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
112066: CALL_OW 45
112070: PPUSH
112071: LD_INT 1
112073: PPUSH
112074: CALL_OW 51
// end ;
112078: GO 111952
112080: POP
112081: POP
// end ;
112082: PPOPN 2
112084: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
112085: LD_EXP 156
112089: PUSH
112090: LD_EXP 202
112094: AND
112095: IFFALSE 112317
112097: GO 112099
112099: DISABLE
112100: LD_INT 0
112102: PPUSH
112103: PPUSH
112104: PPUSH
112105: PPUSH
112106: PPUSH
112107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112108: LD_ADDR_VAR 0 6
112112: PUSH
112113: LD_INT 22
112115: PUSH
112116: LD_OWVAR 2
112120: PUSH
112121: EMPTY
112122: LIST
112123: LIST
112124: PUSH
112125: LD_INT 21
112127: PUSH
112128: LD_INT 1
112130: PUSH
112131: EMPTY
112132: LIST
112133: LIST
112134: PUSH
112135: LD_INT 3
112137: PUSH
112138: LD_INT 23
112140: PUSH
112141: LD_INT 0
112143: PUSH
112144: EMPTY
112145: LIST
112146: LIST
112147: PUSH
112148: EMPTY
112149: LIST
112150: LIST
112151: PUSH
112152: EMPTY
112153: LIST
112154: LIST
112155: LIST
112156: PPUSH
112157: CALL_OW 69
112161: ST_TO_ADDR
// if not tmp then
112162: LD_VAR 0 6
112166: NOT
112167: IFFALSE 112171
// exit ;
112169: GO 112317
// s1 := rand ( 1 , 4 ) ;
112171: LD_ADDR_VAR 0 2
112175: PUSH
112176: LD_INT 1
112178: PPUSH
112179: LD_INT 4
112181: PPUSH
112182: CALL_OW 12
112186: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
112187: LD_ADDR_VAR 0 4
112191: PUSH
112192: LD_VAR 0 6
112196: PUSH
112197: LD_INT 1
112199: ARRAY
112200: PPUSH
112201: LD_VAR 0 2
112205: PPUSH
112206: CALL_OW 259
112210: ST_TO_ADDR
// if s1 = 1 then
112211: LD_VAR 0 2
112215: PUSH
112216: LD_INT 1
112218: EQUAL
112219: IFFALSE 112239
// s2 := rand ( 2 , 4 ) else
112221: LD_ADDR_VAR 0 3
112225: PUSH
112226: LD_INT 2
112228: PPUSH
112229: LD_INT 4
112231: PPUSH
112232: CALL_OW 12
112236: ST_TO_ADDR
112237: GO 112247
// s2 := 1 ;
112239: LD_ADDR_VAR 0 3
112243: PUSH
112244: LD_INT 1
112246: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
112247: LD_ADDR_VAR 0 5
112251: PUSH
112252: LD_VAR 0 6
112256: PUSH
112257: LD_INT 1
112259: ARRAY
112260: PPUSH
112261: LD_VAR 0 3
112265: PPUSH
112266: CALL_OW 259
112270: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
112271: LD_VAR 0 6
112275: PUSH
112276: LD_INT 1
112278: ARRAY
112279: PPUSH
112280: LD_VAR 0 2
112284: PPUSH
112285: LD_VAR 0 5
112289: PPUSH
112290: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
112294: LD_VAR 0 6
112298: PUSH
112299: LD_INT 1
112301: ARRAY
112302: PPUSH
112303: LD_VAR 0 3
112307: PPUSH
112308: LD_VAR 0 4
112312: PPUSH
112313: CALL_OW 237
// end ;
112317: PPOPN 6
112319: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
112320: LD_EXP 156
112324: PUSH
112325: LD_EXP 203
112329: AND
112330: IFFALSE 112409
112332: GO 112334
112334: DISABLE
112335: LD_INT 0
112337: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
112338: LD_ADDR_VAR 0 1
112342: PUSH
112343: LD_INT 22
112345: PUSH
112346: LD_OWVAR 2
112350: PUSH
112351: EMPTY
112352: LIST
112353: LIST
112354: PUSH
112355: LD_INT 30
112357: PUSH
112358: LD_INT 3
112360: PUSH
112361: EMPTY
112362: LIST
112363: LIST
112364: PUSH
112365: EMPTY
112366: LIST
112367: LIST
112368: PPUSH
112369: CALL_OW 69
112373: ST_TO_ADDR
// if not tmp then
112374: LD_VAR 0 1
112378: NOT
112379: IFFALSE 112383
// exit ;
112381: GO 112409
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
112383: LD_VAR 0 1
112387: PUSH
112388: LD_INT 1
112390: PPUSH
112391: LD_VAR 0 1
112395: PPUSH
112396: CALL_OW 12
112400: ARRAY
112401: PPUSH
112402: LD_INT 1
112404: PPUSH
112405: CALL_OW 234
// end ;
112409: PPOPN 1
112411: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
112412: LD_EXP 156
112416: PUSH
112417: LD_EXP 204
112421: AND
112422: IFFALSE 112534
112424: GO 112426
112426: DISABLE
112427: LD_INT 0
112429: PPUSH
112430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
112431: LD_ADDR_VAR 0 2
112435: PUSH
112436: LD_INT 22
112438: PUSH
112439: LD_OWVAR 2
112443: PUSH
112444: EMPTY
112445: LIST
112446: LIST
112447: PUSH
112448: LD_INT 2
112450: PUSH
112451: LD_INT 30
112453: PUSH
112454: LD_INT 27
112456: PUSH
112457: EMPTY
112458: LIST
112459: LIST
112460: PUSH
112461: LD_INT 30
112463: PUSH
112464: LD_INT 26
112466: PUSH
112467: EMPTY
112468: LIST
112469: LIST
112470: PUSH
112471: LD_INT 30
112473: PUSH
112474: LD_INT 28
112476: PUSH
112477: EMPTY
112478: LIST
112479: LIST
112480: PUSH
112481: EMPTY
112482: LIST
112483: LIST
112484: LIST
112485: LIST
112486: PUSH
112487: EMPTY
112488: LIST
112489: LIST
112490: PPUSH
112491: CALL_OW 69
112495: ST_TO_ADDR
// if not tmp then
112496: LD_VAR 0 2
112500: NOT
112501: IFFALSE 112505
// exit ;
112503: GO 112534
// for i in tmp do
112505: LD_ADDR_VAR 0 1
112509: PUSH
112510: LD_VAR 0 2
112514: PUSH
112515: FOR_IN
112516: IFFALSE 112532
// SetLives ( i , 1 ) ;
112518: LD_VAR 0 1
112522: PPUSH
112523: LD_INT 1
112525: PPUSH
112526: CALL_OW 234
112530: GO 112515
112532: POP
112533: POP
// end ;
112534: PPOPN 2
112536: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
112537: LD_EXP 156
112541: PUSH
112542: LD_EXP 205
112546: AND
112547: IFFALSE 112821
112549: GO 112551
112551: DISABLE
112552: LD_INT 0
112554: PPUSH
112555: PPUSH
112556: PPUSH
// begin i := rand ( 1 , 7 ) ;
112557: LD_ADDR_VAR 0 1
112561: PUSH
112562: LD_INT 1
112564: PPUSH
112565: LD_INT 7
112567: PPUSH
112568: CALL_OW 12
112572: ST_TO_ADDR
// case i of 1 :
112573: LD_VAR 0 1
112577: PUSH
112578: LD_INT 1
112580: DOUBLE
112581: EQUAL
112582: IFTRUE 112586
112584: GO 112596
112586: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
112587: LD_STRING earthquake(getX(game), 0, 32)
112589: PPUSH
112590: CALL_OW 559
112594: GO 112821
112596: LD_INT 2
112598: DOUBLE
112599: EQUAL
112600: IFTRUE 112604
112602: GO 112618
112604: POP
// begin ToLua ( displayStucuk(); ) ;
112605: LD_STRING displayStucuk();
112607: PPUSH
112608: CALL_OW 559
// ResetFog ;
112612: CALL_OW 335
// end ; 3 :
112616: GO 112821
112618: LD_INT 3
112620: DOUBLE
112621: EQUAL
112622: IFTRUE 112626
112624: GO 112730
112626: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112627: LD_ADDR_VAR 0 2
112631: PUSH
112632: LD_INT 22
112634: PUSH
112635: LD_OWVAR 2
112639: PUSH
112640: EMPTY
112641: LIST
112642: LIST
112643: PUSH
112644: LD_INT 25
112646: PUSH
112647: LD_INT 1
112649: PUSH
112650: EMPTY
112651: LIST
112652: LIST
112653: PUSH
112654: EMPTY
112655: LIST
112656: LIST
112657: PPUSH
112658: CALL_OW 69
112662: ST_TO_ADDR
// if not tmp then
112663: LD_VAR 0 2
112667: NOT
112668: IFFALSE 112672
// exit ;
112670: GO 112821
// un := tmp [ rand ( 1 , tmp ) ] ;
112672: LD_ADDR_VAR 0 3
112676: PUSH
112677: LD_VAR 0 2
112681: PUSH
112682: LD_INT 1
112684: PPUSH
112685: LD_VAR 0 2
112689: PPUSH
112690: CALL_OW 12
112694: ARRAY
112695: ST_TO_ADDR
// if Crawls ( un ) then
112696: LD_VAR 0 3
112700: PPUSH
112701: CALL_OW 318
112705: IFFALSE 112716
// ComWalk ( un ) ;
112707: LD_VAR 0 3
112711: PPUSH
112712: CALL_OW 138
// SetClass ( un , class_mortar ) ;
112716: LD_VAR 0 3
112720: PPUSH
112721: LD_INT 8
112723: PPUSH
112724: CALL_OW 336
// end ; 4 :
112728: GO 112821
112730: LD_INT 4
112732: DOUBLE
112733: EQUAL
112734: IFTRUE 112738
112736: GO 112799
112738: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
112739: LD_ADDR_VAR 0 2
112743: PUSH
112744: LD_INT 22
112746: PUSH
112747: LD_OWVAR 2
112751: PUSH
112752: EMPTY
112753: LIST
112754: LIST
112755: PUSH
112756: LD_INT 30
112758: PUSH
112759: LD_INT 29
112761: PUSH
112762: EMPTY
112763: LIST
112764: LIST
112765: PUSH
112766: EMPTY
112767: LIST
112768: LIST
112769: PPUSH
112770: CALL_OW 69
112774: ST_TO_ADDR
// if not tmp then
112775: LD_VAR 0 2
112779: NOT
112780: IFFALSE 112784
// exit ;
112782: GO 112821
// DestroyUnit ( tmp [ 1 ] ) ;
112784: LD_VAR 0 2
112788: PUSH
112789: LD_INT 1
112791: ARRAY
112792: PPUSH
112793: CALL_OW 65
// end ; 5 .. 7 :
112797: GO 112821
112799: LD_INT 5
112801: DOUBLE
112802: GREATEREQUAL
112803: IFFALSE 112811
112805: LD_INT 7
112807: DOUBLE
112808: LESSEQUAL
112809: IFTRUE 112813
112811: GO 112820
112813: POP
// StreamSibBomb ; end ;
112814: CALL 109071 0 0
112818: GO 112821
112820: POP
// end ;
112821: PPOPN 3
112823: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
112824: LD_EXP 156
112828: PUSH
112829: LD_EXP 206
112833: AND
112834: IFFALSE 112990
112836: GO 112838
112838: DISABLE
112839: LD_INT 0
112841: PPUSH
112842: PPUSH
112843: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
112844: LD_ADDR_VAR 0 2
112848: PUSH
112849: LD_INT 81
112851: PUSH
112852: LD_OWVAR 2
112856: PUSH
112857: EMPTY
112858: LIST
112859: LIST
112860: PUSH
112861: LD_INT 2
112863: PUSH
112864: LD_INT 21
112866: PUSH
112867: LD_INT 1
112869: PUSH
112870: EMPTY
112871: LIST
112872: LIST
112873: PUSH
112874: LD_INT 21
112876: PUSH
112877: LD_INT 2
112879: PUSH
112880: EMPTY
112881: LIST
112882: LIST
112883: PUSH
112884: EMPTY
112885: LIST
112886: LIST
112887: LIST
112888: PUSH
112889: EMPTY
112890: LIST
112891: LIST
112892: PPUSH
112893: CALL_OW 69
112897: ST_TO_ADDR
// if not tmp then
112898: LD_VAR 0 2
112902: NOT
112903: IFFALSE 112907
// exit ;
112905: GO 112990
// p := 0 ;
112907: LD_ADDR_VAR 0 3
112911: PUSH
112912: LD_INT 0
112914: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112915: LD_INT 35
112917: PPUSH
112918: CALL_OW 67
// p := p + 1 ;
112922: LD_ADDR_VAR 0 3
112926: PUSH
112927: LD_VAR 0 3
112931: PUSH
112932: LD_INT 1
112934: PLUS
112935: ST_TO_ADDR
// for i in tmp do
112936: LD_ADDR_VAR 0 1
112940: PUSH
112941: LD_VAR 0 2
112945: PUSH
112946: FOR_IN
112947: IFFALSE 112978
// if GetLives ( i ) < 1000 then
112949: LD_VAR 0 1
112953: PPUSH
112954: CALL_OW 256
112958: PUSH
112959: LD_INT 1000
112961: LESS
112962: IFFALSE 112976
// SetLives ( i , 1000 ) ;
112964: LD_VAR 0 1
112968: PPUSH
112969: LD_INT 1000
112971: PPUSH
112972: CALL_OW 234
112976: GO 112946
112978: POP
112979: POP
// until p > 20 ;
112980: LD_VAR 0 3
112984: PUSH
112985: LD_INT 20
112987: GREATER
112988: IFFALSE 112915
// end ;
112990: PPOPN 3
112992: END
// every 0 0$1 trigger StreamModeActive and sTime do
112993: LD_EXP 156
112997: PUSH
112998: LD_EXP 207
113002: AND
113003: IFFALSE 113038
113005: GO 113007
113007: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
113008: LD_INT 28
113010: PPUSH
113011: LD_OWVAR 2
113015: PPUSH
113016: LD_INT 2
113018: PPUSH
113019: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
113023: LD_INT 30
113025: PPUSH
113026: LD_OWVAR 2
113030: PPUSH
113031: LD_INT 2
113033: PPUSH
113034: CALL_OW 322
// end ;
113038: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
113039: LD_EXP 156
113043: PUSH
113044: LD_EXP 208
113048: AND
113049: IFFALSE 113170
113051: GO 113053
113053: DISABLE
113054: LD_INT 0
113056: PPUSH
113057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113058: LD_ADDR_VAR 0 2
113062: PUSH
113063: LD_INT 22
113065: PUSH
113066: LD_OWVAR 2
113070: PUSH
113071: EMPTY
113072: LIST
113073: LIST
113074: PUSH
113075: LD_INT 21
113077: PUSH
113078: LD_INT 1
113080: PUSH
113081: EMPTY
113082: LIST
113083: LIST
113084: PUSH
113085: LD_INT 3
113087: PUSH
113088: LD_INT 23
113090: PUSH
113091: LD_INT 0
113093: PUSH
113094: EMPTY
113095: LIST
113096: LIST
113097: PUSH
113098: EMPTY
113099: LIST
113100: LIST
113101: PUSH
113102: EMPTY
113103: LIST
113104: LIST
113105: LIST
113106: PPUSH
113107: CALL_OW 69
113111: ST_TO_ADDR
// if not tmp then
113112: LD_VAR 0 2
113116: NOT
113117: IFFALSE 113121
// exit ;
113119: GO 113170
// for i in tmp do
113121: LD_ADDR_VAR 0 1
113125: PUSH
113126: LD_VAR 0 2
113130: PUSH
113131: FOR_IN
113132: IFFALSE 113168
// begin if Crawls ( i ) then
113134: LD_VAR 0 1
113138: PPUSH
113139: CALL_OW 318
113143: IFFALSE 113154
// ComWalk ( i ) ;
113145: LD_VAR 0 1
113149: PPUSH
113150: CALL_OW 138
// SetClass ( i , 2 ) ;
113154: LD_VAR 0 1
113158: PPUSH
113159: LD_INT 2
113161: PPUSH
113162: CALL_OW 336
// end ;
113166: GO 113131
113168: POP
113169: POP
// end ;
113170: PPOPN 2
113172: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
113173: LD_EXP 156
113177: PUSH
113178: LD_EXP 209
113182: AND
113183: IFFALSE 113464
113185: GO 113187
113187: DISABLE
113188: LD_INT 0
113190: PPUSH
113191: PPUSH
113192: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
113193: LD_OWVAR 2
113197: PPUSH
113198: LD_INT 9
113200: PPUSH
113201: LD_INT 1
113203: PPUSH
113204: LD_INT 1
113206: PPUSH
113207: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
113211: LD_INT 9
113213: PPUSH
113214: LD_OWVAR 2
113218: PPUSH
113219: CALL_OW 343
// uc_side := 9 ;
113223: LD_ADDR_OWVAR 20
113227: PUSH
113228: LD_INT 9
113230: ST_TO_ADDR
// uc_nation := 2 ;
113231: LD_ADDR_OWVAR 21
113235: PUSH
113236: LD_INT 2
113238: ST_TO_ADDR
// hc_name := Dark Warrior ;
113239: LD_ADDR_OWVAR 26
113243: PUSH
113244: LD_STRING Dark Warrior
113246: ST_TO_ADDR
// hc_gallery :=  ;
113247: LD_ADDR_OWVAR 33
113251: PUSH
113252: LD_STRING 
113254: ST_TO_ADDR
// hc_noskilllimit := true ;
113255: LD_ADDR_OWVAR 76
113259: PUSH
113260: LD_INT 1
113262: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
113263: LD_ADDR_OWVAR 31
113267: PUSH
113268: LD_INT 30
113270: PUSH
113271: LD_INT 30
113273: PUSH
113274: LD_INT 30
113276: PUSH
113277: LD_INT 30
113279: PUSH
113280: EMPTY
113281: LIST
113282: LIST
113283: LIST
113284: LIST
113285: ST_TO_ADDR
// un := CreateHuman ;
113286: LD_ADDR_VAR 0 3
113290: PUSH
113291: CALL_OW 44
113295: ST_TO_ADDR
// hc_noskilllimit := false ;
113296: LD_ADDR_OWVAR 76
113300: PUSH
113301: LD_INT 0
113303: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113304: LD_VAR 0 3
113308: PPUSH
113309: LD_INT 1
113311: PPUSH
113312: CALL_OW 51
// p := 0 ;
113316: LD_ADDR_VAR 0 2
113320: PUSH
113321: LD_INT 0
113323: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
113324: LD_INT 35
113326: PPUSH
113327: CALL_OW 67
// p := p + 1 ;
113331: LD_ADDR_VAR 0 2
113335: PUSH
113336: LD_VAR 0 2
113340: PUSH
113341: LD_INT 1
113343: PLUS
113344: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
113345: LD_VAR 0 3
113349: PPUSH
113350: CALL_OW 256
113354: PUSH
113355: LD_INT 1000
113357: LESS
113358: IFFALSE 113372
// SetLives ( un , 1000 ) ;
113360: LD_VAR 0 3
113364: PPUSH
113365: LD_INT 1000
113367: PPUSH
113368: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
113372: LD_VAR 0 3
113376: PPUSH
113377: LD_INT 81
113379: PUSH
113380: LD_OWVAR 2
113384: PUSH
113385: EMPTY
113386: LIST
113387: LIST
113388: PUSH
113389: LD_INT 91
113391: PUSH
113392: LD_VAR 0 3
113396: PUSH
113397: LD_INT 30
113399: PUSH
113400: EMPTY
113401: LIST
113402: LIST
113403: LIST
113404: PUSH
113405: EMPTY
113406: LIST
113407: LIST
113408: PPUSH
113409: CALL_OW 69
113413: PPUSH
113414: LD_VAR 0 3
113418: PPUSH
113419: CALL_OW 74
113423: PPUSH
113424: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
113428: LD_VAR 0 2
113432: PUSH
113433: LD_INT 60
113435: GREATER
113436: PUSH
113437: LD_VAR 0 3
113441: PPUSH
113442: CALL_OW 301
113446: OR
113447: IFFALSE 113324
// if un then
113449: LD_VAR 0 3
113453: IFFALSE 113464
// RemoveUnit ( un ) ;
113455: LD_VAR 0 3
113459: PPUSH
113460: CALL_OW 64
// end ;
113464: PPOPN 3
113466: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113467: LD_INT 0
113469: PPUSH
// case cmd of 301 :
113470: LD_VAR 0 1
113474: PUSH
113475: LD_INT 301
113477: DOUBLE
113478: EQUAL
113479: IFTRUE 113483
113481: GO 113515
113483: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
113484: LD_VAR 0 6
113488: PPUSH
113489: LD_VAR 0 7
113493: PPUSH
113494: LD_VAR 0 8
113498: PPUSH
113499: LD_VAR 0 4
113503: PPUSH
113504: LD_VAR 0 5
113508: PPUSH
113509: CALL 114716 0 5
113513: GO 113636
113515: LD_INT 302
113517: DOUBLE
113518: EQUAL
113519: IFTRUE 113523
113521: GO 113560
113523: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
113524: LD_VAR 0 6
113528: PPUSH
113529: LD_VAR 0 7
113533: PPUSH
113534: LD_VAR 0 8
113538: PPUSH
113539: LD_VAR 0 9
113543: PPUSH
113544: LD_VAR 0 4
113548: PPUSH
113549: LD_VAR 0 5
113553: PPUSH
113554: CALL 114807 0 6
113558: GO 113636
113560: LD_INT 303
113562: DOUBLE
113563: EQUAL
113564: IFTRUE 113568
113566: GO 113605
113568: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
113569: LD_VAR 0 6
113573: PPUSH
113574: LD_VAR 0 7
113578: PPUSH
113579: LD_VAR 0 8
113583: PPUSH
113584: LD_VAR 0 9
113588: PPUSH
113589: LD_VAR 0 4
113593: PPUSH
113594: LD_VAR 0 5
113598: PPUSH
113599: CALL 113641 0 6
113603: GO 113636
113605: LD_INT 304
113607: DOUBLE
113608: EQUAL
113609: IFTRUE 113613
113611: GO 113635
113613: POP
// hHackTeleport ( unit , x , y ) ; end ;
113614: LD_VAR 0 2
113618: PPUSH
113619: LD_VAR 0 4
113623: PPUSH
113624: LD_VAR 0 5
113628: PPUSH
113629: CALL 115400 0 3
113633: GO 113636
113635: POP
// end ;
113636: LD_VAR 0 12
113640: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
113641: LD_INT 0
113643: PPUSH
113644: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
113645: LD_VAR 0 1
113649: PUSH
113650: LD_INT 1
113652: LESS
113653: PUSH
113654: LD_VAR 0 1
113658: PUSH
113659: LD_INT 3
113661: GREATER
113662: OR
113663: PUSH
113664: LD_VAR 0 5
113668: PPUSH
113669: LD_VAR 0 6
113673: PPUSH
113674: CALL_OW 428
113678: OR
113679: IFFALSE 113683
// exit ;
113681: GO 114403
// uc_side := your_side ;
113683: LD_ADDR_OWVAR 20
113687: PUSH
113688: LD_OWVAR 2
113692: ST_TO_ADDR
// uc_nation := nation ;
113693: LD_ADDR_OWVAR 21
113697: PUSH
113698: LD_VAR 0 1
113702: ST_TO_ADDR
// bc_level = 1 ;
113703: LD_ADDR_OWVAR 43
113707: PUSH
113708: LD_INT 1
113710: ST_TO_ADDR
// case btype of 1 :
113711: LD_VAR 0 2
113715: PUSH
113716: LD_INT 1
113718: DOUBLE
113719: EQUAL
113720: IFTRUE 113724
113722: GO 113735
113724: POP
// bc_type := b_depot ; 2 :
113725: LD_ADDR_OWVAR 42
113729: PUSH
113730: LD_INT 0
113732: ST_TO_ADDR
113733: GO 114347
113735: LD_INT 2
113737: DOUBLE
113738: EQUAL
113739: IFTRUE 113743
113741: GO 113754
113743: POP
// bc_type := b_warehouse ; 3 :
113744: LD_ADDR_OWVAR 42
113748: PUSH
113749: LD_INT 1
113751: ST_TO_ADDR
113752: GO 114347
113754: LD_INT 3
113756: DOUBLE
113757: EQUAL
113758: IFTRUE 113762
113760: GO 113773
113762: POP
// bc_type := b_lab ; 4 .. 9 :
113763: LD_ADDR_OWVAR 42
113767: PUSH
113768: LD_INT 6
113770: ST_TO_ADDR
113771: GO 114347
113773: LD_INT 4
113775: DOUBLE
113776: GREATEREQUAL
113777: IFFALSE 113785
113779: LD_INT 9
113781: DOUBLE
113782: LESSEQUAL
113783: IFTRUE 113787
113785: GO 113839
113787: POP
// begin bc_type := b_lab_half ;
113788: LD_ADDR_OWVAR 42
113792: PUSH
113793: LD_INT 7
113795: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
113796: LD_ADDR_OWVAR 44
113800: PUSH
113801: LD_INT 10
113803: PUSH
113804: LD_INT 11
113806: PUSH
113807: LD_INT 12
113809: PUSH
113810: LD_INT 15
113812: PUSH
113813: LD_INT 14
113815: PUSH
113816: LD_INT 13
113818: PUSH
113819: EMPTY
113820: LIST
113821: LIST
113822: LIST
113823: LIST
113824: LIST
113825: LIST
113826: PUSH
113827: LD_VAR 0 2
113831: PUSH
113832: LD_INT 3
113834: MINUS
113835: ARRAY
113836: ST_TO_ADDR
// end ; 10 .. 13 :
113837: GO 114347
113839: LD_INT 10
113841: DOUBLE
113842: GREATEREQUAL
113843: IFFALSE 113851
113845: LD_INT 13
113847: DOUBLE
113848: LESSEQUAL
113849: IFTRUE 113853
113851: GO 113930
113853: POP
// begin bc_type := b_lab_full ;
113854: LD_ADDR_OWVAR 42
113858: PUSH
113859: LD_INT 8
113861: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
113862: LD_ADDR_OWVAR 44
113866: PUSH
113867: LD_INT 10
113869: PUSH
113870: LD_INT 12
113872: PUSH
113873: LD_INT 14
113875: PUSH
113876: LD_INT 13
113878: PUSH
113879: EMPTY
113880: LIST
113881: LIST
113882: LIST
113883: LIST
113884: PUSH
113885: LD_VAR 0 2
113889: PUSH
113890: LD_INT 9
113892: MINUS
113893: ARRAY
113894: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
113895: LD_ADDR_OWVAR 45
113899: PUSH
113900: LD_INT 11
113902: PUSH
113903: LD_INT 15
113905: PUSH
113906: LD_INT 12
113908: PUSH
113909: LD_INT 15
113911: PUSH
113912: EMPTY
113913: LIST
113914: LIST
113915: LIST
113916: LIST
113917: PUSH
113918: LD_VAR 0 2
113922: PUSH
113923: LD_INT 9
113925: MINUS
113926: ARRAY
113927: ST_TO_ADDR
// end ; 14 :
113928: GO 114347
113930: LD_INT 14
113932: DOUBLE
113933: EQUAL
113934: IFTRUE 113938
113936: GO 113949
113938: POP
// bc_type := b_workshop ; 15 :
113939: LD_ADDR_OWVAR 42
113943: PUSH
113944: LD_INT 2
113946: ST_TO_ADDR
113947: GO 114347
113949: LD_INT 15
113951: DOUBLE
113952: EQUAL
113953: IFTRUE 113957
113955: GO 113968
113957: POP
// bc_type := b_factory ; 16 :
113958: LD_ADDR_OWVAR 42
113962: PUSH
113963: LD_INT 3
113965: ST_TO_ADDR
113966: GO 114347
113968: LD_INT 16
113970: DOUBLE
113971: EQUAL
113972: IFTRUE 113976
113974: GO 113987
113976: POP
// bc_type := b_ext_gun ; 17 :
113977: LD_ADDR_OWVAR 42
113981: PUSH
113982: LD_INT 17
113984: ST_TO_ADDR
113985: GO 114347
113987: LD_INT 17
113989: DOUBLE
113990: EQUAL
113991: IFTRUE 113995
113993: GO 114023
113995: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
113996: LD_ADDR_OWVAR 42
114000: PUSH
114001: LD_INT 19
114003: PUSH
114004: LD_INT 23
114006: PUSH
114007: LD_INT 19
114009: PUSH
114010: EMPTY
114011: LIST
114012: LIST
114013: LIST
114014: PUSH
114015: LD_VAR 0 1
114019: ARRAY
114020: ST_TO_ADDR
114021: GO 114347
114023: LD_INT 18
114025: DOUBLE
114026: EQUAL
114027: IFTRUE 114031
114029: GO 114042
114031: POP
// bc_type := b_ext_radar ; 19 :
114032: LD_ADDR_OWVAR 42
114036: PUSH
114037: LD_INT 20
114039: ST_TO_ADDR
114040: GO 114347
114042: LD_INT 19
114044: DOUBLE
114045: EQUAL
114046: IFTRUE 114050
114048: GO 114061
114050: POP
// bc_type := b_ext_radio ; 20 :
114051: LD_ADDR_OWVAR 42
114055: PUSH
114056: LD_INT 22
114058: ST_TO_ADDR
114059: GO 114347
114061: LD_INT 20
114063: DOUBLE
114064: EQUAL
114065: IFTRUE 114069
114067: GO 114080
114069: POP
// bc_type := b_ext_siberium ; 21 :
114070: LD_ADDR_OWVAR 42
114074: PUSH
114075: LD_INT 21
114077: ST_TO_ADDR
114078: GO 114347
114080: LD_INT 21
114082: DOUBLE
114083: EQUAL
114084: IFTRUE 114088
114086: GO 114099
114088: POP
// bc_type := b_ext_computer ; 22 :
114089: LD_ADDR_OWVAR 42
114093: PUSH
114094: LD_INT 24
114096: ST_TO_ADDR
114097: GO 114347
114099: LD_INT 22
114101: DOUBLE
114102: EQUAL
114103: IFTRUE 114107
114105: GO 114118
114107: POP
// bc_type := b_ext_track ; 23 :
114108: LD_ADDR_OWVAR 42
114112: PUSH
114113: LD_INT 16
114115: ST_TO_ADDR
114116: GO 114347
114118: LD_INT 23
114120: DOUBLE
114121: EQUAL
114122: IFTRUE 114126
114124: GO 114137
114126: POP
// bc_type := b_ext_laser ; 24 :
114127: LD_ADDR_OWVAR 42
114131: PUSH
114132: LD_INT 25
114134: ST_TO_ADDR
114135: GO 114347
114137: LD_INT 24
114139: DOUBLE
114140: EQUAL
114141: IFTRUE 114145
114143: GO 114156
114145: POP
// bc_type := b_control_tower ; 25 :
114146: LD_ADDR_OWVAR 42
114150: PUSH
114151: LD_INT 36
114153: ST_TO_ADDR
114154: GO 114347
114156: LD_INT 25
114158: DOUBLE
114159: EQUAL
114160: IFTRUE 114164
114162: GO 114175
114164: POP
// bc_type := b_breastwork ; 26 :
114165: LD_ADDR_OWVAR 42
114169: PUSH
114170: LD_INT 31
114172: ST_TO_ADDR
114173: GO 114347
114175: LD_INT 26
114177: DOUBLE
114178: EQUAL
114179: IFTRUE 114183
114181: GO 114194
114183: POP
// bc_type := b_bunker ; 27 :
114184: LD_ADDR_OWVAR 42
114188: PUSH
114189: LD_INT 32
114191: ST_TO_ADDR
114192: GO 114347
114194: LD_INT 27
114196: DOUBLE
114197: EQUAL
114198: IFTRUE 114202
114200: GO 114213
114202: POP
// bc_type := b_turret ; 28 :
114203: LD_ADDR_OWVAR 42
114207: PUSH
114208: LD_INT 33
114210: ST_TO_ADDR
114211: GO 114347
114213: LD_INT 28
114215: DOUBLE
114216: EQUAL
114217: IFTRUE 114221
114219: GO 114232
114221: POP
// bc_type := b_armoury ; 29 :
114222: LD_ADDR_OWVAR 42
114226: PUSH
114227: LD_INT 4
114229: ST_TO_ADDR
114230: GO 114347
114232: LD_INT 29
114234: DOUBLE
114235: EQUAL
114236: IFTRUE 114240
114238: GO 114251
114240: POP
// bc_type := b_barracks ; 30 :
114241: LD_ADDR_OWVAR 42
114245: PUSH
114246: LD_INT 5
114248: ST_TO_ADDR
114249: GO 114347
114251: LD_INT 30
114253: DOUBLE
114254: EQUAL
114255: IFTRUE 114259
114257: GO 114270
114259: POP
// bc_type := b_solar_power ; 31 :
114260: LD_ADDR_OWVAR 42
114264: PUSH
114265: LD_INT 27
114267: ST_TO_ADDR
114268: GO 114347
114270: LD_INT 31
114272: DOUBLE
114273: EQUAL
114274: IFTRUE 114278
114276: GO 114289
114278: POP
// bc_type := b_oil_power ; 32 :
114279: LD_ADDR_OWVAR 42
114283: PUSH
114284: LD_INT 26
114286: ST_TO_ADDR
114287: GO 114347
114289: LD_INT 32
114291: DOUBLE
114292: EQUAL
114293: IFTRUE 114297
114295: GO 114308
114297: POP
// bc_type := b_siberite_power ; 33 :
114298: LD_ADDR_OWVAR 42
114302: PUSH
114303: LD_INT 28
114305: ST_TO_ADDR
114306: GO 114347
114308: LD_INT 33
114310: DOUBLE
114311: EQUAL
114312: IFTRUE 114316
114314: GO 114327
114316: POP
// bc_type := b_oil_mine ; 34 :
114317: LD_ADDR_OWVAR 42
114321: PUSH
114322: LD_INT 29
114324: ST_TO_ADDR
114325: GO 114347
114327: LD_INT 34
114329: DOUBLE
114330: EQUAL
114331: IFTRUE 114335
114333: GO 114346
114335: POP
// bc_type := b_siberite_mine ; end ;
114336: LD_ADDR_OWVAR 42
114340: PUSH
114341: LD_INT 30
114343: ST_TO_ADDR
114344: GO 114347
114346: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
114347: LD_ADDR_VAR 0 8
114351: PUSH
114352: LD_VAR 0 5
114356: PPUSH
114357: LD_VAR 0 6
114361: PPUSH
114362: LD_VAR 0 3
114366: PPUSH
114367: CALL_OW 47
114371: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
114372: LD_OWVAR 42
114376: PUSH
114377: LD_INT 32
114379: PUSH
114380: LD_INT 33
114382: PUSH
114383: EMPTY
114384: LIST
114385: LIST
114386: IN
114387: IFFALSE 114403
// PlaceWeaponTurret ( b , weapon ) ;
114389: LD_VAR 0 8
114393: PPUSH
114394: LD_VAR 0 4
114398: PPUSH
114399: CALL_OW 431
// end ;
114403: LD_VAR 0 7
114407: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
114408: LD_INT 0
114410: PPUSH
114411: PPUSH
114412: PPUSH
114413: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
114414: LD_ADDR_VAR 0 4
114418: PUSH
114419: LD_INT 22
114421: PUSH
114422: LD_OWVAR 2
114426: PUSH
114427: EMPTY
114428: LIST
114429: LIST
114430: PUSH
114431: LD_INT 2
114433: PUSH
114434: LD_INT 30
114436: PUSH
114437: LD_INT 0
114439: PUSH
114440: EMPTY
114441: LIST
114442: LIST
114443: PUSH
114444: LD_INT 30
114446: PUSH
114447: LD_INT 1
114449: PUSH
114450: EMPTY
114451: LIST
114452: LIST
114453: PUSH
114454: EMPTY
114455: LIST
114456: LIST
114457: LIST
114458: PUSH
114459: EMPTY
114460: LIST
114461: LIST
114462: PPUSH
114463: CALL_OW 69
114467: ST_TO_ADDR
// if not tmp then
114468: LD_VAR 0 4
114472: NOT
114473: IFFALSE 114477
// exit ;
114475: GO 114536
// for i in tmp do
114477: LD_ADDR_VAR 0 2
114481: PUSH
114482: LD_VAR 0 4
114486: PUSH
114487: FOR_IN
114488: IFFALSE 114534
// for j = 1 to 3 do
114490: LD_ADDR_VAR 0 3
114494: PUSH
114495: DOUBLE
114496: LD_INT 1
114498: DEC
114499: ST_TO_ADDR
114500: LD_INT 3
114502: PUSH
114503: FOR_TO
114504: IFFALSE 114530
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
114506: LD_VAR 0 2
114510: PPUSH
114511: CALL_OW 274
114515: PPUSH
114516: LD_VAR 0 3
114520: PPUSH
114521: LD_INT 99999
114523: PPUSH
114524: CALL_OW 277
114528: GO 114503
114530: POP
114531: POP
114532: GO 114487
114534: POP
114535: POP
// end ;
114536: LD_VAR 0 1
114540: RET
// export function hHackSetLevel10 ; var i , j ; begin
114541: LD_INT 0
114543: PPUSH
114544: PPUSH
114545: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
114546: LD_ADDR_VAR 0 2
114550: PUSH
114551: LD_INT 21
114553: PUSH
114554: LD_INT 1
114556: PUSH
114557: EMPTY
114558: LIST
114559: LIST
114560: PPUSH
114561: CALL_OW 69
114565: PUSH
114566: FOR_IN
114567: IFFALSE 114619
// if IsSelected ( i ) then
114569: LD_VAR 0 2
114573: PPUSH
114574: CALL_OW 306
114578: IFFALSE 114617
// begin for j := 1 to 4 do
114580: LD_ADDR_VAR 0 3
114584: PUSH
114585: DOUBLE
114586: LD_INT 1
114588: DEC
114589: ST_TO_ADDR
114590: LD_INT 4
114592: PUSH
114593: FOR_TO
114594: IFFALSE 114615
// SetSkill ( i , j , 10 ) ;
114596: LD_VAR 0 2
114600: PPUSH
114601: LD_VAR 0 3
114605: PPUSH
114606: LD_INT 10
114608: PPUSH
114609: CALL_OW 237
114613: GO 114593
114615: POP
114616: POP
// end ;
114617: GO 114566
114619: POP
114620: POP
// end ;
114621: LD_VAR 0 1
114625: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
114626: LD_INT 0
114628: PPUSH
114629: PPUSH
114630: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
114631: LD_ADDR_VAR 0 2
114635: PUSH
114636: LD_INT 22
114638: PUSH
114639: LD_OWVAR 2
114643: PUSH
114644: EMPTY
114645: LIST
114646: LIST
114647: PUSH
114648: LD_INT 21
114650: PUSH
114651: LD_INT 1
114653: PUSH
114654: EMPTY
114655: LIST
114656: LIST
114657: PUSH
114658: EMPTY
114659: LIST
114660: LIST
114661: PPUSH
114662: CALL_OW 69
114666: PUSH
114667: FOR_IN
114668: IFFALSE 114709
// begin for j := 1 to 4 do
114670: LD_ADDR_VAR 0 3
114674: PUSH
114675: DOUBLE
114676: LD_INT 1
114678: DEC
114679: ST_TO_ADDR
114680: LD_INT 4
114682: PUSH
114683: FOR_TO
114684: IFFALSE 114705
// SetSkill ( i , j , 10 ) ;
114686: LD_VAR 0 2
114690: PPUSH
114691: LD_VAR 0 3
114695: PPUSH
114696: LD_INT 10
114698: PPUSH
114699: CALL_OW 237
114703: GO 114683
114705: POP
114706: POP
// end ;
114707: GO 114667
114709: POP
114710: POP
// end ;
114711: LD_VAR 0 1
114715: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
114716: LD_INT 0
114718: PPUSH
// uc_side := your_side ;
114719: LD_ADDR_OWVAR 20
114723: PUSH
114724: LD_OWVAR 2
114728: ST_TO_ADDR
// uc_nation := nation ;
114729: LD_ADDR_OWVAR 21
114733: PUSH
114734: LD_VAR 0 1
114738: ST_TO_ADDR
// InitHc ;
114739: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
114743: LD_INT 0
114745: PPUSH
114746: LD_VAR 0 2
114750: PPUSH
114751: LD_VAR 0 3
114755: PPUSH
114756: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
114760: LD_VAR 0 4
114764: PPUSH
114765: LD_VAR 0 5
114769: PPUSH
114770: CALL_OW 428
114774: PUSH
114775: LD_INT 0
114777: EQUAL
114778: IFFALSE 114802
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
114780: CALL_OW 44
114784: PPUSH
114785: LD_VAR 0 4
114789: PPUSH
114790: LD_VAR 0 5
114794: PPUSH
114795: LD_INT 1
114797: PPUSH
114798: CALL_OW 48
// end ;
114802: LD_VAR 0 6
114806: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
114807: LD_INT 0
114809: PPUSH
114810: PPUSH
// uc_side := your_side ;
114811: LD_ADDR_OWVAR 20
114815: PUSH
114816: LD_OWVAR 2
114820: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
114821: LD_VAR 0 1
114825: PUSH
114826: LD_INT 1
114828: PUSH
114829: LD_INT 2
114831: PUSH
114832: LD_INT 3
114834: PUSH
114835: LD_INT 4
114837: PUSH
114838: LD_INT 5
114840: PUSH
114841: EMPTY
114842: LIST
114843: LIST
114844: LIST
114845: LIST
114846: LIST
114847: IN
114848: IFFALSE 114860
// uc_nation := nation_american else
114850: LD_ADDR_OWVAR 21
114854: PUSH
114855: LD_INT 1
114857: ST_TO_ADDR
114858: GO 114903
// if chassis in [ 11 , 12 , 13 , 14 ] then
114860: LD_VAR 0 1
114864: PUSH
114865: LD_INT 11
114867: PUSH
114868: LD_INT 12
114870: PUSH
114871: LD_INT 13
114873: PUSH
114874: LD_INT 14
114876: PUSH
114877: EMPTY
114878: LIST
114879: LIST
114880: LIST
114881: LIST
114882: IN
114883: IFFALSE 114895
// uc_nation := nation_arabian else
114885: LD_ADDR_OWVAR 21
114889: PUSH
114890: LD_INT 2
114892: ST_TO_ADDR
114893: GO 114903
// uc_nation := nation_russian ;
114895: LD_ADDR_OWVAR 21
114899: PUSH
114900: LD_INT 3
114902: ST_TO_ADDR
// vc_chassis := chassis ;
114903: LD_ADDR_OWVAR 37
114907: PUSH
114908: LD_VAR 0 1
114912: ST_TO_ADDR
// vc_engine := engine ;
114913: LD_ADDR_OWVAR 39
114917: PUSH
114918: LD_VAR 0 2
114922: ST_TO_ADDR
// vc_control := control ;
114923: LD_ADDR_OWVAR 38
114927: PUSH
114928: LD_VAR 0 3
114932: ST_TO_ADDR
// vc_weapon := weapon ;
114933: LD_ADDR_OWVAR 40
114937: PUSH
114938: LD_VAR 0 4
114942: ST_TO_ADDR
// un := CreateVehicle ;
114943: LD_ADDR_VAR 0 8
114947: PUSH
114948: CALL_OW 45
114952: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
114953: LD_VAR 0 8
114957: PPUSH
114958: LD_INT 0
114960: PPUSH
114961: LD_INT 5
114963: PPUSH
114964: CALL_OW 12
114968: PPUSH
114969: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
114973: LD_VAR 0 8
114977: PPUSH
114978: LD_VAR 0 5
114982: PPUSH
114983: LD_VAR 0 6
114987: PPUSH
114988: LD_INT 1
114990: PPUSH
114991: CALL_OW 48
// end ;
114995: LD_VAR 0 7
114999: RET
// export hInvincible ; every 1 do
115000: GO 115002
115002: DISABLE
// hInvincible := [ ] ;
115003: LD_ADDR_EXP 210
115007: PUSH
115008: EMPTY
115009: ST_TO_ADDR
115010: END
// every 10 do var i ;
115011: GO 115013
115013: DISABLE
115014: LD_INT 0
115016: PPUSH
// begin enable ;
115017: ENABLE
// if not hInvincible then
115018: LD_EXP 210
115022: NOT
115023: IFFALSE 115027
// exit ;
115025: GO 115071
// for i in hInvincible do
115027: LD_ADDR_VAR 0 1
115031: PUSH
115032: LD_EXP 210
115036: PUSH
115037: FOR_IN
115038: IFFALSE 115069
// if GetLives ( i ) < 1000 then
115040: LD_VAR 0 1
115044: PPUSH
115045: CALL_OW 256
115049: PUSH
115050: LD_INT 1000
115052: LESS
115053: IFFALSE 115067
// SetLives ( i , 1000 ) ;
115055: LD_VAR 0 1
115059: PPUSH
115060: LD_INT 1000
115062: PPUSH
115063: CALL_OW 234
115067: GO 115037
115069: POP
115070: POP
// end ;
115071: PPOPN 1
115073: END
// export function hHackInvincible ; var i ; begin
115074: LD_INT 0
115076: PPUSH
115077: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
115078: LD_ADDR_VAR 0 2
115082: PUSH
115083: LD_INT 2
115085: PUSH
115086: LD_INT 21
115088: PUSH
115089: LD_INT 1
115091: PUSH
115092: EMPTY
115093: LIST
115094: LIST
115095: PUSH
115096: LD_INT 21
115098: PUSH
115099: LD_INT 2
115101: PUSH
115102: EMPTY
115103: LIST
115104: LIST
115105: PUSH
115106: EMPTY
115107: LIST
115108: LIST
115109: LIST
115110: PPUSH
115111: CALL_OW 69
115115: PUSH
115116: FOR_IN
115117: IFFALSE 115178
// if IsSelected ( i ) then
115119: LD_VAR 0 2
115123: PPUSH
115124: CALL_OW 306
115128: IFFALSE 115176
// begin if i in hInvincible then
115130: LD_VAR 0 2
115134: PUSH
115135: LD_EXP 210
115139: IN
115140: IFFALSE 115160
// hInvincible := hInvincible diff i else
115142: LD_ADDR_EXP 210
115146: PUSH
115147: LD_EXP 210
115151: PUSH
115152: LD_VAR 0 2
115156: DIFF
115157: ST_TO_ADDR
115158: GO 115176
// hInvincible := hInvincible union i ;
115160: LD_ADDR_EXP 210
115164: PUSH
115165: LD_EXP 210
115169: PUSH
115170: LD_VAR 0 2
115174: UNION
115175: ST_TO_ADDR
// end ;
115176: GO 115116
115178: POP
115179: POP
// end ;
115180: LD_VAR 0 1
115184: RET
// export function hHackInvisible ; var i , j ; begin
115185: LD_INT 0
115187: PPUSH
115188: PPUSH
115189: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
115190: LD_ADDR_VAR 0 2
115194: PUSH
115195: LD_INT 21
115197: PUSH
115198: LD_INT 1
115200: PUSH
115201: EMPTY
115202: LIST
115203: LIST
115204: PPUSH
115205: CALL_OW 69
115209: PUSH
115210: FOR_IN
115211: IFFALSE 115235
// if IsSelected ( i ) then
115213: LD_VAR 0 2
115217: PPUSH
115218: CALL_OW 306
115222: IFFALSE 115233
// ComForceInvisible ( i ) ;
115224: LD_VAR 0 2
115228: PPUSH
115229: CALL_OW 496
115233: GO 115210
115235: POP
115236: POP
// end ;
115237: LD_VAR 0 1
115241: RET
// export function hHackChangeYourSide ; begin
115242: LD_INT 0
115244: PPUSH
// if your_side = 8 then
115245: LD_OWVAR 2
115249: PUSH
115250: LD_INT 8
115252: EQUAL
115253: IFFALSE 115265
// your_side := 0 else
115255: LD_ADDR_OWVAR 2
115259: PUSH
115260: LD_INT 0
115262: ST_TO_ADDR
115263: GO 115279
// your_side := your_side + 1 ;
115265: LD_ADDR_OWVAR 2
115269: PUSH
115270: LD_OWVAR 2
115274: PUSH
115275: LD_INT 1
115277: PLUS
115278: ST_TO_ADDR
// end ;
115279: LD_VAR 0 1
115283: RET
// export function hHackChangeUnitSide ; var i , j ; begin
115284: LD_INT 0
115286: PPUSH
115287: PPUSH
115288: PPUSH
// for i in all_units do
115289: LD_ADDR_VAR 0 2
115293: PUSH
115294: LD_OWVAR 3
115298: PUSH
115299: FOR_IN
115300: IFFALSE 115378
// if IsSelected ( i ) then
115302: LD_VAR 0 2
115306: PPUSH
115307: CALL_OW 306
115311: IFFALSE 115376
// begin j := GetSide ( i ) ;
115313: LD_ADDR_VAR 0 3
115317: PUSH
115318: LD_VAR 0 2
115322: PPUSH
115323: CALL_OW 255
115327: ST_TO_ADDR
// if j = 8 then
115328: LD_VAR 0 3
115332: PUSH
115333: LD_INT 8
115335: EQUAL
115336: IFFALSE 115348
// j := 0 else
115338: LD_ADDR_VAR 0 3
115342: PUSH
115343: LD_INT 0
115345: ST_TO_ADDR
115346: GO 115362
// j := j + 1 ;
115348: LD_ADDR_VAR 0 3
115352: PUSH
115353: LD_VAR 0 3
115357: PUSH
115358: LD_INT 1
115360: PLUS
115361: ST_TO_ADDR
// SetSide ( i , j ) ;
115362: LD_VAR 0 2
115366: PPUSH
115367: LD_VAR 0 3
115371: PPUSH
115372: CALL_OW 235
// end ;
115376: GO 115299
115378: POP
115379: POP
// end ;
115380: LD_VAR 0 1
115384: RET
// export function hHackFog ; begin
115385: LD_INT 0
115387: PPUSH
// FogOff ( true ) ;
115388: LD_INT 1
115390: PPUSH
115391: CALL_OW 344
// end ;
115395: LD_VAR 0 1
115399: RET
// export function hHackTeleport ( unit , x , y ) ; begin
115400: LD_INT 0
115402: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
115403: LD_VAR 0 1
115407: PPUSH
115408: LD_VAR 0 2
115412: PPUSH
115413: LD_VAR 0 3
115417: PPUSH
115418: LD_INT 1
115420: PPUSH
115421: LD_INT 1
115423: PPUSH
115424: CALL_OW 483
// CenterOnXY ( x , y ) ;
115428: LD_VAR 0 2
115432: PPUSH
115433: LD_VAR 0 3
115437: PPUSH
115438: CALL_OW 84
// end ; end_of_file
115442: LD_VAR 0 4
115446: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
115447: LD_INT 0
115449: PPUSH
115450: PPUSH
115451: PPUSH
115452: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
115453: LD_VAR 0 1
115457: PPUSH
115458: CALL_OW 264
115462: PUSH
115463: LD_EXP 99
115467: EQUAL
115468: IFFALSE 115540
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
115470: LD_INT 68
115472: PPUSH
115473: LD_VAR 0 1
115477: PPUSH
115478: CALL_OW 255
115482: PPUSH
115483: CALL_OW 321
115487: PUSH
115488: LD_INT 2
115490: EQUAL
115491: IFFALSE 115503
// eff := 70 else
115493: LD_ADDR_VAR 0 4
115497: PUSH
115498: LD_INT 70
115500: ST_TO_ADDR
115501: GO 115511
// eff := 30 ;
115503: LD_ADDR_VAR 0 4
115507: PUSH
115508: LD_INT 30
115510: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
115511: LD_VAR 0 1
115515: PPUSH
115516: CALL_OW 250
115520: PPUSH
115521: LD_VAR 0 1
115525: PPUSH
115526: CALL_OW 251
115530: PPUSH
115531: LD_VAR 0 4
115535: PPUSH
115536: CALL_OW 495
// end ; end ;
115540: LD_VAR 0 2
115544: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
115545: LD_INT 0
115547: PPUSH
// end ;
115548: LD_VAR 0 4
115552: RET
// export function SOS_Command ( cmd ) ; begin
115553: LD_INT 0
115555: PPUSH
// end ;
115556: LD_VAR 0 2
115560: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
115561: LD_INT 0
115563: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
115564: LD_VAR 0 1
115568: PUSH
115569: LD_INT 250
115571: EQUAL
115572: PUSH
115573: LD_VAR 0 2
115577: PPUSH
115578: CALL_OW 264
115582: PUSH
115583: LD_EXP 102
115587: EQUAL
115588: AND
115589: IFFALSE 115610
// MinerPlaceMine ( unit , x , y ) ;
115591: LD_VAR 0 2
115595: PPUSH
115596: LD_VAR 0 4
115600: PPUSH
115601: LD_VAR 0 5
115605: PPUSH
115606: CALL 117951 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
115610: LD_VAR 0 1
115614: PUSH
115615: LD_INT 251
115617: EQUAL
115618: PUSH
115619: LD_VAR 0 2
115623: PPUSH
115624: CALL_OW 264
115628: PUSH
115629: LD_EXP 102
115633: EQUAL
115634: AND
115635: IFFALSE 115656
// MinerDetonateMine ( unit , x , y ) ;
115637: LD_VAR 0 2
115641: PPUSH
115642: LD_VAR 0 4
115646: PPUSH
115647: LD_VAR 0 5
115651: PPUSH
115652: CALL 118228 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
115656: LD_VAR 0 1
115660: PUSH
115661: LD_INT 252
115663: EQUAL
115664: PUSH
115665: LD_VAR 0 2
115669: PPUSH
115670: CALL_OW 264
115674: PUSH
115675: LD_EXP 102
115679: EQUAL
115680: AND
115681: IFFALSE 115702
// MinerCreateMinefield ( unit , x , y ) ;
115683: LD_VAR 0 2
115687: PPUSH
115688: LD_VAR 0 4
115692: PPUSH
115693: LD_VAR 0 5
115697: PPUSH
115698: CALL 118645 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
115702: LD_VAR 0 1
115706: PUSH
115707: LD_INT 253
115709: EQUAL
115710: PUSH
115711: LD_VAR 0 2
115715: PPUSH
115716: CALL_OW 257
115720: PUSH
115721: LD_INT 5
115723: EQUAL
115724: AND
115725: IFFALSE 115746
// ComBinocular ( unit , x , y ) ;
115727: LD_VAR 0 2
115731: PPUSH
115732: LD_VAR 0 4
115736: PPUSH
115737: LD_VAR 0 5
115741: PPUSH
115742: CALL 119016 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
115746: LD_VAR 0 1
115750: PUSH
115751: LD_INT 254
115753: EQUAL
115754: PUSH
115755: LD_VAR 0 2
115759: PPUSH
115760: CALL_OW 264
115764: PUSH
115765: LD_EXP 97
115769: EQUAL
115770: AND
115771: PUSH
115772: LD_VAR 0 3
115776: PPUSH
115777: CALL_OW 263
115781: PUSH
115782: LD_INT 3
115784: EQUAL
115785: AND
115786: IFFALSE 115802
// HackDestroyVehicle ( unit , selectedUnit ) ;
115788: LD_VAR 0 2
115792: PPUSH
115793: LD_VAR 0 3
115797: PPUSH
115798: CALL 117311 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
115802: LD_VAR 0 1
115806: PUSH
115807: LD_INT 255
115809: EQUAL
115810: PUSH
115811: LD_VAR 0 2
115815: PPUSH
115816: CALL_OW 264
115820: PUSH
115821: LD_INT 14
115823: PUSH
115824: LD_INT 53
115826: PUSH
115827: EMPTY
115828: LIST
115829: LIST
115830: IN
115831: AND
115832: PUSH
115833: LD_VAR 0 4
115837: PPUSH
115838: LD_VAR 0 5
115842: PPUSH
115843: CALL_OW 488
115847: AND
115848: IFFALSE 115872
// CutTreeXYR ( unit , x , y , 12 ) ;
115850: LD_VAR 0 2
115854: PPUSH
115855: LD_VAR 0 4
115859: PPUSH
115860: LD_VAR 0 5
115864: PPUSH
115865: LD_INT 12
115867: PPUSH
115868: CALL 115877 0 4
// end ;
115872: LD_VAR 0 6
115876: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
115877: LD_INT 0
115879: PPUSH
115880: PPUSH
115881: PPUSH
115882: PPUSH
115883: PPUSH
115884: PPUSH
115885: PPUSH
115886: PPUSH
115887: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
115888: LD_VAR 0 1
115892: NOT
115893: PUSH
115894: LD_VAR 0 2
115898: PPUSH
115899: LD_VAR 0 3
115903: PPUSH
115904: CALL_OW 488
115908: NOT
115909: OR
115910: PUSH
115911: LD_VAR 0 4
115915: NOT
115916: OR
115917: IFFALSE 115921
// exit ;
115919: GO 116261
// list := [ ] ;
115921: LD_ADDR_VAR 0 13
115925: PUSH
115926: EMPTY
115927: ST_TO_ADDR
// if x - r < 0 then
115928: LD_VAR 0 2
115932: PUSH
115933: LD_VAR 0 4
115937: MINUS
115938: PUSH
115939: LD_INT 0
115941: LESS
115942: IFFALSE 115954
// min_x := 0 else
115944: LD_ADDR_VAR 0 7
115948: PUSH
115949: LD_INT 0
115951: ST_TO_ADDR
115952: GO 115970
// min_x := x - r ;
115954: LD_ADDR_VAR 0 7
115958: PUSH
115959: LD_VAR 0 2
115963: PUSH
115964: LD_VAR 0 4
115968: MINUS
115969: ST_TO_ADDR
// if y - r < 0 then
115970: LD_VAR 0 3
115974: PUSH
115975: LD_VAR 0 4
115979: MINUS
115980: PUSH
115981: LD_INT 0
115983: LESS
115984: IFFALSE 115996
// min_y := 0 else
115986: LD_ADDR_VAR 0 8
115990: PUSH
115991: LD_INT 0
115993: ST_TO_ADDR
115994: GO 116012
// min_y := y - r ;
115996: LD_ADDR_VAR 0 8
116000: PUSH
116001: LD_VAR 0 3
116005: PUSH
116006: LD_VAR 0 4
116010: MINUS
116011: ST_TO_ADDR
// max_x := x + r ;
116012: LD_ADDR_VAR 0 9
116016: PUSH
116017: LD_VAR 0 2
116021: PUSH
116022: LD_VAR 0 4
116026: PLUS
116027: ST_TO_ADDR
// max_y := y + r ;
116028: LD_ADDR_VAR 0 10
116032: PUSH
116033: LD_VAR 0 3
116037: PUSH
116038: LD_VAR 0 4
116042: PLUS
116043: ST_TO_ADDR
// for _x = min_x to max_x do
116044: LD_ADDR_VAR 0 11
116048: PUSH
116049: DOUBLE
116050: LD_VAR 0 7
116054: DEC
116055: ST_TO_ADDR
116056: LD_VAR 0 9
116060: PUSH
116061: FOR_TO
116062: IFFALSE 116179
// for _y = min_y to max_y do
116064: LD_ADDR_VAR 0 12
116068: PUSH
116069: DOUBLE
116070: LD_VAR 0 8
116074: DEC
116075: ST_TO_ADDR
116076: LD_VAR 0 10
116080: PUSH
116081: FOR_TO
116082: IFFALSE 116175
// begin if not ValidHex ( _x , _y ) then
116084: LD_VAR 0 11
116088: PPUSH
116089: LD_VAR 0 12
116093: PPUSH
116094: CALL_OW 488
116098: NOT
116099: IFFALSE 116103
// continue ;
116101: GO 116081
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
116103: LD_VAR 0 11
116107: PPUSH
116108: LD_VAR 0 12
116112: PPUSH
116113: CALL_OW 351
116117: PUSH
116118: LD_VAR 0 11
116122: PPUSH
116123: LD_VAR 0 12
116127: PPUSH
116128: CALL_OW 554
116132: AND
116133: IFFALSE 116173
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
116135: LD_ADDR_VAR 0 13
116139: PUSH
116140: LD_VAR 0 13
116144: PPUSH
116145: LD_VAR 0 13
116149: PUSH
116150: LD_INT 1
116152: PLUS
116153: PPUSH
116154: LD_VAR 0 11
116158: PUSH
116159: LD_VAR 0 12
116163: PUSH
116164: EMPTY
116165: LIST
116166: LIST
116167: PPUSH
116168: CALL_OW 2
116172: ST_TO_ADDR
// end ;
116173: GO 116081
116175: POP
116176: POP
116177: GO 116061
116179: POP
116180: POP
// if not list then
116181: LD_VAR 0 13
116185: NOT
116186: IFFALSE 116190
// exit ;
116188: GO 116261
// for i in list do
116190: LD_ADDR_VAR 0 6
116194: PUSH
116195: LD_VAR 0 13
116199: PUSH
116200: FOR_IN
116201: IFFALSE 116259
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
116203: LD_VAR 0 1
116207: PPUSH
116208: LD_STRING M
116210: PUSH
116211: LD_VAR 0 6
116215: PUSH
116216: LD_INT 1
116218: ARRAY
116219: PUSH
116220: LD_VAR 0 6
116224: PUSH
116225: LD_INT 2
116227: ARRAY
116228: PUSH
116229: LD_INT 0
116231: PUSH
116232: LD_INT 0
116234: PUSH
116235: LD_INT 0
116237: PUSH
116238: LD_INT 0
116240: PUSH
116241: EMPTY
116242: LIST
116243: LIST
116244: LIST
116245: LIST
116246: LIST
116247: LIST
116248: LIST
116249: PUSH
116250: EMPTY
116251: LIST
116252: PPUSH
116253: CALL_OW 447
116257: GO 116200
116259: POP
116260: POP
// end ;
116261: LD_VAR 0 5
116265: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
116266: LD_EXP 211
116270: NOT
116271: IFFALSE 116321
116273: GO 116275
116275: DISABLE
// begin initHack := true ;
116276: LD_ADDR_EXP 211
116280: PUSH
116281: LD_INT 1
116283: ST_TO_ADDR
// hackTanks := [ ] ;
116284: LD_ADDR_EXP 212
116288: PUSH
116289: EMPTY
116290: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
116291: LD_ADDR_EXP 213
116295: PUSH
116296: EMPTY
116297: ST_TO_ADDR
// hackLimit := 3 ;
116298: LD_ADDR_EXP 214
116302: PUSH
116303: LD_INT 3
116305: ST_TO_ADDR
// hackDist := 12 ;
116306: LD_ADDR_EXP 215
116310: PUSH
116311: LD_INT 12
116313: ST_TO_ADDR
// hackCounter := [ ] ;
116314: LD_ADDR_EXP 216
116318: PUSH
116319: EMPTY
116320: ST_TO_ADDR
// end ;
116321: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
116322: LD_EXP 211
116326: PUSH
116327: LD_INT 34
116329: PUSH
116330: LD_EXP 97
116334: PUSH
116335: EMPTY
116336: LIST
116337: LIST
116338: PPUSH
116339: CALL_OW 69
116343: AND
116344: IFFALSE 116599
116346: GO 116348
116348: DISABLE
116349: LD_INT 0
116351: PPUSH
116352: PPUSH
// begin enable ;
116353: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
116354: LD_ADDR_VAR 0 1
116358: PUSH
116359: LD_INT 34
116361: PUSH
116362: LD_EXP 97
116366: PUSH
116367: EMPTY
116368: LIST
116369: LIST
116370: PPUSH
116371: CALL_OW 69
116375: PUSH
116376: FOR_IN
116377: IFFALSE 116597
// begin if not i in hackTanks then
116379: LD_VAR 0 1
116383: PUSH
116384: LD_EXP 212
116388: IN
116389: NOT
116390: IFFALSE 116473
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
116392: LD_ADDR_EXP 212
116396: PUSH
116397: LD_EXP 212
116401: PPUSH
116402: LD_EXP 212
116406: PUSH
116407: LD_INT 1
116409: PLUS
116410: PPUSH
116411: LD_VAR 0 1
116415: PPUSH
116416: CALL_OW 1
116420: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
116421: LD_ADDR_EXP 213
116425: PUSH
116426: LD_EXP 213
116430: PPUSH
116431: LD_EXP 213
116435: PUSH
116436: LD_INT 1
116438: PLUS
116439: PPUSH
116440: EMPTY
116441: PPUSH
116442: CALL_OW 1
116446: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
116447: LD_ADDR_EXP 216
116451: PUSH
116452: LD_EXP 216
116456: PPUSH
116457: LD_EXP 216
116461: PUSH
116462: LD_INT 1
116464: PLUS
116465: PPUSH
116466: EMPTY
116467: PPUSH
116468: CALL_OW 1
116472: ST_TO_ADDR
// end ; if not IsOk ( i ) then
116473: LD_VAR 0 1
116477: PPUSH
116478: CALL_OW 302
116482: NOT
116483: IFFALSE 116496
// begin HackUnlinkAll ( i ) ;
116485: LD_VAR 0 1
116489: PPUSH
116490: CALL 116602 0 1
// continue ;
116494: GO 116376
// end ; HackCheckCapturedStatus ( i ) ;
116496: LD_VAR 0 1
116500: PPUSH
116501: CALL 117045 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
116505: LD_ADDR_VAR 0 2
116509: PUSH
116510: LD_INT 81
116512: PUSH
116513: LD_VAR 0 1
116517: PPUSH
116518: CALL_OW 255
116522: PUSH
116523: EMPTY
116524: LIST
116525: LIST
116526: PUSH
116527: LD_INT 33
116529: PUSH
116530: LD_INT 3
116532: PUSH
116533: EMPTY
116534: LIST
116535: LIST
116536: PUSH
116537: LD_INT 91
116539: PUSH
116540: LD_VAR 0 1
116544: PUSH
116545: LD_EXP 215
116549: PUSH
116550: EMPTY
116551: LIST
116552: LIST
116553: LIST
116554: PUSH
116555: LD_INT 50
116557: PUSH
116558: EMPTY
116559: LIST
116560: PUSH
116561: EMPTY
116562: LIST
116563: LIST
116564: LIST
116565: LIST
116566: PPUSH
116567: CALL_OW 69
116571: ST_TO_ADDR
// if not tmp then
116572: LD_VAR 0 2
116576: NOT
116577: IFFALSE 116581
// continue ;
116579: GO 116376
// HackLink ( i , tmp ) ;
116581: LD_VAR 0 1
116585: PPUSH
116586: LD_VAR 0 2
116590: PPUSH
116591: CALL 116738 0 2
// end ;
116595: GO 116376
116597: POP
116598: POP
// end ;
116599: PPOPN 2
116601: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
116602: LD_INT 0
116604: PPUSH
116605: PPUSH
116606: PPUSH
// if not hack in hackTanks then
116607: LD_VAR 0 1
116611: PUSH
116612: LD_EXP 212
116616: IN
116617: NOT
116618: IFFALSE 116622
// exit ;
116620: GO 116733
// index := GetElementIndex ( hackTanks , hack ) ;
116622: LD_ADDR_VAR 0 4
116626: PUSH
116627: LD_EXP 212
116631: PPUSH
116632: LD_VAR 0 1
116636: PPUSH
116637: CALL 69942 0 2
116641: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
116642: LD_EXP 213
116646: PUSH
116647: LD_VAR 0 4
116651: ARRAY
116652: IFFALSE 116733
// begin for i in hackTanksCaptured [ index ] do
116654: LD_ADDR_VAR 0 3
116658: PUSH
116659: LD_EXP 213
116663: PUSH
116664: LD_VAR 0 4
116668: ARRAY
116669: PUSH
116670: FOR_IN
116671: IFFALSE 116697
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
116673: LD_VAR 0 3
116677: PUSH
116678: LD_INT 1
116680: ARRAY
116681: PPUSH
116682: LD_VAR 0 3
116686: PUSH
116687: LD_INT 2
116689: ARRAY
116690: PPUSH
116691: CALL_OW 235
116695: GO 116670
116697: POP
116698: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
116699: LD_ADDR_EXP 213
116703: PUSH
116704: LD_EXP 213
116708: PPUSH
116709: LD_VAR 0 4
116713: PPUSH
116714: EMPTY
116715: PPUSH
116716: CALL_OW 1
116720: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
116721: LD_VAR 0 1
116725: PPUSH
116726: LD_INT 0
116728: PPUSH
116729: CALL_OW 505
// end ; end ;
116733: LD_VAR 0 2
116737: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
116738: LD_INT 0
116740: PPUSH
116741: PPUSH
116742: PPUSH
// if not hack in hackTanks or not vehicles then
116743: LD_VAR 0 1
116747: PUSH
116748: LD_EXP 212
116752: IN
116753: NOT
116754: PUSH
116755: LD_VAR 0 2
116759: NOT
116760: OR
116761: IFFALSE 116765
// exit ;
116763: GO 117040
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
116765: LD_ADDR_VAR 0 2
116769: PUSH
116770: LD_VAR 0 1
116774: PPUSH
116775: LD_VAR 0 2
116779: PPUSH
116780: LD_INT 1
116782: PPUSH
116783: LD_INT 1
116785: PPUSH
116786: CALL 70592 0 4
116790: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
116791: LD_ADDR_VAR 0 5
116795: PUSH
116796: LD_EXP 212
116800: PPUSH
116801: LD_VAR 0 1
116805: PPUSH
116806: CALL 69942 0 2
116810: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
116811: LD_EXP 213
116815: PUSH
116816: LD_VAR 0 5
116820: ARRAY
116821: PUSH
116822: LD_EXP 214
116826: LESS
116827: IFFALSE 117016
// begin for i := 1 to vehicles do
116829: LD_ADDR_VAR 0 4
116833: PUSH
116834: DOUBLE
116835: LD_INT 1
116837: DEC
116838: ST_TO_ADDR
116839: LD_VAR 0 2
116843: PUSH
116844: FOR_TO
116845: IFFALSE 117014
// begin if hackTanksCaptured [ index ] = hackLimit then
116847: LD_EXP 213
116851: PUSH
116852: LD_VAR 0 5
116856: ARRAY
116857: PUSH
116858: LD_EXP 214
116862: EQUAL
116863: IFFALSE 116867
// break ;
116865: GO 117014
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
116867: LD_ADDR_EXP 216
116871: PUSH
116872: LD_EXP 216
116876: PPUSH
116877: LD_VAR 0 5
116881: PPUSH
116882: LD_EXP 216
116886: PUSH
116887: LD_VAR 0 5
116891: ARRAY
116892: PUSH
116893: LD_INT 1
116895: PLUS
116896: PPUSH
116897: CALL_OW 1
116901: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
116902: LD_ADDR_EXP 213
116906: PUSH
116907: LD_EXP 213
116911: PPUSH
116912: LD_VAR 0 5
116916: PUSH
116917: LD_EXP 213
116921: PUSH
116922: LD_VAR 0 5
116926: ARRAY
116927: PUSH
116928: LD_INT 1
116930: PLUS
116931: PUSH
116932: EMPTY
116933: LIST
116934: LIST
116935: PPUSH
116936: LD_VAR 0 2
116940: PUSH
116941: LD_VAR 0 4
116945: ARRAY
116946: PUSH
116947: LD_VAR 0 2
116951: PUSH
116952: LD_VAR 0 4
116956: ARRAY
116957: PPUSH
116958: CALL_OW 255
116962: PUSH
116963: EMPTY
116964: LIST
116965: LIST
116966: PPUSH
116967: CALL 70157 0 3
116971: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
116972: LD_VAR 0 2
116976: PUSH
116977: LD_VAR 0 4
116981: ARRAY
116982: PPUSH
116983: LD_VAR 0 1
116987: PPUSH
116988: CALL_OW 255
116992: PPUSH
116993: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
116997: LD_VAR 0 2
117001: PUSH
117002: LD_VAR 0 4
117006: ARRAY
117007: PPUSH
117008: CALL_OW 141
// end ;
117012: GO 116844
117014: POP
117015: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117016: LD_VAR 0 1
117020: PPUSH
117021: LD_EXP 213
117025: PUSH
117026: LD_VAR 0 5
117030: ARRAY
117031: PUSH
117032: LD_INT 0
117034: PLUS
117035: PPUSH
117036: CALL_OW 505
// end ;
117040: LD_VAR 0 3
117044: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
117045: LD_INT 0
117047: PPUSH
117048: PPUSH
117049: PPUSH
117050: PPUSH
// if not hack in hackTanks then
117051: LD_VAR 0 1
117055: PUSH
117056: LD_EXP 212
117060: IN
117061: NOT
117062: IFFALSE 117066
// exit ;
117064: GO 117306
// index := GetElementIndex ( hackTanks , hack ) ;
117066: LD_ADDR_VAR 0 4
117070: PUSH
117071: LD_EXP 212
117075: PPUSH
117076: LD_VAR 0 1
117080: PPUSH
117081: CALL 69942 0 2
117085: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
117086: LD_ADDR_VAR 0 3
117090: PUSH
117091: DOUBLE
117092: LD_EXP 213
117096: PUSH
117097: LD_VAR 0 4
117101: ARRAY
117102: INC
117103: ST_TO_ADDR
117104: LD_INT 1
117106: PUSH
117107: FOR_DOWNTO
117108: IFFALSE 117280
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
117110: LD_ADDR_VAR 0 5
117114: PUSH
117115: LD_EXP 213
117119: PUSH
117120: LD_VAR 0 4
117124: ARRAY
117125: PUSH
117126: LD_VAR 0 3
117130: ARRAY
117131: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
117132: LD_VAR 0 5
117136: PUSH
117137: LD_INT 1
117139: ARRAY
117140: PPUSH
117141: CALL_OW 302
117145: NOT
117146: PUSH
117147: LD_VAR 0 5
117151: PUSH
117152: LD_INT 1
117154: ARRAY
117155: PPUSH
117156: CALL_OW 255
117160: PUSH
117161: LD_VAR 0 1
117165: PPUSH
117166: CALL_OW 255
117170: NONEQUAL
117171: OR
117172: IFFALSE 117278
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
117174: LD_VAR 0 5
117178: PUSH
117179: LD_INT 1
117181: ARRAY
117182: PPUSH
117183: CALL_OW 305
117187: PUSH
117188: LD_VAR 0 5
117192: PUSH
117193: LD_INT 1
117195: ARRAY
117196: PPUSH
117197: CALL_OW 255
117201: PUSH
117202: LD_VAR 0 1
117206: PPUSH
117207: CALL_OW 255
117211: EQUAL
117212: AND
117213: IFFALSE 117237
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
117215: LD_VAR 0 5
117219: PUSH
117220: LD_INT 1
117222: ARRAY
117223: PPUSH
117224: LD_VAR 0 5
117228: PUSH
117229: LD_INT 2
117231: ARRAY
117232: PPUSH
117233: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
117237: LD_ADDR_EXP 213
117241: PUSH
117242: LD_EXP 213
117246: PPUSH
117247: LD_VAR 0 4
117251: PPUSH
117252: LD_EXP 213
117256: PUSH
117257: LD_VAR 0 4
117261: ARRAY
117262: PPUSH
117263: LD_VAR 0 3
117267: PPUSH
117268: CALL_OW 3
117272: PPUSH
117273: CALL_OW 1
117277: ST_TO_ADDR
// end ; end ;
117278: GO 117107
117280: POP
117281: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117282: LD_VAR 0 1
117286: PPUSH
117287: LD_EXP 213
117291: PUSH
117292: LD_VAR 0 4
117296: ARRAY
117297: PUSH
117298: LD_INT 0
117300: PLUS
117301: PPUSH
117302: CALL_OW 505
// end ;
117306: LD_VAR 0 2
117310: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
117311: LD_INT 0
117313: PPUSH
117314: PPUSH
117315: PPUSH
117316: PPUSH
// if not hack in hackTanks then
117317: LD_VAR 0 1
117321: PUSH
117322: LD_EXP 212
117326: IN
117327: NOT
117328: IFFALSE 117332
// exit ;
117330: GO 117417
// index := GetElementIndex ( hackTanks , hack ) ;
117332: LD_ADDR_VAR 0 5
117336: PUSH
117337: LD_EXP 212
117341: PPUSH
117342: LD_VAR 0 1
117346: PPUSH
117347: CALL 69942 0 2
117351: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
117352: LD_ADDR_VAR 0 4
117356: PUSH
117357: DOUBLE
117358: LD_INT 1
117360: DEC
117361: ST_TO_ADDR
117362: LD_EXP 213
117366: PUSH
117367: LD_VAR 0 5
117371: ARRAY
117372: PUSH
117373: FOR_TO
117374: IFFALSE 117415
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
117376: LD_EXP 213
117380: PUSH
117381: LD_VAR 0 5
117385: ARRAY
117386: PUSH
117387: LD_VAR 0 4
117391: ARRAY
117392: PUSH
117393: LD_INT 1
117395: ARRAY
117396: PUSH
117397: LD_VAR 0 2
117401: EQUAL
117402: IFFALSE 117413
// KillUnit ( vehicle ) ;
117404: LD_VAR 0 2
117408: PPUSH
117409: CALL_OW 66
117413: GO 117373
117415: POP
117416: POP
// end ;
117417: LD_VAR 0 3
117421: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
117422: LD_EXP 217
117426: NOT
117427: IFFALSE 117462
117429: GO 117431
117431: DISABLE
// begin initMiner := true ;
117432: LD_ADDR_EXP 217
117436: PUSH
117437: LD_INT 1
117439: ST_TO_ADDR
// minersList := [ ] ;
117440: LD_ADDR_EXP 218
117444: PUSH
117445: EMPTY
117446: ST_TO_ADDR
// minerMinesList := [ ] ;
117447: LD_ADDR_EXP 219
117451: PUSH
117452: EMPTY
117453: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
117454: LD_ADDR_EXP 220
117458: PUSH
117459: LD_INT 5
117461: ST_TO_ADDR
// end ;
117462: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
117463: LD_EXP 217
117467: PUSH
117468: LD_INT 34
117470: PUSH
117471: LD_EXP 102
117475: PUSH
117476: EMPTY
117477: LIST
117478: LIST
117479: PPUSH
117480: CALL_OW 69
117484: AND
117485: IFFALSE 117948
117487: GO 117489
117489: DISABLE
117490: LD_INT 0
117492: PPUSH
117493: PPUSH
117494: PPUSH
117495: PPUSH
// begin enable ;
117496: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
117497: LD_ADDR_VAR 0 1
117501: PUSH
117502: LD_INT 34
117504: PUSH
117505: LD_EXP 102
117509: PUSH
117510: EMPTY
117511: LIST
117512: LIST
117513: PPUSH
117514: CALL_OW 69
117518: PUSH
117519: FOR_IN
117520: IFFALSE 117592
// begin if not i in minersList then
117522: LD_VAR 0 1
117526: PUSH
117527: LD_EXP 218
117531: IN
117532: NOT
117533: IFFALSE 117590
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
117535: LD_ADDR_EXP 218
117539: PUSH
117540: LD_EXP 218
117544: PPUSH
117545: LD_EXP 218
117549: PUSH
117550: LD_INT 1
117552: PLUS
117553: PPUSH
117554: LD_VAR 0 1
117558: PPUSH
117559: CALL_OW 1
117563: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
117564: LD_ADDR_EXP 219
117568: PUSH
117569: LD_EXP 219
117573: PPUSH
117574: LD_EXP 219
117578: PUSH
117579: LD_INT 1
117581: PLUS
117582: PPUSH
117583: EMPTY
117584: PPUSH
117585: CALL_OW 1
117589: ST_TO_ADDR
// end end ;
117590: GO 117519
117592: POP
117593: POP
// for i := minerMinesList downto 1 do
117594: LD_ADDR_VAR 0 1
117598: PUSH
117599: DOUBLE
117600: LD_EXP 219
117604: INC
117605: ST_TO_ADDR
117606: LD_INT 1
117608: PUSH
117609: FOR_DOWNTO
117610: IFFALSE 117946
// begin if IsLive ( minersList [ i ] ) then
117612: LD_EXP 218
117616: PUSH
117617: LD_VAR 0 1
117621: ARRAY
117622: PPUSH
117623: CALL_OW 300
117627: IFFALSE 117655
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
117629: LD_EXP 218
117633: PUSH
117634: LD_VAR 0 1
117638: ARRAY
117639: PPUSH
117640: LD_EXP 219
117644: PUSH
117645: LD_VAR 0 1
117649: ARRAY
117650: PPUSH
117651: CALL_OW 505
// if not minerMinesList [ i ] then
117655: LD_EXP 219
117659: PUSH
117660: LD_VAR 0 1
117664: ARRAY
117665: NOT
117666: IFFALSE 117670
// continue ;
117668: GO 117609
// for j := minerMinesList [ i ] downto 1 do
117670: LD_ADDR_VAR 0 2
117674: PUSH
117675: DOUBLE
117676: LD_EXP 219
117680: PUSH
117681: LD_VAR 0 1
117685: ARRAY
117686: INC
117687: ST_TO_ADDR
117688: LD_INT 1
117690: PUSH
117691: FOR_DOWNTO
117692: IFFALSE 117942
// begin side := GetSide ( minersList [ i ] ) ;
117694: LD_ADDR_VAR 0 3
117698: PUSH
117699: LD_EXP 218
117703: PUSH
117704: LD_VAR 0 1
117708: ARRAY
117709: PPUSH
117710: CALL_OW 255
117714: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
117715: LD_ADDR_VAR 0 4
117719: PUSH
117720: LD_EXP 219
117724: PUSH
117725: LD_VAR 0 1
117729: ARRAY
117730: PUSH
117731: LD_VAR 0 2
117735: ARRAY
117736: PUSH
117737: LD_INT 1
117739: ARRAY
117740: PPUSH
117741: LD_EXP 219
117745: PUSH
117746: LD_VAR 0 1
117750: ARRAY
117751: PUSH
117752: LD_VAR 0 2
117756: ARRAY
117757: PUSH
117758: LD_INT 2
117760: ARRAY
117761: PPUSH
117762: CALL_OW 428
117766: ST_TO_ADDR
// if not tmp then
117767: LD_VAR 0 4
117771: NOT
117772: IFFALSE 117776
// continue ;
117774: GO 117691
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
117776: LD_VAR 0 4
117780: PUSH
117781: LD_INT 81
117783: PUSH
117784: LD_VAR 0 3
117788: PUSH
117789: EMPTY
117790: LIST
117791: LIST
117792: PPUSH
117793: CALL_OW 69
117797: IN
117798: PUSH
117799: LD_EXP 219
117803: PUSH
117804: LD_VAR 0 1
117808: ARRAY
117809: PUSH
117810: LD_VAR 0 2
117814: ARRAY
117815: PUSH
117816: LD_INT 1
117818: ARRAY
117819: PPUSH
117820: LD_EXP 219
117824: PUSH
117825: LD_VAR 0 1
117829: ARRAY
117830: PUSH
117831: LD_VAR 0 2
117835: ARRAY
117836: PUSH
117837: LD_INT 2
117839: ARRAY
117840: PPUSH
117841: CALL_OW 458
117845: AND
117846: IFFALSE 117940
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
117848: LD_EXP 219
117852: PUSH
117853: LD_VAR 0 1
117857: ARRAY
117858: PUSH
117859: LD_VAR 0 2
117863: ARRAY
117864: PUSH
117865: LD_INT 1
117867: ARRAY
117868: PPUSH
117869: LD_EXP 219
117873: PUSH
117874: LD_VAR 0 1
117878: ARRAY
117879: PUSH
117880: LD_VAR 0 2
117884: ARRAY
117885: PUSH
117886: LD_INT 2
117888: ARRAY
117889: PPUSH
117890: LD_VAR 0 3
117894: PPUSH
117895: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
117899: LD_ADDR_EXP 219
117903: PUSH
117904: LD_EXP 219
117908: PPUSH
117909: LD_VAR 0 1
117913: PPUSH
117914: LD_EXP 219
117918: PUSH
117919: LD_VAR 0 1
117923: ARRAY
117924: PPUSH
117925: LD_VAR 0 2
117929: PPUSH
117930: CALL_OW 3
117934: PPUSH
117935: CALL_OW 1
117939: ST_TO_ADDR
// end ; end ;
117940: GO 117691
117942: POP
117943: POP
// end ;
117944: GO 117609
117946: POP
117947: POP
// end ;
117948: PPOPN 4
117950: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
117951: LD_INT 0
117953: PPUSH
117954: PPUSH
// result := false ;
117955: LD_ADDR_VAR 0 4
117959: PUSH
117960: LD_INT 0
117962: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
117963: LD_VAR 0 1
117967: PPUSH
117968: CALL_OW 264
117972: PUSH
117973: LD_EXP 102
117977: EQUAL
117978: NOT
117979: IFFALSE 117983
// exit ;
117981: GO 118223
// index := GetElementIndex ( minersList , unit ) ;
117983: LD_ADDR_VAR 0 5
117987: PUSH
117988: LD_EXP 218
117992: PPUSH
117993: LD_VAR 0 1
117997: PPUSH
117998: CALL 69942 0 2
118002: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
118003: LD_EXP 219
118007: PUSH
118008: LD_VAR 0 5
118012: ARRAY
118013: PUSH
118014: LD_EXP 220
118018: GREATEREQUAL
118019: IFFALSE 118023
// exit ;
118021: GO 118223
// ComMoveXY ( unit , x , y ) ;
118023: LD_VAR 0 1
118027: PPUSH
118028: LD_VAR 0 2
118032: PPUSH
118033: LD_VAR 0 3
118037: PPUSH
118038: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
118042: LD_INT 35
118044: PPUSH
118045: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
118049: LD_VAR 0 1
118053: PPUSH
118054: LD_VAR 0 2
118058: PPUSH
118059: LD_VAR 0 3
118063: PPUSH
118064: CALL 100006 0 3
118068: NOT
118069: PUSH
118070: LD_VAR 0 1
118074: PPUSH
118075: CALL_OW 314
118079: AND
118080: IFFALSE 118084
// exit ;
118082: GO 118223
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
118084: LD_VAR 0 2
118088: PPUSH
118089: LD_VAR 0 3
118093: PPUSH
118094: CALL_OW 428
118098: PUSH
118099: LD_VAR 0 1
118103: EQUAL
118104: PUSH
118105: LD_VAR 0 1
118109: PPUSH
118110: CALL_OW 314
118114: NOT
118115: AND
118116: IFFALSE 118042
// PlaySoundXY ( x , y , PlantMine ) ;
118118: LD_VAR 0 2
118122: PPUSH
118123: LD_VAR 0 3
118127: PPUSH
118128: LD_STRING PlantMine
118130: PPUSH
118131: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
118135: LD_VAR 0 2
118139: PPUSH
118140: LD_VAR 0 3
118144: PPUSH
118145: LD_VAR 0 1
118149: PPUSH
118150: CALL_OW 255
118154: PPUSH
118155: LD_INT 0
118157: PPUSH
118158: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
118162: LD_ADDR_EXP 219
118166: PUSH
118167: LD_EXP 219
118171: PPUSH
118172: LD_VAR 0 5
118176: PUSH
118177: LD_EXP 219
118181: PUSH
118182: LD_VAR 0 5
118186: ARRAY
118187: PUSH
118188: LD_INT 1
118190: PLUS
118191: PUSH
118192: EMPTY
118193: LIST
118194: LIST
118195: PPUSH
118196: LD_VAR 0 2
118200: PUSH
118201: LD_VAR 0 3
118205: PUSH
118206: EMPTY
118207: LIST
118208: LIST
118209: PPUSH
118210: CALL 70157 0 3
118214: ST_TO_ADDR
// result := true ;
118215: LD_ADDR_VAR 0 4
118219: PUSH
118220: LD_INT 1
118222: ST_TO_ADDR
// end ;
118223: LD_VAR 0 4
118227: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
118228: LD_INT 0
118230: PPUSH
118231: PPUSH
118232: PPUSH
// if not unit in minersList then
118233: LD_VAR 0 1
118237: PUSH
118238: LD_EXP 218
118242: IN
118243: NOT
118244: IFFALSE 118248
// exit ;
118246: GO 118640
// index := GetElementIndex ( minersList , unit ) ;
118248: LD_ADDR_VAR 0 6
118252: PUSH
118253: LD_EXP 218
118257: PPUSH
118258: LD_VAR 0 1
118262: PPUSH
118263: CALL 69942 0 2
118267: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
118268: LD_ADDR_VAR 0 5
118272: PUSH
118273: DOUBLE
118274: LD_EXP 219
118278: PUSH
118279: LD_VAR 0 6
118283: ARRAY
118284: INC
118285: ST_TO_ADDR
118286: LD_INT 1
118288: PUSH
118289: FOR_DOWNTO
118290: IFFALSE 118451
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
118292: LD_EXP 219
118296: PUSH
118297: LD_VAR 0 6
118301: ARRAY
118302: PUSH
118303: LD_VAR 0 5
118307: ARRAY
118308: PUSH
118309: LD_INT 1
118311: ARRAY
118312: PUSH
118313: LD_VAR 0 2
118317: EQUAL
118318: PUSH
118319: LD_EXP 219
118323: PUSH
118324: LD_VAR 0 6
118328: ARRAY
118329: PUSH
118330: LD_VAR 0 5
118334: ARRAY
118335: PUSH
118336: LD_INT 2
118338: ARRAY
118339: PUSH
118340: LD_VAR 0 3
118344: EQUAL
118345: AND
118346: IFFALSE 118449
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118348: LD_EXP 219
118352: PUSH
118353: LD_VAR 0 6
118357: ARRAY
118358: PUSH
118359: LD_VAR 0 5
118363: ARRAY
118364: PUSH
118365: LD_INT 1
118367: ARRAY
118368: PPUSH
118369: LD_EXP 219
118373: PUSH
118374: LD_VAR 0 6
118378: ARRAY
118379: PUSH
118380: LD_VAR 0 5
118384: ARRAY
118385: PUSH
118386: LD_INT 2
118388: ARRAY
118389: PPUSH
118390: LD_VAR 0 1
118394: PPUSH
118395: CALL_OW 255
118399: PPUSH
118400: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118404: LD_ADDR_EXP 219
118408: PUSH
118409: LD_EXP 219
118413: PPUSH
118414: LD_VAR 0 6
118418: PPUSH
118419: LD_EXP 219
118423: PUSH
118424: LD_VAR 0 6
118428: ARRAY
118429: PPUSH
118430: LD_VAR 0 5
118434: PPUSH
118435: CALL_OW 3
118439: PPUSH
118440: CALL_OW 1
118444: ST_TO_ADDR
// exit ;
118445: POP
118446: POP
118447: GO 118640
// end ; end ;
118449: GO 118289
118451: POP
118452: POP
// for i := minerMinesList [ index ] downto 1 do
118453: LD_ADDR_VAR 0 5
118457: PUSH
118458: DOUBLE
118459: LD_EXP 219
118463: PUSH
118464: LD_VAR 0 6
118468: ARRAY
118469: INC
118470: ST_TO_ADDR
118471: LD_INT 1
118473: PUSH
118474: FOR_DOWNTO
118475: IFFALSE 118638
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
118477: LD_EXP 219
118481: PUSH
118482: LD_VAR 0 6
118486: ARRAY
118487: PUSH
118488: LD_VAR 0 5
118492: ARRAY
118493: PUSH
118494: LD_INT 1
118496: ARRAY
118497: PPUSH
118498: LD_EXP 219
118502: PUSH
118503: LD_VAR 0 6
118507: ARRAY
118508: PUSH
118509: LD_VAR 0 5
118513: ARRAY
118514: PUSH
118515: LD_INT 2
118517: ARRAY
118518: PPUSH
118519: LD_VAR 0 2
118523: PPUSH
118524: LD_VAR 0 3
118528: PPUSH
118529: CALL_OW 298
118533: PUSH
118534: LD_INT 6
118536: LESS
118537: IFFALSE 118636
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118539: LD_EXP 219
118543: PUSH
118544: LD_VAR 0 6
118548: ARRAY
118549: PUSH
118550: LD_VAR 0 5
118554: ARRAY
118555: PUSH
118556: LD_INT 1
118558: ARRAY
118559: PPUSH
118560: LD_EXP 219
118564: PUSH
118565: LD_VAR 0 6
118569: ARRAY
118570: PUSH
118571: LD_VAR 0 5
118575: ARRAY
118576: PUSH
118577: LD_INT 2
118579: ARRAY
118580: PPUSH
118581: LD_VAR 0 1
118585: PPUSH
118586: CALL_OW 255
118590: PPUSH
118591: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118595: LD_ADDR_EXP 219
118599: PUSH
118600: LD_EXP 219
118604: PPUSH
118605: LD_VAR 0 6
118609: PPUSH
118610: LD_EXP 219
118614: PUSH
118615: LD_VAR 0 6
118619: ARRAY
118620: PPUSH
118621: LD_VAR 0 5
118625: PPUSH
118626: CALL_OW 3
118630: PPUSH
118631: CALL_OW 1
118635: ST_TO_ADDR
// end ; end ;
118636: GO 118474
118638: POP
118639: POP
// end ;
118640: LD_VAR 0 4
118644: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
118645: LD_INT 0
118647: PPUSH
118648: PPUSH
118649: PPUSH
118650: PPUSH
118651: PPUSH
118652: PPUSH
118653: PPUSH
118654: PPUSH
118655: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
118656: LD_VAR 0 1
118660: PPUSH
118661: CALL_OW 264
118665: PUSH
118666: LD_EXP 102
118670: EQUAL
118671: NOT
118672: PUSH
118673: LD_VAR 0 1
118677: PUSH
118678: LD_EXP 218
118682: IN
118683: NOT
118684: OR
118685: IFFALSE 118689
// exit ;
118687: GO 119011
// index := GetElementIndex ( minersList , unit ) ;
118689: LD_ADDR_VAR 0 6
118693: PUSH
118694: LD_EXP 218
118698: PPUSH
118699: LD_VAR 0 1
118703: PPUSH
118704: CALL 69942 0 2
118708: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
118709: LD_ADDR_VAR 0 8
118713: PUSH
118714: LD_EXP 220
118718: PUSH
118719: LD_EXP 219
118723: PUSH
118724: LD_VAR 0 6
118728: ARRAY
118729: MINUS
118730: ST_TO_ADDR
// if not minesFreeAmount then
118731: LD_VAR 0 8
118735: NOT
118736: IFFALSE 118740
// exit ;
118738: GO 119011
// tmp := [ ] ;
118740: LD_ADDR_VAR 0 7
118744: PUSH
118745: EMPTY
118746: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
118747: LD_ADDR_VAR 0 5
118751: PUSH
118752: DOUBLE
118753: LD_INT 1
118755: DEC
118756: ST_TO_ADDR
118757: LD_VAR 0 8
118761: PUSH
118762: FOR_TO
118763: IFFALSE 118958
// begin _d := rand ( 0 , 5 ) ;
118765: LD_ADDR_VAR 0 11
118769: PUSH
118770: LD_INT 0
118772: PPUSH
118773: LD_INT 5
118775: PPUSH
118776: CALL_OW 12
118780: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
118781: LD_ADDR_VAR 0 12
118785: PUSH
118786: LD_INT 2
118788: PPUSH
118789: LD_INT 6
118791: PPUSH
118792: CALL_OW 12
118796: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
118797: LD_ADDR_VAR 0 9
118801: PUSH
118802: LD_VAR 0 2
118806: PPUSH
118807: LD_VAR 0 11
118811: PPUSH
118812: LD_VAR 0 12
118816: PPUSH
118817: CALL_OW 272
118821: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
118822: LD_ADDR_VAR 0 10
118826: PUSH
118827: LD_VAR 0 3
118831: PPUSH
118832: LD_VAR 0 11
118836: PPUSH
118837: LD_VAR 0 12
118841: PPUSH
118842: CALL_OW 273
118846: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
118847: LD_VAR 0 9
118851: PPUSH
118852: LD_VAR 0 10
118856: PPUSH
118857: CALL_OW 488
118861: PUSH
118862: LD_VAR 0 9
118866: PUSH
118867: LD_VAR 0 10
118871: PUSH
118872: EMPTY
118873: LIST
118874: LIST
118875: PUSH
118876: LD_VAR 0 7
118880: IN
118881: NOT
118882: AND
118883: PUSH
118884: LD_VAR 0 9
118888: PPUSH
118889: LD_VAR 0 10
118893: PPUSH
118894: CALL_OW 458
118898: NOT
118899: AND
118900: IFFALSE 118942
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
118902: LD_ADDR_VAR 0 7
118906: PUSH
118907: LD_VAR 0 7
118911: PPUSH
118912: LD_VAR 0 7
118916: PUSH
118917: LD_INT 1
118919: PLUS
118920: PPUSH
118921: LD_VAR 0 9
118925: PUSH
118926: LD_VAR 0 10
118930: PUSH
118931: EMPTY
118932: LIST
118933: LIST
118934: PPUSH
118935: CALL_OW 1
118939: ST_TO_ADDR
118940: GO 118956
// i := i - 1 ;
118942: LD_ADDR_VAR 0 5
118946: PUSH
118947: LD_VAR 0 5
118951: PUSH
118952: LD_INT 1
118954: MINUS
118955: ST_TO_ADDR
// end ;
118956: GO 118762
118958: POP
118959: POP
// for i in tmp do
118960: LD_ADDR_VAR 0 5
118964: PUSH
118965: LD_VAR 0 7
118969: PUSH
118970: FOR_IN
118971: IFFALSE 119009
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
118973: LD_VAR 0 1
118977: PPUSH
118978: LD_VAR 0 5
118982: PUSH
118983: LD_INT 1
118985: ARRAY
118986: PPUSH
118987: LD_VAR 0 5
118991: PUSH
118992: LD_INT 2
118994: ARRAY
118995: PPUSH
118996: CALL 117951 0 3
119000: NOT
119001: IFFALSE 119007
// exit ;
119003: POP
119004: POP
119005: GO 119011
119007: GO 118970
119009: POP
119010: POP
// end ;
119011: LD_VAR 0 4
119015: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
119016: LD_INT 0
119018: PPUSH
119019: PPUSH
119020: PPUSH
119021: PPUSH
119022: PPUSH
119023: PPUSH
119024: PPUSH
// if not GetClass ( unit ) = class_sniper then
119025: LD_VAR 0 1
119029: PPUSH
119030: CALL_OW 257
119034: PUSH
119035: LD_INT 5
119037: EQUAL
119038: NOT
119039: IFFALSE 119043
// exit ;
119041: GO 119431
// dist := 8 ;
119043: LD_ADDR_VAR 0 5
119047: PUSH
119048: LD_INT 8
119050: ST_TO_ADDR
// viewRange := 12 ;
119051: LD_ADDR_VAR 0 7
119055: PUSH
119056: LD_INT 12
119058: ST_TO_ADDR
// side := GetSide ( unit ) ;
119059: LD_ADDR_VAR 0 6
119063: PUSH
119064: LD_VAR 0 1
119068: PPUSH
119069: CALL_OW 255
119073: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
119074: LD_INT 61
119076: PPUSH
119077: LD_VAR 0 6
119081: PPUSH
119082: CALL_OW 321
119086: PUSH
119087: LD_INT 2
119089: EQUAL
119090: IFFALSE 119100
// viewRange := 16 ;
119092: LD_ADDR_VAR 0 7
119096: PUSH
119097: LD_INT 16
119099: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
119100: LD_VAR 0 1
119104: PPUSH
119105: LD_VAR 0 2
119109: PPUSH
119110: LD_VAR 0 3
119114: PPUSH
119115: CALL_OW 297
119119: PUSH
119120: LD_VAR 0 5
119124: GREATER
119125: IFFALSE 119204
// begin ComMoveXY ( unit , x , y ) ;
119127: LD_VAR 0 1
119131: PPUSH
119132: LD_VAR 0 2
119136: PPUSH
119137: LD_VAR 0 3
119141: PPUSH
119142: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
119146: LD_INT 35
119148: PPUSH
119149: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
119153: LD_VAR 0 1
119157: PPUSH
119158: LD_VAR 0 2
119162: PPUSH
119163: LD_VAR 0 3
119167: PPUSH
119168: CALL 100006 0 3
119172: NOT
119173: IFFALSE 119177
// exit ;
119175: GO 119431
// until GetDistUnitXY ( unit , x , y ) < dist ;
119177: LD_VAR 0 1
119181: PPUSH
119182: LD_VAR 0 2
119186: PPUSH
119187: LD_VAR 0 3
119191: PPUSH
119192: CALL_OW 297
119196: PUSH
119197: LD_VAR 0 5
119201: LESS
119202: IFFALSE 119146
// end ; ComTurnXY ( unit , x , y ) ;
119204: LD_VAR 0 1
119208: PPUSH
119209: LD_VAR 0 2
119213: PPUSH
119214: LD_VAR 0 3
119218: PPUSH
119219: CALL_OW 118
// wait ( 5 ) ;
119223: LD_INT 5
119225: PPUSH
119226: CALL_OW 67
// _d := GetDir ( unit ) ;
119230: LD_ADDR_VAR 0 10
119234: PUSH
119235: LD_VAR 0 1
119239: PPUSH
119240: CALL_OW 254
119244: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
119245: LD_ADDR_VAR 0 8
119249: PUSH
119250: LD_VAR 0 1
119254: PPUSH
119255: CALL_OW 250
119259: PPUSH
119260: LD_VAR 0 10
119264: PPUSH
119265: LD_VAR 0 5
119269: PPUSH
119270: CALL_OW 272
119274: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
119275: LD_ADDR_VAR 0 9
119279: PUSH
119280: LD_VAR 0 1
119284: PPUSH
119285: CALL_OW 251
119289: PPUSH
119290: LD_VAR 0 10
119294: PPUSH
119295: LD_VAR 0 5
119299: PPUSH
119300: CALL_OW 273
119304: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
119305: LD_VAR 0 8
119309: PPUSH
119310: LD_VAR 0 9
119314: PPUSH
119315: CALL_OW 488
119319: NOT
119320: IFFALSE 119324
// exit ;
119322: GO 119431
// ComAnimCustom ( unit , 1 ) ;
119324: LD_VAR 0 1
119328: PPUSH
119329: LD_INT 1
119331: PPUSH
119332: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
119336: LD_VAR 0 8
119340: PPUSH
119341: LD_VAR 0 9
119345: PPUSH
119346: LD_VAR 0 6
119350: PPUSH
119351: LD_VAR 0 7
119355: PPUSH
119356: CALL_OW 330
// repeat wait ( 1 ) ;
119360: LD_INT 1
119362: PPUSH
119363: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
119367: LD_VAR 0 1
119371: PPUSH
119372: CALL_OW 316
119376: PUSH
119377: LD_VAR 0 1
119381: PPUSH
119382: CALL_OW 314
119386: OR
119387: PUSH
119388: LD_VAR 0 1
119392: PPUSH
119393: CALL_OW 302
119397: NOT
119398: OR
119399: PUSH
119400: LD_VAR 0 1
119404: PPUSH
119405: CALL_OW 301
119409: OR
119410: IFFALSE 119360
// RemoveSeeing ( _x , _y , side ) ;
119412: LD_VAR 0 8
119416: PPUSH
119417: LD_VAR 0 9
119421: PPUSH
119422: LD_VAR 0 6
119426: PPUSH
119427: CALL_OW 331
// end ; end_of_file
119431: LD_VAR 0 4
119435: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
119436: LD_INT 0
119438: PPUSH
119439: PPUSH
119440: PPUSH
119441: PPUSH
119442: PPUSH
119443: PPUSH
119444: PPUSH
119445: PPUSH
119446: PPUSH
119447: PPUSH
119448: PPUSH
119449: PPUSH
119450: PPUSH
119451: PPUSH
119452: PPUSH
119453: PPUSH
119454: PPUSH
119455: PPUSH
119456: PPUSH
119457: PPUSH
119458: PPUSH
119459: PPUSH
119460: PPUSH
119461: PPUSH
119462: PPUSH
119463: PPUSH
119464: PPUSH
119465: PPUSH
119466: PPUSH
119467: PPUSH
119468: PPUSH
119469: PPUSH
119470: PPUSH
119471: PPUSH
// if not list then
119472: LD_VAR 0 1
119476: NOT
119477: IFFALSE 119481
// exit ;
119479: GO 124140
// base := list [ 1 ] ;
119481: LD_ADDR_VAR 0 3
119485: PUSH
119486: LD_VAR 0 1
119490: PUSH
119491: LD_INT 1
119493: ARRAY
119494: ST_TO_ADDR
// group := list [ 2 ] ;
119495: LD_ADDR_VAR 0 4
119499: PUSH
119500: LD_VAR 0 1
119504: PUSH
119505: LD_INT 2
119507: ARRAY
119508: ST_TO_ADDR
// path := list [ 3 ] ;
119509: LD_ADDR_VAR 0 5
119513: PUSH
119514: LD_VAR 0 1
119518: PUSH
119519: LD_INT 3
119521: ARRAY
119522: ST_TO_ADDR
// flags := list [ 4 ] ;
119523: LD_ADDR_VAR 0 6
119527: PUSH
119528: LD_VAR 0 1
119532: PUSH
119533: LD_INT 4
119535: ARRAY
119536: ST_TO_ADDR
// mined := [ ] ;
119537: LD_ADDR_VAR 0 27
119541: PUSH
119542: EMPTY
119543: ST_TO_ADDR
// bombed := [ ] ;
119544: LD_ADDR_VAR 0 28
119548: PUSH
119549: EMPTY
119550: ST_TO_ADDR
// healers := [ ] ;
119551: LD_ADDR_VAR 0 31
119555: PUSH
119556: EMPTY
119557: ST_TO_ADDR
// to_heal := [ ] ;
119558: LD_ADDR_VAR 0 30
119562: PUSH
119563: EMPTY
119564: ST_TO_ADDR
// repairs := [ ] ;
119565: LD_ADDR_VAR 0 33
119569: PUSH
119570: EMPTY
119571: ST_TO_ADDR
// to_repair := [ ] ;
119572: LD_ADDR_VAR 0 32
119576: PUSH
119577: EMPTY
119578: ST_TO_ADDR
// if not group or not path then
119579: LD_VAR 0 4
119583: NOT
119584: PUSH
119585: LD_VAR 0 5
119589: NOT
119590: OR
119591: IFFALSE 119595
// exit ;
119593: GO 124140
// side := GetSide ( group [ 1 ] ) ;
119595: LD_ADDR_VAR 0 35
119599: PUSH
119600: LD_VAR 0 4
119604: PUSH
119605: LD_INT 1
119607: ARRAY
119608: PPUSH
119609: CALL_OW 255
119613: ST_TO_ADDR
// if flags then
119614: LD_VAR 0 6
119618: IFFALSE 119762
// begin f_ignore_area := flags [ 1 ] ;
119620: LD_ADDR_VAR 0 17
119624: PUSH
119625: LD_VAR 0 6
119629: PUSH
119630: LD_INT 1
119632: ARRAY
119633: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
119634: LD_ADDR_VAR 0 18
119638: PUSH
119639: LD_VAR 0 6
119643: PUSH
119644: LD_INT 2
119646: ARRAY
119647: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
119648: LD_ADDR_VAR 0 19
119652: PUSH
119653: LD_VAR 0 6
119657: PUSH
119658: LD_INT 3
119660: ARRAY
119661: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
119662: LD_ADDR_VAR 0 20
119666: PUSH
119667: LD_VAR 0 6
119671: PUSH
119672: LD_INT 4
119674: ARRAY
119675: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
119676: LD_ADDR_VAR 0 21
119680: PUSH
119681: LD_VAR 0 6
119685: PUSH
119686: LD_INT 5
119688: ARRAY
119689: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
119690: LD_ADDR_VAR 0 22
119694: PUSH
119695: LD_VAR 0 6
119699: PUSH
119700: LD_INT 6
119702: ARRAY
119703: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
119704: LD_ADDR_VAR 0 23
119708: PUSH
119709: LD_VAR 0 6
119713: PUSH
119714: LD_INT 7
119716: ARRAY
119717: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
119718: LD_ADDR_VAR 0 24
119722: PUSH
119723: LD_VAR 0 6
119727: PUSH
119728: LD_INT 8
119730: ARRAY
119731: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
119732: LD_ADDR_VAR 0 25
119736: PUSH
119737: LD_VAR 0 6
119741: PUSH
119742: LD_INT 9
119744: ARRAY
119745: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
119746: LD_ADDR_VAR 0 26
119750: PUSH
119751: LD_VAR 0 6
119755: PUSH
119756: LD_INT 10
119758: ARRAY
119759: ST_TO_ADDR
// end else
119760: GO 119842
// begin f_ignore_area := false ;
119762: LD_ADDR_VAR 0 17
119766: PUSH
119767: LD_INT 0
119769: ST_TO_ADDR
// f_capture := false ;
119770: LD_ADDR_VAR 0 18
119774: PUSH
119775: LD_INT 0
119777: ST_TO_ADDR
// f_ignore_civ := false ;
119778: LD_ADDR_VAR 0 19
119782: PUSH
119783: LD_INT 0
119785: ST_TO_ADDR
// f_murder := false ;
119786: LD_ADDR_VAR 0 20
119790: PUSH
119791: LD_INT 0
119793: ST_TO_ADDR
// f_mines := false ;
119794: LD_ADDR_VAR 0 21
119798: PUSH
119799: LD_INT 0
119801: ST_TO_ADDR
// f_repair := false ;
119802: LD_ADDR_VAR 0 22
119806: PUSH
119807: LD_INT 0
119809: ST_TO_ADDR
// f_heal := false ;
119810: LD_ADDR_VAR 0 23
119814: PUSH
119815: LD_INT 0
119817: ST_TO_ADDR
// f_spacetime := false ;
119818: LD_ADDR_VAR 0 24
119822: PUSH
119823: LD_INT 0
119825: ST_TO_ADDR
// f_attack_depot := false ;
119826: LD_ADDR_VAR 0 25
119830: PUSH
119831: LD_INT 0
119833: ST_TO_ADDR
// f_crawl := false ;
119834: LD_ADDR_VAR 0 26
119838: PUSH
119839: LD_INT 0
119841: ST_TO_ADDR
// end ; if f_heal then
119842: LD_VAR 0 23
119846: IFFALSE 119873
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
119848: LD_ADDR_VAR 0 31
119852: PUSH
119853: LD_VAR 0 4
119857: PPUSH
119858: LD_INT 25
119860: PUSH
119861: LD_INT 4
119863: PUSH
119864: EMPTY
119865: LIST
119866: LIST
119867: PPUSH
119868: CALL_OW 72
119872: ST_TO_ADDR
// if f_repair then
119873: LD_VAR 0 22
119877: IFFALSE 119904
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
119879: LD_ADDR_VAR 0 33
119883: PUSH
119884: LD_VAR 0 4
119888: PPUSH
119889: LD_INT 25
119891: PUSH
119892: LD_INT 3
119894: PUSH
119895: EMPTY
119896: LIST
119897: LIST
119898: PPUSH
119899: CALL_OW 72
119903: ST_TO_ADDR
// units_path := [ ] ;
119904: LD_ADDR_VAR 0 16
119908: PUSH
119909: EMPTY
119910: ST_TO_ADDR
// for i = 1 to group do
119911: LD_ADDR_VAR 0 7
119915: PUSH
119916: DOUBLE
119917: LD_INT 1
119919: DEC
119920: ST_TO_ADDR
119921: LD_VAR 0 4
119925: PUSH
119926: FOR_TO
119927: IFFALSE 119956
// units_path := Replace ( units_path , i , path ) ;
119929: LD_ADDR_VAR 0 16
119933: PUSH
119934: LD_VAR 0 16
119938: PPUSH
119939: LD_VAR 0 7
119943: PPUSH
119944: LD_VAR 0 5
119948: PPUSH
119949: CALL_OW 1
119953: ST_TO_ADDR
119954: GO 119926
119956: POP
119957: POP
// repeat for i = group downto 1 do
119958: LD_ADDR_VAR 0 7
119962: PUSH
119963: DOUBLE
119964: LD_VAR 0 4
119968: INC
119969: ST_TO_ADDR
119970: LD_INT 1
119972: PUSH
119973: FOR_DOWNTO
119974: IFFALSE 124096
// begin wait ( 5 ) ;
119976: LD_INT 5
119978: PPUSH
119979: CALL_OW 67
// tmp := [ ] ;
119983: LD_ADDR_VAR 0 14
119987: PUSH
119988: EMPTY
119989: ST_TO_ADDR
// attacking := false ;
119990: LD_ADDR_VAR 0 29
119994: PUSH
119995: LD_INT 0
119997: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
119998: LD_VAR 0 4
120002: PUSH
120003: LD_VAR 0 7
120007: ARRAY
120008: PPUSH
120009: CALL_OW 301
120013: PUSH
120014: LD_VAR 0 4
120018: PUSH
120019: LD_VAR 0 7
120023: ARRAY
120024: NOT
120025: OR
120026: IFFALSE 120135
// begin if GetType ( group [ i ] ) = unit_human then
120028: LD_VAR 0 4
120032: PUSH
120033: LD_VAR 0 7
120037: ARRAY
120038: PPUSH
120039: CALL_OW 247
120043: PUSH
120044: LD_INT 1
120046: EQUAL
120047: IFFALSE 120093
// begin to_heal := to_heal diff group [ i ] ;
120049: LD_ADDR_VAR 0 30
120053: PUSH
120054: LD_VAR 0 30
120058: PUSH
120059: LD_VAR 0 4
120063: PUSH
120064: LD_VAR 0 7
120068: ARRAY
120069: DIFF
120070: ST_TO_ADDR
// healers := healers diff group [ i ] ;
120071: LD_ADDR_VAR 0 31
120075: PUSH
120076: LD_VAR 0 31
120080: PUSH
120081: LD_VAR 0 4
120085: PUSH
120086: LD_VAR 0 7
120090: ARRAY
120091: DIFF
120092: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
120093: LD_ADDR_VAR 0 4
120097: PUSH
120098: LD_VAR 0 4
120102: PPUSH
120103: LD_VAR 0 7
120107: PPUSH
120108: CALL_OW 3
120112: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
120113: LD_ADDR_VAR 0 16
120117: PUSH
120118: LD_VAR 0 16
120122: PPUSH
120123: LD_VAR 0 7
120127: PPUSH
120128: CALL_OW 3
120132: ST_TO_ADDR
// continue ;
120133: GO 119973
// end ; if f_repair then
120135: LD_VAR 0 22
120139: IFFALSE 120628
// begin if GetType ( group [ i ] ) = unit_vehicle then
120141: LD_VAR 0 4
120145: PUSH
120146: LD_VAR 0 7
120150: ARRAY
120151: PPUSH
120152: CALL_OW 247
120156: PUSH
120157: LD_INT 2
120159: EQUAL
120160: IFFALSE 120350
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
120162: LD_VAR 0 4
120166: PUSH
120167: LD_VAR 0 7
120171: ARRAY
120172: PPUSH
120173: CALL_OW 256
120177: PUSH
120178: LD_INT 700
120180: LESS
120181: PUSH
120182: LD_VAR 0 4
120186: PUSH
120187: LD_VAR 0 7
120191: ARRAY
120192: PUSH
120193: LD_VAR 0 32
120197: IN
120198: NOT
120199: AND
120200: IFFALSE 120224
// to_repair := to_repair union group [ i ] ;
120202: LD_ADDR_VAR 0 32
120206: PUSH
120207: LD_VAR 0 32
120211: PUSH
120212: LD_VAR 0 4
120216: PUSH
120217: LD_VAR 0 7
120221: ARRAY
120222: UNION
120223: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
120224: LD_VAR 0 4
120228: PUSH
120229: LD_VAR 0 7
120233: ARRAY
120234: PPUSH
120235: CALL_OW 256
120239: PUSH
120240: LD_INT 1000
120242: EQUAL
120243: PUSH
120244: LD_VAR 0 4
120248: PUSH
120249: LD_VAR 0 7
120253: ARRAY
120254: PUSH
120255: LD_VAR 0 32
120259: IN
120260: AND
120261: IFFALSE 120285
// to_repair := to_repair diff group [ i ] ;
120263: LD_ADDR_VAR 0 32
120267: PUSH
120268: LD_VAR 0 32
120272: PUSH
120273: LD_VAR 0 4
120277: PUSH
120278: LD_VAR 0 7
120282: ARRAY
120283: DIFF
120284: ST_TO_ADDR
// if group [ i ] in to_repair then
120285: LD_VAR 0 4
120289: PUSH
120290: LD_VAR 0 7
120294: ARRAY
120295: PUSH
120296: LD_VAR 0 32
120300: IN
120301: IFFALSE 120348
// begin if not IsInArea ( group [ i ] , f_repair ) then
120303: LD_VAR 0 4
120307: PUSH
120308: LD_VAR 0 7
120312: ARRAY
120313: PPUSH
120314: LD_VAR 0 22
120318: PPUSH
120319: CALL_OW 308
120323: NOT
120324: IFFALSE 120346
// ComMoveToArea ( group [ i ] , f_repair ) ;
120326: LD_VAR 0 4
120330: PUSH
120331: LD_VAR 0 7
120335: ARRAY
120336: PPUSH
120337: LD_VAR 0 22
120341: PPUSH
120342: CALL_OW 113
// continue ;
120346: GO 119973
// end ; end else
120348: GO 120628
// if group [ i ] in repairs then
120350: LD_VAR 0 4
120354: PUSH
120355: LD_VAR 0 7
120359: ARRAY
120360: PUSH
120361: LD_VAR 0 33
120365: IN
120366: IFFALSE 120628
// begin if IsInUnit ( group [ i ] ) then
120368: LD_VAR 0 4
120372: PUSH
120373: LD_VAR 0 7
120377: ARRAY
120378: PPUSH
120379: CALL_OW 310
120383: IFFALSE 120451
// begin z := IsInUnit ( group [ i ] ) ;
120385: LD_ADDR_VAR 0 13
120389: PUSH
120390: LD_VAR 0 4
120394: PUSH
120395: LD_VAR 0 7
120399: ARRAY
120400: PPUSH
120401: CALL_OW 310
120405: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
120406: LD_VAR 0 13
120410: PUSH
120411: LD_VAR 0 32
120415: IN
120416: PUSH
120417: LD_VAR 0 13
120421: PPUSH
120422: LD_VAR 0 22
120426: PPUSH
120427: CALL_OW 308
120431: AND
120432: IFFALSE 120449
// ComExitVehicle ( group [ i ] ) ;
120434: LD_VAR 0 4
120438: PUSH
120439: LD_VAR 0 7
120443: ARRAY
120444: PPUSH
120445: CALL_OW 121
// end else
120449: GO 120628
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
120451: LD_ADDR_VAR 0 13
120455: PUSH
120456: LD_VAR 0 4
120460: PPUSH
120461: LD_INT 95
120463: PUSH
120464: LD_VAR 0 22
120468: PUSH
120469: EMPTY
120470: LIST
120471: LIST
120472: PUSH
120473: LD_INT 58
120475: PUSH
120476: EMPTY
120477: LIST
120478: PUSH
120479: EMPTY
120480: LIST
120481: LIST
120482: PPUSH
120483: CALL_OW 72
120487: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
120488: LD_VAR 0 4
120492: PUSH
120493: LD_VAR 0 7
120497: ARRAY
120498: PPUSH
120499: CALL_OW 314
120503: NOT
120504: IFFALSE 120626
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
120506: LD_ADDR_VAR 0 10
120510: PUSH
120511: LD_VAR 0 13
120515: PPUSH
120516: LD_VAR 0 4
120520: PUSH
120521: LD_VAR 0 7
120525: ARRAY
120526: PPUSH
120527: CALL_OW 74
120531: ST_TO_ADDR
// if not x then
120532: LD_VAR 0 10
120536: NOT
120537: IFFALSE 120541
// continue ;
120539: GO 119973
// if GetLives ( x ) < 1000 then
120541: LD_VAR 0 10
120545: PPUSH
120546: CALL_OW 256
120550: PUSH
120551: LD_INT 1000
120553: LESS
120554: IFFALSE 120578
// ComRepairVehicle ( group [ i ] , x ) else
120556: LD_VAR 0 4
120560: PUSH
120561: LD_VAR 0 7
120565: ARRAY
120566: PPUSH
120567: LD_VAR 0 10
120571: PPUSH
120572: CALL_OW 129
120576: GO 120626
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
120578: LD_VAR 0 23
120582: PUSH
120583: LD_VAR 0 4
120587: PUSH
120588: LD_VAR 0 7
120592: ARRAY
120593: PPUSH
120594: CALL_OW 256
120598: PUSH
120599: LD_INT 1000
120601: LESS
120602: AND
120603: NOT
120604: IFFALSE 120626
// ComEnterUnit ( group [ i ] , x ) ;
120606: LD_VAR 0 4
120610: PUSH
120611: LD_VAR 0 7
120615: ARRAY
120616: PPUSH
120617: LD_VAR 0 10
120621: PPUSH
120622: CALL_OW 120
// end ; continue ;
120626: GO 119973
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
120628: LD_VAR 0 23
120632: PUSH
120633: LD_VAR 0 4
120637: PUSH
120638: LD_VAR 0 7
120642: ARRAY
120643: PPUSH
120644: CALL_OW 247
120648: PUSH
120649: LD_INT 1
120651: EQUAL
120652: AND
120653: IFFALSE 121131
// begin if group [ i ] in healers then
120655: LD_VAR 0 4
120659: PUSH
120660: LD_VAR 0 7
120664: ARRAY
120665: PUSH
120666: LD_VAR 0 31
120670: IN
120671: IFFALSE 120944
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
120673: LD_VAR 0 4
120677: PUSH
120678: LD_VAR 0 7
120682: ARRAY
120683: PPUSH
120684: LD_VAR 0 23
120688: PPUSH
120689: CALL_OW 308
120693: NOT
120694: PUSH
120695: LD_VAR 0 4
120699: PUSH
120700: LD_VAR 0 7
120704: ARRAY
120705: PPUSH
120706: CALL_OW 314
120710: NOT
120711: AND
120712: IFFALSE 120736
// ComMoveToArea ( group [ i ] , f_heal ) else
120714: LD_VAR 0 4
120718: PUSH
120719: LD_VAR 0 7
120723: ARRAY
120724: PPUSH
120725: LD_VAR 0 23
120729: PPUSH
120730: CALL_OW 113
120734: GO 120942
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
120736: LD_VAR 0 4
120740: PUSH
120741: LD_VAR 0 7
120745: ARRAY
120746: PPUSH
120747: CALL 98529 0 1
120751: PPUSH
120752: CALL_OW 256
120756: PUSH
120757: LD_INT 1000
120759: EQUAL
120760: IFFALSE 120779
// ComStop ( group [ i ] ) else
120762: LD_VAR 0 4
120766: PUSH
120767: LD_VAR 0 7
120771: ARRAY
120772: PPUSH
120773: CALL_OW 141
120777: GO 120942
// if not HasTask ( group [ i ] ) and to_heal then
120779: LD_VAR 0 4
120783: PUSH
120784: LD_VAR 0 7
120788: ARRAY
120789: PPUSH
120790: CALL_OW 314
120794: NOT
120795: PUSH
120796: LD_VAR 0 30
120800: AND
120801: IFFALSE 120942
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
120803: LD_ADDR_VAR 0 13
120807: PUSH
120808: LD_VAR 0 30
120812: PPUSH
120813: LD_INT 3
120815: PUSH
120816: LD_INT 54
120818: PUSH
120819: EMPTY
120820: LIST
120821: PUSH
120822: EMPTY
120823: LIST
120824: LIST
120825: PPUSH
120826: CALL_OW 72
120830: PPUSH
120831: LD_VAR 0 4
120835: PUSH
120836: LD_VAR 0 7
120840: ARRAY
120841: PPUSH
120842: CALL_OW 74
120846: ST_TO_ADDR
// if z then
120847: LD_VAR 0 13
120851: IFFALSE 120942
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
120853: LD_INT 91
120855: PUSH
120856: LD_VAR 0 13
120860: PUSH
120861: LD_INT 10
120863: PUSH
120864: EMPTY
120865: LIST
120866: LIST
120867: LIST
120868: PUSH
120869: LD_INT 81
120871: PUSH
120872: LD_VAR 0 13
120876: PPUSH
120877: CALL_OW 255
120881: PUSH
120882: EMPTY
120883: LIST
120884: LIST
120885: PUSH
120886: EMPTY
120887: LIST
120888: LIST
120889: PPUSH
120890: CALL_OW 69
120894: PUSH
120895: LD_INT 0
120897: EQUAL
120898: IFFALSE 120922
// ComHeal ( group [ i ] , z ) else
120900: LD_VAR 0 4
120904: PUSH
120905: LD_VAR 0 7
120909: ARRAY
120910: PPUSH
120911: LD_VAR 0 13
120915: PPUSH
120916: CALL_OW 128
120920: GO 120942
// ComMoveToArea ( group [ i ] , f_heal ) ;
120922: LD_VAR 0 4
120926: PUSH
120927: LD_VAR 0 7
120931: ARRAY
120932: PPUSH
120933: LD_VAR 0 23
120937: PPUSH
120938: CALL_OW 113
// end ; continue ;
120942: GO 119973
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
120944: LD_VAR 0 4
120948: PUSH
120949: LD_VAR 0 7
120953: ARRAY
120954: PPUSH
120955: CALL_OW 256
120959: PUSH
120960: LD_INT 700
120962: LESS
120963: PUSH
120964: LD_VAR 0 4
120968: PUSH
120969: LD_VAR 0 7
120973: ARRAY
120974: PUSH
120975: LD_VAR 0 30
120979: IN
120980: NOT
120981: AND
120982: IFFALSE 121006
// to_heal := to_heal union group [ i ] ;
120984: LD_ADDR_VAR 0 30
120988: PUSH
120989: LD_VAR 0 30
120993: PUSH
120994: LD_VAR 0 4
120998: PUSH
120999: LD_VAR 0 7
121003: ARRAY
121004: UNION
121005: ST_TO_ADDR
// if group [ i ] in to_heal then
121006: LD_VAR 0 4
121010: PUSH
121011: LD_VAR 0 7
121015: ARRAY
121016: PUSH
121017: LD_VAR 0 30
121021: IN
121022: IFFALSE 121131
// begin if GetLives ( group [ i ] ) = 1000 then
121024: LD_VAR 0 4
121028: PUSH
121029: LD_VAR 0 7
121033: ARRAY
121034: PPUSH
121035: CALL_OW 256
121039: PUSH
121040: LD_INT 1000
121042: EQUAL
121043: IFFALSE 121069
// to_heal := to_heal diff group [ i ] else
121045: LD_ADDR_VAR 0 30
121049: PUSH
121050: LD_VAR 0 30
121054: PUSH
121055: LD_VAR 0 4
121059: PUSH
121060: LD_VAR 0 7
121064: ARRAY
121065: DIFF
121066: ST_TO_ADDR
121067: GO 121131
// begin if not IsInArea ( group [ i ] , to_heal ) then
121069: LD_VAR 0 4
121073: PUSH
121074: LD_VAR 0 7
121078: ARRAY
121079: PPUSH
121080: LD_VAR 0 30
121084: PPUSH
121085: CALL_OW 308
121089: NOT
121090: IFFALSE 121114
// ComMoveToArea ( group [ i ] , f_heal ) else
121092: LD_VAR 0 4
121096: PUSH
121097: LD_VAR 0 7
121101: ARRAY
121102: PPUSH
121103: LD_VAR 0 23
121107: PPUSH
121108: CALL_OW 113
121112: GO 121129
// ComHold ( group [ i ] ) ;
121114: LD_VAR 0 4
121118: PUSH
121119: LD_VAR 0 7
121123: ARRAY
121124: PPUSH
121125: CALL_OW 140
// continue ;
121129: GO 119973
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
121131: LD_VAR 0 4
121135: PUSH
121136: LD_VAR 0 7
121140: ARRAY
121141: PPUSH
121142: LD_INT 10
121144: PPUSH
121145: CALL 96949 0 2
121149: NOT
121150: PUSH
121151: LD_VAR 0 16
121155: PUSH
121156: LD_VAR 0 7
121160: ARRAY
121161: PUSH
121162: EMPTY
121163: EQUAL
121164: NOT
121165: AND
121166: IFFALSE 121432
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
121168: LD_VAR 0 4
121172: PUSH
121173: LD_VAR 0 7
121177: ARRAY
121178: PPUSH
121179: CALL_OW 262
121183: PUSH
121184: LD_INT 1
121186: PUSH
121187: LD_INT 2
121189: PUSH
121190: EMPTY
121191: LIST
121192: LIST
121193: IN
121194: IFFALSE 121235
// if GetFuel ( group [ i ] ) < 10 then
121196: LD_VAR 0 4
121200: PUSH
121201: LD_VAR 0 7
121205: ARRAY
121206: PPUSH
121207: CALL_OW 261
121211: PUSH
121212: LD_INT 10
121214: LESS
121215: IFFALSE 121235
// SetFuel ( group [ i ] , 12 ) ;
121217: LD_VAR 0 4
121221: PUSH
121222: LD_VAR 0 7
121226: ARRAY
121227: PPUSH
121228: LD_INT 12
121230: PPUSH
121231: CALL_OW 240
// if units_path [ i ] then
121235: LD_VAR 0 16
121239: PUSH
121240: LD_VAR 0 7
121244: ARRAY
121245: IFFALSE 121430
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
121247: LD_VAR 0 4
121251: PUSH
121252: LD_VAR 0 7
121256: ARRAY
121257: PPUSH
121258: LD_VAR 0 16
121262: PUSH
121263: LD_VAR 0 7
121267: ARRAY
121268: PUSH
121269: LD_INT 1
121271: ARRAY
121272: PUSH
121273: LD_INT 1
121275: ARRAY
121276: PPUSH
121277: LD_VAR 0 16
121281: PUSH
121282: LD_VAR 0 7
121286: ARRAY
121287: PUSH
121288: LD_INT 1
121290: ARRAY
121291: PUSH
121292: LD_INT 2
121294: ARRAY
121295: PPUSH
121296: CALL_OW 297
121300: PUSH
121301: LD_INT 6
121303: GREATER
121304: IFFALSE 121379
// begin if not HasTask ( group [ i ] ) then
121306: LD_VAR 0 4
121310: PUSH
121311: LD_VAR 0 7
121315: ARRAY
121316: PPUSH
121317: CALL_OW 314
121321: NOT
121322: IFFALSE 121377
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
121324: LD_VAR 0 4
121328: PUSH
121329: LD_VAR 0 7
121333: ARRAY
121334: PPUSH
121335: LD_VAR 0 16
121339: PUSH
121340: LD_VAR 0 7
121344: ARRAY
121345: PUSH
121346: LD_INT 1
121348: ARRAY
121349: PUSH
121350: LD_INT 1
121352: ARRAY
121353: PPUSH
121354: LD_VAR 0 16
121358: PUSH
121359: LD_VAR 0 7
121363: ARRAY
121364: PUSH
121365: LD_INT 1
121367: ARRAY
121368: PUSH
121369: LD_INT 2
121371: ARRAY
121372: PPUSH
121373: CALL_OW 114
// end else
121377: GO 121430
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
121379: LD_ADDR_VAR 0 15
121383: PUSH
121384: LD_VAR 0 16
121388: PUSH
121389: LD_VAR 0 7
121393: ARRAY
121394: PPUSH
121395: LD_INT 1
121397: PPUSH
121398: CALL_OW 3
121402: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
121403: LD_ADDR_VAR 0 16
121407: PUSH
121408: LD_VAR 0 16
121412: PPUSH
121413: LD_VAR 0 7
121417: PPUSH
121418: LD_VAR 0 15
121422: PPUSH
121423: CALL_OW 1
121427: ST_TO_ADDR
// continue ;
121428: GO 119973
// end ; end ; end else
121430: GO 124094
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
121432: LD_ADDR_VAR 0 14
121436: PUSH
121437: LD_INT 81
121439: PUSH
121440: LD_VAR 0 4
121444: PUSH
121445: LD_VAR 0 7
121449: ARRAY
121450: PPUSH
121451: CALL_OW 255
121455: PUSH
121456: EMPTY
121457: LIST
121458: LIST
121459: PPUSH
121460: CALL_OW 69
121464: ST_TO_ADDR
// if not tmp then
121465: LD_VAR 0 14
121469: NOT
121470: IFFALSE 121474
// continue ;
121472: GO 119973
// if f_ignore_area then
121474: LD_VAR 0 17
121478: IFFALSE 121566
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
121480: LD_ADDR_VAR 0 15
121484: PUSH
121485: LD_VAR 0 14
121489: PPUSH
121490: LD_INT 3
121492: PUSH
121493: LD_INT 92
121495: PUSH
121496: LD_VAR 0 17
121500: PUSH
121501: LD_INT 1
121503: ARRAY
121504: PUSH
121505: LD_VAR 0 17
121509: PUSH
121510: LD_INT 2
121512: ARRAY
121513: PUSH
121514: LD_VAR 0 17
121518: PUSH
121519: LD_INT 3
121521: ARRAY
121522: PUSH
121523: EMPTY
121524: LIST
121525: LIST
121526: LIST
121527: LIST
121528: PUSH
121529: EMPTY
121530: LIST
121531: LIST
121532: PPUSH
121533: CALL_OW 72
121537: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121538: LD_VAR 0 14
121542: PUSH
121543: LD_VAR 0 15
121547: DIFF
121548: IFFALSE 121566
// tmp := tmp diff tmp2 ;
121550: LD_ADDR_VAR 0 14
121554: PUSH
121555: LD_VAR 0 14
121559: PUSH
121560: LD_VAR 0 15
121564: DIFF
121565: ST_TO_ADDR
// end ; if not f_murder then
121566: LD_VAR 0 20
121570: NOT
121571: IFFALSE 121629
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
121573: LD_ADDR_VAR 0 15
121577: PUSH
121578: LD_VAR 0 14
121582: PPUSH
121583: LD_INT 3
121585: PUSH
121586: LD_INT 50
121588: PUSH
121589: EMPTY
121590: LIST
121591: PUSH
121592: EMPTY
121593: LIST
121594: LIST
121595: PPUSH
121596: CALL_OW 72
121600: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
121601: LD_VAR 0 14
121605: PUSH
121606: LD_VAR 0 15
121610: DIFF
121611: IFFALSE 121629
// tmp := tmp diff tmp2 ;
121613: LD_ADDR_VAR 0 14
121617: PUSH
121618: LD_VAR 0 14
121622: PUSH
121623: LD_VAR 0 15
121627: DIFF
121628: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
121629: LD_ADDR_VAR 0 14
121633: PUSH
121634: LD_VAR 0 4
121638: PUSH
121639: LD_VAR 0 7
121643: ARRAY
121644: PPUSH
121645: LD_VAR 0 14
121649: PPUSH
121650: LD_INT 1
121652: PPUSH
121653: LD_INT 1
121655: PPUSH
121656: CALL 70592 0 4
121660: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
121661: LD_VAR 0 4
121665: PUSH
121666: LD_VAR 0 7
121670: ARRAY
121671: PPUSH
121672: CALL_OW 257
121676: PUSH
121677: LD_INT 1
121679: EQUAL
121680: IFFALSE 122128
// begin if WantPlant ( group [ i ] ) then
121682: LD_VAR 0 4
121686: PUSH
121687: LD_VAR 0 7
121691: ARRAY
121692: PPUSH
121693: CALL 70093 0 1
121697: IFFALSE 121701
// continue ;
121699: GO 119973
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
121701: LD_VAR 0 18
121705: PUSH
121706: LD_VAR 0 4
121710: PUSH
121711: LD_VAR 0 7
121715: ARRAY
121716: PPUSH
121717: CALL_OW 310
121721: NOT
121722: AND
121723: PUSH
121724: LD_VAR 0 14
121728: PUSH
121729: LD_INT 1
121731: ARRAY
121732: PUSH
121733: LD_VAR 0 14
121737: PPUSH
121738: LD_INT 21
121740: PUSH
121741: LD_INT 2
121743: PUSH
121744: EMPTY
121745: LIST
121746: LIST
121747: PUSH
121748: LD_INT 58
121750: PUSH
121751: EMPTY
121752: LIST
121753: PUSH
121754: EMPTY
121755: LIST
121756: LIST
121757: PPUSH
121758: CALL_OW 72
121762: IN
121763: AND
121764: IFFALSE 121800
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
121766: LD_VAR 0 4
121770: PUSH
121771: LD_VAR 0 7
121775: ARRAY
121776: PPUSH
121777: LD_VAR 0 14
121781: PUSH
121782: LD_INT 1
121784: ARRAY
121785: PPUSH
121786: CALL_OW 120
// attacking := true ;
121790: LD_ADDR_VAR 0 29
121794: PUSH
121795: LD_INT 1
121797: ST_TO_ADDR
// continue ;
121798: GO 119973
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
121800: LD_VAR 0 26
121804: PUSH
121805: LD_VAR 0 4
121809: PUSH
121810: LD_VAR 0 7
121814: ARRAY
121815: PPUSH
121816: CALL_OW 257
121820: PUSH
121821: LD_INT 1
121823: EQUAL
121824: AND
121825: PUSH
121826: LD_VAR 0 4
121830: PUSH
121831: LD_VAR 0 7
121835: ARRAY
121836: PPUSH
121837: CALL_OW 256
121841: PUSH
121842: LD_INT 800
121844: LESS
121845: AND
121846: PUSH
121847: LD_VAR 0 4
121851: PUSH
121852: LD_VAR 0 7
121856: ARRAY
121857: PPUSH
121858: CALL_OW 318
121862: NOT
121863: AND
121864: IFFALSE 121881
// ComCrawl ( group [ i ] ) ;
121866: LD_VAR 0 4
121870: PUSH
121871: LD_VAR 0 7
121875: ARRAY
121876: PPUSH
121877: CALL_OW 137
// if f_mines then
121881: LD_VAR 0 21
121885: IFFALSE 122128
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
121887: LD_VAR 0 14
121891: PUSH
121892: LD_INT 1
121894: ARRAY
121895: PPUSH
121896: CALL_OW 247
121900: PUSH
121901: LD_INT 3
121903: EQUAL
121904: PUSH
121905: LD_VAR 0 14
121909: PUSH
121910: LD_INT 1
121912: ARRAY
121913: PUSH
121914: LD_VAR 0 27
121918: IN
121919: NOT
121920: AND
121921: IFFALSE 122128
// begin x := GetX ( tmp [ 1 ] ) ;
121923: LD_ADDR_VAR 0 10
121927: PUSH
121928: LD_VAR 0 14
121932: PUSH
121933: LD_INT 1
121935: ARRAY
121936: PPUSH
121937: CALL_OW 250
121941: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
121942: LD_ADDR_VAR 0 11
121946: PUSH
121947: LD_VAR 0 14
121951: PUSH
121952: LD_INT 1
121954: ARRAY
121955: PPUSH
121956: CALL_OW 251
121960: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
121961: LD_ADDR_VAR 0 12
121965: PUSH
121966: LD_VAR 0 4
121970: PUSH
121971: LD_VAR 0 7
121975: ARRAY
121976: PPUSH
121977: CALL 97034 0 1
121981: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
121982: LD_VAR 0 4
121986: PUSH
121987: LD_VAR 0 7
121991: ARRAY
121992: PPUSH
121993: LD_VAR 0 10
121997: PPUSH
121998: LD_VAR 0 11
122002: PPUSH
122003: LD_VAR 0 14
122007: PUSH
122008: LD_INT 1
122010: ARRAY
122011: PPUSH
122012: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
122016: LD_VAR 0 4
122020: PUSH
122021: LD_VAR 0 7
122025: ARRAY
122026: PPUSH
122027: LD_VAR 0 10
122031: PPUSH
122032: LD_VAR 0 12
122036: PPUSH
122037: LD_INT 7
122039: PPUSH
122040: CALL_OW 272
122044: PPUSH
122045: LD_VAR 0 11
122049: PPUSH
122050: LD_VAR 0 12
122054: PPUSH
122055: LD_INT 7
122057: PPUSH
122058: CALL_OW 273
122062: PPUSH
122063: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
122067: LD_VAR 0 4
122071: PUSH
122072: LD_VAR 0 7
122076: ARRAY
122077: PPUSH
122078: LD_INT 71
122080: PPUSH
122081: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
122085: LD_ADDR_VAR 0 27
122089: PUSH
122090: LD_VAR 0 27
122094: PPUSH
122095: LD_VAR 0 27
122099: PUSH
122100: LD_INT 1
122102: PLUS
122103: PPUSH
122104: LD_VAR 0 14
122108: PUSH
122109: LD_INT 1
122111: ARRAY
122112: PPUSH
122113: CALL_OW 1
122117: ST_TO_ADDR
// attacking := true ;
122118: LD_ADDR_VAR 0 29
122122: PUSH
122123: LD_INT 1
122125: ST_TO_ADDR
// continue ;
122126: GO 119973
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
122128: LD_VAR 0 4
122132: PUSH
122133: LD_VAR 0 7
122137: ARRAY
122138: PPUSH
122139: CALL_OW 257
122143: PUSH
122144: LD_INT 17
122146: EQUAL
122147: PUSH
122148: LD_VAR 0 4
122152: PUSH
122153: LD_VAR 0 7
122157: ARRAY
122158: PPUSH
122159: CALL_OW 110
122163: PUSH
122164: LD_INT 71
122166: EQUAL
122167: NOT
122168: AND
122169: IFFALSE 122315
// begin attacking := false ;
122171: LD_ADDR_VAR 0 29
122175: PUSH
122176: LD_INT 0
122178: ST_TO_ADDR
// k := 5 ;
122179: LD_ADDR_VAR 0 9
122183: PUSH
122184: LD_INT 5
122186: ST_TO_ADDR
// if tmp < k then
122187: LD_VAR 0 14
122191: PUSH
122192: LD_VAR 0 9
122196: LESS
122197: IFFALSE 122209
// k := tmp ;
122199: LD_ADDR_VAR 0 9
122203: PUSH
122204: LD_VAR 0 14
122208: ST_TO_ADDR
// for j = 1 to k do
122209: LD_ADDR_VAR 0 8
122213: PUSH
122214: DOUBLE
122215: LD_INT 1
122217: DEC
122218: ST_TO_ADDR
122219: LD_VAR 0 9
122223: PUSH
122224: FOR_TO
122225: IFFALSE 122313
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
122227: LD_VAR 0 14
122231: PUSH
122232: LD_VAR 0 8
122236: ARRAY
122237: PUSH
122238: LD_VAR 0 14
122242: PPUSH
122243: LD_INT 58
122245: PUSH
122246: EMPTY
122247: LIST
122248: PPUSH
122249: CALL_OW 72
122253: IN
122254: NOT
122255: IFFALSE 122311
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
122257: LD_VAR 0 4
122261: PUSH
122262: LD_VAR 0 7
122266: ARRAY
122267: PPUSH
122268: LD_VAR 0 14
122272: PUSH
122273: LD_VAR 0 8
122277: ARRAY
122278: PPUSH
122279: CALL_OW 115
// attacking := true ;
122283: LD_ADDR_VAR 0 29
122287: PUSH
122288: LD_INT 1
122290: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
122291: LD_VAR 0 4
122295: PUSH
122296: LD_VAR 0 7
122300: ARRAY
122301: PPUSH
122302: LD_INT 71
122304: PPUSH
122305: CALL_OW 109
// continue ;
122309: GO 122224
// end ; end ;
122311: GO 122224
122313: POP
122314: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
122315: LD_VAR 0 4
122319: PUSH
122320: LD_VAR 0 7
122324: ARRAY
122325: PPUSH
122326: CALL_OW 257
122330: PUSH
122331: LD_INT 8
122333: EQUAL
122334: PUSH
122335: LD_VAR 0 4
122339: PUSH
122340: LD_VAR 0 7
122344: ARRAY
122345: PPUSH
122346: CALL_OW 264
122350: PUSH
122351: LD_INT 28
122353: PUSH
122354: LD_INT 45
122356: PUSH
122357: LD_INT 7
122359: PUSH
122360: LD_INT 47
122362: PUSH
122363: EMPTY
122364: LIST
122365: LIST
122366: LIST
122367: LIST
122368: IN
122369: OR
122370: IFFALSE 122626
// begin attacking := false ;
122372: LD_ADDR_VAR 0 29
122376: PUSH
122377: LD_INT 0
122379: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
122380: LD_VAR 0 14
122384: PUSH
122385: LD_INT 1
122387: ARRAY
122388: PPUSH
122389: CALL_OW 266
122393: PUSH
122394: LD_INT 32
122396: PUSH
122397: LD_INT 31
122399: PUSH
122400: LD_INT 33
122402: PUSH
122403: LD_INT 4
122405: PUSH
122406: LD_INT 5
122408: PUSH
122409: EMPTY
122410: LIST
122411: LIST
122412: LIST
122413: LIST
122414: LIST
122415: IN
122416: IFFALSE 122602
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
122418: LD_ADDR_VAR 0 9
122422: PUSH
122423: LD_VAR 0 14
122427: PUSH
122428: LD_INT 1
122430: ARRAY
122431: PPUSH
122432: CALL_OW 266
122436: PPUSH
122437: LD_VAR 0 14
122441: PUSH
122442: LD_INT 1
122444: ARRAY
122445: PPUSH
122446: CALL_OW 250
122450: PPUSH
122451: LD_VAR 0 14
122455: PUSH
122456: LD_INT 1
122458: ARRAY
122459: PPUSH
122460: CALL_OW 251
122464: PPUSH
122465: LD_VAR 0 14
122469: PUSH
122470: LD_INT 1
122472: ARRAY
122473: PPUSH
122474: CALL_OW 254
122478: PPUSH
122479: LD_VAR 0 14
122483: PUSH
122484: LD_INT 1
122486: ARRAY
122487: PPUSH
122488: CALL_OW 248
122492: PPUSH
122493: LD_INT 0
122495: PPUSH
122496: CALL 78404 0 6
122500: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
122501: LD_ADDR_VAR 0 8
122505: PUSH
122506: LD_VAR 0 4
122510: PUSH
122511: LD_VAR 0 7
122515: ARRAY
122516: PPUSH
122517: LD_VAR 0 9
122521: PPUSH
122522: CALL 97074 0 2
122526: ST_TO_ADDR
// if j then
122527: LD_VAR 0 8
122531: IFFALSE 122600
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
122533: LD_VAR 0 8
122537: PUSH
122538: LD_INT 1
122540: ARRAY
122541: PPUSH
122542: LD_VAR 0 8
122546: PUSH
122547: LD_INT 2
122549: ARRAY
122550: PPUSH
122551: CALL_OW 488
122555: IFFALSE 122600
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
122557: LD_VAR 0 4
122561: PUSH
122562: LD_VAR 0 7
122566: ARRAY
122567: PPUSH
122568: LD_VAR 0 8
122572: PUSH
122573: LD_INT 1
122575: ARRAY
122576: PPUSH
122577: LD_VAR 0 8
122581: PUSH
122582: LD_INT 2
122584: ARRAY
122585: PPUSH
122586: CALL_OW 116
// attacking := true ;
122590: LD_ADDR_VAR 0 29
122594: PUSH
122595: LD_INT 1
122597: ST_TO_ADDR
// continue ;
122598: GO 119973
// end ; end else
122600: GO 122626
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122602: LD_VAR 0 4
122606: PUSH
122607: LD_VAR 0 7
122611: ARRAY
122612: PPUSH
122613: LD_VAR 0 14
122617: PUSH
122618: LD_INT 1
122620: ARRAY
122621: PPUSH
122622: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
122626: LD_VAR 0 4
122630: PUSH
122631: LD_VAR 0 7
122635: ARRAY
122636: PPUSH
122637: CALL_OW 265
122641: PUSH
122642: LD_INT 11
122644: EQUAL
122645: IFFALSE 122923
// begin k := 10 ;
122647: LD_ADDR_VAR 0 9
122651: PUSH
122652: LD_INT 10
122654: ST_TO_ADDR
// x := 0 ;
122655: LD_ADDR_VAR 0 10
122659: PUSH
122660: LD_INT 0
122662: ST_TO_ADDR
// if tmp < k then
122663: LD_VAR 0 14
122667: PUSH
122668: LD_VAR 0 9
122672: LESS
122673: IFFALSE 122685
// k := tmp ;
122675: LD_ADDR_VAR 0 9
122679: PUSH
122680: LD_VAR 0 14
122684: ST_TO_ADDR
// for j = k downto 1 do
122685: LD_ADDR_VAR 0 8
122689: PUSH
122690: DOUBLE
122691: LD_VAR 0 9
122695: INC
122696: ST_TO_ADDR
122697: LD_INT 1
122699: PUSH
122700: FOR_DOWNTO
122701: IFFALSE 122776
// begin if GetType ( tmp [ j ] ) = unit_human then
122703: LD_VAR 0 14
122707: PUSH
122708: LD_VAR 0 8
122712: ARRAY
122713: PPUSH
122714: CALL_OW 247
122718: PUSH
122719: LD_INT 1
122721: EQUAL
122722: IFFALSE 122774
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
122724: LD_VAR 0 4
122728: PUSH
122729: LD_VAR 0 7
122733: ARRAY
122734: PPUSH
122735: LD_VAR 0 14
122739: PUSH
122740: LD_VAR 0 8
122744: ARRAY
122745: PPUSH
122746: CALL 97345 0 2
// x := tmp [ j ] ;
122750: LD_ADDR_VAR 0 10
122754: PUSH
122755: LD_VAR 0 14
122759: PUSH
122760: LD_VAR 0 8
122764: ARRAY
122765: ST_TO_ADDR
// attacking := true ;
122766: LD_ADDR_VAR 0 29
122770: PUSH
122771: LD_INT 1
122773: ST_TO_ADDR
// end ; end ;
122774: GO 122700
122776: POP
122777: POP
// if not x then
122778: LD_VAR 0 10
122782: NOT
122783: IFFALSE 122923
// begin attacking := true ;
122785: LD_ADDR_VAR 0 29
122789: PUSH
122790: LD_INT 1
122792: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
122793: LD_VAR 0 4
122797: PUSH
122798: LD_VAR 0 7
122802: ARRAY
122803: PPUSH
122804: CALL_OW 250
122808: PPUSH
122809: LD_VAR 0 4
122813: PUSH
122814: LD_VAR 0 7
122818: ARRAY
122819: PPUSH
122820: CALL_OW 251
122824: PPUSH
122825: CALL_OW 546
122829: PUSH
122830: LD_INT 2
122832: ARRAY
122833: PUSH
122834: LD_VAR 0 14
122838: PUSH
122839: LD_INT 1
122841: ARRAY
122842: PPUSH
122843: CALL_OW 250
122847: PPUSH
122848: LD_VAR 0 14
122852: PUSH
122853: LD_INT 1
122855: ARRAY
122856: PPUSH
122857: CALL_OW 251
122861: PPUSH
122862: CALL_OW 546
122866: PUSH
122867: LD_INT 2
122869: ARRAY
122870: EQUAL
122871: IFFALSE 122899
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
122873: LD_VAR 0 4
122877: PUSH
122878: LD_VAR 0 7
122882: ARRAY
122883: PPUSH
122884: LD_VAR 0 14
122888: PUSH
122889: LD_INT 1
122891: ARRAY
122892: PPUSH
122893: CALL 97345 0 2
122897: GO 122923
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122899: LD_VAR 0 4
122903: PUSH
122904: LD_VAR 0 7
122908: ARRAY
122909: PPUSH
122910: LD_VAR 0 14
122914: PUSH
122915: LD_INT 1
122917: ARRAY
122918: PPUSH
122919: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
122923: LD_VAR 0 4
122927: PUSH
122928: LD_VAR 0 7
122932: ARRAY
122933: PPUSH
122934: CALL_OW 264
122938: PUSH
122939: LD_INT 29
122941: EQUAL
122942: IFFALSE 123308
// begin if WantsToAttack ( group [ i ] ) in bombed then
122944: LD_VAR 0 4
122948: PUSH
122949: LD_VAR 0 7
122953: ARRAY
122954: PPUSH
122955: CALL_OW 319
122959: PUSH
122960: LD_VAR 0 28
122964: IN
122965: IFFALSE 122969
// continue ;
122967: GO 119973
// k := 8 ;
122969: LD_ADDR_VAR 0 9
122973: PUSH
122974: LD_INT 8
122976: ST_TO_ADDR
// x := 0 ;
122977: LD_ADDR_VAR 0 10
122981: PUSH
122982: LD_INT 0
122984: ST_TO_ADDR
// if tmp < k then
122985: LD_VAR 0 14
122989: PUSH
122990: LD_VAR 0 9
122994: LESS
122995: IFFALSE 123007
// k := tmp ;
122997: LD_ADDR_VAR 0 9
123001: PUSH
123002: LD_VAR 0 14
123006: ST_TO_ADDR
// for j = 1 to k do
123007: LD_ADDR_VAR 0 8
123011: PUSH
123012: DOUBLE
123013: LD_INT 1
123015: DEC
123016: ST_TO_ADDR
123017: LD_VAR 0 9
123021: PUSH
123022: FOR_TO
123023: IFFALSE 123155
// begin if GetType ( tmp [ j ] ) = unit_building then
123025: LD_VAR 0 14
123029: PUSH
123030: LD_VAR 0 8
123034: ARRAY
123035: PPUSH
123036: CALL_OW 247
123040: PUSH
123041: LD_INT 3
123043: EQUAL
123044: IFFALSE 123153
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
123046: LD_VAR 0 14
123050: PUSH
123051: LD_VAR 0 8
123055: ARRAY
123056: PUSH
123057: LD_VAR 0 28
123061: IN
123062: NOT
123063: PUSH
123064: LD_VAR 0 14
123068: PUSH
123069: LD_VAR 0 8
123073: ARRAY
123074: PPUSH
123075: CALL_OW 313
123079: AND
123080: IFFALSE 123153
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123082: LD_VAR 0 4
123086: PUSH
123087: LD_VAR 0 7
123091: ARRAY
123092: PPUSH
123093: LD_VAR 0 14
123097: PUSH
123098: LD_VAR 0 8
123102: ARRAY
123103: PPUSH
123104: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
123108: LD_ADDR_VAR 0 28
123112: PUSH
123113: LD_VAR 0 28
123117: PPUSH
123118: LD_VAR 0 28
123122: PUSH
123123: LD_INT 1
123125: PLUS
123126: PPUSH
123127: LD_VAR 0 14
123131: PUSH
123132: LD_VAR 0 8
123136: ARRAY
123137: PPUSH
123138: CALL_OW 1
123142: ST_TO_ADDR
// attacking := true ;
123143: LD_ADDR_VAR 0 29
123147: PUSH
123148: LD_INT 1
123150: ST_TO_ADDR
// break ;
123151: GO 123155
// end ; end ;
123153: GO 123022
123155: POP
123156: POP
// if not attacking and f_attack_depot then
123157: LD_VAR 0 29
123161: NOT
123162: PUSH
123163: LD_VAR 0 25
123167: AND
123168: IFFALSE 123263
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123170: LD_ADDR_VAR 0 13
123174: PUSH
123175: LD_VAR 0 14
123179: PPUSH
123180: LD_INT 2
123182: PUSH
123183: LD_INT 30
123185: PUSH
123186: LD_INT 0
123188: PUSH
123189: EMPTY
123190: LIST
123191: LIST
123192: PUSH
123193: LD_INT 30
123195: PUSH
123196: LD_INT 1
123198: PUSH
123199: EMPTY
123200: LIST
123201: LIST
123202: PUSH
123203: EMPTY
123204: LIST
123205: LIST
123206: LIST
123207: PPUSH
123208: CALL_OW 72
123212: ST_TO_ADDR
// if z then
123213: LD_VAR 0 13
123217: IFFALSE 123263
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
123219: LD_VAR 0 4
123223: PUSH
123224: LD_VAR 0 7
123228: ARRAY
123229: PPUSH
123230: LD_VAR 0 13
123234: PPUSH
123235: LD_VAR 0 4
123239: PUSH
123240: LD_VAR 0 7
123244: ARRAY
123245: PPUSH
123246: CALL_OW 74
123250: PPUSH
123251: CALL_OW 115
// attacking := true ;
123255: LD_ADDR_VAR 0 29
123259: PUSH
123260: LD_INT 1
123262: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
123263: LD_VAR 0 4
123267: PUSH
123268: LD_VAR 0 7
123272: ARRAY
123273: PPUSH
123274: CALL_OW 256
123278: PUSH
123279: LD_INT 500
123281: LESS
123282: IFFALSE 123308
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123284: LD_VAR 0 4
123288: PUSH
123289: LD_VAR 0 7
123293: ARRAY
123294: PPUSH
123295: LD_VAR 0 14
123299: PUSH
123300: LD_INT 1
123302: ARRAY
123303: PPUSH
123304: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
123308: LD_VAR 0 4
123312: PUSH
123313: LD_VAR 0 7
123317: ARRAY
123318: PPUSH
123319: CALL_OW 264
123323: PUSH
123324: LD_INT 49
123326: EQUAL
123327: IFFALSE 123448
// begin if not HasTask ( group [ i ] ) then
123329: LD_VAR 0 4
123333: PUSH
123334: LD_VAR 0 7
123338: ARRAY
123339: PPUSH
123340: CALL_OW 314
123344: NOT
123345: IFFALSE 123448
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
123347: LD_ADDR_VAR 0 9
123351: PUSH
123352: LD_INT 81
123354: PUSH
123355: LD_VAR 0 4
123359: PUSH
123360: LD_VAR 0 7
123364: ARRAY
123365: PPUSH
123366: CALL_OW 255
123370: PUSH
123371: EMPTY
123372: LIST
123373: LIST
123374: PPUSH
123375: CALL_OW 69
123379: PPUSH
123380: LD_VAR 0 4
123384: PUSH
123385: LD_VAR 0 7
123389: ARRAY
123390: PPUSH
123391: CALL_OW 74
123395: ST_TO_ADDR
// if k then
123396: LD_VAR 0 9
123400: IFFALSE 123448
// if GetDistUnits ( group [ i ] , k ) > 10 then
123402: LD_VAR 0 4
123406: PUSH
123407: LD_VAR 0 7
123411: ARRAY
123412: PPUSH
123413: LD_VAR 0 9
123417: PPUSH
123418: CALL_OW 296
123422: PUSH
123423: LD_INT 10
123425: GREATER
123426: IFFALSE 123448
// ComMoveUnit ( group [ i ] , k ) ;
123428: LD_VAR 0 4
123432: PUSH
123433: LD_VAR 0 7
123437: ARRAY
123438: PPUSH
123439: LD_VAR 0 9
123443: PPUSH
123444: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
123448: LD_VAR 0 4
123452: PUSH
123453: LD_VAR 0 7
123457: ARRAY
123458: PPUSH
123459: CALL_OW 256
123463: PUSH
123464: LD_INT 250
123466: LESS
123467: PUSH
123468: LD_VAR 0 4
123472: PUSH
123473: LD_VAR 0 7
123477: ARRAY
123478: PUSH
123479: LD_INT 21
123481: PUSH
123482: LD_INT 2
123484: PUSH
123485: EMPTY
123486: LIST
123487: LIST
123488: PUSH
123489: LD_INT 23
123491: PUSH
123492: LD_INT 2
123494: PUSH
123495: EMPTY
123496: LIST
123497: LIST
123498: PUSH
123499: EMPTY
123500: LIST
123501: LIST
123502: PPUSH
123503: CALL_OW 69
123507: IN
123508: AND
123509: IFFALSE 123634
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
123511: LD_ADDR_VAR 0 9
123515: PUSH
123516: LD_OWVAR 3
123520: PUSH
123521: LD_VAR 0 4
123525: PUSH
123526: LD_VAR 0 7
123530: ARRAY
123531: DIFF
123532: PPUSH
123533: LD_VAR 0 4
123537: PUSH
123538: LD_VAR 0 7
123542: ARRAY
123543: PPUSH
123544: CALL_OW 74
123548: ST_TO_ADDR
// if not k then
123549: LD_VAR 0 9
123553: NOT
123554: IFFALSE 123558
// continue ;
123556: GO 119973
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
123558: LD_VAR 0 9
123562: PUSH
123563: LD_INT 81
123565: PUSH
123566: LD_VAR 0 4
123570: PUSH
123571: LD_VAR 0 7
123575: ARRAY
123576: PPUSH
123577: CALL_OW 255
123581: PUSH
123582: EMPTY
123583: LIST
123584: LIST
123585: PPUSH
123586: CALL_OW 69
123590: IN
123591: PUSH
123592: LD_VAR 0 9
123596: PPUSH
123597: LD_VAR 0 4
123601: PUSH
123602: LD_VAR 0 7
123606: ARRAY
123607: PPUSH
123608: CALL_OW 296
123612: PUSH
123613: LD_INT 5
123615: LESS
123616: AND
123617: IFFALSE 123634
// ComAutodestruct ( group [ i ] ) ;
123619: LD_VAR 0 4
123623: PUSH
123624: LD_VAR 0 7
123628: ARRAY
123629: PPUSH
123630: CALL 97243 0 1
// end ; if f_attack_depot then
123634: LD_VAR 0 25
123638: IFFALSE 123750
// begin k := 6 ;
123640: LD_ADDR_VAR 0 9
123644: PUSH
123645: LD_INT 6
123647: ST_TO_ADDR
// if tmp < k then
123648: LD_VAR 0 14
123652: PUSH
123653: LD_VAR 0 9
123657: LESS
123658: IFFALSE 123670
// k := tmp ;
123660: LD_ADDR_VAR 0 9
123664: PUSH
123665: LD_VAR 0 14
123669: ST_TO_ADDR
// for j = 1 to k do
123670: LD_ADDR_VAR 0 8
123674: PUSH
123675: DOUBLE
123676: LD_INT 1
123678: DEC
123679: ST_TO_ADDR
123680: LD_VAR 0 9
123684: PUSH
123685: FOR_TO
123686: IFFALSE 123748
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
123688: LD_VAR 0 8
123692: PPUSH
123693: CALL_OW 266
123697: PUSH
123698: LD_INT 0
123700: PUSH
123701: LD_INT 1
123703: PUSH
123704: EMPTY
123705: LIST
123706: LIST
123707: IN
123708: IFFALSE 123746
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123710: LD_VAR 0 4
123714: PUSH
123715: LD_VAR 0 7
123719: ARRAY
123720: PPUSH
123721: LD_VAR 0 14
123725: PUSH
123726: LD_VAR 0 8
123730: ARRAY
123731: PPUSH
123732: CALL_OW 115
// attacking := true ;
123736: LD_ADDR_VAR 0 29
123740: PUSH
123741: LD_INT 1
123743: ST_TO_ADDR
// break ;
123744: GO 123748
// end ;
123746: GO 123685
123748: POP
123749: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
123750: LD_VAR 0 4
123754: PUSH
123755: LD_VAR 0 7
123759: ARRAY
123760: PPUSH
123761: CALL_OW 302
123765: PUSH
123766: LD_VAR 0 29
123770: NOT
123771: AND
123772: IFFALSE 124094
// begin if GetTag ( group [ i ] ) = 71 then
123774: LD_VAR 0 4
123778: PUSH
123779: LD_VAR 0 7
123783: ARRAY
123784: PPUSH
123785: CALL_OW 110
123789: PUSH
123790: LD_INT 71
123792: EQUAL
123793: IFFALSE 123834
// begin if HasTask ( group [ i ] ) then
123795: LD_VAR 0 4
123799: PUSH
123800: LD_VAR 0 7
123804: ARRAY
123805: PPUSH
123806: CALL_OW 314
123810: IFFALSE 123816
// continue else
123812: GO 119973
123814: GO 123834
// SetTag ( group [ i ] , 0 ) ;
123816: LD_VAR 0 4
123820: PUSH
123821: LD_VAR 0 7
123825: ARRAY
123826: PPUSH
123827: LD_INT 0
123829: PPUSH
123830: CALL_OW 109
// end ; k := 8 ;
123834: LD_ADDR_VAR 0 9
123838: PUSH
123839: LD_INT 8
123841: ST_TO_ADDR
// x := 0 ;
123842: LD_ADDR_VAR 0 10
123846: PUSH
123847: LD_INT 0
123849: ST_TO_ADDR
// if tmp < k then
123850: LD_VAR 0 14
123854: PUSH
123855: LD_VAR 0 9
123859: LESS
123860: IFFALSE 123872
// k := tmp ;
123862: LD_ADDR_VAR 0 9
123866: PUSH
123867: LD_VAR 0 14
123871: ST_TO_ADDR
// for j = 1 to k do
123872: LD_ADDR_VAR 0 8
123876: PUSH
123877: DOUBLE
123878: LD_INT 1
123880: DEC
123881: ST_TO_ADDR
123882: LD_VAR 0 9
123886: PUSH
123887: FOR_TO
123888: IFFALSE 123986
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
123890: LD_VAR 0 14
123894: PUSH
123895: LD_VAR 0 8
123899: ARRAY
123900: PPUSH
123901: CALL_OW 247
123905: PUSH
123906: LD_INT 1
123908: EQUAL
123909: PUSH
123910: LD_VAR 0 14
123914: PUSH
123915: LD_VAR 0 8
123919: ARRAY
123920: PPUSH
123921: CALL_OW 256
123925: PUSH
123926: LD_INT 250
123928: LESS
123929: PUSH
123930: LD_VAR 0 20
123934: AND
123935: PUSH
123936: LD_VAR 0 20
123940: NOT
123941: PUSH
123942: LD_VAR 0 14
123946: PUSH
123947: LD_VAR 0 8
123951: ARRAY
123952: PPUSH
123953: CALL_OW 256
123957: PUSH
123958: LD_INT 250
123960: GREATEREQUAL
123961: AND
123962: OR
123963: AND
123964: IFFALSE 123984
// begin x := tmp [ j ] ;
123966: LD_ADDR_VAR 0 10
123970: PUSH
123971: LD_VAR 0 14
123975: PUSH
123976: LD_VAR 0 8
123980: ARRAY
123981: ST_TO_ADDR
// break ;
123982: GO 123986
// end ;
123984: GO 123887
123986: POP
123987: POP
// if x then
123988: LD_VAR 0 10
123992: IFFALSE 124016
// ComAttackUnit ( group [ i ] , x ) else
123994: LD_VAR 0 4
123998: PUSH
123999: LD_VAR 0 7
124003: ARRAY
124004: PPUSH
124005: LD_VAR 0 10
124009: PPUSH
124010: CALL_OW 115
124014: GO 124040
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124016: LD_VAR 0 4
124020: PUSH
124021: LD_VAR 0 7
124025: ARRAY
124026: PPUSH
124027: LD_VAR 0 14
124031: PUSH
124032: LD_INT 1
124034: ARRAY
124035: PPUSH
124036: CALL_OW 115
// if not HasTask ( group [ i ] ) then
124040: LD_VAR 0 4
124044: PUSH
124045: LD_VAR 0 7
124049: ARRAY
124050: PPUSH
124051: CALL_OW 314
124055: NOT
124056: IFFALSE 124094
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
124058: LD_VAR 0 4
124062: PUSH
124063: LD_VAR 0 7
124067: ARRAY
124068: PPUSH
124069: LD_VAR 0 14
124073: PPUSH
124074: LD_VAR 0 4
124078: PUSH
124079: LD_VAR 0 7
124083: ARRAY
124084: PPUSH
124085: CALL_OW 74
124089: PPUSH
124090: CALL_OW 115
// end ; end ; end ;
124094: GO 119973
124096: POP
124097: POP
// wait ( 0 0$2 ) ;
124098: LD_INT 70
124100: PPUSH
124101: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
124105: LD_VAR 0 4
124109: NOT
124110: PUSH
124111: LD_VAR 0 4
124115: PUSH
124116: EMPTY
124117: EQUAL
124118: OR
124119: PUSH
124120: LD_INT 81
124122: PUSH
124123: LD_VAR 0 35
124127: PUSH
124128: EMPTY
124129: LIST
124130: LIST
124131: PPUSH
124132: CALL_OW 69
124136: NOT
124137: OR
124138: IFFALSE 119958
// end ;
124140: LD_VAR 0 2
124144: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
124145: LD_INT 0
124147: PPUSH
124148: PPUSH
124149: PPUSH
124150: PPUSH
124151: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
124152: LD_VAR 0 1
124156: NOT
124157: PUSH
124158: LD_EXP 113
124162: PUSH
124163: LD_VAR 0 1
124167: ARRAY
124168: NOT
124169: OR
124170: PUSH
124171: LD_VAR 0 2
124175: NOT
124176: OR
124177: PUSH
124178: LD_VAR 0 3
124182: NOT
124183: OR
124184: IFFALSE 124188
// exit ;
124186: GO 124701
// side := mc_sides [ base ] ;
124188: LD_ADDR_VAR 0 6
124192: PUSH
124193: LD_EXP 139
124197: PUSH
124198: LD_VAR 0 1
124202: ARRAY
124203: ST_TO_ADDR
// if not side then
124204: LD_VAR 0 6
124208: NOT
124209: IFFALSE 124213
// exit ;
124211: GO 124701
// for i in solds do
124213: LD_ADDR_VAR 0 7
124217: PUSH
124218: LD_VAR 0 2
124222: PUSH
124223: FOR_IN
124224: IFFALSE 124285
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
124226: LD_VAR 0 7
124230: PPUSH
124231: CALL_OW 310
124235: PPUSH
124236: CALL_OW 266
124240: PUSH
124241: LD_INT 32
124243: PUSH
124244: LD_INT 31
124246: PUSH
124247: EMPTY
124248: LIST
124249: LIST
124250: IN
124251: IFFALSE 124271
// solds := solds diff i else
124253: LD_ADDR_VAR 0 2
124257: PUSH
124258: LD_VAR 0 2
124262: PUSH
124263: LD_VAR 0 7
124267: DIFF
124268: ST_TO_ADDR
124269: GO 124283
// SetTag ( i , 18 ) ;
124271: LD_VAR 0 7
124275: PPUSH
124276: LD_INT 18
124278: PPUSH
124279: CALL_OW 109
124283: GO 124223
124285: POP
124286: POP
// if not solds then
124287: LD_VAR 0 2
124291: NOT
124292: IFFALSE 124296
// exit ;
124294: GO 124701
// repeat wait ( 0 0$2 ) ;
124296: LD_INT 70
124298: PPUSH
124299: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
124303: LD_ADDR_VAR 0 5
124307: PUSH
124308: LD_VAR 0 6
124312: PPUSH
124313: LD_VAR 0 3
124317: PPUSH
124318: CALL 66958 0 2
124322: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124323: LD_EXP 113
124327: PUSH
124328: LD_VAR 0 1
124332: ARRAY
124333: NOT
124334: PUSH
124335: LD_EXP 113
124339: PUSH
124340: LD_VAR 0 1
124344: ARRAY
124345: PUSH
124346: EMPTY
124347: EQUAL
124348: OR
124349: IFFALSE 124386
// begin for i in solds do
124351: LD_ADDR_VAR 0 7
124355: PUSH
124356: LD_VAR 0 2
124360: PUSH
124361: FOR_IN
124362: IFFALSE 124375
// ComStop ( i ) ;
124364: LD_VAR 0 7
124368: PPUSH
124369: CALL_OW 141
124373: GO 124361
124375: POP
124376: POP
// solds := [ ] ;
124377: LD_ADDR_VAR 0 2
124381: PUSH
124382: EMPTY
124383: ST_TO_ADDR
// exit ;
124384: GO 124701
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
124386: LD_VAR 0 5
124390: NOT
124391: PUSH
124392: LD_VAR 0 5
124396: PUSH
124397: LD_INT 3
124399: GREATER
124400: OR
124401: PUSH
124402: LD_EXP 135
124406: PUSH
124407: LD_VAR 0 1
124411: ARRAY
124412: OR
124413: IFFALSE 124454
// begin for i in solds do
124415: LD_ADDR_VAR 0 7
124419: PUSH
124420: LD_VAR 0 2
124424: PUSH
124425: FOR_IN
124426: IFFALSE 124450
// if HasTask ( i ) then
124428: LD_VAR 0 7
124432: PPUSH
124433: CALL_OW 314
124437: IFFALSE 124448
// ComStop ( i ) ;
124439: LD_VAR 0 7
124443: PPUSH
124444: CALL_OW 141
124448: GO 124425
124450: POP
124451: POP
// break ;
124452: GO 124689
// end ; for i in solds do
124454: LD_ADDR_VAR 0 7
124458: PUSH
124459: LD_VAR 0 2
124463: PUSH
124464: FOR_IN
124465: IFFALSE 124681
// begin if IsInUnit ( i ) then
124467: LD_VAR 0 7
124471: PPUSH
124472: CALL_OW 310
124476: IFFALSE 124487
// ComExitBuilding ( i ) ;
124478: LD_VAR 0 7
124482: PPUSH
124483: CALL_OW 122
// if GetLives ( i ) > 333 then
124487: LD_VAR 0 7
124491: PPUSH
124492: CALL_OW 256
124496: PUSH
124497: LD_INT 333
124499: GREATER
124500: IFFALSE 124528
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
124502: LD_VAR 0 7
124506: PPUSH
124507: LD_VAR 0 5
124511: PPUSH
124512: LD_VAR 0 7
124516: PPUSH
124517: CALL_OW 74
124521: PPUSH
124522: CALL_OW 115
124526: GO 124679
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
124528: LD_ADDR_VAR 0 8
124532: PUSH
124533: LD_EXP 113
124537: PUSH
124538: LD_VAR 0 1
124542: ARRAY
124543: PPUSH
124544: LD_INT 2
124546: PUSH
124547: LD_INT 30
124549: PUSH
124550: LD_INT 0
124552: PUSH
124553: EMPTY
124554: LIST
124555: LIST
124556: PUSH
124557: LD_INT 30
124559: PUSH
124560: LD_INT 1
124562: PUSH
124563: EMPTY
124564: LIST
124565: LIST
124566: PUSH
124567: LD_INT 30
124569: PUSH
124570: LD_INT 6
124572: PUSH
124573: EMPTY
124574: LIST
124575: LIST
124576: PUSH
124577: EMPTY
124578: LIST
124579: LIST
124580: LIST
124581: LIST
124582: PPUSH
124583: CALL_OW 72
124587: PPUSH
124588: LD_VAR 0 7
124592: PPUSH
124593: CALL_OW 74
124597: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
124598: LD_VAR 0 7
124602: PPUSH
124603: LD_VAR 0 8
124607: PPUSH
124608: CALL_OW 250
124612: PPUSH
124613: LD_INT 3
124615: PPUSH
124616: LD_INT 5
124618: PPUSH
124619: CALL_OW 272
124623: PPUSH
124624: LD_VAR 0 8
124628: PPUSH
124629: CALL_OW 251
124633: PPUSH
124634: LD_INT 3
124636: PPUSH
124637: LD_INT 5
124639: PPUSH
124640: CALL_OW 273
124644: PPUSH
124645: CALL_OW 111
// SetTag ( i , 0 ) ;
124649: LD_VAR 0 7
124653: PPUSH
124654: LD_INT 0
124656: PPUSH
124657: CALL_OW 109
// solds := solds diff i ;
124661: LD_ADDR_VAR 0 2
124665: PUSH
124666: LD_VAR 0 2
124670: PUSH
124671: LD_VAR 0 7
124675: DIFF
124676: ST_TO_ADDR
// continue ;
124677: GO 124464
// end ; end ;
124679: GO 124464
124681: POP
124682: POP
// until solds ;
124683: LD_VAR 0 2
124687: IFFALSE 124296
// MC_Reset ( base , 18 ) ;
124689: LD_VAR 0 1
124693: PPUSH
124694: LD_INT 18
124696: PPUSH
124697: CALL 39199 0 2
// end ;
124701: LD_VAR 0 4
124705: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
124706: LD_INT 0
124708: PPUSH
124709: PPUSH
124710: PPUSH
124711: PPUSH
124712: PPUSH
124713: PPUSH
124714: PPUSH
124715: PPUSH
124716: PPUSH
124717: PPUSH
124718: PPUSH
124719: PPUSH
124720: PPUSH
124721: PPUSH
124722: PPUSH
124723: PPUSH
124724: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
124725: LD_ADDR_VAR 0 13
124729: PUSH
124730: LD_EXP 113
124734: PUSH
124735: LD_VAR 0 1
124739: ARRAY
124740: PPUSH
124741: LD_INT 25
124743: PUSH
124744: LD_INT 3
124746: PUSH
124747: EMPTY
124748: LIST
124749: LIST
124750: PPUSH
124751: CALL_OW 72
124755: ST_TO_ADDR
// if mc_remote_driver [ base ] then
124756: LD_EXP 153
124760: PUSH
124761: LD_VAR 0 1
124765: ARRAY
124766: IFFALSE 124790
// mechs := mechs diff mc_remote_driver [ base ] ;
124768: LD_ADDR_VAR 0 13
124772: PUSH
124773: LD_VAR 0 13
124777: PUSH
124778: LD_EXP 153
124782: PUSH
124783: LD_VAR 0 1
124787: ARRAY
124788: DIFF
124789: ST_TO_ADDR
// for i in mechs do
124790: LD_ADDR_VAR 0 5
124794: PUSH
124795: LD_VAR 0 13
124799: PUSH
124800: FOR_IN
124801: IFFALSE 124836
// if GetTag ( i ) > 0 then
124803: LD_VAR 0 5
124807: PPUSH
124808: CALL_OW 110
124812: PUSH
124813: LD_INT 0
124815: GREATER
124816: IFFALSE 124834
// mechs := mechs diff i ;
124818: LD_ADDR_VAR 0 13
124822: PUSH
124823: LD_VAR 0 13
124827: PUSH
124828: LD_VAR 0 5
124832: DIFF
124833: ST_TO_ADDR
124834: GO 124800
124836: POP
124837: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
124838: LD_ADDR_VAR 0 9
124842: PUSH
124843: LD_EXP 113
124847: PUSH
124848: LD_VAR 0 1
124852: ARRAY
124853: PPUSH
124854: LD_INT 2
124856: PUSH
124857: LD_INT 25
124859: PUSH
124860: LD_INT 1
124862: PUSH
124863: EMPTY
124864: LIST
124865: LIST
124866: PUSH
124867: LD_INT 25
124869: PUSH
124870: LD_INT 5
124872: PUSH
124873: EMPTY
124874: LIST
124875: LIST
124876: PUSH
124877: LD_INT 25
124879: PUSH
124880: LD_INT 8
124882: PUSH
124883: EMPTY
124884: LIST
124885: LIST
124886: PUSH
124887: LD_INT 25
124889: PUSH
124890: LD_INT 9
124892: PUSH
124893: EMPTY
124894: LIST
124895: LIST
124896: PUSH
124897: EMPTY
124898: LIST
124899: LIST
124900: LIST
124901: LIST
124902: LIST
124903: PPUSH
124904: CALL_OW 72
124908: ST_TO_ADDR
// if not defenders and not solds then
124909: LD_VAR 0 2
124913: NOT
124914: PUSH
124915: LD_VAR 0 9
124919: NOT
124920: AND
124921: IFFALSE 124925
// exit ;
124923: GO 126615
// depot_under_attack := false ;
124925: LD_ADDR_VAR 0 17
124929: PUSH
124930: LD_INT 0
124932: ST_TO_ADDR
// sold_defenders := [ ] ;
124933: LD_ADDR_VAR 0 18
124937: PUSH
124938: EMPTY
124939: ST_TO_ADDR
// if mechs then
124940: LD_VAR 0 13
124944: IFFALSE 125097
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
124946: LD_ADDR_VAR 0 5
124950: PUSH
124951: LD_VAR 0 2
124955: PPUSH
124956: LD_INT 21
124958: PUSH
124959: LD_INT 2
124961: PUSH
124962: EMPTY
124963: LIST
124964: LIST
124965: PPUSH
124966: CALL_OW 72
124970: PUSH
124971: FOR_IN
124972: IFFALSE 125095
// begin if GetTag ( i ) <> 20 then
124974: LD_VAR 0 5
124978: PPUSH
124979: CALL_OW 110
124983: PUSH
124984: LD_INT 20
124986: NONEQUAL
124987: IFFALSE 125001
// SetTag ( i , 20 ) ;
124989: LD_VAR 0 5
124993: PPUSH
124994: LD_INT 20
124996: PPUSH
124997: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
125001: LD_VAR 0 5
125005: PPUSH
125006: CALL_OW 263
125010: PUSH
125011: LD_INT 1
125013: EQUAL
125014: PUSH
125015: LD_VAR 0 5
125019: PPUSH
125020: CALL_OW 311
125024: NOT
125025: AND
125026: IFFALSE 125093
// begin un := mechs [ 1 ] ;
125028: LD_ADDR_VAR 0 11
125032: PUSH
125033: LD_VAR 0 13
125037: PUSH
125038: LD_INT 1
125040: ARRAY
125041: ST_TO_ADDR
// ComExit ( un ) ;
125042: LD_VAR 0 11
125046: PPUSH
125047: CALL 101588 0 1
// AddComEnterUnit ( un , i ) ;
125051: LD_VAR 0 11
125055: PPUSH
125056: LD_VAR 0 5
125060: PPUSH
125061: CALL_OW 180
// SetTag ( un , 19 ) ;
125065: LD_VAR 0 11
125069: PPUSH
125070: LD_INT 19
125072: PPUSH
125073: CALL_OW 109
// mechs := mechs diff un ;
125077: LD_ADDR_VAR 0 13
125081: PUSH
125082: LD_VAR 0 13
125086: PUSH
125087: LD_VAR 0 11
125091: DIFF
125092: ST_TO_ADDR
// end ; end ;
125093: GO 124971
125095: POP
125096: POP
// if solds then
125097: LD_VAR 0 9
125101: IFFALSE 125160
// for i in solds do
125103: LD_ADDR_VAR 0 5
125107: PUSH
125108: LD_VAR 0 9
125112: PUSH
125113: FOR_IN
125114: IFFALSE 125158
// if not GetTag ( i ) then
125116: LD_VAR 0 5
125120: PPUSH
125121: CALL_OW 110
125125: NOT
125126: IFFALSE 125156
// begin defenders := defenders union i ;
125128: LD_ADDR_VAR 0 2
125132: PUSH
125133: LD_VAR 0 2
125137: PUSH
125138: LD_VAR 0 5
125142: UNION
125143: ST_TO_ADDR
// SetTag ( i , 18 ) ;
125144: LD_VAR 0 5
125148: PPUSH
125149: LD_INT 18
125151: PPUSH
125152: CALL_OW 109
// end ;
125156: GO 125113
125158: POP
125159: POP
// repeat wait ( 0 0$2 ) ;
125160: LD_INT 70
125162: PPUSH
125163: CALL_OW 67
// enemy := mc_scan [ base ] ;
125167: LD_ADDR_VAR 0 3
125171: PUSH
125172: LD_EXP 136
125176: PUSH
125177: LD_VAR 0 1
125181: ARRAY
125182: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125183: LD_EXP 113
125187: PUSH
125188: LD_VAR 0 1
125192: ARRAY
125193: NOT
125194: PUSH
125195: LD_EXP 113
125199: PUSH
125200: LD_VAR 0 1
125204: ARRAY
125205: PUSH
125206: EMPTY
125207: EQUAL
125208: OR
125209: IFFALSE 125246
// begin for i in defenders do
125211: LD_ADDR_VAR 0 5
125215: PUSH
125216: LD_VAR 0 2
125220: PUSH
125221: FOR_IN
125222: IFFALSE 125235
// ComStop ( i ) ;
125224: LD_VAR 0 5
125228: PPUSH
125229: CALL_OW 141
125233: GO 125221
125235: POP
125236: POP
// defenders := [ ] ;
125237: LD_ADDR_VAR 0 2
125241: PUSH
125242: EMPTY
125243: ST_TO_ADDR
// exit ;
125244: GO 126615
// end ; for i in defenders do
125246: LD_ADDR_VAR 0 5
125250: PUSH
125251: LD_VAR 0 2
125255: PUSH
125256: FOR_IN
125257: IFFALSE 126075
// begin e := NearestUnitToUnit ( enemy , i ) ;
125259: LD_ADDR_VAR 0 14
125263: PUSH
125264: LD_VAR 0 3
125268: PPUSH
125269: LD_VAR 0 5
125273: PPUSH
125274: CALL_OW 74
125278: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
125279: LD_ADDR_VAR 0 8
125283: PUSH
125284: LD_EXP 113
125288: PUSH
125289: LD_VAR 0 1
125293: ARRAY
125294: PPUSH
125295: LD_INT 2
125297: PUSH
125298: LD_INT 30
125300: PUSH
125301: LD_INT 0
125303: PUSH
125304: EMPTY
125305: LIST
125306: LIST
125307: PUSH
125308: LD_INT 30
125310: PUSH
125311: LD_INT 1
125313: PUSH
125314: EMPTY
125315: LIST
125316: LIST
125317: PUSH
125318: EMPTY
125319: LIST
125320: LIST
125321: LIST
125322: PPUSH
125323: CALL_OW 72
125327: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
125328: LD_ADDR_VAR 0 17
125332: PUSH
125333: LD_VAR 0 8
125337: NOT
125338: PUSH
125339: LD_VAR 0 8
125343: PPUSH
125344: LD_INT 3
125346: PUSH
125347: LD_INT 24
125349: PUSH
125350: LD_INT 600
125352: PUSH
125353: EMPTY
125354: LIST
125355: LIST
125356: PUSH
125357: EMPTY
125358: LIST
125359: LIST
125360: PPUSH
125361: CALL_OW 72
125365: OR
125366: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
125367: LD_VAR 0 5
125371: PPUSH
125372: CALL_OW 247
125376: PUSH
125377: LD_INT 2
125379: DOUBLE
125380: EQUAL
125381: IFTRUE 125385
125383: GO 125781
125385: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
125386: LD_VAR 0 5
125390: PPUSH
125391: CALL_OW 256
125395: PUSH
125396: LD_INT 650
125398: GREATER
125399: PUSH
125400: LD_VAR 0 5
125404: PPUSH
125405: LD_VAR 0 14
125409: PPUSH
125410: CALL_OW 296
125414: PUSH
125415: LD_INT 40
125417: LESS
125418: PUSH
125419: LD_VAR 0 14
125423: PPUSH
125424: LD_EXP 138
125428: PUSH
125429: LD_VAR 0 1
125433: ARRAY
125434: PPUSH
125435: CALL_OW 308
125439: OR
125440: AND
125441: IFFALSE 125563
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
125443: LD_VAR 0 5
125447: PPUSH
125448: CALL_OW 262
125452: PUSH
125453: LD_INT 1
125455: EQUAL
125456: PUSH
125457: LD_VAR 0 5
125461: PPUSH
125462: CALL_OW 261
125466: PUSH
125467: LD_INT 30
125469: LESS
125470: AND
125471: PUSH
125472: LD_VAR 0 8
125476: AND
125477: IFFALSE 125547
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
125479: LD_VAR 0 5
125483: PPUSH
125484: LD_VAR 0 8
125488: PPUSH
125489: LD_VAR 0 5
125493: PPUSH
125494: CALL_OW 74
125498: PPUSH
125499: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
125503: LD_VAR 0 5
125507: PPUSH
125508: LD_VAR 0 8
125512: PPUSH
125513: LD_VAR 0 5
125517: PPUSH
125518: CALL_OW 74
125522: PPUSH
125523: CALL_OW 296
125527: PUSH
125528: LD_INT 6
125530: LESS
125531: IFFALSE 125545
// SetFuel ( i , 100 ) ;
125533: LD_VAR 0 5
125537: PPUSH
125538: LD_INT 100
125540: PPUSH
125541: CALL_OW 240
// end else
125545: GO 125561
// ComAttackUnit ( i , e ) ;
125547: LD_VAR 0 5
125551: PPUSH
125552: LD_VAR 0 14
125556: PPUSH
125557: CALL_OW 115
// end else
125561: GO 125664
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
125563: LD_VAR 0 14
125567: PPUSH
125568: LD_EXP 138
125572: PUSH
125573: LD_VAR 0 1
125577: ARRAY
125578: PPUSH
125579: CALL_OW 308
125583: NOT
125584: PUSH
125585: LD_VAR 0 5
125589: PPUSH
125590: LD_VAR 0 14
125594: PPUSH
125595: CALL_OW 296
125599: PUSH
125600: LD_INT 40
125602: GREATEREQUAL
125603: AND
125604: PUSH
125605: LD_VAR 0 5
125609: PPUSH
125610: CALL_OW 256
125614: PUSH
125615: LD_INT 650
125617: LESSEQUAL
125618: OR
125619: PUSH
125620: LD_VAR 0 5
125624: PPUSH
125625: LD_EXP 137
125629: PUSH
125630: LD_VAR 0 1
125634: ARRAY
125635: PPUSH
125636: CALL_OW 308
125640: NOT
125641: AND
125642: IFFALSE 125664
// ComMoveToArea ( i , mc_parking [ base ] ) ;
125644: LD_VAR 0 5
125648: PPUSH
125649: LD_EXP 137
125653: PUSH
125654: LD_VAR 0 1
125658: ARRAY
125659: PPUSH
125660: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
125664: LD_VAR 0 5
125668: PPUSH
125669: CALL_OW 256
125673: PUSH
125674: LD_INT 998
125676: LESS
125677: PUSH
125678: LD_VAR 0 5
125682: PPUSH
125683: CALL_OW 263
125687: PUSH
125688: LD_INT 1
125690: EQUAL
125691: AND
125692: PUSH
125693: LD_VAR 0 5
125697: PPUSH
125698: CALL_OW 311
125702: AND
125703: PUSH
125704: LD_VAR 0 5
125708: PPUSH
125709: LD_EXP 137
125713: PUSH
125714: LD_VAR 0 1
125718: ARRAY
125719: PPUSH
125720: CALL_OW 308
125724: AND
125725: IFFALSE 125779
// begin mech := IsDrivenBy ( i ) ;
125727: LD_ADDR_VAR 0 10
125731: PUSH
125732: LD_VAR 0 5
125736: PPUSH
125737: CALL_OW 311
125741: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
125742: LD_VAR 0 10
125746: PPUSH
125747: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
125751: LD_VAR 0 10
125755: PPUSH
125756: LD_VAR 0 5
125760: PPUSH
125761: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
125765: LD_VAR 0 10
125769: PPUSH
125770: LD_VAR 0 5
125774: PPUSH
125775: CALL_OW 180
// end ; end ; unit_human :
125779: GO 126046
125781: LD_INT 1
125783: DOUBLE
125784: EQUAL
125785: IFTRUE 125789
125787: GO 126045
125789: POP
// begin b := IsInUnit ( i ) ;
125790: LD_ADDR_VAR 0 19
125794: PUSH
125795: LD_VAR 0 5
125799: PPUSH
125800: CALL_OW 310
125804: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
125805: LD_ADDR_VAR 0 20
125809: PUSH
125810: LD_VAR 0 19
125814: NOT
125815: PUSH
125816: LD_VAR 0 19
125820: PPUSH
125821: CALL_OW 266
125825: PUSH
125826: LD_INT 32
125828: PUSH
125829: LD_INT 31
125831: PUSH
125832: EMPTY
125833: LIST
125834: LIST
125835: IN
125836: OR
125837: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
125838: LD_VAR 0 17
125842: PUSH
125843: LD_VAR 0 2
125847: PPUSH
125848: LD_INT 21
125850: PUSH
125851: LD_INT 2
125853: PUSH
125854: EMPTY
125855: LIST
125856: LIST
125857: PPUSH
125858: CALL_OW 72
125862: PUSH
125863: LD_INT 1
125865: LESSEQUAL
125866: OR
125867: PUSH
125868: LD_VAR 0 20
125872: AND
125873: PUSH
125874: LD_VAR 0 5
125878: PUSH
125879: LD_VAR 0 18
125883: IN
125884: NOT
125885: AND
125886: IFFALSE 125979
// begin if b then
125888: LD_VAR 0 19
125892: IFFALSE 125941
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
125894: LD_VAR 0 19
125898: PPUSH
125899: LD_VAR 0 3
125903: PPUSH
125904: LD_VAR 0 19
125908: PPUSH
125909: CALL_OW 74
125913: PPUSH
125914: CALL_OW 296
125918: PUSH
125919: LD_INT 10
125921: LESS
125922: PUSH
125923: LD_VAR 0 19
125927: PPUSH
125928: CALL_OW 461
125932: PUSH
125933: LD_INT 7
125935: NONEQUAL
125936: AND
125937: IFFALSE 125941
// continue ;
125939: GO 125256
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
125941: LD_ADDR_VAR 0 18
125945: PUSH
125946: LD_VAR 0 18
125950: PPUSH
125951: LD_VAR 0 18
125955: PUSH
125956: LD_INT 1
125958: PLUS
125959: PPUSH
125960: LD_VAR 0 5
125964: PPUSH
125965: CALL_OW 1
125969: ST_TO_ADDR
// ComExitBuilding ( i ) ;
125970: LD_VAR 0 5
125974: PPUSH
125975: CALL_OW 122
// end ; if sold_defenders then
125979: LD_VAR 0 18
125983: IFFALSE 126043
// if i in sold_defenders then
125985: LD_VAR 0 5
125989: PUSH
125990: LD_VAR 0 18
125994: IN
125995: IFFALSE 126043
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
125997: LD_VAR 0 5
126001: PPUSH
126002: CALL_OW 314
126006: NOT
126007: PUSH
126008: LD_VAR 0 5
126012: PPUSH
126013: LD_VAR 0 14
126017: PPUSH
126018: CALL_OW 296
126022: PUSH
126023: LD_INT 30
126025: LESS
126026: AND
126027: IFFALSE 126043
// ComAttackUnit ( i , e ) ;
126029: LD_VAR 0 5
126033: PPUSH
126034: LD_VAR 0 14
126038: PPUSH
126039: CALL_OW 115
// end ; end ; end ;
126043: GO 126046
126045: POP
// if IsDead ( i ) then
126046: LD_VAR 0 5
126050: PPUSH
126051: CALL_OW 301
126055: IFFALSE 126073
// defenders := defenders diff i ;
126057: LD_ADDR_VAR 0 2
126061: PUSH
126062: LD_VAR 0 2
126066: PUSH
126067: LD_VAR 0 5
126071: DIFF
126072: ST_TO_ADDR
// end ;
126073: GO 125256
126075: POP
126076: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
126077: LD_VAR 0 3
126081: NOT
126082: PUSH
126083: LD_VAR 0 2
126087: NOT
126088: OR
126089: PUSH
126090: LD_EXP 113
126094: PUSH
126095: LD_VAR 0 1
126099: ARRAY
126100: NOT
126101: OR
126102: IFFALSE 125160
// MC_Reset ( base , 18 ) ;
126104: LD_VAR 0 1
126108: PPUSH
126109: LD_INT 18
126111: PPUSH
126112: CALL 39199 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
126116: LD_ADDR_VAR 0 2
126120: PUSH
126121: LD_VAR 0 2
126125: PUSH
126126: LD_VAR 0 2
126130: PPUSH
126131: LD_INT 2
126133: PUSH
126134: LD_INT 25
126136: PUSH
126137: LD_INT 1
126139: PUSH
126140: EMPTY
126141: LIST
126142: LIST
126143: PUSH
126144: LD_INT 25
126146: PUSH
126147: LD_INT 5
126149: PUSH
126150: EMPTY
126151: LIST
126152: LIST
126153: PUSH
126154: LD_INT 25
126156: PUSH
126157: LD_INT 8
126159: PUSH
126160: EMPTY
126161: LIST
126162: LIST
126163: PUSH
126164: LD_INT 25
126166: PUSH
126167: LD_INT 9
126169: PUSH
126170: EMPTY
126171: LIST
126172: LIST
126173: PUSH
126174: EMPTY
126175: LIST
126176: LIST
126177: LIST
126178: LIST
126179: LIST
126180: PPUSH
126181: CALL_OW 72
126185: DIFF
126186: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
126187: LD_VAR 0 3
126191: NOT
126192: PUSH
126193: LD_VAR 0 2
126197: PPUSH
126198: LD_INT 21
126200: PUSH
126201: LD_INT 2
126203: PUSH
126204: EMPTY
126205: LIST
126206: LIST
126207: PPUSH
126208: CALL_OW 72
126212: AND
126213: IFFALSE 126551
// begin tmp := FilterByTag ( defenders , 19 ) ;
126215: LD_ADDR_VAR 0 12
126219: PUSH
126220: LD_VAR 0 2
126224: PPUSH
126225: LD_INT 19
126227: PPUSH
126228: CALL 98718 0 2
126232: ST_TO_ADDR
// if tmp then
126233: LD_VAR 0 12
126237: IFFALSE 126307
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
126239: LD_ADDR_VAR 0 12
126243: PUSH
126244: LD_VAR 0 12
126248: PPUSH
126249: LD_INT 25
126251: PUSH
126252: LD_INT 3
126254: PUSH
126255: EMPTY
126256: LIST
126257: LIST
126258: PPUSH
126259: CALL_OW 72
126263: ST_TO_ADDR
// if tmp then
126264: LD_VAR 0 12
126268: IFFALSE 126307
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
126270: LD_ADDR_EXP 125
126274: PUSH
126275: LD_EXP 125
126279: PPUSH
126280: LD_VAR 0 1
126284: PPUSH
126285: LD_EXP 125
126289: PUSH
126290: LD_VAR 0 1
126294: ARRAY
126295: PUSH
126296: LD_VAR 0 12
126300: UNION
126301: PPUSH
126302: CALL_OW 1
126306: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
126307: LD_VAR 0 1
126311: PPUSH
126312: LD_INT 19
126314: PPUSH
126315: CALL 39199 0 2
// repeat wait ( 0 0$1 ) ;
126319: LD_INT 35
126321: PPUSH
126322: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126326: LD_EXP 113
126330: PUSH
126331: LD_VAR 0 1
126335: ARRAY
126336: NOT
126337: PUSH
126338: LD_EXP 113
126342: PUSH
126343: LD_VAR 0 1
126347: ARRAY
126348: PUSH
126349: EMPTY
126350: EQUAL
126351: OR
126352: IFFALSE 126389
// begin for i in defenders do
126354: LD_ADDR_VAR 0 5
126358: PUSH
126359: LD_VAR 0 2
126363: PUSH
126364: FOR_IN
126365: IFFALSE 126378
// ComStop ( i ) ;
126367: LD_VAR 0 5
126371: PPUSH
126372: CALL_OW 141
126376: GO 126364
126378: POP
126379: POP
// defenders := [ ] ;
126380: LD_ADDR_VAR 0 2
126384: PUSH
126385: EMPTY
126386: ST_TO_ADDR
// exit ;
126387: GO 126615
// end ; for i in defenders do
126389: LD_ADDR_VAR 0 5
126393: PUSH
126394: LD_VAR 0 2
126398: PUSH
126399: FOR_IN
126400: IFFALSE 126489
// begin if not IsInArea ( i , mc_parking [ base ] ) then
126402: LD_VAR 0 5
126406: PPUSH
126407: LD_EXP 137
126411: PUSH
126412: LD_VAR 0 1
126416: ARRAY
126417: PPUSH
126418: CALL_OW 308
126422: NOT
126423: IFFALSE 126447
// ComMoveToArea ( i , mc_parking [ base ] ) else
126425: LD_VAR 0 5
126429: PPUSH
126430: LD_EXP 137
126434: PUSH
126435: LD_VAR 0 1
126439: ARRAY
126440: PPUSH
126441: CALL_OW 113
126445: GO 126487
// if GetControl ( i ) = control_manual then
126447: LD_VAR 0 5
126451: PPUSH
126452: CALL_OW 263
126456: PUSH
126457: LD_INT 1
126459: EQUAL
126460: IFFALSE 126487
// if IsDrivenBy ( i ) then
126462: LD_VAR 0 5
126466: PPUSH
126467: CALL_OW 311
126471: IFFALSE 126487
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
126473: LD_VAR 0 5
126477: PPUSH
126478: CALL_OW 311
126482: PPUSH
126483: CALL_OW 121
// end ;
126487: GO 126399
126489: POP
126490: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
126491: LD_VAR 0 2
126495: PPUSH
126496: LD_INT 95
126498: PUSH
126499: LD_EXP 137
126503: PUSH
126504: LD_VAR 0 1
126508: ARRAY
126509: PUSH
126510: EMPTY
126511: LIST
126512: LIST
126513: PPUSH
126514: CALL_OW 72
126518: PUSH
126519: LD_VAR 0 2
126523: EQUAL
126524: PUSH
126525: LD_EXP 136
126529: PUSH
126530: LD_VAR 0 1
126534: ARRAY
126535: OR
126536: PUSH
126537: LD_EXP 113
126541: PUSH
126542: LD_VAR 0 1
126546: ARRAY
126547: NOT
126548: OR
126549: IFFALSE 126319
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
126551: LD_ADDR_EXP 135
126555: PUSH
126556: LD_EXP 135
126560: PPUSH
126561: LD_VAR 0 1
126565: PPUSH
126566: LD_VAR 0 2
126570: PPUSH
126571: LD_INT 21
126573: PUSH
126574: LD_INT 2
126576: PUSH
126577: EMPTY
126578: LIST
126579: LIST
126580: PPUSH
126581: CALL_OW 72
126585: PPUSH
126586: CALL_OW 1
126590: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
126591: LD_VAR 0 1
126595: PPUSH
126596: LD_INT 19
126598: PPUSH
126599: CALL 39199 0 2
// MC_Reset ( base , 20 ) ;
126603: LD_VAR 0 1
126607: PPUSH
126608: LD_INT 20
126610: PPUSH
126611: CALL 39199 0 2
// end ; end_of_file
126615: LD_VAR 0 4
126619: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
126620: LD_VAR 0 1
126624: PUSH
126625: LD_INT 200
126627: DOUBLE
126628: GREATEREQUAL
126629: IFFALSE 126637
126631: LD_INT 299
126633: DOUBLE
126634: LESSEQUAL
126635: IFTRUE 126639
126637: GO 126671
126639: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
126640: LD_VAR 0 1
126644: PPUSH
126645: LD_VAR 0 2
126649: PPUSH
126650: LD_VAR 0 3
126654: PPUSH
126655: LD_VAR 0 4
126659: PPUSH
126660: LD_VAR 0 5
126664: PPUSH
126665: CALL 115561 0 5
126669: GO 126748
126671: LD_INT 300
126673: DOUBLE
126674: GREATEREQUAL
126675: IFFALSE 126683
126677: LD_INT 399
126679: DOUBLE
126680: LESSEQUAL
126681: IFTRUE 126685
126683: GO 126747
126685: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
126686: LD_VAR 0 1
126690: PPUSH
126691: LD_VAR 0 2
126695: PPUSH
126696: LD_VAR 0 3
126700: PPUSH
126701: LD_VAR 0 4
126705: PPUSH
126706: LD_VAR 0 5
126710: PPUSH
126711: LD_VAR 0 6
126715: PPUSH
126716: LD_VAR 0 7
126720: PPUSH
126721: LD_VAR 0 8
126725: PPUSH
126726: LD_VAR 0 9
126730: PPUSH
126731: LD_VAR 0 10
126735: PPUSH
126736: LD_VAR 0 11
126740: PPUSH
126741: CALL 113467 0 11
126745: GO 126748
126747: POP
// end ;
126748: PPOPN 11
126750: END
