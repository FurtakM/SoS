// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36872 0 0
// InitNature ;
  19: CALL 36740 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11915 0 0
// PrepareRussian ;
  40: CALL 7187 0 0
// PrepareLegion ;
  44: CALL 4342 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15994 0 0
// MC_Start ( ) ;
  60: CALL 39044 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 124
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 125
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61842 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61935 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 61285 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 61100 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61842 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61935 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 61100 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 61285 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61715 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60782 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61842 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61935 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 129
 971: PUSH
 972: LD_EXP 129
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 61100 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61842 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61935 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 60992 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 62253 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61424 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61715 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61715 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 62047 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 61100 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61666 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67536 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72551 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72551 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72551 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72551 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72551 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67536 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67536 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67536 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67536 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 67536 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 67536 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 67536 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 67536 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 67536 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 67536 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 67536 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 67536 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 67536 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 67536 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 67536 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3159: LD_ADDR_EXP 60
3163: PUSH
3164: LD_STRING Powell
3166: PPUSH
3167: CALL_OW 25
3171: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3172: LD_EXP 60
3176: PPUSH
3177: LD_INT 57
3179: PPUSH
3180: LD_INT 94
3182: PPUSH
3183: LD_INT 0
3185: PPUSH
3186: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3190: LD_EXP 60
3194: PPUSH
3195: LD_INT 58
3197: PPUSH
3198: LD_INT 94
3200: PPUSH
3201: CALL_OW 118
// vip := [ ] ;
3205: LD_ADDR_EXP 61
3209: PUSH
3210: EMPTY
3211: ST_TO_ADDR
// tmp := [ ] ;
3212: LD_ADDR_VAR 0 5
3216: PUSH
3217: EMPTY
3218: ST_TO_ADDR
// if JMMGirl <> 2 then
3219: LD_EXP 7
3223: PUSH
3224: LD_INT 2
3226: NONEQUAL
3227: IFFALSE 3251
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3229: LD_ADDR_EXP 43
3233: PUSH
3234: LD_STRING Lisa
3236: PPUSH
3237: LD_EXP 1
3241: NOT
3242: PPUSH
3243: LD_STRING 13s_
3245: PPUSH
3246: CALL 67536 0 3
3250: ST_TO_ADDR
// if Lisa then
3251: LD_EXP 43
3255: IFFALSE 3273
// tmp := tmp ^ Lisa ;
3257: LD_ADDR_VAR 0 5
3261: PUSH
3262: LD_VAR 0 5
3266: PUSH
3267: LD_EXP 43
3271: ADD
3272: ST_TO_ADDR
// if JMMGirl < 3 then
3273: LD_EXP 7
3277: PUSH
3278: LD_INT 3
3280: LESS
3281: IFFALSE 3312
// begin Connie := NewCharacter ( Coonie ) ;
3283: LD_ADDR_EXP 55
3287: PUSH
3288: LD_STRING Coonie
3290: PPUSH
3291: CALL_OW 25
3295: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3296: LD_ADDR_VAR 0 5
3300: PUSH
3301: LD_VAR 0 5
3305: PUSH
3306: LD_EXP 55
3310: ADD
3311: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 44
3316: PUSH
3317: LD_STRING Donaldson
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 67536 0 3
3333: ST_TO_ADDR
// if Donaldson then
3334: LD_EXP 44
3338: IFFALSE 3356
// tmp := tmp ^ Donaldson ;
3340: LD_ADDR_VAR 0 5
3344: PUSH
3345: LD_VAR 0 5
3349: PUSH
3350: LD_EXP 44
3354: ADD
3355: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 45
3360: PUSH
3361: LD_STRING Bobby
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 67536 0 3
3377: ST_TO_ADDR
// if Bobby then
3378: LD_EXP 45
3382: IFFALSE 3400
// tmp := tmp ^ Bobby ;
3384: LD_ADDR_VAR 0 5
3388: PUSH
3389: LD_VAR 0 5
3393: PUSH
3394: LD_EXP 45
3398: ADD
3399: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 46
3404: PUSH
3405: LD_STRING Cyrus
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 67536 0 3
3421: ST_TO_ADDR
// if Cyrus then
3422: LD_EXP 46
3426: IFFALSE 3444
// tmp := tmp ^ Cyrus ;
3428: LD_ADDR_VAR 0 5
3432: PUSH
3433: LD_VAR 0 5
3437: PUSH
3438: LD_EXP 46
3442: ADD
3443: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 47
3448: PUSH
3449: LD_STRING Denis
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 67536 0 3
3465: ST_TO_ADDR
// if not Denis then
3466: LD_EXP 47
3470: NOT
3471: IFFALSE 3495
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3473: LD_ADDR_EXP 47
3477: PUSH
3478: LD_STRING Denis
3480: PPUSH
3481: LD_EXP 1
3485: NOT
3486: PPUSH
3487: LD_STRING 13f_
3489: PPUSH
3490: CALL 67536 0 3
3494: ST_TO_ADDR
// if Denis then
3495: LD_EXP 47
3499: IFFALSE 3517
// tmp := tmp ^ Denis ;
3501: LD_ADDR_VAR 0 5
3505: PUSH
3506: LD_VAR 0 5
3510: PUSH
3511: LD_EXP 47
3515: ADD
3516: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3517: LD_ADDR_EXP 48
3521: PUSH
3522: LD_STRING Brown
3524: PPUSH
3525: LD_EXP 1
3529: NOT
3530: PPUSH
3531: LD_STRING 13s_
3533: PPUSH
3534: CALL 67536 0 3
3538: ST_TO_ADDR
// if Brown then
3539: LD_EXP 48
3543: IFFALSE 3561
// tmp := tmp ^ Brown ;
3545: LD_ADDR_VAR 0 5
3549: PUSH
3550: LD_VAR 0 5
3554: PUSH
3555: LD_EXP 48
3559: ADD
3560: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3561: LD_ADDR_EXP 49
3565: PUSH
3566: LD_STRING Gladstone
3568: PPUSH
3569: LD_EXP 1
3573: NOT
3574: PPUSH
3575: LD_STRING 13s_
3577: PPUSH
3578: CALL 67536 0 3
3582: ST_TO_ADDR
// if Gladstone then
3583: LD_EXP 49
3587: IFFALSE 3605
// tmp := tmp ^ Gladstone ;
3589: LD_ADDR_VAR 0 5
3593: PUSH
3594: LD_VAR 0 5
3598: PUSH
3599: LD_EXP 49
3603: ADD
3604: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3605: LD_ADDR_EXP 50
3609: PUSH
3610: LD_STRING Houten
3612: PPUSH
3613: LD_EXP 1
3617: NOT
3618: PPUSH
3619: LD_STRING 13s_
3621: PPUSH
3622: CALL 67536 0 3
3626: ST_TO_ADDR
// if Houten then
3627: LD_EXP 50
3631: IFFALSE 3649
// tmp := tmp ^ Houten ;
3633: LD_ADDR_VAR 0 5
3637: PUSH
3638: LD_VAR 0 5
3642: PUSH
3643: LD_EXP 50
3647: ADD
3648: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3649: LD_ADDR_EXP 51
3653: PUSH
3654: LD_STRING Cornel
3656: PPUSH
3657: LD_EXP 1
3661: NOT
3662: PPUSH
3663: LD_STRING 13s_
3665: PPUSH
3666: CALL 67536 0 3
3670: ST_TO_ADDR
// if Cornel then
3671: LD_EXP 51
3675: IFFALSE 3693
// tmp := tmp ^ Cornel ;
3677: LD_ADDR_VAR 0 5
3681: PUSH
3682: LD_VAR 0 5
3686: PUSH
3687: LD_EXP 51
3691: ADD
3692: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3693: LD_ADDR_EXP 52
3697: PUSH
3698: LD_STRING Gary
3700: PPUSH
3701: LD_EXP 1
3705: NOT
3706: PPUSH
3707: LD_STRING 13s_
3709: PPUSH
3710: CALL 67536 0 3
3714: ST_TO_ADDR
// if Gary then
3715: LD_EXP 52
3719: IFFALSE 3737
// tmp := tmp ^ Gary ;
3721: LD_ADDR_VAR 0 5
3725: PUSH
3726: LD_VAR 0 5
3730: PUSH
3731: LD_EXP 52
3735: ADD
3736: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3737: LD_ADDR_EXP 53
3741: PUSH
3742: LD_STRING Frank
3744: PPUSH
3745: LD_EXP 1
3749: NOT
3750: PPUSH
3751: LD_STRING 13s_
3753: PPUSH
3754: CALL 67536 0 3
3758: ST_TO_ADDR
// if Frank then
3759: LD_EXP 53
3763: IFFALSE 3781
// tmp := tmp ^ Frank ;
3765: LD_ADDR_VAR 0 5
3769: PUSH
3770: LD_VAR 0 5
3774: PUSH
3775: LD_EXP 53
3779: ADD
3780: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3781: LD_ADDR_EXP 54
3785: PUSH
3786: LD_STRING Kikuchi
3788: PPUSH
3789: LD_EXP 1
3793: NOT
3794: PPUSH
3795: LD_STRING 13s_
3797: PPUSH
3798: CALL 67536 0 3
3802: ST_TO_ADDR
// if Kikuchi then
3803: LD_EXP 54
3807: IFFALSE 3825
// tmp := tmp ^ Kikuchi ;
3809: LD_ADDR_VAR 0 5
3813: PUSH
3814: LD_VAR 0 5
3818: PUSH
3819: LD_EXP 54
3823: ADD
3824: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3825: LD_ADDR_EXP 57
3829: PUSH
3830: LD_STRING Mike
3832: PPUSH
3833: LD_EXP 1
3837: NOT
3838: PPUSH
3839: LD_STRING 10c_
3841: PPUSH
3842: CALL 67536 0 3
3846: ST_TO_ADDR
// if Mike then
3847: LD_EXP 57
3851: IFFALSE 3874
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3853: LD_EXP 57
3857: PPUSH
3858: LD_INT 61
3860: PPUSH
3861: LD_INT 89
3863: PPUSH
3864: LD_INT 8
3866: PPUSH
3867: LD_INT 0
3869: PPUSH
3870: CALL_OW 50
// vip := tmp ;
3874: LD_ADDR_EXP 61
3878: PUSH
3879: LD_VAR 0 5
3883: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3884: LD_ADDR_VAR 0 5
3888: PUSH
3889: LD_VAR 0 5
3893: PUSH
3894: LD_STRING 13s_others
3896: PPUSH
3897: CALL_OW 31
3901: UNION
3902: ST_TO_ADDR
// if tmp < 18 then
3903: LD_VAR 0 5
3907: PUSH
3908: LD_INT 18
3910: LESS
3911: IFFALSE 4004
// for i = 1 to 18 - tmp do
3913: LD_ADDR_VAR 0 2
3917: PUSH
3918: DOUBLE
3919: LD_INT 1
3921: DEC
3922: ST_TO_ADDR
3923: LD_INT 18
3925: PUSH
3926: LD_VAR 0 5
3930: MINUS
3931: PUSH
3932: FOR_TO
3933: IFFALSE 4002
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3935: LD_INT 1
3937: PPUSH
3938: LD_VAR 0 2
3942: PUSH
3943: LD_INT 4
3945: MOD
3946: PUSH
3947: LD_INT 1
3949: PLUS
3950: PPUSH
3951: LD_INT 4
3953: PPUSH
3954: CALL_OW 380
// un := CreateHuman ;
3958: LD_ADDR_VAR 0 10
3962: PUSH
3963: CALL_OW 44
3967: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3968: LD_ADDR_VAR 0 5
3972: PUSH
3973: LD_VAR 0 5
3977: PPUSH
3978: LD_VAR 0 10
3982: PPUSH
3983: CALL 104985 0 2
3987: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3988: LD_VAR 0 10
3992: PPUSH
3993: LD_INT 1
3995: PPUSH
3996: CALL_OW 109
// end ;
4000: GO 3932
4002: POP
4003: POP
// depot := HexInfo ( 53 , 94 ) ;
4004: LD_ADDR_VAR 0 6
4008: PUSH
4009: LD_INT 53
4011: PPUSH
4012: LD_INT 94
4014: PPUSH
4015: CALL_OW 428
4019: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4020: LD_ADDR_VAR 0 7
4024: PUSH
4025: LD_INT 56
4027: PPUSH
4028: LD_INT 101
4030: PPUSH
4031: CALL_OW 428
4035: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4036: LD_ADDR_VAR 0 8
4040: PUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 101
4046: PPUSH
4047: CALL_OW 428
4051: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4052: LD_ADDR_VAR 0 9
4056: PUSH
4057: LD_INT 54
4059: PPUSH
4060: LD_INT 85
4062: PPUSH
4063: CALL_OW 428
4067: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4068: LD_ADDR_VAR 0 3
4072: PUSH
4073: LD_VAR 0 8
4077: PUSH
4078: LD_VAR 0 6
4082: PUSH
4083: LD_VAR 0 9
4087: PUSH
4088: LD_VAR 0 7
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// for i in tmp do
4099: LD_ADDR_VAR 0 2
4103: PUSH
4104: LD_VAR 0 5
4108: PUSH
4109: FOR_IN
4110: IFFALSE 4198
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4112: LD_VAR 0 3
4116: PUSH
4117: LD_INT 1
4119: ARRAY
4120: PPUSH
4121: CALL_OW 313
4125: PUSH
4126: LD_INT 6
4128: EQUAL
4129: IFFALSE 4149
// b := Delete ( b , 1 ) ;
4131: LD_ADDR_VAR 0 3
4135: PUSH
4136: LD_VAR 0 3
4140: PPUSH
4141: LD_INT 1
4143: PPUSH
4144: CALL_OW 3
4148: ST_TO_ADDR
// if b then
4149: LD_VAR 0 3
4153: IFFALSE 4175
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4155: LD_VAR 0 2
4159: PPUSH
4160: LD_VAR 0 3
4164: PUSH
4165: LD_INT 1
4167: ARRAY
4168: PPUSH
4169: CALL_OW 52
4173: GO 4196
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4175: LD_VAR 0 2
4179: PPUSH
4180: LD_INT 61
4182: PPUSH
4183: LD_INT 89
4185: PPUSH
4186: LD_INT 8
4188: PPUSH
4189: LD_INT 0
4191: PPUSH
4192: CALL_OW 50
// end ;
4196: GO 4109
4198: POP
4199: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4200: LD_INT 2
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: LD_INT 12
4211: PPUSH
4212: LD_INT 100
4214: PPUSH
4215: CALL 72551 0 5
// veh := CreateVehicle ;
4219: LD_ADDR_VAR 0 4
4223: PUSH
4224: CALL_OW 45
4228: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4229: LD_VAR 0 4
4233: PPUSH
4234: LD_INT 4
4236: PPUSH
4237: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4241: LD_VAR 0 4
4245: PPUSH
4246: LD_INT 49
4248: PPUSH
4249: LD_INT 88
4251: PPUSH
4252: LD_INT 0
4254: PPUSH
4255: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4259: LD_VAR 0 4
4263: PPUSH
4264: LD_INT 1
4266: PPUSH
4267: LD_INT 100
4269: PPUSH
4270: CALL_OW 290
// uc_side := 0 ;
4274: LD_ADDR_OWVAR 20
4278: PUSH
4279: LD_INT 0
4281: ST_TO_ADDR
// uc_nation := 0 ;
4282: LD_ADDR_OWVAR 21
4286: PUSH
4287: LD_INT 0
4289: ST_TO_ADDR
// for i := 1 to 3 do
4290: LD_ADDR_VAR 0 2
4294: PUSH
4295: DOUBLE
4296: LD_INT 1
4298: DEC
4299: ST_TO_ADDR
4300: LD_INT 3
4302: PUSH
4303: FOR_TO
4304: IFFALSE 4335
// begin InitHc ;
4306: CALL_OW 19
// hc_class := class_apeman ;
4310: LD_ADDR_OWVAR 28
4314: PUSH
4315: LD_INT 12
4317: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4318: CALL_OW 44
4322: PPUSH
4323: LD_INT 13
4325: PPUSH
4326: LD_INT 0
4328: PPUSH
4329: CALL_OW 49
// end ;
4333: GO 4303
4335: POP
4336: POP
// end ; end_of_file
4337: LD_VAR 0 1
4341: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4342: LD_INT 0
4344: PPUSH
4345: PPUSH
4346: PPUSH
4347: PPUSH
4348: PPUSH
// side := 8 ;
4349: LD_ADDR_VAR 0 3
4353: PUSH
4354: LD_INT 8
4356: ST_TO_ADDR
// uc_side := side ;
4357: LD_ADDR_OWVAR 20
4361: PUSH
4362: LD_VAR 0 3
4366: ST_TO_ADDR
// uc_nation := 2 ;
4367: LD_ADDR_OWVAR 21
4371: PUSH
4372: LD_INT 2
4374: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4375: LD_ADDR_VAR 0 2
4379: PUSH
4380: LD_INT 22
4382: PUSH
4383: LD_VAR 0 3
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 21
4394: PUSH
4395: LD_INT 3
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PPUSH
4406: CALL_OW 69
4410: PUSH
4411: FOR_IN
4412: IFFALSE 4428
// SetBLevel ( i , 10 ) ;
4414: LD_VAR 0 2
4418: PPUSH
4419: LD_INT 10
4421: PPUSH
4422: CALL_OW 241
4426: GO 4411
4428: POP
4429: POP
// if KurtStatus then
4430: LD_EXP 3
4434: IFFALSE 4457
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4436: LD_ADDR_EXP 62
4440: PUSH
4441: LD_STRING Kurt
4443: PPUSH
4444: LD_INT 0
4446: PPUSH
4447: LD_STRING 
4449: PPUSH
4450: CALL 67536 0 3
4454: ST_TO_ADDR
4455: GO 4479
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4457: LD_ADDR_EXP 62
4461: PUSH
4462: LD_STRING AltKurt
4464: PPUSH
4465: LD_EXP 1
4469: NOT
4470: PPUSH
4471: LD_STRING 
4473: PPUSH
4474: CALL 67536 0 3
4478: ST_TO_ADDR
// if not Kurt then
4479: LD_EXP 62
4483: NOT
4484: IFFALSE 4510
// begin InitHc ;
4486: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4490: LD_INT 1
4492: PPUSH
4493: LD_INT 10
4495: PPUSH
4496: CALL_OW 381
// Kurt := CreateHuman ;
4500: LD_ADDR_EXP 62
4504: PUSH
4505: CALL_OW 44
4509: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4510: LD_EXP 62
4514: PPUSH
4515: LD_INT 324
4517: PPUSH
4518: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4522: LD_ADDR_EXP 63
4526: PUSH
4527: LD_STRING Kozlov
4529: PPUSH
4530: LD_INT 0
4532: PPUSH
4533: LD_STRING 
4535: PPUSH
4536: CALL 67536 0 3
4540: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4541: LD_EXP 63
4545: PPUSH
4546: LD_INT 22
4548: PUSH
4549: LD_INT 8
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 23
4558: PUSH
4559: LD_INT 3
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 30
4568: PUSH
4569: LD_INT 8
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: LIST
4580: PPUSH
4581: CALL_OW 69
4585: PUSH
4586: LD_INT 1
4588: ARRAY
4589: PPUSH
4590: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4594: LD_EXP 63
4598: PPUSH
4599: LD_INT 3
4601: PPUSH
4602: LD_INT 10
4604: PPUSH
4605: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4609: LD_EXP 63
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 10
4619: PPUSH
4620: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4624: LD_ADDR_VAR 0 5
4628: PUSH
4629: LD_INT 22
4631: PUSH
4632: LD_VAR 0 3
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: PUSH
4641: LD_INT 30
4643: PUSH
4644: LD_INT 32
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 58
4653: PUSH
4654: EMPTY
4655: LIST
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: LIST
4661: PPUSH
4662: CALL_OW 69
4666: ST_TO_ADDR
// for i = 1 to 10 do
4667: LD_ADDR_VAR 0 2
4671: PUSH
4672: DOUBLE
4673: LD_INT 1
4675: DEC
4676: ST_TO_ADDR
4677: LD_INT 10
4679: PUSH
4680: FOR_TO
4681: IFFALSE 4753
// begin uc_nation := nation_nature ;
4683: LD_ADDR_OWVAR 21
4687: PUSH
4688: LD_INT 0
4690: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4691: LD_ADDR_OWVAR 28
4695: PUSH
4696: LD_INT 15
4698: ST_TO_ADDR
// hc_gallery :=  ;
4699: LD_ADDR_OWVAR 33
4703: PUSH
4704: LD_STRING 
4706: ST_TO_ADDR
// hc_name :=  ;
4707: LD_ADDR_OWVAR 26
4711: PUSH
4712: LD_STRING 
4714: ST_TO_ADDR
// un := CreateHuman ;
4715: LD_ADDR_VAR 0 4
4719: PUSH
4720: CALL_OW 44
4724: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4725: LD_VAR 0 4
4729: PPUSH
4730: LD_VAR 0 5
4734: PUSH
4735: LD_VAR 0 5
4739: PUSH
4740: LD_VAR 0 2
4744: MINUS
4745: ARRAY
4746: PPUSH
4747: CALL_OW 52
// end ;
4751: GO 4680
4753: POP
4754: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4755: LD_ADDR_VAR 0 5
4759: PUSH
4760: LD_STRING 12_kurt_squad
4762: PPUSH
4763: CALL_OW 31
4767: ST_TO_ADDR
// if tmp then
4768: LD_VAR 0 5
4772: IFFALSE 4806
// for i in tmp do
4774: LD_ADDR_VAR 0 2
4778: PUSH
4779: LD_VAR 0 5
4783: PUSH
4784: FOR_IN
4785: IFFALSE 4804
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4787: LD_VAR 0 2
4791: PPUSH
4792: LD_INT 5
4794: PPUSH
4795: LD_INT 0
4797: PPUSH
4798: CALL_OW 49
4802: GO 4784
4804: POP
4805: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4806: LD_INT 324
4808: PPUSH
4809: LD_INT 5
4811: PPUSH
4812: LD_STRING 
4814: PPUSH
4815: LD_INT 8
4817: PUSH
4818: LD_INT 9
4820: PUSH
4821: LD_INT 10
4823: PUSH
4824: LD_INT 10
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: PUSH
4833: LD_OWVAR 67
4837: ARRAY
4838: PPUSH
4839: LD_INT 3000
4841: PUSH
4842: LD_INT 500
4844: PUSH
4845: LD_INT 150
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: LIST
4852: PPUSH
4853: LD_INT 16
4855: PUSH
4856: LD_INT 6
4858: PUSH
4859: LD_INT 6
4861: PUSH
4862: LD_INT 8
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: PPUSH
4871: CALL 75995 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4875: LD_ADDR_EXP 100
4879: PUSH
4880: LD_EXP 100
4884: PPUSH
4885: LD_INT 3
4887: PPUSH
4888: LD_INT 22
4890: PUSH
4891: LD_VAR 0 3
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: PUSH
4900: LD_INT 23
4902: PUSH
4903: LD_INT 2
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 3
4912: PUSH
4913: LD_INT 21
4915: PUSH
4916: LD_INT 2
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: EMPTY
4928: LIST
4929: LIST
4930: LIST
4931: PPUSH
4932: CALL_OW 69
4936: PUSH
4937: LD_EXP 62
4941: DIFF
4942: PPUSH
4943: CALL_OW 1
4947: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4948: LD_INT 1
4950: PPUSH
4951: LD_INT 7
4953: PPUSH
4954: CALL_OW 383
// hc_name := Ali Hadrach ;
4958: LD_ADDR_OWVAR 26
4962: PUSH
4963: LD_STRING Ali Hadrach
4965: ST_TO_ADDR
// hc_face_number := 31 ;
4966: LD_ADDR_OWVAR 34
4970: PUSH
4971: LD_INT 31
4973: ST_TO_ADDR
// Friend := CreateHuman ;
4974: LD_ADDR_EXP 64
4978: PUSH
4979: CALL_OW 44
4983: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4984: LD_INT 14
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 1
4992: PPUSH
4993: LD_INT 29
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 72551 0 5
// powellBomb := CreateVehicle ;
5003: LD_ADDR_EXP 65
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5013: LD_EXP 65
5017: PPUSH
5018: LD_INT 90
5020: PPUSH
5021: LD_INT 51
5023: PPUSH
5024: LD_INT 0
5026: PPUSH
5027: CALL_OW 48
// end ;
5031: LD_VAR 0 1
5035: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5036: LD_INT 0
5038: PPUSH
5039: PPUSH
5040: PPUSH
// if IsLive ( kozlov_fac ) then
5041: LD_INT 332
5043: PPUSH
5044: CALL_OW 300
5048: IFFALSE 5052
// exit ;
5050: GO 5619
// ComExitBuilding ( Kozlov ) ;
5052: LD_EXP 63
5056: PPUSH
5057: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5061: LD_EXP 63
5065: PPUSH
5066: CALL_OW 257
5070: PUSH
5071: LD_INT 2
5073: NONEQUAL
5074: IFFALSE 5109
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5076: LD_EXP 63
5080: PPUSH
5081: LD_INT 324
5083: PPUSH
5084: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5088: LD_EXP 63
5092: PPUSH
5093: LD_INT 2
5095: PPUSH
5096: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5100: LD_EXP 63
5104: PPUSH
5105: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5109: LD_EXP 63
5113: PPUSH
5114: LD_INT 2
5116: PPUSH
5117: LD_INT 93
5119: PPUSH
5120: LD_INT 32
5122: PPUSH
5123: LD_INT 3
5125: PPUSH
5126: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5130: LD_INT 35
5132: PPUSH
5133: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5137: LD_INT 22
5139: PUSH
5140: LD_INT 8
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: LD_INT 30
5149: PUSH
5150: LD_INT 3
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: PUSH
5157: LD_INT 23
5159: PUSH
5160: LD_INT 3
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PUSH
5167: LD_INT 57
5169: PUSH
5170: EMPTY
5171: LIST
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: PPUSH
5179: CALL_OW 69
5183: IFFALSE 5130
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5185: LD_ADDR_VAR 0 2
5189: PUSH
5190: LD_INT 22
5192: PUSH
5193: LD_INT 8
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: LD_INT 30
5202: PUSH
5203: LD_INT 3
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 23
5212: PUSH
5213: LD_INT 3
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 57
5222: PUSH
5223: EMPTY
5224: LIST
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: PPUSH
5232: CALL_OW 69
5236: PUSH
5237: LD_INT 1
5239: ARRAY
5240: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5241: LD_INT 22
5243: PUSH
5244: LD_INT 8
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: PUSH
5251: LD_INT 23
5253: PUSH
5254: LD_INT 3
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 30
5263: PUSH
5264: LD_INT 21
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: EMPTY
5272: LIST
5273: LIST
5274: LIST
5275: PPUSH
5276: CALL_OW 69
5280: NOT
5281: IFFALSE 5359
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5283: LD_EXP 63
5287: PPUSH
5288: LD_INT 21
5290: PPUSH
5291: LD_INT 97
5293: PPUSH
5294: LD_INT 36
5296: PPUSH
5297: LD_INT 5
5299: PPUSH
5300: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5304: LD_INT 35
5306: PPUSH
5307: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5311: LD_INT 22
5313: PUSH
5314: LD_INT 8
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PUSH
5321: LD_INT 23
5323: PUSH
5324: LD_INT 3
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 30
5333: PUSH
5334: LD_INT 21
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 57
5343: PUSH
5344: EMPTY
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: PPUSH
5353: CALL_OW 69
5357: IFFALSE 5304
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5359: LD_INT 22
5361: PUSH
5362: LD_INT 8
5364: PUSH
5365: EMPTY
5366: LIST
5367: LIST
5368: PUSH
5369: LD_INT 23
5371: PUSH
5372: LD_INT 3
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 30
5381: PUSH
5382: LD_INT 18
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: LIST
5393: PPUSH
5394: CALL_OW 69
5398: NOT
5399: IFFALSE 5477
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5401: LD_EXP 63
5405: PPUSH
5406: LD_INT 18
5408: PPUSH
5409: LD_INT 89
5411: PPUSH
5412: LD_INT 32
5414: PPUSH
5415: LD_INT 1
5417: PPUSH
5418: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5422: LD_INT 35
5424: PPUSH
5425: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5429: LD_INT 22
5431: PUSH
5432: LD_INT 8
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: LD_INT 23
5441: PUSH
5442: LD_INT 3
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 30
5451: PUSH
5452: LD_INT 18
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 57
5461: PUSH
5462: EMPTY
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: PPUSH
5471: CALL_OW 69
5475: IFFALSE 5422
// end ; lab := kozlov_lab ;
5477: LD_ADDR_VAR 0 3
5481: PUSH
5482: LD_INT 336
5484: ST_TO_ADDR
// if not lab then
5485: LD_VAR 0 3
5489: NOT
5490: IFFALSE 5494
// exit ;
5492: GO 5619
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5494: LD_EXP 63
5498: PPUSH
5499: LD_VAR 0 3
5503: PUSH
5504: LD_INT 1
5506: ARRAY
5507: PPUSH
5508: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5512: LD_EXP 63
5516: PPUSH
5517: LD_INT 4
5519: PPUSH
5520: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5524: LD_VAR 0 3
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: PPUSH
5533: LD_INT 25
5535: PPUSH
5536: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5540: LD_INT 35
5542: PPUSH
5543: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5547: LD_INT 25
5549: PPUSH
5550: LD_INT 8
5552: PPUSH
5553: CALL_OW 321
5557: PUSH
5558: LD_INT 2
5560: EQUAL
5561: IFFALSE 5540
// ComExitBuilding ( Kozlov ) ;
5563: LD_EXP 63
5567: PPUSH
5568: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5572: LD_EXP 63
5576: PPUSH
5577: LD_VAR 0 2
5581: PPUSH
5582: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5586: LD_EXP 63
5590: PPUSH
5591: LD_INT 3
5593: PPUSH
5594: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5598: LD_VAR 0 2
5602: PPUSH
5603: LD_INT 23
5605: PPUSH
5606: LD_INT 3
5608: PPUSH
5609: LD_INT 1
5611: PPUSH
5612: LD_INT 48
5614: PPUSH
5615: CALL_OW 125
// end ;
5619: LD_VAR 0 1
5623: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5624: LD_EXP 22
5628: NOT
5629: PUSH
5630: LD_EXP 15
5634: PUSH
5635: LD_INT 6
5637: GREATEREQUAL
5638: AND
5639: IFFALSE 5720
5641: GO 5643
5643: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5644: LD_INT 3
5646: PPUSH
5647: LD_INT 3
5649: PPUSH
5650: CALL 61285 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5654: LD_INT 3
5656: PPUSH
5657: LD_INT 14
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 28
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 14
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 28
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 14
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 28
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: LIST
5715: PPUSH
5716: CALL 61148 0 2
// end ;
5720: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5721: LD_EXP 22
5725: NOT
5726: PUSH
5727: LD_EXP 15
5731: PUSH
5732: LD_INT 6
5734: GREATEREQUAL
5735: AND
5736: PUSH
5737: LD_INT 3
5739: PPUSH
5740: LD_INT 1
5742: PPUSH
5743: CALL 62566 0 2
5747: NOT
5748: AND
5749: IFFALSE 6623
5751: GO 5753
5753: DISABLE
5754: LD_INT 0
5756: PPUSH
5757: PPUSH
5758: PPUSH
// begin enable ;
5759: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5760: LD_INT 22
5762: PUSH
5763: LD_INT 8
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: PUSH
5770: LD_INT 23
5772: PUSH
5773: LD_INT 2
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 30
5782: PUSH
5783: LD_INT 3
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: LIST
5794: PPUSH
5795: CALL_OW 69
5799: NOT
5800: IFFALSE 5804
// exit ;
5802: GO 6623
// if Prob ( 40 ) then
5804: LD_INT 40
5806: PPUSH
5807: CALL_OW 13
5811: IFFALSE 5938
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5813: LD_INT 3
5815: PPUSH
5816: LD_INT 14
5818: PUSH
5819: LD_INT 1
5821: PUSH
5822: LD_INT 2
5824: PUSH
5825: LD_INT 28
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: LIST
5833: PUSH
5834: LD_INT 14
5836: PUSH
5837: LD_INT 1
5839: PUSH
5840: LD_INT 2
5842: PUSH
5843: LD_INT 28
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_INT 14
5854: PUSH
5855: LD_INT 1
5857: PUSH
5858: LD_INT 2
5860: PUSH
5861: LD_INT 28
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 14
5872: PUSH
5873: LD_INT 1
5875: PUSH
5876: LD_INT 2
5878: PUSH
5879: LD_INT 28
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_INT 14
5890: PUSH
5891: LD_INT 1
5893: PUSH
5894: LD_INT 2
5896: PUSH
5897: LD_INT 28
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 14
5908: PUSH
5909: LD_INT 1
5911: PUSH
5912: LD_INT 2
5914: PUSH
5915: LD_INT 26
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL 61148 0 2
// end else
5936: GO 6145
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_INT 14
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 2
5949: PUSH
5950: LD_INT 27
5952: PUSH
5953: LD_INT 26
5955: PUSH
5956: LD_INT 26
5958: PUSH
5959: LD_INT 28
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: LD_OWVAR 67
5972: ARRAY
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: PUSH
5980: LD_INT 14
5982: PUSH
5983: LD_INT 1
5985: PUSH
5986: LD_INT 2
5988: PUSH
5989: LD_INT 27
5991: PUSH
5992: LD_INT 26
5994: PUSH
5995: LD_INT 26
5997: PUSH
5998: LD_INT 26
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: PUSH
6007: LD_OWVAR 67
6011: ARRAY
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 2
6027: PUSH
6028: LD_INT 26
6030: PUSH
6031: LD_INT 26
6033: PUSH
6034: LD_INT 29
6036: PUSH
6037: LD_INT 29
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: PUSH
6046: LD_OWVAR 67
6050: ARRAY
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: LIST
6056: LIST
6057: PUSH
6058: LD_INT 13
6060: PUSH
6061: LD_INT 1
6063: PUSH
6064: LD_INT 2
6066: PUSH
6067: LD_INT 26
6069: PUSH
6070: LD_INT 29
6072: PUSH
6073: LD_INT 29
6075: PUSH
6076: LD_INT 29
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: LIST
6083: LIST
6084: PUSH
6085: LD_OWVAR 67
6089: ARRAY
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 13
6099: PUSH
6100: LD_INT 1
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: LD_INT 29
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 14
6117: PUSH
6118: LD_INT 1
6120: PUSH
6121: LD_INT 2
6123: PUSH
6124: LD_INT 26
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: LIST
6137: LIST
6138: LIST
6139: LIST
6140: PPUSH
6141: CALL 61148 0 2
// end ; repeat wait ( 0 0$1 ) ;
6145: LD_INT 35
6147: PPUSH
6148: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6152: LD_INT 3
6154: PPUSH
6155: LD_INT 1
6157: PPUSH
6158: CALL 62566 0 2
6162: PUSH
6163: LD_INT 6
6165: GREATEREQUAL
6166: IFFALSE 6145
// wait ( 0 0$30 ) ;
6168: LD_INT 1050
6170: PPUSH
6171: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_INT 3
6182: PPUSH
6183: LD_INT 1
6185: PPUSH
6186: CALL 62566 0 2
6190: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6191: LD_ADDR_EXP 119
6195: PUSH
6196: LD_EXP 119
6200: PPUSH
6201: LD_INT 3
6203: PPUSH
6204: LD_EXP 119
6208: PUSH
6209: LD_INT 3
6211: ARRAY
6212: PUSH
6213: LD_VAR 0 2
6217: DIFF
6218: PPUSH
6219: CALL_OW 1
6223: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6224: LD_ADDR_VAR 0 3
6228: PUSH
6229: LD_INT 0
6231: PPUSH
6232: LD_INT 2
6234: PPUSH
6235: CALL_OW 12
6239: ST_TO_ADDR
// if target then
6240: LD_VAR 0 3
6244: IFFALSE 6381
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PPUSH
6256: LD_INT 24
6258: PUSH
6259: LD_INT 250
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: PPUSH
6266: CALL_OW 72
6270: ST_TO_ADDR
// if not tmp then
6271: LD_VAR 0 2
6275: NOT
6276: IFFALSE 6280
// break ;
6278: GO 6379
// for i in tmp do
6280: LD_ADDR_VAR 0 1
6284: PUSH
6285: LD_VAR 0 2
6289: PUSH
6290: FOR_IN
6291: IFFALSE 6331
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6293: LD_VAR 0 1
6297: PPUSH
6298: LD_INT 89
6300: PPUSH
6301: LD_INT 71
6303: PPUSH
6304: CALL_OW 297
6308: PUSH
6309: LD_INT 9
6311: GREATER
6312: IFFALSE 6329
// ComMoveXY ( i , 89 , 71 ) ;
6314: LD_VAR 0 1
6318: PPUSH
6319: LD_INT 89
6321: PPUSH
6322: LD_INT 71
6324: PPUSH
6325: CALL_OW 111
6329: GO 6290
6331: POP
6332: POP
// wait ( 0 0$1 ) ;
6333: LD_INT 35
6335: PPUSH
6336: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6340: LD_VAR 0 2
6344: PPUSH
6345: LD_INT 92
6347: PUSH
6348: LD_INT 89
6350: PUSH
6351: LD_INT 71
6353: PUSH
6354: LD_INT 9
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PPUSH
6363: CALL_OW 72
6367: PUSH
6368: LD_VAR 0 2
6372: PUSH
6373: LD_INT 1
6375: MINUS
6376: GREATEREQUAL
6377: IFFALSE 6246
// end else
6379: GO 6514
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PPUSH
6391: LD_INT 24
6393: PUSH
6394: LD_INT 250
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PPUSH
6401: CALL_OW 72
6405: ST_TO_ADDR
// if not tmp then
6406: LD_VAR 0 2
6410: NOT
6411: IFFALSE 6415
// break ;
6413: GO 6514
// for i in tmp do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: LD_VAR 0 2
6424: PUSH
6425: FOR_IN
6426: IFFALSE 6466
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6428: LD_VAR 0 1
6432: PPUSH
6433: LD_INT 125
6435: PPUSH
6436: LD_INT 129
6438: PPUSH
6439: CALL_OW 297
6443: PUSH
6444: LD_INT 9
6446: GREATER
6447: IFFALSE 6464
// ComMoveXY ( i , 125 , 129 ) ;
6449: LD_VAR 0 1
6453: PPUSH
6454: LD_INT 125
6456: PPUSH
6457: LD_INT 129
6459: PPUSH
6460: CALL_OW 111
6464: GO 6425
6466: POP
6467: POP
// wait ( 0 0$1 ) ;
6468: LD_INT 35
6470: PPUSH
6471: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6475: LD_VAR 0 2
6479: PPUSH
6480: LD_INT 92
6482: PUSH
6483: LD_INT 125
6485: PUSH
6486: LD_INT 129
6488: PUSH
6489: LD_INT 9
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PPUSH
6498: CALL_OW 72
6502: PUSH
6503: LD_VAR 0 2
6507: PUSH
6508: LD_INT 1
6510: MINUS
6511: GREATEREQUAL
6512: IFFALSE 6381
// end ; repeat wait ( 0 0$1 ) ;
6514: LD_INT 35
6516: PPUSH
6517: CALL_OW 67
// for i in tmp do
6521: LD_ADDR_VAR 0 1
6525: PUSH
6526: LD_VAR 0 2
6530: PUSH
6531: FOR_IN
6532: IFFALSE 6614
// begin if GetLives ( i ) > 251 then
6534: LD_VAR 0 1
6538: PPUSH
6539: CALL_OW 256
6543: PUSH
6544: LD_INT 251
6546: GREATER
6547: IFFALSE 6585
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6549: LD_VAR 0 1
6553: PPUSH
6554: LD_INT 81
6556: PUSH
6557: LD_INT 8
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PPUSH
6564: CALL_OW 69
6568: PPUSH
6569: LD_VAR 0 1
6573: PPUSH
6574: CALL_OW 74
6578: PPUSH
6579: CALL_OW 115
6583: GO 6612
// if IsDead ( i ) then
6585: LD_VAR 0 1
6589: PPUSH
6590: CALL_OW 301
6594: IFFALSE 6612
// tmp := tmp diff i ;
6596: LD_ADDR_VAR 0 2
6600: PUSH
6601: LD_VAR 0 2
6605: PUSH
6606: LD_VAR 0 1
6610: DIFF
6611: ST_TO_ADDR
// end ;
6612: GO 6531
6614: POP
6615: POP
// until not tmp ;
6616: LD_VAR 0 2
6620: NOT
6621: IFFALSE 6514
// end ;
6623: PPOPN 3
6625: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6626: LD_EXP 22
6630: NOT
6631: PUSH
6632: LD_EXP 15
6636: PUSH
6637: LD_INT 6
6639: GREATEREQUAL
6640: AND
6641: PUSH
6642: LD_OWVAR 67
6646: PUSH
6647: LD_INT 1
6649: GREATER
6650: AND
6651: IFFALSE 7184
6653: GO 6655
6655: DISABLE
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// begin enable ;
6661: ENABLE
// tmp := [ ] ;
6662: LD_ADDR_VAR 0 3
6666: PUSH
6667: EMPTY
6668: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6669: LD_ADDR_VAR 0 1
6673: PUSH
6674: DOUBLE
6675: LD_INT 1
6677: DEC
6678: ST_TO_ADDR
6679: LD_INT 4
6681: PUSH
6682: LD_INT 6
6684: PUSH
6685: LD_INT 7
6687: PUSH
6688: LD_INT 8
6690: PUSH
6691: EMPTY
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: PUSH
6697: LD_OWVAR 67
6701: ARRAY
6702: PUSH
6703: FOR_TO
6704: IFFALSE 6864
// begin uc_side := 8 ;
6706: LD_ADDR_OWVAR 20
6710: PUSH
6711: LD_INT 8
6713: ST_TO_ADDR
// uc_nation := 2 ;
6714: LD_ADDR_OWVAR 21
6718: PUSH
6719: LD_INT 2
6721: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6722: LD_INT 13
6724: PUSH
6725: LD_INT 14
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PUSH
6732: LD_INT 1
6734: PPUSH
6735: LD_INT 2
6737: PPUSH
6738: CALL_OW 12
6742: ARRAY
6743: PPUSH
6744: LD_INT 1
6746: PPUSH
6747: LD_INT 5
6749: PPUSH
6750: LD_INT 27
6752: PUSH
6753: LD_INT 28
6755: PUSH
6756: LD_INT 26
6758: PUSH
6759: LD_INT 25
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: PUSH
6768: LD_INT 1
6770: PPUSH
6771: LD_INT 4
6773: PPUSH
6774: CALL_OW 12
6778: ARRAY
6779: PPUSH
6780: LD_INT 88
6782: PPUSH
6783: CALL 72551 0 5
// un := CreateVehicle ;
6787: LD_ADDR_VAR 0 2
6791: PUSH
6792: CALL_OW 45
6796: ST_TO_ADDR
// tmp := tmp ^ un ;
6797: LD_ADDR_VAR 0 3
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: LD_VAR 0 2
6811: ADD
6812: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6813: LD_VAR 0 2
6817: PPUSH
6818: LD_INT 3
6820: PPUSH
6821: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 30
6832: PPUSH
6833: LD_INT 0
6835: PPUSH
6836: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6840: LD_VAR 0 2
6844: PPUSH
6845: LD_INT 16
6847: PPUSH
6848: LD_INT 11
6850: PPUSH
6851: CALL_OW 111
// wait ( 0 0$2 ) ;
6855: LD_INT 70
6857: PPUSH
6858: CALL_OW 67
// end ;
6862: GO 6703
6864: POP
6865: POP
// for i = 1 to Difficulty do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: DOUBLE
6872: LD_INT 1
6874: DEC
6875: ST_TO_ADDR
6876: LD_OWVAR 67
6880: PUSH
6881: FOR_TO
6882: IFFALSE 7011
// begin uc_side := 8 ;
6884: LD_ADDR_OWVAR 20
6888: PUSH
6889: LD_INT 8
6891: ST_TO_ADDR
// uc_nation := 2 ;
6892: LD_ADDR_OWVAR 21
6896: PUSH
6897: LD_INT 2
6899: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6900: LD_INT 0
6902: PPUSH
6903: LD_INT 8
6905: PPUSH
6906: LD_INT 8
6908: PUSH
6909: LD_INT 8
6911: PUSH
6912: LD_INT 9
6914: PUSH
6915: LD_INT 10
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: PUSH
6924: LD_OWVAR 67
6928: ARRAY
6929: PPUSH
6930: CALL_OW 380
// un := CreateHuman ;
6934: LD_ADDR_VAR 0 2
6938: PUSH
6939: CALL_OW 44
6943: ST_TO_ADDR
// tmp := tmp ^ un ;
6944: LD_ADDR_VAR 0 3
6948: PUSH
6949: LD_VAR 0 3
6953: PUSH
6954: LD_VAR 0 2
6958: ADD
6959: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6960: LD_VAR 0 2
6964: PPUSH
6965: LD_INT 3
6967: PPUSH
6968: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 30
6979: PPUSH
6980: LD_INT 0
6982: PPUSH
6983: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6987: LD_VAR 0 2
6991: PPUSH
6992: LD_INT 16
6994: PPUSH
6995: LD_INT 11
6997: PPUSH
6998: CALL_OW 111
// wait ( 0 0$2 ) ;
7002: LD_INT 70
7004: PPUSH
7005: CALL_OW 67
// end ;
7009: GO 6881
7011: POP
7012: POP
// repeat wait ( 0 0$1 ) ;
7013: LD_INT 35
7015: PPUSH
7016: CALL_OW 67
// if legionDestroyed then
7020: LD_EXP 22
7024: IFFALSE 7028
// exit ;
7026: GO 7184
// for i in tmp do
7028: LD_ADDR_VAR 0 1
7032: PUSH
7033: LD_VAR 0 3
7037: PUSH
7038: FOR_IN
7039: IFFALSE 7175
// begin if GetLives ( i ) > 250 then
7041: LD_VAR 0 1
7045: PPUSH
7046: CALL_OW 256
7050: PUSH
7051: LD_INT 250
7053: GREATER
7054: IFFALSE 7146
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7056: LD_INT 81
7058: PUSH
7059: LD_INT 8
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: PUSH
7066: LD_INT 91
7068: PUSH
7069: LD_VAR 0 1
7073: PUSH
7074: LD_INT 10
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PPUSH
7086: CALL_OW 69
7090: NOT
7091: IFFALSE 7110
// ComAgressiveMove ( i , 67 , 110 ) else
7093: LD_VAR 0 1
7097: PPUSH
7098: LD_INT 67
7100: PPUSH
7101: LD_INT 110
7103: PPUSH
7104: CALL_OW 114
7108: GO 7144
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7110: LD_VAR 0 1
7114: PPUSH
7115: LD_INT 81
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL_OW 69
7129: PPUSH
7130: LD_VAR 0 1
7134: PPUSH
7135: CALL_OW 74
7139: PPUSH
7140: CALL_OW 115
// end else
7144: GO 7173
// if IsDead ( i ) then
7146: LD_VAR 0 1
7150: PPUSH
7151: CALL_OW 301
7155: IFFALSE 7173
// tmp := tmp diff i ;
7157: LD_ADDR_VAR 0 3
7161: PUSH
7162: LD_VAR 0 3
7166: PUSH
7167: LD_VAR 0 1
7171: DIFF
7172: ST_TO_ADDR
// end ;
7173: GO 7038
7175: POP
7176: POP
// until not tmp ;
7177: LD_VAR 0 3
7181: NOT
7182: IFFALSE 7013
// end ; end_of_file
7184: PPOPN 3
7186: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7187: LD_INT 0
7189: PPUSH
7190: PPUSH
7191: PPUSH
7192: PPUSH
7193: PPUSH
7194: PPUSH
7195: PPUSH
7196: PPUSH
7197: PPUSH
// side := 3 ;
7198: LD_ADDR_VAR 0 6
7202: PUSH
7203: LD_INT 3
7205: ST_TO_ADDR
// uc_side := side ;
7206: LD_ADDR_OWVAR 20
7210: PUSH
7211: LD_VAR 0 6
7215: ST_TO_ADDR
// uc_nation := 3 ;
7216: LD_ADDR_OWVAR 21
7220: PUSH
7221: LD_INT 3
7223: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7224: LD_ADDR_VAR 0 2
7228: PUSH
7229: LD_INT 22
7231: PUSH
7232: LD_VAR 0 6
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: LD_INT 21
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 69
7259: PUSH
7260: FOR_IN
7261: IFFALSE 7277
// SetBLevel ( i , 10 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 10
7270: PPUSH
7271: CALL_OW 241
7275: GO 7260
7277: POP
7278: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7279: LD_ADDR_VAR 0 9
7283: PUSH
7284: LD_INT 22
7286: PUSH
7287: LD_VAR 0 6
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 30
7298: PUSH
7299: LD_INT 34
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PPUSH
7310: CALL_OW 69
7314: ST_TO_ADDR
// if teleport then
7315: LD_VAR 0 9
7319: IFFALSE 7340
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7321: LD_VAR 0 9
7325: PUSH
7326: LD_INT 1
7328: ARRAY
7329: PPUSH
7330: LD_INT 123
7332: PPUSH
7333: LD_INT 122
7335: PPUSH
7336: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7340: LD_ADDR_EXP 66
7344: PUSH
7345: LD_STRING Platonov
7347: PPUSH
7348: CALL_OW 25
7352: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7353: LD_ADDR_EXP 67
7357: PUSH
7358: LD_STRING Kovalyuk
7360: PPUSH
7361: CALL_OW 25
7365: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7366: LD_ADDR_EXP 69
7370: PUSH
7371: LD_STRING Yakotich
7373: PPUSH
7374: LD_EXP 1
7378: NOT
7379: PPUSH
7380: LD_STRING 09_
7382: PPUSH
7383: CALL 67536 0 3
7387: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7388: LD_ADDR_EXP 68
7392: PUSH
7393: LD_STRING Bystrov
7395: PPUSH
7396: CALL_OW 25
7400: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7401: LD_ADDR_EXP 70
7405: PUSH
7406: LD_STRING Gleb
7408: PPUSH
7409: CALL_OW 25
7413: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7414: LD_STRING 03_Cornel
7416: PPUSH
7417: CALL_OW 28
7421: IFFALSE 7469
// begin Bierezov := NewCharacter ( Mikhail ) ;
7423: LD_ADDR_EXP 71
7427: PUSH
7428: LD_STRING Mikhail
7430: PPUSH
7431: CALL_OW 25
7435: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7436: LD_EXP 71
7440: PPUSH
7441: LD_INT 197
7443: PPUSH
7444: LD_INT 111
7446: PPUSH
7447: LD_INT 9
7449: PPUSH
7450: LD_INT 0
7452: PPUSH
7453: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7457: LD_EXP 71
7461: PPUSH
7462: LD_INT 3
7464: PPUSH
7465: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7469: LD_EXP 66
7473: PPUSH
7474: LD_INT 126
7476: PPUSH
7477: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7481: LD_EXP 67
7485: PPUSH
7486: LD_INT 134
7488: PPUSH
7489: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7493: LD_EXP 69
7497: PPUSH
7498: LD_INT 197
7500: PPUSH
7501: LD_INT 111
7503: PPUSH
7504: LD_INT 9
7506: PPUSH
7507: LD_INT 0
7509: PPUSH
7510: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7514: LD_EXP 68
7518: PPUSH
7519: LD_INT 197
7521: PPUSH
7522: LD_INT 111
7524: PPUSH
7525: LD_INT 9
7527: PPUSH
7528: LD_INT 0
7530: PPUSH
7531: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7535: LD_EXP 70
7539: PPUSH
7540: LD_INT 197
7542: PPUSH
7543: LD_INT 111
7545: PPUSH
7546: LD_INT 9
7548: PPUSH
7549: LD_INT 0
7551: PPUSH
7552: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7556: LD_ADDR_VAR 0 5
7560: PUSH
7561: LD_INT 126
7563: PPUSH
7564: LD_INT 4
7566: PPUSH
7567: LD_STRING zhukov
7569: PPUSH
7570: LD_INT 9
7572: PUSH
7573: LD_INT 10
7575: PUSH
7576: LD_INT 10
7578: PUSH
7579: LD_INT 10
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: LIST
7587: PUSH
7588: LD_OWVAR 67
7592: ARRAY
7593: PPUSH
7594: LD_INT 90000
7596: PUSH
7597: LD_INT 1000
7599: PUSH
7600: LD_INT 300
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: LIST
7607: PPUSH
7608: LD_INT 18
7610: PUSH
7611: LD_INT 8
7613: PUSH
7614: LD_INT 13
7616: PUSH
7617: LD_INT 8
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL 75995 0 6
7630: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7631: LD_ADDR_VAR 0 4
7635: PUSH
7636: LD_INT 267
7638: PPUSH
7639: CALL_OW 274
7643: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7644: LD_VAR 0 4
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_INT 5000
7654: PPUSH
7655: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7659: LD_VAR 0 4
7663: PPUSH
7664: LD_INT 2
7666: PPUSH
7667: LD_INT 200
7669: PPUSH
7670: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7674: LD_VAR 0 4
7678: PPUSH
7679: LD_INT 3
7681: PPUSH
7682: LD_INT 200
7684: PPUSH
7685: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7689: LD_ADDR_EXP 100
7693: PUSH
7694: LD_EXP 100
7698: PPUSH
7699: LD_INT 2
7701: PPUSH
7702: LD_VAR 0 5
7706: PUSH
7707: LD_INT 22
7709: PUSH
7710: LD_VAR 0 6
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: PUSH
7719: LD_INT 3
7721: PUSH
7722: LD_INT 21
7724: PUSH
7725: LD_INT 2
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PPUSH
7740: CALL_OW 69
7744: UNION
7745: PUSH
7746: LD_EXP 66
7750: DIFF
7751: PPUSH
7752: CALL_OW 1
7756: ST_TO_ADDR
// behemoths := [ ] ;
7757: LD_ADDR_EXP 74
7761: PUSH
7762: EMPTY
7763: ST_TO_ADDR
// behemothBuilders := [ ] ;
7764: LD_ADDR_EXP 75
7768: PUSH
7769: EMPTY
7770: ST_TO_ADDR
// if Kovalyuk then
7771: LD_EXP 67
7775: IFFALSE 7797
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7777: LD_ADDR_EXP 75
7781: PUSH
7782: LD_EXP 75
7786: PPUSH
7787: LD_EXP 67
7791: PPUSH
7792: CALL 104985 0 2
7796: ST_TO_ADDR
// j := 3 ;
7797: LD_ADDR_VAR 0 3
7801: PUSH
7802: LD_INT 3
7804: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7805: LD_ADDR_VAR 0 2
7809: PUSH
7810: LD_INT 22
7812: PUSH
7813: LD_INT 3
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: LD_INT 25
7822: PUSH
7823: LD_INT 3
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PPUSH
7834: CALL_OW 69
7838: PUSH
7839: LD_EXP 67
7843: DIFF
7844: PUSH
7845: FOR_IN
7846: IFFALSE 7896
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7848: LD_ADDR_EXP 75
7852: PUSH
7853: LD_EXP 75
7857: PPUSH
7858: LD_VAR 0 2
7862: PPUSH
7863: CALL 104985 0 2
7867: ST_TO_ADDR
// j := j - 1 ;
7868: LD_ADDR_VAR 0 3
7872: PUSH
7873: LD_VAR 0 3
7877: PUSH
7878: LD_INT 1
7880: MINUS
7881: ST_TO_ADDR
// if j = 0 then
7882: LD_VAR 0 3
7886: PUSH
7887: LD_INT 0
7889: EQUAL
7890: IFFALSE 7894
// break ;
7892: GO 7896
// end ;
7894: GO 7845
7896: POP
7897: POP
// end ;
7898: LD_VAR 0 1
7902: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
7907: PPUSH
7908: PPUSH
7909: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7910: LD_ADDR_VAR 0 4
7914: PUSH
7915: LD_INT 209
7917: PUSH
7918: LD_INT 149
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: PUSH
7925: LD_INT 219
7927: PUSH
7928: LD_INT 154
7930: PUSH
7931: EMPTY
7932: LIST
7933: LIST
7934: PUSH
7935: LD_INT 223
7937: PUSH
7938: LD_INT 149
7940: PUSH
7941: EMPTY
7942: LIST
7943: LIST
7944: PUSH
7945: LD_INT 232
7947: PUSH
7948: LD_INT 155
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: LIST
7959: LIST
7960: ST_TO_ADDR
// if not behemothBuilders then
7961: LD_EXP 75
7965: NOT
7966: IFFALSE 7970
// exit ;
7968: GO 8101
// j := 1 ;
7970: LD_ADDR_VAR 0 3
7974: PUSH
7975: LD_INT 1
7977: ST_TO_ADDR
// for i in behemothBuilders do
7978: LD_ADDR_VAR 0 2
7982: PUSH
7983: LD_EXP 75
7987: PUSH
7988: FOR_IN
7989: IFFALSE 8099
// begin if GetClass ( i ) <> class_mechanic then
7991: LD_VAR 0 2
7995: PPUSH
7996: CALL_OW 257
8000: PUSH
8001: LD_INT 3
8003: NONEQUAL
8004: IFFALSE 8018
// SetClass ( i , class_mechanic ) ;
8006: LD_VAR 0 2
8010: PPUSH
8011: LD_INT 3
8013: PPUSH
8014: CALL_OW 336
// if IsInUnit ( i ) then
8018: LD_VAR 0 2
8022: PPUSH
8023: CALL_OW 310
8027: IFFALSE 8038
// ComExitBuilding ( i ) ;
8029: LD_VAR 0 2
8033: PPUSH
8034: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8038: LD_VAR 0 2
8042: PPUSH
8043: LD_INT 37
8045: PPUSH
8046: LD_VAR 0 4
8050: PUSH
8051: LD_VAR 0 3
8055: ARRAY
8056: PUSH
8057: LD_INT 1
8059: ARRAY
8060: PPUSH
8061: LD_VAR 0 4
8065: PUSH
8066: LD_VAR 0 3
8070: ARRAY
8071: PUSH
8072: LD_INT 2
8074: ARRAY
8075: PPUSH
8076: LD_INT 0
8078: PPUSH
8079: CALL_OW 230
// j := j + 1 ;
8083: LD_ADDR_VAR 0 3
8087: PUSH
8088: LD_VAR 0 3
8092: PUSH
8093: LD_INT 1
8095: PLUS
8096: ST_TO_ADDR
// end ;
8097: GO 7988
8099: POP
8100: POP
// end ;
8101: LD_VAR 0 1
8105: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8106: LD_INT 24
8108: PPUSH
8109: LD_INT 30
8111: PUSH
8112: LD_INT 37
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 70
8123: IFFALSE 8136
8125: GO 8127
8127: DISABLE
// behemothUnderConstruct := true ;
8128: LD_ADDR_EXP 26
8132: PUSH
8133: LD_INT 1
8135: ST_TO_ADDR
8136: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8137: LD_INT 3
8139: PPUSH
8140: CALL 105046 0 1
8144: PUSH
8145: LD_INT 22
8147: PUSH
8148: LD_INT 3
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 30
8157: PUSH
8158: LD_INT 37
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 69
8173: NOT
8174: AND
8175: IFFALSE 8361
8177: GO 8179
8179: DISABLE
8180: LD_INT 0
8182: PPUSH
8183: PPUSH
// begin enable ;
8184: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8185: LD_ADDR_VAR 0 2
8189: PUSH
8190: LD_INT 3
8192: PPUSH
8193: CALL 105046 0 1
8197: ST_TO_ADDR
// for i in tmp do
8198: LD_ADDR_VAR 0 1
8202: PUSH
8203: LD_VAR 0 2
8207: PUSH
8208: FOR_IN
8209: IFFALSE 8359
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8211: LD_VAR 0 1
8215: PPUSH
8216: LD_INT 9
8218: PPUSH
8219: CALL_OW 308
8223: PUSH
8224: LD_VAR 0 1
8228: PPUSH
8229: CALL_OW 110
8233: PUSH
8234: LD_INT 2
8236: EQUAL
8237: NOT
8238: AND
8239: IFFALSE 8253
// SetTag ( i , 2 ) ;
8241: LD_VAR 0 1
8245: PPUSH
8246: LD_INT 2
8248: PPUSH
8249: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8253: LD_INT 81
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: PUSH
8263: LD_INT 91
8265: PUSH
8266: LD_VAR 0 1
8270: PUSH
8271: LD_INT 12
8273: PUSH
8274: EMPTY
8275: LIST
8276: LIST
8277: LIST
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PPUSH
8283: CALL_OW 69
8287: NOT
8288: PUSH
8289: LD_VAR 0 1
8293: PPUSH
8294: CALL_OW 110
8298: PUSH
8299: LD_INT 2
8301: EQUAL
8302: NOT
8303: AND
8304: IFFALSE 8323
// ComAgressiveMove ( i , 64 , 93 ) else
8306: LD_VAR 0 1
8310: PPUSH
8311: LD_INT 64
8313: PPUSH
8314: LD_INT 93
8316: PPUSH
8317: CALL_OW 114
8321: GO 8357
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8323: LD_VAR 0 1
8327: PPUSH
8328: LD_INT 81
8330: PUSH
8331: LD_INT 3
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PPUSH
8338: CALL_OW 69
8342: PPUSH
8343: LD_VAR 0 1
8347: PPUSH
8348: CALL_OW 74
8352: PPUSH
8353: CALL_OW 115
// end ;
8357: GO 8208
8359: POP
8360: POP
// end ;
8361: PPOPN 2
8363: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8364: LD_INT 0
8366: PPUSH
8367: PPUSH
8368: PPUSH
// result := [ ] ;
8369: LD_ADDR_VAR 0 2
8373: PUSH
8374: EMPTY
8375: ST_TO_ADDR
// uc_side := 6 ;
8376: LD_ADDR_OWVAR 20
8380: PUSH
8381: LD_INT 6
8383: ST_TO_ADDR
// uc_nation := 3 ;
8384: LD_ADDR_OWVAR 21
8388: PUSH
8389: LD_INT 3
8391: ST_TO_ADDR
// case strength of 1 :
8392: LD_VAR 0 1
8396: PUSH
8397: LD_INT 1
8399: DOUBLE
8400: EQUAL
8401: IFTRUE 8405
8403: GO 8547
8405: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: DOUBLE
8412: LD_INT 1
8414: DEC
8415: ST_TO_ADDR
8416: LD_INT 4
8418: PUSH
8419: LD_INT 5
8421: PUSH
8422: LD_INT 6
8424: PUSH
8425: LD_INT 7
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_OWVAR 67
8438: ARRAY
8439: PUSH
8440: FOR_TO
8441: IFFALSE 8543
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8443: LD_INT 22
8445: PUSH
8446: LD_INT 24
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: PUSH
8453: LD_VAR 0 3
8457: PUSH
8458: LD_INT 2
8460: MOD
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: ARRAY
8466: PPUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 1
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 12
8487: ARRAY
8488: PPUSH
8489: LD_INT 3
8491: PPUSH
8492: LD_INT 43
8494: PUSH
8495: LD_INT 44
8497: PUSH
8498: LD_INT 45
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 1
8508: PPUSH
8509: LD_INT 3
8511: PPUSH
8512: CALL_OW 12
8516: ARRAY
8517: PPUSH
8518: LD_INT 80
8520: PPUSH
8521: CALL 72551 0 5
// result := result union CreateVehicle ;
8525: LD_ADDR_VAR 0 2
8529: PUSH
8530: LD_VAR 0 2
8534: PUSH
8535: CALL_OW 45
8539: UNION
8540: ST_TO_ADDR
// end ;
8541: GO 8440
8543: POP
8544: POP
// end ; 2 :
8545: GO 9542
8547: LD_INT 2
8549: DOUBLE
8550: EQUAL
8551: IFTRUE 8555
8553: GO 8723
8555: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8556: LD_ADDR_VAR 0 3
8560: PUSH
8561: DOUBLE
8562: LD_INT 1
8564: DEC
8565: ST_TO_ADDR
8566: LD_INT 5
8568: PUSH
8569: LD_INT 6
8571: PUSH
8572: LD_INT 7
8574: PUSH
8575: LD_INT 8
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: PUSH
8584: LD_OWVAR 67
8588: ARRAY
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8719
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8593: LD_INT 22
8595: PUSH
8596: LD_INT 24
8598: PUSH
8599: LD_INT 24
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: LIST
8606: PUSH
8607: LD_VAR 0 3
8611: PUSH
8612: LD_INT 3
8614: MOD
8615: PUSH
8616: LD_INT 1
8618: PLUS
8619: ARRAY
8620: PPUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PUSH
8631: LD_INT 1
8633: PPUSH
8634: LD_INT 2
8636: PPUSH
8637: CALL_OW 12
8641: ARRAY
8642: PPUSH
8643: LD_INT 3
8645: PPUSH
8646: LD_INT 43
8648: PUSH
8649: LD_INT 44
8651: PUSH
8652: LD_INT 45
8654: PUSH
8655: LD_INT 44
8657: PUSH
8658: LD_INT 46
8660: PUSH
8661: LD_INT 46
8663: PUSH
8664: LD_INT 49
8666: PUSH
8667: LD_INT 49
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: LIST
8679: PUSH
8680: LD_VAR 0 3
8684: PUSH
8685: LD_INT 8
8687: MOD
8688: PUSH
8689: LD_INT 1
8691: PLUS
8692: ARRAY
8693: PPUSH
8694: LD_INT 80
8696: PPUSH
8697: CALL 72551 0 5
// result := result union CreateVehicle ;
8701: LD_ADDR_VAR 0 2
8705: PUSH
8706: LD_VAR 0 2
8710: PUSH
8711: CALL_OW 45
8715: UNION
8716: ST_TO_ADDR
// end ;
8717: GO 8590
8719: POP
8720: POP
// end ; 3 :
8721: GO 9542
8723: LD_INT 3
8725: DOUBLE
8726: EQUAL
8727: IFTRUE 8731
8729: GO 8903
8731: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8732: LD_ADDR_VAR 0 3
8736: PUSH
8737: DOUBLE
8738: LD_INT 1
8740: DEC
8741: ST_TO_ADDR
8742: LD_INT 6
8744: PUSH
8745: LD_INT 7
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: LD_INT 9
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: LIST
8758: LIST
8759: PUSH
8760: LD_OWVAR 67
8764: ARRAY
8765: PUSH
8766: FOR_TO
8767: IFFALSE 8899
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8769: LD_INT 22
8771: PUSH
8772: LD_INT 24
8774: PUSH
8775: LD_INT 24
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: LIST
8782: PUSH
8783: LD_VAR 0 3
8787: PUSH
8788: LD_INT 3
8790: MOD
8791: PUSH
8792: LD_INT 1
8794: PLUS
8795: ARRAY
8796: PPUSH
8797: LD_INT 1
8799: PUSH
8800: LD_INT 3
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 1
8809: PPUSH
8810: LD_INT 2
8812: PPUSH
8813: CALL_OW 12
8817: ARRAY
8818: PPUSH
8819: LD_INT 3
8821: PPUSH
8822: LD_INT 43
8824: PUSH
8825: LD_INT 47
8827: PUSH
8828: LD_INT 45
8830: PUSH
8831: LD_INT 45
8833: PUSH
8834: LD_INT 46
8836: PUSH
8837: LD_INT 46
8839: PUSH
8840: LD_INT 49
8842: PUSH
8843: LD_INT 49
8845: PUSH
8846: LD_INT 49
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: PUSH
8860: LD_VAR 0 3
8864: PUSH
8865: LD_INT 9
8867: MOD
8868: PUSH
8869: LD_INT 1
8871: PLUS
8872: ARRAY
8873: PPUSH
8874: LD_INT 80
8876: PPUSH
8877: CALL 72551 0 5
// result := result union CreateVehicle ;
8881: LD_ADDR_VAR 0 2
8885: PUSH
8886: LD_VAR 0 2
8890: PUSH
8891: CALL_OW 45
8895: UNION
8896: ST_TO_ADDR
// end ;
8897: GO 8766
8899: POP
8900: POP
// end ; 4 :
8901: GO 9542
8903: LD_INT 4
8905: DOUBLE
8906: EQUAL
8907: IFTRUE 8911
8909: GO 9541
8911: POP
// begin uc_nation := 3 ;
8912: LD_ADDR_OWVAR 21
8916: PUSH
8917: LD_INT 3
8919: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8920: LD_ADDR_VAR 0 3
8924: PUSH
8925: DOUBLE
8926: LD_INT 1
8928: DEC
8929: ST_TO_ADDR
8930: LD_INT 6
8932: PUSH
8933: LD_INT 8
8935: PUSH
8936: LD_INT 9
8938: PUSH
8939: LD_INT 10
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: LIST
8946: LIST
8947: PUSH
8948: LD_OWVAR 67
8952: ARRAY
8953: PUSH
8954: FOR_TO
8955: IFFALSE 9087
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8957: LD_INT 22
8959: PUSH
8960: LD_INT 24
8962: PUSH
8963: LD_INT 24
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_VAR 0 3
8975: PUSH
8976: LD_INT 3
8978: MOD
8979: PUSH
8980: LD_INT 1
8982: PLUS
8983: ARRAY
8984: PPUSH
8985: LD_INT 1
8987: PUSH
8988: LD_INT 3
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: PUSH
8995: LD_INT 1
8997: PPUSH
8998: LD_INT 2
9000: PPUSH
9001: CALL_OW 12
9005: ARRAY
9006: PPUSH
9007: LD_INT 3
9009: PPUSH
9010: LD_INT 45
9012: PUSH
9013: LD_INT 47
9015: PUSH
9016: LD_INT 47
9018: PUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 46
9024: PUSH
9025: LD_INT 46
9027: PUSH
9028: LD_INT 49
9030: PUSH
9031: LD_INT 49
9033: PUSH
9034: LD_INT 49
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: LIST
9043: LIST
9044: LIST
9045: LIST
9046: LIST
9047: PUSH
9048: LD_VAR 0 3
9052: PUSH
9053: LD_INT 9
9055: MOD
9056: PUSH
9057: LD_INT 1
9059: PLUS
9060: ARRAY
9061: PPUSH
9062: LD_INT 80
9064: PPUSH
9065: CALL 72551 0 5
// result := result union CreateVehicle ;
9069: LD_ADDR_VAR 0 2
9073: PUSH
9074: LD_VAR 0 2
9078: PUSH
9079: CALL_OW 45
9083: UNION
9084: ST_TO_ADDR
// end ;
9085: GO 8954
9087: POP
9088: POP
// if not KappaStatus then
9089: LD_EXP 2
9093: NOT
9094: IFFALSE 9329
// begin uc_nation := 1 ;
9096: LD_ADDR_OWVAR 21
9100: PUSH
9101: LD_INT 1
9103: ST_TO_ADDR
// for i = 1 to 3 do
9104: LD_ADDR_VAR 0 3
9108: PUSH
9109: DOUBLE
9110: LD_INT 1
9112: DEC
9113: ST_TO_ADDR
9114: LD_INT 3
9116: PUSH
9117: FOR_TO
9118: IFFALSE 9254
// begin j := rand ( 0 , 1 ) ;
9120: LD_ADDR_VAR 0 4
9124: PUSH
9125: LD_INT 0
9127: PPUSH
9128: LD_INT 1
9130: PPUSH
9131: CALL_OW 12
9135: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9136: LD_INT 3
9138: PUSH
9139: LD_INT 5
9141: PUSH
9142: LD_INT 5
9144: PUSH
9145: LD_INT 4
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: PUSH
9154: LD_VAR 0 4
9158: PUSH
9159: LD_INT 1
9161: PPUSH
9162: LD_INT 3
9164: PPUSH
9165: CALL_OW 12
9169: PLUS
9170: ARRAY
9171: PPUSH
9172: LD_INT 1
9174: PUSH
9175: LD_INT 3
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ARRAY
9193: PPUSH
9194: LD_INT 3
9196: PPUSH
9197: LD_INT 9
9199: PUSH
9200: LD_INT 7
9202: PUSH
9203: LD_INT 6
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: LIST
9210: PUSH
9211: LD_VAR 0 4
9215: PUSH
9216: LD_INT 1
9218: PPUSH
9219: LD_INT 2
9221: PPUSH
9222: CALL_OW 12
9226: PLUS
9227: ARRAY
9228: PPUSH
9229: LD_INT 85
9231: PPUSH
9232: CALL 72551 0 5
// result := result union CreateVehicle ;
9236: LD_ADDR_VAR 0 2
9240: PUSH
9241: LD_VAR 0 2
9245: PUSH
9246: CALL_OW 45
9250: UNION
9251: ST_TO_ADDR
// end ;
9252: GO 9117
9254: POP
9255: POP
// if vsevolodFirstAttack then
9256: LD_EXP 24
9260: IFFALSE 9327
// begin vsevolodFirstAttack := false ;
9262: LD_ADDR_EXP 24
9266: PUSH
9267: LD_INT 0
9269: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9270: LD_INT 5
9272: PPUSH
9273: LD_INT 3
9275: PPUSH
9276: LD_INT 1
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 100
9284: PPUSH
9285: CALL 72551 0 5
// sewiVeh := CreateVehicle ;
9289: LD_ADDR_EXP 73
9293: PUSH
9294: CALL_OW 45
9298: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9299: LD_EXP 73
9303: PPUSH
9304: LD_INT 1
9306: PPUSH
9307: CALL_OW 242
// result := result union sewiVeh ;
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: LD_VAR 0 2
9320: PUSH
9321: LD_EXP 73
9325: UNION
9326: ST_TO_ADDR
// end ; end else
9327: GO 9539
// if vsevolodFirstAttack then
9329: LD_EXP 24
9333: IFFALSE 9539
// begin vsevolodFirstAttack := false ;
9335: LD_ADDR_EXP 24
9339: PUSH
9340: LD_INT 0
9342: ST_TO_ADDR
// uc_nation := 3 ;
9343: LD_ADDR_OWVAR 21
9347: PUSH
9348: LD_INT 3
9350: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9351: LD_ADDR_VAR 0 3
9355: PUSH
9356: DOUBLE
9357: LD_INT 1
9359: DEC
9360: ST_TO_ADDR
9361: LD_INT 2
9363: PUSH
9364: LD_OWVAR 67
9368: PLUS
9369: PUSH
9370: FOR_TO
9371: IFFALSE 9479
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9373: LD_INT 22
9375: PUSH
9376: LD_INT 24
9378: PUSH
9379: LD_INT 24
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: LIST
9386: PUSH
9387: LD_VAR 0 3
9391: PUSH
9392: LD_INT 3
9394: MOD
9395: PUSH
9396: LD_INT 1
9398: PLUS
9399: ARRAY
9400: PPUSH
9401: LD_INT 1
9403: PUSH
9404: LD_INT 3
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 1
9413: PPUSH
9414: LD_INT 2
9416: PPUSH
9417: CALL_OW 12
9421: ARRAY
9422: PPUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 45
9428: PUSH
9429: LD_INT 47
9431: PUSH
9432: LD_INT 47
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: LIST
9439: PUSH
9440: LD_VAR 0 3
9444: PUSH
9445: LD_INT 3
9447: MOD
9448: PUSH
9449: LD_INT 1
9451: PLUS
9452: ARRAY
9453: PPUSH
9454: LD_INT 80
9456: PPUSH
9457: CALL 72551 0 5
// result := result union CreateVehicle ;
9461: LD_ADDR_VAR 0 2
9465: PUSH
9466: LD_VAR 0 2
9470: PUSH
9471: CALL_OW 45
9475: UNION
9476: ST_TO_ADDR
// end ;
9477: GO 9370
9479: POP
9480: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9481: LD_INT 24
9483: PPUSH
9484: LD_INT 3
9486: PPUSH
9487: LD_INT 1
9489: PPUSH
9490: LD_INT 47
9492: PPUSH
9493: LD_INT 100
9495: PPUSH
9496: CALL 72551 0 5
// sewiVeh := CreateVehicle ;
9500: LD_ADDR_EXP 73
9504: PUSH
9505: CALL_OW 45
9509: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9510: LD_EXP 73
9514: PPUSH
9515: LD_INT 6
9517: NEG
9518: PPUSH
9519: CALL_OW 242
// result := result union sewiVeh ;
9523: LD_ADDR_VAR 0 2
9527: PUSH
9528: LD_VAR 0 2
9532: PUSH
9533: LD_EXP 73
9537: UNION
9538: ST_TO_ADDR
// end ; end ; end ;
9539: GO 9542
9541: POP
// end ;
9542: LD_VAR 0 2
9546: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9547: LD_EXP 16
9551: IFFALSE 10222
9553: GO 9555
9555: DISABLE
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
9562: PPUSH
9563: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9564: LD_ADDR_VAR 0 4
9568: PUSH
9569: LD_INT 11
9571: PUSH
9572: LD_INT 12
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9579: LD_ADDR_VAR 0 3
9583: PUSH
9584: LD_INT 11550
9586: PUSH
9587: LD_INT 10150
9589: PUSH
9590: LD_INT 9800
9592: PUSH
9593: LD_INT 9450
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: LD_OWVAR 67
9606: ARRAY
9607: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9608: LD_ADDR_VAR 0 6
9612: PUSH
9613: LD_INT 70
9615: PUSH
9616: LD_INT 118
9618: PUSH
9619: EMPTY
9620: LIST
9621: LIST
9622: PUSH
9623: LD_INT 78
9625: PUSH
9626: LD_INT 31
9628: PUSH
9629: EMPTY
9630: LIST
9631: LIST
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: ST_TO_ADDR
// repeat if missionStage = 2 then
9637: LD_EXP 15
9641: PUSH
9642: LD_INT 2
9644: EQUAL
9645: IFFALSE 9656
// wait ( 1 1$30 ) else
9647: LD_INT 3150
9649: PPUSH
9650: CALL_OW 67
9654: GO 9665
// wait ( time ) ;
9656: LD_VAR 0 3
9660: PPUSH
9661: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9665: LD_EXP 15
9669: PUSH
9670: LD_INT 6
9672: EQUAL
9673: PUSH
9674: LD_OWVAR 67
9678: PUSH
9679: LD_INT 2
9681: GREATER
9682: OR
9683: IFFALSE 9711
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9685: LD_INT 51
9687: PPUSH
9688: LD_INT 6
9690: PPUSH
9691: LD_INT 2
9693: PPUSH
9694: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9698: LD_INT 57
9700: PPUSH
9701: LD_INT 6
9703: PPUSH
9704: LD_INT 2
9706: PPUSH
9707: CALL_OW 322
// end ; if missionStage = 8 then
9711: LD_EXP 15
9715: PUSH
9716: LD_INT 8
9718: EQUAL
9719: IFFALSE 9747
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9721: LD_INT 52
9723: PPUSH
9724: LD_INT 6
9726: PPUSH
9727: LD_INT 2
9729: PPUSH
9730: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9734: LD_INT 58
9736: PPUSH
9737: LD_INT 6
9739: PPUSH
9740: LD_INT 2
9742: PPUSH
9743: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9747: LD_EXP 15
9751: PUSH
9752: LD_INT 10
9754: EQUAL
9755: PUSH
9756: LD_OWVAR 67
9760: PUSH
9761: LD_INT 1
9763: GREATER
9764: AND
9765: IFFALSE 9793
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9767: LD_INT 53
9769: PPUSH
9770: LD_INT 6
9772: PPUSH
9773: LD_INT 2
9775: PPUSH
9776: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9780: LD_INT 59
9782: PPUSH
9783: LD_INT 6
9785: PPUSH
9786: LD_INT 2
9788: PPUSH
9789: CALL_OW 322
// end ; if activeAttacks then
9793: LD_EXP 16
9797: IFFALSE 10216
// begin if missionStage = 2 then
9799: LD_EXP 15
9803: PUSH
9804: LD_INT 2
9806: EQUAL
9807: IFFALSE 9817
// strength := 1 ;
9809: LD_ADDR_VAR 0 5
9813: PUSH
9814: LD_INT 1
9816: ST_TO_ADDR
// if missionStage > 2 then
9817: LD_EXP 15
9821: PUSH
9822: LD_INT 2
9824: GREATER
9825: IFFALSE 9835
// strength := 2 ;
9827: LD_ADDR_VAR 0 5
9831: PUSH
9832: LD_INT 2
9834: ST_TO_ADDR
// if missionStage > 6 then
9835: LD_EXP 15
9839: PUSH
9840: LD_INT 6
9842: GREATER
9843: IFFALSE 9853
// strength := 3 ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_INT 3
9852: ST_TO_ADDR
// if missionStage > 10 then
9853: LD_EXP 15
9857: PUSH
9858: LD_INT 10
9860: GREATER
9861: IFFALSE 9871
// strength := 4 ;
9863: LD_ADDR_VAR 0 5
9867: PUSH
9868: LD_INT 4
9870: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9871: LD_ADDR_VAR 0 2
9875: PUSH
9876: LD_VAR 0 5
9880: PPUSH
9881: CALL 8364 0 1
9885: ST_TO_ADDR
// for i in tmp do
9886: LD_ADDR_VAR 0 1
9890: PUSH
9891: LD_VAR 0 2
9895: PUSH
9896: FOR_IN
9897: IFFALSE 10106
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9899: LD_VAR 0 1
9903: PPUSH
9904: LD_VAR 0 4
9908: PUSH
9909: LD_INT 1
9911: PPUSH
9912: LD_INT 2
9914: PPUSH
9915: CALL_OW 12
9919: ARRAY
9920: PPUSH
9921: LD_INT 0
9923: PPUSH
9924: CALL_OW 49
// if i = sewiVeh then
9928: LD_VAR 0 1
9932: PUSH
9933: LD_EXP 73
9937: EQUAL
9938: IFFALSE 9975
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9940: LD_ADDR_EXP 72
9944: PUSH
9945: LD_STRING Vsevolod
9947: PPUSH
9948: LD_INT 0
9950: PPUSH
9951: LD_STRING 
9953: PPUSH
9954: CALL 67536 0 3
9958: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9959: LD_EXP 72
9963: PPUSH
9964: LD_VAR 0 1
9968: PPUSH
9969: CALL_OW 52
// end else
9973: GO 10056
// if GetControl ( i ) = control_manual then
9975: LD_VAR 0 1
9979: PPUSH
9980: CALL_OW 263
9984: PUSH
9985: LD_INT 1
9987: EQUAL
9988: IFFALSE 10056
// begin uc_side := 6 ;
9990: LD_ADDR_OWVAR 20
9994: PUSH
9995: LD_INT 6
9997: ST_TO_ADDR
// uc_nation := 3 ;
9998: LD_ADDR_OWVAR 21
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// hc_gallery :=  ;
10006: LD_ADDR_OWVAR 33
10010: PUSH
10011: LD_STRING 
10013: ST_TO_ADDR
// hc_name :=  ;
10014: LD_ADDR_OWVAR 26
10018: PUSH
10019: LD_STRING 
10021: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10022: LD_INT 0
10024: PPUSH
10025: LD_INT 3
10027: PPUSH
10028: LD_INT 10
10030: PPUSH
10031: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10035: CALL_OW 44
10039: PPUSH
10040: LD_VAR 0 1
10044: PPUSH
10045: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10049: LD_INT 10
10051: PPUSH
10052: CALL_OW 67
// end ; if Prob ( 50 ) then
10056: LD_INT 50
10058: PPUSH
10059: CALL_OW 13
10063: IFFALSE 10082
// ComMoveXY ( i , 111 , 197 ) else
10065: LD_VAR 0 1
10069: PPUSH
10070: LD_INT 111
10072: PPUSH
10073: LD_INT 197
10075: PPUSH
10076: CALL_OW 111
10080: GO 10097
// ComMoveXY ( i , 91 , 165 ) ;
10082: LD_VAR 0 1
10086: PPUSH
10087: LD_INT 91
10089: PPUSH
10090: LD_INT 165
10092: PPUSH
10093: CALL_OW 111
// wait ( 0 0$2 ) ;
10097: LD_INT 70
10099: PPUSH
10100: CALL_OW 67
// end ;
10104: GO 9896
10106: POP
10107: POP
// repeat wait ( 0 0$1 ) ;
10108: LD_INT 35
10110: PPUSH
10111: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10115: LD_ADDR_VAR 0 1
10119: PUSH
10120: LD_VAR 0 2
10124: PPUSH
10125: LD_INT 50
10127: PUSH
10128: EMPTY
10129: LIST
10130: PPUSH
10131: CALL_OW 72
10135: PUSH
10136: FOR_IN
10137: IFFALSE 10196
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10139: LD_VAR 0 1
10143: PPUSH
10144: LD_INT 108
10146: PUSH
10147: LD_INT 153
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 105
10156: PUSH
10157: LD_INT 149
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 85
10166: PUSH
10167: LD_INT 131
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 64
10176: PUSH
10177: LD_INT 105
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: PPUSH
10190: CALL 107589 0 2
10194: GO 10136
10196: POP
10197: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10198: LD_VAR 0 2
10202: PPUSH
10203: LD_INT 50
10205: PUSH
10206: EMPTY
10207: LIST
10208: PPUSH
10209: CALL_OW 72
10213: NOT
10214: IFFALSE 10108
// end ; until russianDestroyed ;
10216: LD_EXP 21
10220: IFFALSE 9637
// end ;
10222: PPOPN 6
10224: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10225: LD_EXP 21
10229: NOT
10230: PUSH
10231: LD_EXP 15
10235: PUSH
10236: LD_INT 6
10238: GREATEREQUAL
10239: AND
10240: PUSH
10241: LD_INT 2
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL 62566 0 2
10251: NOT
10252: AND
10253: IFFALSE 11192
10255: GO 10257
10257: DISABLE
10258: LD_INT 0
10260: PPUSH
10261: PPUSH
10262: PPUSH
10263: PPUSH
// begin enable ;
10264: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 30
10277: PUSH
10278: LD_INT 3
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: PPUSH
10289: CALL_OW 69
10293: NOT
10294: IFFALSE 10298
// exit ;
10296: GO 11192
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10298: LD_ADDR_VAR 0 4
10302: PUSH
10303: LD_INT 22
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 30
10315: PUSH
10316: LD_INT 34
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PPUSH
10327: CALL_OW 69
10331: ST_TO_ADDR
// if Prob ( 40 ) then
10332: LD_INT 40
10334: PPUSH
10335: CALL_OW 13
10339: IFFALSE 10485
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10341: LD_INT 2
10343: PPUSH
10344: LD_INT 22
10346: PUSH
10347: LD_INT 3
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 49
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: PUSH
10362: LD_INT 22
10364: PUSH
10365: LD_INT 3
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 49
10373: PUSH
10374: EMPTY
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 22
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 49
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: PUSH
10398: LD_INT 24
10400: PUSH
10401: LD_INT 3
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 46
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 24
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 46
10427: PUSH
10428: EMPTY
10429: LIST
10430: LIST
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 24
10436: PUSH
10437: LD_INT 3
10439: PUSH
10440: LD_INT 3
10442: PUSH
10443: LD_INT 46
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: LIST
10450: LIST
10451: PUSH
10452: LD_INT 24
10454: PUSH
10455: LD_INT 3
10457: PUSH
10458: LD_INT 3
10460: PUSH
10461: LD_INT 46
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: PPUSH
10479: CALL 61148 0 2
// end else
10483: GO 10627
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10485: LD_INT 2
10487: PPUSH
10488: LD_INT 24
10490: PUSH
10491: LD_INT 3
10493: PUSH
10494: LD_INT 3
10496: PUSH
10497: LD_INT 47
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: PUSH
10506: LD_INT 24
10508: PUSH
10509: LD_INT 3
10511: PUSH
10512: LD_INT 3
10514: PUSH
10515: LD_INT 47
10517: PUSH
10518: EMPTY
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 24
10526: PUSH
10527: LD_INT 3
10529: PUSH
10530: LD_INT 3
10532: PUSH
10533: LD_INT 47
10535: PUSH
10536: EMPTY
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: PUSH
10542: LD_INT 24
10544: PUSH
10545: LD_INT 3
10547: PUSH
10548: LD_INT 3
10550: PUSH
10551: LD_INT 46
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: PUSH
10560: LD_INT 24
10562: PUSH
10563: LD_INT 3
10565: PUSH
10566: LD_INT 3
10568: PUSH
10569: LD_INT 46
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: PUSH
10578: LD_INT 24
10580: PUSH
10581: LD_INT 3
10583: PUSH
10584: LD_INT 3
10586: PUSH
10587: LD_INT 46
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 24
10598: PUSH
10599: LD_INT 3
10601: PUSH
10602: LD_INT 3
10604: PUSH
10605: LD_INT 46
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: PPUSH
10623: CALL 61148 0 2
// end ; repeat wait ( 0 0$1 ) ;
10627: LD_INT 35
10629: PPUSH
10630: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10634: LD_INT 2
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: CALL 62566 0 2
10644: PUSH
10645: LD_INT 7
10647: GREATEREQUAL
10648: IFFALSE 10627
// wait ( 0 0$10 ) ;
10650: LD_INT 350
10652: PPUSH
10653: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10657: LD_ADDR_VAR 0 2
10661: PUSH
10662: LD_INT 2
10664: PPUSH
10665: LD_INT 1
10667: PPUSH
10668: CALL 62566 0 2
10672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10673: LD_ADDR_EXP 119
10677: PUSH
10678: LD_EXP 119
10682: PPUSH
10683: LD_INT 2
10685: PPUSH
10686: LD_EXP 119
10690: PUSH
10691: LD_INT 2
10693: ARRAY
10694: PUSH
10695: LD_VAR 0 2
10699: DIFF
10700: PPUSH
10701: CALL_OW 1
10705: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10706: LD_ADDR_VAR 0 3
10710: PUSH
10711: LD_INT 0
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: CALL_OW 12
10721: ST_TO_ADDR
// if target then
10722: LD_VAR 0 3
10726: IFFALSE 10854
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10728: LD_ADDR_VAR 0 2
10732: PUSH
10733: LD_VAR 0 2
10737: PPUSH
10738: LD_INT 24
10740: PUSH
10741: LD_INT 250
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: PPUSH
10748: CALL_OW 72
10752: ST_TO_ADDR
// for i in tmp do
10753: LD_ADDR_VAR 0 1
10757: PUSH
10758: LD_VAR 0 2
10762: PUSH
10763: FOR_IN
10764: IFFALSE 10804
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10766: LD_VAR 0 1
10770: PPUSH
10771: LD_INT 139
10773: PPUSH
10774: LD_INT 89
10776: PPUSH
10777: CALL_OW 297
10781: PUSH
10782: LD_INT 9
10784: GREATER
10785: IFFALSE 10802
// ComMoveXY ( i , 139 , 89 ) ;
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 139
10794: PPUSH
10795: LD_INT 89
10797: PPUSH
10798: CALL_OW 111
10802: GO 10763
10804: POP
10805: POP
// wait ( 0 0$1 ) ;
10806: LD_INT 35
10808: PPUSH
10809: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10813: LD_VAR 0 2
10817: PPUSH
10818: LD_INT 92
10820: PUSH
10821: LD_INT 139
10823: PUSH
10824: LD_INT 89
10826: PUSH
10827: LD_INT 9
10829: PUSH
10830: EMPTY
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: PPUSH
10836: CALL_OW 72
10840: PUSH
10841: LD_VAR 0 2
10845: PUSH
10846: LD_INT 1
10848: MINUS
10849: GREATEREQUAL
10850: IFFALSE 10728
// end else
10852: GO 10996
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10854: LD_VAR 0 2
10858: PPUSH
10859: LD_VAR 0 4
10863: PUSH
10864: LD_INT 1
10866: ARRAY
10867: PPUSH
10868: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10872: LD_ADDR_VAR 0 2
10876: PUSH
10877: LD_VAR 0 2
10881: PPUSH
10882: LD_INT 24
10884: PUSH
10885: LD_INT 250
10887: PUSH
10888: EMPTY
10889: LIST
10890: LIST
10891: PPUSH
10892: CALL_OW 72
10896: ST_TO_ADDR
// for i in tmp do
10897: LD_ADDR_VAR 0 1
10901: PUSH
10902: LD_VAR 0 2
10906: PUSH
10907: FOR_IN
10908: IFFALSE 10948
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10910: LD_VAR 0 1
10914: PPUSH
10915: LD_INT 124
10917: PPUSH
10918: LD_INT 139
10920: PPUSH
10921: CALL_OW 297
10925: PUSH
10926: LD_INT 9
10928: GREATER
10929: IFFALSE 10946
// ComMoveXY ( i , 124 , 139 ) ;
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_INT 124
10938: PPUSH
10939: LD_INT 139
10941: PPUSH
10942: CALL_OW 111
10946: GO 10907
10948: POP
10949: POP
// wait ( 0 0$1 ) ;
10950: LD_INT 35
10952: PPUSH
10953: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10957: LD_VAR 0 2
10961: PPUSH
10962: LD_INT 92
10964: PUSH
10965: LD_INT 124
10967: PUSH
10968: LD_INT 139
10970: PUSH
10971: LD_INT 9
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: PPUSH
10980: CALL_OW 72
10984: PUSH
10985: LD_VAR 0 2
10989: PUSH
10990: LD_INT 1
10992: MINUS
10993: GREATEREQUAL
10994: IFFALSE 10872
// end ; repeat wait ( 0 0$1 ) ;
10996: LD_INT 35
10998: PPUSH
10999: CALL_OW 67
// for i in tmp do
11003: LD_ADDR_VAR 0 1
11007: PUSH
11008: LD_VAR 0 2
11012: PUSH
11013: FOR_IN
11014: IFFALSE 11183
// begin if GetLives ( i ) > 251 then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 256
11025: PUSH
11026: LD_INT 251
11028: GREATER
11029: IFFALSE 11154
// begin if GetWeapon ( i ) = ru_time_lapser then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 264
11040: PUSH
11041: LD_INT 49
11043: EQUAL
11044: IFFALSE 11100
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11046: LD_VAR 0 1
11050: PPUSH
11051: LD_INT 2
11053: PUSH
11054: LD_INT 22
11056: PUSH
11057: LD_INT 1
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 8
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: LIST
11078: PPUSH
11079: CALL_OW 69
11083: PPUSH
11084: LD_VAR 0 1
11088: PPUSH
11089: CALL_OW 74
11093: PPUSH
11094: CALL_OW 112
11098: GO 11152
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11100: LD_VAR 0 1
11104: PPUSH
11105: LD_INT 2
11107: PUSH
11108: LD_INT 22
11110: PUSH
11111: LD_INT 1
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 22
11120: PUSH
11121: LD_INT 8
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: LIST
11132: PPUSH
11133: CALL_OW 69
11137: PPUSH
11138: LD_VAR 0 1
11142: PPUSH
11143: CALL_OW 74
11147: PPUSH
11148: CALL_OW 115
// end else
11152: GO 11181
// if IsDead ( i ) then
11154: LD_VAR 0 1
11158: PPUSH
11159: CALL_OW 301
11163: IFFALSE 11181
// tmp := tmp diff i ;
11165: LD_ADDR_VAR 0 2
11169: PUSH
11170: LD_VAR 0 2
11174: PUSH
11175: LD_VAR 0 1
11179: DIFF
11180: ST_TO_ADDR
// end ;
11181: GO 11013
11183: POP
11184: POP
// until not tmp ;
11185: LD_VAR 0 2
11189: NOT
11190: IFFALSE 10996
// end ;
11192: PPOPN 4
11194: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11195: LD_EXP 15
11199: PUSH
11200: LD_INT 8
11202: GREATEREQUAL
11203: PUSH
11204: LD_OWVAR 67
11208: PUSH
11209: LD_INT 1
11211: GREATER
11212: AND
11213: IFFALSE 11397
11215: GO 11217
11217: DISABLE
11218: LD_INT 0
11220: PPUSH
11221: PPUSH
11222: PPUSH
// begin ruMobile := [ ] ;
11223: LD_ADDR_EXP 76
11227: PUSH
11228: EMPTY
11229: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11230: LD_ADDR_VAR 0 1
11234: PUSH
11235: DOUBLE
11236: LD_INT 1
11238: DEC
11239: ST_TO_ADDR
11240: LD_INT 3
11242: PUSH
11243: LD_INT 4
11245: PUSH
11246: LD_INT 5
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: LIST
11253: PUSH
11254: LD_OWVAR 67
11258: PUSH
11259: LD_INT 1
11261: MINUS
11262: ARRAY
11263: PUSH
11264: FOR_TO
11265: IFFALSE 11395
// begin uc_side := 3 ;
11267: LD_ADDR_OWVAR 20
11271: PUSH
11272: LD_INT 3
11274: ST_TO_ADDR
// uc_nation := 3 ;
11275: LD_ADDR_OWVAR 21
11279: PUSH
11280: LD_INT 3
11282: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11283: LD_INT 21
11285: PPUSH
11286: LD_INT 3
11288: PPUSH
11289: LD_INT 1
11291: PPUSH
11292: LD_INT 45
11294: PPUSH
11295: LD_INT 100
11297: PPUSH
11298: CALL 72551 0 5
// veh := CreateVehicle ;
11302: LD_ADDR_VAR 0 2
11306: PUSH
11307: CALL_OW 45
11311: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11312: LD_VAR 0 2
11316: PPUSH
11317: LD_INT 3
11319: PPUSH
11320: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11324: LD_VAR 0 2
11328: PPUSH
11329: LD_INT 29
11331: PPUSH
11332: LD_INT 0
11334: PPUSH
11335: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11339: LD_INT 0
11341: PPUSH
11342: LD_INT 10
11344: PPUSH
11345: CALL_OW 383
// un := CreateHuman ;
11349: LD_ADDR_VAR 0 3
11353: PUSH
11354: CALL_OW 44
11358: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11359: LD_VAR 0 3
11363: PPUSH
11364: LD_VAR 0 2
11368: PPUSH
11369: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11373: LD_ADDR_EXP 76
11377: PUSH
11378: LD_EXP 76
11382: PPUSH
11383: LD_VAR 0 2
11387: PPUSH
11388: CALL 104985 0 2
11392: ST_TO_ADDR
// end ;
11393: GO 11264
11395: POP
11396: POP
// end ;
11397: PPOPN 3
11399: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11400: LD_EXP 76
11404: IFFALSE 11912
11406: GO 11408
11408: DISABLE
11409: LD_INT 0
11411: PPUSH
11412: PPUSH
11413: PPUSH
// begin enable ;
11414: ENABLE
// if not ruMobile then
11415: LD_EXP 76
11419: NOT
11420: IFFALSE 11424
// exit ;
11422: GO 11912
// for i in ruMobile do
11424: LD_ADDR_VAR 0 1
11428: PUSH
11429: LD_EXP 76
11433: PUSH
11434: FOR_IN
11435: IFFALSE 11910
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11437: LD_VAR 0 1
11441: PPUSH
11442: CALL_OW 302
11446: NOT
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 255
11457: PUSH
11458: LD_INT 3
11460: NONEQUAL
11461: OR
11462: IFFALSE 11482
// begin ruMobile := ruMobile diff i ;
11464: LD_ADDR_EXP 76
11468: PUSH
11469: LD_EXP 76
11473: PUSH
11474: LD_VAR 0 1
11478: DIFF
11479: ST_TO_ADDR
// continue ;
11480: GO 11434
// end ; if GetTag ( i ) = 300 then
11482: LD_VAR 0 1
11486: PPUSH
11487: CALL_OW 110
11491: PUSH
11492: LD_INT 300
11494: EQUAL
11495: IFFALSE 11545
// begin ComMoveXY ( i , 160 , 81 ) ;
11497: LD_VAR 0 1
11501: PPUSH
11502: LD_INT 160
11504: PPUSH
11505: LD_INT 81
11507: PPUSH
11508: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11512: LD_VAR 0 1
11516: PPUSH
11517: LD_INT 160
11519: PPUSH
11520: LD_INT 81
11522: PPUSH
11523: CALL_OW 297
11527: PUSH
11528: LD_INT 8
11530: LESS
11531: IFFALSE 11545
// SetTag ( i , 301 ) ;
11533: LD_VAR 0 1
11537: PPUSH
11538: LD_INT 301
11540: PPUSH
11541: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11545: LD_VAR 0 1
11549: PPUSH
11550: CALL_OW 110
11554: PUSH
11555: LD_INT 301
11557: EQUAL
11558: IFFALSE 11601
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11560: LD_VAR 0 1
11564: PPUSH
11565: LD_INT 33
11567: PPUSH
11568: CALL_OW 308
11572: NOT
11573: IFFALSE 11589
// ComMoveToArea ( i , ruMobileParkingArea ) else
11575: LD_VAR 0 1
11579: PPUSH
11580: LD_INT 33
11582: PPUSH
11583: CALL_OW 113
11587: GO 11601
// SetTag ( i , 302 ) ;
11589: LD_VAR 0 1
11593: PPUSH
11594: LD_INT 302
11596: PPUSH
11597: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11601: LD_VAR 0 1
11605: PPUSH
11606: CALL_OW 110
11610: PUSH
11611: LD_INT 302
11613: EQUAL
11614: IFFALSE 11744
// begin if GetLives ( i ) < 1000 then
11616: LD_VAR 0 1
11620: PPUSH
11621: CALL_OW 256
11625: PUSH
11626: LD_INT 1000
11628: LESS
11629: IFFALSE 11721
// begin if not IsDrivenBy ( i ) then
11631: LD_VAR 0 1
11635: PPUSH
11636: CALL_OW 311
11640: NOT
11641: IFFALSE 11645
// continue ;
11643: GO 11434
// mech := IsDrivenBy ( i ) ;
11645: LD_ADDR_VAR 0 2
11649: PUSH
11650: LD_VAR 0 1
11654: PPUSH
11655: CALL_OW 311
11659: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11660: LD_VAR 0 2
11664: PPUSH
11665: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11669: LD_VAR 0 2
11673: PPUSH
11674: LD_VAR 0 1
11678: PPUSH
11679: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11683: LD_INT 35
11685: PPUSH
11686: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11690: LD_VAR 0 1
11694: PPUSH
11695: CALL_OW 256
11699: PUSH
11700: LD_INT 1000
11702: EQUAL
11703: IFFALSE 11683
// ComEnterUnit ( mech , i ) ;
11705: LD_VAR 0 2
11709: PPUSH
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 120
// end else
11719: GO 11744
// if IsDrivenBy ( i ) then
11721: LD_VAR 0 1
11725: PPUSH
11726: CALL_OW 311
11730: IFFALSE 11744
// SetTag ( i , 0 ) ;
11732: LD_VAR 0 1
11736: PPUSH
11737: LD_INT 0
11739: PPUSH
11740: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11744: LD_VAR 0 1
11748: PPUSH
11749: CALL_OW 110
11753: PUSH
11754: LD_INT 300
11756: LESS
11757: IFFALSE 11908
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_INT 4
11766: PPUSH
11767: LD_INT 81
11769: PUSH
11770: LD_INT 3
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: PPUSH
11777: CALL_OW 70
11781: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11782: LD_VAR 0 1
11786: PPUSH
11787: CALL_OW 256
11791: PUSH
11792: LD_INT 650
11794: LESS
11795: IFFALSE 11820
// begin ComStop ( i ) ;
11797: LD_VAR 0 1
11801: PPUSH
11802: CALL_OW 141
// SetTag ( i , 300 ) ;
11806: LD_VAR 0 1
11810: PPUSH
11811: LD_INT 300
11813: PPUSH
11814: CALL_OW 109
// continue ;
11818: GO 11434
// end ; if enemy then
11820: LD_VAR 0 3
11824: IFFALSE 11864
// begin if not HasTask ( i ) then
11826: LD_VAR 0 1
11830: PPUSH
11831: CALL_OW 314
11835: NOT
11836: IFFALSE 11862
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11838: LD_VAR 0 1
11842: PPUSH
11843: LD_VAR 0 3
11847: PPUSH
11848: LD_VAR 0 1
11852: PPUSH
11853: CALL_OW 74
11857: PPUSH
11858: CALL_OW 115
// end else
11862: GO 11908
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11864: LD_VAR 0 1
11868: PPUSH
11869: LD_INT 158
11871: PUSH
11872: LD_INT 61
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PUSH
11879: LD_INT 98
11881: PUSH
11882: LD_INT 100
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: LD_INT 78
11891: PUSH
11892: LD_INT 93
11894: PUSH
11895: EMPTY
11896: LIST
11897: LIST
11898: PUSH
11899: EMPTY
11900: LIST
11901: LIST
11902: LIST
11903: PPUSH
11904: CALL 107589 0 2
// end ; end ;
11908: GO 11434
11910: POP
11911: POP
// end ; end_of_file
11912: PPOPN 3
11914: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11915: LD_INT 0
11917: PPUSH
11918: PPUSH
11919: PPUSH
11920: PPUSH
11921: PPUSH
11922: PPUSH
// side := 7 ;
11923: LD_ADDR_VAR 0 5
11927: PUSH
11928: LD_INT 7
11930: ST_TO_ADDR
// uc_side := side ;
11931: LD_ADDR_OWVAR 20
11935: PUSH
11936: LD_VAR 0 5
11940: ST_TO_ADDR
// uc_nation := 1 ;
11941: LD_ADDR_OWVAR 21
11945: PUSH
11946: LD_INT 1
11948: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11949: LD_ADDR_VAR 0 2
11953: PUSH
11954: LD_INT 22
11956: PUSH
11957: LD_VAR 0 5
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 21
11968: PUSH
11969: LD_INT 3
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: PPUSH
11980: CALL_OW 69
11984: PUSH
11985: FOR_IN
11986: IFFALSE 12002
// SetBLevel ( i , 10 ) ;
11988: LD_VAR 0 2
11992: PPUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 241
12000: GO 11985
12002: POP
12003: POP
// base := GetBase ( al_depot ) ;
12004: LD_ADDR_VAR 0 4
12008: PUSH
12009: LD_INT 2
12011: PPUSH
12012: CALL_OW 274
12016: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12017: LD_ADDR_VAR 0 6
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_VAR 0 5
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: PUSH
12034: LD_INT 30
12036: PUSH
12037: LD_INT 34
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PPUSH
12048: CALL_OW 69
12052: ST_TO_ADDR
// if teleport then
12053: LD_VAR 0 6
12057: IFFALSE 12078
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12059: LD_VAR 0 6
12063: PUSH
12064: LD_INT 1
12066: ARRAY
12067: PPUSH
12068: LD_INT 262
12070: PPUSH
12071: LD_INT 119
12073: PPUSH
12074: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12078: LD_VAR 0 4
12082: PPUSH
12083: LD_INT 1
12085: PPUSH
12086: LD_INT 19500
12088: PPUSH
12089: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12093: LD_VAR 0 4
12097: PPUSH
12098: LD_INT 2
12100: PPUSH
12101: LD_INT 200
12103: PPUSH
12104: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12108: LD_VAR 0 4
12112: PPUSH
12113: LD_INT 3
12115: PPUSH
12116: LD_INT 650
12118: PPUSH
12119: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12123: LD_ADDR_EXP 77
12127: PUSH
12128: LD_STRING Roth
12130: PPUSH
12131: CALL_OW 25
12135: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12136: LD_ADDR_EXP 78
12140: PUSH
12141: LD_STRING Simms
12143: PPUSH
12144: LD_EXP 1
12148: NOT
12149: PPUSH
12150: LD_STRING 10c_
12152: PPUSH
12153: CALL 67536 0 3
12157: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12158: LD_EXP 78
12162: PPUSH
12163: LD_INT 4
12165: PPUSH
12166: CALL_OW 336
// if not Simms then
12170: LD_EXP 78
12174: NOT
12175: IFFALSE 12205
// begin uc_nation := 1 ;
12177: LD_ADDR_OWVAR 21
12181: PUSH
12182: LD_INT 1
12184: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12185: LD_INT 2
12187: PPUSH
12188: LD_INT 10
12190: PPUSH
12191: CALL_OW 384
// Simms := CreateHuman ;
12195: LD_ADDR_EXP 78
12199: PUSH
12200: CALL_OW 44
12204: ST_TO_ADDR
// end ; uc_nation := 3 ;
12205: LD_ADDR_OWVAR 21
12209: PUSH
12210: LD_INT 3
12212: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12213: LD_ADDR_EXP 79
12217: PUSH
12218: LD_STRING Kirilenkova
12220: PPUSH
12221: CALL_OW 25
12225: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12226: LD_ADDR_EXP 93
12230: PUSH
12231: LD_STRING Oblukov
12233: PPUSH
12234: CALL_OW 25
12238: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12239: LD_ADDR_EXP 80
12243: PUSH
12244: LD_STRING Dolgov
12246: PPUSH
12247: CALL_OW 25
12251: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12252: LD_ADDR_EXP 81
12256: PUSH
12257: LD_STRING Petrosyan
12259: PPUSH
12260: CALL_OW 25
12264: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12265: LD_ADDR_EXP 92
12269: PUSH
12270: LD_STRING Scholtze
12272: PPUSH
12273: CALL_OW 25
12277: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12278: LD_ADDR_EXP 91
12282: PUSH
12283: LD_STRING Kapitsova
12285: PPUSH
12286: CALL_OW 25
12290: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12291: LD_ADDR_EXP 82
12295: PUSH
12296: LD_STRING Petrovova
12298: PPUSH
12299: CALL_OW 25
12303: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12304: LD_ADDR_EXP 83
12308: PUSH
12309: LD_STRING Kuzmov
12311: PPUSH
12312: CALL_OW 25
12316: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12317: LD_ADDR_EXP 90
12321: PUSH
12322: LD_STRING Karamazov
12324: PPUSH
12325: CALL_OW 25
12329: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12330: LD_STRING 13_Lipshchin_1
12332: PPUSH
12333: LD_INT 0
12335: PPUSH
12336: CALL_OW 30
12340: IFFALSE 12355
// Lipshchin := NewCharacter ( Lipshchin ) ;
12342: LD_ADDR_EXP 84
12346: PUSH
12347: LD_STRING Lipshchin
12349: PPUSH
12350: CALL_OW 25
12354: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12355: LD_STRING 13_Titov_1
12357: PPUSH
12358: LD_INT 0
12360: PPUSH
12361: CALL_OW 30
12365: IFFALSE 12380
// Titov := NewCharacter ( Titov ) ;
12367: LD_ADDR_EXP 86
12371: PUSH
12372: LD_STRING Titov
12374: PPUSH
12375: CALL_OW 25
12379: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12380: LD_STRING 13_Gnyevko_1
12382: PPUSH
12383: LD_INT 0
12385: PPUSH
12386: CALL_OW 30
12390: IFFALSE 12405
// Gnyevko := NewCharacter ( Gnyevko ) ;
12392: LD_ADDR_EXP 85
12396: PUSH
12397: LD_STRING Gnyevko
12399: PPUSH
12400: CALL_OW 25
12404: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12405: LD_STRING 13_Xavier_1
12407: PPUSH
12408: LD_INT 0
12410: PPUSH
12411: CALL_OW 30
12415: IFFALSE 12430
// Xavier := NewCharacter ( Xavier2 ) ;
12417: LD_ADDR_EXP 87
12421: PUSH
12422: LD_STRING Xavier2
12424: PPUSH
12425: CALL_OW 25
12429: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12430: LD_STRING 13_Belkov_1
12432: PPUSH
12433: LD_INT 0
12435: PPUSH
12436: CALL_OW 30
12440: IFFALSE 12455
// Belkov := NewCharacter ( Belkov ) ;
12442: LD_ADDR_EXP 88
12446: PUSH
12447: LD_STRING Belkov
12449: PPUSH
12450: CALL_OW 25
12454: ST_TO_ADDR
// if not BurlakStatus then
12455: LD_EXP 9
12459: NOT
12460: IFFALSE 12475
// Burlak = NewCharacter ( Burlak ) ;
12462: LD_ADDR_EXP 89
12466: PUSH
12467: LD_STRING Burlak
12469: PPUSH
12470: CALL_OW 25
12474: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12475: LD_ADDR_VAR 0 3
12479: PUSH
12480: LD_EXP 77
12484: PUSH
12485: LD_EXP 79
12489: PUSH
12490: LD_EXP 93
12494: PUSH
12495: LD_EXP 80
12499: PUSH
12500: LD_EXP 81
12504: PUSH
12505: LD_EXP 92
12509: PUSH
12510: LD_EXP 91
12514: PUSH
12515: LD_EXP 82
12519: PUSH
12520: LD_EXP 83
12524: PUSH
12525: LD_EXP 90
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: LIST
12541: ST_TO_ADDR
// if Simms then
12542: LD_EXP 78
12546: IFFALSE 12564
// tmp := tmp ^ Simms ;
12548: LD_ADDR_VAR 0 3
12552: PUSH
12553: LD_VAR 0 3
12557: PUSH
12558: LD_EXP 78
12562: ADD
12563: ST_TO_ADDR
// if Titov then
12564: LD_EXP 86
12568: IFFALSE 12586
// tmp := tmp ^ Titov ;
12570: LD_ADDR_VAR 0 3
12574: PUSH
12575: LD_VAR 0 3
12579: PUSH
12580: LD_EXP 86
12584: ADD
12585: ST_TO_ADDR
// if Lipshchin then
12586: LD_EXP 84
12590: IFFALSE 12608
// tmp := tmp ^ Lipshchin ;
12592: LD_ADDR_VAR 0 3
12596: PUSH
12597: LD_VAR 0 3
12601: PUSH
12602: LD_EXP 84
12606: ADD
12607: ST_TO_ADDR
// if Gnyevko then
12608: LD_EXP 85
12612: IFFALSE 12630
// tmp := tmp ^ Gnyevko ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_EXP 85
12628: ADD
12629: ST_TO_ADDR
// if Xavier then
12630: LD_EXP 87
12634: IFFALSE 12652
// tmp := tmp ^ Xavier ;
12636: LD_ADDR_VAR 0 3
12640: PUSH
12641: LD_VAR 0 3
12645: PUSH
12646: LD_EXP 87
12650: ADD
12651: ST_TO_ADDR
// if Belkov then
12652: LD_EXP 88
12656: IFFALSE 12674
// tmp := tmp ^ Belkov ;
12658: LD_ADDR_VAR 0 3
12662: PUSH
12663: LD_VAR 0 3
12667: PUSH
12668: LD_EXP 88
12672: ADD
12673: ST_TO_ADDR
// if Burlak then
12674: LD_EXP 89
12678: IFFALSE 12696
// tmp := tmp ^ Burlak ;
12680: LD_ADDR_VAR 0 3
12684: PUSH
12685: LD_VAR 0 3
12689: PUSH
12690: LD_EXP 89
12694: ADD
12695: ST_TO_ADDR
// for i = 1 to 11 do
12696: LD_ADDR_VAR 0 2
12700: PUSH
12701: DOUBLE
12702: LD_INT 1
12704: DEC
12705: ST_TO_ADDR
12706: LD_INT 11
12708: PUSH
12709: FOR_TO
12710: IFFALSE 12776
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12712: LD_ADDR_OWVAR 21
12716: PUSH
12717: LD_INT 1
12719: PUSH
12720: LD_INT 3
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 1
12729: PPUSH
12730: LD_INT 2
12732: PPUSH
12733: CALL_OW 12
12737: ARRAY
12738: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12739: LD_INT 0
12741: PPUSH
12742: LD_VAR 0 2
12746: PUSH
12747: LD_INT 2
12749: DIV
12750: PPUSH
12751: LD_INT 10
12753: PPUSH
12754: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_VAR 0 3
12767: PUSH
12768: CALL_OW 44
12772: ADD
12773: ST_TO_ADDR
// end ;
12774: GO 12709
12776: POP
12777: POP
// for i in tmp do
12778: LD_ADDR_VAR 0 2
12782: PUSH
12783: LD_VAR 0 3
12787: PUSH
12788: FOR_IN
12789: IFFALSE 12814
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12791: LD_VAR 0 2
12795: PPUSH
12796: LD_INT 260
12798: PPUSH
12799: LD_INT 235
12801: PPUSH
12802: LD_INT 8
12804: PPUSH
12805: LD_INT 0
12807: PPUSH
12808: CALL_OW 50
12812: GO 12788
12814: POP
12815: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12816: LD_ADDR_EXP 100
12820: PUSH
12821: LD_EXP 100
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: LD_INT 22
12831: PUSH
12832: LD_VAR 0 5
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 3
12843: PUSH
12844: LD_INT 21
12846: PUSH
12847: LD_INT 2
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: EMPTY
12855: LIST
12856: LIST
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PPUSH
12862: CALL_OW 69
12866: PUSH
12867: LD_EXP 77
12871: PUSH
12872: LD_EXP 78
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: DIFF
12881: PPUSH
12882: CALL_OW 1
12886: ST_TO_ADDR
// uc_side := 0 ;
12887: LD_ADDR_OWVAR 20
12891: PUSH
12892: LD_INT 0
12894: ST_TO_ADDR
// uc_nation := 0 ;
12895: LD_ADDR_OWVAR 21
12899: PUSH
12900: LD_INT 0
12902: ST_TO_ADDR
// for i = 1 to 5 do
12903: LD_ADDR_VAR 0 2
12907: PUSH
12908: DOUBLE
12909: LD_INT 1
12911: DEC
12912: ST_TO_ADDR
12913: LD_INT 5
12915: PUSH
12916: FOR_TO
12917: IFFALSE 12954
// begin InitHc ;
12919: CALL_OW 19
// hc_class := class_apeman ;
12923: LD_ADDR_OWVAR 28
12927: PUSH
12928: LD_INT 12
12930: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12931: CALL_OW 44
12935: PPUSH
12936: LD_INT 299
12938: PPUSH
12939: LD_INT 229
12941: PPUSH
12942: LD_INT 10
12944: PPUSH
12945: LD_INT 0
12947: PPUSH
12948: CALL_OW 50
// end ;
12952: GO 12916
12954: POP
12955: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12956: LD_EXP 77
12960: PPUSH
12961: LD_INT 259
12963: PPUSH
12964: LD_INT 235
12966: PPUSH
12967: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12971: LD_EXP 77
12975: PPUSH
12976: LD_INT 262
12978: PPUSH
12979: LD_INT 235
12981: PPUSH
12982: CALL_OW 178
// if Simms then
12986: LD_EXP 78
12990: IFFALSE 13021
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12992: LD_EXP 78
12996: PPUSH
12997: LD_INT 262
12999: PPUSH
13000: LD_INT 235
13002: PPUSH
13003: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13007: LD_EXP 78
13011: PPUSH
13012: LD_EXP 77
13016: PPUSH
13017: CALL_OW 179
// end ; end ;
13021: LD_VAR 0 1
13025: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13026: LD_EXP 31
13030: PUSH
13031: LD_EXP 23
13035: NOT
13036: AND
13037: IFFALSE 13265
13039: GO 13041
13041: DISABLE
13042: LD_INT 0
13044: PPUSH
13045: PPUSH
13046: PPUSH
// begin enable ;
13047: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13048: LD_ADDR_VAR 0 2
13052: PUSH
13053: LD_INT 81
13055: PUSH
13056: LD_INT 7
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 2
13065: PUSH
13066: LD_INT 32
13068: PUSH
13069: LD_INT 3
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PUSH
13076: LD_INT 30
13078: PUSH
13079: LD_INT 30
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: PUSH
13086: LD_INT 30
13088: PUSH
13089: LD_INT 28
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 34
13098: PUSH
13099: LD_INT 49
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PUSH
13106: LD_INT 34
13108: PUSH
13109: LD_INT 10
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PUSH
13116: LD_INT 34
13118: PUSH
13119: LD_INT 8
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL_OW 69
13143: ST_TO_ADDR
// if not tmp then
13144: LD_VAR 0 2
13148: NOT
13149: IFFALSE 13153
// exit ;
13151: GO 13265
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13153: LD_VAR 0 2
13157: PPUSH
13158: LD_INT 34
13160: PUSH
13161: LD_INT 8
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PPUSH
13168: CALL_OW 72
13172: IFFALSE 13205
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13174: LD_ADDR_VAR 0 3
13178: PUSH
13179: LD_VAR 0 2
13183: PPUSH
13184: LD_INT 34
13186: PUSH
13187: LD_INT 8
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 72
13198: PUSH
13199: LD_INT 1
13201: ARRAY
13202: ST_TO_ADDR
13203: GO 13229
// target := tmp [ rand ( 1 , tmp ) ] ;
13205: LD_ADDR_VAR 0 3
13209: PUSH
13210: LD_VAR 0 2
13214: PUSH
13215: LD_INT 1
13217: PPUSH
13218: LD_VAR 0 2
13222: PPUSH
13223: CALL_OW 12
13227: ARRAY
13228: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13229: LD_VAR 0 3
13233: PPUSH
13234: CALL_OW 255
13238: PUSH
13239: LD_INT 1
13241: EQUAL
13242: IFFALSE 13253
// CenterNowOnUnits ( target ) ;
13244: LD_VAR 0 3
13248: PPUSH
13249: CALL_OW 87
// SetLives ( target , 0 ) ;
13253: LD_VAR 0 3
13257: PPUSH
13258: LD_INT 0
13260: PPUSH
13261: CALL_OW 234
// end ;
13265: PPOPN 3
13267: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13268: LD_EXP 23
13272: NOT
13273: PUSH
13274: LD_EXP 31
13278: AND
13279: IFFALSE 13805
13281: GO 13283
13283: DISABLE
13284: LD_INT 0
13286: PPUSH
13287: PPUSH
13288: PPUSH
// begin uc_side := 7 ;
13289: LD_ADDR_OWVAR 20
13293: PUSH
13294: LD_INT 7
13296: ST_TO_ADDR
// uc_nation := 1 ;
13297: LD_ADDR_OWVAR 21
13301: PUSH
13302: LD_INT 1
13304: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13305: LD_ADDR_VAR 0 3
13309: PUSH
13310: LD_INT 125
13312: PUSH
13313: LD_INT 163
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: PUSH
13320: LD_INT 185
13322: PUSH
13323: LD_INT 168
13325: PUSH
13326: EMPTY
13327: LIST
13328: LIST
13329: PUSH
13330: LD_INT 111
13332: PUSH
13333: LD_INT 97
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: LIST
13344: PPUSH
13345: CALL 105090 0 1
13349: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13350: LD_ADDR_EXP 94
13354: PUSH
13355: EMPTY
13356: ST_TO_ADDR
// for i = 1 to Difficulty do
13357: LD_ADDR_VAR 0 1
13361: PUSH
13362: DOUBLE
13363: LD_INT 1
13365: DEC
13366: ST_TO_ADDR
13367: LD_OWVAR 67
13371: PUSH
13372: FOR_TO
13373: IFFALSE 13531
// begin InitHc ;
13375: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13379: LD_INT 0
13381: PPUSH
13382: LD_INT 8
13384: PPUSH
13385: CALL_OW 381
// un := CreateHuman ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: CALL_OW 44
13398: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13399: LD_VAR 0 2
13403: PPUSH
13404: LD_INT 258
13406: PPUSH
13407: LD_INT 267
13409: PPUSH
13410: LD_INT 4
13412: PPUSH
13413: LD_INT 0
13415: PPUSH
13416: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13420: LD_ADDR_EXP 94
13424: PUSH
13425: LD_EXP 94
13429: PUSH
13430: LD_VAR 0 2
13434: UNION
13435: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13436: LD_VAR 0 2
13440: PPUSH
13441: LD_VAR 0 3
13445: PUSH
13446: LD_VAR 0 1
13450: ARRAY
13451: PUSH
13452: LD_INT 1
13454: ARRAY
13455: PPUSH
13456: LD_VAR 0 3
13460: PUSH
13461: LD_VAR 0 1
13465: ARRAY
13466: PUSH
13467: LD_INT 2
13469: ARRAY
13470: PPUSH
13471: LD_INT 4
13473: PPUSH
13474: LD_INT 1
13476: PPUSH
13477: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13481: LD_VAR 0 2
13485: PPUSH
13486: LD_VAR 0 3
13490: PUSH
13491: LD_VAR 0 1
13495: ARRAY
13496: PUSH
13497: LD_INT 1
13499: ARRAY
13500: PPUSH
13501: LD_VAR 0 3
13505: PUSH
13506: LD_VAR 0 1
13510: ARRAY
13511: PUSH
13512: LD_INT 2
13514: ARRAY
13515: PPUSH
13516: CALL_OW 171
// AddComInvisible ( un ) ;
13520: LD_VAR 0 2
13524: PPUSH
13525: CALL_OW 212
// end ;
13529: GO 13372
13531: POP
13532: POP
// repeat wait ( 0 0$20 ) ;
13533: LD_INT 700
13535: PPUSH
13536: CALL_OW 67
// for i in allianceSpecialForce do
13540: LD_ADDR_VAR 0 1
13544: PUSH
13545: LD_EXP 94
13549: PUSH
13550: FOR_IN
13551: IFFALSE 13790
// begin if IsInvisible ( i ) then
13553: LD_VAR 0 1
13557: PPUSH
13558: CALL_OW 571
13562: IFFALSE 13759
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13564: LD_ADDR_VAR 0 3
13568: PUSH
13569: LD_INT 22
13571: PUSH
13572: LD_INT 1
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: LD_INT 50
13581: PUSH
13582: EMPTY
13583: LIST
13584: PUSH
13585: LD_INT 56
13587: PUSH
13588: EMPTY
13589: LIST
13590: PUSH
13591: LD_INT 91
13593: PUSH
13594: LD_VAR 0 1
13598: PUSH
13599: LD_INT 25
13601: PUSH
13602: LD_INT 30
13604: PUSH
13605: LD_INT 35
13607: PUSH
13608: LD_INT 40
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: PUSH
13617: LD_OWVAR 67
13621: ARRAY
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 2
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 1
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 25
13643: PUSH
13644: LD_INT 2
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: LD_INT 25
13653: PUSH
13654: LD_INT 3
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PUSH
13661: LD_INT 25
13663: PUSH
13664: LD_INT 4
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: PUSH
13671: LD_INT 25
13673: PUSH
13674: LD_INT 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 25
13683: PUSH
13684: LD_INT 8
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 69
13711: ST_TO_ADDR
// if not tmp then
13712: LD_VAR 0 3
13716: NOT
13717: IFFALSE 13721
// continue ;
13719: GO 13550
// if Prob ( 30 * Difficulty ) then
13721: LD_INT 30
13723: PUSH
13724: LD_OWVAR 67
13728: MUL
13729: PPUSH
13730: CALL_OW 13
13734: IFFALSE 13759
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13736: LD_VAR 0 3
13740: PUSH
13741: LD_INT 1
13743: PPUSH
13744: LD_VAR 0 3
13748: PPUSH
13749: CALL_OW 12
13753: ARRAY
13754: PPUSH
13755: CALL 32858 0 1
// end ; if IsDead ( i ) then
13759: LD_VAR 0 1
13763: PPUSH
13764: CALL_OW 301
13768: IFFALSE 13788
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13770: LD_ADDR_EXP 94
13774: PUSH
13775: LD_EXP 94
13779: PUSH
13780: LD_VAR 0 1
13784: DIFF
13785: ST_TO_ADDR
// continue ;
13786: GO 13550
// end ; end ;
13788: GO 13550
13790: POP
13791: POP
// until allianceDestroyed or not allianceSpecialForce ;
13792: LD_EXP 23
13796: PUSH
13797: LD_EXP 94
13801: NOT
13802: OR
13803: IFFALSE 13533
// end ;
13805: PPOPN 3
13807: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13808: LD_EXP 23
13812: NOT
13813: PUSH
13814: LD_EXP 31
13818: AND
13819: IFFALSE 14769
13821: GO 13823
13823: DISABLE
13824: LD_INT 0
13826: PPUSH
13827: PPUSH
13828: PPUSH
13829: PPUSH
// begin enable ;
13830: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13831: LD_INT 22
13833: PUSH
13834: LD_INT 7
13836: PUSH
13837: EMPTY
13838: LIST
13839: LIST
13840: PUSH
13841: LD_INT 30
13843: PUSH
13844: LD_INT 3
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: EMPTY
13852: LIST
13853: LIST
13854: PPUSH
13855: CALL_OW 69
13859: NOT
13860: IFFALSE 13864
// exit ;
13862: GO 14769
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13864: LD_ADDR_VAR 0 4
13868: PUSH
13869: LD_INT 22
13871: PUSH
13872: LD_INT 7
13874: PUSH
13875: EMPTY
13876: LIST
13877: LIST
13878: PUSH
13879: LD_INT 30
13881: PUSH
13882: LD_INT 34
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: PUSH
13889: EMPTY
13890: LIST
13891: LIST
13892: PPUSH
13893: CALL_OW 69
13897: ST_TO_ADDR
// if Prob ( 40 ) then
13898: LD_INT 40
13900: PPUSH
13901: CALL_OW 13
13905: IFFALSE 14051
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13907: LD_INT 1
13909: PPUSH
13910: LD_INT 5
13912: PUSH
13913: LD_INT 3
13915: PUSH
13916: LD_INT 2
13918: PUSH
13919: LD_INT 6
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: PUSH
13928: LD_INT 5
13930: PUSH
13931: LD_INT 3
13933: PUSH
13934: LD_INT 2
13936: PUSH
13937: LD_INT 6
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 5
13948: PUSH
13949: LD_INT 3
13951: PUSH
13952: LD_INT 2
13954: PUSH
13955: LD_INT 6
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 5
13966: PUSH
13967: LD_INT 3
13969: PUSH
13970: LD_INT 2
13972: PUSH
13973: LD_INT 9
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: PUSH
13982: LD_INT 24
13984: PUSH
13985: LD_INT 3
13987: PUSH
13988: LD_INT 3
13990: PUSH
13991: LD_INT 45
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: PUSH
14000: LD_INT 24
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: LD_INT 3
14008: PUSH
14009: LD_INT 47
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: PUSH
14018: LD_INT 24
14020: PUSH
14021: LD_INT 3
14023: PUSH
14024: LD_INT 3
14026: PUSH
14027: LD_INT 45
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: PPUSH
14045: CALL 61148 0 2
// end else
14049: GO 14193
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14051: LD_INT 1
14053: PPUSH
14054: LD_INT 24
14056: PUSH
14057: LD_INT 3
14059: PUSH
14060: LD_INT 3
14062: PUSH
14063: LD_INT 47
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: PUSH
14072: LD_INT 24
14074: PUSH
14075: LD_INT 3
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: LD_INT 47
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 5
14092: PUSH
14093: LD_INT 3
14095: PUSH
14096: LD_INT 2
14098: PUSH
14099: LD_INT 9
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: PUSH
14108: LD_INT 5
14110: PUSH
14111: LD_INT 3
14113: PUSH
14114: LD_INT 2
14116: PUSH
14117: LD_INT 9
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: PUSH
14126: LD_INT 5
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: LD_INT 2
14134: PUSH
14135: LD_INT 9
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: PUSH
14144: LD_INT 24
14146: PUSH
14147: LD_INT 1
14149: PUSH
14150: LD_INT 3
14152: PUSH
14153: LD_INT 45
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 24
14164: PUSH
14165: LD_INT 1
14167: PUSH
14168: LD_INT 3
14170: PUSH
14171: LD_INT 45
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: PPUSH
14189: CALL 61148 0 2
// end ; repeat wait ( 0 0$1 ) ;
14193: LD_INT 35
14195: PPUSH
14196: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14200: LD_INT 1
14202: PPUSH
14203: LD_INT 1
14205: PPUSH
14206: CALL 62566 0 2
14210: PUSH
14211: LD_INT 7
14213: GREATEREQUAL
14214: IFFALSE 14193
// wait ( 0 0$10 ) ;
14216: LD_INT 350
14218: PPUSH
14219: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14223: LD_ADDR_VAR 0 2
14227: PUSH
14228: LD_INT 1
14230: PPUSH
14231: LD_INT 1
14233: PPUSH
14234: CALL 62566 0 2
14238: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14239: LD_ADDR_EXP 119
14243: PUSH
14244: LD_EXP 119
14248: PPUSH
14249: LD_INT 1
14251: PPUSH
14252: LD_EXP 119
14256: PUSH
14257: LD_INT 1
14259: ARRAY
14260: PUSH
14261: LD_VAR 0 2
14265: DIFF
14266: PPUSH
14267: CALL_OW 1
14271: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14272: LD_ADDR_VAR 0 3
14276: PUSH
14277: LD_INT 0
14279: PPUSH
14280: LD_INT 1
14282: PPUSH
14283: CALL_OW 12
14287: ST_TO_ADDR
// if target then
14288: LD_VAR 0 3
14292: IFFALSE 14458
// begin for i in tmp do
14294: LD_ADDR_VAR 0 1
14298: PUSH
14299: LD_VAR 0 2
14303: PUSH
14304: FOR_IN
14305: IFFALSE 14330
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14307: LD_VAR 0 1
14311: PPUSH
14312: LD_INT 179
14314: PPUSH
14315: LD_INT 209
14317: PPUSH
14318: LD_INT 8
14320: PPUSH
14321: LD_INT 1
14323: PPUSH
14324: CALL_OW 483
14328: GO 14304
14330: POP
14331: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14332: LD_ADDR_VAR 0 2
14336: PUSH
14337: LD_VAR 0 2
14341: PPUSH
14342: LD_INT 24
14344: PUSH
14345: LD_INT 250
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PPUSH
14352: CALL_OW 72
14356: ST_TO_ADDR
// for i in tmp do
14357: LD_ADDR_VAR 0 1
14361: PUSH
14362: LD_VAR 0 2
14366: PUSH
14367: FOR_IN
14368: IFFALSE 14408
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14370: LD_VAR 0 1
14374: PPUSH
14375: LD_INT 179
14377: PPUSH
14378: LD_INT 209
14380: PPUSH
14381: CALL_OW 297
14385: PUSH
14386: LD_INT 9
14388: GREATER
14389: IFFALSE 14406
// ComMoveXY ( i , 179 , 209 ) ;
14391: LD_VAR 0 1
14395: PPUSH
14396: LD_INT 179
14398: PPUSH
14399: LD_INT 209
14401: PPUSH
14402: CALL_OW 111
14406: GO 14367
14408: POP
14409: POP
// wait ( 0 0$1 ) ;
14410: LD_INT 35
14412: PPUSH
14413: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14417: LD_VAR 0 2
14421: PPUSH
14422: LD_INT 92
14424: PUSH
14425: LD_INT 179
14427: PUSH
14428: LD_INT 209
14430: PUSH
14431: LD_INT 9
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: PPUSH
14440: CALL_OW 72
14444: PUSH
14445: LD_VAR 0 2
14449: PUSH
14450: LD_INT 1
14452: MINUS
14453: GREATEREQUAL
14454: IFFALSE 14332
// end else
14456: GO 14620
// begin for i in tmp do
14458: LD_ADDR_VAR 0 1
14462: PUSH
14463: LD_VAR 0 2
14467: PUSH
14468: FOR_IN
14469: IFFALSE 14494
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14471: LD_VAR 0 1
14475: PPUSH
14476: LD_INT 285
14478: PPUSH
14479: LD_INT 163
14481: PPUSH
14482: LD_INT 8
14484: PPUSH
14485: LD_INT 1
14487: PPUSH
14488: CALL_OW 483
14492: GO 14468
14494: POP
14495: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14496: LD_ADDR_VAR 0 2
14500: PUSH
14501: LD_VAR 0 2
14505: PPUSH
14506: LD_INT 24
14508: PUSH
14509: LD_INT 250
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 72
14520: ST_TO_ADDR
// for i in tmp do
14521: LD_ADDR_VAR 0 1
14525: PUSH
14526: LD_VAR 0 2
14530: PUSH
14531: FOR_IN
14532: IFFALSE 14572
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14534: LD_VAR 0 1
14538: PPUSH
14539: LD_INT 285
14541: PPUSH
14542: LD_INT 163
14544: PPUSH
14545: CALL_OW 297
14549: PUSH
14550: LD_INT 9
14552: GREATER
14553: IFFALSE 14570
// ComMoveXY ( i , 285 , 163 ) ;
14555: LD_VAR 0 1
14559: PPUSH
14560: LD_INT 285
14562: PPUSH
14563: LD_INT 163
14565: PPUSH
14566: CALL_OW 111
14570: GO 14531
14572: POP
14573: POP
// wait ( 0 0$1 ) ;
14574: LD_INT 35
14576: PPUSH
14577: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14581: LD_VAR 0 2
14585: PPUSH
14586: LD_INT 92
14588: PUSH
14589: LD_INT 285
14591: PUSH
14592: LD_INT 163
14594: PUSH
14595: LD_INT 9
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: PPUSH
14604: CALL_OW 72
14608: PUSH
14609: LD_VAR 0 2
14613: PUSH
14614: LD_INT 1
14616: MINUS
14617: GREATEREQUAL
14618: IFFALSE 14496
// end ; repeat wait ( 0 0$1 ) ;
14620: LD_INT 35
14622: PPUSH
14623: CALL_OW 67
// for i in tmp do
14627: LD_ADDR_VAR 0 1
14631: PUSH
14632: LD_VAR 0 2
14636: PUSH
14637: FOR_IN
14638: IFFALSE 14760
// if GetLives ( i ) > 251 then
14640: LD_VAR 0 1
14644: PPUSH
14645: CALL_OW 256
14649: PUSH
14650: LD_INT 251
14652: GREATER
14653: IFFALSE 14742
// begin if GetWeapon ( i ) = ru_time_lapser then
14655: LD_VAR 0 1
14659: PPUSH
14660: CALL_OW 264
14664: PUSH
14665: LD_INT 49
14667: EQUAL
14668: IFFALSE 14706
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14670: LD_VAR 0 1
14674: PPUSH
14675: LD_INT 81
14677: PUSH
14678: LD_INT 7
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: PPUSH
14690: LD_VAR 0 1
14694: PPUSH
14695: CALL_OW 74
14699: PPUSH
14700: CALL_OW 112
14704: GO 14740
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14706: LD_VAR 0 1
14710: PPUSH
14711: LD_INT 81
14713: PUSH
14714: LD_INT 7
14716: PUSH
14717: EMPTY
14718: LIST
14719: LIST
14720: PPUSH
14721: CALL_OW 69
14725: PPUSH
14726: LD_VAR 0 1
14730: PPUSH
14731: CALL_OW 74
14735: PPUSH
14736: CALL_OW 115
// end else
14740: GO 14758
// tmp := tmp diff i ;
14742: LD_ADDR_VAR 0 2
14746: PUSH
14747: LD_VAR 0 2
14751: PUSH
14752: LD_VAR 0 1
14756: DIFF
14757: ST_TO_ADDR
14758: GO 14637
14760: POP
14761: POP
// until not tmp ;
14762: LD_VAR 0 2
14766: NOT
14767: IFFALSE 14620
// end ; end_of_file
14769: PPOPN 4
14771: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14772: LD_INT 0
14774: PPUSH
14775: PPUSH
14776: PPUSH
14777: PPUSH
// missionStage := 13 ;
14778: LD_ADDR_EXP 15
14782: PUSH
14783: LD_INT 13
14785: ST_TO_ADDR
// uc_side := 2 ;
14786: LD_ADDR_OWVAR 20
14790: PUSH
14791: LD_INT 2
14793: ST_TO_ADDR
// uc_nation := 2 ;
14794: LD_ADDR_OWVAR 21
14798: PUSH
14799: LD_INT 2
14801: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14802: LD_ADDR_EXP 95
14806: PUSH
14807: LD_STRING Omar
14809: PPUSH
14810: CALL_OW 25
14814: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14815: LD_EXP 95
14819: PPUSH
14820: LD_INT 4
14822: PPUSH
14823: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14827: LD_EXP 95
14831: PPUSH
14832: LD_INT 242
14834: PPUSH
14835: LD_INT 75
14837: PPUSH
14838: LD_INT 0
14840: PPUSH
14841: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14845: LD_ADDR_EXP 96
14849: PUSH
14850: LD_STRING Heike
14852: PPUSH
14853: CALL_OW 25
14857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14858: LD_INT 14
14860: PPUSH
14861: LD_INT 3
14863: PPUSH
14864: LD_INT 1
14866: PPUSH
14867: LD_INT 27
14869: PPUSH
14870: LD_INT 100
14872: PPUSH
14873: CALL 72551 0 5
// veh := CreateVehicle ;
14877: LD_ADDR_VAR 0 3
14881: PUSH
14882: CALL_OW 45
14886: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14887: LD_VAR 0 3
14891: PPUSH
14892: LD_INT 2
14894: NEG
14895: PPUSH
14896: CALL_OW 242
// SetDir ( veh , 4 ) ;
14900: LD_VAR 0 3
14904: PPUSH
14905: LD_INT 4
14907: PPUSH
14908: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14912: LD_VAR 0 3
14916: PPUSH
14917: LD_INT 241
14919: PPUSH
14920: LD_INT 72
14922: PPUSH
14923: LD_INT 0
14925: PPUSH
14926: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14930: LD_EXP 96
14934: PPUSH
14935: LD_VAR 0 3
14939: PPUSH
14940: CALL_OW 52
// if KhatamStatus then
14944: LD_EXP 8
14948: IFFALSE 15011
// begin Khatam := NewCharacter ( Khatam ) ;
14950: LD_ADDR_EXP 97
14954: PUSH
14955: LD_STRING Khatam
14957: PPUSH
14958: CALL_OW 25
14962: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14963: LD_EXP 97
14967: PPUSH
14968: LD_INT 245
14970: PPUSH
14971: LD_INT 78
14973: PPUSH
14974: LD_INT 3
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14984: LD_EXP 97
14988: PPUSH
14989: LD_INT 4
14991: PPUSH
14992: LD_INT 10
14994: PPUSH
14995: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14999: LD_EXP 97
15003: PPUSH
15004: LD_INT 4
15006: PPUSH
15007: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: DOUBLE
15017: LD_INT 1
15019: DEC
15020: ST_TO_ADDR
15021: LD_INT 2
15023: PUSH
15024: LD_INT 2
15026: PUSH
15027: LD_INT 3
15029: PUSH
15030: LD_INT 3
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: PUSH
15039: LD_OWVAR 67
15043: ARRAY
15044: PUSH
15045: FOR_TO
15046: IFFALSE 15112
// begin PrepareScientist ( false , 6 + Difficulty ) ;
15048: LD_INT 0
15050: PPUSH
15051: LD_INT 6
15053: PUSH
15054: LD_OWVAR 67
15058: PLUS
15059: PPUSH
15060: CALL_OW 384
// un := CreateHuman ;
15064: LD_ADDR_VAR 0 4
15068: PUSH
15069: CALL_OW 44
15073: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
15074: LD_VAR 0 4
15078: PPUSH
15079: LD_INT 28
15081: PUSH
15082: LD_INT 29
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PUSH
15089: LD_VAR 0 2
15093: PUSH
15094: LD_INT 2
15096: MOD
15097: PUSH
15098: LD_INT 1
15100: PLUS
15101: ARRAY
15102: PPUSH
15103: LD_INT 0
15105: PPUSH
15106: CALL_OW 49
// end ;
15110: GO 15045
15112: POP
15113: POP
// for i = 1 to 6 do
15114: LD_ADDR_VAR 0 2
15118: PUSH
15119: DOUBLE
15120: LD_INT 1
15122: DEC
15123: ST_TO_ADDR
15124: LD_INT 6
15126: PUSH
15127: FOR_TO
15128: IFFALSE 15173
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15130: LD_INT 0
15132: PPUSH
15133: LD_INT 6
15135: PUSH
15136: LD_OWVAR 67
15140: PLUS
15141: PPUSH
15142: CALL_OW 381
// un := CreateHuman ;
15146: LD_ADDR_VAR 0 4
15150: PUSH
15151: CALL_OW 44
15155: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15156: LD_VAR 0 4
15160: PPUSH
15161: LD_INT 32
15163: PPUSH
15164: LD_INT 0
15166: PPUSH
15167: CALL_OW 49
// end ;
15171: GO 15127
15173: POP
15174: POP
// for i = 1 to 3 do
15175: LD_ADDR_VAR 0 2
15179: PUSH
15180: DOUBLE
15181: LD_INT 1
15183: DEC
15184: ST_TO_ADDR
15185: LD_INT 3
15187: PUSH
15188: FOR_TO
15189: IFFALSE 15237
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15191: LD_INT 0
15193: PPUSH
15194: LD_INT 8
15196: PPUSH
15197: LD_INT 6
15199: PUSH
15200: LD_OWVAR 67
15204: PLUS
15205: PPUSH
15206: CALL_OW 380
// un := CreateHuman ;
15210: LD_ADDR_VAR 0 4
15214: PUSH
15215: CALL_OW 44
15219: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15220: LD_VAR 0 4
15224: PPUSH
15225: LD_INT 32
15227: PPUSH
15228: LD_INT 0
15230: PPUSH
15231: CALL_OW 49
// end ;
15235: GO 15188
15237: POP
15238: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15239: LD_ADDR_VAR 0 2
15243: PUSH
15244: DOUBLE
15245: LD_INT 1
15247: DEC
15248: ST_TO_ADDR
15249: LD_INT 2
15251: PUSH
15252: LD_INT 3
15254: PUSH
15255: LD_INT 4
15257: PUSH
15258: LD_INT 4
15260: PUSH
15261: EMPTY
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: PUSH
15267: LD_OWVAR 67
15271: ARRAY
15272: PUSH
15273: FOR_TO
15274: IFFALSE 15364
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15276: LD_INT 14
15278: PPUSH
15279: LD_INT 2
15281: PPUSH
15282: LD_INT 1
15284: PPUSH
15285: LD_INT 28
15287: PPUSH
15288: LD_INT 80
15290: PPUSH
15291: CALL 72551 0 5
// veh := CreateVehicle ;
15295: LD_ADDR_VAR 0 3
15299: PUSH
15300: CALL_OW 45
15304: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15305: LD_VAR 0 3
15309: PPUSH
15310: LD_INT 3
15312: PPUSH
15313: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15317: LD_VAR 0 3
15321: PPUSH
15322: LD_INT 29
15324: PPUSH
15325: LD_INT 0
15327: PPUSH
15328: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15332: LD_INT 0
15334: PPUSH
15335: LD_INT 6
15337: PUSH
15338: LD_OWVAR 67
15342: PLUS
15343: PPUSH
15344: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15348: CALL_OW 44
15352: PPUSH
15353: LD_VAR 0 3
15357: PPUSH
15358: CALL_OW 52
// end ;
15362: GO 15273
15364: POP
15365: POP
// for i = 1 to 5 + Difficulty do
15366: LD_ADDR_VAR 0 2
15370: PUSH
15371: DOUBLE
15372: LD_INT 1
15374: DEC
15375: ST_TO_ADDR
15376: LD_INT 5
15378: PUSH
15379: LD_OWVAR 67
15383: PLUS
15384: PUSH
15385: FOR_TO
15386: IFFALSE 15513
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15388: LD_INT 14
15390: PPUSH
15391: LD_INT 1
15393: PPUSH
15394: LD_INT 3
15396: PPUSH
15397: CALL_OW 12
15401: PPUSH
15402: LD_INT 1
15404: PPUSH
15405: LD_INT 28
15407: PUSH
15408: LD_INT 26
15410: PUSH
15411: LD_INT 27
15413: PUSH
15414: LD_INT 25
15416: PUSH
15417: EMPTY
15418: LIST
15419: LIST
15420: LIST
15421: LIST
15422: PUSH
15423: LD_VAR 0 2
15427: PUSH
15428: LD_INT 4
15430: MOD
15431: PUSH
15432: LD_INT 1
15434: PLUS
15435: ARRAY
15436: PPUSH
15437: LD_INT 80
15439: PPUSH
15440: CALL 72551 0 5
// veh := CreateVehicle ;
15444: LD_ADDR_VAR 0 3
15448: PUSH
15449: CALL_OW 45
15453: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15454: LD_VAR 0 3
15458: PPUSH
15459: LD_INT 4
15461: PPUSH
15462: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15466: LD_VAR 0 3
15470: PPUSH
15471: LD_INT 28
15473: PPUSH
15474: LD_INT 0
15476: PPUSH
15477: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15481: LD_INT 0
15483: PPUSH
15484: LD_INT 6
15486: PUSH
15487: LD_OWVAR 67
15491: PLUS
15492: PPUSH
15493: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15497: CALL_OW 44
15501: PPUSH
15502: LD_VAR 0 3
15506: PPUSH
15507: CALL_OW 52
// end ;
15511: GO 15385
15513: POP
15514: POP
// for i = 1 to Difficulty do
15515: LD_ADDR_VAR 0 2
15519: PUSH
15520: DOUBLE
15521: LD_INT 1
15523: DEC
15524: ST_TO_ADDR
15525: LD_OWVAR 67
15529: PUSH
15530: FOR_TO
15531: IFFALSE 15591
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15533: LD_INT 14
15535: PPUSH
15536: LD_INT 3
15538: PPUSH
15539: LD_INT 5
15541: PPUSH
15542: LD_INT 29
15544: PPUSH
15545: LD_INT 80
15547: PPUSH
15548: CALL 72551 0 5
// veh := CreateVehicle ;
15552: LD_ADDR_VAR 0 3
15556: PUSH
15557: CALL_OW 45
15561: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15562: LD_VAR 0 3
15566: PPUSH
15567: LD_INT 4
15569: PPUSH
15570: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15574: LD_VAR 0 3
15578: PPUSH
15579: LD_INT 28
15581: PPUSH
15582: LD_INT 0
15584: PPUSH
15585: CALL_OW 49
// end ;
15589: GO 15530
15591: POP
15592: POP
// end ;
15593: LD_VAR 0 1
15597: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15598: LD_INT 22
15600: PUSH
15601: LD_INT 2
15603: PUSH
15604: EMPTY
15605: LIST
15606: LIST
15607: PPUSH
15608: CALL_OW 69
15612: IFFALSE 15991
15614: GO 15616
15616: DISABLE
15617: LD_INT 0
15619: PPUSH
15620: PPUSH
15621: PPUSH
15622: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15623: LD_ADDR_VAR 0 3
15627: PUSH
15628: LD_INT 22
15630: PUSH
15631: LD_INT 2
15633: PUSH
15634: EMPTY
15635: LIST
15636: LIST
15637: PUSH
15638: LD_INT 25
15640: PUSH
15641: LD_INT 4
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: PUSH
15648: EMPTY
15649: LIST
15650: LIST
15651: PPUSH
15652: CALL_OW 69
15656: PUSH
15657: LD_EXP 97
15661: DIFF
15662: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15663: LD_ADDR_VAR 0 2
15667: PUSH
15668: LD_INT 22
15670: PUSH
15671: LD_INT 2
15673: PUSH
15674: EMPTY
15675: LIST
15676: LIST
15677: PPUSH
15678: CALL_OW 69
15682: PUSH
15683: LD_EXP 97
15687: PUSH
15688: LD_VAR 0 3
15692: UNION
15693: DIFF
15694: ST_TO_ADDR
// if Khatam then
15695: LD_EXP 97
15699: IFFALSE 15716
// ComMoveXY ( Khatam , 211 , 92 ) ;
15701: LD_EXP 97
15705: PPUSH
15706: LD_INT 211
15708: PPUSH
15709: LD_INT 92
15711: PPUSH
15712: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15716: LD_INT 197
15718: PPUSH
15719: LD_INT 80
15721: PPUSH
15722: LD_INT 2
15724: PPUSH
15725: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15729: LD_INT 213
15731: PPUSH
15732: LD_INT 90
15734: PPUSH
15735: LD_INT 2
15737: PPUSH
15738: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15742: LD_INT 215
15744: PPUSH
15745: LD_INT 129
15747: PPUSH
15748: LD_INT 2
15750: PPUSH
15751: CALL_OW 441
// if sci then
15755: LD_VAR 0 3
15759: IFFALSE 15780
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15761: LD_VAR 0 3
15765: PUSH
15766: LD_INT 1
15768: ARRAY
15769: PPUSH
15770: LD_INT 197
15772: PPUSH
15773: LD_INT 80
15775: PPUSH
15776: CALL_OW 158
// if sci > 1 then
15780: LD_VAR 0 3
15784: PUSH
15785: LD_INT 1
15787: GREATER
15788: IFFALSE 15809
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15790: LD_VAR 0 3
15794: PUSH
15795: LD_INT 2
15797: ARRAY
15798: PPUSH
15799: LD_INT 213
15801: PPUSH
15802: LD_INT 90
15804: PPUSH
15805: CALL_OW 158
// if sci > 2 then
15809: LD_VAR 0 3
15813: PUSH
15814: LD_INT 2
15816: GREATER
15817: IFFALSE 15838
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15819: LD_VAR 0 3
15823: PUSH
15824: LD_INT 3
15826: ARRAY
15827: PPUSH
15828: LD_INT 215
15830: PPUSH
15831: LD_INT 129
15833: PPUSH
15834: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15838: LD_VAR 0 2
15842: PPUSH
15843: LD_INT 195
15845: PPUSH
15846: LD_INT 102
15848: PPUSH
15849: CALL_OW 114
// wait ( 0 0$5 ) ;
15853: LD_INT 175
15855: PPUSH
15856: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15860: LD_INT 70
15862: PPUSH
15863: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
15867: LD_ADDR_VAR 0 4
15871: PUSH
15872: LD_INT 92
15874: PUSH
15875: LD_INT 195
15877: PUSH
15878: LD_INT 102
15880: PUSH
15881: LD_INT 36
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: LIST
15889: PUSH
15890: LD_INT 22
15892: PUSH
15893: LD_INT 1
15895: PUSH
15896: EMPTY
15897: LIST
15898: LIST
15899: PUSH
15900: EMPTY
15901: LIST
15902: LIST
15903: PPUSH
15904: CALL_OW 69
15908: ST_TO_ADDR
// for i in tmp do
15909: LD_ADDR_VAR 0 1
15913: PUSH
15914: LD_VAR 0 2
15918: PUSH
15919: FOR_IN
15920: IFFALSE 15971
// if enemy then
15922: LD_VAR 0 4
15926: IFFALSE 15954
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_VAR 0 4
15937: PPUSH
15938: LD_VAR 0 1
15942: PPUSH
15943: CALL_OW 74
15947: PPUSH
15948: CALL_OW 115
15952: GO 15969
// ComAgressiveMove ( i , 195 , 102 ) ;
15954: LD_VAR 0 1
15958: PPUSH
15959: LD_INT 195
15961: PPUSH
15962: LD_INT 102
15964: PPUSH
15965: CALL_OW 114
15969: GO 15919
15971: POP
15972: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15973: LD_VAR 0 2
15977: PPUSH
15978: LD_INT 50
15980: PUSH
15981: EMPTY
15982: LIST
15983: PPUSH
15984: CALL_OW 72
15988: NOT
15989: IFFALSE 15860
// end ; end_of_file
15991: PPOPN 4
15993: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15994: LD_INT 0
15996: PPUSH
15997: PPUSH
15998: PPUSH
15999: PPUSH
16000: PPUSH
16001: PPUSH
16002: PPUSH
16003: PPUSH
16004: PPUSH
// Video ( true ) ;
16005: LD_INT 1
16007: PPUSH
16008: CALL 104957 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
16012: LD_ADDR_VAR 0 5
16016: PUSH
16017: LD_INT 7
16019: PPUSH
16020: LD_INT 0
16022: PPUSH
16023: CALL_OW 517
16027: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
16028: LD_ADDR_VAR 0 2
16032: PUSH
16033: DOUBLE
16034: LD_INT 1
16036: DEC
16037: ST_TO_ADDR
16038: LD_VAR 0 5
16042: PUSH
16043: LD_INT 1
16045: ARRAY
16046: PUSH
16047: FOR_TO
16048: IFFALSE 16093
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
16050: LD_VAR 0 5
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PUSH
16059: LD_VAR 0 2
16063: ARRAY
16064: PPUSH
16065: LD_VAR 0 5
16069: PUSH
16070: LD_INT 2
16072: ARRAY
16073: PUSH
16074: LD_VAR 0 2
16078: ARRAY
16079: PPUSH
16080: LD_INT 1
16082: PPUSH
16083: LD_INT 15
16085: NEG
16086: PPUSH
16087: CALL 104871 0 4
16091: GO 16047
16093: POP
16094: POP
// CenterNowOnUnits ( Powell ) ;
16095: LD_EXP 60
16099: PPUSH
16100: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
16104: LD_ADDR_VAR 0 5
16108: PUSH
16109: LD_EXP 58
16113: PUSH
16114: EMPTY
16115: LIST
16116: ST_TO_ADDR
// if GirlNewVeh then
16117: LD_EXP 59
16121: IFFALSE 16139
// tmp := tmp ^ GirlNewVeh ;
16123: LD_ADDR_VAR 0 5
16127: PUSH
16128: LD_VAR 0 5
16132: PUSH
16133: LD_EXP 59
16137: ADD
16138: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16139: LD_VAR 0 5
16143: PPUSH
16144: LD_INT 60
16146: PPUSH
16147: LD_INT 109
16149: PPUSH
16150: CALL_OW 111
// if KappaStatus then
16154: LD_EXP 2
16158: IFFALSE 16210
// begin Say ( JMM , D1nT-JMM-1 ) ;
16160: LD_EXP 40
16164: PPUSH
16165: LD_STRING D1nT-JMM-1
16167: PPUSH
16168: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16172: LD_EXP 60
16176: PPUSH
16177: LD_STRING D1T-Pow-1
16179: PPUSH
16180: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16184: LD_EXP 40
16188: PPUSH
16189: LD_STRING D1T-JMM-2
16191: PPUSH
16192: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16196: LD_EXP 60
16200: PPUSH
16201: LD_STRING D1T-Pow-2
16203: PPUSH
16204: CALL_OW 88
// end else
16208: GO 16416
// if JMMGirlStatus then
16210: LD_EXP 6
16214: IFFALSE 16359
// begin Say ( JMM , D1T-JMM-1 ) ;
16216: LD_EXP 40
16220: PPUSH
16221: LD_STRING D1T-JMM-1
16223: PPUSH
16224: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16228: LD_EXP 60
16232: PPUSH
16233: LD_STRING D1T-Pow-1
16235: PPUSH
16236: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16240: LD_EXP 40
16244: PPUSH
16245: LD_STRING D1T-JMM-3
16247: PPUSH
16248: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16252: LD_EXP 60
16256: PPUSH
16257: LD_STRING D1T-Pow-3
16259: PPUSH
16260: CALL_OW 88
// if JMMGirl then
16264: LD_EXP 7
16268: IFFALSE 16357
// begin case JMMGirl of 1 :
16270: LD_EXP 7
16274: PUSH
16275: LD_INT 1
16277: DOUBLE
16278: EQUAL
16279: IFTRUE 16283
16281: GO 16298
16283: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16284: LD_EXP 41
16288: PPUSH
16289: LD_STRING D1T-Joan-3
16291: PPUSH
16292: CALL_OW 88
16296: GO 16345
16298: LD_INT 2
16300: DOUBLE
16301: EQUAL
16302: IFTRUE 16306
16304: GO 16321
16306: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16307: LD_EXP 43
16311: PPUSH
16312: LD_STRING D1T-Lisa-3
16314: PPUSH
16315: CALL_OW 88
16319: GO 16345
16321: LD_INT 3
16323: DOUBLE
16324: EQUAL
16325: IFTRUE 16329
16327: GO 16344
16329: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16330: LD_EXP 55
16334: PPUSH
16335: LD_STRING D1T-Con-3
16337: PPUSH
16338: CALL_OW 88
16342: GO 16345
16344: POP
// Say ( Powell , D1T-Pow-4 ) ;
16345: LD_EXP 60
16349: PPUSH
16350: LD_STRING D1T-Pow-4
16352: PPUSH
16353: CALL_OW 88
// end ; end else
16357: GO 16416
// if not FastEnd then
16359: LD_EXP 11
16363: NOT
16364: IFFALSE 16392
// begin Say ( JMM , D1T-JMM-4 ) ;
16366: LD_EXP 40
16370: PPUSH
16371: LD_STRING D1T-JMM-4
16373: PPUSH
16374: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16378: LD_EXP 60
16382: PPUSH
16383: LD_STRING D1T-Pow-5
16385: PPUSH
16386: CALL_OW 88
// end else
16390: GO 16416
// begin Say ( JMM , D1nT-JMM-1 ) ;
16392: LD_EXP 40
16396: PPUSH
16397: LD_STRING D1nT-JMM-1
16399: PPUSH
16400: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16404: LD_EXP 60
16408: PPUSH
16409: LD_STRING D1nT-Pow-1
16411: PPUSH
16412: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16416: LD_INT 3
16418: PPUSH
16419: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16423: LD_EXP 58
16427: PPUSH
16428: CALL_OW 314
16432: NOT
16433: IFFALSE 16416
// ComExitVehicle ( JMM ) ;
16435: LD_EXP 40
16439: PPUSH
16440: CALL_OW 121
// repeat wait ( 3 ) ;
16444: LD_INT 3
16446: PPUSH
16447: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16451: LD_EXP 40
16455: PPUSH
16456: CALL_OW 310
16460: NOT
16461: IFFALSE 16444
// ComMoveXY ( JMM , 60 , 94 ) ;
16463: LD_EXP 40
16467: PPUSH
16468: LD_INT 60
16470: PPUSH
16471: LD_INT 94
16473: PPUSH
16474: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16478: LD_EXP 40
16482: PPUSH
16483: LD_EXP 60
16487: PPUSH
16488: CALL_OW 179
// if Joan then
16492: LD_EXP 41
16496: IFFALSE 16550
// begin ComExitVehicle ( Joan ) ;
16498: LD_EXP 41
16502: PPUSH
16503: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16507: LD_EXP 41
16511: PPUSH
16512: LD_INT 35
16514: PPUSH
16515: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16519: LD_EXP 41
16523: PPUSH
16524: LD_INT 65
16526: PPUSH
16527: LD_INT 104
16529: PPUSH
16530: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16534: LD_EXP 41
16538: PPUSH
16539: LD_EXP 40
16543: PPUSH
16544: CALL_OW 179
// end else
16548: GO 16684
// if Lisa and JMMGirl = 2 then
16550: LD_EXP 43
16554: PUSH
16555: LD_EXP 7
16559: PUSH
16560: LD_INT 2
16562: EQUAL
16563: AND
16564: IFFALSE 16618
// begin ComExitVehicle ( Lisa ) ;
16566: LD_EXP 43
16570: PPUSH
16571: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16575: LD_EXP 43
16579: PPUSH
16580: LD_INT 35
16582: PPUSH
16583: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16587: LD_EXP 43
16591: PPUSH
16592: LD_INT 65
16594: PPUSH
16595: LD_INT 104
16597: PPUSH
16598: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16602: LD_EXP 43
16606: PPUSH
16607: LD_EXP 40
16611: PPUSH
16612: CALL_OW 179
// end else
16616: GO 16684
// if Connie and JMMGirl = 3 then
16618: LD_EXP 55
16622: PUSH
16623: LD_EXP 7
16627: PUSH
16628: LD_INT 3
16630: EQUAL
16631: AND
16632: IFFALSE 16684
// begin ComExitVehicle ( Connie ) ;
16634: LD_EXP 55
16638: PPUSH
16639: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16643: LD_EXP 55
16647: PPUSH
16648: LD_INT 35
16650: PPUSH
16651: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16655: LD_EXP 55
16659: PPUSH
16660: LD_INT 65
16662: PPUSH
16663: LD_INT 104
16665: PPUSH
16666: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16670: LD_EXP 55
16674: PPUSH
16675: LD_EXP 40
16679: PPUSH
16680: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16684: LD_INT 35
16686: PPUSH
16687: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16691: LD_EXP 40
16695: PPUSH
16696: LD_EXP 60
16700: PPUSH
16701: CALL_OW 296
16705: PUSH
16706: LD_INT 8
16708: LESS
16709: IFFALSE 16684
// wait ( 0 0$0.5 ) ;
16711: LD_INT 18
16713: PPUSH
16714: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16718: LD_EXP 40
16722: PPUSH
16723: LD_STRING D1-JMM-1
16725: PPUSH
16726: CALL_OW 88
// async ;
16730: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16731: LD_EXP 60
16735: PPUSH
16736: LD_STRING D1-Pow-1
16738: PPUSH
16739: CALL_OW 88
// if not dialogue_skipped then
16743: LD_OWVAR 59
16747: NOT
16748: IFFALSE 16757
// wait ( 0 0$2 ) ;
16750: LD_INT 70
16752: PPUSH
16753: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16757: LD_INT 170
16759: PPUSH
16760: LD_INT 99
16762: PPUSH
16763: LD_INT 1
16765: PPUSH
16766: LD_INT 6
16768: NEG
16769: PPUSH
16770: CALL 104871 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16774: LD_INT 174
16776: PPUSH
16777: LD_INT 115
16779: PPUSH
16780: LD_INT 1
16782: PPUSH
16783: LD_INT 6
16785: NEG
16786: PPUSH
16787: CALL 104871 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16791: LD_INT 169
16793: PPUSH
16794: LD_INT 71
16796: PPUSH
16797: LD_INT 1
16799: PPUSH
16800: LD_INT 6
16802: NEG
16803: PPUSH
16804: CALL 104871 0 4
// if not dialogue_skipped then
16808: LD_OWVAR 59
16812: NOT
16813: IFFALSE 16832
// begin CenterOnXY ( 170 , 99 ) ;
16815: LD_INT 170
16817: PPUSH
16818: LD_INT 99
16820: PPUSH
16821: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16825: LD_INT 80
16827: PPUSH
16828: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16832: LD_INT 75
16834: PPUSH
16835: LD_INT 53
16837: PPUSH
16838: LD_INT 1
16840: PPUSH
16841: LD_INT 9
16843: NEG
16844: PPUSH
16845: CALL 104871 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16849: LD_INT 54
16851: PPUSH
16852: LD_INT 42
16854: PPUSH
16855: LD_INT 1
16857: PPUSH
16858: LD_INT 9
16860: NEG
16861: PPUSH
16862: CALL 104871 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16866: LD_INT 62
16868: PPUSH
16869: LD_INT 51
16871: PPUSH
16872: LD_INT 1
16874: PPUSH
16875: LD_INT 9
16877: NEG
16878: PPUSH
16879: CALL 104871 0 4
// if not dialogue_skipped then
16883: LD_OWVAR 59
16887: NOT
16888: IFFALSE 16907
// begin CenterOnXY ( 75 , 53 ) ;
16890: LD_INT 75
16892: PPUSH
16893: LD_INT 53
16895: PPUSH
16896: CALL_OW 84
// wait ( 0 0$4 ) ;
16900: LD_INT 140
16902: PPUSH
16903: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16907: LD_EXP 60
16911: PPUSH
16912: CALL_OW 87
// if not dialogue_skipped then
16916: LD_OWVAR 59
16920: NOT
16921: IFFALSE 16930
// wait ( 0 0$2 ) ;
16923: LD_INT 70
16925: PPUSH
16926: CALL_OW 67
// sync ;
16930: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16931: LD_EXP 40
16935: PPUSH
16936: LD_STRING D1-JMM-2
16938: PPUSH
16939: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16943: LD_EXP 60
16947: PPUSH
16948: LD_STRING D1-Pow-2
16950: PPUSH
16951: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16955: LD_EXP 40
16959: PPUSH
16960: LD_STRING D1-JMM-3
16962: PPUSH
16963: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16967: LD_EXP 60
16971: PPUSH
16972: LD_STRING D1-Pow-3
16974: PPUSH
16975: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16979: LD_EXP 40
16983: PPUSH
16984: LD_STRING D1-JMM-4
16986: PPUSH
16987: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16991: LD_EXP 60
16995: PPUSH
16996: LD_STRING D1-Pow-4
16998: PPUSH
16999: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
17003: LD_EXP 40
17007: PPUSH
17008: LD_STRING D1-JMM-5
17010: PPUSH
17011: CALL_OW 88
// async ;
17015: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
17016: LD_EXP 60
17020: PPUSH
17021: LD_STRING D1-Pow-5
17023: PPUSH
17024: CALL_OW 88
// if not dialogue_skipped then
17028: LD_OWVAR 59
17032: NOT
17033: IFFALSE 17042
// wait ( 0 0$3.6 ) ;
17035: LD_INT 126
17037: PPUSH
17038: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
17042: LD_INT 134
17044: PPUSH
17045: LD_INT 210
17047: PPUSH
17048: LD_INT 1
17050: PPUSH
17051: LD_INT 11
17053: NEG
17054: PPUSH
17055: CALL 104871 0 4
// if not dialogue_skipped then
17059: LD_OWVAR 59
17063: NOT
17064: IFFALSE 17083
// begin CenterOnXY ( 134 , 210 ) ;
17066: LD_INT 134
17068: PPUSH
17069: LD_INT 210
17071: PPUSH
17072: CALL_OW 84
// wait ( 0 0$2 ) ;
17076: LD_INT 70
17078: PPUSH
17079: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
17083: LD_INT 101
17085: PPUSH
17086: LD_INT 159
17088: PPUSH
17089: LD_INT 1
17091: PPUSH
17092: LD_INT 10
17094: NEG
17095: PPUSH
17096: CALL 104871 0 4
// if not dialogue_skipped then
17100: LD_OWVAR 59
17104: NOT
17105: IFFALSE 17124
// begin CenterOnXY ( 101 , 159 ) ;
17107: LD_INT 101
17109: PPUSH
17110: LD_INT 159
17112: PPUSH
17113: CALL_OW 84
// wait ( 0 0$2 ) ;
17117: LD_INT 70
17119: PPUSH
17120: CALL_OW 67
// end ; sync ;
17124: SYNC
// CenterNowOnUnits ( Powell ) ;
17125: LD_EXP 60
17129: PPUSH
17130: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17134: LD_ADDR_VAR 0 6
17138: PUSH
17139: LD_INT 1
17141: PUSH
17142: LD_INT 2
17144: PUSH
17145: LD_INT 3
17147: PUSH
17148: LD_INT 4
17150: PUSH
17151: LD_INT 5
17153: PUSH
17154: LD_INT 6
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: LIST
17164: ST_TO_ADDR
// if not dialogue_skipped then
17165: LD_OWVAR 59
17169: NOT
17170: IFFALSE 17339
// begin game_speed := 4 ;
17172: LD_ADDR_OWVAR 65
17176: PUSH
17177: LD_INT 4
17179: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17180: LD_INT 210
17182: PPUSH
17183: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17187: LD_ADDR_VAR 0 7
17191: PUSH
17192: LD_STRING Q1
17194: PPUSH
17195: LD_VAR 0 6
17199: PPUSH
17200: CALL_OW 98
17204: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17205: LD_ADDR_VAR 0 7
17209: PUSH
17210: LD_STRING Q1
17212: PPUSH
17213: LD_VAR 0 6
17217: PPUSH
17218: CALL_OW 98
17222: ST_TO_ADDR
// options := options diff dec ;
17223: LD_ADDR_VAR 0 6
17227: PUSH
17228: LD_VAR 0 6
17232: PUSH
17233: LD_VAR 0 7
17237: DIFF
17238: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17239: LD_VAR 0 7
17243: PPUSH
17244: LD_VAR 0 6
17248: PPUSH
17249: CALL 18903 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17253: LD_VAR 0 7
17257: PUSH
17258: LD_INT 5
17260: PUSH
17261: LD_INT 6
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: IN
17268: PUSH
17269: LD_VAR 0 6
17273: PUSH
17274: LD_INT 2
17276: EQUAL
17277: OR
17278: IFFALSE 17205
// if not ( dec in [ 5 , 6 ] ) then
17280: LD_VAR 0 7
17284: PUSH
17285: LD_INT 5
17287: PUSH
17288: LD_INT 6
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: IN
17295: NOT
17296: IFFALSE 17339
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17298: LD_ADDR_VAR 0 7
17302: PUSH
17303: LD_STRING Q1a
17305: PPUSH
17306: LD_INT 1
17308: PUSH
17309: LD_INT 2
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PPUSH
17316: CALL_OW 98
17320: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 4
17328: PLUS
17329: PPUSH
17330: LD_VAR 0 6
17334: PPUSH
17335: CALL 18903 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17339: LD_INT 81
17341: PPUSH
17342: LD_INT 127
17344: PPUSH
17345: CALL_OW 84
// amount := 8 ;
17349: LD_ADDR_VAR 0 8
17353: PUSH
17354: LD_INT 8
17356: ST_TO_ADDR
// macmilan_squad := [ ] ;
17357: LD_ADDR_VAR 0 9
17361: PUSH
17362: EMPTY
17363: ST_TO_ADDR
// if vip < amount then
17364: LD_EXP 61
17368: PUSH
17369: LD_VAR 0 8
17373: LESS
17374: IFFALSE 17418
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17376: LD_ADDR_VAR 0 5
17380: PUSH
17381: LD_EXP 61
17385: PUSH
17386: LD_INT 22
17388: PUSH
17389: LD_INT 4
17391: PUSH
17392: EMPTY
17393: LIST
17394: LIST
17395: PUSH
17396: LD_INT 21
17398: PUSH
17399: LD_INT 1
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: PUSH
17406: EMPTY
17407: LIST
17408: LIST
17409: PPUSH
17410: CALL_OW 69
17414: UNION
17415: ST_TO_ADDR
17416: GO 17428
// tmp := vip ;
17418: LD_ADDR_VAR 0 5
17422: PUSH
17423: LD_EXP 61
17427: ST_TO_ADDR
// tmp := tmp diff Powell ;
17428: LD_ADDR_VAR 0 5
17432: PUSH
17433: LD_VAR 0 5
17437: PUSH
17438: LD_EXP 60
17442: DIFF
17443: ST_TO_ADDR
// if tmp < amount then
17444: LD_VAR 0 5
17448: PUSH
17449: LD_VAR 0 8
17453: LESS
17454: IFFALSE 17466
// amount := tmp ;
17456: LD_ADDR_VAR 0 8
17460: PUSH
17461: LD_VAR 0 5
17465: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17466: LD_VAR 0 5
17470: PUSH
17471: LD_INT 1
17473: ARRAY
17474: PPUSH
17475: CALL_OW 257
17479: PUSH
17480: LD_INT 2
17482: NONEQUAL
17483: IFFALSE 17581
// begin if IsInUnit ( tmp [ 1 ] ) then
17485: LD_VAR 0 5
17489: PUSH
17490: LD_INT 1
17492: ARRAY
17493: PPUSH
17494: CALL_OW 310
17498: IFFALSE 17513
// ComExitBuilding ( tmp [ 1 ] ) ;
17500: LD_VAR 0 5
17504: PUSH
17505: LD_INT 1
17507: ARRAY
17508: PPUSH
17509: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17513: LD_INT 387
17515: PPUSH
17516: CALL_OW 313
17520: PUSH
17521: LD_INT 6
17523: EQUAL
17524: IFFALSE 17549
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17526: LD_INT 387
17528: PPUSH
17529: CALL_OW 313
17533: PUSH
17534: LD_INT 1
17536: ARRAY
17537: PPUSH
17538: CALL_OW 122
// wait ( 3 ) ;
17542: LD_INT 3
17544: PPUSH
17545: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17549: LD_VAR 0 5
17553: PUSH
17554: LD_INT 1
17556: ARRAY
17557: PPUSH
17558: LD_INT 387
17560: PPUSH
17561: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17565: LD_VAR 0 5
17569: PUSH
17570: LD_INT 1
17572: ARRAY
17573: PPUSH
17574: LD_INT 2
17576: PPUSH
17577: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17581: LD_EXP 40
17585: PPUSH
17586: LD_INT 82
17588: PPUSH
17589: LD_INT 129
17591: PPUSH
17592: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17596: LD_EXP 40
17600: PPUSH
17601: LD_EXP 60
17605: PPUSH
17606: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17610: LD_INT 22
17612: PUSH
17613: LD_INT 1
17615: PUSH
17616: EMPTY
17617: LIST
17618: LIST
17619: PPUSH
17620: CALL_OW 69
17624: PUSH
17625: LD_EXP 40
17629: DIFF
17630: PPUSH
17631: LD_INT 84
17633: PPUSH
17634: LD_INT 128
17636: PPUSH
17637: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17641: LD_INT 22
17643: PUSH
17644: LD_INT 1
17646: PUSH
17647: EMPTY
17648: LIST
17649: LIST
17650: PPUSH
17651: CALL_OW 69
17655: PUSH
17656: LD_EXP 40
17660: DIFF
17661: PPUSH
17662: LD_EXP 40
17666: PPUSH
17667: CALL_OW 179
// for i = 1 to amount do
17671: LD_ADDR_VAR 0 2
17675: PUSH
17676: DOUBLE
17677: LD_INT 1
17679: DEC
17680: ST_TO_ADDR
17681: LD_VAR 0 8
17685: PUSH
17686: FOR_TO
17687: IFFALSE 17855
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17689: LD_ADDR_VAR 0 9
17693: PUSH
17694: LD_VAR 0 9
17698: PUSH
17699: LD_VAR 0 5
17703: PUSH
17704: LD_VAR 0 2
17708: ARRAY
17709: ADD
17710: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17711: LD_VAR 0 5
17715: PUSH
17716: LD_VAR 0 2
17720: ARRAY
17721: PPUSH
17722: CALL_OW 310
17726: IFFALSE 17743
// AddComExitBuilding ( tmp [ i ] ) ;
17728: LD_VAR 0 5
17732: PUSH
17733: LD_VAR 0 2
17737: ARRAY
17738: PPUSH
17739: CALL_OW 182
// if i = 2 and JMMNewVeh then
17743: LD_VAR 0 2
17747: PUSH
17748: LD_INT 2
17750: EQUAL
17751: PUSH
17752: LD_EXP 58
17756: AND
17757: IFFALSE 17815
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17759: LD_VAR 0 5
17763: PUSH
17764: LD_VAR 0 2
17768: ARRAY
17769: PPUSH
17770: LD_EXP 58
17774: PPUSH
17775: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17779: LD_VAR 0 5
17783: PUSH
17784: LD_VAR 0 2
17788: ARRAY
17789: PPUSH
17790: LD_INT 86
17792: PPUSH
17793: LD_INT 133
17795: PPUSH
17796: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 2
17809: ARRAY
17810: PPUSH
17811: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17815: LD_VAR 0 5
17819: PUSH
17820: LD_VAR 0 2
17824: ARRAY
17825: PPUSH
17826: LD_INT 8
17828: PPUSH
17829: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17833: LD_VAR 0 5
17837: PUSH
17838: LD_VAR 0 2
17842: ARRAY
17843: PPUSH
17844: LD_EXP 40
17848: PPUSH
17849: CALL_OW 179
// end ;
17853: GO 17686
17855: POP
17856: POP
// if GirlNewVeh then
17857: LD_EXP 59
17861: IFFALSE 17875
// SetSide ( GirlNewVeh , 4 ) ;
17863: LD_EXP 59
17867: PPUSH
17868: LD_INT 4
17870: PPUSH
17871: CALL_OW 235
// if Mike then
17875: LD_EXP 57
17879: IFFALSE 17916
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
17881: LD_ADDR_VAR 0 9
17885: PUSH
17886: LD_VAR 0 9
17890: PPUSH
17891: LD_EXP 57
17895: PPUSH
17896: CALL 104985 0 2
17900: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
17901: LD_EXP 57
17905: PPUSH
17906: LD_INT 86
17908: PPUSH
17909: LD_INT 133
17911: PPUSH
17912: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
17916: LD_INT 35
17918: PPUSH
17919: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17923: LD_VAR 0 9
17927: PPUSH
17928: LD_INT 95
17930: PUSH
17931: LD_INT 9
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: PPUSH
17938: CALL_OW 72
17942: PUSH
17943: LD_INT 0
17945: EQUAL
17946: PUSH
17947: LD_EXP 40
17951: PPUSH
17952: LD_INT 9
17954: PPUSH
17955: CALL_OW 308
17959: NOT
17960: AND
17961: IFFALSE 17916
// wait ( 0 0$2 ) ;
17963: LD_INT 70
17965: PPUSH
17966: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17970: LD_VAR 0 9
17974: PPUSH
17975: LD_INT 1
17977: PPUSH
17978: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17982: LD_INT 21
17984: PUSH
17985: LD_INT 2
17987: PUSH
17988: EMPTY
17989: LIST
17990: LIST
17991: PUSH
17992: LD_INT 92
17994: PUSH
17995: LD_INT 83
17997: PUSH
17998: LD_INT 130
18000: PUSH
18001: LD_INT 10
18003: PUSH
18004: EMPTY
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: PUSH
18010: EMPTY
18011: LIST
18012: LIST
18013: PPUSH
18014: CALL_OW 69
18018: PPUSH
18019: LD_INT 1
18021: PPUSH
18022: CALL_OW 235
// tick := 0 ;
18026: LD_ADDR_OWVAR 1
18030: PUSH
18031: LD_INT 0
18033: ST_TO_ADDR
// Video ( false ) ;
18034: LD_INT 0
18036: PPUSH
18037: CALL 104957 0 1
// ChangeMissionObjectives ( M1 ) ;
18041: LD_STRING M1
18043: PPUSH
18044: CALL_OW 337
// SaveForQuickRestart ;
18048: CALL_OW 22
// missionStart := true ;
18052: LD_ADDR_EXP 13
18056: PUSH
18057: LD_INT 1
18059: ST_TO_ADDR
// missionStage := 2 ;
18060: LD_ADDR_EXP 15
18064: PUSH
18065: LD_INT 2
18067: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18068: LD_INT 35
18070: PPUSH
18071: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
18075: LD_ADDR_VAR 0 5
18079: PUSH
18080: LD_INT 22
18082: PUSH
18083: LD_INT 4
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: PUSH
18090: LD_INT 21
18092: PUSH
18093: LD_INT 1
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PPUSH
18104: CALL_OW 69
18108: PUSH
18109: LD_EXP 60
18113: DIFF
18114: ST_TO_ADDR
// if not tmp then
18115: LD_VAR 0 5
18119: NOT
18120: IFFALSE 18135
// tmp := [ Powell ] ;
18122: LD_ADDR_VAR 0 5
18126: PUSH
18127: LD_EXP 60
18131: PUSH
18132: EMPTY
18133: LIST
18134: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
18135: LD_ADDR_VAR 0 4
18139: PUSH
18140: LD_INT 22
18142: PUSH
18143: LD_INT 4
18145: PUSH
18146: EMPTY
18147: LIST
18148: LIST
18149: PUSH
18150: LD_INT 34
18152: PUSH
18153: LD_INT 12
18155: PUSH
18156: EMPTY
18157: LIST
18158: LIST
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PPUSH
18164: CALL_OW 69
18168: PUSH
18169: LD_INT 1
18171: ARRAY
18172: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18173: LD_VAR 0 5
18177: PUSH
18178: LD_INT 1
18180: ARRAY
18181: PPUSH
18182: CALL_OW 310
18186: IFFALSE 18201
// ComExitBuilding ( tmp [ 1 ] ) ;
18188: LD_VAR 0 5
18192: PUSH
18193: LD_INT 1
18195: ARRAY
18196: PPUSH
18197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18201: LD_VAR 0 5
18205: PUSH
18206: LD_INT 1
18208: ARRAY
18209: PPUSH
18210: LD_VAR 0 4
18214: PPUSH
18215: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18219: LD_VAR 0 5
18223: PUSH
18224: LD_INT 1
18226: ARRAY
18227: PPUSH
18228: LD_INT 80
18230: PPUSH
18231: LD_INT 136
18233: PPUSH
18234: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18238: LD_VAR 0 5
18242: PUSH
18243: LD_INT 1
18245: ARRAY
18246: PPUSH
18247: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18251: LD_VAR 0 5
18255: PUSH
18256: LD_INT 1
18258: ARRAY
18259: PPUSH
18260: LD_INT 59
18262: PPUSH
18263: LD_INT 112
18265: PPUSH
18266: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18270: LD_VAR 0 5
18274: PUSH
18275: LD_INT 1
18277: ARRAY
18278: PPUSH
18279: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18283: LD_EXP 41
18287: PUSH
18288: LD_EXP 41
18292: PPUSH
18293: CALL_OW 255
18297: PUSH
18298: LD_INT 1
18300: EQUAL
18301: AND
18302: IFFALSE 18328
// begin Say ( Joan , D3W-Joan-1 ) ;
18304: LD_EXP 41
18308: PPUSH
18309: LD_STRING D3W-Joan-1
18311: PPUSH
18312: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18316: LD_EXP 40
18320: PPUSH
18321: LD_STRING D3W-JMM-1
18323: PPUSH
18324: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18328: LD_EXP 43
18332: PUSH
18333: LD_EXP 43
18337: PPUSH
18338: CALL_OW 255
18342: PUSH
18343: LD_INT 1
18345: EQUAL
18346: AND
18347: PUSH
18348: LD_EXP 43
18352: PUSH
18353: LD_EXP 61
18357: IN
18358: NOT
18359: AND
18360: IFFALSE 18386
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18362: LD_EXP 43
18366: PPUSH
18367: LD_STRING D3W-Lisa-1
18369: PPUSH
18370: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18374: LD_EXP 40
18378: PPUSH
18379: LD_STRING D3W-JMM-1
18381: PPUSH
18382: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18386: LD_EXP 55
18390: PUSH
18391: LD_EXP 55
18395: PPUSH
18396: CALL_OW 255
18400: PUSH
18401: LD_INT 1
18403: EQUAL
18404: AND
18405: IFFALSE 18431
// begin Say ( Connie , D3W-Con-1 ) ;
18407: LD_EXP 55
18411: PPUSH
18412: LD_STRING D3W-Con-1
18414: PPUSH
18415: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18419: LD_EXP 40
18423: PPUSH
18424: LD_STRING D3W-JMM-1
18426: PPUSH
18427: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
18431: LD_INT 18
18433: PPUSH
18434: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
18438: LD_EXP 43
18442: PUSH
18443: LD_EXP 61
18447: IN
18448: PUSH
18449: LD_EXP 43
18453: PPUSH
18454: CALL_OW 255
18458: PUSH
18459: LD_INT 1
18461: EQUAL
18462: AND
18463: IFFALSE 18479
// Say ( Lisa , D3nW-Lisa-1 ) else
18465: LD_EXP 43
18469: PPUSH
18470: LD_STRING D3nW-Lisa-1
18472: PPUSH
18473: CALL_OW 88
18477: GO 18723
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18479: LD_EXP 46
18483: PUSH
18484: LD_EXP 61
18488: IN
18489: PUSH
18490: LD_EXP 46
18494: PPUSH
18495: CALL_OW 255
18499: PUSH
18500: LD_INT 1
18502: EQUAL
18503: AND
18504: IFFALSE 18520
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18506: LD_EXP 46
18510: PPUSH
18511: LD_STRING D3nW-Cyrus-1
18513: PPUSH
18514: CALL_OW 88
18518: GO 18723
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18520: LD_EXP 45
18524: PUSH
18525: LD_EXP 61
18529: IN
18530: PUSH
18531: LD_EXP 45
18535: PPUSH
18536: CALL_OW 255
18540: PUSH
18541: LD_INT 1
18543: EQUAL
18544: AND
18545: IFFALSE 18561
// Say ( Bobby , D3nW-Bobby-1 ) else
18547: LD_EXP 45
18551: PPUSH
18552: LD_STRING D3nW-Bobby-1
18554: PPUSH
18555: CALL_OW 88
18559: GO 18723
// if Gary in vip and GetSide ( Gary ) = 1 then
18561: LD_EXP 52
18565: PUSH
18566: LD_EXP 61
18570: IN
18571: PUSH
18572: LD_EXP 52
18576: PPUSH
18577: CALL_OW 255
18581: PUSH
18582: LD_INT 1
18584: EQUAL
18585: AND
18586: IFFALSE 18602
// Say ( Gary , D3nW-Gary-1 ) else
18588: LD_EXP 52
18592: PPUSH
18593: LD_STRING D3nW-Gary-1
18595: PPUSH
18596: CALL_OW 88
18600: GO 18723
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18602: LD_EXP 44
18606: PUSH
18607: LD_EXP 61
18611: IN
18612: PUSH
18613: LD_EXP 44
18617: PPUSH
18618: CALL_OW 255
18622: PUSH
18623: LD_INT 1
18625: EQUAL
18626: AND
18627: IFFALSE 18643
// Say ( Donaldson , D3nW-Don-1 ) else
18629: LD_EXP 44
18633: PPUSH
18634: LD_STRING D3nW-Don-1
18636: PPUSH
18637: CALL_OW 88
18641: GO 18723
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18643: LD_EXP 51
18647: PUSH
18648: LD_EXP 61
18652: IN
18653: PUSH
18654: LD_EXP 51
18658: PPUSH
18659: CALL_OW 255
18663: PUSH
18664: LD_INT 1
18666: EQUAL
18667: AND
18668: IFFALSE 18684
// Say ( Cornel , D3nW-Corn-1 ) else
18670: LD_EXP 51
18674: PPUSH
18675: LD_STRING D3nW-Corn-1
18677: PPUSH
18678: CALL_OW 88
18682: GO 18723
// if Frank in vip and GetSide ( Frank ) = 1 then
18684: LD_EXP 53
18688: PUSH
18689: LD_EXP 61
18693: IN
18694: PUSH
18695: LD_EXP 53
18699: PPUSH
18700: CALL_OW 255
18704: PUSH
18705: LD_INT 1
18707: EQUAL
18708: AND
18709: IFFALSE 18723
// Say ( Frank , D3nW-Frank-1 ) ;
18711: LD_EXP 53
18715: PPUSH
18716: LD_STRING D3nW-Frank-1
18718: PPUSH
18719: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18723: LD_EXP 61
18727: PPUSH
18728: LD_INT 22
18730: PUSH
18731: LD_INT 1
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: PPUSH
18738: CALL_OW 72
18742: IFFALSE 18768
// begin Say ( JMM , D3nW-JMM-1 ) ;
18744: LD_EXP 40
18748: PPUSH
18749: LD_STRING D3nW-JMM-1
18751: PPUSH
18752: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18756: LD_EXP 40
18760: PPUSH
18761: LD_STRING D3nW-JMM-1a
18763: PPUSH
18764: CALL_OW 88
// end ; t := 0 0$00 ;
18768: LD_ADDR_VAR 0 3
18772: PUSH
18773: LD_INT 0
18775: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18776: LD_INT 35
18778: PPUSH
18779: CALL_OW 67
// t := t + 0 0$1 ;
18783: LD_ADDR_VAR 0 3
18787: PUSH
18788: LD_VAR 0 3
18792: PUSH
18793: LD_INT 35
18795: PLUS
18796: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18797: LD_INT 59
18799: PPUSH
18800: LD_INT 112
18802: PPUSH
18803: CALL_OW 428
18807: PUSH
18808: LD_VAR 0 3
18812: PUSH
18813: LD_INT 2100
18815: GREATER
18816: OR
18817: IFFALSE 18776
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18819: LD_ADDR_EXP 100
18823: PUSH
18824: LD_EXP 100
18828: PPUSH
18829: LD_INT 4
18831: PPUSH
18832: LD_INT 22
18834: PUSH
18835: LD_INT 4
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: PUSH
18842: LD_INT 23
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PUSH
18852: LD_INT 3
18854: PUSH
18855: LD_INT 21
18857: PUSH
18858: LD_INT 2
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: LIST
18873: PPUSH
18874: CALL_OW 69
18878: PUSH
18879: LD_EXP 60
18883: DIFF
18884: PPUSH
18885: CALL_OW 1
18889: ST_TO_ADDR
// activeAttacks := true ;
18890: LD_ADDR_EXP 16
18894: PUSH
18895: LD_INT 1
18897: ST_TO_ADDR
// end ;
18898: LD_VAR 0 1
18902: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18903: LD_INT 0
18905: PPUSH
// case question of 1 :
18906: LD_VAR 0 1
18910: PUSH
18911: LD_INT 1
18913: DOUBLE
18914: EQUAL
18915: IFTRUE 18919
18917: GO 18970
18919: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18920: LD_EXP 40
18924: PPUSH
18925: LD_STRING D2Mot-JMM-1
18927: PPUSH
18928: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18932: LD_EXP 60
18936: PPUSH
18937: LD_STRING D2Mot-Pow-1
18939: PPUSH
18940: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18944: LD_EXP 40
18948: PPUSH
18949: LD_STRING D2Mot-JMM-2
18951: PPUSH
18952: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18956: LD_EXP 60
18960: PPUSH
18961: LD_STRING D2Mot-Pow-2
18963: PPUSH
18964: CALL_OW 88
// end ; 2 :
18968: GO 19321
18970: LD_INT 2
18972: DOUBLE
18973: EQUAL
18974: IFTRUE 18978
18976: GO 19054
18978: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18979: LD_EXP 40
18983: PPUSH
18984: LD_STRING D2Rus-JMM-1
18986: PPUSH
18987: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18991: LD_EXP 60
18995: PPUSH
18996: LD_STRING D2Rus-Pow-1
18998: PPUSH
18999: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
19003: LD_EXP 40
19007: PPUSH
19008: LD_STRING D2Rus-JMM-2
19010: PPUSH
19011: CALL_OW 88
// if not ( 3 in list_of_q ) then
19015: LD_INT 3
19017: PUSH
19018: LD_VAR 0 2
19022: IN
19023: NOT
19024: IFFALSE 19040
// Say ( Powell , D2Rus-Pow-2 ) else
19026: LD_EXP 60
19030: PPUSH
19031: LD_STRING D2Rus-Pow-2
19033: PPUSH
19034: CALL_OW 88
19038: GO 19052
// Say ( Powell , D2Rus-Pow-2a ) ;
19040: LD_EXP 60
19044: PPUSH
19045: LD_STRING D2Rus-Pow-2a
19047: PPUSH
19048: CALL_OW 88
// end ; 3 :
19052: GO 19321
19054: LD_INT 3
19056: DOUBLE
19057: EQUAL
19058: IFTRUE 19062
19060: GO 19147
19062: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
19063: LD_EXP 40
19067: PPUSH
19068: LD_STRING D2Leg-JMM-1
19070: PPUSH
19071: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
19075: LD_EXP 60
19079: PPUSH
19080: LD_STRING D2Leg-Pow-1
19082: PPUSH
19083: CALL_OW 88
// if 2 in list_of_q then
19087: LD_INT 2
19089: PUSH
19090: LD_VAR 0 2
19094: IN
19095: IFFALSE 19121
// begin Say ( JMM , D2Leg-JMM-2 ) ;
19097: LD_EXP 40
19101: PPUSH
19102: LD_STRING D2Leg-JMM-2
19104: PPUSH
19105: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
19109: LD_EXP 60
19113: PPUSH
19114: LD_STRING D2Leg-Pow-2
19116: PPUSH
19117: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
19121: LD_EXP 40
19125: PPUSH
19126: LD_STRING D2Leg-JMM-3
19128: PPUSH
19129: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
19133: LD_EXP 60
19137: PPUSH
19138: LD_STRING D2Leg-Pow-3
19140: PPUSH
19141: CALL_OW 88
// end ; 4 :
19145: GO 19321
19147: LD_INT 4
19149: DOUBLE
19150: EQUAL
19151: IFTRUE 19155
19153: GO 19230
19155: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
19156: LD_EXP 40
19160: PPUSH
19161: LD_STRING D2Ar-JMM-1
19163: PPUSH
19164: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
19168: LD_EXP 60
19172: PPUSH
19173: LD_STRING D2Ar-Pow-1
19175: PPUSH
19176: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19180: LD_EXP 40
19184: PPUSH
19185: LD_STRING D2Ar-JMM-2
19187: PPUSH
19188: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19192: LD_EXP 60
19196: PPUSH
19197: LD_STRING D2Ar-Pow-2
19199: PPUSH
19200: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19204: LD_EXP 40
19208: PPUSH
19209: LD_STRING D2Ar-JMM-3
19211: PPUSH
19212: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19216: LD_EXP 60
19220: PPUSH
19221: LD_STRING D2Ar-Pow-3
19223: PPUSH
19224: CALL_OW 88
// end ; 5 :
19228: GO 19321
19230: LD_INT 5
19232: DOUBLE
19233: EQUAL
19234: IFTRUE 19238
19236: GO 19253
19238: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19239: LD_EXP 40
19243: PPUSH
19244: LD_STRING D2Conf-JMM-1
19246: PPUSH
19247: CALL_OW 88
19251: GO 19321
19253: LD_INT 6
19255: DOUBLE
19256: EQUAL
19257: IFTRUE 19261
19259: GO 19320
19261: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19262: LD_EXP 40
19266: PPUSH
19267: LD_STRING D2Com-JMM-1
19269: PPUSH
19270: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19274: LD_EXP 60
19278: PPUSH
19279: LD_STRING D2Com-Pow-1
19281: PPUSH
19282: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19286: LD_EXP 40
19290: PPUSH
19291: LD_STRING D2Com-JMM-2
19293: PPUSH
19294: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19298: LD_EXP 60
19302: PPUSH
19303: LD_STRING D2Com-Pow-2
19305: PPUSH
19306: CALL_OW 88
// powellAngerQuery := true ;
19310: LD_ADDR_EXP 36
19314: PUSH
19315: LD_INT 1
19317: ST_TO_ADDR
// end ; end ;
19318: GO 19321
19320: POP
// end ;
19321: LD_VAR 0 3
19325: RET
// every 0 0$5 trigger missionStart do var tmp ;
19326: LD_EXP 13
19330: IFFALSE 19613
19332: GO 19334
19334: DISABLE
19335: LD_INT 0
19337: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19338: LD_INT 35
19340: PPUSH
19341: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19345: LD_INT 14
19347: PPUSH
19348: LD_INT 22
19350: PUSH
19351: LD_INT 1
19353: PUSH
19354: EMPTY
19355: LIST
19356: LIST
19357: PPUSH
19358: CALL_OW 70
19362: PUSH
19363: LD_EXP 15
19367: PUSH
19368: LD_INT 2
19370: PUSH
19371: LD_INT 3
19373: PUSH
19374: LD_INT 4
19376: PUSH
19377: LD_INT 5
19379: PUSH
19380: EMPTY
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: IN
19386: AND
19387: IFFALSE 19603
// begin powellAnger := powellAnger + 1 ;
19389: LD_ADDR_EXP 17
19393: PUSH
19394: LD_EXP 17
19398: PUSH
19399: LD_INT 1
19401: PLUS
19402: ST_TO_ADDR
// Video ( true ) ;
19403: LD_INT 1
19405: PPUSH
19406: CALL 104957 0 1
// CenterNowOnUnits ( tmp ) ;
19410: LD_VAR 0 1
19414: PPUSH
19415: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19419: LD_INT 14
19421: PPUSH
19422: LD_INT 22
19424: PUSH
19425: LD_INT 1
19427: PUSH
19428: EMPTY
19429: LIST
19430: LIST
19431: PPUSH
19432: CALL_OW 70
19436: PPUSH
19437: LD_INT 86
19439: PPUSH
19440: LD_INT 133
19442: PPUSH
19443: CALL_OW 111
// async ;
19447: ASYNC
// case powellAnger of 1 :
19448: LD_EXP 17
19452: PUSH
19453: LD_INT 1
19455: DOUBLE
19456: EQUAL
19457: IFTRUE 19461
19459: GO 19476
19461: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19462: LD_EXP 60
19466: PPUSH
19467: LD_STRING DBack1-Pow-1
19469: PPUSH
19470: CALL_OW 88
19474: GO 19523
19476: LD_INT 2
19478: DOUBLE
19479: EQUAL
19480: IFTRUE 19484
19482: GO 19499
19484: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19485: LD_EXP 60
19489: PPUSH
19490: LD_STRING DBack2-Pow-1
19492: PPUSH
19493: CALL_OW 88
19497: GO 19523
19499: LD_INT 3
19501: DOUBLE
19502: EQUAL
19503: IFTRUE 19507
19505: GO 19522
19507: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19508: LD_EXP 60
19512: PPUSH
19513: LD_STRING DBack3-Pow-1
19515: PPUSH
19516: CALL_OW 88
19520: GO 19523
19522: POP
// sync ;
19523: SYNC
// repeat wait ( 0 0$1 ) ;
19524: LD_INT 35
19526: PPUSH
19527: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19531: LD_INT 14
19533: PPUSH
19534: LD_INT 22
19536: PUSH
19537: LD_INT 1
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: PPUSH
19544: CALL_OW 70
19548: PPUSH
19549: LD_INT 86
19551: PPUSH
19552: LD_INT 133
19554: PPUSH
19555: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19559: LD_INT 14
19561: PPUSH
19562: LD_INT 22
19564: PUSH
19565: LD_INT 1
19567: PUSH
19568: EMPTY
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 70
19576: NOT
19577: IFFALSE 19524
// if powellAnger >= 3 then
19579: LD_EXP 17
19583: PUSH
19584: LD_INT 3
19586: GREATEREQUAL
19587: IFFALSE 19596
// YouLost ( Dismissed ) ;
19589: LD_STRING Dismissed
19591: PPUSH
19592: CALL_OW 104
// Video ( false ) ;
19596: LD_INT 0
19598: PPUSH
19599: CALL 104957 0 1
// end ; until missionStage > 5 ;
19603: LD_EXP 15
19607: PUSH
19608: LD_INT 5
19610: GREATER
19611: IFFALSE 19338
// end ;
19613: PPOPN 1
19615: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19616: LD_EXP 13
19620: PUSH
19621: LD_INT 22
19623: PUSH
19624: LD_INT 4
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 21
19633: PUSH
19634: LD_INT 2
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: PUSH
19641: EMPTY
19642: LIST
19643: LIST
19644: PPUSH
19645: CALL_OW 69
19649: PUSH
19650: LD_INT 4
19652: GREATEREQUAL
19653: AND
19654: PUSH
19655: LD_EXP 15
19659: PUSH
19660: LD_INT 2
19662: EQUAL
19663: AND
19664: IFFALSE 21854
19666: GO 19668
19668: DISABLE
19669: LD_INT 0
19671: PPUSH
19672: PPUSH
19673: PPUSH
19674: PPUSH
19675: PPUSH
19676: PPUSH
19677: PPUSH
19678: PPUSH
19679: PPUSH
19680: PPUSH
// begin missionStage := 3 ;
19681: LD_ADDR_EXP 15
19685: PUSH
19686: LD_INT 3
19688: ST_TO_ADDR
// retreat := false ;
19689: LD_ADDR_VAR 0 4
19693: PUSH
19694: LD_INT 0
19696: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19697: LD_ADDR_VAR 0 5
19701: PUSH
19702: LD_INT 22
19704: PUSH
19705: LD_INT 4
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PUSH
19712: LD_INT 30
19714: PUSH
19715: LD_INT 4
19717: PUSH
19718: EMPTY
19719: LIST
19720: LIST
19721: PUSH
19722: EMPTY
19723: LIST
19724: LIST
19725: PPUSH
19726: CALL_OW 69
19730: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19731: LD_ADDR_VAR 0 6
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 30
19748: PUSH
19749: LD_INT 5
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: ST_TO_ADDR
// if not bar then
19765: LD_VAR 0 6
19769: NOT
19770: IFFALSE 19823
// begin repeat wait ( 0 0$1 ) ;
19772: LD_INT 35
19774: PPUSH
19775: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19779: LD_INT 22
19781: PUSH
19782: LD_INT 4
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 3
19791: PUSH
19792: LD_INT 57
19794: PUSH
19795: EMPTY
19796: LIST
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: PUSH
19802: LD_INT 30
19804: PUSH
19805: LD_INT 5
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: LIST
19816: PPUSH
19817: CALL_OW 69
19821: IFFALSE 19772
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19823: LD_ADDR_VAR 0 6
19827: PUSH
19828: LD_INT 22
19830: PUSH
19831: LD_INT 4
19833: PUSH
19834: EMPTY
19835: LIST
19836: LIST
19837: PUSH
19838: LD_INT 30
19840: PUSH
19841: LD_INT 5
19843: PUSH
19844: EMPTY
19845: LIST
19846: LIST
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: PPUSH
19852: CALL_OW 69
19856: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19857: LD_INT 35
19859: PPUSH
19860: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19864: LD_EXP 119
19868: PUSH
19869: LD_INT 4
19871: ARRAY
19872: PUSH
19873: LD_INT 4
19875: GREATEREQUAL
19876: IFFALSE 19857
// tmp := [ ] ;
19878: LD_ADDR_VAR 0 2
19882: PUSH
19883: EMPTY
19884: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19885: LD_ADDR_VAR 0 1
19889: PUSH
19890: LD_INT 22
19892: PUSH
19893: LD_INT 4
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: PUSH
19900: LD_INT 2
19902: PUSH
19903: LD_INT 25
19905: PUSH
19906: LD_INT 1
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 25
19915: PUSH
19916: LD_INT 2
19918: PUSH
19919: EMPTY
19920: LIST
19921: LIST
19922: PUSH
19923: LD_INT 25
19925: PUSH
19926: LD_INT 3
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: PUSH
19933: LD_INT 25
19935: PUSH
19936: LD_INT 4
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: PUSH
19943: LD_INT 25
19945: PUSH
19946: LD_INT 5
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: PUSH
19961: EMPTY
19962: LIST
19963: LIST
19964: PPUSH
19965: CALL_OW 69
19969: PUSH
19970: LD_EXP 60
19974: PUSH
19975: LD_EXP 61
19979: ADD
19980: DIFF
19981: PUSH
19982: FOR_IN
19983: IFFALSE 20047
// if GetTag ( i ) = 1 then
19985: LD_VAR 0 1
19989: PPUSH
19990: CALL_OW 110
19994: PUSH
19995: LD_INT 1
19997: EQUAL
19998: IFFALSE 20022
// tmp := Join ( tmp , i ) else
20000: LD_ADDR_VAR 0 2
20004: PUSH
20005: LD_VAR 0 2
20009: PPUSH
20010: LD_VAR 0 1
20014: PPUSH
20015: CALL 104985 0 2
20019: ST_TO_ADDR
20020: GO 20045
// tmp := Insert ( tmp , 1 , i ) ;
20022: LD_ADDR_VAR 0 2
20026: PUSH
20027: LD_VAR 0 2
20031: PPUSH
20032: LD_INT 1
20034: PPUSH
20035: LD_VAR 0 1
20039: PPUSH
20040: CALL_OW 2
20044: ST_TO_ADDR
20045: GO 19982
20047: POP
20048: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
20049: LD_ADDR_VAR 0 3
20053: PUSH
20054: LD_VAR 0 2
20058: PPUSH
20059: LD_INT 26
20061: PUSH
20062: LD_INT 1
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: PPUSH
20069: CALL_OW 72
20073: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
20074: LD_ADDR_VAR 0 2
20078: PUSH
20079: LD_VAR 0 2
20083: PUSH
20084: LD_VAR 0 3
20088: DIFF
20089: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
20090: LD_ADDR_VAR 0 2
20094: PUSH
20095: LD_VAR 0 2
20099: PPUSH
20100: LD_INT 3
20102: PPUSH
20103: CALL 103494 0 2
20107: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_VAR 0 3
20117: PPUSH
20118: LD_INT 3
20120: PPUSH
20121: CALL 103494 0 2
20125: ST_TO_ADDR
// for i := 1 to 4 do
20126: LD_ADDR_VAR 0 1
20130: PUSH
20131: DOUBLE
20132: LD_INT 1
20134: DEC
20135: ST_TO_ADDR
20136: LD_INT 4
20138: PUSH
20139: FOR_TO
20140: IFFALSE 20293
// begin if tmp2 then
20142: LD_VAR 0 3
20146: IFFALSE 20214
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
20148: LD_ADDR_EXP 18
20152: PUSH
20153: LD_EXP 18
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_EXP 18
20165: PUSH
20166: LD_INT 1
20168: ARRAY
20169: PUSH
20170: LD_VAR 0 3
20174: PUSH
20175: LD_VAR 0 3
20179: ARRAY
20180: ADD
20181: PPUSH
20182: CALL_OW 1
20186: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20187: LD_VAR 0 3
20191: PUSH
20192: LD_VAR 0 3
20196: ARRAY
20197: PPUSH
20198: LD_INT 1
20200: PPUSH
20201: CALL_OW 109
// tmp2 := [ ] ;
20205: LD_ADDR_VAR 0 3
20209: PUSH
20210: EMPTY
20211: ST_TO_ADDR
// end else
20212: GO 20291
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20214: LD_ADDR_EXP 18
20218: PUSH
20219: LD_EXP 18
20223: PPUSH
20224: LD_INT 1
20226: PPUSH
20227: LD_EXP 18
20231: PUSH
20232: LD_INT 1
20234: ARRAY
20235: PUSH
20236: LD_VAR 0 2
20240: PUSH
20241: LD_VAR 0 2
20245: ARRAY
20246: ADD
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20253: LD_VAR 0 2
20257: PUSH
20258: LD_VAR 0 2
20262: ARRAY
20263: PPUSH
20264: LD_INT 1
20266: PPUSH
20267: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20271: LD_ADDR_VAR 0 2
20275: PUSH
20276: LD_VAR 0 2
20280: PPUSH
20281: LD_VAR 0 2
20285: PPUSH
20286: CALL_OW 3
20290: ST_TO_ADDR
// end ; end ;
20291: GO 20139
20293: POP
20294: POP
// if tmp2 then
20295: LD_VAR 0 3
20299: IFFALSE 20317
// tmp := tmp union tmp2 ;
20301: LD_ADDR_VAR 0 2
20305: PUSH
20306: LD_VAR 0 2
20310: PUSH
20311: LD_VAR 0 3
20315: UNION
20316: ST_TO_ADDR
// for i := 1 to 4 do
20317: LD_ADDR_VAR 0 1
20321: PUSH
20322: DOUBLE
20323: LD_INT 1
20325: DEC
20326: ST_TO_ADDR
20327: LD_INT 4
20329: PUSH
20330: FOR_TO
20331: IFFALSE 20380
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20333: LD_ADDR_EXP 18
20337: PUSH
20338: LD_EXP 18
20342: PPUSH
20343: LD_INT 2
20345: PPUSH
20346: LD_EXP 18
20350: PUSH
20351: LD_INT 2
20353: ARRAY
20354: PUSH
20355: LD_VAR 0 2
20359: PUSH
20360: LD_VAR 0 2
20364: PUSH
20365: LD_VAR 0 1
20369: MINUS
20370: ARRAY
20371: ADD
20372: PPUSH
20373: CALL_OW 1
20377: ST_TO_ADDR
20378: GO 20330
20380: POP
20381: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20382: LD_ADDR_EXP 100
20386: PUSH
20387: LD_EXP 100
20391: PPUSH
20392: LD_INT 4
20394: PPUSH
20395: LD_EXP 100
20399: PUSH
20400: LD_INT 4
20402: ARRAY
20403: PUSH
20404: LD_EXP 18
20408: PUSH
20409: LD_INT 1
20411: ARRAY
20412: DIFF
20413: PPUSH
20414: CALL_OW 1
20418: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20419: LD_VAR 0 5
20423: PUSH
20424: LD_INT 1
20426: ARRAY
20427: PPUSH
20428: CALL_OW 313
20432: IFFALSE 20487
// begin for i in UnitsInside ( arm [ 1 ] ) do
20434: LD_ADDR_VAR 0 1
20438: PUSH
20439: LD_VAR 0 5
20443: PUSH
20444: LD_INT 1
20446: ARRAY
20447: PPUSH
20448: CALL_OW 313
20452: PUSH
20453: FOR_IN
20454: IFFALSE 20485
// begin ComExitBuilding ( i ) ;
20456: LD_VAR 0 1
20460: PPUSH
20461: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20465: LD_VAR 0 1
20469: PPUSH
20470: LD_VAR 0 6
20474: PUSH
20475: LD_INT 1
20477: ARRAY
20478: PPUSH
20479: CALL_OW 180
// end ;
20483: GO 20453
20485: POP
20486: POP
// end ; wait ( 0 0$3 ) ;
20487: LD_INT 105
20489: PPUSH
20490: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20494: LD_ADDR_VAR 0 1
20498: PUSH
20499: LD_EXP 18
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PUSH
20508: FOR_IN
20509: IFFALSE 20616
// begin if IsInUnit ( i ) then
20511: LD_VAR 0 1
20515: PPUSH
20516: CALL_OW 310
20520: IFFALSE 20531
// ComExitBuilding ( i ) ;
20522: LD_VAR 0 1
20526: PPUSH
20527: CALL_OW 122
// if GetClass ( i ) <> 1 then
20531: LD_VAR 0 1
20535: PPUSH
20536: CALL_OW 257
20540: PUSH
20541: LD_INT 1
20543: NONEQUAL
20544: IFFALSE 20585
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20546: LD_VAR 0 1
20550: PPUSH
20551: LD_VAR 0 5
20555: PUSH
20556: LD_INT 1
20558: ARRAY
20559: PPUSH
20560: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20564: LD_VAR 0 1
20568: PPUSH
20569: LD_INT 1
20571: PPUSH
20572: CALL_OW 183
// AddComExitBuilding ( i ) ;
20576: LD_VAR 0 1
20580: PPUSH
20581: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20585: LD_VAR 0 1
20589: PPUSH
20590: LD_INT 60
20592: PPUSH
20593: LD_INT 94
20595: PPUSH
20596: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20600: LD_VAR 0 1
20604: PPUSH
20605: LD_EXP 60
20609: PPUSH
20610: CALL_OW 179
// end ;
20614: GO 20508
20616: POP
20617: POP
// wait ( 0 0$10 ) ;
20618: LD_INT 350
20620: PPUSH
20621: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20625: LD_EXP 60
20629: PPUSH
20630: LD_STRING D4-Pow-1
20632: PPUSH
20633: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20637: LD_ADDR_VAR 0 2
20641: PUSH
20642: LD_EXP 18
20646: PUSH
20647: LD_INT 1
20649: ARRAY
20650: PPUSH
20651: LD_INT 26
20653: PUSH
20654: LD_INT 1
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: PPUSH
20661: CALL_OW 72
20665: ST_TO_ADDR
// if tmp then
20666: LD_VAR 0 2
20670: IFFALSE 20688
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20672: LD_VAR 0 2
20676: PUSH
20677: LD_INT 1
20679: ARRAY
20680: PPUSH
20681: LD_STRING D4-Sol1-1
20683: PPUSH
20684: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20688: LD_EXP 60
20692: PPUSH
20693: LD_STRING D4-Pow-2
20695: PPUSH
20696: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20700: LD_ADDR_VAR 0 1
20704: PUSH
20705: DOUBLE
20706: LD_INT 1
20708: DEC
20709: ST_TO_ADDR
20710: LD_EXP 18
20714: PUSH
20715: LD_INT 1
20717: ARRAY
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20813
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20722: LD_EXP 18
20726: PUSH
20727: LD_INT 1
20729: ARRAY
20730: PUSH
20731: LD_VAR 0 1
20735: ARRAY
20736: PPUSH
20737: LD_EXP 119
20741: PUSH
20742: LD_INT 4
20744: ARRAY
20745: PUSH
20746: LD_INT 1
20748: ARRAY
20749: PPUSH
20750: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20754: LD_ADDR_EXP 119
20758: PUSH
20759: LD_EXP 119
20763: PPUSH
20764: LD_INT 4
20766: PPUSH
20767: LD_EXP 119
20771: PUSH
20772: LD_INT 4
20774: ARRAY
20775: PPUSH
20776: LD_INT 1
20778: PPUSH
20779: CALL_OW 3
20783: PPUSH
20784: CALL_OW 1
20788: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20789: LD_INT 8
20791: PPUSH
20792: LD_EXP 18
20796: PUSH
20797: LD_INT 1
20799: ARRAY
20800: PUSH
20801: LD_VAR 0 1
20805: ARRAY
20806: PPUSH
20807: CALL_OW 471
// end ;
20811: GO 20719
20813: POP
20814: POP
// repeat wait ( 0 0$1 ) ;
20815: LD_INT 35
20817: PPUSH
20818: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20822: LD_EXP 18
20826: PUSH
20827: LD_INT 1
20829: ARRAY
20830: PPUSH
20831: LD_INT 55
20833: PUSH
20834: EMPTY
20835: LIST
20836: PPUSH
20837: CALL_OW 72
20841: PUSH
20842: LD_INT 4
20844: GREATEREQUAL
20845: IFFALSE 20815
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20847: LD_EXP 18
20851: PUSH
20852: LD_INT 1
20854: ARRAY
20855: PPUSH
20856: LD_INT 69
20858: PPUSH
20859: LD_INT 94
20861: PPUSH
20862: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20866: LD_EXP 18
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: PPUSH
20875: LD_INT 82
20877: PPUSH
20878: LD_INT 83
20880: PPUSH
20881: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20885: LD_EXP 18
20889: PUSH
20890: LD_INT 1
20892: ARRAY
20893: PPUSH
20894: LD_INT 77
20896: PPUSH
20897: LD_INT 69
20899: PPUSH
20900: CALL_OW 174
// repeat wait ( 3 ) ;
20904: LD_INT 3
20906: PPUSH
20907: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20911: LD_ADDR_VAR 0 1
20915: PUSH
20916: LD_EXP 18
20920: PUSH
20921: LD_INT 1
20923: ARRAY
20924: PUSH
20925: FOR_IN
20926: IFFALSE 21062
// begin if GetLives ( i ) < 990 then
20928: LD_VAR 0 1
20932: PPUSH
20933: CALL_OW 256
20937: PUSH
20938: LD_INT 990
20940: LESS
20941: IFFALSE 20955
// SetLives ( i , 1000 ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_INT 1000
20950: PPUSH
20951: CALL_OW 234
// if not IsInUnit ( i ) then
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 310
20964: NOT
20965: IFFALSE 21060
// begin if not HasTask ( i ) then
20967: LD_VAR 0 1
20971: PPUSH
20972: CALL_OW 314
20976: NOT
20977: IFFALSE 20994
// ComMoveXY ( i , 64 , 93 ) ;
20979: LD_VAR 0 1
20983: PPUSH
20984: LD_INT 64
20986: PPUSH
20987: LD_INT 93
20989: PPUSH
20990: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20994: LD_VAR 0 4
20998: NOT
20999: PUSH
21000: LD_VAR 0 1
21004: PPUSH
21005: CALL_OW 258
21009: PUSH
21010: LD_INT 1
21012: EQUAL
21013: AND
21014: IFFALSE 21060
// begin retreat := true ;
21016: LD_ADDR_VAR 0 4
21020: PUSH
21021: LD_INT 1
21023: ST_TO_ADDR
// SetTag ( i , 2 ) ;
21024: LD_VAR 0 1
21028: PPUSH
21029: LD_INT 2
21031: PPUSH
21032: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
21036: LD_VAR 0 1
21040: PPUSH
21041: LD_STRING D4a-Sol1-1
21043: PPUSH
21044: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
21048: LD_EXP 60
21052: PPUSH
21053: LD_STRING D4a-Pow-1
21055: PPUSH
21056: CALL_OW 88
// end ; end ; end ;
21060: GO 20925
21062: POP
21063: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
21064: LD_EXP 18
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: LD_INT 95
21075: PUSH
21076: LD_INT 9
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: PUSH
21083: LD_INT 3
21085: PUSH
21086: LD_INT 55
21088: PUSH
21089: EMPTY
21090: LIST
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: PPUSH
21100: CALL_OW 72
21104: PUSH
21105: LD_INT 4
21107: GREATEREQUAL
21108: IFFALSE 20904
// for i in powellSquadAttack [ 1 ] do
21110: LD_ADDR_VAR 0 1
21114: PUSH
21115: LD_EXP 18
21119: PUSH
21120: LD_INT 1
21122: ARRAY
21123: PUSH
21124: FOR_IN
21125: IFFALSE 21261
// begin if GetTag ( i ) = 2 then
21127: LD_VAR 0 1
21131: PPUSH
21132: CALL_OW 110
21136: PUSH
21137: LD_INT 2
21139: EQUAL
21140: IFFALSE 21202
// begin ComMoveXY ( i , 60 , 94 ) ;
21142: LD_VAR 0 1
21146: PPUSH
21147: LD_INT 60
21149: PPUSH
21150: LD_INT 94
21152: PPUSH
21153: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
21157: LD_VAR 0 1
21161: PPUSH
21162: LD_EXP 60
21166: PPUSH
21167: CALL_OW 179
// wait ( 0 0$3 ) ;
21171: LD_INT 105
21173: PPUSH
21174: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21178: LD_VAR 0 1
21182: PPUSH
21183: LD_STRING D4a-Sol1-2
21185: PPUSH
21186: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21190: LD_EXP 60
21194: PPUSH
21195: LD_STRING D4a-Pow-2
21197: PPUSH
21198: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_INT 0
21209: PPUSH
21210: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21214: LD_ADDR_EXP 100
21218: PUSH
21219: LD_EXP 100
21223: PPUSH
21224: LD_INT 4
21226: PPUSH
21227: LD_EXP 100
21231: PUSH
21232: LD_INT 4
21234: ARRAY
21235: PUSH
21236: LD_VAR 0 1
21240: UNION
21241: PPUSH
21242: CALL_OW 1
21246: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21247: LD_INT 8
21249: PPUSH
21250: LD_VAR 0 1
21254: PPUSH
21255: CALL_OW 472
// end ;
21259: GO 21124
21261: POP
21262: POP
// wait ( 2 2$00 ) ;
21263: LD_INT 4200
21265: PPUSH
21266: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21270: LD_ADDR_VAR 0 9
21274: PUSH
21275: LD_INT 22
21277: PUSH
21278: LD_INT 4
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: LD_INT 30
21287: PUSH
21288: LD_INT 32
21290: PUSH
21291: EMPTY
21292: LIST
21293: LIST
21294: PUSH
21295: LD_INT 58
21297: PUSH
21298: EMPTY
21299: LIST
21300: PUSH
21301: EMPTY
21302: LIST
21303: LIST
21304: LIST
21305: PPUSH
21306: CALL_OW 69
21310: ST_TO_ADDR
// if tmp then
21311: LD_VAR 0 2
21315: IFFALSE 21555
// begin for i := 1 to tmp do
21317: LD_ADDR_VAR 0 1
21321: PUSH
21322: DOUBLE
21323: LD_INT 1
21325: DEC
21326: ST_TO_ADDR
21327: LD_VAR 0 2
21331: PUSH
21332: FOR_TO
21333: IFFALSE 21546
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21335: LD_ADDR_EXP 100
21339: PUSH
21340: LD_EXP 100
21344: PPUSH
21345: LD_INT 4
21347: PPUSH
21348: LD_EXP 100
21352: PUSH
21353: LD_INT 4
21355: ARRAY
21356: PUSH
21357: LD_VAR 0 2
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: DIFF
21368: PPUSH
21369: CALL_OW 1
21373: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21374: LD_ADDR_VAR 0 10
21378: PUSH
21379: LD_VAR 0 2
21383: PUSH
21384: LD_VAR 0 1
21388: ARRAY
21389: PPUSH
21390: CALL_OW 310
21394: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21395: LD_VAR 0 10
21399: PUSH
21400: LD_VAR 0 10
21404: PPUSH
21405: CALL_OW 266
21409: PUSH
21410: LD_INT 32
21412: EQUAL
21413: AND
21414: IFFALSE 21418
// continue ;
21416: GO 21332
// if t then
21418: LD_VAR 0 10
21422: IFFALSE 21439
// ComExitBuilding ( tmp [ i ] ) ;
21424: LD_VAR 0 2
21428: PUSH
21429: LD_VAR 0 1
21433: ARRAY
21434: PPUSH
21435: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21439: LD_VAR 0 2
21443: PUSH
21444: LD_VAR 0 1
21448: ARRAY
21449: PPUSH
21450: LD_VAR 0 5
21454: PUSH
21455: LD_INT 1
21457: ARRAY
21458: PPUSH
21459: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21463: LD_VAR 0 2
21467: PUSH
21468: LD_VAR 0 1
21472: ARRAY
21473: PPUSH
21474: LD_INT 1
21476: PPUSH
21477: CALL_OW 183
// if emptyTowers then
21481: LD_VAR 0 9
21485: IFFALSE 21544
// begin AddComExitBuilding ( tmp [ i ] ) ;
21487: LD_VAR 0 2
21491: PUSH
21492: LD_VAR 0 1
21496: ARRAY
21497: PPUSH
21498: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21502: LD_VAR 0 2
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: PPUSH
21513: LD_VAR 0 9
21517: PUSH
21518: LD_INT 1
21520: ARRAY
21521: PPUSH
21522: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21526: LD_ADDR_VAR 0 9
21530: PUSH
21531: LD_VAR 0 9
21535: PPUSH
21536: LD_INT 1
21538: PPUSH
21539: CALL_OW 3
21543: ST_TO_ADDR
// end ; end ;
21544: GO 21332
21546: POP
21547: POP
// wait ( 0 0$30 ) ;
21548: LD_INT 1050
21550: PPUSH
21551: CALL_OW 67
// end ; uc_side := 6 ;
21555: LD_ADDR_OWVAR 20
21559: PUSH
21560: LD_INT 6
21562: ST_TO_ADDR
// uc_nation := 3 ;
21563: LD_ADDR_OWVAR 21
21567: PUSH
21568: LD_INT 3
21570: ST_TO_ADDR
// ru := [ ] ;
21571: LD_ADDR_VAR 0 7
21575: PUSH
21576: EMPTY
21577: ST_TO_ADDR
// for i = 1 to 5 do
21578: LD_ADDR_VAR 0 1
21582: PUSH
21583: DOUBLE
21584: LD_INT 1
21586: DEC
21587: ST_TO_ADDR
21588: LD_INT 5
21590: PUSH
21591: FOR_TO
21592: IFFALSE 21712
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21594: LD_INT 22
21596: PUSH
21597: LD_INT 23
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: LD_INT 1
21606: PPUSH
21607: LD_INT 2
21609: PPUSH
21610: CALL_OW 12
21614: ARRAY
21615: PPUSH
21616: LD_INT 1
21618: PPUSH
21619: LD_INT 3
21621: PPUSH
21622: LD_INT 43
21624: PUSH
21625: LD_INT 44
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: PUSH
21632: LD_INT 1
21634: PPUSH
21635: LD_INT 2
21637: PPUSH
21638: CALL_OW 12
21642: ARRAY
21643: PPUSH
21644: LD_INT 89
21646: PPUSH
21647: CALL 72551 0 5
// un := CreateVehicle ;
21651: LD_ADDR_VAR 0 8
21655: PUSH
21656: CALL_OW 45
21660: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21661: LD_VAR 0 8
21665: PPUSH
21666: LD_INT 4
21668: PPUSH
21669: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21673: LD_VAR 0 8
21677: PPUSH
21678: LD_INT 136
21680: PPUSH
21681: LD_INT 90
21683: PPUSH
21684: LD_INT 8
21686: PPUSH
21687: LD_INT 0
21689: PPUSH
21690: CALL_OW 50
// ru := ru ^ un ;
21694: LD_ADDR_VAR 0 7
21698: PUSH
21699: LD_VAR 0 7
21703: PUSH
21704: LD_VAR 0 8
21708: ADD
21709: ST_TO_ADDR
// end ;
21710: GO 21591
21712: POP
21713: POP
// if ru then
21714: LD_VAR 0 7
21718: IFFALSE 21735
// ComAgressiveMove ( ru , 57 , 94 ) ;
21720: LD_VAR 0 7
21724: PPUSH
21725: LD_INT 57
21727: PPUSH
21728: LD_INT 94
21730: PPUSH
21731: CALL_OW 114
// wait ( 3 3$00 ) ;
21735: LD_INT 6300
21737: PPUSH
21738: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21742: LD_INT 4
21744: PPUSH
21745: LD_INT 3
21747: PUSH
21748: LD_INT 1
21750: PUSH
21751: LD_INT 1
21753: PUSH
21754: LD_INT 5
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: PUSH
21763: LD_INT 4
21765: PUSH
21766: LD_INT 1
21768: PUSH
21769: LD_INT 1
21771: PUSH
21772: LD_INT 6
21774: PUSH
21775: EMPTY
21776: LIST
21777: LIST
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 4
21783: PUSH
21784: LD_INT 1
21786: PUSH
21787: LD_INT 1
21789: PUSH
21790: LD_INT 7
21792: PUSH
21793: EMPTY
21794: LIST
21795: LIST
21796: LIST
21797: LIST
21798: PUSH
21799: LD_INT 3
21801: PUSH
21802: LD_INT 1
21804: PUSH
21805: LD_INT 1
21807: PUSH
21808: LD_INT 7
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: LIST
21816: PUSH
21817: LD_INT 3
21819: PUSH
21820: LD_INT 1
21822: PUSH
21823: LD_INT 1
21825: PUSH
21826: LD_INT 5
21828: PUSH
21829: EMPTY
21830: LIST
21831: LIST
21832: LIST
21833: LIST
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: LIST
21839: LIST
21840: LIST
21841: PPUSH
21842: CALL 61100 0 2
// missionStage := 4 ;
21846: LD_ADDR_EXP 15
21850: PUSH
21851: LD_INT 4
21853: ST_TO_ADDR
// end ;
21854: PPOPN 10
21856: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21857: LD_EXP 15
21861: PUSH
21862: LD_INT 4
21864: EQUAL
21865: PUSH
21866: LD_INT 22
21868: PUSH
21869: LD_INT 4
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: LD_INT 21
21878: PUSH
21879: LD_INT 2
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PUSH
21886: EMPTY
21887: LIST
21888: LIST
21889: PPUSH
21890: CALL_OW 69
21894: PUSH
21895: LD_INT 5
21897: GREATEREQUAL
21898: AND
21899: IFFALSE 26112
21901: GO 21903
21903: DISABLE
21904: LD_INT 0
21906: PPUSH
21907: PPUSH
21908: PPUSH
21909: PPUSH
21910: PPUSH
21911: PPUSH
21912: PPUSH
21913: PPUSH
21914: PPUSH
21915: PPUSH
21916: PPUSH
21917: PPUSH
21918: PPUSH
// begin wait ( 0 0$10 ) ;
21919: LD_INT 350
21921: PPUSH
21922: CALL_OW 67
// missionStage := 5 ;
21926: LD_ADDR_EXP 15
21930: PUSH
21931: LD_INT 5
21933: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21934: LD_ADDR_VAR 0 10
21938: PUSH
21939: LD_INT 22
21941: PUSH
21942: LD_INT 4
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: PUSH
21949: LD_INT 2
21951: PUSH
21952: LD_INT 30
21954: PUSH
21955: LD_INT 4
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 30
21964: PUSH
21965: LD_INT 5
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: LIST
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: PPUSH
21981: CALL_OW 69
21985: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21986: LD_ADDR_VAR 0 6
21990: PUSH
21991: LD_INT 22
21993: PUSH
21994: LD_INT 4
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 21
22003: PUSH
22004: LD_INT 1
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: PUSH
22011: LD_INT 3
22013: PUSH
22014: LD_INT 25
22016: PUSH
22017: LD_INT 16
22019: PUSH
22020: EMPTY
22021: LIST
22022: LIST
22023: PUSH
22024: EMPTY
22025: LIST
22026: LIST
22027: PUSH
22028: LD_INT 3
22030: PUSH
22031: LD_INT 25
22033: PUSH
22034: LD_INT 12
22036: PUSH
22037: EMPTY
22038: LIST
22039: LIST
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: LIST
22049: LIST
22050: PPUSH
22051: CALL_OW 69
22055: PUSH
22056: LD_EXP 60
22060: DIFF
22061: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
22062: LD_ADDR_VAR 0 9
22066: PUSH
22067: LD_INT 22
22069: PUSH
22070: LD_INT 4
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PUSH
22077: LD_INT 30
22079: PUSH
22080: LD_INT 3
22082: PUSH
22083: EMPTY
22084: LIST
22085: LIST
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PPUSH
22091: CALL_OW 69
22095: PUSH
22096: LD_INT 1
22098: ARRAY
22099: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
22100: LD_INT 350
22102: PPUSH
22103: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
22107: LD_EXP 119
22111: PUSH
22112: LD_INT 4
22114: ARRAY
22115: PUSH
22116: LD_INT 5
22118: LESS
22119: PUSH
22120: LD_VAR 0 9
22124: PPUSH
22125: CALL_OW 461
22129: PUSH
22130: LD_INT 2
22132: EQUAL
22133: AND
22134: IFFALSE 22164
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22136: LD_INT 4
22138: PPUSH
22139: LD_INT 3
22141: PUSH
22142: LD_INT 1
22144: PUSH
22145: LD_INT 1
22147: PUSH
22148: LD_INT 5
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: PUSH
22157: EMPTY
22158: LIST
22159: PPUSH
22160: CALL 61148 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
22164: LD_EXP 119
22168: PUSH
22169: LD_INT 4
22171: ARRAY
22172: PUSH
22173: LD_INT 5
22175: GREATEREQUAL
22176: PUSH
22177: LD_EXP 119
22181: PUSH
22182: LD_INT 4
22184: ARRAY
22185: PPUSH
22186: LD_INT 58
22188: PUSH
22189: EMPTY
22190: LIST
22191: PPUSH
22192: CALL_OW 72
22196: PUSH
22197: LD_INT 5
22199: GREATEREQUAL
22200: AND
22201: IFFALSE 22100
// powellAllowRetreat := false ;
22203: LD_ADDR_EXP 19
22207: PUSH
22208: LD_INT 0
22210: ST_TO_ADDR
// activeAttacks := false ;
22211: LD_ADDR_EXP 16
22215: PUSH
22216: LD_INT 0
22218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22219: LD_INT 35
22221: PPUSH
22222: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22226: LD_INT 22
22228: PUSH
22229: LD_INT 6
22231: PUSH
22232: EMPTY
22233: LIST
22234: LIST
22235: PPUSH
22236: CALL_OW 69
22240: PUSH
22241: LD_INT 0
22243: EQUAL
22244: IFFALSE 22219
// tmp := mc_vehicles [ 4 ] ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_EXP 119
22255: PUSH
22256: LD_INT 4
22258: ARRAY
22259: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22260: LD_ADDR_VAR 0 1
22264: PUSH
22265: DOUBLE
22266: LD_INT 1
22268: DEC
22269: ST_TO_ADDR
22270: LD_EXP 18
22274: PUSH
22275: FOR_TO
22276: IFFALSE 22537
// begin for j in powellSquadAttack [ i ] do
22278: LD_ADDR_VAR 0 2
22282: PUSH
22283: LD_EXP 18
22287: PUSH
22288: LD_VAR 0 1
22292: ARRAY
22293: PUSH
22294: FOR_IN
22295: IFFALSE 22533
// begin forces := forces diff j ;
22297: LD_ADDR_VAR 0 6
22301: PUSH
22302: LD_VAR 0 6
22306: PUSH
22307: LD_VAR 0 2
22311: DIFF
22312: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22313: LD_VAR 0 2
22317: PPUSH
22318: LD_INT 1
22320: PPUSH
22321: CALL_OW 109
// wait ( 0 0$2 ) ;
22325: LD_INT 70
22327: PPUSH
22328: CALL_OW 67
// if IsInUnit ( j ) then
22332: LD_VAR 0 2
22336: PPUSH
22337: CALL_OW 310
22341: IFFALSE 22352
// ComExitBuilding ( j ) ;
22343: LD_VAR 0 2
22347: PPUSH
22348: CALL_OW 122
// if GetClass ( j ) <> 1 then
22352: LD_VAR 0 2
22356: PPUSH
22357: CALL_OW 257
22361: PUSH
22362: LD_INT 1
22364: NONEQUAL
22365: IFFALSE 22445
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22367: LD_VAR 0 10
22371: PUSH
22372: LD_INT 1
22374: ARRAY
22375: PPUSH
22376: CALL_OW 313
22380: PUSH
22381: LD_INT 5
22383: GREATEREQUAL
22384: IFFALSE 22406
// AddComEnterUnit ( j , arm [ 2 ] ) else
22386: LD_VAR 0 2
22390: PPUSH
22391: LD_VAR 0 10
22395: PUSH
22396: LD_INT 2
22398: ARRAY
22399: PPUSH
22400: CALL_OW 180
22404: GO 22424
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22406: LD_VAR 0 2
22410: PPUSH
22411: LD_VAR 0 10
22415: PUSH
22416: LD_INT 1
22418: ARRAY
22419: PPUSH
22420: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22424: LD_VAR 0 2
22428: PPUSH
22429: LD_INT 1
22431: PPUSH
22432: CALL_OW 183
// AddComExitBuilding ( j ) ;
22436: LD_VAR 0 2
22440: PPUSH
22441: CALL_OW 182
// end ; if i = 2 then
22445: LD_VAR 0 1
22449: PUSH
22450: LD_INT 2
22452: EQUAL
22453: IFFALSE 22470
// AddComMoveXY ( j , 61 , 93 ) ;
22455: LD_VAR 0 2
22459: PPUSH
22460: LD_INT 61
22462: PPUSH
22463: LD_INT 93
22465: PPUSH
22466: CALL_OW 171
// if i = 1 then
22470: LD_VAR 0 1
22474: PUSH
22475: LD_INT 1
22477: EQUAL
22478: IFFALSE 22531
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22480: LD_VAR 0 2
22484: PPUSH
22485: LD_VAR 0 3
22489: PUSH
22490: LD_INT 1
22492: ARRAY
22493: PPUSH
22494: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_VAR 0 3
22507: PPUSH
22508: LD_INT 1
22510: PPUSH
22511: CALL_OW 3
22515: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22516: LD_VAR 0 2
22520: PPUSH
22521: LD_INT 69
22523: PPUSH
22524: LD_INT 94
22526: PPUSH
22527: CALL_OW 171
// end ; end ;
22531: GO 22294
22533: POP
22534: POP
// end ;
22535: GO 22275
22537: POP
22538: POP
// wait ( 0 0$30 ) ;
22539: LD_INT 1050
22541: PPUSH
22542: CALL_OW 67
// MC_Kill ( 4 ) ;
22546: LD_INT 4
22548: PPUSH
22549: CALL 37121 0 1
// tmp := UnitsInside ( fac ) ;
22553: LD_ADDR_VAR 0 3
22557: PUSH
22558: LD_VAR 0 9
22562: PPUSH
22563: CALL_OW 313
22567: ST_TO_ADDR
// if tmp then
22568: LD_VAR 0 3
22572: IFFALSE 22693
// for i in tmp do
22574: LD_ADDR_VAR 0 1
22578: PUSH
22579: LD_VAR 0 3
22583: PUSH
22584: FOR_IN
22585: IFFALSE 22691
// begin ComExitBuilding ( i ) ;
22587: LD_VAR 0 1
22591: PPUSH
22592: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22596: LD_VAR 0 10
22600: PUSH
22601: LD_INT 2
22603: ARRAY
22604: PPUSH
22605: CALL_OW 313
22609: PUSH
22610: LD_INT 6
22612: LESS
22613: IFFALSE 22635
// AddComEnterUnit ( i , arm [ 2 ] ) else
22615: LD_VAR 0 1
22619: PPUSH
22620: LD_VAR 0 10
22624: PUSH
22625: LD_INT 2
22627: ARRAY
22628: PPUSH
22629: CALL_OW 180
22633: GO 22689
// if UnitsInside ( arm [ 1 ] ) < 6 then
22635: LD_VAR 0 10
22639: PUSH
22640: LD_INT 1
22642: ARRAY
22643: PPUSH
22644: CALL_OW 313
22648: PUSH
22649: LD_INT 6
22651: LESS
22652: IFFALSE 22674
// AddComEnterUnit ( i , arm [ 1 ] ) else
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 10
22663: PUSH
22664: LD_INT 1
22666: ARRAY
22667: PPUSH
22668: CALL_OW 180
22672: GO 22689
// AddComMoveXY ( i , 37 , 68 ) ;
22674: LD_VAR 0 1
22678: PPUSH
22679: LD_INT 37
22681: PPUSH
22682: LD_INT 68
22684: PPUSH
22685: CALL_OW 171
// end ;
22689: GO 22584
22691: POP
22692: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22693: LD_ADDR_VAR 0 11
22697: PUSH
22698: LD_VAR 0 6
22702: PPUSH
22703: LD_INT 26
22705: PUSH
22706: LD_INT 1
22708: PUSH
22709: EMPTY
22710: LIST
22711: LIST
22712: PPUSH
22713: CALL_OW 72
22717: PUSH
22718: LD_EXP 61
22722: DIFF
22723: ST_TO_ADDR
// if not speaker then
22724: LD_VAR 0 11
22728: NOT
22729: IFFALSE 22756
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22731: LD_ADDR_VAR 0 11
22735: PUSH
22736: LD_VAR 0 6
22740: PPUSH
22741: LD_INT 26
22743: PUSH
22744: LD_INT 1
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PPUSH
22751: CALL_OW 72
22755: ST_TO_ADDR
// if speaker then
22756: LD_VAR 0 11
22760: IFFALSE 22776
// speaker := speaker [ 1 ] ;
22762: LD_ADDR_VAR 0 11
22766: PUSH
22767: LD_VAR 0 11
22771: PUSH
22772: LD_INT 1
22774: ARRAY
22775: ST_TO_ADDR
// Video ( true ) ;
22776: LD_INT 1
22778: PPUSH
22779: CALL 104957 0 1
// CenterNowOnUnits ( Powell ) ;
22783: LD_EXP 60
22787: PPUSH
22788: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22792: LD_ADDR_VAR 0 3
22796: PUSH
22797: LD_VAR 0 6
22801: PPUSH
22802: LD_INT 3
22804: PUSH
22805: LD_INT 25
22807: PUSH
22808: LD_INT 1
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: PPUSH
22819: CALL_OW 72
22823: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22824: LD_ADDR_VAR 0 12
22828: PUSH
22829: LD_INT 22
22831: PUSH
22832: LD_INT 4
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: PUSH
22839: LD_INT 30
22841: PUSH
22842: LD_INT 32
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: PUSH
22849: LD_INT 58
22851: PUSH
22852: EMPTY
22853: LIST
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: PPUSH
22860: CALL_OW 69
22864: ST_TO_ADDR
// for i := 1 to 4 do
22865: LD_ADDR_VAR 0 1
22869: PUSH
22870: DOUBLE
22871: LD_INT 1
22873: DEC
22874: ST_TO_ADDR
22875: LD_INT 4
22877: PUSH
22878: FOR_TO
22879: IFFALSE 23020
// begin if IsInUnit ( tmp [ i ] ) then
22881: LD_VAR 0 3
22885: PUSH
22886: LD_VAR 0 1
22890: ARRAY
22891: PPUSH
22892: CALL_OW 310
22896: IFFALSE 22913
// ComExitBuilding ( tmp [ i ] ) ;
22898: LD_VAR 0 3
22902: PUSH
22903: LD_VAR 0 1
22907: ARRAY
22908: PPUSH
22909: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22913: LD_VAR 0 3
22917: PUSH
22918: LD_VAR 0 1
22922: ARRAY
22923: PPUSH
22924: LD_VAR 0 10
22928: PUSH
22929: LD_INT 1
22931: ARRAY
22932: PPUSH
22933: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22937: LD_VAR 0 3
22941: PUSH
22942: LD_VAR 0 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 1
22950: PPUSH
22951: CALL_OW 183
// if emp_towers then
22955: LD_VAR 0 12
22959: IFFALSE 23018
// begin AddComExitBuilding ( tmp [ i ] ) ;
22961: LD_VAR 0 3
22965: PUSH
22966: LD_VAR 0 1
22970: ARRAY
22971: PPUSH
22972: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22976: LD_VAR 0 3
22980: PUSH
22981: LD_VAR 0 1
22985: ARRAY
22986: PPUSH
22987: LD_VAR 0 12
22991: PUSH
22992: LD_INT 1
22994: ARRAY
22995: PPUSH
22996: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
23000: LD_ADDR_VAR 0 12
23004: PUSH
23005: LD_VAR 0 12
23009: PPUSH
23010: LD_INT 1
23012: PPUSH
23013: CALL_OW 3
23017: ST_TO_ADDR
// end ; end ;
23018: GO 22878
23020: POP
23021: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: LD_EXP 18
23031: PUSH
23032: LD_INT 1
23034: ARRAY
23035: PUSH
23036: LD_EXP 18
23040: PUSH
23041: LD_INT 2
23043: ARRAY
23044: ADD
23045: PPUSH
23046: LD_INT 26
23048: PUSH
23049: LD_INT 1
23051: PUSH
23052: EMPTY
23053: LIST
23054: LIST
23055: PPUSH
23056: CALL_OW 72
23060: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
23061: LD_ADDR_VAR 0 1
23065: PUSH
23066: LD_EXP 18
23070: PUSH
23071: LD_INT 2
23073: ARRAY
23074: PUSH
23075: FOR_IN
23076: IFFALSE 23094
// ComTurnUnit ( i , Powell ) ;
23078: LD_VAR 0 1
23082: PPUSH
23083: LD_EXP 60
23087: PPUSH
23088: CALL_OW 119
23092: GO 23075
23094: POP
23095: POP
// Say ( Powell , D5-Pow-1 ) ;
23096: LD_EXP 60
23100: PPUSH
23101: LD_STRING D5-Pow-1
23103: PPUSH
23104: CALL_OW 88
// if tmp then
23108: LD_VAR 0 3
23112: IFFALSE 23130
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
23114: LD_VAR 0 3
23118: PUSH
23119: LD_INT 1
23121: ARRAY
23122: PPUSH
23123: LD_STRING D5-Sol2-1
23125: PPUSH
23126: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
23130: LD_EXP 60
23134: PPUSH
23135: LD_STRING D5-Pow-2
23137: PPUSH
23138: CALL_OW 88
// if tmp > 1 then
23142: LD_VAR 0 3
23146: PUSH
23147: LD_INT 1
23149: GREATER
23150: IFFALSE 23168
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
23152: LD_VAR 0 3
23156: PUSH
23157: LD_INT 2
23159: ARRAY
23160: PPUSH
23161: LD_STRING D5-Sol2-2
23163: PPUSH
23164: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
23168: LD_EXP 60
23172: PPUSH
23173: LD_STRING D5-Pow-3
23175: PPUSH
23176: CALL_OW 88
// wait ( 0 0$1 ) ;
23180: LD_INT 35
23182: PPUSH
23183: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23187: LD_ADDR_VAR 0 3
23191: PUSH
23192: LD_EXP 18
23196: PUSH
23197: LD_INT 1
23199: ARRAY
23200: PUSH
23201: LD_EXP 18
23205: PUSH
23206: LD_INT 2
23208: ARRAY
23209: UNION
23210: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23211: LD_VAR 0 3
23215: PPUSH
23216: LD_INT 80
23218: PPUSH
23219: LD_INT 67
23221: PPUSH
23222: CALL_OW 114
// wait ( 0 0$2 ) ;
23226: LD_INT 70
23228: PPUSH
23229: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23233: LD_INT 79
23235: PPUSH
23236: LD_INT 72
23238: PPUSH
23239: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23243: LD_INT 70
23245: PPUSH
23246: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23250: LD_VAR 0 3
23254: PPUSH
23255: LD_INT 3
23257: PUSH
23258: LD_INT 24
23260: PUSH
23261: LD_INT 1000
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PPUSH
23272: CALL_OW 72
23276: IFFALSE 23243
// Say ( Powell , D5a-Pow-1 ) ;
23278: LD_EXP 60
23282: PPUSH
23283: LD_STRING D5a-Pow-1
23285: PPUSH
23286: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23290: LD_EXP 60
23294: PPUSH
23295: LD_STRING D5a-Pow-1a
23297: PPUSH
23298: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23302: LD_INT 24
23304: PPUSH
23305: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23309: LD_EXP 60
23313: PPUSH
23314: LD_STRING D5a-Pow-1b
23316: PPUSH
23317: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23321: LD_INT 10
23323: PPUSH
23324: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23328: LD_EXP 60
23332: PPUSH
23333: LD_STRING D5a-Pow-1c
23335: PPUSH
23336: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23340: LD_VAR 0 3
23344: PPUSH
23345: LD_INT 68
23347: PPUSH
23348: LD_INT 63
23350: PPUSH
23351: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23355: LD_INT 18
23357: PPUSH
23358: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23362: LD_EXP 60
23366: PPUSH
23367: LD_STRING D5a-Pow-1d
23369: PPUSH
23370: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23374: LD_INT 35
23376: PPUSH
23377: CALL_OW 67
// if not HasTask ( tmp ) then
23381: LD_VAR 0 3
23385: PPUSH
23386: CALL_OW 314
23390: NOT
23391: IFFALSE 23408
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23393: LD_VAR 0 3
23397: PPUSH
23398: LD_INT 68
23400: PPUSH
23401: LD_INT 63
23403: PPUSH
23404: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23408: LD_VAR 0 3
23412: PPUSH
23413: LD_INT 24
23415: PUSH
23416: LD_INT 1
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: PPUSH
23423: CALL_OW 72
23427: NOT
23428: IFFALSE 23374
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_INT 22
23437: PUSH
23438: LD_INT 4
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: LD_INT 92
23447: PUSH
23448: LD_INT 60
23450: PUSH
23451: LD_INT 93
23453: PUSH
23454: LD_INT 10
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: LIST
23462: PUSH
23463: LD_INT 3
23465: PUSH
23466: LD_INT 54
23468: PUSH
23469: EMPTY
23470: LIST
23471: PUSH
23472: EMPTY
23473: LIST
23474: LIST
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: LIST
23480: PPUSH
23481: CALL_OW 69
23485: PUSH
23486: LD_EXP 60
23490: DIFF
23491: ST_TO_ADDR
// if tmp then
23492: LD_VAR 0 3
23496: IFFALSE 23530
// for i in tmp do
23498: LD_ADDR_VAR 0 1
23502: PUSH
23503: LD_VAR 0 3
23507: PUSH
23508: FOR_IN
23509: IFFALSE 23528
// ComMoveXY ( i , 36 , 67 ) ;
23511: LD_VAR 0 1
23515: PPUSH
23516: LD_INT 36
23518: PPUSH
23519: LD_INT 67
23521: PPUSH
23522: CALL_OW 111
23526: GO 23508
23528: POP
23529: POP
// wait ( 0 0$3 ) ;
23530: LD_INT 105
23532: PPUSH
23533: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23537: LD_VAR 0 11
23541: PPUSH
23542: LD_STRING D6-Sol3-1
23544: PPUSH
23545: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23549: LD_EXP 60
23553: PPUSH
23554: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23558: LD_EXP 60
23562: PPUSH
23563: LD_STRING D6-Pow-1
23565: PPUSH
23566: CALL_OW 88
// tmp := [ ] ;
23570: LD_ADDR_VAR 0 3
23574: PUSH
23575: EMPTY
23576: ST_TO_ADDR
// for i = 1 to 2 do
23577: LD_ADDR_VAR 0 1
23581: PUSH
23582: DOUBLE
23583: LD_INT 1
23585: DEC
23586: ST_TO_ADDR
23587: LD_INT 2
23589: PUSH
23590: FOR_TO
23591: IFFALSE 23705
// begin uc_side := 8 ;
23593: LD_ADDR_OWVAR 20
23597: PUSH
23598: LD_INT 8
23600: ST_TO_ADDR
// uc_nation := 2 ;
23601: LD_ADDR_OWVAR 21
23605: PUSH
23606: LD_INT 2
23608: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23609: LD_INT 14
23611: PPUSH
23612: LD_INT 3
23614: PPUSH
23615: LD_INT 2
23617: PPUSH
23618: LD_INT 29
23620: PPUSH
23621: LD_INT 100
23623: PPUSH
23624: CALL 72551 0 5
// veh := CreateVehicle ;
23628: LD_ADDR_VAR 0 13
23632: PUSH
23633: CALL_OW 45
23637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23638: LD_VAR 0 13
23642: PPUSH
23643: LD_INT 4
23645: PPUSH
23646: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23650: LD_VAR 0 13
23654: PPUSH
23655: LD_INT 99
23657: PPUSH
23658: LD_INT 83
23660: PPUSH
23661: LD_INT 3
23663: PPUSH
23664: LD_INT 0
23666: PPUSH
23667: CALL_OW 50
// wait ( 3 ) ;
23671: LD_INT 3
23673: PPUSH
23674: CALL_OW 67
// Connect ( veh ) ;
23678: LD_VAR 0 13
23682: PPUSH
23683: CALL 75642 0 1
// tmp := tmp ^ veh ;
23687: LD_ADDR_VAR 0 3
23691: PUSH
23692: LD_VAR 0 3
23696: PUSH
23697: LD_VAR 0 13
23701: ADD
23702: ST_TO_ADDR
// end ;
23703: GO 23590
23705: POP
23706: POP
// wait ( 0 0$1 ) ;
23707: LD_INT 35
23709: PPUSH
23710: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23714: LD_INT 99
23716: PPUSH
23717: LD_INT 83
23719: PPUSH
23720: LD_INT 1
23722: PPUSH
23723: LD_INT 10
23725: PPUSH
23726: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23730: LD_INT 99
23732: PPUSH
23733: LD_INT 83
23735: PPUSH
23736: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23740: LD_VAR 0 11
23744: PPUSH
23745: LD_STRING D6-Sol3-2
23747: PPUSH
23748: CALL_OW 88
// async ;
23752: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23753: LD_EXP 60
23757: PPUSH
23758: LD_STRING D6-Pow-2
23760: PPUSH
23761: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23765: LD_VAR 0 3
23769: PUSH
23770: LD_INT 1
23772: ARRAY
23773: PPUSH
23774: LD_VAR 0 9
23778: PPUSH
23779: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23783: LD_VAR 0 3
23787: PUSH
23788: LD_INT 2
23790: ARRAY
23791: PPUSH
23792: LD_INT 22
23794: PUSH
23795: LD_INT 4
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: PUSH
23802: LD_INT 21
23804: PUSH
23805: LD_INT 3
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: PUSH
23812: EMPTY
23813: LIST
23814: LIST
23815: PPUSH
23816: CALL_OW 69
23820: PPUSH
23821: LD_VAR 0 3
23825: PUSH
23826: LD_INT 2
23828: ARRAY
23829: PPUSH
23830: CALL_OW 74
23834: PPUSH
23835: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23839: LD_EXP 60
23843: PPUSH
23844: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23848: LD_INT 99
23850: PPUSH
23851: LD_INT 83
23853: PPUSH
23854: LD_INT 1
23856: PPUSH
23857: CALL_OW 331
// repeat wait ( 4 ) ;
23861: LD_INT 4
23863: PPUSH
23864: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23868: LD_VAR 0 3
23872: PUSH
23873: LD_INT 1
23875: ARRAY
23876: PPUSH
23877: CALL_OW 256
23881: PUSH
23882: LD_INT 1000
23884: LESS
23885: IFFALSE 23903
// SetLives ( tmp [ 1 ] , 1000 ) ;
23887: LD_VAR 0 3
23891: PUSH
23892: LD_INT 1
23894: ARRAY
23895: PPUSH
23896: LD_INT 1000
23898: PPUSH
23899: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23903: LD_INT 22
23905: PUSH
23906: LD_INT 4
23908: PUSH
23909: EMPTY
23910: LIST
23911: LIST
23912: PUSH
23913: LD_INT 30
23915: PUSH
23916: LD_INT 3
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PPUSH
23927: CALL_OW 69
23931: PUSH
23932: LD_INT 0
23934: EQUAL
23935: IFFALSE 23861
// skirmish := false ;
23937: LD_ADDR_EXP 98
23941: PUSH
23942: LD_INT 0
23944: ST_TO_ADDR
// sync ;
23945: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23946: LD_EXP 60
23950: PPUSH
23951: LD_STRING D6a-Pow-1
23953: PPUSH
23954: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23958: LD_VAR 0 11
23962: PPUSH
23963: LD_STRING D6a-Sol3-1
23965: PPUSH
23966: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23970: LD_EXP 60
23974: PPUSH
23975: LD_STRING D6a-Pow-2
23977: PPUSH
23978: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23982: LD_VAR 0 11
23986: PPUSH
23987: LD_STRING D6a-Sol3-2
23989: PPUSH
23990: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23994: LD_EXP 60
23998: PPUSH
23999: LD_STRING D6a-Pow-3
24001: PPUSH
24002: CALL_OW 88
// powellCenterCameraMode := true ;
24006: LD_ADDR_EXP 20
24010: PUSH
24011: LD_INT 1
24013: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
24014: LD_ADDR_VAR 0 1
24018: PUSH
24019: LD_INT 22
24021: PUSH
24022: LD_INT 8
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 25
24031: PUSH
24032: LD_INT 2
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: EMPTY
24040: LIST
24041: LIST
24042: PPUSH
24043: CALL_OW 69
24047: PUSH
24048: FOR_IN
24049: IFFALSE 24104
// begin SetTag ( i , 1 ) ;
24051: LD_VAR 0 1
24055: PPUSH
24056: LD_INT 1
24058: PPUSH
24059: CALL_OW 109
// ComExitBuilding ( i ) ;
24063: LD_VAR 0 1
24067: PPUSH
24068: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
24072: LD_VAR 0 1
24076: PPUSH
24077: LD_INT 35
24079: PPUSH
24080: LD_INT 6
24082: PPUSH
24083: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
24087: LD_VAR 0 1
24091: PPUSH
24092: LD_INT 53
24094: PPUSH
24095: LD_INT 4
24097: PPUSH
24098: CALL_OW 171
// end ;
24102: GO 24048
24104: POP
24105: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
24106: LD_ADDR_VAR 0 3
24110: PUSH
24111: LD_INT 22
24113: PUSH
24114: LD_INT 4
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: PUSH
24121: LD_INT 21
24123: PUSH
24124: LD_INT 2
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PUSH
24131: LD_INT 3
24133: PUSH
24134: LD_INT 34
24136: PUSH
24137: LD_INT 12
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: PPUSH
24153: CALL_OW 69
24157: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
24158: LD_EXP 60
24162: PPUSH
24163: LD_VAR 0 3
24167: PPUSH
24168: LD_EXP 60
24172: PPUSH
24173: CALL_OW 74
24177: PPUSH
24178: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24182: LD_EXP 60
24186: PPUSH
24187: LD_INT 100
24189: PPUSH
24190: LD_INT 88
24192: PPUSH
24193: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24197: LD_EXP 60
24201: PPUSH
24202: LD_INT 100
24204: PPUSH
24205: LD_INT 75
24207: PPUSH
24208: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24212: LD_EXP 60
24216: PPUSH
24217: LD_INT 88
24219: PPUSH
24220: LD_INT 53
24222: PPUSH
24223: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24227: LD_INT 8
24229: PPUSH
24230: LD_EXP 60
24234: PPUSH
24235: CALL_OW 471
// repeat wait ( 3 ) ;
24239: LD_INT 3
24241: PPUSH
24242: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24246: LD_INT 22
24248: PUSH
24249: LD_INT 4
24251: PUSH
24252: EMPTY
24253: LIST
24254: LIST
24255: PUSH
24256: LD_INT 92
24258: PUSH
24259: LD_INT 100
24261: PUSH
24262: LD_INT 75
24264: PUSH
24265: LD_INT 6
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: LIST
24272: LIST
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: PPUSH
24278: CALL_OW 69
24282: IFFALSE 24239
// async ;
24284: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24285: LD_EXP 60
24289: PPUSH
24290: LD_STRING D6b-Pow-1
24292: PPUSH
24293: CALL_OW 88
// repeat wait ( 3 ) ;
24297: LD_INT 3
24299: PPUSH
24300: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24304: LD_EXP 60
24308: PPUSH
24309: CALL_OW 310
24313: PPUSH
24314: CALL_OW 256
24318: PUSH
24319: LD_INT 1000
24321: LESS
24322: IFFALSE 24341
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24324: LD_EXP 60
24328: PPUSH
24329: CALL_OW 310
24333: PPUSH
24334: LD_INT 1000
24336: PPUSH
24337: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24341: LD_EXP 60
24345: PPUSH
24346: CALL_OW 256
24350: PUSH
24351: LD_INT 1000
24353: LESS
24354: IFFALSE 24368
// SetLives ( Powell , 1000 ) ;
24356: LD_EXP 60
24360: PPUSH
24361: LD_INT 1000
24363: PPUSH
24364: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24368: LD_EXP 60
24372: PPUSH
24373: LD_EXP 65
24377: PPUSH
24378: CALL_OW 296
24382: PUSH
24383: LD_INT 5
24385: LESS
24386: PUSH
24387: LD_EXP 60
24391: PPUSH
24392: CALL_OW 310
24396: PPUSH
24397: LD_EXP 65
24401: PPUSH
24402: CALL_OW 296
24406: PUSH
24407: LD_INT 5
24409: LESS
24410: OR
24411: IFFALSE 24430
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24413: LD_EXP 60
24417: PPUSH
24418: CALL_OW 310
24422: PPUSH
24423: LD_INT 100
24425: PPUSH
24426: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24430: LD_EXP 60
24434: PPUSH
24435: CALL_OW 310
24439: NOT
24440: IFFALSE 24297
// DoNotAttack ( 8 , powellBomb ) ;
24442: LD_INT 8
24444: PPUSH
24445: LD_EXP 65
24449: PPUSH
24450: CALL_OW 471
// game_speed := 4 ;
24454: LD_ADDR_OWVAR 65
24458: PUSH
24459: LD_INT 4
24461: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24462: LD_EXP 60
24466: PPUSH
24467: LD_STRING D6b-Pow-1a
24469: PPUSH
24470: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24474: LD_EXP 60
24478: PPUSH
24479: LD_EXP 65
24483: PPUSH
24484: CALL_OW 180
// sync ;
24488: SYNC
// repeat wait ( 0 0$1 ) ;
24489: LD_INT 35
24491: PPUSH
24492: CALL_OW 67
// until IsInUnit ( Powell ) ;
24496: LD_EXP 60
24500: PPUSH
24501: CALL_OW 310
24505: IFFALSE 24489
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24507: LD_INT 8
24509: PPUSH
24510: LD_EXP 60
24514: PPUSH
24515: CALL_OW 310
24519: PPUSH
24520: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24524: LD_EXP 60
24528: PPUSH
24529: LD_INT 91
24531: PPUSH
24532: LD_INT 44
24534: PPUSH
24535: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24539: LD_EXP 60
24543: PPUSH
24544: LD_INT 96
24546: PPUSH
24547: LD_INT 44
24549: PPUSH
24550: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24554: LD_EXP 60
24558: PPUSH
24559: LD_INT 96
24561: PPUSH
24562: LD_INT 41
24564: PPUSH
24565: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24569: LD_EXP 60
24573: PPUSH
24574: LD_INT 92
24576: PPUSH
24577: LD_INT 39
24579: PPUSH
24580: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24584: LD_EXP 60
24588: PPUSH
24589: LD_INT 88
24591: PPUSH
24592: LD_INT 41
24594: PPUSH
24595: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24599: LD_EXP 60
24603: PPUSH
24604: LD_INT 91
24606: PPUSH
24607: LD_INT 44
24609: PPUSH
24610: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24614: LD_EXP 60
24618: PPUSH
24619: LD_INT 96
24621: PPUSH
24622: LD_INT 44
24624: PPUSH
24625: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24629: LD_EXP 60
24633: PPUSH
24634: LD_INT 96
24636: PPUSH
24637: LD_INT 41
24639: PPUSH
24640: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24644: LD_EXP 60
24648: PPUSH
24649: LD_INT 92
24651: PPUSH
24652: LD_INT 39
24654: PPUSH
24655: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24659: LD_EXP 60
24663: PPUSH
24664: LD_INT 88
24666: PPUSH
24667: LD_INT 41
24669: PPUSH
24670: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24674: LD_EXP 60
24678: PPUSH
24679: LD_INT 91
24681: PPUSH
24682: LD_INT 44
24684: PPUSH
24685: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24689: LD_EXP 60
24693: PPUSH
24694: LD_INT 93
24696: PPUSH
24697: LD_INT 39
24699: PPUSH
24700: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24704: LD_EXP 60
24708: PPUSH
24709: LD_INT 93
24711: PPUSH
24712: LD_INT 36
24714: PPUSH
24715: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24719: LD_INT 122
24721: PPUSH
24722: CALL_OW 67
// game_speed := 4 ;
24726: LD_ADDR_OWVAR 65
24730: PUSH
24731: LD_INT 4
24733: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24734: LD_EXP 60
24738: PPUSH
24739: LD_STRING D6b-Pow-1b
24741: PPUSH
24742: CALL_OW 88
// tmp := [ ] ;
24746: LD_ADDR_VAR 0 3
24750: PUSH
24751: EMPTY
24752: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24753: LD_ADDR_VAR 0 5
24757: PUSH
24758: LD_INT 78
24760: PUSH
24761: LD_INT 47
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PUSH
24768: LD_INT 106
24770: PUSH
24771: LD_INT 53
24773: PUSH
24774: EMPTY
24775: LIST
24776: LIST
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24782: LD_ADDR_VAR 0 1
24786: PUSH
24787: LD_INT 22
24789: PUSH
24790: LD_INT 8
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 21
24799: PUSH
24800: LD_INT 3
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: LD_INT 92
24809: PUSH
24810: LD_INT 90
24812: PUSH
24813: LD_INT 52
24815: PUSH
24816: LD_INT 12
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: LIST
24829: PPUSH
24830: CALL_OW 69
24834: PUSH
24835: FOR_IN
24836: IFFALSE 24861
// tmp := tmp ^ UnitsInside ( i ) ;
24838: LD_ADDR_VAR 0 3
24842: PUSH
24843: LD_VAR 0 3
24847: PUSH
24848: LD_VAR 0 1
24852: PPUSH
24853: CALL_OW 313
24857: ADD
24858: ST_TO_ADDR
24859: GO 24835
24861: POP
24862: POP
// for i in tmp do
24863: LD_ADDR_VAR 0 1
24867: PUSH
24868: LD_VAR 0 3
24872: PUSH
24873: FOR_IN
24874: IFFALSE 25036
// begin dist := 9999 ;
24876: LD_ADDR_VAR 0 8
24880: PUSH
24881: LD_INT 9999
24883: ST_TO_ADDR
// _xy := [ ] ;
24884: LD_ADDR_VAR 0 7
24888: PUSH
24889: EMPTY
24890: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24891: LD_VAR 0 1
24895: PPUSH
24896: LD_INT 1
24898: PPUSH
24899: CALL_OW 109
// ComExitBuilding ( i ) ;
24903: LD_VAR 0 1
24907: PPUSH
24908: CALL_OW 122
// for j in xy do
24912: LD_ADDR_VAR 0 2
24916: PUSH
24917: LD_VAR 0 5
24921: PUSH
24922: FOR_IN
24923: IFFALSE 25005
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24925: LD_VAR 0 1
24929: PPUSH
24930: LD_VAR 0 2
24934: PUSH
24935: LD_INT 1
24937: ARRAY
24938: PPUSH
24939: LD_VAR 0 2
24943: PUSH
24944: LD_INT 2
24946: ARRAY
24947: PPUSH
24948: CALL_OW 297
24952: PUSH
24953: LD_VAR 0 8
24957: LESS
24958: IFFALSE 25003
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24960: LD_ADDR_VAR 0 8
24964: PUSH
24965: LD_VAR 0 1
24969: PPUSH
24970: LD_VAR 0 2
24974: PUSH
24975: LD_INT 1
24977: ARRAY
24978: PPUSH
24979: LD_VAR 0 2
24983: PUSH
24984: LD_INT 2
24986: ARRAY
24987: PPUSH
24988: CALL_OW 297
24992: ST_TO_ADDR
// _xy := j ;
24993: LD_ADDR_VAR 0 7
24997: PUSH
24998: LD_VAR 0 2
25002: ST_TO_ADDR
// end ;
25003: GO 24922
25005: POP
25006: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
25007: LD_VAR 0 1
25011: PPUSH
25012: LD_VAR 0 7
25016: PUSH
25017: LD_INT 1
25019: ARRAY
25020: PPUSH
25021: LD_VAR 0 7
25025: PUSH
25026: LD_INT 2
25028: ARRAY
25029: PPUSH
25030: CALL_OW 171
// end ;
25034: GO 24873
25036: POP
25037: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
25038: LD_ADDR_VAR 0 4
25042: PUSH
25043: LD_VAR 0 3
25047: PPUSH
25048: LD_INT 26
25050: PUSH
25051: LD_INT 1
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 25
25060: PUSH
25061: LD_INT 1
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PPUSH
25072: CALL_OW 72
25076: ST_TO_ADDR
// if tmp2 < 2 then
25077: LD_VAR 0 4
25081: PUSH
25082: LD_INT 2
25084: LESS
25085: IFFALSE 25154
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_INT 22
25094: PUSH
25095: LD_INT 8
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: PUSH
25102: LD_INT 26
25104: PUSH
25105: LD_INT 1
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 3
25114: PUSH
25115: LD_INT 25
25117: PUSH
25118: LD_INT 15
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: EMPTY
25126: LIST
25127: LIST
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: PPUSH
25134: CALL_OW 69
25138: PUSH
25139: LD_EXP 62
25143: PUSH
25144: LD_EXP 63
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: DIFF
25153: ST_TO_ADDR
// if tmp2 then
25154: LD_VAR 0 4
25158: IFFALSE 25176
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
25160: LD_VAR 0 4
25164: PUSH
25165: LD_INT 1
25167: ARRAY
25168: PPUSH
25169: LD_STRING D6b-ArSol1-1
25171: PPUSH
25172: CALL_OW 88
// async ;
25176: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25177: LD_EXP 60
25181: PPUSH
25182: LD_STRING D6b-Pow-2
25184: PPUSH
25185: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25189: LD_INT 18
25191: PPUSH
25192: CALL_OW 67
// if tmp2 > 1 then
25196: LD_VAR 0 4
25200: PUSH
25201: LD_INT 1
25203: GREATER
25204: IFFALSE 25222
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25206: LD_VAR 0 4
25210: PUSH
25211: LD_INT 2
25213: ARRAY
25214: PPUSH
25215: LD_STRING D6b-ArSol2-1
25217: PPUSH
25218: CALL_OW 88
// sync ;
25222: SYNC
// repeat wait ( 5 ) ;
25223: LD_INT 5
25225: PPUSH
25226: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25230: LD_INT 93
25232: PPUSH
25233: LD_INT 36
25235: PPUSH
25236: CALL_OW 428
25240: PPUSH
25241: CALL_OW 255
25245: PUSH
25246: LD_INT 4
25248: EQUAL
25249: IFFALSE 25223
// DialogueOn ;
25251: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25255: LD_INT 10
25257: PPUSH
25258: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25262: LD_EXP 60
25266: PPUSH
25267: LD_STRING D6b-Pow-2a
25269: PPUSH
25270: CALL_OW 88
// DialogueOff ;
25274: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25278: LD_EXP 60
25282: PPUSH
25283: CALL_OW 310
25287: PPUSH
25288: LD_INT 332
25290: PPUSH
25291: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25295: LD_INT 93
25297: PPUSH
25298: LD_INT 35
25300: PPUSH
25301: LD_INT 1
25303: PPUSH
25304: LD_INT 6
25306: NEG
25307: PPUSH
25308: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25312: LD_INT 35
25314: PPUSH
25315: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25319: LD_INT 332
25321: PPUSH
25322: CALL_OW 256
25326: PUSH
25327: LD_INT 1000
25329: LESS
25330: PUSH
25331: LD_INT 332
25333: PPUSH
25334: CALL_OW 300
25338: AND
25339: IFFALSE 25351
// SetLives ( kozlov_fac , 0 ) ;
25341: LD_INT 332
25343: PPUSH
25344: LD_INT 0
25346: PPUSH
25347: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25351: LD_INT 332
25353: PPUSH
25354: CALL_OW 301
25358: PUSH
25359: LD_EXP 60
25363: PPUSH
25364: CALL_OW 301
25368: OR
25369: IFFALSE 25312
// game_speed := 4 ;
25371: LD_ADDR_OWVAR 65
25375: PUSH
25376: LD_INT 4
25378: ST_TO_ADDR
// powellCenterCameraMode := false ;
25379: LD_ADDR_EXP 20
25383: PUSH
25384: LD_INT 0
25386: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25387: LD_ADDR_VAR 0 1
25391: PUSH
25392: LD_VAR 0 3
25396: PUSH
25397: LD_INT 22
25399: PUSH
25400: LD_INT 8
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 25
25409: PUSH
25410: LD_INT 2
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: PPUSH
25421: CALL_OW 69
25425: UNION
25426: PUSH
25427: FOR_IN
25428: IFFALSE 25444
// SetTag ( i , 0 ) ;
25430: LD_VAR 0 1
25434: PPUSH
25435: LD_INT 0
25437: PPUSH
25438: CALL_OW 109
25442: GO 25427
25444: POP
25445: POP
// wait ( 0 0$3 ) ;
25446: LD_INT 105
25448: PPUSH
25449: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25453: LD_INT 93
25455: PPUSH
25456: LD_INT 35
25458: PPUSH
25459: LD_INT 1
25461: PPUSH
25462: CALL_OW 331
// DialogueOn ;
25466: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25470: LD_VAR 0 11
25474: PPUSH
25475: LD_STRING D6c-Sol3-1
25477: PPUSH
25478: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25482: LD_INT 10
25484: PPUSH
25485: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25489: LD_EXP 40
25493: PPUSH
25494: LD_STRING D6c-JMM-1
25496: PPUSH
25497: CALL_OW 88
// if Cyrus then
25501: LD_EXP 46
25505: IFFALSE 25519
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25507: LD_EXP 46
25511: PPUSH
25512: LD_STRING D6c-Cyrus-1
25514: PPUSH
25515: CALL_OW 88
// if Bobby then
25519: LD_EXP 45
25523: IFFALSE 25537
// Say ( Bobby , D6c-Bobby-1 ) ;
25525: LD_EXP 45
25529: PPUSH
25530: LD_STRING D6c-Bobby-1
25532: PPUSH
25533: CALL_OW 88
// if Cornel then
25537: LD_EXP 51
25541: IFFALSE 25555
// Say ( Cornel , D6c-Corn-1 ) ;
25543: LD_EXP 51
25547: PPUSH
25548: LD_STRING D6c-Corn-1
25550: PPUSH
25551: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25555: LD_ADDR_VAR 0 4
25559: PUSH
25560: LD_INT 2
25562: PUSH
25563: LD_INT 22
25565: PUSH
25566: LD_INT 1
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: LD_INT 22
25575: PUSH
25576: LD_INT 4
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 26
25590: PUSH
25591: LD_INT 1
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: LD_INT 23
25600: PUSH
25601: LD_INT 1
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: LIST
25612: PPUSH
25613: CALL_OW 69
25617: PUSH
25618: LD_VAR 0 11
25622: PUSH
25623: LD_EXP 40
25627: UNION
25628: PUSH
25629: LD_EXP 61
25633: UNION
25634: DIFF
25635: ST_TO_ADDR
// if tmp2 then
25636: LD_VAR 0 4
25640: IFFALSE 25658
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25642: LD_VAR 0 4
25646: PUSH
25647: LD_INT 1
25649: ARRAY
25650: PPUSH
25651: LD_STRING D6c-Sol1-1
25653: PPUSH
25654: CALL_OW 88
// if Lisa then
25658: LD_EXP 43
25662: IFFALSE 25676
// Say ( Lisa , D6c-Lisa-1 ) ;
25664: LD_EXP 43
25668: PPUSH
25669: LD_STRING D6c-Lisa-1
25671: PPUSH
25672: CALL_OW 88
// if Gary then
25676: LD_EXP 52
25680: IFFALSE 25694
// Say ( Gary , D6c-Gary-1 ) ;
25682: LD_EXP 52
25686: PPUSH
25687: LD_STRING D6c-Gary-1
25689: PPUSH
25690: CALL_OW 88
// if Donaldson then
25694: LD_EXP 44
25698: IFFALSE 25712
// Say ( Donaldson , D6c-Don-1 ) ;
25700: LD_EXP 44
25704: PPUSH
25705: LD_STRING D6c-Don-1
25707: PPUSH
25708: CALL_OW 88
// if tmp2 > 1 then
25712: LD_VAR 0 4
25716: PUSH
25717: LD_INT 1
25719: GREATER
25720: IFFALSE 25738
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25722: LD_VAR 0 4
25726: PUSH
25727: LD_INT 2
25729: ARRAY
25730: PPUSH
25731: LD_STRING D6c-Sol2-1
25733: PPUSH
25734: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25738: LD_VAR 0 11
25742: PPUSH
25743: LD_STRING D6c-Sol3-2
25745: PPUSH
25746: CALL_OW 88
// if IsInUnit ( JMM ) then
25750: LD_EXP 40
25754: PPUSH
25755: CALL_OW 310
25759: IFFALSE 25777
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25761: LD_EXP 40
25765: PPUSH
25766: CALL_OW 310
25770: PPUSH
25771: CALL_OW 87
25775: GO 25786
// CenterNowOnUnits ( JMM ) ;
25777: LD_EXP 40
25781: PPUSH
25782: CALL_OW 87
// dwait ( 0 0$2 ) ;
25786: LD_INT 70
25788: PPUSH
25789: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25793: LD_EXP 40
25797: PPUSH
25798: LD_STRING D6c-JMM-2
25800: PPUSH
25801: CALL_OW 88
// DialogueOff ;
25805: CALL_OW 7
// Video ( false ) ;
25809: LD_INT 0
25811: PPUSH
25812: CALL 104957 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25816: LD_INT 22
25818: PUSH
25819: LD_INT 4
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PPUSH
25826: CALL_OW 69
25830: PPUSH
25831: LD_INT 1
25833: PPUSH
25834: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25838: LD_INT 4
25840: PPUSH
25841: LD_INT 4
25843: PPUSH
25844: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25848: LD_ADDR_VAR 0 1
25852: PUSH
25853: LD_INT 4
25855: PPUSH
25856: LD_INT 1
25858: PPUSH
25859: LD_INT 2
25861: PPUSH
25862: CALL 67599 0 3
25866: PUSH
25867: FOR_IN
25868: IFFALSE 25905
// if GetTech ( i , 1 ) <> state_researched then
25870: LD_VAR 0 1
25874: PPUSH
25875: LD_INT 1
25877: PPUSH
25878: CALL_OW 321
25882: PUSH
25883: LD_INT 2
25885: NONEQUAL
25886: IFFALSE 25903
// SetTech ( i , 1 , state_researched ) ;
25888: LD_VAR 0 1
25892: PPUSH
25893: LD_INT 1
25895: PPUSH
25896: LD_INT 2
25898: PPUSH
25899: CALL_OW 322
25903: GO 25867
25905: POP
25906: POP
// missionStage := 6 ;
25907: LD_ADDR_EXP 15
25911: PUSH
25912: LD_INT 6
25914: ST_TO_ADDR
// activeAttacks := true ;
25915: LD_ADDR_EXP 16
25919: PUSH
25920: LD_INT 1
25922: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25923: LD_STRING M2
25925: PPUSH
25926: CALL_OW 337
// SaveForQuickRestart ;
25930: CALL_OW 22
// wait ( 0 0$40 ) ;
25934: LD_INT 1400
25936: PPUSH
25937: CALL_OW 67
// DialogueOn ;
25941: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
25945: LD_EXP 64
25949: PPUSH
25950: LD_STRING D7-Friend-1
25952: PPUSH
25953: CALL 108904 0 2
// Say ( JMM , D7-JMM-1 ) ;
25957: LD_EXP 40
25961: PPUSH
25962: LD_STRING D7-JMM-1
25964: PPUSH
25965: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
25969: LD_EXP 64
25973: PPUSH
25974: LD_STRING D7-Friend-2
25976: PPUSH
25977: CALL 108904 0 2
// Say ( JMM , D7-JMM-2 ) ;
25981: LD_EXP 40
25985: PPUSH
25986: LD_STRING D7-JMM-2
25988: PPUSH
25989: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
25993: LD_EXP 64
25997: PPUSH
25998: LD_STRING D7-Friend-3
26000: PPUSH
26001: CALL 108904 0 2
// Say ( JMM , D7-JMM-3 ) ;
26005: LD_EXP 40
26009: PPUSH
26010: LD_STRING D7-JMM-3
26012: PPUSH
26013: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
26017: LD_EXP 64
26021: PPUSH
26022: LD_STRING D7-Friend-4
26024: PPUSH
26025: CALL 108904 0 2
// Say ( JMM , D7-JMM-4 ) ;
26029: LD_EXP 40
26033: PPUSH
26034: LD_STRING D7-JMM-4
26036: PPUSH
26037: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
26041: LD_EXP 64
26045: PPUSH
26046: LD_STRING D7-Friend-5
26048: PPUSH
26049: CALL 108904 0 2
// Say ( JMM , D7-JMM-5 ) ;
26053: LD_EXP 40
26057: PPUSH
26058: LD_STRING D7-JMM-5
26060: PPUSH
26061: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
26065: LD_EXP 64
26069: PPUSH
26070: LD_STRING D7-Friend-6
26072: PPUSH
26073: CALL 108904 0 2
// Say ( JMM , D7-JMM-6 ) ;
26077: LD_EXP 40
26081: PPUSH
26082: LD_STRING D7-JMM-6
26084: PPUSH
26085: CALL_OW 88
// DialogueOff ;
26089: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
26093: LD_STRING Mlegion
26095: PPUSH
26096: CALL_OW 337
// skirmish := true ;
26100: LD_ADDR_EXP 98
26104: PUSH
26105: LD_INT 1
26107: ST_TO_ADDR
// RebuildKozlovFactory ;
26108: CALL 5036 0 0
// end ;
26112: PPOPN 13
26114: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
26115: LD_EXP 20
26119: PUSH
26120: LD_EXP 60
26124: PPUSH
26125: CALL_OW 300
26129: AND
26130: IFFALSE 26172
26132: GO 26134
26134: DISABLE
// begin enable ;
26135: ENABLE
// if IsInUnit ( Powell ) then
26136: LD_EXP 60
26140: PPUSH
26141: CALL_OW 310
26145: IFFALSE 26163
// CenterOnUnits ( IsInUnit ( Powell ) ) else
26147: LD_EXP 60
26151: PPUSH
26152: CALL_OW 310
26156: PPUSH
26157: CALL_OW 85
26161: GO 26172
// CenterOnUnits ( Powell ) ;
26163: LD_EXP 60
26167: PPUSH
26168: CALL_OW 85
// end ;
26172: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
26173: LD_INT 22
26175: PUSH
26176: LD_INT 8
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 34
26185: PUSH
26186: LD_INT 48
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PPUSH
26197: CALL_OW 69
26201: IFFALSE 26475
26203: GO 26205
26205: DISABLE
26206: LD_INT 0
26208: PPUSH
26209: PPUSH
// begin if missionStage < 9 then
26210: LD_EXP 15
26214: PUSH
26215: LD_INT 9
26217: LESS
26218: IFFALSE 26228
// missionStage := 9 ;
26220: LD_ADDR_EXP 15
26224: PUSH
26225: LD_INT 9
26227: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26228: LD_ADDR_VAR 0 1
26232: PUSH
26233: LD_INT 22
26235: PUSH
26236: LD_INT 8
26238: PUSH
26239: EMPTY
26240: LIST
26241: LIST
26242: PUSH
26243: LD_INT 34
26245: PUSH
26246: LD_INT 48
26248: PUSH
26249: EMPTY
26250: LIST
26251: LIST
26252: PUSH
26253: EMPTY
26254: LIST
26255: LIST
26256: PPUSH
26257: CALL_OW 69
26261: PUSH
26262: LD_INT 1
26264: ARRAY
26265: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26266: LD_INT 175
26268: PPUSH
26269: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26273: LD_EXP 12
26277: PUSH
26278: LD_EXP 3
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: LD_INT 2
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: IN
26293: OR
26294: IFFALSE 26317
// target := [ 68 , 108 , 1 ] else
26296: LD_ADDR_VAR 0 2
26300: PUSH
26301: LD_INT 68
26303: PUSH
26304: LD_INT 108
26306: PUSH
26307: LD_INT 1
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: LIST
26314: ST_TO_ADDR
26315: GO 26336
// target := [ 181 , 88 , 2 ] ;
26317: LD_ADDR_VAR 0 2
26321: PUSH
26322: LD_INT 181
26324: PUSH
26325: LD_INT 88
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26336: LD_VAR 0 1
26340: PPUSH
26341: LD_VAR 0 2
26345: PUSH
26346: LD_INT 1
26348: ARRAY
26349: PPUSH
26350: LD_VAR 0 2
26354: PUSH
26355: LD_INT 2
26357: ARRAY
26358: PPUSH
26359: CALL_OW 176
// if target [ 3 ] = 1 then
26363: LD_VAR 0 2
26367: PUSH
26368: LD_INT 3
26370: ARRAY
26371: PUSH
26372: LD_INT 1
26374: EQUAL
26375: IFFALSE 26391
// SayRadio ( Kurt , D12-Kurt-1 ) else
26377: LD_EXP 62
26381: PPUSH
26382: LD_STRING D12-Kurt-1
26384: PPUSH
26385: CALL_OW 94
26389: GO 26415
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26391: LD_EXP 62
26395: PPUSH
26396: LD_STRING D12a-Kurt-1
26398: PPUSH
26399: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26403: LD_EXP 77
26407: PPUSH
26408: LD_STRING D12a-Roth-1
26410: PPUSH
26411: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26415: LD_INT 350
26417: PPUSH
26418: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26422: LD_VAR 0 1
26426: PPUSH
26427: LD_INT 22
26429: PUSH
26430: LD_INT 8
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 23
26439: PUSH
26440: LD_INT 2
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: LD_INT 30
26449: PUSH
26450: LD_INT 3
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: PPUSH
26462: CALL_OW 69
26466: PUSH
26467: LD_INT 1
26469: ARRAY
26470: PPUSH
26471: CALL_OW 228
// end ;
26475: PPOPN 2
26477: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26478: LD_EXP 62
26482: PPUSH
26483: CALL_OW 256
26487: PUSH
26488: LD_INT 999
26490: LESS
26491: PUSH
26492: LD_INT 22
26494: PUSH
26495: LD_INT 8
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: PUSH
26502: LD_INT 21
26504: PUSH
26505: LD_INT 1
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: LD_INT 23
26514: PUSH
26515: LD_INT 2
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 69
26531: PUSH
26532: LD_INT 9
26534: PUSH
26535: LD_INT 8
26537: PUSH
26538: LD_INT 7
26540: PUSH
26541: LD_INT 6
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: LIST
26548: LIST
26549: PUSH
26550: LD_OWVAR 67
26554: ARRAY
26555: LESSEQUAL
26556: OR
26557: PUSH
26558: LD_INT 22
26560: PUSH
26561: LD_INT 8
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: PUSH
26568: LD_INT 34
26570: PUSH
26571: LD_INT 48
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PPUSH
26582: CALL_OW 69
26586: NOT
26587: AND
26588: PUSH
26589: LD_EXP 62
26593: PPUSH
26594: CALL_OW 302
26598: AND
26599: PUSH
26600: LD_INT 5
26602: PPUSH
26603: LD_INT 22
26605: PUSH
26606: LD_INT 1
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PPUSH
26613: CALL_OW 70
26617: AND
26618: IFFALSE 27362
26620: GO 26622
26622: DISABLE
26623: LD_INT 0
26625: PPUSH
26626: PPUSH
26627: PPUSH
// begin legionDestroyed := true ;
26628: LD_ADDR_EXP 22
26632: PUSH
26633: LD_INT 1
26635: ST_TO_ADDR
// DialogueOn ;
26636: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26640: LD_EXP 40
26644: PPUSH
26645: LD_STRING D13-JMM-1
26647: PPUSH
26648: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26652: LD_EXP 62
26656: PPUSH
26657: LD_STRING D13-Kurt-1
26659: PPUSH
26660: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26664: LD_EXP 40
26668: PPUSH
26669: LD_STRING D13-JMM-2
26671: PPUSH
26672: CALL_OW 88
// if FakeInfo then
26676: LD_EXP 12
26680: IFFALSE 26700
// begin Say ( Kurt , D13-Kurt-2 ) ;
26682: LD_EXP 62
26686: PPUSH
26687: LD_STRING D13-Kurt-2
26689: PPUSH
26690: CALL_OW 88
// DialogueOff ;
26694: CALL_OW 7
// exit ;
26698: GO 27362
// end ; if not KurtStatus then
26700: LD_EXP 3
26704: NOT
26705: IFFALSE 26721
// Say ( Kurt , D13-Kurt-2b ) else
26707: LD_EXP 62
26711: PPUSH
26712: LD_STRING D13-Kurt-2b
26714: PPUSH
26715: CALL_OW 88
26719: GO 26733
// Say ( Kurt , D13-Kurt-2a ) ;
26721: LD_EXP 62
26725: PPUSH
26726: LD_STRING D13-Kurt-2a
26728: PPUSH
26729: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26733: LD_EXP 40
26737: PPUSH
26738: LD_STRING D13-JMM-3
26740: PPUSH
26741: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26745: LD_EXP 62
26749: PPUSH
26750: LD_STRING D13-Kurt-3
26752: PPUSH
26753: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26757: LD_EXP 40
26761: PPUSH
26762: LD_STRING D13-JMM-4
26764: PPUSH
26765: CALL_OW 88
// DialogueOff ;
26769: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26773: LD_STRING MlegionOut
26775: PPUSH
26776: CALL_OW 337
// MC_Kill ( 3 ) ;
26780: LD_INT 3
26782: PPUSH
26783: CALL 37121 0 1
// KillUnit ( Kozlov ) ;
26787: LD_EXP 63
26791: PPUSH
26792: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26796: LD_ADDR_VAR 0 1
26800: PUSH
26801: LD_INT 22
26803: PUSH
26804: LD_INT 8
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: PUSH
26811: LD_INT 23
26813: PUSH
26814: LD_INT 3
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 3
26823: PUSH
26824: LD_INT 21
26826: PUSH
26827: LD_INT 33
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: LIST
26842: PPUSH
26843: CALL_OW 69
26847: PUSH
26848: FOR_IN
26849: IFFALSE 26862
// KillUnit ( i ) ;
26851: LD_VAR 0 1
26855: PPUSH
26856: CALL_OW 66
26860: GO 26848
26862: POP
26863: POP
// ChangeSideFog ( 8 , 1 ) ;
26864: LD_INT 8
26866: PPUSH
26867: LD_INT 1
26869: PPUSH
26870: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26874: LD_ADDR_VAR 0 2
26878: PUSH
26879: LD_INT 22
26881: PUSH
26882: LD_INT 8
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 21
26891: PUSH
26892: LD_INT 1
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PPUSH
26903: CALL_OW 69
26907: PUSH
26908: LD_EXP 63
26912: PUSH
26913: LD_EXP 62
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: DIFF
26922: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26923: LD_VAR 0 2
26927: PUSH
26928: LD_INT 6
26930: PUSH
26931: LD_INT 5
26933: PUSH
26934: LD_INT 4
26936: PUSH
26937: LD_INT 3
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: PUSH
26946: LD_OWVAR 67
26950: ARRAY
26951: GREATEREQUAL
26952: IFFALSE 27104
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26954: LD_ADDR_VAR 0 3
26958: PUSH
26959: LD_INT 6
26961: PUSH
26962: LD_INT 5
26964: PUSH
26965: LD_INT 4
26967: PUSH
26968: LD_INT 3
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: LIST
26975: LIST
26976: PUSH
26977: LD_OWVAR 67
26981: ARRAY
26982: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26983: LD_ADDR_VAR 0 1
26987: PUSH
26988: DOUBLE
26989: LD_VAR 0 2
26993: PUSH
26994: LD_VAR 0 3
26998: PUSH
26999: LD_INT 1
27001: PLUS
27002: MINUS
27003: INC
27004: ST_TO_ADDR
27005: LD_INT 1
27007: PUSH
27008: FOR_DOWNTO
27009: IFFALSE 27100
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
27011: LD_ADDR_EXP 38
27015: PUSH
27016: LD_EXP 38
27020: PUSH
27021: LD_VAR 0 2
27025: PUSH
27026: LD_VAR 0 1
27030: ARRAY
27031: ADD
27032: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
27033: LD_VAR 0 2
27037: PUSH
27038: LD_VAR 0 1
27042: ARRAY
27043: PPUSH
27044: CALL_OW 310
27048: IFFALSE 27065
// ComExit ( tmp [ i ] ) ;
27050: LD_VAR 0 2
27054: PUSH
27055: LD_VAR 0 1
27059: ARRAY
27060: PPUSH
27061: CALL 105383 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
27065: LD_VAR 0 2
27069: PUSH
27070: LD_VAR 0 1
27074: ARRAY
27075: PPUSH
27076: LD_INT 34
27078: PUSH
27079: LD_INT 0
27081: PPUSH
27082: LD_INT 6
27084: PPUSH
27085: CALL_OW 12
27089: PLUS
27090: PPUSH
27091: LD_INT 1
27093: PPUSH
27094: CALL_OW 171
// end ;
27098: GO 27008
27100: POP
27101: POP
// end else
27102: GO 27114
// x := tmp ;
27104: LD_ADDR_VAR 0 3
27108: PUSH
27109: LD_VAR 0 2
27113: ST_TO_ADDR
// for i := tmp downto tmp - x do
27114: LD_ADDR_VAR 0 1
27118: PUSH
27119: DOUBLE
27120: LD_VAR 0 2
27124: INC
27125: ST_TO_ADDR
27126: LD_VAR 0 2
27130: PUSH
27131: LD_VAR 0 3
27135: MINUS
27136: PUSH
27137: FOR_DOWNTO
27138: IFFALSE 27192
// begin if IsInUnit ( tmp [ i ] ) then
27140: LD_VAR 0 2
27144: PUSH
27145: LD_VAR 0 1
27149: ARRAY
27150: PPUSH
27151: CALL_OW 310
27155: IFFALSE 27172
// ComExit ( tmp [ i ] ) ;
27157: LD_VAR 0 2
27161: PUSH
27162: LD_VAR 0 1
27166: ARRAY
27167: PPUSH
27168: CALL 105383 0 1
// SetSide ( tmp [ i ] , 1 ) ;
27172: LD_VAR 0 2
27176: PUSH
27177: LD_VAR 0 1
27181: ARRAY
27182: PPUSH
27183: LD_INT 1
27185: PPUSH
27186: CALL_OW 235
// end ;
27190: GO 27137
27192: POP
27193: POP
// wait ( 0 0$0.3 ) ;
27194: LD_INT 10
27196: PPUSH
27197: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27201: LD_ADDR_VAR 0 1
27205: PUSH
27206: LD_INT 22
27208: PUSH
27209: LD_INT 8
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: PUSH
27216: LD_INT 21
27218: PUSH
27219: LD_INT 2
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PPUSH
27230: CALL_OW 69
27234: PUSH
27235: FOR_IN
27236: IFFALSE 27249
// KillUnit ( i ) ;
27238: LD_VAR 0 1
27242: PPUSH
27243: CALL_OW 66
27247: GO 27235
27249: POP
27250: POP
// SetSide ( Kurt , 1 ) ;
27251: LD_EXP 62
27255: PPUSH
27256: LD_INT 1
27258: PPUSH
27259: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27263: LD_INT 22
27265: PUSH
27266: LD_INT 8
27268: PUSH
27269: EMPTY
27270: LIST
27271: LIST
27272: PUSH
27273: LD_INT 21
27275: PUSH
27276: LD_INT 3
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PPUSH
27287: CALL_OW 69
27291: PPUSH
27292: LD_INT 1
27294: PPUSH
27295: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27299: LD_INT 8
27301: PPUSH
27302: LD_INT 1
27304: PPUSH
27305: LD_INT 1
27307: PPUSH
27308: LD_INT 1
27310: PPUSH
27311: CALL_OW 80
// wait ( 1 1$20 ) ;
27315: LD_INT 2800
27317: PPUSH
27318: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27322: LD_EXP 64
27326: PPUSH
27327: LD_INT 37
27329: PPUSH
27330: LD_INT 1
27332: PPUSH
27333: LD_INT 0
27335: PPUSH
27336: CALL_OW 48
// wait ( 0 0$1 ) ;
27340: LD_INT 35
27342: PPUSH
27343: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27347: LD_EXP 64
27351: PPUSH
27352: LD_INT 60
27354: PPUSH
27355: LD_INT 95
27357: PPUSH
27358: CALL_OW 111
// end ;
27362: PPOPN 3
27364: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27365: LD_EXP 22
27369: NOT
27370: PUSH
27371: LD_INT 22
27373: PUSH
27374: LD_INT 8
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 21
27383: PUSH
27384: LD_INT 1
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PPUSH
27395: CALL_OW 69
27399: PUSH
27400: LD_INT 0
27402: EQUAL
27403: AND
27404: IFFALSE 27424
27406: GO 27408
27408: DISABLE
// begin legionDestroyed := true ;
27409: LD_ADDR_EXP 22
27413: PUSH
27414: LD_INT 1
27416: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27417: LD_STRING MlegionOut
27419: PPUSH
27420: CALL_OW 337
// end ;
27424: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27425: LD_EXP 38
27429: IFFALSE 27504
27431: GO 27433
27433: DISABLE
27434: LD_INT 0
27436: PPUSH
// begin enable ;
27437: ENABLE
// for i in legionEscapeUnits do
27438: LD_ADDR_VAR 0 1
27442: PUSH
27443: LD_EXP 38
27447: PUSH
27448: FOR_IN
27449: IFFALSE 27502
// begin if IsInArea ( i , legionEscapeArea ) then
27451: LD_VAR 0 1
27455: PPUSH
27456: LD_INT 31
27458: PPUSH
27459: CALL_OW 308
27463: IFFALSE 27476
// RemoveUnit ( i ) else
27465: LD_VAR 0 1
27469: PPUSH
27470: CALL_OW 64
27474: GO 27500
// if not HasTask ( i ) then
27476: LD_VAR 0 1
27480: PPUSH
27481: CALL_OW 314
27485: NOT
27486: IFFALSE 27500
// ComMoveToArea ( i , legionEscapeArea ) ;
27488: LD_VAR 0 1
27492: PPUSH
27493: LD_INT 31
27495: PPUSH
27496: CALL_OW 113
// end ;
27500: GO 27448
27502: POP
27503: POP
// end ;
27504: PPOPN 1
27506: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27507: LD_INT 1
27509: PPUSH
27510: LD_EXP 64
27514: PPUSH
27515: CALL_OW 292
27519: IFFALSE 27817
27521: GO 27523
27523: DISABLE
27524: LD_INT 0
27526: PPUSH
// begin wait ( 0 0$2 ) ;
27527: LD_INT 70
27529: PPUSH
27530: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27534: LD_EXP 64
27538: PPUSH
27539: CALL_OW 87
// DialogueOn ;
27543: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27547: LD_EXP 40
27551: PPUSH
27552: LD_STRING D14-JMM-1
27554: PPUSH
27555: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27559: LD_EXP 64
27563: PPUSH
27564: LD_STRING D14-Friend-1
27566: PPUSH
27567: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27571: LD_EXP 40
27575: PPUSH
27576: LD_STRING D14-JMM-2
27578: PPUSH
27579: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27583: LD_EXP 64
27587: PPUSH
27588: LD_STRING D14-Friend-2
27590: PPUSH
27591: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27595: LD_EXP 40
27599: PPUSH
27600: LD_STRING D14-JMM-3
27602: PPUSH
27603: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27607: LD_EXP 64
27611: PPUSH
27612: LD_STRING D14-Friend-3
27614: PPUSH
27615: CALL_OW 88
// DialogueOff ;
27619: CALL_OW 7
// dec = Query ( Q14 ) ;
27623: LD_ADDR_VAR 0 1
27627: PUSH
27628: LD_STRING Q14
27630: PPUSH
27631: CALL_OW 97
27635: ST_TO_ADDR
// if dec = 1 then
27636: LD_VAR 0 1
27640: PUSH
27641: LD_INT 1
27643: EQUAL
27644: IFFALSE 27678
// begin DialogueOn ;
27646: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27650: LD_EXP 40
27654: PPUSH
27655: LD_STRING D14a-JMM-1
27657: PPUSH
27658: CALL_OW 88
// DialogueOff ;
27662: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27666: LD_EXP 64
27670: PPUSH
27671: LD_INT 1
27673: PPUSH
27674: CALL_OW 235
// end ; if dec = 2 then
27678: LD_VAR 0 1
27682: PUSH
27683: LD_INT 2
27685: EQUAL
27686: IFFALSE 27739
// begin DialogueOn ;
27688: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27692: LD_EXP 40
27696: PPUSH
27697: LD_STRING D14b-JMM-1
27699: PPUSH
27700: CALL_OW 88
// DialogueOff ;
27704: CALL_OW 7
// wait ( 0 0$1 ) ;
27708: LD_INT 35
27710: PPUSH
27711: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27715: LD_EXP 64
27719: PPUSH
27720: LD_INT 9
27722: PPUSH
27723: LD_INT 2
27725: PPUSH
27726: CALL_OW 111
// AddComHold ( Friend ) ;
27730: LD_EXP 64
27734: PPUSH
27735: CALL_OW 200
// end ; if dec = 3 then
27739: LD_VAR 0 1
27743: PUSH
27744: LD_INT 3
27746: EQUAL
27747: IFFALSE 27817
// begin DialogueOn ;
27749: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27753: LD_EXP 40
27757: PPUSH
27758: LD_STRING D14c-JMM-1
27760: PPUSH
27761: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27765: LD_EXP 64
27769: PPUSH
27770: LD_STRING D14c-Friend-1
27772: PPUSH
27773: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27777: LD_EXP 40
27781: PPUSH
27782: LD_STRING D14c-JMM-2
27784: PPUSH
27785: CALL_OW 88
// DialogueOff ;
27789: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27793: LD_EXP 64
27797: PPUSH
27798: LD_INT 9
27800: PPUSH
27801: LD_INT 2
27803: PPUSH
27804: CALL_OW 111
// AddComHold ( Friend ) ;
27808: LD_EXP 64
27812: PPUSH
27813: CALL_OW 200
// end ; end ;
27817: PPOPN 1
27819: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27820: LD_INT 9
27822: PPUSH
27823: LD_INT 2
27825: PPUSH
27826: CALL_OW 428
27830: PUSH
27831: LD_EXP 64
27835: EQUAL
27836: PUSH
27837: LD_EXP 64
27841: PPUSH
27842: CALL_OW 255
27846: PUSH
27847: LD_INT 8
27849: EQUAL
27850: AND
27851: IFFALSE 27865
27853: GO 27855
27855: DISABLE
// RemoveUnit ( Friend ) ;
27856: LD_EXP 64
27860: PPUSH
27861: CALL_OW 64
27865: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27866: LD_EXP 14
27870: PUSH
27871: LD_INT 31500
27873: GREATEREQUAL
27874: PUSH
27875: LD_EXP 7
27879: AND
27880: PUSH
27881: LD_EXP 2
27885: AND
27886: IFFALSE 28316
27888: GO 27890
27890: DISABLE
27891: LD_INT 0
27893: PPUSH
27894: PPUSH
27895: PPUSH
// begin missionStage := 7 ;
27896: LD_ADDR_EXP 15
27900: PUSH
27901: LD_INT 7
27903: ST_TO_ADDR
// uc_side = 1 ;
27904: LD_ADDR_OWVAR 20
27908: PUSH
27909: LD_INT 1
27911: ST_TO_ADDR
// uc_nation = 1 ;
27912: LD_ADDR_OWVAR 21
27916: PUSH
27917: LD_INT 1
27919: ST_TO_ADDR
// for i = 1 to 5 do
27920: LD_ADDR_VAR 0 1
27924: PUSH
27925: DOUBLE
27926: LD_INT 1
27928: DEC
27929: ST_TO_ADDR
27930: LD_INT 5
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28030
// begin vc_engine = 3 ;
27936: LD_ADDR_OWVAR 39
27940: PUSH
27941: LD_INT 3
27943: ST_TO_ADDR
// vc_control = 3 ;
27944: LD_ADDR_OWVAR 38
27948: PUSH
27949: LD_INT 3
27951: ST_TO_ADDR
// vc_chassis = 3 ;
27952: LD_ADDR_OWVAR 37
27956: PUSH
27957: LD_INT 3
27959: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27960: LD_ADDR_OWVAR 40
27964: PUSH
27965: LD_INT 5
27967: PUSH
27968: LD_INT 9
27970: PUSH
27971: LD_INT 7
27973: PUSH
27974: EMPTY
27975: LIST
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 1
27981: PPUSH
27982: LD_INT 3
27984: PPUSH
27985: CALL_OW 12
27989: ARRAY
27990: ST_TO_ADDR
// veh = CreateVehicle ;
27991: LD_ADDR_VAR 0 2
27995: PUSH
27996: CALL_OW 45
28000: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28001: LD_VAR 0 2
28005: PPUSH
28006: LD_INT 1
28008: PPUSH
28009: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28013: LD_VAR 0 2
28017: PPUSH
28018: LD_INT 19
28020: PPUSH
28021: LD_INT 0
28023: PPUSH
28024: CALL_OW 49
// end ;
28028: GO 27933
28030: POP
28031: POP
// vc_engine = 3 ;
28032: LD_ADDR_OWVAR 39
28036: PUSH
28037: LD_INT 3
28039: ST_TO_ADDR
// vc_control = 1 ;
28040: LD_ADDR_OWVAR 38
28044: PUSH
28045: LD_INT 1
28047: ST_TO_ADDR
// vc_chassis = 3 ;
28048: LD_ADDR_OWVAR 37
28052: PUSH
28053: LD_INT 3
28055: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28056: LD_ADDR_OWVAR 40
28060: PUSH
28061: LD_INT 5
28063: PUSH
28064: LD_INT 9
28066: PUSH
28067: LD_INT 7
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: LIST
28074: PUSH
28075: LD_INT 1
28077: PPUSH
28078: LD_INT 3
28080: PPUSH
28081: CALL_OW 12
28085: ARRAY
28086: ST_TO_ADDR
// vehG = CreateVehicle ;
28087: LD_ADDR_VAR 0 3
28091: PUSH
28092: CALL_OW 45
28096: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
28097: LD_VAR 0 3
28101: PPUSH
28102: LD_INT 1
28104: PPUSH
28105: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
28109: LD_VAR 0 3
28113: PPUSH
28114: LD_INT 19
28116: PPUSH
28117: LD_INT 0
28119: PPUSH
28120: CALL_OW 49
// if JMMGirl = 1 then
28124: LD_EXP 7
28128: PUSH
28129: LD_INT 1
28131: EQUAL
28132: IFFALSE 28188
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
28134: LD_ADDR_EXP 41
28138: PUSH
28139: LD_STRING Joan
28141: PPUSH
28142: LD_INT 1
28144: PPUSH
28145: LD_STRING 14_
28147: PPUSH
28148: CALL 67536 0 3
28152: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
28153: LD_EXP 41
28157: PPUSH
28158: LD_VAR 0 3
28162: PPUSH
28163: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28167: LD_VAR 0 3
28171: PPUSH
28172: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28176: LD_EXP 41
28180: PPUSH
28181: LD_STRING D10BW-Joan-1
28183: PPUSH
28184: CALL_OW 94
// end ; if JMMGirl = 2 then
28188: LD_EXP 7
28192: PUSH
28193: LD_INT 2
28195: EQUAL
28196: IFFALSE 28252
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28198: LD_ADDR_EXP 43
28202: PUSH
28203: LD_STRING Lisa
28205: PPUSH
28206: LD_INT 1
28208: PPUSH
28209: LD_STRING 14_
28211: PPUSH
28212: CALL 67536 0 3
28216: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28217: LD_EXP 43
28221: PPUSH
28222: LD_VAR 0 3
28226: PPUSH
28227: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28231: LD_VAR 0 3
28235: PPUSH
28236: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28240: LD_EXP 43
28244: PPUSH
28245: LD_STRING D10BW-Lisa-1
28247: PPUSH
28248: CALL_OW 94
// end ; if JMMGirl = 3 then
28252: LD_EXP 7
28256: PUSH
28257: LD_INT 3
28259: EQUAL
28260: IFFALSE 28316
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28262: LD_ADDR_EXP 55
28266: PUSH
28267: LD_STRING Connie
28269: PPUSH
28270: LD_INT 1
28272: PPUSH
28273: LD_STRING 14_
28275: PPUSH
28276: CALL 67536 0 3
28280: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28281: LD_EXP 55
28285: PPUSH
28286: LD_VAR 0 3
28290: PPUSH
28291: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28295: LD_VAR 0 3
28299: PPUSH
28300: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28304: LD_EXP 55
28308: PPUSH
28309: LD_STRING D10BW-Con-1
28311: PPUSH
28312: CALL_OW 94
// end ; end ;
28316: PPOPN 3
28318: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28319: LD_EXP 14
28323: PUSH
28324: LD_INT 94500
28326: GREATEREQUAL
28327: IFFALSE 28739
28329: GO 28331
28331: DISABLE
28332: LD_INT 0
28334: PPUSH
28335: PPUSH
28336: PPUSH
// begin tmp := PrepareStevensSquad ;
28337: LD_ADDR_VAR 0 3
28341: PUSH
28342: CALL 2323 0 0
28346: ST_TO_ADDR
// if not tmp then
28347: LD_VAR 0 3
28351: NOT
28352: IFFALSE 28356
// exit ;
28354: GO 28739
// uc_side := 1 ;
28356: LD_ADDR_OWVAR 20
28360: PUSH
28361: LD_INT 1
28363: ST_TO_ADDR
// uc_nation := 1 ;
28364: LD_ADDR_OWVAR 21
28368: PUSH
28369: LD_INT 1
28371: ST_TO_ADDR
// for i in tmp do
28372: LD_ADDR_VAR 0 1
28376: PUSH
28377: LD_VAR 0 3
28381: PUSH
28382: FOR_IN
28383: IFFALSE 28480
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28385: LD_INT 3
28387: PPUSH
28388: LD_INT 3
28390: PPUSH
28391: LD_INT 1
28393: PPUSH
28394: LD_INT 5
28396: PUSH
28397: LD_INT 9
28399: PUSH
28400: LD_INT 7
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 1
28410: PPUSH
28411: LD_INT 3
28413: PPUSH
28414: CALL_OW 12
28418: ARRAY
28419: PPUSH
28420: LD_INT 40
28422: PPUSH
28423: CALL 72551 0 5
// veh := CreateVehicle ;
28427: LD_ADDR_VAR 0 2
28431: PUSH
28432: CALL_OW 45
28436: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28437: LD_VAR 0 2
28441: PPUSH
28442: LD_INT 1
28444: PPUSH
28445: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28449: LD_VAR 0 2
28453: PPUSH
28454: LD_INT 19
28456: PPUSH
28457: LD_INT 0
28459: PPUSH
28460: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28464: LD_VAR 0 1
28468: PPUSH
28469: LD_VAR 0 2
28473: PPUSH
28474: CALL_OW 52
// end ;
28478: GO 28382
28480: POP
28481: POP
// missionStage := 8 ;
28482: LD_ADDR_EXP 15
28486: PUSH
28487: LD_INT 8
28489: ST_TO_ADDR
// DialogueOn ;
28490: CALL_OW 6
// if Stevens then
28494: LD_EXP 42
28498: IFFALSE 28612
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28500: LD_EXP 42
28504: PPUSH
28505: CALL_OW 310
28509: PPUSH
28510: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28514: LD_EXP 42
28518: PPUSH
28519: LD_STRING D8-Huck-1
28521: PPUSH
28522: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28526: LD_EXP 40
28530: PPUSH
28531: LD_STRING D8-JMM-1
28533: PPUSH
28534: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28538: LD_EXP 42
28542: PPUSH
28543: LD_STRING D8-Huck-2
28545: PPUSH
28546: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28550: LD_EXP 40
28554: PPUSH
28555: LD_STRING D8-JMM-2
28557: PPUSH
28558: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28562: LD_EXP 42
28566: PPUSH
28567: LD_STRING D8-Huck-3
28569: PPUSH
28570: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28574: LD_EXP 40
28578: PPUSH
28579: LD_STRING D8-JMM-3
28581: PPUSH
28582: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28586: LD_EXP 42
28590: PPUSH
28591: LD_STRING D8-Huck-4
28593: PPUSH
28594: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28598: LD_EXP 40
28602: PPUSH
28603: LD_STRING D8-JMM-4
28605: PPUSH
28606: CALL_OW 88
// end else
28610: GO 28722
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28612: LD_EXP 56
28616: PPUSH
28617: CALL_OW 310
28621: PPUSH
28622: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28626: LD_EXP 56
28630: PPUSH
28631: LD_STRING D8-Huck-1
28633: PPUSH
28634: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28638: LD_EXP 40
28642: PPUSH
28643: LD_STRING D8-JMM-1a
28645: PPUSH
28646: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28650: LD_EXP 56
28654: PPUSH
28655: LD_STRING D8-Huck-2
28657: PPUSH
28658: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28662: LD_EXP 40
28666: PPUSH
28667: LD_STRING D8-JMM-2
28669: PPUSH
28670: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28674: LD_EXP 56
28678: PPUSH
28679: LD_STRING D8-Huck-3
28681: PPUSH
28682: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28686: LD_EXP 40
28690: PPUSH
28691: LD_STRING D8-JMM-3
28693: PPUSH
28694: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28698: LD_EXP 56
28702: PPUSH
28703: LD_STRING D8-Huck-4
28705: PPUSH
28706: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28710: LD_EXP 40
28714: PPUSH
28715: LD_STRING D8-JMM-4
28717: PPUSH
28718: CALL_OW 88
// end ; DialogueOff ;
28722: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28726: LD_INT 25
28728: PPUSH
28729: LD_INT 1
28731: PPUSH
28732: LD_INT 1
28734: PPUSH
28735: CALL_OW 322
// end ;
28739: PPOPN 3
28741: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
28742: LD_EXP 73
28746: PPUSH
28747: CALL_OW 302
28751: PUSH
28752: LD_INT 1
28754: PPUSH
28755: LD_EXP 73
28759: PPUSH
28760: CALL_OW 292
28764: AND
28765: IFFALSE 29016
28767: GO 28769
28769: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28770: LD_EXP 73
28774: PPUSH
28775: CALL_OW 87
// DialogueOn ;
28779: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28783: LD_EXP 40
28787: PPUSH
28788: LD_STRING D10nB-JMM-1
28790: PPUSH
28791: CALL_OW 88
// if BurlakStatus = 1 then
28795: LD_EXP 9
28799: PUSH
28800: LD_INT 1
28802: EQUAL
28803: IFFALSE 28817
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28805: LD_EXP 72
28809: PPUSH
28810: LD_STRING D10nB-Vse-1a
28812: PPUSH
28813: CALL_OW 94
// end ; if BurlakStatus = 0 then
28817: LD_EXP 9
28821: PUSH
28822: LD_INT 0
28824: EQUAL
28825: IFFALSE 28839
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28827: LD_EXP 72
28831: PPUSH
28832: LD_STRING D10nB-Vse-1
28834: PPUSH
28835: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28839: LD_EXP 40
28843: PPUSH
28844: LD_STRING D10nB-JMM-2
28846: PPUSH
28847: CALL_OW 88
// if KappaStatus then
28851: LD_EXP 2
28855: IFFALSE 28869
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28857: LD_EXP 72
28861: PPUSH
28862: LD_STRING D10nB-Vse-5a
28864: PPUSH
28865: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28869: LD_EXP 2
28873: NOT
28874: PUSH
28875: LD_EXP 6
28879: PUSH
28880: LD_INT 0
28882: EQUAL
28883: AND
28884: IFFALSE 29012
// begin if JMMGirl = 1 then
28886: LD_EXP 7
28890: PUSH
28891: LD_INT 1
28893: EQUAL
28894: IFFALSE 28944
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28896: LD_EXP 72
28900: PPUSH
28901: LD_STRING D10nB-Vse-2
28903: PPUSH
28904: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28908: LD_EXP 40
28912: PPUSH
28913: LD_STRING D10nB-JMM-3
28915: PPUSH
28916: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28920: LD_EXP 72
28924: PPUSH
28925: LD_STRING D10nB-Vse-3
28927: PPUSH
28928: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28932: LD_EXP 40
28936: PPUSH
28937: LD_STRING D10nB-JMM-4
28939: PPUSH
28940: CALL_OW 88
// end ; if JMMGirl = 2 then
28944: LD_EXP 7
28948: PUSH
28949: LD_INT 2
28951: EQUAL
28952: IFFALSE 28978
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28954: LD_EXP 72
28958: PPUSH
28959: LD_STRING D10nB-Vse-4
28961: PPUSH
28962: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28966: LD_EXP 40
28970: PPUSH
28971: LD_STRING D10nB-JMM-5
28973: PPUSH
28974: CALL_OW 88
// end ; if JMMGirl = 3 then
28978: LD_EXP 7
28982: PUSH
28983: LD_INT 3
28985: EQUAL
28986: IFFALSE 29012
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28988: LD_EXP 72
28992: PPUSH
28993: LD_STRING D10nB-Vse-5
28995: PPUSH
28996: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
29000: LD_EXP 40
29004: PPUSH
29005: LD_STRING D10nB-JMM-6
29007: PPUSH
29008: CALL_OW 88
// end ; end ; DialogueOff ;
29012: CALL_OW 7
// end ;
29016: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
29017: LD_EXP 14
29021: PUSH
29022: LD_INT 115500
29024: GREATEREQUAL
29025: IFFALSE 29401
29027: GO 29029
29029: DISABLE
29030: LD_INT 0
29032: PPUSH
// begin missionStage := 10 ;
29033: LD_ADDR_EXP 15
29037: PUSH
29038: LD_INT 10
29040: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
29041: LD_ADDR_VAR 0 1
29045: PUSH
29046: LD_INT 22
29048: PUSH
29049: LD_INT 1
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 23
29058: PUSH
29059: LD_INT 1
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 26
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 25
29081: PUSH
29082: LD_INT 12
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 3
29095: PUSH
29096: LD_INT 25
29098: PUSH
29099: LD_INT 16
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: LIST
29115: LIST
29116: PPUSH
29117: CALL_OW 69
29121: PUSH
29122: LD_EXP 40
29126: PUSH
29127: LD_EXP 62
29131: PUSH
29132: LD_EXP 42
29136: PUSH
29137: LD_EXP 56
29141: PUSH
29142: LD_EXP 43
29146: PUSH
29147: LD_EXP 44
29151: PUSH
29152: LD_EXP 45
29156: PUSH
29157: LD_EXP 46
29161: PUSH
29162: LD_EXP 47
29166: PUSH
29167: LD_EXP 48
29171: PUSH
29172: LD_EXP 49
29176: PUSH
29177: LD_EXP 50
29181: PUSH
29182: LD_EXP 51
29186: PUSH
29187: LD_EXP 52
29191: PUSH
29192: LD_EXP 53
29196: PUSH
29197: LD_EXP 54
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: DIFF
29220: ST_TO_ADDR
// if not tmp and Brown then
29221: LD_VAR 0 1
29225: NOT
29226: PUSH
29227: LD_EXP 48
29231: AND
29232: IFFALSE 29247
// tmp := [ Brown ] ;
29234: LD_ADDR_VAR 0 1
29238: PUSH
29239: LD_EXP 48
29243: PUSH
29244: EMPTY
29245: LIST
29246: ST_TO_ADDR
// DialogueOn ;
29247: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29251: LD_VAR 0 1
29255: PUSH
29256: LD_INT 1
29258: ARRAY
29259: PPUSH
29260: LD_STRING D11-Sol1-1
29262: PPUSH
29263: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29267: LD_EXP 66
29271: PPUSH
29272: LD_STRING D11-Pla-1
29274: PPUSH
29275: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29279: LD_EXP 67
29283: PPUSH
29284: LD_STRING D11-Kov-1
29286: PPUSH
29287: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29291: LD_EXP 66
29295: PPUSH
29296: LD_STRING D11-Pla-2
29298: PPUSH
29299: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29303: LD_VAR 0 1
29307: PUSH
29308: LD_INT 1
29310: ARRAY
29311: PPUSH
29312: LD_STRING D11-Sol1-2
29314: PPUSH
29315: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29319: LD_EXP 40
29323: PPUSH
29324: LD_STRING D11-JMM-2
29326: PPUSH
29327: CALL_OW 88
// DialogueOff ;
29331: CALL_OW 7
// allowBehemothConstruct := true ;
29335: LD_ADDR_EXP 25
29339: PUSH
29340: LD_INT 1
29342: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29343: LD_STRING M4
29345: PPUSH
29346: CALL_OW 337
// BuildBehemoths ;
29350: CALL 7903 0 0
// repeat wait ( 15 15$00 ) ;
29354: LD_INT 31500
29356: PPUSH
29357: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29361: LD_EXP 27
29365: IFFALSE 29369
// break ;
29367: GO 29401
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29369: LD_INT 267
29371: PPUSH
29372: CALL_OW 274
29376: PPUSH
29377: LD_INT 1
29379: PPUSH
29380: CALL_OW 275
29384: PUSH
29385: LD_INT 1000
29387: GREATEREQUAL
29388: IFFALSE 29394
// BuildBehemoths ;
29390: CALL 7903 0 0
// until not behemothBuilders ;
29394: LD_EXP 75
29398: NOT
29399: IFFALSE 29354
// end ;
29401: PPOPN 1
29403: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29404: LD_EXP 75
29408: NOT
29409: PUSH
29410: LD_EXP 28
29414: NOT
29415: AND
29416: PUSH
29417: LD_EXP 25
29421: AND
29422: IFFALSE 29442
29424: GO 29426
29426: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29427: LD_STRING M4a
29429: PPUSH
29430: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29434: LD_ADDR_EXP 27
29438: PUSH
29439: LD_INT 1
29441: ST_TO_ADDR
// end ;
29442: END
// every 0 0$1 trigger behemothDone do
29443: LD_EXP 28
29447: IFFALSE 29459
29449: GO 29451
29451: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29452: LD_STRING M4b
29454: PPUSH
29455: CALL_OW 337
29459: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29460: LD_EXP 29
29464: NOT
29465: IFFALSE 29661
29467: GO 29469
29469: DISABLE
29470: LD_INT 0
29472: PPUSH
29473: PPUSH
// begin enable ;
29474: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29475: LD_ADDR_VAR 0 1
29479: PUSH
29480: LD_INT 3
29482: PPUSH
29483: CALL 105046 0 1
29487: ST_TO_ADDR
// if not tmp and not behemothDone then
29488: LD_VAR 0 1
29492: NOT
29493: PUSH
29494: LD_EXP 28
29498: NOT
29499: AND
29500: IFFALSE 29536
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29502: LD_ADDR_VAR 0 1
29506: PUSH
29507: LD_INT 22
29509: PUSH
29510: LD_INT 3
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 30
29519: PUSH
29520: LD_INT 37
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: PPUSH
29531: CALL_OW 69
29535: ST_TO_ADDR
// if not tmp then
29536: LD_VAR 0 1
29540: NOT
29541: IFFALSE 29545
// exit ;
29543: GO 29661
// for i in tmp do
29545: LD_ADDR_VAR 0 2
29549: PUSH
29550: LD_VAR 0 1
29554: PUSH
29555: FOR_IN
29556: IFFALSE 29659
// if See ( 1 , i ) then
29558: LD_INT 1
29560: PPUSH
29561: LD_VAR 0 2
29565: PPUSH
29566: CALL_OW 292
29570: IFFALSE 29657
// begin if GetType ( i ) = unit_building then
29572: LD_VAR 0 2
29576: PPUSH
29577: CALL_OW 247
29581: PUSH
29582: LD_INT 3
29584: EQUAL
29585: IFFALSE 29623
// begin disable ;
29587: DISABLE
// CenterNowOnUnits ( i ) ;
29588: LD_VAR 0 2
29592: PPUSH
29593: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29597: LD_EXP 40
29601: PPUSH
29602: LD_STRING D17a-JMM-1
29604: PPUSH
29605: CALL_OW 88
// seeBehemoth := true ;
29609: LD_ADDR_EXP 29
29613: PUSH
29614: LD_INT 1
29616: ST_TO_ADDR
// exit ;
29617: POP
29618: POP
29619: GO 29661
// end else
29621: GO 29657
// begin disable ;
29623: DISABLE
// CenterNowOnUnits ( i ) ;
29624: LD_VAR 0 2
29628: PPUSH
29629: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29633: LD_EXP 40
29637: PPUSH
29638: LD_STRING D17b-JMM-1
29640: PPUSH
29641: CALL_OW 88
// seeBehemoth := true ;
29645: LD_ADDR_EXP 29
29649: PUSH
29650: LD_INT 1
29652: ST_TO_ADDR
// exit ;
29653: POP
29654: POP
29655: GO 29661
// end ; end ;
29657: GO 29555
29659: POP
29660: POP
// end ;
29661: PPOPN 2
29663: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29664: LD_EXP 14
29668: PUSH
29669: LD_INT 123200
29671: GREATEREQUAL
29672: IFFALSE 30872
29674: GO 29676
29676: DISABLE
29677: LD_INT 0
29679: PPUSH
29680: PPUSH
29681: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29682: LD_INT 2
29684: PPUSH
29685: LD_INT 23
29687: PUSH
29688: LD_INT 3
29690: PUSH
29691: LD_INT 3
29693: PUSH
29694: LD_INT 48
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: PUSH
29703: EMPTY
29704: LIST
29705: PPUSH
29706: CALL 61148 0 2
// repeat wait ( 0 0$1 ) ;
29710: LD_INT 35
29712: PPUSH
29713: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29717: LD_INT 22
29719: PUSH
29720: LD_INT 3
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: LD_INT 34
29729: PUSH
29730: LD_INT 48
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PPUSH
29741: CALL_OW 69
29745: IFFALSE 29710
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29747: LD_ADDR_VAR 0 1
29751: PUSH
29752: LD_INT 22
29754: PUSH
29755: LD_INT 3
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 34
29764: PUSH
29765: LD_INT 48
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PPUSH
29776: CALL_OW 69
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: ST_TO_ADDR
// missionStage := 12 ;
29785: LD_ADDR_EXP 15
29789: PUSH
29790: LD_INT 12
29792: ST_TO_ADDR
// platonovHasBomb := true ;
29793: LD_ADDR_EXP 30
29797: PUSH
29798: LD_INT 1
29800: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29801: LD_VAR 0 1
29805: PPUSH
29806: LD_INT 181
29808: PPUSH
29809: LD_INT 86
29811: PPUSH
29812: CALL_OW 171
// AddComHold ( bomb ) ;
29816: LD_VAR 0 1
29820: PPUSH
29821: CALL_OW 200
// wait ( 0 0$10 ) ;
29825: LD_INT 350
29827: PPUSH
29828: CALL_OW 67
// DialogueOn ;
29832: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29836: LD_EXP 66
29840: PPUSH
29841: LD_STRING D15-Pla-1
29843: PPUSH
29844: CALL_OW 94
// dec = Query ( Q15a ) ;
29848: LD_ADDR_VAR 0 2
29852: PUSH
29853: LD_STRING Q15a
29855: PPUSH
29856: CALL_OW 97
29860: ST_TO_ADDR
// if dec = 1 then
29861: LD_VAR 0 2
29865: PUSH
29866: LD_INT 1
29868: EQUAL
29869: IFFALSE 29892
// begin Say ( JMM , D15a-JMM-1 ) ;
29871: LD_EXP 40
29875: PPUSH
29876: LD_STRING D15a-JMM-1
29878: PPUSH
29879: CALL_OW 88
// YouLost ( Surrender ) ;
29883: LD_STRING Surrender
29885: PPUSH
29886: CALL_OW 104
// exit ;
29890: GO 30872
// end ; if dec = 2 then
29892: LD_VAR 0 2
29896: PUSH
29897: LD_INT 2
29899: EQUAL
29900: IFFALSE 29969
// begin Say ( JMM , D15b-JMM-1 ) ;
29902: LD_EXP 40
29906: PPUSH
29907: LD_STRING D15b-JMM-1
29909: PPUSH
29910: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29914: LD_EXP 66
29918: PPUSH
29919: LD_STRING D15b-Pla-1
29921: PPUSH
29922: CALL_OW 94
// DialogueOff ;
29926: CALL_OW 7
// wait ( 3 3$00 ) ;
29930: LD_INT 6300
29932: PPUSH
29933: CALL_OW 67
// DialogueOn ;
29937: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29941: LD_EXP 40
29945: PPUSH
29946: LD_STRING D15d-JMM-1a
29948: PPUSH
29949: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29953: LD_EXP 66
29957: PPUSH
29958: LD_STRING D15d-Pla-1
29960: PPUSH
29961: CALL_OW 94
// DialogueOff ;
29965: CALL_OW 7
// end ; if dec = 3 then
29969: LD_VAR 0 2
29973: PUSH
29974: LD_INT 3
29976: EQUAL
29977: IFFALSE 30031
// begin Say ( JMM , D15c-JMM-1 ) ;
29979: LD_EXP 40
29983: PPUSH
29984: LD_STRING D15c-JMM-1
29986: PPUSH
29987: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29991: LD_EXP 66
29995: PPUSH
29996: LD_STRING D15c-Pla-1
29998: PPUSH
29999: CALL_OW 94
// DialogueOff ;
30003: CALL_OW 7
// wait ( 0 0$15 ) ;
30007: LD_INT 525
30009: PPUSH
30010: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
30014: LD_VAR 0 1
30018: PPUSH
30019: LD_INT 60
30021: PPUSH
30022: LD_INT 95
30024: PPUSH
30025: CALL_OW 116
// exit ;
30029: GO 30872
// end ; if dec = 4 then
30031: LD_VAR 0 2
30035: PUSH
30036: LD_INT 4
30038: EQUAL
30039: IFFALSE 30069
// begin Say ( JMM , D15d-JMM-1 ) ;
30041: LD_EXP 40
30045: PPUSH
30046: LD_STRING D15d-JMM-1
30048: PPUSH
30049: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30053: LD_EXP 66
30057: PPUSH
30058: LD_STRING D15d-Pla-1
30060: PPUSH
30061: CALL_OW 94
// DialogueOff ;
30065: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30069: LD_EXP 64
30073: PPUSH
30074: CALL_OW 302
30078: PUSH
30079: LD_EXP 64
30083: PPUSH
30084: CALL_OW 255
30088: PUSH
30089: LD_INT 1
30091: EQUAL
30092: AND
30093: PUSH
30094: LD_INT 22
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 34
30106: PUSH
30107: LD_INT 8
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PPUSH
30118: CALL_OW 69
30122: NOT
30123: AND
30124: IFFALSE 30773
// begin SetSide ( Friend , 8 ) ;
30126: LD_EXP 64
30130: PPUSH
30131: LD_INT 8
30133: PPUSH
30134: CALL_OW 235
// if IsInUnit ( Friend ) then
30138: LD_EXP 64
30142: PPUSH
30143: CALL_OW 310
30147: IFFALSE 30158
// ComExitBuilding ( Friend ) ;
30149: LD_EXP 64
30153: PPUSH
30154: CALL_OW 122
// if IsDriver ( Friend ) then
30158: LD_EXP 64
30162: PPUSH
30163: CALL 102594 0 1
30167: IFFALSE 30178
// ComExitVehicle ( Friend ) ;
30169: LD_EXP 64
30173: PPUSH
30174: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30178: LD_EXP 64
30182: PPUSH
30183: LD_INT 9
30185: PPUSH
30186: LD_INT 2
30188: PPUSH
30189: CALL_OW 171
// wait ( 0 0$05 ) ;
30193: LD_INT 175
30195: PPUSH
30196: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30200: LD_EXP 64
30204: PPUSH
30205: CALL_OW 87
// DialogueOn ;
30209: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30213: LD_EXP 40
30217: PPUSH
30218: LD_STRING D16-JMM-1
30220: PPUSH
30221: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30225: LD_EXP 64
30229: PPUSH
30230: LD_STRING D16-Friend-1
30232: PPUSH
30233: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30237: LD_EXP 40
30241: PPUSH
30242: LD_STRING D16-JMM-2
30244: PPUSH
30245: CALL_OW 88
// DialogueOff ;
30249: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30253: LD_EXP 64
30257: PPUSH
30258: LD_INT 1
30260: PPUSH
30261: CALL_OW 235
// ComHold ( Friend ) ;
30265: LD_EXP 64
30269: PPUSH
30270: CALL_OW 140
// wait ( 0 0$20 ) ;
30274: LD_INT 700
30276: PPUSH
30277: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30281: LD_EXP 64
30285: PPUSH
30286: LD_INT 9
30288: PPUSH
30289: LD_INT 2
30291: PPUSH
30292: CALL_OW 297
30296: PUSH
30297: LD_INT 30
30299: LESS
30300: IFFALSE 30369
// begin SetSide ( Friend , 8 ) ;
30302: LD_EXP 64
30306: PPUSH
30307: LD_INT 8
30309: PPUSH
30310: CALL_OW 235
// if IsInUnit ( Friend ) then
30314: LD_EXP 64
30318: PPUSH
30319: CALL_OW 310
30323: IFFALSE 30334
// ComExitBuilding ( Friend ) ;
30325: LD_EXP 64
30329: PPUSH
30330: CALL_OW 122
// if IsDriver ( Friend ) then
30334: LD_EXP 64
30338: PPUSH
30339: CALL 102594 0 1
30343: IFFALSE 30354
// ComExitVehicle ( Friend ) ;
30345: LD_EXP 64
30349: PPUSH
30350: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30354: LD_EXP 64
30358: PPUSH
30359: LD_INT 9
30361: PPUSH
30362: LD_INT 2
30364: PPUSH
30365: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30369: LD_INT 1050
30371: PPUSH
30372: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30376: LD_INT 22
30378: PUSH
30379: LD_INT 1
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 34
30388: PUSH
30389: LD_INT 8
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PPUSH
30400: CALL_OW 69
30404: NOT
30405: IFFALSE 30751
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30407: LD_ADDR_VAR 0 3
30411: PUSH
30412: LD_INT 22
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 26
30424: PUSH
30425: LD_INT 1
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 3
30434: PUSH
30435: LD_INT 25
30437: PUSH
30438: LD_INT 12
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 25
30447: PUSH
30448: LD_INT 16
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: LIST
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: LIST
30464: PPUSH
30465: CALL_OW 69
30469: PUSH
30470: LD_EXP 40
30474: PUSH
30475: LD_EXP 42
30479: PUSH
30480: LD_EXP 56
30484: PUSH
30485: LD_EXP 43
30489: PUSH
30490: LD_EXP 44
30494: PUSH
30495: LD_EXP 45
30499: PUSH
30500: LD_EXP 46
30504: PUSH
30505: LD_EXP 47
30509: PUSH
30510: LD_EXP 48
30514: PUSH
30515: LD_EXP 49
30519: PUSH
30520: LD_EXP 50
30524: PUSH
30525: LD_EXP 51
30529: PUSH
30530: LD_EXP 52
30534: PUSH
30535: LD_EXP 53
30539: PUSH
30540: LD_EXP 54
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: DIFF
30562: ST_TO_ADDR
// DialogueOn ;
30563: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30567: LD_EXP 66
30571: PPUSH
30572: LD_STRING D16a-Pla-1
30574: PPUSH
30575: CALL_OW 94
// if Stevens then
30579: LD_EXP 42
30583: IFFALSE 30599
// Say ( Stevens , D16a-Huck-1 ) else
30585: LD_EXP 42
30589: PPUSH
30590: LD_STRING D16a-Huck-1
30592: PPUSH
30593: CALL_OW 88
30597: GO 30641
// if Baker then
30599: LD_EXP 56
30603: IFFALSE 30619
// Say ( Baker , D16a-Huck-1 ) else
30605: LD_EXP 56
30609: PPUSH
30610: LD_STRING D16a-Huck-1
30612: PPUSH
30613: CALL_OW 88
30617: GO 30641
// if tmp then
30619: LD_VAR 0 3
30623: IFFALSE 30641
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30625: LD_VAR 0 3
30629: PUSH
30630: LD_INT 1
30632: ARRAY
30633: PPUSH
30634: LD_STRING D16a-Sol1-1
30636: PPUSH
30637: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30641: LD_EXP 64
30645: PPUSH
30646: CALL_OW 255
30650: PUSH
30651: LD_INT 8
30653: EQUAL
30654: IFFALSE 30670
// Say ( JMM , D16a-JMM-1 ) else
30656: LD_EXP 40
30660: PPUSH
30661: LD_STRING D16a-JMM-1
30663: PPUSH
30664: CALL_OW 88
30668: GO 30730
// begin Say ( JMM , D16a-JMM-1a ) ;
30670: LD_EXP 40
30674: PPUSH
30675: LD_STRING D16a-JMM-1a
30677: PPUSH
30678: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30682: LD_EXP 64
30686: PPUSH
30687: LD_STRING D16a-Friend-1
30689: PPUSH
30690: CALL_OW 88
// ComExitBuilding ( Friend ) ;
30694: LD_EXP 64
30698: PPUSH
30699: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
30703: LD_EXP 64
30707: PPUSH
30708: LD_INT 191
30710: PPUSH
30711: LD_INT 103
30713: PPUSH
30714: CALL_OW 171
// SetSide ( Friend , 3 ) ;
30718: LD_EXP 64
30722: PPUSH
30723: LD_INT 3
30725: PPUSH
30726: CALL_OW 235
// end ; DialogueOff ;
30730: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30734: LD_VAR 0 1
30738: PPUSH
30739: LD_INT 60
30741: PPUSH
30742: LD_INT 95
30744: PPUSH
30745: CALL_OW 116
// end else
30749: GO 30771
// begin DialogueOn ;
30751: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30755: LD_EXP 66
30759: PPUSH
30760: LD_STRING D16c-Pla-1
30762: PPUSH
30763: CALL_OW 94
// DialogueOff ;
30767: CALL_OW 7
// end ; end else
30771: GO 30872
// begin wait ( 3 3$00 ) ;
30773: LD_INT 6300
30775: PPUSH
30776: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30780: LD_INT 22
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 34
30792: PUSH
30793: LD_INT 8
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PPUSH
30804: CALL_OW 69
30808: NOT
30809: IFFALSE 30852
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30811: LD_EXP 66
30815: PPUSH
30816: LD_STRING D16b-Pla-1
30818: PPUSH
30819: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
30823: LD_EXP 40
30827: PPUSH
30828: LD_STRING D16b-JMM-1
30830: PPUSH
30831: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30835: LD_VAR 0 1
30839: PPUSH
30840: LD_INT 60
30842: PPUSH
30843: LD_INT 95
30845: PPUSH
30846: CALL_OW 116
// end else
30850: GO 30872
// begin DialogueOn ;
30852: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30856: LD_EXP 66
30860: PPUSH
30861: LD_STRING D16c-Pla-1
30863: PPUSH
30864: CALL_OW 94
// DialogueOff ;
30868: CALL_OW 7
// end ; end ; end ;
30872: PPOPN 3
30874: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30875: LD_EXP 14
30879: PUSH
30880: LD_INT 126000
30882: GREATEREQUAL
30883: PUSH
30884: LD_EXP 23
30888: NOT
30889: AND
30890: PUSH
30891: LD_EXP 77
30895: PPUSH
30896: CALL_OW 302
30900: AND
30901: IFFALSE 31259
30903: GO 30905
30905: DISABLE
30906: LD_INT 0
30908: PPUSH
// begin missionStage = 11 ;
30909: LD_ADDR_EXP 15
30913: PUSH
30914: LD_INT 11
30916: ST_TO_ADDR
// DialogueOn ;
30917: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30921: LD_EXP 77
30925: PPUSH
30926: LD_STRING D9-Roth-1
30928: PPUSH
30929: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30933: LD_EXP 40
30937: PPUSH
30938: LD_STRING D9-JMM-1
30940: PPUSH
30941: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30945: LD_EXP 77
30949: PPUSH
30950: LD_STRING D9-Roth-2
30952: PPUSH
30953: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30957: LD_EXP 77
30961: PPUSH
30962: LD_STRING D9-Roth-2a
30964: PPUSH
30965: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30969: LD_EXP 66
30973: PPUSH
30974: LD_STRING D9-Pla-2
30976: PPUSH
30977: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30981: LD_EXP 77
30985: PPUSH
30986: LD_STRING D9-Roth-3
30988: PPUSH
30989: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30993: LD_EXP 66
30997: PPUSH
30998: LD_STRING D9-Pla-3
31000: PPUSH
31001: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
31005: LD_EXP 77
31009: PPUSH
31010: LD_STRING D9-Roth-4
31012: PPUSH
31013: CALL_OW 94
// dec = Query ( Q9 ) ;
31017: LD_ADDR_VAR 0 1
31021: PUSH
31022: LD_STRING Q9
31024: PPUSH
31025: CALL_OW 97
31029: ST_TO_ADDR
// if dec = 1 then
31030: LD_VAR 0 1
31034: PUSH
31035: LD_INT 1
31037: EQUAL
31038: IFFALSE 31052
// SayRadio ( Roth , D9a-Roth-1 ) ;
31040: LD_EXP 77
31044: PPUSH
31045: LD_STRING D9a-Roth-1
31047: PPUSH
31048: CALL_OW 94
// if dec = 2 then
31052: LD_VAR 0 1
31056: PUSH
31057: LD_INT 2
31059: EQUAL
31060: IFFALSE 31086
// begin Say ( JMM , D9b-JMM-1 ) ;
31062: LD_EXP 40
31066: PPUSH
31067: LD_STRING D9b-JMM-1
31069: PPUSH
31070: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
31074: LD_EXP 77
31078: PPUSH
31079: LD_STRING D9b-Roth-1
31081: PPUSH
31082: CALL_OW 94
// end ; if dec = 3 then
31086: LD_VAR 0 1
31090: PUSH
31091: LD_INT 3
31093: EQUAL
31094: IFFALSE 31156
// begin Say ( JMM , D9c-JMM-1 ) ;
31096: LD_EXP 40
31100: PPUSH
31101: LD_STRING D9c-JMM-1
31103: PPUSH
31104: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
31108: LD_EXP 77
31112: PPUSH
31113: LD_STRING D9c-Roth-1
31115: PPUSH
31116: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
31120: LD_EXP 40
31124: PPUSH
31125: LD_STRING D9c-JMM-2
31127: PPUSH
31128: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
31132: LD_EXP 77
31136: PPUSH
31137: LD_STRING D9c-Roth-2
31139: PPUSH
31140: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
31144: LD_EXP 40
31148: PPUSH
31149: LD_STRING D9c-JMM-3
31151: PPUSH
31152: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
31156: LD_EXP 77
31160: PPUSH
31161: LD_STRING D9c-Roth-3
31163: PPUSH
31164: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
31168: LD_EXP 77
31172: PPUSH
31173: LD_STRING D9cont-Roth-1
31175: PPUSH
31176: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
31180: LD_EXP 40
31184: PPUSH
31185: LD_STRING D9cont-JMM-1
31187: PPUSH
31188: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
31192: LD_EXP 77
31196: PPUSH
31197: LD_STRING D9cont-Roth-2
31199: PPUSH
31200: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
31204: LD_EXP 40
31208: PPUSH
31209: LD_STRING D9cont-JMM-2
31211: PPUSH
31212: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31216: LD_EXP 77
31220: PPUSH
31221: LD_STRING D9cont-Roth-3
31223: PPUSH
31224: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31228: LD_EXP 40
31232: PPUSH
31233: LD_STRING D9cont-JMM-3
31235: PPUSH
31236: CALL_OW 88
// DialogueOff ;
31240: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31244: LD_STRING M3
31246: PPUSH
31247: CALL_OW 337
// allianceActive := true ;
31251: LD_ADDR_EXP 31
31255: PUSH
31256: LD_INT 1
31258: ST_TO_ADDR
// end ;
31259: PPOPN 1
31261: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31262: LD_INT 1
31264: PPUSH
31265: LD_INT 126
31267: PPUSH
31268: CALL_OW 292
31272: PUSH
31273: LD_EXP 66
31277: PPUSH
31278: CALL_OW 310
31282: AND
31283: IFFALSE 31363
31285: GO 31287
31287: DISABLE
31288: LD_INT 0
31290: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31291: LD_EXP 66
31295: PPUSH
31296: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31300: LD_ADDR_VAR 0 1
31304: PUSH
31305: LD_INT 4
31307: PPUSH
31308: LD_INT 22
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PPUSH
31318: CALL_OW 70
31322: PPUSH
31323: LD_EXP 66
31327: PPUSH
31328: CALL_OW 74
31332: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31333: LD_EXP 66
31337: PPUSH
31338: LD_VAR 0 1
31342: PUSH
31343: LD_INT 1
31345: ARRAY
31346: PPUSH
31347: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31351: LD_EXP 66
31355: PPUSH
31356: LD_STRING D18-Pla-1
31358: PPUSH
31359: CALL_OW 88
// end ;
31363: PPOPN 1
31365: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31366: LD_EXP 66
31370: PPUSH
31371: CALL_OW 301
31375: PUSH
31376: LD_EXP 69
31380: PPUSH
31381: CALL_OW 301
31385: AND
31386: PUSH
31387: LD_INT 22
31389: PUSH
31390: LD_INT 3
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 21
31399: PUSH
31400: LD_INT 1
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 50
31409: PUSH
31410: EMPTY
31411: LIST
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: LIST
31417: PPUSH
31418: CALL_OW 69
31422: PUSH
31423: LD_INT 7
31425: PUSH
31426: LD_INT 8
31428: PUSH
31429: LD_INT 9
31431: PUSH
31432: LD_INT 10
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: PUSH
31441: LD_OWVAR 67
31445: ARRAY
31446: LESS
31447: AND
31448: IFFALSE 32247
31450: GO 31452
31452: DISABLE
31453: LD_INT 0
31455: PPUSH
31456: PPUSH
31457: PPUSH
31458: PPUSH
// begin MC_Kill ( 2 ) ;
31459: LD_INT 2
31461: PPUSH
31462: CALL 37121 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31466: LD_INT 1
31468: PPUSH
31469: LD_INT 3
31471: PPUSH
31472: LD_INT 1
31474: PPUSH
31475: LD_INT 1
31477: PPUSH
31478: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31482: LD_ADDR_VAR 0 2
31486: PUSH
31487: LD_INT 22
31489: PUSH
31490: LD_INT 3
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 21
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 50
31509: PUSH
31510: EMPTY
31511: LIST
31512: PUSH
31513: LD_INT 26
31515: PUSH
31516: LD_INT 1
31518: PUSH
31519: EMPTY
31520: LIST
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: PPUSH
31529: CALL_OW 69
31533: ST_TO_ADDR
// if not tmp then
31534: LD_VAR 0 2
31538: NOT
31539: IFFALSE 31595
// begin uc_side = 3 ;
31541: LD_ADDR_OWVAR 20
31545: PUSH
31546: LD_INT 3
31548: ST_TO_ADDR
// uc_nation = 3 ;
31549: LD_ADDR_OWVAR 21
31553: PUSH
31554: LD_INT 3
31556: ST_TO_ADDR
// hc_name =  ;
31557: LD_ADDR_OWVAR 26
31561: PUSH
31562: LD_STRING 
31564: ST_TO_ADDR
// hc_gallery =  ;
31565: LD_ADDR_OWVAR 33
31569: PUSH
31570: LD_STRING 
31572: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31573: LD_INT 1
31575: PPUSH
31576: LD_INT 10
31578: PPUSH
31579: CALL_OW 381
// tmp = CreateHuman ;
31583: LD_ADDR_VAR 0 2
31587: PUSH
31588: CALL_OW 44
31592: ST_TO_ADDR
// end else
31593: GO 31609
// tmp := tmp [ 1 ] ;
31595: LD_ADDR_VAR 0 2
31599: PUSH
31600: LD_VAR 0 2
31604: PUSH
31605: LD_INT 1
31607: ARRAY
31608: ST_TO_ADDR
// DialogueOn ;
31609: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31613: LD_VAR 0 2
31617: PPUSH
31618: LD_STRING DSurrenderRussians-RSol1-1a
31620: PPUSH
31621: CALL_OW 94
// DialogueOff ;
31625: CALL_OW 7
// russianDestroyed := true ;
31629: LD_ADDR_EXP 21
31633: PUSH
31634: LD_INT 1
31636: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
31637: LD_ADDR_VAR 0 1
31641: PUSH
31642: LD_INT 22
31644: PUSH
31645: LD_INT 6
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PPUSH
31652: CALL_OW 69
31656: PUSH
31657: FOR_IN
31658: IFFALSE 31671
// KillUnit ( i ) ;
31660: LD_VAR 0 1
31664: PPUSH
31665: CALL_OW 66
31669: GO 31657
31671: POP
31672: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31673: LD_INT 22
31675: PUSH
31676: LD_INT 3
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 21
31685: PUSH
31686: LD_INT 1
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PPUSH
31697: CALL_OW 69
31701: PPUSH
31702: CALL_OW 122
// wait ( 0 0$1 ) ;
31706: LD_INT 35
31708: PPUSH
31709: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31713: LD_INT 22
31715: PUSH
31716: LD_INT 3
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 21
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: PPUSH
31742: LD_INT 25
31744: PPUSH
31745: CALL_OW 173
// wait ( 0 0$35 ) ;
31749: LD_INT 1225
31751: PPUSH
31752: CALL_OW 67
// PrepareOmarInvasion ;
31756: CALL 14772 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31760: LD_ADDR_VAR 0 2
31764: PUSH
31765: LD_EXP 95
31769: PPUSH
31770: CALL_OW 250
31774: PUSH
31775: LD_EXP 95
31779: PPUSH
31780: CALL_OW 251
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31789: LD_VAR 0 2
31793: PUSH
31794: LD_INT 1
31796: ARRAY
31797: PPUSH
31798: LD_VAR 0 2
31802: PUSH
31803: LD_INT 2
31805: ARRAY
31806: PPUSH
31807: LD_INT 1
31809: PPUSH
31810: LD_INT 8
31812: NEG
31813: PPUSH
31814: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31818: LD_EXP 95
31822: PPUSH
31823: CALL_OW 87
// DialogueOn ;
31827: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31831: LD_EXP 40
31835: PPUSH
31836: LD_STRING D19-JMM-1
31838: PPUSH
31839: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31843: LD_ADDR_VAR 0 3
31847: PUSH
31848: LD_INT 22
31850: PUSH
31851: LD_INT 1
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: LD_INT 26
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 2
31870: PUSH
31871: LD_INT 25
31873: PUSH
31874: LD_INT 1
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 25
31883: PUSH
31884: LD_INT 2
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 25
31893: PUSH
31894: LD_INT 3
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 25
31903: PUSH
31904: LD_INT 4
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 25
31913: PUSH
31914: LD_INT 5
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 25
31923: PUSH
31924: LD_INT 8
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: LIST
31944: PPUSH
31945: CALL_OW 69
31949: PUSH
31950: LD_EXP 40
31954: PUSH
31955: LD_EXP 41
31959: PUSH
31960: LD_EXP 62
31964: PUSH
31965: LD_EXP 42
31969: PUSH
31970: LD_EXP 43
31974: PUSH
31975: LD_EXP 44
31979: PUSH
31980: LD_EXP 45
31984: PUSH
31985: LD_EXP 46
31989: PUSH
31990: LD_EXP 47
31994: PUSH
31995: LD_EXP 48
31999: PUSH
32000: LD_EXP 49
32004: PUSH
32005: LD_EXP 50
32009: PUSH
32010: LD_EXP 51
32014: PUSH
32015: LD_EXP 52
32019: PUSH
32020: LD_EXP 53
32024: PUSH
32025: LD_EXP 54
32029: PUSH
32030: LD_EXP 55
32034: PUSH
32035: LD_EXP 56
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: DIFF
32060: ST_TO_ADDR
// if tmp2 then
32061: LD_VAR 0 3
32065: IFFALSE 32083
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
32067: LD_VAR 0 3
32071: PUSH
32072: LD_INT 1
32074: ARRAY
32075: PPUSH
32076: LD_STRING D19-Sol1-1
32078: PPUSH
32079: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
32083: LD_EXP 40
32087: PPUSH
32088: LD_STRING D19-JMM-2
32090: PPUSH
32091: CALL_OW 88
// DialogueOff ;
32095: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
32099: LD_VAR 0 2
32103: PUSH
32104: LD_INT 1
32106: ARRAY
32107: PPUSH
32108: LD_VAR 0 2
32112: PUSH
32113: LD_INT 2
32115: ARRAY
32116: PPUSH
32117: LD_INT 1
32119: PPUSH
32120: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
32124: LD_STRING M5
32126: PPUSH
32127: CALL_OW 337
// omarOnMotherLode := false ;
32131: LD_ADDR_VAR 0 4
32135: PUSH
32136: LD_INT 0
32138: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32139: LD_INT 35
32141: PPUSH
32142: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
32146: LD_EXP 95
32150: PPUSH
32151: LD_INT 215
32153: PPUSH
32154: LD_INT 100
32156: PPUSH
32157: CALL_OW 297
32161: PUSH
32162: LD_INT 10
32164: LESS
32165: PUSH
32166: LD_VAR 0 4
32170: NOT
32171: AND
32172: IFFALSE 32206
// begin omarOnMotherLode := true ;
32174: LD_ADDR_VAR 0 4
32178: PUSH
32179: LD_INT 1
32181: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
32182: LD_EXP 40
32186: PPUSH
32187: LD_STRING D19b-JMM-1
32189: PPUSH
32190: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
32194: LD_EXP 95
32198: PPUSH
32199: LD_STRING DOmarContam-Omar-1
32201: PPUSH
32202: CALL_OW 88
// end ; until IsDead ( Omar ) ;
32206: LD_EXP 95
32210: PPUSH
32211: CALL_OW 301
32215: IFFALSE 32139
// Say ( JMM , D19a-JMM-1 ) ;
32217: LD_EXP 40
32221: PPUSH
32222: LD_STRING D19a-JMM-1
32224: PPUSH
32225: CALL_OW 88
// if Heike then
32229: LD_EXP 96
32233: IFFALSE 32247
// Say ( Heike , D19a-Hke-1 ) ;
32235: LD_EXP 96
32239: PPUSH
32240: LD_STRING D19a-Hke-1
32242: PPUSH
32243: CALL_OW 88
// end ;
32247: PPOPN 4
32249: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32250: LD_INT 22
32252: PUSH
32253: LD_INT 3
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 21
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PPUSH
32274: CALL_OW 69
32278: PUSH
32279: LD_EXP 21
32283: AND
32284: IFFALSE 32352
32286: GO 32288
32288: DISABLE
32289: LD_INT 0
32291: PPUSH
32292: PPUSH
// begin enable ;
32293: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32294: LD_ADDR_VAR 0 2
32298: PUSH
32299: LD_INT 25
32301: PPUSH
32302: LD_INT 22
32304: PUSH
32305: LD_INT 3
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PPUSH
32312: CALL_OW 70
32316: ST_TO_ADDR
// if not tmp then
32317: LD_VAR 0 2
32321: NOT
32322: IFFALSE 32326
// exit ;
32324: GO 32352
// for i in tmp do
32326: LD_ADDR_VAR 0 1
32330: PUSH
32331: LD_VAR 0 2
32335: PUSH
32336: FOR_IN
32337: IFFALSE 32350
// RemoveUnit ( i ) ;
32339: LD_VAR 0 1
32343: PPUSH
32344: CALL_OW 64
32348: GO 32336
32350: POP
32351: POP
// end ;
32352: PPOPN 2
32354: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32355: LD_INT 22
32357: PUSH
32358: LD_INT 7
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 21
32367: PUSH
32368: LD_INT 1
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PPUSH
32379: CALL_OW 69
32383: PUSH
32384: LD_INT 6
32386: LESS
32387: IFFALSE 32855
32389: GO 32391
32391: DISABLE
32392: LD_INT 0
32394: PPUSH
32395: PPUSH
// begin MC_Kill ( 1 ) ;
32396: LD_INT 1
32398: PPUSH
32399: CALL 37121 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32403: LD_INT 7
32405: PPUSH
32406: LD_INT 1
32408: PPUSH
32409: LD_INT 1
32411: PPUSH
32412: LD_INT 1
32414: PPUSH
32415: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32419: LD_ADDR_VAR 0 1
32423: PUSH
32424: LD_INT 22
32426: PUSH
32427: LD_INT 7
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 26
32436: PUSH
32437: LD_INT 1
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PPUSH
32448: CALL_OW 69
32452: PUSH
32453: LD_EXP 77
32457: DIFF
32458: ST_TO_ADDR
// if tmp then
32459: LD_VAR 0 1
32463: IFFALSE 32481
// tmp := tmp [ 1 ] else
32465: LD_ADDR_VAR 0 1
32469: PUSH
32470: LD_VAR 0 1
32474: PUSH
32475: LD_INT 1
32477: ARRAY
32478: ST_TO_ADDR
32479: GO 32517
// begin uc_side := 7 ;
32481: LD_ADDR_OWVAR 20
32485: PUSH
32486: LD_INT 7
32488: ST_TO_ADDR
// uc_nation := 1 ;
32489: LD_ADDR_OWVAR 21
32493: PUSH
32494: LD_INT 1
32496: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32497: LD_INT 1
32499: PPUSH
32500: LD_INT 8
32502: PPUSH
32503: CALL_OW 384
// tmp := CreateHuman ;
32507: LD_ADDR_VAR 0 1
32511: PUSH
32512: CALL_OW 44
32516: ST_TO_ADDR
// end ; DialogueOn ;
32517: CALL_OW 6
// if IsOK ( Roth ) then
32521: LD_EXP 77
32525: PPUSH
32526: CALL_OW 302
32530: IFFALSE 32544
// Say ( JMM , DAb-JMM-1 ) ;
32532: LD_EXP 40
32536: PPUSH
32537: LD_STRING DAb-JMM-1
32539: PPUSH
32540: CALL_OW 88
// if IsOK ( Roth ) then
32544: LD_EXP 77
32548: PPUSH
32549: CALL_OW 302
32553: IFFALSE 32577
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32555: LD_EXP 77
32559: PPUSH
32560: LD_STRING DSurrenderAlliance-Roth-1
32562: PPUSH
32563: CALL_OW 88
// RothCaptured := true ;
32567: LD_ADDR_EXP 33
32571: PUSH
32572: LD_INT 1
32574: ST_TO_ADDR
// end else
32575: GO 32589
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32577: LD_VAR 0 1
32581: PPUSH
32582: LD_STRING DSurrenderAlliance-Sci1-1
32584: PPUSH
32585: CALL_OW 88
// DialogueOff ;
32589: CALL_OW 7
// allianceDestroyed := true ;
32593: LD_ADDR_EXP 23
32597: PUSH
32598: LD_INT 1
32600: ST_TO_ADDR
// if capturedUnit = 0 then
32601: LD_EXP 34
32605: PUSH
32606: LD_INT 0
32608: EQUAL
32609: IFFALSE 32618
// SetAchievement ( ACH_ALLIANCE ) ;
32611: LD_STRING ACH_ALLIANCE
32613: PPUSH
32614: CALL_OW 543
// if trueAmericans then
32618: LD_EXP 35
32622: IFFALSE 32698
// begin if trueAmericans = 1 then
32624: LD_EXP 35
32628: PUSH
32629: LD_INT 1
32631: EQUAL
32632: IFFALSE 32648
// Say ( JMM , DAb-JMM-1a ) else
32634: LD_EXP 40
32638: PPUSH
32639: LD_STRING DAb-JMM-1a
32641: PPUSH
32642: CALL_OW 88
32646: GO 32660
// Say ( JMM , DAb-JMM-1b ) ;
32648: LD_EXP 40
32652: PPUSH
32653: LD_STRING DAb-JMM-1b
32655: PPUSH
32656: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32660: LD_EXP 35
32664: PPUSH
32665: CALL_OW 87
// for i in trueAmericans do
32669: LD_ADDR_VAR 0 2
32673: PUSH
32674: LD_EXP 35
32678: PUSH
32679: FOR_IN
32680: IFFALSE 32696
// SetSide ( i , 1 ) ;
32682: LD_VAR 0 2
32686: PPUSH
32687: LD_INT 1
32689: PPUSH
32690: CALL_OW 235
32694: GO 32679
32696: POP
32697: POP
// end ; repeat wait ( 0 0$1 ) ;
32698: LD_INT 35
32700: PPUSH
32701: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32705: LD_ADDR_VAR 0 2
32709: PUSH
32710: LD_INT 22
32712: PUSH
32713: LD_INT 7
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 21
32722: PUSH
32723: LD_INT 1
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PPUSH
32734: CALL_OW 69
32738: PUSH
32739: FOR_IN
32740: IFFALSE 32822
// begin if IsInUnit ( i ) then
32742: LD_VAR 0 2
32746: PPUSH
32747: CALL_OW 310
32751: IFFALSE 32762
// ComExitBuilding ( i ) ;
32753: LD_VAR 0 2
32757: PPUSH
32758: CALL_OW 122
// if IsDriver ( i ) then
32762: LD_VAR 0 2
32766: PPUSH
32767: CALL 102594 0 1
32771: IFFALSE 32782
// ComExitVehicle ( i ) ;
32773: LD_VAR 0 2
32777: PPUSH
32778: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32782: LD_VAR 0 2
32786: PPUSH
32787: LD_INT 26
32789: PPUSH
32790: CALL_OW 308
32794: NOT
32795: IFFALSE 32811
// AddComMoveToArea ( i , allianceEscapeArea ) else
32797: LD_VAR 0 2
32801: PPUSH
32802: LD_INT 26
32804: PPUSH
32805: CALL_OW 173
32809: GO 32820
// RemoveUnit ( i ) ;
32811: LD_VAR 0 2
32815: PPUSH
32816: CALL_OW 64
// end ;
32820: GO 32739
32822: POP
32823: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32824: LD_INT 22
32826: PUSH
32827: LD_INT 7
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 21
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PPUSH
32848: CALL_OW 69
32852: NOT
32853: IFFALSE 32698
// end ;
32855: PPOPN 2
32857: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32858: LD_INT 0
32860: PPUSH
32861: PPUSH
// if not unit then
32862: LD_VAR 0 1
32866: NOT
32867: IFFALSE 32871
// exit ;
32869: GO 34369
// DoNotAttack ( 7 , unit ) ;
32871: LD_INT 7
32873: PPUSH
32874: LD_VAR 0 1
32878: PPUSH
32879: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32883: LD_VAR 0 1
32887: PPUSH
32888: LD_INT 260
32890: PPUSH
32891: LD_INT 235
32893: PPUSH
32894: LD_INT 3
32896: PPUSH
32897: LD_INT 1
32899: PPUSH
32900: CALL_OW 483
// SetSide ( unit , 4 ) ;
32904: LD_VAR 0 1
32908: PPUSH
32909: LD_INT 4
32911: PPUSH
32912: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32916: LD_ADDR_EXP 34
32920: PUSH
32921: LD_EXP 34
32925: PUSH
32926: LD_INT 1
32928: PLUS
32929: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32930: LD_INT 70
32932: PPUSH
32933: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32937: LD_INT 260
32939: PPUSH
32940: LD_INT 235
32942: PPUSH
32943: LD_INT 1
32945: PPUSH
32946: LD_INT 8
32948: NEG
32949: PPUSH
32950: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32954: LD_VAR 0 1
32958: PPUSH
32959: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32963: LD_VAR 0 1
32967: PPUSH
32968: LD_EXP 77
32972: PPUSH
32973: CALL_OW 119
// DialogueOn ;
32977: CALL_OW 6
// case unit of JMM :
32981: LD_VAR 0 1
32985: PUSH
32986: LD_EXP 40
32990: DOUBLE
32991: EQUAL
32992: IFTRUE 32996
32994: GO 33011
32996: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32997: LD_EXP 40
33001: PPUSH
33002: LD_STRING DA1-JMM-1
33004: PPUSH
33005: CALL_OW 91
33009: GO 33453
33011: LD_EXP 41
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33036
33021: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
33022: LD_EXP 41
33026: PPUSH
33027: LD_STRING DA1-Joan-1
33029: PPUSH
33030: CALL_OW 91
33034: GO 33453
33036: LD_EXP 43
33040: DOUBLE
33041: EQUAL
33042: IFTRUE 33046
33044: GO 33061
33046: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
33047: LD_EXP 43
33051: PPUSH
33052: LD_STRING DA1-Lisa-1
33054: PPUSH
33055: CALL_OW 91
33059: GO 33453
33061: LD_EXP 44
33065: DOUBLE
33066: EQUAL
33067: IFTRUE 33071
33069: GO 33086
33071: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
33072: LD_EXP 44
33076: PPUSH
33077: LD_STRING DA1-Don-1
33079: PPUSH
33080: CALL_OW 91
33084: GO 33453
33086: LD_EXP 51
33090: DOUBLE
33091: EQUAL
33092: IFTRUE 33096
33094: GO 33111
33096: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
33097: LD_EXP 51
33101: PPUSH
33102: LD_STRING DA1-Corn-1
33104: PPUSH
33105: CALL_OW 91
33109: GO 33453
33111: LD_EXP 47
33115: DOUBLE
33116: EQUAL
33117: IFTRUE 33121
33119: GO 33136
33121: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
33122: LD_EXP 47
33126: PPUSH
33127: LD_STRING DA1-Den-1
33129: PPUSH
33130: CALL_OW 91
33134: GO 33453
33136: LD_EXP 45
33140: DOUBLE
33141: EQUAL
33142: IFTRUE 33146
33144: GO 33161
33146: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
33147: LD_EXP 45
33151: PPUSH
33152: LD_STRING DA1-Bobby-1
33154: PPUSH
33155: CALL_OW 91
33159: GO 33453
33161: LD_EXP 49
33165: DOUBLE
33166: EQUAL
33167: IFTRUE 33171
33169: GO 33186
33171: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
33172: LD_EXP 49
33176: PPUSH
33177: LD_STRING DA1-Glad-1
33179: PPUSH
33180: CALL_OW 91
33184: GO 33453
33186: LD_EXP 46
33190: DOUBLE
33191: EQUAL
33192: IFTRUE 33196
33194: GO 33211
33196: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
33197: LD_EXP 46
33201: PPUSH
33202: LD_STRING DA1-Cyrus-1
33204: PPUSH
33205: CALL_OW 91
33209: GO 33453
33211: LD_EXP 42
33215: DOUBLE
33216: EQUAL
33217: IFTRUE 33221
33219: GO 33236
33221: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33222: LD_EXP 42
33226: PPUSH
33227: LD_STRING DA1-Huck-1
33229: PPUSH
33230: CALL_OW 91
33234: GO 33453
33236: LD_EXP 56
33240: DOUBLE
33241: EQUAL
33242: IFTRUE 33246
33244: GO 33261
33246: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33247: LD_EXP 56
33251: PPUSH
33252: LD_STRING DA1-Huck-1
33254: PPUSH
33255: CALL_OW 91
33259: GO 33453
33261: LD_EXP 48
33265: DOUBLE
33266: EQUAL
33267: IFTRUE 33271
33269: GO 33286
33271: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33272: LD_EXP 48
33276: PPUSH
33277: LD_STRING DA1-Brown-1
33279: PPUSH
33280: CALL_OW 91
33284: GO 33453
33286: LD_EXP 52
33290: DOUBLE
33291: EQUAL
33292: IFTRUE 33296
33294: GO 33311
33296: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33297: LD_EXP 52
33301: PPUSH
33302: LD_STRING DA1-Gary-1
33304: PPUSH
33305: CALL_OW 91
33309: GO 33453
33311: LD_EXP 55
33315: DOUBLE
33316: EQUAL
33317: IFTRUE 33321
33319: GO 33336
33321: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33322: LD_EXP 55
33326: PPUSH
33327: LD_STRING DA1-Con-1
33329: PPUSH
33330: CALL_OW 91
33334: GO 33453
33336: LD_EXP 62
33340: DOUBLE
33341: EQUAL
33342: IFTRUE 33346
33344: GO 33361
33346: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33347: LD_EXP 62
33351: PPUSH
33352: LD_STRING DA1-Kurt-1
33354: PPUSH
33355: CALL_OW 91
33359: GO 33453
33361: LD_EXP 54
33365: DOUBLE
33366: EQUAL
33367: IFTRUE 33371
33369: GO 33386
33371: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33372: LD_EXP 54
33376: PPUSH
33377: LD_STRING DA1-Yam-1
33379: PPUSH
33380: CALL_OW 91
33384: GO 33453
33386: LD_EXP 53
33390: DOUBLE
33391: EQUAL
33392: IFTRUE 33396
33394: GO 33411
33396: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33397: LD_EXP 53
33401: PPUSH
33402: LD_STRING DA1-Frank-1
33404: PPUSH
33405: CALL_OW 91
33409: GO 33453
33411: POP
// begin if GetSex ( unit ) = sex_male then
33412: LD_VAR 0 1
33416: PPUSH
33417: CALL_OW 258
33421: PUSH
33422: LD_INT 1
33424: EQUAL
33425: IFFALSE 33441
// ForceSay ( unit , DA1-Sol1-1 ) else
33427: LD_VAR 0 1
33431: PPUSH
33432: LD_STRING DA1-Sol1-1
33434: PPUSH
33435: CALL_OW 91
33439: GO 33453
// ForceSay ( unit , DA1-FSol1-1 ) ;
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_STRING DA1-FSol1-1
33448: PPUSH
33449: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33453: LD_EXP 77
33457: PPUSH
33458: LD_STRING DA-Roth-1
33460: PPUSH
33461: CALL_OW 88
// if capturedUnit = 1 then
33465: LD_EXP 34
33469: PUSH
33470: LD_INT 1
33472: EQUAL
33473: IFFALSE 33501
// begin Say ( Simms , DA-Sim-1 ) ;
33475: LD_EXP 78
33479: PPUSH
33480: LD_STRING DA-Sim-1
33482: PPUSH
33483: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33487: LD_EXP 77
33491: PPUSH
33492: LD_STRING DA-Roth-2
33494: PPUSH
33495: CALL_OW 88
// end else
33499: GO 33513
// Say ( Simms , DA-Sim-2 ) ;
33501: LD_EXP 78
33505: PPUSH
33506: LD_STRING DA-Sim-2
33508: PPUSH
33509: CALL_OW 88
// case unit of JMM :
33513: LD_VAR 0 1
33517: PUSH
33518: LD_EXP 40
33522: DOUBLE
33523: EQUAL
33524: IFTRUE 33528
33526: GO 33543
33528: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33529: LD_EXP 40
33533: PPUSH
33534: LD_STRING DA1-JMM-1a
33536: PPUSH
33537: CALL_OW 91
33541: GO 34050
33543: LD_EXP 41
33547: DOUBLE
33548: EQUAL
33549: IFTRUE 33553
33551: GO 33568
33553: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33554: LD_EXP 41
33558: PPUSH
33559: LD_STRING DA1-Joan-1a
33561: PPUSH
33562: CALL_OW 91
33566: GO 34050
33568: LD_EXP 43
33572: DOUBLE
33573: EQUAL
33574: IFTRUE 33578
33576: GO 33593
33578: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33579: LD_EXP 43
33583: PPUSH
33584: LD_STRING DA1-Lisa-1a
33586: PPUSH
33587: CALL_OW 91
33591: GO 34050
33593: LD_EXP 44
33597: DOUBLE
33598: EQUAL
33599: IFTRUE 33603
33601: GO 33618
33603: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33604: LD_EXP 44
33608: PPUSH
33609: LD_STRING DA1-Don-1a
33611: PPUSH
33612: CALL_OW 91
33616: GO 34050
33618: LD_EXP 51
33622: DOUBLE
33623: EQUAL
33624: IFTRUE 33628
33626: GO 33643
33628: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33629: LD_EXP 51
33633: PPUSH
33634: LD_STRING DA1-Corn-1a
33636: PPUSH
33637: CALL_OW 91
33641: GO 34050
33643: LD_EXP 47
33647: DOUBLE
33648: EQUAL
33649: IFTRUE 33653
33651: GO 33668
33653: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33654: LD_EXP 47
33658: PPUSH
33659: LD_STRING DA1-Den-1a
33661: PPUSH
33662: CALL_OW 91
33666: GO 34050
33668: LD_EXP 45
33672: DOUBLE
33673: EQUAL
33674: IFTRUE 33678
33676: GO 33693
33678: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33679: LD_EXP 45
33683: PPUSH
33684: LD_STRING DA1-Bobby-1a
33686: PPUSH
33687: CALL_OW 91
33691: GO 34050
33693: LD_EXP 49
33697: DOUBLE
33698: EQUAL
33699: IFTRUE 33703
33701: GO 33718
33703: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33704: LD_EXP 49
33708: PPUSH
33709: LD_STRING DA1-Glad-1a
33711: PPUSH
33712: CALL_OW 91
33716: GO 34050
33718: LD_EXP 46
33722: DOUBLE
33723: EQUAL
33724: IFTRUE 33728
33726: GO 33743
33728: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33729: LD_EXP 46
33733: PPUSH
33734: LD_STRING DA1-Cyrus-1a
33736: PPUSH
33737: CALL_OW 91
33741: GO 34050
33743: LD_EXP 42
33747: DOUBLE
33748: EQUAL
33749: IFTRUE 33753
33751: GO 33768
33753: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33754: LD_EXP 42
33758: PPUSH
33759: LD_STRING DA1-Huck-1a
33761: PPUSH
33762: CALL_OW 91
33766: GO 34050
33768: LD_EXP 56
33772: DOUBLE
33773: EQUAL
33774: IFTRUE 33778
33776: GO 33793
33778: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33779: LD_EXP 56
33783: PPUSH
33784: LD_STRING DA1-Huck-1a
33786: PPUSH
33787: CALL_OW 91
33791: GO 34050
33793: LD_EXP 48
33797: DOUBLE
33798: EQUAL
33799: IFTRUE 33803
33801: GO 33818
33803: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33804: LD_EXP 48
33808: PPUSH
33809: LD_STRING DA1-Brown-1a
33811: PPUSH
33812: CALL_OW 91
33816: GO 34050
33818: LD_EXP 52
33822: DOUBLE
33823: EQUAL
33824: IFTRUE 33828
33826: GO 33843
33828: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33829: LD_EXP 52
33833: PPUSH
33834: LD_STRING DA1-Gary-1a
33836: PPUSH
33837: CALL_OW 91
33841: GO 34050
33843: LD_EXP 55
33847: DOUBLE
33848: EQUAL
33849: IFTRUE 33853
33851: GO 33868
33853: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33854: LD_EXP 55
33858: PPUSH
33859: LD_STRING DA1-Con-1a
33861: PPUSH
33862: CALL_OW 91
33866: GO 34050
33868: LD_EXP 62
33872: DOUBLE
33873: EQUAL
33874: IFTRUE 33878
33876: GO 33893
33878: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33879: LD_EXP 62
33883: PPUSH
33884: LD_STRING DA1-Kurt-1a
33886: PPUSH
33887: CALL_OW 91
33891: GO 34050
33893: LD_EXP 54
33897: DOUBLE
33898: EQUAL
33899: IFTRUE 33903
33901: GO 33918
33903: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33904: LD_EXP 54
33908: PPUSH
33909: LD_STRING DA1-Yam-1a
33911: PPUSH
33912: CALL_OW 91
33916: GO 34050
33918: LD_EXP 53
33922: DOUBLE
33923: EQUAL
33924: IFTRUE 33928
33926: GO 33943
33928: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33929: LD_EXP 53
33933: PPUSH
33934: LD_STRING DA1-Frank-1a
33936: PPUSH
33937: CALL_OW 91
33941: GO 34050
33943: POP
// begin join := rand ( 0 , 1 ) ;
33944: LD_ADDR_VAR 0 3
33948: PUSH
33949: LD_INT 0
33951: PPUSH
33952: LD_INT 1
33954: PPUSH
33955: CALL_OW 12
33959: ST_TO_ADDR
// if join then
33960: LD_VAR 0 3
33964: IFFALSE 34009
// begin if GetSex ( unit ) = sex_male then
33966: LD_VAR 0 1
33970: PPUSH
33971: CALL_OW 258
33975: PUSH
33976: LD_INT 1
33978: EQUAL
33979: IFFALSE 33995
// ForceSay ( unit , DA1-Sol1-1b ) else
33981: LD_VAR 0 1
33985: PPUSH
33986: LD_STRING DA1-Sol1-1b
33988: PPUSH
33989: CALL_OW 91
33993: GO 34007
// ForceSay ( unit , DA1-FSol1-1b ) ;
33995: LD_VAR 0 1
33999: PPUSH
34000: LD_STRING DA1-FSol1-1b
34002: PPUSH
34003: CALL_OW 91
// end else
34007: GO 34050
// begin if GetSex ( unit ) = sex_male then
34009: LD_VAR 0 1
34013: PPUSH
34014: CALL_OW 258
34018: PUSH
34019: LD_INT 1
34021: EQUAL
34022: IFFALSE 34038
// ForceSay ( unit , DA1-Sol1-1a ) else
34024: LD_VAR 0 1
34028: PPUSH
34029: LD_STRING DA1-Sol1-1a
34031: PPUSH
34032: CALL_OW 91
34036: GO 34050
// ForceSay ( unit , DA1-FSol1-1a ) ;
34038: LD_VAR 0 1
34042: PPUSH
34043: LD_STRING DA1-FSol1-1a
34045: PPUSH
34046: CALL_OW 91
// end ; end ; end ; if unit = JMM then
34050: LD_VAR 0 1
34054: PUSH
34055: LD_EXP 40
34059: EQUAL
34060: IFFALSE 34071
// begin YouLost ( JMMCaptured ) ;
34062: LD_STRING JMMCaptured
34064: PPUSH
34065: CALL_OW 104
// exit ;
34069: GO 34369
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
34071: LD_VAR 0 1
34075: PUSH
34076: LD_EXP 44
34080: PUSH
34081: LD_EXP 47
34085: PUSH
34086: LD_EXP 45
34090: PUSH
34091: LD_EXP 42
34095: PUSH
34096: LD_EXP 56
34100: PUSH
34101: LD_EXP 48
34105: PUSH
34106: LD_EXP 54
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: IN
34120: PUSH
34121: LD_VAR 0 3
34125: OR
34126: IFFALSE 34225
// begin Say ( Roth , DA-Roth-3 ) ;
34128: LD_EXP 77
34132: PPUSH
34133: LD_STRING DA-Roth-3
34135: PPUSH
34136: CALL_OW 88
// SetSide ( unit , 7 ) ;
34140: LD_VAR 0 1
34144: PPUSH
34145: LD_INT 7
34147: PPUSH
34148: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
34152: LD_ADDR_EXP 100
34156: PUSH
34157: LD_EXP 100
34161: PPUSH
34162: LD_INT 1
34164: PPUSH
34165: LD_EXP 100
34169: PUSH
34170: LD_INT 1
34172: ARRAY
34173: PUSH
34174: LD_VAR 0 1
34178: ADD
34179: PPUSH
34180: CALL_OW 1
34184: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34185: LD_INT 260
34187: PPUSH
34188: LD_INT 235
34190: PPUSH
34191: LD_INT 1
34193: PPUSH
34194: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34198: LD_VAR 0 1
34202: PPUSH
34203: LD_INT 1000
34205: PPUSH
34206: CALL_OW 234
// DialogueOff ;
34210: CALL_OW 7
// ComFree ( unit ) ;
34214: LD_VAR 0 1
34218: PPUSH
34219: CALL_OW 139
// end else
34223: GO 34306
// begin Say ( Roth , DA-Roth-3a ) ;
34225: LD_EXP 77
34229: PPUSH
34230: LD_STRING DA-Roth-3a
34232: PPUSH
34233: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34237: LD_ADDR_EXP 35
34241: PUSH
34242: LD_EXP 35
34246: PUSH
34247: LD_VAR 0 1
34251: ADD
34252: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34253: LD_INT 260
34255: PPUSH
34256: LD_INT 235
34258: PPUSH
34259: LD_INT 1
34261: PPUSH
34262: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34266: LD_VAR 0 1
34270: PPUSH
34271: LD_INT 1000
34273: PPUSH
34274: CALL_OW 234
// DialogueOff ;
34278: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34282: LD_VAR 0 1
34286: PPUSH
34287: LD_INT 272
34289: PPUSH
34290: LD_INT 254
34292: PPUSH
34293: CALL_OW 111
// AddComHold ( unit ) ;
34297: LD_VAR 0 1
34301: PPUSH
34302: CALL_OW 200
// end ; if capturedUnit = 1 then
34306: LD_EXP 34
34310: PUSH
34311: LD_INT 1
34313: EQUAL
34314: IFFALSE 34369
// begin DialogueOn ;
34316: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34320: LD_EXP 40
34324: PPUSH
34325: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34329: LD_EXP 40
34333: PPUSH
34334: LD_STRING DAa-JMM-1
34336: PPUSH
34337: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34341: LD_EXP 40
34345: PPUSH
34346: LD_STRING DAa-JMM-1a
34348: PPUSH
34349: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34353: LD_EXP 40
34357: PPUSH
34358: LD_STRING DAa-JMM-1b
34360: PPUSH
34361: CALL_OW 88
// DialogueOff ;
34365: CALL_OW 7
// end ; end ;
34369: LD_VAR 0 2
34373: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34374: LD_EXP 15
34378: PUSH
34379: LD_INT 13
34381: GREATEREQUAL
34382: PUSH
34383: LD_INT 22
34385: PUSH
34386: LD_INT 2
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 21
34395: PUSH
34396: LD_INT 1
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PPUSH
34407: CALL_OW 69
34411: PUSH
34412: LD_INT 0
34414: EQUAL
34415: AND
34416: PUSH
34417: LD_INT 22
34419: PUSH
34420: LD_INT 2
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 33
34429: PUSH
34430: LD_INT 5
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 21
34439: PUSH
34440: LD_INT 2
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 50
34449: PUSH
34450: EMPTY
34451: LIST
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: PPUSH
34459: CALL_OW 69
34463: PUSH
34464: LD_INT 0
34466: EQUAL
34467: AND
34468: PUSH
34469: LD_EXP 21
34473: AND
34474: PUSH
34475: LD_EXP 22
34479: AND
34480: PUSH
34481: LD_EXP 23
34485: AND
34486: IFFALSE 35175
34488: GO 34490
34490: DISABLE
34491: LD_INT 0
34493: PPUSH
34494: PPUSH
34495: PPUSH
// begin m1 := false ;
34496: LD_ADDR_VAR 0 1
34500: PUSH
34501: LD_INT 0
34503: ST_TO_ADDR
// m2 := false ;
34504: LD_ADDR_VAR 0 2
34508: PUSH
34509: LD_INT 0
34511: ST_TO_ADDR
// m3 := false ;
34512: LD_ADDR_VAR 0 3
34516: PUSH
34517: LD_INT 0
34519: ST_TO_ADDR
// if not bombExploded then
34520: LD_EXP 37
34524: NOT
34525: IFFALSE 34534
// SetAchievement ( ACH_SIBROCKET ) ;
34527: LD_STRING ACH_SIBROCKET
34529: PPUSH
34530: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34534: LD_EXP 64
34538: PPUSH
34539: CALL_OW 255
34543: PUSH
34544: LD_INT 1
34546: EQUAL
34547: PUSH
34548: LD_EXP 64
34552: PPUSH
34553: CALL_OW 302
34557: AND
34558: IFFALSE 34574
// begin wait ( 3 ) ;
34560: LD_INT 3
34562: PPUSH
34563: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34567: LD_STRING ACH_OPO
34569: PPUSH
34570: CALL_OW 543
// end ; if tick <= 120 120$00 then
34574: LD_OWVAR 1
34578: PUSH
34579: LD_INT 252000
34581: LESSEQUAL
34582: IFFALSE 34598
// begin wait ( 3 ) ;
34584: LD_INT 3
34586: PPUSH
34587: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34591: LD_STRING ACH_ASPEED_15
34593: PPUSH
34594: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34598: LD_EXP 40
34602: PPUSH
34603: CALL_OW 87
// music_class := 5 ;
34607: LD_ADDR_OWVAR 72
34611: PUSH
34612: LD_INT 5
34614: ST_TO_ADDR
// music_nat := 5 ;
34615: LD_ADDR_OWVAR 71
34619: PUSH
34620: LD_INT 5
34622: ST_TO_ADDR
// DialogueOn ;
34623: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34627: LD_EXP 40
34631: PPUSH
34632: LD_STRING D20-JMM-1
34634: PPUSH
34635: CALL_OW 88
// if IsOK ( Joan ) then
34639: LD_EXP 41
34643: PPUSH
34644: CALL_OW 302
34648: IFFALSE 34662
// Say ( Joan , D20-Joan-1 ) ;
34650: LD_EXP 41
34654: PPUSH
34655: LD_STRING D20-Joan-1
34657: PPUSH
34658: CALL_OW 88
// if IsOk ( Lisa ) then
34662: LD_EXP 43
34666: PPUSH
34667: CALL_OW 302
34671: IFFALSE 34685
// Say ( Lisa , D20-Lisa-1 ) ;
34673: LD_EXP 43
34677: PPUSH
34678: LD_STRING D20-Lisa-1
34680: PPUSH
34681: CALL_OW 88
// if IsOk ( Donaldson ) then
34685: LD_EXP 44
34689: PPUSH
34690: CALL_OW 302
34694: IFFALSE 34708
// Say ( Donaldson , D20-Don-1 ) ;
34696: LD_EXP 44
34700: PPUSH
34701: LD_STRING D20-Don-1
34703: PPUSH
34704: CALL_OW 88
// if IsOK ( Cornel ) then
34708: LD_EXP 51
34712: PPUSH
34713: CALL_OW 302
34717: IFFALSE 34731
// Say ( Cornel , D20-Corn-1 ) ;
34719: LD_EXP 51
34723: PPUSH
34724: LD_STRING D20-Corn-1
34726: PPUSH
34727: CALL_OW 88
// if IsOk ( Denis ) then
34731: LD_EXP 47
34735: PPUSH
34736: CALL_OW 302
34740: IFFALSE 34754
// Say ( Denis , D20-Den-1 ) ;
34742: LD_EXP 47
34746: PPUSH
34747: LD_STRING D20-Den-1
34749: PPUSH
34750: CALL_OW 88
// if IsOk ( Bobby ) then
34754: LD_EXP 45
34758: PPUSH
34759: CALL_OW 302
34763: IFFALSE 34777
// Say ( Bobby , D20-Bobby-1 ) ;
34765: LD_EXP 45
34769: PPUSH
34770: LD_STRING D20-Bobby-1
34772: PPUSH
34773: CALL_OW 88
// if IsOk ( Gladstone ) then
34777: LD_EXP 49
34781: PPUSH
34782: CALL_OW 302
34786: IFFALSE 34800
// Say ( Gladstone , D20-Glad-1 ) ;
34788: LD_EXP 49
34792: PPUSH
34793: LD_STRING D20-Glad-1
34795: PPUSH
34796: CALL_OW 88
// if IsOk ( Cyrus ) then
34800: LD_EXP 46
34804: PPUSH
34805: CALL_OW 302
34809: IFFALSE 34823
// Say ( Cyrus , D20-Cyrus-1 ) ;
34811: LD_EXP 46
34815: PPUSH
34816: LD_STRING D20-Cyrus-1
34818: PPUSH
34819: CALL_OW 88
// if IsOk ( Stevens ) then
34823: LD_EXP 42
34827: PPUSH
34828: CALL_OW 302
34832: IFFALSE 34846
// Say ( Stevens , D20-Huck-1 ) ;
34834: LD_EXP 42
34838: PPUSH
34839: LD_STRING D20-Huck-1
34841: PPUSH
34842: CALL_OW 88
// if IsOk ( Brown ) then
34846: LD_EXP 48
34850: PPUSH
34851: CALL_OW 302
34855: IFFALSE 34869
// Say ( Brown , D20-Brown-1 ) ;
34857: LD_EXP 48
34861: PPUSH
34862: LD_STRING D20-Brown-1
34864: PPUSH
34865: CALL_OW 88
// if IsOk ( Gary ) then
34869: LD_EXP 52
34873: PPUSH
34874: CALL_OW 302
34878: IFFALSE 34892
// Say ( Gary , D20-Gary-1 ) ;
34880: LD_EXP 52
34884: PPUSH
34885: LD_STRING D20-Gary-1
34887: PPUSH
34888: CALL_OW 88
// if IsOk ( Connie ) then
34892: LD_EXP 55
34896: PPUSH
34897: CALL_OW 302
34901: IFFALSE 34915
// Say ( Connie , D20-Con-1 ) ;
34903: LD_EXP 55
34907: PPUSH
34908: LD_STRING D20-Con-1
34910: PPUSH
34911: CALL_OW 88
// if IsOk ( Kurt ) then
34915: LD_EXP 62
34919: PPUSH
34920: CALL_OW 302
34924: IFFALSE 34938
// Say ( Kurt , D20-Kurt-1 ) ;
34926: LD_EXP 62
34930: PPUSH
34931: LD_STRING D20-Kurt-1
34933: PPUSH
34934: CALL_OW 88
// if IsOk ( Kikuchi ) then
34938: LD_EXP 54
34942: PPUSH
34943: CALL_OW 302
34947: IFFALSE 34961
// Say ( Kikuchi , D20-Yam-1 ) ;
34949: LD_EXP 54
34953: PPUSH
34954: LD_STRING D20-Yam-1
34956: PPUSH
34957: CALL_OW 88
// if IsOk ( Frank ) then
34961: LD_EXP 53
34965: PPUSH
34966: CALL_OW 302
34970: IFFALSE 34984
// Say ( Frank , D20-Frank-1 ) ;
34972: LD_EXP 53
34976: PPUSH
34977: LD_STRING D20-Frank-1
34979: PPUSH
34980: CALL_OW 88
// DialogueOff ;
34984: CALL_OW 7
// if RothCaptured then
34988: LD_EXP 33
34992: IFFALSE 35014
// begin m1 := true ;
34994: LD_ADDR_VAR 0 1
34998: PUSH
34999: LD_INT 1
35001: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
35002: LD_STRING Roth
35004: PPUSH
35005: LD_INT 1
35007: PPUSH
35008: CALL_OW 101
// end else
35012: GO 35025
// AddMedal ( Roth , - 1 ) ;
35014: LD_STRING Roth
35016: PPUSH
35017: LD_INT 1
35019: NEG
35020: PPUSH
35021: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
35025: LD_EXP 25
35029: NOT
35030: PUSH
35031: LD_EXP 27
35035: OR
35036: IFFALSE 35058
// begin m2 := true ;
35038: LD_ADDR_VAR 0 2
35042: PUSH
35043: LD_INT 1
35045: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
35046: LD_STRING Project
35048: PPUSH
35049: LD_INT 1
35051: PPUSH
35052: CALL_OW 101
// end else
35056: GO 35069
// AddMedal ( Project , - 1 ) ;
35058: LD_STRING Project
35060: PPUSH
35061: LD_INT 1
35063: NEG
35064: PPUSH
35065: CALL_OW 101
// if lostCounter = 0 then
35069: LD_EXP 32
35073: PUSH
35074: LD_INT 0
35076: EQUAL
35077: IFFALSE 35099
// begin m3 := true ;
35079: LD_ADDR_VAR 0 3
35083: PUSH
35084: LD_INT 1
35086: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
35087: LD_STRING NoLosses
35089: PPUSH
35090: LD_INT 1
35092: PPUSH
35093: CALL_OW 101
// end else
35097: GO 35110
// AddMedal ( NoLosses , - 1 ) ;
35099: LD_STRING NoLosses
35101: PPUSH
35102: LD_INT 1
35104: NEG
35105: PPUSH
35106: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
35110: LD_VAR 0 1
35114: PUSH
35115: LD_VAR 0 2
35119: AND
35120: PUSH
35121: LD_VAR 0 3
35125: AND
35126: PUSH
35127: LD_OWVAR 67
35131: PUSH
35132: LD_INT 3
35134: GREATEREQUAL
35135: AND
35136: IFFALSE 35148
// SetAchievementEX ( ACH_AMER , 15 ) ;
35138: LD_STRING ACH_AMER
35140: PPUSH
35141: LD_INT 15
35143: PPUSH
35144: CALL_OW 564
// GiveMedals ( MAIN ) ;
35148: LD_STRING MAIN
35150: PPUSH
35151: CALL_OW 102
// music_class := 4 ;
35155: LD_ADDR_OWVAR 72
35159: PUSH
35160: LD_INT 4
35162: ST_TO_ADDR
// music_nat := 1 ;
35163: LD_ADDR_OWVAR 71
35167: PUSH
35168: LD_INT 1
35170: ST_TO_ADDR
// YouWin ;
35171: CALL_OW 103
// end ; end_of_file
35175: PPOPN 3
35177: END
// export function CustomEvent ( event ) ; begin
35178: LD_INT 0
35180: PPUSH
// end ;
35181: LD_VAR 0 2
35185: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
35186: LD_VAR 0 1
35190: PUSH
35191: LD_INT 1
35193: EQUAL
35194: PUSH
35195: LD_VAR 0 2
35199: PUSH
35200: LD_INT 4
35202: EQUAL
35203: AND
35204: PUSH
35205: LD_EXP 60
35209: PPUSH
35210: CALL_OW 300
35214: AND
35215: IFFALSE 35231
// begin wait ( 0 0$2 ) ;
35217: LD_INT 70
35219: PPUSH
35220: CALL_OW 67
// YouLost ( Dismissed ) ;
35224: LD_STRING Dismissed
35226: PPUSH
35227: CALL_OW 104
// end ; end ;
35231: PPOPN 2
35233: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35234: LD_VAR 0 2
35238: PPUSH
35239: LD_VAR 0 3
35243: PPUSH
35244: LD_INT 18
35246: PPUSH
35247: CALL_OW 309
35251: IFFALSE 35260
// YouLost ( Motherlode3 ) ;
35253: LD_STRING Motherlode3
35255: PPUSH
35256: CALL_OW 104
// end ;
35260: PPOPN 3
35262: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35263: LD_EXP 27
35267: NOT
35268: IFFALSE 35278
// behemothDone := true ;
35270: LD_ADDR_EXP 28
35274: PUSH
35275: LD_INT 1
35277: ST_TO_ADDR
// end ;
35278: PPOPN 1
35280: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35281: LD_VAR 0 1
35285: PPUSH
35286: CALL_OW 255
35290: PUSH
35291: LD_INT 1
35293: EQUAL
35294: IFFALSE 35304
// bombExploded := true ;
35296: LD_ADDR_EXP 37
35300: PUSH
35301: LD_INT 1
35303: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
35304: LD_VAR 0 1
35308: PPUSH
35309: CALL_OW 255
35313: PUSH
35314: LD_INT 3
35316: EQUAL
35317: IFFALSE 35347
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
35319: LD_INT 2
35321: PPUSH
35322: LD_INT 23
35324: PUSH
35325: LD_INT 3
35327: PUSH
35328: LD_INT 3
35330: PUSH
35331: LD_INT 48
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: PUSH
35340: EMPTY
35341: LIST
35342: PPUSH
35343: CALL 61148 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35347: LD_VAR 0 1
35351: PPUSH
35352: CALL_OW 255
35356: PUSH
35357: LD_INT 1
35359: EQUAL
35360: PUSH
35361: LD_EXP 64
35365: PPUSH
35366: CALL_OW 255
35370: PUSH
35371: LD_INT 1
35373: EQUAL
35374: AND
35375: PUSH
35376: LD_EXP 64
35380: PPUSH
35381: CALL_OW 302
35385: AND
35386: PUSH
35387: LD_EXP 30
35391: AND
35392: PUSH
35393: LD_INT 22
35395: PUSH
35396: LD_INT 3
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 34
35405: PUSH
35406: LD_INT 48
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PPUSH
35417: CALL_OW 69
35421: AND
35422: PUSH
35423: LD_INT 22
35425: PUSH
35426: LD_INT 1
35428: PUSH
35429: EMPTY
35430: LIST
35431: LIST
35432: PUSH
35433: LD_INT 34
35435: PUSH
35436: LD_INT 8
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PPUSH
35447: CALL_OW 69
35451: NOT
35452: AND
35453: IFFALSE 35505
// begin wait ( 0 0$5 ) ;
35455: LD_INT 175
35457: PPUSH
35458: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35462: LD_INT 22
35464: PUSH
35465: LD_INT 3
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 34
35474: PUSH
35475: LD_INT 48
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PPUSH
35486: CALL_OW 69
35490: PUSH
35491: LD_INT 1
35493: ARRAY
35494: PPUSH
35495: LD_INT 60
35497: PPUSH
35498: LD_INT 95
35500: PPUSH
35501: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
35505: LD_VAR 0 2
35509: PPUSH
35510: LD_VAR 0 3
35514: PPUSH
35515: LD_INT 18
35517: PPUSH
35518: CALL_OW 309
35522: PUSH
35523: LD_VAR 0 2
35527: PPUSH
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_INT 18
35535: PPUSH
35536: CALL 108794 0 3
35540: OR
35541: IFFALSE 35588
// begin if GetSide ( unit ) = 1 then
35543: LD_VAR 0 1
35547: PPUSH
35548: CALL_OW 255
35552: PUSH
35553: LD_INT 1
35555: EQUAL
35556: IFFALSE 35574
// begin wait ( 0 0$6 ) ;
35558: LD_INT 210
35560: PPUSH
35561: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35565: LD_STRING Motherlode2
35567: PPUSH
35568: CALL_OW 104
// end else
35572: GO 35588
// begin wait ( 0 0$6 ) ;
35574: LD_INT 210
35576: PPUSH
35577: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35581: LD_STRING Motherlode1
35583: PPUSH
35584: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35588: LD_VAR 0 1
35592: PPUSH
35593: CALL_OW 255
35597: PUSH
35598: LD_INT 3
35600: EQUAL
35601: IFFALSE 35622
// begin wait ( 0 0$5 ) ;
35603: LD_INT 175
35605: PPUSH
35606: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35610: LD_EXP 66
35614: PPUSH
35615: LD_STRING D18-Pla-1
35617: PPUSH
35618: CALL_OW 94
// end ; end ;
35622: PPOPN 3
35624: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35625: LD_VAR 0 1
35629: PPUSH
35630: CALL 124587 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35634: LD_VAR 0 1
35638: PUSH
35639: LD_INT 22
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 21
35651: PUSH
35652: LD_INT 1
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 23
35661: PUSH
35662: LD_INT 1
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: LIST
35673: PPUSH
35674: CALL_OW 69
35678: IN
35679: IFFALSE 35695
// lostCounter := lostCounter + 1 ;
35681: LD_ADDR_EXP 32
35685: PUSH
35686: LD_EXP 32
35690: PUSH
35691: LD_INT 1
35693: PLUS
35694: ST_TO_ADDR
// if un in behemothBuilders then
35695: LD_VAR 0 1
35699: PUSH
35700: LD_EXP 75
35704: IN
35705: IFFALSE 35725
// begin behemothBuilders := behemothBuilders diff un ;
35707: LD_ADDR_EXP 75
35711: PUSH
35712: LD_EXP 75
35716: PUSH
35717: LD_VAR 0 1
35721: DIFF
35722: ST_TO_ADDR
// exit ;
35723: GO 35755
// end ; if un = JMM then
35725: LD_VAR 0 1
35729: PUSH
35730: LD_EXP 40
35734: EQUAL
35735: IFFALSE 35746
// begin YouLost ( JMM ) ;
35737: LD_STRING JMM
35739: PPUSH
35740: CALL_OW 104
// exit ;
35744: GO 35755
// end ; MCE_UnitDestroyed ( un ) ;
35746: LD_VAR 0 1
35750: PPUSH
35751: CALL 64552 0 1
// end ;
35755: PPOPN 1
35757: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35758: LD_VAR 0 1
35762: PPUSH
35763: LD_VAR 0 2
35767: PPUSH
35768: CALL 66884 0 2
// end ;
35772: PPOPN 2
35774: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35775: LD_VAR 0 1
35779: PPUSH
35780: CALL 65952 0 1
// end ;
35784: PPOPN 1
35786: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35787: LD_VAR 0 1
35791: PUSH
35792: LD_INT 22
35794: PUSH
35795: LD_INT 8
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 30
35804: PUSH
35805: LD_INT 2
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 23
35814: PUSH
35815: LD_INT 3
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: LIST
35826: PPUSH
35827: CALL_OW 69
35831: IN
35832: IFFALSE 35859
// begin ComUpgrade ( building ) ;
35834: LD_VAR 0 1
35838: PPUSH
35839: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35843: LD_EXP 63
35847: PPUSH
35848: LD_VAR 0 1
35852: PPUSH
35853: CALL 75534 0 2
// exit ;
35857: GO 35868
// end ; MCE_BuildingComplete ( building ) ;
35859: LD_VAR 0 1
35863: PPUSH
35864: CALL 66193 0 1
// end ;
35868: PPOPN 1
35870: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35871: LD_VAR 0 1
35875: PPUSH
35876: LD_VAR 0 2
35880: PPUSH
35881: CALL 64248 0 2
// end ;
35885: PPOPN 2
35887: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35888: LD_VAR 0 1
35892: PPUSH
35893: LD_VAR 0 2
35897: PPUSH
35898: LD_VAR 0 3
35902: PPUSH
35903: LD_VAR 0 4
35907: PPUSH
35908: LD_VAR 0 5
35912: PPUSH
35913: CALL 63868 0 5
// end ;
35917: PPOPN 5
35919: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35920: LD_VAR 0 1
35924: PPUSH
35925: CALL_OW 255
35929: PUSH
35930: LD_INT 1
35932: EQUAL
35933: IFFALSE 35950
// amConstructCounter := Inc ( amConstructCounter ) ;
35935: LD_ADDR_EXP 39
35939: PUSH
35940: LD_EXP 39
35944: PPUSH
35945: CALL 106346 0 1
35949: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35950: LD_VAR 0 1
35954: PPUSH
35955: LD_VAR 0 2
35959: PPUSH
35960: CALL 124707 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35964: LD_VAR 0 1
35968: PPUSH
35969: LD_VAR 0 2
35973: PPUSH
35974: CALL 63459 0 2
// end ;
35978: PPOPN 2
35980: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35981: LD_VAR 0 1
35985: PPUSH
35986: LD_VAR 0 2
35990: PPUSH
35991: LD_VAR 0 3
35995: PPUSH
35996: LD_VAR 0 4
36000: PPUSH
36001: CALL 63297 0 4
// end ;
36005: PPOPN 4
36007: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
36008: LD_VAR 0 1
36012: PPUSH
36013: LD_VAR 0 2
36017: PPUSH
36018: LD_VAR 0 3
36022: PPUSH
36023: CALL 63072 0 3
// end ;
36027: PPOPN 3
36029: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
36030: LD_VAR 0 1
36034: PPUSH
36035: LD_VAR 0 2
36039: PPUSH
36040: CALL 62957 0 2
// end ;
36044: PPOPN 2
36046: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
36047: LD_VAR 0 1
36051: PPUSH
36052: LD_VAR 0 2
36056: PPUSH
36057: CALL 67179 0 2
// end ;
36061: PPOPN 2
36063: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
36064: LD_VAR 0 1
36068: PPUSH
36069: CALL_OW 255
36073: PUSH
36074: LD_INT 4
36076: EQUAL
36077: PUSH
36078: LD_VAR 0 1
36082: PUSH
36083: LD_EXP 18
36087: PUSH
36088: LD_INT 1
36090: ARRAY
36091: IN
36092: AND
36093: PUSH
36094: LD_EXP 19
36098: AND
36099: IFFALSE 36118
// begin ComMoveXY ( driver , 61 , 93 ) ;
36101: LD_VAR 0 1
36105: PPUSH
36106: LD_INT 61
36108: PPUSH
36109: LD_INT 93
36111: PPUSH
36112: CALL_OW 111
// exit ;
36116: GO 36142
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
36118: LD_VAR 0 1
36122: PPUSH
36123: LD_VAR 0 2
36127: PPUSH
36128: LD_VAR 0 3
36132: PPUSH
36133: LD_VAR 0 4
36137: PPUSH
36138: CALL 67395 0 4
// end ;
36142: PPOPN 4
36144: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
36145: LD_VAR 0 1
36149: PPUSH
36150: LD_VAR 0 2
36154: PPUSH
36155: CALL 62766 0 2
// end ;
36159: PPOPN 2
36161: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
36162: LD_VAR 0 1
36166: PPUSH
36167: CALL 124691 0 1
// end ; end_of_file
36171: PPOPN 1
36173: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
36174: LD_EXP 15
36178: PUSH
36179: LD_INT 2
36181: EQUAL
36182: IFFALSE 36685
36184: GO 36186
36186: DISABLE
36187: LD_INT 0
36189: PPUSH
36190: PPUSH
// begin time := 0 0$35 ;
36191: LD_ADDR_VAR 0 2
36195: PUSH
36196: LD_INT 1225
36198: ST_TO_ADDR
// repeat wait ( time ) ;
36199: LD_VAR 0 2
36203: PPUSH
36204: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
36208: LD_INT 1
36210: PPUSH
36211: LD_INT 5
36213: PPUSH
36214: CALL_OW 12
36218: PPUSH
36219: LD_INT 106
36221: PPUSH
36222: LD_INT 150
36224: PPUSH
36225: LD_INT 19
36227: PPUSH
36228: LD_INT 1
36230: PPUSH
36231: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
36235: LD_INT 455
36237: PPUSH
36238: LD_INT 770
36240: PPUSH
36241: CALL_OW 12
36245: PPUSH
36246: CALL_OW 67
// if Prob ( 50 ) then
36250: LD_INT 50
36252: PPUSH
36253: CALL_OW 13
36257: IFFALSE 36286
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
36259: LD_INT 1
36261: PPUSH
36262: LD_INT 5
36264: PPUSH
36265: CALL_OW 12
36269: PPUSH
36270: LD_INT 62
36272: PPUSH
36273: LD_INT 108
36275: PPUSH
36276: LD_INT 10
36278: PPUSH
36279: LD_INT 1
36281: PPUSH
36282: CALL_OW 56
// until missionStage > 4 ;
36286: LD_EXP 15
36290: PUSH
36291: LD_INT 4
36293: GREATER
36294: IFFALSE 36199
// repeat wait ( 0 0$1 ) ;
36296: LD_INT 35
36298: PPUSH
36299: CALL_OW 67
// until missionStage = 6 ;
36303: LD_EXP 15
36307: PUSH
36308: LD_INT 6
36310: EQUAL
36311: IFFALSE 36296
// time := 0 0$20 ;
36313: LD_ADDR_VAR 0 2
36317: PUSH
36318: LD_INT 700
36320: ST_TO_ADDR
// repeat wait ( time ) ;
36321: LD_VAR 0 2
36325: PPUSH
36326: CALL_OW 67
// if Prob ( 90 ) then
36330: LD_INT 90
36332: PPUSH
36333: CALL_OW 13
36337: IFFALSE 36380
// begin time := time + 0 0$2 ;
36339: LD_ADDR_VAR 0 2
36343: PUSH
36344: LD_VAR 0 2
36348: PUSH
36349: LD_INT 70
36351: PLUS
36352: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36353: LD_INT 1
36355: PPUSH
36356: LD_INT 5
36358: PPUSH
36359: CALL_OW 12
36363: PPUSH
36364: LD_INT 106
36366: PPUSH
36367: LD_INT 89
36369: PPUSH
36370: LD_INT 45
36372: PPUSH
36373: LD_INT 1
36375: PPUSH
36376: CALL_OW 56
// end ; if Prob ( 45 ) then
36380: LD_INT 45
36382: PPUSH
36383: CALL_OW 13
36387: IFFALSE 36443
// begin for i := 1 to 4 do
36389: LD_ADDR_VAR 0 1
36393: PUSH
36394: DOUBLE
36395: LD_INT 1
36397: DEC
36398: ST_TO_ADDR
36399: LD_INT 4
36401: PUSH
36402: FOR_TO
36403: IFFALSE 36441
// begin wait ( 0 0$5 ) ;
36405: LD_INT 175
36407: PPUSH
36408: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36412: LD_INT 1
36414: PPUSH
36415: LD_INT 5
36417: PPUSH
36418: CALL_OW 12
36422: PPUSH
36423: LD_INT 113
36425: PPUSH
36426: LD_INT 117
36428: PPUSH
36429: LD_INT 25
36431: PPUSH
36432: LD_INT 1
36434: PPUSH
36435: CALL_OW 56
// end ;
36439: GO 36402
36441: POP
36442: POP
// end ; if Prob ( 40 ) then
36443: LD_INT 40
36445: PPUSH
36446: CALL_OW 13
36450: IFFALSE 36496
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36452: LD_INT 385
36454: PPUSH
36455: LD_INT 945
36457: PPUSH
36458: CALL_OW 12
36462: PPUSH
36463: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36467: LD_INT 1
36469: PPUSH
36470: LD_INT 5
36472: PPUSH
36473: CALL_OW 12
36477: PPUSH
36478: LD_INT 21
36480: PPUSH
36481: LD_INT 26
36483: PPUSH
36484: LD_INT 12
36486: PPUSH
36487: LD_INT 1
36489: PPUSH
36490: CALL_OW 56
// end else
36494: GO 36532
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36496: LD_INT 700
36498: PPUSH
36499: LD_INT 1225
36501: PPUSH
36502: CALL_OW 12
36506: PPUSH
36507: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36511: LD_INT 1
36513: PPUSH
36514: LD_INT 5
36516: PPUSH
36517: CALL_OW 12
36521: PPUSH
36522: LD_INT 16
36524: PPUSH
36525: LD_INT 1
36527: PPUSH
36528: CALL_OW 55
// end ; if Prob ( 50 ) then
36532: LD_INT 50
36534: PPUSH
36535: CALL_OW 13
36539: IFFALSE 36585
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36541: LD_INT 700
36543: PPUSH
36544: LD_INT 1050
36546: PPUSH
36547: CALL_OW 12
36551: PPUSH
36552: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36556: LD_INT 1
36558: PPUSH
36559: LD_INT 5
36561: PPUSH
36562: CALL_OW 12
36566: PPUSH
36567: LD_INT 168
36569: PPUSH
36570: LD_INT 168
36572: PPUSH
36573: LD_INT 16
36575: PPUSH
36576: LD_INT 1
36578: PPUSH
36579: CALL_OW 56
// end else
36583: GO 36621
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36585: LD_INT 350
36587: PPUSH
36588: LD_INT 525
36590: PPUSH
36591: CALL_OW 12
36595: PPUSH
36596: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36600: LD_INT 1
36602: PPUSH
36603: LD_INT 5
36605: PPUSH
36606: CALL_OW 12
36610: PPUSH
36611: LD_INT 15
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36621: LD_INT 175
36623: PPUSH
36624: LD_INT 315
36626: PPUSH
36627: CALL_OW 12
36631: PPUSH
36632: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36636: LD_INT 1
36638: PPUSH
36639: LD_INT 5
36641: PPUSH
36642: CALL_OW 12
36646: PPUSH
36647: LD_INT 103
36649: PPUSH
36650: LD_INT 140
36652: PPUSH
36653: LD_INT 20
36655: PPUSH
36656: LD_INT 1
36658: PPUSH
36659: CALL_OW 56
// if time > 1 1$10 then
36663: LD_VAR 0 2
36667: PUSH
36668: LD_INT 2450
36670: GREATER
36671: IFFALSE 36681
// time := 0 0$30 ;
36673: LD_ADDR_VAR 0 2
36677: PUSH
36678: LD_INT 1050
36680: ST_TO_ADDR
// until false ;
36681: LD_INT 0
36683: IFFALSE 36321
// end ; end_of_file
36685: PPOPN 2
36687: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36688: LD_EXP 13
36692: PUSH
36693: LD_EXP 15
36697: PUSH
36698: LD_INT 6
36700: GREATEREQUAL
36701: AND
36702: IFFALSE 36739
36704: GO 36706
36706: DISABLE
// begin enable ;
36707: ENABLE
// missionTime := missionTime + 0 0$1 ;
36708: LD_ADDR_EXP 14
36712: PUSH
36713: LD_EXP 14
36717: PUSH
36718: LD_INT 35
36720: PLUS
36721: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36722: LD_ADDR_OWVAR 47
36726: PUSH
36727: LD_STRING #Am15-1
36729: PUSH
36730: LD_EXP 14
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: ST_TO_ADDR
// end ; end_of_file
36739: END
// export function InitNature ; begin
36740: LD_INT 0
36742: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36743: LD_INT 3
36745: PPUSH
36746: LD_INT 3
36748: PPUSH
36749: LD_INT 2
36751: PPUSH
36752: LD_INT 1
36754: PPUSH
36755: LD_INT 1
36757: PPUSH
36758: LD_INT 0
36760: PPUSH
36761: LD_INT 0
36763: PPUSH
36764: LD_INT 20
36766: PPUSH
36767: LD_INT 0
36769: PPUSH
36770: CALL 101667 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36774: LD_INT 2
36776: PPUSH
36777: LD_INT 1
36779: PPUSH
36780: LD_INT 1
36782: PPUSH
36783: LD_INT 1
36785: PPUSH
36786: LD_INT 1
36788: PPUSH
36789: LD_INT 0
36791: PPUSH
36792: LD_INT 0
36794: PPUSH
36795: LD_INT 21
36797: PPUSH
36798: LD_INT 0
36800: PPUSH
36801: CALL 101667 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36805: LD_INT 4
36807: PPUSH
36808: LD_INT 1
36810: PPUSH
36811: LD_INT 2
36813: PPUSH
36814: LD_INT 4
36816: PPUSH
36817: LD_INT 2
36819: PPUSH
36820: LD_INT 1
36822: PPUSH
36823: LD_INT 0
36825: PPUSH
36826: LD_INT 22
36828: PPUSH
36829: LD_INT 0
36831: PPUSH
36832: CALL 101667 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36836: LD_INT 0
36838: PPUSH
36839: LD_INT 0
36841: PPUSH
36842: LD_INT 0
36844: PPUSH
36845: LD_INT 0
36847: PPUSH
36848: LD_INT 0
36850: PPUSH
36851: LD_INT 0
36853: PPUSH
36854: LD_INT 9
36856: PPUSH
36857: LD_INT 0
36859: PPUSH
36860: LD_INT 23
36862: PPUSH
36863: CALL 101667 0 9
// end ; end_of_file
36867: LD_VAR 0 1
36871: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
36872: LD_INT 0
36874: PPUSH
36875: PPUSH
// skirmish := false ;
36876: LD_ADDR_EXP 98
36880: PUSH
36881: LD_INT 0
36883: ST_TO_ADDR
// debug_mc := false ;
36884: LD_ADDR_EXP 99
36888: PUSH
36889: LD_INT 0
36891: ST_TO_ADDR
// mc_bases := [ ] ;
36892: LD_ADDR_EXP 100
36896: PUSH
36897: EMPTY
36898: ST_TO_ADDR
// mc_sides := [ ] ;
36899: LD_ADDR_EXP 126
36903: PUSH
36904: EMPTY
36905: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36906: LD_ADDR_EXP 101
36910: PUSH
36911: EMPTY
36912: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36913: LD_ADDR_EXP 102
36917: PUSH
36918: EMPTY
36919: ST_TO_ADDR
// mc_need_heal := [ ] ;
36920: LD_ADDR_EXP 103
36924: PUSH
36925: EMPTY
36926: ST_TO_ADDR
// mc_healers := [ ] ;
36927: LD_ADDR_EXP 104
36931: PUSH
36932: EMPTY
36933: ST_TO_ADDR
// mc_build_list := [ ] ;
36934: LD_ADDR_EXP 105
36938: PUSH
36939: EMPTY
36940: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36941: LD_ADDR_EXP 132
36945: PUSH
36946: EMPTY
36947: ST_TO_ADDR
// mc_builders := [ ] ;
36948: LD_ADDR_EXP 106
36952: PUSH
36953: EMPTY
36954: ST_TO_ADDR
// mc_construct_list := [ ] ;
36955: LD_ADDR_EXP 107
36959: PUSH
36960: EMPTY
36961: ST_TO_ADDR
// mc_turret_list := [ ] ;
36962: LD_ADDR_EXP 108
36966: PUSH
36967: EMPTY
36968: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36969: LD_ADDR_EXP 109
36973: PUSH
36974: EMPTY
36975: ST_TO_ADDR
// mc_miners := [ ] ;
36976: LD_ADDR_EXP 114
36980: PUSH
36981: EMPTY
36982: ST_TO_ADDR
// mc_mines := [ ] ;
36983: LD_ADDR_EXP 113
36987: PUSH
36988: EMPTY
36989: ST_TO_ADDR
// mc_minefields := [ ] ;
36990: LD_ADDR_EXP 115
36994: PUSH
36995: EMPTY
36996: ST_TO_ADDR
// mc_crates := [ ] ;
36997: LD_ADDR_EXP 116
37001: PUSH
37002: EMPTY
37003: ST_TO_ADDR
// mc_crates_collector := [ ] ;
37004: LD_ADDR_EXP 117
37008: PUSH
37009: EMPTY
37010: ST_TO_ADDR
// mc_crates_area := [ ] ;
37011: LD_ADDR_EXP 118
37015: PUSH
37016: EMPTY
37017: ST_TO_ADDR
// mc_vehicles := [ ] ;
37018: LD_ADDR_EXP 119
37022: PUSH
37023: EMPTY
37024: ST_TO_ADDR
// mc_attack := [ ] ;
37025: LD_ADDR_EXP 120
37029: PUSH
37030: EMPTY
37031: ST_TO_ADDR
// mc_produce := [ ] ;
37032: LD_ADDR_EXP 121
37036: PUSH
37037: EMPTY
37038: ST_TO_ADDR
// mc_defender := [ ] ;
37039: LD_ADDR_EXP 122
37043: PUSH
37044: EMPTY
37045: ST_TO_ADDR
// mc_parking := [ ] ;
37046: LD_ADDR_EXP 124
37050: PUSH
37051: EMPTY
37052: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
37053: LD_ADDR_EXP 110
37057: PUSH
37058: EMPTY
37059: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
37060: LD_ADDR_EXP 112
37064: PUSH
37065: EMPTY
37066: ST_TO_ADDR
// mc_scan := [ ] ;
37067: LD_ADDR_EXP 123
37071: PUSH
37072: EMPTY
37073: ST_TO_ADDR
// mc_scan_area := [ ] ;
37074: LD_ADDR_EXP 125
37078: PUSH
37079: EMPTY
37080: ST_TO_ADDR
// mc_tech := [ ] ;
37081: LD_ADDR_EXP 127
37085: PUSH
37086: EMPTY
37087: ST_TO_ADDR
// mc_class := [ ] ;
37088: LD_ADDR_EXP 141
37092: PUSH
37093: EMPTY
37094: ST_TO_ADDR
// mc_class_case_use := [ ] ;
37095: LD_ADDR_EXP 142
37099: PUSH
37100: EMPTY
37101: ST_TO_ADDR
// mc_is_defending := [ ] ;
37102: LD_ADDR_EXP 143
37106: PUSH
37107: EMPTY
37108: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
37109: LD_ADDR_EXP 134
37113: PUSH
37114: EMPTY
37115: ST_TO_ADDR
// end ;
37116: LD_VAR 0 1
37120: RET
// export function MC_Kill ( base ) ; begin
37121: LD_INT 0
37123: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
37124: LD_ADDR_EXP 100
37128: PUSH
37129: LD_EXP 100
37133: PPUSH
37134: LD_VAR 0 1
37138: PPUSH
37139: EMPTY
37140: PPUSH
37141: CALL_OW 1
37145: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37146: LD_ADDR_EXP 101
37150: PUSH
37151: LD_EXP 101
37155: PPUSH
37156: LD_VAR 0 1
37160: PPUSH
37161: EMPTY
37162: PPUSH
37163: CALL_OW 1
37167: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37168: LD_ADDR_EXP 102
37172: PUSH
37173: LD_EXP 102
37177: PPUSH
37178: LD_VAR 0 1
37182: PPUSH
37183: EMPTY
37184: PPUSH
37185: CALL_OW 1
37189: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37190: LD_ADDR_EXP 103
37194: PUSH
37195: LD_EXP 103
37199: PPUSH
37200: LD_VAR 0 1
37204: PPUSH
37205: EMPTY
37206: PPUSH
37207: CALL_OW 1
37211: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37212: LD_ADDR_EXP 104
37216: PUSH
37217: LD_EXP 104
37221: PPUSH
37222: LD_VAR 0 1
37226: PPUSH
37227: EMPTY
37228: PPUSH
37229: CALL_OW 1
37233: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37234: LD_ADDR_EXP 105
37238: PUSH
37239: LD_EXP 105
37243: PPUSH
37244: LD_VAR 0 1
37248: PPUSH
37249: EMPTY
37250: PPUSH
37251: CALL_OW 1
37255: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37256: LD_ADDR_EXP 106
37260: PUSH
37261: LD_EXP 106
37265: PPUSH
37266: LD_VAR 0 1
37270: PPUSH
37271: EMPTY
37272: PPUSH
37273: CALL_OW 1
37277: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37278: LD_ADDR_EXP 107
37282: PUSH
37283: LD_EXP 107
37287: PPUSH
37288: LD_VAR 0 1
37292: PPUSH
37293: EMPTY
37294: PPUSH
37295: CALL_OW 1
37299: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37300: LD_ADDR_EXP 108
37304: PUSH
37305: LD_EXP 108
37309: PPUSH
37310: LD_VAR 0 1
37314: PPUSH
37315: EMPTY
37316: PPUSH
37317: CALL_OW 1
37321: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37322: LD_ADDR_EXP 109
37326: PUSH
37327: LD_EXP 109
37331: PPUSH
37332: LD_VAR 0 1
37336: PPUSH
37337: EMPTY
37338: PPUSH
37339: CALL_OW 1
37343: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37344: LD_ADDR_EXP 110
37348: PUSH
37349: LD_EXP 110
37353: PPUSH
37354: LD_VAR 0 1
37358: PPUSH
37359: EMPTY
37360: PPUSH
37361: CALL_OW 1
37365: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37366: LD_ADDR_EXP 111
37370: PUSH
37371: LD_EXP 111
37375: PPUSH
37376: LD_VAR 0 1
37380: PPUSH
37381: LD_INT 0
37383: PPUSH
37384: CALL_OW 1
37388: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37389: LD_ADDR_EXP 112
37393: PUSH
37394: LD_EXP 112
37398: PPUSH
37399: LD_VAR 0 1
37403: PPUSH
37404: EMPTY
37405: PPUSH
37406: CALL_OW 1
37410: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37411: LD_ADDR_EXP 113
37415: PUSH
37416: LD_EXP 113
37420: PPUSH
37421: LD_VAR 0 1
37425: PPUSH
37426: EMPTY
37427: PPUSH
37428: CALL_OW 1
37432: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37433: LD_ADDR_EXP 114
37437: PUSH
37438: LD_EXP 114
37442: PPUSH
37443: LD_VAR 0 1
37447: PPUSH
37448: EMPTY
37449: PPUSH
37450: CALL_OW 1
37454: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37455: LD_ADDR_EXP 115
37459: PUSH
37460: LD_EXP 115
37464: PPUSH
37465: LD_VAR 0 1
37469: PPUSH
37470: EMPTY
37471: PPUSH
37472: CALL_OW 1
37476: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37477: LD_ADDR_EXP 116
37481: PUSH
37482: LD_EXP 116
37486: PPUSH
37487: LD_VAR 0 1
37491: PPUSH
37492: EMPTY
37493: PPUSH
37494: CALL_OW 1
37498: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37499: LD_ADDR_EXP 117
37503: PUSH
37504: LD_EXP 117
37508: PPUSH
37509: LD_VAR 0 1
37513: PPUSH
37514: EMPTY
37515: PPUSH
37516: CALL_OW 1
37520: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37521: LD_ADDR_EXP 118
37525: PUSH
37526: LD_EXP 118
37530: PPUSH
37531: LD_VAR 0 1
37535: PPUSH
37536: EMPTY
37537: PPUSH
37538: CALL_OW 1
37542: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37543: LD_ADDR_EXP 119
37547: PUSH
37548: LD_EXP 119
37552: PPUSH
37553: LD_VAR 0 1
37557: PPUSH
37558: EMPTY
37559: PPUSH
37560: CALL_OW 1
37564: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37565: LD_ADDR_EXP 120
37569: PUSH
37570: LD_EXP 120
37574: PPUSH
37575: LD_VAR 0 1
37579: PPUSH
37580: EMPTY
37581: PPUSH
37582: CALL_OW 1
37586: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37587: LD_ADDR_EXP 121
37591: PUSH
37592: LD_EXP 121
37596: PPUSH
37597: LD_VAR 0 1
37601: PPUSH
37602: EMPTY
37603: PPUSH
37604: CALL_OW 1
37608: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37609: LD_ADDR_EXP 122
37613: PUSH
37614: LD_EXP 122
37618: PPUSH
37619: LD_VAR 0 1
37623: PPUSH
37624: EMPTY
37625: PPUSH
37626: CALL_OW 1
37630: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37631: LD_ADDR_EXP 123
37635: PUSH
37636: LD_EXP 123
37640: PPUSH
37641: LD_VAR 0 1
37645: PPUSH
37646: EMPTY
37647: PPUSH
37648: CALL_OW 1
37652: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37653: LD_ADDR_EXP 124
37657: PUSH
37658: LD_EXP 124
37662: PPUSH
37663: LD_VAR 0 1
37667: PPUSH
37668: EMPTY
37669: PPUSH
37670: CALL_OW 1
37674: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37675: LD_ADDR_EXP 125
37679: PUSH
37680: LD_EXP 125
37684: PPUSH
37685: LD_VAR 0 1
37689: PPUSH
37690: EMPTY
37691: PPUSH
37692: CALL_OW 1
37696: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37697: LD_ADDR_EXP 127
37701: PUSH
37702: LD_EXP 127
37706: PPUSH
37707: LD_VAR 0 1
37711: PPUSH
37712: EMPTY
37713: PPUSH
37714: CALL_OW 1
37718: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37719: LD_ADDR_EXP 129
37723: PUSH
37724: LD_EXP 129
37728: PPUSH
37729: LD_VAR 0 1
37733: PPUSH
37734: EMPTY
37735: PPUSH
37736: CALL_OW 1
37740: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37741: LD_ADDR_EXP 130
37745: PUSH
37746: LD_EXP 130
37750: PPUSH
37751: LD_VAR 0 1
37755: PPUSH
37756: EMPTY
37757: PPUSH
37758: CALL_OW 1
37762: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37763: LD_ADDR_EXP 131
37767: PUSH
37768: LD_EXP 131
37772: PPUSH
37773: LD_VAR 0 1
37777: PPUSH
37778: EMPTY
37779: PPUSH
37780: CALL_OW 1
37784: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37785: LD_ADDR_EXP 132
37789: PUSH
37790: LD_EXP 132
37794: PPUSH
37795: LD_VAR 0 1
37799: PPUSH
37800: EMPTY
37801: PPUSH
37802: CALL_OW 1
37806: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37807: LD_ADDR_EXP 133
37811: PUSH
37812: LD_EXP 133
37816: PPUSH
37817: LD_VAR 0 1
37821: PPUSH
37822: EMPTY
37823: PPUSH
37824: CALL_OW 1
37828: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37829: LD_ADDR_EXP 134
37833: PUSH
37834: LD_EXP 134
37838: PPUSH
37839: LD_VAR 0 1
37843: PPUSH
37844: EMPTY
37845: PPUSH
37846: CALL_OW 1
37850: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37851: LD_ADDR_EXP 135
37855: PUSH
37856: LD_EXP 135
37860: PPUSH
37861: LD_VAR 0 1
37865: PPUSH
37866: EMPTY
37867: PPUSH
37868: CALL_OW 1
37872: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37873: LD_ADDR_EXP 136
37877: PUSH
37878: LD_EXP 136
37882: PPUSH
37883: LD_VAR 0 1
37887: PPUSH
37888: EMPTY
37889: PPUSH
37890: CALL_OW 1
37894: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37895: LD_ADDR_EXP 137
37899: PUSH
37900: LD_EXP 137
37904: PPUSH
37905: LD_VAR 0 1
37909: PPUSH
37910: EMPTY
37911: PPUSH
37912: CALL_OW 1
37916: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37917: LD_ADDR_EXP 138
37921: PUSH
37922: LD_EXP 138
37926: PPUSH
37927: LD_VAR 0 1
37931: PPUSH
37932: EMPTY
37933: PPUSH
37934: CALL_OW 1
37938: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37939: LD_ADDR_EXP 139
37943: PUSH
37944: LD_EXP 139
37948: PPUSH
37949: LD_VAR 0 1
37953: PPUSH
37954: EMPTY
37955: PPUSH
37956: CALL_OW 1
37960: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37961: LD_ADDR_EXP 140
37965: PUSH
37966: LD_EXP 140
37970: PPUSH
37971: LD_VAR 0 1
37975: PPUSH
37976: EMPTY
37977: PPUSH
37978: CALL_OW 1
37982: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37983: LD_ADDR_EXP 141
37987: PUSH
37988: LD_EXP 141
37992: PPUSH
37993: LD_VAR 0 1
37997: PPUSH
37998: EMPTY
37999: PPUSH
38000: CALL_OW 1
38004: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38005: LD_ADDR_EXP 142
38009: PUSH
38010: LD_EXP 142
38014: PPUSH
38015: LD_VAR 0 1
38019: PPUSH
38020: LD_INT 0
38022: PPUSH
38023: CALL_OW 1
38027: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38028: LD_ADDR_EXP 143
38032: PUSH
38033: LD_EXP 143
38037: PPUSH
38038: LD_VAR 0 1
38042: PPUSH
38043: LD_INT 0
38045: PPUSH
38046: CALL_OW 1
38050: ST_TO_ADDR
// end ;
38051: LD_VAR 0 2
38055: RET
// export function MC_Add ( side , units ) ; var base ; begin
38056: LD_INT 0
38058: PPUSH
38059: PPUSH
// base := mc_bases + 1 ;
38060: LD_ADDR_VAR 0 4
38064: PUSH
38065: LD_EXP 100
38069: PUSH
38070: LD_INT 1
38072: PLUS
38073: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
38074: LD_ADDR_EXP 126
38078: PUSH
38079: LD_EXP 126
38083: PPUSH
38084: LD_VAR 0 4
38088: PPUSH
38089: LD_VAR 0 1
38093: PPUSH
38094: CALL_OW 1
38098: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
38099: LD_ADDR_EXP 100
38103: PUSH
38104: LD_EXP 100
38108: PPUSH
38109: LD_VAR 0 4
38113: PPUSH
38114: LD_VAR 0 2
38118: PPUSH
38119: CALL_OW 1
38123: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38124: LD_ADDR_EXP 101
38128: PUSH
38129: LD_EXP 101
38133: PPUSH
38134: LD_VAR 0 4
38138: PPUSH
38139: EMPTY
38140: PPUSH
38141: CALL_OW 1
38145: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38146: LD_ADDR_EXP 102
38150: PUSH
38151: LD_EXP 102
38155: PPUSH
38156: LD_VAR 0 4
38160: PPUSH
38161: EMPTY
38162: PPUSH
38163: CALL_OW 1
38167: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38168: LD_ADDR_EXP 103
38172: PUSH
38173: LD_EXP 103
38177: PPUSH
38178: LD_VAR 0 4
38182: PPUSH
38183: EMPTY
38184: PPUSH
38185: CALL_OW 1
38189: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38190: LD_ADDR_EXP 104
38194: PUSH
38195: LD_EXP 104
38199: PPUSH
38200: LD_VAR 0 4
38204: PPUSH
38205: EMPTY
38206: PPUSH
38207: CALL_OW 1
38211: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38212: LD_ADDR_EXP 105
38216: PUSH
38217: LD_EXP 105
38221: PPUSH
38222: LD_VAR 0 4
38226: PPUSH
38227: EMPTY
38228: PPUSH
38229: CALL_OW 1
38233: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38234: LD_ADDR_EXP 106
38238: PUSH
38239: LD_EXP 106
38243: PPUSH
38244: LD_VAR 0 4
38248: PPUSH
38249: EMPTY
38250: PPUSH
38251: CALL_OW 1
38255: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38256: LD_ADDR_EXP 107
38260: PUSH
38261: LD_EXP 107
38265: PPUSH
38266: LD_VAR 0 4
38270: PPUSH
38271: EMPTY
38272: PPUSH
38273: CALL_OW 1
38277: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38278: LD_ADDR_EXP 108
38282: PUSH
38283: LD_EXP 108
38287: PPUSH
38288: LD_VAR 0 4
38292: PPUSH
38293: EMPTY
38294: PPUSH
38295: CALL_OW 1
38299: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38300: LD_ADDR_EXP 109
38304: PUSH
38305: LD_EXP 109
38309: PPUSH
38310: LD_VAR 0 4
38314: PPUSH
38315: EMPTY
38316: PPUSH
38317: CALL_OW 1
38321: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38322: LD_ADDR_EXP 110
38326: PUSH
38327: LD_EXP 110
38331: PPUSH
38332: LD_VAR 0 4
38336: PPUSH
38337: EMPTY
38338: PPUSH
38339: CALL_OW 1
38343: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38344: LD_ADDR_EXP 111
38348: PUSH
38349: LD_EXP 111
38353: PPUSH
38354: LD_VAR 0 4
38358: PPUSH
38359: LD_INT 0
38361: PPUSH
38362: CALL_OW 1
38366: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38367: LD_ADDR_EXP 112
38371: PUSH
38372: LD_EXP 112
38376: PPUSH
38377: LD_VAR 0 4
38381: PPUSH
38382: EMPTY
38383: PPUSH
38384: CALL_OW 1
38388: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38389: LD_ADDR_EXP 113
38393: PUSH
38394: LD_EXP 113
38398: PPUSH
38399: LD_VAR 0 4
38403: PPUSH
38404: EMPTY
38405: PPUSH
38406: CALL_OW 1
38410: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38411: LD_ADDR_EXP 114
38415: PUSH
38416: LD_EXP 114
38420: PPUSH
38421: LD_VAR 0 4
38425: PPUSH
38426: EMPTY
38427: PPUSH
38428: CALL_OW 1
38432: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38433: LD_ADDR_EXP 115
38437: PUSH
38438: LD_EXP 115
38442: PPUSH
38443: LD_VAR 0 4
38447: PPUSH
38448: EMPTY
38449: PPUSH
38450: CALL_OW 1
38454: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38455: LD_ADDR_EXP 116
38459: PUSH
38460: LD_EXP 116
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: EMPTY
38471: PPUSH
38472: CALL_OW 1
38476: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38477: LD_ADDR_EXP 117
38481: PUSH
38482: LD_EXP 117
38486: PPUSH
38487: LD_VAR 0 4
38491: PPUSH
38492: EMPTY
38493: PPUSH
38494: CALL_OW 1
38498: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38499: LD_ADDR_EXP 118
38503: PUSH
38504: LD_EXP 118
38508: PPUSH
38509: LD_VAR 0 4
38513: PPUSH
38514: EMPTY
38515: PPUSH
38516: CALL_OW 1
38520: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38521: LD_ADDR_EXP 119
38525: PUSH
38526: LD_EXP 119
38530: PPUSH
38531: LD_VAR 0 4
38535: PPUSH
38536: EMPTY
38537: PPUSH
38538: CALL_OW 1
38542: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38543: LD_ADDR_EXP 120
38547: PUSH
38548: LD_EXP 120
38552: PPUSH
38553: LD_VAR 0 4
38557: PPUSH
38558: EMPTY
38559: PPUSH
38560: CALL_OW 1
38564: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38565: LD_ADDR_EXP 121
38569: PUSH
38570: LD_EXP 121
38574: PPUSH
38575: LD_VAR 0 4
38579: PPUSH
38580: EMPTY
38581: PPUSH
38582: CALL_OW 1
38586: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38587: LD_ADDR_EXP 122
38591: PUSH
38592: LD_EXP 122
38596: PPUSH
38597: LD_VAR 0 4
38601: PPUSH
38602: EMPTY
38603: PPUSH
38604: CALL_OW 1
38608: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38609: LD_ADDR_EXP 123
38613: PUSH
38614: LD_EXP 123
38618: PPUSH
38619: LD_VAR 0 4
38623: PPUSH
38624: EMPTY
38625: PPUSH
38626: CALL_OW 1
38630: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38631: LD_ADDR_EXP 124
38635: PUSH
38636: LD_EXP 124
38640: PPUSH
38641: LD_VAR 0 4
38645: PPUSH
38646: EMPTY
38647: PPUSH
38648: CALL_OW 1
38652: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38653: LD_ADDR_EXP 125
38657: PUSH
38658: LD_EXP 125
38662: PPUSH
38663: LD_VAR 0 4
38667: PPUSH
38668: EMPTY
38669: PPUSH
38670: CALL_OW 1
38674: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38675: LD_ADDR_EXP 127
38679: PUSH
38680: LD_EXP 127
38684: PPUSH
38685: LD_VAR 0 4
38689: PPUSH
38690: EMPTY
38691: PPUSH
38692: CALL_OW 1
38696: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38697: LD_ADDR_EXP 129
38701: PUSH
38702: LD_EXP 129
38706: PPUSH
38707: LD_VAR 0 4
38711: PPUSH
38712: EMPTY
38713: PPUSH
38714: CALL_OW 1
38718: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38719: LD_ADDR_EXP 130
38723: PUSH
38724: LD_EXP 130
38728: PPUSH
38729: LD_VAR 0 4
38733: PPUSH
38734: EMPTY
38735: PPUSH
38736: CALL_OW 1
38740: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38741: LD_ADDR_EXP 131
38745: PUSH
38746: LD_EXP 131
38750: PPUSH
38751: LD_VAR 0 4
38755: PPUSH
38756: EMPTY
38757: PPUSH
38758: CALL_OW 1
38762: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38763: LD_ADDR_EXP 132
38767: PUSH
38768: LD_EXP 132
38772: PPUSH
38773: LD_VAR 0 4
38777: PPUSH
38778: EMPTY
38779: PPUSH
38780: CALL_OW 1
38784: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38785: LD_ADDR_EXP 133
38789: PUSH
38790: LD_EXP 133
38794: PPUSH
38795: LD_VAR 0 4
38799: PPUSH
38800: EMPTY
38801: PPUSH
38802: CALL_OW 1
38806: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38807: LD_ADDR_EXP 134
38811: PUSH
38812: LD_EXP 134
38816: PPUSH
38817: LD_VAR 0 4
38821: PPUSH
38822: EMPTY
38823: PPUSH
38824: CALL_OW 1
38828: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38829: LD_ADDR_EXP 135
38833: PUSH
38834: LD_EXP 135
38838: PPUSH
38839: LD_VAR 0 4
38843: PPUSH
38844: EMPTY
38845: PPUSH
38846: CALL_OW 1
38850: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38851: LD_ADDR_EXP 136
38855: PUSH
38856: LD_EXP 136
38860: PPUSH
38861: LD_VAR 0 4
38865: PPUSH
38866: EMPTY
38867: PPUSH
38868: CALL_OW 1
38872: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38873: LD_ADDR_EXP 137
38877: PUSH
38878: LD_EXP 137
38882: PPUSH
38883: LD_VAR 0 4
38887: PPUSH
38888: EMPTY
38889: PPUSH
38890: CALL_OW 1
38894: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38895: LD_ADDR_EXP 138
38899: PUSH
38900: LD_EXP 138
38904: PPUSH
38905: LD_VAR 0 4
38909: PPUSH
38910: EMPTY
38911: PPUSH
38912: CALL_OW 1
38916: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38917: LD_ADDR_EXP 139
38921: PUSH
38922: LD_EXP 139
38926: PPUSH
38927: LD_VAR 0 4
38931: PPUSH
38932: EMPTY
38933: PPUSH
38934: CALL_OW 1
38938: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38939: LD_ADDR_EXP 140
38943: PUSH
38944: LD_EXP 140
38948: PPUSH
38949: LD_VAR 0 4
38953: PPUSH
38954: EMPTY
38955: PPUSH
38956: CALL_OW 1
38960: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38961: LD_ADDR_EXP 141
38965: PUSH
38966: LD_EXP 141
38970: PPUSH
38971: LD_VAR 0 4
38975: PPUSH
38976: EMPTY
38977: PPUSH
38978: CALL_OW 1
38982: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38983: LD_ADDR_EXP 142
38987: PUSH
38988: LD_EXP 142
38992: PPUSH
38993: LD_VAR 0 4
38997: PPUSH
38998: LD_INT 0
39000: PPUSH
39001: CALL_OW 1
39005: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39006: LD_ADDR_EXP 143
39010: PUSH
39011: LD_EXP 143
39015: PPUSH
39016: LD_VAR 0 4
39020: PPUSH
39021: LD_INT 0
39023: PPUSH
39024: CALL_OW 1
39028: ST_TO_ADDR
// result := base ;
39029: LD_ADDR_VAR 0 3
39033: PUSH
39034: LD_VAR 0 4
39038: ST_TO_ADDR
// end ;
39039: LD_VAR 0 3
39043: RET
// export function MC_Start ( ) ; var i ; begin
39044: LD_INT 0
39046: PPUSH
39047: PPUSH
// for i = 1 to mc_bases do
39048: LD_ADDR_VAR 0 2
39052: PUSH
39053: DOUBLE
39054: LD_INT 1
39056: DEC
39057: ST_TO_ADDR
39058: LD_EXP 100
39062: PUSH
39063: FOR_TO
39064: IFFALSE 40164
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
39066: LD_ADDR_EXP 100
39070: PUSH
39071: LD_EXP 100
39075: PPUSH
39076: LD_VAR 0 2
39080: PPUSH
39081: LD_EXP 100
39085: PUSH
39086: LD_VAR 0 2
39090: ARRAY
39091: PUSH
39092: LD_INT 0
39094: DIFF
39095: PPUSH
39096: CALL_OW 1
39100: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
39101: LD_ADDR_EXP 101
39105: PUSH
39106: LD_EXP 101
39110: PPUSH
39111: LD_VAR 0 2
39115: PPUSH
39116: EMPTY
39117: PPUSH
39118: CALL_OW 1
39122: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
39123: LD_ADDR_EXP 102
39127: PUSH
39128: LD_EXP 102
39132: PPUSH
39133: LD_VAR 0 2
39137: PPUSH
39138: EMPTY
39139: PPUSH
39140: CALL_OW 1
39144: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
39145: LD_ADDR_EXP 103
39149: PUSH
39150: LD_EXP 103
39154: PPUSH
39155: LD_VAR 0 2
39159: PPUSH
39160: EMPTY
39161: PPUSH
39162: CALL_OW 1
39166: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
39167: LD_ADDR_EXP 104
39171: PUSH
39172: LD_EXP 104
39176: PPUSH
39177: LD_VAR 0 2
39181: PPUSH
39182: EMPTY
39183: PUSH
39184: EMPTY
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PPUSH
39190: CALL_OW 1
39194: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
39195: LD_ADDR_EXP 105
39199: PUSH
39200: LD_EXP 105
39204: PPUSH
39205: LD_VAR 0 2
39209: PPUSH
39210: EMPTY
39211: PPUSH
39212: CALL_OW 1
39216: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
39217: LD_ADDR_EXP 132
39221: PUSH
39222: LD_EXP 132
39226: PPUSH
39227: LD_VAR 0 2
39231: PPUSH
39232: EMPTY
39233: PPUSH
39234: CALL_OW 1
39238: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
39239: LD_ADDR_EXP 106
39243: PUSH
39244: LD_EXP 106
39248: PPUSH
39249: LD_VAR 0 2
39253: PPUSH
39254: EMPTY
39255: PPUSH
39256: CALL_OW 1
39260: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
39261: LD_ADDR_EXP 107
39265: PUSH
39266: LD_EXP 107
39270: PPUSH
39271: LD_VAR 0 2
39275: PPUSH
39276: EMPTY
39277: PPUSH
39278: CALL_OW 1
39282: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
39283: LD_ADDR_EXP 108
39287: PUSH
39288: LD_EXP 108
39292: PPUSH
39293: LD_VAR 0 2
39297: PPUSH
39298: LD_EXP 100
39302: PUSH
39303: LD_VAR 0 2
39307: ARRAY
39308: PPUSH
39309: LD_INT 2
39311: PUSH
39312: LD_INT 30
39314: PUSH
39315: LD_INT 32
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 30
39324: PUSH
39325: LD_INT 33
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: LIST
39336: PPUSH
39337: CALL_OW 72
39341: PPUSH
39342: CALL_OW 1
39346: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39347: LD_ADDR_EXP 109
39351: PUSH
39352: LD_EXP 109
39356: PPUSH
39357: LD_VAR 0 2
39361: PPUSH
39362: LD_EXP 100
39366: PUSH
39367: LD_VAR 0 2
39371: ARRAY
39372: PPUSH
39373: LD_INT 2
39375: PUSH
39376: LD_INT 30
39378: PUSH
39379: LD_INT 32
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PUSH
39386: LD_INT 30
39388: PUSH
39389: LD_INT 31
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 58
39403: PUSH
39404: EMPTY
39405: LIST
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PPUSH
39411: CALL_OW 72
39415: PPUSH
39416: CALL_OW 1
39420: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39421: LD_ADDR_EXP 110
39425: PUSH
39426: LD_EXP 110
39430: PPUSH
39431: LD_VAR 0 2
39435: PPUSH
39436: EMPTY
39437: PPUSH
39438: CALL_OW 1
39442: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39443: LD_ADDR_EXP 114
39447: PUSH
39448: LD_EXP 114
39452: PPUSH
39453: LD_VAR 0 2
39457: PPUSH
39458: EMPTY
39459: PPUSH
39460: CALL_OW 1
39464: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39465: LD_ADDR_EXP 113
39469: PUSH
39470: LD_EXP 113
39474: PPUSH
39475: LD_VAR 0 2
39479: PPUSH
39480: EMPTY
39481: PPUSH
39482: CALL_OW 1
39486: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39487: LD_ADDR_EXP 115
39491: PUSH
39492: LD_EXP 115
39496: PPUSH
39497: LD_VAR 0 2
39501: PPUSH
39502: EMPTY
39503: PPUSH
39504: CALL_OW 1
39508: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39509: LD_ADDR_EXP 116
39513: PUSH
39514: LD_EXP 116
39518: PPUSH
39519: LD_VAR 0 2
39523: PPUSH
39524: EMPTY
39525: PPUSH
39526: CALL_OW 1
39530: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39531: LD_ADDR_EXP 117
39535: PUSH
39536: LD_EXP 117
39540: PPUSH
39541: LD_VAR 0 2
39545: PPUSH
39546: EMPTY
39547: PPUSH
39548: CALL_OW 1
39552: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39553: LD_ADDR_EXP 118
39557: PUSH
39558: LD_EXP 118
39562: PPUSH
39563: LD_VAR 0 2
39567: PPUSH
39568: EMPTY
39569: PPUSH
39570: CALL_OW 1
39574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39575: LD_ADDR_EXP 119
39579: PUSH
39580: LD_EXP 119
39584: PPUSH
39585: LD_VAR 0 2
39589: PPUSH
39590: EMPTY
39591: PPUSH
39592: CALL_OW 1
39596: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39597: LD_ADDR_EXP 120
39601: PUSH
39602: LD_EXP 120
39606: PPUSH
39607: LD_VAR 0 2
39611: PPUSH
39612: EMPTY
39613: PPUSH
39614: CALL_OW 1
39618: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39619: LD_ADDR_EXP 121
39623: PUSH
39624: LD_EXP 121
39628: PPUSH
39629: LD_VAR 0 2
39633: PPUSH
39634: EMPTY
39635: PPUSH
39636: CALL_OW 1
39640: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39641: LD_ADDR_EXP 122
39645: PUSH
39646: LD_EXP 122
39650: PPUSH
39651: LD_VAR 0 2
39655: PPUSH
39656: EMPTY
39657: PPUSH
39658: CALL_OW 1
39662: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39663: LD_ADDR_EXP 111
39667: PUSH
39668: LD_EXP 111
39672: PPUSH
39673: LD_VAR 0 2
39677: PPUSH
39678: LD_INT 0
39680: PPUSH
39681: CALL_OW 1
39685: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39686: LD_ADDR_EXP 124
39690: PUSH
39691: LD_EXP 124
39695: PPUSH
39696: LD_VAR 0 2
39700: PPUSH
39701: LD_INT 0
39703: PPUSH
39704: CALL_OW 1
39708: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39709: LD_ADDR_EXP 112
39713: PUSH
39714: LD_EXP 112
39718: PPUSH
39719: LD_VAR 0 2
39723: PPUSH
39724: EMPTY
39725: PPUSH
39726: CALL_OW 1
39730: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39731: LD_ADDR_EXP 123
39735: PUSH
39736: LD_EXP 123
39740: PPUSH
39741: LD_VAR 0 2
39745: PPUSH
39746: LD_INT 0
39748: PPUSH
39749: CALL_OW 1
39753: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39754: LD_ADDR_EXP 125
39758: PUSH
39759: LD_EXP 125
39763: PPUSH
39764: LD_VAR 0 2
39768: PPUSH
39769: EMPTY
39770: PPUSH
39771: CALL_OW 1
39775: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39776: LD_ADDR_EXP 128
39780: PUSH
39781: LD_EXP 128
39785: PPUSH
39786: LD_VAR 0 2
39790: PPUSH
39791: LD_INT 0
39793: PPUSH
39794: CALL_OW 1
39798: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39799: LD_ADDR_EXP 129
39803: PUSH
39804: LD_EXP 129
39808: PPUSH
39809: LD_VAR 0 2
39813: PPUSH
39814: EMPTY
39815: PPUSH
39816: CALL_OW 1
39820: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39821: LD_ADDR_EXP 130
39825: PUSH
39826: LD_EXP 130
39830: PPUSH
39831: LD_VAR 0 2
39835: PPUSH
39836: EMPTY
39837: PPUSH
39838: CALL_OW 1
39842: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39843: LD_ADDR_EXP 131
39847: PUSH
39848: LD_EXP 131
39852: PPUSH
39853: LD_VAR 0 2
39857: PPUSH
39858: EMPTY
39859: PPUSH
39860: CALL_OW 1
39864: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39865: LD_ADDR_EXP 133
39869: PUSH
39870: LD_EXP 133
39874: PPUSH
39875: LD_VAR 0 2
39879: PPUSH
39880: LD_EXP 100
39884: PUSH
39885: LD_VAR 0 2
39889: ARRAY
39890: PPUSH
39891: LD_INT 2
39893: PUSH
39894: LD_INT 30
39896: PUSH
39897: LD_INT 6
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 30
39906: PUSH
39907: LD_INT 7
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 30
39916: PUSH
39917: LD_INT 8
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: PPUSH
39930: CALL_OW 72
39934: PPUSH
39935: CALL_OW 1
39939: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39940: LD_ADDR_EXP 134
39944: PUSH
39945: LD_EXP 134
39949: PPUSH
39950: LD_VAR 0 2
39954: PPUSH
39955: EMPTY
39956: PPUSH
39957: CALL_OW 1
39961: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39962: LD_ADDR_EXP 135
39966: PUSH
39967: LD_EXP 135
39971: PPUSH
39972: LD_VAR 0 2
39976: PPUSH
39977: EMPTY
39978: PPUSH
39979: CALL_OW 1
39983: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39984: LD_ADDR_EXP 136
39988: PUSH
39989: LD_EXP 136
39993: PPUSH
39994: LD_VAR 0 2
39998: PPUSH
39999: EMPTY
40000: PPUSH
40001: CALL_OW 1
40005: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
40006: LD_ADDR_EXP 137
40010: PUSH
40011: LD_EXP 137
40015: PPUSH
40016: LD_VAR 0 2
40020: PPUSH
40021: EMPTY
40022: PPUSH
40023: CALL_OW 1
40027: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40028: LD_ADDR_EXP 138
40032: PUSH
40033: LD_EXP 138
40037: PPUSH
40038: LD_VAR 0 2
40042: PPUSH
40043: EMPTY
40044: PPUSH
40045: CALL_OW 1
40049: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
40050: LD_ADDR_EXP 139
40054: PUSH
40055: LD_EXP 139
40059: PPUSH
40060: LD_VAR 0 2
40064: PPUSH
40065: EMPTY
40066: PPUSH
40067: CALL_OW 1
40071: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
40072: LD_ADDR_EXP 140
40076: PUSH
40077: LD_EXP 140
40081: PPUSH
40082: LD_VAR 0 2
40086: PPUSH
40087: EMPTY
40088: PPUSH
40089: CALL_OW 1
40093: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
40094: LD_ADDR_EXP 141
40098: PUSH
40099: LD_EXP 141
40103: PPUSH
40104: LD_VAR 0 2
40108: PPUSH
40109: EMPTY
40110: PPUSH
40111: CALL_OW 1
40115: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
40116: LD_ADDR_EXP 142
40120: PUSH
40121: LD_EXP 142
40125: PPUSH
40126: LD_VAR 0 2
40130: PPUSH
40131: LD_INT 0
40133: PPUSH
40134: CALL_OW 1
40138: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
40139: LD_ADDR_EXP 143
40143: PUSH
40144: LD_EXP 143
40148: PPUSH
40149: LD_VAR 0 2
40153: PPUSH
40154: LD_INT 0
40156: PPUSH
40157: CALL_OW 1
40161: ST_TO_ADDR
// end ;
40162: GO 39063
40164: POP
40165: POP
// MC_InitSides ( ) ;
40166: CALL 40452 0 0
// MC_InitResearch ( ) ;
40170: CALL 40191 0 0
// CustomInitMacro ( ) ;
40174: CALL 475 0 0
// skirmish := true ;
40178: LD_ADDR_EXP 98
40182: PUSH
40183: LD_INT 1
40185: ST_TO_ADDR
// end ;
40186: LD_VAR 0 1
40190: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
40191: LD_INT 0
40193: PPUSH
40194: PPUSH
40195: PPUSH
40196: PPUSH
40197: PPUSH
40198: PPUSH
// if not mc_bases then
40199: LD_EXP 100
40203: NOT
40204: IFFALSE 40208
// exit ;
40206: GO 40447
// for i = 1 to 8 do
40208: LD_ADDR_VAR 0 2
40212: PUSH
40213: DOUBLE
40214: LD_INT 1
40216: DEC
40217: ST_TO_ADDR
40218: LD_INT 8
40220: PUSH
40221: FOR_TO
40222: IFFALSE 40248
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
40224: LD_ADDR_EXP 127
40228: PUSH
40229: LD_EXP 127
40233: PPUSH
40234: LD_VAR 0 2
40238: PPUSH
40239: EMPTY
40240: PPUSH
40241: CALL_OW 1
40245: ST_TO_ADDR
40246: GO 40221
40248: POP
40249: POP
// tmp := [ ] ;
40250: LD_ADDR_VAR 0 5
40254: PUSH
40255: EMPTY
40256: ST_TO_ADDR
// for i = 1 to mc_sides do
40257: LD_ADDR_VAR 0 2
40261: PUSH
40262: DOUBLE
40263: LD_INT 1
40265: DEC
40266: ST_TO_ADDR
40267: LD_EXP 126
40271: PUSH
40272: FOR_TO
40273: IFFALSE 40331
// if not mc_sides [ i ] in tmp then
40275: LD_EXP 126
40279: PUSH
40280: LD_VAR 0 2
40284: ARRAY
40285: PUSH
40286: LD_VAR 0 5
40290: IN
40291: NOT
40292: IFFALSE 40329
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
40294: LD_ADDR_VAR 0 5
40298: PUSH
40299: LD_VAR 0 5
40303: PPUSH
40304: LD_VAR 0 5
40308: PUSH
40309: LD_INT 1
40311: PLUS
40312: PPUSH
40313: LD_EXP 126
40317: PUSH
40318: LD_VAR 0 2
40322: ARRAY
40323: PPUSH
40324: CALL_OW 2
40328: ST_TO_ADDR
40329: GO 40272
40331: POP
40332: POP
// if not tmp then
40333: LD_VAR 0 5
40337: NOT
40338: IFFALSE 40342
// exit ;
40340: GO 40447
// for j in tmp do
40342: LD_ADDR_VAR 0 3
40346: PUSH
40347: LD_VAR 0 5
40351: PUSH
40352: FOR_IN
40353: IFFALSE 40445
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40355: LD_ADDR_VAR 0 6
40359: PUSH
40360: LD_INT 22
40362: PUSH
40363: LD_VAR 0 3
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PPUSH
40372: CALL_OW 69
40376: ST_TO_ADDR
// if not un then
40377: LD_VAR 0 6
40381: NOT
40382: IFFALSE 40386
// continue ;
40384: GO 40352
// nation := GetNation ( un [ 1 ] ) ;
40386: LD_ADDR_VAR 0 4
40390: PUSH
40391: LD_VAR 0 6
40395: PUSH
40396: LD_INT 1
40398: ARRAY
40399: PPUSH
40400: CALL_OW 248
40404: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40405: LD_ADDR_EXP 127
40409: PUSH
40410: LD_EXP 127
40414: PPUSH
40415: LD_VAR 0 3
40419: PPUSH
40420: LD_VAR 0 3
40424: PPUSH
40425: LD_VAR 0 4
40429: PPUSH
40430: LD_INT 1
40432: PPUSH
40433: CALL 67599 0 3
40437: PPUSH
40438: CALL_OW 1
40442: ST_TO_ADDR
// end ;
40443: GO 40352
40445: POP
40446: POP
// end ;
40447: LD_VAR 0 1
40451: RET
// export function MC_InitSides ( ) ; var i ; begin
40452: LD_INT 0
40454: PPUSH
40455: PPUSH
// if not mc_bases then
40456: LD_EXP 100
40460: NOT
40461: IFFALSE 40465
// exit ;
40463: GO 40539
// for i = 1 to mc_bases do
40465: LD_ADDR_VAR 0 2
40469: PUSH
40470: DOUBLE
40471: LD_INT 1
40473: DEC
40474: ST_TO_ADDR
40475: LD_EXP 100
40479: PUSH
40480: FOR_TO
40481: IFFALSE 40537
// if mc_bases [ i ] then
40483: LD_EXP 100
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: IFFALSE 40535
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40495: LD_ADDR_EXP 126
40499: PUSH
40500: LD_EXP 126
40504: PPUSH
40505: LD_VAR 0 2
40509: PPUSH
40510: LD_EXP 100
40514: PUSH
40515: LD_VAR 0 2
40519: ARRAY
40520: PUSH
40521: LD_INT 1
40523: ARRAY
40524: PPUSH
40525: CALL_OW 255
40529: PPUSH
40530: CALL_OW 1
40534: ST_TO_ADDR
40535: GO 40480
40537: POP
40538: POP
// end ;
40539: LD_VAR 0 1
40543: RET
// every 0 0$03 trigger skirmish do
40544: LD_EXP 98
40548: IFFALSE 40702
40550: GO 40552
40552: DISABLE
// begin enable ;
40553: ENABLE
// MC_CheckBuildings ( ) ;
40554: CALL 45200 0 0
// MC_CheckPeopleLife ( ) ;
40558: CALL 45361 0 0
// RaiseSailEvent ( 100 ) ;
40562: LD_INT 100
40564: PPUSH
40565: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40569: LD_INT 103
40571: PPUSH
40572: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40576: LD_INT 104
40578: PPUSH
40579: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40583: LD_INT 105
40585: PPUSH
40586: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40590: LD_INT 106
40592: PPUSH
40593: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40597: LD_INT 107
40599: PPUSH
40600: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40604: LD_INT 108
40606: PPUSH
40607: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40611: LD_INT 109
40613: PPUSH
40614: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40618: LD_INT 110
40620: PPUSH
40621: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40625: LD_INT 111
40627: PPUSH
40628: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40632: LD_INT 112
40634: PPUSH
40635: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40639: LD_INT 113
40641: PPUSH
40642: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40646: LD_INT 120
40648: PPUSH
40649: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40653: LD_INT 121
40655: PPUSH
40656: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40660: LD_INT 122
40662: PPUSH
40663: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40667: LD_INT 123
40669: PPUSH
40670: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40674: LD_INT 124
40676: PPUSH
40677: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40681: LD_INT 125
40683: PPUSH
40684: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40688: LD_INT 126
40690: PPUSH
40691: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40695: LD_INT 200
40697: PPUSH
40698: CALL_OW 427
// end ;
40702: END
// on SailEvent ( event ) do begin if event < 100 then
40703: LD_VAR 0 1
40707: PUSH
40708: LD_INT 100
40710: LESS
40711: IFFALSE 40722
// CustomEvent ( event ) ;
40713: LD_VAR 0 1
40717: PPUSH
40718: CALL 35178 0 1
// if event = 100 then
40722: LD_VAR 0 1
40726: PUSH
40727: LD_INT 100
40729: EQUAL
40730: IFFALSE 40736
// MC_ClassManager ( ) ;
40732: CALL 41128 0 0
// if event = 101 then
40736: LD_VAR 0 1
40740: PUSH
40741: LD_INT 101
40743: EQUAL
40744: IFFALSE 40750
// MC_RepairBuildings ( ) ;
40746: CALL 45946 0 0
// if event = 102 then
40750: LD_VAR 0 1
40754: PUSH
40755: LD_INT 102
40757: EQUAL
40758: IFFALSE 40764
// MC_Heal ( ) ;
40760: CALL 46881 0 0
// if event = 103 then
40764: LD_VAR 0 1
40768: PUSH
40769: LD_INT 103
40771: EQUAL
40772: IFFALSE 40778
// MC_Build ( ) ;
40774: CALL 47303 0 0
// if event = 104 then
40778: LD_VAR 0 1
40782: PUSH
40783: LD_INT 104
40785: EQUAL
40786: IFFALSE 40792
// MC_TurretWeapon ( ) ;
40788: CALL 48937 0 0
// if event = 105 then
40792: LD_VAR 0 1
40796: PUSH
40797: LD_INT 105
40799: EQUAL
40800: IFFALSE 40806
// MC_BuildUpgrade ( ) ;
40802: CALL 48488 0 0
// if event = 106 then
40806: LD_VAR 0 1
40810: PUSH
40811: LD_INT 106
40813: EQUAL
40814: IFFALSE 40820
// MC_PlantMines ( ) ;
40816: CALL 49367 0 0
// if event = 107 then
40820: LD_VAR 0 1
40824: PUSH
40825: LD_INT 107
40827: EQUAL
40828: IFFALSE 40834
// MC_CollectCrates ( ) ;
40830: CALL 50158 0 0
// if event = 108 then
40834: LD_VAR 0 1
40838: PUSH
40839: LD_INT 108
40841: EQUAL
40842: IFFALSE 40848
// MC_LinkRemoteControl ( ) ;
40844: CALL 52008 0 0
// if event = 109 then
40848: LD_VAR 0 1
40852: PUSH
40853: LD_INT 109
40855: EQUAL
40856: IFFALSE 40862
// MC_ProduceVehicle ( ) ;
40858: CALL 52189 0 0
// if event = 110 then
40862: LD_VAR 0 1
40866: PUSH
40867: LD_INT 110
40869: EQUAL
40870: IFFALSE 40876
// MC_SendAttack ( ) ;
40872: CALL 52655 0 0
// if event = 111 then
40876: LD_VAR 0 1
40880: PUSH
40881: LD_INT 111
40883: EQUAL
40884: IFFALSE 40890
// MC_Defend ( ) ;
40886: CALL 52763 0 0
// if event = 112 then
40890: LD_VAR 0 1
40894: PUSH
40895: LD_INT 112
40897: EQUAL
40898: IFFALSE 40904
// MC_Research ( ) ;
40900: CALL 53643 0 0
// if event = 113 then
40904: LD_VAR 0 1
40908: PUSH
40909: LD_INT 113
40911: EQUAL
40912: IFFALSE 40918
// MC_MinesTrigger ( ) ;
40914: CALL 54757 0 0
// if event = 120 then
40918: LD_VAR 0 1
40922: PUSH
40923: LD_INT 120
40925: EQUAL
40926: IFFALSE 40932
// MC_RepairVehicle ( ) ;
40928: CALL 54856 0 0
// if event = 121 then
40932: LD_VAR 0 1
40936: PUSH
40937: LD_INT 121
40939: EQUAL
40940: IFFALSE 40946
// MC_TameApe ( ) ;
40942: CALL 55625 0 0
// if event = 122 then
40946: LD_VAR 0 1
40950: PUSH
40951: LD_INT 122
40953: EQUAL
40954: IFFALSE 40960
// MC_ChangeApeClass ( ) ;
40956: CALL 56454 0 0
// if event = 123 then
40960: LD_VAR 0 1
40964: PUSH
40965: LD_INT 123
40967: EQUAL
40968: IFFALSE 40974
// MC_Bazooka ( ) ;
40970: CALL 57104 0 0
// if event = 124 then
40974: LD_VAR 0 1
40978: PUSH
40979: LD_INT 124
40981: EQUAL
40982: IFFALSE 40988
// MC_TeleportExit ( ) ;
40984: CALL 57302 0 0
// if event = 125 then
40988: LD_VAR 0 1
40992: PUSH
40993: LD_INT 125
40995: EQUAL
40996: IFFALSE 41002
// MC_Deposits ( ) ;
40998: CALL 57949 0 0
// if event = 126 then
41002: LD_VAR 0 1
41006: PUSH
41007: LD_INT 126
41009: EQUAL
41010: IFFALSE 41016
// MC_RemoteDriver ( ) ;
41012: CALL 58574 0 0
// if event = 200 then
41016: LD_VAR 0 1
41020: PUSH
41021: LD_INT 200
41023: EQUAL
41024: IFFALSE 41030
// MC_Idle ( ) ;
41026: CALL 60523 0 0
// end ;
41030: PPOPN 1
41032: END
// export function MC_Reset ( base , tag ) ; var i ; begin
41033: LD_INT 0
41035: PPUSH
41036: PPUSH
// if not mc_bases [ base ] or not tag then
41037: LD_EXP 100
41041: PUSH
41042: LD_VAR 0 1
41046: ARRAY
41047: NOT
41048: PUSH
41049: LD_VAR 0 2
41053: NOT
41054: OR
41055: IFFALSE 41059
// exit ;
41057: GO 41123
// for i in mc_bases [ base ] union mc_ape [ base ] do
41059: LD_ADDR_VAR 0 4
41063: PUSH
41064: LD_EXP 100
41068: PUSH
41069: LD_VAR 0 1
41073: ARRAY
41074: PUSH
41075: LD_EXP 129
41079: PUSH
41080: LD_VAR 0 1
41084: ARRAY
41085: UNION
41086: PUSH
41087: FOR_IN
41088: IFFALSE 41121
// if GetTag ( i ) = tag then
41090: LD_VAR 0 4
41094: PPUSH
41095: CALL_OW 110
41099: PUSH
41100: LD_VAR 0 2
41104: EQUAL
41105: IFFALSE 41119
// SetTag ( i , 0 ) ;
41107: LD_VAR 0 4
41111: PPUSH
41112: LD_INT 0
41114: PPUSH
41115: CALL_OW 109
41119: GO 41087
41121: POP
41122: POP
// end ;
41123: LD_VAR 0 3
41127: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
41128: LD_INT 0
41130: PPUSH
41131: PPUSH
41132: PPUSH
41133: PPUSH
41134: PPUSH
41135: PPUSH
41136: PPUSH
41137: PPUSH
// if not mc_bases then
41138: LD_EXP 100
41142: NOT
41143: IFFALSE 41147
// exit ;
41145: GO 41605
// for i = 1 to mc_bases do
41147: LD_ADDR_VAR 0 2
41151: PUSH
41152: DOUBLE
41153: LD_INT 1
41155: DEC
41156: ST_TO_ADDR
41157: LD_EXP 100
41161: PUSH
41162: FOR_TO
41163: IFFALSE 41603
// begin tmp := MC_ClassCheckReq ( i ) ;
41165: LD_ADDR_VAR 0 4
41169: PUSH
41170: LD_VAR 0 2
41174: PPUSH
41175: CALL 41610 0 1
41179: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
41180: LD_ADDR_EXP 141
41184: PUSH
41185: LD_EXP 141
41189: PPUSH
41190: LD_VAR 0 2
41194: PPUSH
41195: LD_VAR 0 4
41199: PPUSH
41200: CALL_OW 1
41204: ST_TO_ADDR
// if not tmp then
41205: LD_VAR 0 4
41209: NOT
41210: IFFALSE 41214
// continue ;
41212: GO 41162
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
41214: LD_ADDR_VAR 0 6
41218: PUSH
41219: LD_EXP 100
41223: PUSH
41224: LD_VAR 0 2
41228: ARRAY
41229: PPUSH
41230: LD_INT 2
41232: PUSH
41233: LD_INT 30
41235: PUSH
41236: LD_INT 4
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 30
41245: PUSH
41246: LD_INT 5
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: LIST
41257: PPUSH
41258: CALL_OW 72
41262: PUSH
41263: LD_EXP 100
41267: PUSH
41268: LD_VAR 0 2
41272: ARRAY
41273: PPUSH
41274: LD_INT 2
41276: PUSH
41277: LD_INT 30
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 30
41289: PUSH
41290: LD_INT 1
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: LIST
41301: PPUSH
41302: CALL_OW 72
41306: PUSH
41307: LD_EXP 100
41311: PUSH
41312: LD_VAR 0 2
41316: ARRAY
41317: PPUSH
41318: LD_INT 30
41320: PUSH
41321: LD_INT 3
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PPUSH
41328: CALL_OW 72
41332: PUSH
41333: LD_EXP 100
41337: PUSH
41338: LD_VAR 0 2
41342: ARRAY
41343: PPUSH
41344: LD_INT 2
41346: PUSH
41347: LD_INT 30
41349: PUSH
41350: LD_INT 6
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 30
41359: PUSH
41360: LD_INT 7
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 30
41369: PUSH
41370: LD_INT 8
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL_OW 72
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: LIST
41392: LIST
41393: ST_TO_ADDR
// for j = 1 to 4 do
41394: LD_ADDR_VAR 0 3
41398: PUSH
41399: DOUBLE
41400: LD_INT 1
41402: DEC
41403: ST_TO_ADDR
41404: LD_INT 4
41406: PUSH
41407: FOR_TO
41408: IFFALSE 41599
// begin if not tmp [ j ] then
41410: LD_VAR 0 4
41414: PUSH
41415: LD_VAR 0 3
41419: ARRAY
41420: NOT
41421: IFFALSE 41425
// continue ;
41423: GO 41407
// for p in tmp [ j ] do
41425: LD_ADDR_VAR 0 5
41429: PUSH
41430: LD_VAR 0 4
41434: PUSH
41435: LD_VAR 0 3
41439: ARRAY
41440: PUSH
41441: FOR_IN
41442: IFFALSE 41595
// begin if not b [ j ] then
41444: LD_VAR 0 6
41448: PUSH
41449: LD_VAR 0 3
41453: ARRAY
41454: NOT
41455: IFFALSE 41459
// break ;
41457: GO 41595
// e := 0 ;
41459: LD_ADDR_VAR 0 7
41463: PUSH
41464: LD_INT 0
41466: ST_TO_ADDR
// for k in b [ j ] do
41467: LD_ADDR_VAR 0 8
41471: PUSH
41472: LD_VAR 0 6
41476: PUSH
41477: LD_VAR 0 3
41481: ARRAY
41482: PUSH
41483: FOR_IN
41484: IFFALSE 41511
// if IsNotFull ( k ) then
41486: LD_VAR 0 8
41490: PPUSH
41491: CALL 69752 0 1
41495: IFFALSE 41509
// begin e := k ;
41497: LD_ADDR_VAR 0 7
41501: PUSH
41502: LD_VAR 0 8
41506: ST_TO_ADDR
// break ;
41507: GO 41511
// end ;
41509: GO 41483
41511: POP
41512: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41513: LD_VAR 0 7
41517: PUSH
41518: LD_VAR 0 5
41522: PPUSH
41523: LD_VAR 0 7
41527: PPUSH
41528: CALL 103631 0 2
41532: NOT
41533: AND
41534: IFFALSE 41593
// begin if IsInUnit ( p ) then
41536: LD_VAR 0 5
41540: PPUSH
41541: CALL_OW 310
41545: IFFALSE 41556
// ComExitBuilding ( p ) ;
41547: LD_VAR 0 5
41551: PPUSH
41552: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41556: LD_VAR 0 5
41560: PPUSH
41561: LD_VAR 0 7
41565: PPUSH
41566: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41570: LD_VAR 0 5
41574: PPUSH
41575: LD_VAR 0 3
41579: PPUSH
41580: CALL_OW 183
// AddComExitBuilding ( p ) ;
41584: LD_VAR 0 5
41588: PPUSH
41589: CALL_OW 182
// end ; end ;
41593: GO 41441
41595: POP
41596: POP
// end ;
41597: GO 41407
41599: POP
41600: POP
// end ;
41601: GO 41162
41603: POP
41604: POP
// end ;
41605: LD_VAR 0 1
41609: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41610: LD_INT 0
41612: PPUSH
41613: PPUSH
41614: PPUSH
41615: PPUSH
41616: PPUSH
41617: PPUSH
41618: PPUSH
41619: PPUSH
41620: PPUSH
41621: PPUSH
41622: PPUSH
41623: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41624: LD_VAR 0 1
41628: NOT
41629: PUSH
41630: LD_EXP 100
41634: PUSH
41635: LD_VAR 0 1
41639: ARRAY
41640: NOT
41641: OR
41642: PUSH
41643: LD_EXP 100
41647: PUSH
41648: LD_VAR 0 1
41652: ARRAY
41653: PPUSH
41654: LD_INT 2
41656: PUSH
41657: LD_INT 30
41659: PUSH
41660: LD_INT 0
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 30
41669: PUSH
41670: LD_INT 1
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: LIST
41681: PPUSH
41682: CALL_OW 72
41686: NOT
41687: OR
41688: IFFALSE 41692
// exit ;
41690: GO 45195
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41692: LD_ADDR_VAR 0 4
41696: PUSH
41697: LD_EXP 100
41701: PUSH
41702: LD_VAR 0 1
41706: ARRAY
41707: PPUSH
41708: LD_INT 2
41710: PUSH
41711: LD_INT 25
41713: PUSH
41714: LD_INT 1
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 25
41723: PUSH
41724: LD_INT 2
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 25
41733: PUSH
41734: LD_INT 3
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 25
41743: PUSH
41744: LD_INT 4
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 25
41753: PUSH
41754: LD_INT 5
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 25
41763: PUSH
41764: LD_INT 8
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: LD_INT 25
41773: PUSH
41774: LD_INT 9
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: PPUSH
41791: CALL_OW 72
41795: ST_TO_ADDR
// if not tmp then
41796: LD_VAR 0 4
41800: NOT
41801: IFFALSE 41805
// exit ;
41803: GO 45195
// for i in tmp do
41805: LD_ADDR_VAR 0 3
41809: PUSH
41810: LD_VAR 0 4
41814: PUSH
41815: FOR_IN
41816: IFFALSE 41847
// if GetTag ( i ) then
41818: LD_VAR 0 3
41822: PPUSH
41823: CALL_OW 110
41827: IFFALSE 41845
// tmp := tmp diff i ;
41829: LD_ADDR_VAR 0 4
41833: PUSH
41834: LD_VAR 0 4
41838: PUSH
41839: LD_VAR 0 3
41843: DIFF
41844: ST_TO_ADDR
41845: GO 41815
41847: POP
41848: POP
// if not tmp then
41849: LD_VAR 0 4
41853: NOT
41854: IFFALSE 41858
// exit ;
41856: GO 45195
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41858: LD_ADDR_VAR 0 5
41862: PUSH
41863: LD_EXP 100
41867: PUSH
41868: LD_VAR 0 1
41872: ARRAY
41873: PPUSH
41874: LD_INT 2
41876: PUSH
41877: LD_INT 25
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 25
41889: PUSH
41890: LD_INT 5
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 25
41899: PUSH
41900: LD_INT 8
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 25
41909: PUSH
41910: LD_INT 9
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: EMPTY
41918: LIST
41919: LIST
41920: LIST
41921: LIST
41922: LIST
41923: PPUSH
41924: CALL_OW 72
41928: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41929: LD_ADDR_VAR 0 6
41933: PUSH
41934: LD_EXP 100
41938: PUSH
41939: LD_VAR 0 1
41943: ARRAY
41944: PPUSH
41945: LD_INT 25
41947: PUSH
41948: LD_INT 2
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PPUSH
41955: CALL_OW 72
41959: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41960: LD_ADDR_VAR 0 7
41964: PUSH
41965: LD_EXP 100
41969: PUSH
41970: LD_VAR 0 1
41974: ARRAY
41975: PPUSH
41976: LD_INT 25
41978: PUSH
41979: LD_INT 3
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: PPUSH
41986: CALL_OW 72
41990: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41991: LD_ADDR_VAR 0 8
41995: PUSH
41996: LD_EXP 100
42000: PUSH
42001: LD_VAR 0 1
42005: ARRAY
42006: PPUSH
42007: LD_INT 25
42009: PUSH
42010: LD_INT 4
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: PUSH
42017: LD_INT 24
42019: PUSH
42020: LD_INT 251
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PPUSH
42031: CALL_OW 72
42035: ST_TO_ADDR
// if mc_is_defending [ base ] then
42036: LD_EXP 143
42040: PUSH
42041: LD_VAR 0 1
42045: ARRAY
42046: IFFALSE 42507
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
42048: LD_ADDR_EXP 142
42052: PUSH
42053: LD_EXP 142
42057: PPUSH
42058: LD_VAR 0 1
42062: PPUSH
42063: LD_INT 4
42065: PPUSH
42066: CALL_OW 1
42070: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42071: LD_ADDR_VAR 0 12
42075: PUSH
42076: LD_EXP 100
42080: PUSH
42081: LD_VAR 0 1
42085: ARRAY
42086: PPUSH
42087: LD_INT 2
42089: PUSH
42090: LD_INT 30
42092: PUSH
42093: LD_INT 4
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 30
42102: PUSH
42103: LD_INT 5
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: LIST
42114: PPUSH
42115: CALL_OW 72
42119: ST_TO_ADDR
// if not b then
42120: LD_VAR 0 12
42124: NOT
42125: IFFALSE 42129
// exit ;
42127: GO 45195
// p := [ ] ;
42129: LD_ADDR_VAR 0 11
42133: PUSH
42134: EMPTY
42135: ST_TO_ADDR
// if sci >= 2 then
42136: LD_VAR 0 8
42140: PUSH
42141: LD_INT 2
42143: GREATEREQUAL
42144: IFFALSE 42175
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
42146: LD_ADDR_VAR 0 8
42150: PUSH
42151: LD_VAR 0 8
42155: PUSH
42156: LD_INT 1
42158: ARRAY
42159: PUSH
42160: LD_VAR 0 8
42164: PUSH
42165: LD_INT 2
42167: ARRAY
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: ST_TO_ADDR
42173: GO 42236
// if sci = 1 then
42175: LD_VAR 0 8
42179: PUSH
42180: LD_INT 1
42182: EQUAL
42183: IFFALSE 42204
// sci := [ sci [ 1 ] ] else
42185: LD_ADDR_VAR 0 8
42189: PUSH
42190: LD_VAR 0 8
42194: PUSH
42195: LD_INT 1
42197: ARRAY
42198: PUSH
42199: EMPTY
42200: LIST
42201: ST_TO_ADDR
42202: GO 42236
// if sci = 0 then
42204: LD_VAR 0 8
42208: PUSH
42209: LD_INT 0
42211: EQUAL
42212: IFFALSE 42236
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
42214: LD_ADDR_VAR 0 11
42218: PUSH
42219: LD_VAR 0 4
42223: PPUSH
42224: LD_INT 4
42226: PPUSH
42227: CALL 103494 0 2
42231: PUSH
42232: LD_INT 1
42234: ARRAY
42235: ST_TO_ADDR
// if eng > 4 then
42236: LD_VAR 0 6
42240: PUSH
42241: LD_INT 4
42243: GREATER
42244: IFFALSE 42290
// for i = eng downto 4 do
42246: LD_ADDR_VAR 0 3
42250: PUSH
42251: DOUBLE
42252: LD_VAR 0 6
42256: INC
42257: ST_TO_ADDR
42258: LD_INT 4
42260: PUSH
42261: FOR_DOWNTO
42262: IFFALSE 42288
// eng := eng diff eng [ i ] ;
42264: LD_ADDR_VAR 0 6
42268: PUSH
42269: LD_VAR 0 6
42273: PUSH
42274: LD_VAR 0 6
42278: PUSH
42279: LD_VAR 0 3
42283: ARRAY
42284: DIFF
42285: ST_TO_ADDR
42286: GO 42261
42288: POP
42289: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
42290: LD_ADDR_VAR 0 4
42294: PUSH
42295: LD_VAR 0 4
42299: PUSH
42300: LD_VAR 0 5
42304: PUSH
42305: LD_VAR 0 6
42309: UNION
42310: PUSH
42311: LD_VAR 0 7
42315: UNION
42316: PUSH
42317: LD_VAR 0 8
42321: UNION
42322: DIFF
42323: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42324: LD_ADDR_VAR 0 13
42328: PUSH
42329: LD_EXP 100
42333: PUSH
42334: LD_VAR 0 1
42338: ARRAY
42339: PPUSH
42340: LD_INT 2
42342: PUSH
42343: LD_INT 30
42345: PUSH
42346: LD_INT 32
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 30
42355: PUSH
42356: LD_INT 31
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: LIST
42367: PPUSH
42368: CALL_OW 72
42372: PUSH
42373: LD_EXP 100
42377: PUSH
42378: LD_VAR 0 1
42382: ARRAY
42383: PPUSH
42384: LD_INT 2
42386: PUSH
42387: LD_INT 30
42389: PUSH
42390: LD_INT 4
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 30
42399: PUSH
42400: LD_INT 5
42402: PUSH
42403: EMPTY
42404: LIST
42405: LIST
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: LIST
42411: PPUSH
42412: CALL_OW 72
42416: PUSH
42417: LD_INT 6
42419: MUL
42420: PLUS
42421: ST_TO_ADDR
// if bcount < tmp then
42422: LD_VAR 0 13
42426: PUSH
42427: LD_VAR 0 4
42431: LESS
42432: IFFALSE 42478
// for i = tmp downto bcount do
42434: LD_ADDR_VAR 0 3
42438: PUSH
42439: DOUBLE
42440: LD_VAR 0 4
42444: INC
42445: ST_TO_ADDR
42446: LD_VAR 0 13
42450: PUSH
42451: FOR_DOWNTO
42452: IFFALSE 42476
// tmp := Delete ( tmp , tmp ) ;
42454: LD_ADDR_VAR 0 4
42458: PUSH
42459: LD_VAR 0 4
42463: PPUSH
42464: LD_VAR 0 4
42468: PPUSH
42469: CALL_OW 3
42473: ST_TO_ADDR
42474: GO 42451
42476: POP
42477: POP
// result := [ tmp , 0 , 0 , p ] ;
42478: LD_ADDR_VAR 0 2
42482: PUSH
42483: LD_VAR 0 4
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: LD_INT 0
42493: PUSH
42494: LD_VAR 0 11
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: ST_TO_ADDR
// exit ;
42505: GO 45195
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42507: LD_EXP 100
42511: PUSH
42512: LD_VAR 0 1
42516: ARRAY
42517: PPUSH
42518: LD_INT 2
42520: PUSH
42521: LD_INT 30
42523: PUSH
42524: LD_INT 6
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 30
42533: PUSH
42534: LD_INT 7
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 30
42543: PUSH
42544: LD_INT 8
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: LIST
42555: LIST
42556: PPUSH
42557: CALL_OW 72
42561: NOT
42562: PUSH
42563: LD_EXP 100
42567: PUSH
42568: LD_VAR 0 1
42572: ARRAY
42573: PPUSH
42574: LD_INT 30
42576: PUSH
42577: LD_INT 3
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PPUSH
42584: CALL_OW 72
42588: NOT
42589: AND
42590: IFFALSE 42662
// begin if eng = tmp then
42592: LD_VAR 0 6
42596: PUSH
42597: LD_VAR 0 4
42601: EQUAL
42602: IFFALSE 42606
// exit ;
42604: GO 45195
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42606: LD_ADDR_EXP 142
42610: PUSH
42611: LD_EXP 142
42615: PPUSH
42616: LD_VAR 0 1
42620: PPUSH
42621: LD_INT 1
42623: PPUSH
42624: CALL_OW 1
42628: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42629: LD_ADDR_VAR 0 2
42633: PUSH
42634: LD_INT 0
42636: PUSH
42637: LD_VAR 0 4
42641: PUSH
42642: LD_VAR 0 6
42646: DIFF
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: LD_INT 0
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: LIST
42658: LIST
42659: ST_TO_ADDR
// exit ;
42660: GO 45195
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42662: LD_EXP 127
42666: PUSH
42667: LD_EXP 126
42671: PUSH
42672: LD_VAR 0 1
42676: ARRAY
42677: ARRAY
42678: PUSH
42679: LD_EXP 100
42683: PUSH
42684: LD_VAR 0 1
42688: ARRAY
42689: PPUSH
42690: LD_INT 2
42692: PUSH
42693: LD_INT 30
42695: PUSH
42696: LD_INT 6
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: LD_INT 30
42705: PUSH
42706: LD_INT 7
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 30
42715: PUSH
42716: LD_INT 8
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: PPUSH
42729: CALL_OW 72
42733: AND
42734: PUSH
42735: LD_EXP 100
42739: PUSH
42740: LD_VAR 0 1
42744: ARRAY
42745: PPUSH
42746: LD_INT 30
42748: PUSH
42749: LD_INT 3
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PPUSH
42756: CALL_OW 72
42760: NOT
42761: AND
42762: IFFALSE 42976
// begin if sci >= 6 then
42764: LD_VAR 0 8
42768: PUSH
42769: LD_INT 6
42771: GREATEREQUAL
42772: IFFALSE 42776
// exit ;
42774: GO 45195
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42776: LD_ADDR_EXP 142
42780: PUSH
42781: LD_EXP 142
42785: PPUSH
42786: LD_VAR 0 1
42790: PPUSH
42791: LD_INT 2
42793: PPUSH
42794: CALL_OW 1
42798: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42799: LD_ADDR_VAR 0 9
42803: PUSH
42804: LD_VAR 0 4
42808: PUSH
42809: LD_VAR 0 8
42813: DIFF
42814: PPUSH
42815: LD_INT 4
42817: PPUSH
42818: CALL 103494 0 2
42822: ST_TO_ADDR
// p := [ ] ;
42823: LD_ADDR_VAR 0 11
42827: PUSH
42828: EMPTY
42829: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42830: LD_VAR 0 8
42834: PUSH
42835: LD_INT 6
42837: LESS
42838: PUSH
42839: LD_VAR 0 9
42843: PUSH
42844: LD_INT 6
42846: GREATER
42847: AND
42848: IFFALSE 42929
// begin for i = 1 to 6 - sci do
42850: LD_ADDR_VAR 0 3
42854: PUSH
42855: DOUBLE
42856: LD_INT 1
42858: DEC
42859: ST_TO_ADDR
42860: LD_INT 6
42862: PUSH
42863: LD_VAR 0 8
42867: MINUS
42868: PUSH
42869: FOR_TO
42870: IFFALSE 42925
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42872: LD_ADDR_VAR 0 11
42876: PUSH
42877: LD_VAR 0 11
42881: PPUSH
42882: LD_VAR 0 11
42886: PUSH
42887: LD_INT 1
42889: PLUS
42890: PPUSH
42891: LD_VAR 0 9
42895: PUSH
42896: LD_INT 1
42898: ARRAY
42899: PPUSH
42900: CALL_OW 2
42904: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42905: LD_ADDR_VAR 0 9
42909: PUSH
42910: LD_VAR 0 9
42914: PPUSH
42915: LD_INT 1
42917: PPUSH
42918: CALL_OW 3
42922: ST_TO_ADDR
// end ;
42923: GO 42869
42925: POP
42926: POP
// end else
42927: GO 42949
// if sort then
42929: LD_VAR 0 9
42933: IFFALSE 42949
// p := sort [ 1 ] ;
42935: LD_ADDR_VAR 0 11
42939: PUSH
42940: LD_VAR 0 9
42944: PUSH
42945: LD_INT 1
42947: ARRAY
42948: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42949: LD_ADDR_VAR 0 2
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: LD_INT 0
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: LD_VAR 0 11
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: LIST
42972: LIST
42973: ST_TO_ADDR
// exit ;
42974: GO 45195
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42976: LD_EXP 127
42980: PUSH
42981: LD_EXP 126
42985: PUSH
42986: LD_VAR 0 1
42990: ARRAY
42991: ARRAY
42992: PUSH
42993: LD_EXP 100
42997: PUSH
42998: LD_VAR 0 1
43002: ARRAY
43003: PPUSH
43004: LD_INT 2
43006: PUSH
43007: LD_INT 30
43009: PUSH
43010: LD_INT 6
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 30
43019: PUSH
43020: LD_INT 7
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 30
43029: PUSH
43030: LD_INT 8
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: PPUSH
43043: CALL_OW 72
43047: AND
43048: PUSH
43049: LD_EXP 100
43053: PUSH
43054: LD_VAR 0 1
43058: ARRAY
43059: PPUSH
43060: LD_INT 30
43062: PUSH
43063: LD_INT 3
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PPUSH
43070: CALL_OW 72
43074: AND
43075: IFFALSE 43809
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
43077: LD_ADDR_EXP 142
43081: PUSH
43082: LD_EXP 142
43086: PPUSH
43087: LD_VAR 0 1
43091: PPUSH
43092: LD_INT 3
43094: PPUSH
43095: CALL_OW 1
43099: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43100: LD_ADDR_VAR 0 2
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: LD_INT 0
43110: PUSH
43111: LD_INT 0
43113: PUSH
43114: LD_INT 0
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: LIST
43121: LIST
43122: ST_TO_ADDR
// if not eng then
43123: LD_VAR 0 6
43127: NOT
43128: IFFALSE 43191
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
43130: LD_ADDR_VAR 0 11
43134: PUSH
43135: LD_VAR 0 4
43139: PPUSH
43140: LD_INT 2
43142: PPUSH
43143: CALL 103494 0 2
43147: PUSH
43148: LD_INT 1
43150: ARRAY
43151: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
43152: LD_ADDR_VAR 0 2
43156: PUSH
43157: LD_VAR 0 2
43161: PPUSH
43162: LD_INT 2
43164: PPUSH
43165: LD_VAR 0 11
43169: PPUSH
43170: CALL_OW 1
43174: ST_TO_ADDR
// tmp := tmp diff p ;
43175: LD_ADDR_VAR 0 4
43179: PUSH
43180: LD_VAR 0 4
43184: PUSH
43185: LD_VAR 0 11
43189: DIFF
43190: ST_TO_ADDR
// end ; if tmp and sci < 6 then
43191: LD_VAR 0 4
43195: PUSH
43196: LD_VAR 0 8
43200: PUSH
43201: LD_INT 6
43203: LESS
43204: AND
43205: IFFALSE 43393
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
43207: LD_ADDR_VAR 0 9
43211: PUSH
43212: LD_VAR 0 4
43216: PUSH
43217: LD_VAR 0 8
43221: PUSH
43222: LD_VAR 0 7
43226: UNION
43227: DIFF
43228: PPUSH
43229: LD_INT 4
43231: PPUSH
43232: CALL 103494 0 2
43236: ST_TO_ADDR
// p := [ ] ;
43237: LD_ADDR_VAR 0 11
43241: PUSH
43242: EMPTY
43243: ST_TO_ADDR
// if sort then
43244: LD_VAR 0 9
43248: IFFALSE 43364
// for i = 1 to 6 - sci do
43250: LD_ADDR_VAR 0 3
43254: PUSH
43255: DOUBLE
43256: LD_INT 1
43258: DEC
43259: ST_TO_ADDR
43260: LD_INT 6
43262: PUSH
43263: LD_VAR 0 8
43267: MINUS
43268: PUSH
43269: FOR_TO
43270: IFFALSE 43362
// begin if i = sort then
43272: LD_VAR 0 3
43276: PUSH
43277: LD_VAR 0 9
43281: EQUAL
43282: IFFALSE 43286
// break ;
43284: GO 43362
// if GetClass ( i ) = 4 then
43286: LD_VAR 0 3
43290: PPUSH
43291: CALL_OW 257
43295: PUSH
43296: LD_INT 4
43298: EQUAL
43299: IFFALSE 43303
// continue ;
43301: GO 43269
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43303: LD_ADDR_VAR 0 11
43307: PUSH
43308: LD_VAR 0 11
43312: PPUSH
43313: LD_VAR 0 11
43317: PUSH
43318: LD_INT 1
43320: PLUS
43321: PPUSH
43322: LD_VAR 0 9
43326: PUSH
43327: LD_VAR 0 3
43331: ARRAY
43332: PPUSH
43333: CALL_OW 2
43337: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43338: LD_ADDR_VAR 0 4
43342: PUSH
43343: LD_VAR 0 4
43347: PUSH
43348: LD_VAR 0 9
43352: PUSH
43353: LD_VAR 0 3
43357: ARRAY
43358: DIFF
43359: ST_TO_ADDR
// end ;
43360: GO 43269
43362: POP
43363: POP
// if p then
43364: LD_VAR 0 11
43368: IFFALSE 43393
// result := Replace ( result , 4 , p ) ;
43370: LD_ADDR_VAR 0 2
43374: PUSH
43375: LD_VAR 0 2
43379: PPUSH
43380: LD_INT 4
43382: PPUSH
43383: LD_VAR 0 11
43387: PPUSH
43388: CALL_OW 1
43392: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43393: LD_VAR 0 4
43397: PUSH
43398: LD_VAR 0 7
43402: PUSH
43403: LD_INT 6
43405: LESS
43406: AND
43407: IFFALSE 43595
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43409: LD_ADDR_VAR 0 9
43413: PUSH
43414: LD_VAR 0 4
43418: PUSH
43419: LD_VAR 0 8
43423: PUSH
43424: LD_VAR 0 7
43428: UNION
43429: DIFF
43430: PPUSH
43431: LD_INT 3
43433: PPUSH
43434: CALL 103494 0 2
43438: ST_TO_ADDR
// p := [ ] ;
43439: LD_ADDR_VAR 0 11
43443: PUSH
43444: EMPTY
43445: ST_TO_ADDR
// if sort then
43446: LD_VAR 0 9
43450: IFFALSE 43566
// for i = 1 to 6 - mech do
43452: LD_ADDR_VAR 0 3
43456: PUSH
43457: DOUBLE
43458: LD_INT 1
43460: DEC
43461: ST_TO_ADDR
43462: LD_INT 6
43464: PUSH
43465: LD_VAR 0 7
43469: MINUS
43470: PUSH
43471: FOR_TO
43472: IFFALSE 43564
// begin if i = sort then
43474: LD_VAR 0 3
43478: PUSH
43479: LD_VAR 0 9
43483: EQUAL
43484: IFFALSE 43488
// break ;
43486: GO 43564
// if GetClass ( i ) = 3 then
43488: LD_VAR 0 3
43492: PPUSH
43493: CALL_OW 257
43497: PUSH
43498: LD_INT 3
43500: EQUAL
43501: IFFALSE 43505
// continue ;
43503: GO 43471
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43505: LD_ADDR_VAR 0 11
43509: PUSH
43510: LD_VAR 0 11
43514: PPUSH
43515: LD_VAR 0 11
43519: PUSH
43520: LD_INT 1
43522: PLUS
43523: PPUSH
43524: LD_VAR 0 9
43528: PUSH
43529: LD_VAR 0 3
43533: ARRAY
43534: PPUSH
43535: CALL_OW 2
43539: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43540: LD_ADDR_VAR 0 4
43544: PUSH
43545: LD_VAR 0 4
43549: PUSH
43550: LD_VAR 0 9
43554: PUSH
43555: LD_VAR 0 3
43559: ARRAY
43560: DIFF
43561: ST_TO_ADDR
// end ;
43562: GO 43471
43564: POP
43565: POP
// if p then
43566: LD_VAR 0 11
43570: IFFALSE 43595
// result := Replace ( result , 3 , p ) ;
43572: LD_ADDR_VAR 0 2
43576: PUSH
43577: LD_VAR 0 2
43581: PPUSH
43582: LD_INT 3
43584: PPUSH
43585: LD_VAR 0 11
43589: PPUSH
43590: CALL_OW 1
43594: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43595: LD_VAR 0 4
43599: PUSH
43600: LD_INT 6
43602: GREATER
43603: PUSH
43604: LD_VAR 0 6
43608: PUSH
43609: LD_INT 6
43611: LESS
43612: AND
43613: IFFALSE 43807
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43615: LD_ADDR_VAR 0 9
43619: PUSH
43620: LD_VAR 0 4
43624: PUSH
43625: LD_VAR 0 8
43629: PUSH
43630: LD_VAR 0 7
43634: UNION
43635: PUSH
43636: LD_VAR 0 6
43640: UNION
43641: DIFF
43642: PPUSH
43643: LD_INT 2
43645: PPUSH
43646: CALL 103494 0 2
43650: ST_TO_ADDR
// p := [ ] ;
43651: LD_ADDR_VAR 0 11
43655: PUSH
43656: EMPTY
43657: ST_TO_ADDR
// if sort then
43658: LD_VAR 0 9
43662: IFFALSE 43778
// for i = 1 to 6 - eng do
43664: LD_ADDR_VAR 0 3
43668: PUSH
43669: DOUBLE
43670: LD_INT 1
43672: DEC
43673: ST_TO_ADDR
43674: LD_INT 6
43676: PUSH
43677: LD_VAR 0 6
43681: MINUS
43682: PUSH
43683: FOR_TO
43684: IFFALSE 43776
// begin if i = sort then
43686: LD_VAR 0 3
43690: PUSH
43691: LD_VAR 0 9
43695: EQUAL
43696: IFFALSE 43700
// break ;
43698: GO 43776
// if GetClass ( i ) = 2 then
43700: LD_VAR 0 3
43704: PPUSH
43705: CALL_OW 257
43709: PUSH
43710: LD_INT 2
43712: EQUAL
43713: IFFALSE 43717
// continue ;
43715: GO 43683
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43717: LD_ADDR_VAR 0 11
43721: PUSH
43722: LD_VAR 0 11
43726: PPUSH
43727: LD_VAR 0 11
43731: PUSH
43732: LD_INT 1
43734: PLUS
43735: PPUSH
43736: LD_VAR 0 9
43740: PUSH
43741: LD_VAR 0 3
43745: ARRAY
43746: PPUSH
43747: CALL_OW 2
43751: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43752: LD_ADDR_VAR 0 4
43756: PUSH
43757: LD_VAR 0 4
43761: PUSH
43762: LD_VAR 0 9
43766: PUSH
43767: LD_VAR 0 3
43771: ARRAY
43772: DIFF
43773: ST_TO_ADDR
// end ;
43774: GO 43683
43776: POP
43777: POP
// if p then
43778: LD_VAR 0 11
43782: IFFALSE 43807
// result := Replace ( result , 2 , p ) ;
43784: LD_ADDR_VAR 0 2
43788: PUSH
43789: LD_VAR 0 2
43793: PPUSH
43794: LD_INT 2
43796: PPUSH
43797: LD_VAR 0 11
43801: PPUSH
43802: CALL_OW 1
43806: ST_TO_ADDR
// end ; exit ;
43807: GO 45195
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43809: LD_EXP 127
43813: PUSH
43814: LD_EXP 126
43818: PUSH
43819: LD_VAR 0 1
43823: ARRAY
43824: ARRAY
43825: NOT
43826: PUSH
43827: LD_EXP 100
43831: PUSH
43832: LD_VAR 0 1
43836: ARRAY
43837: PPUSH
43838: LD_INT 30
43840: PUSH
43841: LD_INT 3
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PPUSH
43848: CALL_OW 72
43852: AND
43853: PUSH
43854: LD_EXP 105
43858: PUSH
43859: LD_VAR 0 1
43863: ARRAY
43864: AND
43865: IFFALSE 44473
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43867: LD_ADDR_EXP 142
43871: PUSH
43872: LD_EXP 142
43876: PPUSH
43877: LD_VAR 0 1
43881: PPUSH
43882: LD_INT 5
43884: PPUSH
43885: CALL_OW 1
43889: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43890: LD_ADDR_VAR 0 2
43894: PUSH
43895: LD_INT 0
43897: PUSH
43898: LD_INT 0
43900: PUSH
43901: LD_INT 0
43903: PUSH
43904: LD_INT 0
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: ST_TO_ADDR
// if sci > 1 then
43913: LD_VAR 0 8
43917: PUSH
43918: LD_INT 1
43920: GREATER
43921: IFFALSE 43949
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43923: LD_ADDR_VAR 0 4
43927: PUSH
43928: LD_VAR 0 4
43932: PUSH
43933: LD_VAR 0 8
43937: PUSH
43938: LD_VAR 0 8
43942: PUSH
43943: LD_INT 1
43945: ARRAY
43946: DIFF
43947: DIFF
43948: ST_TO_ADDR
// if tmp and not sci then
43949: LD_VAR 0 4
43953: PUSH
43954: LD_VAR 0 8
43958: NOT
43959: AND
43960: IFFALSE 44029
// begin sort := SortBySkill ( tmp , 4 ) ;
43962: LD_ADDR_VAR 0 9
43966: PUSH
43967: LD_VAR 0 4
43971: PPUSH
43972: LD_INT 4
43974: PPUSH
43975: CALL 103494 0 2
43979: ST_TO_ADDR
// if sort then
43980: LD_VAR 0 9
43984: IFFALSE 44000
// p := sort [ 1 ] ;
43986: LD_ADDR_VAR 0 11
43990: PUSH
43991: LD_VAR 0 9
43995: PUSH
43996: LD_INT 1
43998: ARRAY
43999: ST_TO_ADDR
// if p then
44000: LD_VAR 0 11
44004: IFFALSE 44029
// result := Replace ( result , 4 , p ) ;
44006: LD_ADDR_VAR 0 2
44010: PUSH
44011: LD_VAR 0 2
44015: PPUSH
44016: LD_INT 4
44018: PPUSH
44019: LD_VAR 0 11
44023: PPUSH
44024: CALL_OW 1
44028: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44029: LD_ADDR_VAR 0 4
44033: PUSH
44034: LD_VAR 0 4
44038: PUSH
44039: LD_VAR 0 7
44043: DIFF
44044: ST_TO_ADDR
// if tmp and mech < 6 then
44045: LD_VAR 0 4
44049: PUSH
44050: LD_VAR 0 7
44054: PUSH
44055: LD_INT 6
44057: LESS
44058: AND
44059: IFFALSE 44247
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44061: LD_ADDR_VAR 0 9
44065: PUSH
44066: LD_VAR 0 4
44070: PUSH
44071: LD_VAR 0 8
44075: PUSH
44076: LD_VAR 0 7
44080: UNION
44081: DIFF
44082: PPUSH
44083: LD_INT 3
44085: PPUSH
44086: CALL 103494 0 2
44090: ST_TO_ADDR
// p := [ ] ;
44091: LD_ADDR_VAR 0 11
44095: PUSH
44096: EMPTY
44097: ST_TO_ADDR
// if sort then
44098: LD_VAR 0 9
44102: IFFALSE 44218
// for i = 1 to 6 - mech do
44104: LD_ADDR_VAR 0 3
44108: PUSH
44109: DOUBLE
44110: LD_INT 1
44112: DEC
44113: ST_TO_ADDR
44114: LD_INT 6
44116: PUSH
44117: LD_VAR 0 7
44121: MINUS
44122: PUSH
44123: FOR_TO
44124: IFFALSE 44216
// begin if i = sort then
44126: LD_VAR 0 3
44130: PUSH
44131: LD_VAR 0 9
44135: EQUAL
44136: IFFALSE 44140
// break ;
44138: GO 44216
// if GetClass ( i ) = 3 then
44140: LD_VAR 0 3
44144: PPUSH
44145: CALL_OW 257
44149: PUSH
44150: LD_INT 3
44152: EQUAL
44153: IFFALSE 44157
// continue ;
44155: GO 44123
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44157: LD_ADDR_VAR 0 11
44161: PUSH
44162: LD_VAR 0 11
44166: PPUSH
44167: LD_VAR 0 11
44171: PUSH
44172: LD_INT 1
44174: PLUS
44175: PPUSH
44176: LD_VAR 0 9
44180: PUSH
44181: LD_VAR 0 3
44185: ARRAY
44186: PPUSH
44187: CALL_OW 2
44191: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44192: LD_ADDR_VAR 0 4
44196: PUSH
44197: LD_VAR 0 4
44201: PUSH
44202: LD_VAR 0 9
44206: PUSH
44207: LD_VAR 0 3
44211: ARRAY
44212: DIFF
44213: ST_TO_ADDR
// end ;
44214: GO 44123
44216: POP
44217: POP
// if p then
44218: LD_VAR 0 11
44222: IFFALSE 44247
// result := Replace ( result , 3 , p ) ;
44224: LD_ADDR_VAR 0 2
44228: PUSH
44229: LD_VAR 0 2
44233: PPUSH
44234: LD_INT 3
44236: PPUSH
44237: LD_VAR 0 11
44241: PPUSH
44242: CALL_OW 1
44246: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44247: LD_ADDR_VAR 0 4
44251: PUSH
44252: LD_VAR 0 4
44256: PUSH
44257: LD_VAR 0 6
44261: DIFF
44262: ST_TO_ADDR
// if tmp and eng < 6 then
44263: LD_VAR 0 4
44267: PUSH
44268: LD_VAR 0 6
44272: PUSH
44273: LD_INT 6
44275: LESS
44276: AND
44277: IFFALSE 44471
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44279: LD_ADDR_VAR 0 9
44283: PUSH
44284: LD_VAR 0 4
44288: PUSH
44289: LD_VAR 0 8
44293: PUSH
44294: LD_VAR 0 7
44298: UNION
44299: PUSH
44300: LD_VAR 0 6
44304: UNION
44305: DIFF
44306: PPUSH
44307: LD_INT 2
44309: PPUSH
44310: CALL 103494 0 2
44314: ST_TO_ADDR
// p := [ ] ;
44315: LD_ADDR_VAR 0 11
44319: PUSH
44320: EMPTY
44321: ST_TO_ADDR
// if sort then
44322: LD_VAR 0 9
44326: IFFALSE 44442
// for i = 1 to 6 - eng do
44328: LD_ADDR_VAR 0 3
44332: PUSH
44333: DOUBLE
44334: LD_INT 1
44336: DEC
44337: ST_TO_ADDR
44338: LD_INT 6
44340: PUSH
44341: LD_VAR 0 6
44345: MINUS
44346: PUSH
44347: FOR_TO
44348: IFFALSE 44440
// begin if i = sort then
44350: LD_VAR 0 3
44354: PUSH
44355: LD_VAR 0 9
44359: EQUAL
44360: IFFALSE 44364
// break ;
44362: GO 44440
// if GetClass ( i ) = 2 then
44364: LD_VAR 0 3
44368: PPUSH
44369: CALL_OW 257
44373: PUSH
44374: LD_INT 2
44376: EQUAL
44377: IFFALSE 44381
// continue ;
44379: GO 44347
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44381: LD_ADDR_VAR 0 11
44385: PUSH
44386: LD_VAR 0 11
44390: PPUSH
44391: LD_VAR 0 11
44395: PUSH
44396: LD_INT 1
44398: PLUS
44399: PPUSH
44400: LD_VAR 0 9
44404: PUSH
44405: LD_VAR 0 3
44409: ARRAY
44410: PPUSH
44411: CALL_OW 2
44415: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44416: LD_ADDR_VAR 0 4
44420: PUSH
44421: LD_VAR 0 4
44425: PUSH
44426: LD_VAR 0 9
44430: PUSH
44431: LD_VAR 0 3
44435: ARRAY
44436: DIFF
44437: ST_TO_ADDR
// end ;
44438: GO 44347
44440: POP
44441: POP
// if p then
44442: LD_VAR 0 11
44446: IFFALSE 44471
// result := Replace ( result , 2 , p ) ;
44448: LD_ADDR_VAR 0 2
44452: PUSH
44453: LD_VAR 0 2
44457: PPUSH
44458: LD_INT 2
44460: PPUSH
44461: LD_VAR 0 11
44465: PPUSH
44466: CALL_OW 1
44470: ST_TO_ADDR
// end ; exit ;
44471: GO 45195
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44473: LD_EXP 127
44477: PUSH
44478: LD_EXP 126
44482: PUSH
44483: LD_VAR 0 1
44487: ARRAY
44488: ARRAY
44489: NOT
44490: PUSH
44491: LD_EXP 100
44495: PUSH
44496: LD_VAR 0 1
44500: ARRAY
44501: PPUSH
44502: LD_INT 30
44504: PUSH
44505: LD_INT 3
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PPUSH
44512: CALL_OW 72
44516: AND
44517: PUSH
44518: LD_EXP 105
44522: PUSH
44523: LD_VAR 0 1
44527: ARRAY
44528: NOT
44529: AND
44530: IFFALSE 45195
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44532: LD_ADDR_EXP 142
44536: PUSH
44537: LD_EXP 142
44541: PPUSH
44542: LD_VAR 0 1
44546: PPUSH
44547: LD_INT 6
44549: PPUSH
44550: CALL_OW 1
44554: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44555: LD_ADDR_VAR 0 2
44559: PUSH
44560: LD_INT 0
44562: PUSH
44563: LD_INT 0
44565: PUSH
44566: LD_INT 0
44568: PUSH
44569: LD_INT 0
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: ST_TO_ADDR
// if sci >= 1 then
44578: LD_VAR 0 8
44582: PUSH
44583: LD_INT 1
44585: GREATEREQUAL
44586: IFFALSE 44608
// tmp := tmp diff sci [ 1 ] ;
44588: LD_ADDR_VAR 0 4
44592: PUSH
44593: LD_VAR 0 4
44597: PUSH
44598: LD_VAR 0 8
44602: PUSH
44603: LD_INT 1
44605: ARRAY
44606: DIFF
44607: ST_TO_ADDR
// if tmp and not sci then
44608: LD_VAR 0 4
44612: PUSH
44613: LD_VAR 0 8
44617: NOT
44618: AND
44619: IFFALSE 44688
// begin sort := SortBySkill ( tmp , 4 ) ;
44621: LD_ADDR_VAR 0 9
44625: PUSH
44626: LD_VAR 0 4
44630: PPUSH
44631: LD_INT 4
44633: PPUSH
44634: CALL 103494 0 2
44638: ST_TO_ADDR
// if sort then
44639: LD_VAR 0 9
44643: IFFALSE 44659
// p := sort [ 1 ] ;
44645: LD_ADDR_VAR 0 11
44649: PUSH
44650: LD_VAR 0 9
44654: PUSH
44655: LD_INT 1
44657: ARRAY
44658: ST_TO_ADDR
// if p then
44659: LD_VAR 0 11
44663: IFFALSE 44688
// result := Replace ( result , 4 , p ) ;
44665: LD_ADDR_VAR 0 2
44669: PUSH
44670: LD_VAR 0 2
44674: PPUSH
44675: LD_INT 4
44677: PPUSH
44678: LD_VAR 0 11
44682: PPUSH
44683: CALL_OW 1
44687: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44688: LD_ADDR_VAR 0 4
44692: PUSH
44693: LD_VAR 0 4
44697: PUSH
44698: LD_VAR 0 7
44702: DIFF
44703: ST_TO_ADDR
// if tmp and mech < 6 then
44704: LD_VAR 0 4
44708: PUSH
44709: LD_VAR 0 7
44713: PUSH
44714: LD_INT 6
44716: LESS
44717: AND
44718: IFFALSE 44900
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44720: LD_ADDR_VAR 0 9
44724: PUSH
44725: LD_VAR 0 4
44729: PUSH
44730: LD_VAR 0 7
44734: DIFF
44735: PPUSH
44736: LD_INT 3
44738: PPUSH
44739: CALL 103494 0 2
44743: ST_TO_ADDR
// p := [ ] ;
44744: LD_ADDR_VAR 0 11
44748: PUSH
44749: EMPTY
44750: ST_TO_ADDR
// if sort then
44751: LD_VAR 0 9
44755: IFFALSE 44871
// for i = 1 to 6 - mech do
44757: LD_ADDR_VAR 0 3
44761: PUSH
44762: DOUBLE
44763: LD_INT 1
44765: DEC
44766: ST_TO_ADDR
44767: LD_INT 6
44769: PUSH
44770: LD_VAR 0 7
44774: MINUS
44775: PUSH
44776: FOR_TO
44777: IFFALSE 44869
// begin if i = sort then
44779: LD_VAR 0 3
44783: PUSH
44784: LD_VAR 0 9
44788: EQUAL
44789: IFFALSE 44793
// break ;
44791: GO 44869
// if GetClass ( i ) = 3 then
44793: LD_VAR 0 3
44797: PPUSH
44798: CALL_OW 257
44802: PUSH
44803: LD_INT 3
44805: EQUAL
44806: IFFALSE 44810
// continue ;
44808: GO 44776
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44810: LD_ADDR_VAR 0 11
44814: PUSH
44815: LD_VAR 0 11
44819: PPUSH
44820: LD_VAR 0 11
44824: PUSH
44825: LD_INT 1
44827: PLUS
44828: PPUSH
44829: LD_VAR 0 9
44833: PUSH
44834: LD_VAR 0 3
44838: ARRAY
44839: PPUSH
44840: CALL_OW 2
44844: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44845: LD_ADDR_VAR 0 4
44849: PUSH
44850: LD_VAR 0 4
44854: PUSH
44855: LD_VAR 0 9
44859: PUSH
44860: LD_VAR 0 3
44864: ARRAY
44865: DIFF
44866: ST_TO_ADDR
// end ;
44867: GO 44776
44869: POP
44870: POP
// if p then
44871: LD_VAR 0 11
44875: IFFALSE 44900
// result := Replace ( result , 3 , p ) ;
44877: LD_ADDR_VAR 0 2
44881: PUSH
44882: LD_VAR 0 2
44886: PPUSH
44887: LD_INT 3
44889: PPUSH
44890: LD_VAR 0 11
44894: PPUSH
44895: CALL_OW 1
44899: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44900: LD_ADDR_VAR 0 4
44904: PUSH
44905: LD_VAR 0 4
44909: PUSH
44910: LD_VAR 0 6
44914: DIFF
44915: ST_TO_ADDR
// if tmp and eng < 4 then
44916: LD_VAR 0 4
44920: PUSH
44921: LD_VAR 0 6
44925: PUSH
44926: LD_INT 4
44928: LESS
44929: AND
44930: IFFALSE 45120
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44932: LD_ADDR_VAR 0 9
44936: PUSH
44937: LD_VAR 0 4
44941: PUSH
44942: LD_VAR 0 7
44946: PUSH
44947: LD_VAR 0 6
44951: UNION
44952: DIFF
44953: PPUSH
44954: LD_INT 2
44956: PPUSH
44957: CALL 103494 0 2
44961: ST_TO_ADDR
// p := [ ] ;
44962: LD_ADDR_VAR 0 11
44966: PUSH
44967: EMPTY
44968: ST_TO_ADDR
// if sort then
44969: LD_VAR 0 9
44973: IFFALSE 45089
// for i = 1 to 4 - eng do
44975: LD_ADDR_VAR 0 3
44979: PUSH
44980: DOUBLE
44981: LD_INT 1
44983: DEC
44984: ST_TO_ADDR
44985: LD_INT 4
44987: PUSH
44988: LD_VAR 0 6
44992: MINUS
44993: PUSH
44994: FOR_TO
44995: IFFALSE 45087
// begin if i = sort then
44997: LD_VAR 0 3
45001: PUSH
45002: LD_VAR 0 9
45006: EQUAL
45007: IFFALSE 45011
// break ;
45009: GO 45087
// if GetClass ( i ) = 2 then
45011: LD_VAR 0 3
45015: PPUSH
45016: CALL_OW 257
45020: PUSH
45021: LD_INT 2
45023: EQUAL
45024: IFFALSE 45028
// continue ;
45026: GO 44994
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45028: LD_ADDR_VAR 0 11
45032: PUSH
45033: LD_VAR 0 11
45037: PPUSH
45038: LD_VAR 0 11
45042: PUSH
45043: LD_INT 1
45045: PLUS
45046: PPUSH
45047: LD_VAR 0 9
45051: PUSH
45052: LD_VAR 0 3
45056: ARRAY
45057: PPUSH
45058: CALL_OW 2
45062: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45063: LD_ADDR_VAR 0 4
45067: PUSH
45068: LD_VAR 0 4
45072: PUSH
45073: LD_VAR 0 9
45077: PUSH
45078: LD_VAR 0 3
45082: ARRAY
45083: DIFF
45084: ST_TO_ADDR
// end ;
45085: GO 44994
45087: POP
45088: POP
// if p then
45089: LD_VAR 0 11
45093: IFFALSE 45118
// result := Replace ( result , 2 , p ) ;
45095: LD_ADDR_VAR 0 2
45099: PUSH
45100: LD_VAR 0 2
45104: PPUSH
45105: LD_INT 2
45107: PPUSH
45108: LD_VAR 0 11
45112: PPUSH
45113: CALL_OW 1
45117: ST_TO_ADDR
// end else
45118: GO 45164
// for i = eng downto 5 do
45120: LD_ADDR_VAR 0 3
45124: PUSH
45125: DOUBLE
45126: LD_VAR 0 6
45130: INC
45131: ST_TO_ADDR
45132: LD_INT 5
45134: PUSH
45135: FOR_DOWNTO
45136: IFFALSE 45162
// tmp := tmp union eng [ i ] ;
45138: LD_ADDR_VAR 0 4
45142: PUSH
45143: LD_VAR 0 4
45147: PUSH
45148: LD_VAR 0 6
45152: PUSH
45153: LD_VAR 0 3
45157: ARRAY
45158: UNION
45159: ST_TO_ADDR
45160: GO 45135
45162: POP
45163: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
45164: LD_ADDR_VAR 0 2
45168: PUSH
45169: LD_VAR 0 2
45173: PPUSH
45174: LD_INT 1
45176: PPUSH
45177: LD_VAR 0 4
45181: PUSH
45182: LD_VAR 0 5
45186: DIFF
45187: PPUSH
45188: CALL_OW 1
45192: ST_TO_ADDR
// exit ;
45193: GO 45195
// end ; end ;
45195: LD_VAR 0 2
45199: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
45200: LD_INT 0
45202: PPUSH
45203: PPUSH
45204: PPUSH
// if not mc_bases then
45205: LD_EXP 100
45209: NOT
45210: IFFALSE 45214
// exit ;
45212: GO 45356
// for i = 1 to mc_bases do
45214: LD_ADDR_VAR 0 2
45218: PUSH
45219: DOUBLE
45220: LD_INT 1
45222: DEC
45223: ST_TO_ADDR
45224: LD_EXP 100
45228: PUSH
45229: FOR_TO
45230: IFFALSE 45347
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
45232: LD_ADDR_VAR 0 3
45236: PUSH
45237: LD_EXP 100
45241: PUSH
45242: LD_VAR 0 2
45246: ARRAY
45247: PPUSH
45248: LD_INT 21
45250: PUSH
45251: LD_INT 3
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PUSH
45258: LD_INT 3
45260: PUSH
45261: LD_INT 2
45263: PUSH
45264: LD_INT 30
45266: PUSH
45267: LD_INT 29
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: PUSH
45274: LD_INT 30
45276: PUSH
45277: LD_INT 30
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: LIST
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 3
45295: PUSH
45296: LD_INT 24
45298: PUSH
45299: LD_INT 1000
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: LIST
45314: PPUSH
45315: CALL_OW 72
45319: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45320: LD_ADDR_EXP 101
45324: PUSH
45325: LD_EXP 101
45329: PPUSH
45330: LD_VAR 0 2
45334: PPUSH
45335: LD_VAR 0 3
45339: PPUSH
45340: CALL_OW 1
45344: ST_TO_ADDR
// end ;
45345: GO 45229
45347: POP
45348: POP
// RaiseSailEvent ( 101 ) ;
45349: LD_INT 101
45351: PPUSH
45352: CALL_OW 427
// end ;
45356: LD_VAR 0 1
45360: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45361: LD_INT 0
45363: PPUSH
45364: PPUSH
45365: PPUSH
45366: PPUSH
45367: PPUSH
45368: PPUSH
45369: PPUSH
// if not mc_bases then
45370: LD_EXP 100
45374: NOT
45375: IFFALSE 45379
// exit ;
45377: GO 45941
// for i = 1 to mc_bases do
45379: LD_ADDR_VAR 0 2
45383: PUSH
45384: DOUBLE
45385: LD_INT 1
45387: DEC
45388: ST_TO_ADDR
45389: LD_EXP 100
45393: PUSH
45394: FOR_TO
45395: IFFALSE 45932
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45397: LD_ADDR_VAR 0 5
45401: PUSH
45402: LD_EXP 100
45406: PUSH
45407: LD_VAR 0 2
45411: ARRAY
45412: PUSH
45413: LD_EXP 129
45417: PUSH
45418: LD_VAR 0 2
45422: ARRAY
45423: UNION
45424: PPUSH
45425: LD_INT 21
45427: PUSH
45428: LD_INT 1
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 1
45437: PUSH
45438: LD_INT 3
45440: PUSH
45441: LD_INT 54
45443: PUSH
45444: EMPTY
45445: LIST
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 3
45453: PUSH
45454: LD_INT 24
45456: PUSH
45457: LD_INT 1000
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: LIST
45472: PUSH
45473: EMPTY
45474: LIST
45475: LIST
45476: PPUSH
45477: CALL_OW 72
45481: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45482: LD_ADDR_VAR 0 6
45486: PUSH
45487: LD_EXP 100
45491: PUSH
45492: LD_VAR 0 2
45496: ARRAY
45497: PPUSH
45498: LD_INT 21
45500: PUSH
45501: LD_INT 1
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: LD_INT 1
45510: PUSH
45511: LD_INT 3
45513: PUSH
45514: LD_INT 54
45516: PUSH
45517: EMPTY
45518: LIST
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: PUSH
45524: LD_INT 3
45526: PUSH
45527: LD_INT 24
45529: PUSH
45530: LD_INT 250
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: LIST
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PPUSH
45550: CALL_OW 72
45554: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45555: LD_ADDR_VAR 0 7
45559: PUSH
45560: LD_VAR 0 5
45564: PUSH
45565: LD_VAR 0 6
45569: DIFF
45570: ST_TO_ADDR
// if not need_heal_1 then
45571: LD_VAR 0 6
45575: NOT
45576: IFFALSE 45609
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45578: LD_ADDR_EXP 103
45582: PUSH
45583: LD_EXP 103
45587: PPUSH
45588: LD_VAR 0 2
45592: PUSH
45593: LD_INT 1
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: PPUSH
45600: EMPTY
45601: PPUSH
45602: CALL 72673 0 3
45606: ST_TO_ADDR
45607: GO 45679
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45609: LD_ADDR_EXP 103
45613: PUSH
45614: LD_EXP 103
45618: PPUSH
45619: LD_VAR 0 2
45623: PUSH
45624: LD_INT 1
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PPUSH
45631: LD_EXP 103
45635: PUSH
45636: LD_VAR 0 2
45640: ARRAY
45641: PUSH
45642: LD_INT 1
45644: ARRAY
45645: PPUSH
45646: LD_INT 3
45648: PUSH
45649: LD_INT 24
45651: PUSH
45652: LD_INT 1000
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: EMPTY
45660: LIST
45661: LIST
45662: PPUSH
45663: CALL_OW 72
45667: PUSH
45668: LD_VAR 0 6
45672: UNION
45673: PPUSH
45674: CALL 72673 0 3
45678: ST_TO_ADDR
// if not need_heal_2 then
45679: LD_VAR 0 7
45683: NOT
45684: IFFALSE 45717
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45686: LD_ADDR_EXP 103
45690: PUSH
45691: LD_EXP 103
45695: PPUSH
45696: LD_VAR 0 2
45700: PUSH
45701: LD_INT 2
45703: PUSH
45704: EMPTY
45705: LIST
45706: LIST
45707: PPUSH
45708: EMPTY
45709: PPUSH
45710: CALL 72673 0 3
45714: ST_TO_ADDR
45715: GO 45749
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45717: LD_ADDR_EXP 103
45721: PUSH
45722: LD_EXP 103
45726: PPUSH
45727: LD_VAR 0 2
45731: PUSH
45732: LD_INT 2
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PPUSH
45739: LD_VAR 0 7
45743: PPUSH
45744: CALL 72673 0 3
45748: ST_TO_ADDR
// if need_heal_2 then
45749: LD_VAR 0 7
45753: IFFALSE 45914
// for j in need_heal_2 do
45755: LD_ADDR_VAR 0 3
45759: PUSH
45760: LD_VAR 0 7
45764: PUSH
45765: FOR_IN
45766: IFFALSE 45912
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45768: LD_ADDR_VAR 0 5
45772: PUSH
45773: LD_EXP 100
45777: PUSH
45778: LD_VAR 0 2
45782: ARRAY
45783: PPUSH
45784: LD_INT 2
45786: PUSH
45787: LD_INT 30
45789: PUSH
45790: LD_INT 6
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 30
45799: PUSH
45800: LD_INT 7
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 30
45809: PUSH
45810: LD_INT 8
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 30
45819: PUSH
45820: LD_INT 0
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 30
45829: PUSH
45830: LD_INT 1
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: PPUSH
45845: CALL_OW 72
45849: ST_TO_ADDR
// if tmp then
45850: LD_VAR 0 5
45854: IFFALSE 45910
// begin k := NearestUnitToUnit ( tmp , j ) ;
45856: LD_ADDR_VAR 0 4
45860: PUSH
45861: LD_VAR 0 5
45865: PPUSH
45866: LD_VAR 0 3
45870: PPUSH
45871: CALL_OW 74
45875: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45876: LD_VAR 0 3
45880: PPUSH
45881: LD_VAR 0 4
45885: PPUSH
45886: CALL_OW 296
45890: PUSH
45891: LD_INT 5
45893: GREATER
45894: IFFALSE 45910
// ComMoveToNearbyEntrance ( j , k ) ;
45896: LD_VAR 0 3
45900: PPUSH
45901: LD_VAR 0 4
45905: PPUSH
45906: CALL 105862 0 2
// end ; end ;
45910: GO 45765
45912: POP
45913: POP
// if not need_heal_1 and not need_heal_2 then
45914: LD_VAR 0 6
45918: NOT
45919: PUSH
45920: LD_VAR 0 7
45924: NOT
45925: AND
45926: IFFALSE 45930
// continue ;
45928: GO 45394
// end ;
45930: GO 45394
45932: POP
45933: POP
// RaiseSailEvent ( 102 ) ;
45934: LD_INT 102
45936: PPUSH
45937: CALL_OW 427
// end ;
45941: LD_VAR 0 1
45945: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45946: LD_INT 0
45948: PPUSH
45949: PPUSH
45950: PPUSH
45951: PPUSH
45952: PPUSH
45953: PPUSH
45954: PPUSH
45955: PPUSH
// if not mc_bases then
45956: LD_EXP 100
45960: NOT
45961: IFFALSE 45965
// exit ;
45963: GO 46876
// for i = 1 to mc_bases do
45965: LD_ADDR_VAR 0 2
45969: PUSH
45970: DOUBLE
45971: LD_INT 1
45973: DEC
45974: ST_TO_ADDR
45975: LD_EXP 100
45979: PUSH
45980: FOR_TO
45981: IFFALSE 46874
// begin if not mc_building_need_repair [ i ] then
45983: LD_EXP 101
45987: PUSH
45988: LD_VAR 0 2
45992: ARRAY
45993: NOT
45994: IFFALSE 46179
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
45996: LD_ADDR_VAR 0 6
46000: PUSH
46001: LD_EXP 119
46005: PUSH
46006: LD_VAR 0 2
46010: ARRAY
46011: PPUSH
46012: LD_INT 3
46014: PUSH
46015: LD_INT 24
46017: PUSH
46018: LD_INT 1000
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 2
46031: PUSH
46032: LD_INT 34
46034: PUSH
46035: LD_INT 13
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 34
46044: PUSH
46045: LD_INT 52
46047: PUSH
46048: EMPTY
46049: LIST
46050: LIST
46051: PUSH
46052: LD_INT 34
46054: PUSH
46055: LD_INT 88
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PPUSH
46072: CALL_OW 72
46076: ST_TO_ADDR
// if cranes then
46077: LD_VAR 0 6
46081: IFFALSE 46143
// for j in cranes do
46083: LD_ADDR_VAR 0 3
46087: PUSH
46088: LD_VAR 0 6
46092: PUSH
46093: FOR_IN
46094: IFFALSE 46141
// if not IsInArea ( j , mc_parking [ i ] ) then
46096: LD_VAR 0 3
46100: PPUSH
46101: LD_EXP 124
46105: PUSH
46106: LD_VAR 0 2
46110: ARRAY
46111: PPUSH
46112: CALL_OW 308
46116: NOT
46117: IFFALSE 46139
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46119: LD_VAR 0 3
46123: PPUSH
46124: LD_EXP 124
46128: PUSH
46129: LD_VAR 0 2
46133: ARRAY
46134: PPUSH
46135: CALL_OW 113
46139: GO 46093
46141: POP
46142: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
46143: LD_ADDR_EXP 102
46147: PUSH
46148: LD_EXP 102
46152: PPUSH
46153: LD_VAR 0 2
46157: PPUSH
46158: EMPTY
46159: PPUSH
46160: CALL_OW 1
46164: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
46165: LD_VAR 0 2
46169: PPUSH
46170: LD_INT 101
46172: PPUSH
46173: CALL 41033 0 2
// continue ;
46177: GO 45980
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
46179: LD_ADDR_EXP 106
46183: PUSH
46184: LD_EXP 106
46188: PPUSH
46189: LD_VAR 0 2
46193: PPUSH
46194: EMPTY
46195: PPUSH
46196: CALL_OW 1
46200: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
46201: LD_VAR 0 2
46205: PPUSH
46206: LD_INT 103
46208: PPUSH
46209: CALL 41033 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
46213: LD_ADDR_VAR 0 5
46217: PUSH
46218: LD_EXP 100
46222: PUSH
46223: LD_VAR 0 2
46227: ARRAY
46228: PUSH
46229: LD_EXP 129
46233: PUSH
46234: LD_VAR 0 2
46238: ARRAY
46239: UNION
46240: PPUSH
46241: LD_INT 2
46243: PUSH
46244: LD_INT 25
46246: PUSH
46247: LD_INT 2
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 25
46256: PUSH
46257: LD_INT 16
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: LIST
46268: PUSH
46269: EMPTY
46270: LIST
46271: PPUSH
46272: CALL_OW 72
46276: ST_TO_ADDR
// if mc_need_heal [ i ] then
46277: LD_EXP 103
46281: PUSH
46282: LD_VAR 0 2
46286: ARRAY
46287: IFFALSE 46331
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
46289: LD_ADDR_VAR 0 5
46293: PUSH
46294: LD_VAR 0 5
46298: PUSH
46299: LD_EXP 103
46303: PUSH
46304: LD_VAR 0 2
46308: ARRAY
46309: PUSH
46310: LD_INT 1
46312: ARRAY
46313: PUSH
46314: LD_EXP 103
46318: PUSH
46319: LD_VAR 0 2
46323: ARRAY
46324: PUSH
46325: LD_INT 2
46327: ARRAY
46328: UNION
46329: DIFF
46330: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46331: LD_ADDR_VAR 0 6
46335: PUSH
46336: LD_EXP 119
46340: PUSH
46341: LD_VAR 0 2
46345: ARRAY
46346: PPUSH
46347: LD_INT 2
46349: PUSH
46350: LD_INT 34
46352: PUSH
46353: LD_INT 13
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 34
46362: PUSH
46363: LD_INT 52
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: PUSH
46370: LD_INT 34
46372: PUSH
46373: LD_INT 88
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: PPUSH
46386: CALL_OW 72
46390: ST_TO_ADDR
// if cranes then
46391: LD_VAR 0 6
46395: IFFALSE 46563
// begin for j in cranes do
46397: LD_ADDR_VAR 0 3
46401: PUSH
46402: LD_VAR 0 6
46406: PUSH
46407: FOR_IN
46408: IFFALSE 46561
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46410: LD_VAR 0 3
46414: PPUSH
46415: CALL_OW 256
46419: PUSH
46420: LD_INT 1000
46422: EQUAL
46423: PUSH
46424: LD_VAR 0 3
46428: PPUSH
46429: CALL_OW 314
46433: NOT
46434: AND
46435: IFFALSE 46501
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46437: LD_ADDR_VAR 0 8
46441: PUSH
46442: LD_EXP 101
46446: PUSH
46447: LD_VAR 0 2
46451: ARRAY
46452: PPUSH
46453: LD_VAR 0 3
46457: PPUSH
46458: CALL_OW 74
46462: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46463: LD_VAR 0 8
46467: PPUSH
46468: LD_INT 16
46470: PPUSH
46471: CALL 75270 0 2
46475: PUSH
46476: LD_INT 4
46478: ARRAY
46479: PUSH
46480: LD_INT 10
46482: LESS
46483: IFFALSE 46499
// ComRepairBuilding ( j , to_repair ) ;
46485: LD_VAR 0 3
46489: PPUSH
46490: LD_VAR 0 8
46494: PPUSH
46495: CALL_OW 130
// end else
46499: GO 46559
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46501: LD_VAR 0 3
46505: PPUSH
46506: CALL_OW 256
46510: PUSH
46511: LD_INT 500
46513: LESS
46514: PUSH
46515: LD_VAR 0 3
46519: PPUSH
46520: LD_EXP 124
46524: PUSH
46525: LD_VAR 0 2
46529: ARRAY
46530: PPUSH
46531: CALL_OW 308
46535: NOT
46536: AND
46537: IFFALSE 46559
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46539: LD_VAR 0 3
46543: PPUSH
46544: LD_EXP 124
46548: PUSH
46549: LD_VAR 0 2
46553: ARRAY
46554: PPUSH
46555: CALL_OW 113
// end ;
46559: GO 46407
46561: POP
46562: POP
// end ; if tmp > 3 then
46563: LD_VAR 0 5
46567: PUSH
46568: LD_INT 3
46570: GREATER
46571: IFFALSE 46591
// tmp := ShrinkArray ( tmp , 4 ) ;
46573: LD_ADDR_VAR 0 5
46577: PUSH
46578: LD_VAR 0 5
46582: PPUSH
46583: LD_INT 4
46585: PPUSH
46586: CALL 105300 0 2
46590: ST_TO_ADDR
// if not tmp then
46591: LD_VAR 0 5
46595: NOT
46596: IFFALSE 46600
// continue ;
46598: GO 45980
// for j in tmp do
46600: LD_ADDR_VAR 0 3
46604: PUSH
46605: LD_VAR 0 5
46609: PUSH
46610: FOR_IN
46611: IFFALSE 46870
// begin if IsInUnit ( j ) then
46613: LD_VAR 0 3
46617: PPUSH
46618: CALL_OW 310
46622: IFFALSE 46633
// ComExitBuilding ( j ) ;
46624: LD_VAR 0 3
46628: PPUSH
46629: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46633: LD_VAR 0 3
46637: PUSH
46638: LD_EXP 102
46642: PUSH
46643: LD_VAR 0 2
46647: ARRAY
46648: IN
46649: NOT
46650: IFFALSE 46708
// begin SetTag ( j , 101 ) ;
46652: LD_VAR 0 3
46656: PPUSH
46657: LD_INT 101
46659: PPUSH
46660: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46664: LD_ADDR_EXP 102
46668: PUSH
46669: LD_EXP 102
46673: PPUSH
46674: LD_VAR 0 2
46678: PUSH
46679: LD_EXP 102
46683: PUSH
46684: LD_VAR 0 2
46688: ARRAY
46689: PUSH
46690: LD_INT 1
46692: PLUS
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PPUSH
46698: LD_VAR 0 3
46702: PPUSH
46703: CALL 72673 0 3
46707: ST_TO_ADDR
// end ; wait ( 1 ) ;
46708: LD_INT 1
46710: PPUSH
46711: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46715: LD_ADDR_VAR 0 7
46719: PUSH
46720: LD_EXP 101
46724: PUSH
46725: LD_VAR 0 2
46729: ARRAY
46730: ST_TO_ADDR
// if mc_scan [ i ] then
46731: LD_EXP 123
46735: PUSH
46736: LD_VAR 0 2
46740: ARRAY
46741: IFFALSE 46803
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46743: LD_ADDR_VAR 0 7
46747: PUSH
46748: LD_EXP 101
46752: PUSH
46753: LD_VAR 0 2
46757: ARRAY
46758: PPUSH
46759: LD_INT 3
46761: PUSH
46762: LD_INT 30
46764: PUSH
46765: LD_INT 32
46767: PUSH
46768: EMPTY
46769: LIST
46770: LIST
46771: PUSH
46772: LD_INT 30
46774: PUSH
46775: LD_INT 33
46777: PUSH
46778: EMPTY
46779: LIST
46780: LIST
46781: PUSH
46782: LD_INT 30
46784: PUSH
46785: LD_INT 31
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: PPUSH
46798: CALL_OW 72
46802: ST_TO_ADDR
// if not to_repair_tmp then
46803: LD_VAR 0 7
46807: NOT
46808: IFFALSE 46812
// continue ;
46810: GO 46610
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46812: LD_ADDR_VAR 0 8
46816: PUSH
46817: LD_VAR 0 7
46821: PPUSH
46822: LD_VAR 0 3
46826: PPUSH
46827: CALL_OW 74
46831: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46832: LD_VAR 0 8
46836: PPUSH
46837: LD_INT 16
46839: PPUSH
46840: CALL 75270 0 2
46844: PUSH
46845: LD_INT 4
46847: ARRAY
46848: PUSH
46849: LD_INT 14
46851: LESS
46852: IFFALSE 46868
// ComRepairBuilding ( j , to_repair ) ;
46854: LD_VAR 0 3
46858: PPUSH
46859: LD_VAR 0 8
46863: PPUSH
46864: CALL_OW 130
// end ;
46868: GO 46610
46870: POP
46871: POP
// end ;
46872: GO 45980
46874: POP
46875: POP
// end ;
46876: LD_VAR 0 1
46880: RET
// export function MC_Heal ; var i , j , tmp ; begin
46881: LD_INT 0
46883: PPUSH
46884: PPUSH
46885: PPUSH
46886: PPUSH
// if not mc_bases then
46887: LD_EXP 100
46891: NOT
46892: IFFALSE 46896
// exit ;
46894: GO 47298
// for i = 1 to mc_bases do
46896: LD_ADDR_VAR 0 2
46900: PUSH
46901: DOUBLE
46902: LD_INT 1
46904: DEC
46905: ST_TO_ADDR
46906: LD_EXP 100
46910: PUSH
46911: FOR_TO
46912: IFFALSE 47296
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46914: LD_EXP 103
46918: PUSH
46919: LD_VAR 0 2
46923: ARRAY
46924: PUSH
46925: LD_INT 1
46927: ARRAY
46928: NOT
46929: PUSH
46930: LD_EXP 103
46934: PUSH
46935: LD_VAR 0 2
46939: ARRAY
46940: PUSH
46941: LD_INT 2
46943: ARRAY
46944: NOT
46945: AND
46946: IFFALSE 46984
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46948: LD_ADDR_EXP 104
46952: PUSH
46953: LD_EXP 104
46957: PPUSH
46958: LD_VAR 0 2
46962: PPUSH
46963: EMPTY
46964: PPUSH
46965: CALL_OW 1
46969: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46970: LD_VAR 0 2
46974: PPUSH
46975: LD_INT 102
46977: PPUSH
46978: CALL 41033 0 2
// continue ;
46982: GO 46911
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46984: LD_ADDR_VAR 0 4
46988: PUSH
46989: LD_EXP 100
46993: PUSH
46994: LD_VAR 0 2
46998: ARRAY
46999: PPUSH
47000: LD_INT 25
47002: PUSH
47003: LD_INT 4
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PPUSH
47010: CALL_OW 72
47014: ST_TO_ADDR
// if not tmp then
47015: LD_VAR 0 4
47019: NOT
47020: IFFALSE 47024
// continue ;
47022: GO 46911
// if mc_taming [ i ] then
47024: LD_EXP 131
47028: PUSH
47029: LD_VAR 0 2
47033: ARRAY
47034: IFFALSE 47058
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
47036: LD_ADDR_EXP 131
47040: PUSH
47041: LD_EXP 131
47045: PPUSH
47046: LD_VAR 0 2
47050: PPUSH
47051: EMPTY
47052: PPUSH
47053: CALL_OW 1
47057: ST_TO_ADDR
// for j in tmp do
47058: LD_ADDR_VAR 0 3
47062: PUSH
47063: LD_VAR 0 4
47067: PUSH
47068: FOR_IN
47069: IFFALSE 47292
// begin if IsInUnit ( j ) then
47071: LD_VAR 0 3
47075: PPUSH
47076: CALL_OW 310
47080: IFFALSE 47091
// ComExitBuilding ( j ) ;
47082: LD_VAR 0 3
47086: PPUSH
47087: CALL_OW 122
// if not j in mc_healers [ i ] then
47091: LD_VAR 0 3
47095: PUSH
47096: LD_EXP 104
47100: PUSH
47101: LD_VAR 0 2
47105: ARRAY
47106: IN
47107: NOT
47108: IFFALSE 47154
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
47110: LD_ADDR_EXP 104
47114: PUSH
47115: LD_EXP 104
47119: PPUSH
47120: LD_VAR 0 2
47124: PUSH
47125: LD_EXP 104
47129: PUSH
47130: LD_VAR 0 2
47134: ARRAY
47135: PUSH
47136: LD_INT 1
47138: PLUS
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PPUSH
47144: LD_VAR 0 3
47148: PPUSH
47149: CALL 72673 0 3
47153: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
47154: LD_VAR 0 3
47158: PPUSH
47159: CALL_OW 110
47163: PUSH
47164: LD_INT 102
47166: NONEQUAL
47167: IFFALSE 47181
// SetTag ( j , 102 ) ;
47169: LD_VAR 0 3
47173: PPUSH
47174: LD_INT 102
47176: PPUSH
47177: CALL_OW 109
// Wait ( 3 ) ;
47181: LD_INT 3
47183: PPUSH
47184: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
47188: LD_EXP 103
47192: PUSH
47193: LD_VAR 0 2
47197: ARRAY
47198: PUSH
47199: LD_INT 1
47201: ARRAY
47202: IFFALSE 47234
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
47204: LD_VAR 0 3
47208: PPUSH
47209: LD_EXP 103
47213: PUSH
47214: LD_VAR 0 2
47218: ARRAY
47219: PUSH
47220: LD_INT 1
47222: ARRAY
47223: PUSH
47224: LD_INT 1
47226: ARRAY
47227: PPUSH
47228: CALL_OW 128
47232: GO 47290
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
47234: LD_VAR 0 3
47238: PPUSH
47239: CALL_OW 314
47243: NOT
47244: PUSH
47245: LD_EXP 103
47249: PUSH
47250: LD_VAR 0 2
47254: ARRAY
47255: PUSH
47256: LD_INT 2
47258: ARRAY
47259: AND
47260: IFFALSE 47290
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
47262: LD_VAR 0 3
47266: PPUSH
47267: LD_EXP 103
47271: PUSH
47272: LD_VAR 0 2
47276: ARRAY
47277: PUSH
47278: LD_INT 2
47280: ARRAY
47281: PUSH
47282: LD_INT 1
47284: ARRAY
47285: PPUSH
47286: CALL_OW 128
// end ;
47290: GO 47068
47292: POP
47293: POP
// end ;
47294: GO 46911
47296: POP
47297: POP
// end ;
47298: LD_VAR 0 1
47302: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47303: LD_INT 0
47305: PPUSH
47306: PPUSH
47307: PPUSH
47308: PPUSH
47309: PPUSH
47310: PPUSH
// if not mc_bases then
47311: LD_EXP 100
47315: NOT
47316: IFFALSE 47320
// exit ;
47318: GO 48483
// for i = 1 to mc_bases do
47320: LD_ADDR_VAR 0 2
47324: PUSH
47325: DOUBLE
47326: LD_INT 1
47328: DEC
47329: ST_TO_ADDR
47330: LD_EXP 100
47334: PUSH
47335: FOR_TO
47336: IFFALSE 48481
// begin if mc_scan [ i ] then
47338: LD_EXP 123
47342: PUSH
47343: LD_VAR 0 2
47347: ARRAY
47348: IFFALSE 47352
// continue ;
47350: GO 47335
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47352: LD_EXP 105
47356: PUSH
47357: LD_VAR 0 2
47361: ARRAY
47362: NOT
47363: PUSH
47364: LD_EXP 107
47368: PUSH
47369: LD_VAR 0 2
47373: ARRAY
47374: NOT
47375: AND
47376: PUSH
47377: LD_EXP 106
47381: PUSH
47382: LD_VAR 0 2
47386: ARRAY
47387: AND
47388: IFFALSE 47426
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47390: LD_ADDR_EXP 106
47394: PUSH
47395: LD_EXP 106
47399: PPUSH
47400: LD_VAR 0 2
47404: PPUSH
47405: EMPTY
47406: PPUSH
47407: CALL_OW 1
47411: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47412: LD_VAR 0 2
47416: PPUSH
47417: LD_INT 103
47419: PPUSH
47420: CALL 41033 0 2
// continue ;
47424: GO 47335
// end ; if mc_construct_list [ i ] then
47426: LD_EXP 107
47430: PUSH
47431: LD_VAR 0 2
47435: ARRAY
47436: IFFALSE 47656
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47438: LD_ADDR_VAR 0 5
47442: PUSH
47443: LD_EXP 100
47447: PUSH
47448: LD_VAR 0 2
47452: ARRAY
47453: PPUSH
47454: LD_INT 25
47456: PUSH
47457: LD_INT 2
47459: PUSH
47460: EMPTY
47461: LIST
47462: LIST
47463: PPUSH
47464: CALL_OW 72
47468: PUSH
47469: LD_EXP 102
47473: PUSH
47474: LD_VAR 0 2
47478: ARRAY
47479: DIFF
47480: ST_TO_ADDR
// if not tmp then
47481: LD_VAR 0 5
47485: NOT
47486: IFFALSE 47490
// continue ;
47488: GO 47335
// for j in tmp do
47490: LD_ADDR_VAR 0 3
47494: PUSH
47495: LD_VAR 0 5
47499: PUSH
47500: FOR_IN
47501: IFFALSE 47652
// begin if not mc_builders [ i ] then
47503: LD_EXP 106
47507: PUSH
47508: LD_VAR 0 2
47512: ARRAY
47513: NOT
47514: IFFALSE 47572
// begin SetTag ( j , 103 ) ;
47516: LD_VAR 0 3
47520: PPUSH
47521: LD_INT 103
47523: PPUSH
47524: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47528: LD_ADDR_EXP 106
47532: PUSH
47533: LD_EXP 106
47537: PPUSH
47538: LD_VAR 0 2
47542: PUSH
47543: LD_EXP 106
47547: PUSH
47548: LD_VAR 0 2
47552: ARRAY
47553: PUSH
47554: LD_INT 1
47556: PLUS
47557: PUSH
47558: EMPTY
47559: LIST
47560: LIST
47561: PPUSH
47562: LD_VAR 0 3
47566: PPUSH
47567: CALL 72673 0 3
47571: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47572: LD_VAR 0 3
47576: PPUSH
47577: CALL_OW 310
47581: IFFALSE 47592
// ComExitBuilding ( j ) ;
47583: LD_VAR 0 3
47587: PPUSH
47588: CALL_OW 122
// wait ( 3 ) ;
47592: LD_INT 3
47594: PPUSH
47595: CALL_OW 67
// if not mc_construct_list [ i ] then
47599: LD_EXP 107
47603: PUSH
47604: LD_VAR 0 2
47608: ARRAY
47609: NOT
47610: IFFALSE 47614
// break ;
47612: GO 47652
// if not HasTask ( j ) then
47614: LD_VAR 0 3
47618: PPUSH
47619: CALL_OW 314
47623: NOT
47624: IFFALSE 47650
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47626: LD_VAR 0 3
47630: PPUSH
47631: LD_EXP 107
47635: PUSH
47636: LD_VAR 0 2
47640: ARRAY
47641: PUSH
47642: LD_INT 1
47644: ARRAY
47645: PPUSH
47646: CALL 75534 0 2
// end ;
47650: GO 47500
47652: POP
47653: POP
// end else
47654: GO 48479
// if mc_build_list [ i ] then
47656: LD_EXP 105
47660: PUSH
47661: LD_VAR 0 2
47665: ARRAY
47666: IFFALSE 48479
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47668: LD_EXP 105
47672: PUSH
47673: LD_VAR 0 2
47677: ARRAY
47678: PUSH
47679: LD_INT 1
47681: ARRAY
47682: PUSH
47683: LD_INT 1
47685: ARRAY
47686: PPUSH
47687: CALL 75358 0 1
47691: PUSH
47692: LD_EXP 100
47696: PUSH
47697: LD_VAR 0 2
47701: ARRAY
47702: PPUSH
47703: LD_INT 2
47705: PUSH
47706: LD_INT 30
47708: PUSH
47709: LD_INT 2
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: LD_INT 30
47718: PUSH
47719: LD_INT 3
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: PUSH
47726: EMPTY
47727: LIST
47728: LIST
47729: LIST
47730: PPUSH
47731: CALL_OW 72
47735: NOT
47736: AND
47737: IFFALSE 47842
// begin for j = 1 to mc_build_list [ i ] do
47739: LD_ADDR_VAR 0 3
47743: PUSH
47744: DOUBLE
47745: LD_INT 1
47747: DEC
47748: ST_TO_ADDR
47749: LD_EXP 105
47753: PUSH
47754: LD_VAR 0 2
47758: ARRAY
47759: PUSH
47760: FOR_TO
47761: IFFALSE 47840
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47763: LD_EXP 105
47767: PUSH
47768: LD_VAR 0 2
47772: ARRAY
47773: PUSH
47774: LD_VAR 0 3
47778: ARRAY
47779: PUSH
47780: LD_INT 1
47782: ARRAY
47783: PUSH
47784: LD_INT 2
47786: EQUAL
47787: IFFALSE 47838
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47789: LD_ADDR_EXP 105
47793: PUSH
47794: LD_EXP 105
47798: PPUSH
47799: LD_VAR 0 2
47803: PPUSH
47804: LD_EXP 105
47808: PUSH
47809: LD_VAR 0 2
47813: ARRAY
47814: PPUSH
47815: LD_VAR 0 3
47819: PPUSH
47820: LD_INT 1
47822: PPUSH
47823: LD_INT 0
47825: PPUSH
47826: CALL 72091 0 4
47830: PPUSH
47831: CALL_OW 1
47835: ST_TO_ADDR
// break ;
47836: GO 47840
// end ;
47838: GO 47760
47840: POP
47841: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47842: LD_ADDR_VAR 0 6
47846: PUSH
47847: LD_EXP 100
47851: PUSH
47852: LD_VAR 0 2
47856: ARRAY
47857: PPUSH
47858: LD_INT 2
47860: PUSH
47861: LD_INT 30
47863: PUSH
47864: LD_INT 0
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: PUSH
47871: LD_INT 30
47873: PUSH
47874: LD_INT 1
47876: PUSH
47877: EMPTY
47878: LIST
47879: LIST
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: LIST
47885: PPUSH
47886: CALL_OW 72
47890: ST_TO_ADDR
// for k := 1 to depot do
47891: LD_ADDR_VAR 0 4
47895: PUSH
47896: DOUBLE
47897: LD_INT 1
47899: DEC
47900: ST_TO_ADDR
47901: LD_VAR 0 6
47905: PUSH
47906: FOR_TO
47907: IFFALSE 48477
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47909: LD_EXP 105
47913: PUSH
47914: LD_VAR 0 2
47918: ARRAY
47919: PUSH
47920: LD_INT 1
47922: ARRAY
47923: PUSH
47924: LD_INT 1
47926: ARRAY
47927: PUSH
47928: LD_INT 0
47930: EQUAL
47931: PUSH
47932: LD_VAR 0 6
47936: PUSH
47937: LD_VAR 0 4
47941: ARRAY
47942: PPUSH
47943: LD_EXP 105
47947: PUSH
47948: LD_VAR 0 2
47952: ARRAY
47953: PUSH
47954: LD_INT 1
47956: ARRAY
47957: PUSH
47958: LD_INT 1
47960: ARRAY
47961: PPUSH
47962: LD_EXP 105
47966: PUSH
47967: LD_VAR 0 2
47971: ARRAY
47972: PUSH
47973: LD_INT 1
47975: ARRAY
47976: PUSH
47977: LD_INT 2
47979: ARRAY
47980: PPUSH
47981: LD_EXP 105
47985: PUSH
47986: LD_VAR 0 2
47990: ARRAY
47991: PUSH
47992: LD_INT 1
47994: ARRAY
47995: PUSH
47996: LD_INT 3
47998: ARRAY
47999: PPUSH
48000: LD_EXP 105
48004: PUSH
48005: LD_VAR 0 2
48009: ARRAY
48010: PUSH
48011: LD_INT 1
48013: ARRAY
48014: PUSH
48015: LD_INT 4
48017: ARRAY
48018: PPUSH
48019: CALL 80770 0 5
48023: OR
48024: IFFALSE 48305
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48026: LD_ADDR_VAR 0 5
48030: PUSH
48031: LD_EXP 100
48035: PUSH
48036: LD_VAR 0 2
48040: ARRAY
48041: PPUSH
48042: LD_INT 25
48044: PUSH
48045: LD_INT 2
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: PPUSH
48052: CALL_OW 72
48056: PUSH
48057: LD_EXP 102
48061: PUSH
48062: LD_VAR 0 2
48066: ARRAY
48067: DIFF
48068: ST_TO_ADDR
// if not tmp then
48069: LD_VAR 0 5
48073: NOT
48074: IFFALSE 48078
// continue ;
48076: GO 47906
// for j in tmp do
48078: LD_ADDR_VAR 0 3
48082: PUSH
48083: LD_VAR 0 5
48087: PUSH
48088: FOR_IN
48089: IFFALSE 48301
// begin if not mc_builders [ i ] then
48091: LD_EXP 106
48095: PUSH
48096: LD_VAR 0 2
48100: ARRAY
48101: NOT
48102: IFFALSE 48160
// begin SetTag ( j , 103 ) ;
48104: LD_VAR 0 3
48108: PPUSH
48109: LD_INT 103
48111: PPUSH
48112: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
48116: LD_ADDR_EXP 106
48120: PUSH
48121: LD_EXP 106
48125: PPUSH
48126: LD_VAR 0 2
48130: PUSH
48131: LD_EXP 106
48135: PUSH
48136: LD_VAR 0 2
48140: ARRAY
48141: PUSH
48142: LD_INT 1
48144: PLUS
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PPUSH
48150: LD_VAR 0 3
48154: PPUSH
48155: CALL 72673 0 3
48159: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
48160: LD_VAR 0 3
48164: PPUSH
48165: CALL_OW 310
48169: IFFALSE 48180
// ComExitBuilding ( j ) ;
48171: LD_VAR 0 3
48175: PPUSH
48176: CALL_OW 122
// wait ( 3 ) ;
48180: LD_INT 3
48182: PPUSH
48183: CALL_OW 67
// if not mc_build_list [ i ] then
48187: LD_EXP 105
48191: PUSH
48192: LD_VAR 0 2
48196: ARRAY
48197: NOT
48198: IFFALSE 48202
// break ;
48200: GO 48301
// if not HasTask ( j ) then
48202: LD_VAR 0 3
48206: PPUSH
48207: CALL_OW 314
48211: NOT
48212: IFFALSE 48299
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
48214: LD_VAR 0 3
48218: PPUSH
48219: LD_EXP 105
48223: PUSH
48224: LD_VAR 0 2
48228: ARRAY
48229: PUSH
48230: LD_INT 1
48232: ARRAY
48233: PUSH
48234: LD_INT 1
48236: ARRAY
48237: PPUSH
48238: LD_EXP 105
48242: PUSH
48243: LD_VAR 0 2
48247: ARRAY
48248: PUSH
48249: LD_INT 1
48251: ARRAY
48252: PUSH
48253: LD_INT 2
48255: ARRAY
48256: PPUSH
48257: LD_EXP 105
48261: PUSH
48262: LD_VAR 0 2
48266: ARRAY
48267: PUSH
48268: LD_INT 1
48270: ARRAY
48271: PUSH
48272: LD_INT 3
48274: ARRAY
48275: PPUSH
48276: LD_EXP 105
48280: PUSH
48281: LD_VAR 0 2
48285: ARRAY
48286: PUSH
48287: LD_INT 1
48289: ARRAY
48290: PUSH
48291: LD_INT 4
48293: ARRAY
48294: PPUSH
48295: CALL_OW 145
// end ;
48299: GO 48088
48301: POP
48302: POP
// end else
48303: GO 48475
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48305: LD_EXP 100
48309: PUSH
48310: LD_VAR 0 2
48314: ARRAY
48315: PPUSH
48316: LD_EXP 105
48320: PUSH
48321: LD_VAR 0 2
48325: ARRAY
48326: PUSH
48327: LD_INT 1
48329: ARRAY
48330: PUSH
48331: LD_INT 1
48333: ARRAY
48334: PPUSH
48335: LD_EXP 105
48339: PUSH
48340: LD_VAR 0 2
48344: ARRAY
48345: PUSH
48346: LD_INT 1
48348: ARRAY
48349: PUSH
48350: LD_INT 2
48352: ARRAY
48353: PPUSH
48354: LD_EXP 105
48358: PUSH
48359: LD_VAR 0 2
48363: ARRAY
48364: PUSH
48365: LD_INT 1
48367: ARRAY
48368: PUSH
48369: LD_INT 3
48371: ARRAY
48372: PPUSH
48373: LD_EXP 105
48377: PUSH
48378: LD_VAR 0 2
48382: ARRAY
48383: PUSH
48384: LD_INT 1
48386: ARRAY
48387: PUSH
48388: LD_INT 4
48390: ARRAY
48391: PPUSH
48392: LD_EXP 100
48396: PUSH
48397: LD_VAR 0 2
48401: ARRAY
48402: PPUSH
48403: LD_INT 21
48405: PUSH
48406: LD_INT 3
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: PPUSH
48413: CALL_OW 72
48417: PPUSH
48418: EMPTY
48419: PPUSH
48420: CALL 79524 0 7
48424: NOT
48425: IFFALSE 48475
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48427: LD_ADDR_EXP 105
48431: PUSH
48432: LD_EXP 105
48436: PPUSH
48437: LD_VAR 0 2
48441: PPUSH
48442: LD_EXP 105
48446: PUSH
48447: LD_VAR 0 2
48451: ARRAY
48452: PPUSH
48453: LD_INT 1
48455: PPUSH
48456: LD_INT 1
48458: NEG
48459: PPUSH
48460: LD_INT 0
48462: PPUSH
48463: CALL 72091 0 4
48467: PPUSH
48468: CALL_OW 1
48472: ST_TO_ADDR
// continue ;
48473: GO 47906
// end ; end ;
48475: GO 47906
48477: POP
48478: POP
// end ; end ;
48479: GO 47335
48481: POP
48482: POP
// end ;
48483: LD_VAR 0 1
48487: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48488: LD_INT 0
48490: PPUSH
48491: PPUSH
48492: PPUSH
48493: PPUSH
48494: PPUSH
48495: PPUSH
// if not mc_bases then
48496: LD_EXP 100
48500: NOT
48501: IFFALSE 48505
// exit ;
48503: GO 48932
// for i = 1 to mc_bases do
48505: LD_ADDR_VAR 0 2
48509: PUSH
48510: DOUBLE
48511: LD_INT 1
48513: DEC
48514: ST_TO_ADDR
48515: LD_EXP 100
48519: PUSH
48520: FOR_TO
48521: IFFALSE 48930
// begin tmp := mc_build_upgrade [ i ] ;
48523: LD_ADDR_VAR 0 4
48527: PUSH
48528: LD_EXP 132
48532: PUSH
48533: LD_VAR 0 2
48537: ARRAY
48538: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48539: LD_ADDR_VAR 0 6
48543: PUSH
48544: LD_EXP 133
48548: PUSH
48549: LD_VAR 0 2
48553: ARRAY
48554: PPUSH
48555: LD_INT 2
48557: PUSH
48558: LD_INT 30
48560: PUSH
48561: LD_INT 6
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 30
48570: PUSH
48571: LD_INT 7
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: EMPTY
48579: LIST
48580: LIST
48581: LIST
48582: PPUSH
48583: CALL_OW 72
48587: ST_TO_ADDR
// if not tmp and not lab then
48588: LD_VAR 0 4
48592: NOT
48593: PUSH
48594: LD_VAR 0 6
48598: NOT
48599: AND
48600: IFFALSE 48604
// continue ;
48602: GO 48520
// if tmp then
48604: LD_VAR 0 4
48608: IFFALSE 48728
// for j in tmp do
48610: LD_ADDR_VAR 0 3
48614: PUSH
48615: LD_VAR 0 4
48619: PUSH
48620: FOR_IN
48621: IFFALSE 48726
// begin if UpgradeCost ( j ) then
48623: LD_VAR 0 3
48627: PPUSH
48628: CALL 79184 0 1
48632: IFFALSE 48724
// begin ComUpgrade ( j ) ;
48634: LD_VAR 0 3
48638: PPUSH
48639: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48643: LD_ADDR_EXP 132
48647: PUSH
48648: LD_EXP 132
48652: PPUSH
48653: LD_VAR 0 2
48657: PPUSH
48658: LD_EXP 132
48662: PUSH
48663: LD_VAR 0 2
48667: ARRAY
48668: PUSH
48669: LD_VAR 0 3
48673: DIFF
48674: PPUSH
48675: CALL_OW 1
48679: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48680: LD_ADDR_EXP 107
48684: PUSH
48685: LD_EXP 107
48689: PPUSH
48690: LD_VAR 0 2
48694: PUSH
48695: LD_EXP 107
48699: PUSH
48700: LD_VAR 0 2
48704: ARRAY
48705: PUSH
48706: LD_INT 1
48708: PLUS
48709: PUSH
48710: EMPTY
48711: LIST
48712: LIST
48713: PPUSH
48714: LD_VAR 0 3
48718: PPUSH
48719: CALL 72673 0 3
48723: ST_TO_ADDR
// end ; end ;
48724: GO 48620
48726: POP
48727: POP
// if not lab or not mc_lab_upgrade [ i ] then
48728: LD_VAR 0 6
48732: NOT
48733: PUSH
48734: LD_EXP 134
48738: PUSH
48739: LD_VAR 0 2
48743: ARRAY
48744: NOT
48745: OR
48746: IFFALSE 48750
// continue ;
48748: GO 48520
// for j in lab do
48750: LD_ADDR_VAR 0 3
48754: PUSH
48755: LD_VAR 0 6
48759: PUSH
48760: FOR_IN
48761: IFFALSE 48926
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48763: LD_VAR 0 3
48767: PPUSH
48768: CALL_OW 266
48772: PUSH
48773: LD_INT 6
48775: PUSH
48776: LD_INT 7
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: IN
48783: PUSH
48784: LD_VAR 0 3
48788: PPUSH
48789: CALL_OW 461
48793: PUSH
48794: LD_INT 1
48796: NONEQUAL
48797: AND
48798: IFFALSE 48924
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48800: LD_VAR 0 3
48804: PPUSH
48805: LD_EXP 134
48809: PUSH
48810: LD_VAR 0 2
48814: ARRAY
48815: PUSH
48816: LD_INT 1
48818: ARRAY
48819: PPUSH
48820: CALL 79389 0 2
48824: IFFALSE 48924
// begin ComCancel ( j ) ;
48826: LD_VAR 0 3
48830: PPUSH
48831: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48835: LD_VAR 0 3
48839: PPUSH
48840: LD_EXP 134
48844: PUSH
48845: LD_VAR 0 2
48849: ARRAY
48850: PUSH
48851: LD_INT 1
48853: ARRAY
48854: PPUSH
48855: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48859: LD_VAR 0 3
48863: PUSH
48864: LD_EXP 107
48868: PUSH
48869: LD_VAR 0 2
48873: ARRAY
48874: IN
48875: NOT
48876: IFFALSE 48922
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48878: LD_ADDR_EXP 107
48882: PUSH
48883: LD_EXP 107
48887: PPUSH
48888: LD_VAR 0 2
48892: PUSH
48893: LD_EXP 107
48897: PUSH
48898: LD_VAR 0 2
48902: ARRAY
48903: PUSH
48904: LD_INT 1
48906: PLUS
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: PPUSH
48912: LD_VAR 0 3
48916: PPUSH
48917: CALL 72673 0 3
48921: ST_TO_ADDR
// break ;
48922: GO 48926
// end ; end ; end ;
48924: GO 48760
48926: POP
48927: POP
// end ;
48928: GO 48520
48930: POP
48931: POP
// end ;
48932: LD_VAR 0 1
48936: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48937: LD_INT 0
48939: PPUSH
48940: PPUSH
48941: PPUSH
48942: PPUSH
48943: PPUSH
48944: PPUSH
48945: PPUSH
48946: PPUSH
48947: PPUSH
// if not mc_bases then
48948: LD_EXP 100
48952: NOT
48953: IFFALSE 48957
// exit ;
48955: GO 49362
// for i = 1 to mc_bases do
48957: LD_ADDR_VAR 0 2
48961: PUSH
48962: DOUBLE
48963: LD_INT 1
48965: DEC
48966: ST_TO_ADDR
48967: LD_EXP 100
48971: PUSH
48972: FOR_TO
48973: IFFALSE 49360
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48975: LD_EXP 108
48979: PUSH
48980: LD_VAR 0 2
48984: ARRAY
48985: NOT
48986: PUSH
48987: LD_EXP 100
48991: PUSH
48992: LD_VAR 0 2
48996: ARRAY
48997: PPUSH
48998: LD_INT 30
49000: PUSH
49001: LD_INT 3
49003: PUSH
49004: EMPTY
49005: LIST
49006: LIST
49007: PPUSH
49008: CALL_OW 72
49012: NOT
49013: OR
49014: IFFALSE 49018
// continue ;
49016: GO 48972
// busy := false ;
49018: LD_ADDR_VAR 0 8
49022: PUSH
49023: LD_INT 0
49025: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49026: LD_ADDR_VAR 0 4
49030: PUSH
49031: LD_EXP 100
49035: PUSH
49036: LD_VAR 0 2
49040: ARRAY
49041: PPUSH
49042: LD_INT 30
49044: PUSH
49045: LD_INT 3
49047: PUSH
49048: EMPTY
49049: LIST
49050: LIST
49051: PPUSH
49052: CALL_OW 72
49056: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
49057: LD_ADDR_VAR 0 6
49061: PUSH
49062: LD_EXP 108
49066: PUSH
49067: LD_VAR 0 2
49071: ARRAY
49072: PPUSH
49073: LD_INT 2
49075: PUSH
49076: LD_INT 30
49078: PUSH
49079: LD_INT 32
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: PUSH
49086: LD_INT 30
49088: PUSH
49089: LD_INT 33
49091: PUSH
49092: EMPTY
49093: LIST
49094: LIST
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: LIST
49100: PPUSH
49101: CALL_OW 72
49105: ST_TO_ADDR
// if not t then
49106: LD_VAR 0 6
49110: NOT
49111: IFFALSE 49115
// continue ;
49113: GO 48972
// for j in tmp do
49115: LD_ADDR_VAR 0 3
49119: PUSH
49120: LD_VAR 0 4
49124: PUSH
49125: FOR_IN
49126: IFFALSE 49156
// if not BuildingStatus ( j ) = bs_idle then
49128: LD_VAR 0 3
49132: PPUSH
49133: CALL_OW 461
49137: PUSH
49138: LD_INT 2
49140: EQUAL
49141: NOT
49142: IFFALSE 49154
// begin busy := true ;
49144: LD_ADDR_VAR 0 8
49148: PUSH
49149: LD_INT 1
49151: ST_TO_ADDR
// break ;
49152: GO 49156
// end ;
49154: GO 49125
49156: POP
49157: POP
// if busy then
49158: LD_VAR 0 8
49162: IFFALSE 49166
// continue ;
49164: GO 48972
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
49166: LD_ADDR_VAR 0 7
49170: PUSH
49171: LD_VAR 0 6
49175: PPUSH
49176: LD_INT 35
49178: PUSH
49179: LD_INT 0
49181: PUSH
49182: EMPTY
49183: LIST
49184: LIST
49185: PPUSH
49186: CALL_OW 72
49190: ST_TO_ADDR
// if tw then
49191: LD_VAR 0 7
49195: IFFALSE 49272
// begin tw := tw [ 1 ] ;
49197: LD_ADDR_VAR 0 7
49201: PUSH
49202: LD_VAR 0 7
49206: PUSH
49207: LD_INT 1
49209: ARRAY
49210: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
49211: LD_ADDR_VAR 0 9
49215: PUSH
49216: LD_VAR 0 7
49220: PPUSH
49221: LD_EXP 125
49225: PUSH
49226: LD_VAR 0 2
49230: ARRAY
49231: PPUSH
49232: CALL 77681 0 2
49236: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
49237: LD_EXP 139
49241: PUSH
49242: LD_VAR 0 2
49246: ARRAY
49247: IFFALSE 49270
// if not weapon in mc_allowed_tower_weapons [ i ] then
49249: LD_VAR 0 9
49253: PUSH
49254: LD_EXP 139
49258: PUSH
49259: LD_VAR 0 2
49263: ARRAY
49264: IN
49265: NOT
49266: IFFALSE 49270
// continue ;
49268: GO 48972
// end else
49270: GO 49335
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
49272: LD_ADDR_VAR 0 5
49276: PUSH
49277: LD_EXP 108
49281: PUSH
49282: LD_VAR 0 2
49286: ARRAY
49287: PPUSH
49288: LD_VAR 0 4
49292: PPUSH
49293: CALL 104533 0 2
49297: ST_TO_ADDR
// if not tmp2 then
49298: LD_VAR 0 5
49302: NOT
49303: IFFALSE 49307
// continue ;
49305: GO 48972
// tw := tmp2 [ 1 ] ;
49307: LD_ADDR_VAR 0 7
49311: PUSH
49312: LD_VAR 0 5
49316: PUSH
49317: LD_INT 1
49319: ARRAY
49320: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49321: LD_ADDR_VAR 0 9
49325: PUSH
49326: LD_VAR 0 5
49330: PUSH
49331: LD_INT 2
49333: ARRAY
49334: ST_TO_ADDR
// end ; if not weapon then
49335: LD_VAR 0 9
49339: NOT
49340: IFFALSE 49344
// continue ;
49342: GO 48972
// ComPlaceWeapon ( tw , weapon ) ;
49344: LD_VAR 0 7
49348: PPUSH
49349: LD_VAR 0 9
49353: PPUSH
49354: CALL_OW 148
// end ;
49358: GO 48972
49360: POP
49361: POP
// end ;
49362: LD_VAR 0 1
49366: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49367: LD_INT 0
49369: PPUSH
49370: PPUSH
49371: PPUSH
49372: PPUSH
49373: PPUSH
49374: PPUSH
49375: PPUSH
// if not mc_bases then
49376: LD_EXP 100
49380: NOT
49381: IFFALSE 49385
// exit ;
49383: GO 50153
// for i = 1 to mc_bases do
49385: LD_ADDR_VAR 0 2
49389: PUSH
49390: DOUBLE
49391: LD_INT 1
49393: DEC
49394: ST_TO_ADDR
49395: LD_EXP 100
49399: PUSH
49400: FOR_TO
49401: IFFALSE 50151
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49403: LD_EXP 113
49407: PUSH
49408: LD_VAR 0 2
49412: ARRAY
49413: NOT
49414: PUSH
49415: LD_EXP 113
49419: PUSH
49420: LD_VAR 0 2
49424: ARRAY
49425: PUSH
49426: LD_EXP 114
49430: PUSH
49431: LD_VAR 0 2
49435: ARRAY
49436: EQUAL
49437: OR
49438: PUSH
49439: LD_EXP 123
49443: PUSH
49444: LD_VAR 0 2
49448: ARRAY
49449: OR
49450: IFFALSE 49454
// continue ;
49452: GO 49400
// if mc_miners [ i ] then
49454: LD_EXP 114
49458: PUSH
49459: LD_VAR 0 2
49463: ARRAY
49464: IFFALSE 49838
// begin for j = mc_miners [ i ] downto 1 do
49466: LD_ADDR_VAR 0 3
49470: PUSH
49471: DOUBLE
49472: LD_EXP 114
49476: PUSH
49477: LD_VAR 0 2
49481: ARRAY
49482: INC
49483: ST_TO_ADDR
49484: LD_INT 1
49486: PUSH
49487: FOR_DOWNTO
49488: IFFALSE 49836
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49490: LD_EXP 114
49494: PUSH
49495: LD_VAR 0 2
49499: ARRAY
49500: PUSH
49501: LD_VAR 0 3
49505: ARRAY
49506: PPUSH
49507: CALL_OW 301
49511: PUSH
49512: LD_EXP 114
49516: PUSH
49517: LD_VAR 0 2
49521: ARRAY
49522: PUSH
49523: LD_VAR 0 3
49527: ARRAY
49528: PPUSH
49529: CALL_OW 257
49533: PUSH
49534: LD_INT 1
49536: NONEQUAL
49537: OR
49538: IFFALSE 49601
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49540: LD_ADDR_VAR 0 5
49544: PUSH
49545: LD_EXP 114
49549: PUSH
49550: LD_VAR 0 2
49554: ARRAY
49555: PUSH
49556: LD_EXP 114
49560: PUSH
49561: LD_VAR 0 2
49565: ARRAY
49566: PUSH
49567: LD_VAR 0 3
49571: ARRAY
49572: DIFF
49573: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49574: LD_ADDR_EXP 114
49578: PUSH
49579: LD_EXP 114
49583: PPUSH
49584: LD_VAR 0 2
49588: PPUSH
49589: LD_VAR 0 5
49593: PPUSH
49594: CALL_OW 1
49598: ST_TO_ADDR
// continue ;
49599: GO 49487
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49601: LD_EXP 114
49605: PUSH
49606: LD_VAR 0 2
49610: ARRAY
49611: PUSH
49612: LD_VAR 0 3
49616: ARRAY
49617: PPUSH
49618: CALL_OW 257
49622: PUSH
49623: LD_INT 1
49625: EQUAL
49626: PUSH
49627: LD_EXP 114
49631: PUSH
49632: LD_VAR 0 2
49636: ARRAY
49637: PUSH
49638: LD_VAR 0 3
49642: ARRAY
49643: PPUSH
49644: CALL_OW 459
49648: NOT
49649: AND
49650: PUSH
49651: LD_EXP 114
49655: PUSH
49656: LD_VAR 0 2
49660: ARRAY
49661: PUSH
49662: LD_VAR 0 3
49666: ARRAY
49667: PPUSH
49668: CALL_OW 314
49672: NOT
49673: AND
49674: IFFALSE 49834
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49676: LD_EXP 114
49680: PUSH
49681: LD_VAR 0 2
49685: ARRAY
49686: PUSH
49687: LD_VAR 0 3
49691: ARRAY
49692: PPUSH
49693: CALL_OW 310
49697: IFFALSE 49720
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49699: LD_EXP 114
49703: PUSH
49704: LD_VAR 0 2
49708: ARRAY
49709: PUSH
49710: LD_VAR 0 3
49714: ARRAY
49715: PPUSH
49716: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49720: LD_EXP 114
49724: PUSH
49725: LD_VAR 0 2
49729: ARRAY
49730: PUSH
49731: LD_VAR 0 3
49735: ARRAY
49736: PPUSH
49737: CALL_OW 314
49741: NOT
49742: IFFALSE 49834
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49744: LD_ADDR_VAR 0 7
49748: PUSH
49749: LD_INT 1
49751: PPUSH
49752: LD_EXP 113
49756: PUSH
49757: LD_VAR 0 2
49761: ARRAY
49762: PPUSH
49763: CALL_OW 12
49767: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49768: LD_EXP 114
49772: PUSH
49773: LD_VAR 0 2
49777: ARRAY
49778: PUSH
49779: LD_VAR 0 3
49783: ARRAY
49784: PPUSH
49785: LD_EXP 113
49789: PUSH
49790: LD_VAR 0 2
49794: ARRAY
49795: PUSH
49796: LD_VAR 0 7
49800: ARRAY
49801: PUSH
49802: LD_INT 1
49804: ARRAY
49805: PPUSH
49806: LD_EXP 113
49810: PUSH
49811: LD_VAR 0 2
49815: ARRAY
49816: PUSH
49817: LD_VAR 0 7
49821: ARRAY
49822: PUSH
49823: LD_INT 2
49825: ARRAY
49826: PPUSH
49827: LD_INT 0
49829: PPUSH
49830: CALL_OW 193
// end ; end ; end ;
49834: GO 49487
49836: POP
49837: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49838: LD_ADDR_VAR 0 5
49842: PUSH
49843: LD_EXP 100
49847: PUSH
49848: LD_VAR 0 2
49852: ARRAY
49853: PPUSH
49854: LD_INT 2
49856: PUSH
49857: LD_INT 30
49859: PUSH
49860: LD_INT 4
49862: PUSH
49863: EMPTY
49864: LIST
49865: LIST
49866: PUSH
49867: LD_INT 30
49869: PUSH
49870: LD_INT 5
49872: PUSH
49873: EMPTY
49874: LIST
49875: LIST
49876: PUSH
49877: LD_INT 30
49879: PUSH
49880: LD_INT 32
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: PUSH
49887: EMPTY
49888: LIST
49889: LIST
49890: LIST
49891: LIST
49892: PPUSH
49893: CALL_OW 72
49897: ST_TO_ADDR
// if not tmp then
49898: LD_VAR 0 5
49902: NOT
49903: IFFALSE 49907
// continue ;
49905: GO 49400
// list := [ ] ;
49907: LD_ADDR_VAR 0 6
49911: PUSH
49912: EMPTY
49913: ST_TO_ADDR
// for j in tmp do
49914: LD_ADDR_VAR 0 3
49918: PUSH
49919: LD_VAR 0 5
49923: PUSH
49924: FOR_IN
49925: IFFALSE 49994
// begin for k in UnitsInside ( j ) do
49927: LD_ADDR_VAR 0 4
49931: PUSH
49932: LD_VAR 0 3
49936: PPUSH
49937: CALL_OW 313
49941: PUSH
49942: FOR_IN
49943: IFFALSE 49990
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49945: LD_VAR 0 4
49949: PPUSH
49950: CALL_OW 257
49954: PUSH
49955: LD_INT 1
49957: EQUAL
49958: PUSH
49959: LD_VAR 0 4
49963: PPUSH
49964: CALL_OW 459
49968: NOT
49969: AND
49970: IFFALSE 49988
// list := list ^ k ;
49972: LD_ADDR_VAR 0 6
49976: PUSH
49977: LD_VAR 0 6
49981: PUSH
49982: LD_VAR 0 4
49986: ADD
49987: ST_TO_ADDR
49988: GO 49942
49990: POP
49991: POP
// end ;
49992: GO 49924
49994: POP
49995: POP
// list := list diff mc_miners [ i ] ;
49996: LD_ADDR_VAR 0 6
50000: PUSH
50001: LD_VAR 0 6
50005: PUSH
50006: LD_EXP 114
50010: PUSH
50011: LD_VAR 0 2
50015: ARRAY
50016: DIFF
50017: ST_TO_ADDR
// if not list then
50018: LD_VAR 0 6
50022: NOT
50023: IFFALSE 50027
// continue ;
50025: GO 49400
// k := mc_mines [ i ] - mc_miners [ i ] ;
50027: LD_ADDR_VAR 0 4
50031: PUSH
50032: LD_EXP 113
50036: PUSH
50037: LD_VAR 0 2
50041: ARRAY
50042: PUSH
50043: LD_EXP 114
50047: PUSH
50048: LD_VAR 0 2
50052: ARRAY
50053: MINUS
50054: ST_TO_ADDR
// if k > list then
50055: LD_VAR 0 4
50059: PUSH
50060: LD_VAR 0 6
50064: GREATER
50065: IFFALSE 50077
// k := list ;
50067: LD_ADDR_VAR 0 4
50071: PUSH
50072: LD_VAR 0 6
50076: ST_TO_ADDR
// for j = 1 to k do
50077: LD_ADDR_VAR 0 3
50081: PUSH
50082: DOUBLE
50083: LD_INT 1
50085: DEC
50086: ST_TO_ADDR
50087: LD_VAR 0 4
50091: PUSH
50092: FOR_TO
50093: IFFALSE 50147
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
50095: LD_ADDR_EXP 114
50099: PUSH
50100: LD_EXP 114
50104: PPUSH
50105: LD_VAR 0 2
50109: PUSH
50110: LD_EXP 114
50114: PUSH
50115: LD_VAR 0 2
50119: ARRAY
50120: PUSH
50121: LD_INT 1
50123: PLUS
50124: PUSH
50125: EMPTY
50126: LIST
50127: LIST
50128: PPUSH
50129: LD_VAR 0 6
50133: PUSH
50134: LD_VAR 0 3
50138: ARRAY
50139: PPUSH
50140: CALL 72673 0 3
50144: ST_TO_ADDR
50145: GO 50092
50147: POP
50148: POP
// end ;
50149: GO 49400
50151: POP
50152: POP
// end ;
50153: LD_VAR 0 1
50157: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
50158: LD_INT 0
50160: PPUSH
50161: PPUSH
50162: PPUSH
50163: PPUSH
50164: PPUSH
50165: PPUSH
50166: PPUSH
50167: PPUSH
50168: PPUSH
50169: PPUSH
50170: PPUSH
// if not mc_bases then
50171: LD_EXP 100
50175: NOT
50176: IFFALSE 50180
// exit ;
50178: GO 52003
// for i = 1 to mc_bases do
50180: LD_ADDR_VAR 0 2
50184: PUSH
50185: DOUBLE
50186: LD_INT 1
50188: DEC
50189: ST_TO_ADDR
50190: LD_EXP 100
50194: PUSH
50195: FOR_TO
50196: IFFALSE 52001
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
50198: LD_EXP 100
50202: PUSH
50203: LD_VAR 0 2
50207: ARRAY
50208: NOT
50209: PUSH
50210: LD_EXP 107
50214: PUSH
50215: LD_VAR 0 2
50219: ARRAY
50220: OR
50221: IFFALSE 50225
// continue ;
50223: GO 50195
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
50225: LD_EXP 116
50229: PUSH
50230: LD_VAR 0 2
50234: ARRAY
50235: NOT
50236: PUSH
50237: LD_EXP 117
50241: PUSH
50242: LD_VAR 0 2
50246: ARRAY
50247: AND
50248: IFFALSE 50286
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50250: LD_ADDR_EXP 117
50254: PUSH
50255: LD_EXP 117
50259: PPUSH
50260: LD_VAR 0 2
50264: PPUSH
50265: EMPTY
50266: PPUSH
50267: CALL_OW 1
50271: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
50272: LD_VAR 0 2
50276: PPUSH
50277: LD_INT 107
50279: PPUSH
50280: CALL 41033 0 2
// continue ;
50284: GO 50195
// end ; target := [ ] ;
50286: LD_ADDR_VAR 0 7
50290: PUSH
50291: EMPTY
50292: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50293: LD_ADDR_VAR 0 6
50297: PUSH
50298: LD_EXP 100
50302: PUSH
50303: LD_VAR 0 2
50307: ARRAY
50308: PUSH
50309: LD_INT 1
50311: ARRAY
50312: PPUSH
50313: CALL_OW 255
50317: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50318: LD_ADDR_VAR 0 9
50322: PUSH
50323: LD_EXP 100
50327: PUSH
50328: LD_VAR 0 2
50332: ARRAY
50333: PPUSH
50334: LD_INT 2
50336: PUSH
50337: LD_INT 30
50339: PUSH
50340: LD_INT 0
50342: PUSH
50343: EMPTY
50344: LIST
50345: LIST
50346: PUSH
50347: LD_INT 30
50349: PUSH
50350: LD_INT 1
50352: PUSH
50353: EMPTY
50354: LIST
50355: LIST
50356: PUSH
50357: EMPTY
50358: LIST
50359: LIST
50360: LIST
50361: PPUSH
50362: CALL_OW 72
50366: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50367: LD_ADDR_VAR 0 3
50371: PUSH
50372: DOUBLE
50373: LD_EXP 116
50377: PUSH
50378: LD_VAR 0 2
50382: ARRAY
50383: INC
50384: ST_TO_ADDR
50385: LD_INT 1
50387: PUSH
50388: FOR_DOWNTO
50389: IFFALSE 50634
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50391: LD_EXP 116
50395: PUSH
50396: LD_VAR 0 2
50400: ARRAY
50401: PUSH
50402: LD_VAR 0 3
50406: ARRAY
50407: PUSH
50408: LD_INT 2
50410: ARRAY
50411: PPUSH
50412: LD_EXP 116
50416: PUSH
50417: LD_VAR 0 2
50421: ARRAY
50422: PUSH
50423: LD_VAR 0 3
50427: ARRAY
50428: PUSH
50429: LD_INT 3
50431: ARRAY
50432: PPUSH
50433: CALL_OW 488
50437: PUSH
50438: LD_EXP 116
50442: PUSH
50443: LD_VAR 0 2
50447: ARRAY
50448: PUSH
50449: LD_VAR 0 3
50453: ARRAY
50454: PUSH
50455: LD_INT 2
50457: ARRAY
50458: PPUSH
50459: LD_EXP 116
50463: PUSH
50464: LD_VAR 0 2
50468: ARRAY
50469: PUSH
50470: LD_VAR 0 3
50474: ARRAY
50475: PUSH
50476: LD_INT 3
50478: ARRAY
50479: PPUSH
50480: CALL_OW 284
50484: PUSH
50485: LD_INT 0
50487: EQUAL
50488: AND
50489: IFFALSE 50544
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50491: LD_ADDR_VAR 0 5
50495: PUSH
50496: LD_EXP 116
50500: PUSH
50501: LD_VAR 0 2
50505: ARRAY
50506: PPUSH
50507: LD_VAR 0 3
50511: PPUSH
50512: CALL_OW 3
50516: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50517: LD_ADDR_EXP 116
50521: PUSH
50522: LD_EXP 116
50526: PPUSH
50527: LD_VAR 0 2
50531: PPUSH
50532: LD_VAR 0 5
50536: PPUSH
50537: CALL_OW 1
50541: ST_TO_ADDR
// continue ;
50542: GO 50388
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50544: LD_VAR 0 6
50548: PPUSH
50549: LD_EXP 116
50553: PUSH
50554: LD_VAR 0 2
50558: ARRAY
50559: PUSH
50560: LD_VAR 0 3
50564: ARRAY
50565: PUSH
50566: LD_INT 2
50568: ARRAY
50569: PPUSH
50570: LD_EXP 116
50574: PUSH
50575: LD_VAR 0 2
50579: ARRAY
50580: PUSH
50581: LD_VAR 0 3
50585: ARRAY
50586: PUSH
50587: LD_INT 3
50589: ARRAY
50590: PPUSH
50591: LD_INT 30
50593: PPUSH
50594: CALL 73569 0 4
50598: PUSH
50599: LD_INT 4
50601: ARRAY
50602: PUSH
50603: LD_INT 0
50605: EQUAL
50606: IFFALSE 50632
// begin target := mc_crates [ i ] [ j ] ;
50608: LD_ADDR_VAR 0 7
50612: PUSH
50613: LD_EXP 116
50617: PUSH
50618: LD_VAR 0 2
50622: ARRAY
50623: PUSH
50624: LD_VAR 0 3
50628: ARRAY
50629: ST_TO_ADDR
// break ;
50630: GO 50634
// end ; end ;
50632: GO 50388
50634: POP
50635: POP
// if not target then
50636: LD_VAR 0 7
50640: NOT
50641: IFFALSE 50645
// continue ;
50643: GO 50195
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50645: LD_ADDR_VAR 0 8
50649: PUSH
50650: LD_EXP 119
50654: PUSH
50655: LD_VAR 0 2
50659: ARRAY
50660: PPUSH
50661: LD_INT 2
50663: PUSH
50664: LD_INT 3
50666: PUSH
50667: LD_INT 58
50669: PUSH
50670: EMPTY
50671: LIST
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 61
50679: PUSH
50680: EMPTY
50681: LIST
50682: PUSH
50683: LD_INT 33
50685: PUSH
50686: LD_INT 5
50688: PUSH
50689: EMPTY
50690: LIST
50691: LIST
50692: PUSH
50693: LD_INT 33
50695: PUSH
50696: LD_INT 3
50698: PUSH
50699: EMPTY
50700: LIST
50701: LIST
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: LIST
50707: LIST
50708: LIST
50709: PUSH
50710: LD_INT 2
50712: PUSH
50713: LD_INT 34
50715: PUSH
50716: LD_INT 32
50718: PUSH
50719: EMPTY
50720: LIST
50721: LIST
50722: PUSH
50723: LD_INT 34
50725: PUSH
50726: LD_INT 51
50728: PUSH
50729: EMPTY
50730: LIST
50731: LIST
50732: PUSH
50733: LD_INT 34
50735: PUSH
50736: LD_INT 12
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: LIST
50747: LIST
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: PPUSH
50753: CALL_OW 72
50757: ST_TO_ADDR
// if not cargo then
50758: LD_VAR 0 8
50762: NOT
50763: IFFALSE 51469
// begin if mc_crates_collector [ i ] < 5 then
50765: LD_EXP 117
50769: PUSH
50770: LD_VAR 0 2
50774: ARRAY
50775: PUSH
50776: LD_INT 5
50778: LESS
50779: IFFALSE 51145
// begin if mc_ape [ i ] then
50781: LD_EXP 129
50785: PUSH
50786: LD_VAR 0 2
50790: ARRAY
50791: IFFALSE 50838
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50793: LD_ADDR_VAR 0 5
50797: PUSH
50798: LD_EXP 129
50802: PUSH
50803: LD_VAR 0 2
50807: ARRAY
50808: PPUSH
50809: LD_INT 25
50811: PUSH
50812: LD_INT 16
50814: PUSH
50815: EMPTY
50816: LIST
50817: LIST
50818: PUSH
50819: LD_INT 24
50821: PUSH
50822: LD_INT 750
50824: PUSH
50825: EMPTY
50826: LIST
50827: LIST
50828: PUSH
50829: EMPTY
50830: LIST
50831: LIST
50832: PPUSH
50833: CALL_OW 72
50837: ST_TO_ADDR
// if not tmp then
50838: LD_VAR 0 5
50842: NOT
50843: IFFALSE 50890
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50845: LD_ADDR_VAR 0 5
50849: PUSH
50850: LD_EXP 100
50854: PUSH
50855: LD_VAR 0 2
50859: ARRAY
50860: PPUSH
50861: LD_INT 25
50863: PUSH
50864: LD_INT 2
50866: PUSH
50867: EMPTY
50868: LIST
50869: LIST
50870: PUSH
50871: LD_INT 24
50873: PUSH
50874: LD_INT 750
50876: PUSH
50877: EMPTY
50878: LIST
50879: LIST
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: PPUSH
50885: CALL_OW 72
50889: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50890: LD_EXP 129
50894: PUSH
50895: LD_VAR 0 2
50899: ARRAY
50900: PUSH
50901: LD_EXP 100
50905: PUSH
50906: LD_VAR 0 2
50910: ARRAY
50911: PPUSH
50912: LD_INT 25
50914: PUSH
50915: LD_INT 2
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: LD_INT 24
50924: PUSH
50925: LD_INT 750
50927: PUSH
50928: EMPTY
50929: LIST
50930: LIST
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: PPUSH
50936: CALL_OW 72
50940: AND
50941: PUSH
50942: LD_VAR 0 5
50946: PUSH
50947: LD_INT 5
50949: LESS
50950: AND
50951: IFFALSE 51033
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50953: LD_ADDR_VAR 0 3
50957: PUSH
50958: LD_EXP 100
50962: PUSH
50963: LD_VAR 0 2
50967: ARRAY
50968: PPUSH
50969: LD_INT 25
50971: PUSH
50972: LD_INT 2
50974: PUSH
50975: EMPTY
50976: LIST
50977: LIST
50978: PUSH
50979: LD_INT 24
50981: PUSH
50982: LD_INT 750
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: PUSH
50989: EMPTY
50990: LIST
50991: LIST
50992: PPUSH
50993: CALL_OW 72
50997: PUSH
50998: FOR_IN
50999: IFFALSE 51031
// begin tmp := tmp union j ;
51001: LD_ADDR_VAR 0 5
51005: PUSH
51006: LD_VAR 0 5
51010: PUSH
51011: LD_VAR 0 3
51015: UNION
51016: ST_TO_ADDR
// if tmp >= 5 then
51017: LD_VAR 0 5
51021: PUSH
51022: LD_INT 5
51024: GREATEREQUAL
51025: IFFALSE 51029
// break ;
51027: GO 51031
// end ;
51029: GO 50998
51031: POP
51032: POP
// end ; if not tmp then
51033: LD_VAR 0 5
51037: NOT
51038: IFFALSE 51042
// continue ;
51040: GO 50195
// for j in tmp do
51042: LD_ADDR_VAR 0 3
51046: PUSH
51047: LD_VAR 0 5
51051: PUSH
51052: FOR_IN
51053: IFFALSE 51143
// if not GetTag ( j ) then
51055: LD_VAR 0 3
51059: PPUSH
51060: CALL_OW 110
51064: NOT
51065: IFFALSE 51141
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
51067: LD_ADDR_EXP 117
51071: PUSH
51072: LD_EXP 117
51076: PPUSH
51077: LD_VAR 0 2
51081: PUSH
51082: LD_EXP 117
51086: PUSH
51087: LD_VAR 0 2
51091: ARRAY
51092: PUSH
51093: LD_INT 1
51095: PLUS
51096: PUSH
51097: EMPTY
51098: LIST
51099: LIST
51100: PPUSH
51101: LD_VAR 0 3
51105: PPUSH
51106: CALL 72673 0 3
51110: ST_TO_ADDR
// SetTag ( j , 107 ) ;
51111: LD_VAR 0 3
51115: PPUSH
51116: LD_INT 107
51118: PPUSH
51119: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
51123: LD_EXP 117
51127: PUSH
51128: LD_VAR 0 2
51132: ARRAY
51133: PUSH
51134: LD_INT 5
51136: GREATEREQUAL
51137: IFFALSE 51141
// break ;
51139: GO 51143
// end ;
51141: GO 51052
51143: POP
51144: POP
// end ; if mc_crates_collector [ i ] and target then
51145: LD_EXP 117
51149: PUSH
51150: LD_VAR 0 2
51154: ARRAY
51155: PUSH
51156: LD_VAR 0 7
51160: AND
51161: IFFALSE 51467
// begin if mc_crates_collector [ i ] < target [ 1 ] then
51163: LD_EXP 117
51167: PUSH
51168: LD_VAR 0 2
51172: ARRAY
51173: PUSH
51174: LD_VAR 0 7
51178: PUSH
51179: LD_INT 1
51181: ARRAY
51182: LESS
51183: IFFALSE 51203
// tmp := mc_crates_collector [ i ] else
51185: LD_ADDR_VAR 0 5
51189: PUSH
51190: LD_EXP 117
51194: PUSH
51195: LD_VAR 0 2
51199: ARRAY
51200: ST_TO_ADDR
51201: GO 51217
// tmp := target [ 1 ] ;
51203: LD_ADDR_VAR 0 5
51207: PUSH
51208: LD_VAR 0 7
51212: PUSH
51213: LD_INT 1
51215: ARRAY
51216: ST_TO_ADDR
// k := 0 ;
51217: LD_ADDR_VAR 0 4
51221: PUSH
51222: LD_INT 0
51224: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
51225: LD_ADDR_VAR 0 3
51229: PUSH
51230: LD_EXP 117
51234: PUSH
51235: LD_VAR 0 2
51239: ARRAY
51240: PUSH
51241: FOR_IN
51242: IFFALSE 51465
// begin k := k + 1 ;
51244: LD_ADDR_VAR 0 4
51248: PUSH
51249: LD_VAR 0 4
51253: PUSH
51254: LD_INT 1
51256: PLUS
51257: ST_TO_ADDR
// if k > tmp then
51258: LD_VAR 0 4
51262: PUSH
51263: LD_VAR 0 5
51267: GREATER
51268: IFFALSE 51272
// break ;
51270: GO 51465
// if not GetClass ( j ) in [ 2 , 16 ] then
51272: LD_VAR 0 3
51276: PPUSH
51277: CALL_OW 257
51281: PUSH
51282: LD_INT 2
51284: PUSH
51285: LD_INT 16
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: IN
51292: NOT
51293: IFFALSE 51346
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
51295: LD_ADDR_EXP 117
51299: PUSH
51300: LD_EXP 117
51304: PPUSH
51305: LD_VAR 0 2
51309: PPUSH
51310: LD_EXP 117
51314: PUSH
51315: LD_VAR 0 2
51319: ARRAY
51320: PUSH
51321: LD_VAR 0 3
51325: DIFF
51326: PPUSH
51327: CALL_OW 1
51331: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51332: LD_VAR 0 3
51336: PPUSH
51337: LD_INT 0
51339: PPUSH
51340: CALL_OW 109
// continue ;
51344: GO 51241
// end ; if IsInUnit ( j ) then
51346: LD_VAR 0 3
51350: PPUSH
51351: CALL_OW 310
51355: IFFALSE 51366
// ComExitBuilding ( j ) ;
51357: LD_VAR 0 3
51361: PPUSH
51362: CALL_OW 122
// wait ( 3 ) ;
51366: LD_INT 3
51368: PPUSH
51369: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51373: LD_VAR 0 3
51377: PPUSH
51378: CALL_OW 314
51382: PUSH
51383: LD_VAR 0 6
51387: PPUSH
51388: LD_VAR 0 7
51392: PUSH
51393: LD_INT 2
51395: ARRAY
51396: PPUSH
51397: LD_VAR 0 7
51401: PUSH
51402: LD_INT 3
51404: ARRAY
51405: PPUSH
51406: LD_INT 30
51408: PPUSH
51409: CALL 73569 0 4
51413: PUSH
51414: LD_INT 4
51416: ARRAY
51417: AND
51418: IFFALSE 51436
// ComStandNearbyBuilding ( j , depot ) else
51420: LD_VAR 0 3
51424: PPUSH
51425: LD_VAR 0 9
51429: PPUSH
51430: CALL 69100 0 2
51434: GO 51463
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51436: LD_VAR 0 3
51440: PPUSH
51441: LD_VAR 0 7
51445: PUSH
51446: LD_INT 2
51448: ARRAY
51449: PPUSH
51450: LD_VAR 0 7
51454: PUSH
51455: LD_INT 3
51457: ARRAY
51458: PPUSH
51459: CALL_OW 117
// end ;
51463: GO 51241
51465: POP
51466: POP
// end ; end else
51467: GO 51999
// begin for j in cargo do
51469: LD_ADDR_VAR 0 3
51473: PUSH
51474: LD_VAR 0 8
51478: PUSH
51479: FOR_IN
51480: IFFALSE 51997
// begin if GetTag ( j ) <> 0 then
51482: LD_VAR 0 3
51486: PPUSH
51487: CALL_OW 110
51491: PUSH
51492: LD_INT 0
51494: NONEQUAL
51495: IFFALSE 51499
// continue ;
51497: GO 51479
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51499: LD_VAR 0 3
51503: PPUSH
51504: CALL_OW 256
51508: PUSH
51509: LD_INT 1000
51511: LESS
51512: PUSH
51513: LD_VAR 0 3
51517: PPUSH
51518: LD_EXP 124
51522: PUSH
51523: LD_VAR 0 2
51527: ARRAY
51528: PPUSH
51529: CALL_OW 308
51533: NOT
51534: AND
51535: IFFALSE 51557
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51537: LD_VAR 0 3
51541: PPUSH
51542: LD_EXP 124
51546: PUSH
51547: LD_VAR 0 2
51551: ARRAY
51552: PPUSH
51553: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51557: LD_VAR 0 3
51561: PPUSH
51562: CALL_OW 256
51566: PUSH
51567: LD_INT 1000
51569: LESS
51570: PUSH
51571: LD_VAR 0 3
51575: PPUSH
51576: LD_EXP 124
51580: PUSH
51581: LD_VAR 0 2
51585: ARRAY
51586: PPUSH
51587: CALL_OW 308
51591: AND
51592: IFFALSE 51596
// continue ;
51594: GO 51479
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51596: LD_VAR 0 3
51600: PPUSH
51601: CALL_OW 262
51605: PUSH
51606: LD_INT 2
51608: EQUAL
51609: PUSH
51610: LD_VAR 0 3
51614: PPUSH
51615: CALL_OW 261
51619: PUSH
51620: LD_INT 15
51622: LESS
51623: AND
51624: IFFALSE 51628
// continue ;
51626: GO 51479
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51628: LD_VAR 0 3
51632: PPUSH
51633: CALL_OW 262
51637: PUSH
51638: LD_INT 1
51640: EQUAL
51641: PUSH
51642: LD_VAR 0 3
51646: PPUSH
51647: CALL_OW 261
51651: PUSH
51652: LD_INT 10
51654: LESS
51655: AND
51656: IFFALSE 51936
// begin if not depot then
51658: LD_VAR 0 9
51662: NOT
51663: IFFALSE 51667
// continue ;
51665: GO 51479
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51667: LD_VAR 0 3
51671: PPUSH
51672: LD_VAR 0 9
51676: PPUSH
51677: LD_VAR 0 3
51681: PPUSH
51682: CALL_OW 74
51686: PPUSH
51687: CALL_OW 296
51691: PUSH
51692: LD_INT 6
51694: LESS
51695: IFFALSE 51711
// SetFuel ( j , 100 ) else
51697: LD_VAR 0 3
51701: PPUSH
51702: LD_INT 100
51704: PPUSH
51705: CALL_OW 240
51709: GO 51936
// if GetFuel ( j ) = 0 then
51711: LD_VAR 0 3
51715: PPUSH
51716: CALL_OW 261
51720: PUSH
51721: LD_INT 0
51723: EQUAL
51724: IFFALSE 51936
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51726: LD_ADDR_EXP 119
51730: PUSH
51731: LD_EXP 119
51735: PPUSH
51736: LD_VAR 0 2
51740: PPUSH
51741: LD_EXP 119
51745: PUSH
51746: LD_VAR 0 2
51750: ARRAY
51751: PUSH
51752: LD_VAR 0 3
51756: DIFF
51757: PPUSH
51758: CALL_OW 1
51762: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51763: LD_VAR 0 3
51767: PPUSH
51768: CALL_OW 263
51772: PUSH
51773: LD_INT 1
51775: EQUAL
51776: IFFALSE 51792
// ComExitVehicle ( IsInUnit ( j ) ) ;
51778: LD_VAR 0 3
51782: PPUSH
51783: CALL_OW 310
51787: PPUSH
51788: CALL_OW 121
// if GetControl ( j ) = control_remote then
51792: LD_VAR 0 3
51796: PPUSH
51797: CALL_OW 263
51801: PUSH
51802: LD_INT 2
51804: EQUAL
51805: IFFALSE 51816
// ComUnlink ( j ) ;
51807: LD_VAR 0 3
51811: PPUSH
51812: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51816: LD_ADDR_VAR 0 10
51820: PUSH
51821: LD_VAR 0 2
51825: PPUSH
51826: LD_INT 3
51828: PPUSH
51829: CALL 61603 0 2
51833: ST_TO_ADDR
// if fac then
51834: LD_VAR 0 10
51838: IFFALSE 51934
// begin for k in fac do
51840: LD_ADDR_VAR 0 4
51844: PUSH
51845: LD_VAR 0 10
51849: PUSH
51850: FOR_IN
51851: IFFALSE 51932
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51853: LD_ADDR_VAR 0 11
51857: PUSH
51858: LD_VAR 0 10
51862: PPUSH
51863: LD_VAR 0 3
51867: PPUSH
51868: CALL_OW 265
51872: PPUSH
51873: LD_VAR 0 3
51877: PPUSH
51878: CALL_OW 262
51882: PPUSH
51883: LD_VAR 0 3
51887: PPUSH
51888: CALL_OW 263
51892: PPUSH
51893: LD_VAR 0 3
51897: PPUSH
51898: CALL_OW 264
51902: PPUSH
51903: CALL 70171 0 5
51907: ST_TO_ADDR
// if components then
51908: LD_VAR 0 11
51912: IFFALSE 51930
// begin MC_InsertProduceList ( i , components ) ;
51914: LD_VAR 0 2
51918: PPUSH
51919: LD_VAR 0 11
51923: PPUSH
51924: CALL 61148 0 2
// break ;
51928: GO 51932
// end ; end ;
51930: GO 51850
51932: POP
51933: POP
// end ; continue ;
51934: GO 51479
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51936: LD_VAR 0 3
51940: PPUSH
51941: LD_INT 1
51943: PPUSH
51944: CALL_OW 289
51948: PUSH
51949: LD_INT 100
51951: LESS
51952: PUSH
51953: LD_VAR 0 3
51957: PPUSH
51958: CALL_OW 314
51962: NOT
51963: AND
51964: IFFALSE 51993
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51966: LD_VAR 0 3
51970: PPUSH
51971: LD_VAR 0 7
51975: PUSH
51976: LD_INT 2
51978: ARRAY
51979: PPUSH
51980: LD_VAR 0 7
51984: PUSH
51985: LD_INT 3
51987: ARRAY
51988: PPUSH
51989: CALL_OW 117
// break ;
51993: GO 51997
// end ;
51995: GO 51479
51997: POP
51998: POP
// end ; end ;
51999: GO 50195
52001: POP
52002: POP
// end ;
52003: LD_VAR 0 1
52007: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
52008: LD_INT 0
52010: PPUSH
52011: PPUSH
52012: PPUSH
52013: PPUSH
// if not mc_bases then
52014: LD_EXP 100
52018: NOT
52019: IFFALSE 52023
// exit ;
52021: GO 52184
// for i = 1 to mc_bases do
52023: LD_ADDR_VAR 0 2
52027: PUSH
52028: DOUBLE
52029: LD_INT 1
52031: DEC
52032: ST_TO_ADDR
52033: LD_EXP 100
52037: PUSH
52038: FOR_TO
52039: IFFALSE 52182
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
52041: LD_ADDR_VAR 0 4
52045: PUSH
52046: LD_EXP 119
52050: PUSH
52051: LD_VAR 0 2
52055: ARRAY
52056: PUSH
52057: LD_EXP 122
52061: PUSH
52062: LD_VAR 0 2
52066: ARRAY
52067: UNION
52068: PPUSH
52069: LD_INT 33
52071: PUSH
52072: LD_INT 2
52074: PUSH
52075: EMPTY
52076: LIST
52077: LIST
52078: PPUSH
52079: CALL_OW 72
52083: ST_TO_ADDR
// if tmp then
52084: LD_VAR 0 4
52088: IFFALSE 52180
// for j in tmp do
52090: LD_ADDR_VAR 0 3
52094: PUSH
52095: LD_VAR 0 4
52099: PUSH
52100: FOR_IN
52101: IFFALSE 52178
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
52103: LD_VAR 0 3
52107: PPUSH
52108: CALL_OW 312
52112: NOT
52113: PUSH
52114: LD_VAR 0 3
52118: PPUSH
52119: CALL_OW 256
52123: PUSH
52124: LD_INT 250
52126: GREATEREQUAL
52127: AND
52128: IFFALSE 52141
// Connect ( j ) else
52130: LD_VAR 0 3
52134: PPUSH
52135: CALL 75642 0 1
52139: GO 52176
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
52141: LD_VAR 0 3
52145: PPUSH
52146: CALL_OW 256
52150: PUSH
52151: LD_INT 250
52153: LESS
52154: PUSH
52155: LD_VAR 0 3
52159: PPUSH
52160: CALL_OW 312
52164: AND
52165: IFFALSE 52176
// ComUnlink ( j ) ;
52167: LD_VAR 0 3
52171: PPUSH
52172: CALL_OW 136
52176: GO 52100
52178: POP
52179: POP
// end ;
52180: GO 52038
52182: POP
52183: POP
// end ;
52184: LD_VAR 0 1
52188: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
52189: LD_INT 0
52191: PPUSH
52192: PPUSH
52193: PPUSH
52194: PPUSH
52195: PPUSH
// if not mc_bases then
52196: LD_EXP 100
52200: NOT
52201: IFFALSE 52205
// exit ;
52203: GO 52650
// for i = 1 to mc_bases do
52205: LD_ADDR_VAR 0 2
52209: PUSH
52210: DOUBLE
52211: LD_INT 1
52213: DEC
52214: ST_TO_ADDR
52215: LD_EXP 100
52219: PUSH
52220: FOR_TO
52221: IFFALSE 52648
// begin if not mc_produce [ i ] then
52223: LD_EXP 121
52227: PUSH
52228: LD_VAR 0 2
52232: ARRAY
52233: NOT
52234: IFFALSE 52238
// continue ;
52236: GO 52220
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52238: LD_ADDR_VAR 0 5
52242: PUSH
52243: LD_EXP 100
52247: PUSH
52248: LD_VAR 0 2
52252: ARRAY
52253: PPUSH
52254: LD_INT 30
52256: PUSH
52257: LD_INT 3
52259: PUSH
52260: EMPTY
52261: LIST
52262: LIST
52263: PPUSH
52264: CALL_OW 72
52268: ST_TO_ADDR
// if not fac then
52269: LD_VAR 0 5
52273: NOT
52274: IFFALSE 52278
// continue ;
52276: GO 52220
// for j in fac do
52278: LD_ADDR_VAR 0 3
52282: PUSH
52283: LD_VAR 0 5
52287: PUSH
52288: FOR_IN
52289: IFFALSE 52644
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
52291: LD_VAR 0 3
52295: PPUSH
52296: CALL_OW 461
52300: PUSH
52301: LD_INT 2
52303: NONEQUAL
52304: PUSH
52305: LD_VAR 0 3
52309: PPUSH
52310: LD_INT 15
52312: PPUSH
52313: CALL 75270 0 2
52317: PUSH
52318: LD_INT 4
52320: ARRAY
52321: OR
52322: IFFALSE 52326
// continue ;
52324: GO 52288
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52326: LD_VAR 0 3
52330: PPUSH
52331: LD_EXP 121
52335: PUSH
52336: LD_VAR 0 2
52340: ARRAY
52341: PUSH
52342: LD_INT 1
52344: ARRAY
52345: PUSH
52346: LD_INT 1
52348: ARRAY
52349: PPUSH
52350: LD_EXP 121
52354: PUSH
52355: LD_VAR 0 2
52359: ARRAY
52360: PUSH
52361: LD_INT 1
52363: ARRAY
52364: PUSH
52365: LD_INT 2
52367: ARRAY
52368: PPUSH
52369: LD_EXP 121
52373: PUSH
52374: LD_VAR 0 2
52378: ARRAY
52379: PUSH
52380: LD_INT 1
52382: ARRAY
52383: PUSH
52384: LD_INT 3
52386: ARRAY
52387: PPUSH
52388: LD_EXP 121
52392: PUSH
52393: LD_VAR 0 2
52397: ARRAY
52398: PUSH
52399: LD_INT 1
52401: ARRAY
52402: PUSH
52403: LD_INT 4
52405: ARRAY
52406: PPUSH
52407: CALL_OW 448
52411: PUSH
52412: LD_VAR 0 3
52416: PPUSH
52417: LD_EXP 121
52421: PUSH
52422: LD_VAR 0 2
52426: ARRAY
52427: PUSH
52428: LD_INT 1
52430: ARRAY
52431: PUSH
52432: LD_INT 1
52434: ARRAY
52435: PUSH
52436: LD_EXP 121
52440: PUSH
52441: LD_VAR 0 2
52445: ARRAY
52446: PUSH
52447: LD_INT 1
52449: ARRAY
52450: PUSH
52451: LD_INT 2
52453: ARRAY
52454: PUSH
52455: LD_EXP 121
52459: PUSH
52460: LD_VAR 0 2
52464: ARRAY
52465: PUSH
52466: LD_INT 1
52468: ARRAY
52469: PUSH
52470: LD_INT 3
52472: ARRAY
52473: PUSH
52474: LD_EXP 121
52478: PUSH
52479: LD_VAR 0 2
52483: ARRAY
52484: PUSH
52485: LD_INT 1
52487: ARRAY
52488: PUSH
52489: LD_INT 4
52491: ARRAY
52492: PUSH
52493: EMPTY
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: PPUSH
52499: CALL 79037 0 2
52503: AND
52504: IFFALSE 52642
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52506: LD_VAR 0 3
52510: PPUSH
52511: LD_EXP 121
52515: PUSH
52516: LD_VAR 0 2
52520: ARRAY
52521: PUSH
52522: LD_INT 1
52524: ARRAY
52525: PUSH
52526: LD_INT 1
52528: ARRAY
52529: PPUSH
52530: LD_EXP 121
52534: PUSH
52535: LD_VAR 0 2
52539: ARRAY
52540: PUSH
52541: LD_INT 1
52543: ARRAY
52544: PUSH
52545: LD_INT 2
52547: ARRAY
52548: PPUSH
52549: LD_EXP 121
52553: PUSH
52554: LD_VAR 0 2
52558: ARRAY
52559: PUSH
52560: LD_INT 1
52562: ARRAY
52563: PUSH
52564: LD_INT 3
52566: ARRAY
52567: PPUSH
52568: LD_EXP 121
52572: PUSH
52573: LD_VAR 0 2
52577: ARRAY
52578: PUSH
52579: LD_INT 1
52581: ARRAY
52582: PUSH
52583: LD_INT 4
52585: ARRAY
52586: PPUSH
52587: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52591: LD_ADDR_VAR 0 4
52595: PUSH
52596: LD_EXP 121
52600: PUSH
52601: LD_VAR 0 2
52605: ARRAY
52606: PPUSH
52607: LD_INT 1
52609: PPUSH
52610: CALL_OW 3
52614: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52615: LD_ADDR_EXP 121
52619: PUSH
52620: LD_EXP 121
52624: PPUSH
52625: LD_VAR 0 2
52629: PPUSH
52630: LD_VAR 0 4
52634: PPUSH
52635: CALL_OW 1
52639: ST_TO_ADDR
// break ;
52640: GO 52644
// end ; end ;
52642: GO 52288
52644: POP
52645: POP
// end ;
52646: GO 52220
52648: POP
52649: POP
// end ;
52650: LD_VAR 0 1
52654: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52655: LD_INT 0
52657: PPUSH
52658: PPUSH
52659: PPUSH
// if not mc_bases then
52660: LD_EXP 100
52664: NOT
52665: IFFALSE 52669
// exit ;
52667: GO 52758
// for i = 1 to mc_bases do
52669: LD_ADDR_VAR 0 2
52673: PUSH
52674: DOUBLE
52675: LD_INT 1
52677: DEC
52678: ST_TO_ADDR
52679: LD_EXP 100
52683: PUSH
52684: FOR_TO
52685: IFFALSE 52756
// begin if mc_attack [ i ] then
52687: LD_EXP 120
52691: PUSH
52692: LD_VAR 0 2
52696: ARRAY
52697: IFFALSE 52754
// begin tmp := mc_attack [ i ] [ 1 ] ;
52699: LD_ADDR_VAR 0 3
52703: PUSH
52704: LD_EXP 120
52708: PUSH
52709: LD_VAR 0 2
52713: ARRAY
52714: PUSH
52715: LD_INT 1
52717: ARRAY
52718: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52719: LD_ADDR_EXP 120
52723: PUSH
52724: LD_EXP 120
52728: PPUSH
52729: LD_VAR 0 2
52733: PPUSH
52734: EMPTY
52735: PPUSH
52736: CALL_OW 1
52740: ST_TO_ADDR
// Attack ( tmp ) ;
52741: LD_VAR 0 3
52745: PPUSH
52746: CALL 128876 0 1
// exit ;
52750: POP
52751: POP
52752: GO 52758
// end ; end ;
52754: GO 52684
52756: POP
52757: POP
// end ;
52758: LD_VAR 0 1
52762: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52763: LD_INT 0
52765: PPUSH
52766: PPUSH
52767: PPUSH
52768: PPUSH
52769: PPUSH
52770: PPUSH
52771: PPUSH
// if not mc_bases then
52772: LD_EXP 100
52776: NOT
52777: IFFALSE 52781
// exit ;
52779: GO 53638
// for i = 1 to mc_bases do
52781: LD_ADDR_VAR 0 2
52785: PUSH
52786: DOUBLE
52787: LD_INT 1
52789: DEC
52790: ST_TO_ADDR
52791: LD_EXP 100
52795: PUSH
52796: FOR_TO
52797: IFFALSE 53636
// begin if not mc_bases [ i ] then
52799: LD_EXP 100
52803: PUSH
52804: LD_VAR 0 2
52808: ARRAY
52809: NOT
52810: IFFALSE 52814
// continue ;
52812: GO 52796
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52814: LD_ADDR_VAR 0 7
52818: PUSH
52819: LD_EXP 100
52823: PUSH
52824: LD_VAR 0 2
52828: ARRAY
52829: PUSH
52830: LD_INT 1
52832: ARRAY
52833: PPUSH
52834: CALL 69322 0 1
52838: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52839: LD_ADDR_EXP 123
52843: PUSH
52844: LD_EXP 123
52848: PPUSH
52849: LD_VAR 0 2
52853: PPUSH
52854: LD_EXP 100
52858: PUSH
52859: LD_VAR 0 2
52863: ARRAY
52864: PUSH
52865: LD_INT 1
52867: ARRAY
52868: PPUSH
52869: CALL_OW 255
52873: PPUSH
52874: LD_EXP 125
52878: PUSH
52879: LD_VAR 0 2
52883: ARRAY
52884: PPUSH
52885: CALL 69287 0 2
52889: PPUSH
52890: CALL_OW 1
52894: ST_TO_ADDR
// if not mc_scan [ i ] then
52895: LD_EXP 123
52899: PUSH
52900: LD_VAR 0 2
52904: ARRAY
52905: NOT
52906: IFFALSE 53084
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52908: LD_ADDR_EXP 143
52912: PUSH
52913: LD_EXP 143
52917: PPUSH
52918: LD_VAR 0 2
52922: PPUSH
52923: LD_INT 0
52925: PPUSH
52926: CALL_OW 1
52930: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52931: LD_ADDR_VAR 0 4
52935: PUSH
52936: LD_EXP 100
52940: PUSH
52941: LD_VAR 0 2
52945: ARRAY
52946: PPUSH
52947: LD_INT 2
52949: PUSH
52950: LD_INT 25
52952: PUSH
52953: LD_INT 5
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: PUSH
52960: LD_INT 25
52962: PUSH
52963: LD_INT 8
52965: PUSH
52966: EMPTY
52967: LIST
52968: LIST
52969: PUSH
52970: LD_INT 25
52972: PUSH
52973: LD_INT 9
52975: PUSH
52976: EMPTY
52977: LIST
52978: LIST
52979: PUSH
52980: EMPTY
52981: LIST
52982: LIST
52983: LIST
52984: LIST
52985: PPUSH
52986: CALL_OW 72
52990: ST_TO_ADDR
// if not tmp then
52991: LD_VAR 0 4
52995: NOT
52996: IFFALSE 53000
// continue ;
52998: GO 52796
// for j in tmp do
53000: LD_ADDR_VAR 0 3
53004: PUSH
53005: LD_VAR 0 4
53009: PUSH
53010: FOR_IN
53011: IFFALSE 53082
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
53013: LD_VAR 0 3
53017: PPUSH
53018: CALL_OW 310
53022: PPUSH
53023: CALL_OW 266
53027: PUSH
53028: LD_INT 5
53030: EQUAL
53031: PUSH
53032: LD_VAR 0 3
53036: PPUSH
53037: CALL_OW 257
53041: PUSH
53042: LD_INT 1
53044: EQUAL
53045: AND
53046: PUSH
53047: LD_VAR 0 3
53051: PPUSH
53052: CALL_OW 459
53056: NOT
53057: AND
53058: PUSH
53059: LD_VAR 0 7
53063: AND
53064: IFFALSE 53080
// ComChangeProfession ( j , class ) ;
53066: LD_VAR 0 3
53070: PPUSH
53071: LD_VAR 0 7
53075: PPUSH
53076: CALL_OW 123
53080: GO 53010
53082: POP
53083: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
53084: LD_EXP 123
53088: PUSH
53089: LD_VAR 0 2
53093: ARRAY
53094: PUSH
53095: LD_EXP 143
53099: PUSH
53100: LD_VAR 0 2
53104: ARRAY
53105: NOT
53106: AND
53107: PUSH
53108: LD_EXP 122
53112: PUSH
53113: LD_VAR 0 2
53117: ARRAY
53118: NOT
53119: AND
53120: PUSH
53121: LD_EXP 100
53125: PUSH
53126: LD_VAR 0 2
53130: ARRAY
53131: PPUSH
53132: LD_INT 50
53134: PUSH
53135: EMPTY
53136: LIST
53137: PUSH
53138: LD_INT 2
53140: PUSH
53141: LD_INT 30
53143: PUSH
53144: LD_INT 32
53146: PUSH
53147: EMPTY
53148: LIST
53149: LIST
53150: PUSH
53151: LD_INT 30
53153: PUSH
53154: LD_INT 33
53156: PUSH
53157: EMPTY
53158: LIST
53159: LIST
53160: PUSH
53161: LD_INT 30
53163: PUSH
53164: LD_INT 4
53166: PUSH
53167: EMPTY
53168: LIST
53169: LIST
53170: PUSH
53171: LD_INT 30
53173: PUSH
53174: LD_INT 5
53176: PUSH
53177: EMPTY
53178: LIST
53179: LIST
53180: PUSH
53181: EMPTY
53182: LIST
53183: LIST
53184: LIST
53185: LIST
53186: LIST
53187: PUSH
53188: EMPTY
53189: LIST
53190: LIST
53191: PPUSH
53192: CALL_OW 72
53196: PUSH
53197: LD_INT 4
53199: LESS
53200: PUSH
53201: LD_EXP 100
53205: PUSH
53206: LD_VAR 0 2
53210: ARRAY
53211: PPUSH
53212: LD_INT 3
53214: PUSH
53215: LD_INT 24
53217: PUSH
53218: LD_INT 1000
53220: PUSH
53221: EMPTY
53222: LIST
53223: LIST
53224: PUSH
53225: EMPTY
53226: LIST
53227: LIST
53228: PUSH
53229: LD_INT 2
53231: PUSH
53232: LD_INT 30
53234: PUSH
53235: LD_INT 0
53237: PUSH
53238: EMPTY
53239: LIST
53240: LIST
53241: PUSH
53242: LD_INT 30
53244: PUSH
53245: LD_INT 1
53247: PUSH
53248: EMPTY
53249: LIST
53250: LIST
53251: PUSH
53252: EMPTY
53253: LIST
53254: LIST
53255: LIST
53256: PUSH
53257: EMPTY
53258: LIST
53259: LIST
53260: PPUSH
53261: CALL_OW 72
53265: OR
53266: AND
53267: IFFALSE 53518
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53269: LD_ADDR_EXP 143
53273: PUSH
53274: LD_EXP 143
53278: PPUSH
53279: LD_VAR 0 2
53283: PPUSH
53284: LD_INT 1
53286: PPUSH
53287: CALL_OW 1
53291: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53292: LD_ADDR_VAR 0 4
53296: PUSH
53297: LD_EXP 100
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: PPUSH
53308: LD_INT 2
53310: PUSH
53311: LD_INT 25
53313: PUSH
53314: LD_INT 1
53316: PUSH
53317: EMPTY
53318: LIST
53319: LIST
53320: PUSH
53321: LD_INT 25
53323: PUSH
53324: LD_INT 5
53326: PUSH
53327: EMPTY
53328: LIST
53329: LIST
53330: PUSH
53331: LD_INT 25
53333: PUSH
53334: LD_INT 8
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: PUSH
53341: LD_INT 25
53343: PUSH
53344: LD_INT 9
53346: PUSH
53347: EMPTY
53348: LIST
53349: LIST
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: LIST
53357: PPUSH
53358: CALL_OW 72
53362: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53363: LD_ADDR_VAR 0 4
53367: PUSH
53368: LD_VAR 0 4
53372: PUSH
53373: LD_VAR 0 4
53377: PPUSH
53378: LD_INT 18
53380: PPUSH
53381: CALL 102559 0 2
53385: DIFF
53386: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53387: LD_VAR 0 4
53391: NOT
53392: PUSH
53393: LD_EXP 100
53397: PUSH
53398: LD_VAR 0 2
53402: ARRAY
53403: PPUSH
53404: LD_INT 2
53406: PUSH
53407: LD_INT 30
53409: PUSH
53410: LD_INT 4
53412: PUSH
53413: EMPTY
53414: LIST
53415: LIST
53416: PUSH
53417: LD_INT 30
53419: PUSH
53420: LD_INT 5
53422: PUSH
53423: EMPTY
53424: LIST
53425: LIST
53426: PUSH
53427: EMPTY
53428: LIST
53429: LIST
53430: LIST
53431: PPUSH
53432: CALL_OW 72
53436: NOT
53437: AND
53438: IFFALSE 53500
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53440: LD_ADDR_VAR 0 4
53444: PUSH
53445: LD_EXP 100
53449: PUSH
53450: LD_VAR 0 2
53454: ARRAY
53455: PPUSH
53456: LD_INT 2
53458: PUSH
53459: LD_INT 25
53461: PUSH
53462: LD_INT 2
53464: PUSH
53465: EMPTY
53466: LIST
53467: LIST
53468: PUSH
53469: LD_INT 25
53471: PUSH
53472: LD_INT 3
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: PUSH
53479: LD_INT 25
53481: PUSH
53482: LD_INT 4
53484: PUSH
53485: EMPTY
53486: LIST
53487: LIST
53488: PUSH
53489: EMPTY
53490: LIST
53491: LIST
53492: LIST
53493: LIST
53494: PPUSH
53495: CALL_OW 72
53499: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53500: LD_VAR 0 2
53504: PPUSH
53505: LD_VAR 0 4
53509: PPUSH
53510: CALL 133585 0 2
// exit ;
53514: POP
53515: POP
53516: GO 53638
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53518: LD_EXP 123
53522: PUSH
53523: LD_VAR 0 2
53527: ARRAY
53528: PUSH
53529: LD_EXP 143
53533: PUSH
53534: LD_VAR 0 2
53538: ARRAY
53539: NOT
53540: AND
53541: PUSH
53542: LD_EXP 122
53546: PUSH
53547: LD_VAR 0 2
53551: ARRAY
53552: AND
53553: IFFALSE 53634
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53555: LD_ADDR_EXP 143
53559: PUSH
53560: LD_EXP 143
53564: PPUSH
53565: LD_VAR 0 2
53569: PPUSH
53570: LD_INT 1
53572: PPUSH
53573: CALL_OW 1
53577: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53578: LD_ADDR_VAR 0 4
53582: PUSH
53583: LD_EXP 122
53587: PUSH
53588: LD_VAR 0 2
53592: ARRAY
53593: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53594: LD_ADDR_EXP 122
53598: PUSH
53599: LD_EXP 122
53603: PPUSH
53604: LD_VAR 0 2
53608: PPUSH
53609: EMPTY
53610: PPUSH
53611: CALL_OW 1
53615: ST_TO_ADDR
// Defend ( i , tmp ) ;
53616: LD_VAR 0 2
53620: PPUSH
53621: LD_VAR 0 4
53625: PPUSH
53626: CALL 134181 0 2
// exit ;
53630: POP
53631: POP
53632: GO 53638
// end ; end ;
53634: GO 52796
53636: POP
53637: POP
// end ;
53638: LD_VAR 0 1
53642: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53643: LD_INT 0
53645: PPUSH
53646: PPUSH
53647: PPUSH
53648: PPUSH
53649: PPUSH
53650: PPUSH
53651: PPUSH
53652: PPUSH
53653: PPUSH
53654: PPUSH
53655: PPUSH
// if not mc_bases then
53656: LD_EXP 100
53660: NOT
53661: IFFALSE 53665
// exit ;
53663: GO 54752
// for i = 1 to mc_bases do
53665: LD_ADDR_VAR 0 2
53669: PUSH
53670: DOUBLE
53671: LD_INT 1
53673: DEC
53674: ST_TO_ADDR
53675: LD_EXP 100
53679: PUSH
53680: FOR_TO
53681: IFFALSE 54750
// begin tmp := mc_lab [ i ] ;
53683: LD_ADDR_VAR 0 6
53687: PUSH
53688: LD_EXP 133
53692: PUSH
53693: LD_VAR 0 2
53697: ARRAY
53698: ST_TO_ADDR
// if not tmp then
53699: LD_VAR 0 6
53703: NOT
53704: IFFALSE 53708
// continue ;
53706: GO 53680
// idle_lab := 0 ;
53708: LD_ADDR_VAR 0 11
53712: PUSH
53713: LD_INT 0
53715: ST_TO_ADDR
// for j in tmp do
53716: LD_ADDR_VAR 0 3
53720: PUSH
53721: LD_VAR 0 6
53725: PUSH
53726: FOR_IN
53727: IFFALSE 54746
// begin researching := false ;
53729: LD_ADDR_VAR 0 10
53733: PUSH
53734: LD_INT 0
53736: ST_TO_ADDR
// side := GetSide ( j ) ;
53737: LD_ADDR_VAR 0 4
53741: PUSH
53742: LD_VAR 0 3
53746: PPUSH
53747: CALL_OW 255
53751: ST_TO_ADDR
// if not mc_tech [ side ] then
53752: LD_EXP 127
53756: PUSH
53757: LD_VAR 0 4
53761: ARRAY
53762: NOT
53763: IFFALSE 53767
// continue ;
53765: GO 53726
// if BuildingStatus ( j ) = bs_idle then
53767: LD_VAR 0 3
53771: PPUSH
53772: CALL_OW 461
53776: PUSH
53777: LD_INT 2
53779: EQUAL
53780: IFFALSE 53968
// begin if idle_lab and UnitsInside ( j ) < 6 then
53782: LD_VAR 0 11
53786: PUSH
53787: LD_VAR 0 3
53791: PPUSH
53792: CALL_OW 313
53796: PUSH
53797: LD_INT 6
53799: LESS
53800: AND
53801: IFFALSE 53872
// begin tmp2 := UnitsInside ( idle_lab ) ;
53803: LD_ADDR_VAR 0 9
53807: PUSH
53808: LD_VAR 0 11
53812: PPUSH
53813: CALL_OW 313
53817: ST_TO_ADDR
// if tmp2 then
53818: LD_VAR 0 9
53822: IFFALSE 53864
// for x in tmp2 do
53824: LD_ADDR_VAR 0 7
53828: PUSH
53829: LD_VAR 0 9
53833: PUSH
53834: FOR_IN
53835: IFFALSE 53862
// begin ComExitBuilding ( x ) ;
53837: LD_VAR 0 7
53841: PPUSH
53842: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53846: LD_VAR 0 7
53850: PPUSH
53851: LD_VAR 0 3
53855: PPUSH
53856: CALL_OW 180
// end ;
53860: GO 53834
53862: POP
53863: POP
// idle_lab := 0 ;
53864: LD_ADDR_VAR 0 11
53868: PUSH
53869: LD_INT 0
53871: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53872: LD_ADDR_VAR 0 5
53876: PUSH
53877: LD_EXP 127
53881: PUSH
53882: LD_VAR 0 4
53886: ARRAY
53887: PUSH
53888: FOR_IN
53889: IFFALSE 53949
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53891: LD_VAR 0 3
53895: PPUSH
53896: LD_VAR 0 5
53900: PPUSH
53901: CALL_OW 430
53905: PUSH
53906: LD_VAR 0 4
53910: PPUSH
53911: LD_VAR 0 5
53915: PPUSH
53916: CALL 68392 0 2
53920: AND
53921: IFFALSE 53947
// begin researching := true ;
53923: LD_ADDR_VAR 0 10
53927: PUSH
53928: LD_INT 1
53930: ST_TO_ADDR
// ComResearch ( j , t ) ;
53931: LD_VAR 0 3
53935: PPUSH
53936: LD_VAR 0 5
53940: PPUSH
53941: CALL_OW 124
// break ;
53945: GO 53949
// end ;
53947: GO 53888
53949: POP
53950: POP
// if not researching then
53951: LD_VAR 0 10
53955: NOT
53956: IFFALSE 53968
// idle_lab := j ;
53958: LD_ADDR_VAR 0 11
53962: PUSH
53963: LD_VAR 0 3
53967: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53968: LD_VAR 0 3
53972: PPUSH
53973: CALL_OW 461
53977: PUSH
53978: LD_INT 10
53980: EQUAL
53981: IFFALSE 54569
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53983: LD_EXP 129
53987: PUSH
53988: LD_VAR 0 2
53992: ARRAY
53993: NOT
53994: PUSH
53995: LD_EXP 130
53999: PUSH
54000: LD_VAR 0 2
54004: ARRAY
54005: NOT
54006: AND
54007: PUSH
54008: LD_EXP 127
54012: PUSH
54013: LD_VAR 0 4
54017: ARRAY
54018: PUSH
54019: LD_INT 1
54021: GREATER
54022: AND
54023: IFFALSE 54154
// begin ComCancel ( j ) ;
54025: LD_VAR 0 3
54029: PPUSH
54030: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
54034: LD_ADDR_EXP 127
54038: PUSH
54039: LD_EXP 127
54043: PPUSH
54044: LD_VAR 0 4
54048: PPUSH
54049: LD_EXP 127
54053: PUSH
54054: LD_VAR 0 4
54058: ARRAY
54059: PPUSH
54060: LD_EXP 127
54064: PUSH
54065: LD_VAR 0 4
54069: ARRAY
54070: PUSH
54071: LD_INT 1
54073: MINUS
54074: PPUSH
54075: LD_EXP 127
54079: PUSH
54080: LD_VAR 0 4
54084: ARRAY
54085: PPUSH
54086: LD_INT 0
54088: PPUSH
54089: CALL 72091 0 4
54093: PPUSH
54094: CALL_OW 1
54098: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
54099: LD_ADDR_EXP 127
54103: PUSH
54104: LD_EXP 127
54108: PPUSH
54109: LD_VAR 0 4
54113: PPUSH
54114: LD_EXP 127
54118: PUSH
54119: LD_VAR 0 4
54123: ARRAY
54124: PPUSH
54125: LD_EXP 127
54129: PUSH
54130: LD_VAR 0 4
54134: ARRAY
54135: PPUSH
54136: LD_INT 1
54138: PPUSH
54139: LD_INT 0
54141: PPUSH
54142: CALL 72091 0 4
54146: PPUSH
54147: CALL_OW 1
54151: ST_TO_ADDR
// continue ;
54152: GO 53726
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
54154: LD_EXP 129
54158: PUSH
54159: LD_VAR 0 2
54163: ARRAY
54164: PUSH
54165: LD_EXP 130
54169: PUSH
54170: LD_VAR 0 2
54174: ARRAY
54175: NOT
54176: AND
54177: IFFALSE 54304
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
54179: LD_ADDR_EXP 130
54183: PUSH
54184: LD_EXP 130
54188: PPUSH
54189: LD_VAR 0 2
54193: PUSH
54194: LD_EXP 130
54198: PUSH
54199: LD_VAR 0 2
54203: ARRAY
54204: PUSH
54205: LD_INT 1
54207: PLUS
54208: PUSH
54209: EMPTY
54210: LIST
54211: LIST
54212: PPUSH
54213: LD_EXP 129
54217: PUSH
54218: LD_VAR 0 2
54222: ARRAY
54223: PUSH
54224: LD_INT 1
54226: ARRAY
54227: PPUSH
54228: CALL 72673 0 3
54232: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
54233: LD_EXP 129
54237: PUSH
54238: LD_VAR 0 2
54242: ARRAY
54243: PUSH
54244: LD_INT 1
54246: ARRAY
54247: PPUSH
54248: LD_INT 112
54250: PPUSH
54251: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
54255: LD_ADDR_VAR 0 9
54259: PUSH
54260: LD_EXP 129
54264: PUSH
54265: LD_VAR 0 2
54269: ARRAY
54270: PPUSH
54271: LD_INT 1
54273: PPUSH
54274: CALL_OW 3
54278: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
54279: LD_ADDR_EXP 129
54283: PUSH
54284: LD_EXP 129
54288: PPUSH
54289: LD_VAR 0 2
54293: PPUSH
54294: LD_VAR 0 9
54298: PPUSH
54299: CALL_OW 1
54303: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54304: LD_EXP 129
54308: PUSH
54309: LD_VAR 0 2
54313: ARRAY
54314: PUSH
54315: LD_EXP 130
54319: PUSH
54320: LD_VAR 0 2
54324: ARRAY
54325: AND
54326: PUSH
54327: LD_EXP 130
54331: PUSH
54332: LD_VAR 0 2
54336: ARRAY
54337: PUSH
54338: LD_INT 1
54340: ARRAY
54341: PPUSH
54342: CALL_OW 310
54346: NOT
54347: AND
54348: PUSH
54349: LD_VAR 0 3
54353: PPUSH
54354: CALL_OW 313
54358: PUSH
54359: LD_INT 6
54361: EQUAL
54362: AND
54363: IFFALSE 54419
// begin tmp2 := UnitsInside ( j ) ;
54365: LD_ADDR_VAR 0 9
54369: PUSH
54370: LD_VAR 0 3
54374: PPUSH
54375: CALL_OW 313
54379: ST_TO_ADDR
// if tmp2 = 6 then
54380: LD_VAR 0 9
54384: PUSH
54385: LD_INT 6
54387: EQUAL
54388: IFFALSE 54419
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54390: LD_VAR 0 9
54394: PUSH
54395: LD_INT 1
54397: ARRAY
54398: PPUSH
54399: LD_INT 112
54401: PPUSH
54402: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54406: LD_VAR 0 9
54410: PUSH
54411: LD_INT 1
54413: ARRAY
54414: PPUSH
54415: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54419: LD_EXP 130
54423: PUSH
54424: LD_VAR 0 2
54428: ARRAY
54429: PUSH
54430: LD_EXP 130
54434: PUSH
54435: LD_VAR 0 2
54439: ARRAY
54440: PUSH
54441: LD_INT 1
54443: ARRAY
54444: PPUSH
54445: CALL_OW 314
54449: NOT
54450: AND
54451: PUSH
54452: LD_EXP 130
54456: PUSH
54457: LD_VAR 0 2
54461: ARRAY
54462: PUSH
54463: LD_INT 1
54465: ARRAY
54466: PPUSH
54467: CALL_OW 310
54471: NOT
54472: AND
54473: IFFALSE 54499
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54475: LD_EXP 130
54479: PUSH
54480: LD_VAR 0 2
54484: ARRAY
54485: PUSH
54486: LD_INT 1
54488: ARRAY
54489: PPUSH
54490: LD_VAR 0 3
54494: PPUSH
54495: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54499: LD_EXP 130
54503: PUSH
54504: LD_VAR 0 2
54508: ARRAY
54509: PUSH
54510: LD_INT 1
54512: ARRAY
54513: PPUSH
54514: CALL_OW 310
54518: PUSH
54519: LD_EXP 130
54523: PUSH
54524: LD_VAR 0 2
54528: ARRAY
54529: PUSH
54530: LD_INT 1
54532: ARRAY
54533: PPUSH
54534: CALL_OW 310
54538: PPUSH
54539: CALL_OW 461
54543: PUSH
54544: LD_INT 3
54546: NONEQUAL
54547: AND
54548: IFFALSE 54569
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54550: LD_EXP 130
54554: PUSH
54555: LD_VAR 0 2
54559: ARRAY
54560: PUSH
54561: LD_INT 1
54563: ARRAY
54564: PPUSH
54565: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54569: LD_VAR 0 3
54573: PPUSH
54574: CALL_OW 461
54578: PUSH
54579: LD_INT 6
54581: EQUAL
54582: PUSH
54583: LD_VAR 0 6
54587: PUSH
54588: LD_INT 1
54590: GREATER
54591: AND
54592: IFFALSE 54744
// begin sci := [ ] ;
54594: LD_ADDR_VAR 0 8
54598: PUSH
54599: EMPTY
54600: ST_TO_ADDR
// for x in ( tmp diff j ) do
54601: LD_ADDR_VAR 0 7
54605: PUSH
54606: LD_VAR 0 6
54610: PUSH
54611: LD_VAR 0 3
54615: DIFF
54616: PUSH
54617: FOR_IN
54618: IFFALSE 54670
// begin if sci = 6 then
54620: LD_VAR 0 8
54624: PUSH
54625: LD_INT 6
54627: EQUAL
54628: IFFALSE 54632
// break ;
54630: GO 54670
// if BuildingStatus ( x ) = bs_idle then
54632: LD_VAR 0 7
54636: PPUSH
54637: CALL_OW 461
54641: PUSH
54642: LD_INT 2
54644: EQUAL
54645: IFFALSE 54668
// sci := sci ^ UnitsInside ( x ) ;
54647: LD_ADDR_VAR 0 8
54651: PUSH
54652: LD_VAR 0 8
54656: PUSH
54657: LD_VAR 0 7
54661: PPUSH
54662: CALL_OW 313
54666: ADD
54667: ST_TO_ADDR
// end ;
54668: GO 54617
54670: POP
54671: POP
// if not sci then
54672: LD_VAR 0 8
54676: NOT
54677: IFFALSE 54681
// continue ;
54679: GO 53726
// for x in sci do
54681: LD_ADDR_VAR 0 7
54685: PUSH
54686: LD_VAR 0 8
54690: PUSH
54691: FOR_IN
54692: IFFALSE 54742
// if IsInUnit ( x ) and not HasTask ( x ) then
54694: LD_VAR 0 7
54698: PPUSH
54699: CALL_OW 310
54703: PUSH
54704: LD_VAR 0 7
54708: PPUSH
54709: CALL_OW 314
54713: NOT
54714: AND
54715: IFFALSE 54740
// begin ComExitBuilding ( x ) ;
54717: LD_VAR 0 7
54721: PPUSH
54722: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54726: LD_VAR 0 7
54730: PPUSH
54731: LD_VAR 0 3
54735: PPUSH
54736: CALL_OW 180
// end ;
54740: GO 54691
54742: POP
54743: POP
// end ; end ;
54744: GO 53726
54746: POP
54747: POP
// end ;
54748: GO 53680
54750: POP
54751: POP
// end ;
54752: LD_VAR 0 1
54756: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54757: LD_INT 0
54759: PPUSH
54760: PPUSH
// if not mc_bases then
54761: LD_EXP 100
54765: NOT
54766: IFFALSE 54770
// exit ;
54768: GO 54851
// for i = 1 to mc_bases do
54770: LD_ADDR_VAR 0 2
54774: PUSH
54775: DOUBLE
54776: LD_INT 1
54778: DEC
54779: ST_TO_ADDR
54780: LD_EXP 100
54784: PUSH
54785: FOR_TO
54786: IFFALSE 54849
// if mc_mines [ i ] and mc_miners [ i ] then
54788: LD_EXP 113
54792: PUSH
54793: LD_VAR 0 2
54797: ARRAY
54798: PUSH
54799: LD_EXP 114
54803: PUSH
54804: LD_VAR 0 2
54808: ARRAY
54809: AND
54810: IFFALSE 54847
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54812: LD_EXP 114
54816: PUSH
54817: LD_VAR 0 2
54821: ARRAY
54822: PUSH
54823: LD_INT 1
54825: ARRAY
54826: PPUSH
54827: CALL_OW 255
54831: PPUSH
54832: LD_EXP 113
54836: PUSH
54837: LD_VAR 0 2
54841: ARRAY
54842: PPUSH
54843: CALL 69475 0 2
54847: GO 54785
54849: POP
54850: POP
// end ;
54851: LD_VAR 0 1
54855: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54856: LD_INT 0
54858: PPUSH
54859: PPUSH
54860: PPUSH
54861: PPUSH
54862: PPUSH
54863: PPUSH
54864: PPUSH
54865: PPUSH
// if not mc_bases or not mc_parking then
54866: LD_EXP 100
54870: NOT
54871: PUSH
54872: LD_EXP 124
54876: NOT
54877: OR
54878: IFFALSE 54882
// exit ;
54880: GO 55620
// for i = 1 to mc_bases do
54882: LD_ADDR_VAR 0 2
54886: PUSH
54887: DOUBLE
54888: LD_INT 1
54890: DEC
54891: ST_TO_ADDR
54892: LD_EXP 100
54896: PUSH
54897: FOR_TO
54898: IFFALSE 55618
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54900: LD_EXP 100
54904: PUSH
54905: LD_VAR 0 2
54909: ARRAY
54910: NOT
54911: PUSH
54912: LD_EXP 124
54916: PUSH
54917: LD_VAR 0 2
54921: ARRAY
54922: NOT
54923: OR
54924: IFFALSE 54928
// continue ;
54926: GO 54897
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54928: LD_ADDR_VAR 0 5
54932: PUSH
54933: LD_EXP 100
54937: PUSH
54938: LD_VAR 0 2
54942: ARRAY
54943: PUSH
54944: LD_INT 1
54946: ARRAY
54947: PPUSH
54948: CALL_OW 255
54952: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54953: LD_ADDR_VAR 0 6
54957: PUSH
54958: LD_EXP 100
54962: PUSH
54963: LD_VAR 0 2
54967: ARRAY
54968: PPUSH
54969: LD_INT 30
54971: PUSH
54972: LD_INT 3
54974: PUSH
54975: EMPTY
54976: LIST
54977: LIST
54978: PPUSH
54979: CALL_OW 72
54983: ST_TO_ADDR
// if not fac then
54984: LD_VAR 0 6
54988: NOT
54989: IFFALSE 55040
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54991: LD_ADDR_VAR 0 6
54995: PUSH
54996: LD_EXP 100
55000: PUSH
55001: LD_VAR 0 2
55005: ARRAY
55006: PPUSH
55007: LD_INT 2
55009: PUSH
55010: LD_INT 30
55012: PUSH
55013: LD_INT 0
55015: PUSH
55016: EMPTY
55017: LIST
55018: LIST
55019: PUSH
55020: LD_INT 30
55022: PUSH
55023: LD_INT 1
55025: PUSH
55026: EMPTY
55027: LIST
55028: LIST
55029: PUSH
55030: EMPTY
55031: LIST
55032: LIST
55033: LIST
55034: PPUSH
55035: CALL_OW 72
55039: ST_TO_ADDR
// if not fac then
55040: LD_VAR 0 6
55044: NOT
55045: IFFALSE 55049
// continue ;
55047: GO 54897
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55049: LD_ADDR_VAR 0 7
55053: PUSH
55054: LD_EXP 124
55058: PUSH
55059: LD_VAR 0 2
55063: ARRAY
55064: PPUSH
55065: LD_INT 22
55067: PUSH
55068: LD_VAR 0 5
55072: PUSH
55073: EMPTY
55074: LIST
55075: LIST
55076: PUSH
55077: LD_INT 21
55079: PUSH
55080: LD_INT 2
55082: PUSH
55083: EMPTY
55084: LIST
55085: LIST
55086: PUSH
55087: LD_INT 3
55089: PUSH
55090: LD_INT 60
55092: PUSH
55093: EMPTY
55094: LIST
55095: PUSH
55096: EMPTY
55097: LIST
55098: LIST
55099: PUSH
55100: LD_INT 3
55102: PUSH
55103: LD_INT 24
55105: PUSH
55106: LD_INT 1000
55108: PUSH
55109: EMPTY
55110: LIST
55111: LIST
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: LIST
55121: LIST
55122: PPUSH
55123: CALL_OW 70
55127: ST_TO_ADDR
// for j in fac do
55128: LD_ADDR_VAR 0 3
55132: PUSH
55133: LD_VAR 0 6
55137: PUSH
55138: FOR_IN
55139: IFFALSE 55234
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55141: LD_ADDR_VAR 0 7
55145: PUSH
55146: LD_VAR 0 7
55150: PUSH
55151: LD_INT 22
55153: PUSH
55154: LD_VAR 0 5
55158: PUSH
55159: EMPTY
55160: LIST
55161: LIST
55162: PUSH
55163: LD_INT 91
55165: PUSH
55166: LD_VAR 0 3
55170: PUSH
55171: LD_INT 15
55173: PUSH
55174: EMPTY
55175: LIST
55176: LIST
55177: LIST
55178: PUSH
55179: LD_INT 21
55181: PUSH
55182: LD_INT 2
55184: PUSH
55185: EMPTY
55186: LIST
55187: LIST
55188: PUSH
55189: LD_INT 3
55191: PUSH
55192: LD_INT 60
55194: PUSH
55195: EMPTY
55196: LIST
55197: PUSH
55198: EMPTY
55199: LIST
55200: LIST
55201: PUSH
55202: LD_INT 3
55204: PUSH
55205: LD_INT 24
55207: PUSH
55208: LD_INT 1000
55210: PUSH
55211: EMPTY
55212: LIST
55213: LIST
55214: PUSH
55215: EMPTY
55216: LIST
55217: LIST
55218: PUSH
55219: EMPTY
55220: LIST
55221: LIST
55222: LIST
55223: LIST
55224: LIST
55225: PPUSH
55226: CALL_OW 69
55230: UNION
55231: ST_TO_ADDR
55232: GO 55138
55234: POP
55235: POP
// if not vehs then
55236: LD_VAR 0 7
55240: NOT
55241: IFFALSE 55267
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55243: LD_ADDR_EXP 112
55247: PUSH
55248: LD_EXP 112
55252: PPUSH
55253: LD_VAR 0 2
55257: PPUSH
55258: EMPTY
55259: PPUSH
55260: CALL_OW 1
55264: ST_TO_ADDR
// continue ;
55265: GO 54897
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55267: LD_ADDR_VAR 0 8
55271: PUSH
55272: LD_EXP 100
55276: PUSH
55277: LD_VAR 0 2
55281: ARRAY
55282: PPUSH
55283: LD_INT 30
55285: PUSH
55286: LD_INT 3
55288: PUSH
55289: EMPTY
55290: LIST
55291: LIST
55292: PPUSH
55293: CALL_OW 72
55297: ST_TO_ADDR
// if tmp then
55298: LD_VAR 0 8
55302: IFFALSE 55405
// begin for j in tmp do
55304: LD_ADDR_VAR 0 3
55308: PUSH
55309: LD_VAR 0 8
55313: PUSH
55314: FOR_IN
55315: IFFALSE 55403
// for k in UnitsInside ( j ) do
55317: LD_ADDR_VAR 0 4
55321: PUSH
55322: LD_VAR 0 3
55326: PPUSH
55327: CALL_OW 313
55331: PUSH
55332: FOR_IN
55333: IFFALSE 55399
// if k then
55335: LD_VAR 0 4
55339: IFFALSE 55397
// if not k in mc_repair_vehicle [ i ] then
55341: LD_VAR 0 4
55345: PUSH
55346: LD_EXP 112
55350: PUSH
55351: LD_VAR 0 2
55355: ARRAY
55356: IN
55357: NOT
55358: IFFALSE 55397
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55360: LD_ADDR_EXP 112
55364: PUSH
55365: LD_EXP 112
55369: PPUSH
55370: LD_VAR 0 2
55374: PPUSH
55375: LD_EXP 112
55379: PUSH
55380: LD_VAR 0 2
55384: ARRAY
55385: PUSH
55386: LD_VAR 0 4
55390: UNION
55391: PPUSH
55392: CALL_OW 1
55396: ST_TO_ADDR
55397: GO 55332
55399: POP
55400: POP
55401: GO 55314
55403: POP
55404: POP
// end ; if not mc_repair_vehicle [ i ] then
55405: LD_EXP 112
55409: PUSH
55410: LD_VAR 0 2
55414: ARRAY
55415: NOT
55416: IFFALSE 55420
// continue ;
55418: GO 54897
// for j in mc_repair_vehicle [ i ] do
55420: LD_ADDR_VAR 0 3
55424: PUSH
55425: LD_EXP 112
55429: PUSH
55430: LD_VAR 0 2
55434: ARRAY
55435: PUSH
55436: FOR_IN
55437: IFFALSE 55614
// begin if GetClass ( j ) <> 3 then
55439: LD_VAR 0 3
55443: PPUSH
55444: CALL_OW 257
55448: PUSH
55449: LD_INT 3
55451: NONEQUAL
55452: IFFALSE 55493
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55454: LD_ADDR_EXP 112
55458: PUSH
55459: LD_EXP 112
55463: PPUSH
55464: LD_VAR 0 2
55468: PPUSH
55469: LD_EXP 112
55473: PUSH
55474: LD_VAR 0 2
55478: ARRAY
55479: PUSH
55480: LD_VAR 0 3
55484: DIFF
55485: PPUSH
55486: CALL_OW 1
55490: ST_TO_ADDR
// continue ;
55491: GO 55436
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55493: LD_VAR 0 3
55497: PPUSH
55498: CALL_OW 311
55502: NOT
55503: PUSH
55504: LD_VAR 0 3
55508: PUSH
55509: LD_EXP 103
55513: PUSH
55514: LD_VAR 0 2
55518: ARRAY
55519: PUSH
55520: LD_INT 1
55522: ARRAY
55523: IN
55524: NOT
55525: AND
55526: PUSH
55527: LD_VAR 0 3
55531: PUSH
55532: LD_EXP 103
55536: PUSH
55537: LD_VAR 0 2
55541: ARRAY
55542: PUSH
55543: LD_INT 2
55545: ARRAY
55546: IN
55547: NOT
55548: AND
55549: IFFALSE 55612
// begin if IsInUnit ( j ) then
55551: LD_VAR 0 3
55555: PPUSH
55556: CALL_OW 310
55560: IFFALSE 55573
// ComExitBuilding ( j ) else
55562: LD_VAR 0 3
55566: PPUSH
55567: CALL_OW 122
55571: GO 55612
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55573: LD_VAR 0 3
55577: PPUSH
55578: LD_VAR 0 7
55582: PUSH
55583: LD_INT 1
55585: ARRAY
55586: PPUSH
55587: CALL 107050 0 2
55591: NOT
55592: IFFALSE 55612
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55594: LD_VAR 0 3
55598: PPUSH
55599: LD_VAR 0 7
55603: PUSH
55604: LD_INT 1
55606: ARRAY
55607: PPUSH
55608: CALL_OW 129
// end ; end ;
55612: GO 55436
55614: POP
55615: POP
// end ;
55616: GO 54897
55618: POP
55619: POP
// end ;
55620: LD_VAR 0 1
55624: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55625: LD_INT 0
55627: PPUSH
55628: PPUSH
55629: PPUSH
55630: PPUSH
55631: PPUSH
55632: PPUSH
55633: PPUSH
55634: PPUSH
55635: PPUSH
55636: PPUSH
55637: PPUSH
// if not mc_bases then
55638: LD_EXP 100
55642: NOT
55643: IFFALSE 55647
// exit ;
55645: GO 56449
// for i = 1 to mc_bases do
55647: LD_ADDR_VAR 0 2
55651: PUSH
55652: DOUBLE
55653: LD_INT 1
55655: DEC
55656: ST_TO_ADDR
55657: LD_EXP 100
55661: PUSH
55662: FOR_TO
55663: IFFALSE 56447
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55665: LD_EXP 128
55669: PUSH
55670: LD_VAR 0 2
55674: ARRAY
55675: NOT
55676: PUSH
55677: LD_EXP 103
55681: PUSH
55682: LD_VAR 0 2
55686: ARRAY
55687: PUSH
55688: LD_INT 1
55690: ARRAY
55691: OR
55692: PUSH
55693: LD_EXP 103
55697: PUSH
55698: LD_VAR 0 2
55702: ARRAY
55703: PUSH
55704: LD_INT 2
55706: ARRAY
55707: OR
55708: PUSH
55709: LD_EXP 126
55713: PUSH
55714: LD_VAR 0 2
55718: ARRAY
55719: PPUSH
55720: LD_INT 1
55722: PPUSH
55723: CALL_OW 325
55727: NOT
55728: OR
55729: PUSH
55730: LD_EXP 123
55734: PUSH
55735: LD_VAR 0 2
55739: ARRAY
55740: OR
55741: IFFALSE 55745
// continue ;
55743: GO 55662
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55745: LD_ADDR_VAR 0 8
55749: PUSH
55750: LD_EXP 100
55754: PUSH
55755: LD_VAR 0 2
55759: ARRAY
55760: PPUSH
55761: LD_INT 25
55763: PUSH
55764: LD_INT 4
55766: PUSH
55767: EMPTY
55768: LIST
55769: LIST
55770: PUSH
55771: LD_INT 50
55773: PUSH
55774: EMPTY
55775: LIST
55776: PUSH
55777: LD_INT 3
55779: PUSH
55780: LD_INT 60
55782: PUSH
55783: EMPTY
55784: LIST
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: PPUSH
55795: CALL_OW 72
55799: PUSH
55800: LD_EXP 104
55804: PUSH
55805: LD_VAR 0 2
55809: ARRAY
55810: DIFF
55811: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55812: LD_ADDR_VAR 0 9
55816: PUSH
55817: LD_EXP 100
55821: PUSH
55822: LD_VAR 0 2
55826: ARRAY
55827: PPUSH
55828: LD_INT 2
55830: PUSH
55831: LD_INT 30
55833: PUSH
55834: LD_INT 0
55836: PUSH
55837: EMPTY
55838: LIST
55839: LIST
55840: PUSH
55841: LD_INT 30
55843: PUSH
55844: LD_INT 1
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: LIST
55855: PPUSH
55856: CALL_OW 72
55860: ST_TO_ADDR
// if not tmp or not dep then
55861: LD_VAR 0 8
55865: NOT
55866: PUSH
55867: LD_VAR 0 9
55871: NOT
55872: OR
55873: IFFALSE 55877
// continue ;
55875: GO 55662
// side := GetSide ( tmp [ 1 ] ) ;
55877: LD_ADDR_VAR 0 11
55881: PUSH
55882: LD_VAR 0 8
55886: PUSH
55887: LD_INT 1
55889: ARRAY
55890: PPUSH
55891: CALL_OW 255
55895: ST_TO_ADDR
// dep := dep [ 1 ] ;
55896: LD_ADDR_VAR 0 9
55900: PUSH
55901: LD_VAR 0 9
55905: PUSH
55906: LD_INT 1
55908: ARRAY
55909: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55910: LD_ADDR_VAR 0 7
55914: PUSH
55915: LD_EXP 128
55919: PUSH
55920: LD_VAR 0 2
55924: ARRAY
55925: PPUSH
55926: LD_INT 22
55928: PUSH
55929: LD_INT 0
55931: PUSH
55932: EMPTY
55933: LIST
55934: LIST
55935: PUSH
55936: LD_INT 25
55938: PUSH
55939: LD_INT 12
55941: PUSH
55942: EMPTY
55943: LIST
55944: LIST
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: PPUSH
55950: CALL_OW 70
55954: PUSH
55955: LD_INT 22
55957: PUSH
55958: LD_INT 0
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: PUSH
55965: LD_INT 25
55967: PUSH
55968: LD_INT 12
55970: PUSH
55971: EMPTY
55972: LIST
55973: LIST
55974: PUSH
55975: LD_INT 91
55977: PUSH
55978: LD_VAR 0 9
55982: PUSH
55983: LD_INT 20
55985: PUSH
55986: EMPTY
55987: LIST
55988: LIST
55989: LIST
55990: PUSH
55991: EMPTY
55992: LIST
55993: LIST
55994: LIST
55995: PPUSH
55996: CALL_OW 69
56000: UNION
56001: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
56002: LD_ADDR_VAR 0 10
56006: PUSH
56007: LD_EXP 128
56011: PUSH
56012: LD_VAR 0 2
56016: ARRAY
56017: PPUSH
56018: LD_INT 81
56020: PUSH
56021: LD_VAR 0 11
56025: PUSH
56026: EMPTY
56027: LIST
56028: LIST
56029: PPUSH
56030: CALL_OW 70
56034: ST_TO_ADDR
// if not apes or danger_at_area then
56035: LD_VAR 0 7
56039: NOT
56040: PUSH
56041: LD_VAR 0 10
56045: OR
56046: IFFALSE 56096
// begin if mc_taming [ i ] then
56048: LD_EXP 131
56052: PUSH
56053: LD_VAR 0 2
56057: ARRAY
56058: IFFALSE 56094
// begin MC_Reset ( i , 121 ) ;
56060: LD_VAR 0 2
56064: PPUSH
56065: LD_INT 121
56067: PPUSH
56068: CALL 41033 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56072: LD_ADDR_EXP 131
56076: PUSH
56077: LD_EXP 131
56081: PPUSH
56082: LD_VAR 0 2
56086: PPUSH
56087: EMPTY
56088: PPUSH
56089: CALL_OW 1
56093: ST_TO_ADDR
// end ; continue ;
56094: GO 55662
// end ; for j in tmp do
56096: LD_ADDR_VAR 0 3
56100: PUSH
56101: LD_VAR 0 8
56105: PUSH
56106: FOR_IN
56107: IFFALSE 56443
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
56109: LD_VAR 0 3
56113: PUSH
56114: LD_EXP 131
56118: PUSH
56119: LD_VAR 0 2
56123: ARRAY
56124: IN
56125: NOT
56126: PUSH
56127: LD_EXP 131
56131: PUSH
56132: LD_VAR 0 2
56136: ARRAY
56137: PUSH
56138: LD_INT 3
56140: LESS
56141: AND
56142: IFFALSE 56200
// begin SetTag ( j , 121 ) ;
56144: LD_VAR 0 3
56148: PPUSH
56149: LD_INT 121
56151: PPUSH
56152: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
56156: LD_ADDR_EXP 131
56160: PUSH
56161: LD_EXP 131
56165: PPUSH
56166: LD_VAR 0 2
56170: PUSH
56171: LD_EXP 131
56175: PUSH
56176: LD_VAR 0 2
56180: ARRAY
56181: PUSH
56182: LD_INT 1
56184: PLUS
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: PPUSH
56190: LD_VAR 0 3
56194: PPUSH
56195: CALL 72673 0 3
56199: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
56200: LD_VAR 0 3
56204: PUSH
56205: LD_EXP 131
56209: PUSH
56210: LD_VAR 0 2
56214: ARRAY
56215: IN
56216: IFFALSE 56441
// begin if GetClass ( j ) <> 4 then
56218: LD_VAR 0 3
56222: PPUSH
56223: CALL_OW 257
56227: PUSH
56228: LD_INT 4
56230: NONEQUAL
56231: IFFALSE 56284
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
56233: LD_ADDR_EXP 131
56237: PUSH
56238: LD_EXP 131
56242: PPUSH
56243: LD_VAR 0 2
56247: PPUSH
56248: LD_EXP 131
56252: PUSH
56253: LD_VAR 0 2
56257: ARRAY
56258: PUSH
56259: LD_VAR 0 3
56263: DIFF
56264: PPUSH
56265: CALL_OW 1
56269: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56270: LD_VAR 0 3
56274: PPUSH
56275: LD_INT 0
56277: PPUSH
56278: CALL_OW 109
// continue ;
56282: GO 56106
// end ; if IsInUnit ( j ) then
56284: LD_VAR 0 3
56288: PPUSH
56289: CALL_OW 310
56293: IFFALSE 56304
// ComExitBuilding ( j ) ;
56295: LD_VAR 0 3
56299: PPUSH
56300: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56304: LD_ADDR_VAR 0 6
56308: PUSH
56309: LD_VAR 0 7
56313: PPUSH
56314: LD_VAR 0 3
56318: PPUSH
56319: CALL_OW 74
56323: ST_TO_ADDR
// if not ape then
56324: LD_VAR 0 6
56328: NOT
56329: IFFALSE 56333
// break ;
56331: GO 56443
// x := GetX ( ape ) ;
56333: LD_ADDR_VAR 0 4
56337: PUSH
56338: LD_VAR 0 6
56342: PPUSH
56343: CALL_OW 250
56347: ST_TO_ADDR
// y := GetY ( ape ) ;
56348: LD_ADDR_VAR 0 5
56352: PUSH
56353: LD_VAR 0 6
56357: PPUSH
56358: CALL_OW 251
56362: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56363: LD_VAR 0 4
56367: PPUSH
56368: LD_VAR 0 5
56372: PPUSH
56373: CALL_OW 488
56377: NOT
56378: PUSH
56379: LD_VAR 0 11
56383: PPUSH
56384: LD_VAR 0 4
56388: PPUSH
56389: LD_VAR 0 5
56393: PPUSH
56394: LD_INT 20
56396: PPUSH
56397: CALL 73569 0 4
56401: PUSH
56402: LD_INT 4
56404: ARRAY
56405: OR
56406: IFFALSE 56410
// break ;
56408: GO 56443
// if not HasTask ( j ) then
56410: LD_VAR 0 3
56414: PPUSH
56415: CALL_OW 314
56419: NOT
56420: IFFALSE 56441
// ComTameXY ( j , x , y ) ;
56422: LD_VAR 0 3
56426: PPUSH
56427: LD_VAR 0 4
56431: PPUSH
56432: LD_VAR 0 5
56436: PPUSH
56437: CALL_OW 131
// end ; end ;
56441: GO 56106
56443: POP
56444: POP
// end ;
56445: GO 55662
56447: POP
56448: POP
// end ;
56449: LD_VAR 0 1
56453: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56454: LD_INT 0
56456: PPUSH
56457: PPUSH
56458: PPUSH
56459: PPUSH
56460: PPUSH
56461: PPUSH
56462: PPUSH
56463: PPUSH
// if not mc_bases then
56464: LD_EXP 100
56468: NOT
56469: IFFALSE 56473
// exit ;
56471: GO 57099
// for i = 1 to mc_bases do
56473: LD_ADDR_VAR 0 2
56477: PUSH
56478: DOUBLE
56479: LD_INT 1
56481: DEC
56482: ST_TO_ADDR
56483: LD_EXP 100
56487: PUSH
56488: FOR_TO
56489: IFFALSE 57097
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56491: LD_EXP 129
56495: PUSH
56496: LD_VAR 0 2
56500: ARRAY
56501: NOT
56502: PUSH
56503: LD_EXP 129
56507: PUSH
56508: LD_VAR 0 2
56512: ARRAY
56513: PPUSH
56514: LD_INT 25
56516: PUSH
56517: LD_INT 12
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: PPUSH
56524: CALL_OW 72
56528: NOT
56529: OR
56530: IFFALSE 56534
// continue ;
56532: GO 56488
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56534: LD_ADDR_VAR 0 5
56538: PUSH
56539: LD_EXP 129
56543: PUSH
56544: LD_VAR 0 2
56548: ARRAY
56549: PUSH
56550: LD_INT 1
56552: ARRAY
56553: PPUSH
56554: CALL_OW 255
56558: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56559: LD_VAR 0 5
56563: PPUSH
56564: LD_INT 2
56566: PPUSH
56567: CALL_OW 325
56571: IFFALSE 56824
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56573: LD_ADDR_VAR 0 4
56577: PUSH
56578: LD_EXP 129
56582: PUSH
56583: LD_VAR 0 2
56587: ARRAY
56588: PPUSH
56589: LD_INT 25
56591: PUSH
56592: LD_INT 16
56594: PUSH
56595: EMPTY
56596: LIST
56597: LIST
56598: PPUSH
56599: CALL_OW 72
56603: ST_TO_ADDR
// if tmp < 6 then
56604: LD_VAR 0 4
56608: PUSH
56609: LD_INT 6
56611: LESS
56612: IFFALSE 56824
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56614: LD_ADDR_VAR 0 6
56618: PUSH
56619: LD_EXP 100
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PPUSH
56630: LD_INT 2
56632: PUSH
56633: LD_INT 30
56635: PUSH
56636: LD_INT 0
56638: PUSH
56639: EMPTY
56640: LIST
56641: LIST
56642: PUSH
56643: LD_INT 30
56645: PUSH
56646: LD_INT 1
56648: PUSH
56649: EMPTY
56650: LIST
56651: LIST
56652: PUSH
56653: EMPTY
56654: LIST
56655: LIST
56656: LIST
56657: PPUSH
56658: CALL_OW 72
56662: ST_TO_ADDR
// if depot then
56663: LD_VAR 0 6
56667: IFFALSE 56824
// begin selected := 0 ;
56669: LD_ADDR_VAR 0 7
56673: PUSH
56674: LD_INT 0
56676: ST_TO_ADDR
// for j in depot do
56677: LD_ADDR_VAR 0 3
56681: PUSH
56682: LD_VAR 0 6
56686: PUSH
56687: FOR_IN
56688: IFFALSE 56719
// begin if UnitsInside ( j ) < 6 then
56690: LD_VAR 0 3
56694: PPUSH
56695: CALL_OW 313
56699: PUSH
56700: LD_INT 6
56702: LESS
56703: IFFALSE 56717
// begin selected := j ;
56705: LD_ADDR_VAR 0 7
56709: PUSH
56710: LD_VAR 0 3
56714: ST_TO_ADDR
// break ;
56715: GO 56719
// end ; end ;
56717: GO 56687
56719: POP
56720: POP
// if selected then
56721: LD_VAR 0 7
56725: IFFALSE 56824
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56727: LD_ADDR_VAR 0 3
56731: PUSH
56732: LD_EXP 129
56736: PUSH
56737: LD_VAR 0 2
56741: ARRAY
56742: PPUSH
56743: LD_INT 25
56745: PUSH
56746: LD_INT 12
56748: PUSH
56749: EMPTY
56750: LIST
56751: LIST
56752: PPUSH
56753: CALL_OW 72
56757: PUSH
56758: FOR_IN
56759: IFFALSE 56822
// if not HasTask ( j ) then
56761: LD_VAR 0 3
56765: PPUSH
56766: CALL_OW 314
56770: NOT
56771: IFFALSE 56820
// begin if not IsInUnit ( j ) then
56773: LD_VAR 0 3
56777: PPUSH
56778: CALL_OW 310
56782: NOT
56783: IFFALSE 56799
// ComEnterUnit ( j , selected ) ;
56785: LD_VAR 0 3
56789: PPUSH
56790: LD_VAR 0 7
56794: PPUSH
56795: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56799: LD_VAR 0 3
56803: PPUSH
56804: LD_INT 16
56806: PPUSH
56807: CALL_OW 183
// AddComExitBuilding ( j ) ;
56811: LD_VAR 0 3
56815: PPUSH
56816: CALL_OW 182
// end ;
56820: GO 56758
56822: POP
56823: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56824: LD_VAR 0 5
56828: PPUSH
56829: LD_INT 11
56831: PPUSH
56832: CALL_OW 325
56836: IFFALSE 57095
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56838: LD_ADDR_VAR 0 4
56842: PUSH
56843: LD_EXP 129
56847: PUSH
56848: LD_VAR 0 2
56852: ARRAY
56853: PPUSH
56854: LD_INT 25
56856: PUSH
56857: LD_INT 16
56859: PUSH
56860: EMPTY
56861: LIST
56862: LIST
56863: PPUSH
56864: CALL_OW 72
56868: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56869: LD_VAR 0 4
56873: PUSH
56874: LD_INT 6
56876: GREATEREQUAL
56877: PUSH
56878: LD_VAR 0 5
56882: PPUSH
56883: LD_INT 2
56885: PPUSH
56886: CALL_OW 325
56890: NOT
56891: OR
56892: IFFALSE 57095
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56894: LD_ADDR_VAR 0 8
56898: PUSH
56899: LD_EXP 100
56903: PUSH
56904: LD_VAR 0 2
56908: ARRAY
56909: PPUSH
56910: LD_INT 2
56912: PUSH
56913: LD_INT 30
56915: PUSH
56916: LD_INT 4
56918: PUSH
56919: EMPTY
56920: LIST
56921: LIST
56922: PUSH
56923: LD_INT 30
56925: PUSH
56926: LD_INT 5
56928: PUSH
56929: EMPTY
56930: LIST
56931: LIST
56932: PUSH
56933: EMPTY
56934: LIST
56935: LIST
56936: LIST
56937: PPUSH
56938: CALL_OW 72
56942: ST_TO_ADDR
// if barracks then
56943: LD_VAR 0 8
56947: IFFALSE 57095
// begin selected := 0 ;
56949: LD_ADDR_VAR 0 7
56953: PUSH
56954: LD_INT 0
56956: ST_TO_ADDR
// for j in barracks do
56957: LD_ADDR_VAR 0 3
56961: PUSH
56962: LD_VAR 0 8
56966: PUSH
56967: FOR_IN
56968: IFFALSE 56999
// begin if UnitsInside ( j ) < 6 then
56970: LD_VAR 0 3
56974: PPUSH
56975: CALL_OW 313
56979: PUSH
56980: LD_INT 6
56982: LESS
56983: IFFALSE 56997
// begin selected := j ;
56985: LD_ADDR_VAR 0 7
56989: PUSH
56990: LD_VAR 0 3
56994: ST_TO_ADDR
// break ;
56995: GO 56999
// end ; end ;
56997: GO 56967
56999: POP
57000: POP
// if selected then
57001: LD_VAR 0 7
57005: IFFALSE 57095
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
57007: LD_ADDR_VAR 0 3
57011: PUSH
57012: LD_EXP 129
57016: PUSH
57017: LD_VAR 0 2
57021: ARRAY
57022: PPUSH
57023: LD_INT 25
57025: PUSH
57026: LD_INT 12
57028: PUSH
57029: EMPTY
57030: LIST
57031: LIST
57032: PPUSH
57033: CALL_OW 72
57037: PUSH
57038: FOR_IN
57039: IFFALSE 57093
// if not IsInUnit ( j ) and not HasTask ( j ) then
57041: LD_VAR 0 3
57045: PPUSH
57046: CALL_OW 310
57050: NOT
57051: PUSH
57052: LD_VAR 0 3
57056: PPUSH
57057: CALL_OW 314
57061: NOT
57062: AND
57063: IFFALSE 57091
// begin ComEnterUnit ( j , selected ) ;
57065: LD_VAR 0 3
57069: PPUSH
57070: LD_VAR 0 7
57074: PPUSH
57075: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
57079: LD_VAR 0 3
57083: PPUSH
57084: LD_INT 15
57086: PPUSH
57087: CALL_OW 183
// end ;
57091: GO 57038
57093: POP
57094: POP
// end ; end ; end ; end ; end ;
57095: GO 56488
57097: POP
57098: POP
// end ;
57099: LD_VAR 0 1
57103: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
57104: LD_INT 0
57106: PPUSH
57107: PPUSH
57108: PPUSH
57109: PPUSH
// if not mc_bases then
57110: LD_EXP 100
57114: NOT
57115: IFFALSE 57119
// exit ;
57117: GO 57297
// for i = 1 to mc_bases do
57119: LD_ADDR_VAR 0 2
57123: PUSH
57124: DOUBLE
57125: LD_INT 1
57127: DEC
57128: ST_TO_ADDR
57129: LD_EXP 100
57133: PUSH
57134: FOR_TO
57135: IFFALSE 57295
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
57137: LD_ADDR_VAR 0 4
57141: PUSH
57142: LD_EXP 100
57146: PUSH
57147: LD_VAR 0 2
57151: ARRAY
57152: PPUSH
57153: LD_INT 25
57155: PUSH
57156: LD_INT 9
57158: PUSH
57159: EMPTY
57160: LIST
57161: LIST
57162: PPUSH
57163: CALL_OW 72
57167: ST_TO_ADDR
// if not tmp then
57168: LD_VAR 0 4
57172: NOT
57173: IFFALSE 57177
// continue ;
57175: GO 57134
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
57177: LD_EXP 126
57181: PUSH
57182: LD_VAR 0 2
57186: ARRAY
57187: PPUSH
57188: LD_INT 29
57190: PPUSH
57191: CALL_OW 325
57195: NOT
57196: PUSH
57197: LD_EXP 126
57201: PUSH
57202: LD_VAR 0 2
57206: ARRAY
57207: PPUSH
57208: LD_INT 28
57210: PPUSH
57211: CALL_OW 325
57215: NOT
57216: AND
57217: IFFALSE 57221
// continue ;
57219: GO 57134
// for j in tmp do
57221: LD_ADDR_VAR 0 3
57225: PUSH
57226: LD_VAR 0 4
57230: PUSH
57231: FOR_IN
57232: IFFALSE 57291
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57234: LD_VAR 0 3
57238: PUSH
57239: LD_EXP 103
57243: PUSH
57244: LD_VAR 0 2
57248: ARRAY
57249: PUSH
57250: LD_INT 1
57252: ARRAY
57253: IN
57254: NOT
57255: PUSH
57256: LD_VAR 0 3
57260: PUSH
57261: LD_EXP 103
57265: PUSH
57266: LD_VAR 0 2
57270: ARRAY
57271: PUSH
57272: LD_INT 2
57274: ARRAY
57275: IN
57276: NOT
57277: AND
57278: IFFALSE 57289
// ComSpaceTimeShoot ( j ) ;
57280: LD_VAR 0 3
57284: PPUSH
57285: CALL 68483 0 1
57289: GO 57231
57291: POP
57292: POP
// end ;
57293: GO 57134
57295: POP
57296: POP
// end ;
57297: LD_VAR 0 1
57301: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57302: LD_INT 0
57304: PPUSH
57305: PPUSH
57306: PPUSH
57307: PPUSH
57308: PPUSH
57309: PPUSH
57310: PPUSH
57311: PPUSH
57312: PPUSH
// if not mc_bases then
57313: LD_EXP 100
57317: NOT
57318: IFFALSE 57322
// exit ;
57320: GO 57944
// for i = 1 to mc_bases do
57322: LD_ADDR_VAR 0 2
57326: PUSH
57327: DOUBLE
57328: LD_INT 1
57330: DEC
57331: ST_TO_ADDR
57332: LD_EXP 100
57336: PUSH
57337: FOR_TO
57338: IFFALSE 57942
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57340: LD_EXP 135
57344: PUSH
57345: LD_VAR 0 2
57349: ARRAY
57350: NOT
57351: PUSH
57352: LD_INT 38
57354: PPUSH
57355: LD_EXP 126
57359: PUSH
57360: LD_VAR 0 2
57364: ARRAY
57365: PPUSH
57366: CALL_OW 321
57370: PUSH
57371: LD_INT 2
57373: NONEQUAL
57374: OR
57375: IFFALSE 57379
// continue ;
57377: GO 57337
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57379: LD_ADDR_VAR 0 8
57383: PUSH
57384: LD_EXP 100
57388: PUSH
57389: LD_VAR 0 2
57393: ARRAY
57394: PPUSH
57395: LD_INT 30
57397: PUSH
57398: LD_INT 34
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: PPUSH
57405: CALL_OW 72
57409: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57410: LD_ADDR_VAR 0 9
57414: PUSH
57415: LD_EXP 100
57419: PUSH
57420: LD_VAR 0 2
57424: ARRAY
57425: PPUSH
57426: LD_INT 25
57428: PUSH
57429: LD_INT 4
57431: PUSH
57432: EMPTY
57433: LIST
57434: LIST
57435: PPUSH
57436: CALL_OW 72
57440: PPUSH
57441: LD_INT 0
57443: PPUSH
57444: CALL 102559 0 2
57448: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57449: LD_VAR 0 9
57453: NOT
57454: PUSH
57455: LD_VAR 0 8
57459: NOT
57460: OR
57461: PUSH
57462: LD_EXP 100
57466: PUSH
57467: LD_VAR 0 2
57471: ARRAY
57472: PPUSH
57473: LD_INT 124
57475: PPUSH
57476: CALL 102559 0 2
57480: OR
57481: IFFALSE 57485
// continue ;
57483: GO 57337
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57485: LD_EXP 136
57489: PUSH
57490: LD_VAR 0 2
57494: ARRAY
57495: PUSH
57496: LD_EXP 135
57500: PUSH
57501: LD_VAR 0 2
57505: ARRAY
57506: LESS
57507: PUSH
57508: LD_EXP 136
57512: PUSH
57513: LD_VAR 0 2
57517: ARRAY
57518: PUSH
57519: LD_VAR 0 8
57523: LESS
57524: AND
57525: IFFALSE 57940
// begin tmp := sci [ 1 ] ;
57527: LD_ADDR_VAR 0 7
57531: PUSH
57532: LD_VAR 0 9
57536: PUSH
57537: LD_INT 1
57539: ARRAY
57540: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57541: LD_VAR 0 7
57545: PPUSH
57546: LD_INT 124
57548: PPUSH
57549: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57553: LD_ADDR_VAR 0 3
57557: PUSH
57558: DOUBLE
57559: LD_EXP 135
57563: PUSH
57564: LD_VAR 0 2
57568: ARRAY
57569: INC
57570: ST_TO_ADDR
57571: LD_EXP 135
57575: PUSH
57576: LD_VAR 0 2
57580: ARRAY
57581: PUSH
57582: FOR_DOWNTO
57583: IFFALSE 57926
// begin if IsInUnit ( tmp ) then
57585: LD_VAR 0 7
57589: PPUSH
57590: CALL_OW 310
57594: IFFALSE 57605
// ComExitBuilding ( tmp ) ;
57596: LD_VAR 0 7
57600: PPUSH
57601: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57605: LD_INT 35
57607: PPUSH
57608: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57612: LD_VAR 0 7
57616: PPUSH
57617: CALL_OW 310
57621: NOT
57622: PUSH
57623: LD_VAR 0 7
57627: PPUSH
57628: CALL_OW 314
57632: NOT
57633: AND
57634: IFFALSE 57605
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57636: LD_ADDR_VAR 0 6
57640: PUSH
57641: LD_VAR 0 7
57645: PPUSH
57646: CALL_OW 250
57650: PUSH
57651: LD_VAR 0 7
57655: PPUSH
57656: CALL_OW 251
57660: PUSH
57661: EMPTY
57662: LIST
57663: LIST
57664: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57665: LD_INT 35
57667: PPUSH
57668: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57672: LD_ADDR_VAR 0 4
57676: PUSH
57677: LD_EXP 135
57681: PUSH
57682: LD_VAR 0 2
57686: ARRAY
57687: PUSH
57688: LD_VAR 0 3
57692: ARRAY
57693: PUSH
57694: LD_INT 1
57696: ARRAY
57697: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57698: LD_ADDR_VAR 0 5
57702: PUSH
57703: LD_EXP 135
57707: PUSH
57708: LD_VAR 0 2
57712: ARRAY
57713: PUSH
57714: LD_VAR 0 3
57718: ARRAY
57719: PUSH
57720: LD_INT 2
57722: ARRAY
57723: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57724: LD_VAR 0 7
57728: PPUSH
57729: LD_INT 10
57731: PPUSH
57732: CALL 75270 0 2
57736: PUSH
57737: LD_INT 4
57739: ARRAY
57740: IFFALSE 57778
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57742: LD_VAR 0 7
57746: PPUSH
57747: LD_VAR 0 6
57751: PUSH
57752: LD_INT 1
57754: ARRAY
57755: PPUSH
57756: LD_VAR 0 6
57760: PUSH
57761: LD_INT 2
57763: ARRAY
57764: PPUSH
57765: CALL_OW 111
// wait ( 0 0$10 ) ;
57769: LD_INT 350
57771: PPUSH
57772: CALL_OW 67
// end else
57776: GO 57804
// begin ComMoveXY ( tmp , x , y ) ;
57778: LD_VAR 0 7
57782: PPUSH
57783: LD_VAR 0 4
57787: PPUSH
57788: LD_VAR 0 5
57792: PPUSH
57793: CALL_OW 111
// wait ( 0 0$3 ) ;
57797: LD_INT 105
57799: PPUSH
57800: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57804: LD_VAR 0 7
57808: PPUSH
57809: LD_VAR 0 4
57813: PPUSH
57814: LD_VAR 0 5
57818: PPUSH
57819: CALL_OW 307
57823: IFFALSE 57665
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57825: LD_VAR 0 7
57829: PPUSH
57830: LD_VAR 0 4
57834: PPUSH
57835: LD_VAR 0 5
57839: PPUSH
57840: LD_VAR 0 8
57844: PUSH
57845: LD_VAR 0 3
57849: ARRAY
57850: PPUSH
57851: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57855: LD_INT 35
57857: PPUSH
57858: CALL_OW 67
// until not HasTask ( tmp ) ;
57862: LD_VAR 0 7
57866: PPUSH
57867: CALL_OW 314
57871: NOT
57872: IFFALSE 57855
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57874: LD_ADDR_EXP 136
57878: PUSH
57879: LD_EXP 136
57883: PPUSH
57884: LD_VAR 0 2
57888: PUSH
57889: LD_EXP 136
57893: PUSH
57894: LD_VAR 0 2
57898: ARRAY
57899: PUSH
57900: LD_INT 1
57902: PLUS
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: PPUSH
57908: LD_VAR 0 8
57912: PUSH
57913: LD_VAR 0 3
57917: ARRAY
57918: PPUSH
57919: CALL 72673 0 3
57923: ST_TO_ADDR
// end ;
57924: GO 57582
57926: POP
57927: POP
// MC_Reset ( i , 124 ) ;
57928: LD_VAR 0 2
57932: PPUSH
57933: LD_INT 124
57935: PPUSH
57936: CALL 41033 0 2
// end ; end ;
57940: GO 57337
57942: POP
57943: POP
// end ;
57944: LD_VAR 0 1
57948: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57949: LD_INT 0
57951: PPUSH
57952: PPUSH
57953: PPUSH
// if not mc_bases then
57954: LD_EXP 100
57958: NOT
57959: IFFALSE 57963
// exit ;
57961: GO 58569
// for i = 1 to mc_bases do
57963: LD_ADDR_VAR 0 2
57967: PUSH
57968: DOUBLE
57969: LD_INT 1
57971: DEC
57972: ST_TO_ADDR
57973: LD_EXP 100
57977: PUSH
57978: FOR_TO
57979: IFFALSE 58567
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57981: LD_ADDR_VAR 0 3
57985: PUSH
57986: LD_EXP 100
57990: PUSH
57991: LD_VAR 0 2
57995: ARRAY
57996: PPUSH
57997: LD_INT 25
57999: PUSH
58000: LD_INT 4
58002: PUSH
58003: EMPTY
58004: LIST
58005: LIST
58006: PPUSH
58007: CALL_OW 72
58011: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58012: LD_VAR 0 3
58016: NOT
58017: PUSH
58018: LD_EXP 137
58022: PUSH
58023: LD_VAR 0 2
58027: ARRAY
58028: NOT
58029: OR
58030: PUSH
58031: LD_EXP 100
58035: PUSH
58036: LD_VAR 0 2
58040: ARRAY
58041: PPUSH
58042: LD_INT 2
58044: PUSH
58045: LD_INT 30
58047: PUSH
58048: LD_INT 0
58050: PUSH
58051: EMPTY
58052: LIST
58053: LIST
58054: PUSH
58055: LD_INT 30
58057: PUSH
58058: LD_INT 1
58060: PUSH
58061: EMPTY
58062: LIST
58063: LIST
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: LIST
58069: PPUSH
58070: CALL_OW 72
58074: NOT
58075: OR
58076: IFFALSE 58126
// begin if mc_deposits_finder [ i ] then
58078: LD_EXP 138
58082: PUSH
58083: LD_VAR 0 2
58087: ARRAY
58088: IFFALSE 58124
// begin MC_Reset ( i , 125 ) ;
58090: LD_VAR 0 2
58094: PPUSH
58095: LD_INT 125
58097: PPUSH
58098: CALL 41033 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58102: LD_ADDR_EXP 138
58106: PUSH
58107: LD_EXP 138
58111: PPUSH
58112: LD_VAR 0 2
58116: PPUSH
58117: EMPTY
58118: PPUSH
58119: CALL_OW 1
58123: ST_TO_ADDR
// end ; continue ;
58124: GO 57978
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
58126: LD_EXP 137
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: PUSH
58137: LD_INT 1
58139: ARRAY
58140: PUSH
58141: LD_INT 3
58143: ARRAY
58144: PUSH
58145: LD_INT 1
58147: EQUAL
58148: PUSH
58149: LD_INT 20
58151: PPUSH
58152: LD_EXP 126
58156: PUSH
58157: LD_VAR 0 2
58161: ARRAY
58162: PPUSH
58163: CALL_OW 321
58167: PUSH
58168: LD_INT 2
58170: NONEQUAL
58171: AND
58172: IFFALSE 58222
// begin if mc_deposits_finder [ i ] then
58174: LD_EXP 138
58178: PUSH
58179: LD_VAR 0 2
58183: ARRAY
58184: IFFALSE 58220
// begin MC_Reset ( i , 125 ) ;
58186: LD_VAR 0 2
58190: PPUSH
58191: LD_INT 125
58193: PPUSH
58194: CALL 41033 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58198: LD_ADDR_EXP 138
58202: PUSH
58203: LD_EXP 138
58207: PPUSH
58208: LD_VAR 0 2
58212: PPUSH
58213: EMPTY
58214: PPUSH
58215: CALL_OW 1
58219: ST_TO_ADDR
// end ; continue ;
58220: GO 57978
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
58222: LD_EXP 137
58226: PUSH
58227: LD_VAR 0 2
58231: ARRAY
58232: PUSH
58233: LD_INT 1
58235: ARRAY
58236: PUSH
58237: LD_INT 1
58239: ARRAY
58240: PPUSH
58241: LD_EXP 137
58245: PUSH
58246: LD_VAR 0 2
58250: ARRAY
58251: PUSH
58252: LD_INT 1
58254: ARRAY
58255: PUSH
58256: LD_INT 2
58258: ARRAY
58259: PPUSH
58260: LD_EXP 126
58264: PUSH
58265: LD_VAR 0 2
58269: ARRAY
58270: PPUSH
58271: CALL_OW 440
58275: IFFALSE 58318
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
58277: LD_ADDR_EXP 137
58281: PUSH
58282: LD_EXP 137
58286: PPUSH
58287: LD_VAR 0 2
58291: PPUSH
58292: LD_EXP 137
58296: PUSH
58297: LD_VAR 0 2
58301: ARRAY
58302: PPUSH
58303: LD_INT 1
58305: PPUSH
58306: CALL_OW 3
58310: PPUSH
58311: CALL_OW 1
58315: ST_TO_ADDR
58316: GO 58565
// begin if not mc_deposits_finder [ i ] then
58318: LD_EXP 138
58322: PUSH
58323: LD_VAR 0 2
58327: ARRAY
58328: NOT
58329: IFFALSE 58381
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58331: LD_ADDR_EXP 138
58335: PUSH
58336: LD_EXP 138
58340: PPUSH
58341: LD_VAR 0 2
58345: PPUSH
58346: LD_VAR 0 3
58350: PUSH
58351: LD_INT 1
58353: ARRAY
58354: PUSH
58355: EMPTY
58356: LIST
58357: PPUSH
58358: CALL_OW 1
58362: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58363: LD_VAR 0 3
58367: PUSH
58368: LD_INT 1
58370: ARRAY
58371: PPUSH
58372: LD_INT 125
58374: PPUSH
58375: CALL_OW 109
// end else
58379: GO 58565
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58381: LD_EXP 138
58385: PUSH
58386: LD_VAR 0 2
58390: ARRAY
58391: PUSH
58392: LD_INT 1
58394: ARRAY
58395: PPUSH
58396: CALL_OW 310
58400: IFFALSE 58423
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58402: LD_EXP 138
58406: PUSH
58407: LD_VAR 0 2
58411: ARRAY
58412: PUSH
58413: LD_INT 1
58415: ARRAY
58416: PPUSH
58417: CALL_OW 122
58421: GO 58565
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58423: LD_EXP 138
58427: PUSH
58428: LD_VAR 0 2
58432: ARRAY
58433: PUSH
58434: LD_INT 1
58436: ARRAY
58437: PPUSH
58438: CALL_OW 314
58442: NOT
58443: PUSH
58444: LD_EXP 138
58448: PUSH
58449: LD_VAR 0 2
58453: ARRAY
58454: PUSH
58455: LD_INT 1
58457: ARRAY
58458: PPUSH
58459: LD_EXP 137
58463: PUSH
58464: LD_VAR 0 2
58468: ARRAY
58469: PUSH
58470: LD_INT 1
58472: ARRAY
58473: PUSH
58474: LD_INT 1
58476: ARRAY
58477: PPUSH
58478: LD_EXP 137
58482: PUSH
58483: LD_VAR 0 2
58487: ARRAY
58488: PUSH
58489: LD_INT 1
58491: ARRAY
58492: PUSH
58493: LD_INT 2
58495: ARRAY
58496: PPUSH
58497: CALL_OW 297
58501: PUSH
58502: LD_INT 6
58504: GREATER
58505: AND
58506: IFFALSE 58565
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58508: LD_EXP 138
58512: PUSH
58513: LD_VAR 0 2
58517: ARRAY
58518: PUSH
58519: LD_INT 1
58521: ARRAY
58522: PPUSH
58523: LD_EXP 137
58527: PUSH
58528: LD_VAR 0 2
58532: ARRAY
58533: PUSH
58534: LD_INT 1
58536: ARRAY
58537: PUSH
58538: LD_INT 1
58540: ARRAY
58541: PPUSH
58542: LD_EXP 137
58546: PUSH
58547: LD_VAR 0 2
58551: ARRAY
58552: PUSH
58553: LD_INT 1
58555: ARRAY
58556: PUSH
58557: LD_INT 2
58559: ARRAY
58560: PPUSH
58561: CALL_OW 111
// end ; end ; end ;
58565: GO 57978
58567: POP
58568: POP
// end ;
58569: LD_VAR 0 1
58573: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58574: LD_INT 0
58576: PPUSH
58577: PPUSH
58578: PPUSH
58579: PPUSH
58580: PPUSH
58581: PPUSH
58582: PPUSH
58583: PPUSH
58584: PPUSH
58585: PPUSH
58586: PPUSH
// if not mc_bases then
58587: LD_EXP 100
58591: NOT
58592: IFFALSE 58596
// exit ;
58594: GO 59536
// for i = 1 to mc_bases do
58596: LD_ADDR_VAR 0 2
58600: PUSH
58601: DOUBLE
58602: LD_INT 1
58604: DEC
58605: ST_TO_ADDR
58606: LD_EXP 100
58610: PUSH
58611: FOR_TO
58612: IFFALSE 59534
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58614: LD_EXP 100
58618: PUSH
58619: LD_VAR 0 2
58623: ARRAY
58624: NOT
58625: PUSH
58626: LD_EXP 123
58630: PUSH
58631: LD_VAR 0 2
58635: ARRAY
58636: OR
58637: IFFALSE 58641
// continue ;
58639: GO 58611
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58641: LD_ADDR_VAR 0 7
58645: PUSH
58646: LD_EXP 100
58650: PUSH
58651: LD_VAR 0 2
58655: ARRAY
58656: PUSH
58657: LD_INT 1
58659: ARRAY
58660: PPUSH
58661: CALL_OW 248
58665: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58666: LD_VAR 0 7
58670: PUSH
58671: LD_INT 3
58673: EQUAL
58674: PUSH
58675: LD_EXP 119
58679: PUSH
58680: LD_VAR 0 2
58684: ARRAY
58685: PUSH
58686: LD_EXP 122
58690: PUSH
58691: LD_VAR 0 2
58695: ARRAY
58696: UNION
58697: PPUSH
58698: LD_INT 33
58700: PUSH
58701: LD_INT 2
58703: PUSH
58704: EMPTY
58705: LIST
58706: LIST
58707: PPUSH
58708: CALL_OW 72
58712: NOT
58713: OR
58714: IFFALSE 58718
// continue ;
58716: GO 58611
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58718: LD_ADDR_VAR 0 9
58722: PUSH
58723: LD_EXP 100
58727: PUSH
58728: LD_VAR 0 2
58732: ARRAY
58733: PPUSH
58734: LD_INT 30
58736: PUSH
58737: LD_INT 36
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: PPUSH
58744: CALL_OW 72
58748: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58749: LD_ADDR_VAR 0 10
58753: PUSH
58754: LD_EXP 119
58758: PUSH
58759: LD_VAR 0 2
58763: ARRAY
58764: PPUSH
58765: LD_INT 34
58767: PUSH
58768: LD_INT 31
58770: PUSH
58771: EMPTY
58772: LIST
58773: LIST
58774: PPUSH
58775: CALL_OW 72
58779: ST_TO_ADDR
// if not cts and not mcts then
58780: LD_VAR 0 9
58784: NOT
58785: PUSH
58786: LD_VAR 0 10
58790: NOT
58791: AND
58792: IFFALSE 58796
// continue ;
58794: GO 58611
// x := cts ;
58796: LD_ADDR_VAR 0 11
58800: PUSH
58801: LD_VAR 0 9
58805: ST_TO_ADDR
// if not x then
58806: LD_VAR 0 11
58810: NOT
58811: IFFALSE 58823
// x := mcts ;
58813: LD_ADDR_VAR 0 11
58817: PUSH
58818: LD_VAR 0 10
58822: ST_TO_ADDR
// if not x then
58823: LD_VAR 0 11
58827: NOT
58828: IFFALSE 58832
// continue ;
58830: GO 58611
// if mc_remote_driver [ i ] then
58832: LD_EXP 140
58836: PUSH
58837: LD_VAR 0 2
58841: ARRAY
58842: IFFALSE 59229
// for j in mc_remote_driver [ i ] do
58844: LD_ADDR_VAR 0 3
58848: PUSH
58849: LD_EXP 140
58853: PUSH
58854: LD_VAR 0 2
58858: ARRAY
58859: PUSH
58860: FOR_IN
58861: IFFALSE 59227
// begin if GetClass ( j ) <> 3 then
58863: LD_VAR 0 3
58867: PPUSH
58868: CALL_OW 257
58872: PUSH
58873: LD_INT 3
58875: NONEQUAL
58876: IFFALSE 58929
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58878: LD_ADDR_EXP 140
58882: PUSH
58883: LD_EXP 140
58887: PPUSH
58888: LD_VAR 0 2
58892: PPUSH
58893: LD_EXP 140
58897: PUSH
58898: LD_VAR 0 2
58902: ARRAY
58903: PUSH
58904: LD_VAR 0 3
58908: DIFF
58909: PPUSH
58910: CALL_OW 1
58914: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58915: LD_VAR 0 3
58919: PPUSH
58920: LD_INT 0
58922: PPUSH
58923: CALL_OW 109
// continue ;
58927: GO 58860
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58929: LD_EXP 119
58933: PUSH
58934: LD_VAR 0 2
58938: ARRAY
58939: PPUSH
58940: LD_INT 34
58942: PUSH
58943: LD_INT 31
58945: PUSH
58946: EMPTY
58947: LIST
58948: LIST
58949: PUSH
58950: LD_INT 58
58952: PUSH
58953: EMPTY
58954: LIST
58955: PUSH
58956: EMPTY
58957: LIST
58958: LIST
58959: PPUSH
58960: CALL_OW 72
58964: PUSH
58965: LD_VAR 0 3
58969: PPUSH
58970: CALL 102594 0 1
58974: NOT
58975: AND
58976: IFFALSE 59047
// begin if IsInUnit ( j ) then
58978: LD_VAR 0 3
58982: PPUSH
58983: CALL_OW 310
58987: IFFALSE 58998
// ComExitBuilding ( j ) ;
58989: LD_VAR 0 3
58993: PPUSH
58994: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
58998: LD_VAR 0 3
59002: PPUSH
59003: LD_EXP 119
59007: PUSH
59008: LD_VAR 0 2
59012: ARRAY
59013: PPUSH
59014: LD_INT 34
59016: PUSH
59017: LD_INT 31
59019: PUSH
59020: EMPTY
59021: LIST
59022: LIST
59023: PUSH
59024: LD_INT 58
59026: PUSH
59027: EMPTY
59028: LIST
59029: PUSH
59030: EMPTY
59031: LIST
59032: LIST
59033: PPUSH
59034: CALL_OW 72
59038: PUSH
59039: LD_INT 1
59041: ARRAY
59042: PPUSH
59043: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
59047: LD_VAR 0 3
59051: PPUSH
59052: CALL_OW 310
59056: NOT
59057: PUSH
59058: LD_VAR 0 3
59062: PPUSH
59063: CALL_OW 310
59067: PPUSH
59068: CALL_OW 266
59072: PUSH
59073: LD_INT 36
59075: NONEQUAL
59076: PUSH
59077: LD_VAR 0 3
59081: PPUSH
59082: CALL 102594 0 1
59086: NOT
59087: AND
59088: OR
59089: IFFALSE 59225
// begin if IsInUnit ( j ) then
59091: LD_VAR 0 3
59095: PPUSH
59096: CALL_OW 310
59100: IFFALSE 59111
// ComExitBuilding ( j ) ;
59102: LD_VAR 0 3
59106: PPUSH
59107: CALL_OW 122
// ct := 0 ;
59111: LD_ADDR_VAR 0 8
59115: PUSH
59116: LD_INT 0
59118: ST_TO_ADDR
// for k in x do
59119: LD_ADDR_VAR 0 4
59123: PUSH
59124: LD_VAR 0 11
59128: PUSH
59129: FOR_IN
59130: IFFALSE 59203
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
59132: LD_VAR 0 4
59136: PPUSH
59137: CALL_OW 264
59141: PUSH
59142: LD_INT 31
59144: EQUAL
59145: PUSH
59146: LD_VAR 0 4
59150: PPUSH
59151: CALL_OW 311
59155: NOT
59156: AND
59157: PUSH
59158: LD_VAR 0 4
59162: PPUSH
59163: CALL_OW 266
59167: PUSH
59168: LD_INT 36
59170: EQUAL
59171: PUSH
59172: LD_VAR 0 4
59176: PPUSH
59177: CALL_OW 313
59181: PUSH
59182: LD_INT 3
59184: LESS
59185: AND
59186: OR
59187: IFFALSE 59201
// begin ct := k ;
59189: LD_ADDR_VAR 0 8
59193: PUSH
59194: LD_VAR 0 4
59198: ST_TO_ADDR
// break ;
59199: GO 59203
// end ;
59201: GO 59129
59203: POP
59204: POP
// if ct then
59205: LD_VAR 0 8
59209: IFFALSE 59225
// ComEnterUnit ( j , ct ) ;
59211: LD_VAR 0 3
59215: PPUSH
59216: LD_VAR 0 8
59220: PPUSH
59221: CALL_OW 120
// end ; end ;
59225: GO 58860
59227: POP
59228: POP
// places := 0 ;
59229: LD_ADDR_VAR 0 5
59233: PUSH
59234: LD_INT 0
59236: ST_TO_ADDR
// for j = 1 to x do
59237: LD_ADDR_VAR 0 3
59241: PUSH
59242: DOUBLE
59243: LD_INT 1
59245: DEC
59246: ST_TO_ADDR
59247: LD_VAR 0 11
59251: PUSH
59252: FOR_TO
59253: IFFALSE 59329
// if GetWeapon ( x [ j ] ) = ar_control_tower then
59255: LD_VAR 0 11
59259: PUSH
59260: LD_VAR 0 3
59264: ARRAY
59265: PPUSH
59266: CALL_OW 264
59270: PUSH
59271: LD_INT 31
59273: EQUAL
59274: IFFALSE 59292
// places := places + 1 else
59276: LD_ADDR_VAR 0 5
59280: PUSH
59281: LD_VAR 0 5
59285: PUSH
59286: LD_INT 1
59288: PLUS
59289: ST_TO_ADDR
59290: GO 59327
// if GetBType ( x [ j ] ) = b_control_tower then
59292: LD_VAR 0 11
59296: PUSH
59297: LD_VAR 0 3
59301: ARRAY
59302: PPUSH
59303: CALL_OW 266
59307: PUSH
59308: LD_INT 36
59310: EQUAL
59311: IFFALSE 59327
// places := places + 3 ;
59313: LD_ADDR_VAR 0 5
59317: PUSH
59318: LD_VAR 0 5
59322: PUSH
59323: LD_INT 3
59325: PLUS
59326: ST_TO_ADDR
59327: GO 59252
59329: POP
59330: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59331: LD_VAR 0 5
59335: PUSH
59336: LD_INT 0
59338: EQUAL
59339: PUSH
59340: LD_VAR 0 5
59344: PUSH
59345: LD_EXP 140
59349: PUSH
59350: LD_VAR 0 2
59354: ARRAY
59355: LESSEQUAL
59356: OR
59357: IFFALSE 59361
// continue ;
59359: GO 58611
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59361: LD_ADDR_VAR 0 6
59365: PUSH
59366: LD_EXP 100
59370: PUSH
59371: LD_VAR 0 2
59375: ARRAY
59376: PPUSH
59377: LD_INT 25
59379: PUSH
59380: LD_INT 3
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PPUSH
59387: CALL_OW 72
59391: PUSH
59392: LD_EXP 140
59396: PUSH
59397: LD_VAR 0 2
59401: ARRAY
59402: DIFF
59403: PPUSH
59404: LD_INT 3
59406: PPUSH
59407: CALL 103494 0 2
59411: ST_TO_ADDR
// for j in tmp do
59412: LD_ADDR_VAR 0 3
59416: PUSH
59417: LD_VAR 0 6
59421: PUSH
59422: FOR_IN
59423: IFFALSE 59458
// if GetTag ( j ) > 0 then
59425: LD_VAR 0 3
59429: PPUSH
59430: CALL_OW 110
59434: PUSH
59435: LD_INT 0
59437: GREATER
59438: IFFALSE 59456
// tmp := tmp diff j ;
59440: LD_ADDR_VAR 0 6
59444: PUSH
59445: LD_VAR 0 6
59449: PUSH
59450: LD_VAR 0 3
59454: DIFF
59455: ST_TO_ADDR
59456: GO 59422
59458: POP
59459: POP
// if not tmp then
59460: LD_VAR 0 6
59464: NOT
59465: IFFALSE 59469
// continue ;
59467: GO 58611
// if places then
59469: LD_VAR 0 5
59473: IFFALSE 59532
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59475: LD_ADDR_EXP 140
59479: PUSH
59480: LD_EXP 140
59484: PPUSH
59485: LD_VAR 0 2
59489: PPUSH
59490: LD_EXP 140
59494: PUSH
59495: LD_VAR 0 2
59499: ARRAY
59500: PUSH
59501: LD_VAR 0 6
59505: PUSH
59506: LD_INT 1
59508: ARRAY
59509: UNION
59510: PPUSH
59511: CALL_OW 1
59515: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59516: LD_VAR 0 6
59520: PUSH
59521: LD_INT 1
59523: ARRAY
59524: PPUSH
59525: LD_INT 126
59527: PPUSH
59528: CALL_OW 109
// end ; end ;
59532: GO 58611
59534: POP
59535: POP
// end ;
59536: LD_VAR 0 1
59540: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59541: LD_INT 0
59543: PPUSH
59544: PPUSH
59545: PPUSH
59546: PPUSH
59547: PPUSH
59548: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59549: LD_VAR 0 1
59553: NOT
59554: PUSH
59555: LD_VAR 0 2
59559: NOT
59560: OR
59561: PUSH
59562: LD_VAR 0 3
59566: NOT
59567: OR
59568: PUSH
59569: LD_VAR 0 4
59573: PUSH
59574: LD_INT 1
59576: PUSH
59577: LD_INT 2
59579: PUSH
59580: LD_INT 3
59582: PUSH
59583: LD_INT 4
59585: PUSH
59586: LD_INT 5
59588: PUSH
59589: LD_INT 8
59591: PUSH
59592: LD_INT 9
59594: PUSH
59595: LD_INT 15
59597: PUSH
59598: LD_INT 16
59600: PUSH
59601: EMPTY
59602: LIST
59603: LIST
59604: LIST
59605: LIST
59606: LIST
59607: LIST
59608: LIST
59609: LIST
59610: LIST
59611: IN
59612: NOT
59613: OR
59614: IFFALSE 59618
// exit ;
59616: GO 60518
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59618: LD_ADDR_VAR 0 2
59622: PUSH
59623: LD_VAR 0 2
59627: PPUSH
59628: LD_INT 21
59630: PUSH
59631: LD_INT 3
59633: PUSH
59634: EMPTY
59635: LIST
59636: LIST
59637: PUSH
59638: LD_INT 24
59640: PUSH
59641: LD_INT 250
59643: PUSH
59644: EMPTY
59645: LIST
59646: LIST
59647: PUSH
59648: EMPTY
59649: LIST
59650: LIST
59651: PPUSH
59652: CALL_OW 72
59656: ST_TO_ADDR
// case class of 1 , 15 :
59657: LD_VAR 0 4
59661: PUSH
59662: LD_INT 1
59664: DOUBLE
59665: EQUAL
59666: IFTRUE 59676
59668: LD_INT 15
59670: DOUBLE
59671: EQUAL
59672: IFTRUE 59676
59674: GO 59761
59676: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59677: LD_ADDR_VAR 0 8
59681: PUSH
59682: LD_VAR 0 2
59686: PPUSH
59687: LD_INT 2
59689: PUSH
59690: LD_INT 30
59692: PUSH
59693: LD_INT 32
59695: PUSH
59696: EMPTY
59697: LIST
59698: LIST
59699: PUSH
59700: LD_INT 30
59702: PUSH
59703: LD_INT 31
59705: PUSH
59706: EMPTY
59707: LIST
59708: LIST
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: LIST
59714: PPUSH
59715: CALL_OW 72
59719: PUSH
59720: LD_VAR 0 2
59724: PPUSH
59725: LD_INT 2
59727: PUSH
59728: LD_INT 30
59730: PUSH
59731: LD_INT 4
59733: PUSH
59734: EMPTY
59735: LIST
59736: LIST
59737: PUSH
59738: LD_INT 30
59740: PUSH
59741: LD_INT 5
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: PUSH
59748: EMPTY
59749: LIST
59750: LIST
59751: LIST
59752: PPUSH
59753: CALL_OW 72
59757: ADD
59758: ST_TO_ADDR
59759: GO 60007
59761: LD_INT 2
59763: DOUBLE
59764: EQUAL
59765: IFTRUE 59775
59767: LD_INT 16
59769: DOUBLE
59770: EQUAL
59771: IFTRUE 59775
59773: GO 59821
59775: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59776: LD_ADDR_VAR 0 8
59780: PUSH
59781: LD_VAR 0 2
59785: PPUSH
59786: LD_INT 2
59788: PUSH
59789: LD_INT 30
59791: PUSH
59792: LD_INT 0
59794: PUSH
59795: EMPTY
59796: LIST
59797: LIST
59798: PUSH
59799: LD_INT 30
59801: PUSH
59802: LD_INT 1
59804: PUSH
59805: EMPTY
59806: LIST
59807: LIST
59808: PUSH
59809: EMPTY
59810: LIST
59811: LIST
59812: LIST
59813: PPUSH
59814: CALL_OW 72
59818: ST_TO_ADDR
59819: GO 60007
59821: LD_INT 3
59823: DOUBLE
59824: EQUAL
59825: IFTRUE 59829
59827: GO 59875
59829: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59830: LD_ADDR_VAR 0 8
59834: PUSH
59835: LD_VAR 0 2
59839: PPUSH
59840: LD_INT 2
59842: PUSH
59843: LD_INT 30
59845: PUSH
59846: LD_INT 2
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: PUSH
59853: LD_INT 30
59855: PUSH
59856: LD_INT 3
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: LIST
59867: PPUSH
59868: CALL_OW 72
59872: ST_TO_ADDR
59873: GO 60007
59875: LD_INT 4
59877: DOUBLE
59878: EQUAL
59879: IFTRUE 59883
59881: GO 59940
59883: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59884: LD_ADDR_VAR 0 8
59888: PUSH
59889: LD_VAR 0 2
59893: PPUSH
59894: LD_INT 2
59896: PUSH
59897: LD_INT 30
59899: PUSH
59900: LD_INT 6
59902: PUSH
59903: EMPTY
59904: LIST
59905: LIST
59906: PUSH
59907: LD_INT 30
59909: PUSH
59910: LD_INT 7
59912: PUSH
59913: EMPTY
59914: LIST
59915: LIST
59916: PUSH
59917: LD_INT 30
59919: PUSH
59920: LD_INT 8
59922: PUSH
59923: EMPTY
59924: LIST
59925: LIST
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: LIST
59931: LIST
59932: PPUSH
59933: CALL_OW 72
59937: ST_TO_ADDR
59938: GO 60007
59940: LD_INT 5
59942: DOUBLE
59943: EQUAL
59944: IFTRUE 59960
59946: LD_INT 8
59948: DOUBLE
59949: EQUAL
59950: IFTRUE 59960
59952: LD_INT 9
59954: DOUBLE
59955: EQUAL
59956: IFTRUE 59960
59958: GO 60006
59960: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59961: LD_ADDR_VAR 0 8
59965: PUSH
59966: LD_VAR 0 2
59970: PPUSH
59971: LD_INT 2
59973: PUSH
59974: LD_INT 30
59976: PUSH
59977: LD_INT 4
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PUSH
59984: LD_INT 30
59986: PUSH
59987: LD_INT 5
59989: PUSH
59990: EMPTY
59991: LIST
59992: LIST
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: LIST
59998: PPUSH
59999: CALL_OW 72
60003: ST_TO_ADDR
60004: GO 60007
60006: POP
// if not tmp then
60007: LD_VAR 0 8
60011: NOT
60012: IFFALSE 60016
// exit ;
60014: GO 60518
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
60016: LD_VAR 0 4
60020: PUSH
60021: LD_INT 1
60023: PUSH
60024: LD_INT 15
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: IN
60031: PUSH
60032: LD_EXP 109
60036: PUSH
60037: LD_VAR 0 1
60041: ARRAY
60042: AND
60043: IFFALSE 60199
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
60045: LD_ADDR_VAR 0 9
60049: PUSH
60050: LD_EXP 109
60054: PUSH
60055: LD_VAR 0 1
60059: ARRAY
60060: PUSH
60061: LD_INT 1
60063: ARRAY
60064: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
60065: LD_VAR 0 9
60069: PUSH
60070: LD_EXP 110
60074: PUSH
60075: LD_VAR 0 1
60079: ARRAY
60080: IN
60081: NOT
60082: IFFALSE 60197
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
60084: LD_ADDR_EXP 110
60088: PUSH
60089: LD_EXP 110
60093: PPUSH
60094: LD_VAR 0 1
60098: PUSH
60099: LD_EXP 110
60103: PUSH
60104: LD_VAR 0 1
60108: ARRAY
60109: PUSH
60110: LD_INT 1
60112: PLUS
60113: PUSH
60114: EMPTY
60115: LIST
60116: LIST
60117: PPUSH
60118: LD_VAR 0 9
60122: PPUSH
60123: CALL 72673 0 3
60127: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
60128: LD_ADDR_EXP 109
60132: PUSH
60133: LD_EXP 109
60137: PPUSH
60138: LD_VAR 0 1
60142: PPUSH
60143: LD_EXP 109
60147: PUSH
60148: LD_VAR 0 1
60152: ARRAY
60153: PUSH
60154: LD_VAR 0 9
60158: DIFF
60159: PPUSH
60160: CALL_OW 1
60164: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
60165: LD_VAR 0 3
60169: PPUSH
60170: LD_EXP 110
60174: PUSH
60175: LD_VAR 0 1
60179: ARRAY
60180: PUSH
60181: LD_EXP 110
60185: PUSH
60186: LD_VAR 0 1
60190: ARRAY
60191: ARRAY
60192: PPUSH
60193: CALL_OW 120
// end ; exit ;
60197: GO 60518
// end ; if tmp > 1 then
60199: LD_VAR 0 8
60203: PUSH
60204: LD_INT 1
60206: GREATER
60207: IFFALSE 60311
// for i = 2 to tmp do
60209: LD_ADDR_VAR 0 6
60213: PUSH
60214: DOUBLE
60215: LD_INT 2
60217: DEC
60218: ST_TO_ADDR
60219: LD_VAR 0 8
60223: PUSH
60224: FOR_TO
60225: IFFALSE 60309
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
60227: LD_VAR 0 8
60231: PUSH
60232: LD_VAR 0 6
60236: ARRAY
60237: PPUSH
60238: CALL_OW 461
60242: PUSH
60243: LD_INT 6
60245: EQUAL
60246: IFFALSE 60307
// begin x := tmp [ i ] ;
60248: LD_ADDR_VAR 0 9
60252: PUSH
60253: LD_VAR 0 8
60257: PUSH
60258: LD_VAR 0 6
60262: ARRAY
60263: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
60264: LD_ADDR_VAR 0 8
60268: PUSH
60269: LD_VAR 0 8
60273: PPUSH
60274: LD_VAR 0 6
60278: PPUSH
60279: CALL_OW 3
60283: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
60284: LD_ADDR_VAR 0 8
60288: PUSH
60289: LD_VAR 0 8
60293: PPUSH
60294: LD_INT 1
60296: PPUSH
60297: LD_VAR 0 9
60301: PPUSH
60302: CALL_OW 2
60306: ST_TO_ADDR
// end ;
60307: GO 60224
60309: POP
60310: POP
// for i in tmp do
60311: LD_ADDR_VAR 0 6
60315: PUSH
60316: LD_VAR 0 8
60320: PUSH
60321: FOR_IN
60322: IFFALSE 60391
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
60324: LD_VAR 0 6
60328: PPUSH
60329: CALL_OW 313
60333: PUSH
60334: LD_INT 6
60336: LESS
60337: PUSH
60338: LD_VAR 0 6
60342: PPUSH
60343: CALL_OW 266
60347: PUSH
60348: LD_INT 31
60350: PUSH
60351: LD_INT 32
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: IN
60358: NOT
60359: AND
60360: PUSH
60361: LD_VAR 0 6
60365: PPUSH
60366: CALL_OW 313
60370: PUSH
60371: LD_INT 0
60373: EQUAL
60374: OR
60375: IFFALSE 60389
// begin j := i ;
60377: LD_ADDR_VAR 0 7
60381: PUSH
60382: LD_VAR 0 6
60386: ST_TO_ADDR
// break ;
60387: GO 60391
// end ; end ;
60389: GO 60321
60391: POP
60392: POP
// if j then
60393: LD_VAR 0 7
60397: IFFALSE 60415
// ComEnterUnit ( unit , j ) else
60399: LD_VAR 0 3
60403: PPUSH
60404: LD_VAR 0 7
60408: PPUSH
60409: CALL_OW 120
60413: GO 60518
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60415: LD_ADDR_VAR 0 10
60419: PUSH
60420: LD_VAR 0 2
60424: PPUSH
60425: LD_INT 2
60427: PUSH
60428: LD_INT 30
60430: PUSH
60431: LD_INT 0
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: PUSH
60438: LD_INT 30
60440: PUSH
60441: LD_INT 1
60443: PUSH
60444: EMPTY
60445: LIST
60446: LIST
60447: PUSH
60448: EMPTY
60449: LIST
60450: LIST
60451: LIST
60452: PPUSH
60453: CALL_OW 72
60457: ST_TO_ADDR
// if depot then
60458: LD_VAR 0 10
60462: IFFALSE 60518
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60464: LD_ADDR_VAR 0 10
60468: PUSH
60469: LD_VAR 0 10
60473: PPUSH
60474: LD_VAR 0 3
60478: PPUSH
60479: CALL_OW 74
60483: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60484: LD_VAR 0 3
60488: PPUSH
60489: LD_VAR 0 10
60493: PPUSH
60494: CALL_OW 296
60498: PUSH
60499: LD_INT 10
60501: GREATER
60502: IFFALSE 60518
// ComStandNearbyBuilding ( unit , depot ) ;
60504: LD_VAR 0 3
60508: PPUSH
60509: LD_VAR 0 10
60513: PPUSH
60514: CALL 69100 0 2
// end ; end ; end ;
60518: LD_VAR 0 5
60522: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60523: LD_INT 0
60525: PPUSH
60526: PPUSH
60527: PPUSH
60528: PPUSH
// if not mc_bases then
60529: LD_EXP 100
60533: NOT
60534: IFFALSE 60538
// exit ;
60536: GO 60777
// for i = 1 to mc_bases do
60538: LD_ADDR_VAR 0 2
60542: PUSH
60543: DOUBLE
60544: LD_INT 1
60546: DEC
60547: ST_TO_ADDR
60548: LD_EXP 100
60552: PUSH
60553: FOR_TO
60554: IFFALSE 60775
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60556: LD_ADDR_VAR 0 4
60560: PUSH
60561: LD_EXP 100
60565: PUSH
60566: LD_VAR 0 2
60570: ARRAY
60571: PPUSH
60572: LD_INT 21
60574: PUSH
60575: LD_INT 1
60577: PUSH
60578: EMPTY
60579: LIST
60580: LIST
60581: PPUSH
60582: CALL_OW 72
60586: PUSH
60587: LD_EXP 129
60591: PUSH
60592: LD_VAR 0 2
60596: ARRAY
60597: UNION
60598: ST_TO_ADDR
// if not tmp then
60599: LD_VAR 0 4
60603: NOT
60604: IFFALSE 60608
// continue ;
60606: GO 60553
// for j in tmp do
60608: LD_ADDR_VAR 0 3
60612: PUSH
60613: LD_VAR 0 4
60617: PUSH
60618: FOR_IN
60619: IFFALSE 60771
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60621: LD_VAR 0 3
60625: PPUSH
60626: CALL_OW 110
60630: NOT
60631: PUSH
60632: LD_VAR 0 3
60636: PPUSH
60637: CALL_OW 314
60641: NOT
60642: AND
60643: PUSH
60644: LD_VAR 0 3
60648: PPUSH
60649: CALL_OW 311
60653: NOT
60654: AND
60655: PUSH
60656: LD_VAR 0 3
60660: PPUSH
60661: CALL_OW 310
60665: NOT
60666: AND
60667: PUSH
60668: LD_VAR 0 3
60672: PUSH
60673: LD_EXP 103
60677: PUSH
60678: LD_VAR 0 2
60682: ARRAY
60683: PUSH
60684: LD_INT 1
60686: ARRAY
60687: IN
60688: NOT
60689: AND
60690: PUSH
60691: LD_VAR 0 3
60695: PUSH
60696: LD_EXP 103
60700: PUSH
60701: LD_VAR 0 2
60705: ARRAY
60706: PUSH
60707: LD_INT 2
60709: ARRAY
60710: IN
60711: NOT
60712: AND
60713: PUSH
60714: LD_VAR 0 3
60718: PUSH
60719: LD_EXP 112
60723: PUSH
60724: LD_VAR 0 2
60728: ARRAY
60729: IN
60730: NOT
60731: AND
60732: IFFALSE 60769
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60734: LD_VAR 0 2
60738: PPUSH
60739: LD_EXP 100
60743: PUSH
60744: LD_VAR 0 2
60748: ARRAY
60749: PPUSH
60750: LD_VAR 0 3
60754: PPUSH
60755: LD_VAR 0 3
60759: PPUSH
60760: CALL_OW 257
60764: PPUSH
60765: CALL 59541 0 4
// end ;
60769: GO 60618
60771: POP
60772: POP
// end ;
60773: GO 60553
60775: POP
60776: POP
// end ;
60777: LD_VAR 0 1
60781: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60782: LD_INT 0
60784: PPUSH
60785: PPUSH
60786: PPUSH
60787: PPUSH
60788: PPUSH
60789: PPUSH
// if not mc_bases [ base ] then
60790: LD_EXP 100
60794: PUSH
60795: LD_VAR 0 1
60799: ARRAY
60800: NOT
60801: IFFALSE 60805
// exit ;
60803: GO 60987
// tmp := [ ] ;
60805: LD_ADDR_VAR 0 6
60809: PUSH
60810: EMPTY
60811: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60812: LD_ADDR_VAR 0 7
60816: PUSH
60817: LD_VAR 0 3
60821: PPUSH
60822: LD_INT 0
60824: PPUSH
60825: CALL_OW 517
60829: ST_TO_ADDR
// if not list then
60830: LD_VAR 0 7
60834: NOT
60835: IFFALSE 60839
// exit ;
60837: GO 60987
// for i = 1 to amount do
60839: LD_ADDR_VAR 0 5
60843: PUSH
60844: DOUBLE
60845: LD_INT 1
60847: DEC
60848: ST_TO_ADDR
60849: LD_VAR 0 2
60853: PUSH
60854: FOR_TO
60855: IFFALSE 60935
// begin x := rand ( 1 , list [ 1 ] ) ;
60857: LD_ADDR_VAR 0 8
60861: PUSH
60862: LD_INT 1
60864: PPUSH
60865: LD_VAR 0 7
60869: PUSH
60870: LD_INT 1
60872: ARRAY
60873: PPUSH
60874: CALL_OW 12
60878: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60879: LD_ADDR_VAR 0 6
60883: PUSH
60884: LD_VAR 0 6
60888: PPUSH
60889: LD_VAR 0 5
60893: PPUSH
60894: LD_VAR 0 7
60898: PUSH
60899: LD_INT 1
60901: ARRAY
60902: PUSH
60903: LD_VAR 0 8
60907: ARRAY
60908: PUSH
60909: LD_VAR 0 7
60913: PUSH
60914: LD_INT 2
60916: ARRAY
60917: PUSH
60918: LD_VAR 0 8
60922: ARRAY
60923: PUSH
60924: EMPTY
60925: LIST
60926: LIST
60927: PPUSH
60928: CALL_OW 1
60932: ST_TO_ADDR
// end ;
60933: GO 60854
60935: POP
60936: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60937: LD_ADDR_EXP 113
60941: PUSH
60942: LD_EXP 113
60946: PPUSH
60947: LD_VAR 0 1
60951: PPUSH
60952: LD_VAR 0 6
60956: PPUSH
60957: CALL_OW 1
60961: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60962: LD_ADDR_EXP 115
60966: PUSH
60967: LD_EXP 115
60971: PPUSH
60972: LD_VAR 0 1
60976: PPUSH
60977: LD_VAR 0 3
60981: PPUSH
60982: CALL_OW 1
60986: ST_TO_ADDR
// end ;
60987: LD_VAR 0 4
60991: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
60992: LD_INT 0
60994: PPUSH
// if not mc_bases [ base ] then
60995: LD_EXP 100
60999: PUSH
61000: LD_VAR 0 1
61004: ARRAY
61005: NOT
61006: IFFALSE 61010
// exit ;
61008: GO 61035
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
61010: LD_ADDR_EXP 105
61014: PUSH
61015: LD_EXP 105
61019: PPUSH
61020: LD_VAR 0 1
61024: PPUSH
61025: LD_VAR 0 2
61029: PPUSH
61030: CALL_OW 1
61034: ST_TO_ADDR
// end ;
61035: LD_VAR 0 3
61039: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
61040: LD_INT 0
61042: PPUSH
// if not mc_bases [ base ] then
61043: LD_EXP 100
61047: PUSH
61048: LD_VAR 0 1
61052: ARRAY
61053: NOT
61054: IFFALSE 61058
// exit ;
61056: GO 61095
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
61058: LD_ADDR_EXP 105
61062: PUSH
61063: LD_EXP 105
61067: PPUSH
61068: LD_VAR 0 1
61072: PPUSH
61073: LD_EXP 105
61077: PUSH
61078: LD_VAR 0 1
61082: ARRAY
61083: PUSH
61084: LD_VAR 0 2
61088: UNION
61089: PPUSH
61090: CALL_OW 1
61094: ST_TO_ADDR
// end ;
61095: LD_VAR 0 3
61099: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
61100: LD_INT 0
61102: PPUSH
// if not mc_bases [ base ] then
61103: LD_EXP 100
61107: PUSH
61108: LD_VAR 0 1
61112: ARRAY
61113: NOT
61114: IFFALSE 61118
// exit ;
61116: GO 61143
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
61118: LD_ADDR_EXP 121
61122: PUSH
61123: LD_EXP 121
61127: PPUSH
61128: LD_VAR 0 1
61132: PPUSH
61133: LD_VAR 0 2
61137: PPUSH
61138: CALL_OW 1
61142: ST_TO_ADDR
// end ;
61143: LD_VAR 0 3
61147: RET
// export function MC_InsertProduceList ( base , components ) ; begin
61148: LD_INT 0
61150: PPUSH
// if not mc_bases [ base ] then
61151: LD_EXP 100
61155: PUSH
61156: LD_VAR 0 1
61160: ARRAY
61161: NOT
61162: IFFALSE 61166
// exit ;
61164: GO 61203
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
61166: LD_ADDR_EXP 121
61170: PUSH
61171: LD_EXP 121
61175: PPUSH
61176: LD_VAR 0 1
61180: PPUSH
61181: LD_EXP 121
61185: PUSH
61186: LD_VAR 0 1
61190: ARRAY
61191: PUSH
61192: LD_VAR 0 2
61196: ADD
61197: PPUSH
61198: CALL_OW 1
61202: ST_TO_ADDR
// end ;
61203: LD_VAR 0 3
61207: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
61208: LD_INT 0
61210: PPUSH
// if not mc_bases [ base ] then
61211: LD_EXP 100
61215: PUSH
61216: LD_VAR 0 1
61220: ARRAY
61221: NOT
61222: IFFALSE 61226
// exit ;
61224: GO 61280
// mc_defender := Replace ( mc_defender , base , deflist ) ;
61226: LD_ADDR_EXP 122
61230: PUSH
61231: LD_EXP 122
61235: PPUSH
61236: LD_VAR 0 1
61240: PPUSH
61241: LD_VAR 0 2
61245: PPUSH
61246: CALL_OW 1
61250: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
61251: LD_ADDR_EXP 111
61255: PUSH
61256: LD_EXP 111
61260: PPUSH
61261: LD_VAR 0 1
61265: PPUSH
61266: LD_VAR 0 2
61270: PUSH
61271: LD_INT 0
61273: PLUS
61274: PPUSH
61275: CALL_OW 1
61279: ST_TO_ADDR
// end ;
61280: LD_VAR 0 3
61284: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
61285: LD_INT 0
61287: PPUSH
// if not mc_bases [ base ] then
61288: LD_EXP 100
61292: PUSH
61293: LD_VAR 0 1
61297: ARRAY
61298: NOT
61299: IFFALSE 61303
// exit ;
61301: GO 61328
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61303: LD_ADDR_EXP 111
61307: PUSH
61308: LD_EXP 111
61312: PPUSH
61313: LD_VAR 0 1
61317: PPUSH
61318: LD_VAR 0 2
61322: PPUSH
61323: CALL_OW 1
61327: ST_TO_ADDR
// end ;
61328: LD_VAR 0 3
61332: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61333: LD_INT 0
61335: PPUSH
61336: PPUSH
61337: PPUSH
61338: PPUSH
// if not mc_bases [ base ] then
61339: LD_EXP 100
61343: PUSH
61344: LD_VAR 0 1
61348: ARRAY
61349: NOT
61350: IFFALSE 61354
// exit ;
61352: GO 61419
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61354: LD_ADDR_EXP 120
61358: PUSH
61359: LD_EXP 120
61363: PPUSH
61364: LD_VAR 0 1
61368: PUSH
61369: LD_EXP 120
61373: PUSH
61374: LD_VAR 0 1
61378: ARRAY
61379: PUSH
61380: LD_INT 1
61382: PLUS
61383: PUSH
61384: EMPTY
61385: LIST
61386: LIST
61387: PPUSH
61388: LD_VAR 0 1
61392: PUSH
61393: LD_VAR 0 2
61397: PUSH
61398: LD_VAR 0 3
61402: PUSH
61403: LD_VAR 0 4
61407: PUSH
61408: EMPTY
61409: LIST
61410: LIST
61411: LIST
61412: LIST
61413: PPUSH
61414: CALL 72673 0 3
61418: ST_TO_ADDR
// end ;
61419: LD_VAR 0 5
61423: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61424: LD_INT 0
61426: PPUSH
// if not mc_bases [ base ] then
61427: LD_EXP 100
61431: PUSH
61432: LD_VAR 0 1
61436: ARRAY
61437: NOT
61438: IFFALSE 61442
// exit ;
61440: GO 61467
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61442: LD_ADDR_EXP 137
61446: PUSH
61447: LD_EXP 137
61451: PPUSH
61452: LD_VAR 0 1
61456: PPUSH
61457: LD_VAR 0 2
61461: PPUSH
61462: CALL_OW 1
61466: ST_TO_ADDR
// end ;
61467: LD_VAR 0 3
61471: RET
// export function MC_GetMinesField ( base ) ; begin
61472: LD_INT 0
61474: PPUSH
// result := mc_mines [ base ] ;
61475: LD_ADDR_VAR 0 2
61479: PUSH
61480: LD_EXP 113
61484: PUSH
61485: LD_VAR 0 1
61489: ARRAY
61490: ST_TO_ADDR
// end ;
61491: LD_VAR 0 2
61495: RET
// export function MC_GetProduceList ( base ) ; begin
61496: LD_INT 0
61498: PPUSH
// result := mc_produce [ base ] ;
61499: LD_ADDR_VAR 0 2
61503: PUSH
61504: LD_EXP 121
61508: PUSH
61509: LD_VAR 0 1
61513: ARRAY
61514: ST_TO_ADDR
// end ;
61515: LD_VAR 0 2
61519: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61520: LD_INT 0
61522: PPUSH
61523: PPUSH
// if not mc_bases then
61524: LD_EXP 100
61528: NOT
61529: IFFALSE 61533
// exit ;
61531: GO 61598
// if mc_bases [ base ] then
61533: LD_EXP 100
61537: PUSH
61538: LD_VAR 0 1
61542: ARRAY
61543: IFFALSE 61598
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61545: LD_ADDR_VAR 0 3
61549: PUSH
61550: LD_EXP 100
61554: PUSH
61555: LD_VAR 0 1
61559: ARRAY
61560: PPUSH
61561: LD_INT 30
61563: PUSH
61564: LD_VAR 0 2
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PPUSH
61573: CALL_OW 72
61577: ST_TO_ADDR
// if result then
61578: LD_VAR 0 3
61582: IFFALSE 61598
// result := result [ 1 ] ;
61584: LD_ADDR_VAR 0 3
61588: PUSH
61589: LD_VAR 0 3
61593: PUSH
61594: LD_INT 1
61596: ARRAY
61597: ST_TO_ADDR
// end ; end ;
61598: LD_VAR 0 3
61602: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61603: LD_INT 0
61605: PPUSH
61606: PPUSH
// if not mc_bases then
61607: LD_EXP 100
61611: NOT
61612: IFFALSE 61616
// exit ;
61614: GO 61661
// if mc_bases [ base ] then
61616: LD_EXP 100
61620: PUSH
61621: LD_VAR 0 1
61625: ARRAY
61626: IFFALSE 61661
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61628: LD_ADDR_VAR 0 3
61632: PUSH
61633: LD_EXP 100
61637: PUSH
61638: LD_VAR 0 1
61642: ARRAY
61643: PPUSH
61644: LD_INT 30
61646: PUSH
61647: LD_VAR 0 2
61651: PUSH
61652: EMPTY
61653: LIST
61654: LIST
61655: PPUSH
61656: CALL_OW 72
61660: ST_TO_ADDR
// end ;
61661: LD_VAR 0 3
61665: RET
// export function MC_SetTame ( base , area ) ; begin
61666: LD_INT 0
61668: PPUSH
// if not mc_bases or not base then
61669: LD_EXP 100
61673: NOT
61674: PUSH
61675: LD_VAR 0 1
61679: NOT
61680: OR
61681: IFFALSE 61685
// exit ;
61683: GO 61710
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61685: LD_ADDR_EXP 128
61689: PUSH
61690: LD_EXP 128
61694: PPUSH
61695: LD_VAR 0 1
61699: PPUSH
61700: LD_VAR 0 2
61704: PPUSH
61705: CALL_OW 1
61709: ST_TO_ADDR
// end ;
61710: LD_VAR 0 3
61714: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61715: LD_INT 0
61717: PPUSH
61718: PPUSH
// if not mc_bases or not base then
61719: LD_EXP 100
61723: NOT
61724: PUSH
61725: LD_VAR 0 1
61729: NOT
61730: OR
61731: IFFALSE 61735
// exit ;
61733: GO 61837
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61735: LD_ADDR_VAR 0 4
61739: PUSH
61740: LD_EXP 100
61744: PUSH
61745: LD_VAR 0 1
61749: ARRAY
61750: PPUSH
61751: LD_INT 30
61753: PUSH
61754: LD_VAR 0 2
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PPUSH
61763: CALL_OW 72
61767: ST_TO_ADDR
// if not tmp then
61768: LD_VAR 0 4
61772: NOT
61773: IFFALSE 61777
// exit ;
61775: GO 61837
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61777: LD_ADDR_EXP 132
61781: PUSH
61782: LD_EXP 132
61786: PPUSH
61787: LD_VAR 0 1
61791: PPUSH
61792: LD_EXP 132
61796: PUSH
61797: LD_VAR 0 1
61801: ARRAY
61802: PPUSH
61803: LD_EXP 132
61807: PUSH
61808: LD_VAR 0 1
61812: ARRAY
61813: PUSH
61814: LD_INT 1
61816: PLUS
61817: PPUSH
61818: LD_VAR 0 4
61822: PUSH
61823: LD_INT 1
61825: ARRAY
61826: PPUSH
61827: CALL_OW 2
61831: PPUSH
61832: CALL_OW 1
61836: ST_TO_ADDR
// end ;
61837: LD_VAR 0 3
61841: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61842: LD_INT 0
61844: PPUSH
61845: PPUSH
// if not mc_bases or not base or not kinds then
61846: LD_EXP 100
61850: NOT
61851: PUSH
61852: LD_VAR 0 1
61856: NOT
61857: OR
61858: PUSH
61859: LD_VAR 0 2
61863: NOT
61864: OR
61865: IFFALSE 61869
// exit ;
61867: GO 61930
// for i in kinds do
61869: LD_ADDR_VAR 0 4
61873: PUSH
61874: LD_VAR 0 2
61878: PUSH
61879: FOR_IN
61880: IFFALSE 61928
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61882: LD_ADDR_EXP 134
61886: PUSH
61887: LD_EXP 134
61891: PPUSH
61892: LD_VAR 0 1
61896: PUSH
61897: LD_EXP 134
61901: PUSH
61902: LD_VAR 0 1
61906: ARRAY
61907: PUSH
61908: LD_INT 1
61910: PLUS
61911: PUSH
61912: EMPTY
61913: LIST
61914: LIST
61915: PPUSH
61916: LD_VAR 0 4
61920: PPUSH
61921: CALL 72673 0 3
61925: ST_TO_ADDR
61926: GO 61879
61928: POP
61929: POP
// end ;
61930: LD_VAR 0 3
61934: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61935: LD_INT 0
61937: PPUSH
// if not mc_bases or not base or not areas then
61938: LD_EXP 100
61942: NOT
61943: PUSH
61944: LD_VAR 0 1
61948: NOT
61949: OR
61950: PUSH
61951: LD_VAR 0 2
61955: NOT
61956: OR
61957: IFFALSE 61961
// exit ;
61959: GO 61986
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61961: LD_ADDR_EXP 118
61965: PUSH
61966: LD_EXP 118
61970: PPUSH
61971: LD_VAR 0 1
61975: PPUSH
61976: LD_VAR 0 2
61980: PPUSH
61981: CALL_OW 1
61985: ST_TO_ADDR
// end ;
61986: LD_VAR 0 3
61990: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61991: LD_INT 0
61993: PPUSH
// if not mc_bases or not base or not teleports_exit then
61994: LD_EXP 100
61998: NOT
61999: PUSH
62000: LD_VAR 0 1
62004: NOT
62005: OR
62006: PUSH
62007: LD_VAR 0 2
62011: NOT
62012: OR
62013: IFFALSE 62017
// exit ;
62015: GO 62042
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
62017: LD_ADDR_EXP 135
62021: PUSH
62022: LD_EXP 135
62026: PPUSH
62027: LD_VAR 0 1
62031: PPUSH
62032: LD_VAR 0 2
62036: PPUSH
62037: CALL_OW 1
62041: ST_TO_ADDR
// end ;
62042: LD_VAR 0 3
62046: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
62047: LD_INT 0
62049: PPUSH
62050: PPUSH
62051: PPUSH
// if not mc_bases or not base or not ext_list then
62052: LD_EXP 100
62056: NOT
62057: PUSH
62058: LD_VAR 0 1
62062: NOT
62063: OR
62064: PUSH
62065: LD_VAR 0 5
62069: NOT
62070: OR
62071: IFFALSE 62075
// exit ;
62073: GO 62248
// tmp := GetFacExtXYD ( x , y , d ) ;
62075: LD_ADDR_VAR 0 8
62079: PUSH
62080: LD_VAR 0 2
62084: PPUSH
62085: LD_VAR 0 3
62089: PPUSH
62090: LD_VAR 0 4
62094: PPUSH
62095: CALL 102624 0 3
62099: ST_TO_ADDR
// if not tmp then
62100: LD_VAR 0 8
62104: NOT
62105: IFFALSE 62109
// exit ;
62107: GO 62248
// for i in tmp do
62109: LD_ADDR_VAR 0 7
62113: PUSH
62114: LD_VAR 0 8
62118: PUSH
62119: FOR_IN
62120: IFFALSE 62246
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
62122: LD_ADDR_EXP 105
62126: PUSH
62127: LD_EXP 105
62131: PPUSH
62132: LD_VAR 0 1
62136: PPUSH
62137: LD_EXP 105
62141: PUSH
62142: LD_VAR 0 1
62146: ARRAY
62147: PPUSH
62148: LD_EXP 105
62152: PUSH
62153: LD_VAR 0 1
62157: ARRAY
62158: PUSH
62159: LD_INT 1
62161: PLUS
62162: PPUSH
62163: LD_VAR 0 5
62167: PUSH
62168: LD_INT 1
62170: ARRAY
62171: PUSH
62172: LD_VAR 0 7
62176: PUSH
62177: LD_INT 1
62179: ARRAY
62180: PUSH
62181: LD_VAR 0 7
62185: PUSH
62186: LD_INT 2
62188: ARRAY
62189: PUSH
62190: LD_VAR 0 7
62194: PUSH
62195: LD_INT 3
62197: ARRAY
62198: PUSH
62199: EMPTY
62200: LIST
62201: LIST
62202: LIST
62203: LIST
62204: PPUSH
62205: CALL_OW 2
62209: PPUSH
62210: CALL_OW 1
62214: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
62215: LD_ADDR_VAR 0 5
62219: PUSH
62220: LD_VAR 0 5
62224: PPUSH
62225: LD_INT 1
62227: PPUSH
62228: CALL_OW 3
62232: ST_TO_ADDR
// if not ext_list then
62233: LD_VAR 0 5
62237: NOT
62238: IFFALSE 62244
// exit ;
62240: POP
62241: POP
62242: GO 62248
// end ;
62244: GO 62119
62246: POP
62247: POP
// end ;
62248: LD_VAR 0 6
62252: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
62253: LD_INT 0
62255: PPUSH
// if not mc_bases or not base or not weapon_list then
62256: LD_EXP 100
62260: NOT
62261: PUSH
62262: LD_VAR 0 1
62266: NOT
62267: OR
62268: PUSH
62269: LD_VAR 0 2
62273: NOT
62274: OR
62275: IFFALSE 62279
// exit ;
62277: GO 62304
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
62279: LD_ADDR_EXP 139
62283: PUSH
62284: LD_EXP 139
62288: PPUSH
62289: LD_VAR 0 1
62293: PPUSH
62294: LD_VAR 0 2
62298: PPUSH
62299: CALL_OW 1
62303: ST_TO_ADDR
// end ;
62304: LD_VAR 0 3
62308: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62309: LD_INT 0
62311: PPUSH
// if not mc_bases or not base or not tech_list then
62312: LD_EXP 100
62316: NOT
62317: PUSH
62318: LD_VAR 0 1
62322: NOT
62323: OR
62324: PUSH
62325: LD_VAR 0 2
62329: NOT
62330: OR
62331: IFFALSE 62335
// exit ;
62333: GO 62360
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62335: LD_ADDR_EXP 127
62339: PUSH
62340: LD_EXP 127
62344: PPUSH
62345: LD_VAR 0 1
62349: PPUSH
62350: LD_VAR 0 2
62354: PPUSH
62355: CALL_OW 1
62359: ST_TO_ADDR
// end ;
62360: LD_VAR 0 3
62364: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62365: LD_INT 0
62367: PPUSH
// if not mc_bases or not parking_area or not base then
62368: LD_EXP 100
62372: NOT
62373: PUSH
62374: LD_VAR 0 2
62378: NOT
62379: OR
62380: PUSH
62381: LD_VAR 0 1
62385: NOT
62386: OR
62387: IFFALSE 62391
// exit ;
62389: GO 62416
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62391: LD_ADDR_EXP 124
62395: PUSH
62396: LD_EXP 124
62400: PPUSH
62401: LD_VAR 0 1
62405: PPUSH
62406: LD_VAR 0 2
62410: PPUSH
62411: CALL_OW 1
62415: ST_TO_ADDR
// end ;
62416: LD_VAR 0 3
62420: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62421: LD_INT 0
62423: PPUSH
// if not mc_bases or not base or not scan_area then
62424: LD_EXP 100
62428: NOT
62429: PUSH
62430: LD_VAR 0 1
62434: NOT
62435: OR
62436: PUSH
62437: LD_VAR 0 2
62441: NOT
62442: OR
62443: IFFALSE 62447
// exit ;
62445: GO 62472
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62447: LD_ADDR_EXP 125
62451: PUSH
62452: LD_EXP 125
62456: PPUSH
62457: LD_VAR 0 1
62461: PPUSH
62462: LD_VAR 0 2
62466: PPUSH
62467: CALL_OW 1
62471: ST_TO_ADDR
// end ;
62472: LD_VAR 0 3
62476: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62477: LD_INT 0
62479: PPUSH
62480: PPUSH
// if not mc_bases or not base then
62481: LD_EXP 100
62485: NOT
62486: PUSH
62487: LD_VAR 0 1
62491: NOT
62492: OR
62493: IFFALSE 62497
// exit ;
62495: GO 62561
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62497: LD_ADDR_VAR 0 3
62501: PUSH
62502: LD_INT 1
62504: PUSH
62505: LD_INT 2
62507: PUSH
62508: LD_INT 3
62510: PUSH
62511: LD_INT 4
62513: PUSH
62514: LD_INT 11
62516: PUSH
62517: EMPTY
62518: LIST
62519: LIST
62520: LIST
62521: LIST
62522: LIST
62523: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62524: LD_ADDR_EXP 127
62528: PUSH
62529: LD_EXP 127
62533: PPUSH
62534: LD_VAR 0 1
62538: PPUSH
62539: LD_EXP 127
62543: PUSH
62544: LD_VAR 0 1
62548: ARRAY
62549: PUSH
62550: LD_VAR 0 3
62554: DIFF
62555: PPUSH
62556: CALL_OW 1
62560: ST_TO_ADDR
// end ;
62561: LD_VAR 0 2
62565: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62566: LD_INT 0
62568: PPUSH
// result := mc_vehicles [ base ] ;
62569: LD_ADDR_VAR 0 3
62573: PUSH
62574: LD_EXP 119
62578: PUSH
62579: LD_VAR 0 1
62583: ARRAY
62584: ST_TO_ADDR
// if onlyCombat then
62585: LD_VAR 0 2
62589: IFFALSE 62761
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62591: LD_ADDR_VAR 0 3
62595: PUSH
62596: LD_VAR 0 3
62600: PUSH
62601: LD_VAR 0 3
62605: PPUSH
62606: LD_INT 2
62608: PUSH
62609: LD_INT 34
62611: PUSH
62612: LD_INT 12
62614: PUSH
62615: EMPTY
62616: LIST
62617: LIST
62618: PUSH
62619: LD_INT 34
62621: PUSH
62622: LD_INT 51
62624: PUSH
62625: EMPTY
62626: LIST
62627: LIST
62628: PUSH
62629: LD_INT 34
62631: PUSH
62632: LD_INT 89
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PUSH
62639: LD_INT 34
62641: PUSH
62642: LD_INT 32
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: PUSH
62649: LD_INT 34
62651: PUSH
62652: LD_INT 13
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PUSH
62659: LD_INT 34
62661: PUSH
62662: LD_INT 52
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: PUSH
62669: LD_INT 34
62671: PUSH
62672: LD_INT 88
62674: PUSH
62675: EMPTY
62676: LIST
62677: LIST
62678: PUSH
62679: LD_INT 34
62681: PUSH
62682: LD_INT 14
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 34
62691: PUSH
62692: LD_INT 53
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: LD_INT 34
62701: PUSH
62702: LD_INT 98
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: PUSH
62709: LD_INT 34
62711: PUSH
62712: LD_INT 31
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: PUSH
62719: LD_INT 34
62721: PUSH
62722: LD_INT 48
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 34
62731: PUSH
62732: LD_INT 8
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: LIST
62743: LIST
62744: LIST
62745: LIST
62746: LIST
62747: LIST
62748: LIST
62749: LIST
62750: LIST
62751: LIST
62752: LIST
62753: LIST
62754: PPUSH
62755: CALL_OW 72
62759: DIFF
62760: ST_TO_ADDR
// end ; end_of_file
62761: LD_VAR 0 3
62765: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62766: LD_INT 0
62768: PPUSH
62769: PPUSH
62770: PPUSH
// if not mc_bases or not skirmish then
62771: LD_EXP 100
62775: NOT
62776: PUSH
62777: LD_EXP 98
62781: NOT
62782: OR
62783: IFFALSE 62787
// exit ;
62785: GO 62952
// for i = 1 to mc_bases do
62787: LD_ADDR_VAR 0 4
62791: PUSH
62792: DOUBLE
62793: LD_INT 1
62795: DEC
62796: ST_TO_ADDR
62797: LD_EXP 100
62801: PUSH
62802: FOR_TO
62803: IFFALSE 62950
// begin if sci in mc_bases [ i ] then
62805: LD_VAR 0 2
62809: PUSH
62810: LD_EXP 100
62814: PUSH
62815: LD_VAR 0 4
62819: ARRAY
62820: IN
62821: IFFALSE 62948
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62823: LD_ADDR_EXP 129
62827: PUSH
62828: LD_EXP 129
62832: PPUSH
62833: LD_VAR 0 4
62837: PUSH
62838: LD_EXP 129
62842: PUSH
62843: LD_VAR 0 4
62847: ARRAY
62848: PUSH
62849: LD_INT 1
62851: PLUS
62852: PUSH
62853: EMPTY
62854: LIST
62855: LIST
62856: PPUSH
62857: LD_VAR 0 1
62861: PPUSH
62862: CALL 72673 0 3
62866: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62867: LD_ADDR_VAR 0 5
62871: PUSH
62872: LD_EXP 100
62876: PUSH
62877: LD_VAR 0 4
62881: ARRAY
62882: PPUSH
62883: LD_INT 2
62885: PUSH
62886: LD_INT 30
62888: PUSH
62889: LD_INT 0
62891: PUSH
62892: EMPTY
62893: LIST
62894: LIST
62895: PUSH
62896: LD_INT 30
62898: PUSH
62899: LD_INT 1
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: EMPTY
62907: LIST
62908: LIST
62909: LIST
62910: PPUSH
62911: CALL_OW 72
62915: PPUSH
62916: LD_VAR 0 1
62920: PPUSH
62921: CALL_OW 74
62925: ST_TO_ADDR
// if tmp then
62926: LD_VAR 0 5
62930: IFFALSE 62946
// ComStandNearbyBuilding ( ape , tmp ) ;
62932: LD_VAR 0 1
62936: PPUSH
62937: LD_VAR 0 5
62941: PPUSH
62942: CALL 69100 0 2
// break ;
62946: GO 62950
// end ; end ;
62948: GO 62802
62950: POP
62951: POP
// end ;
62952: LD_VAR 0 3
62956: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62957: LD_INT 0
62959: PPUSH
62960: PPUSH
62961: PPUSH
// if not mc_bases or not skirmish then
62962: LD_EXP 100
62966: NOT
62967: PUSH
62968: LD_EXP 98
62972: NOT
62973: OR
62974: IFFALSE 62978
// exit ;
62976: GO 63067
// for i = 1 to mc_bases do
62978: LD_ADDR_VAR 0 4
62982: PUSH
62983: DOUBLE
62984: LD_INT 1
62986: DEC
62987: ST_TO_ADDR
62988: LD_EXP 100
62992: PUSH
62993: FOR_TO
62994: IFFALSE 63065
// begin if building in mc_busy_turret_list [ i ] then
62996: LD_VAR 0 1
63000: PUSH
63001: LD_EXP 110
63005: PUSH
63006: LD_VAR 0 4
63010: ARRAY
63011: IN
63012: IFFALSE 63063
// begin tmp := mc_busy_turret_list [ i ] diff building ;
63014: LD_ADDR_VAR 0 5
63018: PUSH
63019: LD_EXP 110
63023: PUSH
63024: LD_VAR 0 4
63028: ARRAY
63029: PUSH
63030: LD_VAR 0 1
63034: DIFF
63035: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
63036: LD_ADDR_EXP 110
63040: PUSH
63041: LD_EXP 110
63045: PPUSH
63046: LD_VAR 0 4
63050: PPUSH
63051: LD_VAR 0 5
63055: PPUSH
63056: CALL_OW 1
63060: ST_TO_ADDR
// break ;
63061: GO 63065
// end ; end ;
63063: GO 62993
63065: POP
63066: POP
// end ;
63067: LD_VAR 0 3
63071: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
63072: LD_INT 0
63074: PPUSH
63075: PPUSH
63076: PPUSH
// if not mc_bases or not skirmish then
63077: LD_EXP 100
63081: NOT
63082: PUSH
63083: LD_EXP 98
63087: NOT
63088: OR
63089: IFFALSE 63093
// exit ;
63091: GO 63292
// for i = 1 to mc_bases do
63093: LD_ADDR_VAR 0 5
63097: PUSH
63098: DOUBLE
63099: LD_INT 1
63101: DEC
63102: ST_TO_ADDR
63103: LD_EXP 100
63107: PUSH
63108: FOR_TO
63109: IFFALSE 63290
// if building in mc_bases [ i ] then
63111: LD_VAR 0 1
63115: PUSH
63116: LD_EXP 100
63120: PUSH
63121: LD_VAR 0 5
63125: ARRAY
63126: IN
63127: IFFALSE 63288
// begin tmp := mc_bases [ i ] diff building ;
63129: LD_ADDR_VAR 0 6
63133: PUSH
63134: LD_EXP 100
63138: PUSH
63139: LD_VAR 0 5
63143: ARRAY
63144: PUSH
63145: LD_VAR 0 1
63149: DIFF
63150: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
63151: LD_ADDR_EXP 100
63155: PUSH
63156: LD_EXP 100
63160: PPUSH
63161: LD_VAR 0 5
63165: PPUSH
63166: LD_VAR 0 6
63170: PPUSH
63171: CALL_OW 1
63175: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
63176: LD_VAR 0 1
63180: PUSH
63181: LD_EXP 108
63185: PUSH
63186: LD_VAR 0 5
63190: ARRAY
63191: IN
63192: IFFALSE 63231
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
63194: LD_ADDR_EXP 108
63198: PUSH
63199: LD_EXP 108
63203: PPUSH
63204: LD_VAR 0 5
63208: PPUSH
63209: LD_EXP 108
63213: PUSH
63214: LD_VAR 0 5
63218: ARRAY
63219: PUSH
63220: LD_VAR 0 1
63224: DIFF
63225: PPUSH
63226: CALL_OW 1
63230: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
63231: LD_VAR 0 1
63235: PUSH
63236: LD_EXP 109
63240: PUSH
63241: LD_VAR 0 5
63245: ARRAY
63246: IN
63247: IFFALSE 63286
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
63249: LD_ADDR_EXP 109
63253: PUSH
63254: LD_EXP 109
63258: PPUSH
63259: LD_VAR 0 5
63263: PPUSH
63264: LD_EXP 109
63268: PUSH
63269: LD_VAR 0 5
63273: ARRAY
63274: PUSH
63275: LD_VAR 0 1
63279: DIFF
63280: PPUSH
63281: CALL_OW 1
63285: ST_TO_ADDR
// break ;
63286: GO 63290
// end ;
63288: GO 63108
63290: POP
63291: POP
// end ;
63292: LD_VAR 0 4
63296: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
63297: LD_INT 0
63299: PPUSH
63300: PPUSH
63301: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63302: LD_EXP 100
63306: NOT
63307: PUSH
63308: LD_EXP 98
63312: NOT
63313: OR
63314: PUSH
63315: LD_VAR 0 3
63319: PUSH
63320: LD_EXP 126
63324: IN
63325: NOT
63326: OR
63327: IFFALSE 63331
// exit ;
63329: GO 63454
// for i = 1 to mc_vehicles do
63331: LD_ADDR_VAR 0 6
63335: PUSH
63336: DOUBLE
63337: LD_INT 1
63339: DEC
63340: ST_TO_ADDR
63341: LD_EXP 119
63345: PUSH
63346: FOR_TO
63347: IFFALSE 63452
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63349: LD_VAR 0 2
63353: PUSH
63354: LD_EXP 119
63358: PUSH
63359: LD_VAR 0 6
63363: ARRAY
63364: IN
63365: PUSH
63366: LD_VAR 0 1
63370: PUSH
63371: LD_EXP 119
63375: PUSH
63376: LD_VAR 0 6
63380: ARRAY
63381: IN
63382: OR
63383: IFFALSE 63450
// begin tmp := mc_vehicles [ i ] diff old ;
63385: LD_ADDR_VAR 0 7
63389: PUSH
63390: LD_EXP 119
63394: PUSH
63395: LD_VAR 0 6
63399: ARRAY
63400: PUSH
63401: LD_VAR 0 2
63405: DIFF
63406: ST_TO_ADDR
// tmp := tmp diff new ;
63407: LD_ADDR_VAR 0 7
63411: PUSH
63412: LD_VAR 0 7
63416: PUSH
63417: LD_VAR 0 1
63421: DIFF
63422: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63423: LD_ADDR_EXP 119
63427: PUSH
63428: LD_EXP 119
63432: PPUSH
63433: LD_VAR 0 6
63437: PPUSH
63438: LD_VAR 0 7
63442: PPUSH
63443: CALL_OW 1
63447: ST_TO_ADDR
// break ;
63448: GO 63452
// end ;
63450: GO 63346
63452: POP
63453: POP
// end ;
63454: LD_VAR 0 5
63458: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63459: LD_INT 0
63461: PPUSH
63462: PPUSH
63463: PPUSH
63464: PPUSH
// if not mc_bases or not skirmish then
63465: LD_EXP 100
63469: NOT
63470: PUSH
63471: LD_EXP 98
63475: NOT
63476: OR
63477: IFFALSE 63481
// exit ;
63479: GO 63863
// side := GetSide ( vehicle ) ;
63481: LD_ADDR_VAR 0 5
63485: PUSH
63486: LD_VAR 0 1
63490: PPUSH
63491: CALL_OW 255
63495: ST_TO_ADDR
// for i = 1 to mc_bases do
63496: LD_ADDR_VAR 0 4
63500: PUSH
63501: DOUBLE
63502: LD_INT 1
63504: DEC
63505: ST_TO_ADDR
63506: LD_EXP 100
63510: PUSH
63511: FOR_TO
63512: IFFALSE 63861
// begin if factory in mc_bases [ i ] then
63514: LD_VAR 0 2
63518: PUSH
63519: LD_EXP 100
63523: PUSH
63524: LD_VAR 0 4
63528: ARRAY
63529: IN
63530: IFFALSE 63859
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63532: LD_EXP 122
63536: PUSH
63537: LD_VAR 0 4
63541: ARRAY
63542: PUSH
63543: LD_EXP 111
63547: PUSH
63548: LD_VAR 0 4
63552: ARRAY
63553: LESS
63554: PUSH
63555: LD_VAR 0 1
63559: PPUSH
63560: CALL_OW 264
63564: PUSH
63565: LD_INT 31
63567: PUSH
63568: LD_INT 32
63570: PUSH
63571: LD_INT 51
63573: PUSH
63574: LD_INT 89
63576: PUSH
63577: LD_INT 12
63579: PUSH
63580: LD_INT 30
63582: PUSH
63583: LD_INT 98
63585: PUSH
63586: LD_INT 11
63588: PUSH
63589: LD_INT 53
63591: PUSH
63592: LD_INT 14
63594: PUSH
63595: LD_INT 91
63597: PUSH
63598: LD_INT 29
63600: PUSH
63601: LD_INT 99
63603: PUSH
63604: LD_INT 13
63606: PUSH
63607: LD_INT 52
63609: PUSH
63610: LD_INT 88
63612: PUSH
63613: LD_INT 48
63615: PUSH
63616: LD_INT 8
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: IN
63639: NOT
63640: AND
63641: IFFALSE 63689
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63643: LD_ADDR_EXP 122
63647: PUSH
63648: LD_EXP 122
63652: PPUSH
63653: LD_VAR 0 4
63657: PUSH
63658: LD_EXP 122
63662: PUSH
63663: LD_VAR 0 4
63667: ARRAY
63668: PUSH
63669: LD_INT 1
63671: PLUS
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: PPUSH
63677: LD_VAR 0 1
63681: PPUSH
63682: CALL 72673 0 3
63686: ST_TO_ADDR
63687: GO 63733
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63689: LD_ADDR_EXP 119
63693: PUSH
63694: LD_EXP 119
63698: PPUSH
63699: LD_VAR 0 4
63703: PUSH
63704: LD_EXP 119
63708: PUSH
63709: LD_VAR 0 4
63713: ARRAY
63714: PUSH
63715: LD_INT 1
63717: PLUS
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: PPUSH
63723: LD_VAR 0 1
63727: PPUSH
63728: CALL 72673 0 3
63732: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63733: LD_VAR 0 1
63737: PPUSH
63738: CALL_OW 263
63742: PUSH
63743: LD_INT 2
63745: EQUAL
63746: IFFALSE 63775
// begin repeat wait ( 0 0$3 ) ;
63748: LD_INT 105
63750: PPUSH
63751: CALL_OW 67
// Connect ( vehicle ) ;
63755: LD_VAR 0 1
63759: PPUSH
63760: CALL 75642 0 1
// until IsControledBy ( vehicle ) ;
63764: LD_VAR 0 1
63768: PPUSH
63769: CALL_OW 312
63773: IFFALSE 63748
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63775: LD_VAR 0 1
63779: PPUSH
63780: LD_EXP 124
63784: PUSH
63785: LD_VAR 0 4
63789: ARRAY
63790: PPUSH
63791: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63795: LD_VAR 0 1
63799: PPUSH
63800: CALL_OW 263
63804: PUSH
63805: LD_INT 1
63807: NONEQUAL
63808: IFFALSE 63812
// break ;
63810: GO 63861
// repeat wait ( 0 0$1 ) ;
63812: LD_INT 35
63814: PPUSH
63815: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63819: LD_VAR 0 1
63823: PPUSH
63824: LD_EXP 124
63828: PUSH
63829: LD_VAR 0 4
63833: ARRAY
63834: PPUSH
63835: CALL_OW 308
63839: IFFALSE 63812
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63841: LD_VAR 0 1
63845: PPUSH
63846: CALL_OW 311
63850: PPUSH
63851: CALL_OW 121
// exit ;
63855: POP
63856: POP
63857: GO 63863
// end ; end ;
63859: GO 63511
63861: POP
63862: POP
// end ;
63863: LD_VAR 0 3
63867: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63868: LD_INT 0
63870: PPUSH
63871: PPUSH
63872: PPUSH
63873: PPUSH
// if not mc_bases or not skirmish then
63874: LD_EXP 100
63878: NOT
63879: PUSH
63880: LD_EXP 98
63884: NOT
63885: OR
63886: IFFALSE 63890
// exit ;
63888: GO 64243
// repeat wait ( 0 0$1 ) ;
63890: LD_INT 35
63892: PPUSH
63893: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63897: LD_VAR 0 2
63901: PPUSH
63902: LD_VAR 0 3
63906: PPUSH
63907: CALL_OW 284
63911: IFFALSE 63890
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63913: LD_VAR 0 2
63917: PPUSH
63918: LD_VAR 0 3
63922: PPUSH
63923: CALL_OW 283
63927: PUSH
63928: LD_INT 4
63930: EQUAL
63931: IFFALSE 63935
// exit ;
63933: GO 64243
// for i = 1 to mc_bases do
63935: LD_ADDR_VAR 0 7
63939: PUSH
63940: DOUBLE
63941: LD_INT 1
63943: DEC
63944: ST_TO_ADDR
63945: LD_EXP 100
63949: PUSH
63950: FOR_TO
63951: IFFALSE 64241
// begin if mc_crates_area [ i ] then
63953: LD_EXP 118
63957: PUSH
63958: LD_VAR 0 7
63962: ARRAY
63963: IFFALSE 64074
// for j in mc_crates_area [ i ] do
63965: LD_ADDR_VAR 0 8
63969: PUSH
63970: LD_EXP 118
63974: PUSH
63975: LD_VAR 0 7
63979: ARRAY
63980: PUSH
63981: FOR_IN
63982: IFFALSE 64072
// if InArea ( x , y , j ) then
63984: LD_VAR 0 2
63988: PPUSH
63989: LD_VAR 0 3
63993: PPUSH
63994: LD_VAR 0 8
63998: PPUSH
63999: CALL_OW 309
64003: IFFALSE 64070
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64005: LD_ADDR_EXP 116
64009: PUSH
64010: LD_EXP 116
64014: PPUSH
64015: LD_VAR 0 7
64019: PUSH
64020: LD_EXP 116
64024: PUSH
64025: LD_VAR 0 7
64029: ARRAY
64030: PUSH
64031: LD_INT 1
64033: PLUS
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: PPUSH
64039: LD_VAR 0 4
64043: PUSH
64044: LD_VAR 0 2
64048: PUSH
64049: LD_VAR 0 3
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: LIST
64058: PPUSH
64059: CALL 72673 0 3
64063: ST_TO_ADDR
// exit ;
64064: POP
64065: POP
64066: POP
64067: POP
64068: GO 64243
// end ;
64070: GO 63981
64072: POP
64073: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64074: LD_ADDR_VAR 0 9
64078: PUSH
64079: LD_EXP 100
64083: PUSH
64084: LD_VAR 0 7
64088: ARRAY
64089: PPUSH
64090: LD_INT 2
64092: PUSH
64093: LD_INT 30
64095: PUSH
64096: LD_INT 0
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: PUSH
64103: LD_INT 30
64105: PUSH
64106: LD_INT 1
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: LIST
64117: PPUSH
64118: CALL_OW 72
64122: ST_TO_ADDR
// if not depot then
64123: LD_VAR 0 9
64127: NOT
64128: IFFALSE 64132
// continue ;
64130: GO 63950
// for j in depot do
64132: LD_ADDR_VAR 0 8
64136: PUSH
64137: LD_VAR 0 9
64141: PUSH
64142: FOR_IN
64143: IFFALSE 64237
// if GetDistUnitXY ( j , x , y ) < 30 then
64145: LD_VAR 0 8
64149: PPUSH
64150: LD_VAR 0 2
64154: PPUSH
64155: LD_VAR 0 3
64159: PPUSH
64160: CALL_OW 297
64164: PUSH
64165: LD_INT 30
64167: LESS
64168: IFFALSE 64235
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64170: LD_ADDR_EXP 116
64174: PUSH
64175: LD_EXP 116
64179: PPUSH
64180: LD_VAR 0 7
64184: PUSH
64185: LD_EXP 116
64189: PUSH
64190: LD_VAR 0 7
64194: ARRAY
64195: PUSH
64196: LD_INT 1
64198: PLUS
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: PPUSH
64204: LD_VAR 0 4
64208: PUSH
64209: LD_VAR 0 2
64213: PUSH
64214: LD_VAR 0 3
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: LIST
64223: PPUSH
64224: CALL 72673 0 3
64228: ST_TO_ADDR
// exit ;
64229: POP
64230: POP
64231: POP
64232: POP
64233: GO 64243
// end ;
64235: GO 64142
64237: POP
64238: POP
// end ;
64239: GO 63950
64241: POP
64242: POP
// end ;
64243: LD_VAR 0 6
64247: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
64248: LD_INT 0
64250: PPUSH
64251: PPUSH
64252: PPUSH
64253: PPUSH
// if not mc_bases or not skirmish then
64254: LD_EXP 100
64258: NOT
64259: PUSH
64260: LD_EXP 98
64264: NOT
64265: OR
64266: IFFALSE 64270
// exit ;
64268: GO 64547
// side := GetSide ( lab ) ;
64270: LD_ADDR_VAR 0 4
64274: PUSH
64275: LD_VAR 0 2
64279: PPUSH
64280: CALL_OW 255
64284: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
64285: LD_VAR 0 4
64289: PUSH
64290: LD_EXP 126
64294: IN
64295: NOT
64296: PUSH
64297: LD_EXP 127
64301: NOT
64302: OR
64303: PUSH
64304: LD_EXP 100
64308: NOT
64309: OR
64310: IFFALSE 64314
// exit ;
64312: GO 64547
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64314: LD_ADDR_EXP 127
64318: PUSH
64319: LD_EXP 127
64323: PPUSH
64324: LD_VAR 0 4
64328: PPUSH
64329: LD_EXP 127
64333: PUSH
64334: LD_VAR 0 4
64338: ARRAY
64339: PUSH
64340: LD_VAR 0 1
64344: DIFF
64345: PPUSH
64346: CALL_OW 1
64350: ST_TO_ADDR
// for i = 1 to mc_bases do
64351: LD_ADDR_VAR 0 5
64355: PUSH
64356: DOUBLE
64357: LD_INT 1
64359: DEC
64360: ST_TO_ADDR
64361: LD_EXP 100
64365: PUSH
64366: FOR_TO
64367: IFFALSE 64545
// begin if lab in mc_bases [ i ] then
64369: LD_VAR 0 2
64373: PUSH
64374: LD_EXP 100
64378: PUSH
64379: LD_VAR 0 5
64383: ARRAY
64384: IN
64385: IFFALSE 64543
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64387: LD_VAR 0 1
64391: PUSH
64392: LD_INT 11
64394: PUSH
64395: LD_INT 4
64397: PUSH
64398: LD_INT 3
64400: PUSH
64401: LD_INT 2
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: IN
64410: PUSH
64411: LD_EXP 130
64415: PUSH
64416: LD_VAR 0 5
64420: ARRAY
64421: AND
64422: IFFALSE 64543
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64424: LD_ADDR_VAR 0 6
64428: PUSH
64429: LD_EXP 130
64433: PUSH
64434: LD_VAR 0 5
64438: ARRAY
64439: PUSH
64440: LD_INT 1
64442: ARRAY
64443: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64444: LD_ADDR_EXP 130
64448: PUSH
64449: LD_EXP 130
64453: PPUSH
64454: LD_VAR 0 5
64458: PPUSH
64459: EMPTY
64460: PPUSH
64461: CALL_OW 1
64465: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64466: LD_VAR 0 6
64470: PPUSH
64471: LD_INT 0
64473: PPUSH
64474: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64478: LD_VAR 0 6
64482: PPUSH
64483: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64487: LD_ADDR_EXP 129
64491: PUSH
64492: LD_EXP 129
64496: PPUSH
64497: LD_VAR 0 5
64501: PPUSH
64502: LD_EXP 129
64506: PUSH
64507: LD_VAR 0 5
64511: ARRAY
64512: PPUSH
64513: LD_INT 1
64515: PPUSH
64516: LD_VAR 0 6
64520: PPUSH
64521: CALL_OW 2
64525: PPUSH
64526: CALL_OW 1
64530: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64531: LD_VAR 0 5
64535: PPUSH
64536: LD_INT 112
64538: PPUSH
64539: CALL 41033 0 2
// end ; end ; end ;
64543: GO 64366
64545: POP
64546: POP
// end ;
64547: LD_VAR 0 3
64551: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64552: LD_INT 0
64554: PPUSH
64555: PPUSH
64556: PPUSH
64557: PPUSH
64558: PPUSH
64559: PPUSH
64560: PPUSH
64561: PPUSH
// if not mc_bases or not skirmish then
64562: LD_EXP 100
64566: NOT
64567: PUSH
64568: LD_EXP 98
64572: NOT
64573: OR
64574: IFFALSE 64578
// exit ;
64576: GO 65947
// for i = 1 to mc_bases do
64578: LD_ADDR_VAR 0 3
64582: PUSH
64583: DOUBLE
64584: LD_INT 1
64586: DEC
64587: ST_TO_ADDR
64588: LD_EXP 100
64592: PUSH
64593: FOR_TO
64594: IFFALSE 65945
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64596: LD_VAR 0 1
64600: PUSH
64601: LD_EXP 100
64605: PUSH
64606: LD_VAR 0 3
64610: ARRAY
64611: IN
64612: PUSH
64613: LD_VAR 0 1
64617: PUSH
64618: LD_EXP 107
64622: PUSH
64623: LD_VAR 0 3
64627: ARRAY
64628: IN
64629: OR
64630: PUSH
64631: LD_VAR 0 1
64635: PUSH
64636: LD_EXP 122
64640: PUSH
64641: LD_VAR 0 3
64645: ARRAY
64646: IN
64647: OR
64648: PUSH
64649: LD_VAR 0 1
64653: PUSH
64654: LD_EXP 119
64658: PUSH
64659: LD_VAR 0 3
64663: ARRAY
64664: IN
64665: OR
64666: PUSH
64667: LD_VAR 0 1
64671: PUSH
64672: LD_EXP 129
64676: PUSH
64677: LD_VAR 0 3
64681: ARRAY
64682: IN
64683: OR
64684: PUSH
64685: LD_VAR 0 1
64689: PUSH
64690: LD_EXP 130
64694: PUSH
64695: LD_VAR 0 3
64699: ARRAY
64700: IN
64701: OR
64702: IFFALSE 65943
// begin if un in mc_ape [ i ] then
64704: LD_VAR 0 1
64708: PUSH
64709: LD_EXP 129
64713: PUSH
64714: LD_VAR 0 3
64718: ARRAY
64719: IN
64720: IFFALSE 64759
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64722: LD_ADDR_EXP 129
64726: PUSH
64727: LD_EXP 129
64731: PPUSH
64732: LD_VAR 0 3
64736: PPUSH
64737: LD_EXP 129
64741: PUSH
64742: LD_VAR 0 3
64746: ARRAY
64747: PUSH
64748: LD_VAR 0 1
64752: DIFF
64753: PPUSH
64754: CALL_OW 1
64758: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64759: LD_VAR 0 1
64763: PUSH
64764: LD_EXP 130
64768: PUSH
64769: LD_VAR 0 3
64773: ARRAY
64774: IN
64775: IFFALSE 64799
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64777: LD_ADDR_EXP 130
64781: PUSH
64782: LD_EXP 130
64786: PPUSH
64787: LD_VAR 0 3
64791: PPUSH
64792: EMPTY
64793: PPUSH
64794: CALL_OW 1
64798: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64799: LD_VAR 0 1
64803: PPUSH
64804: CALL_OW 247
64808: PUSH
64809: LD_INT 2
64811: EQUAL
64812: PUSH
64813: LD_VAR 0 1
64817: PPUSH
64818: CALL_OW 110
64822: PUSH
64823: LD_INT 20
64825: EQUAL
64826: PUSH
64827: LD_VAR 0 1
64831: PUSH
64832: LD_EXP 122
64836: PUSH
64837: LD_VAR 0 3
64841: ARRAY
64842: IN
64843: OR
64844: PUSH
64845: LD_VAR 0 1
64849: PPUSH
64850: CALL_OW 264
64854: PUSH
64855: LD_INT 12
64857: PUSH
64858: LD_INT 51
64860: PUSH
64861: LD_INT 89
64863: PUSH
64864: LD_INT 32
64866: PUSH
64867: LD_INT 13
64869: PUSH
64870: LD_INT 52
64872: PUSH
64873: LD_INT 31
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: LIST
64882: LIST
64883: LIST
64884: IN
64885: OR
64886: AND
64887: IFFALSE 65195
// begin if un in mc_defender [ i ] then
64889: LD_VAR 0 1
64893: PUSH
64894: LD_EXP 122
64898: PUSH
64899: LD_VAR 0 3
64903: ARRAY
64904: IN
64905: IFFALSE 64944
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64907: LD_ADDR_EXP 122
64911: PUSH
64912: LD_EXP 122
64916: PPUSH
64917: LD_VAR 0 3
64921: PPUSH
64922: LD_EXP 122
64926: PUSH
64927: LD_VAR 0 3
64931: ARRAY
64932: PUSH
64933: LD_VAR 0 1
64937: DIFF
64938: PPUSH
64939: CALL_OW 1
64943: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64944: LD_ADDR_VAR 0 8
64948: PUSH
64949: LD_VAR 0 3
64953: PPUSH
64954: LD_INT 3
64956: PPUSH
64957: CALL 61603 0 2
64961: ST_TO_ADDR
// if fac then
64962: LD_VAR 0 8
64966: IFFALSE 65195
// begin for j in fac do
64968: LD_ADDR_VAR 0 4
64972: PUSH
64973: LD_VAR 0 8
64977: PUSH
64978: FOR_IN
64979: IFFALSE 65193
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
64981: LD_ADDR_VAR 0 9
64985: PUSH
64986: LD_VAR 0 8
64990: PPUSH
64991: LD_VAR 0 1
64995: PPUSH
64996: CALL_OW 265
65000: PPUSH
65001: LD_VAR 0 1
65005: PPUSH
65006: CALL_OW 262
65010: PPUSH
65011: LD_VAR 0 1
65015: PPUSH
65016: CALL_OW 263
65020: PPUSH
65021: LD_VAR 0 1
65025: PPUSH
65026: CALL_OW 264
65030: PPUSH
65031: CALL 70171 0 5
65035: ST_TO_ADDR
// if components then
65036: LD_VAR 0 9
65040: IFFALSE 65191
// begin if GetWeapon ( un ) = ar_control_tower then
65042: LD_VAR 0 1
65046: PPUSH
65047: CALL_OW 264
65051: PUSH
65052: LD_INT 31
65054: EQUAL
65055: IFFALSE 65172
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
65057: LD_VAR 0 1
65061: PPUSH
65062: CALL_OW 311
65066: PPUSH
65067: LD_INT 0
65069: PPUSH
65070: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
65074: LD_ADDR_EXP 140
65078: PUSH
65079: LD_EXP 140
65083: PPUSH
65084: LD_VAR 0 3
65088: PPUSH
65089: LD_EXP 140
65093: PUSH
65094: LD_VAR 0 3
65098: ARRAY
65099: PUSH
65100: LD_VAR 0 1
65104: PPUSH
65105: CALL_OW 311
65109: DIFF
65110: PPUSH
65111: CALL_OW 1
65115: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
65116: LD_ADDR_VAR 0 7
65120: PUSH
65121: LD_EXP 121
65125: PUSH
65126: LD_VAR 0 3
65130: ARRAY
65131: PPUSH
65132: LD_INT 1
65134: PPUSH
65135: LD_VAR 0 9
65139: PPUSH
65140: CALL_OW 2
65144: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65145: LD_ADDR_EXP 121
65149: PUSH
65150: LD_EXP 121
65154: PPUSH
65155: LD_VAR 0 3
65159: PPUSH
65160: LD_VAR 0 7
65164: PPUSH
65165: CALL_OW 1
65169: ST_TO_ADDR
// end else
65170: GO 65189
// MC_InsertProduceList ( i , [ components ] ) ;
65172: LD_VAR 0 3
65176: PPUSH
65177: LD_VAR 0 9
65181: PUSH
65182: EMPTY
65183: LIST
65184: PPUSH
65185: CALL 61148 0 2
// break ;
65189: GO 65193
// end ; end ;
65191: GO 64978
65193: POP
65194: POP
// end ; end ; if GetType ( un ) = unit_building then
65195: LD_VAR 0 1
65199: PPUSH
65200: CALL_OW 247
65204: PUSH
65205: LD_INT 3
65207: EQUAL
65208: IFFALSE 65611
// begin btype := GetBType ( un ) ;
65210: LD_ADDR_VAR 0 5
65214: PUSH
65215: LD_VAR 0 1
65219: PPUSH
65220: CALL_OW 266
65224: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
65225: LD_VAR 0 5
65229: PUSH
65230: LD_INT 29
65232: PUSH
65233: LD_INT 30
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: IN
65240: IFFALSE 65313
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
65242: LD_VAR 0 1
65246: PPUSH
65247: CALL_OW 250
65251: PPUSH
65252: LD_VAR 0 1
65256: PPUSH
65257: CALL_OW 251
65261: PPUSH
65262: LD_VAR 0 1
65266: PPUSH
65267: CALL_OW 255
65271: PPUSH
65272: CALL_OW 440
65276: NOT
65277: IFFALSE 65313
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
65279: LD_VAR 0 1
65283: PPUSH
65284: CALL_OW 250
65288: PPUSH
65289: LD_VAR 0 1
65293: PPUSH
65294: CALL_OW 251
65298: PPUSH
65299: LD_VAR 0 1
65303: PPUSH
65304: CALL_OW 255
65308: PPUSH
65309: CALL_OW 441
// end ; if btype = b_warehouse then
65313: LD_VAR 0 5
65317: PUSH
65318: LD_INT 1
65320: EQUAL
65321: IFFALSE 65339
// begin btype := b_depot ;
65323: LD_ADDR_VAR 0 5
65327: PUSH
65328: LD_INT 0
65330: ST_TO_ADDR
// pos := 1 ;
65331: LD_ADDR_VAR 0 6
65335: PUSH
65336: LD_INT 1
65338: ST_TO_ADDR
// end ; if btype = b_factory then
65339: LD_VAR 0 5
65343: PUSH
65344: LD_INT 3
65346: EQUAL
65347: IFFALSE 65365
// begin btype := b_workshop ;
65349: LD_ADDR_VAR 0 5
65353: PUSH
65354: LD_INT 2
65356: ST_TO_ADDR
// pos := 1 ;
65357: LD_ADDR_VAR 0 6
65361: PUSH
65362: LD_INT 1
65364: ST_TO_ADDR
// end ; if btype = b_barracks then
65365: LD_VAR 0 5
65369: PUSH
65370: LD_INT 5
65372: EQUAL
65373: IFFALSE 65383
// btype := b_armoury ;
65375: LD_ADDR_VAR 0 5
65379: PUSH
65380: LD_INT 4
65382: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65383: LD_VAR 0 5
65387: PUSH
65388: LD_INT 7
65390: PUSH
65391: LD_INT 8
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: IN
65398: IFFALSE 65408
// btype := b_lab ;
65400: LD_ADDR_VAR 0 5
65404: PUSH
65405: LD_INT 6
65407: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65408: LD_ADDR_EXP 105
65412: PUSH
65413: LD_EXP 105
65417: PPUSH
65418: LD_VAR 0 3
65422: PUSH
65423: LD_EXP 105
65427: PUSH
65428: LD_VAR 0 3
65432: ARRAY
65433: PUSH
65434: LD_INT 1
65436: PLUS
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: PPUSH
65442: LD_VAR 0 5
65446: PUSH
65447: LD_VAR 0 1
65451: PPUSH
65452: CALL_OW 250
65456: PUSH
65457: LD_VAR 0 1
65461: PPUSH
65462: CALL_OW 251
65466: PUSH
65467: LD_VAR 0 1
65471: PPUSH
65472: CALL_OW 254
65476: PUSH
65477: EMPTY
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: PPUSH
65483: CALL 72673 0 3
65487: ST_TO_ADDR
// if pos = 1 then
65488: LD_VAR 0 6
65492: PUSH
65493: LD_INT 1
65495: EQUAL
65496: IFFALSE 65611
// begin tmp := mc_build_list [ i ] ;
65498: LD_ADDR_VAR 0 7
65502: PUSH
65503: LD_EXP 105
65507: PUSH
65508: LD_VAR 0 3
65512: ARRAY
65513: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65514: LD_VAR 0 7
65518: PPUSH
65519: LD_INT 2
65521: PUSH
65522: LD_INT 30
65524: PUSH
65525: LD_INT 0
65527: PUSH
65528: EMPTY
65529: LIST
65530: LIST
65531: PUSH
65532: LD_INT 30
65534: PUSH
65535: LD_INT 1
65537: PUSH
65538: EMPTY
65539: LIST
65540: LIST
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: LIST
65546: PPUSH
65547: CALL_OW 72
65551: IFFALSE 65561
// pos := 2 ;
65553: LD_ADDR_VAR 0 6
65557: PUSH
65558: LD_INT 2
65560: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65561: LD_ADDR_VAR 0 7
65565: PUSH
65566: LD_VAR 0 7
65570: PPUSH
65571: LD_VAR 0 6
65575: PPUSH
65576: LD_VAR 0 7
65580: PPUSH
65581: CALL 72999 0 3
65585: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65586: LD_ADDR_EXP 105
65590: PUSH
65591: LD_EXP 105
65595: PPUSH
65596: LD_VAR 0 3
65600: PPUSH
65601: LD_VAR 0 7
65605: PPUSH
65606: CALL_OW 1
65610: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65611: LD_VAR 0 1
65615: PUSH
65616: LD_EXP 100
65620: PUSH
65621: LD_VAR 0 3
65625: ARRAY
65626: IN
65627: IFFALSE 65666
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65629: LD_ADDR_EXP 100
65633: PUSH
65634: LD_EXP 100
65638: PPUSH
65639: LD_VAR 0 3
65643: PPUSH
65644: LD_EXP 100
65648: PUSH
65649: LD_VAR 0 3
65653: ARRAY
65654: PUSH
65655: LD_VAR 0 1
65659: DIFF
65660: PPUSH
65661: CALL_OW 1
65665: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65666: LD_VAR 0 1
65670: PUSH
65671: LD_EXP 107
65675: PUSH
65676: LD_VAR 0 3
65680: ARRAY
65681: IN
65682: IFFALSE 65721
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65684: LD_ADDR_EXP 107
65688: PUSH
65689: LD_EXP 107
65693: PPUSH
65694: LD_VAR 0 3
65698: PPUSH
65699: LD_EXP 107
65703: PUSH
65704: LD_VAR 0 3
65708: ARRAY
65709: PUSH
65710: LD_VAR 0 1
65714: DIFF
65715: PPUSH
65716: CALL_OW 1
65720: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65721: LD_VAR 0 1
65725: PUSH
65726: LD_EXP 119
65730: PUSH
65731: LD_VAR 0 3
65735: ARRAY
65736: IN
65737: IFFALSE 65776
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65739: LD_ADDR_EXP 119
65743: PUSH
65744: LD_EXP 119
65748: PPUSH
65749: LD_VAR 0 3
65753: PPUSH
65754: LD_EXP 119
65758: PUSH
65759: LD_VAR 0 3
65763: ARRAY
65764: PUSH
65765: LD_VAR 0 1
65769: DIFF
65770: PPUSH
65771: CALL_OW 1
65775: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65776: LD_VAR 0 1
65780: PUSH
65781: LD_EXP 122
65785: PUSH
65786: LD_VAR 0 3
65790: ARRAY
65791: IN
65792: IFFALSE 65831
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65794: LD_ADDR_EXP 122
65798: PUSH
65799: LD_EXP 122
65803: PPUSH
65804: LD_VAR 0 3
65808: PPUSH
65809: LD_EXP 122
65813: PUSH
65814: LD_VAR 0 3
65818: ARRAY
65819: PUSH
65820: LD_VAR 0 1
65824: DIFF
65825: PPUSH
65826: CALL_OW 1
65830: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65831: LD_VAR 0 1
65835: PUSH
65836: LD_EXP 109
65840: PUSH
65841: LD_VAR 0 3
65845: ARRAY
65846: IN
65847: IFFALSE 65886
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65849: LD_ADDR_EXP 109
65853: PUSH
65854: LD_EXP 109
65858: PPUSH
65859: LD_VAR 0 3
65863: PPUSH
65864: LD_EXP 109
65868: PUSH
65869: LD_VAR 0 3
65873: ARRAY
65874: PUSH
65875: LD_VAR 0 1
65879: DIFF
65880: PPUSH
65881: CALL_OW 1
65885: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65886: LD_VAR 0 1
65890: PUSH
65891: LD_EXP 108
65895: PUSH
65896: LD_VAR 0 3
65900: ARRAY
65901: IN
65902: IFFALSE 65941
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65904: LD_ADDR_EXP 108
65908: PUSH
65909: LD_EXP 108
65913: PPUSH
65914: LD_VAR 0 3
65918: PPUSH
65919: LD_EXP 108
65923: PUSH
65924: LD_VAR 0 3
65928: ARRAY
65929: PUSH
65930: LD_VAR 0 1
65934: DIFF
65935: PPUSH
65936: CALL_OW 1
65940: ST_TO_ADDR
// end ; break ;
65941: GO 65945
// end ;
65943: GO 64593
65945: POP
65946: POP
// end ;
65947: LD_VAR 0 2
65951: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65952: LD_INT 0
65954: PPUSH
65955: PPUSH
65956: PPUSH
// if not mc_bases or not skirmish then
65957: LD_EXP 100
65961: NOT
65962: PUSH
65963: LD_EXP 98
65967: NOT
65968: OR
65969: IFFALSE 65973
// exit ;
65971: GO 66188
// for i = 1 to mc_bases do
65973: LD_ADDR_VAR 0 3
65977: PUSH
65978: DOUBLE
65979: LD_INT 1
65981: DEC
65982: ST_TO_ADDR
65983: LD_EXP 100
65987: PUSH
65988: FOR_TO
65989: IFFALSE 66186
// begin if building in mc_construct_list [ i ] then
65991: LD_VAR 0 1
65995: PUSH
65996: LD_EXP 107
66000: PUSH
66001: LD_VAR 0 3
66005: ARRAY
66006: IN
66007: IFFALSE 66184
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66009: LD_ADDR_EXP 107
66013: PUSH
66014: LD_EXP 107
66018: PPUSH
66019: LD_VAR 0 3
66023: PPUSH
66024: LD_EXP 107
66028: PUSH
66029: LD_VAR 0 3
66033: ARRAY
66034: PUSH
66035: LD_VAR 0 1
66039: DIFF
66040: PPUSH
66041: CALL_OW 1
66045: ST_TO_ADDR
// if building in mc_lab [ i ] then
66046: LD_VAR 0 1
66050: PUSH
66051: LD_EXP 133
66055: PUSH
66056: LD_VAR 0 3
66060: ARRAY
66061: IN
66062: IFFALSE 66117
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
66064: LD_ADDR_EXP 134
66068: PUSH
66069: LD_EXP 134
66073: PPUSH
66074: LD_VAR 0 3
66078: PPUSH
66079: LD_EXP 134
66083: PUSH
66084: LD_VAR 0 3
66088: ARRAY
66089: PPUSH
66090: LD_INT 1
66092: PPUSH
66093: LD_EXP 134
66097: PUSH
66098: LD_VAR 0 3
66102: ARRAY
66103: PPUSH
66104: LD_INT 0
66106: PPUSH
66107: CALL 72091 0 4
66111: PPUSH
66112: CALL_OW 1
66116: ST_TO_ADDR
// if not building in mc_bases [ i ] then
66117: LD_VAR 0 1
66121: PUSH
66122: LD_EXP 100
66126: PUSH
66127: LD_VAR 0 3
66131: ARRAY
66132: IN
66133: NOT
66134: IFFALSE 66180
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66136: LD_ADDR_EXP 100
66140: PUSH
66141: LD_EXP 100
66145: PPUSH
66146: LD_VAR 0 3
66150: PUSH
66151: LD_EXP 100
66155: PUSH
66156: LD_VAR 0 3
66160: ARRAY
66161: PUSH
66162: LD_INT 1
66164: PLUS
66165: PUSH
66166: EMPTY
66167: LIST
66168: LIST
66169: PPUSH
66170: LD_VAR 0 1
66174: PPUSH
66175: CALL 72673 0 3
66179: ST_TO_ADDR
// exit ;
66180: POP
66181: POP
66182: GO 66188
// end ; end ;
66184: GO 65988
66186: POP
66187: POP
// end ;
66188: LD_VAR 0 2
66192: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
66193: LD_INT 0
66195: PPUSH
66196: PPUSH
66197: PPUSH
66198: PPUSH
66199: PPUSH
66200: PPUSH
66201: PPUSH
// if not mc_bases or not skirmish then
66202: LD_EXP 100
66206: NOT
66207: PUSH
66208: LD_EXP 98
66212: NOT
66213: OR
66214: IFFALSE 66218
// exit ;
66216: GO 66879
// for i = 1 to mc_bases do
66218: LD_ADDR_VAR 0 3
66222: PUSH
66223: DOUBLE
66224: LD_INT 1
66226: DEC
66227: ST_TO_ADDR
66228: LD_EXP 100
66232: PUSH
66233: FOR_TO
66234: IFFALSE 66877
// begin if building in mc_construct_list [ i ] then
66236: LD_VAR 0 1
66240: PUSH
66241: LD_EXP 107
66245: PUSH
66246: LD_VAR 0 3
66250: ARRAY
66251: IN
66252: IFFALSE 66875
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66254: LD_ADDR_EXP 107
66258: PUSH
66259: LD_EXP 107
66263: PPUSH
66264: LD_VAR 0 3
66268: PPUSH
66269: LD_EXP 107
66273: PUSH
66274: LD_VAR 0 3
66278: ARRAY
66279: PUSH
66280: LD_VAR 0 1
66284: DIFF
66285: PPUSH
66286: CALL_OW 1
66290: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66291: LD_ADDR_EXP 100
66295: PUSH
66296: LD_EXP 100
66300: PPUSH
66301: LD_VAR 0 3
66305: PUSH
66306: LD_EXP 100
66310: PUSH
66311: LD_VAR 0 3
66315: ARRAY
66316: PUSH
66317: LD_INT 1
66319: PLUS
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PPUSH
66325: LD_VAR 0 1
66329: PPUSH
66330: CALL 72673 0 3
66334: ST_TO_ADDR
// btype := GetBType ( building ) ;
66335: LD_ADDR_VAR 0 5
66339: PUSH
66340: LD_VAR 0 1
66344: PPUSH
66345: CALL_OW 266
66349: ST_TO_ADDR
// side := GetSide ( building ) ;
66350: LD_ADDR_VAR 0 8
66354: PUSH
66355: LD_VAR 0 1
66359: PPUSH
66360: CALL_OW 255
66364: ST_TO_ADDR
// if btype = b_lab then
66365: LD_VAR 0 5
66369: PUSH
66370: LD_INT 6
66372: EQUAL
66373: IFFALSE 66423
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66375: LD_ADDR_EXP 133
66379: PUSH
66380: LD_EXP 133
66384: PPUSH
66385: LD_VAR 0 3
66389: PUSH
66390: LD_EXP 133
66394: PUSH
66395: LD_VAR 0 3
66399: ARRAY
66400: PUSH
66401: LD_INT 1
66403: PLUS
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PPUSH
66409: LD_VAR 0 1
66413: PPUSH
66414: CALL 72673 0 3
66418: ST_TO_ADDR
// exit ;
66419: POP
66420: POP
66421: GO 66879
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66423: LD_VAR 0 5
66427: PUSH
66428: LD_INT 0
66430: PUSH
66431: LD_INT 2
66433: PUSH
66434: LD_INT 4
66436: PUSH
66437: EMPTY
66438: LIST
66439: LIST
66440: LIST
66441: IN
66442: IFFALSE 66566
// begin if btype = b_armoury then
66444: LD_VAR 0 5
66448: PUSH
66449: LD_INT 4
66451: EQUAL
66452: IFFALSE 66462
// btype := b_barracks ;
66454: LD_ADDR_VAR 0 5
66458: PUSH
66459: LD_INT 5
66461: ST_TO_ADDR
// if btype = b_depot then
66462: LD_VAR 0 5
66466: PUSH
66467: LD_INT 0
66469: EQUAL
66470: IFFALSE 66480
// btype := b_warehouse ;
66472: LD_ADDR_VAR 0 5
66476: PUSH
66477: LD_INT 1
66479: ST_TO_ADDR
// if btype = b_workshop then
66480: LD_VAR 0 5
66484: PUSH
66485: LD_INT 2
66487: EQUAL
66488: IFFALSE 66498
// btype := b_factory ;
66490: LD_ADDR_VAR 0 5
66494: PUSH
66495: LD_INT 3
66497: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66498: LD_VAR 0 5
66502: PPUSH
66503: LD_VAR 0 8
66507: PPUSH
66508: CALL_OW 323
66512: PUSH
66513: LD_INT 1
66515: EQUAL
66516: IFFALSE 66562
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66518: LD_ADDR_EXP 132
66522: PUSH
66523: LD_EXP 132
66527: PPUSH
66528: LD_VAR 0 3
66532: PUSH
66533: LD_EXP 132
66537: PUSH
66538: LD_VAR 0 3
66542: ARRAY
66543: PUSH
66544: LD_INT 1
66546: PLUS
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PPUSH
66552: LD_VAR 0 1
66556: PPUSH
66557: CALL 72673 0 3
66561: ST_TO_ADDR
// exit ;
66562: POP
66563: POP
66564: GO 66879
// end ; if btype in [ b_bunker , b_turret ] then
66566: LD_VAR 0 5
66570: PUSH
66571: LD_INT 32
66573: PUSH
66574: LD_INT 33
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: IN
66581: IFFALSE 66871
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66583: LD_ADDR_EXP 108
66587: PUSH
66588: LD_EXP 108
66592: PPUSH
66593: LD_VAR 0 3
66597: PUSH
66598: LD_EXP 108
66602: PUSH
66603: LD_VAR 0 3
66607: ARRAY
66608: PUSH
66609: LD_INT 1
66611: PLUS
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PPUSH
66617: LD_VAR 0 1
66621: PPUSH
66622: CALL 72673 0 3
66626: ST_TO_ADDR
// if btype = b_bunker then
66627: LD_VAR 0 5
66631: PUSH
66632: LD_INT 32
66634: EQUAL
66635: IFFALSE 66871
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66637: LD_ADDR_EXP 109
66641: PUSH
66642: LD_EXP 109
66646: PPUSH
66647: LD_VAR 0 3
66651: PUSH
66652: LD_EXP 109
66656: PUSH
66657: LD_VAR 0 3
66661: ARRAY
66662: PUSH
66663: LD_INT 1
66665: PLUS
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PPUSH
66671: LD_VAR 0 1
66675: PPUSH
66676: CALL 72673 0 3
66680: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66681: LD_ADDR_VAR 0 6
66685: PUSH
66686: LD_EXP 100
66690: PUSH
66691: LD_VAR 0 3
66695: ARRAY
66696: PPUSH
66697: LD_INT 25
66699: PUSH
66700: LD_INT 1
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: LD_INT 3
66709: PUSH
66710: LD_INT 54
66712: PUSH
66713: EMPTY
66714: LIST
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: EMPTY
66721: LIST
66722: LIST
66723: PPUSH
66724: CALL_OW 72
66728: ST_TO_ADDR
// if tmp then
66729: LD_VAR 0 6
66733: IFFALSE 66739
// exit ;
66735: POP
66736: POP
66737: GO 66879
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66739: LD_ADDR_VAR 0 6
66743: PUSH
66744: LD_EXP 100
66748: PUSH
66749: LD_VAR 0 3
66753: ARRAY
66754: PPUSH
66755: LD_INT 2
66757: PUSH
66758: LD_INT 30
66760: PUSH
66761: LD_INT 4
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: LD_INT 30
66770: PUSH
66771: LD_INT 5
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: LIST
66782: PPUSH
66783: CALL_OW 72
66787: ST_TO_ADDR
// if not tmp then
66788: LD_VAR 0 6
66792: NOT
66793: IFFALSE 66799
// exit ;
66795: POP
66796: POP
66797: GO 66879
// for j in tmp do
66799: LD_ADDR_VAR 0 4
66803: PUSH
66804: LD_VAR 0 6
66808: PUSH
66809: FOR_IN
66810: IFFALSE 66869
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66812: LD_ADDR_VAR 0 7
66816: PUSH
66817: LD_VAR 0 4
66821: PPUSH
66822: CALL_OW 313
66826: PPUSH
66827: LD_INT 25
66829: PUSH
66830: LD_INT 1
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PPUSH
66837: CALL_OW 72
66841: ST_TO_ADDR
// if units then
66842: LD_VAR 0 7
66846: IFFALSE 66867
// begin ComExitBuilding ( units [ 1 ] ) ;
66848: LD_VAR 0 7
66852: PUSH
66853: LD_INT 1
66855: ARRAY
66856: PPUSH
66857: CALL_OW 122
// exit ;
66861: POP
66862: POP
66863: POP
66864: POP
66865: GO 66879
// end ; end ;
66867: GO 66809
66869: POP
66870: POP
// end ; end ; exit ;
66871: POP
66872: POP
66873: GO 66879
// end ; end ;
66875: GO 66233
66877: POP
66878: POP
// end ;
66879: LD_VAR 0 2
66883: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66884: LD_INT 0
66886: PPUSH
66887: PPUSH
66888: PPUSH
66889: PPUSH
66890: PPUSH
66891: PPUSH
66892: PPUSH
// if not mc_bases or not skirmish then
66893: LD_EXP 100
66897: NOT
66898: PUSH
66899: LD_EXP 98
66903: NOT
66904: OR
66905: IFFALSE 66909
// exit ;
66907: GO 67174
// btype := GetBType ( building ) ;
66909: LD_ADDR_VAR 0 6
66913: PUSH
66914: LD_VAR 0 1
66918: PPUSH
66919: CALL_OW 266
66923: ST_TO_ADDR
// x := GetX ( building ) ;
66924: LD_ADDR_VAR 0 7
66928: PUSH
66929: LD_VAR 0 1
66933: PPUSH
66934: CALL_OW 250
66938: ST_TO_ADDR
// y := GetY ( building ) ;
66939: LD_ADDR_VAR 0 8
66943: PUSH
66944: LD_VAR 0 1
66948: PPUSH
66949: CALL_OW 251
66953: ST_TO_ADDR
// d := GetDir ( building ) ;
66954: LD_ADDR_VAR 0 9
66958: PUSH
66959: LD_VAR 0 1
66963: PPUSH
66964: CALL_OW 254
66968: ST_TO_ADDR
// for i = 1 to mc_bases do
66969: LD_ADDR_VAR 0 4
66973: PUSH
66974: DOUBLE
66975: LD_INT 1
66977: DEC
66978: ST_TO_ADDR
66979: LD_EXP 100
66983: PUSH
66984: FOR_TO
66985: IFFALSE 67172
// begin if not mc_build_list [ i ] then
66987: LD_EXP 105
66991: PUSH
66992: LD_VAR 0 4
66996: ARRAY
66997: NOT
66998: IFFALSE 67002
// continue ;
67000: GO 66984
// for j := 1 to mc_build_list [ i ] do
67002: LD_ADDR_VAR 0 5
67006: PUSH
67007: DOUBLE
67008: LD_INT 1
67010: DEC
67011: ST_TO_ADDR
67012: LD_EXP 105
67016: PUSH
67017: LD_VAR 0 4
67021: ARRAY
67022: PUSH
67023: FOR_TO
67024: IFFALSE 67168
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
67026: LD_VAR 0 6
67030: PUSH
67031: LD_VAR 0 7
67035: PUSH
67036: LD_VAR 0 8
67040: PUSH
67041: LD_VAR 0 9
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: PPUSH
67052: LD_EXP 105
67056: PUSH
67057: LD_VAR 0 4
67061: ARRAY
67062: PUSH
67063: LD_VAR 0 5
67067: ARRAY
67068: PPUSH
67069: CALL 78853 0 2
67073: IFFALSE 67166
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
67075: LD_ADDR_EXP 105
67079: PUSH
67080: LD_EXP 105
67084: PPUSH
67085: LD_VAR 0 4
67089: PPUSH
67090: LD_EXP 105
67094: PUSH
67095: LD_VAR 0 4
67099: ARRAY
67100: PPUSH
67101: LD_VAR 0 5
67105: PPUSH
67106: CALL_OW 3
67110: PPUSH
67111: CALL_OW 1
67115: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
67116: LD_ADDR_EXP 107
67120: PUSH
67121: LD_EXP 107
67125: PPUSH
67126: LD_VAR 0 4
67130: PUSH
67131: LD_EXP 107
67135: PUSH
67136: LD_VAR 0 4
67140: ARRAY
67141: PUSH
67142: LD_INT 1
67144: PLUS
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PPUSH
67150: LD_VAR 0 1
67154: PPUSH
67155: CALL 72673 0 3
67159: ST_TO_ADDR
// exit ;
67160: POP
67161: POP
67162: POP
67163: POP
67164: GO 67174
// end ;
67166: GO 67023
67168: POP
67169: POP
// end ;
67170: GO 66984
67172: POP
67173: POP
// end ;
67174: LD_VAR 0 3
67178: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
67179: LD_INT 0
67181: PPUSH
67182: PPUSH
67183: PPUSH
// if not mc_bases or not skirmish then
67184: LD_EXP 100
67188: NOT
67189: PUSH
67190: LD_EXP 98
67194: NOT
67195: OR
67196: IFFALSE 67200
// exit ;
67198: GO 67390
// for i = 1 to mc_bases do
67200: LD_ADDR_VAR 0 4
67204: PUSH
67205: DOUBLE
67206: LD_INT 1
67208: DEC
67209: ST_TO_ADDR
67210: LD_EXP 100
67214: PUSH
67215: FOR_TO
67216: IFFALSE 67303
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
67218: LD_VAR 0 1
67222: PUSH
67223: LD_EXP 108
67227: PUSH
67228: LD_VAR 0 4
67232: ARRAY
67233: IN
67234: PUSH
67235: LD_VAR 0 1
67239: PUSH
67240: LD_EXP 109
67244: PUSH
67245: LD_VAR 0 4
67249: ARRAY
67250: IN
67251: NOT
67252: AND
67253: IFFALSE 67301
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67255: LD_ADDR_EXP 109
67259: PUSH
67260: LD_EXP 109
67264: PPUSH
67265: LD_VAR 0 4
67269: PUSH
67270: LD_EXP 109
67274: PUSH
67275: LD_VAR 0 4
67279: ARRAY
67280: PUSH
67281: LD_INT 1
67283: PLUS
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: PPUSH
67289: LD_VAR 0 1
67293: PPUSH
67294: CALL 72673 0 3
67298: ST_TO_ADDR
// break ;
67299: GO 67303
// end ; end ;
67301: GO 67215
67303: POP
67304: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67305: LD_VAR 0 1
67309: PPUSH
67310: CALL_OW 257
67314: PUSH
67315: LD_EXP 126
67319: IN
67320: PUSH
67321: LD_VAR 0 1
67325: PPUSH
67326: CALL_OW 266
67330: PUSH
67331: LD_INT 5
67333: EQUAL
67334: AND
67335: PUSH
67336: LD_VAR 0 2
67340: PPUSH
67341: CALL_OW 110
67345: PUSH
67346: LD_INT 18
67348: NONEQUAL
67349: AND
67350: IFFALSE 67390
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67352: LD_VAR 0 2
67356: PPUSH
67357: CALL_OW 257
67361: PUSH
67362: LD_INT 5
67364: PUSH
67365: LD_INT 8
67367: PUSH
67368: LD_INT 9
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: LIST
67375: IN
67376: IFFALSE 67390
// SetClass ( unit , 1 ) ;
67378: LD_VAR 0 2
67382: PPUSH
67383: LD_INT 1
67385: PPUSH
67386: CALL_OW 336
// end ;
67390: LD_VAR 0 3
67394: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67395: LD_INT 0
67397: PPUSH
67398: PPUSH
// if not mc_bases or not skirmish then
67399: LD_EXP 100
67403: NOT
67404: PUSH
67405: LD_EXP 98
67409: NOT
67410: OR
67411: IFFALSE 67415
// exit ;
67413: GO 67531
// if GetLives ( abandoned_vehicle ) > 250 then
67415: LD_VAR 0 2
67419: PPUSH
67420: CALL_OW 256
67424: PUSH
67425: LD_INT 250
67427: GREATER
67428: IFFALSE 67432
// exit ;
67430: GO 67531
// for i = 1 to mc_bases do
67432: LD_ADDR_VAR 0 6
67436: PUSH
67437: DOUBLE
67438: LD_INT 1
67440: DEC
67441: ST_TO_ADDR
67442: LD_EXP 100
67446: PUSH
67447: FOR_TO
67448: IFFALSE 67529
// begin if driver in mc_bases [ i ] then
67450: LD_VAR 0 1
67454: PUSH
67455: LD_EXP 100
67459: PUSH
67460: LD_VAR 0 6
67464: ARRAY
67465: IN
67466: IFFALSE 67527
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67468: LD_VAR 0 1
67472: PPUSH
67473: LD_EXP 100
67477: PUSH
67478: LD_VAR 0 6
67482: ARRAY
67483: PPUSH
67484: LD_INT 2
67486: PUSH
67487: LD_INT 30
67489: PUSH
67490: LD_INT 0
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 30
67499: PUSH
67500: LD_INT 1
67502: PUSH
67503: EMPTY
67504: LIST
67505: LIST
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: LIST
67511: PPUSH
67512: CALL_OW 72
67516: PUSH
67517: LD_INT 1
67519: ARRAY
67520: PPUSH
67521: CALL 105862 0 2
// break ;
67525: GO 67529
// end ; end ;
67527: GO 67447
67529: POP
67530: POP
// end ; end_of_file
67531: LD_VAR 0 5
67535: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67536: LD_INT 0
67538: PPUSH
67539: PPUSH
// if exist_mode then
67540: LD_VAR 0 2
67544: IFFALSE 67569
// unit := CreateCharacter ( prefix & ident ) else
67546: LD_ADDR_VAR 0 5
67550: PUSH
67551: LD_VAR 0 3
67555: PUSH
67556: LD_VAR 0 1
67560: STR
67561: PPUSH
67562: CALL_OW 34
67566: ST_TO_ADDR
67567: GO 67584
// unit := NewCharacter ( ident ) ;
67569: LD_ADDR_VAR 0 5
67573: PUSH
67574: LD_VAR 0 1
67578: PPUSH
67579: CALL_OW 25
67583: ST_TO_ADDR
// result := unit ;
67584: LD_ADDR_VAR 0 4
67588: PUSH
67589: LD_VAR 0 5
67593: ST_TO_ADDR
// end ;
67594: LD_VAR 0 4
67598: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67599: LD_INT 0
67601: PPUSH
67602: PPUSH
// if not side or not nation then
67603: LD_VAR 0 1
67607: NOT
67608: PUSH
67609: LD_VAR 0 2
67613: NOT
67614: OR
67615: IFFALSE 67619
// exit ;
67617: GO 68387
// case nation of nation_american :
67619: LD_VAR 0 2
67623: PUSH
67624: LD_INT 1
67626: DOUBLE
67627: EQUAL
67628: IFTRUE 67632
67630: GO 67846
67632: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67633: LD_ADDR_VAR 0 4
67637: PUSH
67638: LD_INT 35
67640: PUSH
67641: LD_INT 45
67643: PUSH
67644: LD_INT 46
67646: PUSH
67647: LD_INT 47
67649: PUSH
67650: LD_INT 82
67652: PUSH
67653: LD_INT 83
67655: PUSH
67656: LD_INT 84
67658: PUSH
67659: LD_INT 85
67661: PUSH
67662: LD_INT 86
67664: PUSH
67665: LD_INT 1
67667: PUSH
67668: LD_INT 2
67670: PUSH
67671: LD_INT 6
67673: PUSH
67674: LD_INT 15
67676: PUSH
67677: LD_INT 16
67679: PUSH
67680: LD_INT 7
67682: PUSH
67683: LD_INT 12
67685: PUSH
67686: LD_INT 13
67688: PUSH
67689: LD_INT 10
67691: PUSH
67692: LD_INT 14
67694: PUSH
67695: LD_INT 20
67697: PUSH
67698: LD_INT 21
67700: PUSH
67701: LD_INT 22
67703: PUSH
67704: LD_INT 25
67706: PUSH
67707: LD_INT 32
67709: PUSH
67710: LD_INT 27
67712: PUSH
67713: LD_INT 36
67715: PUSH
67716: LD_INT 69
67718: PUSH
67719: LD_INT 39
67721: PUSH
67722: LD_INT 34
67724: PUSH
67725: LD_INT 40
67727: PUSH
67728: LD_INT 48
67730: PUSH
67731: LD_INT 49
67733: PUSH
67734: LD_INT 50
67736: PUSH
67737: LD_INT 51
67739: PUSH
67740: LD_INT 52
67742: PUSH
67743: LD_INT 53
67745: PUSH
67746: LD_INT 54
67748: PUSH
67749: LD_INT 55
67751: PUSH
67752: LD_INT 56
67754: PUSH
67755: LD_INT 57
67757: PUSH
67758: LD_INT 58
67760: PUSH
67761: LD_INT 59
67763: PUSH
67764: LD_INT 60
67766: PUSH
67767: LD_INT 61
67769: PUSH
67770: LD_INT 62
67772: PUSH
67773: LD_INT 80
67775: PUSH
67776: LD_INT 82
67778: PUSH
67779: LD_INT 83
67781: PUSH
67782: LD_INT 84
67784: PUSH
67785: LD_INT 85
67787: PUSH
67788: LD_INT 86
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: LIST
67810: LIST
67811: LIST
67812: LIST
67813: LIST
67814: LIST
67815: LIST
67816: LIST
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: LIST
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: ST_TO_ADDR
67844: GO 68311
67846: LD_INT 2
67848: DOUBLE
67849: EQUAL
67850: IFTRUE 67854
67852: GO 68080
67854: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67855: LD_ADDR_VAR 0 4
67859: PUSH
67860: LD_INT 35
67862: PUSH
67863: LD_INT 45
67865: PUSH
67866: LD_INT 46
67868: PUSH
67869: LD_INT 47
67871: PUSH
67872: LD_INT 82
67874: PUSH
67875: LD_INT 83
67877: PUSH
67878: LD_INT 84
67880: PUSH
67881: LD_INT 85
67883: PUSH
67884: LD_INT 87
67886: PUSH
67887: LD_INT 70
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: LD_INT 11
67895: PUSH
67896: LD_INT 3
67898: PUSH
67899: LD_INT 4
67901: PUSH
67902: LD_INT 5
67904: PUSH
67905: LD_INT 6
67907: PUSH
67908: LD_INT 15
67910: PUSH
67911: LD_INT 18
67913: PUSH
67914: LD_INT 7
67916: PUSH
67917: LD_INT 17
67919: PUSH
67920: LD_INT 8
67922: PUSH
67923: LD_INT 20
67925: PUSH
67926: LD_INT 21
67928: PUSH
67929: LD_INT 22
67931: PUSH
67932: LD_INT 72
67934: PUSH
67935: LD_INT 26
67937: PUSH
67938: LD_INT 69
67940: PUSH
67941: LD_INT 39
67943: PUSH
67944: LD_INT 40
67946: PUSH
67947: LD_INT 41
67949: PUSH
67950: LD_INT 42
67952: PUSH
67953: LD_INT 43
67955: PUSH
67956: LD_INT 48
67958: PUSH
67959: LD_INT 49
67961: PUSH
67962: LD_INT 50
67964: PUSH
67965: LD_INT 51
67967: PUSH
67968: LD_INT 52
67970: PUSH
67971: LD_INT 53
67973: PUSH
67974: LD_INT 54
67976: PUSH
67977: LD_INT 55
67979: PUSH
67980: LD_INT 56
67982: PUSH
67983: LD_INT 60
67985: PUSH
67986: LD_INT 61
67988: PUSH
67989: LD_INT 62
67991: PUSH
67992: LD_INT 66
67994: PUSH
67995: LD_INT 67
67997: PUSH
67998: LD_INT 68
68000: PUSH
68001: LD_INT 81
68003: PUSH
68004: LD_INT 82
68006: PUSH
68007: LD_INT 83
68009: PUSH
68010: LD_INT 84
68012: PUSH
68013: LD_INT 85
68015: PUSH
68016: LD_INT 87
68018: PUSH
68019: LD_INT 88
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: ST_TO_ADDR
68078: GO 68311
68080: LD_INT 3
68082: DOUBLE
68083: EQUAL
68084: IFTRUE 68088
68086: GO 68310
68088: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
68089: LD_ADDR_VAR 0 4
68093: PUSH
68094: LD_INT 46
68096: PUSH
68097: LD_INT 47
68099: PUSH
68100: LD_INT 1
68102: PUSH
68103: LD_INT 2
68105: PUSH
68106: LD_INT 82
68108: PUSH
68109: LD_INT 83
68111: PUSH
68112: LD_INT 84
68114: PUSH
68115: LD_INT 85
68117: PUSH
68118: LD_INT 86
68120: PUSH
68121: LD_INT 11
68123: PUSH
68124: LD_INT 9
68126: PUSH
68127: LD_INT 20
68129: PUSH
68130: LD_INT 19
68132: PUSH
68133: LD_INT 21
68135: PUSH
68136: LD_INT 24
68138: PUSH
68139: LD_INT 22
68141: PUSH
68142: LD_INT 25
68144: PUSH
68145: LD_INT 28
68147: PUSH
68148: LD_INT 29
68150: PUSH
68151: LD_INT 30
68153: PUSH
68154: LD_INT 31
68156: PUSH
68157: LD_INT 37
68159: PUSH
68160: LD_INT 38
68162: PUSH
68163: LD_INT 32
68165: PUSH
68166: LD_INT 27
68168: PUSH
68169: LD_INT 33
68171: PUSH
68172: LD_INT 69
68174: PUSH
68175: LD_INT 39
68177: PUSH
68178: LD_INT 34
68180: PUSH
68181: LD_INT 40
68183: PUSH
68184: LD_INT 71
68186: PUSH
68187: LD_INT 23
68189: PUSH
68190: LD_INT 44
68192: PUSH
68193: LD_INT 48
68195: PUSH
68196: LD_INT 49
68198: PUSH
68199: LD_INT 50
68201: PUSH
68202: LD_INT 51
68204: PUSH
68205: LD_INT 52
68207: PUSH
68208: LD_INT 53
68210: PUSH
68211: LD_INT 54
68213: PUSH
68214: LD_INT 55
68216: PUSH
68217: LD_INT 56
68219: PUSH
68220: LD_INT 57
68222: PUSH
68223: LD_INT 58
68225: PUSH
68226: LD_INT 59
68228: PUSH
68229: LD_INT 63
68231: PUSH
68232: LD_INT 64
68234: PUSH
68235: LD_INT 65
68237: PUSH
68238: LD_INT 82
68240: PUSH
68241: LD_INT 83
68243: PUSH
68244: LD_INT 84
68246: PUSH
68247: LD_INT 85
68249: PUSH
68250: LD_INT 86
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: LIST
68257: LIST
68258: LIST
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: ST_TO_ADDR
68308: GO 68311
68310: POP
// if state > - 1 and state < 3 then
68311: LD_VAR 0 3
68315: PUSH
68316: LD_INT 1
68318: NEG
68319: GREATER
68320: PUSH
68321: LD_VAR 0 3
68325: PUSH
68326: LD_INT 3
68328: LESS
68329: AND
68330: IFFALSE 68387
// for i in result do
68332: LD_ADDR_VAR 0 5
68336: PUSH
68337: LD_VAR 0 4
68341: PUSH
68342: FOR_IN
68343: IFFALSE 68385
// if GetTech ( i , side ) <> state then
68345: LD_VAR 0 5
68349: PPUSH
68350: LD_VAR 0 1
68354: PPUSH
68355: CALL_OW 321
68359: PUSH
68360: LD_VAR 0 3
68364: NONEQUAL
68365: IFFALSE 68383
// result := result diff i ;
68367: LD_ADDR_VAR 0 4
68371: PUSH
68372: LD_VAR 0 4
68376: PUSH
68377: LD_VAR 0 5
68381: DIFF
68382: ST_TO_ADDR
68383: GO 68342
68385: POP
68386: POP
// end ;
68387: LD_VAR 0 4
68391: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68392: LD_INT 0
68394: PPUSH
68395: PPUSH
68396: PPUSH
// result := true ;
68397: LD_ADDR_VAR 0 3
68401: PUSH
68402: LD_INT 1
68404: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68405: LD_ADDR_VAR 0 5
68409: PUSH
68410: LD_VAR 0 2
68414: PPUSH
68415: CALL_OW 480
68419: ST_TO_ADDR
// if not tmp then
68420: LD_VAR 0 5
68424: NOT
68425: IFFALSE 68429
// exit ;
68427: GO 68478
// for i in tmp do
68429: LD_ADDR_VAR 0 4
68433: PUSH
68434: LD_VAR 0 5
68438: PUSH
68439: FOR_IN
68440: IFFALSE 68476
// if GetTech ( i , side ) <> state_researched then
68442: LD_VAR 0 4
68446: PPUSH
68447: LD_VAR 0 1
68451: PPUSH
68452: CALL_OW 321
68456: PUSH
68457: LD_INT 2
68459: NONEQUAL
68460: IFFALSE 68474
// begin result := false ;
68462: LD_ADDR_VAR 0 3
68466: PUSH
68467: LD_INT 0
68469: ST_TO_ADDR
// exit ;
68470: POP
68471: POP
68472: GO 68478
// end ;
68474: GO 68439
68476: POP
68477: POP
// end ;
68478: LD_VAR 0 3
68482: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68483: LD_INT 0
68485: PPUSH
68486: PPUSH
68487: PPUSH
68488: PPUSH
68489: PPUSH
68490: PPUSH
68491: PPUSH
68492: PPUSH
68493: PPUSH
68494: PPUSH
68495: PPUSH
68496: PPUSH
68497: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68498: LD_VAR 0 1
68502: NOT
68503: PUSH
68504: LD_VAR 0 1
68508: PPUSH
68509: CALL_OW 257
68513: PUSH
68514: LD_INT 9
68516: NONEQUAL
68517: OR
68518: IFFALSE 68522
// exit ;
68520: GO 69095
// side := GetSide ( unit ) ;
68522: LD_ADDR_VAR 0 9
68526: PUSH
68527: LD_VAR 0 1
68531: PPUSH
68532: CALL_OW 255
68536: ST_TO_ADDR
// tech_space := tech_spacanom ;
68537: LD_ADDR_VAR 0 12
68541: PUSH
68542: LD_INT 29
68544: ST_TO_ADDR
// tech_time := tech_taurad ;
68545: LD_ADDR_VAR 0 13
68549: PUSH
68550: LD_INT 28
68552: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68553: LD_ADDR_VAR 0 11
68557: PUSH
68558: LD_VAR 0 1
68562: PPUSH
68563: CALL_OW 310
68567: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68568: LD_VAR 0 11
68572: PPUSH
68573: CALL_OW 247
68577: PUSH
68578: LD_INT 2
68580: EQUAL
68581: IFFALSE 68585
// exit ;
68583: GO 69095
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68585: LD_ADDR_VAR 0 8
68589: PUSH
68590: LD_INT 81
68592: PUSH
68593: LD_VAR 0 9
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 3
68604: PUSH
68605: LD_INT 21
68607: PUSH
68608: LD_INT 3
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PPUSH
68623: CALL_OW 69
68627: ST_TO_ADDR
// if not tmp then
68628: LD_VAR 0 8
68632: NOT
68633: IFFALSE 68637
// exit ;
68635: GO 69095
// if in_unit then
68637: LD_VAR 0 11
68641: IFFALSE 68665
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68643: LD_ADDR_VAR 0 10
68647: PUSH
68648: LD_VAR 0 8
68652: PPUSH
68653: LD_VAR 0 11
68657: PPUSH
68658: CALL_OW 74
68662: ST_TO_ADDR
68663: GO 68685
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68665: LD_ADDR_VAR 0 10
68669: PUSH
68670: LD_VAR 0 8
68674: PPUSH
68675: LD_VAR 0 1
68679: PPUSH
68680: CALL_OW 74
68684: ST_TO_ADDR
// if not enemy then
68685: LD_VAR 0 10
68689: NOT
68690: IFFALSE 68694
// exit ;
68692: GO 69095
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68694: LD_VAR 0 11
68698: PUSH
68699: LD_VAR 0 11
68703: PPUSH
68704: LD_VAR 0 10
68708: PPUSH
68709: CALL_OW 296
68713: PUSH
68714: LD_INT 13
68716: GREATER
68717: AND
68718: PUSH
68719: LD_VAR 0 1
68723: PPUSH
68724: LD_VAR 0 10
68728: PPUSH
68729: CALL_OW 296
68733: PUSH
68734: LD_INT 12
68736: GREATER
68737: OR
68738: IFFALSE 68742
// exit ;
68740: GO 69095
// missile := [ 1 ] ;
68742: LD_ADDR_VAR 0 14
68746: PUSH
68747: LD_INT 1
68749: PUSH
68750: EMPTY
68751: LIST
68752: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68753: LD_VAR 0 9
68757: PPUSH
68758: LD_VAR 0 12
68762: PPUSH
68763: CALL_OW 325
68767: IFFALSE 68796
// missile := Replace ( missile , missile + 1 , 2 ) ;
68769: LD_ADDR_VAR 0 14
68773: PUSH
68774: LD_VAR 0 14
68778: PPUSH
68779: LD_VAR 0 14
68783: PUSH
68784: LD_INT 1
68786: PLUS
68787: PPUSH
68788: LD_INT 2
68790: PPUSH
68791: CALL_OW 1
68795: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68796: LD_VAR 0 9
68800: PPUSH
68801: LD_VAR 0 13
68805: PPUSH
68806: CALL_OW 325
68810: PUSH
68811: LD_VAR 0 10
68815: PPUSH
68816: CALL_OW 255
68820: PPUSH
68821: LD_VAR 0 13
68825: PPUSH
68826: CALL_OW 325
68830: NOT
68831: AND
68832: IFFALSE 68861
// missile := Replace ( missile , missile + 1 , 3 ) ;
68834: LD_ADDR_VAR 0 14
68838: PUSH
68839: LD_VAR 0 14
68843: PPUSH
68844: LD_VAR 0 14
68848: PUSH
68849: LD_INT 1
68851: PLUS
68852: PPUSH
68853: LD_INT 3
68855: PPUSH
68856: CALL_OW 1
68860: ST_TO_ADDR
// if missile < 2 then
68861: LD_VAR 0 14
68865: PUSH
68866: LD_INT 2
68868: LESS
68869: IFFALSE 68873
// exit ;
68871: GO 69095
// x := GetX ( enemy ) ;
68873: LD_ADDR_VAR 0 4
68877: PUSH
68878: LD_VAR 0 10
68882: PPUSH
68883: CALL_OW 250
68887: ST_TO_ADDR
// y := GetY ( enemy ) ;
68888: LD_ADDR_VAR 0 5
68892: PUSH
68893: LD_VAR 0 10
68897: PPUSH
68898: CALL_OW 251
68902: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68903: LD_ADDR_VAR 0 6
68907: PUSH
68908: LD_VAR 0 4
68912: PUSH
68913: LD_INT 1
68915: NEG
68916: PPUSH
68917: LD_INT 1
68919: PPUSH
68920: CALL_OW 12
68924: PLUS
68925: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68926: LD_ADDR_VAR 0 7
68930: PUSH
68931: LD_VAR 0 5
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PPUSH
68940: LD_INT 1
68942: PPUSH
68943: CALL_OW 12
68947: PLUS
68948: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68949: LD_VAR 0 6
68953: PPUSH
68954: LD_VAR 0 7
68958: PPUSH
68959: CALL_OW 488
68963: NOT
68964: IFFALSE 68986
// begin _x := x ;
68966: LD_ADDR_VAR 0 6
68970: PUSH
68971: LD_VAR 0 4
68975: ST_TO_ADDR
// _y := y ;
68976: LD_ADDR_VAR 0 7
68980: PUSH
68981: LD_VAR 0 5
68985: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
68986: LD_ADDR_VAR 0 3
68990: PUSH
68991: LD_INT 1
68993: PPUSH
68994: LD_VAR 0 14
68998: PPUSH
68999: CALL_OW 12
69003: ST_TO_ADDR
// case i of 1 :
69004: LD_VAR 0 3
69008: PUSH
69009: LD_INT 1
69011: DOUBLE
69012: EQUAL
69013: IFTRUE 69017
69015: GO 69034
69017: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
69018: LD_VAR 0 1
69022: PPUSH
69023: LD_VAR 0 10
69027: PPUSH
69028: CALL_OW 115
69032: GO 69095
69034: LD_INT 2
69036: DOUBLE
69037: EQUAL
69038: IFTRUE 69042
69040: GO 69064
69042: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
69043: LD_VAR 0 1
69047: PPUSH
69048: LD_VAR 0 6
69052: PPUSH
69053: LD_VAR 0 7
69057: PPUSH
69058: CALL_OW 153
69062: GO 69095
69064: LD_INT 3
69066: DOUBLE
69067: EQUAL
69068: IFTRUE 69072
69070: GO 69094
69072: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
69073: LD_VAR 0 1
69077: PPUSH
69078: LD_VAR 0 6
69082: PPUSH
69083: LD_VAR 0 7
69087: PPUSH
69088: CALL_OW 154
69092: GO 69095
69094: POP
// end ;
69095: LD_VAR 0 2
69099: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
69100: LD_INT 0
69102: PPUSH
69103: PPUSH
69104: PPUSH
69105: PPUSH
69106: PPUSH
69107: PPUSH
// if not unit or not building then
69108: LD_VAR 0 1
69112: NOT
69113: PUSH
69114: LD_VAR 0 2
69118: NOT
69119: OR
69120: IFFALSE 69124
// exit ;
69122: GO 69282
// x := GetX ( building ) ;
69124: LD_ADDR_VAR 0 5
69128: PUSH
69129: LD_VAR 0 2
69133: PPUSH
69134: CALL_OW 250
69138: ST_TO_ADDR
// y := GetY ( building ) ;
69139: LD_ADDR_VAR 0 6
69143: PUSH
69144: LD_VAR 0 2
69148: PPUSH
69149: CALL_OW 251
69153: ST_TO_ADDR
// for i = 0 to 5 do
69154: LD_ADDR_VAR 0 4
69158: PUSH
69159: DOUBLE
69160: LD_INT 0
69162: DEC
69163: ST_TO_ADDR
69164: LD_INT 5
69166: PUSH
69167: FOR_TO
69168: IFFALSE 69280
// begin _x := ShiftX ( x , i , 3 ) ;
69170: LD_ADDR_VAR 0 7
69174: PUSH
69175: LD_VAR 0 5
69179: PPUSH
69180: LD_VAR 0 4
69184: PPUSH
69185: LD_INT 3
69187: PPUSH
69188: CALL_OW 272
69192: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
69193: LD_ADDR_VAR 0 8
69197: PUSH
69198: LD_VAR 0 6
69202: PPUSH
69203: LD_VAR 0 4
69207: PPUSH
69208: LD_INT 3
69210: PPUSH
69211: CALL_OW 273
69215: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69216: LD_VAR 0 7
69220: PPUSH
69221: LD_VAR 0 8
69225: PPUSH
69226: CALL_OW 488
69230: NOT
69231: IFFALSE 69235
// continue ;
69233: GO 69167
// if HexInfo ( _x , _y ) = 0 then
69235: LD_VAR 0 7
69239: PPUSH
69240: LD_VAR 0 8
69244: PPUSH
69245: CALL_OW 428
69249: PUSH
69250: LD_INT 0
69252: EQUAL
69253: IFFALSE 69278
// begin ComMoveXY ( unit , _x , _y ) ;
69255: LD_VAR 0 1
69259: PPUSH
69260: LD_VAR 0 7
69264: PPUSH
69265: LD_VAR 0 8
69269: PPUSH
69270: CALL_OW 111
// exit ;
69274: POP
69275: POP
69276: GO 69282
// end ; end ;
69278: GO 69167
69280: POP
69281: POP
// end ;
69282: LD_VAR 0 3
69286: RET
// export function ScanBase ( side , base_area ) ; begin
69287: LD_INT 0
69289: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
69290: LD_ADDR_VAR 0 3
69294: PUSH
69295: LD_VAR 0 2
69299: PPUSH
69300: LD_INT 81
69302: PUSH
69303: LD_VAR 0 1
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PPUSH
69312: CALL_OW 70
69316: ST_TO_ADDR
// end ;
69317: LD_VAR 0 3
69321: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69322: LD_INT 0
69324: PPUSH
69325: PPUSH
69326: PPUSH
69327: PPUSH
// result := false ;
69328: LD_ADDR_VAR 0 2
69332: PUSH
69333: LD_INT 0
69335: ST_TO_ADDR
// side := GetSide ( unit ) ;
69336: LD_ADDR_VAR 0 3
69340: PUSH
69341: LD_VAR 0 1
69345: PPUSH
69346: CALL_OW 255
69350: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69351: LD_ADDR_VAR 0 4
69355: PUSH
69356: LD_VAR 0 1
69360: PPUSH
69361: CALL_OW 248
69365: ST_TO_ADDR
// case nat of 1 :
69366: LD_VAR 0 4
69370: PUSH
69371: LD_INT 1
69373: DOUBLE
69374: EQUAL
69375: IFTRUE 69379
69377: GO 69390
69379: POP
// tech := tech_lassight ; 2 :
69380: LD_ADDR_VAR 0 5
69384: PUSH
69385: LD_INT 12
69387: ST_TO_ADDR
69388: GO 69429
69390: LD_INT 2
69392: DOUBLE
69393: EQUAL
69394: IFTRUE 69398
69396: GO 69409
69398: POP
// tech := tech_mortar ; 3 :
69399: LD_ADDR_VAR 0 5
69403: PUSH
69404: LD_INT 41
69406: ST_TO_ADDR
69407: GO 69429
69409: LD_INT 3
69411: DOUBLE
69412: EQUAL
69413: IFTRUE 69417
69415: GO 69428
69417: POP
// tech := tech_bazooka ; end ;
69418: LD_ADDR_VAR 0 5
69422: PUSH
69423: LD_INT 44
69425: ST_TO_ADDR
69426: GO 69429
69428: POP
// if Researched ( side , tech ) then
69429: LD_VAR 0 3
69433: PPUSH
69434: LD_VAR 0 5
69438: PPUSH
69439: CALL_OW 325
69443: IFFALSE 69470
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69445: LD_ADDR_VAR 0 2
69449: PUSH
69450: LD_INT 5
69452: PUSH
69453: LD_INT 8
69455: PUSH
69456: LD_INT 9
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: LIST
69463: PUSH
69464: LD_VAR 0 4
69468: ARRAY
69469: ST_TO_ADDR
// end ;
69470: LD_VAR 0 2
69474: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69475: LD_INT 0
69477: PPUSH
69478: PPUSH
69479: PPUSH
// if not mines then
69480: LD_VAR 0 2
69484: NOT
69485: IFFALSE 69489
// exit ;
69487: GO 69633
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69489: LD_ADDR_VAR 0 5
69493: PUSH
69494: LD_INT 81
69496: PUSH
69497: LD_VAR 0 1
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 3
69508: PUSH
69509: LD_INT 21
69511: PUSH
69512: LD_INT 3
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PPUSH
69527: CALL_OW 69
69531: ST_TO_ADDR
// for i in mines do
69532: LD_ADDR_VAR 0 4
69536: PUSH
69537: LD_VAR 0 2
69541: PUSH
69542: FOR_IN
69543: IFFALSE 69631
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69545: LD_VAR 0 4
69549: PUSH
69550: LD_INT 1
69552: ARRAY
69553: PPUSH
69554: LD_VAR 0 4
69558: PUSH
69559: LD_INT 2
69561: ARRAY
69562: PPUSH
69563: CALL_OW 458
69567: NOT
69568: IFFALSE 69572
// continue ;
69570: GO 69542
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69572: LD_VAR 0 4
69576: PUSH
69577: LD_INT 1
69579: ARRAY
69580: PPUSH
69581: LD_VAR 0 4
69585: PUSH
69586: LD_INT 2
69588: ARRAY
69589: PPUSH
69590: CALL_OW 428
69594: PUSH
69595: LD_VAR 0 5
69599: IN
69600: IFFALSE 69629
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69602: LD_VAR 0 4
69606: PUSH
69607: LD_INT 1
69609: ARRAY
69610: PPUSH
69611: LD_VAR 0 4
69615: PUSH
69616: LD_INT 2
69618: ARRAY
69619: PPUSH
69620: LD_VAR 0 1
69624: PPUSH
69625: CALL_OW 456
// end ;
69629: GO 69542
69631: POP
69632: POP
// end ;
69633: LD_VAR 0 3
69637: RET
// export function Count ( array ) ; var i ; begin
69638: LD_INT 0
69640: PPUSH
69641: PPUSH
// result := 0 ;
69642: LD_ADDR_VAR 0 2
69646: PUSH
69647: LD_INT 0
69649: ST_TO_ADDR
// for i in array do
69650: LD_ADDR_VAR 0 3
69654: PUSH
69655: LD_VAR 0 1
69659: PUSH
69660: FOR_IN
69661: IFFALSE 69685
// if i then
69663: LD_VAR 0 3
69667: IFFALSE 69683
// result := result + 1 ;
69669: LD_ADDR_VAR 0 2
69673: PUSH
69674: LD_VAR 0 2
69678: PUSH
69679: LD_INT 1
69681: PLUS
69682: ST_TO_ADDR
69683: GO 69660
69685: POP
69686: POP
// end ;
69687: LD_VAR 0 2
69691: RET
// export function IsEmpty ( building ) ; begin
69692: LD_INT 0
69694: PPUSH
// if not building then
69695: LD_VAR 0 1
69699: NOT
69700: IFFALSE 69704
// exit ;
69702: GO 69747
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69704: LD_ADDR_VAR 0 2
69708: PUSH
69709: LD_VAR 0 1
69713: PUSH
69714: LD_INT 22
69716: PUSH
69717: LD_VAR 0 1
69721: PPUSH
69722: CALL_OW 255
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 58
69733: PUSH
69734: EMPTY
69735: LIST
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PPUSH
69741: CALL_OW 69
69745: IN
69746: ST_TO_ADDR
// end ;
69747: LD_VAR 0 2
69751: RET
// export function IsNotFull ( building ) ; var places ; begin
69752: LD_INT 0
69754: PPUSH
69755: PPUSH
// if not building then
69756: LD_VAR 0 1
69760: NOT
69761: IFFALSE 69765
// exit ;
69763: GO 69936
// result := false ;
69765: LD_ADDR_VAR 0 2
69769: PUSH
69770: LD_INT 0
69772: ST_TO_ADDR
// places := 0 ;
69773: LD_ADDR_VAR 0 3
69777: PUSH
69778: LD_INT 0
69780: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69781: LD_VAR 0 1
69785: PPUSH
69786: CALL_OW 266
69790: PUSH
69791: LD_INT 0
69793: DOUBLE
69794: EQUAL
69795: IFTRUE 69853
69797: LD_INT 1
69799: DOUBLE
69800: EQUAL
69801: IFTRUE 69853
69803: LD_INT 6
69805: DOUBLE
69806: EQUAL
69807: IFTRUE 69853
69809: LD_INT 7
69811: DOUBLE
69812: EQUAL
69813: IFTRUE 69853
69815: LD_INT 8
69817: DOUBLE
69818: EQUAL
69819: IFTRUE 69853
69821: LD_INT 4
69823: DOUBLE
69824: EQUAL
69825: IFTRUE 69853
69827: LD_INT 5
69829: DOUBLE
69830: EQUAL
69831: IFTRUE 69853
69833: LD_INT 2
69835: DOUBLE
69836: EQUAL
69837: IFTRUE 69853
69839: LD_INT 3
69841: DOUBLE
69842: EQUAL
69843: IFTRUE 69853
69845: LD_INT 35
69847: DOUBLE
69848: EQUAL
69849: IFTRUE 69853
69851: GO 69864
69853: POP
// places := 6 ; b_bunker , b_breastwork :
69854: LD_ADDR_VAR 0 3
69858: PUSH
69859: LD_INT 6
69861: ST_TO_ADDR
69862: GO 69909
69864: LD_INT 32
69866: DOUBLE
69867: EQUAL
69868: IFTRUE 69878
69870: LD_INT 31
69872: DOUBLE
69873: EQUAL
69874: IFTRUE 69878
69876: GO 69889
69878: POP
// places := 1 ; b_control_tower :
69879: LD_ADDR_VAR 0 3
69883: PUSH
69884: LD_INT 1
69886: ST_TO_ADDR
69887: GO 69909
69889: LD_INT 36
69891: DOUBLE
69892: EQUAL
69893: IFTRUE 69897
69895: GO 69908
69897: POP
// places := 3 ; end ;
69898: LD_ADDR_VAR 0 3
69902: PUSH
69903: LD_INT 3
69905: ST_TO_ADDR
69906: GO 69909
69908: POP
// if places then
69909: LD_VAR 0 3
69913: IFFALSE 69936
// result := UnitsInside ( building ) < places ;
69915: LD_ADDR_VAR 0 2
69919: PUSH
69920: LD_VAR 0 1
69924: PPUSH
69925: CALL_OW 313
69929: PUSH
69930: LD_VAR 0 3
69934: LESS
69935: ST_TO_ADDR
// end ;
69936: LD_VAR 0 2
69940: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69941: LD_INT 0
69943: PPUSH
69944: PPUSH
69945: PPUSH
69946: PPUSH
// tmp := [ ] ;
69947: LD_ADDR_VAR 0 3
69951: PUSH
69952: EMPTY
69953: ST_TO_ADDR
// list := [ ] ;
69954: LD_ADDR_VAR 0 5
69958: PUSH
69959: EMPTY
69960: ST_TO_ADDR
// for i = 16 to 25 do
69961: LD_ADDR_VAR 0 4
69965: PUSH
69966: DOUBLE
69967: LD_INT 16
69969: DEC
69970: ST_TO_ADDR
69971: LD_INT 25
69973: PUSH
69974: FOR_TO
69975: IFFALSE 70048
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69977: LD_ADDR_VAR 0 3
69981: PUSH
69982: LD_VAR 0 3
69986: PUSH
69987: LD_INT 22
69989: PUSH
69990: LD_VAR 0 1
69994: PPUSH
69995: CALL_OW 255
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 91
70006: PUSH
70007: LD_VAR 0 1
70011: PUSH
70012: LD_INT 6
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 30
70022: PUSH
70023: LD_VAR 0 4
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: LIST
70036: PUSH
70037: EMPTY
70038: LIST
70039: PPUSH
70040: CALL_OW 69
70044: ADD
70045: ST_TO_ADDR
70046: GO 69974
70048: POP
70049: POP
// for i = 1 to tmp do
70050: LD_ADDR_VAR 0 4
70054: PUSH
70055: DOUBLE
70056: LD_INT 1
70058: DEC
70059: ST_TO_ADDR
70060: LD_VAR 0 3
70064: PUSH
70065: FOR_TO
70066: IFFALSE 70154
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
70068: LD_ADDR_VAR 0 5
70072: PUSH
70073: LD_VAR 0 5
70077: PUSH
70078: LD_VAR 0 3
70082: PUSH
70083: LD_VAR 0 4
70087: ARRAY
70088: PPUSH
70089: CALL_OW 266
70093: PUSH
70094: LD_VAR 0 3
70098: PUSH
70099: LD_VAR 0 4
70103: ARRAY
70104: PPUSH
70105: CALL_OW 250
70109: PUSH
70110: LD_VAR 0 3
70114: PUSH
70115: LD_VAR 0 4
70119: ARRAY
70120: PPUSH
70121: CALL_OW 251
70125: PUSH
70126: LD_VAR 0 3
70130: PUSH
70131: LD_VAR 0 4
70135: ARRAY
70136: PPUSH
70137: CALL_OW 254
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: PUSH
70148: EMPTY
70149: LIST
70150: ADD
70151: ST_TO_ADDR
70152: GO 70065
70154: POP
70155: POP
// result := list ;
70156: LD_ADDR_VAR 0 2
70160: PUSH
70161: LD_VAR 0 5
70165: ST_TO_ADDR
// end ;
70166: LD_VAR 0 2
70170: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
70171: LD_INT 0
70173: PPUSH
70174: PPUSH
70175: PPUSH
70176: PPUSH
70177: PPUSH
70178: PPUSH
70179: PPUSH
// if not factory then
70180: LD_VAR 0 1
70184: NOT
70185: IFFALSE 70189
// exit ;
70187: GO 70782
// if control = control_apeman then
70189: LD_VAR 0 4
70193: PUSH
70194: LD_INT 5
70196: EQUAL
70197: IFFALSE 70306
// begin tmp := UnitsInside ( factory ) ;
70199: LD_ADDR_VAR 0 8
70203: PUSH
70204: LD_VAR 0 1
70208: PPUSH
70209: CALL_OW 313
70213: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
70214: LD_VAR 0 8
70218: PPUSH
70219: LD_INT 25
70221: PUSH
70222: LD_INT 12
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PPUSH
70229: CALL_OW 72
70233: NOT
70234: IFFALSE 70244
// control := control_manual ;
70236: LD_ADDR_VAR 0 4
70240: PUSH
70241: LD_INT 1
70243: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
70244: LD_ADDR_VAR 0 8
70248: PUSH
70249: LD_VAR 0 1
70253: PPUSH
70254: CALL 69941 0 1
70258: ST_TO_ADDR
// if tmp then
70259: LD_VAR 0 8
70263: IFFALSE 70306
// begin for i in tmp do
70265: LD_ADDR_VAR 0 7
70269: PUSH
70270: LD_VAR 0 8
70274: PUSH
70275: FOR_IN
70276: IFFALSE 70304
// if i [ 1 ] = b_ext_radio then
70278: LD_VAR 0 7
70282: PUSH
70283: LD_INT 1
70285: ARRAY
70286: PUSH
70287: LD_INT 22
70289: EQUAL
70290: IFFALSE 70302
// begin control := control_remote ;
70292: LD_ADDR_VAR 0 4
70296: PUSH
70297: LD_INT 2
70299: ST_TO_ADDR
// break ;
70300: GO 70304
// end ;
70302: GO 70275
70304: POP
70305: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70306: LD_VAR 0 1
70310: PPUSH
70311: LD_VAR 0 2
70315: PPUSH
70316: LD_VAR 0 3
70320: PPUSH
70321: LD_VAR 0 4
70325: PPUSH
70326: LD_VAR 0 5
70330: PPUSH
70331: CALL_OW 448
70335: IFFALSE 70370
// begin result := [ chassis , engine , control , weapon ] ;
70337: LD_ADDR_VAR 0 6
70341: PUSH
70342: LD_VAR 0 2
70346: PUSH
70347: LD_VAR 0 3
70351: PUSH
70352: LD_VAR 0 4
70356: PUSH
70357: LD_VAR 0 5
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: LIST
70366: LIST
70367: ST_TO_ADDR
// exit ;
70368: GO 70782
// end ; _chassis := AvailableChassisList ( factory ) ;
70370: LD_ADDR_VAR 0 9
70374: PUSH
70375: LD_VAR 0 1
70379: PPUSH
70380: CALL_OW 475
70384: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70385: LD_ADDR_VAR 0 11
70389: PUSH
70390: LD_VAR 0 1
70394: PPUSH
70395: CALL_OW 476
70399: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70400: LD_ADDR_VAR 0 12
70404: PUSH
70405: LD_VAR 0 1
70409: PPUSH
70410: CALL_OW 477
70414: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70415: LD_ADDR_VAR 0 10
70419: PUSH
70420: LD_VAR 0 1
70424: PPUSH
70425: CALL_OW 478
70429: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70430: LD_VAR 0 9
70434: NOT
70435: PUSH
70436: LD_VAR 0 11
70440: NOT
70441: OR
70442: PUSH
70443: LD_VAR 0 12
70447: NOT
70448: OR
70449: PUSH
70450: LD_VAR 0 10
70454: NOT
70455: OR
70456: IFFALSE 70491
// begin result := [ chassis , engine , control , weapon ] ;
70458: LD_ADDR_VAR 0 6
70462: PUSH
70463: LD_VAR 0 2
70467: PUSH
70468: LD_VAR 0 3
70472: PUSH
70473: LD_VAR 0 4
70477: PUSH
70478: LD_VAR 0 5
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: LIST
70487: LIST
70488: ST_TO_ADDR
// exit ;
70489: GO 70782
// end ; if not chassis in _chassis then
70491: LD_VAR 0 2
70495: PUSH
70496: LD_VAR 0 9
70500: IN
70501: NOT
70502: IFFALSE 70528
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70504: LD_ADDR_VAR 0 2
70508: PUSH
70509: LD_VAR 0 9
70513: PUSH
70514: LD_INT 1
70516: PPUSH
70517: LD_VAR 0 9
70521: PPUSH
70522: CALL_OW 12
70526: ARRAY
70527: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70528: LD_VAR 0 2
70532: PPUSH
70533: LD_VAR 0 3
70537: PPUSH
70538: CALL 70787 0 2
70542: NOT
70543: IFFALSE 70602
// repeat engine := _engine [ 1 ] ;
70545: LD_ADDR_VAR 0 3
70549: PUSH
70550: LD_VAR 0 11
70554: PUSH
70555: LD_INT 1
70557: ARRAY
70558: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70559: LD_ADDR_VAR 0 11
70563: PUSH
70564: LD_VAR 0 11
70568: PPUSH
70569: LD_INT 1
70571: PPUSH
70572: CALL_OW 3
70576: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70577: LD_VAR 0 2
70581: PPUSH
70582: LD_VAR 0 3
70586: PPUSH
70587: CALL 70787 0 2
70591: PUSH
70592: LD_VAR 0 11
70596: PUSH
70597: EMPTY
70598: EQUAL
70599: OR
70600: IFFALSE 70545
// if not control in _control then
70602: LD_VAR 0 4
70606: PUSH
70607: LD_VAR 0 12
70611: IN
70612: NOT
70613: IFFALSE 70639
// control := _control [ rand ( 1 , _control ) ] ;
70615: LD_ADDR_VAR 0 4
70619: PUSH
70620: LD_VAR 0 12
70624: PUSH
70625: LD_INT 1
70627: PPUSH
70628: LD_VAR 0 12
70632: PPUSH
70633: CALL_OW 12
70637: ARRAY
70638: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70639: LD_VAR 0 2
70643: PPUSH
70644: LD_VAR 0 5
70648: PPUSH
70649: CALL 71007 0 2
70653: NOT
70654: IFFALSE 70713
// repeat weapon := _weapon [ 1 ] ;
70656: LD_ADDR_VAR 0 5
70660: PUSH
70661: LD_VAR 0 10
70665: PUSH
70666: LD_INT 1
70668: ARRAY
70669: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70670: LD_ADDR_VAR 0 10
70674: PUSH
70675: LD_VAR 0 10
70679: PPUSH
70680: LD_INT 1
70682: PPUSH
70683: CALL_OW 3
70687: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70688: LD_VAR 0 2
70692: PPUSH
70693: LD_VAR 0 5
70697: PPUSH
70698: CALL 71007 0 2
70702: PUSH
70703: LD_VAR 0 10
70707: PUSH
70708: EMPTY
70709: EQUAL
70710: OR
70711: IFFALSE 70656
// result := [ ] ;
70713: LD_ADDR_VAR 0 6
70717: PUSH
70718: EMPTY
70719: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70720: LD_VAR 0 1
70724: PPUSH
70725: LD_VAR 0 2
70729: PPUSH
70730: LD_VAR 0 3
70734: PPUSH
70735: LD_VAR 0 4
70739: PPUSH
70740: LD_VAR 0 5
70744: PPUSH
70745: CALL_OW 448
70749: IFFALSE 70782
// result := [ chassis , engine , control , weapon ] ;
70751: LD_ADDR_VAR 0 6
70755: PUSH
70756: LD_VAR 0 2
70760: PUSH
70761: LD_VAR 0 3
70765: PUSH
70766: LD_VAR 0 4
70770: PUSH
70771: LD_VAR 0 5
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: ST_TO_ADDR
// end ;
70782: LD_VAR 0 6
70786: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70787: LD_INT 0
70789: PPUSH
// if not chassis or not engine then
70790: LD_VAR 0 1
70794: NOT
70795: PUSH
70796: LD_VAR 0 2
70800: NOT
70801: OR
70802: IFFALSE 70806
// exit ;
70804: GO 71002
// case engine of engine_solar :
70806: LD_VAR 0 2
70810: PUSH
70811: LD_INT 2
70813: DOUBLE
70814: EQUAL
70815: IFTRUE 70819
70817: GO 70857
70819: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70820: LD_ADDR_VAR 0 3
70824: PUSH
70825: LD_INT 11
70827: PUSH
70828: LD_INT 12
70830: PUSH
70831: LD_INT 13
70833: PUSH
70834: LD_INT 14
70836: PUSH
70837: LD_INT 1
70839: PUSH
70840: LD_INT 2
70842: PUSH
70843: LD_INT 3
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: LIST
70850: LIST
70851: LIST
70852: LIST
70853: LIST
70854: ST_TO_ADDR
70855: GO 70986
70857: LD_INT 1
70859: DOUBLE
70860: EQUAL
70861: IFTRUE 70865
70863: GO 70927
70865: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70866: LD_ADDR_VAR 0 3
70870: PUSH
70871: LD_INT 11
70873: PUSH
70874: LD_INT 12
70876: PUSH
70877: LD_INT 13
70879: PUSH
70880: LD_INT 14
70882: PUSH
70883: LD_INT 1
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 3
70891: PUSH
70892: LD_INT 4
70894: PUSH
70895: LD_INT 5
70897: PUSH
70898: LD_INT 21
70900: PUSH
70901: LD_INT 23
70903: PUSH
70904: LD_INT 22
70906: PUSH
70907: LD_INT 24
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: ST_TO_ADDR
70925: GO 70986
70927: LD_INT 3
70929: DOUBLE
70930: EQUAL
70931: IFTRUE 70935
70933: GO 70985
70935: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70936: LD_ADDR_VAR 0 3
70940: PUSH
70941: LD_INT 13
70943: PUSH
70944: LD_INT 14
70946: PUSH
70947: LD_INT 2
70949: PUSH
70950: LD_INT 3
70952: PUSH
70953: LD_INT 4
70955: PUSH
70956: LD_INT 5
70958: PUSH
70959: LD_INT 21
70961: PUSH
70962: LD_INT 22
70964: PUSH
70965: LD_INT 23
70967: PUSH
70968: LD_INT 24
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: ST_TO_ADDR
70983: GO 70986
70985: POP
// result := ( chassis in result ) ;
70986: LD_ADDR_VAR 0 3
70990: PUSH
70991: LD_VAR 0 1
70995: PUSH
70996: LD_VAR 0 3
71000: IN
71001: ST_TO_ADDR
// end ;
71002: LD_VAR 0 3
71006: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
71007: LD_INT 0
71009: PPUSH
// if not chassis or not weapon then
71010: LD_VAR 0 1
71014: NOT
71015: PUSH
71016: LD_VAR 0 2
71020: NOT
71021: OR
71022: IFFALSE 71026
// exit ;
71024: GO 72086
// case weapon of us_machine_gun :
71026: LD_VAR 0 2
71030: PUSH
71031: LD_INT 2
71033: DOUBLE
71034: EQUAL
71035: IFTRUE 71039
71037: GO 71069
71039: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
71040: LD_ADDR_VAR 0 3
71044: PUSH
71045: LD_INT 1
71047: PUSH
71048: LD_INT 2
71050: PUSH
71051: LD_INT 3
71053: PUSH
71054: LD_INT 4
71056: PUSH
71057: LD_INT 5
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: ST_TO_ADDR
71067: GO 72070
71069: LD_INT 3
71071: DOUBLE
71072: EQUAL
71073: IFTRUE 71077
71075: GO 71107
71077: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
71078: LD_ADDR_VAR 0 3
71082: PUSH
71083: LD_INT 1
71085: PUSH
71086: LD_INT 2
71088: PUSH
71089: LD_INT 3
71091: PUSH
71092: LD_INT 4
71094: PUSH
71095: LD_INT 5
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: LIST
71102: LIST
71103: LIST
71104: ST_TO_ADDR
71105: GO 72070
71107: LD_INT 11
71109: DOUBLE
71110: EQUAL
71111: IFTRUE 71115
71113: GO 71145
71115: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
71116: LD_ADDR_VAR 0 3
71120: PUSH
71121: LD_INT 1
71123: PUSH
71124: LD_INT 2
71126: PUSH
71127: LD_INT 3
71129: PUSH
71130: LD_INT 4
71132: PUSH
71133: LD_INT 5
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: ST_TO_ADDR
71143: GO 72070
71145: LD_INT 4
71147: DOUBLE
71148: EQUAL
71149: IFTRUE 71153
71151: GO 71179
71153: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
71154: LD_ADDR_VAR 0 3
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: LD_INT 3
71164: PUSH
71165: LD_INT 4
71167: PUSH
71168: LD_INT 5
71170: PUSH
71171: EMPTY
71172: LIST
71173: LIST
71174: LIST
71175: LIST
71176: ST_TO_ADDR
71177: GO 72070
71179: LD_INT 5
71181: DOUBLE
71182: EQUAL
71183: IFTRUE 71187
71185: GO 71213
71187: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
71188: LD_ADDR_VAR 0 3
71192: PUSH
71193: LD_INT 2
71195: PUSH
71196: LD_INT 3
71198: PUSH
71199: LD_INT 4
71201: PUSH
71202: LD_INT 5
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: LIST
71209: LIST
71210: ST_TO_ADDR
71211: GO 72070
71213: LD_INT 9
71215: DOUBLE
71216: EQUAL
71217: IFTRUE 71221
71219: GO 71247
71221: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
71222: LD_ADDR_VAR 0 3
71226: PUSH
71227: LD_INT 2
71229: PUSH
71230: LD_INT 3
71232: PUSH
71233: LD_INT 4
71235: PUSH
71236: LD_INT 5
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: LIST
71243: LIST
71244: ST_TO_ADDR
71245: GO 72070
71247: LD_INT 7
71249: DOUBLE
71250: EQUAL
71251: IFTRUE 71255
71253: GO 71281
71255: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
71256: LD_ADDR_VAR 0 3
71260: PUSH
71261: LD_INT 2
71263: PUSH
71264: LD_INT 3
71266: PUSH
71267: LD_INT 4
71269: PUSH
71270: LD_INT 5
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: ST_TO_ADDR
71279: GO 72070
71281: LD_INT 12
71283: DOUBLE
71284: EQUAL
71285: IFTRUE 71289
71287: GO 71315
71289: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
71290: LD_ADDR_VAR 0 3
71294: PUSH
71295: LD_INT 2
71297: PUSH
71298: LD_INT 3
71300: PUSH
71301: LD_INT 4
71303: PUSH
71304: LD_INT 5
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: ST_TO_ADDR
71313: GO 72070
71315: LD_INT 13
71317: DOUBLE
71318: EQUAL
71319: IFTRUE 71323
71321: GO 71349
71323: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71324: LD_ADDR_VAR 0 3
71328: PUSH
71329: LD_INT 2
71331: PUSH
71332: LD_INT 3
71334: PUSH
71335: LD_INT 4
71337: PUSH
71338: LD_INT 5
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: ST_TO_ADDR
71347: GO 72070
71349: LD_INT 14
71351: DOUBLE
71352: EQUAL
71353: IFTRUE 71357
71355: GO 71375
71357: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71358: LD_ADDR_VAR 0 3
71362: PUSH
71363: LD_INT 4
71365: PUSH
71366: LD_INT 5
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: ST_TO_ADDR
71373: GO 72070
71375: LD_INT 6
71377: DOUBLE
71378: EQUAL
71379: IFTRUE 71383
71381: GO 71401
71383: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71384: LD_ADDR_VAR 0 3
71388: PUSH
71389: LD_INT 4
71391: PUSH
71392: LD_INT 5
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: ST_TO_ADDR
71399: GO 72070
71401: LD_INT 10
71403: DOUBLE
71404: EQUAL
71405: IFTRUE 71409
71407: GO 71427
71409: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71410: LD_ADDR_VAR 0 3
71414: PUSH
71415: LD_INT 4
71417: PUSH
71418: LD_INT 5
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: ST_TO_ADDR
71425: GO 72070
71427: LD_INT 22
71429: DOUBLE
71430: EQUAL
71431: IFTRUE 71435
71433: GO 71461
71435: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71436: LD_ADDR_VAR 0 3
71440: PUSH
71441: LD_INT 11
71443: PUSH
71444: LD_INT 12
71446: PUSH
71447: LD_INT 13
71449: PUSH
71450: LD_INT 14
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: LIST
71457: LIST
71458: ST_TO_ADDR
71459: GO 72070
71461: LD_INT 23
71463: DOUBLE
71464: EQUAL
71465: IFTRUE 71469
71467: GO 71495
71469: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71470: LD_ADDR_VAR 0 3
71474: PUSH
71475: LD_INT 11
71477: PUSH
71478: LD_INT 12
71480: PUSH
71481: LD_INT 13
71483: PUSH
71484: LD_INT 14
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: ST_TO_ADDR
71493: GO 72070
71495: LD_INT 24
71497: DOUBLE
71498: EQUAL
71499: IFTRUE 71503
71501: GO 71529
71503: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71504: LD_ADDR_VAR 0 3
71508: PUSH
71509: LD_INT 11
71511: PUSH
71512: LD_INT 12
71514: PUSH
71515: LD_INT 13
71517: PUSH
71518: LD_INT 14
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: ST_TO_ADDR
71527: GO 72070
71529: LD_INT 30
71531: DOUBLE
71532: EQUAL
71533: IFTRUE 71537
71535: GO 71563
71537: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71538: LD_ADDR_VAR 0 3
71542: PUSH
71543: LD_INT 11
71545: PUSH
71546: LD_INT 12
71548: PUSH
71549: LD_INT 13
71551: PUSH
71552: LD_INT 14
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: ST_TO_ADDR
71561: GO 72070
71563: LD_INT 25
71565: DOUBLE
71566: EQUAL
71567: IFTRUE 71571
71569: GO 71589
71571: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71572: LD_ADDR_VAR 0 3
71576: PUSH
71577: LD_INT 13
71579: PUSH
71580: LD_INT 14
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: ST_TO_ADDR
71587: GO 72070
71589: LD_INT 27
71591: DOUBLE
71592: EQUAL
71593: IFTRUE 71597
71595: GO 71615
71597: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71598: LD_ADDR_VAR 0 3
71602: PUSH
71603: LD_INT 13
71605: PUSH
71606: LD_INT 14
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: ST_TO_ADDR
71613: GO 72070
71615: LD_INT 92
71617: DOUBLE
71618: EQUAL
71619: IFTRUE 71623
71621: GO 71649
71623: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71624: LD_ADDR_VAR 0 3
71628: PUSH
71629: LD_INT 11
71631: PUSH
71632: LD_INT 12
71634: PUSH
71635: LD_INT 13
71637: PUSH
71638: LD_INT 14
71640: PUSH
71641: EMPTY
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: ST_TO_ADDR
71647: GO 72070
71649: LD_INT 28
71651: DOUBLE
71652: EQUAL
71653: IFTRUE 71657
71655: GO 71675
71657: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71658: LD_ADDR_VAR 0 3
71662: PUSH
71663: LD_INT 13
71665: PUSH
71666: LD_INT 14
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: ST_TO_ADDR
71673: GO 72070
71675: LD_INT 29
71677: DOUBLE
71678: EQUAL
71679: IFTRUE 71683
71681: GO 71701
71683: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71684: LD_ADDR_VAR 0 3
71688: PUSH
71689: LD_INT 13
71691: PUSH
71692: LD_INT 14
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: ST_TO_ADDR
71699: GO 72070
71701: LD_INT 31
71703: DOUBLE
71704: EQUAL
71705: IFTRUE 71709
71707: GO 71727
71709: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71710: LD_ADDR_VAR 0 3
71714: PUSH
71715: LD_INT 13
71717: PUSH
71718: LD_INT 14
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: ST_TO_ADDR
71725: GO 72070
71727: LD_INT 26
71729: DOUBLE
71730: EQUAL
71731: IFTRUE 71735
71733: GO 71753
71735: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71736: LD_ADDR_VAR 0 3
71740: PUSH
71741: LD_INT 13
71743: PUSH
71744: LD_INT 14
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: ST_TO_ADDR
71751: GO 72070
71753: LD_INT 42
71755: DOUBLE
71756: EQUAL
71757: IFTRUE 71761
71759: GO 71787
71761: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71762: LD_ADDR_VAR 0 3
71766: PUSH
71767: LD_INT 21
71769: PUSH
71770: LD_INT 22
71772: PUSH
71773: LD_INT 23
71775: PUSH
71776: LD_INT 24
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: ST_TO_ADDR
71785: GO 72070
71787: LD_INT 43
71789: DOUBLE
71790: EQUAL
71791: IFTRUE 71795
71793: GO 71821
71795: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71796: LD_ADDR_VAR 0 3
71800: PUSH
71801: LD_INT 21
71803: PUSH
71804: LD_INT 22
71806: PUSH
71807: LD_INT 23
71809: PUSH
71810: LD_INT 24
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: ST_TO_ADDR
71819: GO 72070
71821: LD_INT 44
71823: DOUBLE
71824: EQUAL
71825: IFTRUE 71829
71827: GO 71855
71829: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71830: LD_ADDR_VAR 0 3
71834: PUSH
71835: LD_INT 21
71837: PUSH
71838: LD_INT 22
71840: PUSH
71841: LD_INT 23
71843: PUSH
71844: LD_INT 24
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: LIST
71851: LIST
71852: ST_TO_ADDR
71853: GO 72070
71855: LD_INT 45
71857: DOUBLE
71858: EQUAL
71859: IFTRUE 71863
71861: GO 71889
71863: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71864: LD_ADDR_VAR 0 3
71868: PUSH
71869: LD_INT 21
71871: PUSH
71872: LD_INT 22
71874: PUSH
71875: LD_INT 23
71877: PUSH
71878: LD_INT 24
71880: PUSH
71881: EMPTY
71882: LIST
71883: LIST
71884: LIST
71885: LIST
71886: ST_TO_ADDR
71887: GO 72070
71889: LD_INT 49
71891: DOUBLE
71892: EQUAL
71893: IFTRUE 71897
71895: GO 71923
71897: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71898: LD_ADDR_VAR 0 3
71902: PUSH
71903: LD_INT 21
71905: PUSH
71906: LD_INT 22
71908: PUSH
71909: LD_INT 23
71911: PUSH
71912: LD_INT 24
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: LIST
71919: LIST
71920: ST_TO_ADDR
71921: GO 72070
71923: LD_INT 51
71925: DOUBLE
71926: EQUAL
71927: IFTRUE 71931
71929: GO 71957
71931: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71932: LD_ADDR_VAR 0 3
71936: PUSH
71937: LD_INT 21
71939: PUSH
71940: LD_INT 22
71942: PUSH
71943: LD_INT 23
71945: PUSH
71946: LD_INT 24
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: ST_TO_ADDR
71955: GO 72070
71957: LD_INT 52
71959: DOUBLE
71960: EQUAL
71961: IFTRUE 71965
71963: GO 71991
71965: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71966: LD_ADDR_VAR 0 3
71970: PUSH
71971: LD_INT 21
71973: PUSH
71974: LD_INT 22
71976: PUSH
71977: LD_INT 23
71979: PUSH
71980: LD_INT 24
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: ST_TO_ADDR
71989: GO 72070
71991: LD_INT 53
71993: DOUBLE
71994: EQUAL
71995: IFTRUE 71999
71997: GO 72017
71999: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
72000: LD_ADDR_VAR 0 3
72004: PUSH
72005: LD_INT 23
72007: PUSH
72008: LD_INT 24
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: ST_TO_ADDR
72015: GO 72070
72017: LD_INT 46
72019: DOUBLE
72020: EQUAL
72021: IFTRUE 72025
72023: GO 72043
72025: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
72026: LD_ADDR_VAR 0 3
72030: PUSH
72031: LD_INT 23
72033: PUSH
72034: LD_INT 24
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: ST_TO_ADDR
72041: GO 72070
72043: LD_INT 47
72045: DOUBLE
72046: EQUAL
72047: IFTRUE 72051
72049: GO 72069
72051: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72052: LD_ADDR_VAR 0 3
72056: PUSH
72057: LD_INT 23
72059: PUSH
72060: LD_INT 24
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: ST_TO_ADDR
72067: GO 72070
72069: POP
// result := ( chassis in result ) ;
72070: LD_ADDR_VAR 0 3
72074: PUSH
72075: LD_VAR 0 1
72079: PUSH
72080: LD_VAR 0 3
72084: IN
72085: ST_TO_ADDR
// end ;
72086: LD_VAR 0 3
72090: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
72091: LD_INT 0
72093: PPUSH
72094: PPUSH
72095: PPUSH
72096: PPUSH
72097: PPUSH
72098: PPUSH
72099: PPUSH
// result := array ;
72100: LD_ADDR_VAR 0 5
72104: PUSH
72105: LD_VAR 0 1
72109: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
72110: LD_VAR 0 1
72114: NOT
72115: PUSH
72116: LD_VAR 0 2
72120: NOT
72121: OR
72122: PUSH
72123: LD_VAR 0 3
72127: NOT
72128: OR
72129: PUSH
72130: LD_VAR 0 2
72134: PUSH
72135: LD_VAR 0 1
72139: GREATER
72140: OR
72141: PUSH
72142: LD_VAR 0 3
72146: PUSH
72147: LD_VAR 0 1
72151: GREATER
72152: OR
72153: IFFALSE 72157
// exit ;
72155: GO 72453
// if direction then
72157: LD_VAR 0 4
72161: IFFALSE 72225
// begin d := 1 ;
72163: LD_ADDR_VAR 0 9
72167: PUSH
72168: LD_INT 1
72170: ST_TO_ADDR
// if i_from > i_to then
72171: LD_VAR 0 2
72175: PUSH
72176: LD_VAR 0 3
72180: GREATER
72181: IFFALSE 72207
// length := ( array - i_from ) + i_to else
72183: LD_ADDR_VAR 0 11
72187: PUSH
72188: LD_VAR 0 1
72192: PUSH
72193: LD_VAR 0 2
72197: MINUS
72198: PUSH
72199: LD_VAR 0 3
72203: PLUS
72204: ST_TO_ADDR
72205: GO 72223
// length := i_to - i_from ;
72207: LD_ADDR_VAR 0 11
72211: PUSH
72212: LD_VAR 0 3
72216: PUSH
72217: LD_VAR 0 2
72221: MINUS
72222: ST_TO_ADDR
// end else
72223: GO 72286
// begin d := - 1 ;
72225: LD_ADDR_VAR 0 9
72229: PUSH
72230: LD_INT 1
72232: NEG
72233: ST_TO_ADDR
// if i_from > i_to then
72234: LD_VAR 0 2
72238: PUSH
72239: LD_VAR 0 3
72243: GREATER
72244: IFFALSE 72264
// length := i_from - i_to else
72246: LD_ADDR_VAR 0 11
72250: PUSH
72251: LD_VAR 0 2
72255: PUSH
72256: LD_VAR 0 3
72260: MINUS
72261: ST_TO_ADDR
72262: GO 72286
// length := ( array - i_to ) + i_from ;
72264: LD_ADDR_VAR 0 11
72268: PUSH
72269: LD_VAR 0 1
72273: PUSH
72274: LD_VAR 0 3
72278: MINUS
72279: PUSH
72280: LD_VAR 0 2
72284: PLUS
72285: ST_TO_ADDR
// end ; if not length then
72286: LD_VAR 0 11
72290: NOT
72291: IFFALSE 72295
// exit ;
72293: GO 72453
// tmp := array ;
72295: LD_ADDR_VAR 0 10
72299: PUSH
72300: LD_VAR 0 1
72304: ST_TO_ADDR
// for i = 1 to length do
72305: LD_ADDR_VAR 0 6
72309: PUSH
72310: DOUBLE
72311: LD_INT 1
72313: DEC
72314: ST_TO_ADDR
72315: LD_VAR 0 11
72319: PUSH
72320: FOR_TO
72321: IFFALSE 72441
// begin for j = 1 to array do
72323: LD_ADDR_VAR 0 7
72327: PUSH
72328: DOUBLE
72329: LD_INT 1
72331: DEC
72332: ST_TO_ADDR
72333: LD_VAR 0 1
72337: PUSH
72338: FOR_TO
72339: IFFALSE 72427
// begin k := j + d ;
72341: LD_ADDR_VAR 0 8
72345: PUSH
72346: LD_VAR 0 7
72350: PUSH
72351: LD_VAR 0 9
72355: PLUS
72356: ST_TO_ADDR
// if k > array then
72357: LD_VAR 0 8
72361: PUSH
72362: LD_VAR 0 1
72366: GREATER
72367: IFFALSE 72377
// k := 1 ;
72369: LD_ADDR_VAR 0 8
72373: PUSH
72374: LD_INT 1
72376: ST_TO_ADDR
// if not k then
72377: LD_VAR 0 8
72381: NOT
72382: IFFALSE 72394
// k := array ;
72384: LD_ADDR_VAR 0 8
72388: PUSH
72389: LD_VAR 0 1
72393: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72394: LD_ADDR_VAR 0 10
72398: PUSH
72399: LD_VAR 0 10
72403: PPUSH
72404: LD_VAR 0 8
72408: PPUSH
72409: LD_VAR 0 1
72413: PUSH
72414: LD_VAR 0 7
72418: ARRAY
72419: PPUSH
72420: CALL_OW 1
72424: ST_TO_ADDR
// end ;
72425: GO 72338
72427: POP
72428: POP
// array := tmp ;
72429: LD_ADDR_VAR 0 1
72433: PUSH
72434: LD_VAR 0 10
72438: ST_TO_ADDR
// end ;
72439: GO 72320
72441: POP
72442: POP
// result := array ;
72443: LD_ADDR_VAR 0 5
72447: PUSH
72448: LD_VAR 0 1
72452: ST_TO_ADDR
// end ;
72453: LD_VAR 0 5
72457: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72458: LD_INT 0
72460: PPUSH
72461: PPUSH
// result := 0 ;
72462: LD_ADDR_VAR 0 3
72466: PUSH
72467: LD_INT 0
72469: ST_TO_ADDR
// if not array or not value in array then
72470: LD_VAR 0 1
72474: NOT
72475: PUSH
72476: LD_VAR 0 2
72480: PUSH
72481: LD_VAR 0 1
72485: IN
72486: NOT
72487: OR
72488: IFFALSE 72492
// exit ;
72490: GO 72546
// for i = 1 to array do
72492: LD_ADDR_VAR 0 4
72496: PUSH
72497: DOUBLE
72498: LD_INT 1
72500: DEC
72501: ST_TO_ADDR
72502: LD_VAR 0 1
72506: PUSH
72507: FOR_TO
72508: IFFALSE 72544
// if value = array [ i ] then
72510: LD_VAR 0 2
72514: PUSH
72515: LD_VAR 0 1
72519: PUSH
72520: LD_VAR 0 4
72524: ARRAY
72525: EQUAL
72526: IFFALSE 72542
// begin result := i ;
72528: LD_ADDR_VAR 0 3
72532: PUSH
72533: LD_VAR 0 4
72537: ST_TO_ADDR
// exit ;
72538: POP
72539: POP
72540: GO 72546
// end ;
72542: GO 72507
72544: POP
72545: POP
// end ;
72546: LD_VAR 0 3
72550: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72551: LD_INT 0
72553: PPUSH
// vc_chassis := chassis ;
72554: LD_ADDR_OWVAR 37
72558: PUSH
72559: LD_VAR 0 1
72563: ST_TO_ADDR
// vc_engine := engine ;
72564: LD_ADDR_OWVAR 39
72568: PUSH
72569: LD_VAR 0 2
72573: ST_TO_ADDR
// vc_control := control ;
72574: LD_ADDR_OWVAR 38
72578: PUSH
72579: LD_VAR 0 3
72583: ST_TO_ADDR
// vc_weapon := weapon ;
72584: LD_ADDR_OWVAR 40
72588: PUSH
72589: LD_VAR 0 4
72593: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72594: LD_ADDR_OWVAR 41
72598: PUSH
72599: LD_VAR 0 5
72603: ST_TO_ADDR
// end ;
72604: LD_VAR 0 6
72608: RET
// export function WantPlant ( unit ) ; var task ; begin
72609: LD_INT 0
72611: PPUSH
72612: PPUSH
// result := false ;
72613: LD_ADDR_VAR 0 2
72617: PUSH
72618: LD_INT 0
72620: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72621: LD_ADDR_VAR 0 3
72625: PUSH
72626: LD_VAR 0 1
72630: PPUSH
72631: CALL_OW 437
72635: ST_TO_ADDR
// if task then
72636: LD_VAR 0 3
72640: IFFALSE 72668
// if task [ 1 ] [ 1 ] = p then
72642: LD_VAR 0 3
72646: PUSH
72647: LD_INT 1
72649: ARRAY
72650: PUSH
72651: LD_INT 1
72653: ARRAY
72654: PUSH
72655: LD_STRING p
72657: EQUAL
72658: IFFALSE 72668
// result := true ;
72660: LD_ADDR_VAR 0 2
72664: PUSH
72665: LD_INT 1
72667: ST_TO_ADDR
// end ;
72668: LD_VAR 0 2
72672: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72673: LD_INT 0
72675: PPUSH
72676: PPUSH
72677: PPUSH
72678: PPUSH
// if pos < 1 then
72679: LD_VAR 0 2
72683: PUSH
72684: LD_INT 1
72686: LESS
72687: IFFALSE 72691
// exit ;
72689: GO 72994
// if pos = 1 then
72691: LD_VAR 0 2
72695: PUSH
72696: LD_INT 1
72698: EQUAL
72699: IFFALSE 72732
// result := Replace ( arr , pos [ 1 ] , value ) else
72701: LD_ADDR_VAR 0 4
72705: PUSH
72706: LD_VAR 0 1
72710: PPUSH
72711: LD_VAR 0 2
72715: PUSH
72716: LD_INT 1
72718: ARRAY
72719: PPUSH
72720: LD_VAR 0 3
72724: PPUSH
72725: CALL_OW 1
72729: ST_TO_ADDR
72730: GO 72994
// begin tmp := arr ;
72732: LD_ADDR_VAR 0 6
72736: PUSH
72737: LD_VAR 0 1
72741: ST_TO_ADDR
// s_arr := [ tmp ] ;
72742: LD_ADDR_VAR 0 7
72746: PUSH
72747: LD_VAR 0 6
72751: PUSH
72752: EMPTY
72753: LIST
72754: ST_TO_ADDR
// for i = 1 to pos - 1 do
72755: LD_ADDR_VAR 0 5
72759: PUSH
72760: DOUBLE
72761: LD_INT 1
72763: DEC
72764: ST_TO_ADDR
72765: LD_VAR 0 2
72769: PUSH
72770: LD_INT 1
72772: MINUS
72773: PUSH
72774: FOR_TO
72775: IFFALSE 72820
// begin tmp := tmp [ pos [ i ] ] ;
72777: LD_ADDR_VAR 0 6
72781: PUSH
72782: LD_VAR 0 6
72786: PUSH
72787: LD_VAR 0 2
72791: PUSH
72792: LD_VAR 0 5
72796: ARRAY
72797: ARRAY
72798: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72799: LD_ADDR_VAR 0 7
72803: PUSH
72804: LD_VAR 0 7
72808: PUSH
72809: LD_VAR 0 6
72813: PUSH
72814: EMPTY
72815: LIST
72816: ADD
72817: ST_TO_ADDR
// end ;
72818: GO 72774
72820: POP
72821: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72822: LD_ADDR_VAR 0 6
72826: PUSH
72827: LD_VAR 0 6
72831: PPUSH
72832: LD_VAR 0 2
72836: PUSH
72837: LD_VAR 0 2
72841: ARRAY
72842: PPUSH
72843: LD_VAR 0 3
72847: PPUSH
72848: CALL_OW 1
72852: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72853: LD_ADDR_VAR 0 7
72857: PUSH
72858: LD_VAR 0 7
72862: PPUSH
72863: LD_VAR 0 7
72867: PPUSH
72868: LD_VAR 0 6
72872: PPUSH
72873: CALL_OW 1
72877: ST_TO_ADDR
// for i = s_arr downto 2 do
72878: LD_ADDR_VAR 0 5
72882: PUSH
72883: DOUBLE
72884: LD_VAR 0 7
72888: INC
72889: ST_TO_ADDR
72890: LD_INT 2
72892: PUSH
72893: FOR_DOWNTO
72894: IFFALSE 72978
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72896: LD_ADDR_VAR 0 6
72900: PUSH
72901: LD_VAR 0 7
72905: PUSH
72906: LD_VAR 0 5
72910: PUSH
72911: LD_INT 1
72913: MINUS
72914: ARRAY
72915: PPUSH
72916: LD_VAR 0 2
72920: PUSH
72921: LD_VAR 0 5
72925: PUSH
72926: LD_INT 1
72928: MINUS
72929: ARRAY
72930: PPUSH
72931: LD_VAR 0 7
72935: PUSH
72936: LD_VAR 0 5
72940: ARRAY
72941: PPUSH
72942: CALL_OW 1
72946: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72947: LD_ADDR_VAR 0 7
72951: PUSH
72952: LD_VAR 0 7
72956: PPUSH
72957: LD_VAR 0 5
72961: PUSH
72962: LD_INT 1
72964: MINUS
72965: PPUSH
72966: LD_VAR 0 6
72970: PPUSH
72971: CALL_OW 1
72975: ST_TO_ADDR
// end ;
72976: GO 72893
72978: POP
72979: POP
// result := s_arr [ 1 ] ;
72980: LD_ADDR_VAR 0 4
72984: PUSH
72985: LD_VAR 0 7
72989: PUSH
72990: LD_INT 1
72992: ARRAY
72993: ST_TO_ADDR
// end ; end ;
72994: LD_VAR 0 4
72998: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72999: LD_INT 0
73001: PPUSH
73002: PPUSH
// if not list then
73003: LD_VAR 0 1
73007: NOT
73008: IFFALSE 73012
// exit ;
73010: GO 73103
// i := list [ pos1 ] ;
73012: LD_ADDR_VAR 0 5
73016: PUSH
73017: LD_VAR 0 1
73021: PUSH
73022: LD_VAR 0 2
73026: ARRAY
73027: ST_TO_ADDR
// if not i then
73028: LD_VAR 0 5
73032: NOT
73033: IFFALSE 73037
// exit ;
73035: GO 73103
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
73037: LD_ADDR_VAR 0 1
73041: PUSH
73042: LD_VAR 0 1
73046: PPUSH
73047: LD_VAR 0 2
73051: PPUSH
73052: LD_VAR 0 1
73056: PUSH
73057: LD_VAR 0 3
73061: ARRAY
73062: PPUSH
73063: CALL_OW 1
73067: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
73068: LD_ADDR_VAR 0 1
73072: PUSH
73073: LD_VAR 0 1
73077: PPUSH
73078: LD_VAR 0 3
73082: PPUSH
73083: LD_VAR 0 5
73087: PPUSH
73088: CALL_OW 1
73092: ST_TO_ADDR
// result := list ;
73093: LD_ADDR_VAR 0 4
73097: PUSH
73098: LD_VAR 0 1
73102: ST_TO_ADDR
// end ;
73103: LD_VAR 0 4
73107: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
73108: LD_INT 0
73110: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
73111: LD_ADDR_VAR 0 5
73115: PUSH
73116: LD_VAR 0 1
73120: PPUSH
73121: CALL_OW 250
73125: PPUSH
73126: LD_VAR 0 1
73130: PPUSH
73131: CALL_OW 251
73135: PPUSH
73136: LD_VAR 0 2
73140: PPUSH
73141: LD_VAR 0 3
73145: PPUSH
73146: LD_VAR 0 4
73150: PPUSH
73151: CALL 73161 0 5
73155: ST_TO_ADDR
// end ;
73156: LD_VAR 0 5
73160: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
73161: LD_INT 0
73163: PPUSH
73164: PPUSH
73165: PPUSH
73166: PPUSH
// if not list then
73167: LD_VAR 0 3
73171: NOT
73172: IFFALSE 73176
// exit ;
73174: GO 73564
// result := [ ] ;
73176: LD_ADDR_VAR 0 6
73180: PUSH
73181: EMPTY
73182: ST_TO_ADDR
// for i in list do
73183: LD_ADDR_VAR 0 7
73187: PUSH
73188: LD_VAR 0 3
73192: PUSH
73193: FOR_IN
73194: IFFALSE 73396
// begin tmp := GetDistUnitXY ( i , x , y ) ;
73196: LD_ADDR_VAR 0 9
73200: PUSH
73201: LD_VAR 0 7
73205: PPUSH
73206: LD_VAR 0 1
73210: PPUSH
73211: LD_VAR 0 2
73215: PPUSH
73216: CALL_OW 297
73220: ST_TO_ADDR
// if not result then
73221: LD_VAR 0 6
73225: NOT
73226: IFFALSE 73252
// result := [ [ i , tmp ] ] else
73228: LD_ADDR_VAR 0 6
73232: PUSH
73233: LD_VAR 0 7
73237: PUSH
73238: LD_VAR 0 9
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: EMPTY
73248: LIST
73249: ST_TO_ADDR
73250: GO 73394
// begin if result [ result ] [ 2 ] < tmp then
73252: LD_VAR 0 6
73256: PUSH
73257: LD_VAR 0 6
73261: ARRAY
73262: PUSH
73263: LD_INT 2
73265: ARRAY
73266: PUSH
73267: LD_VAR 0 9
73271: LESS
73272: IFFALSE 73314
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
73274: LD_ADDR_VAR 0 6
73278: PUSH
73279: LD_VAR 0 6
73283: PPUSH
73284: LD_VAR 0 6
73288: PUSH
73289: LD_INT 1
73291: PLUS
73292: PPUSH
73293: LD_VAR 0 7
73297: PUSH
73298: LD_VAR 0 9
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PPUSH
73307: CALL_OW 2
73311: ST_TO_ADDR
73312: GO 73394
// for j = 1 to result do
73314: LD_ADDR_VAR 0 8
73318: PUSH
73319: DOUBLE
73320: LD_INT 1
73322: DEC
73323: ST_TO_ADDR
73324: LD_VAR 0 6
73328: PUSH
73329: FOR_TO
73330: IFFALSE 73392
// begin if tmp < result [ j ] [ 2 ] then
73332: LD_VAR 0 9
73336: PUSH
73337: LD_VAR 0 6
73341: PUSH
73342: LD_VAR 0 8
73346: ARRAY
73347: PUSH
73348: LD_INT 2
73350: ARRAY
73351: LESS
73352: IFFALSE 73390
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73354: LD_ADDR_VAR 0 6
73358: PUSH
73359: LD_VAR 0 6
73363: PPUSH
73364: LD_VAR 0 8
73368: PPUSH
73369: LD_VAR 0 7
73373: PUSH
73374: LD_VAR 0 9
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PPUSH
73383: CALL_OW 2
73387: ST_TO_ADDR
// break ;
73388: GO 73392
// end ; end ;
73390: GO 73329
73392: POP
73393: POP
// end ; end ;
73394: GO 73193
73396: POP
73397: POP
// if result and not asc then
73398: LD_VAR 0 6
73402: PUSH
73403: LD_VAR 0 4
73407: NOT
73408: AND
73409: IFFALSE 73484
// begin tmp := result ;
73411: LD_ADDR_VAR 0 9
73415: PUSH
73416: LD_VAR 0 6
73420: ST_TO_ADDR
// for i = tmp downto 1 do
73421: LD_ADDR_VAR 0 7
73425: PUSH
73426: DOUBLE
73427: LD_VAR 0 9
73431: INC
73432: ST_TO_ADDR
73433: LD_INT 1
73435: PUSH
73436: FOR_DOWNTO
73437: IFFALSE 73482
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73439: LD_ADDR_VAR 0 6
73443: PUSH
73444: LD_VAR 0 6
73448: PPUSH
73449: LD_VAR 0 9
73453: PUSH
73454: LD_VAR 0 7
73458: MINUS
73459: PUSH
73460: LD_INT 1
73462: PLUS
73463: PPUSH
73464: LD_VAR 0 9
73468: PUSH
73469: LD_VAR 0 7
73473: ARRAY
73474: PPUSH
73475: CALL_OW 1
73479: ST_TO_ADDR
73480: GO 73436
73482: POP
73483: POP
// end ; tmp := [ ] ;
73484: LD_ADDR_VAR 0 9
73488: PUSH
73489: EMPTY
73490: ST_TO_ADDR
// if mode then
73491: LD_VAR 0 5
73495: IFFALSE 73564
// begin for i = 1 to result do
73497: LD_ADDR_VAR 0 7
73501: PUSH
73502: DOUBLE
73503: LD_INT 1
73505: DEC
73506: ST_TO_ADDR
73507: LD_VAR 0 6
73511: PUSH
73512: FOR_TO
73513: IFFALSE 73552
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73515: LD_ADDR_VAR 0 9
73519: PUSH
73520: LD_VAR 0 9
73524: PPUSH
73525: LD_VAR 0 7
73529: PPUSH
73530: LD_VAR 0 6
73534: PUSH
73535: LD_VAR 0 7
73539: ARRAY
73540: PUSH
73541: LD_INT 1
73543: ARRAY
73544: PPUSH
73545: CALL_OW 1
73549: ST_TO_ADDR
73550: GO 73512
73552: POP
73553: POP
// result := tmp ;
73554: LD_ADDR_VAR 0 6
73558: PUSH
73559: LD_VAR 0 9
73563: ST_TO_ADDR
// end ; end ;
73564: LD_VAR 0 6
73568: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73569: LD_INT 0
73571: PPUSH
73572: PPUSH
73573: PPUSH
73574: PPUSH
73575: PPUSH
73576: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73577: LD_ADDR_VAR 0 5
73581: PUSH
73582: LD_INT 0
73584: PUSH
73585: LD_INT 0
73587: PUSH
73588: LD_INT 0
73590: PUSH
73591: EMPTY
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: ST_TO_ADDR
// if not x or not y then
73599: LD_VAR 0 2
73603: NOT
73604: PUSH
73605: LD_VAR 0 3
73609: NOT
73610: OR
73611: IFFALSE 73615
// exit ;
73613: GO 75265
// if not range then
73615: LD_VAR 0 4
73619: NOT
73620: IFFALSE 73630
// range := 10 ;
73622: LD_ADDR_VAR 0 4
73626: PUSH
73627: LD_INT 10
73629: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73630: LD_ADDR_VAR 0 8
73634: PUSH
73635: LD_INT 81
73637: PUSH
73638: LD_VAR 0 1
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 92
73649: PUSH
73650: LD_VAR 0 2
73654: PUSH
73655: LD_VAR 0 3
73659: PUSH
73660: LD_VAR 0 4
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 3
73673: PUSH
73674: LD_INT 21
73676: PUSH
73677: LD_INT 3
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: LIST
73692: PPUSH
73693: CALL_OW 69
73697: ST_TO_ADDR
// if not tmp then
73698: LD_VAR 0 8
73702: NOT
73703: IFFALSE 73707
// exit ;
73705: GO 75265
// for i in tmp do
73707: LD_ADDR_VAR 0 6
73711: PUSH
73712: LD_VAR 0 8
73716: PUSH
73717: FOR_IN
73718: IFFALSE 75240
// begin points := [ 0 , 0 , 0 ] ;
73720: LD_ADDR_VAR 0 9
73724: PUSH
73725: LD_INT 0
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: LIST
73738: ST_TO_ADDR
// bpoints := 1 ;
73739: LD_ADDR_VAR 0 10
73743: PUSH
73744: LD_INT 1
73746: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73747: LD_VAR 0 6
73751: PPUSH
73752: CALL_OW 247
73756: PUSH
73757: LD_INT 1
73759: DOUBLE
73760: EQUAL
73761: IFTRUE 73765
73763: GO 74343
73765: POP
// begin if GetClass ( i ) = 1 then
73766: LD_VAR 0 6
73770: PPUSH
73771: CALL_OW 257
73775: PUSH
73776: LD_INT 1
73778: EQUAL
73779: IFFALSE 73800
// points := [ 10 , 5 , 3 ] ;
73781: LD_ADDR_VAR 0 9
73785: PUSH
73786: LD_INT 10
73788: PUSH
73789: LD_INT 5
73791: PUSH
73792: LD_INT 3
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: LIST
73799: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73800: LD_VAR 0 6
73804: PPUSH
73805: CALL_OW 257
73809: PUSH
73810: LD_INT 2
73812: PUSH
73813: LD_INT 3
73815: PUSH
73816: LD_INT 4
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: LIST
73823: IN
73824: IFFALSE 73845
// points := [ 3 , 2 , 1 ] ;
73826: LD_ADDR_VAR 0 9
73830: PUSH
73831: LD_INT 3
73833: PUSH
73834: LD_INT 2
73836: PUSH
73837: LD_INT 1
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: LIST
73844: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73845: LD_VAR 0 6
73849: PPUSH
73850: CALL_OW 257
73854: PUSH
73855: LD_INT 5
73857: EQUAL
73858: IFFALSE 73879
// points := [ 130 , 5 , 2 ] ;
73860: LD_ADDR_VAR 0 9
73864: PUSH
73865: LD_INT 130
73867: PUSH
73868: LD_INT 5
73870: PUSH
73871: LD_INT 2
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: LIST
73878: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73879: LD_VAR 0 6
73883: PPUSH
73884: CALL_OW 257
73888: PUSH
73889: LD_INT 8
73891: EQUAL
73892: IFFALSE 73913
// points := [ 35 , 35 , 30 ] ;
73894: LD_ADDR_VAR 0 9
73898: PUSH
73899: LD_INT 35
73901: PUSH
73902: LD_INT 35
73904: PUSH
73905: LD_INT 30
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: LIST
73912: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73913: LD_VAR 0 6
73917: PPUSH
73918: CALL_OW 257
73922: PUSH
73923: LD_INT 9
73925: EQUAL
73926: IFFALSE 73947
// points := [ 20 , 55 , 40 ] ;
73928: LD_ADDR_VAR 0 9
73932: PUSH
73933: LD_INT 20
73935: PUSH
73936: LD_INT 55
73938: PUSH
73939: LD_INT 40
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: LIST
73946: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73947: LD_VAR 0 6
73951: PPUSH
73952: CALL_OW 257
73956: PUSH
73957: LD_INT 12
73959: PUSH
73960: LD_INT 16
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: IN
73967: IFFALSE 73988
// points := [ 5 , 3 , 2 ] ;
73969: LD_ADDR_VAR 0 9
73973: PUSH
73974: LD_INT 5
73976: PUSH
73977: LD_INT 3
73979: PUSH
73980: LD_INT 2
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: LIST
73987: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73988: LD_VAR 0 6
73992: PPUSH
73993: CALL_OW 257
73997: PUSH
73998: LD_INT 17
74000: EQUAL
74001: IFFALSE 74022
// points := [ 100 , 50 , 75 ] ;
74003: LD_ADDR_VAR 0 9
74007: PUSH
74008: LD_INT 100
74010: PUSH
74011: LD_INT 50
74013: PUSH
74014: LD_INT 75
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: LIST
74021: ST_TO_ADDR
// if GetClass ( i ) = 15 then
74022: LD_VAR 0 6
74026: PPUSH
74027: CALL_OW 257
74031: PUSH
74032: LD_INT 15
74034: EQUAL
74035: IFFALSE 74056
// points := [ 10 , 5 , 3 ] ;
74037: LD_ADDR_VAR 0 9
74041: PUSH
74042: LD_INT 10
74044: PUSH
74045: LD_INT 5
74047: PUSH
74048: LD_INT 3
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: LIST
74055: ST_TO_ADDR
// if GetClass ( i ) = 14 then
74056: LD_VAR 0 6
74060: PPUSH
74061: CALL_OW 257
74065: PUSH
74066: LD_INT 14
74068: EQUAL
74069: IFFALSE 74090
// points := [ 10 , 0 , 0 ] ;
74071: LD_ADDR_VAR 0 9
74075: PUSH
74076: LD_INT 10
74078: PUSH
74079: LD_INT 0
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: LIST
74089: ST_TO_ADDR
// if GetClass ( i ) = 11 then
74090: LD_VAR 0 6
74094: PPUSH
74095: CALL_OW 257
74099: PUSH
74100: LD_INT 11
74102: EQUAL
74103: IFFALSE 74124
// points := [ 30 , 10 , 5 ] ;
74105: LD_ADDR_VAR 0 9
74109: PUSH
74110: LD_INT 30
74112: PUSH
74113: LD_INT 10
74115: PUSH
74116: LD_INT 5
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: LIST
74123: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
74124: LD_VAR 0 1
74128: PPUSH
74129: LD_INT 5
74131: PPUSH
74132: CALL_OW 321
74136: PUSH
74137: LD_INT 2
74139: EQUAL
74140: IFFALSE 74157
// bpoints := bpoints * 1.8 ;
74142: LD_ADDR_VAR 0 10
74146: PUSH
74147: LD_VAR 0 10
74151: PUSH
74152: LD_REAL  1.80000000000000E+0000
74155: MUL
74156: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
74157: LD_VAR 0 6
74161: PPUSH
74162: CALL_OW 257
74166: PUSH
74167: LD_INT 1
74169: PUSH
74170: LD_INT 2
74172: PUSH
74173: LD_INT 3
74175: PUSH
74176: LD_INT 4
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: LIST
74183: LIST
74184: IN
74185: PUSH
74186: LD_VAR 0 1
74190: PPUSH
74191: LD_INT 51
74193: PPUSH
74194: CALL_OW 321
74198: PUSH
74199: LD_INT 2
74201: EQUAL
74202: AND
74203: IFFALSE 74220
// bpoints := bpoints * 1.2 ;
74205: LD_ADDR_VAR 0 10
74209: PUSH
74210: LD_VAR 0 10
74214: PUSH
74215: LD_REAL  1.20000000000000E+0000
74218: MUL
74219: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
74220: LD_VAR 0 6
74224: PPUSH
74225: CALL_OW 257
74229: PUSH
74230: LD_INT 5
74232: PUSH
74233: LD_INT 7
74235: PUSH
74236: LD_INT 9
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: LIST
74243: IN
74244: PUSH
74245: LD_VAR 0 1
74249: PPUSH
74250: LD_INT 52
74252: PPUSH
74253: CALL_OW 321
74257: PUSH
74258: LD_INT 2
74260: EQUAL
74261: AND
74262: IFFALSE 74279
// bpoints := bpoints * 1.5 ;
74264: LD_ADDR_VAR 0 10
74268: PUSH
74269: LD_VAR 0 10
74273: PUSH
74274: LD_REAL  1.50000000000000E+0000
74277: MUL
74278: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
74279: LD_VAR 0 1
74283: PPUSH
74284: LD_INT 66
74286: PPUSH
74287: CALL_OW 321
74291: PUSH
74292: LD_INT 2
74294: EQUAL
74295: IFFALSE 74312
// bpoints := bpoints * 1.1 ;
74297: LD_ADDR_VAR 0 10
74301: PUSH
74302: LD_VAR 0 10
74306: PUSH
74307: LD_REAL  1.10000000000000E+0000
74310: MUL
74311: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74312: LD_ADDR_VAR 0 10
74316: PUSH
74317: LD_VAR 0 10
74321: PUSH
74322: LD_VAR 0 6
74326: PPUSH
74327: LD_INT 1
74329: PPUSH
74330: CALL_OW 259
74334: PUSH
74335: LD_REAL  1.15000000000000E+0000
74338: MUL
74339: MUL
74340: ST_TO_ADDR
// end ; unit_vehicle :
74341: GO 75169
74343: LD_INT 2
74345: DOUBLE
74346: EQUAL
74347: IFTRUE 74351
74349: GO 75157
74351: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74352: LD_VAR 0 6
74356: PPUSH
74357: CALL_OW 264
74361: PUSH
74362: LD_INT 2
74364: PUSH
74365: LD_INT 42
74367: PUSH
74368: LD_INT 24
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: LIST
74375: IN
74376: IFFALSE 74397
// points := [ 25 , 5 , 3 ] ;
74378: LD_ADDR_VAR 0 9
74382: PUSH
74383: LD_INT 25
74385: PUSH
74386: LD_INT 5
74388: PUSH
74389: LD_INT 3
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: LIST
74396: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74397: LD_VAR 0 6
74401: PPUSH
74402: CALL_OW 264
74406: PUSH
74407: LD_INT 4
74409: PUSH
74410: LD_INT 43
74412: PUSH
74413: LD_INT 25
74415: PUSH
74416: EMPTY
74417: LIST
74418: LIST
74419: LIST
74420: IN
74421: IFFALSE 74442
// points := [ 40 , 15 , 5 ] ;
74423: LD_ADDR_VAR 0 9
74427: PUSH
74428: LD_INT 40
74430: PUSH
74431: LD_INT 15
74433: PUSH
74434: LD_INT 5
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: LIST
74441: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74442: LD_VAR 0 6
74446: PPUSH
74447: CALL_OW 264
74451: PUSH
74452: LD_INT 3
74454: PUSH
74455: LD_INT 23
74457: PUSH
74458: EMPTY
74459: LIST
74460: LIST
74461: IN
74462: IFFALSE 74483
// points := [ 7 , 25 , 8 ] ;
74464: LD_ADDR_VAR 0 9
74468: PUSH
74469: LD_INT 7
74471: PUSH
74472: LD_INT 25
74474: PUSH
74475: LD_INT 8
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: LIST
74482: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74483: LD_VAR 0 6
74487: PPUSH
74488: CALL_OW 264
74492: PUSH
74493: LD_INT 5
74495: PUSH
74496: LD_INT 27
74498: PUSH
74499: LD_INT 44
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: LIST
74506: IN
74507: IFFALSE 74528
// points := [ 14 , 50 , 16 ] ;
74509: LD_ADDR_VAR 0 9
74513: PUSH
74514: LD_INT 14
74516: PUSH
74517: LD_INT 50
74519: PUSH
74520: LD_INT 16
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: LIST
74527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74528: LD_VAR 0 6
74532: PPUSH
74533: CALL_OW 264
74537: PUSH
74538: LD_INT 6
74540: PUSH
74541: LD_INT 46
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: IN
74548: IFFALSE 74569
// points := [ 32 , 120 , 70 ] ;
74550: LD_ADDR_VAR 0 9
74554: PUSH
74555: LD_INT 32
74557: PUSH
74558: LD_INT 120
74560: PUSH
74561: LD_INT 70
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: LIST
74568: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74569: LD_VAR 0 6
74573: PPUSH
74574: CALL_OW 264
74578: PUSH
74579: LD_INT 7
74581: PUSH
74582: LD_INT 28
74584: PUSH
74585: LD_INT 45
74587: PUSH
74588: LD_INT 92
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: LIST
74595: LIST
74596: IN
74597: IFFALSE 74618
// points := [ 35 , 20 , 45 ] ;
74599: LD_ADDR_VAR 0 9
74603: PUSH
74604: LD_INT 35
74606: PUSH
74607: LD_INT 20
74609: PUSH
74610: LD_INT 45
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: LIST
74617: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74618: LD_VAR 0 6
74622: PPUSH
74623: CALL_OW 264
74627: PUSH
74628: LD_INT 47
74630: PUSH
74631: EMPTY
74632: LIST
74633: IN
74634: IFFALSE 74655
// points := [ 67 , 45 , 75 ] ;
74636: LD_ADDR_VAR 0 9
74640: PUSH
74641: LD_INT 67
74643: PUSH
74644: LD_INT 45
74646: PUSH
74647: LD_INT 75
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: LIST
74654: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74655: LD_VAR 0 6
74659: PPUSH
74660: CALL_OW 264
74664: PUSH
74665: LD_INT 26
74667: PUSH
74668: EMPTY
74669: LIST
74670: IN
74671: IFFALSE 74692
// points := [ 120 , 30 , 80 ] ;
74673: LD_ADDR_VAR 0 9
74677: PUSH
74678: LD_INT 120
74680: PUSH
74681: LD_INT 30
74683: PUSH
74684: LD_INT 80
74686: PUSH
74687: EMPTY
74688: LIST
74689: LIST
74690: LIST
74691: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74692: LD_VAR 0 6
74696: PPUSH
74697: CALL_OW 264
74701: PUSH
74702: LD_INT 22
74704: PUSH
74705: EMPTY
74706: LIST
74707: IN
74708: IFFALSE 74729
// points := [ 40 , 1 , 1 ] ;
74710: LD_ADDR_VAR 0 9
74714: PUSH
74715: LD_INT 40
74717: PUSH
74718: LD_INT 1
74720: PUSH
74721: LD_INT 1
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: LIST
74728: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74729: LD_VAR 0 6
74733: PPUSH
74734: CALL_OW 264
74738: PUSH
74739: LD_INT 29
74741: PUSH
74742: EMPTY
74743: LIST
74744: IN
74745: IFFALSE 74766
// points := [ 70 , 200 , 400 ] ;
74747: LD_ADDR_VAR 0 9
74751: PUSH
74752: LD_INT 70
74754: PUSH
74755: LD_INT 200
74757: PUSH
74758: LD_INT 400
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: LIST
74765: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74766: LD_VAR 0 6
74770: PPUSH
74771: CALL_OW 264
74775: PUSH
74776: LD_INT 14
74778: PUSH
74779: LD_INT 53
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: IN
74786: IFFALSE 74807
// points := [ 40 , 10 , 20 ] ;
74788: LD_ADDR_VAR 0 9
74792: PUSH
74793: LD_INT 40
74795: PUSH
74796: LD_INT 10
74798: PUSH
74799: LD_INT 20
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: LIST
74806: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74807: LD_VAR 0 6
74811: PPUSH
74812: CALL_OW 264
74816: PUSH
74817: LD_INT 9
74819: PUSH
74820: EMPTY
74821: LIST
74822: IN
74823: IFFALSE 74844
// points := [ 5 , 70 , 20 ] ;
74825: LD_ADDR_VAR 0 9
74829: PUSH
74830: LD_INT 5
74832: PUSH
74833: LD_INT 70
74835: PUSH
74836: LD_INT 20
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: LIST
74843: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74844: LD_VAR 0 6
74848: PPUSH
74849: CALL_OW 264
74853: PUSH
74854: LD_INT 10
74856: PUSH
74857: EMPTY
74858: LIST
74859: IN
74860: IFFALSE 74881
// points := [ 35 , 110 , 70 ] ;
74862: LD_ADDR_VAR 0 9
74866: PUSH
74867: LD_INT 35
74869: PUSH
74870: LD_INT 110
74872: PUSH
74873: LD_INT 70
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: LIST
74880: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74881: LD_VAR 0 6
74885: PPUSH
74886: CALL_OW 265
74890: PUSH
74891: LD_INT 25
74893: EQUAL
74894: IFFALSE 74915
// points := [ 80 , 65 , 100 ] ;
74896: LD_ADDR_VAR 0 9
74900: PUSH
74901: LD_INT 80
74903: PUSH
74904: LD_INT 65
74906: PUSH
74907: LD_INT 100
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: LIST
74914: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74915: LD_VAR 0 6
74919: PPUSH
74920: CALL_OW 263
74924: PUSH
74925: LD_INT 1
74927: EQUAL
74928: IFFALSE 74963
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74930: LD_ADDR_VAR 0 10
74934: PUSH
74935: LD_VAR 0 10
74939: PUSH
74940: LD_VAR 0 6
74944: PPUSH
74945: CALL_OW 311
74949: PPUSH
74950: LD_INT 3
74952: PPUSH
74953: CALL_OW 259
74957: PUSH
74958: LD_INT 4
74960: MUL
74961: MUL
74962: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74963: LD_VAR 0 6
74967: PPUSH
74968: CALL_OW 263
74972: PUSH
74973: LD_INT 2
74975: EQUAL
74976: IFFALSE 75027
// begin j := IsControledBy ( i ) ;
74978: LD_ADDR_VAR 0 7
74982: PUSH
74983: LD_VAR 0 6
74987: PPUSH
74988: CALL_OW 312
74992: ST_TO_ADDR
// if j then
74993: LD_VAR 0 7
74997: IFFALSE 75027
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74999: LD_ADDR_VAR 0 10
75003: PUSH
75004: LD_VAR 0 10
75008: PUSH
75009: LD_VAR 0 7
75013: PPUSH
75014: LD_INT 3
75016: PPUSH
75017: CALL_OW 259
75021: PUSH
75022: LD_INT 3
75024: MUL
75025: MUL
75026: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
75027: LD_VAR 0 6
75031: PPUSH
75032: CALL_OW 264
75036: PUSH
75037: LD_INT 5
75039: PUSH
75040: LD_INT 6
75042: PUSH
75043: LD_INT 46
75045: PUSH
75046: LD_INT 44
75048: PUSH
75049: LD_INT 47
75051: PUSH
75052: LD_INT 45
75054: PUSH
75055: LD_INT 28
75057: PUSH
75058: LD_INT 7
75060: PUSH
75061: LD_INT 27
75063: PUSH
75064: LD_INT 29
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: IN
75079: PUSH
75080: LD_VAR 0 1
75084: PPUSH
75085: LD_INT 52
75087: PPUSH
75088: CALL_OW 321
75092: PUSH
75093: LD_INT 2
75095: EQUAL
75096: AND
75097: IFFALSE 75114
// bpoints := bpoints * 1.2 ;
75099: LD_ADDR_VAR 0 10
75103: PUSH
75104: LD_VAR 0 10
75108: PUSH
75109: LD_REAL  1.20000000000000E+0000
75112: MUL
75113: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
75114: LD_VAR 0 6
75118: PPUSH
75119: CALL_OW 264
75123: PUSH
75124: LD_INT 6
75126: PUSH
75127: LD_INT 46
75129: PUSH
75130: LD_INT 47
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: LIST
75137: IN
75138: IFFALSE 75155
// bpoints := bpoints * 1.2 ;
75140: LD_ADDR_VAR 0 10
75144: PUSH
75145: LD_VAR 0 10
75149: PUSH
75150: LD_REAL  1.20000000000000E+0000
75153: MUL
75154: ST_TO_ADDR
// end ; unit_building :
75155: GO 75169
75157: LD_INT 3
75159: DOUBLE
75160: EQUAL
75161: IFTRUE 75165
75163: GO 75168
75165: POP
// ; end ;
75166: GO 75169
75168: POP
// for j = 1 to 3 do
75169: LD_ADDR_VAR 0 7
75173: PUSH
75174: DOUBLE
75175: LD_INT 1
75177: DEC
75178: ST_TO_ADDR
75179: LD_INT 3
75181: PUSH
75182: FOR_TO
75183: IFFALSE 75236
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
75185: LD_ADDR_VAR 0 5
75189: PUSH
75190: LD_VAR 0 5
75194: PPUSH
75195: LD_VAR 0 7
75199: PPUSH
75200: LD_VAR 0 5
75204: PUSH
75205: LD_VAR 0 7
75209: ARRAY
75210: PUSH
75211: LD_VAR 0 9
75215: PUSH
75216: LD_VAR 0 7
75220: ARRAY
75221: PUSH
75222: LD_VAR 0 10
75226: MUL
75227: PLUS
75228: PPUSH
75229: CALL_OW 1
75233: ST_TO_ADDR
75234: GO 75182
75236: POP
75237: POP
// end ;
75238: GO 73717
75240: POP
75241: POP
// result := Replace ( result , 4 , tmp ) ;
75242: LD_ADDR_VAR 0 5
75246: PUSH
75247: LD_VAR 0 5
75251: PPUSH
75252: LD_INT 4
75254: PPUSH
75255: LD_VAR 0 8
75259: PPUSH
75260: CALL_OW 1
75264: ST_TO_ADDR
// end ;
75265: LD_VAR 0 5
75269: RET
// export function DangerAtRange ( unit , range ) ; begin
75270: LD_INT 0
75272: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
75273: LD_ADDR_VAR 0 3
75277: PUSH
75278: LD_VAR 0 1
75282: PPUSH
75283: CALL_OW 255
75287: PPUSH
75288: LD_VAR 0 1
75292: PPUSH
75293: CALL_OW 250
75297: PPUSH
75298: LD_VAR 0 1
75302: PPUSH
75303: CALL_OW 251
75307: PPUSH
75308: LD_VAR 0 2
75312: PPUSH
75313: CALL 73569 0 4
75317: ST_TO_ADDR
// end ;
75318: LD_VAR 0 3
75322: RET
// export function DangerInArea ( side , area ) ; begin
75323: LD_INT 0
75325: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75326: LD_ADDR_VAR 0 3
75330: PUSH
75331: LD_VAR 0 2
75335: PPUSH
75336: LD_INT 81
75338: PUSH
75339: LD_VAR 0 1
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PPUSH
75348: CALL_OW 70
75352: ST_TO_ADDR
// end ;
75353: LD_VAR 0 3
75357: RET
// export function IsExtension ( b ) ; begin
75358: LD_INT 0
75360: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75361: LD_ADDR_VAR 0 2
75365: PUSH
75366: LD_VAR 0 1
75370: PUSH
75371: LD_INT 23
75373: PUSH
75374: LD_INT 20
75376: PUSH
75377: LD_INT 22
75379: PUSH
75380: LD_INT 17
75382: PUSH
75383: LD_INT 24
75385: PUSH
75386: LD_INT 21
75388: PUSH
75389: LD_INT 19
75391: PUSH
75392: LD_INT 16
75394: PUSH
75395: LD_INT 25
75397: PUSH
75398: LD_INT 18
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: LIST
75410: LIST
75411: LIST
75412: IN
75413: ST_TO_ADDR
// end ;
75414: LD_VAR 0 2
75418: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75419: LD_INT 0
75421: PPUSH
75422: PPUSH
75423: PPUSH
// result := [ ] ;
75424: LD_ADDR_VAR 0 4
75428: PUSH
75429: EMPTY
75430: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75431: LD_ADDR_VAR 0 5
75435: PUSH
75436: LD_VAR 0 2
75440: PPUSH
75441: LD_INT 21
75443: PUSH
75444: LD_INT 3
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PPUSH
75451: CALL_OW 70
75455: ST_TO_ADDR
// if not tmp then
75456: LD_VAR 0 5
75460: NOT
75461: IFFALSE 75465
// exit ;
75463: GO 75529
// if checkLink then
75465: LD_VAR 0 3
75469: IFFALSE 75519
// begin for i in tmp do
75471: LD_ADDR_VAR 0 6
75475: PUSH
75476: LD_VAR 0 5
75480: PUSH
75481: FOR_IN
75482: IFFALSE 75517
// if GetBase ( i ) <> base then
75484: LD_VAR 0 6
75488: PPUSH
75489: CALL_OW 274
75493: PUSH
75494: LD_VAR 0 1
75498: NONEQUAL
75499: IFFALSE 75515
// ComLinkToBase ( base , i ) ;
75501: LD_VAR 0 1
75505: PPUSH
75506: LD_VAR 0 6
75510: PPUSH
75511: CALL_OW 169
75515: GO 75481
75517: POP
75518: POP
// end ; result := tmp ;
75519: LD_ADDR_VAR 0 4
75523: PUSH
75524: LD_VAR 0 5
75528: ST_TO_ADDR
// end ;
75529: LD_VAR 0 4
75533: RET
// export function ComComplete ( units , b ) ; var i ; begin
75534: LD_INT 0
75536: PPUSH
75537: PPUSH
// if not units then
75538: LD_VAR 0 1
75542: NOT
75543: IFFALSE 75547
// exit ;
75545: GO 75637
// for i in units do
75547: LD_ADDR_VAR 0 4
75551: PUSH
75552: LD_VAR 0 1
75556: PUSH
75557: FOR_IN
75558: IFFALSE 75635
// if BuildingStatus ( b ) = bs_build then
75560: LD_VAR 0 2
75564: PPUSH
75565: CALL_OW 461
75569: PUSH
75570: LD_INT 1
75572: EQUAL
75573: IFFALSE 75633
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75575: LD_VAR 0 4
75579: PPUSH
75580: LD_STRING h
75582: PUSH
75583: LD_VAR 0 2
75587: PPUSH
75588: CALL_OW 250
75592: PUSH
75593: LD_VAR 0 2
75597: PPUSH
75598: CALL_OW 251
75602: PUSH
75603: LD_VAR 0 2
75607: PUSH
75608: LD_INT 0
75610: PUSH
75611: LD_INT 0
75613: PUSH
75614: LD_INT 0
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: LIST
75621: LIST
75622: LIST
75623: LIST
75624: LIST
75625: PUSH
75626: EMPTY
75627: LIST
75628: PPUSH
75629: CALL_OW 446
75633: GO 75557
75635: POP
75636: POP
// end ;
75637: LD_VAR 0 3
75641: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75642: LD_INT 0
75644: PPUSH
75645: PPUSH
75646: PPUSH
75647: PPUSH
75648: PPUSH
75649: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75650: LD_VAR 0 1
75654: NOT
75655: PUSH
75656: LD_VAR 0 1
75660: PPUSH
75661: CALL_OW 263
75665: PUSH
75666: LD_INT 2
75668: NONEQUAL
75669: OR
75670: IFFALSE 75674
// exit ;
75672: GO 75990
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75674: LD_ADDR_VAR 0 6
75678: PUSH
75679: LD_INT 22
75681: PUSH
75682: LD_VAR 0 1
75686: PPUSH
75687: CALL_OW 255
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 2
75698: PUSH
75699: LD_INT 30
75701: PUSH
75702: LD_INT 36
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 34
75711: PUSH
75712: LD_INT 31
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: LIST
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PPUSH
75728: CALL_OW 69
75732: ST_TO_ADDR
// if not tmp then
75733: LD_VAR 0 6
75737: NOT
75738: IFFALSE 75742
// exit ;
75740: GO 75990
// result := [ ] ;
75742: LD_ADDR_VAR 0 2
75746: PUSH
75747: EMPTY
75748: ST_TO_ADDR
// for i in tmp do
75749: LD_ADDR_VAR 0 3
75753: PUSH
75754: LD_VAR 0 6
75758: PUSH
75759: FOR_IN
75760: IFFALSE 75831
// begin t := UnitsInside ( i ) ;
75762: LD_ADDR_VAR 0 4
75766: PUSH
75767: LD_VAR 0 3
75771: PPUSH
75772: CALL_OW 313
75776: ST_TO_ADDR
// if t then
75777: LD_VAR 0 4
75781: IFFALSE 75829
// for j in t do
75783: LD_ADDR_VAR 0 7
75787: PUSH
75788: LD_VAR 0 4
75792: PUSH
75793: FOR_IN
75794: IFFALSE 75827
// result := Replace ( result , result + 1 , j ) ;
75796: LD_ADDR_VAR 0 2
75800: PUSH
75801: LD_VAR 0 2
75805: PPUSH
75806: LD_VAR 0 2
75810: PUSH
75811: LD_INT 1
75813: PLUS
75814: PPUSH
75815: LD_VAR 0 7
75819: PPUSH
75820: CALL_OW 1
75824: ST_TO_ADDR
75825: GO 75793
75827: POP
75828: POP
// end ;
75829: GO 75759
75831: POP
75832: POP
// if not result then
75833: LD_VAR 0 2
75837: NOT
75838: IFFALSE 75842
// exit ;
75840: GO 75990
// mech := result [ 1 ] ;
75842: LD_ADDR_VAR 0 5
75846: PUSH
75847: LD_VAR 0 2
75851: PUSH
75852: LD_INT 1
75854: ARRAY
75855: ST_TO_ADDR
// if result > 1 then
75856: LD_VAR 0 2
75860: PUSH
75861: LD_INT 1
75863: GREATER
75864: IFFALSE 75976
// begin for i = 2 to result do
75866: LD_ADDR_VAR 0 3
75870: PUSH
75871: DOUBLE
75872: LD_INT 2
75874: DEC
75875: ST_TO_ADDR
75876: LD_VAR 0 2
75880: PUSH
75881: FOR_TO
75882: IFFALSE 75974
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75884: LD_ADDR_VAR 0 4
75888: PUSH
75889: LD_VAR 0 2
75893: PUSH
75894: LD_VAR 0 3
75898: ARRAY
75899: PPUSH
75900: LD_INT 3
75902: PPUSH
75903: CALL_OW 259
75907: PUSH
75908: LD_VAR 0 2
75912: PUSH
75913: LD_VAR 0 3
75917: ARRAY
75918: PPUSH
75919: CALL_OW 432
75923: MINUS
75924: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75925: LD_VAR 0 4
75929: PUSH
75930: LD_VAR 0 5
75934: PPUSH
75935: LD_INT 3
75937: PPUSH
75938: CALL_OW 259
75942: PUSH
75943: LD_VAR 0 5
75947: PPUSH
75948: CALL_OW 432
75952: MINUS
75953: GREATEREQUAL
75954: IFFALSE 75972
// mech := result [ i ] ;
75956: LD_ADDR_VAR 0 5
75960: PUSH
75961: LD_VAR 0 2
75965: PUSH
75966: LD_VAR 0 3
75970: ARRAY
75971: ST_TO_ADDR
// end ;
75972: GO 75881
75974: POP
75975: POP
// end ; ComLinkTo ( vehicle , mech ) ;
75976: LD_VAR 0 1
75980: PPUSH
75981: LD_VAR 0 5
75985: PPUSH
75986: CALL_OW 135
// end ;
75990: LD_VAR 0 2
75994: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75995: LD_INT 0
75997: PPUSH
75998: PPUSH
75999: PPUSH
76000: PPUSH
76001: PPUSH
76002: PPUSH
76003: PPUSH
76004: PPUSH
76005: PPUSH
76006: PPUSH
76007: PPUSH
76008: PPUSH
76009: PPUSH
// result := [ ] ;
76010: LD_ADDR_VAR 0 7
76014: PUSH
76015: EMPTY
76016: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
76017: LD_VAR 0 1
76021: PPUSH
76022: CALL_OW 266
76026: PUSH
76027: LD_INT 0
76029: PUSH
76030: LD_INT 1
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: IN
76037: NOT
76038: IFFALSE 76042
// exit ;
76040: GO 77676
// if name then
76042: LD_VAR 0 3
76046: IFFALSE 76062
// SetBName ( base_dep , name ) ;
76048: LD_VAR 0 1
76052: PPUSH
76053: LD_VAR 0 3
76057: PPUSH
76058: CALL_OW 500
// base := GetBase ( base_dep ) ;
76062: LD_ADDR_VAR 0 15
76066: PUSH
76067: LD_VAR 0 1
76071: PPUSH
76072: CALL_OW 274
76076: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
76077: LD_ADDR_VAR 0 16
76081: PUSH
76082: LD_VAR 0 1
76086: PPUSH
76087: CALL_OW 255
76091: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
76092: LD_ADDR_VAR 0 17
76096: PUSH
76097: LD_VAR 0 1
76101: PPUSH
76102: CALL_OW 248
76106: ST_TO_ADDR
// if sources then
76107: LD_VAR 0 5
76111: IFFALSE 76158
// for i = 1 to 3 do
76113: LD_ADDR_VAR 0 8
76117: PUSH
76118: DOUBLE
76119: LD_INT 1
76121: DEC
76122: ST_TO_ADDR
76123: LD_INT 3
76125: PUSH
76126: FOR_TO
76127: IFFALSE 76156
// AddResourceType ( base , i , sources [ i ] ) ;
76129: LD_VAR 0 15
76133: PPUSH
76134: LD_VAR 0 8
76138: PPUSH
76139: LD_VAR 0 5
76143: PUSH
76144: LD_VAR 0 8
76148: ARRAY
76149: PPUSH
76150: CALL_OW 276
76154: GO 76126
76156: POP
76157: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
76158: LD_ADDR_VAR 0 18
76162: PUSH
76163: LD_VAR 0 15
76167: PPUSH
76168: LD_VAR 0 2
76172: PPUSH
76173: LD_INT 1
76175: PPUSH
76176: CALL 75419 0 3
76180: ST_TO_ADDR
// InitHc ;
76181: CALL_OW 19
// InitUc ;
76185: CALL_OW 18
// uc_side := side ;
76189: LD_ADDR_OWVAR 20
76193: PUSH
76194: LD_VAR 0 16
76198: ST_TO_ADDR
// uc_nation := nation ;
76199: LD_ADDR_OWVAR 21
76203: PUSH
76204: LD_VAR 0 17
76208: ST_TO_ADDR
// if buildings then
76209: LD_VAR 0 18
76213: IFFALSE 77535
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
76215: LD_ADDR_VAR 0 19
76219: PUSH
76220: LD_VAR 0 18
76224: PPUSH
76225: LD_INT 2
76227: PUSH
76228: LD_INT 30
76230: PUSH
76231: LD_INT 29
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: LD_INT 30
76240: PUSH
76241: LD_INT 30
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: LIST
76252: PPUSH
76253: CALL_OW 72
76257: ST_TO_ADDR
// if tmp then
76258: LD_VAR 0 19
76262: IFFALSE 76310
// for i in tmp do
76264: LD_ADDR_VAR 0 8
76268: PUSH
76269: LD_VAR 0 19
76273: PUSH
76274: FOR_IN
76275: IFFALSE 76308
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
76277: LD_VAR 0 8
76281: PPUSH
76282: CALL_OW 250
76286: PPUSH
76287: LD_VAR 0 8
76291: PPUSH
76292: CALL_OW 251
76296: PPUSH
76297: LD_VAR 0 16
76301: PPUSH
76302: CALL_OW 441
76306: GO 76274
76308: POP
76309: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76310: LD_VAR 0 18
76314: PPUSH
76315: LD_INT 2
76317: PUSH
76318: LD_INT 30
76320: PUSH
76321: LD_INT 32
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: LD_INT 30
76330: PUSH
76331: LD_INT 33
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: LIST
76342: PPUSH
76343: CALL_OW 72
76347: IFFALSE 76435
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76349: LD_ADDR_VAR 0 8
76353: PUSH
76354: LD_VAR 0 18
76358: PPUSH
76359: LD_INT 2
76361: PUSH
76362: LD_INT 30
76364: PUSH
76365: LD_INT 32
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 30
76374: PUSH
76375: LD_INT 33
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: LIST
76386: PPUSH
76387: CALL_OW 72
76391: PUSH
76392: FOR_IN
76393: IFFALSE 76433
// begin if not GetBWeapon ( i ) then
76395: LD_VAR 0 8
76399: PPUSH
76400: CALL_OW 269
76404: NOT
76405: IFFALSE 76431
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76407: LD_VAR 0 8
76411: PPUSH
76412: LD_VAR 0 8
76416: PPUSH
76417: LD_VAR 0 2
76421: PPUSH
76422: CALL 77681 0 2
76426: PPUSH
76427: CALL_OW 431
// end ;
76431: GO 76392
76433: POP
76434: POP
// end ; for i = 1 to personel do
76435: LD_ADDR_VAR 0 8
76439: PUSH
76440: DOUBLE
76441: LD_INT 1
76443: DEC
76444: ST_TO_ADDR
76445: LD_VAR 0 6
76449: PUSH
76450: FOR_TO
76451: IFFALSE 77515
// begin if i > 4 then
76453: LD_VAR 0 8
76457: PUSH
76458: LD_INT 4
76460: GREATER
76461: IFFALSE 76465
// break ;
76463: GO 77515
// case i of 1 :
76465: LD_VAR 0 8
76469: PUSH
76470: LD_INT 1
76472: DOUBLE
76473: EQUAL
76474: IFTRUE 76478
76476: GO 76558
76478: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76479: LD_ADDR_VAR 0 12
76483: PUSH
76484: LD_VAR 0 18
76488: PPUSH
76489: LD_INT 22
76491: PUSH
76492: LD_VAR 0 16
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 58
76503: PUSH
76504: EMPTY
76505: LIST
76506: PUSH
76507: LD_INT 2
76509: PUSH
76510: LD_INT 30
76512: PUSH
76513: LD_INT 32
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 30
76522: PUSH
76523: LD_INT 4
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 30
76532: PUSH
76533: LD_INT 5
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: LIST
76550: PPUSH
76551: CALL_OW 72
76555: ST_TO_ADDR
76556: GO 76780
76558: LD_INT 2
76560: DOUBLE
76561: EQUAL
76562: IFTRUE 76566
76564: GO 76628
76566: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76567: LD_ADDR_VAR 0 12
76571: PUSH
76572: LD_VAR 0 18
76576: PPUSH
76577: LD_INT 22
76579: PUSH
76580: LD_VAR 0 16
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: LD_INT 2
76591: PUSH
76592: LD_INT 30
76594: PUSH
76595: LD_INT 0
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 30
76604: PUSH
76605: LD_INT 1
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: LIST
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PPUSH
76621: CALL_OW 72
76625: ST_TO_ADDR
76626: GO 76780
76628: LD_INT 3
76630: DOUBLE
76631: EQUAL
76632: IFTRUE 76636
76634: GO 76698
76636: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76637: LD_ADDR_VAR 0 12
76641: PUSH
76642: LD_VAR 0 18
76646: PPUSH
76647: LD_INT 22
76649: PUSH
76650: LD_VAR 0 16
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: LD_INT 2
76661: PUSH
76662: LD_INT 30
76664: PUSH
76665: LD_INT 2
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: LD_INT 30
76674: PUSH
76675: LD_INT 3
76677: PUSH
76678: EMPTY
76679: LIST
76680: LIST
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: LIST
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PPUSH
76691: CALL_OW 72
76695: ST_TO_ADDR
76696: GO 76780
76698: LD_INT 4
76700: DOUBLE
76701: EQUAL
76702: IFTRUE 76706
76704: GO 76779
76706: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76707: LD_ADDR_VAR 0 12
76711: PUSH
76712: LD_VAR 0 18
76716: PPUSH
76717: LD_INT 22
76719: PUSH
76720: LD_VAR 0 16
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 2
76731: PUSH
76732: LD_INT 30
76734: PUSH
76735: LD_INT 6
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 30
76744: PUSH
76745: LD_INT 7
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 30
76754: PUSH
76755: LD_INT 8
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: EMPTY
76763: LIST
76764: LIST
76765: LIST
76766: LIST
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PPUSH
76772: CALL_OW 72
76776: ST_TO_ADDR
76777: GO 76780
76779: POP
// if i = 1 then
76780: LD_VAR 0 8
76784: PUSH
76785: LD_INT 1
76787: EQUAL
76788: IFFALSE 76899
// begin tmp := [ ] ;
76790: LD_ADDR_VAR 0 19
76794: PUSH
76795: EMPTY
76796: ST_TO_ADDR
// for j in f do
76797: LD_ADDR_VAR 0 9
76801: PUSH
76802: LD_VAR 0 12
76806: PUSH
76807: FOR_IN
76808: IFFALSE 76881
// if GetBType ( j ) = b_bunker then
76810: LD_VAR 0 9
76814: PPUSH
76815: CALL_OW 266
76819: PUSH
76820: LD_INT 32
76822: EQUAL
76823: IFFALSE 76850
// tmp := Insert ( tmp , 1 , j ) else
76825: LD_ADDR_VAR 0 19
76829: PUSH
76830: LD_VAR 0 19
76834: PPUSH
76835: LD_INT 1
76837: PPUSH
76838: LD_VAR 0 9
76842: PPUSH
76843: CALL_OW 2
76847: ST_TO_ADDR
76848: GO 76879
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76850: LD_ADDR_VAR 0 19
76854: PUSH
76855: LD_VAR 0 19
76859: PPUSH
76860: LD_VAR 0 19
76864: PUSH
76865: LD_INT 1
76867: PLUS
76868: PPUSH
76869: LD_VAR 0 9
76873: PPUSH
76874: CALL_OW 2
76878: ST_TO_ADDR
76879: GO 76807
76881: POP
76882: POP
// if tmp then
76883: LD_VAR 0 19
76887: IFFALSE 76899
// f := tmp ;
76889: LD_ADDR_VAR 0 12
76893: PUSH
76894: LD_VAR 0 19
76898: ST_TO_ADDR
// end ; x := personel [ i ] ;
76899: LD_ADDR_VAR 0 13
76903: PUSH
76904: LD_VAR 0 6
76908: PUSH
76909: LD_VAR 0 8
76913: ARRAY
76914: ST_TO_ADDR
// if x = - 1 then
76915: LD_VAR 0 13
76919: PUSH
76920: LD_INT 1
76922: NEG
76923: EQUAL
76924: IFFALSE 77133
// begin for j in f do
76926: LD_ADDR_VAR 0 9
76930: PUSH
76931: LD_VAR 0 12
76935: PUSH
76936: FOR_IN
76937: IFFALSE 77129
// repeat InitHc ;
76939: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76943: LD_VAR 0 9
76947: PPUSH
76948: CALL_OW 266
76952: PUSH
76953: LD_INT 5
76955: EQUAL
76956: IFFALSE 77026
// begin if UnitsInside ( j ) < 3 then
76958: LD_VAR 0 9
76962: PPUSH
76963: CALL_OW 313
76967: PUSH
76968: LD_INT 3
76970: LESS
76971: IFFALSE 77007
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76973: LD_INT 0
76975: PPUSH
76976: LD_INT 5
76978: PUSH
76979: LD_INT 8
76981: PUSH
76982: LD_INT 9
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: LIST
76989: PUSH
76990: LD_VAR 0 17
76994: ARRAY
76995: PPUSH
76996: LD_VAR 0 4
77000: PPUSH
77001: CALL_OW 380
77005: GO 77024
// PrepareHuman ( false , i , skill ) ;
77007: LD_INT 0
77009: PPUSH
77010: LD_VAR 0 8
77014: PPUSH
77015: LD_VAR 0 4
77019: PPUSH
77020: CALL_OW 380
// end else
77024: GO 77043
// PrepareHuman ( false , i , skill ) ;
77026: LD_INT 0
77028: PPUSH
77029: LD_VAR 0 8
77033: PPUSH
77034: LD_VAR 0 4
77038: PPUSH
77039: CALL_OW 380
// un := CreateHuman ;
77043: LD_ADDR_VAR 0 14
77047: PUSH
77048: CALL_OW 44
77052: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77053: LD_ADDR_VAR 0 7
77057: PUSH
77058: LD_VAR 0 7
77062: PPUSH
77063: LD_INT 1
77065: PPUSH
77066: LD_VAR 0 14
77070: PPUSH
77071: CALL_OW 2
77075: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
77076: LD_VAR 0 14
77080: PPUSH
77081: LD_VAR 0 9
77085: PPUSH
77086: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
77090: LD_VAR 0 9
77094: PPUSH
77095: CALL_OW 313
77099: PUSH
77100: LD_INT 6
77102: EQUAL
77103: PUSH
77104: LD_VAR 0 9
77108: PPUSH
77109: CALL_OW 266
77113: PUSH
77114: LD_INT 32
77116: PUSH
77117: LD_INT 31
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: IN
77124: OR
77125: IFFALSE 76939
77127: GO 76936
77129: POP
77130: POP
// end else
77131: GO 77513
// for j = 1 to x do
77133: LD_ADDR_VAR 0 9
77137: PUSH
77138: DOUBLE
77139: LD_INT 1
77141: DEC
77142: ST_TO_ADDR
77143: LD_VAR 0 13
77147: PUSH
77148: FOR_TO
77149: IFFALSE 77511
// begin InitHc ;
77151: CALL_OW 19
// if not f then
77155: LD_VAR 0 12
77159: NOT
77160: IFFALSE 77249
// begin PrepareHuman ( false , i , skill ) ;
77162: LD_INT 0
77164: PPUSH
77165: LD_VAR 0 8
77169: PPUSH
77170: LD_VAR 0 4
77174: PPUSH
77175: CALL_OW 380
// un := CreateHuman ;
77179: LD_ADDR_VAR 0 14
77183: PUSH
77184: CALL_OW 44
77188: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77189: LD_ADDR_VAR 0 7
77193: PUSH
77194: LD_VAR 0 7
77198: PPUSH
77199: LD_INT 1
77201: PPUSH
77202: LD_VAR 0 14
77206: PPUSH
77207: CALL_OW 2
77211: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77212: LD_VAR 0 14
77216: PPUSH
77217: LD_VAR 0 1
77221: PPUSH
77222: CALL_OW 250
77226: PPUSH
77227: LD_VAR 0 1
77231: PPUSH
77232: CALL_OW 251
77236: PPUSH
77237: LD_INT 10
77239: PPUSH
77240: LD_INT 0
77242: PPUSH
77243: CALL_OW 50
// continue ;
77247: GO 77148
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
77249: LD_VAR 0 12
77253: PUSH
77254: LD_INT 1
77256: ARRAY
77257: PPUSH
77258: CALL_OW 313
77262: PUSH
77263: LD_VAR 0 12
77267: PUSH
77268: LD_INT 1
77270: ARRAY
77271: PPUSH
77272: CALL_OW 266
77276: PUSH
77277: LD_INT 32
77279: PUSH
77280: LD_INT 31
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: IN
77287: AND
77288: PUSH
77289: LD_VAR 0 12
77293: PUSH
77294: LD_INT 1
77296: ARRAY
77297: PPUSH
77298: CALL_OW 313
77302: PUSH
77303: LD_INT 6
77305: EQUAL
77306: OR
77307: IFFALSE 77327
// f := Delete ( f , 1 ) ;
77309: LD_ADDR_VAR 0 12
77313: PUSH
77314: LD_VAR 0 12
77318: PPUSH
77319: LD_INT 1
77321: PPUSH
77322: CALL_OW 3
77326: ST_TO_ADDR
// if not f then
77327: LD_VAR 0 12
77331: NOT
77332: IFFALSE 77350
// begin x := x + 2 ;
77334: LD_ADDR_VAR 0 13
77338: PUSH
77339: LD_VAR 0 13
77343: PUSH
77344: LD_INT 2
77346: PLUS
77347: ST_TO_ADDR
// continue ;
77348: GO 77148
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77350: LD_VAR 0 12
77354: PUSH
77355: LD_INT 1
77357: ARRAY
77358: PPUSH
77359: CALL_OW 266
77363: PUSH
77364: LD_INT 5
77366: EQUAL
77367: IFFALSE 77441
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77369: LD_VAR 0 12
77373: PUSH
77374: LD_INT 1
77376: ARRAY
77377: PPUSH
77378: CALL_OW 313
77382: PUSH
77383: LD_INT 3
77385: LESS
77386: IFFALSE 77422
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77388: LD_INT 0
77390: PPUSH
77391: LD_INT 5
77393: PUSH
77394: LD_INT 8
77396: PUSH
77397: LD_INT 9
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: LIST
77404: PUSH
77405: LD_VAR 0 17
77409: ARRAY
77410: PPUSH
77411: LD_VAR 0 4
77415: PPUSH
77416: CALL_OW 380
77420: GO 77439
// PrepareHuman ( false , i , skill ) ;
77422: LD_INT 0
77424: PPUSH
77425: LD_VAR 0 8
77429: PPUSH
77430: LD_VAR 0 4
77434: PPUSH
77435: CALL_OW 380
// end else
77439: GO 77458
// PrepareHuman ( false , i , skill ) ;
77441: LD_INT 0
77443: PPUSH
77444: LD_VAR 0 8
77448: PPUSH
77449: LD_VAR 0 4
77453: PPUSH
77454: CALL_OW 380
// un := CreateHuman ;
77458: LD_ADDR_VAR 0 14
77462: PUSH
77463: CALL_OW 44
77467: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77468: LD_ADDR_VAR 0 7
77472: PUSH
77473: LD_VAR 0 7
77477: PPUSH
77478: LD_INT 1
77480: PPUSH
77481: LD_VAR 0 14
77485: PPUSH
77486: CALL_OW 2
77490: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77491: LD_VAR 0 14
77495: PPUSH
77496: LD_VAR 0 12
77500: PUSH
77501: LD_INT 1
77503: ARRAY
77504: PPUSH
77505: CALL_OW 52
// end ;
77509: GO 77148
77511: POP
77512: POP
// end ;
77513: GO 76450
77515: POP
77516: POP
// result := result ^ buildings ;
77517: LD_ADDR_VAR 0 7
77521: PUSH
77522: LD_VAR 0 7
77526: PUSH
77527: LD_VAR 0 18
77531: ADD
77532: ST_TO_ADDR
// end else
77533: GO 77676
// begin for i = 1 to personel do
77535: LD_ADDR_VAR 0 8
77539: PUSH
77540: DOUBLE
77541: LD_INT 1
77543: DEC
77544: ST_TO_ADDR
77545: LD_VAR 0 6
77549: PUSH
77550: FOR_TO
77551: IFFALSE 77674
// begin if i > 4 then
77553: LD_VAR 0 8
77557: PUSH
77558: LD_INT 4
77560: GREATER
77561: IFFALSE 77565
// break ;
77563: GO 77674
// x := personel [ i ] ;
77565: LD_ADDR_VAR 0 13
77569: PUSH
77570: LD_VAR 0 6
77574: PUSH
77575: LD_VAR 0 8
77579: ARRAY
77580: ST_TO_ADDR
// if x = - 1 then
77581: LD_VAR 0 13
77585: PUSH
77586: LD_INT 1
77588: NEG
77589: EQUAL
77590: IFFALSE 77594
// continue ;
77592: GO 77550
// PrepareHuman ( false , i , skill ) ;
77594: LD_INT 0
77596: PPUSH
77597: LD_VAR 0 8
77601: PPUSH
77602: LD_VAR 0 4
77606: PPUSH
77607: CALL_OW 380
// un := CreateHuman ;
77611: LD_ADDR_VAR 0 14
77615: PUSH
77616: CALL_OW 44
77620: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77621: LD_VAR 0 14
77625: PPUSH
77626: LD_VAR 0 1
77630: PPUSH
77631: CALL_OW 250
77635: PPUSH
77636: LD_VAR 0 1
77640: PPUSH
77641: CALL_OW 251
77645: PPUSH
77646: LD_INT 10
77648: PPUSH
77649: LD_INT 0
77651: PPUSH
77652: CALL_OW 50
// result := result ^ un ;
77656: LD_ADDR_VAR 0 7
77660: PUSH
77661: LD_VAR 0 7
77665: PUSH
77666: LD_VAR 0 14
77670: ADD
77671: ST_TO_ADDR
// end ;
77672: GO 77550
77674: POP
77675: POP
// end ; end ;
77676: LD_VAR 0 7
77680: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77681: LD_INT 0
77683: PPUSH
77684: PPUSH
77685: PPUSH
77686: PPUSH
77687: PPUSH
77688: PPUSH
77689: PPUSH
77690: PPUSH
77691: PPUSH
77692: PPUSH
77693: PPUSH
77694: PPUSH
77695: PPUSH
77696: PPUSH
77697: PPUSH
77698: PPUSH
// result := false ;
77699: LD_ADDR_VAR 0 3
77703: PUSH
77704: LD_INT 0
77706: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77707: LD_VAR 0 1
77711: NOT
77712: PUSH
77713: LD_VAR 0 1
77717: PPUSH
77718: CALL_OW 266
77722: PUSH
77723: LD_INT 32
77725: PUSH
77726: LD_INT 33
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: IN
77733: NOT
77734: OR
77735: IFFALSE 77739
// exit ;
77737: GO 78848
// nat := GetNation ( tower ) ;
77739: LD_ADDR_VAR 0 12
77743: PUSH
77744: LD_VAR 0 1
77748: PPUSH
77749: CALL_OW 248
77753: ST_TO_ADDR
// side := GetSide ( tower ) ;
77754: LD_ADDR_VAR 0 16
77758: PUSH
77759: LD_VAR 0 1
77763: PPUSH
77764: CALL_OW 255
77768: ST_TO_ADDR
// x := GetX ( tower ) ;
77769: LD_ADDR_VAR 0 10
77773: PUSH
77774: LD_VAR 0 1
77778: PPUSH
77779: CALL_OW 250
77783: ST_TO_ADDR
// y := GetY ( tower ) ;
77784: LD_ADDR_VAR 0 11
77788: PUSH
77789: LD_VAR 0 1
77793: PPUSH
77794: CALL_OW 251
77798: ST_TO_ADDR
// if not x or not y then
77799: LD_VAR 0 10
77803: NOT
77804: PUSH
77805: LD_VAR 0 11
77809: NOT
77810: OR
77811: IFFALSE 77815
// exit ;
77813: GO 78848
// weapon := 0 ;
77815: LD_ADDR_VAR 0 18
77819: PUSH
77820: LD_INT 0
77822: ST_TO_ADDR
// fac_list := [ ] ;
77823: LD_ADDR_VAR 0 17
77827: PUSH
77828: EMPTY
77829: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77830: LD_ADDR_VAR 0 6
77834: PUSH
77835: LD_VAR 0 1
77839: PPUSH
77840: CALL_OW 274
77844: PPUSH
77845: LD_VAR 0 2
77849: PPUSH
77850: LD_INT 0
77852: PPUSH
77853: CALL 75419 0 3
77857: PPUSH
77858: LD_INT 30
77860: PUSH
77861: LD_INT 3
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PPUSH
77868: CALL_OW 72
77872: ST_TO_ADDR
// if not factories then
77873: LD_VAR 0 6
77877: NOT
77878: IFFALSE 77882
// exit ;
77880: GO 78848
// for i in factories do
77882: LD_ADDR_VAR 0 8
77886: PUSH
77887: LD_VAR 0 6
77891: PUSH
77892: FOR_IN
77893: IFFALSE 77918
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77895: LD_ADDR_VAR 0 17
77899: PUSH
77900: LD_VAR 0 17
77904: PUSH
77905: LD_VAR 0 8
77909: PPUSH
77910: CALL_OW 478
77914: UNION
77915: ST_TO_ADDR
77916: GO 77892
77918: POP
77919: POP
// if not fac_list then
77920: LD_VAR 0 17
77924: NOT
77925: IFFALSE 77929
// exit ;
77927: GO 78848
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77929: LD_ADDR_VAR 0 5
77933: PUSH
77934: LD_INT 4
77936: PUSH
77937: LD_INT 5
77939: PUSH
77940: LD_INT 9
77942: PUSH
77943: LD_INT 10
77945: PUSH
77946: LD_INT 6
77948: PUSH
77949: LD_INT 7
77951: PUSH
77952: LD_INT 11
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 27
77966: PUSH
77967: LD_INT 28
77969: PUSH
77970: LD_INT 26
77972: PUSH
77973: LD_INT 30
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: PUSH
77982: LD_INT 43
77984: PUSH
77985: LD_INT 44
77987: PUSH
77988: LD_INT 46
77990: PUSH
77991: LD_INT 45
77993: PUSH
77994: LD_INT 47
77996: PUSH
77997: LD_INT 49
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: PUSH
78008: EMPTY
78009: LIST
78010: LIST
78011: LIST
78012: PUSH
78013: LD_VAR 0 12
78017: ARRAY
78018: ST_TO_ADDR
// list := list isect fac_list ;
78019: LD_ADDR_VAR 0 5
78023: PUSH
78024: LD_VAR 0 5
78028: PUSH
78029: LD_VAR 0 17
78033: ISECT
78034: ST_TO_ADDR
// if not list then
78035: LD_VAR 0 5
78039: NOT
78040: IFFALSE 78044
// exit ;
78042: GO 78848
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
78044: LD_VAR 0 12
78048: PUSH
78049: LD_INT 3
78051: EQUAL
78052: PUSH
78053: LD_INT 49
78055: PUSH
78056: LD_VAR 0 5
78060: IN
78061: AND
78062: PUSH
78063: LD_INT 31
78065: PPUSH
78066: LD_VAR 0 16
78070: PPUSH
78071: CALL_OW 321
78075: PUSH
78076: LD_INT 2
78078: EQUAL
78079: AND
78080: IFFALSE 78140
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
78082: LD_INT 22
78084: PUSH
78085: LD_VAR 0 16
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 35
78096: PUSH
78097: LD_INT 49
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 91
78106: PUSH
78107: LD_VAR 0 1
78111: PUSH
78112: LD_INT 10
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: LIST
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: LIST
78124: PPUSH
78125: CALL_OW 69
78129: NOT
78130: IFFALSE 78140
// weapon := ru_time_lapser ;
78132: LD_ADDR_VAR 0 18
78136: PUSH
78137: LD_INT 49
78139: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
78140: LD_VAR 0 12
78144: PUSH
78145: LD_INT 1
78147: PUSH
78148: LD_INT 2
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: IN
78155: PUSH
78156: LD_INT 11
78158: PUSH
78159: LD_VAR 0 5
78163: IN
78164: PUSH
78165: LD_INT 30
78167: PUSH
78168: LD_VAR 0 5
78172: IN
78173: OR
78174: AND
78175: PUSH
78176: LD_INT 6
78178: PPUSH
78179: LD_VAR 0 16
78183: PPUSH
78184: CALL_OW 321
78188: PUSH
78189: LD_INT 2
78191: EQUAL
78192: AND
78193: IFFALSE 78358
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
78195: LD_INT 22
78197: PUSH
78198: LD_VAR 0 16
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PUSH
78207: LD_INT 2
78209: PUSH
78210: LD_INT 35
78212: PUSH
78213: LD_INT 11
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 35
78222: PUSH
78223: LD_INT 30
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 91
78237: PUSH
78238: LD_VAR 0 1
78242: PUSH
78243: LD_INT 18
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: LIST
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: LIST
78255: PPUSH
78256: CALL_OW 69
78260: NOT
78261: PUSH
78262: LD_INT 22
78264: PUSH
78265: LD_VAR 0 16
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 2
78276: PUSH
78277: LD_INT 30
78279: PUSH
78280: LD_INT 32
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: LD_INT 30
78289: PUSH
78290: LD_INT 33
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 91
78304: PUSH
78305: LD_VAR 0 1
78309: PUSH
78310: LD_INT 12
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: LIST
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: LIST
78322: PUSH
78323: EMPTY
78324: LIST
78325: PPUSH
78326: CALL_OW 69
78330: PUSH
78331: LD_INT 2
78333: GREATER
78334: AND
78335: IFFALSE 78358
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78337: LD_ADDR_VAR 0 18
78341: PUSH
78342: LD_INT 11
78344: PUSH
78345: LD_INT 30
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_VAR 0 12
78356: ARRAY
78357: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78358: LD_VAR 0 18
78362: NOT
78363: PUSH
78364: LD_INT 40
78366: PPUSH
78367: LD_VAR 0 16
78371: PPUSH
78372: CALL_OW 321
78376: PUSH
78377: LD_INT 2
78379: EQUAL
78380: AND
78381: PUSH
78382: LD_INT 7
78384: PUSH
78385: LD_VAR 0 5
78389: IN
78390: PUSH
78391: LD_INT 28
78393: PUSH
78394: LD_VAR 0 5
78398: IN
78399: OR
78400: PUSH
78401: LD_INT 45
78403: PUSH
78404: LD_VAR 0 5
78408: IN
78409: OR
78410: AND
78411: IFFALSE 78665
// begin hex := GetHexInfo ( x , y ) ;
78413: LD_ADDR_VAR 0 4
78417: PUSH
78418: LD_VAR 0 10
78422: PPUSH
78423: LD_VAR 0 11
78427: PPUSH
78428: CALL_OW 546
78432: ST_TO_ADDR
// if hex [ 1 ] then
78433: LD_VAR 0 4
78437: PUSH
78438: LD_INT 1
78440: ARRAY
78441: IFFALSE 78445
// exit ;
78443: GO 78848
// height := hex [ 2 ] ;
78445: LD_ADDR_VAR 0 15
78449: PUSH
78450: LD_VAR 0 4
78454: PUSH
78455: LD_INT 2
78457: ARRAY
78458: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78459: LD_ADDR_VAR 0 14
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: LD_INT 2
78469: PUSH
78470: LD_INT 3
78472: PUSH
78473: LD_INT 5
78475: PUSH
78476: EMPTY
78477: LIST
78478: LIST
78479: LIST
78480: LIST
78481: ST_TO_ADDR
// for i in tmp do
78482: LD_ADDR_VAR 0 8
78486: PUSH
78487: LD_VAR 0 14
78491: PUSH
78492: FOR_IN
78493: IFFALSE 78663
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78495: LD_ADDR_VAR 0 9
78499: PUSH
78500: LD_VAR 0 10
78504: PPUSH
78505: LD_VAR 0 8
78509: PPUSH
78510: LD_INT 5
78512: PPUSH
78513: CALL_OW 272
78517: PUSH
78518: LD_VAR 0 11
78522: PPUSH
78523: LD_VAR 0 8
78527: PPUSH
78528: LD_INT 5
78530: PPUSH
78531: CALL_OW 273
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78540: LD_VAR 0 9
78544: PUSH
78545: LD_INT 1
78547: ARRAY
78548: PPUSH
78549: LD_VAR 0 9
78553: PUSH
78554: LD_INT 2
78556: ARRAY
78557: PPUSH
78558: CALL_OW 488
78562: IFFALSE 78661
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78564: LD_ADDR_VAR 0 4
78568: PUSH
78569: LD_VAR 0 9
78573: PUSH
78574: LD_INT 1
78576: ARRAY
78577: PPUSH
78578: LD_VAR 0 9
78582: PUSH
78583: LD_INT 2
78585: ARRAY
78586: PPUSH
78587: CALL_OW 546
78591: ST_TO_ADDR
// if hex [ 1 ] then
78592: LD_VAR 0 4
78596: PUSH
78597: LD_INT 1
78599: ARRAY
78600: IFFALSE 78604
// continue ;
78602: GO 78492
// h := hex [ 2 ] ;
78604: LD_ADDR_VAR 0 13
78608: PUSH
78609: LD_VAR 0 4
78613: PUSH
78614: LD_INT 2
78616: ARRAY
78617: ST_TO_ADDR
// if h + 7 < height then
78618: LD_VAR 0 13
78622: PUSH
78623: LD_INT 7
78625: PLUS
78626: PUSH
78627: LD_VAR 0 15
78631: LESS
78632: IFFALSE 78661
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78634: LD_ADDR_VAR 0 18
78638: PUSH
78639: LD_INT 7
78641: PUSH
78642: LD_INT 28
78644: PUSH
78645: LD_INT 45
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: LIST
78652: PUSH
78653: LD_VAR 0 12
78657: ARRAY
78658: ST_TO_ADDR
// break ;
78659: GO 78663
// end ; end ; end ;
78661: GO 78492
78663: POP
78664: POP
// end ; if not weapon then
78665: LD_VAR 0 18
78669: NOT
78670: IFFALSE 78730
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78672: LD_ADDR_VAR 0 5
78676: PUSH
78677: LD_VAR 0 5
78681: PUSH
78682: LD_INT 11
78684: PUSH
78685: LD_INT 30
78687: PUSH
78688: LD_INT 49
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: LIST
78695: DIFF
78696: ST_TO_ADDR
// if not list then
78697: LD_VAR 0 5
78701: NOT
78702: IFFALSE 78706
// exit ;
78704: GO 78848
// weapon := list [ rand ( 1 , list ) ] ;
78706: LD_ADDR_VAR 0 18
78710: PUSH
78711: LD_VAR 0 5
78715: PUSH
78716: LD_INT 1
78718: PPUSH
78719: LD_VAR 0 5
78723: PPUSH
78724: CALL_OW 12
78728: ARRAY
78729: ST_TO_ADDR
// end ; if weapon then
78730: LD_VAR 0 18
78734: IFFALSE 78848
// begin tmp := CostOfWeapon ( weapon ) ;
78736: LD_ADDR_VAR 0 14
78740: PUSH
78741: LD_VAR 0 18
78745: PPUSH
78746: CALL_OW 451
78750: ST_TO_ADDR
// j := GetBase ( tower ) ;
78751: LD_ADDR_VAR 0 9
78755: PUSH
78756: LD_VAR 0 1
78760: PPUSH
78761: CALL_OW 274
78765: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78766: LD_VAR 0 9
78770: PPUSH
78771: LD_INT 1
78773: PPUSH
78774: CALL_OW 275
78778: PUSH
78779: LD_VAR 0 14
78783: PUSH
78784: LD_INT 1
78786: ARRAY
78787: GREATEREQUAL
78788: PUSH
78789: LD_VAR 0 9
78793: PPUSH
78794: LD_INT 2
78796: PPUSH
78797: CALL_OW 275
78801: PUSH
78802: LD_VAR 0 14
78806: PUSH
78807: LD_INT 2
78809: ARRAY
78810: GREATEREQUAL
78811: AND
78812: PUSH
78813: LD_VAR 0 9
78817: PPUSH
78818: LD_INT 3
78820: PPUSH
78821: CALL_OW 275
78825: PUSH
78826: LD_VAR 0 14
78830: PUSH
78831: LD_INT 3
78833: ARRAY
78834: GREATEREQUAL
78835: AND
78836: IFFALSE 78848
// result := weapon ;
78838: LD_ADDR_VAR 0 3
78842: PUSH
78843: LD_VAR 0 18
78847: ST_TO_ADDR
// end ; end ;
78848: LD_VAR 0 3
78852: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78853: LD_INT 0
78855: PPUSH
78856: PPUSH
// result := true ;
78857: LD_ADDR_VAR 0 3
78861: PUSH
78862: LD_INT 1
78864: ST_TO_ADDR
// if array1 = array2 then
78865: LD_VAR 0 1
78869: PUSH
78870: LD_VAR 0 2
78874: EQUAL
78875: IFFALSE 78935
// begin for i = 1 to array1 do
78877: LD_ADDR_VAR 0 4
78881: PUSH
78882: DOUBLE
78883: LD_INT 1
78885: DEC
78886: ST_TO_ADDR
78887: LD_VAR 0 1
78891: PUSH
78892: FOR_TO
78893: IFFALSE 78931
// if array1 [ i ] <> array2 [ i ] then
78895: LD_VAR 0 1
78899: PUSH
78900: LD_VAR 0 4
78904: ARRAY
78905: PUSH
78906: LD_VAR 0 2
78910: PUSH
78911: LD_VAR 0 4
78915: ARRAY
78916: NONEQUAL
78917: IFFALSE 78929
// begin result := false ;
78919: LD_ADDR_VAR 0 3
78923: PUSH
78924: LD_INT 0
78926: ST_TO_ADDR
// break ;
78927: GO 78931
// end ;
78929: GO 78892
78931: POP
78932: POP
// end else
78933: GO 78943
// result := false ;
78935: LD_ADDR_VAR 0 3
78939: PUSH
78940: LD_INT 0
78942: ST_TO_ADDR
// end ;
78943: LD_VAR 0 3
78947: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78948: LD_INT 0
78950: PPUSH
78951: PPUSH
// if not array1 or not array2 then
78952: LD_VAR 0 1
78956: NOT
78957: PUSH
78958: LD_VAR 0 2
78962: NOT
78963: OR
78964: IFFALSE 78968
// exit ;
78966: GO 79032
// result := true ;
78968: LD_ADDR_VAR 0 3
78972: PUSH
78973: LD_INT 1
78975: ST_TO_ADDR
// for i = 1 to array1 do
78976: LD_ADDR_VAR 0 4
78980: PUSH
78981: DOUBLE
78982: LD_INT 1
78984: DEC
78985: ST_TO_ADDR
78986: LD_VAR 0 1
78990: PUSH
78991: FOR_TO
78992: IFFALSE 79030
// if array1 [ i ] <> array2 [ i ] then
78994: LD_VAR 0 1
78998: PUSH
78999: LD_VAR 0 4
79003: ARRAY
79004: PUSH
79005: LD_VAR 0 2
79009: PUSH
79010: LD_VAR 0 4
79014: ARRAY
79015: NONEQUAL
79016: IFFALSE 79028
// begin result := false ;
79018: LD_ADDR_VAR 0 3
79022: PUSH
79023: LD_INT 0
79025: ST_TO_ADDR
// break ;
79026: GO 79030
// end ;
79028: GO 78991
79030: POP
79031: POP
// end ;
79032: LD_VAR 0 3
79036: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
79037: LD_INT 0
79039: PPUSH
79040: PPUSH
79041: PPUSH
// pom := GetBase ( fac ) ;
79042: LD_ADDR_VAR 0 5
79046: PUSH
79047: LD_VAR 0 1
79051: PPUSH
79052: CALL_OW 274
79056: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
79057: LD_ADDR_VAR 0 4
79061: PUSH
79062: LD_VAR 0 2
79066: PUSH
79067: LD_INT 1
79069: ARRAY
79070: PPUSH
79071: LD_VAR 0 2
79075: PUSH
79076: LD_INT 2
79078: ARRAY
79079: PPUSH
79080: LD_VAR 0 2
79084: PUSH
79085: LD_INT 3
79087: ARRAY
79088: PPUSH
79089: LD_VAR 0 2
79093: PUSH
79094: LD_INT 4
79096: ARRAY
79097: PPUSH
79098: CALL_OW 449
79102: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79103: LD_ADDR_VAR 0 3
79107: PUSH
79108: LD_VAR 0 5
79112: PPUSH
79113: LD_INT 1
79115: PPUSH
79116: CALL_OW 275
79120: PUSH
79121: LD_VAR 0 4
79125: PUSH
79126: LD_INT 1
79128: ARRAY
79129: GREATEREQUAL
79130: PUSH
79131: LD_VAR 0 5
79135: PPUSH
79136: LD_INT 2
79138: PPUSH
79139: CALL_OW 275
79143: PUSH
79144: LD_VAR 0 4
79148: PUSH
79149: LD_INT 2
79151: ARRAY
79152: GREATEREQUAL
79153: AND
79154: PUSH
79155: LD_VAR 0 5
79159: PPUSH
79160: LD_INT 3
79162: PPUSH
79163: CALL_OW 275
79167: PUSH
79168: LD_VAR 0 4
79172: PUSH
79173: LD_INT 3
79175: ARRAY
79176: GREATEREQUAL
79177: AND
79178: ST_TO_ADDR
// end ;
79179: LD_VAR 0 3
79183: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
79184: LD_INT 0
79186: PPUSH
79187: PPUSH
79188: PPUSH
79189: PPUSH
// pom := GetBase ( building ) ;
79190: LD_ADDR_VAR 0 3
79194: PUSH
79195: LD_VAR 0 1
79199: PPUSH
79200: CALL_OW 274
79204: ST_TO_ADDR
// if not pom then
79205: LD_VAR 0 3
79209: NOT
79210: IFFALSE 79214
// exit ;
79212: GO 79384
// btype := GetBType ( building ) ;
79214: LD_ADDR_VAR 0 5
79218: PUSH
79219: LD_VAR 0 1
79223: PPUSH
79224: CALL_OW 266
79228: ST_TO_ADDR
// if btype = b_armoury then
79229: LD_VAR 0 5
79233: PUSH
79234: LD_INT 4
79236: EQUAL
79237: IFFALSE 79247
// btype := b_barracks ;
79239: LD_ADDR_VAR 0 5
79243: PUSH
79244: LD_INT 5
79246: ST_TO_ADDR
// if btype = b_depot then
79247: LD_VAR 0 5
79251: PUSH
79252: LD_INT 0
79254: EQUAL
79255: IFFALSE 79265
// btype := b_warehouse ;
79257: LD_ADDR_VAR 0 5
79261: PUSH
79262: LD_INT 1
79264: ST_TO_ADDR
// if btype = b_workshop then
79265: LD_VAR 0 5
79269: PUSH
79270: LD_INT 2
79272: EQUAL
79273: IFFALSE 79283
// btype := b_factory ;
79275: LD_ADDR_VAR 0 5
79279: PUSH
79280: LD_INT 3
79282: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79283: LD_ADDR_VAR 0 4
79287: PUSH
79288: LD_VAR 0 5
79292: PPUSH
79293: LD_VAR 0 1
79297: PPUSH
79298: CALL_OW 248
79302: PPUSH
79303: CALL_OW 450
79307: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79308: LD_ADDR_VAR 0 2
79312: PUSH
79313: LD_VAR 0 3
79317: PPUSH
79318: LD_INT 1
79320: PPUSH
79321: CALL_OW 275
79325: PUSH
79326: LD_VAR 0 4
79330: PUSH
79331: LD_INT 1
79333: ARRAY
79334: GREATEREQUAL
79335: PUSH
79336: LD_VAR 0 3
79340: PPUSH
79341: LD_INT 2
79343: PPUSH
79344: CALL_OW 275
79348: PUSH
79349: LD_VAR 0 4
79353: PUSH
79354: LD_INT 2
79356: ARRAY
79357: GREATEREQUAL
79358: AND
79359: PUSH
79360: LD_VAR 0 3
79364: PPUSH
79365: LD_INT 3
79367: PPUSH
79368: CALL_OW 275
79372: PUSH
79373: LD_VAR 0 4
79377: PUSH
79378: LD_INT 3
79380: ARRAY
79381: GREATEREQUAL
79382: AND
79383: ST_TO_ADDR
// end ;
79384: LD_VAR 0 2
79388: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79389: LD_INT 0
79391: PPUSH
79392: PPUSH
79393: PPUSH
// pom := GetBase ( building ) ;
79394: LD_ADDR_VAR 0 4
79398: PUSH
79399: LD_VAR 0 1
79403: PPUSH
79404: CALL_OW 274
79408: ST_TO_ADDR
// if not pom then
79409: LD_VAR 0 4
79413: NOT
79414: IFFALSE 79418
// exit ;
79416: GO 79519
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79418: LD_ADDR_VAR 0 5
79422: PUSH
79423: LD_VAR 0 2
79427: PPUSH
79428: LD_VAR 0 1
79432: PPUSH
79433: CALL_OW 248
79437: PPUSH
79438: CALL_OW 450
79442: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79443: LD_ADDR_VAR 0 3
79447: PUSH
79448: LD_VAR 0 4
79452: PPUSH
79453: LD_INT 1
79455: PPUSH
79456: CALL_OW 275
79460: PUSH
79461: LD_VAR 0 5
79465: PUSH
79466: LD_INT 1
79468: ARRAY
79469: GREATEREQUAL
79470: PUSH
79471: LD_VAR 0 4
79475: PPUSH
79476: LD_INT 2
79478: PPUSH
79479: CALL_OW 275
79483: PUSH
79484: LD_VAR 0 5
79488: PUSH
79489: LD_INT 2
79491: ARRAY
79492: GREATEREQUAL
79493: AND
79494: PUSH
79495: LD_VAR 0 4
79499: PPUSH
79500: LD_INT 3
79502: PPUSH
79503: CALL_OW 275
79507: PUSH
79508: LD_VAR 0 5
79512: PUSH
79513: LD_INT 3
79515: ARRAY
79516: GREATEREQUAL
79517: AND
79518: ST_TO_ADDR
// end ;
79519: LD_VAR 0 3
79523: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79524: LD_INT 0
79526: PPUSH
79527: PPUSH
79528: PPUSH
79529: PPUSH
79530: PPUSH
79531: PPUSH
79532: PPUSH
79533: PPUSH
79534: PPUSH
79535: PPUSH
79536: PPUSH
// result := false ;
79537: LD_ADDR_VAR 0 8
79541: PUSH
79542: LD_INT 0
79544: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79545: LD_VAR 0 5
79549: NOT
79550: PUSH
79551: LD_VAR 0 1
79555: NOT
79556: OR
79557: PUSH
79558: LD_VAR 0 2
79562: NOT
79563: OR
79564: PUSH
79565: LD_VAR 0 3
79569: NOT
79570: OR
79571: IFFALSE 79575
// exit ;
79573: GO 80389
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79575: LD_ADDR_VAR 0 14
79579: PUSH
79580: LD_VAR 0 1
79584: PPUSH
79585: LD_VAR 0 2
79589: PPUSH
79590: LD_VAR 0 3
79594: PPUSH
79595: LD_VAR 0 4
79599: PPUSH
79600: LD_VAR 0 5
79604: PUSH
79605: LD_INT 1
79607: ARRAY
79608: PPUSH
79609: CALL_OW 248
79613: PPUSH
79614: LD_INT 0
79616: PPUSH
79617: CALL 81622 0 6
79621: ST_TO_ADDR
// if not hexes then
79622: LD_VAR 0 14
79626: NOT
79627: IFFALSE 79631
// exit ;
79629: GO 80389
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79631: LD_ADDR_VAR 0 17
79635: PUSH
79636: LD_VAR 0 5
79640: PPUSH
79641: LD_INT 22
79643: PUSH
79644: LD_VAR 0 13
79648: PPUSH
79649: CALL_OW 255
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 2
79660: PUSH
79661: LD_INT 30
79663: PUSH
79664: LD_INT 0
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 30
79673: PUSH
79674: LD_INT 1
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: LIST
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PPUSH
79690: CALL_OW 72
79694: ST_TO_ADDR
// for i = 1 to hexes do
79695: LD_ADDR_VAR 0 9
79699: PUSH
79700: DOUBLE
79701: LD_INT 1
79703: DEC
79704: ST_TO_ADDR
79705: LD_VAR 0 14
79709: PUSH
79710: FOR_TO
79711: IFFALSE 80387
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79713: LD_ADDR_VAR 0 13
79717: PUSH
79718: LD_VAR 0 14
79722: PUSH
79723: LD_VAR 0 9
79727: ARRAY
79728: PUSH
79729: LD_INT 1
79731: ARRAY
79732: PPUSH
79733: LD_VAR 0 14
79737: PUSH
79738: LD_VAR 0 9
79742: ARRAY
79743: PUSH
79744: LD_INT 2
79746: ARRAY
79747: PPUSH
79748: CALL_OW 428
79752: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79753: LD_VAR 0 14
79757: PUSH
79758: LD_VAR 0 9
79762: ARRAY
79763: PUSH
79764: LD_INT 1
79766: ARRAY
79767: PPUSH
79768: LD_VAR 0 14
79772: PUSH
79773: LD_VAR 0 9
79777: ARRAY
79778: PUSH
79779: LD_INT 2
79781: ARRAY
79782: PPUSH
79783: CALL_OW 351
79787: PUSH
79788: LD_VAR 0 14
79792: PUSH
79793: LD_VAR 0 9
79797: ARRAY
79798: PUSH
79799: LD_INT 1
79801: ARRAY
79802: PPUSH
79803: LD_VAR 0 14
79807: PUSH
79808: LD_VAR 0 9
79812: ARRAY
79813: PUSH
79814: LD_INT 2
79816: ARRAY
79817: PPUSH
79818: CALL_OW 488
79822: NOT
79823: OR
79824: PUSH
79825: LD_VAR 0 13
79829: PPUSH
79830: CALL_OW 247
79834: PUSH
79835: LD_INT 3
79837: EQUAL
79838: OR
79839: IFFALSE 79845
// exit ;
79841: POP
79842: POP
79843: GO 80389
// if not tmp then
79845: LD_VAR 0 13
79849: NOT
79850: IFFALSE 79854
// continue ;
79852: GO 79710
// result := true ;
79854: LD_ADDR_VAR 0 8
79858: PUSH
79859: LD_INT 1
79861: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79862: LD_VAR 0 6
79866: PUSH
79867: LD_VAR 0 13
79871: PPUSH
79872: CALL_OW 247
79876: PUSH
79877: LD_INT 2
79879: EQUAL
79880: AND
79881: PUSH
79882: LD_VAR 0 13
79886: PPUSH
79887: CALL_OW 263
79891: PUSH
79892: LD_INT 1
79894: EQUAL
79895: AND
79896: IFFALSE 80060
// begin if IsDrivenBy ( tmp ) then
79898: LD_VAR 0 13
79902: PPUSH
79903: CALL_OW 311
79907: IFFALSE 79911
// continue ;
79909: GO 79710
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79911: LD_VAR 0 6
79915: PPUSH
79916: LD_INT 3
79918: PUSH
79919: LD_INT 60
79921: PUSH
79922: EMPTY
79923: LIST
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 3
79931: PUSH
79932: LD_INT 55
79934: PUSH
79935: EMPTY
79936: LIST
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PPUSH
79946: CALL_OW 72
79950: IFFALSE 80058
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79952: LD_ADDR_VAR 0 18
79956: PUSH
79957: LD_VAR 0 6
79961: PPUSH
79962: LD_INT 3
79964: PUSH
79965: LD_INT 60
79967: PUSH
79968: EMPTY
79969: LIST
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 3
79977: PUSH
79978: LD_INT 55
79980: PUSH
79981: EMPTY
79982: LIST
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PPUSH
79992: CALL_OW 72
79996: PUSH
79997: LD_INT 1
79999: ARRAY
80000: ST_TO_ADDR
// if IsInUnit ( driver ) then
80001: LD_VAR 0 18
80005: PPUSH
80006: CALL_OW 310
80010: IFFALSE 80021
// ComExit ( driver ) ;
80012: LD_VAR 0 18
80016: PPUSH
80017: CALL 105383 0 1
// AddComEnterUnit ( driver , tmp ) ;
80021: LD_VAR 0 18
80025: PPUSH
80026: LD_VAR 0 13
80030: PPUSH
80031: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
80035: LD_VAR 0 18
80039: PPUSH
80040: LD_VAR 0 7
80044: PPUSH
80045: CALL_OW 173
// AddComExitVehicle ( driver ) ;
80049: LD_VAR 0 18
80053: PPUSH
80054: CALL_OW 181
// end ; continue ;
80058: GO 79710
// end ; if not cleaners or not tmp in cleaners then
80060: LD_VAR 0 6
80064: NOT
80065: PUSH
80066: LD_VAR 0 13
80070: PUSH
80071: LD_VAR 0 6
80075: IN
80076: NOT
80077: OR
80078: IFFALSE 80385
// begin if dep then
80080: LD_VAR 0 17
80084: IFFALSE 80220
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
80086: LD_ADDR_VAR 0 16
80090: PUSH
80091: LD_VAR 0 17
80095: PUSH
80096: LD_INT 1
80098: ARRAY
80099: PPUSH
80100: CALL_OW 250
80104: PPUSH
80105: LD_VAR 0 17
80109: PUSH
80110: LD_INT 1
80112: ARRAY
80113: PPUSH
80114: CALL_OW 254
80118: PPUSH
80119: LD_INT 5
80121: PPUSH
80122: CALL_OW 272
80126: PUSH
80127: LD_VAR 0 17
80131: PUSH
80132: LD_INT 1
80134: ARRAY
80135: PPUSH
80136: CALL_OW 251
80140: PPUSH
80141: LD_VAR 0 17
80145: PUSH
80146: LD_INT 1
80148: ARRAY
80149: PPUSH
80150: CALL_OW 254
80154: PPUSH
80155: LD_INT 5
80157: PPUSH
80158: CALL_OW 273
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
80167: LD_VAR 0 16
80171: PUSH
80172: LD_INT 1
80174: ARRAY
80175: PPUSH
80176: LD_VAR 0 16
80180: PUSH
80181: LD_INT 2
80183: ARRAY
80184: PPUSH
80185: CALL_OW 488
80189: IFFALSE 80220
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
80191: LD_VAR 0 13
80195: PPUSH
80196: LD_VAR 0 16
80200: PUSH
80201: LD_INT 1
80203: ARRAY
80204: PPUSH
80205: LD_VAR 0 16
80209: PUSH
80210: LD_INT 2
80212: ARRAY
80213: PPUSH
80214: CALL_OW 111
// continue ;
80218: GO 79710
// end ; end ; r := GetDir ( tmp ) ;
80220: LD_ADDR_VAR 0 15
80224: PUSH
80225: LD_VAR 0 13
80229: PPUSH
80230: CALL_OW 254
80234: ST_TO_ADDR
// if r = 5 then
80235: LD_VAR 0 15
80239: PUSH
80240: LD_INT 5
80242: EQUAL
80243: IFFALSE 80253
// r := 0 ;
80245: LD_ADDR_VAR 0 15
80249: PUSH
80250: LD_INT 0
80252: ST_TO_ADDR
// for j = r to 5 do
80253: LD_ADDR_VAR 0 10
80257: PUSH
80258: DOUBLE
80259: LD_VAR 0 15
80263: DEC
80264: ST_TO_ADDR
80265: LD_INT 5
80267: PUSH
80268: FOR_TO
80269: IFFALSE 80383
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
80271: LD_ADDR_VAR 0 11
80275: PUSH
80276: LD_VAR 0 13
80280: PPUSH
80281: CALL_OW 250
80285: PPUSH
80286: LD_VAR 0 10
80290: PPUSH
80291: LD_INT 2
80293: PPUSH
80294: CALL_OW 272
80298: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
80299: LD_ADDR_VAR 0 12
80303: PUSH
80304: LD_VAR 0 13
80308: PPUSH
80309: CALL_OW 251
80313: PPUSH
80314: LD_VAR 0 10
80318: PPUSH
80319: LD_INT 2
80321: PPUSH
80322: CALL_OW 273
80326: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80327: LD_VAR 0 11
80331: PPUSH
80332: LD_VAR 0 12
80336: PPUSH
80337: CALL_OW 488
80341: PUSH
80342: LD_VAR 0 11
80346: PPUSH
80347: LD_VAR 0 12
80351: PPUSH
80352: CALL_OW 428
80356: NOT
80357: AND
80358: IFFALSE 80381
// begin ComMoveXY ( tmp , _x , _y ) ;
80360: LD_VAR 0 13
80364: PPUSH
80365: LD_VAR 0 11
80369: PPUSH
80370: LD_VAR 0 12
80374: PPUSH
80375: CALL_OW 111
// break ;
80379: GO 80383
// end ; end ;
80381: GO 80268
80383: POP
80384: POP
// end ; end ;
80385: GO 79710
80387: POP
80388: POP
// end ;
80389: LD_VAR 0 8
80393: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80394: LD_INT 0
80396: PPUSH
// result := true ;
80397: LD_ADDR_VAR 0 3
80401: PUSH
80402: LD_INT 1
80404: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80405: LD_VAR 0 2
80409: PUSH
80410: LD_INT 24
80412: DOUBLE
80413: EQUAL
80414: IFTRUE 80424
80416: LD_INT 33
80418: DOUBLE
80419: EQUAL
80420: IFTRUE 80424
80422: GO 80449
80424: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80425: LD_ADDR_VAR 0 3
80429: PUSH
80430: LD_INT 32
80432: PPUSH
80433: LD_VAR 0 1
80437: PPUSH
80438: CALL_OW 321
80442: PUSH
80443: LD_INT 2
80445: EQUAL
80446: ST_TO_ADDR
80447: GO 80765
80449: LD_INT 20
80451: DOUBLE
80452: EQUAL
80453: IFTRUE 80457
80455: GO 80482
80457: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80458: LD_ADDR_VAR 0 3
80462: PUSH
80463: LD_INT 6
80465: PPUSH
80466: LD_VAR 0 1
80470: PPUSH
80471: CALL_OW 321
80475: PUSH
80476: LD_INT 2
80478: EQUAL
80479: ST_TO_ADDR
80480: GO 80765
80482: LD_INT 22
80484: DOUBLE
80485: EQUAL
80486: IFTRUE 80496
80488: LD_INT 36
80490: DOUBLE
80491: EQUAL
80492: IFTRUE 80496
80494: GO 80521
80496: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80497: LD_ADDR_VAR 0 3
80501: PUSH
80502: LD_INT 15
80504: PPUSH
80505: LD_VAR 0 1
80509: PPUSH
80510: CALL_OW 321
80514: PUSH
80515: LD_INT 2
80517: EQUAL
80518: ST_TO_ADDR
80519: GO 80765
80521: LD_INT 30
80523: DOUBLE
80524: EQUAL
80525: IFTRUE 80529
80527: GO 80554
80529: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80530: LD_ADDR_VAR 0 3
80534: PUSH
80535: LD_INT 20
80537: PPUSH
80538: LD_VAR 0 1
80542: PPUSH
80543: CALL_OW 321
80547: PUSH
80548: LD_INT 2
80550: EQUAL
80551: ST_TO_ADDR
80552: GO 80765
80554: LD_INT 28
80556: DOUBLE
80557: EQUAL
80558: IFTRUE 80568
80560: LD_INT 21
80562: DOUBLE
80563: EQUAL
80564: IFTRUE 80568
80566: GO 80593
80568: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80569: LD_ADDR_VAR 0 3
80573: PUSH
80574: LD_INT 21
80576: PPUSH
80577: LD_VAR 0 1
80581: PPUSH
80582: CALL_OW 321
80586: PUSH
80587: LD_INT 2
80589: EQUAL
80590: ST_TO_ADDR
80591: GO 80765
80593: LD_INT 16
80595: DOUBLE
80596: EQUAL
80597: IFTRUE 80601
80599: GO 80626
80601: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80602: LD_ADDR_VAR 0 3
80606: PUSH
80607: LD_INT 84
80609: PPUSH
80610: LD_VAR 0 1
80614: PPUSH
80615: CALL_OW 321
80619: PUSH
80620: LD_INT 2
80622: EQUAL
80623: ST_TO_ADDR
80624: GO 80765
80626: LD_INT 19
80628: DOUBLE
80629: EQUAL
80630: IFTRUE 80640
80632: LD_INT 23
80634: DOUBLE
80635: EQUAL
80636: IFTRUE 80640
80638: GO 80665
80640: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80641: LD_ADDR_VAR 0 3
80645: PUSH
80646: LD_INT 83
80648: PPUSH
80649: LD_VAR 0 1
80653: PPUSH
80654: CALL_OW 321
80658: PUSH
80659: LD_INT 2
80661: EQUAL
80662: ST_TO_ADDR
80663: GO 80765
80665: LD_INT 17
80667: DOUBLE
80668: EQUAL
80669: IFTRUE 80673
80671: GO 80698
80673: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80674: LD_ADDR_VAR 0 3
80678: PUSH
80679: LD_INT 39
80681: PPUSH
80682: LD_VAR 0 1
80686: PPUSH
80687: CALL_OW 321
80691: PUSH
80692: LD_INT 2
80694: EQUAL
80695: ST_TO_ADDR
80696: GO 80765
80698: LD_INT 18
80700: DOUBLE
80701: EQUAL
80702: IFTRUE 80706
80704: GO 80731
80706: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80707: LD_ADDR_VAR 0 3
80711: PUSH
80712: LD_INT 40
80714: PPUSH
80715: LD_VAR 0 1
80719: PPUSH
80720: CALL_OW 321
80724: PUSH
80725: LD_INT 2
80727: EQUAL
80728: ST_TO_ADDR
80729: GO 80765
80731: LD_INT 27
80733: DOUBLE
80734: EQUAL
80735: IFTRUE 80739
80737: GO 80764
80739: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80740: LD_ADDR_VAR 0 3
80744: PUSH
80745: LD_INT 35
80747: PPUSH
80748: LD_VAR 0 1
80752: PPUSH
80753: CALL_OW 321
80757: PUSH
80758: LD_INT 2
80760: EQUAL
80761: ST_TO_ADDR
80762: GO 80765
80764: POP
// end ;
80765: LD_VAR 0 3
80769: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80770: LD_INT 0
80772: PPUSH
80773: PPUSH
80774: PPUSH
80775: PPUSH
80776: PPUSH
80777: PPUSH
80778: PPUSH
80779: PPUSH
80780: PPUSH
80781: PPUSH
80782: PPUSH
// result := false ;
80783: LD_ADDR_VAR 0 6
80787: PUSH
80788: LD_INT 0
80790: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80791: LD_VAR 0 1
80795: NOT
80796: PUSH
80797: LD_VAR 0 1
80801: PPUSH
80802: CALL_OW 266
80806: PUSH
80807: LD_INT 0
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: IN
80817: NOT
80818: OR
80819: PUSH
80820: LD_VAR 0 2
80824: NOT
80825: OR
80826: PUSH
80827: LD_VAR 0 5
80831: PUSH
80832: LD_INT 0
80834: PUSH
80835: LD_INT 1
80837: PUSH
80838: LD_INT 2
80840: PUSH
80841: LD_INT 3
80843: PUSH
80844: LD_INT 4
80846: PUSH
80847: LD_INT 5
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: IN
80858: NOT
80859: OR
80860: PUSH
80861: LD_VAR 0 3
80865: PPUSH
80866: LD_VAR 0 4
80870: PPUSH
80871: CALL_OW 488
80875: NOT
80876: OR
80877: IFFALSE 80881
// exit ;
80879: GO 81617
// side := GetSide ( depot ) ;
80881: LD_ADDR_VAR 0 9
80885: PUSH
80886: LD_VAR 0 1
80890: PPUSH
80891: CALL_OW 255
80895: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80896: LD_VAR 0 9
80900: PPUSH
80901: LD_VAR 0 2
80905: PPUSH
80906: CALL 80394 0 2
80910: NOT
80911: IFFALSE 80915
// exit ;
80913: GO 81617
// pom := GetBase ( depot ) ;
80915: LD_ADDR_VAR 0 10
80919: PUSH
80920: LD_VAR 0 1
80924: PPUSH
80925: CALL_OW 274
80929: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80930: LD_ADDR_VAR 0 11
80934: PUSH
80935: LD_VAR 0 2
80939: PPUSH
80940: LD_VAR 0 1
80944: PPUSH
80945: CALL_OW 248
80949: PPUSH
80950: CALL_OW 450
80954: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
80955: LD_VAR 0 10
80959: PPUSH
80960: LD_INT 1
80962: PPUSH
80963: CALL_OW 275
80967: PUSH
80968: LD_VAR 0 11
80972: PUSH
80973: LD_INT 1
80975: ARRAY
80976: GREATEREQUAL
80977: PUSH
80978: LD_VAR 0 10
80982: PPUSH
80983: LD_INT 2
80985: PPUSH
80986: CALL_OW 275
80990: PUSH
80991: LD_VAR 0 11
80995: PUSH
80996: LD_INT 2
80998: ARRAY
80999: GREATEREQUAL
81000: AND
81001: PUSH
81002: LD_VAR 0 10
81006: PPUSH
81007: LD_INT 3
81009: PPUSH
81010: CALL_OW 275
81014: PUSH
81015: LD_VAR 0 11
81019: PUSH
81020: LD_INT 3
81022: ARRAY
81023: GREATEREQUAL
81024: AND
81025: NOT
81026: IFFALSE 81030
// exit ;
81028: GO 81617
// if GetBType ( depot ) = b_depot then
81030: LD_VAR 0 1
81034: PPUSH
81035: CALL_OW 266
81039: PUSH
81040: LD_INT 0
81042: EQUAL
81043: IFFALSE 81055
// dist := 28 else
81045: LD_ADDR_VAR 0 14
81049: PUSH
81050: LD_INT 28
81052: ST_TO_ADDR
81053: GO 81063
// dist := 36 ;
81055: LD_ADDR_VAR 0 14
81059: PUSH
81060: LD_INT 36
81062: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
81063: LD_VAR 0 1
81067: PPUSH
81068: LD_VAR 0 3
81072: PPUSH
81073: LD_VAR 0 4
81077: PPUSH
81078: CALL_OW 297
81082: PUSH
81083: LD_VAR 0 14
81087: GREATER
81088: IFFALSE 81092
// exit ;
81090: GO 81617
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
81092: LD_ADDR_VAR 0 12
81096: PUSH
81097: LD_VAR 0 2
81101: PPUSH
81102: LD_VAR 0 3
81106: PPUSH
81107: LD_VAR 0 4
81111: PPUSH
81112: LD_VAR 0 5
81116: PPUSH
81117: LD_VAR 0 1
81121: PPUSH
81122: CALL_OW 248
81126: PPUSH
81127: LD_INT 0
81129: PPUSH
81130: CALL 81622 0 6
81134: ST_TO_ADDR
// if not hexes then
81135: LD_VAR 0 12
81139: NOT
81140: IFFALSE 81144
// exit ;
81142: GO 81617
// hex := GetHexInfo ( x , y ) ;
81144: LD_ADDR_VAR 0 15
81148: PUSH
81149: LD_VAR 0 3
81153: PPUSH
81154: LD_VAR 0 4
81158: PPUSH
81159: CALL_OW 546
81163: ST_TO_ADDR
// if hex [ 1 ] then
81164: LD_VAR 0 15
81168: PUSH
81169: LD_INT 1
81171: ARRAY
81172: IFFALSE 81176
// exit ;
81174: GO 81617
// height := hex [ 2 ] ;
81176: LD_ADDR_VAR 0 13
81180: PUSH
81181: LD_VAR 0 15
81185: PUSH
81186: LD_INT 2
81188: ARRAY
81189: ST_TO_ADDR
// for i = 1 to hexes do
81190: LD_ADDR_VAR 0 7
81194: PUSH
81195: DOUBLE
81196: LD_INT 1
81198: DEC
81199: ST_TO_ADDR
81200: LD_VAR 0 12
81204: PUSH
81205: FOR_TO
81206: IFFALSE 81536
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
81208: LD_VAR 0 12
81212: PUSH
81213: LD_VAR 0 7
81217: ARRAY
81218: PUSH
81219: LD_INT 1
81221: ARRAY
81222: PPUSH
81223: LD_VAR 0 12
81227: PUSH
81228: LD_VAR 0 7
81232: ARRAY
81233: PUSH
81234: LD_INT 2
81236: ARRAY
81237: PPUSH
81238: CALL_OW 488
81242: NOT
81243: PUSH
81244: LD_VAR 0 12
81248: PUSH
81249: LD_VAR 0 7
81253: ARRAY
81254: PUSH
81255: LD_INT 1
81257: ARRAY
81258: PPUSH
81259: LD_VAR 0 12
81263: PUSH
81264: LD_VAR 0 7
81268: ARRAY
81269: PUSH
81270: LD_INT 2
81272: ARRAY
81273: PPUSH
81274: CALL_OW 428
81278: PUSH
81279: LD_INT 0
81281: GREATER
81282: OR
81283: PUSH
81284: LD_VAR 0 12
81288: PUSH
81289: LD_VAR 0 7
81293: ARRAY
81294: PUSH
81295: LD_INT 1
81297: ARRAY
81298: PPUSH
81299: LD_VAR 0 12
81303: PUSH
81304: LD_VAR 0 7
81308: ARRAY
81309: PUSH
81310: LD_INT 2
81312: ARRAY
81313: PPUSH
81314: CALL_OW 351
81318: OR
81319: IFFALSE 81325
// exit ;
81321: POP
81322: POP
81323: GO 81617
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81325: LD_ADDR_VAR 0 8
81329: PUSH
81330: LD_VAR 0 12
81334: PUSH
81335: LD_VAR 0 7
81339: ARRAY
81340: PUSH
81341: LD_INT 1
81343: ARRAY
81344: PPUSH
81345: LD_VAR 0 12
81349: PUSH
81350: LD_VAR 0 7
81354: ARRAY
81355: PUSH
81356: LD_INT 2
81358: ARRAY
81359: PPUSH
81360: CALL_OW 546
81364: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81365: LD_VAR 0 8
81369: PUSH
81370: LD_INT 1
81372: ARRAY
81373: PUSH
81374: LD_VAR 0 8
81378: PUSH
81379: LD_INT 2
81381: ARRAY
81382: PUSH
81383: LD_VAR 0 13
81387: PUSH
81388: LD_INT 2
81390: PLUS
81391: GREATER
81392: OR
81393: PUSH
81394: LD_VAR 0 8
81398: PUSH
81399: LD_INT 2
81401: ARRAY
81402: PUSH
81403: LD_VAR 0 13
81407: PUSH
81408: LD_INT 2
81410: MINUS
81411: LESS
81412: OR
81413: PUSH
81414: LD_VAR 0 8
81418: PUSH
81419: LD_INT 3
81421: ARRAY
81422: PUSH
81423: LD_INT 0
81425: PUSH
81426: LD_INT 8
81428: PUSH
81429: LD_INT 9
81431: PUSH
81432: LD_INT 10
81434: PUSH
81435: LD_INT 11
81437: PUSH
81438: LD_INT 12
81440: PUSH
81441: LD_INT 13
81443: PUSH
81444: LD_INT 16
81446: PUSH
81447: LD_INT 17
81449: PUSH
81450: LD_INT 18
81452: PUSH
81453: LD_INT 19
81455: PUSH
81456: LD_INT 20
81458: PUSH
81459: LD_INT 21
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: IN
81477: NOT
81478: OR
81479: PUSH
81480: LD_VAR 0 8
81484: PUSH
81485: LD_INT 5
81487: ARRAY
81488: NOT
81489: OR
81490: PUSH
81491: LD_VAR 0 8
81495: PUSH
81496: LD_INT 6
81498: ARRAY
81499: PUSH
81500: LD_INT 1
81502: PUSH
81503: LD_INT 2
81505: PUSH
81506: LD_INT 7
81508: PUSH
81509: LD_INT 9
81511: PUSH
81512: LD_INT 10
81514: PUSH
81515: LD_INT 11
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: IN
81526: NOT
81527: OR
81528: IFFALSE 81534
// exit ;
81530: POP
81531: POP
81532: GO 81617
// end ;
81534: GO 81205
81536: POP
81537: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81538: LD_VAR 0 9
81542: PPUSH
81543: LD_VAR 0 3
81547: PPUSH
81548: LD_VAR 0 4
81552: PPUSH
81553: LD_INT 20
81555: PPUSH
81556: CALL 73569 0 4
81560: PUSH
81561: LD_INT 4
81563: ARRAY
81564: IFFALSE 81568
// exit ;
81566: GO 81617
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81568: LD_VAR 0 2
81572: PUSH
81573: LD_INT 29
81575: PUSH
81576: LD_INT 30
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: IN
81583: PUSH
81584: LD_VAR 0 3
81588: PPUSH
81589: LD_VAR 0 4
81593: PPUSH
81594: LD_VAR 0 9
81598: PPUSH
81599: CALL_OW 440
81603: NOT
81604: AND
81605: IFFALSE 81609
// exit ;
81607: GO 81617
// result := true ;
81609: LD_ADDR_VAR 0 6
81613: PUSH
81614: LD_INT 1
81616: ST_TO_ADDR
// end ;
81617: LD_VAR 0 6
81621: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81622: LD_INT 0
81624: PPUSH
81625: PPUSH
81626: PPUSH
81627: PPUSH
81628: PPUSH
81629: PPUSH
81630: PPUSH
81631: PPUSH
81632: PPUSH
81633: PPUSH
81634: PPUSH
81635: PPUSH
81636: PPUSH
81637: PPUSH
81638: PPUSH
81639: PPUSH
81640: PPUSH
81641: PPUSH
81642: PPUSH
81643: PPUSH
81644: PPUSH
81645: PPUSH
81646: PPUSH
81647: PPUSH
81648: PPUSH
81649: PPUSH
81650: PPUSH
81651: PPUSH
81652: PPUSH
81653: PPUSH
81654: PPUSH
81655: PPUSH
81656: PPUSH
81657: PPUSH
81658: PPUSH
81659: PPUSH
81660: PPUSH
81661: PPUSH
81662: PPUSH
81663: PPUSH
81664: PPUSH
81665: PPUSH
81666: PPUSH
81667: PPUSH
81668: PPUSH
81669: PPUSH
81670: PPUSH
81671: PPUSH
81672: PPUSH
81673: PPUSH
81674: PPUSH
81675: PPUSH
81676: PPUSH
81677: PPUSH
81678: PPUSH
81679: PPUSH
81680: PPUSH
81681: PPUSH
// result = [ ] ;
81682: LD_ADDR_VAR 0 7
81686: PUSH
81687: EMPTY
81688: ST_TO_ADDR
// temp_list = [ ] ;
81689: LD_ADDR_VAR 0 9
81693: PUSH
81694: EMPTY
81695: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81696: LD_VAR 0 4
81700: PUSH
81701: LD_INT 0
81703: PUSH
81704: LD_INT 1
81706: PUSH
81707: LD_INT 2
81709: PUSH
81710: LD_INT 3
81712: PUSH
81713: LD_INT 4
81715: PUSH
81716: LD_INT 5
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: IN
81727: NOT
81728: PUSH
81729: LD_VAR 0 1
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: LD_INT 1
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: IN
81744: PUSH
81745: LD_VAR 0 5
81749: PUSH
81750: LD_INT 1
81752: PUSH
81753: LD_INT 2
81755: PUSH
81756: LD_INT 3
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: LIST
81763: IN
81764: NOT
81765: AND
81766: OR
81767: IFFALSE 81771
// exit ;
81769: GO 100162
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81771: LD_VAR 0 1
81775: PUSH
81776: LD_INT 6
81778: PUSH
81779: LD_INT 7
81781: PUSH
81782: LD_INT 8
81784: PUSH
81785: LD_INT 13
81787: PUSH
81788: LD_INT 12
81790: PUSH
81791: LD_INT 15
81793: PUSH
81794: LD_INT 11
81796: PUSH
81797: LD_INT 14
81799: PUSH
81800: LD_INT 10
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: IN
81814: IFFALSE 81824
// btype = b_lab ;
81816: LD_ADDR_VAR 0 1
81820: PUSH
81821: LD_INT 6
81823: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81824: LD_VAR 0 6
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: LD_INT 1
81834: PUSH
81835: LD_INT 2
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: LIST
81842: IN
81843: NOT
81844: PUSH
81845: LD_VAR 0 1
81849: PUSH
81850: LD_INT 0
81852: PUSH
81853: LD_INT 1
81855: PUSH
81856: LD_INT 2
81858: PUSH
81859: LD_INT 3
81861: PUSH
81862: LD_INT 6
81864: PUSH
81865: LD_INT 36
81867: PUSH
81868: LD_INT 4
81870: PUSH
81871: LD_INT 5
81873: PUSH
81874: LD_INT 31
81876: PUSH
81877: LD_INT 32
81879: PUSH
81880: LD_INT 33
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: LIST
81887: LIST
81888: LIST
81889: LIST
81890: LIST
81891: LIST
81892: LIST
81893: LIST
81894: LIST
81895: IN
81896: NOT
81897: PUSH
81898: LD_VAR 0 6
81902: PUSH
81903: LD_INT 1
81905: EQUAL
81906: AND
81907: OR
81908: PUSH
81909: LD_VAR 0 1
81913: PUSH
81914: LD_INT 2
81916: PUSH
81917: LD_INT 3
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: IN
81924: NOT
81925: PUSH
81926: LD_VAR 0 6
81930: PUSH
81931: LD_INT 2
81933: EQUAL
81934: AND
81935: OR
81936: IFFALSE 81946
// mode = 0 ;
81938: LD_ADDR_VAR 0 6
81942: PUSH
81943: LD_INT 0
81945: ST_TO_ADDR
// case mode of 0 :
81946: LD_VAR 0 6
81950: PUSH
81951: LD_INT 0
81953: DOUBLE
81954: EQUAL
81955: IFTRUE 81959
81957: GO 93412
81959: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81960: LD_ADDR_VAR 0 11
81964: PUSH
81965: LD_INT 0
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 0
81977: PUSH
81978: LD_INT 1
81980: NEG
81981: PUSH
81982: EMPTY
81983: LIST
81984: LIST
81985: PUSH
81986: LD_INT 1
81988: PUSH
81989: LD_INT 0
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: PUSH
81996: LD_INT 1
81998: PUSH
81999: LD_INT 1
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 0
82008: PUSH
82009: LD_INT 1
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 1
82018: NEG
82019: PUSH
82020: LD_INT 0
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 1
82029: NEG
82030: PUSH
82031: LD_INT 1
82033: NEG
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 1
82041: NEG
82042: PUSH
82043: LD_INT 2
82045: NEG
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: LD_INT 0
82053: PUSH
82054: LD_INT 2
82056: NEG
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 1
82064: PUSH
82065: LD_INT 1
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 1
82075: PUSH
82076: LD_INT 2
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 0
82085: PUSH
82086: LD_INT 2
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 1
82095: NEG
82096: PUSH
82097: LD_INT 1
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 1
82106: PUSH
82107: LD_INT 3
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 0
82116: PUSH
82117: LD_INT 3
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: LD_INT 1
82126: NEG
82127: PUSH
82128: LD_INT 2
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82153: LD_ADDR_VAR 0 12
82157: PUSH
82158: LD_INT 0
82160: PUSH
82161: LD_INT 0
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 1
82181: PUSH
82182: LD_INT 0
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 1
82191: PUSH
82192: LD_INT 1
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 0
82201: PUSH
82202: LD_INT 1
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 1
82222: NEG
82223: PUSH
82224: LD_INT 1
82226: NEG
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 1
82234: PUSH
82235: LD_INT 1
82237: NEG
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 2
82245: PUSH
82246: LD_INT 0
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 2
82255: PUSH
82256: LD_INT 1
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: LD_INT 1
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 2
82276: NEG
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 2
82287: NEG
82288: PUSH
82289: LD_INT 1
82291: NEG
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 2
82299: NEG
82300: PUSH
82301: LD_INT 1
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 3
82310: NEG
82311: PUSH
82312: LD_INT 0
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 3
82321: NEG
82322: PUSH
82323: LD_INT 1
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: LIST
82347: LIST
82348: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82349: LD_ADDR_VAR 0 13
82353: PUSH
82354: LD_INT 0
82356: PUSH
82357: LD_INT 0
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 0
82366: PUSH
82367: LD_INT 1
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: LD_INT 0
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: LD_INT 1
82387: PUSH
82388: LD_INT 1
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 0
82397: PUSH
82398: LD_INT 1
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 1
82407: NEG
82408: PUSH
82409: LD_INT 0
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 1
82418: NEG
82419: PUSH
82420: LD_INT 1
82422: NEG
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 1
82430: NEG
82431: PUSH
82432: LD_INT 2
82434: NEG
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 2
82442: PUSH
82443: LD_INT 1
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 2
82452: PUSH
82453: LD_INT 2
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 1
82462: PUSH
82463: LD_INT 2
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 2
82472: NEG
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 2
82484: NEG
82485: PUSH
82486: LD_INT 2
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 2
82496: NEG
82497: PUSH
82498: LD_INT 3
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 3
82508: NEG
82509: PUSH
82510: LD_INT 2
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 3
82520: NEG
82521: PUSH
82522: LD_INT 3
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82548: LD_ADDR_VAR 0 14
82552: PUSH
82553: LD_INT 0
82555: PUSH
82556: LD_INT 0
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 0
82565: PUSH
82566: LD_INT 1
82568: NEG
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 1
82576: PUSH
82577: LD_INT 0
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: PUSH
82584: LD_INT 1
82586: PUSH
82587: LD_INT 1
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_INT 0
82596: PUSH
82597: LD_INT 1
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 1
82606: NEG
82607: PUSH
82608: LD_INT 0
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 1
82617: NEG
82618: PUSH
82619: LD_INT 1
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 1
82629: NEG
82630: PUSH
82631: LD_INT 2
82633: NEG
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 0
82641: PUSH
82642: LD_INT 2
82644: NEG
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 1
82652: PUSH
82653: LD_INT 1
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: LD_INT 2
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 0
82673: PUSH
82674: LD_INT 2
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 1
82683: NEG
82684: PUSH
82685: LD_INT 1
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 1
82694: NEG
82695: PUSH
82696: LD_INT 3
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 0
82706: PUSH
82707: LD_INT 3
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 1
82717: PUSH
82718: LD_INT 2
82720: NEG
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82744: LD_ADDR_VAR 0 15
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: LD_INT 1
82764: NEG
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 1
82772: PUSH
82773: LD_INT 0
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 1
82782: PUSH
82783: LD_INT 1
82785: PUSH
82786: EMPTY
82787: LIST
82788: LIST
82789: PUSH
82790: LD_INT 0
82792: PUSH
82793: LD_INT 1
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 1
82802: NEG
82803: PUSH
82804: LD_INT 0
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: LD_INT 1
82817: NEG
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 1
82825: PUSH
82826: LD_INT 1
82828: NEG
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 2
82836: PUSH
82837: LD_INT 0
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 2
82846: PUSH
82847: LD_INT 1
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 1
82856: NEG
82857: PUSH
82858: LD_INT 1
82860: PUSH
82861: EMPTY
82862: LIST
82863: LIST
82864: PUSH
82865: LD_INT 2
82867: NEG
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: EMPTY
82873: LIST
82874: LIST
82875: PUSH
82876: LD_INT 2
82878: NEG
82879: PUSH
82880: LD_INT 1
82882: NEG
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 2
82890: PUSH
82891: LD_INT 1
82893: NEG
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 3
82901: PUSH
82902: LD_INT 0
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 3
82911: PUSH
82912: LD_INT 1
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82937: LD_ADDR_VAR 0 16
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: LD_INT 0
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 0
82954: PUSH
82955: LD_INT 1
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 0
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 1
82975: PUSH
82976: LD_INT 1
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 0
82985: PUSH
82986: LD_INT 1
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 1
82995: NEG
82996: PUSH
82997: LD_INT 0
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 1
83006: NEG
83007: PUSH
83008: LD_INT 1
83010: NEG
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 1
83018: NEG
83019: PUSH
83020: LD_INT 2
83022: NEG
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: PUSH
83028: LD_INT 2
83030: PUSH
83031: LD_INT 1
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: PUSH
83038: LD_INT 2
83040: PUSH
83041: LD_INT 2
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 1
83050: PUSH
83051: LD_INT 2
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: LD_INT 2
83060: NEG
83061: PUSH
83062: LD_INT 1
83064: NEG
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 2
83072: NEG
83073: PUSH
83074: LD_INT 2
83076: NEG
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 3
83084: PUSH
83085: LD_INT 2
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 3
83094: PUSH
83095: LD_INT 3
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_INT 2
83104: PUSH
83105: LD_INT 3
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83130: LD_ADDR_VAR 0 17
83134: PUSH
83135: LD_INT 0
83137: PUSH
83138: LD_INT 0
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: PUSH
83145: LD_INT 0
83147: PUSH
83148: LD_INT 1
83150: NEG
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 1
83158: PUSH
83159: LD_INT 0
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 1
83168: PUSH
83169: LD_INT 1
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: LD_INT 0
83178: PUSH
83179: LD_INT 1
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PUSH
83186: LD_INT 1
83188: NEG
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 1
83199: NEG
83200: PUSH
83201: LD_INT 1
83203: NEG
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 1
83211: NEG
83212: PUSH
83213: LD_INT 2
83215: NEG
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 0
83223: PUSH
83224: LD_INT 2
83226: NEG
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 1
83234: PUSH
83235: LD_INT 1
83237: NEG
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 2
83245: PUSH
83246: LD_INT 0
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: PUSH
83253: LD_INT 2
83255: PUSH
83256: LD_INT 1
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 2
83265: PUSH
83266: LD_INT 2
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 1
83275: PUSH
83276: LD_INT 2
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 0
83285: PUSH
83286: LD_INT 2
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: LD_INT 1
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 2
83306: NEG
83307: PUSH
83308: LD_INT 0
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 2
83317: NEG
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 2
83329: NEG
83330: PUSH
83331: LD_INT 2
83333: NEG
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: LIST
83348: LIST
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83360: LD_ADDR_VAR 0 18
83364: PUSH
83365: LD_INT 0
83367: PUSH
83368: LD_INT 0
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 0
83377: PUSH
83378: LD_INT 1
83380: NEG
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 1
83388: PUSH
83389: LD_INT 0
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 1
83398: PUSH
83399: LD_INT 1
83401: PUSH
83402: EMPTY
83403: LIST
83404: LIST
83405: PUSH
83406: LD_INT 0
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 1
83418: NEG
83419: PUSH
83420: LD_INT 0
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 1
83429: NEG
83430: PUSH
83431: LD_INT 1
83433: NEG
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 1
83441: NEG
83442: PUSH
83443: LD_INT 2
83445: NEG
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 0
83453: PUSH
83454: LD_INT 2
83456: NEG
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 1
83464: PUSH
83465: LD_INT 1
83467: NEG
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 2
83475: PUSH
83476: LD_INT 0
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 2
83485: PUSH
83486: LD_INT 1
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: PUSH
83493: LD_INT 2
83495: PUSH
83496: LD_INT 2
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 1
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 0
83515: PUSH
83516: LD_INT 2
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 1
83525: NEG
83526: PUSH
83527: LD_INT 1
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 2
83536: NEG
83537: PUSH
83538: LD_INT 0
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 2
83547: NEG
83548: PUSH
83549: LD_INT 1
83551: NEG
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 2
83559: NEG
83560: PUSH
83561: LD_INT 2
83563: NEG
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83590: LD_ADDR_VAR 0 19
83594: PUSH
83595: LD_INT 0
83597: PUSH
83598: LD_INT 0
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: LD_INT 1
83610: NEG
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PUSH
83616: LD_INT 1
83618: PUSH
83619: LD_INT 0
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: LD_INT 1
83628: PUSH
83629: LD_INT 1
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 0
83638: PUSH
83639: LD_INT 1
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 1
83648: NEG
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 1
83659: NEG
83660: PUSH
83661: LD_INT 1
83663: NEG
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 1
83671: NEG
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 0
83683: PUSH
83684: LD_INT 2
83686: NEG
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 1
83694: PUSH
83695: LD_INT 1
83697: NEG
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 2
83705: PUSH
83706: LD_INT 0
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: PUSH
83713: LD_INT 2
83715: PUSH
83716: LD_INT 1
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 2
83725: PUSH
83726: LD_INT 2
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 1
83735: PUSH
83736: LD_INT 2
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: LD_INT 0
83745: PUSH
83746: LD_INT 2
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 1
83755: NEG
83756: PUSH
83757: LD_INT 1
83759: PUSH
83760: EMPTY
83761: LIST
83762: LIST
83763: PUSH
83764: LD_INT 2
83766: NEG
83767: PUSH
83768: LD_INT 0
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: PUSH
83775: LD_INT 2
83777: NEG
83778: PUSH
83779: LD_INT 1
83781: NEG
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 2
83789: NEG
83790: PUSH
83791: LD_INT 2
83793: NEG
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83820: LD_ADDR_VAR 0 20
83824: PUSH
83825: LD_INT 0
83827: PUSH
83828: LD_INT 0
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 0
83837: PUSH
83838: LD_INT 1
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 1
83848: PUSH
83849: LD_INT 0
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PUSH
83856: LD_INT 1
83858: PUSH
83859: LD_INT 1
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 0
83868: PUSH
83869: LD_INT 1
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: PUSH
83876: LD_INT 1
83878: NEG
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 1
83889: NEG
83890: PUSH
83891: LD_INT 1
83893: NEG
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: LD_INT 2
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: LD_INT 2
83916: NEG
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 1
83924: PUSH
83925: LD_INT 1
83927: NEG
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 2
83935: PUSH
83936: LD_INT 0
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 2
83945: PUSH
83946: LD_INT 1
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 2
83955: PUSH
83956: LD_INT 2
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 1
83965: PUSH
83966: LD_INT 2
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 0
83975: PUSH
83976: LD_INT 2
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 1
83985: NEG
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 2
83996: NEG
83997: PUSH
83998: LD_INT 0
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 2
84007: NEG
84008: PUSH
84009: LD_INT 1
84011: NEG
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 2
84019: NEG
84020: PUSH
84021: LD_INT 2
84023: NEG
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: LIST
84048: LIST
84049: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84050: LD_ADDR_VAR 0 21
84054: PUSH
84055: LD_INT 0
84057: PUSH
84058: LD_INT 0
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 0
84067: PUSH
84068: LD_INT 1
84070: NEG
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 1
84078: PUSH
84079: LD_INT 0
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 1
84088: PUSH
84089: LD_INT 1
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 0
84098: PUSH
84099: LD_INT 1
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 1
84108: NEG
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 1
84119: NEG
84120: PUSH
84121: LD_INT 1
84123: NEG
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 1
84131: NEG
84132: PUSH
84133: LD_INT 2
84135: NEG
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 0
84143: PUSH
84144: LD_INT 2
84146: NEG
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 1
84154: PUSH
84155: LD_INT 1
84157: NEG
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 2
84165: PUSH
84166: LD_INT 0
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 2
84175: PUSH
84176: LD_INT 1
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 2
84185: PUSH
84186: LD_INT 2
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 1
84195: PUSH
84196: LD_INT 2
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: LD_INT 0
84205: PUSH
84206: LD_INT 2
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 1
84215: NEG
84216: PUSH
84217: LD_INT 1
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 2
84226: NEG
84227: PUSH
84228: LD_INT 0
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 2
84237: NEG
84238: PUSH
84239: LD_INT 1
84241: NEG
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 2
84249: NEG
84250: PUSH
84251: LD_INT 2
84253: NEG
84254: PUSH
84255: EMPTY
84256: LIST
84257: LIST
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: LIST
84263: LIST
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84280: LD_ADDR_VAR 0 22
84284: PUSH
84285: LD_INT 0
84287: PUSH
84288: LD_INT 0
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 0
84297: PUSH
84298: LD_INT 1
84300: NEG
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PUSH
84306: LD_INT 1
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: PUSH
84319: LD_INT 1
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_INT 0
84328: PUSH
84329: LD_INT 1
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: PUSH
84336: LD_INT 1
84338: NEG
84339: PUSH
84340: LD_INT 0
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 1
84349: NEG
84350: PUSH
84351: LD_INT 1
84353: NEG
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: LD_INT 2
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 0
84373: PUSH
84374: LD_INT 2
84376: NEG
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 1
84384: PUSH
84385: LD_INT 1
84387: NEG
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 2
84395: PUSH
84396: LD_INT 0
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 2
84405: PUSH
84406: LD_INT 1
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 2
84415: PUSH
84416: LD_INT 2
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: PUSH
84423: LD_INT 1
84425: PUSH
84426: LD_INT 2
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: LD_INT 0
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: PUSH
84443: LD_INT 1
84445: NEG
84446: PUSH
84447: LD_INT 1
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 2
84456: NEG
84457: PUSH
84458: LD_INT 0
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 2
84467: NEG
84468: PUSH
84469: LD_INT 1
84471: NEG
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: LD_INT 2
84483: NEG
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: EMPTY
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84510: LD_ADDR_VAR 0 23
84514: PUSH
84515: LD_INT 0
84517: PUSH
84518: LD_INT 0
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: LD_INT 1
84530: NEG
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: PUSH
84536: LD_INT 1
84538: PUSH
84539: LD_INT 0
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: LD_INT 1
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: LD_INT 0
84558: PUSH
84559: LD_INT 1
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 1
84568: NEG
84569: PUSH
84570: LD_INT 0
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: LD_INT 1
84579: NEG
84580: PUSH
84581: LD_INT 1
84583: NEG
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 1
84591: NEG
84592: PUSH
84593: LD_INT 2
84595: NEG
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 0
84603: PUSH
84604: LD_INT 2
84606: NEG
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 1
84614: PUSH
84615: LD_INT 1
84617: NEG
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 2
84625: PUSH
84626: LD_INT 0
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 2
84635: PUSH
84636: LD_INT 1
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 2
84645: PUSH
84646: LD_INT 2
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 1
84655: PUSH
84656: LD_INT 2
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: LD_INT 0
84665: PUSH
84666: LD_INT 2
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: PUSH
84673: LD_INT 1
84675: NEG
84676: PUSH
84677: LD_INT 1
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: PUSH
84684: LD_INT 2
84686: NEG
84687: PUSH
84688: LD_INT 0
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: PUSH
84695: LD_INT 2
84697: NEG
84698: PUSH
84699: LD_INT 1
84701: NEG
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 2
84709: NEG
84710: PUSH
84711: LD_INT 2
84713: NEG
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 2
84721: NEG
84722: PUSH
84723: LD_INT 3
84725: NEG
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 1
84733: NEG
84734: PUSH
84735: LD_INT 3
84737: NEG
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 1
84745: PUSH
84746: LD_INT 2
84748: NEG
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: PUSH
84754: LD_INT 2
84756: PUSH
84757: LD_INT 1
84759: NEG
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: LIST
84789: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84790: LD_ADDR_VAR 0 24
84794: PUSH
84795: LD_INT 0
84797: PUSH
84798: LD_INT 0
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 0
84807: PUSH
84808: LD_INT 1
84810: NEG
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 0
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 1
84828: PUSH
84829: LD_INT 1
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 0
84838: PUSH
84839: LD_INT 1
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 1
84848: NEG
84849: PUSH
84850: LD_INT 0
84852: PUSH
84853: EMPTY
84854: LIST
84855: LIST
84856: PUSH
84857: LD_INT 1
84859: NEG
84860: PUSH
84861: LD_INT 1
84863: NEG
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: LD_INT 1
84871: NEG
84872: PUSH
84873: LD_INT 2
84875: NEG
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 0
84883: PUSH
84884: LD_INT 2
84886: NEG
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 1
84894: PUSH
84895: LD_INT 1
84897: NEG
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: PUSH
84903: LD_INT 2
84905: PUSH
84906: LD_INT 0
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: PUSH
84913: LD_INT 2
84915: PUSH
84916: LD_INT 1
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: PUSH
84923: LD_INT 2
84925: PUSH
84926: LD_INT 2
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: PUSH
84933: LD_INT 1
84935: PUSH
84936: LD_INT 2
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: PUSH
84943: LD_INT 0
84945: PUSH
84946: LD_INT 2
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: PUSH
84953: LD_INT 1
84955: NEG
84956: PUSH
84957: LD_INT 1
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: LD_INT 2
84966: NEG
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 2
84977: NEG
84978: PUSH
84979: LD_INT 1
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 2
84989: NEG
84990: PUSH
84991: LD_INT 2
84993: NEG
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 1
85001: PUSH
85002: LD_INT 2
85004: NEG
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 2
85012: PUSH
85013: LD_INT 1
85015: NEG
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 3
85023: PUSH
85024: LD_INT 1
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 3
85033: PUSH
85034: LD_INT 2
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
85066: LD_ADDR_VAR 0 25
85070: PUSH
85071: LD_INT 0
85073: PUSH
85074: LD_INT 0
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: LD_INT 1
85086: NEG
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: PUSH
85092: LD_INT 1
85094: PUSH
85095: LD_INT 0
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 1
85104: PUSH
85105: LD_INT 1
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: LD_INT 1
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 1
85124: NEG
85125: PUSH
85126: LD_INT 0
85128: PUSH
85129: EMPTY
85130: LIST
85131: LIST
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: LD_INT 1
85139: NEG
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 1
85147: NEG
85148: PUSH
85149: LD_INT 2
85151: NEG
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: PUSH
85157: LD_INT 0
85159: PUSH
85160: LD_INT 2
85162: NEG
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 1
85170: PUSH
85171: LD_INT 1
85173: NEG
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 2
85181: PUSH
85182: LD_INT 0
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PUSH
85189: LD_INT 2
85191: PUSH
85192: LD_INT 1
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 2
85201: PUSH
85202: LD_INT 2
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: PUSH
85209: LD_INT 1
85211: PUSH
85212: LD_INT 2
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: PUSH
85219: LD_INT 0
85221: PUSH
85222: LD_INT 2
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: PUSH
85229: LD_INT 1
85231: NEG
85232: PUSH
85233: LD_INT 1
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: LD_INT 2
85242: NEG
85243: PUSH
85244: LD_INT 0
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: PUSH
85251: LD_INT 2
85253: NEG
85254: PUSH
85255: LD_INT 1
85257: NEG
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 2
85265: NEG
85266: PUSH
85267: LD_INT 2
85269: NEG
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 3
85277: PUSH
85278: LD_INT 1
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: LD_INT 3
85287: PUSH
85288: LD_INT 2
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: PUSH
85295: LD_INT 2
85297: PUSH
85298: LD_INT 3
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: LD_INT 1
85307: PUSH
85308: LD_INT 3
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85340: LD_ADDR_VAR 0 26
85344: PUSH
85345: LD_INT 0
85347: PUSH
85348: LD_INT 0
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_INT 0
85357: PUSH
85358: LD_INT 1
85360: NEG
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: LD_INT 0
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 1
85378: PUSH
85379: LD_INT 1
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 0
85388: PUSH
85389: LD_INT 1
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: LD_INT 0
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 1
85409: NEG
85410: PUSH
85411: LD_INT 1
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 1
85421: NEG
85422: PUSH
85423: LD_INT 2
85425: NEG
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: LD_INT 2
85436: NEG
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: LD_INT 1
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 2
85455: PUSH
85456: LD_INT 0
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 2
85465: PUSH
85466: LD_INT 1
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 2
85475: PUSH
85476: LD_INT 2
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 1
85485: PUSH
85486: LD_INT 2
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 0
85495: PUSH
85496: LD_INT 2
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 1
85505: NEG
85506: PUSH
85507: LD_INT 1
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 2
85516: NEG
85517: PUSH
85518: LD_INT 0
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 2
85527: NEG
85528: PUSH
85529: LD_INT 1
85531: NEG
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 2
85539: NEG
85540: PUSH
85541: LD_INT 2
85543: NEG
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 2
85551: PUSH
85552: LD_INT 3
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 1
85561: PUSH
85562: LD_INT 3
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 1
85571: NEG
85572: PUSH
85573: LD_INT 2
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 2
85582: NEG
85583: PUSH
85584: LD_INT 1
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85616: LD_ADDR_VAR 0 27
85620: PUSH
85621: LD_INT 0
85623: PUSH
85624: LD_INT 0
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 0
85633: PUSH
85634: LD_INT 1
85636: NEG
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: LD_INT 0
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: LD_INT 1
85654: PUSH
85655: LD_INT 1
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 1
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 1
85674: NEG
85675: PUSH
85676: LD_INT 0
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: NEG
85686: PUSH
85687: LD_INT 1
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 1
85697: NEG
85698: PUSH
85699: LD_INT 2
85701: NEG
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: LD_INT 2
85712: NEG
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 1
85720: PUSH
85721: LD_INT 1
85723: NEG
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 2
85731: PUSH
85732: LD_INT 0
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 2
85741: PUSH
85742: LD_INT 1
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 2
85751: PUSH
85752: LD_INT 2
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 1
85761: PUSH
85762: LD_INT 2
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: LD_INT 2
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 1
85781: NEG
85782: PUSH
85783: LD_INT 1
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 2
85792: NEG
85793: PUSH
85794: LD_INT 0
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: LD_INT 2
85803: NEG
85804: PUSH
85805: LD_INT 1
85807: NEG
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: LD_INT 2
85815: NEG
85816: PUSH
85817: LD_INT 2
85819: NEG
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: LD_INT 2
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 2
85838: NEG
85839: PUSH
85840: LD_INT 1
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 3
85849: NEG
85850: PUSH
85851: LD_INT 1
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 3
85861: NEG
85862: PUSH
85863: LD_INT 2
85865: NEG
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85896: LD_ADDR_VAR 0 28
85900: PUSH
85901: LD_INT 0
85903: PUSH
85904: LD_INT 0
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 0
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: EMPTY
85919: LIST
85920: LIST
85921: PUSH
85922: LD_INT 1
85924: PUSH
85925: LD_INT 0
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 1
85934: PUSH
85935: LD_INT 1
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 0
85944: PUSH
85945: LD_INT 1
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 1
85954: NEG
85955: PUSH
85956: LD_INT 0
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: LD_INT 1
85969: NEG
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 1
85977: NEG
85978: PUSH
85979: LD_INT 2
85981: NEG
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 0
85989: PUSH
85990: LD_INT 2
85992: NEG
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 1
86000: PUSH
86001: LD_INT 1
86003: NEG
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 2
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 2
86021: PUSH
86022: LD_INT 1
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 2
86031: PUSH
86032: LD_INT 2
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 1
86041: PUSH
86042: LD_INT 2
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 0
86051: PUSH
86052: LD_INT 2
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 1
86061: NEG
86062: PUSH
86063: LD_INT 1
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 2
86072: NEG
86073: PUSH
86074: LD_INT 0
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: PUSH
86081: LD_INT 2
86083: NEG
86084: PUSH
86085: LD_INT 1
86087: NEG
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 2
86095: NEG
86096: PUSH
86097: LD_INT 2
86099: NEG
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 2
86107: NEG
86108: PUSH
86109: LD_INT 3
86111: NEG
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 1
86119: NEG
86120: PUSH
86121: LD_INT 3
86123: NEG
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PUSH
86129: LD_INT 3
86131: NEG
86132: PUSH
86133: LD_INT 1
86135: NEG
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 3
86143: NEG
86144: PUSH
86145: LD_INT 2
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86178: LD_ADDR_VAR 0 29
86182: PUSH
86183: LD_INT 0
86185: PUSH
86186: LD_INT 0
86188: PUSH
86189: EMPTY
86190: LIST
86191: LIST
86192: PUSH
86193: LD_INT 0
86195: PUSH
86196: LD_INT 1
86198: NEG
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 1
86206: PUSH
86207: LD_INT 0
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: LD_INT 1
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: LD_INT 1
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 1
86236: NEG
86237: PUSH
86238: LD_INT 0
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 1
86259: NEG
86260: PUSH
86261: LD_INT 2
86263: NEG
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 0
86271: PUSH
86272: LD_INT 2
86274: NEG
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: PUSH
86283: LD_INT 1
86285: NEG
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 2
86293: PUSH
86294: LD_INT 0
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 2
86303: PUSH
86304: LD_INT 1
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 1
86313: PUSH
86314: LD_INT 2
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 0
86323: PUSH
86324: LD_INT 2
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: PUSH
86331: LD_INT 1
86333: NEG
86334: PUSH
86335: LD_INT 1
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: LD_INT 2
86344: NEG
86345: PUSH
86346: LD_INT 1
86348: NEG
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 2
86356: NEG
86357: PUSH
86358: LD_INT 2
86360: NEG
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: PUSH
86366: LD_INT 2
86368: NEG
86369: PUSH
86370: LD_INT 3
86372: NEG
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: PUSH
86378: LD_INT 2
86380: PUSH
86381: LD_INT 1
86383: NEG
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: LD_INT 3
86391: PUSH
86392: LD_INT 1
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 1
86401: PUSH
86402: LD_INT 3
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 1
86411: NEG
86412: PUSH
86413: LD_INT 2
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: PUSH
86420: LD_INT 3
86422: NEG
86423: PUSH
86424: LD_INT 2
86426: NEG
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86457: LD_ADDR_VAR 0 30
86461: PUSH
86462: LD_INT 0
86464: PUSH
86465: LD_INT 0
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PUSH
86472: LD_INT 0
86474: PUSH
86475: LD_INT 1
86477: NEG
86478: PUSH
86479: EMPTY
86480: LIST
86481: LIST
86482: PUSH
86483: LD_INT 1
86485: PUSH
86486: LD_INT 0
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: PUSH
86493: LD_INT 1
86495: PUSH
86496: LD_INT 1
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 0
86505: PUSH
86506: LD_INT 1
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: LD_INT 0
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: PUSH
86524: LD_INT 1
86526: NEG
86527: PUSH
86528: LD_INT 1
86530: NEG
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: LD_INT 1
86538: NEG
86539: PUSH
86540: LD_INT 2
86542: NEG
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: LD_INT 2
86553: NEG
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 1
86561: PUSH
86562: LD_INT 1
86564: NEG
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: PUSH
86570: LD_INT 2
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 2
86582: PUSH
86583: LD_INT 1
86585: PUSH
86586: EMPTY
86587: LIST
86588: LIST
86589: PUSH
86590: LD_INT 2
86592: PUSH
86593: LD_INT 2
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 1
86602: PUSH
86603: LD_INT 2
86605: PUSH
86606: EMPTY
86607: LIST
86608: LIST
86609: PUSH
86610: LD_INT 1
86612: NEG
86613: PUSH
86614: LD_INT 1
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 2
86623: NEG
86624: PUSH
86625: LD_INT 0
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 2
86634: NEG
86635: PUSH
86636: LD_INT 1
86638: NEG
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 1
86646: NEG
86647: PUSH
86648: LD_INT 3
86650: NEG
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 1
86658: PUSH
86659: LD_INT 2
86661: NEG
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 3
86669: PUSH
86670: LD_INT 2
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 2
86679: PUSH
86680: LD_INT 3
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 2
86689: NEG
86690: PUSH
86691: LD_INT 1
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 3
86700: NEG
86701: PUSH
86702: LD_INT 1
86704: NEG
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86735: LD_ADDR_VAR 0 31
86739: PUSH
86740: LD_INT 0
86742: PUSH
86743: LD_INT 0
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: PUSH
86750: LD_INT 0
86752: PUSH
86753: LD_INT 1
86755: NEG
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: PUSH
86761: LD_INT 1
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 1
86773: PUSH
86774: LD_INT 1
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 0
86783: PUSH
86784: LD_INT 1
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 1
86793: NEG
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 1
86804: NEG
86805: PUSH
86806: LD_INT 1
86808: NEG
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 1
86816: NEG
86817: PUSH
86818: LD_INT 2
86820: NEG
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: LD_INT 1
86831: NEG
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 2
86839: PUSH
86840: LD_INT 0
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 2
86849: PUSH
86850: LD_INT 1
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 2
86859: PUSH
86860: LD_INT 2
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: LD_INT 1
86869: PUSH
86870: LD_INT 2
86872: PUSH
86873: EMPTY
86874: LIST
86875: LIST
86876: PUSH
86877: LD_INT 0
86879: PUSH
86880: LD_INT 2
86882: PUSH
86883: EMPTY
86884: LIST
86885: LIST
86886: PUSH
86887: LD_INT 1
86889: NEG
86890: PUSH
86891: LD_INT 1
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 2
86900: NEG
86901: PUSH
86902: LD_INT 1
86904: NEG
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 2
86912: NEG
86913: PUSH
86914: LD_INT 2
86916: NEG
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: LD_INT 2
86924: NEG
86925: PUSH
86926: LD_INT 3
86928: NEG
86929: PUSH
86930: EMPTY
86931: LIST
86932: LIST
86933: PUSH
86934: LD_INT 2
86936: PUSH
86937: LD_INT 1
86939: NEG
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PUSH
86945: LD_INT 3
86947: PUSH
86948: LD_INT 1
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 1
86957: PUSH
86958: LD_INT 3
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 1
86967: NEG
86968: PUSH
86969: LD_INT 2
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 3
86978: NEG
86979: PUSH
86980: LD_INT 2
86982: NEG
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87013: LD_ADDR_VAR 0 32
87017: PUSH
87018: LD_INT 0
87020: PUSH
87021: LD_INT 0
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: LD_INT 1
87033: NEG
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 1
87041: PUSH
87042: LD_INT 0
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 1
87051: PUSH
87052: LD_INT 1
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 0
87061: PUSH
87062: LD_INT 1
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 1
87071: NEG
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: NEG
87083: PUSH
87084: LD_INT 1
87086: NEG
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 1
87094: NEG
87095: PUSH
87096: LD_INT 2
87098: NEG
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 0
87106: PUSH
87107: LD_INT 2
87109: NEG
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PUSH
87115: LD_INT 1
87117: PUSH
87118: LD_INT 1
87120: NEG
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 2
87128: PUSH
87129: LD_INT 1
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 2
87138: PUSH
87139: LD_INT 2
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 1
87148: PUSH
87149: LD_INT 2
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: PUSH
87156: LD_INT 0
87158: PUSH
87159: LD_INT 2
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 1
87168: NEG
87169: PUSH
87170: LD_INT 1
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 2
87179: NEG
87180: PUSH
87181: LD_INT 0
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 2
87190: NEG
87191: PUSH
87192: LD_INT 1
87194: NEG
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 1
87202: NEG
87203: PUSH
87204: LD_INT 3
87206: NEG
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 1
87214: PUSH
87215: LD_INT 2
87217: NEG
87218: PUSH
87219: EMPTY
87220: LIST
87221: LIST
87222: PUSH
87223: LD_INT 3
87225: PUSH
87226: LD_INT 2
87228: PUSH
87229: EMPTY
87230: LIST
87231: LIST
87232: PUSH
87233: LD_INT 2
87235: PUSH
87236: LD_INT 3
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: PUSH
87243: LD_INT 2
87245: NEG
87246: PUSH
87247: LD_INT 1
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 3
87256: NEG
87257: PUSH
87258: LD_INT 1
87260: NEG
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: LIST
87287: LIST
87288: LIST
87289: LIST
87290: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87291: LD_ADDR_VAR 0 33
87295: PUSH
87296: LD_INT 0
87298: PUSH
87299: LD_INT 0
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 0
87308: PUSH
87309: LD_INT 1
87311: NEG
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 1
87319: PUSH
87320: LD_INT 0
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 1
87329: PUSH
87330: LD_INT 1
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 0
87339: PUSH
87340: LD_INT 1
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 1
87349: NEG
87350: PUSH
87351: LD_INT 0
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: PUSH
87358: LD_INT 1
87360: NEG
87361: PUSH
87362: LD_INT 1
87364: NEG
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: NEG
87373: PUSH
87374: LD_INT 2
87376: NEG
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 1
87384: PUSH
87385: LD_INT 1
87387: NEG
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 2
87395: PUSH
87396: LD_INT 0
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 2
87405: PUSH
87406: LD_INT 1
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 1
87415: PUSH
87416: LD_INT 2
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PUSH
87423: LD_INT 0
87425: PUSH
87426: LD_INT 2
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 1
87435: NEG
87436: PUSH
87437: LD_INT 1
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: PUSH
87444: LD_INT 2
87446: NEG
87447: PUSH
87448: LD_INT 0
87450: PUSH
87451: EMPTY
87452: LIST
87453: LIST
87454: PUSH
87455: LD_INT 2
87457: NEG
87458: PUSH
87459: LD_INT 1
87461: NEG
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 2
87469: NEG
87470: PUSH
87471: LD_INT 2
87473: NEG
87474: PUSH
87475: EMPTY
87476: LIST
87477: LIST
87478: PUSH
87479: LD_INT 2
87481: NEG
87482: PUSH
87483: LD_INT 3
87485: NEG
87486: PUSH
87487: EMPTY
87488: LIST
87489: LIST
87490: PUSH
87491: LD_INT 2
87493: PUSH
87494: LD_INT 1
87496: NEG
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 3
87504: PUSH
87505: LD_INT 1
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 1
87514: PUSH
87515: LD_INT 3
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 1
87524: NEG
87525: PUSH
87526: LD_INT 2
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 3
87535: NEG
87536: PUSH
87537: LD_INT 2
87539: NEG
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87570: LD_ADDR_VAR 0 34
87574: PUSH
87575: LD_INT 0
87577: PUSH
87578: LD_INT 0
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: LD_INT 0
87587: PUSH
87588: LD_INT 1
87590: NEG
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 1
87598: PUSH
87599: LD_INT 0
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: PUSH
87606: LD_INT 1
87608: PUSH
87609: LD_INT 1
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 0
87618: PUSH
87619: LD_INT 1
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: PUSH
87626: LD_INT 1
87628: NEG
87629: PUSH
87630: LD_INT 0
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 1
87639: NEG
87640: PUSH
87641: LD_INT 1
87643: NEG
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 1
87651: NEG
87652: PUSH
87653: LD_INT 2
87655: NEG
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 0
87663: PUSH
87664: LD_INT 2
87666: NEG
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 1
87674: PUSH
87675: LD_INT 1
87677: NEG
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 2
87685: PUSH
87686: LD_INT 1
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: PUSH
87693: LD_INT 2
87695: PUSH
87696: LD_INT 2
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: PUSH
87703: LD_INT 1
87705: PUSH
87706: LD_INT 2
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: PUSH
87713: LD_INT 1
87715: NEG
87716: PUSH
87717: LD_INT 1
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 2
87726: NEG
87727: PUSH
87728: LD_INT 0
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 2
87737: NEG
87738: PUSH
87739: LD_INT 1
87741: NEG
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: LD_INT 2
87749: NEG
87750: PUSH
87751: LD_INT 2
87753: NEG
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 1
87761: NEG
87762: PUSH
87763: LD_INT 3
87765: NEG
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 1
87773: PUSH
87774: LD_INT 2
87776: NEG
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 3
87784: PUSH
87785: LD_INT 2
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 2
87794: PUSH
87795: LD_INT 3
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: NEG
87805: PUSH
87806: LD_INT 1
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: PUSH
87813: LD_INT 3
87815: NEG
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: EMPTY
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87850: LD_ADDR_VAR 0 35
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 0
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: LD_INT 0
87867: PUSH
87868: LD_INT 1
87870: NEG
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 1
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 1
87888: PUSH
87889: LD_INT 1
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 0
87898: PUSH
87899: LD_INT 1
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 1
87908: NEG
87909: PUSH
87910: LD_INT 0
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: LD_INT 1
87919: NEG
87920: PUSH
87921: LD_INT 1
87923: NEG
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 2
87931: PUSH
87932: LD_INT 1
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PUSH
87939: LD_INT 2
87941: NEG
87942: PUSH
87943: LD_INT 1
87945: NEG
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87962: LD_ADDR_VAR 0 36
87966: PUSH
87967: LD_INT 0
87969: PUSH
87970: LD_INT 0
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 0
87979: PUSH
87980: LD_INT 1
87982: NEG
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 1
87990: PUSH
87991: LD_INT 0
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 1
88000: PUSH
88001: LD_INT 1
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: LD_INT 1
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 1
88020: NEG
88021: PUSH
88022: LD_INT 0
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: LD_INT 1
88031: NEG
88032: PUSH
88033: LD_INT 1
88035: NEG
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 1
88043: NEG
88044: PUSH
88045: LD_INT 2
88047: NEG
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 1
88055: PUSH
88056: LD_INT 2
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: LIST
88072: LIST
88073: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88074: LD_ADDR_VAR 0 37
88078: PUSH
88079: LD_INT 0
88081: PUSH
88082: LD_INT 0
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 0
88091: PUSH
88092: LD_INT 1
88094: NEG
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 1
88102: PUSH
88103: LD_INT 0
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 1
88112: PUSH
88113: LD_INT 1
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: LD_INT 0
88122: PUSH
88123: LD_INT 1
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 1
88132: NEG
88133: PUSH
88134: LD_INT 0
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 1
88143: NEG
88144: PUSH
88145: LD_INT 1
88147: NEG
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 1
88155: PUSH
88156: LD_INT 1
88158: NEG
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 1
88166: NEG
88167: PUSH
88168: LD_INT 1
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
88186: LD_ADDR_VAR 0 38
88190: PUSH
88191: LD_INT 0
88193: PUSH
88194: LD_INT 0
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: LD_INT 0
88203: PUSH
88204: LD_INT 1
88206: NEG
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: PUSH
88212: LD_INT 1
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: EMPTY
88219: LIST
88220: LIST
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: LD_INT 1
88227: PUSH
88228: EMPTY
88229: LIST
88230: LIST
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: LD_INT 1
88237: PUSH
88238: EMPTY
88239: LIST
88240: LIST
88241: PUSH
88242: LD_INT 1
88244: NEG
88245: PUSH
88246: LD_INT 0
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PUSH
88253: LD_INT 1
88255: NEG
88256: PUSH
88257: LD_INT 1
88259: NEG
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: PUSH
88265: LD_INT 2
88267: PUSH
88268: LD_INT 1
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 2
88277: NEG
88278: PUSH
88279: LD_INT 1
88281: NEG
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88298: LD_ADDR_VAR 0 39
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: LD_INT 0
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 0
88315: PUSH
88316: LD_INT 1
88318: NEG
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 1
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 1
88336: PUSH
88337: LD_INT 1
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 0
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: LD_INT 0
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: PUSH
88365: LD_INT 1
88367: NEG
88368: PUSH
88369: LD_INT 1
88371: NEG
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 1
88379: NEG
88380: PUSH
88381: LD_INT 2
88383: NEG
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PUSH
88389: LD_INT 1
88391: PUSH
88392: LD_INT 2
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88410: LD_ADDR_VAR 0 40
88414: PUSH
88415: LD_INT 0
88417: PUSH
88418: LD_INT 0
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 0
88427: PUSH
88428: LD_INT 1
88430: NEG
88431: PUSH
88432: EMPTY
88433: LIST
88434: LIST
88435: PUSH
88436: LD_INT 1
88438: PUSH
88439: LD_INT 0
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 1
88448: PUSH
88449: LD_INT 1
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PUSH
88456: LD_INT 0
88458: PUSH
88459: LD_INT 1
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: PUSH
88466: LD_INT 1
88468: NEG
88469: PUSH
88470: LD_INT 0
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: LD_INT 1
88479: NEG
88480: PUSH
88481: LD_INT 1
88483: NEG
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 1
88491: PUSH
88492: LD_INT 1
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 1
88502: NEG
88503: PUSH
88504: LD_INT 1
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88522: LD_ADDR_VAR 0 41
88526: PUSH
88527: LD_INT 0
88529: PUSH
88530: LD_INT 0
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: PUSH
88537: LD_INT 0
88539: PUSH
88540: LD_INT 1
88542: NEG
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 1
88550: PUSH
88551: LD_INT 0
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 1
88560: PUSH
88561: LD_INT 1
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 0
88570: PUSH
88571: LD_INT 1
88573: PUSH
88574: EMPTY
88575: LIST
88576: LIST
88577: PUSH
88578: LD_INT 1
88580: NEG
88581: PUSH
88582: LD_INT 0
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 1
88591: NEG
88592: PUSH
88593: LD_INT 1
88595: NEG
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: LD_INT 1
88603: NEG
88604: PUSH
88605: LD_INT 2
88607: NEG
88608: PUSH
88609: EMPTY
88610: LIST
88611: LIST
88612: PUSH
88613: LD_INT 1
88615: PUSH
88616: LD_INT 1
88618: NEG
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: PUSH
88624: LD_INT 2
88626: PUSH
88627: LD_INT 0
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: LD_INT 2
88636: PUSH
88637: LD_INT 1
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: PUSH
88644: LD_INT 2
88646: PUSH
88647: LD_INT 2
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 1
88656: PUSH
88657: LD_INT 2
88659: PUSH
88660: EMPTY
88661: LIST
88662: LIST
88663: PUSH
88664: LD_INT 1
88666: NEG
88667: PUSH
88668: LD_INT 1
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: PUSH
88675: LD_INT 2
88677: NEG
88678: PUSH
88679: LD_INT 0
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: PUSH
88686: LD_INT 2
88688: NEG
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 2
88700: NEG
88701: PUSH
88702: LD_INT 2
88704: NEG
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 2
88712: NEG
88713: PUSH
88714: LD_INT 3
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 2
88724: PUSH
88725: LD_INT 1
88727: NEG
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 3
88735: PUSH
88736: LD_INT 0
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 3
88745: PUSH
88746: LD_INT 1
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 3
88755: PUSH
88756: LD_INT 2
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 3
88765: PUSH
88766: LD_INT 3
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 2
88775: PUSH
88776: LD_INT 3
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 2
88785: NEG
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 3
88796: NEG
88797: PUSH
88798: LD_INT 0
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 3
88807: NEG
88808: PUSH
88809: LD_INT 1
88811: NEG
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 3
88819: NEG
88820: PUSH
88821: LD_INT 2
88823: NEG
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 3
88831: NEG
88832: PUSH
88833: LD_INT 3
88835: NEG
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88872: LD_ADDR_VAR 0 42
88876: PUSH
88877: LD_INT 0
88879: PUSH
88880: LD_INT 0
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 0
88889: PUSH
88890: LD_INT 1
88892: NEG
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 1
88900: PUSH
88901: LD_INT 0
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 1
88910: PUSH
88911: LD_INT 1
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 0
88920: PUSH
88921: LD_INT 1
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 1
88930: NEG
88931: PUSH
88932: LD_INT 0
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: LD_INT 1
88941: NEG
88942: PUSH
88943: LD_INT 1
88945: NEG
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: LD_INT 1
88953: NEG
88954: PUSH
88955: LD_INT 2
88957: NEG
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: PUSH
88963: LD_INT 0
88965: PUSH
88966: LD_INT 2
88968: NEG
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 1
88976: PUSH
88977: LD_INT 1
88979: NEG
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 2
88987: PUSH
88988: LD_INT 1
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 2
88997: PUSH
88998: LD_INT 2
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 1
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 0
89017: PUSH
89018: LD_INT 2
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 1
89027: NEG
89028: PUSH
89029: LD_INT 1
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 2
89038: NEG
89039: PUSH
89040: LD_INT 1
89042: NEG
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: LD_INT 2
89050: NEG
89051: PUSH
89052: LD_INT 2
89054: NEG
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 2
89062: NEG
89063: PUSH
89064: LD_INT 3
89066: NEG
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 1
89074: NEG
89075: PUSH
89076: LD_INT 3
89078: NEG
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 0
89086: PUSH
89087: LD_INT 3
89089: NEG
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: PUSH
89098: LD_INT 2
89100: NEG
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 3
89108: PUSH
89109: LD_INT 2
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: LD_INT 3
89118: PUSH
89119: LD_INT 3
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: LD_INT 2
89128: PUSH
89129: LD_INT 3
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: PUSH
89136: LD_INT 1
89138: PUSH
89139: LD_INT 3
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 0
89148: PUSH
89149: LD_INT 3
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 1
89158: NEG
89159: PUSH
89160: LD_INT 2
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: LD_INT 3
89169: NEG
89170: PUSH
89171: LD_INT 2
89173: NEG
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 3
89181: NEG
89182: PUSH
89183: LD_INT 3
89185: NEG
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89222: LD_ADDR_VAR 0 43
89226: PUSH
89227: LD_INT 0
89229: PUSH
89230: LD_INT 0
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: LD_INT 1
89242: NEG
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 1
89250: PUSH
89251: LD_INT 0
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 1
89260: PUSH
89261: LD_INT 1
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 0
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 1
89280: NEG
89281: PUSH
89282: LD_INT 0
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 1
89291: NEG
89292: PUSH
89293: LD_INT 1
89295: NEG
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: PUSH
89301: LD_INT 1
89303: NEG
89304: PUSH
89305: LD_INT 2
89307: NEG
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: LD_INT 2
89318: NEG
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 1
89326: PUSH
89327: LD_INT 1
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 2
89337: PUSH
89338: LD_INT 0
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 2
89347: PUSH
89348: LD_INT 1
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 1
89357: PUSH
89358: LD_INT 2
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 0
89367: PUSH
89368: LD_INT 2
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 1
89377: NEG
89378: PUSH
89379: LD_INT 1
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: LD_INT 2
89388: NEG
89389: PUSH
89390: LD_INT 0
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: PUSH
89397: LD_INT 2
89399: NEG
89400: PUSH
89401: LD_INT 1
89403: NEG
89404: PUSH
89405: EMPTY
89406: LIST
89407: LIST
89408: PUSH
89409: LD_INT 1
89411: NEG
89412: PUSH
89413: LD_INT 3
89415: NEG
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PUSH
89421: LD_INT 0
89423: PUSH
89424: LD_INT 3
89426: NEG
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 1
89434: PUSH
89435: LD_INT 2
89437: NEG
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 2
89445: PUSH
89446: LD_INT 1
89448: NEG
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 3
89456: PUSH
89457: LD_INT 0
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 3
89466: PUSH
89467: LD_INT 1
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PUSH
89474: LD_INT 1
89476: PUSH
89477: LD_INT 3
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 0
89486: PUSH
89487: LD_INT 3
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 1
89496: NEG
89497: PUSH
89498: LD_INT 2
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: LD_INT 2
89507: NEG
89508: PUSH
89509: LD_INT 1
89511: PUSH
89512: EMPTY
89513: LIST
89514: LIST
89515: PUSH
89516: LD_INT 3
89518: NEG
89519: PUSH
89520: LD_INT 0
89522: PUSH
89523: EMPTY
89524: LIST
89525: LIST
89526: PUSH
89527: LD_INT 3
89529: NEG
89530: PUSH
89531: LD_INT 1
89533: NEG
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: EMPTY
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89570: LD_ADDR_VAR 0 44
89574: PUSH
89575: LD_INT 0
89577: PUSH
89578: LD_INT 0
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: LD_INT 0
89587: PUSH
89588: LD_INT 1
89590: NEG
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 1
89598: PUSH
89599: LD_INT 0
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 1
89608: PUSH
89609: LD_INT 1
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 0
89618: PUSH
89619: LD_INT 1
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 1
89628: NEG
89629: PUSH
89630: LD_INT 0
89632: PUSH
89633: EMPTY
89634: LIST
89635: LIST
89636: PUSH
89637: LD_INT 1
89639: NEG
89640: PUSH
89641: LD_INT 1
89643: NEG
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 1
89651: NEG
89652: PUSH
89653: LD_INT 2
89655: NEG
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 1
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 2
89674: PUSH
89675: LD_INT 0
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: LD_INT 2
89684: PUSH
89685: LD_INT 1
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: PUSH
89692: LD_INT 2
89694: PUSH
89695: LD_INT 2
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: PUSH
89702: LD_INT 1
89704: PUSH
89705: LD_INT 2
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: LD_INT 1
89714: NEG
89715: PUSH
89716: LD_INT 1
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: LD_INT 2
89725: NEG
89726: PUSH
89727: LD_INT 0
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: LD_INT 2
89736: NEG
89737: PUSH
89738: LD_INT 1
89740: NEG
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: PUSH
89746: LD_INT 2
89748: NEG
89749: PUSH
89750: LD_INT 2
89752: NEG
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 2
89760: NEG
89761: PUSH
89762: LD_INT 3
89764: NEG
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 2
89772: PUSH
89773: LD_INT 1
89775: NEG
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 3
89783: PUSH
89784: LD_INT 0
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 3
89793: PUSH
89794: LD_INT 1
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 3
89803: PUSH
89804: LD_INT 2
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 3
89813: PUSH
89814: LD_INT 3
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 2
89823: PUSH
89824: LD_INT 3
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 2
89833: NEG
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 3
89844: NEG
89845: PUSH
89846: LD_INT 0
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 3
89855: NEG
89856: PUSH
89857: LD_INT 1
89859: NEG
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 3
89867: NEG
89868: PUSH
89869: LD_INT 2
89871: NEG
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 3
89879: NEG
89880: PUSH
89881: LD_INT 3
89883: NEG
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89920: LD_ADDR_VAR 0 45
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: LD_INT 0
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 0
89937: PUSH
89938: LD_INT 1
89940: NEG
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: LD_INT 1
89948: PUSH
89949: LD_INT 0
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 1
89958: PUSH
89959: LD_INT 1
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: PUSH
89966: LD_INT 0
89968: PUSH
89969: LD_INT 1
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 1
89978: NEG
89979: PUSH
89980: LD_INT 0
89982: PUSH
89983: EMPTY
89984: LIST
89985: LIST
89986: PUSH
89987: LD_INT 1
89989: NEG
89990: PUSH
89991: LD_INT 1
89993: NEG
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: LD_INT 2
90005: NEG
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 0
90013: PUSH
90014: LD_INT 2
90016: NEG
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: PUSH
90022: LD_INT 1
90024: PUSH
90025: LD_INT 1
90027: NEG
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 2
90035: PUSH
90036: LD_INT 1
90038: PUSH
90039: EMPTY
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 2
90045: PUSH
90046: LD_INT 2
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 1
90055: PUSH
90056: LD_INT 2
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PUSH
90063: LD_INT 0
90065: PUSH
90066: LD_INT 2
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: PUSH
90073: LD_INT 1
90075: NEG
90076: PUSH
90077: LD_INT 1
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 2
90086: NEG
90087: PUSH
90088: LD_INT 1
90090: NEG
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 2
90098: NEG
90099: PUSH
90100: LD_INT 2
90102: NEG
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: LD_INT 2
90110: NEG
90111: PUSH
90112: LD_INT 3
90114: NEG
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 1
90122: NEG
90123: PUSH
90124: LD_INT 3
90126: NEG
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 0
90134: PUSH
90135: LD_INT 3
90137: NEG
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 1
90145: PUSH
90146: LD_INT 2
90148: NEG
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 3
90156: PUSH
90157: LD_INT 2
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 3
90166: PUSH
90167: LD_INT 3
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 2
90176: PUSH
90177: LD_INT 3
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 1
90186: PUSH
90187: LD_INT 3
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 0
90196: PUSH
90197: LD_INT 3
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 1
90206: NEG
90207: PUSH
90208: LD_INT 2
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 3
90217: NEG
90218: PUSH
90219: LD_INT 2
90221: NEG
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PUSH
90227: LD_INT 3
90229: NEG
90230: PUSH
90231: LD_INT 3
90233: NEG
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90270: LD_ADDR_VAR 0 46
90274: PUSH
90275: LD_INT 0
90277: PUSH
90278: LD_INT 0
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 0
90287: PUSH
90288: LD_INT 1
90290: NEG
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 1
90298: PUSH
90299: LD_INT 0
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 1
90308: PUSH
90309: LD_INT 1
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 0
90318: PUSH
90319: LD_INT 1
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: PUSH
90326: LD_INT 1
90328: NEG
90329: PUSH
90330: LD_INT 0
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 1
90339: NEG
90340: PUSH
90341: LD_INT 1
90343: NEG
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: LD_INT 1
90351: NEG
90352: PUSH
90353: LD_INT 2
90355: NEG
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 0
90363: PUSH
90364: LD_INT 2
90366: NEG
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 1
90374: PUSH
90375: LD_INT 1
90377: NEG
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 2
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 2
90395: PUSH
90396: LD_INT 1
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: PUSH
90403: LD_INT 1
90405: PUSH
90406: LD_INT 2
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: PUSH
90413: LD_INT 0
90415: PUSH
90416: LD_INT 2
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 1
90425: NEG
90426: PUSH
90427: LD_INT 1
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 2
90436: NEG
90437: PUSH
90438: LD_INT 0
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 2
90447: NEG
90448: PUSH
90449: LD_INT 1
90451: NEG
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: LD_INT 1
90459: NEG
90460: PUSH
90461: LD_INT 3
90463: NEG
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 0
90471: PUSH
90472: LD_INT 3
90474: NEG
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: LD_INT 2
90485: NEG
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: LD_INT 2
90493: PUSH
90494: LD_INT 1
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 3
90504: PUSH
90505: LD_INT 0
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 3
90514: PUSH
90515: LD_INT 1
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 1
90524: PUSH
90525: LD_INT 3
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 0
90534: PUSH
90535: LD_INT 3
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 1
90544: NEG
90545: PUSH
90546: LD_INT 2
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 2
90555: NEG
90556: PUSH
90557: LD_INT 1
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 3
90566: NEG
90567: PUSH
90568: LD_INT 0
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: LD_INT 3
90577: NEG
90578: PUSH
90579: LD_INT 1
90581: NEG
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90618: LD_ADDR_VAR 0 47
90622: PUSH
90623: LD_INT 0
90625: PUSH
90626: LD_INT 0
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: PUSH
90633: LD_INT 0
90635: PUSH
90636: LD_INT 1
90638: NEG
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: LD_INT 1
90646: PUSH
90647: LD_INT 0
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: LD_INT 1
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: LD_INT 1
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 1
90676: NEG
90677: PUSH
90678: LD_INT 0
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 1
90687: NEG
90688: PUSH
90689: LD_INT 1
90691: NEG
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: LD_INT 2
90703: NEG
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: LD_INT 2
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: PUSH
90723: LD_INT 1
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 2
90733: NEG
90734: PUSH
90735: LD_INT 1
90737: NEG
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 2
90745: NEG
90746: PUSH
90747: LD_INT 2
90749: NEG
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90769: LD_ADDR_VAR 0 48
90773: PUSH
90774: LD_INT 0
90776: PUSH
90777: LD_INT 0
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 0
90786: PUSH
90787: LD_INT 1
90789: NEG
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: LD_INT 1
90797: PUSH
90798: LD_INT 0
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: PUSH
90805: LD_INT 1
90807: PUSH
90808: LD_INT 1
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 0
90817: PUSH
90818: LD_INT 1
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 1
90827: NEG
90828: PUSH
90829: LD_INT 0
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 1
90838: NEG
90839: PUSH
90840: LD_INT 1
90842: NEG
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 1
90850: NEG
90851: PUSH
90852: LD_INT 2
90854: NEG
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 0
90862: PUSH
90863: LD_INT 2
90865: NEG
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 1
90873: PUSH
90874: LD_INT 1
90876: NEG
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 2
90884: PUSH
90885: LD_INT 0
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 2
90894: PUSH
90895: LD_INT 1
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90916: LD_ADDR_VAR 0 49
90920: PUSH
90921: LD_INT 0
90923: PUSH
90924: LD_INT 0
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 0
90933: PUSH
90934: LD_INT 1
90936: NEG
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 1
90944: PUSH
90945: LD_INT 0
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 1
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 0
90964: PUSH
90965: LD_INT 1
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 1
90974: NEG
90975: PUSH
90976: LD_INT 0
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: LD_INT 1
90985: NEG
90986: PUSH
90987: LD_INT 1
90989: NEG
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: PUSH
90995: LD_INT 1
90997: PUSH
90998: LD_INT 1
91000: NEG
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 2
91008: PUSH
91009: LD_INT 0
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: PUSH
91016: LD_INT 2
91018: PUSH
91019: LD_INT 1
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 2
91028: PUSH
91029: LD_INT 2
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 1
91038: PUSH
91039: LD_INT 2
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91060: LD_ADDR_VAR 0 50
91064: PUSH
91065: LD_INT 0
91067: PUSH
91068: LD_INT 0
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: PUSH
91075: LD_INT 0
91077: PUSH
91078: LD_INT 1
91080: NEG
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 1
91088: PUSH
91089: LD_INT 0
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 1
91098: PUSH
91099: LD_INT 1
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: LD_INT 0
91108: PUSH
91109: LD_INT 1
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 1
91118: NEG
91119: PUSH
91120: LD_INT 0
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: LD_INT 1
91133: NEG
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PUSH
91139: LD_INT 2
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 2
91151: PUSH
91152: LD_INT 2
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: LD_INT 1
91161: PUSH
91162: LD_INT 2
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: LD_INT 2
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: LD_INT 1
91181: NEG
91182: PUSH
91183: LD_INT 1
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: EMPTY
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91204: LD_ADDR_VAR 0 51
91208: PUSH
91209: LD_INT 0
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 0
91221: PUSH
91222: LD_INT 1
91224: NEG
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 1
91232: PUSH
91233: LD_INT 0
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 1
91242: PUSH
91243: LD_INT 1
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: PUSH
91250: LD_INT 0
91252: PUSH
91253: LD_INT 1
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 1
91262: NEG
91263: PUSH
91264: LD_INT 0
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: LD_INT 1
91273: NEG
91274: PUSH
91275: LD_INT 1
91277: NEG
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: LD_INT 1
91285: PUSH
91286: LD_INT 2
91288: PUSH
91289: EMPTY
91290: LIST
91291: LIST
91292: PUSH
91293: LD_INT 0
91295: PUSH
91296: LD_INT 2
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 1
91305: NEG
91306: PUSH
91307: LD_INT 1
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 2
91316: NEG
91317: PUSH
91318: LD_INT 0
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 2
91327: NEG
91328: PUSH
91329: LD_INT 1
91331: NEG
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91351: LD_ADDR_VAR 0 52
91355: PUSH
91356: LD_INT 0
91358: PUSH
91359: LD_INT 0
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: LD_INT 0
91368: PUSH
91369: LD_INT 1
91371: NEG
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 1
91379: PUSH
91380: LD_INT 0
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 1
91389: PUSH
91390: LD_INT 1
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 0
91399: PUSH
91400: LD_INT 1
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: LD_INT 1
91409: NEG
91410: PUSH
91411: LD_INT 0
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 1
91420: NEG
91421: PUSH
91422: LD_INT 1
91424: NEG
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: PUSH
91430: LD_INT 1
91432: NEG
91433: PUSH
91434: LD_INT 2
91436: NEG
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: PUSH
91442: LD_INT 1
91444: NEG
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: PUSH
91453: LD_INT 2
91455: NEG
91456: PUSH
91457: LD_INT 0
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 2
91466: NEG
91467: PUSH
91468: LD_INT 1
91470: NEG
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 2
91478: NEG
91479: PUSH
91480: LD_INT 2
91482: NEG
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91502: LD_ADDR_VAR 0 53
91506: PUSH
91507: LD_INT 0
91509: PUSH
91510: LD_INT 0
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: LD_INT 0
91519: PUSH
91520: LD_INT 1
91522: NEG
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 1
91530: PUSH
91531: LD_INT 0
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: PUSH
91538: LD_INT 1
91540: PUSH
91541: LD_INT 1
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: PUSH
91548: LD_INT 0
91550: PUSH
91551: LD_INT 1
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: PUSH
91558: LD_INT 1
91560: NEG
91561: PUSH
91562: LD_INT 0
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 1
91571: NEG
91572: PUSH
91573: LD_INT 1
91575: NEG
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 1
91583: NEG
91584: PUSH
91585: LD_INT 2
91587: NEG
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 0
91595: PUSH
91596: LD_INT 2
91598: NEG
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: PUSH
91607: LD_INT 1
91609: NEG
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: PUSH
91615: LD_INT 2
91617: PUSH
91618: LD_INT 0
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: PUSH
91625: LD_INT 2
91627: PUSH
91628: LD_INT 1
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: LD_INT 2
91637: PUSH
91638: LD_INT 2
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: LD_INT 1
91647: PUSH
91648: LD_INT 2
91650: PUSH
91651: EMPTY
91652: LIST
91653: LIST
91654: PUSH
91655: LD_INT 0
91657: PUSH
91658: LD_INT 2
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: LD_INT 1
91667: NEG
91668: PUSH
91669: LD_INT 1
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 2
91678: NEG
91679: PUSH
91680: LD_INT 0
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 2
91689: NEG
91690: PUSH
91691: LD_INT 1
91693: NEG
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: PUSH
91699: LD_INT 2
91701: NEG
91702: PUSH
91703: LD_INT 2
91705: NEG
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: PUSH
91711: EMPTY
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91732: LD_ADDR_VAR 0 54
91736: PUSH
91737: LD_INT 0
91739: PUSH
91740: LD_INT 0
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 0
91749: PUSH
91750: LD_INT 1
91752: NEG
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 1
91760: PUSH
91761: LD_INT 0
91763: PUSH
91764: EMPTY
91765: LIST
91766: LIST
91767: PUSH
91768: LD_INT 1
91770: PUSH
91771: LD_INT 1
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 0
91780: PUSH
91781: LD_INT 1
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 1
91790: NEG
91791: PUSH
91792: LD_INT 0
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 1
91801: NEG
91802: PUSH
91803: LD_INT 1
91805: NEG
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 1
91813: NEG
91814: PUSH
91815: LD_INT 2
91817: NEG
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 0
91825: PUSH
91826: LD_INT 2
91828: NEG
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 1
91836: PUSH
91837: LD_INT 1
91839: NEG
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 2
91847: PUSH
91848: LD_INT 0
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: PUSH
91855: LD_INT 2
91857: PUSH
91858: LD_INT 1
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: LD_INT 2
91867: PUSH
91868: LD_INT 2
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: PUSH
91875: LD_INT 1
91877: PUSH
91878: LD_INT 2
91880: PUSH
91881: EMPTY
91882: LIST
91883: LIST
91884: PUSH
91885: LD_INT 0
91887: PUSH
91888: LD_INT 2
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: LD_INT 1
91897: NEG
91898: PUSH
91899: LD_INT 1
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: PUSH
91906: LD_INT 2
91908: NEG
91909: PUSH
91910: LD_INT 0
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: PUSH
91917: LD_INT 2
91919: NEG
91920: PUSH
91921: LD_INT 1
91923: NEG
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 2
91931: NEG
91932: PUSH
91933: LD_INT 2
91935: NEG
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: LIST
91952: LIST
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91962: LD_ADDR_VAR 0 55
91966: PUSH
91967: LD_INT 0
91969: PUSH
91970: LD_INT 0
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: LD_INT 0
91979: PUSH
91980: LD_INT 1
91982: NEG
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: LD_INT 1
91990: PUSH
91991: LD_INT 0
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: PUSH
91998: LD_INT 1
92000: PUSH
92001: LD_INT 1
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: LD_INT 0
92010: PUSH
92011: LD_INT 1
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 1
92020: NEG
92021: PUSH
92022: LD_INT 0
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 1
92031: NEG
92032: PUSH
92033: LD_INT 1
92035: NEG
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 1
92043: NEG
92044: PUSH
92045: LD_INT 2
92047: NEG
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: LD_INT 0
92055: PUSH
92056: LD_INT 2
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 1
92066: PUSH
92067: LD_INT 1
92069: NEG
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 2
92077: PUSH
92078: LD_INT 0
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 2
92087: PUSH
92088: LD_INT 1
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: PUSH
92095: LD_INT 2
92097: PUSH
92098: LD_INT 2
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 1
92107: PUSH
92108: LD_INT 2
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: LD_INT 0
92117: PUSH
92118: LD_INT 2
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 1
92127: NEG
92128: PUSH
92129: LD_INT 1
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: PUSH
92136: LD_INT 2
92138: NEG
92139: PUSH
92140: LD_INT 0
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 2
92149: NEG
92150: PUSH
92151: LD_INT 1
92153: NEG
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 2
92161: NEG
92162: PUSH
92163: LD_INT 2
92165: NEG
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92192: LD_ADDR_VAR 0 56
92196: PUSH
92197: LD_INT 0
92199: PUSH
92200: LD_INT 0
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: LD_INT 0
92209: PUSH
92210: LD_INT 1
92212: NEG
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 1
92220: PUSH
92221: LD_INT 0
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PUSH
92228: LD_INT 1
92230: PUSH
92231: LD_INT 1
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: LD_INT 0
92240: PUSH
92241: LD_INT 1
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: PUSH
92248: LD_INT 1
92250: NEG
92251: PUSH
92252: LD_INT 0
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: PUSH
92259: LD_INT 1
92261: NEG
92262: PUSH
92263: LD_INT 1
92265: NEG
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 1
92273: NEG
92274: PUSH
92275: LD_INT 2
92277: NEG
92278: PUSH
92279: EMPTY
92280: LIST
92281: LIST
92282: PUSH
92283: LD_INT 0
92285: PUSH
92286: LD_INT 2
92288: NEG
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 1
92296: PUSH
92297: LD_INT 1
92299: NEG
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: LD_INT 2
92307: PUSH
92308: LD_INT 0
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: PUSH
92315: LD_INT 2
92317: PUSH
92318: LD_INT 1
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PUSH
92325: LD_INT 2
92327: PUSH
92328: LD_INT 2
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: PUSH
92335: LD_INT 1
92337: PUSH
92338: LD_INT 2
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 0
92347: PUSH
92348: LD_INT 2
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: LD_INT 1
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: PUSH
92366: LD_INT 2
92368: NEG
92369: PUSH
92370: LD_INT 0
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 2
92379: NEG
92380: PUSH
92381: LD_INT 1
92383: NEG
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: PUSH
92389: LD_INT 2
92391: NEG
92392: PUSH
92393: LD_INT 2
92395: NEG
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92422: LD_ADDR_VAR 0 57
92426: PUSH
92427: LD_INT 0
92429: PUSH
92430: LD_INT 0
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 0
92439: PUSH
92440: LD_INT 1
92442: NEG
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: PUSH
92448: LD_INT 1
92450: PUSH
92451: LD_INT 0
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 1
92460: PUSH
92461: LD_INT 1
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: PUSH
92468: LD_INT 0
92470: PUSH
92471: LD_INT 1
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 1
92480: NEG
92481: PUSH
92482: LD_INT 0
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 1
92491: NEG
92492: PUSH
92493: LD_INT 1
92495: NEG
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 1
92503: NEG
92504: PUSH
92505: LD_INT 2
92507: NEG
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: LD_INT 0
92515: PUSH
92516: LD_INT 2
92518: NEG
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 1
92526: PUSH
92527: LD_INT 1
92529: NEG
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 2
92537: PUSH
92538: LD_INT 0
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 2
92547: PUSH
92548: LD_INT 1
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 2
92557: PUSH
92558: LD_INT 2
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: LD_INT 1
92567: PUSH
92568: LD_INT 2
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 0
92577: PUSH
92578: LD_INT 2
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: LD_INT 1
92587: NEG
92588: PUSH
92589: LD_INT 1
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: LD_INT 2
92598: NEG
92599: PUSH
92600: LD_INT 0
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 2
92609: NEG
92610: PUSH
92611: LD_INT 1
92613: NEG
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 2
92621: NEG
92622: PUSH
92623: LD_INT 2
92625: NEG
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92652: LD_ADDR_VAR 0 58
92656: PUSH
92657: LD_INT 0
92659: PUSH
92660: LD_INT 0
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 0
92669: PUSH
92670: LD_INT 1
92672: NEG
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PUSH
92678: LD_INT 1
92680: PUSH
92681: LD_INT 0
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 1
92690: PUSH
92691: LD_INT 1
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 0
92700: PUSH
92701: LD_INT 1
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: LD_INT 1
92710: NEG
92711: PUSH
92712: LD_INT 0
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PUSH
92719: LD_INT 1
92721: NEG
92722: PUSH
92723: LD_INT 1
92725: NEG
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: LD_INT 2
92737: NEG
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 0
92745: PUSH
92746: LD_INT 2
92748: NEG
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 1
92756: PUSH
92757: LD_INT 1
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 2
92767: PUSH
92768: LD_INT 0
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: LD_INT 2
92777: PUSH
92778: LD_INT 1
92780: PUSH
92781: EMPTY
92782: LIST
92783: LIST
92784: PUSH
92785: LD_INT 2
92787: PUSH
92788: LD_INT 2
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: PUSH
92795: LD_INT 1
92797: PUSH
92798: LD_INT 2
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 0
92807: PUSH
92808: LD_INT 2
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: LD_INT 1
92817: NEG
92818: PUSH
92819: LD_INT 1
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 2
92828: NEG
92829: PUSH
92830: LD_INT 0
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 2
92839: NEG
92840: PUSH
92841: LD_INT 1
92843: NEG
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 2
92851: NEG
92852: PUSH
92853: LD_INT 2
92855: NEG
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92882: LD_ADDR_VAR 0 59
92886: PUSH
92887: LD_INT 0
92889: PUSH
92890: LD_INT 0
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 0
92899: PUSH
92900: LD_INT 1
92902: NEG
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 1
92910: PUSH
92911: LD_INT 0
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 1
92920: PUSH
92921: LD_INT 1
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 0
92930: PUSH
92931: LD_INT 1
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: LD_INT 1
92940: NEG
92941: PUSH
92942: LD_INT 0
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 1
92951: NEG
92952: PUSH
92953: LD_INT 1
92955: NEG
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92970: LD_ADDR_VAR 0 60
92974: PUSH
92975: LD_INT 0
92977: PUSH
92978: LD_INT 0
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 0
92987: PUSH
92988: LD_INT 1
92990: NEG
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: PUSH
92996: LD_INT 1
92998: PUSH
92999: LD_INT 0
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: PUSH
93006: LD_INT 1
93008: PUSH
93009: LD_INT 1
93011: PUSH
93012: EMPTY
93013: LIST
93014: LIST
93015: PUSH
93016: LD_INT 0
93018: PUSH
93019: LD_INT 1
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: LD_INT 1
93028: NEG
93029: PUSH
93030: LD_INT 0
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: LD_INT 1
93039: NEG
93040: PUSH
93041: LD_INT 1
93043: NEG
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93058: LD_ADDR_VAR 0 61
93062: PUSH
93063: LD_INT 0
93065: PUSH
93066: LD_INT 0
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: PUSH
93073: LD_INT 0
93075: PUSH
93076: LD_INT 1
93078: NEG
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: LD_INT 1
93086: PUSH
93087: LD_INT 0
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 1
93096: PUSH
93097: LD_INT 1
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: LD_INT 0
93106: PUSH
93107: LD_INT 1
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: LD_INT 1
93116: NEG
93117: PUSH
93118: LD_INT 0
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 1
93127: NEG
93128: PUSH
93129: LD_INT 1
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93146: LD_ADDR_VAR 0 62
93150: PUSH
93151: LD_INT 0
93153: PUSH
93154: LD_INT 0
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 0
93163: PUSH
93164: LD_INT 1
93166: NEG
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: LD_INT 1
93174: PUSH
93175: LD_INT 0
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 1
93184: PUSH
93185: LD_INT 1
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: PUSH
93192: LD_INT 0
93194: PUSH
93195: LD_INT 1
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 1
93204: NEG
93205: PUSH
93206: LD_INT 0
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 1
93215: NEG
93216: PUSH
93217: LD_INT 1
93219: NEG
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93234: LD_ADDR_VAR 0 63
93238: PUSH
93239: LD_INT 0
93241: PUSH
93242: LD_INT 0
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 0
93251: PUSH
93252: LD_INT 1
93254: NEG
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 1
93262: PUSH
93263: LD_INT 0
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 1
93272: PUSH
93273: LD_INT 1
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 0
93282: PUSH
93283: LD_INT 1
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 1
93292: NEG
93293: PUSH
93294: LD_INT 0
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 1
93303: NEG
93304: PUSH
93305: LD_INT 1
93307: NEG
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93322: LD_ADDR_VAR 0 64
93326: PUSH
93327: LD_INT 0
93329: PUSH
93330: LD_INT 0
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 0
93339: PUSH
93340: LD_INT 1
93342: NEG
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 1
93350: PUSH
93351: LD_INT 0
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 1
93360: PUSH
93361: LD_INT 1
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 0
93370: PUSH
93371: LD_INT 1
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 1
93380: NEG
93381: PUSH
93382: LD_INT 0
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: PUSH
93389: LD_INT 1
93391: NEG
93392: PUSH
93393: LD_INT 1
93395: NEG
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: ST_TO_ADDR
// end ; 1 :
93410: GO 99307
93412: LD_INT 1
93414: DOUBLE
93415: EQUAL
93416: IFTRUE 93420
93418: GO 96043
93420: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93421: LD_ADDR_VAR 0 11
93425: PUSH
93426: LD_INT 1
93428: NEG
93429: PUSH
93430: LD_INT 3
93432: NEG
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: PUSH
93438: LD_INT 0
93440: PUSH
93441: LD_INT 3
93443: NEG
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 1
93451: PUSH
93452: LD_INT 2
93454: NEG
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: LIST
93464: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93465: LD_ADDR_VAR 0 12
93469: PUSH
93470: LD_INT 2
93472: PUSH
93473: LD_INT 1
93475: NEG
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 3
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 3
93493: PUSH
93494: LD_INT 1
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: LIST
93505: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93506: LD_ADDR_VAR 0 13
93510: PUSH
93511: LD_INT 3
93513: PUSH
93514: LD_INT 2
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 3
93523: PUSH
93524: LD_INT 3
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 2
93533: PUSH
93534: LD_INT 3
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: LIST
93545: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93546: LD_ADDR_VAR 0 14
93550: PUSH
93551: LD_INT 1
93553: PUSH
93554: LD_INT 3
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: LD_INT 0
93563: PUSH
93564: LD_INT 3
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: LD_INT 1
93573: NEG
93574: PUSH
93575: LD_INT 2
93577: PUSH
93578: EMPTY
93579: LIST
93580: LIST
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: LIST
93586: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93587: LD_ADDR_VAR 0 15
93591: PUSH
93592: LD_INT 2
93594: NEG
93595: PUSH
93596: LD_INT 1
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: PUSH
93603: LD_INT 3
93605: NEG
93606: PUSH
93607: LD_INT 0
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: LD_INT 3
93616: NEG
93617: PUSH
93618: LD_INT 1
93620: NEG
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: LIST
93630: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93631: LD_ADDR_VAR 0 16
93635: PUSH
93636: LD_INT 2
93638: NEG
93639: PUSH
93640: LD_INT 3
93642: NEG
93643: PUSH
93644: EMPTY
93645: LIST
93646: LIST
93647: PUSH
93648: LD_INT 3
93650: NEG
93651: PUSH
93652: LD_INT 2
93654: NEG
93655: PUSH
93656: EMPTY
93657: LIST
93658: LIST
93659: PUSH
93660: LD_INT 3
93662: NEG
93663: PUSH
93664: LD_INT 3
93666: NEG
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: LIST
93676: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93677: LD_ADDR_VAR 0 17
93681: PUSH
93682: LD_INT 1
93684: NEG
93685: PUSH
93686: LD_INT 3
93688: NEG
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 0
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: EMPTY
93702: LIST
93703: LIST
93704: PUSH
93705: LD_INT 1
93707: PUSH
93708: LD_INT 2
93710: NEG
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: LIST
93720: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93721: LD_ADDR_VAR 0 18
93725: PUSH
93726: LD_INT 2
93728: PUSH
93729: LD_INT 1
93731: NEG
93732: PUSH
93733: EMPTY
93734: LIST
93735: LIST
93736: PUSH
93737: LD_INT 3
93739: PUSH
93740: LD_INT 0
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 3
93749: PUSH
93750: LD_INT 1
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: LIST
93761: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93762: LD_ADDR_VAR 0 19
93766: PUSH
93767: LD_INT 3
93769: PUSH
93770: LD_INT 2
93772: PUSH
93773: EMPTY
93774: LIST
93775: LIST
93776: PUSH
93777: LD_INT 3
93779: PUSH
93780: LD_INT 3
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 2
93789: PUSH
93790: LD_INT 3
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: LIST
93801: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93802: LD_ADDR_VAR 0 20
93806: PUSH
93807: LD_INT 1
93809: PUSH
93810: LD_INT 3
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 0
93819: PUSH
93820: LD_INT 3
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 1
93829: NEG
93830: PUSH
93831: LD_INT 2
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: LIST
93842: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93843: LD_ADDR_VAR 0 21
93847: PUSH
93848: LD_INT 2
93850: NEG
93851: PUSH
93852: LD_INT 1
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 3
93861: NEG
93862: PUSH
93863: LD_INT 0
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 3
93872: NEG
93873: PUSH
93874: LD_INT 1
93876: NEG
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: LIST
93886: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93887: LD_ADDR_VAR 0 22
93891: PUSH
93892: LD_INT 2
93894: NEG
93895: PUSH
93896: LD_INT 3
93898: NEG
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 3
93906: NEG
93907: PUSH
93908: LD_INT 2
93910: NEG
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 3
93918: NEG
93919: PUSH
93920: LD_INT 3
93922: NEG
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: LIST
93932: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93933: LD_ADDR_VAR 0 23
93937: PUSH
93938: LD_INT 0
93940: PUSH
93941: LD_INT 3
93943: NEG
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 1
93951: NEG
93952: PUSH
93953: LD_INT 4
93955: NEG
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PUSH
93961: LD_INT 1
93963: PUSH
93964: LD_INT 3
93966: NEG
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: LIST
93976: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
93977: LD_ADDR_VAR 0 24
93981: PUSH
93982: LD_INT 3
93984: PUSH
93985: LD_INT 0
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: LD_INT 3
93994: PUSH
93995: LD_INT 1
93997: NEG
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: LD_INT 4
94005: PUSH
94006: LD_INT 1
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: LIST
94017: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
94018: LD_ADDR_VAR 0 25
94022: PUSH
94023: LD_INT 3
94025: PUSH
94026: LD_INT 3
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 4
94035: PUSH
94036: LD_INT 3
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 3
94045: PUSH
94046: LD_INT 4
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: LIST
94057: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
94058: LD_ADDR_VAR 0 26
94062: PUSH
94063: LD_INT 0
94065: PUSH
94066: LD_INT 3
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 1
94075: PUSH
94076: LD_INT 4
94078: PUSH
94079: EMPTY
94080: LIST
94081: LIST
94082: PUSH
94083: LD_INT 1
94085: NEG
94086: PUSH
94087: LD_INT 3
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: PUSH
94094: EMPTY
94095: LIST
94096: LIST
94097: LIST
94098: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
94099: LD_ADDR_VAR 0 27
94103: PUSH
94104: LD_INT 3
94106: NEG
94107: PUSH
94108: LD_INT 0
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 3
94117: NEG
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 4
94128: NEG
94129: PUSH
94130: LD_INT 1
94132: NEG
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: LIST
94142: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
94143: LD_ADDR_VAR 0 28
94147: PUSH
94148: LD_INT 3
94150: NEG
94151: PUSH
94152: LD_INT 3
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 3
94162: NEG
94163: PUSH
94164: LD_INT 4
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 4
94174: NEG
94175: PUSH
94176: LD_INT 3
94178: NEG
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: LIST
94188: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
94189: LD_ADDR_VAR 0 29
94193: PUSH
94194: LD_INT 1
94196: NEG
94197: PUSH
94198: LD_INT 3
94200: NEG
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: PUSH
94206: LD_INT 0
94208: PUSH
94209: LD_INT 3
94211: NEG
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PUSH
94217: LD_INT 1
94219: PUSH
94220: LD_INT 2
94222: NEG
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 1
94230: NEG
94231: PUSH
94232: LD_INT 4
94234: NEG
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: LD_INT 0
94242: PUSH
94243: LD_INT 4
94245: NEG
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 1
94253: PUSH
94254: LD_INT 3
94256: NEG
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 1
94264: NEG
94265: PUSH
94266: LD_INT 5
94268: NEG
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 0
94276: PUSH
94277: LD_INT 5
94279: NEG
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 1
94287: PUSH
94288: LD_INT 4
94290: NEG
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: PUSH
94296: LD_INT 1
94298: NEG
94299: PUSH
94300: LD_INT 6
94302: NEG
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: LD_INT 0
94310: PUSH
94311: LD_INT 6
94313: NEG
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 1
94321: PUSH
94322: LD_INT 5
94324: NEG
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94344: LD_ADDR_VAR 0 30
94348: PUSH
94349: LD_INT 2
94351: PUSH
94352: LD_INT 1
94354: NEG
94355: PUSH
94356: EMPTY
94357: LIST
94358: LIST
94359: PUSH
94360: LD_INT 3
94362: PUSH
94363: LD_INT 0
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 3
94372: PUSH
94373: LD_INT 1
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 3
94382: PUSH
94383: LD_INT 1
94385: NEG
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 4
94393: PUSH
94394: LD_INT 0
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 4
94403: PUSH
94404: LD_INT 1
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 4
94413: PUSH
94414: LD_INT 1
94416: NEG
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 5
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 5
94434: PUSH
94435: LD_INT 1
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 5
94444: PUSH
94445: LD_INT 1
94447: NEG
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 6
94455: PUSH
94456: LD_INT 0
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 6
94465: PUSH
94466: LD_INT 1
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94487: LD_ADDR_VAR 0 31
94491: PUSH
94492: LD_INT 3
94494: PUSH
94495: LD_INT 2
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PUSH
94502: LD_INT 3
94504: PUSH
94505: LD_INT 3
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 2
94514: PUSH
94515: LD_INT 3
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: LD_INT 4
94524: PUSH
94525: LD_INT 3
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PUSH
94532: LD_INT 4
94534: PUSH
94535: LD_INT 4
94537: PUSH
94538: EMPTY
94539: LIST
94540: LIST
94541: PUSH
94542: LD_INT 3
94544: PUSH
94545: LD_INT 4
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 5
94554: PUSH
94555: LD_INT 4
94557: PUSH
94558: EMPTY
94559: LIST
94560: LIST
94561: PUSH
94562: LD_INT 5
94564: PUSH
94565: LD_INT 5
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 4
94574: PUSH
94575: LD_INT 5
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 6
94584: PUSH
94585: LD_INT 5
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: PUSH
94592: LD_INT 6
94594: PUSH
94595: LD_INT 6
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 5
94604: PUSH
94605: LD_INT 6
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94626: LD_ADDR_VAR 0 32
94630: PUSH
94631: LD_INT 1
94633: PUSH
94634: LD_INT 3
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 0
94643: PUSH
94644: LD_INT 3
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 1
94653: NEG
94654: PUSH
94655: LD_INT 2
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 1
94664: PUSH
94665: LD_INT 4
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 0
94674: PUSH
94675: LD_INT 4
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: PUSH
94682: LD_INT 1
94684: NEG
94685: PUSH
94686: LD_INT 3
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 1
94695: PUSH
94696: LD_INT 5
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: LD_INT 0
94705: PUSH
94706: LD_INT 5
94708: PUSH
94709: EMPTY
94710: LIST
94711: LIST
94712: PUSH
94713: LD_INT 1
94715: NEG
94716: PUSH
94717: LD_INT 4
94719: PUSH
94720: EMPTY
94721: LIST
94722: LIST
94723: PUSH
94724: LD_INT 1
94726: PUSH
94727: LD_INT 6
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 0
94736: PUSH
94737: LD_INT 6
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 1
94746: NEG
94747: PUSH
94748: LD_INT 5
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94769: LD_ADDR_VAR 0 33
94773: PUSH
94774: LD_INT 2
94776: NEG
94777: PUSH
94778: LD_INT 1
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: PUSH
94785: LD_INT 3
94787: NEG
94788: PUSH
94789: LD_INT 0
94791: PUSH
94792: EMPTY
94793: LIST
94794: LIST
94795: PUSH
94796: LD_INT 3
94798: NEG
94799: PUSH
94800: LD_INT 1
94802: NEG
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 3
94810: NEG
94811: PUSH
94812: LD_INT 1
94814: PUSH
94815: EMPTY
94816: LIST
94817: LIST
94818: PUSH
94819: LD_INT 4
94821: NEG
94822: PUSH
94823: LD_INT 0
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 4
94832: NEG
94833: PUSH
94834: LD_INT 1
94836: NEG
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 4
94844: NEG
94845: PUSH
94846: LD_INT 1
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: PUSH
94853: LD_INT 5
94855: NEG
94856: PUSH
94857: LD_INT 0
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 5
94866: NEG
94867: PUSH
94868: LD_INT 1
94870: NEG
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 5
94878: NEG
94879: PUSH
94880: LD_INT 1
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: PUSH
94887: LD_INT 6
94889: NEG
94890: PUSH
94891: LD_INT 0
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PUSH
94898: LD_INT 6
94900: NEG
94901: PUSH
94902: LD_INT 1
94904: NEG
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94924: LD_ADDR_VAR 0 34
94928: PUSH
94929: LD_INT 2
94931: NEG
94932: PUSH
94933: LD_INT 3
94935: NEG
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 3
94943: NEG
94944: PUSH
94945: LD_INT 2
94947: NEG
94948: PUSH
94949: EMPTY
94950: LIST
94951: LIST
94952: PUSH
94953: LD_INT 3
94955: NEG
94956: PUSH
94957: LD_INT 3
94959: NEG
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: PUSH
94965: LD_INT 3
94967: NEG
94968: PUSH
94969: LD_INT 4
94971: NEG
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 4
94979: NEG
94980: PUSH
94981: LD_INT 3
94983: NEG
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: LD_INT 4
94991: NEG
94992: PUSH
94993: LD_INT 4
94995: NEG
94996: PUSH
94997: EMPTY
94998: LIST
94999: LIST
95000: PUSH
95001: LD_INT 4
95003: NEG
95004: PUSH
95005: LD_INT 5
95007: NEG
95008: PUSH
95009: EMPTY
95010: LIST
95011: LIST
95012: PUSH
95013: LD_INT 5
95015: NEG
95016: PUSH
95017: LD_INT 4
95019: NEG
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: PUSH
95025: LD_INT 5
95027: NEG
95028: PUSH
95029: LD_INT 5
95031: NEG
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: PUSH
95037: LD_INT 5
95039: NEG
95040: PUSH
95041: LD_INT 6
95043: NEG
95044: PUSH
95045: EMPTY
95046: LIST
95047: LIST
95048: PUSH
95049: LD_INT 6
95051: NEG
95052: PUSH
95053: LD_INT 5
95055: NEG
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 6
95063: NEG
95064: PUSH
95065: LD_INT 6
95067: NEG
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
95087: LD_ADDR_VAR 0 41
95091: PUSH
95092: LD_INT 0
95094: PUSH
95095: LD_INT 2
95097: NEG
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 1
95105: NEG
95106: PUSH
95107: LD_INT 3
95109: NEG
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 1
95117: PUSH
95118: LD_INT 2
95120: NEG
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: EMPTY
95127: LIST
95128: LIST
95129: LIST
95130: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
95131: LD_ADDR_VAR 0 42
95135: PUSH
95136: LD_INT 2
95138: PUSH
95139: LD_INT 0
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: LD_INT 2
95148: PUSH
95149: LD_INT 1
95151: NEG
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: PUSH
95157: LD_INT 3
95159: PUSH
95160: LD_INT 1
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: LIST
95171: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
95172: LD_ADDR_VAR 0 43
95176: PUSH
95177: LD_INT 2
95179: PUSH
95180: LD_INT 2
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 3
95189: PUSH
95190: LD_INT 2
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: PUSH
95197: LD_INT 2
95199: PUSH
95200: LD_INT 3
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: LIST
95211: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
95212: LD_ADDR_VAR 0 44
95216: PUSH
95217: LD_INT 0
95219: PUSH
95220: LD_INT 2
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 1
95229: PUSH
95230: LD_INT 3
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 1
95239: NEG
95240: PUSH
95241: LD_INT 2
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: LIST
95252: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
95253: LD_ADDR_VAR 0 45
95257: PUSH
95258: LD_INT 2
95260: NEG
95261: PUSH
95262: LD_INT 0
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: PUSH
95269: LD_INT 2
95271: NEG
95272: PUSH
95273: LD_INT 1
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: PUSH
95280: LD_INT 3
95282: NEG
95283: PUSH
95284: LD_INT 1
95286: NEG
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: PUSH
95292: EMPTY
95293: LIST
95294: LIST
95295: LIST
95296: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
95297: LD_ADDR_VAR 0 46
95301: PUSH
95302: LD_INT 2
95304: NEG
95305: PUSH
95306: LD_INT 2
95308: NEG
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 2
95316: NEG
95317: PUSH
95318: LD_INT 3
95320: NEG
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: LD_INT 3
95328: NEG
95329: PUSH
95330: LD_INT 2
95332: NEG
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: EMPTY
95339: LIST
95340: LIST
95341: LIST
95342: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95343: LD_ADDR_VAR 0 47
95347: PUSH
95348: LD_INT 2
95350: NEG
95351: PUSH
95352: LD_INT 3
95354: NEG
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 1
95362: NEG
95363: PUSH
95364: LD_INT 3
95366: NEG
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95376: LD_ADDR_VAR 0 48
95380: PUSH
95381: LD_INT 1
95383: PUSH
95384: LD_INT 2
95386: NEG
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 2
95394: PUSH
95395: LD_INT 1
95397: NEG
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95407: LD_ADDR_VAR 0 49
95411: PUSH
95412: LD_INT 3
95414: PUSH
95415: LD_INT 1
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: PUSH
95422: LD_INT 3
95424: PUSH
95425: LD_INT 2
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: EMPTY
95433: LIST
95434: LIST
95435: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95436: LD_ADDR_VAR 0 50
95440: PUSH
95441: LD_INT 2
95443: PUSH
95444: LD_INT 3
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 1
95453: PUSH
95454: LD_INT 3
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95465: LD_ADDR_VAR 0 51
95469: PUSH
95470: LD_INT 1
95472: NEG
95473: PUSH
95474: LD_INT 2
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 2
95483: NEG
95484: PUSH
95485: LD_INT 1
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95496: LD_ADDR_VAR 0 52
95500: PUSH
95501: LD_INT 3
95503: NEG
95504: PUSH
95505: LD_INT 1
95507: NEG
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: LD_INT 3
95515: NEG
95516: PUSH
95517: LD_INT 2
95519: NEG
95520: PUSH
95521: EMPTY
95522: LIST
95523: LIST
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95529: LD_ADDR_VAR 0 53
95533: PUSH
95534: LD_INT 1
95536: NEG
95537: PUSH
95538: LD_INT 3
95540: NEG
95541: PUSH
95542: EMPTY
95543: LIST
95544: LIST
95545: PUSH
95546: LD_INT 0
95548: PUSH
95549: LD_INT 3
95551: NEG
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 1
95559: PUSH
95560: LD_INT 2
95562: NEG
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: LIST
95572: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95573: LD_ADDR_VAR 0 54
95577: PUSH
95578: LD_INT 2
95580: PUSH
95581: LD_INT 1
95583: NEG
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: PUSH
95589: LD_INT 3
95591: PUSH
95592: LD_INT 0
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: PUSH
95599: LD_INT 3
95601: PUSH
95602: LD_INT 1
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: LIST
95613: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95614: LD_ADDR_VAR 0 55
95618: PUSH
95619: LD_INT 3
95621: PUSH
95622: LD_INT 2
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 3
95631: PUSH
95632: LD_INT 3
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 2
95641: PUSH
95642: LD_INT 3
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: LIST
95653: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95654: LD_ADDR_VAR 0 56
95658: PUSH
95659: LD_INT 1
95661: PUSH
95662: LD_INT 3
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: LD_INT 0
95671: PUSH
95672: LD_INT 3
95674: PUSH
95675: EMPTY
95676: LIST
95677: LIST
95678: PUSH
95679: LD_INT 1
95681: NEG
95682: PUSH
95683: LD_INT 2
95685: PUSH
95686: EMPTY
95687: LIST
95688: LIST
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: LIST
95694: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95695: LD_ADDR_VAR 0 57
95699: PUSH
95700: LD_INT 2
95702: NEG
95703: PUSH
95704: LD_INT 1
95706: PUSH
95707: EMPTY
95708: LIST
95709: LIST
95710: PUSH
95711: LD_INT 3
95713: NEG
95714: PUSH
95715: LD_INT 0
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 3
95724: NEG
95725: PUSH
95726: LD_INT 1
95728: NEG
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: LIST
95738: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95739: LD_ADDR_VAR 0 58
95743: PUSH
95744: LD_INT 2
95746: NEG
95747: PUSH
95748: LD_INT 3
95750: NEG
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: PUSH
95756: LD_INT 3
95758: NEG
95759: PUSH
95760: LD_INT 2
95762: NEG
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: LD_INT 3
95770: NEG
95771: PUSH
95772: LD_INT 3
95774: NEG
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: LIST
95784: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95785: LD_ADDR_VAR 0 59
95789: PUSH
95790: LD_INT 1
95792: NEG
95793: PUSH
95794: LD_INT 2
95796: NEG
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 0
95804: PUSH
95805: LD_INT 2
95807: NEG
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: LD_INT 1
95815: PUSH
95816: LD_INT 1
95818: NEG
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: PUSH
95824: EMPTY
95825: LIST
95826: LIST
95827: LIST
95828: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95829: LD_ADDR_VAR 0 60
95833: PUSH
95834: LD_INT 1
95836: PUSH
95837: LD_INT 1
95839: NEG
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: PUSH
95845: LD_INT 2
95847: PUSH
95848: LD_INT 0
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: PUSH
95855: LD_INT 2
95857: PUSH
95858: LD_INT 1
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: LIST
95869: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95870: LD_ADDR_VAR 0 61
95874: PUSH
95875: LD_INT 2
95877: PUSH
95878: LD_INT 1
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: PUSH
95885: LD_INT 2
95887: PUSH
95888: LD_INT 2
95890: PUSH
95891: EMPTY
95892: LIST
95893: LIST
95894: PUSH
95895: LD_INT 1
95897: PUSH
95898: LD_INT 2
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: LIST
95909: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95910: LD_ADDR_VAR 0 62
95914: PUSH
95915: LD_INT 1
95917: PUSH
95918: LD_INT 2
95920: PUSH
95921: EMPTY
95922: LIST
95923: LIST
95924: PUSH
95925: LD_INT 0
95927: PUSH
95928: LD_INT 2
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: PUSH
95935: LD_INT 1
95937: NEG
95938: PUSH
95939: LD_INT 1
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: PUSH
95946: EMPTY
95947: LIST
95948: LIST
95949: LIST
95950: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95951: LD_ADDR_VAR 0 63
95955: PUSH
95956: LD_INT 1
95958: NEG
95959: PUSH
95960: LD_INT 1
95962: PUSH
95963: EMPTY
95964: LIST
95965: LIST
95966: PUSH
95967: LD_INT 2
95969: NEG
95970: PUSH
95971: LD_INT 0
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 2
95980: NEG
95981: PUSH
95982: LD_INT 1
95984: NEG
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: LIST
95994: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95995: LD_ADDR_VAR 0 64
95999: PUSH
96000: LD_INT 1
96002: NEG
96003: PUSH
96004: LD_INT 2
96006: NEG
96007: PUSH
96008: EMPTY
96009: LIST
96010: LIST
96011: PUSH
96012: LD_INT 2
96014: NEG
96015: PUSH
96016: LD_INT 1
96018: NEG
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: PUSH
96024: LD_INT 2
96026: NEG
96027: PUSH
96028: LD_INT 2
96030: NEG
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: LIST
96040: ST_TO_ADDR
// end ; 2 :
96041: GO 99307
96043: LD_INT 2
96045: DOUBLE
96046: EQUAL
96047: IFTRUE 96051
96049: GO 99306
96051: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
96052: LD_ADDR_VAR 0 29
96056: PUSH
96057: LD_INT 4
96059: PUSH
96060: LD_INT 0
96062: PUSH
96063: EMPTY
96064: LIST
96065: LIST
96066: PUSH
96067: LD_INT 4
96069: PUSH
96070: LD_INT 1
96072: NEG
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: PUSH
96078: LD_INT 5
96080: PUSH
96081: LD_INT 0
96083: PUSH
96084: EMPTY
96085: LIST
96086: LIST
96087: PUSH
96088: LD_INT 5
96090: PUSH
96091: LD_INT 1
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 4
96100: PUSH
96101: LD_INT 1
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: PUSH
96108: LD_INT 3
96110: PUSH
96111: LD_INT 0
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 3
96120: PUSH
96121: LD_INT 1
96123: NEG
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 3
96131: PUSH
96132: LD_INT 2
96134: NEG
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 5
96142: PUSH
96143: LD_INT 2
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 3
96152: PUSH
96153: LD_INT 3
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 3
96162: PUSH
96163: LD_INT 2
96165: PUSH
96166: EMPTY
96167: LIST
96168: LIST
96169: PUSH
96170: LD_INT 4
96172: PUSH
96173: LD_INT 3
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 4
96182: PUSH
96183: LD_INT 4
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: PUSH
96190: LD_INT 3
96192: PUSH
96193: LD_INT 4
96195: PUSH
96196: EMPTY
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 2
96202: PUSH
96203: LD_INT 3
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 2
96212: PUSH
96213: LD_INT 2
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: PUSH
96220: LD_INT 4
96222: PUSH
96223: LD_INT 2
96225: PUSH
96226: EMPTY
96227: LIST
96228: LIST
96229: PUSH
96230: LD_INT 2
96232: PUSH
96233: LD_INT 4
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: PUSH
96240: LD_INT 0
96242: PUSH
96243: LD_INT 4
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: PUSH
96250: LD_INT 0
96252: PUSH
96253: LD_INT 3
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: LD_INT 1
96262: PUSH
96263: LD_INT 4
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 1
96272: PUSH
96273: LD_INT 5
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 0
96282: PUSH
96283: LD_INT 5
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PUSH
96290: LD_INT 1
96292: NEG
96293: PUSH
96294: LD_INT 4
96296: PUSH
96297: EMPTY
96298: LIST
96299: LIST
96300: PUSH
96301: LD_INT 1
96303: NEG
96304: PUSH
96305: LD_INT 3
96307: PUSH
96308: EMPTY
96309: LIST
96310: LIST
96311: PUSH
96312: LD_INT 2
96314: PUSH
96315: LD_INT 5
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: PUSH
96322: LD_INT 2
96324: NEG
96325: PUSH
96326: LD_INT 3
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 3
96335: NEG
96336: PUSH
96337: LD_INT 0
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 3
96346: NEG
96347: PUSH
96348: LD_INT 1
96350: NEG
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 2
96358: NEG
96359: PUSH
96360: LD_INT 0
96362: PUSH
96363: EMPTY
96364: LIST
96365: LIST
96366: PUSH
96367: LD_INT 2
96369: NEG
96370: PUSH
96371: LD_INT 1
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: PUSH
96378: LD_INT 3
96380: NEG
96381: PUSH
96382: LD_INT 1
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: PUSH
96389: LD_INT 4
96391: NEG
96392: PUSH
96393: LD_INT 0
96395: PUSH
96396: EMPTY
96397: LIST
96398: LIST
96399: PUSH
96400: LD_INT 4
96402: NEG
96403: PUSH
96404: LD_INT 1
96406: NEG
96407: PUSH
96408: EMPTY
96409: LIST
96410: LIST
96411: PUSH
96412: LD_INT 4
96414: NEG
96415: PUSH
96416: LD_INT 2
96418: NEG
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 2
96426: NEG
96427: PUSH
96428: LD_INT 2
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: LD_INT 4
96437: NEG
96438: PUSH
96439: LD_INT 4
96441: NEG
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 4
96449: NEG
96450: PUSH
96451: LD_INT 5
96453: NEG
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 3
96461: NEG
96462: PUSH
96463: LD_INT 4
96465: NEG
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: LD_INT 3
96477: NEG
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 4
96485: NEG
96486: PUSH
96487: LD_INT 3
96489: NEG
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: PUSH
96495: LD_INT 5
96497: NEG
96498: PUSH
96499: LD_INT 4
96501: NEG
96502: PUSH
96503: EMPTY
96504: LIST
96505: LIST
96506: PUSH
96507: LD_INT 5
96509: NEG
96510: PUSH
96511: LD_INT 5
96513: NEG
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 3
96521: NEG
96522: PUSH
96523: LD_INT 5
96525: NEG
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 5
96533: NEG
96534: PUSH
96535: LD_INT 3
96537: NEG
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96590: LD_ADDR_VAR 0 30
96594: PUSH
96595: LD_INT 4
96597: PUSH
96598: LD_INT 4
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PUSH
96605: LD_INT 4
96607: PUSH
96608: LD_INT 3
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: PUSH
96615: LD_INT 5
96617: PUSH
96618: LD_INT 4
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 5
96627: PUSH
96628: LD_INT 5
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: LD_INT 4
96637: PUSH
96638: LD_INT 5
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 3
96647: PUSH
96648: LD_INT 4
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 3
96657: PUSH
96658: LD_INT 3
96660: PUSH
96661: EMPTY
96662: LIST
96663: LIST
96664: PUSH
96665: LD_INT 5
96667: PUSH
96668: LD_INT 3
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: PUSH
96675: LD_INT 3
96677: PUSH
96678: LD_INT 5
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: PUSH
96685: LD_INT 0
96687: PUSH
96688: LD_INT 3
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: LD_INT 0
96697: PUSH
96698: LD_INT 2
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 1
96707: PUSH
96708: LD_INT 3
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 1
96717: PUSH
96718: LD_INT 4
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 0
96727: PUSH
96728: LD_INT 4
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 1
96737: NEG
96738: PUSH
96739: LD_INT 3
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 1
96748: NEG
96749: PUSH
96750: LD_INT 2
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: PUSH
96757: LD_INT 2
96759: PUSH
96760: LD_INT 4
96762: PUSH
96763: EMPTY
96764: LIST
96765: LIST
96766: PUSH
96767: LD_INT 2
96769: NEG
96770: PUSH
96771: LD_INT 2
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: LD_INT 4
96780: NEG
96781: PUSH
96782: LD_INT 0
96784: PUSH
96785: EMPTY
96786: LIST
96787: LIST
96788: PUSH
96789: LD_INT 4
96791: NEG
96792: PUSH
96793: LD_INT 1
96795: NEG
96796: PUSH
96797: EMPTY
96798: LIST
96799: LIST
96800: PUSH
96801: LD_INT 3
96803: NEG
96804: PUSH
96805: LD_INT 0
96807: PUSH
96808: EMPTY
96809: LIST
96810: LIST
96811: PUSH
96812: LD_INT 3
96814: NEG
96815: PUSH
96816: LD_INT 1
96818: PUSH
96819: EMPTY
96820: LIST
96821: LIST
96822: PUSH
96823: LD_INT 4
96825: NEG
96826: PUSH
96827: LD_INT 1
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: PUSH
96834: LD_INT 5
96836: NEG
96837: PUSH
96838: LD_INT 0
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: PUSH
96845: LD_INT 5
96847: NEG
96848: PUSH
96849: LD_INT 1
96851: NEG
96852: PUSH
96853: EMPTY
96854: LIST
96855: LIST
96856: PUSH
96857: LD_INT 5
96859: NEG
96860: PUSH
96861: LD_INT 2
96863: NEG
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PUSH
96869: LD_INT 3
96871: NEG
96872: PUSH
96873: LD_INT 2
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: PUSH
96880: LD_INT 3
96882: NEG
96883: PUSH
96884: LD_INT 3
96886: NEG
96887: PUSH
96888: EMPTY
96889: LIST
96890: LIST
96891: PUSH
96892: LD_INT 3
96894: NEG
96895: PUSH
96896: LD_INT 4
96898: NEG
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: PUSH
96904: LD_INT 2
96906: NEG
96907: PUSH
96908: LD_INT 3
96910: NEG
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: PUSH
96916: LD_INT 2
96918: NEG
96919: PUSH
96920: LD_INT 2
96922: NEG
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 3
96930: NEG
96931: PUSH
96932: LD_INT 2
96934: NEG
96935: PUSH
96936: EMPTY
96937: LIST
96938: LIST
96939: PUSH
96940: LD_INT 4
96942: NEG
96943: PUSH
96944: LD_INT 3
96946: NEG
96947: PUSH
96948: EMPTY
96949: LIST
96950: LIST
96951: PUSH
96952: LD_INT 4
96954: NEG
96955: PUSH
96956: LD_INT 4
96958: NEG
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: PUSH
96964: LD_INT 2
96966: NEG
96967: PUSH
96968: LD_INT 4
96970: NEG
96971: PUSH
96972: EMPTY
96973: LIST
96974: LIST
96975: PUSH
96976: LD_INT 4
96978: NEG
96979: PUSH
96980: LD_INT 2
96982: NEG
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: PUSH
96988: LD_INT 0
96990: PUSH
96991: LD_INT 4
96993: NEG
96994: PUSH
96995: EMPTY
96996: LIST
96997: LIST
96998: PUSH
96999: LD_INT 0
97001: PUSH
97002: LD_INT 5
97004: NEG
97005: PUSH
97006: EMPTY
97007: LIST
97008: LIST
97009: PUSH
97010: LD_INT 1
97012: PUSH
97013: LD_INT 4
97015: NEG
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: PUSH
97021: LD_INT 1
97023: PUSH
97024: LD_INT 3
97026: NEG
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: PUSH
97032: LD_INT 0
97034: PUSH
97035: LD_INT 3
97037: NEG
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: LD_INT 1
97045: NEG
97046: PUSH
97047: LD_INT 4
97049: NEG
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: PUSH
97055: LD_INT 1
97057: NEG
97058: PUSH
97059: LD_INT 5
97061: NEG
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: PUSH
97067: LD_INT 2
97069: PUSH
97070: LD_INT 3
97072: NEG
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 2
97080: NEG
97081: PUSH
97082: LD_INT 5
97084: NEG
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
97137: LD_ADDR_VAR 0 31
97141: PUSH
97142: LD_INT 0
97144: PUSH
97145: LD_INT 4
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: PUSH
97152: LD_INT 0
97154: PUSH
97155: LD_INT 3
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PUSH
97162: LD_INT 1
97164: PUSH
97165: LD_INT 4
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PUSH
97172: LD_INT 1
97174: PUSH
97175: LD_INT 5
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: LD_INT 0
97184: PUSH
97185: LD_INT 5
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: PUSH
97192: LD_INT 1
97194: NEG
97195: PUSH
97196: LD_INT 4
97198: PUSH
97199: EMPTY
97200: LIST
97201: LIST
97202: PUSH
97203: LD_INT 1
97205: NEG
97206: PUSH
97207: LD_INT 3
97209: PUSH
97210: EMPTY
97211: LIST
97212: LIST
97213: PUSH
97214: LD_INT 2
97216: PUSH
97217: LD_INT 5
97219: PUSH
97220: EMPTY
97221: LIST
97222: LIST
97223: PUSH
97224: LD_INT 2
97226: NEG
97227: PUSH
97228: LD_INT 3
97230: PUSH
97231: EMPTY
97232: LIST
97233: LIST
97234: PUSH
97235: LD_INT 3
97237: NEG
97238: PUSH
97239: LD_INT 0
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 3
97248: NEG
97249: PUSH
97250: LD_INT 1
97252: NEG
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: LD_INT 2
97260: NEG
97261: PUSH
97262: LD_INT 0
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: PUSH
97269: LD_INT 2
97271: NEG
97272: PUSH
97273: LD_INT 1
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: PUSH
97280: LD_INT 3
97282: NEG
97283: PUSH
97284: LD_INT 1
97286: PUSH
97287: EMPTY
97288: LIST
97289: LIST
97290: PUSH
97291: LD_INT 4
97293: NEG
97294: PUSH
97295: LD_INT 0
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PUSH
97302: LD_INT 4
97304: NEG
97305: PUSH
97306: LD_INT 1
97308: NEG
97309: PUSH
97310: EMPTY
97311: LIST
97312: LIST
97313: PUSH
97314: LD_INT 4
97316: NEG
97317: PUSH
97318: LD_INT 2
97320: NEG
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: PUSH
97326: LD_INT 2
97328: NEG
97329: PUSH
97330: LD_INT 2
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: LD_INT 4
97339: NEG
97340: PUSH
97341: LD_INT 4
97343: NEG
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: PUSH
97349: LD_INT 4
97351: NEG
97352: PUSH
97353: LD_INT 5
97355: NEG
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: PUSH
97361: LD_INT 3
97363: NEG
97364: PUSH
97365: LD_INT 4
97367: NEG
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PUSH
97373: LD_INT 3
97375: NEG
97376: PUSH
97377: LD_INT 3
97379: NEG
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 4
97387: NEG
97388: PUSH
97389: LD_INT 3
97391: NEG
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PUSH
97397: LD_INT 5
97399: NEG
97400: PUSH
97401: LD_INT 4
97403: NEG
97404: PUSH
97405: EMPTY
97406: LIST
97407: LIST
97408: PUSH
97409: LD_INT 5
97411: NEG
97412: PUSH
97413: LD_INT 5
97415: NEG
97416: PUSH
97417: EMPTY
97418: LIST
97419: LIST
97420: PUSH
97421: LD_INT 3
97423: NEG
97424: PUSH
97425: LD_INT 5
97427: NEG
97428: PUSH
97429: EMPTY
97430: LIST
97431: LIST
97432: PUSH
97433: LD_INT 5
97435: NEG
97436: PUSH
97437: LD_INT 3
97439: NEG
97440: PUSH
97441: EMPTY
97442: LIST
97443: LIST
97444: PUSH
97445: LD_INT 0
97447: PUSH
97448: LD_INT 3
97450: NEG
97451: PUSH
97452: EMPTY
97453: LIST
97454: LIST
97455: PUSH
97456: LD_INT 0
97458: PUSH
97459: LD_INT 4
97461: NEG
97462: PUSH
97463: EMPTY
97464: LIST
97465: LIST
97466: PUSH
97467: LD_INT 1
97469: PUSH
97470: LD_INT 3
97472: NEG
97473: PUSH
97474: EMPTY
97475: LIST
97476: LIST
97477: PUSH
97478: LD_INT 1
97480: PUSH
97481: LD_INT 2
97483: NEG
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: PUSH
97489: LD_INT 0
97491: PUSH
97492: LD_INT 2
97494: NEG
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: LD_INT 1
97502: NEG
97503: PUSH
97504: LD_INT 3
97506: NEG
97507: PUSH
97508: EMPTY
97509: LIST
97510: LIST
97511: PUSH
97512: LD_INT 1
97514: NEG
97515: PUSH
97516: LD_INT 4
97518: NEG
97519: PUSH
97520: EMPTY
97521: LIST
97522: LIST
97523: PUSH
97524: LD_INT 2
97526: PUSH
97527: LD_INT 2
97529: NEG
97530: PUSH
97531: EMPTY
97532: LIST
97533: LIST
97534: PUSH
97535: LD_INT 2
97537: NEG
97538: PUSH
97539: LD_INT 4
97541: NEG
97542: PUSH
97543: EMPTY
97544: LIST
97545: LIST
97546: PUSH
97547: LD_INT 4
97549: PUSH
97550: LD_INT 0
97552: PUSH
97553: EMPTY
97554: LIST
97555: LIST
97556: PUSH
97557: LD_INT 4
97559: PUSH
97560: LD_INT 1
97562: NEG
97563: PUSH
97564: EMPTY
97565: LIST
97566: LIST
97567: PUSH
97568: LD_INT 5
97570: PUSH
97571: LD_INT 0
97573: PUSH
97574: EMPTY
97575: LIST
97576: LIST
97577: PUSH
97578: LD_INT 5
97580: PUSH
97581: LD_INT 1
97583: PUSH
97584: EMPTY
97585: LIST
97586: LIST
97587: PUSH
97588: LD_INT 4
97590: PUSH
97591: LD_INT 1
97593: PUSH
97594: EMPTY
97595: LIST
97596: LIST
97597: PUSH
97598: LD_INT 3
97600: PUSH
97601: LD_INT 0
97603: PUSH
97604: EMPTY
97605: LIST
97606: LIST
97607: PUSH
97608: LD_INT 3
97610: PUSH
97611: LD_INT 1
97613: NEG
97614: PUSH
97615: EMPTY
97616: LIST
97617: LIST
97618: PUSH
97619: LD_INT 3
97621: PUSH
97622: LD_INT 2
97624: NEG
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: LD_INT 5
97632: PUSH
97633: LD_INT 2
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97687: LD_ADDR_VAR 0 32
97691: PUSH
97692: LD_INT 4
97694: NEG
97695: PUSH
97696: LD_INT 0
97698: PUSH
97699: EMPTY
97700: LIST
97701: LIST
97702: PUSH
97703: LD_INT 4
97705: NEG
97706: PUSH
97707: LD_INT 1
97709: NEG
97710: PUSH
97711: EMPTY
97712: LIST
97713: LIST
97714: PUSH
97715: LD_INT 3
97717: NEG
97718: PUSH
97719: LD_INT 0
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 3
97728: NEG
97729: PUSH
97730: LD_INT 1
97732: PUSH
97733: EMPTY
97734: LIST
97735: LIST
97736: PUSH
97737: LD_INT 4
97739: NEG
97740: PUSH
97741: LD_INT 1
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PUSH
97748: LD_INT 5
97750: NEG
97751: PUSH
97752: LD_INT 0
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PUSH
97759: LD_INT 5
97761: NEG
97762: PUSH
97763: LD_INT 1
97765: NEG
97766: PUSH
97767: EMPTY
97768: LIST
97769: LIST
97770: PUSH
97771: LD_INT 5
97773: NEG
97774: PUSH
97775: LD_INT 2
97777: NEG
97778: PUSH
97779: EMPTY
97780: LIST
97781: LIST
97782: PUSH
97783: LD_INT 3
97785: NEG
97786: PUSH
97787: LD_INT 2
97789: PUSH
97790: EMPTY
97791: LIST
97792: LIST
97793: PUSH
97794: LD_INT 3
97796: NEG
97797: PUSH
97798: LD_INT 3
97800: NEG
97801: PUSH
97802: EMPTY
97803: LIST
97804: LIST
97805: PUSH
97806: LD_INT 3
97808: NEG
97809: PUSH
97810: LD_INT 4
97812: NEG
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 2
97820: NEG
97821: PUSH
97822: LD_INT 3
97824: NEG
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: LD_INT 2
97832: NEG
97833: PUSH
97834: LD_INT 2
97836: NEG
97837: PUSH
97838: EMPTY
97839: LIST
97840: LIST
97841: PUSH
97842: LD_INT 3
97844: NEG
97845: PUSH
97846: LD_INT 2
97848: NEG
97849: PUSH
97850: EMPTY
97851: LIST
97852: LIST
97853: PUSH
97854: LD_INT 4
97856: NEG
97857: PUSH
97858: LD_INT 3
97860: NEG
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: PUSH
97866: LD_INT 4
97868: NEG
97869: PUSH
97870: LD_INT 4
97872: NEG
97873: PUSH
97874: EMPTY
97875: LIST
97876: LIST
97877: PUSH
97878: LD_INT 2
97880: NEG
97881: PUSH
97882: LD_INT 4
97884: NEG
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: PUSH
97890: LD_INT 4
97892: NEG
97893: PUSH
97894: LD_INT 2
97896: NEG
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PUSH
97902: LD_INT 0
97904: PUSH
97905: LD_INT 4
97907: NEG
97908: PUSH
97909: EMPTY
97910: LIST
97911: LIST
97912: PUSH
97913: LD_INT 0
97915: PUSH
97916: LD_INT 5
97918: NEG
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PUSH
97924: LD_INT 1
97926: PUSH
97927: LD_INT 4
97929: NEG
97930: PUSH
97931: EMPTY
97932: LIST
97933: LIST
97934: PUSH
97935: LD_INT 1
97937: PUSH
97938: LD_INT 3
97940: NEG
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: PUSH
97946: LD_INT 0
97948: PUSH
97949: LD_INT 3
97951: NEG
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: LD_INT 1
97959: NEG
97960: PUSH
97961: LD_INT 4
97963: NEG
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: PUSH
97969: LD_INT 1
97971: NEG
97972: PUSH
97973: LD_INT 5
97975: NEG
97976: PUSH
97977: EMPTY
97978: LIST
97979: LIST
97980: PUSH
97981: LD_INT 2
97983: PUSH
97984: LD_INT 3
97986: NEG
97987: PUSH
97988: EMPTY
97989: LIST
97990: LIST
97991: PUSH
97992: LD_INT 2
97994: NEG
97995: PUSH
97996: LD_INT 5
97998: NEG
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PUSH
98004: LD_INT 3
98006: PUSH
98007: LD_INT 0
98009: PUSH
98010: EMPTY
98011: LIST
98012: LIST
98013: PUSH
98014: LD_INT 3
98016: PUSH
98017: LD_INT 1
98019: NEG
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: PUSH
98025: LD_INT 4
98027: PUSH
98028: LD_INT 0
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: PUSH
98035: LD_INT 4
98037: PUSH
98038: LD_INT 1
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: PUSH
98045: LD_INT 3
98047: PUSH
98048: LD_INT 1
98050: PUSH
98051: EMPTY
98052: LIST
98053: LIST
98054: PUSH
98055: LD_INT 2
98057: PUSH
98058: LD_INT 0
98060: PUSH
98061: EMPTY
98062: LIST
98063: LIST
98064: PUSH
98065: LD_INT 2
98067: PUSH
98068: LD_INT 1
98070: NEG
98071: PUSH
98072: EMPTY
98073: LIST
98074: LIST
98075: PUSH
98076: LD_INT 2
98078: PUSH
98079: LD_INT 2
98081: NEG
98082: PUSH
98083: EMPTY
98084: LIST
98085: LIST
98086: PUSH
98087: LD_INT 4
98089: PUSH
98090: LD_INT 2
98092: PUSH
98093: EMPTY
98094: LIST
98095: LIST
98096: PUSH
98097: LD_INT 4
98099: PUSH
98100: LD_INT 4
98102: PUSH
98103: EMPTY
98104: LIST
98105: LIST
98106: PUSH
98107: LD_INT 4
98109: PUSH
98110: LD_INT 3
98112: PUSH
98113: EMPTY
98114: LIST
98115: LIST
98116: PUSH
98117: LD_INT 5
98119: PUSH
98120: LD_INT 4
98122: PUSH
98123: EMPTY
98124: LIST
98125: LIST
98126: PUSH
98127: LD_INT 5
98129: PUSH
98130: LD_INT 5
98132: PUSH
98133: EMPTY
98134: LIST
98135: LIST
98136: PUSH
98137: LD_INT 4
98139: PUSH
98140: LD_INT 5
98142: PUSH
98143: EMPTY
98144: LIST
98145: LIST
98146: PUSH
98147: LD_INT 3
98149: PUSH
98150: LD_INT 4
98152: PUSH
98153: EMPTY
98154: LIST
98155: LIST
98156: PUSH
98157: LD_INT 3
98159: PUSH
98160: LD_INT 3
98162: PUSH
98163: EMPTY
98164: LIST
98165: LIST
98166: PUSH
98167: LD_INT 5
98169: PUSH
98170: LD_INT 3
98172: PUSH
98173: EMPTY
98174: LIST
98175: LIST
98176: PUSH
98177: LD_INT 3
98179: PUSH
98180: LD_INT 5
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: PUSH
98187: EMPTY
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: LIST
98223: LIST
98224: LIST
98225: LIST
98226: LIST
98227: LIST
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
98234: LD_ADDR_VAR 0 33
98238: PUSH
98239: LD_INT 4
98241: NEG
98242: PUSH
98243: LD_INT 4
98245: NEG
98246: PUSH
98247: EMPTY
98248: LIST
98249: LIST
98250: PUSH
98251: LD_INT 4
98253: NEG
98254: PUSH
98255: LD_INT 5
98257: NEG
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: PUSH
98263: LD_INT 3
98265: NEG
98266: PUSH
98267: LD_INT 4
98269: NEG
98270: PUSH
98271: EMPTY
98272: LIST
98273: LIST
98274: PUSH
98275: LD_INT 3
98277: NEG
98278: PUSH
98279: LD_INT 3
98281: NEG
98282: PUSH
98283: EMPTY
98284: LIST
98285: LIST
98286: PUSH
98287: LD_INT 4
98289: NEG
98290: PUSH
98291: LD_INT 3
98293: NEG
98294: PUSH
98295: EMPTY
98296: LIST
98297: LIST
98298: PUSH
98299: LD_INT 5
98301: NEG
98302: PUSH
98303: LD_INT 4
98305: NEG
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: PUSH
98311: LD_INT 5
98313: NEG
98314: PUSH
98315: LD_INT 5
98317: NEG
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: PUSH
98323: LD_INT 3
98325: NEG
98326: PUSH
98327: LD_INT 5
98329: NEG
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PUSH
98335: LD_INT 5
98337: NEG
98338: PUSH
98339: LD_INT 3
98341: NEG
98342: PUSH
98343: EMPTY
98344: LIST
98345: LIST
98346: PUSH
98347: LD_INT 0
98349: PUSH
98350: LD_INT 3
98352: NEG
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: PUSH
98358: LD_INT 0
98360: PUSH
98361: LD_INT 4
98363: NEG
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PUSH
98369: LD_INT 1
98371: PUSH
98372: LD_INT 3
98374: NEG
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 1
98382: PUSH
98383: LD_INT 2
98385: NEG
98386: PUSH
98387: EMPTY
98388: LIST
98389: LIST
98390: PUSH
98391: LD_INT 0
98393: PUSH
98394: LD_INT 2
98396: NEG
98397: PUSH
98398: EMPTY
98399: LIST
98400: LIST
98401: PUSH
98402: LD_INT 1
98404: NEG
98405: PUSH
98406: LD_INT 3
98408: NEG
98409: PUSH
98410: EMPTY
98411: LIST
98412: LIST
98413: PUSH
98414: LD_INT 1
98416: NEG
98417: PUSH
98418: LD_INT 4
98420: NEG
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: PUSH
98426: LD_INT 2
98428: PUSH
98429: LD_INT 2
98431: NEG
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: PUSH
98437: LD_INT 2
98439: NEG
98440: PUSH
98441: LD_INT 4
98443: NEG
98444: PUSH
98445: EMPTY
98446: LIST
98447: LIST
98448: PUSH
98449: LD_INT 4
98451: PUSH
98452: LD_INT 0
98454: PUSH
98455: EMPTY
98456: LIST
98457: LIST
98458: PUSH
98459: LD_INT 4
98461: PUSH
98462: LD_INT 1
98464: NEG
98465: PUSH
98466: EMPTY
98467: LIST
98468: LIST
98469: PUSH
98470: LD_INT 5
98472: PUSH
98473: LD_INT 0
98475: PUSH
98476: EMPTY
98477: LIST
98478: LIST
98479: PUSH
98480: LD_INT 5
98482: PUSH
98483: LD_INT 1
98485: PUSH
98486: EMPTY
98487: LIST
98488: LIST
98489: PUSH
98490: LD_INT 4
98492: PUSH
98493: LD_INT 1
98495: PUSH
98496: EMPTY
98497: LIST
98498: LIST
98499: PUSH
98500: LD_INT 3
98502: PUSH
98503: LD_INT 0
98505: PUSH
98506: EMPTY
98507: LIST
98508: LIST
98509: PUSH
98510: LD_INT 3
98512: PUSH
98513: LD_INT 1
98515: NEG
98516: PUSH
98517: EMPTY
98518: LIST
98519: LIST
98520: PUSH
98521: LD_INT 3
98523: PUSH
98524: LD_INT 2
98526: NEG
98527: PUSH
98528: EMPTY
98529: LIST
98530: LIST
98531: PUSH
98532: LD_INT 5
98534: PUSH
98535: LD_INT 2
98537: PUSH
98538: EMPTY
98539: LIST
98540: LIST
98541: PUSH
98542: LD_INT 3
98544: PUSH
98545: LD_INT 3
98547: PUSH
98548: EMPTY
98549: LIST
98550: LIST
98551: PUSH
98552: LD_INT 3
98554: PUSH
98555: LD_INT 2
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: PUSH
98562: LD_INT 4
98564: PUSH
98565: LD_INT 3
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: PUSH
98572: LD_INT 4
98574: PUSH
98575: LD_INT 4
98577: PUSH
98578: EMPTY
98579: LIST
98580: LIST
98581: PUSH
98582: LD_INT 3
98584: PUSH
98585: LD_INT 4
98587: PUSH
98588: EMPTY
98589: LIST
98590: LIST
98591: PUSH
98592: LD_INT 2
98594: PUSH
98595: LD_INT 3
98597: PUSH
98598: EMPTY
98599: LIST
98600: LIST
98601: PUSH
98602: LD_INT 2
98604: PUSH
98605: LD_INT 2
98607: PUSH
98608: EMPTY
98609: LIST
98610: LIST
98611: PUSH
98612: LD_INT 4
98614: PUSH
98615: LD_INT 2
98617: PUSH
98618: EMPTY
98619: LIST
98620: LIST
98621: PUSH
98622: LD_INT 2
98624: PUSH
98625: LD_INT 4
98627: PUSH
98628: EMPTY
98629: LIST
98630: LIST
98631: PUSH
98632: LD_INT 0
98634: PUSH
98635: LD_INT 4
98637: PUSH
98638: EMPTY
98639: LIST
98640: LIST
98641: PUSH
98642: LD_INT 0
98644: PUSH
98645: LD_INT 3
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: PUSH
98652: LD_INT 1
98654: PUSH
98655: LD_INT 4
98657: PUSH
98658: EMPTY
98659: LIST
98660: LIST
98661: PUSH
98662: LD_INT 1
98664: PUSH
98665: LD_INT 5
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: PUSH
98672: LD_INT 0
98674: PUSH
98675: LD_INT 5
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: PUSH
98682: LD_INT 1
98684: NEG
98685: PUSH
98686: LD_INT 4
98688: PUSH
98689: EMPTY
98690: LIST
98691: LIST
98692: PUSH
98693: LD_INT 1
98695: NEG
98696: PUSH
98697: LD_INT 3
98699: PUSH
98700: EMPTY
98701: LIST
98702: LIST
98703: PUSH
98704: LD_INT 2
98706: PUSH
98707: LD_INT 5
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: PUSH
98714: LD_INT 2
98716: NEG
98717: PUSH
98718: LD_INT 3
98720: PUSH
98721: EMPTY
98722: LIST
98723: LIST
98724: PUSH
98725: EMPTY
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: LIST
98764: LIST
98765: LIST
98766: LIST
98767: LIST
98768: LIST
98769: LIST
98770: LIST
98771: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98772: LD_ADDR_VAR 0 34
98776: PUSH
98777: LD_INT 0
98779: PUSH
98780: LD_INT 4
98782: NEG
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PUSH
98788: LD_INT 0
98790: PUSH
98791: LD_INT 5
98793: NEG
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: PUSH
98799: LD_INT 1
98801: PUSH
98802: LD_INT 4
98804: NEG
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: PUSH
98810: LD_INT 1
98812: PUSH
98813: LD_INT 3
98815: NEG
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: PUSH
98821: LD_INT 0
98823: PUSH
98824: LD_INT 3
98826: NEG
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: PUSH
98832: LD_INT 1
98834: NEG
98835: PUSH
98836: LD_INT 4
98838: NEG
98839: PUSH
98840: EMPTY
98841: LIST
98842: LIST
98843: PUSH
98844: LD_INT 1
98846: NEG
98847: PUSH
98848: LD_INT 5
98850: NEG
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: PUSH
98856: LD_INT 2
98858: PUSH
98859: LD_INT 3
98861: NEG
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: PUSH
98867: LD_INT 2
98869: NEG
98870: PUSH
98871: LD_INT 5
98873: NEG
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: PUSH
98879: LD_INT 3
98881: PUSH
98882: LD_INT 0
98884: PUSH
98885: EMPTY
98886: LIST
98887: LIST
98888: PUSH
98889: LD_INT 3
98891: PUSH
98892: LD_INT 1
98894: NEG
98895: PUSH
98896: EMPTY
98897: LIST
98898: LIST
98899: PUSH
98900: LD_INT 4
98902: PUSH
98903: LD_INT 0
98905: PUSH
98906: EMPTY
98907: LIST
98908: LIST
98909: PUSH
98910: LD_INT 4
98912: PUSH
98913: LD_INT 1
98915: PUSH
98916: EMPTY
98917: LIST
98918: LIST
98919: PUSH
98920: LD_INT 3
98922: PUSH
98923: LD_INT 1
98925: PUSH
98926: EMPTY
98927: LIST
98928: LIST
98929: PUSH
98930: LD_INT 2
98932: PUSH
98933: LD_INT 0
98935: PUSH
98936: EMPTY
98937: LIST
98938: LIST
98939: PUSH
98940: LD_INT 2
98942: PUSH
98943: LD_INT 1
98945: NEG
98946: PUSH
98947: EMPTY
98948: LIST
98949: LIST
98950: PUSH
98951: LD_INT 2
98953: PUSH
98954: LD_INT 2
98956: NEG
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 4
98964: PUSH
98965: LD_INT 2
98967: PUSH
98968: EMPTY
98969: LIST
98970: LIST
98971: PUSH
98972: LD_INT 4
98974: PUSH
98975: LD_INT 4
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: PUSH
98982: LD_INT 4
98984: PUSH
98985: LD_INT 3
98987: PUSH
98988: EMPTY
98989: LIST
98990: LIST
98991: PUSH
98992: LD_INT 5
98994: PUSH
98995: LD_INT 4
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: PUSH
99002: LD_INT 5
99004: PUSH
99005: LD_INT 5
99007: PUSH
99008: EMPTY
99009: LIST
99010: LIST
99011: PUSH
99012: LD_INT 4
99014: PUSH
99015: LD_INT 5
99017: PUSH
99018: EMPTY
99019: LIST
99020: LIST
99021: PUSH
99022: LD_INT 3
99024: PUSH
99025: LD_INT 4
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: PUSH
99032: LD_INT 3
99034: PUSH
99035: LD_INT 3
99037: PUSH
99038: EMPTY
99039: LIST
99040: LIST
99041: PUSH
99042: LD_INT 5
99044: PUSH
99045: LD_INT 3
99047: PUSH
99048: EMPTY
99049: LIST
99050: LIST
99051: PUSH
99052: LD_INT 3
99054: PUSH
99055: LD_INT 5
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: PUSH
99062: LD_INT 0
99064: PUSH
99065: LD_INT 3
99067: PUSH
99068: EMPTY
99069: LIST
99070: LIST
99071: PUSH
99072: LD_INT 0
99074: PUSH
99075: LD_INT 2
99077: PUSH
99078: EMPTY
99079: LIST
99080: LIST
99081: PUSH
99082: LD_INT 1
99084: PUSH
99085: LD_INT 3
99087: PUSH
99088: EMPTY
99089: LIST
99090: LIST
99091: PUSH
99092: LD_INT 1
99094: PUSH
99095: LD_INT 4
99097: PUSH
99098: EMPTY
99099: LIST
99100: LIST
99101: PUSH
99102: LD_INT 0
99104: PUSH
99105: LD_INT 4
99107: PUSH
99108: EMPTY
99109: LIST
99110: LIST
99111: PUSH
99112: LD_INT 1
99114: NEG
99115: PUSH
99116: LD_INT 3
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: PUSH
99123: LD_INT 1
99125: NEG
99126: PUSH
99127: LD_INT 2
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: PUSH
99134: LD_INT 2
99136: PUSH
99137: LD_INT 4
99139: PUSH
99140: EMPTY
99141: LIST
99142: LIST
99143: PUSH
99144: LD_INT 2
99146: NEG
99147: PUSH
99148: LD_INT 2
99150: PUSH
99151: EMPTY
99152: LIST
99153: LIST
99154: PUSH
99155: LD_INT 4
99157: NEG
99158: PUSH
99159: LD_INT 0
99161: PUSH
99162: EMPTY
99163: LIST
99164: LIST
99165: PUSH
99166: LD_INT 4
99168: NEG
99169: PUSH
99170: LD_INT 1
99172: NEG
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: PUSH
99178: LD_INT 3
99180: NEG
99181: PUSH
99182: LD_INT 0
99184: PUSH
99185: EMPTY
99186: LIST
99187: LIST
99188: PUSH
99189: LD_INT 3
99191: NEG
99192: PUSH
99193: LD_INT 1
99195: PUSH
99196: EMPTY
99197: LIST
99198: LIST
99199: PUSH
99200: LD_INT 4
99202: NEG
99203: PUSH
99204: LD_INT 1
99206: PUSH
99207: EMPTY
99208: LIST
99209: LIST
99210: PUSH
99211: LD_INT 5
99213: NEG
99214: PUSH
99215: LD_INT 0
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: PUSH
99222: LD_INT 5
99224: NEG
99225: PUSH
99226: LD_INT 1
99228: NEG
99229: PUSH
99230: EMPTY
99231: LIST
99232: LIST
99233: PUSH
99234: LD_INT 5
99236: NEG
99237: PUSH
99238: LD_INT 2
99240: NEG
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: PUSH
99246: LD_INT 3
99248: NEG
99249: PUSH
99250: LD_INT 2
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: LIST
99277: LIST
99278: LIST
99279: LIST
99280: LIST
99281: LIST
99282: LIST
99283: LIST
99284: LIST
99285: LIST
99286: LIST
99287: LIST
99288: LIST
99289: LIST
99290: LIST
99291: LIST
99292: LIST
99293: LIST
99294: LIST
99295: LIST
99296: LIST
99297: LIST
99298: LIST
99299: LIST
99300: LIST
99301: LIST
99302: LIST
99303: ST_TO_ADDR
// end ; end ;
99304: GO 99307
99306: POP
// case btype of b_depot , b_warehouse :
99307: LD_VAR 0 1
99311: PUSH
99312: LD_INT 0
99314: DOUBLE
99315: EQUAL
99316: IFTRUE 99326
99318: LD_INT 1
99320: DOUBLE
99321: EQUAL
99322: IFTRUE 99326
99324: GO 99527
99326: POP
// case nation of nation_american :
99327: LD_VAR 0 5
99331: PUSH
99332: LD_INT 1
99334: DOUBLE
99335: EQUAL
99336: IFTRUE 99340
99338: GO 99396
99340: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99341: LD_ADDR_VAR 0 9
99345: PUSH
99346: LD_VAR 0 11
99350: PUSH
99351: LD_VAR 0 12
99355: PUSH
99356: LD_VAR 0 13
99360: PUSH
99361: LD_VAR 0 14
99365: PUSH
99366: LD_VAR 0 15
99370: PUSH
99371: LD_VAR 0 16
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: PUSH
99384: LD_VAR 0 4
99388: PUSH
99389: LD_INT 1
99391: PLUS
99392: ARRAY
99393: ST_TO_ADDR
99394: GO 99525
99396: LD_INT 2
99398: DOUBLE
99399: EQUAL
99400: IFTRUE 99404
99402: GO 99460
99404: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99405: LD_ADDR_VAR 0 9
99409: PUSH
99410: LD_VAR 0 17
99414: PUSH
99415: LD_VAR 0 18
99419: PUSH
99420: LD_VAR 0 19
99424: PUSH
99425: LD_VAR 0 20
99429: PUSH
99430: LD_VAR 0 21
99434: PUSH
99435: LD_VAR 0 22
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: LIST
99444: LIST
99445: LIST
99446: LIST
99447: PUSH
99448: LD_VAR 0 4
99452: PUSH
99453: LD_INT 1
99455: PLUS
99456: ARRAY
99457: ST_TO_ADDR
99458: GO 99525
99460: LD_INT 3
99462: DOUBLE
99463: EQUAL
99464: IFTRUE 99468
99466: GO 99524
99468: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99469: LD_ADDR_VAR 0 9
99473: PUSH
99474: LD_VAR 0 23
99478: PUSH
99479: LD_VAR 0 24
99483: PUSH
99484: LD_VAR 0 25
99488: PUSH
99489: LD_VAR 0 26
99493: PUSH
99494: LD_VAR 0 27
99498: PUSH
99499: LD_VAR 0 28
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: PUSH
99512: LD_VAR 0 4
99516: PUSH
99517: LD_INT 1
99519: PLUS
99520: ARRAY
99521: ST_TO_ADDR
99522: GO 99525
99524: POP
99525: GO 100080
99527: LD_INT 2
99529: DOUBLE
99530: EQUAL
99531: IFTRUE 99541
99533: LD_INT 3
99535: DOUBLE
99536: EQUAL
99537: IFTRUE 99541
99539: GO 99597
99541: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99542: LD_ADDR_VAR 0 9
99546: PUSH
99547: LD_VAR 0 29
99551: PUSH
99552: LD_VAR 0 30
99556: PUSH
99557: LD_VAR 0 31
99561: PUSH
99562: LD_VAR 0 32
99566: PUSH
99567: LD_VAR 0 33
99571: PUSH
99572: LD_VAR 0 34
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: PUSH
99585: LD_VAR 0 4
99589: PUSH
99590: LD_INT 1
99592: PLUS
99593: ARRAY
99594: ST_TO_ADDR
99595: GO 100080
99597: LD_INT 16
99599: DOUBLE
99600: EQUAL
99601: IFTRUE 99659
99603: LD_INT 17
99605: DOUBLE
99606: EQUAL
99607: IFTRUE 99659
99609: LD_INT 18
99611: DOUBLE
99612: EQUAL
99613: IFTRUE 99659
99615: LD_INT 19
99617: DOUBLE
99618: EQUAL
99619: IFTRUE 99659
99621: LD_INT 22
99623: DOUBLE
99624: EQUAL
99625: IFTRUE 99659
99627: LD_INT 20
99629: DOUBLE
99630: EQUAL
99631: IFTRUE 99659
99633: LD_INT 21
99635: DOUBLE
99636: EQUAL
99637: IFTRUE 99659
99639: LD_INT 23
99641: DOUBLE
99642: EQUAL
99643: IFTRUE 99659
99645: LD_INT 24
99647: DOUBLE
99648: EQUAL
99649: IFTRUE 99659
99651: LD_INT 25
99653: DOUBLE
99654: EQUAL
99655: IFTRUE 99659
99657: GO 99715
99659: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99660: LD_ADDR_VAR 0 9
99664: PUSH
99665: LD_VAR 0 35
99669: PUSH
99670: LD_VAR 0 36
99674: PUSH
99675: LD_VAR 0 37
99679: PUSH
99680: LD_VAR 0 38
99684: PUSH
99685: LD_VAR 0 39
99689: PUSH
99690: LD_VAR 0 40
99694: PUSH
99695: EMPTY
99696: LIST
99697: LIST
99698: LIST
99699: LIST
99700: LIST
99701: LIST
99702: PUSH
99703: LD_VAR 0 4
99707: PUSH
99708: LD_INT 1
99710: PLUS
99711: ARRAY
99712: ST_TO_ADDR
99713: GO 100080
99715: LD_INT 6
99717: DOUBLE
99718: EQUAL
99719: IFTRUE 99771
99721: LD_INT 7
99723: DOUBLE
99724: EQUAL
99725: IFTRUE 99771
99727: LD_INT 8
99729: DOUBLE
99730: EQUAL
99731: IFTRUE 99771
99733: LD_INT 13
99735: DOUBLE
99736: EQUAL
99737: IFTRUE 99771
99739: LD_INT 12
99741: DOUBLE
99742: EQUAL
99743: IFTRUE 99771
99745: LD_INT 15
99747: DOUBLE
99748: EQUAL
99749: IFTRUE 99771
99751: LD_INT 11
99753: DOUBLE
99754: EQUAL
99755: IFTRUE 99771
99757: LD_INT 14
99759: DOUBLE
99760: EQUAL
99761: IFTRUE 99771
99763: LD_INT 10
99765: DOUBLE
99766: EQUAL
99767: IFTRUE 99771
99769: GO 99827
99771: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99772: LD_ADDR_VAR 0 9
99776: PUSH
99777: LD_VAR 0 41
99781: PUSH
99782: LD_VAR 0 42
99786: PUSH
99787: LD_VAR 0 43
99791: PUSH
99792: LD_VAR 0 44
99796: PUSH
99797: LD_VAR 0 45
99801: PUSH
99802: LD_VAR 0 46
99806: PUSH
99807: EMPTY
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: PUSH
99815: LD_VAR 0 4
99819: PUSH
99820: LD_INT 1
99822: PLUS
99823: ARRAY
99824: ST_TO_ADDR
99825: GO 100080
99827: LD_INT 36
99829: DOUBLE
99830: EQUAL
99831: IFTRUE 99835
99833: GO 99891
99835: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99836: LD_ADDR_VAR 0 9
99840: PUSH
99841: LD_VAR 0 47
99845: PUSH
99846: LD_VAR 0 48
99850: PUSH
99851: LD_VAR 0 49
99855: PUSH
99856: LD_VAR 0 50
99860: PUSH
99861: LD_VAR 0 51
99865: PUSH
99866: LD_VAR 0 52
99870: PUSH
99871: EMPTY
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: PUSH
99879: LD_VAR 0 4
99883: PUSH
99884: LD_INT 1
99886: PLUS
99887: ARRAY
99888: ST_TO_ADDR
99889: GO 100080
99891: LD_INT 4
99893: DOUBLE
99894: EQUAL
99895: IFTRUE 99917
99897: LD_INT 5
99899: DOUBLE
99900: EQUAL
99901: IFTRUE 99917
99903: LD_INT 34
99905: DOUBLE
99906: EQUAL
99907: IFTRUE 99917
99909: LD_INT 37
99911: DOUBLE
99912: EQUAL
99913: IFTRUE 99917
99915: GO 99973
99917: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99918: LD_ADDR_VAR 0 9
99922: PUSH
99923: LD_VAR 0 53
99927: PUSH
99928: LD_VAR 0 54
99932: PUSH
99933: LD_VAR 0 55
99937: PUSH
99938: LD_VAR 0 56
99942: PUSH
99943: LD_VAR 0 57
99947: PUSH
99948: LD_VAR 0 58
99952: PUSH
99953: EMPTY
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: PUSH
99961: LD_VAR 0 4
99965: PUSH
99966: LD_INT 1
99968: PLUS
99969: ARRAY
99970: ST_TO_ADDR
99971: GO 100080
99973: LD_INT 31
99975: DOUBLE
99976: EQUAL
99977: IFTRUE 100023
99979: LD_INT 32
99981: DOUBLE
99982: EQUAL
99983: IFTRUE 100023
99985: LD_INT 33
99987: DOUBLE
99988: EQUAL
99989: IFTRUE 100023
99991: LD_INT 27
99993: DOUBLE
99994: EQUAL
99995: IFTRUE 100023
99997: LD_INT 26
99999: DOUBLE
100000: EQUAL
100001: IFTRUE 100023
100003: LD_INT 28
100005: DOUBLE
100006: EQUAL
100007: IFTRUE 100023
100009: LD_INT 29
100011: DOUBLE
100012: EQUAL
100013: IFTRUE 100023
100015: LD_INT 30
100017: DOUBLE
100018: EQUAL
100019: IFTRUE 100023
100021: GO 100079
100023: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
100024: LD_ADDR_VAR 0 9
100028: PUSH
100029: LD_VAR 0 59
100033: PUSH
100034: LD_VAR 0 60
100038: PUSH
100039: LD_VAR 0 61
100043: PUSH
100044: LD_VAR 0 62
100048: PUSH
100049: LD_VAR 0 63
100053: PUSH
100054: LD_VAR 0 64
100058: PUSH
100059: EMPTY
100060: LIST
100061: LIST
100062: LIST
100063: LIST
100064: LIST
100065: LIST
100066: PUSH
100067: LD_VAR 0 4
100071: PUSH
100072: LD_INT 1
100074: PLUS
100075: ARRAY
100076: ST_TO_ADDR
100077: GO 100080
100079: POP
// temp_list2 = [ ] ;
100080: LD_ADDR_VAR 0 10
100084: PUSH
100085: EMPTY
100086: ST_TO_ADDR
// for i in temp_list do
100087: LD_ADDR_VAR 0 8
100091: PUSH
100092: LD_VAR 0 9
100096: PUSH
100097: FOR_IN
100098: IFFALSE 100150
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
100100: LD_ADDR_VAR 0 10
100104: PUSH
100105: LD_VAR 0 10
100109: PUSH
100110: LD_VAR 0 8
100114: PUSH
100115: LD_INT 1
100117: ARRAY
100118: PUSH
100119: LD_VAR 0 2
100123: PLUS
100124: PUSH
100125: LD_VAR 0 8
100129: PUSH
100130: LD_INT 2
100132: ARRAY
100133: PUSH
100134: LD_VAR 0 3
100138: PLUS
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PUSH
100144: EMPTY
100145: LIST
100146: ADD
100147: ST_TO_ADDR
100148: GO 100097
100150: POP
100151: POP
// result = temp_list2 ;
100152: LD_ADDR_VAR 0 7
100156: PUSH
100157: LD_VAR 0 10
100161: ST_TO_ADDR
// end ;
100162: LD_VAR 0 7
100166: RET
// export function EnemyInRange ( unit , dist ) ; begin
100167: LD_INT 0
100169: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
100170: LD_ADDR_VAR 0 3
100174: PUSH
100175: LD_VAR 0 1
100179: PPUSH
100180: CALL_OW 255
100184: PPUSH
100185: LD_VAR 0 1
100189: PPUSH
100190: CALL_OW 250
100194: PPUSH
100195: LD_VAR 0 1
100199: PPUSH
100200: CALL_OW 251
100204: PPUSH
100205: LD_VAR 0 2
100209: PPUSH
100210: CALL 73569 0 4
100214: PUSH
100215: LD_INT 4
100217: ARRAY
100218: ST_TO_ADDR
// end ;
100219: LD_VAR 0 3
100223: RET
// export function PlayerSeeMe ( unit ) ; begin
100224: LD_INT 0
100226: PPUSH
// result := See ( your_side , unit ) ;
100227: LD_ADDR_VAR 0 2
100231: PUSH
100232: LD_OWVAR 2
100236: PPUSH
100237: LD_VAR 0 1
100241: PPUSH
100242: CALL_OW 292
100246: ST_TO_ADDR
// end ;
100247: LD_VAR 0 2
100251: RET
// export function ReverseDir ( unit ) ; begin
100252: LD_INT 0
100254: PPUSH
// if not unit then
100255: LD_VAR 0 1
100259: NOT
100260: IFFALSE 100264
// exit ;
100262: GO 100287
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
100264: LD_ADDR_VAR 0 2
100268: PUSH
100269: LD_VAR 0 1
100273: PPUSH
100274: CALL_OW 254
100278: PUSH
100279: LD_INT 3
100281: PLUS
100282: PUSH
100283: LD_INT 6
100285: MOD
100286: ST_TO_ADDR
// end ;
100287: LD_VAR 0 2
100291: RET
// export function ReverseArray ( array ) ; var i ; begin
100292: LD_INT 0
100294: PPUSH
100295: PPUSH
// if not array then
100296: LD_VAR 0 1
100300: NOT
100301: IFFALSE 100305
// exit ;
100303: GO 100360
// result := [ ] ;
100305: LD_ADDR_VAR 0 2
100309: PUSH
100310: EMPTY
100311: ST_TO_ADDR
// for i := array downto 1 do
100312: LD_ADDR_VAR 0 3
100316: PUSH
100317: DOUBLE
100318: LD_VAR 0 1
100322: INC
100323: ST_TO_ADDR
100324: LD_INT 1
100326: PUSH
100327: FOR_DOWNTO
100328: IFFALSE 100358
// result := Join ( result , array [ i ] ) ;
100330: LD_ADDR_VAR 0 2
100334: PUSH
100335: LD_VAR 0 2
100339: PPUSH
100340: LD_VAR 0 1
100344: PUSH
100345: LD_VAR 0 3
100349: ARRAY
100350: PPUSH
100351: CALL 104985 0 2
100355: ST_TO_ADDR
100356: GO 100327
100358: POP
100359: POP
// end ;
100360: LD_VAR 0 2
100364: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100365: LD_INT 0
100367: PPUSH
100368: PPUSH
100369: PPUSH
100370: PPUSH
100371: PPUSH
100372: PPUSH
// if not unit or not hexes then
100373: LD_VAR 0 1
100377: NOT
100378: PUSH
100379: LD_VAR 0 2
100383: NOT
100384: OR
100385: IFFALSE 100389
// exit ;
100387: GO 100512
// dist := 9999 ;
100389: LD_ADDR_VAR 0 5
100393: PUSH
100394: LD_INT 9999
100396: ST_TO_ADDR
// for i = 1 to hexes do
100397: LD_ADDR_VAR 0 4
100401: PUSH
100402: DOUBLE
100403: LD_INT 1
100405: DEC
100406: ST_TO_ADDR
100407: LD_VAR 0 2
100411: PUSH
100412: FOR_TO
100413: IFFALSE 100500
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100415: LD_ADDR_VAR 0 6
100419: PUSH
100420: LD_VAR 0 1
100424: PPUSH
100425: LD_VAR 0 2
100429: PUSH
100430: LD_VAR 0 4
100434: ARRAY
100435: PUSH
100436: LD_INT 1
100438: ARRAY
100439: PPUSH
100440: LD_VAR 0 2
100444: PUSH
100445: LD_VAR 0 4
100449: ARRAY
100450: PUSH
100451: LD_INT 2
100453: ARRAY
100454: PPUSH
100455: CALL_OW 297
100459: ST_TO_ADDR
// if tdist < dist then
100460: LD_VAR 0 6
100464: PUSH
100465: LD_VAR 0 5
100469: LESS
100470: IFFALSE 100498
// begin hex := hexes [ i ] ;
100472: LD_ADDR_VAR 0 8
100476: PUSH
100477: LD_VAR 0 2
100481: PUSH
100482: LD_VAR 0 4
100486: ARRAY
100487: ST_TO_ADDR
// dist := tdist ;
100488: LD_ADDR_VAR 0 5
100492: PUSH
100493: LD_VAR 0 6
100497: ST_TO_ADDR
// end ; end ;
100498: GO 100412
100500: POP
100501: POP
// result := hex ;
100502: LD_ADDR_VAR 0 3
100506: PUSH
100507: LD_VAR 0 8
100511: ST_TO_ADDR
// end ;
100512: LD_VAR 0 3
100516: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100517: LD_INT 0
100519: PPUSH
100520: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100521: LD_VAR 0 1
100525: NOT
100526: PUSH
100527: LD_VAR 0 1
100531: PUSH
100532: LD_INT 21
100534: PUSH
100535: LD_INT 2
100537: PUSH
100538: EMPTY
100539: LIST
100540: LIST
100541: PUSH
100542: LD_INT 23
100544: PUSH
100545: LD_INT 2
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: PUSH
100552: EMPTY
100553: LIST
100554: LIST
100555: PPUSH
100556: CALL_OW 69
100560: IN
100561: NOT
100562: OR
100563: IFFALSE 100567
// exit ;
100565: GO 100614
// for i = 1 to 3 do
100567: LD_ADDR_VAR 0 3
100571: PUSH
100572: DOUBLE
100573: LD_INT 1
100575: DEC
100576: ST_TO_ADDR
100577: LD_INT 3
100579: PUSH
100580: FOR_TO
100581: IFFALSE 100612
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100583: LD_VAR 0 1
100587: PPUSH
100588: CALL_OW 250
100592: PPUSH
100593: LD_VAR 0 1
100597: PPUSH
100598: CALL_OW 251
100602: PPUSH
100603: LD_INT 1
100605: PPUSH
100606: CALL_OW 453
100610: GO 100580
100612: POP
100613: POP
// end ;
100614: LD_VAR 0 2
100618: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100619: LD_INT 0
100621: PPUSH
100622: PPUSH
100623: PPUSH
100624: PPUSH
100625: PPUSH
100626: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100627: LD_VAR 0 1
100631: NOT
100632: PUSH
100633: LD_VAR 0 2
100637: NOT
100638: OR
100639: PUSH
100640: LD_VAR 0 1
100644: PPUSH
100645: CALL_OW 314
100649: OR
100650: IFFALSE 100654
// exit ;
100652: GO 101095
// x := GetX ( enemy_unit ) ;
100654: LD_ADDR_VAR 0 7
100658: PUSH
100659: LD_VAR 0 2
100663: PPUSH
100664: CALL_OW 250
100668: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100669: LD_ADDR_VAR 0 8
100673: PUSH
100674: LD_VAR 0 2
100678: PPUSH
100679: CALL_OW 251
100683: ST_TO_ADDR
// if not x or not y then
100684: LD_VAR 0 7
100688: NOT
100689: PUSH
100690: LD_VAR 0 8
100694: NOT
100695: OR
100696: IFFALSE 100700
// exit ;
100698: GO 101095
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100700: LD_ADDR_VAR 0 6
100704: PUSH
100705: LD_VAR 0 7
100709: PPUSH
100710: LD_INT 0
100712: PPUSH
100713: LD_INT 4
100715: PPUSH
100716: CALL_OW 272
100720: PUSH
100721: LD_VAR 0 8
100725: PPUSH
100726: LD_INT 0
100728: PPUSH
100729: LD_INT 4
100731: PPUSH
100732: CALL_OW 273
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PUSH
100741: LD_VAR 0 7
100745: PPUSH
100746: LD_INT 1
100748: PPUSH
100749: LD_INT 4
100751: PPUSH
100752: CALL_OW 272
100756: PUSH
100757: LD_VAR 0 8
100761: PPUSH
100762: LD_INT 1
100764: PPUSH
100765: LD_INT 4
100767: PPUSH
100768: CALL_OW 273
100772: PUSH
100773: EMPTY
100774: LIST
100775: LIST
100776: PUSH
100777: LD_VAR 0 7
100781: PPUSH
100782: LD_INT 2
100784: PPUSH
100785: LD_INT 4
100787: PPUSH
100788: CALL_OW 272
100792: PUSH
100793: LD_VAR 0 8
100797: PPUSH
100798: LD_INT 2
100800: PPUSH
100801: LD_INT 4
100803: PPUSH
100804: CALL_OW 273
100808: PUSH
100809: EMPTY
100810: LIST
100811: LIST
100812: PUSH
100813: LD_VAR 0 7
100817: PPUSH
100818: LD_INT 3
100820: PPUSH
100821: LD_INT 4
100823: PPUSH
100824: CALL_OW 272
100828: PUSH
100829: LD_VAR 0 8
100833: PPUSH
100834: LD_INT 3
100836: PPUSH
100837: LD_INT 4
100839: PPUSH
100840: CALL_OW 273
100844: PUSH
100845: EMPTY
100846: LIST
100847: LIST
100848: PUSH
100849: LD_VAR 0 7
100853: PPUSH
100854: LD_INT 4
100856: PPUSH
100857: LD_INT 4
100859: PPUSH
100860: CALL_OW 272
100864: PUSH
100865: LD_VAR 0 8
100869: PPUSH
100870: LD_INT 4
100872: PPUSH
100873: LD_INT 4
100875: PPUSH
100876: CALL_OW 273
100880: PUSH
100881: EMPTY
100882: LIST
100883: LIST
100884: PUSH
100885: LD_VAR 0 7
100889: PPUSH
100890: LD_INT 5
100892: PPUSH
100893: LD_INT 4
100895: PPUSH
100896: CALL_OW 272
100900: PUSH
100901: LD_VAR 0 8
100905: PPUSH
100906: LD_INT 5
100908: PPUSH
100909: LD_INT 4
100911: PPUSH
100912: CALL_OW 273
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: LIST
100925: LIST
100926: LIST
100927: LIST
100928: ST_TO_ADDR
// for i = tmp downto 1 do
100929: LD_ADDR_VAR 0 4
100933: PUSH
100934: DOUBLE
100935: LD_VAR 0 6
100939: INC
100940: ST_TO_ADDR
100941: LD_INT 1
100943: PUSH
100944: FOR_DOWNTO
100945: IFFALSE 101046
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
100947: LD_VAR 0 6
100951: PUSH
100952: LD_VAR 0 4
100956: ARRAY
100957: PUSH
100958: LD_INT 1
100960: ARRAY
100961: PPUSH
100962: LD_VAR 0 6
100966: PUSH
100967: LD_VAR 0 4
100971: ARRAY
100972: PUSH
100973: LD_INT 2
100975: ARRAY
100976: PPUSH
100977: CALL_OW 488
100981: NOT
100982: PUSH
100983: LD_VAR 0 6
100987: PUSH
100988: LD_VAR 0 4
100992: ARRAY
100993: PUSH
100994: LD_INT 1
100996: ARRAY
100997: PPUSH
100998: LD_VAR 0 6
101002: PUSH
101003: LD_VAR 0 4
101007: ARRAY
101008: PUSH
101009: LD_INT 2
101011: ARRAY
101012: PPUSH
101013: CALL_OW 428
101017: PUSH
101018: LD_INT 0
101020: NONEQUAL
101021: OR
101022: IFFALSE 101044
// tmp := Delete ( tmp , i ) ;
101024: LD_ADDR_VAR 0 6
101028: PUSH
101029: LD_VAR 0 6
101033: PPUSH
101034: LD_VAR 0 4
101038: PPUSH
101039: CALL_OW 3
101043: ST_TO_ADDR
101044: GO 100944
101046: POP
101047: POP
// j := GetClosestHex ( unit , tmp ) ;
101048: LD_ADDR_VAR 0 5
101052: PUSH
101053: LD_VAR 0 1
101057: PPUSH
101058: LD_VAR 0 6
101062: PPUSH
101063: CALL 100365 0 2
101067: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
101068: LD_VAR 0 1
101072: PPUSH
101073: LD_VAR 0 5
101077: PUSH
101078: LD_INT 1
101080: ARRAY
101081: PPUSH
101082: LD_VAR 0 5
101086: PUSH
101087: LD_INT 2
101089: ARRAY
101090: PPUSH
101091: CALL_OW 111
// end ;
101095: LD_VAR 0 3
101099: RET
// export function PrepareApemanSoldier ( ) ; begin
101100: LD_INT 0
101102: PPUSH
// uc_nation := 0 ;
101103: LD_ADDR_OWVAR 21
101107: PUSH
101108: LD_INT 0
101110: ST_TO_ADDR
// hc_sex := sex_male ;
101111: LD_ADDR_OWVAR 27
101115: PUSH
101116: LD_INT 1
101118: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
101119: LD_ADDR_OWVAR 28
101123: PUSH
101124: LD_INT 15
101126: ST_TO_ADDR
// hc_gallery :=  ;
101127: LD_ADDR_OWVAR 33
101131: PUSH
101132: LD_STRING 
101134: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101135: LD_ADDR_OWVAR 31
101139: PUSH
101140: LD_INT 0
101142: PPUSH
101143: LD_INT 3
101145: PPUSH
101146: CALL_OW 12
101150: PUSH
101151: LD_INT 0
101153: PPUSH
101154: LD_INT 3
101156: PPUSH
101157: CALL_OW 12
101161: PUSH
101162: LD_INT 0
101164: PUSH
101165: LD_INT 0
101167: PUSH
101168: EMPTY
101169: LIST
101170: LIST
101171: LIST
101172: LIST
101173: ST_TO_ADDR
// end ;
101174: LD_VAR 0 1
101178: RET
// export function PrepareApemanEngineer ( ) ; begin
101179: LD_INT 0
101181: PPUSH
// uc_nation := 0 ;
101182: LD_ADDR_OWVAR 21
101186: PUSH
101187: LD_INT 0
101189: ST_TO_ADDR
// hc_sex := sex_male ;
101190: LD_ADDR_OWVAR 27
101194: PUSH
101195: LD_INT 1
101197: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
101198: LD_ADDR_OWVAR 28
101202: PUSH
101203: LD_INT 16
101205: ST_TO_ADDR
// hc_gallery :=  ;
101206: LD_ADDR_OWVAR 33
101210: PUSH
101211: LD_STRING 
101213: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101214: LD_ADDR_OWVAR 31
101218: PUSH
101219: LD_INT 0
101221: PPUSH
101222: LD_INT 3
101224: PPUSH
101225: CALL_OW 12
101229: PUSH
101230: LD_INT 0
101232: PPUSH
101233: LD_INT 3
101235: PPUSH
101236: CALL_OW 12
101240: PUSH
101241: LD_INT 0
101243: PUSH
101244: LD_INT 0
101246: PUSH
101247: EMPTY
101248: LIST
101249: LIST
101250: LIST
101251: LIST
101252: ST_TO_ADDR
// end ;
101253: LD_VAR 0 1
101257: RET
// export function PrepareApeman ( agressivity ) ; begin
101258: LD_INT 0
101260: PPUSH
// uc_side := 0 ;
101261: LD_ADDR_OWVAR 20
101265: PUSH
101266: LD_INT 0
101268: ST_TO_ADDR
// uc_nation := 0 ;
101269: LD_ADDR_OWVAR 21
101273: PUSH
101274: LD_INT 0
101276: ST_TO_ADDR
// hc_sex := sex_male ;
101277: LD_ADDR_OWVAR 27
101281: PUSH
101282: LD_INT 1
101284: ST_TO_ADDR
// hc_class := class_apeman ;
101285: LD_ADDR_OWVAR 28
101289: PUSH
101290: LD_INT 12
101292: ST_TO_ADDR
// hc_gallery :=  ;
101293: LD_ADDR_OWVAR 33
101297: PUSH
101298: LD_STRING 
101300: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101301: LD_ADDR_OWVAR 35
101305: PUSH
101306: LD_VAR 0 1
101310: NEG
101311: PPUSH
101312: LD_VAR 0 1
101316: PPUSH
101317: CALL_OW 12
101321: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101322: LD_ADDR_OWVAR 31
101326: PUSH
101327: LD_INT 0
101329: PPUSH
101330: LD_INT 3
101332: PPUSH
101333: CALL_OW 12
101337: PUSH
101338: LD_INT 0
101340: PPUSH
101341: LD_INT 3
101343: PPUSH
101344: CALL_OW 12
101348: PUSH
101349: LD_INT 0
101351: PUSH
101352: LD_INT 0
101354: PUSH
101355: EMPTY
101356: LIST
101357: LIST
101358: LIST
101359: LIST
101360: ST_TO_ADDR
// end ;
101361: LD_VAR 0 2
101365: RET
// export function PrepareTiger ( agressivity ) ; begin
101366: LD_INT 0
101368: PPUSH
// uc_side := 0 ;
101369: LD_ADDR_OWVAR 20
101373: PUSH
101374: LD_INT 0
101376: ST_TO_ADDR
// uc_nation := 0 ;
101377: LD_ADDR_OWVAR 21
101381: PUSH
101382: LD_INT 0
101384: ST_TO_ADDR
// hc_class := class_tiger ;
101385: LD_ADDR_OWVAR 28
101389: PUSH
101390: LD_INT 14
101392: ST_TO_ADDR
// hc_gallery :=  ;
101393: LD_ADDR_OWVAR 33
101397: PUSH
101398: LD_STRING 
101400: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101401: LD_ADDR_OWVAR 35
101405: PUSH
101406: LD_VAR 0 1
101410: NEG
101411: PPUSH
101412: LD_VAR 0 1
101416: PPUSH
101417: CALL_OW 12
101421: ST_TO_ADDR
// end ;
101422: LD_VAR 0 2
101426: RET
// export function PrepareEnchidna ( ) ; begin
101427: LD_INT 0
101429: PPUSH
// uc_side := 0 ;
101430: LD_ADDR_OWVAR 20
101434: PUSH
101435: LD_INT 0
101437: ST_TO_ADDR
// uc_nation := 0 ;
101438: LD_ADDR_OWVAR 21
101442: PUSH
101443: LD_INT 0
101445: ST_TO_ADDR
// hc_class := class_baggie ;
101446: LD_ADDR_OWVAR 28
101450: PUSH
101451: LD_INT 13
101453: ST_TO_ADDR
// hc_gallery :=  ;
101454: LD_ADDR_OWVAR 33
101458: PUSH
101459: LD_STRING 
101461: ST_TO_ADDR
// end ;
101462: LD_VAR 0 1
101466: RET
// export function PrepareFrog ( ) ; begin
101467: LD_INT 0
101469: PPUSH
// uc_side := 0 ;
101470: LD_ADDR_OWVAR 20
101474: PUSH
101475: LD_INT 0
101477: ST_TO_ADDR
// uc_nation := 0 ;
101478: LD_ADDR_OWVAR 21
101482: PUSH
101483: LD_INT 0
101485: ST_TO_ADDR
// hc_class := class_frog ;
101486: LD_ADDR_OWVAR 28
101490: PUSH
101491: LD_INT 19
101493: ST_TO_ADDR
// hc_gallery :=  ;
101494: LD_ADDR_OWVAR 33
101498: PUSH
101499: LD_STRING 
101501: ST_TO_ADDR
// end ;
101502: LD_VAR 0 1
101506: RET
// export function PrepareFish ( ) ; begin
101507: LD_INT 0
101509: PPUSH
// uc_side := 0 ;
101510: LD_ADDR_OWVAR 20
101514: PUSH
101515: LD_INT 0
101517: ST_TO_ADDR
// uc_nation := 0 ;
101518: LD_ADDR_OWVAR 21
101522: PUSH
101523: LD_INT 0
101525: ST_TO_ADDR
// hc_class := class_fish ;
101526: LD_ADDR_OWVAR 28
101530: PUSH
101531: LD_INT 20
101533: ST_TO_ADDR
// hc_gallery :=  ;
101534: LD_ADDR_OWVAR 33
101538: PUSH
101539: LD_STRING 
101541: ST_TO_ADDR
// end ;
101542: LD_VAR 0 1
101546: RET
// export function PrepareBird ( ) ; begin
101547: LD_INT 0
101549: PPUSH
// uc_side := 0 ;
101550: LD_ADDR_OWVAR 20
101554: PUSH
101555: LD_INT 0
101557: ST_TO_ADDR
// uc_nation := 0 ;
101558: LD_ADDR_OWVAR 21
101562: PUSH
101563: LD_INT 0
101565: ST_TO_ADDR
// hc_class := class_phororhacos ;
101566: LD_ADDR_OWVAR 28
101570: PUSH
101571: LD_INT 18
101573: ST_TO_ADDR
// hc_gallery :=  ;
101574: LD_ADDR_OWVAR 33
101578: PUSH
101579: LD_STRING 
101581: ST_TO_ADDR
// end ;
101582: LD_VAR 0 1
101586: RET
// export function PrepareHorse ( ) ; begin
101587: LD_INT 0
101589: PPUSH
// uc_side := 0 ;
101590: LD_ADDR_OWVAR 20
101594: PUSH
101595: LD_INT 0
101597: ST_TO_ADDR
// uc_nation := 0 ;
101598: LD_ADDR_OWVAR 21
101602: PUSH
101603: LD_INT 0
101605: ST_TO_ADDR
// hc_class := class_horse ;
101606: LD_ADDR_OWVAR 28
101610: PUSH
101611: LD_INT 21
101613: ST_TO_ADDR
// hc_gallery :=  ;
101614: LD_ADDR_OWVAR 33
101618: PUSH
101619: LD_STRING 
101621: ST_TO_ADDR
// end ;
101622: LD_VAR 0 1
101626: RET
// export function PrepareMastodont ( ) ; begin
101627: LD_INT 0
101629: PPUSH
// uc_side := 0 ;
101630: LD_ADDR_OWVAR 20
101634: PUSH
101635: LD_INT 0
101637: ST_TO_ADDR
// uc_nation := 0 ;
101638: LD_ADDR_OWVAR 21
101642: PUSH
101643: LD_INT 0
101645: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101646: LD_ADDR_OWVAR 37
101650: PUSH
101651: LD_INT 31
101653: ST_TO_ADDR
// vc_control := control_rider ;
101654: LD_ADDR_OWVAR 38
101658: PUSH
101659: LD_INT 4
101661: ST_TO_ADDR
// end ;
101662: LD_VAR 0 1
101666: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101667: LD_INT 0
101669: PPUSH
101670: PPUSH
101671: PPUSH
// uc_side = 0 ;
101672: LD_ADDR_OWVAR 20
101676: PUSH
101677: LD_INT 0
101679: ST_TO_ADDR
// uc_nation = 0 ;
101680: LD_ADDR_OWVAR 21
101684: PUSH
101685: LD_INT 0
101687: ST_TO_ADDR
// InitHc_All ( ) ;
101688: CALL_OW 584
// InitVc ;
101692: CALL_OW 20
// if mastodonts then
101696: LD_VAR 0 6
101700: IFFALSE 101767
// for i = 1 to mastodonts do
101702: LD_ADDR_VAR 0 11
101706: PUSH
101707: DOUBLE
101708: LD_INT 1
101710: DEC
101711: ST_TO_ADDR
101712: LD_VAR 0 6
101716: PUSH
101717: FOR_TO
101718: IFFALSE 101765
// begin vc_chassis := 31 ;
101720: LD_ADDR_OWVAR 37
101724: PUSH
101725: LD_INT 31
101727: ST_TO_ADDR
// vc_control := control_rider ;
101728: LD_ADDR_OWVAR 38
101732: PUSH
101733: LD_INT 4
101735: ST_TO_ADDR
// animal := CreateVehicle ;
101736: LD_ADDR_VAR 0 12
101740: PUSH
101741: CALL_OW 45
101745: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101746: LD_VAR 0 12
101750: PPUSH
101751: LD_VAR 0 8
101755: PPUSH
101756: LD_INT 0
101758: PPUSH
101759: CALL 103902 0 3
// end ;
101763: GO 101717
101765: POP
101766: POP
// if horses then
101767: LD_VAR 0 5
101771: IFFALSE 101838
// for i = 1 to horses do
101773: LD_ADDR_VAR 0 11
101777: PUSH
101778: DOUBLE
101779: LD_INT 1
101781: DEC
101782: ST_TO_ADDR
101783: LD_VAR 0 5
101787: PUSH
101788: FOR_TO
101789: IFFALSE 101836
// begin hc_class := 21 ;
101791: LD_ADDR_OWVAR 28
101795: PUSH
101796: LD_INT 21
101798: ST_TO_ADDR
// hc_gallery :=  ;
101799: LD_ADDR_OWVAR 33
101803: PUSH
101804: LD_STRING 
101806: ST_TO_ADDR
// animal := CreateHuman ;
101807: LD_ADDR_VAR 0 12
101811: PUSH
101812: CALL_OW 44
101816: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101817: LD_VAR 0 12
101821: PPUSH
101822: LD_VAR 0 8
101826: PPUSH
101827: LD_INT 0
101829: PPUSH
101830: CALL 103902 0 3
// end ;
101834: GO 101788
101836: POP
101837: POP
// if birds then
101838: LD_VAR 0 1
101842: IFFALSE 101909
// for i = 1 to birds do
101844: LD_ADDR_VAR 0 11
101848: PUSH
101849: DOUBLE
101850: LD_INT 1
101852: DEC
101853: ST_TO_ADDR
101854: LD_VAR 0 1
101858: PUSH
101859: FOR_TO
101860: IFFALSE 101907
// begin hc_class = 18 ;
101862: LD_ADDR_OWVAR 28
101866: PUSH
101867: LD_INT 18
101869: ST_TO_ADDR
// hc_gallery =  ;
101870: LD_ADDR_OWVAR 33
101874: PUSH
101875: LD_STRING 
101877: ST_TO_ADDR
// animal := CreateHuman ;
101878: LD_ADDR_VAR 0 12
101882: PUSH
101883: CALL_OW 44
101887: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101888: LD_VAR 0 12
101892: PPUSH
101893: LD_VAR 0 8
101897: PPUSH
101898: LD_INT 0
101900: PPUSH
101901: CALL 103902 0 3
// end ;
101905: GO 101859
101907: POP
101908: POP
// if tigers then
101909: LD_VAR 0 2
101913: IFFALSE 101997
// for i = 1 to tigers do
101915: LD_ADDR_VAR 0 11
101919: PUSH
101920: DOUBLE
101921: LD_INT 1
101923: DEC
101924: ST_TO_ADDR
101925: LD_VAR 0 2
101929: PUSH
101930: FOR_TO
101931: IFFALSE 101995
// begin hc_class = class_tiger ;
101933: LD_ADDR_OWVAR 28
101937: PUSH
101938: LD_INT 14
101940: ST_TO_ADDR
// hc_gallery =  ;
101941: LD_ADDR_OWVAR 33
101945: PUSH
101946: LD_STRING 
101948: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
101949: LD_ADDR_OWVAR 35
101953: PUSH
101954: LD_INT 7
101956: NEG
101957: PPUSH
101958: LD_INT 7
101960: PPUSH
101961: CALL_OW 12
101965: ST_TO_ADDR
// animal := CreateHuman ;
101966: LD_ADDR_VAR 0 12
101970: PUSH
101971: CALL_OW 44
101975: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101976: LD_VAR 0 12
101980: PPUSH
101981: LD_VAR 0 8
101985: PPUSH
101986: LD_INT 0
101988: PPUSH
101989: CALL 103902 0 3
// end ;
101993: GO 101930
101995: POP
101996: POP
// if apemans then
101997: LD_VAR 0 3
102001: IFFALSE 102124
// for i = 1 to apemans do
102003: LD_ADDR_VAR 0 11
102007: PUSH
102008: DOUBLE
102009: LD_INT 1
102011: DEC
102012: ST_TO_ADDR
102013: LD_VAR 0 3
102017: PUSH
102018: FOR_TO
102019: IFFALSE 102122
// begin hc_class = class_apeman ;
102021: LD_ADDR_OWVAR 28
102025: PUSH
102026: LD_INT 12
102028: ST_TO_ADDR
// hc_gallery =  ;
102029: LD_ADDR_OWVAR 33
102033: PUSH
102034: LD_STRING 
102036: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
102037: LD_ADDR_OWVAR 35
102041: PUSH
102042: LD_INT 2
102044: NEG
102045: PPUSH
102046: LD_INT 2
102048: PPUSH
102049: CALL_OW 12
102053: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
102054: LD_ADDR_OWVAR 31
102058: PUSH
102059: LD_INT 1
102061: PPUSH
102062: LD_INT 3
102064: PPUSH
102065: CALL_OW 12
102069: PUSH
102070: LD_INT 1
102072: PPUSH
102073: LD_INT 3
102075: PPUSH
102076: CALL_OW 12
102080: PUSH
102081: LD_INT 0
102083: PUSH
102084: LD_INT 0
102086: PUSH
102087: EMPTY
102088: LIST
102089: LIST
102090: LIST
102091: LIST
102092: ST_TO_ADDR
// animal := CreateHuman ;
102093: LD_ADDR_VAR 0 12
102097: PUSH
102098: CALL_OW 44
102102: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102103: LD_VAR 0 12
102107: PPUSH
102108: LD_VAR 0 8
102112: PPUSH
102113: LD_INT 0
102115: PPUSH
102116: CALL 103902 0 3
// end ;
102120: GO 102018
102122: POP
102123: POP
// if enchidnas then
102124: LD_VAR 0 4
102128: IFFALSE 102195
// for i = 1 to enchidnas do
102130: LD_ADDR_VAR 0 11
102134: PUSH
102135: DOUBLE
102136: LD_INT 1
102138: DEC
102139: ST_TO_ADDR
102140: LD_VAR 0 4
102144: PUSH
102145: FOR_TO
102146: IFFALSE 102193
// begin hc_class = 13 ;
102148: LD_ADDR_OWVAR 28
102152: PUSH
102153: LD_INT 13
102155: ST_TO_ADDR
// hc_gallery =  ;
102156: LD_ADDR_OWVAR 33
102160: PUSH
102161: LD_STRING 
102163: ST_TO_ADDR
// animal := CreateHuman ;
102164: LD_ADDR_VAR 0 12
102168: PUSH
102169: CALL_OW 44
102173: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102174: LD_VAR 0 12
102178: PPUSH
102179: LD_VAR 0 8
102183: PPUSH
102184: LD_INT 0
102186: PPUSH
102187: CALL 103902 0 3
// end ;
102191: GO 102145
102193: POP
102194: POP
// if fishes then
102195: LD_VAR 0 7
102199: IFFALSE 102266
// for i = 1 to fishes do
102201: LD_ADDR_VAR 0 11
102205: PUSH
102206: DOUBLE
102207: LD_INT 1
102209: DEC
102210: ST_TO_ADDR
102211: LD_VAR 0 7
102215: PUSH
102216: FOR_TO
102217: IFFALSE 102264
// begin hc_class = 20 ;
102219: LD_ADDR_OWVAR 28
102223: PUSH
102224: LD_INT 20
102226: ST_TO_ADDR
// hc_gallery =  ;
102227: LD_ADDR_OWVAR 33
102231: PUSH
102232: LD_STRING 
102234: ST_TO_ADDR
// animal := CreateHuman ;
102235: LD_ADDR_VAR 0 12
102239: PUSH
102240: CALL_OW 44
102244: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
102245: LD_VAR 0 12
102249: PPUSH
102250: LD_VAR 0 9
102254: PPUSH
102255: LD_INT 0
102257: PPUSH
102258: CALL 103902 0 3
// end ;
102262: GO 102216
102264: POP
102265: POP
// end ;
102266: LD_VAR 0 10
102270: RET
// export function WantHeal ( sci , unit ) ; begin
102271: LD_INT 0
102273: PPUSH
// if GetTaskList ( sci ) > 0 then
102274: LD_VAR 0 1
102278: PPUSH
102279: CALL_OW 437
102283: PUSH
102284: LD_INT 0
102286: GREATER
102287: IFFALSE 102357
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
102289: LD_VAR 0 1
102293: PPUSH
102294: CALL_OW 437
102298: PUSH
102299: LD_INT 1
102301: ARRAY
102302: PUSH
102303: LD_INT 1
102305: ARRAY
102306: PUSH
102307: LD_STRING l
102309: EQUAL
102310: PUSH
102311: LD_VAR 0 1
102315: PPUSH
102316: CALL_OW 437
102320: PUSH
102321: LD_INT 1
102323: ARRAY
102324: PUSH
102325: LD_INT 4
102327: ARRAY
102328: PUSH
102329: LD_VAR 0 2
102333: EQUAL
102334: AND
102335: IFFALSE 102347
// result := true else
102337: LD_ADDR_VAR 0 3
102341: PUSH
102342: LD_INT 1
102344: ST_TO_ADDR
102345: GO 102355
// result := false ;
102347: LD_ADDR_VAR 0 3
102351: PUSH
102352: LD_INT 0
102354: ST_TO_ADDR
// end else
102355: GO 102365
// result := false ;
102357: LD_ADDR_VAR 0 3
102361: PUSH
102362: LD_INT 0
102364: ST_TO_ADDR
// end ;
102365: LD_VAR 0 3
102369: RET
// export function HealTarget ( sci ) ; begin
102370: LD_INT 0
102372: PPUSH
// if not sci then
102373: LD_VAR 0 1
102377: NOT
102378: IFFALSE 102382
// exit ;
102380: GO 102447
// result := 0 ;
102382: LD_ADDR_VAR 0 2
102386: PUSH
102387: LD_INT 0
102389: ST_TO_ADDR
// if GetTaskList ( sci ) then
102390: LD_VAR 0 1
102394: PPUSH
102395: CALL_OW 437
102399: IFFALSE 102447
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102401: LD_VAR 0 1
102405: PPUSH
102406: CALL_OW 437
102410: PUSH
102411: LD_INT 1
102413: ARRAY
102414: PUSH
102415: LD_INT 1
102417: ARRAY
102418: PUSH
102419: LD_STRING l
102421: EQUAL
102422: IFFALSE 102447
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102424: LD_ADDR_VAR 0 2
102428: PUSH
102429: LD_VAR 0 1
102433: PPUSH
102434: CALL_OW 437
102438: PUSH
102439: LD_INT 1
102441: ARRAY
102442: PUSH
102443: LD_INT 4
102445: ARRAY
102446: ST_TO_ADDR
// end ;
102447: LD_VAR 0 2
102451: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102452: LD_INT 0
102454: PPUSH
102455: PPUSH
102456: PPUSH
102457: PPUSH
// if not base_units then
102458: LD_VAR 0 1
102462: NOT
102463: IFFALSE 102467
// exit ;
102465: GO 102554
// result := false ;
102467: LD_ADDR_VAR 0 2
102471: PUSH
102472: LD_INT 0
102474: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102475: LD_ADDR_VAR 0 5
102479: PUSH
102480: LD_VAR 0 1
102484: PPUSH
102485: LD_INT 21
102487: PUSH
102488: LD_INT 3
102490: PUSH
102491: EMPTY
102492: LIST
102493: LIST
102494: PPUSH
102495: CALL_OW 72
102499: ST_TO_ADDR
// if not tmp then
102500: LD_VAR 0 5
102504: NOT
102505: IFFALSE 102509
// exit ;
102507: GO 102554
// for i in tmp do
102509: LD_ADDR_VAR 0 3
102513: PUSH
102514: LD_VAR 0 5
102518: PUSH
102519: FOR_IN
102520: IFFALSE 102552
// begin result := EnemyInRange ( i , 22 ) ;
102522: LD_ADDR_VAR 0 2
102526: PUSH
102527: LD_VAR 0 3
102531: PPUSH
102532: LD_INT 22
102534: PPUSH
102535: CALL 100167 0 2
102539: ST_TO_ADDR
// if result then
102540: LD_VAR 0 2
102544: IFFALSE 102550
// exit ;
102546: POP
102547: POP
102548: GO 102554
// end ;
102550: GO 102519
102552: POP
102553: POP
// end ;
102554: LD_VAR 0 2
102558: RET
// export function FilterByTag ( units , tag ) ; begin
102559: LD_INT 0
102561: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102562: LD_ADDR_VAR 0 3
102566: PUSH
102567: LD_VAR 0 1
102571: PPUSH
102572: LD_INT 120
102574: PUSH
102575: LD_VAR 0 2
102579: PUSH
102580: EMPTY
102581: LIST
102582: LIST
102583: PPUSH
102584: CALL_OW 72
102588: ST_TO_ADDR
// end ;
102589: LD_VAR 0 3
102593: RET
// export function IsDriver ( un ) ; begin
102594: LD_INT 0
102596: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102597: LD_ADDR_VAR 0 2
102601: PUSH
102602: LD_VAR 0 1
102606: PUSH
102607: LD_INT 55
102609: PUSH
102610: EMPTY
102611: LIST
102612: PPUSH
102613: CALL_OW 69
102617: IN
102618: ST_TO_ADDR
// end ;
102619: LD_VAR 0 2
102623: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102624: LD_INT 0
102626: PPUSH
102627: PPUSH
// list := [ ] ;
102628: LD_ADDR_VAR 0 5
102632: PUSH
102633: EMPTY
102634: ST_TO_ADDR
// case d of 0 :
102635: LD_VAR 0 3
102639: PUSH
102640: LD_INT 0
102642: DOUBLE
102643: EQUAL
102644: IFTRUE 102648
102646: GO 102781
102648: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102649: LD_ADDR_VAR 0 5
102653: PUSH
102654: LD_VAR 0 1
102658: PUSH
102659: LD_INT 4
102661: MINUS
102662: PUSH
102663: LD_VAR 0 2
102667: PUSH
102668: LD_INT 4
102670: MINUS
102671: PUSH
102672: LD_INT 2
102674: PUSH
102675: EMPTY
102676: LIST
102677: LIST
102678: LIST
102679: PUSH
102680: LD_VAR 0 1
102684: PUSH
102685: LD_INT 3
102687: MINUS
102688: PUSH
102689: LD_VAR 0 2
102693: PUSH
102694: LD_INT 1
102696: PUSH
102697: EMPTY
102698: LIST
102699: LIST
102700: LIST
102701: PUSH
102702: LD_VAR 0 1
102706: PUSH
102707: LD_INT 4
102709: PLUS
102710: PUSH
102711: LD_VAR 0 2
102715: PUSH
102716: LD_INT 4
102718: PUSH
102719: EMPTY
102720: LIST
102721: LIST
102722: LIST
102723: PUSH
102724: LD_VAR 0 1
102728: PUSH
102729: LD_INT 3
102731: PLUS
102732: PUSH
102733: LD_VAR 0 2
102737: PUSH
102738: LD_INT 3
102740: PLUS
102741: PUSH
102742: LD_INT 5
102744: PUSH
102745: EMPTY
102746: LIST
102747: LIST
102748: LIST
102749: PUSH
102750: LD_VAR 0 1
102754: PUSH
102755: LD_VAR 0 2
102759: PUSH
102760: LD_INT 4
102762: PLUS
102763: PUSH
102764: LD_INT 0
102766: PUSH
102767: EMPTY
102768: LIST
102769: LIST
102770: LIST
102771: PUSH
102772: EMPTY
102773: LIST
102774: LIST
102775: LIST
102776: LIST
102777: LIST
102778: ST_TO_ADDR
// end ; 1 :
102779: GO 103479
102781: LD_INT 1
102783: DOUBLE
102784: EQUAL
102785: IFTRUE 102789
102787: GO 102922
102789: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102790: LD_ADDR_VAR 0 5
102794: PUSH
102795: LD_VAR 0 1
102799: PUSH
102800: LD_VAR 0 2
102804: PUSH
102805: LD_INT 4
102807: MINUS
102808: PUSH
102809: LD_INT 3
102811: PUSH
102812: EMPTY
102813: LIST
102814: LIST
102815: LIST
102816: PUSH
102817: LD_VAR 0 1
102821: PUSH
102822: LD_INT 3
102824: MINUS
102825: PUSH
102826: LD_VAR 0 2
102830: PUSH
102831: LD_INT 3
102833: MINUS
102834: PUSH
102835: LD_INT 2
102837: PUSH
102838: EMPTY
102839: LIST
102840: LIST
102841: LIST
102842: PUSH
102843: LD_VAR 0 1
102847: PUSH
102848: LD_INT 4
102850: MINUS
102851: PUSH
102852: LD_VAR 0 2
102856: PUSH
102857: LD_INT 1
102859: PUSH
102860: EMPTY
102861: LIST
102862: LIST
102863: LIST
102864: PUSH
102865: LD_VAR 0 1
102869: PUSH
102870: LD_VAR 0 2
102874: PUSH
102875: LD_INT 3
102877: PLUS
102878: PUSH
102879: LD_INT 0
102881: PUSH
102882: EMPTY
102883: LIST
102884: LIST
102885: LIST
102886: PUSH
102887: LD_VAR 0 1
102891: PUSH
102892: LD_INT 4
102894: PLUS
102895: PUSH
102896: LD_VAR 0 2
102900: PUSH
102901: LD_INT 4
102903: PLUS
102904: PUSH
102905: LD_INT 5
102907: PUSH
102908: EMPTY
102909: LIST
102910: LIST
102911: LIST
102912: PUSH
102913: EMPTY
102914: LIST
102915: LIST
102916: LIST
102917: LIST
102918: LIST
102919: ST_TO_ADDR
// end ; 2 :
102920: GO 103479
102922: LD_INT 2
102924: DOUBLE
102925: EQUAL
102926: IFTRUE 102930
102928: GO 103059
102930: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102931: LD_ADDR_VAR 0 5
102935: PUSH
102936: LD_VAR 0 1
102940: PUSH
102941: LD_VAR 0 2
102945: PUSH
102946: LD_INT 3
102948: MINUS
102949: PUSH
102950: LD_INT 3
102952: PUSH
102953: EMPTY
102954: LIST
102955: LIST
102956: LIST
102957: PUSH
102958: LD_VAR 0 1
102962: PUSH
102963: LD_INT 4
102965: PLUS
102966: PUSH
102967: LD_VAR 0 2
102971: PUSH
102972: LD_INT 4
102974: PUSH
102975: EMPTY
102976: LIST
102977: LIST
102978: LIST
102979: PUSH
102980: LD_VAR 0 1
102984: PUSH
102985: LD_VAR 0 2
102989: PUSH
102990: LD_INT 4
102992: PLUS
102993: PUSH
102994: LD_INT 0
102996: PUSH
102997: EMPTY
102998: LIST
102999: LIST
103000: LIST
103001: PUSH
103002: LD_VAR 0 1
103006: PUSH
103007: LD_INT 3
103009: MINUS
103010: PUSH
103011: LD_VAR 0 2
103015: PUSH
103016: LD_INT 1
103018: PUSH
103019: EMPTY
103020: LIST
103021: LIST
103022: LIST
103023: PUSH
103024: LD_VAR 0 1
103028: PUSH
103029: LD_INT 4
103031: MINUS
103032: PUSH
103033: LD_VAR 0 2
103037: PUSH
103038: LD_INT 4
103040: MINUS
103041: PUSH
103042: LD_INT 2
103044: PUSH
103045: EMPTY
103046: LIST
103047: LIST
103048: LIST
103049: PUSH
103050: EMPTY
103051: LIST
103052: LIST
103053: LIST
103054: LIST
103055: LIST
103056: ST_TO_ADDR
// end ; 3 :
103057: GO 103479
103059: LD_INT 3
103061: DOUBLE
103062: EQUAL
103063: IFTRUE 103067
103065: GO 103200
103067: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103068: LD_ADDR_VAR 0 5
103072: PUSH
103073: LD_VAR 0 1
103077: PUSH
103078: LD_INT 3
103080: PLUS
103081: PUSH
103082: LD_VAR 0 2
103086: PUSH
103087: LD_INT 4
103089: PUSH
103090: EMPTY
103091: LIST
103092: LIST
103093: LIST
103094: PUSH
103095: LD_VAR 0 1
103099: PUSH
103100: LD_INT 4
103102: PLUS
103103: PUSH
103104: LD_VAR 0 2
103108: PUSH
103109: LD_INT 4
103111: PLUS
103112: PUSH
103113: LD_INT 5
103115: PUSH
103116: EMPTY
103117: LIST
103118: LIST
103119: LIST
103120: PUSH
103121: LD_VAR 0 1
103125: PUSH
103126: LD_INT 4
103128: MINUS
103129: PUSH
103130: LD_VAR 0 2
103134: PUSH
103135: LD_INT 1
103137: PUSH
103138: EMPTY
103139: LIST
103140: LIST
103141: LIST
103142: PUSH
103143: LD_VAR 0 1
103147: PUSH
103148: LD_VAR 0 2
103152: PUSH
103153: LD_INT 4
103155: MINUS
103156: PUSH
103157: LD_INT 3
103159: PUSH
103160: EMPTY
103161: LIST
103162: LIST
103163: LIST
103164: PUSH
103165: LD_VAR 0 1
103169: PUSH
103170: LD_INT 3
103172: MINUS
103173: PUSH
103174: LD_VAR 0 2
103178: PUSH
103179: LD_INT 3
103181: MINUS
103182: PUSH
103183: LD_INT 2
103185: PUSH
103186: EMPTY
103187: LIST
103188: LIST
103189: LIST
103190: PUSH
103191: EMPTY
103192: LIST
103193: LIST
103194: LIST
103195: LIST
103196: LIST
103197: ST_TO_ADDR
// end ; 4 :
103198: GO 103479
103200: LD_INT 4
103202: DOUBLE
103203: EQUAL
103204: IFTRUE 103208
103206: GO 103341
103208: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103209: LD_ADDR_VAR 0 5
103213: PUSH
103214: LD_VAR 0 1
103218: PUSH
103219: LD_VAR 0 2
103223: PUSH
103224: LD_INT 4
103226: PLUS
103227: PUSH
103228: LD_INT 0
103230: PUSH
103231: EMPTY
103232: LIST
103233: LIST
103234: LIST
103235: PUSH
103236: LD_VAR 0 1
103240: PUSH
103241: LD_INT 3
103243: PLUS
103244: PUSH
103245: LD_VAR 0 2
103249: PUSH
103250: LD_INT 3
103252: PLUS
103253: PUSH
103254: LD_INT 5
103256: PUSH
103257: EMPTY
103258: LIST
103259: LIST
103260: LIST
103261: PUSH
103262: LD_VAR 0 1
103266: PUSH
103267: LD_INT 4
103269: PLUS
103270: PUSH
103271: LD_VAR 0 2
103275: PUSH
103276: LD_INT 4
103278: PUSH
103279: EMPTY
103280: LIST
103281: LIST
103282: LIST
103283: PUSH
103284: LD_VAR 0 1
103288: PUSH
103289: LD_VAR 0 2
103293: PUSH
103294: LD_INT 3
103296: MINUS
103297: PUSH
103298: LD_INT 3
103300: PUSH
103301: EMPTY
103302: LIST
103303: LIST
103304: LIST
103305: PUSH
103306: LD_VAR 0 1
103310: PUSH
103311: LD_INT 4
103313: MINUS
103314: PUSH
103315: LD_VAR 0 2
103319: PUSH
103320: LD_INT 4
103322: MINUS
103323: PUSH
103324: LD_INT 2
103326: PUSH
103327: EMPTY
103328: LIST
103329: LIST
103330: LIST
103331: PUSH
103332: EMPTY
103333: LIST
103334: LIST
103335: LIST
103336: LIST
103337: LIST
103338: ST_TO_ADDR
// end ; 5 :
103339: GO 103479
103341: LD_INT 5
103343: DOUBLE
103344: EQUAL
103345: IFTRUE 103349
103347: GO 103478
103349: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103350: LD_ADDR_VAR 0 5
103354: PUSH
103355: LD_VAR 0 1
103359: PUSH
103360: LD_INT 4
103362: MINUS
103363: PUSH
103364: LD_VAR 0 2
103368: PUSH
103369: LD_INT 1
103371: PUSH
103372: EMPTY
103373: LIST
103374: LIST
103375: LIST
103376: PUSH
103377: LD_VAR 0 1
103381: PUSH
103382: LD_VAR 0 2
103386: PUSH
103387: LD_INT 4
103389: MINUS
103390: PUSH
103391: LD_INT 3
103393: PUSH
103394: EMPTY
103395: LIST
103396: LIST
103397: LIST
103398: PUSH
103399: LD_VAR 0 1
103403: PUSH
103404: LD_INT 4
103406: PLUS
103407: PUSH
103408: LD_VAR 0 2
103412: PUSH
103413: LD_INT 4
103415: PLUS
103416: PUSH
103417: LD_INT 5
103419: PUSH
103420: EMPTY
103421: LIST
103422: LIST
103423: LIST
103424: PUSH
103425: LD_VAR 0 1
103429: PUSH
103430: LD_INT 3
103432: PLUS
103433: PUSH
103434: LD_VAR 0 2
103438: PUSH
103439: LD_INT 4
103441: PUSH
103442: EMPTY
103443: LIST
103444: LIST
103445: LIST
103446: PUSH
103447: LD_VAR 0 1
103451: PUSH
103452: LD_VAR 0 2
103456: PUSH
103457: LD_INT 3
103459: PLUS
103460: PUSH
103461: LD_INT 0
103463: PUSH
103464: EMPTY
103465: LIST
103466: LIST
103467: LIST
103468: PUSH
103469: EMPTY
103470: LIST
103471: LIST
103472: LIST
103473: LIST
103474: LIST
103475: ST_TO_ADDR
// end ; end ;
103476: GO 103479
103478: POP
// result := list ;
103479: LD_ADDR_VAR 0 4
103483: PUSH
103484: LD_VAR 0 5
103488: ST_TO_ADDR
// end ;
103489: LD_VAR 0 4
103493: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103494: LD_INT 0
103496: PPUSH
103497: PPUSH
103498: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103499: LD_VAR 0 1
103503: NOT
103504: PUSH
103505: LD_VAR 0 2
103509: PUSH
103510: LD_INT 1
103512: PUSH
103513: LD_INT 2
103515: PUSH
103516: LD_INT 3
103518: PUSH
103519: LD_INT 4
103521: PUSH
103522: EMPTY
103523: LIST
103524: LIST
103525: LIST
103526: LIST
103527: IN
103528: NOT
103529: OR
103530: IFFALSE 103534
// exit ;
103532: GO 103626
// tmp := [ ] ;
103534: LD_ADDR_VAR 0 5
103538: PUSH
103539: EMPTY
103540: ST_TO_ADDR
// for i in units do
103541: LD_ADDR_VAR 0 4
103545: PUSH
103546: LD_VAR 0 1
103550: PUSH
103551: FOR_IN
103552: IFFALSE 103595
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103554: LD_ADDR_VAR 0 5
103558: PUSH
103559: LD_VAR 0 5
103563: PPUSH
103564: LD_VAR 0 5
103568: PUSH
103569: LD_INT 1
103571: PLUS
103572: PPUSH
103573: LD_VAR 0 4
103577: PPUSH
103578: LD_VAR 0 2
103582: PPUSH
103583: CALL_OW 259
103587: PPUSH
103588: CALL_OW 2
103592: ST_TO_ADDR
103593: GO 103551
103595: POP
103596: POP
// if not tmp then
103597: LD_VAR 0 5
103601: NOT
103602: IFFALSE 103606
// exit ;
103604: GO 103626
// result := SortListByListDesc ( units , tmp ) ;
103606: LD_ADDR_VAR 0 3
103610: PUSH
103611: LD_VAR 0 1
103615: PPUSH
103616: LD_VAR 0 5
103620: PPUSH
103621: CALL_OW 77
103625: ST_TO_ADDR
// end ;
103626: LD_VAR 0 3
103630: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103631: LD_INT 0
103633: PPUSH
103634: PPUSH
103635: PPUSH
// result := false ;
103636: LD_ADDR_VAR 0 3
103640: PUSH
103641: LD_INT 0
103643: ST_TO_ADDR
// x := GetX ( building ) ;
103644: LD_ADDR_VAR 0 4
103648: PUSH
103649: LD_VAR 0 2
103653: PPUSH
103654: CALL_OW 250
103658: ST_TO_ADDR
// y := GetY ( building ) ;
103659: LD_ADDR_VAR 0 5
103663: PUSH
103664: LD_VAR 0 2
103668: PPUSH
103669: CALL_OW 251
103673: ST_TO_ADDR
// if not building or not x or not y then
103674: LD_VAR 0 2
103678: NOT
103679: PUSH
103680: LD_VAR 0 4
103684: NOT
103685: OR
103686: PUSH
103687: LD_VAR 0 5
103691: NOT
103692: OR
103693: IFFALSE 103697
// exit ;
103695: GO 103789
// if GetTaskList ( unit ) then
103697: LD_VAR 0 1
103701: PPUSH
103702: CALL_OW 437
103706: IFFALSE 103789
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103708: LD_STRING e
103710: PUSH
103711: LD_VAR 0 1
103715: PPUSH
103716: CALL_OW 437
103720: PUSH
103721: LD_INT 1
103723: ARRAY
103724: PUSH
103725: LD_INT 1
103727: ARRAY
103728: EQUAL
103729: PUSH
103730: LD_VAR 0 4
103734: PUSH
103735: LD_VAR 0 1
103739: PPUSH
103740: CALL_OW 437
103744: PUSH
103745: LD_INT 1
103747: ARRAY
103748: PUSH
103749: LD_INT 2
103751: ARRAY
103752: EQUAL
103753: AND
103754: PUSH
103755: LD_VAR 0 5
103759: PUSH
103760: LD_VAR 0 1
103764: PPUSH
103765: CALL_OW 437
103769: PUSH
103770: LD_INT 1
103772: ARRAY
103773: PUSH
103774: LD_INT 3
103776: ARRAY
103777: EQUAL
103778: AND
103779: IFFALSE 103789
// result := true end ;
103781: LD_ADDR_VAR 0 3
103785: PUSH
103786: LD_INT 1
103788: ST_TO_ADDR
// end ;
103789: LD_VAR 0 3
103793: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103794: LD_INT 0
103796: PPUSH
// result := false ;
103797: LD_ADDR_VAR 0 4
103801: PUSH
103802: LD_INT 0
103804: ST_TO_ADDR
// if GetTaskList ( unit ) then
103805: LD_VAR 0 1
103809: PPUSH
103810: CALL_OW 437
103814: IFFALSE 103897
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103816: LD_STRING M
103818: PUSH
103819: LD_VAR 0 1
103823: PPUSH
103824: CALL_OW 437
103828: PUSH
103829: LD_INT 1
103831: ARRAY
103832: PUSH
103833: LD_INT 1
103835: ARRAY
103836: EQUAL
103837: PUSH
103838: LD_VAR 0 2
103842: PUSH
103843: LD_VAR 0 1
103847: PPUSH
103848: CALL_OW 437
103852: PUSH
103853: LD_INT 1
103855: ARRAY
103856: PUSH
103857: LD_INT 2
103859: ARRAY
103860: EQUAL
103861: AND
103862: PUSH
103863: LD_VAR 0 3
103867: PUSH
103868: LD_VAR 0 1
103872: PPUSH
103873: CALL_OW 437
103877: PUSH
103878: LD_INT 1
103880: ARRAY
103881: PUSH
103882: LD_INT 3
103884: ARRAY
103885: EQUAL
103886: AND
103887: IFFALSE 103897
// result := true ;
103889: LD_ADDR_VAR 0 4
103893: PUSH
103894: LD_INT 1
103896: ST_TO_ADDR
// end ; end ;
103897: LD_VAR 0 4
103901: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103902: LD_INT 0
103904: PPUSH
103905: PPUSH
103906: PPUSH
103907: PPUSH
// if not unit or not area then
103908: LD_VAR 0 1
103912: NOT
103913: PUSH
103914: LD_VAR 0 2
103918: NOT
103919: OR
103920: IFFALSE 103924
// exit ;
103922: GO 104088
// tmp := AreaToList ( area , i ) ;
103924: LD_ADDR_VAR 0 6
103928: PUSH
103929: LD_VAR 0 2
103933: PPUSH
103934: LD_VAR 0 5
103938: PPUSH
103939: CALL_OW 517
103943: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103944: LD_ADDR_VAR 0 5
103948: PUSH
103949: DOUBLE
103950: LD_INT 1
103952: DEC
103953: ST_TO_ADDR
103954: LD_VAR 0 6
103958: PUSH
103959: LD_INT 1
103961: ARRAY
103962: PUSH
103963: FOR_TO
103964: IFFALSE 104086
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103966: LD_ADDR_VAR 0 7
103970: PUSH
103971: LD_VAR 0 6
103975: PUSH
103976: LD_INT 1
103978: ARRAY
103979: PUSH
103980: LD_VAR 0 5
103984: ARRAY
103985: PUSH
103986: LD_VAR 0 6
103990: PUSH
103991: LD_INT 2
103993: ARRAY
103994: PUSH
103995: LD_VAR 0 5
103999: ARRAY
104000: PUSH
104001: EMPTY
104002: LIST
104003: LIST
104004: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
104005: LD_VAR 0 7
104009: PUSH
104010: LD_INT 1
104012: ARRAY
104013: PPUSH
104014: LD_VAR 0 7
104018: PUSH
104019: LD_INT 2
104021: ARRAY
104022: PPUSH
104023: CALL_OW 428
104027: PUSH
104028: LD_INT 0
104030: EQUAL
104031: IFFALSE 104084
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104033: LD_VAR 0 1
104037: PPUSH
104038: LD_VAR 0 7
104042: PUSH
104043: LD_INT 1
104045: ARRAY
104046: PPUSH
104047: LD_VAR 0 7
104051: PUSH
104052: LD_INT 2
104054: ARRAY
104055: PPUSH
104056: LD_VAR 0 3
104060: PPUSH
104061: CALL_OW 48
// result := IsPlaced ( unit ) ;
104065: LD_ADDR_VAR 0 4
104069: PUSH
104070: LD_VAR 0 1
104074: PPUSH
104075: CALL_OW 305
104079: ST_TO_ADDR
// exit ;
104080: POP
104081: POP
104082: GO 104088
// end ; end ;
104084: GO 103963
104086: POP
104087: POP
// end ;
104088: LD_VAR 0 4
104092: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104093: LD_INT 0
104095: PPUSH
104096: PPUSH
104097: PPUSH
// if not side or side > 8 then
104098: LD_VAR 0 1
104102: NOT
104103: PUSH
104104: LD_VAR 0 1
104108: PUSH
104109: LD_INT 8
104111: GREATER
104112: OR
104113: IFFALSE 104117
// exit ;
104115: GO 104304
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104117: LD_ADDR_VAR 0 4
104121: PUSH
104122: LD_INT 22
104124: PUSH
104125: LD_VAR 0 1
104129: PUSH
104130: EMPTY
104131: LIST
104132: LIST
104133: PUSH
104134: LD_INT 21
104136: PUSH
104137: LD_INT 3
104139: PUSH
104140: EMPTY
104141: LIST
104142: LIST
104143: PUSH
104144: EMPTY
104145: LIST
104146: LIST
104147: PPUSH
104148: CALL_OW 69
104152: ST_TO_ADDR
// if not tmp then
104153: LD_VAR 0 4
104157: NOT
104158: IFFALSE 104162
// exit ;
104160: GO 104304
// enable_addtolog := true ;
104162: LD_ADDR_OWVAR 81
104166: PUSH
104167: LD_INT 1
104169: ST_TO_ADDR
// AddToLog ( [ ) ;
104170: LD_STRING [
104172: PPUSH
104173: CALL_OW 561
// for i in tmp do
104177: LD_ADDR_VAR 0 3
104181: PUSH
104182: LD_VAR 0 4
104186: PUSH
104187: FOR_IN
104188: IFFALSE 104295
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104190: LD_STRING [
104192: PUSH
104193: LD_VAR 0 3
104197: PPUSH
104198: CALL_OW 266
104202: STR
104203: PUSH
104204: LD_STRING , 
104206: STR
104207: PUSH
104208: LD_VAR 0 3
104212: PPUSH
104213: CALL_OW 250
104217: STR
104218: PUSH
104219: LD_STRING , 
104221: STR
104222: PUSH
104223: LD_VAR 0 3
104227: PPUSH
104228: CALL_OW 251
104232: STR
104233: PUSH
104234: LD_STRING , 
104236: STR
104237: PUSH
104238: LD_VAR 0 3
104242: PPUSH
104243: CALL_OW 254
104247: STR
104248: PUSH
104249: LD_STRING , 
104251: STR
104252: PUSH
104253: LD_VAR 0 3
104257: PPUSH
104258: LD_INT 1
104260: PPUSH
104261: CALL_OW 268
104265: STR
104266: PUSH
104267: LD_STRING , 
104269: STR
104270: PUSH
104271: LD_VAR 0 3
104275: PPUSH
104276: LD_INT 2
104278: PPUSH
104279: CALL_OW 268
104283: STR
104284: PUSH
104285: LD_STRING ],
104287: STR
104288: PPUSH
104289: CALL_OW 561
// end ;
104293: GO 104187
104295: POP
104296: POP
// AddToLog ( ]; ) ;
104297: LD_STRING ];
104299: PPUSH
104300: CALL_OW 561
// end ;
104304: LD_VAR 0 2
104308: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104309: LD_INT 0
104311: PPUSH
104312: PPUSH
104313: PPUSH
104314: PPUSH
104315: PPUSH
// if not area or not rate or not max then
104316: LD_VAR 0 1
104320: NOT
104321: PUSH
104322: LD_VAR 0 2
104326: NOT
104327: OR
104328: PUSH
104329: LD_VAR 0 4
104333: NOT
104334: OR
104335: IFFALSE 104339
// exit ;
104337: GO 104528
// while 1 do
104339: LD_INT 1
104341: IFFALSE 104528
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104343: LD_ADDR_VAR 0 9
104347: PUSH
104348: LD_VAR 0 1
104352: PPUSH
104353: LD_INT 1
104355: PPUSH
104356: CALL_OW 287
104360: PUSH
104361: LD_INT 10
104363: MUL
104364: ST_TO_ADDR
// r := rate / 10 ;
104365: LD_ADDR_VAR 0 7
104369: PUSH
104370: LD_VAR 0 2
104374: PUSH
104375: LD_INT 10
104377: DIVREAL
104378: ST_TO_ADDR
// time := 1 1$00 ;
104379: LD_ADDR_VAR 0 8
104383: PUSH
104384: LD_INT 2100
104386: ST_TO_ADDR
// if amount < min then
104387: LD_VAR 0 9
104391: PUSH
104392: LD_VAR 0 3
104396: LESS
104397: IFFALSE 104415
// r := r * 2 else
104399: LD_ADDR_VAR 0 7
104403: PUSH
104404: LD_VAR 0 7
104408: PUSH
104409: LD_INT 2
104411: MUL
104412: ST_TO_ADDR
104413: GO 104441
// if amount > max then
104415: LD_VAR 0 9
104419: PUSH
104420: LD_VAR 0 4
104424: GREATER
104425: IFFALSE 104441
// r := r / 2 ;
104427: LD_ADDR_VAR 0 7
104431: PUSH
104432: LD_VAR 0 7
104436: PUSH
104437: LD_INT 2
104439: DIVREAL
104440: ST_TO_ADDR
// time := time / r ;
104441: LD_ADDR_VAR 0 8
104445: PUSH
104446: LD_VAR 0 8
104450: PUSH
104451: LD_VAR 0 7
104455: DIVREAL
104456: ST_TO_ADDR
// if time < 0 then
104457: LD_VAR 0 8
104461: PUSH
104462: LD_INT 0
104464: LESS
104465: IFFALSE 104482
// time := time * - 1 ;
104467: LD_ADDR_VAR 0 8
104471: PUSH
104472: LD_VAR 0 8
104476: PUSH
104477: LD_INT 1
104479: NEG
104480: MUL
104481: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104482: LD_VAR 0 8
104486: PUSH
104487: LD_INT 35
104489: PPUSH
104490: LD_INT 875
104492: PPUSH
104493: CALL_OW 12
104497: PLUS
104498: PPUSH
104499: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104503: LD_INT 1
104505: PPUSH
104506: LD_INT 5
104508: PPUSH
104509: CALL_OW 12
104513: PPUSH
104514: LD_VAR 0 1
104518: PPUSH
104519: LD_INT 1
104521: PPUSH
104522: CALL_OW 55
// end ;
104526: GO 104339
// end ;
104528: LD_VAR 0 5
104532: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104533: LD_INT 0
104535: PPUSH
104536: PPUSH
104537: PPUSH
104538: PPUSH
104539: PPUSH
104540: PPUSH
104541: PPUSH
104542: PPUSH
// if not turrets or not factories then
104543: LD_VAR 0 1
104547: NOT
104548: PUSH
104549: LD_VAR 0 2
104553: NOT
104554: OR
104555: IFFALSE 104559
// exit ;
104557: GO 104866
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104559: LD_ADDR_VAR 0 10
104563: PUSH
104564: LD_INT 5
104566: PUSH
104567: LD_INT 6
104569: PUSH
104570: EMPTY
104571: LIST
104572: LIST
104573: PUSH
104574: LD_INT 2
104576: PUSH
104577: LD_INT 4
104579: PUSH
104580: EMPTY
104581: LIST
104582: LIST
104583: PUSH
104584: LD_INT 3
104586: PUSH
104587: LD_INT 5
104589: PUSH
104590: EMPTY
104591: LIST
104592: LIST
104593: PUSH
104594: EMPTY
104595: LIST
104596: LIST
104597: LIST
104598: PUSH
104599: LD_INT 24
104601: PUSH
104602: LD_INT 25
104604: PUSH
104605: EMPTY
104606: LIST
104607: LIST
104608: PUSH
104609: LD_INT 23
104611: PUSH
104612: LD_INT 27
104614: PUSH
104615: EMPTY
104616: LIST
104617: LIST
104618: PUSH
104619: EMPTY
104620: LIST
104621: LIST
104622: PUSH
104623: LD_INT 42
104625: PUSH
104626: LD_INT 43
104628: PUSH
104629: EMPTY
104630: LIST
104631: LIST
104632: PUSH
104633: LD_INT 44
104635: PUSH
104636: LD_INT 46
104638: PUSH
104639: EMPTY
104640: LIST
104641: LIST
104642: PUSH
104643: LD_INT 45
104645: PUSH
104646: LD_INT 47
104648: PUSH
104649: EMPTY
104650: LIST
104651: LIST
104652: PUSH
104653: EMPTY
104654: LIST
104655: LIST
104656: LIST
104657: PUSH
104658: EMPTY
104659: LIST
104660: LIST
104661: LIST
104662: ST_TO_ADDR
// result := [ ] ;
104663: LD_ADDR_VAR 0 3
104667: PUSH
104668: EMPTY
104669: ST_TO_ADDR
// for i in turrets do
104670: LD_ADDR_VAR 0 4
104674: PUSH
104675: LD_VAR 0 1
104679: PUSH
104680: FOR_IN
104681: IFFALSE 104864
// begin nat := GetNation ( i ) ;
104683: LD_ADDR_VAR 0 7
104687: PUSH
104688: LD_VAR 0 4
104692: PPUSH
104693: CALL_OW 248
104697: ST_TO_ADDR
// weapon := 0 ;
104698: LD_ADDR_VAR 0 8
104702: PUSH
104703: LD_INT 0
104705: ST_TO_ADDR
// if not nat then
104706: LD_VAR 0 7
104710: NOT
104711: IFFALSE 104715
// continue ;
104713: GO 104680
// for j in list [ nat ] do
104715: LD_ADDR_VAR 0 5
104719: PUSH
104720: LD_VAR 0 10
104724: PUSH
104725: LD_VAR 0 7
104729: ARRAY
104730: PUSH
104731: FOR_IN
104732: IFFALSE 104773
// if GetBWeapon ( i ) = j [ 1 ] then
104734: LD_VAR 0 4
104738: PPUSH
104739: CALL_OW 269
104743: PUSH
104744: LD_VAR 0 5
104748: PUSH
104749: LD_INT 1
104751: ARRAY
104752: EQUAL
104753: IFFALSE 104771
// begin weapon := j [ 2 ] ;
104755: LD_ADDR_VAR 0 8
104759: PUSH
104760: LD_VAR 0 5
104764: PUSH
104765: LD_INT 2
104767: ARRAY
104768: ST_TO_ADDR
// break ;
104769: GO 104773
// end ;
104771: GO 104731
104773: POP
104774: POP
// if not weapon then
104775: LD_VAR 0 8
104779: NOT
104780: IFFALSE 104784
// continue ;
104782: GO 104680
// for k in factories do
104784: LD_ADDR_VAR 0 6
104788: PUSH
104789: LD_VAR 0 2
104793: PUSH
104794: FOR_IN
104795: IFFALSE 104860
// begin weapons := AvailableWeaponList ( k ) ;
104797: LD_ADDR_VAR 0 9
104801: PUSH
104802: LD_VAR 0 6
104806: PPUSH
104807: CALL_OW 478
104811: ST_TO_ADDR
// if not weapons then
104812: LD_VAR 0 9
104816: NOT
104817: IFFALSE 104821
// continue ;
104819: GO 104794
// if weapon in weapons then
104821: LD_VAR 0 8
104825: PUSH
104826: LD_VAR 0 9
104830: IN
104831: IFFALSE 104858
// begin result := [ i , weapon ] ;
104833: LD_ADDR_VAR 0 3
104837: PUSH
104838: LD_VAR 0 4
104842: PUSH
104843: LD_VAR 0 8
104847: PUSH
104848: EMPTY
104849: LIST
104850: LIST
104851: ST_TO_ADDR
// exit ;
104852: POP
104853: POP
104854: POP
104855: POP
104856: GO 104866
// end ; end ;
104858: GO 104794
104860: POP
104861: POP
// end ;
104862: GO 104680
104864: POP
104865: POP
// end ;
104866: LD_VAR 0 3
104870: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104871: LD_INT 0
104873: PPUSH
// if not side or side > 8 then
104874: LD_VAR 0 3
104878: NOT
104879: PUSH
104880: LD_VAR 0 3
104884: PUSH
104885: LD_INT 8
104887: GREATER
104888: OR
104889: IFFALSE 104893
// exit ;
104891: GO 104952
// if not range then
104893: LD_VAR 0 4
104897: NOT
104898: IFFALSE 104909
// range := - 12 ;
104900: LD_ADDR_VAR 0 4
104904: PUSH
104905: LD_INT 12
104907: NEG
104908: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104909: LD_VAR 0 1
104913: PPUSH
104914: LD_VAR 0 2
104918: PPUSH
104919: LD_VAR 0 3
104923: PPUSH
104924: LD_VAR 0 4
104928: PPUSH
104929: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104933: LD_VAR 0 1
104937: PPUSH
104938: LD_VAR 0 2
104942: PPUSH
104943: LD_VAR 0 3
104947: PPUSH
104948: CALL_OW 331
// end ;
104952: LD_VAR 0 5
104956: RET
// export function Video ( mode ) ; begin
104957: LD_INT 0
104959: PPUSH
// ingame_video = mode ;
104960: LD_ADDR_OWVAR 52
104964: PUSH
104965: LD_VAR 0 1
104969: ST_TO_ADDR
// interface_hidden = mode ;
104970: LD_ADDR_OWVAR 54
104974: PUSH
104975: LD_VAR 0 1
104979: ST_TO_ADDR
// end ;
104980: LD_VAR 0 2
104984: RET
// export function Join ( array , element ) ; begin
104985: LD_INT 0
104987: PPUSH
// result := Replace ( array , array + 1 , element ) ;
104988: LD_ADDR_VAR 0 3
104992: PUSH
104993: LD_VAR 0 1
104997: PPUSH
104998: LD_VAR 0 1
105002: PUSH
105003: LD_INT 1
105005: PLUS
105006: PPUSH
105007: LD_VAR 0 2
105011: PPUSH
105012: CALL_OW 1
105016: ST_TO_ADDR
// end ;
105017: LD_VAR 0 3
105021: RET
// export function JoinUnion ( array , element ) ; begin
105022: LD_INT 0
105024: PPUSH
// result := array union element ;
105025: LD_ADDR_VAR 0 3
105029: PUSH
105030: LD_VAR 0 1
105034: PUSH
105035: LD_VAR 0 2
105039: UNION
105040: ST_TO_ADDR
// end ;
105041: LD_VAR 0 3
105045: RET
// export function GetBehemoths ( side ) ; begin
105046: LD_INT 0
105048: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
105049: LD_ADDR_VAR 0 2
105053: PUSH
105054: LD_INT 22
105056: PUSH
105057: LD_VAR 0 1
105061: PUSH
105062: EMPTY
105063: LIST
105064: LIST
105065: PUSH
105066: LD_INT 31
105068: PUSH
105069: LD_INT 25
105071: PUSH
105072: EMPTY
105073: LIST
105074: LIST
105075: PUSH
105076: EMPTY
105077: LIST
105078: LIST
105079: PPUSH
105080: CALL_OW 69
105084: ST_TO_ADDR
// end ;
105085: LD_VAR 0 2
105089: RET
// export function Shuffle ( array ) ; var i , index ; begin
105090: LD_INT 0
105092: PPUSH
105093: PPUSH
105094: PPUSH
// result := [ ] ;
105095: LD_ADDR_VAR 0 2
105099: PUSH
105100: EMPTY
105101: ST_TO_ADDR
// if not array then
105102: LD_VAR 0 1
105106: NOT
105107: IFFALSE 105111
// exit ;
105109: GO 105210
// Randomize ;
105111: CALL_OW 10
// for i = array downto 1 do
105115: LD_ADDR_VAR 0 3
105119: PUSH
105120: DOUBLE
105121: LD_VAR 0 1
105125: INC
105126: ST_TO_ADDR
105127: LD_INT 1
105129: PUSH
105130: FOR_DOWNTO
105131: IFFALSE 105208
// begin index := rand ( 1 , array ) ;
105133: LD_ADDR_VAR 0 4
105137: PUSH
105138: LD_INT 1
105140: PPUSH
105141: LD_VAR 0 1
105145: PPUSH
105146: CALL_OW 12
105150: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105151: LD_ADDR_VAR 0 2
105155: PUSH
105156: LD_VAR 0 2
105160: PPUSH
105161: LD_VAR 0 2
105165: PUSH
105166: LD_INT 1
105168: PLUS
105169: PPUSH
105170: LD_VAR 0 1
105174: PUSH
105175: LD_VAR 0 4
105179: ARRAY
105180: PPUSH
105181: CALL_OW 2
105185: ST_TO_ADDR
// array := Delete ( array , index ) ;
105186: LD_ADDR_VAR 0 1
105190: PUSH
105191: LD_VAR 0 1
105195: PPUSH
105196: LD_VAR 0 4
105200: PPUSH
105201: CALL_OW 3
105205: ST_TO_ADDR
// end ;
105206: GO 105130
105208: POP
105209: POP
// end ;
105210: LD_VAR 0 2
105214: RET
// export function GetBaseMaterials ( base ) ; begin
105215: LD_INT 0
105217: PPUSH
// result := [ 0 , 0 , 0 ] ;
105218: LD_ADDR_VAR 0 2
105222: PUSH
105223: LD_INT 0
105225: PUSH
105226: LD_INT 0
105228: PUSH
105229: LD_INT 0
105231: PUSH
105232: EMPTY
105233: LIST
105234: LIST
105235: LIST
105236: ST_TO_ADDR
// if not base then
105237: LD_VAR 0 1
105241: NOT
105242: IFFALSE 105246
// exit ;
105244: GO 105295
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
105246: LD_ADDR_VAR 0 2
105250: PUSH
105251: LD_VAR 0 1
105255: PPUSH
105256: LD_INT 1
105258: PPUSH
105259: CALL_OW 275
105263: PUSH
105264: LD_VAR 0 1
105268: PPUSH
105269: LD_INT 2
105271: PPUSH
105272: CALL_OW 275
105276: PUSH
105277: LD_VAR 0 1
105281: PPUSH
105282: LD_INT 3
105284: PPUSH
105285: CALL_OW 275
105289: PUSH
105290: EMPTY
105291: LIST
105292: LIST
105293: LIST
105294: ST_TO_ADDR
// end ;
105295: LD_VAR 0 2
105299: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
105300: LD_INT 0
105302: PPUSH
105303: PPUSH
// result := array ;
105304: LD_ADDR_VAR 0 3
105308: PUSH
105309: LD_VAR 0 1
105313: ST_TO_ADDR
// if size >= result then
105314: LD_VAR 0 2
105318: PUSH
105319: LD_VAR 0 3
105323: GREATEREQUAL
105324: IFFALSE 105328
// exit ;
105326: GO 105378
// if size then
105328: LD_VAR 0 2
105332: IFFALSE 105378
// for i := array downto size do
105334: LD_ADDR_VAR 0 4
105338: PUSH
105339: DOUBLE
105340: LD_VAR 0 1
105344: INC
105345: ST_TO_ADDR
105346: LD_VAR 0 2
105350: PUSH
105351: FOR_DOWNTO
105352: IFFALSE 105376
// result := Delete ( result , result ) ;
105354: LD_ADDR_VAR 0 3
105358: PUSH
105359: LD_VAR 0 3
105363: PPUSH
105364: LD_VAR 0 3
105368: PPUSH
105369: CALL_OW 3
105373: ST_TO_ADDR
105374: GO 105351
105376: POP
105377: POP
// end ;
105378: LD_VAR 0 3
105382: RET
// export function ComExit ( unit ) ; var tmp ; begin
105383: LD_INT 0
105385: PPUSH
105386: PPUSH
// if not IsInUnit ( unit ) then
105387: LD_VAR 0 1
105391: PPUSH
105392: CALL_OW 310
105396: NOT
105397: IFFALSE 105401
// exit ;
105399: GO 105461
// tmp := IsInUnit ( unit ) ;
105401: LD_ADDR_VAR 0 3
105405: PUSH
105406: LD_VAR 0 1
105410: PPUSH
105411: CALL_OW 310
105415: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105416: LD_VAR 0 3
105420: PPUSH
105421: CALL_OW 247
105425: PUSH
105426: LD_INT 2
105428: EQUAL
105429: IFFALSE 105442
// ComExitVehicle ( unit ) else
105431: LD_VAR 0 1
105435: PPUSH
105436: CALL_OW 121
105440: GO 105451
// ComExitBuilding ( unit ) ;
105442: LD_VAR 0 1
105446: PPUSH
105447: CALL_OW 122
// result := tmp ;
105451: LD_ADDR_VAR 0 2
105455: PUSH
105456: LD_VAR 0 3
105460: ST_TO_ADDR
// end ;
105461: LD_VAR 0 2
105465: RET
// export function ComExitAll ( units ) ; var i ; begin
105466: LD_INT 0
105468: PPUSH
105469: PPUSH
// if not units then
105470: LD_VAR 0 1
105474: NOT
105475: IFFALSE 105479
// exit ;
105477: GO 105505
// for i in units do
105479: LD_ADDR_VAR 0 3
105483: PUSH
105484: LD_VAR 0 1
105488: PUSH
105489: FOR_IN
105490: IFFALSE 105503
// ComExit ( i ) ;
105492: LD_VAR 0 3
105496: PPUSH
105497: CALL 105383 0 1
105501: GO 105489
105503: POP
105504: POP
// end ;
105505: LD_VAR 0 2
105509: RET
// export function ResetHc ; begin
105510: LD_INT 0
105512: PPUSH
// InitHc ;
105513: CALL_OW 19
// hc_importance := 0 ;
105517: LD_ADDR_OWVAR 32
105521: PUSH
105522: LD_INT 0
105524: ST_TO_ADDR
// end ;
105525: LD_VAR 0 1
105529: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105530: LD_INT 0
105532: PPUSH
105533: PPUSH
105534: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105535: LD_ADDR_VAR 0 6
105539: PUSH
105540: LD_VAR 0 1
105544: PUSH
105545: LD_VAR 0 3
105549: PLUS
105550: PUSH
105551: LD_INT 2
105553: DIV
105554: ST_TO_ADDR
// if _x < 0 then
105555: LD_VAR 0 6
105559: PUSH
105560: LD_INT 0
105562: LESS
105563: IFFALSE 105580
// _x := _x * - 1 ;
105565: LD_ADDR_VAR 0 6
105569: PUSH
105570: LD_VAR 0 6
105574: PUSH
105575: LD_INT 1
105577: NEG
105578: MUL
105579: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105580: LD_ADDR_VAR 0 7
105584: PUSH
105585: LD_VAR 0 2
105589: PUSH
105590: LD_VAR 0 4
105594: PLUS
105595: PUSH
105596: LD_INT 2
105598: DIV
105599: ST_TO_ADDR
// if _y < 0 then
105600: LD_VAR 0 7
105604: PUSH
105605: LD_INT 0
105607: LESS
105608: IFFALSE 105625
// _y := _y * - 1 ;
105610: LD_ADDR_VAR 0 7
105614: PUSH
105615: LD_VAR 0 7
105619: PUSH
105620: LD_INT 1
105622: NEG
105623: MUL
105624: ST_TO_ADDR
// result := [ _x , _y ] ;
105625: LD_ADDR_VAR 0 5
105629: PUSH
105630: LD_VAR 0 6
105634: PUSH
105635: LD_VAR 0 7
105639: PUSH
105640: EMPTY
105641: LIST
105642: LIST
105643: ST_TO_ADDR
// end ;
105644: LD_VAR 0 5
105648: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105649: LD_INT 0
105651: PPUSH
105652: PPUSH
105653: PPUSH
105654: PPUSH
// task := GetTaskList ( unit ) ;
105655: LD_ADDR_VAR 0 7
105659: PUSH
105660: LD_VAR 0 1
105664: PPUSH
105665: CALL_OW 437
105669: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105670: LD_VAR 0 7
105674: NOT
105675: PUSH
105676: LD_VAR 0 1
105680: PPUSH
105681: LD_VAR 0 2
105685: PPUSH
105686: CALL_OW 308
105690: NOT
105691: AND
105692: IFFALSE 105696
// exit ;
105694: GO 105814
// if IsInArea ( unit , area ) then
105696: LD_VAR 0 1
105700: PPUSH
105701: LD_VAR 0 2
105705: PPUSH
105706: CALL_OW 308
105710: IFFALSE 105728
// begin ComMoveToArea ( unit , goAway ) ;
105712: LD_VAR 0 1
105716: PPUSH
105717: LD_VAR 0 3
105721: PPUSH
105722: CALL_OW 113
// exit ;
105726: GO 105814
// end ; if task [ 1 ] [ 1 ] <> M then
105728: LD_VAR 0 7
105732: PUSH
105733: LD_INT 1
105735: ARRAY
105736: PUSH
105737: LD_INT 1
105739: ARRAY
105740: PUSH
105741: LD_STRING M
105743: NONEQUAL
105744: IFFALSE 105748
// exit ;
105746: GO 105814
// x := task [ 1 ] [ 2 ] ;
105748: LD_ADDR_VAR 0 5
105752: PUSH
105753: LD_VAR 0 7
105757: PUSH
105758: LD_INT 1
105760: ARRAY
105761: PUSH
105762: LD_INT 2
105764: ARRAY
105765: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105766: LD_ADDR_VAR 0 6
105770: PUSH
105771: LD_VAR 0 7
105775: PUSH
105776: LD_INT 1
105778: ARRAY
105779: PUSH
105780: LD_INT 3
105782: ARRAY
105783: ST_TO_ADDR
// if InArea ( x , y , area ) then
105784: LD_VAR 0 5
105788: PPUSH
105789: LD_VAR 0 6
105793: PPUSH
105794: LD_VAR 0 2
105798: PPUSH
105799: CALL_OW 309
105803: IFFALSE 105814
// ComStop ( unit ) ;
105805: LD_VAR 0 1
105809: PPUSH
105810: CALL_OW 141
// end ;
105814: LD_VAR 0 4
105818: RET
// export function Abs ( value ) ; begin
105819: LD_INT 0
105821: PPUSH
// result := value ;
105822: LD_ADDR_VAR 0 2
105826: PUSH
105827: LD_VAR 0 1
105831: ST_TO_ADDR
// if value < 0 then
105832: LD_VAR 0 1
105836: PUSH
105837: LD_INT 0
105839: LESS
105840: IFFALSE 105857
// result := value * - 1 ;
105842: LD_ADDR_VAR 0 2
105846: PUSH
105847: LD_VAR 0 1
105851: PUSH
105852: LD_INT 1
105854: NEG
105855: MUL
105856: ST_TO_ADDR
// end ;
105857: LD_VAR 0 2
105861: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105862: LD_INT 0
105864: PPUSH
105865: PPUSH
105866: PPUSH
105867: PPUSH
105868: PPUSH
105869: PPUSH
105870: PPUSH
105871: PPUSH
// if not unit or not building then
105872: LD_VAR 0 1
105876: NOT
105877: PUSH
105878: LD_VAR 0 2
105882: NOT
105883: OR
105884: IFFALSE 105888
// exit ;
105886: GO 106114
// x := GetX ( building ) ;
105888: LD_ADDR_VAR 0 4
105892: PUSH
105893: LD_VAR 0 2
105897: PPUSH
105898: CALL_OW 250
105902: ST_TO_ADDR
// y := GetY ( building ) ;
105903: LD_ADDR_VAR 0 6
105907: PUSH
105908: LD_VAR 0 2
105912: PPUSH
105913: CALL_OW 251
105917: ST_TO_ADDR
// d := GetDir ( building ) ;
105918: LD_ADDR_VAR 0 8
105922: PUSH
105923: LD_VAR 0 2
105927: PPUSH
105928: CALL_OW 254
105932: ST_TO_ADDR
// r := 4 ;
105933: LD_ADDR_VAR 0 9
105937: PUSH
105938: LD_INT 4
105940: ST_TO_ADDR
// for i := 1 to 5 do
105941: LD_ADDR_VAR 0 10
105945: PUSH
105946: DOUBLE
105947: LD_INT 1
105949: DEC
105950: ST_TO_ADDR
105951: LD_INT 5
105953: PUSH
105954: FOR_TO
105955: IFFALSE 106112
// begin _x := ShiftX ( x , d , r + i ) ;
105957: LD_ADDR_VAR 0 5
105961: PUSH
105962: LD_VAR 0 4
105966: PPUSH
105967: LD_VAR 0 8
105971: PPUSH
105972: LD_VAR 0 9
105976: PUSH
105977: LD_VAR 0 10
105981: PLUS
105982: PPUSH
105983: CALL_OW 272
105987: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
105988: LD_ADDR_VAR 0 7
105992: PUSH
105993: LD_VAR 0 6
105997: PPUSH
105998: LD_VAR 0 8
106002: PPUSH
106003: LD_VAR 0 9
106007: PUSH
106008: LD_VAR 0 10
106012: PLUS
106013: PPUSH
106014: CALL_OW 273
106018: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
106019: LD_VAR 0 5
106023: PPUSH
106024: LD_VAR 0 7
106028: PPUSH
106029: CALL_OW 488
106033: PUSH
106034: LD_VAR 0 5
106038: PPUSH
106039: LD_VAR 0 7
106043: PPUSH
106044: CALL_OW 428
106048: PPUSH
106049: CALL_OW 247
106053: PUSH
106054: LD_INT 3
106056: PUSH
106057: LD_INT 2
106059: PUSH
106060: EMPTY
106061: LIST
106062: LIST
106063: IN
106064: NOT
106065: AND
106066: IFFALSE 106110
// begin ComMoveXY ( unit , _x , _y ) ;
106068: LD_VAR 0 1
106072: PPUSH
106073: LD_VAR 0 5
106077: PPUSH
106078: LD_VAR 0 7
106082: PPUSH
106083: CALL_OW 111
// result := [ _x , _y ] ;
106087: LD_ADDR_VAR 0 3
106091: PUSH
106092: LD_VAR 0 5
106096: PUSH
106097: LD_VAR 0 7
106101: PUSH
106102: EMPTY
106103: LIST
106104: LIST
106105: ST_TO_ADDR
// exit ;
106106: POP
106107: POP
106108: GO 106114
// end ; end ;
106110: GO 105954
106112: POP
106113: POP
// end ;
106114: LD_VAR 0 3
106118: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
106119: LD_INT 0
106121: PPUSH
106122: PPUSH
106123: PPUSH
// result := 0 ;
106124: LD_ADDR_VAR 0 3
106128: PUSH
106129: LD_INT 0
106131: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
106132: LD_VAR 0 1
106136: PUSH
106137: LD_INT 0
106139: LESS
106140: PUSH
106141: LD_VAR 0 1
106145: PUSH
106146: LD_INT 8
106148: GREATER
106149: OR
106150: PUSH
106151: LD_VAR 0 2
106155: PUSH
106156: LD_INT 0
106158: LESS
106159: OR
106160: PUSH
106161: LD_VAR 0 2
106165: PUSH
106166: LD_INT 8
106168: GREATER
106169: OR
106170: IFFALSE 106174
// exit ;
106172: GO 106249
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
106174: LD_ADDR_VAR 0 4
106178: PUSH
106179: LD_INT 22
106181: PUSH
106182: LD_VAR 0 2
106186: PUSH
106187: EMPTY
106188: LIST
106189: LIST
106190: PPUSH
106191: CALL_OW 69
106195: PUSH
106196: FOR_IN
106197: IFFALSE 106247
// begin un := UnitShoot ( i ) ;
106199: LD_ADDR_VAR 0 5
106203: PUSH
106204: LD_VAR 0 4
106208: PPUSH
106209: CALL_OW 504
106213: ST_TO_ADDR
// if GetSide ( un ) = side1 then
106214: LD_VAR 0 5
106218: PPUSH
106219: CALL_OW 255
106223: PUSH
106224: LD_VAR 0 1
106228: EQUAL
106229: IFFALSE 106245
// begin result := un ;
106231: LD_ADDR_VAR 0 3
106235: PUSH
106236: LD_VAR 0 5
106240: ST_TO_ADDR
// exit ;
106241: POP
106242: POP
106243: GO 106249
// end ; end ;
106245: GO 106196
106247: POP
106248: POP
// end ;
106249: LD_VAR 0 3
106253: RET
// export function GetCargoBay ( units ) ; begin
106254: LD_INT 0
106256: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
106257: LD_ADDR_VAR 0 2
106261: PUSH
106262: LD_VAR 0 1
106266: PPUSH
106267: LD_INT 2
106269: PUSH
106270: LD_INT 34
106272: PUSH
106273: LD_INT 12
106275: PUSH
106276: EMPTY
106277: LIST
106278: LIST
106279: PUSH
106280: LD_INT 34
106282: PUSH
106283: LD_INT 51
106285: PUSH
106286: EMPTY
106287: LIST
106288: LIST
106289: PUSH
106290: LD_INT 34
106292: PUSH
106293: LD_INT 32
106295: PUSH
106296: EMPTY
106297: LIST
106298: LIST
106299: PUSH
106300: LD_INT 34
106302: PUSH
106303: LD_INT 89
106305: PUSH
106306: EMPTY
106307: LIST
106308: LIST
106309: PUSH
106310: EMPTY
106311: LIST
106312: LIST
106313: LIST
106314: LIST
106315: LIST
106316: PPUSH
106317: CALL_OW 72
106321: ST_TO_ADDR
// end ;
106322: LD_VAR 0 2
106326: RET
// export function Negate ( value ) ; begin
106327: LD_INT 0
106329: PPUSH
// result := not value ;
106330: LD_ADDR_VAR 0 2
106334: PUSH
106335: LD_VAR 0 1
106339: NOT
106340: ST_TO_ADDR
// end ;
106341: LD_VAR 0 2
106345: RET
// export function Inc ( value ) ; begin
106346: LD_INT 0
106348: PPUSH
// result := value + 1 ;
106349: LD_ADDR_VAR 0 2
106353: PUSH
106354: LD_VAR 0 1
106358: PUSH
106359: LD_INT 1
106361: PLUS
106362: ST_TO_ADDR
// end ;
106363: LD_VAR 0 2
106367: RET
// export function Dec ( value ) ; begin
106368: LD_INT 0
106370: PPUSH
// result := value - 1 ;
106371: LD_ADDR_VAR 0 2
106375: PUSH
106376: LD_VAR 0 1
106380: PUSH
106381: LD_INT 1
106383: MINUS
106384: ST_TO_ADDR
// end ;
106385: LD_VAR 0 2
106389: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106390: LD_INT 0
106392: PPUSH
106393: PPUSH
106394: PPUSH
106395: PPUSH
106396: PPUSH
106397: PPUSH
106398: PPUSH
106399: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106400: LD_VAR 0 1
106404: PPUSH
106405: LD_VAR 0 2
106409: PPUSH
106410: CALL_OW 488
106414: NOT
106415: PUSH
106416: LD_VAR 0 3
106420: PPUSH
106421: LD_VAR 0 4
106425: PPUSH
106426: CALL_OW 488
106430: NOT
106431: OR
106432: IFFALSE 106445
// begin result := - 1 ;
106434: LD_ADDR_VAR 0 5
106438: PUSH
106439: LD_INT 1
106441: NEG
106442: ST_TO_ADDR
// exit ;
106443: GO 106680
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106445: LD_ADDR_VAR 0 12
106449: PUSH
106450: LD_VAR 0 1
106454: PPUSH
106455: LD_VAR 0 2
106459: PPUSH
106460: LD_VAR 0 3
106464: PPUSH
106465: LD_VAR 0 4
106469: PPUSH
106470: CALL 105530 0 4
106474: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106475: LD_ADDR_VAR 0 11
106479: PUSH
106480: LD_VAR 0 1
106484: PPUSH
106485: LD_VAR 0 2
106489: PPUSH
106490: LD_VAR 0 12
106494: PUSH
106495: LD_INT 1
106497: ARRAY
106498: PPUSH
106499: LD_VAR 0 12
106503: PUSH
106504: LD_INT 2
106506: ARRAY
106507: PPUSH
106508: CALL_OW 298
106512: ST_TO_ADDR
// distance := 9999 ;
106513: LD_ADDR_VAR 0 10
106517: PUSH
106518: LD_INT 9999
106520: ST_TO_ADDR
// for i := 0 to 5 do
106521: LD_ADDR_VAR 0 6
106525: PUSH
106526: DOUBLE
106527: LD_INT 0
106529: DEC
106530: ST_TO_ADDR
106531: LD_INT 5
106533: PUSH
106534: FOR_TO
106535: IFFALSE 106678
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106537: LD_ADDR_VAR 0 7
106541: PUSH
106542: LD_VAR 0 1
106546: PPUSH
106547: LD_VAR 0 6
106551: PPUSH
106552: LD_VAR 0 11
106556: PPUSH
106557: CALL_OW 272
106561: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106562: LD_ADDR_VAR 0 8
106566: PUSH
106567: LD_VAR 0 2
106571: PPUSH
106572: LD_VAR 0 6
106576: PPUSH
106577: LD_VAR 0 11
106581: PPUSH
106582: CALL_OW 273
106586: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106587: LD_VAR 0 7
106591: PPUSH
106592: LD_VAR 0 8
106596: PPUSH
106597: CALL_OW 488
106601: NOT
106602: IFFALSE 106606
// continue ;
106604: GO 106534
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106606: LD_ADDR_VAR 0 9
106610: PUSH
106611: LD_VAR 0 12
106615: PUSH
106616: LD_INT 1
106618: ARRAY
106619: PPUSH
106620: LD_VAR 0 12
106624: PUSH
106625: LD_INT 2
106627: ARRAY
106628: PPUSH
106629: LD_VAR 0 7
106633: PPUSH
106634: LD_VAR 0 8
106638: PPUSH
106639: CALL_OW 298
106643: ST_TO_ADDR
// if tmp < distance then
106644: LD_VAR 0 9
106648: PUSH
106649: LD_VAR 0 10
106653: LESS
106654: IFFALSE 106676
// begin result := i ;
106656: LD_ADDR_VAR 0 5
106660: PUSH
106661: LD_VAR 0 6
106665: ST_TO_ADDR
// distance := tmp ;
106666: LD_ADDR_VAR 0 10
106670: PUSH
106671: LD_VAR 0 9
106675: ST_TO_ADDR
// end ; end ;
106676: GO 106534
106678: POP
106679: POP
// end ;
106680: LD_VAR 0 5
106684: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106685: LD_INT 0
106687: PPUSH
106688: PPUSH
// if not driver or not IsInUnit ( driver ) then
106689: LD_VAR 0 1
106693: NOT
106694: PUSH
106695: LD_VAR 0 1
106699: PPUSH
106700: CALL_OW 310
106704: NOT
106705: OR
106706: IFFALSE 106710
// exit ;
106708: GO 106800
// vehicle := IsInUnit ( driver ) ;
106710: LD_ADDR_VAR 0 3
106714: PUSH
106715: LD_VAR 0 1
106719: PPUSH
106720: CALL_OW 310
106724: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106725: LD_VAR 0 1
106729: PPUSH
106730: LD_STRING \
106732: PUSH
106733: LD_INT 0
106735: PUSH
106736: LD_INT 0
106738: PUSH
106739: LD_INT 0
106741: PUSH
106742: LD_INT 0
106744: PUSH
106745: LD_INT 0
106747: PUSH
106748: LD_INT 0
106750: PUSH
106751: EMPTY
106752: LIST
106753: LIST
106754: LIST
106755: LIST
106756: LIST
106757: LIST
106758: LIST
106759: PUSH
106760: LD_STRING E
106762: PUSH
106763: LD_INT 0
106765: PUSH
106766: LD_INT 0
106768: PUSH
106769: LD_VAR 0 3
106773: PUSH
106774: LD_INT 0
106776: PUSH
106777: LD_INT 0
106779: PUSH
106780: LD_INT 0
106782: PUSH
106783: EMPTY
106784: LIST
106785: LIST
106786: LIST
106787: LIST
106788: LIST
106789: LIST
106790: LIST
106791: PUSH
106792: EMPTY
106793: LIST
106794: LIST
106795: PPUSH
106796: CALL_OW 446
// end ;
106800: LD_VAR 0 2
106804: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106805: LD_INT 0
106807: PPUSH
106808: PPUSH
// if not driver or not IsInUnit ( driver ) then
106809: LD_VAR 0 1
106813: NOT
106814: PUSH
106815: LD_VAR 0 1
106819: PPUSH
106820: CALL_OW 310
106824: NOT
106825: OR
106826: IFFALSE 106830
// exit ;
106828: GO 106920
// vehicle := IsInUnit ( driver ) ;
106830: LD_ADDR_VAR 0 3
106834: PUSH
106835: LD_VAR 0 1
106839: PPUSH
106840: CALL_OW 310
106844: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106845: LD_VAR 0 1
106849: PPUSH
106850: LD_STRING \
106852: PUSH
106853: LD_INT 0
106855: PUSH
106856: LD_INT 0
106858: PUSH
106859: LD_INT 0
106861: PUSH
106862: LD_INT 0
106864: PUSH
106865: LD_INT 0
106867: PUSH
106868: LD_INT 0
106870: PUSH
106871: EMPTY
106872: LIST
106873: LIST
106874: LIST
106875: LIST
106876: LIST
106877: LIST
106878: LIST
106879: PUSH
106880: LD_STRING E
106882: PUSH
106883: LD_INT 0
106885: PUSH
106886: LD_INT 0
106888: PUSH
106889: LD_VAR 0 3
106893: PUSH
106894: LD_INT 0
106896: PUSH
106897: LD_INT 0
106899: PUSH
106900: LD_INT 0
106902: PUSH
106903: EMPTY
106904: LIST
106905: LIST
106906: LIST
106907: LIST
106908: LIST
106909: LIST
106910: LIST
106911: PUSH
106912: EMPTY
106913: LIST
106914: LIST
106915: PPUSH
106916: CALL_OW 447
// end ;
106920: LD_VAR 0 2
106924: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106925: LD_INT 0
106927: PPUSH
106928: PPUSH
106929: PPUSH
// tmp := [ ] ;
106930: LD_ADDR_VAR 0 5
106934: PUSH
106935: EMPTY
106936: ST_TO_ADDR
// for i in units do
106937: LD_ADDR_VAR 0 4
106941: PUSH
106942: LD_VAR 0 1
106946: PUSH
106947: FOR_IN
106948: IFFALSE 106986
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
106950: LD_ADDR_VAR 0 5
106954: PUSH
106955: LD_VAR 0 5
106959: PPUSH
106960: LD_VAR 0 5
106964: PUSH
106965: LD_INT 1
106967: PLUS
106968: PPUSH
106969: LD_VAR 0 4
106973: PPUSH
106974: CALL_OW 256
106978: PPUSH
106979: CALL_OW 2
106983: ST_TO_ADDR
106984: GO 106947
106986: POP
106987: POP
// if not tmp then
106988: LD_VAR 0 5
106992: NOT
106993: IFFALSE 106997
// exit ;
106995: GO 107045
// if asc then
106997: LD_VAR 0 2
107001: IFFALSE 107025
// result := SortListByListAsc ( units , tmp ) else
107003: LD_ADDR_VAR 0 3
107007: PUSH
107008: LD_VAR 0 1
107012: PPUSH
107013: LD_VAR 0 5
107017: PPUSH
107018: CALL_OW 76
107022: ST_TO_ADDR
107023: GO 107045
// result := SortListByListDesc ( units , tmp ) ;
107025: LD_ADDR_VAR 0 3
107029: PUSH
107030: LD_VAR 0 1
107034: PPUSH
107035: LD_VAR 0 5
107039: PPUSH
107040: CALL_OW 77
107044: ST_TO_ADDR
// end ;
107045: LD_VAR 0 3
107049: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
107050: LD_INT 0
107052: PPUSH
107053: PPUSH
// task := GetTaskList ( mech ) ;
107054: LD_ADDR_VAR 0 4
107058: PUSH
107059: LD_VAR 0 1
107063: PPUSH
107064: CALL_OW 437
107068: ST_TO_ADDR
// if not task then
107069: LD_VAR 0 4
107073: NOT
107074: IFFALSE 107078
// exit ;
107076: GO 107120
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
107078: LD_ADDR_VAR 0 3
107082: PUSH
107083: LD_VAR 0 4
107087: PUSH
107088: LD_INT 1
107090: ARRAY
107091: PUSH
107092: LD_INT 1
107094: ARRAY
107095: PUSH
107096: LD_STRING r
107098: EQUAL
107099: PUSH
107100: LD_VAR 0 4
107104: PUSH
107105: LD_INT 1
107107: ARRAY
107108: PUSH
107109: LD_INT 4
107111: ARRAY
107112: PUSH
107113: LD_VAR 0 2
107117: EQUAL
107118: AND
107119: ST_TO_ADDR
// end ;
107120: LD_VAR 0 3
107124: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
107125: LD_INT 0
107127: PPUSH
// SetDir ( unit , d ) ;
107128: LD_VAR 0 1
107132: PPUSH
107133: LD_VAR 0 4
107137: PPUSH
107138: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
107142: LD_VAR 0 1
107146: PPUSH
107147: LD_VAR 0 2
107151: PPUSH
107152: LD_VAR 0 3
107156: PPUSH
107157: LD_VAR 0 5
107161: PPUSH
107162: CALL_OW 48
// end ;
107166: LD_VAR 0 6
107170: RET
// export function ToNaturalNumber ( number ) ; begin
107171: LD_INT 0
107173: PPUSH
// result := number div 1 ;
107174: LD_ADDR_VAR 0 2
107178: PUSH
107179: LD_VAR 0 1
107183: PUSH
107184: LD_INT 1
107186: DIV
107187: ST_TO_ADDR
// if number < 0 then
107188: LD_VAR 0 1
107192: PUSH
107193: LD_INT 0
107195: LESS
107196: IFFALSE 107206
// result := 0 ;
107198: LD_ADDR_VAR 0 2
107202: PUSH
107203: LD_INT 0
107205: ST_TO_ADDR
// end ;
107206: LD_VAR 0 2
107210: RET
// export function SortByClass ( units , class ) ; var un ; begin
107211: LD_INT 0
107213: PPUSH
107214: PPUSH
// if not units or not class then
107215: LD_VAR 0 1
107219: NOT
107220: PUSH
107221: LD_VAR 0 2
107225: NOT
107226: OR
107227: IFFALSE 107231
// exit ;
107229: GO 107326
// result := [ ] ;
107231: LD_ADDR_VAR 0 3
107235: PUSH
107236: EMPTY
107237: ST_TO_ADDR
// for un in units do
107238: LD_ADDR_VAR 0 4
107242: PUSH
107243: LD_VAR 0 1
107247: PUSH
107248: FOR_IN
107249: IFFALSE 107324
// if GetClass ( un ) = class then
107251: LD_VAR 0 4
107255: PPUSH
107256: CALL_OW 257
107260: PUSH
107261: LD_VAR 0 2
107265: EQUAL
107266: IFFALSE 107293
// result := Insert ( result , 1 , un ) else
107268: LD_ADDR_VAR 0 3
107272: PUSH
107273: LD_VAR 0 3
107277: PPUSH
107278: LD_INT 1
107280: PPUSH
107281: LD_VAR 0 4
107285: PPUSH
107286: CALL_OW 2
107290: ST_TO_ADDR
107291: GO 107322
// result := Replace ( result , result + 1 , un ) ;
107293: LD_ADDR_VAR 0 3
107297: PUSH
107298: LD_VAR 0 3
107302: PPUSH
107303: LD_VAR 0 3
107307: PUSH
107308: LD_INT 1
107310: PLUS
107311: PPUSH
107312: LD_VAR 0 4
107316: PPUSH
107317: CALL_OW 1
107321: ST_TO_ADDR
107322: GO 107248
107324: POP
107325: POP
// end ;
107326: LD_VAR 0 3
107330: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107331: LD_INT 0
107333: PPUSH
107334: PPUSH
107335: PPUSH
107336: PPUSH
107337: PPUSH
107338: PPUSH
107339: PPUSH
// result := [ ] ;
107340: LD_ADDR_VAR 0 4
107344: PUSH
107345: EMPTY
107346: ST_TO_ADDR
// if x - r < 0 then
107347: LD_VAR 0 1
107351: PUSH
107352: LD_VAR 0 3
107356: MINUS
107357: PUSH
107358: LD_INT 0
107360: LESS
107361: IFFALSE 107373
// min_x := 0 else
107363: LD_ADDR_VAR 0 8
107367: PUSH
107368: LD_INT 0
107370: ST_TO_ADDR
107371: GO 107389
// min_x := x - r ;
107373: LD_ADDR_VAR 0 8
107377: PUSH
107378: LD_VAR 0 1
107382: PUSH
107383: LD_VAR 0 3
107387: MINUS
107388: ST_TO_ADDR
// if y - r < 0 then
107389: LD_VAR 0 2
107393: PUSH
107394: LD_VAR 0 3
107398: MINUS
107399: PUSH
107400: LD_INT 0
107402: LESS
107403: IFFALSE 107415
// min_y := 0 else
107405: LD_ADDR_VAR 0 7
107409: PUSH
107410: LD_INT 0
107412: ST_TO_ADDR
107413: GO 107431
// min_y := y - r ;
107415: LD_ADDR_VAR 0 7
107419: PUSH
107420: LD_VAR 0 2
107424: PUSH
107425: LD_VAR 0 3
107429: MINUS
107430: ST_TO_ADDR
// max_x := x + r ;
107431: LD_ADDR_VAR 0 9
107435: PUSH
107436: LD_VAR 0 1
107440: PUSH
107441: LD_VAR 0 3
107445: PLUS
107446: ST_TO_ADDR
// max_y := y + r ;
107447: LD_ADDR_VAR 0 10
107451: PUSH
107452: LD_VAR 0 2
107456: PUSH
107457: LD_VAR 0 3
107461: PLUS
107462: ST_TO_ADDR
// for _x = min_x to max_x do
107463: LD_ADDR_VAR 0 5
107467: PUSH
107468: DOUBLE
107469: LD_VAR 0 8
107473: DEC
107474: ST_TO_ADDR
107475: LD_VAR 0 9
107479: PUSH
107480: FOR_TO
107481: IFFALSE 107582
// for _y = min_y to max_y do
107483: LD_ADDR_VAR 0 6
107487: PUSH
107488: DOUBLE
107489: LD_VAR 0 7
107493: DEC
107494: ST_TO_ADDR
107495: LD_VAR 0 10
107499: PUSH
107500: FOR_TO
107501: IFFALSE 107578
// begin if not ValidHex ( _x , _y ) then
107503: LD_VAR 0 5
107507: PPUSH
107508: LD_VAR 0 6
107512: PPUSH
107513: CALL_OW 488
107517: NOT
107518: IFFALSE 107522
// continue ;
107520: GO 107500
// if GetResourceTypeXY ( _x , _y ) then
107522: LD_VAR 0 5
107526: PPUSH
107527: LD_VAR 0 6
107531: PPUSH
107532: CALL_OW 283
107536: IFFALSE 107576
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107538: LD_ADDR_VAR 0 4
107542: PUSH
107543: LD_VAR 0 4
107547: PPUSH
107548: LD_VAR 0 4
107552: PUSH
107553: LD_INT 1
107555: PLUS
107556: PPUSH
107557: LD_VAR 0 5
107561: PUSH
107562: LD_VAR 0 6
107566: PUSH
107567: EMPTY
107568: LIST
107569: LIST
107570: PPUSH
107571: CALL_OW 1
107575: ST_TO_ADDR
// end ;
107576: GO 107500
107578: POP
107579: POP
107580: GO 107480
107582: POP
107583: POP
// end ;
107584: LD_VAR 0 4
107588: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107589: LD_INT 0
107591: PPUSH
107592: PPUSH
107593: PPUSH
107594: PPUSH
107595: PPUSH
107596: PPUSH
107597: PPUSH
107598: PPUSH
// if not units then
107599: LD_VAR 0 1
107603: NOT
107604: IFFALSE 107608
// exit ;
107606: GO 108132
// result := UnitFilter ( units , [ f_ok ] ) ;
107608: LD_ADDR_VAR 0 3
107612: PUSH
107613: LD_VAR 0 1
107617: PPUSH
107618: LD_INT 50
107620: PUSH
107621: EMPTY
107622: LIST
107623: PPUSH
107624: CALL_OW 72
107628: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107629: LD_ADDR_VAR 0 8
107633: PUSH
107634: LD_VAR 0 1
107638: PUSH
107639: LD_INT 1
107641: ARRAY
107642: PPUSH
107643: CALL_OW 255
107647: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107648: LD_ADDR_VAR 0 10
107652: PUSH
107653: LD_INT 29
107655: PUSH
107656: LD_INT 91
107658: PUSH
107659: LD_INT 49
107661: PUSH
107662: EMPTY
107663: LIST
107664: LIST
107665: LIST
107666: ST_TO_ADDR
// if not result then
107667: LD_VAR 0 3
107671: NOT
107672: IFFALSE 107676
// exit ;
107674: GO 108132
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107676: LD_ADDR_VAR 0 5
107680: PUSH
107681: LD_INT 81
107683: PUSH
107684: LD_VAR 0 8
107688: PUSH
107689: EMPTY
107690: LIST
107691: LIST
107692: PPUSH
107693: CALL_OW 69
107697: ST_TO_ADDR
// for i in result do
107698: LD_ADDR_VAR 0 4
107702: PUSH
107703: LD_VAR 0 3
107707: PUSH
107708: FOR_IN
107709: IFFALSE 108130
// begin tag := GetTag ( i ) + 1 ;
107711: LD_ADDR_VAR 0 9
107715: PUSH
107716: LD_VAR 0 4
107720: PPUSH
107721: CALL_OW 110
107725: PUSH
107726: LD_INT 1
107728: PLUS
107729: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107730: LD_ADDR_VAR 0 7
107734: PUSH
107735: LD_VAR 0 4
107739: PPUSH
107740: CALL_OW 250
107744: PPUSH
107745: LD_VAR 0 4
107749: PPUSH
107750: CALL_OW 251
107754: PPUSH
107755: LD_INT 6
107757: PPUSH
107758: CALL 107331 0 3
107762: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107763: LD_VAR 0 4
107767: PPUSH
107768: CALL_OW 247
107772: PUSH
107773: LD_INT 2
107775: EQUAL
107776: PUSH
107777: LD_VAR 0 7
107781: AND
107782: PUSH
107783: LD_VAR 0 4
107787: PPUSH
107788: CALL_OW 264
107792: PUSH
107793: LD_VAR 0 10
107797: IN
107798: NOT
107799: AND
107800: IFFALSE 107839
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107802: LD_VAR 0 4
107806: PPUSH
107807: LD_VAR 0 7
107811: PUSH
107812: LD_INT 1
107814: ARRAY
107815: PUSH
107816: LD_INT 1
107818: ARRAY
107819: PPUSH
107820: LD_VAR 0 7
107824: PUSH
107825: LD_INT 1
107827: ARRAY
107828: PUSH
107829: LD_INT 2
107831: ARRAY
107832: PPUSH
107833: CALL_OW 116
107837: GO 108128
// if path > tag then
107839: LD_VAR 0 2
107843: PUSH
107844: LD_VAR 0 9
107848: GREATER
107849: IFFALSE 108057
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107851: LD_ADDR_VAR 0 6
107855: PUSH
107856: LD_VAR 0 5
107860: PPUSH
107861: LD_INT 91
107863: PUSH
107864: LD_VAR 0 4
107868: PUSH
107869: LD_INT 8
107871: PUSH
107872: EMPTY
107873: LIST
107874: LIST
107875: LIST
107876: PPUSH
107877: CALL_OW 72
107881: ST_TO_ADDR
// if nearEnemy then
107882: LD_VAR 0 6
107886: IFFALSE 107955
// begin if GetWeapon ( i ) = ru_time_lapser then
107888: LD_VAR 0 4
107892: PPUSH
107893: CALL_OW 264
107897: PUSH
107898: LD_INT 49
107900: EQUAL
107901: IFFALSE 107929
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107903: LD_VAR 0 4
107907: PPUSH
107908: LD_VAR 0 6
107912: PPUSH
107913: LD_VAR 0 4
107917: PPUSH
107918: CALL_OW 74
107922: PPUSH
107923: CALL_OW 112
107927: GO 107953
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107929: LD_VAR 0 4
107933: PPUSH
107934: LD_VAR 0 6
107938: PPUSH
107939: LD_VAR 0 4
107943: PPUSH
107944: CALL_OW 74
107948: PPUSH
107949: CALL_OW 115
// end else
107953: GO 108055
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
107955: LD_VAR 0 4
107959: PPUSH
107960: LD_VAR 0 2
107964: PUSH
107965: LD_VAR 0 9
107969: ARRAY
107970: PUSH
107971: LD_INT 1
107973: ARRAY
107974: PPUSH
107975: LD_VAR 0 2
107979: PUSH
107980: LD_VAR 0 9
107984: ARRAY
107985: PUSH
107986: LD_INT 2
107988: ARRAY
107989: PPUSH
107990: CALL_OW 297
107994: PUSH
107995: LD_INT 6
107997: GREATER
107998: IFFALSE 108041
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
108000: LD_VAR 0 4
108004: PPUSH
108005: LD_VAR 0 2
108009: PUSH
108010: LD_VAR 0 9
108014: ARRAY
108015: PUSH
108016: LD_INT 1
108018: ARRAY
108019: PPUSH
108020: LD_VAR 0 2
108024: PUSH
108025: LD_VAR 0 9
108029: ARRAY
108030: PUSH
108031: LD_INT 2
108033: ARRAY
108034: PPUSH
108035: CALL_OW 114
108039: GO 108055
// SetTag ( i , tag ) ;
108041: LD_VAR 0 4
108045: PPUSH
108046: LD_VAR 0 9
108050: PPUSH
108051: CALL_OW 109
// end else
108055: GO 108128
// if enemy then
108057: LD_VAR 0 5
108061: IFFALSE 108128
// begin if GetWeapon ( i ) = ru_time_lapser then
108063: LD_VAR 0 4
108067: PPUSH
108068: CALL_OW 264
108072: PUSH
108073: LD_INT 49
108075: EQUAL
108076: IFFALSE 108104
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
108078: LD_VAR 0 4
108082: PPUSH
108083: LD_VAR 0 5
108087: PPUSH
108088: LD_VAR 0 4
108092: PPUSH
108093: CALL_OW 74
108097: PPUSH
108098: CALL_OW 112
108102: GO 108128
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
108104: LD_VAR 0 4
108108: PPUSH
108109: LD_VAR 0 5
108113: PPUSH
108114: LD_VAR 0 4
108118: PPUSH
108119: CALL_OW 74
108123: PPUSH
108124: CALL_OW 115
// end ; end ;
108128: GO 107708
108130: POP
108131: POP
// end ;
108132: LD_VAR 0 3
108136: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
108137: LD_INT 0
108139: PPUSH
108140: PPUSH
108141: PPUSH
// if not unit or IsInUnit ( unit ) then
108142: LD_VAR 0 1
108146: NOT
108147: PUSH
108148: LD_VAR 0 1
108152: PPUSH
108153: CALL_OW 310
108157: OR
108158: IFFALSE 108162
// exit ;
108160: GO 108253
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
108162: LD_ADDR_VAR 0 4
108166: PUSH
108167: LD_VAR 0 1
108171: PPUSH
108172: CALL_OW 250
108176: PPUSH
108177: LD_VAR 0 2
108181: PPUSH
108182: LD_INT 1
108184: PPUSH
108185: CALL_OW 272
108189: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
108190: LD_ADDR_VAR 0 5
108194: PUSH
108195: LD_VAR 0 1
108199: PPUSH
108200: CALL_OW 251
108204: PPUSH
108205: LD_VAR 0 2
108209: PPUSH
108210: LD_INT 1
108212: PPUSH
108213: CALL_OW 273
108217: ST_TO_ADDR
// if ValidHex ( x , y ) then
108218: LD_VAR 0 4
108222: PPUSH
108223: LD_VAR 0 5
108227: PPUSH
108228: CALL_OW 488
108232: IFFALSE 108253
// ComTurnXY ( unit , x , y ) ;
108234: LD_VAR 0 1
108238: PPUSH
108239: LD_VAR 0 4
108243: PPUSH
108244: LD_VAR 0 5
108248: PPUSH
108249: CALL_OW 118
// end ;
108253: LD_VAR 0 3
108257: RET
// export function SeeUnits ( side , units ) ; var i ; begin
108258: LD_INT 0
108260: PPUSH
108261: PPUSH
// result := false ;
108262: LD_ADDR_VAR 0 3
108266: PUSH
108267: LD_INT 0
108269: ST_TO_ADDR
// if not units then
108270: LD_VAR 0 2
108274: NOT
108275: IFFALSE 108279
// exit ;
108277: GO 108324
// for i in units do
108279: LD_ADDR_VAR 0 4
108283: PUSH
108284: LD_VAR 0 2
108288: PUSH
108289: FOR_IN
108290: IFFALSE 108322
// if See ( side , i ) then
108292: LD_VAR 0 1
108296: PPUSH
108297: LD_VAR 0 4
108301: PPUSH
108302: CALL_OW 292
108306: IFFALSE 108320
// begin result := true ;
108308: LD_ADDR_VAR 0 3
108312: PUSH
108313: LD_INT 1
108315: ST_TO_ADDR
// exit ;
108316: POP
108317: POP
108318: GO 108324
// end ;
108320: GO 108289
108322: POP
108323: POP
// end ;
108324: LD_VAR 0 3
108328: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108329: LD_INT 0
108331: PPUSH
108332: PPUSH
108333: PPUSH
108334: PPUSH
// if not unit or not points then
108335: LD_VAR 0 1
108339: NOT
108340: PUSH
108341: LD_VAR 0 2
108345: NOT
108346: OR
108347: IFFALSE 108351
// exit ;
108349: GO 108441
// dist := 99999 ;
108351: LD_ADDR_VAR 0 5
108355: PUSH
108356: LD_INT 99999
108358: ST_TO_ADDR
// for i in points do
108359: LD_ADDR_VAR 0 4
108363: PUSH
108364: LD_VAR 0 2
108368: PUSH
108369: FOR_IN
108370: IFFALSE 108439
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108372: LD_ADDR_VAR 0 6
108376: PUSH
108377: LD_VAR 0 1
108381: PPUSH
108382: LD_VAR 0 4
108386: PUSH
108387: LD_INT 1
108389: ARRAY
108390: PPUSH
108391: LD_VAR 0 4
108395: PUSH
108396: LD_INT 2
108398: ARRAY
108399: PPUSH
108400: CALL_OW 297
108404: ST_TO_ADDR
// if tmpDist < dist then
108405: LD_VAR 0 6
108409: PUSH
108410: LD_VAR 0 5
108414: LESS
108415: IFFALSE 108437
// begin result := i ;
108417: LD_ADDR_VAR 0 3
108421: PUSH
108422: LD_VAR 0 4
108426: ST_TO_ADDR
// dist := tmpDist ;
108427: LD_ADDR_VAR 0 5
108431: PUSH
108432: LD_VAR 0 6
108436: ST_TO_ADDR
// end ; end ;
108437: GO 108369
108439: POP
108440: POP
// end ;
108441: LD_VAR 0 3
108445: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108446: LD_INT 0
108448: PPUSH
// uc_side := side ;
108449: LD_ADDR_OWVAR 20
108453: PUSH
108454: LD_VAR 0 1
108458: ST_TO_ADDR
// uc_nation := 3 ;
108459: LD_ADDR_OWVAR 21
108463: PUSH
108464: LD_INT 3
108466: ST_TO_ADDR
// vc_chassis := 25 ;
108467: LD_ADDR_OWVAR 37
108471: PUSH
108472: LD_INT 25
108474: ST_TO_ADDR
// vc_engine := engine_siberite ;
108475: LD_ADDR_OWVAR 39
108479: PUSH
108480: LD_INT 3
108482: ST_TO_ADDR
// vc_control := control_computer ;
108483: LD_ADDR_OWVAR 38
108487: PUSH
108488: LD_INT 3
108490: ST_TO_ADDR
// vc_weapon := 59 ;
108491: LD_ADDR_OWVAR 40
108495: PUSH
108496: LD_INT 59
108498: ST_TO_ADDR
// result := CreateVehicle ;
108499: LD_ADDR_VAR 0 5
108503: PUSH
108504: CALL_OW 45
108508: ST_TO_ADDR
// SetDir ( result , d ) ;
108509: LD_VAR 0 5
108513: PPUSH
108514: LD_VAR 0 4
108518: PPUSH
108519: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108523: LD_VAR 0 5
108527: PPUSH
108528: LD_VAR 0 2
108532: PPUSH
108533: LD_VAR 0 3
108537: PPUSH
108538: LD_INT 0
108540: PPUSH
108541: CALL_OW 48
// end ;
108545: LD_VAR 0 5
108549: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108550: LD_INT 0
108552: PPUSH
108553: PPUSH
108554: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108555: LD_ADDR_VAR 0 2
108559: PUSH
108560: LD_INT 0
108562: PUSH
108563: LD_INT 0
108565: PUSH
108566: LD_INT 0
108568: PUSH
108569: LD_INT 0
108571: PUSH
108572: EMPTY
108573: LIST
108574: LIST
108575: LIST
108576: LIST
108577: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108578: LD_VAR 0 1
108582: NOT
108583: PUSH
108584: LD_VAR 0 1
108588: PPUSH
108589: CALL_OW 264
108593: PUSH
108594: LD_INT 12
108596: PUSH
108597: LD_INT 51
108599: PUSH
108600: LD_INT 32
108602: PUSH
108603: LD_INT 89
108605: PUSH
108606: EMPTY
108607: LIST
108608: LIST
108609: LIST
108610: LIST
108611: IN
108612: NOT
108613: OR
108614: IFFALSE 108618
// exit ;
108616: GO 108716
// for i := 1 to 3 do
108618: LD_ADDR_VAR 0 3
108622: PUSH
108623: DOUBLE
108624: LD_INT 1
108626: DEC
108627: ST_TO_ADDR
108628: LD_INT 3
108630: PUSH
108631: FOR_TO
108632: IFFALSE 108714
// begin tmp := GetCargo ( cargo , i ) ;
108634: LD_ADDR_VAR 0 4
108638: PUSH
108639: LD_VAR 0 1
108643: PPUSH
108644: LD_VAR 0 3
108648: PPUSH
108649: CALL_OW 289
108653: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108654: LD_ADDR_VAR 0 2
108658: PUSH
108659: LD_VAR 0 2
108663: PPUSH
108664: LD_VAR 0 3
108668: PPUSH
108669: LD_VAR 0 4
108673: PPUSH
108674: CALL_OW 1
108678: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108679: LD_ADDR_VAR 0 2
108683: PUSH
108684: LD_VAR 0 2
108688: PPUSH
108689: LD_INT 4
108691: PPUSH
108692: LD_VAR 0 2
108696: PUSH
108697: LD_INT 4
108699: ARRAY
108700: PUSH
108701: LD_VAR 0 4
108705: PLUS
108706: PPUSH
108707: CALL_OW 1
108711: ST_TO_ADDR
// end ;
108712: GO 108631
108714: POP
108715: POP
// end ;
108716: LD_VAR 0 2
108720: RET
// export function Length ( array ) ; begin
108721: LD_INT 0
108723: PPUSH
// result := array + 0 ;
108724: LD_ADDR_VAR 0 2
108728: PUSH
108729: LD_VAR 0 1
108733: PUSH
108734: LD_INT 0
108736: PLUS
108737: ST_TO_ADDR
// end ;
108738: LD_VAR 0 2
108742: RET
// export function PrepareArray ( array ) ; begin
108743: LD_INT 0
108745: PPUSH
// result := array diff 0 ;
108746: LD_ADDR_VAR 0 2
108750: PUSH
108751: LD_VAR 0 1
108755: PUSH
108756: LD_INT 0
108758: DIFF
108759: ST_TO_ADDR
// if not result [ 1 ] then
108760: LD_VAR 0 2
108764: PUSH
108765: LD_INT 1
108767: ARRAY
108768: NOT
108769: IFFALSE 108789
// result := Delete ( result , 1 ) ;
108771: LD_ADDR_VAR 0 2
108775: PUSH
108776: LD_VAR 0 2
108780: PPUSH
108781: LD_INT 1
108783: PPUSH
108784: CALL_OW 3
108788: ST_TO_ADDR
// end ;
108789: LD_VAR 0 2
108793: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
108794: LD_INT 0
108796: PPUSH
108797: PPUSH
108798: PPUSH
108799: PPUSH
// sibRocketRange := 25 ;
108800: LD_ADDR_VAR 0 6
108804: PUSH
108805: LD_INT 25
108807: ST_TO_ADDR
// result := false ;
108808: LD_ADDR_VAR 0 4
108812: PUSH
108813: LD_INT 0
108815: ST_TO_ADDR
// for i := 0 to 5 do
108816: LD_ADDR_VAR 0 5
108820: PUSH
108821: DOUBLE
108822: LD_INT 0
108824: DEC
108825: ST_TO_ADDR
108826: LD_INT 5
108828: PUSH
108829: FOR_TO
108830: IFFALSE 108897
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
108832: LD_VAR 0 1
108836: PPUSH
108837: LD_VAR 0 5
108841: PPUSH
108842: LD_VAR 0 6
108846: PPUSH
108847: CALL_OW 272
108851: PPUSH
108852: LD_VAR 0 2
108856: PPUSH
108857: LD_VAR 0 5
108861: PPUSH
108862: LD_VAR 0 6
108866: PPUSH
108867: CALL_OW 273
108871: PPUSH
108872: LD_VAR 0 3
108876: PPUSH
108877: CALL_OW 309
108881: IFFALSE 108895
// begin result := true ;
108883: LD_ADDR_VAR 0 4
108887: PUSH
108888: LD_INT 1
108890: ST_TO_ADDR
// exit ;
108891: POP
108892: POP
108893: GO 108899
// end ;
108895: GO 108829
108897: POP
108898: POP
// end ;
108899: LD_VAR 0 4
108903: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
108904: LD_INT 0
108906: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
108907: LD_VAR 0 1
108911: PPUSH
108912: LD_VAR 0 2
108916: PPUSH
108917: LD_INT 0
108919: PPUSH
108920: LD_INT 0
108922: PPUSH
108923: LD_INT 1
108925: PPUSH
108926: LD_INT 0
108928: PPUSH
108929: CALL_OW 587
// end ; end_of_file end_of_file
108933: LD_VAR 0 3
108937: RET
// every 0 0$1 do
108938: GO 108940
108940: DISABLE
// begin enable ;
108941: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
108942: LD_STRING updateTimer(
108944: PUSH
108945: LD_OWVAR 1
108949: STR
108950: PUSH
108951: LD_STRING );
108953: STR
108954: PPUSH
108955: CALL_OW 559
// end ;
108959: END
// export function SOS_MapStart ( ) ; begin
108960: LD_INT 0
108962: PPUSH
// if streamModeActive then
108963: LD_EXP 144
108967: IFFALSE 108976
// DefineStreamItems ( true ) ;
108969: LD_INT 1
108971: PPUSH
108972: CALL 110630 0 1
// UpdateFactoryWaypoints ( ) ;
108976: CALL 123491 0 0
// UpdateWarehouseGatheringPoints ( ) ;
108980: CALL 123748 0 0
// end ;
108984: LD_VAR 0 1
108988: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108989: LD_INT 0
108991: PPUSH
// if p2 = hack_mode then
108992: LD_VAR 0 2
108996: PUSH
108997: LD_INT 100
108999: EQUAL
109000: IFFALSE 110003
// begin if not StreamModeActive then
109002: LD_EXP 144
109006: NOT
109007: IFFALSE 109017
// StreamModeActive := true ;
109009: LD_ADDR_EXP 144
109013: PUSH
109014: LD_INT 1
109016: ST_TO_ADDR
// if p3 = 0 then
109017: LD_VAR 0 3
109021: PUSH
109022: LD_INT 0
109024: EQUAL
109025: IFFALSE 109031
// InitStreamMode ;
109027: CALL 110166 0 0
// if p3 = 1 then
109031: LD_VAR 0 3
109035: PUSH
109036: LD_INT 1
109038: EQUAL
109039: IFFALSE 109049
// sRocket := true ;
109041: LD_ADDR_EXP 149
109045: PUSH
109046: LD_INT 1
109048: ST_TO_ADDR
// if p3 = 2 then
109049: LD_VAR 0 3
109053: PUSH
109054: LD_INT 2
109056: EQUAL
109057: IFFALSE 109067
// sSpeed := true ;
109059: LD_ADDR_EXP 148
109063: PUSH
109064: LD_INT 1
109066: ST_TO_ADDR
// if p3 = 3 then
109067: LD_VAR 0 3
109071: PUSH
109072: LD_INT 3
109074: EQUAL
109075: IFFALSE 109085
// sEngine := true ;
109077: LD_ADDR_EXP 150
109081: PUSH
109082: LD_INT 1
109084: ST_TO_ADDR
// if p3 = 4 then
109085: LD_VAR 0 3
109089: PUSH
109090: LD_INT 4
109092: EQUAL
109093: IFFALSE 109103
// sSpec := true ;
109095: LD_ADDR_EXP 147
109099: PUSH
109100: LD_INT 1
109102: ST_TO_ADDR
// if p3 = 5 then
109103: LD_VAR 0 3
109107: PUSH
109108: LD_INT 5
109110: EQUAL
109111: IFFALSE 109121
// sLevel := true ;
109113: LD_ADDR_EXP 151
109117: PUSH
109118: LD_INT 1
109120: ST_TO_ADDR
// if p3 = 6 then
109121: LD_VAR 0 3
109125: PUSH
109126: LD_INT 6
109128: EQUAL
109129: IFFALSE 109139
// sArmoury := true ;
109131: LD_ADDR_EXP 152
109135: PUSH
109136: LD_INT 1
109138: ST_TO_ADDR
// if p3 = 7 then
109139: LD_VAR 0 3
109143: PUSH
109144: LD_INT 7
109146: EQUAL
109147: IFFALSE 109157
// sRadar := true ;
109149: LD_ADDR_EXP 153
109153: PUSH
109154: LD_INT 1
109156: ST_TO_ADDR
// if p3 = 8 then
109157: LD_VAR 0 3
109161: PUSH
109162: LD_INT 8
109164: EQUAL
109165: IFFALSE 109175
// sBunker := true ;
109167: LD_ADDR_EXP 154
109171: PUSH
109172: LD_INT 1
109174: ST_TO_ADDR
// if p3 = 9 then
109175: LD_VAR 0 3
109179: PUSH
109180: LD_INT 9
109182: EQUAL
109183: IFFALSE 109193
// sHack := true ;
109185: LD_ADDR_EXP 155
109189: PUSH
109190: LD_INT 1
109192: ST_TO_ADDR
// if p3 = 10 then
109193: LD_VAR 0 3
109197: PUSH
109198: LD_INT 10
109200: EQUAL
109201: IFFALSE 109211
// sFire := true ;
109203: LD_ADDR_EXP 156
109207: PUSH
109208: LD_INT 1
109210: ST_TO_ADDR
// if p3 = 11 then
109211: LD_VAR 0 3
109215: PUSH
109216: LD_INT 11
109218: EQUAL
109219: IFFALSE 109229
// sRefresh := true ;
109221: LD_ADDR_EXP 157
109225: PUSH
109226: LD_INT 1
109228: ST_TO_ADDR
// if p3 = 12 then
109229: LD_VAR 0 3
109233: PUSH
109234: LD_INT 12
109236: EQUAL
109237: IFFALSE 109247
// sExp := true ;
109239: LD_ADDR_EXP 158
109243: PUSH
109244: LD_INT 1
109246: ST_TO_ADDR
// if p3 = 13 then
109247: LD_VAR 0 3
109251: PUSH
109252: LD_INT 13
109254: EQUAL
109255: IFFALSE 109265
// sDepot := true ;
109257: LD_ADDR_EXP 159
109261: PUSH
109262: LD_INT 1
109264: ST_TO_ADDR
// if p3 = 14 then
109265: LD_VAR 0 3
109269: PUSH
109270: LD_INT 14
109272: EQUAL
109273: IFFALSE 109283
// sFlag := true ;
109275: LD_ADDR_EXP 160
109279: PUSH
109280: LD_INT 1
109282: ST_TO_ADDR
// if p3 = 15 then
109283: LD_VAR 0 3
109287: PUSH
109288: LD_INT 15
109290: EQUAL
109291: IFFALSE 109301
// sKamikadze := true ;
109293: LD_ADDR_EXP 168
109297: PUSH
109298: LD_INT 1
109300: ST_TO_ADDR
// if p3 = 16 then
109301: LD_VAR 0 3
109305: PUSH
109306: LD_INT 16
109308: EQUAL
109309: IFFALSE 109319
// sTroll := true ;
109311: LD_ADDR_EXP 169
109315: PUSH
109316: LD_INT 1
109318: ST_TO_ADDR
// if p3 = 17 then
109319: LD_VAR 0 3
109323: PUSH
109324: LD_INT 17
109326: EQUAL
109327: IFFALSE 109337
// sSlow := true ;
109329: LD_ADDR_EXP 170
109333: PUSH
109334: LD_INT 1
109336: ST_TO_ADDR
// if p3 = 18 then
109337: LD_VAR 0 3
109341: PUSH
109342: LD_INT 18
109344: EQUAL
109345: IFFALSE 109355
// sLack := true ;
109347: LD_ADDR_EXP 171
109351: PUSH
109352: LD_INT 1
109354: ST_TO_ADDR
// if p3 = 19 then
109355: LD_VAR 0 3
109359: PUSH
109360: LD_INT 19
109362: EQUAL
109363: IFFALSE 109373
// sTank := true ;
109365: LD_ADDR_EXP 173
109369: PUSH
109370: LD_INT 1
109372: ST_TO_ADDR
// if p3 = 20 then
109373: LD_VAR 0 3
109377: PUSH
109378: LD_INT 20
109380: EQUAL
109381: IFFALSE 109391
// sRemote := true ;
109383: LD_ADDR_EXP 174
109387: PUSH
109388: LD_INT 1
109390: ST_TO_ADDR
// if p3 = 21 then
109391: LD_VAR 0 3
109395: PUSH
109396: LD_INT 21
109398: EQUAL
109399: IFFALSE 109409
// sPowell := true ;
109401: LD_ADDR_EXP 175
109405: PUSH
109406: LD_INT 1
109408: ST_TO_ADDR
// if p3 = 22 then
109409: LD_VAR 0 3
109413: PUSH
109414: LD_INT 22
109416: EQUAL
109417: IFFALSE 109427
// sTeleport := true ;
109419: LD_ADDR_EXP 178
109423: PUSH
109424: LD_INT 1
109426: ST_TO_ADDR
// if p3 = 23 then
109427: LD_VAR 0 3
109431: PUSH
109432: LD_INT 23
109434: EQUAL
109435: IFFALSE 109445
// sOilTower := true ;
109437: LD_ADDR_EXP 180
109441: PUSH
109442: LD_INT 1
109444: ST_TO_ADDR
// if p3 = 24 then
109445: LD_VAR 0 3
109449: PUSH
109450: LD_INT 24
109452: EQUAL
109453: IFFALSE 109463
// sShovel := true ;
109455: LD_ADDR_EXP 181
109459: PUSH
109460: LD_INT 1
109462: ST_TO_ADDR
// if p3 = 25 then
109463: LD_VAR 0 3
109467: PUSH
109468: LD_INT 25
109470: EQUAL
109471: IFFALSE 109481
// sSheik := true ;
109473: LD_ADDR_EXP 182
109477: PUSH
109478: LD_INT 1
109480: ST_TO_ADDR
// if p3 = 26 then
109481: LD_VAR 0 3
109485: PUSH
109486: LD_INT 26
109488: EQUAL
109489: IFFALSE 109499
// sEarthquake := true ;
109491: LD_ADDR_EXP 184
109495: PUSH
109496: LD_INT 1
109498: ST_TO_ADDR
// if p3 = 27 then
109499: LD_VAR 0 3
109503: PUSH
109504: LD_INT 27
109506: EQUAL
109507: IFFALSE 109517
// sAI := true ;
109509: LD_ADDR_EXP 185
109513: PUSH
109514: LD_INT 1
109516: ST_TO_ADDR
// if p3 = 28 then
109517: LD_VAR 0 3
109521: PUSH
109522: LD_INT 28
109524: EQUAL
109525: IFFALSE 109535
// sCargo := true ;
109527: LD_ADDR_EXP 188
109531: PUSH
109532: LD_INT 1
109534: ST_TO_ADDR
// if p3 = 29 then
109535: LD_VAR 0 3
109539: PUSH
109540: LD_INT 29
109542: EQUAL
109543: IFFALSE 109553
// sDLaser := true ;
109545: LD_ADDR_EXP 189
109549: PUSH
109550: LD_INT 1
109552: ST_TO_ADDR
// if p3 = 30 then
109553: LD_VAR 0 3
109557: PUSH
109558: LD_INT 30
109560: EQUAL
109561: IFFALSE 109571
// sExchange := true ;
109563: LD_ADDR_EXP 190
109567: PUSH
109568: LD_INT 1
109570: ST_TO_ADDR
// if p3 = 31 then
109571: LD_VAR 0 3
109575: PUSH
109576: LD_INT 31
109578: EQUAL
109579: IFFALSE 109589
// sFac := true ;
109581: LD_ADDR_EXP 191
109585: PUSH
109586: LD_INT 1
109588: ST_TO_ADDR
// if p3 = 32 then
109589: LD_VAR 0 3
109593: PUSH
109594: LD_INT 32
109596: EQUAL
109597: IFFALSE 109607
// sPower := true ;
109599: LD_ADDR_EXP 192
109603: PUSH
109604: LD_INT 1
109606: ST_TO_ADDR
// if p3 = 33 then
109607: LD_VAR 0 3
109611: PUSH
109612: LD_INT 33
109614: EQUAL
109615: IFFALSE 109625
// sRandom := true ;
109617: LD_ADDR_EXP 193
109621: PUSH
109622: LD_INT 1
109624: ST_TO_ADDR
// if p3 = 34 then
109625: LD_VAR 0 3
109629: PUSH
109630: LD_INT 34
109632: EQUAL
109633: IFFALSE 109643
// sShield := true ;
109635: LD_ADDR_EXP 194
109639: PUSH
109640: LD_INT 1
109642: ST_TO_ADDR
// if p3 = 35 then
109643: LD_VAR 0 3
109647: PUSH
109648: LD_INT 35
109650: EQUAL
109651: IFFALSE 109661
// sTime := true ;
109653: LD_ADDR_EXP 195
109657: PUSH
109658: LD_INT 1
109660: ST_TO_ADDR
// if p3 = 36 then
109661: LD_VAR 0 3
109665: PUSH
109666: LD_INT 36
109668: EQUAL
109669: IFFALSE 109679
// sTools := true ;
109671: LD_ADDR_EXP 196
109675: PUSH
109676: LD_INT 1
109678: ST_TO_ADDR
// if p3 = 101 then
109679: LD_VAR 0 3
109683: PUSH
109684: LD_INT 101
109686: EQUAL
109687: IFFALSE 109697
// sSold := true ;
109689: LD_ADDR_EXP 161
109693: PUSH
109694: LD_INT 1
109696: ST_TO_ADDR
// if p3 = 102 then
109697: LD_VAR 0 3
109701: PUSH
109702: LD_INT 102
109704: EQUAL
109705: IFFALSE 109715
// sDiff := true ;
109707: LD_ADDR_EXP 162
109711: PUSH
109712: LD_INT 1
109714: ST_TO_ADDR
// if p3 = 103 then
109715: LD_VAR 0 3
109719: PUSH
109720: LD_INT 103
109722: EQUAL
109723: IFFALSE 109733
// sFog := true ;
109725: LD_ADDR_EXP 165
109729: PUSH
109730: LD_INT 1
109732: ST_TO_ADDR
// if p3 = 104 then
109733: LD_VAR 0 3
109737: PUSH
109738: LD_INT 104
109740: EQUAL
109741: IFFALSE 109751
// sReset := true ;
109743: LD_ADDR_EXP 166
109747: PUSH
109748: LD_INT 1
109750: ST_TO_ADDR
// if p3 = 105 then
109751: LD_VAR 0 3
109755: PUSH
109756: LD_INT 105
109758: EQUAL
109759: IFFALSE 109769
// sSun := true ;
109761: LD_ADDR_EXP 167
109765: PUSH
109766: LD_INT 1
109768: ST_TO_ADDR
// if p3 = 106 then
109769: LD_VAR 0 3
109773: PUSH
109774: LD_INT 106
109776: EQUAL
109777: IFFALSE 109787
// sTiger := true ;
109779: LD_ADDR_EXP 163
109783: PUSH
109784: LD_INT 1
109786: ST_TO_ADDR
// if p3 = 107 then
109787: LD_VAR 0 3
109791: PUSH
109792: LD_INT 107
109794: EQUAL
109795: IFFALSE 109805
// sBomb := true ;
109797: LD_ADDR_EXP 164
109801: PUSH
109802: LD_INT 1
109804: ST_TO_ADDR
// if p3 = 108 then
109805: LD_VAR 0 3
109809: PUSH
109810: LD_INT 108
109812: EQUAL
109813: IFFALSE 109823
// sWound := true ;
109815: LD_ADDR_EXP 172
109819: PUSH
109820: LD_INT 1
109822: ST_TO_ADDR
// if p3 = 109 then
109823: LD_VAR 0 3
109827: PUSH
109828: LD_INT 109
109830: EQUAL
109831: IFFALSE 109841
// sBetray := true ;
109833: LD_ADDR_EXP 176
109837: PUSH
109838: LD_INT 1
109840: ST_TO_ADDR
// if p3 = 110 then
109841: LD_VAR 0 3
109845: PUSH
109846: LD_INT 110
109848: EQUAL
109849: IFFALSE 109859
// sContamin := true ;
109851: LD_ADDR_EXP 177
109855: PUSH
109856: LD_INT 1
109858: ST_TO_ADDR
// if p3 = 111 then
109859: LD_VAR 0 3
109863: PUSH
109864: LD_INT 111
109866: EQUAL
109867: IFFALSE 109877
// sOil := true ;
109869: LD_ADDR_EXP 179
109873: PUSH
109874: LD_INT 1
109876: ST_TO_ADDR
// if p3 = 112 then
109877: LD_VAR 0 3
109881: PUSH
109882: LD_INT 112
109884: EQUAL
109885: IFFALSE 109895
// sStu := true ;
109887: LD_ADDR_EXP 183
109891: PUSH
109892: LD_INT 1
109894: ST_TO_ADDR
// if p3 = 113 then
109895: LD_VAR 0 3
109899: PUSH
109900: LD_INT 113
109902: EQUAL
109903: IFFALSE 109913
// sBazooka := true ;
109905: LD_ADDR_EXP 186
109909: PUSH
109910: LD_INT 1
109912: ST_TO_ADDR
// if p3 = 114 then
109913: LD_VAR 0 3
109917: PUSH
109918: LD_INT 114
109920: EQUAL
109921: IFFALSE 109931
// sMortar := true ;
109923: LD_ADDR_EXP 187
109927: PUSH
109928: LD_INT 1
109930: ST_TO_ADDR
// if p3 = 115 then
109931: LD_VAR 0 3
109935: PUSH
109936: LD_INT 115
109938: EQUAL
109939: IFFALSE 109949
// sRanger := true ;
109941: LD_ADDR_EXP 197
109945: PUSH
109946: LD_INT 1
109948: ST_TO_ADDR
// if p3 = 116 then
109949: LD_VAR 0 3
109953: PUSH
109954: LD_INT 116
109956: EQUAL
109957: IFFALSE 109967
// sComputer := true ;
109959: LD_ADDR_EXP 198
109963: PUSH
109964: LD_INT 1
109966: ST_TO_ADDR
// if p3 = 117 then
109967: LD_VAR 0 3
109971: PUSH
109972: LD_INT 117
109974: EQUAL
109975: IFFALSE 109985
// s30 := true ;
109977: LD_ADDR_EXP 199
109981: PUSH
109982: LD_INT 1
109984: ST_TO_ADDR
// if p3 = 118 then
109985: LD_VAR 0 3
109989: PUSH
109990: LD_INT 118
109992: EQUAL
109993: IFFALSE 110003
// s60 := true ;
109995: LD_ADDR_EXP 200
109999: PUSH
110000: LD_INT 1
110002: ST_TO_ADDR
// end ; if p2 = stream_mode then
110003: LD_VAR 0 2
110007: PUSH
110008: LD_INT 101
110010: EQUAL
110011: IFFALSE 110139
// begin case p3 of 1 :
110013: LD_VAR 0 3
110017: PUSH
110018: LD_INT 1
110020: DOUBLE
110021: EQUAL
110022: IFTRUE 110026
110024: GO 110033
110026: POP
// hHackUnlimitedResources ; 2 :
110027: CALL 122237 0 0
110031: GO 110139
110033: LD_INT 2
110035: DOUBLE
110036: EQUAL
110037: IFTRUE 110041
110039: GO 110048
110041: POP
// hHackSetLevel10 ; 3 :
110042: CALL 122370 0 0
110046: GO 110139
110048: LD_INT 3
110050: DOUBLE
110051: EQUAL
110052: IFTRUE 110056
110054: GO 110063
110056: POP
// hHackSetLevel10YourUnits ; 4 :
110057: CALL 122455 0 0
110061: GO 110139
110063: LD_INT 4
110065: DOUBLE
110066: EQUAL
110067: IFTRUE 110071
110069: GO 110078
110071: POP
// hHackInvincible ; 5 :
110072: CALL 122903 0 0
110076: GO 110139
110078: LD_INT 5
110080: DOUBLE
110081: EQUAL
110082: IFTRUE 110086
110084: GO 110093
110086: POP
// hHackInvisible ; 6 :
110087: CALL 123014 0 0
110091: GO 110139
110093: LD_INT 6
110095: DOUBLE
110096: EQUAL
110097: IFTRUE 110101
110099: GO 110108
110101: POP
// hHackChangeYourSide ; 7 :
110102: CALL 123071 0 0
110106: GO 110139
110108: LD_INT 7
110110: DOUBLE
110111: EQUAL
110112: IFTRUE 110116
110114: GO 110123
110116: POP
// hHackChangeUnitSide ; 8 :
110117: CALL 123113 0 0
110121: GO 110139
110123: LD_INT 8
110125: DOUBLE
110126: EQUAL
110127: IFTRUE 110131
110129: GO 110138
110131: POP
// hHackFog ; end ;
110132: CALL 123214 0 0
110136: GO 110139
110138: POP
// end ; end ;
110139: LD_VAR 0 7
110143: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
110144: GO 110146
110146: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
110147: LD_STRING initStreamRollete();
110149: PPUSH
110150: CALL_OW 559
// InitStreamMode ;
110154: CALL 110166 0 0
// DefineStreamItems ( false ) ;
110158: LD_INT 0
110160: PPUSH
110161: CALL 110630 0 1
// end ;
110165: END
// function InitStreamMode ; begin
110166: LD_INT 0
110168: PPUSH
// streamModeActive := false ;
110169: LD_ADDR_EXP 144
110173: PUSH
110174: LD_INT 0
110176: ST_TO_ADDR
// normalCounter := 36 ;
110177: LD_ADDR_EXP 145
110181: PUSH
110182: LD_INT 36
110184: ST_TO_ADDR
// hardcoreCounter := 18 ;
110185: LD_ADDR_EXP 146
110189: PUSH
110190: LD_INT 18
110192: ST_TO_ADDR
// sRocket := false ;
110193: LD_ADDR_EXP 149
110197: PUSH
110198: LD_INT 0
110200: ST_TO_ADDR
// sSpeed := false ;
110201: LD_ADDR_EXP 148
110205: PUSH
110206: LD_INT 0
110208: ST_TO_ADDR
// sEngine := false ;
110209: LD_ADDR_EXP 150
110213: PUSH
110214: LD_INT 0
110216: ST_TO_ADDR
// sSpec := false ;
110217: LD_ADDR_EXP 147
110221: PUSH
110222: LD_INT 0
110224: ST_TO_ADDR
// sLevel := false ;
110225: LD_ADDR_EXP 151
110229: PUSH
110230: LD_INT 0
110232: ST_TO_ADDR
// sArmoury := false ;
110233: LD_ADDR_EXP 152
110237: PUSH
110238: LD_INT 0
110240: ST_TO_ADDR
// sRadar := false ;
110241: LD_ADDR_EXP 153
110245: PUSH
110246: LD_INT 0
110248: ST_TO_ADDR
// sBunker := false ;
110249: LD_ADDR_EXP 154
110253: PUSH
110254: LD_INT 0
110256: ST_TO_ADDR
// sHack := false ;
110257: LD_ADDR_EXP 155
110261: PUSH
110262: LD_INT 0
110264: ST_TO_ADDR
// sFire := false ;
110265: LD_ADDR_EXP 156
110269: PUSH
110270: LD_INT 0
110272: ST_TO_ADDR
// sRefresh := false ;
110273: LD_ADDR_EXP 157
110277: PUSH
110278: LD_INT 0
110280: ST_TO_ADDR
// sExp := false ;
110281: LD_ADDR_EXP 158
110285: PUSH
110286: LD_INT 0
110288: ST_TO_ADDR
// sDepot := false ;
110289: LD_ADDR_EXP 159
110293: PUSH
110294: LD_INT 0
110296: ST_TO_ADDR
// sFlag := false ;
110297: LD_ADDR_EXP 160
110301: PUSH
110302: LD_INT 0
110304: ST_TO_ADDR
// sKamikadze := false ;
110305: LD_ADDR_EXP 168
110309: PUSH
110310: LD_INT 0
110312: ST_TO_ADDR
// sTroll := false ;
110313: LD_ADDR_EXP 169
110317: PUSH
110318: LD_INT 0
110320: ST_TO_ADDR
// sSlow := false ;
110321: LD_ADDR_EXP 170
110325: PUSH
110326: LD_INT 0
110328: ST_TO_ADDR
// sLack := false ;
110329: LD_ADDR_EXP 171
110333: PUSH
110334: LD_INT 0
110336: ST_TO_ADDR
// sTank := false ;
110337: LD_ADDR_EXP 173
110341: PUSH
110342: LD_INT 0
110344: ST_TO_ADDR
// sRemote := false ;
110345: LD_ADDR_EXP 174
110349: PUSH
110350: LD_INT 0
110352: ST_TO_ADDR
// sPowell := false ;
110353: LD_ADDR_EXP 175
110357: PUSH
110358: LD_INT 0
110360: ST_TO_ADDR
// sTeleport := false ;
110361: LD_ADDR_EXP 178
110365: PUSH
110366: LD_INT 0
110368: ST_TO_ADDR
// sOilTower := false ;
110369: LD_ADDR_EXP 180
110373: PUSH
110374: LD_INT 0
110376: ST_TO_ADDR
// sShovel := false ;
110377: LD_ADDR_EXP 181
110381: PUSH
110382: LD_INT 0
110384: ST_TO_ADDR
// sSheik := false ;
110385: LD_ADDR_EXP 182
110389: PUSH
110390: LD_INT 0
110392: ST_TO_ADDR
// sEarthquake := false ;
110393: LD_ADDR_EXP 184
110397: PUSH
110398: LD_INT 0
110400: ST_TO_ADDR
// sAI := false ;
110401: LD_ADDR_EXP 185
110405: PUSH
110406: LD_INT 0
110408: ST_TO_ADDR
// sCargo := false ;
110409: LD_ADDR_EXP 188
110413: PUSH
110414: LD_INT 0
110416: ST_TO_ADDR
// sDLaser := false ;
110417: LD_ADDR_EXP 189
110421: PUSH
110422: LD_INT 0
110424: ST_TO_ADDR
// sExchange := false ;
110425: LD_ADDR_EXP 190
110429: PUSH
110430: LD_INT 0
110432: ST_TO_ADDR
// sFac := false ;
110433: LD_ADDR_EXP 191
110437: PUSH
110438: LD_INT 0
110440: ST_TO_ADDR
// sPower := false ;
110441: LD_ADDR_EXP 192
110445: PUSH
110446: LD_INT 0
110448: ST_TO_ADDR
// sRandom := false ;
110449: LD_ADDR_EXP 193
110453: PUSH
110454: LD_INT 0
110456: ST_TO_ADDR
// sShield := false ;
110457: LD_ADDR_EXP 194
110461: PUSH
110462: LD_INT 0
110464: ST_TO_ADDR
// sTime := false ;
110465: LD_ADDR_EXP 195
110469: PUSH
110470: LD_INT 0
110472: ST_TO_ADDR
// sTools := false ;
110473: LD_ADDR_EXP 196
110477: PUSH
110478: LD_INT 0
110480: ST_TO_ADDR
// sSold := false ;
110481: LD_ADDR_EXP 161
110485: PUSH
110486: LD_INT 0
110488: ST_TO_ADDR
// sDiff := false ;
110489: LD_ADDR_EXP 162
110493: PUSH
110494: LD_INT 0
110496: ST_TO_ADDR
// sFog := false ;
110497: LD_ADDR_EXP 165
110501: PUSH
110502: LD_INT 0
110504: ST_TO_ADDR
// sReset := false ;
110505: LD_ADDR_EXP 166
110509: PUSH
110510: LD_INT 0
110512: ST_TO_ADDR
// sSun := false ;
110513: LD_ADDR_EXP 167
110517: PUSH
110518: LD_INT 0
110520: ST_TO_ADDR
// sTiger := false ;
110521: LD_ADDR_EXP 163
110525: PUSH
110526: LD_INT 0
110528: ST_TO_ADDR
// sBomb := false ;
110529: LD_ADDR_EXP 164
110533: PUSH
110534: LD_INT 0
110536: ST_TO_ADDR
// sWound := false ;
110537: LD_ADDR_EXP 172
110541: PUSH
110542: LD_INT 0
110544: ST_TO_ADDR
// sBetray := false ;
110545: LD_ADDR_EXP 176
110549: PUSH
110550: LD_INT 0
110552: ST_TO_ADDR
// sContamin := false ;
110553: LD_ADDR_EXP 177
110557: PUSH
110558: LD_INT 0
110560: ST_TO_ADDR
// sOil := false ;
110561: LD_ADDR_EXP 179
110565: PUSH
110566: LD_INT 0
110568: ST_TO_ADDR
// sStu := false ;
110569: LD_ADDR_EXP 183
110573: PUSH
110574: LD_INT 0
110576: ST_TO_ADDR
// sBazooka := false ;
110577: LD_ADDR_EXP 186
110581: PUSH
110582: LD_INT 0
110584: ST_TO_ADDR
// sMortar := false ;
110585: LD_ADDR_EXP 187
110589: PUSH
110590: LD_INT 0
110592: ST_TO_ADDR
// sRanger := false ;
110593: LD_ADDR_EXP 197
110597: PUSH
110598: LD_INT 0
110600: ST_TO_ADDR
// sComputer := false ;
110601: LD_ADDR_EXP 198
110605: PUSH
110606: LD_INT 0
110608: ST_TO_ADDR
// s30 := false ;
110609: LD_ADDR_EXP 199
110613: PUSH
110614: LD_INT 0
110616: ST_TO_ADDR
// s60 := false ;
110617: LD_ADDR_EXP 200
110621: PUSH
110622: LD_INT 0
110624: ST_TO_ADDR
// end ;
110625: LD_VAR 0 1
110629: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110630: LD_INT 0
110632: PPUSH
110633: PPUSH
110634: PPUSH
110635: PPUSH
110636: PPUSH
110637: PPUSH
110638: PPUSH
// result := [ ] ;
110639: LD_ADDR_VAR 0 2
110643: PUSH
110644: EMPTY
110645: ST_TO_ADDR
// if campaign_id = 1 then
110646: LD_OWVAR 69
110650: PUSH
110651: LD_INT 1
110653: EQUAL
110654: IFFALSE 113820
// begin case mission_number of 1 :
110656: LD_OWVAR 70
110660: PUSH
110661: LD_INT 1
110663: DOUBLE
110664: EQUAL
110665: IFTRUE 110669
110667: GO 110745
110669: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110670: LD_ADDR_VAR 0 2
110674: PUSH
110675: LD_INT 2
110677: PUSH
110678: LD_INT 4
110680: PUSH
110681: LD_INT 11
110683: PUSH
110684: LD_INT 12
110686: PUSH
110687: LD_INT 15
110689: PUSH
110690: LD_INT 16
110692: PUSH
110693: LD_INT 22
110695: PUSH
110696: LD_INT 23
110698: PUSH
110699: LD_INT 26
110701: PUSH
110702: EMPTY
110703: LIST
110704: LIST
110705: LIST
110706: LIST
110707: LIST
110708: LIST
110709: LIST
110710: LIST
110711: LIST
110712: PUSH
110713: LD_INT 101
110715: PUSH
110716: LD_INT 102
110718: PUSH
110719: LD_INT 106
110721: PUSH
110722: LD_INT 116
110724: PUSH
110725: LD_INT 117
110727: PUSH
110728: LD_INT 118
110730: PUSH
110731: EMPTY
110732: LIST
110733: LIST
110734: LIST
110735: LIST
110736: LIST
110737: LIST
110738: PUSH
110739: EMPTY
110740: LIST
110741: LIST
110742: ST_TO_ADDR
110743: GO 113818
110745: LD_INT 2
110747: DOUBLE
110748: EQUAL
110749: IFTRUE 110753
110751: GO 110837
110753: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110754: LD_ADDR_VAR 0 2
110758: PUSH
110759: LD_INT 2
110761: PUSH
110762: LD_INT 4
110764: PUSH
110765: LD_INT 11
110767: PUSH
110768: LD_INT 12
110770: PUSH
110771: LD_INT 15
110773: PUSH
110774: LD_INT 16
110776: PUSH
110777: LD_INT 22
110779: PUSH
110780: LD_INT 23
110782: PUSH
110783: LD_INT 26
110785: PUSH
110786: EMPTY
110787: LIST
110788: LIST
110789: LIST
110790: LIST
110791: LIST
110792: LIST
110793: LIST
110794: LIST
110795: LIST
110796: PUSH
110797: LD_INT 101
110799: PUSH
110800: LD_INT 102
110802: PUSH
110803: LD_INT 105
110805: PUSH
110806: LD_INT 106
110808: PUSH
110809: LD_INT 108
110811: PUSH
110812: LD_INT 116
110814: PUSH
110815: LD_INT 117
110817: PUSH
110818: LD_INT 118
110820: PUSH
110821: EMPTY
110822: LIST
110823: LIST
110824: LIST
110825: LIST
110826: LIST
110827: LIST
110828: LIST
110829: LIST
110830: PUSH
110831: EMPTY
110832: LIST
110833: LIST
110834: ST_TO_ADDR
110835: GO 113818
110837: LD_INT 3
110839: DOUBLE
110840: EQUAL
110841: IFTRUE 110845
110843: GO 110933
110845: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
110846: LD_ADDR_VAR 0 2
110850: PUSH
110851: LD_INT 2
110853: PUSH
110854: LD_INT 4
110856: PUSH
110857: LD_INT 5
110859: PUSH
110860: LD_INT 11
110862: PUSH
110863: LD_INT 12
110865: PUSH
110866: LD_INT 15
110868: PUSH
110869: LD_INT 16
110871: PUSH
110872: LD_INT 22
110874: PUSH
110875: LD_INT 26
110877: PUSH
110878: LD_INT 36
110880: PUSH
110881: EMPTY
110882: LIST
110883: LIST
110884: LIST
110885: LIST
110886: LIST
110887: LIST
110888: LIST
110889: LIST
110890: LIST
110891: LIST
110892: PUSH
110893: LD_INT 101
110895: PUSH
110896: LD_INT 102
110898: PUSH
110899: LD_INT 105
110901: PUSH
110902: LD_INT 106
110904: PUSH
110905: LD_INT 108
110907: PUSH
110908: LD_INT 116
110910: PUSH
110911: LD_INT 117
110913: PUSH
110914: LD_INT 118
110916: PUSH
110917: EMPTY
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: LIST
110923: LIST
110924: LIST
110925: LIST
110926: PUSH
110927: EMPTY
110928: LIST
110929: LIST
110930: ST_TO_ADDR
110931: GO 113818
110933: LD_INT 4
110935: DOUBLE
110936: EQUAL
110937: IFTRUE 110941
110939: GO 111037
110941: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
110942: LD_ADDR_VAR 0 2
110946: PUSH
110947: LD_INT 2
110949: PUSH
110950: LD_INT 4
110952: PUSH
110953: LD_INT 5
110955: PUSH
110956: LD_INT 8
110958: PUSH
110959: LD_INT 11
110961: PUSH
110962: LD_INT 12
110964: PUSH
110965: LD_INT 15
110967: PUSH
110968: LD_INT 16
110970: PUSH
110971: LD_INT 22
110973: PUSH
110974: LD_INT 23
110976: PUSH
110977: LD_INT 26
110979: PUSH
110980: LD_INT 36
110982: PUSH
110983: EMPTY
110984: LIST
110985: LIST
110986: LIST
110987: LIST
110988: LIST
110989: LIST
110990: LIST
110991: LIST
110992: LIST
110993: LIST
110994: LIST
110995: LIST
110996: PUSH
110997: LD_INT 101
110999: PUSH
111000: LD_INT 102
111002: PUSH
111003: LD_INT 105
111005: PUSH
111006: LD_INT 106
111008: PUSH
111009: LD_INT 108
111011: PUSH
111012: LD_INT 116
111014: PUSH
111015: LD_INT 117
111017: PUSH
111018: LD_INT 118
111020: PUSH
111021: EMPTY
111022: LIST
111023: LIST
111024: LIST
111025: LIST
111026: LIST
111027: LIST
111028: LIST
111029: LIST
111030: PUSH
111031: EMPTY
111032: LIST
111033: LIST
111034: ST_TO_ADDR
111035: GO 113818
111037: LD_INT 5
111039: DOUBLE
111040: EQUAL
111041: IFTRUE 111045
111043: GO 111157
111045: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
111046: LD_ADDR_VAR 0 2
111050: PUSH
111051: LD_INT 2
111053: PUSH
111054: LD_INT 4
111056: PUSH
111057: LD_INT 5
111059: PUSH
111060: LD_INT 6
111062: PUSH
111063: LD_INT 8
111065: PUSH
111066: LD_INT 11
111068: PUSH
111069: LD_INT 12
111071: PUSH
111072: LD_INT 15
111074: PUSH
111075: LD_INT 16
111077: PUSH
111078: LD_INT 22
111080: PUSH
111081: LD_INT 23
111083: PUSH
111084: LD_INT 25
111086: PUSH
111087: LD_INT 26
111089: PUSH
111090: LD_INT 36
111092: PUSH
111093: EMPTY
111094: LIST
111095: LIST
111096: LIST
111097: LIST
111098: LIST
111099: LIST
111100: LIST
111101: LIST
111102: LIST
111103: LIST
111104: LIST
111105: LIST
111106: LIST
111107: LIST
111108: PUSH
111109: LD_INT 101
111111: PUSH
111112: LD_INT 102
111114: PUSH
111115: LD_INT 105
111117: PUSH
111118: LD_INT 106
111120: PUSH
111121: LD_INT 108
111123: PUSH
111124: LD_INT 109
111126: PUSH
111127: LD_INT 112
111129: PUSH
111130: LD_INT 116
111132: PUSH
111133: LD_INT 117
111135: PUSH
111136: LD_INT 118
111138: PUSH
111139: EMPTY
111140: LIST
111141: LIST
111142: LIST
111143: LIST
111144: LIST
111145: LIST
111146: LIST
111147: LIST
111148: LIST
111149: LIST
111150: PUSH
111151: EMPTY
111152: LIST
111153: LIST
111154: ST_TO_ADDR
111155: GO 113818
111157: LD_INT 6
111159: DOUBLE
111160: EQUAL
111161: IFTRUE 111165
111163: GO 111297
111165: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
111166: LD_ADDR_VAR 0 2
111170: PUSH
111171: LD_INT 2
111173: PUSH
111174: LD_INT 4
111176: PUSH
111177: LD_INT 5
111179: PUSH
111180: LD_INT 6
111182: PUSH
111183: LD_INT 8
111185: PUSH
111186: LD_INT 11
111188: PUSH
111189: LD_INT 12
111191: PUSH
111192: LD_INT 15
111194: PUSH
111195: LD_INT 16
111197: PUSH
111198: LD_INT 20
111200: PUSH
111201: LD_INT 21
111203: PUSH
111204: LD_INT 22
111206: PUSH
111207: LD_INT 23
111209: PUSH
111210: LD_INT 25
111212: PUSH
111213: LD_INT 26
111215: PUSH
111216: LD_INT 30
111218: PUSH
111219: LD_INT 31
111221: PUSH
111222: LD_INT 32
111224: PUSH
111225: LD_INT 36
111227: PUSH
111228: EMPTY
111229: LIST
111230: LIST
111231: LIST
111232: LIST
111233: LIST
111234: LIST
111235: LIST
111236: LIST
111237: LIST
111238: LIST
111239: LIST
111240: LIST
111241: LIST
111242: LIST
111243: LIST
111244: LIST
111245: LIST
111246: LIST
111247: LIST
111248: PUSH
111249: LD_INT 101
111251: PUSH
111252: LD_INT 102
111254: PUSH
111255: LD_INT 105
111257: PUSH
111258: LD_INT 106
111260: PUSH
111261: LD_INT 108
111263: PUSH
111264: LD_INT 109
111266: PUSH
111267: LD_INT 112
111269: PUSH
111270: LD_INT 116
111272: PUSH
111273: LD_INT 117
111275: PUSH
111276: LD_INT 118
111278: PUSH
111279: EMPTY
111280: LIST
111281: LIST
111282: LIST
111283: LIST
111284: LIST
111285: LIST
111286: LIST
111287: LIST
111288: LIST
111289: LIST
111290: PUSH
111291: EMPTY
111292: LIST
111293: LIST
111294: ST_TO_ADDR
111295: GO 113818
111297: LD_INT 7
111299: DOUBLE
111300: EQUAL
111301: IFTRUE 111305
111303: GO 111417
111305: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
111306: LD_ADDR_VAR 0 2
111310: PUSH
111311: LD_INT 2
111313: PUSH
111314: LD_INT 4
111316: PUSH
111317: LD_INT 5
111319: PUSH
111320: LD_INT 7
111322: PUSH
111323: LD_INT 11
111325: PUSH
111326: LD_INT 12
111328: PUSH
111329: LD_INT 15
111331: PUSH
111332: LD_INT 16
111334: PUSH
111335: LD_INT 20
111337: PUSH
111338: LD_INT 21
111340: PUSH
111341: LD_INT 22
111343: PUSH
111344: LD_INT 23
111346: PUSH
111347: LD_INT 25
111349: PUSH
111350: LD_INT 26
111352: PUSH
111353: EMPTY
111354: LIST
111355: LIST
111356: LIST
111357: LIST
111358: LIST
111359: LIST
111360: LIST
111361: LIST
111362: LIST
111363: LIST
111364: LIST
111365: LIST
111366: LIST
111367: LIST
111368: PUSH
111369: LD_INT 101
111371: PUSH
111372: LD_INT 102
111374: PUSH
111375: LD_INT 103
111377: PUSH
111378: LD_INT 105
111380: PUSH
111381: LD_INT 106
111383: PUSH
111384: LD_INT 108
111386: PUSH
111387: LD_INT 112
111389: PUSH
111390: LD_INT 116
111392: PUSH
111393: LD_INT 117
111395: PUSH
111396: LD_INT 118
111398: PUSH
111399: EMPTY
111400: LIST
111401: LIST
111402: LIST
111403: LIST
111404: LIST
111405: LIST
111406: LIST
111407: LIST
111408: LIST
111409: LIST
111410: PUSH
111411: EMPTY
111412: LIST
111413: LIST
111414: ST_TO_ADDR
111415: GO 113818
111417: LD_INT 8
111419: DOUBLE
111420: EQUAL
111421: IFTRUE 111425
111423: GO 111565
111425: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
111426: LD_ADDR_VAR 0 2
111430: PUSH
111431: LD_INT 2
111433: PUSH
111434: LD_INT 4
111436: PUSH
111437: LD_INT 5
111439: PUSH
111440: LD_INT 6
111442: PUSH
111443: LD_INT 7
111445: PUSH
111446: LD_INT 8
111448: PUSH
111449: LD_INT 11
111451: PUSH
111452: LD_INT 12
111454: PUSH
111455: LD_INT 15
111457: PUSH
111458: LD_INT 16
111460: PUSH
111461: LD_INT 20
111463: PUSH
111464: LD_INT 21
111466: PUSH
111467: LD_INT 22
111469: PUSH
111470: LD_INT 23
111472: PUSH
111473: LD_INT 25
111475: PUSH
111476: LD_INT 26
111478: PUSH
111479: LD_INT 30
111481: PUSH
111482: LD_INT 31
111484: PUSH
111485: LD_INT 32
111487: PUSH
111488: LD_INT 36
111490: PUSH
111491: EMPTY
111492: LIST
111493: LIST
111494: LIST
111495: LIST
111496: LIST
111497: LIST
111498: LIST
111499: LIST
111500: LIST
111501: LIST
111502: LIST
111503: LIST
111504: LIST
111505: LIST
111506: LIST
111507: LIST
111508: LIST
111509: LIST
111510: LIST
111511: LIST
111512: PUSH
111513: LD_INT 101
111515: PUSH
111516: LD_INT 102
111518: PUSH
111519: LD_INT 103
111521: PUSH
111522: LD_INT 105
111524: PUSH
111525: LD_INT 106
111527: PUSH
111528: LD_INT 108
111530: PUSH
111531: LD_INT 109
111533: PUSH
111534: LD_INT 112
111536: PUSH
111537: LD_INT 116
111539: PUSH
111540: LD_INT 117
111542: PUSH
111543: LD_INT 118
111545: PUSH
111546: EMPTY
111547: LIST
111548: LIST
111549: LIST
111550: LIST
111551: LIST
111552: LIST
111553: LIST
111554: LIST
111555: LIST
111556: LIST
111557: LIST
111558: PUSH
111559: EMPTY
111560: LIST
111561: LIST
111562: ST_TO_ADDR
111563: GO 113818
111565: LD_INT 9
111567: DOUBLE
111568: EQUAL
111569: IFTRUE 111573
111571: GO 111721
111573: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111574: LD_ADDR_VAR 0 2
111578: PUSH
111579: LD_INT 2
111581: PUSH
111582: LD_INT 4
111584: PUSH
111585: LD_INT 5
111587: PUSH
111588: LD_INT 6
111590: PUSH
111591: LD_INT 7
111593: PUSH
111594: LD_INT 8
111596: PUSH
111597: LD_INT 11
111599: PUSH
111600: LD_INT 12
111602: PUSH
111603: LD_INT 15
111605: PUSH
111606: LD_INT 16
111608: PUSH
111609: LD_INT 20
111611: PUSH
111612: LD_INT 21
111614: PUSH
111615: LD_INT 22
111617: PUSH
111618: LD_INT 23
111620: PUSH
111621: LD_INT 25
111623: PUSH
111624: LD_INT 26
111626: PUSH
111627: LD_INT 28
111629: PUSH
111630: LD_INT 30
111632: PUSH
111633: LD_INT 31
111635: PUSH
111636: LD_INT 32
111638: PUSH
111639: LD_INT 36
111641: PUSH
111642: EMPTY
111643: LIST
111644: LIST
111645: LIST
111646: LIST
111647: LIST
111648: LIST
111649: LIST
111650: LIST
111651: LIST
111652: LIST
111653: LIST
111654: LIST
111655: LIST
111656: LIST
111657: LIST
111658: LIST
111659: LIST
111660: LIST
111661: LIST
111662: LIST
111663: LIST
111664: PUSH
111665: LD_INT 101
111667: PUSH
111668: LD_INT 102
111670: PUSH
111671: LD_INT 103
111673: PUSH
111674: LD_INT 105
111676: PUSH
111677: LD_INT 106
111679: PUSH
111680: LD_INT 108
111682: PUSH
111683: LD_INT 109
111685: PUSH
111686: LD_INT 112
111688: PUSH
111689: LD_INT 114
111691: PUSH
111692: LD_INT 116
111694: PUSH
111695: LD_INT 117
111697: PUSH
111698: LD_INT 118
111700: PUSH
111701: EMPTY
111702: LIST
111703: LIST
111704: LIST
111705: LIST
111706: LIST
111707: LIST
111708: LIST
111709: LIST
111710: LIST
111711: LIST
111712: LIST
111713: LIST
111714: PUSH
111715: EMPTY
111716: LIST
111717: LIST
111718: ST_TO_ADDR
111719: GO 113818
111721: LD_INT 10
111723: DOUBLE
111724: EQUAL
111725: IFTRUE 111729
111727: GO 111925
111729: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111730: LD_ADDR_VAR 0 2
111734: PUSH
111735: LD_INT 2
111737: PUSH
111738: LD_INT 4
111740: PUSH
111741: LD_INT 5
111743: PUSH
111744: LD_INT 6
111746: PUSH
111747: LD_INT 7
111749: PUSH
111750: LD_INT 8
111752: PUSH
111753: LD_INT 9
111755: PUSH
111756: LD_INT 10
111758: PUSH
111759: LD_INT 11
111761: PUSH
111762: LD_INT 12
111764: PUSH
111765: LD_INT 13
111767: PUSH
111768: LD_INT 14
111770: PUSH
111771: LD_INT 15
111773: PUSH
111774: LD_INT 16
111776: PUSH
111777: LD_INT 17
111779: PUSH
111780: LD_INT 18
111782: PUSH
111783: LD_INT 19
111785: PUSH
111786: LD_INT 20
111788: PUSH
111789: LD_INT 21
111791: PUSH
111792: LD_INT 22
111794: PUSH
111795: LD_INT 23
111797: PUSH
111798: LD_INT 24
111800: PUSH
111801: LD_INT 25
111803: PUSH
111804: LD_INT 26
111806: PUSH
111807: LD_INT 28
111809: PUSH
111810: LD_INT 30
111812: PUSH
111813: LD_INT 31
111815: PUSH
111816: LD_INT 32
111818: PUSH
111819: LD_INT 36
111821: PUSH
111822: EMPTY
111823: LIST
111824: LIST
111825: LIST
111826: LIST
111827: LIST
111828: LIST
111829: LIST
111830: LIST
111831: LIST
111832: LIST
111833: LIST
111834: LIST
111835: LIST
111836: LIST
111837: LIST
111838: LIST
111839: LIST
111840: LIST
111841: LIST
111842: LIST
111843: LIST
111844: LIST
111845: LIST
111846: LIST
111847: LIST
111848: LIST
111849: LIST
111850: LIST
111851: LIST
111852: PUSH
111853: LD_INT 101
111855: PUSH
111856: LD_INT 102
111858: PUSH
111859: LD_INT 103
111861: PUSH
111862: LD_INT 104
111864: PUSH
111865: LD_INT 105
111867: PUSH
111868: LD_INT 106
111870: PUSH
111871: LD_INT 107
111873: PUSH
111874: LD_INT 108
111876: PUSH
111877: LD_INT 109
111879: PUSH
111880: LD_INT 110
111882: PUSH
111883: LD_INT 111
111885: PUSH
111886: LD_INT 112
111888: PUSH
111889: LD_INT 114
111891: PUSH
111892: LD_INT 116
111894: PUSH
111895: LD_INT 117
111897: PUSH
111898: LD_INT 118
111900: PUSH
111901: EMPTY
111902: LIST
111903: LIST
111904: LIST
111905: LIST
111906: LIST
111907: LIST
111908: LIST
111909: LIST
111910: LIST
111911: LIST
111912: LIST
111913: LIST
111914: LIST
111915: LIST
111916: LIST
111917: LIST
111918: PUSH
111919: EMPTY
111920: LIST
111921: LIST
111922: ST_TO_ADDR
111923: GO 113818
111925: LD_INT 11
111927: DOUBLE
111928: EQUAL
111929: IFTRUE 111933
111931: GO 112137
111933: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
111934: LD_ADDR_VAR 0 2
111938: PUSH
111939: LD_INT 2
111941: PUSH
111942: LD_INT 3
111944: PUSH
111945: LD_INT 4
111947: PUSH
111948: LD_INT 5
111950: PUSH
111951: LD_INT 6
111953: PUSH
111954: LD_INT 7
111956: PUSH
111957: LD_INT 8
111959: PUSH
111960: LD_INT 9
111962: PUSH
111963: LD_INT 10
111965: PUSH
111966: LD_INT 11
111968: PUSH
111969: LD_INT 12
111971: PUSH
111972: LD_INT 13
111974: PUSH
111975: LD_INT 14
111977: PUSH
111978: LD_INT 15
111980: PUSH
111981: LD_INT 16
111983: PUSH
111984: LD_INT 17
111986: PUSH
111987: LD_INT 18
111989: PUSH
111990: LD_INT 19
111992: PUSH
111993: LD_INT 20
111995: PUSH
111996: LD_INT 21
111998: PUSH
111999: LD_INT 22
112001: PUSH
112002: LD_INT 23
112004: PUSH
112005: LD_INT 24
112007: PUSH
112008: LD_INT 25
112010: PUSH
112011: LD_INT 26
112013: PUSH
112014: LD_INT 28
112016: PUSH
112017: LD_INT 30
112019: PUSH
112020: LD_INT 31
112022: PUSH
112023: LD_INT 32
112025: PUSH
112026: LD_INT 34
112028: PUSH
112029: LD_INT 36
112031: PUSH
112032: EMPTY
112033: LIST
112034: LIST
112035: LIST
112036: LIST
112037: LIST
112038: LIST
112039: LIST
112040: LIST
112041: LIST
112042: LIST
112043: LIST
112044: LIST
112045: LIST
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: LIST
112051: LIST
112052: LIST
112053: LIST
112054: LIST
112055: LIST
112056: LIST
112057: LIST
112058: LIST
112059: LIST
112060: LIST
112061: LIST
112062: LIST
112063: LIST
112064: PUSH
112065: LD_INT 101
112067: PUSH
112068: LD_INT 102
112070: PUSH
112071: LD_INT 103
112073: PUSH
112074: LD_INT 104
112076: PUSH
112077: LD_INT 105
112079: PUSH
112080: LD_INT 106
112082: PUSH
112083: LD_INT 107
112085: PUSH
112086: LD_INT 108
112088: PUSH
112089: LD_INT 109
112091: PUSH
112092: LD_INT 110
112094: PUSH
112095: LD_INT 111
112097: PUSH
112098: LD_INT 112
112100: PUSH
112101: LD_INT 114
112103: PUSH
112104: LD_INT 116
112106: PUSH
112107: LD_INT 117
112109: PUSH
112110: LD_INT 118
112112: PUSH
112113: EMPTY
112114: LIST
112115: LIST
112116: LIST
112117: LIST
112118: LIST
112119: LIST
112120: LIST
112121: LIST
112122: LIST
112123: LIST
112124: LIST
112125: LIST
112126: LIST
112127: LIST
112128: LIST
112129: LIST
112130: PUSH
112131: EMPTY
112132: LIST
112133: LIST
112134: ST_TO_ADDR
112135: GO 113818
112137: LD_INT 12
112139: DOUBLE
112140: EQUAL
112141: IFTRUE 112145
112143: GO 112365
112145: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
112146: LD_ADDR_VAR 0 2
112150: PUSH
112151: LD_INT 1
112153: PUSH
112154: LD_INT 2
112156: PUSH
112157: LD_INT 3
112159: PUSH
112160: LD_INT 4
112162: PUSH
112163: LD_INT 5
112165: PUSH
112166: LD_INT 6
112168: PUSH
112169: LD_INT 7
112171: PUSH
112172: LD_INT 8
112174: PUSH
112175: LD_INT 9
112177: PUSH
112178: LD_INT 10
112180: PUSH
112181: LD_INT 11
112183: PUSH
112184: LD_INT 12
112186: PUSH
112187: LD_INT 13
112189: PUSH
112190: LD_INT 14
112192: PUSH
112193: LD_INT 15
112195: PUSH
112196: LD_INT 16
112198: PUSH
112199: LD_INT 17
112201: PUSH
112202: LD_INT 18
112204: PUSH
112205: LD_INT 19
112207: PUSH
112208: LD_INT 20
112210: PUSH
112211: LD_INT 21
112213: PUSH
112214: LD_INT 22
112216: PUSH
112217: LD_INT 23
112219: PUSH
112220: LD_INT 24
112222: PUSH
112223: LD_INT 25
112225: PUSH
112226: LD_INT 26
112228: PUSH
112229: LD_INT 27
112231: PUSH
112232: LD_INT 28
112234: PUSH
112235: LD_INT 30
112237: PUSH
112238: LD_INT 31
112240: PUSH
112241: LD_INT 32
112243: PUSH
112244: LD_INT 33
112246: PUSH
112247: LD_INT 34
112249: PUSH
112250: LD_INT 36
112252: PUSH
112253: EMPTY
112254: LIST
112255: LIST
112256: LIST
112257: LIST
112258: LIST
112259: LIST
112260: LIST
112261: LIST
112262: LIST
112263: LIST
112264: LIST
112265: LIST
112266: LIST
112267: LIST
112268: LIST
112269: LIST
112270: LIST
112271: LIST
112272: LIST
112273: LIST
112274: LIST
112275: LIST
112276: LIST
112277: LIST
112278: LIST
112279: LIST
112280: LIST
112281: LIST
112282: LIST
112283: LIST
112284: LIST
112285: LIST
112286: LIST
112287: LIST
112288: PUSH
112289: LD_INT 101
112291: PUSH
112292: LD_INT 102
112294: PUSH
112295: LD_INT 103
112297: PUSH
112298: LD_INT 104
112300: PUSH
112301: LD_INT 105
112303: PUSH
112304: LD_INT 106
112306: PUSH
112307: LD_INT 107
112309: PUSH
112310: LD_INT 108
112312: PUSH
112313: LD_INT 109
112315: PUSH
112316: LD_INT 110
112318: PUSH
112319: LD_INT 111
112321: PUSH
112322: LD_INT 112
112324: PUSH
112325: LD_INT 113
112327: PUSH
112328: LD_INT 114
112330: PUSH
112331: LD_INT 116
112333: PUSH
112334: LD_INT 117
112336: PUSH
112337: LD_INT 118
112339: PUSH
112340: EMPTY
112341: LIST
112342: LIST
112343: LIST
112344: LIST
112345: LIST
112346: LIST
112347: LIST
112348: LIST
112349: LIST
112350: LIST
112351: LIST
112352: LIST
112353: LIST
112354: LIST
112355: LIST
112356: LIST
112357: LIST
112358: PUSH
112359: EMPTY
112360: LIST
112361: LIST
112362: ST_TO_ADDR
112363: GO 113818
112365: LD_INT 13
112367: DOUBLE
112368: EQUAL
112369: IFTRUE 112373
112371: GO 112581
112373: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
112374: LD_ADDR_VAR 0 2
112378: PUSH
112379: LD_INT 1
112381: PUSH
112382: LD_INT 2
112384: PUSH
112385: LD_INT 3
112387: PUSH
112388: LD_INT 4
112390: PUSH
112391: LD_INT 5
112393: PUSH
112394: LD_INT 8
112396: PUSH
112397: LD_INT 9
112399: PUSH
112400: LD_INT 10
112402: PUSH
112403: LD_INT 11
112405: PUSH
112406: LD_INT 12
112408: PUSH
112409: LD_INT 14
112411: PUSH
112412: LD_INT 15
112414: PUSH
112415: LD_INT 16
112417: PUSH
112418: LD_INT 17
112420: PUSH
112421: LD_INT 18
112423: PUSH
112424: LD_INT 19
112426: PUSH
112427: LD_INT 20
112429: PUSH
112430: LD_INT 21
112432: PUSH
112433: LD_INT 22
112435: PUSH
112436: LD_INT 23
112438: PUSH
112439: LD_INT 24
112441: PUSH
112442: LD_INT 25
112444: PUSH
112445: LD_INT 26
112447: PUSH
112448: LD_INT 27
112450: PUSH
112451: LD_INT 28
112453: PUSH
112454: LD_INT 30
112456: PUSH
112457: LD_INT 31
112459: PUSH
112460: LD_INT 32
112462: PUSH
112463: LD_INT 33
112465: PUSH
112466: LD_INT 34
112468: PUSH
112469: LD_INT 36
112471: PUSH
112472: EMPTY
112473: LIST
112474: LIST
112475: LIST
112476: LIST
112477: LIST
112478: LIST
112479: LIST
112480: LIST
112481: LIST
112482: LIST
112483: LIST
112484: LIST
112485: LIST
112486: LIST
112487: LIST
112488: LIST
112489: LIST
112490: LIST
112491: LIST
112492: LIST
112493: LIST
112494: LIST
112495: LIST
112496: LIST
112497: LIST
112498: LIST
112499: LIST
112500: LIST
112501: LIST
112502: LIST
112503: LIST
112504: PUSH
112505: LD_INT 101
112507: PUSH
112508: LD_INT 102
112510: PUSH
112511: LD_INT 103
112513: PUSH
112514: LD_INT 104
112516: PUSH
112517: LD_INT 105
112519: PUSH
112520: LD_INT 106
112522: PUSH
112523: LD_INT 107
112525: PUSH
112526: LD_INT 108
112528: PUSH
112529: LD_INT 109
112531: PUSH
112532: LD_INT 110
112534: PUSH
112535: LD_INT 111
112537: PUSH
112538: LD_INT 112
112540: PUSH
112541: LD_INT 113
112543: PUSH
112544: LD_INT 114
112546: PUSH
112547: LD_INT 116
112549: PUSH
112550: LD_INT 117
112552: PUSH
112553: LD_INT 118
112555: PUSH
112556: EMPTY
112557: LIST
112558: LIST
112559: LIST
112560: LIST
112561: LIST
112562: LIST
112563: LIST
112564: LIST
112565: LIST
112566: LIST
112567: LIST
112568: LIST
112569: LIST
112570: LIST
112571: LIST
112572: LIST
112573: LIST
112574: PUSH
112575: EMPTY
112576: LIST
112577: LIST
112578: ST_TO_ADDR
112579: GO 113818
112581: LD_INT 14
112583: DOUBLE
112584: EQUAL
112585: IFTRUE 112589
112587: GO 112813
112589: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112590: LD_ADDR_VAR 0 2
112594: PUSH
112595: LD_INT 1
112597: PUSH
112598: LD_INT 2
112600: PUSH
112601: LD_INT 3
112603: PUSH
112604: LD_INT 4
112606: PUSH
112607: LD_INT 5
112609: PUSH
112610: LD_INT 6
112612: PUSH
112613: LD_INT 7
112615: PUSH
112616: LD_INT 8
112618: PUSH
112619: LD_INT 9
112621: PUSH
112622: LD_INT 10
112624: PUSH
112625: LD_INT 11
112627: PUSH
112628: LD_INT 12
112630: PUSH
112631: LD_INT 13
112633: PUSH
112634: LD_INT 14
112636: PUSH
112637: LD_INT 15
112639: PUSH
112640: LD_INT 16
112642: PUSH
112643: LD_INT 17
112645: PUSH
112646: LD_INT 18
112648: PUSH
112649: LD_INT 19
112651: PUSH
112652: LD_INT 20
112654: PUSH
112655: LD_INT 21
112657: PUSH
112658: LD_INT 22
112660: PUSH
112661: LD_INT 23
112663: PUSH
112664: LD_INT 24
112666: PUSH
112667: LD_INT 25
112669: PUSH
112670: LD_INT 26
112672: PUSH
112673: LD_INT 27
112675: PUSH
112676: LD_INT 28
112678: PUSH
112679: LD_INT 29
112681: PUSH
112682: LD_INT 30
112684: PUSH
112685: LD_INT 31
112687: PUSH
112688: LD_INT 32
112690: PUSH
112691: LD_INT 33
112693: PUSH
112694: LD_INT 34
112696: PUSH
112697: LD_INT 36
112699: PUSH
112700: EMPTY
112701: LIST
112702: LIST
112703: LIST
112704: LIST
112705: LIST
112706: LIST
112707: LIST
112708: LIST
112709: LIST
112710: LIST
112711: LIST
112712: LIST
112713: LIST
112714: LIST
112715: LIST
112716: LIST
112717: LIST
112718: LIST
112719: LIST
112720: LIST
112721: LIST
112722: LIST
112723: LIST
112724: LIST
112725: LIST
112726: LIST
112727: LIST
112728: LIST
112729: LIST
112730: LIST
112731: LIST
112732: LIST
112733: LIST
112734: LIST
112735: LIST
112736: PUSH
112737: LD_INT 101
112739: PUSH
112740: LD_INT 102
112742: PUSH
112743: LD_INT 103
112745: PUSH
112746: LD_INT 104
112748: PUSH
112749: LD_INT 105
112751: PUSH
112752: LD_INT 106
112754: PUSH
112755: LD_INT 107
112757: PUSH
112758: LD_INT 108
112760: PUSH
112761: LD_INT 109
112763: PUSH
112764: LD_INT 110
112766: PUSH
112767: LD_INT 111
112769: PUSH
112770: LD_INT 112
112772: PUSH
112773: LD_INT 113
112775: PUSH
112776: LD_INT 114
112778: PUSH
112779: LD_INT 116
112781: PUSH
112782: LD_INT 117
112784: PUSH
112785: LD_INT 118
112787: PUSH
112788: EMPTY
112789: LIST
112790: LIST
112791: LIST
112792: LIST
112793: LIST
112794: LIST
112795: LIST
112796: LIST
112797: LIST
112798: LIST
112799: LIST
112800: LIST
112801: LIST
112802: LIST
112803: LIST
112804: LIST
112805: LIST
112806: PUSH
112807: EMPTY
112808: LIST
112809: LIST
112810: ST_TO_ADDR
112811: GO 113818
112813: LD_INT 15
112815: DOUBLE
112816: EQUAL
112817: IFTRUE 112821
112819: GO 113045
112821: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
112822: LD_ADDR_VAR 0 2
112826: PUSH
112827: LD_INT 1
112829: PUSH
112830: LD_INT 2
112832: PUSH
112833: LD_INT 3
112835: PUSH
112836: LD_INT 4
112838: PUSH
112839: LD_INT 5
112841: PUSH
112842: LD_INT 6
112844: PUSH
112845: LD_INT 7
112847: PUSH
112848: LD_INT 8
112850: PUSH
112851: LD_INT 9
112853: PUSH
112854: LD_INT 10
112856: PUSH
112857: LD_INT 11
112859: PUSH
112860: LD_INT 12
112862: PUSH
112863: LD_INT 13
112865: PUSH
112866: LD_INT 14
112868: PUSH
112869: LD_INT 15
112871: PUSH
112872: LD_INT 16
112874: PUSH
112875: LD_INT 17
112877: PUSH
112878: LD_INT 18
112880: PUSH
112881: LD_INT 19
112883: PUSH
112884: LD_INT 20
112886: PUSH
112887: LD_INT 21
112889: PUSH
112890: LD_INT 22
112892: PUSH
112893: LD_INT 23
112895: PUSH
112896: LD_INT 24
112898: PUSH
112899: LD_INT 25
112901: PUSH
112902: LD_INT 26
112904: PUSH
112905: LD_INT 27
112907: PUSH
112908: LD_INT 28
112910: PUSH
112911: LD_INT 29
112913: PUSH
112914: LD_INT 30
112916: PUSH
112917: LD_INT 31
112919: PUSH
112920: LD_INT 32
112922: PUSH
112923: LD_INT 33
112925: PUSH
112926: LD_INT 34
112928: PUSH
112929: LD_INT 36
112931: PUSH
112932: EMPTY
112933: LIST
112934: LIST
112935: LIST
112936: LIST
112937: LIST
112938: LIST
112939: LIST
112940: LIST
112941: LIST
112942: LIST
112943: LIST
112944: LIST
112945: LIST
112946: LIST
112947: LIST
112948: LIST
112949: LIST
112950: LIST
112951: LIST
112952: LIST
112953: LIST
112954: LIST
112955: LIST
112956: LIST
112957: LIST
112958: LIST
112959: LIST
112960: LIST
112961: LIST
112962: LIST
112963: LIST
112964: LIST
112965: LIST
112966: LIST
112967: LIST
112968: PUSH
112969: LD_INT 101
112971: PUSH
112972: LD_INT 102
112974: PUSH
112975: LD_INT 103
112977: PUSH
112978: LD_INT 104
112980: PUSH
112981: LD_INT 105
112983: PUSH
112984: LD_INT 106
112986: PUSH
112987: LD_INT 107
112989: PUSH
112990: LD_INT 108
112992: PUSH
112993: LD_INT 109
112995: PUSH
112996: LD_INT 110
112998: PUSH
112999: LD_INT 111
113001: PUSH
113002: LD_INT 112
113004: PUSH
113005: LD_INT 113
113007: PUSH
113008: LD_INT 114
113010: PUSH
113011: LD_INT 116
113013: PUSH
113014: LD_INT 117
113016: PUSH
113017: LD_INT 118
113019: PUSH
113020: EMPTY
113021: LIST
113022: LIST
113023: LIST
113024: LIST
113025: LIST
113026: LIST
113027: LIST
113028: LIST
113029: LIST
113030: LIST
113031: LIST
113032: LIST
113033: LIST
113034: LIST
113035: LIST
113036: LIST
113037: LIST
113038: PUSH
113039: EMPTY
113040: LIST
113041: LIST
113042: ST_TO_ADDR
113043: GO 113818
113045: LD_INT 16
113047: DOUBLE
113048: EQUAL
113049: IFTRUE 113053
113051: GO 113189
113053: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
113054: LD_ADDR_VAR 0 2
113058: PUSH
113059: LD_INT 2
113061: PUSH
113062: LD_INT 4
113064: PUSH
113065: LD_INT 5
113067: PUSH
113068: LD_INT 7
113070: PUSH
113071: LD_INT 11
113073: PUSH
113074: LD_INT 12
113076: PUSH
113077: LD_INT 15
113079: PUSH
113080: LD_INT 16
113082: PUSH
113083: LD_INT 20
113085: PUSH
113086: LD_INT 21
113088: PUSH
113089: LD_INT 22
113091: PUSH
113092: LD_INT 23
113094: PUSH
113095: LD_INT 25
113097: PUSH
113098: LD_INT 26
113100: PUSH
113101: LD_INT 30
113103: PUSH
113104: LD_INT 31
113106: PUSH
113107: LD_INT 32
113109: PUSH
113110: LD_INT 33
113112: PUSH
113113: LD_INT 34
113115: PUSH
113116: EMPTY
113117: LIST
113118: LIST
113119: LIST
113120: LIST
113121: LIST
113122: LIST
113123: LIST
113124: LIST
113125: LIST
113126: LIST
113127: LIST
113128: LIST
113129: LIST
113130: LIST
113131: LIST
113132: LIST
113133: LIST
113134: LIST
113135: LIST
113136: PUSH
113137: LD_INT 101
113139: PUSH
113140: LD_INT 102
113142: PUSH
113143: LD_INT 103
113145: PUSH
113146: LD_INT 106
113148: PUSH
113149: LD_INT 108
113151: PUSH
113152: LD_INT 112
113154: PUSH
113155: LD_INT 113
113157: PUSH
113158: LD_INT 114
113160: PUSH
113161: LD_INT 116
113163: PUSH
113164: LD_INT 117
113166: PUSH
113167: LD_INT 118
113169: PUSH
113170: EMPTY
113171: LIST
113172: LIST
113173: LIST
113174: LIST
113175: LIST
113176: LIST
113177: LIST
113178: LIST
113179: LIST
113180: LIST
113181: LIST
113182: PUSH
113183: EMPTY
113184: LIST
113185: LIST
113186: ST_TO_ADDR
113187: GO 113818
113189: LD_INT 17
113191: DOUBLE
113192: EQUAL
113193: IFTRUE 113197
113195: GO 113421
113197: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
113198: LD_ADDR_VAR 0 2
113202: PUSH
113203: LD_INT 1
113205: PUSH
113206: LD_INT 2
113208: PUSH
113209: LD_INT 3
113211: PUSH
113212: LD_INT 4
113214: PUSH
113215: LD_INT 5
113217: PUSH
113218: LD_INT 6
113220: PUSH
113221: LD_INT 7
113223: PUSH
113224: LD_INT 8
113226: PUSH
113227: LD_INT 9
113229: PUSH
113230: LD_INT 10
113232: PUSH
113233: LD_INT 11
113235: PUSH
113236: LD_INT 12
113238: PUSH
113239: LD_INT 13
113241: PUSH
113242: LD_INT 14
113244: PUSH
113245: LD_INT 15
113247: PUSH
113248: LD_INT 16
113250: PUSH
113251: LD_INT 17
113253: PUSH
113254: LD_INT 18
113256: PUSH
113257: LD_INT 19
113259: PUSH
113260: LD_INT 20
113262: PUSH
113263: LD_INT 21
113265: PUSH
113266: LD_INT 22
113268: PUSH
113269: LD_INT 23
113271: PUSH
113272: LD_INT 24
113274: PUSH
113275: LD_INT 25
113277: PUSH
113278: LD_INT 26
113280: PUSH
113281: LD_INT 27
113283: PUSH
113284: LD_INT 28
113286: PUSH
113287: LD_INT 29
113289: PUSH
113290: LD_INT 30
113292: PUSH
113293: LD_INT 31
113295: PUSH
113296: LD_INT 32
113298: PUSH
113299: LD_INT 33
113301: PUSH
113302: LD_INT 34
113304: PUSH
113305: LD_INT 36
113307: PUSH
113308: EMPTY
113309: LIST
113310: LIST
113311: LIST
113312: LIST
113313: LIST
113314: LIST
113315: LIST
113316: LIST
113317: LIST
113318: LIST
113319: LIST
113320: LIST
113321: LIST
113322: LIST
113323: LIST
113324: LIST
113325: LIST
113326: LIST
113327: LIST
113328: LIST
113329: LIST
113330: LIST
113331: LIST
113332: LIST
113333: LIST
113334: LIST
113335: LIST
113336: LIST
113337: LIST
113338: LIST
113339: LIST
113340: LIST
113341: LIST
113342: LIST
113343: LIST
113344: PUSH
113345: LD_INT 101
113347: PUSH
113348: LD_INT 102
113350: PUSH
113351: LD_INT 103
113353: PUSH
113354: LD_INT 104
113356: PUSH
113357: LD_INT 105
113359: PUSH
113360: LD_INT 106
113362: PUSH
113363: LD_INT 107
113365: PUSH
113366: LD_INT 108
113368: PUSH
113369: LD_INT 109
113371: PUSH
113372: LD_INT 110
113374: PUSH
113375: LD_INT 111
113377: PUSH
113378: LD_INT 112
113380: PUSH
113381: LD_INT 113
113383: PUSH
113384: LD_INT 114
113386: PUSH
113387: LD_INT 116
113389: PUSH
113390: LD_INT 117
113392: PUSH
113393: LD_INT 118
113395: PUSH
113396: EMPTY
113397: LIST
113398: LIST
113399: LIST
113400: LIST
113401: LIST
113402: LIST
113403: LIST
113404: LIST
113405: LIST
113406: LIST
113407: LIST
113408: LIST
113409: LIST
113410: LIST
113411: LIST
113412: LIST
113413: LIST
113414: PUSH
113415: EMPTY
113416: LIST
113417: LIST
113418: ST_TO_ADDR
113419: GO 113818
113421: LD_INT 18
113423: DOUBLE
113424: EQUAL
113425: IFTRUE 113429
113427: GO 113577
113429: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
113430: LD_ADDR_VAR 0 2
113434: PUSH
113435: LD_INT 2
113437: PUSH
113438: LD_INT 4
113440: PUSH
113441: LD_INT 5
113443: PUSH
113444: LD_INT 7
113446: PUSH
113447: LD_INT 11
113449: PUSH
113450: LD_INT 12
113452: PUSH
113453: LD_INT 15
113455: PUSH
113456: LD_INT 16
113458: PUSH
113459: LD_INT 20
113461: PUSH
113462: LD_INT 21
113464: PUSH
113465: LD_INT 22
113467: PUSH
113468: LD_INT 23
113470: PUSH
113471: LD_INT 25
113473: PUSH
113474: LD_INT 26
113476: PUSH
113477: LD_INT 30
113479: PUSH
113480: LD_INT 31
113482: PUSH
113483: LD_INT 32
113485: PUSH
113486: LD_INT 33
113488: PUSH
113489: LD_INT 34
113491: PUSH
113492: LD_INT 35
113494: PUSH
113495: LD_INT 36
113497: PUSH
113498: EMPTY
113499: LIST
113500: LIST
113501: LIST
113502: LIST
113503: LIST
113504: LIST
113505: LIST
113506: LIST
113507: LIST
113508: LIST
113509: LIST
113510: LIST
113511: LIST
113512: LIST
113513: LIST
113514: LIST
113515: LIST
113516: LIST
113517: LIST
113518: LIST
113519: LIST
113520: PUSH
113521: LD_INT 101
113523: PUSH
113524: LD_INT 102
113526: PUSH
113527: LD_INT 103
113529: PUSH
113530: LD_INT 106
113532: PUSH
113533: LD_INT 108
113535: PUSH
113536: LD_INT 112
113538: PUSH
113539: LD_INT 113
113541: PUSH
113542: LD_INT 114
113544: PUSH
113545: LD_INT 115
113547: PUSH
113548: LD_INT 116
113550: PUSH
113551: LD_INT 117
113553: PUSH
113554: LD_INT 118
113556: PUSH
113557: EMPTY
113558: LIST
113559: LIST
113560: LIST
113561: LIST
113562: LIST
113563: LIST
113564: LIST
113565: LIST
113566: LIST
113567: LIST
113568: LIST
113569: LIST
113570: PUSH
113571: EMPTY
113572: LIST
113573: LIST
113574: ST_TO_ADDR
113575: GO 113818
113577: LD_INT 19
113579: DOUBLE
113580: EQUAL
113581: IFTRUE 113585
113583: GO 113817
113585: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113586: LD_ADDR_VAR 0 2
113590: PUSH
113591: LD_INT 1
113593: PUSH
113594: LD_INT 2
113596: PUSH
113597: LD_INT 3
113599: PUSH
113600: LD_INT 4
113602: PUSH
113603: LD_INT 5
113605: PUSH
113606: LD_INT 6
113608: PUSH
113609: LD_INT 7
113611: PUSH
113612: LD_INT 8
113614: PUSH
113615: LD_INT 9
113617: PUSH
113618: LD_INT 10
113620: PUSH
113621: LD_INT 11
113623: PUSH
113624: LD_INT 12
113626: PUSH
113627: LD_INT 13
113629: PUSH
113630: LD_INT 14
113632: PUSH
113633: LD_INT 15
113635: PUSH
113636: LD_INT 16
113638: PUSH
113639: LD_INT 17
113641: PUSH
113642: LD_INT 18
113644: PUSH
113645: LD_INT 19
113647: PUSH
113648: LD_INT 20
113650: PUSH
113651: LD_INT 21
113653: PUSH
113654: LD_INT 22
113656: PUSH
113657: LD_INT 23
113659: PUSH
113660: LD_INT 24
113662: PUSH
113663: LD_INT 25
113665: PUSH
113666: LD_INT 26
113668: PUSH
113669: LD_INT 27
113671: PUSH
113672: LD_INT 28
113674: PUSH
113675: LD_INT 29
113677: PUSH
113678: LD_INT 30
113680: PUSH
113681: LD_INT 31
113683: PUSH
113684: LD_INT 32
113686: PUSH
113687: LD_INT 33
113689: PUSH
113690: LD_INT 34
113692: PUSH
113693: LD_INT 35
113695: PUSH
113696: LD_INT 36
113698: PUSH
113699: EMPTY
113700: LIST
113701: LIST
113702: LIST
113703: LIST
113704: LIST
113705: LIST
113706: LIST
113707: LIST
113708: LIST
113709: LIST
113710: LIST
113711: LIST
113712: LIST
113713: LIST
113714: LIST
113715: LIST
113716: LIST
113717: LIST
113718: LIST
113719: LIST
113720: LIST
113721: LIST
113722: LIST
113723: LIST
113724: LIST
113725: LIST
113726: LIST
113727: LIST
113728: LIST
113729: LIST
113730: LIST
113731: LIST
113732: LIST
113733: LIST
113734: LIST
113735: LIST
113736: PUSH
113737: LD_INT 101
113739: PUSH
113740: LD_INT 102
113742: PUSH
113743: LD_INT 103
113745: PUSH
113746: LD_INT 104
113748: PUSH
113749: LD_INT 105
113751: PUSH
113752: LD_INT 106
113754: PUSH
113755: LD_INT 107
113757: PUSH
113758: LD_INT 108
113760: PUSH
113761: LD_INT 109
113763: PUSH
113764: LD_INT 110
113766: PUSH
113767: LD_INT 111
113769: PUSH
113770: LD_INT 112
113772: PUSH
113773: LD_INT 113
113775: PUSH
113776: LD_INT 114
113778: PUSH
113779: LD_INT 115
113781: PUSH
113782: LD_INT 116
113784: PUSH
113785: LD_INT 117
113787: PUSH
113788: LD_INT 118
113790: PUSH
113791: EMPTY
113792: LIST
113793: LIST
113794: LIST
113795: LIST
113796: LIST
113797: LIST
113798: LIST
113799: LIST
113800: LIST
113801: LIST
113802: LIST
113803: LIST
113804: LIST
113805: LIST
113806: LIST
113807: LIST
113808: LIST
113809: LIST
113810: PUSH
113811: EMPTY
113812: LIST
113813: LIST
113814: ST_TO_ADDR
113815: GO 113818
113817: POP
// end else
113818: GO 114049
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
113820: LD_ADDR_VAR 0 2
113824: PUSH
113825: LD_INT 1
113827: PUSH
113828: LD_INT 2
113830: PUSH
113831: LD_INT 3
113833: PUSH
113834: LD_INT 4
113836: PUSH
113837: LD_INT 5
113839: PUSH
113840: LD_INT 6
113842: PUSH
113843: LD_INT 7
113845: PUSH
113846: LD_INT 8
113848: PUSH
113849: LD_INT 9
113851: PUSH
113852: LD_INT 10
113854: PUSH
113855: LD_INT 11
113857: PUSH
113858: LD_INT 12
113860: PUSH
113861: LD_INT 13
113863: PUSH
113864: LD_INT 14
113866: PUSH
113867: LD_INT 15
113869: PUSH
113870: LD_INT 16
113872: PUSH
113873: LD_INT 17
113875: PUSH
113876: LD_INT 18
113878: PUSH
113879: LD_INT 19
113881: PUSH
113882: LD_INT 20
113884: PUSH
113885: LD_INT 21
113887: PUSH
113888: LD_INT 22
113890: PUSH
113891: LD_INT 23
113893: PUSH
113894: LD_INT 24
113896: PUSH
113897: LD_INT 25
113899: PUSH
113900: LD_INT 26
113902: PUSH
113903: LD_INT 27
113905: PUSH
113906: LD_INT 28
113908: PUSH
113909: LD_INT 29
113911: PUSH
113912: LD_INT 30
113914: PUSH
113915: LD_INT 31
113917: PUSH
113918: LD_INT 32
113920: PUSH
113921: LD_INT 33
113923: PUSH
113924: LD_INT 34
113926: PUSH
113927: LD_INT 35
113929: PUSH
113930: LD_INT 36
113932: PUSH
113933: EMPTY
113934: LIST
113935: LIST
113936: LIST
113937: LIST
113938: LIST
113939: LIST
113940: LIST
113941: LIST
113942: LIST
113943: LIST
113944: LIST
113945: LIST
113946: LIST
113947: LIST
113948: LIST
113949: LIST
113950: LIST
113951: LIST
113952: LIST
113953: LIST
113954: LIST
113955: LIST
113956: LIST
113957: LIST
113958: LIST
113959: LIST
113960: LIST
113961: LIST
113962: LIST
113963: LIST
113964: LIST
113965: LIST
113966: LIST
113967: LIST
113968: LIST
113969: LIST
113970: PUSH
113971: LD_INT 101
113973: PUSH
113974: LD_INT 102
113976: PUSH
113977: LD_INT 103
113979: PUSH
113980: LD_INT 104
113982: PUSH
113983: LD_INT 105
113985: PUSH
113986: LD_INT 106
113988: PUSH
113989: LD_INT 107
113991: PUSH
113992: LD_INT 108
113994: PUSH
113995: LD_INT 109
113997: PUSH
113998: LD_INT 110
114000: PUSH
114001: LD_INT 111
114003: PUSH
114004: LD_INT 112
114006: PUSH
114007: LD_INT 113
114009: PUSH
114010: LD_INT 114
114012: PUSH
114013: LD_INT 115
114015: PUSH
114016: LD_INT 116
114018: PUSH
114019: LD_INT 117
114021: PUSH
114022: LD_INT 118
114024: PUSH
114025: EMPTY
114026: LIST
114027: LIST
114028: LIST
114029: LIST
114030: LIST
114031: LIST
114032: LIST
114033: LIST
114034: LIST
114035: LIST
114036: LIST
114037: LIST
114038: LIST
114039: LIST
114040: LIST
114041: LIST
114042: LIST
114043: LIST
114044: PUSH
114045: EMPTY
114046: LIST
114047: LIST
114048: ST_TO_ADDR
// if result then
114049: LD_VAR 0 2
114053: IFFALSE 114839
// begin normal :=  ;
114055: LD_ADDR_VAR 0 5
114059: PUSH
114060: LD_STRING 
114062: ST_TO_ADDR
// hardcore :=  ;
114063: LD_ADDR_VAR 0 6
114067: PUSH
114068: LD_STRING 
114070: ST_TO_ADDR
// active :=  ;
114071: LD_ADDR_VAR 0 7
114075: PUSH
114076: LD_STRING 
114078: ST_TO_ADDR
// for i = 1 to normalCounter do
114079: LD_ADDR_VAR 0 8
114083: PUSH
114084: DOUBLE
114085: LD_INT 1
114087: DEC
114088: ST_TO_ADDR
114089: LD_EXP 145
114093: PUSH
114094: FOR_TO
114095: IFFALSE 114196
// begin tmp := 0 ;
114097: LD_ADDR_VAR 0 3
114101: PUSH
114102: LD_STRING 0
114104: ST_TO_ADDR
// if result [ 1 ] then
114105: LD_VAR 0 2
114109: PUSH
114110: LD_INT 1
114112: ARRAY
114113: IFFALSE 114178
// if result [ 1 ] [ 1 ] = i then
114115: LD_VAR 0 2
114119: PUSH
114120: LD_INT 1
114122: ARRAY
114123: PUSH
114124: LD_INT 1
114126: ARRAY
114127: PUSH
114128: LD_VAR 0 8
114132: EQUAL
114133: IFFALSE 114178
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
114135: LD_ADDR_VAR 0 2
114139: PUSH
114140: LD_VAR 0 2
114144: PPUSH
114145: LD_INT 1
114147: PPUSH
114148: LD_VAR 0 2
114152: PUSH
114153: LD_INT 1
114155: ARRAY
114156: PPUSH
114157: LD_INT 1
114159: PPUSH
114160: CALL_OW 3
114164: PPUSH
114165: CALL_OW 1
114169: ST_TO_ADDR
// tmp := 1 ;
114170: LD_ADDR_VAR 0 3
114174: PUSH
114175: LD_STRING 1
114177: ST_TO_ADDR
// end ; normal := normal & tmp ;
114178: LD_ADDR_VAR 0 5
114182: PUSH
114183: LD_VAR 0 5
114187: PUSH
114188: LD_VAR 0 3
114192: STR
114193: ST_TO_ADDR
// end ;
114194: GO 114094
114196: POP
114197: POP
// for i = 1 to hardcoreCounter do
114198: LD_ADDR_VAR 0 8
114202: PUSH
114203: DOUBLE
114204: LD_INT 1
114206: DEC
114207: ST_TO_ADDR
114208: LD_EXP 146
114212: PUSH
114213: FOR_TO
114214: IFFALSE 114319
// begin tmp := 0 ;
114216: LD_ADDR_VAR 0 3
114220: PUSH
114221: LD_STRING 0
114223: ST_TO_ADDR
// if result [ 2 ] then
114224: LD_VAR 0 2
114228: PUSH
114229: LD_INT 2
114231: ARRAY
114232: IFFALSE 114301
// if result [ 2 ] [ 1 ] = 100 + i then
114234: LD_VAR 0 2
114238: PUSH
114239: LD_INT 2
114241: ARRAY
114242: PUSH
114243: LD_INT 1
114245: ARRAY
114246: PUSH
114247: LD_INT 100
114249: PUSH
114250: LD_VAR 0 8
114254: PLUS
114255: EQUAL
114256: IFFALSE 114301
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
114258: LD_ADDR_VAR 0 2
114262: PUSH
114263: LD_VAR 0 2
114267: PPUSH
114268: LD_INT 2
114270: PPUSH
114271: LD_VAR 0 2
114275: PUSH
114276: LD_INT 2
114278: ARRAY
114279: PPUSH
114280: LD_INT 1
114282: PPUSH
114283: CALL_OW 3
114287: PPUSH
114288: CALL_OW 1
114292: ST_TO_ADDR
// tmp := 1 ;
114293: LD_ADDR_VAR 0 3
114297: PUSH
114298: LD_STRING 1
114300: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
114301: LD_ADDR_VAR 0 6
114305: PUSH
114306: LD_VAR 0 6
114310: PUSH
114311: LD_VAR 0 3
114315: STR
114316: ST_TO_ADDR
// end ;
114317: GO 114213
114319: POP
114320: POP
// if isGameLoad then
114321: LD_VAR 0 1
114325: IFFALSE 114800
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
114327: LD_ADDR_VAR 0 4
114331: PUSH
114332: LD_EXP 149
114336: PUSH
114337: LD_EXP 148
114341: PUSH
114342: LD_EXP 150
114346: PUSH
114347: LD_EXP 147
114351: PUSH
114352: LD_EXP 151
114356: PUSH
114357: LD_EXP 152
114361: PUSH
114362: LD_EXP 153
114366: PUSH
114367: LD_EXP 154
114371: PUSH
114372: LD_EXP 155
114376: PUSH
114377: LD_EXP 156
114381: PUSH
114382: LD_EXP 157
114386: PUSH
114387: LD_EXP 158
114391: PUSH
114392: LD_EXP 159
114396: PUSH
114397: LD_EXP 160
114401: PUSH
114402: LD_EXP 168
114406: PUSH
114407: LD_EXP 169
114411: PUSH
114412: LD_EXP 170
114416: PUSH
114417: LD_EXP 171
114421: PUSH
114422: LD_EXP 173
114426: PUSH
114427: LD_EXP 174
114431: PUSH
114432: LD_EXP 175
114436: PUSH
114437: LD_EXP 178
114441: PUSH
114442: LD_EXP 180
114446: PUSH
114447: LD_EXP 181
114451: PUSH
114452: LD_EXP 182
114456: PUSH
114457: LD_EXP 184
114461: PUSH
114462: LD_EXP 185
114466: PUSH
114467: LD_EXP 188
114471: PUSH
114472: LD_EXP 189
114476: PUSH
114477: LD_EXP 190
114481: PUSH
114482: LD_EXP 191
114486: PUSH
114487: LD_EXP 192
114491: PUSH
114492: LD_EXP 193
114496: PUSH
114497: LD_EXP 194
114501: PUSH
114502: LD_EXP 195
114506: PUSH
114507: LD_EXP 196
114511: PUSH
114512: LD_EXP 161
114516: PUSH
114517: LD_EXP 162
114521: PUSH
114522: LD_EXP 165
114526: PUSH
114527: LD_EXP 166
114531: PUSH
114532: LD_EXP 167
114536: PUSH
114537: LD_EXP 163
114541: PUSH
114542: LD_EXP 164
114546: PUSH
114547: LD_EXP 172
114551: PUSH
114552: LD_EXP 176
114556: PUSH
114557: LD_EXP 177
114561: PUSH
114562: LD_EXP 179
114566: PUSH
114567: LD_EXP 183
114571: PUSH
114572: LD_EXP 186
114576: PUSH
114577: LD_EXP 187
114581: PUSH
114582: LD_EXP 197
114586: PUSH
114587: LD_EXP 198
114591: PUSH
114592: LD_EXP 199
114596: PUSH
114597: LD_EXP 200
114601: PUSH
114602: EMPTY
114603: LIST
114604: LIST
114605: LIST
114606: LIST
114607: LIST
114608: LIST
114609: LIST
114610: LIST
114611: LIST
114612: LIST
114613: LIST
114614: LIST
114615: LIST
114616: LIST
114617: LIST
114618: LIST
114619: LIST
114620: LIST
114621: LIST
114622: LIST
114623: LIST
114624: LIST
114625: LIST
114626: LIST
114627: LIST
114628: LIST
114629: LIST
114630: LIST
114631: LIST
114632: LIST
114633: LIST
114634: LIST
114635: LIST
114636: LIST
114637: LIST
114638: LIST
114639: LIST
114640: LIST
114641: LIST
114642: LIST
114643: LIST
114644: LIST
114645: LIST
114646: LIST
114647: LIST
114648: LIST
114649: LIST
114650: LIST
114651: LIST
114652: LIST
114653: LIST
114654: LIST
114655: LIST
114656: LIST
114657: ST_TO_ADDR
// tmp :=  ;
114658: LD_ADDR_VAR 0 3
114662: PUSH
114663: LD_STRING 
114665: ST_TO_ADDR
// for i = 1 to normalCounter do
114666: LD_ADDR_VAR 0 8
114670: PUSH
114671: DOUBLE
114672: LD_INT 1
114674: DEC
114675: ST_TO_ADDR
114676: LD_EXP 145
114680: PUSH
114681: FOR_TO
114682: IFFALSE 114718
// begin if flags [ i ] then
114684: LD_VAR 0 4
114688: PUSH
114689: LD_VAR 0 8
114693: ARRAY
114694: IFFALSE 114716
// tmp := tmp & i & ; ;
114696: LD_ADDR_VAR 0 3
114700: PUSH
114701: LD_VAR 0 3
114705: PUSH
114706: LD_VAR 0 8
114710: STR
114711: PUSH
114712: LD_STRING ;
114714: STR
114715: ST_TO_ADDR
// end ;
114716: GO 114681
114718: POP
114719: POP
// for i = 1 to hardcoreCounter do
114720: LD_ADDR_VAR 0 8
114724: PUSH
114725: DOUBLE
114726: LD_INT 1
114728: DEC
114729: ST_TO_ADDR
114730: LD_EXP 146
114734: PUSH
114735: FOR_TO
114736: IFFALSE 114782
// begin if flags [ normalCounter + i ] then
114738: LD_VAR 0 4
114742: PUSH
114743: LD_EXP 145
114747: PUSH
114748: LD_VAR 0 8
114752: PLUS
114753: ARRAY
114754: IFFALSE 114780
// tmp := tmp & ( 100 + i ) & ; ;
114756: LD_ADDR_VAR 0 3
114760: PUSH
114761: LD_VAR 0 3
114765: PUSH
114766: LD_INT 100
114768: PUSH
114769: LD_VAR 0 8
114773: PLUS
114774: STR
114775: PUSH
114776: LD_STRING ;
114778: STR
114779: ST_TO_ADDR
// end ;
114780: GO 114735
114782: POP
114783: POP
// if tmp then
114784: LD_VAR 0 3
114788: IFFALSE 114800
// active := tmp ;
114790: LD_ADDR_VAR 0 7
114794: PUSH
114795: LD_VAR 0 3
114799: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
114800: LD_STRING getStreamItemsFromMission("
114802: PUSH
114803: LD_VAR 0 5
114807: STR
114808: PUSH
114809: LD_STRING ","
114811: STR
114812: PUSH
114813: LD_VAR 0 6
114817: STR
114818: PUSH
114819: LD_STRING ","
114821: STR
114822: PUSH
114823: LD_VAR 0 7
114827: STR
114828: PUSH
114829: LD_STRING ")
114831: STR
114832: PPUSH
114833: CALL_OW 559
// end else
114837: GO 114846
// ToLua ( getStreamItemsFromMission("","","") ) ;
114839: LD_STRING getStreamItemsFromMission("","","")
114841: PPUSH
114842: CALL_OW 559
// end ;
114846: LD_VAR 0 2
114850: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
114851: LD_EXP 144
114855: PUSH
114856: LD_EXP 149
114860: AND
114861: IFFALSE 114985
114863: GO 114865
114865: DISABLE
114866: LD_INT 0
114868: PPUSH
114869: PPUSH
// begin enable ;
114870: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
114871: LD_ADDR_VAR 0 2
114875: PUSH
114876: LD_INT 22
114878: PUSH
114879: LD_OWVAR 2
114883: PUSH
114884: EMPTY
114885: LIST
114886: LIST
114887: PUSH
114888: LD_INT 2
114890: PUSH
114891: LD_INT 34
114893: PUSH
114894: LD_INT 7
114896: PUSH
114897: EMPTY
114898: LIST
114899: LIST
114900: PUSH
114901: LD_INT 34
114903: PUSH
114904: LD_INT 45
114906: PUSH
114907: EMPTY
114908: LIST
114909: LIST
114910: PUSH
114911: LD_INT 34
114913: PUSH
114914: LD_INT 28
114916: PUSH
114917: EMPTY
114918: LIST
114919: LIST
114920: PUSH
114921: LD_INT 34
114923: PUSH
114924: LD_INT 47
114926: PUSH
114927: EMPTY
114928: LIST
114929: LIST
114930: PUSH
114931: EMPTY
114932: LIST
114933: LIST
114934: LIST
114935: LIST
114936: LIST
114937: PUSH
114938: EMPTY
114939: LIST
114940: LIST
114941: PPUSH
114942: CALL_OW 69
114946: ST_TO_ADDR
// if not tmp then
114947: LD_VAR 0 2
114951: NOT
114952: IFFALSE 114956
// exit ;
114954: GO 114985
// for i in tmp do
114956: LD_ADDR_VAR 0 1
114960: PUSH
114961: LD_VAR 0 2
114965: PUSH
114966: FOR_IN
114967: IFFALSE 114983
// begin SetLives ( i , 0 ) ;
114969: LD_VAR 0 1
114973: PPUSH
114974: LD_INT 0
114976: PPUSH
114977: CALL_OW 234
// end ;
114981: GO 114966
114983: POP
114984: POP
// end ;
114985: PPOPN 2
114987: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
114988: LD_EXP 144
114992: PUSH
114993: LD_EXP 150
114997: AND
114998: IFFALSE 115082
115000: GO 115002
115002: DISABLE
115003: LD_INT 0
115005: PPUSH
115006: PPUSH
// begin enable ;
115007: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
115008: LD_ADDR_VAR 0 2
115012: PUSH
115013: LD_INT 22
115015: PUSH
115016: LD_OWVAR 2
115020: PUSH
115021: EMPTY
115022: LIST
115023: LIST
115024: PUSH
115025: LD_INT 32
115027: PUSH
115028: LD_INT 3
115030: PUSH
115031: EMPTY
115032: LIST
115033: LIST
115034: PUSH
115035: EMPTY
115036: LIST
115037: LIST
115038: PPUSH
115039: CALL_OW 69
115043: ST_TO_ADDR
// if not tmp then
115044: LD_VAR 0 2
115048: NOT
115049: IFFALSE 115053
// exit ;
115051: GO 115082
// for i in tmp do
115053: LD_ADDR_VAR 0 1
115057: PUSH
115058: LD_VAR 0 2
115062: PUSH
115063: FOR_IN
115064: IFFALSE 115080
// begin SetLives ( i , 0 ) ;
115066: LD_VAR 0 1
115070: PPUSH
115071: LD_INT 0
115073: PPUSH
115074: CALL_OW 234
// end ;
115078: GO 115063
115080: POP
115081: POP
// end ;
115082: PPOPN 2
115084: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
115085: LD_EXP 144
115089: PUSH
115090: LD_EXP 147
115094: AND
115095: IFFALSE 115188
115097: GO 115099
115099: DISABLE
115100: LD_INT 0
115102: PPUSH
// begin enable ;
115103: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
115104: LD_ADDR_VAR 0 1
115108: PUSH
115109: LD_INT 22
115111: PUSH
115112: LD_OWVAR 2
115116: PUSH
115117: EMPTY
115118: LIST
115119: LIST
115120: PUSH
115121: LD_INT 2
115123: PUSH
115124: LD_INT 25
115126: PUSH
115127: LD_INT 5
115129: PUSH
115130: EMPTY
115131: LIST
115132: LIST
115133: PUSH
115134: LD_INT 25
115136: PUSH
115137: LD_INT 9
115139: PUSH
115140: EMPTY
115141: LIST
115142: LIST
115143: PUSH
115144: LD_INT 25
115146: PUSH
115147: LD_INT 8
115149: PUSH
115150: EMPTY
115151: LIST
115152: LIST
115153: PUSH
115154: EMPTY
115155: LIST
115156: LIST
115157: LIST
115158: LIST
115159: PUSH
115160: EMPTY
115161: LIST
115162: LIST
115163: PPUSH
115164: CALL_OW 69
115168: PUSH
115169: FOR_IN
115170: IFFALSE 115186
// begin SetClass ( i , 1 ) ;
115172: LD_VAR 0 1
115176: PPUSH
115177: LD_INT 1
115179: PPUSH
115180: CALL_OW 336
// end ;
115184: GO 115169
115186: POP
115187: POP
// end ;
115188: PPOPN 1
115190: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
115191: LD_EXP 144
115195: PUSH
115196: LD_EXP 148
115200: AND
115201: PUSH
115202: LD_OWVAR 65
115206: PUSH
115207: LD_INT 7
115209: LESS
115210: AND
115211: IFFALSE 115225
115213: GO 115215
115215: DISABLE
// begin enable ;
115216: ENABLE
// game_speed := 7 ;
115217: LD_ADDR_OWVAR 65
115221: PUSH
115222: LD_INT 7
115224: ST_TO_ADDR
// end ;
115225: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
115226: LD_EXP 144
115230: PUSH
115231: LD_EXP 151
115235: AND
115236: IFFALSE 115438
115238: GO 115240
115240: DISABLE
115241: LD_INT 0
115243: PPUSH
115244: PPUSH
115245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
115246: LD_ADDR_VAR 0 3
115250: PUSH
115251: LD_INT 81
115253: PUSH
115254: LD_OWVAR 2
115258: PUSH
115259: EMPTY
115260: LIST
115261: LIST
115262: PUSH
115263: LD_INT 21
115265: PUSH
115266: LD_INT 1
115268: PUSH
115269: EMPTY
115270: LIST
115271: LIST
115272: PUSH
115273: EMPTY
115274: LIST
115275: LIST
115276: PPUSH
115277: CALL_OW 69
115281: ST_TO_ADDR
// if not tmp then
115282: LD_VAR 0 3
115286: NOT
115287: IFFALSE 115291
// exit ;
115289: GO 115438
// if tmp > 5 then
115291: LD_VAR 0 3
115295: PUSH
115296: LD_INT 5
115298: GREATER
115299: IFFALSE 115311
// k := 5 else
115301: LD_ADDR_VAR 0 2
115305: PUSH
115306: LD_INT 5
115308: ST_TO_ADDR
115309: GO 115321
// k := tmp ;
115311: LD_ADDR_VAR 0 2
115315: PUSH
115316: LD_VAR 0 3
115320: ST_TO_ADDR
// for i := 1 to k do
115321: LD_ADDR_VAR 0 1
115325: PUSH
115326: DOUBLE
115327: LD_INT 1
115329: DEC
115330: ST_TO_ADDR
115331: LD_VAR 0 2
115335: PUSH
115336: FOR_TO
115337: IFFALSE 115436
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
115339: LD_VAR 0 3
115343: PUSH
115344: LD_VAR 0 1
115348: ARRAY
115349: PPUSH
115350: LD_VAR 0 1
115354: PUSH
115355: LD_INT 4
115357: MOD
115358: PUSH
115359: LD_INT 1
115361: PLUS
115362: PPUSH
115363: CALL_OW 259
115367: PUSH
115368: LD_INT 10
115370: LESS
115371: IFFALSE 115434
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
115373: LD_VAR 0 3
115377: PUSH
115378: LD_VAR 0 1
115382: ARRAY
115383: PPUSH
115384: LD_VAR 0 1
115388: PUSH
115389: LD_INT 4
115391: MOD
115392: PUSH
115393: LD_INT 1
115395: PLUS
115396: PPUSH
115397: LD_VAR 0 3
115401: PUSH
115402: LD_VAR 0 1
115406: ARRAY
115407: PPUSH
115408: LD_VAR 0 1
115412: PUSH
115413: LD_INT 4
115415: MOD
115416: PUSH
115417: LD_INT 1
115419: PLUS
115420: PPUSH
115421: CALL_OW 259
115425: PUSH
115426: LD_INT 1
115428: PLUS
115429: PPUSH
115430: CALL_OW 237
115434: GO 115336
115436: POP
115437: POP
// end ;
115438: PPOPN 3
115440: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
115441: LD_EXP 144
115445: PUSH
115446: LD_EXP 152
115450: AND
115451: IFFALSE 115471
115453: GO 115455
115455: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
115456: LD_INT 4
115458: PPUSH
115459: LD_OWVAR 2
115463: PPUSH
115464: LD_INT 0
115466: PPUSH
115467: CALL_OW 324
115471: END
// every 0 0$1 trigger StreamModeActive and sShovel do
115472: LD_EXP 144
115476: PUSH
115477: LD_EXP 181
115481: AND
115482: IFFALSE 115502
115484: GO 115486
115486: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115487: LD_INT 19
115489: PPUSH
115490: LD_OWVAR 2
115494: PPUSH
115495: LD_INT 0
115497: PPUSH
115498: CALL_OW 324
115502: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115503: LD_EXP 144
115507: PUSH
115508: LD_EXP 153
115512: AND
115513: IFFALSE 115615
115515: GO 115517
115517: DISABLE
115518: LD_INT 0
115520: PPUSH
115521: PPUSH
// begin enable ;
115522: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115523: LD_ADDR_VAR 0 2
115527: PUSH
115528: LD_INT 22
115530: PUSH
115531: LD_OWVAR 2
115535: PUSH
115536: EMPTY
115537: LIST
115538: LIST
115539: PUSH
115540: LD_INT 2
115542: PUSH
115543: LD_INT 34
115545: PUSH
115546: LD_INT 11
115548: PUSH
115549: EMPTY
115550: LIST
115551: LIST
115552: PUSH
115553: LD_INT 34
115555: PUSH
115556: LD_INT 30
115558: PUSH
115559: EMPTY
115560: LIST
115561: LIST
115562: PUSH
115563: EMPTY
115564: LIST
115565: LIST
115566: LIST
115567: PUSH
115568: EMPTY
115569: LIST
115570: LIST
115571: PPUSH
115572: CALL_OW 69
115576: ST_TO_ADDR
// if not tmp then
115577: LD_VAR 0 2
115581: NOT
115582: IFFALSE 115586
// exit ;
115584: GO 115615
// for i in tmp do
115586: LD_ADDR_VAR 0 1
115590: PUSH
115591: LD_VAR 0 2
115595: PUSH
115596: FOR_IN
115597: IFFALSE 115613
// begin SetLives ( i , 0 ) ;
115599: LD_VAR 0 1
115603: PPUSH
115604: LD_INT 0
115606: PPUSH
115607: CALL_OW 234
// end ;
115611: GO 115596
115613: POP
115614: POP
// end ;
115615: PPOPN 2
115617: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115618: LD_EXP 144
115622: PUSH
115623: LD_EXP 154
115627: AND
115628: IFFALSE 115648
115630: GO 115632
115632: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115633: LD_INT 32
115635: PPUSH
115636: LD_OWVAR 2
115640: PPUSH
115641: LD_INT 0
115643: PPUSH
115644: CALL_OW 324
115648: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115649: LD_EXP 144
115653: PUSH
115654: LD_EXP 155
115658: AND
115659: IFFALSE 115840
115661: GO 115663
115663: DISABLE
115664: LD_INT 0
115666: PPUSH
115667: PPUSH
115668: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115669: LD_ADDR_VAR 0 2
115673: PUSH
115674: LD_INT 22
115676: PUSH
115677: LD_OWVAR 2
115681: PUSH
115682: EMPTY
115683: LIST
115684: LIST
115685: PUSH
115686: LD_INT 33
115688: PUSH
115689: LD_INT 3
115691: PUSH
115692: EMPTY
115693: LIST
115694: LIST
115695: PUSH
115696: EMPTY
115697: LIST
115698: LIST
115699: PPUSH
115700: CALL_OW 69
115704: ST_TO_ADDR
// if not tmp then
115705: LD_VAR 0 2
115709: NOT
115710: IFFALSE 115714
// exit ;
115712: GO 115840
// side := 0 ;
115714: LD_ADDR_VAR 0 3
115718: PUSH
115719: LD_INT 0
115721: ST_TO_ADDR
// for i := 1 to 8 do
115722: LD_ADDR_VAR 0 1
115726: PUSH
115727: DOUBLE
115728: LD_INT 1
115730: DEC
115731: ST_TO_ADDR
115732: LD_INT 8
115734: PUSH
115735: FOR_TO
115736: IFFALSE 115784
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115738: LD_OWVAR 2
115742: PUSH
115743: LD_VAR 0 1
115747: NONEQUAL
115748: PUSH
115749: LD_OWVAR 2
115753: PPUSH
115754: LD_VAR 0 1
115758: PPUSH
115759: CALL_OW 81
115763: PUSH
115764: LD_INT 2
115766: EQUAL
115767: AND
115768: IFFALSE 115782
// begin side := i ;
115770: LD_ADDR_VAR 0 3
115774: PUSH
115775: LD_VAR 0 1
115779: ST_TO_ADDR
// break ;
115780: GO 115784
// end ;
115782: GO 115735
115784: POP
115785: POP
// if not side then
115786: LD_VAR 0 3
115790: NOT
115791: IFFALSE 115795
// exit ;
115793: GO 115840
// for i := 1 to tmp do
115795: LD_ADDR_VAR 0 1
115799: PUSH
115800: DOUBLE
115801: LD_INT 1
115803: DEC
115804: ST_TO_ADDR
115805: LD_VAR 0 2
115809: PUSH
115810: FOR_TO
115811: IFFALSE 115838
// if Prob ( 60 ) then
115813: LD_INT 60
115815: PPUSH
115816: CALL_OW 13
115820: IFFALSE 115836
// SetSide ( i , side ) ;
115822: LD_VAR 0 1
115826: PPUSH
115827: LD_VAR 0 3
115831: PPUSH
115832: CALL_OW 235
115836: GO 115810
115838: POP
115839: POP
// end ;
115840: PPOPN 3
115842: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
115843: LD_EXP 144
115847: PUSH
115848: LD_EXP 157
115852: AND
115853: IFFALSE 115972
115855: GO 115857
115857: DISABLE
115858: LD_INT 0
115860: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
115861: LD_ADDR_VAR 0 1
115865: PUSH
115866: LD_INT 22
115868: PUSH
115869: LD_OWVAR 2
115873: PUSH
115874: EMPTY
115875: LIST
115876: LIST
115877: PUSH
115878: LD_INT 21
115880: PUSH
115881: LD_INT 1
115883: PUSH
115884: EMPTY
115885: LIST
115886: LIST
115887: PUSH
115888: LD_INT 3
115890: PUSH
115891: LD_INT 23
115893: PUSH
115894: LD_INT 0
115896: PUSH
115897: EMPTY
115898: LIST
115899: LIST
115900: PUSH
115901: EMPTY
115902: LIST
115903: LIST
115904: PUSH
115905: EMPTY
115906: LIST
115907: LIST
115908: LIST
115909: PPUSH
115910: CALL_OW 69
115914: PUSH
115915: FOR_IN
115916: IFFALSE 115970
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
115918: LD_VAR 0 1
115922: PPUSH
115923: CALL_OW 257
115927: PUSH
115928: LD_INT 1
115930: PUSH
115931: LD_INT 2
115933: PUSH
115934: LD_INT 3
115936: PUSH
115937: LD_INT 4
115939: PUSH
115940: EMPTY
115941: LIST
115942: LIST
115943: LIST
115944: LIST
115945: IN
115946: IFFALSE 115968
// SetClass ( un , rand ( 1 , 4 ) ) ;
115948: LD_VAR 0 1
115952: PPUSH
115953: LD_INT 1
115955: PPUSH
115956: LD_INT 4
115958: PPUSH
115959: CALL_OW 12
115963: PPUSH
115964: CALL_OW 336
115968: GO 115915
115970: POP
115971: POP
// end ;
115972: PPOPN 1
115974: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
115975: LD_EXP 144
115979: PUSH
115980: LD_EXP 156
115984: AND
115985: IFFALSE 116064
115987: GO 115989
115989: DISABLE
115990: LD_INT 0
115992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115993: LD_ADDR_VAR 0 1
115997: PUSH
115998: LD_INT 22
116000: PUSH
116001: LD_OWVAR 2
116005: PUSH
116006: EMPTY
116007: LIST
116008: LIST
116009: PUSH
116010: LD_INT 21
116012: PUSH
116013: LD_INT 3
116015: PUSH
116016: EMPTY
116017: LIST
116018: LIST
116019: PUSH
116020: EMPTY
116021: LIST
116022: LIST
116023: PPUSH
116024: CALL_OW 69
116028: ST_TO_ADDR
// if not tmp then
116029: LD_VAR 0 1
116033: NOT
116034: IFFALSE 116038
// exit ;
116036: GO 116064
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
116038: LD_VAR 0 1
116042: PUSH
116043: LD_INT 1
116045: PPUSH
116046: LD_VAR 0 1
116050: PPUSH
116051: CALL_OW 12
116055: ARRAY
116056: PPUSH
116057: LD_INT 100
116059: PPUSH
116060: CALL_OW 234
// end ;
116064: PPOPN 1
116066: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
116067: LD_EXP 144
116071: PUSH
116072: LD_EXP 158
116076: AND
116077: IFFALSE 116175
116079: GO 116081
116081: DISABLE
116082: LD_INT 0
116084: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116085: LD_ADDR_VAR 0 1
116089: PUSH
116090: LD_INT 22
116092: PUSH
116093: LD_OWVAR 2
116097: PUSH
116098: EMPTY
116099: LIST
116100: LIST
116101: PUSH
116102: LD_INT 21
116104: PUSH
116105: LD_INT 1
116107: PUSH
116108: EMPTY
116109: LIST
116110: LIST
116111: PUSH
116112: EMPTY
116113: LIST
116114: LIST
116115: PPUSH
116116: CALL_OW 69
116120: ST_TO_ADDR
// if not tmp then
116121: LD_VAR 0 1
116125: NOT
116126: IFFALSE 116130
// exit ;
116128: GO 116175
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
116130: LD_VAR 0 1
116134: PUSH
116135: LD_INT 1
116137: PPUSH
116138: LD_VAR 0 1
116142: PPUSH
116143: CALL_OW 12
116147: ARRAY
116148: PPUSH
116149: LD_INT 1
116151: PPUSH
116152: LD_INT 4
116154: PPUSH
116155: CALL_OW 12
116159: PPUSH
116160: LD_INT 3000
116162: PPUSH
116163: LD_INT 9000
116165: PPUSH
116166: CALL_OW 12
116170: PPUSH
116171: CALL_OW 492
// end ;
116175: PPOPN 1
116177: END
// every 0 0$1 trigger StreamModeActive and sDepot do
116178: LD_EXP 144
116182: PUSH
116183: LD_EXP 159
116187: AND
116188: IFFALSE 116208
116190: GO 116192
116192: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
116193: LD_INT 1
116195: PPUSH
116196: LD_OWVAR 2
116200: PPUSH
116201: LD_INT 0
116203: PPUSH
116204: CALL_OW 324
116208: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
116209: LD_EXP 144
116213: PUSH
116214: LD_EXP 160
116218: AND
116219: IFFALSE 116302
116221: GO 116223
116223: DISABLE
116224: LD_INT 0
116226: PPUSH
116227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
116228: LD_ADDR_VAR 0 2
116232: PUSH
116233: LD_INT 22
116235: PUSH
116236: LD_OWVAR 2
116240: PUSH
116241: EMPTY
116242: LIST
116243: LIST
116244: PUSH
116245: LD_INT 21
116247: PUSH
116248: LD_INT 3
116250: PUSH
116251: EMPTY
116252: LIST
116253: LIST
116254: PUSH
116255: EMPTY
116256: LIST
116257: LIST
116258: PPUSH
116259: CALL_OW 69
116263: ST_TO_ADDR
// if not tmp then
116264: LD_VAR 0 2
116268: NOT
116269: IFFALSE 116273
// exit ;
116271: GO 116302
// for i in tmp do
116273: LD_ADDR_VAR 0 1
116277: PUSH
116278: LD_VAR 0 2
116282: PUSH
116283: FOR_IN
116284: IFFALSE 116300
// SetBLevel ( i , 10 ) ;
116286: LD_VAR 0 1
116290: PPUSH
116291: LD_INT 10
116293: PPUSH
116294: CALL_OW 241
116298: GO 116283
116300: POP
116301: POP
// end ;
116302: PPOPN 2
116304: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
116305: LD_EXP 144
116309: PUSH
116310: LD_EXP 161
116314: AND
116315: IFFALSE 116426
116317: GO 116319
116319: DISABLE
116320: LD_INT 0
116322: PPUSH
116323: PPUSH
116324: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116325: LD_ADDR_VAR 0 3
116329: PUSH
116330: LD_INT 22
116332: PUSH
116333: LD_OWVAR 2
116337: PUSH
116338: EMPTY
116339: LIST
116340: LIST
116341: PUSH
116342: LD_INT 25
116344: PUSH
116345: LD_INT 1
116347: PUSH
116348: EMPTY
116349: LIST
116350: LIST
116351: PUSH
116352: EMPTY
116353: LIST
116354: LIST
116355: PPUSH
116356: CALL_OW 69
116360: ST_TO_ADDR
// if not tmp then
116361: LD_VAR 0 3
116365: NOT
116366: IFFALSE 116370
// exit ;
116368: GO 116426
// un := tmp [ rand ( 1 , tmp ) ] ;
116370: LD_ADDR_VAR 0 2
116374: PUSH
116375: LD_VAR 0 3
116379: PUSH
116380: LD_INT 1
116382: PPUSH
116383: LD_VAR 0 3
116387: PPUSH
116388: CALL_OW 12
116392: ARRAY
116393: ST_TO_ADDR
// if Crawls ( un ) then
116394: LD_VAR 0 2
116398: PPUSH
116399: CALL_OW 318
116403: IFFALSE 116414
// ComWalk ( un ) ;
116405: LD_VAR 0 2
116409: PPUSH
116410: CALL_OW 138
// SetClass ( un , class_sniper ) ;
116414: LD_VAR 0 2
116418: PPUSH
116419: LD_INT 5
116421: PPUSH
116422: CALL_OW 336
// end ;
116426: PPOPN 3
116428: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
116429: LD_EXP 144
116433: PUSH
116434: LD_EXP 162
116438: AND
116439: PUSH
116440: LD_OWVAR 67
116444: PUSH
116445: LD_INT 4
116447: LESS
116448: AND
116449: IFFALSE 116468
116451: GO 116453
116453: DISABLE
// begin Difficulty := Difficulty + 1 ;
116454: LD_ADDR_OWVAR 67
116458: PUSH
116459: LD_OWVAR 67
116463: PUSH
116464: LD_INT 1
116466: PLUS
116467: ST_TO_ADDR
// end ;
116468: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
116469: LD_EXP 144
116473: PUSH
116474: LD_EXP 163
116478: AND
116479: IFFALSE 116582
116481: GO 116483
116483: DISABLE
116484: LD_INT 0
116486: PPUSH
// begin for i := 1 to 5 do
116487: LD_ADDR_VAR 0 1
116491: PUSH
116492: DOUBLE
116493: LD_INT 1
116495: DEC
116496: ST_TO_ADDR
116497: LD_INT 5
116499: PUSH
116500: FOR_TO
116501: IFFALSE 116580
// begin uc_nation := nation_nature ;
116503: LD_ADDR_OWVAR 21
116507: PUSH
116508: LD_INT 0
116510: ST_TO_ADDR
// uc_side := 0 ;
116511: LD_ADDR_OWVAR 20
116515: PUSH
116516: LD_INT 0
116518: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116519: LD_ADDR_OWVAR 29
116523: PUSH
116524: LD_INT 12
116526: PUSH
116527: LD_INT 12
116529: PUSH
116530: EMPTY
116531: LIST
116532: LIST
116533: ST_TO_ADDR
// hc_agressivity := 20 ;
116534: LD_ADDR_OWVAR 35
116538: PUSH
116539: LD_INT 20
116541: ST_TO_ADDR
// hc_class := class_tiger ;
116542: LD_ADDR_OWVAR 28
116546: PUSH
116547: LD_INT 14
116549: ST_TO_ADDR
// hc_gallery :=  ;
116550: LD_ADDR_OWVAR 33
116554: PUSH
116555: LD_STRING 
116557: ST_TO_ADDR
// hc_name :=  ;
116558: LD_ADDR_OWVAR 26
116562: PUSH
116563: LD_STRING 
116565: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116566: CALL_OW 44
116570: PPUSH
116571: LD_INT 0
116573: PPUSH
116574: CALL_OW 51
// end ;
116578: GO 116500
116580: POP
116581: POP
// end ;
116582: PPOPN 1
116584: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116585: LD_EXP 144
116589: PUSH
116590: LD_EXP 164
116594: AND
116595: IFFALSE 116604
116597: GO 116599
116599: DISABLE
// StreamSibBomb ;
116600: CALL 116605 0 0
116604: END
// export function StreamSibBomb ; var i , x , y ; begin
116605: LD_INT 0
116607: PPUSH
116608: PPUSH
116609: PPUSH
116610: PPUSH
// result := false ;
116611: LD_ADDR_VAR 0 1
116615: PUSH
116616: LD_INT 0
116618: ST_TO_ADDR
// for i := 1 to 16 do
116619: LD_ADDR_VAR 0 2
116623: PUSH
116624: DOUBLE
116625: LD_INT 1
116627: DEC
116628: ST_TO_ADDR
116629: LD_INT 16
116631: PUSH
116632: FOR_TO
116633: IFFALSE 116832
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116635: LD_ADDR_VAR 0 3
116639: PUSH
116640: LD_INT 10
116642: PUSH
116643: LD_INT 20
116645: PUSH
116646: LD_INT 30
116648: PUSH
116649: LD_INT 40
116651: PUSH
116652: LD_INT 50
116654: PUSH
116655: LD_INT 60
116657: PUSH
116658: LD_INT 70
116660: PUSH
116661: LD_INT 80
116663: PUSH
116664: LD_INT 90
116666: PUSH
116667: LD_INT 100
116669: PUSH
116670: LD_INT 110
116672: PUSH
116673: LD_INT 120
116675: PUSH
116676: LD_INT 130
116678: PUSH
116679: LD_INT 140
116681: PUSH
116682: LD_INT 150
116684: PUSH
116685: EMPTY
116686: LIST
116687: LIST
116688: LIST
116689: LIST
116690: LIST
116691: LIST
116692: LIST
116693: LIST
116694: LIST
116695: LIST
116696: LIST
116697: LIST
116698: LIST
116699: LIST
116700: LIST
116701: PUSH
116702: LD_INT 1
116704: PPUSH
116705: LD_INT 15
116707: PPUSH
116708: CALL_OW 12
116712: ARRAY
116713: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116714: LD_ADDR_VAR 0 4
116718: PUSH
116719: LD_INT 10
116721: PUSH
116722: LD_INT 20
116724: PUSH
116725: LD_INT 30
116727: PUSH
116728: LD_INT 40
116730: PUSH
116731: LD_INT 50
116733: PUSH
116734: LD_INT 60
116736: PUSH
116737: LD_INT 70
116739: PUSH
116740: LD_INT 80
116742: PUSH
116743: LD_INT 90
116745: PUSH
116746: LD_INT 100
116748: PUSH
116749: LD_INT 110
116751: PUSH
116752: LD_INT 120
116754: PUSH
116755: LD_INT 130
116757: PUSH
116758: LD_INT 140
116760: PUSH
116761: LD_INT 150
116763: PUSH
116764: EMPTY
116765: LIST
116766: LIST
116767: LIST
116768: LIST
116769: LIST
116770: LIST
116771: LIST
116772: LIST
116773: LIST
116774: LIST
116775: LIST
116776: LIST
116777: LIST
116778: LIST
116779: LIST
116780: PUSH
116781: LD_INT 1
116783: PPUSH
116784: LD_INT 15
116786: PPUSH
116787: CALL_OW 12
116791: ARRAY
116792: ST_TO_ADDR
// if ValidHex ( x , y ) then
116793: LD_VAR 0 3
116797: PPUSH
116798: LD_VAR 0 4
116802: PPUSH
116803: CALL_OW 488
116807: IFFALSE 116830
// begin result := [ x , y ] ;
116809: LD_ADDR_VAR 0 1
116813: PUSH
116814: LD_VAR 0 3
116818: PUSH
116819: LD_VAR 0 4
116823: PUSH
116824: EMPTY
116825: LIST
116826: LIST
116827: ST_TO_ADDR
// break ;
116828: GO 116832
// end ; end ;
116830: GO 116632
116832: POP
116833: POP
// if result then
116834: LD_VAR 0 1
116838: IFFALSE 116898
// begin ToLua ( playSibBomb() ) ;
116840: LD_STRING playSibBomb()
116842: PPUSH
116843: CALL_OW 559
// wait ( 0 0$14 ) ;
116847: LD_INT 490
116849: PPUSH
116850: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
116854: LD_VAR 0 1
116858: PUSH
116859: LD_INT 1
116861: ARRAY
116862: PPUSH
116863: LD_VAR 0 1
116867: PUSH
116868: LD_INT 2
116870: ARRAY
116871: PPUSH
116872: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
116876: LD_VAR 0 1
116880: PUSH
116881: LD_INT 1
116883: ARRAY
116884: PPUSH
116885: LD_VAR 0 1
116889: PUSH
116890: LD_INT 2
116892: ARRAY
116893: PPUSH
116894: CALL_OW 429
// end ; end ;
116898: LD_VAR 0 1
116902: RET
// every 0 0$1 trigger StreamModeActive and sReset do
116903: LD_EXP 144
116907: PUSH
116908: LD_EXP 166
116912: AND
116913: IFFALSE 116925
116915: GO 116917
116917: DISABLE
// YouLost (  ) ;
116918: LD_STRING 
116920: PPUSH
116921: CALL_OW 104
116925: END
// every 0 0$1 trigger StreamModeActive and sFog do
116926: LD_EXP 144
116930: PUSH
116931: LD_EXP 165
116935: AND
116936: IFFALSE 116950
116938: GO 116940
116940: DISABLE
// FogOff ( your_side ) ;
116941: LD_OWVAR 2
116945: PPUSH
116946: CALL_OW 344
116950: END
// every 0 0$1 trigger StreamModeActive and sSun do
116951: LD_EXP 144
116955: PUSH
116956: LD_EXP 167
116960: AND
116961: IFFALSE 116989
116963: GO 116965
116965: DISABLE
// begin solar_recharge_percent := 0 ;
116966: LD_ADDR_OWVAR 79
116970: PUSH
116971: LD_INT 0
116973: ST_TO_ADDR
// wait ( 5 5$00 ) ;
116974: LD_INT 10500
116976: PPUSH
116977: CALL_OW 67
// solar_recharge_percent := 100 ;
116981: LD_ADDR_OWVAR 79
116985: PUSH
116986: LD_INT 100
116988: ST_TO_ADDR
// end ;
116989: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
116990: LD_EXP 144
116994: PUSH
116995: LD_EXP 168
116999: AND
117000: IFFALSE 117239
117002: GO 117004
117004: DISABLE
117005: LD_INT 0
117007: PPUSH
117008: PPUSH
117009: PPUSH
// begin tmp := [ ] ;
117010: LD_ADDR_VAR 0 3
117014: PUSH
117015: EMPTY
117016: ST_TO_ADDR
// for i := 1 to 6 do
117017: LD_ADDR_VAR 0 1
117021: PUSH
117022: DOUBLE
117023: LD_INT 1
117025: DEC
117026: ST_TO_ADDR
117027: LD_INT 6
117029: PUSH
117030: FOR_TO
117031: IFFALSE 117136
// begin uc_nation := nation_nature ;
117033: LD_ADDR_OWVAR 21
117037: PUSH
117038: LD_INT 0
117040: ST_TO_ADDR
// uc_side := 0 ;
117041: LD_ADDR_OWVAR 20
117045: PUSH
117046: LD_INT 0
117048: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117049: LD_ADDR_OWVAR 29
117053: PUSH
117054: LD_INT 12
117056: PUSH
117057: LD_INT 12
117059: PUSH
117060: EMPTY
117061: LIST
117062: LIST
117063: ST_TO_ADDR
// hc_agressivity := 20 ;
117064: LD_ADDR_OWVAR 35
117068: PUSH
117069: LD_INT 20
117071: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
117072: LD_ADDR_OWVAR 28
117076: PUSH
117077: LD_INT 17
117079: ST_TO_ADDR
// hc_gallery :=  ;
117080: LD_ADDR_OWVAR 33
117084: PUSH
117085: LD_STRING 
117087: ST_TO_ADDR
// hc_name :=  ;
117088: LD_ADDR_OWVAR 26
117092: PUSH
117093: LD_STRING 
117095: ST_TO_ADDR
// un := CreateHuman ;
117096: LD_ADDR_VAR 0 2
117100: PUSH
117101: CALL_OW 44
117105: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
117106: LD_VAR 0 2
117110: PPUSH
117111: LD_INT 1
117113: PPUSH
117114: CALL_OW 51
// tmp := tmp ^ un ;
117118: LD_ADDR_VAR 0 3
117122: PUSH
117123: LD_VAR 0 3
117127: PUSH
117128: LD_VAR 0 2
117132: ADD
117133: ST_TO_ADDR
// end ;
117134: GO 117030
117136: POP
117137: POP
// repeat wait ( 0 0$1 ) ;
117138: LD_INT 35
117140: PPUSH
117141: CALL_OW 67
// for un in tmp do
117145: LD_ADDR_VAR 0 2
117149: PUSH
117150: LD_VAR 0 3
117154: PUSH
117155: FOR_IN
117156: IFFALSE 117230
// begin if IsDead ( un ) then
117158: LD_VAR 0 2
117162: PPUSH
117163: CALL_OW 301
117167: IFFALSE 117187
// begin tmp := tmp diff un ;
117169: LD_ADDR_VAR 0 3
117173: PUSH
117174: LD_VAR 0 3
117178: PUSH
117179: LD_VAR 0 2
117183: DIFF
117184: ST_TO_ADDR
// continue ;
117185: GO 117155
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
117187: LD_VAR 0 2
117191: PPUSH
117192: LD_INT 3
117194: PUSH
117195: LD_INT 22
117197: PUSH
117198: LD_INT 0
117200: PUSH
117201: EMPTY
117202: LIST
117203: LIST
117204: PUSH
117205: EMPTY
117206: LIST
117207: LIST
117208: PPUSH
117209: CALL_OW 69
117213: PPUSH
117214: LD_VAR 0 2
117218: PPUSH
117219: CALL_OW 74
117223: PPUSH
117224: CALL_OW 115
// end ;
117228: GO 117155
117230: POP
117231: POP
// until not tmp ;
117232: LD_VAR 0 3
117236: NOT
117237: IFFALSE 117138
// end ;
117239: PPOPN 3
117241: END
// every 0 0$1 trigger StreamModeActive and sTroll do
117242: LD_EXP 144
117246: PUSH
117247: LD_EXP 169
117251: AND
117252: IFFALSE 117306
117254: GO 117256
117256: DISABLE
// begin ToLua ( displayTroll(); ) ;
117257: LD_STRING displayTroll();
117259: PPUSH
117260: CALL_OW 559
// wait ( 3 3$00 ) ;
117264: LD_INT 6300
117266: PPUSH
117267: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117271: LD_STRING hideTroll();
117273: PPUSH
117274: CALL_OW 559
// wait ( 1 1$00 ) ;
117278: LD_INT 2100
117280: PPUSH
117281: CALL_OW 67
// ToLua ( displayTroll(); ) ;
117285: LD_STRING displayTroll();
117287: PPUSH
117288: CALL_OW 559
// wait ( 1 1$00 ) ;
117292: LD_INT 2100
117294: PPUSH
117295: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117299: LD_STRING hideTroll();
117301: PPUSH
117302: CALL_OW 559
// end ;
117306: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
117307: LD_EXP 144
117311: PUSH
117312: LD_EXP 170
117316: AND
117317: IFFALSE 117380
117319: GO 117321
117321: DISABLE
117322: LD_INT 0
117324: PPUSH
// begin p := 0 ;
117325: LD_ADDR_VAR 0 1
117329: PUSH
117330: LD_INT 0
117332: ST_TO_ADDR
// repeat game_speed := 1 ;
117333: LD_ADDR_OWVAR 65
117337: PUSH
117338: LD_INT 1
117340: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117341: LD_INT 35
117343: PPUSH
117344: CALL_OW 67
// p := p + 1 ;
117348: LD_ADDR_VAR 0 1
117352: PUSH
117353: LD_VAR 0 1
117357: PUSH
117358: LD_INT 1
117360: PLUS
117361: ST_TO_ADDR
// until p >= 60 ;
117362: LD_VAR 0 1
117366: PUSH
117367: LD_INT 60
117369: GREATEREQUAL
117370: IFFALSE 117333
// game_speed := 4 ;
117372: LD_ADDR_OWVAR 65
117376: PUSH
117377: LD_INT 4
117379: ST_TO_ADDR
// end ;
117380: PPOPN 1
117382: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
117383: LD_EXP 144
117387: PUSH
117388: LD_EXP 171
117392: AND
117393: IFFALSE 117539
117395: GO 117397
117397: DISABLE
117398: LD_INT 0
117400: PPUSH
117401: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117402: LD_ADDR_VAR 0 1
117406: PUSH
117407: LD_INT 22
117409: PUSH
117410: LD_OWVAR 2
117414: PUSH
117415: EMPTY
117416: LIST
117417: LIST
117418: PUSH
117419: LD_INT 2
117421: PUSH
117422: LD_INT 30
117424: PUSH
117425: LD_INT 0
117427: PUSH
117428: EMPTY
117429: LIST
117430: LIST
117431: PUSH
117432: LD_INT 30
117434: PUSH
117435: LD_INT 1
117437: PUSH
117438: EMPTY
117439: LIST
117440: LIST
117441: PUSH
117442: EMPTY
117443: LIST
117444: LIST
117445: LIST
117446: PUSH
117447: EMPTY
117448: LIST
117449: LIST
117450: PPUSH
117451: CALL_OW 69
117455: ST_TO_ADDR
// if not depot then
117456: LD_VAR 0 1
117460: NOT
117461: IFFALSE 117465
// exit ;
117463: GO 117539
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
117465: LD_ADDR_VAR 0 2
117469: PUSH
117470: LD_VAR 0 1
117474: PUSH
117475: LD_INT 1
117477: PPUSH
117478: LD_VAR 0 1
117482: PPUSH
117483: CALL_OW 12
117487: ARRAY
117488: PPUSH
117489: CALL_OW 274
117493: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117494: LD_VAR 0 2
117498: PPUSH
117499: LD_INT 1
117501: PPUSH
117502: LD_INT 0
117504: PPUSH
117505: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117509: LD_VAR 0 2
117513: PPUSH
117514: LD_INT 2
117516: PPUSH
117517: LD_INT 0
117519: PPUSH
117520: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117524: LD_VAR 0 2
117528: PPUSH
117529: LD_INT 3
117531: PPUSH
117532: LD_INT 0
117534: PPUSH
117535: CALL_OW 277
// end ;
117539: PPOPN 2
117541: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117542: LD_EXP 144
117546: PUSH
117547: LD_EXP 172
117551: AND
117552: IFFALSE 117649
117554: GO 117556
117556: DISABLE
117557: LD_INT 0
117559: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117560: LD_ADDR_VAR 0 1
117564: PUSH
117565: LD_INT 22
117567: PUSH
117568: LD_OWVAR 2
117572: PUSH
117573: EMPTY
117574: LIST
117575: LIST
117576: PUSH
117577: LD_INT 21
117579: PUSH
117580: LD_INT 1
117582: PUSH
117583: EMPTY
117584: LIST
117585: LIST
117586: PUSH
117587: LD_INT 3
117589: PUSH
117590: LD_INT 23
117592: PUSH
117593: LD_INT 0
117595: PUSH
117596: EMPTY
117597: LIST
117598: LIST
117599: PUSH
117600: EMPTY
117601: LIST
117602: LIST
117603: PUSH
117604: EMPTY
117605: LIST
117606: LIST
117607: LIST
117608: PPUSH
117609: CALL_OW 69
117613: ST_TO_ADDR
// if not tmp then
117614: LD_VAR 0 1
117618: NOT
117619: IFFALSE 117623
// exit ;
117621: GO 117649
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117623: LD_VAR 0 1
117627: PUSH
117628: LD_INT 1
117630: PPUSH
117631: LD_VAR 0 1
117635: PPUSH
117636: CALL_OW 12
117640: ARRAY
117641: PPUSH
117642: LD_INT 200
117644: PPUSH
117645: CALL_OW 234
// end ;
117649: PPOPN 1
117651: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117652: LD_EXP 144
117656: PUSH
117657: LD_EXP 173
117661: AND
117662: IFFALSE 117741
117664: GO 117666
117666: DISABLE
117667: LD_INT 0
117669: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117670: LD_ADDR_VAR 0 1
117674: PUSH
117675: LD_INT 22
117677: PUSH
117678: LD_OWVAR 2
117682: PUSH
117683: EMPTY
117684: LIST
117685: LIST
117686: PUSH
117687: LD_INT 21
117689: PUSH
117690: LD_INT 2
117692: PUSH
117693: EMPTY
117694: LIST
117695: LIST
117696: PUSH
117697: EMPTY
117698: LIST
117699: LIST
117700: PPUSH
117701: CALL_OW 69
117705: ST_TO_ADDR
// if not tmp then
117706: LD_VAR 0 1
117710: NOT
117711: IFFALSE 117715
// exit ;
117713: GO 117741
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117715: LD_VAR 0 1
117719: PUSH
117720: LD_INT 1
117722: PPUSH
117723: LD_VAR 0 1
117727: PPUSH
117728: CALL_OW 12
117732: ARRAY
117733: PPUSH
117734: LD_INT 60
117736: PPUSH
117737: CALL_OW 234
// end ;
117741: PPOPN 1
117743: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117744: LD_EXP 144
117748: PUSH
117749: LD_EXP 174
117753: AND
117754: IFFALSE 117853
117756: GO 117758
117758: DISABLE
117759: LD_INT 0
117761: PPUSH
117762: PPUSH
// begin enable ;
117763: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117764: LD_ADDR_VAR 0 1
117768: PUSH
117769: LD_INT 22
117771: PUSH
117772: LD_OWVAR 2
117776: PUSH
117777: EMPTY
117778: LIST
117779: LIST
117780: PUSH
117781: LD_INT 61
117783: PUSH
117784: EMPTY
117785: LIST
117786: PUSH
117787: LD_INT 33
117789: PUSH
117790: LD_INT 2
117792: PUSH
117793: EMPTY
117794: LIST
117795: LIST
117796: PUSH
117797: EMPTY
117798: LIST
117799: LIST
117800: LIST
117801: PPUSH
117802: CALL_OW 69
117806: ST_TO_ADDR
// if not tmp then
117807: LD_VAR 0 1
117811: NOT
117812: IFFALSE 117816
// exit ;
117814: GO 117853
// for i in tmp do
117816: LD_ADDR_VAR 0 2
117820: PUSH
117821: LD_VAR 0 1
117825: PUSH
117826: FOR_IN
117827: IFFALSE 117851
// if IsControledBy ( i ) then
117829: LD_VAR 0 2
117833: PPUSH
117834: CALL_OW 312
117838: IFFALSE 117849
// ComUnlink ( i ) ;
117840: LD_VAR 0 2
117844: PPUSH
117845: CALL_OW 136
117849: GO 117826
117851: POP
117852: POP
// end ;
117853: PPOPN 2
117855: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
117856: LD_EXP 144
117860: PUSH
117861: LD_EXP 175
117865: AND
117866: IFFALSE 118006
117868: GO 117870
117870: DISABLE
117871: LD_INT 0
117873: PPUSH
117874: PPUSH
// begin ToLua ( displayPowell(); ) ;
117875: LD_STRING displayPowell();
117877: PPUSH
117878: CALL_OW 559
// uc_side := 0 ;
117882: LD_ADDR_OWVAR 20
117886: PUSH
117887: LD_INT 0
117889: ST_TO_ADDR
// uc_nation := 2 ;
117890: LD_ADDR_OWVAR 21
117894: PUSH
117895: LD_INT 2
117897: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
117898: LD_ADDR_OWVAR 37
117902: PUSH
117903: LD_INT 14
117905: ST_TO_ADDR
// vc_engine := engine_siberite ;
117906: LD_ADDR_OWVAR 39
117910: PUSH
117911: LD_INT 3
117913: ST_TO_ADDR
// vc_control := control_apeman ;
117914: LD_ADDR_OWVAR 38
117918: PUSH
117919: LD_INT 5
117921: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
117922: LD_ADDR_OWVAR 40
117926: PUSH
117927: LD_INT 29
117929: ST_TO_ADDR
// un := CreateVehicle ;
117930: LD_ADDR_VAR 0 2
117934: PUSH
117935: CALL_OW 45
117939: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117940: LD_VAR 0 2
117944: PPUSH
117945: LD_INT 1
117947: PPUSH
117948: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117952: LD_INT 35
117954: PPUSH
117955: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117959: LD_VAR 0 2
117963: PPUSH
117964: LD_INT 22
117966: PUSH
117967: LD_OWVAR 2
117971: PUSH
117972: EMPTY
117973: LIST
117974: LIST
117975: PPUSH
117976: CALL_OW 69
117980: PPUSH
117981: LD_VAR 0 2
117985: PPUSH
117986: CALL_OW 74
117990: PPUSH
117991: CALL_OW 115
// until IsDead ( un ) ;
117995: LD_VAR 0 2
117999: PPUSH
118000: CALL_OW 301
118004: IFFALSE 117952
// end ;
118006: PPOPN 2
118008: END
// every 0 0$1 trigger StreamModeActive and sStu do
118009: LD_EXP 144
118013: PUSH
118014: LD_EXP 183
118018: AND
118019: IFFALSE 118035
118021: GO 118023
118023: DISABLE
// begin ToLua ( displayStucuk(); ) ;
118024: LD_STRING displayStucuk();
118026: PPUSH
118027: CALL_OW 559
// ResetFog ;
118031: CALL_OW 335
// end ;
118035: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
118036: LD_EXP 144
118040: PUSH
118041: LD_EXP 176
118045: AND
118046: IFFALSE 118187
118048: GO 118050
118050: DISABLE
118051: LD_INT 0
118053: PPUSH
118054: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118055: LD_ADDR_VAR 0 2
118059: PUSH
118060: LD_INT 22
118062: PUSH
118063: LD_OWVAR 2
118067: PUSH
118068: EMPTY
118069: LIST
118070: LIST
118071: PUSH
118072: LD_INT 21
118074: PUSH
118075: LD_INT 1
118077: PUSH
118078: EMPTY
118079: LIST
118080: LIST
118081: PUSH
118082: EMPTY
118083: LIST
118084: LIST
118085: PPUSH
118086: CALL_OW 69
118090: ST_TO_ADDR
// if not tmp then
118091: LD_VAR 0 2
118095: NOT
118096: IFFALSE 118100
// exit ;
118098: GO 118187
// un := tmp [ rand ( 1 , tmp ) ] ;
118100: LD_ADDR_VAR 0 1
118104: PUSH
118105: LD_VAR 0 2
118109: PUSH
118110: LD_INT 1
118112: PPUSH
118113: LD_VAR 0 2
118117: PPUSH
118118: CALL_OW 12
118122: ARRAY
118123: ST_TO_ADDR
// SetSide ( un , 0 ) ;
118124: LD_VAR 0 1
118128: PPUSH
118129: LD_INT 0
118131: PPUSH
118132: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
118136: LD_VAR 0 1
118140: PPUSH
118141: LD_OWVAR 3
118145: PUSH
118146: LD_VAR 0 1
118150: DIFF
118151: PPUSH
118152: LD_VAR 0 1
118156: PPUSH
118157: CALL_OW 74
118161: PPUSH
118162: CALL_OW 115
// wait ( 0 0$20 ) ;
118166: LD_INT 700
118168: PPUSH
118169: CALL_OW 67
// SetSide ( un , your_side ) ;
118173: LD_VAR 0 1
118177: PPUSH
118178: LD_OWVAR 2
118182: PPUSH
118183: CALL_OW 235
// end ;
118187: PPOPN 2
118189: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
118190: LD_EXP 144
118194: PUSH
118195: LD_EXP 177
118199: AND
118200: IFFALSE 118306
118202: GO 118204
118204: DISABLE
118205: LD_INT 0
118207: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118208: LD_ADDR_VAR 0 1
118212: PUSH
118213: LD_INT 22
118215: PUSH
118216: LD_OWVAR 2
118220: PUSH
118221: EMPTY
118222: LIST
118223: LIST
118224: PUSH
118225: LD_INT 2
118227: PUSH
118228: LD_INT 30
118230: PUSH
118231: LD_INT 0
118233: PUSH
118234: EMPTY
118235: LIST
118236: LIST
118237: PUSH
118238: LD_INT 30
118240: PUSH
118241: LD_INT 1
118243: PUSH
118244: EMPTY
118245: LIST
118246: LIST
118247: PUSH
118248: EMPTY
118249: LIST
118250: LIST
118251: LIST
118252: PUSH
118253: EMPTY
118254: LIST
118255: LIST
118256: PPUSH
118257: CALL_OW 69
118261: ST_TO_ADDR
// if not depot then
118262: LD_VAR 0 1
118266: NOT
118267: IFFALSE 118271
// exit ;
118269: GO 118306
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
118271: LD_VAR 0 1
118275: PUSH
118276: LD_INT 1
118278: ARRAY
118279: PPUSH
118280: CALL_OW 250
118284: PPUSH
118285: LD_VAR 0 1
118289: PUSH
118290: LD_INT 1
118292: ARRAY
118293: PPUSH
118294: CALL_OW 251
118298: PPUSH
118299: LD_INT 70
118301: PPUSH
118302: CALL_OW 495
// end ;
118306: PPOPN 1
118308: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
118309: LD_EXP 144
118313: PUSH
118314: LD_EXP 178
118318: AND
118319: IFFALSE 118530
118321: GO 118323
118323: DISABLE
118324: LD_INT 0
118326: PPUSH
118327: PPUSH
118328: PPUSH
118329: PPUSH
118330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118331: LD_ADDR_VAR 0 5
118335: PUSH
118336: LD_INT 22
118338: PUSH
118339: LD_OWVAR 2
118343: PUSH
118344: EMPTY
118345: LIST
118346: LIST
118347: PUSH
118348: LD_INT 21
118350: PUSH
118351: LD_INT 1
118353: PUSH
118354: EMPTY
118355: LIST
118356: LIST
118357: PUSH
118358: EMPTY
118359: LIST
118360: LIST
118361: PPUSH
118362: CALL_OW 69
118366: ST_TO_ADDR
// if not tmp then
118367: LD_VAR 0 5
118371: NOT
118372: IFFALSE 118376
// exit ;
118374: GO 118530
// for i in tmp do
118376: LD_ADDR_VAR 0 1
118380: PUSH
118381: LD_VAR 0 5
118385: PUSH
118386: FOR_IN
118387: IFFALSE 118528
// begin d := rand ( 0 , 5 ) ;
118389: LD_ADDR_VAR 0 4
118393: PUSH
118394: LD_INT 0
118396: PPUSH
118397: LD_INT 5
118399: PPUSH
118400: CALL_OW 12
118404: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
118405: LD_ADDR_VAR 0 2
118409: PUSH
118410: LD_VAR 0 1
118414: PPUSH
118415: CALL_OW 250
118419: PPUSH
118420: LD_VAR 0 4
118424: PPUSH
118425: LD_INT 3
118427: PPUSH
118428: LD_INT 12
118430: PPUSH
118431: CALL_OW 12
118435: PPUSH
118436: CALL_OW 272
118440: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
118441: LD_ADDR_VAR 0 3
118445: PUSH
118446: LD_VAR 0 1
118450: PPUSH
118451: CALL_OW 251
118455: PPUSH
118456: LD_VAR 0 4
118460: PPUSH
118461: LD_INT 3
118463: PPUSH
118464: LD_INT 12
118466: PPUSH
118467: CALL_OW 12
118471: PPUSH
118472: CALL_OW 273
118476: ST_TO_ADDR
// if ValidHex ( x , y ) then
118477: LD_VAR 0 2
118481: PPUSH
118482: LD_VAR 0 3
118486: PPUSH
118487: CALL_OW 488
118491: IFFALSE 118526
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118493: LD_VAR 0 1
118497: PPUSH
118498: LD_VAR 0 2
118502: PPUSH
118503: LD_VAR 0 3
118507: PPUSH
118508: LD_INT 3
118510: PPUSH
118511: LD_INT 6
118513: PPUSH
118514: CALL_OW 12
118518: PPUSH
118519: LD_INT 1
118521: PPUSH
118522: CALL_OW 483
// end ;
118526: GO 118386
118528: POP
118529: POP
// end ;
118530: PPOPN 5
118532: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118533: LD_EXP 144
118537: PUSH
118538: LD_EXP 179
118542: AND
118543: IFFALSE 118637
118545: GO 118547
118547: DISABLE
118548: LD_INT 0
118550: PPUSH
118551: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118552: LD_ADDR_VAR 0 2
118556: PUSH
118557: LD_INT 22
118559: PUSH
118560: LD_OWVAR 2
118564: PUSH
118565: EMPTY
118566: LIST
118567: LIST
118568: PUSH
118569: LD_INT 32
118571: PUSH
118572: LD_INT 1
118574: PUSH
118575: EMPTY
118576: LIST
118577: LIST
118578: PUSH
118579: LD_INT 21
118581: PUSH
118582: LD_INT 2
118584: PUSH
118585: EMPTY
118586: LIST
118587: LIST
118588: PUSH
118589: EMPTY
118590: LIST
118591: LIST
118592: LIST
118593: PPUSH
118594: CALL_OW 69
118598: ST_TO_ADDR
// if not tmp then
118599: LD_VAR 0 2
118603: NOT
118604: IFFALSE 118608
// exit ;
118606: GO 118637
// for i in tmp do
118608: LD_ADDR_VAR 0 1
118612: PUSH
118613: LD_VAR 0 2
118617: PUSH
118618: FOR_IN
118619: IFFALSE 118635
// SetFuel ( i , 0 ) ;
118621: LD_VAR 0 1
118625: PPUSH
118626: LD_INT 0
118628: PPUSH
118629: CALL_OW 240
118633: GO 118618
118635: POP
118636: POP
// end ;
118637: PPOPN 2
118639: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118640: LD_EXP 144
118644: PUSH
118645: LD_EXP 180
118649: AND
118650: IFFALSE 118716
118652: GO 118654
118654: DISABLE
118655: LD_INT 0
118657: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118658: LD_ADDR_VAR 0 1
118662: PUSH
118663: LD_INT 22
118665: PUSH
118666: LD_OWVAR 2
118670: PUSH
118671: EMPTY
118672: LIST
118673: LIST
118674: PUSH
118675: LD_INT 30
118677: PUSH
118678: LD_INT 29
118680: PUSH
118681: EMPTY
118682: LIST
118683: LIST
118684: PUSH
118685: EMPTY
118686: LIST
118687: LIST
118688: PPUSH
118689: CALL_OW 69
118693: ST_TO_ADDR
// if not tmp then
118694: LD_VAR 0 1
118698: NOT
118699: IFFALSE 118703
// exit ;
118701: GO 118716
// DestroyUnit ( tmp [ 1 ] ) ;
118703: LD_VAR 0 1
118707: PUSH
118708: LD_INT 1
118710: ARRAY
118711: PPUSH
118712: CALL_OW 65
// end ;
118716: PPOPN 1
118718: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118719: LD_EXP 144
118723: PUSH
118724: LD_EXP 182
118728: AND
118729: IFFALSE 118858
118731: GO 118733
118733: DISABLE
118734: LD_INT 0
118736: PPUSH
// begin uc_side := 0 ;
118737: LD_ADDR_OWVAR 20
118741: PUSH
118742: LD_INT 0
118744: ST_TO_ADDR
// uc_nation := nation_arabian ;
118745: LD_ADDR_OWVAR 21
118749: PUSH
118750: LD_INT 2
118752: ST_TO_ADDR
// hc_gallery :=  ;
118753: LD_ADDR_OWVAR 33
118757: PUSH
118758: LD_STRING 
118760: ST_TO_ADDR
// hc_name :=  ;
118761: LD_ADDR_OWVAR 26
118765: PUSH
118766: LD_STRING 
118768: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118769: LD_INT 1
118771: PPUSH
118772: LD_INT 11
118774: PPUSH
118775: LD_INT 10
118777: PPUSH
118778: CALL_OW 380
// un := CreateHuman ;
118782: LD_ADDR_VAR 0 1
118786: PUSH
118787: CALL_OW 44
118791: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118792: LD_VAR 0 1
118796: PPUSH
118797: LD_INT 1
118799: PPUSH
118800: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118804: LD_INT 35
118806: PPUSH
118807: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118811: LD_VAR 0 1
118815: PPUSH
118816: LD_INT 22
118818: PUSH
118819: LD_OWVAR 2
118823: PUSH
118824: EMPTY
118825: LIST
118826: LIST
118827: PPUSH
118828: CALL_OW 69
118832: PPUSH
118833: LD_VAR 0 1
118837: PPUSH
118838: CALL_OW 74
118842: PPUSH
118843: CALL_OW 115
// until IsDead ( un ) ;
118847: LD_VAR 0 1
118851: PPUSH
118852: CALL_OW 301
118856: IFFALSE 118804
// end ;
118858: PPOPN 1
118860: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
118861: LD_EXP 144
118865: PUSH
118866: LD_EXP 184
118870: AND
118871: IFFALSE 118883
118873: GO 118875
118875: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
118876: LD_STRING earthquake(getX(game), 0, 32)
118878: PPUSH
118879: CALL_OW 559
118883: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
118884: LD_EXP 144
118888: PUSH
118889: LD_EXP 185
118893: AND
118894: IFFALSE 118985
118896: GO 118898
118898: DISABLE
118899: LD_INT 0
118901: PPUSH
// begin enable ;
118902: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
118903: LD_ADDR_VAR 0 1
118907: PUSH
118908: LD_INT 22
118910: PUSH
118911: LD_OWVAR 2
118915: PUSH
118916: EMPTY
118917: LIST
118918: LIST
118919: PUSH
118920: LD_INT 21
118922: PUSH
118923: LD_INT 2
118925: PUSH
118926: EMPTY
118927: LIST
118928: LIST
118929: PUSH
118930: LD_INT 33
118932: PUSH
118933: LD_INT 3
118935: PUSH
118936: EMPTY
118937: LIST
118938: LIST
118939: PUSH
118940: EMPTY
118941: LIST
118942: LIST
118943: LIST
118944: PPUSH
118945: CALL_OW 69
118949: ST_TO_ADDR
// if not tmp then
118950: LD_VAR 0 1
118954: NOT
118955: IFFALSE 118959
// exit ;
118957: GO 118985
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118959: LD_VAR 0 1
118963: PUSH
118964: LD_INT 1
118966: PPUSH
118967: LD_VAR 0 1
118971: PPUSH
118972: CALL_OW 12
118976: ARRAY
118977: PPUSH
118978: LD_INT 1
118980: PPUSH
118981: CALL_OW 234
// end ;
118985: PPOPN 1
118987: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
118988: LD_EXP 144
118992: PUSH
118993: LD_EXP 186
118997: AND
118998: IFFALSE 119139
119000: GO 119002
119002: DISABLE
119003: LD_INT 0
119005: PPUSH
119006: PPUSH
119007: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119008: LD_ADDR_VAR 0 3
119012: PUSH
119013: LD_INT 22
119015: PUSH
119016: LD_OWVAR 2
119020: PUSH
119021: EMPTY
119022: LIST
119023: LIST
119024: PUSH
119025: LD_INT 25
119027: PUSH
119028: LD_INT 1
119030: PUSH
119031: EMPTY
119032: LIST
119033: LIST
119034: PUSH
119035: EMPTY
119036: LIST
119037: LIST
119038: PPUSH
119039: CALL_OW 69
119043: ST_TO_ADDR
// if not tmp then
119044: LD_VAR 0 3
119048: NOT
119049: IFFALSE 119053
// exit ;
119051: GO 119139
// un := tmp [ rand ( 1 , tmp ) ] ;
119053: LD_ADDR_VAR 0 2
119057: PUSH
119058: LD_VAR 0 3
119062: PUSH
119063: LD_INT 1
119065: PPUSH
119066: LD_VAR 0 3
119070: PPUSH
119071: CALL_OW 12
119075: ARRAY
119076: ST_TO_ADDR
// if Crawls ( un ) then
119077: LD_VAR 0 2
119081: PPUSH
119082: CALL_OW 318
119086: IFFALSE 119097
// ComWalk ( un ) ;
119088: LD_VAR 0 2
119092: PPUSH
119093: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
119097: LD_VAR 0 2
119101: PPUSH
119102: LD_INT 9
119104: PPUSH
119105: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
119109: LD_INT 28
119111: PPUSH
119112: LD_OWVAR 2
119116: PPUSH
119117: LD_INT 2
119119: PPUSH
119120: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
119124: LD_INT 29
119126: PPUSH
119127: LD_OWVAR 2
119131: PPUSH
119132: LD_INT 2
119134: PPUSH
119135: CALL_OW 322
// end ;
119139: PPOPN 3
119141: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
119142: LD_EXP 144
119146: PUSH
119147: LD_EXP 187
119151: AND
119152: IFFALSE 119263
119154: GO 119156
119156: DISABLE
119157: LD_INT 0
119159: PPUSH
119160: PPUSH
119161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119162: LD_ADDR_VAR 0 3
119166: PUSH
119167: LD_INT 22
119169: PUSH
119170: LD_OWVAR 2
119174: PUSH
119175: EMPTY
119176: LIST
119177: LIST
119178: PUSH
119179: LD_INT 25
119181: PUSH
119182: LD_INT 1
119184: PUSH
119185: EMPTY
119186: LIST
119187: LIST
119188: PUSH
119189: EMPTY
119190: LIST
119191: LIST
119192: PPUSH
119193: CALL_OW 69
119197: ST_TO_ADDR
// if not tmp then
119198: LD_VAR 0 3
119202: NOT
119203: IFFALSE 119207
// exit ;
119205: GO 119263
// un := tmp [ rand ( 1 , tmp ) ] ;
119207: LD_ADDR_VAR 0 2
119211: PUSH
119212: LD_VAR 0 3
119216: PUSH
119217: LD_INT 1
119219: PPUSH
119220: LD_VAR 0 3
119224: PPUSH
119225: CALL_OW 12
119229: ARRAY
119230: ST_TO_ADDR
// if Crawls ( un ) then
119231: LD_VAR 0 2
119235: PPUSH
119236: CALL_OW 318
119240: IFFALSE 119251
// ComWalk ( un ) ;
119242: LD_VAR 0 2
119246: PPUSH
119247: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119251: LD_VAR 0 2
119255: PPUSH
119256: LD_INT 8
119258: PPUSH
119259: CALL_OW 336
// end ;
119263: PPOPN 3
119265: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
119266: LD_EXP 144
119270: PUSH
119271: LD_EXP 188
119275: AND
119276: IFFALSE 119420
119278: GO 119280
119280: DISABLE
119281: LD_INT 0
119283: PPUSH
119284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
119285: LD_ADDR_VAR 0 2
119289: PUSH
119290: LD_INT 22
119292: PUSH
119293: LD_OWVAR 2
119297: PUSH
119298: EMPTY
119299: LIST
119300: LIST
119301: PUSH
119302: LD_INT 21
119304: PUSH
119305: LD_INT 2
119307: PUSH
119308: EMPTY
119309: LIST
119310: LIST
119311: PUSH
119312: LD_INT 2
119314: PUSH
119315: LD_INT 34
119317: PUSH
119318: LD_INT 12
119320: PUSH
119321: EMPTY
119322: LIST
119323: LIST
119324: PUSH
119325: LD_INT 34
119327: PUSH
119328: LD_INT 51
119330: PUSH
119331: EMPTY
119332: LIST
119333: LIST
119334: PUSH
119335: LD_INT 34
119337: PUSH
119338: LD_INT 32
119340: PUSH
119341: EMPTY
119342: LIST
119343: LIST
119344: PUSH
119345: EMPTY
119346: LIST
119347: LIST
119348: LIST
119349: LIST
119350: PUSH
119351: EMPTY
119352: LIST
119353: LIST
119354: LIST
119355: PPUSH
119356: CALL_OW 69
119360: ST_TO_ADDR
// if not tmp then
119361: LD_VAR 0 2
119365: NOT
119366: IFFALSE 119370
// exit ;
119368: GO 119420
// for i in tmp do
119370: LD_ADDR_VAR 0 1
119374: PUSH
119375: LD_VAR 0 2
119379: PUSH
119380: FOR_IN
119381: IFFALSE 119418
// if GetCargo ( i , mat_artifact ) = 0 then
119383: LD_VAR 0 1
119387: PPUSH
119388: LD_INT 4
119390: PPUSH
119391: CALL_OW 289
119395: PUSH
119396: LD_INT 0
119398: EQUAL
119399: IFFALSE 119416
// SetCargo ( i , mat_siberit , 100 ) ;
119401: LD_VAR 0 1
119405: PPUSH
119406: LD_INT 3
119408: PPUSH
119409: LD_INT 100
119411: PPUSH
119412: CALL_OW 290
119416: GO 119380
119418: POP
119419: POP
// end ;
119420: PPOPN 2
119422: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
119423: LD_EXP 144
119427: PUSH
119428: LD_EXP 189
119432: AND
119433: IFFALSE 119616
119435: GO 119437
119437: DISABLE
119438: LD_INT 0
119440: PPUSH
119441: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119442: LD_ADDR_VAR 0 2
119446: PUSH
119447: LD_INT 22
119449: PUSH
119450: LD_OWVAR 2
119454: PUSH
119455: EMPTY
119456: LIST
119457: LIST
119458: PPUSH
119459: CALL_OW 69
119463: ST_TO_ADDR
// if not tmp then
119464: LD_VAR 0 2
119468: NOT
119469: IFFALSE 119473
// exit ;
119471: GO 119616
// for i := 1 to 2 do
119473: LD_ADDR_VAR 0 1
119477: PUSH
119478: DOUBLE
119479: LD_INT 1
119481: DEC
119482: ST_TO_ADDR
119483: LD_INT 2
119485: PUSH
119486: FOR_TO
119487: IFFALSE 119614
// begin uc_side := your_side ;
119489: LD_ADDR_OWVAR 20
119493: PUSH
119494: LD_OWVAR 2
119498: ST_TO_ADDR
// uc_nation := nation_american ;
119499: LD_ADDR_OWVAR 21
119503: PUSH
119504: LD_INT 1
119506: ST_TO_ADDR
// vc_chassis := us_morphling ;
119507: LD_ADDR_OWVAR 37
119511: PUSH
119512: LD_INT 5
119514: ST_TO_ADDR
// vc_engine := engine_siberite ;
119515: LD_ADDR_OWVAR 39
119519: PUSH
119520: LD_INT 3
119522: ST_TO_ADDR
// vc_control := control_computer ;
119523: LD_ADDR_OWVAR 38
119527: PUSH
119528: LD_INT 3
119530: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119531: LD_ADDR_OWVAR 40
119535: PUSH
119536: LD_INT 10
119538: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119539: LD_VAR 0 2
119543: PUSH
119544: LD_INT 1
119546: ARRAY
119547: PPUSH
119548: CALL_OW 310
119552: NOT
119553: IFFALSE 119600
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119555: CALL_OW 45
119559: PPUSH
119560: LD_VAR 0 2
119564: PUSH
119565: LD_INT 1
119567: ARRAY
119568: PPUSH
119569: CALL_OW 250
119573: PPUSH
119574: LD_VAR 0 2
119578: PUSH
119579: LD_INT 1
119581: ARRAY
119582: PPUSH
119583: CALL_OW 251
119587: PPUSH
119588: LD_INT 12
119590: PPUSH
119591: LD_INT 1
119593: PPUSH
119594: CALL_OW 50
119598: GO 119612
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119600: CALL_OW 45
119604: PPUSH
119605: LD_INT 1
119607: PPUSH
119608: CALL_OW 51
// end ;
119612: GO 119486
119614: POP
119615: POP
// end ;
119616: PPOPN 2
119618: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119619: LD_EXP 144
119623: PUSH
119624: LD_EXP 190
119628: AND
119629: IFFALSE 119851
119631: GO 119633
119633: DISABLE
119634: LD_INT 0
119636: PPUSH
119637: PPUSH
119638: PPUSH
119639: PPUSH
119640: PPUSH
119641: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119642: LD_ADDR_VAR 0 6
119646: PUSH
119647: LD_INT 22
119649: PUSH
119650: LD_OWVAR 2
119654: PUSH
119655: EMPTY
119656: LIST
119657: LIST
119658: PUSH
119659: LD_INT 21
119661: PUSH
119662: LD_INT 1
119664: PUSH
119665: EMPTY
119666: LIST
119667: LIST
119668: PUSH
119669: LD_INT 3
119671: PUSH
119672: LD_INT 23
119674: PUSH
119675: LD_INT 0
119677: PUSH
119678: EMPTY
119679: LIST
119680: LIST
119681: PUSH
119682: EMPTY
119683: LIST
119684: LIST
119685: PUSH
119686: EMPTY
119687: LIST
119688: LIST
119689: LIST
119690: PPUSH
119691: CALL_OW 69
119695: ST_TO_ADDR
// if not tmp then
119696: LD_VAR 0 6
119700: NOT
119701: IFFALSE 119705
// exit ;
119703: GO 119851
// s1 := rand ( 1 , 4 ) ;
119705: LD_ADDR_VAR 0 2
119709: PUSH
119710: LD_INT 1
119712: PPUSH
119713: LD_INT 4
119715: PPUSH
119716: CALL_OW 12
119720: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119721: LD_ADDR_VAR 0 4
119725: PUSH
119726: LD_VAR 0 6
119730: PUSH
119731: LD_INT 1
119733: ARRAY
119734: PPUSH
119735: LD_VAR 0 2
119739: PPUSH
119740: CALL_OW 259
119744: ST_TO_ADDR
// if s1 = 1 then
119745: LD_VAR 0 2
119749: PUSH
119750: LD_INT 1
119752: EQUAL
119753: IFFALSE 119773
// s2 := rand ( 2 , 4 ) else
119755: LD_ADDR_VAR 0 3
119759: PUSH
119760: LD_INT 2
119762: PPUSH
119763: LD_INT 4
119765: PPUSH
119766: CALL_OW 12
119770: ST_TO_ADDR
119771: GO 119781
// s2 := 1 ;
119773: LD_ADDR_VAR 0 3
119777: PUSH
119778: LD_INT 1
119780: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119781: LD_ADDR_VAR 0 5
119785: PUSH
119786: LD_VAR 0 6
119790: PUSH
119791: LD_INT 1
119793: ARRAY
119794: PPUSH
119795: LD_VAR 0 3
119799: PPUSH
119800: CALL_OW 259
119804: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
119805: LD_VAR 0 6
119809: PUSH
119810: LD_INT 1
119812: ARRAY
119813: PPUSH
119814: LD_VAR 0 2
119818: PPUSH
119819: LD_VAR 0 5
119823: PPUSH
119824: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
119828: LD_VAR 0 6
119832: PUSH
119833: LD_INT 1
119835: ARRAY
119836: PPUSH
119837: LD_VAR 0 3
119841: PPUSH
119842: LD_VAR 0 4
119846: PPUSH
119847: CALL_OW 237
// end ;
119851: PPOPN 6
119853: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
119854: LD_EXP 144
119858: PUSH
119859: LD_EXP 191
119863: AND
119864: IFFALSE 119943
119866: GO 119868
119868: DISABLE
119869: LD_INT 0
119871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
119872: LD_ADDR_VAR 0 1
119876: PUSH
119877: LD_INT 22
119879: PUSH
119880: LD_OWVAR 2
119884: PUSH
119885: EMPTY
119886: LIST
119887: LIST
119888: PUSH
119889: LD_INT 30
119891: PUSH
119892: LD_INT 3
119894: PUSH
119895: EMPTY
119896: LIST
119897: LIST
119898: PUSH
119899: EMPTY
119900: LIST
119901: LIST
119902: PPUSH
119903: CALL_OW 69
119907: ST_TO_ADDR
// if not tmp then
119908: LD_VAR 0 1
119912: NOT
119913: IFFALSE 119917
// exit ;
119915: GO 119943
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119917: LD_VAR 0 1
119921: PUSH
119922: LD_INT 1
119924: PPUSH
119925: LD_VAR 0 1
119929: PPUSH
119930: CALL_OW 12
119934: ARRAY
119935: PPUSH
119936: LD_INT 1
119938: PPUSH
119939: CALL_OW 234
// end ;
119943: PPOPN 1
119945: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
119946: LD_EXP 144
119950: PUSH
119951: LD_EXP 192
119955: AND
119956: IFFALSE 120068
119958: GO 119960
119960: DISABLE
119961: LD_INT 0
119963: PPUSH
119964: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
119965: LD_ADDR_VAR 0 2
119969: PUSH
119970: LD_INT 22
119972: PUSH
119973: LD_OWVAR 2
119977: PUSH
119978: EMPTY
119979: LIST
119980: LIST
119981: PUSH
119982: LD_INT 2
119984: PUSH
119985: LD_INT 30
119987: PUSH
119988: LD_INT 27
119990: PUSH
119991: EMPTY
119992: LIST
119993: LIST
119994: PUSH
119995: LD_INT 30
119997: PUSH
119998: LD_INT 26
120000: PUSH
120001: EMPTY
120002: LIST
120003: LIST
120004: PUSH
120005: LD_INT 30
120007: PUSH
120008: LD_INT 28
120010: PUSH
120011: EMPTY
120012: LIST
120013: LIST
120014: PUSH
120015: EMPTY
120016: LIST
120017: LIST
120018: LIST
120019: LIST
120020: PUSH
120021: EMPTY
120022: LIST
120023: LIST
120024: PPUSH
120025: CALL_OW 69
120029: ST_TO_ADDR
// if not tmp then
120030: LD_VAR 0 2
120034: NOT
120035: IFFALSE 120039
// exit ;
120037: GO 120068
// for i in tmp do
120039: LD_ADDR_VAR 0 1
120043: PUSH
120044: LD_VAR 0 2
120048: PUSH
120049: FOR_IN
120050: IFFALSE 120066
// SetLives ( i , 1 ) ;
120052: LD_VAR 0 1
120056: PPUSH
120057: LD_INT 1
120059: PPUSH
120060: CALL_OW 234
120064: GO 120049
120066: POP
120067: POP
// end ;
120068: PPOPN 2
120070: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
120071: LD_EXP 144
120075: PUSH
120076: LD_EXP 193
120080: AND
120081: IFFALSE 120368
120083: GO 120085
120085: DISABLE
120086: LD_INT 0
120088: PPUSH
120089: PPUSH
120090: PPUSH
// begin i := rand ( 1 , 7 ) ;
120091: LD_ADDR_VAR 0 1
120095: PUSH
120096: LD_INT 1
120098: PPUSH
120099: LD_INT 7
120101: PPUSH
120102: CALL_OW 12
120106: ST_TO_ADDR
// case i of 1 :
120107: LD_VAR 0 1
120111: PUSH
120112: LD_INT 1
120114: DOUBLE
120115: EQUAL
120116: IFTRUE 120120
120118: GO 120130
120120: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
120121: LD_STRING earthquake(getX(game), 0, 32)
120123: PPUSH
120124: CALL_OW 559
120128: GO 120368
120130: LD_INT 2
120132: DOUBLE
120133: EQUAL
120134: IFTRUE 120138
120136: GO 120152
120138: POP
// begin ToLua ( displayStucuk(); ) ;
120139: LD_STRING displayStucuk();
120141: PPUSH
120142: CALL_OW 559
// ResetFog ;
120146: CALL_OW 335
// end ; 3 :
120150: GO 120368
120152: LD_INT 3
120154: DOUBLE
120155: EQUAL
120156: IFTRUE 120160
120158: GO 120264
120160: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120161: LD_ADDR_VAR 0 2
120165: PUSH
120166: LD_INT 22
120168: PUSH
120169: LD_OWVAR 2
120173: PUSH
120174: EMPTY
120175: LIST
120176: LIST
120177: PUSH
120178: LD_INT 25
120180: PUSH
120181: LD_INT 1
120183: PUSH
120184: EMPTY
120185: LIST
120186: LIST
120187: PUSH
120188: EMPTY
120189: LIST
120190: LIST
120191: PPUSH
120192: CALL_OW 69
120196: ST_TO_ADDR
// if not tmp then
120197: LD_VAR 0 2
120201: NOT
120202: IFFALSE 120206
// exit ;
120204: GO 120368
// un := tmp [ rand ( 1 , tmp ) ] ;
120206: LD_ADDR_VAR 0 3
120210: PUSH
120211: LD_VAR 0 2
120215: PUSH
120216: LD_INT 1
120218: PPUSH
120219: LD_VAR 0 2
120223: PPUSH
120224: CALL_OW 12
120228: ARRAY
120229: ST_TO_ADDR
// if Crawls ( un ) then
120230: LD_VAR 0 3
120234: PPUSH
120235: CALL_OW 318
120239: IFFALSE 120250
// ComWalk ( un ) ;
120241: LD_VAR 0 3
120245: PPUSH
120246: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120250: LD_VAR 0 3
120254: PPUSH
120255: LD_INT 8
120257: PPUSH
120258: CALL_OW 336
// end ; 4 :
120262: GO 120368
120264: LD_INT 4
120266: DOUBLE
120267: EQUAL
120268: IFTRUE 120272
120270: GO 120346
120272: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120273: LD_ADDR_VAR 0 2
120277: PUSH
120278: LD_INT 22
120280: PUSH
120281: LD_OWVAR 2
120285: PUSH
120286: EMPTY
120287: LIST
120288: LIST
120289: PUSH
120290: LD_INT 30
120292: PUSH
120293: LD_INT 29
120295: PUSH
120296: EMPTY
120297: LIST
120298: LIST
120299: PUSH
120300: EMPTY
120301: LIST
120302: LIST
120303: PPUSH
120304: CALL_OW 69
120308: ST_TO_ADDR
// if not tmp then
120309: LD_VAR 0 2
120313: NOT
120314: IFFALSE 120318
// exit ;
120316: GO 120368
// CenterNowOnUnits ( tmp [ 1 ] ) ;
120318: LD_VAR 0 2
120322: PUSH
120323: LD_INT 1
120325: ARRAY
120326: PPUSH
120327: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
120331: LD_VAR 0 2
120335: PUSH
120336: LD_INT 1
120338: ARRAY
120339: PPUSH
120340: CALL_OW 65
// end ; 5 .. 7 :
120344: GO 120368
120346: LD_INT 5
120348: DOUBLE
120349: GREATEREQUAL
120350: IFFALSE 120358
120352: LD_INT 7
120354: DOUBLE
120355: LESSEQUAL
120356: IFTRUE 120360
120358: GO 120367
120360: POP
// StreamSibBomb ; end ;
120361: CALL 116605 0 0
120365: GO 120368
120367: POP
// end ;
120368: PPOPN 3
120370: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
120371: LD_EXP 144
120375: PUSH
120376: LD_EXP 194
120380: AND
120381: IFFALSE 120537
120383: GO 120385
120385: DISABLE
120386: LD_INT 0
120388: PPUSH
120389: PPUSH
120390: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
120391: LD_ADDR_VAR 0 2
120395: PUSH
120396: LD_INT 81
120398: PUSH
120399: LD_OWVAR 2
120403: PUSH
120404: EMPTY
120405: LIST
120406: LIST
120407: PUSH
120408: LD_INT 2
120410: PUSH
120411: LD_INT 21
120413: PUSH
120414: LD_INT 1
120416: PUSH
120417: EMPTY
120418: LIST
120419: LIST
120420: PUSH
120421: LD_INT 21
120423: PUSH
120424: LD_INT 2
120426: PUSH
120427: EMPTY
120428: LIST
120429: LIST
120430: PUSH
120431: EMPTY
120432: LIST
120433: LIST
120434: LIST
120435: PUSH
120436: EMPTY
120437: LIST
120438: LIST
120439: PPUSH
120440: CALL_OW 69
120444: ST_TO_ADDR
// if not tmp then
120445: LD_VAR 0 2
120449: NOT
120450: IFFALSE 120454
// exit ;
120452: GO 120537
// p := 0 ;
120454: LD_ADDR_VAR 0 3
120458: PUSH
120459: LD_INT 0
120461: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120462: LD_INT 35
120464: PPUSH
120465: CALL_OW 67
// p := p + 1 ;
120469: LD_ADDR_VAR 0 3
120473: PUSH
120474: LD_VAR 0 3
120478: PUSH
120479: LD_INT 1
120481: PLUS
120482: ST_TO_ADDR
// for i in tmp do
120483: LD_ADDR_VAR 0 1
120487: PUSH
120488: LD_VAR 0 2
120492: PUSH
120493: FOR_IN
120494: IFFALSE 120525
// if GetLives ( i ) < 1000 then
120496: LD_VAR 0 1
120500: PPUSH
120501: CALL_OW 256
120505: PUSH
120506: LD_INT 1000
120508: LESS
120509: IFFALSE 120523
// SetLives ( i , 1000 ) ;
120511: LD_VAR 0 1
120515: PPUSH
120516: LD_INT 1000
120518: PPUSH
120519: CALL_OW 234
120523: GO 120493
120525: POP
120526: POP
// until p > 20 ;
120527: LD_VAR 0 3
120531: PUSH
120532: LD_INT 20
120534: GREATER
120535: IFFALSE 120462
// end ;
120537: PPOPN 3
120539: END
// every 0 0$1 trigger StreamModeActive and sTime do
120540: LD_EXP 144
120544: PUSH
120545: LD_EXP 195
120549: AND
120550: IFFALSE 120585
120552: GO 120554
120554: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120555: LD_INT 28
120557: PPUSH
120558: LD_OWVAR 2
120562: PPUSH
120563: LD_INT 2
120565: PPUSH
120566: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120570: LD_INT 30
120572: PPUSH
120573: LD_OWVAR 2
120577: PPUSH
120578: LD_INT 2
120580: PPUSH
120581: CALL_OW 322
// end ;
120585: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120586: LD_EXP 144
120590: PUSH
120591: LD_EXP 196
120595: AND
120596: IFFALSE 120717
120598: GO 120600
120600: DISABLE
120601: LD_INT 0
120603: PPUSH
120604: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120605: LD_ADDR_VAR 0 2
120609: PUSH
120610: LD_INT 22
120612: PUSH
120613: LD_OWVAR 2
120617: PUSH
120618: EMPTY
120619: LIST
120620: LIST
120621: PUSH
120622: LD_INT 21
120624: PUSH
120625: LD_INT 1
120627: PUSH
120628: EMPTY
120629: LIST
120630: LIST
120631: PUSH
120632: LD_INT 3
120634: PUSH
120635: LD_INT 23
120637: PUSH
120638: LD_INT 0
120640: PUSH
120641: EMPTY
120642: LIST
120643: LIST
120644: PUSH
120645: EMPTY
120646: LIST
120647: LIST
120648: PUSH
120649: EMPTY
120650: LIST
120651: LIST
120652: LIST
120653: PPUSH
120654: CALL_OW 69
120658: ST_TO_ADDR
// if not tmp then
120659: LD_VAR 0 2
120663: NOT
120664: IFFALSE 120668
// exit ;
120666: GO 120717
// for i in tmp do
120668: LD_ADDR_VAR 0 1
120672: PUSH
120673: LD_VAR 0 2
120677: PUSH
120678: FOR_IN
120679: IFFALSE 120715
// begin if Crawls ( i ) then
120681: LD_VAR 0 1
120685: PPUSH
120686: CALL_OW 318
120690: IFFALSE 120701
// ComWalk ( i ) ;
120692: LD_VAR 0 1
120696: PPUSH
120697: CALL_OW 138
// SetClass ( i , 2 ) ;
120701: LD_VAR 0 1
120705: PPUSH
120706: LD_INT 2
120708: PPUSH
120709: CALL_OW 336
// end ;
120713: GO 120678
120715: POP
120716: POP
// end ;
120717: PPOPN 2
120719: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120720: LD_EXP 144
120724: PUSH
120725: LD_EXP 197
120729: AND
120730: IFFALSE 121018
120732: GO 120734
120734: DISABLE
120735: LD_INT 0
120737: PPUSH
120738: PPUSH
120739: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120740: LD_OWVAR 2
120744: PPUSH
120745: LD_INT 9
120747: PPUSH
120748: LD_INT 1
120750: PPUSH
120751: LD_INT 1
120753: PPUSH
120754: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120758: LD_INT 9
120760: PPUSH
120761: LD_OWVAR 2
120765: PPUSH
120766: CALL_OW 343
// uc_side := 9 ;
120770: LD_ADDR_OWVAR 20
120774: PUSH
120775: LD_INT 9
120777: ST_TO_ADDR
// uc_nation := 2 ;
120778: LD_ADDR_OWVAR 21
120782: PUSH
120783: LD_INT 2
120785: ST_TO_ADDR
// hc_name := Dark Warrior ;
120786: LD_ADDR_OWVAR 26
120790: PUSH
120791: LD_STRING Dark Warrior
120793: ST_TO_ADDR
// hc_gallery :=  ;
120794: LD_ADDR_OWVAR 33
120798: PUSH
120799: LD_STRING 
120801: ST_TO_ADDR
// hc_noskilllimit := true ;
120802: LD_ADDR_OWVAR 76
120806: PUSH
120807: LD_INT 1
120809: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
120810: LD_ADDR_OWVAR 31
120814: PUSH
120815: LD_INT 30
120817: PUSH
120818: LD_INT 30
120820: PUSH
120821: LD_INT 30
120823: PUSH
120824: LD_INT 30
120826: PUSH
120827: EMPTY
120828: LIST
120829: LIST
120830: LIST
120831: LIST
120832: ST_TO_ADDR
// un := CreateHuman ;
120833: LD_ADDR_VAR 0 3
120837: PUSH
120838: CALL_OW 44
120842: ST_TO_ADDR
// hc_noskilllimit := false ;
120843: LD_ADDR_OWVAR 76
120847: PUSH
120848: LD_INT 0
120850: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120851: LD_VAR 0 3
120855: PPUSH
120856: LD_INT 1
120858: PPUSH
120859: CALL_OW 51
// ToLua ( playRanger() ) ;
120863: LD_STRING playRanger()
120865: PPUSH
120866: CALL_OW 559
// p := 0 ;
120870: LD_ADDR_VAR 0 2
120874: PUSH
120875: LD_INT 0
120877: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120878: LD_INT 35
120880: PPUSH
120881: CALL_OW 67
// p := p + 1 ;
120885: LD_ADDR_VAR 0 2
120889: PUSH
120890: LD_VAR 0 2
120894: PUSH
120895: LD_INT 1
120897: PLUS
120898: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
120899: LD_VAR 0 3
120903: PPUSH
120904: CALL_OW 256
120908: PUSH
120909: LD_INT 1000
120911: LESS
120912: IFFALSE 120926
// SetLives ( un , 1000 ) ;
120914: LD_VAR 0 3
120918: PPUSH
120919: LD_INT 1000
120921: PPUSH
120922: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
120926: LD_VAR 0 3
120930: PPUSH
120931: LD_INT 81
120933: PUSH
120934: LD_OWVAR 2
120938: PUSH
120939: EMPTY
120940: LIST
120941: LIST
120942: PUSH
120943: LD_INT 91
120945: PUSH
120946: LD_VAR 0 3
120950: PUSH
120951: LD_INT 30
120953: PUSH
120954: EMPTY
120955: LIST
120956: LIST
120957: LIST
120958: PUSH
120959: EMPTY
120960: LIST
120961: LIST
120962: PPUSH
120963: CALL_OW 69
120967: PPUSH
120968: LD_VAR 0 3
120972: PPUSH
120973: CALL_OW 74
120977: PPUSH
120978: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
120982: LD_VAR 0 2
120986: PUSH
120987: LD_INT 80
120989: GREATER
120990: PUSH
120991: LD_VAR 0 3
120995: PPUSH
120996: CALL_OW 301
121000: OR
121001: IFFALSE 120878
// if un then
121003: LD_VAR 0 3
121007: IFFALSE 121018
// RemoveUnit ( un ) ;
121009: LD_VAR 0 3
121013: PPUSH
121014: CALL_OW 64
// end ;
121018: PPOPN 3
121020: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
121021: LD_EXP 198
121025: IFFALSE 121141
121027: GO 121029
121029: DISABLE
121030: LD_INT 0
121032: PPUSH
121033: PPUSH
121034: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
121035: LD_ADDR_VAR 0 2
121039: PUSH
121040: LD_INT 81
121042: PUSH
121043: LD_OWVAR 2
121047: PUSH
121048: EMPTY
121049: LIST
121050: LIST
121051: PUSH
121052: LD_INT 21
121054: PUSH
121055: LD_INT 1
121057: PUSH
121058: EMPTY
121059: LIST
121060: LIST
121061: PUSH
121062: EMPTY
121063: LIST
121064: LIST
121065: PPUSH
121066: CALL_OW 69
121070: ST_TO_ADDR
// ToLua ( playComputer() ) ;
121071: LD_STRING playComputer()
121073: PPUSH
121074: CALL_OW 559
// if not tmp then
121078: LD_VAR 0 2
121082: NOT
121083: IFFALSE 121087
// exit ;
121085: GO 121141
// for i in tmp do
121087: LD_ADDR_VAR 0 1
121091: PUSH
121092: LD_VAR 0 2
121096: PUSH
121097: FOR_IN
121098: IFFALSE 121139
// for j := 1 to 4 do
121100: LD_ADDR_VAR 0 3
121104: PUSH
121105: DOUBLE
121106: LD_INT 1
121108: DEC
121109: ST_TO_ADDR
121110: LD_INT 4
121112: PUSH
121113: FOR_TO
121114: IFFALSE 121135
// SetSkill ( i , j , 10 ) ;
121116: LD_VAR 0 1
121120: PPUSH
121121: LD_VAR 0 3
121125: PPUSH
121126: LD_INT 10
121128: PPUSH
121129: CALL_OW 237
121133: GO 121113
121135: POP
121136: POP
121137: GO 121097
121139: POP
121140: POP
// end ;
121141: PPOPN 3
121143: END
// every 0 0$1 trigger s30 do var i , tmp ;
121144: LD_EXP 199
121148: IFFALSE 121217
121150: GO 121152
121152: DISABLE
121153: LD_INT 0
121155: PPUSH
121156: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121157: LD_ADDR_VAR 0 2
121161: PUSH
121162: LD_INT 22
121164: PUSH
121165: LD_OWVAR 2
121169: PUSH
121170: EMPTY
121171: LIST
121172: LIST
121173: PPUSH
121174: CALL_OW 69
121178: ST_TO_ADDR
// if not tmp then
121179: LD_VAR 0 2
121183: NOT
121184: IFFALSE 121188
// exit ;
121186: GO 121217
// for i in tmp do
121188: LD_ADDR_VAR 0 1
121192: PUSH
121193: LD_VAR 0 2
121197: PUSH
121198: FOR_IN
121199: IFFALSE 121215
// SetLives ( i , 300 ) ;
121201: LD_VAR 0 1
121205: PPUSH
121206: LD_INT 300
121208: PPUSH
121209: CALL_OW 234
121213: GO 121198
121215: POP
121216: POP
// end ;
121217: PPOPN 2
121219: END
// every 0 0$1 trigger s60 do var i , tmp ;
121220: LD_EXP 200
121224: IFFALSE 121293
121226: GO 121228
121228: DISABLE
121229: LD_INT 0
121231: PPUSH
121232: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121233: LD_ADDR_VAR 0 2
121237: PUSH
121238: LD_INT 22
121240: PUSH
121241: LD_OWVAR 2
121245: PUSH
121246: EMPTY
121247: LIST
121248: LIST
121249: PPUSH
121250: CALL_OW 69
121254: ST_TO_ADDR
// if not tmp then
121255: LD_VAR 0 2
121259: NOT
121260: IFFALSE 121264
// exit ;
121262: GO 121293
// for i in tmp do
121264: LD_ADDR_VAR 0 1
121268: PUSH
121269: LD_VAR 0 2
121273: PUSH
121274: FOR_IN
121275: IFFALSE 121291
// SetLives ( i , 600 ) ;
121277: LD_VAR 0 1
121281: PPUSH
121282: LD_INT 600
121284: PPUSH
121285: CALL_OW 234
121289: GO 121274
121291: POP
121292: POP
// end ;
121293: PPOPN 2
121295: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
121296: LD_INT 0
121298: PPUSH
// case cmd of 301 :
121299: LD_VAR 0 1
121303: PUSH
121304: LD_INT 301
121306: DOUBLE
121307: EQUAL
121308: IFTRUE 121312
121310: GO 121344
121312: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
121313: LD_VAR 0 6
121317: PPUSH
121318: LD_VAR 0 7
121322: PPUSH
121323: LD_VAR 0 8
121327: PPUSH
121328: LD_VAR 0 4
121332: PPUSH
121333: LD_VAR 0 5
121337: PPUSH
121338: CALL 122545 0 5
121342: GO 121465
121344: LD_INT 302
121346: DOUBLE
121347: EQUAL
121348: IFTRUE 121352
121350: GO 121389
121352: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
121353: LD_VAR 0 6
121357: PPUSH
121358: LD_VAR 0 7
121362: PPUSH
121363: LD_VAR 0 8
121367: PPUSH
121368: LD_VAR 0 9
121372: PPUSH
121373: LD_VAR 0 4
121377: PPUSH
121378: LD_VAR 0 5
121382: PPUSH
121383: CALL 122636 0 6
121387: GO 121465
121389: LD_INT 303
121391: DOUBLE
121392: EQUAL
121393: IFTRUE 121397
121395: GO 121434
121397: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
121398: LD_VAR 0 6
121402: PPUSH
121403: LD_VAR 0 7
121407: PPUSH
121408: LD_VAR 0 8
121412: PPUSH
121413: LD_VAR 0 9
121417: PPUSH
121418: LD_VAR 0 4
121422: PPUSH
121423: LD_VAR 0 5
121427: PPUSH
121428: CALL 121470 0 6
121432: GO 121465
121434: LD_INT 304
121436: DOUBLE
121437: EQUAL
121438: IFTRUE 121442
121440: GO 121464
121442: POP
// hHackTeleport ( unit , x , y ) ; end ;
121443: LD_VAR 0 2
121447: PPUSH
121448: LD_VAR 0 4
121452: PPUSH
121453: LD_VAR 0 5
121457: PPUSH
121458: CALL 123229 0 3
121462: GO 121465
121464: POP
// end ;
121465: LD_VAR 0 12
121469: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
121470: LD_INT 0
121472: PPUSH
121473: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
121474: LD_VAR 0 1
121478: PUSH
121479: LD_INT 1
121481: LESS
121482: PUSH
121483: LD_VAR 0 1
121487: PUSH
121488: LD_INT 3
121490: GREATER
121491: OR
121492: PUSH
121493: LD_VAR 0 5
121497: PPUSH
121498: LD_VAR 0 6
121502: PPUSH
121503: CALL_OW 428
121507: OR
121508: IFFALSE 121512
// exit ;
121510: GO 122232
// uc_side := your_side ;
121512: LD_ADDR_OWVAR 20
121516: PUSH
121517: LD_OWVAR 2
121521: ST_TO_ADDR
// uc_nation := nation ;
121522: LD_ADDR_OWVAR 21
121526: PUSH
121527: LD_VAR 0 1
121531: ST_TO_ADDR
// bc_level = 1 ;
121532: LD_ADDR_OWVAR 43
121536: PUSH
121537: LD_INT 1
121539: ST_TO_ADDR
// case btype of 1 :
121540: LD_VAR 0 2
121544: PUSH
121545: LD_INT 1
121547: DOUBLE
121548: EQUAL
121549: IFTRUE 121553
121551: GO 121564
121553: POP
// bc_type := b_depot ; 2 :
121554: LD_ADDR_OWVAR 42
121558: PUSH
121559: LD_INT 0
121561: ST_TO_ADDR
121562: GO 122176
121564: LD_INT 2
121566: DOUBLE
121567: EQUAL
121568: IFTRUE 121572
121570: GO 121583
121572: POP
// bc_type := b_warehouse ; 3 :
121573: LD_ADDR_OWVAR 42
121577: PUSH
121578: LD_INT 1
121580: ST_TO_ADDR
121581: GO 122176
121583: LD_INT 3
121585: DOUBLE
121586: EQUAL
121587: IFTRUE 121591
121589: GO 121602
121591: POP
// bc_type := b_lab ; 4 .. 9 :
121592: LD_ADDR_OWVAR 42
121596: PUSH
121597: LD_INT 6
121599: ST_TO_ADDR
121600: GO 122176
121602: LD_INT 4
121604: DOUBLE
121605: GREATEREQUAL
121606: IFFALSE 121614
121608: LD_INT 9
121610: DOUBLE
121611: LESSEQUAL
121612: IFTRUE 121616
121614: GO 121668
121616: POP
// begin bc_type := b_lab_half ;
121617: LD_ADDR_OWVAR 42
121621: PUSH
121622: LD_INT 7
121624: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121625: LD_ADDR_OWVAR 44
121629: PUSH
121630: LD_INT 10
121632: PUSH
121633: LD_INT 11
121635: PUSH
121636: LD_INT 12
121638: PUSH
121639: LD_INT 15
121641: PUSH
121642: LD_INT 14
121644: PUSH
121645: LD_INT 13
121647: PUSH
121648: EMPTY
121649: LIST
121650: LIST
121651: LIST
121652: LIST
121653: LIST
121654: LIST
121655: PUSH
121656: LD_VAR 0 2
121660: PUSH
121661: LD_INT 3
121663: MINUS
121664: ARRAY
121665: ST_TO_ADDR
// end ; 10 .. 13 :
121666: GO 122176
121668: LD_INT 10
121670: DOUBLE
121671: GREATEREQUAL
121672: IFFALSE 121680
121674: LD_INT 13
121676: DOUBLE
121677: LESSEQUAL
121678: IFTRUE 121682
121680: GO 121759
121682: POP
// begin bc_type := b_lab_full ;
121683: LD_ADDR_OWVAR 42
121687: PUSH
121688: LD_INT 8
121690: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121691: LD_ADDR_OWVAR 44
121695: PUSH
121696: LD_INT 10
121698: PUSH
121699: LD_INT 12
121701: PUSH
121702: LD_INT 14
121704: PUSH
121705: LD_INT 13
121707: PUSH
121708: EMPTY
121709: LIST
121710: LIST
121711: LIST
121712: LIST
121713: PUSH
121714: LD_VAR 0 2
121718: PUSH
121719: LD_INT 9
121721: MINUS
121722: ARRAY
121723: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121724: LD_ADDR_OWVAR 45
121728: PUSH
121729: LD_INT 11
121731: PUSH
121732: LD_INT 15
121734: PUSH
121735: LD_INT 12
121737: PUSH
121738: LD_INT 15
121740: PUSH
121741: EMPTY
121742: LIST
121743: LIST
121744: LIST
121745: LIST
121746: PUSH
121747: LD_VAR 0 2
121751: PUSH
121752: LD_INT 9
121754: MINUS
121755: ARRAY
121756: ST_TO_ADDR
// end ; 14 :
121757: GO 122176
121759: LD_INT 14
121761: DOUBLE
121762: EQUAL
121763: IFTRUE 121767
121765: GO 121778
121767: POP
// bc_type := b_workshop ; 15 :
121768: LD_ADDR_OWVAR 42
121772: PUSH
121773: LD_INT 2
121775: ST_TO_ADDR
121776: GO 122176
121778: LD_INT 15
121780: DOUBLE
121781: EQUAL
121782: IFTRUE 121786
121784: GO 121797
121786: POP
// bc_type := b_factory ; 16 :
121787: LD_ADDR_OWVAR 42
121791: PUSH
121792: LD_INT 3
121794: ST_TO_ADDR
121795: GO 122176
121797: LD_INT 16
121799: DOUBLE
121800: EQUAL
121801: IFTRUE 121805
121803: GO 121816
121805: POP
// bc_type := b_ext_gun ; 17 :
121806: LD_ADDR_OWVAR 42
121810: PUSH
121811: LD_INT 17
121813: ST_TO_ADDR
121814: GO 122176
121816: LD_INT 17
121818: DOUBLE
121819: EQUAL
121820: IFTRUE 121824
121822: GO 121852
121824: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
121825: LD_ADDR_OWVAR 42
121829: PUSH
121830: LD_INT 19
121832: PUSH
121833: LD_INT 23
121835: PUSH
121836: LD_INT 19
121838: PUSH
121839: EMPTY
121840: LIST
121841: LIST
121842: LIST
121843: PUSH
121844: LD_VAR 0 1
121848: ARRAY
121849: ST_TO_ADDR
121850: GO 122176
121852: LD_INT 18
121854: DOUBLE
121855: EQUAL
121856: IFTRUE 121860
121858: GO 121871
121860: POP
// bc_type := b_ext_radar ; 19 :
121861: LD_ADDR_OWVAR 42
121865: PUSH
121866: LD_INT 20
121868: ST_TO_ADDR
121869: GO 122176
121871: LD_INT 19
121873: DOUBLE
121874: EQUAL
121875: IFTRUE 121879
121877: GO 121890
121879: POP
// bc_type := b_ext_radio ; 20 :
121880: LD_ADDR_OWVAR 42
121884: PUSH
121885: LD_INT 22
121887: ST_TO_ADDR
121888: GO 122176
121890: LD_INT 20
121892: DOUBLE
121893: EQUAL
121894: IFTRUE 121898
121896: GO 121909
121898: POP
// bc_type := b_ext_siberium ; 21 :
121899: LD_ADDR_OWVAR 42
121903: PUSH
121904: LD_INT 21
121906: ST_TO_ADDR
121907: GO 122176
121909: LD_INT 21
121911: DOUBLE
121912: EQUAL
121913: IFTRUE 121917
121915: GO 121928
121917: POP
// bc_type := b_ext_computer ; 22 :
121918: LD_ADDR_OWVAR 42
121922: PUSH
121923: LD_INT 24
121925: ST_TO_ADDR
121926: GO 122176
121928: LD_INT 22
121930: DOUBLE
121931: EQUAL
121932: IFTRUE 121936
121934: GO 121947
121936: POP
// bc_type := b_ext_track ; 23 :
121937: LD_ADDR_OWVAR 42
121941: PUSH
121942: LD_INT 16
121944: ST_TO_ADDR
121945: GO 122176
121947: LD_INT 23
121949: DOUBLE
121950: EQUAL
121951: IFTRUE 121955
121953: GO 121966
121955: POP
// bc_type := b_ext_laser ; 24 :
121956: LD_ADDR_OWVAR 42
121960: PUSH
121961: LD_INT 25
121963: ST_TO_ADDR
121964: GO 122176
121966: LD_INT 24
121968: DOUBLE
121969: EQUAL
121970: IFTRUE 121974
121972: GO 121985
121974: POP
// bc_type := b_control_tower ; 25 :
121975: LD_ADDR_OWVAR 42
121979: PUSH
121980: LD_INT 36
121982: ST_TO_ADDR
121983: GO 122176
121985: LD_INT 25
121987: DOUBLE
121988: EQUAL
121989: IFTRUE 121993
121991: GO 122004
121993: POP
// bc_type := b_breastwork ; 26 :
121994: LD_ADDR_OWVAR 42
121998: PUSH
121999: LD_INT 31
122001: ST_TO_ADDR
122002: GO 122176
122004: LD_INT 26
122006: DOUBLE
122007: EQUAL
122008: IFTRUE 122012
122010: GO 122023
122012: POP
// bc_type := b_bunker ; 27 :
122013: LD_ADDR_OWVAR 42
122017: PUSH
122018: LD_INT 32
122020: ST_TO_ADDR
122021: GO 122176
122023: LD_INT 27
122025: DOUBLE
122026: EQUAL
122027: IFTRUE 122031
122029: GO 122042
122031: POP
// bc_type := b_turret ; 28 :
122032: LD_ADDR_OWVAR 42
122036: PUSH
122037: LD_INT 33
122039: ST_TO_ADDR
122040: GO 122176
122042: LD_INT 28
122044: DOUBLE
122045: EQUAL
122046: IFTRUE 122050
122048: GO 122061
122050: POP
// bc_type := b_armoury ; 29 :
122051: LD_ADDR_OWVAR 42
122055: PUSH
122056: LD_INT 4
122058: ST_TO_ADDR
122059: GO 122176
122061: LD_INT 29
122063: DOUBLE
122064: EQUAL
122065: IFTRUE 122069
122067: GO 122080
122069: POP
// bc_type := b_barracks ; 30 :
122070: LD_ADDR_OWVAR 42
122074: PUSH
122075: LD_INT 5
122077: ST_TO_ADDR
122078: GO 122176
122080: LD_INT 30
122082: DOUBLE
122083: EQUAL
122084: IFTRUE 122088
122086: GO 122099
122088: POP
// bc_type := b_solar_power ; 31 :
122089: LD_ADDR_OWVAR 42
122093: PUSH
122094: LD_INT 27
122096: ST_TO_ADDR
122097: GO 122176
122099: LD_INT 31
122101: DOUBLE
122102: EQUAL
122103: IFTRUE 122107
122105: GO 122118
122107: POP
// bc_type := b_oil_power ; 32 :
122108: LD_ADDR_OWVAR 42
122112: PUSH
122113: LD_INT 26
122115: ST_TO_ADDR
122116: GO 122176
122118: LD_INT 32
122120: DOUBLE
122121: EQUAL
122122: IFTRUE 122126
122124: GO 122137
122126: POP
// bc_type := b_siberite_power ; 33 :
122127: LD_ADDR_OWVAR 42
122131: PUSH
122132: LD_INT 28
122134: ST_TO_ADDR
122135: GO 122176
122137: LD_INT 33
122139: DOUBLE
122140: EQUAL
122141: IFTRUE 122145
122143: GO 122156
122145: POP
// bc_type := b_oil_mine ; 34 :
122146: LD_ADDR_OWVAR 42
122150: PUSH
122151: LD_INT 29
122153: ST_TO_ADDR
122154: GO 122176
122156: LD_INT 34
122158: DOUBLE
122159: EQUAL
122160: IFTRUE 122164
122162: GO 122175
122164: POP
// bc_type := b_siberite_mine ; end ;
122165: LD_ADDR_OWVAR 42
122169: PUSH
122170: LD_INT 30
122172: ST_TO_ADDR
122173: GO 122176
122175: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
122176: LD_ADDR_VAR 0 8
122180: PUSH
122181: LD_VAR 0 5
122185: PPUSH
122186: LD_VAR 0 6
122190: PPUSH
122191: LD_VAR 0 3
122195: PPUSH
122196: CALL_OW 47
122200: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
122201: LD_OWVAR 42
122205: PUSH
122206: LD_INT 32
122208: PUSH
122209: LD_INT 33
122211: PUSH
122212: EMPTY
122213: LIST
122214: LIST
122215: IN
122216: IFFALSE 122232
// PlaceWeaponTurret ( b , weapon ) ;
122218: LD_VAR 0 8
122222: PPUSH
122223: LD_VAR 0 4
122227: PPUSH
122228: CALL_OW 431
// end ;
122232: LD_VAR 0 7
122236: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
122237: LD_INT 0
122239: PPUSH
122240: PPUSH
122241: PPUSH
122242: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122243: LD_ADDR_VAR 0 4
122247: PUSH
122248: LD_INT 22
122250: PUSH
122251: LD_OWVAR 2
122255: PUSH
122256: EMPTY
122257: LIST
122258: LIST
122259: PUSH
122260: LD_INT 2
122262: PUSH
122263: LD_INT 30
122265: PUSH
122266: LD_INT 0
122268: PUSH
122269: EMPTY
122270: LIST
122271: LIST
122272: PUSH
122273: LD_INT 30
122275: PUSH
122276: LD_INT 1
122278: PUSH
122279: EMPTY
122280: LIST
122281: LIST
122282: PUSH
122283: EMPTY
122284: LIST
122285: LIST
122286: LIST
122287: PUSH
122288: EMPTY
122289: LIST
122290: LIST
122291: PPUSH
122292: CALL_OW 69
122296: ST_TO_ADDR
// if not tmp then
122297: LD_VAR 0 4
122301: NOT
122302: IFFALSE 122306
// exit ;
122304: GO 122365
// for i in tmp do
122306: LD_ADDR_VAR 0 2
122310: PUSH
122311: LD_VAR 0 4
122315: PUSH
122316: FOR_IN
122317: IFFALSE 122363
// for j = 1 to 3 do
122319: LD_ADDR_VAR 0 3
122323: PUSH
122324: DOUBLE
122325: LD_INT 1
122327: DEC
122328: ST_TO_ADDR
122329: LD_INT 3
122331: PUSH
122332: FOR_TO
122333: IFFALSE 122359
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
122335: LD_VAR 0 2
122339: PPUSH
122340: CALL_OW 274
122344: PPUSH
122345: LD_VAR 0 3
122349: PPUSH
122350: LD_INT 99999
122352: PPUSH
122353: CALL_OW 277
122357: GO 122332
122359: POP
122360: POP
122361: GO 122316
122363: POP
122364: POP
// end ;
122365: LD_VAR 0 1
122369: RET
// export function hHackSetLevel10 ; var i , j ; begin
122370: LD_INT 0
122372: PPUSH
122373: PPUSH
122374: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122375: LD_ADDR_VAR 0 2
122379: PUSH
122380: LD_INT 21
122382: PUSH
122383: LD_INT 1
122385: PUSH
122386: EMPTY
122387: LIST
122388: LIST
122389: PPUSH
122390: CALL_OW 69
122394: PUSH
122395: FOR_IN
122396: IFFALSE 122448
// if IsSelected ( i ) then
122398: LD_VAR 0 2
122402: PPUSH
122403: CALL_OW 306
122407: IFFALSE 122446
// begin for j := 1 to 4 do
122409: LD_ADDR_VAR 0 3
122413: PUSH
122414: DOUBLE
122415: LD_INT 1
122417: DEC
122418: ST_TO_ADDR
122419: LD_INT 4
122421: PUSH
122422: FOR_TO
122423: IFFALSE 122444
// SetSkill ( i , j , 10 ) ;
122425: LD_VAR 0 2
122429: PPUSH
122430: LD_VAR 0 3
122434: PPUSH
122435: LD_INT 10
122437: PPUSH
122438: CALL_OW 237
122442: GO 122422
122444: POP
122445: POP
// end ;
122446: GO 122395
122448: POP
122449: POP
// end ;
122450: LD_VAR 0 1
122454: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
122455: LD_INT 0
122457: PPUSH
122458: PPUSH
122459: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
122460: LD_ADDR_VAR 0 2
122464: PUSH
122465: LD_INT 22
122467: PUSH
122468: LD_OWVAR 2
122472: PUSH
122473: EMPTY
122474: LIST
122475: LIST
122476: PUSH
122477: LD_INT 21
122479: PUSH
122480: LD_INT 1
122482: PUSH
122483: EMPTY
122484: LIST
122485: LIST
122486: PUSH
122487: EMPTY
122488: LIST
122489: LIST
122490: PPUSH
122491: CALL_OW 69
122495: PUSH
122496: FOR_IN
122497: IFFALSE 122538
// begin for j := 1 to 4 do
122499: LD_ADDR_VAR 0 3
122503: PUSH
122504: DOUBLE
122505: LD_INT 1
122507: DEC
122508: ST_TO_ADDR
122509: LD_INT 4
122511: PUSH
122512: FOR_TO
122513: IFFALSE 122534
// SetSkill ( i , j , 10 ) ;
122515: LD_VAR 0 2
122519: PPUSH
122520: LD_VAR 0 3
122524: PPUSH
122525: LD_INT 10
122527: PPUSH
122528: CALL_OW 237
122532: GO 122512
122534: POP
122535: POP
// end ;
122536: GO 122496
122538: POP
122539: POP
// end ;
122540: LD_VAR 0 1
122544: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122545: LD_INT 0
122547: PPUSH
// uc_side := your_side ;
122548: LD_ADDR_OWVAR 20
122552: PUSH
122553: LD_OWVAR 2
122557: ST_TO_ADDR
// uc_nation := nation ;
122558: LD_ADDR_OWVAR 21
122562: PUSH
122563: LD_VAR 0 1
122567: ST_TO_ADDR
// InitHc ;
122568: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122572: LD_INT 0
122574: PPUSH
122575: LD_VAR 0 2
122579: PPUSH
122580: LD_VAR 0 3
122584: PPUSH
122585: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122589: LD_VAR 0 4
122593: PPUSH
122594: LD_VAR 0 5
122598: PPUSH
122599: CALL_OW 428
122603: PUSH
122604: LD_INT 0
122606: EQUAL
122607: IFFALSE 122631
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122609: CALL_OW 44
122613: PPUSH
122614: LD_VAR 0 4
122618: PPUSH
122619: LD_VAR 0 5
122623: PPUSH
122624: LD_INT 1
122626: PPUSH
122627: CALL_OW 48
// end ;
122631: LD_VAR 0 6
122635: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122636: LD_INT 0
122638: PPUSH
122639: PPUSH
// uc_side := your_side ;
122640: LD_ADDR_OWVAR 20
122644: PUSH
122645: LD_OWVAR 2
122649: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122650: LD_VAR 0 1
122654: PUSH
122655: LD_INT 1
122657: PUSH
122658: LD_INT 2
122660: PUSH
122661: LD_INT 3
122663: PUSH
122664: LD_INT 4
122666: PUSH
122667: LD_INT 5
122669: PUSH
122670: EMPTY
122671: LIST
122672: LIST
122673: LIST
122674: LIST
122675: LIST
122676: IN
122677: IFFALSE 122689
// uc_nation := nation_american else
122679: LD_ADDR_OWVAR 21
122683: PUSH
122684: LD_INT 1
122686: ST_TO_ADDR
122687: GO 122732
// if chassis in [ 11 , 12 , 13 , 14 ] then
122689: LD_VAR 0 1
122693: PUSH
122694: LD_INT 11
122696: PUSH
122697: LD_INT 12
122699: PUSH
122700: LD_INT 13
122702: PUSH
122703: LD_INT 14
122705: PUSH
122706: EMPTY
122707: LIST
122708: LIST
122709: LIST
122710: LIST
122711: IN
122712: IFFALSE 122724
// uc_nation := nation_arabian else
122714: LD_ADDR_OWVAR 21
122718: PUSH
122719: LD_INT 2
122721: ST_TO_ADDR
122722: GO 122732
// uc_nation := nation_russian ;
122724: LD_ADDR_OWVAR 21
122728: PUSH
122729: LD_INT 3
122731: ST_TO_ADDR
// vc_chassis := chassis ;
122732: LD_ADDR_OWVAR 37
122736: PUSH
122737: LD_VAR 0 1
122741: ST_TO_ADDR
// vc_engine := engine ;
122742: LD_ADDR_OWVAR 39
122746: PUSH
122747: LD_VAR 0 2
122751: ST_TO_ADDR
// vc_control := control ;
122752: LD_ADDR_OWVAR 38
122756: PUSH
122757: LD_VAR 0 3
122761: ST_TO_ADDR
// vc_weapon := weapon ;
122762: LD_ADDR_OWVAR 40
122766: PUSH
122767: LD_VAR 0 4
122771: ST_TO_ADDR
// un := CreateVehicle ;
122772: LD_ADDR_VAR 0 8
122776: PUSH
122777: CALL_OW 45
122781: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122782: LD_VAR 0 8
122786: PPUSH
122787: LD_INT 0
122789: PPUSH
122790: LD_INT 5
122792: PPUSH
122793: CALL_OW 12
122797: PPUSH
122798: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
122802: LD_VAR 0 8
122806: PPUSH
122807: LD_VAR 0 5
122811: PPUSH
122812: LD_VAR 0 6
122816: PPUSH
122817: LD_INT 1
122819: PPUSH
122820: CALL_OW 48
// end ;
122824: LD_VAR 0 7
122828: RET
// export hInvincible ; every 1 do
122829: GO 122831
122831: DISABLE
// hInvincible := [ ] ;
122832: LD_ADDR_EXP 201
122836: PUSH
122837: EMPTY
122838: ST_TO_ADDR
122839: END
// every 10 do var i ;
122840: GO 122842
122842: DISABLE
122843: LD_INT 0
122845: PPUSH
// begin enable ;
122846: ENABLE
// if not hInvincible then
122847: LD_EXP 201
122851: NOT
122852: IFFALSE 122856
// exit ;
122854: GO 122900
// for i in hInvincible do
122856: LD_ADDR_VAR 0 1
122860: PUSH
122861: LD_EXP 201
122865: PUSH
122866: FOR_IN
122867: IFFALSE 122898
// if GetLives ( i ) < 1000 then
122869: LD_VAR 0 1
122873: PPUSH
122874: CALL_OW 256
122878: PUSH
122879: LD_INT 1000
122881: LESS
122882: IFFALSE 122896
// SetLives ( i , 1000 ) ;
122884: LD_VAR 0 1
122888: PPUSH
122889: LD_INT 1000
122891: PPUSH
122892: CALL_OW 234
122896: GO 122866
122898: POP
122899: POP
// end ;
122900: PPOPN 1
122902: END
// export function hHackInvincible ; var i ; begin
122903: LD_INT 0
122905: PPUSH
122906: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
122907: LD_ADDR_VAR 0 2
122911: PUSH
122912: LD_INT 2
122914: PUSH
122915: LD_INT 21
122917: PUSH
122918: LD_INT 1
122920: PUSH
122921: EMPTY
122922: LIST
122923: LIST
122924: PUSH
122925: LD_INT 21
122927: PUSH
122928: LD_INT 2
122930: PUSH
122931: EMPTY
122932: LIST
122933: LIST
122934: PUSH
122935: EMPTY
122936: LIST
122937: LIST
122938: LIST
122939: PPUSH
122940: CALL_OW 69
122944: PUSH
122945: FOR_IN
122946: IFFALSE 123007
// if IsSelected ( i ) then
122948: LD_VAR 0 2
122952: PPUSH
122953: CALL_OW 306
122957: IFFALSE 123005
// begin if i in hInvincible then
122959: LD_VAR 0 2
122963: PUSH
122964: LD_EXP 201
122968: IN
122969: IFFALSE 122989
// hInvincible := hInvincible diff i else
122971: LD_ADDR_EXP 201
122975: PUSH
122976: LD_EXP 201
122980: PUSH
122981: LD_VAR 0 2
122985: DIFF
122986: ST_TO_ADDR
122987: GO 123005
// hInvincible := hInvincible union i ;
122989: LD_ADDR_EXP 201
122993: PUSH
122994: LD_EXP 201
122998: PUSH
122999: LD_VAR 0 2
123003: UNION
123004: ST_TO_ADDR
// end ;
123005: GO 122945
123007: POP
123008: POP
// end ;
123009: LD_VAR 0 1
123013: RET
// export function hHackInvisible ; var i , j ; begin
123014: LD_INT 0
123016: PPUSH
123017: PPUSH
123018: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
123019: LD_ADDR_VAR 0 2
123023: PUSH
123024: LD_INT 21
123026: PUSH
123027: LD_INT 1
123029: PUSH
123030: EMPTY
123031: LIST
123032: LIST
123033: PPUSH
123034: CALL_OW 69
123038: PUSH
123039: FOR_IN
123040: IFFALSE 123064
// if IsSelected ( i ) then
123042: LD_VAR 0 2
123046: PPUSH
123047: CALL_OW 306
123051: IFFALSE 123062
// ComForceInvisible ( i ) ;
123053: LD_VAR 0 2
123057: PPUSH
123058: CALL_OW 496
123062: GO 123039
123064: POP
123065: POP
// end ;
123066: LD_VAR 0 1
123070: RET
// export function hHackChangeYourSide ; begin
123071: LD_INT 0
123073: PPUSH
// if your_side = 8 then
123074: LD_OWVAR 2
123078: PUSH
123079: LD_INT 8
123081: EQUAL
123082: IFFALSE 123094
// your_side := 0 else
123084: LD_ADDR_OWVAR 2
123088: PUSH
123089: LD_INT 0
123091: ST_TO_ADDR
123092: GO 123108
// your_side := your_side + 1 ;
123094: LD_ADDR_OWVAR 2
123098: PUSH
123099: LD_OWVAR 2
123103: PUSH
123104: LD_INT 1
123106: PLUS
123107: ST_TO_ADDR
// end ;
123108: LD_VAR 0 1
123112: RET
// export function hHackChangeUnitSide ; var i , j ; begin
123113: LD_INT 0
123115: PPUSH
123116: PPUSH
123117: PPUSH
// for i in all_units do
123118: LD_ADDR_VAR 0 2
123122: PUSH
123123: LD_OWVAR 3
123127: PUSH
123128: FOR_IN
123129: IFFALSE 123207
// if IsSelected ( i ) then
123131: LD_VAR 0 2
123135: PPUSH
123136: CALL_OW 306
123140: IFFALSE 123205
// begin j := GetSide ( i ) ;
123142: LD_ADDR_VAR 0 3
123146: PUSH
123147: LD_VAR 0 2
123151: PPUSH
123152: CALL_OW 255
123156: ST_TO_ADDR
// if j = 8 then
123157: LD_VAR 0 3
123161: PUSH
123162: LD_INT 8
123164: EQUAL
123165: IFFALSE 123177
// j := 0 else
123167: LD_ADDR_VAR 0 3
123171: PUSH
123172: LD_INT 0
123174: ST_TO_ADDR
123175: GO 123191
// j := j + 1 ;
123177: LD_ADDR_VAR 0 3
123181: PUSH
123182: LD_VAR 0 3
123186: PUSH
123187: LD_INT 1
123189: PLUS
123190: ST_TO_ADDR
// SetSide ( i , j ) ;
123191: LD_VAR 0 2
123195: PPUSH
123196: LD_VAR 0 3
123200: PPUSH
123201: CALL_OW 235
// end ;
123205: GO 123128
123207: POP
123208: POP
// end ;
123209: LD_VAR 0 1
123213: RET
// export function hHackFog ; begin
123214: LD_INT 0
123216: PPUSH
// FogOff ( true ) ;
123217: LD_INT 1
123219: PPUSH
123220: CALL_OW 344
// end ;
123224: LD_VAR 0 1
123228: RET
// export function hHackTeleport ( unit , x , y ) ; begin
123229: LD_INT 0
123231: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
123232: LD_VAR 0 1
123236: PPUSH
123237: LD_VAR 0 2
123241: PPUSH
123242: LD_VAR 0 3
123246: PPUSH
123247: LD_INT 1
123249: PPUSH
123250: LD_INT 1
123252: PPUSH
123253: CALL_OW 483
// CenterOnXY ( x , y ) ;
123257: LD_VAR 0 2
123261: PPUSH
123262: LD_VAR 0 3
123266: PPUSH
123267: CALL_OW 84
// end ;
123271: LD_VAR 0 4
123275: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
123276: LD_INT 0
123278: PPUSH
123279: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
123280: LD_VAR 0 1
123284: NOT
123285: PUSH
123286: LD_VAR 0 2
123290: PPUSH
123291: LD_VAR 0 3
123295: PPUSH
123296: CALL_OW 488
123300: NOT
123301: OR
123302: PUSH
123303: LD_VAR 0 1
123307: PPUSH
123308: CALL_OW 266
123312: PUSH
123313: LD_INT 3
123315: NONEQUAL
123316: PUSH
123317: LD_VAR 0 1
123321: PPUSH
123322: CALL_OW 247
123326: PUSH
123327: LD_INT 1
123329: EQUAL
123330: NOT
123331: AND
123332: OR
123333: IFFALSE 123337
// exit ;
123335: GO 123486
// if GetType ( factory ) = unit_human then
123337: LD_VAR 0 1
123341: PPUSH
123342: CALL_OW 247
123346: PUSH
123347: LD_INT 1
123349: EQUAL
123350: IFFALSE 123367
// factory := IsInUnit ( factory ) ;
123352: LD_ADDR_VAR 0 1
123356: PUSH
123357: LD_VAR 0 1
123361: PPUSH
123362: CALL_OW 310
123366: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
123367: LD_VAR 0 1
123371: PPUSH
123372: CALL_OW 266
123376: PUSH
123377: LD_INT 3
123379: NONEQUAL
123380: IFFALSE 123384
// exit ;
123382: GO 123486
// if HexInfo ( x , y ) = factory then
123384: LD_VAR 0 2
123388: PPUSH
123389: LD_VAR 0 3
123393: PPUSH
123394: CALL_OW 428
123398: PUSH
123399: LD_VAR 0 1
123403: EQUAL
123404: IFFALSE 123431
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
123406: LD_ADDR_EXP 202
123410: PUSH
123411: LD_EXP 202
123415: PPUSH
123416: LD_VAR 0 1
123420: PPUSH
123421: LD_INT 0
123423: PPUSH
123424: CALL_OW 1
123428: ST_TO_ADDR
123429: GO 123482
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
123431: LD_ADDR_EXP 202
123435: PUSH
123436: LD_EXP 202
123440: PPUSH
123441: LD_VAR 0 1
123445: PPUSH
123446: LD_VAR 0 1
123450: PPUSH
123451: CALL_OW 255
123455: PUSH
123456: LD_VAR 0 1
123460: PUSH
123461: LD_VAR 0 2
123465: PUSH
123466: LD_VAR 0 3
123470: PUSH
123471: EMPTY
123472: LIST
123473: LIST
123474: LIST
123475: LIST
123476: PPUSH
123477: CALL_OW 1
123481: ST_TO_ADDR
// UpdateFactoryWaypoints ;
123482: CALL 123491 0 0
// end ;
123486: LD_VAR 0 4
123490: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123491: LD_INT 0
123493: PPUSH
123494: PPUSH
123495: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123496: LD_STRING resetFactoryWaypoint();
123498: PPUSH
123499: CALL_OW 559
// if factoryWaypoints then
123503: LD_EXP 202
123507: IFFALSE 123633
// begin list := PrepareArray ( factoryWaypoints ) ;
123509: LD_ADDR_VAR 0 3
123513: PUSH
123514: LD_EXP 202
123518: PPUSH
123519: CALL 108743 0 1
123523: ST_TO_ADDR
// for i := 1 to list do
123524: LD_ADDR_VAR 0 2
123528: PUSH
123529: DOUBLE
123530: LD_INT 1
123532: DEC
123533: ST_TO_ADDR
123534: LD_VAR 0 3
123538: PUSH
123539: FOR_TO
123540: IFFALSE 123631
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123542: LD_STRING setFactoryWaypointXY(
123544: PUSH
123545: LD_VAR 0 3
123549: PUSH
123550: LD_VAR 0 2
123554: ARRAY
123555: PUSH
123556: LD_INT 1
123558: ARRAY
123559: STR
123560: PUSH
123561: LD_STRING ,
123563: STR
123564: PUSH
123565: LD_VAR 0 3
123569: PUSH
123570: LD_VAR 0 2
123574: ARRAY
123575: PUSH
123576: LD_INT 2
123578: ARRAY
123579: STR
123580: PUSH
123581: LD_STRING ,
123583: STR
123584: PUSH
123585: LD_VAR 0 3
123589: PUSH
123590: LD_VAR 0 2
123594: ARRAY
123595: PUSH
123596: LD_INT 3
123598: ARRAY
123599: STR
123600: PUSH
123601: LD_STRING ,
123603: STR
123604: PUSH
123605: LD_VAR 0 3
123609: PUSH
123610: LD_VAR 0 2
123614: ARRAY
123615: PUSH
123616: LD_INT 4
123618: ARRAY
123619: STR
123620: PUSH
123621: LD_STRING )
123623: STR
123624: PPUSH
123625: CALL_OW 559
123629: GO 123539
123631: POP
123632: POP
// end ; end ;
123633: LD_VAR 0 1
123637: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123638: LD_INT 0
123640: PPUSH
// if HexInfo ( x , y ) = warehouse then
123641: LD_VAR 0 2
123645: PPUSH
123646: LD_VAR 0 3
123650: PPUSH
123651: CALL_OW 428
123655: PUSH
123656: LD_VAR 0 1
123660: EQUAL
123661: IFFALSE 123688
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123663: LD_ADDR_EXP 203
123667: PUSH
123668: LD_EXP 203
123672: PPUSH
123673: LD_VAR 0 1
123677: PPUSH
123678: LD_INT 0
123680: PPUSH
123681: CALL_OW 1
123685: ST_TO_ADDR
123686: GO 123739
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123688: LD_ADDR_EXP 203
123692: PUSH
123693: LD_EXP 203
123697: PPUSH
123698: LD_VAR 0 1
123702: PPUSH
123703: LD_VAR 0 1
123707: PPUSH
123708: CALL_OW 255
123712: PUSH
123713: LD_VAR 0 1
123717: PUSH
123718: LD_VAR 0 2
123722: PUSH
123723: LD_VAR 0 3
123727: PUSH
123728: EMPTY
123729: LIST
123730: LIST
123731: LIST
123732: LIST
123733: PPUSH
123734: CALL_OW 1
123738: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123739: CALL 123748 0 0
// end ;
123743: LD_VAR 0 4
123747: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123748: LD_INT 0
123750: PPUSH
123751: PPUSH
123752: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123753: LD_STRING resetWarehouseGatheringPoints();
123755: PPUSH
123756: CALL_OW 559
// if warehouseGatheringPoints then
123760: LD_EXP 203
123764: IFFALSE 123890
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123766: LD_ADDR_VAR 0 3
123770: PUSH
123771: LD_EXP 203
123775: PPUSH
123776: CALL 108743 0 1
123780: ST_TO_ADDR
// for i := 1 to list do
123781: LD_ADDR_VAR 0 2
123785: PUSH
123786: DOUBLE
123787: LD_INT 1
123789: DEC
123790: ST_TO_ADDR
123791: LD_VAR 0 3
123795: PUSH
123796: FOR_TO
123797: IFFALSE 123888
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123799: LD_STRING setWarehouseGatheringPointXY(
123801: PUSH
123802: LD_VAR 0 3
123806: PUSH
123807: LD_VAR 0 2
123811: ARRAY
123812: PUSH
123813: LD_INT 1
123815: ARRAY
123816: STR
123817: PUSH
123818: LD_STRING ,
123820: STR
123821: PUSH
123822: LD_VAR 0 3
123826: PUSH
123827: LD_VAR 0 2
123831: ARRAY
123832: PUSH
123833: LD_INT 2
123835: ARRAY
123836: STR
123837: PUSH
123838: LD_STRING ,
123840: STR
123841: PUSH
123842: LD_VAR 0 3
123846: PUSH
123847: LD_VAR 0 2
123851: ARRAY
123852: PUSH
123853: LD_INT 3
123855: ARRAY
123856: STR
123857: PUSH
123858: LD_STRING ,
123860: STR
123861: PUSH
123862: LD_VAR 0 3
123866: PUSH
123867: LD_VAR 0 2
123871: ARRAY
123872: PUSH
123873: LD_INT 4
123875: ARRAY
123876: STR
123877: PUSH
123878: LD_STRING )
123880: STR
123881: PPUSH
123882: CALL_OW 559
123886: GO 123796
123888: POP
123889: POP
// end ; end ;
123890: LD_VAR 0 1
123894: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
123895: LD_EXP 203
123899: IFFALSE 124584
123901: GO 123903
123903: DISABLE
123904: LD_INT 0
123906: PPUSH
123907: PPUSH
123908: PPUSH
123909: PPUSH
123910: PPUSH
123911: PPUSH
123912: PPUSH
123913: PPUSH
123914: PPUSH
// begin enable ;
123915: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
123916: LD_ADDR_VAR 0 3
123920: PUSH
123921: LD_EXP 203
123925: PPUSH
123926: CALL 108743 0 1
123930: ST_TO_ADDR
// if not list then
123931: LD_VAR 0 3
123935: NOT
123936: IFFALSE 123940
// exit ;
123938: GO 124584
// for i := 1 to list do
123940: LD_ADDR_VAR 0 1
123944: PUSH
123945: DOUBLE
123946: LD_INT 1
123948: DEC
123949: ST_TO_ADDR
123950: LD_VAR 0 3
123954: PUSH
123955: FOR_TO
123956: IFFALSE 124582
// begin depot := list [ i ] [ 2 ] ;
123958: LD_ADDR_VAR 0 8
123962: PUSH
123963: LD_VAR 0 3
123967: PUSH
123968: LD_VAR 0 1
123972: ARRAY
123973: PUSH
123974: LD_INT 2
123976: ARRAY
123977: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
123978: LD_ADDR_VAR 0 5
123982: PUSH
123983: LD_VAR 0 3
123987: PUSH
123988: LD_VAR 0 1
123992: ARRAY
123993: PUSH
123994: LD_INT 1
123996: ARRAY
123997: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
123998: LD_VAR 0 8
124002: PPUSH
124003: CALL_OW 301
124007: PUSH
124008: LD_VAR 0 5
124012: PUSH
124013: LD_VAR 0 8
124017: PPUSH
124018: CALL_OW 255
124022: NONEQUAL
124023: OR
124024: IFFALSE 124053
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
124026: LD_ADDR_EXP 203
124030: PUSH
124031: LD_EXP 203
124035: PPUSH
124036: LD_VAR 0 8
124040: PPUSH
124041: LD_INT 0
124043: PPUSH
124044: CALL_OW 1
124048: ST_TO_ADDR
// exit ;
124049: POP
124050: POP
124051: GO 124584
// end ; x := list [ i ] [ 3 ] ;
124053: LD_ADDR_VAR 0 6
124057: PUSH
124058: LD_VAR 0 3
124062: PUSH
124063: LD_VAR 0 1
124067: ARRAY
124068: PUSH
124069: LD_INT 3
124071: ARRAY
124072: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
124073: LD_ADDR_VAR 0 7
124077: PUSH
124078: LD_VAR 0 3
124082: PUSH
124083: LD_VAR 0 1
124087: ARRAY
124088: PUSH
124089: LD_INT 4
124091: ARRAY
124092: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
124093: LD_ADDR_VAR 0 9
124097: PUSH
124098: LD_VAR 0 6
124102: PPUSH
124103: LD_VAR 0 7
124107: PPUSH
124108: LD_INT 16
124110: PPUSH
124111: CALL 107331 0 3
124115: ST_TO_ADDR
// if not cratesNearbyPoint then
124116: LD_VAR 0 9
124120: NOT
124121: IFFALSE 124127
// exit ;
124123: POP
124124: POP
124125: GO 124584
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
124127: LD_ADDR_VAR 0 4
124131: PUSH
124132: LD_INT 22
124134: PUSH
124135: LD_VAR 0 5
124139: PUSH
124140: EMPTY
124141: LIST
124142: LIST
124143: PUSH
124144: LD_INT 3
124146: PUSH
124147: LD_INT 60
124149: PUSH
124150: EMPTY
124151: LIST
124152: PUSH
124153: EMPTY
124154: LIST
124155: LIST
124156: PUSH
124157: LD_INT 91
124159: PUSH
124160: LD_VAR 0 8
124164: PUSH
124165: LD_INT 6
124167: PUSH
124168: EMPTY
124169: LIST
124170: LIST
124171: LIST
124172: PUSH
124173: LD_INT 2
124175: PUSH
124176: LD_INT 25
124178: PUSH
124179: LD_INT 2
124181: PUSH
124182: EMPTY
124183: LIST
124184: LIST
124185: PUSH
124186: LD_INT 25
124188: PUSH
124189: LD_INT 16
124191: PUSH
124192: EMPTY
124193: LIST
124194: LIST
124195: PUSH
124196: EMPTY
124197: LIST
124198: LIST
124199: LIST
124200: PUSH
124201: EMPTY
124202: LIST
124203: LIST
124204: LIST
124205: LIST
124206: PPUSH
124207: CALL_OW 69
124211: PUSH
124212: LD_VAR 0 8
124216: PPUSH
124217: CALL_OW 313
124221: PPUSH
124222: LD_INT 3
124224: PUSH
124225: LD_INT 60
124227: PUSH
124228: EMPTY
124229: LIST
124230: PUSH
124231: EMPTY
124232: LIST
124233: LIST
124234: PUSH
124235: LD_INT 2
124237: PUSH
124238: LD_INT 25
124240: PUSH
124241: LD_INT 2
124243: PUSH
124244: EMPTY
124245: LIST
124246: LIST
124247: PUSH
124248: LD_INT 25
124250: PUSH
124251: LD_INT 16
124253: PUSH
124254: EMPTY
124255: LIST
124256: LIST
124257: PUSH
124258: EMPTY
124259: LIST
124260: LIST
124261: LIST
124262: PUSH
124263: EMPTY
124264: LIST
124265: LIST
124266: PPUSH
124267: CALL_OW 72
124271: UNION
124272: ST_TO_ADDR
// if tmp then
124273: LD_VAR 0 4
124277: IFFALSE 124357
// begin tmp := ShrinkArray ( tmp , 3 ) ;
124279: LD_ADDR_VAR 0 4
124283: PUSH
124284: LD_VAR 0 4
124288: PPUSH
124289: LD_INT 3
124291: PPUSH
124292: CALL 105300 0 2
124296: ST_TO_ADDR
// for j in tmp do
124297: LD_ADDR_VAR 0 2
124301: PUSH
124302: LD_VAR 0 4
124306: PUSH
124307: FOR_IN
124308: IFFALSE 124351
// begin if IsInUnit ( j ) then
124310: LD_VAR 0 2
124314: PPUSH
124315: CALL_OW 310
124319: IFFALSE 124330
// ComExit ( j ) ;
124321: LD_VAR 0 2
124325: PPUSH
124326: CALL 105383 0 1
// AddComCollect ( j , x , y ) ;
124330: LD_VAR 0 2
124334: PPUSH
124335: LD_VAR 0 6
124339: PPUSH
124340: LD_VAR 0 7
124344: PPUSH
124345: CALL_OW 177
// end ;
124349: GO 124307
124351: POP
124352: POP
// exit ;
124353: POP
124354: POP
124355: GO 124584
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
124357: LD_ADDR_VAR 0 4
124361: PUSH
124362: LD_INT 22
124364: PUSH
124365: LD_VAR 0 5
124369: PUSH
124370: EMPTY
124371: LIST
124372: LIST
124373: PUSH
124374: LD_INT 91
124376: PUSH
124377: LD_VAR 0 8
124381: PUSH
124382: LD_INT 8
124384: PUSH
124385: EMPTY
124386: LIST
124387: LIST
124388: LIST
124389: PUSH
124390: LD_INT 2
124392: PUSH
124393: LD_INT 34
124395: PUSH
124396: LD_INT 12
124398: PUSH
124399: EMPTY
124400: LIST
124401: LIST
124402: PUSH
124403: LD_INT 34
124405: PUSH
124406: LD_INT 51
124408: PUSH
124409: EMPTY
124410: LIST
124411: LIST
124412: PUSH
124413: LD_INT 34
124415: PUSH
124416: LD_INT 32
124418: PUSH
124419: EMPTY
124420: LIST
124421: LIST
124422: PUSH
124423: LD_INT 34
124425: PUSH
124426: LD_INT 89
124428: PUSH
124429: EMPTY
124430: LIST
124431: LIST
124432: PUSH
124433: EMPTY
124434: LIST
124435: LIST
124436: LIST
124437: LIST
124438: LIST
124439: PUSH
124440: EMPTY
124441: LIST
124442: LIST
124443: LIST
124444: PPUSH
124445: CALL_OW 69
124449: ST_TO_ADDR
// if tmp then
124450: LD_VAR 0 4
124454: IFFALSE 124580
// begin for j in tmp do
124456: LD_ADDR_VAR 0 2
124460: PUSH
124461: LD_VAR 0 4
124465: PUSH
124466: FOR_IN
124467: IFFALSE 124578
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
124469: LD_VAR 0 2
124473: PPUSH
124474: CALL_OW 262
124478: PUSH
124479: LD_INT 3
124481: EQUAL
124482: PUSH
124483: LD_VAR 0 2
124487: PPUSH
124488: CALL_OW 261
124492: PUSH
124493: LD_INT 20
124495: GREATER
124496: OR
124497: PUSH
124498: LD_VAR 0 2
124502: PPUSH
124503: CALL_OW 314
124507: NOT
124508: AND
124509: PUSH
124510: LD_VAR 0 2
124514: PPUSH
124515: CALL_OW 263
124519: PUSH
124520: LD_INT 1
124522: NONEQUAL
124523: PUSH
124524: LD_VAR 0 2
124528: PPUSH
124529: CALL_OW 311
124533: OR
124534: AND
124535: IFFALSE 124576
// begin ComCollect ( j , x , y ) ;
124537: LD_VAR 0 2
124541: PPUSH
124542: LD_VAR 0 6
124546: PPUSH
124547: LD_VAR 0 7
124551: PPUSH
124552: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124556: LD_VAR 0 2
124560: PPUSH
124561: LD_VAR 0 8
124565: PPUSH
124566: CALL_OW 172
// exit ;
124570: POP
124571: POP
124572: POP
124573: POP
124574: GO 124584
// end ;
124576: GO 124466
124578: POP
124579: POP
// end ; end ;
124580: GO 123955
124582: POP
124583: POP
// end ; end_of_file
124584: PPOPN 9
124586: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124587: LD_INT 0
124589: PPUSH
124590: PPUSH
124591: PPUSH
124592: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124593: LD_VAR 0 1
124597: PPUSH
124598: CALL_OW 264
124602: PUSH
124603: LD_INT 91
124605: EQUAL
124606: IFFALSE 124678
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124608: LD_INT 68
124610: PPUSH
124611: LD_VAR 0 1
124615: PPUSH
124616: CALL_OW 255
124620: PPUSH
124621: CALL_OW 321
124625: PUSH
124626: LD_INT 2
124628: EQUAL
124629: IFFALSE 124641
// eff := 70 else
124631: LD_ADDR_VAR 0 4
124635: PUSH
124636: LD_INT 70
124638: ST_TO_ADDR
124639: GO 124649
// eff := 30 ;
124641: LD_ADDR_VAR 0 4
124645: PUSH
124646: LD_INT 30
124648: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124649: LD_VAR 0 1
124653: PPUSH
124654: CALL_OW 250
124658: PPUSH
124659: LD_VAR 0 1
124663: PPUSH
124664: CALL_OW 251
124668: PPUSH
124669: LD_VAR 0 4
124673: PPUSH
124674: CALL_OW 495
// end ; end ;
124678: LD_VAR 0 2
124682: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124683: LD_INT 0
124685: PPUSH
// end ;
124686: LD_VAR 0 4
124690: RET
// export function SOS_Command ( cmd ) ; begin
124691: LD_INT 0
124693: PPUSH
// end ;
124694: LD_VAR 0 2
124698: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124699: LD_INT 0
124701: PPUSH
// end ;
124702: LD_VAR 0 6
124706: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124707: LD_INT 0
124709: PPUSH
124710: PPUSH
// if not vehicle or not factory then
124711: LD_VAR 0 1
124715: NOT
124716: PUSH
124717: LD_VAR 0 2
124721: NOT
124722: OR
124723: IFFALSE 124727
// exit ;
124725: GO 124958
// if factoryWaypoints >= factory then
124727: LD_EXP 202
124731: PUSH
124732: LD_VAR 0 2
124736: GREATEREQUAL
124737: IFFALSE 124958
// if factoryWaypoints [ factory ] then
124739: LD_EXP 202
124743: PUSH
124744: LD_VAR 0 2
124748: ARRAY
124749: IFFALSE 124958
// begin if GetControl ( vehicle ) = control_manual then
124751: LD_VAR 0 1
124755: PPUSH
124756: CALL_OW 263
124760: PUSH
124761: LD_INT 1
124763: EQUAL
124764: IFFALSE 124845
// begin driver := IsDrivenBy ( vehicle ) ;
124766: LD_ADDR_VAR 0 4
124770: PUSH
124771: LD_VAR 0 1
124775: PPUSH
124776: CALL_OW 311
124780: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124781: LD_VAR 0 4
124785: PPUSH
124786: LD_EXP 202
124790: PUSH
124791: LD_VAR 0 2
124795: ARRAY
124796: PUSH
124797: LD_INT 3
124799: ARRAY
124800: PPUSH
124801: LD_EXP 202
124805: PUSH
124806: LD_VAR 0 2
124810: ARRAY
124811: PUSH
124812: LD_INT 4
124814: ARRAY
124815: PPUSH
124816: CALL_OW 171
// AddComExitVehicle ( driver ) ;
124820: LD_VAR 0 4
124824: PPUSH
124825: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
124829: LD_VAR 0 4
124833: PPUSH
124834: LD_VAR 0 2
124838: PPUSH
124839: CALL_OW 180
// end else
124843: GO 124958
// if GetControl ( vehicle ) = control_remote then
124845: LD_VAR 0 1
124849: PPUSH
124850: CALL_OW 263
124854: PUSH
124855: LD_INT 2
124857: EQUAL
124858: IFFALSE 124919
// begin wait ( 0 0$2 ) ;
124860: LD_INT 70
124862: PPUSH
124863: CALL_OW 67
// if Connect ( vehicle ) then
124867: LD_VAR 0 1
124871: PPUSH
124872: CALL 75642 0 1
124876: IFFALSE 124917
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124878: LD_VAR 0 1
124882: PPUSH
124883: LD_EXP 202
124887: PUSH
124888: LD_VAR 0 2
124892: ARRAY
124893: PUSH
124894: LD_INT 3
124896: ARRAY
124897: PPUSH
124898: LD_EXP 202
124902: PUSH
124903: LD_VAR 0 2
124907: ARRAY
124908: PUSH
124909: LD_INT 4
124911: ARRAY
124912: PPUSH
124913: CALL_OW 171
// end else
124917: GO 124958
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124919: LD_VAR 0 1
124923: PPUSH
124924: LD_EXP 202
124928: PUSH
124929: LD_VAR 0 2
124933: ARRAY
124934: PUSH
124935: LD_INT 3
124937: ARRAY
124938: PPUSH
124939: LD_EXP 202
124943: PUSH
124944: LD_VAR 0 2
124948: ARRAY
124949: PUSH
124950: LD_INT 4
124952: ARRAY
124953: PPUSH
124954: CALL_OW 171
// end ; end ;
124958: LD_VAR 0 3
124962: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
124963: LD_INT 0
124965: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
124966: LD_VAR 0 1
124970: PUSH
124971: LD_INT 250
124973: EQUAL
124974: PUSH
124975: LD_VAR 0 2
124979: PPUSH
124980: CALL_OW 264
124984: PUSH
124985: LD_INT 81
124987: EQUAL
124988: AND
124989: IFFALSE 125010
// MinerPlaceMine ( unit , x , y ) ;
124991: LD_VAR 0 2
124995: PPUSH
124996: LD_VAR 0 4
125000: PPUSH
125001: LD_VAR 0 5
125005: PPUSH
125006: CALL 127395 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
125010: LD_VAR 0 1
125014: PUSH
125015: LD_INT 251
125017: EQUAL
125018: PUSH
125019: LD_VAR 0 2
125023: PPUSH
125024: CALL_OW 264
125028: PUSH
125029: LD_INT 81
125031: EQUAL
125032: AND
125033: IFFALSE 125054
// MinerDetonateMine ( unit , x , y ) ;
125035: LD_VAR 0 2
125039: PPUSH
125040: LD_VAR 0 4
125044: PPUSH
125045: LD_VAR 0 5
125049: PPUSH
125050: CALL 127670 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
125054: LD_VAR 0 1
125058: PUSH
125059: LD_INT 252
125061: EQUAL
125062: PUSH
125063: LD_VAR 0 2
125067: PPUSH
125068: CALL_OW 264
125072: PUSH
125073: LD_INT 81
125075: EQUAL
125076: AND
125077: IFFALSE 125098
// MinerCreateMinefield ( unit , x , y ) ;
125079: LD_VAR 0 2
125083: PPUSH
125084: LD_VAR 0 4
125088: PPUSH
125089: LD_VAR 0 5
125093: PPUSH
125094: CALL 128087 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
125098: LD_VAR 0 1
125102: PUSH
125103: LD_INT 253
125105: EQUAL
125106: PUSH
125107: LD_VAR 0 2
125111: PPUSH
125112: CALL_OW 257
125116: PUSH
125117: LD_INT 5
125119: EQUAL
125120: AND
125121: IFFALSE 125142
// ComBinocular ( unit , x , y ) ;
125123: LD_VAR 0 2
125127: PPUSH
125128: LD_VAR 0 4
125132: PPUSH
125133: LD_VAR 0 5
125137: PPUSH
125138: CALL 128456 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
125142: LD_VAR 0 1
125146: PUSH
125147: LD_INT 254
125149: EQUAL
125150: PUSH
125151: LD_VAR 0 2
125155: PPUSH
125156: CALL_OW 264
125160: PUSH
125161: LD_INT 99
125163: EQUAL
125164: AND
125165: PUSH
125166: LD_VAR 0 3
125170: PPUSH
125171: CALL_OW 263
125175: PUSH
125176: LD_INT 3
125178: EQUAL
125179: AND
125180: IFFALSE 125196
// HackDestroyVehicle ( unit , selectedUnit ) ;
125182: LD_VAR 0 2
125186: PPUSH
125187: LD_VAR 0 3
125191: PPUSH
125192: CALL 126759 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
125196: LD_VAR 0 1
125200: PUSH
125201: LD_INT 255
125203: EQUAL
125204: PUSH
125205: LD_VAR 0 2
125209: PPUSH
125210: CALL_OW 264
125214: PUSH
125215: LD_INT 14
125217: PUSH
125218: LD_INT 53
125220: PUSH
125221: EMPTY
125222: LIST
125223: LIST
125224: IN
125225: AND
125226: PUSH
125227: LD_VAR 0 4
125231: PPUSH
125232: LD_VAR 0 5
125236: PPUSH
125237: CALL_OW 488
125241: AND
125242: IFFALSE 125266
// CutTreeXYR ( unit , x , y , 12 ) ;
125244: LD_VAR 0 2
125248: PPUSH
125249: LD_VAR 0 4
125253: PPUSH
125254: LD_VAR 0 5
125258: PPUSH
125259: LD_INT 12
125261: PPUSH
125262: CALL 125329 0 4
// if cmd = 256 then
125266: LD_VAR 0 1
125270: PUSH
125271: LD_INT 256
125273: EQUAL
125274: IFFALSE 125295
// SetFactoryWaypoint ( unit , x , y ) ;
125276: LD_VAR 0 2
125280: PPUSH
125281: LD_VAR 0 4
125285: PPUSH
125286: LD_VAR 0 5
125290: PPUSH
125291: CALL 123276 0 3
// if cmd = 257 then
125295: LD_VAR 0 1
125299: PUSH
125300: LD_INT 257
125302: EQUAL
125303: IFFALSE 125324
// SetWarehouseGatheringPoint ( unit , x , y ) ;
125305: LD_VAR 0 2
125309: PPUSH
125310: LD_VAR 0 4
125314: PPUSH
125315: LD_VAR 0 5
125319: PPUSH
125320: CALL 123638 0 3
// end ;
125324: LD_VAR 0 6
125328: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
125329: LD_INT 0
125331: PPUSH
125332: PPUSH
125333: PPUSH
125334: PPUSH
125335: PPUSH
125336: PPUSH
125337: PPUSH
125338: PPUSH
125339: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
125340: LD_VAR 0 1
125344: NOT
125345: PUSH
125346: LD_VAR 0 2
125350: PPUSH
125351: LD_VAR 0 3
125355: PPUSH
125356: CALL_OW 488
125360: NOT
125361: OR
125362: PUSH
125363: LD_VAR 0 4
125367: NOT
125368: OR
125369: IFFALSE 125373
// exit ;
125371: GO 125713
// list := [ ] ;
125373: LD_ADDR_VAR 0 13
125377: PUSH
125378: EMPTY
125379: ST_TO_ADDR
// if x - r < 0 then
125380: LD_VAR 0 2
125384: PUSH
125385: LD_VAR 0 4
125389: MINUS
125390: PUSH
125391: LD_INT 0
125393: LESS
125394: IFFALSE 125406
// min_x := 0 else
125396: LD_ADDR_VAR 0 7
125400: PUSH
125401: LD_INT 0
125403: ST_TO_ADDR
125404: GO 125422
// min_x := x - r ;
125406: LD_ADDR_VAR 0 7
125410: PUSH
125411: LD_VAR 0 2
125415: PUSH
125416: LD_VAR 0 4
125420: MINUS
125421: ST_TO_ADDR
// if y - r < 0 then
125422: LD_VAR 0 3
125426: PUSH
125427: LD_VAR 0 4
125431: MINUS
125432: PUSH
125433: LD_INT 0
125435: LESS
125436: IFFALSE 125448
// min_y := 0 else
125438: LD_ADDR_VAR 0 8
125442: PUSH
125443: LD_INT 0
125445: ST_TO_ADDR
125446: GO 125464
// min_y := y - r ;
125448: LD_ADDR_VAR 0 8
125452: PUSH
125453: LD_VAR 0 3
125457: PUSH
125458: LD_VAR 0 4
125462: MINUS
125463: ST_TO_ADDR
// max_x := x + r ;
125464: LD_ADDR_VAR 0 9
125468: PUSH
125469: LD_VAR 0 2
125473: PUSH
125474: LD_VAR 0 4
125478: PLUS
125479: ST_TO_ADDR
// max_y := y + r ;
125480: LD_ADDR_VAR 0 10
125484: PUSH
125485: LD_VAR 0 3
125489: PUSH
125490: LD_VAR 0 4
125494: PLUS
125495: ST_TO_ADDR
// for _x = min_x to max_x do
125496: LD_ADDR_VAR 0 11
125500: PUSH
125501: DOUBLE
125502: LD_VAR 0 7
125506: DEC
125507: ST_TO_ADDR
125508: LD_VAR 0 9
125512: PUSH
125513: FOR_TO
125514: IFFALSE 125631
// for _y = min_y to max_y do
125516: LD_ADDR_VAR 0 12
125520: PUSH
125521: DOUBLE
125522: LD_VAR 0 8
125526: DEC
125527: ST_TO_ADDR
125528: LD_VAR 0 10
125532: PUSH
125533: FOR_TO
125534: IFFALSE 125627
// begin if not ValidHex ( _x , _y ) then
125536: LD_VAR 0 11
125540: PPUSH
125541: LD_VAR 0 12
125545: PPUSH
125546: CALL_OW 488
125550: NOT
125551: IFFALSE 125555
// continue ;
125553: GO 125533
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125555: LD_VAR 0 11
125559: PPUSH
125560: LD_VAR 0 12
125564: PPUSH
125565: CALL_OW 351
125569: PUSH
125570: LD_VAR 0 11
125574: PPUSH
125575: LD_VAR 0 12
125579: PPUSH
125580: CALL_OW 554
125584: AND
125585: IFFALSE 125625
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125587: LD_ADDR_VAR 0 13
125591: PUSH
125592: LD_VAR 0 13
125596: PPUSH
125597: LD_VAR 0 13
125601: PUSH
125602: LD_INT 1
125604: PLUS
125605: PPUSH
125606: LD_VAR 0 11
125610: PUSH
125611: LD_VAR 0 12
125615: PUSH
125616: EMPTY
125617: LIST
125618: LIST
125619: PPUSH
125620: CALL_OW 2
125624: ST_TO_ADDR
// end ;
125625: GO 125533
125627: POP
125628: POP
125629: GO 125513
125631: POP
125632: POP
// if not list then
125633: LD_VAR 0 13
125637: NOT
125638: IFFALSE 125642
// exit ;
125640: GO 125713
// for i in list do
125642: LD_ADDR_VAR 0 6
125646: PUSH
125647: LD_VAR 0 13
125651: PUSH
125652: FOR_IN
125653: IFFALSE 125711
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125655: LD_VAR 0 1
125659: PPUSH
125660: LD_STRING M
125662: PUSH
125663: LD_VAR 0 6
125667: PUSH
125668: LD_INT 1
125670: ARRAY
125671: PUSH
125672: LD_VAR 0 6
125676: PUSH
125677: LD_INT 2
125679: ARRAY
125680: PUSH
125681: LD_INT 0
125683: PUSH
125684: LD_INT 0
125686: PUSH
125687: LD_INT 0
125689: PUSH
125690: LD_INT 0
125692: PUSH
125693: EMPTY
125694: LIST
125695: LIST
125696: LIST
125697: LIST
125698: LIST
125699: LIST
125700: LIST
125701: PUSH
125702: EMPTY
125703: LIST
125704: PPUSH
125705: CALL_OW 447
125709: GO 125652
125711: POP
125712: POP
// end ;
125713: LD_VAR 0 5
125717: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125718: LD_EXP 205
125722: NOT
125723: IFFALSE 125773
125725: GO 125727
125727: DISABLE
// begin initHack := true ;
125728: LD_ADDR_EXP 205
125732: PUSH
125733: LD_INT 1
125735: ST_TO_ADDR
// hackTanks := [ ] ;
125736: LD_ADDR_EXP 206
125740: PUSH
125741: EMPTY
125742: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125743: LD_ADDR_EXP 207
125747: PUSH
125748: EMPTY
125749: ST_TO_ADDR
// hackLimit := 3 ;
125750: LD_ADDR_EXP 208
125754: PUSH
125755: LD_INT 3
125757: ST_TO_ADDR
// hackDist := 12 ;
125758: LD_ADDR_EXP 209
125762: PUSH
125763: LD_INT 12
125765: ST_TO_ADDR
// hackCounter := [ ] ;
125766: LD_ADDR_EXP 210
125770: PUSH
125771: EMPTY
125772: ST_TO_ADDR
// end ;
125773: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125774: LD_EXP 205
125778: PUSH
125779: LD_INT 34
125781: PUSH
125782: LD_INT 99
125784: PUSH
125785: EMPTY
125786: LIST
125787: LIST
125788: PPUSH
125789: CALL_OW 69
125793: AND
125794: IFFALSE 126047
125796: GO 125798
125798: DISABLE
125799: LD_INT 0
125801: PPUSH
125802: PPUSH
// begin enable ;
125803: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
125804: LD_ADDR_VAR 0 1
125808: PUSH
125809: LD_INT 34
125811: PUSH
125812: LD_INT 99
125814: PUSH
125815: EMPTY
125816: LIST
125817: LIST
125818: PPUSH
125819: CALL_OW 69
125823: PUSH
125824: FOR_IN
125825: IFFALSE 126045
// begin if not i in hackTanks then
125827: LD_VAR 0 1
125831: PUSH
125832: LD_EXP 206
125836: IN
125837: NOT
125838: IFFALSE 125921
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
125840: LD_ADDR_EXP 206
125844: PUSH
125845: LD_EXP 206
125849: PPUSH
125850: LD_EXP 206
125854: PUSH
125855: LD_INT 1
125857: PLUS
125858: PPUSH
125859: LD_VAR 0 1
125863: PPUSH
125864: CALL_OW 1
125868: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
125869: LD_ADDR_EXP 207
125873: PUSH
125874: LD_EXP 207
125878: PPUSH
125879: LD_EXP 207
125883: PUSH
125884: LD_INT 1
125886: PLUS
125887: PPUSH
125888: EMPTY
125889: PPUSH
125890: CALL_OW 1
125894: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
125895: LD_ADDR_EXP 210
125899: PUSH
125900: LD_EXP 210
125904: PPUSH
125905: LD_EXP 210
125909: PUSH
125910: LD_INT 1
125912: PLUS
125913: PPUSH
125914: EMPTY
125915: PPUSH
125916: CALL_OW 1
125920: ST_TO_ADDR
// end ; if not IsOk ( i ) then
125921: LD_VAR 0 1
125925: PPUSH
125926: CALL_OW 302
125930: NOT
125931: IFFALSE 125944
// begin HackUnlinkAll ( i ) ;
125933: LD_VAR 0 1
125937: PPUSH
125938: CALL 126050 0 1
// continue ;
125942: GO 125824
// end ; HackCheckCapturedStatus ( i ) ;
125944: LD_VAR 0 1
125948: PPUSH
125949: CALL 126493 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
125953: LD_ADDR_VAR 0 2
125957: PUSH
125958: LD_INT 81
125960: PUSH
125961: LD_VAR 0 1
125965: PPUSH
125966: CALL_OW 255
125970: PUSH
125971: EMPTY
125972: LIST
125973: LIST
125974: PUSH
125975: LD_INT 33
125977: PUSH
125978: LD_INT 3
125980: PUSH
125981: EMPTY
125982: LIST
125983: LIST
125984: PUSH
125985: LD_INT 91
125987: PUSH
125988: LD_VAR 0 1
125992: PUSH
125993: LD_EXP 209
125997: PUSH
125998: EMPTY
125999: LIST
126000: LIST
126001: LIST
126002: PUSH
126003: LD_INT 50
126005: PUSH
126006: EMPTY
126007: LIST
126008: PUSH
126009: EMPTY
126010: LIST
126011: LIST
126012: LIST
126013: LIST
126014: PPUSH
126015: CALL_OW 69
126019: ST_TO_ADDR
// if not tmp then
126020: LD_VAR 0 2
126024: NOT
126025: IFFALSE 126029
// continue ;
126027: GO 125824
// HackLink ( i , tmp ) ;
126029: LD_VAR 0 1
126033: PPUSH
126034: LD_VAR 0 2
126038: PPUSH
126039: CALL 126186 0 2
// end ;
126043: GO 125824
126045: POP
126046: POP
// end ;
126047: PPOPN 2
126049: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
126050: LD_INT 0
126052: PPUSH
126053: PPUSH
126054: PPUSH
// if not hack in hackTanks then
126055: LD_VAR 0 1
126059: PUSH
126060: LD_EXP 206
126064: IN
126065: NOT
126066: IFFALSE 126070
// exit ;
126068: GO 126181
// index := GetElementIndex ( hackTanks , hack ) ;
126070: LD_ADDR_VAR 0 4
126074: PUSH
126075: LD_EXP 206
126079: PPUSH
126080: LD_VAR 0 1
126084: PPUSH
126085: CALL 72458 0 2
126089: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
126090: LD_EXP 207
126094: PUSH
126095: LD_VAR 0 4
126099: ARRAY
126100: IFFALSE 126181
// begin for i in hackTanksCaptured [ index ] do
126102: LD_ADDR_VAR 0 3
126106: PUSH
126107: LD_EXP 207
126111: PUSH
126112: LD_VAR 0 4
126116: ARRAY
126117: PUSH
126118: FOR_IN
126119: IFFALSE 126145
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
126121: LD_VAR 0 3
126125: PUSH
126126: LD_INT 1
126128: ARRAY
126129: PPUSH
126130: LD_VAR 0 3
126134: PUSH
126135: LD_INT 2
126137: ARRAY
126138: PPUSH
126139: CALL_OW 235
126143: GO 126118
126145: POP
126146: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
126147: LD_ADDR_EXP 207
126151: PUSH
126152: LD_EXP 207
126156: PPUSH
126157: LD_VAR 0 4
126161: PPUSH
126162: EMPTY
126163: PPUSH
126164: CALL_OW 1
126168: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
126169: LD_VAR 0 1
126173: PPUSH
126174: LD_INT 0
126176: PPUSH
126177: CALL_OW 505
// end ; end ;
126181: LD_VAR 0 2
126185: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
126186: LD_INT 0
126188: PPUSH
126189: PPUSH
126190: PPUSH
// if not hack in hackTanks or not vehicles then
126191: LD_VAR 0 1
126195: PUSH
126196: LD_EXP 206
126200: IN
126201: NOT
126202: PUSH
126203: LD_VAR 0 2
126207: NOT
126208: OR
126209: IFFALSE 126213
// exit ;
126211: GO 126488
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
126213: LD_ADDR_VAR 0 2
126217: PUSH
126218: LD_VAR 0 1
126222: PPUSH
126223: LD_VAR 0 2
126227: PPUSH
126228: LD_INT 1
126230: PPUSH
126231: LD_INT 1
126233: PPUSH
126234: CALL 73108 0 4
126238: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
126239: LD_ADDR_VAR 0 5
126243: PUSH
126244: LD_EXP 206
126248: PPUSH
126249: LD_VAR 0 1
126253: PPUSH
126254: CALL 72458 0 2
126258: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
126259: LD_EXP 207
126263: PUSH
126264: LD_VAR 0 5
126268: ARRAY
126269: PUSH
126270: LD_EXP 208
126274: LESS
126275: IFFALSE 126464
// begin for i := 1 to vehicles do
126277: LD_ADDR_VAR 0 4
126281: PUSH
126282: DOUBLE
126283: LD_INT 1
126285: DEC
126286: ST_TO_ADDR
126287: LD_VAR 0 2
126291: PUSH
126292: FOR_TO
126293: IFFALSE 126462
// begin if hackTanksCaptured [ index ] = hackLimit then
126295: LD_EXP 207
126299: PUSH
126300: LD_VAR 0 5
126304: ARRAY
126305: PUSH
126306: LD_EXP 208
126310: EQUAL
126311: IFFALSE 126315
// break ;
126313: GO 126462
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
126315: LD_ADDR_EXP 210
126319: PUSH
126320: LD_EXP 210
126324: PPUSH
126325: LD_VAR 0 5
126329: PPUSH
126330: LD_EXP 210
126334: PUSH
126335: LD_VAR 0 5
126339: ARRAY
126340: PUSH
126341: LD_INT 1
126343: PLUS
126344: PPUSH
126345: CALL_OW 1
126349: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
126350: LD_ADDR_EXP 207
126354: PUSH
126355: LD_EXP 207
126359: PPUSH
126360: LD_VAR 0 5
126364: PUSH
126365: LD_EXP 207
126369: PUSH
126370: LD_VAR 0 5
126374: ARRAY
126375: PUSH
126376: LD_INT 1
126378: PLUS
126379: PUSH
126380: EMPTY
126381: LIST
126382: LIST
126383: PPUSH
126384: LD_VAR 0 2
126388: PUSH
126389: LD_VAR 0 4
126393: ARRAY
126394: PUSH
126395: LD_VAR 0 2
126399: PUSH
126400: LD_VAR 0 4
126404: ARRAY
126405: PPUSH
126406: CALL_OW 255
126410: PUSH
126411: EMPTY
126412: LIST
126413: LIST
126414: PPUSH
126415: CALL 72673 0 3
126419: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
126420: LD_VAR 0 2
126424: PUSH
126425: LD_VAR 0 4
126429: ARRAY
126430: PPUSH
126431: LD_VAR 0 1
126435: PPUSH
126436: CALL_OW 255
126440: PPUSH
126441: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
126445: LD_VAR 0 2
126449: PUSH
126450: LD_VAR 0 4
126454: ARRAY
126455: PPUSH
126456: CALL_OW 141
// end ;
126460: GO 126292
126462: POP
126463: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126464: LD_VAR 0 1
126468: PPUSH
126469: LD_EXP 207
126473: PUSH
126474: LD_VAR 0 5
126478: ARRAY
126479: PUSH
126480: LD_INT 0
126482: PLUS
126483: PPUSH
126484: CALL_OW 505
// end ;
126488: LD_VAR 0 3
126492: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126493: LD_INT 0
126495: PPUSH
126496: PPUSH
126497: PPUSH
126498: PPUSH
// if not hack in hackTanks then
126499: LD_VAR 0 1
126503: PUSH
126504: LD_EXP 206
126508: IN
126509: NOT
126510: IFFALSE 126514
// exit ;
126512: GO 126754
// index := GetElementIndex ( hackTanks , hack ) ;
126514: LD_ADDR_VAR 0 4
126518: PUSH
126519: LD_EXP 206
126523: PPUSH
126524: LD_VAR 0 1
126528: PPUSH
126529: CALL 72458 0 2
126533: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126534: LD_ADDR_VAR 0 3
126538: PUSH
126539: DOUBLE
126540: LD_EXP 207
126544: PUSH
126545: LD_VAR 0 4
126549: ARRAY
126550: INC
126551: ST_TO_ADDR
126552: LD_INT 1
126554: PUSH
126555: FOR_DOWNTO
126556: IFFALSE 126728
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126558: LD_ADDR_VAR 0 5
126562: PUSH
126563: LD_EXP 207
126567: PUSH
126568: LD_VAR 0 4
126572: ARRAY
126573: PUSH
126574: LD_VAR 0 3
126578: ARRAY
126579: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126580: LD_VAR 0 5
126584: PUSH
126585: LD_INT 1
126587: ARRAY
126588: PPUSH
126589: CALL_OW 302
126593: NOT
126594: PUSH
126595: LD_VAR 0 5
126599: PUSH
126600: LD_INT 1
126602: ARRAY
126603: PPUSH
126604: CALL_OW 255
126608: PUSH
126609: LD_VAR 0 1
126613: PPUSH
126614: CALL_OW 255
126618: NONEQUAL
126619: OR
126620: IFFALSE 126726
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126622: LD_VAR 0 5
126626: PUSH
126627: LD_INT 1
126629: ARRAY
126630: PPUSH
126631: CALL_OW 305
126635: PUSH
126636: LD_VAR 0 5
126640: PUSH
126641: LD_INT 1
126643: ARRAY
126644: PPUSH
126645: CALL_OW 255
126649: PUSH
126650: LD_VAR 0 1
126654: PPUSH
126655: CALL_OW 255
126659: EQUAL
126660: AND
126661: IFFALSE 126685
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126663: LD_VAR 0 5
126667: PUSH
126668: LD_INT 1
126670: ARRAY
126671: PPUSH
126672: LD_VAR 0 5
126676: PUSH
126677: LD_INT 2
126679: ARRAY
126680: PPUSH
126681: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126685: LD_ADDR_EXP 207
126689: PUSH
126690: LD_EXP 207
126694: PPUSH
126695: LD_VAR 0 4
126699: PPUSH
126700: LD_EXP 207
126704: PUSH
126705: LD_VAR 0 4
126709: ARRAY
126710: PPUSH
126711: LD_VAR 0 3
126715: PPUSH
126716: CALL_OW 3
126720: PPUSH
126721: CALL_OW 1
126725: ST_TO_ADDR
// end ; end ;
126726: GO 126555
126728: POP
126729: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126730: LD_VAR 0 1
126734: PPUSH
126735: LD_EXP 207
126739: PUSH
126740: LD_VAR 0 4
126744: ARRAY
126745: PUSH
126746: LD_INT 0
126748: PLUS
126749: PPUSH
126750: CALL_OW 505
// end ;
126754: LD_VAR 0 2
126758: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126759: LD_INT 0
126761: PPUSH
126762: PPUSH
126763: PPUSH
126764: PPUSH
// if not hack in hackTanks then
126765: LD_VAR 0 1
126769: PUSH
126770: LD_EXP 206
126774: IN
126775: NOT
126776: IFFALSE 126780
// exit ;
126778: GO 126865
// index := GetElementIndex ( hackTanks , hack ) ;
126780: LD_ADDR_VAR 0 5
126784: PUSH
126785: LD_EXP 206
126789: PPUSH
126790: LD_VAR 0 1
126794: PPUSH
126795: CALL 72458 0 2
126799: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
126800: LD_ADDR_VAR 0 4
126804: PUSH
126805: DOUBLE
126806: LD_INT 1
126808: DEC
126809: ST_TO_ADDR
126810: LD_EXP 207
126814: PUSH
126815: LD_VAR 0 5
126819: ARRAY
126820: PUSH
126821: FOR_TO
126822: IFFALSE 126863
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
126824: LD_EXP 207
126828: PUSH
126829: LD_VAR 0 5
126833: ARRAY
126834: PUSH
126835: LD_VAR 0 4
126839: ARRAY
126840: PUSH
126841: LD_INT 1
126843: ARRAY
126844: PUSH
126845: LD_VAR 0 2
126849: EQUAL
126850: IFFALSE 126861
// KillUnit ( vehicle ) ;
126852: LD_VAR 0 2
126856: PPUSH
126857: CALL_OW 66
126861: GO 126821
126863: POP
126864: POP
// end ;
126865: LD_VAR 0 3
126869: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
126870: LD_EXP 211
126874: NOT
126875: IFFALSE 126910
126877: GO 126879
126879: DISABLE
// begin initMiner := true ;
126880: LD_ADDR_EXP 211
126884: PUSH
126885: LD_INT 1
126887: ST_TO_ADDR
// minersList := [ ] ;
126888: LD_ADDR_EXP 212
126892: PUSH
126893: EMPTY
126894: ST_TO_ADDR
// minerMinesList := [ ] ;
126895: LD_ADDR_EXP 213
126899: PUSH
126900: EMPTY
126901: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
126902: LD_ADDR_EXP 214
126906: PUSH
126907: LD_INT 5
126909: ST_TO_ADDR
// end ;
126910: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
126911: LD_EXP 211
126915: PUSH
126916: LD_INT 34
126918: PUSH
126919: LD_INT 81
126921: PUSH
126922: EMPTY
126923: LIST
126924: LIST
126925: PPUSH
126926: CALL_OW 69
126930: AND
126931: IFFALSE 127392
126933: GO 126935
126935: DISABLE
126936: LD_INT 0
126938: PPUSH
126939: PPUSH
126940: PPUSH
126941: PPUSH
// begin enable ;
126942: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
126943: LD_ADDR_VAR 0 1
126947: PUSH
126948: LD_INT 34
126950: PUSH
126951: LD_INT 81
126953: PUSH
126954: EMPTY
126955: LIST
126956: LIST
126957: PPUSH
126958: CALL_OW 69
126962: PUSH
126963: FOR_IN
126964: IFFALSE 127036
// begin if not i in minersList then
126966: LD_VAR 0 1
126970: PUSH
126971: LD_EXP 212
126975: IN
126976: NOT
126977: IFFALSE 127034
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
126979: LD_ADDR_EXP 212
126983: PUSH
126984: LD_EXP 212
126988: PPUSH
126989: LD_EXP 212
126993: PUSH
126994: LD_INT 1
126996: PLUS
126997: PPUSH
126998: LD_VAR 0 1
127002: PPUSH
127003: CALL_OW 1
127007: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
127008: LD_ADDR_EXP 213
127012: PUSH
127013: LD_EXP 213
127017: PPUSH
127018: LD_EXP 213
127022: PUSH
127023: LD_INT 1
127025: PLUS
127026: PPUSH
127027: EMPTY
127028: PPUSH
127029: CALL_OW 1
127033: ST_TO_ADDR
// end end ;
127034: GO 126963
127036: POP
127037: POP
// for i := minerMinesList downto 1 do
127038: LD_ADDR_VAR 0 1
127042: PUSH
127043: DOUBLE
127044: LD_EXP 213
127048: INC
127049: ST_TO_ADDR
127050: LD_INT 1
127052: PUSH
127053: FOR_DOWNTO
127054: IFFALSE 127390
// begin if IsLive ( minersList [ i ] ) then
127056: LD_EXP 212
127060: PUSH
127061: LD_VAR 0 1
127065: ARRAY
127066: PPUSH
127067: CALL_OW 300
127071: IFFALSE 127099
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
127073: LD_EXP 212
127077: PUSH
127078: LD_VAR 0 1
127082: ARRAY
127083: PPUSH
127084: LD_EXP 213
127088: PUSH
127089: LD_VAR 0 1
127093: ARRAY
127094: PPUSH
127095: CALL_OW 505
// if not minerMinesList [ i ] then
127099: LD_EXP 213
127103: PUSH
127104: LD_VAR 0 1
127108: ARRAY
127109: NOT
127110: IFFALSE 127114
// continue ;
127112: GO 127053
// for j := minerMinesList [ i ] downto 1 do
127114: LD_ADDR_VAR 0 2
127118: PUSH
127119: DOUBLE
127120: LD_EXP 213
127124: PUSH
127125: LD_VAR 0 1
127129: ARRAY
127130: INC
127131: ST_TO_ADDR
127132: LD_INT 1
127134: PUSH
127135: FOR_DOWNTO
127136: IFFALSE 127386
// begin side := GetSide ( minersList [ i ] ) ;
127138: LD_ADDR_VAR 0 3
127142: PUSH
127143: LD_EXP 212
127147: PUSH
127148: LD_VAR 0 1
127152: ARRAY
127153: PPUSH
127154: CALL_OW 255
127158: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
127159: LD_ADDR_VAR 0 4
127163: PUSH
127164: LD_EXP 213
127168: PUSH
127169: LD_VAR 0 1
127173: ARRAY
127174: PUSH
127175: LD_VAR 0 2
127179: ARRAY
127180: PUSH
127181: LD_INT 1
127183: ARRAY
127184: PPUSH
127185: LD_EXP 213
127189: PUSH
127190: LD_VAR 0 1
127194: ARRAY
127195: PUSH
127196: LD_VAR 0 2
127200: ARRAY
127201: PUSH
127202: LD_INT 2
127204: ARRAY
127205: PPUSH
127206: CALL_OW 428
127210: ST_TO_ADDR
// if not tmp then
127211: LD_VAR 0 4
127215: NOT
127216: IFFALSE 127220
// continue ;
127218: GO 127135
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
127220: LD_VAR 0 4
127224: PUSH
127225: LD_INT 81
127227: PUSH
127228: LD_VAR 0 3
127232: PUSH
127233: EMPTY
127234: LIST
127235: LIST
127236: PPUSH
127237: CALL_OW 69
127241: IN
127242: PUSH
127243: LD_EXP 213
127247: PUSH
127248: LD_VAR 0 1
127252: ARRAY
127253: PUSH
127254: LD_VAR 0 2
127258: ARRAY
127259: PUSH
127260: LD_INT 1
127262: ARRAY
127263: PPUSH
127264: LD_EXP 213
127268: PUSH
127269: LD_VAR 0 1
127273: ARRAY
127274: PUSH
127275: LD_VAR 0 2
127279: ARRAY
127280: PUSH
127281: LD_INT 2
127283: ARRAY
127284: PPUSH
127285: CALL_OW 458
127289: AND
127290: IFFALSE 127384
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
127292: LD_EXP 213
127296: PUSH
127297: LD_VAR 0 1
127301: ARRAY
127302: PUSH
127303: LD_VAR 0 2
127307: ARRAY
127308: PUSH
127309: LD_INT 1
127311: ARRAY
127312: PPUSH
127313: LD_EXP 213
127317: PUSH
127318: LD_VAR 0 1
127322: ARRAY
127323: PUSH
127324: LD_VAR 0 2
127328: ARRAY
127329: PUSH
127330: LD_INT 2
127332: ARRAY
127333: PPUSH
127334: LD_VAR 0 3
127338: PPUSH
127339: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
127343: LD_ADDR_EXP 213
127347: PUSH
127348: LD_EXP 213
127352: PPUSH
127353: LD_VAR 0 1
127357: PPUSH
127358: LD_EXP 213
127362: PUSH
127363: LD_VAR 0 1
127367: ARRAY
127368: PPUSH
127369: LD_VAR 0 2
127373: PPUSH
127374: CALL_OW 3
127378: PPUSH
127379: CALL_OW 1
127383: ST_TO_ADDR
// end ; end ;
127384: GO 127135
127386: POP
127387: POP
// end ;
127388: GO 127053
127390: POP
127391: POP
// end ;
127392: PPOPN 4
127394: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
127395: LD_INT 0
127397: PPUSH
127398: PPUSH
// result := false ;
127399: LD_ADDR_VAR 0 4
127403: PUSH
127404: LD_INT 0
127406: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
127407: LD_VAR 0 1
127411: PPUSH
127412: CALL_OW 264
127416: PUSH
127417: LD_INT 81
127419: EQUAL
127420: NOT
127421: IFFALSE 127425
// exit ;
127423: GO 127665
// index := GetElementIndex ( minersList , unit ) ;
127425: LD_ADDR_VAR 0 5
127429: PUSH
127430: LD_EXP 212
127434: PPUSH
127435: LD_VAR 0 1
127439: PPUSH
127440: CALL 72458 0 2
127444: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
127445: LD_EXP 213
127449: PUSH
127450: LD_VAR 0 5
127454: ARRAY
127455: PUSH
127456: LD_EXP 214
127460: GREATEREQUAL
127461: IFFALSE 127465
// exit ;
127463: GO 127665
// ComMoveXY ( unit , x , y ) ;
127465: LD_VAR 0 1
127469: PPUSH
127470: LD_VAR 0 2
127474: PPUSH
127475: LD_VAR 0 3
127479: PPUSH
127480: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
127484: LD_INT 35
127486: PPUSH
127487: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127491: LD_VAR 0 1
127495: PPUSH
127496: LD_VAR 0 2
127500: PPUSH
127501: LD_VAR 0 3
127505: PPUSH
127506: CALL 103794 0 3
127510: NOT
127511: PUSH
127512: LD_VAR 0 1
127516: PPUSH
127517: CALL_OW 314
127521: AND
127522: IFFALSE 127526
// exit ;
127524: GO 127665
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127526: LD_VAR 0 2
127530: PPUSH
127531: LD_VAR 0 3
127535: PPUSH
127536: CALL_OW 428
127540: PUSH
127541: LD_VAR 0 1
127545: EQUAL
127546: PUSH
127547: LD_VAR 0 1
127551: PPUSH
127552: CALL_OW 314
127556: NOT
127557: AND
127558: IFFALSE 127484
// PlaySoundXY ( x , y , PlantMine ) ;
127560: LD_VAR 0 2
127564: PPUSH
127565: LD_VAR 0 3
127569: PPUSH
127570: LD_STRING PlantMine
127572: PPUSH
127573: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127577: LD_VAR 0 2
127581: PPUSH
127582: LD_VAR 0 3
127586: PPUSH
127587: LD_VAR 0 1
127591: PPUSH
127592: CALL_OW 255
127596: PPUSH
127597: LD_INT 0
127599: PPUSH
127600: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127604: LD_ADDR_EXP 213
127608: PUSH
127609: LD_EXP 213
127613: PPUSH
127614: LD_VAR 0 5
127618: PUSH
127619: LD_EXP 213
127623: PUSH
127624: LD_VAR 0 5
127628: ARRAY
127629: PUSH
127630: LD_INT 1
127632: PLUS
127633: PUSH
127634: EMPTY
127635: LIST
127636: LIST
127637: PPUSH
127638: LD_VAR 0 2
127642: PUSH
127643: LD_VAR 0 3
127647: PUSH
127648: EMPTY
127649: LIST
127650: LIST
127651: PPUSH
127652: CALL 72673 0 3
127656: ST_TO_ADDR
// result := true ;
127657: LD_ADDR_VAR 0 4
127661: PUSH
127662: LD_INT 1
127664: ST_TO_ADDR
// end ;
127665: LD_VAR 0 4
127669: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127670: LD_INT 0
127672: PPUSH
127673: PPUSH
127674: PPUSH
// if not unit in minersList then
127675: LD_VAR 0 1
127679: PUSH
127680: LD_EXP 212
127684: IN
127685: NOT
127686: IFFALSE 127690
// exit ;
127688: GO 128082
// index := GetElementIndex ( minersList , unit ) ;
127690: LD_ADDR_VAR 0 6
127694: PUSH
127695: LD_EXP 212
127699: PPUSH
127700: LD_VAR 0 1
127704: PPUSH
127705: CALL 72458 0 2
127709: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127710: LD_ADDR_VAR 0 5
127714: PUSH
127715: DOUBLE
127716: LD_EXP 213
127720: PUSH
127721: LD_VAR 0 6
127725: ARRAY
127726: INC
127727: ST_TO_ADDR
127728: LD_INT 1
127730: PUSH
127731: FOR_DOWNTO
127732: IFFALSE 127893
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127734: LD_EXP 213
127738: PUSH
127739: LD_VAR 0 6
127743: ARRAY
127744: PUSH
127745: LD_VAR 0 5
127749: ARRAY
127750: PUSH
127751: LD_INT 1
127753: ARRAY
127754: PUSH
127755: LD_VAR 0 2
127759: EQUAL
127760: PUSH
127761: LD_EXP 213
127765: PUSH
127766: LD_VAR 0 6
127770: ARRAY
127771: PUSH
127772: LD_VAR 0 5
127776: ARRAY
127777: PUSH
127778: LD_INT 2
127780: ARRAY
127781: PUSH
127782: LD_VAR 0 3
127786: EQUAL
127787: AND
127788: IFFALSE 127891
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127790: LD_EXP 213
127794: PUSH
127795: LD_VAR 0 6
127799: ARRAY
127800: PUSH
127801: LD_VAR 0 5
127805: ARRAY
127806: PUSH
127807: LD_INT 1
127809: ARRAY
127810: PPUSH
127811: LD_EXP 213
127815: PUSH
127816: LD_VAR 0 6
127820: ARRAY
127821: PUSH
127822: LD_VAR 0 5
127826: ARRAY
127827: PUSH
127828: LD_INT 2
127830: ARRAY
127831: PPUSH
127832: LD_VAR 0 1
127836: PPUSH
127837: CALL_OW 255
127841: PPUSH
127842: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127846: LD_ADDR_EXP 213
127850: PUSH
127851: LD_EXP 213
127855: PPUSH
127856: LD_VAR 0 6
127860: PPUSH
127861: LD_EXP 213
127865: PUSH
127866: LD_VAR 0 6
127870: ARRAY
127871: PPUSH
127872: LD_VAR 0 5
127876: PPUSH
127877: CALL_OW 3
127881: PPUSH
127882: CALL_OW 1
127886: ST_TO_ADDR
// exit ;
127887: POP
127888: POP
127889: GO 128082
// end ; end ;
127891: GO 127731
127893: POP
127894: POP
// for i := minerMinesList [ index ] downto 1 do
127895: LD_ADDR_VAR 0 5
127899: PUSH
127900: DOUBLE
127901: LD_EXP 213
127905: PUSH
127906: LD_VAR 0 6
127910: ARRAY
127911: INC
127912: ST_TO_ADDR
127913: LD_INT 1
127915: PUSH
127916: FOR_DOWNTO
127917: IFFALSE 128080
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
127919: LD_EXP 213
127923: PUSH
127924: LD_VAR 0 6
127928: ARRAY
127929: PUSH
127930: LD_VAR 0 5
127934: ARRAY
127935: PUSH
127936: LD_INT 1
127938: ARRAY
127939: PPUSH
127940: LD_EXP 213
127944: PUSH
127945: LD_VAR 0 6
127949: ARRAY
127950: PUSH
127951: LD_VAR 0 5
127955: ARRAY
127956: PUSH
127957: LD_INT 2
127959: ARRAY
127960: PPUSH
127961: LD_VAR 0 2
127965: PPUSH
127966: LD_VAR 0 3
127970: PPUSH
127971: CALL_OW 298
127975: PUSH
127976: LD_INT 6
127978: LESS
127979: IFFALSE 128078
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127981: LD_EXP 213
127985: PUSH
127986: LD_VAR 0 6
127990: ARRAY
127991: PUSH
127992: LD_VAR 0 5
127996: ARRAY
127997: PUSH
127998: LD_INT 1
128000: ARRAY
128001: PPUSH
128002: LD_EXP 213
128006: PUSH
128007: LD_VAR 0 6
128011: ARRAY
128012: PUSH
128013: LD_VAR 0 5
128017: ARRAY
128018: PUSH
128019: LD_INT 2
128021: ARRAY
128022: PPUSH
128023: LD_VAR 0 1
128027: PPUSH
128028: CALL_OW 255
128032: PPUSH
128033: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128037: LD_ADDR_EXP 213
128041: PUSH
128042: LD_EXP 213
128046: PPUSH
128047: LD_VAR 0 6
128051: PPUSH
128052: LD_EXP 213
128056: PUSH
128057: LD_VAR 0 6
128061: ARRAY
128062: PPUSH
128063: LD_VAR 0 5
128067: PPUSH
128068: CALL_OW 3
128072: PPUSH
128073: CALL_OW 1
128077: ST_TO_ADDR
// end ; end ;
128078: GO 127916
128080: POP
128081: POP
// end ;
128082: LD_VAR 0 4
128086: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
128087: LD_INT 0
128089: PPUSH
128090: PPUSH
128091: PPUSH
128092: PPUSH
128093: PPUSH
128094: PPUSH
128095: PPUSH
128096: PPUSH
128097: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
128098: LD_VAR 0 1
128102: PPUSH
128103: CALL_OW 264
128107: PUSH
128108: LD_INT 81
128110: EQUAL
128111: NOT
128112: PUSH
128113: LD_VAR 0 1
128117: PUSH
128118: LD_EXP 212
128122: IN
128123: NOT
128124: OR
128125: IFFALSE 128129
// exit ;
128127: GO 128451
// index := GetElementIndex ( minersList , unit ) ;
128129: LD_ADDR_VAR 0 6
128133: PUSH
128134: LD_EXP 212
128138: PPUSH
128139: LD_VAR 0 1
128143: PPUSH
128144: CALL 72458 0 2
128148: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
128149: LD_ADDR_VAR 0 8
128153: PUSH
128154: LD_EXP 214
128158: PUSH
128159: LD_EXP 213
128163: PUSH
128164: LD_VAR 0 6
128168: ARRAY
128169: MINUS
128170: ST_TO_ADDR
// if not minesFreeAmount then
128171: LD_VAR 0 8
128175: NOT
128176: IFFALSE 128180
// exit ;
128178: GO 128451
// tmp := [ ] ;
128180: LD_ADDR_VAR 0 7
128184: PUSH
128185: EMPTY
128186: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
128187: LD_ADDR_VAR 0 5
128191: PUSH
128192: DOUBLE
128193: LD_INT 1
128195: DEC
128196: ST_TO_ADDR
128197: LD_VAR 0 8
128201: PUSH
128202: FOR_TO
128203: IFFALSE 128398
// begin _d := rand ( 0 , 5 ) ;
128205: LD_ADDR_VAR 0 11
128209: PUSH
128210: LD_INT 0
128212: PPUSH
128213: LD_INT 5
128215: PPUSH
128216: CALL_OW 12
128220: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
128221: LD_ADDR_VAR 0 12
128225: PUSH
128226: LD_INT 2
128228: PPUSH
128229: LD_INT 6
128231: PPUSH
128232: CALL_OW 12
128236: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
128237: LD_ADDR_VAR 0 9
128241: PUSH
128242: LD_VAR 0 2
128246: PPUSH
128247: LD_VAR 0 11
128251: PPUSH
128252: LD_VAR 0 12
128256: PPUSH
128257: CALL_OW 272
128261: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
128262: LD_ADDR_VAR 0 10
128266: PUSH
128267: LD_VAR 0 3
128271: PPUSH
128272: LD_VAR 0 11
128276: PPUSH
128277: LD_VAR 0 12
128281: PPUSH
128282: CALL_OW 273
128286: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
128287: LD_VAR 0 9
128291: PPUSH
128292: LD_VAR 0 10
128296: PPUSH
128297: CALL_OW 488
128301: PUSH
128302: LD_VAR 0 9
128306: PUSH
128307: LD_VAR 0 10
128311: PUSH
128312: EMPTY
128313: LIST
128314: LIST
128315: PUSH
128316: LD_VAR 0 7
128320: IN
128321: NOT
128322: AND
128323: PUSH
128324: LD_VAR 0 9
128328: PPUSH
128329: LD_VAR 0 10
128333: PPUSH
128334: CALL_OW 458
128338: NOT
128339: AND
128340: IFFALSE 128382
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
128342: LD_ADDR_VAR 0 7
128346: PUSH
128347: LD_VAR 0 7
128351: PPUSH
128352: LD_VAR 0 7
128356: PUSH
128357: LD_INT 1
128359: PLUS
128360: PPUSH
128361: LD_VAR 0 9
128365: PUSH
128366: LD_VAR 0 10
128370: PUSH
128371: EMPTY
128372: LIST
128373: LIST
128374: PPUSH
128375: CALL_OW 1
128379: ST_TO_ADDR
128380: GO 128396
// i := i - 1 ;
128382: LD_ADDR_VAR 0 5
128386: PUSH
128387: LD_VAR 0 5
128391: PUSH
128392: LD_INT 1
128394: MINUS
128395: ST_TO_ADDR
// end ;
128396: GO 128202
128398: POP
128399: POP
// for i in tmp do
128400: LD_ADDR_VAR 0 5
128404: PUSH
128405: LD_VAR 0 7
128409: PUSH
128410: FOR_IN
128411: IFFALSE 128449
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
128413: LD_VAR 0 1
128417: PPUSH
128418: LD_VAR 0 5
128422: PUSH
128423: LD_INT 1
128425: ARRAY
128426: PPUSH
128427: LD_VAR 0 5
128431: PUSH
128432: LD_INT 2
128434: ARRAY
128435: PPUSH
128436: CALL 127395 0 3
128440: NOT
128441: IFFALSE 128447
// exit ;
128443: POP
128444: POP
128445: GO 128451
128447: GO 128410
128449: POP
128450: POP
// end ;
128451: LD_VAR 0 4
128455: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
128456: LD_INT 0
128458: PPUSH
128459: PPUSH
128460: PPUSH
128461: PPUSH
128462: PPUSH
128463: PPUSH
128464: PPUSH
// if not GetClass ( unit ) = class_sniper then
128465: LD_VAR 0 1
128469: PPUSH
128470: CALL_OW 257
128474: PUSH
128475: LD_INT 5
128477: EQUAL
128478: NOT
128479: IFFALSE 128483
// exit ;
128481: GO 128871
// dist := 8 ;
128483: LD_ADDR_VAR 0 5
128487: PUSH
128488: LD_INT 8
128490: ST_TO_ADDR
// viewRange := 12 ;
128491: LD_ADDR_VAR 0 7
128495: PUSH
128496: LD_INT 12
128498: ST_TO_ADDR
// side := GetSide ( unit ) ;
128499: LD_ADDR_VAR 0 6
128503: PUSH
128504: LD_VAR 0 1
128508: PPUSH
128509: CALL_OW 255
128513: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128514: LD_INT 61
128516: PPUSH
128517: LD_VAR 0 6
128521: PPUSH
128522: CALL_OW 321
128526: PUSH
128527: LD_INT 2
128529: EQUAL
128530: IFFALSE 128540
// viewRange := 16 ;
128532: LD_ADDR_VAR 0 7
128536: PUSH
128537: LD_INT 16
128539: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128540: LD_VAR 0 1
128544: PPUSH
128545: LD_VAR 0 2
128549: PPUSH
128550: LD_VAR 0 3
128554: PPUSH
128555: CALL_OW 297
128559: PUSH
128560: LD_VAR 0 5
128564: GREATER
128565: IFFALSE 128644
// begin ComMoveXY ( unit , x , y ) ;
128567: LD_VAR 0 1
128571: PPUSH
128572: LD_VAR 0 2
128576: PPUSH
128577: LD_VAR 0 3
128581: PPUSH
128582: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128586: LD_INT 35
128588: PPUSH
128589: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128593: LD_VAR 0 1
128597: PPUSH
128598: LD_VAR 0 2
128602: PPUSH
128603: LD_VAR 0 3
128607: PPUSH
128608: CALL 103794 0 3
128612: NOT
128613: IFFALSE 128617
// exit ;
128615: GO 128871
// until GetDistUnitXY ( unit , x , y ) < dist ;
128617: LD_VAR 0 1
128621: PPUSH
128622: LD_VAR 0 2
128626: PPUSH
128627: LD_VAR 0 3
128631: PPUSH
128632: CALL_OW 297
128636: PUSH
128637: LD_VAR 0 5
128641: LESS
128642: IFFALSE 128586
// end ; ComTurnXY ( unit , x , y ) ;
128644: LD_VAR 0 1
128648: PPUSH
128649: LD_VAR 0 2
128653: PPUSH
128654: LD_VAR 0 3
128658: PPUSH
128659: CALL_OW 118
// wait ( 5 ) ;
128663: LD_INT 5
128665: PPUSH
128666: CALL_OW 67
// _d := GetDir ( unit ) ;
128670: LD_ADDR_VAR 0 10
128674: PUSH
128675: LD_VAR 0 1
128679: PPUSH
128680: CALL_OW 254
128684: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128685: LD_ADDR_VAR 0 8
128689: PUSH
128690: LD_VAR 0 1
128694: PPUSH
128695: CALL_OW 250
128699: PPUSH
128700: LD_VAR 0 10
128704: PPUSH
128705: LD_VAR 0 5
128709: PPUSH
128710: CALL_OW 272
128714: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128715: LD_ADDR_VAR 0 9
128719: PUSH
128720: LD_VAR 0 1
128724: PPUSH
128725: CALL_OW 251
128729: PPUSH
128730: LD_VAR 0 10
128734: PPUSH
128735: LD_VAR 0 5
128739: PPUSH
128740: CALL_OW 273
128744: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128745: LD_VAR 0 8
128749: PPUSH
128750: LD_VAR 0 9
128754: PPUSH
128755: CALL_OW 488
128759: NOT
128760: IFFALSE 128764
// exit ;
128762: GO 128871
// ComAnimCustom ( unit , 1 ) ;
128764: LD_VAR 0 1
128768: PPUSH
128769: LD_INT 1
128771: PPUSH
128772: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128776: LD_VAR 0 8
128780: PPUSH
128781: LD_VAR 0 9
128785: PPUSH
128786: LD_VAR 0 6
128790: PPUSH
128791: LD_VAR 0 7
128795: PPUSH
128796: CALL_OW 330
// repeat wait ( 1 ) ;
128800: LD_INT 1
128802: PPUSH
128803: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
128807: LD_VAR 0 1
128811: PPUSH
128812: CALL_OW 316
128816: PUSH
128817: LD_VAR 0 1
128821: PPUSH
128822: CALL_OW 314
128826: OR
128827: PUSH
128828: LD_VAR 0 1
128832: PPUSH
128833: CALL_OW 302
128837: NOT
128838: OR
128839: PUSH
128840: LD_VAR 0 1
128844: PPUSH
128845: CALL_OW 301
128849: OR
128850: IFFALSE 128800
// RemoveSeeing ( _x , _y , side ) ;
128852: LD_VAR 0 8
128856: PPUSH
128857: LD_VAR 0 9
128861: PPUSH
128862: LD_VAR 0 6
128866: PPUSH
128867: CALL_OW 331
// end ; end_of_file
128871: LD_VAR 0 4
128875: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
128876: LD_INT 0
128878: PPUSH
128879: PPUSH
128880: PPUSH
128881: PPUSH
128882: PPUSH
128883: PPUSH
128884: PPUSH
128885: PPUSH
128886: PPUSH
128887: PPUSH
128888: PPUSH
128889: PPUSH
128890: PPUSH
128891: PPUSH
128892: PPUSH
128893: PPUSH
128894: PPUSH
128895: PPUSH
128896: PPUSH
128897: PPUSH
128898: PPUSH
128899: PPUSH
128900: PPUSH
128901: PPUSH
128902: PPUSH
128903: PPUSH
128904: PPUSH
128905: PPUSH
128906: PPUSH
128907: PPUSH
128908: PPUSH
128909: PPUSH
128910: PPUSH
128911: PPUSH
// if not list then
128912: LD_VAR 0 1
128916: NOT
128917: IFFALSE 128921
// exit ;
128919: GO 133580
// base := list [ 1 ] ;
128921: LD_ADDR_VAR 0 3
128925: PUSH
128926: LD_VAR 0 1
128930: PUSH
128931: LD_INT 1
128933: ARRAY
128934: ST_TO_ADDR
// group := list [ 2 ] ;
128935: LD_ADDR_VAR 0 4
128939: PUSH
128940: LD_VAR 0 1
128944: PUSH
128945: LD_INT 2
128947: ARRAY
128948: ST_TO_ADDR
// path := list [ 3 ] ;
128949: LD_ADDR_VAR 0 5
128953: PUSH
128954: LD_VAR 0 1
128958: PUSH
128959: LD_INT 3
128961: ARRAY
128962: ST_TO_ADDR
// flags := list [ 4 ] ;
128963: LD_ADDR_VAR 0 6
128967: PUSH
128968: LD_VAR 0 1
128972: PUSH
128973: LD_INT 4
128975: ARRAY
128976: ST_TO_ADDR
// mined := [ ] ;
128977: LD_ADDR_VAR 0 27
128981: PUSH
128982: EMPTY
128983: ST_TO_ADDR
// bombed := [ ] ;
128984: LD_ADDR_VAR 0 28
128988: PUSH
128989: EMPTY
128990: ST_TO_ADDR
// healers := [ ] ;
128991: LD_ADDR_VAR 0 31
128995: PUSH
128996: EMPTY
128997: ST_TO_ADDR
// to_heal := [ ] ;
128998: LD_ADDR_VAR 0 30
129002: PUSH
129003: EMPTY
129004: ST_TO_ADDR
// repairs := [ ] ;
129005: LD_ADDR_VAR 0 33
129009: PUSH
129010: EMPTY
129011: ST_TO_ADDR
// to_repair := [ ] ;
129012: LD_ADDR_VAR 0 32
129016: PUSH
129017: EMPTY
129018: ST_TO_ADDR
// if not group or not path then
129019: LD_VAR 0 4
129023: NOT
129024: PUSH
129025: LD_VAR 0 5
129029: NOT
129030: OR
129031: IFFALSE 129035
// exit ;
129033: GO 133580
// side := GetSide ( group [ 1 ] ) ;
129035: LD_ADDR_VAR 0 35
129039: PUSH
129040: LD_VAR 0 4
129044: PUSH
129045: LD_INT 1
129047: ARRAY
129048: PPUSH
129049: CALL_OW 255
129053: ST_TO_ADDR
// if flags then
129054: LD_VAR 0 6
129058: IFFALSE 129202
// begin f_ignore_area := flags [ 1 ] ;
129060: LD_ADDR_VAR 0 17
129064: PUSH
129065: LD_VAR 0 6
129069: PUSH
129070: LD_INT 1
129072: ARRAY
129073: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
129074: LD_ADDR_VAR 0 18
129078: PUSH
129079: LD_VAR 0 6
129083: PUSH
129084: LD_INT 2
129086: ARRAY
129087: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
129088: LD_ADDR_VAR 0 19
129092: PUSH
129093: LD_VAR 0 6
129097: PUSH
129098: LD_INT 3
129100: ARRAY
129101: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
129102: LD_ADDR_VAR 0 20
129106: PUSH
129107: LD_VAR 0 6
129111: PUSH
129112: LD_INT 4
129114: ARRAY
129115: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
129116: LD_ADDR_VAR 0 21
129120: PUSH
129121: LD_VAR 0 6
129125: PUSH
129126: LD_INT 5
129128: ARRAY
129129: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
129130: LD_ADDR_VAR 0 22
129134: PUSH
129135: LD_VAR 0 6
129139: PUSH
129140: LD_INT 6
129142: ARRAY
129143: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
129144: LD_ADDR_VAR 0 23
129148: PUSH
129149: LD_VAR 0 6
129153: PUSH
129154: LD_INT 7
129156: ARRAY
129157: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
129158: LD_ADDR_VAR 0 24
129162: PUSH
129163: LD_VAR 0 6
129167: PUSH
129168: LD_INT 8
129170: ARRAY
129171: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
129172: LD_ADDR_VAR 0 25
129176: PUSH
129177: LD_VAR 0 6
129181: PUSH
129182: LD_INT 9
129184: ARRAY
129185: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
129186: LD_ADDR_VAR 0 26
129190: PUSH
129191: LD_VAR 0 6
129195: PUSH
129196: LD_INT 10
129198: ARRAY
129199: ST_TO_ADDR
// end else
129200: GO 129282
// begin f_ignore_area := false ;
129202: LD_ADDR_VAR 0 17
129206: PUSH
129207: LD_INT 0
129209: ST_TO_ADDR
// f_capture := false ;
129210: LD_ADDR_VAR 0 18
129214: PUSH
129215: LD_INT 0
129217: ST_TO_ADDR
// f_ignore_civ := false ;
129218: LD_ADDR_VAR 0 19
129222: PUSH
129223: LD_INT 0
129225: ST_TO_ADDR
// f_murder := false ;
129226: LD_ADDR_VAR 0 20
129230: PUSH
129231: LD_INT 0
129233: ST_TO_ADDR
// f_mines := false ;
129234: LD_ADDR_VAR 0 21
129238: PUSH
129239: LD_INT 0
129241: ST_TO_ADDR
// f_repair := false ;
129242: LD_ADDR_VAR 0 22
129246: PUSH
129247: LD_INT 0
129249: ST_TO_ADDR
// f_heal := false ;
129250: LD_ADDR_VAR 0 23
129254: PUSH
129255: LD_INT 0
129257: ST_TO_ADDR
// f_spacetime := false ;
129258: LD_ADDR_VAR 0 24
129262: PUSH
129263: LD_INT 0
129265: ST_TO_ADDR
// f_attack_depot := false ;
129266: LD_ADDR_VAR 0 25
129270: PUSH
129271: LD_INT 0
129273: ST_TO_ADDR
// f_crawl := false ;
129274: LD_ADDR_VAR 0 26
129278: PUSH
129279: LD_INT 0
129281: ST_TO_ADDR
// end ; if f_heal then
129282: LD_VAR 0 23
129286: IFFALSE 129313
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
129288: LD_ADDR_VAR 0 31
129292: PUSH
129293: LD_VAR 0 4
129297: PPUSH
129298: LD_INT 25
129300: PUSH
129301: LD_INT 4
129303: PUSH
129304: EMPTY
129305: LIST
129306: LIST
129307: PPUSH
129308: CALL_OW 72
129312: ST_TO_ADDR
// if f_repair then
129313: LD_VAR 0 22
129317: IFFALSE 129344
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
129319: LD_ADDR_VAR 0 33
129323: PUSH
129324: LD_VAR 0 4
129328: PPUSH
129329: LD_INT 25
129331: PUSH
129332: LD_INT 3
129334: PUSH
129335: EMPTY
129336: LIST
129337: LIST
129338: PPUSH
129339: CALL_OW 72
129343: ST_TO_ADDR
// units_path := [ ] ;
129344: LD_ADDR_VAR 0 16
129348: PUSH
129349: EMPTY
129350: ST_TO_ADDR
// for i = 1 to group do
129351: LD_ADDR_VAR 0 7
129355: PUSH
129356: DOUBLE
129357: LD_INT 1
129359: DEC
129360: ST_TO_ADDR
129361: LD_VAR 0 4
129365: PUSH
129366: FOR_TO
129367: IFFALSE 129396
// units_path := Replace ( units_path , i , path ) ;
129369: LD_ADDR_VAR 0 16
129373: PUSH
129374: LD_VAR 0 16
129378: PPUSH
129379: LD_VAR 0 7
129383: PPUSH
129384: LD_VAR 0 5
129388: PPUSH
129389: CALL_OW 1
129393: ST_TO_ADDR
129394: GO 129366
129396: POP
129397: POP
// repeat for i = group downto 1 do
129398: LD_ADDR_VAR 0 7
129402: PUSH
129403: DOUBLE
129404: LD_VAR 0 4
129408: INC
129409: ST_TO_ADDR
129410: LD_INT 1
129412: PUSH
129413: FOR_DOWNTO
129414: IFFALSE 133536
// begin wait ( 5 ) ;
129416: LD_INT 5
129418: PPUSH
129419: CALL_OW 67
// tmp := [ ] ;
129423: LD_ADDR_VAR 0 14
129427: PUSH
129428: EMPTY
129429: ST_TO_ADDR
// attacking := false ;
129430: LD_ADDR_VAR 0 29
129434: PUSH
129435: LD_INT 0
129437: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
129438: LD_VAR 0 4
129442: PUSH
129443: LD_VAR 0 7
129447: ARRAY
129448: PPUSH
129449: CALL_OW 301
129453: PUSH
129454: LD_VAR 0 4
129458: PUSH
129459: LD_VAR 0 7
129463: ARRAY
129464: NOT
129465: OR
129466: IFFALSE 129575
// begin if GetType ( group [ i ] ) = unit_human then
129468: LD_VAR 0 4
129472: PUSH
129473: LD_VAR 0 7
129477: ARRAY
129478: PPUSH
129479: CALL_OW 247
129483: PUSH
129484: LD_INT 1
129486: EQUAL
129487: IFFALSE 129533
// begin to_heal := to_heal diff group [ i ] ;
129489: LD_ADDR_VAR 0 30
129493: PUSH
129494: LD_VAR 0 30
129498: PUSH
129499: LD_VAR 0 4
129503: PUSH
129504: LD_VAR 0 7
129508: ARRAY
129509: DIFF
129510: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129511: LD_ADDR_VAR 0 31
129515: PUSH
129516: LD_VAR 0 31
129520: PUSH
129521: LD_VAR 0 4
129525: PUSH
129526: LD_VAR 0 7
129530: ARRAY
129531: DIFF
129532: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129533: LD_ADDR_VAR 0 4
129537: PUSH
129538: LD_VAR 0 4
129542: PPUSH
129543: LD_VAR 0 7
129547: PPUSH
129548: CALL_OW 3
129552: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129553: LD_ADDR_VAR 0 16
129557: PUSH
129558: LD_VAR 0 16
129562: PPUSH
129563: LD_VAR 0 7
129567: PPUSH
129568: CALL_OW 3
129572: ST_TO_ADDR
// continue ;
129573: GO 129413
// end ; if f_repair then
129575: LD_VAR 0 22
129579: IFFALSE 130068
// begin if GetType ( group [ i ] ) = unit_vehicle then
129581: LD_VAR 0 4
129585: PUSH
129586: LD_VAR 0 7
129590: ARRAY
129591: PPUSH
129592: CALL_OW 247
129596: PUSH
129597: LD_INT 2
129599: EQUAL
129600: IFFALSE 129790
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129602: LD_VAR 0 4
129606: PUSH
129607: LD_VAR 0 7
129611: ARRAY
129612: PPUSH
129613: CALL_OW 256
129617: PUSH
129618: LD_INT 700
129620: LESS
129621: PUSH
129622: LD_VAR 0 4
129626: PUSH
129627: LD_VAR 0 7
129631: ARRAY
129632: PUSH
129633: LD_VAR 0 32
129637: IN
129638: NOT
129639: AND
129640: IFFALSE 129664
// to_repair := to_repair union group [ i ] ;
129642: LD_ADDR_VAR 0 32
129646: PUSH
129647: LD_VAR 0 32
129651: PUSH
129652: LD_VAR 0 4
129656: PUSH
129657: LD_VAR 0 7
129661: ARRAY
129662: UNION
129663: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129664: LD_VAR 0 4
129668: PUSH
129669: LD_VAR 0 7
129673: ARRAY
129674: PPUSH
129675: CALL_OW 256
129679: PUSH
129680: LD_INT 1000
129682: EQUAL
129683: PUSH
129684: LD_VAR 0 4
129688: PUSH
129689: LD_VAR 0 7
129693: ARRAY
129694: PUSH
129695: LD_VAR 0 32
129699: IN
129700: AND
129701: IFFALSE 129725
// to_repair := to_repair diff group [ i ] ;
129703: LD_ADDR_VAR 0 32
129707: PUSH
129708: LD_VAR 0 32
129712: PUSH
129713: LD_VAR 0 4
129717: PUSH
129718: LD_VAR 0 7
129722: ARRAY
129723: DIFF
129724: ST_TO_ADDR
// if group [ i ] in to_repair then
129725: LD_VAR 0 4
129729: PUSH
129730: LD_VAR 0 7
129734: ARRAY
129735: PUSH
129736: LD_VAR 0 32
129740: IN
129741: IFFALSE 129788
// begin if not IsInArea ( group [ i ] , f_repair ) then
129743: LD_VAR 0 4
129747: PUSH
129748: LD_VAR 0 7
129752: ARRAY
129753: PPUSH
129754: LD_VAR 0 22
129758: PPUSH
129759: CALL_OW 308
129763: NOT
129764: IFFALSE 129786
// ComMoveToArea ( group [ i ] , f_repair ) ;
129766: LD_VAR 0 4
129770: PUSH
129771: LD_VAR 0 7
129775: ARRAY
129776: PPUSH
129777: LD_VAR 0 22
129781: PPUSH
129782: CALL_OW 113
// continue ;
129786: GO 129413
// end ; end else
129788: GO 130068
// if group [ i ] in repairs then
129790: LD_VAR 0 4
129794: PUSH
129795: LD_VAR 0 7
129799: ARRAY
129800: PUSH
129801: LD_VAR 0 33
129805: IN
129806: IFFALSE 130068
// begin if IsInUnit ( group [ i ] ) then
129808: LD_VAR 0 4
129812: PUSH
129813: LD_VAR 0 7
129817: ARRAY
129818: PPUSH
129819: CALL_OW 310
129823: IFFALSE 129891
// begin z := IsInUnit ( group [ i ] ) ;
129825: LD_ADDR_VAR 0 13
129829: PUSH
129830: LD_VAR 0 4
129834: PUSH
129835: LD_VAR 0 7
129839: ARRAY
129840: PPUSH
129841: CALL_OW 310
129845: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
129846: LD_VAR 0 13
129850: PUSH
129851: LD_VAR 0 32
129855: IN
129856: PUSH
129857: LD_VAR 0 13
129861: PPUSH
129862: LD_VAR 0 22
129866: PPUSH
129867: CALL_OW 308
129871: AND
129872: IFFALSE 129889
// ComExitVehicle ( group [ i ] ) ;
129874: LD_VAR 0 4
129878: PUSH
129879: LD_VAR 0 7
129883: ARRAY
129884: PPUSH
129885: CALL_OW 121
// end else
129889: GO 130068
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
129891: LD_ADDR_VAR 0 13
129895: PUSH
129896: LD_VAR 0 4
129900: PPUSH
129901: LD_INT 95
129903: PUSH
129904: LD_VAR 0 22
129908: PUSH
129909: EMPTY
129910: LIST
129911: LIST
129912: PUSH
129913: LD_INT 58
129915: PUSH
129916: EMPTY
129917: LIST
129918: PUSH
129919: EMPTY
129920: LIST
129921: LIST
129922: PPUSH
129923: CALL_OW 72
129927: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
129928: LD_VAR 0 4
129932: PUSH
129933: LD_VAR 0 7
129937: ARRAY
129938: PPUSH
129939: CALL_OW 314
129943: NOT
129944: IFFALSE 130066
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
129946: LD_ADDR_VAR 0 10
129950: PUSH
129951: LD_VAR 0 13
129955: PPUSH
129956: LD_VAR 0 4
129960: PUSH
129961: LD_VAR 0 7
129965: ARRAY
129966: PPUSH
129967: CALL_OW 74
129971: ST_TO_ADDR
// if not x then
129972: LD_VAR 0 10
129976: NOT
129977: IFFALSE 129981
// continue ;
129979: GO 129413
// if GetLives ( x ) < 1000 then
129981: LD_VAR 0 10
129985: PPUSH
129986: CALL_OW 256
129990: PUSH
129991: LD_INT 1000
129993: LESS
129994: IFFALSE 130018
// ComRepairVehicle ( group [ i ] , x ) else
129996: LD_VAR 0 4
130000: PUSH
130001: LD_VAR 0 7
130005: ARRAY
130006: PPUSH
130007: LD_VAR 0 10
130011: PPUSH
130012: CALL_OW 129
130016: GO 130066
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
130018: LD_VAR 0 23
130022: PUSH
130023: LD_VAR 0 4
130027: PUSH
130028: LD_VAR 0 7
130032: ARRAY
130033: PPUSH
130034: CALL_OW 256
130038: PUSH
130039: LD_INT 1000
130041: LESS
130042: AND
130043: NOT
130044: IFFALSE 130066
// ComEnterUnit ( group [ i ] , x ) ;
130046: LD_VAR 0 4
130050: PUSH
130051: LD_VAR 0 7
130055: ARRAY
130056: PPUSH
130057: LD_VAR 0 10
130061: PPUSH
130062: CALL_OW 120
// end ; continue ;
130066: GO 129413
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
130068: LD_VAR 0 23
130072: PUSH
130073: LD_VAR 0 4
130077: PUSH
130078: LD_VAR 0 7
130082: ARRAY
130083: PPUSH
130084: CALL_OW 247
130088: PUSH
130089: LD_INT 1
130091: EQUAL
130092: AND
130093: IFFALSE 130571
// begin if group [ i ] in healers then
130095: LD_VAR 0 4
130099: PUSH
130100: LD_VAR 0 7
130104: ARRAY
130105: PUSH
130106: LD_VAR 0 31
130110: IN
130111: IFFALSE 130384
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
130113: LD_VAR 0 4
130117: PUSH
130118: LD_VAR 0 7
130122: ARRAY
130123: PPUSH
130124: LD_VAR 0 23
130128: PPUSH
130129: CALL_OW 308
130133: NOT
130134: PUSH
130135: LD_VAR 0 4
130139: PUSH
130140: LD_VAR 0 7
130144: ARRAY
130145: PPUSH
130146: CALL_OW 314
130150: NOT
130151: AND
130152: IFFALSE 130176
// ComMoveToArea ( group [ i ] , f_heal ) else
130154: LD_VAR 0 4
130158: PUSH
130159: LD_VAR 0 7
130163: ARRAY
130164: PPUSH
130165: LD_VAR 0 23
130169: PPUSH
130170: CALL_OW 113
130174: GO 130382
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
130176: LD_VAR 0 4
130180: PUSH
130181: LD_VAR 0 7
130185: ARRAY
130186: PPUSH
130187: CALL 102370 0 1
130191: PPUSH
130192: CALL_OW 256
130196: PUSH
130197: LD_INT 1000
130199: EQUAL
130200: IFFALSE 130219
// ComStop ( group [ i ] ) else
130202: LD_VAR 0 4
130206: PUSH
130207: LD_VAR 0 7
130211: ARRAY
130212: PPUSH
130213: CALL_OW 141
130217: GO 130382
// if not HasTask ( group [ i ] ) and to_heal then
130219: LD_VAR 0 4
130223: PUSH
130224: LD_VAR 0 7
130228: ARRAY
130229: PPUSH
130230: CALL_OW 314
130234: NOT
130235: PUSH
130236: LD_VAR 0 30
130240: AND
130241: IFFALSE 130382
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
130243: LD_ADDR_VAR 0 13
130247: PUSH
130248: LD_VAR 0 30
130252: PPUSH
130253: LD_INT 3
130255: PUSH
130256: LD_INT 54
130258: PUSH
130259: EMPTY
130260: LIST
130261: PUSH
130262: EMPTY
130263: LIST
130264: LIST
130265: PPUSH
130266: CALL_OW 72
130270: PPUSH
130271: LD_VAR 0 4
130275: PUSH
130276: LD_VAR 0 7
130280: ARRAY
130281: PPUSH
130282: CALL_OW 74
130286: ST_TO_ADDR
// if z then
130287: LD_VAR 0 13
130291: IFFALSE 130382
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
130293: LD_INT 91
130295: PUSH
130296: LD_VAR 0 13
130300: PUSH
130301: LD_INT 10
130303: PUSH
130304: EMPTY
130305: LIST
130306: LIST
130307: LIST
130308: PUSH
130309: LD_INT 81
130311: PUSH
130312: LD_VAR 0 13
130316: PPUSH
130317: CALL_OW 255
130321: PUSH
130322: EMPTY
130323: LIST
130324: LIST
130325: PUSH
130326: EMPTY
130327: LIST
130328: LIST
130329: PPUSH
130330: CALL_OW 69
130334: PUSH
130335: LD_INT 0
130337: EQUAL
130338: IFFALSE 130362
// ComHeal ( group [ i ] , z ) else
130340: LD_VAR 0 4
130344: PUSH
130345: LD_VAR 0 7
130349: ARRAY
130350: PPUSH
130351: LD_VAR 0 13
130355: PPUSH
130356: CALL_OW 128
130360: GO 130382
// ComMoveToArea ( group [ i ] , f_heal ) ;
130362: LD_VAR 0 4
130366: PUSH
130367: LD_VAR 0 7
130371: ARRAY
130372: PPUSH
130373: LD_VAR 0 23
130377: PPUSH
130378: CALL_OW 113
// end ; continue ;
130382: GO 129413
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
130384: LD_VAR 0 4
130388: PUSH
130389: LD_VAR 0 7
130393: ARRAY
130394: PPUSH
130395: CALL_OW 256
130399: PUSH
130400: LD_INT 700
130402: LESS
130403: PUSH
130404: LD_VAR 0 4
130408: PUSH
130409: LD_VAR 0 7
130413: ARRAY
130414: PUSH
130415: LD_VAR 0 30
130419: IN
130420: NOT
130421: AND
130422: IFFALSE 130446
// to_heal := to_heal union group [ i ] ;
130424: LD_ADDR_VAR 0 30
130428: PUSH
130429: LD_VAR 0 30
130433: PUSH
130434: LD_VAR 0 4
130438: PUSH
130439: LD_VAR 0 7
130443: ARRAY
130444: UNION
130445: ST_TO_ADDR
// if group [ i ] in to_heal then
130446: LD_VAR 0 4
130450: PUSH
130451: LD_VAR 0 7
130455: ARRAY
130456: PUSH
130457: LD_VAR 0 30
130461: IN
130462: IFFALSE 130571
// begin if GetLives ( group [ i ] ) = 1000 then
130464: LD_VAR 0 4
130468: PUSH
130469: LD_VAR 0 7
130473: ARRAY
130474: PPUSH
130475: CALL_OW 256
130479: PUSH
130480: LD_INT 1000
130482: EQUAL
130483: IFFALSE 130509
// to_heal := to_heal diff group [ i ] else
130485: LD_ADDR_VAR 0 30
130489: PUSH
130490: LD_VAR 0 30
130494: PUSH
130495: LD_VAR 0 4
130499: PUSH
130500: LD_VAR 0 7
130504: ARRAY
130505: DIFF
130506: ST_TO_ADDR
130507: GO 130571
// begin if not IsInArea ( group [ i ] , to_heal ) then
130509: LD_VAR 0 4
130513: PUSH
130514: LD_VAR 0 7
130518: ARRAY
130519: PPUSH
130520: LD_VAR 0 30
130524: PPUSH
130525: CALL_OW 308
130529: NOT
130530: IFFALSE 130554
// ComMoveToArea ( group [ i ] , f_heal ) else
130532: LD_VAR 0 4
130536: PUSH
130537: LD_VAR 0 7
130541: ARRAY
130542: PPUSH
130543: LD_VAR 0 23
130547: PPUSH
130548: CALL_OW 113
130552: GO 130569
// ComHold ( group [ i ] ) ;
130554: LD_VAR 0 4
130558: PUSH
130559: LD_VAR 0 7
130563: ARRAY
130564: PPUSH
130565: CALL_OW 140
// continue ;
130569: GO 129413
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130571: LD_VAR 0 4
130575: PUSH
130576: LD_VAR 0 7
130580: ARRAY
130581: PPUSH
130582: LD_INT 10
130584: PPUSH
130585: CALL 100167 0 2
130589: NOT
130590: PUSH
130591: LD_VAR 0 16
130595: PUSH
130596: LD_VAR 0 7
130600: ARRAY
130601: PUSH
130602: EMPTY
130603: EQUAL
130604: NOT
130605: AND
130606: IFFALSE 130872
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130608: LD_VAR 0 4
130612: PUSH
130613: LD_VAR 0 7
130617: ARRAY
130618: PPUSH
130619: CALL_OW 262
130623: PUSH
130624: LD_INT 1
130626: PUSH
130627: LD_INT 2
130629: PUSH
130630: EMPTY
130631: LIST
130632: LIST
130633: IN
130634: IFFALSE 130675
// if GetFuel ( group [ i ] ) < 10 then
130636: LD_VAR 0 4
130640: PUSH
130641: LD_VAR 0 7
130645: ARRAY
130646: PPUSH
130647: CALL_OW 261
130651: PUSH
130652: LD_INT 10
130654: LESS
130655: IFFALSE 130675
// SetFuel ( group [ i ] , 12 ) ;
130657: LD_VAR 0 4
130661: PUSH
130662: LD_VAR 0 7
130666: ARRAY
130667: PPUSH
130668: LD_INT 12
130670: PPUSH
130671: CALL_OW 240
// if units_path [ i ] then
130675: LD_VAR 0 16
130679: PUSH
130680: LD_VAR 0 7
130684: ARRAY
130685: IFFALSE 130870
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130687: LD_VAR 0 4
130691: PUSH
130692: LD_VAR 0 7
130696: ARRAY
130697: PPUSH
130698: LD_VAR 0 16
130702: PUSH
130703: LD_VAR 0 7
130707: ARRAY
130708: PUSH
130709: LD_INT 1
130711: ARRAY
130712: PUSH
130713: LD_INT 1
130715: ARRAY
130716: PPUSH
130717: LD_VAR 0 16
130721: PUSH
130722: LD_VAR 0 7
130726: ARRAY
130727: PUSH
130728: LD_INT 1
130730: ARRAY
130731: PUSH
130732: LD_INT 2
130734: ARRAY
130735: PPUSH
130736: CALL_OW 297
130740: PUSH
130741: LD_INT 6
130743: GREATER
130744: IFFALSE 130819
// begin if not HasTask ( group [ i ] ) then
130746: LD_VAR 0 4
130750: PUSH
130751: LD_VAR 0 7
130755: ARRAY
130756: PPUSH
130757: CALL_OW 314
130761: NOT
130762: IFFALSE 130817
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130764: LD_VAR 0 4
130768: PUSH
130769: LD_VAR 0 7
130773: ARRAY
130774: PPUSH
130775: LD_VAR 0 16
130779: PUSH
130780: LD_VAR 0 7
130784: ARRAY
130785: PUSH
130786: LD_INT 1
130788: ARRAY
130789: PUSH
130790: LD_INT 1
130792: ARRAY
130793: PPUSH
130794: LD_VAR 0 16
130798: PUSH
130799: LD_VAR 0 7
130803: ARRAY
130804: PUSH
130805: LD_INT 1
130807: ARRAY
130808: PUSH
130809: LD_INT 2
130811: ARRAY
130812: PPUSH
130813: CALL_OW 114
// end else
130817: GO 130870
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
130819: LD_ADDR_VAR 0 15
130823: PUSH
130824: LD_VAR 0 16
130828: PUSH
130829: LD_VAR 0 7
130833: ARRAY
130834: PPUSH
130835: LD_INT 1
130837: PPUSH
130838: CALL_OW 3
130842: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
130843: LD_ADDR_VAR 0 16
130847: PUSH
130848: LD_VAR 0 16
130852: PPUSH
130853: LD_VAR 0 7
130857: PPUSH
130858: LD_VAR 0 15
130862: PPUSH
130863: CALL_OW 1
130867: ST_TO_ADDR
// continue ;
130868: GO 129413
// end ; end ; end else
130870: GO 133534
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
130872: LD_ADDR_VAR 0 14
130876: PUSH
130877: LD_INT 81
130879: PUSH
130880: LD_VAR 0 4
130884: PUSH
130885: LD_VAR 0 7
130889: ARRAY
130890: PPUSH
130891: CALL_OW 255
130895: PUSH
130896: EMPTY
130897: LIST
130898: LIST
130899: PPUSH
130900: CALL_OW 69
130904: ST_TO_ADDR
// if not tmp then
130905: LD_VAR 0 14
130909: NOT
130910: IFFALSE 130914
// continue ;
130912: GO 129413
// if f_ignore_area then
130914: LD_VAR 0 17
130918: IFFALSE 131006
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
130920: LD_ADDR_VAR 0 15
130924: PUSH
130925: LD_VAR 0 14
130929: PPUSH
130930: LD_INT 3
130932: PUSH
130933: LD_INT 92
130935: PUSH
130936: LD_VAR 0 17
130940: PUSH
130941: LD_INT 1
130943: ARRAY
130944: PUSH
130945: LD_VAR 0 17
130949: PUSH
130950: LD_INT 2
130952: ARRAY
130953: PUSH
130954: LD_VAR 0 17
130958: PUSH
130959: LD_INT 3
130961: ARRAY
130962: PUSH
130963: EMPTY
130964: LIST
130965: LIST
130966: LIST
130967: LIST
130968: PUSH
130969: EMPTY
130970: LIST
130971: LIST
130972: PPUSH
130973: CALL_OW 72
130977: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130978: LD_VAR 0 14
130982: PUSH
130983: LD_VAR 0 15
130987: DIFF
130988: IFFALSE 131006
// tmp := tmp diff tmp2 ;
130990: LD_ADDR_VAR 0 14
130994: PUSH
130995: LD_VAR 0 14
130999: PUSH
131000: LD_VAR 0 15
131004: DIFF
131005: ST_TO_ADDR
// end ; if not f_murder then
131006: LD_VAR 0 20
131010: NOT
131011: IFFALSE 131069
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
131013: LD_ADDR_VAR 0 15
131017: PUSH
131018: LD_VAR 0 14
131022: PPUSH
131023: LD_INT 3
131025: PUSH
131026: LD_INT 50
131028: PUSH
131029: EMPTY
131030: LIST
131031: PUSH
131032: EMPTY
131033: LIST
131034: LIST
131035: PPUSH
131036: CALL_OW 72
131040: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
131041: LD_VAR 0 14
131045: PUSH
131046: LD_VAR 0 15
131050: DIFF
131051: IFFALSE 131069
// tmp := tmp diff tmp2 ;
131053: LD_ADDR_VAR 0 14
131057: PUSH
131058: LD_VAR 0 14
131062: PUSH
131063: LD_VAR 0 15
131067: DIFF
131068: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
131069: LD_ADDR_VAR 0 14
131073: PUSH
131074: LD_VAR 0 4
131078: PUSH
131079: LD_VAR 0 7
131083: ARRAY
131084: PPUSH
131085: LD_VAR 0 14
131089: PPUSH
131090: LD_INT 1
131092: PPUSH
131093: LD_INT 1
131095: PPUSH
131096: CALL 73108 0 4
131100: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
131101: LD_VAR 0 4
131105: PUSH
131106: LD_VAR 0 7
131110: ARRAY
131111: PPUSH
131112: CALL_OW 257
131116: PUSH
131117: LD_INT 1
131119: EQUAL
131120: IFFALSE 131568
// begin if WantPlant ( group [ i ] ) then
131122: LD_VAR 0 4
131126: PUSH
131127: LD_VAR 0 7
131131: ARRAY
131132: PPUSH
131133: CALL 72609 0 1
131137: IFFALSE 131141
// continue ;
131139: GO 129413
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
131141: LD_VAR 0 18
131145: PUSH
131146: LD_VAR 0 4
131150: PUSH
131151: LD_VAR 0 7
131155: ARRAY
131156: PPUSH
131157: CALL_OW 310
131161: NOT
131162: AND
131163: PUSH
131164: LD_VAR 0 14
131168: PUSH
131169: LD_INT 1
131171: ARRAY
131172: PUSH
131173: LD_VAR 0 14
131177: PPUSH
131178: LD_INT 21
131180: PUSH
131181: LD_INT 2
131183: PUSH
131184: EMPTY
131185: LIST
131186: LIST
131187: PUSH
131188: LD_INT 58
131190: PUSH
131191: EMPTY
131192: LIST
131193: PUSH
131194: EMPTY
131195: LIST
131196: LIST
131197: PPUSH
131198: CALL_OW 72
131202: IN
131203: AND
131204: IFFALSE 131240
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
131206: LD_VAR 0 4
131210: PUSH
131211: LD_VAR 0 7
131215: ARRAY
131216: PPUSH
131217: LD_VAR 0 14
131221: PUSH
131222: LD_INT 1
131224: ARRAY
131225: PPUSH
131226: CALL_OW 120
// attacking := true ;
131230: LD_ADDR_VAR 0 29
131234: PUSH
131235: LD_INT 1
131237: ST_TO_ADDR
// continue ;
131238: GO 129413
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
131240: LD_VAR 0 26
131244: PUSH
131245: LD_VAR 0 4
131249: PUSH
131250: LD_VAR 0 7
131254: ARRAY
131255: PPUSH
131256: CALL_OW 257
131260: PUSH
131261: LD_INT 1
131263: EQUAL
131264: AND
131265: PUSH
131266: LD_VAR 0 4
131270: PUSH
131271: LD_VAR 0 7
131275: ARRAY
131276: PPUSH
131277: CALL_OW 256
131281: PUSH
131282: LD_INT 800
131284: LESS
131285: AND
131286: PUSH
131287: LD_VAR 0 4
131291: PUSH
131292: LD_VAR 0 7
131296: ARRAY
131297: PPUSH
131298: CALL_OW 318
131302: NOT
131303: AND
131304: IFFALSE 131321
// ComCrawl ( group [ i ] ) ;
131306: LD_VAR 0 4
131310: PUSH
131311: LD_VAR 0 7
131315: ARRAY
131316: PPUSH
131317: CALL_OW 137
// if f_mines then
131321: LD_VAR 0 21
131325: IFFALSE 131568
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
131327: LD_VAR 0 14
131331: PUSH
131332: LD_INT 1
131334: ARRAY
131335: PPUSH
131336: CALL_OW 247
131340: PUSH
131341: LD_INT 3
131343: EQUAL
131344: PUSH
131345: LD_VAR 0 14
131349: PUSH
131350: LD_INT 1
131352: ARRAY
131353: PUSH
131354: LD_VAR 0 27
131358: IN
131359: NOT
131360: AND
131361: IFFALSE 131568
// begin x := GetX ( tmp [ 1 ] ) ;
131363: LD_ADDR_VAR 0 10
131367: PUSH
131368: LD_VAR 0 14
131372: PUSH
131373: LD_INT 1
131375: ARRAY
131376: PPUSH
131377: CALL_OW 250
131381: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
131382: LD_ADDR_VAR 0 11
131386: PUSH
131387: LD_VAR 0 14
131391: PUSH
131392: LD_INT 1
131394: ARRAY
131395: PPUSH
131396: CALL_OW 251
131400: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
131401: LD_ADDR_VAR 0 12
131405: PUSH
131406: LD_VAR 0 4
131410: PUSH
131411: LD_VAR 0 7
131415: ARRAY
131416: PPUSH
131417: CALL 100252 0 1
131421: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
131422: LD_VAR 0 4
131426: PUSH
131427: LD_VAR 0 7
131431: ARRAY
131432: PPUSH
131433: LD_VAR 0 10
131437: PPUSH
131438: LD_VAR 0 11
131442: PPUSH
131443: LD_VAR 0 14
131447: PUSH
131448: LD_INT 1
131450: ARRAY
131451: PPUSH
131452: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
131456: LD_VAR 0 4
131460: PUSH
131461: LD_VAR 0 7
131465: ARRAY
131466: PPUSH
131467: LD_VAR 0 10
131471: PPUSH
131472: LD_VAR 0 12
131476: PPUSH
131477: LD_INT 7
131479: PPUSH
131480: CALL_OW 272
131484: PPUSH
131485: LD_VAR 0 11
131489: PPUSH
131490: LD_VAR 0 12
131494: PPUSH
131495: LD_INT 7
131497: PPUSH
131498: CALL_OW 273
131502: PPUSH
131503: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131507: LD_VAR 0 4
131511: PUSH
131512: LD_VAR 0 7
131516: ARRAY
131517: PPUSH
131518: LD_INT 71
131520: PPUSH
131521: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131525: LD_ADDR_VAR 0 27
131529: PUSH
131530: LD_VAR 0 27
131534: PPUSH
131535: LD_VAR 0 27
131539: PUSH
131540: LD_INT 1
131542: PLUS
131543: PPUSH
131544: LD_VAR 0 14
131548: PUSH
131549: LD_INT 1
131551: ARRAY
131552: PPUSH
131553: CALL_OW 1
131557: ST_TO_ADDR
// attacking := true ;
131558: LD_ADDR_VAR 0 29
131562: PUSH
131563: LD_INT 1
131565: ST_TO_ADDR
// continue ;
131566: GO 129413
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131568: LD_VAR 0 4
131572: PUSH
131573: LD_VAR 0 7
131577: ARRAY
131578: PPUSH
131579: CALL_OW 257
131583: PUSH
131584: LD_INT 17
131586: EQUAL
131587: PUSH
131588: LD_VAR 0 4
131592: PUSH
131593: LD_VAR 0 7
131597: ARRAY
131598: PPUSH
131599: CALL_OW 110
131603: PUSH
131604: LD_INT 71
131606: EQUAL
131607: NOT
131608: AND
131609: IFFALSE 131755
// begin attacking := false ;
131611: LD_ADDR_VAR 0 29
131615: PUSH
131616: LD_INT 0
131618: ST_TO_ADDR
// k := 5 ;
131619: LD_ADDR_VAR 0 9
131623: PUSH
131624: LD_INT 5
131626: ST_TO_ADDR
// if tmp < k then
131627: LD_VAR 0 14
131631: PUSH
131632: LD_VAR 0 9
131636: LESS
131637: IFFALSE 131649
// k := tmp ;
131639: LD_ADDR_VAR 0 9
131643: PUSH
131644: LD_VAR 0 14
131648: ST_TO_ADDR
// for j = 1 to k do
131649: LD_ADDR_VAR 0 8
131653: PUSH
131654: DOUBLE
131655: LD_INT 1
131657: DEC
131658: ST_TO_ADDR
131659: LD_VAR 0 9
131663: PUSH
131664: FOR_TO
131665: IFFALSE 131753
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131667: LD_VAR 0 14
131671: PUSH
131672: LD_VAR 0 8
131676: ARRAY
131677: PUSH
131678: LD_VAR 0 14
131682: PPUSH
131683: LD_INT 58
131685: PUSH
131686: EMPTY
131687: LIST
131688: PPUSH
131689: CALL_OW 72
131693: IN
131694: NOT
131695: IFFALSE 131751
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131697: LD_VAR 0 4
131701: PUSH
131702: LD_VAR 0 7
131706: ARRAY
131707: PPUSH
131708: LD_VAR 0 14
131712: PUSH
131713: LD_VAR 0 8
131717: ARRAY
131718: PPUSH
131719: CALL_OW 115
// attacking := true ;
131723: LD_ADDR_VAR 0 29
131727: PUSH
131728: LD_INT 1
131730: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131731: LD_VAR 0 4
131735: PUSH
131736: LD_VAR 0 7
131740: ARRAY
131741: PPUSH
131742: LD_INT 71
131744: PPUSH
131745: CALL_OW 109
// continue ;
131749: GO 131664
// end ; end ;
131751: GO 131664
131753: POP
131754: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131755: LD_VAR 0 4
131759: PUSH
131760: LD_VAR 0 7
131764: ARRAY
131765: PPUSH
131766: CALL_OW 257
131770: PUSH
131771: LD_INT 8
131773: EQUAL
131774: PUSH
131775: LD_VAR 0 4
131779: PUSH
131780: LD_VAR 0 7
131784: ARRAY
131785: PPUSH
131786: CALL_OW 264
131790: PUSH
131791: LD_INT 28
131793: PUSH
131794: LD_INT 45
131796: PUSH
131797: LD_INT 7
131799: PUSH
131800: LD_INT 47
131802: PUSH
131803: EMPTY
131804: LIST
131805: LIST
131806: LIST
131807: LIST
131808: IN
131809: OR
131810: IFFALSE 132066
// begin attacking := false ;
131812: LD_ADDR_VAR 0 29
131816: PUSH
131817: LD_INT 0
131819: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
131820: LD_VAR 0 14
131824: PUSH
131825: LD_INT 1
131827: ARRAY
131828: PPUSH
131829: CALL_OW 266
131833: PUSH
131834: LD_INT 32
131836: PUSH
131837: LD_INT 31
131839: PUSH
131840: LD_INT 33
131842: PUSH
131843: LD_INT 4
131845: PUSH
131846: LD_INT 5
131848: PUSH
131849: EMPTY
131850: LIST
131851: LIST
131852: LIST
131853: LIST
131854: LIST
131855: IN
131856: IFFALSE 132042
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
131858: LD_ADDR_VAR 0 9
131862: PUSH
131863: LD_VAR 0 14
131867: PUSH
131868: LD_INT 1
131870: ARRAY
131871: PPUSH
131872: CALL_OW 266
131876: PPUSH
131877: LD_VAR 0 14
131881: PUSH
131882: LD_INT 1
131884: ARRAY
131885: PPUSH
131886: CALL_OW 250
131890: PPUSH
131891: LD_VAR 0 14
131895: PUSH
131896: LD_INT 1
131898: ARRAY
131899: PPUSH
131900: CALL_OW 251
131904: PPUSH
131905: LD_VAR 0 14
131909: PUSH
131910: LD_INT 1
131912: ARRAY
131913: PPUSH
131914: CALL_OW 254
131918: PPUSH
131919: LD_VAR 0 14
131923: PUSH
131924: LD_INT 1
131926: ARRAY
131927: PPUSH
131928: CALL_OW 248
131932: PPUSH
131933: LD_INT 0
131935: PPUSH
131936: CALL 81622 0 6
131940: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
131941: LD_ADDR_VAR 0 8
131945: PUSH
131946: LD_VAR 0 4
131950: PUSH
131951: LD_VAR 0 7
131955: ARRAY
131956: PPUSH
131957: LD_VAR 0 9
131961: PPUSH
131962: CALL 100365 0 2
131966: ST_TO_ADDR
// if j then
131967: LD_VAR 0 8
131971: IFFALSE 132040
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
131973: LD_VAR 0 8
131977: PUSH
131978: LD_INT 1
131980: ARRAY
131981: PPUSH
131982: LD_VAR 0 8
131986: PUSH
131987: LD_INT 2
131989: ARRAY
131990: PPUSH
131991: CALL_OW 488
131995: IFFALSE 132040
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
131997: LD_VAR 0 4
132001: PUSH
132002: LD_VAR 0 7
132006: ARRAY
132007: PPUSH
132008: LD_VAR 0 8
132012: PUSH
132013: LD_INT 1
132015: ARRAY
132016: PPUSH
132017: LD_VAR 0 8
132021: PUSH
132022: LD_INT 2
132024: ARRAY
132025: PPUSH
132026: CALL_OW 116
// attacking := true ;
132030: LD_ADDR_VAR 0 29
132034: PUSH
132035: LD_INT 1
132037: ST_TO_ADDR
// continue ;
132038: GO 129413
// end ; end else
132040: GO 132066
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132042: LD_VAR 0 4
132046: PUSH
132047: LD_VAR 0 7
132051: ARRAY
132052: PPUSH
132053: LD_VAR 0 14
132057: PUSH
132058: LD_INT 1
132060: ARRAY
132061: PPUSH
132062: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
132066: LD_VAR 0 4
132070: PUSH
132071: LD_VAR 0 7
132075: ARRAY
132076: PPUSH
132077: CALL_OW 265
132081: PUSH
132082: LD_INT 11
132084: EQUAL
132085: IFFALSE 132363
// begin k := 10 ;
132087: LD_ADDR_VAR 0 9
132091: PUSH
132092: LD_INT 10
132094: ST_TO_ADDR
// x := 0 ;
132095: LD_ADDR_VAR 0 10
132099: PUSH
132100: LD_INT 0
132102: ST_TO_ADDR
// if tmp < k then
132103: LD_VAR 0 14
132107: PUSH
132108: LD_VAR 0 9
132112: LESS
132113: IFFALSE 132125
// k := tmp ;
132115: LD_ADDR_VAR 0 9
132119: PUSH
132120: LD_VAR 0 14
132124: ST_TO_ADDR
// for j = k downto 1 do
132125: LD_ADDR_VAR 0 8
132129: PUSH
132130: DOUBLE
132131: LD_VAR 0 9
132135: INC
132136: ST_TO_ADDR
132137: LD_INT 1
132139: PUSH
132140: FOR_DOWNTO
132141: IFFALSE 132216
// begin if GetType ( tmp [ j ] ) = unit_human then
132143: LD_VAR 0 14
132147: PUSH
132148: LD_VAR 0 8
132152: ARRAY
132153: PPUSH
132154: CALL_OW 247
132158: PUSH
132159: LD_INT 1
132161: EQUAL
132162: IFFALSE 132214
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
132164: LD_VAR 0 4
132168: PUSH
132169: LD_VAR 0 7
132173: ARRAY
132174: PPUSH
132175: LD_VAR 0 14
132179: PUSH
132180: LD_VAR 0 8
132184: ARRAY
132185: PPUSH
132186: CALL 100619 0 2
// x := tmp [ j ] ;
132190: LD_ADDR_VAR 0 10
132194: PUSH
132195: LD_VAR 0 14
132199: PUSH
132200: LD_VAR 0 8
132204: ARRAY
132205: ST_TO_ADDR
// attacking := true ;
132206: LD_ADDR_VAR 0 29
132210: PUSH
132211: LD_INT 1
132213: ST_TO_ADDR
// end ; end ;
132214: GO 132140
132216: POP
132217: POP
// if not x then
132218: LD_VAR 0 10
132222: NOT
132223: IFFALSE 132363
// begin attacking := true ;
132225: LD_ADDR_VAR 0 29
132229: PUSH
132230: LD_INT 1
132232: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
132233: LD_VAR 0 4
132237: PUSH
132238: LD_VAR 0 7
132242: ARRAY
132243: PPUSH
132244: CALL_OW 250
132248: PPUSH
132249: LD_VAR 0 4
132253: PUSH
132254: LD_VAR 0 7
132258: ARRAY
132259: PPUSH
132260: CALL_OW 251
132264: PPUSH
132265: CALL_OW 546
132269: PUSH
132270: LD_INT 2
132272: ARRAY
132273: PUSH
132274: LD_VAR 0 14
132278: PUSH
132279: LD_INT 1
132281: ARRAY
132282: PPUSH
132283: CALL_OW 250
132287: PPUSH
132288: LD_VAR 0 14
132292: PUSH
132293: LD_INT 1
132295: ARRAY
132296: PPUSH
132297: CALL_OW 251
132301: PPUSH
132302: CALL_OW 546
132306: PUSH
132307: LD_INT 2
132309: ARRAY
132310: EQUAL
132311: IFFALSE 132339
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
132313: LD_VAR 0 4
132317: PUSH
132318: LD_VAR 0 7
132322: ARRAY
132323: PPUSH
132324: LD_VAR 0 14
132328: PUSH
132329: LD_INT 1
132331: ARRAY
132332: PPUSH
132333: CALL 100619 0 2
132337: GO 132363
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132339: LD_VAR 0 4
132343: PUSH
132344: LD_VAR 0 7
132348: ARRAY
132349: PPUSH
132350: LD_VAR 0 14
132354: PUSH
132355: LD_INT 1
132357: ARRAY
132358: PPUSH
132359: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
132363: LD_VAR 0 4
132367: PUSH
132368: LD_VAR 0 7
132372: ARRAY
132373: PPUSH
132374: CALL_OW 264
132378: PUSH
132379: LD_INT 29
132381: EQUAL
132382: IFFALSE 132748
// begin if WantsToAttack ( group [ i ] ) in bombed then
132384: LD_VAR 0 4
132388: PUSH
132389: LD_VAR 0 7
132393: ARRAY
132394: PPUSH
132395: CALL_OW 319
132399: PUSH
132400: LD_VAR 0 28
132404: IN
132405: IFFALSE 132409
// continue ;
132407: GO 129413
// k := 8 ;
132409: LD_ADDR_VAR 0 9
132413: PUSH
132414: LD_INT 8
132416: ST_TO_ADDR
// x := 0 ;
132417: LD_ADDR_VAR 0 10
132421: PUSH
132422: LD_INT 0
132424: ST_TO_ADDR
// if tmp < k then
132425: LD_VAR 0 14
132429: PUSH
132430: LD_VAR 0 9
132434: LESS
132435: IFFALSE 132447
// k := tmp ;
132437: LD_ADDR_VAR 0 9
132441: PUSH
132442: LD_VAR 0 14
132446: ST_TO_ADDR
// for j = 1 to k do
132447: LD_ADDR_VAR 0 8
132451: PUSH
132452: DOUBLE
132453: LD_INT 1
132455: DEC
132456: ST_TO_ADDR
132457: LD_VAR 0 9
132461: PUSH
132462: FOR_TO
132463: IFFALSE 132595
// begin if GetType ( tmp [ j ] ) = unit_building then
132465: LD_VAR 0 14
132469: PUSH
132470: LD_VAR 0 8
132474: ARRAY
132475: PPUSH
132476: CALL_OW 247
132480: PUSH
132481: LD_INT 3
132483: EQUAL
132484: IFFALSE 132593
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132486: LD_VAR 0 14
132490: PUSH
132491: LD_VAR 0 8
132495: ARRAY
132496: PUSH
132497: LD_VAR 0 28
132501: IN
132502: NOT
132503: PUSH
132504: LD_VAR 0 14
132508: PUSH
132509: LD_VAR 0 8
132513: ARRAY
132514: PPUSH
132515: CALL_OW 313
132519: AND
132520: IFFALSE 132593
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132522: LD_VAR 0 4
132526: PUSH
132527: LD_VAR 0 7
132531: ARRAY
132532: PPUSH
132533: LD_VAR 0 14
132537: PUSH
132538: LD_VAR 0 8
132542: ARRAY
132543: PPUSH
132544: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132548: LD_ADDR_VAR 0 28
132552: PUSH
132553: LD_VAR 0 28
132557: PPUSH
132558: LD_VAR 0 28
132562: PUSH
132563: LD_INT 1
132565: PLUS
132566: PPUSH
132567: LD_VAR 0 14
132571: PUSH
132572: LD_VAR 0 8
132576: ARRAY
132577: PPUSH
132578: CALL_OW 1
132582: ST_TO_ADDR
// attacking := true ;
132583: LD_ADDR_VAR 0 29
132587: PUSH
132588: LD_INT 1
132590: ST_TO_ADDR
// break ;
132591: GO 132595
// end ; end ;
132593: GO 132462
132595: POP
132596: POP
// if not attacking and f_attack_depot then
132597: LD_VAR 0 29
132601: NOT
132602: PUSH
132603: LD_VAR 0 25
132607: AND
132608: IFFALSE 132703
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132610: LD_ADDR_VAR 0 13
132614: PUSH
132615: LD_VAR 0 14
132619: PPUSH
132620: LD_INT 2
132622: PUSH
132623: LD_INT 30
132625: PUSH
132626: LD_INT 0
132628: PUSH
132629: EMPTY
132630: LIST
132631: LIST
132632: PUSH
132633: LD_INT 30
132635: PUSH
132636: LD_INT 1
132638: PUSH
132639: EMPTY
132640: LIST
132641: LIST
132642: PUSH
132643: EMPTY
132644: LIST
132645: LIST
132646: LIST
132647: PPUSH
132648: CALL_OW 72
132652: ST_TO_ADDR
// if z then
132653: LD_VAR 0 13
132657: IFFALSE 132703
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132659: LD_VAR 0 4
132663: PUSH
132664: LD_VAR 0 7
132668: ARRAY
132669: PPUSH
132670: LD_VAR 0 13
132674: PPUSH
132675: LD_VAR 0 4
132679: PUSH
132680: LD_VAR 0 7
132684: ARRAY
132685: PPUSH
132686: CALL_OW 74
132690: PPUSH
132691: CALL_OW 115
// attacking := true ;
132695: LD_ADDR_VAR 0 29
132699: PUSH
132700: LD_INT 1
132702: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132703: LD_VAR 0 4
132707: PUSH
132708: LD_VAR 0 7
132712: ARRAY
132713: PPUSH
132714: CALL_OW 256
132718: PUSH
132719: LD_INT 500
132721: LESS
132722: IFFALSE 132748
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132724: LD_VAR 0 4
132728: PUSH
132729: LD_VAR 0 7
132733: ARRAY
132734: PPUSH
132735: LD_VAR 0 14
132739: PUSH
132740: LD_INT 1
132742: ARRAY
132743: PPUSH
132744: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132748: LD_VAR 0 4
132752: PUSH
132753: LD_VAR 0 7
132757: ARRAY
132758: PPUSH
132759: CALL_OW 264
132763: PUSH
132764: LD_INT 49
132766: EQUAL
132767: IFFALSE 132888
// begin if not HasTask ( group [ i ] ) then
132769: LD_VAR 0 4
132773: PUSH
132774: LD_VAR 0 7
132778: ARRAY
132779: PPUSH
132780: CALL_OW 314
132784: NOT
132785: IFFALSE 132888
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132787: LD_ADDR_VAR 0 9
132791: PUSH
132792: LD_INT 81
132794: PUSH
132795: LD_VAR 0 4
132799: PUSH
132800: LD_VAR 0 7
132804: ARRAY
132805: PPUSH
132806: CALL_OW 255
132810: PUSH
132811: EMPTY
132812: LIST
132813: LIST
132814: PPUSH
132815: CALL_OW 69
132819: PPUSH
132820: LD_VAR 0 4
132824: PUSH
132825: LD_VAR 0 7
132829: ARRAY
132830: PPUSH
132831: CALL_OW 74
132835: ST_TO_ADDR
// if k then
132836: LD_VAR 0 9
132840: IFFALSE 132888
// if GetDistUnits ( group [ i ] , k ) > 10 then
132842: LD_VAR 0 4
132846: PUSH
132847: LD_VAR 0 7
132851: ARRAY
132852: PPUSH
132853: LD_VAR 0 9
132857: PPUSH
132858: CALL_OW 296
132862: PUSH
132863: LD_INT 10
132865: GREATER
132866: IFFALSE 132888
// ComMoveUnit ( group [ i ] , k ) ;
132868: LD_VAR 0 4
132872: PUSH
132873: LD_VAR 0 7
132877: ARRAY
132878: PPUSH
132879: LD_VAR 0 9
132883: PPUSH
132884: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
132888: LD_VAR 0 4
132892: PUSH
132893: LD_VAR 0 7
132897: ARRAY
132898: PPUSH
132899: CALL_OW 256
132903: PUSH
132904: LD_INT 250
132906: LESS
132907: PUSH
132908: LD_VAR 0 4
132912: PUSH
132913: LD_VAR 0 7
132917: ARRAY
132918: PUSH
132919: LD_INT 21
132921: PUSH
132922: LD_INT 2
132924: PUSH
132925: EMPTY
132926: LIST
132927: LIST
132928: PUSH
132929: LD_INT 23
132931: PUSH
132932: LD_INT 2
132934: PUSH
132935: EMPTY
132936: LIST
132937: LIST
132938: PUSH
132939: EMPTY
132940: LIST
132941: LIST
132942: PPUSH
132943: CALL_OW 69
132947: IN
132948: AND
132949: IFFALSE 133074
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
132951: LD_ADDR_VAR 0 9
132955: PUSH
132956: LD_OWVAR 3
132960: PUSH
132961: LD_VAR 0 4
132965: PUSH
132966: LD_VAR 0 7
132970: ARRAY
132971: DIFF
132972: PPUSH
132973: LD_VAR 0 4
132977: PUSH
132978: LD_VAR 0 7
132982: ARRAY
132983: PPUSH
132984: CALL_OW 74
132988: ST_TO_ADDR
// if not k then
132989: LD_VAR 0 9
132993: NOT
132994: IFFALSE 132998
// continue ;
132996: GO 129413
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
132998: LD_VAR 0 9
133002: PUSH
133003: LD_INT 81
133005: PUSH
133006: LD_VAR 0 4
133010: PUSH
133011: LD_VAR 0 7
133015: ARRAY
133016: PPUSH
133017: CALL_OW 255
133021: PUSH
133022: EMPTY
133023: LIST
133024: LIST
133025: PPUSH
133026: CALL_OW 69
133030: IN
133031: PUSH
133032: LD_VAR 0 9
133036: PPUSH
133037: LD_VAR 0 4
133041: PUSH
133042: LD_VAR 0 7
133046: ARRAY
133047: PPUSH
133048: CALL_OW 296
133052: PUSH
133053: LD_INT 5
133055: LESS
133056: AND
133057: IFFALSE 133074
// ComAutodestruct ( group [ i ] ) ;
133059: LD_VAR 0 4
133063: PUSH
133064: LD_VAR 0 7
133068: ARRAY
133069: PPUSH
133070: CALL 100517 0 1
// end ; if f_attack_depot then
133074: LD_VAR 0 25
133078: IFFALSE 133190
// begin k := 6 ;
133080: LD_ADDR_VAR 0 9
133084: PUSH
133085: LD_INT 6
133087: ST_TO_ADDR
// if tmp < k then
133088: LD_VAR 0 14
133092: PUSH
133093: LD_VAR 0 9
133097: LESS
133098: IFFALSE 133110
// k := tmp ;
133100: LD_ADDR_VAR 0 9
133104: PUSH
133105: LD_VAR 0 14
133109: ST_TO_ADDR
// for j = 1 to k do
133110: LD_ADDR_VAR 0 8
133114: PUSH
133115: DOUBLE
133116: LD_INT 1
133118: DEC
133119: ST_TO_ADDR
133120: LD_VAR 0 9
133124: PUSH
133125: FOR_TO
133126: IFFALSE 133188
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
133128: LD_VAR 0 8
133132: PPUSH
133133: CALL_OW 266
133137: PUSH
133138: LD_INT 0
133140: PUSH
133141: LD_INT 1
133143: PUSH
133144: EMPTY
133145: LIST
133146: LIST
133147: IN
133148: IFFALSE 133186
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133150: LD_VAR 0 4
133154: PUSH
133155: LD_VAR 0 7
133159: ARRAY
133160: PPUSH
133161: LD_VAR 0 14
133165: PUSH
133166: LD_VAR 0 8
133170: ARRAY
133171: PPUSH
133172: CALL_OW 115
// attacking := true ;
133176: LD_ADDR_VAR 0 29
133180: PUSH
133181: LD_INT 1
133183: ST_TO_ADDR
// break ;
133184: GO 133188
// end ;
133186: GO 133125
133188: POP
133189: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
133190: LD_VAR 0 4
133194: PUSH
133195: LD_VAR 0 7
133199: ARRAY
133200: PPUSH
133201: CALL_OW 302
133205: PUSH
133206: LD_VAR 0 29
133210: NOT
133211: AND
133212: IFFALSE 133534
// begin if GetTag ( group [ i ] ) = 71 then
133214: LD_VAR 0 4
133218: PUSH
133219: LD_VAR 0 7
133223: ARRAY
133224: PPUSH
133225: CALL_OW 110
133229: PUSH
133230: LD_INT 71
133232: EQUAL
133233: IFFALSE 133274
// begin if HasTask ( group [ i ] ) then
133235: LD_VAR 0 4
133239: PUSH
133240: LD_VAR 0 7
133244: ARRAY
133245: PPUSH
133246: CALL_OW 314
133250: IFFALSE 133256
// continue else
133252: GO 129413
133254: GO 133274
// SetTag ( group [ i ] , 0 ) ;
133256: LD_VAR 0 4
133260: PUSH
133261: LD_VAR 0 7
133265: ARRAY
133266: PPUSH
133267: LD_INT 0
133269: PPUSH
133270: CALL_OW 109
// end ; k := 8 ;
133274: LD_ADDR_VAR 0 9
133278: PUSH
133279: LD_INT 8
133281: ST_TO_ADDR
// x := 0 ;
133282: LD_ADDR_VAR 0 10
133286: PUSH
133287: LD_INT 0
133289: ST_TO_ADDR
// if tmp < k then
133290: LD_VAR 0 14
133294: PUSH
133295: LD_VAR 0 9
133299: LESS
133300: IFFALSE 133312
// k := tmp ;
133302: LD_ADDR_VAR 0 9
133306: PUSH
133307: LD_VAR 0 14
133311: ST_TO_ADDR
// for j = 1 to k do
133312: LD_ADDR_VAR 0 8
133316: PUSH
133317: DOUBLE
133318: LD_INT 1
133320: DEC
133321: ST_TO_ADDR
133322: LD_VAR 0 9
133326: PUSH
133327: FOR_TO
133328: IFFALSE 133426
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
133330: LD_VAR 0 14
133334: PUSH
133335: LD_VAR 0 8
133339: ARRAY
133340: PPUSH
133341: CALL_OW 247
133345: PUSH
133346: LD_INT 1
133348: EQUAL
133349: PUSH
133350: LD_VAR 0 14
133354: PUSH
133355: LD_VAR 0 8
133359: ARRAY
133360: PPUSH
133361: CALL_OW 256
133365: PUSH
133366: LD_INT 250
133368: LESS
133369: PUSH
133370: LD_VAR 0 20
133374: AND
133375: PUSH
133376: LD_VAR 0 20
133380: NOT
133381: PUSH
133382: LD_VAR 0 14
133386: PUSH
133387: LD_VAR 0 8
133391: ARRAY
133392: PPUSH
133393: CALL_OW 256
133397: PUSH
133398: LD_INT 250
133400: GREATEREQUAL
133401: AND
133402: OR
133403: AND
133404: IFFALSE 133424
// begin x := tmp [ j ] ;
133406: LD_ADDR_VAR 0 10
133410: PUSH
133411: LD_VAR 0 14
133415: PUSH
133416: LD_VAR 0 8
133420: ARRAY
133421: ST_TO_ADDR
// break ;
133422: GO 133426
// end ;
133424: GO 133327
133426: POP
133427: POP
// if x then
133428: LD_VAR 0 10
133432: IFFALSE 133456
// ComAttackUnit ( group [ i ] , x ) else
133434: LD_VAR 0 4
133438: PUSH
133439: LD_VAR 0 7
133443: ARRAY
133444: PPUSH
133445: LD_VAR 0 10
133449: PPUSH
133450: CALL_OW 115
133454: GO 133480
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133456: LD_VAR 0 4
133460: PUSH
133461: LD_VAR 0 7
133465: ARRAY
133466: PPUSH
133467: LD_VAR 0 14
133471: PUSH
133472: LD_INT 1
133474: ARRAY
133475: PPUSH
133476: CALL_OW 115
// if not HasTask ( group [ i ] ) then
133480: LD_VAR 0 4
133484: PUSH
133485: LD_VAR 0 7
133489: ARRAY
133490: PPUSH
133491: CALL_OW 314
133495: NOT
133496: IFFALSE 133534
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133498: LD_VAR 0 4
133502: PUSH
133503: LD_VAR 0 7
133507: ARRAY
133508: PPUSH
133509: LD_VAR 0 14
133513: PPUSH
133514: LD_VAR 0 4
133518: PUSH
133519: LD_VAR 0 7
133523: ARRAY
133524: PPUSH
133525: CALL_OW 74
133529: PPUSH
133530: CALL_OW 115
// end ; end ; end ;
133534: GO 129413
133536: POP
133537: POP
// wait ( 0 0$2 ) ;
133538: LD_INT 70
133540: PPUSH
133541: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133545: LD_VAR 0 4
133549: NOT
133550: PUSH
133551: LD_VAR 0 4
133555: PUSH
133556: EMPTY
133557: EQUAL
133558: OR
133559: PUSH
133560: LD_INT 81
133562: PUSH
133563: LD_VAR 0 35
133567: PUSH
133568: EMPTY
133569: LIST
133570: LIST
133571: PPUSH
133572: CALL_OW 69
133576: NOT
133577: OR
133578: IFFALSE 129398
// end ;
133580: LD_VAR 0 2
133584: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133585: LD_INT 0
133587: PPUSH
133588: PPUSH
133589: PPUSH
133590: PPUSH
133591: PPUSH
133592: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133593: LD_VAR 0 1
133597: NOT
133598: PUSH
133599: LD_EXP 100
133603: PUSH
133604: LD_VAR 0 1
133608: ARRAY
133609: NOT
133610: OR
133611: PUSH
133612: LD_VAR 0 2
133616: NOT
133617: OR
133618: IFFALSE 133622
// exit ;
133620: GO 134176
// side := mc_sides [ base ] ;
133622: LD_ADDR_VAR 0 6
133626: PUSH
133627: LD_EXP 126
133631: PUSH
133632: LD_VAR 0 1
133636: ARRAY
133637: ST_TO_ADDR
// if not side then
133638: LD_VAR 0 6
133642: NOT
133643: IFFALSE 133647
// exit ;
133645: GO 134176
// for i in solds do
133647: LD_ADDR_VAR 0 7
133651: PUSH
133652: LD_VAR 0 2
133656: PUSH
133657: FOR_IN
133658: IFFALSE 133719
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133660: LD_VAR 0 7
133664: PPUSH
133665: CALL_OW 310
133669: PPUSH
133670: CALL_OW 266
133674: PUSH
133675: LD_INT 32
133677: PUSH
133678: LD_INT 31
133680: PUSH
133681: EMPTY
133682: LIST
133683: LIST
133684: IN
133685: IFFALSE 133705
// solds := solds diff i else
133687: LD_ADDR_VAR 0 2
133691: PUSH
133692: LD_VAR 0 2
133696: PUSH
133697: LD_VAR 0 7
133701: DIFF
133702: ST_TO_ADDR
133703: GO 133717
// SetTag ( i , 18 ) ;
133705: LD_VAR 0 7
133709: PPUSH
133710: LD_INT 18
133712: PPUSH
133713: CALL_OW 109
133717: GO 133657
133719: POP
133720: POP
// if not solds then
133721: LD_VAR 0 2
133725: NOT
133726: IFFALSE 133730
// exit ;
133728: GO 134176
// repeat wait ( 0 0$2 ) ;
133730: LD_INT 70
133732: PPUSH
133733: CALL_OW 67
// enemy := mc_scan [ base ] ;
133737: LD_ADDR_VAR 0 4
133741: PUSH
133742: LD_EXP 123
133746: PUSH
133747: LD_VAR 0 1
133751: ARRAY
133752: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133753: LD_EXP 100
133757: PUSH
133758: LD_VAR 0 1
133762: ARRAY
133763: NOT
133764: PUSH
133765: LD_EXP 100
133769: PUSH
133770: LD_VAR 0 1
133774: ARRAY
133775: PUSH
133776: EMPTY
133777: EQUAL
133778: OR
133779: IFFALSE 133816
// begin for i in solds do
133781: LD_ADDR_VAR 0 7
133785: PUSH
133786: LD_VAR 0 2
133790: PUSH
133791: FOR_IN
133792: IFFALSE 133805
// ComStop ( i ) ;
133794: LD_VAR 0 7
133798: PPUSH
133799: CALL_OW 141
133803: GO 133791
133805: POP
133806: POP
// solds := [ ] ;
133807: LD_ADDR_VAR 0 2
133811: PUSH
133812: EMPTY
133813: ST_TO_ADDR
// exit ;
133814: GO 134176
// end ; for i in solds do
133816: LD_ADDR_VAR 0 7
133820: PUSH
133821: LD_VAR 0 2
133825: PUSH
133826: FOR_IN
133827: IFFALSE 134148
// begin if IsInUnit ( i ) then
133829: LD_VAR 0 7
133833: PPUSH
133834: CALL_OW 310
133838: IFFALSE 133849
// ComExitBuilding ( i ) ;
133840: LD_VAR 0 7
133844: PPUSH
133845: CALL_OW 122
// if GetLives ( i ) > 500 then
133849: LD_VAR 0 7
133853: PPUSH
133854: CALL_OW 256
133858: PUSH
133859: LD_INT 500
133861: GREATER
133862: IFFALSE 133915
// begin e := NearestUnitToUnit ( enemy , i ) ;
133864: LD_ADDR_VAR 0 5
133868: PUSH
133869: LD_VAR 0 4
133873: PPUSH
133874: LD_VAR 0 7
133878: PPUSH
133879: CALL_OW 74
133883: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
133884: LD_VAR 0 7
133888: PPUSH
133889: LD_VAR 0 5
133893: PPUSH
133894: CALL_OW 250
133898: PPUSH
133899: LD_VAR 0 5
133903: PPUSH
133904: CALL_OW 251
133908: PPUSH
133909: CALL_OW 114
// end else
133913: GO 134146
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
133915: LD_VAR 0 7
133919: PPUSH
133920: LD_EXP 100
133924: PUSH
133925: LD_VAR 0 1
133929: ARRAY
133930: PPUSH
133931: LD_INT 2
133933: PUSH
133934: LD_INT 30
133936: PUSH
133937: LD_INT 0
133939: PUSH
133940: EMPTY
133941: LIST
133942: LIST
133943: PUSH
133944: LD_INT 30
133946: PUSH
133947: LD_INT 1
133949: PUSH
133950: EMPTY
133951: LIST
133952: LIST
133953: PUSH
133954: LD_INT 30
133956: PUSH
133957: LD_INT 6
133959: PUSH
133960: EMPTY
133961: LIST
133962: LIST
133963: PUSH
133964: EMPTY
133965: LIST
133966: LIST
133967: LIST
133968: LIST
133969: PPUSH
133970: CALL_OW 72
133974: PPUSH
133975: LD_VAR 0 7
133979: PPUSH
133980: CALL_OW 74
133984: PPUSH
133985: CALL_OW 296
133989: PUSH
133990: LD_INT 10
133992: GREATER
133993: IFFALSE 134146
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
133995: LD_ADDR_VAR 0 8
133999: PUSH
134000: LD_EXP 100
134004: PUSH
134005: LD_VAR 0 1
134009: ARRAY
134010: PPUSH
134011: LD_INT 2
134013: PUSH
134014: LD_INT 30
134016: PUSH
134017: LD_INT 0
134019: PUSH
134020: EMPTY
134021: LIST
134022: LIST
134023: PUSH
134024: LD_INT 30
134026: PUSH
134027: LD_INT 1
134029: PUSH
134030: EMPTY
134031: LIST
134032: LIST
134033: PUSH
134034: LD_INT 30
134036: PUSH
134037: LD_INT 6
134039: PUSH
134040: EMPTY
134041: LIST
134042: LIST
134043: PUSH
134044: EMPTY
134045: LIST
134046: LIST
134047: LIST
134048: LIST
134049: PPUSH
134050: CALL_OW 72
134054: PPUSH
134055: LD_VAR 0 7
134059: PPUSH
134060: CALL_OW 74
134064: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
134065: LD_VAR 0 7
134069: PPUSH
134070: LD_VAR 0 8
134074: PPUSH
134075: CALL_OW 250
134079: PPUSH
134080: LD_INT 3
134082: PPUSH
134083: LD_INT 5
134085: PPUSH
134086: CALL_OW 272
134090: PPUSH
134091: LD_VAR 0 8
134095: PPUSH
134096: CALL_OW 251
134100: PPUSH
134101: LD_INT 3
134103: PPUSH
134104: LD_INT 5
134106: PPUSH
134107: CALL_OW 273
134111: PPUSH
134112: CALL_OW 111
// SetTag ( i , 0 ) ;
134116: LD_VAR 0 7
134120: PPUSH
134121: LD_INT 0
134123: PPUSH
134124: CALL_OW 109
// solds := solds diff i ;
134128: LD_ADDR_VAR 0 2
134132: PUSH
134133: LD_VAR 0 2
134137: PUSH
134138: LD_VAR 0 7
134142: DIFF
134143: ST_TO_ADDR
// continue ;
134144: GO 133826
// end ; end ;
134146: GO 133826
134148: POP
134149: POP
// until not solds or not enemy ;
134150: LD_VAR 0 2
134154: NOT
134155: PUSH
134156: LD_VAR 0 4
134160: NOT
134161: OR
134162: IFFALSE 133730
// MC_Reset ( base , 18 ) ;
134164: LD_VAR 0 1
134168: PPUSH
134169: LD_INT 18
134171: PPUSH
134172: CALL 41033 0 2
// end ;
134176: LD_VAR 0 3
134180: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
134181: LD_INT 0
134183: PPUSH
134184: PPUSH
134185: PPUSH
134186: PPUSH
134187: PPUSH
134188: PPUSH
134189: PPUSH
134190: PPUSH
134191: PPUSH
134192: PPUSH
134193: PPUSH
134194: PPUSH
134195: PPUSH
134196: PPUSH
134197: PPUSH
134198: PPUSH
134199: PPUSH
134200: PPUSH
134201: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
134202: LD_ADDR_VAR 0 12
134206: PUSH
134207: LD_EXP 100
134211: PUSH
134212: LD_VAR 0 1
134216: ARRAY
134217: PPUSH
134218: LD_INT 25
134220: PUSH
134221: LD_INT 3
134223: PUSH
134224: EMPTY
134225: LIST
134226: LIST
134227: PPUSH
134228: CALL_OW 72
134232: ST_TO_ADDR
// if mc_remote_driver [ base ] then
134233: LD_EXP 140
134237: PUSH
134238: LD_VAR 0 1
134242: ARRAY
134243: IFFALSE 134267
// mechs := mechs diff mc_remote_driver [ base ] ;
134245: LD_ADDR_VAR 0 12
134249: PUSH
134250: LD_VAR 0 12
134254: PUSH
134255: LD_EXP 140
134259: PUSH
134260: LD_VAR 0 1
134264: ARRAY
134265: DIFF
134266: ST_TO_ADDR
// for i in mechs do
134267: LD_ADDR_VAR 0 4
134271: PUSH
134272: LD_VAR 0 12
134276: PUSH
134277: FOR_IN
134278: IFFALSE 134313
// if GetTag ( i ) > 0 then
134280: LD_VAR 0 4
134284: PPUSH
134285: CALL_OW 110
134289: PUSH
134290: LD_INT 0
134292: GREATER
134293: IFFALSE 134311
// mechs := mechs diff i ;
134295: LD_ADDR_VAR 0 12
134299: PUSH
134300: LD_VAR 0 12
134304: PUSH
134305: LD_VAR 0 4
134309: DIFF
134310: ST_TO_ADDR
134311: GO 134277
134313: POP
134314: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
134315: LD_ADDR_VAR 0 8
134319: PUSH
134320: LD_EXP 100
134324: PUSH
134325: LD_VAR 0 1
134329: ARRAY
134330: PPUSH
134331: LD_INT 2
134333: PUSH
134334: LD_INT 25
134336: PUSH
134337: LD_INT 1
134339: PUSH
134340: EMPTY
134341: LIST
134342: LIST
134343: PUSH
134344: LD_INT 25
134346: PUSH
134347: LD_INT 5
134349: PUSH
134350: EMPTY
134351: LIST
134352: LIST
134353: PUSH
134354: LD_INT 25
134356: PUSH
134357: LD_INT 8
134359: PUSH
134360: EMPTY
134361: LIST
134362: LIST
134363: PUSH
134364: LD_INT 25
134366: PUSH
134367: LD_INT 9
134369: PUSH
134370: EMPTY
134371: LIST
134372: LIST
134373: PUSH
134374: EMPTY
134375: LIST
134376: LIST
134377: LIST
134378: LIST
134379: LIST
134380: PPUSH
134381: CALL_OW 72
134385: ST_TO_ADDR
// if not defenders and not solds then
134386: LD_VAR 0 2
134390: NOT
134391: PUSH
134392: LD_VAR 0 8
134396: NOT
134397: AND
134398: IFFALSE 134402
// exit ;
134400: GO 136172
// depot_under_attack := false ;
134402: LD_ADDR_VAR 0 16
134406: PUSH
134407: LD_INT 0
134409: ST_TO_ADDR
// sold_defenders := [ ] ;
134410: LD_ADDR_VAR 0 17
134414: PUSH
134415: EMPTY
134416: ST_TO_ADDR
// if mechs then
134417: LD_VAR 0 12
134421: IFFALSE 134574
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
134423: LD_ADDR_VAR 0 4
134427: PUSH
134428: LD_VAR 0 2
134432: PPUSH
134433: LD_INT 21
134435: PUSH
134436: LD_INT 2
134438: PUSH
134439: EMPTY
134440: LIST
134441: LIST
134442: PPUSH
134443: CALL_OW 72
134447: PUSH
134448: FOR_IN
134449: IFFALSE 134572
// begin if GetTag ( i ) <> 20 then
134451: LD_VAR 0 4
134455: PPUSH
134456: CALL_OW 110
134460: PUSH
134461: LD_INT 20
134463: NONEQUAL
134464: IFFALSE 134478
// SetTag ( i , 20 ) ;
134466: LD_VAR 0 4
134470: PPUSH
134471: LD_INT 20
134473: PPUSH
134474: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
134478: LD_VAR 0 4
134482: PPUSH
134483: CALL_OW 263
134487: PUSH
134488: LD_INT 1
134490: EQUAL
134491: PUSH
134492: LD_VAR 0 4
134496: PPUSH
134497: CALL_OW 311
134501: NOT
134502: AND
134503: IFFALSE 134570
// begin un := mechs [ 1 ] ;
134505: LD_ADDR_VAR 0 10
134509: PUSH
134510: LD_VAR 0 12
134514: PUSH
134515: LD_INT 1
134517: ARRAY
134518: ST_TO_ADDR
// ComExit ( un ) ;
134519: LD_VAR 0 10
134523: PPUSH
134524: CALL 105383 0 1
// AddComEnterUnit ( un , i ) ;
134528: LD_VAR 0 10
134532: PPUSH
134533: LD_VAR 0 4
134537: PPUSH
134538: CALL_OW 180
// SetTag ( un , 19 ) ;
134542: LD_VAR 0 10
134546: PPUSH
134547: LD_INT 19
134549: PPUSH
134550: CALL_OW 109
// mechs := mechs diff un ;
134554: LD_ADDR_VAR 0 12
134558: PUSH
134559: LD_VAR 0 12
134563: PUSH
134564: LD_VAR 0 10
134568: DIFF
134569: ST_TO_ADDR
// end ; end ;
134570: GO 134448
134572: POP
134573: POP
// if solds then
134574: LD_VAR 0 8
134578: IFFALSE 134637
// for i in solds do
134580: LD_ADDR_VAR 0 4
134584: PUSH
134585: LD_VAR 0 8
134589: PUSH
134590: FOR_IN
134591: IFFALSE 134635
// if not GetTag ( i ) then
134593: LD_VAR 0 4
134597: PPUSH
134598: CALL_OW 110
134602: NOT
134603: IFFALSE 134633
// begin defenders := defenders union i ;
134605: LD_ADDR_VAR 0 2
134609: PUSH
134610: LD_VAR 0 2
134614: PUSH
134615: LD_VAR 0 4
134619: UNION
134620: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134621: LD_VAR 0 4
134625: PPUSH
134626: LD_INT 18
134628: PPUSH
134629: CALL_OW 109
// end ;
134633: GO 134590
134635: POP
134636: POP
// repeat wait ( 0 0$2 ) ;
134637: LD_INT 70
134639: PPUSH
134640: CALL_OW 67
// enemy := mc_scan [ base ] ;
134644: LD_ADDR_VAR 0 21
134648: PUSH
134649: LD_EXP 123
134653: PUSH
134654: LD_VAR 0 1
134658: ARRAY
134659: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134660: LD_EXP 100
134664: PUSH
134665: LD_VAR 0 1
134669: ARRAY
134670: NOT
134671: PUSH
134672: LD_EXP 100
134676: PUSH
134677: LD_VAR 0 1
134681: ARRAY
134682: PUSH
134683: EMPTY
134684: EQUAL
134685: OR
134686: IFFALSE 134723
// begin for i in defenders do
134688: LD_ADDR_VAR 0 4
134692: PUSH
134693: LD_VAR 0 2
134697: PUSH
134698: FOR_IN
134699: IFFALSE 134712
// ComStop ( i ) ;
134701: LD_VAR 0 4
134705: PPUSH
134706: CALL_OW 141
134710: GO 134698
134712: POP
134713: POP
// defenders := [ ] ;
134714: LD_ADDR_VAR 0 2
134718: PUSH
134719: EMPTY
134720: ST_TO_ADDR
// exit ;
134721: GO 136172
// end ; for i in defenders do
134723: LD_ADDR_VAR 0 4
134727: PUSH
134728: LD_VAR 0 2
134732: PUSH
134733: FOR_IN
134734: IFFALSE 135632
// begin e := NearestUnitToUnit ( enemy , i ) ;
134736: LD_ADDR_VAR 0 13
134740: PUSH
134741: LD_VAR 0 21
134745: PPUSH
134746: LD_VAR 0 4
134750: PPUSH
134751: CALL_OW 74
134755: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134756: LD_ADDR_VAR 0 7
134760: PUSH
134761: LD_EXP 100
134765: PUSH
134766: LD_VAR 0 1
134770: ARRAY
134771: PPUSH
134772: LD_INT 2
134774: PUSH
134775: LD_INT 30
134777: PUSH
134778: LD_INT 0
134780: PUSH
134781: EMPTY
134782: LIST
134783: LIST
134784: PUSH
134785: LD_INT 30
134787: PUSH
134788: LD_INT 1
134790: PUSH
134791: EMPTY
134792: LIST
134793: LIST
134794: PUSH
134795: EMPTY
134796: LIST
134797: LIST
134798: LIST
134799: PPUSH
134800: CALL_OW 72
134804: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
134805: LD_ADDR_VAR 0 16
134809: PUSH
134810: LD_VAR 0 7
134814: NOT
134815: PUSH
134816: LD_VAR 0 7
134820: PPUSH
134821: LD_INT 3
134823: PUSH
134824: LD_INT 24
134826: PUSH
134827: LD_INT 600
134829: PUSH
134830: EMPTY
134831: LIST
134832: LIST
134833: PUSH
134834: EMPTY
134835: LIST
134836: LIST
134837: PPUSH
134838: CALL_OW 72
134842: OR
134843: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
134844: LD_VAR 0 4
134848: PPUSH
134849: CALL_OW 247
134853: PUSH
134854: LD_INT 2
134856: DOUBLE
134857: EQUAL
134858: IFTRUE 134862
134860: GO 135258
134862: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
134863: LD_VAR 0 4
134867: PPUSH
134868: CALL_OW 256
134872: PUSH
134873: LD_INT 1000
134875: EQUAL
134876: PUSH
134877: LD_VAR 0 4
134881: PPUSH
134882: LD_VAR 0 13
134886: PPUSH
134887: CALL_OW 296
134891: PUSH
134892: LD_INT 40
134894: LESS
134895: PUSH
134896: LD_VAR 0 13
134900: PPUSH
134901: LD_EXP 125
134905: PUSH
134906: LD_VAR 0 1
134910: ARRAY
134911: PPUSH
134912: CALL_OW 308
134916: OR
134917: AND
134918: IFFALSE 135040
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
134920: LD_VAR 0 4
134924: PPUSH
134925: CALL_OW 262
134929: PUSH
134930: LD_INT 1
134932: EQUAL
134933: PUSH
134934: LD_VAR 0 4
134938: PPUSH
134939: CALL_OW 261
134943: PUSH
134944: LD_INT 30
134946: LESS
134947: AND
134948: PUSH
134949: LD_VAR 0 7
134953: AND
134954: IFFALSE 135024
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
134956: LD_VAR 0 4
134960: PPUSH
134961: LD_VAR 0 7
134965: PPUSH
134966: LD_VAR 0 4
134970: PPUSH
134971: CALL_OW 74
134975: PPUSH
134976: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
134980: LD_VAR 0 4
134984: PPUSH
134985: LD_VAR 0 7
134989: PPUSH
134990: LD_VAR 0 4
134994: PPUSH
134995: CALL_OW 74
134999: PPUSH
135000: CALL_OW 296
135004: PUSH
135005: LD_INT 6
135007: LESS
135008: IFFALSE 135022
// SetFuel ( i , 100 ) ;
135010: LD_VAR 0 4
135014: PPUSH
135015: LD_INT 100
135017: PPUSH
135018: CALL_OW 240
// end else
135022: GO 135038
// ComAttackUnit ( i , e ) ;
135024: LD_VAR 0 4
135028: PPUSH
135029: LD_VAR 0 13
135033: PPUSH
135034: CALL_OW 115
// end else
135038: GO 135141
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
135040: LD_VAR 0 13
135044: PPUSH
135045: LD_EXP 125
135049: PUSH
135050: LD_VAR 0 1
135054: ARRAY
135055: PPUSH
135056: CALL_OW 308
135060: NOT
135061: PUSH
135062: LD_VAR 0 4
135066: PPUSH
135067: LD_VAR 0 13
135071: PPUSH
135072: CALL_OW 296
135076: PUSH
135077: LD_INT 40
135079: GREATEREQUAL
135080: AND
135081: PUSH
135082: LD_VAR 0 4
135086: PPUSH
135087: CALL_OW 256
135091: PUSH
135092: LD_INT 650
135094: LESSEQUAL
135095: OR
135096: PUSH
135097: LD_VAR 0 4
135101: PPUSH
135102: LD_EXP 124
135106: PUSH
135107: LD_VAR 0 1
135111: ARRAY
135112: PPUSH
135113: CALL_OW 308
135117: NOT
135118: AND
135119: IFFALSE 135141
// ComMoveToArea ( i , mc_parking [ base ] ) ;
135121: LD_VAR 0 4
135125: PPUSH
135126: LD_EXP 124
135130: PUSH
135131: LD_VAR 0 1
135135: ARRAY
135136: PPUSH
135137: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
135141: LD_VAR 0 4
135145: PPUSH
135146: CALL_OW 256
135150: PUSH
135151: LD_INT 1000
135153: LESS
135154: PUSH
135155: LD_VAR 0 4
135159: PPUSH
135160: CALL_OW 263
135164: PUSH
135165: LD_INT 1
135167: EQUAL
135168: AND
135169: PUSH
135170: LD_VAR 0 4
135174: PPUSH
135175: CALL_OW 311
135179: AND
135180: PUSH
135181: LD_VAR 0 4
135185: PPUSH
135186: LD_EXP 124
135190: PUSH
135191: LD_VAR 0 1
135195: ARRAY
135196: PPUSH
135197: CALL_OW 308
135201: AND
135202: IFFALSE 135256
// begin mech := IsDrivenBy ( i ) ;
135204: LD_ADDR_VAR 0 9
135208: PUSH
135209: LD_VAR 0 4
135213: PPUSH
135214: CALL_OW 311
135218: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
135219: LD_VAR 0 9
135223: PPUSH
135224: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
135228: LD_VAR 0 9
135232: PPUSH
135233: LD_VAR 0 4
135237: PPUSH
135238: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
135242: LD_VAR 0 9
135246: PPUSH
135247: LD_VAR 0 4
135251: PPUSH
135252: CALL_OW 180
// end ; end ; unit_human :
135256: GO 135603
135258: LD_INT 1
135260: DOUBLE
135261: EQUAL
135262: IFTRUE 135266
135264: GO 135602
135266: POP
// begin b := IsInUnit ( i ) ;
135267: LD_ADDR_VAR 0 18
135271: PUSH
135272: LD_VAR 0 4
135276: PPUSH
135277: CALL_OW 310
135281: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
135282: LD_ADDR_VAR 0 19
135286: PUSH
135287: LD_VAR 0 18
135291: NOT
135292: PUSH
135293: LD_VAR 0 18
135297: PPUSH
135298: CALL_OW 266
135302: PUSH
135303: LD_INT 32
135305: PUSH
135306: LD_INT 31
135308: PUSH
135309: EMPTY
135310: LIST
135311: LIST
135312: IN
135313: OR
135314: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
135315: LD_VAR 0 18
135319: PPUSH
135320: CALL_OW 266
135324: PUSH
135325: LD_INT 5
135327: EQUAL
135328: PUSH
135329: LD_VAR 0 4
135333: PPUSH
135334: CALL_OW 257
135338: PUSH
135339: LD_INT 1
135341: PUSH
135342: LD_INT 2
135344: PUSH
135345: LD_INT 3
135347: PUSH
135348: LD_INT 4
135350: PUSH
135351: EMPTY
135352: LIST
135353: LIST
135354: LIST
135355: LIST
135356: IN
135357: AND
135358: IFFALSE 135395
// begin class := AllowSpecClass ( i ) ;
135360: LD_ADDR_VAR 0 20
135364: PUSH
135365: LD_VAR 0 4
135369: PPUSH
135370: CALL 69322 0 1
135374: ST_TO_ADDR
// if class then
135375: LD_VAR 0 20
135379: IFFALSE 135395
// ComChangeProfession ( i , class ) ;
135381: LD_VAR 0 4
135385: PPUSH
135386: LD_VAR 0 20
135390: PPUSH
135391: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
135395: LD_VAR 0 16
135399: PUSH
135400: LD_VAR 0 2
135404: PPUSH
135405: LD_INT 21
135407: PUSH
135408: LD_INT 2
135410: PUSH
135411: EMPTY
135412: LIST
135413: LIST
135414: PPUSH
135415: CALL_OW 72
135419: PUSH
135420: LD_INT 1
135422: LESSEQUAL
135423: OR
135424: PUSH
135425: LD_VAR 0 19
135429: AND
135430: PUSH
135431: LD_VAR 0 4
135435: PUSH
135436: LD_VAR 0 17
135440: IN
135441: NOT
135442: AND
135443: IFFALSE 135536
// begin if b then
135445: LD_VAR 0 18
135449: IFFALSE 135498
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135451: LD_VAR 0 18
135455: PPUSH
135456: LD_VAR 0 21
135460: PPUSH
135461: LD_VAR 0 18
135465: PPUSH
135466: CALL_OW 74
135470: PPUSH
135471: CALL_OW 296
135475: PUSH
135476: LD_INT 10
135478: LESS
135479: PUSH
135480: LD_VAR 0 18
135484: PPUSH
135485: CALL_OW 461
135489: PUSH
135490: LD_INT 7
135492: NONEQUAL
135493: AND
135494: IFFALSE 135498
// continue ;
135496: GO 134733
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135498: LD_ADDR_VAR 0 17
135502: PUSH
135503: LD_VAR 0 17
135507: PPUSH
135508: LD_VAR 0 17
135512: PUSH
135513: LD_INT 1
135515: PLUS
135516: PPUSH
135517: LD_VAR 0 4
135521: PPUSH
135522: CALL_OW 1
135526: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135527: LD_VAR 0 4
135531: PPUSH
135532: CALL_OW 122
// end ; if sold_defenders then
135536: LD_VAR 0 17
135540: IFFALSE 135600
// if i in sold_defenders then
135542: LD_VAR 0 4
135546: PUSH
135547: LD_VAR 0 17
135551: IN
135552: IFFALSE 135600
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135554: LD_VAR 0 4
135558: PPUSH
135559: CALL_OW 314
135563: NOT
135564: PUSH
135565: LD_VAR 0 4
135569: PPUSH
135570: LD_VAR 0 13
135574: PPUSH
135575: CALL_OW 296
135579: PUSH
135580: LD_INT 30
135582: LESS
135583: AND
135584: IFFALSE 135600
// ComAttackUnit ( i , e ) ;
135586: LD_VAR 0 4
135590: PPUSH
135591: LD_VAR 0 13
135595: PPUSH
135596: CALL_OW 115
// end ; end ; end ;
135600: GO 135603
135602: POP
// if IsDead ( i ) then
135603: LD_VAR 0 4
135607: PPUSH
135608: CALL_OW 301
135612: IFFALSE 135630
// defenders := defenders diff i ;
135614: LD_ADDR_VAR 0 2
135618: PUSH
135619: LD_VAR 0 2
135623: PUSH
135624: LD_VAR 0 4
135628: DIFF
135629: ST_TO_ADDR
// end ;
135630: GO 134733
135632: POP
135633: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135634: LD_VAR 0 21
135638: NOT
135639: PUSH
135640: LD_VAR 0 2
135644: NOT
135645: OR
135646: PUSH
135647: LD_EXP 100
135651: PUSH
135652: LD_VAR 0 1
135656: ARRAY
135657: NOT
135658: OR
135659: IFFALSE 134637
// MC_Reset ( base , 18 ) ;
135661: LD_VAR 0 1
135665: PPUSH
135666: LD_INT 18
135668: PPUSH
135669: CALL 41033 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135673: LD_ADDR_VAR 0 2
135677: PUSH
135678: LD_VAR 0 2
135682: PUSH
135683: LD_VAR 0 2
135687: PPUSH
135688: LD_INT 2
135690: PUSH
135691: LD_INT 25
135693: PUSH
135694: LD_INT 1
135696: PUSH
135697: EMPTY
135698: LIST
135699: LIST
135700: PUSH
135701: LD_INT 25
135703: PUSH
135704: LD_INT 5
135706: PUSH
135707: EMPTY
135708: LIST
135709: LIST
135710: PUSH
135711: LD_INT 25
135713: PUSH
135714: LD_INT 8
135716: PUSH
135717: EMPTY
135718: LIST
135719: LIST
135720: PUSH
135721: LD_INT 25
135723: PUSH
135724: LD_INT 9
135726: PUSH
135727: EMPTY
135728: LIST
135729: LIST
135730: PUSH
135731: EMPTY
135732: LIST
135733: LIST
135734: LIST
135735: LIST
135736: LIST
135737: PPUSH
135738: CALL_OW 72
135742: DIFF
135743: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135744: LD_VAR 0 21
135748: NOT
135749: PUSH
135750: LD_VAR 0 2
135754: PPUSH
135755: LD_INT 21
135757: PUSH
135758: LD_INT 2
135760: PUSH
135761: EMPTY
135762: LIST
135763: LIST
135764: PPUSH
135765: CALL_OW 72
135769: AND
135770: IFFALSE 136108
// begin tmp := FilterByTag ( defenders , 19 ) ;
135772: LD_ADDR_VAR 0 11
135776: PUSH
135777: LD_VAR 0 2
135781: PPUSH
135782: LD_INT 19
135784: PPUSH
135785: CALL 102559 0 2
135789: ST_TO_ADDR
// if tmp then
135790: LD_VAR 0 11
135794: IFFALSE 135864
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
135796: LD_ADDR_VAR 0 11
135800: PUSH
135801: LD_VAR 0 11
135805: PPUSH
135806: LD_INT 25
135808: PUSH
135809: LD_INT 3
135811: PUSH
135812: EMPTY
135813: LIST
135814: LIST
135815: PPUSH
135816: CALL_OW 72
135820: ST_TO_ADDR
// if tmp then
135821: LD_VAR 0 11
135825: IFFALSE 135864
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
135827: LD_ADDR_EXP 112
135831: PUSH
135832: LD_EXP 112
135836: PPUSH
135837: LD_VAR 0 1
135841: PPUSH
135842: LD_EXP 112
135846: PUSH
135847: LD_VAR 0 1
135851: ARRAY
135852: PUSH
135853: LD_VAR 0 11
135857: UNION
135858: PPUSH
135859: CALL_OW 1
135863: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
135864: LD_VAR 0 1
135868: PPUSH
135869: LD_INT 19
135871: PPUSH
135872: CALL 41033 0 2
// repeat wait ( 0 0$1 ) ;
135876: LD_INT 35
135878: PPUSH
135879: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135883: LD_EXP 100
135887: PUSH
135888: LD_VAR 0 1
135892: ARRAY
135893: NOT
135894: PUSH
135895: LD_EXP 100
135899: PUSH
135900: LD_VAR 0 1
135904: ARRAY
135905: PUSH
135906: EMPTY
135907: EQUAL
135908: OR
135909: IFFALSE 135946
// begin for i in defenders do
135911: LD_ADDR_VAR 0 4
135915: PUSH
135916: LD_VAR 0 2
135920: PUSH
135921: FOR_IN
135922: IFFALSE 135935
// ComStop ( i ) ;
135924: LD_VAR 0 4
135928: PPUSH
135929: CALL_OW 141
135933: GO 135921
135935: POP
135936: POP
// defenders := [ ] ;
135937: LD_ADDR_VAR 0 2
135941: PUSH
135942: EMPTY
135943: ST_TO_ADDR
// exit ;
135944: GO 136172
// end ; for i in defenders do
135946: LD_ADDR_VAR 0 4
135950: PUSH
135951: LD_VAR 0 2
135955: PUSH
135956: FOR_IN
135957: IFFALSE 136046
// begin if not IsInArea ( i , mc_parking [ base ] ) then
135959: LD_VAR 0 4
135963: PPUSH
135964: LD_EXP 124
135968: PUSH
135969: LD_VAR 0 1
135973: ARRAY
135974: PPUSH
135975: CALL_OW 308
135979: NOT
135980: IFFALSE 136004
// ComMoveToArea ( i , mc_parking [ base ] ) else
135982: LD_VAR 0 4
135986: PPUSH
135987: LD_EXP 124
135991: PUSH
135992: LD_VAR 0 1
135996: ARRAY
135997: PPUSH
135998: CALL_OW 113
136002: GO 136044
// if GetControl ( i ) = control_manual then
136004: LD_VAR 0 4
136008: PPUSH
136009: CALL_OW 263
136013: PUSH
136014: LD_INT 1
136016: EQUAL
136017: IFFALSE 136044
// if IsDrivenBy ( i ) then
136019: LD_VAR 0 4
136023: PPUSH
136024: CALL_OW 311
136028: IFFALSE 136044
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
136030: LD_VAR 0 4
136034: PPUSH
136035: CALL_OW 311
136039: PPUSH
136040: CALL_OW 121
// end ;
136044: GO 135956
136046: POP
136047: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
136048: LD_VAR 0 2
136052: PPUSH
136053: LD_INT 95
136055: PUSH
136056: LD_EXP 124
136060: PUSH
136061: LD_VAR 0 1
136065: ARRAY
136066: PUSH
136067: EMPTY
136068: LIST
136069: LIST
136070: PPUSH
136071: CALL_OW 72
136075: PUSH
136076: LD_VAR 0 2
136080: EQUAL
136081: PUSH
136082: LD_EXP 123
136086: PUSH
136087: LD_VAR 0 1
136091: ARRAY
136092: OR
136093: PUSH
136094: LD_EXP 100
136098: PUSH
136099: LD_VAR 0 1
136103: ARRAY
136104: NOT
136105: OR
136106: IFFALSE 135876
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
136108: LD_ADDR_EXP 122
136112: PUSH
136113: LD_EXP 122
136117: PPUSH
136118: LD_VAR 0 1
136122: PPUSH
136123: LD_VAR 0 2
136127: PPUSH
136128: LD_INT 21
136130: PUSH
136131: LD_INT 2
136133: PUSH
136134: EMPTY
136135: LIST
136136: LIST
136137: PPUSH
136138: CALL_OW 72
136142: PPUSH
136143: CALL_OW 1
136147: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
136148: LD_VAR 0 1
136152: PPUSH
136153: LD_INT 19
136155: PPUSH
136156: CALL 41033 0 2
// MC_Reset ( base , 20 ) ;
136160: LD_VAR 0 1
136164: PPUSH
136165: LD_INT 20
136167: PPUSH
136168: CALL 41033 0 2
// end ; end_of_file
136172: LD_VAR 0 3
136176: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
136177: LD_VAR 0 1
136181: PUSH
136182: LD_INT 200
136184: DOUBLE
136185: GREATEREQUAL
136186: IFFALSE 136194
136188: LD_INT 299
136190: DOUBLE
136191: LESSEQUAL
136192: IFTRUE 136196
136194: GO 136228
136196: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
136197: LD_VAR 0 1
136201: PPUSH
136202: LD_VAR 0 2
136206: PPUSH
136207: LD_VAR 0 3
136211: PPUSH
136212: LD_VAR 0 4
136216: PPUSH
136217: LD_VAR 0 5
136221: PPUSH
136222: CALL 124963 0 5
136226: GO 136305
136228: LD_INT 300
136230: DOUBLE
136231: GREATEREQUAL
136232: IFFALSE 136240
136234: LD_INT 399
136236: DOUBLE
136237: LESSEQUAL
136238: IFTRUE 136242
136240: GO 136304
136242: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
136243: LD_VAR 0 1
136247: PPUSH
136248: LD_VAR 0 2
136252: PPUSH
136253: LD_VAR 0 3
136257: PPUSH
136258: LD_VAR 0 4
136262: PPUSH
136263: LD_VAR 0 5
136267: PPUSH
136268: LD_VAR 0 6
136272: PPUSH
136273: LD_VAR 0 7
136277: PPUSH
136278: LD_VAR 0 8
136282: PPUSH
136283: LD_VAR 0 9
136287: PPUSH
136288: LD_VAR 0 10
136292: PPUSH
136293: LD_VAR 0 11
136297: PPUSH
136298: CALL 121296 0 11
136302: GO 136305
136304: POP
// end ;
136305: PPOPN 11
136307: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
136308: LD_VAR 0 1
136312: PPUSH
136313: LD_VAR 0 2
136317: PPUSH
136318: LD_VAR 0 3
136322: PPUSH
136323: LD_VAR 0 4
136327: PPUSH
136328: LD_VAR 0 5
136332: PPUSH
136333: CALL 124699 0 5
// end ; end_of_file
136337: PPOPN 5
136339: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
136340: LD_VAR 0 1
136344: PPUSH
136345: LD_VAR 0 2
136349: PPUSH
136350: LD_VAR 0 3
136354: PPUSH
136355: LD_VAR 0 4
136359: PPUSH
136360: LD_VAR 0 5
136364: PPUSH
136365: LD_VAR 0 6
136369: PPUSH
136370: CALL 108989 0 6
// end ;
136374: PPOPN 6
136376: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
136377: LD_INT 0
136379: PPUSH
// begin if not units then
136380: LD_VAR 0 1
136384: NOT
136385: IFFALSE 136389
// exit ;
136387: GO 136389
// end ;
136389: PPOPN 7
136391: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
136392: CALL 108960 0 0
// end ;
136396: PPOPN 1
136398: END
