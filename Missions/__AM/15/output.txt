// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 34975 0 0
// InitMacro ;
  19: CALL 35143 0 0
// InitNature ;
  23: CALL 34843 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11097 0 0
// PrepareRussian ;
  44: CALL 6981 0 0
// PrepareLegion ;
  48: CALL 4206 0 0
// PreparePowell ;
  52: CALL 2943 0 0
// PrepareAmerican ;
  56: CALL 1715 0 0
// Action ;
  60: CALL 14991 0 0
// MC_Start ( ) ;
  64: CALL 37308 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 140
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 141
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 59841 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 59934 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59284 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59099 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 59841 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 59934 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59099 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59284 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59714 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 15
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58781 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 59841 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 59934 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 145
 959: PUSH
 960: LD_EXP 145
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_EXP 101
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PPUSH
1085: CALL 59099 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 10
1094: PUSH
1095: LD_INT 12
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 59841 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 9
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 59934 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 26
1124: PUSH
1125: LD_INT 74
1127: PUSH
1128: LD_INT 107
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 32
1142: PUSH
1143: LD_INT 77
1145: PUSH
1146: LD_INT 101
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 32
1160: PUSH
1161: LD_INT 69
1163: PUSH
1164: LD_INT 86
1166: PUSH
1167: LD_INT 4
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 27
1178: PUSH
1179: LD_INT 77
1181: PUSH
1182: LD_INT 110
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 42
1199: PUSH
1200: LD_INT 79
1202: PUSH
1203: LD_INT 5
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 29
1214: PUSH
1215: LD_INT 86
1217: PUSH
1218: LD_INT 105
1220: PUSH
1221: LD_INT 2
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 30
1232: PUSH
1233: LD_INT 40
1235: PUSH
1236: LD_INT 75
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: LD_INT 80
1253: PUSH
1254: LD_INT 106
1256: PUSH
1257: LD_INT 4
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 32
1268: PUSH
1269: LD_INT 75
1271: PUSH
1272: LD_INT 114
1274: PUSH
1275: LD_INT 5
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PUSH
1284: LD_INT 32
1286: PUSH
1287: LD_INT 82
1289: PUSH
1290: LD_INT 110
1292: PUSH
1293: LD_INT 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: LD_INT 32
1304: PUSH
1305: LD_INT 62
1307: PUSH
1308: LD_INT 78
1310: PUSH
1311: LD_INT 4
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PUSH
1320: LD_INT 4
1322: PUSH
1323: LD_INT 39
1325: PUSH
1326: LD_INT 61
1328: PUSH
1329: LD_INT 3
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 58991 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 5
1361: PUSH
1362: LD_INT 6
1364: PUSH
1365: LD_INT 7
1367: PUSH
1368: LD_INT 9
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 60252 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 40
1386: PUSH
1387: LD_INT 75
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 86
1400: PUSH
1401: LD_INT 105
1403: PUSH
1404: LD_INT 0
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL 59423 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1420: LD_INT 4
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL 59714 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL 59714 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1440: LD_INT 4
1442: PPUSH
1443: LD_INT 54
1445: PPUSH
1446: LD_INT 85
1448: PPUSH
1449: LD_INT 2
1451: PPUSH
1452: LD_INT 19
1454: PUSH
1455: LD_INT 16
1457: PUSH
1458: LD_INT 17
1460: PUSH
1461: LD_INT 18
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL 60046 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1474: LD_INT 4
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 4
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 1
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 59099 0 2
// MC_SetTame ( 4 , powellApe ) ;
1559: LD_INT 4
1561: PPUSH
1562: LD_INT 13
1564: PPUSH
1565: CALL 59665 0 2
// end ;
1569: LD_VAR 0 1
1573: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1574: LD_EXP 36
1578: PUSH
1579: LD_EXP 17
1583: PUSH
1584: LD_INT 2
1586: GREATEREQUAL
1587: AND
1588: IFFALSE 1600
1590: GO 1592
1592: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1593: LD_STRING ACH_POWELL
1595: PPUSH
1596: CALL_OW 543
1600: END
// every 0 0$1 trigger debug do var i , tmp ;
1601: LD_EXP 1
1605: IFFALSE 1712
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
// begin enable ;
1614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: LD_INT 22
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 21
1635: PUSH
1636: LD_INT 3
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 24
1652: PUSH
1653: LD_INT 999
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PPUSH
1669: CALL_OW 69
1673: ST_TO_ADDR
// if not tmp then
1674: LD_VAR 0 2
1678: NOT
1679: IFFALSE 1683
// exit ;
1681: GO 1712
// for i in tmp do
1683: LD_ADDR_VAR 0 1
1687: PUSH
1688: LD_VAR 0 2
1692: PUSH
1693: FOR_IN
1694: IFFALSE 1710
// SetLives ( i , 1000 ) ;
1696: LD_VAR 0 1
1700: PPUSH
1701: LD_INT 1000
1703: PPUSH
1704: CALL_OW 234
1708: GO 1693
1710: POP
1711: POP
// end ; end_of_file
1712: PPOPN 2
1714: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1715: LD_INT 0
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1734: LD_ADDR_EXP 39
1738: PUSH
1739: LD_STRING JMM
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 14_
1750: PPUSH
1751: CALL 65553 0 3
1755: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1756: LD_EXP 4
1760: NOT
1761: PUSH
1762: LD_EXP 4
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: NOT
1775: OR
1776: IFFALSE 1799
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1778: LD_INT 5
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 9
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 70417 0 5
1797: GO 1858
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1799: LD_EXP 4
1803: PUSH
1804: LD_INT 1
1806: ARRAY
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PPUSH
1812: LD_EXP 4
1816: PUSH
1817: LD_INT 2
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_EXP 4
1829: PUSH
1830: LD_INT 3
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 4
1842: PUSH
1843: LD_INT 4
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL 70417 0 5
// JMMNewVeh := CreateVehicle ;
1858: LD_ADDR_EXP 56
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// if not JMMNewVeh then
1868: LD_EXP 56
1872: NOT
1873: IFFALSE 1904
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1875: LD_INT 5
1877: PPUSH
1878: LD_INT 3
1880: PPUSH
1881: LD_INT 1
1883: PPUSH
1884: LD_INT 9
1886: PPUSH
1887: LD_INT 100
1889: PPUSH
1890: CALL 70417 0 5
// JMMNewVeh := CreateVehicle ;
1894: LD_ADDR_EXP 56
1898: PUSH
1899: CALL_OW 45
1903: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1904: LD_EXP 56
1908: PPUSH
1909: LD_INT 4
1911: PPUSH
1912: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1916: LD_EXP 56
1920: PPUSH
1921: LD_INT 79
1923: PPUSH
1924: LD_INT 91
1926: PPUSH
1927: LD_INT 0
1929: PPUSH
1930: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1934: LD_EXP 39
1938: PPUSH
1939: LD_EXP 56
1943: PPUSH
1944: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1948: LD_EXP 6
1952: PUSH
1953: LD_EXP 2
1957: NOT
1958: AND
1959: IFFALSE 2217
// begin if not JMMGirlVeh then
1961: LD_EXP 5
1965: NOT
1966: IFFALSE 1989
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1968: LD_INT 3
1970: PPUSH
1971: LD_INT 3
1973: PPUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 9
1979: PPUSH
1980: LD_INT 100
1982: PPUSH
1983: CALL 70417 0 5
1987: GO 2048
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1989: LD_EXP 5
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PPUSH
2002: LD_EXP 5
2006: PUSH
2007: LD_INT 2
2009: ARRAY
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_EXP 5
2019: PUSH
2020: LD_INT 3
2022: ARRAY
2023: PUSH
2024: LD_INT 1
2026: ARRAY
2027: PPUSH
2028: LD_EXP 5
2032: PUSH
2033: LD_INT 4
2035: ARRAY
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: LD_INT 30
2043: PPUSH
2044: CALL 70417 0 5
// GirlNewVeh := CreateVehicle ;
2048: LD_ADDR_EXP 57
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2058: LD_EXP 57
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2070: LD_EXP 57
2074: PPUSH
2075: LD_INT 82
2077: PPUSH
2078: LD_INT 96
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 48
// if JMMGirl = 1 then
2088: LD_EXP 7
2092: PUSH
2093: LD_INT 1
2095: EQUAL
2096: IFFALSE 2131
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2098: LD_ADDR_EXP 40
2102: PUSH
2103: LD_STRING Joan
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_STRING 14_
2111: PPUSH
2112: CALL 65553 0 3
2116: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2117: LD_EXP 40
2121: PPUSH
2122: LD_EXP 57
2126: PPUSH
2127: CALL_OW 52
// end ; if JMMGirl = 2 then
2131: LD_EXP 7
2135: PUSH
2136: LD_INT 2
2138: EQUAL
2139: IFFALSE 2174
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2141: LD_ADDR_EXP 42
2145: PUSH
2146: LD_STRING Lisa
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_STRING 14_
2154: PPUSH
2155: CALL 65553 0 3
2159: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2160: LD_EXP 42
2164: PPUSH
2165: LD_EXP 57
2169: PPUSH
2170: CALL_OW 52
// end ; if JMMGirl = 3 then
2174: LD_EXP 7
2178: PUSH
2179: LD_INT 3
2181: EQUAL
2182: IFFALSE 2217
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2184: LD_ADDR_EXP 54
2188: PUSH
2189: LD_STRING Connie
2191: PPUSH
2192: LD_INT 1
2194: PPUSH
2195: LD_STRING 14_
2197: PPUSH
2198: CALL 65553 0 3
2202: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2203: LD_EXP 54
2207: PPUSH
2208: LD_EXP 57
2212: PPUSH
2213: CALL_OW 52
// end ; end ; end ;
2217: LD_VAR 0 1
2221: RET
// export function PrepareStevensSquad ; var tmp ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
// uc_side := 1 ;
2226: LD_ADDR_OWVAR 20
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// uc_nation := 1 ;
2234: LD_ADDR_OWVAR 21
2238: PUSH
2239: LD_INT 1
2241: ST_TO_ADDR
// tmp := [ ] ;
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: EMPTY
2248: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2249: LD_ADDR_EXP 41
2253: PUSH
2254: LD_STRING Stevens
2256: PPUSH
2257: LD_EXP 1
2261: NOT
2262: PPUSH
2263: LD_STRING 13f_
2265: PPUSH
2266: CALL 65553 0 3
2270: ST_TO_ADDR
// if not Stevens then
2271: LD_EXP 41
2275: NOT
2276: IFFALSE 2332
// begin hc_name = Baker Smith ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING Baker Smith
2285: ST_TO_ADDR
// hc_gallery =  ;
2286: LD_ADDR_OWVAR 33
2290: PUSH
2291: LD_STRING 
2293: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 10
2299: PPUSH
2300: CALL_OW 384
// Baker = CreateHuman ;
2304: LD_ADDR_EXP 55
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 55
2328: ADD
2329: ST_TO_ADDR
// end else
2330: GO 2348
// tmp := tmp ^ Stevens ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: LD_EXP 41
2346: ADD
2347: ST_TO_ADDR
// if not Lisa then
2348: LD_EXP 42
2352: NOT
2353: IFFALSE 2399
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2355: LD_ADDR_EXP 42
2359: PUSH
2360: LD_STRING Lisa
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_STRING 13f_
2371: PPUSH
2372: CALL 65553 0 3
2376: ST_TO_ADDR
// if Lisa then
2377: LD_EXP 42
2381: IFFALSE 2399
// tmp := tmp ^ Lisa ;
2383: LD_ADDR_VAR 0 2
2387: PUSH
2388: LD_VAR 0 2
2392: PUSH
2393: LD_EXP 42
2397: ADD
2398: ST_TO_ADDR
// end ; if not Donaldson then
2399: LD_EXP 43
2403: NOT
2404: IFFALSE 2450
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2406: LD_ADDR_EXP 43
2410: PUSH
2411: LD_STRING Donaldson
2413: PPUSH
2414: LD_EXP 1
2418: NOT
2419: PPUSH
2420: LD_STRING 13f_
2422: PPUSH
2423: CALL 65553 0 3
2427: ST_TO_ADDR
// if Donaldson then
2428: LD_EXP 43
2432: IFFALSE 2450
// tmp := tmp ^ Donaldson ;
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 2
2443: PUSH
2444: LD_EXP 43
2448: ADD
2449: ST_TO_ADDR
// end ; if not Bobby then
2450: LD_EXP 44
2454: NOT
2455: IFFALSE 2501
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2457: LD_ADDR_EXP 44
2461: PUSH
2462: LD_STRING Bobby
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13f_
2473: PPUSH
2474: CALL 65553 0 3
2478: ST_TO_ADDR
// if Bobby then
2479: LD_EXP 44
2483: IFFALSE 2501
// tmp := tmp ^ Bobby ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 44
2499: ADD
2500: ST_TO_ADDR
// end ; if not Cyrus then
2501: LD_EXP 45
2505: NOT
2506: IFFALSE 2552
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2508: LD_ADDR_EXP 45
2512: PUSH
2513: LD_STRING Cyrus
2515: PPUSH
2516: LD_EXP 1
2520: NOT
2521: PPUSH
2522: LD_STRING 13f_
2524: PPUSH
2525: CALL 65553 0 3
2529: ST_TO_ADDR
// if Cyrus then
2530: LD_EXP 45
2534: IFFALSE 2552
// tmp := tmp ^ Cyrus ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_EXP 45
2550: ADD
2551: ST_TO_ADDR
// end ; if not Brown then
2552: LD_EXP 47
2556: NOT
2557: IFFALSE 2603
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2559: LD_ADDR_EXP 47
2563: PUSH
2564: LD_STRING Brown
2566: PPUSH
2567: LD_EXP 1
2571: NOT
2572: PPUSH
2573: LD_STRING 13f_
2575: PPUSH
2576: CALL 65553 0 3
2580: ST_TO_ADDR
// if Brown then
2581: LD_EXP 47
2585: IFFALSE 2603
// tmp := tmp ^ Brown ;
2587: LD_ADDR_VAR 0 2
2591: PUSH
2592: LD_VAR 0 2
2596: PUSH
2597: LD_EXP 47
2601: ADD
2602: ST_TO_ADDR
// end ; if not Gladstone then
2603: LD_EXP 48
2607: NOT
2608: IFFALSE 2654
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2610: LD_ADDR_EXP 48
2614: PUSH
2615: LD_STRING Gladstone
2617: PPUSH
2618: LD_EXP 1
2622: NOT
2623: PPUSH
2624: LD_STRING 13f_
2626: PPUSH
2627: CALL 65553 0 3
2631: ST_TO_ADDR
// if Gladstone then
2632: LD_EXP 48
2636: IFFALSE 2654
// tmp := tmp ^ Gladstone ;
2638: LD_ADDR_VAR 0 2
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 48
2652: ADD
2653: ST_TO_ADDR
// end ; if not Houten then
2654: LD_EXP 49
2658: NOT
2659: IFFALSE 2705
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2661: LD_ADDR_EXP 49
2665: PUSH
2666: LD_STRING Houten
2668: PPUSH
2669: LD_EXP 1
2673: NOT
2674: PPUSH
2675: LD_STRING 13f_
2677: PPUSH
2678: CALL 65553 0 3
2682: ST_TO_ADDR
// if Houten then
2683: LD_EXP 49
2687: IFFALSE 2705
// tmp := tmp ^ Houten ;
2689: LD_ADDR_VAR 0 2
2693: PUSH
2694: LD_VAR 0 2
2698: PUSH
2699: LD_EXP 49
2703: ADD
2704: ST_TO_ADDR
// end ; if not Cornel then
2705: LD_EXP 50
2709: NOT
2710: IFFALSE 2756
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2712: LD_ADDR_EXP 50
2716: PUSH
2717: LD_STRING Cornell
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13f_
2728: PPUSH
2729: CALL 65553 0 3
2733: ST_TO_ADDR
// if Cornel then
2734: LD_EXP 50
2738: IFFALSE 2756
// tmp := tmp ^ Cornel ;
2740: LD_ADDR_VAR 0 2
2744: PUSH
2745: LD_VAR 0 2
2749: PUSH
2750: LD_EXP 50
2754: ADD
2755: ST_TO_ADDR
// end ; if not Gary then
2756: LD_EXP 51
2760: NOT
2761: IFFALSE 2807
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2763: LD_ADDR_EXP 51
2767: PUSH
2768: LD_STRING Gary
2770: PPUSH
2771: LD_EXP 1
2775: NOT
2776: PPUSH
2777: LD_STRING 13f_
2779: PPUSH
2780: CALL 65553 0 3
2784: ST_TO_ADDR
// if Gary then
2785: LD_EXP 51
2789: IFFALSE 2807
// tmp := tmp ^ Gary ;
2791: LD_ADDR_VAR 0 2
2795: PUSH
2796: LD_VAR 0 2
2800: PUSH
2801: LD_EXP 51
2805: ADD
2806: ST_TO_ADDR
// end ; if not Frank then
2807: LD_EXP 52
2811: NOT
2812: IFFALSE 2858
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2814: LD_ADDR_EXP 52
2818: PUSH
2819: LD_STRING Frank
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_STRING 13f_
2830: PPUSH
2831: CALL 65553 0 3
2835: ST_TO_ADDR
// if Frank then
2836: LD_EXP 52
2840: IFFALSE 2858
// tmp := tmp ^ Frank ;
2842: LD_ADDR_VAR 0 2
2846: PUSH
2847: LD_VAR 0 2
2851: PUSH
2852: LD_EXP 52
2856: ADD
2857: ST_TO_ADDR
// end ; if not Kikuchi then
2858: LD_EXP 53
2862: NOT
2863: IFFALSE 2909
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2865: LD_ADDR_EXP 53
2869: PUSH
2870: LD_STRING Kikuchi
2872: PPUSH
2873: LD_EXP 1
2877: NOT
2878: PPUSH
2879: LD_STRING 13f_
2881: PPUSH
2882: CALL 65553 0 3
2886: ST_TO_ADDR
// if Kikuchi then
2887: LD_EXP 53
2891: IFFALSE 2909
// tmp := tmp ^ Kikuchi ;
2893: LD_ADDR_VAR 0 2
2897: PUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_EXP 53
2907: ADD
2908: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_STRING 13_other_survivors
2921: PPUSH
2922: CALL_OW 31
2926: UNION
2927: ST_TO_ADDR
// result := tmp ;
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_VAR 0 2
2937: ST_TO_ADDR
// end ; end_of_file
2938: LD_VAR 0 1
2942: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2943: LD_INT 0
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
// uc_side := 4 ;
2955: LD_ADDR_OWVAR 20
2959: PUSH
2960: LD_INT 4
2962: ST_TO_ADDR
// uc_nation := 1 ;
2963: LD_ADDR_OWVAR 21
2967: PUSH
2968: LD_INT 1
2970: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2971: LD_INT 387
2973: PPUSH
2974: CALL_OW 274
2978: PPUSH
2979: LD_INT 1
2981: PPUSH
2982: LD_INT 3500
2984: PUSH
2985: LD_INT 3000
2987: PUSH
2988: LD_INT 2500
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_OWVAR 67
3000: ARRAY
3001: PPUSH
3002: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3006: LD_INT 387
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 2
3016: PPUSH
3017: LD_INT 400
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3024: LD_INT 387
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 3
3034: PPUSH
3035: LD_INT 10
3037: PPUSH
3038: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3042: LD_ADDR_EXP 58
3046: PUSH
3047: LD_STRING Powell
3049: PPUSH
3050: CALL_OW 25
3054: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3055: LD_EXP 58
3059: PPUSH
3060: LD_INT 57
3062: PPUSH
3063: LD_INT 94
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3073: LD_EXP 58
3077: PPUSH
3078: LD_INT 58
3080: PPUSH
3081: LD_INT 94
3083: PPUSH
3084: CALL_OW 118
// vip := [ ] ;
3088: LD_ADDR_EXP 59
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// tmp := [ ] ;
3095: LD_ADDR_VAR 0 6
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// if JMMGirl <> 2 then
3102: LD_EXP 7
3106: PUSH
3107: LD_INT 2
3109: NONEQUAL
3110: IFFALSE 3134
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3112: LD_ADDR_EXP 42
3116: PUSH
3117: LD_STRING Lisa
3119: PPUSH
3120: LD_EXP 1
3124: NOT
3125: PPUSH
3126: LD_STRING 13s_
3128: PPUSH
3129: CALL 65553 0 3
3133: ST_TO_ADDR
// if Lisa then
3134: LD_EXP 42
3138: IFFALSE 3156
// tmp := tmp ^ Lisa ;
3140: LD_ADDR_VAR 0 6
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: LD_EXP 42
3154: ADD
3155: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3156: LD_ADDR_EXP 43
3160: PUSH
3161: LD_STRING Donaldson
3163: PPUSH
3164: LD_EXP 1
3168: NOT
3169: PPUSH
3170: LD_STRING 13s_
3172: PPUSH
3173: CALL 65553 0 3
3177: ST_TO_ADDR
// if Donaldson then
3178: LD_EXP 43
3182: IFFALSE 3200
// tmp := tmp ^ Donaldson ;
3184: LD_ADDR_VAR 0 6
3188: PUSH
3189: LD_VAR 0 6
3193: PUSH
3194: LD_EXP 43
3198: ADD
3199: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3200: LD_ADDR_EXP 44
3204: PUSH
3205: LD_STRING Bobby
3207: PPUSH
3208: LD_EXP 1
3212: NOT
3213: PPUSH
3214: LD_STRING 13s_
3216: PPUSH
3217: CALL 65553 0 3
3221: ST_TO_ADDR
// if Bobby then
3222: LD_EXP 44
3226: IFFALSE 3244
// tmp := tmp ^ Bobby ;
3228: LD_ADDR_VAR 0 6
3232: PUSH
3233: LD_VAR 0 6
3237: PUSH
3238: LD_EXP 44
3242: ADD
3243: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3244: LD_ADDR_EXP 45
3248: PUSH
3249: LD_STRING Cyrus
3251: PPUSH
3252: LD_EXP 1
3256: NOT
3257: PPUSH
3258: LD_STRING 13s_
3260: PPUSH
3261: CALL 65553 0 3
3265: ST_TO_ADDR
// if Cyrus then
3266: LD_EXP 45
3270: IFFALSE 3288
// tmp := tmp ^ Cyrus ;
3272: LD_ADDR_VAR 0 6
3276: PUSH
3277: LD_VAR 0 6
3281: PUSH
3282: LD_EXP 45
3286: ADD
3287: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3288: LD_ADDR_EXP 46
3292: PUSH
3293: LD_STRING Denis
3295: PPUSH
3296: LD_EXP 1
3300: NOT
3301: PPUSH
3302: LD_STRING 13s_
3304: PPUSH
3305: CALL 65553 0 3
3309: ST_TO_ADDR
// if not Denis then
3310: LD_EXP 46
3314: NOT
3315: IFFALSE 3339
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3317: LD_ADDR_EXP 46
3321: PUSH
3322: LD_STRING Denis
3324: PPUSH
3325: LD_EXP 1
3329: NOT
3330: PPUSH
3331: LD_STRING 13f_
3333: PPUSH
3334: CALL 65553 0 3
3338: ST_TO_ADDR
// if Denis then
3339: LD_EXP 46
3343: IFFALSE 3361
// tmp := tmp ^ Denis ;
3345: LD_ADDR_VAR 0 6
3349: PUSH
3350: LD_VAR 0 6
3354: PUSH
3355: LD_EXP 46
3359: ADD
3360: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3361: LD_ADDR_EXP 47
3365: PUSH
3366: LD_STRING Brown
3368: PPUSH
3369: LD_EXP 1
3373: NOT
3374: PPUSH
3375: LD_STRING 13s_
3377: PPUSH
3378: CALL 65553 0 3
3382: ST_TO_ADDR
// if Brown then
3383: LD_EXP 47
3387: IFFALSE 3405
// tmp := tmp ^ Brown ;
3389: LD_ADDR_VAR 0 6
3393: PUSH
3394: LD_VAR 0 6
3398: PUSH
3399: LD_EXP 47
3403: ADD
3404: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3405: LD_ADDR_EXP 48
3409: PUSH
3410: LD_STRING Gladstone
3412: PPUSH
3413: LD_EXP 1
3417: NOT
3418: PPUSH
3419: LD_STRING 13s_
3421: PPUSH
3422: CALL 65553 0 3
3426: ST_TO_ADDR
// if Gladstone then
3427: LD_EXP 48
3431: IFFALSE 3449
// tmp := tmp ^ Gladstone ;
3433: LD_ADDR_VAR 0 6
3437: PUSH
3438: LD_VAR 0 6
3442: PUSH
3443: LD_EXP 48
3447: ADD
3448: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3449: LD_ADDR_EXP 49
3453: PUSH
3454: LD_STRING Houten
3456: PPUSH
3457: LD_EXP 1
3461: NOT
3462: PPUSH
3463: LD_STRING 13s_
3465: PPUSH
3466: CALL 65553 0 3
3470: ST_TO_ADDR
// if Houten then
3471: LD_EXP 49
3475: IFFALSE 3493
// tmp := tmp ^ Houten ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_VAR 0 6
3486: PUSH
3487: LD_EXP 49
3491: ADD
3492: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_STRING Cornel
3500: PPUSH
3501: LD_EXP 1
3505: NOT
3506: PPUSH
3507: LD_STRING 13s_
3509: PPUSH
3510: CALL 65553 0 3
3514: ST_TO_ADDR
// if Cornel then
3515: LD_EXP 50
3519: IFFALSE 3537
// tmp := tmp ^ Cornel ;
3521: LD_ADDR_VAR 0 6
3525: PUSH
3526: LD_VAR 0 6
3530: PUSH
3531: LD_EXP 50
3535: ADD
3536: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3537: LD_ADDR_EXP 51
3541: PUSH
3542: LD_STRING Gary
3544: PPUSH
3545: LD_EXP 1
3549: NOT
3550: PPUSH
3551: LD_STRING 13s_
3553: PPUSH
3554: CALL 65553 0 3
3558: ST_TO_ADDR
// if Gary then
3559: LD_EXP 51
3563: IFFALSE 3581
// tmp := tmp ^ Gary ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: LD_EXP 51
3579: ADD
3580: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3581: LD_ADDR_EXP 52
3585: PUSH
3586: LD_STRING Frank
3588: PPUSH
3589: LD_EXP 1
3593: NOT
3594: PPUSH
3595: LD_STRING 13s_
3597: PPUSH
3598: CALL 65553 0 3
3602: ST_TO_ADDR
// if Frank then
3603: LD_EXP 52
3607: IFFALSE 3625
// tmp := tmp ^ Frank ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_VAR 0 6
3618: PUSH
3619: LD_EXP 52
3623: ADD
3624: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3625: LD_ADDR_EXP 53
3629: PUSH
3630: LD_STRING Kikuchi
3632: PPUSH
3633: LD_EXP 1
3637: NOT
3638: PPUSH
3639: LD_STRING 13s_
3641: PPUSH
3642: CALL 65553 0 3
3646: ST_TO_ADDR
// if Kikuchi then
3647: LD_EXP 53
3651: IFFALSE 3669
// tmp := tmp ^ Kikuchi ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_VAR 0 6
3662: PUSH
3663: LD_EXP 53
3667: ADD
3668: ST_TO_ADDR
// vip := tmp ;
3669: LD_ADDR_EXP 59
3673: PUSH
3674: LD_VAR 0 6
3678: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_VAR 0 6
3688: PUSH
3689: LD_STRING 13s_others
3691: PPUSH
3692: CALL_OW 31
3696: UNION
3697: ST_TO_ADDR
// if tmp < 18 then
3698: LD_VAR 0 6
3702: PUSH
3703: LD_INT 18
3705: LESS
3706: IFFALSE 3773
// for i = 1 to 18 - tmp do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 18
3720: PUSH
3721: LD_VAR 0 6
3725: MINUS
3726: PUSH
3727: FOR_TO
3728: IFFALSE 3771
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PUSH
3738: LD_INT 4
3740: MOD
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_INT 5
3748: PPUSH
3749: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3753: LD_ADDR_VAR 0 6
3757: PUSH
3758: LD_VAR 0 6
3762: PUSH
3763: CALL_OW 44
3767: ADD
3768: ST_TO_ADDR
// end ;
3769: GO 3727
3771: POP
3772: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_INT 22
3780: PUSH
3781: LD_INT 4
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 30
3790: PUSH
3791: LD_INT 0
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 4
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 6
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3849: LD_ADDR_VAR 0 9
3853: PUSH
3854: LD_INT 22
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 4
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3887: LD_ADDR_VAR 0 10
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 4
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: ST_TO_ADDR
// for i in tmp do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: LD_VAR 0 6
3934: PUSH
3935: FOR_IN
3936: IFFALSE 4062
// begin cl := GetClass ( i ) ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 257
3952: ST_TO_ADDR
// if cl > 4 then
3953: LD_VAR 0 5
3957: PUSH
3958: LD_INT 4
3960: GREATER
3961: IFFALSE 3971
// cl := 1 ;
3963: LD_ADDR_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 9
3980: PUSH
3981: LD_VAR 0 7
3985: PUSH
3986: LD_VAR 0 10
3990: PUSH
3991: LD_VAR 0 8
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_VAR 0 5
4006: ARRAY
4007: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4008: LD_VAR 0 3
4012: PPUSH
4013: CALL_OW 313
4017: PUSH
4018: LD_INT 6
4020: LESS
4021: IFFALSE 4039
// PlaceHumanInUnit ( i , b ) else
4023: LD_VAR 0 2
4027: PPUSH
4028: LD_VAR 0 3
4032: PPUSH
4033: CALL_OW 52
4037: GO 4060
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4039: LD_VAR 0 2
4043: PPUSH
4044: LD_INT 61
4046: PPUSH
4047: LD_INT 89
4049: PPUSH
4050: LD_INT 6
4052: PPUSH
4053: LD_INT 0
4055: PPUSH
4056: CALL_OW 50
// end ;
4060: GO 3935
4062: POP
4063: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4064: LD_INT 2
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 12
4075: PPUSH
4076: LD_INT 100
4078: PPUSH
4079: CALL 70417 0 5
// veh := CreateVehicle ;
4083: LD_ADDR_VAR 0 4
4087: PUSH
4088: CALL_OW 45
4092: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4105: LD_VAR 0 4
4109: PPUSH
4110: LD_INT 49
4112: PPUSH
4113: LD_INT 88
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4123: LD_VAR 0 4
4127: PPUSH
4128: LD_INT 1
4130: PPUSH
4131: LD_INT 100
4133: PPUSH
4134: CALL_OW 290
// uc_side := 0 ;
4138: LD_ADDR_OWVAR 20
4142: PUSH
4143: LD_INT 0
4145: ST_TO_ADDR
// uc_nation := 0 ;
4146: LD_ADDR_OWVAR 21
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// for i = 1 to 4 do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_INT 4
4166: PUSH
4167: FOR_TO
4168: IFFALSE 4199
// begin InitHc ;
4170: CALL_OW 19
// hc_class := class_apeman ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 12
4181: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4182: CALL_OW 44
4186: PPUSH
4187: LD_INT 13
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 49
// end ;
4197: GO 4167
4199: POP
4200: POP
// end ; end_of_file
4201: LD_VAR 0 1
4205: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4206: LD_INT 0
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
// side := 8 ;
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: LD_INT 8
4220: ST_TO_ADDR
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 3
4230: ST_TO_ADDR
// uc_nation := 2 ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_INT 2
4238: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_VAR 0 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetBLevel ( i , 10 ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 10
4285: PPUSH
4286: CALL_OW 241
4290: GO 4275
4292: POP
4293: POP
// if KurtStatus then
4294: LD_EXP 3
4298: IFFALSE 4321
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4300: LD_ADDR_EXP 60
4304: PUSH
4305: LD_STRING Kurt
4307: PPUSH
4308: LD_INT 0
4310: PPUSH
4311: LD_STRING 
4313: PPUSH
4314: CALL 65553 0 3
4318: ST_TO_ADDR
4319: GO 4343
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4321: LD_ADDR_EXP 60
4325: PUSH
4326: LD_STRING AltKurt
4328: PPUSH
4329: LD_EXP 1
4333: NOT
4334: PPUSH
4335: LD_STRING 
4337: PPUSH
4338: CALL 65553 0 3
4342: ST_TO_ADDR
// if not Kurt then
4343: LD_EXP 60
4347: NOT
4348: IFFALSE 4374
// begin InitHc ;
4350: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 10
4359: PPUSH
4360: CALL_OW 381
// Kurt := CreateHuman ;
4364: LD_ADDR_EXP 60
4368: PUSH
4369: CALL_OW 44
4373: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4374: LD_EXP 60
4378: PPUSH
4379: LD_INT 324
4381: PPUSH
4382: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4386: LD_ADDR_EXP 61
4390: PUSH
4391: LD_STRING Kozlov
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: LD_STRING 
4399: PPUSH
4400: CALL 65553 0 3
4404: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4405: LD_EXP 61
4409: PPUSH
4410: LD_INT 22
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 23
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 30
4432: PUSH
4433: LD_INT 8
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4458: LD_EXP 61
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 10
4468: PPUSH
4469: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 4
4480: PPUSH
4481: LD_INT 10
4483: PPUSH
4484: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: LD_INT 22
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 30
4507: PUSH
4508: LD_INT 32
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 58
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 69
4530: ST_TO_ADDR
// for i = 1 to 10 do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: DOUBLE
4537: LD_INT 1
4539: DEC
4540: ST_TO_ADDR
4541: LD_INT 10
4543: PUSH
4544: FOR_TO
4545: IFFALSE 4617
// begin uc_nation := nation_nature ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 0
4554: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4555: LD_ADDR_OWVAR 28
4559: PUSH
4560: LD_INT 15
4562: ST_TO_ADDR
// hc_gallery :=  ;
4563: LD_ADDR_OWVAR 33
4567: PUSH
4568: LD_STRING 
4570: ST_TO_ADDR
// hc_name :=  ;
4571: LD_ADDR_OWVAR 26
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// un := CreateHuman ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: CALL_OW 44
4588: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_VAR 0 5
4598: PUSH
4599: LD_VAR 0 5
4603: PUSH
4604: LD_VAR 0 2
4608: MINUS
4609: ARRAY
4610: PPUSH
4611: CALL_OW 52
// end ;
4615: GO 4544
4617: POP
4618: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: LD_STRING 12_kurt_squad
4626: PPUSH
4627: CALL_OW 31
4631: ST_TO_ADDR
// if tmp then
4632: LD_VAR 0 5
4636: IFFALSE 4670
// for i in tmp do
4638: LD_ADDR_VAR 0 2
4642: PUSH
4643: LD_VAR 0 5
4647: PUSH
4648: FOR_IN
4649: IFFALSE 4668
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_INT 5
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 49
4666: GO 4648
4668: POP
4669: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4670: LD_INT 324
4672: PPUSH
4673: LD_INT 5
4675: PPUSH
4676: LD_STRING 
4678: PPUSH
4679: LD_INT 8
4681: PUSH
4682: LD_INT 9
4684: PUSH
4685: LD_INT 10
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 3000
4701: PUSH
4702: LD_INT 500
4704: PUSH
4705: LD_INT 150
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 16
4715: PUSH
4716: LD_INT 6
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 8
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 73864 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4735: LD_ADDR_EXP 116
4739: PUSH
4740: LD_EXP 116
4744: PPUSH
4745: LD_INT 3
4747: PPUSH
4748: LD_INT 22
4750: PUSH
4751: LD_VAR 0 3
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 23
4762: PUSH
4763: LD_INT 2
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 21
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL_OW 69
4796: PUSH
4797: LD_EXP 60
4801: DIFF
4802: PPUSH
4803: CALL_OW 1
4807: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 7
4813: PPUSH
4814: CALL_OW 383
// Friend := CreateHuman ;
4818: LD_ADDR_EXP 62
4822: PUSH
4823: CALL_OW 44
4827: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4828: LD_INT 14
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 29
4839: PPUSH
4840: LD_INT 100
4842: PPUSH
4843: CALL 70417 0 5
// powellBomb := CreateVehicle ;
4847: LD_ADDR_EXP 63
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4857: LD_EXP 63
4861: PPUSH
4862: LD_INT 90
4864: PPUSH
4865: LD_INT 51
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// end ;
4875: LD_VAR 0 1
4879: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// if IsLive ( kozlov_fac ) then
4885: LD_INT 332
4887: PPUSH
4888: CALL_OW 300
4892: IFFALSE 4896
// exit ;
4894: GO 5463
// ComExitBuilding ( Kozlov ) ;
4896: LD_EXP 61
4900: PPUSH
4901: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4905: LD_EXP 61
4909: PPUSH
4910: CALL_OW 257
4914: PUSH
4915: LD_INT 2
4917: NONEQUAL
4918: IFFALSE 4953
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4920: LD_EXP 61
4924: PPUSH
4925: LD_INT 324
4927: PPUSH
4928: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 2
4939: PPUSH
4940: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4944: LD_EXP 61
4948: PPUSH
4949: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4953: LD_EXP 61
4957: PPUSH
4958: LD_INT 2
4960: PPUSH
4961: LD_INT 93
4963: PPUSH
4964: LD_INT 32
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4981: LD_INT 22
4983: PUSH
4984: LD_INT 8
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: LD_INT 23
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 57
5013: PUSH
5014: EMPTY
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PPUSH
5023: CALL_OW 69
5027: IFFALSE 4974
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 8
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 3
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 23
5056: PUSH
5057: LD_INT 3
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 57
5066: PUSH
5067: EMPTY
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 69
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5085: LD_INT 22
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 23
5097: PUSH
5098: LD_INT 3
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 30
5107: PUSH
5108: LD_INT 21
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 5203
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5127: LD_EXP 61
5131: PPUSH
5132: LD_INT 21
5134: PPUSH
5135: LD_INT 97
5137: PPUSH
5138: LD_INT 36
5140: PPUSH
5141: LD_INT 5
5143: PPUSH
5144: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5148: LD_INT 35
5150: PPUSH
5151: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5155: LD_INT 22
5157: PUSH
5158: LD_INT 8
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: LD_INT 23
5167: PUSH
5168: LD_INT 3
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 30
5177: PUSH
5178: LD_INT 21
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 57
5187: PUSH
5188: EMPTY
5189: LIST
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: IFFALSE 5148
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5203: LD_INT 22
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 23
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 30
5225: PUSH
5226: LD_INT 18
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 69
5242: NOT
5243: IFFALSE 5321
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5245: LD_EXP 61
5249: PPUSH
5250: LD_INT 18
5252: PPUSH
5253: LD_INT 89
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 23
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 30
5295: PUSH
5296: LD_INT 18
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// end ; lab := kozlov_lab ;
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: LD_INT 336
5328: ST_TO_ADDR
// if not lab then
5329: LD_VAR 0 3
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5463
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5338: LD_EXP 61
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5356: LD_EXP 61
5360: PPUSH
5361: LD_INT 4
5363: PPUSH
5364: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: LD_INT 25
5379: PPUSH
5380: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5384: LD_INT 35
5386: PPUSH
5387: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5391: LD_INT 25
5393: PPUSH
5394: LD_INT 8
5396: PPUSH
5397: CALL_OW 321
5401: PUSH
5402: LD_INT 2
5404: EQUAL
5405: IFFALSE 5384
// ComExitBuilding ( Kozlov ) ;
5407: LD_EXP 61
5411: PPUSH
5412: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5416: LD_EXP 61
5420: PPUSH
5421: LD_VAR 0 2
5425: PPUSH
5426: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5430: LD_EXP 61
5434: PPUSH
5435: LD_INT 3
5437: PPUSH
5438: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_INT 23
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 1
5455: PPUSH
5456: LD_INT 48
5458: PPUSH
5459: CALL_OW 125
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5468: LD_EXP 22
5472: NOT
5473: PUSH
5474: LD_EXP 15
5478: PUSH
5479: LD_INT 6
5481: GREATEREQUAL
5482: AND
5483: IFFALSE 5564
5485: GO 5487
5487: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5488: LD_INT 3
5490: PPUSH
5491: LD_INT 3
5493: PPUSH
5494: CALL 59284 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5498: LD_INT 3
5500: PPUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 14
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 14
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 28
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL 59147 0 2
// end ;
5564: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5565: LD_EXP 22
5569: NOT
5570: PUSH
5571: LD_EXP 15
5575: PUSH
5576: LD_INT 6
5578: GREATEREQUAL
5579: AND
5580: PUSH
5581: LD_INT 3
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: CALL 60565 0 2
5591: NOT
5592: AND
5593: IFFALSE 6433
5595: GO 5597
5597: DISABLE
5598: LD_INT 0
5600: PPUSH
5601: PPUSH
5602: PPUSH
// begin enable ;
5603: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5604: LD_INT 22
5606: PUSH
5607: LD_INT 8
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 23
5616: PUSH
5617: LD_INT 2
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: NOT
5644: IFFALSE 5648
// exit ;
5646: GO 6433
// if Prob ( 40 ) then
5648: LD_INT 40
5650: PPUSH
5651: CALL_OW 13
5655: IFFALSE 5782
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5657: LD_INT 3
5659: PPUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 28
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 14
5734: PUSH
5735: LD_INT 1
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 28
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 14
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 26
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL 59147 0 2
// end else
5780: GO 5973
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5782: LD_INT 3
5784: PPUSH
5785: LD_INT 14
5787: PUSH
5788: LD_INT 1
5790: PUSH
5791: LD_INT 2
5793: PUSH
5794: LD_INT 27
5796: PUSH
5797: LD_INT 26
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 14
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: LD_INT 2
5828: PUSH
5829: LD_INT 27
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_OWVAR 67
5847: ARRAY
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 14
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 26
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: LD_OWVAR 67
5882: ARRAY
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 13
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: LD_INT 26
5901: PUSH
5902: LD_INT 29
5904: PUSH
5905: LD_INT 29
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: PUSH
5913: LD_OWVAR 67
5917: ARRAY
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 13
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 29
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 14
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 26
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PPUSH
5969: CALL 59147 0 2
// end ; repeat wait ( 0 0$1 ) ;
5973: LD_INT 35
5975: PPUSH
5976: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5980: LD_INT 3
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL 60565 0 2
5990: PUSH
5991: LD_INT 6
5993: GREATEREQUAL
5994: IFFALSE 5973
// wait ( 0 0$30 ) ;
5996: LD_INT 1050
5998: PPUSH
5999: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60565 0 2
6018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6019: LD_ADDR_EXP 135
6023: PUSH
6024: LD_EXP 135
6028: PPUSH
6029: LD_INT 3
6031: PPUSH
6032: LD_EXP 135
6036: PUSH
6037: LD_INT 3
6039: ARRAY
6040: PUSH
6041: LD_VAR 0 2
6045: DIFF
6046: PPUSH
6047: CALL_OW 1
6051: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6052: LD_ADDR_VAR 0 3
6056: PUSH
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 2
6062: PPUSH
6063: CALL_OW 12
6067: ST_TO_ADDR
// if target then
6068: LD_VAR 0 3
6072: IFFALSE 6200
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 24
6086: PUSH
6087: LD_INT 250
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL_OW 72
6098: ST_TO_ADDR
// for i in tmp do
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_VAR 0 2
6108: PUSH
6109: FOR_IN
6110: IFFALSE 6150
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6112: LD_VAR 0 1
6116: PPUSH
6117: LD_INT 89
6119: PPUSH
6120: LD_INT 71
6122: PPUSH
6123: CALL_OW 297
6127: PUSH
6128: LD_INT 9
6130: GREATER
6131: IFFALSE 6148
// ComMoveXY ( i , 89 , 71 ) ;
6133: LD_VAR 0 1
6137: PPUSH
6138: LD_INT 89
6140: PPUSH
6141: LD_INT 71
6143: PPUSH
6144: CALL_OW 111
6148: GO 6109
6150: POP
6151: POP
// wait ( 0 0$1 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 92
6166: PUSH
6167: LD_INT 89
6169: PUSH
6170: LD_INT 71
6172: PUSH
6173: LD_INT 9
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_VAR 0 2
6191: PUSH
6192: LD_INT 1
6194: MINUS
6195: GREATEREQUAL
6196: IFFALSE 6074
// end else
6198: GO 6324
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_INT 24
6212: PUSH
6213: LD_INT 250
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: ST_TO_ADDR
// for i in tmp do
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_VAR 0 2
6234: PUSH
6235: FOR_IN
6236: IFFALSE 6276
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6238: LD_VAR 0 1
6242: PPUSH
6243: LD_INT 125
6245: PPUSH
6246: LD_INT 129
6248: PPUSH
6249: CALL_OW 297
6253: PUSH
6254: LD_INT 9
6256: GREATER
6257: IFFALSE 6274
// ComMoveXY ( i , 125 , 129 ) ;
6259: LD_VAR 0 1
6263: PPUSH
6264: LD_INT 125
6266: PPUSH
6267: LD_INT 129
6269: PPUSH
6270: CALL_OW 111
6274: GO 6235
6276: POP
6277: POP
// wait ( 0 0$1 ) ;
6278: LD_INT 35
6280: PPUSH
6281: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 92
6292: PUSH
6293: LD_INT 125
6295: PUSH
6296: LD_INT 129
6298: PUSH
6299: LD_INT 9
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PPUSH
6308: CALL_OW 72
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_INT 1
6320: MINUS
6321: GREATEREQUAL
6322: IFFALSE 6200
// end ; repeat wait ( 0 0$1 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// for i in tmp do
6331: LD_ADDR_VAR 0 1
6335: PUSH
6336: LD_VAR 0 2
6340: PUSH
6341: FOR_IN
6342: IFFALSE 6424
// begin if GetLives ( i ) > 251 then
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 256
6353: PUSH
6354: LD_INT 251
6356: GREATER
6357: IFFALSE 6395
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6359: LD_VAR 0 1
6363: PPUSH
6364: LD_INT 81
6366: PUSH
6367: LD_INT 8
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PPUSH
6374: CALL_OW 69
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: PPUSH
6389: CALL_OW 115
6393: GO 6422
// if IsDead ( i ) then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 301
6404: IFFALSE 6422
// tmp := tmp diff i ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 2
6415: PUSH
6416: LD_VAR 0 1
6420: DIFF
6421: ST_TO_ADDR
// end ;
6422: GO 6341
6424: POP
6425: POP
// until not tmp ;
6426: LD_VAR 0 2
6430: NOT
6431: IFFALSE 6324
// end ;
6433: PPOPN 3
6435: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6436: LD_EXP 22
6440: NOT
6441: PUSH
6442: LD_EXP 15
6446: PUSH
6447: LD_INT 6
6449: GREATEREQUAL
6450: AND
6451: PUSH
6452: LD_OWVAR 67
6456: PUSH
6457: LD_INT 1
6459: GREATER
6460: AND
6461: IFFALSE 6978
6463: GO 6465
6465: DISABLE
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
// begin enable ;
6471: ENABLE
// tmp := [ ] ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6479: LD_ADDR_VAR 0 1
6483: PUSH
6484: DOUBLE
6485: LD_INT 1
6487: DEC
6488: ST_TO_ADDR
6489: LD_INT 4
6491: PUSH
6492: LD_INT 6
6494: PUSH
6495: LD_INT 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_OWVAR 67
6507: ARRAY
6508: PUSH
6509: FOR_TO
6510: IFFALSE 6670
// begin uc_side := 8 ;
6512: LD_ADDR_OWVAR 20
6516: PUSH
6517: LD_INT 8
6519: ST_TO_ADDR
// uc_nation := 2 ;
6520: LD_ADDR_OWVAR 21
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6528: LD_INT 13
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 1
6540: PPUSH
6541: LD_INT 2
6543: PPUSH
6544: CALL_OW 12
6548: ARRAY
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 27
6558: PUSH
6559: LD_INT 28
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 1
6576: PPUSH
6577: LD_INT 4
6579: PPUSH
6580: CALL_OW 12
6584: ARRAY
6585: PPUSH
6586: LD_INT 88
6588: PPUSH
6589: CALL 70417 0 5
// un := CreateVehicle ;
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: CALL_OW 45
6602: ST_TO_ADDR
// tmp := tmp ^ un ;
6603: LD_ADDR_VAR 0 3
6607: PUSH
6608: LD_VAR 0 3
6612: PUSH
6613: LD_VAR 0 2
6617: ADD
6618: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6619: LD_VAR 0 2
6623: PPUSH
6624: LD_INT 3
6626: PPUSH
6627: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_INT 30
6638: PPUSH
6639: LD_INT 0
6641: PPUSH
6642: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6646: LD_VAR 0 2
6650: PPUSH
6651: LD_INT 16
6653: PPUSH
6654: LD_INT 11
6656: PPUSH
6657: CALL_OW 111
// wait ( 0 0$2 ) ;
6661: LD_INT 70
6663: PPUSH
6664: CALL_OW 67
// end ;
6668: GO 6509
6670: POP
6671: POP
// for i = 1 to Difficulty do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_OWVAR 67
6686: PUSH
6687: FOR_TO
6688: IFFALSE 6813
// begin uc_side := 8 ;
6690: LD_ADDR_OWVAR 20
6694: PUSH
6695: LD_INT 8
6697: ST_TO_ADDR
// uc_nation := 2 ;
6698: LD_ADDR_OWVAR 21
6702: PUSH
6703: LD_INT 2
6705: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6706: LD_INT 0
6708: PPUSH
6709: LD_INT 8
6711: PPUSH
6712: LD_INT 8
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: LD_INT 9
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_OWVAR 67
6730: ARRAY
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 2
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// tmp := tmp ^ un ;
6746: LD_ADDR_VAR 0 3
6750: PUSH
6751: LD_VAR 0 3
6755: PUSH
6756: LD_VAR 0 2
6760: ADD
6761: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 3
6769: PPUSH
6770: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 30
6781: PPUSH
6782: LD_INT 0
6784: PPUSH
6785: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 16
6796: PPUSH
6797: LD_INT 11
6799: PPUSH
6800: CALL_OW 111
// wait ( 0 0$2 ) ;
6804: LD_INT 70
6806: PPUSH
6807: CALL_OW 67
// end ;
6811: GO 6687
6813: POP
6814: POP
// repeat wait ( 0 0$1 ) ;
6815: LD_INT 35
6817: PPUSH
6818: CALL_OW 67
// for i in tmp do
6822: LD_ADDR_VAR 0 1
6826: PUSH
6827: LD_VAR 0 3
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6969
// begin if GetLives ( i ) > 250 then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 256
6844: PUSH
6845: LD_INT 250
6847: GREATER
6848: IFFALSE 6940
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6850: LD_INT 81
6852: PUSH
6853: LD_INT 8
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: LD_INT 91
6862: PUSH
6863: LD_VAR 0 1
6867: PUSH
6868: LD_INT 10
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 69
6884: NOT
6885: IFFALSE 6904
// ComAgressiveMove ( i , 67 , 110 ) else
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_INT 67
6894: PPUSH
6895: LD_INT 110
6897: PPUSH
6898: CALL_OW 114
6902: GO 6938
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 81
6911: PUSH
6912: LD_INT 8
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PPUSH
6919: CALL_OW 69
6923: PPUSH
6924: LD_VAR 0 1
6928: PPUSH
6929: CALL_OW 74
6933: PPUSH
6934: CALL_OW 115
// end else
6938: GO 6967
// if IsDead ( i ) then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 301
6949: IFFALSE 6967
// tmp := tmp diff i ;
6951: LD_ADDR_VAR 0 3
6955: PUSH
6956: LD_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: DIFF
6966: ST_TO_ADDR
// end ;
6967: GO 6832
6969: POP
6970: POP
// until not tmp ;
6971: LD_VAR 0 3
6975: NOT
6976: IFFALSE 6815
// end ; end_of_file
6978: PPOPN 3
6980: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6981: LD_INT 0
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
6989: PPUSH
6990: PPUSH
6991: PPUSH
// side := 3 ;
6992: LD_ADDR_VAR 0 6
6996: PUSH
6997: LD_INT 3
6999: ST_TO_ADDR
// uc_side := side ;
7000: LD_ADDR_OWVAR 20
7004: PUSH
7005: LD_VAR 0 6
7009: ST_TO_ADDR
// uc_nation := 3 ;
7010: LD_ADDR_OWVAR 21
7014: PUSH
7015: LD_INT 3
7017: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_VAR 0 6
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: FOR_IN
7055: IFFALSE 7071
// SetBLevel ( i , 10 ) ;
7057: LD_VAR 0 2
7061: PPUSH
7062: LD_INT 10
7064: PPUSH
7065: CALL_OW 241
7069: GO 7054
7071: POP
7072: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7073: LD_ADDR_VAR 0 9
7077: PUSH
7078: LD_INT 22
7080: PUSH
7081: LD_VAR 0 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 34
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: ST_TO_ADDR
// if teleport then
7109: LD_VAR 0 9
7113: IFFALSE 7134
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7115: LD_VAR 0 9
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_INT 123
7126: PPUSH
7127: LD_INT 122
7129: PPUSH
7130: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7134: LD_ADDR_EXP 64
7138: PUSH
7139: LD_STRING Platonov
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7147: LD_ADDR_EXP 65
7151: PUSH
7152: LD_STRING Kovalyuk
7154: PPUSH
7155: CALL_OW 25
7159: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7160: LD_ADDR_EXP 67
7164: PUSH
7165: LD_STRING Yakotich
7167: PPUSH
7168: LD_EXP 1
7172: NOT
7173: PPUSH
7174: LD_STRING 09_
7176: PPUSH
7177: CALL 65553 0 3
7181: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7182: LD_ADDR_EXP 66
7186: PUSH
7187: LD_STRING Bystrov
7189: PPUSH
7190: CALL_OW 25
7194: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7195: LD_ADDR_EXP 68
7199: PUSH
7200: LD_STRING Gleb
7202: PPUSH
7203: CALL_OW 25
7207: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7208: LD_STRING 03_Cornel
7210: PPUSH
7211: CALL_OW 28
7215: IFFALSE 7263
// begin Bierezov := NewCharacter ( Mikhail ) ;
7217: LD_ADDR_EXP 69
7221: PUSH
7222: LD_STRING Mikhail
7224: PPUSH
7225: CALL_OW 25
7229: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7230: LD_EXP 69
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7251: LD_EXP 69
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7263: LD_EXP 64
7267: PPUSH
7268: LD_INT 126
7270: PPUSH
7271: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7275: LD_EXP 65
7279: PPUSH
7280: LD_INT 134
7282: PPUSH
7283: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7287: LD_EXP 67
7291: PPUSH
7292: LD_INT 197
7294: PPUSH
7295: LD_INT 111
7297: PPUSH
7298: LD_INT 9
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7308: LD_EXP 66
7312: PPUSH
7313: LD_INT 197
7315: PPUSH
7316: LD_INT 111
7318: PPUSH
7319: LD_INT 9
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7329: LD_EXP 68
7333: PPUSH
7334: LD_INT 197
7336: PPUSH
7337: LD_INT 111
7339: PPUSH
7340: LD_INT 9
7342: PPUSH
7343: LD_INT 0
7345: PPUSH
7346: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_INT 126
7357: PPUSH
7358: LD_INT 4
7360: PPUSH
7361: LD_STRING zhukov
7363: PPUSH
7364: LD_INT 9
7366: PUSH
7367: LD_INT 10
7369: PUSH
7370: LD_INT 10
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 73864 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 116
7483: PUSH
7484: LD_EXP 116
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 102291 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 102291 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 102352 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 102352 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8306
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_OWVAR 67
8197: ARRAY
8198: PUSH
8199: FOR_TO
8200: IFFALSE 8302
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8202: LD_INT 22
8204: PUSH
8205: LD_INT 24
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: LD_VAR 0 3
8216: PUSH
8217: LD_INT 2
8219: MOD
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ARRAY
8225: PPUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 3
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 1
8238: PPUSH
8239: LD_INT 2
8241: PPUSH
8242: CALL_OW 12
8246: ARRAY
8247: PPUSH
8248: LD_INT 3
8250: PPUSH
8251: LD_INT 43
8253: PUSH
8254: LD_INT 44
8256: PUSH
8257: LD_INT 45
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 12
8275: ARRAY
8276: PPUSH
8277: LD_INT 80
8279: PPUSH
8280: CALL 70417 0 5
// result := result union CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_VAR 0 2
8293: PUSH
8294: CALL_OW 45
8298: UNION
8299: ST_TO_ADDR
// end ;
8300: GO 8199
8302: POP
8303: POP
// end ; 2 :
8304: GO 9257
8306: LD_INT 2
8308: DOUBLE
8309: EQUAL
8310: IFTRUE 8314
8312: GO 8470
8314: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: DOUBLE
8321: LD_INT 1
8323: DEC
8324: ST_TO_ADDR
8325: LD_INT 5
8327: PUSH
8328: LD_INT 6
8330: PUSH
8331: LD_INT 7
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_OWVAR 67
8343: ARRAY
8344: PUSH
8345: FOR_TO
8346: IFFALSE 8466
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 24
8353: PUSH
8354: LD_INT 24
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: PUSH
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 3
8369: MOD
8370: PUSH
8371: LD_INT 1
8373: PLUS
8374: ARRAY
8375: PPUSH
8376: LD_INT 1
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: LD_INT 1
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 12
8396: ARRAY
8397: PPUSH
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 43
8403: PUSH
8404: LD_INT 44
8406: PUSH
8407: LD_INT 45
8409: PUSH
8410: LD_INT 44
8412: PUSH
8413: LD_INT 46
8415: PUSH
8416: LD_INT 46
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: LD_INT 6
8434: MOD
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ARRAY
8440: PPUSH
8441: LD_INT 80
8443: PPUSH
8444: CALL 70417 0 5
// result := result union CreateVehicle ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_VAR 0 2
8457: PUSH
8458: CALL_OW 45
8462: UNION
8463: ST_TO_ADDR
// end ;
8464: GO 8345
8466: POP
8467: POP
// end ; 3 :
8468: GO 9257
8470: LD_INT 3
8472: DOUBLE
8473: EQUAL
8474: IFTRUE 8478
8476: GO 8634
8478: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: DOUBLE
8485: LD_INT 1
8487: DEC
8488: ST_TO_ADDR
8489: LD_INT 5
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 8
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_OWVAR 67
8507: ARRAY
8508: PUSH
8509: FOR_TO
8510: IFFALSE 8630
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8512: LD_INT 22
8514: PUSH
8515: LD_INT 24
8517: PUSH
8518: LD_INT 24
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 3
8530: PUSH
8531: LD_INT 3
8533: MOD
8534: PUSH
8535: LD_INT 1
8537: PLUS
8538: ARRAY
8539: PPUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 12
8560: ARRAY
8561: PPUSH
8562: LD_INT 3
8564: PPUSH
8565: LD_INT 43
8567: PUSH
8568: LD_INT 47
8570: PUSH
8571: LD_INT 45
8573: PUSH
8574: LD_INT 45
8576: PUSH
8577: LD_INT 46
8579: PUSH
8580: LD_INT 46
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 6
8598: MOD
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 80
8607: PPUSH
8608: CALL 70417 0 5
// result := result union CreateVehicle ;
8612: LD_ADDR_VAR 0 2
8616: PUSH
8617: LD_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: UNION
8627: ST_TO_ADDR
// end ;
8628: GO 8509
8630: POP
8631: POP
// end ; 4 :
8632: GO 9257
8634: LD_INT 4
8636: DOUBLE
8637: EQUAL
8638: IFTRUE 8642
8640: GO 9256
8642: POP
// begin uc_nation := 3 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 3
8650: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8651: LD_ADDR_VAR 0 3
8655: PUSH
8656: DOUBLE
8657: LD_INT 1
8659: DEC
8660: ST_TO_ADDR
8661: LD_INT 6
8663: PUSH
8664: LD_INT 8
8666: PUSH
8667: LD_INT 9
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PUSH
8675: LD_OWVAR 67
8679: ARRAY
8680: PUSH
8681: FOR_TO
8682: IFFALSE 8802
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8684: LD_INT 22
8686: PUSH
8687: LD_INT 24
8689: PUSH
8690: LD_INT 24
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_VAR 0 3
8702: PUSH
8703: LD_INT 3
8705: MOD
8706: PUSH
8707: LD_INT 1
8709: PLUS
8710: ARRAY
8711: PPUSH
8712: LD_INT 1
8714: PUSH
8715: LD_INT 3
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 45
8739: PUSH
8740: LD_INT 47
8742: PUSH
8743: LD_INT 47
8745: PUSH
8746: LD_INT 45
8748: PUSH
8749: LD_INT 46
8751: PUSH
8752: LD_INT 46
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_VAR 0 3
8767: PUSH
8768: LD_INT 6
8770: MOD
8771: PUSH
8772: LD_INT 1
8774: PLUS
8775: ARRAY
8776: PPUSH
8777: LD_INT 80
8779: PPUSH
8780: CALL 70417 0 5
// result := result union CreateVehicle ;
8784: LD_ADDR_VAR 0 2
8788: PUSH
8789: LD_VAR 0 2
8793: PUSH
8794: CALL_OW 45
8798: UNION
8799: ST_TO_ADDR
// end ;
8800: GO 8681
8802: POP
8803: POP
// if not KappaStatus then
8804: LD_EXP 2
8808: NOT
8809: IFFALSE 9044
// begin uc_nation := 1 ;
8811: LD_ADDR_OWVAR 21
8815: PUSH
8816: LD_INT 1
8818: ST_TO_ADDR
// for i = 1 to 3 do
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: DOUBLE
8825: LD_INT 1
8827: DEC
8828: ST_TO_ADDR
8829: LD_INT 3
8831: PUSH
8832: FOR_TO
8833: IFFALSE 8969
// begin j := rand ( 0 , 1 ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 0
8842: PPUSH
8843: LD_INT 1
8845: PPUSH
8846: CALL_OW 12
8850: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8851: LD_INT 3
8853: PUSH
8854: LD_INT 5
8856: PUSH
8857: LD_INT 5
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 3
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 1
8889: PUSH
8890: LD_INT 3
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 1
8899: PPUSH
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 12
8907: ARRAY
8908: PPUSH
8909: LD_INT 3
8911: PPUSH
8912: LD_INT 9
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: PPUSH
8934: LD_INT 2
8936: PPUSH
8937: CALL_OW 12
8941: PLUS
8942: ARRAY
8943: PPUSH
8944: LD_INT 85
8946: PPUSH
8947: CALL 70417 0 5
// result := result union CreateVehicle ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 2
8960: PUSH
8961: CALL_OW 45
8965: UNION
8966: ST_TO_ADDR
// end ;
8967: GO 8832
8969: POP
8970: POP
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8985: LD_INT 5
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 6
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 70417 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 71
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 71
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 71
9040: UNION
9041: ST_TO_ADDR
// end ; end else
9042: GO 9254
// if vsevolodFirstAttack then
9044: LD_EXP 24
9048: IFFALSE 9254
// begin vsevolodFirstAttack := false ;
9050: LD_ADDR_EXP 24
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// uc_nation := 3 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 2
9078: PUSH
9079: LD_OWVAR 67
9083: PLUS
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9194
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 24
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_VAR 0 3
9106: PUSH
9107: LD_INT 3
9109: MOD
9110: PUSH
9111: LD_INT 1
9113: PLUS
9114: ARRAY
9115: PPUSH
9116: LD_INT 1
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 1
9128: PPUSH
9129: LD_INT 2
9131: PPUSH
9132: CALL_OW 12
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PPUSH
9141: LD_INT 45
9143: PUSH
9144: LD_INT 47
9146: PUSH
9147: LD_INT 47
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_VAR 0 3
9159: PUSH
9160: LD_INT 3
9162: MOD
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: PPUSH
9169: LD_INT 80
9171: PPUSH
9172: CALL 70417 0 5
// result := result union CreateVehicle ;
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 2
9185: PUSH
9186: CALL_OW 45
9190: UNION
9191: ST_TO_ADDR
// end ;
9192: GO 9085
9194: POP
9195: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9196: LD_INT 24
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 47
9207: PPUSH
9208: LD_INT 100
9210: PPUSH
9211: CALL 70417 0 5
// sewiVeh := CreateVehicle ;
9215: LD_ADDR_EXP 71
9219: PUSH
9220: CALL_OW 45
9224: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9225: LD_EXP 71
9229: PPUSH
9230: LD_INT 6
9232: NEG
9233: PPUSH
9234: CALL_OW 242
// result := result union sewiVeh ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_EXP 71
9252: UNION
9253: ST_TO_ADDR
// end ; end ; end ;
9254: GO 9257
9256: POP
// end ;
9257: LD_VAR 0 2
9261: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9262: LD_EXP 16
9266: IFFALSE 10107
9268: GO 9270
9270: DISABLE
9271: LD_INT 0
9273: PPUSH
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
9278: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9279: LD_ADDR_VAR 0 4
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9294: LD_ADDR_VAR 0 3
9298: PUSH
9299: LD_INT 11550
9301: PUSH
9302: LD_INT 10150
9304: PUSH
9305: LD_INT 9800
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_OWVAR 67
9317: ARRAY
9318: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9319: LD_ADDR_VAR 0 6
9323: PUSH
9324: LD_INT 70
9326: PUSH
9327: LD_INT 118
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 78
9336: PUSH
9337: LD_INT 31
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: ST_TO_ADDR
// repeat if missionStage = 2 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9367
// wait ( 1 1$30 ) else
9358: LD_INT 3150
9360: PPUSH
9361: CALL_OW 67
9365: GO 9376
// wait ( time ) ;
9367: LD_VAR 0 3
9371: PPUSH
9372: CALL_OW 67
// if missionStage = 6 then
9376: LD_EXP 15
9380: PUSH
9381: LD_INT 6
9383: EQUAL
9384: IFFALSE 9412
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9386: LD_INT 51
9388: PPUSH
9389: LD_INT 6
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9399: LD_INT 57
9401: PPUSH
9402: LD_INT 6
9404: PPUSH
9405: LD_INT 2
9407: PPUSH
9408: CALL_OW 322
// end ; if missionStage = 8 then
9412: LD_EXP 15
9416: PUSH
9417: LD_INT 8
9419: EQUAL
9420: IFFALSE 9448
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9422: LD_INT 52
9424: PPUSH
9425: LD_INT 6
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9435: LD_INT 58
9437: PPUSH
9438: LD_INT 6
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9448: LD_EXP 15
9452: PUSH
9453: LD_INT 10
9455: EQUAL
9456: PUSH
9457: LD_OWVAR 67
9461: PUSH
9462: LD_INT 1
9464: GREATER
9465: AND
9466: IFFALSE 9494
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9468: LD_INT 53
9470: PPUSH
9471: LD_INT 6
9473: PPUSH
9474: LD_INT 2
9476: PPUSH
9477: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9481: LD_INT 59
9483: PPUSH
9484: LD_INT 6
9486: PPUSH
9487: LD_INT 2
9489: PPUSH
9490: CALL_OW 322
// end ; if activeAttacks then
9494: LD_EXP 16
9498: IFFALSE 10101
// begin if missionStage = 2 then
9500: LD_EXP 15
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9518
// strength := 1 ;
9510: LD_ADDR_VAR 0 5
9514: PUSH
9515: LD_INT 1
9517: ST_TO_ADDR
// if missionStage > 2 then
9518: LD_EXP 15
9522: PUSH
9523: LD_INT 2
9525: GREATER
9526: IFFALSE 9536
// strength := 2 ;
9528: LD_ADDR_VAR 0 5
9532: PUSH
9533: LD_INT 2
9535: ST_TO_ADDR
// if missionStage > 6 then
9536: LD_EXP 15
9540: PUSH
9541: LD_INT 6
9543: GREATER
9544: IFFALSE 9554
// strength := 3 ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 3
9553: ST_TO_ADDR
// if missionStage > 10 then
9554: LD_EXP 15
9558: PUSH
9559: LD_INT 10
9561: GREATER
9562: IFFALSE 9572
// strength := 4 ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_INT 4
9571: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_VAR 0 5
9581: PPUSH
9582: CALL 8127 0 1
9586: ST_TO_ADDR
// for i in tmp do
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_VAR 0 2
9596: PUSH
9597: FOR_IN
9598: IFFALSE 9781
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 4
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 2
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 49
// if i = sewiVeh then
9629: LD_VAR 0 1
9633: PUSH
9634: LD_EXP 71
9638: EQUAL
9639: IFFALSE 9676
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9641: LD_ADDR_EXP 70
9645: PUSH
9646: LD_STRING Vsevolod
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: LD_STRING 
9654: PPUSH
9655: CALL 65553 0 3
9659: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9660: LD_EXP 70
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 52
// end else
9674: GO 9757
// if GetControl ( i ) = control_manual then
9676: LD_VAR 0 1
9680: PPUSH
9681: CALL_OW 263
9685: PUSH
9686: LD_INT 1
9688: EQUAL
9689: IFFALSE 9757
// begin uc_side := 6 ;
9691: LD_ADDR_OWVAR 20
9695: PUSH
9696: LD_INT 6
9698: ST_TO_ADDR
// uc_nation := 3 ;
9699: LD_ADDR_OWVAR 21
9703: PUSH
9704: LD_INT 3
9706: ST_TO_ADDR
// hc_gallery :=  ;
9707: LD_ADDR_OWVAR 33
9711: PUSH
9712: LD_STRING 
9714: ST_TO_ADDR
// hc_name :=  ;
9715: LD_ADDR_OWVAR 26
9719: PUSH
9720: LD_STRING 
9722: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9723: LD_INT 0
9725: PPUSH
9726: LD_INT 3
9728: PPUSH
9729: LD_INT 10
9731: PPUSH
9732: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9736: CALL_OW 44
9740: PPUSH
9741: LD_VAR 0 1
9745: PPUSH
9746: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9750: LD_INT 10
9752: PPUSH
9753: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9757: LD_VAR 0 1
9761: PPUSH
9762: LD_INT 111
9764: PPUSH
9765: LD_INT 197
9767: PPUSH
9768: CALL_OW 111
// wait ( 0 0$2 ) ;
9772: LD_INT 70
9774: PPUSH
9775: CALL_OW 67
// end ;
9779: GO 9597
9781: POP
9782: POP
// repeat wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// for i in tmp do
9790: LD_ADDR_VAR 0 1
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: FOR_IN
9801: IFFALSE 10082
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9803: LD_INT 81
9805: PUSH
9806: LD_INT 6
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 91
9815: PUSH
9816: LD_VAR 0 1
9820: PUSH
9821: LD_INT 12
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 69
9837: IFFALSE 9895
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 81
9846: PUSH
9847: LD_INT 6
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 91
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 12
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
9893: GO 10080
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9895: LD_INT 9
9897: PPUSH
9898: LD_INT 81
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 70
9912: IFFALSE 10046
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_VAR 0 6
9923: PUSH
9924: LD_INT 1
9926: ARRAY
9927: PUSH
9928: LD_INT 1
9930: ARRAY
9931: PPUSH
9932: LD_VAR 0 6
9936: PUSH
9937: LD_INT 1
9939: ARRAY
9940: PUSH
9941: LD_INT 2
9943: ARRAY
9944: PPUSH
9945: CALL_OW 297
9949: PUSH
9950: LD_INT 10
9952: GREATER
9953: PUSH
9954: LD_VAR 0 1
9958: PPUSH
9959: LD_INT 9
9961: PPUSH
9962: CALL_OW 308
9966: NOT
9967: AND
9968: IFFALSE 10007
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9970: LD_VAR 0 1
9974: PPUSH
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 1
9982: ARRAY
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PPUSH
9988: LD_VAR 0 6
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PUSH
9997: LD_INT 2
9999: ARRAY
10000: PPUSH
10001: CALL_OW 114
10005: GO 10044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: LD_INT 9
10014: PPUSH
10015: LD_INT 81
10017: PUSH
10018: LD_INT 6
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 70
10029: PPUSH
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 74
10039: PPUSH
10040: CALL_OW 115
// end else
10044: GO 10080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_INT 81
10053: PUSH
10054: LD_INT 6
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PPUSH
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 74
10075: PPUSH
10076: CALL_OW 115
// end ;
10080: GO 9800
10082: POP
10083: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 6
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: NOT
10099: IFFALSE 9783
// end ; until russianDestroyed ;
10101: LD_EXP 21
10105: IFFALSE 9348
// end ;
10107: PPOPN 6
10109: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10110: LD_EXP 21
10114: NOT
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: LD_INT 6
10123: GREATEREQUAL
10124: AND
10125: PUSH
10126: LD_INT 2
10128: PPUSH
10129: LD_INT 1
10131: PPUSH
10132: CALL 60565 0 2
10136: NOT
10137: AND
10138: IFFALSE 11094
10140: GO 10142
10142: DISABLE
10143: LD_INT 0
10145: PPUSH
10146: PPUSH
10147: PPUSH
10148: PPUSH
// begin enable ;
10149: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10150: LD_INT 22
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 30
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: NOT
10179: IFFALSE 10183
// exit ;
10181: GO 11094
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10183: LD_ADDR_VAR 0 4
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 30
10200: PUSH
10201: LD_INT 34
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PPUSH
10212: CALL_OW 69
10216: ST_TO_ADDR
// if Prob ( 40 ) then
10217: LD_INT 40
10219: PPUSH
10220: CALL_OW 13
10224: IFFALSE 10351
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10226: LD_INT 2
10228: PPUSH
10229: LD_INT 22
10231: PUSH
10232: LD_INT 3
10234: PUSH
10235: LD_INT 3
10237: PUSH
10238: LD_INT 49
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 3
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: LD_INT 49
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: LD_INT 3
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 24
10285: PUSH
10286: LD_INT 3
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 46
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 24
10303: PUSH
10304: LD_INT 3
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 46
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PUSH
10319: LD_INT 24
10321: PUSH
10322: LD_INT 3
10324: PUSH
10325: LD_INT 3
10327: PUSH
10328: LD_INT 46
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL 59147 0 2
// end else
10349: GO 10474
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10351: LD_INT 2
10353: PPUSH
10354: LD_INT 24
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 3
10362: PUSH
10363: LD_INT 47
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 46
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL 59147 0 2
// end ; if Difficulty > 1 then
10474: LD_OWVAR 67
10478: PUSH
10479: LD_INT 1
10481: GREATER
10482: IFFALSE 10512
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10484: LD_INT 2
10486: PPUSH
10487: LD_INT 24
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 3
10495: PUSH
10496: LD_INT 47
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: PUSH
10505: EMPTY
10506: LIST
10507: PPUSH
10508: CALL 59147 0 2
// repeat wait ( 0 0$1 ) ;
10512: LD_INT 35
10514: PPUSH
10515: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10519: LD_INT 2
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL 60565 0 2
10529: PUSH
10530: LD_INT 6
10532: PUSH
10533: LD_INT 7
10535: PUSH
10536: LD_INT 7
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: LIST
10543: PUSH
10544: LD_OWVAR 67
10548: ARRAY
10549: GREATEREQUAL
10550: IFFALSE 10512
// wait ( 0 0$30 ) ;
10552: LD_INT 1050
10554: PPUSH
10555: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10559: LD_ADDR_VAR 0 2
10563: PUSH
10564: LD_INT 2
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 60565 0 2
10574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10575: LD_ADDR_EXP 135
10579: PUSH
10580: LD_EXP 135
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: LD_EXP 135
10592: PUSH
10593: LD_INT 2
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 2
10601: DIFF
10602: PPUSH
10603: CALL_OW 1
10607: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10608: LD_ADDR_VAR 0 3
10612: PUSH
10613: LD_INT 0
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: CALL_OW 12
10623: ST_TO_ADDR
// if target then
10624: LD_VAR 0 3
10628: IFFALSE 10756
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 250
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 72
10654: ST_TO_ADDR
// for i in tmp do
10655: LD_ADDR_VAR 0 1
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: FOR_IN
10666: IFFALSE 10706
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10668: LD_VAR 0 1
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: LD_INT 89
10678: PPUSH
10679: CALL_OW 297
10683: PUSH
10684: LD_INT 9
10686: GREATER
10687: IFFALSE 10704
// ComMoveXY ( i , 139 , 89 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: LD_INT 89
10699: PPUSH
10700: CALL_OW 111
10704: GO 10665
10706: POP
10707: POP
// wait ( 0 0$1 ) ;
10708: LD_INT 35
10710: PPUSH
10711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10715: LD_VAR 0 2
10719: PPUSH
10720: LD_INT 92
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 89
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: LD_INT 1
10750: MINUS
10751: GREATEREQUAL
10752: IFFALSE 10630
// end else
10754: GO 10898
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10756: LD_VAR 0 2
10760: PPUSH
10761: LD_VAR 0 4
10765: PUSH
10766: LD_INT 1
10768: ARRAY
10769: PPUSH
10770: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 24
10786: PUSH
10787: LD_INT 250
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 72
10798: ST_TO_ADDR
// for i in tmp do
10799: LD_ADDR_VAR 0 1
10803: PUSH
10804: LD_VAR 0 2
10808: PUSH
10809: FOR_IN
10810: IFFALSE 10850
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_INT 124
10819: PPUSH
10820: LD_INT 139
10822: PPUSH
10823: CALL_OW 297
10827: PUSH
10828: LD_INT 9
10830: GREATER
10831: IFFALSE 10848
// ComMoveXY ( i , 124 , 139 ) ;
10833: LD_VAR 0 1
10837: PPUSH
10838: LD_INT 124
10840: PPUSH
10841: LD_INT 139
10843: PPUSH
10844: CALL_OW 111
10848: GO 10809
10850: POP
10851: POP
// wait ( 0 0$1 ) ;
10852: LD_INT 35
10854: PPUSH
10855: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10859: LD_VAR 0 2
10863: PPUSH
10864: LD_INT 92
10866: PUSH
10867: LD_INT 124
10869: PUSH
10870: LD_INT 139
10872: PUSH
10873: LD_INT 9
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_INT 1
10894: MINUS
10895: GREATEREQUAL
10896: IFFALSE 10774
// end ; repeat wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// for i in tmp do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_VAR 0 2
10914: PUSH
10915: FOR_IN
10916: IFFALSE 11085
// begin if GetLives ( i ) > 251 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 256
10927: PUSH
10928: LD_INT 251
10930: GREATER
10931: IFFALSE 11056
// begin if GetWeapon ( i ) = ru_time_lapser then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 49
10945: EQUAL
10946: IFFALSE 11002
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 2
10955: PUSH
10956: LD_INT 22
10958: PUSH
10959: LD_INT 1
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_INT 8
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 112
11000: GO 11054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 2
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 8
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PPUSH
11040: LD_VAR 0 1
11044: PPUSH
11045: CALL_OW 74
11049: PPUSH
11050: CALL_OW 115
// end else
11054: GO 11083
// if IsDead ( i ) then
11056: LD_VAR 0 1
11060: PPUSH
11061: CALL_OW 301
11065: IFFALSE 11083
// tmp := tmp diff i ;
11067: LD_ADDR_VAR 0 2
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_VAR 0 1
11081: DIFF
11082: ST_TO_ADDR
// end ;
11083: GO 10915
11085: POP
11086: POP
// until not tmp ;
11087: LD_VAR 0 2
11091: NOT
11092: IFFALSE 10898
// end ; end_of_file
11094: PPOPN 4
11096: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11097: LD_INT 0
11099: PPUSH
11100: PPUSH
11101: PPUSH
11102: PPUSH
11103: PPUSH
11104: PPUSH
// side := 7 ;
11105: LD_ADDR_VAR 0 5
11109: PUSH
11110: LD_INT 7
11112: ST_TO_ADDR
// uc_side := side ;
11113: LD_ADDR_OWVAR 20
11117: PUSH
11118: LD_VAR 0 5
11122: ST_TO_ADDR
// uc_nation := 1 ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 1
11130: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: EMPTY
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL_OW 69
11166: PUSH
11167: FOR_IN
11168: IFFALSE 11184
// SetBLevel ( i , 10 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_INT 10
11177: PPUSH
11178: CALL_OW 241
11182: GO 11167
11184: POP
11185: POP
// base := GetBase ( al_depot ) ;
11186: LD_ADDR_VAR 0 4
11190: PUSH
11191: LD_INT 2
11193: PPUSH
11194: CALL_OW 274
11198: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11199: LD_ADDR_VAR 0 6
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: LD_INT 30
11218: PUSH
11219: LD_INT 34
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if teleport then
11235: LD_VAR 0 6
11239: IFFALSE 11260
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11241: LD_VAR 0 6
11245: PUSH
11246: LD_INT 1
11248: ARRAY
11249: PPUSH
11250: LD_INT 262
11252: PPUSH
11253: LD_INT 119
11255: PPUSH
11256: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11260: LD_VAR 0 4
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 19500
11270: PPUSH
11271: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11275: LD_VAR 0 4
11279: PPUSH
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 200
11285: PPUSH
11286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11290: LD_VAR 0 4
11294: PPUSH
11295: LD_INT 3
11297: PPUSH
11298: LD_INT 650
11300: PPUSH
11301: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11305: LD_ADDR_EXP 74
11309: PUSH
11310: LD_STRING Roth
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11318: LD_ADDR_EXP 75
11322: PUSH
11323: LD_STRING Simms
11325: PPUSH
11326: LD_EXP 1
11330: NOT
11331: PPUSH
11332: LD_STRING 10c_
11334: PPUSH
11335: CALL 65553 0 3
11339: ST_TO_ADDR
// if not Simms then
11340: LD_EXP 75
11344: NOT
11345: IFFALSE 11375
// begin uc_nation := 1 ;
11347: LD_ADDR_OWVAR 21
11351: PUSH
11352: LD_INT 1
11354: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11355: LD_INT 2
11357: PPUSH
11358: LD_INT 10
11360: PPUSH
11361: CALL_OW 384
// Simms := CreateHuman ;
11365: LD_ADDR_EXP 75
11369: PUSH
11370: CALL_OW 44
11374: ST_TO_ADDR
// end ; uc_nation := 3 ;
11375: LD_ADDR_OWVAR 21
11379: PUSH
11380: LD_INT 3
11382: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11383: LD_ADDR_EXP 76
11387: PUSH
11388: LD_STRING Kirilenkova
11390: PPUSH
11391: CALL_OW 25
11395: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11396: LD_ADDR_EXP 90
11400: PUSH
11401: LD_STRING Oblukov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11409: LD_ADDR_EXP 77
11413: PUSH
11414: LD_STRING Dolgov
11416: PPUSH
11417: CALL_OW 25
11421: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11422: LD_ADDR_EXP 78
11426: PUSH
11427: LD_STRING Petrosyan
11429: PPUSH
11430: CALL_OW 25
11434: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11435: LD_ADDR_EXP 89
11439: PUSH
11440: LD_STRING Scholtze
11442: PPUSH
11443: CALL_OW 25
11447: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11448: LD_ADDR_EXP 88
11452: PUSH
11453: LD_STRING Kapitsova
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11461: LD_ADDR_EXP 79
11465: PUSH
11466: LD_STRING Petrovova
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11474: LD_ADDR_EXP 80
11478: PUSH
11479: LD_STRING Kuzmov
11481: PPUSH
11482: CALL_OW 25
11486: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11487: LD_ADDR_EXP 87
11491: PUSH
11492: LD_STRING Karamazov
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11500: LD_STRING 13_Lipshchin_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Lipshchin := NewCharacter ( Lipshchin ) ;
11512: LD_ADDR_EXP 81
11516: PUSH
11517: LD_STRING Lipshchin
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11525: LD_STRING 13_Titov_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Titov := NewCharacter ( Titov ) ;
11537: LD_ADDR_EXP 83
11541: PUSH
11542: LD_STRING Titov
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11550: LD_STRING 13_Gnyevko_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Gnyevko := NewCharacter ( Gnyevko ) ;
11562: LD_ADDR_EXP 82
11566: PUSH
11567: LD_STRING Gnyevko
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11575: LD_STRING 13_Xavier_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Xavier := NewCharacter ( Xavier2 ) ;
11587: LD_ADDR_EXP 84
11591: PUSH
11592: LD_STRING Xavier2
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11600: LD_STRING 13_Belkov_1
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 30
11610: IFFALSE 11625
// Belkov := NewCharacter ( Belkov ) ;
11612: LD_ADDR_EXP 85
11616: PUSH
11617: LD_STRING Belkov
11619: PPUSH
11620: CALL_OW 25
11624: ST_TO_ADDR
// if not BurlakStatus then
11625: LD_EXP 9
11629: NOT
11630: IFFALSE 11645
// Burlak = NewCharacter ( Burlak ) ;
11632: LD_ADDR_EXP 86
11636: PUSH
11637: LD_STRING Burlak
11639: PPUSH
11640: CALL_OW 25
11644: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_EXP 74
11654: PUSH
11655: LD_EXP 76
11659: PUSH
11660: LD_EXP 90
11664: PUSH
11665: LD_EXP 77
11669: PUSH
11670: LD_EXP 78
11674: PUSH
11675: LD_EXP 89
11679: PUSH
11680: LD_EXP 88
11684: PUSH
11685: LD_EXP 79
11689: PUSH
11690: LD_EXP 80
11694: PUSH
11695: LD_EXP 87
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: ST_TO_ADDR
// if Simms then
11712: LD_EXP 75
11716: IFFALSE 11734
// tmp := tmp ^ Simms ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_EXP 75
11732: ADD
11733: ST_TO_ADDR
// if Titov then
11734: LD_EXP 83
11738: IFFALSE 11756
// tmp := tmp ^ Titov ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_EXP 83
11754: ADD
11755: ST_TO_ADDR
// if Lipshchin then
11756: LD_EXP 81
11760: IFFALSE 11778
// tmp := tmp ^ Lipshchin ;
11762: LD_ADDR_VAR 0 3
11766: PUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_EXP 81
11776: ADD
11777: ST_TO_ADDR
// if Gnyevko then
11778: LD_EXP 82
11782: IFFALSE 11800
// tmp := tmp ^ Gnyevko ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 82
11798: ADD
11799: ST_TO_ADDR
// if Xavier then
11800: LD_EXP 84
11804: IFFALSE 11822
// tmp := tmp ^ Xavier ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 84
11820: ADD
11821: ST_TO_ADDR
// if Belkov then
11822: LD_EXP 85
11826: IFFALSE 11844
// tmp := tmp ^ Belkov ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 85
11842: ADD
11843: ST_TO_ADDR
// if Burlak then
11844: LD_EXP 86
11848: IFFALSE 11866
// tmp := tmp ^ Burlak ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 86
11864: ADD
11865: ST_TO_ADDR
// for i = 1 to 11 do
11866: LD_ADDR_VAR 0 2
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 11
11878: PUSH
11879: FOR_TO
11880: IFFALSE 11946
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11882: LD_ADDR_OWVAR 21
11886: PUSH
11887: LD_INT 1
11889: PUSH
11890: LD_INT 3
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: CALL_OW 12
11907: ARRAY
11908: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11909: LD_INT 0
11911: PPUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 2
11919: DIV
11920: PPUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11928: LD_ADDR_VAR 0 3
11932: PUSH
11933: LD_VAR 0 3
11937: PUSH
11938: CALL_OW 44
11942: ADD
11943: ST_TO_ADDR
// end ;
11944: GO 11879
11946: POP
11947: POP
// for i in tmp do
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 3
11957: PUSH
11958: FOR_IN
11959: IFFALSE 11984
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11961: LD_VAR 0 2
11965: PPUSH
11966: LD_INT 260
11968: PPUSH
11969: LD_INT 235
11971: PPUSH
11972: LD_INT 8
11974: PPUSH
11975: LD_INT 0
11977: PPUSH
11978: CALL_OW 50
11982: GO 11958
11984: POP
11985: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11986: LD_ADDR_EXP 116
11990: PUSH
11991: LD_EXP 116
11995: PPUSH
11996: LD_INT 1
11998: PPUSH
11999: LD_INT 22
12001: PUSH
12002: LD_VAR 0 5
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 69
12036: PUSH
12037: LD_EXP 74
12041: PUSH
12042: LD_EXP 75
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: DIFF
12051: PPUSH
12052: CALL_OW 1
12056: ST_TO_ADDR
// uc_side := 0 ;
12057: LD_ADDR_OWVAR 20
12061: PUSH
12062: LD_INT 0
12064: ST_TO_ADDR
// uc_nation := 0 ;
12065: LD_ADDR_OWVAR 21
12069: PUSH
12070: LD_INT 0
12072: ST_TO_ADDR
// for i = 1 to 5 do
12073: LD_ADDR_VAR 0 2
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_INT 5
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12124
// begin InitHc ;
12089: CALL_OW 19
// hc_class := class_apeman ;
12093: LD_ADDR_OWVAR 28
12097: PUSH
12098: LD_INT 12
12100: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12101: CALL_OW 44
12105: PPUSH
12106: LD_INT 299
12108: PPUSH
12109: LD_INT 229
12111: PPUSH
12112: LD_INT 10
12114: PPUSH
12115: LD_INT 0
12117: PPUSH
12118: CALL_OW 50
// end ;
12122: GO 12086
12124: POP
12125: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12126: LD_EXP 74
12130: PPUSH
12131: LD_INT 259
12133: PPUSH
12134: LD_INT 235
12136: PPUSH
12137: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12141: LD_EXP 74
12145: PPUSH
12146: LD_INT 262
12148: PPUSH
12149: LD_INT 235
12151: PPUSH
12152: CALL_OW 178
// if Simms then
12156: LD_EXP 75
12160: IFFALSE 12191
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12162: LD_EXP 75
12166: PPUSH
12167: LD_INT 262
12169: PPUSH
12170: LD_INT 235
12172: PPUSH
12173: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12177: LD_EXP 75
12181: PPUSH
12182: LD_EXP 74
12186: PPUSH
12187: CALL_OW 179
// end ; end ;
12191: LD_VAR 0 1
12195: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12196: LD_EXP 31
12200: PUSH
12201: LD_EXP 23
12205: NOT
12206: AND
12207: IFFALSE 12383
12209: GO 12211
12211: DISABLE
12212: LD_INT 0
12214: PPUSH
12215: PPUSH
12216: PPUSH
// begin enable ;
12217: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12218: LD_ADDR_VAR 0 2
12222: PUSH
12223: LD_INT 81
12225: PUSH
12226: LD_INT 7
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 3
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 30
12248: PUSH
12249: LD_INT 30
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 30
12258: PUSH
12259: LD_INT 28
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 34
12268: PUSH
12269: LD_INT 49
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 34
12278: PUSH
12279: LD_INT 10
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 34
12288: PUSH
12289: LD_INT 8
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL_OW 69
12313: ST_TO_ADDR
// if not tmp then
12314: LD_VAR 0 2
12318: NOT
12319: IFFALSE 12323
// exit ;
12321: GO 12383
// target := tmp [ rand ( 1 , tmp ) ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 2
12332: PUSH
12333: LD_INT 1
12335: PPUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: CALL_OW 12
12345: ARRAY
12346: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12347: LD_VAR 0 3
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 1
12359: EQUAL
12360: IFFALSE 12371
// CenterNowOnUnits ( target ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 87
// SetLives ( target , 0 ) ;
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 234
// end ;
12383: PPOPN 3
12385: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12386: LD_EXP 23
12390: NOT
12391: PUSH
12392: LD_EXP 31
12396: AND
12397: IFFALSE 12919
12399: GO 12401
12401: DISABLE
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// begin uc_side := 7 ;
12407: LD_ADDR_OWVAR 20
12411: PUSH
12412: LD_INT 7
12414: ST_TO_ADDR
// uc_nation := 1 ;
12415: LD_ADDR_OWVAR 21
12419: PUSH
12420: LD_INT 1
12422: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 125
12430: PUSH
12431: LD_INT 163
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 185
12440: PUSH
12441: LD_INT 168
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 111
12450: PUSH
12451: LD_INT 97
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL 102396 0 1
12467: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to Difficulty do
12475: LD_ADDR_VAR 0 1
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_OWVAR 67
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12649
// begin InitHc ;
12493: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 8
12502: PPUSH
12503: CALL_OW 381
// un := CreateHuman ;
12507: LD_ADDR_VAR 0 2
12511: PUSH
12512: CALL_OW 44
12516: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: LD_INT 258
12524: PPUSH
12525: LD_INT 267
12527: PPUSH
12528: LD_INT 4
12530: PPUSH
12531: LD_INT 0
12533: PPUSH
12534: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12538: LD_ADDR_EXP 91
12542: PUSH
12543: LD_EXP 91
12547: PUSH
12548: LD_VAR 0 2
12552: UNION
12553: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12554: LD_VAR 0 2
12558: PPUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: ARRAY
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 3
12578: PUSH
12579: LD_VAR 0 1
12583: ARRAY
12584: PUSH
12585: LD_INT 2
12587: ARRAY
12588: PPUSH
12589: LD_INT 4
12591: PPUSH
12592: LD_INT 1
12594: PPUSH
12595: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: LD_VAR 0 3
12608: PUSH
12609: LD_VAR 0 1
12613: ARRAY
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: PPUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_VAR 0 1
12628: ARRAY
12629: PUSH
12630: LD_INT 2
12632: ARRAY
12633: PPUSH
12634: CALL_OW 171
// AddComInvisible ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL_OW 212
// end ;
12647: GO 12490
12649: POP
12650: POP
// repeat wait ( 0 0$20 ) ;
12651: LD_INT 700
12653: PPUSH
12654: CALL_OW 67
// for i in allianceSpecialForce do
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_EXP 91
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12904
// begin if IsInvisible ( i ) then
12671: LD_VAR 0 1
12675: PPUSH
12676: CALL_OW 571
12680: IFFALSE 12873
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 50
12699: PUSH
12700: EMPTY
12701: LIST
12702: PUSH
12703: LD_INT 56
12705: PUSH
12706: EMPTY
12707: LIST
12708: PUSH
12709: LD_INT 91
12711: PUSH
12712: LD_VAR 0 1
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 35
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: LD_OWVAR 67
12735: ARRAY
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 2
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 8
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: ST_TO_ADDR
// if not tmp then
12826: LD_VAR 0 3
12830: NOT
12831: IFFALSE 12835
// continue ;
12833: GO 12668
// if Prob ( 30 * Difficulty ) then
12835: LD_INT 30
12837: PUSH
12838: LD_OWVAR 67
12842: MUL
12843: PPUSH
12844: CALL_OW 13
12848: IFFALSE 12873
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12850: LD_VAR 0 3
12854: PUSH
12855: LD_INT 1
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 12
12867: ARRAY
12868: PPUSH
12869: CALL 31166 0 1
// end ; if IsDead ( i ) then
12873: LD_VAR 0 1
12877: PPUSH
12878: CALL_OW 301
12882: IFFALSE 12902
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12884: LD_ADDR_EXP 91
12888: PUSH
12889: LD_EXP 91
12893: PUSH
12894: LD_VAR 0 1
12898: DIFF
12899: ST_TO_ADDR
// continue ;
12900: GO 12668
// end ; end ;
12902: GO 12668
12904: POP
12905: POP
// until allianceDestroyed or not allianceSpecialForce ;
12906: LD_EXP 23
12910: PUSH
12911: LD_EXP 91
12915: NOT
12916: OR
12917: IFFALSE 12651
// end ;
12919: PPOPN 3
12921: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12922: LD_EXP 23
12926: NOT
12927: PUSH
12928: LD_EXP 31
12932: AND
12933: IFFALSE 13900
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
12941: PPUSH
12942: PPUSH
12943: PPUSH
// begin enable ;
12944: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: NOT
12974: IFFALSE 12978
// exit ;
12976: GO 13900
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 7
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 30
12995: PUSH
12996: LD_INT 34
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// if Prob ( 40 ) then
13012: LD_INT 40
13014: PPUSH
13015: CALL_OW 13
13019: IFFALSE 13146
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13021: LD_INT 1
13023: PPUSH
13024: LD_INT 5
13026: PUSH
13027: LD_INT 3
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: PUSH
13042: LD_INT 5
13044: PUSH
13045: LD_INT 3
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 6
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 6
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 24
13080: PUSH
13081: LD_INT 3
13083: PUSH
13084: LD_INT 3
13086: PUSH
13087: LD_INT 45
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 24
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 3
13104: PUSH
13105: LD_INT 47
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 24
13116: PUSH
13117: LD_INT 3
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 45
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PPUSH
13140: CALL 59147 0 2
// end else
13144: GO 13269
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 24
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 3
13157: PUSH
13158: LD_INT 47
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: LD_INT 24
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 47
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 5
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 9
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 3
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: LD_INT 9
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: PUSH
13221: LD_INT 24
13223: PUSH
13224: LD_INT 1
13226: PUSH
13227: LD_INT 3
13229: PUSH
13230: LD_INT 45
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 24
13241: PUSH
13242: LD_INT 1
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 45
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL 59147 0 2
// end ; if Difficulty > 1 then
13269: LD_OWVAR 67
13273: PUSH
13274: LD_INT 1
13276: GREATER
13277: IFFALSE 13307
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13279: LD_INT 1
13281: PPUSH
13282: LD_INT 24
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 3
13290: PUSH
13291: LD_INT 47
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: PPUSH
13303: CALL 59147 0 2
// repeat wait ( 0 0$1 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13314: LD_INT 1
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL 60565 0 2
13324: PUSH
13325: LD_INT 6
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: LD_INT 7
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_OWVAR 67
13343: ARRAY
13344: GREATEREQUAL
13345: IFFALSE 13307
// wait ( 0 0$40 ) ;
13347: LD_INT 1400
13349: PPUSH
13350: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13354: LD_ADDR_VAR 0 2
13358: PUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL 60565 0 2
13369: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13370: LD_ADDR_EXP 135
13374: PUSH
13375: LD_EXP 135
13379: PPUSH
13380: LD_INT 1
13382: PPUSH
13383: LD_EXP 135
13387: PUSH
13388: LD_INT 1
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 2
13396: DIFF
13397: PPUSH
13398: CALL_OW 1
13402: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 0
13410: PPUSH
13411: LD_INT 1
13413: PPUSH
13414: CALL_OW 12
13418: ST_TO_ADDR
// if target then
13419: LD_VAR 0 3
13423: IFFALSE 13589
// begin for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13461
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 179
13445: PPUSH
13446: LD_INT 209
13448: PPUSH
13449: LD_INT 8
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 483
13459: GO 13435
13461: POP
13462: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_INT 24
13475: PUSH
13476: LD_INT 250
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 72
13487: ST_TO_ADDR
// for i in tmp do
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_VAR 0 2
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13539
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 179
13508: PPUSH
13509: LD_INT 209
13511: PPUSH
13512: CALL_OW 297
13516: PUSH
13517: LD_INT 9
13519: GREATER
13520: IFFALSE 13537
// ComMoveXY ( i , 179 , 209 ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 179
13529: PPUSH
13530: LD_INT 209
13532: PPUSH
13533: CALL_OW 111
13537: GO 13498
13539: POP
13540: POP
// wait ( 0 0$1 ) ;
13541: LD_INT 35
13543: PPUSH
13544: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 92
13555: PUSH
13556: LD_INT 179
13558: PUSH
13559: LD_INT 209
13561: PUSH
13562: LD_INT 9
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PPUSH
13571: CALL_OW 72
13575: PUSH
13576: LD_VAR 0 2
13580: PUSH
13581: LD_INT 1
13583: MINUS
13584: GREATEREQUAL
13585: IFFALSE 13463
// end else
13587: GO 13751
// begin for i in tmp do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: LD_VAR 0 2
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 285
13609: PPUSH
13610: LD_INT 163
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
13623: GO 13599
13625: POP
13626: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13627: LD_ADDR_VAR 0 2
13631: PUSH
13632: LD_VAR 0 2
13636: PPUSH
13637: LD_INT 24
13639: PUSH
13640: LD_INT 250
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 72
13651: ST_TO_ADDR
// for i in tmp do
13652: LD_ADDR_VAR 0 1
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: FOR_IN
13663: IFFALSE 13703
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_INT 285
13672: PPUSH
13673: LD_INT 163
13675: PPUSH
13676: CALL_OW 297
13680: PUSH
13681: LD_INT 9
13683: GREATER
13684: IFFALSE 13701
// ComMoveXY ( i , 285 , 163 ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 285
13693: PPUSH
13694: LD_INT 163
13696: PPUSH
13697: CALL_OW 111
13701: GO 13662
13703: POP
13704: POP
// wait ( 0 0$1 ) ;
13705: LD_INT 35
13707: PPUSH
13708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 92
13719: PUSH
13720: LD_INT 285
13722: PUSH
13723: LD_INT 163
13725: PUSH
13726: LD_INT 9
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PUSH
13740: LD_VAR 0 2
13744: PUSH
13745: LD_INT 1
13747: MINUS
13748: GREATEREQUAL
13749: IFFALSE 13627
// end ; repeat wait ( 0 0$1 ) ;
13751: LD_INT 35
13753: PPUSH
13754: CALL_OW 67
// for i in tmp do
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_VAR 0 2
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13891
// if GetLives ( i ) > 251 then
13771: LD_VAR 0 1
13775: PPUSH
13776: CALL_OW 256
13780: PUSH
13781: LD_INT 251
13783: GREATER
13784: IFFALSE 13873
// begin if GetWeapon ( i ) = ru_time_lapser then
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 264
13795: PUSH
13796: LD_INT 49
13798: EQUAL
13799: IFFALSE 13837
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13801: LD_VAR 0 1
13805: PPUSH
13806: LD_INT 81
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PPUSH
13821: LD_VAR 0 1
13825: PPUSH
13826: CALL_OW 74
13830: PPUSH
13831: CALL_OW 112
13835: GO 13871
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_INT 81
13844: PUSH
13845: LD_INT 7
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PPUSH
13852: CALL_OW 69
13856: PPUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 74
13866: PPUSH
13867: CALL_OW 115
// end else
13871: GO 13889
// tmp := tmp diff i ;
13873: LD_ADDR_VAR 0 2
13877: PUSH
13878: LD_VAR 0 2
13882: PUSH
13883: LD_VAR 0 1
13887: DIFF
13888: ST_TO_ADDR
13889: GO 13768
13891: POP
13892: POP
// until not tmp ;
13893: LD_VAR 0 2
13897: NOT
13898: IFFALSE 13751
// end ; end_of_file
13900: PPOPN 4
13902: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
13908: PPUSH
// missionStage := 13 ;
13909: LD_ADDR_EXP 15
13913: PUSH
13914: LD_INT 13
13916: ST_TO_ADDR
// uc_side := 2 ;
13917: LD_ADDR_OWVAR 20
13921: PUSH
13922: LD_INT 2
13924: ST_TO_ADDR
// uc_nation := 2 ;
13925: LD_ADDR_OWVAR 21
13929: PUSH
13930: LD_INT 2
13932: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13933: LD_ADDR_EXP 92
13937: PUSH
13938: LD_STRING Omar
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13946: LD_EXP 92
13950: PPUSH
13951: LD_INT 4
13953: PPUSH
13954: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13958: LD_EXP 92
13962: PPUSH
13963: LD_INT 242
13965: PPUSH
13966: LD_INT 75
13968: PPUSH
13969: LD_INT 0
13971: PPUSH
13972: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13976: LD_ADDR_EXP 93
13980: PUSH
13981: LD_STRING Heike
13983: PPUSH
13984: CALL_OW 25
13988: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13989: LD_INT 14
13991: PPUSH
13992: LD_INT 3
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 27
14000: PPUSH
14001: LD_INT 100
14003: PPUSH
14004: CALL 70417 0 5
// veh := CreateVehicle ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: CALL_OW 45
14017: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 1
14025: PPUSH
14026: CALL_OW 242
// SetDir ( veh , 4 ) ;
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_INT 4
14037: PPUSH
14038: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_INT 241
14049: PPUSH
14050: LD_INT 72
14052: PPUSH
14053: LD_INT 0
14055: PPUSH
14056: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14060: LD_EXP 93
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL_OW 52
// if KhatamStatus then
14074: LD_EXP 8
14078: IFFALSE 14129
// begin Khatam := NewCharacter ( Khatam ) ;
14080: LD_ADDR_EXP 94
14084: PUSH
14085: LD_STRING Khatam
14087: PPUSH
14088: CALL_OW 25
14092: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14093: LD_EXP 94
14097: PPUSH
14098: LD_INT 245
14100: PPUSH
14101: LD_INT 78
14103: PPUSH
14104: LD_INT 3
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14114: LD_EXP 94
14118: PPUSH
14119: LD_INT 4
14121: PPUSH
14122: LD_INT 10
14124: PPUSH
14125: CALL_OW 237
// end ; for i = 1 to Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_OWVAR 67
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14211
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14147: LD_INT 0
14149: PPUSH
14150: LD_INT 7
14152: PUSH
14153: LD_OWVAR 67
14157: PLUS
14158: PPUSH
14159: CALL_OW 384
// un := CreateHuman ;
14163: LD_ADDR_VAR 0 4
14167: PUSH
14168: CALL_OW 44
14172: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14173: LD_VAR 0 4
14177: PPUSH
14178: LD_INT 28
14180: PUSH
14181: LD_INT 29
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_VAR 0 2
14192: PUSH
14193: LD_INT 2
14195: MOD
14196: PUSH
14197: LD_INT 1
14199: PLUS
14200: ARRAY
14201: PPUSH
14202: LD_INT 0
14204: PPUSH
14205: CALL_OW 49
// end ;
14209: GO 14144
14211: POP
14212: POP
// for i = 1 to 6 do
14213: LD_ADDR_VAR 0 2
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_INT 6
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14272
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14229: LD_INT 0
14231: PPUSH
14232: LD_INT 7
14234: PUSH
14235: LD_OWVAR 67
14239: PLUS
14240: PPUSH
14241: CALL_OW 381
// un := CreateHuman ;
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: CALL_OW 44
14254: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14255: LD_VAR 0 4
14259: PPUSH
14260: LD_INT 28
14262: PPUSH
14263: LD_INT 0
14265: PPUSH
14266: CALL_OW 49
// end ;
14270: GO 14226
14272: POP
14273: POP
// for i = 1 to 3 do
14274: LD_ADDR_VAR 0 2
14278: PUSH
14279: DOUBLE
14280: LD_INT 1
14282: DEC
14283: ST_TO_ADDR
14284: LD_INT 3
14286: PUSH
14287: FOR_TO
14288: IFFALSE 14336
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14290: LD_INT 0
14292: PPUSH
14293: LD_INT 8
14295: PPUSH
14296: LD_INT 7
14298: PUSH
14299: LD_OWVAR 67
14303: PLUS
14304: PPUSH
14305: CALL_OW 380
// un := CreateHuman ;
14309: LD_ADDR_VAR 0 4
14313: PUSH
14314: CALL_OW 44
14318: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14319: LD_VAR 0 4
14323: PPUSH
14324: LD_INT 28
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// end ;
14334: GO 14287
14336: POP
14337: POP
// for i = 1 to 3 do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: DOUBLE
14344: LD_INT 1
14346: DEC
14347: ST_TO_ADDR
14348: LD_INT 3
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14442
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14354: LD_INT 14
14356: PPUSH
14357: LD_INT 2
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 80
14368: PPUSH
14369: CALL 70417 0 5
// veh := CreateVehicle ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: CALL_OW 45
14382: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14383: LD_VAR 0 3
14387: PPUSH
14388: LD_INT 3
14390: PPUSH
14391: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14395: LD_VAR 0 3
14399: PPUSH
14400: LD_INT 29
14402: PPUSH
14403: LD_INT 0
14405: PPUSH
14406: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14410: LD_INT 0
14412: PPUSH
14413: LD_INT 7
14415: PUSH
14416: LD_OWVAR 67
14420: PLUS
14421: PPUSH
14422: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14426: CALL_OW 44
14430: PPUSH
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 52
// end ;
14440: GO 14351
14442: POP
14443: POP
// for i = 1 to 5 + Difficulty do
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: DOUBLE
14450: LD_INT 1
14452: DEC
14453: ST_TO_ADDR
14454: LD_INT 5
14456: PUSH
14457: LD_OWVAR 67
14461: PLUS
14462: PUSH
14463: FOR_TO
14464: IFFALSE 14591
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14466: LD_INT 14
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 3
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 28
14485: PUSH
14486: LD_INT 26
14488: PUSH
14489: LD_INT 27
14491: PUSH
14492: LD_INT 25
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: LD_VAR 0 2
14505: PUSH
14506: LD_INT 4
14508: MOD
14509: PUSH
14510: LD_INT 1
14512: PLUS
14513: ARRAY
14514: PPUSH
14515: LD_INT 80
14517: PPUSH
14518: CALL 70417 0 5
// veh := CreateVehicle ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: CALL_OW 45
14531: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 4
14539: PPUSH
14540: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14544: LD_VAR 0 3
14548: PPUSH
14549: LD_INT 28
14551: PPUSH
14552: LD_INT 0
14554: PPUSH
14555: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14559: LD_INT 0
14561: PPUSH
14562: LD_INT 7
14564: PUSH
14565: LD_OWVAR 67
14569: PLUS
14570: PPUSH
14571: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14575: CALL_OW 44
14579: PPUSH
14580: LD_VAR 0 3
14584: PPUSH
14585: CALL_OW 52
// end ;
14589: GO 14463
14591: POP
14592: POP
// for i = 1 to 3 do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 3
14605: PUSH
14606: FOR_TO
14607: IFFALSE 14667
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14609: LD_INT 14
14611: PPUSH
14612: LD_INT 3
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: LD_INT 29
14620: PPUSH
14621: LD_INT 80
14623: PPUSH
14624: CALL 70417 0 5
// veh := CreateVehicle ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: CALL_OW 45
14637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14638: LD_VAR 0 3
14642: PPUSH
14643: LD_INT 4
14645: PPUSH
14646: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14650: LD_VAR 0 3
14654: PPUSH
14655: LD_INT 28
14657: PPUSH
14658: LD_INT 0
14660: PPUSH
14661: CALL_OW 49
// end ;
14665: GO 14606
14667: POP
14668: POP
// end ;
14669: LD_VAR 0 1
14673: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14674: LD_INT 22
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: IFFALSE 14988
14690: GO 14692
14692: DISABLE
14693: LD_INT 0
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 25
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PPUSH
14727: CALL_OW 69
14731: PUSH
14732: LD_EXP 94
14736: DIFF
14737: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 2
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: PUSH
14758: LD_EXP 94
14762: PUSH
14763: LD_VAR 0 3
14767: UNION
14768: DIFF
14769: ST_TO_ADDR
// if Khatam then
14770: LD_EXP 94
14774: IFFALSE 14791
// ComMoveXY ( Khatam , 211 , 92 ) ;
14776: LD_EXP 94
14780: PPUSH
14781: LD_INT 211
14783: PPUSH
14784: LD_INT 92
14786: PPUSH
14787: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14791: LD_INT 197
14793: PPUSH
14794: LD_INT 80
14796: PPUSH
14797: LD_INT 2
14799: PPUSH
14800: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14804: LD_INT 213
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 2
14812: PPUSH
14813: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14817: LD_INT 215
14819: PPUSH
14820: LD_INT 129
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 441
// if sci then
14830: LD_VAR 0 3
14834: IFFALSE 14855
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14836: LD_VAR 0 3
14840: PUSH
14841: LD_INT 1
14843: ARRAY
14844: PPUSH
14845: LD_INT 197
14847: PPUSH
14848: LD_INT 80
14850: PPUSH
14851: CALL_OW 158
// if sci > 1 then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 1
14862: GREATER
14863: IFFALSE 14884
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14865: LD_VAR 0 3
14869: PUSH
14870: LD_INT 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 213
14876: PPUSH
14877: LD_INT 90
14879: PPUSH
14880: CALL_OW 158
// if sci > 2 then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 2
14891: GREATER
14892: IFFALSE 14913
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14894: LD_VAR 0 3
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 215
14905: PPUSH
14906: LD_INT 129
14908: PPUSH
14909: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14913: LD_INT 35
14915: PPUSH
14916: CALL_OW 67
// for i in tmp do
14920: LD_ADDR_VAR 0 1
14924: PUSH
14925: LD_VAR 0 2
14929: PUSH
14930: FOR_IN
14931: IFFALSE 14969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_INT 81
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: PPUSH
14953: LD_VAR 0 1
14957: PPUSH
14958: CALL_OW 74
14962: PPUSH
14963: CALL_OW 115
14967: GO 14930
14969: POP
14970: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14971: LD_INT 22
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PPUSH
14981: CALL_OW 69
14985: NOT
14986: IFFALSE 14913
// end ; end_of_file
14988: PPOPN 3
14990: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14991: LD_INT 0
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// Video ( true ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 102263 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: LD_INT 7
15016: PPUSH
15017: LD_INT 0
15019: PPUSH
15020: CALL_OW 517
15024: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: DOUBLE
15031: LD_INT 1
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 1
15042: ARRAY
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15090
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15047: LD_VAR 0 5
15051: PUSH
15052: LD_INT 1
15054: ARRAY
15055: PUSH
15056: LD_VAR 0 2
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 5
15066: PUSH
15067: LD_INT 2
15069: ARRAY
15070: PUSH
15071: LD_VAR 0 2
15075: ARRAY
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: LD_INT 15
15082: NEG
15083: PPUSH
15084: CALL 102177 0 4
15088: GO 15044
15090: POP
15091: POP
// CenterNowOnUnits ( Powell ) ;
15092: LD_EXP 58
15096: PPUSH
15097: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15101: LD_ADDR_VAR 0 5
15105: PUSH
15106: LD_EXP 56
15110: PUSH
15111: EMPTY
15112: LIST
15113: ST_TO_ADDR
// if GirlNewVeh then
15114: LD_EXP 57
15118: IFFALSE 15136
// tmp := tmp ^ GirlNewVeh ;
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: LD_VAR 0 5
15129: PUSH
15130: LD_EXP 57
15134: ADD
15135: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15136: LD_VAR 0 5
15140: PPUSH
15141: LD_INT 60
15143: PPUSH
15144: LD_INT 109
15146: PPUSH
15147: CALL_OW 111
// if KappaStatus then
15151: LD_EXP 2
15155: IFFALSE 15207
// begin Say ( JMM , D1nT-JMM-1 ) ;
15157: LD_EXP 39
15161: PPUSH
15162: LD_STRING D1nT-JMM-1
15164: PPUSH
15165: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15169: LD_EXP 58
15173: PPUSH
15174: LD_STRING D1T-Pow-1
15176: PPUSH
15177: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15181: LD_EXP 39
15185: PPUSH
15186: LD_STRING D1T-JMM-2
15188: PPUSH
15189: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15193: LD_EXP 58
15197: PPUSH
15198: LD_STRING D1T-Pow-2
15200: PPUSH
15201: CALL_OW 88
// end else
15205: GO 15413
// if JMMGirlStatus then
15207: LD_EXP 6
15211: IFFALSE 15356
// begin Say ( JMM , D1T-JMM-1 ) ;
15213: LD_EXP 39
15217: PPUSH
15218: LD_STRING D1T-JMM-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15225: LD_EXP 58
15229: PPUSH
15230: LD_STRING D1T-Pow-1
15232: PPUSH
15233: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1T-JMM-3
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-3
15256: PPUSH
15257: CALL_OW 88
// if JMMGirl then
15261: LD_EXP 7
15265: IFFALSE 15354
// begin case JMMGirl of 1 :
15267: LD_EXP 7
15271: PUSH
15272: LD_INT 1
15274: DOUBLE
15275: EQUAL
15276: IFTRUE 15280
15278: GO 15295
15280: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15281: LD_EXP 40
15285: PPUSH
15286: LD_STRING D1T-Joan-3
15288: PPUSH
15289: CALL_OW 88
15293: GO 15342
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15318
15303: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15304: LD_EXP 42
15308: PPUSH
15309: LD_STRING D1T-Lisa-3
15311: PPUSH
15312: CALL_OW 88
15316: GO 15342
15318: LD_INT 3
15320: DOUBLE
15321: EQUAL
15322: IFTRUE 15326
15324: GO 15341
15326: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15327: LD_EXP 54
15331: PPUSH
15332: LD_STRING D1T-Con-3
15334: PPUSH
15335: CALL_OW 88
15339: GO 15342
15341: POP
// Say ( Powell , D1T-Pow-4 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-4
15349: PPUSH
15350: CALL_OW 88
// end ; end else
15354: GO 15413
// if not FastEnd then
15356: LD_EXP 11
15360: NOT
15361: IFFALSE 15389
// begin Say ( JMM , D1T-JMM-4 ) ;
15363: LD_EXP 39
15367: PPUSH
15368: LD_STRING D1T-JMM-4
15370: PPUSH
15371: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15375: LD_EXP 58
15379: PPUSH
15380: LD_STRING D1T-Pow-5
15382: PPUSH
15383: CALL_OW 88
// end else
15387: GO 15413
// begin Say ( JMM , D1nT-JMM-1 ) ;
15389: LD_EXP 39
15393: PPUSH
15394: LD_STRING D1nT-JMM-1
15396: PPUSH
15397: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15401: LD_EXP 58
15405: PPUSH
15406: LD_STRING D1nT-Pow-1
15408: PPUSH
15409: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15413: LD_INT 35
15415: PPUSH
15416: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15420: LD_EXP 56
15424: PPUSH
15425: CALL_OW 314
15429: NOT
15430: IFFALSE 15413
// ComExitVehicle ( JMM ) ;
15432: LD_EXP 39
15436: PPUSH
15437: CALL_OW 121
// wait ( 3 ) ;
15441: LD_INT 3
15443: PPUSH
15444: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15448: LD_EXP 39
15452: PPUSH
15453: LD_INT 60
15455: PPUSH
15456: LD_INT 94
15458: PPUSH
15459: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15463: LD_EXP 39
15467: PPUSH
15468: LD_EXP 58
15472: PPUSH
15473: CALL_OW 179
// if Joan then
15477: LD_EXP 40
15481: IFFALSE 15535
// begin ComExitVehicle ( Joan ) ;
15483: LD_EXP 40
15487: PPUSH
15488: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15492: LD_EXP 40
15496: PPUSH
15497: LD_INT 35
15499: PPUSH
15500: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15504: LD_EXP 40
15508: PPUSH
15509: LD_INT 65
15511: PPUSH
15512: LD_INT 104
15514: PPUSH
15515: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15519: LD_EXP 40
15523: PPUSH
15524: LD_EXP 39
15528: PPUSH
15529: CALL_OW 179
// end else
15533: GO 15669
// if Lisa and JMMGirl = 2 then
15535: LD_EXP 42
15539: PUSH
15540: LD_EXP 7
15544: PUSH
15545: LD_INT 2
15547: EQUAL
15548: AND
15549: IFFALSE 15603
// begin ComExitVehicle ( Lisa ) ;
15551: LD_EXP 42
15555: PPUSH
15556: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15560: LD_EXP 42
15564: PPUSH
15565: LD_INT 35
15567: PPUSH
15568: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15572: LD_EXP 42
15576: PPUSH
15577: LD_INT 65
15579: PPUSH
15580: LD_INT 104
15582: PPUSH
15583: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15587: LD_EXP 42
15591: PPUSH
15592: LD_EXP 39
15596: PPUSH
15597: CALL_OW 179
// end else
15601: GO 15669
// if Connie and JMMGirl = 3 then
15603: LD_EXP 54
15607: PUSH
15608: LD_EXP 7
15612: PUSH
15613: LD_INT 3
15615: EQUAL
15616: AND
15617: IFFALSE 15669
// begin ComExitVehicle ( Connie ) ;
15619: LD_EXP 54
15623: PPUSH
15624: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15628: LD_EXP 54
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15640: LD_EXP 54
15644: PPUSH
15645: LD_INT 65
15647: PPUSH
15648: LD_INT 104
15650: PPUSH
15651: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15655: LD_EXP 54
15659: PPUSH
15660: LD_EXP 39
15664: PPUSH
15665: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15669: LD_INT 35
15671: PPUSH
15672: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15676: LD_EXP 39
15680: PPUSH
15681: LD_EXP 58
15685: PPUSH
15686: CALL_OW 296
15690: PUSH
15691: LD_INT 6
15693: LESS
15694: IFFALSE 15669
// wait ( 0 0$0.5 ) ;
15696: LD_INT 18
15698: PPUSH
15699: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15703: LD_EXP 39
15707: PPUSH
15708: LD_STRING D1-JMM-1
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15716: LD_EXP 58
15720: PPUSH
15721: LD_STRING D1-Pow-1
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$2 ) ;
15735: LD_INT 70
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15742: LD_INT 170
15744: PPUSH
15745: LD_INT 99
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 6
15753: NEG
15754: PPUSH
15755: CALL 102177 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15759: LD_INT 174
15761: PPUSH
15762: LD_INT 115
15764: PPUSH
15765: LD_INT 1
15767: PPUSH
15768: LD_INT 6
15770: NEG
15771: PPUSH
15772: CALL 102177 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15776: LD_INT 169
15778: PPUSH
15779: LD_INT 71
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_INT 6
15787: NEG
15788: PPUSH
15789: CALL 102177 0 4
// if not dialogue_skipped then
15793: LD_OWVAR 59
15797: NOT
15798: IFFALSE 15817
// begin CenterOnXY ( 170 , 99 ) ;
15800: LD_INT 170
15802: PPUSH
15803: LD_INT 99
15805: PPUSH
15806: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15810: LD_INT 80
15812: PPUSH
15813: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15817: LD_INT 75
15819: PPUSH
15820: LD_INT 53
15822: PPUSH
15823: LD_INT 1
15825: PPUSH
15826: LD_INT 9
15828: NEG
15829: PPUSH
15830: CALL 102177 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15834: LD_INT 54
15836: PPUSH
15837: LD_INT 42
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 9
15845: NEG
15846: PPUSH
15847: CALL 102177 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15851: LD_INT 62
15853: PPUSH
15854: LD_INT 51
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_INT 9
15862: NEG
15863: PPUSH
15864: CALL 102177 0 4
// if not dialogue_skipped then
15868: LD_OWVAR 59
15872: NOT
15873: IFFALSE 15892
// begin CenterOnXY ( 75 , 53 ) ;
15875: LD_INT 75
15877: PPUSH
15878: LD_INT 53
15880: PPUSH
15881: CALL_OW 84
// wait ( 0 0$4 ) ;
15885: LD_INT 140
15887: PPUSH
15888: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15892: LD_EXP 58
15896: PPUSH
15897: CALL_OW 87
// if not dialogue_skipped then
15901: LD_OWVAR 59
15905: NOT
15906: IFFALSE 15915
// wait ( 0 0$2 ) ;
15908: LD_INT 70
15910: PPUSH
15911: CALL_OW 67
// sync ;
15915: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15916: LD_EXP 39
15920: PPUSH
15921: LD_STRING D1-JMM-2
15923: PPUSH
15924: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15928: LD_EXP 58
15932: PPUSH
15933: LD_STRING D1-Pow-2
15935: PPUSH
15936: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15940: LD_EXP 39
15944: PPUSH
15945: LD_STRING D1-JMM-3
15947: PPUSH
15948: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15952: LD_EXP 58
15956: PPUSH
15957: LD_STRING D1-Pow-3
15959: PPUSH
15960: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15964: LD_EXP 39
15968: PPUSH
15969: LD_STRING D1-JMM-4
15971: PPUSH
15972: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-4
15983: PPUSH
15984: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-5
15995: PPUSH
15996: CALL_OW 88
// async ;
16000: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16001: LD_EXP 58
16005: PPUSH
16006: LD_STRING D1-Pow-5
16008: PPUSH
16009: CALL_OW 88
// if not dialogue_skipped then
16013: LD_OWVAR 59
16017: NOT
16018: IFFALSE 16027
// wait ( 0 0$3.6 ) ;
16020: LD_INT 126
16022: PPUSH
16023: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16027: LD_INT 134
16029: PPUSH
16030: LD_INT 210
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: LD_INT 11
16038: NEG
16039: PPUSH
16040: CALL 102177 0 4
// if not dialogue_skipped then
16044: LD_OWVAR 59
16048: NOT
16049: IFFALSE 16068
// begin CenterOnXY ( 134 , 210 ) ;
16051: LD_INT 134
16053: PPUSH
16054: LD_INT 210
16056: PPUSH
16057: CALL_OW 84
// wait ( 0 0$2 ) ;
16061: LD_INT 70
16063: PPUSH
16064: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16068: LD_INT 101
16070: PPUSH
16071: LD_INT 159
16073: PPUSH
16074: LD_INT 1
16076: PPUSH
16077: LD_INT 10
16079: NEG
16080: PPUSH
16081: CALL 102177 0 4
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16109
// begin CenterOnXY ( 101 , 159 ) ;
16092: LD_INT 101
16094: PPUSH
16095: LD_INT 159
16097: PPUSH
16098: CALL_OW 84
// wait ( 0 0$2 ) ;
16102: LD_INT 70
16104: PPUSH
16105: CALL_OW 67
// end ; sync ;
16109: SYNC
// CenterNowOnUnits ( Powell ) ;
16110: LD_EXP 58
16114: PPUSH
16115: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16119: LD_ADDR_VAR 0 6
16123: PUSH
16124: LD_INT 1
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 5
16138: PUSH
16139: LD_INT 6
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: ST_TO_ADDR
// if not dialogue_skipped then
16150: LD_OWVAR 59
16154: NOT
16155: IFFALSE 16324
// begin game_speed := 4 ;
16157: LD_ADDR_OWVAR 65
16161: PUSH
16162: LD_INT 4
16164: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16165: LD_INT 210
16167: PPUSH
16168: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16172: LD_ADDR_VAR 0 7
16176: PUSH
16177: LD_STRING Q1
16179: PPUSH
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 98
16189: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16190: LD_ADDR_VAR 0 7
16194: PUSH
16195: LD_STRING Q1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: CALL_OW 98
16207: ST_TO_ADDR
// options = options diff dec ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: DIFF
16223: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16224: LD_VAR 0 7
16228: PPUSH
16229: LD_VAR 0 6
16233: PPUSH
16234: CALL 17796 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16238: LD_VAR 0 7
16242: PUSH
16243: LD_INT 5
16245: PUSH
16246: LD_INT 6
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: IN
16253: PUSH
16254: LD_VAR 0 6
16258: PUSH
16259: LD_INT 2
16261: EQUAL
16262: OR
16263: IFFALSE 16190
// if not ( dec in [ 5 , 6 ] ) then
16265: LD_VAR 0 7
16269: PUSH
16270: LD_INT 5
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: IN
16280: NOT
16281: IFFALSE 16324
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1a
16290: PPUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 98
16305: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16306: LD_VAR 0 7
16310: PUSH
16311: LD_INT 4
16313: PLUS
16314: PPUSH
16315: LD_VAR 0 6
16319: PPUSH
16320: CALL 17796 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16324: LD_INT 81
16326: PPUSH
16327: LD_INT 127
16329: PPUSH
16330: CALL_OW 84
// amount := 5 ;
16334: LD_ADDR_VAR 0 8
16338: PUSH
16339: LD_INT 5
16341: ST_TO_ADDR
// macmilan_squad := [ ] ;
16342: LD_ADDR_VAR 0 9
16346: PUSH
16347: EMPTY
16348: ST_TO_ADDR
// if vip < amount then
16349: LD_EXP 59
16353: PUSH
16354: LD_VAR 0 8
16358: LESS
16359: IFFALSE 16403
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: LD_EXP 59
16370: PUSH
16371: LD_INT 22
16373: PUSH
16374: LD_INT 4
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: UNION
16400: ST_TO_ADDR
16401: GO 16413
// tmp := vip ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_EXP 59
16412: ST_TO_ADDR
// tmp := tmp diff Powell ;
16413: LD_ADDR_VAR 0 5
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: LD_EXP 58
16427: DIFF
16428: ST_TO_ADDR
// if tmp < amount then
16429: LD_VAR 0 5
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16451
// amount := tmp ;
16441: LD_ADDR_VAR 0 8
16445: PUSH
16446: LD_VAR 0 5
16450: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16451: LD_VAR 0 5
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 257
16464: PUSH
16465: LD_INT 2
16467: NONEQUAL
16468: IFFALSE 16530
// begin if IsInUnit ( tmp [ 1 ] ) then
16470: LD_VAR 0 5
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: PPUSH
16479: CALL_OW 310
16483: IFFALSE 16498
// ComExitBuilding ( tmp [ 1 ] ) ;
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: ARRAY
16493: PPUSH
16494: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16498: LD_VAR 0 5
16502: PUSH
16503: LD_INT 1
16505: ARRAY
16506: PPUSH
16507: LD_INT 387
16509: PPUSH
16510: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_INT 1
16521: ARRAY
16522: PPUSH
16523: LD_INT 2
16525: PPUSH
16526: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16530: LD_EXP 39
16534: PPUSH
16535: LD_INT 82
16537: PPUSH
16538: LD_INT 129
16540: PPUSH
16541: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16545: LD_EXP 39
16549: PPUSH
16550: LD_EXP 58
16554: PPUSH
16555: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16559: LD_INT 22
16561: PUSH
16562: LD_INT 1
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: PUSH
16574: LD_EXP 39
16578: DIFF
16579: PPUSH
16580: LD_INT 84
16582: PPUSH
16583: LD_INT 128
16585: PPUSH
16586: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16590: LD_INT 22
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: PUSH
16605: LD_EXP 39
16609: DIFF
16610: PPUSH
16611: LD_EXP 39
16615: PPUSH
16616: CALL_OW 179
// for i = 1 to amount do
16620: LD_ADDR_VAR 0 2
16624: PUSH
16625: DOUBLE
16626: LD_INT 1
16628: DEC
16629: ST_TO_ADDR
16630: LD_VAR 0 8
16634: PUSH
16635: FOR_TO
16636: IFFALSE 16804
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16638: LD_ADDR_VAR 0 9
16642: PUSH
16643: LD_VAR 0 9
16647: PUSH
16648: LD_VAR 0 5
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: ADD
16659: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16660: LD_VAR 0 5
16664: PUSH
16665: LD_VAR 0 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 310
16675: IFFALSE 16692
// AddComExitBuilding ( tmp [ i ] ) ;
16677: LD_VAR 0 5
16681: PUSH
16682: LD_VAR 0 2
16686: ARRAY
16687: PPUSH
16688: CALL_OW 182
// if i = 2 and JMMNewVeh then
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: EQUAL
16700: PUSH
16701: LD_EXP 56
16705: AND
16706: IFFALSE 16764
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16708: LD_VAR 0 5
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_EXP 56
16723: PPUSH
16724: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: PPUSH
16739: LD_INT 86
16741: PPUSH
16742: LD_INT 133
16744: PPUSH
16745: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: LD_INT 8
16777: PPUSH
16778: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16782: LD_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: ARRAY
16792: PPUSH
16793: LD_EXP 39
16797: PPUSH
16798: CALL_OW 179
// end ;
16802: GO 16635
16804: POP
16805: POP
// if GirlNewVeh then
16806: LD_EXP 57
16810: IFFALSE 16824
// SetSide ( GirlNewVeh , 4 ) ;
16812: LD_EXP 57
16816: PPUSH
16817: LD_INT 4
16819: PPUSH
16820: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16824: LD_INT 35
16826: PPUSH
16827: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_INT 95
16838: PUSH
16839: LD_INT 9
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 72
16850: PUSH
16851: LD_INT 0
16853: EQUAL
16854: PUSH
16855: LD_EXP 39
16859: PPUSH
16860: LD_INT 9
16862: PPUSH
16863: CALL_OW 308
16867: NOT
16868: AND
16869: IFFALSE 16824
// wait ( 0 0$2 ) ;
16871: LD_INT 70
16873: PPUSH
16874: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16878: LD_VAR 0 9
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16890: LD_INT 21
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 92
16902: PUSH
16903: LD_INT 83
16905: PUSH
16906: LD_INT 130
16908: PUSH
16909: LD_INT 10
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PPUSH
16927: LD_INT 1
16929: PPUSH
16930: CALL_OW 235
// Video ( false ) ;
16934: LD_INT 0
16936: PPUSH
16937: CALL 102263 0 1
// ChangeMissionObjectives ( M1 ) ;
16941: LD_STRING M1
16943: PPUSH
16944: CALL_OW 337
// SaveForQuickRestart ;
16948: CALL_OW 22
// missionStart := true ;
16952: LD_ADDR_EXP 13
16956: PUSH
16957: LD_INT 1
16959: ST_TO_ADDR
// missionStage := 2 ;
16960: LD_ADDR_EXP 15
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16968: LD_INT 105
16970: PPUSH
16971: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16975: LD_ADDR_VAR 0 5
16979: PUSH
16980: LD_INT 22
16982: PUSH
16983: LD_INT 4
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 21
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 69
17008: PUSH
17009: LD_EXP 58
17013: DIFF
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 5
17019: NOT
17020: IFFALSE 17035
// tmp := [ Powell ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_EXP 58
17031: PUSH
17032: EMPTY
17033: LIST
17034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17035: LD_ADDR_EXP 116
17039: PUSH
17040: LD_EXP 116
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 23
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 21
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: PUSH
17095: LD_EXP 58
17099: DIFF
17100: PPUSH
17101: CALL_OW 1
17105: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 34
17123: PUSH
17124: LD_INT 12
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: PUSH
17140: LD_INT 1
17142: ARRAY
17143: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17144: LD_VAR 0 5
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: CALL_OW 310
17157: IFFALSE 17172
// ComExitBuilding ( tmp [ 1 ] ) ;
17159: LD_VAR 0 5
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: PPUSH
17168: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17172: LD_VAR 0 5
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: PPUSH
17181: LD_VAR 0 4
17185: PPUSH
17186: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17190: LD_VAR 0 5
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: LD_INT 80
17201: PPUSH
17202: LD_INT 136
17204: PPUSH
17205: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17209: LD_VAR 0 5
17213: PUSH
17214: LD_INT 1
17216: ARRAY
17217: PPUSH
17218: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17222: LD_VAR 0 5
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_INT 59
17233: PPUSH
17234: LD_INT 112
17236: PPUSH
17237: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17241: LD_VAR 0 5
17245: PUSH
17246: LD_INT 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17254: LD_EXP 40
17258: PUSH
17259: LD_EXP 40
17263: PPUSH
17264: CALL_OW 255
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: AND
17273: IFFALSE 17299
// begin Say ( Joan , D3W-Joan-1 ) ;
17275: LD_EXP 40
17279: PPUSH
17280: LD_STRING D3W-Joan-1
17282: PPUSH
17283: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17287: LD_EXP 39
17291: PPUSH
17292: LD_STRING D3W-JMM-1
17294: PPUSH
17295: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17299: LD_EXP 42
17303: PUSH
17304: LD_EXP 42
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: PUSH
17319: LD_EXP 42
17323: PUSH
17324: LD_EXP 59
17328: IN
17329: NOT
17330: AND
17331: IFFALSE 17357
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17333: LD_EXP 42
17337: PPUSH
17338: LD_STRING D3W-Lisa-1
17340: PPUSH
17341: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17345: LD_EXP 39
17349: PPUSH
17350: LD_STRING D3W-JMM-1
17352: PPUSH
17353: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17357: LD_EXP 54
17361: PUSH
17362: LD_EXP 54
17366: PPUSH
17367: CALL_OW 255
17371: PUSH
17372: LD_INT 1
17374: EQUAL
17375: AND
17376: IFFALSE 17402
// begin Say ( Connie , D3W-Con-1 ) ;
17378: LD_EXP 54
17382: PPUSH
17383: LD_STRING D3W-Con-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17390: LD_EXP 39
17394: PPUSH
17395: LD_STRING D3W-JMM-1
17397: PPUSH
17398: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17402: LD_EXP 42
17406: PUSH
17407: LD_EXP 59
17411: IN
17412: PUSH
17413: LD_EXP 42
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 1
17425: EQUAL
17426: AND
17427: IFFALSE 17443
// Say ( Lisa , D3nW-Lisa-1 ) else
17429: LD_EXP 42
17433: PPUSH
17434: LD_STRING D3nW-Lisa-1
17436: PPUSH
17437: CALL_OW 88
17441: GO 17687
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17443: LD_EXP 45
17447: PUSH
17448: LD_EXP 59
17452: IN
17453: PUSH
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 1
17466: EQUAL
17467: AND
17468: IFFALSE 17484
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17470: LD_EXP 45
17474: PPUSH
17475: LD_STRING D3nW-Cyrus-1
17477: PPUSH
17478: CALL_OW 88
17482: GO 17687
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17484: LD_EXP 44
17488: PUSH
17489: LD_EXP 59
17493: IN
17494: PUSH
17495: LD_EXP 44
17499: PPUSH
17500: CALL_OW 255
17504: PUSH
17505: LD_INT 1
17507: EQUAL
17508: AND
17509: IFFALSE 17525
// Say ( Bobby , D3nW-Bobby-1 ) else
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING D3nW-Bobby-1
17518: PPUSH
17519: CALL_OW 88
17523: GO 17687
// if Gary in vip and GetSide ( Gary ) = 1 then
17525: LD_EXP 51
17529: PUSH
17530: LD_EXP 59
17534: IN
17535: PUSH
17536: LD_EXP 51
17540: PPUSH
17541: CALL_OW 255
17545: PUSH
17546: LD_INT 1
17548: EQUAL
17549: AND
17550: IFFALSE 17566
// Say ( Gary , D3nW-Gary-1 ) else
17552: LD_EXP 51
17556: PPUSH
17557: LD_STRING D3nW-Gary-1
17559: PPUSH
17560: CALL_OW 88
17564: GO 17687
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17566: LD_EXP 43
17570: PUSH
17571: LD_EXP 59
17575: IN
17576: PUSH
17577: LD_EXP 43
17581: PPUSH
17582: CALL_OW 255
17586: PUSH
17587: LD_INT 1
17589: EQUAL
17590: AND
17591: IFFALSE 17607
// Say ( Donaldson , D3nW-Don-1 ) else
17593: LD_EXP 43
17597: PPUSH
17598: LD_STRING D3nW-Don-1
17600: PPUSH
17601: CALL_OW 88
17605: GO 17687
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17607: LD_EXP 50
17611: PUSH
17612: LD_EXP 59
17616: IN
17617: PUSH
17618: LD_EXP 50
17622: PPUSH
17623: CALL_OW 255
17627: PUSH
17628: LD_INT 1
17630: EQUAL
17631: AND
17632: IFFALSE 17648
// Say ( Cornel , D3nW-Corn-1 ) else
17634: LD_EXP 50
17638: PPUSH
17639: LD_STRING D3nW-Corn-1
17641: PPUSH
17642: CALL_OW 88
17646: GO 17687
// if Frank in vip and GetSide ( Frank ) = 1 then
17648: LD_EXP 52
17652: PUSH
17653: LD_EXP 59
17657: IN
17658: PUSH
17659: LD_EXP 52
17663: PPUSH
17664: CALL_OW 255
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: AND
17673: IFFALSE 17687
// Say ( Frank , D3nW-Frank-1 ) ;
17675: LD_EXP 52
17679: PPUSH
17680: LD_STRING D3nW-Frank-1
17682: PPUSH
17683: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17687: LD_EXP 59
17691: PPUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PPUSH
17702: CALL_OW 72
17706: IFFALSE 17732
// begin Say ( JMM , D3nW-JMM-1 ) ;
17708: LD_EXP 39
17712: PPUSH
17713: LD_STRING D3nW-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17720: LD_EXP 39
17724: PPUSH
17725: LD_STRING D3nW-JMM-1a
17727: PPUSH
17728: CALL_OW 88
// end ; t := 0 0$00 ;
17732: LD_ADDR_VAR 0 3
17736: PUSH
17737: LD_INT 0
17739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17740: LD_INT 35
17742: PPUSH
17743: CALL_OW 67
// t := t + 0 0$1 ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 3
17756: PUSH
17757: LD_INT 35
17759: PLUS
17760: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17761: LD_INT 59
17763: PPUSH
17764: LD_INT 112
17766: PPUSH
17767: CALL_OW 428
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 2100
17779: GREATER
17780: OR
17781: IFFALSE 17740
// activeAttacks := true ;
17783: LD_ADDR_EXP 16
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17796: LD_INT 0
17798: PPUSH
// case question of 1 :
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 1
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17863
17812: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D2Mot-JMM-1
17820: PPUSH
17821: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17825: LD_EXP 58
17829: PPUSH
17830: LD_STRING D2Mot-Pow-1
17832: PPUSH
17833: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17837: LD_EXP 39
17841: PPUSH
17842: LD_STRING D2Mot-JMM-2
17844: PPUSH
17845: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17849: LD_EXP 58
17853: PPUSH
17854: LD_STRING D2Mot-Pow-2
17856: PPUSH
17857: CALL_OW 88
// end ; 2 :
17861: GO 18214
17863: LD_INT 2
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17947
17871: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Rus-JMM-1
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Rus-Pow-1
17891: PPUSH
17892: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17896: LD_EXP 39
17900: PPUSH
17901: LD_STRING D2Rus-JMM-2
17903: PPUSH
17904: CALL_OW 88
// if not ( 3 in list_of_q ) then
17908: LD_INT 3
17910: PUSH
17911: LD_VAR 0 2
17915: IN
17916: NOT
17917: IFFALSE 17933
// Say ( Powell , D2Rus-Pow-2 ) else
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-2
17926: PPUSH
17927: CALL_OW 88
17931: GO 17945
// Say ( Powell , D2Rus-Pow-2a ) ;
17933: LD_EXP 58
17937: PPUSH
17938: LD_STRING D2Rus-Pow-2a
17940: PPUSH
17941: CALL_OW 88
// end ; 3 :
17945: GO 18214
17947: LD_INT 3
17949: DOUBLE
17950: EQUAL
17951: IFTRUE 17955
17953: GO 18040
17955: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17956: LD_EXP 39
17960: PPUSH
17961: LD_STRING D2Leg-JMM-1
17963: PPUSH
17964: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Leg-Pow-1
17975: PPUSH
17976: CALL_OW 88
// if 2 in list_of_q then
17980: LD_INT 2
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: IFFALSE 18014
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17990: LD_EXP 39
17994: PPUSH
17995: LD_STRING D2Leg-JMM-2
17997: PPUSH
17998: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18002: LD_EXP 58
18006: PPUSH
18007: LD_STRING D2Leg-Pow-2
18009: PPUSH
18010: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18014: LD_EXP 39
18018: PPUSH
18019: LD_STRING D2Leg-JMM-3
18021: PPUSH
18022: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Leg-Pow-3
18033: PPUSH
18034: CALL_OW 88
// end ; 4 :
18038: GO 18214
18040: LD_INT 4
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18123
18048: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Ar-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Ar-Pow-1
18068: PPUSH
18069: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18073: LD_EXP 39
18077: PPUSH
18078: LD_STRING D2Ar-JMM-2
18080: PPUSH
18081: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18085: LD_EXP 58
18089: PPUSH
18090: LD_STRING D2Ar-Pow-2
18092: PPUSH
18093: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18097: LD_EXP 39
18101: PPUSH
18102: LD_STRING D2Ar-JMM-3
18104: PPUSH
18105: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18109: LD_EXP 58
18113: PPUSH
18114: LD_STRING D2Ar-Pow-3
18116: PPUSH
18117: CALL_OW 88
// end ; 5 :
18121: GO 18214
18123: LD_INT 5
18125: DOUBLE
18126: EQUAL
18127: IFTRUE 18131
18129: GO 18146
18131: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Conf-JMM-1
18139: PPUSH
18140: CALL_OW 88
18144: GO 18214
18146: LD_INT 6
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18213
18154: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18155: LD_EXP 39
18159: PPUSH
18160: LD_STRING D2Com-JMM-1
18162: PPUSH
18163: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18167: LD_EXP 58
18171: PPUSH
18172: LD_STRING D2Com-Pow-1
18174: PPUSH
18175: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18179: LD_EXP 39
18183: PPUSH
18184: LD_STRING D2Com-JMM-2
18186: PPUSH
18187: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18191: LD_EXP 58
18195: PPUSH
18196: LD_STRING D2Com-Pow-2
18198: PPUSH
18199: CALL_OW 88
// powellAngerQuery := true ;
18203: LD_ADDR_EXP 36
18207: PUSH
18208: LD_INT 1
18210: ST_TO_ADDR
// end ; end ;
18211: GO 18214
18213: POP
// end ;
18214: LD_VAR 0 3
18218: RET
// every 0 0$5 trigger missionStart do var tmp ;
18219: LD_EXP 13
18223: IFFALSE 18506
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18231: LD_INT 35
18233: PPUSH
18234: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18238: LD_INT 14
18240: PPUSH
18241: LD_INT 22
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 70
18255: PUSH
18256: LD_EXP 15
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 3
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: AND
18280: IFFALSE 18496
// begin powellAnger := powellAnger + 1 ;
18282: LD_ADDR_EXP 17
18286: PUSH
18287: LD_EXP 17
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// Video ( true ) ;
18296: LD_INT 1
18298: PPUSH
18299: CALL 102263 0 1
// CenterNowOnUnits ( tmp ) ;
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18312: LD_INT 14
18314: PPUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 1
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 70
18329: PPUSH
18330: LD_INT 86
18332: PPUSH
18333: LD_INT 133
18335: PPUSH
18336: CALL_OW 111
// async ;
18340: ASYNC
// case powellAnger of 1 :
18341: LD_EXP 17
18345: PUSH
18346: LD_INT 1
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18369
18354: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18355: LD_EXP 58
18359: PPUSH
18360: LD_STRING DBack1-Pow-1
18362: PPUSH
18363: CALL_OW 88
18367: GO 18416
18369: LD_INT 2
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18392
18377: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18378: LD_EXP 58
18382: PPUSH
18383: LD_STRING DBack2-Pow-1
18385: PPUSH
18386: CALL_OW 88
18390: GO 18416
18392: LD_INT 3
18394: DOUBLE
18395: EQUAL
18396: IFTRUE 18400
18398: GO 18415
18400: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18401: LD_EXP 58
18405: PPUSH
18406: LD_STRING DBack3-Pow-1
18408: PPUSH
18409: CALL_OW 88
18413: GO 18416
18415: POP
// sync ;
18416: SYNC
// repeat wait ( 0 0$1 ) ;
18417: LD_INT 35
18419: PPUSH
18420: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18424: LD_INT 14
18426: PPUSH
18427: LD_INT 22
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL_OW 70
18441: PPUSH
18442: LD_INT 86
18444: PPUSH
18445: LD_INT 133
18447: PPUSH
18448: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18452: LD_INT 14
18454: PPUSH
18455: LD_INT 22
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PPUSH
18465: CALL_OW 70
18469: NOT
18470: IFFALSE 18417
// if powellAnger >= 3 then
18472: LD_EXP 17
18476: PUSH
18477: LD_INT 3
18479: GREATEREQUAL
18480: IFFALSE 18489
// YouLost ( Dismissed ) ;
18482: LD_STRING Dismissed
18484: PPUSH
18485: CALL_OW 104
// Video ( false ) ;
18489: LD_INT 0
18491: PPUSH
18492: CALL 102263 0 1
// end ; until missionStage > 5 ;
18496: LD_EXP 15
18500: PUSH
18501: LD_INT 5
18503: GREATER
18504: IFFALSE 18231
// end ;
18506: PPOPN 1
18508: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18509: LD_EXP 13
18513: PUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 21
18526: PUSH
18527: LD_INT 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PPUSH
18538: CALL_OW 69
18542: PUSH
18543: LD_INT 4
18545: GREATEREQUAL
18546: AND
18547: PUSH
18548: LD_EXP 15
18552: PUSH
18553: LD_INT 2
18555: EQUAL
18556: AND
18557: IFFALSE 20380
18559: GO 18561
18561: DISABLE
18562: LD_INT 0
18564: PPUSH
18565: PPUSH
18566: PPUSH
18567: PPUSH
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// begin missionStage := 3 ;
18572: LD_ADDR_EXP 15
18576: PUSH
18577: LD_INT 3
18579: ST_TO_ADDR
// retreat := false ;
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18588: LD_ADDR_VAR 0 5
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18622: LD_ADDR_VAR 0 6
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 5
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: ST_TO_ADDR
// if not bar then
18656: LD_VAR 0 6
18660: NOT
18661: IFFALSE 18714
// begin repeat wait ( 0 0$1 ) ;
18663: LD_INT 35
18665: PPUSH
18666: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18670: LD_INT 22
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 3
18682: PUSH
18683: LD_INT 57
18685: PUSH
18686: EMPTY
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 30
18695: PUSH
18696: LD_INT 5
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL_OW 69
18712: IFFALSE 18663
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18714: LD_ADDR_VAR 0 6
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 4
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 5
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL_OW 69
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18755: LD_EXP 135
18759: PUSH
18760: LD_INT 4
18762: ARRAY
18763: PUSH
18764: LD_INT 4
18766: GREATEREQUAL
18767: IFFALSE 18748
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18769: LD_ADDR_VAR 0 2
18773: PUSH
18774: LD_INT 22
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: LD_INT 2
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 1
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: LD_INT 25
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: LD_INT 25
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 25
18819: PUSH
18820: LD_INT 4
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 25
18829: PUSH
18830: LD_INT 5
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL_OW 69
18853: PUSH
18854: LD_EXP 58
18858: PUSH
18859: LD_EXP 59
18863: ADD
18864: DIFF
18865: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 2
18875: PPUSH
18876: LD_INT 26
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 72
18890: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_VAR 0 2
18900: PUSH
18901: LD_VAR 0 3
18905: DIFF
18906: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18907: LD_ADDR_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: LD_INT 1
18919: PPUSH
18920: CALL 100797 0 2
18924: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18925: LD_ADDR_VAR 0 3
18929: PUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: CALL 100797 0 2
18942: ST_TO_ADDR
// for i = 1 to 4 do
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: DOUBLE
18949: LD_INT 1
18951: DEC
18952: ST_TO_ADDR
18953: LD_INT 4
18955: PUSH
18956: FOR_TO
18957: IFFALSE 19123
// begin if tmp2 then
18959: LD_VAR 0 3
18963: IFFALSE 19044
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18965: LD_ADDR_EXP 18
18969: PUSH
18970: LD_EXP 18
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: LD_EXP 18
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PUSH
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: ARRAY
18997: ADD
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19004: LD_VAR 0 3
19008: PUSH
19009: LD_VAR 0 3
19013: ARRAY
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_VAR 0 3
19031: PPUSH
19032: LD_VAR 0 3
19036: PPUSH
19037: CALL_OW 3
19041: ST_TO_ADDR
// end else
19042: GO 19121
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19044: LD_ADDR_EXP 18
19048: PUSH
19049: LD_EXP 18
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: LD_EXP 18
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: ADD
19077: PPUSH
19078: CALL_OW 1
19082: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19083: LD_VAR 0 2
19087: PUSH
19088: LD_VAR 0 2
19092: ARRAY
19093: PPUSH
19094: LD_INT 1
19096: PPUSH
19097: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19101: LD_ADDR_VAR 0 2
19105: PUSH
19106: LD_VAR 0 2
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 3
19120: ST_TO_ADDR
// end ; end ;
19121: GO 18956
19123: POP
19124: POP
// if tmp2 then
19125: LD_VAR 0 3
19129: IFFALSE 19147
// tmp := tmp union tmp2 ;
19131: LD_ADDR_VAR 0 2
19135: PUSH
19136: LD_VAR 0 2
19140: PUSH
19141: LD_VAR 0 3
19145: UNION
19146: ST_TO_ADDR
// for i = 1 to 4 do
19147: LD_ADDR_VAR 0 1
19151: PUSH
19152: DOUBLE
19153: LD_INT 1
19155: DEC
19156: ST_TO_ADDR
19157: LD_INT 4
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19210
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19163: LD_ADDR_EXP 18
19167: PUSH
19168: LD_EXP 18
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: LD_EXP 18
19180: PUSH
19181: LD_INT 2
19183: ARRAY
19184: PUSH
19185: LD_VAR 0 2
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 1
19199: MINUS
19200: ARRAY
19201: ADD
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
19208: GO 19160
19210: POP
19211: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19212: LD_ADDR_EXP 116
19216: PUSH
19217: LD_EXP 116
19221: PPUSH
19222: LD_INT 4
19224: PPUSH
19225: LD_EXP 116
19229: PUSH
19230: LD_INT 4
19232: ARRAY
19233: PUSH
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: DIFF
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19249: LD_VAR 0 5
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: CALL_OW 313
19262: IFFALSE 19317
// begin for i in UnitsInside ( arm [ 1 ] ) do
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_VAR 0 5
19273: PUSH
19274: LD_INT 1
19276: ARRAY
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19315
// begin ComExitBuilding ( i ) ;
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 6
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 180
// end ;
19313: GO 19283
19315: POP
19316: POP
// end ; wait ( 0 0$3 ) ;
19317: LD_INT 105
19319: PPUSH
19320: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_EXP 18
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19446
// begin if IsInUnit ( i ) then
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 310
19350: IFFALSE 19361
// ComExitBuilding ( i ) ;
19352: LD_VAR 0 1
19356: PPUSH
19357: CALL_OW 122
// if GetClass ( i ) <> 1 then
19361: LD_VAR 0 1
19365: PPUSH
19366: CALL_OW 257
19370: PUSH
19371: LD_INT 1
19373: NONEQUAL
19374: IFFALSE 19415
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19376: LD_VAR 0 1
19380: PPUSH
19381: LD_VAR 0 5
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19394: LD_VAR 0 1
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 183
// AddComExitBuilding ( i ) ;
19406: LD_VAR 0 1
19410: PPUSH
19411: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19415: LD_VAR 0 1
19419: PPUSH
19420: LD_INT 60
19422: PPUSH
19423: LD_INT 94
19425: PPUSH
19426: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_EXP 58
19439: PPUSH
19440: CALL_OW 179
// end ;
19444: GO 19338
19446: POP
19447: POP
// wait ( 0 0$15 ) ;
19448: LD_INT 525
19450: PPUSH
19451: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19455: LD_EXP 58
19459: PPUSH
19460: LD_STRING D4-Pow-1
19462: PPUSH
19463: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19467: LD_ADDR_VAR 0 2
19471: PUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: LD_INT 26
19483: PUSH
19484: LD_INT 1
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PPUSH
19491: CALL_OW 72
19495: ST_TO_ADDR
// if tmp then
19496: LD_VAR 0 2
19500: IFFALSE 19518
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_STRING D4-Sol1-1
19513: PPUSH
19514: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19518: LD_EXP 58
19522: PPUSH
19523: LD_STRING D4-Pow-2
19525: PPUSH
19526: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19530: LD_ADDR_VAR 0 1
19534: PUSH
19535: DOUBLE
19536: LD_INT 1
19538: DEC
19539: ST_TO_ADDR
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PUSH
19549: FOR_TO
19550: IFFALSE 19643
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PPUSH
19567: LD_EXP 135
19571: PUSH
19572: LD_INT 4
19574: ARRAY
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19584: LD_ADDR_EXP 135
19588: PUSH
19589: LD_EXP 135
19593: PPUSH
19594: LD_INT 4
19596: PPUSH
19597: LD_EXP 135
19601: PUSH
19602: LD_INT 4
19604: ARRAY
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: CALL_OW 3
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19619: LD_INT 8
19621: PPUSH
19622: LD_EXP 18
19626: PUSH
19627: LD_INT 1
19629: ARRAY
19630: PUSH
19631: LD_VAR 0 1
19635: ARRAY
19636: PPUSH
19637: CALL_OW 471
// end ;
19641: GO 19549
19643: POP
19644: POP
// repeat wait ( 0 0$1 ) ;
19645: LD_INT 35
19647: PPUSH
19648: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 55
19663: PUSH
19664: EMPTY
19665: LIST
19666: PPUSH
19667: CALL_OW 72
19671: PUSH
19672: LD_INT 4
19674: GREATEREQUAL
19675: IFFALSE 19645
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19677: LD_EXP 18
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: PPUSH
19686: LD_INT 69
19688: PPUSH
19689: LD_INT 94
19691: PPUSH
19692: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19696: LD_EXP 18
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: LD_INT 82
19707: PPUSH
19708: LD_INT 83
19710: PPUSH
19711: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: LD_INT 77
19726: PPUSH
19727: LD_INT 69
19729: PPUSH
19730: CALL_OW 174
// repeat wait ( 3 ) ;
19734: LD_INT 3
19736: PPUSH
19737: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_EXP 18
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: FOR_IN
19756: IFFALSE 19892
// begin if GetLives ( i ) < 990 then
19758: LD_VAR 0 1
19762: PPUSH
19763: CALL_OW 256
19767: PUSH
19768: LD_INT 990
19770: LESS
19771: IFFALSE 19785
// SetLives ( i , 1000 ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: LD_INT 1000
19780: PPUSH
19781: CALL_OW 234
// if not IsInUnit ( i ) then
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 310
19794: NOT
19795: IFFALSE 19890
// begin if not HasTask ( i ) then
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 314
19806: NOT
19807: IFFALSE 19824
// ComMoveXY ( i , 64 , 93 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 64
19816: PPUSH
19817: LD_INT 93
19819: PPUSH
19820: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19824: LD_VAR 0 4
19828: NOT
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 258
19839: PUSH
19840: LD_INT 1
19842: EQUAL
19843: AND
19844: IFFALSE 19890
// begin retreat := true ;
19846: LD_ADDR_VAR 0 4
19850: PUSH
19851: LD_INT 1
19853: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: LD_INT 2
19861: PPUSH
19862: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_STRING D4a-Sol1-1
19873: PPUSH
19874: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19878: LD_EXP 58
19882: PPUSH
19883: LD_STRING D4a-Pow-1
19885: PPUSH
19886: CALL_OW 88
// end ; end ; end ;
19890: GO 19755
19892: POP
19893: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19894: LD_EXP 18
19898: PUSH
19899: LD_INT 1
19901: ARRAY
19902: PPUSH
19903: LD_INT 95
19905: PUSH
19906: LD_INT 9
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 3
19915: PUSH
19916: LD_INT 55
19918: PUSH
19919: EMPTY
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PPUSH
19930: CALL_OW 72
19934: PUSH
19935: LD_INT 4
19937: GREATEREQUAL
19938: IFFALSE 19734
// for i in powellSquadAttack [ 1 ] do
19940: LD_ADDR_VAR 0 1
19944: PUSH
19945: LD_EXP 18
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20091
// begin if GetTag ( i ) = 2 then
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 110
19966: PUSH
19967: LD_INT 2
19969: EQUAL
19970: IFFALSE 20032
// begin ComMoveXY ( i , 60 , 94 ) ;
19972: LD_VAR 0 1
19976: PPUSH
19977: LD_INT 60
19979: PPUSH
19980: LD_INT 94
19982: PPUSH
19983: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_EXP 58
19996: PPUSH
19997: CALL_OW 179
// wait ( 0 0$3 ) ;
20001: LD_INT 105
20003: PPUSH
20004: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_STRING D4a-Sol1-2
20015: PPUSH
20016: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20020: LD_EXP 58
20024: PPUSH
20025: LD_STRING D4a-Pow-2
20027: PPUSH
20028: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20032: LD_VAR 0 1
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20044: LD_ADDR_EXP 116
20048: PUSH
20049: LD_EXP 116
20053: PPUSH
20054: LD_INT 4
20056: PPUSH
20057: LD_EXP 116
20061: PUSH
20062: LD_INT 4
20064: ARRAY
20065: PUSH
20066: LD_VAR 0 1
20070: UNION
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20077: LD_INT 8
20079: PPUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 472
// end ;
20089: GO 19954
20091: POP
20092: POP
// wait ( 4 4$00 ) ;
20093: LD_INT 8400
20095: PPUSH
20096: CALL_OW 67
// uc_side := 6 ;
20100: LD_ADDR_OWVAR 20
20104: PUSH
20105: LD_INT 6
20107: ST_TO_ADDR
// uc_nation := 3 ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 3
20115: ST_TO_ADDR
// ru := [ ] ;
20116: LD_ADDR_VAR 0 7
20120: PUSH
20121: EMPTY
20122: ST_TO_ADDR
// for i = 1 to 4 do
20123: LD_ADDR_VAR 0 1
20127: PUSH
20128: DOUBLE
20129: LD_INT 1
20131: DEC
20132: ST_TO_ADDR
20133: LD_INT 4
20135: PUSH
20136: FOR_TO
20137: IFFALSE 20238
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20139: LD_INT 22
20141: PPUSH
20142: LD_INT 1
20144: PPUSH
20145: LD_INT 3
20147: PPUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_INT 2
20163: PPUSH
20164: CALL_OW 12
20168: ARRAY
20169: PPUSH
20170: LD_INT 89
20172: PPUSH
20173: CALL 70417 0 5
// un := CreateVehicle ;
20177: LD_ADDR_VAR 0 8
20181: PUSH
20182: CALL_OW 45
20186: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20187: LD_VAR 0 8
20191: PPUSH
20192: LD_INT 4
20194: PPUSH
20195: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20199: LD_VAR 0 8
20203: PPUSH
20204: LD_INT 136
20206: PPUSH
20207: LD_INT 90
20209: PPUSH
20210: LD_INT 8
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL_OW 50
// ru := ru ^ un ;
20220: LD_ADDR_VAR 0 7
20224: PUSH
20225: LD_VAR 0 7
20229: PUSH
20230: LD_VAR 0 8
20234: ADD
20235: ST_TO_ADDR
// end ;
20236: GO 20136
20238: POP
20239: POP
// if ru then
20240: LD_VAR 0 7
20244: IFFALSE 20261
// ComAgressiveMove ( ru , 80 , 92 ) ;
20246: LD_VAR 0 7
20250: PPUSH
20251: LD_INT 80
20253: PPUSH
20254: LD_INT 92
20256: PPUSH
20257: CALL_OW 114
// wait ( 8 8$00 ) ;
20261: LD_INT 16800
20263: PPUSH
20264: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20268: LD_INT 4
20270: PPUSH
20271: LD_INT 3
20273: PUSH
20274: LD_INT 1
20276: PUSH
20277: LD_INT 1
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 4
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 6
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 1
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 3
20327: PUSH
20328: LD_INT 1
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: LD_INT 7
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: PPUSH
20368: CALL 59099 0 2
// missionStage := 4 ;
20372: LD_ADDR_EXP 15
20376: PUSH
20377: LD_INT 4
20379: ST_TO_ADDR
// end ;
20380: PPOPN 8
20382: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20383: LD_EXP 15
20387: PUSH
20388: LD_INT 4
20390: EQUAL
20391: PUSH
20392: LD_INT 22
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 21
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL_OW 69
20420: PUSH
20421: LD_INT 5
20423: GREATEREQUAL
20424: AND
20425: IFFALSE 24530
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
20434: PPUSH
20435: PPUSH
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin missionStage := 5 ;
20445: LD_ADDR_EXP 15
20449: PUSH
20450: LD_INT 5
20452: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20453: LD_ADDR_VAR 0 10
20457: PUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 30
20473: PUSH
20474: LD_INT 4
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 30
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 4
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 21
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PUSH
20530: LD_INT 3
20532: PUSH
20533: LD_INT 25
20535: PUSH
20536: LD_INT 16
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 3
20549: PUSH
20550: LD_INT 25
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 58
20579: DIFF
20580: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 4
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20619: LD_INT 35
20621: PPUSH
20622: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20626: LD_EXP 135
20630: PUSH
20631: LD_INT 4
20633: ARRAY
20634: PUSH
20635: LD_INT 5
20637: GREATEREQUAL
20638: PUSH
20639: LD_EXP 135
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PPUSH
20648: LD_INT 58
20650: PUSH
20651: EMPTY
20652: LIST
20653: PPUSH
20654: CALL_OW 72
20658: PUSH
20659: LD_INT 5
20661: GREATEREQUAL
20662: AND
20663: IFFALSE 20619
// powellAllowRetreat := false ;
20665: LD_ADDR_EXP 19
20669: PUSH
20670: LD_INT 0
20672: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20673: LD_INT 700
20675: PPUSH
20676: CALL_OW 67
// activeAttacks := false ;
20680: LD_ADDR_EXP 16
20684: PUSH
20685: LD_INT 0
20687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20688: LD_INT 35
20690: PPUSH
20691: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20695: LD_INT 22
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: PUSH
20710: LD_INT 0
20712: EQUAL
20713: IFFALSE 20688
// tmp := mc_vehicles [ 4 ] ;
20715: LD_ADDR_VAR 0 3
20719: PUSH
20720: LD_EXP 135
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20729: LD_ADDR_VAR 0 1
20733: PUSH
20734: DOUBLE
20735: LD_INT 1
20737: DEC
20738: ST_TO_ADDR
20739: LD_EXP 18
20743: PUSH
20744: FOR_TO
20745: IFFALSE 21006
// begin for j in powellSquadAttack [ i ] do
20747: LD_ADDR_VAR 0 2
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_VAR 0 1
20761: ARRAY
20762: PUSH
20763: FOR_IN
20764: IFFALSE 21002
// begin forces := forces diff j ;
20766: LD_ADDR_VAR 0 6
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_VAR 0 2
20780: DIFF
20781: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20782: LD_VAR 0 2
20786: PPUSH
20787: LD_INT 1
20789: PPUSH
20790: CALL_OW 109
// wait ( 0 0$2 ) ;
20794: LD_INT 70
20796: PPUSH
20797: CALL_OW 67
// if IsInUnit ( j ) then
20801: LD_VAR 0 2
20805: PPUSH
20806: CALL_OW 310
20810: IFFALSE 20821
// ComExitBuilding ( j ) ;
20812: LD_VAR 0 2
20816: PPUSH
20817: CALL_OW 122
// if GetClass ( j ) <> 1 then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 257
20830: PUSH
20831: LD_INT 1
20833: NONEQUAL
20834: IFFALSE 20914
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20836: LD_VAR 0 10
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: PPUSH
20845: CALL_OW 313
20849: PUSH
20850: LD_INT 5
20852: GREATEREQUAL
20853: IFFALSE 20875
// AddComEnterUnit ( j , arm [ 2 ] ) else
20855: LD_VAR 0 2
20859: PPUSH
20860: LD_VAR 0 10
20864: PUSH
20865: LD_INT 2
20867: ARRAY
20868: PPUSH
20869: CALL_OW 180
20873: GO 20893
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20875: LD_VAR 0 2
20879: PPUSH
20880: LD_VAR 0 10
20884: PUSH
20885: LD_INT 1
20887: ARRAY
20888: PPUSH
20889: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 183
// AddComExitBuilding ( j ) ;
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 182
// end ; if i = 2 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 2
20921: EQUAL
20922: IFFALSE 20939
// AddComMoveXY ( j , 61 , 93 ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 61
20931: PPUSH
20932: LD_INT 93
20934: PPUSH
20935: CALL_OW 171
// if i = 1 then
20939: LD_VAR 0 1
20943: PUSH
20944: LD_INT 1
20946: EQUAL
20947: IFFALSE 21000
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_VAR 0 3
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 3
20984: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: LD_INT 69
20992: PPUSH
20993: LD_INT 94
20995: PPUSH
20996: CALL_OW 171
// end ; end ;
21000: GO 20763
21002: POP
21003: POP
// end ;
21004: GO 20744
21006: POP
21007: POP
// wait ( 0 0$55 ) ;
21008: LD_INT 1925
21010: PPUSH
21011: CALL_OW 67
// MC_Kill ( 4 ) ;
21015: LD_INT 4
21017: PPUSH
21018: CALL 35385 0 1
// tmp := UnitsInside ( fac ) ;
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_VAR 0 9
21031: PPUSH
21032: CALL_OW 313
21036: ST_TO_ADDR
// if tmp then
21037: LD_VAR 0 3
21041: IFFALSE 21162
// for i in tmp do
21043: LD_ADDR_VAR 0 1
21047: PUSH
21048: LD_VAR 0 3
21052: PUSH
21053: FOR_IN
21054: IFFALSE 21160
// begin ComExitBuilding ( i ) ;
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21065: LD_VAR 0 10
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: CALL_OW 313
21078: PUSH
21079: LD_INT 6
21081: LESS
21082: IFFALSE 21104
// AddComEnterUnit ( i , arm [ 2 ] ) else
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 10
21093: PUSH
21094: LD_INT 2
21096: ARRAY
21097: PPUSH
21098: CALL_OW 180
21102: GO 21158
// if UnitsInside ( arm [ 1 ] ) < 6 then
21104: LD_VAR 0 10
21108: PUSH
21109: LD_INT 1
21111: ARRAY
21112: PPUSH
21113: CALL_OW 313
21117: PUSH
21118: LD_INT 6
21120: LESS
21121: IFFALSE 21143
// AddComEnterUnit ( i , arm [ 1 ] ) else
21123: LD_VAR 0 1
21127: PPUSH
21128: LD_VAR 0 10
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: CALL_OW 180
21141: GO 21158
// AddComMoveXY ( i , 37 , 68 ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_INT 37
21150: PPUSH
21151: LD_INT 68
21153: PPUSH
21154: CALL_OW 171
// end ;
21158: GO 21053
21160: POP
21161: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 6
21171: PPUSH
21172: LD_INT 26
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 72
21186: PUSH
21187: LD_EXP 59
21191: DIFF
21192: ST_TO_ADDR
// if not speaker then
21193: LD_VAR 0 11
21197: NOT
21198: IFFALSE 21225
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21200: LD_ADDR_VAR 0 11
21204: PUSH
21205: LD_VAR 0 6
21209: PPUSH
21210: LD_INT 26
21212: PUSH
21213: LD_INT 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 72
21224: ST_TO_ADDR
// if speaker then
21225: LD_VAR 0 11
21229: IFFALSE 21245
// speaker := speaker [ 1 ] ;
21231: LD_ADDR_VAR 0 11
21235: PUSH
21236: LD_VAR 0 11
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: ST_TO_ADDR
// Video ( true ) ;
21245: LD_INT 1
21247: PPUSH
21248: CALL 102263 0 1
// CenterNowOnUnits ( Powell ) ;
21252: LD_EXP 58
21256: PPUSH
21257: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21261: LD_ADDR_VAR 0 3
21265: PUSH
21266: LD_VAR 0 6
21270: PPUSH
21271: LD_INT 3
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 72
21292: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21293: LD_ADDR_VAR 0 12
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_INT 4
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 32
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 58
21320: PUSH
21321: EMPTY
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: PPUSH
21329: CALL_OW 69
21333: ST_TO_ADDR
// for i = 1 to 6 do
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: DOUBLE
21340: LD_INT 1
21342: DEC
21343: ST_TO_ADDR
21344: LD_INT 6
21346: PUSH
21347: FOR_TO
21348: IFFALSE 21489
// begin if IsInUnit ( tmp [ i ] ) then
21350: LD_VAR 0 3
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 310
21365: IFFALSE 21382
// ComExitBuilding ( tmp [ i ] ) ;
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: ARRAY
21377: PPUSH
21378: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21382: LD_VAR 0 3
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 10
21397: PUSH
21398: LD_INT 1
21400: ARRAY
21401: PPUSH
21402: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21406: LD_VAR 0 3
21410: PUSH
21411: LD_VAR 0 1
21415: ARRAY
21416: PPUSH
21417: LD_INT 1
21419: PPUSH
21420: CALL_OW 183
// if emp_towers then
21424: LD_VAR 0 12
21428: IFFALSE 21487
// begin AddComExitBuilding ( tmp [ i ] ) ;
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 1
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 12
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PPUSH
21465: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21469: LD_ADDR_VAR 0 12
21473: PUSH
21474: LD_VAR 0 12
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 3
21486: ST_TO_ADDR
// end ; end ;
21487: GO 21347
21489: POP
21490: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21491: LD_ADDR_VAR 0 3
21495: PUSH
21496: LD_EXP 18
21500: PUSH
21501: LD_INT 1
21503: ARRAY
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 2
21512: ARRAY
21513: ADD
21514: PPUSH
21515: LD_INT 26
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 72
21529: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21530: LD_ADDR_VAR 0 1
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 2
21542: ARRAY
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21563
// ComTurnUnit ( i , Powell ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_EXP 58
21556: PPUSH
21557: CALL_OW 119
21561: GO 21544
21563: POP
21564: POP
// Say ( Powell , D5-Pow-1 ) ;
21565: LD_EXP 58
21569: PPUSH
21570: LD_STRING D5-Pow-1
21572: PPUSH
21573: CALL_OW 88
// if tmp then
21577: LD_VAR 0 3
21581: IFFALSE 21599
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21583: LD_VAR 0 3
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_STRING D5-Sol2-1
21594: PPUSH
21595: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21599: LD_EXP 58
21603: PPUSH
21604: LD_STRING D5-Pow-2
21606: PPUSH
21607: CALL_OW 88
// if tmp > 1 then
21611: LD_VAR 0 3
21615: PUSH
21616: LD_INT 1
21618: GREATER
21619: IFFALSE 21637
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 2
21628: ARRAY
21629: PPUSH
21630: LD_STRING D5-Sol2-2
21632: PPUSH
21633: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-3
21644: PPUSH
21645: CALL_OW 88
// wait ( 0 0$1 ) ;
21649: LD_INT 35
21651: PPUSH
21652: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_EXP 18
21674: PUSH
21675: LD_INT 2
21677: ARRAY
21678: UNION
21679: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21680: LD_VAR 0 3
21684: PPUSH
21685: LD_INT 80
21687: PPUSH
21688: LD_INT 67
21690: PPUSH
21691: CALL_OW 114
// wait ( 0 0$2 ) ;
21695: LD_INT 70
21697: PPUSH
21698: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21702: LD_INT 79
21704: PPUSH
21705: LD_INT 72
21707: PPUSH
21708: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21712: LD_INT 35
21714: PPUSH
21715: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21719: LD_VAR 0 3
21723: PPUSH
21724: LD_INT 3
21726: PUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1000
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: CALL_OW 72
21745: IFFALSE 21712
// Say ( Powell , D5a-Pow-1 ) ;
21747: LD_EXP 58
21751: PPUSH
21752: LD_STRING D5a-Pow-1
21754: PPUSH
21755: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21759: LD_EXP 58
21763: PPUSH
21764: LD_STRING D5a-Pow-1a
21766: PPUSH
21767: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21771: LD_INT 10
21773: PPUSH
21774: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21778: LD_EXP 58
21782: PPUSH
21783: LD_STRING D5a-Pow-1b
21785: PPUSH
21786: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21790: LD_EXP 58
21794: PPUSH
21795: LD_STRING D5a-Pow-1c
21797: PPUSH
21798: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21802: LD_EXP 58
21806: PPUSH
21807: LD_STRING D5a-Pow-1d
21809: PPUSH
21810: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21814: LD_INT 35
21816: PPUSH
21817: CALL_OW 67
// if not HasTask ( tmp ) then
21821: LD_VAR 0 3
21825: PPUSH
21826: CALL_OW 314
21830: NOT
21831: IFFALSE 21848
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 80
21840: PPUSH
21841: LD_INT 67
21843: PPUSH
21844: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21848: LD_VAR 0 3
21852: PPUSH
21853: LD_INT 24
21855: PUSH
21856: LD_INT 1
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 72
21867: NOT
21868: IFFALSE 21814
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_INT 22
21877: PUSH
21878: LD_INT 4
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 92
21887: PUSH
21888: LD_INT 60
21890: PUSH
21891: LD_INT 93
21893: PUSH
21894: LD_INT 10
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 3
21905: PUSH
21906: LD_INT 54
21908: PUSH
21909: EMPTY
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 69
21925: PUSH
21926: LD_EXP 58
21930: DIFF
21931: ST_TO_ADDR
// if tmp then
21932: LD_VAR 0 3
21936: IFFALSE 21970
// for i in tmp do
21938: LD_ADDR_VAR 0 1
21942: PUSH
21943: LD_VAR 0 3
21947: PUSH
21948: FOR_IN
21949: IFFALSE 21968
// ComMoveXY ( i , 36 , 67 ) ;
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 36
21958: PPUSH
21959: LD_INT 67
21961: PPUSH
21962: CALL_OW 111
21966: GO 21948
21968: POP
21969: POP
// wait ( 0 0$3 ) ;
21970: LD_INT 105
21972: PPUSH
21973: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21977: LD_VAR 0 11
21981: PPUSH
21982: LD_STRING D6-Sol3-1
21984: PPUSH
21985: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21989: LD_EXP 58
21993: PPUSH
21994: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21998: LD_EXP 58
22002: PPUSH
22003: LD_STRING D6-Pow-1
22005: PPUSH
22006: CALL_OW 88
// tmp := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// for i = 1 to 2 do
22017: LD_ADDR_VAR 0 1
22021: PUSH
22022: DOUBLE
22023: LD_INT 1
22025: DEC
22026: ST_TO_ADDR
22027: LD_INT 2
22029: PUSH
22030: FOR_TO
22031: IFFALSE 22145
// begin uc_side := 8 ;
22033: LD_ADDR_OWVAR 20
22037: PUSH
22038: LD_INT 8
22040: ST_TO_ADDR
// uc_nation := 2 ;
22041: LD_ADDR_OWVAR 21
22045: PUSH
22046: LD_INT 2
22048: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22049: LD_INT 14
22051: PPUSH
22052: LD_INT 3
22054: PPUSH
22055: LD_INT 2
22057: PPUSH
22058: LD_INT 29
22060: PPUSH
22061: LD_INT 100
22063: PPUSH
22064: CALL 70417 0 5
// veh := CreateVehicle ;
22068: LD_ADDR_VAR 0 13
22072: PUSH
22073: CALL_OW 45
22077: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: LD_INT 4
22085: PPUSH
22086: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22090: LD_VAR 0 13
22094: PPUSH
22095: LD_INT 99
22097: PPUSH
22098: LD_INT 83
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: LD_INT 0
22106: PPUSH
22107: CALL_OW 50
// wait ( 3 ) ;
22111: LD_INT 3
22113: PPUSH
22114: CALL_OW 67
// Connect ( veh ) ;
22118: LD_VAR 0 13
22122: PPUSH
22123: CALL 73510 0 1
// tmp := tmp ^ veh ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_VAR 0 3
22136: PUSH
22137: LD_VAR 0 13
22141: ADD
22142: ST_TO_ADDR
// end ;
22143: GO 22030
22145: POP
22146: POP
// wait ( 0 0$1 ) ;
22147: LD_INT 35
22149: PPUSH
22150: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22154: LD_INT 99
22156: PPUSH
22157: LD_INT 83
22159: PPUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_INT 10
22165: PPUSH
22166: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22170: LD_INT 99
22172: PPUSH
22173: LD_INT 83
22175: PPUSH
22176: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22180: LD_VAR 0 11
22184: PPUSH
22185: LD_STRING D6-Sol3-2
22187: PPUSH
22188: CALL_OW 88
// async ;
22192: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22193: LD_EXP 58
22197: PPUSH
22198: LD_STRING D6-Pow-2
22200: PPUSH
22201: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22205: LD_VAR 0 3
22209: PUSH
22210: LD_INT 1
22212: ARRAY
22213: PPUSH
22214: LD_VAR 0 9
22218: PPUSH
22219: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22223: LD_VAR 0 3
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PPUSH
22232: LD_INT 22
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 21
22244: PUSH
22245: LD_INT 3
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 69
22260: PPUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PPUSH
22270: CALL_OW 74
22274: PPUSH
22275: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22279: LD_EXP 58
22283: PPUSH
22284: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22288: LD_INT 99
22290: PPUSH
22291: LD_INT 83
22293: PPUSH
22294: LD_INT 1
22296: PPUSH
22297: CALL_OW 331
// repeat wait ( 4 ) ;
22301: LD_INT 4
22303: PPUSH
22304: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22308: LD_VAR 0 3
22312: PUSH
22313: LD_INT 1
22315: ARRAY
22316: PPUSH
22317: CALL_OW 256
22321: PUSH
22322: LD_INT 1000
22324: LESS
22325: IFFALSE 22343
// SetLives ( tmp [ 1 ] , 1000 ) ;
22327: LD_VAR 0 3
22331: PUSH
22332: LD_INT 1
22334: ARRAY
22335: PPUSH
22336: LD_INT 1000
22338: PPUSH
22339: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22343: LD_INT 22
22345: PUSH
22346: LD_INT 4
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 69
22371: PUSH
22372: LD_INT 0
22374: EQUAL
22375: IFFALSE 22301
// sync ;
22377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22378: LD_EXP 58
22382: PPUSH
22383: LD_STRING D6a-Pow-1
22385: PPUSH
22386: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22390: LD_VAR 0 11
22394: PPUSH
22395: LD_STRING D6a-Sol3-1
22397: PPUSH
22398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22402: LD_EXP 58
22406: PPUSH
22407: LD_STRING D6a-Pow-2
22409: PPUSH
22410: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_STRING D6a-Sol3-2
22421: PPUSH
22422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22426: LD_EXP 58
22430: PPUSH
22431: LD_STRING D6a-Pow-3
22433: PPUSH
22434: CALL_OW 88
// powellCenterCameraMode := true ;
22438: LD_ADDR_EXP 20
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_INT 8
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 25
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 69
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22536
// begin SetTag ( i , 1 ) ;
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: CALL_OW 109
// ComExitBuilding ( i ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22504: LD_VAR 0 1
22508: PPUSH
22509: LD_INT 35
22511: PPUSH
22512: LD_INT 6
22514: PPUSH
22515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 53
22526: PPUSH
22527: LD_INT 4
22529: PPUSH
22530: CALL_OW 171
// end ;
22534: GO 22480
22536: POP
22537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22538: LD_ADDR_VAR 0 3
22542: PUSH
22543: LD_INT 22
22545: PUSH
22546: LD_INT 4
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 21
22555: PUSH
22556: LD_INT 2
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 12
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22590: LD_EXP 58
22594: PPUSH
22595: LD_VAR 0 3
22599: PPUSH
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 74
22609: PPUSH
22610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22614: LD_EXP 58
22618: PPUSH
22619: LD_INT 100
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22629: LD_EXP 58
22633: PPUSH
22634: LD_INT 100
22636: PPUSH
22637: LD_INT 75
22639: PPUSH
22640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22644: LD_EXP 58
22648: PPUSH
22649: LD_INT 88
22651: PPUSH
22652: LD_INT 53
22654: PPUSH
22655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22659: LD_INT 8
22661: PPUSH
22662: LD_EXP 58
22666: PPUSH
22667: CALL_OW 471
// repeat wait ( 3 ) ;
22671: LD_INT 3
22673: PPUSH
22674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22678: LD_INT 22
22680: PUSH
22681: LD_INT 4
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 92
22690: PUSH
22691: LD_INT 100
22693: PUSH
22694: LD_INT 75
22696: PUSH
22697: LD_INT 6
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PPUSH
22710: CALL_OW 69
22714: IFFALSE 22671
// async ;
22716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_STRING D6b-Pow-1
22724: PPUSH
22725: CALL_OW 88
// repeat wait ( 3 ) ;
22729: LD_INT 3
22731: PPUSH
22732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22736: LD_EXP 58
22740: PPUSH
22741: CALL_OW 310
22745: PPUSH
22746: CALL_OW 256
22750: PUSH
22751: LD_INT 1000
22753: LESS
22754: IFFALSE 22773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22756: LD_EXP 58
22760: PPUSH
22761: CALL_OW 310
22765: PPUSH
22766: LD_INT 1000
22768: PPUSH
22769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22773: LD_EXP 58
22777: PPUSH
22778: CALL_OW 256
22782: PUSH
22783: LD_INT 1000
22785: LESS
22786: IFFALSE 22800
// SetLives ( Powell , 1000 ) ;
22788: LD_EXP 58
22792: PPUSH
22793: LD_INT 1000
22795: PPUSH
22796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22800: LD_EXP 58
22804: PPUSH
22805: LD_EXP 63
22809: PPUSH
22810: CALL_OW 296
22814: PUSH
22815: LD_INT 5
22817: LESS
22818: PUSH
22819: LD_EXP 58
22823: PPUSH
22824: CALL_OW 310
22828: PPUSH
22829: LD_EXP 63
22833: PPUSH
22834: CALL_OW 296
22838: PUSH
22839: LD_INT 5
22841: LESS
22842: OR
22843: IFFALSE 22862
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 310
22854: PPUSH
22855: LD_INT 100
22857: PPUSH
22858: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22862: LD_EXP 58
22866: PPUSH
22867: CALL_OW 310
22871: NOT
22872: IFFALSE 22729
// DoNotAttack ( 8 , powellBomb ) ;
22874: LD_INT 8
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 471
// game_speed := 4 ;
22886: LD_ADDR_OWVAR 65
22890: PUSH
22891: LD_INT 4
22893: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22894: LD_EXP 58
22898: PPUSH
22899: LD_STRING D6b-Pow-1a
22901: PPUSH
22902: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22906: LD_EXP 58
22910: PPUSH
22911: LD_EXP 63
22915: PPUSH
22916: CALL_OW 180
// sync ;
22920: SYNC
// repeat wait ( 0 0$1 ) ;
22921: LD_INT 35
22923: PPUSH
22924: CALL_OW 67
// until IsInUnit ( Powell ) ;
22928: LD_EXP 58
22932: PPUSH
22933: CALL_OW 310
22937: IFFALSE 22921
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22939: LD_INT 8
22941: PPUSH
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: PPUSH
22952: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 58
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22971: LD_EXP 58
22975: PPUSH
22976: LD_INT 96
22978: PPUSH
22979: LD_INT 44
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_INT 96
22993: PPUSH
22994: LD_INT 41
22996: PPUSH
22997: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23001: LD_EXP 58
23005: PPUSH
23006: LD_INT 92
23008: PPUSH
23009: LD_INT 39
23011: PPUSH
23012: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23016: LD_EXP 58
23020: PPUSH
23021: LD_INT 88
23023: PPUSH
23024: LD_INT 41
23026: PPUSH
23027: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23031: LD_EXP 58
23035: PPUSH
23036: LD_INT 91
23038: PPUSH
23039: LD_INT 44
23041: PPUSH
23042: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23046: LD_EXP 58
23050: PPUSH
23051: LD_INT 96
23053: PPUSH
23054: LD_INT 44
23056: PPUSH
23057: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23061: LD_EXP 58
23065: PPUSH
23066: LD_INT 96
23068: PPUSH
23069: LD_INT 41
23071: PPUSH
23072: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23076: LD_EXP 58
23080: PPUSH
23081: LD_INT 92
23083: PPUSH
23084: LD_INT 39
23086: PPUSH
23087: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23091: LD_EXP 58
23095: PPUSH
23096: LD_INT 88
23098: PPUSH
23099: LD_INT 41
23101: PPUSH
23102: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23106: LD_EXP 58
23110: PPUSH
23111: LD_INT 91
23113: PPUSH
23114: LD_INT 44
23116: PPUSH
23117: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23121: LD_EXP 58
23125: PPUSH
23126: LD_INT 93
23128: PPUSH
23129: LD_INT 39
23131: PPUSH
23132: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23136: LD_EXP 58
23140: PPUSH
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 36
23146: PPUSH
23147: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23151: LD_INT 122
23153: PPUSH
23154: CALL_OW 67
// game_speed := 4 ;
23158: LD_ADDR_OWVAR 65
23162: PUSH
23163: LD_INT 4
23165: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23166: LD_EXP 58
23170: PPUSH
23171: LD_STRING D6b-Pow-1b
23173: PPUSH
23174: CALL_OW 88
// tmp := [ ] ;
23178: LD_ADDR_VAR 0 3
23182: PUSH
23183: EMPTY
23184: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23185: LD_ADDR_VAR 0 5
23189: PUSH
23190: LD_INT 78
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 53
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23214: LD_ADDR_VAR 0 1
23218: PUSH
23219: LD_INT 22
23221: PUSH
23222: LD_INT 8
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 21
23231: PUSH
23232: LD_INT 3
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 92
23241: PUSH
23242: LD_INT 90
23244: PUSH
23245: LD_INT 52
23247: PUSH
23248: LD_INT 12
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23293
// tmp := tmp ^ UnitsInside ( i ) ;
23270: LD_ADDR_VAR 0 3
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 313
23289: ADD
23290: ST_TO_ADDR
23291: GO 23267
23293: POP
23294: POP
// for i in tmp do
23295: LD_ADDR_VAR 0 1
23299: PUSH
23300: LD_VAR 0 3
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23468
// begin dist := 9999 ;
23308: LD_ADDR_VAR 0 8
23312: PUSH
23313: LD_INT 9999
23315: ST_TO_ADDR
// _xy := [ ] ;
23316: LD_ADDR_VAR 0 7
23320: PUSH
23321: EMPTY
23322: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 109
// ComExitBuilding ( i ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 122
// for j in xy do
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_VAR 0 5
23353: PUSH
23354: FOR_IN
23355: IFFALSE 23437
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: PUSH
23385: LD_VAR 0 8
23389: LESS
23390: IFFALSE 23435
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23392: LD_ADDR_VAR 0 8
23396: PUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 1
23409: ARRAY
23410: PPUSH
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 2
23418: ARRAY
23419: PPUSH
23420: CALL_OW 297
23424: ST_TO_ADDR
// _xy := j ;
23425: LD_ADDR_VAR 0 7
23429: PUSH
23430: LD_VAR 0 2
23434: ST_TO_ADDR
// end ;
23435: GO 23354
23437: POP
23438: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_VAR 0 7
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 2
23460: ARRAY
23461: PPUSH
23462: CALL_OW 171
// end ;
23466: GO 23305
23468: POP
23469: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23470: LD_ADDR_VAR 0 4
23474: PUSH
23475: LD_VAR 0 3
23479: PPUSH
23480: LD_INT 26
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 1
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: ST_TO_ADDR
// if tmp2 < 2 then
23509: LD_VAR 0 4
23513: PUSH
23514: LD_INT 2
23516: LESS
23517: IFFALSE 23586
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23519: LD_ADDR_VAR 0 4
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 26
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 25
23549: PUSH
23550: LD_INT 15
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 69
23570: PUSH
23571: LD_EXP 60
23575: PUSH
23576: LD_EXP 61
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: DIFF
23585: ST_TO_ADDR
// if tmp2 then
23586: LD_VAR 0 4
23590: IFFALSE 23608
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23592: LD_VAR 0 4
23596: PUSH
23597: LD_INT 1
23599: ARRAY
23600: PPUSH
23601: LD_STRING D6b-ArSol1-1
23603: PPUSH
23604: CALL_OW 88
// async ;
23608: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23609: LD_EXP 58
23613: PPUSH
23614: LD_STRING D6b-Pow-2
23616: PPUSH
23617: CALL_OW 88
// wait ( 0 0$1 ) ;
23621: LD_INT 35
23623: PPUSH
23624: CALL_OW 67
// if tmp2 > 1 then
23628: LD_VAR 0 4
23632: PUSH
23633: LD_INT 1
23635: GREATER
23636: IFFALSE 23654
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23638: LD_VAR 0 4
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: LD_STRING D6b-ArSol2-1
23649: PPUSH
23650: CALL_OW 88
// sync ;
23654: SYNC
// repeat wait ( 5 ) ;
23655: LD_INT 5
23657: PPUSH
23658: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23662: LD_INT 93
23664: PPUSH
23665: LD_INT 36
23667: PPUSH
23668: CALL_OW 428
23672: PPUSH
23673: CALL_OW 255
23677: PUSH
23678: LD_INT 4
23680: EQUAL
23681: IFFALSE 23655
// DialogueOn ;
23683: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23687: LD_INT 10
23689: PPUSH
23690: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23694: LD_EXP 58
23698: PPUSH
23699: LD_STRING D6b-Pow-2a
23701: PPUSH
23702: CALL_OW 88
// DialogueOff ;
23706: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23710: LD_EXP 58
23714: PPUSH
23715: CALL_OW 310
23719: PPUSH
23720: LD_INT 332
23722: PPUSH
23723: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23727: LD_INT 93
23729: PPUSH
23730: LD_INT 35
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: LD_INT 6
23738: NEG
23739: PPUSH
23740: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23744: LD_INT 35
23746: PPUSH
23747: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23751: LD_INT 332
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 1000
23761: LESS
23762: PUSH
23763: LD_INT 332
23765: PPUSH
23766: CALL_OW 300
23770: AND
23771: IFFALSE 23783
// SetLives ( kozlov_fac , 0 ) ;
23773: LD_INT 332
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23783: LD_INT 332
23785: PPUSH
23786: CALL_OW 301
23790: PUSH
23791: LD_EXP 58
23795: PPUSH
23796: CALL_OW 301
23800: OR
23801: IFFALSE 23744
// game_speed := 4 ;
23803: LD_ADDR_OWVAR 65
23807: PUSH
23808: LD_INT 4
23810: ST_TO_ADDR
// powellCenterCameraMode := false ;
23811: LD_ADDR_EXP 20
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: LD_INT 22
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 25
23841: PUSH
23842: LD_INT 2
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: UNION
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23876
// SetTag ( i , 0 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 0
23869: PPUSH
23870: CALL_OW 109
23874: GO 23859
23876: POP
23877: POP
// wait ( 0 0$3 ) ;
23878: LD_INT 105
23880: PPUSH
23881: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23885: LD_INT 93
23887: PPUSH
23888: LD_INT 35
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: CALL_OW 331
// DialogueOn ;
23898: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23902: LD_VAR 0 11
23906: PPUSH
23907: LD_STRING D6c-Sol3-1
23909: PPUSH
23910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23914: LD_INT 10
23916: PPUSH
23917: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23921: LD_EXP 39
23925: PPUSH
23926: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23930: LD_EXP 39
23934: PPUSH
23935: LD_STRING D6c-JMM-1
23937: PPUSH
23938: CALL_OW 88
// if Cyrus then
23942: LD_EXP 45
23946: IFFALSE 23960
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23948: LD_EXP 45
23952: PPUSH
23953: LD_STRING D6c-Cyrus-1
23955: PPUSH
23956: CALL_OW 88
// if Bobby then
23960: LD_EXP 44
23964: IFFALSE 23978
// Say ( Bobby , D6c-Bobby-1 ) ;
23966: LD_EXP 44
23970: PPUSH
23971: LD_STRING D6c-Bobby-1
23973: PPUSH
23974: CALL_OW 88
// if Cornel then
23978: LD_EXP 50
23982: IFFALSE 23996
// Say ( Cornel , D6c-Corn-1 ) ;
23984: LD_EXP 50
23988: PPUSH
23989: LD_STRING D6c-Corn-1
23991: PPUSH
23992: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23996: LD_ADDR_VAR 0 4
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 22
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 26
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 25
24044: PUSH
24045: LD_INT 16
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 12
24057: PUSH
24058: EMPTY
24059: LIST
24060: LIST
24061: PUSH
24062: EMPTY
24063: LIST
24064: LIST
24065: LIST
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: PPUSH
24072: CALL_OW 69
24076: PUSH
24077: LD_VAR 0 11
24081: PUSH
24082: LD_EXP 39
24086: UNION
24087: PUSH
24088: LD_EXP 59
24092: UNION
24093: PUSH
24094: EMPTY
24095: LIST
24096: DIFF
24097: ST_TO_ADDR
// if tmp2 then
24098: LD_VAR 0 4
24102: IFFALSE 24120
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24104: LD_VAR 0 4
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: PPUSH
24113: LD_STRING D6c-Sol1-1
24115: PPUSH
24116: CALL_OW 88
// if Lisa then
24120: LD_EXP 42
24124: IFFALSE 24138
// Say ( Lisa , D6c-Lisa-1 ) ;
24126: LD_EXP 42
24130: PPUSH
24131: LD_STRING D6c-Lisa-1
24133: PPUSH
24134: CALL_OW 88
// if Gary then
24138: LD_EXP 51
24142: IFFALSE 24156
// Say ( Gary , D6c-Gary-1 ) ;
24144: LD_EXP 51
24148: PPUSH
24149: LD_STRING D6c-Gary-1
24151: PPUSH
24152: CALL_OW 88
// if Donaldson then
24156: LD_EXP 43
24160: IFFALSE 24174
// Say ( Donaldson , D6c-Don-1 ) ;
24162: LD_EXP 43
24166: PPUSH
24167: LD_STRING D6c-Don-1
24169: PPUSH
24170: CALL_OW 88
// if tmp2 > 1 then
24174: LD_VAR 0 4
24178: PUSH
24179: LD_INT 1
24181: GREATER
24182: IFFALSE 24200
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 2
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol2-1
24195: PPUSH
24196: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24200: LD_VAR 0 11
24204: PPUSH
24205: LD_STRING D6c-Sol3-2
24207: PPUSH
24208: CALL_OW 88
// dwait ( 0 0$1 ) ;
24212: LD_INT 35
24214: PPUSH
24215: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24219: LD_EXP 39
24223: PPUSH
24224: LD_STRING D6c-JMM-2
24226: PPUSH
24227: CALL_OW 88
// DialogueOff ;
24231: CALL_OW 7
// Video ( false ) ;
24235: LD_INT 0
24237: PPUSH
24238: CALL 102263 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24242: LD_INT 22
24244: PUSH
24245: LD_INT 4
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24264: LD_INT 4
24266: PPUSH
24267: LD_INT 4
24269: PPUSH
24270: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24274: LD_ADDR_VAR 0 1
24278: PUSH
24279: LD_INT 4
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: CALL 65616 0 3
24292: PUSH
24293: FOR_IN
24294: IFFALSE 24331
// if GetTech ( i , 1 ) <> state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 1
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: NONEQUAL
24312: IFFALSE 24329
// SetTech ( i , 1 , state_researched ) ;
24314: LD_VAR 0 1
24318: PPUSH
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 2
24324: PPUSH
24325: CALL_OW 322
24329: GO 24293
24331: POP
24332: POP
// missionStage := 6 ;
24333: LD_ADDR_EXP 15
24337: PUSH
24338: LD_INT 6
24340: ST_TO_ADDR
// activeAttacks := true ;
24341: LD_ADDR_EXP 16
24345: PUSH
24346: LD_INT 1
24348: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24349: LD_STRING M2
24351: PPUSH
24352: CALL_OW 337
// SaveForQuickRestart ;
24356: CALL_OW 22
// wait ( 0 0$40 ) ;
24360: LD_INT 1400
24362: PPUSH
24363: CALL_OW 67
// DialogueOn ;
24367: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24371: LD_EXP 62
24375: PPUSH
24376: LD_STRING D7-Friend-1
24378: PPUSH
24379: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24383: LD_EXP 39
24387: PPUSH
24388: LD_STRING D7-JMM-1
24390: PPUSH
24391: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24395: LD_EXP 62
24399: PPUSH
24400: LD_STRING D7-Friend-2
24402: PPUSH
24403: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24407: LD_EXP 39
24411: PPUSH
24412: LD_STRING D7-JMM-2
24414: PPUSH
24415: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24419: LD_EXP 62
24423: PPUSH
24424: LD_STRING D7-Friend-3
24426: PPUSH
24427: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24431: LD_EXP 39
24435: PPUSH
24436: LD_STRING D7-JMM-3
24438: PPUSH
24439: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-4
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-4
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-5
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-5
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-6
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-6
24510: PPUSH
24511: CALL_OW 88
// DialogueOff ;
24515: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24519: LD_STRING Mlegion
24521: PPUSH
24522: CALL_OW 337
// RebuildKozlovFactory ;
24526: CALL 4880 0 0
// end ;
24530: PPOPN 13
24532: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24533: LD_EXP 20
24537: PUSH
24538: LD_EXP 58
24542: PPUSH
24543: CALL_OW 300
24547: AND
24548: IFFALSE 24590
24550: GO 24552
24552: DISABLE
// begin enable ;
24553: ENABLE
// if IsInUnit ( Powell ) then
24554: LD_EXP 58
24558: PPUSH
24559: CALL_OW 310
24563: IFFALSE 24581
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24565: LD_EXP 58
24569: PPUSH
24570: CALL_OW 310
24574: PPUSH
24575: CALL_OW 85
24579: GO 24590
// CenterOnUnits ( Powell ) ;
24581: LD_EXP 58
24585: PPUSH
24586: CALL_OW 85
// end ;
24590: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24591: LD_INT 22
24593: PUSH
24594: LD_INT 8
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: PUSH
24601: LD_INT 34
24603: PUSH
24604: LD_INT 48
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PPUSH
24615: CALL_OW 69
24619: IFFALSE 24893
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
24627: PPUSH
// begin if missionStage < 9 then
24628: LD_EXP 15
24632: PUSH
24633: LD_INT 9
24635: LESS
24636: IFFALSE 24646
// missionStage := 9 ;
24638: LD_ADDR_EXP 15
24642: PUSH
24643: LD_INT 9
24645: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24684: LD_INT 175
24686: PPUSH
24687: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24691: LD_EXP 12
24695: PUSH
24696: LD_EXP 3
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: IN
24711: OR
24712: IFFALSE 24735
// target := [ 68 , 108 , 1 ] else
24714: LD_ADDR_VAR 0 2
24718: PUSH
24719: LD_INT 68
24721: PUSH
24722: LD_INT 108
24724: PUSH
24725: LD_INT 1
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: ST_TO_ADDR
24733: GO 24754
// target := [ 181 , 88 , 2 ] ;
24735: LD_ADDR_VAR 0 2
24739: PUSH
24740: LD_INT 181
24742: PUSH
24743: LD_INT 88
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_VAR 0 2
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PPUSH
24768: LD_VAR 0 2
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PPUSH
24777: CALL_OW 176
// if target [ 3 ] = 1 then
24781: LD_VAR 0 2
24785: PUSH
24786: LD_INT 3
24788: ARRAY
24789: PUSH
24790: LD_INT 1
24792: EQUAL
24793: IFFALSE 24809
// SayRadio ( Kurt , D12-Kurt-1 ) else
24795: LD_EXP 60
24799: PPUSH
24800: LD_STRING D12-Kurt-1
24802: PPUSH
24803: CALL_OW 94
24807: GO 24833
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24809: LD_EXP 60
24813: PPUSH
24814: LD_STRING D12a-Kurt-1
24816: PPUSH
24817: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24821: LD_EXP 74
24825: PPUSH
24826: LD_STRING D12a-Roth-1
24828: PPUSH
24829: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24833: LD_INT 350
24835: PPUSH
24836: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24840: LD_VAR 0 1
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_INT 8
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PUSH
24855: LD_INT 23
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 3
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: CALL_OW 228
// end ;
24893: PPOPN 2
24895: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24896: LD_EXP 60
24900: PPUSH
24901: CALL_OW 256
24905: PUSH
24906: LD_INT 999
24908: LESS
24909: PUSH
24910: LD_INT 22
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 21
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 23
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 69
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 7
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_OWVAR 67
24968: ARRAY
24969: LESSEQUAL
24970: OR
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 8
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: LD_INT 34
24984: PUSH
24985: LD_INT 48
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: NOT
25001: AND
25002: PUSH
25003: LD_EXP 60
25007: PPUSH
25008: CALL_OW 302
25012: AND
25013: PUSH
25014: LD_INT 5
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 70
25031: AND
25032: IFFALSE 25737
25034: GO 25036
25036: DISABLE
25037: LD_INT 0
25039: PPUSH
25040: PPUSH
25041: PPUSH
// begin DialogueOn ;
25042: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25046: LD_EXP 39
25050: PPUSH
25051: LD_STRING D13-JMM-1
25053: PPUSH
25054: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25058: LD_EXP 60
25062: PPUSH
25063: LD_STRING D13-Kurt-1
25065: PPUSH
25066: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25070: LD_EXP 39
25074: PPUSH
25075: LD_STRING D13-JMM-2
25077: PPUSH
25078: CALL_OW 88
// if FakeInfo then
25082: LD_EXP 12
25086: IFFALSE 25106
// begin Say ( Kurt , D13-Kurt-2 ) ;
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2
25095: PPUSH
25096: CALL_OW 88
// DialogueOff ;
25100: CALL_OW 7
// exit ;
25104: GO 25737
// end ; if not KurtStatus then
25106: LD_EXP 3
25110: NOT
25111: IFFALSE 25127
// Say ( Kurt , D13-Kurt-2b ) else
25113: LD_EXP 60
25117: PPUSH
25118: LD_STRING D13-Kurt-2b
25120: PPUSH
25121: CALL_OW 88
25125: GO 25139
// Say ( Kurt , D13-Kurt-2a ) ;
25127: LD_EXP 60
25131: PPUSH
25132: LD_STRING D13-Kurt-2a
25134: PPUSH
25135: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25139: LD_EXP 39
25143: PPUSH
25144: LD_STRING D13-JMM-3
25146: PPUSH
25147: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_STRING D13-Kurt-3
25158: PPUSH
25159: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25163: LD_EXP 39
25167: PPUSH
25168: LD_STRING D13-JMM-4
25170: PPUSH
25171: CALL_OW 88
// DialogueOff ;
25175: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25179: LD_STRING MlegionOut
25181: PPUSH
25182: CALL_OW 337
// legionDestroyed := true ;
25186: LD_ADDR_EXP 22
25190: PUSH
25191: LD_INT 1
25193: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25194: LD_INT 3
25196: PPUSH
25197: CALL 35385 0 1
// KillUnit ( Kozlov ) ;
25201: LD_EXP 61
25205: PPUSH
25206: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_INT 22
25217: PUSH
25218: LD_INT 8
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 23
25227: PUSH
25228: LD_INT 3
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: LD_INT 21
25240: PUSH
25241: LD_INT 33
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: PUSH
25262: FOR_IN
25263: IFFALSE 25276
// KillUnit ( i ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 66
25274: GO 25262
25276: POP
25277: POP
// ChangeSideFog ( 8 , 1 ) ;
25278: LD_INT 8
25280: PPUSH
25281: LD_INT 1
25283: PPUSH
25284: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25288: LD_ADDR_VAR 0 2
25292: PUSH
25293: LD_INT 22
25295: PUSH
25296: LD_INT 8
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 21
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 69
25321: PUSH
25322: LD_EXP 61
25326: PUSH
25327: LD_EXP 60
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: DIFF
25336: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25337: LD_VAR 0 2
25341: PUSH
25342: LD_INT 6
25344: PUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: LD_OWVAR 67
25360: ARRAY
25361: GREATEREQUAL
25362: IFFALSE 25536
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25364: LD_ADDR_VAR 0 3
25368: PUSH
25369: LD_INT 6
25371: PUSH
25372: LD_INT 5
25374: PUSH
25375: LD_INT 4
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: DOUBLE
25395: LD_VAR 0 2
25399: PUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 1
25407: PLUS
25408: MINUS
25409: INC
25410: ST_TO_ADDR
25411: LD_INT 1
25413: PUSH
25414: FOR_DOWNTO
25415: IFFALSE 25532
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25417: LD_ADDR_EXP 38
25421: PUSH
25422: LD_EXP 38
25426: PUSH
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: ADD
25438: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25439: LD_VAR 0 2
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 310
25454: IFFALSE 25471
// ComExitBuilding ( tmp [ i ] ) ;
25456: LD_VAR 0 2
25460: PUSH
25461: LD_VAR 0 1
25465: ARRAY
25466: PPUSH
25467: CALL_OW 122
// if IsInUnit ( i ) then
25471: LD_VAR 0 1
25475: PPUSH
25476: CALL_OW 310
25480: IFFALSE 25497
// ComExitVehicle ( tmp [ i ] ) ;
25482: LD_VAR 0 2
25486: PUSH
25487: LD_VAR 0 1
25491: ARRAY
25492: PPUSH
25493: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25497: LD_VAR 0 2
25501: PUSH
25502: LD_VAR 0 1
25506: ARRAY
25507: PPUSH
25508: LD_INT 34
25510: PUSH
25511: LD_INT 0
25513: PPUSH
25514: LD_INT 6
25516: PPUSH
25517: CALL_OW 12
25521: PLUS
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 171
// end ;
25530: GO 25414
25532: POP
25533: POP
// end else
25534: GO 25546
// x := tmp ;
25536: LD_ADDR_VAR 0 3
25540: PUSH
25541: LD_VAR 0 2
25545: ST_TO_ADDR
// for i := tmp downto tmp - x do
25546: LD_ADDR_VAR 0 1
25550: PUSH
25551: DOUBLE
25552: LD_VAR 0 2
25556: INC
25557: ST_TO_ADDR
25558: LD_VAR 0 2
25562: PUSH
25563: LD_VAR 0 3
25567: MINUS
25568: PUSH
25569: FOR_DOWNTO
25570: IFFALSE 25624
// begin if IsInUnit ( tmp [ i ] ) then
25572: LD_VAR 0 2
25576: PUSH
25577: LD_VAR 0 1
25581: ARRAY
25582: PPUSH
25583: CALL_OW 310
25587: IFFALSE 25604
// ComExitVehicle ( tmp [ i ] ) ;
25589: LD_VAR 0 2
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: LD_INT 1
25617: PPUSH
25618: CALL_OW 235
// end ;
25622: GO 25569
25624: POP
25625: POP
// SetSide ( Kurt , 1 ) ;
25626: LD_EXP 60
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25638: LD_INT 22
25640: PUSH
25641: LD_INT 8
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 21
25650: PUSH
25651: LD_INT 3
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25674: LD_INT 8
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 1
25685: PPUSH
25686: CALL_OW 80
// wait ( 1 1$20 ) ;
25690: LD_INT 2800
25692: PPUSH
25693: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 37
25704: PPUSH
25705: LD_INT 1
25707: PPUSH
25708: LD_INT 0
25710: PPUSH
25711: CALL_OW 48
// wait ( 0 0$1 ) ;
25715: LD_INT 35
25717: PPUSH
25718: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25722: LD_EXP 62
25726: PPUSH
25727: LD_INT 60
25729: PPUSH
25730: LD_INT 95
25732: PPUSH
25733: CALL_OW 111
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25740: LD_EXP 22
25744: NOT
25745: PUSH
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PUSH
25775: LD_INT 0
25777: EQUAL
25778: AND
25779: IFFALSE 25799
25781: GO 25783
25783: DISABLE
// begin legionDestroyed := true ;
25784: LD_ADDR_EXP 22
25788: PUSH
25789: LD_INT 1
25791: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25792: LD_STRING MlegionOut
25794: PPUSH
25795: CALL_OW 337
// end ;
25799: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25800: LD_EXP 38
25804: IFFALSE 25879
25806: GO 25808
25808: DISABLE
25809: LD_INT 0
25811: PPUSH
// begin enable ;
25812: ENABLE
// for i in legionEscapeUnits do
25813: LD_ADDR_VAR 0 1
25817: PUSH
25818: LD_EXP 38
25822: PUSH
25823: FOR_IN
25824: IFFALSE 25877
// begin if IsInArea ( i , legionEscapeArea ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 31
25833: PPUSH
25834: CALL_OW 308
25838: IFFALSE 25851
// RemoveUnit ( i ) else
25840: LD_VAR 0 1
25844: PPUSH
25845: CALL_OW 64
25849: GO 25875
// if not HasTask ( i ) then
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 314
25860: NOT
25861: IFFALSE 25875
// ComMoveToArea ( i , legionEscapeArea ) ;
25863: LD_VAR 0 1
25867: PPUSH
25868: LD_INT 31
25870: PPUSH
25871: CALL_OW 113
// end ;
25875: GO 25823
25877: POP
25878: POP
// end ;
25879: PPOPN 1
25881: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25882: LD_INT 1
25884: PPUSH
25885: LD_EXP 62
25889: PPUSH
25890: CALL_OW 292
25894: IFFALSE 26192
25896: GO 25898
25898: DISABLE
25899: LD_INT 0
25901: PPUSH
// begin wait ( 0 0$2 ) ;
25902: LD_INT 70
25904: PPUSH
25905: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25909: LD_EXP 62
25913: PPUSH
25914: CALL_OW 87
// DialogueOn ;
25918: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25922: LD_EXP 39
25926: PPUSH
25927: LD_STRING D14-JMM-1
25929: PPUSH
25930: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25934: LD_EXP 62
25938: PPUSH
25939: LD_STRING D14-Friend-1
25941: PPUSH
25942: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25946: LD_EXP 39
25950: PPUSH
25951: LD_STRING D14-JMM-2
25953: PPUSH
25954: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_STRING D14-Friend-2
25965: PPUSH
25966: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25970: LD_EXP 39
25974: PPUSH
25975: LD_STRING D14-JMM-3
25977: PPUSH
25978: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25982: LD_EXP 62
25986: PPUSH
25987: LD_STRING D14-Friend-3
25989: PPUSH
25990: CALL_OW 88
// DialogueOff ;
25994: CALL_OW 7
// dec = Query ( Q14 ) ;
25998: LD_ADDR_VAR 0 1
26002: PUSH
26003: LD_STRING Q14
26005: PPUSH
26006: CALL_OW 97
26010: ST_TO_ADDR
// if dec = 1 then
26011: LD_VAR 0 1
26015: PUSH
26016: LD_INT 1
26018: EQUAL
26019: IFFALSE 26053
// begin DialogueOn ;
26021: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26025: LD_EXP 39
26029: PPUSH
26030: LD_STRING D14a-JMM-1
26032: PPUSH
26033: CALL_OW 88
// DialogueOff ;
26037: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26041: LD_EXP 62
26045: PPUSH
26046: LD_INT 1
26048: PPUSH
26049: CALL_OW 235
// end ; if dec = 2 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: IFFALSE 26114
// begin DialogueOn ;
26063: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26067: LD_EXP 39
26071: PPUSH
26072: LD_STRING D14b-JMM-1
26074: PPUSH
26075: CALL_OW 88
// DialogueOff ;
26079: CALL_OW 7
// wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_INT 9
26097: PPUSH
26098: LD_INT 2
26100: PPUSH
26101: CALL_OW 111
// AddComHold ( Friend ) ;
26105: LD_EXP 62
26109: PPUSH
26110: CALL_OW 200
// end ; if dec = 3 then
26114: LD_VAR 0 1
26118: PUSH
26119: LD_INT 3
26121: EQUAL
26122: IFFALSE 26192
// begin DialogueOn ;
26124: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26128: LD_EXP 39
26132: PPUSH
26133: LD_STRING D14c-JMM-1
26135: PPUSH
26136: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26140: LD_EXP 62
26144: PPUSH
26145: LD_STRING D14c-Friend-1
26147: PPUSH
26148: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26152: LD_EXP 39
26156: PPUSH
26157: LD_STRING D14c-JMM-2
26159: PPUSH
26160: CALL_OW 88
// DialogueOff ;
26164: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26168: LD_EXP 62
26172: PPUSH
26173: LD_INT 9
26175: PPUSH
26176: LD_INT 2
26178: PPUSH
26179: CALL_OW 111
// AddComHold ( Friend ) ;
26183: LD_EXP 62
26187: PPUSH
26188: CALL_OW 200
// end ; end ;
26192: PPOPN 1
26194: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 428
26205: PUSH
26206: LD_EXP 62
26210: EQUAL
26211: PUSH
26212: LD_EXP 62
26216: PPUSH
26217: CALL_OW 255
26221: PUSH
26222: LD_INT 8
26224: EQUAL
26225: AND
26226: IFFALSE 26240
26228: GO 26230
26230: DISABLE
// RemoveUnit ( Friend ) ;
26231: LD_EXP 62
26235: PPUSH
26236: CALL_OW 64
26240: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26241: LD_EXP 14
26245: PUSH
26246: LD_INT 31500
26248: GREATEREQUAL
26249: PUSH
26250: LD_EXP 7
26254: AND
26255: PUSH
26256: LD_EXP 2
26260: AND
26261: IFFALSE 26691
26263: GO 26265
26265: DISABLE
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
26270: PPUSH
// begin missionStage := 7 ;
26271: LD_ADDR_EXP 15
26275: PUSH
26276: LD_INT 7
26278: ST_TO_ADDR
// uc_side = 1 ;
26279: LD_ADDR_OWVAR 20
26283: PUSH
26284: LD_INT 1
26286: ST_TO_ADDR
// uc_nation = 1 ;
26287: LD_ADDR_OWVAR 21
26291: PUSH
26292: LD_INT 1
26294: ST_TO_ADDR
// for i = 1 to 5 do
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_INT 5
26307: PUSH
26308: FOR_TO
26309: IFFALSE 26405
// begin vc_engine = 3 ;
26311: LD_ADDR_OWVAR 39
26315: PUSH
26316: LD_INT 3
26318: ST_TO_ADDR
// vc_control = 3 ;
26319: LD_ADDR_OWVAR 38
26323: PUSH
26324: LD_INT 3
26326: ST_TO_ADDR
// vc_chassis = 3 ;
26327: LD_ADDR_OWVAR 37
26331: PUSH
26332: LD_INT 3
26334: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26335: LD_ADDR_OWVAR 40
26339: PUSH
26340: LD_INT 5
26342: PUSH
26343: LD_INT 9
26345: PUSH
26346: LD_INT 7
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PPUSH
26357: LD_INT 3
26359: PPUSH
26360: CALL_OW 12
26364: ARRAY
26365: ST_TO_ADDR
// veh = CreateVehicle ;
26366: LD_ADDR_VAR 0 2
26370: PUSH
26371: CALL_OW 45
26375: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26376: LD_VAR 0 2
26380: PPUSH
26381: LD_INT 1
26383: PPUSH
26384: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_INT 19
26395: PPUSH
26396: LD_INT 0
26398: PPUSH
26399: CALL_OW 49
// end ;
26403: GO 26308
26405: POP
26406: POP
// vc_engine = 3 ;
26407: LD_ADDR_OWVAR 39
26411: PUSH
26412: LD_INT 3
26414: ST_TO_ADDR
// vc_control = 1 ;
26415: LD_ADDR_OWVAR 38
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// vc_chassis = 3 ;
26423: LD_ADDR_OWVAR 37
26427: PUSH
26428: LD_INT 3
26430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26431: LD_ADDR_OWVAR 40
26435: PUSH
26436: LD_INT 5
26438: PUSH
26439: LD_INT 9
26441: PUSH
26442: LD_INT 7
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 1
26452: PPUSH
26453: LD_INT 3
26455: PPUSH
26456: CALL_OW 12
26460: ARRAY
26461: ST_TO_ADDR
// vehG = CreateVehicle ;
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: CALL_OW 45
26471: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 19
26491: PPUSH
26492: LD_INT 0
26494: PPUSH
26495: CALL_OW 49
// if JMMGirl = 1 then
26499: LD_EXP 7
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26563
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26509: LD_ADDR_EXP 40
26513: PUSH
26514: LD_STRING Joan
26516: PPUSH
26517: LD_INT 1
26519: PPUSH
26520: LD_STRING 14_
26522: PPUSH
26523: CALL 65553 0 3
26527: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26528: LD_EXP 40
26532: PPUSH
26533: LD_VAR 0 3
26537: PPUSH
26538: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26542: LD_VAR 0 3
26546: PPUSH
26547: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26551: LD_EXP 40
26555: PPUSH
26556: LD_STRING D10BW-Joan-1
26558: PPUSH
26559: CALL_OW 94
// end ; if JMMGirl = 2 then
26563: LD_EXP 7
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26627
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26573: LD_ADDR_EXP 42
26577: PUSH
26578: LD_STRING Lisa
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_STRING 14_
26586: PPUSH
26587: CALL 65553 0 3
26591: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26592: LD_EXP 42
26596: PPUSH
26597: LD_VAR 0 3
26601: PPUSH
26602: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26615: LD_EXP 42
26619: PPUSH
26620: LD_STRING D10BW-Lisa-1
26622: PPUSH
26623: CALL_OW 94
// end ; if JMMGirl = 3 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 3
26634: EQUAL
26635: IFFALSE 26691
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26637: LD_ADDR_EXP 54
26641: PUSH
26642: LD_STRING Connie
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65553 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26656: LD_EXP 54
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26679: LD_EXP 54
26683: PPUSH
26684: LD_STRING D10BW-Con-1
26686: PPUSH
26687: CALL_OW 94
// end ; end ;
26691: PPOPN 3
26693: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26694: LD_EXP 14
26698: PUSH
26699: LD_INT 94500
26701: GREATEREQUAL
26702: IFFALSE 27114
26704: GO 26706
26706: DISABLE
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// begin tmp := PrepareStevensSquad ;
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: CALL 2222 0 0
26721: ST_TO_ADDR
// if not tmp then
26722: LD_VAR 0 3
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 27114
// uc_side := 1 ;
26731: LD_ADDR_OWVAR 20
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// uc_nation := 1 ;
26739: LD_ADDR_OWVAR 21
26743: PUSH
26744: LD_INT 1
26746: ST_TO_ADDR
// for i in tmp do
26747: LD_ADDR_VAR 0 1
26751: PUSH
26752: LD_VAR 0 3
26756: PUSH
26757: FOR_IN
26758: IFFALSE 26855
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26760: LD_INT 3
26762: PPUSH
26763: LD_INT 3
26765: PPUSH
26766: LD_INT 1
26768: PPUSH
26769: LD_INT 5
26771: PUSH
26772: LD_INT 9
26774: PUSH
26775: LD_INT 7
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PPUSH
26786: LD_INT 3
26788: PPUSH
26789: CALL_OW 12
26793: ARRAY
26794: PPUSH
26795: LD_INT 40
26797: PPUSH
26798: CALL 70417 0 5
// veh := CreateVehicle ;
26802: LD_ADDR_VAR 0 2
26806: PUSH
26807: CALL_OW 45
26811: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26812: LD_VAR 0 2
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_INT 19
26831: PPUSH
26832: LD_INT 0
26834: PPUSH
26835: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26839: LD_VAR 0 1
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: CALL_OW 52
// end ;
26853: GO 26757
26855: POP
26856: POP
// missionStage := 8 ;
26857: LD_ADDR_EXP 15
26861: PUSH
26862: LD_INT 8
26864: ST_TO_ADDR
// DialogueOn ;
26865: CALL_OW 6
// if Stevens then
26869: LD_EXP 41
26873: IFFALSE 26987
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26875: LD_EXP 41
26879: PPUSH
26880: CALL_OW 310
26884: PPUSH
26885: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26889: LD_EXP 41
26893: PPUSH
26894: LD_STRING D8-Huck-1
26896: PPUSH
26897: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26901: LD_EXP 39
26905: PPUSH
26906: LD_STRING D8-JMM-1
26908: PPUSH
26909: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26913: LD_EXP 41
26917: PPUSH
26918: LD_STRING D8-Huck-2
26920: PPUSH
26921: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26925: LD_EXP 39
26929: PPUSH
26930: LD_STRING D8-JMM-2
26932: PPUSH
26933: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26937: LD_EXP 41
26941: PPUSH
26942: LD_STRING D8-Huck-3
26944: PPUSH
26945: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26949: LD_EXP 39
26953: PPUSH
26954: LD_STRING D8-JMM-3
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26961: LD_EXP 41
26965: PPUSH
26966: LD_STRING D8-Huck-4
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-4
26980: PPUSH
26981: CALL_OW 88
// end else
26985: GO 27097
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26987: LD_EXP 55
26991: PPUSH
26992: CALL_OW 310
26996: PPUSH
26997: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27001: LD_EXP 55
27005: PPUSH
27006: LD_STRING D8-Huck-1
27008: PPUSH
27009: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27013: LD_EXP 39
27017: PPUSH
27018: LD_STRING D8-JMM-1a
27020: PPUSH
27021: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27025: LD_EXP 55
27029: PPUSH
27030: LD_STRING D8-Huck-2
27032: PPUSH
27033: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27037: LD_EXP 39
27041: PPUSH
27042: LD_STRING D8-JMM-2
27044: PPUSH
27045: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27049: LD_EXP 55
27053: PPUSH
27054: LD_STRING D8-Huck-3
27056: PPUSH
27057: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27061: LD_EXP 39
27065: PPUSH
27066: LD_STRING D8-JMM-3
27068: PPUSH
27069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27073: LD_EXP 55
27077: PPUSH
27078: LD_STRING D8-Huck-4
27080: PPUSH
27081: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D8-JMM-4
27092: PPUSH
27093: CALL_OW 88
// end ; DialogueOff ;
27097: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27101: LD_INT 25
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: LD_INT 1
27109: PPUSH
27110: CALL_OW 322
// end ;
27114: PPOPN 3
27116: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27117: LD_INT 1
27119: PPUSH
27120: LD_EXP 71
27124: PPUSH
27125: CALL_OW 292
27129: IFFALSE 27380
27131: GO 27133
27133: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27134: LD_EXP 71
27138: PPUSH
27139: CALL_OW 87
// DialogueOn ;
27143: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27147: LD_EXP 39
27151: PPUSH
27152: LD_STRING D10nB-JMM-1
27154: PPUSH
27155: CALL_OW 88
// if BurlakStatus = 1 then
27159: LD_EXP 9
27163: PUSH
27164: LD_INT 1
27166: EQUAL
27167: IFFALSE 27181
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27169: LD_EXP 70
27173: PPUSH
27174: LD_STRING D10nB-Vse-1a
27176: PPUSH
27177: CALL_OW 94
// end ; if BurlakStatus = 0 then
27181: LD_EXP 9
27185: PUSH
27186: LD_INT 0
27188: EQUAL
27189: IFFALSE 27203
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27191: LD_EXP 70
27195: PPUSH
27196: LD_STRING D10nB-Vse-1
27198: PPUSH
27199: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27203: LD_EXP 39
27207: PPUSH
27208: LD_STRING D10nB-JMM-2
27210: PPUSH
27211: CALL_OW 88
// if KappaStatus then
27215: LD_EXP 2
27219: IFFALSE 27233
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27221: LD_EXP 70
27225: PPUSH
27226: LD_STRING D10nB-Vse-5a
27228: PPUSH
27229: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27233: LD_EXP 2
27237: NOT
27238: PUSH
27239: LD_EXP 6
27243: PUSH
27244: LD_INT 0
27246: EQUAL
27247: AND
27248: IFFALSE 27376
// begin if JMMGirl = 1 then
27250: LD_EXP 7
27254: PUSH
27255: LD_INT 1
27257: EQUAL
27258: IFFALSE 27308
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27260: LD_EXP 70
27264: PPUSH
27265: LD_STRING D10nB-Vse-2
27267: PPUSH
27268: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27272: LD_EXP 39
27276: PPUSH
27277: LD_STRING D10nB-JMM-3
27279: PPUSH
27280: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27284: LD_EXP 70
27288: PPUSH
27289: LD_STRING D10nB-Vse-3
27291: PPUSH
27292: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27296: LD_EXP 39
27300: PPUSH
27301: LD_STRING D10nB-JMM-4
27303: PPUSH
27304: CALL_OW 88
// end ; if JMMGirl = 2 then
27308: LD_EXP 7
27312: PUSH
27313: LD_INT 2
27315: EQUAL
27316: IFFALSE 27342
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27318: LD_EXP 70
27322: PPUSH
27323: LD_STRING D10nB-Vse-4
27325: PPUSH
27326: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27330: LD_EXP 39
27334: PPUSH
27335: LD_STRING D10nB-JMM-5
27337: PPUSH
27338: CALL_OW 88
// end ; if JMMGirl = 3 then
27342: LD_EXP 7
27346: PUSH
27347: LD_INT 3
27349: EQUAL
27350: IFFALSE 27376
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27352: LD_EXP 70
27356: PPUSH
27357: LD_STRING D10nB-Vse-5
27359: PPUSH
27360: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27364: LD_EXP 39
27368: PPUSH
27369: LD_STRING D10nB-JMM-6
27371: PPUSH
27372: CALL_OW 88
// end ; end ; DialogueOff ;
27376: CALL_OW 7
// end ;
27380: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27381: LD_EXP 14
27385: PUSH
27386: LD_INT 115500
27388: GREATEREQUAL
27389: IFFALSE 27765
27391: GO 27393
27393: DISABLE
27394: LD_INT 0
27396: PPUSH
// begin missionStage := 10 ;
27397: LD_ADDR_EXP 15
27401: PUSH
27402: LD_INT 10
27404: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27405: LD_ADDR_VAR 0 1
27409: PUSH
27410: LD_INT 22
27412: PUSH
27413: LD_INT 1
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 23
27422: PUSH
27423: LD_INT 1
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 26
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 3
27442: PUSH
27443: LD_INT 25
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 25
27462: PUSH
27463: LD_INT 16
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: PUSH
27486: LD_EXP 39
27490: PUSH
27491: LD_EXP 60
27495: PUSH
27496: LD_EXP 41
27500: PUSH
27501: LD_EXP 55
27505: PUSH
27506: LD_EXP 42
27510: PUSH
27511: LD_EXP 43
27515: PUSH
27516: LD_EXP 44
27520: PUSH
27521: LD_EXP 45
27525: PUSH
27526: LD_EXP 46
27530: PUSH
27531: LD_EXP 47
27535: PUSH
27536: LD_EXP 48
27540: PUSH
27541: LD_EXP 49
27545: PUSH
27546: LD_EXP 50
27550: PUSH
27551: LD_EXP 51
27555: PUSH
27556: LD_EXP 52
27560: PUSH
27561: LD_EXP 53
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: DIFF
27584: ST_TO_ADDR
// if not tmp and Brown then
27585: LD_VAR 0 1
27589: NOT
27590: PUSH
27591: LD_EXP 47
27595: AND
27596: IFFALSE 27611
// tmp := [ Brown ] ;
27598: LD_ADDR_VAR 0 1
27602: PUSH
27603: LD_EXP 47
27607: PUSH
27608: EMPTY
27609: LIST
27610: ST_TO_ADDR
// DialogueOn ;
27611: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27615: LD_VAR 0 1
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PPUSH
27624: LD_STRING D11-Sol1-1
27626: PPUSH
27627: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27631: LD_EXP 64
27635: PPUSH
27636: LD_STRING D11-Pla-1
27638: PPUSH
27639: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27643: LD_EXP 65
27647: PPUSH
27648: LD_STRING D11-Kov-1
27650: PPUSH
27651: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27655: LD_EXP 64
27659: PPUSH
27660: LD_STRING D11-Pla-2
27662: PPUSH
27663: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27667: LD_VAR 0 1
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_STRING D11-Sol1-2
27678: PPUSH
27679: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27683: LD_EXP 39
27687: PPUSH
27688: LD_STRING D11-JMM-2
27690: PPUSH
27691: CALL_OW 88
// DialogueOff ;
27695: CALL_OW 7
// allowBehemothConstruct := true ;
27699: LD_ADDR_EXP 25
27703: PUSH
27704: LD_INT 1
27706: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27707: LD_STRING M4
27709: PPUSH
27710: CALL_OW 337
// BuildBehemoths ;
27714: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
27718: LD_INT 31500
27720: PPUSH
27721: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27725: LD_EXP 27
27729: IFFALSE 27733
// break ;
27731: GO 27765
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27733: LD_INT 267
27735: PPUSH
27736: CALL_OW 274
27740: PPUSH
27741: LD_INT 1
27743: PPUSH
27744: CALL_OW 275
27748: PUSH
27749: LD_INT 1000
27751: GREATEREQUAL
27752: IFFALSE 27758
// BuildBehemoths ;
27754: CALL 7693 0 0
// until not behemothBuilders ;
27758: LD_EXP 73
27762: NOT
27763: IFFALSE 27718
// end ;
27765: PPOPN 1
27767: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27768: LD_EXP 73
27772: NOT
27773: PUSH
27774: LD_EXP 28
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 25
27785: AND
27786: IFFALSE 27806
27788: GO 27790
27790: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27791: LD_STRING M4a
27793: PPUSH
27794: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27798: LD_ADDR_EXP 27
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// end ;
27806: END
// every 0 0$1 trigger behemothDone do
27807: LD_EXP 28
27811: IFFALSE 27823
27813: GO 27815
27815: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27816: LD_STRING M4b
27818: PPUSH
27819: CALL_OW 337
27823: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27824: LD_EXP 29
27828: NOT
27829: IFFALSE 28025
27831: GO 27833
27833: DISABLE
27834: LD_INT 0
27836: PPUSH
27837: PPUSH
// begin enable ;
27838: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27839: LD_ADDR_VAR 0 1
27843: PUSH
27844: LD_INT 3
27846: PPUSH
27847: CALL 102352 0 1
27851: ST_TO_ADDR
// if not tmp and not behemothDone then
27852: LD_VAR 0 1
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: IFFALSE 27900
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27866: LD_ADDR_VAR 0 1
27870: PUSH
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 37
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: ST_TO_ADDR
// if not tmp then
27900: LD_VAR 0 1
27904: NOT
27905: IFFALSE 27909
// exit ;
27907: GO 28025
// for i in tmp do
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 1
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28023
// if See ( 1 , i ) then
27922: LD_INT 1
27924: PPUSH
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 292
27934: IFFALSE 28021
// begin if GetType ( i ) = unit_building then
27936: LD_VAR 0 2
27940: PPUSH
27941: CALL_OW 247
27945: PUSH
27946: LD_INT 3
27948: EQUAL
27949: IFFALSE 27987
// begin CenterNowOnUnits ( i ) ;
27951: LD_VAR 0 2
27955: PPUSH
27956: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27960: LD_EXP 39
27964: PPUSH
27965: LD_STRING D17a-JMM-1
27967: PPUSH
27968: CALL_OW 88
// seeBehemoth := true ;
27972: LD_ADDR_EXP 29
27976: PUSH
27977: LD_INT 1
27979: ST_TO_ADDR
// disable ;
27980: DISABLE
// exit ;
27981: POP
27982: POP
27983: GO 28025
// end else
27985: GO 28021
// begin CenterNowOnUnits ( i ) ;
27987: LD_VAR 0 2
27991: PPUSH
27992: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27996: LD_EXP 39
28000: PPUSH
28001: LD_STRING D17b-JMM-1
28003: PPUSH
28004: CALL_OW 88
// seeBehemoth := true ;
28008: LD_ADDR_EXP 29
28012: PUSH
28013: LD_INT 1
28015: ST_TO_ADDR
// disable ;
28016: DISABLE
// exit ;
28017: POP
28018: POP
28019: GO 28025
// end ; end ;
28021: GO 27919
28023: POP
28024: POP
// end ;
28025: PPOPN 2
28027: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28028: LD_EXP 14
28032: PUSH
28033: LD_INT 123200
28035: GREATEREQUAL
28036: IFFALSE 29212
28038: GO 28040
28040: DISABLE
28041: LD_INT 0
28043: PPUSH
28044: PPUSH
28045: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28046: LD_INT 2
28048: PPUSH
28049: LD_INT 23
28051: PUSH
28052: LD_INT 3
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: LD_INT 48
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: PPUSH
28070: CALL 59147 0 2
// repeat wait ( 0 0$1 ) ;
28074: LD_INT 35
28076: PPUSH
28077: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28081: LD_INT 22
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 48
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: CALL_OW 69
28109: IFFALSE 28074
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28111: LD_ADDR_VAR 0 1
28115: PUSH
28116: LD_INT 22
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 34
28128: PUSH
28129: LD_INT 48
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 69
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: ST_TO_ADDR
// missionStage := 12 ;
28149: LD_ADDR_EXP 15
28153: PUSH
28154: LD_INT 12
28156: ST_TO_ADDR
// platonovHasBomb := true ;
28157: LD_ADDR_EXP 30
28161: PUSH
28162: LD_INT 1
28164: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 181
28172: PPUSH
28173: LD_INT 86
28175: PPUSH
28176: CALL_OW 171
// AddComHold ( bomb ) ;
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 200
// wait ( 0 0$10 ) ;
28189: LD_INT 350
28191: PPUSH
28192: CALL_OW 67
// DialogueOn ;
28196: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28200: LD_EXP 64
28204: PPUSH
28205: LD_STRING D15-Pla-1
28207: PPUSH
28208: CALL_OW 94
// dec = Query ( Q15a ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_STRING Q15a
28219: PPUSH
28220: CALL_OW 97
28224: ST_TO_ADDR
// if dec = 1 then
28225: LD_VAR 0 2
28229: PUSH
28230: LD_INT 1
28232: EQUAL
28233: IFFALSE 28256
// begin Say ( JMM , D15a-JMM-1 ) ;
28235: LD_EXP 39
28239: PPUSH
28240: LD_STRING D15a-JMM-1
28242: PPUSH
28243: CALL_OW 88
// YouLost ( Surrender ) ;
28247: LD_STRING Surrender
28249: PPUSH
28250: CALL_OW 104
// exit ;
28254: GO 29212
// end ; if dec = 2 then
28256: LD_VAR 0 2
28260: PUSH
28261: LD_INT 2
28263: EQUAL
28264: IFFALSE 28333
// begin Say ( JMM , D15b-JMM-1 ) ;
28266: LD_EXP 39
28270: PPUSH
28271: LD_STRING D15b-JMM-1
28273: PPUSH
28274: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28278: LD_EXP 64
28282: PPUSH
28283: LD_STRING D15b-Pla-1
28285: PPUSH
28286: CALL_OW 94
// DialogueOff ;
28290: CALL_OW 7
// wait ( 3 3$00 ) ;
28294: LD_INT 6300
28296: PPUSH
28297: CALL_OW 67
// DialogueOn ;
28301: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28305: LD_EXP 39
28309: PPUSH
28310: LD_STRING D15d-JMM-1a
28312: PPUSH
28313: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28317: LD_EXP 64
28321: PPUSH
28322: LD_STRING D15d-Pla-1
28324: PPUSH
28325: CALL_OW 94
// DialogueOff ;
28329: CALL_OW 7
// end ; if dec = 3 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 3
28340: EQUAL
28341: IFFALSE 28395
// begin Say ( JMM , D15c-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15c-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15c-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// wait ( 0 0$15 ) ;
28371: LD_INT 525
28373: PPUSH
28374: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28378: LD_VAR 0 1
28382: PPUSH
28383: LD_INT 60
28385: PPUSH
28386: LD_INT 95
28388: PPUSH
28389: CALL_OW 116
// exit ;
28393: GO 29212
// end ; if dec = 4 then
28395: LD_VAR 0 2
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28433
// begin Say ( JMM , D15d-JMM-1 ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28433: LD_EXP 62
28437: PPUSH
28438: CALL_OW 302
28442: PUSH
28443: LD_EXP 62
28447: PPUSH
28448: CALL_OW 255
28452: PUSH
28453: LD_INT 1
28455: EQUAL
28456: AND
28457: PUSH
28458: LD_INT 22
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 34
28470: PUSH
28471: LD_INT 8
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PPUSH
28482: CALL_OW 69
28486: NOT
28487: AND
28488: IFFALSE 29113
// begin SetSide ( Friend , 8 ) ;
28490: LD_EXP 62
28494: PPUSH
28495: LD_INT 8
28497: PPUSH
28498: CALL_OW 235
// if IsInUnit ( Friend ) then
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( Friend ) ;
28513: LD_EXP 62
28517: PPUSH
28518: CALL_OW 122
// if IsDriver ( Friend ) then
28522: LD_EXP 62
28526: PPUSH
28527: CALL 99897 0 1
28531: IFFALSE 28542
// ComExitVehicle ( Friend ) ;
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28542: LD_EXP 62
28546: PPUSH
28547: LD_INT 9
28549: PPUSH
28550: LD_INT 2
28552: PPUSH
28553: CALL_OW 171
// wait ( 0 0$05 ) ;
28557: LD_INT 175
28559: PPUSH
28560: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28564: LD_EXP 62
28568: PPUSH
28569: CALL_OW 87
// DialogueOn ;
28573: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28577: LD_EXP 39
28581: PPUSH
28582: LD_STRING D16-JMM-1
28584: PPUSH
28585: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28589: LD_EXP 62
28593: PPUSH
28594: LD_STRING D16-Friend-1
28596: PPUSH
28597: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28601: LD_EXP 39
28605: PPUSH
28606: LD_STRING D16-JMM-2
28608: PPUSH
28609: CALL_OW 88
// DialogueOff ;
28613: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28617: LD_EXP 62
28621: PPUSH
28622: LD_INT 1
28624: PPUSH
28625: CALL_OW 235
// ComHold ( Friend ) ;
28629: LD_EXP 62
28633: PPUSH
28634: CALL_OW 140
// wait ( 0 0$20 ) ;
28638: LD_INT 700
28640: PPUSH
28641: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28645: LD_EXP 62
28649: PPUSH
28650: LD_INT 9
28652: PPUSH
28653: LD_INT 2
28655: PPUSH
28656: CALL_OW 297
28660: PUSH
28661: LD_INT 30
28663: LESS
28664: IFFALSE 28733
// begin SetSide ( Friend , 8 ) ;
28666: LD_EXP 62
28670: PPUSH
28671: LD_INT 8
28673: PPUSH
28674: CALL_OW 235
// if IsInUnit ( Friend ) then
28678: LD_EXP 62
28682: PPUSH
28683: CALL_OW 310
28687: IFFALSE 28698
// ComExitBuilding ( Friend ) ;
28689: LD_EXP 62
28693: PPUSH
28694: CALL_OW 122
// if IsDriver ( Friend ) then
28698: LD_EXP 62
28702: PPUSH
28703: CALL 99897 0 1
28707: IFFALSE 28718
// ComExitVehicle ( Friend ) ;
28709: LD_EXP 62
28713: PPUSH
28714: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28718: LD_EXP 62
28722: PPUSH
28723: LD_INT 9
28725: PPUSH
28726: LD_INT 2
28728: PPUSH
28729: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28733: LD_INT 1050
28735: PPUSH
28736: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28740: LD_INT 22
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 34
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PPUSH
28764: CALL_OW 69
28768: NOT
28769: IFFALSE 29091
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_INT 22
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 26
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 3
28798: PUSH
28799: LD_INT 25
28801: PUSH
28802: LD_INT 12
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 25
28811: PUSH
28812: LD_INT 16
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: PPUSH
28829: CALL_OW 69
28833: PUSH
28834: LD_EXP 39
28838: PUSH
28839: LD_EXP 41
28843: PUSH
28844: LD_EXP 55
28848: PUSH
28849: LD_EXP 42
28853: PUSH
28854: LD_EXP 43
28858: PUSH
28859: LD_EXP 44
28863: PUSH
28864: LD_EXP 45
28868: PUSH
28869: LD_EXP 46
28873: PUSH
28874: LD_EXP 47
28878: PUSH
28879: LD_EXP 48
28883: PUSH
28884: LD_EXP 49
28888: PUSH
28889: LD_EXP 50
28893: PUSH
28894: LD_EXP 51
28898: PUSH
28899: LD_EXP 52
28903: PUSH
28904: LD_EXP 53
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: DIFF
28926: ST_TO_ADDR
// DialogueOn ;
28927: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28931: LD_EXP 64
28935: PPUSH
28936: LD_STRING D16a-Pla-1
28938: PPUSH
28939: CALL_OW 94
// if Stevens then
28943: LD_EXP 41
28947: IFFALSE 28963
// Say ( Stevens , D16a-Huck-1 ) else
28949: LD_EXP 41
28953: PPUSH
28954: LD_STRING D16a-Huck-1
28956: PPUSH
28957: CALL_OW 88
28961: GO 29005
// if Baker then
28963: LD_EXP 55
28967: IFFALSE 28983
// Say ( Baker , D16a-Huck-1 ) else
28969: LD_EXP 55
28973: PPUSH
28974: LD_STRING D16a-Huck-1
28976: PPUSH
28977: CALL_OW 88
28981: GO 29005
// if tmp then
28983: LD_VAR 0 3
28987: IFFALSE 29005
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28989: LD_VAR 0 3
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_STRING D16a-Sol1-1
29000: PPUSH
29001: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29005: LD_EXP 62
29009: PPUSH
29010: CALL_OW 255
29014: PUSH
29015: LD_INT 8
29017: EQUAL
29018: IFFALSE 29034
// Say ( JMM , D16a-JMM-1 ) else
29020: LD_EXP 39
29024: PPUSH
29025: LD_STRING D16a-JMM-1
29027: PPUSH
29028: CALL_OW 88
29032: GO 29070
// begin Say ( JMM , D16a-JMM-1a ) ;
29034: LD_EXP 39
29038: PPUSH
29039: LD_STRING D16a-JMM-1a
29041: PPUSH
29042: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29046: LD_EXP 62
29050: PPUSH
29051: LD_STRING D16a-Friend-1
29053: PPUSH
29054: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29058: LD_EXP 62
29062: PPUSH
29063: LD_INT 3
29065: PPUSH
29066: CALL_OW 235
// end ; DialogueOff ;
29070: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: LD_INT 60
29081: PPUSH
29082: LD_INT 95
29084: PPUSH
29085: CALL_OW 116
// end else
29089: GO 29111
// begin DialogueOn ;
29091: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29095: LD_EXP 64
29099: PPUSH
29100: LD_STRING D16c-Pla-
29102: PPUSH
29103: CALL_OW 94
// DialogueOff ;
29107: CALL_OW 7
// end ; end else
29111: GO 29212
// begin wait ( 3 3$00 ) ;
29113: LD_INT 6300
29115: PPUSH
29116: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29120: LD_INT 22
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 34
29132: PUSH
29133: LD_INT 8
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PPUSH
29144: CALL_OW 69
29148: NOT
29149: IFFALSE 29192
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29151: LD_EXP 64
29155: PPUSH
29156: LD_STRING D16b-Pla-1
29158: PPUSH
29159: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29163: LD_EXP 39
29167: PPUSH
29168: LD_STRING D16b-JMM-
29170: PPUSH
29171: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 60
29182: PPUSH
29183: LD_INT 95
29185: PPUSH
29186: CALL_OW 116
// end else
29190: GO 29212
// begin DialogueOn ;
29192: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29196: LD_EXP 64
29200: PPUSH
29201: LD_STRING D16c-Pla-
29203: PPUSH
29204: CALL_OW 94
// DialogueOff ;
29208: CALL_OW 7
// end ; end ; end ;
29212: PPOPN 3
29214: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29215: LD_EXP 14
29219: PUSH
29220: LD_INT 126000
29222: GREATEREQUAL
29223: PUSH
29224: LD_EXP 23
29228: NOT
29229: AND
29230: PUSH
29231: LD_EXP 74
29235: PPUSH
29236: CALL_OW 302
29240: AND
29241: IFFALSE 29599
29243: GO 29245
29245: DISABLE
29246: LD_INT 0
29248: PPUSH
// begin missionStage = 11 ;
29249: LD_ADDR_EXP 15
29253: PUSH
29254: LD_INT 11
29256: ST_TO_ADDR
// DialogueOn ;
29257: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29261: LD_EXP 74
29265: PPUSH
29266: LD_STRING D9-Roth-1
29268: PPUSH
29269: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29273: LD_EXP 39
29277: PPUSH
29278: LD_STRING D9-JMM-1
29280: PPUSH
29281: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29285: LD_EXP 74
29289: PPUSH
29290: LD_STRING D9-Roth-2
29292: PPUSH
29293: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29297: LD_EXP 74
29301: PPUSH
29302: LD_STRING D9-Roth-2a
29304: PPUSH
29305: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29309: LD_EXP 64
29313: PPUSH
29314: LD_STRING D9-Pla-2
29316: PPUSH
29317: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29321: LD_EXP 74
29325: PPUSH
29326: LD_STRING D9-Roth-3
29328: PPUSH
29329: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29333: LD_EXP 64
29337: PPUSH
29338: LD_STRING D9-Pla-3
29340: PPUSH
29341: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-4
29352: PPUSH
29353: CALL_OW 94
// dec = Query ( Q9 ) ;
29357: LD_ADDR_VAR 0 1
29361: PUSH
29362: LD_STRING Q9
29364: PPUSH
29365: CALL_OW 97
29369: ST_TO_ADDR
// if dec = 1 then
29370: LD_VAR 0 1
29374: PUSH
29375: LD_INT 1
29377: EQUAL
29378: IFFALSE 29392
// SayRadio ( Roth , D9a-Roth-1 ) ;
29380: LD_EXP 74
29384: PPUSH
29385: LD_STRING D9a-Roth-1
29387: PPUSH
29388: CALL_OW 94
// if dec = 2 then
29392: LD_VAR 0 1
29396: PUSH
29397: LD_INT 2
29399: EQUAL
29400: IFFALSE 29426
// begin Say ( JMM , D9b-JMM-1 ) ;
29402: LD_EXP 39
29406: PPUSH
29407: LD_STRING D9b-JMM-1
29409: PPUSH
29410: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29414: LD_EXP 74
29418: PPUSH
29419: LD_STRING D9b-Roth-1
29421: PPUSH
29422: CALL_OW 94
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29496
// begin Say ( JMM , D9c-JMM-1 ) ;
29436: LD_EXP 39
29440: PPUSH
29441: LD_STRING D9c-JMM-1
29443: PPUSH
29444: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29448: LD_EXP 74
29452: PPUSH
29453: LD_STRING D9c-Roth-1
29455: PPUSH
29456: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29460: LD_EXP 39
29464: PPUSH
29465: LD_STRING D9c-JMM-2
29467: PPUSH
29468: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29472: LD_EXP 74
29476: PPUSH
29477: LD_STRING D9c-Roth-2
29479: PPUSH
29480: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29484: LD_EXP 39
29488: PPUSH
29489: LD_STRING D9c-JMM-3
29491: PPUSH
29492: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29496: LD_EXP 74
29500: PPUSH
29501: LD_STRING D9c-Roth-3
29503: PPUSH
29504: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9cont-Roth-1
29515: PPUSH
29516: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9cont-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9cont-Roth-2
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9cont-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9cont-Roth-3
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9cont-JMM-3
29575: PPUSH
29576: CALL_OW 88
// DialogueOff ;
29580: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29584: LD_STRING M3
29586: PPUSH
29587: CALL_OW 337
// allianceActive := true ;
29591: LD_ADDR_EXP 31
29595: PUSH
29596: LD_INT 1
29598: ST_TO_ADDR
// end ;
29599: PPOPN 1
29601: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29602: LD_INT 1
29604: PPUSH
29605: LD_INT 126
29607: PPUSH
29608: CALL_OW 292
29612: PUSH
29613: LD_EXP 64
29617: PPUSH
29618: CALL_OW 310
29622: AND
29623: IFFALSE 29703
29625: GO 29627
29627: DISABLE
29628: LD_INT 0
29630: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29631: LD_EXP 64
29635: PPUSH
29636: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29640: LD_ADDR_VAR 0 1
29644: PUSH
29645: LD_INT 4
29647: PPUSH
29648: LD_INT 22
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 70
29662: PPUSH
29663: LD_EXP 64
29667: PPUSH
29668: CALL_OW 74
29672: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29673: LD_EXP 64
29677: PPUSH
29678: LD_VAR 0 1
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29691: LD_EXP 64
29695: PPUSH
29696: LD_STRING D18-Pla-1
29698: PPUSH
29699: CALL_OW 88
// end ;
29703: PPOPN 1
29705: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29706: LD_EXP 64
29710: PPUSH
29711: CALL_OW 301
29715: PUSH
29716: LD_EXP 67
29720: PPUSH
29721: CALL_OW 301
29725: AND
29726: PUSH
29727: LD_INT 22
29729: PUSH
29730: LD_INT 3
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 21
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 50
29749: PUSH
29750: EMPTY
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 69
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: LD_INT 8
29768: PUSH
29769: LD_INT 9
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: LD_OWVAR 67
29781: ARRAY
29782: LESS
29783: AND
29784: IFFALSE 30555
29786: GO 29788
29788: DISABLE
29789: LD_INT 0
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
// begin MC_Kill ( 2 ) ;
29795: LD_INT 2
29797: PPUSH
29798: CALL 35385 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 3
29807: PPUSH
29808: LD_INT 1
29810: PPUSH
29811: LD_INT 1
29813: PPUSH
29814: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29818: LD_ADDR_VAR 0 1
29822: PUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 21
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 24
29845: PUSH
29846: LD_INT 900
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: FOR_IN
29864: IFFALSE 29895
// if GetSex ( i ) = sex_male then
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL_OW 258
29875: PUSH
29876: LD_INT 1
29878: EQUAL
29879: IFFALSE 29893
// begin tmp = i ;
29881: LD_ADDR_VAR 0 2
29885: PUSH
29886: LD_VAR 0 1
29890: ST_TO_ADDR
// break ;
29891: GO 29895
// end ;
29893: GO 29863
29895: POP
29896: POP
// if tmp = 0 then
29897: LD_VAR 0 2
29901: PUSH
29902: LD_INT 0
29904: EQUAL
29905: IFFALSE 29959
// begin uc_side = 3 ;
29907: LD_ADDR_OWVAR 20
29911: PUSH
29912: LD_INT 3
29914: ST_TO_ADDR
// uc_nation = 3 ;
29915: LD_ADDR_OWVAR 21
29919: PUSH
29920: LD_INT 3
29922: ST_TO_ADDR
// hc_name =  ;
29923: LD_ADDR_OWVAR 26
29927: PUSH
29928: LD_STRING 
29930: ST_TO_ADDR
// hc_gallery =  ;
29931: LD_ADDR_OWVAR 33
29935: PUSH
29936: LD_STRING 
29938: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 10
29944: PPUSH
29945: CALL_OW 381
// tmp = CreateHuman ;
29949: LD_ADDR_VAR 0 2
29953: PUSH
29954: CALL_OW 44
29958: ST_TO_ADDR
// end ; DialogueOn ;
29959: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_STRING DSurrenderRussians-RSol1-1a
29970: PPUSH
29971: CALL_OW 94
// DialogueOff ;
29975: CALL_OW 7
// russianDestroyed := true ;
29979: LD_ADDR_EXP 21
29983: PUSH
29984: LD_INT 1
29986: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29987: LD_INT 22
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 21
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PPUSH
30011: CALL_OW 69
30015: PPUSH
30016: CALL_OW 122
// wait ( 0 0$1 ) ;
30020: LD_INT 35
30022: PPUSH
30023: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30027: LD_INT 22
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 21
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 69
30055: PPUSH
30056: LD_INT 25
30058: PPUSH
30059: CALL_OW 173
// wait ( 0 0$10 ) ;
30063: LD_INT 350
30065: PPUSH
30066: CALL_OW 67
// PrepareOmarInvasion ;
30070: CALL 13903 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30074: LD_ADDR_VAR 0 2
30078: PUSH
30079: LD_EXP 92
30083: PPUSH
30084: CALL_OW 250
30088: PUSH
30089: LD_EXP 92
30093: PPUSH
30094: CALL_OW 251
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: PPUSH
30121: LD_INT 1
30123: PPUSH
30124: LD_INT 8
30126: NEG
30127: PPUSH
30128: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30132: LD_EXP 92
30136: PPUSH
30137: CALL_OW 87
// DialogueOn ;
30141: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30145: LD_EXP 39
30149: PPUSH
30150: LD_STRING D19-JMM-1
30152: PPUSH
30153: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_INT 22
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 26
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 25
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 25
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 3
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 25
30217: PUSH
30218: LD_INT 4
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 25
30227: PUSH
30228: LD_INT 5
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 25
30237: PUSH
30238: LD_INT 8
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PUSH
30264: LD_EXP 39
30268: PUSH
30269: LD_EXP 40
30273: PUSH
30274: LD_EXP 41
30278: PUSH
30279: LD_EXP 42
30283: PUSH
30284: LD_EXP 43
30288: PUSH
30289: LD_EXP 44
30293: PUSH
30294: LD_EXP 45
30298: PUSH
30299: LD_EXP 46
30303: PUSH
30304: LD_EXP 47
30308: PUSH
30309: LD_EXP 48
30313: PUSH
30314: LD_EXP 49
30318: PUSH
30319: LD_EXP 50
30323: PUSH
30324: LD_EXP 51
30328: PUSH
30329: LD_EXP 52
30333: PUSH
30334: LD_EXP 53
30338: PUSH
30339: LD_EXP 54
30343: PUSH
30344: LD_EXP 55
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: DIFF
30368: ST_TO_ADDR
// if tmp2 then
30369: LD_VAR 0 3
30373: IFFALSE 30391
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30375: LD_VAR 0 3
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: LD_STRING D19-Sol1-1
30386: PPUSH
30387: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30391: LD_EXP 39
30395: PPUSH
30396: LD_STRING D19-JMM-2
30398: PPUSH
30399: CALL_OW 88
// DialogueOff ;
30403: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30407: LD_VAR 0 2
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: LD_VAR 0 2
30420: PUSH
30421: LD_INT 2
30423: ARRAY
30424: PPUSH
30425: LD_INT 1
30427: PPUSH
30428: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30432: LD_STRING M5
30434: PPUSH
30435: CALL_OW 337
// omarOnMotherLode := false ;
30439: LD_ADDR_VAR 0 4
30443: PUSH
30444: LD_INT 0
30446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30447: LD_INT 35
30449: PPUSH
30450: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30454: LD_EXP 92
30458: PPUSH
30459: LD_INT 215
30461: PPUSH
30462: LD_INT 100
30464: PPUSH
30465: CALL_OW 297
30469: PUSH
30470: LD_INT 10
30472: LESS
30473: PUSH
30474: LD_VAR 0 4
30478: NOT
30479: AND
30480: IFFALSE 30514
// begin omarOnMotherLode := true ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_INT 1
30489: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30490: LD_EXP 39
30494: PPUSH
30495: LD_STRING D19b-JMM-1
30497: PPUSH
30498: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30502: LD_EXP 92
30506: PPUSH
30507: LD_STRING DOmarContam-Omar-1
30509: PPUSH
30510: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30514: LD_EXP 92
30518: PPUSH
30519: CALL_OW 301
30523: IFFALSE 30447
// Say ( JMM , D19a-JMM-1 ) ;
30525: LD_EXP 39
30529: PPUSH
30530: LD_STRING D19a-JMM-1
30532: PPUSH
30533: CALL_OW 88
// if Heike then
30537: LD_EXP 93
30541: IFFALSE 30555
// Say ( Heike , D19a-Hke-1 ) ;
30543: LD_EXP 93
30547: PPUSH
30548: LD_STRING D19a-Hke-1
30550: PPUSH
30551: CALL_OW 88
// end ;
30555: PPOPN 4
30557: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30558: LD_INT 22
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 21
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PPUSH
30582: CALL_OW 69
30586: PUSH
30587: LD_EXP 21
30591: AND
30592: IFFALSE 30660
30594: GO 30596
30596: DISABLE
30597: LD_INT 0
30599: PPUSH
30600: PPUSH
// begin enable ;
30601: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: LD_INT 25
30609: PPUSH
30610: LD_INT 22
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PPUSH
30620: CALL_OW 70
30624: ST_TO_ADDR
// if not tmp then
30625: LD_VAR 0 2
30629: NOT
30630: IFFALSE 30634
// exit ;
30632: GO 30660
// for i in tmp do
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_VAR 0 2
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30658
// RemoveUnit ( i ) ;
30647: LD_VAR 0 1
30651: PPUSH
30652: CALL_OW 64
30656: GO 30644
30658: POP
30659: POP
// end ;
30660: PPOPN 2
30662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30663: LD_INT 22
30665: PUSH
30666: LD_INT 7
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 21
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PPUSH
30687: CALL_OW 69
30691: PUSH
30692: LD_INT 6
30694: LESS
30695: IFFALSE 31163
30697: GO 30699
30699: DISABLE
30700: LD_INT 0
30702: PPUSH
30703: PPUSH
// begin MC_Kill ( 1 ) ;
30704: LD_INT 1
30706: PPUSH
30707: CALL 35385 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30711: LD_INT 7
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: LD_INT 1
30722: PPUSH
30723: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30727: LD_ADDR_VAR 0 1
30731: PUSH
30732: LD_INT 22
30734: PUSH
30735: LD_INT 7
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 26
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PPUSH
30756: CALL_OW 69
30760: PUSH
30761: LD_EXP 74
30765: DIFF
30766: ST_TO_ADDR
// if tmp then
30767: LD_VAR 0 1
30771: IFFALSE 30789
// tmp := tmp [ 1 ] else
30773: LD_ADDR_VAR 0 1
30777: PUSH
30778: LD_VAR 0 1
30782: PUSH
30783: LD_INT 1
30785: ARRAY
30786: ST_TO_ADDR
30787: GO 30825
// begin uc_side := 7 ;
30789: LD_ADDR_OWVAR 20
30793: PUSH
30794: LD_INT 7
30796: ST_TO_ADDR
// uc_nation := 1 ;
30797: LD_ADDR_OWVAR 21
30801: PUSH
30802: LD_INT 1
30804: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 8
30810: PPUSH
30811: CALL_OW 384
// tmp := CreateHuman ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: CALL_OW 44
30824: ST_TO_ADDR
// end ; DialogueOn ;
30825: CALL_OW 6
// if IsOK ( Roth ) then
30829: LD_EXP 74
30833: PPUSH
30834: CALL_OW 302
30838: IFFALSE 30852
// Say ( JMM , DAb-JMM-1 ) ;
30840: LD_EXP 39
30844: PPUSH
30845: LD_STRING DAb-JMM-1
30847: PPUSH
30848: CALL_OW 88
// if IsOK ( Roth ) then
30852: LD_EXP 74
30856: PPUSH
30857: CALL_OW 302
30861: IFFALSE 30885
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30863: LD_EXP 74
30867: PPUSH
30868: LD_STRING DSurrenderAlliance-Roth-1
30870: PPUSH
30871: CALL_OW 88
// RothCaptured := true ;
30875: LD_ADDR_EXP 33
30879: PUSH
30880: LD_INT 1
30882: ST_TO_ADDR
// end else
30883: GO 30897
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DSurrenderAlliance-Sci1-1
30892: PPUSH
30893: CALL_OW 88
// DialogueOff ;
30897: CALL_OW 7
// allianceDestroyed := true ;
30901: LD_ADDR_EXP 23
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// if capturedUnit = 0 then
30909: LD_EXP 34
30913: PUSH
30914: LD_INT 0
30916: EQUAL
30917: IFFALSE 30926
// SetAchievement ( ACH_ALLIANCE ) ;
30919: LD_STRING ACH_ALLIANCE
30921: PPUSH
30922: CALL_OW 543
// if trueAmericans then
30926: LD_EXP 35
30930: IFFALSE 31006
// begin if trueAmericans = 1 then
30932: LD_EXP 35
30936: PUSH
30937: LD_INT 1
30939: EQUAL
30940: IFFALSE 30956
// Say ( JMM , DAb-JMM-1a ) else
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING DAb-JMM-1a
30949: PPUSH
30950: CALL_OW 88
30954: GO 30968
// Say ( JMM , DAb-JMM-1b ) ;
30956: LD_EXP 39
30960: PPUSH
30961: LD_STRING DAb-JMM-1b
30963: PPUSH
30964: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30968: LD_EXP 35
30972: PPUSH
30973: CALL_OW 87
// for i in trueAmericans do
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_EXP 35
30986: PUSH
30987: FOR_IN
30988: IFFALSE 31004
// SetSide ( i , 1 ) ;
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_INT 1
30997: PPUSH
30998: CALL_OW 235
31002: GO 30987
31004: POP
31005: POP
// end ; repeat wait ( 0 0$1 ) ;
31006: LD_INT 35
31008: PPUSH
31009: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31013: LD_ADDR_VAR 0 2
31017: PUSH
31018: LD_INT 22
31020: PUSH
31021: LD_INT 7
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 21
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL_OW 69
31046: PUSH
31047: FOR_IN
31048: IFFALSE 31130
// begin if IsInUnit ( i ) then
31050: LD_VAR 0 2
31054: PPUSH
31055: CALL_OW 310
31059: IFFALSE 31070
// ComExitBuilding ( i ) ;
31061: LD_VAR 0 2
31065: PPUSH
31066: CALL_OW 122
// if IsDriver ( i ) then
31070: LD_VAR 0 2
31074: PPUSH
31075: CALL 99897 0 1
31079: IFFALSE 31090
// ComExitVehicle ( i ) ;
31081: LD_VAR 0 2
31085: PPUSH
31086: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31090: LD_VAR 0 2
31094: PPUSH
31095: LD_INT 26
31097: PPUSH
31098: CALL_OW 308
31102: NOT
31103: IFFALSE 31119
// AddComMoveToArea ( i , allianceEscapeArea ) else
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_INT 26
31112: PPUSH
31113: CALL_OW 173
31117: GO 31128
// RemoveUnit ( i ) ;
31119: LD_VAR 0 2
31123: PPUSH
31124: CALL_OW 64
// end ;
31128: GO 31047
31130: POP
31131: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31132: LD_INT 22
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 21
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PPUSH
31156: CALL_OW 69
31160: NOT
31161: IFFALSE 31006
// end ;
31163: PPOPN 2
31165: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31166: LD_INT 0
31168: PPUSH
31169: PPUSH
// if not unit then
31170: LD_VAR 0 1
31174: NOT
31175: IFFALSE 31179
// exit ;
31177: GO 32677
// DoNotAttack ( 7 , unit ) ;
31179: LD_INT 7
31181: PPUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_INT 260
31198: PPUSH
31199: LD_INT 235
31201: PPUSH
31202: LD_INT 3
31204: PPUSH
31205: LD_INT 1
31207: PPUSH
31208: CALL_OW 483
// SetSide ( unit , 4 ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_INT 4
31219: PPUSH
31220: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31224: LD_ADDR_EXP 34
31228: PUSH
31229: LD_EXP 34
31233: PUSH
31234: LD_INT 1
31236: PLUS
31237: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31238: LD_INT 70
31240: PPUSH
31241: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31245: LD_INT 260
31247: PPUSH
31248: LD_INT 235
31250: PPUSH
31251: LD_INT 1
31253: PPUSH
31254: LD_INT 8
31256: NEG
31257: PPUSH
31258: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31262: LD_VAR 0 1
31266: PPUSH
31267: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31271: LD_VAR 0 1
31275: PPUSH
31276: LD_EXP 74
31280: PPUSH
31281: CALL_OW 119
// DialogueOn ;
31285: CALL_OW 6
// case unit of JMM :
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 39
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31305: LD_EXP 39
31309: PPUSH
31310: LD_STRING DA1-JMM-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31761
31319: LD_EXP 40
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31330: LD_EXP 40
31334: PPUSH
31335: LD_STRING DA1-Joan-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31761
31344: LD_EXP 42
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31355: LD_EXP 42
31359: PPUSH
31360: LD_STRING DA1-Lisa-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31761
31369: LD_EXP 43
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31380: LD_EXP 43
31384: PPUSH
31385: LD_STRING DA1-Don-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31761
31394: LD_EXP 50
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31405: LD_EXP 50
31409: PPUSH
31410: LD_STRING DA1-Corn-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31761
31419: LD_EXP 46
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31430: LD_EXP 46
31434: PPUSH
31435: LD_STRING DA1-Den-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31761
31444: LD_EXP 44
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31455: LD_EXP 44
31459: PPUSH
31460: LD_STRING DA1-Bobby-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31761
31469: LD_EXP 48
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31480: LD_EXP 48
31484: PPUSH
31485: LD_STRING DA1-Glad-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31761
31494: LD_EXP 45
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31505: LD_EXP 45
31509: PPUSH
31510: LD_STRING DA1-Cyrus-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31761
31519: LD_EXP 41
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31530: LD_EXP 41
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31761
31544: LD_EXP 55
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31555: LD_EXP 55
31559: PPUSH
31560: LD_STRING DA1-Huck-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31761
31569: LD_EXP 47
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31580: LD_EXP 47
31584: PPUSH
31585: LD_STRING DA1-Brown-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31761
31594: LD_EXP 51
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31605: LD_EXP 51
31609: PPUSH
31610: LD_STRING DA1-Gary-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31761
31619: LD_EXP 54
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31630: LD_EXP 54
31634: PPUSH
31635: LD_STRING DA1-Con-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31761
31644: LD_EXP 60
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31655: LD_EXP 60
31659: PPUSH
31660: LD_STRING DA1-Kurt-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31761
31669: LD_EXP 53
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31680: LD_EXP 53
31684: PPUSH
31685: LD_STRING DA1-Yam-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31761
31694: LD_EXP 52
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31705: LD_EXP 52
31709: PPUSH
31710: LD_STRING DA1-Frank-1
31712: PPUSH
31713: CALL_OW 91
31717: GO 31761
31719: POP
// begin if GetSex ( unit ) = sex_male then
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 258
31729: PUSH
31730: LD_INT 1
31732: EQUAL
31733: IFFALSE 31749
// ForceSay ( unit , DA1-Sol1-1 ) else
31735: LD_VAR 0 1
31739: PPUSH
31740: LD_STRING DA1-Sol1-1
31742: PPUSH
31743: CALL_OW 91
31747: GO 31761
// ForceSay ( unit , DA1-FSol1-1 ) ;
31749: LD_VAR 0 1
31753: PPUSH
31754: LD_STRING DA1-FSol1-1
31756: PPUSH
31757: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31761: LD_EXP 74
31765: PPUSH
31766: LD_STRING DA-Roth-1
31768: PPUSH
31769: CALL_OW 88
// if capturedUnit = 1 then
31773: LD_EXP 34
31777: PUSH
31778: LD_INT 1
31780: EQUAL
31781: IFFALSE 31809
// begin Say ( Simms , DA-Sim-1 ) ;
31783: LD_EXP 75
31787: PPUSH
31788: LD_STRING DA-Sim-1
31790: PPUSH
31791: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31795: LD_EXP 74
31799: PPUSH
31800: LD_STRING DA-Roth-2
31802: PPUSH
31803: CALL_OW 88
// end else
31807: GO 31821
// Say ( Simms , DA-Sim-2 ) ;
31809: LD_EXP 75
31813: PPUSH
31814: LD_STRING DA-Sim-2
31816: PPUSH
31817: CALL_OW 88
// case unit of JMM :
31821: LD_VAR 0 1
31825: PUSH
31826: LD_EXP 39
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31837: LD_EXP 39
31841: PPUSH
31842: LD_STRING DA1-JMM-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32358
31851: LD_EXP 40
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31862: LD_EXP 40
31866: PPUSH
31867: LD_STRING DA1-Joan-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32358
31876: LD_EXP 42
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31887: LD_EXP 42
31891: PPUSH
31892: LD_STRING DA1-Lisa-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32358
31901: LD_EXP 43
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31912: LD_EXP 43
31916: PPUSH
31917: LD_STRING DA1-Don-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32358
31926: LD_EXP 50
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31937: LD_EXP 50
31941: PPUSH
31942: LD_STRING DA1-Corn-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32358
31951: LD_EXP 46
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31962: LD_EXP 46
31966: PPUSH
31967: LD_STRING DA1-Den-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32358
31976: LD_EXP 44
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31987: LD_EXP 44
31991: PPUSH
31992: LD_STRING DA1-Bobby-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32358
32001: LD_EXP 48
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32012: LD_EXP 48
32016: PPUSH
32017: LD_STRING DA1-Glad-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32358
32026: LD_EXP 45
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32037: LD_EXP 45
32041: PPUSH
32042: LD_STRING DA1-Cyrus-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32358
32051: LD_EXP 41
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32062: LD_EXP 41
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32358
32076: LD_EXP 55
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32087: LD_EXP 55
32091: PPUSH
32092: LD_STRING DA1-Huck-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32358
32101: LD_EXP 47
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32112: LD_EXP 47
32116: PPUSH
32117: LD_STRING DA1-Brown-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32358
32126: LD_EXP 51
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32137: LD_EXP 51
32141: PPUSH
32142: LD_STRING DA1-Gary-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32358
32151: LD_EXP 54
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32162: LD_EXP 54
32166: PPUSH
32167: LD_STRING DA1-Con-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32358
32176: LD_EXP 60
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32187: LD_EXP 60
32191: PPUSH
32192: LD_STRING DA1-Kurt-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32358
32201: LD_EXP 53
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32212: LD_EXP 53
32216: PPUSH
32217: LD_STRING DA1-Yam-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32358
32226: LD_EXP 52
32230: DOUBLE
32231: EQUAL
32232: IFTRUE 32236
32234: GO 32251
32236: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32237: LD_EXP 52
32241: PPUSH
32242: LD_STRING DA1-Frank-1a
32244: PPUSH
32245: CALL_OW 91
32249: GO 32358
32251: POP
// begin join := rand ( 0 , 1 ) ;
32252: LD_ADDR_VAR 0 3
32256: PUSH
32257: LD_INT 0
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 12
32267: ST_TO_ADDR
// if join then
32268: LD_VAR 0 3
32272: IFFALSE 32317
// begin if GetSex ( unit ) = sex_male then
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL_OW 258
32283: PUSH
32284: LD_INT 1
32286: EQUAL
32287: IFFALSE 32303
// ForceSay ( unit , DA1-Sol1-1b ) else
32289: LD_VAR 0 1
32293: PPUSH
32294: LD_STRING DA1-Sol1-1b
32296: PPUSH
32297: CALL_OW 91
32301: GO 32315
// ForceSay ( unit , DA1-FSol1-1b ) ;
32303: LD_VAR 0 1
32307: PPUSH
32308: LD_STRING DA1-FSol1-1b
32310: PPUSH
32311: CALL_OW 91
// end else
32315: GO 32358
// begin if GetSex ( unit ) = sex_male then
32317: LD_VAR 0 1
32321: PPUSH
32322: CALL_OW 258
32326: PUSH
32327: LD_INT 1
32329: EQUAL
32330: IFFALSE 32346
// ForceSay ( unit , DA1-Sol1-1a ) else
32332: LD_VAR 0 1
32336: PPUSH
32337: LD_STRING DA1-Sol1-1a
32339: PPUSH
32340: CALL_OW 91
32344: GO 32358
// ForceSay ( unit , DA1-FSol1-1a ) ;
32346: LD_VAR 0 1
32350: PPUSH
32351: LD_STRING DA1-FSol1-1a
32353: PPUSH
32354: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32358: LD_VAR 0 1
32362: PUSH
32363: LD_EXP 39
32367: EQUAL
32368: IFFALSE 32379
// begin YouLost ( JMMCaptured ) ;
32370: LD_STRING JMMCaptured
32372: PPUSH
32373: CALL_OW 104
// exit ;
32377: GO 32677
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32379: LD_VAR 0 1
32383: PUSH
32384: LD_EXP 43
32388: PUSH
32389: LD_EXP 46
32393: PUSH
32394: LD_EXP 44
32398: PUSH
32399: LD_EXP 41
32403: PUSH
32404: LD_EXP 55
32408: PUSH
32409: LD_EXP 47
32413: PUSH
32414: LD_EXP 53
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: IN
32428: PUSH
32429: LD_VAR 0 3
32433: OR
32434: IFFALSE 32533
// begin Say ( Roth , DA-Roth-3 ) ;
32436: LD_EXP 74
32440: PPUSH
32441: LD_STRING DA-Roth-3
32443: PPUSH
32444: CALL_OW 88
// SetSide ( unit , 7 ) ;
32448: LD_VAR 0 1
32452: PPUSH
32453: LD_INT 7
32455: PPUSH
32456: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32460: LD_ADDR_EXP 116
32464: PUSH
32465: LD_EXP 116
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: LD_EXP 116
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 1
32486: ADD
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32493: LD_INT 260
32495: PPUSH
32496: LD_INT 235
32498: PPUSH
32499: LD_INT 1
32501: PPUSH
32502: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32506: LD_VAR 0 1
32510: PPUSH
32511: LD_INT 1000
32513: PPUSH
32514: CALL_OW 234
// DialogueOff ;
32518: CALL_OW 7
// ComFree ( unit ) ;
32522: LD_VAR 0 1
32526: PPUSH
32527: CALL_OW 139
// end else
32531: GO 32614
// begin Say ( Roth , DA-Roth-3a ) ;
32533: LD_EXP 74
32537: PPUSH
32538: LD_STRING DA-Roth-3a
32540: PPUSH
32541: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32545: LD_ADDR_EXP 35
32549: PUSH
32550: LD_EXP 35
32554: PUSH
32555: LD_VAR 0 1
32559: ADD
32560: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32561: LD_INT 260
32563: PPUSH
32564: LD_INT 235
32566: PPUSH
32567: LD_INT 1
32569: PPUSH
32570: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 1000
32581: PPUSH
32582: CALL_OW 234
// DialogueOff ;
32586: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32590: LD_VAR 0 1
32594: PPUSH
32595: LD_INT 272
32597: PPUSH
32598: LD_INT 254
32600: PPUSH
32601: CALL_OW 111
// AddComHold ( unit ) ;
32605: LD_VAR 0 1
32609: PPUSH
32610: CALL_OW 200
// end ; if capturedUnit = 1 then
32614: LD_EXP 34
32618: PUSH
32619: LD_INT 1
32621: EQUAL
32622: IFFALSE 32677
// begin DialogueOn ;
32624: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32628: LD_EXP 39
32632: PPUSH
32633: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32637: LD_EXP 39
32641: PPUSH
32642: LD_STRING DAa-JMM-1
32644: PPUSH
32645: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32649: LD_EXP 39
32653: PPUSH
32654: LD_STRING DAa-JMM-1a
32656: PPUSH
32657: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32661: LD_EXP 39
32665: PPUSH
32666: LD_STRING DAa-JMM-1b
32668: PPUSH
32669: CALL_OW 88
// DialogueOff ;
32673: CALL_OW 7
// end ; end ;
32677: LD_VAR 0 2
32681: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32682: LD_EXP 15
32686: PUSH
32687: LD_INT 13
32689: GREATEREQUAL
32690: PUSH
32691: LD_INT 22
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PPUSH
32715: CALL_OW 69
32719: PUSH
32720: LD_INT 0
32722: EQUAL
32723: AND
32724: PUSH
32725: LD_INT 22
32727: PUSH
32728: LD_INT 2
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 33
32737: PUSH
32738: LD_INT 5
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 21
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 50
32757: PUSH
32758: EMPTY
32759: LIST
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: PPUSH
32767: CALL_OW 69
32771: PUSH
32772: LD_INT 0
32774: EQUAL
32775: AND
32776: PUSH
32777: LD_EXP 21
32781: AND
32782: PUSH
32783: LD_EXP 22
32787: AND
32788: PUSH
32789: LD_EXP 23
32793: AND
32794: IFFALSE 33443
32796: GO 32798
32798: DISABLE
32799: LD_INT 0
32801: PPUSH
32802: PPUSH
32803: PPUSH
// begin m1 := false ;
32804: LD_ADDR_VAR 0 1
32808: PUSH
32809: LD_INT 0
32811: ST_TO_ADDR
// m2 := false ;
32812: LD_ADDR_VAR 0 2
32816: PUSH
32817: LD_INT 0
32819: ST_TO_ADDR
// m3 := false ;
32820: LD_ADDR_VAR 0 3
32824: PUSH
32825: LD_INT 0
32827: ST_TO_ADDR
// if not bombExploded then
32828: LD_EXP 37
32832: NOT
32833: IFFALSE 32842
// SetAchievement ( ACH_SIBROCKET ) ;
32835: LD_STRING ACH_SIBROCKET
32837: PPUSH
32838: CALL_OW 543
// if tick <= 120 120$00 then
32842: LD_OWVAR 1
32846: PUSH
32847: LD_INT 252000
32849: LESSEQUAL
32850: IFFALSE 32866
// begin wait ( 3 ) ;
32852: LD_INT 3
32854: PPUSH
32855: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32859: LD_STRING ACH_ASPEED_15
32861: PPUSH
32862: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32866: LD_EXP 39
32870: PPUSH
32871: CALL_OW 87
// music_class := 5 ;
32875: LD_ADDR_OWVAR 72
32879: PUSH
32880: LD_INT 5
32882: ST_TO_ADDR
// music_nat := 5 ;
32883: LD_ADDR_OWVAR 71
32887: PUSH
32888: LD_INT 5
32890: ST_TO_ADDR
// DialogueOn ;
32891: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32895: LD_EXP 39
32899: PPUSH
32900: LD_STRING D20-JMM-1
32902: PPUSH
32903: CALL_OW 88
// if IsOK ( Joan ) then
32907: LD_EXP 40
32911: PPUSH
32912: CALL_OW 302
32916: IFFALSE 32930
// Say ( Joan , D20-Joan-1 ) ;
32918: LD_EXP 40
32922: PPUSH
32923: LD_STRING D20-Joan-1
32925: PPUSH
32926: CALL_OW 88
// if IsOk ( Lisa ) then
32930: LD_EXP 42
32934: PPUSH
32935: CALL_OW 302
32939: IFFALSE 32953
// Say ( Lisa , D20-Lisa-1 ) ;
32941: LD_EXP 42
32945: PPUSH
32946: LD_STRING D20-Lisa-1
32948: PPUSH
32949: CALL_OW 88
// if IsOk ( Donaldson ) then
32953: LD_EXP 43
32957: PPUSH
32958: CALL_OW 302
32962: IFFALSE 32976
// Say ( Donaldson , D20-Don-1 ) ;
32964: LD_EXP 43
32968: PPUSH
32969: LD_STRING D20-Don-1
32971: PPUSH
32972: CALL_OW 88
// if IsOK ( Cornel ) then
32976: LD_EXP 50
32980: PPUSH
32981: CALL_OW 302
32985: IFFALSE 32999
// Say ( Cornel , D20-Corn-1 ) ;
32987: LD_EXP 50
32991: PPUSH
32992: LD_STRING D20-Corn-1
32994: PPUSH
32995: CALL_OW 88
// if IsOk ( Denis ) then
32999: LD_EXP 46
33003: PPUSH
33004: CALL_OW 302
33008: IFFALSE 33022
// Say ( Denis , D20-Den-1 ) ;
33010: LD_EXP 46
33014: PPUSH
33015: LD_STRING D20-Den-1
33017: PPUSH
33018: CALL_OW 88
// if IsOk ( Bobby ) then
33022: LD_EXP 44
33026: PPUSH
33027: CALL_OW 302
33031: IFFALSE 33045
// Say ( Bobby , D20-Bobby-1 ) ;
33033: LD_EXP 44
33037: PPUSH
33038: LD_STRING D20-Bobby-1
33040: PPUSH
33041: CALL_OW 88
// if IsOk ( Gladstone ) then
33045: LD_EXP 48
33049: PPUSH
33050: CALL_OW 302
33054: IFFALSE 33068
// Say ( Gladstone , D20-Glad-1 ) ;
33056: LD_EXP 48
33060: PPUSH
33061: LD_STRING D20-Glad-1
33063: PPUSH
33064: CALL_OW 88
// if IsOk ( Cyrus ) then
33068: LD_EXP 45
33072: PPUSH
33073: CALL_OW 302
33077: IFFALSE 33091
// Say ( Cyrus , D20-Cyrus-1 ) ;
33079: LD_EXP 45
33083: PPUSH
33084: LD_STRING D20-Cyrus-1
33086: PPUSH
33087: CALL_OW 88
// if IsOk ( Stevens ) then
33091: LD_EXP 41
33095: PPUSH
33096: CALL_OW 302
33100: IFFALSE 33114
// Say ( Stevens , D20-Huck-1 ) ;
33102: LD_EXP 41
33106: PPUSH
33107: LD_STRING D20-Huck-1
33109: PPUSH
33110: CALL_OW 88
// if IsOk ( Brown ) then
33114: LD_EXP 47
33118: PPUSH
33119: CALL_OW 302
33123: IFFALSE 33137
// Say ( Brown , D20-Brown-1 ) ;
33125: LD_EXP 47
33129: PPUSH
33130: LD_STRING D20-Brown-1
33132: PPUSH
33133: CALL_OW 88
// if IsOk ( Gary ) then
33137: LD_EXP 51
33141: PPUSH
33142: CALL_OW 302
33146: IFFALSE 33160
// Say ( Gary , D20-Gary-1 ) ;
33148: LD_EXP 51
33152: PPUSH
33153: LD_STRING D20-Gary-1
33155: PPUSH
33156: CALL_OW 88
// if IsOk ( Connie ) then
33160: LD_EXP 54
33164: PPUSH
33165: CALL_OW 302
33169: IFFALSE 33183
// Say ( Connie , D20-Con-1 ) ;
33171: LD_EXP 54
33175: PPUSH
33176: LD_STRING D20-Con-1
33178: PPUSH
33179: CALL_OW 88
// if IsOk ( Kurt ) then
33183: LD_EXP 60
33187: PPUSH
33188: CALL_OW 302
33192: IFFALSE 33206
// Say ( Kurt , D20-Kurt-1 ) ;
33194: LD_EXP 60
33198: PPUSH
33199: LD_STRING D20-Kurt-1
33201: PPUSH
33202: CALL_OW 88
// if IsOk ( Kikuchi ) then
33206: LD_EXP 53
33210: PPUSH
33211: CALL_OW 302
33215: IFFALSE 33229
// Say ( Kikuchi , D20-Yam-1 ) ;
33217: LD_EXP 53
33221: PPUSH
33222: LD_STRING D20-Yam-1
33224: PPUSH
33225: CALL_OW 88
// if IsOk ( Frank ) then
33229: LD_EXP 52
33233: PPUSH
33234: CALL_OW 302
33238: IFFALSE 33252
// Say ( Frank , D20-Frank-1 ) ;
33240: LD_EXP 52
33244: PPUSH
33245: LD_STRING D20-Frank-1
33247: PPUSH
33248: CALL_OW 88
// DialogueOff ;
33252: CALL_OW 7
// if RothCaptured then
33256: LD_EXP 33
33260: IFFALSE 33282
// begin m1 := true ;
33262: LD_ADDR_VAR 0 1
33266: PUSH
33267: LD_INT 1
33269: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33270: LD_STRING Roth
33272: PPUSH
33273: LD_INT 1
33275: PPUSH
33276: CALL_OW 101
// end else
33280: GO 33293
// AddMedal ( Roth , - 1 ) ;
33282: LD_STRING Roth
33284: PPUSH
33285: LD_INT 1
33287: NEG
33288: PPUSH
33289: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33293: LD_EXP 25
33297: NOT
33298: PUSH
33299: LD_EXP 27
33303: OR
33304: IFFALSE 33326
// begin m2 := true ;
33306: LD_ADDR_VAR 0 2
33310: PUSH
33311: LD_INT 1
33313: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33314: LD_STRING Project
33316: PPUSH
33317: LD_INT 1
33319: PPUSH
33320: CALL_OW 101
// end else
33324: GO 33337
// AddMedal ( Project , - 1 ) ;
33326: LD_STRING Project
33328: PPUSH
33329: LD_INT 1
33331: NEG
33332: PPUSH
33333: CALL_OW 101
// if lostCounter = 0 then
33337: LD_EXP 32
33341: PUSH
33342: LD_INT 0
33344: EQUAL
33345: IFFALSE 33367
// begin m3 := true ;
33347: LD_ADDR_VAR 0 3
33351: PUSH
33352: LD_INT 1
33354: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33355: LD_STRING NoLosses
33357: PPUSH
33358: LD_INT 1
33360: PPUSH
33361: CALL_OW 101
// end else
33365: GO 33378
// AddMedal ( NoLosses , - 1 ) ;
33367: LD_STRING NoLosses
33369: PPUSH
33370: LD_INT 1
33372: NEG
33373: PPUSH
33374: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33378: LD_VAR 0 1
33382: PUSH
33383: LD_VAR 0 2
33387: AND
33388: PUSH
33389: LD_VAR 0 3
33393: AND
33394: PUSH
33395: LD_OWVAR 67
33399: PUSH
33400: LD_INT 3
33402: EQUAL
33403: AND
33404: IFFALSE 33416
// SetAchievementEX ( ACH_AMER , 15 ) ;
33406: LD_STRING ACH_AMER
33408: PPUSH
33409: LD_INT 15
33411: PPUSH
33412: CALL_OW 564
// GiveMedals ( MAIN ) ;
33416: LD_STRING MAIN
33418: PPUSH
33419: CALL_OW 102
// music_class := 4 ;
33423: LD_ADDR_OWVAR 72
33427: PUSH
33428: LD_INT 4
33430: ST_TO_ADDR
// music_nat := 1 ;
33431: LD_ADDR_OWVAR 71
33435: PUSH
33436: LD_INT 1
33438: ST_TO_ADDR
// YouWin ;
33439: CALL_OW 103
// end ; end_of_file
33443: PPOPN 3
33445: END
// export function CustomEvent ( event ) ; begin
33446: LD_INT 0
33448: PPUSH
// end ;
33449: LD_VAR 0 2
33453: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33454: LD_VAR 0 1
33458: PUSH
33459: LD_INT 1
33461: EQUAL
33462: PUSH
33463: LD_VAR 0 2
33467: PUSH
33468: LD_INT 4
33470: EQUAL
33471: AND
33472: PUSH
33473: LD_EXP 58
33477: PPUSH
33478: CALL_OW 300
33482: AND
33483: IFFALSE 33499
// begin wait ( 0 0$2 ) ;
33485: LD_INT 70
33487: PPUSH
33488: CALL_OW 67
// YouLost ( Dismissed ) ;
33492: LD_STRING Dismissed
33494: PPUSH
33495: CALL_OW 104
// end ; end ;
33499: PPOPN 2
33501: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33502: LD_VAR 0 2
33506: PPUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: LD_INT 18
33514: PPUSH
33515: CALL_OW 309
33519: IFFALSE 33528
// YouLost ( Motherlode3 ) ;
33521: LD_STRING Motherlode3
33523: PPUSH
33524: CALL_OW 104
// end ;
33528: PPOPN 3
33530: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33531: LD_EXP 27
33535: NOT
33536: IFFALSE 33546
// behemothDone := true ;
33538: LD_ADDR_EXP 28
33542: PUSH
33543: LD_INT 1
33545: ST_TO_ADDR
// end ;
33546: PPOPN 1
33548: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33549: LD_VAR 0 1
33553: PPUSH
33554: CALL_OW 255
33558: PUSH
33559: LD_INT 1
33561: EQUAL
33562: IFFALSE 33572
// bombExploded := true ;
33564: LD_ADDR_EXP 37
33568: PUSH
33569: LD_INT 1
33571: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33572: LD_VAR 0 1
33576: PPUSH
33577: CALL_OW 255
33581: PUSH
33582: LD_INT 1
33584: EQUAL
33585: PUSH
33586: LD_EXP 30
33590: AND
33591: PUSH
33592: LD_INT 22
33594: PUSH
33595: LD_INT 3
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 34
33604: PUSH
33605: LD_INT 48
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PPUSH
33616: CALL_OW 69
33620: AND
33621: PUSH
33622: LD_INT 22
33624: PUSH
33625: LD_INT 1
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 34
33634: PUSH
33635: LD_INT 8
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PPUSH
33646: CALL_OW 69
33650: NOT
33651: AND
33652: IFFALSE 33704
// begin wait ( 0 0$5 ) ;
33654: LD_INT 175
33656: PPUSH
33657: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33661: LD_INT 22
33663: PUSH
33664: LD_INT 3
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 34
33673: PUSH
33674: LD_INT 48
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: PPUSH
33685: CALL_OW 69
33689: PUSH
33690: LD_INT 1
33692: ARRAY
33693: PPUSH
33694: LD_INT 60
33696: PPUSH
33697: LD_INT 95
33699: PPUSH
33700: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33704: LD_VAR 0 2
33708: PPUSH
33709: LD_VAR 0 3
33713: PPUSH
33714: LD_INT 18
33716: PPUSH
33717: CALL_OW 309
33721: IFFALSE 33768
// begin if GetSide ( unit ) = 1 then
33723: LD_VAR 0 1
33727: PPUSH
33728: CALL_OW 255
33732: PUSH
33733: LD_INT 1
33735: EQUAL
33736: IFFALSE 33754
// begin wait ( 0 0$6 ) ;
33738: LD_INT 210
33740: PPUSH
33741: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33745: LD_STRING Motherlode2
33747: PPUSH
33748: CALL_OW 104
// end else
33752: GO 33768
// begin wait ( 0 0$6 ) ;
33754: LD_INT 210
33756: PPUSH
33757: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33761: LD_STRING Motherlode1
33763: PPUSH
33764: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33768: LD_VAR 0 1
33772: PPUSH
33773: CALL_OW 255
33777: PUSH
33778: LD_INT 3
33780: EQUAL
33781: IFFALSE 33802
// begin wait ( 0 0$5 ) ;
33783: LD_INT 175
33785: PPUSH
33786: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33790: LD_EXP 64
33794: PPUSH
33795: LD_STRING D18-Pla-1
33797: PPUSH
33798: CALL_OW 94
// end ; end ;
33802: PPOPN 3
33804: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33805: LD_VAR 0 1
33809: PUSH
33810: LD_INT 22
33812: PUSH
33813: LD_INT 1
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 21
33822: PUSH
33823: LD_INT 1
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 23
33832: PUSH
33833: LD_INT 1
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: LIST
33844: PPUSH
33845: CALL_OW 69
33849: IN
33850: IFFALSE 33866
// lostCounter := lostCounter + 1 ;
33852: LD_ADDR_EXP 32
33856: PUSH
33857: LD_EXP 32
33861: PUSH
33862: LD_INT 1
33864: PLUS
33865: ST_TO_ADDR
// if un in behemothBuilders then
33866: LD_VAR 0 1
33870: PUSH
33871: LD_EXP 73
33875: IN
33876: IFFALSE 33896
// begin behemothBuilders := behemothBuilders diff un ;
33878: LD_ADDR_EXP 73
33882: PUSH
33883: LD_EXP 73
33887: PUSH
33888: LD_VAR 0 1
33892: DIFF
33893: ST_TO_ADDR
// exit ;
33894: GO 33926
// end ; if un = JMM then
33896: LD_VAR 0 1
33900: PUSH
33901: LD_EXP 39
33905: EQUAL
33906: IFFALSE 33917
// begin YouLost ( JMM ) ;
33908: LD_STRING JMM
33910: PPUSH
33911: CALL_OW 104
// exit ;
33915: GO 33926
// end ; MCE_UnitDestroyed ( un ) ;
33917: LD_VAR 0 1
33921: PPUSH
33922: CALL 62567 0 1
// end ;
33926: PPOPN 1
33928: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33929: LD_VAR 0 1
33933: PPUSH
33934: LD_VAR 0 2
33938: PPUSH
33939: CALL 64901 0 2
// end ;
33943: PPOPN 2
33945: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33946: LD_VAR 0 1
33950: PPUSH
33951: CALL 63969 0 1
// end ;
33955: PPOPN 1
33957: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33958: LD_VAR 0 1
33962: PUSH
33963: LD_INT 22
33965: PUSH
33966: LD_INT 8
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 30
33975: PUSH
33976: LD_INT 2
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 23
33985: PUSH
33986: LD_INT 3
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: LIST
33997: PPUSH
33998: CALL_OW 69
34002: IN
34003: IFFALSE 34030
// begin ComUpgrade ( building ) ;
34005: LD_VAR 0 1
34009: PPUSH
34010: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34014: LD_EXP 61
34018: PPUSH
34019: LD_VAR 0 1
34023: PPUSH
34024: CALL 73402 0 2
// exit ;
34028: GO 34039
// end ; MCE_BuildingComplete ( building ) ;
34030: LD_VAR 0 1
34034: PPUSH
34035: CALL 64210 0 1
// end ;
34039: PPOPN 1
34041: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34042: LD_VAR 0 1
34046: PPUSH
34047: LD_VAR 0 2
34051: PPUSH
34052: CALL 62263 0 2
// end ;
34056: PPOPN 2
34058: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34059: LD_VAR 0 1
34063: PPUSH
34064: LD_VAR 0 2
34068: PPUSH
34069: LD_VAR 0 3
34073: PPUSH
34074: LD_VAR 0 4
34078: PPUSH
34079: LD_VAR 0 5
34083: PPUSH
34084: CALL 61883 0 5
// end ;
34088: PPOPN 5
34090: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34091: LD_VAR 0 1
34095: PPUSH
34096: LD_VAR 0 2
34100: PPUSH
34101: CALL 61464 0 2
// end ;
34105: PPOPN 2
34107: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34108: LD_VAR 0 1
34112: PPUSH
34113: LD_VAR 0 2
34117: PPUSH
34118: LD_VAR 0 3
34122: PPUSH
34123: LD_VAR 0 4
34127: PPUSH
34128: CALL 61302 0 4
// end ;
34132: PPOPN 4
34134: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34135: LD_VAR 0 1
34139: PPUSH
34140: LD_VAR 0 2
34144: PPUSH
34145: LD_VAR 0 3
34149: PPUSH
34150: CALL 61077 0 3
// end ;
34154: PPOPN 3
34156: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34157: LD_VAR 0 1
34161: PPUSH
34162: LD_VAR 0 2
34166: PPUSH
34167: CALL 60962 0 2
// end ;
34171: PPOPN 2
34173: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34174: LD_VAR 0 1
34178: PPUSH
34179: LD_VAR 0 2
34183: PPUSH
34184: CALL 65196 0 2
// end ;
34188: PPOPN 2
34190: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34191: LD_VAR 0 1
34195: PPUSH
34196: CALL_OW 255
34200: PUSH
34201: LD_INT 4
34203: EQUAL
34204: PUSH
34205: LD_VAR 0 1
34209: PUSH
34210: LD_EXP 18
34214: PUSH
34215: LD_INT 1
34217: ARRAY
34218: IN
34219: AND
34220: PUSH
34221: LD_EXP 19
34225: AND
34226: IFFALSE 34245
// begin ComMoveXY ( driver , 61 , 93 ) ;
34228: LD_VAR 0 1
34232: PPUSH
34233: LD_INT 61
34235: PPUSH
34236: LD_INT 93
34238: PPUSH
34239: CALL_OW 111
// exit ;
34243: GO 34269
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34245: LD_VAR 0 1
34249: PPUSH
34250: LD_VAR 0 2
34254: PPUSH
34255: LD_VAR 0 3
34259: PPUSH
34260: LD_VAR 0 4
34264: PPUSH
34265: CALL 65412 0 4
// end ;
34269: PPOPN 4
34271: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34272: LD_VAR 0 1
34276: PPUSH
34277: LD_VAR 0 2
34281: PPUSH
34282: CALL 60771 0 2
// end ;
34286: PPOPN 2
34288: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34289: LD_VAR 0 1
34293: PPUSH
34294: CALL 117586 0 1
// end ; end_of_file
34298: PPOPN 1
34300: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34301: LD_EXP 15
34305: PUSH
34306: LD_INT 2
34308: EQUAL
34309: IFFALSE 34788
34311: GO 34313
34313: DISABLE
34314: LD_INT 0
34316: PPUSH
// begin time := 0 0$40 ;
34317: LD_ADDR_VAR 0 1
34321: PUSH
34322: LD_INT 1400
34324: ST_TO_ADDR
// repeat wait ( time ) ;
34325: LD_VAR 0 1
34329: PPUSH
34330: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34334: LD_INT 1
34336: PPUSH
34337: LD_INT 5
34339: PPUSH
34340: CALL_OW 12
34344: PPUSH
34345: LD_INT 106
34347: PPUSH
34348: LD_INT 150
34350: PPUSH
34351: LD_INT 19
34353: PPUSH
34354: LD_INT 1
34356: PPUSH
34357: CALL_OW 56
// time := time + 0 0$9 ;
34361: LD_ADDR_VAR 0 1
34365: PUSH
34366: LD_VAR 0 1
34370: PUSH
34371: LD_INT 315
34373: PLUS
34374: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34375: LD_INT 455
34377: PPUSH
34378: LD_INT 840
34380: PPUSH
34381: CALL_OW 12
34385: PPUSH
34386: CALL_OW 67
// if Prob ( 50 ) then
34390: LD_INT 50
34392: PPUSH
34393: CALL_OW 13
34397: IFFALSE 34426
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34399: LD_INT 1
34401: PPUSH
34402: LD_INT 5
34404: PPUSH
34405: CALL_OW 12
34409: PPUSH
34410: LD_INT 62
34412: PPUSH
34413: LD_INT 108
34415: PPUSH
34416: LD_INT 10
34418: PPUSH
34419: LD_INT 1
34421: PPUSH
34422: CALL_OW 56
// until missionStage > 4 ;
34426: LD_EXP 15
34430: PUSH
34431: LD_INT 4
34433: GREATER
34434: IFFALSE 34325
// repeat wait ( 0 0$1 ) ;
34436: LD_INT 35
34438: PPUSH
34439: CALL_OW 67
// until missionStage = 6 ;
34443: LD_EXP 15
34447: PUSH
34448: LD_INT 6
34450: EQUAL
34451: IFFALSE 34436
// time := 0 0$50 ;
34453: LD_ADDR_VAR 0 1
34457: PUSH
34458: LD_INT 1750
34460: ST_TO_ADDR
// repeat wait ( time ) ;
34461: LD_VAR 0 1
34465: PPUSH
34466: CALL_OW 67
// if Prob ( 50 ) then
34470: LD_INT 50
34472: PPUSH
34473: CALL_OW 13
34477: IFFALSE 34506
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34479: LD_INT 1
34481: PPUSH
34482: LD_INT 5
34484: PPUSH
34485: CALL_OW 12
34489: PPUSH
34490: LD_INT 106
34492: PPUSH
34493: LD_INT 89
34495: PPUSH
34496: LD_INT 45
34498: PPUSH
34499: LD_INT 1
34501: PPUSH
34502: CALL_OW 56
// time := time + 0 0$2 ;
34506: LD_ADDR_VAR 0 1
34510: PUSH
34511: LD_VAR 0 1
34515: PUSH
34516: LD_INT 70
34518: PLUS
34519: ST_TO_ADDR
// if Prob ( 30 ) then
34520: LD_INT 30
34522: PPUSH
34523: CALL_OW 13
34527: IFFALSE 34573
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34529: LD_INT 385
34531: PPUSH
34532: LD_INT 945
34534: PPUSH
34535: CALL_OW 12
34539: PPUSH
34540: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34544: LD_INT 1
34546: PPUSH
34547: LD_INT 5
34549: PPUSH
34550: CALL_OW 12
34554: PPUSH
34555: LD_INT 21
34557: PPUSH
34558: LD_INT 26
34560: PPUSH
34561: LD_INT 12
34563: PPUSH
34564: LD_INT 1
34566: PPUSH
34567: CALL_OW 56
// end else
34571: GO 34609
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34573: LD_INT 700
34575: PPUSH
34576: LD_INT 1225
34578: PPUSH
34579: CALL_OW 12
34583: PPUSH
34584: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34588: LD_INT 1
34590: PPUSH
34591: LD_INT 5
34593: PPUSH
34594: CALL_OW 12
34598: PPUSH
34599: LD_INT 16
34601: PPUSH
34602: LD_INT 1
34604: PPUSH
34605: CALL_OW 55
// end ; if Prob ( 50 ) then
34609: LD_INT 50
34611: PPUSH
34612: CALL_OW 13
34616: IFFALSE 34662
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34618: LD_INT 700
34620: PPUSH
34621: LD_INT 1050
34623: PPUSH
34624: CALL_OW 12
34628: PPUSH
34629: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34633: LD_INT 1
34635: PPUSH
34636: LD_INT 5
34638: PPUSH
34639: CALL_OW 12
34643: PPUSH
34644: LD_INT 181
34646: PPUSH
34647: LD_INT 218
34649: PPUSH
34650: LD_INT 16
34652: PPUSH
34653: LD_INT 1
34655: PPUSH
34656: CALL_OW 56
// end else
34660: GO 34698
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34662: LD_INT 350
34664: PPUSH
34665: LD_INT 525
34667: PPUSH
34668: CALL_OW 12
34672: PPUSH
34673: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34677: LD_INT 1
34679: PPUSH
34680: LD_INT 5
34682: PPUSH
34683: CALL_OW 12
34687: PPUSH
34688: LD_INT 15
34690: PPUSH
34691: LD_INT 1
34693: PPUSH
34694: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34698: LD_INT 45
34700: PUSH
34701: LD_INT 32
34703: PUSH
34704: LD_INT 25
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: LIST
34711: PUSH
34712: LD_OWVAR 67
34716: ARRAY
34717: PPUSH
34718: CALL_OW 13
34722: IFFALSE 34766
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34724: LD_INT 175
34726: PPUSH
34727: LD_INT 315
34729: PPUSH
34730: CALL_OW 12
34734: PPUSH
34735: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34739: LD_INT 1
34741: PPUSH
34742: LD_INT 5
34744: PPUSH
34745: CALL_OW 12
34749: PPUSH
34750: LD_INT 103
34752: PPUSH
34753: LD_INT 140
34755: PPUSH
34756: LD_INT 20
34758: PPUSH
34759: LD_INT 1
34761: PPUSH
34762: CALL_OW 56
// end ; if time > 1 1$20 then
34766: LD_VAR 0 1
34770: PUSH
34771: LD_INT 2800
34773: GREATER
34774: IFFALSE 34784
// time := 0 0$30 ;
34776: LD_ADDR_VAR 0 1
34780: PUSH
34781: LD_INT 1050
34783: ST_TO_ADDR
// until false ;
34784: LD_INT 0
34786: IFFALSE 34461
// end ; end_of_file
34788: PPOPN 1
34790: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34791: LD_EXP 13
34795: PUSH
34796: LD_EXP 15
34800: PUSH
34801: LD_INT 6
34803: GREATEREQUAL
34804: AND
34805: IFFALSE 34842
34807: GO 34809
34809: DISABLE
// begin enable ;
34810: ENABLE
// missionTime := missionTime + 0 0$1 ;
34811: LD_ADDR_EXP 14
34815: PUSH
34816: LD_EXP 14
34820: PUSH
34821: LD_INT 35
34823: PLUS
34824: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34825: LD_ADDR_OWVAR 47
34829: PUSH
34830: LD_STRING #Am15-1
34832: PUSH
34833: LD_EXP 14
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: ST_TO_ADDR
// end ; end_of_file
34842: END
// export function InitNature ; begin
34843: LD_INT 0
34845: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34846: LD_INT 3
34848: PPUSH
34849: LD_INT 3
34851: PPUSH
34852: LD_INT 2
34854: PPUSH
34855: LD_INT 1
34857: PPUSH
34858: LD_INT 1
34860: PPUSH
34861: LD_INT 0
34863: PPUSH
34864: LD_INT 0
34866: PPUSH
34867: LD_INT 20
34869: PPUSH
34870: LD_INT 0
34872: PPUSH
34873: CALL 98917 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34877: LD_INT 2
34879: PPUSH
34880: LD_INT 1
34882: PPUSH
34883: LD_INT 1
34885: PPUSH
34886: LD_INT 1
34888: PPUSH
34889: LD_INT 1
34891: PPUSH
34892: LD_INT 0
34894: PPUSH
34895: LD_INT 0
34897: PPUSH
34898: LD_INT 21
34900: PPUSH
34901: LD_INT 0
34903: PPUSH
34904: CALL 98917 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34908: LD_INT 4
34910: PPUSH
34911: LD_INT 1
34913: PPUSH
34914: LD_INT 2
34916: PPUSH
34917: LD_INT 4
34919: PPUSH
34920: LD_INT 2
34922: PPUSH
34923: LD_INT 1
34925: PPUSH
34926: LD_INT 0
34928: PPUSH
34929: LD_INT 22
34931: PPUSH
34932: LD_INT 0
34934: PPUSH
34935: CALL 98917 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34939: LD_INT 0
34941: PPUSH
34942: LD_INT 0
34944: PPUSH
34945: LD_INT 0
34947: PPUSH
34948: LD_INT 0
34950: PPUSH
34951: LD_INT 0
34953: PPUSH
34954: LD_INT 0
34956: PPUSH
34957: LD_INT 9
34959: PPUSH
34960: LD_INT 0
34962: PPUSH
34963: LD_INT 23
34965: PPUSH
34966: CALL 98917 0 9
// end ; end_of_file
34970: LD_VAR 0 1
34974: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
34975: LD_INT 0
34977: PPUSH
// ar_miner := 81 ;
34978: LD_ADDR_EXP 102
34982: PUSH
34983: LD_INT 81
34985: ST_TO_ADDR
// ar_crane := 88 ;
34986: LD_ADDR_EXP 101
34990: PUSH
34991: LD_INT 88
34993: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34994: LD_ADDR_EXP 96
34998: PUSH
34999: LD_INT 89
35001: ST_TO_ADDR
// us_hack := 99 ;
35002: LD_ADDR_EXP 97
35006: PUSH
35007: LD_INT 99
35009: ST_TO_ADDR
// us_artillery := 97 ;
35010: LD_ADDR_EXP 98
35014: PUSH
35015: LD_INT 97
35017: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35018: LD_ADDR_EXP 99
35022: PUSH
35023: LD_INT 91
35025: ST_TO_ADDR
// ar_mortar := 92 ;
35026: LD_ADDR_EXP 100
35030: PUSH
35031: LD_INT 92
35033: ST_TO_ADDR
// ru_radar := 98 ;
35034: LD_ADDR_EXP 95
35038: PUSH
35039: LD_INT 98
35041: ST_TO_ADDR
// tech_Artillery := 80 ;
35042: LD_ADDR_EXP 103
35046: PUSH
35047: LD_INT 80
35049: ST_TO_ADDR
// tech_RadMat := 81 ;
35050: LD_ADDR_EXP 104
35054: PUSH
35055: LD_INT 81
35057: ST_TO_ADDR
// tech_BasicTools := 82 ;
35058: LD_ADDR_EXP 105
35062: PUSH
35063: LD_INT 82
35065: ST_TO_ADDR
// tech_Cargo := 83 ;
35066: LD_ADDR_EXP 106
35070: PUSH
35071: LD_INT 83
35073: ST_TO_ADDR
// tech_Track := 84 ;
35074: LD_ADDR_EXP 107
35078: PUSH
35079: LD_INT 84
35081: ST_TO_ADDR
// tech_Crane := 85 ;
35082: LD_ADDR_EXP 108
35086: PUSH
35087: LD_INT 85
35089: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35090: LD_ADDR_EXP 109
35094: PUSH
35095: LD_INT 86
35097: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35098: LD_ADDR_EXP 110
35102: PUSH
35103: LD_INT 87
35105: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35106: LD_ADDR_EXP 111
35110: PUSH
35111: LD_INT 88
35113: ST_TO_ADDR
// class_mastodont := 31 ;
35114: LD_ADDR_EXP 112
35118: PUSH
35119: LD_INT 31
35121: ST_TO_ADDR
// class_horse := 21 ;
35122: LD_ADDR_EXP 113
35126: PUSH
35127: LD_INT 21
35129: ST_TO_ADDR
// end ;
35130: LD_VAR 0 1
35134: RET
// every 1 do
35135: GO 35137
35137: DISABLE
// InitGlobalVariables ; end_of_file
35138: CALL 34975 0 0
35142: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35143: LD_INT 0
35145: PPUSH
35146: PPUSH
// skirmish := false ;
35147: LD_ADDR_EXP 114
35151: PUSH
35152: LD_INT 0
35154: ST_TO_ADDR
// debug_mc := false ;
35155: LD_ADDR_EXP 115
35159: PUSH
35160: LD_INT 0
35162: ST_TO_ADDR
// mc_bases := [ ] ;
35163: LD_ADDR_EXP 116
35167: PUSH
35168: EMPTY
35169: ST_TO_ADDR
// mc_sides := [ ] ;
35170: LD_ADDR_EXP 142
35174: PUSH
35175: EMPTY
35176: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35177: LD_ADDR_EXP 117
35181: PUSH
35182: EMPTY
35183: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35184: LD_ADDR_EXP 118
35188: PUSH
35189: EMPTY
35190: ST_TO_ADDR
// mc_need_heal := [ ] ;
35191: LD_ADDR_EXP 119
35195: PUSH
35196: EMPTY
35197: ST_TO_ADDR
// mc_healers := [ ] ;
35198: LD_ADDR_EXP 120
35202: PUSH
35203: EMPTY
35204: ST_TO_ADDR
// mc_build_list := [ ] ;
35205: LD_ADDR_EXP 121
35209: PUSH
35210: EMPTY
35211: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35212: LD_ADDR_EXP 148
35216: PUSH
35217: EMPTY
35218: ST_TO_ADDR
// mc_builders := [ ] ;
35219: LD_ADDR_EXP 122
35223: PUSH
35224: EMPTY
35225: ST_TO_ADDR
// mc_construct_list := [ ] ;
35226: LD_ADDR_EXP 123
35230: PUSH
35231: EMPTY
35232: ST_TO_ADDR
// mc_turret_list := [ ] ;
35233: LD_ADDR_EXP 124
35237: PUSH
35238: EMPTY
35239: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35240: LD_ADDR_EXP 125
35244: PUSH
35245: EMPTY
35246: ST_TO_ADDR
// mc_miners := [ ] ;
35247: LD_ADDR_EXP 130
35251: PUSH
35252: EMPTY
35253: ST_TO_ADDR
// mc_mines := [ ] ;
35254: LD_ADDR_EXP 129
35258: PUSH
35259: EMPTY
35260: ST_TO_ADDR
// mc_minefields := [ ] ;
35261: LD_ADDR_EXP 131
35265: PUSH
35266: EMPTY
35267: ST_TO_ADDR
// mc_crates := [ ] ;
35268: LD_ADDR_EXP 132
35272: PUSH
35273: EMPTY
35274: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35275: LD_ADDR_EXP 133
35279: PUSH
35280: EMPTY
35281: ST_TO_ADDR
// mc_crates_area := [ ] ;
35282: LD_ADDR_EXP 134
35286: PUSH
35287: EMPTY
35288: ST_TO_ADDR
// mc_vehicles := [ ] ;
35289: LD_ADDR_EXP 135
35293: PUSH
35294: EMPTY
35295: ST_TO_ADDR
// mc_attack := [ ] ;
35296: LD_ADDR_EXP 136
35300: PUSH
35301: EMPTY
35302: ST_TO_ADDR
// mc_produce := [ ] ;
35303: LD_ADDR_EXP 137
35307: PUSH
35308: EMPTY
35309: ST_TO_ADDR
// mc_defender := [ ] ;
35310: LD_ADDR_EXP 138
35314: PUSH
35315: EMPTY
35316: ST_TO_ADDR
// mc_parking := [ ] ;
35317: LD_ADDR_EXP 140
35321: PUSH
35322: EMPTY
35323: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35324: LD_ADDR_EXP 126
35328: PUSH
35329: EMPTY
35330: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35331: LD_ADDR_EXP 128
35335: PUSH
35336: EMPTY
35337: ST_TO_ADDR
// mc_scan := [ ] ;
35338: LD_ADDR_EXP 139
35342: PUSH
35343: EMPTY
35344: ST_TO_ADDR
// mc_scan_area := [ ] ;
35345: LD_ADDR_EXP 141
35349: PUSH
35350: EMPTY
35351: ST_TO_ADDR
// mc_tech := [ ] ;
35352: LD_ADDR_EXP 143
35356: PUSH
35357: EMPTY
35358: ST_TO_ADDR
// mc_class := [ ] ;
35359: LD_ADDR_EXP 157
35363: PUSH
35364: EMPTY
35365: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35366: LD_ADDR_EXP 158
35370: PUSH
35371: EMPTY
35372: ST_TO_ADDR
// mc_is_defending := [ ] ;
35373: LD_ADDR_EXP 159
35377: PUSH
35378: EMPTY
35379: ST_TO_ADDR
// end ;
35380: LD_VAR 0 1
35384: RET
// export function MC_Kill ( base ) ; begin
35385: LD_INT 0
35387: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35388: LD_ADDR_EXP 116
35392: PUSH
35393: LD_EXP 116
35397: PPUSH
35398: LD_VAR 0 1
35402: PPUSH
35403: EMPTY
35404: PPUSH
35405: CALL_OW 1
35409: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35410: LD_ADDR_EXP 117
35414: PUSH
35415: LD_EXP 117
35419: PPUSH
35420: LD_VAR 0 1
35424: PPUSH
35425: EMPTY
35426: PPUSH
35427: CALL_OW 1
35431: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35432: LD_ADDR_EXP 118
35436: PUSH
35437: LD_EXP 118
35441: PPUSH
35442: LD_VAR 0 1
35446: PPUSH
35447: EMPTY
35448: PPUSH
35449: CALL_OW 1
35453: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35454: LD_ADDR_EXP 119
35458: PUSH
35459: LD_EXP 119
35463: PPUSH
35464: LD_VAR 0 1
35468: PPUSH
35469: EMPTY
35470: PPUSH
35471: CALL_OW 1
35475: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35476: LD_ADDR_EXP 120
35480: PUSH
35481: LD_EXP 120
35485: PPUSH
35486: LD_VAR 0 1
35490: PPUSH
35491: EMPTY
35492: PPUSH
35493: CALL_OW 1
35497: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35498: LD_ADDR_EXP 121
35502: PUSH
35503: LD_EXP 121
35507: PPUSH
35508: LD_VAR 0 1
35512: PPUSH
35513: EMPTY
35514: PPUSH
35515: CALL_OW 1
35519: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35520: LD_ADDR_EXP 122
35524: PUSH
35525: LD_EXP 122
35529: PPUSH
35530: LD_VAR 0 1
35534: PPUSH
35535: EMPTY
35536: PPUSH
35537: CALL_OW 1
35541: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35542: LD_ADDR_EXP 123
35546: PUSH
35547: LD_EXP 123
35551: PPUSH
35552: LD_VAR 0 1
35556: PPUSH
35557: EMPTY
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35564: LD_ADDR_EXP 124
35568: PUSH
35569: LD_EXP 124
35573: PPUSH
35574: LD_VAR 0 1
35578: PPUSH
35579: EMPTY
35580: PPUSH
35581: CALL_OW 1
35585: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35586: LD_ADDR_EXP 125
35590: PUSH
35591: LD_EXP 125
35595: PPUSH
35596: LD_VAR 0 1
35600: PPUSH
35601: EMPTY
35602: PPUSH
35603: CALL_OW 1
35607: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35608: LD_ADDR_EXP 126
35612: PUSH
35613: LD_EXP 126
35617: PPUSH
35618: LD_VAR 0 1
35622: PPUSH
35623: EMPTY
35624: PPUSH
35625: CALL_OW 1
35629: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35630: LD_ADDR_EXP 127
35634: PUSH
35635: LD_EXP 127
35639: PPUSH
35640: LD_VAR 0 1
35644: PPUSH
35645: LD_INT 0
35647: PPUSH
35648: CALL_OW 1
35652: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35653: LD_ADDR_EXP 128
35657: PUSH
35658: LD_EXP 128
35662: PPUSH
35663: LD_VAR 0 1
35667: PPUSH
35668: EMPTY
35669: PPUSH
35670: CALL_OW 1
35674: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35675: LD_ADDR_EXP 129
35679: PUSH
35680: LD_EXP 129
35684: PPUSH
35685: LD_VAR 0 1
35689: PPUSH
35690: EMPTY
35691: PPUSH
35692: CALL_OW 1
35696: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35697: LD_ADDR_EXP 130
35701: PUSH
35702: LD_EXP 130
35706: PPUSH
35707: LD_VAR 0 1
35711: PPUSH
35712: EMPTY
35713: PPUSH
35714: CALL_OW 1
35718: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35719: LD_ADDR_EXP 131
35723: PUSH
35724: LD_EXP 131
35728: PPUSH
35729: LD_VAR 0 1
35733: PPUSH
35734: EMPTY
35735: PPUSH
35736: CALL_OW 1
35740: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35741: LD_ADDR_EXP 132
35745: PUSH
35746: LD_EXP 132
35750: PPUSH
35751: LD_VAR 0 1
35755: PPUSH
35756: EMPTY
35757: PPUSH
35758: CALL_OW 1
35762: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35763: LD_ADDR_EXP 133
35767: PUSH
35768: LD_EXP 133
35772: PPUSH
35773: LD_VAR 0 1
35777: PPUSH
35778: EMPTY
35779: PPUSH
35780: CALL_OW 1
35784: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35785: LD_ADDR_EXP 134
35789: PUSH
35790: LD_EXP 134
35794: PPUSH
35795: LD_VAR 0 1
35799: PPUSH
35800: EMPTY
35801: PPUSH
35802: CALL_OW 1
35806: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35807: LD_ADDR_EXP 135
35811: PUSH
35812: LD_EXP 135
35816: PPUSH
35817: LD_VAR 0 1
35821: PPUSH
35822: EMPTY
35823: PPUSH
35824: CALL_OW 1
35828: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35829: LD_ADDR_EXP 136
35833: PUSH
35834: LD_EXP 136
35838: PPUSH
35839: LD_VAR 0 1
35843: PPUSH
35844: EMPTY
35845: PPUSH
35846: CALL_OW 1
35850: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35851: LD_ADDR_EXP 137
35855: PUSH
35856: LD_EXP 137
35860: PPUSH
35861: LD_VAR 0 1
35865: PPUSH
35866: EMPTY
35867: PPUSH
35868: CALL_OW 1
35872: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35873: LD_ADDR_EXP 138
35877: PUSH
35878: LD_EXP 138
35882: PPUSH
35883: LD_VAR 0 1
35887: PPUSH
35888: EMPTY
35889: PPUSH
35890: CALL_OW 1
35894: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35895: LD_ADDR_EXP 139
35899: PUSH
35900: LD_EXP 139
35904: PPUSH
35905: LD_VAR 0 1
35909: PPUSH
35910: EMPTY
35911: PPUSH
35912: CALL_OW 1
35916: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35917: LD_ADDR_EXP 140
35921: PUSH
35922: LD_EXP 140
35926: PPUSH
35927: LD_VAR 0 1
35931: PPUSH
35932: EMPTY
35933: PPUSH
35934: CALL_OW 1
35938: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35939: LD_ADDR_EXP 141
35943: PUSH
35944: LD_EXP 141
35948: PPUSH
35949: LD_VAR 0 1
35953: PPUSH
35954: EMPTY
35955: PPUSH
35956: CALL_OW 1
35960: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35961: LD_ADDR_EXP 143
35965: PUSH
35966: LD_EXP 143
35970: PPUSH
35971: LD_VAR 0 1
35975: PPUSH
35976: EMPTY
35977: PPUSH
35978: CALL_OW 1
35982: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35983: LD_ADDR_EXP 145
35987: PUSH
35988: LD_EXP 145
35992: PPUSH
35993: LD_VAR 0 1
35997: PPUSH
35998: EMPTY
35999: PPUSH
36000: CALL_OW 1
36004: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36005: LD_ADDR_EXP 146
36009: PUSH
36010: LD_EXP 146
36014: PPUSH
36015: LD_VAR 0 1
36019: PPUSH
36020: EMPTY
36021: PPUSH
36022: CALL_OW 1
36026: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36027: LD_ADDR_EXP 147
36031: PUSH
36032: LD_EXP 147
36036: PPUSH
36037: LD_VAR 0 1
36041: PPUSH
36042: EMPTY
36043: PPUSH
36044: CALL_OW 1
36048: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36049: LD_ADDR_EXP 148
36053: PUSH
36054: LD_EXP 148
36058: PPUSH
36059: LD_VAR 0 1
36063: PPUSH
36064: EMPTY
36065: PPUSH
36066: CALL_OW 1
36070: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36071: LD_ADDR_EXP 149
36075: PUSH
36076: LD_EXP 149
36080: PPUSH
36081: LD_VAR 0 1
36085: PPUSH
36086: EMPTY
36087: PPUSH
36088: CALL_OW 1
36092: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36093: LD_ADDR_EXP 150
36097: PUSH
36098: LD_EXP 150
36102: PPUSH
36103: LD_VAR 0 1
36107: PPUSH
36108: EMPTY
36109: PPUSH
36110: CALL_OW 1
36114: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36115: LD_ADDR_EXP 151
36119: PUSH
36120: LD_EXP 151
36124: PPUSH
36125: LD_VAR 0 1
36129: PPUSH
36130: EMPTY
36131: PPUSH
36132: CALL_OW 1
36136: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36137: LD_ADDR_EXP 152
36141: PUSH
36142: LD_EXP 152
36146: PPUSH
36147: LD_VAR 0 1
36151: PPUSH
36152: EMPTY
36153: PPUSH
36154: CALL_OW 1
36158: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36159: LD_ADDR_EXP 153
36163: PUSH
36164: LD_EXP 153
36168: PPUSH
36169: LD_VAR 0 1
36173: PPUSH
36174: EMPTY
36175: PPUSH
36176: CALL_OW 1
36180: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36181: LD_ADDR_EXP 154
36185: PUSH
36186: LD_EXP 154
36190: PPUSH
36191: LD_VAR 0 1
36195: PPUSH
36196: EMPTY
36197: PPUSH
36198: CALL_OW 1
36202: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36203: LD_ADDR_EXP 155
36207: PUSH
36208: LD_EXP 155
36212: PPUSH
36213: LD_VAR 0 1
36217: PPUSH
36218: EMPTY
36219: PPUSH
36220: CALL_OW 1
36224: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36225: LD_ADDR_EXP 156
36229: PUSH
36230: LD_EXP 156
36234: PPUSH
36235: LD_VAR 0 1
36239: PPUSH
36240: EMPTY
36241: PPUSH
36242: CALL_OW 1
36246: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36247: LD_ADDR_EXP 157
36251: PUSH
36252: LD_EXP 157
36256: PPUSH
36257: LD_VAR 0 1
36261: PPUSH
36262: EMPTY
36263: PPUSH
36264: CALL_OW 1
36268: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36269: LD_ADDR_EXP 158
36273: PUSH
36274: LD_EXP 158
36278: PPUSH
36279: LD_VAR 0 1
36283: PPUSH
36284: LD_INT 0
36286: PPUSH
36287: CALL_OW 1
36291: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36292: LD_ADDR_EXP 159
36296: PUSH
36297: LD_EXP 159
36301: PPUSH
36302: LD_VAR 0 1
36306: PPUSH
36307: LD_INT 0
36309: PPUSH
36310: CALL_OW 1
36314: ST_TO_ADDR
// end ;
36315: LD_VAR 0 2
36319: RET
// export function MC_Add ( side , units ) ; var base ; begin
36320: LD_INT 0
36322: PPUSH
36323: PPUSH
// base := mc_bases + 1 ;
36324: LD_ADDR_VAR 0 4
36328: PUSH
36329: LD_EXP 116
36333: PUSH
36334: LD_INT 1
36336: PLUS
36337: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36338: LD_ADDR_EXP 142
36342: PUSH
36343: LD_EXP 142
36347: PPUSH
36348: LD_VAR 0 4
36352: PPUSH
36353: LD_VAR 0 1
36357: PPUSH
36358: CALL_OW 1
36362: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36363: LD_ADDR_EXP 116
36367: PUSH
36368: LD_EXP 116
36372: PPUSH
36373: LD_VAR 0 4
36377: PPUSH
36378: LD_VAR 0 2
36382: PPUSH
36383: CALL_OW 1
36387: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36388: LD_ADDR_EXP 117
36392: PUSH
36393: LD_EXP 117
36397: PPUSH
36398: LD_VAR 0 4
36402: PPUSH
36403: EMPTY
36404: PPUSH
36405: CALL_OW 1
36409: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36410: LD_ADDR_EXP 118
36414: PUSH
36415: LD_EXP 118
36419: PPUSH
36420: LD_VAR 0 4
36424: PPUSH
36425: EMPTY
36426: PPUSH
36427: CALL_OW 1
36431: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36432: LD_ADDR_EXP 119
36436: PUSH
36437: LD_EXP 119
36441: PPUSH
36442: LD_VAR 0 4
36446: PPUSH
36447: EMPTY
36448: PPUSH
36449: CALL_OW 1
36453: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36454: LD_ADDR_EXP 120
36458: PUSH
36459: LD_EXP 120
36463: PPUSH
36464: LD_VAR 0 4
36468: PPUSH
36469: EMPTY
36470: PPUSH
36471: CALL_OW 1
36475: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36476: LD_ADDR_EXP 121
36480: PUSH
36481: LD_EXP 121
36485: PPUSH
36486: LD_VAR 0 4
36490: PPUSH
36491: EMPTY
36492: PPUSH
36493: CALL_OW 1
36497: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36498: LD_ADDR_EXP 122
36502: PUSH
36503: LD_EXP 122
36507: PPUSH
36508: LD_VAR 0 4
36512: PPUSH
36513: EMPTY
36514: PPUSH
36515: CALL_OW 1
36519: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36520: LD_ADDR_EXP 123
36524: PUSH
36525: LD_EXP 123
36529: PPUSH
36530: LD_VAR 0 4
36534: PPUSH
36535: EMPTY
36536: PPUSH
36537: CALL_OW 1
36541: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36542: LD_ADDR_EXP 124
36546: PUSH
36547: LD_EXP 124
36551: PPUSH
36552: LD_VAR 0 4
36556: PPUSH
36557: EMPTY
36558: PPUSH
36559: CALL_OW 1
36563: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36564: LD_ADDR_EXP 125
36568: PUSH
36569: LD_EXP 125
36573: PPUSH
36574: LD_VAR 0 4
36578: PPUSH
36579: EMPTY
36580: PPUSH
36581: CALL_OW 1
36585: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36586: LD_ADDR_EXP 126
36590: PUSH
36591: LD_EXP 126
36595: PPUSH
36596: LD_VAR 0 4
36600: PPUSH
36601: EMPTY
36602: PPUSH
36603: CALL_OW 1
36607: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36608: LD_ADDR_EXP 127
36612: PUSH
36613: LD_EXP 127
36617: PPUSH
36618: LD_VAR 0 4
36622: PPUSH
36623: LD_INT 0
36625: PPUSH
36626: CALL_OW 1
36630: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36631: LD_ADDR_EXP 128
36635: PUSH
36636: LD_EXP 128
36640: PPUSH
36641: LD_VAR 0 4
36645: PPUSH
36646: EMPTY
36647: PPUSH
36648: CALL_OW 1
36652: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36653: LD_ADDR_EXP 129
36657: PUSH
36658: LD_EXP 129
36662: PPUSH
36663: LD_VAR 0 4
36667: PPUSH
36668: EMPTY
36669: PPUSH
36670: CALL_OW 1
36674: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36675: LD_ADDR_EXP 130
36679: PUSH
36680: LD_EXP 130
36684: PPUSH
36685: LD_VAR 0 4
36689: PPUSH
36690: EMPTY
36691: PPUSH
36692: CALL_OW 1
36696: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36697: LD_ADDR_EXP 131
36701: PUSH
36702: LD_EXP 131
36706: PPUSH
36707: LD_VAR 0 4
36711: PPUSH
36712: EMPTY
36713: PPUSH
36714: CALL_OW 1
36718: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36719: LD_ADDR_EXP 132
36723: PUSH
36724: LD_EXP 132
36728: PPUSH
36729: LD_VAR 0 4
36733: PPUSH
36734: EMPTY
36735: PPUSH
36736: CALL_OW 1
36740: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36741: LD_ADDR_EXP 133
36745: PUSH
36746: LD_EXP 133
36750: PPUSH
36751: LD_VAR 0 4
36755: PPUSH
36756: EMPTY
36757: PPUSH
36758: CALL_OW 1
36762: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36763: LD_ADDR_EXP 134
36767: PUSH
36768: LD_EXP 134
36772: PPUSH
36773: LD_VAR 0 4
36777: PPUSH
36778: EMPTY
36779: PPUSH
36780: CALL_OW 1
36784: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36785: LD_ADDR_EXP 135
36789: PUSH
36790: LD_EXP 135
36794: PPUSH
36795: LD_VAR 0 4
36799: PPUSH
36800: EMPTY
36801: PPUSH
36802: CALL_OW 1
36806: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36807: LD_ADDR_EXP 136
36811: PUSH
36812: LD_EXP 136
36816: PPUSH
36817: LD_VAR 0 4
36821: PPUSH
36822: EMPTY
36823: PPUSH
36824: CALL_OW 1
36828: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36829: LD_ADDR_EXP 137
36833: PUSH
36834: LD_EXP 137
36838: PPUSH
36839: LD_VAR 0 4
36843: PPUSH
36844: EMPTY
36845: PPUSH
36846: CALL_OW 1
36850: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36851: LD_ADDR_EXP 138
36855: PUSH
36856: LD_EXP 138
36860: PPUSH
36861: LD_VAR 0 4
36865: PPUSH
36866: EMPTY
36867: PPUSH
36868: CALL_OW 1
36872: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36873: LD_ADDR_EXP 139
36877: PUSH
36878: LD_EXP 139
36882: PPUSH
36883: LD_VAR 0 4
36887: PPUSH
36888: EMPTY
36889: PPUSH
36890: CALL_OW 1
36894: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36895: LD_ADDR_EXP 140
36899: PUSH
36900: LD_EXP 140
36904: PPUSH
36905: LD_VAR 0 4
36909: PPUSH
36910: EMPTY
36911: PPUSH
36912: CALL_OW 1
36916: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36917: LD_ADDR_EXP 141
36921: PUSH
36922: LD_EXP 141
36926: PPUSH
36927: LD_VAR 0 4
36931: PPUSH
36932: EMPTY
36933: PPUSH
36934: CALL_OW 1
36938: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36939: LD_ADDR_EXP 143
36943: PUSH
36944: LD_EXP 143
36948: PPUSH
36949: LD_VAR 0 4
36953: PPUSH
36954: EMPTY
36955: PPUSH
36956: CALL_OW 1
36960: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36961: LD_ADDR_EXP 145
36965: PUSH
36966: LD_EXP 145
36970: PPUSH
36971: LD_VAR 0 4
36975: PPUSH
36976: EMPTY
36977: PPUSH
36978: CALL_OW 1
36982: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36983: LD_ADDR_EXP 146
36987: PUSH
36988: LD_EXP 146
36992: PPUSH
36993: LD_VAR 0 4
36997: PPUSH
36998: EMPTY
36999: PPUSH
37000: CALL_OW 1
37004: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37005: LD_ADDR_EXP 147
37009: PUSH
37010: LD_EXP 147
37014: PPUSH
37015: LD_VAR 0 4
37019: PPUSH
37020: EMPTY
37021: PPUSH
37022: CALL_OW 1
37026: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37027: LD_ADDR_EXP 148
37031: PUSH
37032: LD_EXP 148
37036: PPUSH
37037: LD_VAR 0 4
37041: PPUSH
37042: EMPTY
37043: PPUSH
37044: CALL_OW 1
37048: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37049: LD_ADDR_EXP 149
37053: PUSH
37054: LD_EXP 149
37058: PPUSH
37059: LD_VAR 0 4
37063: PPUSH
37064: EMPTY
37065: PPUSH
37066: CALL_OW 1
37070: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37071: LD_ADDR_EXP 150
37075: PUSH
37076: LD_EXP 150
37080: PPUSH
37081: LD_VAR 0 4
37085: PPUSH
37086: EMPTY
37087: PPUSH
37088: CALL_OW 1
37092: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37093: LD_ADDR_EXP 151
37097: PUSH
37098: LD_EXP 151
37102: PPUSH
37103: LD_VAR 0 4
37107: PPUSH
37108: EMPTY
37109: PPUSH
37110: CALL_OW 1
37114: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37115: LD_ADDR_EXP 152
37119: PUSH
37120: LD_EXP 152
37124: PPUSH
37125: LD_VAR 0 4
37129: PPUSH
37130: EMPTY
37131: PPUSH
37132: CALL_OW 1
37136: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37137: LD_ADDR_EXP 153
37141: PUSH
37142: LD_EXP 153
37146: PPUSH
37147: LD_VAR 0 4
37151: PPUSH
37152: EMPTY
37153: PPUSH
37154: CALL_OW 1
37158: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37159: LD_ADDR_EXP 154
37163: PUSH
37164: LD_EXP 154
37168: PPUSH
37169: LD_VAR 0 4
37173: PPUSH
37174: EMPTY
37175: PPUSH
37176: CALL_OW 1
37180: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37181: LD_ADDR_EXP 155
37185: PUSH
37186: LD_EXP 155
37190: PPUSH
37191: LD_VAR 0 4
37195: PPUSH
37196: EMPTY
37197: PPUSH
37198: CALL_OW 1
37202: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37203: LD_ADDR_EXP 156
37207: PUSH
37208: LD_EXP 156
37212: PPUSH
37213: LD_VAR 0 4
37217: PPUSH
37218: EMPTY
37219: PPUSH
37220: CALL_OW 1
37224: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37225: LD_ADDR_EXP 157
37229: PUSH
37230: LD_EXP 157
37234: PPUSH
37235: LD_VAR 0 4
37239: PPUSH
37240: EMPTY
37241: PPUSH
37242: CALL_OW 1
37246: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37247: LD_ADDR_EXP 158
37251: PUSH
37252: LD_EXP 158
37256: PPUSH
37257: LD_VAR 0 4
37261: PPUSH
37262: LD_INT 0
37264: PPUSH
37265: CALL_OW 1
37269: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37270: LD_ADDR_EXP 159
37274: PUSH
37275: LD_EXP 159
37279: PPUSH
37280: LD_VAR 0 4
37284: PPUSH
37285: LD_INT 0
37287: PPUSH
37288: CALL_OW 1
37292: ST_TO_ADDR
// result := base ;
37293: LD_ADDR_VAR 0 3
37297: PUSH
37298: LD_VAR 0 4
37302: ST_TO_ADDR
// end ;
37303: LD_VAR 0 3
37307: RET
// export function MC_Start ( ) ; var i ; begin
37308: LD_INT 0
37310: PPUSH
37311: PPUSH
// for i = 1 to mc_bases do
37312: LD_ADDR_VAR 0 2
37316: PUSH
37317: DOUBLE
37318: LD_INT 1
37320: DEC
37321: ST_TO_ADDR
37322: LD_EXP 116
37326: PUSH
37327: FOR_TO
37328: IFFALSE 38428
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37330: LD_ADDR_EXP 116
37334: PUSH
37335: LD_EXP 116
37339: PPUSH
37340: LD_VAR 0 2
37344: PPUSH
37345: LD_EXP 116
37349: PUSH
37350: LD_VAR 0 2
37354: ARRAY
37355: PUSH
37356: LD_INT 0
37358: DIFF
37359: PPUSH
37360: CALL_OW 1
37364: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37365: LD_ADDR_EXP 117
37369: PUSH
37370: LD_EXP 117
37374: PPUSH
37375: LD_VAR 0 2
37379: PPUSH
37380: EMPTY
37381: PPUSH
37382: CALL_OW 1
37386: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37387: LD_ADDR_EXP 118
37391: PUSH
37392: LD_EXP 118
37396: PPUSH
37397: LD_VAR 0 2
37401: PPUSH
37402: EMPTY
37403: PPUSH
37404: CALL_OW 1
37408: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37409: LD_ADDR_EXP 119
37413: PUSH
37414: LD_EXP 119
37418: PPUSH
37419: LD_VAR 0 2
37423: PPUSH
37424: EMPTY
37425: PPUSH
37426: CALL_OW 1
37430: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37431: LD_ADDR_EXP 120
37435: PUSH
37436: LD_EXP 120
37440: PPUSH
37441: LD_VAR 0 2
37445: PPUSH
37446: EMPTY
37447: PUSH
37448: EMPTY
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PPUSH
37454: CALL_OW 1
37458: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37459: LD_ADDR_EXP 121
37463: PUSH
37464: LD_EXP 121
37468: PPUSH
37469: LD_VAR 0 2
37473: PPUSH
37474: EMPTY
37475: PPUSH
37476: CALL_OW 1
37480: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37481: LD_ADDR_EXP 148
37485: PUSH
37486: LD_EXP 148
37490: PPUSH
37491: LD_VAR 0 2
37495: PPUSH
37496: EMPTY
37497: PPUSH
37498: CALL_OW 1
37502: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37503: LD_ADDR_EXP 122
37507: PUSH
37508: LD_EXP 122
37512: PPUSH
37513: LD_VAR 0 2
37517: PPUSH
37518: EMPTY
37519: PPUSH
37520: CALL_OW 1
37524: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37525: LD_ADDR_EXP 123
37529: PUSH
37530: LD_EXP 123
37534: PPUSH
37535: LD_VAR 0 2
37539: PPUSH
37540: EMPTY
37541: PPUSH
37542: CALL_OW 1
37546: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37547: LD_ADDR_EXP 124
37551: PUSH
37552: LD_EXP 124
37556: PPUSH
37557: LD_VAR 0 2
37561: PPUSH
37562: LD_EXP 116
37566: PUSH
37567: LD_VAR 0 2
37571: ARRAY
37572: PPUSH
37573: LD_INT 2
37575: PUSH
37576: LD_INT 30
37578: PUSH
37579: LD_INT 32
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 30
37588: PUSH
37589: LD_INT 33
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: LIST
37600: PPUSH
37601: CALL_OW 72
37605: PPUSH
37606: CALL_OW 1
37610: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37611: LD_ADDR_EXP 125
37615: PUSH
37616: LD_EXP 125
37620: PPUSH
37621: LD_VAR 0 2
37625: PPUSH
37626: LD_EXP 116
37630: PUSH
37631: LD_VAR 0 2
37635: ARRAY
37636: PPUSH
37637: LD_INT 2
37639: PUSH
37640: LD_INT 30
37642: PUSH
37643: LD_INT 32
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 30
37652: PUSH
37653: LD_INT 31
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 58
37667: PUSH
37668: EMPTY
37669: LIST
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PPUSH
37675: CALL_OW 72
37679: PPUSH
37680: CALL_OW 1
37684: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37685: LD_ADDR_EXP 126
37689: PUSH
37690: LD_EXP 126
37694: PPUSH
37695: LD_VAR 0 2
37699: PPUSH
37700: EMPTY
37701: PPUSH
37702: CALL_OW 1
37706: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37707: LD_ADDR_EXP 130
37711: PUSH
37712: LD_EXP 130
37716: PPUSH
37717: LD_VAR 0 2
37721: PPUSH
37722: EMPTY
37723: PPUSH
37724: CALL_OW 1
37728: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37729: LD_ADDR_EXP 129
37733: PUSH
37734: LD_EXP 129
37738: PPUSH
37739: LD_VAR 0 2
37743: PPUSH
37744: EMPTY
37745: PPUSH
37746: CALL_OW 1
37750: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37751: LD_ADDR_EXP 131
37755: PUSH
37756: LD_EXP 131
37760: PPUSH
37761: LD_VAR 0 2
37765: PPUSH
37766: EMPTY
37767: PPUSH
37768: CALL_OW 1
37772: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37773: LD_ADDR_EXP 132
37777: PUSH
37778: LD_EXP 132
37782: PPUSH
37783: LD_VAR 0 2
37787: PPUSH
37788: EMPTY
37789: PPUSH
37790: CALL_OW 1
37794: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37795: LD_ADDR_EXP 133
37799: PUSH
37800: LD_EXP 133
37804: PPUSH
37805: LD_VAR 0 2
37809: PPUSH
37810: EMPTY
37811: PPUSH
37812: CALL_OW 1
37816: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37817: LD_ADDR_EXP 134
37821: PUSH
37822: LD_EXP 134
37826: PPUSH
37827: LD_VAR 0 2
37831: PPUSH
37832: EMPTY
37833: PPUSH
37834: CALL_OW 1
37838: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37839: LD_ADDR_EXP 135
37843: PUSH
37844: LD_EXP 135
37848: PPUSH
37849: LD_VAR 0 2
37853: PPUSH
37854: EMPTY
37855: PPUSH
37856: CALL_OW 1
37860: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37861: LD_ADDR_EXP 136
37865: PUSH
37866: LD_EXP 136
37870: PPUSH
37871: LD_VAR 0 2
37875: PPUSH
37876: EMPTY
37877: PPUSH
37878: CALL_OW 1
37882: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37883: LD_ADDR_EXP 137
37887: PUSH
37888: LD_EXP 137
37892: PPUSH
37893: LD_VAR 0 2
37897: PPUSH
37898: EMPTY
37899: PPUSH
37900: CALL_OW 1
37904: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37905: LD_ADDR_EXP 138
37909: PUSH
37910: LD_EXP 138
37914: PPUSH
37915: LD_VAR 0 2
37919: PPUSH
37920: EMPTY
37921: PPUSH
37922: CALL_OW 1
37926: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37927: LD_ADDR_EXP 127
37931: PUSH
37932: LD_EXP 127
37936: PPUSH
37937: LD_VAR 0 2
37941: PPUSH
37942: LD_INT 0
37944: PPUSH
37945: CALL_OW 1
37949: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37950: LD_ADDR_EXP 140
37954: PUSH
37955: LD_EXP 140
37959: PPUSH
37960: LD_VAR 0 2
37964: PPUSH
37965: LD_INT 0
37967: PPUSH
37968: CALL_OW 1
37972: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37973: LD_ADDR_EXP 128
37977: PUSH
37978: LD_EXP 128
37982: PPUSH
37983: LD_VAR 0 2
37987: PPUSH
37988: EMPTY
37989: PPUSH
37990: CALL_OW 1
37994: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37995: LD_ADDR_EXP 139
37999: PUSH
38000: LD_EXP 139
38004: PPUSH
38005: LD_VAR 0 2
38009: PPUSH
38010: LD_INT 0
38012: PPUSH
38013: CALL_OW 1
38017: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38018: LD_ADDR_EXP 141
38022: PUSH
38023: LD_EXP 141
38027: PPUSH
38028: LD_VAR 0 2
38032: PPUSH
38033: EMPTY
38034: PPUSH
38035: CALL_OW 1
38039: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38040: LD_ADDR_EXP 144
38044: PUSH
38045: LD_EXP 144
38049: PPUSH
38050: LD_VAR 0 2
38054: PPUSH
38055: LD_INT 0
38057: PPUSH
38058: CALL_OW 1
38062: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38063: LD_ADDR_EXP 145
38067: PUSH
38068: LD_EXP 145
38072: PPUSH
38073: LD_VAR 0 2
38077: PPUSH
38078: EMPTY
38079: PPUSH
38080: CALL_OW 1
38084: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38085: LD_ADDR_EXP 146
38089: PUSH
38090: LD_EXP 146
38094: PPUSH
38095: LD_VAR 0 2
38099: PPUSH
38100: EMPTY
38101: PPUSH
38102: CALL_OW 1
38106: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38107: LD_ADDR_EXP 147
38111: PUSH
38112: LD_EXP 147
38116: PPUSH
38117: LD_VAR 0 2
38121: PPUSH
38122: EMPTY
38123: PPUSH
38124: CALL_OW 1
38128: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38129: LD_ADDR_EXP 149
38133: PUSH
38134: LD_EXP 149
38138: PPUSH
38139: LD_VAR 0 2
38143: PPUSH
38144: LD_EXP 116
38148: PUSH
38149: LD_VAR 0 2
38153: ARRAY
38154: PPUSH
38155: LD_INT 2
38157: PUSH
38158: LD_INT 30
38160: PUSH
38161: LD_INT 6
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 30
38170: PUSH
38171: LD_INT 7
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 30
38180: PUSH
38181: LD_INT 8
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: PPUSH
38194: CALL_OW 72
38198: PPUSH
38199: CALL_OW 1
38203: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38204: LD_ADDR_EXP 150
38208: PUSH
38209: LD_EXP 150
38213: PPUSH
38214: LD_VAR 0 2
38218: PPUSH
38219: EMPTY
38220: PPUSH
38221: CALL_OW 1
38225: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38226: LD_ADDR_EXP 151
38230: PUSH
38231: LD_EXP 151
38235: PPUSH
38236: LD_VAR 0 2
38240: PPUSH
38241: EMPTY
38242: PPUSH
38243: CALL_OW 1
38247: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38248: LD_ADDR_EXP 152
38252: PUSH
38253: LD_EXP 152
38257: PPUSH
38258: LD_VAR 0 2
38262: PPUSH
38263: EMPTY
38264: PPUSH
38265: CALL_OW 1
38269: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38270: LD_ADDR_EXP 153
38274: PUSH
38275: LD_EXP 153
38279: PPUSH
38280: LD_VAR 0 2
38284: PPUSH
38285: EMPTY
38286: PPUSH
38287: CALL_OW 1
38291: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38292: LD_ADDR_EXP 154
38296: PUSH
38297: LD_EXP 154
38301: PPUSH
38302: LD_VAR 0 2
38306: PPUSH
38307: EMPTY
38308: PPUSH
38309: CALL_OW 1
38313: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38314: LD_ADDR_EXP 155
38318: PUSH
38319: LD_EXP 155
38323: PPUSH
38324: LD_VAR 0 2
38328: PPUSH
38329: EMPTY
38330: PPUSH
38331: CALL_OW 1
38335: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38336: LD_ADDR_EXP 156
38340: PUSH
38341: LD_EXP 156
38345: PPUSH
38346: LD_VAR 0 2
38350: PPUSH
38351: EMPTY
38352: PPUSH
38353: CALL_OW 1
38357: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38358: LD_ADDR_EXP 157
38362: PUSH
38363: LD_EXP 157
38367: PPUSH
38368: LD_VAR 0 2
38372: PPUSH
38373: EMPTY
38374: PPUSH
38375: CALL_OW 1
38379: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38380: LD_ADDR_EXP 158
38384: PUSH
38385: LD_EXP 158
38389: PPUSH
38390: LD_VAR 0 2
38394: PPUSH
38395: LD_INT 0
38397: PPUSH
38398: CALL_OW 1
38402: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38403: LD_ADDR_EXP 159
38407: PUSH
38408: LD_EXP 159
38412: PPUSH
38413: LD_VAR 0 2
38417: PPUSH
38418: LD_INT 0
38420: PPUSH
38421: CALL_OW 1
38425: ST_TO_ADDR
// end ;
38426: GO 37327
38428: POP
38429: POP
// MC_InitSides ( ) ;
38430: CALL 38716 0 0
// MC_InitResearch ( ) ;
38434: CALL 38455 0 0
// CustomInitMacro ( ) ;
38438: CALL 471 0 0
// skirmish := true ;
38442: LD_ADDR_EXP 114
38446: PUSH
38447: LD_INT 1
38449: ST_TO_ADDR
// end ;
38450: LD_VAR 0 1
38454: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38455: LD_INT 0
38457: PPUSH
38458: PPUSH
38459: PPUSH
38460: PPUSH
38461: PPUSH
38462: PPUSH
// if not mc_bases then
38463: LD_EXP 116
38467: NOT
38468: IFFALSE 38472
// exit ;
38470: GO 38711
// for i = 1 to 8 do
38472: LD_ADDR_VAR 0 2
38476: PUSH
38477: DOUBLE
38478: LD_INT 1
38480: DEC
38481: ST_TO_ADDR
38482: LD_INT 8
38484: PUSH
38485: FOR_TO
38486: IFFALSE 38512
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38488: LD_ADDR_EXP 143
38492: PUSH
38493: LD_EXP 143
38497: PPUSH
38498: LD_VAR 0 2
38502: PPUSH
38503: EMPTY
38504: PPUSH
38505: CALL_OW 1
38509: ST_TO_ADDR
38510: GO 38485
38512: POP
38513: POP
// tmp := [ ] ;
38514: LD_ADDR_VAR 0 5
38518: PUSH
38519: EMPTY
38520: ST_TO_ADDR
// for i = 1 to mc_sides do
38521: LD_ADDR_VAR 0 2
38525: PUSH
38526: DOUBLE
38527: LD_INT 1
38529: DEC
38530: ST_TO_ADDR
38531: LD_EXP 142
38535: PUSH
38536: FOR_TO
38537: IFFALSE 38595
// if not mc_sides [ i ] in tmp then
38539: LD_EXP 142
38543: PUSH
38544: LD_VAR 0 2
38548: ARRAY
38549: PUSH
38550: LD_VAR 0 5
38554: IN
38555: NOT
38556: IFFALSE 38593
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38558: LD_ADDR_VAR 0 5
38562: PUSH
38563: LD_VAR 0 5
38567: PPUSH
38568: LD_VAR 0 5
38572: PUSH
38573: LD_INT 1
38575: PLUS
38576: PPUSH
38577: LD_EXP 142
38581: PUSH
38582: LD_VAR 0 2
38586: ARRAY
38587: PPUSH
38588: CALL_OW 2
38592: ST_TO_ADDR
38593: GO 38536
38595: POP
38596: POP
// if not tmp then
38597: LD_VAR 0 5
38601: NOT
38602: IFFALSE 38606
// exit ;
38604: GO 38711
// for j in tmp do
38606: LD_ADDR_VAR 0 3
38610: PUSH
38611: LD_VAR 0 5
38615: PUSH
38616: FOR_IN
38617: IFFALSE 38709
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38619: LD_ADDR_VAR 0 6
38623: PUSH
38624: LD_INT 22
38626: PUSH
38627: LD_VAR 0 3
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PPUSH
38636: CALL_OW 69
38640: ST_TO_ADDR
// if not un then
38641: LD_VAR 0 6
38645: NOT
38646: IFFALSE 38650
// continue ;
38648: GO 38616
// nation := GetNation ( un [ 1 ] ) ;
38650: LD_ADDR_VAR 0 4
38654: PUSH
38655: LD_VAR 0 6
38659: PUSH
38660: LD_INT 1
38662: ARRAY
38663: PPUSH
38664: CALL_OW 248
38668: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38669: LD_ADDR_EXP 143
38673: PUSH
38674: LD_EXP 143
38678: PPUSH
38679: LD_VAR 0 3
38683: PPUSH
38684: LD_VAR 0 3
38688: PPUSH
38689: LD_VAR 0 4
38693: PPUSH
38694: LD_INT 1
38696: PPUSH
38697: CALL 65616 0 3
38701: PPUSH
38702: CALL_OW 1
38706: ST_TO_ADDR
// end ;
38707: GO 38616
38709: POP
38710: POP
// end ;
38711: LD_VAR 0 1
38715: RET
// export function MC_InitSides ( ) ; var i ; begin
38716: LD_INT 0
38718: PPUSH
38719: PPUSH
// if not mc_bases then
38720: LD_EXP 116
38724: NOT
38725: IFFALSE 38729
// exit ;
38727: GO 38803
// for i = 1 to mc_bases do
38729: LD_ADDR_VAR 0 2
38733: PUSH
38734: DOUBLE
38735: LD_INT 1
38737: DEC
38738: ST_TO_ADDR
38739: LD_EXP 116
38743: PUSH
38744: FOR_TO
38745: IFFALSE 38801
// if mc_bases [ i ] then
38747: LD_EXP 116
38751: PUSH
38752: LD_VAR 0 2
38756: ARRAY
38757: IFFALSE 38799
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38759: LD_ADDR_EXP 142
38763: PUSH
38764: LD_EXP 142
38768: PPUSH
38769: LD_VAR 0 2
38773: PPUSH
38774: LD_EXP 116
38778: PUSH
38779: LD_VAR 0 2
38783: ARRAY
38784: PUSH
38785: LD_INT 1
38787: ARRAY
38788: PPUSH
38789: CALL_OW 255
38793: PPUSH
38794: CALL_OW 1
38798: ST_TO_ADDR
38799: GO 38744
38801: POP
38802: POP
// end ;
38803: LD_VAR 0 1
38807: RET
// every 0 0$03 trigger skirmish do
38808: LD_EXP 114
38812: IFFALSE 38966
38814: GO 38816
38816: DISABLE
// begin enable ;
38817: ENABLE
// MC_CheckBuildings ( ) ;
38818: CALL 43464 0 0
// MC_CheckPeopleLife ( ) ;
38822: CALL 43589 0 0
// RaiseSailEvent ( 100 ) ;
38826: LD_INT 100
38828: PPUSH
38829: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38833: LD_INT 103
38835: PPUSH
38836: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38840: LD_INT 104
38842: PPUSH
38843: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38847: LD_INT 105
38849: PPUSH
38850: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38854: LD_INT 106
38856: PPUSH
38857: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38861: LD_INT 107
38863: PPUSH
38864: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38868: LD_INT 108
38870: PPUSH
38871: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38875: LD_INT 109
38877: PPUSH
38878: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38882: LD_INT 110
38884: PPUSH
38885: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38889: LD_INT 111
38891: PPUSH
38892: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38896: LD_INT 112
38898: PPUSH
38899: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38903: LD_INT 113
38905: PPUSH
38906: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38910: LD_INT 120
38912: PPUSH
38913: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38917: LD_INT 121
38919: PPUSH
38920: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38924: LD_INT 122
38926: PPUSH
38927: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38931: LD_INT 123
38933: PPUSH
38934: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38938: LD_INT 124
38940: PPUSH
38941: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38945: LD_INT 125
38947: PPUSH
38948: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38952: LD_INT 126
38954: PPUSH
38955: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38959: LD_INT 200
38961: PPUSH
38962: CALL_OW 427
// end ;
38966: END
// on SailEvent ( event ) do begin if event < 100 then
38967: LD_VAR 0 1
38971: PUSH
38972: LD_INT 100
38974: LESS
38975: IFFALSE 38986
// CustomEvent ( event ) ;
38977: LD_VAR 0 1
38981: PPUSH
38982: CALL 33446 0 1
// if event = 100 then
38986: LD_VAR 0 1
38990: PUSH
38991: LD_INT 100
38993: EQUAL
38994: IFFALSE 39000
// MC_ClassManager ( ) ;
38996: CALL 39392 0 0
// if event = 101 then
39000: LD_VAR 0 1
39004: PUSH
39005: LD_INT 101
39007: EQUAL
39008: IFFALSE 39014
// MC_RepairBuildings ( ) ;
39010: CALL 44174 0 0
// if event = 102 then
39014: LD_VAR 0 1
39018: PUSH
39019: LD_INT 102
39021: EQUAL
39022: IFFALSE 39028
// MC_Heal ( ) ;
39024: CALL 45059 0 0
// if event = 103 then
39028: LD_VAR 0 1
39032: PUSH
39033: LD_INT 103
39035: EQUAL
39036: IFFALSE 39042
// MC_Build ( ) ;
39038: CALL 45481 0 0
// if event = 104 then
39042: LD_VAR 0 1
39046: PUSH
39047: LD_INT 104
39049: EQUAL
39050: IFFALSE 39056
// MC_TurretWeapon ( ) ;
39052: CALL 47122 0 0
// if event = 105 then
39056: LD_VAR 0 1
39060: PUSH
39061: LD_INT 105
39063: EQUAL
39064: IFFALSE 39070
// MC_BuildUpgrade ( ) ;
39066: CALL 46673 0 0
// if event = 106 then
39070: LD_VAR 0 1
39074: PUSH
39075: LD_INT 106
39077: EQUAL
39078: IFFALSE 39084
// MC_PlantMines ( ) ;
39080: CALL 47552 0 0
// if event = 107 then
39084: LD_VAR 0 1
39088: PUSH
39089: LD_INT 107
39091: EQUAL
39092: IFFALSE 39098
// MC_CollectCrates ( ) ;
39094: CALL 48343 0 0
// if event = 108 then
39098: LD_VAR 0 1
39102: PUSH
39103: LD_INT 108
39105: EQUAL
39106: IFFALSE 39112
// MC_LinkRemoteControl ( ) ;
39108: CALL 50193 0 0
// if event = 109 then
39112: LD_VAR 0 1
39116: PUSH
39117: LD_INT 109
39119: EQUAL
39120: IFFALSE 39126
// MC_ProduceVehicle ( ) ;
39122: CALL 50374 0 0
// if event = 110 then
39126: LD_VAR 0 1
39130: PUSH
39131: LD_INT 110
39133: EQUAL
39134: IFFALSE 39140
// MC_SendAttack ( ) ;
39136: CALL 50840 0 0
// if event = 111 then
39140: LD_VAR 0 1
39144: PUSH
39145: LD_INT 111
39147: EQUAL
39148: IFFALSE 39154
// MC_Defend ( ) ;
39150: CALL 50948 0 0
// if event = 112 then
39154: LD_VAR 0 1
39158: PUSH
39159: LD_INT 112
39161: EQUAL
39162: IFFALSE 39168
// MC_Research ( ) ;
39164: CALL 51670 0 0
// if event = 113 then
39168: LD_VAR 0 1
39172: PUSH
39173: LD_INT 113
39175: EQUAL
39176: IFFALSE 39182
// MC_MinesTrigger ( ) ;
39178: CALL 52784 0 0
// if event = 120 then
39182: LD_VAR 0 1
39186: PUSH
39187: LD_INT 120
39189: EQUAL
39190: IFFALSE 39196
// MC_RepairVehicle ( ) ;
39192: CALL 52883 0 0
// if event = 121 then
39196: LD_VAR 0 1
39200: PUSH
39201: LD_INT 121
39203: EQUAL
39204: IFFALSE 39210
// MC_TameApe ( ) ;
39206: CALL 53624 0 0
// if event = 122 then
39210: LD_VAR 0 1
39214: PUSH
39215: LD_INT 122
39217: EQUAL
39218: IFFALSE 39224
// MC_ChangeApeClass ( ) ;
39220: CALL 54453 0 0
// if event = 123 then
39224: LD_VAR 0 1
39228: PUSH
39229: LD_INT 123
39231: EQUAL
39232: IFFALSE 39238
// MC_Bazooka ( ) ;
39234: CALL 55103 0 0
// if event = 124 then
39238: LD_VAR 0 1
39242: PUSH
39243: LD_INT 124
39245: EQUAL
39246: IFFALSE 39252
// MC_TeleportExit ( ) ;
39248: CALL 55301 0 0
// if event = 125 then
39252: LD_VAR 0 1
39256: PUSH
39257: LD_INT 125
39259: EQUAL
39260: IFFALSE 39266
// MC_Deposits ( ) ;
39262: CALL 55948 0 0
// if event = 126 then
39266: LD_VAR 0 1
39270: PUSH
39271: LD_INT 126
39273: EQUAL
39274: IFFALSE 39280
// MC_RemoteDriver ( ) ;
39276: CALL 56573 0 0
// if event = 200 then
39280: LD_VAR 0 1
39284: PUSH
39285: LD_INT 200
39287: EQUAL
39288: IFFALSE 39294
// MC_Idle ( ) ;
39290: CALL 58522 0 0
// end ;
39294: PPOPN 1
39296: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39297: LD_INT 0
39299: PPUSH
39300: PPUSH
// if not mc_bases [ base ] or not tag then
39301: LD_EXP 116
39305: PUSH
39306: LD_VAR 0 1
39310: ARRAY
39311: NOT
39312: PUSH
39313: LD_VAR 0 2
39317: NOT
39318: OR
39319: IFFALSE 39323
// exit ;
39321: GO 39387
// for i in mc_bases [ base ] union mc_ape [ base ] do
39323: LD_ADDR_VAR 0 4
39327: PUSH
39328: LD_EXP 116
39332: PUSH
39333: LD_VAR 0 1
39337: ARRAY
39338: PUSH
39339: LD_EXP 145
39343: PUSH
39344: LD_VAR 0 1
39348: ARRAY
39349: UNION
39350: PUSH
39351: FOR_IN
39352: IFFALSE 39385
// if GetTag ( i ) = tag then
39354: LD_VAR 0 4
39358: PPUSH
39359: CALL_OW 110
39363: PUSH
39364: LD_VAR 0 2
39368: EQUAL
39369: IFFALSE 39383
// SetTag ( i , 0 ) ;
39371: LD_VAR 0 4
39375: PPUSH
39376: LD_INT 0
39378: PPUSH
39379: CALL_OW 109
39383: GO 39351
39385: POP
39386: POP
// end ;
39387: LD_VAR 0 3
39391: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39392: LD_INT 0
39394: PPUSH
39395: PPUSH
39396: PPUSH
39397: PPUSH
39398: PPUSH
39399: PPUSH
39400: PPUSH
39401: PPUSH
// if not mc_bases then
39402: LD_EXP 116
39406: NOT
39407: IFFALSE 39411
// exit ;
39409: GO 39869
// for i = 1 to mc_bases do
39411: LD_ADDR_VAR 0 2
39415: PUSH
39416: DOUBLE
39417: LD_INT 1
39419: DEC
39420: ST_TO_ADDR
39421: LD_EXP 116
39425: PUSH
39426: FOR_TO
39427: IFFALSE 39867
// begin tmp := MC_ClassCheckReq ( i ) ;
39429: LD_ADDR_VAR 0 4
39433: PUSH
39434: LD_VAR 0 2
39438: PPUSH
39439: CALL 39874 0 1
39443: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39444: LD_ADDR_EXP 157
39448: PUSH
39449: LD_EXP 157
39453: PPUSH
39454: LD_VAR 0 2
39458: PPUSH
39459: LD_VAR 0 4
39463: PPUSH
39464: CALL_OW 1
39468: ST_TO_ADDR
// if not tmp then
39469: LD_VAR 0 4
39473: NOT
39474: IFFALSE 39478
// continue ;
39476: GO 39426
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39478: LD_ADDR_VAR 0 6
39482: PUSH
39483: LD_EXP 116
39487: PUSH
39488: LD_VAR 0 2
39492: ARRAY
39493: PPUSH
39494: LD_INT 2
39496: PUSH
39497: LD_INT 30
39499: PUSH
39500: LD_INT 4
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 30
39509: PUSH
39510: LD_INT 5
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: LIST
39521: PPUSH
39522: CALL_OW 72
39526: PUSH
39527: LD_EXP 116
39531: PUSH
39532: LD_VAR 0 2
39536: ARRAY
39537: PPUSH
39538: LD_INT 2
39540: PUSH
39541: LD_INT 30
39543: PUSH
39544: LD_INT 0
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 30
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: LIST
39565: PPUSH
39566: CALL_OW 72
39570: PUSH
39571: LD_EXP 116
39575: PUSH
39576: LD_VAR 0 2
39580: ARRAY
39581: PPUSH
39582: LD_INT 30
39584: PUSH
39585: LD_INT 3
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PPUSH
39592: CALL_OW 72
39596: PUSH
39597: LD_EXP 116
39601: PUSH
39602: LD_VAR 0 2
39606: ARRAY
39607: PPUSH
39608: LD_INT 2
39610: PUSH
39611: LD_INT 30
39613: PUSH
39614: LD_INT 6
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 30
39623: PUSH
39624: LD_INT 7
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 30
39633: PUSH
39634: LD_INT 8
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: PPUSH
39647: CALL_OW 72
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: ST_TO_ADDR
// for j = 1 to 4 do
39658: LD_ADDR_VAR 0 3
39662: PUSH
39663: DOUBLE
39664: LD_INT 1
39666: DEC
39667: ST_TO_ADDR
39668: LD_INT 4
39670: PUSH
39671: FOR_TO
39672: IFFALSE 39863
// begin if not tmp [ j ] then
39674: LD_VAR 0 4
39678: PUSH
39679: LD_VAR 0 3
39683: ARRAY
39684: NOT
39685: IFFALSE 39689
// continue ;
39687: GO 39671
// for p in tmp [ j ] do
39689: LD_ADDR_VAR 0 5
39693: PUSH
39694: LD_VAR 0 4
39698: PUSH
39699: LD_VAR 0 3
39703: ARRAY
39704: PUSH
39705: FOR_IN
39706: IFFALSE 39859
// begin if not b [ j ] then
39708: LD_VAR 0 6
39712: PUSH
39713: LD_VAR 0 3
39717: ARRAY
39718: NOT
39719: IFFALSE 39723
// break ;
39721: GO 39859
// e := 0 ;
39723: LD_ADDR_VAR 0 7
39727: PUSH
39728: LD_INT 0
39730: ST_TO_ADDR
// for k in b [ j ] do
39731: LD_ADDR_VAR 0 8
39735: PUSH
39736: LD_VAR 0 6
39740: PUSH
39741: LD_VAR 0 3
39745: ARRAY
39746: PUSH
39747: FOR_IN
39748: IFFALSE 39775
// if IsNotFull ( k ) then
39750: LD_VAR 0 8
39754: PPUSH
39755: CALL 67769 0 1
39759: IFFALSE 39773
// begin e := k ;
39761: LD_ADDR_VAR 0 7
39765: PUSH
39766: LD_VAR 0 8
39770: ST_TO_ADDR
// break ;
39771: GO 39775
// end ;
39773: GO 39747
39775: POP
39776: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39777: LD_VAR 0 7
39781: PUSH
39782: LD_VAR 0 5
39786: PPUSH
39787: LD_VAR 0 7
39791: PPUSH
39792: CALL 100934 0 2
39796: NOT
39797: AND
39798: IFFALSE 39857
// begin if IsInUnit ( p ) then
39800: LD_VAR 0 5
39804: PPUSH
39805: CALL_OW 310
39809: IFFALSE 39820
// ComExitBuilding ( p ) ;
39811: LD_VAR 0 5
39815: PPUSH
39816: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39820: LD_VAR 0 5
39824: PPUSH
39825: LD_VAR 0 7
39829: PPUSH
39830: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39834: LD_VAR 0 5
39838: PPUSH
39839: LD_VAR 0 3
39843: PPUSH
39844: CALL_OW 183
// AddComExitBuilding ( p ) ;
39848: LD_VAR 0 5
39852: PPUSH
39853: CALL_OW 182
// end ; end ;
39857: GO 39705
39859: POP
39860: POP
// end ;
39861: GO 39671
39863: POP
39864: POP
// end ;
39865: GO 39426
39867: POP
39868: POP
// end ;
39869: LD_VAR 0 1
39873: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39874: LD_INT 0
39876: PPUSH
39877: PPUSH
39878: PPUSH
39879: PPUSH
39880: PPUSH
39881: PPUSH
39882: PPUSH
39883: PPUSH
39884: PPUSH
39885: PPUSH
39886: PPUSH
39887: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39888: LD_VAR 0 1
39892: NOT
39893: PUSH
39894: LD_EXP 116
39898: PUSH
39899: LD_VAR 0 1
39903: ARRAY
39904: NOT
39905: OR
39906: PUSH
39907: LD_EXP 116
39911: PUSH
39912: LD_VAR 0 1
39916: ARRAY
39917: PPUSH
39918: LD_INT 2
39920: PUSH
39921: LD_INT 30
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 30
39933: PUSH
39934: LD_INT 1
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: LIST
39945: PPUSH
39946: CALL_OW 72
39950: NOT
39951: OR
39952: IFFALSE 39956
// exit ;
39954: GO 43459
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39956: LD_ADDR_VAR 0 4
39960: PUSH
39961: LD_EXP 116
39965: PUSH
39966: LD_VAR 0 1
39970: ARRAY
39971: PPUSH
39972: LD_INT 2
39974: PUSH
39975: LD_INT 25
39977: PUSH
39978: LD_INT 1
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 25
39987: PUSH
39988: LD_INT 2
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 25
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 25
40007: PUSH
40008: LD_INT 4
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 25
40017: PUSH
40018: LD_INT 5
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 25
40027: PUSH
40028: LD_INT 8
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 25
40037: PUSH
40038: LD_INT 9
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: PPUSH
40055: CALL_OW 72
40059: ST_TO_ADDR
// if not tmp then
40060: LD_VAR 0 4
40064: NOT
40065: IFFALSE 40069
// exit ;
40067: GO 43459
// for i in tmp do
40069: LD_ADDR_VAR 0 3
40073: PUSH
40074: LD_VAR 0 4
40078: PUSH
40079: FOR_IN
40080: IFFALSE 40111
// if GetTag ( i ) then
40082: LD_VAR 0 3
40086: PPUSH
40087: CALL_OW 110
40091: IFFALSE 40109
// tmp := tmp diff i ;
40093: LD_ADDR_VAR 0 4
40097: PUSH
40098: LD_VAR 0 4
40102: PUSH
40103: LD_VAR 0 3
40107: DIFF
40108: ST_TO_ADDR
40109: GO 40079
40111: POP
40112: POP
// if not tmp then
40113: LD_VAR 0 4
40117: NOT
40118: IFFALSE 40122
// exit ;
40120: GO 43459
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40122: LD_ADDR_VAR 0 5
40126: PUSH
40127: LD_EXP 116
40131: PUSH
40132: LD_VAR 0 1
40136: ARRAY
40137: PPUSH
40138: LD_INT 2
40140: PUSH
40141: LD_INT 25
40143: PUSH
40144: LD_INT 1
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 25
40153: PUSH
40154: LD_INT 5
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 25
40163: PUSH
40164: LD_INT 8
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 25
40173: PUSH
40174: LD_INT 9
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: PPUSH
40188: CALL_OW 72
40192: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40193: LD_ADDR_VAR 0 6
40197: PUSH
40198: LD_EXP 116
40202: PUSH
40203: LD_VAR 0 1
40207: ARRAY
40208: PPUSH
40209: LD_INT 25
40211: PUSH
40212: LD_INT 2
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PPUSH
40219: CALL_OW 72
40223: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40224: LD_ADDR_VAR 0 7
40228: PUSH
40229: LD_EXP 116
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PPUSH
40240: LD_INT 25
40242: PUSH
40243: LD_INT 3
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PPUSH
40250: CALL_OW 72
40254: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40255: LD_ADDR_VAR 0 8
40259: PUSH
40260: LD_EXP 116
40264: PUSH
40265: LD_VAR 0 1
40269: ARRAY
40270: PPUSH
40271: LD_INT 25
40273: PUSH
40274: LD_INT 4
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 24
40283: PUSH
40284: LD_INT 251
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PPUSH
40295: CALL_OW 72
40299: ST_TO_ADDR
// if mc_scan [ base ] then
40300: LD_EXP 139
40304: PUSH
40305: LD_VAR 0 1
40309: ARRAY
40310: IFFALSE 40771
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40312: LD_ADDR_EXP 158
40316: PUSH
40317: LD_EXP 158
40321: PPUSH
40322: LD_VAR 0 1
40326: PPUSH
40327: LD_INT 4
40329: PPUSH
40330: CALL_OW 1
40334: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40335: LD_ADDR_VAR 0 12
40339: PUSH
40340: LD_EXP 116
40344: PUSH
40345: LD_VAR 0 1
40349: ARRAY
40350: PPUSH
40351: LD_INT 2
40353: PUSH
40354: LD_INT 30
40356: PUSH
40357: LD_INT 4
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 30
40366: PUSH
40367: LD_INT 5
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: LIST
40378: PPUSH
40379: CALL_OW 72
40383: ST_TO_ADDR
// if not b then
40384: LD_VAR 0 12
40388: NOT
40389: IFFALSE 40393
// exit ;
40391: GO 43459
// p := [ ] ;
40393: LD_ADDR_VAR 0 11
40397: PUSH
40398: EMPTY
40399: ST_TO_ADDR
// if sci >= 2 then
40400: LD_VAR 0 8
40404: PUSH
40405: LD_INT 2
40407: GREATEREQUAL
40408: IFFALSE 40439
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40410: LD_ADDR_VAR 0 8
40414: PUSH
40415: LD_VAR 0 8
40419: PUSH
40420: LD_INT 1
40422: ARRAY
40423: PUSH
40424: LD_VAR 0 8
40428: PUSH
40429: LD_INT 2
40431: ARRAY
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: ST_TO_ADDR
40437: GO 40500
// if sci = 1 then
40439: LD_VAR 0 8
40443: PUSH
40444: LD_INT 1
40446: EQUAL
40447: IFFALSE 40468
// sci := [ sci [ 1 ] ] else
40449: LD_ADDR_VAR 0 8
40453: PUSH
40454: LD_VAR 0 8
40458: PUSH
40459: LD_INT 1
40461: ARRAY
40462: PUSH
40463: EMPTY
40464: LIST
40465: ST_TO_ADDR
40466: GO 40500
// if sci = 0 then
40468: LD_VAR 0 8
40472: PUSH
40473: LD_INT 0
40475: EQUAL
40476: IFFALSE 40500
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40478: LD_ADDR_VAR 0 11
40482: PUSH
40483: LD_VAR 0 4
40487: PPUSH
40488: LD_INT 4
40490: PPUSH
40491: CALL 100797 0 2
40495: PUSH
40496: LD_INT 1
40498: ARRAY
40499: ST_TO_ADDR
// if eng > 4 then
40500: LD_VAR 0 6
40504: PUSH
40505: LD_INT 4
40507: GREATER
40508: IFFALSE 40554
// for i = eng downto 4 do
40510: LD_ADDR_VAR 0 3
40514: PUSH
40515: DOUBLE
40516: LD_VAR 0 6
40520: INC
40521: ST_TO_ADDR
40522: LD_INT 4
40524: PUSH
40525: FOR_DOWNTO
40526: IFFALSE 40552
// eng := eng diff eng [ i ] ;
40528: LD_ADDR_VAR 0 6
40532: PUSH
40533: LD_VAR 0 6
40537: PUSH
40538: LD_VAR 0 6
40542: PUSH
40543: LD_VAR 0 3
40547: ARRAY
40548: DIFF
40549: ST_TO_ADDR
40550: GO 40525
40552: POP
40553: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40554: LD_ADDR_VAR 0 4
40558: PUSH
40559: LD_VAR 0 4
40563: PUSH
40564: LD_VAR 0 5
40568: PUSH
40569: LD_VAR 0 6
40573: UNION
40574: PUSH
40575: LD_VAR 0 7
40579: UNION
40580: PUSH
40581: LD_VAR 0 8
40585: UNION
40586: DIFF
40587: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40588: LD_ADDR_VAR 0 13
40592: PUSH
40593: LD_EXP 116
40597: PUSH
40598: LD_VAR 0 1
40602: ARRAY
40603: PPUSH
40604: LD_INT 2
40606: PUSH
40607: LD_INT 30
40609: PUSH
40610: LD_INT 32
40612: PUSH
40613: EMPTY
40614: LIST
40615: LIST
40616: PUSH
40617: LD_INT 30
40619: PUSH
40620: LD_INT 31
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: LIST
40631: PPUSH
40632: CALL_OW 72
40636: PUSH
40637: LD_EXP 116
40641: PUSH
40642: LD_VAR 0 1
40646: ARRAY
40647: PPUSH
40648: LD_INT 2
40650: PUSH
40651: LD_INT 30
40653: PUSH
40654: LD_INT 4
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 30
40663: PUSH
40664: LD_INT 5
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: LIST
40675: PPUSH
40676: CALL_OW 72
40680: PUSH
40681: LD_INT 6
40683: MUL
40684: PLUS
40685: ST_TO_ADDR
// if bcount < tmp then
40686: LD_VAR 0 13
40690: PUSH
40691: LD_VAR 0 4
40695: LESS
40696: IFFALSE 40742
// for i = tmp downto bcount do
40698: LD_ADDR_VAR 0 3
40702: PUSH
40703: DOUBLE
40704: LD_VAR 0 4
40708: INC
40709: ST_TO_ADDR
40710: LD_VAR 0 13
40714: PUSH
40715: FOR_DOWNTO
40716: IFFALSE 40740
// tmp := Delete ( tmp , tmp ) ;
40718: LD_ADDR_VAR 0 4
40722: PUSH
40723: LD_VAR 0 4
40727: PPUSH
40728: LD_VAR 0 4
40732: PPUSH
40733: CALL_OW 3
40737: ST_TO_ADDR
40738: GO 40715
40740: POP
40741: POP
// result := [ tmp , 0 , 0 , p ] ;
40742: LD_ADDR_VAR 0 2
40746: PUSH
40747: LD_VAR 0 4
40751: PUSH
40752: LD_INT 0
40754: PUSH
40755: LD_INT 0
40757: PUSH
40758: LD_VAR 0 11
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: LIST
40767: LIST
40768: ST_TO_ADDR
// exit ;
40769: GO 43459
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40771: LD_EXP 116
40775: PUSH
40776: LD_VAR 0 1
40780: ARRAY
40781: PPUSH
40782: LD_INT 2
40784: PUSH
40785: LD_INT 30
40787: PUSH
40788: LD_INT 6
40790: PUSH
40791: EMPTY
40792: LIST
40793: LIST
40794: PUSH
40795: LD_INT 30
40797: PUSH
40798: LD_INT 7
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 30
40807: PUSH
40808: LD_INT 8
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: LIST
40819: LIST
40820: PPUSH
40821: CALL_OW 72
40825: NOT
40826: PUSH
40827: LD_EXP 116
40831: PUSH
40832: LD_VAR 0 1
40836: ARRAY
40837: PPUSH
40838: LD_INT 30
40840: PUSH
40841: LD_INT 3
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PPUSH
40848: CALL_OW 72
40852: NOT
40853: AND
40854: IFFALSE 40926
// begin if eng = tmp then
40856: LD_VAR 0 6
40860: PUSH
40861: LD_VAR 0 4
40865: EQUAL
40866: IFFALSE 40870
// exit ;
40868: GO 43459
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40870: LD_ADDR_EXP 158
40874: PUSH
40875: LD_EXP 158
40879: PPUSH
40880: LD_VAR 0 1
40884: PPUSH
40885: LD_INT 1
40887: PPUSH
40888: CALL_OW 1
40892: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40893: LD_ADDR_VAR 0 2
40897: PUSH
40898: LD_INT 0
40900: PUSH
40901: LD_VAR 0 4
40905: PUSH
40906: LD_VAR 0 6
40910: DIFF
40911: PUSH
40912: LD_INT 0
40914: PUSH
40915: LD_INT 0
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: ST_TO_ADDR
// exit ;
40924: GO 43459
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40926: LD_EXP 143
40930: PUSH
40931: LD_EXP 142
40935: PUSH
40936: LD_VAR 0 1
40940: ARRAY
40941: ARRAY
40942: PUSH
40943: LD_EXP 116
40947: PUSH
40948: LD_VAR 0 1
40952: ARRAY
40953: PPUSH
40954: LD_INT 2
40956: PUSH
40957: LD_INT 30
40959: PUSH
40960: LD_INT 6
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 30
40969: PUSH
40970: LD_INT 7
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 30
40979: PUSH
40980: LD_INT 8
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: PPUSH
40993: CALL_OW 72
40997: AND
40998: PUSH
40999: LD_EXP 116
41003: PUSH
41004: LD_VAR 0 1
41008: ARRAY
41009: PPUSH
41010: LD_INT 30
41012: PUSH
41013: LD_INT 3
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PPUSH
41020: CALL_OW 72
41024: NOT
41025: AND
41026: IFFALSE 41240
// begin if sci >= 6 then
41028: LD_VAR 0 8
41032: PUSH
41033: LD_INT 6
41035: GREATEREQUAL
41036: IFFALSE 41040
// exit ;
41038: GO 43459
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41040: LD_ADDR_EXP 158
41044: PUSH
41045: LD_EXP 158
41049: PPUSH
41050: LD_VAR 0 1
41054: PPUSH
41055: LD_INT 2
41057: PPUSH
41058: CALL_OW 1
41062: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41063: LD_ADDR_VAR 0 9
41067: PUSH
41068: LD_VAR 0 4
41072: PUSH
41073: LD_VAR 0 8
41077: DIFF
41078: PPUSH
41079: LD_INT 4
41081: PPUSH
41082: CALL 100797 0 2
41086: ST_TO_ADDR
// p := [ ] ;
41087: LD_ADDR_VAR 0 11
41091: PUSH
41092: EMPTY
41093: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41094: LD_VAR 0 8
41098: PUSH
41099: LD_INT 6
41101: LESS
41102: PUSH
41103: LD_VAR 0 9
41107: PUSH
41108: LD_INT 6
41110: GREATER
41111: AND
41112: IFFALSE 41193
// begin for i = 1 to 6 - sci do
41114: LD_ADDR_VAR 0 3
41118: PUSH
41119: DOUBLE
41120: LD_INT 1
41122: DEC
41123: ST_TO_ADDR
41124: LD_INT 6
41126: PUSH
41127: LD_VAR 0 8
41131: MINUS
41132: PUSH
41133: FOR_TO
41134: IFFALSE 41189
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41136: LD_ADDR_VAR 0 11
41140: PUSH
41141: LD_VAR 0 11
41145: PPUSH
41146: LD_VAR 0 11
41150: PUSH
41151: LD_INT 1
41153: PLUS
41154: PPUSH
41155: LD_VAR 0 9
41159: PUSH
41160: LD_INT 1
41162: ARRAY
41163: PPUSH
41164: CALL_OW 2
41168: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41169: LD_ADDR_VAR 0 9
41173: PUSH
41174: LD_VAR 0 9
41178: PPUSH
41179: LD_INT 1
41181: PPUSH
41182: CALL_OW 3
41186: ST_TO_ADDR
// end ;
41187: GO 41133
41189: POP
41190: POP
// end else
41191: GO 41213
// if sort then
41193: LD_VAR 0 9
41197: IFFALSE 41213
// p := sort [ 1 ] ;
41199: LD_ADDR_VAR 0 11
41203: PUSH
41204: LD_VAR 0 9
41208: PUSH
41209: LD_INT 1
41211: ARRAY
41212: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41213: LD_ADDR_VAR 0 2
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: LD_INT 0
41223: PUSH
41224: LD_INT 0
41226: PUSH
41227: LD_VAR 0 11
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: ST_TO_ADDR
// exit ;
41238: GO 43459
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41240: LD_EXP 143
41244: PUSH
41245: LD_EXP 142
41249: PUSH
41250: LD_VAR 0 1
41254: ARRAY
41255: ARRAY
41256: PUSH
41257: LD_EXP 116
41261: PUSH
41262: LD_VAR 0 1
41266: ARRAY
41267: PPUSH
41268: LD_INT 2
41270: PUSH
41271: LD_INT 30
41273: PUSH
41274: LD_INT 6
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 30
41283: PUSH
41284: LD_INT 7
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 30
41293: PUSH
41294: LD_INT 8
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 72
41311: AND
41312: PUSH
41313: LD_EXP 116
41317: PUSH
41318: LD_VAR 0 1
41322: ARRAY
41323: PPUSH
41324: LD_INT 30
41326: PUSH
41327: LD_INT 3
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PPUSH
41334: CALL_OW 72
41338: AND
41339: IFFALSE 42073
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41341: LD_ADDR_EXP 158
41345: PUSH
41346: LD_EXP 158
41350: PPUSH
41351: LD_VAR 0 1
41355: PPUSH
41356: LD_INT 3
41358: PPUSH
41359: CALL_OW 1
41363: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41364: LD_ADDR_VAR 0 2
41368: PUSH
41369: LD_INT 0
41371: PUSH
41372: LD_INT 0
41374: PUSH
41375: LD_INT 0
41377: PUSH
41378: LD_INT 0
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: LIST
41385: LIST
41386: ST_TO_ADDR
// if not eng then
41387: LD_VAR 0 6
41391: NOT
41392: IFFALSE 41455
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41394: LD_ADDR_VAR 0 11
41398: PUSH
41399: LD_VAR 0 4
41403: PPUSH
41404: LD_INT 2
41406: PPUSH
41407: CALL 100797 0 2
41411: PUSH
41412: LD_INT 1
41414: ARRAY
41415: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41416: LD_ADDR_VAR 0 2
41420: PUSH
41421: LD_VAR 0 2
41425: PPUSH
41426: LD_INT 2
41428: PPUSH
41429: LD_VAR 0 11
41433: PPUSH
41434: CALL_OW 1
41438: ST_TO_ADDR
// tmp := tmp diff p ;
41439: LD_ADDR_VAR 0 4
41443: PUSH
41444: LD_VAR 0 4
41448: PUSH
41449: LD_VAR 0 11
41453: DIFF
41454: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41455: LD_VAR 0 4
41459: PUSH
41460: LD_VAR 0 8
41464: PUSH
41465: LD_INT 6
41467: LESS
41468: AND
41469: IFFALSE 41657
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41471: LD_ADDR_VAR 0 9
41475: PUSH
41476: LD_VAR 0 4
41480: PUSH
41481: LD_VAR 0 8
41485: PUSH
41486: LD_VAR 0 7
41490: UNION
41491: DIFF
41492: PPUSH
41493: LD_INT 4
41495: PPUSH
41496: CALL 100797 0 2
41500: ST_TO_ADDR
// p := [ ] ;
41501: LD_ADDR_VAR 0 11
41505: PUSH
41506: EMPTY
41507: ST_TO_ADDR
// if sort then
41508: LD_VAR 0 9
41512: IFFALSE 41628
// for i = 1 to 6 - sci do
41514: LD_ADDR_VAR 0 3
41518: PUSH
41519: DOUBLE
41520: LD_INT 1
41522: DEC
41523: ST_TO_ADDR
41524: LD_INT 6
41526: PUSH
41527: LD_VAR 0 8
41531: MINUS
41532: PUSH
41533: FOR_TO
41534: IFFALSE 41626
// begin if i = sort then
41536: LD_VAR 0 3
41540: PUSH
41541: LD_VAR 0 9
41545: EQUAL
41546: IFFALSE 41550
// break ;
41548: GO 41626
// if GetClass ( i ) = 4 then
41550: LD_VAR 0 3
41554: PPUSH
41555: CALL_OW 257
41559: PUSH
41560: LD_INT 4
41562: EQUAL
41563: IFFALSE 41567
// continue ;
41565: GO 41533
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41567: LD_ADDR_VAR 0 11
41571: PUSH
41572: LD_VAR 0 11
41576: PPUSH
41577: LD_VAR 0 11
41581: PUSH
41582: LD_INT 1
41584: PLUS
41585: PPUSH
41586: LD_VAR 0 9
41590: PUSH
41591: LD_VAR 0 3
41595: ARRAY
41596: PPUSH
41597: CALL_OW 2
41601: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41602: LD_ADDR_VAR 0 4
41606: PUSH
41607: LD_VAR 0 4
41611: PUSH
41612: LD_VAR 0 9
41616: PUSH
41617: LD_VAR 0 3
41621: ARRAY
41622: DIFF
41623: ST_TO_ADDR
// end ;
41624: GO 41533
41626: POP
41627: POP
// if p then
41628: LD_VAR 0 11
41632: IFFALSE 41657
// result := Replace ( result , 4 , p ) ;
41634: LD_ADDR_VAR 0 2
41638: PUSH
41639: LD_VAR 0 2
41643: PPUSH
41644: LD_INT 4
41646: PPUSH
41647: LD_VAR 0 11
41651: PPUSH
41652: CALL_OW 1
41656: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41657: LD_VAR 0 4
41661: PUSH
41662: LD_VAR 0 7
41666: PUSH
41667: LD_INT 6
41669: LESS
41670: AND
41671: IFFALSE 41859
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41673: LD_ADDR_VAR 0 9
41677: PUSH
41678: LD_VAR 0 4
41682: PUSH
41683: LD_VAR 0 8
41687: PUSH
41688: LD_VAR 0 7
41692: UNION
41693: DIFF
41694: PPUSH
41695: LD_INT 3
41697: PPUSH
41698: CALL 100797 0 2
41702: ST_TO_ADDR
// p := [ ] ;
41703: LD_ADDR_VAR 0 11
41707: PUSH
41708: EMPTY
41709: ST_TO_ADDR
// if sort then
41710: LD_VAR 0 9
41714: IFFALSE 41830
// for i = 1 to 6 - mech do
41716: LD_ADDR_VAR 0 3
41720: PUSH
41721: DOUBLE
41722: LD_INT 1
41724: DEC
41725: ST_TO_ADDR
41726: LD_INT 6
41728: PUSH
41729: LD_VAR 0 7
41733: MINUS
41734: PUSH
41735: FOR_TO
41736: IFFALSE 41828
// begin if i = sort then
41738: LD_VAR 0 3
41742: PUSH
41743: LD_VAR 0 9
41747: EQUAL
41748: IFFALSE 41752
// break ;
41750: GO 41828
// if GetClass ( i ) = 3 then
41752: LD_VAR 0 3
41756: PPUSH
41757: CALL_OW 257
41761: PUSH
41762: LD_INT 3
41764: EQUAL
41765: IFFALSE 41769
// continue ;
41767: GO 41735
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41769: LD_ADDR_VAR 0 11
41773: PUSH
41774: LD_VAR 0 11
41778: PPUSH
41779: LD_VAR 0 11
41783: PUSH
41784: LD_INT 1
41786: PLUS
41787: PPUSH
41788: LD_VAR 0 9
41792: PUSH
41793: LD_VAR 0 3
41797: ARRAY
41798: PPUSH
41799: CALL_OW 2
41803: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41804: LD_ADDR_VAR 0 4
41808: PUSH
41809: LD_VAR 0 4
41813: PUSH
41814: LD_VAR 0 9
41818: PUSH
41819: LD_VAR 0 3
41823: ARRAY
41824: DIFF
41825: ST_TO_ADDR
// end ;
41826: GO 41735
41828: POP
41829: POP
// if p then
41830: LD_VAR 0 11
41834: IFFALSE 41859
// result := Replace ( result , 3 , p ) ;
41836: LD_ADDR_VAR 0 2
41840: PUSH
41841: LD_VAR 0 2
41845: PPUSH
41846: LD_INT 3
41848: PPUSH
41849: LD_VAR 0 11
41853: PPUSH
41854: CALL_OW 1
41858: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41859: LD_VAR 0 4
41863: PUSH
41864: LD_INT 6
41866: GREATER
41867: PUSH
41868: LD_VAR 0 6
41872: PUSH
41873: LD_INT 6
41875: LESS
41876: AND
41877: IFFALSE 42071
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41879: LD_ADDR_VAR 0 9
41883: PUSH
41884: LD_VAR 0 4
41888: PUSH
41889: LD_VAR 0 8
41893: PUSH
41894: LD_VAR 0 7
41898: UNION
41899: PUSH
41900: LD_VAR 0 6
41904: UNION
41905: DIFF
41906: PPUSH
41907: LD_INT 2
41909: PPUSH
41910: CALL 100797 0 2
41914: ST_TO_ADDR
// p := [ ] ;
41915: LD_ADDR_VAR 0 11
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// if sort then
41922: LD_VAR 0 9
41926: IFFALSE 42042
// for i = 1 to 6 - eng do
41928: LD_ADDR_VAR 0 3
41932: PUSH
41933: DOUBLE
41934: LD_INT 1
41936: DEC
41937: ST_TO_ADDR
41938: LD_INT 6
41940: PUSH
41941: LD_VAR 0 6
41945: MINUS
41946: PUSH
41947: FOR_TO
41948: IFFALSE 42040
// begin if i = sort then
41950: LD_VAR 0 3
41954: PUSH
41955: LD_VAR 0 9
41959: EQUAL
41960: IFFALSE 41964
// break ;
41962: GO 42040
// if GetClass ( i ) = 2 then
41964: LD_VAR 0 3
41968: PPUSH
41969: CALL_OW 257
41973: PUSH
41974: LD_INT 2
41976: EQUAL
41977: IFFALSE 41981
// continue ;
41979: GO 41947
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41981: LD_ADDR_VAR 0 11
41985: PUSH
41986: LD_VAR 0 11
41990: PPUSH
41991: LD_VAR 0 11
41995: PUSH
41996: LD_INT 1
41998: PLUS
41999: PPUSH
42000: LD_VAR 0 9
42004: PUSH
42005: LD_VAR 0 3
42009: ARRAY
42010: PPUSH
42011: CALL_OW 2
42015: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42016: LD_ADDR_VAR 0 4
42020: PUSH
42021: LD_VAR 0 4
42025: PUSH
42026: LD_VAR 0 9
42030: PUSH
42031: LD_VAR 0 3
42035: ARRAY
42036: DIFF
42037: ST_TO_ADDR
// end ;
42038: GO 41947
42040: POP
42041: POP
// if p then
42042: LD_VAR 0 11
42046: IFFALSE 42071
// result := Replace ( result , 2 , p ) ;
42048: LD_ADDR_VAR 0 2
42052: PUSH
42053: LD_VAR 0 2
42057: PPUSH
42058: LD_INT 2
42060: PPUSH
42061: LD_VAR 0 11
42065: PPUSH
42066: CALL_OW 1
42070: ST_TO_ADDR
// end ; exit ;
42071: GO 43459
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42073: LD_EXP 143
42077: PUSH
42078: LD_EXP 142
42082: PUSH
42083: LD_VAR 0 1
42087: ARRAY
42088: ARRAY
42089: NOT
42090: PUSH
42091: LD_EXP 116
42095: PUSH
42096: LD_VAR 0 1
42100: ARRAY
42101: PPUSH
42102: LD_INT 30
42104: PUSH
42105: LD_INT 3
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: PPUSH
42112: CALL_OW 72
42116: AND
42117: PUSH
42118: LD_EXP 121
42122: PUSH
42123: LD_VAR 0 1
42127: ARRAY
42128: AND
42129: IFFALSE 42737
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42131: LD_ADDR_EXP 158
42135: PUSH
42136: LD_EXP 158
42140: PPUSH
42141: LD_VAR 0 1
42145: PPUSH
42146: LD_INT 5
42148: PPUSH
42149: CALL_OW 1
42153: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42154: LD_ADDR_VAR 0 2
42158: PUSH
42159: LD_INT 0
42161: PUSH
42162: LD_INT 0
42164: PUSH
42165: LD_INT 0
42167: PUSH
42168: LD_INT 0
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: ST_TO_ADDR
// if sci > 1 then
42177: LD_VAR 0 8
42181: PUSH
42182: LD_INT 1
42184: GREATER
42185: IFFALSE 42213
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42187: LD_ADDR_VAR 0 4
42191: PUSH
42192: LD_VAR 0 4
42196: PUSH
42197: LD_VAR 0 8
42201: PUSH
42202: LD_VAR 0 8
42206: PUSH
42207: LD_INT 1
42209: ARRAY
42210: DIFF
42211: DIFF
42212: ST_TO_ADDR
// if tmp and not sci then
42213: LD_VAR 0 4
42217: PUSH
42218: LD_VAR 0 8
42222: NOT
42223: AND
42224: IFFALSE 42293
// begin sort := SortBySkill ( tmp , 4 ) ;
42226: LD_ADDR_VAR 0 9
42230: PUSH
42231: LD_VAR 0 4
42235: PPUSH
42236: LD_INT 4
42238: PPUSH
42239: CALL 100797 0 2
42243: ST_TO_ADDR
// if sort then
42244: LD_VAR 0 9
42248: IFFALSE 42264
// p := sort [ 1 ] ;
42250: LD_ADDR_VAR 0 11
42254: PUSH
42255: LD_VAR 0 9
42259: PUSH
42260: LD_INT 1
42262: ARRAY
42263: ST_TO_ADDR
// if p then
42264: LD_VAR 0 11
42268: IFFALSE 42293
// result := Replace ( result , 4 , p ) ;
42270: LD_ADDR_VAR 0 2
42274: PUSH
42275: LD_VAR 0 2
42279: PPUSH
42280: LD_INT 4
42282: PPUSH
42283: LD_VAR 0 11
42287: PPUSH
42288: CALL_OW 1
42292: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42293: LD_ADDR_VAR 0 4
42297: PUSH
42298: LD_VAR 0 4
42302: PUSH
42303: LD_VAR 0 7
42307: DIFF
42308: ST_TO_ADDR
// if tmp and mech < 6 then
42309: LD_VAR 0 4
42313: PUSH
42314: LD_VAR 0 7
42318: PUSH
42319: LD_INT 6
42321: LESS
42322: AND
42323: IFFALSE 42511
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42325: LD_ADDR_VAR 0 9
42329: PUSH
42330: LD_VAR 0 4
42334: PUSH
42335: LD_VAR 0 8
42339: PUSH
42340: LD_VAR 0 7
42344: UNION
42345: DIFF
42346: PPUSH
42347: LD_INT 3
42349: PPUSH
42350: CALL 100797 0 2
42354: ST_TO_ADDR
// p := [ ] ;
42355: LD_ADDR_VAR 0 11
42359: PUSH
42360: EMPTY
42361: ST_TO_ADDR
// if sort then
42362: LD_VAR 0 9
42366: IFFALSE 42482
// for i = 1 to 6 - mech do
42368: LD_ADDR_VAR 0 3
42372: PUSH
42373: DOUBLE
42374: LD_INT 1
42376: DEC
42377: ST_TO_ADDR
42378: LD_INT 6
42380: PUSH
42381: LD_VAR 0 7
42385: MINUS
42386: PUSH
42387: FOR_TO
42388: IFFALSE 42480
// begin if i = sort then
42390: LD_VAR 0 3
42394: PUSH
42395: LD_VAR 0 9
42399: EQUAL
42400: IFFALSE 42404
// break ;
42402: GO 42480
// if GetClass ( i ) = 3 then
42404: LD_VAR 0 3
42408: PPUSH
42409: CALL_OW 257
42413: PUSH
42414: LD_INT 3
42416: EQUAL
42417: IFFALSE 42421
// continue ;
42419: GO 42387
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42421: LD_ADDR_VAR 0 11
42425: PUSH
42426: LD_VAR 0 11
42430: PPUSH
42431: LD_VAR 0 11
42435: PUSH
42436: LD_INT 1
42438: PLUS
42439: PPUSH
42440: LD_VAR 0 9
42444: PUSH
42445: LD_VAR 0 3
42449: ARRAY
42450: PPUSH
42451: CALL_OW 2
42455: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42456: LD_ADDR_VAR 0 4
42460: PUSH
42461: LD_VAR 0 4
42465: PUSH
42466: LD_VAR 0 9
42470: PUSH
42471: LD_VAR 0 3
42475: ARRAY
42476: DIFF
42477: ST_TO_ADDR
// end ;
42478: GO 42387
42480: POP
42481: POP
// if p then
42482: LD_VAR 0 11
42486: IFFALSE 42511
// result := Replace ( result , 3 , p ) ;
42488: LD_ADDR_VAR 0 2
42492: PUSH
42493: LD_VAR 0 2
42497: PPUSH
42498: LD_INT 3
42500: PPUSH
42501: LD_VAR 0 11
42505: PPUSH
42506: CALL_OW 1
42510: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42511: LD_ADDR_VAR 0 4
42515: PUSH
42516: LD_VAR 0 4
42520: PUSH
42521: LD_VAR 0 6
42525: DIFF
42526: ST_TO_ADDR
// if tmp and eng < 6 then
42527: LD_VAR 0 4
42531: PUSH
42532: LD_VAR 0 6
42536: PUSH
42537: LD_INT 6
42539: LESS
42540: AND
42541: IFFALSE 42735
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42543: LD_ADDR_VAR 0 9
42547: PUSH
42548: LD_VAR 0 4
42552: PUSH
42553: LD_VAR 0 8
42557: PUSH
42558: LD_VAR 0 7
42562: UNION
42563: PUSH
42564: LD_VAR 0 6
42568: UNION
42569: DIFF
42570: PPUSH
42571: LD_INT 2
42573: PPUSH
42574: CALL 100797 0 2
42578: ST_TO_ADDR
// p := [ ] ;
42579: LD_ADDR_VAR 0 11
42583: PUSH
42584: EMPTY
42585: ST_TO_ADDR
// if sort then
42586: LD_VAR 0 9
42590: IFFALSE 42706
// for i = 1 to 6 - eng do
42592: LD_ADDR_VAR 0 3
42596: PUSH
42597: DOUBLE
42598: LD_INT 1
42600: DEC
42601: ST_TO_ADDR
42602: LD_INT 6
42604: PUSH
42605: LD_VAR 0 6
42609: MINUS
42610: PUSH
42611: FOR_TO
42612: IFFALSE 42704
// begin if i = sort then
42614: LD_VAR 0 3
42618: PUSH
42619: LD_VAR 0 9
42623: EQUAL
42624: IFFALSE 42628
// break ;
42626: GO 42704
// if GetClass ( i ) = 2 then
42628: LD_VAR 0 3
42632: PPUSH
42633: CALL_OW 257
42637: PUSH
42638: LD_INT 2
42640: EQUAL
42641: IFFALSE 42645
// continue ;
42643: GO 42611
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42645: LD_ADDR_VAR 0 11
42649: PUSH
42650: LD_VAR 0 11
42654: PPUSH
42655: LD_VAR 0 11
42659: PUSH
42660: LD_INT 1
42662: PLUS
42663: PPUSH
42664: LD_VAR 0 9
42668: PUSH
42669: LD_VAR 0 3
42673: ARRAY
42674: PPUSH
42675: CALL_OW 2
42679: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42680: LD_ADDR_VAR 0 4
42684: PUSH
42685: LD_VAR 0 4
42689: PUSH
42690: LD_VAR 0 9
42694: PUSH
42695: LD_VAR 0 3
42699: ARRAY
42700: DIFF
42701: ST_TO_ADDR
// end ;
42702: GO 42611
42704: POP
42705: POP
// if p then
42706: LD_VAR 0 11
42710: IFFALSE 42735
// result := Replace ( result , 2 , p ) ;
42712: LD_ADDR_VAR 0 2
42716: PUSH
42717: LD_VAR 0 2
42721: PPUSH
42722: LD_INT 2
42724: PPUSH
42725: LD_VAR 0 11
42729: PPUSH
42730: CALL_OW 1
42734: ST_TO_ADDR
// end ; exit ;
42735: GO 43459
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42737: LD_EXP 143
42741: PUSH
42742: LD_EXP 142
42746: PUSH
42747: LD_VAR 0 1
42751: ARRAY
42752: ARRAY
42753: NOT
42754: PUSH
42755: LD_EXP 116
42759: PUSH
42760: LD_VAR 0 1
42764: ARRAY
42765: PPUSH
42766: LD_INT 30
42768: PUSH
42769: LD_INT 3
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PPUSH
42776: CALL_OW 72
42780: AND
42781: PUSH
42782: LD_EXP 121
42786: PUSH
42787: LD_VAR 0 1
42791: ARRAY
42792: NOT
42793: AND
42794: IFFALSE 43459
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42796: LD_ADDR_EXP 158
42800: PUSH
42801: LD_EXP 158
42805: PPUSH
42806: LD_VAR 0 1
42810: PPUSH
42811: LD_INT 6
42813: PPUSH
42814: CALL_OW 1
42818: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42819: LD_ADDR_VAR 0 2
42823: PUSH
42824: LD_INT 0
42826: PUSH
42827: LD_INT 0
42829: PUSH
42830: LD_INT 0
42832: PUSH
42833: LD_INT 0
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: ST_TO_ADDR
// if sci >= 1 then
42842: LD_VAR 0 8
42846: PUSH
42847: LD_INT 1
42849: GREATEREQUAL
42850: IFFALSE 42872
// tmp := tmp diff sci [ 1 ] ;
42852: LD_ADDR_VAR 0 4
42856: PUSH
42857: LD_VAR 0 4
42861: PUSH
42862: LD_VAR 0 8
42866: PUSH
42867: LD_INT 1
42869: ARRAY
42870: DIFF
42871: ST_TO_ADDR
// if tmp and not sci then
42872: LD_VAR 0 4
42876: PUSH
42877: LD_VAR 0 8
42881: NOT
42882: AND
42883: IFFALSE 42952
// begin sort := SortBySkill ( tmp , 4 ) ;
42885: LD_ADDR_VAR 0 9
42889: PUSH
42890: LD_VAR 0 4
42894: PPUSH
42895: LD_INT 4
42897: PPUSH
42898: CALL 100797 0 2
42902: ST_TO_ADDR
// if sort then
42903: LD_VAR 0 9
42907: IFFALSE 42923
// p := sort [ 1 ] ;
42909: LD_ADDR_VAR 0 11
42913: PUSH
42914: LD_VAR 0 9
42918: PUSH
42919: LD_INT 1
42921: ARRAY
42922: ST_TO_ADDR
// if p then
42923: LD_VAR 0 11
42927: IFFALSE 42952
// result := Replace ( result , 4 , p ) ;
42929: LD_ADDR_VAR 0 2
42933: PUSH
42934: LD_VAR 0 2
42938: PPUSH
42939: LD_INT 4
42941: PPUSH
42942: LD_VAR 0 11
42946: PPUSH
42947: CALL_OW 1
42951: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42952: LD_ADDR_VAR 0 4
42956: PUSH
42957: LD_VAR 0 4
42961: PUSH
42962: LD_VAR 0 7
42966: DIFF
42967: ST_TO_ADDR
// if tmp and mech < 6 then
42968: LD_VAR 0 4
42972: PUSH
42973: LD_VAR 0 7
42977: PUSH
42978: LD_INT 6
42980: LESS
42981: AND
42982: IFFALSE 43164
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42984: LD_ADDR_VAR 0 9
42988: PUSH
42989: LD_VAR 0 4
42993: PUSH
42994: LD_VAR 0 7
42998: DIFF
42999: PPUSH
43000: LD_INT 3
43002: PPUSH
43003: CALL 100797 0 2
43007: ST_TO_ADDR
// p := [ ] ;
43008: LD_ADDR_VAR 0 11
43012: PUSH
43013: EMPTY
43014: ST_TO_ADDR
// if sort then
43015: LD_VAR 0 9
43019: IFFALSE 43135
// for i = 1 to 6 - mech do
43021: LD_ADDR_VAR 0 3
43025: PUSH
43026: DOUBLE
43027: LD_INT 1
43029: DEC
43030: ST_TO_ADDR
43031: LD_INT 6
43033: PUSH
43034: LD_VAR 0 7
43038: MINUS
43039: PUSH
43040: FOR_TO
43041: IFFALSE 43133
// begin if i = sort then
43043: LD_VAR 0 3
43047: PUSH
43048: LD_VAR 0 9
43052: EQUAL
43053: IFFALSE 43057
// break ;
43055: GO 43133
// if GetClass ( i ) = 3 then
43057: LD_VAR 0 3
43061: PPUSH
43062: CALL_OW 257
43066: PUSH
43067: LD_INT 3
43069: EQUAL
43070: IFFALSE 43074
// continue ;
43072: GO 43040
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43074: LD_ADDR_VAR 0 11
43078: PUSH
43079: LD_VAR 0 11
43083: PPUSH
43084: LD_VAR 0 11
43088: PUSH
43089: LD_INT 1
43091: PLUS
43092: PPUSH
43093: LD_VAR 0 9
43097: PUSH
43098: LD_VAR 0 3
43102: ARRAY
43103: PPUSH
43104: CALL_OW 2
43108: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43109: LD_ADDR_VAR 0 4
43113: PUSH
43114: LD_VAR 0 4
43118: PUSH
43119: LD_VAR 0 9
43123: PUSH
43124: LD_VAR 0 3
43128: ARRAY
43129: DIFF
43130: ST_TO_ADDR
// end ;
43131: GO 43040
43133: POP
43134: POP
// if p then
43135: LD_VAR 0 11
43139: IFFALSE 43164
// result := Replace ( result , 3 , p ) ;
43141: LD_ADDR_VAR 0 2
43145: PUSH
43146: LD_VAR 0 2
43150: PPUSH
43151: LD_INT 3
43153: PPUSH
43154: LD_VAR 0 11
43158: PPUSH
43159: CALL_OW 1
43163: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43164: LD_ADDR_VAR 0 4
43168: PUSH
43169: LD_VAR 0 4
43173: PUSH
43174: LD_VAR 0 6
43178: DIFF
43179: ST_TO_ADDR
// if tmp and eng < 4 then
43180: LD_VAR 0 4
43184: PUSH
43185: LD_VAR 0 6
43189: PUSH
43190: LD_INT 4
43192: LESS
43193: AND
43194: IFFALSE 43384
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43196: LD_ADDR_VAR 0 9
43200: PUSH
43201: LD_VAR 0 4
43205: PUSH
43206: LD_VAR 0 7
43210: PUSH
43211: LD_VAR 0 6
43215: UNION
43216: DIFF
43217: PPUSH
43218: LD_INT 2
43220: PPUSH
43221: CALL 100797 0 2
43225: ST_TO_ADDR
// p := [ ] ;
43226: LD_ADDR_VAR 0 11
43230: PUSH
43231: EMPTY
43232: ST_TO_ADDR
// if sort then
43233: LD_VAR 0 9
43237: IFFALSE 43353
// for i = 1 to 4 - eng do
43239: LD_ADDR_VAR 0 3
43243: PUSH
43244: DOUBLE
43245: LD_INT 1
43247: DEC
43248: ST_TO_ADDR
43249: LD_INT 4
43251: PUSH
43252: LD_VAR 0 6
43256: MINUS
43257: PUSH
43258: FOR_TO
43259: IFFALSE 43351
// begin if i = sort then
43261: LD_VAR 0 3
43265: PUSH
43266: LD_VAR 0 9
43270: EQUAL
43271: IFFALSE 43275
// break ;
43273: GO 43351
// if GetClass ( i ) = 2 then
43275: LD_VAR 0 3
43279: PPUSH
43280: CALL_OW 257
43284: PUSH
43285: LD_INT 2
43287: EQUAL
43288: IFFALSE 43292
// continue ;
43290: GO 43258
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43292: LD_ADDR_VAR 0 11
43296: PUSH
43297: LD_VAR 0 11
43301: PPUSH
43302: LD_VAR 0 11
43306: PUSH
43307: LD_INT 1
43309: PLUS
43310: PPUSH
43311: LD_VAR 0 9
43315: PUSH
43316: LD_VAR 0 3
43320: ARRAY
43321: PPUSH
43322: CALL_OW 2
43326: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43327: LD_ADDR_VAR 0 4
43331: PUSH
43332: LD_VAR 0 4
43336: PUSH
43337: LD_VAR 0 9
43341: PUSH
43342: LD_VAR 0 3
43346: ARRAY
43347: DIFF
43348: ST_TO_ADDR
// end ;
43349: GO 43258
43351: POP
43352: POP
// if p then
43353: LD_VAR 0 11
43357: IFFALSE 43382
// result := Replace ( result , 2 , p ) ;
43359: LD_ADDR_VAR 0 2
43363: PUSH
43364: LD_VAR 0 2
43368: PPUSH
43369: LD_INT 2
43371: PPUSH
43372: LD_VAR 0 11
43376: PPUSH
43377: CALL_OW 1
43381: ST_TO_ADDR
// end else
43382: GO 43428
// for i = eng downto 5 do
43384: LD_ADDR_VAR 0 3
43388: PUSH
43389: DOUBLE
43390: LD_VAR 0 6
43394: INC
43395: ST_TO_ADDR
43396: LD_INT 5
43398: PUSH
43399: FOR_DOWNTO
43400: IFFALSE 43426
// tmp := tmp union eng [ i ] ;
43402: LD_ADDR_VAR 0 4
43406: PUSH
43407: LD_VAR 0 4
43411: PUSH
43412: LD_VAR 0 6
43416: PUSH
43417: LD_VAR 0 3
43421: ARRAY
43422: UNION
43423: ST_TO_ADDR
43424: GO 43399
43426: POP
43427: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43428: LD_ADDR_VAR 0 2
43432: PUSH
43433: LD_VAR 0 2
43437: PPUSH
43438: LD_INT 1
43440: PPUSH
43441: LD_VAR 0 4
43445: PUSH
43446: LD_VAR 0 5
43450: DIFF
43451: PPUSH
43452: CALL_OW 1
43456: ST_TO_ADDR
// exit ;
43457: GO 43459
// end ; end ;
43459: LD_VAR 0 2
43463: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43464: LD_INT 0
43466: PPUSH
43467: PPUSH
43468: PPUSH
// if not mc_bases then
43469: LD_EXP 116
43473: NOT
43474: IFFALSE 43478
// exit ;
43476: GO 43584
// for i = 1 to mc_bases do
43478: LD_ADDR_VAR 0 2
43482: PUSH
43483: DOUBLE
43484: LD_INT 1
43486: DEC
43487: ST_TO_ADDR
43488: LD_EXP 116
43492: PUSH
43493: FOR_TO
43494: IFFALSE 43575
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43496: LD_ADDR_VAR 0 3
43500: PUSH
43501: LD_EXP 116
43505: PUSH
43506: LD_VAR 0 2
43510: ARRAY
43511: PPUSH
43512: LD_INT 21
43514: PUSH
43515: LD_INT 3
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 3
43524: PUSH
43525: LD_INT 24
43527: PUSH
43528: LD_INT 1000
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PPUSH
43543: CALL_OW 72
43547: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43548: LD_ADDR_EXP 117
43552: PUSH
43553: LD_EXP 117
43557: PPUSH
43558: LD_VAR 0 2
43562: PPUSH
43563: LD_VAR 0 3
43567: PPUSH
43568: CALL_OW 1
43572: ST_TO_ADDR
// end ;
43573: GO 43493
43575: POP
43576: POP
// RaiseSailEvent ( 101 ) ;
43577: LD_INT 101
43579: PPUSH
43580: CALL_OW 427
// end ;
43584: LD_VAR 0 1
43588: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43589: LD_INT 0
43591: PPUSH
43592: PPUSH
43593: PPUSH
43594: PPUSH
43595: PPUSH
43596: PPUSH
43597: PPUSH
// if not mc_bases then
43598: LD_EXP 116
43602: NOT
43603: IFFALSE 43607
// exit ;
43605: GO 44169
// for i = 1 to mc_bases do
43607: LD_ADDR_VAR 0 2
43611: PUSH
43612: DOUBLE
43613: LD_INT 1
43615: DEC
43616: ST_TO_ADDR
43617: LD_EXP 116
43621: PUSH
43622: FOR_TO
43623: IFFALSE 44160
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43625: LD_ADDR_VAR 0 5
43629: PUSH
43630: LD_EXP 116
43634: PUSH
43635: LD_VAR 0 2
43639: ARRAY
43640: PUSH
43641: LD_EXP 145
43645: PUSH
43646: LD_VAR 0 2
43650: ARRAY
43651: UNION
43652: PPUSH
43653: LD_INT 21
43655: PUSH
43656: LD_INT 1
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 1
43665: PUSH
43666: LD_INT 3
43668: PUSH
43669: LD_INT 54
43671: PUSH
43672: EMPTY
43673: LIST
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 3
43681: PUSH
43682: LD_INT 24
43684: PUSH
43685: LD_INT 1000
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: LIST
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PPUSH
43705: CALL_OW 72
43709: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43710: LD_ADDR_VAR 0 6
43714: PUSH
43715: LD_EXP 116
43719: PUSH
43720: LD_VAR 0 2
43724: ARRAY
43725: PPUSH
43726: LD_INT 21
43728: PUSH
43729: LD_INT 1
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 1
43738: PUSH
43739: LD_INT 3
43741: PUSH
43742: LD_INT 54
43744: PUSH
43745: EMPTY
43746: LIST
43747: PUSH
43748: EMPTY
43749: LIST
43750: LIST
43751: PUSH
43752: LD_INT 3
43754: PUSH
43755: LD_INT 24
43757: PUSH
43758: LD_INT 250
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: LIST
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PPUSH
43778: CALL_OW 72
43782: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43783: LD_ADDR_VAR 0 7
43787: PUSH
43788: LD_VAR 0 5
43792: PUSH
43793: LD_VAR 0 6
43797: DIFF
43798: ST_TO_ADDR
// if not need_heal_1 then
43799: LD_VAR 0 6
43803: NOT
43804: IFFALSE 43837
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43806: LD_ADDR_EXP 119
43810: PUSH
43811: LD_EXP 119
43815: PPUSH
43816: LD_VAR 0 2
43820: PUSH
43821: LD_INT 1
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: PPUSH
43828: EMPTY
43829: PPUSH
43830: CALL 70539 0 3
43834: ST_TO_ADDR
43835: GO 43907
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43837: LD_ADDR_EXP 119
43841: PUSH
43842: LD_EXP 119
43846: PPUSH
43847: LD_VAR 0 2
43851: PUSH
43852: LD_INT 1
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PPUSH
43859: LD_EXP 119
43863: PUSH
43864: LD_VAR 0 2
43868: ARRAY
43869: PUSH
43870: LD_INT 1
43872: ARRAY
43873: PPUSH
43874: LD_INT 3
43876: PUSH
43877: LD_INT 24
43879: PUSH
43880: LD_INT 1000
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PPUSH
43891: CALL_OW 72
43895: PUSH
43896: LD_VAR 0 6
43900: UNION
43901: PPUSH
43902: CALL 70539 0 3
43906: ST_TO_ADDR
// if not need_heal_2 then
43907: LD_VAR 0 7
43911: NOT
43912: IFFALSE 43945
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43914: LD_ADDR_EXP 119
43918: PUSH
43919: LD_EXP 119
43923: PPUSH
43924: LD_VAR 0 2
43928: PUSH
43929: LD_INT 2
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PPUSH
43936: EMPTY
43937: PPUSH
43938: CALL 70539 0 3
43942: ST_TO_ADDR
43943: GO 43977
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43945: LD_ADDR_EXP 119
43949: PUSH
43950: LD_EXP 119
43954: PPUSH
43955: LD_VAR 0 2
43959: PUSH
43960: LD_INT 2
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PPUSH
43967: LD_VAR 0 7
43971: PPUSH
43972: CALL 70539 0 3
43976: ST_TO_ADDR
// if need_heal_2 then
43977: LD_VAR 0 7
43981: IFFALSE 44142
// for j in need_heal_2 do
43983: LD_ADDR_VAR 0 3
43987: PUSH
43988: LD_VAR 0 7
43992: PUSH
43993: FOR_IN
43994: IFFALSE 44140
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43996: LD_ADDR_VAR 0 5
44000: PUSH
44001: LD_EXP 116
44005: PUSH
44006: LD_VAR 0 2
44010: ARRAY
44011: PPUSH
44012: LD_INT 2
44014: PUSH
44015: LD_INT 30
44017: PUSH
44018: LD_INT 6
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 30
44027: PUSH
44028: LD_INT 7
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 30
44037: PUSH
44038: LD_INT 8
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: PUSH
44045: LD_INT 30
44047: PUSH
44048: LD_INT 0
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: PUSH
44055: LD_INT 30
44057: PUSH
44058: LD_INT 1
44060: PUSH
44061: EMPTY
44062: LIST
44063: LIST
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: PPUSH
44073: CALL_OW 72
44077: ST_TO_ADDR
// if tmp then
44078: LD_VAR 0 5
44082: IFFALSE 44138
// begin k := NearestUnitToUnit ( tmp , j ) ;
44084: LD_ADDR_VAR 0 4
44088: PUSH
44089: LD_VAR 0 5
44093: PPUSH
44094: LD_VAR 0 3
44098: PPUSH
44099: CALL_OW 74
44103: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44104: LD_VAR 0 3
44108: PPUSH
44109: LD_VAR 0 4
44113: PPUSH
44114: CALL_OW 296
44118: PUSH
44119: LD_INT 5
44121: GREATER
44122: IFFALSE 44138
// ComMoveToNearbyEntrance ( j , k ) ;
44124: LD_VAR 0 3
44128: PPUSH
44129: LD_VAR 0 4
44133: PPUSH
44134: CALL 103158 0 2
// end ; end ;
44138: GO 43993
44140: POP
44141: POP
// if not need_heal_1 and not need_heal_2 then
44142: LD_VAR 0 6
44146: NOT
44147: PUSH
44148: LD_VAR 0 7
44152: NOT
44153: AND
44154: IFFALSE 44158
// continue ;
44156: GO 43622
// end ;
44158: GO 43622
44160: POP
44161: POP
// RaiseSailEvent ( 102 ) ;
44162: LD_INT 102
44164: PPUSH
44165: CALL_OW 427
// end ;
44169: LD_VAR 0 1
44173: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44174: LD_INT 0
44176: PPUSH
44177: PPUSH
44178: PPUSH
44179: PPUSH
44180: PPUSH
44181: PPUSH
44182: PPUSH
44183: PPUSH
// if not mc_bases then
44184: LD_EXP 116
44188: NOT
44189: IFFALSE 44193
// exit ;
44191: GO 45054
// for i = 1 to mc_bases do
44193: LD_ADDR_VAR 0 2
44197: PUSH
44198: DOUBLE
44199: LD_INT 1
44201: DEC
44202: ST_TO_ADDR
44203: LD_EXP 116
44207: PUSH
44208: FOR_TO
44209: IFFALSE 45052
// begin if not mc_building_need_repair [ i ] then
44211: LD_EXP 117
44215: PUSH
44216: LD_VAR 0 2
44220: ARRAY
44221: NOT
44222: IFFALSE 44409
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44224: LD_ADDR_VAR 0 6
44228: PUSH
44229: LD_EXP 135
44233: PUSH
44234: LD_VAR 0 2
44238: ARRAY
44239: PPUSH
44240: LD_INT 3
44242: PUSH
44243: LD_INT 24
44245: PUSH
44246: LD_INT 1000
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: LD_INT 2
44259: PUSH
44260: LD_INT 34
44262: PUSH
44263: LD_INT 13
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: LD_INT 34
44272: PUSH
44273: LD_INT 52
44275: PUSH
44276: EMPTY
44277: LIST
44278: LIST
44279: PUSH
44280: LD_INT 34
44282: PUSH
44283: LD_EXP 101
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PPUSH
44302: CALL_OW 72
44306: ST_TO_ADDR
// if cranes then
44307: LD_VAR 0 6
44311: IFFALSE 44373
// for j in cranes do
44313: LD_ADDR_VAR 0 3
44317: PUSH
44318: LD_VAR 0 6
44322: PUSH
44323: FOR_IN
44324: IFFALSE 44371
// if not IsInArea ( j , mc_parking [ i ] ) then
44326: LD_VAR 0 3
44330: PPUSH
44331: LD_EXP 140
44335: PUSH
44336: LD_VAR 0 2
44340: ARRAY
44341: PPUSH
44342: CALL_OW 308
44346: NOT
44347: IFFALSE 44369
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44349: LD_VAR 0 3
44353: PPUSH
44354: LD_EXP 140
44358: PUSH
44359: LD_VAR 0 2
44363: ARRAY
44364: PPUSH
44365: CALL_OW 113
44369: GO 44323
44371: POP
44372: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44373: LD_ADDR_EXP 118
44377: PUSH
44378: LD_EXP 118
44382: PPUSH
44383: LD_VAR 0 2
44387: PPUSH
44388: EMPTY
44389: PPUSH
44390: CALL_OW 1
44394: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44395: LD_VAR 0 2
44399: PPUSH
44400: LD_INT 101
44402: PPUSH
44403: CALL 39297 0 2
// continue ;
44407: GO 44208
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44409: LD_ADDR_EXP 122
44413: PUSH
44414: LD_EXP 122
44418: PPUSH
44419: LD_VAR 0 2
44423: PPUSH
44424: EMPTY
44425: PPUSH
44426: CALL_OW 1
44430: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44431: LD_VAR 0 2
44435: PPUSH
44436: LD_INT 103
44438: PPUSH
44439: CALL 39297 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44443: LD_ADDR_VAR 0 5
44447: PUSH
44448: LD_EXP 116
44452: PUSH
44453: LD_VAR 0 2
44457: ARRAY
44458: PUSH
44459: LD_EXP 145
44463: PUSH
44464: LD_VAR 0 2
44468: ARRAY
44469: UNION
44470: PPUSH
44471: LD_INT 2
44473: PUSH
44474: LD_INT 25
44476: PUSH
44477: LD_INT 2
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 25
44486: PUSH
44487: LD_INT 16
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: LIST
44498: PUSH
44499: EMPTY
44500: LIST
44501: PPUSH
44502: CALL_OW 72
44506: PUSH
44507: LD_EXP 119
44511: PUSH
44512: LD_VAR 0 2
44516: ARRAY
44517: PUSH
44518: LD_INT 1
44520: ARRAY
44521: PUSH
44522: LD_EXP 119
44526: PUSH
44527: LD_VAR 0 2
44531: ARRAY
44532: PUSH
44533: LD_INT 2
44535: ARRAY
44536: UNION
44537: DIFF
44538: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44539: LD_ADDR_VAR 0 6
44543: PUSH
44544: LD_EXP 135
44548: PUSH
44549: LD_VAR 0 2
44553: ARRAY
44554: PPUSH
44555: LD_INT 2
44557: PUSH
44558: LD_INT 34
44560: PUSH
44561: LD_INT 13
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 34
44570: PUSH
44571: LD_INT 52
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 34
44580: PUSH
44581: LD_EXP 101
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PUSH
44590: EMPTY
44591: LIST
44592: LIST
44593: LIST
44594: LIST
44595: PPUSH
44596: CALL_OW 72
44600: ST_TO_ADDR
// if cranes then
44601: LD_VAR 0 6
44605: IFFALSE 44741
// begin for j in cranes do
44607: LD_ADDR_VAR 0 3
44611: PUSH
44612: LD_VAR 0 6
44616: PUSH
44617: FOR_IN
44618: IFFALSE 44739
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44620: LD_VAR 0 3
44624: PPUSH
44625: CALL_OW 256
44629: PUSH
44630: LD_INT 1000
44632: EQUAL
44633: PUSH
44634: LD_VAR 0 3
44638: PPUSH
44639: CALL_OW 314
44643: NOT
44644: AND
44645: IFFALSE 44679
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44647: LD_VAR 0 3
44651: PPUSH
44652: LD_EXP 117
44656: PUSH
44657: LD_VAR 0 2
44661: ARRAY
44662: PPUSH
44663: LD_VAR 0 3
44667: PPUSH
44668: CALL_OW 74
44672: PPUSH
44673: CALL_OW 130
44677: GO 44737
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44679: LD_VAR 0 3
44683: PPUSH
44684: CALL_OW 256
44688: PUSH
44689: LD_INT 500
44691: LESS
44692: PUSH
44693: LD_VAR 0 3
44697: PPUSH
44698: LD_EXP 140
44702: PUSH
44703: LD_VAR 0 2
44707: ARRAY
44708: PPUSH
44709: CALL_OW 308
44713: NOT
44714: AND
44715: IFFALSE 44737
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44717: LD_VAR 0 3
44721: PPUSH
44722: LD_EXP 140
44726: PUSH
44727: LD_VAR 0 2
44731: ARRAY
44732: PPUSH
44733: CALL_OW 113
// end ;
44737: GO 44617
44739: POP
44740: POP
// end ; if tmp > 3 then
44741: LD_VAR 0 5
44745: PUSH
44746: LD_INT 3
44748: GREATER
44749: IFFALSE 44769
// tmp := ShrinkArray ( tmp , 4 ) ;
44751: LD_ADDR_VAR 0 5
44755: PUSH
44756: LD_VAR 0 5
44760: PPUSH
44761: LD_INT 4
44763: PPUSH
44764: CALL 102606 0 2
44768: ST_TO_ADDR
// if not tmp then
44769: LD_VAR 0 5
44773: NOT
44774: IFFALSE 44778
// continue ;
44776: GO 44208
// for j in tmp do
44778: LD_ADDR_VAR 0 3
44782: PUSH
44783: LD_VAR 0 5
44787: PUSH
44788: FOR_IN
44789: IFFALSE 45048
// begin if IsInUnit ( j ) then
44791: LD_VAR 0 3
44795: PPUSH
44796: CALL_OW 310
44800: IFFALSE 44811
// ComExitBuilding ( j ) ;
44802: LD_VAR 0 3
44806: PPUSH
44807: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44811: LD_VAR 0 3
44815: PUSH
44816: LD_EXP 118
44820: PUSH
44821: LD_VAR 0 2
44825: ARRAY
44826: IN
44827: NOT
44828: IFFALSE 44886
// begin SetTag ( j , 101 ) ;
44830: LD_VAR 0 3
44834: PPUSH
44835: LD_INT 101
44837: PPUSH
44838: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44842: LD_ADDR_EXP 118
44846: PUSH
44847: LD_EXP 118
44851: PPUSH
44852: LD_VAR 0 2
44856: PUSH
44857: LD_EXP 118
44861: PUSH
44862: LD_VAR 0 2
44866: ARRAY
44867: PUSH
44868: LD_INT 1
44870: PLUS
44871: PUSH
44872: EMPTY
44873: LIST
44874: LIST
44875: PPUSH
44876: LD_VAR 0 3
44880: PPUSH
44881: CALL 70539 0 3
44885: ST_TO_ADDR
// end ; wait ( 1 ) ;
44886: LD_INT 1
44888: PPUSH
44889: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44893: LD_ADDR_VAR 0 7
44897: PUSH
44898: LD_EXP 117
44902: PUSH
44903: LD_VAR 0 2
44907: ARRAY
44908: ST_TO_ADDR
// if mc_scan [ i ] then
44909: LD_EXP 139
44913: PUSH
44914: LD_VAR 0 2
44918: ARRAY
44919: IFFALSE 44981
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44921: LD_ADDR_VAR 0 7
44925: PUSH
44926: LD_EXP 117
44930: PUSH
44931: LD_VAR 0 2
44935: ARRAY
44936: PPUSH
44937: LD_INT 3
44939: PUSH
44940: LD_INT 30
44942: PUSH
44943: LD_INT 32
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 30
44952: PUSH
44953: LD_INT 33
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PUSH
44960: LD_INT 30
44962: PUSH
44963: LD_INT 31
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: EMPTY
44971: LIST
44972: LIST
44973: LIST
44974: LIST
44975: PPUSH
44976: CALL_OW 72
44980: ST_TO_ADDR
// if not to_repair_tmp then
44981: LD_VAR 0 7
44985: NOT
44986: IFFALSE 44990
// continue ;
44988: GO 44788
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44990: LD_ADDR_VAR 0 8
44994: PUSH
44995: LD_VAR 0 7
44999: PPUSH
45000: LD_VAR 0 3
45004: PPUSH
45005: CALL_OW 74
45009: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45010: LD_VAR 0 8
45014: PPUSH
45015: LD_INT 16
45017: PPUSH
45018: CALL 73138 0 2
45022: PUSH
45023: LD_INT 4
45025: ARRAY
45026: PUSH
45027: LD_INT 10
45029: LESS
45030: IFFALSE 45046
// ComRepairBuilding ( j , to_repair ) ;
45032: LD_VAR 0 3
45036: PPUSH
45037: LD_VAR 0 8
45041: PPUSH
45042: CALL_OW 130
// end ;
45046: GO 44788
45048: POP
45049: POP
// end ;
45050: GO 44208
45052: POP
45053: POP
// end ;
45054: LD_VAR 0 1
45058: RET
// export function MC_Heal ; var i , j , tmp ; begin
45059: LD_INT 0
45061: PPUSH
45062: PPUSH
45063: PPUSH
45064: PPUSH
// if not mc_bases then
45065: LD_EXP 116
45069: NOT
45070: IFFALSE 45074
// exit ;
45072: GO 45476
// for i = 1 to mc_bases do
45074: LD_ADDR_VAR 0 2
45078: PUSH
45079: DOUBLE
45080: LD_INT 1
45082: DEC
45083: ST_TO_ADDR
45084: LD_EXP 116
45088: PUSH
45089: FOR_TO
45090: IFFALSE 45474
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45092: LD_EXP 119
45096: PUSH
45097: LD_VAR 0 2
45101: ARRAY
45102: PUSH
45103: LD_INT 1
45105: ARRAY
45106: NOT
45107: PUSH
45108: LD_EXP 119
45112: PUSH
45113: LD_VAR 0 2
45117: ARRAY
45118: PUSH
45119: LD_INT 2
45121: ARRAY
45122: NOT
45123: AND
45124: IFFALSE 45162
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45126: LD_ADDR_EXP 120
45130: PUSH
45131: LD_EXP 120
45135: PPUSH
45136: LD_VAR 0 2
45140: PPUSH
45141: EMPTY
45142: PPUSH
45143: CALL_OW 1
45147: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45148: LD_VAR 0 2
45152: PPUSH
45153: LD_INT 102
45155: PPUSH
45156: CALL 39297 0 2
// continue ;
45160: GO 45089
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45162: LD_ADDR_VAR 0 4
45166: PUSH
45167: LD_EXP 116
45171: PUSH
45172: LD_VAR 0 2
45176: ARRAY
45177: PPUSH
45178: LD_INT 25
45180: PUSH
45181: LD_INT 4
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PPUSH
45188: CALL_OW 72
45192: ST_TO_ADDR
// if not tmp then
45193: LD_VAR 0 4
45197: NOT
45198: IFFALSE 45202
// continue ;
45200: GO 45089
// if mc_taming [ i ] then
45202: LD_EXP 147
45206: PUSH
45207: LD_VAR 0 2
45211: ARRAY
45212: IFFALSE 45236
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45214: LD_ADDR_EXP 147
45218: PUSH
45219: LD_EXP 147
45223: PPUSH
45224: LD_VAR 0 2
45228: PPUSH
45229: EMPTY
45230: PPUSH
45231: CALL_OW 1
45235: ST_TO_ADDR
// for j in tmp do
45236: LD_ADDR_VAR 0 3
45240: PUSH
45241: LD_VAR 0 4
45245: PUSH
45246: FOR_IN
45247: IFFALSE 45470
// begin if IsInUnit ( j ) then
45249: LD_VAR 0 3
45253: PPUSH
45254: CALL_OW 310
45258: IFFALSE 45269
// ComExitBuilding ( j ) ;
45260: LD_VAR 0 3
45264: PPUSH
45265: CALL_OW 122
// if not j in mc_healers [ i ] then
45269: LD_VAR 0 3
45273: PUSH
45274: LD_EXP 120
45278: PUSH
45279: LD_VAR 0 2
45283: ARRAY
45284: IN
45285: NOT
45286: IFFALSE 45332
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45288: LD_ADDR_EXP 120
45292: PUSH
45293: LD_EXP 120
45297: PPUSH
45298: LD_VAR 0 2
45302: PUSH
45303: LD_EXP 120
45307: PUSH
45308: LD_VAR 0 2
45312: ARRAY
45313: PUSH
45314: LD_INT 1
45316: PLUS
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PPUSH
45322: LD_VAR 0 3
45326: PPUSH
45327: CALL 70539 0 3
45331: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45332: LD_VAR 0 3
45336: PPUSH
45337: CALL_OW 110
45341: PUSH
45342: LD_INT 102
45344: NONEQUAL
45345: IFFALSE 45359
// SetTag ( j , 102 ) ;
45347: LD_VAR 0 3
45351: PPUSH
45352: LD_INT 102
45354: PPUSH
45355: CALL_OW 109
// Wait ( 3 ) ;
45359: LD_INT 3
45361: PPUSH
45362: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45366: LD_EXP 119
45370: PUSH
45371: LD_VAR 0 2
45375: ARRAY
45376: PUSH
45377: LD_INT 1
45379: ARRAY
45380: IFFALSE 45412
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45382: LD_VAR 0 3
45386: PPUSH
45387: LD_EXP 119
45391: PUSH
45392: LD_VAR 0 2
45396: ARRAY
45397: PUSH
45398: LD_INT 1
45400: ARRAY
45401: PUSH
45402: LD_INT 1
45404: ARRAY
45405: PPUSH
45406: CALL_OW 128
45410: GO 45468
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45412: LD_VAR 0 3
45416: PPUSH
45417: CALL_OW 314
45421: NOT
45422: PUSH
45423: LD_EXP 119
45427: PUSH
45428: LD_VAR 0 2
45432: ARRAY
45433: PUSH
45434: LD_INT 2
45436: ARRAY
45437: AND
45438: IFFALSE 45468
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45440: LD_VAR 0 3
45444: PPUSH
45445: LD_EXP 119
45449: PUSH
45450: LD_VAR 0 2
45454: ARRAY
45455: PUSH
45456: LD_INT 2
45458: ARRAY
45459: PUSH
45460: LD_INT 1
45462: ARRAY
45463: PPUSH
45464: CALL_OW 128
// end ;
45468: GO 45246
45470: POP
45471: POP
// end ;
45472: GO 45089
45474: POP
45475: POP
// end ;
45476: LD_VAR 0 1
45480: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45481: LD_INT 0
45483: PPUSH
45484: PPUSH
45485: PPUSH
45486: PPUSH
45487: PPUSH
// if not mc_bases then
45488: LD_EXP 116
45492: NOT
45493: IFFALSE 45497
// exit ;
45495: GO 46668
// for i = 1 to mc_bases do
45497: LD_ADDR_VAR 0 2
45501: PUSH
45502: DOUBLE
45503: LD_INT 1
45505: DEC
45506: ST_TO_ADDR
45507: LD_EXP 116
45511: PUSH
45512: FOR_TO
45513: IFFALSE 46666
// begin if mc_scan [ i ] then
45515: LD_EXP 139
45519: PUSH
45520: LD_VAR 0 2
45524: ARRAY
45525: IFFALSE 45529
// continue ;
45527: GO 45512
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45529: LD_EXP 121
45533: PUSH
45534: LD_VAR 0 2
45538: ARRAY
45539: NOT
45540: PUSH
45541: LD_EXP 123
45545: PUSH
45546: LD_VAR 0 2
45550: ARRAY
45551: NOT
45552: AND
45553: PUSH
45554: LD_EXP 122
45558: PUSH
45559: LD_VAR 0 2
45563: ARRAY
45564: AND
45565: IFFALSE 45603
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45567: LD_ADDR_EXP 122
45571: PUSH
45572: LD_EXP 122
45576: PPUSH
45577: LD_VAR 0 2
45581: PPUSH
45582: EMPTY
45583: PPUSH
45584: CALL_OW 1
45588: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45589: LD_VAR 0 2
45593: PPUSH
45594: LD_INT 103
45596: PPUSH
45597: CALL 39297 0 2
// continue ;
45601: GO 45512
// end ; if mc_construct_list [ i ] then
45603: LD_EXP 123
45607: PUSH
45608: LD_VAR 0 2
45612: ARRAY
45613: IFFALSE 45833
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45615: LD_ADDR_VAR 0 4
45619: PUSH
45620: LD_EXP 116
45624: PUSH
45625: LD_VAR 0 2
45629: ARRAY
45630: PPUSH
45631: LD_INT 25
45633: PUSH
45634: LD_INT 2
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PPUSH
45641: CALL_OW 72
45645: PUSH
45646: LD_EXP 118
45650: PUSH
45651: LD_VAR 0 2
45655: ARRAY
45656: DIFF
45657: ST_TO_ADDR
// if not tmp then
45658: LD_VAR 0 4
45662: NOT
45663: IFFALSE 45667
// continue ;
45665: GO 45512
// for j in tmp do
45667: LD_ADDR_VAR 0 3
45671: PUSH
45672: LD_VAR 0 4
45676: PUSH
45677: FOR_IN
45678: IFFALSE 45829
// begin if not mc_builders [ i ] then
45680: LD_EXP 122
45684: PUSH
45685: LD_VAR 0 2
45689: ARRAY
45690: NOT
45691: IFFALSE 45749
// begin SetTag ( j , 103 ) ;
45693: LD_VAR 0 3
45697: PPUSH
45698: LD_INT 103
45700: PPUSH
45701: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45705: LD_ADDR_EXP 122
45709: PUSH
45710: LD_EXP 122
45714: PPUSH
45715: LD_VAR 0 2
45719: PUSH
45720: LD_EXP 122
45724: PUSH
45725: LD_VAR 0 2
45729: ARRAY
45730: PUSH
45731: LD_INT 1
45733: PLUS
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PPUSH
45739: LD_VAR 0 3
45743: PPUSH
45744: CALL 70539 0 3
45748: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45749: LD_VAR 0 3
45753: PPUSH
45754: CALL_OW 310
45758: IFFALSE 45769
// ComExitBuilding ( j ) ;
45760: LD_VAR 0 3
45764: PPUSH
45765: CALL_OW 122
// wait ( 3 ) ;
45769: LD_INT 3
45771: PPUSH
45772: CALL_OW 67
// if not mc_construct_list [ i ] then
45776: LD_EXP 123
45780: PUSH
45781: LD_VAR 0 2
45785: ARRAY
45786: NOT
45787: IFFALSE 45791
// break ;
45789: GO 45829
// if not HasTask ( j ) then
45791: LD_VAR 0 3
45795: PPUSH
45796: CALL_OW 314
45800: NOT
45801: IFFALSE 45827
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45803: LD_VAR 0 3
45807: PPUSH
45808: LD_EXP 123
45812: PUSH
45813: LD_VAR 0 2
45817: ARRAY
45818: PUSH
45819: LD_INT 1
45821: ARRAY
45822: PPUSH
45823: CALL 73402 0 2
// end ;
45827: GO 45677
45829: POP
45830: POP
// end else
45831: GO 46664
// if mc_build_list [ i ] then
45833: LD_EXP 121
45837: PUSH
45838: LD_VAR 0 2
45842: ARRAY
45843: IFFALSE 46664
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45845: LD_ADDR_VAR 0 5
45849: PUSH
45850: LD_EXP 116
45854: PUSH
45855: LD_VAR 0 2
45859: ARRAY
45860: PPUSH
45861: LD_INT 2
45863: PUSH
45864: LD_INT 30
45866: PUSH
45867: LD_INT 0
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 30
45876: PUSH
45877: LD_INT 1
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: LIST
45888: PPUSH
45889: CALL_OW 72
45893: ST_TO_ADDR
// if depot then
45894: LD_VAR 0 5
45898: IFFALSE 45916
// depot := depot [ 1 ] else
45900: LD_ADDR_VAR 0 5
45904: PUSH
45905: LD_VAR 0 5
45909: PUSH
45910: LD_INT 1
45912: ARRAY
45913: ST_TO_ADDR
45914: GO 45924
// depot := 0 ;
45916: LD_ADDR_VAR 0 5
45920: PUSH
45921: LD_INT 0
45923: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45924: LD_EXP 121
45928: PUSH
45929: LD_VAR 0 2
45933: ARRAY
45934: PUSH
45935: LD_INT 1
45937: ARRAY
45938: PUSH
45939: LD_INT 1
45941: ARRAY
45942: PPUSH
45943: CALL 73226 0 1
45947: PUSH
45948: LD_EXP 116
45952: PUSH
45953: LD_VAR 0 2
45957: ARRAY
45958: PPUSH
45959: LD_INT 2
45961: PUSH
45962: LD_INT 30
45964: PUSH
45965: LD_INT 2
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: LD_INT 30
45974: PUSH
45975: LD_INT 3
45977: PUSH
45978: EMPTY
45979: LIST
45980: LIST
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: LIST
45986: PPUSH
45987: CALL_OW 72
45991: NOT
45992: AND
45993: IFFALSE 46098
// begin for j = 1 to mc_build_list [ i ] do
45995: LD_ADDR_VAR 0 3
45999: PUSH
46000: DOUBLE
46001: LD_INT 1
46003: DEC
46004: ST_TO_ADDR
46005: LD_EXP 121
46009: PUSH
46010: LD_VAR 0 2
46014: ARRAY
46015: PUSH
46016: FOR_TO
46017: IFFALSE 46096
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46019: LD_EXP 121
46023: PUSH
46024: LD_VAR 0 2
46028: ARRAY
46029: PUSH
46030: LD_VAR 0 3
46034: ARRAY
46035: PUSH
46036: LD_INT 1
46038: ARRAY
46039: PUSH
46040: LD_INT 2
46042: EQUAL
46043: IFFALSE 46094
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46045: LD_ADDR_EXP 121
46049: PUSH
46050: LD_EXP 121
46054: PPUSH
46055: LD_VAR 0 2
46059: PPUSH
46060: LD_EXP 121
46064: PUSH
46065: LD_VAR 0 2
46069: ARRAY
46070: PPUSH
46071: LD_VAR 0 3
46075: PPUSH
46076: LD_INT 1
46078: PPUSH
46079: LD_INT 0
46081: PPUSH
46082: CALL 69957 0 4
46086: PPUSH
46087: CALL_OW 1
46091: ST_TO_ADDR
// break ;
46092: GO 46096
// end ;
46094: GO 46016
46096: POP
46097: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46098: LD_EXP 121
46102: PUSH
46103: LD_VAR 0 2
46107: ARRAY
46108: PUSH
46109: LD_INT 1
46111: ARRAY
46112: PUSH
46113: LD_INT 1
46115: ARRAY
46116: PUSH
46117: LD_INT 0
46119: EQUAL
46120: PUSH
46121: LD_VAR 0 5
46125: PUSH
46126: LD_VAR 0 5
46130: PPUSH
46131: LD_EXP 121
46135: PUSH
46136: LD_VAR 0 2
46140: ARRAY
46141: PUSH
46142: LD_INT 1
46144: ARRAY
46145: PUSH
46146: LD_INT 1
46148: ARRAY
46149: PPUSH
46150: LD_EXP 121
46154: PUSH
46155: LD_VAR 0 2
46159: ARRAY
46160: PUSH
46161: LD_INT 1
46163: ARRAY
46164: PUSH
46165: LD_INT 2
46167: ARRAY
46168: PPUSH
46169: LD_EXP 121
46173: PUSH
46174: LD_VAR 0 2
46178: ARRAY
46179: PUSH
46180: LD_INT 1
46182: ARRAY
46183: PUSH
46184: LD_INT 3
46186: ARRAY
46187: PPUSH
46188: LD_EXP 121
46192: PUSH
46193: LD_VAR 0 2
46197: ARRAY
46198: PUSH
46199: LD_INT 1
46201: ARRAY
46202: PUSH
46203: LD_INT 4
46205: ARRAY
46206: PPUSH
46207: CALL 78643 0 5
46211: AND
46212: OR
46213: IFFALSE 46494
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46215: LD_ADDR_VAR 0 4
46219: PUSH
46220: LD_EXP 116
46224: PUSH
46225: LD_VAR 0 2
46229: ARRAY
46230: PPUSH
46231: LD_INT 25
46233: PUSH
46234: LD_INT 2
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PPUSH
46241: CALL_OW 72
46245: PUSH
46246: LD_EXP 118
46250: PUSH
46251: LD_VAR 0 2
46255: ARRAY
46256: DIFF
46257: ST_TO_ADDR
// if not tmp then
46258: LD_VAR 0 4
46262: NOT
46263: IFFALSE 46267
// continue ;
46265: GO 45512
// for j in tmp do
46267: LD_ADDR_VAR 0 3
46271: PUSH
46272: LD_VAR 0 4
46276: PUSH
46277: FOR_IN
46278: IFFALSE 46490
// begin if not mc_builders [ i ] then
46280: LD_EXP 122
46284: PUSH
46285: LD_VAR 0 2
46289: ARRAY
46290: NOT
46291: IFFALSE 46349
// begin SetTag ( j , 103 ) ;
46293: LD_VAR 0 3
46297: PPUSH
46298: LD_INT 103
46300: PPUSH
46301: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46305: LD_ADDR_EXP 122
46309: PUSH
46310: LD_EXP 122
46314: PPUSH
46315: LD_VAR 0 2
46319: PUSH
46320: LD_EXP 122
46324: PUSH
46325: LD_VAR 0 2
46329: ARRAY
46330: PUSH
46331: LD_INT 1
46333: PLUS
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PPUSH
46339: LD_VAR 0 3
46343: PPUSH
46344: CALL 70539 0 3
46348: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46349: LD_VAR 0 3
46353: PPUSH
46354: CALL_OW 310
46358: IFFALSE 46369
// ComExitBuilding ( j ) ;
46360: LD_VAR 0 3
46364: PPUSH
46365: CALL_OW 122
// wait ( 3 ) ;
46369: LD_INT 3
46371: PPUSH
46372: CALL_OW 67
// if not mc_build_list [ i ] then
46376: LD_EXP 121
46380: PUSH
46381: LD_VAR 0 2
46385: ARRAY
46386: NOT
46387: IFFALSE 46391
// break ;
46389: GO 46490
// if not HasTask ( j ) then
46391: LD_VAR 0 3
46395: PPUSH
46396: CALL_OW 314
46400: NOT
46401: IFFALSE 46488
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46403: LD_VAR 0 3
46407: PPUSH
46408: LD_EXP 121
46412: PUSH
46413: LD_VAR 0 2
46417: ARRAY
46418: PUSH
46419: LD_INT 1
46421: ARRAY
46422: PUSH
46423: LD_INT 1
46425: ARRAY
46426: PPUSH
46427: LD_EXP 121
46431: PUSH
46432: LD_VAR 0 2
46436: ARRAY
46437: PUSH
46438: LD_INT 1
46440: ARRAY
46441: PUSH
46442: LD_INT 2
46444: ARRAY
46445: PPUSH
46446: LD_EXP 121
46450: PUSH
46451: LD_VAR 0 2
46455: ARRAY
46456: PUSH
46457: LD_INT 1
46459: ARRAY
46460: PUSH
46461: LD_INT 3
46463: ARRAY
46464: PPUSH
46465: LD_EXP 121
46469: PUSH
46470: LD_VAR 0 2
46474: ARRAY
46475: PUSH
46476: LD_INT 1
46478: ARRAY
46479: PUSH
46480: LD_INT 4
46482: ARRAY
46483: PPUSH
46484: CALL_OW 145
// end ;
46488: GO 46277
46490: POP
46491: POP
// end else
46492: GO 46664
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46494: LD_EXP 116
46498: PUSH
46499: LD_VAR 0 2
46503: ARRAY
46504: PPUSH
46505: LD_EXP 121
46509: PUSH
46510: LD_VAR 0 2
46514: ARRAY
46515: PUSH
46516: LD_INT 1
46518: ARRAY
46519: PUSH
46520: LD_INT 1
46522: ARRAY
46523: PPUSH
46524: LD_EXP 121
46528: PUSH
46529: LD_VAR 0 2
46533: ARRAY
46534: PUSH
46535: LD_INT 1
46537: ARRAY
46538: PUSH
46539: LD_INT 2
46541: ARRAY
46542: PPUSH
46543: LD_EXP 121
46547: PUSH
46548: LD_VAR 0 2
46552: ARRAY
46553: PUSH
46554: LD_INT 1
46556: ARRAY
46557: PUSH
46558: LD_INT 3
46560: ARRAY
46561: PPUSH
46562: LD_EXP 121
46566: PUSH
46567: LD_VAR 0 2
46571: ARRAY
46572: PUSH
46573: LD_INT 1
46575: ARRAY
46576: PUSH
46577: LD_INT 4
46579: ARRAY
46580: PPUSH
46581: LD_EXP 116
46585: PUSH
46586: LD_VAR 0 2
46590: ARRAY
46591: PPUSH
46592: LD_INT 21
46594: PUSH
46595: LD_INT 3
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: PPUSH
46602: CALL_OW 72
46606: PPUSH
46607: EMPTY
46608: PPUSH
46609: CALL 77393 0 7
46613: NOT
46614: IFFALSE 46664
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46616: LD_ADDR_EXP 121
46620: PUSH
46621: LD_EXP 121
46625: PPUSH
46626: LD_VAR 0 2
46630: PPUSH
46631: LD_EXP 121
46635: PUSH
46636: LD_VAR 0 2
46640: ARRAY
46641: PPUSH
46642: LD_INT 1
46644: PPUSH
46645: LD_INT 1
46647: NEG
46648: PPUSH
46649: LD_INT 0
46651: PPUSH
46652: CALL 69957 0 4
46656: PPUSH
46657: CALL_OW 1
46661: ST_TO_ADDR
// continue ;
46662: GO 45512
// end ; end ; end ;
46664: GO 45512
46666: POP
46667: POP
// end ;
46668: LD_VAR 0 1
46672: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46673: LD_INT 0
46675: PPUSH
46676: PPUSH
46677: PPUSH
46678: PPUSH
46679: PPUSH
46680: PPUSH
// if not mc_bases then
46681: LD_EXP 116
46685: NOT
46686: IFFALSE 46690
// exit ;
46688: GO 47117
// for i = 1 to mc_bases do
46690: LD_ADDR_VAR 0 2
46694: PUSH
46695: DOUBLE
46696: LD_INT 1
46698: DEC
46699: ST_TO_ADDR
46700: LD_EXP 116
46704: PUSH
46705: FOR_TO
46706: IFFALSE 47115
// begin tmp := mc_build_upgrade [ i ] ;
46708: LD_ADDR_VAR 0 4
46712: PUSH
46713: LD_EXP 148
46717: PUSH
46718: LD_VAR 0 2
46722: ARRAY
46723: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46724: LD_ADDR_VAR 0 6
46728: PUSH
46729: LD_EXP 149
46733: PUSH
46734: LD_VAR 0 2
46738: ARRAY
46739: PPUSH
46740: LD_INT 2
46742: PUSH
46743: LD_INT 30
46745: PUSH
46746: LD_INT 6
46748: PUSH
46749: EMPTY
46750: LIST
46751: LIST
46752: PUSH
46753: LD_INT 30
46755: PUSH
46756: LD_INT 7
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: PUSH
46763: EMPTY
46764: LIST
46765: LIST
46766: LIST
46767: PPUSH
46768: CALL_OW 72
46772: ST_TO_ADDR
// if not tmp and not lab then
46773: LD_VAR 0 4
46777: NOT
46778: PUSH
46779: LD_VAR 0 6
46783: NOT
46784: AND
46785: IFFALSE 46789
// continue ;
46787: GO 46705
// if tmp then
46789: LD_VAR 0 4
46793: IFFALSE 46913
// for j in tmp do
46795: LD_ADDR_VAR 0 3
46799: PUSH
46800: LD_VAR 0 4
46804: PUSH
46805: FOR_IN
46806: IFFALSE 46911
// begin if UpgradeCost ( j ) then
46808: LD_VAR 0 3
46812: PPUSH
46813: CALL 77053 0 1
46817: IFFALSE 46909
// begin ComUpgrade ( j ) ;
46819: LD_VAR 0 3
46823: PPUSH
46824: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46828: LD_ADDR_EXP 148
46832: PUSH
46833: LD_EXP 148
46837: PPUSH
46838: LD_VAR 0 2
46842: PPUSH
46843: LD_EXP 148
46847: PUSH
46848: LD_VAR 0 2
46852: ARRAY
46853: PUSH
46854: LD_VAR 0 3
46858: DIFF
46859: PPUSH
46860: CALL_OW 1
46864: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46865: LD_ADDR_EXP 123
46869: PUSH
46870: LD_EXP 123
46874: PPUSH
46875: LD_VAR 0 2
46879: PUSH
46880: LD_EXP 123
46884: PUSH
46885: LD_VAR 0 2
46889: ARRAY
46890: PUSH
46891: LD_INT 1
46893: PLUS
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: PPUSH
46899: LD_VAR 0 3
46903: PPUSH
46904: CALL 70539 0 3
46908: ST_TO_ADDR
// end ; end ;
46909: GO 46805
46911: POP
46912: POP
// if not lab or not mc_lab_upgrade [ i ] then
46913: LD_VAR 0 6
46917: NOT
46918: PUSH
46919: LD_EXP 150
46923: PUSH
46924: LD_VAR 0 2
46928: ARRAY
46929: NOT
46930: OR
46931: IFFALSE 46935
// continue ;
46933: GO 46705
// for j in lab do
46935: LD_ADDR_VAR 0 3
46939: PUSH
46940: LD_VAR 0 6
46944: PUSH
46945: FOR_IN
46946: IFFALSE 47111
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46948: LD_VAR 0 3
46952: PPUSH
46953: CALL_OW 266
46957: PUSH
46958: LD_INT 6
46960: PUSH
46961: LD_INT 7
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: IN
46968: PUSH
46969: LD_VAR 0 3
46973: PPUSH
46974: CALL_OW 461
46978: PUSH
46979: LD_INT 1
46981: NONEQUAL
46982: AND
46983: IFFALSE 47109
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46985: LD_VAR 0 3
46989: PPUSH
46990: LD_EXP 150
46994: PUSH
46995: LD_VAR 0 2
46999: ARRAY
47000: PUSH
47001: LD_INT 1
47003: ARRAY
47004: PPUSH
47005: CALL 77258 0 2
47009: IFFALSE 47109
// begin ComCancel ( j ) ;
47011: LD_VAR 0 3
47015: PPUSH
47016: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47020: LD_VAR 0 3
47024: PPUSH
47025: LD_EXP 150
47029: PUSH
47030: LD_VAR 0 2
47034: ARRAY
47035: PUSH
47036: LD_INT 1
47038: ARRAY
47039: PPUSH
47040: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47044: LD_VAR 0 3
47048: PUSH
47049: LD_EXP 123
47053: PUSH
47054: LD_VAR 0 2
47058: ARRAY
47059: IN
47060: NOT
47061: IFFALSE 47107
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47063: LD_ADDR_EXP 123
47067: PUSH
47068: LD_EXP 123
47072: PPUSH
47073: LD_VAR 0 2
47077: PUSH
47078: LD_EXP 123
47082: PUSH
47083: LD_VAR 0 2
47087: ARRAY
47088: PUSH
47089: LD_INT 1
47091: PLUS
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PPUSH
47097: LD_VAR 0 3
47101: PPUSH
47102: CALL 70539 0 3
47106: ST_TO_ADDR
// break ;
47107: GO 47111
// end ; end ; end ;
47109: GO 46945
47111: POP
47112: POP
// end ;
47113: GO 46705
47115: POP
47116: POP
// end ;
47117: LD_VAR 0 1
47121: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47122: LD_INT 0
47124: PPUSH
47125: PPUSH
47126: PPUSH
47127: PPUSH
47128: PPUSH
47129: PPUSH
47130: PPUSH
47131: PPUSH
47132: PPUSH
// if not mc_bases then
47133: LD_EXP 116
47137: NOT
47138: IFFALSE 47142
// exit ;
47140: GO 47547
// for i = 1 to mc_bases do
47142: LD_ADDR_VAR 0 2
47146: PUSH
47147: DOUBLE
47148: LD_INT 1
47150: DEC
47151: ST_TO_ADDR
47152: LD_EXP 116
47156: PUSH
47157: FOR_TO
47158: IFFALSE 47545
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47160: LD_EXP 124
47164: PUSH
47165: LD_VAR 0 2
47169: ARRAY
47170: NOT
47171: PUSH
47172: LD_EXP 116
47176: PUSH
47177: LD_VAR 0 2
47181: ARRAY
47182: PPUSH
47183: LD_INT 30
47185: PUSH
47186: LD_INT 3
47188: PUSH
47189: EMPTY
47190: LIST
47191: LIST
47192: PPUSH
47193: CALL_OW 72
47197: NOT
47198: OR
47199: IFFALSE 47203
// continue ;
47201: GO 47157
// busy := false ;
47203: LD_ADDR_VAR 0 8
47207: PUSH
47208: LD_INT 0
47210: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47211: LD_ADDR_VAR 0 4
47215: PUSH
47216: LD_EXP 116
47220: PUSH
47221: LD_VAR 0 2
47225: ARRAY
47226: PPUSH
47227: LD_INT 30
47229: PUSH
47230: LD_INT 3
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: PPUSH
47237: CALL_OW 72
47241: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47242: LD_ADDR_VAR 0 6
47246: PUSH
47247: LD_EXP 124
47251: PUSH
47252: LD_VAR 0 2
47256: ARRAY
47257: PPUSH
47258: LD_INT 2
47260: PUSH
47261: LD_INT 30
47263: PUSH
47264: LD_INT 32
47266: PUSH
47267: EMPTY
47268: LIST
47269: LIST
47270: PUSH
47271: LD_INT 30
47273: PUSH
47274: LD_INT 33
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: PUSH
47281: EMPTY
47282: LIST
47283: LIST
47284: LIST
47285: PPUSH
47286: CALL_OW 72
47290: ST_TO_ADDR
// if not t then
47291: LD_VAR 0 6
47295: NOT
47296: IFFALSE 47300
// continue ;
47298: GO 47157
// for j in tmp do
47300: LD_ADDR_VAR 0 3
47304: PUSH
47305: LD_VAR 0 4
47309: PUSH
47310: FOR_IN
47311: IFFALSE 47341
// if not BuildingStatus ( j ) = bs_idle then
47313: LD_VAR 0 3
47317: PPUSH
47318: CALL_OW 461
47322: PUSH
47323: LD_INT 2
47325: EQUAL
47326: NOT
47327: IFFALSE 47339
// begin busy := true ;
47329: LD_ADDR_VAR 0 8
47333: PUSH
47334: LD_INT 1
47336: ST_TO_ADDR
// break ;
47337: GO 47341
// end ;
47339: GO 47310
47341: POP
47342: POP
// if busy then
47343: LD_VAR 0 8
47347: IFFALSE 47351
// continue ;
47349: GO 47157
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47351: LD_ADDR_VAR 0 7
47355: PUSH
47356: LD_VAR 0 6
47360: PPUSH
47361: LD_INT 35
47363: PUSH
47364: LD_INT 0
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: PPUSH
47371: CALL_OW 72
47375: ST_TO_ADDR
// if tw then
47376: LD_VAR 0 7
47380: IFFALSE 47457
// begin tw := tw [ 1 ] ;
47382: LD_ADDR_VAR 0 7
47386: PUSH
47387: LD_VAR 0 7
47391: PUSH
47392: LD_INT 1
47394: ARRAY
47395: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47396: LD_ADDR_VAR 0 9
47400: PUSH
47401: LD_VAR 0 7
47405: PPUSH
47406: LD_EXP 141
47410: PUSH
47411: LD_VAR 0 2
47415: ARRAY
47416: PPUSH
47417: CALL 75550 0 2
47421: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47422: LD_EXP 155
47426: PUSH
47427: LD_VAR 0 2
47431: ARRAY
47432: IFFALSE 47455
// if not weapon in mc_allowed_tower_weapons [ i ] then
47434: LD_VAR 0 9
47438: PUSH
47439: LD_EXP 155
47443: PUSH
47444: LD_VAR 0 2
47448: ARRAY
47449: IN
47450: NOT
47451: IFFALSE 47455
// continue ;
47453: GO 47157
// end else
47455: GO 47520
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47457: LD_ADDR_VAR 0 5
47461: PUSH
47462: LD_EXP 124
47466: PUSH
47467: LD_VAR 0 2
47471: ARRAY
47472: PPUSH
47473: LD_VAR 0 4
47477: PPUSH
47478: CALL 101839 0 2
47482: ST_TO_ADDR
// if not tmp2 then
47483: LD_VAR 0 5
47487: NOT
47488: IFFALSE 47492
// continue ;
47490: GO 47157
// tw := tmp2 [ 1 ] ;
47492: LD_ADDR_VAR 0 7
47496: PUSH
47497: LD_VAR 0 5
47501: PUSH
47502: LD_INT 1
47504: ARRAY
47505: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47506: LD_ADDR_VAR 0 9
47510: PUSH
47511: LD_VAR 0 5
47515: PUSH
47516: LD_INT 2
47518: ARRAY
47519: ST_TO_ADDR
// end ; if not weapon then
47520: LD_VAR 0 9
47524: NOT
47525: IFFALSE 47529
// continue ;
47527: GO 47157
// ComPlaceWeapon ( tw , weapon ) ;
47529: LD_VAR 0 7
47533: PPUSH
47534: LD_VAR 0 9
47538: PPUSH
47539: CALL_OW 148
// end ;
47543: GO 47157
47545: POP
47546: POP
// end ;
47547: LD_VAR 0 1
47551: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47552: LD_INT 0
47554: PPUSH
47555: PPUSH
47556: PPUSH
47557: PPUSH
47558: PPUSH
47559: PPUSH
47560: PPUSH
// if not mc_bases then
47561: LD_EXP 116
47565: NOT
47566: IFFALSE 47570
// exit ;
47568: GO 48338
// for i = 1 to mc_bases do
47570: LD_ADDR_VAR 0 2
47574: PUSH
47575: DOUBLE
47576: LD_INT 1
47578: DEC
47579: ST_TO_ADDR
47580: LD_EXP 116
47584: PUSH
47585: FOR_TO
47586: IFFALSE 48336
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47588: LD_EXP 129
47592: PUSH
47593: LD_VAR 0 2
47597: ARRAY
47598: NOT
47599: PUSH
47600: LD_EXP 129
47604: PUSH
47605: LD_VAR 0 2
47609: ARRAY
47610: PUSH
47611: LD_EXP 130
47615: PUSH
47616: LD_VAR 0 2
47620: ARRAY
47621: EQUAL
47622: OR
47623: PUSH
47624: LD_EXP 139
47628: PUSH
47629: LD_VAR 0 2
47633: ARRAY
47634: OR
47635: IFFALSE 47639
// continue ;
47637: GO 47585
// if mc_miners [ i ] then
47639: LD_EXP 130
47643: PUSH
47644: LD_VAR 0 2
47648: ARRAY
47649: IFFALSE 48023
// begin for j = mc_miners [ i ] downto 1 do
47651: LD_ADDR_VAR 0 3
47655: PUSH
47656: DOUBLE
47657: LD_EXP 130
47661: PUSH
47662: LD_VAR 0 2
47666: ARRAY
47667: INC
47668: ST_TO_ADDR
47669: LD_INT 1
47671: PUSH
47672: FOR_DOWNTO
47673: IFFALSE 48021
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47675: LD_EXP 130
47679: PUSH
47680: LD_VAR 0 2
47684: ARRAY
47685: PUSH
47686: LD_VAR 0 3
47690: ARRAY
47691: PPUSH
47692: CALL_OW 301
47696: PUSH
47697: LD_EXP 130
47701: PUSH
47702: LD_VAR 0 2
47706: ARRAY
47707: PUSH
47708: LD_VAR 0 3
47712: ARRAY
47713: PPUSH
47714: CALL_OW 257
47718: PUSH
47719: LD_INT 1
47721: NONEQUAL
47722: OR
47723: IFFALSE 47786
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47725: LD_ADDR_VAR 0 5
47729: PUSH
47730: LD_EXP 130
47734: PUSH
47735: LD_VAR 0 2
47739: ARRAY
47740: PUSH
47741: LD_EXP 130
47745: PUSH
47746: LD_VAR 0 2
47750: ARRAY
47751: PUSH
47752: LD_VAR 0 3
47756: ARRAY
47757: DIFF
47758: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47759: LD_ADDR_EXP 130
47763: PUSH
47764: LD_EXP 130
47768: PPUSH
47769: LD_VAR 0 2
47773: PPUSH
47774: LD_VAR 0 5
47778: PPUSH
47779: CALL_OW 1
47783: ST_TO_ADDR
// continue ;
47784: GO 47672
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47786: LD_EXP 130
47790: PUSH
47791: LD_VAR 0 2
47795: ARRAY
47796: PUSH
47797: LD_VAR 0 3
47801: ARRAY
47802: PPUSH
47803: CALL_OW 257
47807: PUSH
47808: LD_INT 1
47810: EQUAL
47811: PUSH
47812: LD_EXP 130
47816: PUSH
47817: LD_VAR 0 2
47821: ARRAY
47822: PUSH
47823: LD_VAR 0 3
47827: ARRAY
47828: PPUSH
47829: CALL_OW 459
47833: NOT
47834: AND
47835: PUSH
47836: LD_EXP 130
47840: PUSH
47841: LD_VAR 0 2
47845: ARRAY
47846: PUSH
47847: LD_VAR 0 3
47851: ARRAY
47852: PPUSH
47853: CALL_OW 314
47857: NOT
47858: AND
47859: IFFALSE 48019
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47861: LD_EXP 130
47865: PUSH
47866: LD_VAR 0 2
47870: ARRAY
47871: PUSH
47872: LD_VAR 0 3
47876: ARRAY
47877: PPUSH
47878: CALL_OW 310
47882: IFFALSE 47905
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47884: LD_EXP 130
47888: PUSH
47889: LD_VAR 0 2
47893: ARRAY
47894: PUSH
47895: LD_VAR 0 3
47899: ARRAY
47900: PPUSH
47901: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47905: LD_EXP 130
47909: PUSH
47910: LD_VAR 0 2
47914: ARRAY
47915: PUSH
47916: LD_VAR 0 3
47920: ARRAY
47921: PPUSH
47922: CALL_OW 314
47926: NOT
47927: IFFALSE 48019
// begin r := rand ( 1 , mc_mines [ i ] ) ;
47929: LD_ADDR_VAR 0 7
47933: PUSH
47934: LD_INT 1
47936: PPUSH
47937: LD_EXP 129
47941: PUSH
47942: LD_VAR 0 2
47946: ARRAY
47947: PPUSH
47948: CALL_OW 12
47952: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
47953: LD_EXP 130
47957: PUSH
47958: LD_VAR 0 2
47962: ARRAY
47963: PUSH
47964: LD_VAR 0 3
47968: ARRAY
47969: PPUSH
47970: LD_EXP 129
47974: PUSH
47975: LD_VAR 0 2
47979: ARRAY
47980: PUSH
47981: LD_VAR 0 7
47985: ARRAY
47986: PUSH
47987: LD_INT 1
47989: ARRAY
47990: PPUSH
47991: LD_EXP 129
47995: PUSH
47996: LD_VAR 0 2
48000: ARRAY
48001: PUSH
48002: LD_VAR 0 7
48006: ARRAY
48007: PUSH
48008: LD_INT 2
48010: ARRAY
48011: PPUSH
48012: LD_INT 0
48014: PPUSH
48015: CALL_OW 193
// end ; end ; end ;
48019: GO 47672
48021: POP
48022: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48023: LD_ADDR_VAR 0 5
48027: PUSH
48028: LD_EXP 116
48032: PUSH
48033: LD_VAR 0 2
48037: ARRAY
48038: PPUSH
48039: LD_INT 2
48041: PUSH
48042: LD_INT 30
48044: PUSH
48045: LD_INT 4
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: PUSH
48052: LD_INT 30
48054: PUSH
48055: LD_INT 5
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: PUSH
48062: LD_INT 30
48064: PUSH
48065: LD_INT 32
48067: PUSH
48068: EMPTY
48069: LIST
48070: LIST
48071: PUSH
48072: EMPTY
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: PPUSH
48078: CALL_OW 72
48082: ST_TO_ADDR
// if not tmp then
48083: LD_VAR 0 5
48087: NOT
48088: IFFALSE 48092
// continue ;
48090: GO 47585
// list := [ ] ;
48092: LD_ADDR_VAR 0 6
48096: PUSH
48097: EMPTY
48098: ST_TO_ADDR
// for j in tmp do
48099: LD_ADDR_VAR 0 3
48103: PUSH
48104: LD_VAR 0 5
48108: PUSH
48109: FOR_IN
48110: IFFALSE 48179
// begin for k in UnitsInside ( j ) do
48112: LD_ADDR_VAR 0 4
48116: PUSH
48117: LD_VAR 0 3
48121: PPUSH
48122: CALL_OW 313
48126: PUSH
48127: FOR_IN
48128: IFFALSE 48175
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48130: LD_VAR 0 4
48134: PPUSH
48135: CALL_OW 257
48139: PUSH
48140: LD_INT 1
48142: EQUAL
48143: PUSH
48144: LD_VAR 0 4
48148: PPUSH
48149: CALL_OW 459
48153: NOT
48154: AND
48155: IFFALSE 48173
// list := list ^ k ;
48157: LD_ADDR_VAR 0 6
48161: PUSH
48162: LD_VAR 0 6
48166: PUSH
48167: LD_VAR 0 4
48171: ADD
48172: ST_TO_ADDR
48173: GO 48127
48175: POP
48176: POP
// end ;
48177: GO 48109
48179: POP
48180: POP
// list := list diff mc_miners [ i ] ;
48181: LD_ADDR_VAR 0 6
48185: PUSH
48186: LD_VAR 0 6
48190: PUSH
48191: LD_EXP 130
48195: PUSH
48196: LD_VAR 0 2
48200: ARRAY
48201: DIFF
48202: ST_TO_ADDR
// if not list then
48203: LD_VAR 0 6
48207: NOT
48208: IFFALSE 48212
// continue ;
48210: GO 47585
// k := mc_mines [ i ] - mc_miners [ i ] ;
48212: LD_ADDR_VAR 0 4
48216: PUSH
48217: LD_EXP 129
48221: PUSH
48222: LD_VAR 0 2
48226: ARRAY
48227: PUSH
48228: LD_EXP 130
48232: PUSH
48233: LD_VAR 0 2
48237: ARRAY
48238: MINUS
48239: ST_TO_ADDR
// if k > list then
48240: LD_VAR 0 4
48244: PUSH
48245: LD_VAR 0 6
48249: GREATER
48250: IFFALSE 48262
// k := list ;
48252: LD_ADDR_VAR 0 4
48256: PUSH
48257: LD_VAR 0 6
48261: ST_TO_ADDR
// for j = 1 to k do
48262: LD_ADDR_VAR 0 3
48266: PUSH
48267: DOUBLE
48268: LD_INT 1
48270: DEC
48271: ST_TO_ADDR
48272: LD_VAR 0 4
48276: PUSH
48277: FOR_TO
48278: IFFALSE 48332
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48280: LD_ADDR_EXP 130
48284: PUSH
48285: LD_EXP 130
48289: PPUSH
48290: LD_VAR 0 2
48294: PUSH
48295: LD_EXP 130
48299: PUSH
48300: LD_VAR 0 2
48304: ARRAY
48305: PUSH
48306: LD_INT 1
48308: PLUS
48309: PUSH
48310: EMPTY
48311: LIST
48312: LIST
48313: PPUSH
48314: LD_VAR 0 6
48318: PUSH
48319: LD_VAR 0 3
48323: ARRAY
48324: PPUSH
48325: CALL 70539 0 3
48329: ST_TO_ADDR
48330: GO 48277
48332: POP
48333: POP
// end ;
48334: GO 47585
48336: POP
48337: POP
// end ;
48338: LD_VAR 0 1
48342: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48343: LD_INT 0
48345: PPUSH
48346: PPUSH
48347: PPUSH
48348: PPUSH
48349: PPUSH
48350: PPUSH
48351: PPUSH
48352: PPUSH
48353: PPUSH
48354: PPUSH
48355: PPUSH
// if not mc_bases then
48356: LD_EXP 116
48360: NOT
48361: IFFALSE 48365
// exit ;
48363: GO 50188
// for i = 1 to mc_bases do
48365: LD_ADDR_VAR 0 2
48369: PUSH
48370: DOUBLE
48371: LD_INT 1
48373: DEC
48374: ST_TO_ADDR
48375: LD_EXP 116
48379: PUSH
48380: FOR_TO
48381: IFFALSE 50186
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48383: LD_EXP 116
48387: PUSH
48388: LD_VAR 0 2
48392: ARRAY
48393: NOT
48394: PUSH
48395: LD_EXP 123
48399: PUSH
48400: LD_VAR 0 2
48404: ARRAY
48405: OR
48406: IFFALSE 48410
// continue ;
48408: GO 48380
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48410: LD_EXP 132
48414: PUSH
48415: LD_VAR 0 2
48419: ARRAY
48420: NOT
48421: PUSH
48422: LD_EXP 133
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: AND
48433: IFFALSE 48471
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48435: LD_ADDR_EXP 133
48439: PUSH
48440: LD_EXP 133
48444: PPUSH
48445: LD_VAR 0 2
48449: PPUSH
48450: EMPTY
48451: PPUSH
48452: CALL_OW 1
48456: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48457: LD_VAR 0 2
48461: PPUSH
48462: LD_INT 107
48464: PPUSH
48465: CALL 39297 0 2
// continue ;
48469: GO 48380
// end ; target := [ ] ;
48471: LD_ADDR_VAR 0 7
48475: PUSH
48476: EMPTY
48477: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48478: LD_ADDR_VAR 0 6
48482: PUSH
48483: LD_EXP 116
48487: PUSH
48488: LD_VAR 0 2
48492: ARRAY
48493: PUSH
48494: LD_INT 1
48496: ARRAY
48497: PPUSH
48498: CALL_OW 255
48502: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48503: LD_ADDR_VAR 0 9
48507: PUSH
48508: LD_EXP 116
48512: PUSH
48513: LD_VAR 0 2
48517: ARRAY
48518: PPUSH
48519: LD_INT 2
48521: PUSH
48522: LD_INT 30
48524: PUSH
48525: LD_INT 0
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PUSH
48532: LD_INT 30
48534: PUSH
48535: LD_INT 1
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: LIST
48546: PPUSH
48547: CALL_OW 72
48551: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48552: LD_ADDR_VAR 0 3
48556: PUSH
48557: DOUBLE
48558: LD_EXP 132
48562: PUSH
48563: LD_VAR 0 2
48567: ARRAY
48568: INC
48569: ST_TO_ADDR
48570: LD_INT 1
48572: PUSH
48573: FOR_DOWNTO
48574: IFFALSE 48819
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48576: LD_EXP 132
48580: PUSH
48581: LD_VAR 0 2
48585: ARRAY
48586: PUSH
48587: LD_VAR 0 3
48591: ARRAY
48592: PUSH
48593: LD_INT 2
48595: ARRAY
48596: PPUSH
48597: LD_EXP 132
48601: PUSH
48602: LD_VAR 0 2
48606: ARRAY
48607: PUSH
48608: LD_VAR 0 3
48612: ARRAY
48613: PUSH
48614: LD_INT 3
48616: ARRAY
48617: PPUSH
48618: CALL_OW 488
48622: PUSH
48623: LD_EXP 132
48627: PUSH
48628: LD_VAR 0 2
48632: ARRAY
48633: PUSH
48634: LD_VAR 0 3
48638: ARRAY
48639: PUSH
48640: LD_INT 2
48642: ARRAY
48643: PPUSH
48644: LD_EXP 132
48648: PUSH
48649: LD_VAR 0 2
48653: ARRAY
48654: PUSH
48655: LD_VAR 0 3
48659: ARRAY
48660: PUSH
48661: LD_INT 3
48663: ARRAY
48664: PPUSH
48665: CALL_OW 284
48669: PUSH
48670: LD_INT 0
48672: EQUAL
48673: AND
48674: IFFALSE 48729
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48676: LD_ADDR_VAR 0 5
48680: PUSH
48681: LD_EXP 132
48685: PUSH
48686: LD_VAR 0 2
48690: ARRAY
48691: PPUSH
48692: LD_VAR 0 3
48696: PPUSH
48697: CALL_OW 3
48701: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48702: LD_ADDR_EXP 132
48706: PUSH
48707: LD_EXP 132
48711: PPUSH
48712: LD_VAR 0 2
48716: PPUSH
48717: LD_VAR 0 5
48721: PPUSH
48722: CALL_OW 1
48726: ST_TO_ADDR
// continue ;
48727: GO 48573
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48729: LD_VAR 0 6
48733: PPUSH
48734: LD_EXP 132
48738: PUSH
48739: LD_VAR 0 2
48743: ARRAY
48744: PUSH
48745: LD_VAR 0 3
48749: ARRAY
48750: PUSH
48751: LD_INT 2
48753: ARRAY
48754: PPUSH
48755: LD_EXP 132
48759: PUSH
48760: LD_VAR 0 2
48764: ARRAY
48765: PUSH
48766: LD_VAR 0 3
48770: ARRAY
48771: PUSH
48772: LD_INT 3
48774: ARRAY
48775: PPUSH
48776: LD_INT 30
48778: PPUSH
48779: CALL 71435 0 4
48783: PUSH
48784: LD_INT 4
48786: ARRAY
48787: PUSH
48788: LD_INT 0
48790: EQUAL
48791: IFFALSE 48817
// begin target := mc_crates [ i ] [ j ] ;
48793: LD_ADDR_VAR 0 7
48797: PUSH
48798: LD_EXP 132
48802: PUSH
48803: LD_VAR 0 2
48807: ARRAY
48808: PUSH
48809: LD_VAR 0 3
48813: ARRAY
48814: ST_TO_ADDR
// break ;
48815: GO 48819
// end ; end ;
48817: GO 48573
48819: POP
48820: POP
// if not target then
48821: LD_VAR 0 7
48825: NOT
48826: IFFALSE 48830
// continue ;
48828: GO 48380
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48830: LD_ADDR_VAR 0 8
48834: PUSH
48835: LD_EXP 135
48839: PUSH
48840: LD_VAR 0 2
48844: ARRAY
48845: PPUSH
48846: LD_INT 2
48848: PUSH
48849: LD_INT 3
48851: PUSH
48852: LD_INT 58
48854: PUSH
48855: EMPTY
48856: LIST
48857: PUSH
48858: EMPTY
48859: LIST
48860: LIST
48861: PUSH
48862: LD_INT 61
48864: PUSH
48865: EMPTY
48866: LIST
48867: PUSH
48868: LD_INT 33
48870: PUSH
48871: LD_INT 5
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: PUSH
48878: LD_INT 33
48880: PUSH
48881: LD_INT 3
48883: PUSH
48884: EMPTY
48885: LIST
48886: LIST
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: LIST
48892: LIST
48893: LIST
48894: PUSH
48895: LD_INT 2
48897: PUSH
48898: LD_INT 34
48900: PUSH
48901: LD_INT 32
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: PUSH
48908: LD_INT 34
48910: PUSH
48911: LD_INT 51
48913: PUSH
48914: EMPTY
48915: LIST
48916: LIST
48917: PUSH
48918: LD_INT 34
48920: PUSH
48921: LD_INT 12
48923: PUSH
48924: EMPTY
48925: LIST
48926: LIST
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: PUSH
48934: EMPTY
48935: LIST
48936: LIST
48937: PPUSH
48938: CALL_OW 72
48942: ST_TO_ADDR
// if not cargo then
48943: LD_VAR 0 8
48947: NOT
48948: IFFALSE 49654
// begin if mc_crates_collector [ i ] < 5 then
48950: LD_EXP 133
48954: PUSH
48955: LD_VAR 0 2
48959: ARRAY
48960: PUSH
48961: LD_INT 5
48963: LESS
48964: IFFALSE 49330
// begin if mc_ape [ i ] then
48966: LD_EXP 145
48970: PUSH
48971: LD_VAR 0 2
48975: ARRAY
48976: IFFALSE 49023
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48978: LD_ADDR_VAR 0 5
48982: PUSH
48983: LD_EXP 145
48987: PUSH
48988: LD_VAR 0 2
48992: ARRAY
48993: PPUSH
48994: LD_INT 25
48996: PUSH
48997: LD_INT 16
48999: PUSH
49000: EMPTY
49001: LIST
49002: LIST
49003: PUSH
49004: LD_INT 24
49006: PUSH
49007: LD_INT 750
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: EMPTY
49015: LIST
49016: LIST
49017: PPUSH
49018: CALL_OW 72
49022: ST_TO_ADDR
// if not tmp then
49023: LD_VAR 0 5
49027: NOT
49028: IFFALSE 49075
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49030: LD_ADDR_VAR 0 5
49034: PUSH
49035: LD_EXP 116
49039: PUSH
49040: LD_VAR 0 2
49044: ARRAY
49045: PPUSH
49046: LD_INT 25
49048: PUSH
49049: LD_INT 2
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: PUSH
49056: LD_INT 24
49058: PUSH
49059: LD_INT 750
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: PPUSH
49070: CALL_OW 72
49074: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49075: LD_EXP 145
49079: PUSH
49080: LD_VAR 0 2
49084: ARRAY
49085: PUSH
49086: LD_EXP 116
49090: PUSH
49091: LD_VAR 0 2
49095: ARRAY
49096: PPUSH
49097: LD_INT 25
49099: PUSH
49100: LD_INT 2
49102: PUSH
49103: EMPTY
49104: LIST
49105: LIST
49106: PUSH
49107: LD_INT 24
49109: PUSH
49110: LD_INT 750
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: PPUSH
49121: CALL_OW 72
49125: AND
49126: PUSH
49127: LD_VAR 0 5
49131: PUSH
49132: LD_INT 5
49134: LESS
49135: AND
49136: IFFALSE 49218
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49138: LD_ADDR_VAR 0 3
49142: PUSH
49143: LD_EXP 116
49147: PUSH
49148: LD_VAR 0 2
49152: ARRAY
49153: PPUSH
49154: LD_INT 25
49156: PUSH
49157: LD_INT 2
49159: PUSH
49160: EMPTY
49161: LIST
49162: LIST
49163: PUSH
49164: LD_INT 24
49166: PUSH
49167: LD_INT 750
49169: PUSH
49170: EMPTY
49171: LIST
49172: LIST
49173: PUSH
49174: EMPTY
49175: LIST
49176: LIST
49177: PPUSH
49178: CALL_OW 72
49182: PUSH
49183: FOR_IN
49184: IFFALSE 49216
// begin tmp := tmp union j ;
49186: LD_ADDR_VAR 0 5
49190: PUSH
49191: LD_VAR 0 5
49195: PUSH
49196: LD_VAR 0 3
49200: UNION
49201: ST_TO_ADDR
// if tmp >= 5 then
49202: LD_VAR 0 5
49206: PUSH
49207: LD_INT 5
49209: GREATEREQUAL
49210: IFFALSE 49214
// break ;
49212: GO 49216
// end ;
49214: GO 49183
49216: POP
49217: POP
// end ; if not tmp then
49218: LD_VAR 0 5
49222: NOT
49223: IFFALSE 49227
// continue ;
49225: GO 48380
// for j in tmp do
49227: LD_ADDR_VAR 0 3
49231: PUSH
49232: LD_VAR 0 5
49236: PUSH
49237: FOR_IN
49238: IFFALSE 49328
// if not GetTag ( j ) then
49240: LD_VAR 0 3
49244: PPUSH
49245: CALL_OW 110
49249: NOT
49250: IFFALSE 49326
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49252: LD_ADDR_EXP 133
49256: PUSH
49257: LD_EXP 133
49261: PPUSH
49262: LD_VAR 0 2
49266: PUSH
49267: LD_EXP 133
49271: PUSH
49272: LD_VAR 0 2
49276: ARRAY
49277: PUSH
49278: LD_INT 1
49280: PLUS
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: PPUSH
49286: LD_VAR 0 3
49290: PPUSH
49291: CALL 70539 0 3
49295: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49296: LD_VAR 0 3
49300: PPUSH
49301: LD_INT 107
49303: PPUSH
49304: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49308: LD_EXP 133
49312: PUSH
49313: LD_VAR 0 2
49317: ARRAY
49318: PUSH
49319: LD_INT 5
49321: GREATEREQUAL
49322: IFFALSE 49326
// break ;
49324: GO 49328
// end ;
49326: GO 49237
49328: POP
49329: POP
// end ; if mc_crates_collector [ i ] and target then
49330: LD_EXP 133
49334: PUSH
49335: LD_VAR 0 2
49339: ARRAY
49340: PUSH
49341: LD_VAR 0 7
49345: AND
49346: IFFALSE 49652
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49348: LD_EXP 133
49352: PUSH
49353: LD_VAR 0 2
49357: ARRAY
49358: PUSH
49359: LD_VAR 0 7
49363: PUSH
49364: LD_INT 1
49366: ARRAY
49367: LESS
49368: IFFALSE 49388
// tmp := mc_crates_collector [ i ] else
49370: LD_ADDR_VAR 0 5
49374: PUSH
49375: LD_EXP 133
49379: PUSH
49380: LD_VAR 0 2
49384: ARRAY
49385: ST_TO_ADDR
49386: GO 49402
// tmp := target [ 1 ] ;
49388: LD_ADDR_VAR 0 5
49392: PUSH
49393: LD_VAR 0 7
49397: PUSH
49398: LD_INT 1
49400: ARRAY
49401: ST_TO_ADDR
// k := 0 ;
49402: LD_ADDR_VAR 0 4
49406: PUSH
49407: LD_INT 0
49409: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49410: LD_ADDR_VAR 0 3
49414: PUSH
49415: LD_EXP 133
49419: PUSH
49420: LD_VAR 0 2
49424: ARRAY
49425: PUSH
49426: FOR_IN
49427: IFFALSE 49650
// begin k := k + 1 ;
49429: LD_ADDR_VAR 0 4
49433: PUSH
49434: LD_VAR 0 4
49438: PUSH
49439: LD_INT 1
49441: PLUS
49442: ST_TO_ADDR
// if k > tmp then
49443: LD_VAR 0 4
49447: PUSH
49448: LD_VAR 0 5
49452: GREATER
49453: IFFALSE 49457
// break ;
49455: GO 49650
// if not GetClass ( j ) in [ 2 , 16 ] then
49457: LD_VAR 0 3
49461: PPUSH
49462: CALL_OW 257
49466: PUSH
49467: LD_INT 2
49469: PUSH
49470: LD_INT 16
49472: PUSH
49473: EMPTY
49474: LIST
49475: LIST
49476: IN
49477: NOT
49478: IFFALSE 49531
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49480: LD_ADDR_EXP 133
49484: PUSH
49485: LD_EXP 133
49489: PPUSH
49490: LD_VAR 0 2
49494: PPUSH
49495: LD_EXP 133
49499: PUSH
49500: LD_VAR 0 2
49504: ARRAY
49505: PUSH
49506: LD_VAR 0 3
49510: DIFF
49511: PPUSH
49512: CALL_OW 1
49516: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49517: LD_VAR 0 3
49521: PPUSH
49522: LD_INT 0
49524: PPUSH
49525: CALL_OW 109
// continue ;
49529: GO 49426
// end ; if IsInUnit ( j ) then
49531: LD_VAR 0 3
49535: PPUSH
49536: CALL_OW 310
49540: IFFALSE 49551
// ComExitBuilding ( j ) ;
49542: LD_VAR 0 3
49546: PPUSH
49547: CALL_OW 122
// wait ( 3 ) ;
49551: LD_INT 3
49553: PPUSH
49554: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49558: LD_VAR 0 3
49562: PPUSH
49563: CALL_OW 314
49567: PUSH
49568: LD_VAR 0 6
49572: PPUSH
49573: LD_VAR 0 7
49577: PUSH
49578: LD_INT 2
49580: ARRAY
49581: PPUSH
49582: LD_VAR 0 7
49586: PUSH
49587: LD_INT 3
49589: ARRAY
49590: PPUSH
49591: LD_INT 30
49593: PPUSH
49594: CALL 71435 0 4
49598: PUSH
49599: LD_INT 4
49601: ARRAY
49602: AND
49603: IFFALSE 49621
// ComStandNearbyBuilding ( j , depot ) else
49605: LD_VAR 0 3
49609: PPUSH
49610: LD_VAR 0 9
49614: PPUSH
49615: CALL 67117 0 2
49619: GO 49648
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49621: LD_VAR 0 3
49625: PPUSH
49626: LD_VAR 0 7
49630: PUSH
49631: LD_INT 2
49633: ARRAY
49634: PPUSH
49635: LD_VAR 0 7
49639: PUSH
49640: LD_INT 3
49642: ARRAY
49643: PPUSH
49644: CALL_OW 117
// end ;
49648: GO 49426
49650: POP
49651: POP
// end ; end else
49652: GO 50184
// begin for j in cargo do
49654: LD_ADDR_VAR 0 3
49658: PUSH
49659: LD_VAR 0 8
49663: PUSH
49664: FOR_IN
49665: IFFALSE 50182
// begin if GetTag ( j ) <> 0 then
49667: LD_VAR 0 3
49671: PPUSH
49672: CALL_OW 110
49676: PUSH
49677: LD_INT 0
49679: NONEQUAL
49680: IFFALSE 49684
// continue ;
49682: GO 49664
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49684: LD_VAR 0 3
49688: PPUSH
49689: CALL_OW 256
49693: PUSH
49694: LD_INT 1000
49696: LESS
49697: PUSH
49698: LD_VAR 0 3
49702: PPUSH
49703: LD_EXP 140
49707: PUSH
49708: LD_VAR 0 2
49712: ARRAY
49713: PPUSH
49714: CALL_OW 308
49718: NOT
49719: AND
49720: IFFALSE 49742
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49722: LD_VAR 0 3
49726: PPUSH
49727: LD_EXP 140
49731: PUSH
49732: LD_VAR 0 2
49736: ARRAY
49737: PPUSH
49738: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49742: LD_VAR 0 3
49746: PPUSH
49747: CALL_OW 256
49751: PUSH
49752: LD_INT 1000
49754: LESS
49755: PUSH
49756: LD_VAR 0 3
49760: PPUSH
49761: LD_EXP 140
49765: PUSH
49766: LD_VAR 0 2
49770: ARRAY
49771: PPUSH
49772: CALL_OW 308
49776: AND
49777: IFFALSE 49781
// continue ;
49779: GO 49664
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49781: LD_VAR 0 3
49785: PPUSH
49786: CALL_OW 262
49790: PUSH
49791: LD_INT 2
49793: EQUAL
49794: PUSH
49795: LD_VAR 0 3
49799: PPUSH
49800: CALL_OW 261
49804: PUSH
49805: LD_INT 15
49807: LESS
49808: AND
49809: IFFALSE 49813
// continue ;
49811: GO 49664
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49813: LD_VAR 0 3
49817: PPUSH
49818: CALL_OW 262
49822: PUSH
49823: LD_INT 1
49825: EQUAL
49826: PUSH
49827: LD_VAR 0 3
49831: PPUSH
49832: CALL_OW 261
49836: PUSH
49837: LD_INT 10
49839: LESS
49840: AND
49841: IFFALSE 50121
// begin if not depot then
49843: LD_VAR 0 9
49847: NOT
49848: IFFALSE 49852
// continue ;
49850: GO 49664
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49852: LD_VAR 0 3
49856: PPUSH
49857: LD_VAR 0 9
49861: PPUSH
49862: LD_VAR 0 3
49866: PPUSH
49867: CALL_OW 74
49871: PPUSH
49872: CALL_OW 296
49876: PUSH
49877: LD_INT 6
49879: LESS
49880: IFFALSE 49896
// SetFuel ( j , 100 ) else
49882: LD_VAR 0 3
49886: PPUSH
49887: LD_INT 100
49889: PPUSH
49890: CALL_OW 240
49894: GO 50121
// if GetFuel ( j ) = 0 then
49896: LD_VAR 0 3
49900: PPUSH
49901: CALL_OW 261
49905: PUSH
49906: LD_INT 0
49908: EQUAL
49909: IFFALSE 50121
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49911: LD_ADDR_EXP 135
49915: PUSH
49916: LD_EXP 135
49920: PPUSH
49921: LD_VAR 0 2
49925: PPUSH
49926: LD_EXP 135
49930: PUSH
49931: LD_VAR 0 2
49935: ARRAY
49936: PUSH
49937: LD_VAR 0 3
49941: DIFF
49942: PPUSH
49943: CALL_OW 1
49947: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49948: LD_VAR 0 3
49952: PPUSH
49953: CALL_OW 263
49957: PUSH
49958: LD_INT 1
49960: EQUAL
49961: IFFALSE 49977
// ComExitVehicle ( IsInUnit ( j ) ) ;
49963: LD_VAR 0 3
49967: PPUSH
49968: CALL_OW 310
49972: PPUSH
49973: CALL_OW 121
// if GetControl ( j ) = control_remote then
49977: LD_VAR 0 3
49981: PPUSH
49982: CALL_OW 263
49986: PUSH
49987: LD_INT 2
49989: EQUAL
49990: IFFALSE 50001
// ComUnlink ( j ) ;
49992: LD_VAR 0 3
49996: PPUSH
49997: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50001: LD_ADDR_VAR 0 10
50005: PUSH
50006: LD_VAR 0 2
50010: PPUSH
50011: LD_INT 3
50013: PPUSH
50014: CALL 59602 0 2
50018: ST_TO_ADDR
// if fac then
50019: LD_VAR 0 10
50023: IFFALSE 50119
// begin for k in fac do
50025: LD_ADDR_VAR 0 4
50029: PUSH
50030: LD_VAR 0 10
50034: PUSH
50035: FOR_IN
50036: IFFALSE 50117
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50038: LD_ADDR_VAR 0 11
50042: PUSH
50043: LD_VAR 0 10
50047: PPUSH
50048: LD_VAR 0 3
50052: PPUSH
50053: CALL_OW 265
50057: PPUSH
50058: LD_VAR 0 3
50062: PPUSH
50063: CALL_OW 262
50067: PPUSH
50068: LD_VAR 0 3
50072: PPUSH
50073: CALL_OW 263
50077: PPUSH
50078: LD_VAR 0 3
50082: PPUSH
50083: CALL_OW 264
50087: PPUSH
50088: CALL 68035 0 5
50092: ST_TO_ADDR
// if components then
50093: LD_VAR 0 11
50097: IFFALSE 50115
// begin MC_InsertProduceList ( i , components ) ;
50099: LD_VAR 0 2
50103: PPUSH
50104: LD_VAR 0 11
50108: PPUSH
50109: CALL 59147 0 2
// break ;
50113: GO 50117
// end ; end ;
50115: GO 50035
50117: POP
50118: POP
// end ; continue ;
50119: GO 49664
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50121: LD_VAR 0 3
50125: PPUSH
50126: LD_INT 1
50128: PPUSH
50129: CALL_OW 289
50133: PUSH
50134: LD_INT 100
50136: LESS
50137: PUSH
50138: LD_VAR 0 3
50142: PPUSH
50143: CALL_OW 314
50147: NOT
50148: AND
50149: IFFALSE 50178
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50151: LD_VAR 0 3
50155: PPUSH
50156: LD_VAR 0 7
50160: PUSH
50161: LD_INT 2
50163: ARRAY
50164: PPUSH
50165: LD_VAR 0 7
50169: PUSH
50170: LD_INT 3
50172: ARRAY
50173: PPUSH
50174: CALL_OW 117
// break ;
50178: GO 50182
// end ;
50180: GO 49664
50182: POP
50183: POP
// end ; end ;
50184: GO 48380
50186: POP
50187: POP
// end ;
50188: LD_VAR 0 1
50192: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50193: LD_INT 0
50195: PPUSH
50196: PPUSH
50197: PPUSH
50198: PPUSH
// if not mc_bases then
50199: LD_EXP 116
50203: NOT
50204: IFFALSE 50208
// exit ;
50206: GO 50369
// for i = 1 to mc_bases do
50208: LD_ADDR_VAR 0 2
50212: PUSH
50213: DOUBLE
50214: LD_INT 1
50216: DEC
50217: ST_TO_ADDR
50218: LD_EXP 116
50222: PUSH
50223: FOR_TO
50224: IFFALSE 50367
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50226: LD_ADDR_VAR 0 4
50230: PUSH
50231: LD_EXP 135
50235: PUSH
50236: LD_VAR 0 2
50240: ARRAY
50241: PUSH
50242: LD_EXP 138
50246: PUSH
50247: LD_VAR 0 2
50251: ARRAY
50252: UNION
50253: PPUSH
50254: LD_INT 33
50256: PUSH
50257: LD_INT 2
50259: PUSH
50260: EMPTY
50261: LIST
50262: LIST
50263: PPUSH
50264: CALL_OW 72
50268: ST_TO_ADDR
// if tmp then
50269: LD_VAR 0 4
50273: IFFALSE 50365
// for j in tmp do
50275: LD_ADDR_VAR 0 3
50279: PUSH
50280: LD_VAR 0 4
50284: PUSH
50285: FOR_IN
50286: IFFALSE 50363
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50288: LD_VAR 0 3
50292: PPUSH
50293: CALL_OW 312
50297: NOT
50298: PUSH
50299: LD_VAR 0 3
50303: PPUSH
50304: CALL_OW 256
50308: PUSH
50309: LD_INT 250
50311: GREATEREQUAL
50312: AND
50313: IFFALSE 50326
// Connect ( j ) else
50315: LD_VAR 0 3
50319: PPUSH
50320: CALL 73510 0 1
50324: GO 50361
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50326: LD_VAR 0 3
50330: PPUSH
50331: CALL_OW 256
50335: PUSH
50336: LD_INT 250
50338: LESS
50339: PUSH
50340: LD_VAR 0 3
50344: PPUSH
50345: CALL_OW 312
50349: AND
50350: IFFALSE 50361
// ComUnlink ( j ) ;
50352: LD_VAR 0 3
50356: PPUSH
50357: CALL_OW 136
50361: GO 50285
50363: POP
50364: POP
// end ;
50365: GO 50223
50367: POP
50368: POP
// end ;
50369: LD_VAR 0 1
50373: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50374: LD_INT 0
50376: PPUSH
50377: PPUSH
50378: PPUSH
50379: PPUSH
50380: PPUSH
// if not mc_bases then
50381: LD_EXP 116
50385: NOT
50386: IFFALSE 50390
// exit ;
50388: GO 50835
// for i = 1 to mc_bases do
50390: LD_ADDR_VAR 0 2
50394: PUSH
50395: DOUBLE
50396: LD_INT 1
50398: DEC
50399: ST_TO_ADDR
50400: LD_EXP 116
50404: PUSH
50405: FOR_TO
50406: IFFALSE 50833
// begin if not mc_produce [ i ] then
50408: LD_EXP 137
50412: PUSH
50413: LD_VAR 0 2
50417: ARRAY
50418: NOT
50419: IFFALSE 50423
// continue ;
50421: GO 50405
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50423: LD_ADDR_VAR 0 5
50427: PUSH
50428: LD_EXP 116
50432: PUSH
50433: LD_VAR 0 2
50437: ARRAY
50438: PPUSH
50439: LD_INT 30
50441: PUSH
50442: LD_INT 3
50444: PUSH
50445: EMPTY
50446: LIST
50447: LIST
50448: PPUSH
50449: CALL_OW 72
50453: ST_TO_ADDR
// if not fac then
50454: LD_VAR 0 5
50458: NOT
50459: IFFALSE 50463
// continue ;
50461: GO 50405
// for j in fac do
50463: LD_ADDR_VAR 0 3
50467: PUSH
50468: LD_VAR 0 5
50472: PUSH
50473: FOR_IN
50474: IFFALSE 50829
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50476: LD_VAR 0 3
50480: PPUSH
50481: CALL_OW 461
50485: PUSH
50486: LD_INT 2
50488: NONEQUAL
50489: PUSH
50490: LD_VAR 0 3
50494: PPUSH
50495: LD_INT 15
50497: PPUSH
50498: CALL 73138 0 2
50502: PUSH
50503: LD_INT 4
50505: ARRAY
50506: OR
50507: IFFALSE 50511
// continue ;
50509: GO 50473
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50511: LD_VAR 0 3
50515: PPUSH
50516: LD_EXP 137
50520: PUSH
50521: LD_VAR 0 2
50525: ARRAY
50526: PUSH
50527: LD_INT 1
50529: ARRAY
50530: PUSH
50531: LD_INT 1
50533: ARRAY
50534: PPUSH
50535: LD_EXP 137
50539: PUSH
50540: LD_VAR 0 2
50544: ARRAY
50545: PUSH
50546: LD_INT 1
50548: ARRAY
50549: PUSH
50550: LD_INT 2
50552: ARRAY
50553: PPUSH
50554: LD_EXP 137
50558: PUSH
50559: LD_VAR 0 2
50563: ARRAY
50564: PUSH
50565: LD_INT 1
50567: ARRAY
50568: PUSH
50569: LD_INT 3
50571: ARRAY
50572: PPUSH
50573: LD_EXP 137
50577: PUSH
50578: LD_VAR 0 2
50582: ARRAY
50583: PUSH
50584: LD_INT 1
50586: ARRAY
50587: PUSH
50588: LD_INT 4
50590: ARRAY
50591: PPUSH
50592: CALL_OW 448
50596: PUSH
50597: LD_VAR 0 3
50601: PPUSH
50602: LD_EXP 137
50606: PUSH
50607: LD_VAR 0 2
50611: ARRAY
50612: PUSH
50613: LD_INT 1
50615: ARRAY
50616: PUSH
50617: LD_INT 1
50619: ARRAY
50620: PUSH
50621: LD_EXP 137
50625: PUSH
50626: LD_VAR 0 2
50630: ARRAY
50631: PUSH
50632: LD_INT 1
50634: ARRAY
50635: PUSH
50636: LD_INT 2
50638: ARRAY
50639: PUSH
50640: LD_EXP 137
50644: PUSH
50645: LD_VAR 0 2
50649: ARRAY
50650: PUSH
50651: LD_INT 1
50653: ARRAY
50654: PUSH
50655: LD_INT 3
50657: ARRAY
50658: PUSH
50659: LD_EXP 137
50663: PUSH
50664: LD_VAR 0 2
50668: ARRAY
50669: PUSH
50670: LD_INT 1
50672: ARRAY
50673: PUSH
50674: LD_INT 4
50676: ARRAY
50677: PUSH
50678: EMPTY
50679: LIST
50680: LIST
50681: LIST
50682: LIST
50683: PPUSH
50684: CALL 76906 0 2
50688: AND
50689: IFFALSE 50827
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50691: LD_VAR 0 3
50695: PPUSH
50696: LD_EXP 137
50700: PUSH
50701: LD_VAR 0 2
50705: ARRAY
50706: PUSH
50707: LD_INT 1
50709: ARRAY
50710: PUSH
50711: LD_INT 1
50713: ARRAY
50714: PPUSH
50715: LD_EXP 137
50719: PUSH
50720: LD_VAR 0 2
50724: ARRAY
50725: PUSH
50726: LD_INT 1
50728: ARRAY
50729: PUSH
50730: LD_INT 2
50732: ARRAY
50733: PPUSH
50734: LD_EXP 137
50738: PUSH
50739: LD_VAR 0 2
50743: ARRAY
50744: PUSH
50745: LD_INT 1
50747: ARRAY
50748: PUSH
50749: LD_INT 3
50751: ARRAY
50752: PPUSH
50753: LD_EXP 137
50757: PUSH
50758: LD_VAR 0 2
50762: ARRAY
50763: PUSH
50764: LD_INT 1
50766: ARRAY
50767: PUSH
50768: LD_INT 4
50770: ARRAY
50771: PPUSH
50772: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50776: LD_ADDR_VAR 0 4
50780: PUSH
50781: LD_EXP 137
50785: PUSH
50786: LD_VAR 0 2
50790: ARRAY
50791: PPUSH
50792: LD_INT 1
50794: PPUSH
50795: CALL_OW 3
50799: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50800: LD_ADDR_EXP 137
50804: PUSH
50805: LD_EXP 137
50809: PPUSH
50810: LD_VAR 0 2
50814: PPUSH
50815: LD_VAR 0 4
50819: PPUSH
50820: CALL_OW 1
50824: ST_TO_ADDR
// break ;
50825: GO 50829
// end ; end ;
50827: GO 50473
50829: POP
50830: POP
// end ;
50831: GO 50405
50833: POP
50834: POP
// end ;
50835: LD_VAR 0 1
50839: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50840: LD_INT 0
50842: PPUSH
50843: PPUSH
50844: PPUSH
// if not mc_bases then
50845: LD_EXP 116
50849: NOT
50850: IFFALSE 50854
// exit ;
50852: GO 50943
// for i = 1 to mc_bases do
50854: LD_ADDR_VAR 0 2
50858: PUSH
50859: DOUBLE
50860: LD_INT 1
50862: DEC
50863: ST_TO_ADDR
50864: LD_EXP 116
50868: PUSH
50869: FOR_TO
50870: IFFALSE 50941
// begin if mc_attack [ i ] then
50872: LD_EXP 136
50876: PUSH
50877: LD_VAR 0 2
50881: ARRAY
50882: IFFALSE 50939
// begin tmp := mc_attack [ i ] [ 1 ] ;
50884: LD_ADDR_VAR 0 3
50888: PUSH
50889: LD_EXP 136
50893: PUSH
50894: LD_VAR 0 2
50898: ARRAY
50899: PUSH
50900: LD_INT 1
50902: ARRAY
50903: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50904: LD_ADDR_EXP 136
50908: PUSH
50909: LD_EXP 136
50913: PPUSH
50914: LD_VAR 0 2
50918: PPUSH
50919: EMPTY
50920: PPUSH
50921: CALL_OW 1
50925: ST_TO_ADDR
// Attack ( tmp ) ;
50926: LD_VAR 0 3
50930: PPUSH
50931: CALL 121495 0 1
// exit ;
50935: POP
50936: POP
50937: GO 50943
// end ; end ;
50939: GO 50869
50941: POP
50942: POP
// end ;
50943: LD_VAR 0 1
50947: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50948: LD_INT 0
50950: PPUSH
50951: PPUSH
50952: PPUSH
50953: PPUSH
50954: PPUSH
50955: PPUSH
50956: PPUSH
// if not mc_bases then
50957: LD_EXP 116
50961: NOT
50962: IFFALSE 50966
// exit ;
50964: GO 51665
// for i = 1 to mc_bases do
50966: LD_ADDR_VAR 0 2
50970: PUSH
50971: DOUBLE
50972: LD_INT 1
50974: DEC
50975: ST_TO_ADDR
50976: LD_EXP 116
50980: PUSH
50981: FOR_TO
50982: IFFALSE 51663
// begin if not mc_bases [ i ] then
50984: LD_EXP 116
50988: PUSH
50989: LD_VAR 0 2
50993: ARRAY
50994: NOT
50995: IFFALSE 50999
// continue ;
50997: GO 50981
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50999: LD_ADDR_VAR 0 7
51003: PUSH
51004: LD_EXP 116
51008: PUSH
51009: LD_VAR 0 2
51013: ARRAY
51014: PUSH
51015: LD_INT 1
51017: ARRAY
51018: PPUSH
51019: CALL 67339 0 1
51023: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51024: LD_ADDR_EXP 139
51028: PUSH
51029: LD_EXP 139
51033: PPUSH
51034: LD_VAR 0 2
51038: PPUSH
51039: LD_EXP 116
51043: PUSH
51044: LD_VAR 0 2
51048: ARRAY
51049: PUSH
51050: LD_INT 1
51052: ARRAY
51053: PPUSH
51054: CALL_OW 255
51058: PPUSH
51059: LD_EXP 141
51063: PUSH
51064: LD_VAR 0 2
51068: ARRAY
51069: PPUSH
51070: CALL 67304 0 2
51074: PPUSH
51075: CALL_OW 1
51079: ST_TO_ADDR
// if not mc_scan [ i ] then
51080: LD_EXP 139
51084: PUSH
51085: LD_VAR 0 2
51089: ARRAY
51090: NOT
51091: IFFALSE 51269
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51093: LD_ADDR_VAR 0 4
51097: PUSH
51098: LD_EXP 116
51102: PUSH
51103: LD_VAR 0 2
51107: ARRAY
51108: PPUSH
51109: LD_INT 2
51111: PUSH
51112: LD_INT 25
51114: PUSH
51115: LD_INT 5
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PUSH
51122: LD_INT 25
51124: PUSH
51125: LD_INT 8
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: PUSH
51132: LD_INT 25
51134: PUSH
51135: LD_INT 9
51137: PUSH
51138: EMPTY
51139: LIST
51140: LIST
51141: PUSH
51142: EMPTY
51143: LIST
51144: LIST
51145: LIST
51146: LIST
51147: PPUSH
51148: CALL_OW 72
51152: ST_TO_ADDR
// if not tmp then
51153: LD_VAR 0 4
51157: NOT
51158: IFFALSE 51162
// continue ;
51160: GO 50981
// for j in tmp do
51162: LD_ADDR_VAR 0 3
51166: PUSH
51167: LD_VAR 0 4
51171: PUSH
51172: FOR_IN
51173: IFFALSE 51244
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51175: LD_VAR 0 3
51179: PPUSH
51180: CALL_OW 310
51184: PPUSH
51185: CALL_OW 266
51189: PUSH
51190: LD_INT 5
51192: EQUAL
51193: PUSH
51194: LD_VAR 0 3
51198: PPUSH
51199: CALL_OW 257
51203: PUSH
51204: LD_INT 1
51206: EQUAL
51207: AND
51208: PUSH
51209: LD_VAR 0 3
51213: PPUSH
51214: CALL_OW 459
51218: NOT
51219: AND
51220: PUSH
51221: LD_VAR 0 7
51225: AND
51226: IFFALSE 51242
// ComChangeProfession ( j , class ) ;
51228: LD_VAR 0 3
51232: PPUSH
51233: LD_VAR 0 7
51237: PPUSH
51238: CALL_OW 123
51242: GO 51172
51244: POP
51245: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51246: LD_ADDR_EXP 159
51250: PUSH
51251: LD_EXP 159
51255: PPUSH
51256: LD_VAR 0 2
51260: PPUSH
51261: LD_INT 0
51263: PPUSH
51264: CALL_OW 1
51268: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51269: LD_EXP 139
51273: PUSH
51274: LD_VAR 0 2
51278: ARRAY
51279: PUSH
51280: LD_EXP 159
51284: PUSH
51285: LD_VAR 0 2
51289: ARRAY
51290: NOT
51291: AND
51292: PUSH
51293: LD_EXP 138
51297: PUSH
51298: LD_VAR 0 2
51302: ARRAY
51303: NOT
51304: AND
51305: PUSH
51306: LD_EXP 116
51310: PUSH
51311: LD_VAR 0 2
51315: ARRAY
51316: PPUSH
51317: LD_INT 30
51319: PUSH
51320: LD_INT 32
51322: PUSH
51323: EMPTY
51324: LIST
51325: LIST
51326: PPUSH
51327: CALL_OW 72
51331: NOT
51332: AND
51333: PUSH
51334: LD_EXP 116
51338: PUSH
51339: LD_VAR 0 2
51343: ARRAY
51344: PPUSH
51345: LD_INT 2
51347: PUSH
51348: LD_INT 30
51350: PUSH
51351: LD_INT 4
51353: PUSH
51354: EMPTY
51355: LIST
51356: LIST
51357: PUSH
51358: LD_INT 30
51360: PUSH
51361: LD_INT 5
51363: PUSH
51364: EMPTY
51365: LIST
51366: LIST
51367: PUSH
51368: EMPTY
51369: LIST
51370: LIST
51371: LIST
51372: PPUSH
51373: CALL_OW 72
51377: NOT
51378: AND
51379: IFFALSE 51534
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51381: LD_ADDR_VAR 0 4
51385: PUSH
51386: LD_EXP 116
51390: PUSH
51391: LD_VAR 0 2
51395: ARRAY
51396: PPUSH
51397: LD_INT 2
51399: PUSH
51400: LD_INT 25
51402: PUSH
51403: LD_INT 1
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 25
51412: PUSH
51413: LD_INT 5
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: LD_INT 25
51422: PUSH
51423: LD_INT 8
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 25
51432: PUSH
51433: LD_INT 9
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PUSH
51440: EMPTY
51441: LIST
51442: LIST
51443: LIST
51444: LIST
51445: LIST
51446: PPUSH
51447: CALL_OW 72
51451: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51452: LD_ADDR_VAR 0 4
51456: PUSH
51457: LD_VAR 0 4
51461: PUSH
51462: LD_VAR 0 4
51466: PPUSH
51467: LD_INT 18
51469: PPUSH
51470: CALL 99809 0 2
51474: DIFF
51475: ST_TO_ADDR
// if tmp then
51476: LD_VAR 0 4
51480: IFFALSE 51534
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51482: LD_ADDR_EXP 159
51486: PUSH
51487: LD_EXP 159
51491: PPUSH
51492: LD_VAR 0 2
51496: PPUSH
51497: LD_INT 1
51499: PPUSH
51500: CALL_OW 1
51504: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51505: LD_VAR 0 2
51509: PPUSH
51510: LD_VAR 0 4
51514: PPUSH
51515: LD_EXP 141
51519: PUSH
51520: LD_VAR 0 2
51524: ARRAY
51525: PPUSH
51526: CALL 126204 0 3
// exit ;
51530: POP
51531: POP
51532: GO 51665
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51534: LD_EXP 139
51538: PUSH
51539: LD_VAR 0 2
51543: ARRAY
51544: PUSH
51545: LD_EXP 159
51549: PUSH
51550: LD_VAR 0 2
51554: ARRAY
51555: NOT
51556: AND
51557: PUSH
51558: LD_EXP 138
51562: PUSH
51563: LD_VAR 0 2
51567: ARRAY
51568: AND
51569: IFFALSE 51661
// begin tmp := mc_defender [ i ] ;
51571: LD_ADDR_VAR 0 4
51575: PUSH
51576: LD_EXP 138
51580: PUSH
51581: LD_VAR 0 2
51585: ARRAY
51586: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51587: LD_ADDR_EXP 138
51591: PUSH
51592: LD_EXP 138
51596: PPUSH
51597: LD_VAR 0 2
51601: PPUSH
51602: EMPTY
51603: PPUSH
51604: CALL_OW 1
51608: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51609: LD_ADDR_EXP 159
51613: PUSH
51614: LD_EXP 159
51618: PPUSH
51619: LD_VAR 0 2
51623: PPUSH
51624: LD_INT 1
51626: PPUSH
51627: CALL_OW 1
51631: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51632: LD_VAR 0 2
51636: PPUSH
51637: LD_VAR 0 4
51641: PPUSH
51642: LD_EXP 139
51646: PUSH
51647: LD_VAR 0 2
51651: ARRAY
51652: PPUSH
51653: CALL 126765 0 3
// exit ;
51657: POP
51658: POP
51659: GO 51665
// end ; end ;
51661: GO 50981
51663: POP
51664: POP
// end ;
51665: LD_VAR 0 1
51669: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51670: LD_INT 0
51672: PPUSH
51673: PPUSH
51674: PPUSH
51675: PPUSH
51676: PPUSH
51677: PPUSH
51678: PPUSH
51679: PPUSH
51680: PPUSH
51681: PPUSH
51682: PPUSH
// if not mc_bases then
51683: LD_EXP 116
51687: NOT
51688: IFFALSE 51692
// exit ;
51690: GO 52779
// for i = 1 to mc_bases do
51692: LD_ADDR_VAR 0 2
51696: PUSH
51697: DOUBLE
51698: LD_INT 1
51700: DEC
51701: ST_TO_ADDR
51702: LD_EXP 116
51706: PUSH
51707: FOR_TO
51708: IFFALSE 52777
// begin tmp := mc_lab [ i ] ;
51710: LD_ADDR_VAR 0 6
51714: PUSH
51715: LD_EXP 149
51719: PUSH
51720: LD_VAR 0 2
51724: ARRAY
51725: ST_TO_ADDR
// if not tmp then
51726: LD_VAR 0 6
51730: NOT
51731: IFFALSE 51735
// continue ;
51733: GO 51707
// idle_lab := 0 ;
51735: LD_ADDR_VAR 0 11
51739: PUSH
51740: LD_INT 0
51742: ST_TO_ADDR
// for j in tmp do
51743: LD_ADDR_VAR 0 3
51747: PUSH
51748: LD_VAR 0 6
51752: PUSH
51753: FOR_IN
51754: IFFALSE 52773
// begin researching := false ;
51756: LD_ADDR_VAR 0 10
51760: PUSH
51761: LD_INT 0
51763: ST_TO_ADDR
// side := GetSide ( j ) ;
51764: LD_ADDR_VAR 0 4
51768: PUSH
51769: LD_VAR 0 3
51773: PPUSH
51774: CALL_OW 255
51778: ST_TO_ADDR
// if not mc_tech [ side ] then
51779: LD_EXP 143
51783: PUSH
51784: LD_VAR 0 4
51788: ARRAY
51789: NOT
51790: IFFALSE 51794
// continue ;
51792: GO 51753
// if BuildingStatus ( j ) = bs_idle then
51794: LD_VAR 0 3
51798: PPUSH
51799: CALL_OW 461
51803: PUSH
51804: LD_INT 2
51806: EQUAL
51807: IFFALSE 51995
// begin if idle_lab and UnitsInside ( j ) < 6 then
51809: LD_VAR 0 11
51813: PUSH
51814: LD_VAR 0 3
51818: PPUSH
51819: CALL_OW 313
51823: PUSH
51824: LD_INT 6
51826: LESS
51827: AND
51828: IFFALSE 51899
// begin tmp2 := UnitsInside ( idle_lab ) ;
51830: LD_ADDR_VAR 0 9
51834: PUSH
51835: LD_VAR 0 11
51839: PPUSH
51840: CALL_OW 313
51844: ST_TO_ADDR
// if tmp2 then
51845: LD_VAR 0 9
51849: IFFALSE 51891
// for x in tmp2 do
51851: LD_ADDR_VAR 0 7
51855: PUSH
51856: LD_VAR 0 9
51860: PUSH
51861: FOR_IN
51862: IFFALSE 51889
// begin ComExitBuilding ( x ) ;
51864: LD_VAR 0 7
51868: PPUSH
51869: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51873: LD_VAR 0 7
51877: PPUSH
51878: LD_VAR 0 3
51882: PPUSH
51883: CALL_OW 180
// end ;
51887: GO 51861
51889: POP
51890: POP
// idle_lab := 0 ;
51891: LD_ADDR_VAR 0 11
51895: PUSH
51896: LD_INT 0
51898: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51899: LD_ADDR_VAR 0 5
51903: PUSH
51904: LD_EXP 143
51908: PUSH
51909: LD_VAR 0 4
51913: ARRAY
51914: PUSH
51915: FOR_IN
51916: IFFALSE 51976
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51918: LD_VAR 0 3
51922: PPUSH
51923: LD_VAR 0 5
51927: PPUSH
51928: CALL_OW 430
51932: PUSH
51933: LD_VAR 0 4
51937: PPUSH
51938: LD_VAR 0 5
51942: PPUSH
51943: CALL 66409 0 2
51947: AND
51948: IFFALSE 51974
// begin researching := true ;
51950: LD_ADDR_VAR 0 10
51954: PUSH
51955: LD_INT 1
51957: ST_TO_ADDR
// ComResearch ( j , t ) ;
51958: LD_VAR 0 3
51962: PPUSH
51963: LD_VAR 0 5
51967: PPUSH
51968: CALL_OW 124
// break ;
51972: GO 51976
// end ;
51974: GO 51915
51976: POP
51977: POP
// if not researching then
51978: LD_VAR 0 10
51982: NOT
51983: IFFALSE 51995
// idle_lab := j ;
51985: LD_ADDR_VAR 0 11
51989: PUSH
51990: LD_VAR 0 3
51994: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51995: LD_VAR 0 3
51999: PPUSH
52000: CALL_OW 461
52004: PUSH
52005: LD_INT 10
52007: EQUAL
52008: IFFALSE 52596
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52010: LD_EXP 145
52014: PUSH
52015: LD_VAR 0 2
52019: ARRAY
52020: NOT
52021: PUSH
52022: LD_EXP 146
52026: PUSH
52027: LD_VAR 0 2
52031: ARRAY
52032: NOT
52033: AND
52034: PUSH
52035: LD_EXP 143
52039: PUSH
52040: LD_VAR 0 4
52044: ARRAY
52045: PUSH
52046: LD_INT 1
52048: GREATER
52049: AND
52050: IFFALSE 52181
// begin ComCancel ( j ) ;
52052: LD_VAR 0 3
52056: PPUSH
52057: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52061: LD_ADDR_EXP 143
52065: PUSH
52066: LD_EXP 143
52070: PPUSH
52071: LD_VAR 0 4
52075: PPUSH
52076: LD_EXP 143
52080: PUSH
52081: LD_VAR 0 4
52085: ARRAY
52086: PPUSH
52087: LD_EXP 143
52091: PUSH
52092: LD_VAR 0 4
52096: ARRAY
52097: PUSH
52098: LD_INT 1
52100: MINUS
52101: PPUSH
52102: LD_EXP 143
52106: PUSH
52107: LD_VAR 0 4
52111: ARRAY
52112: PPUSH
52113: LD_INT 0
52115: PPUSH
52116: CALL 69957 0 4
52120: PPUSH
52121: CALL_OW 1
52125: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52126: LD_ADDR_EXP 143
52130: PUSH
52131: LD_EXP 143
52135: PPUSH
52136: LD_VAR 0 4
52140: PPUSH
52141: LD_EXP 143
52145: PUSH
52146: LD_VAR 0 4
52150: ARRAY
52151: PPUSH
52152: LD_EXP 143
52156: PUSH
52157: LD_VAR 0 4
52161: ARRAY
52162: PPUSH
52163: LD_INT 1
52165: PPUSH
52166: LD_INT 0
52168: PPUSH
52169: CALL 69957 0 4
52173: PPUSH
52174: CALL_OW 1
52178: ST_TO_ADDR
// continue ;
52179: GO 51753
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52181: LD_EXP 145
52185: PUSH
52186: LD_VAR 0 2
52190: ARRAY
52191: PUSH
52192: LD_EXP 146
52196: PUSH
52197: LD_VAR 0 2
52201: ARRAY
52202: NOT
52203: AND
52204: IFFALSE 52331
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52206: LD_ADDR_EXP 146
52210: PUSH
52211: LD_EXP 146
52215: PPUSH
52216: LD_VAR 0 2
52220: PUSH
52221: LD_EXP 146
52225: PUSH
52226: LD_VAR 0 2
52230: ARRAY
52231: PUSH
52232: LD_INT 1
52234: PLUS
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: PPUSH
52240: LD_EXP 145
52244: PUSH
52245: LD_VAR 0 2
52249: ARRAY
52250: PUSH
52251: LD_INT 1
52253: ARRAY
52254: PPUSH
52255: CALL 70539 0 3
52259: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52260: LD_EXP 145
52264: PUSH
52265: LD_VAR 0 2
52269: ARRAY
52270: PUSH
52271: LD_INT 1
52273: ARRAY
52274: PPUSH
52275: LD_INT 112
52277: PPUSH
52278: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52282: LD_ADDR_VAR 0 9
52286: PUSH
52287: LD_EXP 145
52291: PUSH
52292: LD_VAR 0 2
52296: ARRAY
52297: PPUSH
52298: LD_INT 1
52300: PPUSH
52301: CALL_OW 3
52305: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52306: LD_ADDR_EXP 145
52310: PUSH
52311: LD_EXP 145
52315: PPUSH
52316: LD_VAR 0 2
52320: PPUSH
52321: LD_VAR 0 9
52325: PPUSH
52326: CALL_OW 1
52330: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52331: LD_EXP 145
52335: PUSH
52336: LD_VAR 0 2
52340: ARRAY
52341: PUSH
52342: LD_EXP 146
52346: PUSH
52347: LD_VAR 0 2
52351: ARRAY
52352: AND
52353: PUSH
52354: LD_EXP 146
52358: PUSH
52359: LD_VAR 0 2
52363: ARRAY
52364: PUSH
52365: LD_INT 1
52367: ARRAY
52368: PPUSH
52369: CALL_OW 310
52373: NOT
52374: AND
52375: PUSH
52376: LD_VAR 0 3
52380: PPUSH
52381: CALL_OW 313
52385: PUSH
52386: LD_INT 6
52388: EQUAL
52389: AND
52390: IFFALSE 52446
// begin tmp2 := UnitsInside ( j ) ;
52392: LD_ADDR_VAR 0 9
52396: PUSH
52397: LD_VAR 0 3
52401: PPUSH
52402: CALL_OW 313
52406: ST_TO_ADDR
// if tmp2 = 6 then
52407: LD_VAR 0 9
52411: PUSH
52412: LD_INT 6
52414: EQUAL
52415: IFFALSE 52446
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52417: LD_VAR 0 9
52421: PUSH
52422: LD_INT 1
52424: ARRAY
52425: PPUSH
52426: LD_INT 112
52428: PPUSH
52429: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52433: LD_VAR 0 9
52437: PUSH
52438: LD_INT 1
52440: ARRAY
52441: PPUSH
52442: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52446: LD_EXP 146
52450: PUSH
52451: LD_VAR 0 2
52455: ARRAY
52456: PUSH
52457: LD_EXP 146
52461: PUSH
52462: LD_VAR 0 2
52466: ARRAY
52467: PUSH
52468: LD_INT 1
52470: ARRAY
52471: PPUSH
52472: CALL_OW 314
52476: NOT
52477: AND
52478: PUSH
52479: LD_EXP 146
52483: PUSH
52484: LD_VAR 0 2
52488: ARRAY
52489: PUSH
52490: LD_INT 1
52492: ARRAY
52493: PPUSH
52494: CALL_OW 310
52498: NOT
52499: AND
52500: IFFALSE 52526
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52502: LD_EXP 146
52506: PUSH
52507: LD_VAR 0 2
52511: ARRAY
52512: PUSH
52513: LD_INT 1
52515: ARRAY
52516: PPUSH
52517: LD_VAR 0 3
52521: PPUSH
52522: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52526: LD_EXP 146
52530: PUSH
52531: LD_VAR 0 2
52535: ARRAY
52536: PUSH
52537: LD_INT 1
52539: ARRAY
52540: PPUSH
52541: CALL_OW 310
52545: PUSH
52546: LD_EXP 146
52550: PUSH
52551: LD_VAR 0 2
52555: ARRAY
52556: PUSH
52557: LD_INT 1
52559: ARRAY
52560: PPUSH
52561: CALL_OW 310
52565: PPUSH
52566: CALL_OW 461
52570: PUSH
52571: LD_INT 3
52573: NONEQUAL
52574: AND
52575: IFFALSE 52596
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52577: LD_EXP 146
52581: PUSH
52582: LD_VAR 0 2
52586: ARRAY
52587: PUSH
52588: LD_INT 1
52590: ARRAY
52591: PPUSH
52592: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52596: LD_VAR 0 3
52600: PPUSH
52601: CALL_OW 461
52605: PUSH
52606: LD_INT 6
52608: EQUAL
52609: PUSH
52610: LD_VAR 0 6
52614: PUSH
52615: LD_INT 1
52617: GREATER
52618: AND
52619: IFFALSE 52771
// begin sci := [ ] ;
52621: LD_ADDR_VAR 0 8
52625: PUSH
52626: EMPTY
52627: ST_TO_ADDR
// for x in ( tmp diff j ) do
52628: LD_ADDR_VAR 0 7
52632: PUSH
52633: LD_VAR 0 6
52637: PUSH
52638: LD_VAR 0 3
52642: DIFF
52643: PUSH
52644: FOR_IN
52645: IFFALSE 52697
// begin if sci = 6 then
52647: LD_VAR 0 8
52651: PUSH
52652: LD_INT 6
52654: EQUAL
52655: IFFALSE 52659
// break ;
52657: GO 52697
// if BuildingStatus ( x ) = bs_idle then
52659: LD_VAR 0 7
52663: PPUSH
52664: CALL_OW 461
52668: PUSH
52669: LD_INT 2
52671: EQUAL
52672: IFFALSE 52695
// sci := sci ^ UnitsInside ( x ) ;
52674: LD_ADDR_VAR 0 8
52678: PUSH
52679: LD_VAR 0 8
52683: PUSH
52684: LD_VAR 0 7
52688: PPUSH
52689: CALL_OW 313
52693: ADD
52694: ST_TO_ADDR
// end ;
52695: GO 52644
52697: POP
52698: POP
// if not sci then
52699: LD_VAR 0 8
52703: NOT
52704: IFFALSE 52708
// continue ;
52706: GO 51753
// for x in sci do
52708: LD_ADDR_VAR 0 7
52712: PUSH
52713: LD_VAR 0 8
52717: PUSH
52718: FOR_IN
52719: IFFALSE 52769
// if IsInUnit ( x ) and not HasTask ( x ) then
52721: LD_VAR 0 7
52725: PPUSH
52726: CALL_OW 310
52730: PUSH
52731: LD_VAR 0 7
52735: PPUSH
52736: CALL_OW 314
52740: NOT
52741: AND
52742: IFFALSE 52767
// begin ComExitBuilding ( x ) ;
52744: LD_VAR 0 7
52748: PPUSH
52749: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52753: LD_VAR 0 7
52757: PPUSH
52758: LD_VAR 0 3
52762: PPUSH
52763: CALL_OW 180
// end ;
52767: GO 52718
52769: POP
52770: POP
// end ; end ;
52771: GO 51753
52773: POP
52774: POP
// end ;
52775: GO 51707
52777: POP
52778: POP
// end ;
52779: LD_VAR 0 1
52783: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52784: LD_INT 0
52786: PPUSH
52787: PPUSH
// if not mc_bases then
52788: LD_EXP 116
52792: NOT
52793: IFFALSE 52797
// exit ;
52795: GO 52878
// for i = 1 to mc_bases do
52797: LD_ADDR_VAR 0 2
52801: PUSH
52802: DOUBLE
52803: LD_INT 1
52805: DEC
52806: ST_TO_ADDR
52807: LD_EXP 116
52811: PUSH
52812: FOR_TO
52813: IFFALSE 52876
// if mc_mines [ i ] and mc_miners [ i ] then
52815: LD_EXP 129
52819: PUSH
52820: LD_VAR 0 2
52824: ARRAY
52825: PUSH
52826: LD_EXP 130
52830: PUSH
52831: LD_VAR 0 2
52835: ARRAY
52836: AND
52837: IFFALSE 52874
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52839: LD_EXP 130
52843: PUSH
52844: LD_VAR 0 2
52848: ARRAY
52849: PUSH
52850: LD_INT 1
52852: ARRAY
52853: PPUSH
52854: CALL_OW 255
52858: PPUSH
52859: LD_EXP 129
52863: PUSH
52864: LD_VAR 0 2
52868: ARRAY
52869: PPUSH
52870: CALL 67492 0 2
52874: GO 52812
52876: POP
52877: POP
// end ;
52878: LD_VAR 0 1
52882: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52883: LD_INT 0
52885: PPUSH
52886: PPUSH
52887: PPUSH
52888: PPUSH
52889: PPUSH
52890: PPUSH
52891: PPUSH
52892: PPUSH
// if not mc_bases or not mc_parking then
52893: LD_EXP 116
52897: NOT
52898: PUSH
52899: LD_EXP 140
52903: NOT
52904: OR
52905: IFFALSE 52909
// exit ;
52907: GO 53619
// for i = 1 to mc_bases do
52909: LD_ADDR_VAR 0 2
52913: PUSH
52914: DOUBLE
52915: LD_INT 1
52917: DEC
52918: ST_TO_ADDR
52919: LD_EXP 116
52923: PUSH
52924: FOR_TO
52925: IFFALSE 53617
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52927: LD_EXP 116
52931: PUSH
52932: LD_VAR 0 2
52936: ARRAY
52937: NOT
52938: PUSH
52939: LD_EXP 140
52943: PUSH
52944: LD_VAR 0 2
52948: ARRAY
52949: NOT
52950: OR
52951: IFFALSE 52955
// continue ;
52953: GO 52924
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52955: LD_ADDR_VAR 0 5
52959: PUSH
52960: LD_EXP 116
52964: PUSH
52965: LD_VAR 0 2
52969: ARRAY
52970: PUSH
52971: LD_INT 1
52973: ARRAY
52974: PPUSH
52975: CALL_OW 255
52979: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52980: LD_ADDR_VAR 0 6
52984: PUSH
52985: LD_EXP 116
52989: PUSH
52990: LD_VAR 0 2
52994: ARRAY
52995: PPUSH
52996: LD_INT 30
52998: PUSH
52999: LD_INT 3
53001: PUSH
53002: EMPTY
53003: LIST
53004: LIST
53005: PPUSH
53006: CALL_OW 72
53010: ST_TO_ADDR
// if not fac then
53011: LD_VAR 0 6
53015: NOT
53016: IFFALSE 53067
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53018: LD_ADDR_VAR 0 6
53022: PUSH
53023: LD_EXP 116
53027: PUSH
53028: LD_VAR 0 2
53032: ARRAY
53033: PPUSH
53034: LD_INT 2
53036: PUSH
53037: LD_INT 30
53039: PUSH
53040: LD_INT 0
53042: PUSH
53043: EMPTY
53044: LIST
53045: LIST
53046: PUSH
53047: LD_INT 30
53049: PUSH
53050: LD_INT 1
53052: PUSH
53053: EMPTY
53054: LIST
53055: LIST
53056: PUSH
53057: EMPTY
53058: LIST
53059: LIST
53060: LIST
53061: PPUSH
53062: CALL_OW 72
53066: ST_TO_ADDR
// if not fac then
53067: LD_VAR 0 6
53071: NOT
53072: IFFALSE 53076
// continue ;
53074: GO 52924
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53076: LD_ADDR_VAR 0 7
53080: PUSH
53081: LD_EXP 140
53085: PUSH
53086: LD_VAR 0 2
53090: ARRAY
53091: PPUSH
53092: LD_INT 22
53094: PUSH
53095: LD_VAR 0 5
53099: PUSH
53100: EMPTY
53101: LIST
53102: LIST
53103: PUSH
53104: LD_INT 21
53106: PUSH
53107: LD_INT 2
53109: PUSH
53110: EMPTY
53111: LIST
53112: LIST
53113: PUSH
53114: LD_INT 3
53116: PUSH
53117: LD_INT 24
53119: PUSH
53120: LD_INT 1000
53122: PUSH
53123: EMPTY
53124: LIST
53125: LIST
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: PUSH
53131: EMPTY
53132: LIST
53133: LIST
53134: LIST
53135: PPUSH
53136: CALL_OW 70
53140: ST_TO_ADDR
// for j in fac do
53141: LD_ADDR_VAR 0 3
53145: PUSH
53146: LD_VAR 0 6
53150: PUSH
53151: FOR_IN
53152: IFFALSE 53233
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53154: LD_ADDR_VAR 0 7
53158: PUSH
53159: LD_VAR 0 7
53163: PUSH
53164: LD_INT 22
53166: PUSH
53167: LD_VAR 0 5
53171: PUSH
53172: EMPTY
53173: LIST
53174: LIST
53175: PUSH
53176: LD_INT 91
53178: PUSH
53179: LD_VAR 0 3
53183: PUSH
53184: LD_INT 15
53186: PUSH
53187: EMPTY
53188: LIST
53189: LIST
53190: LIST
53191: PUSH
53192: LD_INT 21
53194: PUSH
53195: LD_INT 2
53197: PUSH
53198: EMPTY
53199: LIST
53200: LIST
53201: PUSH
53202: LD_INT 3
53204: PUSH
53205: LD_INT 24
53207: PUSH
53208: LD_INT 1000
53210: PUSH
53211: EMPTY
53212: LIST
53213: LIST
53214: PUSH
53215: EMPTY
53216: LIST
53217: LIST
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: LIST
53223: LIST
53224: PPUSH
53225: CALL_OW 69
53229: UNION
53230: ST_TO_ADDR
53231: GO 53151
53233: POP
53234: POP
// if not vehs then
53235: LD_VAR 0 7
53239: NOT
53240: IFFALSE 53266
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53242: LD_ADDR_EXP 128
53246: PUSH
53247: LD_EXP 128
53251: PPUSH
53252: LD_VAR 0 2
53256: PPUSH
53257: EMPTY
53258: PPUSH
53259: CALL_OW 1
53263: ST_TO_ADDR
// continue ;
53264: GO 52924
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53266: LD_ADDR_VAR 0 8
53270: PUSH
53271: LD_EXP 116
53275: PUSH
53276: LD_VAR 0 2
53280: ARRAY
53281: PPUSH
53282: LD_INT 30
53284: PUSH
53285: LD_INT 3
53287: PUSH
53288: EMPTY
53289: LIST
53290: LIST
53291: PPUSH
53292: CALL_OW 72
53296: ST_TO_ADDR
// if tmp then
53297: LD_VAR 0 8
53301: IFFALSE 53404
// begin for j in tmp do
53303: LD_ADDR_VAR 0 3
53307: PUSH
53308: LD_VAR 0 8
53312: PUSH
53313: FOR_IN
53314: IFFALSE 53402
// for k in UnitsInside ( j ) do
53316: LD_ADDR_VAR 0 4
53320: PUSH
53321: LD_VAR 0 3
53325: PPUSH
53326: CALL_OW 313
53330: PUSH
53331: FOR_IN
53332: IFFALSE 53398
// if k then
53334: LD_VAR 0 4
53338: IFFALSE 53396
// if not k in mc_repair_vehicle [ i ] then
53340: LD_VAR 0 4
53344: PUSH
53345: LD_EXP 128
53349: PUSH
53350: LD_VAR 0 2
53354: ARRAY
53355: IN
53356: NOT
53357: IFFALSE 53396
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53359: LD_ADDR_EXP 128
53363: PUSH
53364: LD_EXP 128
53368: PPUSH
53369: LD_VAR 0 2
53373: PPUSH
53374: LD_EXP 128
53378: PUSH
53379: LD_VAR 0 2
53383: ARRAY
53384: PUSH
53385: LD_VAR 0 4
53389: UNION
53390: PPUSH
53391: CALL_OW 1
53395: ST_TO_ADDR
53396: GO 53331
53398: POP
53399: POP
53400: GO 53313
53402: POP
53403: POP
// end ; if not mc_repair_vehicle [ i ] then
53404: LD_EXP 128
53408: PUSH
53409: LD_VAR 0 2
53413: ARRAY
53414: NOT
53415: IFFALSE 53419
// continue ;
53417: GO 52924
// for j in mc_repair_vehicle [ i ] do
53419: LD_ADDR_VAR 0 3
53423: PUSH
53424: LD_EXP 128
53428: PUSH
53429: LD_VAR 0 2
53433: ARRAY
53434: PUSH
53435: FOR_IN
53436: IFFALSE 53613
// begin if GetClass ( j ) <> 3 then
53438: LD_VAR 0 3
53442: PPUSH
53443: CALL_OW 257
53447: PUSH
53448: LD_INT 3
53450: NONEQUAL
53451: IFFALSE 53492
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53453: LD_ADDR_EXP 128
53457: PUSH
53458: LD_EXP 128
53462: PPUSH
53463: LD_VAR 0 2
53467: PPUSH
53468: LD_EXP 128
53472: PUSH
53473: LD_VAR 0 2
53477: ARRAY
53478: PUSH
53479: LD_VAR 0 3
53483: DIFF
53484: PPUSH
53485: CALL_OW 1
53489: ST_TO_ADDR
// continue ;
53490: GO 53435
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53492: LD_VAR 0 3
53496: PPUSH
53497: CALL_OW 311
53501: NOT
53502: PUSH
53503: LD_VAR 0 3
53507: PUSH
53508: LD_EXP 119
53512: PUSH
53513: LD_VAR 0 2
53517: ARRAY
53518: PUSH
53519: LD_INT 1
53521: ARRAY
53522: IN
53523: NOT
53524: AND
53525: PUSH
53526: LD_VAR 0 3
53530: PUSH
53531: LD_EXP 119
53535: PUSH
53536: LD_VAR 0 2
53540: ARRAY
53541: PUSH
53542: LD_INT 2
53544: ARRAY
53545: IN
53546: NOT
53547: AND
53548: IFFALSE 53611
// begin if IsInUnit ( j ) then
53550: LD_VAR 0 3
53554: PPUSH
53555: CALL_OW 310
53559: IFFALSE 53572
// ComExitBuilding ( j ) else
53561: LD_VAR 0 3
53565: PPUSH
53566: CALL_OW 122
53570: GO 53611
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53572: LD_VAR 0 3
53576: PPUSH
53577: LD_VAR 0 7
53581: PUSH
53582: LD_INT 1
53584: ARRAY
53585: PPUSH
53586: CALL 104147 0 2
53590: NOT
53591: IFFALSE 53611
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53593: LD_VAR 0 3
53597: PPUSH
53598: LD_VAR 0 7
53602: PUSH
53603: LD_INT 1
53605: ARRAY
53606: PPUSH
53607: CALL_OW 129
// end ; end ;
53611: GO 53435
53613: POP
53614: POP
// end ;
53615: GO 52924
53617: POP
53618: POP
// end ;
53619: LD_VAR 0 1
53623: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53624: LD_INT 0
53626: PPUSH
53627: PPUSH
53628: PPUSH
53629: PPUSH
53630: PPUSH
53631: PPUSH
53632: PPUSH
53633: PPUSH
53634: PPUSH
53635: PPUSH
53636: PPUSH
// if not mc_bases then
53637: LD_EXP 116
53641: NOT
53642: IFFALSE 53646
// exit ;
53644: GO 54448
// for i = 1 to mc_bases do
53646: LD_ADDR_VAR 0 2
53650: PUSH
53651: DOUBLE
53652: LD_INT 1
53654: DEC
53655: ST_TO_ADDR
53656: LD_EXP 116
53660: PUSH
53661: FOR_TO
53662: IFFALSE 54446
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53664: LD_EXP 144
53668: PUSH
53669: LD_VAR 0 2
53673: ARRAY
53674: NOT
53675: PUSH
53676: LD_EXP 119
53680: PUSH
53681: LD_VAR 0 2
53685: ARRAY
53686: PUSH
53687: LD_INT 1
53689: ARRAY
53690: OR
53691: PUSH
53692: LD_EXP 119
53696: PUSH
53697: LD_VAR 0 2
53701: ARRAY
53702: PUSH
53703: LD_INT 2
53705: ARRAY
53706: OR
53707: PUSH
53708: LD_EXP 142
53712: PUSH
53713: LD_VAR 0 2
53717: ARRAY
53718: PPUSH
53719: LD_INT 1
53721: PPUSH
53722: CALL_OW 325
53726: NOT
53727: OR
53728: PUSH
53729: LD_EXP 139
53733: PUSH
53734: LD_VAR 0 2
53738: ARRAY
53739: OR
53740: IFFALSE 53744
// continue ;
53742: GO 53661
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53744: LD_ADDR_VAR 0 8
53748: PUSH
53749: LD_EXP 116
53753: PUSH
53754: LD_VAR 0 2
53758: ARRAY
53759: PPUSH
53760: LD_INT 25
53762: PUSH
53763: LD_INT 4
53765: PUSH
53766: EMPTY
53767: LIST
53768: LIST
53769: PUSH
53770: LD_INT 50
53772: PUSH
53773: EMPTY
53774: LIST
53775: PUSH
53776: LD_INT 3
53778: PUSH
53779: LD_INT 60
53781: PUSH
53782: EMPTY
53783: LIST
53784: PUSH
53785: EMPTY
53786: LIST
53787: LIST
53788: PUSH
53789: EMPTY
53790: LIST
53791: LIST
53792: LIST
53793: PPUSH
53794: CALL_OW 72
53798: PUSH
53799: LD_EXP 120
53803: PUSH
53804: LD_VAR 0 2
53808: ARRAY
53809: DIFF
53810: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53811: LD_ADDR_VAR 0 9
53815: PUSH
53816: LD_EXP 116
53820: PUSH
53821: LD_VAR 0 2
53825: ARRAY
53826: PPUSH
53827: LD_INT 2
53829: PUSH
53830: LD_INT 30
53832: PUSH
53833: LD_INT 0
53835: PUSH
53836: EMPTY
53837: LIST
53838: LIST
53839: PUSH
53840: LD_INT 30
53842: PUSH
53843: LD_INT 1
53845: PUSH
53846: EMPTY
53847: LIST
53848: LIST
53849: PUSH
53850: EMPTY
53851: LIST
53852: LIST
53853: LIST
53854: PPUSH
53855: CALL_OW 72
53859: ST_TO_ADDR
// if not tmp or not dep then
53860: LD_VAR 0 8
53864: NOT
53865: PUSH
53866: LD_VAR 0 9
53870: NOT
53871: OR
53872: IFFALSE 53876
// continue ;
53874: GO 53661
// side := GetSide ( tmp [ 1 ] ) ;
53876: LD_ADDR_VAR 0 11
53880: PUSH
53881: LD_VAR 0 8
53885: PUSH
53886: LD_INT 1
53888: ARRAY
53889: PPUSH
53890: CALL_OW 255
53894: ST_TO_ADDR
// dep := dep [ 1 ] ;
53895: LD_ADDR_VAR 0 9
53899: PUSH
53900: LD_VAR 0 9
53904: PUSH
53905: LD_INT 1
53907: ARRAY
53908: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53909: LD_ADDR_VAR 0 7
53913: PUSH
53914: LD_EXP 144
53918: PUSH
53919: LD_VAR 0 2
53923: ARRAY
53924: PPUSH
53925: LD_INT 22
53927: PUSH
53928: LD_INT 0
53930: PUSH
53931: EMPTY
53932: LIST
53933: LIST
53934: PUSH
53935: LD_INT 25
53937: PUSH
53938: LD_INT 12
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: PUSH
53945: EMPTY
53946: LIST
53947: LIST
53948: PPUSH
53949: CALL_OW 70
53953: PUSH
53954: LD_INT 22
53956: PUSH
53957: LD_INT 0
53959: PUSH
53960: EMPTY
53961: LIST
53962: LIST
53963: PUSH
53964: LD_INT 25
53966: PUSH
53967: LD_INT 12
53969: PUSH
53970: EMPTY
53971: LIST
53972: LIST
53973: PUSH
53974: LD_INT 91
53976: PUSH
53977: LD_VAR 0 9
53981: PUSH
53982: LD_INT 20
53984: PUSH
53985: EMPTY
53986: LIST
53987: LIST
53988: LIST
53989: PUSH
53990: EMPTY
53991: LIST
53992: LIST
53993: LIST
53994: PPUSH
53995: CALL_OW 69
53999: UNION
54000: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54001: LD_ADDR_VAR 0 10
54005: PUSH
54006: LD_EXP 144
54010: PUSH
54011: LD_VAR 0 2
54015: ARRAY
54016: PPUSH
54017: LD_INT 81
54019: PUSH
54020: LD_VAR 0 11
54024: PUSH
54025: EMPTY
54026: LIST
54027: LIST
54028: PPUSH
54029: CALL_OW 70
54033: ST_TO_ADDR
// if not apes or danger_at_area then
54034: LD_VAR 0 7
54038: NOT
54039: PUSH
54040: LD_VAR 0 10
54044: OR
54045: IFFALSE 54095
// begin if mc_taming [ i ] then
54047: LD_EXP 147
54051: PUSH
54052: LD_VAR 0 2
54056: ARRAY
54057: IFFALSE 54093
// begin MC_Reset ( i , 121 ) ;
54059: LD_VAR 0 2
54063: PPUSH
54064: LD_INT 121
54066: PPUSH
54067: CALL 39297 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54071: LD_ADDR_EXP 147
54075: PUSH
54076: LD_EXP 147
54080: PPUSH
54081: LD_VAR 0 2
54085: PPUSH
54086: EMPTY
54087: PPUSH
54088: CALL_OW 1
54092: ST_TO_ADDR
// end ; continue ;
54093: GO 53661
// end ; for j in tmp do
54095: LD_ADDR_VAR 0 3
54099: PUSH
54100: LD_VAR 0 8
54104: PUSH
54105: FOR_IN
54106: IFFALSE 54442
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54108: LD_VAR 0 3
54112: PUSH
54113: LD_EXP 147
54117: PUSH
54118: LD_VAR 0 2
54122: ARRAY
54123: IN
54124: NOT
54125: PUSH
54126: LD_EXP 147
54130: PUSH
54131: LD_VAR 0 2
54135: ARRAY
54136: PUSH
54137: LD_INT 3
54139: LESS
54140: AND
54141: IFFALSE 54199
// begin SetTag ( j , 121 ) ;
54143: LD_VAR 0 3
54147: PPUSH
54148: LD_INT 121
54150: PPUSH
54151: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54155: LD_ADDR_EXP 147
54159: PUSH
54160: LD_EXP 147
54164: PPUSH
54165: LD_VAR 0 2
54169: PUSH
54170: LD_EXP 147
54174: PUSH
54175: LD_VAR 0 2
54179: ARRAY
54180: PUSH
54181: LD_INT 1
54183: PLUS
54184: PUSH
54185: EMPTY
54186: LIST
54187: LIST
54188: PPUSH
54189: LD_VAR 0 3
54193: PPUSH
54194: CALL 70539 0 3
54198: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54199: LD_VAR 0 3
54203: PUSH
54204: LD_EXP 147
54208: PUSH
54209: LD_VAR 0 2
54213: ARRAY
54214: IN
54215: IFFALSE 54440
// begin if GetClass ( j ) <> 4 then
54217: LD_VAR 0 3
54221: PPUSH
54222: CALL_OW 257
54226: PUSH
54227: LD_INT 4
54229: NONEQUAL
54230: IFFALSE 54283
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54232: LD_ADDR_EXP 147
54236: PUSH
54237: LD_EXP 147
54241: PPUSH
54242: LD_VAR 0 2
54246: PPUSH
54247: LD_EXP 147
54251: PUSH
54252: LD_VAR 0 2
54256: ARRAY
54257: PUSH
54258: LD_VAR 0 3
54262: DIFF
54263: PPUSH
54264: CALL_OW 1
54268: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54269: LD_VAR 0 3
54273: PPUSH
54274: LD_INT 0
54276: PPUSH
54277: CALL_OW 109
// continue ;
54281: GO 54105
// end ; if IsInUnit ( j ) then
54283: LD_VAR 0 3
54287: PPUSH
54288: CALL_OW 310
54292: IFFALSE 54303
// ComExitBuilding ( j ) ;
54294: LD_VAR 0 3
54298: PPUSH
54299: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54303: LD_ADDR_VAR 0 6
54307: PUSH
54308: LD_VAR 0 7
54312: PPUSH
54313: LD_VAR 0 3
54317: PPUSH
54318: CALL_OW 74
54322: ST_TO_ADDR
// if not ape then
54323: LD_VAR 0 6
54327: NOT
54328: IFFALSE 54332
// break ;
54330: GO 54442
// x := GetX ( ape ) ;
54332: LD_ADDR_VAR 0 4
54336: PUSH
54337: LD_VAR 0 6
54341: PPUSH
54342: CALL_OW 250
54346: ST_TO_ADDR
// y := GetY ( ape ) ;
54347: LD_ADDR_VAR 0 5
54351: PUSH
54352: LD_VAR 0 6
54356: PPUSH
54357: CALL_OW 251
54361: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54362: LD_VAR 0 4
54366: PPUSH
54367: LD_VAR 0 5
54371: PPUSH
54372: CALL_OW 488
54376: NOT
54377: PUSH
54378: LD_VAR 0 11
54382: PPUSH
54383: LD_VAR 0 4
54387: PPUSH
54388: LD_VAR 0 5
54392: PPUSH
54393: LD_INT 20
54395: PPUSH
54396: CALL 71435 0 4
54400: PUSH
54401: LD_INT 4
54403: ARRAY
54404: OR
54405: IFFALSE 54409
// break ;
54407: GO 54442
// if not HasTask ( j ) then
54409: LD_VAR 0 3
54413: PPUSH
54414: CALL_OW 314
54418: NOT
54419: IFFALSE 54440
// ComTameXY ( j , x , y ) ;
54421: LD_VAR 0 3
54425: PPUSH
54426: LD_VAR 0 4
54430: PPUSH
54431: LD_VAR 0 5
54435: PPUSH
54436: CALL_OW 131
// end ; end ;
54440: GO 54105
54442: POP
54443: POP
// end ;
54444: GO 53661
54446: POP
54447: POP
// end ;
54448: LD_VAR 0 1
54452: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54453: LD_INT 0
54455: PPUSH
54456: PPUSH
54457: PPUSH
54458: PPUSH
54459: PPUSH
54460: PPUSH
54461: PPUSH
54462: PPUSH
// if not mc_bases then
54463: LD_EXP 116
54467: NOT
54468: IFFALSE 54472
// exit ;
54470: GO 55098
// for i = 1 to mc_bases do
54472: LD_ADDR_VAR 0 2
54476: PUSH
54477: DOUBLE
54478: LD_INT 1
54480: DEC
54481: ST_TO_ADDR
54482: LD_EXP 116
54486: PUSH
54487: FOR_TO
54488: IFFALSE 55096
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54490: LD_EXP 145
54494: PUSH
54495: LD_VAR 0 2
54499: ARRAY
54500: NOT
54501: PUSH
54502: LD_EXP 145
54506: PUSH
54507: LD_VAR 0 2
54511: ARRAY
54512: PPUSH
54513: LD_INT 25
54515: PUSH
54516: LD_INT 12
54518: PUSH
54519: EMPTY
54520: LIST
54521: LIST
54522: PPUSH
54523: CALL_OW 72
54527: NOT
54528: OR
54529: IFFALSE 54533
// continue ;
54531: GO 54487
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54533: LD_ADDR_VAR 0 5
54537: PUSH
54538: LD_EXP 145
54542: PUSH
54543: LD_VAR 0 2
54547: ARRAY
54548: PUSH
54549: LD_INT 1
54551: ARRAY
54552: PPUSH
54553: CALL_OW 255
54557: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54558: LD_VAR 0 5
54562: PPUSH
54563: LD_INT 2
54565: PPUSH
54566: CALL_OW 325
54570: IFFALSE 54823
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54572: LD_ADDR_VAR 0 4
54576: PUSH
54577: LD_EXP 145
54581: PUSH
54582: LD_VAR 0 2
54586: ARRAY
54587: PPUSH
54588: LD_INT 25
54590: PUSH
54591: LD_INT 16
54593: PUSH
54594: EMPTY
54595: LIST
54596: LIST
54597: PPUSH
54598: CALL_OW 72
54602: ST_TO_ADDR
// if tmp < 6 then
54603: LD_VAR 0 4
54607: PUSH
54608: LD_INT 6
54610: LESS
54611: IFFALSE 54823
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54613: LD_ADDR_VAR 0 6
54617: PUSH
54618: LD_EXP 116
54622: PUSH
54623: LD_VAR 0 2
54627: ARRAY
54628: PPUSH
54629: LD_INT 2
54631: PUSH
54632: LD_INT 30
54634: PUSH
54635: LD_INT 0
54637: PUSH
54638: EMPTY
54639: LIST
54640: LIST
54641: PUSH
54642: LD_INT 30
54644: PUSH
54645: LD_INT 1
54647: PUSH
54648: EMPTY
54649: LIST
54650: LIST
54651: PUSH
54652: EMPTY
54653: LIST
54654: LIST
54655: LIST
54656: PPUSH
54657: CALL_OW 72
54661: ST_TO_ADDR
// if depot then
54662: LD_VAR 0 6
54666: IFFALSE 54823
// begin selected := 0 ;
54668: LD_ADDR_VAR 0 7
54672: PUSH
54673: LD_INT 0
54675: ST_TO_ADDR
// for j in depot do
54676: LD_ADDR_VAR 0 3
54680: PUSH
54681: LD_VAR 0 6
54685: PUSH
54686: FOR_IN
54687: IFFALSE 54718
// begin if UnitsInside ( j ) < 6 then
54689: LD_VAR 0 3
54693: PPUSH
54694: CALL_OW 313
54698: PUSH
54699: LD_INT 6
54701: LESS
54702: IFFALSE 54716
// begin selected := j ;
54704: LD_ADDR_VAR 0 7
54708: PUSH
54709: LD_VAR 0 3
54713: ST_TO_ADDR
// break ;
54714: GO 54718
// end ; end ;
54716: GO 54686
54718: POP
54719: POP
// if selected then
54720: LD_VAR 0 7
54724: IFFALSE 54823
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54726: LD_ADDR_VAR 0 3
54730: PUSH
54731: LD_EXP 145
54735: PUSH
54736: LD_VAR 0 2
54740: ARRAY
54741: PPUSH
54742: LD_INT 25
54744: PUSH
54745: LD_INT 12
54747: PUSH
54748: EMPTY
54749: LIST
54750: LIST
54751: PPUSH
54752: CALL_OW 72
54756: PUSH
54757: FOR_IN
54758: IFFALSE 54821
// if not HasTask ( j ) then
54760: LD_VAR 0 3
54764: PPUSH
54765: CALL_OW 314
54769: NOT
54770: IFFALSE 54819
// begin if not IsInUnit ( j ) then
54772: LD_VAR 0 3
54776: PPUSH
54777: CALL_OW 310
54781: NOT
54782: IFFALSE 54798
// ComEnterUnit ( j , selected ) ;
54784: LD_VAR 0 3
54788: PPUSH
54789: LD_VAR 0 7
54793: PPUSH
54794: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54798: LD_VAR 0 3
54802: PPUSH
54803: LD_INT 16
54805: PPUSH
54806: CALL_OW 183
// AddComExitBuilding ( j ) ;
54810: LD_VAR 0 3
54814: PPUSH
54815: CALL_OW 182
// end ;
54819: GO 54757
54821: POP
54822: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54823: LD_VAR 0 5
54827: PPUSH
54828: LD_INT 11
54830: PPUSH
54831: CALL_OW 325
54835: IFFALSE 55094
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54837: LD_ADDR_VAR 0 4
54841: PUSH
54842: LD_EXP 145
54846: PUSH
54847: LD_VAR 0 2
54851: ARRAY
54852: PPUSH
54853: LD_INT 25
54855: PUSH
54856: LD_INT 16
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: PPUSH
54863: CALL_OW 72
54867: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54868: LD_VAR 0 4
54872: PUSH
54873: LD_INT 6
54875: GREATEREQUAL
54876: PUSH
54877: LD_VAR 0 5
54881: PPUSH
54882: LD_INT 2
54884: PPUSH
54885: CALL_OW 325
54889: NOT
54890: OR
54891: IFFALSE 55094
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54893: LD_ADDR_VAR 0 8
54897: PUSH
54898: LD_EXP 116
54902: PUSH
54903: LD_VAR 0 2
54907: ARRAY
54908: PPUSH
54909: LD_INT 2
54911: PUSH
54912: LD_INT 30
54914: PUSH
54915: LD_INT 4
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: PUSH
54922: LD_INT 30
54924: PUSH
54925: LD_INT 5
54927: PUSH
54928: EMPTY
54929: LIST
54930: LIST
54931: PUSH
54932: EMPTY
54933: LIST
54934: LIST
54935: LIST
54936: PPUSH
54937: CALL_OW 72
54941: ST_TO_ADDR
// if barracks then
54942: LD_VAR 0 8
54946: IFFALSE 55094
// begin selected := 0 ;
54948: LD_ADDR_VAR 0 7
54952: PUSH
54953: LD_INT 0
54955: ST_TO_ADDR
// for j in barracks do
54956: LD_ADDR_VAR 0 3
54960: PUSH
54961: LD_VAR 0 8
54965: PUSH
54966: FOR_IN
54967: IFFALSE 54998
// begin if UnitsInside ( j ) < 6 then
54969: LD_VAR 0 3
54973: PPUSH
54974: CALL_OW 313
54978: PUSH
54979: LD_INT 6
54981: LESS
54982: IFFALSE 54996
// begin selected := j ;
54984: LD_ADDR_VAR 0 7
54988: PUSH
54989: LD_VAR 0 3
54993: ST_TO_ADDR
// break ;
54994: GO 54998
// end ; end ;
54996: GO 54966
54998: POP
54999: POP
// if selected then
55000: LD_VAR 0 7
55004: IFFALSE 55094
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55006: LD_ADDR_VAR 0 3
55010: PUSH
55011: LD_EXP 145
55015: PUSH
55016: LD_VAR 0 2
55020: ARRAY
55021: PPUSH
55022: LD_INT 25
55024: PUSH
55025: LD_INT 12
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: PPUSH
55032: CALL_OW 72
55036: PUSH
55037: FOR_IN
55038: IFFALSE 55092
// if not IsInUnit ( j ) and not HasTask ( j ) then
55040: LD_VAR 0 3
55044: PPUSH
55045: CALL_OW 310
55049: NOT
55050: PUSH
55051: LD_VAR 0 3
55055: PPUSH
55056: CALL_OW 314
55060: NOT
55061: AND
55062: IFFALSE 55090
// begin ComEnterUnit ( j , selected ) ;
55064: LD_VAR 0 3
55068: PPUSH
55069: LD_VAR 0 7
55073: PPUSH
55074: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55078: LD_VAR 0 3
55082: PPUSH
55083: LD_INT 15
55085: PPUSH
55086: CALL_OW 183
// end ;
55090: GO 55037
55092: POP
55093: POP
// end ; end ; end ; end ; end ;
55094: GO 54487
55096: POP
55097: POP
// end ;
55098: LD_VAR 0 1
55102: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55103: LD_INT 0
55105: PPUSH
55106: PPUSH
55107: PPUSH
55108: PPUSH
// if not mc_bases then
55109: LD_EXP 116
55113: NOT
55114: IFFALSE 55118
// exit ;
55116: GO 55296
// for i = 1 to mc_bases do
55118: LD_ADDR_VAR 0 2
55122: PUSH
55123: DOUBLE
55124: LD_INT 1
55126: DEC
55127: ST_TO_ADDR
55128: LD_EXP 116
55132: PUSH
55133: FOR_TO
55134: IFFALSE 55294
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55136: LD_ADDR_VAR 0 4
55140: PUSH
55141: LD_EXP 116
55145: PUSH
55146: LD_VAR 0 2
55150: ARRAY
55151: PPUSH
55152: LD_INT 25
55154: PUSH
55155: LD_INT 9
55157: PUSH
55158: EMPTY
55159: LIST
55160: LIST
55161: PPUSH
55162: CALL_OW 72
55166: ST_TO_ADDR
// if not tmp then
55167: LD_VAR 0 4
55171: NOT
55172: IFFALSE 55176
// continue ;
55174: GO 55133
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55176: LD_EXP 142
55180: PUSH
55181: LD_VAR 0 2
55185: ARRAY
55186: PPUSH
55187: LD_INT 29
55189: PPUSH
55190: CALL_OW 325
55194: NOT
55195: PUSH
55196: LD_EXP 142
55200: PUSH
55201: LD_VAR 0 2
55205: ARRAY
55206: PPUSH
55207: LD_INT 28
55209: PPUSH
55210: CALL_OW 325
55214: NOT
55215: AND
55216: IFFALSE 55220
// continue ;
55218: GO 55133
// for j in tmp do
55220: LD_ADDR_VAR 0 3
55224: PUSH
55225: LD_VAR 0 4
55229: PUSH
55230: FOR_IN
55231: IFFALSE 55290
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55233: LD_VAR 0 3
55237: PUSH
55238: LD_EXP 119
55242: PUSH
55243: LD_VAR 0 2
55247: ARRAY
55248: PUSH
55249: LD_INT 1
55251: ARRAY
55252: IN
55253: NOT
55254: PUSH
55255: LD_VAR 0 3
55259: PUSH
55260: LD_EXP 119
55264: PUSH
55265: LD_VAR 0 2
55269: ARRAY
55270: PUSH
55271: LD_INT 2
55273: ARRAY
55274: IN
55275: NOT
55276: AND
55277: IFFALSE 55288
// ComSpaceTimeShoot ( j ) ;
55279: LD_VAR 0 3
55283: PPUSH
55284: CALL 66500 0 1
55288: GO 55230
55290: POP
55291: POP
// end ;
55292: GO 55133
55294: POP
55295: POP
// end ;
55296: LD_VAR 0 1
55300: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55301: LD_INT 0
55303: PPUSH
55304: PPUSH
55305: PPUSH
55306: PPUSH
55307: PPUSH
55308: PPUSH
55309: PPUSH
55310: PPUSH
55311: PPUSH
// if not mc_bases then
55312: LD_EXP 116
55316: NOT
55317: IFFALSE 55321
// exit ;
55319: GO 55943
// for i = 1 to mc_bases do
55321: LD_ADDR_VAR 0 2
55325: PUSH
55326: DOUBLE
55327: LD_INT 1
55329: DEC
55330: ST_TO_ADDR
55331: LD_EXP 116
55335: PUSH
55336: FOR_TO
55337: IFFALSE 55941
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55339: LD_EXP 151
55343: PUSH
55344: LD_VAR 0 2
55348: ARRAY
55349: NOT
55350: PUSH
55351: LD_INT 38
55353: PPUSH
55354: LD_EXP 142
55358: PUSH
55359: LD_VAR 0 2
55363: ARRAY
55364: PPUSH
55365: CALL_OW 321
55369: PUSH
55370: LD_INT 2
55372: NONEQUAL
55373: OR
55374: IFFALSE 55378
// continue ;
55376: GO 55336
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55378: LD_ADDR_VAR 0 8
55382: PUSH
55383: LD_EXP 116
55387: PUSH
55388: LD_VAR 0 2
55392: ARRAY
55393: PPUSH
55394: LD_INT 30
55396: PUSH
55397: LD_INT 34
55399: PUSH
55400: EMPTY
55401: LIST
55402: LIST
55403: PPUSH
55404: CALL_OW 72
55408: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55409: LD_ADDR_VAR 0 9
55413: PUSH
55414: LD_EXP 116
55418: PUSH
55419: LD_VAR 0 2
55423: ARRAY
55424: PPUSH
55425: LD_INT 25
55427: PUSH
55428: LD_INT 4
55430: PUSH
55431: EMPTY
55432: LIST
55433: LIST
55434: PPUSH
55435: CALL_OW 72
55439: PPUSH
55440: LD_INT 0
55442: PPUSH
55443: CALL 99809 0 2
55447: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55448: LD_VAR 0 9
55452: NOT
55453: PUSH
55454: LD_VAR 0 8
55458: NOT
55459: OR
55460: PUSH
55461: LD_EXP 116
55465: PUSH
55466: LD_VAR 0 2
55470: ARRAY
55471: PPUSH
55472: LD_INT 124
55474: PPUSH
55475: CALL 99809 0 2
55479: OR
55480: IFFALSE 55484
// continue ;
55482: GO 55336
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55484: LD_EXP 152
55488: PUSH
55489: LD_VAR 0 2
55493: ARRAY
55494: PUSH
55495: LD_EXP 151
55499: PUSH
55500: LD_VAR 0 2
55504: ARRAY
55505: LESS
55506: PUSH
55507: LD_EXP 152
55511: PUSH
55512: LD_VAR 0 2
55516: ARRAY
55517: PUSH
55518: LD_VAR 0 8
55522: LESS
55523: AND
55524: IFFALSE 55939
// begin tmp := sci [ 1 ] ;
55526: LD_ADDR_VAR 0 7
55530: PUSH
55531: LD_VAR 0 9
55535: PUSH
55536: LD_INT 1
55538: ARRAY
55539: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55540: LD_VAR 0 7
55544: PPUSH
55545: LD_INT 124
55547: PPUSH
55548: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55552: LD_ADDR_VAR 0 3
55556: PUSH
55557: DOUBLE
55558: LD_EXP 151
55562: PUSH
55563: LD_VAR 0 2
55567: ARRAY
55568: INC
55569: ST_TO_ADDR
55570: LD_EXP 151
55574: PUSH
55575: LD_VAR 0 2
55579: ARRAY
55580: PUSH
55581: FOR_DOWNTO
55582: IFFALSE 55925
// begin if IsInUnit ( tmp ) then
55584: LD_VAR 0 7
55588: PPUSH
55589: CALL_OW 310
55593: IFFALSE 55604
// ComExitBuilding ( tmp ) ;
55595: LD_VAR 0 7
55599: PPUSH
55600: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55604: LD_INT 35
55606: PPUSH
55607: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55611: LD_VAR 0 7
55615: PPUSH
55616: CALL_OW 310
55620: NOT
55621: PUSH
55622: LD_VAR 0 7
55626: PPUSH
55627: CALL_OW 314
55631: NOT
55632: AND
55633: IFFALSE 55604
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55635: LD_ADDR_VAR 0 6
55639: PUSH
55640: LD_VAR 0 7
55644: PPUSH
55645: CALL_OW 250
55649: PUSH
55650: LD_VAR 0 7
55654: PPUSH
55655: CALL_OW 251
55659: PUSH
55660: EMPTY
55661: LIST
55662: LIST
55663: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55664: LD_INT 35
55666: PPUSH
55667: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55671: LD_ADDR_VAR 0 4
55675: PUSH
55676: LD_EXP 151
55680: PUSH
55681: LD_VAR 0 2
55685: ARRAY
55686: PUSH
55687: LD_VAR 0 3
55691: ARRAY
55692: PUSH
55693: LD_INT 1
55695: ARRAY
55696: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55697: LD_ADDR_VAR 0 5
55701: PUSH
55702: LD_EXP 151
55706: PUSH
55707: LD_VAR 0 2
55711: ARRAY
55712: PUSH
55713: LD_VAR 0 3
55717: ARRAY
55718: PUSH
55719: LD_INT 2
55721: ARRAY
55722: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55723: LD_VAR 0 7
55727: PPUSH
55728: LD_INT 10
55730: PPUSH
55731: CALL 73138 0 2
55735: PUSH
55736: LD_INT 4
55738: ARRAY
55739: IFFALSE 55777
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55741: LD_VAR 0 7
55745: PPUSH
55746: LD_VAR 0 6
55750: PUSH
55751: LD_INT 1
55753: ARRAY
55754: PPUSH
55755: LD_VAR 0 6
55759: PUSH
55760: LD_INT 2
55762: ARRAY
55763: PPUSH
55764: CALL_OW 111
// wait ( 0 0$10 ) ;
55768: LD_INT 350
55770: PPUSH
55771: CALL_OW 67
// end else
55775: GO 55803
// begin ComMoveXY ( tmp , x , y ) ;
55777: LD_VAR 0 7
55781: PPUSH
55782: LD_VAR 0 4
55786: PPUSH
55787: LD_VAR 0 5
55791: PPUSH
55792: CALL_OW 111
// wait ( 0 0$3 ) ;
55796: LD_INT 105
55798: PPUSH
55799: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55803: LD_VAR 0 7
55807: PPUSH
55808: LD_VAR 0 4
55812: PPUSH
55813: LD_VAR 0 5
55817: PPUSH
55818: CALL_OW 307
55822: IFFALSE 55664
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55824: LD_VAR 0 7
55828: PPUSH
55829: LD_VAR 0 4
55833: PPUSH
55834: LD_VAR 0 5
55838: PPUSH
55839: LD_VAR 0 8
55843: PUSH
55844: LD_VAR 0 3
55848: ARRAY
55849: PPUSH
55850: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55854: LD_INT 35
55856: PPUSH
55857: CALL_OW 67
// until not HasTask ( tmp ) ;
55861: LD_VAR 0 7
55865: PPUSH
55866: CALL_OW 314
55870: NOT
55871: IFFALSE 55854
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55873: LD_ADDR_EXP 152
55877: PUSH
55878: LD_EXP 152
55882: PPUSH
55883: LD_VAR 0 2
55887: PUSH
55888: LD_EXP 152
55892: PUSH
55893: LD_VAR 0 2
55897: ARRAY
55898: PUSH
55899: LD_INT 1
55901: PLUS
55902: PUSH
55903: EMPTY
55904: LIST
55905: LIST
55906: PPUSH
55907: LD_VAR 0 8
55911: PUSH
55912: LD_VAR 0 3
55916: ARRAY
55917: PPUSH
55918: CALL 70539 0 3
55922: ST_TO_ADDR
// end ;
55923: GO 55581
55925: POP
55926: POP
// MC_Reset ( i , 124 ) ;
55927: LD_VAR 0 2
55931: PPUSH
55932: LD_INT 124
55934: PPUSH
55935: CALL 39297 0 2
// end ; end ;
55939: GO 55336
55941: POP
55942: POP
// end ;
55943: LD_VAR 0 1
55947: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55948: LD_INT 0
55950: PPUSH
55951: PPUSH
55952: PPUSH
// if not mc_bases then
55953: LD_EXP 116
55957: NOT
55958: IFFALSE 55962
// exit ;
55960: GO 56568
// for i = 1 to mc_bases do
55962: LD_ADDR_VAR 0 2
55966: PUSH
55967: DOUBLE
55968: LD_INT 1
55970: DEC
55971: ST_TO_ADDR
55972: LD_EXP 116
55976: PUSH
55977: FOR_TO
55978: IFFALSE 56566
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55980: LD_ADDR_VAR 0 3
55984: PUSH
55985: LD_EXP 116
55989: PUSH
55990: LD_VAR 0 2
55994: ARRAY
55995: PPUSH
55996: LD_INT 25
55998: PUSH
55999: LD_INT 4
56001: PUSH
56002: EMPTY
56003: LIST
56004: LIST
56005: PPUSH
56006: CALL_OW 72
56010: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56011: LD_VAR 0 3
56015: NOT
56016: PUSH
56017: LD_EXP 153
56021: PUSH
56022: LD_VAR 0 2
56026: ARRAY
56027: NOT
56028: OR
56029: PUSH
56030: LD_EXP 116
56034: PUSH
56035: LD_VAR 0 2
56039: ARRAY
56040: PPUSH
56041: LD_INT 2
56043: PUSH
56044: LD_INT 30
56046: PUSH
56047: LD_INT 0
56049: PUSH
56050: EMPTY
56051: LIST
56052: LIST
56053: PUSH
56054: LD_INT 30
56056: PUSH
56057: LD_INT 1
56059: PUSH
56060: EMPTY
56061: LIST
56062: LIST
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: LIST
56068: PPUSH
56069: CALL_OW 72
56073: NOT
56074: OR
56075: IFFALSE 56125
// begin if mc_deposits_finder [ i ] then
56077: LD_EXP 154
56081: PUSH
56082: LD_VAR 0 2
56086: ARRAY
56087: IFFALSE 56123
// begin MC_Reset ( i , 125 ) ;
56089: LD_VAR 0 2
56093: PPUSH
56094: LD_INT 125
56096: PPUSH
56097: CALL 39297 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56101: LD_ADDR_EXP 154
56105: PUSH
56106: LD_EXP 154
56110: PPUSH
56111: LD_VAR 0 2
56115: PPUSH
56116: EMPTY
56117: PPUSH
56118: CALL_OW 1
56122: ST_TO_ADDR
// end ; continue ;
56123: GO 55977
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56125: LD_EXP 153
56129: PUSH
56130: LD_VAR 0 2
56134: ARRAY
56135: PUSH
56136: LD_INT 1
56138: ARRAY
56139: PUSH
56140: LD_INT 3
56142: ARRAY
56143: PUSH
56144: LD_INT 1
56146: EQUAL
56147: PUSH
56148: LD_INT 20
56150: PPUSH
56151: LD_EXP 142
56155: PUSH
56156: LD_VAR 0 2
56160: ARRAY
56161: PPUSH
56162: CALL_OW 321
56166: PUSH
56167: LD_INT 2
56169: NONEQUAL
56170: AND
56171: IFFALSE 56221
// begin if mc_deposits_finder [ i ] then
56173: LD_EXP 154
56177: PUSH
56178: LD_VAR 0 2
56182: ARRAY
56183: IFFALSE 56219
// begin MC_Reset ( i , 125 ) ;
56185: LD_VAR 0 2
56189: PPUSH
56190: LD_INT 125
56192: PPUSH
56193: CALL 39297 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56197: LD_ADDR_EXP 154
56201: PUSH
56202: LD_EXP 154
56206: PPUSH
56207: LD_VAR 0 2
56211: PPUSH
56212: EMPTY
56213: PPUSH
56214: CALL_OW 1
56218: ST_TO_ADDR
// end ; continue ;
56219: GO 55977
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56221: LD_EXP 153
56225: PUSH
56226: LD_VAR 0 2
56230: ARRAY
56231: PUSH
56232: LD_INT 1
56234: ARRAY
56235: PUSH
56236: LD_INT 1
56238: ARRAY
56239: PPUSH
56240: LD_EXP 153
56244: PUSH
56245: LD_VAR 0 2
56249: ARRAY
56250: PUSH
56251: LD_INT 1
56253: ARRAY
56254: PUSH
56255: LD_INT 2
56257: ARRAY
56258: PPUSH
56259: LD_EXP 142
56263: PUSH
56264: LD_VAR 0 2
56268: ARRAY
56269: PPUSH
56270: CALL_OW 440
56274: IFFALSE 56317
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56276: LD_ADDR_EXP 153
56280: PUSH
56281: LD_EXP 153
56285: PPUSH
56286: LD_VAR 0 2
56290: PPUSH
56291: LD_EXP 153
56295: PUSH
56296: LD_VAR 0 2
56300: ARRAY
56301: PPUSH
56302: LD_INT 1
56304: PPUSH
56305: CALL_OW 3
56309: PPUSH
56310: CALL_OW 1
56314: ST_TO_ADDR
56315: GO 56564
// begin if not mc_deposits_finder [ i ] then
56317: LD_EXP 154
56321: PUSH
56322: LD_VAR 0 2
56326: ARRAY
56327: NOT
56328: IFFALSE 56380
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56330: LD_ADDR_EXP 154
56334: PUSH
56335: LD_EXP 154
56339: PPUSH
56340: LD_VAR 0 2
56344: PPUSH
56345: LD_VAR 0 3
56349: PUSH
56350: LD_INT 1
56352: ARRAY
56353: PUSH
56354: EMPTY
56355: LIST
56356: PPUSH
56357: CALL_OW 1
56361: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56362: LD_VAR 0 3
56366: PUSH
56367: LD_INT 1
56369: ARRAY
56370: PPUSH
56371: LD_INT 125
56373: PPUSH
56374: CALL_OW 109
// end else
56378: GO 56564
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56380: LD_EXP 154
56384: PUSH
56385: LD_VAR 0 2
56389: ARRAY
56390: PUSH
56391: LD_INT 1
56393: ARRAY
56394: PPUSH
56395: CALL_OW 310
56399: IFFALSE 56422
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56401: LD_EXP 154
56405: PUSH
56406: LD_VAR 0 2
56410: ARRAY
56411: PUSH
56412: LD_INT 1
56414: ARRAY
56415: PPUSH
56416: CALL_OW 122
56420: GO 56564
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56422: LD_EXP 154
56426: PUSH
56427: LD_VAR 0 2
56431: ARRAY
56432: PUSH
56433: LD_INT 1
56435: ARRAY
56436: PPUSH
56437: CALL_OW 314
56441: NOT
56442: PUSH
56443: LD_EXP 154
56447: PUSH
56448: LD_VAR 0 2
56452: ARRAY
56453: PUSH
56454: LD_INT 1
56456: ARRAY
56457: PPUSH
56458: LD_EXP 153
56462: PUSH
56463: LD_VAR 0 2
56467: ARRAY
56468: PUSH
56469: LD_INT 1
56471: ARRAY
56472: PUSH
56473: LD_INT 1
56475: ARRAY
56476: PPUSH
56477: LD_EXP 153
56481: PUSH
56482: LD_VAR 0 2
56486: ARRAY
56487: PUSH
56488: LD_INT 1
56490: ARRAY
56491: PUSH
56492: LD_INT 2
56494: ARRAY
56495: PPUSH
56496: CALL_OW 297
56500: PUSH
56501: LD_INT 6
56503: GREATER
56504: AND
56505: IFFALSE 56564
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56507: LD_EXP 154
56511: PUSH
56512: LD_VAR 0 2
56516: ARRAY
56517: PUSH
56518: LD_INT 1
56520: ARRAY
56521: PPUSH
56522: LD_EXP 153
56526: PUSH
56527: LD_VAR 0 2
56531: ARRAY
56532: PUSH
56533: LD_INT 1
56535: ARRAY
56536: PUSH
56537: LD_INT 1
56539: ARRAY
56540: PPUSH
56541: LD_EXP 153
56545: PUSH
56546: LD_VAR 0 2
56550: ARRAY
56551: PUSH
56552: LD_INT 1
56554: ARRAY
56555: PUSH
56556: LD_INT 2
56558: ARRAY
56559: PPUSH
56560: CALL_OW 111
// end ; end ; end ;
56564: GO 55977
56566: POP
56567: POP
// end ;
56568: LD_VAR 0 1
56572: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56573: LD_INT 0
56575: PPUSH
56576: PPUSH
56577: PPUSH
56578: PPUSH
56579: PPUSH
56580: PPUSH
56581: PPUSH
56582: PPUSH
56583: PPUSH
56584: PPUSH
56585: PPUSH
// if not mc_bases then
56586: LD_EXP 116
56590: NOT
56591: IFFALSE 56595
// exit ;
56593: GO 57535
// for i = 1 to mc_bases do
56595: LD_ADDR_VAR 0 2
56599: PUSH
56600: DOUBLE
56601: LD_INT 1
56603: DEC
56604: ST_TO_ADDR
56605: LD_EXP 116
56609: PUSH
56610: FOR_TO
56611: IFFALSE 57533
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56613: LD_EXP 116
56617: PUSH
56618: LD_VAR 0 2
56622: ARRAY
56623: NOT
56624: PUSH
56625: LD_EXP 139
56629: PUSH
56630: LD_VAR 0 2
56634: ARRAY
56635: OR
56636: IFFALSE 56640
// continue ;
56638: GO 56610
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56640: LD_ADDR_VAR 0 7
56644: PUSH
56645: LD_EXP 116
56649: PUSH
56650: LD_VAR 0 2
56654: ARRAY
56655: PUSH
56656: LD_INT 1
56658: ARRAY
56659: PPUSH
56660: CALL_OW 248
56664: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56665: LD_VAR 0 7
56669: PUSH
56670: LD_INT 3
56672: EQUAL
56673: PUSH
56674: LD_EXP 135
56678: PUSH
56679: LD_VAR 0 2
56683: ARRAY
56684: PUSH
56685: LD_EXP 138
56689: PUSH
56690: LD_VAR 0 2
56694: ARRAY
56695: UNION
56696: PPUSH
56697: LD_INT 33
56699: PUSH
56700: LD_INT 2
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: PPUSH
56707: CALL_OW 72
56711: NOT
56712: OR
56713: IFFALSE 56717
// continue ;
56715: GO 56610
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56717: LD_ADDR_VAR 0 9
56721: PUSH
56722: LD_EXP 116
56726: PUSH
56727: LD_VAR 0 2
56731: ARRAY
56732: PPUSH
56733: LD_INT 30
56735: PUSH
56736: LD_INT 36
56738: PUSH
56739: EMPTY
56740: LIST
56741: LIST
56742: PPUSH
56743: CALL_OW 72
56747: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56748: LD_ADDR_VAR 0 10
56752: PUSH
56753: LD_EXP 135
56757: PUSH
56758: LD_VAR 0 2
56762: ARRAY
56763: PPUSH
56764: LD_INT 34
56766: PUSH
56767: LD_INT 31
56769: PUSH
56770: EMPTY
56771: LIST
56772: LIST
56773: PPUSH
56774: CALL_OW 72
56778: ST_TO_ADDR
// if not cts and not mcts then
56779: LD_VAR 0 9
56783: NOT
56784: PUSH
56785: LD_VAR 0 10
56789: NOT
56790: AND
56791: IFFALSE 56795
// continue ;
56793: GO 56610
// x := cts ;
56795: LD_ADDR_VAR 0 11
56799: PUSH
56800: LD_VAR 0 9
56804: ST_TO_ADDR
// if not x then
56805: LD_VAR 0 11
56809: NOT
56810: IFFALSE 56822
// x := mcts ;
56812: LD_ADDR_VAR 0 11
56816: PUSH
56817: LD_VAR 0 10
56821: ST_TO_ADDR
// if not x then
56822: LD_VAR 0 11
56826: NOT
56827: IFFALSE 56831
// continue ;
56829: GO 56610
// if mc_remote_driver [ i ] then
56831: LD_EXP 156
56835: PUSH
56836: LD_VAR 0 2
56840: ARRAY
56841: IFFALSE 57228
// for j in mc_remote_driver [ i ] do
56843: LD_ADDR_VAR 0 3
56847: PUSH
56848: LD_EXP 156
56852: PUSH
56853: LD_VAR 0 2
56857: ARRAY
56858: PUSH
56859: FOR_IN
56860: IFFALSE 57226
// begin if GetClass ( j ) <> 3 then
56862: LD_VAR 0 3
56866: PPUSH
56867: CALL_OW 257
56871: PUSH
56872: LD_INT 3
56874: NONEQUAL
56875: IFFALSE 56928
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56877: LD_ADDR_EXP 156
56881: PUSH
56882: LD_EXP 156
56886: PPUSH
56887: LD_VAR 0 2
56891: PPUSH
56892: LD_EXP 156
56896: PUSH
56897: LD_VAR 0 2
56901: ARRAY
56902: PUSH
56903: LD_VAR 0 3
56907: DIFF
56908: PPUSH
56909: CALL_OW 1
56913: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56914: LD_VAR 0 3
56918: PPUSH
56919: LD_INT 0
56921: PPUSH
56922: CALL_OW 109
// continue ;
56926: GO 56859
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56928: LD_EXP 135
56932: PUSH
56933: LD_VAR 0 2
56937: ARRAY
56938: PPUSH
56939: LD_INT 34
56941: PUSH
56942: LD_INT 31
56944: PUSH
56945: EMPTY
56946: LIST
56947: LIST
56948: PUSH
56949: LD_INT 58
56951: PUSH
56952: EMPTY
56953: LIST
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: PPUSH
56959: CALL_OW 72
56963: PUSH
56964: LD_VAR 0 3
56968: PPUSH
56969: CALL 99897 0 1
56973: NOT
56974: AND
56975: IFFALSE 57046
// begin if IsInUnit ( j ) then
56977: LD_VAR 0 3
56981: PPUSH
56982: CALL_OW 310
56986: IFFALSE 56997
// ComExitBuilding ( j ) ;
56988: LD_VAR 0 3
56992: PPUSH
56993: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56997: LD_VAR 0 3
57001: PPUSH
57002: LD_EXP 135
57006: PUSH
57007: LD_VAR 0 2
57011: ARRAY
57012: PPUSH
57013: LD_INT 34
57015: PUSH
57016: LD_INT 31
57018: PUSH
57019: EMPTY
57020: LIST
57021: LIST
57022: PUSH
57023: LD_INT 58
57025: PUSH
57026: EMPTY
57027: LIST
57028: PUSH
57029: EMPTY
57030: LIST
57031: LIST
57032: PPUSH
57033: CALL_OW 72
57037: PUSH
57038: LD_INT 1
57040: ARRAY
57041: PPUSH
57042: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57046: LD_VAR 0 3
57050: PPUSH
57051: CALL_OW 310
57055: NOT
57056: PUSH
57057: LD_VAR 0 3
57061: PPUSH
57062: CALL_OW 310
57066: PPUSH
57067: CALL_OW 266
57071: PUSH
57072: LD_INT 36
57074: NONEQUAL
57075: PUSH
57076: LD_VAR 0 3
57080: PPUSH
57081: CALL 99897 0 1
57085: NOT
57086: AND
57087: OR
57088: IFFALSE 57224
// begin if IsInUnit ( j ) then
57090: LD_VAR 0 3
57094: PPUSH
57095: CALL_OW 310
57099: IFFALSE 57110
// ComExitBuilding ( j ) ;
57101: LD_VAR 0 3
57105: PPUSH
57106: CALL_OW 122
// ct := 0 ;
57110: LD_ADDR_VAR 0 8
57114: PUSH
57115: LD_INT 0
57117: ST_TO_ADDR
// for k in x do
57118: LD_ADDR_VAR 0 4
57122: PUSH
57123: LD_VAR 0 11
57127: PUSH
57128: FOR_IN
57129: IFFALSE 57202
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57131: LD_VAR 0 4
57135: PPUSH
57136: CALL_OW 264
57140: PUSH
57141: LD_INT 31
57143: EQUAL
57144: PUSH
57145: LD_VAR 0 4
57149: PPUSH
57150: CALL_OW 311
57154: NOT
57155: AND
57156: PUSH
57157: LD_VAR 0 4
57161: PPUSH
57162: CALL_OW 266
57166: PUSH
57167: LD_INT 36
57169: EQUAL
57170: PUSH
57171: LD_VAR 0 4
57175: PPUSH
57176: CALL_OW 313
57180: PUSH
57181: LD_INT 3
57183: LESS
57184: AND
57185: OR
57186: IFFALSE 57200
// begin ct := k ;
57188: LD_ADDR_VAR 0 8
57192: PUSH
57193: LD_VAR 0 4
57197: ST_TO_ADDR
// break ;
57198: GO 57202
// end ;
57200: GO 57128
57202: POP
57203: POP
// if ct then
57204: LD_VAR 0 8
57208: IFFALSE 57224
// ComEnterUnit ( j , ct ) ;
57210: LD_VAR 0 3
57214: PPUSH
57215: LD_VAR 0 8
57219: PPUSH
57220: CALL_OW 120
// end ; end ;
57224: GO 56859
57226: POP
57227: POP
// places := 0 ;
57228: LD_ADDR_VAR 0 5
57232: PUSH
57233: LD_INT 0
57235: ST_TO_ADDR
// for j = 1 to x do
57236: LD_ADDR_VAR 0 3
57240: PUSH
57241: DOUBLE
57242: LD_INT 1
57244: DEC
57245: ST_TO_ADDR
57246: LD_VAR 0 11
57250: PUSH
57251: FOR_TO
57252: IFFALSE 57328
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57254: LD_VAR 0 11
57258: PUSH
57259: LD_VAR 0 3
57263: ARRAY
57264: PPUSH
57265: CALL_OW 264
57269: PUSH
57270: LD_INT 31
57272: EQUAL
57273: IFFALSE 57291
// places := places + 1 else
57275: LD_ADDR_VAR 0 5
57279: PUSH
57280: LD_VAR 0 5
57284: PUSH
57285: LD_INT 1
57287: PLUS
57288: ST_TO_ADDR
57289: GO 57326
// if GetBType ( x [ j ] ) = b_control_tower then
57291: LD_VAR 0 11
57295: PUSH
57296: LD_VAR 0 3
57300: ARRAY
57301: PPUSH
57302: CALL_OW 266
57306: PUSH
57307: LD_INT 36
57309: EQUAL
57310: IFFALSE 57326
// places := places + 3 ;
57312: LD_ADDR_VAR 0 5
57316: PUSH
57317: LD_VAR 0 5
57321: PUSH
57322: LD_INT 3
57324: PLUS
57325: ST_TO_ADDR
57326: GO 57251
57328: POP
57329: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57330: LD_VAR 0 5
57334: PUSH
57335: LD_INT 0
57337: EQUAL
57338: PUSH
57339: LD_VAR 0 5
57343: PUSH
57344: LD_EXP 156
57348: PUSH
57349: LD_VAR 0 2
57353: ARRAY
57354: LESSEQUAL
57355: OR
57356: IFFALSE 57360
// continue ;
57358: GO 56610
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57360: LD_ADDR_VAR 0 6
57364: PUSH
57365: LD_EXP 116
57369: PUSH
57370: LD_VAR 0 2
57374: ARRAY
57375: PPUSH
57376: LD_INT 25
57378: PUSH
57379: LD_INT 3
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: PPUSH
57386: CALL_OW 72
57390: PUSH
57391: LD_EXP 156
57395: PUSH
57396: LD_VAR 0 2
57400: ARRAY
57401: DIFF
57402: PPUSH
57403: LD_INT 3
57405: PPUSH
57406: CALL 100797 0 2
57410: ST_TO_ADDR
// for j in tmp do
57411: LD_ADDR_VAR 0 3
57415: PUSH
57416: LD_VAR 0 6
57420: PUSH
57421: FOR_IN
57422: IFFALSE 57457
// if GetTag ( j ) > 0 then
57424: LD_VAR 0 3
57428: PPUSH
57429: CALL_OW 110
57433: PUSH
57434: LD_INT 0
57436: GREATER
57437: IFFALSE 57455
// tmp := tmp diff j ;
57439: LD_ADDR_VAR 0 6
57443: PUSH
57444: LD_VAR 0 6
57448: PUSH
57449: LD_VAR 0 3
57453: DIFF
57454: ST_TO_ADDR
57455: GO 57421
57457: POP
57458: POP
// if not tmp then
57459: LD_VAR 0 6
57463: NOT
57464: IFFALSE 57468
// continue ;
57466: GO 56610
// if places then
57468: LD_VAR 0 5
57472: IFFALSE 57531
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57474: LD_ADDR_EXP 156
57478: PUSH
57479: LD_EXP 156
57483: PPUSH
57484: LD_VAR 0 2
57488: PPUSH
57489: LD_EXP 156
57493: PUSH
57494: LD_VAR 0 2
57498: ARRAY
57499: PUSH
57500: LD_VAR 0 6
57504: PUSH
57505: LD_INT 1
57507: ARRAY
57508: UNION
57509: PPUSH
57510: CALL_OW 1
57514: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57515: LD_VAR 0 6
57519: PUSH
57520: LD_INT 1
57522: ARRAY
57523: PPUSH
57524: LD_INT 126
57526: PPUSH
57527: CALL_OW 109
// end ; end ;
57531: GO 56610
57533: POP
57534: POP
// end ;
57535: LD_VAR 0 1
57539: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57540: LD_INT 0
57542: PPUSH
57543: PPUSH
57544: PPUSH
57545: PPUSH
57546: PPUSH
57547: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57548: LD_VAR 0 1
57552: NOT
57553: PUSH
57554: LD_VAR 0 2
57558: NOT
57559: OR
57560: PUSH
57561: LD_VAR 0 3
57565: NOT
57566: OR
57567: PUSH
57568: LD_VAR 0 4
57572: PUSH
57573: LD_INT 1
57575: PUSH
57576: LD_INT 2
57578: PUSH
57579: LD_INT 3
57581: PUSH
57582: LD_INT 4
57584: PUSH
57585: LD_INT 5
57587: PUSH
57588: LD_INT 8
57590: PUSH
57591: LD_INT 9
57593: PUSH
57594: LD_INT 15
57596: PUSH
57597: LD_INT 16
57599: PUSH
57600: EMPTY
57601: LIST
57602: LIST
57603: LIST
57604: LIST
57605: LIST
57606: LIST
57607: LIST
57608: LIST
57609: LIST
57610: IN
57611: NOT
57612: OR
57613: IFFALSE 57617
// exit ;
57615: GO 58517
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57617: LD_ADDR_VAR 0 2
57621: PUSH
57622: LD_VAR 0 2
57626: PPUSH
57627: LD_INT 21
57629: PUSH
57630: LD_INT 3
57632: PUSH
57633: EMPTY
57634: LIST
57635: LIST
57636: PUSH
57637: LD_INT 24
57639: PUSH
57640: LD_INT 250
57642: PUSH
57643: EMPTY
57644: LIST
57645: LIST
57646: PUSH
57647: EMPTY
57648: LIST
57649: LIST
57650: PPUSH
57651: CALL_OW 72
57655: ST_TO_ADDR
// case class of 1 , 15 :
57656: LD_VAR 0 4
57660: PUSH
57661: LD_INT 1
57663: DOUBLE
57664: EQUAL
57665: IFTRUE 57675
57667: LD_INT 15
57669: DOUBLE
57670: EQUAL
57671: IFTRUE 57675
57673: GO 57760
57675: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57676: LD_ADDR_VAR 0 8
57680: PUSH
57681: LD_VAR 0 2
57685: PPUSH
57686: LD_INT 2
57688: PUSH
57689: LD_INT 30
57691: PUSH
57692: LD_INT 32
57694: PUSH
57695: EMPTY
57696: LIST
57697: LIST
57698: PUSH
57699: LD_INT 30
57701: PUSH
57702: LD_INT 31
57704: PUSH
57705: EMPTY
57706: LIST
57707: LIST
57708: PUSH
57709: EMPTY
57710: LIST
57711: LIST
57712: LIST
57713: PPUSH
57714: CALL_OW 72
57718: PUSH
57719: LD_VAR 0 2
57723: PPUSH
57724: LD_INT 2
57726: PUSH
57727: LD_INT 30
57729: PUSH
57730: LD_INT 4
57732: PUSH
57733: EMPTY
57734: LIST
57735: LIST
57736: PUSH
57737: LD_INT 30
57739: PUSH
57740: LD_INT 5
57742: PUSH
57743: EMPTY
57744: LIST
57745: LIST
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: LIST
57751: PPUSH
57752: CALL_OW 72
57756: ADD
57757: ST_TO_ADDR
57758: GO 58006
57760: LD_INT 2
57762: DOUBLE
57763: EQUAL
57764: IFTRUE 57774
57766: LD_INT 16
57768: DOUBLE
57769: EQUAL
57770: IFTRUE 57774
57772: GO 57820
57774: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57775: LD_ADDR_VAR 0 8
57779: PUSH
57780: LD_VAR 0 2
57784: PPUSH
57785: LD_INT 2
57787: PUSH
57788: LD_INT 30
57790: PUSH
57791: LD_INT 0
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: PUSH
57798: LD_INT 30
57800: PUSH
57801: LD_INT 1
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PUSH
57808: EMPTY
57809: LIST
57810: LIST
57811: LIST
57812: PPUSH
57813: CALL_OW 72
57817: ST_TO_ADDR
57818: GO 58006
57820: LD_INT 3
57822: DOUBLE
57823: EQUAL
57824: IFTRUE 57828
57826: GO 57874
57828: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57829: LD_ADDR_VAR 0 8
57833: PUSH
57834: LD_VAR 0 2
57838: PPUSH
57839: LD_INT 2
57841: PUSH
57842: LD_INT 30
57844: PUSH
57845: LD_INT 2
57847: PUSH
57848: EMPTY
57849: LIST
57850: LIST
57851: PUSH
57852: LD_INT 30
57854: PUSH
57855: LD_INT 3
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: PUSH
57862: EMPTY
57863: LIST
57864: LIST
57865: LIST
57866: PPUSH
57867: CALL_OW 72
57871: ST_TO_ADDR
57872: GO 58006
57874: LD_INT 4
57876: DOUBLE
57877: EQUAL
57878: IFTRUE 57882
57880: GO 57939
57882: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57883: LD_ADDR_VAR 0 8
57887: PUSH
57888: LD_VAR 0 2
57892: PPUSH
57893: LD_INT 2
57895: PUSH
57896: LD_INT 30
57898: PUSH
57899: LD_INT 6
57901: PUSH
57902: EMPTY
57903: LIST
57904: LIST
57905: PUSH
57906: LD_INT 30
57908: PUSH
57909: LD_INT 7
57911: PUSH
57912: EMPTY
57913: LIST
57914: LIST
57915: PUSH
57916: LD_INT 30
57918: PUSH
57919: LD_INT 8
57921: PUSH
57922: EMPTY
57923: LIST
57924: LIST
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: LIST
57930: LIST
57931: PPUSH
57932: CALL_OW 72
57936: ST_TO_ADDR
57937: GO 58006
57939: LD_INT 5
57941: DOUBLE
57942: EQUAL
57943: IFTRUE 57959
57945: LD_INT 8
57947: DOUBLE
57948: EQUAL
57949: IFTRUE 57959
57951: LD_INT 9
57953: DOUBLE
57954: EQUAL
57955: IFTRUE 57959
57957: GO 58005
57959: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57960: LD_ADDR_VAR 0 8
57964: PUSH
57965: LD_VAR 0 2
57969: PPUSH
57970: LD_INT 2
57972: PUSH
57973: LD_INT 30
57975: PUSH
57976: LD_INT 4
57978: PUSH
57979: EMPTY
57980: LIST
57981: LIST
57982: PUSH
57983: LD_INT 30
57985: PUSH
57986: LD_INT 5
57988: PUSH
57989: EMPTY
57990: LIST
57991: LIST
57992: PUSH
57993: EMPTY
57994: LIST
57995: LIST
57996: LIST
57997: PPUSH
57998: CALL_OW 72
58002: ST_TO_ADDR
58003: GO 58006
58005: POP
// if not tmp then
58006: LD_VAR 0 8
58010: NOT
58011: IFFALSE 58015
// exit ;
58013: GO 58517
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58015: LD_VAR 0 4
58019: PUSH
58020: LD_INT 1
58022: PUSH
58023: LD_INT 15
58025: PUSH
58026: EMPTY
58027: LIST
58028: LIST
58029: IN
58030: PUSH
58031: LD_EXP 125
58035: PUSH
58036: LD_VAR 0 1
58040: ARRAY
58041: AND
58042: IFFALSE 58198
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58044: LD_ADDR_VAR 0 9
58048: PUSH
58049: LD_EXP 125
58053: PUSH
58054: LD_VAR 0 1
58058: ARRAY
58059: PUSH
58060: LD_INT 1
58062: ARRAY
58063: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58064: LD_VAR 0 9
58068: PUSH
58069: LD_EXP 126
58073: PUSH
58074: LD_VAR 0 1
58078: ARRAY
58079: IN
58080: NOT
58081: IFFALSE 58196
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58083: LD_ADDR_EXP 126
58087: PUSH
58088: LD_EXP 126
58092: PPUSH
58093: LD_VAR 0 1
58097: PUSH
58098: LD_EXP 126
58102: PUSH
58103: LD_VAR 0 1
58107: ARRAY
58108: PUSH
58109: LD_INT 1
58111: PLUS
58112: PUSH
58113: EMPTY
58114: LIST
58115: LIST
58116: PPUSH
58117: LD_VAR 0 9
58121: PPUSH
58122: CALL 70539 0 3
58126: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58127: LD_ADDR_EXP 125
58131: PUSH
58132: LD_EXP 125
58136: PPUSH
58137: LD_VAR 0 1
58141: PPUSH
58142: LD_EXP 125
58146: PUSH
58147: LD_VAR 0 1
58151: ARRAY
58152: PUSH
58153: LD_VAR 0 9
58157: DIFF
58158: PPUSH
58159: CALL_OW 1
58163: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58164: LD_VAR 0 3
58168: PPUSH
58169: LD_EXP 126
58173: PUSH
58174: LD_VAR 0 1
58178: ARRAY
58179: PUSH
58180: LD_EXP 126
58184: PUSH
58185: LD_VAR 0 1
58189: ARRAY
58190: ARRAY
58191: PPUSH
58192: CALL_OW 120
// end ; exit ;
58196: GO 58517
// end ; if tmp > 1 then
58198: LD_VAR 0 8
58202: PUSH
58203: LD_INT 1
58205: GREATER
58206: IFFALSE 58310
// for i = 2 to tmp do
58208: LD_ADDR_VAR 0 6
58212: PUSH
58213: DOUBLE
58214: LD_INT 2
58216: DEC
58217: ST_TO_ADDR
58218: LD_VAR 0 8
58222: PUSH
58223: FOR_TO
58224: IFFALSE 58308
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58226: LD_VAR 0 8
58230: PUSH
58231: LD_VAR 0 6
58235: ARRAY
58236: PPUSH
58237: CALL_OW 461
58241: PUSH
58242: LD_INT 6
58244: EQUAL
58245: IFFALSE 58306
// begin x := tmp [ i ] ;
58247: LD_ADDR_VAR 0 9
58251: PUSH
58252: LD_VAR 0 8
58256: PUSH
58257: LD_VAR 0 6
58261: ARRAY
58262: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58263: LD_ADDR_VAR 0 8
58267: PUSH
58268: LD_VAR 0 8
58272: PPUSH
58273: LD_VAR 0 6
58277: PPUSH
58278: CALL_OW 3
58282: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58283: LD_ADDR_VAR 0 8
58287: PUSH
58288: LD_VAR 0 8
58292: PPUSH
58293: LD_INT 1
58295: PPUSH
58296: LD_VAR 0 9
58300: PPUSH
58301: CALL_OW 2
58305: ST_TO_ADDR
// end ;
58306: GO 58223
58308: POP
58309: POP
// for i in tmp do
58310: LD_ADDR_VAR 0 6
58314: PUSH
58315: LD_VAR 0 8
58319: PUSH
58320: FOR_IN
58321: IFFALSE 58390
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58323: LD_VAR 0 6
58327: PPUSH
58328: CALL_OW 313
58332: PUSH
58333: LD_INT 6
58335: LESS
58336: PUSH
58337: LD_VAR 0 6
58341: PPUSH
58342: CALL_OW 266
58346: PUSH
58347: LD_INT 31
58349: PUSH
58350: LD_INT 32
58352: PUSH
58353: EMPTY
58354: LIST
58355: LIST
58356: IN
58357: NOT
58358: AND
58359: PUSH
58360: LD_VAR 0 6
58364: PPUSH
58365: CALL_OW 313
58369: PUSH
58370: LD_INT 0
58372: EQUAL
58373: OR
58374: IFFALSE 58388
// begin j := i ;
58376: LD_ADDR_VAR 0 7
58380: PUSH
58381: LD_VAR 0 6
58385: ST_TO_ADDR
// break ;
58386: GO 58390
// end ; end ;
58388: GO 58320
58390: POP
58391: POP
// if j then
58392: LD_VAR 0 7
58396: IFFALSE 58414
// ComEnterUnit ( unit , j ) else
58398: LD_VAR 0 3
58402: PPUSH
58403: LD_VAR 0 7
58407: PPUSH
58408: CALL_OW 120
58412: GO 58517
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58414: LD_ADDR_VAR 0 10
58418: PUSH
58419: LD_VAR 0 2
58423: PPUSH
58424: LD_INT 2
58426: PUSH
58427: LD_INT 30
58429: PUSH
58430: LD_INT 0
58432: PUSH
58433: EMPTY
58434: LIST
58435: LIST
58436: PUSH
58437: LD_INT 30
58439: PUSH
58440: LD_INT 1
58442: PUSH
58443: EMPTY
58444: LIST
58445: LIST
58446: PUSH
58447: EMPTY
58448: LIST
58449: LIST
58450: LIST
58451: PPUSH
58452: CALL_OW 72
58456: ST_TO_ADDR
// if depot then
58457: LD_VAR 0 10
58461: IFFALSE 58517
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58463: LD_ADDR_VAR 0 10
58467: PUSH
58468: LD_VAR 0 10
58472: PPUSH
58473: LD_VAR 0 3
58477: PPUSH
58478: CALL_OW 74
58482: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58483: LD_VAR 0 3
58487: PPUSH
58488: LD_VAR 0 10
58492: PPUSH
58493: CALL_OW 296
58497: PUSH
58498: LD_INT 10
58500: GREATER
58501: IFFALSE 58517
// ComStandNearbyBuilding ( unit , depot ) ;
58503: LD_VAR 0 3
58507: PPUSH
58508: LD_VAR 0 10
58512: PPUSH
58513: CALL 67117 0 2
// end ; end ; end ;
58517: LD_VAR 0 5
58521: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58522: LD_INT 0
58524: PPUSH
58525: PPUSH
58526: PPUSH
58527: PPUSH
// if not mc_bases then
58528: LD_EXP 116
58532: NOT
58533: IFFALSE 58537
// exit ;
58535: GO 58776
// for i = 1 to mc_bases do
58537: LD_ADDR_VAR 0 2
58541: PUSH
58542: DOUBLE
58543: LD_INT 1
58545: DEC
58546: ST_TO_ADDR
58547: LD_EXP 116
58551: PUSH
58552: FOR_TO
58553: IFFALSE 58774
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58555: LD_ADDR_VAR 0 4
58559: PUSH
58560: LD_EXP 116
58564: PUSH
58565: LD_VAR 0 2
58569: ARRAY
58570: PPUSH
58571: LD_INT 21
58573: PUSH
58574: LD_INT 1
58576: PUSH
58577: EMPTY
58578: LIST
58579: LIST
58580: PPUSH
58581: CALL_OW 72
58585: PUSH
58586: LD_EXP 145
58590: PUSH
58591: LD_VAR 0 2
58595: ARRAY
58596: UNION
58597: ST_TO_ADDR
// if not tmp then
58598: LD_VAR 0 4
58602: NOT
58603: IFFALSE 58607
// continue ;
58605: GO 58552
// for j in tmp do
58607: LD_ADDR_VAR 0 3
58611: PUSH
58612: LD_VAR 0 4
58616: PUSH
58617: FOR_IN
58618: IFFALSE 58770
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58620: LD_VAR 0 3
58624: PPUSH
58625: CALL_OW 110
58629: NOT
58630: PUSH
58631: LD_VAR 0 3
58635: PPUSH
58636: CALL_OW 314
58640: NOT
58641: AND
58642: PUSH
58643: LD_VAR 0 3
58647: PPUSH
58648: CALL_OW 311
58652: NOT
58653: AND
58654: PUSH
58655: LD_VAR 0 3
58659: PPUSH
58660: CALL_OW 310
58664: NOT
58665: AND
58666: PUSH
58667: LD_VAR 0 3
58671: PUSH
58672: LD_EXP 119
58676: PUSH
58677: LD_VAR 0 2
58681: ARRAY
58682: PUSH
58683: LD_INT 1
58685: ARRAY
58686: IN
58687: NOT
58688: AND
58689: PUSH
58690: LD_VAR 0 3
58694: PUSH
58695: LD_EXP 119
58699: PUSH
58700: LD_VAR 0 2
58704: ARRAY
58705: PUSH
58706: LD_INT 2
58708: ARRAY
58709: IN
58710: NOT
58711: AND
58712: PUSH
58713: LD_VAR 0 3
58717: PUSH
58718: LD_EXP 128
58722: PUSH
58723: LD_VAR 0 2
58727: ARRAY
58728: IN
58729: NOT
58730: AND
58731: IFFALSE 58768
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58733: LD_VAR 0 2
58737: PPUSH
58738: LD_EXP 116
58742: PUSH
58743: LD_VAR 0 2
58747: ARRAY
58748: PPUSH
58749: LD_VAR 0 3
58753: PPUSH
58754: LD_VAR 0 3
58758: PPUSH
58759: CALL_OW 257
58763: PPUSH
58764: CALL 57540 0 4
// end ;
58768: GO 58617
58770: POP
58771: POP
// end ;
58772: GO 58552
58774: POP
58775: POP
// end ;
58776: LD_VAR 0 1
58780: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58781: LD_INT 0
58783: PPUSH
58784: PPUSH
58785: PPUSH
58786: PPUSH
58787: PPUSH
58788: PPUSH
// if not mc_bases [ base ] then
58789: LD_EXP 116
58793: PUSH
58794: LD_VAR 0 1
58798: ARRAY
58799: NOT
58800: IFFALSE 58804
// exit ;
58802: GO 58986
// tmp := [ ] ;
58804: LD_ADDR_VAR 0 6
58808: PUSH
58809: EMPTY
58810: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58811: LD_ADDR_VAR 0 7
58815: PUSH
58816: LD_VAR 0 3
58820: PPUSH
58821: LD_INT 0
58823: PPUSH
58824: CALL_OW 517
58828: ST_TO_ADDR
// if not list then
58829: LD_VAR 0 7
58833: NOT
58834: IFFALSE 58838
// exit ;
58836: GO 58986
// for i = 1 to amount do
58838: LD_ADDR_VAR 0 5
58842: PUSH
58843: DOUBLE
58844: LD_INT 1
58846: DEC
58847: ST_TO_ADDR
58848: LD_VAR 0 2
58852: PUSH
58853: FOR_TO
58854: IFFALSE 58934
// begin x := rand ( 1 , list [ 1 ] ) ;
58856: LD_ADDR_VAR 0 8
58860: PUSH
58861: LD_INT 1
58863: PPUSH
58864: LD_VAR 0 7
58868: PUSH
58869: LD_INT 1
58871: ARRAY
58872: PPUSH
58873: CALL_OW 12
58877: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58878: LD_ADDR_VAR 0 6
58882: PUSH
58883: LD_VAR 0 6
58887: PPUSH
58888: LD_VAR 0 5
58892: PPUSH
58893: LD_VAR 0 7
58897: PUSH
58898: LD_INT 1
58900: ARRAY
58901: PUSH
58902: LD_VAR 0 8
58906: ARRAY
58907: PUSH
58908: LD_VAR 0 7
58912: PUSH
58913: LD_INT 2
58915: ARRAY
58916: PUSH
58917: LD_VAR 0 8
58921: ARRAY
58922: PUSH
58923: EMPTY
58924: LIST
58925: LIST
58926: PPUSH
58927: CALL_OW 1
58931: ST_TO_ADDR
// end ;
58932: GO 58853
58934: POP
58935: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58936: LD_ADDR_EXP 129
58940: PUSH
58941: LD_EXP 129
58945: PPUSH
58946: LD_VAR 0 1
58950: PPUSH
58951: LD_VAR 0 6
58955: PPUSH
58956: CALL_OW 1
58960: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58961: LD_ADDR_EXP 131
58965: PUSH
58966: LD_EXP 131
58970: PPUSH
58971: LD_VAR 0 1
58975: PPUSH
58976: LD_VAR 0 3
58980: PPUSH
58981: CALL_OW 1
58985: ST_TO_ADDR
// end ;
58986: LD_VAR 0 4
58990: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58991: LD_INT 0
58993: PPUSH
// if not mc_bases [ base ] then
58994: LD_EXP 116
58998: PUSH
58999: LD_VAR 0 1
59003: ARRAY
59004: NOT
59005: IFFALSE 59009
// exit ;
59007: GO 59034
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59009: LD_ADDR_EXP 121
59013: PUSH
59014: LD_EXP 121
59018: PPUSH
59019: LD_VAR 0 1
59023: PPUSH
59024: LD_VAR 0 2
59028: PPUSH
59029: CALL_OW 1
59033: ST_TO_ADDR
// end ;
59034: LD_VAR 0 3
59038: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59039: LD_INT 0
59041: PPUSH
// if not mc_bases [ base ] then
59042: LD_EXP 116
59046: PUSH
59047: LD_VAR 0 1
59051: ARRAY
59052: NOT
59053: IFFALSE 59057
// exit ;
59055: GO 59094
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59057: LD_ADDR_EXP 121
59061: PUSH
59062: LD_EXP 121
59066: PPUSH
59067: LD_VAR 0 1
59071: PPUSH
59072: LD_EXP 121
59076: PUSH
59077: LD_VAR 0 1
59081: ARRAY
59082: PUSH
59083: LD_VAR 0 2
59087: UNION
59088: PPUSH
59089: CALL_OW 1
59093: ST_TO_ADDR
// end ;
59094: LD_VAR 0 3
59098: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59099: LD_INT 0
59101: PPUSH
// if not mc_bases [ base ] then
59102: LD_EXP 116
59106: PUSH
59107: LD_VAR 0 1
59111: ARRAY
59112: NOT
59113: IFFALSE 59117
// exit ;
59115: GO 59142
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59117: LD_ADDR_EXP 137
59121: PUSH
59122: LD_EXP 137
59126: PPUSH
59127: LD_VAR 0 1
59131: PPUSH
59132: LD_VAR 0 2
59136: PPUSH
59137: CALL_OW 1
59141: ST_TO_ADDR
// end ;
59142: LD_VAR 0 3
59146: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59147: LD_INT 0
59149: PPUSH
// if not mc_bases [ base ] then
59150: LD_EXP 116
59154: PUSH
59155: LD_VAR 0 1
59159: ARRAY
59160: NOT
59161: IFFALSE 59165
// exit ;
59163: GO 59202
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59165: LD_ADDR_EXP 137
59169: PUSH
59170: LD_EXP 137
59174: PPUSH
59175: LD_VAR 0 1
59179: PPUSH
59180: LD_EXP 137
59184: PUSH
59185: LD_VAR 0 1
59189: ARRAY
59190: PUSH
59191: LD_VAR 0 2
59195: ADD
59196: PPUSH
59197: CALL_OW 1
59201: ST_TO_ADDR
// end ;
59202: LD_VAR 0 3
59206: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59207: LD_INT 0
59209: PPUSH
// if not mc_bases [ base ] then
59210: LD_EXP 116
59214: PUSH
59215: LD_VAR 0 1
59219: ARRAY
59220: NOT
59221: IFFALSE 59225
// exit ;
59223: GO 59279
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59225: LD_ADDR_EXP 138
59229: PUSH
59230: LD_EXP 138
59234: PPUSH
59235: LD_VAR 0 1
59239: PPUSH
59240: LD_VAR 0 2
59244: PPUSH
59245: CALL_OW 1
59249: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59250: LD_ADDR_EXP 127
59254: PUSH
59255: LD_EXP 127
59259: PPUSH
59260: LD_VAR 0 1
59264: PPUSH
59265: LD_VAR 0 2
59269: PUSH
59270: LD_INT 0
59272: PLUS
59273: PPUSH
59274: CALL_OW 1
59278: ST_TO_ADDR
// end ;
59279: LD_VAR 0 3
59283: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59284: LD_INT 0
59286: PPUSH
// if not mc_bases [ base ] then
59287: LD_EXP 116
59291: PUSH
59292: LD_VAR 0 1
59296: ARRAY
59297: NOT
59298: IFFALSE 59302
// exit ;
59300: GO 59327
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59302: LD_ADDR_EXP 127
59306: PUSH
59307: LD_EXP 127
59311: PPUSH
59312: LD_VAR 0 1
59316: PPUSH
59317: LD_VAR 0 2
59321: PPUSH
59322: CALL_OW 1
59326: ST_TO_ADDR
// end ;
59327: LD_VAR 0 3
59331: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59332: LD_INT 0
59334: PPUSH
59335: PPUSH
59336: PPUSH
59337: PPUSH
// if not mc_bases [ base ] then
59338: LD_EXP 116
59342: PUSH
59343: LD_VAR 0 1
59347: ARRAY
59348: NOT
59349: IFFALSE 59353
// exit ;
59351: GO 59418
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59353: LD_ADDR_EXP 136
59357: PUSH
59358: LD_EXP 136
59362: PPUSH
59363: LD_VAR 0 1
59367: PUSH
59368: LD_EXP 136
59372: PUSH
59373: LD_VAR 0 1
59377: ARRAY
59378: PUSH
59379: LD_INT 1
59381: PLUS
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PPUSH
59387: LD_VAR 0 1
59391: PUSH
59392: LD_VAR 0 2
59396: PUSH
59397: LD_VAR 0 3
59401: PUSH
59402: LD_VAR 0 4
59406: PUSH
59407: EMPTY
59408: LIST
59409: LIST
59410: LIST
59411: LIST
59412: PPUSH
59413: CALL 70539 0 3
59417: ST_TO_ADDR
// end ;
59418: LD_VAR 0 5
59422: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59423: LD_INT 0
59425: PPUSH
// if not mc_bases [ base ] then
59426: LD_EXP 116
59430: PUSH
59431: LD_VAR 0 1
59435: ARRAY
59436: NOT
59437: IFFALSE 59441
// exit ;
59439: GO 59466
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59441: LD_ADDR_EXP 153
59445: PUSH
59446: LD_EXP 153
59450: PPUSH
59451: LD_VAR 0 1
59455: PPUSH
59456: LD_VAR 0 2
59460: PPUSH
59461: CALL_OW 1
59465: ST_TO_ADDR
// end ;
59466: LD_VAR 0 3
59470: RET
// export function MC_GetMinesField ( base ) ; begin
59471: LD_INT 0
59473: PPUSH
// result := mc_mines [ base ] ;
59474: LD_ADDR_VAR 0 2
59478: PUSH
59479: LD_EXP 129
59483: PUSH
59484: LD_VAR 0 1
59488: ARRAY
59489: ST_TO_ADDR
// end ;
59490: LD_VAR 0 2
59494: RET
// export function MC_GetProduceList ( base ) ; begin
59495: LD_INT 0
59497: PPUSH
// result := mc_produce [ base ] ;
59498: LD_ADDR_VAR 0 2
59502: PUSH
59503: LD_EXP 137
59507: PUSH
59508: LD_VAR 0 1
59512: ARRAY
59513: ST_TO_ADDR
// end ;
59514: LD_VAR 0 2
59518: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59519: LD_INT 0
59521: PPUSH
59522: PPUSH
// if not mc_bases then
59523: LD_EXP 116
59527: NOT
59528: IFFALSE 59532
// exit ;
59530: GO 59597
// if mc_bases [ base ] then
59532: LD_EXP 116
59536: PUSH
59537: LD_VAR 0 1
59541: ARRAY
59542: IFFALSE 59597
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59544: LD_ADDR_VAR 0 3
59548: PUSH
59549: LD_EXP 116
59553: PUSH
59554: LD_VAR 0 1
59558: ARRAY
59559: PPUSH
59560: LD_INT 30
59562: PUSH
59563: LD_VAR 0 2
59567: PUSH
59568: EMPTY
59569: LIST
59570: LIST
59571: PPUSH
59572: CALL_OW 72
59576: ST_TO_ADDR
// if result then
59577: LD_VAR 0 3
59581: IFFALSE 59597
// result := result [ 1 ] ;
59583: LD_ADDR_VAR 0 3
59587: PUSH
59588: LD_VAR 0 3
59592: PUSH
59593: LD_INT 1
59595: ARRAY
59596: ST_TO_ADDR
// end ; end ;
59597: LD_VAR 0 3
59601: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59602: LD_INT 0
59604: PPUSH
59605: PPUSH
// if not mc_bases then
59606: LD_EXP 116
59610: NOT
59611: IFFALSE 59615
// exit ;
59613: GO 59660
// if mc_bases [ base ] then
59615: LD_EXP 116
59619: PUSH
59620: LD_VAR 0 1
59624: ARRAY
59625: IFFALSE 59660
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59627: LD_ADDR_VAR 0 3
59631: PUSH
59632: LD_EXP 116
59636: PUSH
59637: LD_VAR 0 1
59641: ARRAY
59642: PPUSH
59643: LD_INT 30
59645: PUSH
59646: LD_VAR 0 2
59650: PUSH
59651: EMPTY
59652: LIST
59653: LIST
59654: PPUSH
59655: CALL_OW 72
59659: ST_TO_ADDR
// end ;
59660: LD_VAR 0 3
59664: RET
// export function MC_SetTame ( base , area ) ; begin
59665: LD_INT 0
59667: PPUSH
// if not mc_bases or not base then
59668: LD_EXP 116
59672: NOT
59673: PUSH
59674: LD_VAR 0 1
59678: NOT
59679: OR
59680: IFFALSE 59684
// exit ;
59682: GO 59709
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59684: LD_ADDR_EXP 144
59688: PUSH
59689: LD_EXP 144
59693: PPUSH
59694: LD_VAR 0 1
59698: PPUSH
59699: LD_VAR 0 2
59703: PPUSH
59704: CALL_OW 1
59708: ST_TO_ADDR
// end ;
59709: LD_VAR 0 3
59713: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59714: LD_INT 0
59716: PPUSH
59717: PPUSH
// if not mc_bases or not base then
59718: LD_EXP 116
59722: NOT
59723: PUSH
59724: LD_VAR 0 1
59728: NOT
59729: OR
59730: IFFALSE 59734
// exit ;
59732: GO 59836
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59734: LD_ADDR_VAR 0 4
59738: PUSH
59739: LD_EXP 116
59743: PUSH
59744: LD_VAR 0 1
59748: ARRAY
59749: PPUSH
59750: LD_INT 30
59752: PUSH
59753: LD_VAR 0 2
59757: PUSH
59758: EMPTY
59759: LIST
59760: LIST
59761: PPUSH
59762: CALL_OW 72
59766: ST_TO_ADDR
// if not tmp then
59767: LD_VAR 0 4
59771: NOT
59772: IFFALSE 59776
// exit ;
59774: GO 59836
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59776: LD_ADDR_EXP 148
59780: PUSH
59781: LD_EXP 148
59785: PPUSH
59786: LD_VAR 0 1
59790: PPUSH
59791: LD_EXP 148
59795: PUSH
59796: LD_VAR 0 1
59800: ARRAY
59801: PPUSH
59802: LD_EXP 148
59806: PUSH
59807: LD_VAR 0 1
59811: ARRAY
59812: PUSH
59813: LD_INT 1
59815: PLUS
59816: PPUSH
59817: LD_VAR 0 4
59821: PUSH
59822: LD_INT 1
59824: ARRAY
59825: PPUSH
59826: CALL_OW 2
59830: PPUSH
59831: CALL_OW 1
59835: ST_TO_ADDR
// end ;
59836: LD_VAR 0 3
59840: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59841: LD_INT 0
59843: PPUSH
59844: PPUSH
// if not mc_bases or not base or not kinds then
59845: LD_EXP 116
59849: NOT
59850: PUSH
59851: LD_VAR 0 1
59855: NOT
59856: OR
59857: PUSH
59858: LD_VAR 0 2
59862: NOT
59863: OR
59864: IFFALSE 59868
// exit ;
59866: GO 59929
// for i in kinds do
59868: LD_ADDR_VAR 0 4
59872: PUSH
59873: LD_VAR 0 2
59877: PUSH
59878: FOR_IN
59879: IFFALSE 59927
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59881: LD_ADDR_EXP 150
59885: PUSH
59886: LD_EXP 150
59890: PPUSH
59891: LD_VAR 0 1
59895: PUSH
59896: LD_EXP 150
59900: PUSH
59901: LD_VAR 0 1
59905: ARRAY
59906: PUSH
59907: LD_INT 1
59909: PLUS
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PPUSH
59915: LD_VAR 0 4
59919: PPUSH
59920: CALL 70539 0 3
59924: ST_TO_ADDR
59925: GO 59878
59927: POP
59928: POP
// end ;
59929: LD_VAR 0 3
59933: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59934: LD_INT 0
59936: PPUSH
// if not mc_bases or not base or not areas then
59937: LD_EXP 116
59941: NOT
59942: PUSH
59943: LD_VAR 0 1
59947: NOT
59948: OR
59949: PUSH
59950: LD_VAR 0 2
59954: NOT
59955: OR
59956: IFFALSE 59960
// exit ;
59958: GO 59985
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59960: LD_ADDR_EXP 134
59964: PUSH
59965: LD_EXP 134
59969: PPUSH
59970: LD_VAR 0 1
59974: PPUSH
59975: LD_VAR 0 2
59979: PPUSH
59980: CALL_OW 1
59984: ST_TO_ADDR
// end ;
59985: LD_VAR 0 3
59989: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59990: LD_INT 0
59992: PPUSH
// if not mc_bases or not base or not teleports_exit then
59993: LD_EXP 116
59997: NOT
59998: PUSH
59999: LD_VAR 0 1
60003: NOT
60004: OR
60005: PUSH
60006: LD_VAR 0 2
60010: NOT
60011: OR
60012: IFFALSE 60016
// exit ;
60014: GO 60041
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60016: LD_ADDR_EXP 151
60020: PUSH
60021: LD_EXP 151
60025: PPUSH
60026: LD_VAR 0 1
60030: PPUSH
60031: LD_VAR 0 2
60035: PPUSH
60036: CALL_OW 1
60040: ST_TO_ADDR
// end ;
60041: LD_VAR 0 3
60045: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60046: LD_INT 0
60048: PPUSH
60049: PPUSH
60050: PPUSH
// if not mc_bases or not base or not ext_list then
60051: LD_EXP 116
60055: NOT
60056: PUSH
60057: LD_VAR 0 1
60061: NOT
60062: OR
60063: PUSH
60064: LD_VAR 0 5
60068: NOT
60069: OR
60070: IFFALSE 60074
// exit ;
60072: GO 60247
// tmp := GetFacExtXYD ( x , y , d ) ;
60074: LD_ADDR_VAR 0 8
60078: PUSH
60079: LD_VAR 0 2
60083: PPUSH
60084: LD_VAR 0 3
60088: PPUSH
60089: LD_VAR 0 4
60093: PPUSH
60094: CALL 99927 0 3
60098: ST_TO_ADDR
// if not tmp then
60099: LD_VAR 0 8
60103: NOT
60104: IFFALSE 60108
// exit ;
60106: GO 60247
// for i in tmp do
60108: LD_ADDR_VAR 0 7
60112: PUSH
60113: LD_VAR 0 8
60117: PUSH
60118: FOR_IN
60119: IFFALSE 60245
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60121: LD_ADDR_EXP 121
60125: PUSH
60126: LD_EXP 121
60130: PPUSH
60131: LD_VAR 0 1
60135: PPUSH
60136: LD_EXP 121
60140: PUSH
60141: LD_VAR 0 1
60145: ARRAY
60146: PPUSH
60147: LD_EXP 121
60151: PUSH
60152: LD_VAR 0 1
60156: ARRAY
60157: PUSH
60158: LD_INT 1
60160: PLUS
60161: PPUSH
60162: LD_VAR 0 5
60166: PUSH
60167: LD_INT 1
60169: ARRAY
60170: PUSH
60171: LD_VAR 0 7
60175: PUSH
60176: LD_INT 1
60178: ARRAY
60179: PUSH
60180: LD_VAR 0 7
60184: PUSH
60185: LD_INT 2
60187: ARRAY
60188: PUSH
60189: LD_VAR 0 7
60193: PUSH
60194: LD_INT 3
60196: ARRAY
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: LIST
60202: LIST
60203: PPUSH
60204: CALL_OW 2
60208: PPUSH
60209: CALL_OW 1
60213: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60214: LD_ADDR_VAR 0 5
60218: PUSH
60219: LD_VAR 0 5
60223: PPUSH
60224: LD_INT 1
60226: PPUSH
60227: CALL_OW 3
60231: ST_TO_ADDR
// if not ext_list then
60232: LD_VAR 0 5
60236: NOT
60237: IFFALSE 60243
// exit ;
60239: POP
60240: POP
60241: GO 60247
// end ;
60243: GO 60118
60245: POP
60246: POP
// end ;
60247: LD_VAR 0 6
60251: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60252: LD_INT 0
60254: PPUSH
// if not mc_bases or not base or not weapon_list then
60255: LD_EXP 116
60259: NOT
60260: PUSH
60261: LD_VAR 0 1
60265: NOT
60266: OR
60267: PUSH
60268: LD_VAR 0 2
60272: NOT
60273: OR
60274: IFFALSE 60278
// exit ;
60276: GO 60303
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60278: LD_ADDR_EXP 155
60282: PUSH
60283: LD_EXP 155
60287: PPUSH
60288: LD_VAR 0 1
60292: PPUSH
60293: LD_VAR 0 2
60297: PPUSH
60298: CALL_OW 1
60302: ST_TO_ADDR
// end ;
60303: LD_VAR 0 3
60307: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60308: LD_INT 0
60310: PPUSH
// if not mc_bases or not base or not tech_list then
60311: LD_EXP 116
60315: NOT
60316: PUSH
60317: LD_VAR 0 1
60321: NOT
60322: OR
60323: PUSH
60324: LD_VAR 0 2
60328: NOT
60329: OR
60330: IFFALSE 60334
// exit ;
60332: GO 60359
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60334: LD_ADDR_EXP 143
60338: PUSH
60339: LD_EXP 143
60343: PPUSH
60344: LD_VAR 0 1
60348: PPUSH
60349: LD_VAR 0 2
60353: PPUSH
60354: CALL_OW 1
60358: ST_TO_ADDR
// end ;
60359: LD_VAR 0 3
60363: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60364: LD_INT 0
60366: PPUSH
// if not mc_bases or not parking_area or not base then
60367: LD_EXP 116
60371: NOT
60372: PUSH
60373: LD_VAR 0 2
60377: NOT
60378: OR
60379: PUSH
60380: LD_VAR 0 1
60384: NOT
60385: OR
60386: IFFALSE 60390
// exit ;
60388: GO 60415
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60390: LD_ADDR_EXP 140
60394: PUSH
60395: LD_EXP 140
60399: PPUSH
60400: LD_VAR 0 1
60404: PPUSH
60405: LD_VAR 0 2
60409: PPUSH
60410: CALL_OW 1
60414: ST_TO_ADDR
// end ;
60415: LD_VAR 0 3
60419: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60420: LD_INT 0
60422: PPUSH
// if not mc_bases or not base or not scan_area then
60423: LD_EXP 116
60427: NOT
60428: PUSH
60429: LD_VAR 0 1
60433: NOT
60434: OR
60435: PUSH
60436: LD_VAR 0 2
60440: NOT
60441: OR
60442: IFFALSE 60446
// exit ;
60444: GO 60471
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60446: LD_ADDR_EXP 141
60450: PUSH
60451: LD_EXP 141
60455: PPUSH
60456: LD_VAR 0 1
60460: PPUSH
60461: LD_VAR 0 2
60465: PPUSH
60466: CALL_OW 1
60470: ST_TO_ADDR
// end ;
60471: LD_VAR 0 3
60475: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60476: LD_INT 0
60478: PPUSH
60479: PPUSH
// if not mc_bases or not base then
60480: LD_EXP 116
60484: NOT
60485: PUSH
60486: LD_VAR 0 1
60490: NOT
60491: OR
60492: IFFALSE 60496
// exit ;
60494: GO 60560
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60496: LD_ADDR_VAR 0 3
60500: PUSH
60501: LD_INT 1
60503: PUSH
60504: LD_INT 2
60506: PUSH
60507: LD_INT 3
60509: PUSH
60510: LD_INT 4
60512: PUSH
60513: LD_INT 11
60515: PUSH
60516: EMPTY
60517: LIST
60518: LIST
60519: LIST
60520: LIST
60521: LIST
60522: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60523: LD_ADDR_EXP 143
60527: PUSH
60528: LD_EXP 143
60532: PPUSH
60533: LD_VAR 0 1
60537: PPUSH
60538: LD_EXP 143
60542: PUSH
60543: LD_VAR 0 1
60547: ARRAY
60548: PUSH
60549: LD_VAR 0 3
60553: DIFF
60554: PPUSH
60555: CALL_OW 1
60559: ST_TO_ADDR
// end ;
60560: LD_VAR 0 2
60564: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60565: LD_INT 0
60567: PPUSH
// result := mc_vehicles [ base ] ;
60568: LD_ADDR_VAR 0 3
60572: PUSH
60573: LD_EXP 135
60577: PUSH
60578: LD_VAR 0 1
60582: ARRAY
60583: ST_TO_ADDR
// if onlyCombat then
60584: LD_VAR 0 2
60588: IFFALSE 60766
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60590: LD_ADDR_VAR 0 3
60594: PUSH
60595: LD_VAR 0 3
60599: PUSH
60600: LD_VAR 0 3
60604: PPUSH
60605: LD_INT 2
60607: PUSH
60608: LD_INT 34
60610: PUSH
60611: LD_INT 12
60613: PUSH
60614: EMPTY
60615: LIST
60616: LIST
60617: PUSH
60618: LD_INT 34
60620: PUSH
60621: LD_INT 51
60623: PUSH
60624: EMPTY
60625: LIST
60626: LIST
60627: PUSH
60628: LD_INT 34
60630: PUSH
60631: LD_EXP 96
60635: PUSH
60636: EMPTY
60637: LIST
60638: LIST
60639: PUSH
60640: LD_INT 34
60642: PUSH
60643: LD_INT 32
60645: PUSH
60646: EMPTY
60647: LIST
60648: LIST
60649: PUSH
60650: LD_INT 34
60652: PUSH
60653: LD_INT 13
60655: PUSH
60656: EMPTY
60657: LIST
60658: LIST
60659: PUSH
60660: LD_INT 34
60662: PUSH
60663: LD_INT 52
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: PUSH
60670: LD_INT 34
60672: PUSH
60673: LD_EXP 101
60677: PUSH
60678: EMPTY
60679: LIST
60680: LIST
60681: PUSH
60682: LD_INT 34
60684: PUSH
60685: LD_INT 14
60687: PUSH
60688: EMPTY
60689: LIST
60690: LIST
60691: PUSH
60692: LD_INT 34
60694: PUSH
60695: LD_INT 53
60697: PUSH
60698: EMPTY
60699: LIST
60700: LIST
60701: PUSH
60702: LD_INT 34
60704: PUSH
60705: LD_EXP 95
60709: PUSH
60710: EMPTY
60711: LIST
60712: LIST
60713: PUSH
60714: LD_INT 34
60716: PUSH
60717: LD_INT 31
60719: PUSH
60720: EMPTY
60721: LIST
60722: LIST
60723: PUSH
60724: LD_INT 34
60726: PUSH
60727: LD_INT 48
60729: PUSH
60730: EMPTY
60731: LIST
60732: LIST
60733: PUSH
60734: LD_INT 34
60736: PUSH
60737: LD_INT 8
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: PUSH
60744: EMPTY
60745: LIST
60746: LIST
60747: LIST
60748: LIST
60749: LIST
60750: LIST
60751: LIST
60752: LIST
60753: LIST
60754: LIST
60755: LIST
60756: LIST
60757: LIST
60758: LIST
60759: PPUSH
60760: CALL_OW 72
60764: DIFF
60765: ST_TO_ADDR
// end ; end_of_file
60766: LD_VAR 0 3
60770: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60771: LD_INT 0
60773: PPUSH
60774: PPUSH
60775: PPUSH
// if not mc_bases or not skirmish then
60776: LD_EXP 116
60780: NOT
60781: PUSH
60782: LD_EXP 114
60786: NOT
60787: OR
60788: IFFALSE 60792
// exit ;
60790: GO 60957
// for i = 1 to mc_bases do
60792: LD_ADDR_VAR 0 4
60796: PUSH
60797: DOUBLE
60798: LD_INT 1
60800: DEC
60801: ST_TO_ADDR
60802: LD_EXP 116
60806: PUSH
60807: FOR_TO
60808: IFFALSE 60955
// begin if sci in mc_bases [ i ] then
60810: LD_VAR 0 2
60814: PUSH
60815: LD_EXP 116
60819: PUSH
60820: LD_VAR 0 4
60824: ARRAY
60825: IN
60826: IFFALSE 60953
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60828: LD_ADDR_EXP 145
60832: PUSH
60833: LD_EXP 145
60837: PPUSH
60838: LD_VAR 0 4
60842: PUSH
60843: LD_EXP 145
60847: PUSH
60848: LD_VAR 0 4
60852: ARRAY
60853: PUSH
60854: LD_INT 1
60856: PLUS
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: PPUSH
60862: LD_VAR 0 1
60866: PPUSH
60867: CALL 70539 0 3
60871: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60872: LD_ADDR_VAR 0 5
60876: PUSH
60877: LD_EXP 116
60881: PUSH
60882: LD_VAR 0 4
60886: ARRAY
60887: PPUSH
60888: LD_INT 2
60890: PUSH
60891: LD_INT 30
60893: PUSH
60894: LD_INT 0
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: LD_INT 30
60903: PUSH
60904: LD_INT 1
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: LIST
60915: PPUSH
60916: CALL_OW 72
60920: PPUSH
60921: LD_VAR 0 1
60925: PPUSH
60926: CALL_OW 74
60930: ST_TO_ADDR
// if tmp then
60931: LD_VAR 0 5
60935: IFFALSE 60951
// ComStandNearbyBuilding ( ape , tmp ) ;
60937: LD_VAR 0 1
60941: PPUSH
60942: LD_VAR 0 5
60946: PPUSH
60947: CALL 67117 0 2
// break ;
60951: GO 60955
// end ; end ;
60953: GO 60807
60955: POP
60956: POP
// end ;
60957: LD_VAR 0 3
60961: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60962: LD_INT 0
60964: PPUSH
60965: PPUSH
60966: PPUSH
// if not mc_bases or not skirmish then
60967: LD_EXP 116
60971: NOT
60972: PUSH
60973: LD_EXP 114
60977: NOT
60978: OR
60979: IFFALSE 60983
// exit ;
60981: GO 61072
// for i = 1 to mc_bases do
60983: LD_ADDR_VAR 0 4
60987: PUSH
60988: DOUBLE
60989: LD_INT 1
60991: DEC
60992: ST_TO_ADDR
60993: LD_EXP 116
60997: PUSH
60998: FOR_TO
60999: IFFALSE 61070
// begin if building in mc_busy_turret_list [ i ] then
61001: LD_VAR 0 1
61005: PUSH
61006: LD_EXP 126
61010: PUSH
61011: LD_VAR 0 4
61015: ARRAY
61016: IN
61017: IFFALSE 61068
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61019: LD_ADDR_VAR 0 5
61023: PUSH
61024: LD_EXP 126
61028: PUSH
61029: LD_VAR 0 4
61033: ARRAY
61034: PUSH
61035: LD_VAR 0 1
61039: DIFF
61040: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61041: LD_ADDR_EXP 126
61045: PUSH
61046: LD_EXP 126
61050: PPUSH
61051: LD_VAR 0 4
61055: PPUSH
61056: LD_VAR 0 5
61060: PPUSH
61061: CALL_OW 1
61065: ST_TO_ADDR
// break ;
61066: GO 61070
// end ; end ;
61068: GO 60998
61070: POP
61071: POP
// end ;
61072: LD_VAR 0 3
61076: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61077: LD_INT 0
61079: PPUSH
61080: PPUSH
61081: PPUSH
// if not mc_bases or not skirmish then
61082: LD_EXP 116
61086: NOT
61087: PUSH
61088: LD_EXP 114
61092: NOT
61093: OR
61094: IFFALSE 61098
// exit ;
61096: GO 61297
// for i = 1 to mc_bases do
61098: LD_ADDR_VAR 0 5
61102: PUSH
61103: DOUBLE
61104: LD_INT 1
61106: DEC
61107: ST_TO_ADDR
61108: LD_EXP 116
61112: PUSH
61113: FOR_TO
61114: IFFALSE 61295
// if building in mc_bases [ i ] then
61116: LD_VAR 0 1
61120: PUSH
61121: LD_EXP 116
61125: PUSH
61126: LD_VAR 0 5
61130: ARRAY
61131: IN
61132: IFFALSE 61293
// begin tmp := mc_bases [ i ] diff building ;
61134: LD_ADDR_VAR 0 6
61138: PUSH
61139: LD_EXP 116
61143: PUSH
61144: LD_VAR 0 5
61148: ARRAY
61149: PUSH
61150: LD_VAR 0 1
61154: DIFF
61155: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61156: LD_ADDR_EXP 116
61160: PUSH
61161: LD_EXP 116
61165: PPUSH
61166: LD_VAR 0 5
61170: PPUSH
61171: LD_VAR 0 6
61175: PPUSH
61176: CALL_OW 1
61180: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61181: LD_VAR 0 1
61185: PUSH
61186: LD_EXP 124
61190: PUSH
61191: LD_VAR 0 5
61195: ARRAY
61196: IN
61197: IFFALSE 61236
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61199: LD_ADDR_EXP 124
61203: PUSH
61204: LD_EXP 124
61208: PPUSH
61209: LD_VAR 0 5
61213: PPUSH
61214: LD_EXP 124
61218: PUSH
61219: LD_VAR 0 5
61223: ARRAY
61224: PUSH
61225: LD_VAR 0 1
61229: DIFF
61230: PPUSH
61231: CALL_OW 1
61235: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61236: LD_VAR 0 1
61240: PUSH
61241: LD_EXP 125
61245: PUSH
61246: LD_VAR 0 5
61250: ARRAY
61251: IN
61252: IFFALSE 61291
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61254: LD_ADDR_EXP 125
61258: PUSH
61259: LD_EXP 125
61263: PPUSH
61264: LD_VAR 0 5
61268: PPUSH
61269: LD_EXP 125
61273: PUSH
61274: LD_VAR 0 5
61278: ARRAY
61279: PUSH
61280: LD_VAR 0 1
61284: DIFF
61285: PPUSH
61286: CALL_OW 1
61290: ST_TO_ADDR
// break ;
61291: GO 61295
// end ;
61293: GO 61113
61295: POP
61296: POP
// end ;
61297: LD_VAR 0 4
61301: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61302: LD_INT 0
61304: PPUSH
61305: PPUSH
61306: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61307: LD_EXP 116
61311: NOT
61312: PUSH
61313: LD_EXP 114
61317: NOT
61318: OR
61319: PUSH
61320: LD_VAR 0 3
61324: PUSH
61325: LD_EXP 142
61329: IN
61330: NOT
61331: OR
61332: IFFALSE 61336
// exit ;
61334: GO 61459
// for i = 1 to mc_vehicles do
61336: LD_ADDR_VAR 0 6
61340: PUSH
61341: DOUBLE
61342: LD_INT 1
61344: DEC
61345: ST_TO_ADDR
61346: LD_EXP 135
61350: PUSH
61351: FOR_TO
61352: IFFALSE 61457
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61354: LD_VAR 0 2
61358: PUSH
61359: LD_EXP 135
61363: PUSH
61364: LD_VAR 0 6
61368: ARRAY
61369: IN
61370: PUSH
61371: LD_VAR 0 1
61375: PUSH
61376: LD_EXP 135
61380: PUSH
61381: LD_VAR 0 6
61385: ARRAY
61386: IN
61387: OR
61388: IFFALSE 61455
// begin tmp := mc_vehicles [ i ] diff old ;
61390: LD_ADDR_VAR 0 7
61394: PUSH
61395: LD_EXP 135
61399: PUSH
61400: LD_VAR 0 6
61404: ARRAY
61405: PUSH
61406: LD_VAR 0 2
61410: DIFF
61411: ST_TO_ADDR
// tmp := tmp diff new ;
61412: LD_ADDR_VAR 0 7
61416: PUSH
61417: LD_VAR 0 7
61421: PUSH
61422: LD_VAR 0 1
61426: DIFF
61427: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61428: LD_ADDR_EXP 135
61432: PUSH
61433: LD_EXP 135
61437: PPUSH
61438: LD_VAR 0 6
61442: PPUSH
61443: LD_VAR 0 7
61447: PPUSH
61448: CALL_OW 1
61452: ST_TO_ADDR
// break ;
61453: GO 61457
// end ;
61455: GO 61351
61457: POP
61458: POP
// end ;
61459: LD_VAR 0 5
61463: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61464: LD_INT 0
61466: PPUSH
61467: PPUSH
61468: PPUSH
61469: PPUSH
// if not mc_bases or not skirmish then
61470: LD_EXP 116
61474: NOT
61475: PUSH
61476: LD_EXP 114
61480: NOT
61481: OR
61482: IFFALSE 61486
// exit ;
61484: GO 61878
// side := GetSide ( vehicle ) ;
61486: LD_ADDR_VAR 0 5
61490: PUSH
61491: LD_VAR 0 1
61495: PPUSH
61496: CALL_OW 255
61500: ST_TO_ADDR
// for i = 1 to mc_bases do
61501: LD_ADDR_VAR 0 4
61505: PUSH
61506: DOUBLE
61507: LD_INT 1
61509: DEC
61510: ST_TO_ADDR
61511: LD_EXP 116
61515: PUSH
61516: FOR_TO
61517: IFFALSE 61876
// begin if factory in mc_bases [ i ] then
61519: LD_VAR 0 2
61523: PUSH
61524: LD_EXP 116
61528: PUSH
61529: LD_VAR 0 4
61533: ARRAY
61534: IN
61535: IFFALSE 61874
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61537: LD_EXP 138
61541: PUSH
61542: LD_VAR 0 4
61546: ARRAY
61547: PUSH
61548: LD_EXP 127
61552: PUSH
61553: LD_VAR 0 4
61557: ARRAY
61558: LESS
61559: PUSH
61560: LD_VAR 0 1
61564: PPUSH
61565: CALL_OW 264
61569: PUSH
61570: LD_INT 31
61572: PUSH
61573: LD_INT 32
61575: PUSH
61576: LD_INT 51
61578: PUSH
61579: LD_EXP 96
61583: PUSH
61584: LD_INT 12
61586: PUSH
61587: LD_INT 30
61589: PUSH
61590: LD_EXP 95
61594: PUSH
61595: LD_INT 11
61597: PUSH
61598: LD_INT 53
61600: PUSH
61601: LD_INT 14
61603: PUSH
61604: LD_EXP 99
61608: PUSH
61609: LD_INT 29
61611: PUSH
61612: LD_EXP 97
61616: PUSH
61617: LD_INT 13
61619: PUSH
61620: LD_INT 52
61622: PUSH
61623: LD_EXP 101
61627: PUSH
61628: LD_INT 48
61630: PUSH
61631: LD_INT 8
61633: PUSH
61634: EMPTY
61635: LIST
61636: LIST
61637: LIST
61638: LIST
61639: LIST
61640: LIST
61641: LIST
61642: LIST
61643: LIST
61644: LIST
61645: LIST
61646: LIST
61647: LIST
61648: LIST
61649: LIST
61650: LIST
61651: LIST
61652: LIST
61653: IN
61654: NOT
61655: AND
61656: IFFALSE 61704
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61658: LD_ADDR_EXP 138
61662: PUSH
61663: LD_EXP 138
61667: PPUSH
61668: LD_VAR 0 4
61672: PUSH
61673: LD_EXP 138
61677: PUSH
61678: LD_VAR 0 4
61682: ARRAY
61683: PUSH
61684: LD_INT 1
61686: PLUS
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PPUSH
61692: LD_VAR 0 1
61696: PPUSH
61697: CALL 70539 0 3
61701: ST_TO_ADDR
61702: GO 61748
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61704: LD_ADDR_EXP 135
61708: PUSH
61709: LD_EXP 135
61713: PPUSH
61714: LD_VAR 0 4
61718: PUSH
61719: LD_EXP 135
61723: PUSH
61724: LD_VAR 0 4
61728: ARRAY
61729: PUSH
61730: LD_INT 1
61732: PLUS
61733: PUSH
61734: EMPTY
61735: LIST
61736: LIST
61737: PPUSH
61738: LD_VAR 0 1
61742: PPUSH
61743: CALL 70539 0 3
61747: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61748: LD_VAR 0 1
61752: PPUSH
61753: CALL_OW 263
61757: PUSH
61758: LD_INT 2
61760: EQUAL
61761: IFFALSE 61790
// begin repeat Connect ( vehicle ) ;
61763: LD_VAR 0 1
61767: PPUSH
61768: CALL 73510 0 1
// wait ( 0 0$1 ) ;
61772: LD_INT 35
61774: PPUSH
61775: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61779: LD_VAR 0 1
61783: PPUSH
61784: CALL_OW 312
61788: IFFALSE 61763
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61790: LD_VAR 0 1
61794: PPUSH
61795: LD_EXP 140
61799: PUSH
61800: LD_VAR 0 4
61804: ARRAY
61805: PPUSH
61806: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61810: LD_VAR 0 1
61814: PPUSH
61815: CALL_OW 263
61819: PUSH
61820: LD_INT 1
61822: NONEQUAL
61823: IFFALSE 61827
// break ;
61825: GO 61876
// repeat wait ( 0 0$1 ) ;
61827: LD_INT 35
61829: PPUSH
61830: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61834: LD_VAR 0 1
61838: PPUSH
61839: LD_EXP 140
61843: PUSH
61844: LD_VAR 0 4
61848: ARRAY
61849: PPUSH
61850: CALL_OW 308
61854: IFFALSE 61827
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61856: LD_VAR 0 1
61860: PPUSH
61861: CALL_OW 311
61865: PPUSH
61866: CALL_OW 121
// exit ;
61870: POP
61871: POP
61872: GO 61878
// end ; end ;
61874: GO 61516
61876: POP
61877: POP
// end ;
61878: LD_VAR 0 3
61882: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61883: LD_INT 0
61885: PPUSH
61886: PPUSH
61887: PPUSH
61888: PPUSH
// if not mc_bases or not skirmish then
61889: LD_EXP 116
61893: NOT
61894: PUSH
61895: LD_EXP 114
61899: NOT
61900: OR
61901: IFFALSE 61905
// exit ;
61903: GO 62258
// repeat wait ( 0 0$1 ) ;
61905: LD_INT 35
61907: PPUSH
61908: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61912: LD_VAR 0 2
61916: PPUSH
61917: LD_VAR 0 3
61921: PPUSH
61922: CALL_OW 284
61926: IFFALSE 61905
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61928: LD_VAR 0 2
61932: PPUSH
61933: LD_VAR 0 3
61937: PPUSH
61938: CALL_OW 283
61942: PUSH
61943: LD_INT 4
61945: EQUAL
61946: IFFALSE 61950
// exit ;
61948: GO 62258
// for i = 1 to mc_bases do
61950: LD_ADDR_VAR 0 7
61954: PUSH
61955: DOUBLE
61956: LD_INT 1
61958: DEC
61959: ST_TO_ADDR
61960: LD_EXP 116
61964: PUSH
61965: FOR_TO
61966: IFFALSE 62256
// begin if mc_crates_area [ i ] then
61968: LD_EXP 134
61972: PUSH
61973: LD_VAR 0 7
61977: ARRAY
61978: IFFALSE 62089
// for j in mc_crates_area [ i ] do
61980: LD_ADDR_VAR 0 8
61984: PUSH
61985: LD_EXP 134
61989: PUSH
61990: LD_VAR 0 7
61994: ARRAY
61995: PUSH
61996: FOR_IN
61997: IFFALSE 62087
// if InArea ( x , y , j ) then
61999: LD_VAR 0 2
62003: PPUSH
62004: LD_VAR 0 3
62008: PPUSH
62009: LD_VAR 0 8
62013: PPUSH
62014: CALL_OW 309
62018: IFFALSE 62085
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62020: LD_ADDR_EXP 132
62024: PUSH
62025: LD_EXP 132
62029: PPUSH
62030: LD_VAR 0 7
62034: PUSH
62035: LD_EXP 132
62039: PUSH
62040: LD_VAR 0 7
62044: ARRAY
62045: PUSH
62046: LD_INT 1
62048: PLUS
62049: PUSH
62050: EMPTY
62051: LIST
62052: LIST
62053: PPUSH
62054: LD_VAR 0 4
62058: PUSH
62059: LD_VAR 0 2
62063: PUSH
62064: LD_VAR 0 3
62068: PUSH
62069: EMPTY
62070: LIST
62071: LIST
62072: LIST
62073: PPUSH
62074: CALL 70539 0 3
62078: ST_TO_ADDR
// exit ;
62079: POP
62080: POP
62081: POP
62082: POP
62083: GO 62258
// end ;
62085: GO 61996
62087: POP
62088: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62089: LD_ADDR_VAR 0 9
62093: PUSH
62094: LD_EXP 116
62098: PUSH
62099: LD_VAR 0 7
62103: ARRAY
62104: PPUSH
62105: LD_INT 2
62107: PUSH
62108: LD_INT 30
62110: PUSH
62111: LD_INT 0
62113: PUSH
62114: EMPTY
62115: LIST
62116: LIST
62117: PUSH
62118: LD_INT 30
62120: PUSH
62121: LD_INT 1
62123: PUSH
62124: EMPTY
62125: LIST
62126: LIST
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: LIST
62132: PPUSH
62133: CALL_OW 72
62137: ST_TO_ADDR
// if not depot then
62138: LD_VAR 0 9
62142: NOT
62143: IFFALSE 62147
// continue ;
62145: GO 61965
// for j in depot do
62147: LD_ADDR_VAR 0 8
62151: PUSH
62152: LD_VAR 0 9
62156: PUSH
62157: FOR_IN
62158: IFFALSE 62252
// if GetDistUnitXY ( j , x , y ) < 30 then
62160: LD_VAR 0 8
62164: PPUSH
62165: LD_VAR 0 2
62169: PPUSH
62170: LD_VAR 0 3
62174: PPUSH
62175: CALL_OW 297
62179: PUSH
62180: LD_INT 30
62182: LESS
62183: IFFALSE 62250
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62185: LD_ADDR_EXP 132
62189: PUSH
62190: LD_EXP 132
62194: PPUSH
62195: LD_VAR 0 7
62199: PUSH
62200: LD_EXP 132
62204: PUSH
62205: LD_VAR 0 7
62209: ARRAY
62210: PUSH
62211: LD_INT 1
62213: PLUS
62214: PUSH
62215: EMPTY
62216: LIST
62217: LIST
62218: PPUSH
62219: LD_VAR 0 4
62223: PUSH
62224: LD_VAR 0 2
62228: PUSH
62229: LD_VAR 0 3
62233: PUSH
62234: EMPTY
62235: LIST
62236: LIST
62237: LIST
62238: PPUSH
62239: CALL 70539 0 3
62243: ST_TO_ADDR
// exit ;
62244: POP
62245: POP
62246: POP
62247: POP
62248: GO 62258
// end ;
62250: GO 62157
62252: POP
62253: POP
// end ;
62254: GO 61965
62256: POP
62257: POP
// end ;
62258: LD_VAR 0 6
62262: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62263: LD_INT 0
62265: PPUSH
62266: PPUSH
62267: PPUSH
62268: PPUSH
// if not mc_bases or not skirmish then
62269: LD_EXP 116
62273: NOT
62274: PUSH
62275: LD_EXP 114
62279: NOT
62280: OR
62281: IFFALSE 62285
// exit ;
62283: GO 62562
// side := GetSide ( lab ) ;
62285: LD_ADDR_VAR 0 4
62289: PUSH
62290: LD_VAR 0 2
62294: PPUSH
62295: CALL_OW 255
62299: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62300: LD_VAR 0 4
62304: PUSH
62305: LD_EXP 142
62309: IN
62310: NOT
62311: PUSH
62312: LD_EXP 143
62316: NOT
62317: OR
62318: PUSH
62319: LD_EXP 116
62323: NOT
62324: OR
62325: IFFALSE 62329
// exit ;
62327: GO 62562
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62329: LD_ADDR_EXP 143
62333: PUSH
62334: LD_EXP 143
62338: PPUSH
62339: LD_VAR 0 4
62343: PPUSH
62344: LD_EXP 143
62348: PUSH
62349: LD_VAR 0 4
62353: ARRAY
62354: PUSH
62355: LD_VAR 0 1
62359: DIFF
62360: PPUSH
62361: CALL_OW 1
62365: ST_TO_ADDR
// for i = 1 to mc_bases do
62366: LD_ADDR_VAR 0 5
62370: PUSH
62371: DOUBLE
62372: LD_INT 1
62374: DEC
62375: ST_TO_ADDR
62376: LD_EXP 116
62380: PUSH
62381: FOR_TO
62382: IFFALSE 62560
// begin if lab in mc_bases [ i ] then
62384: LD_VAR 0 2
62388: PUSH
62389: LD_EXP 116
62393: PUSH
62394: LD_VAR 0 5
62398: ARRAY
62399: IN
62400: IFFALSE 62558
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62402: LD_VAR 0 1
62406: PUSH
62407: LD_INT 11
62409: PUSH
62410: LD_INT 4
62412: PUSH
62413: LD_INT 3
62415: PUSH
62416: LD_INT 2
62418: PUSH
62419: EMPTY
62420: LIST
62421: LIST
62422: LIST
62423: LIST
62424: IN
62425: PUSH
62426: LD_EXP 146
62430: PUSH
62431: LD_VAR 0 5
62435: ARRAY
62436: AND
62437: IFFALSE 62558
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62439: LD_ADDR_VAR 0 6
62443: PUSH
62444: LD_EXP 146
62448: PUSH
62449: LD_VAR 0 5
62453: ARRAY
62454: PUSH
62455: LD_INT 1
62457: ARRAY
62458: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62459: LD_ADDR_EXP 146
62463: PUSH
62464: LD_EXP 146
62468: PPUSH
62469: LD_VAR 0 5
62473: PPUSH
62474: EMPTY
62475: PPUSH
62476: CALL_OW 1
62480: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62481: LD_VAR 0 6
62485: PPUSH
62486: LD_INT 0
62488: PPUSH
62489: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62493: LD_VAR 0 6
62497: PPUSH
62498: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62502: LD_ADDR_EXP 145
62506: PUSH
62507: LD_EXP 145
62511: PPUSH
62512: LD_VAR 0 5
62516: PPUSH
62517: LD_EXP 145
62521: PUSH
62522: LD_VAR 0 5
62526: ARRAY
62527: PPUSH
62528: LD_INT 1
62530: PPUSH
62531: LD_VAR 0 6
62535: PPUSH
62536: CALL_OW 2
62540: PPUSH
62541: CALL_OW 1
62545: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62546: LD_VAR 0 5
62550: PPUSH
62551: LD_INT 112
62553: PPUSH
62554: CALL 39297 0 2
// end ; end ; end ;
62558: GO 62381
62560: POP
62561: POP
// end ;
62562: LD_VAR 0 3
62566: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62567: LD_INT 0
62569: PPUSH
62570: PPUSH
62571: PPUSH
62572: PPUSH
62573: PPUSH
62574: PPUSH
62575: PPUSH
62576: PPUSH
// if not mc_bases or not skirmish then
62577: LD_EXP 116
62581: NOT
62582: PUSH
62583: LD_EXP 114
62587: NOT
62588: OR
62589: IFFALSE 62593
// exit ;
62591: GO 63964
// for i = 1 to mc_bases do
62593: LD_ADDR_VAR 0 3
62597: PUSH
62598: DOUBLE
62599: LD_INT 1
62601: DEC
62602: ST_TO_ADDR
62603: LD_EXP 116
62607: PUSH
62608: FOR_TO
62609: IFFALSE 63962
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62611: LD_VAR 0 1
62615: PUSH
62616: LD_EXP 116
62620: PUSH
62621: LD_VAR 0 3
62625: ARRAY
62626: IN
62627: PUSH
62628: LD_VAR 0 1
62632: PUSH
62633: LD_EXP 123
62637: PUSH
62638: LD_VAR 0 3
62642: ARRAY
62643: IN
62644: OR
62645: PUSH
62646: LD_VAR 0 1
62650: PUSH
62651: LD_EXP 138
62655: PUSH
62656: LD_VAR 0 3
62660: ARRAY
62661: IN
62662: OR
62663: PUSH
62664: LD_VAR 0 1
62668: PUSH
62669: LD_EXP 135
62673: PUSH
62674: LD_VAR 0 3
62678: ARRAY
62679: IN
62680: OR
62681: PUSH
62682: LD_VAR 0 1
62686: PUSH
62687: LD_EXP 145
62691: PUSH
62692: LD_VAR 0 3
62696: ARRAY
62697: IN
62698: OR
62699: PUSH
62700: LD_VAR 0 1
62704: PUSH
62705: LD_EXP 146
62709: PUSH
62710: LD_VAR 0 3
62714: ARRAY
62715: IN
62716: OR
62717: IFFALSE 63960
// begin if un in mc_ape [ i ] then
62719: LD_VAR 0 1
62723: PUSH
62724: LD_EXP 145
62728: PUSH
62729: LD_VAR 0 3
62733: ARRAY
62734: IN
62735: IFFALSE 62774
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62737: LD_ADDR_EXP 145
62741: PUSH
62742: LD_EXP 145
62746: PPUSH
62747: LD_VAR 0 3
62751: PPUSH
62752: LD_EXP 145
62756: PUSH
62757: LD_VAR 0 3
62761: ARRAY
62762: PUSH
62763: LD_VAR 0 1
62767: DIFF
62768: PPUSH
62769: CALL_OW 1
62773: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62774: LD_VAR 0 1
62778: PUSH
62779: LD_EXP 146
62783: PUSH
62784: LD_VAR 0 3
62788: ARRAY
62789: IN
62790: IFFALSE 62814
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62792: LD_ADDR_EXP 146
62796: PUSH
62797: LD_EXP 146
62801: PPUSH
62802: LD_VAR 0 3
62806: PPUSH
62807: EMPTY
62808: PPUSH
62809: CALL_OW 1
62813: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62814: LD_VAR 0 1
62818: PPUSH
62819: CALL_OW 247
62823: PUSH
62824: LD_INT 2
62826: EQUAL
62827: PUSH
62828: LD_VAR 0 1
62832: PPUSH
62833: CALL_OW 110
62837: PUSH
62838: LD_INT 20
62840: EQUAL
62841: PUSH
62842: LD_VAR 0 1
62846: PUSH
62847: LD_EXP 138
62851: PUSH
62852: LD_VAR 0 3
62856: ARRAY
62857: IN
62858: OR
62859: PUSH
62860: LD_VAR 0 1
62864: PPUSH
62865: CALL_OW 264
62869: PUSH
62870: LD_INT 12
62872: PUSH
62873: LD_INT 51
62875: PUSH
62876: LD_EXP 96
62880: PUSH
62881: LD_INT 32
62883: PUSH
62884: LD_INT 13
62886: PUSH
62887: LD_INT 52
62889: PUSH
62890: LD_INT 31
62892: PUSH
62893: EMPTY
62894: LIST
62895: LIST
62896: LIST
62897: LIST
62898: LIST
62899: LIST
62900: LIST
62901: IN
62902: OR
62903: AND
62904: IFFALSE 63212
// begin if un in mc_defender [ i ] then
62906: LD_VAR 0 1
62910: PUSH
62911: LD_EXP 138
62915: PUSH
62916: LD_VAR 0 3
62920: ARRAY
62921: IN
62922: IFFALSE 62961
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62924: LD_ADDR_EXP 138
62928: PUSH
62929: LD_EXP 138
62933: PPUSH
62934: LD_VAR 0 3
62938: PPUSH
62939: LD_EXP 138
62943: PUSH
62944: LD_VAR 0 3
62948: ARRAY
62949: PUSH
62950: LD_VAR 0 1
62954: DIFF
62955: PPUSH
62956: CALL_OW 1
62960: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62961: LD_ADDR_VAR 0 8
62965: PUSH
62966: LD_VAR 0 3
62970: PPUSH
62971: LD_INT 3
62973: PPUSH
62974: CALL 59602 0 2
62978: ST_TO_ADDR
// if fac then
62979: LD_VAR 0 8
62983: IFFALSE 63212
// begin for j in fac do
62985: LD_ADDR_VAR 0 4
62989: PUSH
62990: LD_VAR 0 8
62994: PUSH
62995: FOR_IN
62996: IFFALSE 63210
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62998: LD_ADDR_VAR 0 9
63002: PUSH
63003: LD_VAR 0 8
63007: PPUSH
63008: LD_VAR 0 1
63012: PPUSH
63013: CALL_OW 265
63017: PPUSH
63018: LD_VAR 0 1
63022: PPUSH
63023: CALL_OW 262
63027: PPUSH
63028: LD_VAR 0 1
63032: PPUSH
63033: CALL_OW 263
63037: PPUSH
63038: LD_VAR 0 1
63042: PPUSH
63043: CALL_OW 264
63047: PPUSH
63048: CALL 68035 0 5
63052: ST_TO_ADDR
// if components then
63053: LD_VAR 0 9
63057: IFFALSE 63208
// begin if GetWeapon ( un ) = ar_control_tower then
63059: LD_VAR 0 1
63063: PPUSH
63064: CALL_OW 264
63068: PUSH
63069: LD_INT 31
63071: EQUAL
63072: IFFALSE 63189
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63074: LD_VAR 0 1
63078: PPUSH
63079: CALL_OW 311
63083: PPUSH
63084: LD_INT 0
63086: PPUSH
63087: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63091: LD_ADDR_EXP 156
63095: PUSH
63096: LD_EXP 156
63100: PPUSH
63101: LD_VAR 0 3
63105: PPUSH
63106: LD_EXP 156
63110: PUSH
63111: LD_VAR 0 3
63115: ARRAY
63116: PUSH
63117: LD_VAR 0 1
63121: PPUSH
63122: CALL_OW 311
63126: DIFF
63127: PPUSH
63128: CALL_OW 1
63132: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63133: LD_ADDR_VAR 0 7
63137: PUSH
63138: LD_EXP 137
63142: PUSH
63143: LD_VAR 0 3
63147: ARRAY
63148: PPUSH
63149: LD_INT 1
63151: PPUSH
63152: LD_VAR 0 9
63156: PPUSH
63157: CALL_OW 2
63161: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63162: LD_ADDR_EXP 137
63166: PUSH
63167: LD_EXP 137
63171: PPUSH
63172: LD_VAR 0 3
63176: PPUSH
63177: LD_VAR 0 7
63181: PPUSH
63182: CALL_OW 1
63186: ST_TO_ADDR
// end else
63187: GO 63206
// MC_InsertProduceList ( i , [ components ] ) ;
63189: LD_VAR 0 3
63193: PPUSH
63194: LD_VAR 0 9
63198: PUSH
63199: EMPTY
63200: LIST
63201: PPUSH
63202: CALL 59147 0 2
// break ;
63206: GO 63210
// end ; end ;
63208: GO 62995
63210: POP
63211: POP
// end ; end ; if GetType ( un ) = unit_building then
63212: LD_VAR 0 1
63216: PPUSH
63217: CALL_OW 247
63221: PUSH
63222: LD_INT 3
63224: EQUAL
63225: IFFALSE 63628
// begin btype := GetBType ( un ) ;
63227: LD_ADDR_VAR 0 5
63231: PUSH
63232: LD_VAR 0 1
63236: PPUSH
63237: CALL_OW 266
63241: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63242: LD_VAR 0 5
63246: PUSH
63247: LD_INT 29
63249: PUSH
63250: LD_INT 30
63252: PUSH
63253: EMPTY
63254: LIST
63255: LIST
63256: IN
63257: IFFALSE 63330
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63259: LD_VAR 0 1
63263: PPUSH
63264: CALL_OW 250
63268: PPUSH
63269: LD_VAR 0 1
63273: PPUSH
63274: CALL_OW 251
63278: PPUSH
63279: LD_VAR 0 1
63283: PPUSH
63284: CALL_OW 255
63288: PPUSH
63289: CALL_OW 440
63293: NOT
63294: IFFALSE 63330
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63296: LD_VAR 0 1
63300: PPUSH
63301: CALL_OW 250
63305: PPUSH
63306: LD_VAR 0 1
63310: PPUSH
63311: CALL_OW 251
63315: PPUSH
63316: LD_VAR 0 1
63320: PPUSH
63321: CALL_OW 255
63325: PPUSH
63326: CALL_OW 441
// end ; if btype = b_warehouse then
63330: LD_VAR 0 5
63334: PUSH
63335: LD_INT 1
63337: EQUAL
63338: IFFALSE 63356
// begin btype := b_depot ;
63340: LD_ADDR_VAR 0 5
63344: PUSH
63345: LD_INT 0
63347: ST_TO_ADDR
// pos := 1 ;
63348: LD_ADDR_VAR 0 6
63352: PUSH
63353: LD_INT 1
63355: ST_TO_ADDR
// end ; if btype = b_factory then
63356: LD_VAR 0 5
63360: PUSH
63361: LD_INT 3
63363: EQUAL
63364: IFFALSE 63382
// begin btype := b_workshop ;
63366: LD_ADDR_VAR 0 5
63370: PUSH
63371: LD_INT 2
63373: ST_TO_ADDR
// pos := 1 ;
63374: LD_ADDR_VAR 0 6
63378: PUSH
63379: LD_INT 1
63381: ST_TO_ADDR
// end ; if btype = b_barracks then
63382: LD_VAR 0 5
63386: PUSH
63387: LD_INT 5
63389: EQUAL
63390: IFFALSE 63400
// btype := b_armoury ;
63392: LD_ADDR_VAR 0 5
63396: PUSH
63397: LD_INT 4
63399: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63400: LD_VAR 0 5
63404: PUSH
63405: LD_INT 7
63407: PUSH
63408: LD_INT 8
63410: PUSH
63411: EMPTY
63412: LIST
63413: LIST
63414: IN
63415: IFFALSE 63425
// btype := b_lab ;
63417: LD_ADDR_VAR 0 5
63421: PUSH
63422: LD_INT 6
63424: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63425: LD_ADDR_EXP 121
63429: PUSH
63430: LD_EXP 121
63434: PPUSH
63435: LD_VAR 0 3
63439: PUSH
63440: LD_EXP 121
63444: PUSH
63445: LD_VAR 0 3
63449: ARRAY
63450: PUSH
63451: LD_INT 1
63453: PLUS
63454: PUSH
63455: EMPTY
63456: LIST
63457: LIST
63458: PPUSH
63459: LD_VAR 0 5
63463: PUSH
63464: LD_VAR 0 1
63468: PPUSH
63469: CALL_OW 250
63473: PUSH
63474: LD_VAR 0 1
63478: PPUSH
63479: CALL_OW 251
63483: PUSH
63484: LD_VAR 0 1
63488: PPUSH
63489: CALL_OW 254
63493: PUSH
63494: EMPTY
63495: LIST
63496: LIST
63497: LIST
63498: LIST
63499: PPUSH
63500: CALL 70539 0 3
63504: ST_TO_ADDR
// if pos = 1 then
63505: LD_VAR 0 6
63509: PUSH
63510: LD_INT 1
63512: EQUAL
63513: IFFALSE 63628
// begin tmp := mc_build_list [ i ] ;
63515: LD_ADDR_VAR 0 7
63519: PUSH
63520: LD_EXP 121
63524: PUSH
63525: LD_VAR 0 3
63529: ARRAY
63530: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63531: LD_VAR 0 7
63535: PPUSH
63536: LD_INT 2
63538: PUSH
63539: LD_INT 30
63541: PUSH
63542: LD_INT 0
63544: PUSH
63545: EMPTY
63546: LIST
63547: LIST
63548: PUSH
63549: LD_INT 30
63551: PUSH
63552: LD_INT 1
63554: PUSH
63555: EMPTY
63556: LIST
63557: LIST
63558: PUSH
63559: EMPTY
63560: LIST
63561: LIST
63562: LIST
63563: PPUSH
63564: CALL_OW 72
63568: IFFALSE 63578
// pos := 2 ;
63570: LD_ADDR_VAR 0 6
63574: PUSH
63575: LD_INT 2
63577: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63578: LD_ADDR_VAR 0 7
63582: PUSH
63583: LD_VAR 0 7
63587: PPUSH
63588: LD_VAR 0 6
63592: PPUSH
63593: LD_VAR 0 7
63597: PPUSH
63598: CALL 70865 0 3
63602: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63603: LD_ADDR_EXP 121
63607: PUSH
63608: LD_EXP 121
63612: PPUSH
63613: LD_VAR 0 3
63617: PPUSH
63618: LD_VAR 0 7
63622: PPUSH
63623: CALL_OW 1
63627: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63628: LD_VAR 0 1
63632: PUSH
63633: LD_EXP 116
63637: PUSH
63638: LD_VAR 0 3
63642: ARRAY
63643: IN
63644: IFFALSE 63683
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63646: LD_ADDR_EXP 116
63650: PUSH
63651: LD_EXP 116
63655: PPUSH
63656: LD_VAR 0 3
63660: PPUSH
63661: LD_EXP 116
63665: PUSH
63666: LD_VAR 0 3
63670: ARRAY
63671: PUSH
63672: LD_VAR 0 1
63676: DIFF
63677: PPUSH
63678: CALL_OW 1
63682: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63683: LD_VAR 0 1
63687: PUSH
63688: LD_EXP 123
63692: PUSH
63693: LD_VAR 0 3
63697: ARRAY
63698: IN
63699: IFFALSE 63738
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63701: LD_ADDR_EXP 123
63705: PUSH
63706: LD_EXP 123
63710: PPUSH
63711: LD_VAR 0 3
63715: PPUSH
63716: LD_EXP 123
63720: PUSH
63721: LD_VAR 0 3
63725: ARRAY
63726: PUSH
63727: LD_VAR 0 1
63731: DIFF
63732: PPUSH
63733: CALL_OW 1
63737: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63738: LD_VAR 0 1
63742: PUSH
63743: LD_EXP 135
63747: PUSH
63748: LD_VAR 0 3
63752: ARRAY
63753: IN
63754: IFFALSE 63793
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63756: LD_ADDR_EXP 135
63760: PUSH
63761: LD_EXP 135
63765: PPUSH
63766: LD_VAR 0 3
63770: PPUSH
63771: LD_EXP 135
63775: PUSH
63776: LD_VAR 0 3
63780: ARRAY
63781: PUSH
63782: LD_VAR 0 1
63786: DIFF
63787: PPUSH
63788: CALL_OW 1
63792: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63793: LD_VAR 0 1
63797: PUSH
63798: LD_EXP 138
63802: PUSH
63803: LD_VAR 0 3
63807: ARRAY
63808: IN
63809: IFFALSE 63848
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63811: LD_ADDR_EXP 138
63815: PUSH
63816: LD_EXP 138
63820: PPUSH
63821: LD_VAR 0 3
63825: PPUSH
63826: LD_EXP 138
63830: PUSH
63831: LD_VAR 0 3
63835: ARRAY
63836: PUSH
63837: LD_VAR 0 1
63841: DIFF
63842: PPUSH
63843: CALL_OW 1
63847: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63848: LD_VAR 0 1
63852: PUSH
63853: LD_EXP 125
63857: PUSH
63858: LD_VAR 0 3
63862: ARRAY
63863: IN
63864: IFFALSE 63903
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63866: LD_ADDR_EXP 125
63870: PUSH
63871: LD_EXP 125
63875: PPUSH
63876: LD_VAR 0 3
63880: PPUSH
63881: LD_EXP 125
63885: PUSH
63886: LD_VAR 0 3
63890: ARRAY
63891: PUSH
63892: LD_VAR 0 1
63896: DIFF
63897: PPUSH
63898: CALL_OW 1
63902: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63903: LD_VAR 0 1
63907: PUSH
63908: LD_EXP 124
63912: PUSH
63913: LD_VAR 0 3
63917: ARRAY
63918: IN
63919: IFFALSE 63958
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63921: LD_ADDR_EXP 124
63925: PUSH
63926: LD_EXP 124
63930: PPUSH
63931: LD_VAR 0 3
63935: PPUSH
63936: LD_EXP 124
63940: PUSH
63941: LD_VAR 0 3
63945: ARRAY
63946: PUSH
63947: LD_VAR 0 1
63951: DIFF
63952: PPUSH
63953: CALL_OW 1
63957: ST_TO_ADDR
// end ; break ;
63958: GO 63962
// end ;
63960: GO 62608
63962: POP
63963: POP
// end ;
63964: LD_VAR 0 2
63968: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63969: LD_INT 0
63971: PPUSH
63972: PPUSH
63973: PPUSH
// if not mc_bases or not skirmish then
63974: LD_EXP 116
63978: NOT
63979: PUSH
63980: LD_EXP 114
63984: NOT
63985: OR
63986: IFFALSE 63990
// exit ;
63988: GO 64205
// for i = 1 to mc_bases do
63990: LD_ADDR_VAR 0 3
63994: PUSH
63995: DOUBLE
63996: LD_INT 1
63998: DEC
63999: ST_TO_ADDR
64000: LD_EXP 116
64004: PUSH
64005: FOR_TO
64006: IFFALSE 64203
// begin if building in mc_construct_list [ i ] then
64008: LD_VAR 0 1
64012: PUSH
64013: LD_EXP 123
64017: PUSH
64018: LD_VAR 0 3
64022: ARRAY
64023: IN
64024: IFFALSE 64201
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64026: LD_ADDR_EXP 123
64030: PUSH
64031: LD_EXP 123
64035: PPUSH
64036: LD_VAR 0 3
64040: PPUSH
64041: LD_EXP 123
64045: PUSH
64046: LD_VAR 0 3
64050: ARRAY
64051: PUSH
64052: LD_VAR 0 1
64056: DIFF
64057: PPUSH
64058: CALL_OW 1
64062: ST_TO_ADDR
// if building in mc_lab [ i ] then
64063: LD_VAR 0 1
64067: PUSH
64068: LD_EXP 149
64072: PUSH
64073: LD_VAR 0 3
64077: ARRAY
64078: IN
64079: IFFALSE 64134
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64081: LD_ADDR_EXP 150
64085: PUSH
64086: LD_EXP 150
64090: PPUSH
64091: LD_VAR 0 3
64095: PPUSH
64096: LD_EXP 150
64100: PUSH
64101: LD_VAR 0 3
64105: ARRAY
64106: PPUSH
64107: LD_INT 1
64109: PPUSH
64110: LD_EXP 150
64114: PUSH
64115: LD_VAR 0 3
64119: ARRAY
64120: PPUSH
64121: LD_INT 0
64123: PPUSH
64124: CALL 69957 0 4
64128: PPUSH
64129: CALL_OW 1
64133: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64134: LD_VAR 0 1
64138: PUSH
64139: LD_EXP 116
64143: PUSH
64144: LD_VAR 0 3
64148: ARRAY
64149: IN
64150: NOT
64151: IFFALSE 64197
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64153: LD_ADDR_EXP 116
64157: PUSH
64158: LD_EXP 116
64162: PPUSH
64163: LD_VAR 0 3
64167: PUSH
64168: LD_EXP 116
64172: PUSH
64173: LD_VAR 0 3
64177: ARRAY
64178: PUSH
64179: LD_INT 1
64181: PLUS
64182: PUSH
64183: EMPTY
64184: LIST
64185: LIST
64186: PPUSH
64187: LD_VAR 0 1
64191: PPUSH
64192: CALL 70539 0 3
64196: ST_TO_ADDR
// exit ;
64197: POP
64198: POP
64199: GO 64205
// end ; end ;
64201: GO 64005
64203: POP
64204: POP
// end ;
64205: LD_VAR 0 2
64209: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64210: LD_INT 0
64212: PPUSH
64213: PPUSH
64214: PPUSH
64215: PPUSH
64216: PPUSH
64217: PPUSH
64218: PPUSH
// if not mc_bases or not skirmish then
64219: LD_EXP 116
64223: NOT
64224: PUSH
64225: LD_EXP 114
64229: NOT
64230: OR
64231: IFFALSE 64235
// exit ;
64233: GO 64896
// for i = 1 to mc_bases do
64235: LD_ADDR_VAR 0 3
64239: PUSH
64240: DOUBLE
64241: LD_INT 1
64243: DEC
64244: ST_TO_ADDR
64245: LD_EXP 116
64249: PUSH
64250: FOR_TO
64251: IFFALSE 64894
// begin if building in mc_construct_list [ i ] then
64253: LD_VAR 0 1
64257: PUSH
64258: LD_EXP 123
64262: PUSH
64263: LD_VAR 0 3
64267: ARRAY
64268: IN
64269: IFFALSE 64892
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64271: LD_ADDR_EXP 123
64275: PUSH
64276: LD_EXP 123
64280: PPUSH
64281: LD_VAR 0 3
64285: PPUSH
64286: LD_EXP 123
64290: PUSH
64291: LD_VAR 0 3
64295: ARRAY
64296: PUSH
64297: LD_VAR 0 1
64301: DIFF
64302: PPUSH
64303: CALL_OW 1
64307: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64308: LD_ADDR_EXP 116
64312: PUSH
64313: LD_EXP 116
64317: PPUSH
64318: LD_VAR 0 3
64322: PUSH
64323: LD_EXP 116
64327: PUSH
64328: LD_VAR 0 3
64332: ARRAY
64333: PUSH
64334: LD_INT 1
64336: PLUS
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PPUSH
64342: LD_VAR 0 1
64346: PPUSH
64347: CALL 70539 0 3
64351: ST_TO_ADDR
// btype := GetBType ( building ) ;
64352: LD_ADDR_VAR 0 5
64356: PUSH
64357: LD_VAR 0 1
64361: PPUSH
64362: CALL_OW 266
64366: ST_TO_ADDR
// side := GetSide ( building ) ;
64367: LD_ADDR_VAR 0 8
64371: PUSH
64372: LD_VAR 0 1
64376: PPUSH
64377: CALL_OW 255
64381: ST_TO_ADDR
// if btype = b_lab then
64382: LD_VAR 0 5
64386: PUSH
64387: LD_INT 6
64389: EQUAL
64390: IFFALSE 64440
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64392: LD_ADDR_EXP 149
64396: PUSH
64397: LD_EXP 149
64401: PPUSH
64402: LD_VAR 0 3
64406: PUSH
64407: LD_EXP 149
64411: PUSH
64412: LD_VAR 0 3
64416: ARRAY
64417: PUSH
64418: LD_INT 1
64420: PLUS
64421: PUSH
64422: EMPTY
64423: LIST
64424: LIST
64425: PPUSH
64426: LD_VAR 0 1
64430: PPUSH
64431: CALL 70539 0 3
64435: ST_TO_ADDR
// exit ;
64436: POP
64437: POP
64438: GO 64896
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64440: LD_VAR 0 5
64444: PUSH
64445: LD_INT 0
64447: PUSH
64448: LD_INT 2
64450: PUSH
64451: LD_INT 4
64453: PUSH
64454: EMPTY
64455: LIST
64456: LIST
64457: LIST
64458: IN
64459: IFFALSE 64583
// begin if btype = b_armoury then
64461: LD_VAR 0 5
64465: PUSH
64466: LD_INT 4
64468: EQUAL
64469: IFFALSE 64479
// btype := b_barracks ;
64471: LD_ADDR_VAR 0 5
64475: PUSH
64476: LD_INT 5
64478: ST_TO_ADDR
// if btype = b_depot then
64479: LD_VAR 0 5
64483: PUSH
64484: LD_INT 0
64486: EQUAL
64487: IFFALSE 64497
// btype := b_warehouse ;
64489: LD_ADDR_VAR 0 5
64493: PUSH
64494: LD_INT 1
64496: ST_TO_ADDR
// if btype = b_workshop then
64497: LD_VAR 0 5
64501: PUSH
64502: LD_INT 2
64504: EQUAL
64505: IFFALSE 64515
// btype := b_factory ;
64507: LD_ADDR_VAR 0 5
64511: PUSH
64512: LD_INT 3
64514: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64515: LD_VAR 0 5
64519: PPUSH
64520: LD_VAR 0 8
64524: PPUSH
64525: CALL_OW 323
64529: PUSH
64530: LD_INT 1
64532: EQUAL
64533: IFFALSE 64579
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64535: LD_ADDR_EXP 148
64539: PUSH
64540: LD_EXP 148
64544: PPUSH
64545: LD_VAR 0 3
64549: PUSH
64550: LD_EXP 148
64554: PUSH
64555: LD_VAR 0 3
64559: ARRAY
64560: PUSH
64561: LD_INT 1
64563: PLUS
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: PPUSH
64569: LD_VAR 0 1
64573: PPUSH
64574: CALL 70539 0 3
64578: ST_TO_ADDR
// exit ;
64579: POP
64580: POP
64581: GO 64896
// end ; if btype in [ b_bunker , b_turret ] then
64583: LD_VAR 0 5
64587: PUSH
64588: LD_INT 32
64590: PUSH
64591: LD_INT 33
64593: PUSH
64594: EMPTY
64595: LIST
64596: LIST
64597: IN
64598: IFFALSE 64888
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64600: LD_ADDR_EXP 124
64604: PUSH
64605: LD_EXP 124
64609: PPUSH
64610: LD_VAR 0 3
64614: PUSH
64615: LD_EXP 124
64619: PUSH
64620: LD_VAR 0 3
64624: ARRAY
64625: PUSH
64626: LD_INT 1
64628: PLUS
64629: PUSH
64630: EMPTY
64631: LIST
64632: LIST
64633: PPUSH
64634: LD_VAR 0 1
64638: PPUSH
64639: CALL 70539 0 3
64643: ST_TO_ADDR
// if btype = b_bunker then
64644: LD_VAR 0 5
64648: PUSH
64649: LD_INT 32
64651: EQUAL
64652: IFFALSE 64888
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64654: LD_ADDR_EXP 125
64658: PUSH
64659: LD_EXP 125
64663: PPUSH
64664: LD_VAR 0 3
64668: PUSH
64669: LD_EXP 125
64673: PUSH
64674: LD_VAR 0 3
64678: ARRAY
64679: PUSH
64680: LD_INT 1
64682: PLUS
64683: PUSH
64684: EMPTY
64685: LIST
64686: LIST
64687: PPUSH
64688: LD_VAR 0 1
64692: PPUSH
64693: CALL 70539 0 3
64697: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64698: LD_ADDR_VAR 0 6
64702: PUSH
64703: LD_EXP 116
64707: PUSH
64708: LD_VAR 0 3
64712: ARRAY
64713: PPUSH
64714: LD_INT 25
64716: PUSH
64717: LD_INT 1
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PUSH
64724: LD_INT 3
64726: PUSH
64727: LD_INT 54
64729: PUSH
64730: EMPTY
64731: LIST
64732: PUSH
64733: EMPTY
64734: LIST
64735: LIST
64736: PUSH
64737: EMPTY
64738: LIST
64739: LIST
64740: PPUSH
64741: CALL_OW 72
64745: ST_TO_ADDR
// if tmp then
64746: LD_VAR 0 6
64750: IFFALSE 64756
// exit ;
64752: POP
64753: POP
64754: GO 64896
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64756: LD_ADDR_VAR 0 6
64760: PUSH
64761: LD_EXP 116
64765: PUSH
64766: LD_VAR 0 3
64770: ARRAY
64771: PPUSH
64772: LD_INT 2
64774: PUSH
64775: LD_INT 30
64777: PUSH
64778: LD_INT 4
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 30
64787: PUSH
64788: LD_INT 5
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PUSH
64795: EMPTY
64796: LIST
64797: LIST
64798: LIST
64799: PPUSH
64800: CALL_OW 72
64804: ST_TO_ADDR
// if not tmp then
64805: LD_VAR 0 6
64809: NOT
64810: IFFALSE 64816
// exit ;
64812: POP
64813: POP
64814: GO 64896
// for j in tmp do
64816: LD_ADDR_VAR 0 4
64820: PUSH
64821: LD_VAR 0 6
64825: PUSH
64826: FOR_IN
64827: IFFALSE 64886
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64829: LD_ADDR_VAR 0 7
64833: PUSH
64834: LD_VAR 0 4
64838: PPUSH
64839: CALL_OW 313
64843: PPUSH
64844: LD_INT 25
64846: PUSH
64847: LD_INT 1
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: PPUSH
64854: CALL_OW 72
64858: ST_TO_ADDR
// if units then
64859: LD_VAR 0 7
64863: IFFALSE 64884
// begin ComExitBuilding ( units [ 1 ] ) ;
64865: LD_VAR 0 7
64869: PUSH
64870: LD_INT 1
64872: ARRAY
64873: PPUSH
64874: CALL_OW 122
// exit ;
64878: POP
64879: POP
64880: POP
64881: POP
64882: GO 64896
// end ; end ;
64884: GO 64826
64886: POP
64887: POP
// end ; end ; exit ;
64888: POP
64889: POP
64890: GO 64896
// end ; end ;
64892: GO 64250
64894: POP
64895: POP
// end ;
64896: LD_VAR 0 2
64900: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64901: LD_INT 0
64903: PPUSH
64904: PPUSH
64905: PPUSH
64906: PPUSH
64907: PPUSH
64908: PPUSH
64909: PPUSH
// if not mc_bases or not skirmish then
64910: LD_EXP 116
64914: NOT
64915: PUSH
64916: LD_EXP 114
64920: NOT
64921: OR
64922: IFFALSE 64926
// exit ;
64924: GO 65191
// btype := GetBType ( building ) ;
64926: LD_ADDR_VAR 0 6
64930: PUSH
64931: LD_VAR 0 1
64935: PPUSH
64936: CALL_OW 266
64940: ST_TO_ADDR
// x := GetX ( building ) ;
64941: LD_ADDR_VAR 0 7
64945: PUSH
64946: LD_VAR 0 1
64950: PPUSH
64951: CALL_OW 250
64955: ST_TO_ADDR
// y := GetY ( building ) ;
64956: LD_ADDR_VAR 0 8
64960: PUSH
64961: LD_VAR 0 1
64965: PPUSH
64966: CALL_OW 251
64970: ST_TO_ADDR
// d := GetDir ( building ) ;
64971: LD_ADDR_VAR 0 9
64975: PUSH
64976: LD_VAR 0 1
64980: PPUSH
64981: CALL_OW 254
64985: ST_TO_ADDR
// for i = 1 to mc_bases do
64986: LD_ADDR_VAR 0 4
64990: PUSH
64991: DOUBLE
64992: LD_INT 1
64994: DEC
64995: ST_TO_ADDR
64996: LD_EXP 116
65000: PUSH
65001: FOR_TO
65002: IFFALSE 65189
// begin if not mc_build_list [ i ] then
65004: LD_EXP 121
65008: PUSH
65009: LD_VAR 0 4
65013: ARRAY
65014: NOT
65015: IFFALSE 65019
// continue ;
65017: GO 65001
// for j := 1 to mc_build_list [ i ] do
65019: LD_ADDR_VAR 0 5
65023: PUSH
65024: DOUBLE
65025: LD_INT 1
65027: DEC
65028: ST_TO_ADDR
65029: LD_EXP 121
65033: PUSH
65034: LD_VAR 0 4
65038: ARRAY
65039: PUSH
65040: FOR_TO
65041: IFFALSE 65185
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65043: LD_VAR 0 6
65047: PUSH
65048: LD_VAR 0 7
65052: PUSH
65053: LD_VAR 0 8
65057: PUSH
65058: LD_VAR 0 9
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: LIST
65067: LIST
65068: PPUSH
65069: LD_EXP 121
65073: PUSH
65074: LD_VAR 0 4
65078: ARRAY
65079: PUSH
65080: LD_VAR 0 5
65084: ARRAY
65085: PPUSH
65086: CALL 76722 0 2
65090: IFFALSE 65183
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65092: LD_ADDR_EXP 121
65096: PUSH
65097: LD_EXP 121
65101: PPUSH
65102: LD_VAR 0 4
65106: PPUSH
65107: LD_EXP 121
65111: PUSH
65112: LD_VAR 0 4
65116: ARRAY
65117: PPUSH
65118: LD_VAR 0 5
65122: PPUSH
65123: CALL_OW 3
65127: PPUSH
65128: CALL_OW 1
65132: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65133: LD_ADDR_EXP 123
65137: PUSH
65138: LD_EXP 123
65142: PPUSH
65143: LD_VAR 0 4
65147: PUSH
65148: LD_EXP 123
65152: PUSH
65153: LD_VAR 0 4
65157: ARRAY
65158: PUSH
65159: LD_INT 1
65161: PLUS
65162: PUSH
65163: EMPTY
65164: LIST
65165: LIST
65166: PPUSH
65167: LD_VAR 0 1
65171: PPUSH
65172: CALL 70539 0 3
65176: ST_TO_ADDR
// exit ;
65177: POP
65178: POP
65179: POP
65180: POP
65181: GO 65191
// end ;
65183: GO 65040
65185: POP
65186: POP
// end ;
65187: GO 65001
65189: POP
65190: POP
// end ;
65191: LD_VAR 0 3
65195: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65196: LD_INT 0
65198: PPUSH
65199: PPUSH
65200: PPUSH
// if not mc_bases or not skirmish then
65201: LD_EXP 116
65205: NOT
65206: PUSH
65207: LD_EXP 114
65211: NOT
65212: OR
65213: IFFALSE 65217
// exit ;
65215: GO 65407
// for i = 1 to mc_bases do
65217: LD_ADDR_VAR 0 4
65221: PUSH
65222: DOUBLE
65223: LD_INT 1
65225: DEC
65226: ST_TO_ADDR
65227: LD_EXP 116
65231: PUSH
65232: FOR_TO
65233: IFFALSE 65320
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65235: LD_VAR 0 1
65239: PUSH
65240: LD_EXP 124
65244: PUSH
65245: LD_VAR 0 4
65249: ARRAY
65250: IN
65251: PUSH
65252: LD_VAR 0 1
65256: PUSH
65257: LD_EXP 125
65261: PUSH
65262: LD_VAR 0 4
65266: ARRAY
65267: IN
65268: NOT
65269: AND
65270: IFFALSE 65318
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65272: LD_ADDR_EXP 125
65276: PUSH
65277: LD_EXP 125
65281: PPUSH
65282: LD_VAR 0 4
65286: PUSH
65287: LD_EXP 125
65291: PUSH
65292: LD_VAR 0 4
65296: ARRAY
65297: PUSH
65298: LD_INT 1
65300: PLUS
65301: PUSH
65302: EMPTY
65303: LIST
65304: LIST
65305: PPUSH
65306: LD_VAR 0 1
65310: PPUSH
65311: CALL 70539 0 3
65315: ST_TO_ADDR
// break ;
65316: GO 65320
// end ; end ;
65318: GO 65232
65320: POP
65321: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65322: LD_VAR 0 1
65326: PPUSH
65327: CALL_OW 257
65331: PUSH
65332: LD_EXP 142
65336: IN
65337: PUSH
65338: LD_VAR 0 1
65342: PPUSH
65343: CALL_OW 266
65347: PUSH
65348: LD_INT 5
65350: EQUAL
65351: AND
65352: PUSH
65353: LD_VAR 0 2
65357: PPUSH
65358: CALL_OW 110
65362: PUSH
65363: LD_INT 18
65365: NONEQUAL
65366: AND
65367: IFFALSE 65407
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65369: LD_VAR 0 2
65373: PPUSH
65374: CALL_OW 257
65378: PUSH
65379: LD_INT 5
65381: PUSH
65382: LD_INT 8
65384: PUSH
65385: LD_INT 9
65387: PUSH
65388: EMPTY
65389: LIST
65390: LIST
65391: LIST
65392: IN
65393: IFFALSE 65407
// SetClass ( unit , 1 ) ;
65395: LD_VAR 0 2
65399: PPUSH
65400: LD_INT 1
65402: PPUSH
65403: CALL_OW 336
// end ;
65407: LD_VAR 0 3
65411: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65412: LD_INT 0
65414: PPUSH
65415: PPUSH
// if not mc_bases or not skirmish then
65416: LD_EXP 116
65420: NOT
65421: PUSH
65422: LD_EXP 114
65426: NOT
65427: OR
65428: IFFALSE 65432
// exit ;
65430: GO 65548
// if GetLives ( abandoned_vehicle ) > 250 then
65432: LD_VAR 0 2
65436: PPUSH
65437: CALL_OW 256
65441: PUSH
65442: LD_INT 250
65444: GREATER
65445: IFFALSE 65449
// exit ;
65447: GO 65548
// for i = 1 to mc_bases do
65449: LD_ADDR_VAR 0 6
65453: PUSH
65454: DOUBLE
65455: LD_INT 1
65457: DEC
65458: ST_TO_ADDR
65459: LD_EXP 116
65463: PUSH
65464: FOR_TO
65465: IFFALSE 65546
// begin if driver in mc_bases [ i ] then
65467: LD_VAR 0 1
65471: PUSH
65472: LD_EXP 116
65476: PUSH
65477: LD_VAR 0 6
65481: ARRAY
65482: IN
65483: IFFALSE 65544
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65485: LD_VAR 0 1
65489: PPUSH
65490: LD_EXP 116
65494: PUSH
65495: LD_VAR 0 6
65499: ARRAY
65500: PPUSH
65501: LD_INT 2
65503: PUSH
65504: LD_INT 30
65506: PUSH
65507: LD_INT 0
65509: PUSH
65510: EMPTY
65511: LIST
65512: LIST
65513: PUSH
65514: LD_INT 30
65516: PUSH
65517: LD_INT 1
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: LIST
65528: PPUSH
65529: CALL_OW 72
65533: PUSH
65534: LD_INT 1
65536: ARRAY
65537: PPUSH
65538: CALL 103158 0 2
// break ;
65542: GO 65546
// end ; end ;
65544: GO 65464
65546: POP
65547: POP
// end ; end_of_file
65548: LD_VAR 0 5
65552: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65553: LD_INT 0
65555: PPUSH
65556: PPUSH
// if exist_mode then
65557: LD_VAR 0 2
65561: IFFALSE 65586
// unit := CreateCharacter ( prefix & ident ) else
65563: LD_ADDR_VAR 0 5
65567: PUSH
65568: LD_VAR 0 3
65572: PUSH
65573: LD_VAR 0 1
65577: STR
65578: PPUSH
65579: CALL_OW 34
65583: ST_TO_ADDR
65584: GO 65601
// unit := NewCharacter ( ident ) ;
65586: LD_ADDR_VAR 0 5
65590: PUSH
65591: LD_VAR 0 1
65595: PPUSH
65596: CALL_OW 25
65600: ST_TO_ADDR
// result := unit ;
65601: LD_ADDR_VAR 0 4
65605: PUSH
65606: LD_VAR 0 5
65610: ST_TO_ADDR
// end ;
65611: LD_VAR 0 4
65615: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65616: LD_INT 0
65618: PPUSH
65619: PPUSH
// if not side or not nation then
65620: LD_VAR 0 1
65624: NOT
65625: PUSH
65626: LD_VAR 0 2
65630: NOT
65631: OR
65632: IFFALSE 65636
// exit ;
65634: GO 66404
// case nation of nation_american :
65636: LD_VAR 0 2
65640: PUSH
65641: LD_INT 1
65643: DOUBLE
65644: EQUAL
65645: IFTRUE 65649
65647: GO 65863
65649: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65650: LD_ADDR_VAR 0 4
65654: PUSH
65655: LD_INT 35
65657: PUSH
65658: LD_INT 45
65660: PUSH
65661: LD_INT 46
65663: PUSH
65664: LD_INT 47
65666: PUSH
65667: LD_INT 82
65669: PUSH
65670: LD_INT 83
65672: PUSH
65673: LD_INT 84
65675: PUSH
65676: LD_INT 85
65678: PUSH
65679: LD_INT 86
65681: PUSH
65682: LD_INT 1
65684: PUSH
65685: LD_INT 2
65687: PUSH
65688: LD_INT 6
65690: PUSH
65691: LD_INT 15
65693: PUSH
65694: LD_INT 16
65696: PUSH
65697: LD_INT 7
65699: PUSH
65700: LD_INT 12
65702: PUSH
65703: LD_INT 13
65705: PUSH
65706: LD_INT 10
65708: PUSH
65709: LD_INT 14
65711: PUSH
65712: LD_INT 20
65714: PUSH
65715: LD_INT 21
65717: PUSH
65718: LD_INT 22
65720: PUSH
65721: LD_INT 25
65723: PUSH
65724: LD_INT 32
65726: PUSH
65727: LD_INT 27
65729: PUSH
65730: LD_INT 36
65732: PUSH
65733: LD_INT 69
65735: PUSH
65736: LD_INT 39
65738: PUSH
65739: LD_INT 34
65741: PUSH
65742: LD_INT 40
65744: PUSH
65745: LD_INT 48
65747: PUSH
65748: LD_INT 49
65750: PUSH
65751: LD_INT 50
65753: PUSH
65754: LD_INT 51
65756: PUSH
65757: LD_INT 52
65759: PUSH
65760: LD_INT 53
65762: PUSH
65763: LD_INT 54
65765: PUSH
65766: LD_INT 55
65768: PUSH
65769: LD_INT 56
65771: PUSH
65772: LD_INT 57
65774: PUSH
65775: LD_INT 58
65777: PUSH
65778: LD_INT 59
65780: PUSH
65781: LD_INT 60
65783: PUSH
65784: LD_INT 61
65786: PUSH
65787: LD_INT 62
65789: PUSH
65790: LD_INT 80
65792: PUSH
65793: LD_INT 82
65795: PUSH
65796: LD_INT 83
65798: PUSH
65799: LD_INT 84
65801: PUSH
65802: LD_INT 85
65804: PUSH
65805: LD_INT 86
65807: PUSH
65808: EMPTY
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: ST_TO_ADDR
65861: GO 66328
65863: LD_INT 2
65865: DOUBLE
65866: EQUAL
65867: IFTRUE 65871
65869: GO 66097
65871: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
65872: LD_ADDR_VAR 0 4
65876: PUSH
65877: LD_INT 35
65879: PUSH
65880: LD_INT 45
65882: PUSH
65883: LD_INT 46
65885: PUSH
65886: LD_INT 47
65888: PUSH
65889: LD_INT 82
65891: PUSH
65892: LD_INT 83
65894: PUSH
65895: LD_INT 84
65897: PUSH
65898: LD_INT 85
65900: PUSH
65901: LD_INT 87
65903: PUSH
65904: LD_INT 70
65906: PUSH
65907: LD_INT 1
65909: PUSH
65910: LD_INT 11
65912: PUSH
65913: LD_INT 3
65915: PUSH
65916: LD_INT 4
65918: PUSH
65919: LD_INT 5
65921: PUSH
65922: LD_INT 6
65924: PUSH
65925: LD_INT 15
65927: PUSH
65928: LD_INT 18
65930: PUSH
65931: LD_INT 7
65933: PUSH
65934: LD_INT 17
65936: PUSH
65937: LD_INT 8
65939: PUSH
65940: LD_INT 20
65942: PUSH
65943: LD_INT 21
65945: PUSH
65946: LD_INT 22
65948: PUSH
65949: LD_INT 72
65951: PUSH
65952: LD_INT 26
65954: PUSH
65955: LD_INT 69
65957: PUSH
65958: LD_INT 39
65960: PUSH
65961: LD_INT 40
65963: PUSH
65964: LD_INT 41
65966: PUSH
65967: LD_INT 42
65969: PUSH
65970: LD_INT 43
65972: PUSH
65973: LD_INT 48
65975: PUSH
65976: LD_INT 49
65978: PUSH
65979: LD_INT 50
65981: PUSH
65982: LD_INT 51
65984: PUSH
65985: LD_INT 52
65987: PUSH
65988: LD_INT 53
65990: PUSH
65991: LD_INT 54
65993: PUSH
65994: LD_INT 55
65996: PUSH
65997: LD_INT 56
65999: PUSH
66000: LD_INT 60
66002: PUSH
66003: LD_INT 61
66005: PUSH
66006: LD_INT 62
66008: PUSH
66009: LD_INT 66
66011: PUSH
66012: LD_INT 67
66014: PUSH
66015: LD_INT 68
66017: PUSH
66018: LD_INT 81
66020: PUSH
66021: LD_INT 82
66023: PUSH
66024: LD_INT 83
66026: PUSH
66027: LD_INT 84
66029: PUSH
66030: LD_INT 85
66032: PUSH
66033: LD_INT 87
66035: PUSH
66036: LD_INT 88
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: LIST
66080: LIST
66081: LIST
66082: LIST
66083: LIST
66084: LIST
66085: LIST
66086: LIST
66087: LIST
66088: LIST
66089: LIST
66090: LIST
66091: LIST
66092: LIST
66093: LIST
66094: ST_TO_ADDR
66095: GO 66328
66097: LD_INT 3
66099: DOUBLE
66100: EQUAL
66101: IFTRUE 66105
66103: GO 66327
66105: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66106: LD_ADDR_VAR 0 4
66110: PUSH
66111: LD_INT 46
66113: PUSH
66114: LD_INT 47
66116: PUSH
66117: LD_INT 1
66119: PUSH
66120: LD_INT 2
66122: PUSH
66123: LD_INT 82
66125: PUSH
66126: LD_INT 83
66128: PUSH
66129: LD_INT 84
66131: PUSH
66132: LD_INT 85
66134: PUSH
66135: LD_INT 86
66137: PUSH
66138: LD_INT 11
66140: PUSH
66141: LD_INT 9
66143: PUSH
66144: LD_INT 20
66146: PUSH
66147: LD_INT 19
66149: PUSH
66150: LD_INT 21
66152: PUSH
66153: LD_INT 24
66155: PUSH
66156: LD_INT 22
66158: PUSH
66159: LD_INT 25
66161: PUSH
66162: LD_INT 28
66164: PUSH
66165: LD_INT 29
66167: PUSH
66168: LD_INT 30
66170: PUSH
66171: LD_INT 31
66173: PUSH
66174: LD_INT 37
66176: PUSH
66177: LD_INT 38
66179: PUSH
66180: LD_INT 32
66182: PUSH
66183: LD_INT 27
66185: PUSH
66186: LD_INT 33
66188: PUSH
66189: LD_INT 69
66191: PUSH
66192: LD_INT 39
66194: PUSH
66195: LD_INT 34
66197: PUSH
66198: LD_INT 40
66200: PUSH
66201: LD_INT 71
66203: PUSH
66204: LD_INT 23
66206: PUSH
66207: LD_INT 44
66209: PUSH
66210: LD_INT 48
66212: PUSH
66213: LD_INT 49
66215: PUSH
66216: LD_INT 50
66218: PUSH
66219: LD_INT 51
66221: PUSH
66222: LD_INT 52
66224: PUSH
66225: LD_INT 53
66227: PUSH
66228: LD_INT 54
66230: PUSH
66231: LD_INT 55
66233: PUSH
66234: LD_INT 56
66236: PUSH
66237: LD_INT 57
66239: PUSH
66240: LD_INT 58
66242: PUSH
66243: LD_INT 59
66245: PUSH
66246: LD_INT 63
66248: PUSH
66249: LD_INT 64
66251: PUSH
66252: LD_INT 65
66254: PUSH
66255: LD_INT 82
66257: PUSH
66258: LD_INT 83
66260: PUSH
66261: LD_INT 84
66263: PUSH
66264: LD_INT 85
66266: PUSH
66267: LD_INT 86
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: LIST
66274: LIST
66275: LIST
66276: LIST
66277: LIST
66278: LIST
66279: LIST
66280: LIST
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: LIST
66318: LIST
66319: LIST
66320: LIST
66321: LIST
66322: LIST
66323: LIST
66324: ST_TO_ADDR
66325: GO 66328
66327: POP
// if state > - 1 and state < 3 then
66328: LD_VAR 0 3
66332: PUSH
66333: LD_INT 1
66335: NEG
66336: GREATER
66337: PUSH
66338: LD_VAR 0 3
66342: PUSH
66343: LD_INT 3
66345: LESS
66346: AND
66347: IFFALSE 66404
// for i in result do
66349: LD_ADDR_VAR 0 5
66353: PUSH
66354: LD_VAR 0 4
66358: PUSH
66359: FOR_IN
66360: IFFALSE 66402
// if GetTech ( i , side ) <> state then
66362: LD_VAR 0 5
66366: PPUSH
66367: LD_VAR 0 1
66371: PPUSH
66372: CALL_OW 321
66376: PUSH
66377: LD_VAR 0 3
66381: NONEQUAL
66382: IFFALSE 66400
// result := result diff i ;
66384: LD_ADDR_VAR 0 4
66388: PUSH
66389: LD_VAR 0 4
66393: PUSH
66394: LD_VAR 0 5
66398: DIFF
66399: ST_TO_ADDR
66400: GO 66359
66402: POP
66403: POP
// end ;
66404: LD_VAR 0 4
66408: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66409: LD_INT 0
66411: PPUSH
66412: PPUSH
66413: PPUSH
// result := true ;
66414: LD_ADDR_VAR 0 3
66418: PUSH
66419: LD_INT 1
66421: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66422: LD_ADDR_VAR 0 5
66426: PUSH
66427: LD_VAR 0 2
66431: PPUSH
66432: CALL_OW 480
66436: ST_TO_ADDR
// if not tmp then
66437: LD_VAR 0 5
66441: NOT
66442: IFFALSE 66446
// exit ;
66444: GO 66495
// for i in tmp do
66446: LD_ADDR_VAR 0 4
66450: PUSH
66451: LD_VAR 0 5
66455: PUSH
66456: FOR_IN
66457: IFFALSE 66493
// if GetTech ( i , side ) <> state_researched then
66459: LD_VAR 0 4
66463: PPUSH
66464: LD_VAR 0 1
66468: PPUSH
66469: CALL_OW 321
66473: PUSH
66474: LD_INT 2
66476: NONEQUAL
66477: IFFALSE 66491
// begin result := false ;
66479: LD_ADDR_VAR 0 3
66483: PUSH
66484: LD_INT 0
66486: ST_TO_ADDR
// exit ;
66487: POP
66488: POP
66489: GO 66495
// end ;
66491: GO 66456
66493: POP
66494: POP
// end ;
66495: LD_VAR 0 3
66499: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66500: LD_INT 0
66502: PPUSH
66503: PPUSH
66504: PPUSH
66505: PPUSH
66506: PPUSH
66507: PPUSH
66508: PPUSH
66509: PPUSH
66510: PPUSH
66511: PPUSH
66512: PPUSH
66513: PPUSH
66514: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66515: LD_VAR 0 1
66519: NOT
66520: PUSH
66521: LD_VAR 0 1
66525: PPUSH
66526: CALL_OW 257
66530: PUSH
66531: LD_INT 9
66533: NONEQUAL
66534: OR
66535: IFFALSE 66539
// exit ;
66537: GO 67112
// side := GetSide ( unit ) ;
66539: LD_ADDR_VAR 0 9
66543: PUSH
66544: LD_VAR 0 1
66548: PPUSH
66549: CALL_OW 255
66553: ST_TO_ADDR
// tech_space := tech_spacanom ;
66554: LD_ADDR_VAR 0 12
66558: PUSH
66559: LD_INT 29
66561: ST_TO_ADDR
// tech_time := tech_taurad ;
66562: LD_ADDR_VAR 0 13
66566: PUSH
66567: LD_INT 28
66569: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66570: LD_ADDR_VAR 0 11
66574: PUSH
66575: LD_VAR 0 1
66579: PPUSH
66580: CALL_OW 310
66584: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66585: LD_VAR 0 11
66589: PPUSH
66590: CALL_OW 247
66594: PUSH
66595: LD_INT 2
66597: EQUAL
66598: IFFALSE 66602
// exit ;
66600: GO 67112
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66602: LD_ADDR_VAR 0 8
66606: PUSH
66607: LD_INT 81
66609: PUSH
66610: LD_VAR 0 9
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 3
66621: PUSH
66622: LD_INT 21
66624: PUSH
66625: LD_INT 3
66627: PUSH
66628: EMPTY
66629: LIST
66630: LIST
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: PPUSH
66640: CALL_OW 69
66644: ST_TO_ADDR
// if not tmp then
66645: LD_VAR 0 8
66649: NOT
66650: IFFALSE 66654
// exit ;
66652: GO 67112
// if in_unit then
66654: LD_VAR 0 11
66658: IFFALSE 66682
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66660: LD_ADDR_VAR 0 10
66664: PUSH
66665: LD_VAR 0 8
66669: PPUSH
66670: LD_VAR 0 11
66674: PPUSH
66675: CALL_OW 74
66679: ST_TO_ADDR
66680: GO 66702
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66682: LD_ADDR_VAR 0 10
66686: PUSH
66687: LD_VAR 0 8
66691: PPUSH
66692: LD_VAR 0 1
66696: PPUSH
66697: CALL_OW 74
66701: ST_TO_ADDR
// if not enemy then
66702: LD_VAR 0 10
66706: NOT
66707: IFFALSE 66711
// exit ;
66709: GO 67112
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66711: LD_VAR 0 11
66715: PUSH
66716: LD_VAR 0 11
66720: PPUSH
66721: LD_VAR 0 10
66725: PPUSH
66726: CALL_OW 296
66730: PUSH
66731: LD_INT 13
66733: GREATER
66734: AND
66735: PUSH
66736: LD_VAR 0 1
66740: PPUSH
66741: LD_VAR 0 10
66745: PPUSH
66746: CALL_OW 296
66750: PUSH
66751: LD_INT 12
66753: GREATER
66754: OR
66755: IFFALSE 66759
// exit ;
66757: GO 67112
// missile := [ 1 ] ;
66759: LD_ADDR_VAR 0 14
66763: PUSH
66764: LD_INT 1
66766: PUSH
66767: EMPTY
66768: LIST
66769: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66770: LD_VAR 0 9
66774: PPUSH
66775: LD_VAR 0 12
66779: PPUSH
66780: CALL_OW 325
66784: IFFALSE 66813
// missile := Insert ( missile , missile + 1 , 2 ) ;
66786: LD_ADDR_VAR 0 14
66790: PUSH
66791: LD_VAR 0 14
66795: PPUSH
66796: LD_VAR 0 14
66800: PUSH
66801: LD_INT 1
66803: PLUS
66804: PPUSH
66805: LD_INT 2
66807: PPUSH
66808: CALL_OW 2
66812: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66813: LD_VAR 0 9
66817: PPUSH
66818: LD_VAR 0 13
66822: PPUSH
66823: CALL_OW 325
66827: PUSH
66828: LD_VAR 0 10
66832: PPUSH
66833: CALL_OW 255
66837: PPUSH
66838: LD_VAR 0 13
66842: PPUSH
66843: CALL_OW 325
66847: NOT
66848: AND
66849: IFFALSE 66878
// missile := Insert ( missile , missile + 1 , 3 ) ;
66851: LD_ADDR_VAR 0 14
66855: PUSH
66856: LD_VAR 0 14
66860: PPUSH
66861: LD_VAR 0 14
66865: PUSH
66866: LD_INT 1
66868: PLUS
66869: PPUSH
66870: LD_INT 3
66872: PPUSH
66873: CALL_OW 2
66877: ST_TO_ADDR
// if missile < 2 then
66878: LD_VAR 0 14
66882: PUSH
66883: LD_INT 2
66885: LESS
66886: IFFALSE 66890
// exit ;
66888: GO 67112
// x := GetX ( enemy ) ;
66890: LD_ADDR_VAR 0 4
66894: PUSH
66895: LD_VAR 0 10
66899: PPUSH
66900: CALL_OW 250
66904: ST_TO_ADDR
// y := GetY ( enemy ) ;
66905: LD_ADDR_VAR 0 5
66909: PUSH
66910: LD_VAR 0 10
66914: PPUSH
66915: CALL_OW 251
66919: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66920: LD_ADDR_VAR 0 6
66924: PUSH
66925: LD_VAR 0 4
66929: PUSH
66930: LD_INT 1
66932: NEG
66933: PPUSH
66934: LD_INT 1
66936: PPUSH
66937: CALL_OW 12
66941: PLUS
66942: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66943: LD_ADDR_VAR 0 7
66947: PUSH
66948: LD_VAR 0 5
66952: PUSH
66953: LD_INT 1
66955: NEG
66956: PPUSH
66957: LD_INT 1
66959: PPUSH
66960: CALL_OW 12
66964: PLUS
66965: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66966: LD_VAR 0 6
66970: PPUSH
66971: LD_VAR 0 7
66975: PPUSH
66976: CALL_OW 488
66980: NOT
66981: IFFALSE 67003
// begin _x := x ;
66983: LD_ADDR_VAR 0 6
66987: PUSH
66988: LD_VAR 0 4
66992: ST_TO_ADDR
// _y := y ;
66993: LD_ADDR_VAR 0 7
66997: PUSH
66998: LD_VAR 0 5
67002: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67003: LD_ADDR_VAR 0 3
67007: PUSH
67008: LD_INT 1
67010: PPUSH
67011: LD_VAR 0 14
67015: PPUSH
67016: CALL_OW 12
67020: ST_TO_ADDR
// case i of 1 :
67021: LD_VAR 0 3
67025: PUSH
67026: LD_INT 1
67028: DOUBLE
67029: EQUAL
67030: IFTRUE 67034
67032: GO 67051
67034: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67035: LD_VAR 0 1
67039: PPUSH
67040: LD_VAR 0 10
67044: PPUSH
67045: CALL_OW 115
67049: GO 67112
67051: LD_INT 2
67053: DOUBLE
67054: EQUAL
67055: IFTRUE 67059
67057: GO 67081
67059: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67060: LD_VAR 0 1
67064: PPUSH
67065: LD_VAR 0 6
67069: PPUSH
67070: LD_VAR 0 7
67074: PPUSH
67075: CALL_OW 153
67079: GO 67112
67081: LD_INT 3
67083: DOUBLE
67084: EQUAL
67085: IFTRUE 67089
67087: GO 67111
67089: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67090: LD_VAR 0 1
67094: PPUSH
67095: LD_VAR 0 6
67099: PPUSH
67100: LD_VAR 0 7
67104: PPUSH
67105: CALL_OW 154
67109: GO 67112
67111: POP
// end ;
67112: LD_VAR 0 2
67116: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67117: LD_INT 0
67119: PPUSH
67120: PPUSH
67121: PPUSH
67122: PPUSH
67123: PPUSH
67124: PPUSH
// if not unit or not building then
67125: LD_VAR 0 1
67129: NOT
67130: PUSH
67131: LD_VAR 0 2
67135: NOT
67136: OR
67137: IFFALSE 67141
// exit ;
67139: GO 67299
// x := GetX ( building ) ;
67141: LD_ADDR_VAR 0 5
67145: PUSH
67146: LD_VAR 0 2
67150: PPUSH
67151: CALL_OW 250
67155: ST_TO_ADDR
// y := GetY ( building ) ;
67156: LD_ADDR_VAR 0 6
67160: PUSH
67161: LD_VAR 0 2
67165: PPUSH
67166: CALL_OW 251
67170: ST_TO_ADDR
// for i = 0 to 5 do
67171: LD_ADDR_VAR 0 4
67175: PUSH
67176: DOUBLE
67177: LD_INT 0
67179: DEC
67180: ST_TO_ADDR
67181: LD_INT 5
67183: PUSH
67184: FOR_TO
67185: IFFALSE 67297
// begin _x := ShiftX ( x , i , 3 ) ;
67187: LD_ADDR_VAR 0 7
67191: PUSH
67192: LD_VAR 0 5
67196: PPUSH
67197: LD_VAR 0 4
67201: PPUSH
67202: LD_INT 3
67204: PPUSH
67205: CALL_OW 272
67209: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67210: LD_ADDR_VAR 0 8
67214: PUSH
67215: LD_VAR 0 6
67219: PPUSH
67220: LD_VAR 0 4
67224: PPUSH
67225: LD_INT 3
67227: PPUSH
67228: CALL_OW 273
67232: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67233: LD_VAR 0 7
67237: PPUSH
67238: LD_VAR 0 8
67242: PPUSH
67243: CALL_OW 488
67247: NOT
67248: IFFALSE 67252
// continue ;
67250: GO 67184
// if HexInfo ( _x , _y ) = 0 then
67252: LD_VAR 0 7
67256: PPUSH
67257: LD_VAR 0 8
67261: PPUSH
67262: CALL_OW 428
67266: PUSH
67267: LD_INT 0
67269: EQUAL
67270: IFFALSE 67295
// begin ComMoveXY ( unit , _x , _y ) ;
67272: LD_VAR 0 1
67276: PPUSH
67277: LD_VAR 0 7
67281: PPUSH
67282: LD_VAR 0 8
67286: PPUSH
67287: CALL_OW 111
// exit ;
67291: POP
67292: POP
67293: GO 67299
// end ; end ;
67295: GO 67184
67297: POP
67298: POP
// end ;
67299: LD_VAR 0 3
67303: RET
// export function ScanBase ( side , base_area ) ; begin
67304: LD_INT 0
67306: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67307: LD_ADDR_VAR 0 3
67311: PUSH
67312: LD_VAR 0 2
67316: PPUSH
67317: LD_INT 81
67319: PUSH
67320: LD_VAR 0 1
67324: PUSH
67325: EMPTY
67326: LIST
67327: LIST
67328: PPUSH
67329: CALL_OW 70
67333: ST_TO_ADDR
// end ;
67334: LD_VAR 0 3
67338: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67339: LD_INT 0
67341: PPUSH
67342: PPUSH
67343: PPUSH
67344: PPUSH
// result := false ;
67345: LD_ADDR_VAR 0 2
67349: PUSH
67350: LD_INT 0
67352: ST_TO_ADDR
// side := GetSide ( unit ) ;
67353: LD_ADDR_VAR 0 3
67357: PUSH
67358: LD_VAR 0 1
67362: PPUSH
67363: CALL_OW 255
67367: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67368: LD_ADDR_VAR 0 4
67372: PUSH
67373: LD_VAR 0 1
67377: PPUSH
67378: CALL_OW 248
67382: ST_TO_ADDR
// case nat of 1 :
67383: LD_VAR 0 4
67387: PUSH
67388: LD_INT 1
67390: DOUBLE
67391: EQUAL
67392: IFTRUE 67396
67394: GO 67407
67396: POP
// tech := tech_lassight ; 2 :
67397: LD_ADDR_VAR 0 5
67401: PUSH
67402: LD_INT 12
67404: ST_TO_ADDR
67405: GO 67446
67407: LD_INT 2
67409: DOUBLE
67410: EQUAL
67411: IFTRUE 67415
67413: GO 67426
67415: POP
// tech := tech_mortar ; 3 :
67416: LD_ADDR_VAR 0 5
67420: PUSH
67421: LD_INT 41
67423: ST_TO_ADDR
67424: GO 67446
67426: LD_INT 3
67428: DOUBLE
67429: EQUAL
67430: IFTRUE 67434
67432: GO 67445
67434: POP
// tech := tech_bazooka ; end ;
67435: LD_ADDR_VAR 0 5
67439: PUSH
67440: LD_INT 44
67442: ST_TO_ADDR
67443: GO 67446
67445: POP
// if Researched ( side , tech ) then
67446: LD_VAR 0 3
67450: PPUSH
67451: LD_VAR 0 5
67455: PPUSH
67456: CALL_OW 325
67460: IFFALSE 67487
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67462: LD_ADDR_VAR 0 2
67466: PUSH
67467: LD_INT 5
67469: PUSH
67470: LD_INT 8
67472: PUSH
67473: LD_INT 9
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: LIST
67480: PUSH
67481: LD_VAR 0 4
67485: ARRAY
67486: ST_TO_ADDR
// end ;
67487: LD_VAR 0 2
67491: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67492: LD_INT 0
67494: PPUSH
67495: PPUSH
67496: PPUSH
// if not mines then
67497: LD_VAR 0 2
67501: NOT
67502: IFFALSE 67506
// exit ;
67504: GO 67650
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67506: LD_ADDR_VAR 0 5
67510: PUSH
67511: LD_INT 81
67513: PUSH
67514: LD_VAR 0 1
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 3
67525: PUSH
67526: LD_INT 21
67528: PUSH
67529: LD_INT 3
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PPUSH
67544: CALL_OW 69
67548: ST_TO_ADDR
// for i in mines do
67549: LD_ADDR_VAR 0 4
67553: PUSH
67554: LD_VAR 0 2
67558: PUSH
67559: FOR_IN
67560: IFFALSE 67648
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67562: LD_VAR 0 4
67566: PUSH
67567: LD_INT 1
67569: ARRAY
67570: PPUSH
67571: LD_VAR 0 4
67575: PUSH
67576: LD_INT 2
67578: ARRAY
67579: PPUSH
67580: CALL_OW 458
67584: NOT
67585: IFFALSE 67589
// continue ;
67587: GO 67559
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67589: LD_VAR 0 4
67593: PUSH
67594: LD_INT 1
67596: ARRAY
67597: PPUSH
67598: LD_VAR 0 4
67602: PUSH
67603: LD_INT 2
67605: ARRAY
67606: PPUSH
67607: CALL_OW 428
67611: PUSH
67612: LD_VAR 0 5
67616: IN
67617: IFFALSE 67646
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67619: LD_VAR 0 4
67623: PUSH
67624: LD_INT 1
67626: ARRAY
67627: PPUSH
67628: LD_VAR 0 4
67632: PUSH
67633: LD_INT 2
67635: ARRAY
67636: PPUSH
67637: LD_VAR 0 1
67641: PPUSH
67642: CALL_OW 456
// end ;
67646: GO 67559
67648: POP
67649: POP
// end ;
67650: LD_VAR 0 3
67654: RET
// export function Count ( array ) ; var i ; begin
67655: LD_INT 0
67657: PPUSH
67658: PPUSH
// result := 0 ;
67659: LD_ADDR_VAR 0 2
67663: PUSH
67664: LD_INT 0
67666: ST_TO_ADDR
// for i in array do
67667: LD_ADDR_VAR 0 3
67671: PUSH
67672: LD_VAR 0 1
67676: PUSH
67677: FOR_IN
67678: IFFALSE 67702
// if i then
67680: LD_VAR 0 3
67684: IFFALSE 67700
// result := result + 1 ;
67686: LD_ADDR_VAR 0 2
67690: PUSH
67691: LD_VAR 0 2
67695: PUSH
67696: LD_INT 1
67698: PLUS
67699: ST_TO_ADDR
67700: GO 67677
67702: POP
67703: POP
// end ;
67704: LD_VAR 0 2
67708: RET
// export function IsEmpty ( building ) ; begin
67709: LD_INT 0
67711: PPUSH
// if not building then
67712: LD_VAR 0 1
67716: NOT
67717: IFFALSE 67721
// exit ;
67719: GO 67764
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67721: LD_ADDR_VAR 0 2
67725: PUSH
67726: LD_VAR 0 1
67730: PUSH
67731: LD_INT 22
67733: PUSH
67734: LD_VAR 0 1
67738: PPUSH
67739: CALL_OW 255
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 58
67750: PUSH
67751: EMPTY
67752: LIST
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PPUSH
67758: CALL_OW 69
67762: IN
67763: ST_TO_ADDR
// end ;
67764: LD_VAR 0 2
67768: RET
// export function IsNotFull ( building ) ; begin
67769: LD_INT 0
67771: PPUSH
// if not building then
67772: LD_VAR 0 1
67776: NOT
67777: IFFALSE 67781
// exit ;
67779: GO 67800
// result := UnitsInside ( building ) < 6 ;
67781: LD_ADDR_VAR 0 2
67785: PUSH
67786: LD_VAR 0 1
67790: PPUSH
67791: CALL_OW 313
67795: PUSH
67796: LD_INT 6
67798: LESS
67799: ST_TO_ADDR
// end ;
67800: LD_VAR 0 2
67804: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67805: LD_INT 0
67807: PPUSH
67808: PPUSH
67809: PPUSH
67810: PPUSH
// tmp := [ ] ;
67811: LD_ADDR_VAR 0 3
67815: PUSH
67816: EMPTY
67817: ST_TO_ADDR
// list := [ ] ;
67818: LD_ADDR_VAR 0 5
67822: PUSH
67823: EMPTY
67824: ST_TO_ADDR
// for i = 16 to 25 do
67825: LD_ADDR_VAR 0 4
67829: PUSH
67830: DOUBLE
67831: LD_INT 16
67833: DEC
67834: ST_TO_ADDR
67835: LD_INT 25
67837: PUSH
67838: FOR_TO
67839: IFFALSE 67912
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67841: LD_ADDR_VAR 0 3
67845: PUSH
67846: LD_VAR 0 3
67850: PUSH
67851: LD_INT 22
67853: PUSH
67854: LD_VAR 0 1
67858: PPUSH
67859: CALL_OW 255
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: LD_INT 91
67870: PUSH
67871: LD_VAR 0 1
67875: PUSH
67876: LD_INT 6
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 30
67886: PUSH
67887: LD_VAR 0 4
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: LIST
67900: PUSH
67901: EMPTY
67902: LIST
67903: PPUSH
67904: CALL_OW 69
67908: ADD
67909: ST_TO_ADDR
67910: GO 67838
67912: POP
67913: POP
// for i = 1 to tmp do
67914: LD_ADDR_VAR 0 4
67918: PUSH
67919: DOUBLE
67920: LD_INT 1
67922: DEC
67923: ST_TO_ADDR
67924: LD_VAR 0 3
67928: PUSH
67929: FOR_TO
67930: IFFALSE 68018
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67932: LD_ADDR_VAR 0 5
67936: PUSH
67937: LD_VAR 0 5
67941: PUSH
67942: LD_VAR 0 3
67946: PUSH
67947: LD_VAR 0 4
67951: ARRAY
67952: PPUSH
67953: CALL_OW 266
67957: PUSH
67958: LD_VAR 0 3
67962: PUSH
67963: LD_VAR 0 4
67967: ARRAY
67968: PPUSH
67969: CALL_OW 250
67973: PUSH
67974: LD_VAR 0 3
67978: PUSH
67979: LD_VAR 0 4
67983: ARRAY
67984: PPUSH
67985: CALL_OW 251
67989: PUSH
67990: LD_VAR 0 3
67994: PUSH
67995: LD_VAR 0 4
67999: ARRAY
68000: PPUSH
68001: CALL_OW 254
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: PUSH
68012: EMPTY
68013: LIST
68014: ADD
68015: ST_TO_ADDR
68016: GO 67929
68018: POP
68019: POP
// result := list ;
68020: LD_ADDR_VAR 0 2
68024: PUSH
68025: LD_VAR 0 5
68029: ST_TO_ADDR
// end ;
68030: LD_VAR 0 2
68034: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68035: LD_INT 0
68037: PPUSH
68038: PPUSH
68039: PPUSH
68040: PPUSH
68041: PPUSH
68042: PPUSH
68043: PPUSH
// if not factory then
68044: LD_VAR 0 1
68048: NOT
68049: IFFALSE 68053
// exit ;
68051: GO 68646
// if control = control_apeman then
68053: LD_VAR 0 4
68057: PUSH
68058: LD_INT 5
68060: EQUAL
68061: IFFALSE 68170
// begin tmp := UnitsInside ( factory ) ;
68063: LD_ADDR_VAR 0 8
68067: PUSH
68068: LD_VAR 0 1
68072: PPUSH
68073: CALL_OW 313
68077: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68078: LD_VAR 0 8
68082: PPUSH
68083: LD_INT 25
68085: PUSH
68086: LD_INT 12
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PPUSH
68093: CALL_OW 72
68097: NOT
68098: IFFALSE 68108
// control := control_manual ;
68100: LD_ADDR_VAR 0 4
68104: PUSH
68105: LD_INT 1
68107: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68108: LD_ADDR_VAR 0 8
68112: PUSH
68113: LD_VAR 0 1
68117: PPUSH
68118: CALL 67805 0 1
68122: ST_TO_ADDR
// if tmp then
68123: LD_VAR 0 8
68127: IFFALSE 68170
// begin for i in tmp do
68129: LD_ADDR_VAR 0 7
68133: PUSH
68134: LD_VAR 0 8
68138: PUSH
68139: FOR_IN
68140: IFFALSE 68168
// if i [ 1 ] = b_ext_radio then
68142: LD_VAR 0 7
68146: PUSH
68147: LD_INT 1
68149: ARRAY
68150: PUSH
68151: LD_INT 22
68153: EQUAL
68154: IFFALSE 68166
// begin control := control_remote ;
68156: LD_ADDR_VAR 0 4
68160: PUSH
68161: LD_INT 2
68163: ST_TO_ADDR
// break ;
68164: GO 68168
// end ;
68166: GO 68139
68168: POP
68169: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68170: LD_VAR 0 1
68174: PPUSH
68175: LD_VAR 0 2
68179: PPUSH
68180: LD_VAR 0 3
68184: PPUSH
68185: LD_VAR 0 4
68189: PPUSH
68190: LD_VAR 0 5
68194: PPUSH
68195: CALL_OW 448
68199: IFFALSE 68234
// begin result := [ chassis , engine , control , weapon ] ;
68201: LD_ADDR_VAR 0 6
68205: PUSH
68206: LD_VAR 0 2
68210: PUSH
68211: LD_VAR 0 3
68215: PUSH
68216: LD_VAR 0 4
68220: PUSH
68221: LD_VAR 0 5
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: LIST
68230: LIST
68231: ST_TO_ADDR
// exit ;
68232: GO 68646
// end ; _chassis := AvailableChassisList ( factory ) ;
68234: LD_ADDR_VAR 0 9
68238: PUSH
68239: LD_VAR 0 1
68243: PPUSH
68244: CALL_OW 475
68248: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68249: LD_ADDR_VAR 0 11
68253: PUSH
68254: LD_VAR 0 1
68258: PPUSH
68259: CALL_OW 476
68263: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68264: LD_ADDR_VAR 0 12
68268: PUSH
68269: LD_VAR 0 1
68273: PPUSH
68274: CALL_OW 477
68278: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68279: LD_ADDR_VAR 0 10
68283: PUSH
68284: LD_VAR 0 1
68288: PPUSH
68289: CALL_OW 478
68293: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68294: LD_VAR 0 9
68298: NOT
68299: PUSH
68300: LD_VAR 0 11
68304: NOT
68305: OR
68306: PUSH
68307: LD_VAR 0 12
68311: NOT
68312: OR
68313: PUSH
68314: LD_VAR 0 10
68318: NOT
68319: OR
68320: IFFALSE 68355
// begin result := [ chassis , engine , control , weapon ] ;
68322: LD_ADDR_VAR 0 6
68326: PUSH
68327: LD_VAR 0 2
68331: PUSH
68332: LD_VAR 0 3
68336: PUSH
68337: LD_VAR 0 4
68341: PUSH
68342: LD_VAR 0 5
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: ST_TO_ADDR
// exit ;
68353: GO 68646
// end ; if not chassis in _chassis then
68355: LD_VAR 0 2
68359: PUSH
68360: LD_VAR 0 9
68364: IN
68365: NOT
68366: IFFALSE 68392
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68368: LD_ADDR_VAR 0 2
68372: PUSH
68373: LD_VAR 0 9
68377: PUSH
68378: LD_INT 1
68380: PPUSH
68381: LD_VAR 0 9
68385: PPUSH
68386: CALL_OW 12
68390: ARRAY
68391: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68392: LD_VAR 0 2
68396: PPUSH
68397: LD_VAR 0 3
68401: PPUSH
68402: CALL 68651 0 2
68406: NOT
68407: IFFALSE 68466
// repeat engine := _engine [ 1 ] ;
68409: LD_ADDR_VAR 0 3
68413: PUSH
68414: LD_VAR 0 11
68418: PUSH
68419: LD_INT 1
68421: ARRAY
68422: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68423: LD_ADDR_VAR 0 11
68427: PUSH
68428: LD_VAR 0 11
68432: PPUSH
68433: LD_INT 1
68435: PPUSH
68436: CALL_OW 3
68440: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68441: LD_VAR 0 2
68445: PPUSH
68446: LD_VAR 0 3
68450: PPUSH
68451: CALL 68651 0 2
68455: PUSH
68456: LD_VAR 0 11
68460: PUSH
68461: EMPTY
68462: EQUAL
68463: OR
68464: IFFALSE 68409
// if not control in _control then
68466: LD_VAR 0 4
68470: PUSH
68471: LD_VAR 0 12
68475: IN
68476: NOT
68477: IFFALSE 68503
// control := _control [ rand ( 1 , _control ) ] ;
68479: LD_ADDR_VAR 0 4
68483: PUSH
68484: LD_VAR 0 12
68488: PUSH
68489: LD_INT 1
68491: PPUSH
68492: LD_VAR 0 12
68496: PPUSH
68497: CALL_OW 12
68501: ARRAY
68502: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68503: LD_VAR 0 2
68507: PPUSH
68508: LD_VAR 0 5
68512: PPUSH
68513: CALL 68871 0 2
68517: NOT
68518: IFFALSE 68577
// repeat weapon := _weapon [ 1 ] ;
68520: LD_ADDR_VAR 0 5
68524: PUSH
68525: LD_VAR 0 10
68529: PUSH
68530: LD_INT 1
68532: ARRAY
68533: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68534: LD_ADDR_VAR 0 10
68538: PUSH
68539: LD_VAR 0 10
68543: PPUSH
68544: LD_INT 1
68546: PPUSH
68547: CALL_OW 3
68551: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68552: LD_VAR 0 2
68556: PPUSH
68557: LD_VAR 0 5
68561: PPUSH
68562: CALL 68871 0 2
68566: PUSH
68567: LD_VAR 0 10
68571: PUSH
68572: EMPTY
68573: EQUAL
68574: OR
68575: IFFALSE 68520
// result := [ ] ;
68577: LD_ADDR_VAR 0 6
68581: PUSH
68582: EMPTY
68583: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68584: LD_VAR 0 1
68588: PPUSH
68589: LD_VAR 0 2
68593: PPUSH
68594: LD_VAR 0 3
68598: PPUSH
68599: LD_VAR 0 4
68603: PPUSH
68604: LD_VAR 0 5
68608: PPUSH
68609: CALL_OW 448
68613: IFFALSE 68646
// result := [ chassis , engine , control , weapon ] ;
68615: LD_ADDR_VAR 0 6
68619: PUSH
68620: LD_VAR 0 2
68624: PUSH
68625: LD_VAR 0 3
68629: PUSH
68630: LD_VAR 0 4
68634: PUSH
68635: LD_VAR 0 5
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: ST_TO_ADDR
// end ;
68646: LD_VAR 0 6
68650: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68651: LD_INT 0
68653: PPUSH
// if not chassis or not engine then
68654: LD_VAR 0 1
68658: NOT
68659: PUSH
68660: LD_VAR 0 2
68664: NOT
68665: OR
68666: IFFALSE 68670
// exit ;
68668: GO 68866
// case engine of engine_solar :
68670: LD_VAR 0 2
68674: PUSH
68675: LD_INT 2
68677: DOUBLE
68678: EQUAL
68679: IFTRUE 68683
68681: GO 68721
68683: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68684: LD_ADDR_VAR 0 3
68688: PUSH
68689: LD_INT 11
68691: PUSH
68692: LD_INT 12
68694: PUSH
68695: LD_INT 13
68697: PUSH
68698: LD_INT 14
68700: PUSH
68701: LD_INT 1
68703: PUSH
68704: LD_INT 2
68706: PUSH
68707: LD_INT 3
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: ST_TO_ADDR
68719: GO 68850
68721: LD_INT 1
68723: DOUBLE
68724: EQUAL
68725: IFTRUE 68729
68727: GO 68791
68729: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68730: LD_ADDR_VAR 0 3
68734: PUSH
68735: LD_INT 11
68737: PUSH
68738: LD_INT 12
68740: PUSH
68741: LD_INT 13
68743: PUSH
68744: LD_INT 14
68746: PUSH
68747: LD_INT 1
68749: PUSH
68750: LD_INT 2
68752: PUSH
68753: LD_INT 3
68755: PUSH
68756: LD_INT 4
68758: PUSH
68759: LD_INT 5
68761: PUSH
68762: LD_INT 21
68764: PUSH
68765: LD_INT 23
68767: PUSH
68768: LD_INT 22
68770: PUSH
68771: LD_INT 24
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: LIST
68781: LIST
68782: LIST
68783: LIST
68784: LIST
68785: LIST
68786: LIST
68787: LIST
68788: ST_TO_ADDR
68789: GO 68850
68791: LD_INT 3
68793: DOUBLE
68794: EQUAL
68795: IFTRUE 68799
68797: GO 68849
68799: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68800: LD_ADDR_VAR 0 3
68804: PUSH
68805: LD_INT 13
68807: PUSH
68808: LD_INT 14
68810: PUSH
68811: LD_INT 2
68813: PUSH
68814: LD_INT 3
68816: PUSH
68817: LD_INT 4
68819: PUSH
68820: LD_INT 5
68822: PUSH
68823: LD_INT 21
68825: PUSH
68826: LD_INT 22
68828: PUSH
68829: LD_INT 23
68831: PUSH
68832: LD_INT 24
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: ST_TO_ADDR
68847: GO 68850
68849: POP
// result := ( chassis in result ) ;
68850: LD_ADDR_VAR 0 3
68854: PUSH
68855: LD_VAR 0 1
68859: PUSH
68860: LD_VAR 0 3
68864: IN
68865: ST_TO_ADDR
// end ;
68866: LD_VAR 0 3
68870: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68871: LD_INT 0
68873: PPUSH
// if not chassis or not weapon then
68874: LD_VAR 0 1
68878: NOT
68879: PUSH
68880: LD_VAR 0 2
68884: NOT
68885: OR
68886: IFFALSE 68890
// exit ;
68888: GO 69952
// case weapon of us_machine_gun :
68890: LD_VAR 0 2
68894: PUSH
68895: LD_INT 2
68897: DOUBLE
68898: EQUAL
68899: IFTRUE 68903
68901: GO 68933
68903: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68904: LD_ADDR_VAR 0 3
68908: PUSH
68909: LD_INT 1
68911: PUSH
68912: LD_INT 2
68914: PUSH
68915: LD_INT 3
68917: PUSH
68918: LD_INT 4
68920: PUSH
68921: LD_INT 5
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: LIST
68928: LIST
68929: LIST
68930: ST_TO_ADDR
68931: GO 69936
68933: LD_INT 3
68935: DOUBLE
68936: EQUAL
68937: IFTRUE 68941
68939: GO 68971
68941: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68942: LD_ADDR_VAR 0 3
68946: PUSH
68947: LD_INT 1
68949: PUSH
68950: LD_INT 2
68952: PUSH
68953: LD_INT 3
68955: PUSH
68956: LD_INT 4
68958: PUSH
68959: LD_INT 5
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: ST_TO_ADDR
68969: GO 69936
68971: LD_INT 11
68973: DOUBLE
68974: EQUAL
68975: IFTRUE 68979
68977: GO 69009
68979: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68980: LD_ADDR_VAR 0 3
68984: PUSH
68985: LD_INT 1
68987: PUSH
68988: LD_INT 2
68990: PUSH
68991: LD_INT 3
68993: PUSH
68994: LD_INT 4
68996: PUSH
68997: LD_INT 5
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: ST_TO_ADDR
69007: GO 69936
69009: LD_INT 4
69011: DOUBLE
69012: EQUAL
69013: IFTRUE 69017
69015: GO 69043
69017: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69018: LD_ADDR_VAR 0 3
69022: PUSH
69023: LD_INT 2
69025: PUSH
69026: LD_INT 3
69028: PUSH
69029: LD_INT 4
69031: PUSH
69032: LD_INT 5
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: ST_TO_ADDR
69041: GO 69936
69043: LD_INT 5
69045: DOUBLE
69046: EQUAL
69047: IFTRUE 69051
69049: GO 69077
69051: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69052: LD_ADDR_VAR 0 3
69056: PUSH
69057: LD_INT 2
69059: PUSH
69060: LD_INT 3
69062: PUSH
69063: LD_INT 4
69065: PUSH
69066: LD_INT 5
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: ST_TO_ADDR
69075: GO 69936
69077: LD_INT 9
69079: DOUBLE
69080: EQUAL
69081: IFTRUE 69085
69083: GO 69111
69085: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69086: LD_ADDR_VAR 0 3
69090: PUSH
69091: LD_INT 2
69093: PUSH
69094: LD_INT 3
69096: PUSH
69097: LD_INT 4
69099: PUSH
69100: LD_INT 5
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: LIST
69107: LIST
69108: ST_TO_ADDR
69109: GO 69936
69111: LD_INT 7
69113: DOUBLE
69114: EQUAL
69115: IFTRUE 69119
69117: GO 69145
69119: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69120: LD_ADDR_VAR 0 3
69124: PUSH
69125: LD_INT 2
69127: PUSH
69128: LD_INT 3
69130: PUSH
69131: LD_INT 4
69133: PUSH
69134: LD_INT 5
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: ST_TO_ADDR
69143: GO 69936
69145: LD_INT 12
69147: DOUBLE
69148: EQUAL
69149: IFTRUE 69153
69151: GO 69179
69153: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69154: LD_ADDR_VAR 0 3
69158: PUSH
69159: LD_INT 2
69161: PUSH
69162: LD_INT 3
69164: PUSH
69165: LD_INT 4
69167: PUSH
69168: LD_INT 5
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: ST_TO_ADDR
69177: GO 69936
69179: LD_INT 13
69181: DOUBLE
69182: EQUAL
69183: IFTRUE 69187
69185: GO 69213
69187: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69188: LD_ADDR_VAR 0 3
69192: PUSH
69193: LD_INT 2
69195: PUSH
69196: LD_INT 3
69198: PUSH
69199: LD_INT 4
69201: PUSH
69202: LD_INT 5
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: ST_TO_ADDR
69211: GO 69936
69213: LD_INT 14
69215: DOUBLE
69216: EQUAL
69217: IFTRUE 69221
69219: GO 69239
69221: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69222: LD_ADDR_VAR 0 3
69226: PUSH
69227: LD_INT 4
69229: PUSH
69230: LD_INT 5
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: ST_TO_ADDR
69237: GO 69936
69239: LD_INT 6
69241: DOUBLE
69242: EQUAL
69243: IFTRUE 69247
69245: GO 69265
69247: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69248: LD_ADDR_VAR 0 3
69252: PUSH
69253: LD_INT 4
69255: PUSH
69256: LD_INT 5
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: ST_TO_ADDR
69263: GO 69936
69265: LD_INT 10
69267: DOUBLE
69268: EQUAL
69269: IFTRUE 69273
69271: GO 69291
69273: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69274: LD_ADDR_VAR 0 3
69278: PUSH
69279: LD_INT 4
69281: PUSH
69282: LD_INT 5
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: ST_TO_ADDR
69289: GO 69936
69291: LD_INT 22
69293: DOUBLE
69294: EQUAL
69295: IFTRUE 69299
69297: GO 69325
69299: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69300: LD_ADDR_VAR 0 3
69304: PUSH
69305: LD_INT 11
69307: PUSH
69308: LD_INT 12
69310: PUSH
69311: LD_INT 13
69313: PUSH
69314: LD_INT 14
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: ST_TO_ADDR
69323: GO 69936
69325: LD_INT 23
69327: DOUBLE
69328: EQUAL
69329: IFTRUE 69333
69331: GO 69359
69333: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69334: LD_ADDR_VAR 0 3
69338: PUSH
69339: LD_INT 11
69341: PUSH
69342: LD_INT 12
69344: PUSH
69345: LD_INT 13
69347: PUSH
69348: LD_INT 14
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: ST_TO_ADDR
69357: GO 69936
69359: LD_INT 24
69361: DOUBLE
69362: EQUAL
69363: IFTRUE 69367
69365: GO 69393
69367: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69368: LD_ADDR_VAR 0 3
69372: PUSH
69373: LD_INT 11
69375: PUSH
69376: LD_INT 12
69378: PUSH
69379: LD_INT 13
69381: PUSH
69382: LD_INT 14
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: LIST
69389: LIST
69390: ST_TO_ADDR
69391: GO 69936
69393: LD_INT 30
69395: DOUBLE
69396: EQUAL
69397: IFTRUE 69401
69399: GO 69427
69401: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69402: LD_ADDR_VAR 0 3
69406: PUSH
69407: LD_INT 11
69409: PUSH
69410: LD_INT 12
69412: PUSH
69413: LD_INT 13
69415: PUSH
69416: LD_INT 14
69418: PUSH
69419: EMPTY
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: ST_TO_ADDR
69425: GO 69936
69427: LD_INT 25
69429: DOUBLE
69430: EQUAL
69431: IFTRUE 69435
69433: GO 69453
69435: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69436: LD_ADDR_VAR 0 3
69440: PUSH
69441: LD_INT 13
69443: PUSH
69444: LD_INT 14
69446: PUSH
69447: EMPTY
69448: LIST
69449: LIST
69450: ST_TO_ADDR
69451: GO 69936
69453: LD_INT 27
69455: DOUBLE
69456: EQUAL
69457: IFTRUE 69461
69459: GO 69479
69461: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69462: LD_ADDR_VAR 0 3
69466: PUSH
69467: LD_INT 13
69469: PUSH
69470: LD_INT 14
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: ST_TO_ADDR
69477: GO 69936
69479: LD_EXP 100
69483: DOUBLE
69484: EQUAL
69485: IFTRUE 69489
69487: GO 69515
69489: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69490: LD_ADDR_VAR 0 3
69494: PUSH
69495: LD_INT 11
69497: PUSH
69498: LD_INT 12
69500: PUSH
69501: LD_INT 13
69503: PUSH
69504: LD_INT 14
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: LIST
69511: LIST
69512: ST_TO_ADDR
69513: GO 69936
69515: LD_INT 28
69517: DOUBLE
69518: EQUAL
69519: IFTRUE 69523
69521: GO 69541
69523: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69524: LD_ADDR_VAR 0 3
69528: PUSH
69529: LD_INT 13
69531: PUSH
69532: LD_INT 14
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: ST_TO_ADDR
69539: GO 69936
69541: LD_INT 29
69543: DOUBLE
69544: EQUAL
69545: IFTRUE 69549
69547: GO 69567
69549: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69550: LD_ADDR_VAR 0 3
69554: PUSH
69555: LD_INT 13
69557: PUSH
69558: LD_INT 14
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: ST_TO_ADDR
69565: GO 69936
69567: LD_INT 31
69569: DOUBLE
69570: EQUAL
69571: IFTRUE 69575
69573: GO 69593
69575: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69576: LD_ADDR_VAR 0 3
69580: PUSH
69581: LD_INT 13
69583: PUSH
69584: LD_INT 14
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: ST_TO_ADDR
69591: GO 69936
69593: LD_INT 26
69595: DOUBLE
69596: EQUAL
69597: IFTRUE 69601
69599: GO 69619
69601: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69602: LD_ADDR_VAR 0 3
69606: PUSH
69607: LD_INT 13
69609: PUSH
69610: LD_INT 14
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: ST_TO_ADDR
69617: GO 69936
69619: LD_INT 42
69621: DOUBLE
69622: EQUAL
69623: IFTRUE 69627
69625: GO 69653
69627: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69628: LD_ADDR_VAR 0 3
69632: PUSH
69633: LD_INT 21
69635: PUSH
69636: LD_INT 22
69638: PUSH
69639: LD_INT 23
69641: PUSH
69642: LD_INT 24
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: LIST
69649: LIST
69650: ST_TO_ADDR
69651: GO 69936
69653: LD_INT 43
69655: DOUBLE
69656: EQUAL
69657: IFTRUE 69661
69659: GO 69687
69661: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69662: LD_ADDR_VAR 0 3
69666: PUSH
69667: LD_INT 21
69669: PUSH
69670: LD_INT 22
69672: PUSH
69673: LD_INT 23
69675: PUSH
69676: LD_INT 24
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: ST_TO_ADDR
69685: GO 69936
69687: LD_INT 44
69689: DOUBLE
69690: EQUAL
69691: IFTRUE 69695
69693: GO 69721
69695: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69696: LD_ADDR_VAR 0 3
69700: PUSH
69701: LD_INT 21
69703: PUSH
69704: LD_INT 22
69706: PUSH
69707: LD_INT 23
69709: PUSH
69710: LD_INT 24
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: ST_TO_ADDR
69719: GO 69936
69721: LD_INT 45
69723: DOUBLE
69724: EQUAL
69725: IFTRUE 69729
69727: GO 69755
69729: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69730: LD_ADDR_VAR 0 3
69734: PUSH
69735: LD_INT 21
69737: PUSH
69738: LD_INT 22
69740: PUSH
69741: LD_INT 23
69743: PUSH
69744: LD_INT 24
69746: PUSH
69747: EMPTY
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: ST_TO_ADDR
69753: GO 69936
69755: LD_INT 49
69757: DOUBLE
69758: EQUAL
69759: IFTRUE 69763
69761: GO 69789
69763: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69764: LD_ADDR_VAR 0 3
69768: PUSH
69769: LD_INT 21
69771: PUSH
69772: LD_INT 22
69774: PUSH
69775: LD_INT 23
69777: PUSH
69778: LD_INT 24
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: LIST
69785: LIST
69786: ST_TO_ADDR
69787: GO 69936
69789: LD_INT 51
69791: DOUBLE
69792: EQUAL
69793: IFTRUE 69797
69795: GO 69823
69797: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69798: LD_ADDR_VAR 0 3
69802: PUSH
69803: LD_INT 21
69805: PUSH
69806: LD_INT 22
69808: PUSH
69809: LD_INT 23
69811: PUSH
69812: LD_INT 24
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: LIST
69819: LIST
69820: ST_TO_ADDR
69821: GO 69936
69823: LD_INT 52
69825: DOUBLE
69826: EQUAL
69827: IFTRUE 69831
69829: GO 69857
69831: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69832: LD_ADDR_VAR 0 3
69836: PUSH
69837: LD_INT 21
69839: PUSH
69840: LD_INT 22
69842: PUSH
69843: LD_INT 23
69845: PUSH
69846: LD_INT 24
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: ST_TO_ADDR
69855: GO 69936
69857: LD_INT 53
69859: DOUBLE
69860: EQUAL
69861: IFTRUE 69865
69863: GO 69883
69865: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69866: LD_ADDR_VAR 0 3
69870: PUSH
69871: LD_INT 23
69873: PUSH
69874: LD_INT 24
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: ST_TO_ADDR
69881: GO 69936
69883: LD_INT 46
69885: DOUBLE
69886: EQUAL
69887: IFTRUE 69891
69889: GO 69909
69891: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69892: LD_ADDR_VAR 0 3
69896: PUSH
69897: LD_INT 23
69899: PUSH
69900: LD_INT 24
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: ST_TO_ADDR
69907: GO 69936
69909: LD_INT 47
69911: DOUBLE
69912: EQUAL
69913: IFTRUE 69917
69915: GO 69935
69917: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69918: LD_ADDR_VAR 0 3
69922: PUSH
69923: LD_INT 23
69925: PUSH
69926: LD_INT 24
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: ST_TO_ADDR
69933: GO 69936
69935: POP
// result := ( chassis in result ) ;
69936: LD_ADDR_VAR 0 3
69940: PUSH
69941: LD_VAR 0 1
69945: PUSH
69946: LD_VAR 0 3
69950: IN
69951: ST_TO_ADDR
// end ;
69952: LD_VAR 0 3
69956: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69957: LD_INT 0
69959: PPUSH
69960: PPUSH
69961: PPUSH
69962: PPUSH
69963: PPUSH
69964: PPUSH
69965: PPUSH
// result := array ;
69966: LD_ADDR_VAR 0 5
69970: PUSH
69971: LD_VAR 0 1
69975: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69976: LD_VAR 0 1
69980: NOT
69981: PUSH
69982: LD_VAR 0 2
69986: NOT
69987: OR
69988: PUSH
69989: LD_VAR 0 3
69993: NOT
69994: OR
69995: PUSH
69996: LD_VAR 0 2
70000: PUSH
70001: LD_VAR 0 1
70005: GREATER
70006: OR
70007: PUSH
70008: LD_VAR 0 3
70012: PUSH
70013: LD_VAR 0 1
70017: GREATER
70018: OR
70019: IFFALSE 70023
// exit ;
70021: GO 70319
// if direction then
70023: LD_VAR 0 4
70027: IFFALSE 70091
// begin d := 1 ;
70029: LD_ADDR_VAR 0 9
70033: PUSH
70034: LD_INT 1
70036: ST_TO_ADDR
// if i_from > i_to then
70037: LD_VAR 0 2
70041: PUSH
70042: LD_VAR 0 3
70046: GREATER
70047: IFFALSE 70073
// length := ( array - i_from ) + i_to else
70049: LD_ADDR_VAR 0 11
70053: PUSH
70054: LD_VAR 0 1
70058: PUSH
70059: LD_VAR 0 2
70063: MINUS
70064: PUSH
70065: LD_VAR 0 3
70069: PLUS
70070: ST_TO_ADDR
70071: GO 70089
// length := i_to - i_from ;
70073: LD_ADDR_VAR 0 11
70077: PUSH
70078: LD_VAR 0 3
70082: PUSH
70083: LD_VAR 0 2
70087: MINUS
70088: ST_TO_ADDR
// end else
70089: GO 70152
// begin d := - 1 ;
70091: LD_ADDR_VAR 0 9
70095: PUSH
70096: LD_INT 1
70098: NEG
70099: ST_TO_ADDR
// if i_from > i_to then
70100: LD_VAR 0 2
70104: PUSH
70105: LD_VAR 0 3
70109: GREATER
70110: IFFALSE 70130
// length := i_from - i_to else
70112: LD_ADDR_VAR 0 11
70116: PUSH
70117: LD_VAR 0 2
70121: PUSH
70122: LD_VAR 0 3
70126: MINUS
70127: ST_TO_ADDR
70128: GO 70152
// length := ( array - i_to ) + i_from ;
70130: LD_ADDR_VAR 0 11
70134: PUSH
70135: LD_VAR 0 1
70139: PUSH
70140: LD_VAR 0 3
70144: MINUS
70145: PUSH
70146: LD_VAR 0 2
70150: PLUS
70151: ST_TO_ADDR
// end ; if not length then
70152: LD_VAR 0 11
70156: NOT
70157: IFFALSE 70161
// exit ;
70159: GO 70319
// tmp := array ;
70161: LD_ADDR_VAR 0 10
70165: PUSH
70166: LD_VAR 0 1
70170: ST_TO_ADDR
// for i = 1 to length do
70171: LD_ADDR_VAR 0 6
70175: PUSH
70176: DOUBLE
70177: LD_INT 1
70179: DEC
70180: ST_TO_ADDR
70181: LD_VAR 0 11
70185: PUSH
70186: FOR_TO
70187: IFFALSE 70307
// begin for j = 1 to array do
70189: LD_ADDR_VAR 0 7
70193: PUSH
70194: DOUBLE
70195: LD_INT 1
70197: DEC
70198: ST_TO_ADDR
70199: LD_VAR 0 1
70203: PUSH
70204: FOR_TO
70205: IFFALSE 70293
// begin k := j + d ;
70207: LD_ADDR_VAR 0 8
70211: PUSH
70212: LD_VAR 0 7
70216: PUSH
70217: LD_VAR 0 9
70221: PLUS
70222: ST_TO_ADDR
// if k > array then
70223: LD_VAR 0 8
70227: PUSH
70228: LD_VAR 0 1
70232: GREATER
70233: IFFALSE 70243
// k := 1 ;
70235: LD_ADDR_VAR 0 8
70239: PUSH
70240: LD_INT 1
70242: ST_TO_ADDR
// if not k then
70243: LD_VAR 0 8
70247: NOT
70248: IFFALSE 70260
// k := array ;
70250: LD_ADDR_VAR 0 8
70254: PUSH
70255: LD_VAR 0 1
70259: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70260: LD_ADDR_VAR 0 10
70264: PUSH
70265: LD_VAR 0 10
70269: PPUSH
70270: LD_VAR 0 8
70274: PPUSH
70275: LD_VAR 0 1
70279: PUSH
70280: LD_VAR 0 7
70284: ARRAY
70285: PPUSH
70286: CALL_OW 1
70290: ST_TO_ADDR
// end ;
70291: GO 70204
70293: POP
70294: POP
// array := tmp ;
70295: LD_ADDR_VAR 0 1
70299: PUSH
70300: LD_VAR 0 10
70304: ST_TO_ADDR
// end ;
70305: GO 70186
70307: POP
70308: POP
// result := array ;
70309: LD_ADDR_VAR 0 5
70313: PUSH
70314: LD_VAR 0 1
70318: ST_TO_ADDR
// end ;
70319: LD_VAR 0 5
70323: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70324: LD_INT 0
70326: PPUSH
70327: PPUSH
// result := 0 ;
70328: LD_ADDR_VAR 0 3
70332: PUSH
70333: LD_INT 0
70335: ST_TO_ADDR
// if not array or not value in array then
70336: LD_VAR 0 1
70340: NOT
70341: PUSH
70342: LD_VAR 0 2
70346: PUSH
70347: LD_VAR 0 1
70351: IN
70352: NOT
70353: OR
70354: IFFALSE 70358
// exit ;
70356: GO 70412
// for i = 1 to array do
70358: LD_ADDR_VAR 0 4
70362: PUSH
70363: DOUBLE
70364: LD_INT 1
70366: DEC
70367: ST_TO_ADDR
70368: LD_VAR 0 1
70372: PUSH
70373: FOR_TO
70374: IFFALSE 70410
// if value = array [ i ] then
70376: LD_VAR 0 2
70380: PUSH
70381: LD_VAR 0 1
70385: PUSH
70386: LD_VAR 0 4
70390: ARRAY
70391: EQUAL
70392: IFFALSE 70408
// begin result := i ;
70394: LD_ADDR_VAR 0 3
70398: PUSH
70399: LD_VAR 0 4
70403: ST_TO_ADDR
// exit ;
70404: POP
70405: POP
70406: GO 70412
// end ;
70408: GO 70373
70410: POP
70411: POP
// end ;
70412: LD_VAR 0 3
70416: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70417: LD_INT 0
70419: PPUSH
// vc_chassis := chassis ;
70420: LD_ADDR_OWVAR 37
70424: PUSH
70425: LD_VAR 0 1
70429: ST_TO_ADDR
// vc_engine := engine ;
70430: LD_ADDR_OWVAR 39
70434: PUSH
70435: LD_VAR 0 2
70439: ST_TO_ADDR
// vc_control := control ;
70440: LD_ADDR_OWVAR 38
70444: PUSH
70445: LD_VAR 0 3
70449: ST_TO_ADDR
// vc_weapon := weapon ;
70450: LD_ADDR_OWVAR 40
70454: PUSH
70455: LD_VAR 0 4
70459: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70460: LD_ADDR_OWVAR 41
70464: PUSH
70465: LD_VAR 0 5
70469: ST_TO_ADDR
// end ;
70470: LD_VAR 0 6
70474: RET
// export function WantPlant ( unit ) ; var task ; begin
70475: LD_INT 0
70477: PPUSH
70478: PPUSH
// result := false ;
70479: LD_ADDR_VAR 0 2
70483: PUSH
70484: LD_INT 0
70486: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70487: LD_ADDR_VAR 0 3
70491: PUSH
70492: LD_VAR 0 1
70496: PPUSH
70497: CALL_OW 437
70501: ST_TO_ADDR
// if task then
70502: LD_VAR 0 3
70506: IFFALSE 70534
// if task [ 1 ] [ 1 ] = p then
70508: LD_VAR 0 3
70512: PUSH
70513: LD_INT 1
70515: ARRAY
70516: PUSH
70517: LD_INT 1
70519: ARRAY
70520: PUSH
70521: LD_STRING p
70523: EQUAL
70524: IFFALSE 70534
// result := true ;
70526: LD_ADDR_VAR 0 2
70530: PUSH
70531: LD_INT 1
70533: ST_TO_ADDR
// end ;
70534: LD_VAR 0 2
70538: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70539: LD_INT 0
70541: PPUSH
70542: PPUSH
70543: PPUSH
70544: PPUSH
// if pos < 1 then
70545: LD_VAR 0 2
70549: PUSH
70550: LD_INT 1
70552: LESS
70553: IFFALSE 70557
// exit ;
70555: GO 70860
// if pos = 1 then
70557: LD_VAR 0 2
70561: PUSH
70562: LD_INT 1
70564: EQUAL
70565: IFFALSE 70598
// result := Replace ( arr , pos [ 1 ] , value ) else
70567: LD_ADDR_VAR 0 4
70571: PUSH
70572: LD_VAR 0 1
70576: PPUSH
70577: LD_VAR 0 2
70581: PUSH
70582: LD_INT 1
70584: ARRAY
70585: PPUSH
70586: LD_VAR 0 3
70590: PPUSH
70591: CALL_OW 1
70595: ST_TO_ADDR
70596: GO 70860
// begin tmp := arr ;
70598: LD_ADDR_VAR 0 6
70602: PUSH
70603: LD_VAR 0 1
70607: ST_TO_ADDR
// s_arr := [ tmp ] ;
70608: LD_ADDR_VAR 0 7
70612: PUSH
70613: LD_VAR 0 6
70617: PUSH
70618: EMPTY
70619: LIST
70620: ST_TO_ADDR
// for i = 1 to pos - 1 do
70621: LD_ADDR_VAR 0 5
70625: PUSH
70626: DOUBLE
70627: LD_INT 1
70629: DEC
70630: ST_TO_ADDR
70631: LD_VAR 0 2
70635: PUSH
70636: LD_INT 1
70638: MINUS
70639: PUSH
70640: FOR_TO
70641: IFFALSE 70686
// begin tmp := tmp [ pos [ i ] ] ;
70643: LD_ADDR_VAR 0 6
70647: PUSH
70648: LD_VAR 0 6
70652: PUSH
70653: LD_VAR 0 2
70657: PUSH
70658: LD_VAR 0 5
70662: ARRAY
70663: ARRAY
70664: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70665: LD_ADDR_VAR 0 7
70669: PUSH
70670: LD_VAR 0 7
70674: PUSH
70675: LD_VAR 0 6
70679: PUSH
70680: EMPTY
70681: LIST
70682: ADD
70683: ST_TO_ADDR
// end ;
70684: GO 70640
70686: POP
70687: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70688: LD_ADDR_VAR 0 6
70692: PUSH
70693: LD_VAR 0 6
70697: PPUSH
70698: LD_VAR 0 2
70702: PUSH
70703: LD_VAR 0 2
70707: ARRAY
70708: PPUSH
70709: LD_VAR 0 3
70713: PPUSH
70714: CALL_OW 1
70718: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70719: LD_ADDR_VAR 0 7
70723: PUSH
70724: LD_VAR 0 7
70728: PPUSH
70729: LD_VAR 0 7
70733: PPUSH
70734: LD_VAR 0 6
70738: PPUSH
70739: CALL_OW 1
70743: ST_TO_ADDR
// for i = s_arr downto 2 do
70744: LD_ADDR_VAR 0 5
70748: PUSH
70749: DOUBLE
70750: LD_VAR 0 7
70754: INC
70755: ST_TO_ADDR
70756: LD_INT 2
70758: PUSH
70759: FOR_DOWNTO
70760: IFFALSE 70844
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70762: LD_ADDR_VAR 0 6
70766: PUSH
70767: LD_VAR 0 7
70771: PUSH
70772: LD_VAR 0 5
70776: PUSH
70777: LD_INT 1
70779: MINUS
70780: ARRAY
70781: PPUSH
70782: LD_VAR 0 2
70786: PUSH
70787: LD_VAR 0 5
70791: PUSH
70792: LD_INT 1
70794: MINUS
70795: ARRAY
70796: PPUSH
70797: LD_VAR 0 7
70801: PUSH
70802: LD_VAR 0 5
70806: ARRAY
70807: PPUSH
70808: CALL_OW 1
70812: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70813: LD_ADDR_VAR 0 7
70817: PUSH
70818: LD_VAR 0 7
70822: PPUSH
70823: LD_VAR 0 5
70827: PUSH
70828: LD_INT 1
70830: MINUS
70831: PPUSH
70832: LD_VAR 0 6
70836: PPUSH
70837: CALL_OW 1
70841: ST_TO_ADDR
// end ;
70842: GO 70759
70844: POP
70845: POP
// result := s_arr [ 1 ] ;
70846: LD_ADDR_VAR 0 4
70850: PUSH
70851: LD_VAR 0 7
70855: PUSH
70856: LD_INT 1
70858: ARRAY
70859: ST_TO_ADDR
// end ; end ;
70860: LD_VAR 0 4
70864: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70865: LD_INT 0
70867: PPUSH
70868: PPUSH
// if not list then
70869: LD_VAR 0 1
70873: NOT
70874: IFFALSE 70878
// exit ;
70876: GO 70969
// i := list [ pos1 ] ;
70878: LD_ADDR_VAR 0 5
70882: PUSH
70883: LD_VAR 0 1
70887: PUSH
70888: LD_VAR 0 2
70892: ARRAY
70893: ST_TO_ADDR
// if not i then
70894: LD_VAR 0 5
70898: NOT
70899: IFFALSE 70903
// exit ;
70901: GO 70969
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70903: LD_ADDR_VAR 0 1
70907: PUSH
70908: LD_VAR 0 1
70912: PPUSH
70913: LD_VAR 0 2
70917: PPUSH
70918: LD_VAR 0 1
70922: PUSH
70923: LD_VAR 0 3
70927: ARRAY
70928: PPUSH
70929: CALL_OW 1
70933: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70934: LD_ADDR_VAR 0 1
70938: PUSH
70939: LD_VAR 0 1
70943: PPUSH
70944: LD_VAR 0 3
70948: PPUSH
70949: LD_VAR 0 5
70953: PPUSH
70954: CALL_OW 1
70958: ST_TO_ADDR
// result := list ;
70959: LD_ADDR_VAR 0 4
70963: PUSH
70964: LD_VAR 0 1
70968: ST_TO_ADDR
// end ;
70969: LD_VAR 0 4
70973: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70974: LD_INT 0
70976: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70977: LD_ADDR_VAR 0 5
70981: PUSH
70982: LD_VAR 0 1
70986: PPUSH
70987: CALL_OW 250
70991: PPUSH
70992: LD_VAR 0 1
70996: PPUSH
70997: CALL_OW 251
71001: PPUSH
71002: LD_VAR 0 2
71006: PPUSH
71007: LD_VAR 0 3
71011: PPUSH
71012: LD_VAR 0 4
71016: PPUSH
71017: CALL 71027 0 5
71021: ST_TO_ADDR
// end ;
71022: LD_VAR 0 5
71026: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71027: LD_INT 0
71029: PPUSH
71030: PPUSH
71031: PPUSH
71032: PPUSH
// if not list then
71033: LD_VAR 0 3
71037: NOT
71038: IFFALSE 71042
// exit ;
71040: GO 71430
// result := [ ] ;
71042: LD_ADDR_VAR 0 6
71046: PUSH
71047: EMPTY
71048: ST_TO_ADDR
// for i in list do
71049: LD_ADDR_VAR 0 7
71053: PUSH
71054: LD_VAR 0 3
71058: PUSH
71059: FOR_IN
71060: IFFALSE 71262
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71062: LD_ADDR_VAR 0 9
71066: PUSH
71067: LD_VAR 0 7
71071: PPUSH
71072: LD_VAR 0 1
71076: PPUSH
71077: LD_VAR 0 2
71081: PPUSH
71082: CALL_OW 297
71086: ST_TO_ADDR
// if not result then
71087: LD_VAR 0 6
71091: NOT
71092: IFFALSE 71118
// result := [ [ i , tmp ] ] else
71094: LD_ADDR_VAR 0 6
71098: PUSH
71099: LD_VAR 0 7
71103: PUSH
71104: LD_VAR 0 9
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: EMPTY
71114: LIST
71115: ST_TO_ADDR
71116: GO 71260
// begin if result [ result ] [ 2 ] < tmp then
71118: LD_VAR 0 6
71122: PUSH
71123: LD_VAR 0 6
71127: ARRAY
71128: PUSH
71129: LD_INT 2
71131: ARRAY
71132: PUSH
71133: LD_VAR 0 9
71137: LESS
71138: IFFALSE 71180
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71140: LD_ADDR_VAR 0 6
71144: PUSH
71145: LD_VAR 0 6
71149: PPUSH
71150: LD_VAR 0 6
71154: PUSH
71155: LD_INT 1
71157: PLUS
71158: PPUSH
71159: LD_VAR 0 7
71163: PUSH
71164: LD_VAR 0 9
71168: PUSH
71169: EMPTY
71170: LIST
71171: LIST
71172: PPUSH
71173: CALL_OW 2
71177: ST_TO_ADDR
71178: GO 71260
// for j = 1 to result do
71180: LD_ADDR_VAR 0 8
71184: PUSH
71185: DOUBLE
71186: LD_INT 1
71188: DEC
71189: ST_TO_ADDR
71190: LD_VAR 0 6
71194: PUSH
71195: FOR_TO
71196: IFFALSE 71258
// begin if tmp < result [ j ] [ 2 ] then
71198: LD_VAR 0 9
71202: PUSH
71203: LD_VAR 0 6
71207: PUSH
71208: LD_VAR 0 8
71212: ARRAY
71213: PUSH
71214: LD_INT 2
71216: ARRAY
71217: LESS
71218: IFFALSE 71256
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71220: LD_ADDR_VAR 0 6
71224: PUSH
71225: LD_VAR 0 6
71229: PPUSH
71230: LD_VAR 0 8
71234: PPUSH
71235: LD_VAR 0 7
71239: PUSH
71240: LD_VAR 0 9
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PPUSH
71249: CALL_OW 2
71253: ST_TO_ADDR
// break ;
71254: GO 71258
// end ; end ;
71256: GO 71195
71258: POP
71259: POP
// end ; end ;
71260: GO 71059
71262: POP
71263: POP
// if result and not asc then
71264: LD_VAR 0 6
71268: PUSH
71269: LD_VAR 0 4
71273: NOT
71274: AND
71275: IFFALSE 71350
// begin tmp := result ;
71277: LD_ADDR_VAR 0 9
71281: PUSH
71282: LD_VAR 0 6
71286: ST_TO_ADDR
// for i = tmp downto 1 do
71287: LD_ADDR_VAR 0 7
71291: PUSH
71292: DOUBLE
71293: LD_VAR 0 9
71297: INC
71298: ST_TO_ADDR
71299: LD_INT 1
71301: PUSH
71302: FOR_DOWNTO
71303: IFFALSE 71348
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71305: LD_ADDR_VAR 0 6
71309: PUSH
71310: LD_VAR 0 6
71314: PPUSH
71315: LD_VAR 0 9
71319: PUSH
71320: LD_VAR 0 7
71324: MINUS
71325: PUSH
71326: LD_INT 1
71328: PLUS
71329: PPUSH
71330: LD_VAR 0 9
71334: PUSH
71335: LD_VAR 0 7
71339: ARRAY
71340: PPUSH
71341: CALL_OW 1
71345: ST_TO_ADDR
71346: GO 71302
71348: POP
71349: POP
// end ; tmp := [ ] ;
71350: LD_ADDR_VAR 0 9
71354: PUSH
71355: EMPTY
71356: ST_TO_ADDR
// if mode then
71357: LD_VAR 0 5
71361: IFFALSE 71430
// begin for i = 1 to result do
71363: LD_ADDR_VAR 0 7
71367: PUSH
71368: DOUBLE
71369: LD_INT 1
71371: DEC
71372: ST_TO_ADDR
71373: LD_VAR 0 6
71377: PUSH
71378: FOR_TO
71379: IFFALSE 71418
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71381: LD_ADDR_VAR 0 9
71385: PUSH
71386: LD_VAR 0 9
71390: PPUSH
71391: LD_VAR 0 7
71395: PPUSH
71396: LD_VAR 0 6
71400: PUSH
71401: LD_VAR 0 7
71405: ARRAY
71406: PUSH
71407: LD_INT 1
71409: ARRAY
71410: PPUSH
71411: CALL_OW 1
71415: ST_TO_ADDR
71416: GO 71378
71418: POP
71419: POP
// result := tmp ;
71420: LD_ADDR_VAR 0 6
71424: PUSH
71425: LD_VAR 0 9
71429: ST_TO_ADDR
// end ; end ;
71430: LD_VAR 0 6
71434: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71435: LD_INT 0
71437: PPUSH
71438: PPUSH
71439: PPUSH
71440: PPUSH
71441: PPUSH
71442: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71443: LD_ADDR_VAR 0 5
71447: PUSH
71448: LD_INT 0
71450: PUSH
71451: LD_INT 0
71453: PUSH
71454: LD_INT 0
71456: PUSH
71457: EMPTY
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: LIST
71463: LIST
71464: ST_TO_ADDR
// if not x or not y then
71465: LD_VAR 0 2
71469: NOT
71470: PUSH
71471: LD_VAR 0 3
71475: NOT
71476: OR
71477: IFFALSE 71481
// exit ;
71479: GO 73133
// if not range then
71481: LD_VAR 0 4
71485: NOT
71486: IFFALSE 71496
// range := 10 ;
71488: LD_ADDR_VAR 0 4
71492: PUSH
71493: LD_INT 10
71495: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71496: LD_ADDR_VAR 0 8
71500: PUSH
71501: LD_INT 81
71503: PUSH
71504: LD_VAR 0 1
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: PUSH
71513: LD_INT 92
71515: PUSH
71516: LD_VAR 0 2
71520: PUSH
71521: LD_VAR 0 3
71525: PUSH
71526: LD_VAR 0 4
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 3
71539: PUSH
71540: LD_INT 21
71542: PUSH
71543: LD_INT 3
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: LIST
71558: PPUSH
71559: CALL_OW 69
71563: ST_TO_ADDR
// if not tmp then
71564: LD_VAR 0 8
71568: NOT
71569: IFFALSE 71573
// exit ;
71571: GO 73133
// for i in tmp do
71573: LD_ADDR_VAR 0 6
71577: PUSH
71578: LD_VAR 0 8
71582: PUSH
71583: FOR_IN
71584: IFFALSE 73108
// begin points := [ 0 , 0 , 0 ] ;
71586: LD_ADDR_VAR 0 9
71590: PUSH
71591: LD_INT 0
71593: PUSH
71594: LD_INT 0
71596: PUSH
71597: LD_INT 0
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: LIST
71604: ST_TO_ADDR
// bpoints := 1 ;
71605: LD_ADDR_VAR 0 10
71609: PUSH
71610: LD_INT 1
71612: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71613: LD_VAR 0 6
71617: PPUSH
71618: CALL_OW 247
71622: PUSH
71623: LD_INT 1
71625: DOUBLE
71626: EQUAL
71627: IFTRUE 71631
71629: GO 72209
71631: POP
// begin if GetClass ( i ) = 1 then
71632: LD_VAR 0 6
71636: PPUSH
71637: CALL_OW 257
71641: PUSH
71642: LD_INT 1
71644: EQUAL
71645: IFFALSE 71666
// points := [ 10 , 5 , 3 ] ;
71647: LD_ADDR_VAR 0 9
71651: PUSH
71652: LD_INT 10
71654: PUSH
71655: LD_INT 5
71657: PUSH
71658: LD_INT 3
71660: PUSH
71661: EMPTY
71662: LIST
71663: LIST
71664: LIST
71665: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71666: LD_VAR 0 6
71670: PPUSH
71671: CALL_OW 257
71675: PUSH
71676: LD_INT 2
71678: PUSH
71679: LD_INT 3
71681: PUSH
71682: LD_INT 4
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: LIST
71689: IN
71690: IFFALSE 71711
// points := [ 3 , 2 , 1 ] ;
71692: LD_ADDR_VAR 0 9
71696: PUSH
71697: LD_INT 3
71699: PUSH
71700: LD_INT 2
71702: PUSH
71703: LD_INT 1
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: LIST
71710: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71711: LD_VAR 0 6
71715: PPUSH
71716: CALL_OW 257
71720: PUSH
71721: LD_INT 5
71723: EQUAL
71724: IFFALSE 71745
// points := [ 130 , 5 , 2 ] ;
71726: LD_ADDR_VAR 0 9
71730: PUSH
71731: LD_INT 130
71733: PUSH
71734: LD_INT 5
71736: PUSH
71737: LD_INT 2
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: LIST
71744: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71745: LD_VAR 0 6
71749: PPUSH
71750: CALL_OW 257
71754: PUSH
71755: LD_INT 8
71757: EQUAL
71758: IFFALSE 71779
// points := [ 35 , 35 , 30 ] ;
71760: LD_ADDR_VAR 0 9
71764: PUSH
71765: LD_INT 35
71767: PUSH
71768: LD_INT 35
71770: PUSH
71771: LD_INT 30
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: LIST
71778: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71779: LD_VAR 0 6
71783: PPUSH
71784: CALL_OW 257
71788: PUSH
71789: LD_INT 9
71791: EQUAL
71792: IFFALSE 71813
// points := [ 20 , 55 , 40 ] ;
71794: LD_ADDR_VAR 0 9
71798: PUSH
71799: LD_INT 20
71801: PUSH
71802: LD_INT 55
71804: PUSH
71805: LD_INT 40
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: LIST
71812: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71813: LD_VAR 0 6
71817: PPUSH
71818: CALL_OW 257
71822: PUSH
71823: LD_INT 12
71825: PUSH
71826: LD_INT 16
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: IN
71833: IFFALSE 71854
// points := [ 5 , 3 , 2 ] ;
71835: LD_ADDR_VAR 0 9
71839: PUSH
71840: LD_INT 5
71842: PUSH
71843: LD_INT 3
71845: PUSH
71846: LD_INT 2
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: LIST
71853: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71854: LD_VAR 0 6
71858: PPUSH
71859: CALL_OW 257
71863: PUSH
71864: LD_INT 17
71866: EQUAL
71867: IFFALSE 71888
// points := [ 100 , 50 , 75 ] ;
71869: LD_ADDR_VAR 0 9
71873: PUSH
71874: LD_INT 100
71876: PUSH
71877: LD_INT 50
71879: PUSH
71880: LD_INT 75
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: LIST
71887: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71888: LD_VAR 0 6
71892: PPUSH
71893: CALL_OW 257
71897: PUSH
71898: LD_INT 15
71900: EQUAL
71901: IFFALSE 71922
// points := [ 10 , 5 , 3 ] ;
71903: LD_ADDR_VAR 0 9
71907: PUSH
71908: LD_INT 10
71910: PUSH
71911: LD_INT 5
71913: PUSH
71914: LD_INT 3
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: LIST
71921: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71922: LD_VAR 0 6
71926: PPUSH
71927: CALL_OW 257
71931: PUSH
71932: LD_INT 14
71934: EQUAL
71935: IFFALSE 71956
// points := [ 10 , 0 , 0 ] ;
71937: LD_ADDR_VAR 0 9
71941: PUSH
71942: LD_INT 10
71944: PUSH
71945: LD_INT 0
71947: PUSH
71948: LD_INT 0
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: LIST
71955: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71956: LD_VAR 0 6
71960: PPUSH
71961: CALL_OW 257
71965: PUSH
71966: LD_INT 11
71968: EQUAL
71969: IFFALSE 71990
// points := [ 30 , 10 , 5 ] ;
71971: LD_ADDR_VAR 0 9
71975: PUSH
71976: LD_INT 30
71978: PUSH
71979: LD_INT 10
71981: PUSH
71982: LD_INT 5
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: LIST
71989: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71990: LD_VAR 0 1
71994: PPUSH
71995: LD_INT 5
71997: PPUSH
71998: CALL_OW 321
72002: PUSH
72003: LD_INT 2
72005: EQUAL
72006: IFFALSE 72023
// bpoints := bpoints * 1.8 ;
72008: LD_ADDR_VAR 0 10
72012: PUSH
72013: LD_VAR 0 10
72017: PUSH
72018: LD_REAL  1.80000000000000E+0000
72021: MUL
72022: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72023: LD_VAR 0 6
72027: PPUSH
72028: CALL_OW 257
72032: PUSH
72033: LD_INT 1
72035: PUSH
72036: LD_INT 2
72038: PUSH
72039: LD_INT 3
72041: PUSH
72042: LD_INT 4
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: IN
72051: PUSH
72052: LD_VAR 0 1
72056: PPUSH
72057: LD_INT 51
72059: PPUSH
72060: CALL_OW 321
72064: PUSH
72065: LD_INT 2
72067: EQUAL
72068: AND
72069: IFFALSE 72086
// bpoints := bpoints * 1.2 ;
72071: LD_ADDR_VAR 0 10
72075: PUSH
72076: LD_VAR 0 10
72080: PUSH
72081: LD_REAL  1.20000000000000E+0000
72084: MUL
72085: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72086: LD_VAR 0 6
72090: PPUSH
72091: CALL_OW 257
72095: PUSH
72096: LD_INT 5
72098: PUSH
72099: LD_INT 7
72101: PUSH
72102: LD_INT 9
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: LIST
72109: IN
72110: PUSH
72111: LD_VAR 0 1
72115: PPUSH
72116: LD_INT 52
72118: PPUSH
72119: CALL_OW 321
72123: PUSH
72124: LD_INT 2
72126: EQUAL
72127: AND
72128: IFFALSE 72145
// bpoints := bpoints * 1.5 ;
72130: LD_ADDR_VAR 0 10
72134: PUSH
72135: LD_VAR 0 10
72139: PUSH
72140: LD_REAL  1.50000000000000E+0000
72143: MUL
72144: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72145: LD_VAR 0 1
72149: PPUSH
72150: LD_INT 66
72152: PPUSH
72153: CALL_OW 321
72157: PUSH
72158: LD_INT 2
72160: EQUAL
72161: IFFALSE 72178
// bpoints := bpoints * 1.1 ;
72163: LD_ADDR_VAR 0 10
72167: PUSH
72168: LD_VAR 0 10
72172: PUSH
72173: LD_REAL  1.10000000000000E+0000
72176: MUL
72177: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72178: LD_ADDR_VAR 0 10
72182: PUSH
72183: LD_VAR 0 10
72187: PUSH
72188: LD_VAR 0 6
72192: PPUSH
72193: LD_INT 1
72195: PPUSH
72196: CALL_OW 259
72200: PUSH
72201: LD_REAL  1.15000000000000E+0000
72204: MUL
72205: MUL
72206: ST_TO_ADDR
// end ; unit_vehicle :
72207: GO 73037
72209: LD_INT 2
72211: DOUBLE
72212: EQUAL
72213: IFTRUE 72217
72215: GO 73025
72217: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72218: LD_VAR 0 6
72222: PPUSH
72223: CALL_OW 264
72227: PUSH
72228: LD_INT 2
72230: PUSH
72231: LD_INT 42
72233: PUSH
72234: LD_INT 24
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: LIST
72241: IN
72242: IFFALSE 72263
// points := [ 25 , 5 , 3 ] ;
72244: LD_ADDR_VAR 0 9
72248: PUSH
72249: LD_INT 25
72251: PUSH
72252: LD_INT 5
72254: PUSH
72255: LD_INT 3
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: LIST
72262: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72263: LD_VAR 0 6
72267: PPUSH
72268: CALL_OW 264
72272: PUSH
72273: LD_INT 4
72275: PUSH
72276: LD_INT 43
72278: PUSH
72279: LD_INT 25
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: LIST
72286: IN
72287: IFFALSE 72308
// points := [ 40 , 15 , 5 ] ;
72289: LD_ADDR_VAR 0 9
72293: PUSH
72294: LD_INT 40
72296: PUSH
72297: LD_INT 15
72299: PUSH
72300: LD_INT 5
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: LIST
72307: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72308: LD_VAR 0 6
72312: PPUSH
72313: CALL_OW 264
72317: PUSH
72318: LD_INT 3
72320: PUSH
72321: LD_INT 23
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: IN
72328: IFFALSE 72349
// points := [ 7 , 25 , 8 ] ;
72330: LD_ADDR_VAR 0 9
72334: PUSH
72335: LD_INT 7
72337: PUSH
72338: LD_INT 25
72340: PUSH
72341: LD_INT 8
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: LIST
72348: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72349: LD_VAR 0 6
72353: PPUSH
72354: CALL_OW 264
72358: PUSH
72359: LD_INT 5
72361: PUSH
72362: LD_INT 27
72364: PUSH
72365: LD_INT 44
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: LIST
72372: IN
72373: IFFALSE 72394
// points := [ 14 , 50 , 16 ] ;
72375: LD_ADDR_VAR 0 9
72379: PUSH
72380: LD_INT 14
72382: PUSH
72383: LD_INT 50
72385: PUSH
72386: LD_INT 16
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: LIST
72393: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72394: LD_VAR 0 6
72398: PPUSH
72399: CALL_OW 264
72403: PUSH
72404: LD_INT 6
72406: PUSH
72407: LD_INT 46
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: IN
72414: IFFALSE 72435
// points := [ 32 , 120 , 70 ] ;
72416: LD_ADDR_VAR 0 9
72420: PUSH
72421: LD_INT 32
72423: PUSH
72424: LD_INT 120
72426: PUSH
72427: LD_INT 70
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: LIST
72434: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72435: LD_VAR 0 6
72439: PPUSH
72440: CALL_OW 264
72444: PUSH
72445: LD_INT 7
72447: PUSH
72448: LD_INT 28
72450: PUSH
72451: LD_INT 45
72453: PUSH
72454: LD_EXP 100
72458: PUSH
72459: EMPTY
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: IN
72465: IFFALSE 72486
// points := [ 35 , 20 , 45 ] ;
72467: LD_ADDR_VAR 0 9
72471: PUSH
72472: LD_INT 35
72474: PUSH
72475: LD_INT 20
72477: PUSH
72478: LD_INT 45
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: LIST
72485: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72486: LD_VAR 0 6
72490: PPUSH
72491: CALL_OW 264
72495: PUSH
72496: LD_INT 47
72498: PUSH
72499: EMPTY
72500: LIST
72501: IN
72502: IFFALSE 72523
// points := [ 67 , 45 , 75 ] ;
72504: LD_ADDR_VAR 0 9
72508: PUSH
72509: LD_INT 67
72511: PUSH
72512: LD_INT 45
72514: PUSH
72515: LD_INT 75
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: LIST
72522: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72523: LD_VAR 0 6
72527: PPUSH
72528: CALL_OW 264
72532: PUSH
72533: LD_INT 26
72535: PUSH
72536: EMPTY
72537: LIST
72538: IN
72539: IFFALSE 72560
// points := [ 120 , 30 , 80 ] ;
72541: LD_ADDR_VAR 0 9
72545: PUSH
72546: LD_INT 120
72548: PUSH
72549: LD_INT 30
72551: PUSH
72552: LD_INT 80
72554: PUSH
72555: EMPTY
72556: LIST
72557: LIST
72558: LIST
72559: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72560: LD_VAR 0 6
72564: PPUSH
72565: CALL_OW 264
72569: PUSH
72570: LD_INT 22
72572: PUSH
72573: EMPTY
72574: LIST
72575: IN
72576: IFFALSE 72597
// points := [ 40 , 1 , 1 ] ;
72578: LD_ADDR_VAR 0 9
72582: PUSH
72583: LD_INT 40
72585: PUSH
72586: LD_INT 1
72588: PUSH
72589: LD_INT 1
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: LIST
72596: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72597: LD_VAR 0 6
72601: PPUSH
72602: CALL_OW 264
72606: PUSH
72607: LD_INT 29
72609: PUSH
72610: EMPTY
72611: LIST
72612: IN
72613: IFFALSE 72634
// points := [ 70 , 200 , 400 ] ;
72615: LD_ADDR_VAR 0 9
72619: PUSH
72620: LD_INT 70
72622: PUSH
72623: LD_INT 200
72625: PUSH
72626: LD_INT 400
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: LIST
72633: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72634: LD_VAR 0 6
72638: PPUSH
72639: CALL_OW 264
72643: PUSH
72644: LD_INT 14
72646: PUSH
72647: LD_INT 53
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: IN
72654: IFFALSE 72675
// points := [ 40 , 10 , 20 ] ;
72656: LD_ADDR_VAR 0 9
72660: PUSH
72661: LD_INT 40
72663: PUSH
72664: LD_INT 10
72666: PUSH
72667: LD_INT 20
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: LIST
72674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72675: LD_VAR 0 6
72679: PPUSH
72680: CALL_OW 264
72684: PUSH
72685: LD_INT 9
72687: PUSH
72688: EMPTY
72689: LIST
72690: IN
72691: IFFALSE 72712
// points := [ 5 , 70 , 20 ] ;
72693: LD_ADDR_VAR 0 9
72697: PUSH
72698: LD_INT 5
72700: PUSH
72701: LD_INT 70
72703: PUSH
72704: LD_INT 20
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: LIST
72711: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72712: LD_VAR 0 6
72716: PPUSH
72717: CALL_OW 264
72721: PUSH
72722: LD_INT 10
72724: PUSH
72725: EMPTY
72726: LIST
72727: IN
72728: IFFALSE 72749
// points := [ 35 , 110 , 70 ] ;
72730: LD_ADDR_VAR 0 9
72734: PUSH
72735: LD_INT 35
72737: PUSH
72738: LD_INT 110
72740: PUSH
72741: LD_INT 70
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: LIST
72748: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72749: LD_VAR 0 6
72753: PPUSH
72754: CALL_OW 265
72758: PUSH
72759: LD_INT 25
72761: EQUAL
72762: IFFALSE 72783
// points := [ 80 , 65 , 100 ] ;
72764: LD_ADDR_VAR 0 9
72768: PUSH
72769: LD_INT 80
72771: PUSH
72772: LD_INT 65
72774: PUSH
72775: LD_INT 100
72777: PUSH
72778: EMPTY
72779: LIST
72780: LIST
72781: LIST
72782: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72783: LD_VAR 0 6
72787: PPUSH
72788: CALL_OW 263
72792: PUSH
72793: LD_INT 1
72795: EQUAL
72796: IFFALSE 72831
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72798: LD_ADDR_VAR 0 10
72802: PUSH
72803: LD_VAR 0 10
72807: PUSH
72808: LD_VAR 0 6
72812: PPUSH
72813: CALL_OW 311
72817: PPUSH
72818: LD_INT 3
72820: PPUSH
72821: CALL_OW 259
72825: PUSH
72826: LD_INT 4
72828: MUL
72829: MUL
72830: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72831: LD_VAR 0 6
72835: PPUSH
72836: CALL_OW 263
72840: PUSH
72841: LD_INT 2
72843: EQUAL
72844: IFFALSE 72895
// begin j := IsControledBy ( i ) ;
72846: LD_ADDR_VAR 0 7
72850: PUSH
72851: LD_VAR 0 6
72855: PPUSH
72856: CALL_OW 312
72860: ST_TO_ADDR
// if j then
72861: LD_VAR 0 7
72865: IFFALSE 72895
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72867: LD_ADDR_VAR 0 10
72871: PUSH
72872: LD_VAR 0 10
72876: PUSH
72877: LD_VAR 0 7
72881: PPUSH
72882: LD_INT 3
72884: PPUSH
72885: CALL_OW 259
72889: PUSH
72890: LD_INT 3
72892: MUL
72893: MUL
72894: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72895: LD_VAR 0 6
72899: PPUSH
72900: CALL_OW 264
72904: PUSH
72905: LD_INT 5
72907: PUSH
72908: LD_INT 6
72910: PUSH
72911: LD_INT 46
72913: PUSH
72914: LD_INT 44
72916: PUSH
72917: LD_INT 47
72919: PUSH
72920: LD_INT 45
72922: PUSH
72923: LD_INT 28
72925: PUSH
72926: LD_INT 7
72928: PUSH
72929: LD_INT 27
72931: PUSH
72932: LD_INT 29
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: IN
72947: PUSH
72948: LD_VAR 0 1
72952: PPUSH
72953: LD_INT 52
72955: PPUSH
72956: CALL_OW 321
72960: PUSH
72961: LD_INT 2
72963: EQUAL
72964: AND
72965: IFFALSE 72982
// bpoints := bpoints * 1.2 ;
72967: LD_ADDR_VAR 0 10
72971: PUSH
72972: LD_VAR 0 10
72976: PUSH
72977: LD_REAL  1.20000000000000E+0000
72980: MUL
72981: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72982: LD_VAR 0 6
72986: PPUSH
72987: CALL_OW 264
72991: PUSH
72992: LD_INT 6
72994: PUSH
72995: LD_INT 46
72997: PUSH
72998: LD_INT 47
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: LIST
73005: IN
73006: IFFALSE 73023
// bpoints := bpoints * 1.2 ;
73008: LD_ADDR_VAR 0 10
73012: PUSH
73013: LD_VAR 0 10
73017: PUSH
73018: LD_REAL  1.20000000000000E+0000
73021: MUL
73022: ST_TO_ADDR
// end ; unit_building :
73023: GO 73037
73025: LD_INT 3
73027: DOUBLE
73028: EQUAL
73029: IFTRUE 73033
73031: GO 73036
73033: POP
// ; end ;
73034: GO 73037
73036: POP
// for j = 1 to 3 do
73037: LD_ADDR_VAR 0 7
73041: PUSH
73042: DOUBLE
73043: LD_INT 1
73045: DEC
73046: ST_TO_ADDR
73047: LD_INT 3
73049: PUSH
73050: FOR_TO
73051: IFFALSE 73104
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73053: LD_ADDR_VAR 0 5
73057: PUSH
73058: LD_VAR 0 5
73062: PPUSH
73063: LD_VAR 0 7
73067: PPUSH
73068: LD_VAR 0 5
73072: PUSH
73073: LD_VAR 0 7
73077: ARRAY
73078: PUSH
73079: LD_VAR 0 9
73083: PUSH
73084: LD_VAR 0 7
73088: ARRAY
73089: PUSH
73090: LD_VAR 0 10
73094: MUL
73095: PLUS
73096: PPUSH
73097: CALL_OW 1
73101: ST_TO_ADDR
73102: GO 73050
73104: POP
73105: POP
// end ;
73106: GO 71583
73108: POP
73109: POP
// result := Replace ( result , 4 , tmp ) ;
73110: LD_ADDR_VAR 0 5
73114: PUSH
73115: LD_VAR 0 5
73119: PPUSH
73120: LD_INT 4
73122: PPUSH
73123: LD_VAR 0 8
73127: PPUSH
73128: CALL_OW 1
73132: ST_TO_ADDR
// end ;
73133: LD_VAR 0 5
73137: RET
// export function DangerAtRange ( unit , range ) ; begin
73138: LD_INT 0
73140: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73141: LD_ADDR_VAR 0 3
73145: PUSH
73146: LD_VAR 0 1
73150: PPUSH
73151: CALL_OW 255
73155: PPUSH
73156: LD_VAR 0 1
73160: PPUSH
73161: CALL_OW 250
73165: PPUSH
73166: LD_VAR 0 1
73170: PPUSH
73171: CALL_OW 251
73175: PPUSH
73176: LD_VAR 0 2
73180: PPUSH
73181: CALL 71435 0 4
73185: ST_TO_ADDR
// end ;
73186: LD_VAR 0 3
73190: RET
// export function DangerInArea ( side , area ) ; begin
73191: LD_INT 0
73193: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73194: LD_ADDR_VAR 0 3
73198: PUSH
73199: LD_VAR 0 2
73203: PPUSH
73204: LD_INT 81
73206: PUSH
73207: LD_VAR 0 1
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PPUSH
73216: CALL_OW 70
73220: ST_TO_ADDR
// end ;
73221: LD_VAR 0 3
73225: RET
// export function IsExtension ( b ) ; begin
73226: LD_INT 0
73228: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73229: LD_ADDR_VAR 0 2
73233: PUSH
73234: LD_VAR 0 1
73238: PUSH
73239: LD_INT 23
73241: PUSH
73242: LD_INT 20
73244: PUSH
73245: LD_INT 22
73247: PUSH
73248: LD_INT 17
73250: PUSH
73251: LD_INT 24
73253: PUSH
73254: LD_INT 21
73256: PUSH
73257: LD_INT 19
73259: PUSH
73260: LD_INT 16
73262: PUSH
73263: LD_INT 25
73265: PUSH
73266: LD_INT 18
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: IN
73281: ST_TO_ADDR
// end ;
73282: LD_VAR 0 2
73286: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73287: LD_INT 0
73289: PPUSH
73290: PPUSH
73291: PPUSH
// result := [ ] ;
73292: LD_ADDR_VAR 0 4
73296: PUSH
73297: EMPTY
73298: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73299: LD_ADDR_VAR 0 5
73303: PUSH
73304: LD_VAR 0 2
73308: PPUSH
73309: LD_INT 21
73311: PUSH
73312: LD_INT 3
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PPUSH
73319: CALL_OW 70
73323: ST_TO_ADDR
// if not tmp then
73324: LD_VAR 0 5
73328: NOT
73329: IFFALSE 73333
// exit ;
73331: GO 73397
// if checkLink then
73333: LD_VAR 0 3
73337: IFFALSE 73387
// begin for i in tmp do
73339: LD_ADDR_VAR 0 6
73343: PUSH
73344: LD_VAR 0 5
73348: PUSH
73349: FOR_IN
73350: IFFALSE 73385
// if GetBase ( i ) <> base then
73352: LD_VAR 0 6
73356: PPUSH
73357: CALL_OW 274
73361: PUSH
73362: LD_VAR 0 1
73366: NONEQUAL
73367: IFFALSE 73383
// ComLinkToBase ( base , i ) ;
73369: LD_VAR 0 1
73373: PPUSH
73374: LD_VAR 0 6
73378: PPUSH
73379: CALL_OW 169
73383: GO 73349
73385: POP
73386: POP
// end ; result := tmp ;
73387: LD_ADDR_VAR 0 4
73391: PUSH
73392: LD_VAR 0 5
73396: ST_TO_ADDR
// end ;
73397: LD_VAR 0 4
73401: RET
// export function ComComplete ( units , b ) ; var i ; begin
73402: LD_INT 0
73404: PPUSH
73405: PPUSH
// if not units then
73406: LD_VAR 0 1
73410: NOT
73411: IFFALSE 73415
// exit ;
73413: GO 73505
// for i in units do
73415: LD_ADDR_VAR 0 4
73419: PUSH
73420: LD_VAR 0 1
73424: PUSH
73425: FOR_IN
73426: IFFALSE 73503
// if BuildingStatus ( b ) = bs_build then
73428: LD_VAR 0 2
73432: PPUSH
73433: CALL_OW 461
73437: PUSH
73438: LD_INT 1
73440: EQUAL
73441: IFFALSE 73501
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73443: LD_VAR 0 4
73447: PPUSH
73448: LD_STRING h
73450: PUSH
73451: LD_VAR 0 2
73455: PPUSH
73456: CALL_OW 250
73460: PUSH
73461: LD_VAR 0 2
73465: PPUSH
73466: CALL_OW 251
73470: PUSH
73471: LD_VAR 0 2
73475: PUSH
73476: LD_INT 0
73478: PUSH
73479: LD_INT 0
73481: PUSH
73482: LD_INT 0
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: LIST
73489: LIST
73490: LIST
73491: LIST
73492: LIST
73493: PUSH
73494: EMPTY
73495: LIST
73496: PPUSH
73497: CALL_OW 446
73501: GO 73425
73503: POP
73504: POP
// end ;
73505: LD_VAR 0 3
73509: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73510: LD_INT 0
73512: PPUSH
73513: PPUSH
73514: PPUSH
73515: PPUSH
73516: PPUSH
73517: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73518: LD_VAR 0 1
73522: NOT
73523: PUSH
73524: LD_VAR 0 1
73528: PPUSH
73529: CALL_OW 263
73533: PUSH
73534: LD_INT 2
73536: EQUAL
73537: NOT
73538: OR
73539: IFFALSE 73543
// exit ;
73541: GO 73859
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73543: LD_ADDR_VAR 0 6
73547: PUSH
73548: LD_INT 22
73550: PUSH
73551: LD_VAR 0 1
73555: PPUSH
73556: CALL_OW 255
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 2
73567: PUSH
73568: LD_INT 30
73570: PUSH
73571: LD_INT 36
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 34
73580: PUSH
73581: LD_INT 31
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PPUSH
73597: CALL_OW 69
73601: ST_TO_ADDR
// if not tmp then
73602: LD_VAR 0 6
73606: NOT
73607: IFFALSE 73611
// exit ;
73609: GO 73859
// result := [ ] ;
73611: LD_ADDR_VAR 0 2
73615: PUSH
73616: EMPTY
73617: ST_TO_ADDR
// for i in tmp do
73618: LD_ADDR_VAR 0 3
73622: PUSH
73623: LD_VAR 0 6
73627: PUSH
73628: FOR_IN
73629: IFFALSE 73700
// begin t := UnitsInside ( i ) ;
73631: LD_ADDR_VAR 0 4
73635: PUSH
73636: LD_VAR 0 3
73640: PPUSH
73641: CALL_OW 313
73645: ST_TO_ADDR
// if t then
73646: LD_VAR 0 4
73650: IFFALSE 73698
// for j in t do
73652: LD_ADDR_VAR 0 7
73656: PUSH
73657: LD_VAR 0 4
73661: PUSH
73662: FOR_IN
73663: IFFALSE 73696
// result := Insert ( result , result + 1 , j ) ;
73665: LD_ADDR_VAR 0 2
73669: PUSH
73670: LD_VAR 0 2
73674: PPUSH
73675: LD_VAR 0 2
73679: PUSH
73680: LD_INT 1
73682: PLUS
73683: PPUSH
73684: LD_VAR 0 7
73688: PPUSH
73689: CALL_OW 2
73693: ST_TO_ADDR
73694: GO 73662
73696: POP
73697: POP
// end ;
73698: GO 73628
73700: POP
73701: POP
// if not result then
73702: LD_VAR 0 2
73706: NOT
73707: IFFALSE 73711
// exit ;
73709: GO 73859
// mech := result [ 1 ] ;
73711: LD_ADDR_VAR 0 5
73715: PUSH
73716: LD_VAR 0 2
73720: PUSH
73721: LD_INT 1
73723: ARRAY
73724: ST_TO_ADDR
// if result > 1 then
73725: LD_VAR 0 2
73729: PUSH
73730: LD_INT 1
73732: GREATER
73733: IFFALSE 73845
// for i = 2 to result do
73735: LD_ADDR_VAR 0 3
73739: PUSH
73740: DOUBLE
73741: LD_INT 2
73743: DEC
73744: ST_TO_ADDR
73745: LD_VAR 0 2
73749: PUSH
73750: FOR_TO
73751: IFFALSE 73843
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73753: LD_ADDR_VAR 0 4
73757: PUSH
73758: LD_VAR 0 2
73762: PUSH
73763: LD_VAR 0 3
73767: ARRAY
73768: PPUSH
73769: LD_INT 3
73771: PPUSH
73772: CALL_OW 259
73776: PUSH
73777: LD_VAR 0 2
73781: PUSH
73782: LD_VAR 0 3
73786: ARRAY
73787: PPUSH
73788: CALL_OW 432
73792: MINUS
73793: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73794: LD_VAR 0 4
73798: PUSH
73799: LD_VAR 0 5
73803: PPUSH
73804: LD_INT 3
73806: PPUSH
73807: CALL_OW 259
73811: PUSH
73812: LD_VAR 0 5
73816: PPUSH
73817: CALL_OW 432
73821: MINUS
73822: GREATEREQUAL
73823: IFFALSE 73841
// mech := result [ i ] ;
73825: LD_ADDR_VAR 0 5
73829: PUSH
73830: LD_VAR 0 2
73834: PUSH
73835: LD_VAR 0 3
73839: ARRAY
73840: ST_TO_ADDR
// end ;
73841: GO 73750
73843: POP
73844: POP
// ComLinkTo ( vehicle , mech ) ;
73845: LD_VAR 0 1
73849: PPUSH
73850: LD_VAR 0 5
73854: PPUSH
73855: CALL_OW 135
// end ;
73859: LD_VAR 0 2
73863: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73864: LD_INT 0
73866: PPUSH
73867: PPUSH
73868: PPUSH
73869: PPUSH
73870: PPUSH
73871: PPUSH
73872: PPUSH
73873: PPUSH
73874: PPUSH
73875: PPUSH
73876: PPUSH
73877: PPUSH
73878: PPUSH
// result := [ ] ;
73879: LD_ADDR_VAR 0 7
73883: PUSH
73884: EMPTY
73885: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73886: LD_VAR 0 1
73890: PPUSH
73891: CALL_OW 266
73895: PUSH
73896: LD_INT 0
73898: PUSH
73899: LD_INT 1
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: IN
73906: NOT
73907: IFFALSE 73911
// exit ;
73909: GO 75545
// if name then
73911: LD_VAR 0 3
73915: IFFALSE 73931
// SetBName ( base_dep , name ) ;
73917: LD_VAR 0 1
73921: PPUSH
73922: LD_VAR 0 3
73926: PPUSH
73927: CALL_OW 500
// base := GetBase ( base_dep ) ;
73931: LD_ADDR_VAR 0 15
73935: PUSH
73936: LD_VAR 0 1
73940: PPUSH
73941: CALL_OW 274
73945: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73946: LD_ADDR_VAR 0 16
73950: PUSH
73951: LD_VAR 0 1
73955: PPUSH
73956: CALL_OW 255
73960: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73961: LD_ADDR_VAR 0 17
73965: PUSH
73966: LD_VAR 0 1
73970: PPUSH
73971: CALL_OW 248
73975: ST_TO_ADDR
// if sources then
73976: LD_VAR 0 5
73980: IFFALSE 74027
// for i = 1 to 3 do
73982: LD_ADDR_VAR 0 8
73986: PUSH
73987: DOUBLE
73988: LD_INT 1
73990: DEC
73991: ST_TO_ADDR
73992: LD_INT 3
73994: PUSH
73995: FOR_TO
73996: IFFALSE 74025
// AddResourceType ( base , i , sources [ i ] ) ;
73998: LD_VAR 0 15
74002: PPUSH
74003: LD_VAR 0 8
74007: PPUSH
74008: LD_VAR 0 5
74012: PUSH
74013: LD_VAR 0 8
74017: ARRAY
74018: PPUSH
74019: CALL_OW 276
74023: GO 73995
74025: POP
74026: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74027: LD_ADDR_VAR 0 18
74031: PUSH
74032: LD_VAR 0 15
74036: PPUSH
74037: LD_VAR 0 2
74041: PPUSH
74042: LD_INT 1
74044: PPUSH
74045: CALL 73287 0 3
74049: ST_TO_ADDR
// InitHc ;
74050: CALL_OW 19
// InitUc ;
74054: CALL_OW 18
// uc_side := side ;
74058: LD_ADDR_OWVAR 20
74062: PUSH
74063: LD_VAR 0 16
74067: ST_TO_ADDR
// uc_nation := nation ;
74068: LD_ADDR_OWVAR 21
74072: PUSH
74073: LD_VAR 0 17
74077: ST_TO_ADDR
// if buildings then
74078: LD_VAR 0 18
74082: IFFALSE 75404
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74084: LD_ADDR_VAR 0 19
74088: PUSH
74089: LD_VAR 0 18
74093: PPUSH
74094: LD_INT 2
74096: PUSH
74097: LD_INT 30
74099: PUSH
74100: LD_INT 29
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 30
74109: PUSH
74110: LD_INT 30
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: LIST
74121: PPUSH
74122: CALL_OW 72
74126: ST_TO_ADDR
// if tmp then
74127: LD_VAR 0 19
74131: IFFALSE 74179
// for i in tmp do
74133: LD_ADDR_VAR 0 8
74137: PUSH
74138: LD_VAR 0 19
74142: PUSH
74143: FOR_IN
74144: IFFALSE 74177
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74146: LD_VAR 0 8
74150: PPUSH
74151: CALL_OW 250
74155: PPUSH
74156: LD_VAR 0 8
74160: PPUSH
74161: CALL_OW 251
74165: PPUSH
74166: LD_VAR 0 16
74170: PPUSH
74171: CALL_OW 441
74175: GO 74143
74177: POP
74178: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74179: LD_VAR 0 18
74183: PPUSH
74184: LD_INT 2
74186: PUSH
74187: LD_INT 30
74189: PUSH
74190: LD_INT 32
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 30
74199: PUSH
74200: LD_INT 33
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: LIST
74211: PPUSH
74212: CALL_OW 72
74216: IFFALSE 74304
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74218: LD_ADDR_VAR 0 8
74222: PUSH
74223: LD_VAR 0 18
74227: PPUSH
74228: LD_INT 2
74230: PUSH
74231: LD_INT 30
74233: PUSH
74234: LD_INT 32
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 30
74243: PUSH
74244: LD_INT 33
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: LIST
74255: PPUSH
74256: CALL_OW 72
74260: PUSH
74261: FOR_IN
74262: IFFALSE 74302
// begin if not GetBWeapon ( i ) then
74264: LD_VAR 0 8
74268: PPUSH
74269: CALL_OW 269
74273: NOT
74274: IFFALSE 74300
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74276: LD_VAR 0 8
74280: PPUSH
74281: LD_VAR 0 8
74285: PPUSH
74286: LD_VAR 0 2
74290: PPUSH
74291: CALL 75550 0 2
74295: PPUSH
74296: CALL_OW 431
// end ;
74300: GO 74261
74302: POP
74303: POP
// end ; for i = 1 to personel do
74304: LD_ADDR_VAR 0 8
74308: PUSH
74309: DOUBLE
74310: LD_INT 1
74312: DEC
74313: ST_TO_ADDR
74314: LD_VAR 0 6
74318: PUSH
74319: FOR_TO
74320: IFFALSE 75384
// begin if i > 4 then
74322: LD_VAR 0 8
74326: PUSH
74327: LD_INT 4
74329: GREATER
74330: IFFALSE 74334
// break ;
74332: GO 75384
// case i of 1 :
74334: LD_VAR 0 8
74338: PUSH
74339: LD_INT 1
74341: DOUBLE
74342: EQUAL
74343: IFTRUE 74347
74345: GO 74427
74347: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74348: LD_ADDR_VAR 0 12
74352: PUSH
74353: LD_VAR 0 18
74357: PPUSH
74358: LD_INT 22
74360: PUSH
74361: LD_VAR 0 16
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: PUSH
74370: LD_INT 58
74372: PUSH
74373: EMPTY
74374: LIST
74375: PUSH
74376: LD_INT 2
74378: PUSH
74379: LD_INT 30
74381: PUSH
74382: LD_INT 32
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 30
74391: PUSH
74392: LD_INT 4
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: LD_INT 30
74401: PUSH
74402: LD_INT 5
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: LIST
74419: PPUSH
74420: CALL_OW 72
74424: ST_TO_ADDR
74425: GO 74649
74427: LD_INT 2
74429: DOUBLE
74430: EQUAL
74431: IFTRUE 74435
74433: GO 74497
74435: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74436: LD_ADDR_VAR 0 12
74440: PUSH
74441: LD_VAR 0 18
74445: PPUSH
74446: LD_INT 22
74448: PUSH
74449: LD_VAR 0 16
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 2
74460: PUSH
74461: LD_INT 30
74463: PUSH
74464: LD_INT 0
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: LD_INT 30
74473: PUSH
74474: LD_INT 1
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: LIST
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: PPUSH
74490: CALL_OW 72
74494: ST_TO_ADDR
74495: GO 74649
74497: LD_INT 3
74499: DOUBLE
74500: EQUAL
74501: IFTRUE 74505
74503: GO 74567
74505: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74506: LD_ADDR_VAR 0 12
74510: PUSH
74511: LD_VAR 0 18
74515: PPUSH
74516: LD_INT 22
74518: PUSH
74519: LD_VAR 0 16
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 2
74530: PUSH
74531: LD_INT 30
74533: PUSH
74534: LD_INT 2
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: PUSH
74541: LD_INT 30
74543: PUSH
74544: LD_INT 3
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: EMPTY
74552: LIST
74553: LIST
74554: LIST
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PPUSH
74560: CALL_OW 72
74564: ST_TO_ADDR
74565: GO 74649
74567: LD_INT 4
74569: DOUBLE
74570: EQUAL
74571: IFTRUE 74575
74573: GO 74648
74575: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74576: LD_ADDR_VAR 0 12
74580: PUSH
74581: LD_VAR 0 18
74585: PPUSH
74586: LD_INT 22
74588: PUSH
74589: LD_VAR 0 16
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 2
74600: PUSH
74601: LD_INT 30
74603: PUSH
74604: LD_INT 6
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 30
74613: PUSH
74614: LD_INT 7
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 30
74623: PUSH
74624: LD_INT 8
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PPUSH
74641: CALL_OW 72
74645: ST_TO_ADDR
74646: GO 74649
74648: POP
// if i = 1 then
74649: LD_VAR 0 8
74653: PUSH
74654: LD_INT 1
74656: EQUAL
74657: IFFALSE 74768
// begin tmp := [ ] ;
74659: LD_ADDR_VAR 0 19
74663: PUSH
74664: EMPTY
74665: ST_TO_ADDR
// for j in f do
74666: LD_ADDR_VAR 0 9
74670: PUSH
74671: LD_VAR 0 12
74675: PUSH
74676: FOR_IN
74677: IFFALSE 74750
// if GetBType ( j ) = b_bunker then
74679: LD_VAR 0 9
74683: PPUSH
74684: CALL_OW 266
74688: PUSH
74689: LD_INT 32
74691: EQUAL
74692: IFFALSE 74719
// tmp := Insert ( tmp , 1 , j ) else
74694: LD_ADDR_VAR 0 19
74698: PUSH
74699: LD_VAR 0 19
74703: PPUSH
74704: LD_INT 1
74706: PPUSH
74707: LD_VAR 0 9
74711: PPUSH
74712: CALL_OW 2
74716: ST_TO_ADDR
74717: GO 74748
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74719: LD_ADDR_VAR 0 19
74723: PUSH
74724: LD_VAR 0 19
74728: PPUSH
74729: LD_VAR 0 19
74733: PUSH
74734: LD_INT 1
74736: PLUS
74737: PPUSH
74738: LD_VAR 0 9
74742: PPUSH
74743: CALL_OW 2
74747: ST_TO_ADDR
74748: GO 74676
74750: POP
74751: POP
// if tmp then
74752: LD_VAR 0 19
74756: IFFALSE 74768
// f := tmp ;
74758: LD_ADDR_VAR 0 12
74762: PUSH
74763: LD_VAR 0 19
74767: ST_TO_ADDR
// end ; x := personel [ i ] ;
74768: LD_ADDR_VAR 0 13
74772: PUSH
74773: LD_VAR 0 6
74777: PUSH
74778: LD_VAR 0 8
74782: ARRAY
74783: ST_TO_ADDR
// if x = - 1 then
74784: LD_VAR 0 13
74788: PUSH
74789: LD_INT 1
74791: NEG
74792: EQUAL
74793: IFFALSE 75002
// begin for j in f do
74795: LD_ADDR_VAR 0 9
74799: PUSH
74800: LD_VAR 0 12
74804: PUSH
74805: FOR_IN
74806: IFFALSE 74998
// repeat InitHc ;
74808: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74812: LD_VAR 0 9
74816: PPUSH
74817: CALL_OW 266
74821: PUSH
74822: LD_INT 5
74824: EQUAL
74825: IFFALSE 74895
// begin if UnitsInside ( j ) < 3 then
74827: LD_VAR 0 9
74831: PPUSH
74832: CALL_OW 313
74836: PUSH
74837: LD_INT 3
74839: LESS
74840: IFFALSE 74876
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74842: LD_INT 0
74844: PPUSH
74845: LD_INT 5
74847: PUSH
74848: LD_INT 8
74850: PUSH
74851: LD_INT 9
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: LIST
74858: PUSH
74859: LD_VAR 0 17
74863: ARRAY
74864: PPUSH
74865: LD_VAR 0 4
74869: PPUSH
74870: CALL_OW 380
74874: GO 74893
// PrepareHuman ( false , i , skill ) ;
74876: LD_INT 0
74878: PPUSH
74879: LD_VAR 0 8
74883: PPUSH
74884: LD_VAR 0 4
74888: PPUSH
74889: CALL_OW 380
// end else
74893: GO 74912
// PrepareHuman ( false , i , skill ) ;
74895: LD_INT 0
74897: PPUSH
74898: LD_VAR 0 8
74902: PPUSH
74903: LD_VAR 0 4
74907: PPUSH
74908: CALL_OW 380
// un := CreateHuman ;
74912: LD_ADDR_VAR 0 14
74916: PUSH
74917: CALL_OW 44
74921: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74922: LD_ADDR_VAR 0 7
74926: PUSH
74927: LD_VAR 0 7
74931: PPUSH
74932: LD_INT 1
74934: PPUSH
74935: LD_VAR 0 14
74939: PPUSH
74940: CALL_OW 2
74944: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74945: LD_VAR 0 14
74949: PPUSH
74950: LD_VAR 0 9
74954: PPUSH
74955: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74959: LD_VAR 0 9
74963: PPUSH
74964: CALL_OW 313
74968: PUSH
74969: LD_INT 6
74971: EQUAL
74972: PUSH
74973: LD_VAR 0 9
74977: PPUSH
74978: CALL_OW 266
74982: PUSH
74983: LD_INT 32
74985: PUSH
74986: LD_INT 31
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: IN
74993: OR
74994: IFFALSE 74808
74996: GO 74805
74998: POP
74999: POP
// end else
75000: GO 75382
// for j = 1 to x do
75002: LD_ADDR_VAR 0 9
75006: PUSH
75007: DOUBLE
75008: LD_INT 1
75010: DEC
75011: ST_TO_ADDR
75012: LD_VAR 0 13
75016: PUSH
75017: FOR_TO
75018: IFFALSE 75380
// begin InitHc ;
75020: CALL_OW 19
// if not f then
75024: LD_VAR 0 12
75028: NOT
75029: IFFALSE 75118
// begin PrepareHuman ( false , i , skill ) ;
75031: LD_INT 0
75033: PPUSH
75034: LD_VAR 0 8
75038: PPUSH
75039: LD_VAR 0 4
75043: PPUSH
75044: CALL_OW 380
// un := CreateHuman ;
75048: LD_ADDR_VAR 0 14
75052: PUSH
75053: CALL_OW 44
75057: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75058: LD_ADDR_VAR 0 7
75062: PUSH
75063: LD_VAR 0 7
75067: PPUSH
75068: LD_INT 1
75070: PPUSH
75071: LD_VAR 0 14
75075: PPUSH
75076: CALL_OW 2
75080: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75081: LD_VAR 0 14
75085: PPUSH
75086: LD_VAR 0 1
75090: PPUSH
75091: CALL_OW 250
75095: PPUSH
75096: LD_VAR 0 1
75100: PPUSH
75101: CALL_OW 251
75105: PPUSH
75106: LD_INT 10
75108: PPUSH
75109: LD_INT 0
75111: PPUSH
75112: CALL_OW 50
// continue ;
75116: GO 75017
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75118: LD_VAR 0 12
75122: PUSH
75123: LD_INT 1
75125: ARRAY
75126: PPUSH
75127: CALL_OW 313
75131: PUSH
75132: LD_VAR 0 12
75136: PUSH
75137: LD_INT 1
75139: ARRAY
75140: PPUSH
75141: CALL_OW 266
75145: PUSH
75146: LD_INT 32
75148: PUSH
75149: LD_INT 31
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: IN
75156: AND
75157: PUSH
75158: LD_VAR 0 12
75162: PUSH
75163: LD_INT 1
75165: ARRAY
75166: PPUSH
75167: CALL_OW 313
75171: PUSH
75172: LD_INT 6
75174: EQUAL
75175: OR
75176: IFFALSE 75196
// f := Delete ( f , 1 ) ;
75178: LD_ADDR_VAR 0 12
75182: PUSH
75183: LD_VAR 0 12
75187: PPUSH
75188: LD_INT 1
75190: PPUSH
75191: CALL_OW 3
75195: ST_TO_ADDR
// if not f then
75196: LD_VAR 0 12
75200: NOT
75201: IFFALSE 75219
// begin x := x + 2 ;
75203: LD_ADDR_VAR 0 13
75207: PUSH
75208: LD_VAR 0 13
75212: PUSH
75213: LD_INT 2
75215: PLUS
75216: ST_TO_ADDR
// continue ;
75217: GO 75017
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75219: LD_VAR 0 12
75223: PUSH
75224: LD_INT 1
75226: ARRAY
75227: PPUSH
75228: CALL_OW 266
75232: PUSH
75233: LD_INT 5
75235: EQUAL
75236: IFFALSE 75310
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75238: LD_VAR 0 12
75242: PUSH
75243: LD_INT 1
75245: ARRAY
75246: PPUSH
75247: CALL_OW 313
75251: PUSH
75252: LD_INT 3
75254: LESS
75255: IFFALSE 75291
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75257: LD_INT 0
75259: PPUSH
75260: LD_INT 5
75262: PUSH
75263: LD_INT 8
75265: PUSH
75266: LD_INT 9
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: LIST
75273: PUSH
75274: LD_VAR 0 17
75278: ARRAY
75279: PPUSH
75280: LD_VAR 0 4
75284: PPUSH
75285: CALL_OW 380
75289: GO 75308
// PrepareHuman ( false , i , skill ) ;
75291: LD_INT 0
75293: PPUSH
75294: LD_VAR 0 8
75298: PPUSH
75299: LD_VAR 0 4
75303: PPUSH
75304: CALL_OW 380
// end else
75308: GO 75327
// PrepareHuman ( false , i , skill ) ;
75310: LD_INT 0
75312: PPUSH
75313: LD_VAR 0 8
75317: PPUSH
75318: LD_VAR 0 4
75322: PPUSH
75323: CALL_OW 380
// un := CreateHuman ;
75327: LD_ADDR_VAR 0 14
75331: PUSH
75332: CALL_OW 44
75336: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75337: LD_ADDR_VAR 0 7
75341: PUSH
75342: LD_VAR 0 7
75346: PPUSH
75347: LD_INT 1
75349: PPUSH
75350: LD_VAR 0 14
75354: PPUSH
75355: CALL_OW 2
75359: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75360: LD_VAR 0 14
75364: PPUSH
75365: LD_VAR 0 12
75369: PUSH
75370: LD_INT 1
75372: ARRAY
75373: PPUSH
75374: CALL_OW 52
// end ;
75378: GO 75017
75380: POP
75381: POP
// end ;
75382: GO 74319
75384: POP
75385: POP
// result := result ^ buildings ;
75386: LD_ADDR_VAR 0 7
75390: PUSH
75391: LD_VAR 0 7
75395: PUSH
75396: LD_VAR 0 18
75400: ADD
75401: ST_TO_ADDR
// end else
75402: GO 75545
// begin for i = 1 to personel do
75404: LD_ADDR_VAR 0 8
75408: PUSH
75409: DOUBLE
75410: LD_INT 1
75412: DEC
75413: ST_TO_ADDR
75414: LD_VAR 0 6
75418: PUSH
75419: FOR_TO
75420: IFFALSE 75543
// begin if i > 4 then
75422: LD_VAR 0 8
75426: PUSH
75427: LD_INT 4
75429: GREATER
75430: IFFALSE 75434
// break ;
75432: GO 75543
// x := personel [ i ] ;
75434: LD_ADDR_VAR 0 13
75438: PUSH
75439: LD_VAR 0 6
75443: PUSH
75444: LD_VAR 0 8
75448: ARRAY
75449: ST_TO_ADDR
// if x = - 1 then
75450: LD_VAR 0 13
75454: PUSH
75455: LD_INT 1
75457: NEG
75458: EQUAL
75459: IFFALSE 75463
// continue ;
75461: GO 75419
// PrepareHuman ( false , i , skill ) ;
75463: LD_INT 0
75465: PPUSH
75466: LD_VAR 0 8
75470: PPUSH
75471: LD_VAR 0 4
75475: PPUSH
75476: CALL_OW 380
// un := CreateHuman ;
75480: LD_ADDR_VAR 0 14
75484: PUSH
75485: CALL_OW 44
75489: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75490: LD_VAR 0 14
75494: PPUSH
75495: LD_VAR 0 1
75499: PPUSH
75500: CALL_OW 250
75504: PPUSH
75505: LD_VAR 0 1
75509: PPUSH
75510: CALL_OW 251
75514: PPUSH
75515: LD_INT 10
75517: PPUSH
75518: LD_INT 0
75520: PPUSH
75521: CALL_OW 50
// result := result ^ un ;
75525: LD_ADDR_VAR 0 7
75529: PUSH
75530: LD_VAR 0 7
75534: PUSH
75535: LD_VAR 0 14
75539: ADD
75540: ST_TO_ADDR
// end ;
75541: GO 75419
75543: POP
75544: POP
// end ; end ;
75545: LD_VAR 0 7
75549: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75550: LD_INT 0
75552: PPUSH
75553: PPUSH
75554: PPUSH
75555: PPUSH
75556: PPUSH
75557: PPUSH
75558: PPUSH
75559: PPUSH
75560: PPUSH
75561: PPUSH
75562: PPUSH
75563: PPUSH
75564: PPUSH
75565: PPUSH
75566: PPUSH
75567: PPUSH
// result := false ;
75568: LD_ADDR_VAR 0 3
75572: PUSH
75573: LD_INT 0
75575: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75576: LD_VAR 0 1
75580: NOT
75581: PUSH
75582: LD_VAR 0 1
75586: PPUSH
75587: CALL_OW 266
75591: PUSH
75592: LD_INT 32
75594: PUSH
75595: LD_INT 33
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: IN
75602: NOT
75603: OR
75604: IFFALSE 75608
// exit ;
75606: GO 76717
// nat := GetNation ( tower ) ;
75608: LD_ADDR_VAR 0 12
75612: PUSH
75613: LD_VAR 0 1
75617: PPUSH
75618: CALL_OW 248
75622: ST_TO_ADDR
// side := GetSide ( tower ) ;
75623: LD_ADDR_VAR 0 16
75627: PUSH
75628: LD_VAR 0 1
75632: PPUSH
75633: CALL_OW 255
75637: ST_TO_ADDR
// x := GetX ( tower ) ;
75638: LD_ADDR_VAR 0 10
75642: PUSH
75643: LD_VAR 0 1
75647: PPUSH
75648: CALL_OW 250
75652: ST_TO_ADDR
// y := GetY ( tower ) ;
75653: LD_ADDR_VAR 0 11
75657: PUSH
75658: LD_VAR 0 1
75662: PPUSH
75663: CALL_OW 251
75667: ST_TO_ADDR
// if not x or not y then
75668: LD_VAR 0 10
75672: NOT
75673: PUSH
75674: LD_VAR 0 11
75678: NOT
75679: OR
75680: IFFALSE 75684
// exit ;
75682: GO 76717
// weapon := 0 ;
75684: LD_ADDR_VAR 0 18
75688: PUSH
75689: LD_INT 0
75691: ST_TO_ADDR
// fac_list := [ ] ;
75692: LD_ADDR_VAR 0 17
75696: PUSH
75697: EMPTY
75698: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
75699: LD_ADDR_VAR 0 6
75703: PUSH
75704: LD_VAR 0 1
75708: PPUSH
75709: CALL_OW 274
75713: PPUSH
75714: LD_VAR 0 2
75718: PPUSH
75719: LD_INT 0
75721: PPUSH
75722: CALL 73287 0 3
75726: PPUSH
75727: LD_INT 30
75729: PUSH
75730: LD_INT 3
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PPUSH
75737: CALL_OW 72
75741: ST_TO_ADDR
// if not factories then
75742: LD_VAR 0 6
75746: NOT
75747: IFFALSE 75751
// exit ;
75749: GO 76717
// for i in factories do
75751: LD_ADDR_VAR 0 8
75755: PUSH
75756: LD_VAR 0 6
75760: PUSH
75761: FOR_IN
75762: IFFALSE 75787
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75764: LD_ADDR_VAR 0 17
75768: PUSH
75769: LD_VAR 0 17
75773: PUSH
75774: LD_VAR 0 8
75778: PPUSH
75779: CALL_OW 478
75783: UNION
75784: ST_TO_ADDR
75785: GO 75761
75787: POP
75788: POP
// if not fac_list then
75789: LD_VAR 0 17
75793: NOT
75794: IFFALSE 75798
// exit ;
75796: GO 76717
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75798: LD_ADDR_VAR 0 5
75802: PUSH
75803: LD_INT 4
75805: PUSH
75806: LD_INT 5
75808: PUSH
75809: LD_INT 9
75811: PUSH
75812: LD_INT 10
75814: PUSH
75815: LD_INT 6
75817: PUSH
75818: LD_INT 7
75820: PUSH
75821: LD_INT 11
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: LIST
75832: PUSH
75833: LD_INT 27
75835: PUSH
75836: LD_INT 28
75838: PUSH
75839: LD_INT 26
75841: PUSH
75842: LD_INT 30
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 43
75853: PUSH
75854: LD_INT 44
75856: PUSH
75857: LD_INT 46
75859: PUSH
75860: LD_INT 45
75862: PUSH
75863: LD_INT 47
75865: PUSH
75866: LD_INT 49
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: PUSH
75877: EMPTY
75878: LIST
75879: LIST
75880: LIST
75881: PUSH
75882: LD_VAR 0 12
75886: ARRAY
75887: ST_TO_ADDR
// list := list isect fac_list ;
75888: LD_ADDR_VAR 0 5
75892: PUSH
75893: LD_VAR 0 5
75897: PUSH
75898: LD_VAR 0 17
75902: ISECT
75903: ST_TO_ADDR
// if not list then
75904: LD_VAR 0 5
75908: NOT
75909: IFFALSE 75913
// exit ;
75911: GO 76717
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75913: LD_VAR 0 12
75917: PUSH
75918: LD_INT 3
75920: EQUAL
75921: PUSH
75922: LD_INT 49
75924: PUSH
75925: LD_VAR 0 5
75929: IN
75930: AND
75931: PUSH
75932: LD_INT 31
75934: PPUSH
75935: LD_VAR 0 16
75939: PPUSH
75940: CALL_OW 321
75944: PUSH
75945: LD_INT 2
75947: EQUAL
75948: AND
75949: IFFALSE 76009
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75951: LD_INT 22
75953: PUSH
75954: LD_VAR 0 16
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 35
75965: PUSH
75966: LD_INT 49
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: LD_INT 91
75975: PUSH
75976: LD_VAR 0 1
75980: PUSH
75981: LD_INT 10
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: LIST
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: LIST
75993: PPUSH
75994: CALL_OW 69
75998: NOT
75999: IFFALSE 76009
// weapon := ru_time_lapser ;
76001: LD_ADDR_VAR 0 18
76005: PUSH
76006: LD_INT 49
76008: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76009: LD_VAR 0 12
76013: PUSH
76014: LD_INT 1
76016: PUSH
76017: LD_INT 2
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: IN
76024: PUSH
76025: LD_INT 11
76027: PUSH
76028: LD_VAR 0 5
76032: IN
76033: PUSH
76034: LD_INT 30
76036: PUSH
76037: LD_VAR 0 5
76041: IN
76042: OR
76043: AND
76044: PUSH
76045: LD_INT 6
76047: PPUSH
76048: LD_VAR 0 16
76052: PPUSH
76053: CALL_OW 321
76057: PUSH
76058: LD_INT 2
76060: EQUAL
76061: AND
76062: IFFALSE 76227
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76064: LD_INT 22
76066: PUSH
76067: LD_VAR 0 16
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 2
76078: PUSH
76079: LD_INT 35
76081: PUSH
76082: LD_INT 11
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: PUSH
76089: LD_INT 35
76091: PUSH
76092: LD_INT 30
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: LIST
76103: PUSH
76104: LD_INT 91
76106: PUSH
76107: LD_VAR 0 1
76111: PUSH
76112: LD_INT 18
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: LIST
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: LIST
76124: PPUSH
76125: CALL_OW 69
76129: NOT
76130: PUSH
76131: LD_INT 22
76133: PUSH
76134: LD_VAR 0 16
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 2
76145: PUSH
76146: LD_INT 30
76148: PUSH
76149: LD_INT 32
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 30
76158: PUSH
76159: LD_INT 33
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 91
76173: PUSH
76174: LD_VAR 0 1
76178: PUSH
76179: LD_INT 12
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: LIST
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: LIST
76191: PUSH
76192: EMPTY
76193: LIST
76194: PPUSH
76195: CALL_OW 69
76199: PUSH
76200: LD_INT 2
76202: GREATER
76203: AND
76204: IFFALSE 76227
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76206: LD_ADDR_VAR 0 18
76210: PUSH
76211: LD_INT 11
76213: PUSH
76214: LD_INT 30
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: LD_VAR 0 12
76225: ARRAY
76226: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76227: LD_VAR 0 18
76231: NOT
76232: PUSH
76233: LD_INT 40
76235: PPUSH
76236: LD_VAR 0 16
76240: PPUSH
76241: CALL_OW 321
76245: PUSH
76246: LD_INT 2
76248: EQUAL
76249: AND
76250: PUSH
76251: LD_INT 7
76253: PUSH
76254: LD_VAR 0 5
76258: IN
76259: PUSH
76260: LD_INT 28
76262: PUSH
76263: LD_VAR 0 5
76267: IN
76268: OR
76269: PUSH
76270: LD_INT 45
76272: PUSH
76273: LD_VAR 0 5
76277: IN
76278: OR
76279: AND
76280: IFFALSE 76534
// begin hex := GetHexInfo ( x , y ) ;
76282: LD_ADDR_VAR 0 4
76286: PUSH
76287: LD_VAR 0 10
76291: PPUSH
76292: LD_VAR 0 11
76296: PPUSH
76297: CALL_OW 546
76301: ST_TO_ADDR
// if hex [ 1 ] then
76302: LD_VAR 0 4
76306: PUSH
76307: LD_INT 1
76309: ARRAY
76310: IFFALSE 76314
// exit ;
76312: GO 76717
// height := hex [ 2 ] ;
76314: LD_ADDR_VAR 0 15
76318: PUSH
76319: LD_VAR 0 4
76323: PUSH
76324: LD_INT 2
76326: ARRAY
76327: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76328: LD_ADDR_VAR 0 14
76332: PUSH
76333: LD_INT 0
76335: PUSH
76336: LD_INT 2
76338: PUSH
76339: LD_INT 3
76341: PUSH
76342: LD_INT 5
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: LIST
76349: LIST
76350: ST_TO_ADDR
// for i in tmp do
76351: LD_ADDR_VAR 0 8
76355: PUSH
76356: LD_VAR 0 14
76360: PUSH
76361: FOR_IN
76362: IFFALSE 76532
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76364: LD_ADDR_VAR 0 9
76368: PUSH
76369: LD_VAR 0 10
76373: PPUSH
76374: LD_VAR 0 8
76378: PPUSH
76379: LD_INT 5
76381: PPUSH
76382: CALL_OW 272
76386: PUSH
76387: LD_VAR 0 11
76391: PPUSH
76392: LD_VAR 0 8
76396: PPUSH
76397: LD_INT 5
76399: PPUSH
76400: CALL_OW 273
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76409: LD_VAR 0 9
76413: PUSH
76414: LD_INT 1
76416: ARRAY
76417: PPUSH
76418: LD_VAR 0 9
76422: PUSH
76423: LD_INT 2
76425: ARRAY
76426: PPUSH
76427: CALL_OW 488
76431: IFFALSE 76530
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76433: LD_ADDR_VAR 0 4
76437: PUSH
76438: LD_VAR 0 9
76442: PUSH
76443: LD_INT 1
76445: ARRAY
76446: PPUSH
76447: LD_VAR 0 9
76451: PUSH
76452: LD_INT 2
76454: ARRAY
76455: PPUSH
76456: CALL_OW 546
76460: ST_TO_ADDR
// if hex [ 1 ] then
76461: LD_VAR 0 4
76465: PUSH
76466: LD_INT 1
76468: ARRAY
76469: IFFALSE 76473
// continue ;
76471: GO 76361
// h := hex [ 2 ] ;
76473: LD_ADDR_VAR 0 13
76477: PUSH
76478: LD_VAR 0 4
76482: PUSH
76483: LD_INT 2
76485: ARRAY
76486: ST_TO_ADDR
// if h + 7 < height then
76487: LD_VAR 0 13
76491: PUSH
76492: LD_INT 7
76494: PLUS
76495: PUSH
76496: LD_VAR 0 15
76500: LESS
76501: IFFALSE 76530
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76503: LD_ADDR_VAR 0 18
76507: PUSH
76508: LD_INT 7
76510: PUSH
76511: LD_INT 28
76513: PUSH
76514: LD_INT 45
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: LIST
76521: PUSH
76522: LD_VAR 0 12
76526: ARRAY
76527: ST_TO_ADDR
// break ;
76528: GO 76532
// end ; end ; end ;
76530: GO 76361
76532: POP
76533: POP
// end ; if not weapon then
76534: LD_VAR 0 18
76538: NOT
76539: IFFALSE 76599
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76541: LD_ADDR_VAR 0 5
76545: PUSH
76546: LD_VAR 0 5
76550: PUSH
76551: LD_INT 11
76553: PUSH
76554: LD_INT 30
76556: PUSH
76557: LD_INT 49
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: LIST
76564: DIFF
76565: ST_TO_ADDR
// if not list then
76566: LD_VAR 0 5
76570: NOT
76571: IFFALSE 76575
// exit ;
76573: GO 76717
// weapon := list [ rand ( 1 , list ) ] ;
76575: LD_ADDR_VAR 0 18
76579: PUSH
76580: LD_VAR 0 5
76584: PUSH
76585: LD_INT 1
76587: PPUSH
76588: LD_VAR 0 5
76592: PPUSH
76593: CALL_OW 12
76597: ARRAY
76598: ST_TO_ADDR
// end ; if weapon then
76599: LD_VAR 0 18
76603: IFFALSE 76717
// begin tmp := CostOfWeapon ( weapon ) ;
76605: LD_ADDR_VAR 0 14
76609: PUSH
76610: LD_VAR 0 18
76614: PPUSH
76615: CALL_OW 451
76619: ST_TO_ADDR
// j := GetBase ( tower ) ;
76620: LD_ADDR_VAR 0 9
76624: PUSH
76625: LD_VAR 0 1
76629: PPUSH
76630: CALL_OW 274
76634: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76635: LD_VAR 0 9
76639: PPUSH
76640: LD_INT 1
76642: PPUSH
76643: CALL_OW 275
76647: PUSH
76648: LD_VAR 0 14
76652: PUSH
76653: LD_INT 1
76655: ARRAY
76656: GREATEREQUAL
76657: PUSH
76658: LD_VAR 0 9
76662: PPUSH
76663: LD_INT 2
76665: PPUSH
76666: CALL_OW 275
76670: PUSH
76671: LD_VAR 0 14
76675: PUSH
76676: LD_INT 2
76678: ARRAY
76679: GREATEREQUAL
76680: AND
76681: PUSH
76682: LD_VAR 0 9
76686: PPUSH
76687: LD_INT 3
76689: PPUSH
76690: CALL_OW 275
76694: PUSH
76695: LD_VAR 0 14
76699: PUSH
76700: LD_INT 3
76702: ARRAY
76703: GREATEREQUAL
76704: AND
76705: IFFALSE 76717
// result := weapon ;
76707: LD_ADDR_VAR 0 3
76711: PUSH
76712: LD_VAR 0 18
76716: ST_TO_ADDR
// end ; end ;
76717: LD_VAR 0 3
76721: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76722: LD_INT 0
76724: PPUSH
76725: PPUSH
// result := true ;
76726: LD_ADDR_VAR 0 3
76730: PUSH
76731: LD_INT 1
76733: ST_TO_ADDR
// if array1 = array2 then
76734: LD_VAR 0 1
76738: PUSH
76739: LD_VAR 0 2
76743: EQUAL
76744: IFFALSE 76804
// begin for i = 1 to array1 do
76746: LD_ADDR_VAR 0 4
76750: PUSH
76751: DOUBLE
76752: LD_INT 1
76754: DEC
76755: ST_TO_ADDR
76756: LD_VAR 0 1
76760: PUSH
76761: FOR_TO
76762: IFFALSE 76800
// if array1 [ i ] <> array2 [ i ] then
76764: LD_VAR 0 1
76768: PUSH
76769: LD_VAR 0 4
76773: ARRAY
76774: PUSH
76775: LD_VAR 0 2
76779: PUSH
76780: LD_VAR 0 4
76784: ARRAY
76785: NONEQUAL
76786: IFFALSE 76798
// begin result := false ;
76788: LD_ADDR_VAR 0 3
76792: PUSH
76793: LD_INT 0
76795: ST_TO_ADDR
// break ;
76796: GO 76800
// end ;
76798: GO 76761
76800: POP
76801: POP
// end else
76802: GO 76812
// result := false ;
76804: LD_ADDR_VAR 0 3
76808: PUSH
76809: LD_INT 0
76811: ST_TO_ADDR
// end ;
76812: LD_VAR 0 3
76816: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
76817: LD_INT 0
76819: PPUSH
76820: PPUSH
// if not array1 or not array2 then
76821: LD_VAR 0 1
76825: NOT
76826: PUSH
76827: LD_VAR 0 2
76831: NOT
76832: OR
76833: IFFALSE 76837
// exit ;
76835: GO 76901
// result := true ;
76837: LD_ADDR_VAR 0 3
76841: PUSH
76842: LD_INT 1
76844: ST_TO_ADDR
// for i = 1 to array1 do
76845: LD_ADDR_VAR 0 4
76849: PUSH
76850: DOUBLE
76851: LD_INT 1
76853: DEC
76854: ST_TO_ADDR
76855: LD_VAR 0 1
76859: PUSH
76860: FOR_TO
76861: IFFALSE 76899
// if array1 [ i ] <> array2 [ i ] then
76863: LD_VAR 0 1
76867: PUSH
76868: LD_VAR 0 4
76872: ARRAY
76873: PUSH
76874: LD_VAR 0 2
76878: PUSH
76879: LD_VAR 0 4
76883: ARRAY
76884: NONEQUAL
76885: IFFALSE 76897
// begin result := false ;
76887: LD_ADDR_VAR 0 3
76891: PUSH
76892: LD_INT 0
76894: ST_TO_ADDR
// break ;
76895: GO 76899
// end ;
76897: GO 76860
76899: POP
76900: POP
// end ;
76901: LD_VAR 0 3
76905: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76906: LD_INT 0
76908: PPUSH
76909: PPUSH
76910: PPUSH
// pom := GetBase ( fac ) ;
76911: LD_ADDR_VAR 0 5
76915: PUSH
76916: LD_VAR 0 1
76920: PPUSH
76921: CALL_OW 274
76925: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76926: LD_ADDR_VAR 0 4
76930: PUSH
76931: LD_VAR 0 2
76935: PUSH
76936: LD_INT 1
76938: ARRAY
76939: PPUSH
76940: LD_VAR 0 2
76944: PUSH
76945: LD_INT 2
76947: ARRAY
76948: PPUSH
76949: LD_VAR 0 2
76953: PUSH
76954: LD_INT 3
76956: ARRAY
76957: PPUSH
76958: LD_VAR 0 2
76962: PUSH
76963: LD_INT 4
76965: ARRAY
76966: PPUSH
76967: CALL_OW 449
76971: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76972: LD_ADDR_VAR 0 3
76976: PUSH
76977: LD_VAR 0 5
76981: PPUSH
76982: LD_INT 1
76984: PPUSH
76985: CALL_OW 275
76989: PUSH
76990: LD_VAR 0 4
76994: PUSH
76995: LD_INT 1
76997: ARRAY
76998: GREATEREQUAL
76999: PUSH
77000: LD_VAR 0 5
77004: PPUSH
77005: LD_INT 2
77007: PPUSH
77008: CALL_OW 275
77012: PUSH
77013: LD_VAR 0 4
77017: PUSH
77018: LD_INT 2
77020: ARRAY
77021: GREATEREQUAL
77022: AND
77023: PUSH
77024: LD_VAR 0 5
77028: PPUSH
77029: LD_INT 3
77031: PPUSH
77032: CALL_OW 275
77036: PUSH
77037: LD_VAR 0 4
77041: PUSH
77042: LD_INT 3
77044: ARRAY
77045: GREATEREQUAL
77046: AND
77047: ST_TO_ADDR
// end ;
77048: LD_VAR 0 3
77052: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77053: LD_INT 0
77055: PPUSH
77056: PPUSH
77057: PPUSH
77058: PPUSH
// pom := GetBase ( building ) ;
77059: LD_ADDR_VAR 0 3
77063: PUSH
77064: LD_VAR 0 1
77068: PPUSH
77069: CALL_OW 274
77073: ST_TO_ADDR
// if not pom then
77074: LD_VAR 0 3
77078: NOT
77079: IFFALSE 77083
// exit ;
77081: GO 77253
// btype := GetBType ( building ) ;
77083: LD_ADDR_VAR 0 5
77087: PUSH
77088: LD_VAR 0 1
77092: PPUSH
77093: CALL_OW 266
77097: ST_TO_ADDR
// if btype = b_armoury then
77098: LD_VAR 0 5
77102: PUSH
77103: LD_INT 4
77105: EQUAL
77106: IFFALSE 77116
// btype := b_barracks ;
77108: LD_ADDR_VAR 0 5
77112: PUSH
77113: LD_INT 5
77115: ST_TO_ADDR
// if btype = b_depot then
77116: LD_VAR 0 5
77120: PUSH
77121: LD_INT 0
77123: EQUAL
77124: IFFALSE 77134
// btype := b_warehouse ;
77126: LD_ADDR_VAR 0 5
77130: PUSH
77131: LD_INT 1
77133: ST_TO_ADDR
// if btype = b_workshop then
77134: LD_VAR 0 5
77138: PUSH
77139: LD_INT 2
77141: EQUAL
77142: IFFALSE 77152
// btype := b_factory ;
77144: LD_ADDR_VAR 0 5
77148: PUSH
77149: LD_INT 3
77151: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77152: LD_ADDR_VAR 0 4
77156: PUSH
77157: LD_VAR 0 5
77161: PPUSH
77162: LD_VAR 0 1
77166: PPUSH
77167: CALL_OW 248
77171: PPUSH
77172: CALL_OW 450
77176: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77177: LD_ADDR_VAR 0 2
77181: PUSH
77182: LD_VAR 0 3
77186: PPUSH
77187: LD_INT 1
77189: PPUSH
77190: CALL_OW 275
77194: PUSH
77195: LD_VAR 0 4
77199: PUSH
77200: LD_INT 1
77202: ARRAY
77203: GREATEREQUAL
77204: PUSH
77205: LD_VAR 0 3
77209: PPUSH
77210: LD_INT 2
77212: PPUSH
77213: CALL_OW 275
77217: PUSH
77218: LD_VAR 0 4
77222: PUSH
77223: LD_INT 2
77225: ARRAY
77226: GREATEREQUAL
77227: AND
77228: PUSH
77229: LD_VAR 0 3
77233: PPUSH
77234: LD_INT 3
77236: PPUSH
77237: CALL_OW 275
77241: PUSH
77242: LD_VAR 0 4
77246: PUSH
77247: LD_INT 3
77249: ARRAY
77250: GREATEREQUAL
77251: AND
77252: ST_TO_ADDR
// end ;
77253: LD_VAR 0 2
77257: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77258: LD_INT 0
77260: PPUSH
77261: PPUSH
77262: PPUSH
// pom := GetBase ( building ) ;
77263: LD_ADDR_VAR 0 4
77267: PUSH
77268: LD_VAR 0 1
77272: PPUSH
77273: CALL_OW 274
77277: ST_TO_ADDR
// if not pom then
77278: LD_VAR 0 4
77282: NOT
77283: IFFALSE 77287
// exit ;
77285: GO 77388
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77287: LD_ADDR_VAR 0 5
77291: PUSH
77292: LD_VAR 0 2
77296: PPUSH
77297: LD_VAR 0 1
77301: PPUSH
77302: CALL_OW 248
77306: PPUSH
77307: CALL_OW 450
77311: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77312: LD_ADDR_VAR 0 3
77316: PUSH
77317: LD_VAR 0 4
77321: PPUSH
77322: LD_INT 1
77324: PPUSH
77325: CALL_OW 275
77329: PUSH
77330: LD_VAR 0 5
77334: PUSH
77335: LD_INT 1
77337: ARRAY
77338: GREATEREQUAL
77339: PUSH
77340: LD_VAR 0 4
77344: PPUSH
77345: LD_INT 2
77347: PPUSH
77348: CALL_OW 275
77352: PUSH
77353: LD_VAR 0 5
77357: PUSH
77358: LD_INT 2
77360: ARRAY
77361: GREATEREQUAL
77362: AND
77363: PUSH
77364: LD_VAR 0 4
77368: PPUSH
77369: LD_INT 3
77371: PPUSH
77372: CALL_OW 275
77376: PUSH
77377: LD_VAR 0 5
77381: PUSH
77382: LD_INT 3
77384: ARRAY
77385: GREATEREQUAL
77386: AND
77387: ST_TO_ADDR
// end ;
77388: LD_VAR 0 3
77392: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77393: LD_INT 0
77395: PPUSH
77396: PPUSH
77397: PPUSH
77398: PPUSH
77399: PPUSH
77400: PPUSH
77401: PPUSH
77402: PPUSH
77403: PPUSH
77404: PPUSH
77405: PPUSH
// result := false ;
77406: LD_ADDR_VAR 0 8
77410: PUSH
77411: LD_INT 0
77413: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77414: LD_VAR 0 5
77418: NOT
77419: PUSH
77420: LD_VAR 0 1
77424: NOT
77425: OR
77426: PUSH
77427: LD_VAR 0 2
77431: NOT
77432: OR
77433: PUSH
77434: LD_VAR 0 3
77438: NOT
77439: OR
77440: IFFALSE 77444
// exit ;
77442: GO 78258
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77444: LD_ADDR_VAR 0 14
77448: PUSH
77449: LD_VAR 0 1
77453: PPUSH
77454: LD_VAR 0 2
77458: PPUSH
77459: LD_VAR 0 3
77463: PPUSH
77464: LD_VAR 0 4
77468: PPUSH
77469: LD_VAR 0 5
77473: PUSH
77474: LD_INT 1
77476: ARRAY
77477: PPUSH
77478: CALL_OW 248
77482: PPUSH
77483: LD_INT 0
77485: PPUSH
77486: CALL 79495 0 6
77490: ST_TO_ADDR
// if not hexes then
77491: LD_VAR 0 14
77495: NOT
77496: IFFALSE 77500
// exit ;
77498: GO 78258
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77500: LD_ADDR_VAR 0 17
77504: PUSH
77505: LD_VAR 0 5
77509: PPUSH
77510: LD_INT 22
77512: PUSH
77513: LD_VAR 0 13
77517: PPUSH
77518: CALL_OW 255
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 2
77529: PUSH
77530: LD_INT 30
77532: PUSH
77533: LD_INT 0
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 30
77542: PUSH
77543: LD_INT 1
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: LIST
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PPUSH
77559: CALL_OW 72
77563: ST_TO_ADDR
// for i = 1 to hexes do
77564: LD_ADDR_VAR 0 9
77568: PUSH
77569: DOUBLE
77570: LD_INT 1
77572: DEC
77573: ST_TO_ADDR
77574: LD_VAR 0 14
77578: PUSH
77579: FOR_TO
77580: IFFALSE 78256
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77582: LD_ADDR_VAR 0 13
77586: PUSH
77587: LD_VAR 0 14
77591: PUSH
77592: LD_VAR 0 9
77596: ARRAY
77597: PUSH
77598: LD_INT 1
77600: ARRAY
77601: PPUSH
77602: LD_VAR 0 14
77606: PUSH
77607: LD_VAR 0 9
77611: ARRAY
77612: PUSH
77613: LD_INT 2
77615: ARRAY
77616: PPUSH
77617: CALL_OW 428
77621: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77622: LD_VAR 0 14
77626: PUSH
77627: LD_VAR 0 9
77631: ARRAY
77632: PUSH
77633: LD_INT 1
77635: ARRAY
77636: PPUSH
77637: LD_VAR 0 14
77641: PUSH
77642: LD_VAR 0 9
77646: ARRAY
77647: PUSH
77648: LD_INT 2
77650: ARRAY
77651: PPUSH
77652: CALL_OW 351
77656: PUSH
77657: LD_VAR 0 14
77661: PUSH
77662: LD_VAR 0 9
77666: ARRAY
77667: PUSH
77668: LD_INT 1
77670: ARRAY
77671: PPUSH
77672: LD_VAR 0 14
77676: PUSH
77677: LD_VAR 0 9
77681: ARRAY
77682: PUSH
77683: LD_INT 2
77685: ARRAY
77686: PPUSH
77687: CALL_OW 488
77691: NOT
77692: OR
77693: PUSH
77694: LD_VAR 0 13
77698: PPUSH
77699: CALL_OW 247
77703: PUSH
77704: LD_INT 3
77706: EQUAL
77707: OR
77708: IFFALSE 77714
// exit ;
77710: POP
77711: POP
77712: GO 78258
// if not tmp then
77714: LD_VAR 0 13
77718: NOT
77719: IFFALSE 77723
// continue ;
77721: GO 77579
// result := true ;
77723: LD_ADDR_VAR 0 8
77727: PUSH
77728: LD_INT 1
77730: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
77731: LD_VAR 0 6
77735: PUSH
77736: LD_VAR 0 13
77740: PPUSH
77741: CALL_OW 247
77745: PUSH
77746: LD_INT 2
77748: EQUAL
77749: AND
77750: PUSH
77751: LD_VAR 0 13
77755: PPUSH
77756: CALL_OW 263
77760: PUSH
77761: LD_INT 1
77763: EQUAL
77764: AND
77765: IFFALSE 77929
// begin if IsDrivenBy ( tmp ) then
77767: LD_VAR 0 13
77771: PPUSH
77772: CALL_OW 311
77776: IFFALSE 77780
// continue ;
77778: GO 77579
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
77780: LD_VAR 0 6
77784: PPUSH
77785: LD_INT 3
77787: PUSH
77788: LD_INT 60
77790: PUSH
77791: EMPTY
77792: LIST
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: LD_INT 3
77800: PUSH
77801: LD_INT 55
77803: PUSH
77804: EMPTY
77805: LIST
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PPUSH
77815: CALL_OW 72
77819: IFFALSE 77927
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
77821: LD_ADDR_VAR 0 18
77825: PUSH
77826: LD_VAR 0 6
77830: PPUSH
77831: LD_INT 3
77833: PUSH
77834: LD_INT 60
77836: PUSH
77837: EMPTY
77838: LIST
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 3
77846: PUSH
77847: LD_INT 55
77849: PUSH
77850: EMPTY
77851: LIST
77852: PUSH
77853: EMPTY
77854: LIST
77855: LIST
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PPUSH
77861: CALL_OW 72
77865: PUSH
77866: LD_INT 1
77868: ARRAY
77869: ST_TO_ADDR
// if IsInUnit ( driver ) then
77870: LD_VAR 0 18
77874: PPUSH
77875: CALL_OW 310
77879: IFFALSE 77890
// ComExit ( driver ) ;
77881: LD_VAR 0 18
77885: PPUSH
77886: CALL 102679 0 1
// AddComEnterUnit ( driver , tmp ) ;
77890: LD_VAR 0 18
77894: PPUSH
77895: LD_VAR 0 13
77899: PPUSH
77900: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
77904: LD_VAR 0 18
77908: PPUSH
77909: LD_VAR 0 7
77913: PPUSH
77914: CALL_OW 173
// AddComExitVehicle ( driver ) ;
77918: LD_VAR 0 18
77922: PPUSH
77923: CALL_OW 181
// end ; continue ;
77927: GO 77579
// end ; if not cleaners or not tmp in cleaners then
77929: LD_VAR 0 6
77933: NOT
77934: PUSH
77935: LD_VAR 0 13
77939: PUSH
77940: LD_VAR 0 6
77944: IN
77945: NOT
77946: OR
77947: IFFALSE 78254
// begin if dep then
77949: LD_VAR 0 17
77953: IFFALSE 78089
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77955: LD_ADDR_VAR 0 16
77959: PUSH
77960: LD_VAR 0 17
77964: PUSH
77965: LD_INT 1
77967: ARRAY
77968: PPUSH
77969: CALL_OW 250
77973: PPUSH
77974: LD_VAR 0 17
77978: PUSH
77979: LD_INT 1
77981: ARRAY
77982: PPUSH
77983: CALL_OW 254
77987: PPUSH
77988: LD_INT 5
77990: PPUSH
77991: CALL_OW 272
77995: PUSH
77996: LD_VAR 0 17
78000: PUSH
78001: LD_INT 1
78003: ARRAY
78004: PPUSH
78005: CALL_OW 251
78009: PPUSH
78010: LD_VAR 0 17
78014: PUSH
78015: LD_INT 1
78017: ARRAY
78018: PPUSH
78019: CALL_OW 254
78023: PPUSH
78024: LD_INT 5
78026: PPUSH
78027: CALL_OW 273
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78036: LD_VAR 0 16
78040: PUSH
78041: LD_INT 1
78043: ARRAY
78044: PPUSH
78045: LD_VAR 0 16
78049: PUSH
78050: LD_INT 2
78052: ARRAY
78053: PPUSH
78054: CALL_OW 488
78058: IFFALSE 78089
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78060: LD_VAR 0 13
78064: PPUSH
78065: LD_VAR 0 16
78069: PUSH
78070: LD_INT 1
78072: ARRAY
78073: PPUSH
78074: LD_VAR 0 16
78078: PUSH
78079: LD_INT 2
78081: ARRAY
78082: PPUSH
78083: CALL_OW 111
// continue ;
78087: GO 77579
// end ; end ; r := GetDir ( tmp ) ;
78089: LD_ADDR_VAR 0 15
78093: PUSH
78094: LD_VAR 0 13
78098: PPUSH
78099: CALL_OW 254
78103: ST_TO_ADDR
// if r = 5 then
78104: LD_VAR 0 15
78108: PUSH
78109: LD_INT 5
78111: EQUAL
78112: IFFALSE 78122
// r := 0 ;
78114: LD_ADDR_VAR 0 15
78118: PUSH
78119: LD_INT 0
78121: ST_TO_ADDR
// for j = r to 5 do
78122: LD_ADDR_VAR 0 10
78126: PUSH
78127: DOUBLE
78128: LD_VAR 0 15
78132: DEC
78133: ST_TO_ADDR
78134: LD_INT 5
78136: PUSH
78137: FOR_TO
78138: IFFALSE 78252
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78140: LD_ADDR_VAR 0 11
78144: PUSH
78145: LD_VAR 0 13
78149: PPUSH
78150: CALL_OW 250
78154: PPUSH
78155: LD_VAR 0 10
78159: PPUSH
78160: LD_INT 2
78162: PPUSH
78163: CALL_OW 272
78167: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78168: LD_ADDR_VAR 0 12
78172: PUSH
78173: LD_VAR 0 13
78177: PPUSH
78178: CALL_OW 251
78182: PPUSH
78183: LD_VAR 0 10
78187: PPUSH
78188: LD_INT 2
78190: PPUSH
78191: CALL_OW 273
78195: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78196: LD_VAR 0 11
78200: PPUSH
78201: LD_VAR 0 12
78205: PPUSH
78206: CALL_OW 488
78210: PUSH
78211: LD_VAR 0 11
78215: PPUSH
78216: LD_VAR 0 12
78220: PPUSH
78221: CALL_OW 428
78225: NOT
78226: AND
78227: IFFALSE 78250
// begin ComMoveXY ( tmp , _x , _y ) ;
78229: LD_VAR 0 13
78233: PPUSH
78234: LD_VAR 0 11
78238: PPUSH
78239: LD_VAR 0 12
78243: PPUSH
78244: CALL_OW 111
// break ;
78248: GO 78252
// end ; end ;
78250: GO 78137
78252: POP
78253: POP
// end ; end ;
78254: GO 77579
78256: POP
78257: POP
// end ;
78258: LD_VAR 0 8
78262: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78263: LD_INT 0
78265: PPUSH
// result := true ;
78266: LD_ADDR_VAR 0 3
78270: PUSH
78271: LD_INT 1
78273: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78274: LD_VAR 0 2
78278: PUSH
78279: LD_INT 24
78281: DOUBLE
78282: EQUAL
78283: IFTRUE 78293
78285: LD_INT 33
78287: DOUBLE
78288: EQUAL
78289: IFTRUE 78293
78291: GO 78318
78293: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78294: LD_ADDR_VAR 0 3
78298: PUSH
78299: LD_INT 32
78301: PPUSH
78302: LD_VAR 0 1
78306: PPUSH
78307: CALL_OW 321
78311: PUSH
78312: LD_INT 2
78314: EQUAL
78315: ST_TO_ADDR
78316: GO 78638
78318: LD_INT 20
78320: DOUBLE
78321: EQUAL
78322: IFTRUE 78326
78324: GO 78351
78326: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78327: LD_ADDR_VAR 0 3
78331: PUSH
78332: LD_INT 6
78334: PPUSH
78335: LD_VAR 0 1
78339: PPUSH
78340: CALL_OW 321
78344: PUSH
78345: LD_INT 2
78347: EQUAL
78348: ST_TO_ADDR
78349: GO 78638
78351: LD_INT 22
78353: DOUBLE
78354: EQUAL
78355: IFTRUE 78365
78357: LD_INT 36
78359: DOUBLE
78360: EQUAL
78361: IFTRUE 78365
78363: GO 78390
78365: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78366: LD_ADDR_VAR 0 3
78370: PUSH
78371: LD_INT 15
78373: PPUSH
78374: LD_VAR 0 1
78378: PPUSH
78379: CALL_OW 321
78383: PUSH
78384: LD_INT 2
78386: EQUAL
78387: ST_TO_ADDR
78388: GO 78638
78390: LD_INT 30
78392: DOUBLE
78393: EQUAL
78394: IFTRUE 78398
78396: GO 78423
78398: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78399: LD_ADDR_VAR 0 3
78403: PUSH
78404: LD_INT 20
78406: PPUSH
78407: LD_VAR 0 1
78411: PPUSH
78412: CALL_OW 321
78416: PUSH
78417: LD_INT 2
78419: EQUAL
78420: ST_TO_ADDR
78421: GO 78638
78423: LD_INT 28
78425: DOUBLE
78426: EQUAL
78427: IFTRUE 78437
78429: LD_INT 21
78431: DOUBLE
78432: EQUAL
78433: IFTRUE 78437
78435: GO 78462
78437: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78438: LD_ADDR_VAR 0 3
78442: PUSH
78443: LD_INT 21
78445: PPUSH
78446: LD_VAR 0 1
78450: PPUSH
78451: CALL_OW 321
78455: PUSH
78456: LD_INT 2
78458: EQUAL
78459: ST_TO_ADDR
78460: GO 78638
78462: LD_INT 16
78464: DOUBLE
78465: EQUAL
78466: IFTRUE 78470
78468: GO 78497
78470: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78471: LD_ADDR_VAR 0 3
78475: PUSH
78476: LD_EXP 107
78480: PPUSH
78481: LD_VAR 0 1
78485: PPUSH
78486: CALL_OW 321
78490: PUSH
78491: LD_INT 2
78493: EQUAL
78494: ST_TO_ADDR
78495: GO 78638
78497: LD_INT 19
78499: DOUBLE
78500: EQUAL
78501: IFTRUE 78511
78503: LD_INT 23
78505: DOUBLE
78506: EQUAL
78507: IFTRUE 78511
78509: GO 78538
78511: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78512: LD_ADDR_VAR 0 3
78516: PUSH
78517: LD_EXP 106
78521: PPUSH
78522: LD_VAR 0 1
78526: PPUSH
78527: CALL_OW 321
78531: PUSH
78532: LD_INT 2
78534: EQUAL
78535: ST_TO_ADDR
78536: GO 78638
78538: LD_INT 17
78540: DOUBLE
78541: EQUAL
78542: IFTRUE 78546
78544: GO 78571
78546: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78547: LD_ADDR_VAR 0 3
78551: PUSH
78552: LD_INT 39
78554: PPUSH
78555: LD_VAR 0 1
78559: PPUSH
78560: CALL_OW 321
78564: PUSH
78565: LD_INT 2
78567: EQUAL
78568: ST_TO_ADDR
78569: GO 78638
78571: LD_INT 18
78573: DOUBLE
78574: EQUAL
78575: IFTRUE 78579
78577: GO 78604
78579: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78580: LD_ADDR_VAR 0 3
78584: PUSH
78585: LD_INT 40
78587: PPUSH
78588: LD_VAR 0 1
78592: PPUSH
78593: CALL_OW 321
78597: PUSH
78598: LD_INT 2
78600: EQUAL
78601: ST_TO_ADDR
78602: GO 78638
78604: LD_INT 27
78606: DOUBLE
78607: EQUAL
78608: IFTRUE 78612
78610: GO 78637
78612: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78613: LD_ADDR_VAR 0 3
78617: PUSH
78618: LD_INT 35
78620: PPUSH
78621: LD_VAR 0 1
78625: PPUSH
78626: CALL_OW 321
78630: PUSH
78631: LD_INT 2
78633: EQUAL
78634: ST_TO_ADDR
78635: GO 78638
78637: POP
// end ;
78638: LD_VAR 0 3
78642: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
78643: LD_INT 0
78645: PPUSH
78646: PPUSH
78647: PPUSH
78648: PPUSH
78649: PPUSH
78650: PPUSH
78651: PPUSH
78652: PPUSH
78653: PPUSH
78654: PPUSH
78655: PPUSH
// result := false ;
78656: LD_ADDR_VAR 0 6
78660: PUSH
78661: LD_INT 0
78663: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78664: LD_VAR 0 1
78668: NOT
78669: PUSH
78670: LD_VAR 0 1
78674: PPUSH
78675: CALL_OW 266
78679: PUSH
78680: LD_INT 0
78682: PUSH
78683: LD_INT 1
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: IN
78690: NOT
78691: OR
78692: PUSH
78693: LD_VAR 0 2
78697: NOT
78698: OR
78699: PUSH
78700: LD_VAR 0 5
78704: PUSH
78705: LD_INT 0
78707: PUSH
78708: LD_INT 1
78710: PUSH
78711: LD_INT 2
78713: PUSH
78714: LD_INT 3
78716: PUSH
78717: LD_INT 4
78719: PUSH
78720: LD_INT 5
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: IN
78731: NOT
78732: OR
78733: PUSH
78734: LD_VAR 0 3
78738: PPUSH
78739: LD_VAR 0 4
78743: PPUSH
78744: CALL_OW 488
78748: NOT
78749: OR
78750: IFFALSE 78754
// exit ;
78752: GO 79490
// side := GetSide ( depot ) ;
78754: LD_ADDR_VAR 0 9
78758: PUSH
78759: LD_VAR 0 1
78763: PPUSH
78764: CALL_OW 255
78768: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
78769: LD_VAR 0 9
78773: PPUSH
78774: LD_VAR 0 2
78778: PPUSH
78779: CALL 78263 0 2
78783: NOT
78784: IFFALSE 78788
// exit ;
78786: GO 79490
// pom := GetBase ( depot ) ;
78788: LD_ADDR_VAR 0 10
78792: PUSH
78793: LD_VAR 0 1
78797: PPUSH
78798: CALL_OW 274
78802: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78803: LD_ADDR_VAR 0 11
78807: PUSH
78808: LD_VAR 0 2
78812: PPUSH
78813: LD_VAR 0 1
78817: PPUSH
78818: CALL_OW 248
78822: PPUSH
78823: CALL_OW 450
78827: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78828: LD_VAR 0 10
78832: PPUSH
78833: LD_INT 1
78835: PPUSH
78836: CALL_OW 275
78840: PUSH
78841: LD_VAR 0 11
78845: PUSH
78846: LD_INT 1
78848: ARRAY
78849: GREATEREQUAL
78850: PUSH
78851: LD_VAR 0 10
78855: PPUSH
78856: LD_INT 2
78858: PPUSH
78859: CALL_OW 275
78863: PUSH
78864: LD_VAR 0 11
78868: PUSH
78869: LD_INT 2
78871: ARRAY
78872: GREATEREQUAL
78873: AND
78874: PUSH
78875: LD_VAR 0 10
78879: PPUSH
78880: LD_INT 3
78882: PPUSH
78883: CALL_OW 275
78887: PUSH
78888: LD_VAR 0 11
78892: PUSH
78893: LD_INT 3
78895: ARRAY
78896: GREATEREQUAL
78897: AND
78898: NOT
78899: IFFALSE 78903
// exit ;
78901: GO 79490
// if GetBType ( depot ) = b_depot then
78903: LD_VAR 0 1
78907: PPUSH
78908: CALL_OW 266
78912: PUSH
78913: LD_INT 0
78915: EQUAL
78916: IFFALSE 78928
// dist := 28 else
78918: LD_ADDR_VAR 0 14
78922: PUSH
78923: LD_INT 28
78925: ST_TO_ADDR
78926: GO 78936
// dist := 36 ;
78928: LD_ADDR_VAR 0 14
78932: PUSH
78933: LD_INT 36
78935: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78936: LD_VAR 0 1
78940: PPUSH
78941: LD_VAR 0 3
78945: PPUSH
78946: LD_VAR 0 4
78950: PPUSH
78951: CALL_OW 297
78955: PUSH
78956: LD_VAR 0 14
78960: GREATER
78961: IFFALSE 78965
// exit ;
78963: GO 79490
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78965: LD_ADDR_VAR 0 12
78969: PUSH
78970: LD_VAR 0 2
78974: PPUSH
78975: LD_VAR 0 3
78979: PPUSH
78980: LD_VAR 0 4
78984: PPUSH
78985: LD_VAR 0 5
78989: PPUSH
78990: LD_VAR 0 1
78994: PPUSH
78995: CALL_OW 248
78999: PPUSH
79000: LD_INT 0
79002: PPUSH
79003: CALL 79495 0 6
79007: ST_TO_ADDR
// if not hexes then
79008: LD_VAR 0 12
79012: NOT
79013: IFFALSE 79017
// exit ;
79015: GO 79490
// hex := GetHexInfo ( x , y ) ;
79017: LD_ADDR_VAR 0 15
79021: PUSH
79022: LD_VAR 0 3
79026: PPUSH
79027: LD_VAR 0 4
79031: PPUSH
79032: CALL_OW 546
79036: ST_TO_ADDR
// if hex [ 1 ] then
79037: LD_VAR 0 15
79041: PUSH
79042: LD_INT 1
79044: ARRAY
79045: IFFALSE 79049
// exit ;
79047: GO 79490
// height := hex [ 2 ] ;
79049: LD_ADDR_VAR 0 13
79053: PUSH
79054: LD_VAR 0 15
79058: PUSH
79059: LD_INT 2
79061: ARRAY
79062: ST_TO_ADDR
// for i = 1 to hexes do
79063: LD_ADDR_VAR 0 7
79067: PUSH
79068: DOUBLE
79069: LD_INT 1
79071: DEC
79072: ST_TO_ADDR
79073: LD_VAR 0 12
79077: PUSH
79078: FOR_TO
79079: IFFALSE 79409
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79081: LD_VAR 0 12
79085: PUSH
79086: LD_VAR 0 7
79090: ARRAY
79091: PUSH
79092: LD_INT 1
79094: ARRAY
79095: PPUSH
79096: LD_VAR 0 12
79100: PUSH
79101: LD_VAR 0 7
79105: ARRAY
79106: PUSH
79107: LD_INT 2
79109: ARRAY
79110: PPUSH
79111: CALL_OW 488
79115: NOT
79116: PUSH
79117: LD_VAR 0 12
79121: PUSH
79122: LD_VAR 0 7
79126: ARRAY
79127: PUSH
79128: LD_INT 1
79130: ARRAY
79131: PPUSH
79132: LD_VAR 0 12
79136: PUSH
79137: LD_VAR 0 7
79141: ARRAY
79142: PUSH
79143: LD_INT 2
79145: ARRAY
79146: PPUSH
79147: CALL_OW 428
79151: PUSH
79152: LD_INT 0
79154: GREATER
79155: OR
79156: PUSH
79157: LD_VAR 0 12
79161: PUSH
79162: LD_VAR 0 7
79166: ARRAY
79167: PUSH
79168: LD_INT 1
79170: ARRAY
79171: PPUSH
79172: LD_VAR 0 12
79176: PUSH
79177: LD_VAR 0 7
79181: ARRAY
79182: PUSH
79183: LD_INT 2
79185: ARRAY
79186: PPUSH
79187: CALL_OW 351
79191: OR
79192: IFFALSE 79198
// exit ;
79194: POP
79195: POP
79196: GO 79490
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79198: LD_ADDR_VAR 0 8
79202: PUSH
79203: LD_VAR 0 12
79207: PUSH
79208: LD_VAR 0 7
79212: ARRAY
79213: PUSH
79214: LD_INT 1
79216: ARRAY
79217: PPUSH
79218: LD_VAR 0 12
79222: PUSH
79223: LD_VAR 0 7
79227: ARRAY
79228: PUSH
79229: LD_INT 2
79231: ARRAY
79232: PPUSH
79233: CALL_OW 546
79237: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79238: LD_VAR 0 8
79242: PUSH
79243: LD_INT 1
79245: ARRAY
79246: PUSH
79247: LD_VAR 0 8
79251: PUSH
79252: LD_INT 2
79254: ARRAY
79255: PUSH
79256: LD_VAR 0 13
79260: PUSH
79261: LD_INT 2
79263: PLUS
79264: GREATER
79265: OR
79266: PUSH
79267: LD_VAR 0 8
79271: PUSH
79272: LD_INT 2
79274: ARRAY
79275: PUSH
79276: LD_VAR 0 13
79280: PUSH
79281: LD_INT 2
79283: MINUS
79284: LESS
79285: OR
79286: PUSH
79287: LD_VAR 0 8
79291: PUSH
79292: LD_INT 3
79294: ARRAY
79295: PUSH
79296: LD_INT 0
79298: PUSH
79299: LD_INT 8
79301: PUSH
79302: LD_INT 9
79304: PUSH
79305: LD_INT 10
79307: PUSH
79308: LD_INT 11
79310: PUSH
79311: LD_INT 12
79313: PUSH
79314: LD_INT 13
79316: PUSH
79317: LD_INT 16
79319: PUSH
79320: LD_INT 17
79322: PUSH
79323: LD_INT 18
79325: PUSH
79326: LD_INT 19
79328: PUSH
79329: LD_INT 20
79331: PUSH
79332: LD_INT 21
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: IN
79350: NOT
79351: OR
79352: PUSH
79353: LD_VAR 0 8
79357: PUSH
79358: LD_INT 5
79360: ARRAY
79361: NOT
79362: OR
79363: PUSH
79364: LD_VAR 0 8
79368: PUSH
79369: LD_INT 6
79371: ARRAY
79372: PUSH
79373: LD_INT 1
79375: PUSH
79376: LD_INT 2
79378: PUSH
79379: LD_INT 7
79381: PUSH
79382: LD_INT 9
79384: PUSH
79385: LD_INT 10
79387: PUSH
79388: LD_INT 11
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: IN
79399: NOT
79400: OR
79401: IFFALSE 79407
// exit ;
79403: POP
79404: POP
79405: GO 79490
// end ;
79407: GO 79078
79409: POP
79410: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79411: LD_VAR 0 9
79415: PPUSH
79416: LD_VAR 0 3
79420: PPUSH
79421: LD_VAR 0 4
79425: PPUSH
79426: LD_INT 20
79428: PPUSH
79429: CALL 71435 0 4
79433: PUSH
79434: LD_INT 4
79436: ARRAY
79437: IFFALSE 79441
// exit ;
79439: GO 79490
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79441: LD_VAR 0 2
79445: PUSH
79446: LD_INT 29
79448: PUSH
79449: LD_INT 30
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: IN
79456: PUSH
79457: LD_VAR 0 3
79461: PPUSH
79462: LD_VAR 0 4
79466: PPUSH
79467: LD_VAR 0 9
79471: PPUSH
79472: CALL_OW 440
79476: NOT
79477: AND
79478: IFFALSE 79482
// exit ;
79480: GO 79490
// result := true ;
79482: LD_ADDR_VAR 0 6
79486: PUSH
79487: LD_INT 1
79489: ST_TO_ADDR
// end ;
79490: LD_VAR 0 6
79494: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79495: LD_INT 0
79497: PPUSH
79498: PPUSH
79499: PPUSH
79500: PPUSH
79501: PPUSH
79502: PPUSH
79503: PPUSH
79504: PPUSH
79505: PPUSH
79506: PPUSH
79507: PPUSH
79508: PPUSH
79509: PPUSH
79510: PPUSH
79511: PPUSH
79512: PPUSH
79513: PPUSH
79514: PPUSH
79515: PPUSH
79516: PPUSH
79517: PPUSH
79518: PPUSH
79519: PPUSH
79520: PPUSH
79521: PPUSH
79522: PPUSH
79523: PPUSH
79524: PPUSH
79525: PPUSH
79526: PPUSH
79527: PPUSH
79528: PPUSH
79529: PPUSH
79530: PPUSH
79531: PPUSH
79532: PPUSH
79533: PPUSH
79534: PPUSH
79535: PPUSH
79536: PPUSH
79537: PPUSH
79538: PPUSH
79539: PPUSH
79540: PPUSH
79541: PPUSH
79542: PPUSH
79543: PPUSH
79544: PPUSH
79545: PPUSH
79546: PPUSH
79547: PPUSH
79548: PPUSH
79549: PPUSH
79550: PPUSH
79551: PPUSH
79552: PPUSH
79553: PPUSH
79554: PPUSH
// result = [ ] ;
79555: LD_ADDR_VAR 0 7
79559: PUSH
79560: EMPTY
79561: ST_TO_ADDR
// temp_list = [ ] ;
79562: LD_ADDR_VAR 0 9
79566: PUSH
79567: EMPTY
79568: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79569: LD_VAR 0 4
79573: PUSH
79574: LD_INT 0
79576: PUSH
79577: LD_INT 1
79579: PUSH
79580: LD_INT 2
79582: PUSH
79583: LD_INT 3
79585: PUSH
79586: LD_INT 4
79588: PUSH
79589: LD_INT 5
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: LIST
79596: LIST
79597: LIST
79598: LIST
79599: IN
79600: NOT
79601: PUSH
79602: LD_VAR 0 1
79606: PUSH
79607: LD_INT 0
79609: PUSH
79610: LD_INT 1
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: IN
79617: PUSH
79618: LD_VAR 0 5
79622: PUSH
79623: LD_INT 1
79625: PUSH
79626: LD_INT 2
79628: PUSH
79629: LD_INT 3
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: LIST
79636: IN
79637: NOT
79638: AND
79639: OR
79640: IFFALSE 79644
// exit ;
79642: GO 98035
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79644: LD_VAR 0 1
79648: PUSH
79649: LD_INT 6
79651: PUSH
79652: LD_INT 7
79654: PUSH
79655: LD_INT 8
79657: PUSH
79658: LD_INT 13
79660: PUSH
79661: LD_INT 12
79663: PUSH
79664: LD_INT 15
79666: PUSH
79667: LD_INT 11
79669: PUSH
79670: LD_INT 14
79672: PUSH
79673: LD_INT 10
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: IN
79687: IFFALSE 79697
// btype = b_lab ;
79689: LD_ADDR_VAR 0 1
79693: PUSH
79694: LD_INT 6
79696: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79697: LD_VAR 0 6
79701: PUSH
79702: LD_INT 0
79704: PUSH
79705: LD_INT 1
79707: PUSH
79708: LD_INT 2
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: LIST
79715: IN
79716: NOT
79717: PUSH
79718: LD_VAR 0 1
79722: PUSH
79723: LD_INT 0
79725: PUSH
79726: LD_INT 1
79728: PUSH
79729: LD_INT 2
79731: PUSH
79732: LD_INT 3
79734: PUSH
79735: LD_INT 6
79737: PUSH
79738: LD_INT 36
79740: PUSH
79741: LD_INT 4
79743: PUSH
79744: LD_INT 5
79746: PUSH
79747: LD_INT 31
79749: PUSH
79750: LD_INT 32
79752: PUSH
79753: LD_INT 33
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: LIST
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: IN
79769: NOT
79770: PUSH
79771: LD_VAR 0 6
79775: PUSH
79776: LD_INT 1
79778: EQUAL
79779: AND
79780: OR
79781: PUSH
79782: LD_VAR 0 1
79786: PUSH
79787: LD_INT 2
79789: PUSH
79790: LD_INT 3
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: IN
79797: NOT
79798: PUSH
79799: LD_VAR 0 6
79803: PUSH
79804: LD_INT 2
79806: EQUAL
79807: AND
79808: OR
79809: IFFALSE 79819
// mode = 0 ;
79811: LD_ADDR_VAR 0 6
79815: PUSH
79816: LD_INT 0
79818: ST_TO_ADDR
// case mode of 0 :
79819: LD_VAR 0 6
79823: PUSH
79824: LD_INT 0
79826: DOUBLE
79827: EQUAL
79828: IFTRUE 79832
79830: GO 91285
79832: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79833: LD_ADDR_VAR 0 11
79837: PUSH
79838: LD_INT 0
79840: PUSH
79841: LD_INT 0
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 0
79850: PUSH
79851: LD_INT 1
79853: NEG
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 1
79861: PUSH
79862: LD_INT 0
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: LD_INT 1
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 0
79881: PUSH
79882: LD_INT 1
79884: PUSH
79885: EMPTY
79886: LIST
79887: LIST
79888: PUSH
79889: LD_INT 1
79891: NEG
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 1
79902: NEG
79903: PUSH
79904: LD_INT 1
79906: NEG
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 1
79914: NEG
79915: PUSH
79916: LD_INT 2
79918: NEG
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: LD_INT 0
79926: PUSH
79927: LD_INT 2
79929: NEG
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: LD_INT 1
79937: PUSH
79938: LD_INT 1
79940: NEG
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 1
79948: PUSH
79949: LD_INT 2
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 0
79958: PUSH
79959: LD_INT 2
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 1
79968: NEG
79969: PUSH
79970: LD_INT 1
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 1
79979: PUSH
79980: LD_INT 3
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: LD_INT 0
79989: PUSH
79990: LD_INT 3
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 1
79999: NEG
80000: PUSH
80001: LD_INT 2
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80026: LD_ADDR_VAR 0 12
80030: PUSH
80031: LD_INT 0
80033: PUSH
80034: LD_INT 0
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 0
80043: PUSH
80044: LD_INT 1
80046: NEG
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 1
80054: PUSH
80055: LD_INT 0
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PUSH
80062: LD_INT 1
80064: PUSH
80065: LD_INT 1
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 0
80074: PUSH
80075: LD_INT 1
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: LD_INT 1
80084: NEG
80085: PUSH
80086: LD_INT 0
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: LD_INT 1
80095: NEG
80096: PUSH
80097: LD_INT 1
80099: NEG
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 1
80107: PUSH
80108: LD_INT 1
80110: NEG
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 2
80118: PUSH
80119: LD_INT 0
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 2
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 1
80138: NEG
80139: PUSH
80140: LD_INT 1
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 2
80149: NEG
80150: PUSH
80151: LD_INT 0
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 2
80160: NEG
80161: PUSH
80162: LD_INT 1
80164: NEG
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 2
80172: NEG
80173: PUSH
80174: LD_INT 1
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 3
80183: NEG
80184: PUSH
80185: LD_INT 0
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 3
80194: NEG
80195: PUSH
80196: LD_INT 1
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: LIST
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80222: LD_ADDR_VAR 0 13
80226: PUSH
80227: LD_INT 0
80229: PUSH
80230: LD_INT 0
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 0
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 1
80250: PUSH
80251: LD_INT 0
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 1
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 0
80270: PUSH
80271: LD_INT 1
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 1
80280: NEG
80281: PUSH
80282: LD_INT 0
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 1
80291: NEG
80292: PUSH
80293: LD_INT 1
80295: NEG
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 1
80303: NEG
80304: PUSH
80305: LD_INT 2
80307: NEG
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 2
80315: PUSH
80316: LD_INT 1
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 2
80325: PUSH
80326: LD_INT 2
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 1
80335: PUSH
80336: LD_INT 2
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 2
80345: NEG
80346: PUSH
80347: LD_INT 1
80349: NEG
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 2
80357: NEG
80358: PUSH
80359: LD_INT 2
80361: NEG
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 2
80369: NEG
80370: PUSH
80371: LD_INT 3
80373: NEG
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 3
80381: NEG
80382: PUSH
80383: LD_INT 2
80385: NEG
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 3
80393: NEG
80394: PUSH
80395: LD_INT 3
80397: NEG
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: LIST
80420: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80421: LD_ADDR_VAR 0 14
80425: PUSH
80426: LD_INT 0
80428: PUSH
80429: LD_INT 0
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 0
80438: PUSH
80439: LD_INT 1
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 1
80449: PUSH
80450: LD_INT 0
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 1
80459: PUSH
80460: LD_INT 1
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 0
80469: PUSH
80470: LD_INT 1
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 1
80479: NEG
80480: PUSH
80481: LD_INT 0
80483: PUSH
80484: EMPTY
80485: LIST
80486: LIST
80487: PUSH
80488: LD_INT 1
80490: NEG
80491: PUSH
80492: LD_INT 1
80494: NEG
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: PUSH
80500: LD_INT 1
80502: NEG
80503: PUSH
80504: LD_INT 2
80506: NEG
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 0
80514: PUSH
80515: LD_INT 2
80517: NEG
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 1
80525: PUSH
80526: LD_INT 1
80528: NEG
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 1
80536: PUSH
80537: LD_INT 2
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 0
80546: PUSH
80547: LD_INT 2
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 1
80556: NEG
80557: PUSH
80558: LD_INT 1
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 1
80567: NEG
80568: PUSH
80569: LD_INT 3
80571: NEG
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 0
80579: PUSH
80580: LD_INT 3
80582: NEG
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 1
80590: PUSH
80591: LD_INT 2
80593: NEG
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: EMPTY
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80617: LD_ADDR_VAR 0 15
80621: PUSH
80622: LD_INT 0
80624: PUSH
80625: LD_INT 0
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 0
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 1
80645: PUSH
80646: LD_INT 0
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: LD_INT 1
80655: PUSH
80656: LD_INT 1
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PUSH
80663: LD_INT 0
80665: PUSH
80666: LD_INT 1
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: LD_INT 0
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 1
80686: NEG
80687: PUSH
80688: LD_INT 1
80690: NEG
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 1
80698: PUSH
80699: LD_INT 1
80701: NEG
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 2
80709: PUSH
80710: LD_INT 0
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 2
80719: PUSH
80720: LD_INT 1
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 1
80729: NEG
80730: PUSH
80731: LD_INT 1
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 2
80740: NEG
80741: PUSH
80742: LD_INT 0
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: PUSH
80749: LD_INT 2
80751: NEG
80752: PUSH
80753: LD_INT 1
80755: NEG
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 2
80763: PUSH
80764: LD_INT 1
80766: NEG
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 3
80774: PUSH
80775: LD_INT 0
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: LD_INT 3
80784: PUSH
80785: LD_INT 1
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: LIST
80796: LIST
80797: LIST
80798: LIST
80799: LIST
80800: LIST
80801: LIST
80802: LIST
80803: LIST
80804: LIST
80805: LIST
80806: LIST
80807: LIST
80808: LIST
80809: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80810: LD_ADDR_VAR 0 16
80814: PUSH
80815: LD_INT 0
80817: PUSH
80818: LD_INT 0
80820: PUSH
80821: EMPTY
80822: LIST
80823: LIST
80824: PUSH
80825: LD_INT 0
80827: PUSH
80828: LD_INT 1
80830: NEG
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 1
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 1
80848: PUSH
80849: LD_INT 1
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 0
80858: PUSH
80859: LD_INT 1
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 1
80868: NEG
80869: PUSH
80870: LD_INT 0
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: LD_INT 1
80883: NEG
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 1
80891: NEG
80892: PUSH
80893: LD_INT 2
80895: NEG
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 2
80903: PUSH
80904: LD_INT 1
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: LD_INT 2
80913: PUSH
80914: LD_INT 2
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: PUSH
80921: LD_INT 1
80923: PUSH
80924: LD_INT 2
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: PUSH
80931: LD_INT 2
80933: NEG
80934: PUSH
80935: LD_INT 1
80937: NEG
80938: PUSH
80939: EMPTY
80940: LIST
80941: LIST
80942: PUSH
80943: LD_INT 2
80945: NEG
80946: PUSH
80947: LD_INT 2
80949: NEG
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 3
80957: PUSH
80958: LD_INT 2
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 3
80967: PUSH
80968: LD_INT 3
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 2
80977: PUSH
80978: LD_INT 3
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81003: LD_ADDR_VAR 0 17
81007: PUSH
81008: LD_INT 0
81010: PUSH
81011: LD_INT 0
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: LD_INT 0
81020: PUSH
81021: LD_INT 1
81023: NEG
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 1
81031: PUSH
81032: LD_INT 0
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 1
81041: PUSH
81042: LD_INT 1
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 0
81051: PUSH
81052: LD_INT 1
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 1
81061: NEG
81062: PUSH
81063: LD_INT 0
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 1
81072: NEG
81073: PUSH
81074: LD_INT 1
81076: NEG
81077: PUSH
81078: EMPTY
81079: LIST
81080: LIST
81081: PUSH
81082: LD_INT 1
81084: NEG
81085: PUSH
81086: LD_INT 2
81088: NEG
81089: PUSH
81090: EMPTY
81091: LIST
81092: LIST
81093: PUSH
81094: LD_INT 0
81096: PUSH
81097: LD_INT 2
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 1
81107: PUSH
81108: LD_INT 1
81110: NEG
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 2
81118: PUSH
81119: LD_INT 0
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 2
81128: PUSH
81129: LD_INT 1
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: LD_INT 2
81138: PUSH
81139: LD_INT 2
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 1
81148: PUSH
81149: LD_INT 2
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 0
81158: PUSH
81159: LD_INT 2
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 1
81168: NEG
81169: PUSH
81170: LD_INT 1
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 2
81179: NEG
81180: PUSH
81181: LD_INT 0
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: PUSH
81188: LD_INT 2
81190: NEG
81191: PUSH
81192: LD_INT 1
81194: NEG
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 2
81202: NEG
81203: PUSH
81204: LD_INT 2
81206: NEG
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: LIST
81216: LIST
81217: LIST
81218: LIST
81219: LIST
81220: LIST
81221: LIST
81222: LIST
81223: LIST
81224: LIST
81225: LIST
81226: LIST
81227: LIST
81228: LIST
81229: LIST
81230: LIST
81231: LIST
81232: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81233: LD_ADDR_VAR 0 18
81237: PUSH
81238: LD_INT 0
81240: PUSH
81241: LD_INT 0
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 0
81250: PUSH
81251: LD_INT 1
81253: NEG
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 1
81261: PUSH
81262: LD_INT 0
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 1
81271: PUSH
81272: LD_INT 1
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 0
81281: PUSH
81282: LD_INT 1
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 1
81291: NEG
81292: PUSH
81293: LD_INT 0
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 1
81302: NEG
81303: PUSH
81304: LD_INT 1
81306: NEG
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 1
81314: NEG
81315: PUSH
81316: LD_INT 2
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 0
81326: PUSH
81327: LD_INT 2
81329: NEG
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 1
81337: PUSH
81338: LD_INT 1
81340: NEG
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 2
81348: PUSH
81349: LD_INT 0
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 2
81358: PUSH
81359: LD_INT 1
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 2
81368: PUSH
81369: LD_INT 2
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 1
81378: PUSH
81379: LD_INT 2
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 0
81388: PUSH
81389: LD_INT 2
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 1
81398: NEG
81399: PUSH
81400: LD_INT 1
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 2
81409: NEG
81410: PUSH
81411: LD_INT 0
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 2
81420: NEG
81421: PUSH
81422: LD_INT 1
81424: NEG
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 2
81432: NEG
81433: PUSH
81434: LD_INT 2
81436: NEG
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81463: LD_ADDR_VAR 0 19
81467: PUSH
81468: LD_INT 0
81470: PUSH
81471: LD_INT 0
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 0
81480: PUSH
81481: LD_INT 1
81483: NEG
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 1
81491: PUSH
81492: LD_INT 0
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 1
81501: PUSH
81502: LD_INT 1
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: LD_INT 1
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 1
81521: NEG
81522: PUSH
81523: LD_INT 0
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 1
81532: NEG
81533: PUSH
81534: LD_INT 1
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 1
81544: NEG
81545: PUSH
81546: LD_INT 2
81548: NEG
81549: PUSH
81550: EMPTY
81551: LIST
81552: LIST
81553: PUSH
81554: LD_INT 0
81556: PUSH
81557: LD_INT 2
81559: NEG
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 1
81567: PUSH
81568: LD_INT 1
81570: NEG
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: PUSH
81576: LD_INT 2
81578: PUSH
81579: LD_INT 0
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 2
81588: PUSH
81589: LD_INT 1
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 2
81598: PUSH
81599: LD_INT 2
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 1
81608: PUSH
81609: LD_INT 2
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 0
81618: PUSH
81619: LD_INT 2
81621: PUSH
81622: EMPTY
81623: LIST
81624: LIST
81625: PUSH
81626: LD_INT 1
81628: NEG
81629: PUSH
81630: LD_INT 1
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 2
81639: NEG
81640: PUSH
81641: LD_INT 0
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 2
81650: NEG
81651: PUSH
81652: LD_INT 1
81654: NEG
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: PUSH
81660: LD_INT 2
81662: NEG
81663: PUSH
81664: LD_INT 2
81666: NEG
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81693: LD_ADDR_VAR 0 20
81697: PUSH
81698: LD_INT 0
81700: PUSH
81701: LD_INT 0
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 0
81710: PUSH
81711: LD_INT 1
81713: NEG
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 1
81721: PUSH
81722: LD_INT 0
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 1
81731: PUSH
81732: LD_INT 1
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 0
81741: PUSH
81742: LD_INT 1
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 1
81751: NEG
81752: PUSH
81753: LD_INT 0
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: PUSH
81760: LD_INT 1
81762: NEG
81763: PUSH
81764: LD_INT 1
81766: NEG
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PUSH
81772: LD_INT 1
81774: NEG
81775: PUSH
81776: LD_INT 2
81778: NEG
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 0
81786: PUSH
81787: LD_INT 2
81789: NEG
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 1
81797: PUSH
81798: LD_INT 1
81800: NEG
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 2
81808: PUSH
81809: LD_INT 0
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 2
81818: PUSH
81819: LD_INT 1
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 2
81828: PUSH
81829: LD_INT 2
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 1
81838: PUSH
81839: LD_INT 2
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 0
81848: PUSH
81849: LD_INT 2
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 1
81858: NEG
81859: PUSH
81860: LD_INT 1
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 2
81869: NEG
81870: PUSH
81871: LD_INT 0
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: LD_INT 2
81880: NEG
81881: PUSH
81882: LD_INT 1
81884: NEG
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 2
81892: NEG
81893: PUSH
81894: LD_INT 2
81896: NEG
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: LIST
81906: LIST
81907: LIST
81908: LIST
81909: LIST
81910: LIST
81911: LIST
81912: LIST
81913: LIST
81914: LIST
81915: LIST
81916: LIST
81917: LIST
81918: LIST
81919: LIST
81920: LIST
81921: LIST
81922: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81923: LD_ADDR_VAR 0 21
81927: PUSH
81928: LD_INT 0
81930: PUSH
81931: LD_INT 0
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 0
81940: PUSH
81941: LD_INT 1
81943: NEG
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 1
81951: PUSH
81952: LD_INT 0
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 1
81961: PUSH
81962: LD_INT 1
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 0
81971: PUSH
81972: LD_INT 1
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 1
81981: NEG
81982: PUSH
81983: LD_INT 0
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 1
81992: NEG
81993: PUSH
81994: LD_INT 1
81996: NEG
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 1
82004: NEG
82005: PUSH
82006: LD_INT 2
82008: NEG
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 0
82016: PUSH
82017: LD_INT 2
82019: NEG
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 1
82027: PUSH
82028: LD_INT 1
82030: NEG
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 2
82038: PUSH
82039: LD_INT 0
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: PUSH
82046: LD_INT 2
82048: PUSH
82049: LD_INT 1
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PUSH
82056: LD_INT 2
82058: PUSH
82059: LD_INT 2
82061: PUSH
82062: EMPTY
82063: LIST
82064: LIST
82065: PUSH
82066: LD_INT 1
82068: PUSH
82069: LD_INT 2
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 0
82078: PUSH
82079: LD_INT 2
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 1
82088: NEG
82089: PUSH
82090: LD_INT 1
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 2
82099: NEG
82100: PUSH
82101: LD_INT 0
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 2
82110: NEG
82111: PUSH
82112: LD_INT 1
82114: NEG
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 2
82122: NEG
82123: PUSH
82124: LD_INT 2
82126: NEG
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82153: LD_ADDR_VAR 0 22
82157: PUSH
82158: LD_INT 0
82160: PUSH
82161: LD_INT 0
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 1
82181: PUSH
82182: LD_INT 0
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 1
82191: PUSH
82192: LD_INT 1
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 0
82201: PUSH
82202: LD_INT 1
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 1
82222: NEG
82223: PUSH
82224: LD_INT 1
82226: NEG
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 1
82234: NEG
82235: PUSH
82236: LD_INT 2
82238: NEG
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 0
82246: PUSH
82247: LD_INT 2
82249: NEG
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 1
82257: PUSH
82258: LD_INT 1
82260: NEG
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 2
82268: PUSH
82269: LD_INT 0
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: LD_INT 2
82278: PUSH
82279: LD_INT 1
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 2
82288: PUSH
82289: LD_INT 2
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 1
82298: PUSH
82299: LD_INT 2
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: LD_INT 0
82308: PUSH
82309: LD_INT 2
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 1
82318: NEG
82319: PUSH
82320: LD_INT 1
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 2
82329: NEG
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 2
82340: NEG
82341: PUSH
82342: LD_INT 1
82344: NEG
82345: PUSH
82346: EMPTY
82347: LIST
82348: LIST
82349: PUSH
82350: LD_INT 2
82352: NEG
82353: PUSH
82354: LD_INT 2
82356: NEG
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82383: LD_ADDR_VAR 0 23
82387: PUSH
82388: LD_INT 0
82390: PUSH
82391: LD_INT 0
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 0
82400: PUSH
82401: LD_INT 1
82403: NEG
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 1
82411: PUSH
82412: LD_INT 0
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: PUSH
82419: LD_INT 1
82421: PUSH
82422: LD_INT 1
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 0
82431: PUSH
82432: LD_INT 1
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 1
82441: NEG
82442: PUSH
82443: LD_INT 0
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 1
82452: NEG
82453: PUSH
82454: LD_INT 1
82456: NEG
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 1
82464: NEG
82465: PUSH
82466: LD_INT 2
82468: NEG
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 0
82476: PUSH
82477: LD_INT 2
82479: NEG
82480: PUSH
82481: EMPTY
82482: LIST
82483: LIST
82484: PUSH
82485: LD_INT 1
82487: PUSH
82488: LD_INT 1
82490: NEG
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 2
82498: PUSH
82499: LD_INT 0
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 2
82508: PUSH
82509: LD_INT 1
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 2
82518: PUSH
82519: LD_INT 2
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 1
82528: PUSH
82529: LD_INT 2
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 0
82538: PUSH
82539: LD_INT 2
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: LD_INT 1
82548: NEG
82549: PUSH
82550: LD_INT 1
82552: PUSH
82553: EMPTY
82554: LIST
82555: LIST
82556: PUSH
82557: LD_INT 2
82559: NEG
82560: PUSH
82561: LD_INT 0
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 2
82570: NEG
82571: PUSH
82572: LD_INT 1
82574: NEG
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 2
82582: NEG
82583: PUSH
82584: LD_INT 2
82586: NEG
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 2
82594: NEG
82595: PUSH
82596: LD_INT 3
82598: NEG
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 1
82606: NEG
82607: PUSH
82608: LD_INT 3
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 1
82618: PUSH
82619: LD_INT 2
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 2
82629: PUSH
82630: LD_INT 1
82632: NEG
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82663: LD_ADDR_VAR 0 24
82667: PUSH
82668: LD_INT 0
82670: PUSH
82671: LD_INT 0
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 0
82680: PUSH
82681: LD_INT 1
82683: NEG
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 1
82691: PUSH
82692: LD_INT 0
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 1
82701: PUSH
82702: LD_INT 1
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 0
82711: PUSH
82712: LD_INT 1
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 1
82721: NEG
82722: PUSH
82723: LD_INT 0
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 1
82732: NEG
82733: PUSH
82734: LD_INT 1
82736: NEG
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: NEG
82745: PUSH
82746: LD_INT 2
82748: NEG
82749: PUSH
82750: EMPTY
82751: LIST
82752: LIST
82753: PUSH
82754: LD_INT 0
82756: PUSH
82757: LD_INT 2
82759: NEG
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 1
82767: PUSH
82768: LD_INT 1
82770: NEG
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 2
82778: PUSH
82779: LD_INT 0
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 2
82788: PUSH
82789: LD_INT 1
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 2
82798: PUSH
82799: LD_INT 2
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: PUSH
82806: LD_INT 1
82808: PUSH
82809: LD_INT 2
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 0
82818: PUSH
82819: LD_INT 2
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PUSH
82826: LD_INT 1
82828: NEG
82829: PUSH
82830: LD_INT 1
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 2
82839: NEG
82840: PUSH
82841: LD_INT 0
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: PUSH
82848: LD_INT 2
82850: NEG
82851: PUSH
82852: LD_INT 1
82854: NEG
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 2
82862: NEG
82863: PUSH
82864: LD_INT 2
82866: NEG
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 1
82874: PUSH
82875: LD_INT 2
82877: NEG
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 2
82885: PUSH
82886: LD_INT 1
82888: NEG
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 3
82896: PUSH
82897: LD_INT 1
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 3
82906: PUSH
82907: LD_INT 2
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: LIST
82937: LIST
82938: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82939: LD_ADDR_VAR 0 25
82943: PUSH
82944: LD_INT 0
82946: PUSH
82947: LD_INT 0
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 0
82956: PUSH
82957: LD_INT 1
82959: NEG
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: LD_INT 1
82967: PUSH
82968: LD_INT 0
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 1
82977: PUSH
82978: LD_INT 1
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: LD_INT 0
82987: PUSH
82988: LD_INT 1
82990: PUSH
82991: EMPTY
82992: LIST
82993: LIST
82994: PUSH
82995: LD_INT 1
82997: NEG
82998: PUSH
82999: LD_INT 0
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 1
83008: NEG
83009: PUSH
83010: LD_INT 1
83012: NEG
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 1
83020: NEG
83021: PUSH
83022: LD_INT 2
83024: NEG
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 0
83032: PUSH
83033: LD_INT 2
83035: NEG
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 1
83043: PUSH
83044: LD_INT 1
83046: NEG
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 2
83054: PUSH
83055: LD_INT 0
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 2
83064: PUSH
83065: LD_INT 1
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 2
83074: PUSH
83075: LD_INT 2
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 1
83084: PUSH
83085: LD_INT 2
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 0
83094: PUSH
83095: LD_INT 2
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_INT 1
83104: NEG
83105: PUSH
83106: LD_INT 1
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 2
83115: NEG
83116: PUSH
83117: LD_INT 0
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_INT 2
83126: NEG
83127: PUSH
83128: LD_INT 1
83130: NEG
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 2
83138: NEG
83139: PUSH
83140: LD_INT 2
83142: NEG
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 3
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 3
83160: PUSH
83161: LD_INT 2
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 2
83170: PUSH
83171: LD_INT 3
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 1
83180: PUSH
83181: LD_INT 3
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83213: LD_ADDR_VAR 0 26
83217: PUSH
83218: LD_INT 0
83220: PUSH
83221: LD_INT 0
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 0
83230: PUSH
83231: LD_INT 1
83233: NEG
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 1
83241: PUSH
83242: LD_INT 0
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 1
83251: PUSH
83252: LD_INT 1
83254: PUSH
83255: EMPTY
83256: LIST
83257: LIST
83258: PUSH
83259: LD_INT 0
83261: PUSH
83262: LD_INT 1
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: PUSH
83269: LD_INT 1
83271: NEG
83272: PUSH
83273: LD_INT 0
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: LD_INT 1
83286: NEG
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 1
83294: NEG
83295: PUSH
83296: LD_INT 2
83298: NEG
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 0
83306: PUSH
83307: LD_INT 2
83309: NEG
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 1
83317: PUSH
83318: LD_INT 1
83320: NEG
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PUSH
83326: LD_INT 2
83328: PUSH
83329: LD_INT 0
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 2
83338: PUSH
83339: LD_INT 1
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 2
83348: PUSH
83349: LD_INT 2
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 1
83358: PUSH
83359: LD_INT 2
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 0
83368: PUSH
83369: LD_INT 2
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: PUSH
83376: LD_INT 1
83378: NEG
83379: PUSH
83380: LD_INT 1
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: PUSH
83387: LD_INT 2
83389: NEG
83390: PUSH
83391: LD_INT 0
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 2
83400: NEG
83401: PUSH
83402: LD_INT 1
83404: NEG
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 2
83412: NEG
83413: PUSH
83414: LD_INT 2
83416: NEG
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: PUSH
83422: LD_INT 2
83424: PUSH
83425: LD_INT 3
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: LD_INT 3
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PUSH
83442: LD_INT 1
83444: NEG
83445: PUSH
83446: LD_INT 2
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 2
83455: NEG
83456: PUSH
83457: LD_INT 1
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: LIST
83485: LIST
83486: LIST
83487: LIST
83488: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83489: LD_ADDR_VAR 0 27
83493: PUSH
83494: LD_INT 0
83496: PUSH
83497: LD_INT 0
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 0
83506: PUSH
83507: LD_INT 1
83509: NEG
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: PUSH
83515: LD_INT 1
83517: PUSH
83518: LD_INT 0
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 1
83527: PUSH
83528: LD_INT 1
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 0
83537: PUSH
83538: LD_INT 1
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 1
83547: NEG
83548: PUSH
83549: LD_INT 0
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 1
83558: NEG
83559: PUSH
83560: LD_INT 1
83562: NEG
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 1
83570: NEG
83571: PUSH
83572: LD_INT 2
83574: NEG
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 0
83582: PUSH
83583: LD_INT 2
83585: NEG
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 1
83593: PUSH
83594: LD_INT 1
83596: NEG
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 2
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 2
83614: PUSH
83615: LD_INT 1
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 2
83624: PUSH
83625: LD_INT 2
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 1
83634: PUSH
83635: LD_INT 2
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 0
83644: PUSH
83645: LD_INT 2
83647: PUSH
83648: EMPTY
83649: LIST
83650: LIST
83651: PUSH
83652: LD_INT 1
83654: NEG
83655: PUSH
83656: LD_INT 1
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: LD_INT 2
83665: NEG
83666: PUSH
83667: LD_INT 0
83669: PUSH
83670: EMPTY
83671: LIST
83672: LIST
83673: PUSH
83674: LD_INT 2
83676: NEG
83677: PUSH
83678: LD_INT 1
83680: NEG
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: PUSH
83686: LD_INT 2
83688: NEG
83689: PUSH
83690: LD_INT 2
83692: NEG
83693: PUSH
83694: EMPTY
83695: LIST
83696: LIST
83697: PUSH
83698: LD_INT 1
83700: NEG
83701: PUSH
83702: LD_INT 2
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PUSH
83709: LD_INT 2
83711: NEG
83712: PUSH
83713: LD_INT 1
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 3
83722: NEG
83723: PUSH
83724: LD_INT 1
83726: NEG
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 3
83734: NEG
83735: PUSH
83736: LD_INT 2
83738: NEG
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83769: LD_ADDR_VAR 0 28
83773: PUSH
83774: LD_INT 0
83776: PUSH
83777: LD_INT 0
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 0
83786: PUSH
83787: LD_INT 1
83789: NEG
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: PUSH
83795: LD_INT 1
83797: PUSH
83798: LD_INT 0
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: PUSH
83805: LD_INT 1
83807: PUSH
83808: LD_INT 1
83810: PUSH
83811: EMPTY
83812: LIST
83813: LIST
83814: PUSH
83815: LD_INT 0
83817: PUSH
83818: LD_INT 1
83820: PUSH
83821: EMPTY
83822: LIST
83823: LIST
83824: PUSH
83825: LD_INT 1
83827: NEG
83828: PUSH
83829: LD_INT 0
83831: PUSH
83832: EMPTY
83833: LIST
83834: LIST
83835: PUSH
83836: LD_INT 1
83838: NEG
83839: PUSH
83840: LD_INT 1
83842: NEG
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: NEG
83851: PUSH
83852: LD_INT 2
83854: NEG
83855: PUSH
83856: EMPTY
83857: LIST
83858: LIST
83859: PUSH
83860: LD_INT 0
83862: PUSH
83863: LD_INT 2
83865: NEG
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 1
83873: PUSH
83874: LD_INT 1
83876: NEG
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: PUSH
83882: LD_INT 2
83884: PUSH
83885: LD_INT 0
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 2
83894: PUSH
83895: LD_INT 1
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PUSH
83902: LD_INT 2
83904: PUSH
83905: LD_INT 2
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 1
83914: PUSH
83915: LD_INT 2
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 0
83924: PUSH
83925: LD_INT 2
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: PUSH
83932: LD_INT 1
83934: NEG
83935: PUSH
83936: LD_INT 1
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 2
83945: NEG
83946: PUSH
83947: LD_INT 0
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 2
83956: NEG
83957: PUSH
83958: LD_INT 1
83960: NEG
83961: PUSH
83962: EMPTY
83963: LIST
83964: LIST
83965: PUSH
83966: LD_INT 2
83968: NEG
83969: PUSH
83970: LD_INT 2
83972: NEG
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: PUSH
83978: LD_INT 2
83980: NEG
83981: PUSH
83982: LD_INT 3
83984: NEG
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 1
83992: NEG
83993: PUSH
83994: LD_INT 3
83996: NEG
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: PUSH
84002: LD_INT 3
84004: NEG
84005: PUSH
84006: LD_INT 1
84008: NEG
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PUSH
84014: LD_INT 3
84016: NEG
84017: PUSH
84018: LD_INT 2
84020: NEG
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: LIST
84048: LIST
84049: LIST
84050: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84051: LD_ADDR_VAR 0 29
84055: PUSH
84056: LD_INT 0
84058: PUSH
84059: LD_INT 0
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 0
84068: PUSH
84069: LD_INT 1
84071: NEG
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 1
84079: PUSH
84080: LD_INT 0
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 1
84089: PUSH
84090: LD_INT 1
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 0
84099: PUSH
84100: LD_INT 1
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 1
84109: NEG
84110: PUSH
84111: LD_INT 0
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 1
84120: NEG
84121: PUSH
84122: LD_INT 1
84124: NEG
84125: PUSH
84126: EMPTY
84127: LIST
84128: LIST
84129: PUSH
84130: LD_INT 1
84132: NEG
84133: PUSH
84134: LD_INT 2
84136: NEG
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 0
84144: PUSH
84145: LD_INT 2
84147: NEG
84148: PUSH
84149: EMPTY
84150: LIST
84151: LIST
84152: PUSH
84153: LD_INT 1
84155: PUSH
84156: LD_INT 1
84158: NEG
84159: PUSH
84160: EMPTY
84161: LIST
84162: LIST
84163: PUSH
84164: LD_INT 2
84166: PUSH
84167: LD_INT 0
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 2
84176: PUSH
84177: LD_INT 1
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: LD_INT 1
84186: PUSH
84187: LD_INT 2
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 0
84196: PUSH
84197: LD_INT 2
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 1
84206: NEG
84207: PUSH
84208: LD_INT 1
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 2
84217: NEG
84218: PUSH
84219: LD_INT 1
84221: NEG
84222: PUSH
84223: EMPTY
84224: LIST
84225: LIST
84226: PUSH
84227: LD_INT 2
84229: NEG
84230: PUSH
84231: LD_INT 2
84233: NEG
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 2
84241: NEG
84242: PUSH
84243: LD_INT 3
84245: NEG
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 2
84253: PUSH
84254: LD_INT 1
84256: NEG
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 3
84264: PUSH
84265: LD_INT 1
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 1
84274: PUSH
84275: LD_INT 3
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 1
84284: NEG
84285: PUSH
84286: LD_INT 2
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 3
84295: NEG
84296: PUSH
84297: LD_INT 2
84299: NEG
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84330: LD_ADDR_VAR 0 30
84334: PUSH
84335: LD_INT 0
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 0
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: PUSH
84356: LD_INT 1
84358: PUSH
84359: LD_INT 0
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: LD_INT 1
84368: PUSH
84369: LD_INT 1
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 0
84378: PUSH
84379: LD_INT 1
84381: PUSH
84382: EMPTY
84383: LIST
84384: LIST
84385: PUSH
84386: LD_INT 1
84388: NEG
84389: PUSH
84390: LD_INT 0
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: PUSH
84397: LD_INT 1
84399: NEG
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 1
84411: NEG
84412: PUSH
84413: LD_INT 2
84415: NEG
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: PUSH
84421: LD_INT 0
84423: PUSH
84424: LD_INT 2
84426: NEG
84427: PUSH
84428: EMPTY
84429: LIST
84430: LIST
84431: PUSH
84432: LD_INT 1
84434: PUSH
84435: LD_INT 1
84437: NEG
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: PUSH
84443: LD_INT 2
84445: PUSH
84446: LD_INT 0
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 2
84455: PUSH
84456: LD_INT 1
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 2
84465: PUSH
84466: LD_INT 2
84468: PUSH
84469: EMPTY
84470: LIST
84471: LIST
84472: PUSH
84473: LD_INT 1
84475: PUSH
84476: LD_INT 2
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: PUSH
84483: LD_INT 1
84485: NEG
84486: PUSH
84487: LD_INT 1
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 2
84496: NEG
84497: PUSH
84498: LD_INT 0
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 2
84507: NEG
84508: PUSH
84509: LD_INT 1
84511: NEG
84512: PUSH
84513: EMPTY
84514: LIST
84515: LIST
84516: PUSH
84517: LD_INT 1
84519: NEG
84520: PUSH
84521: LD_INT 3
84523: NEG
84524: PUSH
84525: EMPTY
84526: LIST
84527: LIST
84528: PUSH
84529: LD_INT 1
84531: PUSH
84532: LD_INT 2
84534: NEG
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 3
84542: PUSH
84543: LD_INT 2
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 2
84552: PUSH
84553: LD_INT 3
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 2
84562: NEG
84563: PUSH
84564: LD_INT 1
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 3
84573: NEG
84574: PUSH
84575: LD_INT 1
84577: NEG
84578: PUSH
84579: EMPTY
84580: LIST
84581: LIST
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84608: LD_ADDR_VAR 0 31
84612: PUSH
84613: LD_INT 0
84615: PUSH
84616: LD_INT 0
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 0
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 1
84636: PUSH
84637: LD_INT 0
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: PUSH
84644: LD_INT 1
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 0
84656: PUSH
84657: LD_INT 1
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 1
84666: NEG
84667: PUSH
84668: LD_INT 0
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 1
84677: NEG
84678: PUSH
84679: LD_INT 1
84681: NEG
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 1
84689: NEG
84690: PUSH
84691: LD_INT 2
84693: NEG
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 1
84701: PUSH
84702: LD_INT 1
84704: NEG
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 2
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 2
84722: PUSH
84723: LD_INT 1
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: PUSH
84730: LD_INT 2
84732: PUSH
84733: LD_INT 2
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 1
84742: PUSH
84743: LD_INT 2
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: PUSH
84750: LD_INT 0
84752: PUSH
84753: LD_INT 2
84755: PUSH
84756: EMPTY
84757: LIST
84758: LIST
84759: PUSH
84760: LD_INT 1
84762: NEG
84763: PUSH
84764: LD_INT 1
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: PUSH
84771: LD_INT 2
84773: NEG
84774: PUSH
84775: LD_INT 1
84777: NEG
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 2
84785: NEG
84786: PUSH
84787: LD_INT 2
84789: NEG
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 2
84797: NEG
84798: PUSH
84799: LD_INT 3
84801: NEG
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: PUSH
84807: LD_INT 2
84809: PUSH
84810: LD_INT 1
84812: NEG
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 3
84820: PUSH
84821: LD_INT 1
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 1
84830: PUSH
84831: LD_INT 3
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: LD_INT 1
84840: NEG
84841: PUSH
84842: LD_INT 2
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: PUSH
84849: LD_INT 3
84851: NEG
84852: PUSH
84853: LD_INT 2
84855: NEG
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84886: LD_ADDR_VAR 0 32
84890: PUSH
84891: LD_INT 0
84893: PUSH
84894: LD_INT 0
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: LD_INT 0
84903: PUSH
84904: LD_INT 1
84906: NEG
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: PUSH
84912: LD_INT 1
84914: PUSH
84915: LD_INT 0
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 1
84924: PUSH
84925: LD_INT 1
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: PUSH
84932: LD_INT 0
84934: PUSH
84935: LD_INT 1
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: PUSH
84942: LD_INT 1
84944: NEG
84945: PUSH
84946: LD_INT 0
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: PUSH
84953: LD_INT 1
84955: NEG
84956: PUSH
84957: LD_INT 1
84959: NEG
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 1
84967: NEG
84968: PUSH
84969: LD_INT 2
84971: NEG
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 0
84979: PUSH
84980: LD_INT 2
84982: NEG
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: LD_INT 1
84993: NEG
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 2
85001: PUSH
85002: LD_INT 1
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 2
85011: PUSH
85012: LD_INT 2
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 1
85021: PUSH
85022: LD_INT 2
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 0
85031: PUSH
85032: LD_INT 2
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 1
85041: NEG
85042: PUSH
85043: LD_INT 1
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PUSH
85050: LD_INT 2
85052: NEG
85053: PUSH
85054: LD_INT 0
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 2
85063: NEG
85064: PUSH
85065: LD_INT 1
85067: NEG
85068: PUSH
85069: EMPTY
85070: LIST
85071: LIST
85072: PUSH
85073: LD_INT 1
85075: NEG
85076: PUSH
85077: LD_INT 3
85079: NEG
85080: PUSH
85081: EMPTY
85082: LIST
85083: LIST
85084: PUSH
85085: LD_INT 1
85087: PUSH
85088: LD_INT 2
85090: NEG
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: PUSH
85096: LD_INT 3
85098: PUSH
85099: LD_INT 2
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 2
85108: PUSH
85109: LD_INT 3
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 2
85118: NEG
85119: PUSH
85120: LD_INT 1
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 3
85129: NEG
85130: PUSH
85131: LD_INT 1
85133: NEG
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: EMPTY
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: LIST
85145: LIST
85146: LIST
85147: LIST
85148: LIST
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85164: LD_ADDR_VAR 0 33
85168: PUSH
85169: LD_INT 0
85171: PUSH
85172: LD_INT 0
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 0
85181: PUSH
85182: LD_INT 1
85184: NEG
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 1
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 1
85202: PUSH
85203: LD_INT 1
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 0
85212: PUSH
85213: LD_INT 1
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: PUSH
85220: LD_INT 1
85222: NEG
85223: PUSH
85224: LD_INT 0
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: LD_INT 1
85237: NEG
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 1
85245: NEG
85246: PUSH
85247: LD_INT 2
85249: NEG
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 1
85257: PUSH
85258: LD_INT 1
85260: NEG
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 2
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 2
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 1
85288: PUSH
85289: LD_INT 2
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 0
85298: PUSH
85299: LD_INT 2
85301: PUSH
85302: EMPTY
85303: LIST
85304: LIST
85305: PUSH
85306: LD_INT 1
85308: NEG
85309: PUSH
85310: LD_INT 1
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: PUSH
85317: LD_INT 2
85319: NEG
85320: PUSH
85321: LD_INT 0
85323: PUSH
85324: EMPTY
85325: LIST
85326: LIST
85327: PUSH
85328: LD_INT 2
85330: NEG
85331: PUSH
85332: LD_INT 1
85334: NEG
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 2
85342: NEG
85343: PUSH
85344: LD_INT 2
85346: NEG
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PUSH
85352: LD_INT 2
85354: NEG
85355: PUSH
85356: LD_INT 3
85358: NEG
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 2
85366: PUSH
85367: LD_INT 1
85369: NEG
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 3
85377: PUSH
85378: LD_INT 1
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 1
85387: PUSH
85388: LD_INT 3
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: PUSH
85395: LD_INT 1
85397: NEG
85398: PUSH
85399: LD_INT 2
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: PUSH
85406: LD_INT 3
85408: NEG
85409: PUSH
85410: LD_INT 2
85412: NEG
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: LIST
85438: LIST
85439: LIST
85440: LIST
85441: LIST
85442: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85443: LD_ADDR_VAR 0 34
85447: PUSH
85448: LD_INT 0
85450: PUSH
85451: LD_INT 0
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 0
85460: PUSH
85461: LD_INT 1
85463: NEG
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: PUSH
85469: LD_INT 1
85471: PUSH
85472: LD_INT 0
85474: PUSH
85475: EMPTY
85476: LIST
85477: LIST
85478: PUSH
85479: LD_INT 1
85481: PUSH
85482: LD_INT 1
85484: PUSH
85485: EMPTY
85486: LIST
85487: LIST
85488: PUSH
85489: LD_INT 0
85491: PUSH
85492: LD_INT 1
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: PUSH
85499: LD_INT 1
85501: NEG
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 1
85512: NEG
85513: PUSH
85514: LD_INT 1
85516: NEG
85517: PUSH
85518: EMPTY
85519: LIST
85520: LIST
85521: PUSH
85522: LD_INT 1
85524: NEG
85525: PUSH
85526: LD_INT 2
85528: NEG
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: LD_INT 2
85539: NEG
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: PUSH
85545: LD_INT 1
85547: PUSH
85548: LD_INT 1
85550: NEG
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 2
85558: PUSH
85559: LD_INT 1
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 2
85568: PUSH
85569: LD_INT 2
85571: PUSH
85572: EMPTY
85573: LIST
85574: LIST
85575: PUSH
85576: LD_INT 1
85578: PUSH
85579: LD_INT 2
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 1
85588: NEG
85589: PUSH
85590: LD_INT 1
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 2
85599: NEG
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: EMPTY
85605: LIST
85606: LIST
85607: PUSH
85608: LD_INT 2
85610: NEG
85611: PUSH
85612: LD_INT 1
85614: NEG
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 2
85622: NEG
85623: PUSH
85624: LD_INT 2
85626: NEG
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 1
85634: NEG
85635: PUSH
85636: LD_INT 3
85638: NEG
85639: PUSH
85640: EMPTY
85641: LIST
85642: LIST
85643: PUSH
85644: LD_INT 1
85646: PUSH
85647: LD_INT 2
85649: NEG
85650: PUSH
85651: EMPTY
85652: LIST
85653: LIST
85654: PUSH
85655: LD_INT 3
85657: PUSH
85658: LD_INT 2
85660: PUSH
85661: EMPTY
85662: LIST
85663: LIST
85664: PUSH
85665: LD_INT 2
85667: PUSH
85668: LD_INT 3
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PUSH
85675: LD_INT 2
85677: NEG
85678: PUSH
85679: LD_INT 1
85681: PUSH
85682: EMPTY
85683: LIST
85684: LIST
85685: PUSH
85686: LD_INT 3
85688: NEG
85689: PUSH
85690: LD_INT 1
85692: NEG
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: EMPTY
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: LIST
85720: LIST
85721: LIST
85722: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85723: LD_ADDR_VAR 0 35
85727: PUSH
85728: LD_INT 0
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 0
85740: PUSH
85741: LD_INT 1
85743: NEG
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 1
85751: PUSH
85752: LD_INT 0
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 1
85761: PUSH
85762: LD_INT 1
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: LD_INT 1
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 1
85781: NEG
85782: PUSH
85783: LD_INT 0
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 1
85792: NEG
85793: PUSH
85794: LD_INT 1
85796: NEG
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 2
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 2
85814: NEG
85815: PUSH
85816: LD_INT 1
85818: NEG
85819: PUSH
85820: EMPTY
85821: LIST
85822: LIST
85823: PUSH
85824: EMPTY
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85835: LD_ADDR_VAR 0 36
85839: PUSH
85840: LD_INT 0
85842: PUSH
85843: LD_INT 0
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 0
85852: PUSH
85853: LD_INT 1
85855: NEG
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 1
85863: PUSH
85864: LD_INT 0
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 1
85873: PUSH
85874: LD_INT 1
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 0
85883: PUSH
85884: LD_INT 1
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 1
85893: NEG
85894: PUSH
85895: LD_INT 0
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PUSH
85902: LD_INT 1
85904: NEG
85905: PUSH
85906: LD_INT 1
85908: NEG
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: LD_INT 2
85920: NEG
85921: PUSH
85922: EMPTY
85923: LIST
85924: LIST
85925: PUSH
85926: LD_INT 1
85928: PUSH
85929: LD_INT 2
85931: PUSH
85932: EMPTY
85933: LIST
85934: LIST
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85947: LD_ADDR_VAR 0 37
85951: PUSH
85952: LD_INT 0
85954: PUSH
85955: LD_INT 0
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 0
85964: PUSH
85965: LD_INT 1
85967: NEG
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: LD_INT 1
85975: PUSH
85976: LD_INT 0
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: PUSH
85983: LD_INT 1
85985: PUSH
85986: LD_INT 1
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 0
85995: PUSH
85996: LD_INT 1
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 1
86005: NEG
86006: PUSH
86007: LD_INT 0
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: PUSH
86014: LD_INT 1
86016: NEG
86017: PUSH
86018: LD_INT 1
86020: NEG
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PUSH
86026: LD_INT 1
86028: PUSH
86029: LD_INT 1
86031: NEG
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 1
86039: NEG
86040: PUSH
86041: LD_INT 1
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: LIST
86058: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86059: LD_ADDR_VAR 0 38
86063: PUSH
86064: LD_INT 0
86066: PUSH
86067: LD_INT 0
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 0
86076: PUSH
86077: LD_INT 1
86079: NEG
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: LD_INT 0
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 1
86097: PUSH
86098: LD_INT 1
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 0
86107: PUSH
86108: LD_INT 1
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 1
86117: NEG
86118: PUSH
86119: LD_INT 0
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: LD_INT 1
86128: NEG
86129: PUSH
86130: LD_INT 1
86132: NEG
86133: PUSH
86134: EMPTY
86135: LIST
86136: LIST
86137: PUSH
86138: LD_INT 2
86140: PUSH
86141: LD_INT 1
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: PUSH
86148: LD_INT 2
86150: NEG
86151: PUSH
86152: LD_INT 1
86154: NEG
86155: PUSH
86156: EMPTY
86157: LIST
86158: LIST
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86171: LD_ADDR_VAR 0 39
86175: PUSH
86176: LD_INT 0
86178: PUSH
86179: LD_INT 0
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 0
86188: PUSH
86189: LD_INT 1
86191: NEG
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 1
86199: PUSH
86200: LD_INT 0
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 1
86209: PUSH
86210: LD_INT 1
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 0
86219: PUSH
86220: LD_INT 1
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: PUSH
86227: LD_INT 1
86229: NEG
86230: PUSH
86231: LD_INT 0
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: PUSH
86238: LD_INT 1
86240: NEG
86241: PUSH
86242: LD_INT 1
86244: NEG
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 1
86252: NEG
86253: PUSH
86254: LD_INT 2
86256: NEG
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 1
86264: PUSH
86265: LD_INT 2
86267: PUSH
86268: EMPTY
86269: LIST
86270: LIST
86271: PUSH
86272: EMPTY
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: LIST
86280: LIST
86281: LIST
86282: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86283: LD_ADDR_VAR 0 40
86287: PUSH
86288: LD_INT 0
86290: PUSH
86291: LD_INT 0
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 0
86300: PUSH
86301: LD_INT 1
86303: NEG
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 1
86311: PUSH
86312: LD_INT 0
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 1
86321: PUSH
86322: LD_INT 1
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 0
86331: PUSH
86332: LD_INT 1
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PUSH
86339: LD_INT 1
86341: NEG
86342: PUSH
86343: LD_INT 0
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 1
86352: NEG
86353: PUSH
86354: LD_INT 1
86356: NEG
86357: PUSH
86358: EMPTY
86359: LIST
86360: LIST
86361: PUSH
86362: LD_INT 1
86364: PUSH
86365: LD_INT 1
86367: NEG
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: PUSH
86373: LD_INT 1
86375: NEG
86376: PUSH
86377: LD_INT 1
86379: PUSH
86380: EMPTY
86381: LIST
86382: LIST
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: LIST
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86395: LD_ADDR_VAR 0 41
86399: PUSH
86400: LD_INT 0
86402: PUSH
86403: LD_INT 0
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: LD_INT 0
86412: PUSH
86413: LD_INT 1
86415: NEG
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 1
86423: PUSH
86424: LD_INT 0
86426: PUSH
86427: EMPTY
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 1
86433: PUSH
86434: LD_INT 1
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 0
86443: PUSH
86444: LD_INT 1
86446: PUSH
86447: EMPTY
86448: LIST
86449: LIST
86450: PUSH
86451: LD_INT 1
86453: NEG
86454: PUSH
86455: LD_INT 0
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: LD_INT 1
86464: NEG
86465: PUSH
86466: LD_INT 1
86468: NEG
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: PUSH
86474: LD_INT 1
86476: NEG
86477: PUSH
86478: LD_INT 2
86480: NEG
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: PUSH
86486: LD_INT 1
86488: PUSH
86489: LD_INT 1
86491: NEG
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 2
86499: PUSH
86500: LD_INT 0
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 2
86509: PUSH
86510: LD_INT 1
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: LD_INT 2
86519: PUSH
86520: LD_INT 2
86522: PUSH
86523: EMPTY
86524: LIST
86525: LIST
86526: PUSH
86527: LD_INT 1
86529: PUSH
86530: LD_INT 2
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: PUSH
86537: LD_INT 1
86539: NEG
86540: PUSH
86541: LD_INT 1
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 2
86550: NEG
86551: PUSH
86552: LD_INT 0
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 2
86561: NEG
86562: PUSH
86563: LD_INT 1
86565: NEG
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 2
86573: NEG
86574: PUSH
86575: LD_INT 2
86577: NEG
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: PUSH
86583: LD_INT 2
86585: NEG
86586: PUSH
86587: LD_INT 3
86589: NEG
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 2
86597: PUSH
86598: LD_INT 1
86600: NEG
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 3
86608: PUSH
86609: LD_INT 0
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 3
86618: PUSH
86619: LD_INT 1
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PUSH
86626: LD_INT 3
86628: PUSH
86629: LD_INT 2
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 3
86638: PUSH
86639: LD_INT 3
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 2
86648: PUSH
86649: LD_INT 3
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 2
86658: NEG
86659: PUSH
86660: LD_INT 1
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 3
86669: NEG
86670: PUSH
86671: LD_INT 0
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PUSH
86678: LD_INT 3
86680: NEG
86681: PUSH
86682: LD_INT 1
86684: NEG
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 3
86692: NEG
86693: PUSH
86694: LD_INT 2
86696: NEG
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: LD_INT 3
86704: NEG
86705: PUSH
86706: LD_INT 3
86708: NEG
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: LIST
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86745: LD_ADDR_VAR 0 42
86749: PUSH
86750: LD_INT 0
86752: PUSH
86753: LD_INT 0
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: PUSH
86760: LD_INT 0
86762: PUSH
86763: LD_INT 1
86765: NEG
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 1
86773: PUSH
86774: LD_INT 0
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: LD_INT 1
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 0
86793: PUSH
86794: LD_INT 1
86796: PUSH
86797: EMPTY
86798: LIST
86799: LIST
86800: PUSH
86801: LD_INT 1
86803: NEG
86804: PUSH
86805: LD_INT 0
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 1
86814: NEG
86815: PUSH
86816: LD_INT 1
86818: NEG
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PUSH
86824: LD_INT 1
86826: NEG
86827: PUSH
86828: LD_INT 2
86830: NEG
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 0
86838: PUSH
86839: LD_INT 2
86841: NEG
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 1
86849: PUSH
86850: LD_INT 1
86852: NEG
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 2
86860: PUSH
86861: LD_INT 1
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 2
86870: PUSH
86871: LD_INT 2
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 1
86880: PUSH
86881: LD_INT 2
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 0
86890: PUSH
86891: LD_INT 2
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 1
86900: NEG
86901: PUSH
86902: LD_INT 1
86904: PUSH
86905: EMPTY
86906: LIST
86907: LIST
86908: PUSH
86909: LD_INT 2
86911: NEG
86912: PUSH
86913: LD_INT 1
86915: NEG
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 2
86923: NEG
86924: PUSH
86925: LD_INT 2
86927: NEG
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 2
86935: NEG
86936: PUSH
86937: LD_INT 3
86939: NEG
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PUSH
86945: LD_INT 1
86947: NEG
86948: PUSH
86949: LD_INT 3
86951: NEG
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 0
86959: PUSH
86960: LD_INT 3
86962: NEG
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 1
86970: PUSH
86971: LD_INT 2
86973: NEG
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 3
86981: PUSH
86982: LD_INT 2
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 3
86991: PUSH
86992: LD_INT 3
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 2
87001: PUSH
87002: LD_INT 3
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 1
87011: PUSH
87012: LD_INT 3
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 0
87021: PUSH
87022: LD_INT 3
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 1
87031: NEG
87032: PUSH
87033: LD_INT 2
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PUSH
87040: LD_INT 3
87042: NEG
87043: PUSH
87044: LD_INT 2
87046: NEG
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: PUSH
87052: LD_INT 3
87054: NEG
87055: PUSH
87056: LD_INT 3
87058: NEG
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87095: LD_ADDR_VAR 0 43
87099: PUSH
87100: LD_INT 0
87102: PUSH
87103: LD_INT 0
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 0
87112: PUSH
87113: LD_INT 1
87115: NEG
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: LD_INT 1
87123: PUSH
87124: LD_INT 0
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 1
87133: PUSH
87134: LD_INT 1
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: PUSH
87141: LD_INT 0
87143: PUSH
87144: LD_INT 1
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 1
87153: NEG
87154: PUSH
87155: LD_INT 0
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 1
87164: NEG
87165: PUSH
87166: LD_INT 1
87168: NEG
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 1
87176: NEG
87177: PUSH
87178: LD_INT 2
87180: NEG
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 0
87188: PUSH
87189: LD_INT 2
87191: NEG
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 1
87199: PUSH
87200: LD_INT 1
87202: NEG
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 2
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 2
87220: PUSH
87221: LD_INT 1
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: PUSH
87228: LD_INT 1
87230: PUSH
87231: LD_INT 2
87233: PUSH
87234: EMPTY
87235: LIST
87236: LIST
87237: PUSH
87238: LD_INT 0
87240: PUSH
87241: LD_INT 2
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: PUSH
87248: LD_INT 1
87250: NEG
87251: PUSH
87252: LD_INT 1
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: LD_INT 2
87261: NEG
87262: PUSH
87263: LD_INT 0
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PUSH
87270: LD_INT 2
87272: NEG
87273: PUSH
87274: LD_INT 1
87276: NEG
87277: PUSH
87278: EMPTY
87279: LIST
87280: LIST
87281: PUSH
87282: LD_INT 1
87284: NEG
87285: PUSH
87286: LD_INT 3
87288: NEG
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: LD_INT 3
87299: NEG
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PUSH
87305: LD_INT 1
87307: PUSH
87308: LD_INT 2
87310: NEG
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 2
87318: PUSH
87319: LD_INT 1
87321: NEG
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 3
87329: PUSH
87330: LD_INT 0
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 3
87339: PUSH
87340: LD_INT 1
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 1
87349: PUSH
87350: LD_INT 3
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 0
87359: PUSH
87360: LD_INT 3
87362: PUSH
87363: EMPTY
87364: LIST
87365: LIST
87366: PUSH
87367: LD_INT 1
87369: NEG
87370: PUSH
87371: LD_INT 2
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 2
87380: NEG
87381: PUSH
87382: LD_INT 1
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 3
87391: NEG
87392: PUSH
87393: LD_INT 0
87395: PUSH
87396: EMPTY
87397: LIST
87398: LIST
87399: PUSH
87400: LD_INT 3
87402: NEG
87403: PUSH
87404: LD_INT 1
87406: NEG
87407: PUSH
87408: EMPTY
87409: LIST
87410: LIST
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87443: LD_ADDR_VAR 0 44
87447: PUSH
87448: LD_INT 0
87450: PUSH
87451: LD_INT 0
87453: PUSH
87454: EMPTY
87455: LIST
87456: LIST
87457: PUSH
87458: LD_INT 0
87460: PUSH
87461: LD_INT 1
87463: NEG
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: LD_INT 1
87471: PUSH
87472: LD_INT 0
87474: PUSH
87475: EMPTY
87476: LIST
87477: LIST
87478: PUSH
87479: LD_INT 1
87481: PUSH
87482: LD_INT 1
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: LD_INT 0
87491: PUSH
87492: LD_INT 1
87494: PUSH
87495: EMPTY
87496: LIST
87497: LIST
87498: PUSH
87499: LD_INT 1
87501: NEG
87502: PUSH
87503: LD_INT 0
87505: PUSH
87506: EMPTY
87507: LIST
87508: LIST
87509: PUSH
87510: LD_INT 1
87512: NEG
87513: PUSH
87514: LD_INT 1
87516: NEG
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 1
87524: NEG
87525: PUSH
87526: LD_INT 2
87528: NEG
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 1
87536: PUSH
87537: LD_INT 1
87539: NEG
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 2
87547: PUSH
87548: LD_INT 0
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 2
87557: PUSH
87558: LD_INT 1
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: PUSH
87565: LD_INT 2
87567: PUSH
87568: LD_INT 2
87570: PUSH
87571: EMPTY
87572: LIST
87573: LIST
87574: PUSH
87575: LD_INT 1
87577: PUSH
87578: LD_INT 2
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: LD_INT 1
87587: NEG
87588: PUSH
87589: LD_INT 1
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 2
87598: NEG
87599: PUSH
87600: LD_INT 0
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 2
87609: NEG
87610: PUSH
87611: LD_INT 1
87613: NEG
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 2
87621: NEG
87622: PUSH
87623: LD_INT 2
87625: NEG
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 2
87633: NEG
87634: PUSH
87635: LD_INT 3
87637: NEG
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 2
87645: PUSH
87646: LD_INT 1
87648: NEG
87649: PUSH
87650: EMPTY
87651: LIST
87652: LIST
87653: PUSH
87654: LD_INT 3
87656: PUSH
87657: LD_INT 0
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 3
87666: PUSH
87667: LD_INT 1
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 3
87676: PUSH
87677: LD_INT 2
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 3
87686: PUSH
87687: LD_INT 3
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PUSH
87694: LD_INT 2
87696: PUSH
87697: LD_INT 3
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: LD_INT 2
87706: NEG
87707: PUSH
87708: LD_INT 1
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 3
87717: NEG
87718: PUSH
87719: LD_INT 0
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 3
87728: NEG
87729: PUSH
87730: LD_INT 1
87732: NEG
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 3
87740: NEG
87741: PUSH
87742: LD_INT 2
87744: NEG
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 3
87752: NEG
87753: PUSH
87754: LD_INT 3
87756: NEG
87757: PUSH
87758: EMPTY
87759: LIST
87760: LIST
87761: PUSH
87762: EMPTY
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87793: LD_ADDR_VAR 0 45
87797: PUSH
87798: LD_INT 0
87800: PUSH
87801: LD_INT 0
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: LD_INT 0
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: LD_INT 1
87821: PUSH
87822: LD_INT 0
87824: PUSH
87825: EMPTY
87826: LIST
87827: LIST
87828: PUSH
87829: LD_INT 1
87831: PUSH
87832: LD_INT 1
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 0
87841: PUSH
87842: LD_INT 1
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 1
87851: NEG
87852: PUSH
87853: LD_INT 0
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 1
87862: NEG
87863: PUSH
87864: LD_INT 1
87866: NEG
87867: PUSH
87868: EMPTY
87869: LIST
87870: LIST
87871: PUSH
87872: LD_INT 1
87874: NEG
87875: PUSH
87876: LD_INT 2
87878: NEG
87879: PUSH
87880: EMPTY
87881: LIST
87882: LIST
87883: PUSH
87884: LD_INT 0
87886: PUSH
87887: LD_INT 2
87889: NEG
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: PUSH
87895: LD_INT 1
87897: PUSH
87898: LD_INT 1
87900: NEG
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 2
87908: PUSH
87909: LD_INT 1
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 2
87918: PUSH
87919: LD_INT 2
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 1
87928: PUSH
87929: LD_INT 2
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 0
87938: PUSH
87939: LD_INT 2
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 1
87948: NEG
87949: PUSH
87950: LD_INT 1
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PUSH
87957: LD_INT 2
87959: NEG
87960: PUSH
87961: LD_INT 1
87963: NEG
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 2
87971: NEG
87972: PUSH
87973: LD_INT 2
87975: NEG
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 2
87983: NEG
87984: PUSH
87985: LD_INT 3
87987: NEG
87988: PUSH
87989: EMPTY
87990: LIST
87991: LIST
87992: PUSH
87993: LD_INT 1
87995: NEG
87996: PUSH
87997: LD_INT 3
87999: NEG
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 0
88007: PUSH
88008: LD_INT 3
88010: NEG
88011: PUSH
88012: EMPTY
88013: LIST
88014: LIST
88015: PUSH
88016: LD_INT 1
88018: PUSH
88019: LD_INT 2
88021: NEG
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 3
88029: PUSH
88030: LD_INT 2
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: LD_INT 3
88039: PUSH
88040: LD_INT 3
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: PUSH
88047: LD_INT 2
88049: PUSH
88050: LD_INT 3
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PUSH
88057: LD_INT 1
88059: PUSH
88060: LD_INT 3
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PUSH
88067: LD_INT 0
88069: PUSH
88070: LD_INT 3
88072: PUSH
88073: EMPTY
88074: LIST
88075: LIST
88076: PUSH
88077: LD_INT 1
88079: NEG
88080: PUSH
88081: LD_INT 2
88083: PUSH
88084: EMPTY
88085: LIST
88086: LIST
88087: PUSH
88088: LD_INT 3
88090: NEG
88091: PUSH
88092: LD_INT 2
88094: NEG
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 3
88102: NEG
88103: PUSH
88104: LD_INT 3
88106: NEG
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88143: LD_ADDR_VAR 0 46
88147: PUSH
88148: LD_INT 0
88150: PUSH
88151: LD_INT 0
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PUSH
88158: LD_INT 0
88160: PUSH
88161: LD_INT 1
88163: NEG
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 1
88171: PUSH
88172: LD_INT 0
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 1
88181: PUSH
88182: LD_INT 1
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: PUSH
88189: LD_INT 0
88191: PUSH
88192: LD_INT 1
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: NEG
88202: PUSH
88203: LD_INT 0
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 1
88212: NEG
88213: PUSH
88214: LD_INT 1
88216: NEG
88217: PUSH
88218: EMPTY
88219: LIST
88220: LIST
88221: PUSH
88222: LD_INT 1
88224: NEG
88225: PUSH
88226: LD_INT 2
88228: NEG
88229: PUSH
88230: EMPTY
88231: LIST
88232: LIST
88233: PUSH
88234: LD_INT 0
88236: PUSH
88237: LD_INT 2
88239: NEG
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 1
88247: PUSH
88248: LD_INT 1
88250: NEG
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 2
88258: PUSH
88259: LD_INT 0
88261: PUSH
88262: EMPTY
88263: LIST
88264: LIST
88265: PUSH
88266: LD_INT 2
88268: PUSH
88269: LD_INT 1
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: PUSH
88276: LD_INT 1
88278: PUSH
88279: LD_INT 2
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PUSH
88286: LD_INT 0
88288: PUSH
88289: LD_INT 2
88291: PUSH
88292: EMPTY
88293: LIST
88294: LIST
88295: PUSH
88296: LD_INT 1
88298: NEG
88299: PUSH
88300: LD_INT 1
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_INT 2
88309: NEG
88310: PUSH
88311: LD_INT 0
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: PUSH
88318: LD_INT 2
88320: NEG
88321: PUSH
88322: LD_INT 1
88324: NEG
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: PUSH
88330: LD_INT 1
88332: NEG
88333: PUSH
88334: LD_INT 3
88336: NEG
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 0
88344: PUSH
88345: LD_INT 3
88347: NEG
88348: PUSH
88349: EMPTY
88350: LIST
88351: LIST
88352: PUSH
88353: LD_INT 1
88355: PUSH
88356: LD_INT 2
88358: NEG
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 2
88366: PUSH
88367: LD_INT 1
88369: NEG
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 3
88377: PUSH
88378: LD_INT 0
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: PUSH
88385: LD_INT 3
88387: PUSH
88388: LD_INT 1
88390: PUSH
88391: EMPTY
88392: LIST
88393: LIST
88394: PUSH
88395: LD_INT 1
88397: PUSH
88398: LD_INT 3
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 0
88407: PUSH
88408: LD_INT 3
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 1
88417: NEG
88418: PUSH
88419: LD_INT 2
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: PUSH
88426: LD_INT 2
88428: NEG
88429: PUSH
88430: LD_INT 1
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: PUSH
88437: LD_INT 3
88439: NEG
88440: PUSH
88441: LD_INT 0
88443: PUSH
88444: EMPTY
88445: LIST
88446: LIST
88447: PUSH
88448: LD_INT 3
88450: NEG
88451: PUSH
88452: LD_INT 1
88454: NEG
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88491: LD_ADDR_VAR 0 47
88495: PUSH
88496: LD_INT 0
88498: PUSH
88499: LD_INT 0
88501: PUSH
88502: EMPTY
88503: LIST
88504: LIST
88505: PUSH
88506: LD_INT 0
88508: PUSH
88509: LD_INT 1
88511: NEG
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: LD_INT 1
88519: PUSH
88520: LD_INT 0
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: PUSH
88527: LD_INT 1
88529: PUSH
88530: LD_INT 1
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: PUSH
88537: LD_INT 0
88539: PUSH
88540: LD_INT 1
88542: PUSH
88543: EMPTY
88544: LIST
88545: LIST
88546: PUSH
88547: LD_INT 1
88549: NEG
88550: PUSH
88551: LD_INT 0
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 1
88560: NEG
88561: PUSH
88562: LD_INT 1
88564: NEG
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 1
88572: NEG
88573: PUSH
88574: LD_INT 2
88576: NEG
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: PUSH
88582: LD_INT 0
88584: PUSH
88585: LD_INT 2
88587: NEG
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 1
88595: PUSH
88596: LD_INT 1
88598: NEG
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 2
88606: NEG
88607: PUSH
88608: LD_INT 1
88610: NEG
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 2
88618: NEG
88619: PUSH
88620: LD_INT 2
88622: NEG
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: EMPTY
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88642: LD_ADDR_VAR 0 48
88646: PUSH
88647: LD_INT 0
88649: PUSH
88650: LD_INT 0
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: LD_INT 0
88659: PUSH
88660: LD_INT 1
88662: NEG
88663: PUSH
88664: EMPTY
88665: LIST
88666: LIST
88667: PUSH
88668: LD_INT 1
88670: PUSH
88671: LD_INT 0
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: PUSH
88678: LD_INT 1
88680: PUSH
88681: LD_INT 1
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 0
88690: PUSH
88691: LD_INT 1
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 1
88700: NEG
88701: PUSH
88702: LD_INT 0
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 1
88711: NEG
88712: PUSH
88713: LD_INT 1
88715: NEG
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: LD_INT 1
88723: NEG
88724: PUSH
88725: LD_INT 2
88727: NEG
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 0
88735: PUSH
88736: LD_INT 2
88738: NEG
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 1
88746: PUSH
88747: LD_INT 1
88749: NEG
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 2
88757: PUSH
88758: LD_INT 0
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: LD_INT 2
88767: PUSH
88768: LD_INT 1
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88789: LD_ADDR_VAR 0 49
88793: PUSH
88794: LD_INT 0
88796: PUSH
88797: LD_INT 0
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 0
88806: PUSH
88807: LD_INT 1
88809: NEG
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 1
88817: PUSH
88818: LD_INT 0
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: PUSH
88825: LD_INT 1
88827: PUSH
88828: LD_INT 1
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 0
88837: PUSH
88838: LD_INT 1
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: PUSH
88845: LD_INT 1
88847: NEG
88848: PUSH
88849: LD_INT 0
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PUSH
88856: LD_INT 1
88858: NEG
88859: PUSH
88860: LD_INT 1
88862: NEG
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 1
88870: PUSH
88871: LD_INT 1
88873: NEG
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 2
88881: PUSH
88882: LD_INT 0
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 2
88891: PUSH
88892: LD_INT 1
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 2
88901: PUSH
88902: LD_INT 2
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: LD_INT 1
88911: PUSH
88912: LD_INT 2
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: EMPTY
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88933: LD_ADDR_VAR 0 50
88937: PUSH
88938: LD_INT 0
88940: PUSH
88941: LD_INT 0
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: LD_INT 0
88950: PUSH
88951: LD_INT 1
88953: NEG
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: LD_INT 1
88961: PUSH
88962: LD_INT 0
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 1
88971: PUSH
88972: LD_INT 1
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: LD_INT 0
88981: PUSH
88982: LD_INT 1
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: LD_INT 1
88991: NEG
88992: PUSH
88993: LD_INT 0
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 1
89002: NEG
89003: PUSH
89004: LD_INT 1
89006: NEG
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PUSH
89012: LD_INT 2
89014: PUSH
89015: LD_INT 1
89017: PUSH
89018: EMPTY
89019: LIST
89020: LIST
89021: PUSH
89022: LD_INT 2
89024: PUSH
89025: LD_INT 2
89027: PUSH
89028: EMPTY
89029: LIST
89030: LIST
89031: PUSH
89032: LD_INT 1
89034: PUSH
89035: LD_INT 2
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: LD_INT 2
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: LD_INT 1
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: LIST
89067: LIST
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89077: LD_ADDR_VAR 0 51
89081: PUSH
89082: LD_INT 0
89084: PUSH
89085: LD_INT 0
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: PUSH
89092: LD_INT 0
89094: PUSH
89095: LD_INT 1
89097: NEG
89098: PUSH
89099: EMPTY
89100: LIST
89101: LIST
89102: PUSH
89103: LD_INT 1
89105: PUSH
89106: LD_INT 0
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: LD_INT 1
89115: PUSH
89116: LD_INT 1
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 0
89125: PUSH
89126: LD_INT 1
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: LD_INT 1
89135: NEG
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 1
89146: NEG
89147: PUSH
89148: LD_INT 1
89150: NEG
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 1
89158: PUSH
89159: LD_INT 2
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: LD_INT 2
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 1
89178: NEG
89179: PUSH
89180: LD_INT 1
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 2
89189: NEG
89190: PUSH
89191: LD_INT 0
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: LD_INT 2
89200: NEG
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89224: LD_ADDR_VAR 0 52
89228: PUSH
89229: LD_INT 0
89231: PUSH
89232: LD_INT 0
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: LD_INT 0
89241: PUSH
89242: LD_INT 1
89244: NEG
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: LD_INT 1
89252: PUSH
89253: LD_INT 0
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: PUSH
89260: LD_INT 1
89262: PUSH
89263: LD_INT 1
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: PUSH
89270: LD_INT 0
89272: PUSH
89273: LD_INT 1
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: LD_INT 1
89282: NEG
89283: PUSH
89284: LD_INT 0
89286: PUSH
89287: EMPTY
89288: LIST
89289: LIST
89290: PUSH
89291: LD_INT 1
89293: NEG
89294: PUSH
89295: LD_INT 1
89297: NEG
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 1
89305: NEG
89306: PUSH
89307: LD_INT 2
89309: NEG
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: PUSH
89315: LD_INT 1
89317: NEG
89318: PUSH
89319: LD_INT 1
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 2
89328: NEG
89329: PUSH
89330: LD_INT 0
89332: PUSH
89333: EMPTY
89334: LIST
89335: LIST
89336: PUSH
89337: LD_INT 2
89339: NEG
89340: PUSH
89341: LD_INT 1
89343: NEG
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: PUSH
89349: LD_INT 2
89351: NEG
89352: PUSH
89353: LD_INT 2
89355: NEG
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89375: LD_ADDR_VAR 0 53
89379: PUSH
89380: LD_INT 0
89382: PUSH
89383: LD_INT 0
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PUSH
89390: LD_INT 0
89392: PUSH
89393: LD_INT 1
89395: NEG
89396: PUSH
89397: EMPTY
89398: LIST
89399: LIST
89400: PUSH
89401: LD_INT 1
89403: PUSH
89404: LD_INT 0
89406: PUSH
89407: EMPTY
89408: LIST
89409: LIST
89410: PUSH
89411: LD_INT 1
89413: PUSH
89414: LD_INT 1
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PUSH
89421: LD_INT 0
89423: PUSH
89424: LD_INT 1
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: PUSH
89431: LD_INT 1
89433: NEG
89434: PUSH
89435: LD_INT 0
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 1
89444: NEG
89445: PUSH
89446: LD_INT 1
89448: NEG
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 1
89456: NEG
89457: PUSH
89458: LD_INT 2
89460: NEG
89461: PUSH
89462: EMPTY
89463: LIST
89464: LIST
89465: PUSH
89466: LD_INT 0
89468: PUSH
89469: LD_INT 2
89471: NEG
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: LD_INT 1
89479: PUSH
89480: LD_INT 1
89482: NEG
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: LD_INT 2
89490: PUSH
89491: LD_INT 0
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 2
89500: PUSH
89501: LD_INT 1
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: PUSH
89508: LD_INT 2
89510: PUSH
89511: LD_INT 2
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 1
89520: PUSH
89521: LD_INT 2
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PUSH
89528: LD_INT 0
89530: PUSH
89531: LD_INT 2
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PUSH
89538: LD_INT 1
89540: NEG
89541: PUSH
89542: LD_INT 1
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: PUSH
89549: LD_INT 2
89551: NEG
89552: PUSH
89553: LD_INT 0
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 2
89562: NEG
89563: PUSH
89564: LD_INT 1
89566: NEG
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: PUSH
89572: LD_INT 2
89574: NEG
89575: PUSH
89576: LD_INT 2
89578: NEG
89579: PUSH
89580: EMPTY
89581: LIST
89582: LIST
89583: PUSH
89584: EMPTY
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: LIST
89601: LIST
89602: LIST
89603: LIST
89604: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89605: LD_ADDR_VAR 0 54
89609: PUSH
89610: LD_INT 0
89612: PUSH
89613: LD_INT 0
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: PUSH
89620: LD_INT 0
89622: PUSH
89623: LD_INT 1
89625: NEG
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: LD_INT 1
89633: PUSH
89634: LD_INT 0
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: PUSH
89641: LD_INT 1
89643: PUSH
89644: LD_INT 1
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 0
89653: PUSH
89654: LD_INT 1
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 1
89663: NEG
89664: PUSH
89665: LD_INT 0
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 1
89674: NEG
89675: PUSH
89676: LD_INT 1
89678: NEG
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: PUSH
89684: LD_INT 1
89686: NEG
89687: PUSH
89688: LD_INT 2
89690: NEG
89691: PUSH
89692: EMPTY
89693: LIST
89694: LIST
89695: PUSH
89696: LD_INT 0
89698: PUSH
89699: LD_INT 2
89701: NEG
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: PUSH
89707: LD_INT 1
89709: PUSH
89710: LD_INT 1
89712: NEG
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 2
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 2
89730: PUSH
89731: LD_INT 1
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: PUSH
89738: LD_INT 2
89740: PUSH
89741: LD_INT 2
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PUSH
89748: LD_INT 1
89750: PUSH
89751: LD_INT 2
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 0
89760: PUSH
89761: LD_INT 2
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: PUSH
89768: LD_INT 1
89770: NEG
89771: PUSH
89772: LD_INT 1
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 2
89781: NEG
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 2
89792: NEG
89793: PUSH
89794: LD_INT 1
89796: NEG
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: LD_INT 2
89804: NEG
89805: PUSH
89806: LD_INT 2
89808: NEG
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: PUSH
89814: EMPTY
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89835: LD_ADDR_VAR 0 55
89839: PUSH
89840: LD_INT 0
89842: PUSH
89843: LD_INT 0
89845: PUSH
89846: EMPTY
89847: LIST
89848: LIST
89849: PUSH
89850: LD_INT 0
89852: PUSH
89853: LD_INT 1
89855: NEG
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: PUSH
89861: LD_INT 1
89863: PUSH
89864: LD_INT 0
89866: PUSH
89867: EMPTY
89868: LIST
89869: LIST
89870: PUSH
89871: LD_INT 1
89873: PUSH
89874: LD_INT 1
89876: PUSH
89877: EMPTY
89878: LIST
89879: LIST
89880: PUSH
89881: LD_INT 0
89883: PUSH
89884: LD_INT 1
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 1
89893: NEG
89894: PUSH
89895: LD_INT 0
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: LD_INT 1
89904: NEG
89905: PUSH
89906: LD_INT 1
89908: NEG
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 1
89916: NEG
89917: PUSH
89918: LD_INT 2
89920: NEG
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 0
89928: PUSH
89929: LD_INT 2
89931: NEG
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 1
89939: PUSH
89940: LD_INT 1
89942: NEG
89943: PUSH
89944: EMPTY
89945: LIST
89946: LIST
89947: PUSH
89948: LD_INT 2
89950: PUSH
89951: LD_INT 0
89953: PUSH
89954: EMPTY
89955: LIST
89956: LIST
89957: PUSH
89958: LD_INT 2
89960: PUSH
89961: LD_INT 1
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: PUSH
89968: LD_INT 2
89970: PUSH
89971: LD_INT 2
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: LD_INT 1
89980: PUSH
89981: LD_INT 2
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PUSH
89988: LD_INT 0
89990: PUSH
89991: LD_INT 2
89993: PUSH
89994: EMPTY
89995: LIST
89996: LIST
89997: PUSH
89998: LD_INT 1
90000: NEG
90001: PUSH
90002: LD_INT 1
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: PUSH
90009: LD_INT 2
90011: NEG
90012: PUSH
90013: LD_INT 0
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 2
90022: NEG
90023: PUSH
90024: LD_INT 1
90026: NEG
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: PUSH
90032: LD_INT 2
90034: NEG
90035: PUSH
90036: LD_INT 2
90038: NEG
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90065: LD_ADDR_VAR 0 56
90069: PUSH
90070: LD_INT 0
90072: PUSH
90073: LD_INT 0
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: LD_INT 0
90082: PUSH
90083: LD_INT 1
90085: NEG
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 1
90093: PUSH
90094: LD_INT 0
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 1
90103: PUSH
90104: LD_INT 1
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: PUSH
90111: LD_INT 0
90113: PUSH
90114: LD_INT 1
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 1
90123: NEG
90124: PUSH
90125: LD_INT 0
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 1
90134: NEG
90135: PUSH
90136: LD_INT 1
90138: NEG
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 1
90146: NEG
90147: PUSH
90148: LD_INT 2
90150: NEG
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: LD_INT 0
90158: PUSH
90159: LD_INT 2
90161: NEG
90162: PUSH
90163: EMPTY
90164: LIST
90165: LIST
90166: PUSH
90167: LD_INT 1
90169: PUSH
90170: LD_INT 1
90172: NEG
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 2
90180: PUSH
90181: LD_INT 0
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 2
90190: PUSH
90191: LD_INT 1
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: LD_INT 2
90200: PUSH
90201: LD_INT 2
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 1
90210: PUSH
90211: LD_INT 2
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: LD_INT 0
90220: PUSH
90221: LD_INT 2
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: LD_INT 1
90230: NEG
90231: PUSH
90232: LD_INT 1
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: LD_INT 2
90241: NEG
90242: PUSH
90243: LD_INT 0
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 2
90252: NEG
90253: PUSH
90254: LD_INT 1
90256: NEG
90257: PUSH
90258: EMPTY
90259: LIST
90260: LIST
90261: PUSH
90262: LD_INT 2
90264: NEG
90265: PUSH
90266: LD_INT 2
90268: NEG
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90295: LD_ADDR_VAR 0 57
90299: PUSH
90300: LD_INT 0
90302: PUSH
90303: LD_INT 0
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: PUSH
90310: LD_INT 0
90312: PUSH
90313: LD_INT 1
90315: NEG
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 1
90323: PUSH
90324: LD_INT 0
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 1
90333: PUSH
90334: LD_INT 1
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 0
90343: PUSH
90344: LD_INT 1
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 1
90353: NEG
90354: PUSH
90355: LD_INT 0
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 1
90364: NEG
90365: PUSH
90366: LD_INT 1
90368: NEG
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: PUSH
90374: LD_INT 1
90376: NEG
90377: PUSH
90378: LD_INT 2
90380: NEG
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: LD_INT 2
90391: NEG
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 1
90399: PUSH
90400: LD_INT 1
90402: NEG
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 2
90410: PUSH
90411: LD_INT 0
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 2
90420: PUSH
90421: LD_INT 1
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: LD_INT 2
90430: PUSH
90431: LD_INT 2
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: PUSH
90438: LD_INT 1
90440: PUSH
90441: LD_INT 2
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: PUSH
90448: LD_INT 0
90450: PUSH
90451: LD_INT 2
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: PUSH
90458: LD_INT 1
90460: NEG
90461: PUSH
90462: LD_INT 1
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 2
90471: NEG
90472: PUSH
90473: LD_INT 0
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 2
90482: NEG
90483: PUSH
90484: LD_INT 1
90486: NEG
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PUSH
90492: LD_INT 2
90494: NEG
90495: PUSH
90496: LD_INT 2
90498: NEG
90499: PUSH
90500: EMPTY
90501: LIST
90502: LIST
90503: PUSH
90504: EMPTY
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90525: LD_ADDR_VAR 0 58
90529: PUSH
90530: LD_INT 0
90532: PUSH
90533: LD_INT 0
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: PUSH
90540: LD_INT 0
90542: PUSH
90543: LD_INT 1
90545: NEG
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: LD_INT 1
90553: PUSH
90554: LD_INT 0
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: PUSH
90561: LD_INT 1
90563: PUSH
90564: LD_INT 1
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: LD_INT 0
90573: PUSH
90574: LD_INT 1
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 1
90583: NEG
90584: PUSH
90585: LD_INT 0
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: LD_INT 1
90594: NEG
90595: PUSH
90596: LD_INT 1
90598: NEG
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 1
90606: NEG
90607: PUSH
90608: LD_INT 2
90610: NEG
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 0
90618: PUSH
90619: LD_INT 2
90621: NEG
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PUSH
90627: LD_INT 1
90629: PUSH
90630: LD_INT 1
90632: NEG
90633: PUSH
90634: EMPTY
90635: LIST
90636: LIST
90637: PUSH
90638: LD_INT 2
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 2
90650: PUSH
90651: LD_INT 1
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: LD_INT 2
90660: PUSH
90661: LD_INT 2
90663: PUSH
90664: EMPTY
90665: LIST
90666: LIST
90667: PUSH
90668: LD_INT 1
90670: PUSH
90671: LD_INT 2
90673: PUSH
90674: EMPTY
90675: LIST
90676: LIST
90677: PUSH
90678: LD_INT 0
90680: PUSH
90681: LD_INT 2
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 1
90690: NEG
90691: PUSH
90692: LD_INT 1
90694: PUSH
90695: EMPTY
90696: LIST
90697: LIST
90698: PUSH
90699: LD_INT 2
90701: NEG
90702: PUSH
90703: LD_INT 0
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 2
90712: NEG
90713: PUSH
90714: LD_INT 1
90716: NEG
90717: PUSH
90718: EMPTY
90719: LIST
90720: LIST
90721: PUSH
90722: LD_INT 2
90724: NEG
90725: PUSH
90726: LD_INT 2
90728: NEG
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: EMPTY
90735: LIST
90736: LIST
90737: LIST
90738: LIST
90739: LIST
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90755: LD_ADDR_VAR 0 59
90759: PUSH
90760: LD_INT 0
90762: PUSH
90763: LD_INT 0
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: PUSH
90770: LD_INT 0
90772: PUSH
90773: LD_INT 1
90775: NEG
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 1
90783: PUSH
90784: LD_INT 0
90786: PUSH
90787: EMPTY
90788: LIST
90789: LIST
90790: PUSH
90791: LD_INT 1
90793: PUSH
90794: LD_INT 1
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: LD_INT 0
90803: PUSH
90804: LD_INT 1
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PUSH
90811: LD_INT 1
90813: NEG
90814: PUSH
90815: LD_INT 0
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: PUSH
90822: LD_INT 1
90824: NEG
90825: PUSH
90826: LD_INT 1
90828: NEG
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90843: LD_ADDR_VAR 0 60
90847: PUSH
90848: LD_INT 0
90850: PUSH
90851: LD_INT 0
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: LD_INT 0
90860: PUSH
90861: LD_INT 1
90863: NEG
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 1
90871: PUSH
90872: LD_INT 0
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 1
90881: PUSH
90882: LD_INT 1
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 0
90891: PUSH
90892: LD_INT 1
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: PUSH
90899: LD_INT 1
90901: NEG
90902: PUSH
90903: LD_INT 0
90905: PUSH
90906: EMPTY
90907: LIST
90908: LIST
90909: PUSH
90910: LD_INT 1
90912: NEG
90913: PUSH
90914: LD_INT 1
90916: NEG
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90931: LD_ADDR_VAR 0 61
90935: PUSH
90936: LD_INT 0
90938: PUSH
90939: LD_INT 0
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: LD_INT 0
90948: PUSH
90949: LD_INT 1
90951: NEG
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 1
90959: PUSH
90960: LD_INT 0
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 1
90969: PUSH
90970: LD_INT 1
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 0
90979: PUSH
90980: LD_INT 1
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 1
90989: NEG
90990: PUSH
90991: LD_INT 0
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 1
91000: NEG
91001: PUSH
91002: LD_INT 1
91004: NEG
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: EMPTY
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91019: LD_ADDR_VAR 0 62
91023: PUSH
91024: LD_INT 0
91026: PUSH
91027: LD_INT 0
91029: PUSH
91030: EMPTY
91031: LIST
91032: LIST
91033: PUSH
91034: LD_INT 0
91036: PUSH
91037: LD_INT 1
91039: NEG
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 1
91047: PUSH
91048: LD_INT 0
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PUSH
91055: LD_INT 1
91057: PUSH
91058: LD_INT 1
91060: PUSH
91061: EMPTY
91062: LIST
91063: LIST
91064: PUSH
91065: LD_INT 0
91067: PUSH
91068: LD_INT 1
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: PUSH
91075: LD_INT 1
91077: NEG
91078: PUSH
91079: LD_INT 0
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 1
91088: NEG
91089: PUSH
91090: LD_INT 1
91092: NEG
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91107: LD_ADDR_VAR 0 63
91111: PUSH
91112: LD_INT 0
91114: PUSH
91115: LD_INT 0
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 0
91124: PUSH
91125: LD_INT 1
91127: NEG
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 1
91135: PUSH
91136: LD_INT 0
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 1
91145: PUSH
91146: LD_INT 1
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 0
91155: PUSH
91156: LD_INT 1
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 1
91165: NEG
91166: PUSH
91167: LD_INT 0
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: PUSH
91174: LD_INT 1
91176: NEG
91177: PUSH
91178: LD_INT 1
91180: NEG
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91195: LD_ADDR_VAR 0 64
91199: PUSH
91200: LD_INT 0
91202: PUSH
91203: LD_INT 0
91205: PUSH
91206: EMPTY
91207: LIST
91208: LIST
91209: PUSH
91210: LD_INT 0
91212: PUSH
91213: LD_INT 1
91215: NEG
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 1
91223: PUSH
91224: LD_INT 0
91226: PUSH
91227: EMPTY
91228: LIST
91229: LIST
91230: PUSH
91231: LD_INT 1
91233: PUSH
91234: LD_INT 1
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 0
91243: PUSH
91244: LD_INT 1
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 1
91253: NEG
91254: PUSH
91255: LD_INT 0
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 1
91264: NEG
91265: PUSH
91266: LD_INT 1
91268: NEG
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: EMPTY
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: ST_TO_ADDR
// end ; 1 :
91283: GO 97180
91285: LD_INT 1
91287: DOUBLE
91288: EQUAL
91289: IFTRUE 91293
91291: GO 93916
91293: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91294: LD_ADDR_VAR 0 11
91298: PUSH
91299: LD_INT 1
91301: NEG
91302: PUSH
91303: LD_INT 3
91305: NEG
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 0
91313: PUSH
91314: LD_INT 3
91316: NEG
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: PUSH
91322: LD_INT 1
91324: PUSH
91325: LD_INT 2
91327: NEG
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: LIST
91337: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91338: LD_ADDR_VAR 0 12
91342: PUSH
91343: LD_INT 2
91345: PUSH
91346: LD_INT 1
91348: NEG
91349: PUSH
91350: EMPTY
91351: LIST
91352: LIST
91353: PUSH
91354: LD_INT 3
91356: PUSH
91357: LD_INT 0
91359: PUSH
91360: EMPTY
91361: LIST
91362: LIST
91363: PUSH
91364: LD_INT 3
91366: PUSH
91367: LD_INT 1
91369: PUSH
91370: EMPTY
91371: LIST
91372: LIST
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: LIST
91378: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91379: LD_ADDR_VAR 0 13
91383: PUSH
91384: LD_INT 3
91386: PUSH
91387: LD_INT 2
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 3
91396: PUSH
91397: LD_INT 3
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 2
91406: PUSH
91407: LD_INT 3
91409: PUSH
91410: EMPTY
91411: LIST
91412: LIST
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: LIST
91418: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91419: LD_ADDR_VAR 0 14
91423: PUSH
91424: LD_INT 1
91426: PUSH
91427: LD_INT 3
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: LD_INT 0
91436: PUSH
91437: LD_INT 3
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: PUSH
91444: LD_INT 1
91446: NEG
91447: PUSH
91448: LD_INT 2
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: LIST
91459: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91460: LD_ADDR_VAR 0 15
91464: PUSH
91465: LD_INT 2
91467: NEG
91468: PUSH
91469: LD_INT 1
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 3
91478: NEG
91479: PUSH
91480: LD_INT 0
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: PUSH
91487: LD_INT 3
91489: NEG
91490: PUSH
91491: LD_INT 1
91493: NEG
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: LIST
91503: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91504: LD_ADDR_VAR 0 16
91508: PUSH
91509: LD_INT 2
91511: NEG
91512: PUSH
91513: LD_INT 3
91515: NEG
91516: PUSH
91517: EMPTY
91518: LIST
91519: LIST
91520: PUSH
91521: LD_INT 3
91523: NEG
91524: PUSH
91525: LD_INT 2
91527: NEG
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: LD_INT 3
91535: NEG
91536: PUSH
91537: LD_INT 3
91539: NEG
91540: PUSH
91541: EMPTY
91542: LIST
91543: LIST
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: LIST
91549: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91550: LD_ADDR_VAR 0 17
91554: PUSH
91555: LD_INT 1
91557: NEG
91558: PUSH
91559: LD_INT 3
91561: NEG
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: LD_INT 0
91569: PUSH
91570: LD_INT 3
91572: NEG
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: LD_INT 1
91580: PUSH
91581: LD_INT 2
91583: NEG
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: LIST
91593: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91594: LD_ADDR_VAR 0 18
91598: PUSH
91599: LD_INT 2
91601: PUSH
91602: LD_INT 1
91604: NEG
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: PUSH
91610: LD_INT 3
91612: PUSH
91613: LD_INT 0
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: PUSH
91620: LD_INT 3
91622: PUSH
91623: LD_INT 1
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: LIST
91634: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91635: LD_ADDR_VAR 0 19
91639: PUSH
91640: LD_INT 3
91642: PUSH
91643: LD_INT 2
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 3
91652: PUSH
91653: LD_INT 3
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: PUSH
91660: LD_INT 2
91662: PUSH
91663: LD_INT 3
91665: PUSH
91666: EMPTY
91667: LIST
91668: LIST
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: LIST
91674: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91675: LD_ADDR_VAR 0 20
91679: PUSH
91680: LD_INT 1
91682: PUSH
91683: LD_INT 3
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PUSH
91690: LD_INT 0
91692: PUSH
91693: LD_INT 3
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 1
91702: NEG
91703: PUSH
91704: LD_INT 2
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: PUSH
91711: EMPTY
91712: LIST
91713: LIST
91714: LIST
91715: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91716: LD_ADDR_VAR 0 21
91720: PUSH
91721: LD_INT 2
91723: NEG
91724: PUSH
91725: LD_INT 1
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 3
91734: NEG
91735: PUSH
91736: LD_INT 0
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: PUSH
91743: LD_INT 3
91745: NEG
91746: PUSH
91747: LD_INT 1
91749: NEG
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: PUSH
91755: EMPTY
91756: LIST
91757: LIST
91758: LIST
91759: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91760: LD_ADDR_VAR 0 22
91764: PUSH
91765: LD_INT 2
91767: NEG
91768: PUSH
91769: LD_INT 3
91771: NEG
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 3
91779: NEG
91780: PUSH
91781: LD_INT 2
91783: NEG
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 3
91791: NEG
91792: PUSH
91793: LD_INT 3
91795: NEG
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: LIST
91805: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91806: LD_ADDR_VAR 0 23
91810: PUSH
91811: LD_INT 0
91813: PUSH
91814: LD_INT 3
91816: NEG
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 1
91824: NEG
91825: PUSH
91826: LD_INT 4
91828: NEG
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 1
91836: PUSH
91837: LD_INT 3
91839: NEG
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: LIST
91849: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91850: LD_ADDR_VAR 0 24
91854: PUSH
91855: LD_INT 3
91857: PUSH
91858: LD_INT 0
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: LD_INT 3
91867: PUSH
91868: LD_INT 1
91870: NEG
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 4
91878: PUSH
91879: LD_INT 1
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: LIST
91890: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91891: LD_ADDR_VAR 0 25
91895: PUSH
91896: LD_INT 3
91898: PUSH
91899: LD_INT 3
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: PUSH
91906: LD_INT 4
91908: PUSH
91909: LD_INT 3
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: PUSH
91916: LD_INT 3
91918: PUSH
91919: LD_INT 4
91921: PUSH
91922: EMPTY
91923: LIST
91924: LIST
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: LIST
91930: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91931: LD_ADDR_VAR 0 26
91935: PUSH
91936: LD_INT 0
91938: PUSH
91939: LD_INT 3
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: PUSH
91946: LD_INT 1
91948: PUSH
91949: LD_INT 4
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: LD_INT 1
91958: NEG
91959: PUSH
91960: LD_INT 3
91962: PUSH
91963: EMPTY
91964: LIST
91965: LIST
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: LIST
91971: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91972: LD_ADDR_VAR 0 27
91976: PUSH
91977: LD_INT 3
91979: NEG
91980: PUSH
91981: LD_INT 0
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: LD_INT 3
91990: NEG
91991: PUSH
91992: LD_INT 1
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: LD_INT 4
92001: NEG
92002: PUSH
92003: LD_INT 1
92005: NEG
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: LIST
92015: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92016: LD_ADDR_VAR 0 28
92020: PUSH
92021: LD_INT 3
92023: NEG
92024: PUSH
92025: LD_INT 3
92027: NEG
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: LD_INT 3
92035: NEG
92036: PUSH
92037: LD_INT 4
92039: NEG
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: PUSH
92045: LD_INT 4
92047: NEG
92048: PUSH
92049: LD_INT 3
92051: NEG
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: EMPTY
92058: LIST
92059: LIST
92060: LIST
92061: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92062: LD_ADDR_VAR 0 29
92066: PUSH
92067: LD_INT 1
92069: NEG
92070: PUSH
92071: LD_INT 3
92073: NEG
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 0
92081: PUSH
92082: LD_INT 3
92084: NEG
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: PUSH
92090: LD_INT 1
92092: PUSH
92093: LD_INT 2
92095: NEG
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 1
92103: NEG
92104: PUSH
92105: LD_INT 4
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: LD_INT 0
92115: PUSH
92116: LD_INT 4
92118: NEG
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: LD_INT 1
92126: PUSH
92127: LD_INT 3
92129: NEG
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 1
92137: NEG
92138: PUSH
92139: LD_INT 5
92141: NEG
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 0
92149: PUSH
92150: LD_INT 5
92152: NEG
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: PUSH
92158: LD_INT 1
92160: PUSH
92161: LD_INT 4
92163: NEG
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 1
92171: NEG
92172: PUSH
92173: LD_INT 6
92175: NEG
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 0
92183: PUSH
92184: LD_INT 6
92186: NEG
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 1
92194: PUSH
92195: LD_INT 5
92197: NEG
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92217: LD_ADDR_VAR 0 30
92221: PUSH
92222: LD_INT 2
92224: PUSH
92225: LD_INT 1
92227: NEG
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 3
92235: PUSH
92236: LD_INT 0
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: LD_INT 3
92245: PUSH
92246: LD_INT 1
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 3
92255: PUSH
92256: LD_INT 1
92258: NEG
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 4
92266: PUSH
92267: LD_INT 0
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 4
92276: PUSH
92277: LD_INT 1
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: LD_INT 4
92286: PUSH
92287: LD_INT 1
92289: NEG
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PUSH
92295: LD_INT 5
92297: PUSH
92298: LD_INT 0
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: LD_INT 5
92307: PUSH
92308: LD_INT 1
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: PUSH
92315: LD_INT 5
92317: PUSH
92318: LD_INT 1
92320: NEG
92321: PUSH
92322: EMPTY
92323: LIST
92324: LIST
92325: PUSH
92326: LD_INT 6
92328: PUSH
92329: LD_INT 0
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: PUSH
92336: LD_INT 6
92338: PUSH
92339: LD_INT 1
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92360: LD_ADDR_VAR 0 31
92364: PUSH
92365: LD_INT 3
92367: PUSH
92368: LD_INT 2
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PUSH
92375: LD_INT 3
92377: PUSH
92378: LD_INT 3
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: PUSH
92385: LD_INT 2
92387: PUSH
92388: LD_INT 3
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: PUSH
92395: LD_INT 4
92397: PUSH
92398: LD_INT 3
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: PUSH
92405: LD_INT 4
92407: PUSH
92408: LD_INT 4
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 3
92417: PUSH
92418: LD_INT 4
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 5
92427: PUSH
92428: LD_INT 4
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: PUSH
92435: LD_INT 5
92437: PUSH
92438: LD_INT 5
92440: PUSH
92441: EMPTY
92442: LIST
92443: LIST
92444: PUSH
92445: LD_INT 4
92447: PUSH
92448: LD_INT 5
92450: PUSH
92451: EMPTY
92452: LIST
92453: LIST
92454: PUSH
92455: LD_INT 6
92457: PUSH
92458: LD_INT 5
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 6
92467: PUSH
92468: LD_INT 6
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 5
92477: PUSH
92478: LD_INT 6
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92499: LD_ADDR_VAR 0 32
92503: PUSH
92504: LD_INT 1
92506: PUSH
92507: LD_INT 3
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 0
92516: PUSH
92517: LD_INT 3
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 1
92526: NEG
92527: PUSH
92528: LD_INT 2
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 1
92537: PUSH
92538: LD_INT 4
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 0
92547: PUSH
92548: LD_INT 4
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 1
92557: NEG
92558: PUSH
92559: LD_INT 3
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: PUSH
92566: LD_INT 1
92568: PUSH
92569: LD_INT 5
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 0
92578: PUSH
92579: LD_INT 5
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: PUSH
92586: LD_INT 1
92588: NEG
92589: PUSH
92590: LD_INT 4
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: PUSH
92597: LD_INT 1
92599: PUSH
92600: LD_INT 6
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 0
92609: PUSH
92610: LD_INT 6
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: PUSH
92617: LD_INT 1
92619: NEG
92620: PUSH
92621: LD_INT 5
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92642: LD_ADDR_VAR 0 33
92646: PUSH
92647: LD_INT 2
92649: NEG
92650: PUSH
92651: LD_INT 1
92653: PUSH
92654: EMPTY
92655: LIST
92656: LIST
92657: PUSH
92658: LD_INT 3
92660: NEG
92661: PUSH
92662: LD_INT 0
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: PUSH
92669: LD_INT 3
92671: NEG
92672: PUSH
92673: LD_INT 1
92675: NEG
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: PUSH
92681: LD_INT 3
92683: NEG
92684: PUSH
92685: LD_INT 1
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: PUSH
92692: LD_INT 4
92694: NEG
92695: PUSH
92696: LD_INT 0
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 4
92705: NEG
92706: PUSH
92707: LD_INT 1
92709: NEG
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 4
92717: NEG
92718: PUSH
92719: LD_INT 1
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PUSH
92726: LD_INT 5
92728: NEG
92729: PUSH
92730: LD_INT 0
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 5
92739: NEG
92740: PUSH
92741: LD_INT 1
92743: NEG
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 5
92751: NEG
92752: PUSH
92753: LD_INT 1
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 6
92762: NEG
92763: PUSH
92764: LD_INT 0
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 6
92773: NEG
92774: PUSH
92775: LD_INT 1
92777: NEG
92778: PUSH
92779: EMPTY
92780: LIST
92781: LIST
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92797: LD_ADDR_VAR 0 34
92801: PUSH
92802: LD_INT 2
92804: NEG
92805: PUSH
92806: LD_INT 3
92808: NEG
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PUSH
92814: LD_INT 3
92816: NEG
92817: PUSH
92818: LD_INT 2
92820: NEG
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 3
92828: NEG
92829: PUSH
92830: LD_INT 3
92832: NEG
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 3
92840: NEG
92841: PUSH
92842: LD_INT 4
92844: NEG
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: LD_INT 4
92852: NEG
92853: PUSH
92854: LD_INT 3
92856: NEG
92857: PUSH
92858: EMPTY
92859: LIST
92860: LIST
92861: PUSH
92862: LD_INT 4
92864: NEG
92865: PUSH
92866: LD_INT 4
92868: NEG
92869: PUSH
92870: EMPTY
92871: LIST
92872: LIST
92873: PUSH
92874: LD_INT 4
92876: NEG
92877: PUSH
92878: LD_INT 5
92880: NEG
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 5
92888: NEG
92889: PUSH
92890: LD_INT 4
92892: NEG
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: LD_INT 5
92900: NEG
92901: PUSH
92902: LD_INT 5
92904: NEG
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: PUSH
92910: LD_INT 5
92912: NEG
92913: PUSH
92914: LD_INT 6
92916: NEG
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: PUSH
92922: LD_INT 6
92924: NEG
92925: PUSH
92926: LD_INT 5
92928: NEG
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PUSH
92934: LD_INT 6
92936: NEG
92937: PUSH
92938: LD_INT 6
92940: NEG
92941: PUSH
92942: EMPTY
92943: LIST
92944: LIST
92945: PUSH
92946: EMPTY
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92960: LD_ADDR_VAR 0 41
92964: PUSH
92965: LD_INT 0
92967: PUSH
92968: LD_INT 2
92970: NEG
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: PUSH
92976: LD_INT 1
92978: NEG
92979: PUSH
92980: LD_INT 3
92982: NEG
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 1
92990: PUSH
92991: LD_INT 2
92993: NEG
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: LIST
93003: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93004: LD_ADDR_VAR 0 42
93008: PUSH
93009: LD_INT 2
93011: PUSH
93012: LD_INT 0
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 2
93021: PUSH
93022: LD_INT 1
93024: NEG
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 3
93032: PUSH
93033: LD_INT 1
93035: PUSH
93036: EMPTY
93037: LIST
93038: LIST
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: LIST
93044: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93045: LD_ADDR_VAR 0 43
93049: PUSH
93050: LD_INT 2
93052: PUSH
93053: LD_INT 2
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: PUSH
93060: LD_INT 3
93062: PUSH
93063: LD_INT 2
93065: PUSH
93066: EMPTY
93067: LIST
93068: LIST
93069: PUSH
93070: LD_INT 2
93072: PUSH
93073: LD_INT 3
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: LIST
93084: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93085: LD_ADDR_VAR 0 44
93089: PUSH
93090: LD_INT 0
93092: PUSH
93093: LD_INT 2
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 1
93102: PUSH
93103: LD_INT 3
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: LD_INT 1
93112: NEG
93113: PUSH
93114: LD_INT 2
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: LIST
93125: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93126: LD_ADDR_VAR 0 45
93130: PUSH
93131: LD_INT 2
93133: NEG
93134: PUSH
93135: LD_INT 0
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 2
93144: NEG
93145: PUSH
93146: LD_INT 1
93148: PUSH
93149: EMPTY
93150: LIST
93151: LIST
93152: PUSH
93153: LD_INT 3
93155: NEG
93156: PUSH
93157: LD_INT 1
93159: NEG
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: PUSH
93165: EMPTY
93166: LIST
93167: LIST
93168: LIST
93169: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93170: LD_ADDR_VAR 0 46
93174: PUSH
93175: LD_INT 2
93177: NEG
93178: PUSH
93179: LD_INT 2
93181: NEG
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: PUSH
93187: LD_INT 2
93189: NEG
93190: PUSH
93191: LD_INT 3
93193: NEG
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 3
93201: NEG
93202: PUSH
93203: LD_INT 2
93205: NEG
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: PUSH
93211: EMPTY
93212: LIST
93213: LIST
93214: LIST
93215: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93216: LD_ADDR_VAR 0 47
93220: PUSH
93221: LD_INT 2
93223: NEG
93224: PUSH
93225: LD_INT 3
93227: NEG
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: PUSH
93233: LD_INT 1
93235: NEG
93236: PUSH
93237: LD_INT 3
93239: NEG
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93249: LD_ADDR_VAR 0 48
93253: PUSH
93254: LD_INT 1
93256: PUSH
93257: LD_INT 2
93259: NEG
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: PUSH
93265: LD_INT 2
93267: PUSH
93268: LD_INT 1
93270: NEG
93271: PUSH
93272: EMPTY
93273: LIST
93274: LIST
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93280: LD_ADDR_VAR 0 49
93284: PUSH
93285: LD_INT 3
93287: PUSH
93288: LD_INT 1
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 3
93297: PUSH
93298: LD_INT 2
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: EMPTY
93306: LIST
93307: LIST
93308: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93309: LD_ADDR_VAR 0 50
93313: PUSH
93314: LD_INT 2
93316: PUSH
93317: LD_INT 3
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PUSH
93324: LD_INT 1
93326: PUSH
93327: LD_INT 3
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93338: LD_ADDR_VAR 0 51
93342: PUSH
93343: LD_INT 1
93345: NEG
93346: PUSH
93347: LD_INT 2
93349: PUSH
93350: EMPTY
93351: LIST
93352: LIST
93353: PUSH
93354: LD_INT 2
93356: NEG
93357: PUSH
93358: LD_INT 1
93360: PUSH
93361: EMPTY
93362: LIST
93363: LIST
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93369: LD_ADDR_VAR 0 52
93373: PUSH
93374: LD_INT 3
93376: NEG
93377: PUSH
93378: LD_INT 1
93380: NEG
93381: PUSH
93382: EMPTY
93383: LIST
93384: LIST
93385: PUSH
93386: LD_INT 3
93388: NEG
93389: PUSH
93390: LD_INT 2
93392: NEG
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93402: LD_ADDR_VAR 0 53
93406: PUSH
93407: LD_INT 1
93409: NEG
93410: PUSH
93411: LD_INT 3
93413: NEG
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: PUSH
93419: LD_INT 0
93421: PUSH
93422: LD_INT 3
93424: NEG
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 1
93432: PUSH
93433: LD_INT 2
93435: NEG
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: LIST
93445: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93446: LD_ADDR_VAR 0 54
93450: PUSH
93451: LD_INT 2
93453: PUSH
93454: LD_INT 1
93456: NEG
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: LD_INT 3
93464: PUSH
93465: LD_INT 0
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: LD_INT 3
93474: PUSH
93475: LD_INT 1
93477: PUSH
93478: EMPTY
93479: LIST
93480: LIST
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: LIST
93486: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93487: LD_ADDR_VAR 0 55
93491: PUSH
93492: LD_INT 3
93494: PUSH
93495: LD_INT 2
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: PUSH
93502: LD_INT 3
93504: PUSH
93505: LD_INT 3
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 2
93514: PUSH
93515: LD_INT 3
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: EMPTY
93523: LIST
93524: LIST
93525: LIST
93526: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93527: LD_ADDR_VAR 0 56
93531: PUSH
93532: LD_INT 1
93534: PUSH
93535: LD_INT 3
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 0
93544: PUSH
93545: LD_INT 3
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PUSH
93552: LD_INT 1
93554: NEG
93555: PUSH
93556: LD_INT 2
93558: PUSH
93559: EMPTY
93560: LIST
93561: LIST
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: LIST
93567: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93568: LD_ADDR_VAR 0 57
93572: PUSH
93573: LD_INT 2
93575: NEG
93576: PUSH
93577: LD_INT 1
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: PUSH
93584: LD_INT 3
93586: NEG
93587: PUSH
93588: LD_INT 0
93590: PUSH
93591: EMPTY
93592: LIST
93593: LIST
93594: PUSH
93595: LD_INT 3
93597: NEG
93598: PUSH
93599: LD_INT 1
93601: NEG
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: LIST
93611: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93612: LD_ADDR_VAR 0 58
93616: PUSH
93617: LD_INT 2
93619: NEG
93620: PUSH
93621: LD_INT 3
93623: NEG
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 3
93631: NEG
93632: PUSH
93633: LD_INT 2
93635: NEG
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 3
93643: NEG
93644: PUSH
93645: LD_INT 3
93647: NEG
93648: PUSH
93649: EMPTY
93650: LIST
93651: LIST
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: LIST
93657: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93658: LD_ADDR_VAR 0 59
93662: PUSH
93663: LD_INT 1
93665: NEG
93666: PUSH
93667: LD_INT 2
93669: NEG
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: LD_INT 0
93677: PUSH
93678: LD_INT 2
93680: NEG
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: LD_INT 1
93688: PUSH
93689: LD_INT 1
93691: NEG
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: LIST
93701: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93702: LD_ADDR_VAR 0 60
93706: PUSH
93707: LD_INT 1
93709: PUSH
93710: LD_INT 1
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 2
93720: PUSH
93721: LD_INT 0
93723: PUSH
93724: EMPTY
93725: LIST
93726: LIST
93727: PUSH
93728: LD_INT 2
93730: PUSH
93731: LD_INT 1
93733: PUSH
93734: EMPTY
93735: LIST
93736: LIST
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: LIST
93742: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93743: LD_ADDR_VAR 0 61
93747: PUSH
93748: LD_INT 2
93750: PUSH
93751: LD_INT 1
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 2
93760: PUSH
93761: LD_INT 2
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: PUSH
93768: LD_INT 1
93770: PUSH
93771: LD_INT 2
93773: PUSH
93774: EMPTY
93775: LIST
93776: LIST
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: LIST
93782: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93783: LD_ADDR_VAR 0 62
93787: PUSH
93788: LD_INT 1
93790: PUSH
93791: LD_INT 2
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: PUSH
93798: LD_INT 0
93800: PUSH
93801: LD_INT 2
93803: PUSH
93804: EMPTY
93805: LIST
93806: LIST
93807: PUSH
93808: LD_INT 1
93810: NEG
93811: PUSH
93812: LD_INT 1
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: EMPTY
93820: LIST
93821: LIST
93822: LIST
93823: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93824: LD_ADDR_VAR 0 63
93828: PUSH
93829: LD_INT 1
93831: NEG
93832: PUSH
93833: LD_INT 1
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: PUSH
93840: LD_INT 2
93842: NEG
93843: PUSH
93844: LD_INT 0
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: PUSH
93851: LD_INT 2
93853: NEG
93854: PUSH
93855: LD_INT 1
93857: NEG
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: LIST
93867: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93868: LD_ADDR_VAR 0 64
93872: PUSH
93873: LD_INT 1
93875: NEG
93876: PUSH
93877: LD_INT 2
93879: NEG
93880: PUSH
93881: EMPTY
93882: LIST
93883: LIST
93884: PUSH
93885: LD_INT 2
93887: NEG
93888: PUSH
93889: LD_INT 1
93891: NEG
93892: PUSH
93893: EMPTY
93894: LIST
93895: LIST
93896: PUSH
93897: LD_INT 2
93899: NEG
93900: PUSH
93901: LD_INT 2
93903: NEG
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: LIST
93913: ST_TO_ADDR
// end ; 2 :
93914: GO 97180
93916: LD_INT 2
93918: DOUBLE
93919: EQUAL
93920: IFTRUE 93924
93922: GO 97179
93924: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93925: LD_ADDR_VAR 0 29
93929: PUSH
93930: LD_INT 4
93932: PUSH
93933: LD_INT 0
93935: PUSH
93936: EMPTY
93937: LIST
93938: LIST
93939: PUSH
93940: LD_INT 4
93942: PUSH
93943: LD_INT 1
93945: NEG
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: PUSH
93951: LD_INT 5
93953: PUSH
93954: LD_INT 0
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PUSH
93961: LD_INT 5
93963: PUSH
93964: LD_INT 1
93966: PUSH
93967: EMPTY
93968: LIST
93969: LIST
93970: PUSH
93971: LD_INT 4
93973: PUSH
93974: LD_INT 1
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: PUSH
93981: LD_INT 3
93983: PUSH
93984: LD_INT 0
93986: PUSH
93987: EMPTY
93988: LIST
93989: LIST
93990: PUSH
93991: LD_INT 3
93993: PUSH
93994: LD_INT 1
93996: NEG
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: PUSH
94002: LD_INT 3
94004: PUSH
94005: LD_INT 2
94007: NEG
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: LD_INT 5
94015: PUSH
94016: LD_INT 2
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: LD_INT 3
94025: PUSH
94026: LD_INT 3
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 3
94035: PUSH
94036: LD_INT 2
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 4
94045: PUSH
94046: LD_INT 3
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: LD_INT 4
94055: PUSH
94056: LD_INT 4
94058: PUSH
94059: EMPTY
94060: LIST
94061: LIST
94062: PUSH
94063: LD_INT 3
94065: PUSH
94066: LD_INT 4
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 2
94075: PUSH
94076: LD_INT 3
94078: PUSH
94079: EMPTY
94080: LIST
94081: LIST
94082: PUSH
94083: LD_INT 2
94085: PUSH
94086: LD_INT 2
94088: PUSH
94089: EMPTY
94090: LIST
94091: LIST
94092: PUSH
94093: LD_INT 4
94095: PUSH
94096: LD_INT 2
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 2
94105: PUSH
94106: LD_INT 4
94108: PUSH
94109: EMPTY
94110: LIST
94111: LIST
94112: PUSH
94113: LD_INT 0
94115: PUSH
94116: LD_INT 4
94118: PUSH
94119: EMPTY
94120: LIST
94121: LIST
94122: PUSH
94123: LD_INT 0
94125: PUSH
94126: LD_INT 3
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: PUSH
94133: LD_INT 1
94135: PUSH
94136: LD_INT 4
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: PUSH
94143: LD_INT 1
94145: PUSH
94146: LD_INT 5
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: PUSH
94153: LD_INT 0
94155: PUSH
94156: LD_INT 5
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 1
94165: NEG
94166: PUSH
94167: LD_INT 4
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: PUSH
94174: LD_INT 1
94176: NEG
94177: PUSH
94178: LD_INT 3
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: PUSH
94185: LD_INT 2
94187: PUSH
94188: LD_INT 5
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: PUSH
94195: LD_INT 2
94197: NEG
94198: PUSH
94199: LD_INT 3
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: PUSH
94206: LD_INT 3
94208: NEG
94209: PUSH
94210: LD_INT 0
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PUSH
94217: LD_INT 3
94219: NEG
94220: PUSH
94221: LD_INT 1
94223: NEG
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: PUSH
94229: LD_INT 2
94231: NEG
94232: PUSH
94233: LD_INT 0
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: LD_INT 2
94242: NEG
94243: PUSH
94244: LD_INT 1
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 3
94253: NEG
94254: PUSH
94255: LD_INT 1
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 4
94264: NEG
94265: PUSH
94266: LD_INT 0
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: PUSH
94273: LD_INT 4
94275: NEG
94276: PUSH
94277: LD_INT 1
94279: NEG
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 4
94287: NEG
94288: PUSH
94289: LD_INT 2
94291: NEG
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 2
94299: NEG
94300: PUSH
94301: LD_INT 2
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: LD_INT 4
94310: NEG
94311: PUSH
94312: LD_INT 4
94314: NEG
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: PUSH
94320: LD_INT 4
94322: NEG
94323: PUSH
94324: LD_INT 5
94326: NEG
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 3
94334: NEG
94335: PUSH
94336: LD_INT 4
94338: NEG
94339: PUSH
94340: EMPTY
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 3
94346: NEG
94347: PUSH
94348: LD_INT 3
94350: NEG
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: LD_INT 4
94358: NEG
94359: PUSH
94360: LD_INT 3
94362: NEG
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: PUSH
94368: LD_INT 5
94370: NEG
94371: PUSH
94372: LD_INT 4
94374: NEG
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 5
94382: NEG
94383: PUSH
94384: LD_INT 5
94386: NEG
94387: PUSH
94388: EMPTY
94389: LIST
94390: LIST
94391: PUSH
94392: LD_INT 3
94394: NEG
94395: PUSH
94396: LD_INT 5
94398: NEG
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: PUSH
94404: LD_INT 5
94406: NEG
94407: PUSH
94408: LD_INT 3
94410: NEG
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: EMPTY
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94463: LD_ADDR_VAR 0 30
94467: PUSH
94468: LD_INT 4
94470: PUSH
94471: LD_INT 4
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 4
94480: PUSH
94481: LD_INT 3
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 5
94490: PUSH
94491: LD_INT 4
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: LD_INT 5
94500: PUSH
94501: LD_INT 5
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: LD_INT 4
94510: PUSH
94511: LD_INT 5
94513: PUSH
94514: EMPTY
94515: LIST
94516: LIST
94517: PUSH
94518: LD_INT 3
94520: PUSH
94521: LD_INT 4
94523: PUSH
94524: EMPTY
94525: LIST
94526: LIST
94527: PUSH
94528: LD_INT 3
94530: PUSH
94531: LD_INT 3
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: PUSH
94538: LD_INT 5
94540: PUSH
94541: LD_INT 3
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 3
94550: PUSH
94551: LD_INT 5
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: PUSH
94558: LD_INT 0
94560: PUSH
94561: LD_INT 3
94563: PUSH
94564: EMPTY
94565: LIST
94566: LIST
94567: PUSH
94568: LD_INT 0
94570: PUSH
94571: LD_INT 2
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: LD_INT 3
94583: PUSH
94584: EMPTY
94585: LIST
94586: LIST
94587: PUSH
94588: LD_INT 1
94590: PUSH
94591: LD_INT 4
94593: PUSH
94594: EMPTY
94595: LIST
94596: LIST
94597: PUSH
94598: LD_INT 0
94600: PUSH
94601: LD_INT 4
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: LD_INT 1
94610: NEG
94611: PUSH
94612: LD_INT 3
94614: PUSH
94615: EMPTY
94616: LIST
94617: LIST
94618: PUSH
94619: LD_INT 1
94621: NEG
94622: PUSH
94623: LD_INT 2
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: PUSH
94630: LD_INT 2
94632: PUSH
94633: LD_INT 4
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: PUSH
94640: LD_INT 2
94642: NEG
94643: PUSH
94644: LD_INT 2
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 4
94653: NEG
94654: PUSH
94655: LD_INT 0
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 4
94664: NEG
94665: PUSH
94666: LD_INT 1
94668: NEG
94669: PUSH
94670: EMPTY
94671: LIST
94672: LIST
94673: PUSH
94674: LD_INT 3
94676: NEG
94677: PUSH
94678: LD_INT 0
94680: PUSH
94681: EMPTY
94682: LIST
94683: LIST
94684: PUSH
94685: LD_INT 3
94687: NEG
94688: PUSH
94689: LD_INT 1
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: PUSH
94696: LD_INT 4
94698: NEG
94699: PUSH
94700: LD_INT 1
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: PUSH
94707: LD_INT 5
94709: NEG
94710: PUSH
94711: LD_INT 0
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 5
94720: NEG
94721: PUSH
94722: LD_INT 1
94724: NEG
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 5
94732: NEG
94733: PUSH
94734: LD_INT 2
94736: NEG
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 3
94744: NEG
94745: PUSH
94746: LD_INT 2
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 3
94755: NEG
94756: PUSH
94757: LD_INT 3
94759: NEG
94760: PUSH
94761: EMPTY
94762: LIST
94763: LIST
94764: PUSH
94765: LD_INT 3
94767: NEG
94768: PUSH
94769: LD_INT 4
94771: NEG
94772: PUSH
94773: EMPTY
94774: LIST
94775: LIST
94776: PUSH
94777: LD_INT 2
94779: NEG
94780: PUSH
94781: LD_INT 3
94783: NEG
94784: PUSH
94785: EMPTY
94786: LIST
94787: LIST
94788: PUSH
94789: LD_INT 2
94791: NEG
94792: PUSH
94793: LD_INT 2
94795: NEG
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: PUSH
94801: LD_INT 3
94803: NEG
94804: PUSH
94805: LD_INT 2
94807: NEG
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 4
94815: NEG
94816: PUSH
94817: LD_INT 3
94819: NEG
94820: PUSH
94821: EMPTY
94822: LIST
94823: LIST
94824: PUSH
94825: LD_INT 4
94827: NEG
94828: PUSH
94829: LD_INT 4
94831: NEG
94832: PUSH
94833: EMPTY
94834: LIST
94835: LIST
94836: PUSH
94837: LD_INT 2
94839: NEG
94840: PUSH
94841: LD_INT 4
94843: NEG
94844: PUSH
94845: EMPTY
94846: LIST
94847: LIST
94848: PUSH
94849: LD_INT 4
94851: NEG
94852: PUSH
94853: LD_INT 2
94855: NEG
94856: PUSH
94857: EMPTY
94858: LIST
94859: LIST
94860: PUSH
94861: LD_INT 0
94863: PUSH
94864: LD_INT 4
94866: NEG
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: PUSH
94872: LD_INT 0
94874: PUSH
94875: LD_INT 5
94877: NEG
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: PUSH
94883: LD_INT 1
94885: PUSH
94886: LD_INT 4
94888: NEG
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: PUSH
94894: LD_INT 1
94896: PUSH
94897: LD_INT 3
94899: NEG
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 0
94907: PUSH
94908: LD_INT 3
94910: NEG
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PUSH
94916: LD_INT 1
94918: NEG
94919: PUSH
94920: LD_INT 4
94922: NEG
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: PUSH
94928: LD_INT 1
94930: NEG
94931: PUSH
94932: LD_INT 5
94934: NEG
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PUSH
94940: LD_INT 2
94942: PUSH
94943: LD_INT 3
94945: NEG
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: PUSH
94951: LD_INT 2
94953: NEG
94954: PUSH
94955: LD_INT 5
94957: NEG
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: PUSH
94963: EMPTY
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95010: LD_ADDR_VAR 0 31
95014: PUSH
95015: LD_INT 0
95017: PUSH
95018: LD_INT 4
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: PUSH
95025: LD_INT 0
95027: PUSH
95028: LD_INT 3
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: PUSH
95035: LD_INT 1
95037: PUSH
95038: LD_INT 4
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PUSH
95045: LD_INT 1
95047: PUSH
95048: LD_INT 5
95050: PUSH
95051: EMPTY
95052: LIST
95053: LIST
95054: PUSH
95055: LD_INT 0
95057: PUSH
95058: LD_INT 5
95060: PUSH
95061: EMPTY
95062: LIST
95063: LIST
95064: PUSH
95065: LD_INT 1
95067: NEG
95068: PUSH
95069: LD_INT 4
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 1
95078: NEG
95079: PUSH
95080: LD_INT 3
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 2
95089: PUSH
95090: LD_INT 5
95092: PUSH
95093: EMPTY
95094: LIST
95095: LIST
95096: PUSH
95097: LD_INT 2
95099: NEG
95100: PUSH
95101: LD_INT 3
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: LD_INT 3
95110: NEG
95111: PUSH
95112: LD_INT 0
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: PUSH
95119: LD_INT 3
95121: NEG
95122: PUSH
95123: LD_INT 1
95125: NEG
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: PUSH
95131: LD_INT 2
95133: NEG
95134: PUSH
95135: LD_INT 0
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: PUSH
95142: LD_INT 2
95144: NEG
95145: PUSH
95146: LD_INT 1
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 3
95155: NEG
95156: PUSH
95157: LD_INT 1
95159: PUSH
95160: EMPTY
95161: LIST
95162: LIST
95163: PUSH
95164: LD_INT 4
95166: NEG
95167: PUSH
95168: LD_INT 0
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: PUSH
95175: LD_INT 4
95177: NEG
95178: PUSH
95179: LD_INT 1
95181: NEG
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 4
95189: NEG
95190: PUSH
95191: LD_INT 2
95193: NEG
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PUSH
95199: LD_INT 2
95201: NEG
95202: PUSH
95203: LD_INT 2
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: PUSH
95210: LD_INT 4
95212: NEG
95213: PUSH
95214: LD_INT 4
95216: NEG
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: LD_INT 4
95224: NEG
95225: PUSH
95226: LD_INT 5
95228: NEG
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: PUSH
95234: LD_INT 3
95236: NEG
95237: PUSH
95238: LD_INT 4
95240: NEG
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: PUSH
95246: LD_INT 3
95248: NEG
95249: PUSH
95250: LD_INT 3
95252: NEG
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: PUSH
95258: LD_INT 4
95260: NEG
95261: PUSH
95262: LD_INT 3
95264: NEG
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: PUSH
95270: LD_INT 5
95272: NEG
95273: PUSH
95274: LD_INT 4
95276: NEG
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: PUSH
95282: LD_INT 5
95284: NEG
95285: PUSH
95286: LD_INT 5
95288: NEG
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 3
95296: NEG
95297: PUSH
95298: LD_INT 5
95300: NEG
95301: PUSH
95302: EMPTY
95303: LIST
95304: LIST
95305: PUSH
95306: LD_INT 5
95308: NEG
95309: PUSH
95310: LD_INT 3
95312: NEG
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: PUSH
95318: LD_INT 0
95320: PUSH
95321: LD_INT 3
95323: NEG
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: PUSH
95329: LD_INT 0
95331: PUSH
95332: LD_INT 4
95334: NEG
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: PUSH
95340: LD_INT 1
95342: PUSH
95343: LD_INT 3
95345: NEG
95346: PUSH
95347: EMPTY
95348: LIST
95349: LIST
95350: PUSH
95351: LD_INT 1
95353: PUSH
95354: LD_INT 2
95356: NEG
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PUSH
95362: LD_INT 0
95364: PUSH
95365: LD_INT 2
95367: NEG
95368: PUSH
95369: EMPTY
95370: LIST
95371: LIST
95372: PUSH
95373: LD_INT 1
95375: NEG
95376: PUSH
95377: LD_INT 3
95379: NEG
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: PUSH
95385: LD_INT 1
95387: NEG
95388: PUSH
95389: LD_INT 4
95391: NEG
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 2
95399: PUSH
95400: LD_INT 2
95402: NEG
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: LD_INT 2
95410: NEG
95411: PUSH
95412: LD_INT 4
95414: NEG
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 4
95422: PUSH
95423: LD_INT 0
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: PUSH
95430: LD_INT 4
95432: PUSH
95433: LD_INT 1
95435: NEG
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 5
95443: PUSH
95444: LD_INT 0
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 5
95453: PUSH
95454: LD_INT 1
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: LD_INT 4
95463: PUSH
95464: LD_INT 1
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: PUSH
95471: LD_INT 3
95473: PUSH
95474: LD_INT 0
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 3
95483: PUSH
95484: LD_INT 1
95486: NEG
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: LD_INT 3
95494: PUSH
95495: LD_INT 2
95497: NEG
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 5
95505: PUSH
95506: LD_INT 2
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: EMPTY
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95560: LD_ADDR_VAR 0 32
95564: PUSH
95565: LD_INT 4
95567: NEG
95568: PUSH
95569: LD_INT 0
95571: PUSH
95572: EMPTY
95573: LIST
95574: LIST
95575: PUSH
95576: LD_INT 4
95578: NEG
95579: PUSH
95580: LD_INT 1
95582: NEG
95583: PUSH
95584: EMPTY
95585: LIST
95586: LIST
95587: PUSH
95588: LD_INT 3
95590: NEG
95591: PUSH
95592: LD_INT 0
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: PUSH
95599: LD_INT 3
95601: NEG
95602: PUSH
95603: LD_INT 1
95605: PUSH
95606: EMPTY
95607: LIST
95608: LIST
95609: PUSH
95610: LD_INT 4
95612: NEG
95613: PUSH
95614: LD_INT 1
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: PUSH
95621: LD_INT 5
95623: NEG
95624: PUSH
95625: LD_INT 0
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PUSH
95632: LD_INT 5
95634: NEG
95635: PUSH
95636: LD_INT 1
95638: NEG
95639: PUSH
95640: EMPTY
95641: LIST
95642: LIST
95643: PUSH
95644: LD_INT 5
95646: NEG
95647: PUSH
95648: LD_INT 2
95650: NEG
95651: PUSH
95652: EMPTY
95653: LIST
95654: LIST
95655: PUSH
95656: LD_INT 3
95658: NEG
95659: PUSH
95660: LD_INT 2
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: LD_INT 3
95669: NEG
95670: PUSH
95671: LD_INT 3
95673: NEG
95674: PUSH
95675: EMPTY
95676: LIST
95677: LIST
95678: PUSH
95679: LD_INT 3
95681: NEG
95682: PUSH
95683: LD_INT 4
95685: NEG
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: PUSH
95691: LD_INT 2
95693: NEG
95694: PUSH
95695: LD_INT 3
95697: NEG
95698: PUSH
95699: EMPTY
95700: LIST
95701: LIST
95702: PUSH
95703: LD_INT 2
95705: NEG
95706: PUSH
95707: LD_INT 2
95709: NEG
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 3
95717: NEG
95718: PUSH
95719: LD_INT 2
95721: NEG
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: PUSH
95727: LD_INT 4
95729: NEG
95730: PUSH
95731: LD_INT 3
95733: NEG
95734: PUSH
95735: EMPTY
95736: LIST
95737: LIST
95738: PUSH
95739: LD_INT 4
95741: NEG
95742: PUSH
95743: LD_INT 4
95745: NEG
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: PUSH
95751: LD_INT 2
95753: NEG
95754: PUSH
95755: LD_INT 4
95757: NEG
95758: PUSH
95759: EMPTY
95760: LIST
95761: LIST
95762: PUSH
95763: LD_INT 4
95765: NEG
95766: PUSH
95767: LD_INT 2
95769: NEG
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: PUSH
95775: LD_INT 0
95777: PUSH
95778: LD_INT 4
95780: NEG
95781: PUSH
95782: EMPTY
95783: LIST
95784: LIST
95785: PUSH
95786: LD_INT 0
95788: PUSH
95789: LD_INT 5
95791: NEG
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 1
95799: PUSH
95800: LD_INT 4
95802: NEG
95803: PUSH
95804: EMPTY
95805: LIST
95806: LIST
95807: PUSH
95808: LD_INT 1
95810: PUSH
95811: LD_INT 3
95813: NEG
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: LD_INT 0
95821: PUSH
95822: LD_INT 3
95824: NEG
95825: PUSH
95826: EMPTY
95827: LIST
95828: LIST
95829: PUSH
95830: LD_INT 1
95832: NEG
95833: PUSH
95834: LD_INT 4
95836: NEG
95837: PUSH
95838: EMPTY
95839: LIST
95840: LIST
95841: PUSH
95842: LD_INT 1
95844: NEG
95845: PUSH
95846: LD_INT 5
95848: NEG
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 2
95856: PUSH
95857: LD_INT 3
95859: NEG
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 2
95867: NEG
95868: PUSH
95869: LD_INT 5
95871: NEG
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 3
95879: PUSH
95880: LD_INT 0
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 3
95889: PUSH
95890: LD_INT 1
95892: NEG
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: LD_INT 4
95900: PUSH
95901: LD_INT 0
95903: PUSH
95904: EMPTY
95905: LIST
95906: LIST
95907: PUSH
95908: LD_INT 4
95910: PUSH
95911: LD_INT 1
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PUSH
95918: LD_INT 3
95920: PUSH
95921: LD_INT 1
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 2
95930: PUSH
95931: LD_INT 0
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: LD_INT 2
95940: PUSH
95941: LD_INT 1
95943: NEG
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: LD_INT 2
95951: PUSH
95952: LD_INT 2
95954: NEG
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: PUSH
95960: LD_INT 4
95962: PUSH
95963: LD_INT 2
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: PUSH
95970: LD_INT 4
95972: PUSH
95973: LD_INT 4
95975: PUSH
95976: EMPTY
95977: LIST
95978: LIST
95979: PUSH
95980: LD_INT 4
95982: PUSH
95983: LD_INT 3
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: LD_INT 5
95992: PUSH
95993: LD_INT 4
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: LD_INT 5
96002: PUSH
96003: LD_INT 5
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: LD_INT 4
96012: PUSH
96013: LD_INT 5
96015: PUSH
96016: EMPTY
96017: LIST
96018: LIST
96019: PUSH
96020: LD_INT 3
96022: PUSH
96023: LD_INT 4
96025: PUSH
96026: EMPTY
96027: LIST
96028: LIST
96029: PUSH
96030: LD_INT 3
96032: PUSH
96033: LD_INT 3
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: LD_INT 5
96042: PUSH
96043: LD_INT 3
96045: PUSH
96046: EMPTY
96047: LIST
96048: LIST
96049: PUSH
96050: LD_INT 3
96052: PUSH
96053: LD_INT 5
96055: PUSH
96056: EMPTY
96057: LIST
96058: LIST
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96107: LD_ADDR_VAR 0 33
96111: PUSH
96112: LD_INT 4
96114: NEG
96115: PUSH
96116: LD_INT 4
96118: NEG
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PUSH
96124: LD_INT 4
96126: NEG
96127: PUSH
96128: LD_INT 5
96130: NEG
96131: PUSH
96132: EMPTY
96133: LIST
96134: LIST
96135: PUSH
96136: LD_INT 3
96138: NEG
96139: PUSH
96140: LD_INT 4
96142: NEG
96143: PUSH
96144: EMPTY
96145: LIST
96146: LIST
96147: PUSH
96148: LD_INT 3
96150: NEG
96151: PUSH
96152: LD_INT 3
96154: NEG
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 4
96162: NEG
96163: PUSH
96164: LD_INT 3
96166: NEG
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: PUSH
96172: LD_INT 5
96174: NEG
96175: PUSH
96176: LD_INT 4
96178: NEG
96179: PUSH
96180: EMPTY
96181: LIST
96182: LIST
96183: PUSH
96184: LD_INT 5
96186: NEG
96187: PUSH
96188: LD_INT 5
96190: NEG
96191: PUSH
96192: EMPTY
96193: LIST
96194: LIST
96195: PUSH
96196: LD_INT 3
96198: NEG
96199: PUSH
96200: LD_INT 5
96202: NEG
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 5
96210: NEG
96211: PUSH
96212: LD_INT 3
96214: NEG
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: PUSH
96220: LD_INT 0
96222: PUSH
96223: LD_INT 3
96225: NEG
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 0
96233: PUSH
96234: LD_INT 4
96236: NEG
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: LD_INT 1
96244: PUSH
96245: LD_INT 3
96247: NEG
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: PUSH
96253: LD_INT 1
96255: PUSH
96256: LD_INT 2
96258: NEG
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PUSH
96264: LD_INT 0
96266: PUSH
96267: LD_INT 2
96269: NEG
96270: PUSH
96271: EMPTY
96272: LIST
96273: LIST
96274: PUSH
96275: LD_INT 1
96277: NEG
96278: PUSH
96279: LD_INT 3
96281: NEG
96282: PUSH
96283: EMPTY
96284: LIST
96285: LIST
96286: PUSH
96287: LD_INT 1
96289: NEG
96290: PUSH
96291: LD_INT 4
96293: NEG
96294: PUSH
96295: EMPTY
96296: LIST
96297: LIST
96298: PUSH
96299: LD_INT 2
96301: PUSH
96302: LD_INT 2
96304: NEG
96305: PUSH
96306: EMPTY
96307: LIST
96308: LIST
96309: PUSH
96310: LD_INT 2
96312: NEG
96313: PUSH
96314: LD_INT 4
96316: NEG
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: PUSH
96322: LD_INT 4
96324: PUSH
96325: LD_INT 0
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: LD_INT 4
96334: PUSH
96335: LD_INT 1
96337: NEG
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 5
96345: PUSH
96346: LD_INT 0
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 5
96355: PUSH
96356: LD_INT 1
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: PUSH
96363: LD_INT 4
96365: PUSH
96366: LD_INT 1
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PUSH
96373: LD_INT 3
96375: PUSH
96376: LD_INT 0
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: PUSH
96383: LD_INT 3
96385: PUSH
96386: LD_INT 1
96388: NEG
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 3
96396: PUSH
96397: LD_INT 2
96399: NEG
96400: PUSH
96401: EMPTY
96402: LIST
96403: LIST
96404: PUSH
96405: LD_INT 5
96407: PUSH
96408: LD_INT 2
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: LD_INT 3
96417: PUSH
96418: LD_INT 3
96420: PUSH
96421: EMPTY
96422: LIST
96423: LIST
96424: PUSH
96425: LD_INT 3
96427: PUSH
96428: LD_INT 2
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: LD_INT 4
96437: PUSH
96438: LD_INT 3
96440: PUSH
96441: EMPTY
96442: LIST
96443: LIST
96444: PUSH
96445: LD_INT 4
96447: PUSH
96448: LD_INT 4
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PUSH
96455: LD_INT 3
96457: PUSH
96458: LD_INT 4
96460: PUSH
96461: EMPTY
96462: LIST
96463: LIST
96464: PUSH
96465: LD_INT 2
96467: PUSH
96468: LD_INT 3
96470: PUSH
96471: EMPTY
96472: LIST
96473: LIST
96474: PUSH
96475: LD_INT 2
96477: PUSH
96478: LD_INT 2
96480: PUSH
96481: EMPTY
96482: LIST
96483: LIST
96484: PUSH
96485: LD_INT 4
96487: PUSH
96488: LD_INT 2
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: PUSH
96495: LD_INT 2
96497: PUSH
96498: LD_INT 4
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 0
96507: PUSH
96508: LD_INT 4
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 0
96517: PUSH
96518: LD_INT 3
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: PUSH
96525: LD_INT 1
96527: PUSH
96528: LD_INT 4
96530: PUSH
96531: EMPTY
96532: LIST
96533: LIST
96534: PUSH
96535: LD_INT 1
96537: PUSH
96538: LD_INT 5
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: PUSH
96545: LD_INT 0
96547: PUSH
96548: LD_INT 5
96550: PUSH
96551: EMPTY
96552: LIST
96553: LIST
96554: PUSH
96555: LD_INT 1
96557: NEG
96558: PUSH
96559: LD_INT 4
96561: PUSH
96562: EMPTY
96563: LIST
96564: LIST
96565: PUSH
96566: LD_INT 1
96568: NEG
96569: PUSH
96570: LD_INT 3
96572: PUSH
96573: EMPTY
96574: LIST
96575: LIST
96576: PUSH
96577: LD_INT 2
96579: PUSH
96580: LD_INT 5
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: LD_INT 2
96589: NEG
96590: PUSH
96591: LD_INT 3
96593: PUSH
96594: EMPTY
96595: LIST
96596: LIST
96597: PUSH
96598: EMPTY
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96645: LD_ADDR_VAR 0 34
96649: PUSH
96650: LD_INT 0
96652: PUSH
96653: LD_INT 4
96655: NEG
96656: PUSH
96657: EMPTY
96658: LIST
96659: LIST
96660: PUSH
96661: LD_INT 0
96663: PUSH
96664: LD_INT 5
96666: NEG
96667: PUSH
96668: EMPTY
96669: LIST
96670: LIST
96671: PUSH
96672: LD_INT 1
96674: PUSH
96675: LD_INT 4
96677: NEG
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: PUSH
96683: LD_INT 1
96685: PUSH
96686: LD_INT 3
96688: NEG
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: PUSH
96694: LD_INT 0
96696: PUSH
96697: LD_INT 3
96699: NEG
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 1
96707: NEG
96708: PUSH
96709: LD_INT 4
96711: NEG
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PUSH
96717: LD_INT 1
96719: NEG
96720: PUSH
96721: LD_INT 5
96723: NEG
96724: PUSH
96725: EMPTY
96726: LIST
96727: LIST
96728: PUSH
96729: LD_INT 2
96731: PUSH
96732: LD_INT 3
96734: NEG
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 2
96742: NEG
96743: PUSH
96744: LD_INT 5
96746: NEG
96747: PUSH
96748: EMPTY
96749: LIST
96750: LIST
96751: PUSH
96752: LD_INT 3
96754: PUSH
96755: LD_INT 0
96757: PUSH
96758: EMPTY
96759: LIST
96760: LIST
96761: PUSH
96762: LD_INT 3
96764: PUSH
96765: LD_INT 1
96767: NEG
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PUSH
96773: LD_INT 4
96775: PUSH
96776: LD_INT 0
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: PUSH
96783: LD_INT 4
96785: PUSH
96786: LD_INT 1
96788: PUSH
96789: EMPTY
96790: LIST
96791: LIST
96792: PUSH
96793: LD_INT 3
96795: PUSH
96796: LD_INT 1
96798: PUSH
96799: EMPTY
96800: LIST
96801: LIST
96802: PUSH
96803: LD_INT 2
96805: PUSH
96806: LD_INT 0
96808: PUSH
96809: EMPTY
96810: LIST
96811: LIST
96812: PUSH
96813: LD_INT 2
96815: PUSH
96816: LD_INT 1
96818: NEG
96819: PUSH
96820: EMPTY
96821: LIST
96822: LIST
96823: PUSH
96824: LD_INT 2
96826: PUSH
96827: LD_INT 2
96829: NEG
96830: PUSH
96831: EMPTY
96832: LIST
96833: LIST
96834: PUSH
96835: LD_INT 4
96837: PUSH
96838: LD_INT 2
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: PUSH
96845: LD_INT 4
96847: PUSH
96848: LD_INT 4
96850: PUSH
96851: EMPTY
96852: LIST
96853: LIST
96854: PUSH
96855: LD_INT 4
96857: PUSH
96858: LD_INT 3
96860: PUSH
96861: EMPTY
96862: LIST
96863: LIST
96864: PUSH
96865: LD_INT 5
96867: PUSH
96868: LD_INT 4
96870: PUSH
96871: EMPTY
96872: LIST
96873: LIST
96874: PUSH
96875: LD_INT 5
96877: PUSH
96878: LD_INT 5
96880: PUSH
96881: EMPTY
96882: LIST
96883: LIST
96884: PUSH
96885: LD_INT 4
96887: PUSH
96888: LD_INT 5
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: PUSH
96895: LD_INT 3
96897: PUSH
96898: LD_INT 4
96900: PUSH
96901: EMPTY
96902: LIST
96903: LIST
96904: PUSH
96905: LD_INT 3
96907: PUSH
96908: LD_INT 3
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: PUSH
96915: LD_INT 5
96917: PUSH
96918: LD_INT 3
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: PUSH
96925: LD_INT 3
96927: PUSH
96928: LD_INT 5
96930: PUSH
96931: EMPTY
96932: LIST
96933: LIST
96934: PUSH
96935: LD_INT 0
96937: PUSH
96938: LD_INT 3
96940: PUSH
96941: EMPTY
96942: LIST
96943: LIST
96944: PUSH
96945: LD_INT 0
96947: PUSH
96948: LD_INT 2
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: LD_INT 1
96957: PUSH
96958: LD_INT 3
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 1
96967: PUSH
96968: LD_INT 4
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 0
96977: PUSH
96978: LD_INT 4
96980: PUSH
96981: EMPTY
96982: LIST
96983: LIST
96984: PUSH
96985: LD_INT 1
96987: NEG
96988: PUSH
96989: LD_INT 3
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: PUSH
96996: LD_INT 1
96998: NEG
96999: PUSH
97000: LD_INT 2
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 2
97009: PUSH
97010: LD_INT 4
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 2
97019: NEG
97020: PUSH
97021: LD_INT 2
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PUSH
97028: LD_INT 4
97030: NEG
97031: PUSH
97032: LD_INT 0
97034: PUSH
97035: EMPTY
97036: LIST
97037: LIST
97038: PUSH
97039: LD_INT 4
97041: NEG
97042: PUSH
97043: LD_INT 1
97045: NEG
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PUSH
97051: LD_INT 3
97053: NEG
97054: PUSH
97055: LD_INT 0
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: PUSH
97062: LD_INT 3
97064: NEG
97065: PUSH
97066: LD_INT 1
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: LD_INT 4
97075: NEG
97076: PUSH
97077: LD_INT 1
97079: PUSH
97080: EMPTY
97081: LIST
97082: LIST
97083: PUSH
97084: LD_INT 5
97086: NEG
97087: PUSH
97088: LD_INT 0
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 5
97097: NEG
97098: PUSH
97099: LD_INT 1
97101: NEG
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 5
97109: NEG
97110: PUSH
97111: LD_INT 2
97113: NEG
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 3
97121: NEG
97122: PUSH
97123: LD_INT 2
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: EMPTY
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: ST_TO_ADDR
// end ; end ;
97177: GO 97180
97179: POP
// case btype of b_depot , b_warehouse :
97180: LD_VAR 0 1
97184: PUSH
97185: LD_INT 0
97187: DOUBLE
97188: EQUAL
97189: IFTRUE 97199
97191: LD_INT 1
97193: DOUBLE
97194: EQUAL
97195: IFTRUE 97199
97197: GO 97400
97199: POP
// case nation of nation_american :
97200: LD_VAR 0 5
97204: PUSH
97205: LD_INT 1
97207: DOUBLE
97208: EQUAL
97209: IFTRUE 97213
97211: GO 97269
97213: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97214: LD_ADDR_VAR 0 9
97218: PUSH
97219: LD_VAR 0 11
97223: PUSH
97224: LD_VAR 0 12
97228: PUSH
97229: LD_VAR 0 13
97233: PUSH
97234: LD_VAR 0 14
97238: PUSH
97239: LD_VAR 0 15
97243: PUSH
97244: LD_VAR 0 16
97248: PUSH
97249: EMPTY
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: PUSH
97257: LD_VAR 0 4
97261: PUSH
97262: LD_INT 1
97264: PLUS
97265: ARRAY
97266: ST_TO_ADDR
97267: GO 97398
97269: LD_INT 2
97271: DOUBLE
97272: EQUAL
97273: IFTRUE 97277
97275: GO 97333
97277: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97278: LD_ADDR_VAR 0 9
97282: PUSH
97283: LD_VAR 0 17
97287: PUSH
97288: LD_VAR 0 18
97292: PUSH
97293: LD_VAR 0 19
97297: PUSH
97298: LD_VAR 0 20
97302: PUSH
97303: LD_VAR 0 21
97307: PUSH
97308: LD_VAR 0 22
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: LIST
97317: LIST
97318: LIST
97319: LIST
97320: PUSH
97321: LD_VAR 0 4
97325: PUSH
97326: LD_INT 1
97328: PLUS
97329: ARRAY
97330: ST_TO_ADDR
97331: GO 97398
97333: LD_INT 3
97335: DOUBLE
97336: EQUAL
97337: IFTRUE 97341
97339: GO 97397
97341: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97342: LD_ADDR_VAR 0 9
97346: PUSH
97347: LD_VAR 0 23
97351: PUSH
97352: LD_VAR 0 24
97356: PUSH
97357: LD_VAR 0 25
97361: PUSH
97362: LD_VAR 0 26
97366: PUSH
97367: LD_VAR 0 27
97371: PUSH
97372: LD_VAR 0 28
97376: PUSH
97377: EMPTY
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: PUSH
97385: LD_VAR 0 4
97389: PUSH
97390: LD_INT 1
97392: PLUS
97393: ARRAY
97394: ST_TO_ADDR
97395: GO 97398
97397: POP
97398: GO 97953
97400: LD_INT 2
97402: DOUBLE
97403: EQUAL
97404: IFTRUE 97414
97406: LD_INT 3
97408: DOUBLE
97409: EQUAL
97410: IFTRUE 97414
97412: GO 97470
97414: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97415: LD_ADDR_VAR 0 9
97419: PUSH
97420: LD_VAR 0 29
97424: PUSH
97425: LD_VAR 0 30
97429: PUSH
97430: LD_VAR 0 31
97434: PUSH
97435: LD_VAR 0 32
97439: PUSH
97440: LD_VAR 0 33
97444: PUSH
97445: LD_VAR 0 34
97449: PUSH
97450: EMPTY
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: PUSH
97458: LD_VAR 0 4
97462: PUSH
97463: LD_INT 1
97465: PLUS
97466: ARRAY
97467: ST_TO_ADDR
97468: GO 97953
97470: LD_INT 16
97472: DOUBLE
97473: EQUAL
97474: IFTRUE 97532
97476: LD_INT 17
97478: DOUBLE
97479: EQUAL
97480: IFTRUE 97532
97482: LD_INT 18
97484: DOUBLE
97485: EQUAL
97486: IFTRUE 97532
97488: LD_INT 19
97490: DOUBLE
97491: EQUAL
97492: IFTRUE 97532
97494: LD_INT 22
97496: DOUBLE
97497: EQUAL
97498: IFTRUE 97532
97500: LD_INT 20
97502: DOUBLE
97503: EQUAL
97504: IFTRUE 97532
97506: LD_INT 21
97508: DOUBLE
97509: EQUAL
97510: IFTRUE 97532
97512: LD_INT 23
97514: DOUBLE
97515: EQUAL
97516: IFTRUE 97532
97518: LD_INT 24
97520: DOUBLE
97521: EQUAL
97522: IFTRUE 97532
97524: LD_INT 25
97526: DOUBLE
97527: EQUAL
97528: IFTRUE 97532
97530: GO 97588
97532: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97533: LD_ADDR_VAR 0 9
97537: PUSH
97538: LD_VAR 0 35
97542: PUSH
97543: LD_VAR 0 36
97547: PUSH
97548: LD_VAR 0 37
97552: PUSH
97553: LD_VAR 0 38
97557: PUSH
97558: LD_VAR 0 39
97562: PUSH
97563: LD_VAR 0 40
97567: PUSH
97568: EMPTY
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: PUSH
97576: LD_VAR 0 4
97580: PUSH
97581: LD_INT 1
97583: PLUS
97584: ARRAY
97585: ST_TO_ADDR
97586: GO 97953
97588: LD_INT 6
97590: DOUBLE
97591: EQUAL
97592: IFTRUE 97644
97594: LD_INT 7
97596: DOUBLE
97597: EQUAL
97598: IFTRUE 97644
97600: LD_INT 8
97602: DOUBLE
97603: EQUAL
97604: IFTRUE 97644
97606: LD_INT 13
97608: DOUBLE
97609: EQUAL
97610: IFTRUE 97644
97612: LD_INT 12
97614: DOUBLE
97615: EQUAL
97616: IFTRUE 97644
97618: LD_INT 15
97620: DOUBLE
97621: EQUAL
97622: IFTRUE 97644
97624: LD_INT 11
97626: DOUBLE
97627: EQUAL
97628: IFTRUE 97644
97630: LD_INT 14
97632: DOUBLE
97633: EQUAL
97634: IFTRUE 97644
97636: LD_INT 10
97638: DOUBLE
97639: EQUAL
97640: IFTRUE 97644
97642: GO 97700
97644: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97645: LD_ADDR_VAR 0 9
97649: PUSH
97650: LD_VAR 0 41
97654: PUSH
97655: LD_VAR 0 42
97659: PUSH
97660: LD_VAR 0 43
97664: PUSH
97665: LD_VAR 0 44
97669: PUSH
97670: LD_VAR 0 45
97674: PUSH
97675: LD_VAR 0 46
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: PUSH
97688: LD_VAR 0 4
97692: PUSH
97693: LD_INT 1
97695: PLUS
97696: ARRAY
97697: ST_TO_ADDR
97698: GO 97953
97700: LD_INT 36
97702: DOUBLE
97703: EQUAL
97704: IFTRUE 97708
97706: GO 97764
97708: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97709: LD_ADDR_VAR 0 9
97713: PUSH
97714: LD_VAR 0 47
97718: PUSH
97719: LD_VAR 0 48
97723: PUSH
97724: LD_VAR 0 49
97728: PUSH
97729: LD_VAR 0 50
97733: PUSH
97734: LD_VAR 0 51
97738: PUSH
97739: LD_VAR 0 52
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: PUSH
97752: LD_VAR 0 4
97756: PUSH
97757: LD_INT 1
97759: PLUS
97760: ARRAY
97761: ST_TO_ADDR
97762: GO 97953
97764: LD_INT 4
97766: DOUBLE
97767: EQUAL
97768: IFTRUE 97790
97770: LD_INT 5
97772: DOUBLE
97773: EQUAL
97774: IFTRUE 97790
97776: LD_INT 34
97778: DOUBLE
97779: EQUAL
97780: IFTRUE 97790
97782: LD_INT 37
97784: DOUBLE
97785: EQUAL
97786: IFTRUE 97790
97788: GO 97846
97790: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97791: LD_ADDR_VAR 0 9
97795: PUSH
97796: LD_VAR 0 53
97800: PUSH
97801: LD_VAR 0 54
97805: PUSH
97806: LD_VAR 0 55
97810: PUSH
97811: LD_VAR 0 56
97815: PUSH
97816: LD_VAR 0 57
97820: PUSH
97821: LD_VAR 0 58
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: PUSH
97834: LD_VAR 0 4
97838: PUSH
97839: LD_INT 1
97841: PLUS
97842: ARRAY
97843: ST_TO_ADDR
97844: GO 97953
97846: LD_INT 31
97848: DOUBLE
97849: EQUAL
97850: IFTRUE 97896
97852: LD_INT 32
97854: DOUBLE
97855: EQUAL
97856: IFTRUE 97896
97858: LD_INT 33
97860: DOUBLE
97861: EQUAL
97862: IFTRUE 97896
97864: LD_INT 27
97866: DOUBLE
97867: EQUAL
97868: IFTRUE 97896
97870: LD_INT 26
97872: DOUBLE
97873: EQUAL
97874: IFTRUE 97896
97876: LD_INT 28
97878: DOUBLE
97879: EQUAL
97880: IFTRUE 97896
97882: LD_INT 29
97884: DOUBLE
97885: EQUAL
97886: IFTRUE 97896
97888: LD_INT 30
97890: DOUBLE
97891: EQUAL
97892: IFTRUE 97896
97894: GO 97952
97896: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
97897: LD_ADDR_VAR 0 9
97901: PUSH
97902: LD_VAR 0 59
97906: PUSH
97907: LD_VAR 0 60
97911: PUSH
97912: LD_VAR 0 61
97916: PUSH
97917: LD_VAR 0 62
97921: PUSH
97922: LD_VAR 0 63
97926: PUSH
97927: LD_VAR 0 64
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: PUSH
97940: LD_VAR 0 4
97944: PUSH
97945: LD_INT 1
97947: PLUS
97948: ARRAY
97949: ST_TO_ADDR
97950: GO 97953
97952: POP
// temp_list2 = [ ] ;
97953: LD_ADDR_VAR 0 10
97957: PUSH
97958: EMPTY
97959: ST_TO_ADDR
// for i in temp_list do
97960: LD_ADDR_VAR 0 8
97964: PUSH
97965: LD_VAR 0 9
97969: PUSH
97970: FOR_IN
97971: IFFALSE 98023
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97973: LD_ADDR_VAR 0 10
97977: PUSH
97978: LD_VAR 0 10
97982: PUSH
97983: LD_VAR 0 8
97987: PUSH
97988: LD_INT 1
97990: ARRAY
97991: PUSH
97992: LD_VAR 0 2
97996: PLUS
97997: PUSH
97998: LD_VAR 0 8
98002: PUSH
98003: LD_INT 2
98005: ARRAY
98006: PUSH
98007: LD_VAR 0 3
98011: PLUS
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PUSH
98017: EMPTY
98018: LIST
98019: ADD
98020: ST_TO_ADDR
98021: GO 97970
98023: POP
98024: POP
// result = temp_list2 ;
98025: LD_ADDR_VAR 0 7
98029: PUSH
98030: LD_VAR 0 10
98034: ST_TO_ADDR
// end ;
98035: LD_VAR 0 7
98039: RET
// export function EnemyInRange ( unit , dist ) ; begin
98040: LD_INT 0
98042: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98043: LD_ADDR_VAR 0 3
98047: PUSH
98048: LD_VAR 0 1
98052: PPUSH
98053: CALL_OW 255
98057: PPUSH
98058: LD_VAR 0 1
98062: PPUSH
98063: CALL_OW 250
98067: PPUSH
98068: LD_VAR 0 1
98072: PPUSH
98073: CALL_OW 251
98077: PPUSH
98078: LD_VAR 0 2
98082: PPUSH
98083: CALL 71435 0 4
98087: PUSH
98088: LD_INT 4
98090: ARRAY
98091: ST_TO_ADDR
// end ;
98092: LD_VAR 0 3
98096: RET
// export function PlayerSeeMe ( unit ) ; begin
98097: LD_INT 0
98099: PPUSH
// result := See ( your_side , unit ) ;
98100: LD_ADDR_VAR 0 2
98104: PUSH
98105: LD_OWVAR 2
98109: PPUSH
98110: LD_VAR 0 1
98114: PPUSH
98115: CALL_OW 292
98119: ST_TO_ADDR
// end ;
98120: LD_VAR 0 2
98124: RET
// export function ReverseDir ( unit ) ; begin
98125: LD_INT 0
98127: PPUSH
// if not unit then
98128: LD_VAR 0 1
98132: NOT
98133: IFFALSE 98137
// exit ;
98135: GO 98160
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98137: LD_ADDR_VAR 0 2
98141: PUSH
98142: LD_VAR 0 1
98146: PPUSH
98147: CALL_OW 254
98151: PUSH
98152: LD_INT 3
98154: PLUS
98155: PUSH
98156: LD_INT 6
98158: MOD
98159: ST_TO_ADDR
// end ;
98160: LD_VAR 0 2
98164: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98165: LD_INT 0
98167: PPUSH
98168: PPUSH
98169: PPUSH
98170: PPUSH
98171: PPUSH
// if not hexes then
98172: LD_VAR 0 2
98176: NOT
98177: IFFALSE 98181
// exit ;
98179: GO 98329
// dist := 9999 ;
98181: LD_ADDR_VAR 0 5
98185: PUSH
98186: LD_INT 9999
98188: ST_TO_ADDR
// for i = 1 to hexes do
98189: LD_ADDR_VAR 0 4
98193: PUSH
98194: DOUBLE
98195: LD_INT 1
98197: DEC
98198: ST_TO_ADDR
98199: LD_VAR 0 2
98203: PUSH
98204: FOR_TO
98205: IFFALSE 98317
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98207: LD_VAR 0 1
98211: PPUSH
98212: LD_VAR 0 2
98216: PUSH
98217: LD_VAR 0 4
98221: ARRAY
98222: PUSH
98223: LD_INT 1
98225: ARRAY
98226: PPUSH
98227: LD_VAR 0 2
98231: PUSH
98232: LD_VAR 0 4
98236: ARRAY
98237: PUSH
98238: LD_INT 2
98240: ARRAY
98241: PPUSH
98242: CALL_OW 297
98246: PUSH
98247: LD_VAR 0 5
98251: LESS
98252: IFFALSE 98315
// begin hex := hexes [ i ] ;
98254: LD_ADDR_VAR 0 7
98258: PUSH
98259: LD_VAR 0 2
98263: PUSH
98264: LD_VAR 0 4
98268: ARRAY
98269: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98270: LD_ADDR_VAR 0 5
98274: PUSH
98275: LD_VAR 0 1
98279: PPUSH
98280: LD_VAR 0 2
98284: PUSH
98285: LD_VAR 0 4
98289: ARRAY
98290: PUSH
98291: LD_INT 1
98293: ARRAY
98294: PPUSH
98295: LD_VAR 0 2
98299: PUSH
98300: LD_VAR 0 4
98304: ARRAY
98305: PUSH
98306: LD_INT 2
98308: ARRAY
98309: PPUSH
98310: CALL_OW 297
98314: ST_TO_ADDR
// end ; end ;
98315: GO 98204
98317: POP
98318: POP
// result := hex ;
98319: LD_ADDR_VAR 0 3
98323: PUSH
98324: LD_VAR 0 7
98328: ST_TO_ADDR
// end ;
98329: LD_VAR 0 3
98333: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98334: LD_INT 0
98336: PPUSH
98337: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98338: LD_VAR 0 1
98342: NOT
98343: PUSH
98344: LD_VAR 0 1
98348: PUSH
98349: LD_INT 21
98351: PUSH
98352: LD_INT 2
98354: PUSH
98355: EMPTY
98356: LIST
98357: LIST
98358: PUSH
98359: LD_INT 23
98361: PUSH
98362: LD_INT 2
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PUSH
98369: EMPTY
98370: LIST
98371: LIST
98372: PPUSH
98373: CALL_OW 69
98377: IN
98378: NOT
98379: OR
98380: IFFALSE 98384
// exit ;
98382: GO 98431
// for i = 1 to 3 do
98384: LD_ADDR_VAR 0 3
98388: PUSH
98389: DOUBLE
98390: LD_INT 1
98392: DEC
98393: ST_TO_ADDR
98394: LD_INT 3
98396: PUSH
98397: FOR_TO
98398: IFFALSE 98429
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98400: LD_VAR 0 1
98404: PPUSH
98405: CALL_OW 250
98409: PPUSH
98410: LD_VAR 0 1
98414: PPUSH
98415: CALL_OW 251
98419: PPUSH
98420: LD_INT 1
98422: PPUSH
98423: CALL_OW 453
98427: GO 98397
98429: POP
98430: POP
// end ;
98431: LD_VAR 0 2
98435: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98436: LD_INT 0
98438: PPUSH
98439: PPUSH
98440: PPUSH
98441: PPUSH
98442: PPUSH
98443: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98444: LD_VAR 0 1
98448: NOT
98449: PUSH
98450: LD_VAR 0 2
98454: NOT
98455: OR
98456: PUSH
98457: LD_VAR 0 1
98461: PPUSH
98462: CALL_OW 314
98466: OR
98467: IFFALSE 98471
// exit ;
98469: GO 98912
// x := GetX ( enemy_unit ) ;
98471: LD_ADDR_VAR 0 7
98475: PUSH
98476: LD_VAR 0 2
98480: PPUSH
98481: CALL_OW 250
98485: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98486: LD_ADDR_VAR 0 8
98490: PUSH
98491: LD_VAR 0 2
98495: PPUSH
98496: CALL_OW 251
98500: ST_TO_ADDR
// if not x or not y then
98501: LD_VAR 0 7
98505: NOT
98506: PUSH
98507: LD_VAR 0 8
98511: NOT
98512: OR
98513: IFFALSE 98517
// exit ;
98515: GO 98912
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98517: LD_ADDR_VAR 0 6
98521: PUSH
98522: LD_VAR 0 7
98526: PPUSH
98527: LD_INT 0
98529: PPUSH
98530: LD_INT 4
98532: PPUSH
98533: CALL_OW 272
98537: PUSH
98538: LD_VAR 0 8
98542: PPUSH
98543: LD_INT 0
98545: PPUSH
98546: LD_INT 4
98548: PPUSH
98549: CALL_OW 273
98553: PUSH
98554: EMPTY
98555: LIST
98556: LIST
98557: PUSH
98558: LD_VAR 0 7
98562: PPUSH
98563: LD_INT 1
98565: PPUSH
98566: LD_INT 4
98568: PPUSH
98569: CALL_OW 272
98573: PUSH
98574: LD_VAR 0 8
98578: PPUSH
98579: LD_INT 1
98581: PPUSH
98582: LD_INT 4
98584: PPUSH
98585: CALL_OW 273
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: PUSH
98594: LD_VAR 0 7
98598: PPUSH
98599: LD_INT 2
98601: PPUSH
98602: LD_INT 4
98604: PPUSH
98605: CALL_OW 272
98609: PUSH
98610: LD_VAR 0 8
98614: PPUSH
98615: LD_INT 2
98617: PPUSH
98618: LD_INT 4
98620: PPUSH
98621: CALL_OW 273
98625: PUSH
98626: EMPTY
98627: LIST
98628: LIST
98629: PUSH
98630: LD_VAR 0 7
98634: PPUSH
98635: LD_INT 3
98637: PPUSH
98638: LD_INT 4
98640: PPUSH
98641: CALL_OW 272
98645: PUSH
98646: LD_VAR 0 8
98650: PPUSH
98651: LD_INT 3
98653: PPUSH
98654: LD_INT 4
98656: PPUSH
98657: CALL_OW 273
98661: PUSH
98662: EMPTY
98663: LIST
98664: LIST
98665: PUSH
98666: LD_VAR 0 7
98670: PPUSH
98671: LD_INT 4
98673: PPUSH
98674: LD_INT 4
98676: PPUSH
98677: CALL_OW 272
98681: PUSH
98682: LD_VAR 0 8
98686: PPUSH
98687: LD_INT 4
98689: PPUSH
98690: LD_INT 4
98692: PPUSH
98693: CALL_OW 273
98697: PUSH
98698: EMPTY
98699: LIST
98700: LIST
98701: PUSH
98702: LD_VAR 0 7
98706: PPUSH
98707: LD_INT 5
98709: PPUSH
98710: LD_INT 4
98712: PPUSH
98713: CALL_OW 272
98717: PUSH
98718: LD_VAR 0 8
98722: PPUSH
98723: LD_INT 5
98725: PPUSH
98726: LD_INT 4
98728: PPUSH
98729: CALL_OW 273
98733: PUSH
98734: EMPTY
98735: LIST
98736: LIST
98737: PUSH
98738: EMPTY
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: ST_TO_ADDR
// for i = tmp downto 1 do
98746: LD_ADDR_VAR 0 4
98750: PUSH
98751: DOUBLE
98752: LD_VAR 0 6
98756: INC
98757: ST_TO_ADDR
98758: LD_INT 1
98760: PUSH
98761: FOR_DOWNTO
98762: IFFALSE 98863
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98764: LD_VAR 0 6
98768: PUSH
98769: LD_VAR 0 4
98773: ARRAY
98774: PUSH
98775: LD_INT 1
98777: ARRAY
98778: PPUSH
98779: LD_VAR 0 6
98783: PUSH
98784: LD_VAR 0 4
98788: ARRAY
98789: PUSH
98790: LD_INT 2
98792: ARRAY
98793: PPUSH
98794: CALL_OW 488
98798: NOT
98799: PUSH
98800: LD_VAR 0 6
98804: PUSH
98805: LD_VAR 0 4
98809: ARRAY
98810: PUSH
98811: LD_INT 1
98813: ARRAY
98814: PPUSH
98815: LD_VAR 0 6
98819: PUSH
98820: LD_VAR 0 4
98824: ARRAY
98825: PUSH
98826: LD_INT 2
98828: ARRAY
98829: PPUSH
98830: CALL_OW 428
98834: PUSH
98835: LD_INT 0
98837: NONEQUAL
98838: OR
98839: IFFALSE 98861
// tmp := Delete ( tmp , i ) ;
98841: LD_ADDR_VAR 0 6
98845: PUSH
98846: LD_VAR 0 6
98850: PPUSH
98851: LD_VAR 0 4
98855: PPUSH
98856: CALL_OW 3
98860: ST_TO_ADDR
98861: GO 98761
98863: POP
98864: POP
// j := GetClosestHex ( unit , tmp ) ;
98865: LD_ADDR_VAR 0 5
98869: PUSH
98870: LD_VAR 0 1
98874: PPUSH
98875: LD_VAR 0 6
98879: PPUSH
98880: CALL 98165 0 2
98884: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98885: LD_VAR 0 1
98889: PPUSH
98890: LD_VAR 0 5
98894: PUSH
98895: LD_INT 1
98897: ARRAY
98898: PPUSH
98899: LD_VAR 0 5
98903: PUSH
98904: LD_INT 2
98906: ARRAY
98907: PPUSH
98908: CALL_OW 111
// end ;
98912: LD_VAR 0 3
98916: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98917: LD_INT 0
98919: PPUSH
98920: PPUSH
98921: PPUSH
// uc_side = 0 ;
98922: LD_ADDR_OWVAR 20
98926: PUSH
98927: LD_INT 0
98929: ST_TO_ADDR
// uc_nation = 0 ;
98930: LD_ADDR_OWVAR 21
98934: PUSH
98935: LD_INT 0
98937: ST_TO_ADDR
// InitHc_All ( ) ;
98938: CALL_OW 584
// InitVc ;
98942: CALL_OW 20
// if mastodonts then
98946: LD_VAR 0 6
98950: IFFALSE 99017
// for i = 1 to mastodonts do
98952: LD_ADDR_VAR 0 11
98956: PUSH
98957: DOUBLE
98958: LD_INT 1
98960: DEC
98961: ST_TO_ADDR
98962: LD_VAR 0 6
98966: PUSH
98967: FOR_TO
98968: IFFALSE 99015
// begin vc_chassis := 31 ;
98970: LD_ADDR_OWVAR 37
98974: PUSH
98975: LD_INT 31
98977: ST_TO_ADDR
// vc_control := control_rider ;
98978: LD_ADDR_OWVAR 38
98982: PUSH
98983: LD_INT 4
98985: ST_TO_ADDR
// animal := CreateVehicle ;
98986: LD_ADDR_VAR 0 12
98990: PUSH
98991: CALL_OW 45
98995: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98996: LD_VAR 0 12
99000: PPUSH
99001: LD_VAR 0 8
99005: PPUSH
99006: LD_INT 0
99008: PPUSH
99009: CALL 101205 0 3
// end ;
99013: GO 98967
99015: POP
99016: POP
// if horses then
99017: LD_VAR 0 5
99021: IFFALSE 99088
// for i = 1 to horses do
99023: LD_ADDR_VAR 0 11
99027: PUSH
99028: DOUBLE
99029: LD_INT 1
99031: DEC
99032: ST_TO_ADDR
99033: LD_VAR 0 5
99037: PUSH
99038: FOR_TO
99039: IFFALSE 99086
// begin hc_class := 21 ;
99041: LD_ADDR_OWVAR 28
99045: PUSH
99046: LD_INT 21
99048: ST_TO_ADDR
// hc_gallery :=  ;
99049: LD_ADDR_OWVAR 33
99053: PUSH
99054: LD_STRING 
99056: ST_TO_ADDR
// animal := CreateHuman ;
99057: LD_ADDR_VAR 0 12
99061: PUSH
99062: CALL_OW 44
99066: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99067: LD_VAR 0 12
99071: PPUSH
99072: LD_VAR 0 8
99076: PPUSH
99077: LD_INT 0
99079: PPUSH
99080: CALL 101205 0 3
// end ;
99084: GO 99038
99086: POP
99087: POP
// if birds then
99088: LD_VAR 0 1
99092: IFFALSE 99159
// for i = 1 to birds do
99094: LD_ADDR_VAR 0 11
99098: PUSH
99099: DOUBLE
99100: LD_INT 1
99102: DEC
99103: ST_TO_ADDR
99104: LD_VAR 0 1
99108: PUSH
99109: FOR_TO
99110: IFFALSE 99157
// begin hc_class = 18 ;
99112: LD_ADDR_OWVAR 28
99116: PUSH
99117: LD_INT 18
99119: ST_TO_ADDR
// hc_gallery =  ;
99120: LD_ADDR_OWVAR 33
99124: PUSH
99125: LD_STRING 
99127: ST_TO_ADDR
// animal := CreateHuman ;
99128: LD_ADDR_VAR 0 12
99132: PUSH
99133: CALL_OW 44
99137: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99138: LD_VAR 0 12
99142: PPUSH
99143: LD_VAR 0 8
99147: PPUSH
99148: LD_INT 0
99150: PPUSH
99151: CALL 101205 0 3
// end ;
99155: GO 99109
99157: POP
99158: POP
// if tigers then
99159: LD_VAR 0 2
99163: IFFALSE 99247
// for i = 1 to tigers do
99165: LD_ADDR_VAR 0 11
99169: PUSH
99170: DOUBLE
99171: LD_INT 1
99173: DEC
99174: ST_TO_ADDR
99175: LD_VAR 0 2
99179: PUSH
99180: FOR_TO
99181: IFFALSE 99245
// begin hc_class = class_tiger ;
99183: LD_ADDR_OWVAR 28
99187: PUSH
99188: LD_INT 14
99190: ST_TO_ADDR
// hc_gallery =  ;
99191: LD_ADDR_OWVAR 33
99195: PUSH
99196: LD_STRING 
99198: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99199: LD_ADDR_OWVAR 35
99203: PUSH
99204: LD_INT 7
99206: NEG
99207: PPUSH
99208: LD_INT 7
99210: PPUSH
99211: CALL_OW 12
99215: ST_TO_ADDR
// animal := CreateHuman ;
99216: LD_ADDR_VAR 0 12
99220: PUSH
99221: CALL_OW 44
99225: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99226: LD_VAR 0 12
99230: PPUSH
99231: LD_VAR 0 8
99235: PPUSH
99236: LD_INT 0
99238: PPUSH
99239: CALL 101205 0 3
// end ;
99243: GO 99180
99245: POP
99246: POP
// if apemans then
99247: LD_VAR 0 3
99251: IFFALSE 99374
// for i = 1 to apemans do
99253: LD_ADDR_VAR 0 11
99257: PUSH
99258: DOUBLE
99259: LD_INT 1
99261: DEC
99262: ST_TO_ADDR
99263: LD_VAR 0 3
99267: PUSH
99268: FOR_TO
99269: IFFALSE 99372
// begin hc_class = class_apeman ;
99271: LD_ADDR_OWVAR 28
99275: PUSH
99276: LD_INT 12
99278: ST_TO_ADDR
// hc_gallery =  ;
99279: LD_ADDR_OWVAR 33
99283: PUSH
99284: LD_STRING 
99286: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
99287: LD_ADDR_OWVAR 35
99291: PUSH
99292: LD_INT 2
99294: NEG
99295: PPUSH
99296: LD_INT 2
99298: PPUSH
99299: CALL_OW 12
99303: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99304: LD_ADDR_OWVAR 31
99308: PUSH
99309: LD_INT 1
99311: PPUSH
99312: LD_INT 3
99314: PPUSH
99315: CALL_OW 12
99319: PUSH
99320: LD_INT 1
99322: PPUSH
99323: LD_INT 3
99325: PPUSH
99326: CALL_OW 12
99330: PUSH
99331: LD_INT 0
99333: PUSH
99334: LD_INT 0
99336: PUSH
99337: EMPTY
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: ST_TO_ADDR
// animal := CreateHuman ;
99343: LD_ADDR_VAR 0 12
99347: PUSH
99348: CALL_OW 44
99352: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99353: LD_VAR 0 12
99357: PPUSH
99358: LD_VAR 0 8
99362: PPUSH
99363: LD_INT 0
99365: PPUSH
99366: CALL 101205 0 3
// end ;
99370: GO 99268
99372: POP
99373: POP
// if enchidnas then
99374: LD_VAR 0 4
99378: IFFALSE 99445
// for i = 1 to enchidnas do
99380: LD_ADDR_VAR 0 11
99384: PUSH
99385: DOUBLE
99386: LD_INT 1
99388: DEC
99389: ST_TO_ADDR
99390: LD_VAR 0 4
99394: PUSH
99395: FOR_TO
99396: IFFALSE 99443
// begin hc_class = 13 ;
99398: LD_ADDR_OWVAR 28
99402: PUSH
99403: LD_INT 13
99405: ST_TO_ADDR
// hc_gallery =  ;
99406: LD_ADDR_OWVAR 33
99410: PUSH
99411: LD_STRING 
99413: ST_TO_ADDR
// animal := CreateHuman ;
99414: LD_ADDR_VAR 0 12
99418: PUSH
99419: CALL_OW 44
99423: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99424: LD_VAR 0 12
99428: PPUSH
99429: LD_VAR 0 8
99433: PPUSH
99434: LD_INT 0
99436: PPUSH
99437: CALL 101205 0 3
// end ;
99441: GO 99395
99443: POP
99444: POP
// if fishes then
99445: LD_VAR 0 7
99449: IFFALSE 99516
// for i = 1 to fishes do
99451: LD_ADDR_VAR 0 11
99455: PUSH
99456: DOUBLE
99457: LD_INT 1
99459: DEC
99460: ST_TO_ADDR
99461: LD_VAR 0 7
99465: PUSH
99466: FOR_TO
99467: IFFALSE 99514
// begin hc_class = 20 ;
99469: LD_ADDR_OWVAR 28
99473: PUSH
99474: LD_INT 20
99476: ST_TO_ADDR
// hc_gallery =  ;
99477: LD_ADDR_OWVAR 33
99481: PUSH
99482: LD_STRING 
99484: ST_TO_ADDR
// animal := CreateHuman ;
99485: LD_ADDR_VAR 0 12
99489: PUSH
99490: CALL_OW 44
99494: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99495: LD_VAR 0 12
99499: PPUSH
99500: LD_VAR 0 9
99504: PPUSH
99505: LD_INT 0
99507: PPUSH
99508: CALL 101205 0 3
// end ;
99512: GO 99466
99514: POP
99515: POP
// end ;
99516: LD_VAR 0 10
99520: RET
// export function WantHeal ( sci , unit ) ; begin
99521: LD_INT 0
99523: PPUSH
// if GetTaskList ( sci ) > 0 then
99524: LD_VAR 0 1
99528: PPUSH
99529: CALL_OW 437
99533: PUSH
99534: LD_INT 0
99536: GREATER
99537: IFFALSE 99607
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99539: LD_VAR 0 1
99543: PPUSH
99544: CALL_OW 437
99548: PUSH
99549: LD_INT 1
99551: ARRAY
99552: PUSH
99553: LD_INT 1
99555: ARRAY
99556: PUSH
99557: LD_STRING l
99559: EQUAL
99560: PUSH
99561: LD_VAR 0 1
99565: PPUSH
99566: CALL_OW 437
99570: PUSH
99571: LD_INT 1
99573: ARRAY
99574: PUSH
99575: LD_INT 4
99577: ARRAY
99578: PUSH
99579: LD_VAR 0 2
99583: EQUAL
99584: AND
99585: IFFALSE 99597
// result := true else
99587: LD_ADDR_VAR 0 3
99591: PUSH
99592: LD_INT 1
99594: ST_TO_ADDR
99595: GO 99605
// result := false ;
99597: LD_ADDR_VAR 0 3
99601: PUSH
99602: LD_INT 0
99604: ST_TO_ADDR
// end else
99605: GO 99615
// result := false ;
99607: LD_ADDR_VAR 0 3
99611: PUSH
99612: LD_INT 0
99614: ST_TO_ADDR
// end ;
99615: LD_VAR 0 3
99619: RET
// export function HealTarget ( sci ) ; begin
99620: LD_INT 0
99622: PPUSH
// if not sci then
99623: LD_VAR 0 1
99627: NOT
99628: IFFALSE 99632
// exit ;
99630: GO 99697
// result := 0 ;
99632: LD_ADDR_VAR 0 2
99636: PUSH
99637: LD_INT 0
99639: ST_TO_ADDR
// if GetTaskList ( sci ) then
99640: LD_VAR 0 1
99644: PPUSH
99645: CALL_OW 437
99649: IFFALSE 99697
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99651: LD_VAR 0 1
99655: PPUSH
99656: CALL_OW 437
99660: PUSH
99661: LD_INT 1
99663: ARRAY
99664: PUSH
99665: LD_INT 1
99667: ARRAY
99668: PUSH
99669: LD_STRING l
99671: EQUAL
99672: IFFALSE 99697
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99674: LD_ADDR_VAR 0 2
99678: PUSH
99679: LD_VAR 0 1
99683: PPUSH
99684: CALL_OW 437
99688: PUSH
99689: LD_INT 1
99691: ARRAY
99692: PUSH
99693: LD_INT 4
99695: ARRAY
99696: ST_TO_ADDR
// end ;
99697: LD_VAR 0 2
99701: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
99702: LD_INT 0
99704: PPUSH
99705: PPUSH
99706: PPUSH
99707: PPUSH
// if not base_units then
99708: LD_VAR 0 1
99712: NOT
99713: IFFALSE 99717
// exit ;
99715: GO 99804
// result := false ;
99717: LD_ADDR_VAR 0 2
99721: PUSH
99722: LD_INT 0
99724: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
99725: LD_ADDR_VAR 0 5
99729: PUSH
99730: LD_VAR 0 1
99734: PPUSH
99735: LD_INT 21
99737: PUSH
99738: LD_INT 3
99740: PUSH
99741: EMPTY
99742: LIST
99743: LIST
99744: PPUSH
99745: CALL_OW 72
99749: ST_TO_ADDR
// if not tmp then
99750: LD_VAR 0 5
99754: NOT
99755: IFFALSE 99759
// exit ;
99757: GO 99804
// for i in tmp do
99759: LD_ADDR_VAR 0 3
99763: PUSH
99764: LD_VAR 0 5
99768: PUSH
99769: FOR_IN
99770: IFFALSE 99802
// begin result := EnemyInRange ( i , 22 ) ;
99772: LD_ADDR_VAR 0 2
99776: PUSH
99777: LD_VAR 0 3
99781: PPUSH
99782: LD_INT 22
99784: PPUSH
99785: CALL 98040 0 2
99789: ST_TO_ADDR
// if result then
99790: LD_VAR 0 2
99794: IFFALSE 99800
// exit ;
99796: POP
99797: POP
99798: GO 99804
// end ;
99800: GO 99769
99802: POP
99803: POP
// end ;
99804: LD_VAR 0 2
99808: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
99809: LD_INT 0
99811: PPUSH
99812: PPUSH
// if not units then
99813: LD_VAR 0 1
99817: NOT
99818: IFFALSE 99822
// exit ;
99820: GO 99892
// result := [ ] ;
99822: LD_ADDR_VAR 0 3
99826: PUSH
99827: EMPTY
99828: ST_TO_ADDR
// for i in units do
99829: LD_ADDR_VAR 0 4
99833: PUSH
99834: LD_VAR 0 1
99838: PUSH
99839: FOR_IN
99840: IFFALSE 99890
// if GetTag ( i ) = tag then
99842: LD_VAR 0 4
99846: PPUSH
99847: CALL_OW 110
99851: PUSH
99852: LD_VAR 0 2
99856: EQUAL
99857: IFFALSE 99888
// result := Insert ( result , result + 1 , i ) ;
99859: LD_ADDR_VAR 0 3
99863: PUSH
99864: LD_VAR 0 3
99868: PPUSH
99869: LD_VAR 0 3
99873: PUSH
99874: LD_INT 1
99876: PLUS
99877: PPUSH
99878: LD_VAR 0 4
99882: PPUSH
99883: CALL_OW 2
99887: ST_TO_ADDR
99888: GO 99839
99890: POP
99891: POP
// end ;
99892: LD_VAR 0 3
99896: RET
// export function IsDriver ( un ) ; begin
99897: LD_INT 0
99899: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
99900: LD_ADDR_VAR 0 2
99904: PUSH
99905: LD_VAR 0 1
99909: PUSH
99910: LD_INT 55
99912: PUSH
99913: EMPTY
99914: LIST
99915: PPUSH
99916: CALL_OW 69
99920: IN
99921: ST_TO_ADDR
// end ;
99922: LD_VAR 0 2
99926: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
99927: LD_INT 0
99929: PPUSH
99930: PPUSH
// list := [ ] ;
99931: LD_ADDR_VAR 0 5
99935: PUSH
99936: EMPTY
99937: ST_TO_ADDR
// case d of 0 :
99938: LD_VAR 0 3
99942: PUSH
99943: LD_INT 0
99945: DOUBLE
99946: EQUAL
99947: IFTRUE 99951
99949: GO 100084
99951: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
99952: LD_ADDR_VAR 0 5
99956: PUSH
99957: LD_VAR 0 1
99961: PUSH
99962: LD_INT 4
99964: MINUS
99965: PUSH
99966: LD_VAR 0 2
99970: PUSH
99971: LD_INT 4
99973: MINUS
99974: PUSH
99975: LD_INT 2
99977: PUSH
99978: EMPTY
99979: LIST
99980: LIST
99981: LIST
99982: PUSH
99983: LD_VAR 0 1
99987: PUSH
99988: LD_INT 3
99990: MINUS
99991: PUSH
99992: LD_VAR 0 2
99996: PUSH
99997: LD_INT 1
99999: PUSH
100000: EMPTY
100001: LIST
100002: LIST
100003: LIST
100004: PUSH
100005: LD_VAR 0 1
100009: PUSH
100010: LD_INT 4
100012: PLUS
100013: PUSH
100014: LD_VAR 0 2
100018: PUSH
100019: LD_INT 4
100021: PUSH
100022: EMPTY
100023: LIST
100024: LIST
100025: LIST
100026: PUSH
100027: LD_VAR 0 1
100031: PUSH
100032: LD_INT 3
100034: PLUS
100035: PUSH
100036: LD_VAR 0 2
100040: PUSH
100041: LD_INT 3
100043: PLUS
100044: PUSH
100045: LD_INT 5
100047: PUSH
100048: EMPTY
100049: LIST
100050: LIST
100051: LIST
100052: PUSH
100053: LD_VAR 0 1
100057: PUSH
100058: LD_VAR 0 2
100062: PUSH
100063: LD_INT 4
100065: PLUS
100066: PUSH
100067: LD_INT 0
100069: PUSH
100070: EMPTY
100071: LIST
100072: LIST
100073: LIST
100074: PUSH
100075: EMPTY
100076: LIST
100077: LIST
100078: LIST
100079: LIST
100080: LIST
100081: ST_TO_ADDR
// end ; 1 :
100082: GO 100782
100084: LD_INT 1
100086: DOUBLE
100087: EQUAL
100088: IFTRUE 100092
100090: GO 100225
100092: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100093: LD_ADDR_VAR 0 5
100097: PUSH
100098: LD_VAR 0 1
100102: PUSH
100103: LD_VAR 0 2
100107: PUSH
100108: LD_INT 4
100110: MINUS
100111: PUSH
100112: LD_INT 3
100114: PUSH
100115: EMPTY
100116: LIST
100117: LIST
100118: LIST
100119: PUSH
100120: LD_VAR 0 1
100124: PUSH
100125: LD_INT 3
100127: MINUS
100128: PUSH
100129: LD_VAR 0 2
100133: PUSH
100134: LD_INT 3
100136: MINUS
100137: PUSH
100138: LD_INT 2
100140: PUSH
100141: EMPTY
100142: LIST
100143: LIST
100144: LIST
100145: PUSH
100146: LD_VAR 0 1
100150: PUSH
100151: LD_INT 4
100153: MINUS
100154: PUSH
100155: LD_VAR 0 2
100159: PUSH
100160: LD_INT 1
100162: PUSH
100163: EMPTY
100164: LIST
100165: LIST
100166: LIST
100167: PUSH
100168: LD_VAR 0 1
100172: PUSH
100173: LD_VAR 0 2
100177: PUSH
100178: LD_INT 3
100180: PLUS
100181: PUSH
100182: LD_INT 0
100184: PUSH
100185: EMPTY
100186: LIST
100187: LIST
100188: LIST
100189: PUSH
100190: LD_VAR 0 1
100194: PUSH
100195: LD_INT 4
100197: PLUS
100198: PUSH
100199: LD_VAR 0 2
100203: PUSH
100204: LD_INT 4
100206: PLUS
100207: PUSH
100208: LD_INT 5
100210: PUSH
100211: EMPTY
100212: LIST
100213: LIST
100214: LIST
100215: PUSH
100216: EMPTY
100217: LIST
100218: LIST
100219: LIST
100220: LIST
100221: LIST
100222: ST_TO_ADDR
// end ; 2 :
100223: GO 100782
100225: LD_INT 2
100227: DOUBLE
100228: EQUAL
100229: IFTRUE 100233
100231: GO 100362
100233: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
100234: LD_ADDR_VAR 0 5
100238: PUSH
100239: LD_VAR 0 1
100243: PUSH
100244: LD_VAR 0 2
100248: PUSH
100249: LD_INT 3
100251: MINUS
100252: PUSH
100253: LD_INT 3
100255: PUSH
100256: EMPTY
100257: LIST
100258: LIST
100259: LIST
100260: PUSH
100261: LD_VAR 0 1
100265: PUSH
100266: LD_INT 4
100268: PLUS
100269: PUSH
100270: LD_VAR 0 2
100274: PUSH
100275: LD_INT 4
100277: PUSH
100278: EMPTY
100279: LIST
100280: LIST
100281: LIST
100282: PUSH
100283: LD_VAR 0 1
100287: PUSH
100288: LD_VAR 0 2
100292: PUSH
100293: LD_INT 4
100295: PLUS
100296: PUSH
100297: LD_INT 0
100299: PUSH
100300: EMPTY
100301: LIST
100302: LIST
100303: LIST
100304: PUSH
100305: LD_VAR 0 1
100309: PUSH
100310: LD_INT 3
100312: MINUS
100313: PUSH
100314: LD_VAR 0 2
100318: PUSH
100319: LD_INT 1
100321: PUSH
100322: EMPTY
100323: LIST
100324: LIST
100325: LIST
100326: PUSH
100327: LD_VAR 0 1
100331: PUSH
100332: LD_INT 4
100334: MINUS
100335: PUSH
100336: LD_VAR 0 2
100340: PUSH
100341: LD_INT 4
100343: MINUS
100344: PUSH
100345: LD_INT 2
100347: PUSH
100348: EMPTY
100349: LIST
100350: LIST
100351: LIST
100352: PUSH
100353: EMPTY
100354: LIST
100355: LIST
100356: LIST
100357: LIST
100358: LIST
100359: ST_TO_ADDR
// end ; 3 :
100360: GO 100782
100362: LD_INT 3
100364: DOUBLE
100365: EQUAL
100366: IFTRUE 100370
100368: GO 100503
100370: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
100371: LD_ADDR_VAR 0 5
100375: PUSH
100376: LD_VAR 0 1
100380: PUSH
100381: LD_INT 3
100383: PLUS
100384: PUSH
100385: LD_VAR 0 2
100389: PUSH
100390: LD_INT 4
100392: PUSH
100393: EMPTY
100394: LIST
100395: LIST
100396: LIST
100397: PUSH
100398: LD_VAR 0 1
100402: PUSH
100403: LD_INT 4
100405: PLUS
100406: PUSH
100407: LD_VAR 0 2
100411: PUSH
100412: LD_INT 4
100414: PLUS
100415: PUSH
100416: LD_INT 5
100418: PUSH
100419: EMPTY
100420: LIST
100421: LIST
100422: LIST
100423: PUSH
100424: LD_VAR 0 1
100428: PUSH
100429: LD_INT 4
100431: MINUS
100432: PUSH
100433: LD_VAR 0 2
100437: PUSH
100438: LD_INT 1
100440: PUSH
100441: EMPTY
100442: LIST
100443: LIST
100444: LIST
100445: PUSH
100446: LD_VAR 0 1
100450: PUSH
100451: LD_VAR 0 2
100455: PUSH
100456: LD_INT 4
100458: MINUS
100459: PUSH
100460: LD_INT 3
100462: PUSH
100463: EMPTY
100464: LIST
100465: LIST
100466: LIST
100467: PUSH
100468: LD_VAR 0 1
100472: PUSH
100473: LD_INT 3
100475: MINUS
100476: PUSH
100477: LD_VAR 0 2
100481: PUSH
100482: LD_INT 3
100484: MINUS
100485: PUSH
100486: LD_INT 2
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: LIST
100493: PUSH
100494: EMPTY
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: ST_TO_ADDR
// end ; 4 :
100501: GO 100782
100503: LD_INT 4
100505: DOUBLE
100506: EQUAL
100507: IFTRUE 100511
100509: GO 100644
100511: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100512: LD_ADDR_VAR 0 5
100516: PUSH
100517: LD_VAR 0 1
100521: PUSH
100522: LD_VAR 0 2
100526: PUSH
100527: LD_INT 4
100529: PLUS
100530: PUSH
100531: LD_INT 0
100533: PUSH
100534: EMPTY
100535: LIST
100536: LIST
100537: LIST
100538: PUSH
100539: LD_VAR 0 1
100543: PUSH
100544: LD_INT 3
100546: PLUS
100547: PUSH
100548: LD_VAR 0 2
100552: PUSH
100553: LD_INT 3
100555: PLUS
100556: PUSH
100557: LD_INT 5
100559: PUSH
100560: EMPTY
100561: LIST
100562: LIST
100563: LIST
100564: PUSH
100565: LD_VAR 0 1
100569: PUSH
100570: LD_INT 4
100572: PLUS
100573: PUSH
100574: LD_VAR 0 2
100578: PUSH
100579: LD_INT 4
100581: PUSH
100582: EMPTY
100583: LIST
100584: LIST
100585: LIST
100586: PUSH
100587: LD_VAR 0 1
100591: PUSH
100592: LD_VAR 0 2
100596: PUSH
100597: LD_INT 3
100599: MINUS
100600: PUSH
100601: LD_INT 3
100603: PUSH
100604: EMPTY
100605: LIST
100606: LIST
100607: LIST
100608: PUSH
100609: LD_VAR 0 1
100613: PUSH
100614: LD_INT 4
100616: MINUS
100617: PUSH
100618: LD_VAR 0 2
100622: PUSH
100623: LD_INT 4
100625: MINUS
100626: PUSH
100627: LD_INT 2
100629: PUSH
100630: EMPTY
100631: LIST
100632: LIST
100633: LIST
100634: PUSH
100635: EMPTY
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: ST_TO_ADDR
// end ; 5 :
100642: GO 100782
100644: LD_INT 5
100646: DOUBLE
100647: EQUAL
100648: IFTRUE 100652
100650: GO 100781
100652: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100653: LD_ADDR_VAR 0 5
100657: PUSH
100658: LD_VAR 0 1
100662: PUSH
100663: LD_INT 4
100665: MINUS
100666: PUSH
100667: LD_VAR 0 2
100671: PUSH
100672: LD_INT 1
100674: PUSH
100675: EMPTY
100676: LIST
100677: LIST
100678: LIST
100679: PUSH
100680: LD_VAR 0 1
100684: PUSH
100685: LD_VAR 0 2
100689: PUSH
100690: LD_INT 4
100692: MINUS
100693: PUSH
100694: LD_INT 3
100696: PUSH
100697: EMPTY
100698: LIST
100699: LIST
100700: LIST
100701: PUSH
100702: LD_VAR 0 1
100706: PUSH
100707: LD_INT 4
100709: PLUS
100710: PUSH
100711: LD_VAR 0 2
100715: PUSH
100716: LD_INT 4
100718: PLUS
100719: PUSH
100720: LD_INT 5
100722: PUSH
100723: EMPTY
100724: LIST
100725: LIST
100726: LIST
100727: PUSH
100728: LD_VAR 0 1
100732: PUSH
100733: LD_INT 3
100735: PLUS
100736: PUSH
100737: LD_VAR 0 2
100741: PUSH
100742: LD_INT 4
100744: PUSH
100745: EMPTY
100746: LIST
100747: LIST
100748: LIST
100749: PUSH
100750: LD_VAR 0 1
100754: PUSH
100755: LD_VAR 0 2
100759: PUSH
100760: LD_INT 3
100762: PLUS
100763: PUSH
100764: LD_INT 0
100766: PUSH
100767: EMPTY
100768: LIST
100769: LIST
100770: LIST
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: LIST
100776: LIST
100777: LIST
100778: ST_TO_ADDR
// end ; end ;
100779: GO 100782
100781: POP
// result := list ;
100782: LD_ADDR_VAR 0 4
100786: PUSH
100787: LD_VAR 0 5
100791: ST_TO_ADDR
// end ;
100792: LD_VAR 0 4
100796: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
100797: LD_INT 0
100799: PPUSH
100800: PPUSH
100801: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
100802: LD_VAR 0 1
100806: NOT
100807: PUSH
100808: LD_VAR 0 2
100812: PUSH
100813: LD_INT 1
100815: PUSH
100816: LD_INT 2
100818: PUSH
100819: LD_INT 3
100821: PUSH
100822: LD_INT 4
100824: PUSH
100825: EMPTY
100826: LIST
100827: LIST
100828: LIST
100829: LIST
100830: IN
100831: NOT
100832: OR
100833: IFFALSE 100837
// exit ;
100835: GO 100929
// tmp := [ ] ;
100837: LD_ADDR_VAR 0 5
100841: PUSH
100842: EMPTY
100843: ST_TO_ADDR
// for i in units do
100844: LD_ADDR_VAR 0 4
100848: PUSH
100849: LD_VAR 0 1
100853: PUSH
100854: FOR_IN
100855: IFFALSE 100898
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
100857: LD_ADDR_VAR 0 5
100861: PUSH
100862: LD_VAR 0 5
100866: PPUSH
100867: LD_VAR 0 5
100871: PUSH
100872: LD_INT 1
100874: PLUS
100875: PPUSH
100876: LD_VAR 0 4
100880: PPUSH
100881: LD_VAR 0 2
100885: PPUSH
100886: CALL_OW 259
100890: PPUSH
100891: CALL_OW 2
100895: ST_TO_ADDR
100896: GO 100854
100898: POP
100899: POP
// if not tmp then
100900: LD_VAR 0 5
100904: NOT
100905: IFFALSE 100909
// exit ;
100907: GO 100929
// result := SortListByListDesc ( units , tmp ) ;
100909: LD_ADDR_VAR 0 3
100913: PUSH
100914: LD_VAR 0 1
100918: PPUSH
100919: LD_VAR 0 5
100923: PPUSH
100924: CALL_OW 77
100928: ST_TO_ADDR
// end ;
100929: LD_VAR 0 3
100933: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
100934: LD_INT 0
100936: PPUSH
100937: PPUSH
100938: PPUSH
// result := false ;
100939: LD_ADDR_VAR 0 3
100943: PUSH
100944: LD_INT 0
100946: ST_TO_ADDR
// x := GetX ( building ) ;
100947: LD_ADDR_VAR 0 4
100951: PUSH
100952: LD_VAR 0 2
100956: PPUSH
100957: CALL_OW 250
100961: ST_TO_ADDR
// y := GetY ( building ) ;
100962: LD_ADDR_VAR 0 5
100966: PUSH
100967: LD_VAR 0 2
100971: PPUSH
100972: CALL_OW 251
100976: ST_TO_ADDR
// if not building or not x or not y then
100977: LD_VAR 0 2
100981: NOT
100982: PUSH
100983: LD_VAR 0 4
100987: NOT
100988: OR
100989: PUSH
100990: LD_VAR 0 5
100994: NOT
100995: OR
100996: IFFALSE 101000
// exit ;
100998: GO 101092
// if GetTaskList ( unit ) then
101000: LD_VAR 0 1
101004: PPUSH
101005: CALL_OW 437
101009: IFFALSE 101092
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101011: LD_STRING e
101013: PUSH
101014: LD_VAR 0 1
101018: PPUSH
101019: CALL_OW 437
101023: PUSH
101024: LD_INT 1
101026: ARRAY
101027: PUSH
101028: LD_INT 1
101030: ARRAY
101031: EQUAL
101032: PUSH
101033: LD_VAR 0 4
101037: PUSH
101038: LD_VAR 0 1
101042: PPUSH
101043: CALL_OW 437
101047: PUSH
101048: LD_INT 1
101050: ARRAY
101051: PUSH
101052: LD_INT 2
101054: ARRAY
101055: EQUAL
101056: AND
101057: PUSH
101058: LD_VAR 0 5
101062: PUSH
101063: LD_VAR 0 1
101067: PPUSH
101068: CALL_OW 437
101072: PUSH
101073: LD_INT 1
101075: ARRAY
101076: PUSH
101077: LD_INT 3
101079: ARRAY
101080: EQUAL
101081: AND
101082: IFFALSE 101092
// result := true end ;
101084: LD_ADDR_VAR 0 3
101088: PUSH
101089: LD_INT 1
101091: ST_TO_ADDR
// end ;
101092: LD_VAR 0 3
101096: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101097: LD_INT 0
101099: PPUSH
// result := false ;
101100: LD_ADDR_VAR 0 4
101104: PUSH
101105: LD_INT 0
101107: ST_TO_ADDR
// if GetTaskList ( unit ) then
101108: LD_VAR 0 1
101112: PPUSH
101113: CALL_OW 437
101117: IFFALSE 101200
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101119: LD_STRING M
101121: PUSH
101122: LD_VAR 0 1
101126: PPUSH
101127: CALL_OW 437
101131: PUSH
101132: LD_INT 1
101134: ARRAY
101135: PUSH
101136: LD_INT 1
101138: ARRAY
101139: EQUAL
101140: PUSH
101141: LD_VAR 0 2
101145: PUSH
101146: LD_VAR 0 1
101150: PPUSH
101151: CALL_OW 437
101155: PUSH
101156: LD_INT 1
101158: ARRAY
101159: PUSH
101160: LD_INT 2
101162: ARRAY
101163: EQUAL
101164: AND
101165: PUSH
101166: LD_VAR 0 3
101170: PUSH
101171: LD_VAR 0 1
101175: PPUSH
101176: CALL_OW 437
101180: PUSH
101181: LD_INT 1
101183: ARRAY
101184: PUSH
101185: LD_INT 3
101187: ARRAY
101188: EQUAL
101189: AND
101190: IFFALSE 101200
// result := true ;
101192: LD_ADDR_VAR 0 4
101196: PUSH
101197: LD_INT 1
101199: ST_TO_ADDR
// end ; end ;
101200: LD_VAR 0 4
101204: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
101205: LD_INT 0
101207: PPUSH
101208: PPUSH
101209: PPUSH
101210: PPUSH
// if not unit or not area then
101211: LD_VAR 0 1
101215: NOT
101216: PUSH
101217: LD_VAR 0 2
101221: NOT
101222: OR
101223: IFFALSE 101227
// exit ;
101225: GO 101391
// tmp := AreaToList ( area , i ) ;
101227: LD_ADDR_VAR 0 6
101231: PUSH
101232: LD_VAR 0 2
101236: PPUSH
101237: LD_VAR 0 5
101241: PPUSH
101242: CALL_OW 517
101246: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
101247: LD_ADDR_VAR 0 5
101251: PUSH
101252: DOUBLE
101253: LD_INT 1
101255: DEC
101256: ST_TO_ADDR
101257: LD_VAR 0 6
101261: PUSH
101262: LD_INT 1
101264: ARRAY
101265: PUSH
101266: FOR_TO
101267: IFFALSE 101389
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
101269: LD_ADDR_VAR 0 7
101273: PUSH
101274: LD_VAR 0 6
101278: PUSH
101279: LD_INT 1
101281: ARRAY
101282: PUSH
101283: LD_VAR 0 5
101287: ARRAY
101288: PUSH
101289: LD_VAR 0 6
101293: PUSH
101294: LD_INT 2
101296: ARRAY
101297: PUSH
101298: LD_VAR 0 5
101302: ARRAY
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
101308: LD_VAR 0 7
101312: PUSH
101313: LD_INT 1
101315: ARRAY
101316: PPUSH
101317: LD_VAR 0 7
101321: PUSH
101322: LD_INT 2
101324: ARRAY
101325: PPUSH
101326: CALL_OW 428
101330: PUSH
101331: LD_INT 0
101333: EQUAL
101334: IFFALSE 101387
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
101336: LD_VAR 0 1
101340: PPUSH
101341: LD_VAR 0 7
101345: PUSH
101346: LD_INT 1
101348: ARRAY
101349: PPUSH
101350: LD_VAR 0 7
101354: PUSH
101355: LD_INT 2
101357: ARRAY
101358: PPUSH
101359: LD_VAR 0 3
101363: PPUSH
101364: CALL_OW 48
// result := IsPlaced ( unit ) ;
101368: LD_ADDR_VAR 0 4
101372: PUSH
101373: LD_VAR 0 1
101377: PPUSH
101378: CALL_OW 305
101382: ST_TO_ADDR
// exit ;
101383: POP
101384: POP
101385: GO 101391
// end ; end ;
101387: GO 101266
101389: POP
101390: POP
// end ;
101391: LD_VAR 0 4
101395: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
101396: LD_INT 0
101398: PPUSH
101399: PPUSH
101400: PPUSH
// if not side or side > 8 then
101401: LD_VAR 0 1
101405: NOT
101406: PUSH
101407: LD_VAR 0 1
101411: PUSH
101412: LD_INT 8
101414: GREATER
101415: OR
101416: IFFALSE 101420
// exit ;
101418: GO 101607
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
101420: LD_ADDR_VAR 0 4
101424: PUSH
101425: LD_INT 22
101427: PUSH
101428: LD_VAR 0 1
101432: PUSH
101433: EMPTY
101434: LIST
101435: LIST
101436: PUSH
101437: LD_INT 21
101439: PUSH
101440: LD_INT 3
101442: PUSH
101443: EMPTY
101444: LIST
101445: LIST
101446: PUSH
101447: EMPTY
101448: LIST
101449: LIST
101450: PPUSH
101451: CALL_OW 69
101455: ST_TO_ADDR
// if not tmp then
101456: LD_VAR 0 4
101460: NOT
101461: IFFALSE 101465
// exit ;
101463: GO 101607
// enable_addtolog := true ;
101465: LD_ADDR_OWVAR 81
101469: PUSH
101470: LD_INT 1
101472: ST_TO_ADDR
// AddToLog ( [ ) ;
101473: LD_STRING [
101475: PPUSH
101476: CALL_OW 561
// for i in tmp do
101480: LD_ADDR_VAR 0 3
101484: PUSH
101485: LD_VAR 0 4
101489: PUSH
101490: FOR_IN
101491: IFFALSE 101598
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
101493: LD_STRING [
101495: PUSH
101496: LD_VAR 0 3
101500: PPUSH
101501: CALL_OW 266
101505: STR
101506: PUSH
101507: LD_STRING , 
101509: STR
101510: PUSH
101511: LD_VAR 0 3
101515: PPUSH
101516: CALL_OW 250
101520: STR
101521: PUSH
101522: LD_STRING , 
101524: STR
101525: PUSH
101526: LD_VAR 0 3
101530: PPUSH
101531: CALL_OW 251
101535: STR
101536: PUSH
101537: LD_STRING , 
101539: STR
101540: PUSH
101541: LD_VAR 0 3
101545: PPUSH
101546: CALL_OW 254
101550: STR
101551: PUSH
101552: LD_STRING , 
101554: STR
101555: PUSH
101556: LD_VAR 0 3
101560: PPUSH
101561: LD_INT 1
101563: PPUSH
101564: CALL_OW 268
101568: STR
101569: PUSH
101570: LD_STRING , 
101572: STR
101573: PUSH
101574: LD_VAR 0 3
101578: PPUSH
101579: LD_INT 2
101581: PPUSH
101582: CALL_OW 268
101586: STR
101587: PUSH
101588: LD_STRING ],
101590: STR
101591: PPUSH
101592: CALL_OW 561
// end ;
101596: GO 101490
101598: POP
101599: POP
// AddToLog ( ]; ) ;
101600: LD_STRING ];
101602: PPUSH
101603: CALL_OW 561
// end ;
101607: LD_VAR 0 2
101611: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101612: LD_INT 0
101614: PPUSH
101615: PPUSH
101616: PPUSH
101617: PPUSH
101618: PPUSH
// if not area or not rate or not max then
101619: LD_VAR 0 1
101623: NOT
101624: PUSH
101625: LD_VAR 0 2
101629: NOT
101630: OR
101631: PUSH
101632: LD_VAR 0 4
101636: NOT
101637: OR
101638: IFFALSE 101642
// exit ;
101640: GO 101834
// while 1 do
101642: LD_INT 1
101644: IFFALSE 101834
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101646: LD_ADDR_VAR 0 9
101650: PUSH
101651: LD_VAR 0 1
101655: PPUSH
101656: LD_INT 1
101658: PPUSH
101659: CALL_OW 287
101663: PUSH
101664: LD_INT 10
101666: MUL
101667: ST_TO_ADDR
// r := rate / 10 ;
101668: LD_ADDR_VAR 0 7
101672: PUSH
101673: LD_VAR 0 2
101677: PUSH
101678: LD_INT 10
101680: DIVREAL
101681: ST_TO_ADDR
// time := 1 1$00 ;
101682: LD_ADDR_VAR 0 8
101686: PUSH
101687: LD_INT 2100
101689: ST_TO_ADDR
// if amount < min then
101690: LD_VAR 0 9
101694: PUSH
101695: LD_VAR 0 3
101699: LESS
101700: IFFALSE 101718
// r := r * 2 else
101702: LD_ADDR_VAR 0 7
101706: PUSH
101707: LD_VAR 0 7
101711: PUSH
101712: LD_INT 2
101714: MUL
101715: ST_TO_ADDR
101716: GO 101744
// if amount > max then
101718: LD_VAR 0 9
101722: PUSH
101723: LD_VAR 0 4
101727: GREATER
101728: IFFALSE 101744
// r := r / 2 ;
101730: LD_ADDR_VAR 0 7
101734: PUSH
101735: LD_VAR 0 7
101739: PUSH
101740: LD_INT 2
101742: DIVREAL
101743: ST_TO_ADDR
// time := time / r ;
101744: LD_ADDR_VAR 0 8
101748: PUSH
101749: LD_VAR 0 8
101753: PUSH
101754: LD_VAR 0 7
101758: DIVREAL
101759: ST_TO_ADDR
// if time < 0 then
101760: LD_VAR 0 8
101764: PUSH
101765: LD_INT 0
101767: LESS
101768: IFFALSE 101785
// time := time * - 1 ;
101770: LD_ADDR_VAR 0 8
101774: PUSH
101775: LD_VAR 0 8
101779: PUSH
101780: LD_INT 1
101782: NEG
101783: MUL
101784: ST_TO_ADDR
// wait ( time ) ;
101785: LD_VAR 0 8
101789: PPUSH
101790: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
101794: LD_INT 35
101796: PPUSH
101797: LD_INT 875
101799: PPUSH
101800: CALL_OW 12
101804: PPUSH
101805: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
101809: LD_INT 1
101811: PPUSH
101812: LD_INT 5
101814: PPUSH
101815: CALL_OW 12
101819: PPUSH
101820: LD_VAR 0 1
101824: PPUSH
101825: LD_INT 1
101827: PPUSH
101828: CALL_OW 55
// end ;
101832: GO 101642
// end ;
101834: LD_VAR 0 5
101838: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
101839: LD_INT 0
101841: PPUSH
101842: PPUSH
101843: PPUSH
101844: PPUSH
101845: PPUSH
101846: PPUSH
101847: PPUSH
101848: PPUSH
// if not turrets or not factories then
101849: LD_VAR 0 1
101853: NOT
101854: PUSH
101855: LD_VAR 0 2
101859: NOT
101860: OR
101861: IFFALSE 101865
// exit ;
101863: GO 102172
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
101865: LD_ADDR_VAR 0 10
101869: PUSH
101870: LD_INT 5
101872: PUSH
101873: LD_INT 6
101875: PUSH
101876: EMPTY
101877: LIST
101878: LIST
101879: PUSH
101880: LD_INT 2
101882: PUSH
101883: LD_INT 4
101885: PUSH
101886: EMPTY
101887: LIST
101888: LIST
101889: PUSH
101890: LD_INT 3
101892: PUSH
101893: LD_INT 5
101895: PUSH
101896: EMPTY
101897: LIST
101898: LIST
101899: PUSH
101900: EMPTY
101901: LIST
101902: LIST
101903: LIST
101904: PUSH
101905: LD_INT 24
101907: PUSH
101908: LD_INT 25
101910: PUSH
101911: EMPTY
101912: LIST
101913: LIST
101914: PUSH
101915: LD_INT 23
101917: PUSH
101918: LD_INT 27
101920: PUSH
101921: EMPTY
101922: LIST
101923: LIST
101924: PUSH
101925: EMPTY
101926: LIST
101927: LIST
101928: PUSH
101929: LD_INT 42
101931: PUSH
101932: LD_INT 43
101934: PUSH
101935: EMPTY
101936: LIST
101937: LIST
101938: PUSH
101939: LD_INT 44
101941: PUSH
101942: LD_INT 46
101944: PUSH
101945: EMPTY
101946: LIST
101947: LIST
101948: PUSH
101949: LD_INT 45
101951: PUSH
101952: LD_INT 47
101954: PUSH
101955: EMPTY
101956: LIST
101957: LIST
101958: PUSH
101959: EMPTY
101960: LIST
101961: LIST
101962: LIST
101963: PUSH
101964: EMPTY
101965: LIST
101966: LIST
101967: LIST
101968: ST_TO_ADDR
// result := [ ] ;
101969: LD_ADDR_VAR 0 3
101973: PUSH
101974: EMPTY
101975: ST_TO_ADDR
// for i in turrets do
101976: LD_ADDR_VAR 0 4
101980: PUSH
101981: LD_VAR 0 1
101985: PUSH
101986: FOR_IN
101987: IFFALSE 102170
// begin nat := GetNation ( i ) ;
101989: LD_ADDR_VAR 0 7
101993: PUSH
101994: LD_VAR 0 4
101998: PPUSH
101999: CALL_OW 248
102003: ST_TO_ADDR
// weapon := 0 ;
102004: LD_ADDR_VAR 0 8
102008: PUSH
102009: LD_INT 0
102011: ST_TO_ADDR
// if not nat then
102012: LD_VAR 0 7
102016: NOT
102017: IFFALSE 102021
// continue ;
102019: GO 101986
// for j in list [ nat ] do
102021: LD_ADDR_VAR 0 5
102025: PUSH
102026: LD_VAR 0 10
102030: PUSH
102031: LD_VAR 0 7
102035: ARRAY
102036: PUSH
102037: FOR_IN
102038: IFFALSE 102079
// if GetBWeapon ( i ) = j [ 1 ] then
102040: LD_VAR 0 4
102044: PPUSH
102045: CALL_OW 269
102049: PUSH
102050: LD_VAR 0 5
102054: PUSH
102055: LD_INT 1
102057: ARRAY
102058: EQUAL
102059: IFFALSE 102077
// begin weapon := j [ 2 ] ;
102061: LD_ADDR_VAR 0 8
102065: PUSH
102066: LD_VAR 0 5
102070: PUSH
102071: LD_INT 2
102073: ARRAY
102074: ST_TO_ADDR
// break ;
102075: GO 102079
// end ;
102077: GO 102037
102079: POP
102080: POP
// if not weapon then
102081: LD_VAR 0 8
102085: NOT
102086: IFFALSE 102090
// continue ;
102088: GO 101986
// for k in factories do
102090: LD_ADDR_VAR 0 6
102094: PUSH
102095: LD_VAR 0 2
102099: PUSH
102100: FOR_IN
102101: IFFALSE 102166
// begin weapons := AvailableWeaponList ( k ) ;
102103: LD_ADDR_VAR 0 9
102107: PUSH
102108: LD_VAR 0 6
102112: PPUSH
102113: CALL_OW 478
102117: ST_TO_ADDR
// if not weapons then
102118: LD_VAR 0 9
102122: NOT
102123: IFFALSE 102127
// continue ;
102125: GO 102100
// if weapon in weapons then
102127: LD_VAR 0 8
102131: PUSH
102132: LD_VAR 0 9
102136: IN
102137: IFFALSE 102164
// begin result := [ i , weapon ] ;
102139: LD_ADDR_VAR 0 3
102143: PUSH
102144: LD_VAR 0 4
102148: PUSH
102149: LD_VAR 0 8
102153: PUSH
102154: EMPTY
102155: LIST
102156: LIST
102157: ST_TO_ADDR
// exit ;
102158: POP
102159: POP
102160: POP
102161: POP
102162: GO 102172
// end ; end ;
102164: GO 102100
102166: POP
102167: POP
// end ;
102168: GO 101986
102170: POP
102171: POP
// end ;
102172: LD_VAR 0 3
102176: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102177: LD_INT 0
102179: PPUSH
// if not side or side > 8 then
102180: LD_VAR 0 3
102184: NOT
102185: PUSH
102186: LD_VAR 0 3
102190: PUSH
102191: LD_INT 8
102193: GREATER
102194: OR
102195: IFFALSE 102199
// exit ;
102197: GO 102258
// if not range then
102199: LD_VAR 0 4
102203: NOT
102204: IFFALSE 102215
// range := - 12 ;
102206: LD_ADDR_VAR 0 4
102210: PUSH
102211: LD_INT 12
102213: NEG
102214: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
102215: LD_VAR 0 1
102219: PPUSH
102220: LD_VAR 0 2
102224: PPUSH
102225: LD_VAR 0 3
102229: PPUSH
102230: LD_VAR 0 4
102234: PPUSH
102235: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
102239: LD_VAR 0 1
102243: PPUSH
102244: LD_VAR 0 2
102248: PPUSH
102249: LD_VAR 0 3
102253: PPUSH
102254: CALL_OW 331
// end ;
102258: LD_VAR 0 5
102262: RET
// export function Video ( mode ) ; begin
102263: LD_INT 0
102265: PPUSH
// ingame_video = mode ;
102266: LD_ADDR_OWVAR 52
102270: PUSH
102271: LD_VAR 0 1
102275: ST_TO_ADDR
// interface_hidden = mode ;
102276: LD_ADDR_OWVAR 54
102280: PUSH
102281: LD_VAR 0 1
102285: ST_TO_ADDR
// end ;
102286: LD_VAR 0 2
102290: RET
// export function Join ( array , element ) ; begin
102291: LD_INT 0
102293: PPUSH
// result := Replace ( array , array + 1 , element ) ;
102294: LD_ADDR_VAR 0 3
102298: PUSH
102299: LD_VAR 0 1
102303: PPUSH
102304: LD_VAR 0 1
102308: PUSH
102309: LD_INT 1
102311: PLUS
102312: PPUSH
102313: LD_VAR 0 2
102317: PPUSH
102318: CALL_OW 1
102322: ST_TO_ADDR
// end ;
102323: LD_VAR 0 3
102327: RET
// export function JoinUnion ( array , element ) ; begin
102328: LD_INT 0
102330: PPUSH
// result := array union element ;
102331: LD_ADDR_VAR 0 3
102335: PUSH
102336: LD_VAR 0 1
102340: PUSH
102341: LD_VAR 0 2
102345: UNION
102346: ST_TO_ADDR
// end ;
102347: LD_VAR 0 3
102351: RET
// export function GetBehemoths ( side ) ; begin
102352: LD_INT 0
102354: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
102355: LD_ADDR_VAR 0 2
102359: PUSH
102360: LD_INT 22
102362: PUSH
102363: LD_VAR 0 1
102367: PUSH
102368: EMPTY
102369: LIST
102370: LIST
102371: PUSH
102372: LD_INT 31
102374: PUSH
102375: LD_INT 25
102377: PUSH
102378: EMPTY
102379: LIST
102380: LIST
102381: PUSH
102382: EMPTY
102383: LIST
102384: LIST
102385: PPUSH
102386: CALL_OW 69
102390: ST_TO_ADDR
// end ;
102391: LD_VAR 0 2
102395: RET
// export function Shuffle ( array ) ; var i , index ; begin
102396: LD_INT 0
102398: PPUSH
102399: PPUSH
102400: PPUSH
// result := [ ] ;
102401: LD_ADDR_VAR 0 2
102405: PUSH
102406: EMPTY
102407: ST_TO_ADDR
// if not array then
102408: LD_VAR 0 1
102412: NOT
102413: IFFALSE 102417
// exit ;
102415: GO 102516
// Randomize ;
102417: CALL_OW 10
// for i = array downto 1 do
102421: LD_ADDR_VAR 0 3
102425: PUSH
102426: DOUBLE
102427: LD_VAR 0 1
102431: INC
102432: ST_TO_ADDR
102433: LD_INT 1
102435: PUSH
102436: FOR_DOWNTO
102437: IFFALSE 102514
// begin index := rand ( 1 , array ) ;
102439: LD_ADDR_VAR 0 4
102443: PUSH
102444: LD_INT 1
102446: PPUSH
102447: LD_VAR 0 1
102451: PPUSH
102452: CALL_OW 12
102456: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
102457: LD_ADDR_VAR 0 2
102461: PUSH
102462: LD_VAR 0 2
102466: PPUSH
102467: LD_VAR 0 2
102471: PUSH
102472: LD_INT 1
102474: PLUS
102475: PPUSH
102476: LD_VAR 0 1
102480: PUSH
102481: LD_VAR 0 4
102485: ARRAY
102486: PPUSH
102487: CALL_OW 2
102491: ST_TO_ADDR
// array := Delete ( array , index ) ;
102492: LD_ADDR_VAR 0 1
102496: PUSH
102497: LD_VAR 0 1
102501: PPUSH
102502: LD_VAR 0 4
102506: PPUSH
102507: CALL_OW 3
102511: ST_TO_ADDR
// end ;
102512: GO 102436
102514: POP
102515: POP
// end ;
102516: LD_VAR 0 2
102520: RET
// export function GetBaseMaterials ( base ) ; begin
102521: LD_INT 0
102523: PPUSH
// result := [ 0 , 0 , 0 ] ;
102524: LD_ADDR_VAR 0 2
102528: PUSH
102529: LD_INT 0
102531: PUSH
102532: LD_INT 0
102534: PUSH
102535: LD_INT 0
102537: PUSH
102538: EMPTY
102539: LIST
102540: LIST
102541: LIST
102542: ST_TO_ADDR
// if not base then
102543: LD_VAR 0 1
102547: NOT
102548: IFFALSE 102552
// exit ;
102550: GO 102601
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
102552: LD_ADDR_VAR 0 2
102556: PUSH
102557: LD_VAR 0 1
102561: PPUSH
102562: LD_INT 1
102564: PPUSH
102565: CALL_OW 275
102569: PUSH
102570: LD_VAR 0 1
102574: PPUSH
102575: LD_INT 2
102577: PPUSH
102578: CALL_OW 275
102582: PUSH
102583: LD_VAR 0 1
102587: PPUSH
102588: LD_INT 3
102590: PPUSH
102591: CALL_OW 275
102595: PUSH
102596: EMPTY
102597: LIST
102598: LIST
102599: LIST
102600: ST_TO_ADDR
// end ;
102601: LD_VAR 0 2
102605: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102606: LD_INT 0
102608: PPUSH
102609: PPUSH
// result := array ;
102610: LD_ADDR_VAR 0 3
102614: PUSH
102615: LD_VAR 0 1
102619: ST_TO_ADDR
// if size > 0 then
102620: LD_VAR 0 2
102624: PUSH
102625: LD_INT 0
102627: GREATER
102628: IFFALSE 102674
// for i := array downto size do
102630: LD_ADDR_VAR 0 4
102634: PUSH
102635: DOUBLE
102636: LD_VAR 0 1
102640: INC
102641: ST_TO_ADDR
102642: LD_VAR 0 2
102646: PUSH
102647: FOR_DOWNTO
102648: IFFALSE 102672
// result := Delete ( result , result ) ;
102650: LD_ADDR_VAR 0 3
102654: PUSH
102655: LD_VAR 0 3
102659: PPUSH
102660: LD_VAR 0 3
102664: PPUSH
102665: CALL_OW 3
102669: ST_TO_ADDR
102670: GO 102647
102672: POP
102673: POP
// end ;
102674: LD_VAR 0 3
102678: RET
// export function ComExit ( unit ) ; var tmp ; begin
102679: LD_INT 0
102681: PPUSH
102682: PPUSH
// if not IsInUnit ( unit ) then
102683: LD_VAR 0 1
102687: PPUSH
102688: CALL_OW 310
102692: NOT
102693: IFFALSE 102697
// exit ;
102695: GO 102757
// tmp := IsInUnit ( unit ) ;
102697: LD_ADDR_VAR 0 3
102701: PUSH
102702: LD_VAR 0 1
102706: PPUSH
102707: CALL_OW 310
102711: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
102712: LD_VAR 0 3
102716: PPUSH
102717: CALL_OW 247
102721: PUSH
102722: LD_INT 2
102724: EQUAL
102725: IFFALSE 102738
// ComExitVehicle ( unit ) else
102727: LD_VAR 0 1
102731: PPUSH
102732: CALL_OW 121
102736: GO 102747
// ComExitBuilding ( unit ) ;
102738: LD_VAR 0 1
102742: PPUSH
102743: CALL_OW 122
// result := tmp ;
102747: LD_ADDR_VAR 0 2
102751: PUSH
102752: LD_VAR 0 3
102756: ST_TO_ADDR
// end ;
102757: LD_VAR 0 2
102761: RET
// export function ComExitAll ( units ) ; var i ; begin
102762: LD_INT 0
102764: PPUSH
102765: PPUSH
// if not units then
102766: LD_VAR 0 1
102770: NOT
102771: IFFALSE 102775
// exit ;
102773: GO 102801
// for i in units do
102775: LD_ADDR_VAR 0 3
102779: PUSH
102780: LD_VAR 0 1
102784: PUSH
102785: FOR_IN
102786: IFFALSE 102799
// ComExit ( i ) ;
102788: LD_VAR 0 3
102792: PPUSH
102793: CALL 102679 0 1
102797: GO 102785
102799: POP
102800: POP
// end ;
102801: LD_VAR 0 2
102805: RET
// export function ResetHc ; begin
102806: LD_INT 0
102808: PPUSH
// InitHc ;
102809: CALL_OW 19
// hc_importance := 0 ;
102813: LD_ADDR_OWVAR 32
102817: PUSH
102818: LD_INT 0
102820: ST_TO_ADDR
// end ;
102821: LD_VAR 0 1
102825: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
102826: LD_INT 0
102828: PPUSH
102829: PPUSH
102830: PPUSH
// _x := ( x1 + x2 ) div 2 ;
102831: LD_ADDR_VAR 0 6
102835: PUSH
102836: LD_VAR 0 1
102840: PUSH
102841: LD_VAR 0 3
102845: PLUS
102846: PUSH
102847: LD_INT 2
102849: DIV
102850: ST_TO_ADDR
// if _x < 0 then
102851: LD_VAR 0 6
102855: PUSH
102856: LD_INT 0
102858: LESS
102859: IFFALSE 102876
// _x := _x * - 1 ;
102861: LD_ADDR_VAR 0 6
102865: PUSH
102866: LD_VAR 0 6
102870: PUSH
102871: LD_INT 1
102873: NEG
102874: MUL
102875: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
102876: LD_ADDR_VAR 0 7
102880: PUSH
102881: LD_VAR 0 2
102885: PUSH
102886: LD_VAR 0 4
102890: PLUS
102891: PUSH
102892: LD_INT 2
102894: DIV
102895: ST_TO_ADDR
// if _y < 0 then
102896: LD_VAR 0 7
102900: PUSH
102901: LD_INT 0
102903: LESS
102904: IFFALSE 102921
// _y := _y * - 1 ;
102906: LD_ADDR_VAR 0 7
102910: PUSH
102911: LD_VAR 0 7
102915: PUSH
102916: LD_INT 1
102918: NEG
102919: MUL
102920: ST_TO_ADDR
// result := [ _x , _y ] ;
102921: LD_ADDR_VAR 0 5
102925: PUSH
102926: LD_VAR 0 6
102930: PUSH
102931: LD_VAR 0 7
102935: PUSH
102936: EMPTY
102937: LIST
102938: LIST
102939: ST_TO_ADDR
// end ;
102940: LD_VAR 0 5
102944: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
102945: LD_INT 0
102947: PPUSH
102948: PPUSH
102949: PPUSH
102950: PPUSH
// task := GetTaskList ( unit ) ;
102951: LD_ADDR_VAR 0 7
102955: PUSH
102956: LD_VAR 0 1
102960: PPUSH
102961: CALL_OW 437
102965: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
102966: LD_VAR 0 7
102970: NOT
102971: PUSH
102972: LD_VAR 0 1
102976: PPUSH
102977: LD_VAR 0 2
102981: PPUSH
102982: CALL_OW 308
102986: NOT
102987: AND
102988: IFFALSE 102992
// exit ;
102990: GO 103110
// if IsInArea ( unit , area ) then
102992: LD_VAR 0 1
102996: PPUSH
102997: LD_VAR 0 2
103001: PPUSH
103002: CALL_OW 308
103006: IFFALSE 103024
// begin ComMoveToArea ( unit , goAway ) ;
103008: LD_VAR 0 1
103012: PPUSH
103013: LD_VAR 0 3
103017: PPUSH
103018: CALL_OW 113
// exit ;
103022: GO 103110
// end ; if task [ 1 ] [ 1 ] <> M then
103024: LD_VAR 0 7
103028: PUSH
103029: LD_INT 1
103031: ARRAY
103032: PUSH
103033: LD_INT 1
103035: ARRAY
103036: PUSH
103037: LD_STRING M
103039: NONEQUAL
103040: IFFALSE 103044
// exit ;
103042: GO 103110
// x := task [ 1 ] [ 2 ] ;
103044: LD_ADDR_VAR 0 5
103048: PUSH
103049: LD_VAR 0 7
103053: PUSH
103054: LD_INT 1
103056: ARRAY
103057: PUSH
103058: LD_INT 2
103060: ARRAY
103061: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
103062: LD_ADDR_VAR 0 6
103066: PUSH
103067: LD_VAR 0 7
103071: PUSH
103072: LD_INT 1
103074: ARRAY
103075: PUSH
103076: LD_INT 3
103078: ARRAY
103079: ST_TO_ADDR
// if InArea ( x , y , area ) then
103080: LD_VAR 0 5
103084: PPUSH
103085: LD_VAR 0 6
103089: PPUSH
103090: LD_VAR 0 2
103094: PPUSH
103095: CALL_OW 309
103099: IFFALSE 103110
// ComStop ( unit ) ;
103101: LD_VAR 0 1
103105: PPUSH
103106: CALL_OW 141
// end ;
103110: LD_VAR 0 4
103114: RET
// export function Abs ( value ) ; begin
103115: LD_INT 0
103117: PPUSH
// result := value ;
103118: LD_ADDR_VAR 0 2
103122: PUSH
103123: LD_VAR 0 1
103127: ST_TO_ADDR
// if value < 0 then
103128: LD_VAR 0 1
103132: PUSH
103133: LD_INT 0
103135: LESS
103136: IFFALSE 103153
// result := value * - 1 ;
103138: LD_ADDR_VAR 0 2
103142: PUSH
103143: LD_VAR 0 1
103147: PUSH
103148: LD_INT 1
103150: NEG
103151: MUL
103152: ST_TO_ADDR
// end ;
103153: LD_VAR 0 2
103157: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103158: LD_INT 0
103160: PPUSH
103161: PPUSH
103162: PPUSH
103163: PPUSH
103164: PPUSH
103165: PPUSH
103166: PPUSH
103167: PPUSH
// if not unit or not building then
103168: LD_VAR 0 1
103172: NOT
103173: PUSH
103174: LD_VAR 0 2
103178: NOT
103179: OR
103180: IFFALSE 103184
// exit ;
103182: GO 103410
// x := GetX ( building ) ;
103184: LD_ADDR_VAR 0 4
103188: PUSH
103189: LD_VAR 0 2
103193: PPUSH
103194: CALL_OW 250
103198: ST_TO_ADDR
// y := GetY ( building ) ;
103199: LD_ADDR_VAR 0 6
103203: PUSH
103204: LD_VAR 0 2
103208: PPUSH
103209: CALL_OW 251
103213: ST_TO_ADDR
// d := GetDir ( building ) ;
103214: LD_ADDR_VAR 0 8
103218: PUSH
103219: LD_VAR 0 2
103223: PPUSH
103224: CALL_OW 254
103228: ST_TO_ADDR
// r := 4 ;
103229: LD_ADDR_VAR 0 9
103233: PUSH
103234: LD_INT 4
103236: ST_TO_ADDR
// for i := 1 to 5 do
103237: LD_ADDR_VAR 0 10
103241: PUSH
103242: DOUBLE
103243: LD_INT 1
103245: DEC
103246: ST_TO_ADDR
103247: LD_INT 5
103249: PUSH
103250: FOR_TO
103251: IFFALSE 103408
// begin _x := ShiftX ( x , d , r + i ) ;
103253: LD_ADDR_VAR 0 5
103257: PUSH
103258: LD_VAR 0 4
103262: PPUSH
103263: LD_VAR 0 8
103267: PPUSH
103268: LD_VAR 0 9
103272: PUSH
103273: LD_VAR 0 10
103277: PLUS
103278: PPUSH
103279: CALL_OW 272
103283: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
103284: LD_ADDR_VAR 0 7
103288: PUSH
103289: LD_VAR 0 6
103293: PPUSH
103294: LD_VAR 0 8
103298: PPUSH
103299: LD_VAR 0 9
103303: PUSH
103304: LD_VAR 0 10
103308: PLUS
103309: PPUSH
103310: CALL_OW 273
103314: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
103315: LD_VAR 0 5
103319: PPUSH
103320: LD_VAR 0 7
103324: PPUSH
103325: CALL_OW 488
103329: PUSH
103330: LD_VAR 0 5
103334: PPUSH
103335: LD_VAR 0 7
103339: PPUSH
103340: CALL_OW 428
103344: PPUSH
103345: CALL_OW 247
103349: PUSH
103350: LD_INT 3
103352: PUSH
103353: LD_INT 2
103355: PUSH
103356: EMPTY
103357: LIST
103358: LIST
103359: IN
103360: NOT
103361: AND
103362: IFFALSE 103406
// begin ComMoveXY ( unit , _x , _y ) ;
103364: LD_VAR 0 1
103368: PPUSH
103369: LD_VAR 0 5
103373: PPUSH
103374: LD_VAR 0 7
103378: PPUSH
103379: CALL_OW 111
// result := [ _x , _y ] ;
103383: LD_ADDR_VAR 0 3
103387: PUSH
103388: LD_VAR 0 5
103392: PUSH
103393: LD_VAR 0 7
103397: PUSH
103398: EMPTY
103399: LIST
103400: LIST
103401: ST_TO_ADDR
// exit ;
103402: POP
103403: POP
103404: GO 103410
// end ; end ;
103406: GO 103250
103408: POP
103409: POP
// end ;
103410: LD_VAR 0 3
103414: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
103415: LD_INT 0
103417: PPUSH
103418: PPUSH
103419: PPUSH
// result := 0 ;
103420: LD_ADDR_VAR 0 3
103424: PUSH
103425: LD_INT 0
103427: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
103428: LD_VAR 0 1
103432: PUSH
103433: LD_INT 0
103435: LESS
103436: PUSH
103437: LD_VAR 0 1
103441: PUSH
103442: LD_INT 8
103444: GREATER
103445: OR
103446: PUSH
103447: LD_VAR 0 2
103451: PUSH
103452: LD_INT 0
103454: LESS
103455: OR
103456: PUSH
103457: LD_VAR 0 2
103461: PUSH
103462: LD_INT 8
103464: GREATER
103465: OR
103466: IFFALSE 103470
// exit ;
103468: GO 103545
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
103470: LD_ADDR_VAR 0 4
103474: PUSH
103475: LD_INT 22
103477: PUSH
103478: LD_VAR 0 2
103482: PUSH
103483: EMPTY
103484: LIST
103485: LIST
103486: PPUSH
103487: CALL_OW 69
103491: PUSH
103492: FOR_IN
103493: IFFALSE 103543
// begin un := UnitShoot ( i ) ;
103495: LD_ADDR_VAR 0 5
103499: PUSH
103500: LD_VAR 0 4
103504: PPUSH
103505: CALL_OW 504
103509: ST_TO_ADDR
// if GetSide ( un ) = side1 then
103510: LD_VAR 0 5
103514: PPUSH
103515: CALL_OW 255
103519: PUSH
103520: LD_VAR 0 1
103524: EQUAL
103525: IFFALSE 103541
// begin result := un ;
103527: LD_ADDR_VAR 0 3
103531: PUSH
103532: LD_VAR 0 5
103536: ST_TO_ADDR
// exit ;
103537: POP
103538: POP
103539: GO 103545
// end ; end ;
103541: GO 103492
103543: POP
103544: POP
// end ;
103545: LD_VAR 0 3
103549: RET
// export function GetCargoBay ( units ) ; begin
103550: LD_INT 0
103552: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
103553: LD_ADDR_VAR 0 2
103557: PUSH
103558: LD_VAR 0 1
103562: PPUSH
103563: LD_INT 2
103565: PUSH
103566: LD_INT 34
103568: PUSH
103569: LD_INT 12
103571: PUSH
103572: EMPTY
103573: LIST
103574: LIST
103575: PUSH
103576: LD_INT 34
103578: PUSH
103579: LD_INT 51
103581: PUSH
103582: EMPTY
103583: LIST
103584: LIST
103585: PUSH
103586: LD_INT 34
103588: PUSH
103589: LD_INT 32
103591: PUSH
103592: EMPTY
103593: LIST
103594: LIST
103595: PUSH
103596: LD_INT 34
103598: PUSH
103599: LD_EXP 96
103603: PUSH
103604: EMPTY
103605: LIST
103606: LIST
103607: PUSH
103608: EMPTY
103609: LIST
103610: LIST
103611: LIST
103612: LIST
103613: LIST
103614: PPUSH
103615: CALL_OW 72
103619: ST_TO_ADDR
// end ;
103620: LD_VAR 0 2
103624: RET
// export function Negate ( value ) ; begin
103625: LD_INT 0
103627: PPUSH
// result := not value ;
103628: LD_ADDR_VAR 0 2
103632: PUSH
103633: LD_VAR 0 1
103637: NOT
103638: ST_TO_ADDR
// end ;
103639: LD_VAR 0 2
103643: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
103644: LD_INT 0
103646: PPUSH
// if x1 = x2 then
103647: LD_VAR 0 1
103651: PUSH
103652: LD_VAR 0 3
103656: EQUAL
103657: IFFALSE 103691
// begin if y1 > y2 then
103659: LD_VAR 0 2
103663: PUSH
103664: LD_VAR 0 4
103668: GREATER
103669: IFFALSE 103681
// result := 0 else
103671: LD_ADDR_VAR 0 5
103675: PUSH
103676: LD_INT 0
103678: ST_TO_ADDR
103679: GO 103689
// result := 3 ;
103681: LD_ADDR_VAR 0 5
103685: PUSH
103686: LD_INT 3
103688: ST_TO_ADDR
// exit ;
103689: GO 103777
// end ; if y1 = y2 then
103691: LD_VAR 0 2
103695: PUSH
103696: LD_VAR 0 4
103700: EQUAL
103701: IFFALSE 103735
// begin if x1 > x2 then
103703: LD_VAR 0 1
103707: PUSH
103708: LD_VAR 0 3
103712: GREATER
103713: IFFALSE 103725
// result := 1 else
103715: LD_ADDR_VAR 0 5
103719: PUSH
103720: LD_INT 1
103722: ST_TO_ADDR
103723: GO 103733
// result := 4 ;
103725: LD_ADDR_VAR 0 5
103729: PUSH
103730: LD_INT 4
103732: ST_TO_ADDR
// exit ;
103733: GO 103777
// end ; if x1 > x2 and y1 > y2 then
103735: LD_VAR 0 1
103739: PUSH
103740: LD_VAR 0 3
103744: GREATER
103745: PUSH
103746: LD_VAR 0 2
103750: PUSH
103751: LD_VAR 0 4
103755: GREATER
103756: AND
103757: IFFALSE 103769
// result := 2 else
103759: LD_ADDR_VAR 0 5
103763: PUSH
103764: LD_INT 2
103766: ST_TO_ADDR
103767: GO 103777
// result := 5 ;
103769: LD_ADDR_VAR 0 5
103773: PUSH
103774: LD_INT 5
103776: ST_TO_ADDR
// end ;
103777: LD_VAR 0 5
103781: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103782: LD_INT 0
103784: PPUSH
103785: PPUSH
// if not driver or not IsInUnit ( driver ) then
103786: LD_VAR 0 1
103790: NOT
103791: PUSH
103792: LD_VAR 0 1
103796: PPUSH
103797: CALL_OW 310
103801: NOT
103802: OR
103803: IFFALSE 103807
// exit ;
103805: GO 103897
// vehicle := IsInUnit ( driver ) ;
103807: LD_ADDR_VAR 0 3
103811: PUSH
103812: LD_VAR 0 1
103816: PPUSH
103817: CALL_OW 310
103821: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103822: LD_VAR 0 1
103826: PPUSH
103827: LD_STRING \
103829: PUSH
103830: LD_INT 0
103832: PUSH
103833: LD_INT 0
103835: PUSH
103836: LD_INT 0
103838: PUSH
103839: LD_INT 0
103841: PUSH
103842: LD_INT 0
103844: PUSH
103845: LD_INT 0
103847: PUSH
103848: EMPTY
103849: LIST
103850: LIST
103851: LIST
103852: LIST
103853: LIST
103854: LIST
103855: LIST
103856: PUSH
103857: LD_STRING E
103859: PUSH
103860: LD_INT 0
103862: PUSH
103863: LD_INT 0
103865: PUSH
103866: LD_VAR 0 3
103870: PUSH
103871: LD_INT 0
103873: PUSH
103874: LD_INT 0
103876: PUSH
103877: LD_INT 0
103879: PUSH
103880: EMPTY
103881: LIST
103882: LIST
103883: LIST
103884: LIST
103885: LIST
103886: LIST
103887: LIST
103888: PUSH
103889: EMPTY
103890: LIST
103891: LIST
103892: PPUSH
103893: CALL_OW 446
// end ;
103897: LD_VAR 0 2
103901: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103902: LD_INT 0
103904: PPUSH
103905: PPUSH
// if not driver or not IsInUnit ( driver ) then
103906: LD_VAR 0 1
103910: NOT
103911: PUSH
103912: LD_VAR 0 1
103916: PPUSH
103917: CALL_OW 310
103921: NOT
103922: OR
103923: IFFALSE 103927
// exit ;
103925: GO 104017
// vehicle := IsInUnit ( driver ) ;
103927: LD_ADDR_VAR 0 3
103931: PUSH
103932: LD_VAR 0 1
103936: PPUSH
103937: CALL_OW 310
103941: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103942: LD_VAR 0 1
103946: PPUSH
103947: LD_STRING \
103949: PUSH
103950: LD_INT 0
103952: PUSH
103953: LD_INT 0
103955: PUSH
103956: LD_INT 0
103958: PUSH
103959: LD_INT 0
103961: PUSH
103962: LD_INT 0
103964: PUSH
103965: LD_INT 0
103967: PUSH
103968: EMPTY
103969: LIST
103970: LIST
103971: LIST
103972: LIST
103973: LIST
103974: LIST
103975: LIST
103976: PUSH
103977: LD_STRING E
103979: PUSH
103980: LD_INT 0
103982: PUSH
103983: LD_INT 0
103985: PUSH
103986: LD_VAR 0 3
103990: PUSH
103991: LD_INT 0
103993: PUSH
103994: LD_INT 0
103996: PUSH
103997: LD_INT 0
103999: PUSH
104000: EMPTY
104001: LIST
104002: LIST
104003: LIST
104004: LIST
104005: LIST
104006: LIST
104007: LIST
104008: PUSH
104009: EMPTY
104010: LIST
104011: LIST
104012: PPUSH
104013: CALL_OW 447
// end ;
104017: LD_VAR 0 2
104021: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
104022: LD_INT 0
104024: PPUSH
104025: PPUSH
104026: PPUSH
// tmp := [ ] ;
104027: LD_ADDR_VAR 0 5
104031: PUSH
104032: EMPTY
104033: ST_TO_ADDR
// for i in units do
104034: LD_ADDR_VAR 0 4
104038: PUSH
104039: LD_VAR 0 1
104043: PUSH
104044: FOR_IN
104045: IFFALSE 104083
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
104047: LD_ADDR_VAR 0 5
104051: PUSH
104052: LD_VAR 0 5
104056: PPUSH
104057: LD_VAR 0 5
104061: PUSH
104062: LD_INT 1
104064: PLUS
104065: PPUSH
104066: LD_VAR 0 4
104070: PPUSH
104071: CALL_OW 256
104075: PPUSH
104076: CALL_OW 2
104080: ST_TO_ADDR
104081: GO 104044
104083: POP
104084: POP
// if not tmp then
104085: LD_VAR 0 5
104089: NOT
104090: IFFALSE 104094
// exit ;
104092: GO 104142
// if asc then
104094: LD_VAR 0 2
104098: IFFALSE 104122
// result := SortListByListAsc ( units , tmp ) else
104100: LD_ADDR_VAR 0 3
104104: PUSH
104105: LD_VAR 0 1
104109: PPUSH
104110: LD_VAR 0 5
104114: PPUSH
104115: CALL_OW 76
104119: ST_TO_ADDR
104120: GO 104142
// result := SortListByListDesc ( units , tmp ) ;
104122: LD_ADDR_VAR 0 3
104126: PUSH
104127: LD_VAR 0 1
104131: PPUSH
104132: LD_VAR 0 5
104136: PPUSH
104137: CALL_OW 77
104141: ST_TO_ADDR
// end ;
104142: LD_VAR 0 3
104146: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
104147: LD_INT 0
104149: PPUSH
104150: PPUSH
// task := GetTaskList ( mech ) ;
104151: LD_ADDR_VAR 0 4
104155: PUSH
104156: LD_VAR 0 1
104160: PPUSH
104161: CALL_OW 437
104165: ST_TO_ADDR
// if not task then
104166: LD_VAR 0 4
104170: NOT
104171: IFFALSE 104175
// exit ;
104173: GO 104217
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
104175: LD_ADDR_VAR 0 3
104179: PUSH
104180: LD_VAR 0 4
104184: PUSH
104185: LD_INT 1
104187: ARRAY
104188: PUSH
104189: LD_INT 1
104191: ARRAY
104192: PUSH
104193: LD_STRING r
104195: EQUAL
104196: PUSH
104197: LD_VAR 0 4
104201: PUSH
104202: LD_INT 1
104204: ARRAY
104205: PUSH
104206: LD_INT 4
104208: ARRAY
104209: PUSH
104210: LD_VAR 0 2
104214: EQUAL
104215: AND
104216: ST_TO_ADDR
// end ;
104217: LD_VAR 0 3
104221: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
104222: LD_INT 0
104224: PPUSH
// SetDir ( unit , d ) ;
104225: LD_VAR 0 1
104229: PPUSH
104230: LD_VAR 0 4
104234: PPUSH
104235: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
104239: LD_VAR 0 1
104243: PPUSH
104244: LD_VAR 0 2
104248: PPUSH
104249: LD_VAR 0 3
104253: PPUSH
104254: LD_VAR 0 5
104258: PPUSH
104259: CALL_OW 48
// end ;
104263: LD_VAR 0 6
104267: RET
// export function ToNaturalNumber ( number ) ; begin
104268: LD_INT 0
104270: PPUSH
// result := number div 1 ;
104271: LD_ADDR_VAR 0 2
104275: PUSH
104276: LD_VAR 0 1
104280: PUSH
104281: LD_INT 1
104283: DIV
104284: ST_TO_ADDR
// if number < 0 then
104285: LD_VAR 0 1
104289: PUSH
104290: LD_INT 0
104292: LESS
104293: IFFALSE 104303
// result := 0 ;
104295: LD_ADDR_VAR 0 2
104299: PUSH
104300: LD_INT 0
104302: ST_TO_ADDR
// end ; end_of_file end_of_file
104303: LD_VAR 0 2
104307: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104308: LD_INT 0
104310: PPUSH
// if p2 = 100 then
104311: LD_VAR 0 2
104315: PUSH
104316: LD_INT 100
104318: EQUAL
104319: IFFALSE 105268
// begin if not StreamModeActive then
104321: LD_EXP 160
104325: NOT
104326: IFFALSE 104336
// StreamModeActive := true ;
104328: LD_ADDR_EXP 160
104332: PUSH
104333: LD_INT 1
104335: ST_TO_ADDR
// if p3 = 0 then
104336: LD_VAR 0 3
104340: PUSH
104341: LD_INT 0
104343: EQUAL
104344: IFFALSE 104350
// InitStreamMode ;
104346: CALL 105428 0 0
// if p3 = 1 then
104350: LD_VAR 0 3
104354: PUSH
104355: LD_INT 1
104357: EQUAL
104358: IFFALSE 104368
// sRocket := true ;
104360: LD_ADDR_EXP 165
104364: PUSH
104365: LD_INT 1
104367: ST_TO_ADDR
// if p3 = 2 then
104368: LD_VAR 0 3
104372: PUSH
104373: LD_INT 2
104375: EQUAL
104376: IFFALSE 104386
// sSpeed := true ;
104378: LD_ADDR_EXP 164
104382: PUSH
104383: LD_INT 1
104385: ST_TO_ADDR
// if p3 = 3 then
104386: LD_VAR 0 3
104390: PUSH
104391: LD_INT 3
104393: EQUAL
104394: IFFALSE 104404
// sEngine := true ;
104396: LD_ADDR_EXP 166
104400: PUSH
104401: LD_INT 1
104403: ST_TO_ADDR
// if p3 = 4 then
104404: LD_VAR 0 3
104408: PUSH
104409: LD_INT 4
104411: EQUAL
104412: IFFALSE 104422
// sSpec := true ;
104414: LD_ADDR_EXP 163
104418: PUSH
104419: LD_INT 1
104421: ST_TO_ADDR
// if p3 = 5 then
104422: LD_VAR 0 3
104426: PUSH
104427: LD_INT 5
104429: EQUAL
104430: IFFALSE 104440
// sLevel := true ;
104432: LD_ADDR_EXP 167
104436: PUSH
104437: LD_INT 1
104439: ST_TO_ADDR
// if p3 = 6 then
104440: LD_VAR 0 3
104444: PUSH
104445: LD_INT 6
104447: EQUAL
104448: IFFALSE 104458
// sArmoury := true ;
104450: LD_ADDR_EXP 168
104454: PUSH
104455: LD_INT 1
104457: ST_TO_ADDR
// if p3 = 7 then
104458: LD_VAR 0 3
104462: PUSH
104463: LD_INT 7
104465: EQUAL
104466: IFFALSE 104476
// sRadar := true ;
104468: LD_ADDR_EXP 169
104472: PUSH
104473: LD_INT 1
104475: ST_TO_ADDR
// if p3 = 8 then
104476: LD_VAR 0 3
104480: PUSH
104481: LD_INT 8
104483: EQUAL
104484: IFFALSE 104494
// sBunker := true ;
104486: LD_ADDR_EXP 170
104490: PUSH
104491: LD_INT 1
104493: ST_TO_ADDR
// if p3 = 9 then
104494: LD_VAR 0 3
104498: PUSH
104499: LD_INT 9
104501: EQUAL
104502: IFFALSE 104512
// sHack := true ;
104504: LD_ADDR_EXP 171
104508: PUSH
104509: LD_INT 1
104511: ST_TO_ADDR
// if p3 = 10 then
104512: LD_VAR 0 3
104516: PUSH
104517: LD_INT 10
104519: EQUAL
104520: IFFALSE 104530
// sFire := true ;
104522: LD_ADDR_EXP 172
104526: PUSH
104527: LD_INT 1
104529: ST_TO_ADDR
// if p3 = 11 then
104530: LD_VAR 0 3
104534: PUSH
104535: LD_INT 11
104537: EQUAL
104538: IFFALSE 104548
// sRefresh := true ;
104540: LD_ADDR_EXP 173
104544: PUSH
104545: LD_INT 1
104547: ST_TO_ADDR
// if p3 = 12 then
104548: LD_VAR 0 3
104552: PUSH
104553: LD_INT 12
104555: EQUAL
104556: IFFALSE 104566
// sExp := true ;
104558: LD_ADDR_EXP 174
104562: PUSH
104563: LD_INT 1
104565: ST_TO_ADDR
// if p3 = 13 then
104566: LD_VAR 0 3
104570: PUSH
104571: LD_INT 13
104573: EQUAL
104574: IFFALSE 104584
// sDepot := true ;
104576: LD_ADDR_EXP 175
104580: PUSH
104581: LD_INT 1
104583: ST_TO_ADDR
// if p3 = 14 then
104584: LD_VAR 0 3
104588: PUSH
104589: LD_INT 14
104591: EQUAL
104592: IFFALSE 104602
// sFlag := true ;
104594: LD_ADDR_EXP 176
104598: PUSH
104599: LD_INT 1
104601: ST_TO_ADDR
// if p3 = 15 then
104602: LD_VAR 0 3
104606: PUSH
104607: LD_INT 15
104609: EQUAL
104610: IFFALSE 104620
// sKamikadze := true ;
104612: LD_ADDR_EXP 184
104616: PUSH
104617: LD_INT 1
104619: ST_TO_ADDR
// if p3 = 16 then
104620: LD_VAR 0 3
104624: PUSH
104625: LD_INT 16
104627: EQUAL
104628: IFFALSE 104638
// sTroll := true ;
104630: LD_ADDR_EXP 185
104634: PUSH
104635: LD_INT 1
104637: ST_TO_ADDR
// if p3 = 17 then
104638: LD_VAR 0 3
104642: PUSH
104643: LD_INT 17
104645: EQUAL
104646: IFFALSE 104656
// sSlow := true ;
104648: LD_ADDR_EXP 186
104652: PUSH
104653: LD_INT 1
104655: ST_TO_ADDR
// if p3 = 18 then
104656: LD_VAR 0 3
104660: PUSH
104661: LD_INT 18
104663: EQUAL
104664: IFFALSE 104674
// sLack := true ;
104666: LD_ADDR_EXP 187
104670: PUSH
104671: LD_INT 1
104673: ST_TO_ADDR
// if p3 = 19 then
104674: LD_VAR 0 3
104678: PUSH
104679: LD_INT 19
104681: EQUAL
104682: IFFALSE 104692
// sTank := true ;
104684: LD_ADDR_EXP 189
104688: PUSH
104689: LD_INT 1
104691: ST_TO_ADDR
// if p3 = 20 then
104692: LD_VAR 0 3
104696: PUSH
104697: LD_INT 20
104699: EQUAL
104700: IFFALSE 104710
// sRemote := true ;
104702: LD_ADDR_EXP 190
104706: PUSH
104707: LD_INT 1
104709: ST_TO_ADDR
// if p3 = 21 then
104710: LD_VAR 0 3
104714: PUSH
104715: LD_INT 21
104717: EQUAL
104718: IFFALSE 104728
// sPowell := true ;
104720: LD_ADDR_EXP 191
104724: PUSH
104725: LD_INT 1
104727: ST_TO_ADDR
// if p3 = 22 then
104728: LD_VAR 0 3
104732: PUSH
104733: LD_INT 22
104735: EQUAL
104736: IFFALSE 104746
// sTeleport := true ;
104738: LD_ADDR_EXP 194
104742: PUSH
104743: LD_INT 1
104745: ST_TO_ADDR
// if p3 = 23 then
104746: LD_VAR 0 3
104750: PUSH
104751: LD_INT 23
104753: EQUAL
104754: IFFALSE 104764
// sOilTower := true ;
104756: LD_ADDR_EXP 196
104760: PUSH
104761: LD_INT 1
104763: ST_TO_ADDR
// if p3 = 24 then
104764: LD_VAR 0 3
104768: PUSH
104769: LD_INT 24
104771: EQUAL
104772: IFFALSE 104782
// sShovel := true ;
104774: LD_ADDR_EXP 197
104778: PUSH
104779: LD_INT 1
104781: ST_TO_ADDR
// if p3 = 25 then
104782: LD_VAR 0 3
104786: PUSH
104787: LD_INT 25
104789: EQUAL
104790: IFFALSE 104800
// sSheik := true ;
104792: LD_ADDR_EXP 198
104796: PUSH
104797: LD_INT 1
104799: ST_TO_ADDR
// if p3 = 26 then
104800: LD_VAR 0 3
104804: PUSH
104805: LD_INT 26
104807: EQUAL
104808: IFFALSE 104818
// sEarthquake := true ;
104810: LD_ADDR_EXP 200
104814: PUSH
104815: LD_INT 1
104817: ST_TO_ADDR
// if p3 = 27 then
104818: LD_VAR 0 3
104822: PUSH
104823: LD_INT 27
104825: EQUAL
104826: IFFALSE 104836
// sAI := true ;
104828: LD_ADDR_EXP 201
104832: PUSH
104833: LD_INT 1
104835: ST_TO_ADDR
// if p3 = 28 then
104836: LD_VAR 0 3
104840: PUSH
104841: LD_INT 28
104843: EQUAL
104844: IFFALSE 104854
// sCargo := true ;
104846: LD_ADDR_EXP 204
104850: PUSH
104851: LD_INT 1
104853: ST_TO_ADDR
// if p3 = 29 then
104854: LD_VAR 0 3
104858: PUSH
104859: LD_INT 29
104861: EQUAL
104862: IFFALSE 104872
// sDLaser := true ;
104864: LD_ADDR_EXP 205
104868: PUSH
104869: LD_INT 1
104871: ST_TO_ADDR
// if p3 = 30 then
104872: LD_VAR 0 3
104876: PUSH
104877: LD_INT 30
104879: EQUAL
104880: IFFALSE 104890
// sExchange := true ;
104882: LD_ADDR_EXP 206
104886: PUSH
104887: LD_INT 1
104889: ST_TO_ADDR
// if p3 = 31 then
104890: LD_VAR 0 3
104894: PUSH
104895: LD_INT 31
104897: EQUAL
104898: IFFALSE 104908
// sFac := true ;
104900: LD_ADDR_EXP 207
104904: PUSH
104905: LD_INT 1
104907: ST_TO_ADDR
// if p3 = 32 then
104908: LD_VAR 0 3
104912: PUSH
104913: LD_INT 32
104915: EQUAL
104916: IFFALSE 104926
// sPower := true ;
104918: LD_ADDR_EXP 208
104922: PUSH
104923: LD_INT 1
104925: ST_TO_ADDR
// if p3 = 33 then
104926: LD_VAR 0 3
104930: PUSH
104931: LD_INT 33
104933: EQUAL
104934: IFFALSE 104944
// sRandom := true ;
104936: LD_ADDR_EXP 209
104940: PUSH
104941: LD_INT 1
104943: ST_TO_ADDR
// if p3 = 34 then
104944: LD_VAR 0 3
104948: PUSH
104949: LD_INT 34
104951: EQUAL
104952: IFFALSE 104962
// sShield := true ;
104954: LD_ADDR_EXP 210
104958: PUSH
104959: LD_INT 1
104961: ST_TO_ADDR
// if p3 = 35 then
104962: LD_VAR 0 3
104966: PUSH
104967: LD_INT 35
104969: EQUAL
104970: IFFALSE 104980
// sTime := true ;
104972: LD_ADDR_EXP 211
104976: PUSH
104977: LD_INT 1
104979: ST_TO_ADDR
// if p3 = 36 then
104980: LD_VAR 0 3
104984: PUSH
104985: LD_INT 36
104987: EQUAL
104988: IFFALSE 104998
// sTools := true ;
104990: LD_ADDR_EXP 212
104994: PUSH
104995: LD_INT 1
104997: ST_TO_ADDR
// if p3 = 101 then
104998: LD_VAR 0 3
105002: PUSH
105003: LD_INT 101
105005: EQUAL
105006: IFFALSE 105016
// sSold := true ;
105008: LD_ADDR_EXP 177
105012: PUSH
105013: LD_INT 1
105015: ST_TO_ADDR
// if p3 = 102 then
105016: LD_VAR 0 3
105020: PUSH
105021: LD_INT 102
105023: EQUAL
105024: IFFALSE 105034
// sDiff := true ;
105026: LD_ADDR_EXP 178
105030: PUSH
105031: LD_INT 1
105033: ST_TO_ADDR
// if p3 = 103 then
105034: LD_VAR 0 3
105038: PUSH
105039: LD_INT 103
105041: EQUAL
105042: IFFALSE 105052
// sFog := true ;
105044: LD_ADDR_EXP 181
105048: PUSH
105049: LD_INT 1
105051: ST_TO_ADDR
// if p3 = 104 then
105052: LD_VAR 0 3
105056: PUSH
105057: LD_INT 104
105059: EQUAL
105060: IFFALSE 105070
// sReset := true ;
105062: LD_ADDR_EXP 182
105066: PUSH
105067: LD_INT 1
105069: ST_TO_ADDR
// if p3 = 105 then
105070: LD_VAR 0 3
105074: PUSH
105075: LD_INT 105
105077: EQUAL
105078: IFFALSE 105088
// sSun := true ;
105080: LD_ADDR_EXP 183
105084: PUSH
105085: LD_INT 1
105087: ST_TO_ADDR
// if p3 = 106 then
105088: LD_VAR 0 3
105092: PUSH
105093: LD_INT 106
105095: EQUAL
105096: IFFALSE 105106
// sTiger := true ;
105098: LD_ADDR_EXP 179
105102: PUSH
105103: LD_INT 1
105105: ST_TO_ADDR
// if p3 = 107 then
105106: LD_VAR 0 3
105110: PUSH
105111: LD_INT 107
105113: EQUAL
105114: IFFALSE 105124
// sBomb := true ;
105116: LD_ADDR_EXP 180
105120: PUSH
105121: LD_INT 1
105123: ST_TO_ADDR
// if p3 = 108 then
105124: LD_VAR 0 3
105128: PUSH
105129: LD_INT 108
105131: EQUAL
105132: IFFALSE 105142
// sWound := true ;
105134: LD_ADDR_EXP 188
105138: PUSH
105139: LD_INT 1
105141: ST_TO_ADDR
// if p3 = 109 then
105142: LD_VAR 0 3
105146: PUSH
105147: LD_INT 109
105149: EQUAL
105150: IFFALSE 105160
// sBetray := true ;
105152: LD_ADDR_EXP 192
105156: PUSH
105157: LD_INT 1
105159: ST_TO_ADDR
// if p3 = 110 then
105160: LD_VAR 0 3
105164: PUSH
105165: LD_INT 110
105167: EQUAL
105168: IFFALSE 105178
// sContamin := true ;
105170: LD_ADDR_EXP 193
105174: PUSH
105175: LD_INT 1
105177: ST_TO_ADDR
// if p3 = 111 then
105178: LD_VAR 0 3
105182: PUSH
105183: LD_INT 111
105185: EQUAL
105186: IFFALSE 105196
// sOil := true ;
105188: LD_ADDR_EXP 195
105192: PUSH
105193: LD_INT 1
105195: ST_TO_ADDR
// if p3 = 112 then
105196: LD_VAR 0 3
105200: PUSH
105201: LD_INT 112
105203: EQUAL
105204: IFFALSE 105214
// sStu := true ;
105206: LD_ADDR_EXP 199
105210: PUSH
105211: LD_INT 1
105213: ST_TO_ADDR
// if p3 = 113 then
105214: LD_VAR 0 3
105218: PUSH
105219: LD_INT 113
105221: EQUAL
105222: IFFALSE 105232
// sBazooka := true ;
105224: LD_ADDR_EXP 202
105228: PUSH
105229: LD_INT 1
105231: ST_TO_ADDR
// if p3 = 114 then
105232: LD_VAR 0 3
105236: PUSH
105237: LD_INT 114
105239: EQUAL
105240: IFFALSE 105250
// sMortar := true ;
105242: LD_ADDR_EXP 203
105246: PUSH
105247: LD_INT 1
105249: ST_TO_ADDR
// if p3 = 115 then
105250: LD_VAR 0 3
105254: PUSH
105255: LD_INT 115
105257: EQUAL
105258: IFFALSE 105268
// sRanger := true ;
105260: LD_ADDR_EXP 213
105264: PUSH
105265: LD_INT 1
105267: ST_TO_ADDR
// end ; if p2 = 101 then
105268: LD_VAR 0 2
105272: PUSH
105273: LD_INT 101
105275: EQUAL
105276: IFFALSE 105404
// begin case p3 of 1 :
105278: LD_VAR 0 3
105282: PUSH
105283: LD_INT 1
105285: DOUBLE
105286: EQUAL
105287: IFTRUE 105291
105289: GO 105298
105291: POP
// hHackUnlimitedResources ; 2 :
105292: CALL 116441 0 0
105296: GO 105404
105298: LD_INT 2
105300: DOUBLE
105301: EQUAL
105302: IFTRUE 105306
105304: GO 105313
105306: POP
// hHackSetLevel10 ; 3 :
105307: CALL 116574 0 0
105311: GO 105404
105313: LD_INT 3
105315: DOUBLE
105316: EQUAL
105317: IFTRUE 105321
105319: GO 105328
105321: POP
// hHackSetLevel10YourUnits ; 4 :
105322: CALL 116659 0 0
105326: GO 105404
105328: LD_INT 4
105330: DOUBLE
105331: EQUAL
105332: IFTRUE 105336
105334: GO 105343
105336: POP
// hHackInvincible ; 5 :
105337: CALL 117107 0 0
105341: GO 105404
105343: LD_INT 5
105345: DOUBLE
105346: EQUAL
105347: IFTRUE 105351
105349: GO 105358
105351: POP
// hHackInvisible ; 6 :
105352: CALL 117218 0 0
105356: GO 105404
105358: LD_INT 6
105360: DOUBLE
105361: EQUAL
105362: IFTRUE 105366
105364: GO 105373
105366: POP
// hHackChangeYourSide ; 7 :
105367: CALL 117275 0 0
105371: GO 105404
105373: LD_INT 7
105375: DOUBLE
105376: EQUAL
105377: IFTRUE 105381
105379: GO 105388
105381: POP
// hHackChangeUnitSide ; 8 :
105382: CALL 117317 0 0
105386: GO 105404
105388: LD_INT 8
105390: DOUBLE
105391: EQUAL
105392: IFTRUE 105396
105394: GO 105403
105396: POP
// hHackFog ; end ;
105397: CALL 117418 0 0
105401: GO 105404
105403: POP
// end ; end ;
105404: LD_VAR 0 7
105408: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
105409: GO 105411
105411: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
105412: LD_STRING initStreamRollete();
105414: PPUSH
105415: CALL_OW 559
// InitStreamMode ;
105419: CALL 105428 0 0
// DefineStreamItems ( ) ;
105423: CALL 105868 0 0
// end ;
105427: END
// function InitStreamMode ; begin
105428: LD_INT 0
105430: PPUSH
// streamModeActive := false ;
105431: LD_ADDR_EXP 160
105435: PUSH
105436: LD_INT 0
105438: ST_TO_ADDR
// normalCounter := 36 ;
105439: LD_ADDR_EXP 161
105443: PUSH
105444: LD_INT 36
105446: ST_TO_ADDR
// hardcoreCounter := 16 ;
105447: LD_ADDR_EXP 162
105451: PUSH
105452: LD_INT 16
105454: ST_TO_ADDR
// sRocket := false ;
105455: LD_ADDR_EXP 165
105459: PUSH
105460: LD_INT 0
105462: ST_TO_ADDR
// sSpeed := false ;
105463: LD_ADDR_EXP 164
105467: PUSH
105468: LD_INT 0
105470: ST_TO_ADDR
// sEngine := false ;
105471: LD_ADDR_EXP 166
105475: PUSH
105476: LD_INT 0
105478: ST_TO_ADDR
// sSpec := false ;
105479: LD_ADDR_EXP 163
105483: PUSH
105484: LD_INT 0
105486: ST_TO_ADDR
// sLevel := false ;
105487: LD_ADDR_EXP 167
105491: PUSH
105492: LD_INT 0
105494: ST_TO_ADDR
// sArmoury := false ;
105495: LD_ADDR_EXP 168
105499: PUSH
105500: LD_INT 0
105502: ST_TO_ADDR
// sRadar := false ;
105503: LD_ADDR_EXP 169
105507: PUSH
105508: LD_INT 0
105510: ST_TO_ADDR
// sBunker := false ;
105511: LD_ADDR_EXP 170
105515: PUSH
105516: LD_INT 0
105518: ST_TO_ADDR
// sHack := false ;
105519: LD_ADDR_EXP 171
105523: PUSH
105524: LD_INT 0
105526: ST_TO_ADDR
// sFire := false ;
105527: LD_ADDR_EXP 172
105531: PUSH
105532: LD_INT 0
105534: ST_TO_ADDR
// sRefresh := false ;
105535: LD_ADDR_EXP 173
105539: PUSH
105540: LD_INT 0
105542: ST_TO_ADDR
// sExp := false ;
105543: LD_ADDR_EXP 174
105547: PUSH
105548: LD_INT 0
105550: ST_TO_ADDR
// sDepot := false ;
105551: LD_ADDR_EXP 175
105555: PUSH
105556: LD_INT 0
105558: ST_TO_ADDR
// sFlag := false ;
105559: LD_ADDR_EXP 176
105563: PUSH
105564: LD_INT 0
105566: ST_TO_ADDR
// sKamikadze := false ;
105567: LD_ADDR_EXP 184
105571: PUSH
105572: LD_INT 0
105574: ST_TO_ADDR
// sTroll := false ;
105575: LD_ADDR_EXP 185
105579: PUSH
105580: LD_INT 0
105582: ST_TO_ADDR
// sSlow := false ;
105583: LD_ADDR_EXP 186
105587: PUSH
105588: LD_INT 0
105590: ST_TO_ADDR
// sLack := false ;
105591: LD_ADDR_EXP 187
105595: PUSH
105596: LD_INT 0
105598: ST_TO_ADDR
// sTank := false ;
105599: LD_ADDR_EXP 189
105603: PUSH
105604: LD_INT 0
105606: ST_TO_ADDR
// sRemote := false ;
105607: LD_ADDR_EXP 190
105611: PUSH
105612: LD_INT 0
105614: ST_TO_ADDR
// sPowell := false ;
105615: LD_ADDR_EXP 191
105619: PUSH
105620: LD_INT 0
105622: ST_TO_ADDR
// sTeleport := false ;
105623: LD_ADDR_EXP 194
105627: PUSH
105628: LD_INT 0
105630: ST_TO_ADDR
// sOilTower := false ;
105631: LD_ADDR_EXP 196
105635: PUSH
105636: LD_INT 0
105638: ST_TO_ADDR
// sShovel := false ;
105639: LD_ADDR_EXP 197
105643: PUSH
105644: LD_INT 0
105646: ST_TO_ADDR
// sSheik := false ;
105647: LD_ADDR_EXP 198
105651: PUSH
105652: LD_INT 0
105654: ST_TO_ADDR
// sEarthquake := false ;
105655: LD_ADDR_EXP 200
105659: PUSH
105660: LD_INT 0
105662: ST_TO_ADDR
// sAI := false ;
105663: LD_ADDR_EXP 201
105667: PUSH
105668: LD_INT 0
105670: ST_TO_ADDR
// sCargo := false ;
105671: LD_ADDR_EXP 204
105675: PUSH
105676: LD_INT 0
105678: ST_TO_ADDR
// sDLaser := false ;
105679: LD_ADDR_EXP 205
105683: PUSH
105684: LD_INT 0
105686: ST_TO_ADDR
// sExchange := false ;
105687: LD_ADDR_EXP 206
105691: PUSH
105692: LD_INT 0
105694: ST_TO_ADDR
// sFac := false ;
105695: LD_ADDR_EXP 207
105699: PUSH
105700: LD_INT 0
105702: ST_TO_ADDR
// sPower := false ;
105703: LD_ADDR_EXP 208
105707: PUSH
105708: LD_INT 0
105710: ST_TO_ADDR
// sRandom := false ;
105711: LD_ADDR_EXP 209
105715: PUSH
105716: LD_INT 0
105718: ST_TO_ADDR
// sShield := false ;
105719: LD_ADDR_EXP 210
105723: PUSH
105724: LD_INT 0
105726: ST_TO_ADDR
// sTime := false ;
105727: LD_ADDR_EXP 211
105731: PUSH
105732: LD_INT 0
105734: ST_TO_ADDR
// sTools := false ;
105735: LD_ADDR_EXP 212
105739: PUSH
105740: LD_INT 0
105742: ST_TO_ADDR
// sSold := false ;
105743: LD_ADDR_EXP 177
105747: PUSH
105748: LD_INT 0
105750: ST_TO_ADDR
// sDiff := false ;
105751: LD_ADDR_EXP 178
105755: PUSH
105756: LD_INT 0
105758: ST_TO_ADDR
// sFog := false ;
105759: LD_ADDR_EXP 181
105763: PUSH
105764: LD_INT 0
105766: ST_TO_ADDR
// sReset := false ;
105767: LD_ADDR_EXP 182
105771: PUSH
105772: LD_INT 0
105774: ST_TO_ADDR
// sSun := false ;
105775: LD_ADDR_EXP 183
105779: PUSH
105780: LD_INT 0
105782: ST_TO_ADDR
// sTiger := false ;
105783: LD_ADDR_EXP 179
105787: PUSH
105788: LD_INT 0
105790: ST_TO_ADDR
// sBomb := false ;
105791: LD_ADDR_EXP 180
105795: PUSH
105796: LD_INT 0
105798: ST_TO_ADDR
// sWound := false ;
105799: LD_ADDR_EXP 188
105803: PUSH
105804: LD_INT 0
105806: ST_TO_ADDR
// sBetray := false ;
105807: LD_ADDR_EXP 192
105811: PUSH
105812: LD_INT 0
105814: ST_TO_ADDR
// sContamin := false ;
105815: LD_ADDR_EXP 193
105819: PUSH
105820: LD_INT 0
105822: ST_TO_ADDR
// sOil := false ;
105823: LD_ADDR_EXP 195
105827: PUSH
105828: LD_INT 0
105830: ST_TO_ADDR
// sStu := false ;
105831: LD_ADDR_EXP 199
105835: PUSH
105836: LD_INT 0
105838: ST_TO_ADDR
// sBazooka := false ;
105839: LD_ADDR_EXP 202
105843: PUSH
105844: LD_INT 0
105846: ST_TO_ADDR
// sMortar := false ;
105847: LD_ADDR_EXP 203
105851: PUSH
105852: LD_INT 0
105854: ST_TO_ADDR
// sRanger := false ;
105855: LD_ADDR_EXP 213
105859: PUSH
105860: LD_INT 0
105862: ST_TO_ADDR
// end ;
105863: LD_VAR 0 1
105867: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
105868: LD_INT 0
105870: PPUSH
105871: PPUSH
105872: PPUSH
105873: PPUSH
105874: PPUSH
// result := [ ] ;
105875: LD_ADDR_VAR 0 1
105879: PUSH
105880: EMPTY
105881: ST_TO_ADDR
// if campaign_id = 1 then
105882: LD_OWVAR 69
105886: PUSH
105887: LD_INT 1
105889: EQUAL
105890: IFFALSE 108828
// begin case mission_number of 1 :
105892: LD_OWVAR 70
105896: PUSH
105897: LD_INT 1
105899: DOUBLE
105900: EQUAL
105901: IFTRUE 105905
105903: GO 105969
105905: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
105906: LD_ADDR_VAR 0 1
105910: PUSH
105911: LD_INT 2
105913: PUSH
105914: LD_INT 4
105916: PUSH
105917: LD_INT 11
105919: PUSH
105920: LD_INT 12
105922: PUSH
105923: LD_INT 15
105925: PUSH
105926: LD_INT 16
105928: PUSH
105929: LD_INT 22
105931: PUSH
105932: LD_INT 23
105934: PUSH
105935: LD_INT 26
105937: PUSH
105938: EMPTY
105939: LIST
105940: LIST
105941: LIST
105942: LIST
105943: LIST
105944: LIST
105945: LIST
105946: LIST
105947: LIST
105948: PUSH
105949: LD_INT 101
105951: PUSH
105952: LD_INT 102
105954: PUSH
105955: LD_INT 106
105957: PUSH
105958: EMPTY
105959: LIST
105960: LIST
105961: LIST
105962: PUSH
105963: EMPTY
105964: LIST
105965: LIST
105966: ST_TO_ADDR
105967: GO 108826
105969: LD_INT 2
105971: DOUBLE
105972: EQUAL
105973: IFTRUE 105977
105975: GO 106049
105977: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
105978: LD_ADDR_VAR 0 1
105982: PUSH
105983: LD_INT 2
105985: PUSH
105986: LD_INT 4
105988: PUSH
105989: LD_INT 11
105991: PUSH
105992: LD_INT 12
105994: PUSH
105995: LD_INT 15
105997: PUSH
105998: LD_INT 16
106000: PUSH
106001: LD_INT 22
106003: PUSH
106004: LD_INT 23
106006: PUSH
106007: LD_INT 26
106009: PUSH
106010: EMPTY
106011: LIST
106012: LIST
106013: LIST
106014: LIST
106015: LIST
106016: LIST
106017: LIST
106018: LIST
106019: LIST
106020: PUSH
106021: LD_INT 101
106023: PUSH
106024: LD_INT 102
106026: PUSH
106027: LD_INT 105
106029: PUSH
106030: LD_INT 106
106032: PUSH
106033: LD_INT 108
106035: PUSH
106036: EMPTY
106037: LIST
106038: LIST
106039: LIST
106040: LIST
106041: LIST
106042: PUSH
106043: EMPTY
106044: LIST
106045: LIST
106046: ST_TO_ADDR
106047: GO 108826
106049: LD_INT 3
106051: DOUBLE
106052: EQUAL
106053: IFTRUE 106057
106055: GO 106133
106057: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
106058: LD_ADDR_VAR 0 1
106062: PUSH
106063: LD_INT 2
106065: PUSH
106066: LD_INT 4
106068: PUSH
106069: LD_INT 5
106071: PUSH
106072: LD_INT 11
106074: PUSH
106075: LD_INT 12
106077: PUSH
106078: LD_INT 15
106080: PUSH
106081: LD_INT 16
106083: PUSH
106084: LD_INT 22
106086: PUSH
106087: LD_INT 26
106089: PUSH
106090: LD_INT 36
106092: PUSH
106093: EMPTY
106094: LIST
106095: LIST
106096: LIST
106097: LIST
106098: LIST
106099: LIST
106100: LIST
106101: LIST
106102: LIST
106103: LIST
106104: PUSH
106105: LD_INT 101
106107: PUSH
106108: LD_INT 102
106110: PUSH
106111: LD_INT 105
106113: PUSH
106114: LD_INT 106
106116: PUSH
106117: LD_INT 108
106119: PUSH
106120: EMPTY
106121: LIST
106122: LIST
106123: LIST
106124: LIST
106125: LIST
106126: PUSH
106127: EMPTY
106128: LIST
106129: LIST
106130: ST_TO_ADDR
106131: GO 108826
106133: LD_INT 4
106135: DOUBLE
106136: EQUAL
106137: IFTRUE 106141
106139: GO 106225
106141: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
106142: LD_ADDR_VAR 0 1
106146: PUSH
106147: LD_INT 2
106149: PUSH
106150: LD_INT 4
106152: PUSH
106153: LD_INT 5
106155: PUSH
106156: LD_INT 8
106158: PUSH
106159: LD_INT 11
106161: PUSH
106162: LD_INT 12
106164: PUSH
106165: LD_INT 15
106167: PUSH
106168: LD_INT 16
106170: PUSH
106171: LD_INT 22
106173: PUSH
106174: LD_INT 23
106176: PUSH
106177: LD_INT 26
106179: PUSH
106180: LD_INT 36
106182: PUSH
106183: EMPTY
106184: LIST
106185: LIST
106186: LIST
106187: LIST
106188: LIST
106189: LIST
106190: LIST
106191: LIST
106192: LIST
106193: LIST
106194: LIST
106195: LIST
106196: PUSH
106197: LD_INT 101
106199: PUSH
106200: LD_INT 102
106202: PUSH
106203: LD_INT 105
106205: PUSH
106206: LD_INT 106
106208: PUSH
106209: LD_INT 108
106211: PUSH
106212: EMPTY
106213: LIST
106214: LIST
106215: LIST
106216: LIST
106217: LIST
106218: PUSH
106219: EMPTY
106220: LIST
106221: LIST
106222: ST_TO_ADDR
106223: GO 108826
106225: LD_INT 5
106227: DOUBLE
106228: EQUAL
106229: IFTRUE 106233
106231: GO 106333
106233: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
106234: LD_ADDR_VAR 0 1
106238: PUSH
106239: LD_INT 2
106241: PUSH
106242: LD_INT 4
106244: PUSH
106245: LD_INT 5
106247: PUSH
106248: LD_INT 6
106250: PUSH
106251: LD_INT 8
106253: PUSH
106254: LD_INT 11
106256: PUSH
106257: LD_INT 12
106259: PUSH
106260: LD_INT 15
106262: PUSH
106263: LD_INT 16
106265: PUSH
106266: LD_INT 22
106268: PUSH
106269: LD_INT 23
106271: PUSH
106272: LD_INT 25
106274: PUSH
106275: LD_INT 26
106277: PUSH
106278: LD_INT 36
106280: PUSH
106281: EMPTY
106282: LIST
106283: LIST
106284: LIST
106285: LIST
106286: LIST
106287: LIST
106288: LIST
106289: LIST
106290: LIST
106291: LIST
106292: LIST
106293: LIST
106294: LIST
106295: LIST
106296: PUSH
106297: LD_INT 101
106299: PUSH
106300: LD_INT 102
106302: PUSH
106303: LD_INT 105
106305: PUSH
106306: LD_INT 106
106308: PUSH
106309: LD_INT 108
106311: PUSH
106312: LD_INT 109
106314: PUSH
106315: LD_INT 112
106317: PUSH
106318: EMPTY
106319: LIST
106320: LIST
106321: LIST
106322: LIST
106323: LIST
106324: LIST
106325: LIST
106326: PUSH
106327: EMPTY
106328: LIST
106329: LIST
106330: ST_TO_ADDR
106331: GO 108826
106333: LD_INT 6
106335: DOUBLE
106336: EQUAL
106337: IFTRUE 106341
106339: GO 106461
106341: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
106342: LD_ADDR_VAR 0 1
106346: PUSH
106347: LD_INT 2
106349: PUSH
106350: LD_INT 4
106352: PUSH
106353: LD_INT 5
106355: PUSH
106356: LD_INT 6
106358: PUSH
106359: LD_INT 8
106361: PUSH
106362: LD_INT 11
106364: PUSH
106365: LD_INT 12
106367: PUSH
106368: LD_INT 15
106370: PUSH
106371: LD_INT 16
106373: PUSH
106374: LD_INT 20
106376: PUSH
106377: LD_INT 21
106379: PUSH
106380: LD_INT 22
106382: PUSH
106383: LD_INT 23
106385: PUSH
106386: LD_INT 25
106388: PUSH
106389: LD_INT 26
106391: PUSH
106392: LD_INT 30
106394: PUSH
106395: LD_INT 31
106397: PUSH
106398: LD_INT 32
106400: PUSH
106401: LD_INT 36
106403: PUSH
106404: EMPTY
106405: LIST
106406: LIST
106407: LIST
106408: LIST
106409: LIST
106410: LIST
106411: LIST
106412: LIST
106413: LIST
106414: LIST
106415: LIST
106416: LIST
106417: LIST
106418: LIST
106419: LIST
106420: LIST
106421: LIST
106422: LIST
106423: LIST
106424: PUSH
106425: LD_INT 101
106427: PUSH
106428: LD_INT 102
106430: PUSH
106431: LD_INT 105
106433: PUSH
106434: LD_INT 106
106436: PUSH
106437: LD_INT 108
106439: PUSH
106440: LD_INT 109
106442: PUSH
106443: LD_INT 112
106445: PUSH
106446: EMPTY
106447: LIST
106448: LIST
106449: LIST
106450: LIST
106451: LIST
106452: LIST
106453: LIST
106454: PUSH
106455: EMPTY
106456: LIST
106457: LIST
106458: ST_TO_ADDR
106459: GO 108826
106461: LD_INT 7
106463: DOUBLE
106464: EQUAL
106465: IFTRUE 106469
106467: GO 106569
106469: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
106470: LD_ADDR_VAR 0 1
106474: PUSH
106475: LD_INT 2
106477: PUSH
106478: LD_INT 4
106480: PUSH
106481: LD_INT 5
106483: PUSH
106484: LD_INT 7
106486: PUSH
106487: LD_INT 11
106489: PUSH
106490: LD_INT 12
106492: PUSH
106493: LD_INT 15
106495: PUSH
106496: LD_INT 16
106498: PUSH
106499: LD_INT 20
106501: PUSH
106502: LD_INT 21
106504: PUSH
106505: LD_INT 22
106507: PUSH
106508: LD_INT 23
106510: PUSH
106511: LD_INT 25
106513: PUSH
106514: LD_INT 26
106516: PUSH
106517: EMPTY
106518: LIST
106519: LIST
106520: LIST
106521: LIST
106522: LIST
106523: LIST
106524: LIST
106525: LIST
106526: LIST
106527: LIST
106528: LIST
106529: LIST
106530: LIST
106531: LIST
106532: PUSH
106533: LD_INT 101
106535: PUSH
106536: LD_INT 102
106538: PUSH
106539: LD_INT 103
106541: PUSH
106542: LD_INT 105
106544: PUSH
106545: LD_INT 106
106547: PUSH
106548: LD_INT 108
106550: PUSH
106551: LD_INT 112
106553: PUSH
106554: EMPTY
106555: LIST
106556: LIST
106557: LIST
106558: LIST
106559: LIST
106560: LIST
106561: LIST
106562: PUSH
106563: EMPTY
106564: LIST
106565: LIST
106566: ST_TO_ADDR
106567: GO 108826
106569: LD_INT 8
106571: DOUBLE
106572: EQUAL
106573: IFTRUE 106577
106575: GO 106705
106577: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
106578: LD_ADDR_VAR 0 1
106582: PUSH
106583: LD_INT 2
106585: PUSH
106586: LD_INT 4
106588: PUSH
106589: LD_INT 5
106591: PUSH
106592: LD_INT 6
106594: PUSH
106595: LD_INT 7
106597: PUSH
106598: LD_INT 8
106600: PUSH
106601: LD_INT 11
106603: PUSH
106604: LD_INT 12
106606: PUSH
106607: LD_INT 15
106609: PUSH
106610: LD_INT 16
106612: PUSH
106613: LD_INT 20
106615: PUSH
106616: LD_INT 21
106618: PUSH
106619: LD_INT 22
106621: PUSH
106622: LD_INT 23
106624: PUSH
106625: LD_INT 25
106627: PUSH
106628: LD_INT 26
106630: PUSH
106631: LD_INT 30
106633: PUSH
106634: LD_INT 31
106636: PUSH
106637: LD_INT 32
106639: PUSH
106640: LD_INT 36
106642: PUSH
106643: EMPTY
106644: LIST
106645: LIST
106646: LIST
106647: LIST
106648: LIST
106649: LIST
106650: LIST
106651: LIST
106652: LIST
106653: LIST
106654: LIST
106655: LIST
106656: LIST
106657: LIST
106658: LIST
106659: LIST
106660: LIST
106661: LIST
106662: LIST
106663: LIST
106664: PUSH
106665: LD_INT 101
106667: PUSH
106668: LD_INT 102
106670: PUSH
106671: LD_INT 103
106673: PUSH
106674: LD_INT 105
106676: PUSH
106677: LD_INT 106
106679: PUSH
106680: LD_INT 108
106682: PUSH
106683: LD_INT 109
106685: PUSH
106686: LD_INT 112
106688: PUSH
106689: EMPTY
106690: LIST
106691: LIST
106692: LIST
106693: LIST
106694: LIST
106695: LIST
106696: LIST
106697: LIST
106698: PUSH
106699: EMPTY
106700: LIST
106701: LIST
106702: ST_TO_ADDR
106703: GO 108826
106705: LD_INT 9
106707: DOUBLE
106708: EQUAL
106709: IFTRUE 106713
106711: GO 106849
106713: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
106714: LD_ADDR_VAR 0 1
106718: PUSH
106719: LD_INT 2
106721: PUSH
106722: LD_INT 4
106724: PUSH
106725: LD_INT 5
106727: PUSH
106728: LD_INT 6
106730: PUSH
106731: LD_INT 7
106733: PUSH
106734: LD_INT 8
106736: PUSH
106737: LD_INT 11
106739: PUSH
106740: LD_INT 12
106742: PUSH
106743: LD_INT 15
106745: PUSH
106746: LD_INT 16
106748: PUSH
106749: LD_INT 20
106751: PUSH
106752: LD_INT 21
106754: PUSH
106755: LD_INT 22
106757: PUSH
106758: LD_INT 23
106760: PUSH
106761: LD_INT 25
106763: PUSH
106764: LD_INT 26
106766: PUSH
106767: LD_INT 28
106769: PUSH
106770: LD_INT 30
106772: PUSH
106773: LD_INT 31
106775: PUSH
106776: LD_INT 32
106778: PUSH
106779: LD_INT 36
106781: PUSH
106782: EMPTY
106783: LIST
106784: LIST
106785: LIST
106786: LIST
106787: LIST
106788: LIST
106789: LIST
106790: LIST
106791: LIST
106792: LIST
106793: LIST
106794: LIST
106795: LIST
106796: LIST
106797: LIST
106798: LIST
106799: LIST
106800: LIST
106801: LIST
106802: LIST
106803: LIST
106804: PUSH
106805: LD_INT 101
106807: PUSH
106808: LD_INT 102
106810: PUSH
106811: LD_INT 103
106813: PUSH
106814: LD_INT 105
106816: PUSH
106817: LD_INT 106
106819: PUSH
106820: LD_INT 108
106822: PUSH
106823: LD_INT 109
106825: PUSH
106826: LD_INT 112
106828: PUSH
106829: LD_INT 114
106831: PUSH
106832: EMPTY
106833: LIST
106834: LIST
106835: LIST
106836: LIST
106837: LIST
106838: LIST
106839: LIST
106840: LIST
106841: LIST
106842: PUSH
106843: EMPTY
106844: LIST
106845: LIST
106846: ST_TO_ADDR
106847: GO 108826
106849: LD_INT 10
106851: DOUBLE
106852: EQUAL
106853: IFTRUE 106857
106855: GO 107041
106857: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
106858: LD_ADDR_VAR 0 1
106862: PUSH
106863: LD_INT 2
106865: PUSH
106866: LD_INT 4
106868: PUSH
106869: LD_INT 5
106871: PUSH
106872: LD_INT 6
106874: PUSH
106875: LD_INT 7
106877: PUSH
106878: LD_INT 8
106880: PUSH
106881: LD_INT 9
106883: PUSH
106884: LD_INT 10
106886: PUSH
106887: LD_INT 11
106889: PUSH
106890: LD_INT 12
106892: PUSH
106893: LD_INT 13
106895: PUSH
106896: LD_INT 14
106898: PUSH
106899: LD_INT 15
106901: PUSH
106902: LD_INT 16
106904: PUSH
106905: LD_INT 17
106907: PUSH
106908: LD_INT 18
106910: PUSH
106911: LD_INT 19
106913: PUSH
106914: LD_INT 20
106916: PUSH
106917: LD_INT 21
106919: PUSH
106920: LD_INT 22
106922: PUSH
106923: LD_INT 23
106925: PUSH
106926: LD_INT 24
106928: PUSH
106929: LD_INT 25
106931: PUSH
106932: LD_INT 26
106934: PUSH
106935: LD_INT 28
106937: PUSH
106938: LD_INT 30
106940: PUSH
106941: LD_INT 31
106943: PUSH
106944: LD_INT 32
106946: PUSH
106947: LD_INT 36
106949: PUSH
106950: EMPTY
106951: LIST
106952: LIST
106953: LIST
106954: LIST
106955: LIST
106956: LIST
106957: LIST
106958: LIST
106959: LIST
106960: LIST
106961: LIST
106962: LIST
106963: LIST
106964: LIST
106965: LIST
106966: LIST
106967: LIST
106968: LIST
106969: LIST
106970: LIST
106971: LIST
106972: LIST
106973: LIST
106974: LIST
106975: LIST
106976: LIST
106977: LIST
106978: LIST
106979: LIST
106980: PUSH
106981: LD_INT 101
106983: PUSH
106984: LD_INT 102
106986: PUSH
106987: LD_INT 103
106989: PUSH
106990: LD_INT 104
106992: PUSH
106993: LD_INT 105
106995: PUSH
106996: LD_INT 106
106998: PUSH
106999: LD_INT 107
107001: PUSH
107002: LD_INT 108
107004: PUSH
107005: LD_INT 109
107007: PUSH
107008: LD_INT 110
107010: PUSH
107011: LD_INT 111
107013: PUSH
107014: LD_INT 112
107016: PUSH
107017: LD_INT 114
107019: PUSH
107020: EMPTY
107021: LIST
107022: LIST
107023: LIST
107024: LIST
107025: LIST
107026: LIST
107027: LIST
107028: LIST
107029: LIST
107030: LIST
107031: LIST
107032: LIST
107033: LIST
107034: PUSH
107035: EMPTY
107036: LIST
107037: LIST
107038: ST_TO_ADDR
107039: GO 108826
107041: LD_INT 11
107043: DOUBLE
107044: EQUAL
107045: IFTRUE 107049
107047: GO 107241
107049: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
107050: LD_ADDR_VAR 0 1
107054: PUSH
107055: LD_INT 2
107057: PUSH
107058: LD_INT 3
107060: PUSH
107061: LD_INT 4
107063: PUSH
107064: LD_INT 5
107066: PUSH
107067: LD_INT 6
107069: PUSH
107070: LD_INT 7
107072: PUSH
107073: LD_INT 8
107075: PUSH
107076: LD_INT 9
107078: PUSH
107079: LD_INT 10
107081: PUSH
107082: LD_INT 11
107084: PUSH
107085: LD_INT 12
107087: PUSH
107088: LD_INT 13
107090: PUSH
107091: LD_INT 14
107093: PUSH
107094: LD_INT 15
107096: PUSH
107097: LD_INT 16
107099: PUSH
107100: LD_INT 17
107102: PUSH
107103: LD_INT 18
107105: PUSH
107106: LD_INT 19
107108: PUSH
107109: LD_INT 20
107111: PUSH
107112: LD_INT 21
107114: PUSH
107115: LD_INT 22
107117: PUSH
107118: LD_INT 23
107120: PUSH
107121: LD_INT 24
107123: PUSH
107124: LD_INT 25
107126: PUSH
107127: LD_INT 26
107129: PUSH
107130: LD_INT 28
107132: PUSH
107133: LD_INT 30
107135: PUSH
107136: LD_INT 31
107138: PUSH
107139: LD_INT 32
107141: PUSH
107142: LD_INT 34
107144: PUSH
107145: LD_INT 36
107147: PUSH
107148: EMPTY
107149: LIST
107150: LIST
107151: LIST
107152: LIST
107153: LIST
107154: LIST
107155: LIST
107156: LIST
107157: LIST
107158: LIST
107159: LIST
107160: LIST
107161: LIST
107162: LIST
107163: LIST
107164: LIST
107165: LIST
107166: LIST
107167: LIST
107168: LIST
107169: LIST
107170: LIST
107171: LIST
107172: LIST
107173: LIST
107174: LIST
107175: LIST
107176: LIST
107177: LIST
107178: LIST
107179: LIST
107180: PUSH
107181: LD_INT 101
107183: PUSH
107184: LD_INT 102
107186: PUSH
107187: LD_INT 103
107189: PUSH
107190: LD_INT 104
107192: PUSH
107193: LD_INT 105
107195: PUSH
107196: LD_INT 106
107198: PUSH
107199: LD_INT 107
107201: PUSH
107202: LD_INT 108
107204: PUSH
107205: LD_INT 109
107207: PUSH
107208: LD_INT 110
107210: PUSH
107211: LD_INT 111
107213: PUSH
107214: LD_INT 112
107216: PUSH
107217: LD_INT 114
107219: PUSH
107220: EMPTY
107221: LIST
107222: LIST
107223: LIST
107224: LIST
107225: LIST
107226: LIST
107227: LIST
107228: LIST
107229: LIST
107230: LIST
107231: LIST
107232: LIST
107233: LIST
107234: PUSH
107235: EMPTY
107236: LIST
107237: LIST
107238: ST_TO_ADDR
107239: GO 108826
107241: LD_INT 12
107243: DOUBLE
107244: EQUAL
107245: IFTRUE 107249
107247: GO 107457
107249: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
107250: LD_ADDR_VAR 0 1
107254: PUSH
107255: LD_INT 1
107257: PUSH
107258: LD_INT 2
107260: PUSH
107261: LD_INT 3
107263: PUSH
107264: LD_INT 4
107266: PUSH
107267: LD_INT 5
107269: PUSH
107270: LD_INT 6
107272: PUSH
107273: LD_INT 7
107275: PUSH
107276: LD_INT 8
107278: PUSH
107279: LD_INT 9
107281: PUSH
107282: LD_INT 10
107284: PUSH
107285: LD_INT 11
107287: PUSH
107288: LD_INT 12
107290: PUSH
107291: LD_INT 13
107293: PUSH
107294: LD_INT 14
107296: PUSH
107297: LD_INT 15
107299: PUSH
107300: LD_INT 16
107302: PUSH
107303: LD_INT 17
107305: PUSH
107306: LD_INT 18
107308: PUSH
107309: LD_INT 19
107311: PUSH
107312: LD_INT 20
107314: PUSH
107315: LD_INT 21
107317: PUSH
107318: LD_INT 22
107320: PUSH
107321: LD_INT 23
107323: PUSH
107324: LD_INT 24
107326: PUSH
107327: LD_INT 25
107329: PUSH
107330: LD_INT 26
107332: PUSH
107333: LD_INT 27
107335: PUSH
107336: LD_INT 28
107338: PUSH
107339: LD_INT 30
107341: PUSH
107342: LD_INT 31
107344: PUSH
107345: LD_INT 32
107347: PUSH
107348: LD_INT 33
107350: PUSH
107351: LD_INT 34
107353: PUSH
107354: LD_INT 36
107356: PUSH
107357: EMPTY
107358: LIST
107359: LIST
107360: LIST
107361: LIST
107362: LIST
107363: LIST
107364: LIST
107365: LIST
107366: LIST
107367: LIST
107368: LIST
107369: LIST
107370: LIST
107371: LIST
107372: LIST
107373: LIST
107374: LIST
107375: LIST
107376: LIST
107377: LIST
107378: LIST
107379: LIST
107380: LIST
107381: LIST
107382: LIST
107383: LIST
107384: LIST
107385: LIST
107386: LIST
107387: LIST
107388: LIST
107389: LIST
107390: LIST
107391: LIST
107392: PUSH
107393: LD_INT 101
107395: PUSH
107396: LD_INT 102
107398: PUSH
107399: LD_INT 103
107401: PUSH
107402: LD_INT 104
107404: PUSH
107405: LD_INT 105
107407: PUSH
107408: LD_INT 106
107410: PUSH
107411: LD_INT 107
107413: PUSH
107414: LD_INT 108
107416: PUSH
107417: LD_INT 109
107419: PUSH
107420: LD_INT 110
107422: PUSH
107423: LD_INT 111
107425: PUSH
107426: LD_INT 112
107428: PUSH
107429: LD_INT 113
107431: PUSH
107432: LD_INT 114
107434: PUSH
107435: EMPTY
107436: LIST
107437: LIST
107438: LIST
107439: LIST
107440: LIST
107441: LIST
107442: LIST
107443: LIST
107444: LIST
107445: LIST
107446: LIST
107447: LIST
107448: LIST
107449: LIST
107450: PUSH
107451: EMPTY
107452: LIST
107453: LIST
107454: ST_TO_ADDR
107455: GO 108826
107457: LD_INT 13
107459: DOUBLE
107460: EQUAL
107461: IFTRUE 107465
107463: GO 107661
107465: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
107466: LD_ADDR_VAR 0 1
107470: PUSH
107471: LD_INT 1
107473: PUSH
107474: LD_INT 2
107476: PUSH
107477: LD_INT 3
107479: PUSH
107480: LD_INT 4
107482: PUSH
107483: LD_INT 5
107485: PUSH
107486: LD_INT 8
107488: PUSH
107489: LD_INT 9
107491: PUSH
107492: LD_INT 10
107494: PUSH
107495: LD_INT 11
107497: PUSH
107498: LD_INT 12
107500: PUSH
107501: LD_INT 14
107503: PUSH
107504: LD_INT 15
107506: PUSH
107507: LD_INT 16
107509: PUSH
107510: LD_INT 17
107512: PUSH
107513: LD_INT 18
107515: PUSH
107516: LD_INT 19
107518: PUSH
107519: LD_INT 20
107521: PUSH
107522: LD_INT 21
107524: PUSH
107525: LD_INT 22
107527: PUSH
107528: LD_INT 23
107530: PUSH
107531: LD_INT 24
107533: PUSH
107534: LD_INT 25
107536: PUSH
107537: LD_INT 26
107539: PUSH
107540: LD_INT 27
107542: PUSH
107543: LD_INT 28
107545: PUSH
107546: LD_INT 30
107548: PUSH
107549: LD_INT 31
107551: PUSH
107552: LD_INT 32
107554: PUSH
107555: LD_INT 33
107557: PUSH
107558: LD_INT 34
107560: PUSH
107561: LD_INT 36
107563: PUSH
107564: EMPTY
107565: LIST
107566: LIST
107567: LIST
107568: LIST
107569: LIST
107570: LIST
107571: LIST
107572: LIST
107573: LIST
107574: LIST
107575: LIST
107576: LIST
107577: LIST
107578: LIST
107579: LIST
107580: LIST
107581: LIST
107582: LIST
107583: LIST
107584: LIST
107585: LIST
107586: LIST
107587: LIST
107588: LIST
107589: LIST
107590: LIST
107591: LIST
107592: LIST
107593: LIST
107594: LIST
107595: LIST
107596: PUSH
107597: LD_INT 101
107599: PUSH
107600: LD_INT 102
107602: PUSH
107603: LD_INT 103
107605: PUSH
107606: LD_INT 104
107608: PUSH
107609: LD_INT 105
107611: PUSH
107612: LD_INT 106
107614: PUSH
107615: LD_INT 107
107617: PUSH
107618: LD_INT 108
107620: PUSH
107621: LD_INT 109
107623: PUSH
107624: LD_INT 110
107626: PUSH
107627: LD_INT 111
107629: PUSH
107630: LD_INT 112
107632: PUSH
107633: LD_INT 113
107635: PUSH
107636: LD_INT 114
107638: PUSH
107639: EMPTY
107640: LIST
107641: LIST
107642: LIST
107643: LIST
107644: LIST
107645: LIST
107646: LIST
107647: LIST
107648: LIST
107649: LIST
107650: LIST
107651: LIST
107652: LIST
107653: LIST
107654: PUSH
107655: EMPTY
107656: LIST
107657: LIST
107658: ST_TO_ADDR
107659: GO 108826
107661: LD_INT 14
107663: DOUBLE
107664: EQUAL
107665: IFTRUE 107669
107667: GO 107881
107669: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
107670: LD_ADDR_VAR 0 1
107674: PUSH
107675: LD_INT 1
107677: PUSH
107678: LD_INT 2
107680: PUSH
107681: LD_INT 3
107683: PUSH
107684: LD_INT 4
107686: PUSH
107687: LD_INT 5
107689: PUSH
107690: LD_INT 6
107692: PUSH
107693: LD_INT 7
107695: PUSH
107696: LD_INT 8
107698: PUSH
107699: LD_INT 9
107701: PUSH
107702: LD_INT 10
107704: PUSH
107705: LD_INT 11
107707: PUSH
107708: LD_INT 12
107710: PUSH
107711: LD_INT 13
107713: PUSH
107714: LD_INT 14
107716: PUSH
107717: LD_INT 15
107719: PUSH
107720: LD_INT 16
107722: PUSH
107723: LD_INT 17
107725: PUSH
107726: LD_INT 18
107728: PUSH
107729: LD_INT 19
107731: PUSH
107732: LD_INT 20
107734: PUSH
107735: LD_INT 21
107737: PUSH
107738: LD_INT 22
107740: PUSH
107741: LD_INT 23
107743: PUSH
107744: LD_INT 24
107746: PUSH
107747: LD_INT 25
107749: PUSH
107750: LD_INT 26
107752: PUSH
107753: LD_INT 27
107755: PUSH
107756: LD_INT 28
107758: PUSH
107759: LD_INT 29
107761: PUSH
107762: LD_INT 30
107764: PUSH
107765: LD_INT 31
107767: PUSH
107768: LD_INT 32
107770: PUSH
107771: LD_INT 33
107773: PUSH
107774: LD_INT 34
107776: PUSH
107777: LD_INT 36
107779: PUSH
107780: EMPTY
107781: LIST
107782: LIST
107783: LIST
107784: LIST
107785: LIST
107786: LIST
107787: LIST
107788: LIST
107789: LIST
107790: LIST
107791: LIST
107792: LIST
107793: LIST
107794: LIST
107795: LIST
107796: LIST
107797: LIST
107798: LIST
107799: LIST
107800: LIST
107801: LIST
107802: LIST
107803: LIST
107804: LIST
107805: LIST
107806: LIST
107807: LIST
107808: LIST
107809: LIST
107810: LIST
107811: LIST
107812: LIST
107813: LIST
107814: LIST
107815: LIST
107816: PUSH
107817: LD_INT 101
107819: PUSH
107820: LD_INT 102
107822: PUSH
107823: LD_INT 103
107825: PUSH
107826: LD_INT 104
107828: PUSH
107829: LD_INT 105
107831: PUSH
107832: LD_INT 106
107834: PUSH
107835: LD_INT 107
107837: PUSH
107838: LD_INT 108
107840: PUSH
107841: LD_INT 109
107843: PUSH
107844: LD_INT 110
107846: PUSH
107847: LD_INT 111
107849: PUSH
107850: LD_INT 112
107852: PUSH
107853: LD_INT 113
107855: PUSH
107856: LD_INT 114
107858: PUSH
107859: EMPTY
107860: LIST
107861: LIST
107862: LIST
107863: LIST
107864: LIST
107865: LIST
107866: LIST
107867: LIST
107868: LIST
107869: LIST
107870: LIST
107871: LIST
107872: LIST
107873: LIST
107874: PUSH
107875: EMPTY
107876: LIST
107877: LIST
107878: ST_TO_ADDR
107879: GO 108826
107881: LD_INT 15
107883: DOUBLE
107884: EQUAL
107885: IFTRUE 107889
107887: GO 108101
107889: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
107890: LD_ADDR_VAR 0 1
107894: PUSH
107895: LD_INT 1
107897: PUSH
107898: LD_INT 2
107900: PUSH
107901: LD_INT 3
107903: PUSH
107904: LD_INT 4
107906: PUSH
107907: LD_INT 5
107909: PUSH
107910: LD_INT 6
107912: PUSH
107913: LD_INT 7
107915: PUSH
107916: LD_INT 8
107918: PUSH
107919: LD_INT 9
107921: PUSH
107922: LD_INT 10
107924: PUSH
107925: LD_INT 11
107927: PUSH
107928: LD_INT 12
107930: PUSH
107931: LD_INT 13
107933: PUSH
107934: LD_INT 14
107936: PUSH
107937: LD_INT 15
107939: PUSH
107940: LD_INT 16
107942: PUSH
107943: LD_INT 17
107945: PUSH
107946: LD_INT 18
107948: PUSH
107949: LD_INT 19
107951: PUSH
107952: LD_INT 20
107954: PUSH
107955: LD_INT 21
107957: PUSH
107958: LD_INT 22
107960: PUSH
107961: LD_INT 23
107963: PUSH
107964: LD_INT 24
107966: PUSH
107967: LD_INT 25
107969: PUSH
107970: LD_INT 26
107972: PUSH
107973: LD_INT 27
107975: PUSH
107976: LD_INT 28
107978: PUSH
107979: LD_INT 29
107981: PUSH
107982: LD_INT 30
107984: PUSH
107985: LD_INT 31
107987: PUSH
107988: LD_INT 32
107990: PUSH
107991: LD_INT 33
107993: PUSH
107994: LD_INT 34
107996: PUSH
107997: LD_INT 36
107999: PUSH
108000: EMPTY
108001: LIST
108002: LIST
108003: LIST
108004: LIST
108005: LIST
108006: LIST
108007: LIST
108008: LIST
108009: LIST
108010: LIST
108011: LIST
108012: LIST
108013: LIST
108014: LIST
108015: LIST
108016: LIST
108017: LIST
108018: LIST
108019: LIST
108020: LIST
108021: LIST
108022: LIST
108023: LIST
108024: LIST
108025: LIST
108026: LIST
108027: LIST
108028: LIST
108029: LIST
108030: LIST
108031: LIST
108032: LIST
108033: LIST
108034: LIST
108035: LIST
108036: PUSH
108037: LD_INT 101
108039: PUSH
108040: LD_INT 102
108042: PUSH
108043: LD_INT 103
108045: PUSH
108046: LD_INT 104
108048: PUSH
108049: LD_INT 105
108051: PUSH
108052: LD_INT 106
108054: PUSH
108055: LD_INT 107
108057: PUSH
108058: LD_INT 108
108060: PUSH
108061: LD_INT 109
108063: PUSH
108064: LD_INT 110
108066: PUSH
108067: LD_INT 111
108069: PUSH
108070: LD_INT 112
108072: PUSH
108073: LD_INT 113
108075: PUSH
108076: LD_INT 114
108078: PUSH
108079: EMPTY
108080: LIST
108081: LIST
108082: LIST
108083: LIST
108084: LIST
108085: LIST
108086: LIST
108087: LIST
108088: LIST
108089: LIST
108090: LIST
108091: LIST
108092: LIST
108093: LIST
108094: PUSH
108095: EMPTY
108096: LIST
108097: LIST
108098: ST_TO_ADDR
108099: GO 108826
108101: LD_INT 16
108103: DOUBLE
108104: EQUAL
108105: IFTRUE 108109
108107: GO 108233
108109: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
108110: LD_ADDR_VAR 0 1
108114: PUSH
108115: LD_INT 2
108117: PUSH
108118: LD_INT 4
108120: PUSH
108121: LD_INT 5
108123: PUSH
108124: LD_INT 7
108126: PUSH
108127: LD_INT 11
108129: PUSH
108130: LD_INT 12
108132: PUSH
108133: LD_INT 15
108135: PUSH
108136: LD_INT 16
108138: PUSH
108139: LD_INT 20
108141: PUSH
108142: LD_INT 21
108144: PUSH
108145: LD_INT 22
108147: PUSH
108148: LD_INT 23
108150: PUSH
108151: LD_INT 25
108153: PUSH
108154: LD_INT 26
108156: PUSH
108157: LD_INT 30
108159: PUSH
108160: LD_INT 31
108162: PUSH
108163: LD_INT 32
108165: PUSH
108166: LD_INT 33
108168: PUSH
108169: LD_INT 34
108171: PUSH
108172: EMPTY
108173: LIST
108174: LIST
108175: LIST
108176: LIST
108177: LIST
108178: LIST
108179: LIST
108180: LIST
108181: LIST
108182: LIST
108183: LIST
108184: LIST
108185: LIST
108186: LIST
108187: LIST
108188: LIST
108189: LIST
108190: LIST
108191: LIST
108192: PUSH
108193: LD_INT 101
108195: PUSH
108196: LD_INT 102
108198: PUSH
108199: LD_INT 103
108201: PUSH
108202: LD_INT 106
108204: PUSH
108205: LD_INT 108
108207: PUSH
108208: LD_INT 112
108210: PUSH
108211: LD_INT 113
108213: PUSH
108214: LD_INT 114
108216: PUSH
108217: EMPTY
108218: LIST
108219: LIST
108220: LIST
108221: LIST
108222: LIST
108223: LIST
108224: LIST
108225: LIST
108226: PUSH
108227: EMPTY
108228: LIST
108229: LIST
108230: ST_TO_ADDR
108231: GO 108826
108233: LD_INT 17
108235: DOUBLE
108236: EQUAL
108237: IFTRUE 108241
108239: GO 108453
108241: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
108242: LD_ADDR_VAR 0 1
108246: PUSH
108247: LD_INT 1
108249: PUSH
108250: LD_INT 2
108252: PUSH
108253: LD_INT 3
108255: PUSH
108256: LD_INT 4
108258: PUSH
108259: LD_INT 5
108261: PUSH
108262: LD_INT 6
108264: PUSH
108265: LD_INT 7
108267: PUSH
108268: LD_INT 8
108270: PUSH
108271: LD_INT 9
108273: PUSH
108274: LD_INT 10
108276: PUSH
108277: LD_INT 11
108279: PUSH
108280: LD_INT 12
108282: PUSH
108283: LD_INT 13
108285: PUSH
108286: LD_INT 14
108288: PUSH
108289: LD_INT 15
108291: PUSH
108292: LD_INT 16
108294: PUSH
108295: LD_INT 17
108297: PUSH
108298: LD_INT 18
108300: PUSH
108301: LD_INT 19
108303: PUSH
108304: LD_INT 20
108306: PUSH
108307: LD_INT 21
108309: PUSH
108310: LD_INT 22
108312: PUSH
108313: LD_INT 23
108315: PUSH
108316: LD_INT 24
108318: PUSH
108319: LD_INT 25
108321: PUSH
108322: LD_INT 26
108324: PUSH
108325: LD_INT 27
108327: PUSH
108328: LD_INT 28
108330: PUSH
108331: LD_INT 29
108333: PUSH
108334: LD_INT 30
108336: PUSH
108337: LD_INT 31
108339: PUSH
108340: LD_INT 32
108342: PUSH
108343: LD_INT 33
108345: PUSH
108346: LD_INT 34
108348: PUSH
108349: LD_INT 36
108351: PUSH
108352: EMPTY
108353: LIST
108354: LIST
108355: LIST
108356: LIST
108357: LIST
108358: LIST
108359: LIST
108360: LIST
108361: LIST
108362: LIST
108363: LIST
108364: LIST
108365: LIST
108366: LIST
108367: LIST
108368: LIST
108369: LIST
108370: LIST
108371: LIST
108372: LIST
108373: LIST
108374: LIST
108375: LIST
108376: LIST
108377: LIST
108378: LIST
108379: LIST
108380: LIST
108381: LIST
108382: LIST
108383: LIST
108384: LIST
108385: LIST
108386: LIST
108387: LIST
108388: PUSH
108389: LD_INT 101
108391: PUSH
108392: LD_INT 102
108394: PUSH
108395: LD_INT 103
108397: PUSH
108398: LD_INT 104
108400: PUSH
108401: LD_INT 105
108403: PUSH
108404: LD_INT 106
108406: PUSH
108407: LD_INT 107
108409: PUSH
108410: LD_INT 108
108412: PUSH
108413: LD_INT 109
108415: PUSH
108416: LD_INT 110
108418: PUSH
108419: LD_INT 111
108421: PUSH
108422: LD_INT 112
108424: PUSH
108425: LD_INT 113
108427: PUSH
108428: LD_INT 114
108430: PUSH
108431: EMPTY
108432: LIST
108433: LIST
108434: LIST
108435: LIST
108436: LIST
108437: LIST
108438: LIST
108439: LIST
108440: LIST
108441: LIST
108442: LIST
108443: LIST
108444: LIST
108445: LIST
108446: PUSH
108447: EMPTY
108448: LIST
108449: LIST
108450: ST_TO_ADDR
108451: GO 108826
108453: LD_INT 18
108455: DOUBLE
108456: EQUAL
108457: IFTRUE 108461
108459: GO 108597
108461: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
108462: LD_ADDR_VAR 0 1
108466: PUSH
108467: LD_INT 2
108469: PUSH
108470: LD_INT 4
108472: PUSH
108473: LD_INT 5
108475: PUSH
108476: LD_INT 7
108478: PUSH
108479: LD_INT 11
108481: PUSH
108482: LD_INT 12
108484: PUSH
108485: LD_INT 15
108487: PUSH
108488: LD_INT 16
108490: PUSH
108491: LD_INT 20
108493: PUSH
108494: LD_INT 21
108496: PUSH
108497: LD_INT 22
108499: PUSH
108500: LD_INT 23
108502: PUSH
108503: LD_INT 25
108505: PUSH
108506: LD_INT 26
108508: PUSH
108509: LD_INT 30
108511: PUSH
108512: LD_INT 31
108514: PUSH
108515: LD_INT 32
108517: PUSH
108518: LD_INT 33
108520: PUSH
108521: LD_INT 34
108523: PUSH
108524: LD_INT 35
108526: PUSH
108527: LD_INT 36
108529: PUSH
108530: EMPTY
108531: LIST
108532: LIST
108533: LIST
108534: LIST
108535: LIST
108536: LIST
108537: LIST
108538: LIST
108539: LIST
108540: LIST
108541: LIST
108542: LIST
108543: LIST
108544: LIST
108545: LIST
108546: LIST
108547: LIST
108548: LIST
108549: LIST
108550: LIST
108551: LIST
108552: PUSH
108553: LD_INT 101
108555: PUSH
108556: LD_INT 102
108558: PUSH
108559: LD_INT 103
108561: PUSH
108562: LD_INT 106
108564: PUSH
108565: LD_INT 108
108567: PUSH
108568: LD_INT 112
108570: PUSH
108571: LD_INT 113
108573: PUSH
108574: LD_INT 114
108576: PUSH
108577: LD_INT 115
108579: PUSH
108580: EMPTY
108581: LIST
108582: LIST
108583: LIST
108584: LIST
108585: LIST
108586: LIST
108587: LIST
108588: LIST
108589: LIST
108590: PUSH
108591: EMPTY
108592: LIST
108593: LIST
108594: ST_TO_ADDR
108595: GO 108826
108597: LD_INT 19
108599: DOUBLE
108600: EQUAL
108601: IFTRUE 108605
108603: GO 108825
108605: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
108606: LD_ADDR_VAR 0 1
108610: PUSH
108611: LD_INT 1
108613: PUSH
108614: LD_INT 2
108616: PUSH
108617: LD_INT 3
108619: PUSH
108620: LD_INT 4
108622: PUSH
108623: LD_INT 5
108625: PUSH
108626: LD_INT 6
108628: PUSH
108629: LD_INT 7
108631: PUSH
108632: LD_INT 8
108634: PUSH
108635: LD_INT 9
108637: PUSH
108638: LD_INT 10
108640: PUSH
108641: LD_INT 11
108643: PUSH
108644: LD_INT 12
108646: PUSH
108647: LD_INT 13
108649: PUSH
108650: LD_INT 14
108652: PUSH
108653: LD_INT 15
108655: PUSH
108656: LD_INT 16
108658: PUSH
108659: LD_INT 17
108661: PUSH
108662: LD_INT 18
108664: PUSH
108665: LD_INT 19
108667: PUSH
108668: LD_INT 20
108670: PUSH
108671: LD_INT 21
108673: PUSH
108674: LD_INT 22
108676: PUSH
108677: LD_INT 23
108679: PUSH
108680: LD_INT 24
108682: PUSH
108683: LD_INT 25
108685: PUSH
108686: LD_INT 26
108688: PUSH
108689: LD_INT 27
108691: PUSH
108692: LD_INT 28
108694: PUSH
108695: LD_INT 29
108697: PUSH
108698: LD_INT 30
108700: PUSH
108701: LD_INT 31
108703: PUSH
108704: LD_INT 32
108706: PUSH
108707: LD_INT 33
108709: PUSH
108710: LD_INT 34
108712: PUSH
108713: LD_INT 35
108715: PUSH
108716: LD_INT 36
108718: PUSH
108719: EMPTY
108720: LIST
108721: LIST
108722: LIST
108723: LIST
108724: LIST
108725: LIST
108726: LIST
108727: LIST
108728: LIST
108729: LIST
108730: LIST
108731: LIST
108732: LIST
108733: LIST
108734: LIST
108735: LIST
108736: LIST
108737: LIST
108738: LIST
108739: LIST
108740: LIST
108741: LIST
108742: LIST
108743: LIST
108744: LIST
108745: LIST
108746: LIST
108747: LIST
108748: LIST
108749: LIST
108750: LIST
108751: LIST
108752: LIST
108753: LIST
108754: LIST
108755: LIST
108756: PUSH
108757: LD_INT 101
108759: PUSH
108760: LD_INT 102
108762: PUSH
108763: LD_INT 103
108765: PUSH
108766: LD_INT 104
108768: PUSH
108769: LD_INT 105
108771: PUSH
108772: LD_INT 106
108774: PUSH
108775: LD_INT 107
108777: PUSH
108778: LD_INT 108
108780: PUSH
108781: LD_INT 109
108783: PUSH
108784: LD_INT 110
108786: PUSH
108787: LD_INT 111
108789: PUSH
108790: LD_INT 112
108792: PUSH
108793: LD_INT 113
108795: PUSH
108796: LD_INT 114
108798: PUSH
108799: LD_INT 115
108801: PUSH
108802: EMPTY
108803: LIST
108804: LIST
108805: LIST
108806: LIST
108807: LIST
108808: LIST
108809: LIST
108810: LIST
108811: LIST
108812: LIST
108813: LIST
108814: LIST
108815: LIST
108816: LIST
108817: LIST
108818: PUSH
108819: EMPTY
108820: LIST
108821: LIST
108822: ST_TO_ADDR
108823: GO 108826
108825: POP
// end else
108826: GO 109045
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
108828: LD_ADDR_VAR 0 1
108832: PUSH
108833: LD_INT 1
108835: PUSH
108836: LD_INT 2
108838: PUSH
108839: LD_INT 3
108841: PUSH
108842: LD_INT 4
108844: PUSH
108845: LD_INT 5
108847: PUSH
108848: LD_INT 6
108850: PUSH
108851: LD_INT 7
108853: PUSH
108854: LD_INT 8
108856: PUSH
108857: LD_INT 9
108859: PUSH
108860: LD_INT 10
108862: PUSH
108863: LD_INT 11
108865: PUSH
108866: LD_INT 12
108868: PUSH
108869: LD_INT 13
108871: PUSH
108872: LD_INT 14
108874: PUSH
108875: LD_INT 15
108877: PUSH
108878: LD_INT 16
108880: PUSH
108881: LD_INT 17
108883: PUSH
108884: LD_INT 18
108886: PUSH
108887: LD_INT 19
108889: PUSH
108890: LD_INT 20
108892: PUSH
108893: LD_INT 21
108895: PUSH
108896: LD_INT 22
108898: PUSH
108899: LD_INT 23
108901: PUSH
108902: LD_INT 24
108904: PUSH
108905: LD_INT 25
108907: PUSH
108908: LD_INT 26
108910: PUSH
108911: LD_INT 27
108913: PUSH
108914: LD_INT 28
108916: PUSH
108917: LD_INT 29
108919: PUSH
108920: LD_INT 30
108922: PUSH
108923: LD_INT 31
108925: PUSH
108926: LD_INT 32
108928: PUSH
108929: LD_INT 33
108931: PUSH
108932: LD_INT 34
108934: PUSH
108935: LD_INT 35
108937: PUSH
108938: LD_INT 36
108940: PUSH
108941: EMPTY
108942: LIST
108943: LIST
108944: LIST
108945: LIST
108946: LIST
108947: LIST
108948: LIST
108949: LIST
108950: LIST
108951: LIST
108952: LIST
108953: LIST
108954: LIST
108955: LIST
108956: LIST
108957: LIST
108958: LIST
108959: LIST
108960: LIST
108961: LIST
108962: LIST
108963: LIST
108964: LIST
108965: LIST
108966: LIST
108967: LIST
108968: LIST
108969: LIST
108970: LIST
108971: LIST
108972: LIST
108973: LIST
108974: LIST
108975: LIST
108976: LIST
108977: LIST
108978: PUSH
108979: LD_INT 101
108981: PUSH
108982: LD_INT 102
108984: PUSH
108985: LD_INT 103
108987: PUSH
108988: LD_INT 104
108990: PUSH
108991: LD_INT 105
108993: PUSH
108994: LD_INT 106
108996: PUSH
108997: LD_INT 107
108999: PUSH
109000: LD_INT 108
109002: PUSH
109003: LD_INT 109
109005: PUSH
109006: LD_INT 110
109008: PUSH
109009: LD_INT 111
109011: PUSH
109012: LD_INT 112
109014: PUSH
109015: LD_INT 113
109017: PUSH
109018: LD_INT 114
109020: PUSH
109021: LD_INT 115
109023: PUSH
109024: EMPTY
109025: LIST
109026: LIST
109027: LIST
109028: LIST
109029: LIST
109030: LIST
109031: LIST
109032: LIST
109033: LIST
109034: LIST
109035: LIST
109036: LIST
109037: LIST
109038: LIST
109039: LIST
109040: PUSH
109041: EMPTY
109042: LIST
109043: LIST
109044: ST_TO_ADDR
// if result then
109045: LD_VAR 0 1
109049: IFFALSE 109338
// begin normal :=  ;
109051: LD_ADDR_VAR 0 3
109055: PUSH
109056: LD_STRING 
109058: ST_TO_ADDR
// hardcore :=  ;
109059: LD_ADDR_VAR 0 4
109063: PUSH
109064: LD_STRING 
109066: ST_TO_ADDR
// for i = 1 to normalCounter do
109067: LD_ADDR_VAR 0 5
109071: PUSH
109072: DOUBLE
109073: LD_INT 1
109075: DEC
109076: ST_TO_ADDR
109077: LD_EXP 161
109081: PUSH
109082: FOR_TO
109083: IFFALSE 109184
// begin tmp := 0 ;
109085: LD_ADDR_VAR 0 2
109089: PUSH
109090: LD_STRING 0
109092: ST_TO_ADDR
// if result [ 1 ] then
109093: LD_VAR 0 1
109097: PUSH
109098: LD_INT 1
109100: ARRAY
109101: IFFALSE 109166
// if result [ 1 ] [ 1 ] = i then
109103: LD_VAR 0 1
109107: PUSH
109108: LD_INT 1
109110: ARRAY
109111: PUSH
109112: LD_INT 1
109114: ARRAY
109115: PUSH
109116: LD_VAR 0 5
109120: EQUAL
109121: IFFALSE 109166
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
109123: LD_ADDR_VAR 0 1
109127: PUSH
109128: LD_VAR 0 1
109132: PPUSH
109133: LD_INT 1
109135: PPUSH
109136: LD_VAR 0 1
109140: PUSH
109141: LD_INT 1
109143: ARRAY
109144: PPUSH
109145: LD_INT 1
109147: PPUSH
109148: CALL_OW 3
109152: PPUSH
109153: CALL_OW 1
109157: ST_TO_ADDR
// tmp := 1 ;
109158: LD_ADDR_VAR 0 2
109162: PUSH
109163: LD_STRING 1
109165: ST_TO_ADDR
// end ; normal := normal & tmp ;
109166: LD_ADDR_VAR 0 3
109170: PUSH
109171: LD_VAR 0 3
109175: PUSH
109176: LD_VAR 0 2
109180: STR
109181: ST_TO_ADDR
// end ;
109182: GO 109082
109184: POP
109185: POP
// for i = 1 to hardcoreCounter do
109186: LD_ADDR_VAR 0 5
109190: PUSH
109191: DOUBLE
109192: LD_INT 1
109194: DEC
109195: ST_TO_ADDR
109196: LD_EXP 162
109200: PUSH
109201: FOR_TO
109202: IFFALSE 109307
// begin tmp := 0 ;
109204: LD_ADDR_VAR 0 2
109208: PUSH
109209: LD_STRING 0
109211: ST_TO_ADDR
// if result [ 2 ] then
109212: LD_VAR 0 1
109216: PUSH
109217: LD_INT 2
109219: ARRAY
109220: IFFALSE 109289
// if result [ 2 ] [ 1 ] = 100 + i then
109222: LD_VAR 0 1
109226: PUSH
109227: LD_INT 2
109229: ARRAY
109230: PUSH
109231: LD_INT 1
109233: ARRAY
109234: PUSH
109235: LD_INT 100
109237: PUSH
109238: LD_VAR 0 5
109242: PLUS
109243: EQUAL
109244: IFFALSE 109289
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
109246: LD_ADDR_VAR 0 1
109250: PUSH
109251: LD_VAR 0 1
109255: PPUSH
109256: LD_INT 2
109258: PPUSH
109259: LD_VAR 0 1
109263: PUSH
109264: LD_INT 2
109266: ARRAY
109267: PPUSH
109268: LD_INT 1
109270: PPUSH
109271: CALL_OW 3
109275: PPUSH
109276: CALL_OW 1
109280: ST_TO_ADDR
// tmp := 1 ;
109281: LD_ADDR_VAR 0 2
109285: PUSH
109286: LD_STRING 1
109288: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
109289: LD_ADDR_VAR 0 4
109293: PUSH
109294: LD_VAR 0 4
109298: PUSH
109299: LD_VAR 0 2
109303: STR
109304: ST_TO_ADDR
// end ;
109305: GO 109201
109307: POP
109308: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
109309: LD_STRING getStreamItemsFromMission("
109311: PUSH
109312: LD_VAR 0 3
109316: STR
109317: PUSH
109318: LD_STRING ","
109320: STR
109321: PUSH
109322: LD_VAR 0 4
109326: STR
109327: PUSH
109328: LD_STRING ")
109330: STR
109331: PPUSH
109332: CALL_OW 559
// end else
109336: GO 109345
// ToLua ( getStreamItemsFromMission("","") ) ;
109338: LD_STRING getStreamItemsFromMission("","")
109340: PPUSH
109341: CALL_OW 559
// end ;
109345: LD_VAR 0 1
109349: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
109350: LD_EXP 160
109354: PUSH
109355: LD_EXP 165
109359: AND
109360: IFFALSE 109484
109362: GO 109364
109364: DISABLE
109365: LD_INT 0
109367: PPUSH
109368: PPUSH
// begin enable ;
109369: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
109370: LD_ADDR_VAR 0 2
109374: PUSH
109375: LD_INT 22
109377: PUSH
109378: LD_OWVAR 2
109382: PUSH
109383: EMPTY
109384: LIST
109385: LIST
109386: PUSH
109387: LD_INT 2
109389: PUSH
109390: LD_INT 34
109392: PUSH
109393: LD_INT 7
109395: PUSH
109396: EMPTY
109397: LIST
109398: LIST
109399: PUSH
109400: LD_INT 34
109402: PUSH
109403: LD_INT 45
109405: PUSH
109406: EMPTY
109407: LIST
109408: LIST
109409: PUSH
109410: LD_INT 34
109412: PUSH
109413: LD_INT 28
109415: PUSH
109416: EMPTY
109417: LIST
109418: LIST
109419: PUSH
109420: LD_INT 34
109422: PUSH
109423: LD_INT 47
109425: PUSH
109426: EMPTY
109427: LIST
109428: LIST
109429: PUSH
109430: EMPTY
109431: LIST
109432: LIST
109433: LIST
109434: LIST
109435: LIST
109436: PUSH
109437: EMPTY
109438: LIST
109439: LIST
109440: PPUSH
109441: CALL_OW 69
109445: ST_TO_ADDR
// if not tmp then
109446: LD_VAR 0 2
109450: NOT
109451: IFFALSE 109455
// exit ;
109453: GO 109484
// for i in tmp do
109455: LD_ADDR_VAR 0 1
109459: PUSH
109460: LD_VAR 0 2
109464: PUSH
109465: FOR_IN
109466: IFFALSE 109482
// begin SetLives ( i , 0 ) ;
109468: LD_VAR 0 1
109472: PPUSH
109473: LD_INT 0
109475: PPUSH
109476: CALL_OW 234
// end ;
109480: GO 109465
109482: POP
109483: POP
// end ;
109484: PPOPN 2
109486: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
109487: LD_EXP 160
109491: PUSH
109492: LD_EXP 166
109496: AND
109497: IFFALSE 109581
109499: GO 109501
109501: DISABLE
109502: LD_INT 0
109504: PPUSH
109505: PPUSH
// begin enable ;
109506: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
109507: LD_ADDR_VAR 0 2
109511: PUSH
109512: LD_INT 22
109514: PUSH
109515: LD_OWVAR 2
109519: PUSH
109520: EMPTY
109521: LIST
109522: LIST
109523: PUSH
109524: LD_INT 32
109526: PUSH
109527: LD_INT 3
109529: PUSH
109530: EMPTY
109531: LIST
109532: LIST
109533: PUSH
109534: EMPTY
109535: LIST
109536: LIST
109537: PPUSH
109538: CALL_OW 69
109542: ST_TO_ADDR
// if not tmp then
109543: LD_VAR 0 2
109547: NOT
109548: IFFALSE 109552
// exit ;
109550: GO 109581
// for i in tmp do
109552: LD_ADDR_VAR 0 1
109556: PUSH
109557: LD_VAR 0 2
109561: PUSH
109562: FOR_IN
109563: IFFALSE 109579
// begin SetLives ( i , 0 ) ;
109565: LD_VAR 0 1
109569: PPUSH
109570: LD_INT 0
109572: PPUSH
109573: CALL_OW 234
// end ;
109577: GO 109562
109579: POP
109580: POP
// end ;
109581: PPOPN 2
109583: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
109584: LD_EXP 160
109588: PUSH
109589: LD_EXP 163
109593: AND
109594: IFFALSE 109687
109596: GO 109598
109598: DISABLE
109599: LD_INT 0
109601: PPUSH
// begin enable ;
109602: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
109603: LD_ADDR_VAR 0 1
109607: PUSH
109608: LD_INT 22
109610: PUSH
109611: LD_OWVAR 2
109615: PUSH
109616: EMPTY
109617: LIST
109618: LIST
109619: PUSH
109620: LD_INT 2
109622: PUSH
109623: LD_INT 25
109625: PUSH
109626: LD_INT 5
109628: PUSH
109629: EMPTY
109630: LIST
109631: LIST
109632: PUSH
109633: LD_INT 25
109635: PUSH
109636: LD_INT 9
109638: PUSH
109639: EMPTY
109640: LIST
109641: LIST
109642: PUSH
109643: LD_INT 25
109645: PUSH
109646: LD_INT 8
109648: PUSH
109649: EMPTY
109650: LIST
109651: LIST
109652: PUSH
109653: EMPTY
109654: LIST
109655: LIST
109656: LIST
109657: LIST
109658: PUSH
109659: EMPTY
109660: LIST
109661: LIST
109662: PPUSH
109663: CALL_OW 69
109667: PUSH
109668: FOR_IN
109669: IFFALSE 109685
// begin SetClass ( i , 1 ) ;
109671: LD_VAR 0 1
109675: PPUSH
109676: LD_INT 1
109678: PPUSH
109679: CALL_OW 336
// end ;
109683: GO 109668
109685: POP
109686: POP
// end ;
109687: PPOPN 1
109689: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
109690: LD_EXP 160
109694: PUSH
109695: LD_EXP 164
109699: AND
109700: PUSH
109701: LD_OWVAR 65
109705: PUSH
109706: LD_INT 7
109708: LESS
109709: AND
109710: IFFALSE 109724
109712: GO 109714
109714: DISABLE
// begin enable ;
109715: ENABLE
// game_speed := 7 ;
109716: LD_ADDR_OWVAR 65
109720: PUSH
109721: LD_INT 7
109723: ST_TO_ADDR
// end ;
109724: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
109725: LD_EXP 160
109729: PUSH
109730: LD_EXP 167
109734: AND
109735: IFFALSE 109937
109737: GO 109739
109739: DISABLE
109740: LD_INT 0
109742: PPUSH
109743: PPUSH
109744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
109745: LD_ADDR_VAR 0 3
109749: PUSH
109750: LD_INT 81
109752: PUSH
109753: LD_OWVAR 2
109757: PUSH
109758: EMPTY
109759: LIST
109760: LIST
109761: PUSH
109762: LD_INT 21
109764: PUSH
109765: LD_INT 1
109767: PUSH
109768: EMPTY
109769: LIST
109770: LIST
109771: PUSH
109772: EMPTY
109773: LIST
109774: LIST
109775: PPUSH
109776: CALL_OW 69
109780: ST_TO_ADDR
// if not tmp then
109781: LD_VAR 0 3
109785: NOT
109786: IFFALSE 109790
// exit ;
109788: GO 109937
// if tmp > 5 then
109790: LD_VAR 0 3
109794: PUSH
109795: LD_INT 5
109797: GREATER
109798: IFFALSE 109810
// k := 5 else
109800: LD_ADDR_VAR 0 2
109804: PUSH
109805: LD_INT 5
109807: ST_TO_ADDR
109808: GO 109820
// k := tmp ;
109810: LD_ADDR_VAR 0 2
109814: PUSH
109815: LD_VAR 0 3
109819: ST_TO_ADDR
// for i := 1 to k do
109820: LD_ADDR_VAR 0 1
109824: PUSH
109825: DOUBLE
109826: LD_INT 1
109828: DEC
109829: ST_TO_ADDR
109830: LD_VAR 0 2
109834: PUSH
109835: FOR_TO
109836: IFFALSE 109935
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
109838: LD_VAR 0 3
109842: PUSH
109843: LD_VAR 0 1
109847: ARRAY
109848: PPUSH
109849: LD_VAR 0 1
109853: PUSH
109854: LD_INT 4
109856: MOD
109857: PUSH
109858: LD_INT 1
109860: PLUS
109861: PPUSH
109862: CALL_OW 259
109866: PUSH
109867: LD_INT 10
109869: LESS
109870: IFFALSE 109933
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
109872: LD_VAR 0 3
109876: PUSH
109877: LD_VAR 0 1
109881: ARRAY
109882: PPUSH
109883: LD_VAR 0 1
109887: PUSH
109888: LD_INT 4
109890: MOD
109891: PUSH
109892: LD_INT 1
109894: PLUS
109895: PPUSH
109896: LD_VAR 0 3
109900: PUSH
109901: LD_VAR 0 1
109905: ARRAY
109906: PPUSH
109907: LD_VAR 0 1
109911: PUSH
109912: LD_INT 4
109914: MOD
109915: PUSH
109916: LD_INT 1
109918: PLUS
109919: PPUSH
109920: CALL_OW 259
109924: PUSH
109925: LD_INT 1
109927: PLUS
109928: PPUSH
109929: CALL_OW 237
109933: GO 109835
109935: POP
109936: POP
// end ;
109937: PPOPN 3
109939: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
109940: LD_EXP 160
109944: PUSH
109945: LD_EXP 168
109949: AND
109950: IFFALSE 109970
109952: GO 109954
109954: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
109955: LD_INT 4
109957: PPUSH
109958: LD_OWVAR 2
109962: PPUSH
109963: LD_INT 0
109965: PPUSH
109966: CALL_OW 324
109970: END
// every 0 0$1 trigger StreamModeActive and sShovel do
109971: LD_EXP 160
109975: PUSH
109976: LD_EXP 197
109980: AND
109981: IFFALSE 110001
109983: GO 109985
109985: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
109986: LD_INT 19
109988: PPUSH
109989: LD_OWVAR 2
109993: PPUSH
109994: LD_INT 0
109996: PPUSH
109997: CALL_OW 324
110001: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
110002: LD_EXP 160
110006: PUSH
110007: LD_EXP 169
110011: AND
110012: IFFALSE 110114
110014: GO 110016
110016: DISABLE
110017: LD_INT 0
110019: PPUSH
110020: PPUSH
// begin enable ;
110021: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
110022: LD_ADDR_VAR 0 2
110026: PUSH
110027: LD_INT 22
110029: PUSH
110030: LD_OWVAR 2
110034: PUSH
110035: EMPTY
110036: LIST
110037: LIST
110038: PUSH
110039: LD_INT 2
110041: PUSH
110042: LD_INT 34
110044: PUSH
110045: LD_INT 11
110047: PUSH
110048: EMPTY
110049: LIST
110050: LIST
110051: PUSH
110052: LD_INT 34
110054: PUSH
110055: LD_INT 30
110057: PUSH
110058: EMPTY
110059: LIST
110060: LIST
110061: PUSH
110062: EMPTY
110063: LIST
110064: LIST
110065: LIST
110066: PUSH
110067: EMPTY
110068: LIST
110069: LIST
110070: PPUSH
110071: CALL_OW 69
110075: ST_TO_ADDR
// if not tmp then
110076: LD_VAR 0 2
110080: NOT
110081: IFFALSE 110085
// exit ;
110083: GO 110114
// for i in tmp do
110085: LD_ADDR_VAR 0 1
110089: PUSH
110090: LD_VAR 0 2
110094: PUSH
110095: FOR_IN
110096: IFFALSE 110112
// begin SetLives ( i , 0 ) ;
110098: LD_VAR 0 1
110102: PPUSH
110103: LD_INT 0
110105: PPUSH
110106: CALL_OW 234
// end ;
110110: GO 110095
110112: POP
110113: POP
// end ;
110114: PPOPN 2
110116: END
// every 0 0$1 trigger StreamModeActive and sBunker do
110117: LD_EXP 160
110121: PUSH
110122: LD_EXP 170
110126: AND
110127: IFFALSE 110147
110129: GO 110131
110131: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
110132: LD_INT 32
110134: PPUSH
110135: LD_OWVAR 2
110139: PPUSH
110140: LD_INT 0
110142: PPUSH
110143: CALL_OW 324
110147: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
110148: LD_EXP 160
110152: PUSH
110153: LD_EXP 171
110157: AND
110158: IFFALSE 110339
110160: GO 110162
110162: DISABLE
110163: LD_INT 0
110165: PPUSH
110166: PPUSH
110167: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
110168: LD_ADDR_VAR 0 2
110172: PUSH
110173: LD_INT 22
110175: PUSH
110176: LD_OWVAR 2
110180: PUSH
110181: EMPTY
110182: LIST
110183: LIST
110184: PUSH
110185: LD_INT 33
110187: PUSH
110188: LD_INT 3
110190: PUSH
110191: EMPTY
110192: LIST
110193: LIST
110194: PUSH
110195: EMPTY
110196: LIST
110197: LIST
110198: PPUSH
110199: CALL_OW 69
110203: ST_TO_ADDR
// if not tmp then
110204: LD_VAR 0 2
110208: NOT
110209: IFFALSE 110213
// exit ;
110211: GO 110339
// side := 0 ;
110213: LD_ADDR_VAR 0 3
110217: PUSH
110218: LD_INT 0
110220: ST_TO_ADDR
// for i := 1 to 8 do
110221: LD_ADDR_VAR 0 1
110225: PUSH
110226: DOUBLE
110227: LD_INT 1
110229: DEC
110230: ST_TO_ADDR
110231: LD_INT 8
110233: PUSH
110234: FOR_TO
110235: IFFALSE 110283
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
110237: LD_OWVAR 2
110241: PUSH
110242: LD_VAR 0 1
110246: NONEQUAL
110247: PUSH
110248: LD_OWVAR 2
110252: PPUSH
110253: LD_VAR 0 1
110257: PPUSH
110258: CALL_OW 81
110262: PUSH
110263: LD_INT 2
110265: EQUAL
110266: AND
110267: IFFALSE 110281
// begin side := i ;
110269: LD_ADDR_VAR 0 3
110273: PUSH
110274: LD_VAR 0 1
110278: ST_TO_ADDR
// break ;
110279: GO 110283
// end ;
110281: GO 110234
110283: POP
110284: POP
// if not side then
110285: LD_VAR 0 3
110289: NOT
110290: IFFALSE 110294
// exit ;
110292: GO 110339
// for i := 1 to tmp do
110294: LD_ADDR_VAR 0 1
110298: PUSH
110299: DOUBLE
110300: LD_INT 1
110302: DEC
110303: ST_TO_ADDR
110304: LD_VAR 0 2
110308: PUSH
110309: FOR_TO
110310: IFFALSE 110337
// if Prob ( 60 ) then
110312: LD_INT 60
110314: PPUSH
110315: CALL_OW 13
110319: IFFALSE 110335
// SetSide ( i , side ) ;
110321: LD_VAR 0 1
110325: PPUSH
110326: LD_VAR 0 3
110330: PPUSH
110331: CALL_OW 235
110335: GO 110309
110337: POP
110338: POP
// end ;
110339: PPOPN 3
110341: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
110342: LD_EXP 160
110346: PUSH
110347: LD_EXP 173
110351: AND
110352: IFFALSE 110471
110354: GO 110356
110356: DISABLE
110357: LD_INT 0
110359: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
110360: LD_ADDR_VAR 0 1
110364: PUSH
110365: LD_INT 22
110367: PUSH
110368: LD_OWVAR 2
110372: PUSH
110373: EMPTY
110374: LIST
110375: LIST
110376: PUSH
110377: LD_INT 21
110379: PUSH
110380: LD_INT 1
110382: PUSH
110383: EMPTY
110384: LIST
110385: LIST
110386: PUSH
110387: LD_INT 3
110389: PUSH
110390: LD_INT 23
110392: PUSH
110393: LD_INT 0
110395: PUSH
110396: EMPTY
110397: LIST
110398: LIST
110399: PUSH
110400: EMPTY
110401: LIST
110402: LIST
110403: PUSH
110404: EMPTY
110405: LIST
110406: LIST
110407: LIST
110408: PPUSH
110409: CALL_OW 69
110413: PUSH
110414: FOR_IN
110415: IFFALSE 110469
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
110417: LD_VAR 0 1
110421: PPUSH
110422: CALL_OW 257
110426: PUSH
110427: LD_INT 1
110429: PUSH
110430: LD_INT 2
110432: PUSH
110433: LD_INT 3
110435: PUSH
110436: LD_INT 4
110438: PUSH
110439: EMPTY
110440: LIST
110441: LIST
110442: LIST
110443: LIST
110444: IN
110445: IFFALSE 110467
// SetClass ( un , rand ( 1 , 4 ) ) ;
110447: LD_VAR 0 1
110451: PPUSH
110452: LD_INT 1
110454: PPUSH
110455: LD_INT 4
110457: PPUSH
110458: CALL_OW 12
110462: PPUSH
110463: CALL_OW 336
110467: GO 110414
110469: POP
110470: POP
// end ;
110471: PPOPN 1
110473: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
110474: LD_EXP 160
110478: PUSH
110479: LD_EXP 172
110483: AND
110484: IFFALSE 110563
110486: GO 110488
110488: DISABLE
110489: LD_INT 0
110491: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
110492: LD_ADDR_VAR 0 1
110496: PUSH
110497: LD_INT 22
110499: PUSH
110500: LD_OWVAR 2
110504: PUSH
110505: EMPTY
110506: LIST
110507: LIST
110508: PUSH
110509: LD_INT 21
110511: PUSH
110512: LD_INT 3
110514: PUSH
110515: EMPTY
110516: LIST
110517: LIST
110518: PUSH
110519: EMPTY
110520: LIST
110521: LIST
110522: PPUSH
110523: CALL_OW 69
110527: ST_TO_ADDR
// if not tmp then
110528: LD_VAR 0 1
110532: NOT
110533: IFFALSE 110537
// exit ;
110535: GO 110563
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
110537: LD_VAR 0 1
110541: PUSH
110542: LD_INT 1
110544: PPUSH
110545: LD_VAR 0 1
110549: PPUSH
110550: CALL_OW 12
110554: ARRAY
110555: PPUSH
110556: LD_INT 100
110558: PPUSH
110559: CALL_OW 234
// end ;
110563: PPOPN 1
110565: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
110566: LD_EXP 160
110570: PUSH
110571: LD_EXP 174
110575: AND
110576: IFFALSE 110674
110578: GO 110580
110580: DISABLE
110581: LD_INT 0
110583: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110584: LD_ADDR_VAR 0 1
110588: PUSH
110589: LD_INT 22
110591: PUSH
110592: LD_OWVAR 2
110596: PUSH
110597: EMPTY
110598: LIST
110599: LIST
110600: PUSH
110601: LD_INT 21
110603: PUSH
110604: LD_INT 1
110606: PUSH
110607: EMPTY
110608: LIST
110609: LIST
110610: PUSH
110611: EMPTY
110612: LIST
110613: LIST
110614: PPUSH
110615: CALL_OW 69
110619: ST_TO_ADDR
// if not tmp then
110620: LD_VAR 0 1
110624: NOT
110625: IFFALSE 110629
// exit ;
110627: GO 110674
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
110629: LD_VAR 0 1
110633: PUSH
110634: LD_INT 1
110636: PPUSH
110637: LD_VAR 0 1
110641: PPUSH
110642: CALL_OW 12
110646: ARRAY
110647: PPUSH
110648: LD_INT 1
110650: PPUSH
110651: LD_INT 4
110653: PPUSH
110654: CALL_OW 12
110658: PPUSH
110659: LD_INT 3000
110661: PPUSH
110662: LD_INT 9000
110664: PPUSH
110665: CALL_OW 12
110669: PPUSH
110670: CALL_OW 492
// end ;
110674: PPOPN 1
110676: END
// every 0 0$1 trigger StreamModeActive and sDepot do
110677: LD_EXP 160
110681: PUSH
110682: LD_EXP 175
110686: AND
110687: IFFALSE 110707
110689: GO 110691
110691: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
110692: LD_INT 1
110694: PPUSH
110695: LD_OWVAR 2
110699: PPUSH
110700: LD_INT 0
110702: PPUSH
110703: CALL_OW 324
110707: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
110708: LD_EXP 160
110712: PUSH
110713: LD_EXP 176
110717: AND
110718: IFFALSE 110801
110720: GO 110722
110722: DISABLE
110723: LD_INT 0
110725: PPUSH
110726: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
110727: LD_ADDR_VAR 0 2
110731: PUSH
110732: LD_INT 22
110734: PUSH
110735: LD_OWVAR 2
110739: PUSH
110740: EMPTY
110741: LIST
110742: LIST
110743: PUSH
110744: LD_INT 21
110746: PUSH
110747: LD_INT 3
110749: PUSH
110750: EMPTY
110751: LIST
110752: LIST
110753: PUSH
110754: EMPTY
110755: LIST
110756: LIST
110757: PPUSH
110758: CALL_OW 69
110762: ST_TO_ADDR
// if not tmp then
110763: LD_VAR 0 2
110767: NOT
110768: IFFALSE 110772
// exit ;
110770: GO 110801
// for i in tmp do
110772: LD_ADDR_VAR 0 1
110776: PUSH
110777: LD_VAR 0 2
110781: PUSH
110782: FOR_IN
110783: IFFALSE 110799
// SetBLevel ( i , 10 ) ;
110785: LD_VAR 0 1
110789: PPUSH
110790: LD_INT 10
110792: PPUSH
110793: CALL_OW 241
110797: GO 110782
110799: POP
110800: POP
// end ;
110801: PPOPN 2
110803: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
110804: LD_EXP 160
110808: PUSH
110809: LD_EXP 177
110813: AND
110814: IFFALSE 110925
110816: GO 110818
110818: DISABLE
110819: LD_INT 0
110821: PPUSH
110822: PPUSH
110823: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110824: LD_ADDR_VAR 0 3
110828: PUSH
110829: LD_INT 22
110831: PUSH
110832: LD_OWVAR 2
110836: PUSH
110837: EMPTY
110838: LIST
110839: LIST
110840: PUSH
110841: LD_INT 25
110843: PUSH
110844: LD_INT 1
110846: PUSH
110847: EMPTY
110848: LIST
110849: LIST
110850: PUSH
110851: EMPTY
110852: LIST
110853: LIST
110854: PPUSH
110855: CALL_OW 69
110859: ST_TO_ADDR
// if not tmp then
110860: LD_VAR 0 3
110864: NOT
110865: IFFALSE 110869
// exit ;
110867: GO 110925
// un := tmp [ rand ( 1 , tmp ) ] ;
110869: LD_ADDR_VAR 0 2
110873: PUSH
110874: LD_VAR 0 3
110878: PUSH
110879: LD_INT 1
110881: PPUSH
110882: LD_VAR 0 3
110886: PPUSH
110887: CALL_OW 12
110891: ARRAY
110892: ST_TO_ADDR
// if Crawls ( un ) then
110893: LD_VAR 0 2
110897: PPUSH
110898: CALL_OW 318
110902: IFFALSE 110913
// ComWalk ( un ) ;
110904: LD_VAR 0 2
110908: PPUSH
110909: CALL_OW 138
// SetClass ( un , class_sniper ) ;
110913: LD_VAR 0 2
110917: PPUSH
110918: LD_INT 5
110920: PPUSH
110921: CALL_OW 336
// end ;
110925: PPOPN 3
110927: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
110928: LD_EXP 160
110932: PUSH
110933: LD_EXP 178
110937: AND
110938: PUSH
110939: LD_OWVAR 67
110943: PUSH
110944: LD_INT 3
110946: LESS
110947: AND
110948: IFFALSE 110967
110950: GO 110952
110952: DISABLE
// Difficulty := Difficulty + 1 ;
110953: LD_ADDR_OWVAR 67
110957: PUSH
110958: LD_OWVAR 67
110962: PUSH
110963: LD_INT 1
110965: PLUS
110966: ST_TO_ADDR
110967: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
110968: LD_EXP 160
110972: PUSH
110973: LD_EXP 179
110977: AND
110978: IFFALSE 111081
110980: GO 110982
110982: DISABLE
110983: LD_INT 0
110985: PPUSH
// begin for i := 1 to 5 do
110986: LD_ADDR_VAR 0 1
110990: PUSH
110991: DOUBLE
110992: LD_INT 1
110994: DEC
110995: ST_TO_ADDR
110996: LD_INT 5
110998: PUSH
110999: FOR_TO
111000: IFFALSE 111079
// begin uc_nation := nation_nature ;
111002: LD_ADDR_OWVAR 21
111006: PUSH
111007: LD_INT 0
111009: ST_TO_ADDR
// uc_side := 0 ;
111010: LD_ADDR_OWVAR 20
111014: PUSH
111015: LD_INT 0
111017: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
111018: LD_ADDR_OWVAR 29
111022: PUSH
111023: LD_INT 12
111025: PUSH
111026: LD_INT 12
111028: PUSH
111029: EMPTY
111030: LIST
111031: LIST
111032: ST_TO_ADDR
// hc_agressivity := 20 ;
111033: LD_ADDR_OWVAR 35
111037: PUSH
111038: LD_INT 20
111040: ST_TO_ADDR
// hc_class := class_tiger ;
111041: LD_ADDR_OWVAR 28
111045: PUSH
111046: LD_INT 14
111048: ST_TO_ADDR
// hc_gallery :=  ;
111049: LD_ADDR_OWVAR 33
111053: PUSH
111054: LD_STRING 
111056: ST_TO_ADDR
// hc_name :=  ;
111057: LD_ADDR_OWVAR 26
111061: PUSH
111062: LD_STRING 
111064: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
111065: CALL_OW 44
111069: PPUSH
111070: LD_INT 0
111072: PPUSH
111073: CALL_OW 51
// end ;
111077: GO 110999
111079: POP
111080: POP
// end ;
111081: PPOPN 1
111083: END
// every 0 0$1 trigger StreamModeActive and sBomb do
111084: LD_EXP 160
111088: PUSH
111089: LD_EXP 180
111093: AND
111094: IFFALSE 111103
111096: GO 111098
111098: DISABLE
// StreamSibBomb ;
111099: CALL 111104 0 0
111103: END
// export function StreamSibBomb ; var i , x , y ; begin
111104: LD_INT 0
111106: PPUSH
111107: PPUSH
111108: PPUSH
111109: PPUSH
// result := false ;
111110: LD_ADDR_VAR 0 1
111114: PUSH
111115: LD_INT 0
111117: ST_TO_ADDR
// for i := 1 to 16 do
111118: LD_ADDR_VAR 0 2
111122: PUSH
111123: DOUBLE
111124: LD_INT 1
111126: DEC
111127: ST_TO_ADDR
111128: LD_INT 16
111130: PUSH
111131: FOR_TO
111132: IFFALSE 111331
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
111134: LD_ADDR_VAR 0 3
111138: PUSH
111139: LD_INT 10
111141: PUSH
111142: LD_INT 20
111144: PUSH
111145: LD_INT 30
111147: PUSH
111148: LD_INT 40
111150: PUSH
111151: LD_INT 50
111153: PUSH
111154: LD_INT 60
111156: PUSH
111157: LD_INT 70
111159: PUSH
111160: LD_INT 80
111162: PUSH
111163: LD_INT 90
111165: PUSH
111166: LD_INT 100
111168: PUSH
111169: LD_INT 110
111171: PUSH
111172: LD_INT 120
111174: PUSH
111175: LD_INT 130
111177: PUSH
111178: LD_INT 140
111180: PUSH
111181: LD_INT 150
111183: PUSH
111184: EMPTY
111185: LIST
111186: LIST
111187: LIST
111188: LIST
111189: LIST
111190: LIST
111191: LIST
111192: LIST
111193: LIST
111194: LIST
111195: LIST
111196: LIST
111197: LIST
111198: LIST
111199: LIST
111200: PUSH
111201: LD_INT 1
111203: PPUSH
111204: LD_INT 15
111206: PPUSH
111207: CALL_OW 12
111211: ARRAY
111212: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
111213: LD_ADDR_VAR 0 4
111217: PUSH
111218: LD_INT 10
111220: PUSH
111221: LD_INT 20
111223: PUSH
111224: LD_INT 30
111226: PUSH
111227: LD_INT 40
111229: PUSH
111230: LD_INT 50
111232: PUSH
111233: LD_INT 60
111235: PUSH
111236: LD_INT 70
111238: PUSH
111239: LD_INT 80
111241: PUSH
111242: LD_INT 90
111244: PUSH
111245: LD_INT 100
111247: PUSH
111248: LD_INT 110
111250: PUSH
111251: LD_INT 120
111253: PUSH
111254: LD_INT 130
111256: PUSH
111257: LD_INT 140
111259: PUSH
111260: LD_INT 150
111262: PUSH
111263: EMPTY
111264: LIST
111265: LIST
111266: LIST
111267: LIST
111268: LIST
111269: LIST
111270: LIST
111271: LIST
111272: LIST
111273: LIST
111274: LIST
111275: LIST
111276: LIST
111277: LIST
111278: LIST
111279: PUSH
111280: LD_INT 1
111282: PPUSH
111283: LD_INT 15
111285: PPUSH
111286: CALL_OW 12
111290: ARRAY
111291: ST_TO_ADDR
// if ValidHex ( x , y ) then
111292: LD_VAR 0 3
111296: PPUSH
111297: LD_VAR 0 4
111301: PPUSH
111302: CALL_OW 488
111306: IFFALSE 111329
// begin result := [ x , y ] ;
111308: LD_ADDR_VAR 0 1
111312: PUSH
111313: LD_VAR 0 3
111317: PUSH
111318: LD_VAR 0 4
111322: PUSH
111323: EMPTY
111324: LIST
111325: LIST
111326: ST_TO_ADDR
// break ;
111327: GO 111331
// end ; end ;
111329: GO 111131
111331: POP
111332: POP
// if result then
111333: LD_VAR 0 1
111337: IFFALSE 111397
// begin ToLua ( playSibBomb() ) ;
111339: LD_STRING playSibBomb()
111341: PPUSH
111342: CALL_OW 559
// wait ( 0 0$14 ) ;
111346: LD_INT 490
111348: PPUSH
111349: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
111353: LD_VAR 0 1
111357: PUSH
111358: LD_INT 1
111360: ARRAY
111361: PPUSH
111362: LD_VAR 0 1
111366: PUSH
111367: LD_INT 2
111369: ARRAY
111370: PPUSH
111371: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
111375: LD_VAR 0 1
111379: PUSH
111380: LD_INT 1
111382: ARRAY
111383: PPUSH
111384: LD_VAR 0 1
111388: PUSH
111389: LD_INT 2
111391: ARRAY
111392: PPUSH
111393: CALL_OW 429
// end ; end ;
111397: LD_VAR 0 1
111401: RET
// every 0 0$1 trigger StreamModeActive and sReset do
111402: LD_EXP 160
111406: PUSH
111407: LD_EXP 182
111411: AND
111412: IFFALSE 111424
111414: GO 111416
111416: DISABLE
// YouLost (  ) ;
111417: LD_STRING 
111419: PPUSH
111420: CALL_OW 104
111424: END
// every 0 0$1 trigger StreamModeActive and sFog do
111425: LD_EXP 160
111429: PUSH
111430: LD_EXP 181
111434: AND
111435: IFFALSE 111449
111437: GO 111439
111439: DISABLE
// FogOff ( your_side ) ;
111440: LD_OWVAR 2
111444: PPUSH
111445: CALL_OW 344
111449: END
// every 0 0$1 trigger StreamModeActive and sSun do
111450: LD_EXP 160
111454: PUSH
111455: LD_EXP 183
111459: AND
111460: IFFALSE 111488
111462: GO 111464
111464: DISABLE
// begin solar_recharge_percent := 0 ;
111465: LD_ADDR_OWVAR 79
111469: PUSH
111470: LD_INT 0
111472: ST_TO_ADDR
// wait ( 5 5$00 ) ;
111473: LD_INT 10500
111475: PPUSH
111476: CALL_OW 67
// solar_recharge_percent := 100 ;
111480: LD_ADDR_OWVAR 79
111484: PUSH
111485: LD_INT 100
111487: ST_TO_ADDR
// end ;
111488: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
111489: LD_EXP 160
111493: PUSH
111494: LD_EXP 184
111498: AND
111499: IFFALSE 111738
111501: GO 111503
111503: DISABLE
111504: LD_INT 0
111506: PPUSH
111507: PPUSH
111508: PPUSH
// begin tmp := [ ] ;
111509: LD_ADDR_VAR 0 3
111513: PUSH
111514: EMPTY
111515: ST_TO_ADDR
// for i := 1 to 6 do
111516: LD_ADDR_VAR 0 1
111520: PUSH
111521: DOUBLE
111522: LD_INT 1
111524: DEC
111525: ST_TO_ADDR
111526: LD_INT 6
111528: PUSH
111529: FOR_TO
111530: IFFALSE 111635
// begin uc_nation := nation_nature ;
111532: LD_ADDR_OWVAR 21
111536: PUSH
111537: LD_INT 0
111539: ST_TO_ADDR
// uc_side := 0 ;
111540: LD_ADDR_OWVAR 20
111544: PUSH
111545: LD_INT 0
111547: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
111548: LD_ADDR_OWVAR 29
111552: PUSH
111553: LD_INT 12
111555: PUSH
111556: LD_INT 12
111558: PUSH
111559: EMPTY
111560: LIST
111561: LIST
111562: ST_TO_ADDR
// hc_agressivity := 20 ;
111563: LD_ADDR_OWVAR 35
111567: PUSH
111568: LD_INT 20
111570: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
111571: LD_ADDR_OWVAR 28
111575: PUSH
111576: LD_INT 17
111578: ST_TO_ADDR
// hc_gallery :=  ;
111579: LD_ADDR_OWVAR 33
111583: PUSH
111584: LD_STRING 
111586: ST_TO_ADDR
// hc_name :=  ;
111587: LD_ADDR_OWVAR 26
111591: PUSH
111592: LD_STRING 
111594: ST_TO_ADDR
// un := CreateHuman ;
111595: LD_ADDR_VAR 0 2
111599: PUSH
111600: CALL_OW 44
111604: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
111605: LD_VAR 0 2
111609: PPUSH
111610: LD_INT 1
111612: PPUSH
111613: CALL_OW 51
// tmp := tmp ^ un ;
111617: LD_ADDR_VAR 0 3
111621: PUSH
111622: LD_VAR 0 3
111626: PUSH
111627: LD_VAR 0 2
111631: ADD
111632: ST_TO_ADDR
// end ;
111633: GO 111529
111635: POP
111636: POP
// repeat wait ( 0 0$1 ) ;
111637: LD_INT 35
111639: PPUSH
111640: CALL_OW 67
// for un in tmp do
111644: LD_ADDR_VAR 0 2
111648: PUSH
111649: LD_VAR 0 3
111653: PUSH
111654: FOR_IN
111655: IFFALSE 111729
// begin if IsDead ( un ) then
111657: LD_VAR 0 2
111661: PPUSH
111662: CALL_OW 301
111666: IFFALSE 111686
// begin tmp := tmp diff un ;
111668: LD_ADDR_VAR 0 3
111672: PUSH
111673: LD_VAR 0 3
111677: PUSH
111678: LD_VAR 0 2
111682: DIFF
111683: ST_TO_ADDR
// continue ;
111684: GO 111654
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
111686: LD_VAR 0 2
111690: PPUSH
111691: LD_INT 3
111693: PUSH
111694: LD_INT 22
111696: PUSH
111697: LD_INT 0
111699: PUSH
111700: EMPTY
111701: LIST
111702: LIST
111703: PUSH
111704: EMPTY
111705: LIST
111706: LIST
111707: PPUSH
111708: CALL_OW 69
111712: PPUSH
111713: LD_VAR 0 2
111717: PPUSH
111718: CALL_OW 74
111722: PPUSH
111723: CALL_OW 115
// end ;
111727: GO 111654
111729: POP
111730: POP
// until not tmp ;
111731: LD_VAR 0 3
111735: NOT
111736: IFFALSE 111637
// end ;
111738: PPOPN 3
111740: END
// every 0 0$1 trigger StreamModeActive and sTroll do
111741: LD_EXP 160
111745: PUSH
111746: LD_EXP 185
111750: AND
111751: IFFALSE 111805
111753: GO 111755
111755: DISABLE
// begin ToLua ( displayTroll(); ) ;
111756: LD_STRING displayTroll();
111758: PPUSH
111759: CALL_OW 559
// wait ( 3 3$00 ) ;
111763: LD_INT 6300
111765: PPUSH
111766: CALL_OW 67
// ToLua ( hideTroll(); ) ;
111770: LD_STRING hideTroll();
111772: PPUSH
111773: CALL_OW 559
// wait ( 1 1$00 ) ;
111777: LD_INT 2100
111779: PPUSH
111780: CALL_OW 67
// ToLua ( displayTroll(); ) ;
111784: LD_STRING displayTroll();
111786: PPUSH
111787: CALL_OW 559
// wait ( 1 1$00 ) ;
111791: LD_INT 2100
111793: PPUSH
111794: CALL_OW 67
// ToLua ( hideTroll(); ) ;
111798: LD_STRING hideTroll();
111800: PPUSH
111801: CALL_OW 559
// end ;
111805: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
111806: LD_EXP 160
111810: PUSH
111811: LD_EXP 186
111815: AND
111816: IFFALSE 111879
111818: GO 111820
111820: DISABLE
111821: LD_INT 0
111823: PPUSH
// begin p := 0 ;
111824: LD_ADDR_VAR 0 1
111828: PUSH
111829: LD_INT 0
111831: ST_TO_ADDR
// repeat game_speed := 1 ;
111832: LD_ADDR_OWVAR 65
111836: PUSH
111837: LD_INT 1
111839: ST_TO_ADDR
// wait ( 0 0$1 ) ;
111840: LD_INT 35
111842: PPUSH
111843: CALL_OW 67
// p := p + 1 ;
111847: LD_ADDR_VAR 0 1
111851: PUSH
111852: LD_VAR 0 1
111856: PUSH
111857: LD_INT 1
111859: PLUS
111860: ST_TO_ADDR
// until p >= 60 ;
111861: LD_VAR 0 1
111865: PUSH
111866: LD_INT 60
111868: GREATEREQUAL
111869: IFFALSE 111832
// game_speed := 4 ;
111871: LD_ADDR_OWVAR 65
111875: PUSH
111876: LD_INT 4
111878: ST_TO_ADDR
// end ;
111879: PPOPN 1
111881: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
111882: LD_EXP 160
111886: PUSH
111887: LD_EXP 187
111891: AND
111892: IFFALSE 112038
111894: GO 111896
111896: DISABLE
111897: LD_INT 0
111899: PPUSH
111900: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
111901: LD_ADDR_VAR 0 1
111905: PUSH
111906: LD_INT 22
111908: PUSH
111909: LD_OWVAR 2
111913: PUSH
111914: EMPTY
111915: LIST
111916: LIST
111917: PUSH
111918: LD_INT 2
111920: PUSH
111921: LD_INT 30
111923: PUSH
111924: LD_INT 0
111926: PUSH
111927: EMPTY
111928: LIST
111929: LIST
111930: PUSH
111931: LD_INT 30
111933: PUSH
111934: LD_INT 1
111936: PUSH
111937: EMPTY
111938: LIST
111939: LIST
111940: PUSH
111941: EMPTY
111942: LIST
111943: LIST
111944: LIST
111945: PUSH
111946: EMPTY
111947: LIST
111948: LIST
111949: PPUSH
111950: CALL_OW 69
111954: ST_TO_ADDR
// if not depot then
111955: LD_VAR 0 1
111959: NOT
111960: IFFALSE 111964
// exit ;
111962: GO 112038
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
111964: LD_ADDR_VAR 0 2
111968: PUSH
111969: LD_VAR 0 1
111973: PUSH
111974: LD_INT 1
111976: PPUSH
111977: LD_VAR 0 1
111981: PPUSH
111982: CALL_OW 12
111986: ARRAY
111987: PPUSH
111988: CALL_OW 274
111992: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
111993: LD_VAR 0 2
111997: PPUSH
111998: LD_INT 1
112000: PPUSH
112001: LD_INT 0
112003: PPUSH
112004: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
112008: LD_VAR 0 2
112012: PPUSH
112013: LD_INT 2
112015: PPUSH
112016: LD_INT 0
112018: PPUSH
112019: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
112023: LD_VAR 0 2
112027: PPUSH
112028: LD_INT 3
112030: PPUSH
112031: LD_INT 0
112033: PPUSH
112034: CALL_OW 277
// end ;
112038: PPOPN 2
112040: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
112041: LD_EXP 160
112045: PUSH
112046: LD_EXP 188
112050: AND
112051: IFFALSE 112148
112053: GO 112055
112055: DISABLE
112056: LD_INT 0
112058: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112059: LD_ADDR_VAR 0 1
112063: PUSH
112064: LD_INT 22
112066: PUSH
112067: LD_OWVAR 2
112071: PUSH
112072: EMPTY
112073: LIST
112074: LIST
112075: PUSH
112076: LD_INT 21
112078: PUSH
112079: LD_INT 1
112081: PUSH
112082: EMPTY
112083: LIST
112084: LIST
112085: PUSH
112086: LD_INT 3
112088: PUSH
112089: LD_INT 23
112091: PUSH
112092: LD_INT 0
112094: PUSH
112095: EMPTY
112096: LIST
112097: LIST
112098: PUSH
112099: EMPTY
112100: LIST
112101: LIST
112102: PUSH
112103: EMPTY
112104: LIST
112105: LIST
112106: LIST
112107: PPUSH
112108: CALL_OW 69
112112: ST_TO_ADDR
// if not tmp then
112113: LD_VAR 0 1
112117: NOT
112118: IFFALSE 112122
// exit ;
112120: GO 112148
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
112122: LD_VAR 0 1
112126: PUSH
112127: LD_INT 1
112129: PPUSH
112130: LD_VAR 0 1
112134: PPUSH
112135: CALL_OW 12
112139: ARRAY
112140: PPUSH
112141: LD_INT 200
112143: PPUSH
112144: CALL_OW 234
// end ;
112148: PPOPN 1
112150: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
112151: LD_EXP 160
112155: PUSH
112156: LD_EXP 189
112160: AND
112161: IFFALSE 112240
112163: GO 112165
112165: DISABLE
112166: LD_INT 0
112168: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
112169: LD_ADDR_VAR 0 1
112173: PUSH
112174: LD_INT 22
112176: PUSH
112177: LD_OWVAR 2
112181: PUSH
112182: EMPTY
112183: LIST
112184: LIST
112185: PUSH
112186: LD_INT 21
112188: PUSH
112189: LD_INT 2
112191: PUSH
112192: EMPTY
112193: LIST
112194: LIST
112195: PUSH
112196: EMPTY
112197: LIST
112198: LIST
112199: PPUSH
112200: CALL_OW 69
112204: ST_TO_ADDR
// if not tmp then
112205: LD_VAR 0 1
112209: NOT
112210: IFFALSE 112214
// exit ;
112212: GO 112240
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
112214: LD_VAR 0 1
112218: PUSH
112219: LD_INT 1
112221: PPUSH
112222: LD_VAR 0 1
112226: PPUSH
112227: CALL_OW 12
112231: ARRAY
112232: PPUSH
112233: LD_INT 60
112235: PPUSH
112236: CALL_OW 234
// end ;
112240: PPOPN 1
112242: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
112243: LD_EXP 160
112247: PUSH
112248: LD_EXP 190
112252: AND
112253: IFFALSE 112352
112255: GO 112257
112257: DISABLE
112258: LD_INT 0
112260: PPUSH
112261: PPUSH
// begin enable ;
112262: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
112263: LD_ADDR_VAR 0 1
112267: PUSH
112268: LD_INT 22
112270: PUSH
112271: LD_OWVAR 2
112275: PUSH
112276: EMPTY
112277: LIST
112278: LIST
112279: PUSH
112280: LD_INT 61
112282: PUSH
112283: EMPTY
112284: LIST
112285: PUSH
112286: LD_INT 33
112288: PUSH
112289: LD_INT 2
112291: PUSH
112292: EMPTY
112293: LIST
112294: LIST
112295: PUSH
112296: EMPTY
112297: LIST
112298: LIST
112299: LIST
112300: PPUSH
112301: CALL_OW 69
112305: ST_TO_ADDR
// if not tmp then
112306: LD_VAR 0 1
112310: NOT
112311: IFFALSE 112315
// exit ;
112313: GO 112352
// for i in tmp do
112315: LD_ADDR_VAR 0 2
112319: PUSH
112320: LD_VAR 0 1
112324: PUSH
112325: FOR_IN
112326: IFFALSE 112350
// if IsControledBy ( i ) then
112328: LD_VAR 0 2
112332: PPUSH
112333: CALL_OW 312
112337: IFFALSE 112348
// ComUnlink ( i ) ;
112339: LD_VAR 0 2
112343: PPUSH
112344: CALL_OW 136
112348: GO 112325
112350: POP
112351: POP
// end ;
112352: PPOPN 2
112354: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
112355: LD_EXP 160
112359: PUSH
112360: LD_EXP 191
112364: AND
112365: IFFALSE 112505
112367: GO 112369
112369: DISABLE
112370: LD_INT 0
112372: PPUSH
112373: PPUSH
// begin ToLua ( displayPowell(); ) ;
112374: LD_STRING displayPowell();
112376: PPUSH
112377: CALL_OW 559
// uc_side := 0 ;
112381: LD_ADDR_OWVAR 20
112385: PUSH
112386: LD_INT 0
112388: ST_TO_ADDR
// uc_nation := 2 ;
112389: LD_ADDR_OWVAR 21
112393: PUSH
112394: LD_INT 2
112396: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
112397: LD_ADDR_OWVAR 37
112401: PUSH
112402: LD_INT 14
112404: ST_TO_ADDR
// vc_engine := engine_siberite ;
112405: LD_ADDR_OWVAR 39
112409: PUSH
112410: LD_INT 3
112412: ST_TO_ADDR
// vc_control := control_apeman ;
112413: LD_ADDR_OWVAR 38
112417: PUSH
112418: LD_INT 5
112420: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
112421: LD_ADDR_OWVAR 40
112425: PUSH
112426: LD_INT 29
112428: ST_TO_ADDR
// un := CreateVehicle ;
112429: LD_ADDR_VAR 0 2
112433: PUSH
112434: CALL_OW 45
112438: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112439: LD_VAR 0 2
112443: PPUSH
112444: LD_INT 1
112446: PPUSH
112447: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
112451: LD_INT 35
112453: PPUSH
112454: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
112458: LD_VAR 0 2
112462: PPUSH
112463: LD_INT 22
112465: PUSH
112466: LD_OWVAR 2
112470: PUSH
112471: EMPTY
112472: LIST
112473: LIST
112474: PPUSH
112475: CALL_OW 69
112479: PPUSH
112480: LD_VAR 0 2
112484: PPUSH
112485: CALL_OW 74
112489: PPUSH
112490: CALL_OW 115
// until IsDead ( un ) ;
112494: LD_VAR 0 2
112498: PPUSH
112499: CALL_OW 301
112503: IFFALSE 112451
// end ;
112505: PPOPN 2
112507: END
// every 0 0$1 trigger StreamModeActive and sStu do
112508: LD_EXP 160
112512: PUSH
112513: LD_EXP 199
112517: AND
112518: IFFALSE 112534
112520: GO 112522
112522: DISABLE
// begin ToLua ( displayStucuk(); ) ;
112523: LD_STRING displayStucuk();
112525: PPUSH
112526: CALL_OW 559
// ResetFog ;
112530: CALL_OW 335
// end ;
112534: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
112535: LD_EXP 160
112539: PUSH
112540: LD_EXP 192
112544: AND
112545: IFFALSE 112686
112547: GO 112549
112549: DISABLE
112550: LD_INT 0
112552: PPUSH
112553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
112554: LD_ADDR_VAR 0 2
112558: PUSH
112559: LD_INT 22
112561: PUSH
112562: LD_OWVAR 2
112566: PUSH
112567: EMPTY
112568: LIST
112569: LIST
112570: PUSH
112571: LD_INT 21
112573: PUSH
112574: LD_INT 1
112576: PUSH
112577: EMPTY
112578: LIST
112579: LIST
112580: PUSH
112581: EMPTY
112582: LIST
112583: LIST
112584: PPUSH
112585: CALL_OW 69
112589: ST_TO_ADDR
// if not tmp then
112590: LD_VAR 0 2
112594: NOT
112595: IFFALSE 112599
// exit ;
112597: GO 112686
// un := tmp [ rand ( 1 , tmp ) ] ;
112599: LD_ADDR_VAR 0 1
112603: PUSH
112604: LD_VAR 0 2
112608: PUSH
112609: LD_INT 1
112611: PPUSH
112612: LD_VAR 0 2
112616: PPUSH
112617: CALL_OW 12
112621: ARRAY
112622: ST_TO_ADDR
// SetSide ( un , 0 ) ;
112623: LD_VAR 0 1
112627: PPUSH
112628: LD_INT 0
112630: PPUSH
112631: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
112635: LD_VAR 0 1
112639: PPUSH
112640: LD_OWVAR 3
112644: PUSH
112645: LD_VAR 0 1
112649: DIFF
112650: PPUSH
112651: LD_VAR 0 1
112655: PPUSH
112656: CALL_OW 74
112660: PPUSH
112661: CALL_OW 115
// wait ( 0 0$20 ) ;
112665: LD_INT 700
112667: PPUSH
112668: CALL_OW 67
// SetSide ( un , your_side ) ;
112672: LD_VAR 0 1
112676: PPUSH
112677: LD_OWVAR 2
112681: PPUSH
112682: CALL_OW 235
// end ;
112686: PPOPN 2
112688: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
112689: LD_EXP 160
112693: PUSH
112694: LD_EXP 193
112698: AND
112699: IFFALSE 112805
112701: GO 112703
112703: DISABLE
112704: LD_INT 0
112706: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
112707: LD_ADDR_VAR 0 1
112711: PUSH
112712: LD_INT 22
112714: PUSH
112715: LD_OWVAR 2
112719: PUSH
112720: EMPTY
112721: LIST
112722: LIST
112723: PUSH
112724: LD_INT 2
112726: PUSH
112727: LD_INT 30
112729: PUSH
112730: LD_INT 0
112732: PUSH
112733: EMPTY
112734: LIST
112735: LIST
112736: PUSH
112737: LD_INT 30
112739: PUSH
112740: LD_INT 1
112742: PUSH
112743: EMPTY
112744: LIST
112745: LIST
112746: PUSH
112747: EMPTY
112748: LIST
112749: LIST
112750: LIST
112751: PUSH
112752: EMPTY
112753: LIST
112754: LIST
112755: PPUSH
112756: CALL_OW 69
112760: ST_TO_ADDR
// if not depot then
112761: LD_VAR 0 1
112765: NOT
112766: IFFALSE 112770
// exit ;
112768: GO 112805
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
112770: LD_VAR 0 1
112774: PUSH
112775: LD_INT 1
112777: ARRAY
112778: PPUSH
112779: CALL_OW 250
112783: PPUSH
112784: LD_VAR 0 1
112788: PUSH
112789: LD_INT 1
112791: ARRAY
112792: PPUSH
112793: CALL_OW 251
112797: PPUSH
112798: LD_INT 70
112800: PPUSH
112801: CALL_OW 495
// end ;
112805: PPOPN 1
112807: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
112808: LD_EXP 160
112812: PUSH
112813: LD_EXP 194
112817: AND
112818: IFFALSE 113029
112820: GO 112822
112822: DISABLE
112823: LD_INT 0
112825: PPUSH
112826: PPUSH
112827: PPUSH
112828: PPUSH
112829: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
112830: LD_ADDR_VAR 0 5
112834: PUSH
112835: LD_INT 22
112837: PUSH
112838: LD_OWVAR 2
112842: PUSH
112843: EMPTY
112844: LIST
112845: LIST
112846: PUSH
112847: LD_INT 21
112849: PUSH
112850: LD_INT 1
112852: PUSH
112853: EMPTY
112854: LIST
112855: LIST
112856: PUSH
112857: EMPTY
112858: LIST
112859: LIST
112860: PPUSH
112861: CALL_OW 69
112865: ST_TO_ADDR
// if not tmp then
112866: LD_VAR 0 5
112870: NOT
112871: IFFALSE 112875
// exit ;
112873: GO 113029
// for i in tmp do
112875: LD_ADDR_VAR 0 1
112879: PUSH
112880: LD_VAR 0 5
112884: PUSH
112885: FOR_IN
112886: IFFALSE 113027
// begin d := rand ( 0 , 5 ) ;
112888: LD_ADDR_VAR 0 4
112892: PUSH
112893: LD_INT 0
112895: PPUSH
112896: LD_INT 5
112898: PPUSH
112899: CALL_OW 12
112903: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
112904: LD_ADDR_VAR 0 2
112908: PUSH
112909: LD_VAR 0 1
112913: PPUSH
112914: CALL_OW 250
112918: PPUSH
112919: LD_VAR 0 4
112923: PPUSH
112924: LD_INT 3
112926: PPUSH
112927: LD_INT 12
112929: PPUSH
112930: CALL_OW 12
112934: PPUSH
112935: CALL_OW 272
112939: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
112940: LD_ADDR_VAR 0 3
112944: PUSH
112945: LD_VAR 0 1
112949: PPUSH
112950: CALL_OW 251
112954: PPUSH
112955: LD_VAR 0 4
112959: PPUSH
112960: LD_INT 3
112962: PPUSH
112963: LD_INT 12
112965: PPUSH
112966: CALL_OW 12
112970: PPUSH
112971: CALL_OW 273
112975: ST_TO_ADDR
// if ValidHex ( x , y ) then
112976: LD_VAR 0 2
112980: PPUSH
112981: LD_VAR 0 3
112985: PPUSH
112986: CALL_OW 488
112990: IFFALSE 113025
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
112992: LD_VAR 0 1
112996: PPUSH
112997: LD_VAR 0 2
113001: PPUSH
113002: LD_VAR 0 3
113006: PPUSH
113007: LD_INT 3
113009: PPUSH
113010: LD_INT 6
113012: PPUSH
113013: CALL_OW 12
113017: PPUSH
113018: LD_INT 1
113020: PPUSH
113021: CALL_OW 483
// end ;
113025: GO 112885
113027: POP
113028: POP
// end ;
113029: PPOPN 5
113031: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
113032: LD_EXP 160
113036: PUSH
113037: LD_EXP 195
113041: AND
113042: IFFALSE 113136
113044: GO 113046
113046: DISABLE
113047: LD_INT 0
113049: PPUSH
113050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
113051: LD_ADDR_VAR 0 2
113055: PUSH
113056: LD_INT 22
113058: PUSH
113059: LD_OWVAR 2
113063: PUSH
113064: EMPTY
113065: LIST
113066: LIST
113067: PUSH
113068: LD_INT 32
113070: PUSH
113071: LD_INT 1
113073: PUSH
113074: EMPTY
113075: LIST
113076: LIST
113077: PUSH
113078: LD_INT 21
113080: PUSH
113081: LD_INT 2
113083: PUSH
113084: EMPTY
113085: LIST
113086: LIST
113087: PUSH
113088: EMPTY
113089: LIST
113090: LIST
113091: LIST
113092: PPUSH
113093: CALL_OW 69
113097: ST_TO_ADDR
// if not tmp then
113098: LD_VAR 0 2
113102: NOT
113103: IFFALSE 113107
// exit ;
113105: GO 113136
// for i in tmp do
113107: LD_ADDR_VAR 0 1
113111: PUSH
113112: LD_VAR 0 2
113116: PUSH
113117: FOR_IN
113118: IFFALSE 113134
// SetFuel ( i , 0 ) ;
113120: LD_VAR 0 1
113124: PPUSH
113125: LD_INT 0
113127: PPUSH
113128: CALL_OW 240
113132: GO 113117
113134: POP
113135: POP
// end ;
113136: PPOPN 2
113138: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
113139: LD_EXP 160
113143: PUSH
113144: LD_EXP 196
113148: AND
113149: IFFALSE 113215
113151: GO 113153
113153: DISABLE
113154: LD_INT 0
113156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
113157: LD_ADDR_VAR 0 1
113161: PUSH
113162: LD_INT 22
113164: PUSH
113165: LD_OWVAR 2
113169: PUSH
113170: EMPTY
113171: LIST
113172: LIST
113173: PUSH
113174: LD_INT 30
113176: PUSH
113177: LD_INT 29
113179: PUSH
113180: EMPTY
113181: LIST
113182: LIST
113183: PUSH
113184: EMPTY
113185: LIST
113186: LIST
113187: PPUSH
113188: CALL_OW 69
113192: ST_TO_ADDR
// if not tmp then
113193: LD_VAR 0 1
113197: NOT
113198: IFFALSE 113202
// exit ;
113200: GO 113215
// DestroyUnit ( tmp [ 1 ] ) ;
113202: LD_VAR 0 1
113206: PUSH
113207: LD_INT 1
113209: ARRAY
113210: PPUSH
113211: CALL_OW 65
// end ;
113215: PPOPN 1
113217: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
113218: LD_EXP 160
113222: PUSH
113223: LD_EXP 198
113227: AND
113228: IFFALSE 113357
113230: GO 113232
113232: DISABLE
113233: LD_INT 0
113235: PPUSH
// begin uc_side := 0 ;
113236: LD_ADDR_OWVAR 20
113240: PUSH
113241: LD_INT 0
113243: ST_TO_ADDR
// uc_nation := nation_arabian ;
113244: LD_ADDR_OWVAR 21
113248: PUSH
113249: LD_INT 2
113251: ST_TO_ADDR
// hc_gallery :=  ;
113252: LD_ADDR_OWVAR 33
113256: PUSH
113257: LD_STRING 
113259: ST_TO_ADDR
// hc_name :=  ;
113260: LD_ADDR_OWVAR 26
113264: PUSH
113265: LD_STRING 
113267: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
113268: LD_INT 1
113270: PPUSH
113271: LD_INT 11
113273: PPUSH
113274: LD_INT 10
113276: PPUSH
113277: CALL_OW 380
// un := CreateHuman ;
113281: LD_ADDR_VAR 0 1
113285: PUSH
113286: CALL_OW 44
113290: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113291: LD_VAR 0 1
113295: PPUSH
113296: LD_INT 1
113298: PPUSH
113299: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
113303: LD_INT 35
113305: PPUSH
113306: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
113310: LD_VAR 0 1
113314: PPUSH
113315: LD_INT 22
113317: PUSH
113318: LD_OWVAR 2
113322: PUSH
113323: EMPTY
113324: LIST
113325: LIST
113326: PPUSH
113327: CALL_OW 69
113331: PPUSH
113332: LD_VAR 0 1
113336: PPUSH
113337: CALL_OW 74
113341: PPUSH
113342: CALL_OW 115
// until IsDead ( un ) ;
113346: LD_VAR 0 1
113350: PPUSH
113351: CALL_OW 301
113355: IFFALSE 113303
// end ;
113357: PPOPN 1
113359: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
113360: LD_EXP 160
113364: PUSH
113365: LD_EXP 200
113369: AND
113370: IFFALSE 113382
113372: GO 113374
113374: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
113375: LD_STRING earthquake(getX(game), 0, 32)
113377: PPUSH
113378: CALL_OW 559
113382: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
113383: LD_EXP 160
113387: PUSH
113388: LD_EXP 201
113392: AND
113393: IFFALSE 113484
113395: GO 113397
113397: DISABLE
113398: LD_INT 0
113400: PPUSH
// begin enable ;
113401: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
113402: LD_ADDR_VAR 0 1
113406: PUSH
113407: LD_INT 22
113409: PUSH
113410: LD_OWVAR 2
113414: PUSH
113415: EMPTY
113416: LIST
113417: LIST
113418: PUSH
113419: LD_INT 21
113421: PUSH
113422: LD_INT 2
113424: PUSH
113425: EMPTY
113426: LIST
113427: LIST
113428: PUSH
113429: LD_INT 33
113431: PUSH
113432: LD_INT 3
113434: PUSH
113435: EMPTY
113436: LIST
113437: LIST
113438: PUSH
113439: EMPTY
113440: LIST
113441: LIST
113442: LIST
113443: PPUSH
113444: CALL_OW 69
113448: ST_TO_ADDR
// if not tmp then
113449: LD_VAR 0 1
113453: NOT
113454: IFFALSE 113458
// exit ;
113456: GO 113484
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
113458: LD_VAR 0 1
113462: PUSH
113463: LD_INT 1
113465: PPUSH
113466: LD_VAR 0 1
113470: PPUSH
113471: CALL_OW 12
113475: ARRAY
113476: PPUSH
113477: LD_INT 1
113479: PPUSH
113480: CALL_OW 234
// end ;
113484: PPOPN 1
113486: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
113487: LD_EXP 160
113491: PUSH
113492: LD_EXP 202
113496: AND
113497: IFFALSE 113638
113499: GO 113501
113501: DISABLE
113502: LD_INT 0
113504: PPUSH
113505: PPUSH
113506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
113507: LD_ADDR_VAR 0 3
113511: PUSH
113512: LD_INT 22
113514: PUSH
113515: LD_OWVAR 2
113519: PUSH
113520: EMPTY
113521: LIST
113522: LIST
113523: PUSH
113524: LD_INT 25
113526: PUSH
113527: LD_INT 1
113529: PUSH
113530: EMPTY
113531: LIST
113532: LIST
113533: PUSH
113534: EMPTY
113535: LIST
113536: LIST
113537: PPUSH
113538: CALL_OW 69
113542: ST_TO_ADDR
// if not tmp then
113543: LD_VAR 0 3
113547: NOT
113548: IFFALSE 113552
// exit ;
113550: GO 113638
// un := tmp [ rand ( 1 , tmp ) ] ;
113552: LD_ADDR_VAR 0 2
113556: PUSH
113557: LD_VAR 0 3
113561: PUSH
113562: LD_INT 1
113564: PPUSH
113565: LD_VAR 0 3
113569: PPUSH
113570: CALL_OW 12
113574: ARRAY
113575: ST_TO_ADDR
// if Crawls ( un ) then
113576: LD_VAR 0 2
113580: PPUSH
113581: CALL_OW 318
113585: IFFALSE 113596
// ComWalk ( un ) ;
113587: LD_VAR 0 2
113591: PPUSH
113592: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
113596: LD_VAR 0 2
113600: PPUSH
113601: LD_INT 9
113603: PPUSH
113604: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
113608: LD_INT 28
113610: PPUSH
113611: LD_OWVAR 2
113615: PPUSH
113616: LD_INT 2
113618: PPUSH
113619: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
113623: LD_INT 29
113625: PPUSH
113626: LD_OWVAR 2
113630: PPUSH
113631: LD_INT 2
113633: PPUSH
113634: CALL_OW 322
// end ;
113638: PPOPN 3
113640: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
113641: LD_EXP 160
113645: PUSH
113646: LD_EXP 203
113650: AND
113651: IFFALSE 113762
113653: GO 113655
113655: DISABLE
113656: LD_INT 0
113658: PPUSH
113659: PPUSH
113660: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
113661: LD_ADDR_VAR 0 3
113665: PUSH
113666: LD_INT 22
113668: PUSH
113669: LD_OWVAR 2
113673: PUSH
113674: EMPTY
113675: LIST
113676: LIST
113677: PUSH
113678: LD_INT 25
113680: PUSH
113681: LD_INT 1
113683: PUSH
113684: EMPTY
113685: LIST
113686: LIST
113687: PUSH
113688: EMPTY
113689: LIST
113690: LIST
113691: PPUSH
113692: CALL_OW 69
113696: ST_TO_ADDR
// if not tmp then
113697: LD_VAR 0 3
113701: NOT
113702: IFFALSE 113706
// exit ;
113704: GO 113762
// un := tmp [ rand ( 1 , tmp ) ] ;
113706: LD_ADDR_VAR 0 2
113710: PUSH
113711: LD_VAR 0 3
113715: PUSH
113716: LD_INT 1
113718: PPUSH
113719: LD_VAR 0 3
113723: PPUSH
113724: CALL_OW 12
113728: ARRAY
113729: ST_TO_ADDR
// if Crawls ( un ) then
113730: LD_VAR 0 2
113734: PPUSH
113735: CALL_OW 318
113739: IFFALSE 113750
// ComWalk ( un ) ;
113741: LD_VAR 0 2
113745: PPUSH
113746: CALL_OW 138
// SetClass ( un , class_mortar ) ;
113750: LD_VAR 0 2
113754: PPUSH
113755: LD_INT 8
113757: PPUSH
113758: CALL_OW 336
// end ;
113762: PPOPN 3
113764: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
113765: LD_EXP 160
113769: PUSH
113770: LD_EXP 204
113774: AND
113775: IFFALSE 113919
113777: GO 113779
113779: DISABLE
113780: LD_INT 0
113782: PPUSH
113783: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
113784: LD_ADDR_VAR 0 2
113788: PUSH
113789: LD_INT 22
113791: PUSH
113792: LD_OWVAR 2
113796: PUSH
113797: EMPTY
113798: LIST
113799: LIST
113800: PUSH
113801: LD_INT 21
113803: PUSH
113804: LD_INT 2
113806: PUSH
113807: EMPTY
113808: LIST
113809: LIST
113810: PUSH
113811: LD_INT 2
113813: PUSH
113814: LD_INT 34
113816: PUSH
113817: LD_INT 12
113819: PUSH
113820: EMPTY
113821: LIST
113822: LIST
113823: PUSH
113824: LD_INT 34
113826: PUSH
113827: LD_INT 51
113829: PUSH
113830: EMPTY
113831: LIST
113832: LIST
113833: PUSH
113834: LD_INT 34
113836: PUSH
113837: LD_INT 32
113839: PUSH
113840: EMPTY
113841: LIST
113842: LIST
113843: PUSH
113844: EMPTY
113845: LIST
113846: LIST
113847: LIST
113848: LIST
113849: PUSH
113850: EMPTY
113851: LIST
113852: LIST
113853: LIST
113854: PPUSH
113855: CALL_OW 69
113859: ST_TO_ADDR
// if not tmp then
113860: LD_VAR 0 2
113864: NOT
113865: IFFALSE 113869
// exit ;
113867: GO 113919
// for i in tmp do
113869: LD_ADDR_VAR 0 1
113873: PUSH
113874: LD_VAR 0 2
113878: PUSH
113879: FOR_IN
113880: IFFALSE 113917
// if GetCargo ( i , mat_artifact ) = 0 then
113882: LD_VAR 0 1
113886: PPUSH
113887: LD_INT 4
113889: PPUSH
113890: CALL_OW 289
113894: PUSH
113895: LD_INT 0
113897: EQUAL
113898: IFFALSE 113915
// SetCargo ( i , mat_siberit , 100 ) ;
113900: LD_VAR 0 1
113904: PPUSH
113905: LD_INT 3
113907: PPUSH
113908: LD_INT 100
113910: PPUSH
113911: CALL_OW 290
113915: GO 113879
113917: POP
113918: POP
// end ;
113919: PPOPN 2
113921: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
113922: LD_EXP 160
113926: PUSH
113927: LD_EXP 205
113931: AND
113932: IFFALSE 114115
113934: GO 113936
113936: DISABLE
113937: LD_INT 0
113939: PPUSH
113940: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
113941: LD_ADDR_VAR 0 2
113945: PUSH
113946: LD_INT 22
113948: PUSH
113949: LD_OWVAR 2
113953: PUSH
113954: EMPTY
113955: LIST
113956: LIST
113957: PPUSH
113958: CALL_OW 69
113962: ST_TO_ADDR
// if not tmp then
113963: LD_VAR 0 2
113967: NOT
113968: IFFALSE 113972
// exit ;
113970: GO 114115
// for i := 1 to 2 do
113972: LD_ADDR_VAR 0 1
113976: PUSH
113977: DOUBLE
113978: LD_INT 1
113980: DEC
113981: ST_TO_ADDR
113982: LD_INT 2
113984: PUSH
113985: FOR_TO
113986: IFFALSE 114113
// begin uc_side := your_side ;
113988: LD_ADDR_OWVAR 20
113992: PUSH
113993: LD_OWVAR 2
113997: ST_TO_ADDR
// uc_nation := nation_american ;
113998: LD_ADDR_OWVAR 21
114002: PUSH
114003: LD_INT 1
114005: ST_TO_ADDR
// vc_chassis := us_morphling ;
114006: LD_ADDR_OWVAR 37
114010: PUSH
114011: LD_INT 5
114013: ST_TO_ADDR
// vc_engine := engine_siberite ;
114014: LD_ADDR_OWVAR 39
114018: PUSH
114019: LD_INT 3
114021: ST_TO_ADDR
// vc_control := control_computer ;
114022: LD_ADDR_OWVAR 38
114026: PUSH
114027: LD_INT 3
114029: ST_TO_ADDR
// vc_weapon := us_double_laser ;
114030: LD_ADDR_OWVAR 40
114034: PUSH
114035: LD_INT 10
114037: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
114038: LD_VAR 0 2
114042: PUSH
114043: LD_INT 1
114045: ARRAY
114046: PPUSH
114047: CALL_OW 310
114051: NOT
114052: IFFALSE 114099
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
114054: CALL_OW 45
114058: PPUSH
114059: LD_VAR 0 2
114063: PUSH
114064: LD_INT 1
114066: ARRAY
114067: PPUSH
114068: CALL_OW 250
114072: PPUSH
114073: LD_VAR 0 2
114077: PUSH
114078: LD_INT 1
114080: ARRAY
114081: PPUSH
114082: CALL_OW 251
114086: PPUSH
114087: LD_INT 12
114089: PPUSH
114090: LD_INT 1
114092: PPUSH
114093: CALL_OW 50
114097: GO 114111
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
114099: CALL_OW 45
114103: PPUSH
114104: LD_INT 1
114106: PPUSH
114107: CALL_OW 51
// end ;
114111: GO 113985
114113: POP
114114: POP
// end ;
114115: PPOPN 2
114117: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
114118: LD_EXP 160
114122: PUSH
114123: LD_EXP 206
114127: AND
114128: IFFALSE 114350
114130: GO 114132
114132: DISABLE
114133: LD_INT 0
114135: PPUSH
114136: PPUSH
114137: PPUSH
114138: PPUSH
114139: PPUSH
114140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
114141: LD_ADDR_VAR 0 6
114145: PUSH
114146: LD_INT 22
114148: PUSH
114149: LD_OWVAR 2
114153: PUSH
114154: EMPTY
114155: LIST
114156: LIST
114157: PUSH
114158: LD_INT 21
114160: PUSH
114161: LD_INT 1
114163: PUSH
114164: EMPTY
114165: LIST
114166: LIST
114167: PUSH
114168: LD_INT 3
114170: PUSH
114171: LD_INT 23
114173: PUSH
114174: LD_INT 0
114176: PUSH
114177: EMPTY
114178: LIST
114179: LIST
114180: PUSH
114181: EMPTY
114182: LIST
114183: LIST
114184: PUSH
114185: EMPTY
114186: LIST
114187: LIST
114188: LIST
114189: PPUSH
114190: CALL_OW 69
114194: ST_TO_ADDR
// if not tmp then
114195: LD_VAR 0 6
114199: NOT
114200: IFFALSE 114204
// exit ;
114202: GO 114350
// s1 := rand ( 1 , 4 ) ;
114204: LD_ADDR_VAR 0 2
114208: PUSH
114209: LD_INT 1
114211: PPUSH
114212: LD_INT 4
114214: PPUSH
114215: CALL_OW 12
114219: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
114220: LD_ADDR_VAR 0 4
114224: PUSH
114225: LD_VAR 0 6
114229: PUSH
114230: LD_INT 1
114232: ARRAY
114233: PPUSH
114234: LD_VAR 0 2
114238: PPUSH
114239: CALL_OW 259
114243: ST_TO_ADDR
// if s1 = 1 then
114244: LD_VAR 0 2
114248: PUSH
114249: LD_INT 1
114251: EQUAL
114252: IFFALSE 114272
// s2 := rand ( 2 , 4 ) else
114254: LD_ADDR_VAR 0 3
114258: PUSH
114259: LD_INT 2
114261: PPUSH
114262: LD_INT 4
114264: PPUSH
114265: CALL_OW 12
114269: ST_TO_ADDR
114270: GO 114280
// s2 := 1 ;
114272: LD_ADDR_VAR 0 3
114276: PUSH
114277: LD_INT 1
114279: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
114280: LD_ADDR_VAR 0 5
114284: PUSH
114285: LD_VAR 0 6
114289: PUSH
114290: LD_INT 1
114292: ARRAY
114293: PPUSH
114294: LD_VAR 0 3
114298: PPUSH
114299: CALL_OW 259
114303: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
114304: LD_VAR 0 6
114308: PUSH
114309: LD_INT 1
114311: ARRAY
114312: PPUSH
114313: LD_VAR 0 2
114317: PPUSH
114318: LD_VAR 0 5
114322: PPUSH
114323: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
114327: LD_VAR 0 6
114331: PUSH
114332: LD_INT 1
114334: ARRAY
114335: PPUSH
114336: LD_VAR 0 3
114340: PPUSH
114341: LD_VAR 0 4
114345: PPUSH
114346: CALL_OW 237
// end ;
114350: PPOPN 6
114352: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
114353: LD_EXP 160
114357: PUSH
114358: LD_EXP 207
114362: AND
114363: IFFALSE 114442
114365: GO 114367
114367: DISABLE
114368: LD_INT 0
114370: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
114371: LD_ADDR_VAR 0 1
114375: PUSH
114376: LD_INT 22
114378: PUSH
114379: LD_OWVAR 2
114383: PUSH
114384: EMPTY
114385: LIST
114386: LIST
114387: PUSH
114388: LD_INT 30
114390: PUSH
114391: LD_INT 3
114393: PUSH
114394: EMPTY
114395: LIST
114396: LIST
114397: PUSH
114398: EMPTY
114399: LIST
114400: LIST
114401: PPUSH
114402: CALL_OW 69
114406: ST_TO_ADDR
// if not tmp then
114407: LD_VAR 0 1
114411: NOT
114412: IFFALSE 114416
// exit ;
114414: GO 114442
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
114416: LD_VAR 0 1
114420: PUSH
114421: LD_INT 1
114423: PPUSH
114424: LD_VAR 0 1
114428: PPUSH
114429: CALL_OW 12
114433: ARRAY
114434: PPUSH
114435: LD_INT 1
114437: PPUSH
114438: CALL_OW 234
// end ;
114442: PPOPN 1
114444: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
114445: LD_EXP 160
114449: PUSH
114450: LD_EXP 208
114454: AND
114455: IFFALSE 114567
114457: GO 114459
114459: DISABLE
114460: LD_INT 0
114462: PPUSH
114463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
114464: LD_ADDR_VAR 0 2
114468: PUSH
114469: LD_INT 22
114471: PUSH
114472: LD_OWVAR 2
114476: PUSH
114477: EMPTY
114478: LIST
114479: LIST
114480: PUSH
114481: LD_INT 2
114483: PUSH
114484: LD_INT 30
114486: PUSH
114487: LD_INT 27
114489: PUSH
114490: EMPTY
114491: LIST
114492: LIST
114493: PUSH
114494: LD_INT 30
114496: PUSH
114497: LD_INT 26
114499: PUSH
114500: EMPTY
114501: LIST
114502: LIST
114503: PUSH
114504: LD_INT 30
114506: PUSH
114507: LD_INT 28
114509: PUSH
114510: EMPTY
114511: LIST
114512: LIST
114513: PUSH
114514: EMPTY
114515: LIST
114516: LIST
114517: LIST
114518: LIST
114519: PUSH
114520: EMPTY
114521: LIST
114522: LIST
114523: PPUSH
114524: CALL_OW 69
114528: ST_TO_ADDR
// if not tmp then
114529: LD_VAR 0 2
114533: NOT
114534: IFFALSE 114538
// exit ;
114536: GO 114567
// for i in tmp do
114538: LD_ADDR_VAR 0 1
114542: PUSH
114543: LD_VAR 0 2
114547: PUSH
114548: FOR_IN
114549: IFFALSE 114565
// SetLives ( i , 1 ) ;
114551: LD_VAR 0 1
114555: PPUSH
114556: LD_INT 1
114558: PPUSH
114559: CALL_OW 234
114563: GO 114548
114565: POP
114566: POP
// end ;
114567: PPOPN 2
114569: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
114570: LD_EXP 160
114574: PUSH
114575: LD_EXP 209
114579: AND
114580: IFFALSE 114854
114582: GO 114584
114584: DISABLE
114585: LD_INT 0
114587: PPUSH
114588: PPUSH
114589: PPUSH
// begin i := rand ( 1 , 7 ) ;
114590: LD_ADDR_VAR 0 1
114594: PUSH
114595: LD_INT 1
114597: PPUSH
114598: LD_INT 7
114600: PPUSH
114601: CALL_OW 12
114605: ST_TO_ADDR
// case i of 1 :
114606: LD_VAR 0 1
114610: PUSH
114611: LD_INT 1
114613: DOUBLE
114614: EQUAL
114615: IFTRUE 114619
114617: GO 114629
114619: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
114620: LD_STRING earthquake(getX(game), 0, 32)
114622: PPUSH
114623: CALL_OW 559
114627: GO 114854
114629: LD_INT 2
114631: DOUBLE
114632: EQUAL
114633: IFTRUE 114637
114635: GO 114651
114637: POP
// begin ToLua ( displayStucuk(); ) ;
114638: LD_STRING displayStucuk();
114640: PPUSH
114641: CALL_OW 559
// ResetFog ;
114645: CALL_OW 335
// end ; 3 :
114649: GO 114854
114651: LD_INT 3
114653: DOUBLE
114654: EQUAL
114655: IFTRUE 114659
114657: GO 114763
114659: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114660: LD_ADDR_VAR 0 2
114664: PUSH
114665: LD_INT 22
114667: PUSH
114668: LD_OWVAR 2
114672: PUSH
114673: EMPTY
114674: LIST
114675: LIST
114676: PUSH
114677: LD_INT 25
114679: PUSH
114680: LD_INT 1
114682: PUSH
114683: EMPTY
114684: LIST
114685: LIST
114686: PUSH
114687: EMPTY
114688: LIST
114689: LIST
114690: PPUSH
114691: CALL_OW 69
114695: ST_TO_ADDR
// if not tmp then
114696: LD_VAR 0 2
114700: NOT
114701: IFFALSE 114705
// exit ;
114703: GO 114854
// un := tmp [ rand ( 1 , tmp ) ] ;
114705: LD_ADDR_VAR 0 3
114709: PUSH
114710: LD_VAR 0 2
114714: PUSH
114715: LD_INT 1
114717: PPUSH
114718: LD_VAR 0 2
114722: PPUSH
114723: CALL_OW 12
114727: ARRAY
114728: ST_TO_ADDR
// if Crawls ( un ) then
114729: LD_VAR 0 3
114733: PPUSH
114734: CALL_OW 318
114738: IFFALSE 114749
// ComWalk ( un ) ;
114740: LD_VAR 0 3
114744: PPUSH
114745: CALL_OW 138
// SetClass ( un , class_mortar ) ;
114749: LD_VAR 0 3
114753: PPUSH
114754: LD_INT 8
114756: PPUSH
114757: CALL_OW 336
// end ; 4 :
114761: GO 114854
114763: LD_INT 4
114765: DOUBLE
114766: EQUAL
114767: IFTRUE 114771
114769: GO 114832
114771: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
114772: LD_ADDR_VAR 0 2
114776: PUSH
114777: LD_INT 22
114779: PUSH
114780: LD_OWVAR 2
114784: PUSH
114785: EMPTY
114786: LIST
114787: LIST
114788: PUSH
114789: LD_INT 30
114791: PUSH
114792: LD_INT 29
114794: PUSH
114795: EMPTY
114796: LIST
114797: LIST
114798: PUSH
114799: EMPTY
114800: LIST
114801: LIST
114802: PPUSH
114803: CALL_OW 69
114807: ST_TO_ADDR
// if not tmp then
114808: LD_VAR 0 2
114812: NOT
114813: IFFALSE 114817
// exit ;
114815: GO 114854
// DestroyUnit ( tmp [ 1 ] ) ;
114817: LD_VAR 0 2
114821: PUSH
114822: LD_INT 1
114824: ARRAY
114825: PPUSH
114826: CALL_OW 65
// end ; 5 .. 7 :
114830: GO 114854
114832: LD_INT 5
114834: DOUBLE
114835: GREATEREQUAL
114836: IFFALSE 114844
114838: LD_INT 7
114840: DOUBLE
114841: LESSEQUAL
114842: IFTRUE 114846
114844: GO 114853
114846: POP
// StreamSibBomb ; end ;
114847: CALL 111104 0 0
114851: GO 114854
114853: POP
// end ;
114854: PPOPN 3
114856: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
114857: LD_EXP 160
114861: PUSH
114862: LD_EXP 210
114866: AND
114867: IFFALSE 115023
114869: GO 114871
114871: DISABLE
114872: LD_INT 0
114874: PPUSH
114875: PPUSH
114876: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
114877: LD_ADDR_VAR 0 2
114881: PUSH
114882: LD_INT 81
114884: PUSH
114885: LD_OWVAR 2
114889: PUSH
114890: EMPTY
114891: LIST
114892: LIST
114893: PUSH
114894: LD_INT 2
114896: PUSH
114897: LD_INT 21
114899: PUSH
114900: LD_INT 1
114902: PUSH
114903: EMPTY
114904: LIST
114905: LIST
114906: PUSH
114907: LD_INT 21
114909: PUSH
114910: LD_INT 2
114912: PUSH
114913: EMPTY
114914: LIST
114915: LIST
114916: PUSH
114917: EMPTY
114918: LIST
114919: LIST
114920: LIST
114921: PUSH
114922: EMPTY
114923: LIST
114924: LIST
114925: PPUSH
114926: CALL_OW 69
114930: ST_TO_ADDR
// if not tmp then
114931: LD_VAR 0 2
114935: NOT
114936: IFFALSE 114940
// exit ;
114938: GO 115023
// p := 0 ;
114940: LD_ADDR_VAR 0 3
114944: PUSH
114945: LD_INT 0
114947: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
114948: LD_INT 35
114950: PPUSH
114951: CALL_OW 67
// p := p + 1 ;
114955: LD_ADDR_VAR 0 3
114959: PUSH
114960: LD_VAR 0 3
114964: PUSH
114965: LD_INT 1
114967: PLUS
114968: ST_TO_ADDR
// for i in tmp do
114969: LD_ADDR_VAR 0 1
114973: PUSH
114974: LD_VAR 0 2
114978: PUSH
114979: FOR_IN
114980: IFFALSE 115011
// if GetLives ( i ) < 1000 then
114982: LD_VAR 0 1
114986: PPUSH
114987: CALL_OW 256
114991: PUSH
114992: LD_INT 1000
114994: LESS
114995: IFFALSE 115009
// SetLives ( i , 1000 ) ;
114997: LD_VAR 0 1
115001: PPUSH
115002: LD_INT 1000
115004: PPUSH
115005: CALL_OW 234
115009: GO 114979
115011: POP
115012: POP
// until p > 20 ;
115013: LD_VAR 0 3
115017: PUSH
115018: LD_INT 20
115020: GREATER
115021: IFFALSE 114948
// end ;
115023: PPOPN 3
115025: END
// every 0 0$1 trigger StreamModeActive and sTime do
115026: LD_EXP 160
115030: PUSH
115031: LD_EXP 211
115035: AND
115036: IFFALSE 115071
115038: GO 115040
115040: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
115041: LD_INT 28
115043: PPUSH
115044: LD_OWVAR 2
115048: PPUSH
115049: LD_INT 2
115051: PPUSH
115052: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
115056: LD_INT 30
115058: PPUSH
115059: LD_OWVAR 2
115063: PPUSH
115064: LD_INT 2
115066: PPUSH
115067: CALL_OW 322
// end ;
115071: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
115072: LD_EXP 160
115076: PUSH
115077: LD_EXP 212
115081: AND
115082: IFFALSE 115203
115084: GO 115086
115086: DISABLE
115087: LD_INT 0
115089: PPUSH
115090: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115091: LD_ADDR_VAR 0 2
115095: PUSH
115096: LD_INT 22
115098: PUSH
115099: LD_OWVAR 2
115103: PUSH
115104: EMPTY
115105: LIST
115106: LIST
115107: PUSH
115108: LD_INT 21
115110: PUSH
115111: LD_INT 1
115113: PUSH
115114: EMPTY
115115: LIST
115116: LIST
115117: PUSH
115118: LD_INT 3
115120: PUSH
115121: LD_INT 23
115123: PUSH
115124: LD_INT 0
115126: PUSH
115127: EMPTY
115128: LIST
115129: LIST
115130: PUSH
115131: EMPTY
115132: LIST
115133: LIST
115134: PUSH
115135: EMPTY
115136: LIST
115137: LIST
115138: LIST
115139: PPUSH
115140: CALL_OW 69
115144: ST_TO_ADDR
// if not tmp then
115145: LD_VAR 0 2
115149: NOT
115150: IFFALSE 115154
// exit ;
115152: GO 115203
// for i in tmp do
115154: LD_ADDR_VAR 0 1
115158: PUSH
115159: LD_VAR 0 2
115163: PUSH
115164: FOR_IN
115165: IFFALSE 115201
// begin if Crawls ( i ) then
115167: LD_VAR 0 1
115171: PPUSH
115172: CALL_OW 318
115176: IFFALSE 115187
// ComWalk ( i ) ;
115178: LD_VAR 0 1
115182: PPUSH
115183: CALL_OW 138
// SetClass ( i , 2 ) ;
115187: LD_VAR 0 1
115191: PPUSH
115192: LD_INT 2
115194: PPUSH
115195: CALL_OW 336
// end ;
115199: GO 115164
115201: POP
115202: POP
// end ;
115203: PPOPN 2
115205: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
115206: LD_EXP 160
115210: PUSH
115211: LD_EXP 213
115215: AND
115216: IFFALSE 115497
115218: GO 115220
115220: DISABLE
115221: LD_INT 0
115223: PPUSH
115224: PPUSH
115225: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
115226: LD_OWVAR 2
115230: PPUSH
115231: LD_INT 9
115233: PPUSH
115234: LD_INT 1
115236: PPUSH
115237: LD_INT 1
115239: PPUSH
115240: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
115244: LD_INT 9
115246: PPUSH
115247: LD_OWVAR 2
115251: PPUSH
115252: CALL_OW 343
// uc_side := 9 ;
115256: LD_ADDR_OWVAR 20
115260: PUSH
115261: LD_INT 9
115263: ST_TO_ADDR
// uc_nation := 2 ;
115264: LD_ADDR_OWVAR 21
115268: PUSH
115269: LD_INT 2
115271: ST_TO_ADDR
// hc_name := Dark Warrior ;
115272: LD_ADDR_OWVAR 26
115276: PUSH
115277: LD_STRING Dark Warrior
115279: ST_TO_ADDR
// hc_gallery :=  ;
115280: LD_ADDR_OWVAR 33
115284: PUSH
115285: LD_STRING 
115287: ST_TO_ADDR
// hc_noskilllimit := true ;
115288: LD_ADDR_OWVAR 76
115292: PUSH
115293: LD_INT 1
115295: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
115296: LD_ADDR_OWVAR 31
115300: PUSH
115301: LD_INT 30
115303: PUSH
115304: LD_INT 30
115306: PUSH
115307: LD_INT 30
115309: PUSH
115310: LD_INT 30
115312: PUSH
115313: EMPTY
115314: LIST
115315: LIST
115316: LIST
115317: LIST
115318: ST_TO_ADDR
// un := CreateHuman ;
115319: LD_ADDR_VAR 0 3
115323: PUSH
115324: CALL_OW 44
115328: ST_TO_ADDR
// hc_noskilllimit := false ;
115329: LD_ADDR_OWVAR 76
115333: PUSH
115334: LD_INT 0
115336: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115337: LD_VAR 0 3
115341: PPUSH
115342: LD_INT 1
115344: PPUSH
115345: CALL_OW 51
// p := 0 ;
115349: LD_ADDR_VAR 0 2
115353: PUSH
115354: LD_INT 0
115356: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
115357: LD_INT 35
115359: PPUSH
115360: CALL_OW 67
// p := p + 1 ;
115364: LD_ADDR_VAR 0 2
115368: PUSH
115369: LD_VAR 0 2
115373: PUSH
115374: LD_INT 1
115376: PLUS
115377: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
115378: LD_VAR 0 3
115382: PPUSH
115383: CALL_OW 256
115387: PUSH
115388: LD_INT 1000
115390: LESS
115391: IFFALSE 115405
// SetLives ( un , 1000 ) ;
115393: LD_VAR 0 3
115397: PPUSH
115398: LD_INT 1000
115400: PPUSH
115401: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
115405: LD_VAR 0 3
115409: PPUSH
115410: LD_INT 81
115412: PUSH
115413: LD_OWVAR 2
115417: PUSH
115418: EMPTY
115419: LIST
115420: LIST
115421: PUSH
115422: LD_INT 91
115424: PUSH
115425: LD_VAR 0 3
115429: PUSH
115430: LD_INT 30
115432: PUSH
115433: EMPTY
115434: LIST
115435: LIST
115436: LIST
115437: PUSH
115438: EMPTY
115439: LIST
115440: LIST
115441: PPUSH
115442: CALL_OW 69
115446: PPUSH
115447: LD_VAR 0 3
115451: PPUSH
115452: CALL_OW 74
115456: PPUSH
115457: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
115461: LD_VAR 0 2
115465: PUSH
115466: LD_INT 60
115468: GREATER
115469: PUSH
115470: LD_VAR 0 3
115474: PPUSH
115475: CALL_OW 301
115479: OR
115480: IFFALSE 115357
// if un then
115482: LD_VAR 0 3
115486: IFFALSE 115497
// RemoveUnit ( un ) ;
115488: LD_VAR 0 3
115492: PPUSH
115493: CALL_OW 64
// end ;
115497: PPOPN 3
115499: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
115500: LD_INT 0
115502: PPUSH
// case cmd of 301 :
115503: LD_VAR 0 1
115507: PUSH
115508: LD_INT 301
115510: DOUBLE
115511: EQUAL
115512: IFTRUE 115516
115514: GO 115548
115516: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
115517: LD_VAR 0 6
115521: PPUSH
115522: LD_VAR 0 7
115526: PPUSH
115527: LD_VAR 0 8
115531: PPUSH
115532: LD_VAR 0 4
115536: PPUSH
115537: LD_VAR 0 5
115541: PPUSH
115542: CALL 116749 0 5
115546: GO 115669
115548: LD_INT 302
115550: DOUBLE
115551: EQUAL
115552: IFTRUE 115556
115554: GO 115593
115556: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
115557: LD_VAR 0 6
115561: PPUSH
115562: LD_VAR 0 7
115566: PPUSH
115567: LD_VAR 0 8
115571: PPUSH
115572: LD_VAR 0 9
115576: PPUSH
115577: LD_VAR 0 4
115581: PPUSH
115582: LD_VAR 0 5
115586: PPUSH
115587: CALL 116840 0 6
115591: GO 115669
115593: LD_INT 303
115595: DOUBLE
115596: EQUAL
115597: IFTRUE 115601
115599: GO 115638
115601: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
115602: LD_VAR 0 6
115606: PPUSH
115607: LD_VAR 0 7
115611: PPUSH
115612: LD_VAR 0 8
115616: PPUSH
115617: LD_VAR 0 9
115621: PPUSH
115622: LD_VAR 0 4
115626: PPUSH
115627: LD_VAR 0 5
115631: PPUSH
115632: CALL 115674 0 6
115636: GO 115669
115638: LD_INT 304
115640: DOUBLE
115641: EQUAL
115642: IFTRUE 115646
115644: GO 115668
115646: POP
// hHackTeleport ( unit , x , y ) ; end ;
115647: LD_VAR 0 2
115651: PPUSH
115652: LD_VAR 0 4
115656: PPUSH
115657: LD_VAR 0 5
115661: PPUSH
115662: CALL 117433 0 3
115666: GO 115669
115668: POP
// end ;
115669: LD_VAR 0 12
115673: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
115674: LD_INT 0
115676: PPUSH
115677: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
115678: LD_VAR 0 1
115682: PUSH
115683: LD_INT 1
115685: LESS
115686: PUSH
115687: LD_VAR 0 1
115691: PUSH
115692: LD_INT 3
115694: GREATER
115695: OR
115696: PUSH
115697: LD_VAR 0 5
115701: PPUSH
115702: LD_VAR 0 6
115706: PPUSH
115707: CALL_OW 428
115711: OR
115712: IFFALSE 115716
// exit ;
115714: GO 116436
// uc_side := your_side ;
115716: LD_ADDR_OWVAR 20
115720: PUSH
115721: LD_OWVAR 2
115725: ST_TO_ADDR
// uc_nation := nation ;
115726: LD_ADDR_OWVAR 21
115730: PUSH
115731: LD_VAR 0 1
115735: ST_TO_ADDR
// bc_level = 1 ;
115736: LD_ADDR_OWVAR 43
115740: PUSH
115741: LD_INT 1
115743: ST_TO_ADDR
// case btype of 1 :
115744: LD_VAR 0 2
115748: PUSH
115749: LD_INT 1
115751: DOUBLE
115752: EQUAL
115753: IFTRUE 115757
115755: GO 115768
115757: POP
// bc_type := b_depot ; 2 :
115758: LD_ADDR_OWVAR 42
115762: PUSH
115763: LD_INT 0
115765: ST_TO_ADDR
115766: GO 116380
115768: LD_INT 2
115770: DOUBLE
115771: EQUAL
115772: IFTRUE 115776
115774: GO 115787
115776: POP
// bc_type := b_warehouse ; 3 :
115777: LD_ADDR_OWVAR 42
115781: PUSH
115782: LD_INT 1
115784: ST_TO_ADDR
115785: GO 116380
115787: LD_INT 3
115789: DOUBLE
115790: EQUAL
115791: IFTRUE 115795
115793: GO 115806
115795: POP
// bc_type := b_lab ; 4 .. 9 :
115796: LD_ADDR_OWVAR 42
115800: PUSH
115801: LD_INT 6
115803: ST_TO_ADDR
115804: GO 116380
115806: LD_INT 4
115808: DOUBLE
115809: GREATEREQUAL
115810: IFFALSE 115818
115812: LD_INT 9
115814: DOUBLE
115815: LESSEQUAL
115816: IFTRUE 115820
115818: GO 115872
115820: POP
// begin bc_type := b_lab_half ;
115821: LD_ADDR_OWVAR 42
115825: PUSH
115826: LD_INT 7
115828: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
115829: LD_ADDR_OWVAR 44
115833: PUSH
115834: LD_INT 10
115836: PUSH
115837: LD_INT 11
115839: PUSH
115840: LD_INT 12
115842: PUSH
115843: LD_INT 15
115845: PUSH
115846: LD_INT 14
115848: PUSH
115849: LD_INT 13
115851: PUSH
115852: EMPTY
115853: LIST
115854: LIST
115855: LIST
115856: LIST
115857: LIST
115858: LIST
115859: PUSH
115860: LD_VAR 0 2
115864: PUSH
115865: LD_INT 3
115867: MINUS
115868: ARRAY
115869: ST_TO_ADDR
// end ; 10 .. 13 :
115870: GO 116380
115872: LD_INT 10
115874: DOUBLE
115875: GREATEREQUAL
115876: IFFALSE 115884
115878: LD_INT 13
115880: DOUBLE
115881: LESSEQUAL
115882: IFTRUE 115886
115884: GO 115963
115886: POP
// begin bc_type := b_lab_full ;
115887: LD_ADDR_OWVAR 42
115891: PUSH
115892: LD_INT 8
115894: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
115895: LD_ADDR_OWVAR 44
115899: PUSH
115900: LD_INT 10
115902: PUSH
115903: LD_INT 12
115905: PUSH
115906: LD_INT 14
115908: PUSH
115909: LD_INT 13
115911: PUSH
115912: EMPTY
115913: LIST
115914: LIST
115915: LIST
115916: LIST
115917: PUSH
115918: LD_VAR 0 2
115922: PUSH
115923: LD_INT 9
115925: MINUS
115926: ARRAY
115927: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
115928: LD_ADDR_OWVAR 45
115932: PUSH
115933: LD_INT 11
115935: PUSH
115936: LD_INT 15
115938: PUSH
115939: LD_INT 12
115941: PUSH
115942: LD_INT 15
115944: PUSH
115945: EMPTY
115946: LIST
115947: LIST
115948: LIST
115949: LIST
115950: PUSH
115951: LD_VAR 0 2
115955: PUSH
115956: LD_INT 9
115958: MINUS
115959: ARRAY
115960: ST_TO_ADDR
// end ; 14 :
115961: GO 116380
115963: LD_INT 14
115965: DOUBLE
115966: EQUAL
115967: IFTRUE 115971
115969: GO 115982
115971: POP
// bc_type := b_workshop ; 15 :
115972: LD_ADDR_OWVAR 42
115976: PUSH
115977: LD_INT 2
115979: ST_TO_ADDR
115980: GO 116380
115982: LD_INT 15
115984: DOUBLE
115985: EQUAL
115986: IFTRUE 115990
115988: GO 116001
115990: POP
// bc_type := b_factory ; 16 :
115991: LD_ADDR_OWVAR 42
115995: PUSH
115996: LD_INT 3
115998: ST_TO_ADDR
115999: GO 116380
116001: LD_INT 16
116003: DOUBLE
116004: EQUAL
116005: IFTRUE 116009
116007: GO 116020
116009: POP
// bc_type := b_ext_gun ; 17 :
116010: LD_ADDR_OWVAR 42
116014: PUSH
116015: LD_INT 17
116017: ST_TO_ADDR
116018: GO 116380
116020: LD_INT 17
116022: DOUBLE
116023: EQUAL
116024: IFTRUE 116028
116026: GO 116056
116028: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
116029: LD_ADDR_OWVAR 42
116033: PUSH
116034: LD_INT 19
116036: PUSH
116037: LD_INT 23
116039: PUSH
116040: LD_INT 19
116042: PUSH
116043: EMPTY
116044: LIST
116045: LIST
116046: LIST
116047: PUSH
116048: LD_VAR 0 1
116052: ARRAY
116053: ST_TO_ADDR
116054: GO 116380
116056: LD_INT 18
116058: DOUBLE
116059: EQUAL
116060: IFTRUE 116064
116062: GO 116075
116064: POP
// bc_type := b_ext_radar ; 19 :
116065: LD_ADDR_OWVAR 42
116069: PUSH
116070: LD_INT 20
116072: ST_TO_ADDR
116073: GO 116380
116075: LD_INT 19
116077: DOUBLE
116078: EQUAL
116079: IFTRUE 116083
116081: GO 116094
116083: POP
// bc_type := b_ext_radio ; 20 :
116084: LD_ADDR_OWVAR 42
116088: PUSH
116089: LD_INT 22
116091: ST_TO_ADDR
116092: GO 116380
116094: LD_INT 20
116096: DOUBLE
116097: EQUAL
116098: IFTRUE 116102
116100: GO 116113
116102: POP
// bc_type := b_ext_siberium ; 21 :
116103: LD_ADDR_OWVAR 42
116107: PUSH
116108: LD_INT 21
116110: ST_TO_ADDR
116111: GO 116380
116113: LD_INT 21
116115: DOUBLE
116116: EQUAL
116117: IFTRUE 116121
116119: GO 116132
116121: POP
// bc_type := b_ext_computer ; 22 :
116122: LD_ADDR_OWVAR 42
116126: PUSH
116127: LD_INT 24
116129: ST_TO_ADDR
116130: GO 116380
116132: LD_INT 22
116134: DOUBLE
116135: EQUAL
116136: IFTRUE 116140
116138: GO 116151
116140: POP
// bc_type := b_ext_track ; 23 :
116141: LD_ADDR_OWVAR 42
116145: PUSH
116146: LD_INT 16
116148: ST_TO_ADDR
116149: GO 116380
116151: LD_INT 23
116153: DOUBLE
116154: EQUAL
116155: IFTRUE 116159
116157: GO 116170
116159: POP
// bc_type := b_ext_laser ; 24 :
116160: LD_ADDR_OWVAR 42
116164: PUSH
116165: LD_INT 25
116167: ST_TO_ADDR
116168: GO 116380
116170: LD_INT 24
116172: DOUBLE
116173: EQUAL
116174: IFTRUE 116178
116176: GO 116189
116178: POP
// bc_type := b_control_tower ; 25 :
116179: LD_ADDR_OWVAR 42
116183: PUSH
116184: LD_INT 36
116186: ST_TO_ADDR
116187: GO 116380
116189: LD_INT 25
116191: DOUBLE
116192: EQUAL
116193: IFTRUE 116197
116195: GO 116208
116197: POP
// bc_type := b_breastwork ; 26 :
116198: LD_ADDR_OWVAR 42
116202: PUSH
116203: LD_INT 31
116205: ST_TO_ADDR
116206: GO 116380
116208: LD_INT 26
116210: DOUBLE
116211: EQUAL
116212: IFTRUE 116216
116214: GO 116227
116216: POP
// bc_type := b_bunker ; 27 :
116217: LD_ADDR_OWVAR 42
116221: PUSH
116222: LD_INT 32
116224: ST_TO_ADDR
116225: GO 116380
116227: LD_INT 27
116229: DOUBLE
116230: EQUAL
116231: IFTRUE 116235
116233: GO 116246
116235: POP
// bc_type := b_turret ; 28 :
116236: LD_ADDR_OWVAR 42
116240: PUSH
116241: LD_INT 33
116243: ST_TO_ADDR
116244: GO 116380
116246: LD_INT 28
116248: DOUBLE
116249: EQUAL
116250: IFTRUE 116254
116252: GO 116265
116254: POP
// bc_type := b_armoury ; 29 :
116255: LD_ADDR_OWVAR 42
116259: PUSH
116260: LD_INT 4
116262: ST_TO_ADDR
116263: GO 116380
116265: LD_INT 29
116267: DOUBLE
116268: EQUAL
116269: IFTRUE 116273
116271: GO 116284
116273: POP
// bc_type := b_barracks ; 30 :
116274: LD_ADDR_OWVAR 42
116278: PUSH
116279: LD_INT 5
116281: ST_TO_ADDR
116282: GO 116380
116284: LD_INT 30
116286: DOUBLE
116287: EQUAL
116288: IFTRUE 116292
116290: GO 116303
116292: POP
// bc_type := b_solar_power ; 31 :
116293: LD_ADDR_OWVAR 42
116297: PUSH
116298: LD_INT 27
116300: ST_TO_ADDR
116301: GO 116380
116303: LD_INT 31
116305: DOUBLE
116306: EQUAL
116307: IFTRUE 116311
116309: GO 116322
116311: POP
// bc_type := b_oil_power ; 32 :
116312: LD_ADDR_OWVAR 42
116316: PUSH
116317: LD_INT 26
116319: ST_TO_ADDR
116320: GO 116380
116322: LD_INT 32
116324: DOUBLE
116325: EQUAL
116326: IFTRUE 116330
116328: GO 116341
116330: POP
// bc_type := b_siberite_power ; 33 :
116331: LD_ADDR_OWVAR 42
116335: PUSH
116336: LD_INT 28
116338: ST_TO_ADDR
116339: GO 116380
116341: LD_INT 33
116343: DOUBLE
116344: EQUAL
116345: IFTRUE 116349
116347: GO 116360
116349: POP
// bc_type := b_oil_mine ; 34 :
116350: LD_ADDR_OWVAR 42
116354: PUSH
116355: LD_INT 29
116357: ST_TO_ADDR
116358: GO 116380
116360: LD_INT 34
116362: DOUBLE
116363: EQUAL
116364: IFTRUE 116368
116366: GO 116379
116368: POP
// bc_type := b_siberite_mine ; end ;
116369: LD_ADDR_OWVAR 42
116373: PUSH
116374: LD_INT 30
116376: ST_TO_ADDR
116377: GO 116380
116379: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
116380: LD_ADDR_VAR 0 8
116384: PUSH
116385: LD_VAR 0 5
116389: PPUSH
116390: LD_VAR 0 6
116394: PPUSH
116395: LD_VAR 0 3
116399: PPUSH
116400: CALL_OW 47
116404: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
116405: LD_OWVAR 42
116409: PUSH
116410: LD_INT 32
116412: PUSH
116413: LD_INT 33
116415: PUSH
116416: EMPTY
116417: LIST
116418: LIST
116419: IN
116420: IFFALSE 116436
// PlaceWeaponTurret ( b , weapon ) ;
116422: LD_VAR 0 8
116426: PPUSH
116427: LD_VAR 0 4
116431: PPUSH
116432: CALL_OW 431
// end ;
116436: LD_VAR 0 7
116440: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
116441: LD_INT 0
116443: PPUSH
116444: PPUSH
116445: PPUSH
116446: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116447: LD_ADDR_VAR 0 4
116451: PUSH
116452: LD_INT 22
116454: PUSH
116455: LD_OWVAR 2
116459: PUSH
116460: EMPTY
116461: LIST
116462: LIST
116463: PUSH
116464: LD_INT 2
116466: PUSH
116467: LD_INT 30
116469: PUSH
116470: LD_INT 0
116472: PUSH
116473: EMPTY
116474: LIST
116475: LIST
116476: PUSH
116477: LD_INT 30
116479: PUSH
116480: LD_INT 1
116482: PUSH
116483: EMPTY
116484: LIST
116485: LIST
116486: PUSH
116487: EMPTY
116488: LIST
116489: LIST
116490: LIST
116491: PUSH
116492: EMPTY
116493: LIST
116494: LIST
116495: PPUSH
116496: CALL_OW 69
116500: ST_TO_ADDR
// if not tmp then
116501: LD_VAR 0 4
116505: NOT
116506: IFFALSE 116510
// exit ;
116508: GO 116569
// for i in tmp do
116510: LD_ADDR_VAR 0 2
116514: PUSH
116515: LD_VAR 0 4
116519: PUSH
116520: FOR_IN
116521: IFFALSE 116567
// for j = 1 to 3 do
116523: LD_ADDR_VAR 0 3
116527: PUSH
116528: DOUBLE
116529: LD_INT 1
116531: DEC
116532: ST_TO_ADDR
116533: LD_INT 3
116535: PUSH
116536: FOR_TO
116537: IFFALSE 116563
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
116539: LD_VAR 0 2
116543: PPUSH
116544: CALL_OW 274
116548: PPUSH
116549: LD_VAR 0 3
116553: PPUSH
116554: LD_INT 99999
116556: PPUSH
116557: CALL_OW 277
116561: GO 116536
116563: POP
116564: POP
116565: GO 116520
116567: POP
116568: POP
// end ;
116569: LD_VAR 0 1
116573: RET
// export function hHackSetLevel10 ; var i , j ; begin
116574: LD_INT 0
116576: PPUSH
116577: PPUSH
116578: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
116579: LD_ADDR_VAR 0 2
116583: PUSH
116584: LD_INT 21
116586: PUSH
116587: LD_INT 1
116589: PUSH
116590: EMPTY
116591: LIST
116592: LIST
116593: PPUSH
116594: CALL_OW 69
116598: PUSH
116599: FOR_IN
116600: IFFALSE 116652
// if IsSelected ( i ) then
116602: LD_VAR 0 2
116606: PPUSH
116607: CALL_OW 306
116611: IFFALSE 116650
// begin for j := 1 to 4 do
116613: LD_ADDR_VAR 0 3
116617: PUSH
116618: DOUBLE
116619: LD_INT 1
116621: DEC
116622: ST_TO_ADDR
116623: LD_INT 4
116625: PUSH
116626: FOR_TO
116627: IFFALSE 116648
// SetSkill ( i , j , 10 ) ;
116629: LD_VAR 0 2
116633: PPUSH
116634: LD_VAR 0 3
116638: PPUSH
116639: LD_INT 10
116641: PPUSH
116642: CALL_OW 237
116646: GO 116626
116648: POP
116649: POP
// end ;
116650: GO 116599
116652: POP
116653: POP
// end ;
116654: LD_VAR 0 1
116658: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
116659: LD_INT 0
116661: PPUSH
116662: PPUSH
116663: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
116664: LD_ADDR_VAR 0 2
116668: PUSH
116669: LD_INT 22
116671: PUSH
116672: LD_OWVAR 2
116676: PUSH
116677: EMPTY
116678: LIST
116679: LIST
116680: PUSH
116681: LD_INT 21
116683: PUSH
116684: LD_INT 1
116686: PUSH
116687: EMPTY
116688: LIST
116689: LIST
116690: PUSH
116691: EMPTY
116692: LIST
116693: LIST
116694: PPUSH
116695: CALL_OW 69
116699: PUSH
116700: FOR_IN
116701: IFFALSE 116742
// begin for j := 1 to 4 do
116703: LD_ADDR_VAR 0 3
116707: PUSH
116708: DOUBLE
116709: LD_INT 1
116711: DEC
116712: ST_TO_ADDR
116713: LD_INT 4
116715: PUSH
116716: FOR_TO
116717: IFFALSE 116738
// SetSkill ( i , j , 10 ) ;
116719: LD_VAR 0 2
116723: PPUSH
116724: LD_VAR 0 3
116728: PPUSH
116729: LD_INT 10
116731: PPUSH
116732: CALL_OW 237
116736: GO 116716
116738: POP
116739: POP
// end ;
116740: GO 116700
116742: POP
116743: POP
// end ;
116744: LD_VAR 0 1
116748: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
116749: LD_INT 0
116751: PPUSH
// uc_side := your_side ;
116752: LD_ADDR_OWVAR 20
116756: PUSH
116757: LD_OWVAR 2
116761: ST_TO_ADDR
// uc_nation := nation ;
116762: LD_ADDR_OWVAR 21
116766: PUSH
116767: LD_VAR 0 1
116771: ST_TO_ADDR
// InitHc ;
116772: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
116776: LD_INT 0
116778: PPUSH
116779: LD_VAR 0 2
116783: PPUSH
116784: LD_VAR 0 3
116788: PPUSH
116789: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
116793: LD_VAR 0 4
116797: PPUSH
116798: LD_VAR 0 5
116802: PPUSH
116803: CALL_OW 428
116807: PUSH
116808: LD_INT 0
116810: EQUAL
116811: IFFALSE 116835
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
116813: CALL_OW 44
116817: PPUSH
116818: LD_VAR 0 4
116822: PPUSH
116823: LD_VAR 0 5
116827: PPUSH
116828: LD_INT 1
116830: PPUSH
116831: CALL_OW 48
// end ;
116835: LD_VAR 0 6
116839: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
116840: LD_INT 0
116842: PPUSH
116843: PPUSH
// uc_side := your_side ;
116844: LD_ADDR_OWVAR 20
116848: PUSH
116849: LD_OWVAR 2
116853: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
116854: LD_VAR 0 1
116858: PUSH
116859: LD_INT 1
116861: PUSH
116862: LD_INT 2
116864: PUSH
116865: LD_INT 3
116867: PUSH
116868: LD_INT 4
116870: PUSH
116871: LD_INT 5
116873: PUSH
116874: EMPTY
116875: LIST
116876: LIST
116877: LIST
116878: LIST
116879: LIST
116880: IN
116881: IFFALSE 116893
// uc_nation := nation_american else
116883: LD_ADDR_OWVAR 21
116887: PUSH
116888: LD_INT 1
116890: ST_TO_ADDR
116891: GO 116936
// if chassis in [ 11 , 12 , 13 , 14 ] then
116893: LD_VAR 0 1
116897: PUSH
116898: LD_INT 11
116900: PUSH
116901: LD_INT 12
116903: PUSH
116904: LD_INT 13
116906: PUSH
116907: LD_INT 14
116909: PUSH
116910: EMPTY
116911: LIST
116912: LIST
116913: LIST
116914: LIST
116915: IN
116916: IFFALSE 116928
// uc_nation := nation_arabian else
116918: LD_ADDR_OWVAR 21
116922: PUSH
116923: LD_INT 2
116925: ST_TO_ADDR
116926: GO 116936
// uc_nation := nation_russian ;
116928: LD_ADDR_OWVAR 21
116932: PUSH
116933: LD_INT 3
116935: ST_TO_ADDR
// vc_chassis := chassis ;
116936: LD_ADDR_OWVAR 37
116940: PUSH
116941: LD_VAR 0 1
116945: ST_TO_ADDR
// vc_engine := engine ;
116946: LD_ADDR_OWVAR 39
116950: PUSH
116951: LD_VAR 0 2
116955: ST_TO_ADDR
// vc_control := control ;
116956: LD_ADDR_OWVAR 38
116960: PUSH
116961: LD_VAR 0 3
116965: ST_TO_ADDR
// vc_weapon := weapon ;
116966: LD_ADDR_OWVAR 40
116970: PUSH
116971: LD_VAR 0 4
116975: ST_TO_ADDR
// un := CreateVehicle ;
116976: LD_ADDR_VAR 0 8
116980: PUSH
116981: CALL_OW 45
116985: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
116986: LD_VAR 0 8
116990: PPUSH
116991: LD_INT 0
116993: PPUSH
116994: LD_INT 5
116996: PPUSH
116997: CALL_OW 12
117001: PPUSH
117002: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
117006: LD_VAR 0 8
117010: PPUSH
117011: LD_VAR 0 5
117015: PPUSH
117016: LD_VAR 0 6
117020: PPUSH
117021: LD_INT 1
117023: PPUSH
117024: CALL_OW 48
// end ;
117028: LD_VAR 0 7
117032: RET
// export hInvincible ; every 1 do
117033: GO 117035
117035: DISABLE
// hInvincible := [ ] ;
117036: LD_ADDR_EXP 214
117040: PUSH
117041: EMPTY
117042: ST_TO_ADDR
117043: END
// every 10 do var i ;
117044: GO 117046
117046: DISABLE
117047: LD_INT 0
117049: PPUSH
// begin enable ;
117050: ENABLE
// if not hInvincible then
117051: LD_EXP 214
117055: NOT
117056: IFFALSE 117060
// exit ;
117058: GO 117104
// for i in hInvincible do
117060: LD_ADDR_VAR 0 1
117064: PUSH
117065: LD_EXP 214
117069: PUSH
117070: FOR_IN
117071: IFFALSE 117102
// if GetLives ( i ) < 1000 then
117073: LD_VAR 0 1
117077: PPUSH
117078: CALL_OW 256
117082: PUSH
117083: LD_INT 1000
117085: LESS
117086: IFFALSE 117100
// SetLives ( i , 1000 ) ;
117088: LD_VAR 0 1
117092: PPUSH
117093: LD_INT 1000
117095: PPUSH
117096: CALL_OW 234
117100: GO 117070
117102: POP
117103: POP
// end ;
117104: PPOPN 1
117106: END
// export function hHackInvincible ; var i ; begin
117107: LD_INT 0
117109: PPUSH
117110: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
117111: LD_ADDR_VAR 0 2
117115: PUSH
117116: LD_INT 2
117118: PUSH
117119: LD_INT 21
117121: PUSH
117122: LD_INT 1
117124: PUSH
117125: EMPTY
117126: LIST
117127: LIST
117128: PUSH
117129: LD_INT 21
117131: PUSH
117132: LD_INT 2
117134: PUSH
117135: EMPTY
117136: LIST
117137: LIST
117138: PUSH
117139: EMPTY
117140: LIST
117141: LIST
117142: LIST
117143: PPUSH
117144: CALL_OW 69
117148: PUSH
117149: FOR_IN
117150: IFFALSE 117211
// if IsSelected ( i ) then
117152: LD_VAR 0 2
117156: PPUSH
117157: CALL_OW 306
117161: IFFALSE 117209
// begin if i in hInvincible then
117163: LD_VAR 0 2
117167: PUSH
117168: LD_EXP 214
117172: IN
117173: IFFALSE 117193
// hInvincible := hInvincible diff i else
117175: LD_ADDR_EXP 214
117179: PUSH
117180: LD_EXP 214
117184: PUSH
117185: LD_VAR 0 2
117189: DIFF
117190: ST_TO_ADDR
117191: GO 117209
// hInvincible := hInvincible union i ;
117193: LD_ADDR_EXP 214
117197: PUSH
117198: LD_EXP 214
117202: PUSH
117203: LD_VAR 0 2
117207: UNION
117208: ST_TO_ADDR
// end ;
117209: GO 117149
117211: POP
117212: POP
// end ;
117213: LD_VAR 0 1
117217: RET
// export function hHackInvisible ; var i , j ; begin
117218: LD_INT 0
117220: PPUSH
117221: PPUSH
117222: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
117223: LD_ADDR_VAR 0 2
117227: PUSH
117228: LD_INT 21
117230: PUSH
117231: LD_INT 1
117233: PUSH
117234: EMPTY
117235: LIST
117236: LIST
117237: PPUSH
117238: CALL_OW 69
117242: PUSH
117243: FOR_IN
117244: IFFALSE 117268
// if IsSelected ( i ) then
117246: LD_VAR 0 2
117250: PPUSH
117251: CALL_OW 306
117255: IFFALSE 117266
// ComForceInvisible ( i ) ;
117257: LD_VAR 0 2
117261: PPUSH
117262: CALL_OW 496
117266: GO 117243
117268: POP
117269: POP
// end ;
117270: LD_VAR 0 1
117274: RET
// export function hHackChangeYourSide ; begin
117275: LD_INT 0
117277: PPUSH
// if your_side = 8 then
117278: LD_OWVAR 2
117282: PUSH
117283: LD_INT 8
117285: EQUAL
117286: IFFALSE 117298
// your_side := 0 else
117288: LD_ADDR_OWVAR 2
117292: PUSH
117293: LD_INT 0
117295: ST_TO_ADDR
117296: GO 117312
// your_side := your_side + 1 ;
117298: LD_ADDR_OWVAR 2
117302: PUSH
117303: LD_OWVAR 2
117307: PUSH
117308: LD_INT 1
117310: PLUS
117311: ST_TO_ADDR
// end ;
117312: LD_VAR 0 1
117316: RET
// export function hHackChangeUnitSide ; var i , j ; begin
117317: LD_INT 0
117319: PPUSH
117320: PPUSH
117321: PPUSH
// for i in all_units do
117322: LD_ADDR_VAR 0 2
117326: PUSH
117327: LD_OWVAR 3
117331: PUSH
117332: FOR_IN
117333: IFFALSE 117411
// if IsSelected ( i ) then
117335: LD_VAR 0 2
117339: PPUSH
117340: CALL_OW 306
117344: IFFALSE 117409
// begin j := GetSide ( i ) ;
117346: LD_ADDR_VAR 0 3
117350: PUSH
117351: LD_VAR 0 2
117355: PPUSH
117356: CALL_OW 255
117360: ST_TO_ADDR
// if j = 8 then
117361: LD_VAR 0 3
117365: PUSH
117366: LD_INT 8
117368: EQUAL
117369: IFFALSE 117381
// j := 0 else
117371: LD_ADDR_VAR 0 3
117375: PUSH
117376: LD_INT 0
117378: ST_TO_ADDR
117379: GO 117395
// j := j + 1 ;
117381: LD_ADDR_VAR 0 3
117385: PUSH
117386: LD_VAR 0 3
117390: PUSH
117391: LD_INT 1
117393: PLUS
117394: ST_TO_ADDR
// SetSide ( i , j ) ;
117395: LD_VAR 0 2
117399: PPUSH
117400: LD_VAR 0 3
117404: PPUSH
117405: CALL_OW 235
// end ;
117409: GO 117332
117411: POP
117412: POP
// end ;
117413: LD_VAR 0 1
117417: RET
// export function hHackFog ; begin
117418: LD_INT 0
117420: PPUSH
// FogOff ( true ) ;
117421: LD_INT 1
117423: PPUSH
117424: CALL_OW 344
// end ;
117428: LD_VAR 0 1
117432: RET
// export function hHackTeleport ( unit , x , y ) ; begin
117433: LD_INT 0
117435: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
117436: LD_VAR 0 1
117440: PPUSH
117441: LD_VAR 0 2
117445: PPUSH
117446: LD_VAR 0 3
117450: PPUSH
117451: LD_INT 1
117453: PPUSH
117454: LD_INT 1
117456: PPUSH
117457: CALL_OW 483
// CenterOnXY ( x , y ) ;
117461: LD_VAR 0 2
117465: PPUSH
117466: LD_VAR 0 3
117470: PPUSH
117471: CALL_OW 84
// end ; end_of_file
117475: LD_VAR 0 4
117479: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
117480: LD_INT 0
117482: PPUSH
117483: PPUSH
117484: PPUSH
117485: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
117486: LD_VAR 0 1
117490: PPUSH
117491: CALL_OW 264
117495: PUSH
117496: LD_EXP 99
117500: EQUAL
117501: IFFALSE 117573
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
117503: LD_INT 68
117505: PPUSH
117506: LD_VAR 0 1
117510: PPUSH
117511: CALL_OW 255
117515: PPUSH
117516: CALL_OW 321
117520: PUSH
117521: LD_INT 2
117523: EQUAL
117524: IFFALSE 117536
// eff := 70 else
117526: LD_ADDR_VAR 0 4
117530: PUSH
117531: LD_INT 70
117533: ST_TO_ADDR
117534: GO 117544
// eff := 30 ;
117536: LD_ADDR_VAR 0 4
117540: PUSH
117541: LD_INT 30
117543: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
117544: LD_VAR 0 1
117548: PPUSH
117549: CALL_OW 250
117553: PPUSH
117554: LD_VAR 0 1
117558: PPUSH
117559: CALL_OW 251
117563: PPUSH
117564: LD_VAR 0 4
117568: PPUSH
117569: CALL_OW 495
// end ; end ;
117573: LD_VAR 0 2
117577: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
117578: LD_INT 0
117580: PPUSH
// end ;
117581: LD_VAR 0 4
117585: RET
// export function SOS_Command ( cmd ) ; begin
117586: LD_INT 0
117588: PPUSH
// end ;
117589: LD_VAR 0 2
117593: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
117594: LD_INT 0
117596: PPUSH
// if cmd = 121 then
117597: LD_VAR 0 1
117601: PUSH
117602: LD_INT 121
117604: EQUAL
117605: IFFALSE 117607
// end ;
117607: LD_VAR 0 6
117611: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
117612: LD_INT 0
117614: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
117615: LD_VAR 0 1
117619: PUSH
117620: LD_INT 250
117622: EQUAL
117623: PUSH
117624: LD_VAR 0 2
117628: PPUSH
117629: CALL_OW 264
117633: PUSH
117634: LD_EXP 102
117638: EQUAL
117639: AND
117640: IFFALSE 117661
// MinerPlaceMine ( unit , x , y ) ;
117642: LD_VAR 0 2
117646: PPUSH
117647: LD_VAR 0 4
117651: PPUSH
117652: LD_VAR 0 5
117656: PPUSH
117657: CALL 120010 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
117661: LD_VAR 0 1
117665: PUSH
117666: LD_INT 251
117668: EQUAL
117669: PUSH
117670: LD_VAR 0 2
117674: PPUSH
117675: CALL_OW 264
117679: PUSH
117680: LD_EXP 102
117684: EQUAL
117685: AND
117686: IFFALSE 117707
// MinerDetonateMine ( unit , x , y ) ;
117688: LD_VAR 0 2
117692: PPUSH
117693: LD_VAR 0 4
117697: PPUSH
117698: LD_VAR 0 5
117702: PPUSH
117703: CALL 120287 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
117707: LD_VAR 0 1
117711: PUSH
117712: LD_INT 252
117714: EQUAL
117715: PUSH
117716: LD_VAR 0 2
117720: PPUSH
117721: CALL_OW 264
117725: PUSH
117726: LD_EXP 102
117730: EQUAL
117731: AND
117732: IFFALSE 117753
// MinerCreateMinefield ( unit , x , y ) ;
117734: LD_VAR 0 2
117738: PPUSH
117739: LD_VAR 0 4
117743: PPUSH
117744: LD_VAR 0 5
117748: PPUSH
117749: CALL 120704 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
117753: LD_VAR 0 1
117757: PUSH
117758: LD_INT 253
117760: EQUAL
117761: PUSH
117762: LD_VAR 0 2
117766: PPUSH
117767: CALL_OW 257
117771: PUSH
117772: LD_INT 5
117774: EQUAL
117775: AND
117776: IFFALSE 117797
// ComBinocular ( unit , x , y ) ;
117778: LD_VAR 0 2
117782: PPUSH
117783: LD_VAR 0 4
117787: PPUSH
117788: LD_VAR 0 5
117792: PPUSH
117793: CALL 121075 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
117797: LD_VAR 0 1
117801: PUSH
117802: LD_INT 254
117804: EQUAL
117805: PUSH
117806: LD_VAR 0 2
117810: PPUSH
117811: CALL_OW 264
117815: PUSH
117816: LD_EXP 97
117820: EQUAL
117821: AND
117822: PUSH
117823: LD_VAR 0 3
117827: PPUSH
117828: CALL_OW 263
117832: PUSH
117833: LD_INT 3
117835: EQUAL
117836: AND
117837: IFFALSE 117853
// HackDestroyVehicle ( unit , selectedUnit ) ;
117839: LD_VAR 0 2
117843: PPUSH
117844: LD_VAR 0 3
117848: PPUSH
117849: CALL 119370 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
117853: LD_VAR 0 1
117857: PUSH
117858: LD_INT 255
117860: EQUAL
117861: PUSH
117862: LD_VAR 0 2
117866: PPUSH
117867: CALL_OW 264
117871: PUSH
117872: LD_INT 14
117874: PUSH
117875: LD_INT 53
117877: PUSH
117878: EMPTY
117879: LIST
117880: LIST
117881: IN
117882: AND
117883: PUSH
117884: LD_VAR 0 4
117888: PPUSH
117889: LD_VAR 0 5
117893: PPUSH
117894: CALL_OW 488
117898: AND
117899: IFFALSE 117923
// CutTreeXYR ( unit , x , y , 12 ) ;
117901: LD_VAR 0 2
117905: PPUSH
117906: LD_VAR 0 4
117910: PPUSH
117911: LD_VAR 0 5
117915: PPUSH
117916: LD_INT 12
117918: PPUSH
117919: CALL 117936 0 4
// end ;
117923: LD_VAR 0 6
117927: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
117928: LD_INT 0
117930: PPUSH
// end ;
117931: LD_VAR 0 4
117935: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
117936: LD_INT 0
117938: PPUSH
117939: PPUSH
117940: PPUSH
117941: PPUSH
117942: PPUSH
117943: PPUSH
117944: PPUSH
117945: PPUSH
117946: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
117947: LD_VAR 0 1
117951: NOT
117952: PUSH
117953: LD_VAR 0 2
117957: PPUSH
117958: LD_VAR 0 3
117962: PPUSH
117963: CALL_OW 488
117967: NOT
117968: OR
117969: PUSH
117970: LD_VAR 0 4
117974: NOT
117975: OR
117976: IFFALSE 117980
// exit ;
117978: GO 118320
// list := [ ] ;
117980: LD_ADDR_VAR 0 13
117984: PUSH
117985: EMPTY
117986: ST_TO_ADDR
// if x - r < 0 then
117987: LD_VAR 0 2
117991: PUSH
117992: LD_VAR 0 4
117996: MINUS
117997: PUSH
117998: LD_INT 0
118000: LESS
118001: IFFALSE 118013
// min_x := 0 else
118003: LD_ADDR_VAR 0 7
118007: PUSH
118008: LD_INT 0
118010: ST_TO_ADDR
118011: GO 118029
// min_x := x - r ;
118013: LD_ADDR_VAR 0 7
118017: PUSH
118018: LD_VAR 0 2
118022: PUSH
118023: LD_VAR 0 4
118027: MINUS
118028: ST_TO_ADDR
// if y - r < 0 then
118029: LD_VAR 0 3
118033: PUSH
118034: LD_VAR 0 4
118038: MINUS
118039: PUSH
118040: LD_INT 0
118042: LESS
118043: IFFALSE 118055
// min_y := 0 else
118045: LD_ADDR_VAR 0 8
118049: PUSH
118050: LD_INT 0
118052: ST_TO_ADDR
118053: GO 118071
// min_y := y - r ;
118055: LD_ADDR_VAR 0 8
118059: PUSH
118060: LD_VAR 0 3
118064: PUSH
118065: LD_VAR 0 4
118069: MINUS
118070: ST_TO_ADDR
// max_x := x + r ;
118071: LD_ADDR_VAR 0 9
118075: PUSH
118076: LD_VAR 0 2
118080: PUSH
118081: LD_VAR 0 4
118085: PLUS
118086: ST_TO_ADDR
// max_y := y + r ;
118087: LD_ADDR_VAR 0 10
118091: PUSH
118092: LD_VAR 0 3
118096: PUSH
118097: LD_VAR 0 4
118101: PLUS
118102: ST_TO_ADDR
// for _x = min_x to max_x do
118103: LD_ADDR_VAR 0 11
118107: PUSH
118108: DOUBLE
118109: LD_VAR 0 7
118113: DEC
118114: ST_TO_ADDR
118115: LD_VAR 0 9
118119: PUSH
118120: FOR_TO
118121: IFFALSE 118238
// for _y = min_y to max_y do
118123: LD_ADDR_VAR 0 12
118127: PUSH
118128: DOUBLE
118129: LD_VAR 0 8
118133: DEC
118134: ST_TO_ADDR
118135: LD_VAR 0 10
118139: PUSH
118140: FOR_TO
118141: IFFALSE 118234
// begin if not ValidHex ( _x , _y ) then
118143: LD_VAR 0 11
118147: PPUSH
118148: LD_VAR 0 12
118152: PPUSH
118153: CALL_OW 488
118157: NOT
118158: IFFALSE 118162
// continue ;
118160: GO 118140
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
118162: LD_VAR 0 11
118166: PPUSH
118167: LD_VAR 0 12
118171: PPUSH
118172: CALL_OW 351
118176: PUSH
118177: LD_VAR 0 11
118181: PPUSH
118182: LD_VAR 0 12
118186: PPUSH
118187: CALL_OW 554
118191: AND
118192: IFFALSE 118232
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
118194: LD_ADDR_VAR 0 13
118198: PUSH
118199: LD_VAR 0 13
118203: PPUSH
118204: LD_VAR 0 13
118208: PUSH
118209: LD_INT 1
118211: PLUS
118212: PPUSH
118213: LD_VAR 0 11
118217: PUSH
118218: LD_VAR 0 12
118222: PUSH
118223: EMPTY
118224: LIST
118225: LIST
118226: PPUSH
118227: CALL_OW 2
118231: ST_TO_ADDR
// end ;
118232: GO 118140
118234: POP
118235: POP
118236: GO 118120
118238: POP
118239: POP
// if not list then
118240: LD_VAR 0 13
118244: NOT
118245: IFFALSE 118249
// exit ;
118247: GO 118320
// for i in list do
118249: LD_ADDR_VAR 0 6
118253: PUSH
118254: LD_VAR 0 13
118258: PUSH
118259: FOR_IN
118260: IFFALSE 118318
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
118262: LD_VAR 0 1
118266: PPUSH
118267: LD_STRING M
118269: PUSH
118270: LD_VAR 0 6
118274: PUSH
118275: LD_INT 1
118277: ARRAY
118278: PUSH
118279: LD_VAR 0 6
118283: PUSH
118284: LD_INT 2
118286: ARRAY
118287: PUSH
118288: LD_INT 0
118290: PUSH
118291: LD_INT 0
118293: PUSH
118294: LD_INT 0
118296: PUSH
118297: LD_INT 0
118299: PUSH
118300: EMPTY
118301: LIST
118302: LIST
118303: LIST
118304: LIST
118305: LIST
118306: LIST
118307: LIST
118308: PUSH
118309: EMPTY
118310: LIST
118311: PPUSH
118312: CALL_OW 447
118316: GO 118259
118318: POP
118319: POP
// end ;
118320: LD_VAR 0 5
118324: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
118325: LD_EXP 217
118329: NOT
118330: IFFALSE 118380
118332: GO 118334
118334: DISABLE
// begin initHack := true ;
118335: LD_ADDR_EXP 217
118339: PUSH
118340: LD_INT 1
118342: ST_TO_ADDR
// hackTanks := [ ] ;
118343: LD_ADDR_EXP 218
118347: PUSH
118348: EMPTY
118349: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
118350: LD_ADDR_EXP 219
118354: PUSH
118355: EMPTY
118356: ST_TO_ADDR
// hackLimit := 3 ;
118357: LD_ADDR_EXP 220
118361: PUSH
118362: LD_INT 3
118364: ST_TO_ADDR
// hackDist := 12 ;
118365: LD_ADDR_EXP 221
118369: PUSH
118370: LD_INT 12
118372: ST_TO_ADDR
// hackCounter := [ ] ;
118373: LD_ADDR_EXP 222
118377: PUSH
118378: EMPTY
118379: ST_TO_ADDR
// end ;
118380: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
118381: LD_EXP 217
118385: PUSH
118386: LD_INT 34
118388: PUSH
118389: LD_EXP 97
118393: PUSH
118394: EMPTY
118395: LIST
118396: LIST
118397: PPUSH
118398: CALL_OW 69
118402: AND
118403: IFFALSE 118658
118405: GO 118407
118407: DISABLE
118408: LD_INT 0
118410: PPUSH
118411: PPUSH
// begin enable ;
118412: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
118413: LD_ADDR_VAR 0 1
118417: PUSH
118418: LD_INT 34
118420: PUSH
118421: LD_EXP 97
118425: PUSH
118426: EMPTY
118427: LIST
118428: LIST
118429: PPUSH
118430: CALL_OW 69
118434: PUSH
118435: FOR_IN
118436: IFFALSE 118656
// begin if not i in hackTanks then
118438: LD_VAR 0 1
118442: PUSH
118443: LD_EXP 218
118447: IN
118448: NOT
118449: IFFALSE 118532
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
118451: LD_ADDR_EXP 218
118455: PUSH
118456: LD_EXP 218
118460: PPUSH
118461: LD_EXP 218
118465: PUSH
118466: LD_INT 1
118468: PLUS
118469: PPUSH
118470: LD_VAR 0 1
118474: PPUSH
118475: CALL_OW 1
118479: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
118480: LD_ADDR_EXP 219
118484: PUSH
118485: LD_EXP 219
118489: PPUSH
118490: LD_EXP 219
118494: PUSH
118495: LD_INT 1
118497: PLUS
118498: PPUSH
118499: EMPTY
118500: PPUSH
118501: CALL_OW 1
118505: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
118506: LD_ADDR_EXP 222
118510: PUSH
118511: LD_EXP 222
118515: PPUSH
118516: LD_EXP 222
118520: PUSH
118521: LD_INT 1
118523: PLUS
118524: PPUSH
118525: EMPTY
118526: PPUSH
118527: CALL_OW 1
118531: ST_TO_ADDR
// end ; if not IsOk ( i ) then
118532: LD_VAR 0 1
118536: PPUSH
118537: CALL_OW 302
118541: NOT
118542: IFFALSE 118555
// begin HackUnlinkAll ( i ) ;
118544: LD_VAR 0 1
118548: PPUSH
118549: CALL 118661 0 1
// continue ;
118553: GO 118435
// end ; HackCheckCapturedStatus ( i ) ;
118555: LD_VAR 0 1
118559: PPUSH
118560: CALL 119104 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
118564: LD_ADDR_VAR 0 2
118568: PUSH
118569: LD_INT 81
118571: PUSH
118572: LD_VAR 0 1
118576: PPUSH
118577: CALL_OW 255
118581: PUSH
118582: EMPTY
118583: LIST
118584: LIST
118585: PUSH
118586: LD_INT 33
118588: PUSH
118589: LD_INT 3
118591: PUSH
118592: EMPTY
118593: LIST
118594: LIST
118595: PUSH
118596: LD_INT 91
118598: PUSH
118599: LD_VAR 0 1
118603: PUSH
118604: LD_EXP 221
118608: PUSH
118609: EMPTY
118610: LIST
118611: LIST
118612: LIST
118613: PUSH
118614: LD_INT 50
118616: PUSH
118617: EMPTY
118618: LIST
118619: PUSH
118620: EMPTY
118621: LIST
118622: LIST
118623: LIST
118624: LIST
118625: PPUSH
118626: CALL_OW 69
118630: ST_TO_ADDR
// if not tmp then
118631: LD_VAR 0 2
118635: NOT
118636: IFFALSE 118640
// continue ;
118638: GO 118435
// HackLink ( i , tmp ) ;
118640: LD_VAR 0 1
118644: PPUSH
118645: LD_VAR 0 2
118649: PPUSH
118650: CALL 118797 0 2
// end ;
118654: GO 118435
118656: POP
118657: POP
// end ;
118658: PPOPN 2
118660: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
118661: LD_INT 0
118663: PPUSH
118664: PPUSH
118665: PPUSH
// if not hack in hackTanks then
118666: LD_VAR 0 1
118670: PUSH
118671: LD_EXP 218
118675: IN
118676: NOT
118677: IFFALSE 118681
// exit ;
118679: GO 118792
// index := GetElementIndex ( hackTanks , hack ) ;
118681: LD_ADDR_VAR 0 4
118685: PUSH
118686: LD_EXP 218
118690: PPUSH
118691: LD_VAR 0 1
118695: PPUSH
118696: CALL 70324 0 2
118700: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
118701: LD_EXP 219
118705: PUSH
118706: LD_VAR 0 4
118710: ARRAY
118711: IFFALSE 118792
// begin for i in hackTanksCaptured [ index ] do
118713: LD_ADDR_VAR 0 3
118717: PUSH
118718: LD_EXP 219
118722: PUSH
118723: LD_VAR 0 4
118727: ARRAY
118728: PUSH
118729: FOR_IN
118730: IFFALSE 118756
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
118732: LD_VAR 0 3
118736: PUSH
118737: LD_INT 1
118739: ARRAY
118740: PPUSH
118741: LD_VAR 0 3
118745: PUSH
118746: LD_INT 2
118748: ARRAY
118749: PPUSH
118750: CALL_OW 235
118754: GO 118729
118756: POP
118757: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
118758: LD_ADDR_EXP 219
118762: PUSH
118763: LD_EXP 219
118767: PPUSH
118768: LD_VAR 0 4
118772: PPUSH
118773: EMPTY
118774: PPUSH
118775: CALL_OW 1
118779: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
118780: LD_VAR 0 1
118784: PPUSH
118785: LD_INT 0
118787: PPUSH
118788: CALL_OW 505
// end ; end ;
118792: LD_VAR 0 2
118796: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
118797: LD_INT 0
118799: PPUSH
118800: PPUSH
118801: PPUSH
// if not hack in hackTanks or not vehicles then
118802: LD_VAR 0 1
118806: PUSH
118807: LD_EXP 218
118811: IN
118812: NOT
118813: PUSH
118814: LD_VAR 0 2
118818: NOT
118819: OR
118820: IFFALSE 118824
// exit ;
118822: GO 119099
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
118824: LD_ADDR_VAR 0 2
118828: PUSH
118829: LD_VAR 0 1
118833: PPUSH
118834: LD_VAR 0 2
118838: PPUSH
118839: LD_INT 1
118841: PPUSH
118842: LD_INT 1
118844: PPUSH
118845: CALL 70974 0 4
118849: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
118850: LD_ADDR_VAR 0 5
118854: PUSH
118855: LD_EXP 218
118859: PPUSH
118860: LD_VAR 0 1
118864: PPUSH
118865: CALL 70324 0 2
118869: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
118870: LD_EXP 219
118874: PUSH
118875: LD_VAR 0 5
118879: ARRAY
118880: PUSH
118881: LD_EXP 220
118885: LESS
118886: IFFALSE 119075
// begin for i := 1 to vehicles do
118888: LD_ADDR_VAR 0 4
118892: PUSH
118893: DOUBLE
118894: LD_INT 1
118896: DEC
118897: ST_TO_ADDR
118898: LD_VAR 0 2
118902: PUSH
118903: FOR_TO
118904: IFFALSE 119073
// begin if hackTanksCaptured [ index ] = hackLimit then
118906: LD_EXP 219
118910: PUSH
118911: LD_VAR 0 5
118915: ARRAY
118916: PUSH
118917: LD_EXP 220
118921: EQUAL
118922: IFFALSE 118926
// break ;
118924: GO 119073
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
118926: LD_ADDR_EXP 222
118930: PUSH
118931: LD_EXP 222
118935: PPUSH
118936: LD_VAR 0 5
118940: PPUSH
118941: LD_EXP 222
118945: PUSH
118946: LD_VAR 0 5
118950: ARRAY
118951: PUSH
118952: LD_INT 1
118954: PLUS
118955: PPUSH
118956: CALL_OW 1
118960: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
118961: LD_ADDR_EXP 219
118965: PUSH
118966: LD_EXP 219
118970: PPUSH
118971: LD_VAR 0 5
118975: PUSH
118976: LD_EXP 219
118980: PUSH
118981: LD_VAR 0 5
118985: ARRAY
118986: PUSH
118987: LD_INT 1
118989: PLUS
118990: PUSH
118991: EMPTY
118992: LIST
118993: LIST
118994: PPUSH
118995: LD_VAR 0 2
118999: PUSH
119000: LD_VAR 0 4
119004: ARRAY
119005: PUSH
119006: LD_VAR 0 2
119010: PUSH
119011: LD_VAR 0 4
119015: ARRAY
119016: PPUSH
119017: CALL_OW 255
119021: PUSH
119022: EMPTY
119023: LIST
119024: LIST
119025: PPUSH
119026: CALL 70539 0 3
119030: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
119031: LD_VAR 0 2
119035: PUSH
119036: LD_VAR 0 4
119040: ARRAY
119041: PPUSH
119042: LD_VAR 0 1
119046: PPUSH
119047: CALL_OW 255
119051: PPUSH
119052: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
119056: LD_VAR 0 2
119060: PUSH
119061: LD_VAR 0 4
119065: ARRAY
119066: PPUSH
119067: CALL_OW 141
// end ;
119071: GO 118903
119073: POP
119074: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
119075: LD_VAR 0 1
119079: PPUSH
119080: LD_EXP 219
119084: PUSH
119085: LD_VAR 0 5
119089: ARRAY
119090: PUSH
119091: LD_INT 0
119093: PLUS
119094: PPUSH
119095: CALL_OW 505
// end ;
119099: LD_VAR 0 3
119103: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
119104: LD_INT 0
119106: PPUSH
119107: PPUSH
119108: PPUSH
119109: PPUSH
// if not hack in hackTanks then
119110: LD_VAR 0 1
119114: PUSH
119115: LD_EXP 218
119119: IN
119120: NOT
119121: IFFALSE 119125
// exit ;
119123: GO 119365
// index := GetElementIndex ( hackTanks , hack ) ;
119125: LD_ADDR_VAR 0 4
119129: PUSH
119130: LD_EXP 218
119134: PPUSH
119135: LD_VAR 0 1
119139: PPUSH
119140: CALL 70324 0 2
119144: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
119145: LD_ADDR_VAR 0 3
119149: PUSH
119150: DOUBLE
119151: LD_EXP 219
119155: PUSH
119156: LD_VAR 0 4
119160: ARRAY
119161: INC
119162: ST_TO_ADDR
119163: LD_INT 1
119165: PUSH
119166: FOR_DOWNTO
119167: IFFALSE 119339
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
119169: LD_ADDR_VAR 0 5
119173: PUSH
119174: LD_EXP 219
119178: PUSH
119179: LD_VAR 0 4
119183: ARRAY
119184: PUSH
119185: LD_VAR 0 3
119189: ARRAY
119190: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
119191: LD_VAR 0 5
119195: PUSH
119196: LD_INT 1
119198: ARRAY
119199: PPUSH
119200: CALL_OW 302
119204: NOT
119205: PUSH
119206: LD_VAR 0 5
119210: PUSH
119211: LD_INT 1
119213: ARRAY
119214: PPUSH
119215: CALL_OW 255
119219: PUSH
119220: LD_VAR 0 1
119224: PPUSH
119225: CALL_OW 255
119229: NONEQUAL
119230: OR
119231: IFFALSE 119337
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
119233: LD_VAR 0 5
119237: PUSH
119238: LD_INT 1
119240: ARRAY
119241: PPUSH
119242: CALL_OW 305
119246: PUSH
119247: LD_VAR 0 5
119251: PUSH
119252: LD_INT 1
119254: ARRAY
119255: PPUSH
119256: CALL_OW 255
119260: PUSH
119261: LD_VAR 0 1
119265: PPUSH
119266: CALL_OW 255
119270: EQUAL
119271: AND
119272: IFFALSE 119296
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
119274: LD_VAR 0 5
119278: PUSH
119279: LD_INT 1
119281: ARRAY
119282: PPUSH
119283: LD_VAR 0 5
119287: PUSH
119288: LD_INT 2
119290: ARRAY
119291: PPUSH
119292: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
119296: LD_ADDR_EXP 219
119300: PUSH
119301: LD_EXP 219
119305: PPUSH
119306: LD_VAR 0 4
119310: PPUSH
119311: LD_EXP 219
119315: PUSH
119316: LD_VAR 0 4
119320: ARRAY
119321: PPUSH
119322: LD_VAR 0 3
119326: PPUSH
119327: CALL_OW 3
119331: PPUSH
119332: CALL_OW 1
119336: ST_TO_ADDR
// end ; end ;
119337: GO 119166
119339: POP
119340: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
119341: LD_VAR 0 1
119345: PPUSH
119346: LD_EXP 219
119350: PUSH
119351: LD_VAR 0 4
119355: ARRAY
119356: PUSH
119357: LD_INT 0
119359: PLUS
119360: PPUSH
119361: CALL_OW 505
// end ;
119365: LD_VAR 0 2
119369: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
119370: LD_INT 0
119372: PPUSH
119373: PPUSH
119374: PPUSH
119375: PPUSH
// if not hack in hackTanks then
119376: LD_VAR 0 1
119380: PUSH
119381: LD_EXP 218
119385: IN
119386: NOT
119387: IFFALSE 119391
// exit ;
119389: GO 119476
// index := GetElementIndex ( hackTanks , hack ) ;
119391: LD_ADDR_VAR 0 5
119395: PUSH
119396: LD_EXP 218
119400: PPUSH
119401: LD_VAR 0 1
119405: PPUSH
119406: CALL 70324 0 2
119410: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
119411: LD_ADDR_VAR 0 4
119415: PUSH
119416: DOUBLE
119417: LD_INT 1
119419: DEC
119420: ST_TO_ADDR
119421: LD_EXP 219
119425: PUSH
119426: LD_VAR 0 5
119430: ARRAY
119431: PUSH
119432: FOR_TO
119433: IFFALSE 119474
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
119435: LD_EXP 219
119439: PUSH
119440: LD_VAR 0 5
119444: ARRAY
119445: PUSH
119446: LD_VAR 0 4
119450: ARRAY
119451: PUSH
119452: LD_INT 1
119454: ARRAY
119455: PUSH
119456: LD_VAR 0 2
119460: EQUAL
119461: IFFALSE 119472
// KillUnit ( vehicle ) ;
119463: LD_VAR 0 2
119467: PPUSH
119468: CALL_OW 66
119472: GO 119432
119474: POP
119475: POP
// end ;
119476: LD_VAR 0 3
119480: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
119481: LD_EXP 223
119485: NOT
119486: IFFALSE 119521
119488: GO 119490
119490: DISABLE
// begin initMiner := true ;
119491: LD_ADDR_EXP 223
119495: PUSH
119496: LD_INT 1
119498: ST_TO_ADDR
// minersList := [ ] ;
119499: LD_ADDR_EXP 224
119503: PUSH
119504: EMPTY
119505: ST_TO_ADDR
// minerMinesList := [ ] ;
119506: LD_ADDR_EXP 225
119510: PUSH
119511: EMPTY
119512: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
119513: LD_ADDR_EXP 226
119517: PUSH
119518: LD_INT 5
119520: ST_TO_ADDR
// end ;
119521: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
119522: LD_EXP 223
119526: PUSH
119527: LD_INT 34
119529: PUSH
119530: LD_EXP 102
119534: PUSH
119535: EMPTY
119536: LIST
119537: LIST
119538: PPUSH
119539: CALL_OW 69
119543: AND
119544: IFFALSE 120007
119546: GO 119548
119548: DISABLE
119549: LD_INT 0
119551: PPUSH
119552: PPUSH
119553: PPUSH
119554: PPUSH
// begin enable ;
119555: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
119556: LD_ADDR_VAR 0 1
119560: PUSH
119561: LD_INT 34
119563: PUSH
119564: LD_EXP 102
119568: PUSH
119569: EMPTY
119570: LIST
119571: LIST
119572: PPUSH
119573: CALL_OW 69
119577: PUSH
119578: FOR_IN
119579: IFFALSE 119651
// begin if not i in minersList then
119581: LD_VAR 0 1
119585: PUSH
119586: LD_EXP 224
119590: IN
119591: NOT
119592: IFFALSE 119649
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
119594: LD_ADDR_EXP 224
119598: PUSH
119599: LD_EXP 224
119603: PPUSH
119604: LD_EXP 224
119608: PUSH
119609: LD_INT 1
119611: PLUS
119612: PPUSH
119613: LD_VAR 0 1
119617: PPUSH
119618: CALL_OW 1
119622: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
119623: LD_ADDR_EXP 225
119627: PUSH
119628: LD_EXP 225
119632: PPUSH
119633: LD_EXP 225
119637: PUSH
119638: LD_INT 1
119640: PLUS
119641: PPUSH
119642: EMPTY
119643: PPUSH
119644: CALL_OW 1
119648: ST_TO_ADDR
// end end ;
119649: GO 119578
119651: POP
119652: POP
// for i := minerMinesList downto 1 do
119653: LD_ADDR_VAR 0 1
119657: PUSH
119658: DOUBLE
119659: LD_EXP 225
119663: INC
119664: ST_TO_ADDR
119665: LD_INT 1
119667: PUSH
119668: FOR_DOWNTO
119669: IFFALSE 120005
// begin if IsLive ( minersList [ i ] ) then
119671: LD_EXP 224
119675: PUSH
119676: LD_VAR 0 1
119680: ARRAY
119681: PPUSH
119682: CALL_OW 300
119686: IFFALSE 119714
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
119688: LD_EXP 224
119692: PUSH
119693: LD_VAR 0 1
119697: ARRAY
119698: PPUSH
119699: LD_EXP 225
119703: PUSH
119704: LD_VAR 0 1
119708: ARRAY
119709: PPUSH
119710: CALL_OW 505
// if not minerMinesList [ i ] then
119714: LD_EXP 225
119718: PUSH
119719: LD_VAR 0 1
119723: ARRAY
119724: NOT
119725: IFFALSE 119729
// continue ;
119727: GO 119668
// for j := minerMinesList [ i ] downto 1 do
119729: LD_ADDR_VAR 0 2
119733: PUSH
119734: DOUBLE
119735: LD_EXP 225
119739: PUSH
119740: LD_VAR 0 1
119744: ARRAY
119745: INC
119746: ST_TO_ADDR
119747: LD_INT 1
119749: PUSH
119750: FOR_DOWNTO
119751: IFFALSE 120001
// begin side := GetSide ( minersList [ i ] ) ;
119753: LD_ADDR_VAR 0 3
119757: PUSH
119758: LD_EXP 224
119762: PUSH
119763: LD_VAR 0 1
119767: ARRAY
119768: PPUSH
119769: CALL_OW 255
119773: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
119774: LD_ADDR_VAR 0 4
119778: PUSH
119779: LD_EXP 225
119783: PUSH
119784: LD_VAR 0 1
119788: ARRAY
119789: PUSH
119790: LD_VAR 0 2
119794: ARRAY
119795: PUSH
119796: LD_INT 1
119798: ARRAY
119799: PPUSH
119800: LD_EXP 225
119804: PUSH
119805: LD_VAR 0 1
119809: ARRAY
119810: PUSH
119811: LD_VAR 0 2
119815: ARRAY
119816: PUSH
119817: LD_INT 2
119819: ARRAY
119820: PPUSH
119821: CALL_OW 428
119825: ST_TO_ADDR
// if not tmp then
119826: LD_VAR 0 4
119830: NOT
119831: IFFALSE 119835
// continue ;
119833: GO 119750
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
119835: LD_VAR 0 4
119839: PUSH
119840: LD_INT 81
119842: PUSH
119843: LD_VAR 0 3
119847: PUSH
119848: EMPTY
119849: LIST
119850: LIST
119851: PPUSH
119852: CALL_OW 69
119856: IN
119857: PUSH
119858: LD_EXP 225
119862: PUSH
119863: LD_VAR 0 1
119867: ARRAY
119868: PUSH
119869: LD_VAR 0 2
119873: ARRAY
119874: PUSH
119875: LD_INT 1
119877: ARRAY
119878: PPUSH
119879: LD_EXP 225
119883: PUSH
119884: LD_VAR 0 1
119888: ARRAY
119889: PUSH
119890: LD_VAR 0 2
119894: ARRAY
119895: PUSH
119896: LD_INT 2
119898: ARRAY
119899: PPUSH
119900: CALL_OW 458
119904: AND
119905: IFFALSE 119999
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
119907: LD_EXP 225
119911: PUSH
119912: LD_VAR 0 1
119916: ARRAY
119917: PUSH
119918: LD_VAR 0 2
119922: ARRAY
119923: PUSH
119924: LD_INT 1
119926: ARRAY
119927: PPUSH
119928: LD_EXP 225
119932: PUSH
119933: LD_VAR 0 1
119937: ARRAY
119938: PUSH
119939: LD_VAR 0 2
119943: ARRAY
119944: PUSH
119945: LD_INT 2
119947: ARRAY
119948: PPUSH
119949: LD_VAR 0 3
119953: PPUSH
119954: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
119958: LD_ADDR_EXP 225
119962: PUSH
119963: LD_EXP 225
119967: PPUSH
119968: LD_VAR 0 1
119972: PPUSH
119973: LD_EXP 225
119977: PUSH
119978: LD_VAR 0 1
119982: ARRAY
119983: PPUSH
119984: LD_VAR 0 2
119988: PPUSH
119989: CALL_OW 3
119993: PPUSH
119994: CALL_OW 1
119998: ST_TO_ADDR
// end ; end ;
119999: GO 119750
120001: POP
120002: POP
// end ;
120003: GO 119668
120005: POP
120006: POP
// end ;
120007: PPOPN 4
120009: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
120010: LD_INT 0
120012: PPUSH
120013: PPUSH
// result := false ;
120014: LD_ADDR_VAR 0 4
120018: PUSH
120019: LD_INT 0
120021: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
120022: LD_VAR 0 1
120026: PPUSH
120027: CALL_OW 264
120031: PUSH
120032: LD_EXP 102
120036: EQUAL
120037: NOT
120038: IFFALSE 120042
// exit ;
120040: GO 120282
// index := GetElementIndex ( minersList , unit ) ;
120042: LD_ADDR_VAR 0 5
120046: PUSH
120047: LD_EXP 224
120051: PPUSH
120052: LD_VAR 0 1
120056: PPUSH
120057: CALL 70324 0 2
120061: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
120062: LD_EXP 225
120066: PUSH
120067: LD_VAR 0 5
120071: ARRAY
120072: PUSH
120073: LD_EXP 226
120077: GREATEREQUAL
120078: IFFALSE 120082
// exit ;
120080: GO 120282
// ComMoveXY ( unit , x , y ) ;
120082: LD_VAR 0 1
120086: PPUSH
120087: LD_VAR 0 2
120091: PPUSH
120092: LD_VAR 0 3
120096: PPUSH
120097: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
120101: LD_INT 35
120103: PPUSH
120104: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
120108: LD_VAR 0 1
120112: PPUSH
120113: LD_VAR 0 2
120117: PPUSH
120118: LD_VAR 0 3
120122: PPUSH
120123: CALL 101097 0 3
120127: NOT
120128: PUSH
120129: LD_VAR 0 1
120133: PPUSH
120134: CALL_OW 314
120138: AND
120139: IFFALSE 120143
// exit ;
120141: GO 120282
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
120143: LD_VAR 0 2
120147: PPUSH
120148: LD_VAR 0 3
120152: PPUSH
120153: CALL_OW 428
120157: PUSH
120158: LD_VAR 0 1
120162: EQUAL
120163: PUSH
120164: LD_VAR 0 1
120168: PPUSH
120169: CALL_OW 314
120173: NOT
120174: AND
120175: IFFALSE 120101
// PlaySoundXY ( x , y , PlantMine ) ;
120177: LD_VAR 0 2
120181: PPUSH
120182: LD_VAR 0 3
120186: PPUSH
120187: LD_STRING PlantMine
120189: PPUSH
120190: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
120194: LD_VAR 0 2
120198: PPUSH
120199: LD_VAR 0 3
120203: PPUSH
120204: LD_VAR 0 1
120208: PPUSH
120209: CALL_OW 255
120213: PPUSH
120214: LD_INT 0
120216: PPUSH
120217: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
120221: LD_ADDR_EXP 225
120225: PUSH
120226: LD_EXP 225
120230: PPUSH
120231: LD_VAR 0 5
120235: PUSH
120236: LD_EXP 225
120240: PUSH
120241: LD_VAR 0 5
120245: ARRAY
120246: PUSH
120247: LD_INT 1
120249: PLUS
120250: PUSH
120251: EMPTY
120252: LIST
120253: LIST
120254: PPUSH
120255: LD_VAR 0 2
120259: PUSH
120260: LD_VAR 0 3
120264: PUSH
120265: EMPTY
120266: LIST
120267: LIST
120268: PPUSH
120269: CALL 70539 0 3
120273: ST_TO_ADDR
// result := true ;
120274: LD_ADDR_VAR 0 4
120278: PUSH
120279: LD_INT 1
120281: ST_TO_ADDR
// end ;
120282: LD_VAR 0 4
120286: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
120287: LD_INT 0
120289: PPUSH
120290: PPUSH
120291: PPUSH
// if not unit in minersList then
120292: LD_VAR 0 1
120296: PUSH
120297: LD_EXP 224
120301: IN
120302: NOT
120303: IFFALSE 120307
// exit ;
120305: GO 120699
// index := GetElementIndex ( minersList , unit ) ;
120307: LD_ADDR_VAR 0 6
120311: PUSH
120312: LD_EXP 224
120316: PPUSH
120317: LD_VAR 0 1
120321: PPUSH
120322: CALL 70324 0 2
120326: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
120327: LD_ADDR_VAR 0 5
120331: PUSH
120332: DOUBLE
120333: LD_EXP 225
120337: PUSH
120338: LD_VAR 0 6
120342: ARRAY
120343: INC
120344: ST_TO_ADDR
120345: LD_INT 1
120347: PUSH
120348: FOR_DOWNTO
120349: IFFALSE 120510
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
120351: LD_EXP 225
120355: PUSH
120356: LD_VAR 0 6
120360: ARRAY
120361: PUSH
120362: LD_VAR 0 5
120366: ARRAY
120367: PUSH
120368: LD_INT 1
120370: ARRAY
120371: PUSH
120372: LD_VAR 0 2
120376: EQUAL
120377: PUSH
120378: LD_EXP 225
120382: PUSH
120383: LD_VAR 0 6
120387: ARRAY
120388: PUSH
120389: LD_VAR 0 5
120393: ARRAY
120394: PUSH
120395: LD_INT 2
120397: ARRAY
120398: PUSH
120399: LD_VAR 0 3
120403: EQUAL
120404: AND
120405: IFFALSE 120508
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
120407: LD_EXP 225
120411: PUSH
120412: LD_VAR 0 6
120416: ARRAY
120417: PUSH
120418: LD_VAR 0 5
120422: ARRAY
120423: PUSH
120424: LD_INT 1
120426: ARRAY
120427: PPUSH
120428: LD_EXP 225
120432: PUSH
120433: LD_VAR 0 6
120437: ARRAY
120438: PUSH
120439: LD_VAR 0 5
120443: ARRAY
120444: PUSH
120445: LD_INT 2
120447: ARRAY
120448: PPUSH
120449: LD_VAR 0 1
120453: PPUSH
120454: CALL_OW 255
120458: PPUSH
120459: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
120463: LD_ADDR_EXP 225
120467: PUSH
120468: LD_EXP 225
120472: PPUSH
120473: LD_VAR 0 6
120477: PPUSH
120478: LD_EXP 225
120482: PUSH
120483: LD_VAR 0 6
120487: ARRAY
120488: PPUSH
120489: LD_VAR 0 5
120493: PPUSH
120494: CALL_OW 3
120498: PPUSH
120499: CALL_OW 1
120503: ST_TO_ADDR
// exit ;
120504: POP
120505: POP
120506: GO 120699
// end ; end ;
120508: GO 120348
120510: POP
120511: POP
// for i := minerMinesList [ index ] downto 1 do
120512: LD_ADDR_VAR 0 5
120516: PUSH
120517: DOUBLE
120518: LD_EXP 225
120522: PUSH
120523: LD_VAR 0 6
120527: ARRAY
120528: INC
120529: ST_TO_ADDR
120530: LD_INT 1
120532: PUSH
120533: FOR_DOWNTO
120534: IFFALSE 120697
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
120536: LD_EXP 225
120540: PUSH
120541: LD_VAR 0 6
120545: ARRAY
120546: PUSH
120547: LD_VAR 0 5
120551: ARRAY
120552: PUSH
120553: LD_INT 1
120555: ARRAY
120556: PPUSH
120557: LD_EXP 225
120561: PUSH
120562: LD_VAR 0 6
120566: ARRAY
120567: PUSH
120568: LD_VAR 0 5
120572: ARRAY
120573: PUSH
120574: LD_INT 2
120576: ARRAY
120577: PPUSH
120578: LD_VAR 0 2
120582: PPUSH
120583: LD_VAR 0 3
120587: PPUSH
120588: CALL_OW 298
120592: PUSH
120593: LD_INT 6
120595: LESS
120596: IFFALSE 120695
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
120598: LD_EXP 225
120602: PUSH
120603: LD_VAR 0 6
120607: ARRAY
120608: PUSH
120609: LD_VAR 0 5
120613: ARRAY
120614: PUSH
120615: LD_INT 1
120617: ARRAY
120618: PPUSH
120619: LD_EXP 225
120623: PUSH
120624: LD_VAR 0 6
120628: ARRAY
120629: PUSH
120630: LD_VAR 0 5
120634: ARRAY
120635: PUSH
120636: LD_INT 2
120638: ARRAY
120639: PPUSH
120640: LD_VAR 0 1
120644: PPUSH
120645: CALL_OW 255
120649: PPUSH
120650: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
120654: LD_ADDR_EXP 225
120658: PUSH
120659: LD_EXP 225
120663: PPUSH
120664: LD_VAR 0 6
120668: PPUSH
120669: LD_EXP 225
120673: PUSH
120674: LD_VAR 0 6
120678: ARRAY
120679: PPUSH
120680: LD_VAR 0 5
120684: PPUSH
120685: CALL_OW 3
120689: PPUSH
120690: CALL_OW 1
120694: ST_TO_ADDR
// end ; end ;
120695: GO 120533
120697: POP
120698: POP
// end ;
120699: LD_VAR 0 4
120703: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
120704: LD_INT 0
120706: PPUSH
120707: PPUSH
120708: PPUSH
120709: PPUSH
120710: PPUSH
120711: PPUSH
120712: PPUSH
120713: PPUSH
120714: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
120715: LD_VAR 0 1
120719: PPUSH
120720: CALL_OW 264
120724: PUSH
120725: LD_EXP 102
120729: EQUAL
120730: NOT
120731: PUSH
120732: LD_VAR 0 1
120736: PUSH
120737: LD_EXP 224
120741: IN
120742: NOT
120743: OR
120744: IFFALSE 120748
// exit ;
120746: GO 121070
// index := GetElementIndex ( minersList , unit ) ;
120748: LD_ADDR_VAR 0 6
120752: PUSH
120753: LD_EXP 224
120757: PPUSH
120758: LD_VAR 0 1
120762: PPUSH
120763: CALL 70324 0 2
120767: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
120768: LD_ADDR_VAR 0 8
120772: PUSH
120773: LD_EXP 226
120777: PUSH
120778: LD_EXP 225
120782: PUSH
120783: LD_VAR 0 6
120787: ARRAY
120788: MINUS
120789: ST_TO_ADDR
// if not minesFreeAmount then
120790: LD_VAR 0 8
120794: NOT
120795: IFFALSE 120799
// exit ;
120797: GO 121070
// tmp := [ ] ;
120799: LD_ADDR_VAR 0 7
120803: PUSH
120804: EMPTY
120805: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
120806: LD_ADDR_VAR 0 5
120810: PUSH
120811: DOUBLE
120812: LD_INT 1
120814: DEC
120815: ST_TO_ADDR
120816: LD_VAR 0 8
120820: PUSH
120821: FOR_TO
120822: IFFALSE 121017
// begin _d := rand ( 0 , 5 ) ;
120824: LD_ADDR_VAR 0 11
120828: PUSH
120829: LD_INT 0
120831: PPUSH
120832: LD_INT 5
120834: PPUSH
120835: CALL_OW 12
120839: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
120840: LD_ADDR_VAR 0 12
120844: PUSH
120845: LD_INT 2
120847: PPUSH
120848: LD_INT 6
120850: PPUSH
120851: CALL_OW 12
120855: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
120856: LD_ADDR_VAR 0 9
120860: PUSH
120861: LD_VAR 0 2
120865: PPUSH
120866: LD_VAR 0 11
120870: PPUSH
120871: LD_VAR 0 12
120875: PPUSH
120876: CALL_OW 272
120880: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
120881: LD_ADDR_VAR 0 10
120885: PUSH
120886: LD_VAR 0 3
120890: PPUSH
120891: LD_VAR 0 11
120895: PPUSH
120896: LD_VAR 0 12
120900: PPUSH
120901: CALL_OW 273
120905: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
120906: LD_VAR 0 9
120910: PPUSH
120911: LD_VAR 0 10
120915: PPUSH
120916: CALL_OW 488
120920: PUSH
120921: LD_VAR 0 9
120925: PUSH
120926: LD_VAR 0 10
120930: PUSH
120931: EMPTY
120932: LIST
120933: LIST
120934: PUSH
120935: LD_VAR 0 7
120939: IN
120940: NOT
120941: AND
120942: PUSH
120943: LD_VAR 0 9
120947: PPUSH
120948: LD_VAR 0 10
120952: PPUSH
120953: CALL_OW 458
120957: NOT
120958: AND
120959: IFFALSE 121001
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
120961: LD_ADDR_VAR 0 7
120965: PUSH
120966: LD_VAR 0 7
120970: PPUSH
120971: LD_VAR 0 7
120975: PUSH
120976: LD_INT 1
120978: PLUS
120979: PPUSH
120980: LD_VAR 0 9
120984: PUSH
120985: LD_VAR 0 10
120989: PUSH
120990: EMPTY
120991: LIST
120992: LIST
120993: PPUSH
120994: CALL_OW 1
120998: ST_TO_ADDR
120999: GO 121015
// i := i - 1 ;
121001: LD_ADDR_VAR 0 5
121005: PUSH
121006: LD_VAR 0 5
121010: PUSH
121011: LD_INT 1
121013: MINUS
121014: ST_TO_ADDR
// end ;
121015: GO 120821
121017: POP
121018: POP
// for i in tmp do
121019: LD_ADDR_VAR 0 5
121023: PUSH
121024: LD_VAR 0 7
121028: PUSH
121029: FOR_IN
121030: IFFALSE 121068
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
121032: LD_VAR 0 1
121036: PPUSH
121037: LD_VAR 0 5
121041: PUSH
121042: LD_INT 1
121044: ARRAY
121045: PPUSH
121046: LD_VAR 0 5
121050: PUSH
121051: LD_INT 2
121053: ARRAY
121054: PPUSH
121055: CALL 120010 0 3
121059: NOT
121060: IFFALSE 121066
// exit ;
121062: POP
121063: POP
121064: GO 121070
121066: GO 121029
121068: POP
121069: POP
// end ;
121070: LD_VAR 0 4
121074: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
121075: LD_INT 0
121077: PPUSH
121078: PPUSH
121079: PPUSH
121080: PPUSH
121081: PPUSH
121082: PPUSH
121083: PPUSH
// if not GetClass ( unit ) = class_sniper then
121084: LD_VAR 0 1
121088: PPUSH
121089: CALL_OW 257
121093: PUSH
121094: LD_INT 5
121096: EQUAL
121097: NOT
121098: IFFALSE 121102
// exit ;
121100: GO 121490
// dist := 8 ;
121102: LD_ADDR_VAR 0 5
121106: PUSH
121107: LD_INT 8
121109: ST_TO_ADDR
// viewRange := 12 ;
121110: LD_ADDR_VAR 0 7
121114: PUSH
121115: LD_INT 12
121117: ST_TO_ADDR
// side := GetSide ( unit ) ;
121118: LD_ADDR_VAR 0 6
121122: PUSH
121123: LD_VAR 0 1
121127: PPUSH
121128: CALL_OW 255
121132: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
121133: LD_INT 61
121135: PPUSH
121136: LD_VAR 0 6
121140: PPUSH
121141: CALL_OW 321
121145: PUSH
121146: LD_INT 2
121148: EQUAL
121149: IFFALSE 121159
// viewRange := 16 ;
121151: LD_ADDR_VAR 0 7
121155: PUSH
121156: LD_INT 16
121158: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
121159: LD_VAR 0 1
121163: PPUSH
121164: LD_VAR 0 2
121168: PPUSH
121169: LD_VAR 0 3
121173: PPUSH
121174: CALL_OW 297
121178: PUSH
121179: LD_VAR 0 5
121183: GREATER
121184: IFFALSE 121263
// begin ComMoveXY ( unit , x , y ) ;
121186: LD_VAR 0 1
121190: PPUSH
121191: LD_VAR 0 2
121195: PPUSH
121196: LD_VAR 0 3
121200: PPUSH
121201: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
121205: LD_INT 35
121207: PPUSH
121208: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
121212: LD_VAR 0 1
121216: PPUSH
121217: LD_VAR 0 2
121221: PPUSH
121222: LD_VAR 0 3
121226: PPUSH
121227: CALL 101097 0 3
121231: NOT
121232: IFFALSE 121236
// exit ;
121234: GO 121490
// until GetDistUnitXY ( unit , x , y ) < dist ;
121236: LD_VAR 0 1
121240: PPUSH
121241: LD_VAR 0 2
121245: PPUSH
121246: LD_VAR 0 3
121250: PPUSH
121251: CALL_OW 297
121255: PUSH
121256: LD_VAR 0 5
121260: LESS
121261: IFFALSE 121205
// end ; ComTurnXY ( unit , x , y ) ;
121263: LD_VAR 0 1
121267: PPUSH
121268: LD_VAR 0 2
121272: PPUSH
121273: LD_VAR 0 3
121277: PPUSH
121278: CALL_OW 118
// wait ( 5 ) ;
121282: LD_INT 5
121284: PPUSH
121285: CALL_OW 67
// _d := GetDir ( unit ) ;
121289: LD_ADDR_VAR 0 10
121293: PUSH
121294: LD_VAR 0 1
121298: PPUSH
121299: CALL_OW 254
121303: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
121304: LD_ADDR_VAR 0 8
121308: PUSH
121309: LD_VAR 0 1
121313: PPUSH
121314: CALL_OW 250
121318: PPUSH
121319: LD_VAR 0 10
121323: PPUSH
121324: LD_VAR 0 5
121328: PPUSH
121329: CALL_OW 272
121333: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
121334: LD_ADDR_VAR 0 9
121338: PUSH
121339: LD_VAR 0 1
121343: PPUSH
121344: CALL_OW 251
121348: PPUSH
121349: LD_VAR 0 10
121353: PPUSH
121354: LD_VAR 0 5
121358: PPUSH
121359: CALL_OW 273
121363: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
121364: LD_VAR 0 8
121368: PPUSH
121369: LD_VAR 0 9
121373: PPUSH
121374: CALL_OW 488
121378: NOT
121379: IFFALSE 121383
// exit ;
121381: GO 121490
// ComAnimCustom ( unit , 1 ) ;
121383: LD_VAR 0 1
121387: PPUSH
121388: LD_INT 1
121390: PPUSH
121391: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
121395: LD_VAR 0 8
121399: PPUSH
121400: LD_VAR 0 9
121404: PPUSH
121405: LD_VAR 0 6
121409: PPUSH
121410: LD_VAR 0 7
121414: PPUSH
121415: CALL_OW 330
// repeat wait ( 1 ) ;
121419: LD_INT 1
121421: PPUSH
121422: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
121426: LD_VAR 0 1
121430: PPUSH
121431: CALL_OW 316
121435: PUSH
121436: LD_VAR 0 1
121440: PPUSH
121441: CALL_OW 314
121445: OR
121446: PUSH
121447: LD_VAR 0 1
121451: PPUSH
121452: CALL_OW 302
121456: NOT
121457: OR
121458: PUSH
121459: LD_VAR 0 1
121463: PPUSH
121464: CALL_OW 301
121468: OR
121469: IFFALSE 121419
// RemoveSeeing ( _x , _y , side ) ;
121471: LD_VAR 0 8
121475: PPUSH
121476: LD_VAR 0 9
121480: PPUSH
121481: LD_VAR 0 6
121485: PPUSH
121486: CALL_OW 331
// end ; end_of_file
121490: LD_VAR 0 4
121494: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
121495: LD_INT 0
121497: PPUSH
121498: PPUSH
121499: PPUSH
121500: PPUSH
121501: PPUSH
121502: PPUSH
121503: PPUSH
121504: PPUSH
121505: PPUSH
121506: PPUSH
121507: PPUSH
121508: PPUSH
121509: PPUSH
121510: PPUSH
121511: PPUSH
121512: PPUSH
121513: PPUSH
121514: PPUSH
121515: PPUSH
121516: PPUSH
121517: PPUSH
121518: PPUSH
121519: PPUSH
121520: PPUSH
121521: PPUSH
121522: PPUSH
121523: PPUSH
121524: PPUSH
121525: PPUSH
121526: PPUSH
121527: PPUSH
121528: PPUSH
121529: PPUSH
121530: PPUSH
// if not list then
121531: LD_VAR 0 1
121535: NOT
121536: IFFALSE 121540
// exit ;
121538: GO 126199
// base := list [ 1 ] ;
121540: LD_ADDR_VAR 0 3
121544: PUSH
121545: LD_VAR 0 1
121549: PUSH
121550: LD_INT 1
121552: ARRAY
121553: ST_TO_ADDR
// group := list [ 2 ] ;
121554: LD_ADDR_VAR 0 4
121558: PUSH
121559: LD_VAR 0 1
121563: PUSH
121564: LD_INT 2
121566: ARRAY
121567: ST_TO_ADDR
// path := list [ 3 ] ;
121568: LD_ADDR_VAR 0 5
121572: PUSH
121573: LD_VAR 0 1
121577: PUSH
121578: LD_INT 3
121580: ARRAY
121581: ST_TO_ADDR
// flags := list [ 4 ] ;
121582: LD_ADDR_VAR 0 6
121586: PUSH
121587: LD_VAR 0 1
121591: PUSH
121592: LD_INT 4
121594: ARRAY
121595: ST_TO_ADDR
// mined := [ ] ;
121596: LD_ADDR_VAR 0 27
121600: PUSH
121601: EMPTY
121602: ST_TO_ADDR
// bombed := [ ] ;
121603: LD_ADDR_VAR 0 28
121607: PUSH
121608: EMPTY
121609: ST_TO_ADDR
// healers := [ ] ;
121610: LD_ADDR_VAR 0 31
121614: PUSH
121615: EMPTY
121616: ST_TO_ADDR
// to_heal := [ ] ;
121617: LD_ADDR_VAR 0 30
121621: PUSH
121622: EMPTY
121623: ST_TO_ADDR
// repairs := [ ] ;
121624: LD_ADDR_VAR 0 33
121628: PUSH
121629: EMPTY
121630: ST_TO_ADDR
// to_repair := [ ] ;
121631: LD_ADDR_VAR 0 32
121635: PUSH
121636: EMPTY
121637: ST_TO_ADDR
// if not group or not path then
121638: LD_VAR 0 4
121642: NOT
121643: PUSH
121644: LD_VAR 0 5
121648: NOT
121649: OR
121650: IFFALSE 121654
// exit ;
121652: GO 126199
// side := GetSide ( group [ 1 ] ) ;
121654: LD_ADDR_VAR 0 35
121658: PUSH
121659: LD_VAR 0 4
121663: PUSH
121664: LD_INT 1
121666: ARRAY
121667: PPUSH
121668: CALL_OW 255
121672: ST_TO_ADDR
// if flags then
121673: LD_VAR 0 6
121677: IFFALSE 121821
// begin f_ignore_area := flags [ 1 ] ;
121679: LD_ADDR_VAR 0 17
121683: PUSH
121684: LD_VAR 0 6
121688: PUSH
121689: LD_INT 1
121691: ARRAY
121692: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
121693: LD_ADDR_VAR 0 18
121697: PUSH
121698: LD_VAR 0 6
121702: PUSH
121703: LD_INT 2
121705: ARRAY
121706: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
121707: LD_ADDR_VAR 0 19
121711: PUSH
121712: LD_VAR 0 6
121716: PUSH
121717: LD_INT 3
121719: ARRAY
121720: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
121721: LD_ADDR_VAR 0 20
121725: PUSH
121726: LD_VAR 0 6
121730: PUSH
121731: LD_INT 4
121733: ARRAY
121734: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
121735: LD_ADDR_VAR 0 21
121739: PUSH
121740: LD_VAR 0 6
121744: PUSH
121745: LD_INT 5
121747: ARRAY
121748: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
121749: LD_ADDR_VAR 0 22
121753: PUSH
121754: LD_VAR 0 6
121758: PUSH
121759: LD_INT 6
121761: ARRAY
121762: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
121763: LD_ADDR_VAR 0 23
121767: PUSH
121768: LD_VAR 0 6
121772: PUSH
121773: LD_INT 7
121775: ARRAY
121776: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
121777: LD_ADDR_VAR 0 24
121781: PUSH
121782: LD_VAR 0 6
121786: PUSH
121787: LD_INT 8
121789: ARRAY
121790: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
121791: LD_ADDR_VAR 0 25
121795: PUSH
121796: LD_VAR 0 6
121800: PUSH
121801: LD_INT 9
121803: ARRAY
121804: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
121805: LD_ADDR_VAR 0 26
121809: PUSH
121810: LD_VAR 0 6
121814: PUSH
121815: LD_INT 10
121817: ARRAY
121818: ST_TO_ADDR
// end else
121819: GO 121901
// begin f_ignore_area := false ;
121821: LD_ADDR_VAR 0 17
121825: PUSH
121826: LD_INT 0
121828: ST_TO_ADDR
// f_capture := false ;
121829: LD_ADDR_VAR 0 18
121833: PUSH
121834: LD_INT 0
121836: ST_TO_ADDR
// f_ignore_civ := false ;
121837: LD_ADDR_VAR 0 19
121841: PUSH
121842: LD_INT 0
121844: ST_TO_ADDR
// f_murder := false ;
121845: LD_ADDR_VAR 0 20
121849: PUSH
121850: LD_INT 0
121852: ST_TO_ADDR
// f_mines := false ;
121853: LD_ADDR_VAR 0 21
121857: PUSH
121858: LD_INT 0
121860: ST_TO_ADDR
// f_repair := false ;
121861: LD_ADDR_VAR 0 22
121865: PUSH
121866: LD_INT 0
121868: ST_TO_ADDR
// f_heal := false ;
121869: LD_ADDR_VAR 0 23
121873: PUSH
121874: LD_INT 0
121876: ST_TO_ADDR
// f_spacetime := false ;
121877: LD_ADDR_VAR 0 24
121881: PUSH
121882: LD_INT 0
121884: ST_TO_ADDR
// f_attack_depot := false ;
121885: LD_ADDR_VAR 0 25
121889: PUSH
121890: LD_INT 0
121892: ST_TO_ADDR
// f_crawl := false ;
121893: LD_ADDR_VAR 0 26
121897: PUSH
121898: LD_INT 0
121900: ST_TO_ADDR
// end ; if f_heal then
121901: LD_VAR 0 23
121905: IFFALSE 121932
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
121907: LD_ADDR_VAR 0 31
121911: PUSH
121912: LD_VAR 0 4
121916: PPUSH
121917: LD_INT 25
121919: PUSH
121920: LD_INT 4
121922: PUSH
121923: EMPTY
121924: LIST
121925: LIST
121926: PPUSH
121927: CALL_OW 72
121931: ST_TO_ADDR
// if f_repair then
121932: LD_VAR 0 22
121936: IFFALSE 121963
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
121938: LD_ADDR_VAR 0 33
121942: PUSH
121943: LD_VAR 0 4
121947: PPUSH
121948: LD_INT 25
121950: PUSH
121951: LD_INT 3
121953: PUSH
121954: EMPTY
121955: LIST
121956: LIST
121957: PPUSH
121958: CALL_OW 72
121962: ST_TO_ADDR
// units_path := [ ] ;
121963: LD_ADDR_VAR 0 16
121967: PUSH
121968: EMPTY
121969: ST_TO_ADDR
// for i = 1 to group do
121970: LD_ADDR_VAR 0 7
121974: PUSH
121975: DOUBLE
121976: LD_INT 1
121978: DEC
121979: ST_TO_ADDR
121980: LD_VAR 0 4
121984: PUSH
121985: FOR_TO
121986: IFFALSE 122015
// units_path := Replace ( units_path , i , path ) ;
121988: LD_ADDR_VAR 0 16
121992: PUSH
121993: LD_VAR 0 16
121997: PPUSH
121998: LD_VAR 0 7
122002: PPUSH
122003: LD_VAR 0 5
122007: PPUSH
122008: CALL_OW 1
122012: ST_TO_ADDR
122013: GO 121985
122015: POP
122016: POP
// repeat for i = group downto 1 do
122017: LD_ADDR_VAR 0 7
122021: PUSH
122022: DOUBLE
122023: LD_VAR 0 4
122027: INC
122028: ST_TO_ADDR
122029: LD_INT 1
122031: PUSH
122032: FOR_DOWNTO
122033: IFFALSE 126155
// begin wait ( 5 ) ;
122035: LD_INT 5
122037: PPUSH
122038: CALL_OW 67
// tmp := [ ] ;
122042: LD_ADDR_VAR 0 14
122046: PUSH
122047: EMPTY
122048: ST_TO_ADDR
// attacking := false ;
122049: LD_ADDR_VAR 0 29
122053: PUSH
122054: LD_INT 0
122056: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
122057: LD_VAR 0 4
122061: PUSH
122062: LD_VAR 0 7
122066: ARRAY
122067: PPUSH
122068: CALL_OW 301
122072: PUSH
122073: LD_VAR 0 4
122077: PUSH
122078: LD_VAR 0 7
122082: ARRAY
122083: NOT
122084: OR
122085: IFFALSE 122194
// begin if GetType ( group [ i ] ) = unit_human then
122087: LD_VAR 0 4
122091: PUSH
122092: LD_VAR 0 7
122096: ARRAY
122097: PPUSH
122098: CALL_OW 247
122102: PUSH
122103: LD_INT 1
122105: EQUAL
122106: IFFALSE 122152
// begin to_heal := to_heal diff group [ i ] ;
122108: LD_ADDR_VAR 0 30
122112: PUSH
122113: LD_VAR 0 30
122117: PUSH
122118: LD_VAR 0 4
122122: PUSH
122123: LD_VAR 0 7
122127: ARRAY
122128: DIFF
122129: ST_TO_ADDR
// healers := healers diff group [ i ] ;
122130: LD_ADDR_VAR 0 31
122134: PUSH
122135: LD_VAR 0 31
122139: PUSH
122140: LD_VAR 0 4
122144: PUSH
122145: LD_VAR 0 7
122149: ARRAY
122150: DIFF
122151: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
122152: LD_ADDR_VAR 0 4
122156: PUSH
122157: LD_VAR 0 4
122161: PPUSH
122162: LD_VAR 0 7
122166: PPUSH
122167: CALL_OW 3
122171: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
122172: LD_ADDR_VAR 0 16
122176: PUSH
122177: LD_VAR 0 16
122181: PPUSH
122182: LD_VAR 0 7
122186: PPUSH
122187: CALL_OW 3
122191: ST_TO_ADDR
// continue ;
122192: GO 122032
// end ; if f_repair then
122194: LD_VAR 0 22
122198: IFFALSE 122687
// begin if GetType ( group [ i ] ) = unit_vehicle then
122200: LD_VAR 0 4
122204: PUSH
122205: LD_VAR 0 7
122209: ARRAY
122210: PPUSH
122211: CALL_OW 247
122215: PUSH
122216: LD_INT 2
122218: EQUAL
122219: IFFALSE 122409
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
122221: LD_VAR 0 4
122225: PUSH
122226: LD_VAR 0 7
122230: ARRAY
122231: PPUSH
122232: CALL_OW 256
122236: PUSH
122237: LD_INT 700
122239: LESS
122240: PUSH
122241: LD_VAR 0 4
122245: PUSH
122246: LD_VAR 0 7
122250: ARRAY
122251: PUSH
122252: LD_VAR 0 32
122256: IN
122257: NOT
122258: AND
122259: IFFALSE 122283
// to_repair := to_repair union group [ i ] ;
122261: LD_ADDR_VAR 0 32
122265: PUSH
122266: LD_VAR 0 32
122270: PUSH
122271: LD_VAR 0 4
122275: PUSH
122276: LD_VAR 0 7
122280: ARRAY
122281: UNION
122282: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
122283: LD_VAR 0 4
122287: PUSH
122288: LD_VAR 0 7
122292: ARRAY
122293: PPUSH
122294: CALL_OW 256
122298: PUSH
122299: LD_INT 1000
122301: EQUAL
122302: PUSH
122303: LD_VAR 0 4
122307: PUSH
122308: LD_VAR 0 7
122312: ARRAY
122313: PUSH
122314: LD_VAR 0 32
122318: IN
122319: AND
122320: IFFALSE 122344
// to_repair := to_repair diff group [ i ] ;
122322: LD_ADDR_VAR 0 32
122326: PUSH
122327: LD_VAR 0 32
122331: PUSH
122332: LD_VAR 0 4
122336: PUSH
122337: LD_VAR 0 7
122341: ARRAY
122342: DIFF
122343: ST_TO_ADDR
// if group [ i ] in to_repair then
122344: LD_VAR 0 4
122348: PUSH
122349: LD_VAR 0 7
122353: ARRAY
122354: PUSH
122355: LD_VAR 0 32
122359: IN
122360: IFFALSE 122407
// begin if not IsInArea ( group [ i ] , f_repair ) then
122362: LD_VAR 0 4
122366: PUSH
122367: LD_VAR 0 7
122371: ARRAY
122372: PPUSH
122373: LD_VAR 0 22
122377: PPUSH
122378: CALL_OW 308
122382: NOT
122383: IFFALSE 122405
// ComMoveToArea ( group [ i ] , f_repair ) ;
122385: LD_VAR 0 4
122389: PUSH
122390: LD_VAR 0 7
122394: ARRAY
122395: PPUSH
122396: LD_VAR 0 22
122400: PPUSH
122401: CALL_OW 113
// continue ;
122405: GO 122032
// end ; end else
122407: GO 122687
// if group [ i ] in repairs then
122409: LD_VAR 0 4
122413: PUSH
122414: LD_VAR 0 7
122418: ARRAY
122419: PUSH
122420: LD_VAR 0 33
122424: IN
122425: IFFALSE 122687
// begin if IsInUnit ( group [ i ] ) then
122427: LD_VAR 0 4
122431: PUSH
122432: LD_VAR 0 7
122436: ARRAY
122437: PPUSH
122438: CALL_OW 310
122442: IFFALSE 122510
// begin z := IsInUnit ( group [ i ] ) ;
122444: LD_ADDR_VAR 0 13
122448: PUSH
122449: LD_VAR 0 4
122453: PUSH
122454: LD_VAR 0 7
122458: ARRAY
122459: PPUSH
122460: CALL_OW 310
122464: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
122465: LD_VAR 0 13
122469: PUSH
122470: LD_VAR 0 32
122474: IN
122475: PUSH
122476: LD_VAR 0 13
122480: PPUSH
122481: LD_VAR 0 22
122485: PPUSH
122486: CALL_OW 308
122490: AND
122491: IFFALSE 122508
// ComExitVehicle ( group [ i ] ) ;
122493: LD_VAR 0 4
122497: PUSH
122498: LD_VAR 0 7
122502: ARRAY
122503: PPUSH
122504: CALL_OW 121
// end else
122508: GO 122687
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
122510: LD_ADDR_VAR 0 13
122514: PUSH
122515: LD_VAR 0 4
122519: PPUSH
122520: LD_INT 95
122522: PUSH
122523: LD_VAR 0 22
122527: PUSH
122528: EMPTY
122529: LIST
122530: LIST
122531: PUSH
122532: LD_INT 58
122534: PUSH
122535: EMPTY
122536: LIST
122537: PUSH
122538: EMPTY
122539: LIST
122540: LIST
122541: PPUSH
122542: CALL_OW 72
122546: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
122547: LD_VAR 0 4
122551: PUSH
122552: LD_VAR 0 7
122556: ARRAY
122557: PPUSH
122558: CALL_OW 314
122562: NOT
122563: IFFALSE 122685
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
122565: LD_ADDR_VAR 0 10
122569: PUSH
122570: LD_VAR 0 13
122574: PPUSH
122575: LD_VAR 0 4
122579: PUSH
122580: LD_VAR 0 7
122584: ARRAY
122585: PPUSH
122586: CALL_OW 74
122590: ST_TO_ADDR
// if not x then
122591: LD_VAR 0 10
122595: NOT
122596: IFFALSE 122600
// continue ;
122598: GO 122032
// if GetLives ( x ) < 1000 then
122600: LD_VAR 0 10
122604: PPUSH
122605: CALL_OW 256
122609: PUSH
122610: LD_INT 1000
122612: LESS
122613: IFFALSE 122637
// ComRepairVehicle ( group [ i ] , x ) else
122615: LD_VAR 0 4
122619: PUSH
122620: LD_VAR 0 7
122624: ARRAY
122625: PPUSH
122626: LD_VAR 0 10
122630: PPUSH
122631: CALL_OW 129
122635: GO 122685
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
122637: LD_VAR 0 23
122641: PUSH
122642: LD_VAR 0 4
122646: PUSH
122647: LD_VAR 0 7
122651: ARRAY
122652: PPUSH
122653: CALL_OW 256
122657: PUSH
122658: LD_INT 1000
122660: LESS
122661: AND
122662: NOT
122663: IFFALSE 122685
// ComEnterUnit ( group [ i ] , x ) ;
122665: LD_VAR 0 4
122669: PUSH
122670: LD_VAR 0 7
122674: ARRAY
122675: PPUSH
122676: LD_VAR 0 10
122680: PPUSH
122681: CALL_OW 120
// end ; continue ;
122685: GO 122032
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
122687: LD_VAR 0 23
122691: PUSH
122692: LD_VAR 0 4
122696: PUSH
122697: LD_VAR 0 7
122701: ARRAY
122702: PPUSH
122703: CALL_OW 247
122707: PUSH
122708: LD_INT 1
122710: EQUAL
122711: AND
122712: IFFALSE 123190
// begin if group [ i ] in healers then
122714: LD_VAR 0 4
122718: PUSH
122719: LD_VAR 0 7
122723: ARRAY
122724: PUSH
122725: LD_VAR 0 31
122729: IN
122730: IFFALSE 123003
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
122732: LD_VAR 0 4
122736: PUSH
122737: LD_VAR 0 7
122741: ARRAY
122742: PPUSH
122743: LD_VAR 0 23
122747: PPUSH
122748: CALL_OW 308
122752: NOT
122753: PUSH
122754: LD_VAR 0 4
122758: PUSH
122759: LD_VAR 0 7
122763: ARRAY
122764: PPUSH
122765: CALL_OW 314
122769: NOT
122770: AND
122771: IFFALSE 122795
// ComMoveToArea ( group [ i ] , f_heal ) else
122773: LD_VAR 0 4
122777: PUSH
122778: LD_VAR 0 7
122782: ARRAY
122783: PPUSH
122784: LD_VAR 0 23
122788: PPUSH
122789: CALL_OW 113
122793: GO 123001
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
122795: LD_VAR 0 4
122799: PUSH
122800: LD_VAR 0 7
122804: ARRAY
122805: PPUSH
122806: CALL 99620 0 1
122810: PPUSH
122811: CALL_OW 256
122815: PUSH
122816: LD_INT 1000
122818: EQUAL
122819: IFFALSE 122838
// ComStop ( group [ i ] ) else
122821: LD_VAR 0 4
122825: PUSH
122826: LD_VAR 0 7
122830: ARRAY
122831: PPUSH
122832: CALL_OW 141
122836: GO 123001
// if not HasTask ( group [ i ] ) and to_heal then
122838: LD_VAR 0 4
122842: PUSH
122843: LD_VAR 0 7
122847: ARRAY
122848: PPUSH
122849: CALL_OW 314
122853: NOT
122854: PUSH
122855: LD_VAR 0 30
122859: AND
122860: IFFALSE 123001
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
122862: LD_ADDR_VAR 0 13
122866: PUSH
122867: LD_VAR 0 30
122871: PPUSH
122872: LD_INT 3
122874: PUSH
122875: LD_INT 54
122877: PUSH
122878: EMPTY
122879: LIST
122880: PUSH
122881: EMPTY
122882: LIST
122883: LIST
122884: PPUSH
122885: CALL_OW 72
122889: PPUSH
122890: LD_VAR 0 4
122894: PUSH
122895: LD_VAR 0 7
122899: ARRAY
122900: PPUSH
122901: CALL_OW 74
122905: ST_TO_ADDR
// if z then
122906: LD_VAR 0 13
122910: IFFALSE 123001
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
122912: LD_INT 91
122914: PUSH
122915: LD_VAR 0 13
122919: PUSH
122920: LD_INT 10
122922: PUSH
122923: EMPTY
122924: LIST
122925: LIST
122926: LIST
122927: PUSH
122928: LD_INT 81
122930: PUSH
122931: LD_VAR 0 13
122935: PPUSH
122936: CALL_OW 255
122940: PUSH
122941: EMPTY
122942: LIST
122943: LIST
122944: PUSH
122945: EMPTY
122946: LIST
122947: LIST
122948: PPUSH
122949: CALL_OW 69
122953: PUSH
122954: LD_INT 0
122956: EQUAL
122957: IFFALSE 122981
// ComHeal ( group [ i ] , z ) else
122959: LD_VAR 0 4
122963: PUSH
122964: LD_VAR 0 7
122968: ARRAY
122969: PPUSH
122970: LD_VAR 0 13
122974: PPUSH
122975: CALL_OW 128
122979: GO 123001
// ComMoveToArea ( group [ i ] , f_heal ) ;
122981: LD_VAR 0 4
122985: PUSH
122986: LD_VAR 0 7
122990: ARRAY
122991: PPUSH
122992: LD_VAR 0 23
122996: PPUSH
122997: CALL_OW 113
// end ; continue ;
123001: GO 122032
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
123003: LD_VAR 0 4
123007: PUSH
123008: LD_VAR 0 7
123012: ARRAY
123013: PPUSH
123014: CALL_OW 256
123018: PUSH
123019: LD_INT 700
123021: LESS
123022: PUSH
123023: LD_VAR 0 4
123027: PUSH
123028: LD_VAR 0 7
123032: ARRAY
123033: PUSH
123034: LD_VAR 0 30
123038: IN
123039: NOT
123040: AND
123041: IFFALSE 123065
// to_heal := to_heal union group [ i ] ;
123043: LD_ADDR_VAR 0 30
123047: PUSH
123048: LD_VAR 0 30
123052: PUSH
123053: LD_VAR 0 4
123057: PUSH
123058: LD_VAR 0 7
123062: ARRAY
123063: UNION
123064: ST_TO_ADDR
// if group [ i ] in to_heal then
123065: LD_VAR 0 4
123069: PUSH
123070: LD_VAR 0 7
123074: ARRAY
123075: PUSH
123076: LD_VAR 0 30
123080: IN
123081: IFFALSE 123190
// begin if GetLives ( group [ i ] ) = 1000 then
123083: LD_VAR 0 4
123087: PUSH
123088: LD_VAR 0 7
123092: ARRAY
123093: PPUSH
123094: CALL_OW 256
123098: PUSH
123099: LD_INT 1000
123101: EQUAL
123102: IFFALSE 123128
// to_heal := to_heal diff group [ i ] else
123104: LD_ADDR_VAR 0 30
123108: PUSH
123109: LD_VAR 0 30
123113: PUSH
123114: LD_VAR 0 4
123118: PUSH
123119: LD_VAR 0 7
123123: ARRAY
123124: DIFF
123125: ST_TO_ADDR
123126: GO 123190
// begin if not IsInArea ( group [ i ] , to_heal ) then
123128: LD_VAR 0 4
123132: PUSH
123133: LD_VAR 0 7
123137: ARRAY
123138: PPUSH
123139: LD_VAR 0 30
123143: PPUSH
123144: CALL_OW 308
123148: NOT
123149: IFFALSE 123173
// ComMoveToArea ( group [ i ] , f_heal ) else
123151: LD_VAR 0 4
123155: PUSH
123156: LD_VAR 0 7
123160: ARRAY
123161: PPUSH
123162: LD_VAR 0 23
123166: PPUSH
123167: CALL_OW 113
123171: GO 123188
// ComHold ( group [ i ] ) ;
123173: LD_VAR 0 4
123177: PUSH
123178: LD_VAR 0 7
123182: ARRAY
123183: PPUSH
123184: CALL_OW 140
// continue ;
123188: GO 122032
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
123190: LD_VAR 0 4
123194: PUSH
123195: LD_VAR 0 7
123199: ARRAY
123200: PPUSH
123201: LD_INT 10
123203: PPUSH
123204: CALL 98040 0 2
123208: NOT
123209: PUSH
123210: LD_VAR 0 16
123214: PUSH
123215: LD_VAR 0 7
123219: ARRAY
123220: PUSH
123221: EMPTY
123222: EQUAL
123223: NOT
123224: AND
123225: IFFALSE 123491
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
123227: LD_VAR 0 4
123231: PUSH
123232: LD_VAR 0 7
123236: ARRAY
123237: PPUSH
123238: CALL_OW 262
123242: PUSH
123243: LD_INT 1
123245: PUSH
123246: LD_INT 2
123248: PUSH
123249: EMPTY
123250: LIST
123251: LIST
123252: IN
123253: IFFALSE 123294
// if GetFuel ( group [ i ] ) < 10 then
123255: LD_VAR 0 4
123259: PUSH
123260: LD_VAR 0 7
123264: ARRAY
123265: PPUSH
123266: CALL_OW 261
123270: PUSH
123271: LD_INT 10
123273: LESS
123274: IFFALSE 123294
// SetFuel ( group [ i ] , 12 ) ;
123276: LD_VAR 0 4
123280: PUSH
123281: LD_VAR 0 7
123285: ARRAY
123286: PPUSH
123287: LD_INT 12
123289: PPUSH
123290: CALL_OW 240
// if units_path [ i ] then
123294: LD_VAR 0 16
123298: PUSH
123299: LD_VAR 0 7
123303: ARRAY
123304: IFFALSE 123489
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
123306: LD_VAR 0 4
123310: PUSH
123311: LD_VAR 0 7
123315: ARRAY
123316: PPUSH
123317: LD_VAR 0 16
123321: PUSH
123322: LD_VAR 0 7
123326: ARRAY
123327: PUSH
123328: LD_INT 1
123330: ARRAY
123331: PUSH
123332: LD_INT 1
123334: ARRAY
123335: PPUSH
123336: LD_VAR 0 16
123340: PUSH
123341: LD_VAR 0 7
123345: ARRAY
123346: PUSH
123347: LD_INT 1
123349: ARRAY
123350: PUSH
123351: LD_INT 2
123353: ARRAY
123354: PPUSH
123355: CALL_OW 297
123359: PUSH
123360: LD_INT 6
123362: GREATER
123363: IFFALSE 123438
// begin if not HasTask ( group [ i ] ) then
123365: LD_VAR 0 4
123369: PUSH
123370: LD_VAR 0 7
123374: ARRAY
123375: PPUSH
123376: CALL_OW 314
123380: NOT
123381: IFFALSE 123436
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
123383: LD_VAR 0 4
123387: PUSH
123388: LD_VAR 0 7
123392: ARRAY
123393: PPUSH
123394: LD_VAR 0 16
123398: PUSH
123399: LD_VAR 0 7
123403: ARRAY
123404: PUSH
123405: LD_INT 1
123407: ARRAY
123408: PUSH
123409: LD_INT 1
123411: ARRAY
123412: PPUSH
123413: LD_VAR 0 16
123417: PUSH
123418: LD_VAR 0 7
123422: ARRAY
123423: PUSH
123424: LD_INT 1
123426: ARRAY
123427: PUSH
123428: LD_INT 2
123430: ARRAY
123431: PPUSH
123432: CALL_OW 114
// end else
123436: GO 123489
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
123438: LD_ADDR_VAR 0 15
123442: PUSH
123443: LD_VAR 0 16
123447: PUSH
123448: LD_VAR 0 7
123452: ARRAY
123453: PPUSH
123454: LD_INT 1
123456: PPUSH
123457: CALL_OW 3
123461: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
123462: LD_ADDR_VAR 0 16
123466: PUSH
123467: LD_VAR 0 16
123471: PPUSH
123472: LD_VAR 0 7
123476: PPUSH
123477: LD_VAR 0 15
123481: PPUSH
123482: CALL_OW 1
123486: ST_TO_ADDR
// continue ;
123487: GO 122032
// end ; end ; end else
123489: GO 126153
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
123491: LD_ADDR_VAR 0 14
123495: PUSH
123496: LD_INT 81
123498: PUSH
123499: LD_VAR 0 4
123503: PUSH
123504: LD_VAR 0 7
123508: ARRAY
123509: PPUSH
123510: CALL_OW 255
123514: PUSH
123515: EMPTY
123516: LIST
123517: LIST
123518: PPUSH
123519: CALL_OW 69
123523: ST_TO_ADDR
// if not tmp then
123524: LD_VAR 0 14
123528: NOT
123529: IFFALSE 123533
// continue ;
123531: GO 122032
// if f_ignore_area then
123533: LD_VAR 0 17
123537: IFFALSE 123625
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
123539: LD_ADDR_VAR 0 15
123543: PUSH
123544: LD_VAR 0 14
123548: PPUSH
123549: LD_INT 3
123551: PUSH
123552: LD_INT 92
123554: PUSH
123555: LD_VAR 0 17
123559: PUSH
123560: LD_INT 1
123562: ARRAY
123563: PUSH
123564: LD_VAR 0 17
123568: PUSH
123569: LD_INT 2
123571: ARRAY
123572: PUSH
123573: LD_VAR 0 17
123577: PUSH
123578: LD_INT 3
123580: ARRAY
123581: PUSH
123582: EMPTY
123583: LIST
123584: LIST
123585: LIST
123586: LIST
123587: PUSH
123588: EMPTY
123589: LIST
123590: LIST
123591: PPUSH
123592: CALL_OW 72
123596: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
123597: LD_VAR 0 14
123601: PUSH
123602: LD_VAR 0 15
123606: DIFF
123607: IFFALSE 123625
// tmp := tmp diff tmp2 ;
123609: LD_ADDR_VAR 0 14
123613: PUSH
123614: LD_VAR 0 14
123618: PUSH
123619: LD_VAR 0 15
123623: DIFF
123624: ST_TO_ADDR
// end ; if not f_murder then
123625: LD_VAR 0 20
123629: NOT
123630: IFFALSE 123688
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
123632: LD_ADDR_VAR 0 15
123636: PUSH
123637: LD_VAR 0 14
123641: PPUSH
123642: LD_INT 3
123644: PUSH
123645: LD_INT 50
123647: PUSH
123648: EMPTY
123649: LIST
123650: PUSH
123651: EMPTY
123652: LIST
123653: LIST
123654: PPUSH
123655: CALL_OW 72
123659: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
123660: LD_VAR 0 14
123664: PUSH
123665: LD_VAR 0 15
123669: DIFF
123670: IFFALSE 123688
// tmp := tmp diff tmp2 ;
123672: LD_ADDR_VAR 0 14
123676: PUSH
123677: LD_VAR 0 14
123681: PUSH
123682: LD_VAR 0 15
123686: DIFF
123687: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
123688: LD_ADDR_VAR 0 14
123692: PUSH
123693: LD_VAR 0 4
123697: PUSH
123698: LD_VAR 0 7
123702: ARRAY
123703: PPUSH
123704: LD_VAR 0 14
123708: PPUSH
123709: LD_INT 1
123711: PPUSH
123712: LD_INT 1
123714: PPUSH
123715: CALL 70974 0 4
123719: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
123720: LD_VAR 0 4
123724: PUSH
123725: LD_VAR 0 7
123729: ARRAY
123730: PPUSH
123731: CALL_OW 257
123735: PUSH
123736: LD_INT 1
123738: EQUAL
123739: IFFALSE 124187
// begin if WantPlant ( group [ i ] ) then
123741: LD_VAR 0 4
123745: PUSH
123746: LD_VAR 0 7
123750: ARRAY
123751: PPUSH
123752: CALL 70475 0 1
123756: IFFALSE 123760
// continue ;
123758: GO 122032
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
123760: LD_VAR 0 18
123764: PUSH
123765: LD_VAR 0 4
123769: PUSH
123770: LD_VAR 0 7
123774: ARRAY
123775: PPUSH
123776: CALL_OW 310
123780: NOT
123781: AND
123782: PUSH
123783: LD_VAR 0 14
123787: PUSH
123788: LD_INT 1
123790: ARRAY
123791: PUSH
123792: LD_VAR 0 14
123796: PPUSH
123797: LD_INT 21
123799: PUSH
123800: LD_INT 2
123802: PUSH
123803: EMPTY
123804: LIST
123805: LIST
123806: PUSH
123807: LD_INT 58
123809: PUSH
123810: EMPTY
123811: LIST
123812: PUSH
123813: EMPTY
123814: LIST
123815: LIST
123816: PPUSH
123817: CALL_OW 72
123821: IN
123822: AND
123823: IFFALSE 123859
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
123825: LD_VAR 0 4
123829: PUSH
123830: LD_VAR 0 7
123834: ARRAY
123835: PPUSH
123836: LD_VAR 0 14
123840: PUSH
123841: LD_INT 1
123843: ARRAY
123844: PPUSH
123845: CALL_OW 120
// attacking := true ;
123849: LD_ADDR_VAR 0 29
123853: PUSH
123854: LD_INT 1
123856: ST_TO_ADDR
// continue ;
123857: GO 122032
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
123859: LD_VAR 0 26
123863: PUSH
123864: LD_VAR 0 4
123868: PUSH
123869: LD_VAR 0 7
123873: ARRAY
123874: PPUSH
123875: CALL_OW 257
123879: PUSH
123880: LD_INT 1
123882: EQUAL
123883: AND
123884: PUSH
123885: LD_VAR 0 4
123889: PUSH
123890: LD_VAR 0 7
123894: ARRAY
123895: PPUSH
123896: CALL_OW 256
123900: PUSH
123901: LD_INT 800
123903: LESS
123904: AND
123905: PUSH
123906: LD_VAR 0 4
123910: PUSH
123911: LD_VAR 0 7
123915: ARRAY
123916: PPUSH
123917: CALL_OW 318
123921: NOT
123922: AND
123923: IFFALSE 123940
// ComCrawl ( group [ i ] ) ;
123925: LD_VAR 0 4
123929: PUSH
123930: LD_VAR 0 7
123934: ARRAY
123935: PPUSH
123936: CALL_OW 137
// if f_mines then
123940: LD_VAR 0 21
123944: IFFALSE 124187
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
123946: LD_VAR 0 14
123950: PUSH
123951: LD_INT 1
123953: ARRAY
123954: PPUSH
123955: CALL_OW 247
123959: PUSH
123960: LD_INT 3
123962: EQUAL
123963: PUSH
123964: LD_VAR 0 14
123968: PUSH
123969: LD_INT 1
123971: ARRAY
123972: PUSH
123973: LD_VAR 0 27
123977: IN
123978: NOT
123979: AND
123980: IFFALSE 124187
// begin x := GetX ( tmp [ 1 ] ) ;
123982: LD_ADDR_VAR 0 10
123986: PUSH
123987: LD_VAR 0 14
123991: PUSH
123992: LD_INT 1
123994: ARRAY
123995: PPUSH
123996: CALL_OW 250
124000: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
124001: LD_ADDR_VAR 0 11
124005: PUSH
124006: LD_VAR 0 14
124010: PUSH
124011: LD_INT 1
124013: ARRAY
124014: PPUSH
124015: CALL_OW 251
124019: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
124020: LD_ADDR_VAR 0 12
124024: PUSH
124025: LD_VAR 0 4
124029: PUSH
124030: LD_VAR 0 7
124034: ARRAY
124035: PPUSH
124036: CALL 98125 0 1
124040: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
124041: LD_VAR 0 4
124045: PUSH
124046: LD_VAR 0 7
124050: ARRAY
124051: PPUSH
124052: LD_VAR 0 10
124056: PPUSH
124057: LD_VAR 0 11
124061: PPUSH
124062: LD_VAR 0 14
124066: PUSH
124067: LD_INT 1
124069: ARRAY
124070: PPUSH
124071: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
124075: LD_VAR 0 4
124079: PUSH
124080: LD_VAR 0 7
124084: ARRAY
124085: PPUSH
124086: LD_VAR 0 10
124090: PPUSH
124091: LD_VAR 0 12
124095: PPUSH
124096: LD_INT 7
124098: PPUSH
124099: CALL_OW 272
124103: PPUSH
124104: LD_VAR 0 11
124108: PPUSH
124109: LD_VAR 0 12
124113: PPUSH
124114: LD_INT 7
124116: PPUSH
124117: CALL_OW 273
124121: PPUSH
124122: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
124126: LD_VAR 0 4
124130: PUSH
124131: LD_VAR 0 7
124135: ARRAY
124136: PPUSH
124137: LD_INT 71
124139: PPUSH
124140: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
124144: LD_ADDR_VAR 0 27
124148: PUSH
124149: LD_VAR 0 27
124153: PPUSH
124154: LD_VAR 0 27
124158: PUSH
124159: LD_INT 1
124161: PLUS
124162: PPUSH
124163: LD_VAR 0 14
124167: PUSH
124168: LD_INT 1
124170: ARRAY
124171: PPUSH
124172: CALL_OW 1
124176: ST_TO_ADDR
// attacking := true ;
124177: LD_ADDR_VAR 0 29
124181: PUSH
124182: LD_INT 1
124184: ST_TO_ADDR
// continue ;
124185: GO 122032
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
124187: LD_VAR 0 4
124191: PUSH
124192: LD_VAR 0 7
124196: ARRAY
124197: PPUSH
124198: CALL_OW 257
124202: PUSH
124203: LD_INT 17
124205: EQUAL
124206: PUSH
124207: LD_VAR 0 4
124211: PUSH
124212: LD_VAR 0 7
124216: ARRAY
124217: PPUSH
124218: CALL_OW 110
124222: PUSH
124223: LD_INT 71
124225: EQUAL
124226: NOT
124227: AND
124228: IFFALSE 124374
// begin attacking := false ;
124230: LD_ADDR_VAR 0 29
124234: PUSH
124235: LD_INT 0
124237: ST_TO_ADDR
// k := 5 ;
124238: LD_ADDR_VAR 0 9
124242: PUSH
124243: LD_INT 5
124245: ST_TO_ADDR
// if tmp < k then
124246: LD_VAR 0 14
124250: PUSH
124251: LD_VAR 0 9
124255: LESS
124256: IFFALSE 124268
// k := tmp ;
124258: LD_ADDR_VAR 0 9
124262: PUSH
124263: LD_VAR 0 14
124267: ST_TO_ADDR
// for j = 1 to k do
124268: LD_ADDR_VAR 0 8
124272: PUSH
124273: DOUBLE
124274: LD_INT 1
124276: DEC
124277: ST_TO_ADDR
124278: LD_VAR 0 9
124282: PUSH
124283: FOR_TO
124284: IFFALSE 124372
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
124286: LD_VAR 0 14
124290: PUSH
124291: LD_VAR 0 8
124295: ARRAY
124296: PUSH
124297: LD_VAR 0 14
124301: PPUSH
124302: LD_INT 58
124304: PUSH
124305: EMPTY
124306: LIST
124307: PPUSH
124308: CALL_OW 72
124312: IN
124313: NOT
124314: IFFALSE 124370
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
124316: LD_VAR 0 4
124320: PUSH
124321: LD_VAR 0 7
124325: ARRAY
124326: PPUSH
124327: LD_VAR 0 14
124331: PUSH
124332: LD_VAR 0 8
124336: ARRAY
124337: PPUSH
124338: CALL_OW 115
// attacking := true ;
124342: LD_ADDR_VAR 0 29
124346: PUSH
124347: LD_INT 1
124349: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
124350: LD_VAR 0 4
124354: PUSH
124355: LD_VAR 0 7
124359: ARRAY
124360: PPUSH
124361: LD_INT 71
124363: PPUSH
124364: CALL_OW 109
// continue ;
124368: GO 124283
// end ; end ;
124370: GO 124283
124372: POP
124373: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
124374: LD_VAR 0 4
124378: PUSH
124379: LD_VAR 0 7
124383: ARRAY
124384: PPUSH
124385: CALL_OW 257
124389: PUSH
124390: LD_INT 8
124392: EQUAL
124393: PUSH
124394: LD_VAR 0 4
124398: PUSH
124399: LD_VAR 0 7
124403: ARRAY
124404: PPUSH
124405: CALL_OW 264
124409: PUSH
124410: LD_INT 28
124412: PUSH
124413: LD_INT 45
124415: PUSH
124416: LD_INT 7
124418: PUSH
124419: LD_INT 47
124421: PUSH
124422: EMPTY
124423: LIST
124424: LIST
124425: LIST
124426: LIST
124427: IN
124428: OR
124429: IFFALSE 124685
// begin attacking := false ;
124431: LD_ADDR_VAR 0 29
124435: PUSH
124436: LD_INT 0
124438: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
124439: LD_VAR 0 14
124443: PUSH
124444: LD_INT 1
124446: ARRAY
124447: PPUSH
124448: CALL_OW 266
124452: PUSH
124453: LD_INT 32
124455: PUSH
124456: LD_INT 31
124458: PUSH
124459: LD_INT 33
124461: PUSH
124462: LD_INT 4
124464: PUSH
124465: LD_INT 5
124467: PUSH
124468: EMPTY
124469: LIST
124470: LIST
124471: LIST
124472: LIST
124473: LIST
124474: IN
124475: IFFALSE 124661
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
124477: LD_ADDR_VAR 0 9
124481: PUSH
124482: LD_VAR 0 14
124486: PUSH
124487: LD_INT 1
124489: ARRAY
124490: PPUSH
124491: CALL_OW 266
124495: PPUSH
124496: LD_VAR 0 14
124500: PUSH
124501: LD_INT 1
124503: ARRAY
124504: PPUSH
124505: CALL_OW 250
124509: PPUSH
124510: LD_VAR 0 14
124514: PUSH
124515: LD_INT 1
124517: ARRAY
124518: PPUSH
124519: CALL_OW 251
124523: PPUSH
124524: LD_VAR 0 14
124528: PUSH
124529: LD_INT 1
124531: ARRAY
124532: PPUSH
124533: CALL_OW 254
124537: PPUSH
124538: LD_VAR 0 14
124542: PUSH
124543: LD_INT 1
124545: ARRAY
124546: PPUSH
124547: CALL_OW 248
124551: PPUSH
124552: LD_INT 0
124554: PPUSH
124555: CALL 79495 0 6
124559: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
124560: LD_ADDR_VAR 0 8
124564: PUSH
124565: LD_VAR 0 4
124569: PUSH
124570: LD_VAR 0 7
124574: ARRAY
124575: PPUSH
124576: LD_VAR 0 9
124580: PPUSH
124581: CALL 98165 0 2
124585: ST_TO_ADDR
// if j then
124586: LD_VAR 0 8
124590: IFFALSE 124659
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
124592: LD_VAR 0 8
124596: PUSH
124597: LD_INT 1
124599: ARRAY
124600: PPUSH
124601: LD_VAR 0 8
124605: PUSH
124606: LD_INT 2
124608: ARRAY
124609: PPUSH
124610: CALL_OW 488
124614: IFFALSE 124659
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
124616: LD_VAR 0 4
124620: PUSH
124621: LD_VAR 0 7
124625: ARRAY
124626: PPUSH
124627: LD_VAR 0 8
124631: PUSH
124632: LD_INT 1
124634: ARRAY
124635: PPUSH
124636: LD_VAR 0 8
124640: PUSH
124641: LD_INT 2
124643: ARRAY
124644: PPUSH
124645: CALL_OW 116
// attacking := true ;
124649: LD_ADDR_VAR 0 29
124653: PUSH
124654: LD_INT 1
124656: ST_TO_ADDR
// continue ;
124657: GO 122032
// end ; end else
124659: GO 124685
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124661: LD_VAR 0 4
124665: PUSH
124666: LD_VAR 0 7
124670: ARRAY
124671: PPUSH
124672: LD_VAR 0 14
124676: PUSH
124677: LD_INT 1
124679: ARRAY
124680: PPUSH
124681: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
124685: LD_VAR 0 4
124689: PUSH
124690: LD_VAR 0 7
124694: ARRAY
124695: PPUSH
124696: CALL_OW 265
124700: PUSH
124701: LD_INT 11
124703: EQUAL
124704: IFFALSE 124982
// begin k := 10 ;
124706: LD_ADDR_VAR 0 9
124710: PUSH
124711: LD_INT 10
124713: ST_TO_ADDR
// x := 0 ;
124714: LD_ADDR_VAR 0 10
124718: PUSH
124719: LD_INT 0
124721: ST_TO_ADDR
// if tmp < k then
124722: LD_VAR 0 14
124726: PUSH
124727: LD_VAR 0 9
124731: LESS
124732: IFFALSE 124744
// k := tmp ;
124734: LD_ADDR_VAR 0 9
124738: PUSH
124739: LD_VAR 0 14
124743: ST_TO_ADDR
// for j = k downto 1 do
124744: LD_ADDR_VAR 0 8
124748: PUSH
124749: DOUBLE
124750: LD_VAR 0 9
124754: INC
124755: ST_TO_ADDR
124756: LD_INT 1
124758: PUSH
124759: FOR_DOWNTO
124760: IFFALSE 124835
// begin if GetType ( tmp [ j ] ) = unit_human then
124762: LD_VAR 0 14
124766: PUSH
124767: LD_VAR 0 8
124771: ARRAY
124772: PPUSH
124773: CALL_OW 247
124777: PUSH
124778: LD_INT 1
124780: EQUAL
124781: IFFALSE 124833
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
124783: LD_VAR 0 4
124787: PUSH
124788: LD_VAR 0 7
124792: ARRAY
124793: PPUSH
124794: LD_VAR 0 14
124798: PUSH
124799: LD_VAR 0 8
124803: ARRAY
124804: PPUSH
124805: CALL 98436 0 2
// x := tmp [ j ] ;
124809: LD_ADDR_VAR 0 10
124813: PUSH
124814: LD_VAR 0 14
124818: PUSH
124819: LD_VAR 0 8
124823: ARRAY
124824: ST_TO_ADDR
// attacking := true ;
124825: LD_ADDR_VAR 0 29
124829: PUSH
124830: LD_INT 1
124832: ST_TO_ADDR
// end ; end ;
124833: GO 124759
124835: POP
124836: POP
// if not x then
124837: LD_VAR 0 10
124841: NOT
124842: IFFALSE 124982
// begin attacking := true ;
124844: LD_ADDR_VAR 0 29
124848: PUSH
124849: LD_INT 1
124851: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
124852: LD_VAR 0 4
124856: PUSH
124857: LD_VAR 0 7
124861: ARRAY
124862: PPUSH
124863: CALL_OW 250
124867: PPUSH
124868: LD_VAR 0 4
124872: PUSH
124873: LD_VAR 0 7
124877: ARRAY
124878: PPUSH
124879: CALL_OW 251
124883: PPUSH
124884: CALL_OW 546
124888: PUSH
124889: LD_INT 2
124891: ARRAY
124892: PUSH
124893: LD_VAR 0 14
124897: PUSH
124898: LD_INT 1
124900: ARRAY
124901: PPUSH
124902: CALL_OW 250
124906: PPUSH
124907: LD_VAR 0 14
124911: PUSH
124912: LD_INT 1
124914: ARRAY
124915: PPUSH
124916: CALL_OW 251
124920: PPUSH
124921: CALL_OW 546
124925: PUSH
124926: LD_INT 2
124928: ARRAY
124929: EQUAL
124930: IFFALSE 124958
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
124932: LD_VAR 0 4
124936: PUSH
124937: LD_VAR 0 7
124941: ARRAY
124942: PPUSH
124943: LD_VAR 0 14
124947: PUSH
124948: LD_INT 1
124950: ARRAY
124951: PPUSH
124952: CALL 98436 0 2
124956: GO 124982
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124958: LD_VAR 0 4
124962: PUSH
124963: LD_VAR 0 7
124967: ARRAY
124968: PPUSH
124969: LD_VAR 0 14
124973: PUSH
124974: LD_INT 1
124976: ARRAY
124977: PPUSH
124978: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
124982: LD_VAR 0 4
124986: PUSH
124987: LD_VAR 0 7
124991: ARRAY
124992: PPUSH
124993: CALL_OW 264
124997: PUSH
124998: LD_INT 29
125000: EQUAL
125001: IFFALSE 125367
// begin if WantsToAttack ( group [ i ] ) in bombed then
125003: LD_VAR 0 4
125007: PUSH
125008: LD_VAR 0 7
125012: ARRAY
125013: PPUSH
125014: CALL_OW 319
125018: PUSH
125019: LD_VAR 0 28
125023: IN
125024: IFFALSE 125028
// continue ;
125026: GO 122032
// k := 8 ;
125028: LD_ADDR_VAR 0 9
125032: PUSH
125033: LD_INT 8
125035: ST_TO_ADDR
// x := 0 ;
125036: LD_ADDR_VAR 0 10
125040: PUSH
125041: LD_INT 0
125043: ST_TO_ADDR
// if tmp < k then
125044: LD_VAR 0 14
125048: PUSH
125049: LD_VAR 0 9
125053: LESS
125054: IFFALSE 125066
// k := tmp ;
125056: LD_ADDR_VAR 0 9
125060: PUSH
125061: LD_VAR 0 14
125065: ST_TO_ADDR
// for j = 1 to k do
125066: LD_ADDR_VAR 0 8
125070: PUSH
125071: DOUBLE
125072: LD_INT 1
125074: DEC
125075: ST_TO_ADDR
125076: LD_VAR 0 9
125080: PUSH
125081: FOR_TO
125082: IFFALSE 125214
// begin if GetType ( tmp [ j ] ) = unit_building then
125084: LD_VAR 0 14
125088: PUSH
125089: LD_VAR 0 8
125093: ARRAY
125094: PPUSH
125095: CALL_OW 247
125099: PUSH
125100: LD_INT 3
125102: EQUAL
125103: IFFALSE 125212
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
125105: LD_VAR 0 14
125109: PUSH
125110: LD_VAR 0 8
125114: ARRAY
125115: PUSH
125116: LD_VAR 0 28
125120: IN
125121: NOT
125122: PUSH
125123: LD_VAR 0 14
125127: PUSH
125128: LD_VAR 0 8
125132: ARRAY
125133: PPUSH
125134: CALL_OW 313
125138: AND
125139: IFFALSE 125212
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
125141: LD_VAR 0 4
125145: PUSH
125146: LD_VAR 0 7
125150: ARRAY
125151: PPUSH
125152: LD_VAR 0 14
125156: PUSH
125157: LD_VAR 0 8
125161: ARRAY
125162: PPUSH
125163: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
125167: LD_ADDR_VAR 0 28
125171: PUSH
125172: LD_VAR 0 28
125176: PPUSH
125177: LD_VAR 0 28
125181: PUSH
125182: LD_INT 1
125184: PLUS
125185: PPUSH
125186: LD_VAR 0 14
125190: PUSH
125191: LD_VAR 0 8
125195: ARRAY
125196: PPUSH
125197: CALL_OW 1
125201: ST_TO_ADDR
// attacking := true ;
125202: LD_ADDR_VAR 0 29
125206: PUSH
125207: LD_INT 1
125209: ST_TO_ADDR
// break ;
125210: GO 125214
// end ; end ;
125212: GO 125081
125214: POP
125215: POP
// if not attacking and f_attack_depot then
125216: LD_VAR 0 29
125220: NOT
125221: PUSH
125222: LD_VAR 0 25
125226: AND
125227: IFFALSE 125322
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
125229: LD_ADDR_VAR 0 13
125233: PUSH
125234: LD_VAR 0 14
125238: PPUSH
125239: LD_INT 2
125241: PUSH
125242: LD_INT 30
125244: PUSH
125245: LD_INT 0
125247: PUSH
125248: EMPTY
125249: LIST
125250: LIST
125251: PUSH
125252: LD_INT 30
125254: PUSH
125255: LD_INT 1
125257: PUSH
125258: EMPTY
125259: LIST
125260: LIST
125261: PUSH
125262: EMPTY
125263: LIST
125264: LIST
125265: LIST
125266: PPUSH
125267: CALL_OW 72
125271: ST_TO_ADDR
// if z then
125272: LD_VAR 0 13
125276: IFFALSE 125322
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
125278: LD_VAR 0 4
125282: PUSH
125283: LD_VAR 0 7
125287: ARRAY
125288: PPUSH
125289: LD_VAR 0 13
125293: PPUSH
125294: LD_VAR 0 4
125298: PUSH
125299: LD_VAR 0 7
125303: ARRAY
125304: PPUSH
125305: CALL_OW 74
125309: PPUSH
125310: CALL_OW 115
// attacking := true ;
125314: LD_ADDR_VAR 0 29
125318: PUSH
125319: LD_INT 1
125321: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
125322: LD_VAR 0 4
125326: PUSH
125327: LD_VAR 0 7
125331: ARRAY
125332: PPUSH
125333: CALL_OW 256
125337: PUSH
125338: LD_INT 500
125340: LESS
125341: IFFALSE 125367
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125343: LD_VAR 0 4
125347: PUSH
125348: LD_VAR 0 7
125352: ARRAY
125353: PPUSH
125354: LD_VAR 0 14
125358: PUSH
125359: LD_INT 1
125361: ARRAY
125362: PPUSH
125363: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
125367: LD_VAR 0 4
125371: PUSH
125372: LD_VAR 0 7
125376: ARRAY
125377: PPUSH
125378: CALL_OW 264
125382: PUSH
125383: LD_INT 49
125385: EQUAL
125386: IFFALSE 125507
// begin if not HasTask ( group [ i ] ) then
125388: LD_VAR 0 4
125392: PUSH
125393: LD_VAR 0 7
125397: ARRAY
125398: PPUSH
125399: CALL_OW 314
125403: NOT
125404: IFFALSE 125507
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
125406: LD_ADDR_VAR 0 9
125410: PUSH
125411: LD_INT 81
125413: PUSH
125414: LD_VAR 0 4
125418: PUSH
125419: LD_VAR 0 7
125423: ARRAY
125424: PPUSH
125425: CALL_OW 255
125429: PUSH
125430: EMPTY
125431: LIST
125432: LIST
125433: PPUSH
125434: CALL_OW 69
125438: PPUSH
125439: LD_VAR 0 4
125443: PUSH
125444: LD_VAR 0 7
125448: ARRAY
125449: PPUSH
125450: CALL_OW 74
125454: ST_TO_ADDR
// if k then
125455: LD_VAR 0 9
125459: IFFALSE 125507
// if GetDistUnits ( group [ i ] , k ) > 10 then
125461: LD_VAR 0 4
125465: PUSH
125466: LD_VAR 0 7
125470: ARRAY
125471: PPUSH
125472: LD_VAR 0 9
125476: PPUSH
125477: CALL_OW 296
125481: PUSH
125482: LD_INT 10
125484: GREATER
125485: IFFALSE 125507
// ComMoveUnit ( group [ i ] , k ) ;
125487: LD_VAR 0 4
125491: PUSH
125492: LD_VAR 0 7
125496: ARRAY
125497: PPUSH
125498: LD_VAR 0 9
125502: PPUSH
125503: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
125507: LD_VAR 0 4
125511: PUSH
125512: LD_VAR 0 7
125516: ARRAY
125517: PPUSH
125518: CALL_OW 256
125522: PUSH
125523: LD_INT 250
125525: LESS
125526: PUSH
125527: LD_VAR 0 4
125531: PUSH
125532: LD_VAR 0 7
125536: ARRAY
125537: PUSH
125538: LD_INT 21
125540: PUSH
125541: LD_INT 2
125543: PUSH
125544: EMPTY
125545: LIST
125546: LIST
125547: PUSH
125548: LD_INT 23
125550: PUSH
125551: LD_INT 2
125553: PUSH
125554: EMPTY
125555: LIST
125556: LIST
125557: PUSH
125558: EMPTY
125559: LIST
125560: LIST
125561: PPUSH
125562: CALL_OW 69
125566: IN
125567: AND
125568: IFFALSE 125693
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
125570: LD_ADDR_VAR 0 9
125574: PUSH
125575: LD_OWVAR 3
125579: PUSH
125580: LD_VAR 0 4
125584: PUSH
125585: LD_VAR 0 7
125589: ARRAY
125590: DIFF
125591: PPUSH
125592: LD_VAR 0 4
125596: PUSH
125597: LD_VAR 0 7
125601: ARRAY
125602: PPUSH
125603: CALL_OW 74
125607: ST_TO_ADDR
// if not k then
125608: LD_VAR 0 9
125612: NOT
125613: IFFALSE 125617
// continue ;
125615: GO 122032
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
125617: LD_VAR 0 9
125621: PUSH
125622: LD_INT 81
125624: PUSH
125625: LD_VAR 0 4
125629: PUSH
125630: LD_VAR 0 7
125634: ARRAY
125635: PPUSH
125636: CALL_OW 255
125640: PUSH
125641: EMPTY
125642: LIST
125643: LIST
125644: PPUSH
125645: CALL_OW 69
125649: IN
125650: PUSH
125651: LD_VAR 0 9
125655: PPUSH
125656: LD_VAR 0 4
125660: PUSH
125661: LD_VAR 0 7
125665: ARRAY
125666: PPUSH
125667: CALL_OW 296
125671: PUSH
125672: LD_INT 5
125674: LESS
125675: AND
125676: IFFALSE 125693
// ComAutodestruct ( group [ i ] ) ;
125678: LD_VAR 0 4
125682: PUSH
125683: LD_VAR 0 7
125687: ARRAY
125688: PPUSH
125689: CALL 98334 0 1
// end ; if f_attack_depot then
125693: LD_VAR 0 25
125697: IFFALSE 125809
// begin k := 6 ;
125699: LD_ADDR_VAR 0 9
125703: PUSH
125704: LD_INT 6
125706: ST_TO_ADDR
// if tmp < k then
125707: LD_VAR 0 14
125711: PUSH
125712: LD_VAR 0 9
125716: LESS
125717: IFFALSE 125729
// k := tmp ;
125719: LD_ADDR_VAR 0 9
125723: PUSH
125724: LD_VAR 0 14
125728: ST_TO_ADDR
// for j = 1 to k do
125729: LD_ADDR_VAR 0 8
125733: PUSH
125734: DOUBLE
125735: LD_INT 1
125737: DEC
125738: ST_TO_ADDR
125739: LD_VAR 0 9
125743: PUSH
125744: FOR_TO
125745: IFFALSE 125807
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
125747: LD_VAR 0 8
125751: PPUSH
125752: CALL_OW 266
125756: PUSH
125757: LD_INT 0
125759: PUSH
125760: LD_INT 1
125762: PUSH
125763: EMPTY
125764: LIST
125765: LIST
125766: IN
125767: IFFALSE 125805
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
125769: LD_VAR 0 4
125773: PUSH
125774: LD_VAR 0 7
125778: ARRAY
125779: PPUSH
125780: LD_VAR 0 14
125784: PUSH
125785: LD_VAR 0 8
125789: ARRAY
125790: PPUSH
125791: CALL_OW 115
// attacking := true ;
125795: LD_ADDR_VAR 0 29
125799: PUSH
125800: LD_INT 1
125802: ST_TO_ADDR
// break ;
125803: GO 125807
// end ;
125805: GO 125744
125807: POP
125808: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
125809: LD_VAR 0 4
125813: PUSH
125814: LD_VAR 0 7
125818: ARRAY
125819: PPUSH
125820: CALL_OW 302
125824: PUSH
125825: LD_VAR 0 29
125829: NOT
125830: AND
125831: IFFALSE 126153
// begin if GetTag ( group [ i ] ) = 71 then
125833: LD_VAR 0 4
125837: PUSH
125838: LD_VAR 0 7
125842: ARRAY
125843: PPUSH
125844: CALL_OW 110
125848: PUSH
125849: LD_INT 71
125851: EQUAL
125852: IFFALSE 125893
// begin if HasTask ( group [ i ] ) then
125854: LD_VAR 0 4
125858: PUSH
125859: LD_VAR 0 7
125863: ARRAY
125864: PPUSH
125865: CALL_OW 314
125869: IFFALSE 125875
// continue else
125871: GO 122032
125873: GO 125893
// SetTag ( group [ i ] , 0 ) ;
125875: LD_VAR 0 4
125879: PUSH
125880: LD_VAR 0 7
125884: ARRAY
125885: PPUSH
125886: LD_INT 0
125888: PPUSH
125889: CALL_OW 109
// end ; k := 8 ;
125893: LD_ADDR_VAR 0 9
125897: PUSH
125898: LD_INT 8
125900: ST_TO_ADDR
// x := 0 ;
125901: LD_ADDR_VAR 0 10
125905: PUSH
125906: LD_INT 0
125908: ST_TO_ADDR
// if tmp < k then
125909: LD_VAR 0 14
125913: PUSH
125914: LD_VAR 0 9
125918: LESS
125919: IFFALSE 125931
// k := tmp ;
125921: LD_ADDR_VAR 0 9
125925: PUSH
125926: LD_VAR 0 14
125930: ST_TO_ADDR
// for j = 1 to k do
125931: LD_ADDR_VAR 0 8
125935: PUSH
125936: DOUBLE
125937: LD_INT 1
125939: DEC
125940: ST_TO_ADDR
125941: LD_VAR 0 9
125945: PUSH
125946: FOR_TO
125947: IFFALSE 126045
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
125949: LD_VAR 0 14
125953: PUSH
125954: LD_VAR 0 8
125958: ARRAY
125959: PPUSH
125960: CALL_OW 247
125964: PUSH
125965: LD_INT 1
125967: EQUAL
125968: PUSH
125969: LD_VAR 0 14
125973: PUSH
125974: LD_VAR 0 8
125978: ARRAY
125979: PPUSH
125980: CALL_OW 256
125984: PUSH
125985: LD_INT 250
125987: LESS
125988: PUSH
125989: LD_VAR 0 20
125993: AND
125994: PUSH
125995: LD_VAR 0 20
125999: NOT
126000: PUSH
126001: LD_VAR 0 14
126005: PUSH
126006: LD_VAR 0 8
126010: ARRAY
126011: PPUSH
126012: CALL_OW 256
126016: PUSH
126017: LD_INT 250
126019: GREATEREQUAL
126020: AND
126021: OR
126022: AND
126023: IFFALSE 126043
// begin x := tmp [ j ] ;
126025: LD_ADDR_VAR 0 10
126029: PUSH
126030: LD_VAR 0 14
126034: PUSH
126035: LD_VAR 0 8
126039: ARRAY
126040: ST_TO_ADDR
// break ;
126041: GO 126045
// end ;
126043: GO 125946
126045: POP
126046: POP
// if x then
126047: LD_VAR 0 10
126051: IFFALSE 126075
// ComAttackUnit ( group [ i ] , x ) else
126053: LD_VAR 0 4
126057: PUSH
126058: LD_VAR 0 7
126062: ARRAY
126063: PPUSH
126064: LD_VAR 0 10
126068: PPUSH
126069: CALL_OW 115
126073: GO 126099
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
126075: LD_VAR 0 4
126079: PUSH
126080: LD_VAR 0 7
126084: ARRAY
126085: PPUSH
126086: LD_VAR 0 14
126090: PUSH
126091: LD_INT 1
126093: ARRAY
126094: PPUSH
126095: CALL_OW 115
// if not HasTask ( group [ i ] ) then
126099: LD_VAR 0 4
126103: PUSH
126104: LD_VAR 0 7
126108: ARRAY
126109: PPUSH
126110: CALL_OW 314
126114: NOT
126115: IFFALSE 126153
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
126117: LD_VAR 0 4
126121: PUSH
126122: LD_VAR 0 7
126126: ARRAY
126127: PPUSH
126128: LD_VAR 0 14
126132: PPUSH
126133: LD_VAR 0 4
126137: PUSH
126138: LD_VAR 0 7
126142: ARRAY
126143: PPUSH
126144: CALL_OW 74
126148: PPUSH
126149: CALL_OW 115
// end ; end ; end ;
126153: GO 122032
126155: POP
126156: POP
// wait ( 0 0$2 ) ;
126157: LD_INT 70
126159: PPUSH
126160: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
126164: LD_VAR 0 4
126168: NOT
126169: PUSH
126170: LD_VAR 0 4
126174: PUSH
126175: EMPTY
126176: EQUAL
126177: OR
126178: PUSH
126179: LD_INT 81
126181: PUSH
126182: LD_VAR 0 35
126186: PUSH
126187: EMPTY
126188: LIST
126189: LIST
126190: PPUSH
126191: CALL_OW 69
126195: NOT
126196: OR
126197: IFFALSE 122017
// end ;
126199: LD_VAR 0 2
126203: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
126204: LD_INT 0
126206: PPUSH
126207: PPUSH
126208: PPUSH
126209: PPUSH
126210: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
126211: LD_VAR 0 1
126215: NOT
126216: PUSH
126217: LD_EXP 116
126221: PUSH
126222: LD_VAR 0 1
126226: ARRAY
126227: NOT
126228: OR
126229: PUSH
126230: LD_VAR 0 2
126234: NOT
126235: OR
126236: PUSH
126237: LD_VAR 0 3
126241: NOT
126242: OR
126243: IFFALSE 126247
// exit ;
126245: GO 126760
// side := mc_sides [ base ] ;
126247: LD_ADDR_VAR 0 6
126251: PUSH
126252: LD_EXP 142
126256: PUSH
126257: LD_VAR 0 1
126261: ARRAY
126262: ST_TO_ADDR
// if not side then
126263: LD_VAR 0 6
126267: NOT
126268: IFFALSE 126272
// exit ;
126270: GO 126760
// for i in solds do
126272: LD_ADDR_VAR 0 7
126276: PUSH
126277: LD_VAR 0 2
126281: PUSH
126282: FOR_IN
126283: IFFALSE 126344
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
126285: LD_VAR 0 7
126289: PPUSH
126290: CALL_OW 310
126294: PPUSH
126295: CALL_OW 266
126299: PUSH
126300: LD_INT 32
126302: PUSH
126303: LD_INT 31
126305: PUSH
126306: EMPTY
126307: LIST
126308: LIST
126309: IN
126310: IFFALSE 126330
// solds := solds diff i else
126312: LD_ADDR_VAR 0 2
126316: PUSH
126317: LD_VAR 0 2
126321: PUSH
126322: LD_VAR 0 7
126326: DIFF
126327: ST_TO_ADDR
126328: GO 126342
// SetTag ( i , 18 ) ;
126330: LD_VAR 0 7
126334: PPUSH
126335: LD_INT 18
126337: PPUSH
126338: CALL_OW 109
126342: GO 126282
126344: POP
126345: POP
// if not solds then
126346: LD_VAR 0 2
126350: NOT
126351: IFFALSE 126355
// exit ;
126353: GO 126760
// repeat wait ( 0 0$2 ) ;
126355: LD_INT 70
126357: PPUSH
126358: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
126362: LD_ADDR_VAR 0 5
126366: PUSH
126367: LD_VAR 0 6
126371: PPUSH
126372: LD_VAR 0 3
126376: PPUSH
126377: CALL 67304 0 2
126381: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126382: LD_EXP 116
126386: PUSH
126387: LD_VAR 0 1
126391: ARRAY
126392: NOT
126393: PUSH
126394: LD_EXP 116
126398: PUSH
126399: LD_VAR 0 1
126403: ARRAY
126404: PUSH
126405: EMPTY
126406: EQUAL
126407: OR
126408: IFFALSE 126445
// begin for i in solds do
126410: LD_ADDR_VAR 0 7
126414: PUSH
126415: LD_VAR 0 2
126419: PUSH
126420: FOR_IN
126421: IFFALSE 126434
// ComStop ( i ) ;
126423: LD_VAR 0 7
126427: PPUSH
126428: CALL_OW 141
126432: GO 126420
126434: POP
126435: POP
// solds := [ ] ;
126436: LD_ADDR_VAR 0 2
126440: PUSH
126441: EMPTY
126442: ST_TO_ADDR
// exit ;
126443: GO 126760
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
126445: LD_VAR 0 5
126449: NOT
126450: PUSH
126451: LD_VAR 0 5
126455: PUSH
126456: LD_INT 3
126458: GREATER
126459: OR
126460: PUSH
126461: LD_EXP 138
126465: PUSH
126466: LD_VAR 0 1
126470: ARRAY
126471: OR
126472: IFFALSE 126513
// begin for i in solds do
126474: LD_ADDR_VAR 0 7
126478: PUSH
126479: LD_VAR 0 2
126483: PUSH
126484: FOR_IN
126485: IFFALSE 126509
// if HasTask ( i ) then
126487: LD_VAR 0 7
126491: PPUSH
126492: CALL_OW 314
126496: IFFALSE 126507
// ComStop ( i ) ;
126498: LD_VAR 0 7
126502: PPUSH
126503: CALL_OW 141
126507: GO 126484
126509: POP
126510: POP
// break ;
126511: GO 126748
// end ; for i in solds do
126513: LD_ADDR_VAR 0 7
126517: PUSH
126518: LD_VAR 0 2
126522: PUSH
126523: FOR_IN
126524: IFFALSE 126740
// begin if IsInUnit ( i ) then
126526: LD_VAR 0 7
126530: PPUSH
126531: CALL_OW 310
126535: IFFALSE 126546
// ComExitBuilding ( i ) ;
126537: LD_VAR 0 7
126541: PPUSH
126542: CALL_OW 122
// if GetLives ( i ) > 333 then
126546: LD_VAR 0 7
126550: PPUSH
126551: CALL_OW 256
126555: PUSH
126556: LD_INT 333
126558: GREATER
126559: IFFALSE 126587
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
126561: LD_VAR 0 7
126565: PPUSH
126566: LD_VAR 0 5
126570: PPUSH
126571: LD_VAR 0 7
126575: PPUSH
126576: CALL_OW 74
126580: PPUSH
126581: CALL_OW 115
126585: GO 126738
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
126587: LD_ADDR_VAR 0 8
126591: PUSH
126592: LD_EXP 116
126596: PUSH
126597: LD_VAR 0 1
126601: ARRAY
126602: PPUSH
126603: LD_INT 2
126605: PUSH
126606: LD_INT 30
126608: PUSH
126609: LD_INT 0
126611: PUSH
126612: EMPTY
126613: LIST
126614: LIST
126615: PUSH
126616: LD_INT 30
126618: PUSH
126619: LD_INT 1
126621: PUSH
126622: EMPTY
126623: LIST
126624: LIST
126625: PUSH
126626: LD_INT 30
126628: PUSH
126629: LD_INT 6
126631: PUSH
126632: EMPTY
126633: LIST
126634: LIST
126635: PUSH
126636: EMPTY
126637: LIST
126638: LIST
126639: LIST
126640: LIST
126641: PPUSH
126642: CALL_OW 72
126646: PPUSH
126647: LD_VAR 0 7
126651: PPUSH
126652: CALL_OW 74
126656: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
126657: LD_VAR 0 7
126661: PPUSH
126662: LD_VAR 0 8
126666: PPUSH
126667: CALL_OW 250
126671: PPUSH
126672: LD_INT 3
126674: PPUSH
126675: LD_INT 5
126677: PPUSH
126678: CALL_OW 272
126682: PPUSH
126683: LD_VAR 0 8
126687: PPUSH
126688: CALL_OW 251
126692: PPUSH
126693: LD_INT 3
126695: PPUSH
126696: LD_INT 5
126698: PPUSH
126699: CALL_OW 273
126703: PPUSH
126704: CALL_OW 111
// SetTag ( i , 0 ) ;
126708: LD_VAR 0 7
126712: PPUSH
126713: LD_INT 0
126715: PPUSH
126716: CALL_OW 109
// solds := solds diff i ;
126720: LD_ADDR_VAR 0 2
126724: PUSH
126725: LD_VAR 0 2
126729: PUSH
126730: LD_VAR 0 7
126734: DIFF
126735: ST_TO_ADDR
// continue ;
126736: GO 126523
// end ; end ;
126738: GO 126523
126740: POP
126741: POP
// until solds ;
126742: LD_VAR 0 2
126746: IFFALSE 126355
// MC_Reset ( base , 18 ) ;
126748: LD_VAR 0 1
126752: PPUSH
126753: LD_INT 18
126755: PPUSH
126756: CALL 39297 0 2
// end ;
126760: LD_VAR 0 4
126764: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class ; begin
126765: LD_INT 0
126767: PPUSH
126768: PPUSH
126769: PPUSH
126770: PPUSH
126771: PPUSH
126772: PPUSH
126773: PPUSH
126774: PPUSH
126775: PPUSH
126776: PPUSH
126777: PPUSH
126778: PPUSH
126779: PPUSH
126780: PPUSH
126781: PPUSH
126782: PPUSH
126783: PPUSH
126784: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
126785: LD_ADDR_VAR 0 13
126789: PUSH
126790: LD_EXP 116
126794: PUSH
126795: LD_VAR 0 1
126799: ARRAY
126800: PPUSH
126801: LD_INT 25
126803: PUSH
126804: LD_INT 3
126806: PUSH
126807: EMPTY
126808: LIST
126809: LIST
126810: PPUSH
126811: CALL_OW 72
126815: ST_TO_ADDR
// if mc_remote_driver [ base ] then
126816: LD_EXP 156
126820: PUSH
126821: LD_VAR 0 1
126825: ARRAY
126826: IFFALSE 126850
// mechs := mechs diff mc_remote_driver [ base ] ;
126828: LD_ADDR_VAR 0 13
126832: PUSH
126833: LD_VAR 0 13
126837: PUSH
126838: LD_EXP 156
126842: PUSH
126843: LD_VAR 0 1
126847: ARRAY
126848: DIFF
126849: ST_TO_ADDR
// for i in mechs do
126850: LD_ADDR_VAR 0 5
126854: PUSH
126855: LD_VAR 0 13
126859: PUSH
126860: FOR_IN
126861: IFFALSE 126896
// if GetTag ( i ) > 0 then
126863: LD_VAR 0 5
126867: PPUSH
126868: CALL_OW 110
126872: PUSH
126873: LD_INT 0
126875: GREATER
126876: IFFALSE 126894
// mechs := mechs diff i ;
126878: LD_ADDR_VAR 0 13
126882: PUSH
126883: LD_VAR 0 13
126887: PUSH
126888: LD_VAR 0 5
126892: DIFF
126893: ST_TO_ADDR
126894: GO 126860
126896: POP
126897: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
126898: LD_ADDR_VAR 0 9
126902: PUSH
126903: LD_EXP 116
126907: PUSH
126908: LD_VAR 0 1
126912: ARRAY
126913: PPUSH
126914: LD_INT 2
126916: PUSH
126917: LD_INT 25
126919: PUSH
126920: LD_INT 1
126922: PUSH
126923: EMPTY
126924: LIST
126925: LIST
126926: PUSH
126927: LD_INT 25
126929: PUSH
126930: LD_INT 5
126932: PUSH
126933: EMPTY
126934: LIST
126935: LIST
126936: PUSH
126937: LD_INT 25
126939: PUSH
126940: LD_INT 8
126942: PUSH
126943: EMPTY
126944: LIST
126945: LIST
126946: PUSH
126947: LD_INT 25
126949: PUSH
126950: LD_INT 9
126952: PUSH
126953: EMPTY
126954: LIST
126955: LIST
126956: PUSH
126957: EMPTY
126958: LIST
126959: LIST
126960: LIST
126961: LIST
126962: LIST
126963: PPUSH
126964: CALL_OW 72
126968: ST_TO_ADDR
// if not defenders and not solds then
126969: LD_VAR 0 2
126973: NOT
126974: PUSH
126975: LD_VAR 0 9
126979: NOT
126980: AND
126981: IFFALSE 126985
// exit ;
126983: GO 128755
// depot_under_attack := false ;
126985: LD_ADDR_VAR 0 17
126989: PUSH
126990: LD_INT 0
126992: ST_TO_ADDR
// sold_defenders := [ ] ;
126993: LD_ADDR_VAR 0 18
126997: PUSH
126998: EMPTY
126999: ST_TO_ADDR
// if mechs then
127000: LD_VAR 0 13
127004: IFFALSE 127157
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
127006: LD_ADDR_VAR 0 5
127010: PUSH
127011: LD_VAR 0 2
127015: PPUSH
127016: LD_INT 21
127018: PUSH
127019: LD_INT 2
127021: PUSH
127022: EMPTY
127023: LIST
127024: LIST
127025: PPUSH
127026: CALL_OW 72
127030: PUSH
127031: FOR_IN
127032: IFFALSE 127155
// begin if GetTag ( i ) <> 20 then
127034: LD_VAR 0 5
127038: PPUSH
127039: CALL_OW 110
127043: PUSH
127044: LD_INT 20
127046: NONEQUAL
127047: IFFALSE 127061
// SetTag ( i , 20 ) ;
127049: LD_VAR 0 5
127053: PPUSH
127054: LD_INT 20
127056: PPUSH
127057: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
127061: LD_VAR 0 5
127065: PPUSH
127066: CALL_OW 263
127070: PUSH
127071: LD_INT 1
127073: EQUAL
127074: PUSH
127075: LD_VAR 0 5
127079: PPUSH
127080: CALL_OW 311
127084: NOT
127085: AND
127086: IFFALSE 127153
// begin un := mechs [ 1 ] ;
127088: LD_ADDR_VAR 0 11
127092: PUSH
127093: LD_VAR 0 13
127097: PUSH
127098: LD_INT 1
127100: ARRAY
127101: ST_TO_ADDR
// ComExit ( un ) ;
127102: LD_VAR 0 11
127106: PPUSH
127107: CALL 102679 0 1
// AddComEnterUnit ( un , i ) ;
127111: LD_VAR 0 11
127115: PPUSH
127116: LD_VAR 0 5
127120: PPUSH
127121: CALL_OW 180
// SetTag ( un , 19 ) ;
127125: LD_VAR 0 11
127129: PPUSH
127130: LD_INT 19
127132: PPUSH
127133: CALL_OW 109
// mechs := mechs diff un ;
127137: LD_ADDR_VAR 0 13
127141: PUSH
127142: LD_VAR 0 13
127146: PUSH
127147: LD_VAR 0 11
127151: DIFF
127152: ST_TO_ADDR
// end ; end ;
127153: GO 127031
127155: POP
127156: POP
// if solds then
127157: LD_VAR 0 9
127161: IFFALSE 127220
// for i in solds do
127163: LD_ADDR_VAR 0 5
127167: PUSH
127168: LD_VAR 0 9
127172: PUSH
127173: FOR_IN
127174: IFFALSE 127218
// if not GetTag ( i ) then
127176: LD_VAR 0 5
127180: PPUSH
127181: CALL_OW 110
127185: NOT
127186: IFFALSE 127216
// begin defenders := defenders union i ;
127188: LD_ADDR_VAR 0 2
127192: PUSH
127193: LD_VAR 0 2
127197: PUSH
127198: LD_VAR 0 5
127202: UNION
127203: ST_TO_ADDR
// SetTag ( i , 18 ) ;
127204: LD_VAR 0 5
127208: PPUSH
127209: LD_INT 18
127211: PPUSH
127212: CALL_OW 109
// end ;
127216: GO 127173
127218: POP
127219: POP
// repeat wait ( 0 0$2 ) ;
127220: LD_INT 70
127222: PPUSH
127223: CALL_OW 67
// enemy := mc_scan [ base ] ;
127227: LD_ADDR_VAR 0 3
127231: PUSH
127232: LD_EXP 139
127236: PUSH
127237: LD_VAR 0 1
127241: ARRAY
127242: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
127243: LD_EXP 116
127247: PUSH
127248: LD_VAR 0 1
127252: ARRAY
127253: NOT
127254: PUSH
127255: LD_EXP 116
127259: PUSH
127260: LD_VAR 0 1
127264: ARRAY
127265: PUSH
127266: EMPTY
127267: EQUAL
127268: OR
127269: IFFALSE 127306
// begin for i in defenders do
127271: LD_ADDR_VAR 0 5
127275: PUSH
127276: LD_VAR 0 2
127280: PUSH
127281: FOR_IN
127282: IFFALSE 127295
// ComStop ( i ) ;
127284: LD_VAR 0 5
127288: PPUSH
127289: CALL_OW 141
127293: GO 127281
127295: POP
127296: POP
// defenders := [ ] ;
127297: LD_ADDR_VAR 0 2
127301: PUSH
127302: EMPTY
127303: ST_TO_ADDR
// exit ;
127304: GO 128755
// end ; for i in defenders do
127306: LD_ADDR_VAR 0 5
127310: PUSH
127311: LD_VAR 0 2
127315: PUSH
127316: FOR_IN
127317: IFFALSE 128215
// begin e := NearestUnitToUnit ( enemy , i ) ;
127319: LD_ADDR_VAR 0 14
127323: PUSH
127324: LD_VAR 0 3
127328: PPUSH
127329: LD_VAR 0 5
127333: PPUSH
127334: CALL_OW 74
127338: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
127339: LD_ADDR_VAR 0 8
127343: PUSH
127344: LD_EXP 116
127348: PUSH
127349: LD_VAR 0 1
127353: ARRAY
127354: PPUSH
127355: LD_INT 2
127357: PUSH
127358: LD_INT 30
127360: PUSH
127361: LD_INT 0
127363: PUSH
127364: EMPTY
127365: LIST
127366: LIST
127367: PUSH
127368: LD_INT 30
127370: PUSH
127371: LD_INT 1
127373: PUSH
127374: EMPTY
127375: LIST
127376: LIST
127377: PUSH
127378: EMPTY
127379: LIST
127380: LIST
127381: LIST
127382: PPUSH
127383: CALL_OW 72
127387: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
127388: LD_ADDR_VAR 0 17
127392: PUSH
127393: LD_VAR 0 8
127397: NOT
127398: PUSH
127399: LD_VAR 0 8
127403: PPUSH
127404: LD_INT 3
127406: PUSH
127407: LD_INT 24
127409: PUSH
127410: LD_INT 600
127412: PUSH
127413: EMPTY
127414: LIST
127415: LIST
127416: PUSH
127417: EMPTY
127418: LIST
127419: LIST
127420: PPUSH
127421: CALL_OW 72
127425: OR
127426: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
127427: LD_VAR 0 5
127431: PPUSH
127432: CALL_OW 247
127436: PUSH
127437: LD_INT 2
127439: DOUBLE
127440: EQUAL
127441: IFTRUE 127445
127443: GO 127841
127445: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
127446: LD_VAR 0 5
127450: PPUSH
127451: CALL_OW 256
127455: PUSH
127456: LD_INT 1000
127458: EQUAL
127459: PUSH
127460: LD_VAR 0 5
127464: PPUSH
127465: LD_VAR 0 14
127469: PPUSH
127470: CALL_OW 296
127474: PUSH
127475: LD_INT 40
127477: LESS
127478: PUSH
127479: LD_VAR 0 14
127483: PPUSH
127484: LD_EXP 141
127488: PUSH
127489: LD_VAR 0 1
127493: ARRAY
127494: PPUSH
127495: CALL_OW 308
127499: OR
127500: AND
127501: IFFALSE 127623
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
127503: LD_VAR 0 5
127507: PPUSH
127508: CALL_OW 262
127512: PUSH
127513: LD_INT 1
127515: EQUAL
127516: PUSH
127517: LD_VAR 0 5
127521: PPUSH
127522: CALL_OW 261
127526: PUSH
127527: LD_INT 30
127529: LESS
127530: AND
127531: PUSH
127532: LD_VAR 0 8
127536: AND
127537: IFFALSE 127607
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
127539: LD_VAR 0 5
127543: PPUSH
127544: LD_VAR 0 8
127548: PPUSH
127549: LD_VAR 0 5
127553: PPUSH
127554: CALL_OW 74
127558: PPUSH
127559: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
127563: LD_VAR 0 5
127567: PPUSH
127568: LD_VAR 0 8
127572: PPUSH
127573: LD_VAR 0 5
127577: PPUSH
127578: CALL_OW 74
127582: PPUSH
127583: CALL_OW 296
127587: PUSH
127588: LD_INT 6
127590: LESS
127591: IFFALSE 127605
// SetFuel ( i , 100 ) ;
127593: LD_VAR 0 5
127597: PPUSH
127598: LD_INT 100
127600: PPUSH
127601: CALL_OW 240
// end else
127605: GO 127621
// ComAttackUnit ( i , e ) ;
127607: LD_VAR 0 5
127611: PPUSH
127612: LD_VAR 0 14
127616: PPUSH
127617: CALL_OW 115
// end else
127621: GO 127724
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
127623: LD_VAR 0 14
127627: PPUSH
127628: LD_EXP 141
127632: PUSH
127633: LD_VAR 0 1
127637: ARRAY
127638: PPUSH
127639: CALL_OW 308
127643: NOT
127644: PUSH
127645: LD_VAR 0 5
127649: PPUSH
127650: LD_VAR 0 14
127654: PPUSH
127655: CALL_OW 296
127659: PUSH
127660: LD_INT 40
127662: GREATEREQUAL
127663: AND
127664: PUSH
127665: LD_VAR 0 5
127669: PPUSH
127670: CALL_OW 256
127674: PUSH
127675: LD_INT 650
127677: LESSEQUAL
127678: OR
127679: PUSH
127680: LD_VAR 0 5
127684: PPUSH
127685: LD_EXP 140
127689: PUSH
127690: LD_VAR 0 1
127694: ARRAY
127695: PPUSH
127696: CALL_OW 308
127700: NOT
127701: AND
127702: IFFALSE 127724
// ComMoveToArea ( i , mc_parking [ base ] ) ;
127704: LD_VAR 0 5
127708: PPUSH
127709: LD_EXP 140
127713: PUSH
127714: LD_VAR 0 1
127718: ARRAY
127719: PPUSH
127720: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
127724: LD_VAR 0 5
127728: PPUSH
127729: CALL_OW 256
127733: PUSH
127734: LD_INT 1000
127736: LESS
127737: PUSH
127738: LD_VAR 0 5
127742: PPUSH
127743: CALL_OW 263
127747: PUSH
127748: LD_INT 1
127750: EQUAL
127751: AND
127752: PUSH
127753: LD_VAR 0 5
127757: PPUSH
127758: CALL_OW 311
127762: AND
127763: PUSH
127764: LD_VAR 0 5
127768: PPUSH
127769: LD_EXP 140
127773: PUSH
127774: LD_VAR 0 1
127778: ARRAY
127779: PPUSH
127780: CALL_OW 308
127784: AND
127785: IFFALSE 127839
// begin mech := IsDrivenBy ( i ) ;
127787: LD_ADDR_VAR 0 10
127791: PUSH
127792: LD_VAR 0 5
127796: PPUSH
127797: CALL_OW 311
127801: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
127802: LD_VAR 0 10
127806: PPUSH
127807: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
127811: LD_VAR 0 10
127815: PPUSH
127816: LD_VAR 0 5
127820: PPUSH
127821: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
127825: LD_VAR 0 10
127829: PPUSH
127830: LD_VAR 0 5
127834: PPUSH
127835: CALL_OW 180
// end ; end ; unit_human :
127839: GO 128186
127841: LD_INT 1
127843: DOUBLE
127844: EQUAL
127845: IFTRUE 127849
127847: GO 128185
127849: POP
// begin b := IsInUnit ( i ) ;
127850: LD_ADDR_VAR 0 19
127854: PUSH
127855: LD_VAR 0 5
127859: PPUSH
127860: CALL_OW 310
127864: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
127865: LD_ADDR_VAR 0 20
127869: PUSH
127870: LD_VAR 0 19
127874: NOT
127875: PUSH
127876: LD_VAR 0 19
127880: PPUSH
127881: CALL_OW 266
127885: PUSH
127886: LD_INT 32
127888: PUSH
127889: LD_INT 31
127891: PUSH
127892: EMPTY
127893: LIST
127894: LIST
127895: IN
127896: OR
127897: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
127898: LD_VAR 0 19
127902: PPUSH
127903: CALL_OW 266
127907: PUSH
127908: LD_INT 5
127910: EQUAL
127911: PUSH
127912: LD_VAR 0 5
127916: PPUSH
127917: CALL_OW 257
127921: PUSH
127922: LD_INT 1
127924: PUSH
127925: LD_INT 2
127927: PUSH
127928: LD_INT 3
127930: PUSH
127931: LD_INT 4
127933: PUSH
127934: EMPTY
127935: LIST
127936: LIST
127937: LIST
127938: LIST
127939: IN
127940: AND
127941: IFFALSE 127978
// begin class := AllowSpecClass ( i ) ;
127943: LD_ADDR_VAR 0 21
127947: PUSH
127948: LD_VAR 0 5
127952: PPUSH
127953: CALL 67339 0 1
127957: ST_TO_ADDR
// if class then
127958: LD_VAR 0 21
127962: IFFALSE 127978
// ComChangeProfession ( i , class ) ;
127964: LD_VAR 0 5
127968: PPUSH
127969: LD_VAR 0 21
127973: PPUSH
127974: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
127978: LD_VAR 0 17
127982: PUSH
127983: LD_VAR 0 2
127987: PPUSH
127988: LD_INT 21
127990: PUSH
127991: LD_INT 2
127993: PUSH
127994: EMPTY
127995: LIST
127996: LIST
127997: PPUSH
127998: CALL_OW 72
128002: PUSH
128003: LD_INT 1
128005: LESSEQUAL
128006: OR
128007: PUSH
128008: LD_VAR 0 20
128012: AND
128013: PUSH
128014: LD_VAR 0 5
128018: PUSH
128019: LD_VAR 0 18
128023: IN
128024: NOT
128025: AND
128026: IFFALSE 128119
// begin if b then
128028: LD_VAR 0 19
128032: IFFALSE 128081
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
128034: LD_VAR 0 19
128038: PPUSH
128039: LD_VAR 0 3
128043: PPUSH
128044: LD_VAR 0 19
128048: PPUSH
128049: CALL_OW 74
128053: PPUSH
128054: CALL_OW 296
128058: PUSH
128059: LD_INT 10
128061: LESS
128062: PUSH
128063: LD_VAR 0 19
128067: PPUSH
128068: CALL_OW 461
128072: PUSH
128073: LD_INT 7
128075: NONEQUAL
128076: AND
128077: IFFALSE 128081
// continue ;
128079: GO 127316
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
128081: LD_ADDR_VAR 0 18
128085: PUSH
128086: LD_VAR 0 18
128090: PPUSH
128091: LD_VAR 0 18
128095: PUSH
128096: LD_INT 1
128098: PLUS
128099: PPUSH
128100: LD_VAR 0 5
128104: PPUSH
128105: CALL_OW 1
128109: ST_TO_ADDR
// ComExitBuilding ( i ) ;
128110: LD_VAR 0 5
128114: PPUSH
128115: CALL_OW 122
// end ; if sold_defenders then
128119: LD_VAR 0 18
128123: IFFALSE 128183
// if i in sold_defenders then
128125: LD_VAR 0 5
128129: PUSH
128130: LD_VAR 0 18
128134: IN
128135: IFFALSE 128183
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
128137: LD_VAR 0 5
128141: PPUSH
128142: CALL_OW 314
128146: NOT
128147: PUSH
128148: LD_VAR 0 5
128152: PPUSH
128153: LD_VAR 0 14
128157: PPUSH
128158: CALL_OW 296
128162: PUSH
128163: LD_INT 30
128165: LESS
128166: AND
128167: IFFALSE 128183
// ComAttackUnit ( i , e ) ;
128169: LD_VAR 0 5
128173: PPUSH
128174: LD_VAR 0 14
128178: PPUSH
128179: CALL_OW 115
// end ; end ; end ;
128183: GO 128186
128185: POP
// if IsDead ( i ) then
128186: LD_VAR 0 5
128190: PPUSH
128191: CALL_OW 301
128195: IFFALSE 128213
// defenders := defenders diff i ;
128197: LD_ADDR_VAR 0 2
128201: PUSH
128202: LD_VAR 0 2
128206: PUSH
128207: LD_VAR 0 5
128211: DIFF
128212: ST_TO_ADDR
// end ;
128213: GO 127316
128215: POP
128216: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
128217: LD_VAR 0 3
128221: NOT
128222: PUSH
128223: LD_VAR 0 2
128227: NOT
128228: OR
128229: PUSH
128230: LD_EXP 116
128234: PUSH
128235: LD_VAR 0 1
128239: ARRAY
128240: NOT
128241: OR
128242: IFFALSE 127220
// MC_Reset ( base , 18 ) ;
128244: LD_VAR 0 1
128248: PPUSH
128249: LD_INT 18
128251: PPUSH
128252: CALL 39297 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
128256: LD_ADDR_VAR 0 2
128260: PUSH
128261: LD_VAR 0 2
128265: PUSH
128266: LD_VAR 0 2
128270: PPUSH
128271: LD_INT 2
128273: PUSH
128274: LD_INT 25
128276: PUSH
128277: LD_INT 1
128279: PUSH
128280: EMPTY
128281: LIST
128282: LIST
128283: PUSH
128284: LD_INT 25
128286: PUSH
128287: LD_INT 5
128289: PUSH
128290: EMPTY
128291: LIST
128292: LIST
128293: PUSH
128294: LD_INT 25
128296: PUSH
128297: LD_INT 8
128299: PUSH
128300: EMPTY
128301: LIST
128302: LIST
128303: PUSH
128304: LD_INT 25
128306: PUSH
128307: LD_INT 9
128309: PUSH
128310: EMPTY
128311: LIST
128312: LIST
128313: PUSH
128314: EMPTY
128315: LIST
128316: LIST
128317: LIST
128318: LIST
128319: LIST
128320: PPUSH
128321: CALL_OW 72
128325: DIFF
128326: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
128327: LD_VAR 0 3
128331: NOT
128332: PUSH
128333: LD_VAR 0 2
128337: PPUSH
128338: LD_INT 21
128340: PUSH
128341: LD_INT 2
128343: PUSH
128344: EMPTY
128345: LIST
128346: LIST
128347: PPUSH
128348: CALL_OW 72
128352: AND
128353: IFFALSE 128691
// begin tmp := FilterByTag ( defenders , 19 ) ;
128355: LD_ADDR_VAR 0 12
128359: PUSH
128360: LD_VAR 0 2
128364: PPUSH
128365: LD_INT 19
128367: PPUSH
128368: CALL 99809 0 2
128372: ST_TO_ADDR
// if tmp then
128373: LD_VAR 0 12
128377: IFFALSE 128447
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
128379: LD_ADDR_VAR 0 12
128383: PUSH
128384: LD_VAR 0 12
128388: PPUSH
128389: LD_INT 25
128391: PUSH
128392: LD_INT 3
128394: PUSH
128395: EMPTY
128396: LIST
128397: LIST
128398: PPUSH
128399: CALL_OW 72
128403: ST_TO_ADDR
// if tmp then
128404: LD_VAR 0 12
128408: IFFALSE 128447
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
128410: LD_ADDR_EXP 128
128414: PUSH
128415: LD_EXP 128
128419: PPUSH
128420: LD_VAR 0 1
128424: PPUSH
128425: LD_EXP 128
128429: PUSH
128430: LD_VAR 0 1
128434: ARRAY
128435: PUSH
128436: LD_VAR 0 12
128440: UNION
128441: PPUSH
128442: CALL_OW 1
128446: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
128447: LD_VAR 0 1
128451: PPUSH
128452: LD_INT 19
128454: PPUSH
128455: CALL 39297 0 2
// repeat wait ( 0 0$1 ) ;
128459: LD_INT 35
128461: PPUSH
128462: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
128466: LD_EXP 116
128470: PUSH
128471: LD_VAR 0 1
128475: ARRAY
128476: NOT
128477: PUSH
128478: LD_EXP 116
128482: PUSH
128483: LD_VAR 0 1
128487: ARRAY
128488: PUSH
128489: EMPTY
128490: EQUAL
128491: OR
128492: IFFALSE 128529
// begin for i in defenders do
128494: LD_ADDR_VAR 0 5
128498: PUSH
128499: LD_VAR 0 2
128503: PUSH
128504: FOR_IN
128505: IFFALSE 128518
// ComStop ( i ) ;
128507: LD_VAR 0 5
128511: PPUSH
128512: CALL_OW 141
128516: GO 128504
128518: POP
128519: POP
// defenders := [ ] ;
128520: LD_ADDR_VAR 0 2
128524: PUSH
128525: EMPTY
128526: ST_TO_ADDR
// exit ;
128527: GO 128755
// end ; for i in defenders do
128529: LD_ADDR_VAR 0 5
128533: PUSH
128534: LD_VAR 0 2
128538: PUSH
128539: FOR_IN
128540: IFFALSE 128629
// begin if not IsInArea ( i , mc_parking [ base ] ) then
128542: LD_VAR 0 5
128546: PPUSH
128547: LD_EXP 140
128551: PUSH
128552: LD_VAR 0 1
128556: ARRAY
128557: PPUSH
128558: CALL_OW 308
128562: NOT
128563: IFFALSE 128587
// ComMoveToArea ( i , mc_parking [ base ] ) else
128565: LD_VAR 0 5
128569: PPUSH
128570: LD_EXP 140
128574: PUSH
128575: LD_VAR 0 1
128579: ARRAY
128580: PPUSH
128581: CALL_OW 113
128585: GO 128627
// if GetControl ( i ) = control_manual then
128587: LD_VAR 0 5
128591: PPUSH
128592: CALL_OW 263
128596: PUSH
128597: LD_INT 1
128599: EQUAL
128600: IFFALSE 128627
// if IsDrivenBy ( i ) then
128602: LD_VAR 0 5
128606: PPUSH
128607: CALL_OW 311
128611: IFFALSE 128627
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
128613: LD_VAR 0 5
128617: PPUSH
128618: CALL_OW 311
128622: PPUSH
128623: CALL_OW 121
// end ;
128627: GO 128539
128629: POP
128630: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
128631: LD_VAR 0 2
128635: PPUSH
128636: LD_INT 95
128638: PUSH
128639: LD_EXP 140
128643: PUSH
128644: LD_VAR 0 1
128648: ARRAY
128649: PUSH
128650: EMPTY
128651: LIST
128652: LIST
128653: PPUSH
128654: CALL_OW 72
128658: PUSH
128659: LD_VAR 0 2
128663: EQUAL
128664: PUSH
128665: LD_EXP 139
128669: PUSH
128670: LD_VAR 0 1
128674: ARRAY
128675: OR
128676: PUSH
128677: LD_EXP 116
128681: PUSH
128682: LD_VAR 0 1
128686: ARRAY
128687: NOT
128688: OR
128689: IFFALSE 128459
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
128691: LD_ADDR_EXP 138
128695: PUSH
128696: LD_EXP 138
128700: PPUSH
128701: LD_VAR 0 1
128705: PPUSH
128706: LD_VAR 0 2
128710: PPUSH
128711: LD_INT 21
128713: PUSH
128714: LD_INT 2
128716: PUSH
128717: EMPTY
128718: LIST
128719: LIST
128720: PPUSH
128721: CALL_OW 72
128725: PPUSH
128726: CALL_OW 1
128730: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
128731: LD_VAR 0 1
128735: PPUSH
128736: LD_INT 19
128738: PPUSH
128739: CALL 39297 0 2
// MC_Reset ( base , 20 ) ;
128743: LD_VAR 0 1
128747: PPUSH
128748: LD_INT 20
128750: PPUSH
128751: CALL 39297 0 2
// end ; end_of_file
128755: LD_VAR 0 4
128759: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
128760: LD_VAR 0 1
128764: PUSH
128765: LD_INT 200
128767: DOUBLE
128768: GREATEREQUAL
128769: IFFALSE 128777
128771: LD_INT 299
128773: DOUBLE
128774: LESSEQUAL
128775: IFTRUE 128779
128777: GO 128811
128779: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
128780: LD_VAR 0 1
128784: PPUSH
128785: LD_VAR 0 2
128789: PPUSH
128790: LD_VAR 0 3
128794: PPUSH
128795: LD_VAR 0 4
128799: PPUSH
128800: LD_VAR 0 5
128804: PPUSH
128805: CALL 117612 0 5
128809: GO 128888
128811: LD_INT 300
128813: DOUBLE
128814: GREATEREQUAL
128815: IFFALSE 128823
128817: LD_INT 399
128819: DOUBLE
128820: LESSEQUAL
128821: IFTRUE 128825
128823: GO 128887
128825: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
128826: LD_VAR 0 1
128830: PPUSH
128831: LD_VAR 0 2
128835: PPUSH
128836: LD_VAR 0 3
128840: PPUSH
128841: LD_VAR 0 4
128845: PPUSH
128846: LD_VAR 0 5
128850: PPUSH
128851: LD_VAR 0 6
128855: PPUSH
128856: LD_VAR 0 7
128860: PPUSH
128861: LD_VAR 0 8
128865: PPUSH
128866: LD_VAR 0 9
128870: PPUSH
128871: LD_VAR 0 10
128875: PPUSH
128876: LD_VAR 0 11
128880: PPUSH
128881: CALL 115500 0 11
128885: GO 128888
128887: POP
// end ;
128888: PPOPN 11
128890: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
128891: LD_VAR 0 1
128895: PPUSH
128896: LD_VAR 0 2
128900: PPUSH
128901: LD_VAR 0 3
128905: PPUSH
128906: LD_VAR 0 4
128910: PPUSH
128911: LD_VAR 0 5
128915: PPUSH
128916: CALL 117594 0 5
// end ; end_of_file
128920: PPOPN 5
128922: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
128923: LD_VAR 0 1
128927: PPUSH
128928: LD_VAR 0 2
128932: PPUSH
128933: LD_VAR 0 3
128937: PPUSH
128938: LD_VAR 0 4
128942: PPUSH
128943: LD_VAR 0 5
128947: PPUSH
128948: LD_VAR 0 6
128952: PPUSH
128953: CALL 104308 0 6
// end ;
128957: PPOPN 6
128959: END
