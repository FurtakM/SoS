// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 35042 0 0
// InitNature ;
  19: CALL 34802 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11072 0 0
// PrepareRussian ;
  40: CALL 6956 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14966 0 0
// MC_Start ( ) ;
  60: CALL 37154 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 134
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 135
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59415 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59508 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58858 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58673 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59415 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59508 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58673 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58858 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59288 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58355 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59415 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59508 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 139
 955: PUSH
 956: LD_EXP 139
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58673 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59415 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59508 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58565 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59826 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 58997 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59288 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59288 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59620 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58673 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59239 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 65065 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 69889 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 69889 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 69889 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 69889 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 69889 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 65065 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 65065 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 65065 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 65065 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 65065 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 65065 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 65065 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 65065 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 65065 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 65065 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 65065 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 65065 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 65065 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 65065 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 65065 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 65065 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 65065 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 65065 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 65065 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 65065 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 65065 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 65065 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 65065 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 65065 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 65065 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 65065 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 65065 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 65065 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 16 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 16
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 16 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 16
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 69889 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 65065 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 65065 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 65065 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4448: LD_EXP 61
4452: PPUSH
4453: LD_INT 4
4455: PPUSH
4456: LD_INT 10
4458: PPUSH
4459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4463: LD_ADDR_VAR 0 5
4467: PUSH
4468: LD_INT 22
4470: PUSH
4471: LD_VAR 0 3
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: PUSH
4480: LD_INT 30
4482: PUSH
4483: LD_INT 32
4485: PUSH
4486: EMPTY
4487: LIST
4488: LIST
4489: PUSH
4490: LD_INT 58
4492: PUSH
4493: EMPTY
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: PPUSH
4501: CALL_OW 69
4505: ST_TO_ADDR
// for i = 1 to 10 do
4506: LD_ADDR_VAR 0 2
4510: PUSH
4511: DOUBLE
4512: LD_INT 1
4514: DEC
4515: ST_TO_ADDR
4516: LD_INT 10
4518: PUSH
4519: FOR_TO
4520: IFFALSE 4592
// begin uc_nation := nation_nature ;
4522: LD_ADDR_OWVAR 21
4526: PUSH
4527: LD_INT 0
4529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4530: LD_ADDR_OWVAR 28
4534: PUSH
4535: LD_INT 15
4537: ST_TO_ADDR
// hc_gallery :=  ;
4538: LD_ADDR_OWVAR 33
4542: PUSH
4543: LD_STRING 
4545: ST_TO_ADDR
// hc_name :=  ;
4546: LD_ADDR_OWVAR 26
4550: PUSH
4551: LD_STRING 
4553: ST_TO_ADDR
// un := CreateHuman ;
4554: LD_ADDR_VAR 0 4
4558: PUSH
4559: CALL_OW 44
4563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4564: LD_VAR 0 4
4568: PPUSH
4569: LD_VAR 0 5
4573: PUSH
4574: LD_VAR 0 5
4578: PUSH
4579: LD_VAR 0 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 52
// end ;
4590: GO 4519
4592: POP
4593: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4594: LD_ADDR_VAR 0 5
4598: PUSH
4599: LD_STRING 12_kurt_squad
4601: PPUSH
4602: CALL_OW 31
4606: ST_TO_ADDR
// if tmp then
4607: LD_VAR 0 5
4611: IFFALSE 4645
// for i in tmp do
4613: LD_ADDR_VAR 0 2
4617: PUSH
4618: LD_VAR 0 5
4622: PUSH
4623: FOR_IN
4624: IFFALSE 4643
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4626: LD_VAR 0 2
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 0
4636: PPUSH
4637: CALL_OW 49
4641: GO 4623
4643: POP
4644: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4645: LD_INT 324
4647: PPUSH
4648: LD_INT 5
4650: PPUSH
4651: LD_STRING 
4653: PPUSH
4654: LD_INT 8
4656: PUSH
4657: LD_INT 9
4659: PUSH
4660: LD_INT 10
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: LIST
4667: PUSH
4668: LD_OWVAR 67
4672: ARRAY
4673: PPUSH
4674: LD_INT 3000
4676: PUSH
4677: LD_INT 500
4679: PUSH
4680: LD_INT 150
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: LIST
4687: PPUSH
4688: LD_INT 16
4690: PUSH
4691: LD_INT 6
4693: PUSH
4694: LD_INT 6
4696: PUSH
4697: LD_INT 8
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: PPUSH
4706: CALL 73298 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4710: LD_ADDR_EXP 110
4714: PUSH
4715: LD_EXP 110
4719: PPUSH
4720: LD_INT 3
4722: PPUSH
4723: LD_INT 22
4725: PUSH
4726: LD_VAR 0 3
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 23
4737: PUSH
4738: LD_INT 2
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: LD_INT 3
4747: PUSH
4748: LD_INT 21
4750: PUSH
4751: LD_INT 2
4753: PUSH
4754: EMPTY
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: LIST
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: LIST
4766: PPUSH
4767: CALL_OW 69
4771: PUSH
4772: LD_EXP 60
4776: DIFF
4777: PPUSH
4778: CALL_OW 1
4782: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 7
4788: PPUSH
4789: CALL_OW 383
// Friend := CreateHuman ;
4793: LD_ADDR_EXP 62
4797: PUSH
4798: CALL_OW 44
4802: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4803: LD_INT 14
4805: PPUSH
4806: LD_INT 3
4808: PPUSH
4809: LD_INT 1
4811: PPUSH
4812: LD_INT 29
4814: PPUSH
4815: LD_INT 100
4817: PPUSH
4818: CALL 69889 0 5
// powellBomb := CreateVehicle ;
4822: LD_ADDR_EXP 63
4826: PUSH
4827: CALL_OW 45
4831: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4832: LD_EXP 63
4836: PPUSH
4837: LD_INT 90
4839: PPUSH
4840: LD_INT 51
4842: PPUSH
4843: LD_INT 0
4845: PPUSH
4846: CALL_OW 48
// end ;
4850: LD_VAR 0 1
4854: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4855: LD_INT 0
4857: PPUSH
4858: PPUSH
4859: PPUSH
// if IsLive ( kozlov_fac ) then
4860: LD_INT 332
4862: PPUSH
4863: CALL_OW 300
4867: IFFALSE 4871
// exit ;
4869: GO 5438
// ComExitBuilding ( Kozlov ) ;
4871: LD_EXP 61
4875: PPUSH
4876: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4880: LD_EXP 61
4884: PPUSH
4885: CALL_OW 257
4889: PUSH
4890: LD_INT 2
4892: NONEQUAL
4893: IFFALSE 4928
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4895: LD_EXP 61
4899: PPUSH
4900: LD_INT 324
4902: PPUSH
4903: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4907: LD_EXP 61
4911: PPUSH
4912: LD_INT 2
4914: PPUSH
4915: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4919: LD_EXP 61
4923: PPUSH
4924: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4928: LD_EXP 61
4932: PPUSH
4933: LD_INT 2
4935: PPUSH
4936: LD_INT 93
4938: PPUSH
4939: LD_INT 32
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4949: LD_INT 35
4951: PPUSH
4952: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4956: LD_INT 22
4958: PUSH
4959: LD_INT 8
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 30
4968: PUSH
4969: LD_INT 3
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PUSH
4976: LD_INT 23
4978: PUSH
4979: LD_INT 3
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PUSH
4986: LD_INT 57
4988: PUSH
4989: EMPTY
4990: LIST
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: IFFALSE 4949
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5004: LD_ADDR_VAR 0 2
5008: PUSH
5009: LD_INT 22
5011: PUSH
5012: LD_INT 8
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 30
5021: PUSH
5022: LD_INT 3
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: LD_INT 23
5031: PUSH
5032: LD_INT 3
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 57
5041: PUSH
5042: EMPTY
5043: LIST
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: LIST
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 1
5058: ARRAY
5059: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5060: LD_INT 22
5062: PUSH
5063: LD_INT 8
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: PUSH
5070: LD_INT 23
5072: PUSH
5073: LD_INT 3
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 30
5082: PUSH
5083: LD_INT 21
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PPUSH
5095: CALL_OW 69
5099: NOT
5100: IFFALSE 5178
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5102: LD_EXP 61
5106: PPUSH
5107: LD_INT 21
5109: PPUSH
5110: LD_INT 97
5112: PPUSH
5113: LD_INT 36
5115: PPUSH
5116: LD_INT 5
5118: PPUSH
5119: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5123: LD_INT 35
5125: PPUSH
5126: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5130: LD_INT 22
5132: PUSH
5133: LD_INT 8
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: LD_INT 23
5142: PUSH
5143: LD_INT 3
5145: PUSH
5146: EMPTY
5147: LIST
5148: LIST
5149: PUSH
5150: LD_INT 30
5152: PUSH
5153: LD_INT 21
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 57
5162: PUSH
5163: EMPTY
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: PPUSH
5172: CALL_OW 69
5176: IFFALSE 5123
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5178: LD_INT 22
5180: PUSH
5181: LD_INT 8
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: PUSH
5188: LD_INT 23
5190: PUSH
5191: LD_INT 3
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: PUSH
5198: LD_INT 30
5200: PUSH
5201: LD_INT 18
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 69
5217: NOT
5218: IFFALSE 5296
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5220: LD_EXP 61
5224: PPUSH
5225: LD_INT 18
5227: PPUSH
5228: LD_INT 89
5230: PPUSH
5231: LD_INT 32
5233: PPUSH
5234: LD_INT 1
5236: PPUSH
5237: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5241: LD_INT 35
5243: PPUSH
5244: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5248: LD_INT 22
5250: PUSH
5251: LD_INT 8
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: PUSH
5258: LD_INT 23
5260: PUSH
5261: LD_INT 3
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 30
5270: PUSH
5271: LD_INT 18
5273: PUSH
5274: EMPTY
5275: LIST
5276: LIST
5277: PUSH
5278: LD_INT 57
5280: PUSH
5281: EMPTY
5282: LIST
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 69
5294: IFFALSE 5241
// end ; lab := kozlov_lab ;
5296: LD_ADDR_VAR 0 3
5300: PUSH
5301: LD_INT 336
5303: ST_TO_ADDR
// if not lab then
5304: LD_VAR 0 3
5308: NOT
5309: IFFALSE 5313
// exit ;
5311: GO 5438
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5313: LD_EXP 61
5317: PPUSH
5318: LD_VAR 0 3
5322: PUSH
5323: LD_INT 1
5325: ARRAY
5326: PPUSH
5327: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5331: LD_EXP 61
5335: PPUSH
5336: LD_INT 4
5338: PPUSH
5339: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: LD_INT 25
5354: PPUSH
5355: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5359: LD_INT 35
5361: PPUSH
5362: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5366: LD_INT 25
5368: PPUSH
5369: LD_INT 8
5371: PPUSH
5372: CALL_OW 321
5376: PUSH
5377: LD_INT 2
5379: EQUAL
5380: IFFALSE 5359
// ComExitBuilding ( Kozlov ) ;
5382: LD_EXP 61
5386: PPUSH
5387: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5391: LD_EXP 61
5395: PPUSH
5396: LD_VAR 0 2
5400: PPUSH
5401: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5405: LD_EXP 61
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5417: LD_VAR 0 2
5421: PPUSH
5422: LD_INT 23
5424: PPUSH
5425: LD_INT 3
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: LD_INT 48
5433: PPUSH
5434: CALL_OW 125
// end ;
5438: LD_VAR 0 1
5442: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5443: LD_EXP 22
5447: NOT
5448: PUSH
5449: LD_EXP 15
5453: PUSH
5454: LD_INT 6
5456: GREATEREQUAL
5457: AND
5458: IFFALSE 5539
5460: GO 5462
5462: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5463: LD_INT 3
5465: PPUSH
5466: LD_INT 3
5468: PPUSH
5469: CALL 58858 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5473: LD_INT 3
5475: PPUSH
5476: LD_INT 14
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 28
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 14
5496: PUSH
5497: LD_INT 1
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 28
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: PUSH
5512: LD_INT 14
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: LD_INT 1
5520: PUSH
5521: LD_INT 28
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: PPUSH
5535: CALL 58721 0 2
// end ;
5539: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5540: LD_EXP 22
5544: NOT
5545: PUSH
5546: LD_EXP 15
5550: PUSH
5551: LD_INT 6
5553: GREATEREQUAL
5554: AND
5555: PUSH
5556: LD_INT 3
5558: PPUSH
5559: LD_INT 1
5561: PPUSH
5562: CALL 60139 0 2
5566: NOT
5567: AND
5568: IFFALSE 6408
5570: GO 5572
5572: DISABLE
5573: LD_INT 0
5575: PPUSH
5576: PPUSH
5577: PPUSH
// begin enable ;
5578: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5579: LD_INT 22
5581: PUSH
5582: LD_INT 8
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 23
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: PUSH
5599: LD_INT 30
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 69
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 6408
// if Prob ( 40 ) then
5623: LD_INT 40
5625: PPUSH
5626: CALL_OW 13
5630: IFFALSE 5757
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5632: LD_INT 3
5634: PPUSH
5635: LD_INT 14
5637: PUSH
5638: LD_INT 1
5640: PUSH
5641: LD_INT 2
5643: PUSH
5644: LD_INT 28
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: LD_INT 14
5655: PUSH
5656: LD_INT 1
5658: PUSH
5659: LD_INT 2
5661: PUSH
5662: LD_INT 28
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 14
5673: PUSH
5674: LD_INT 1
5676: PUSH
5677: LD_INT 2
5679: PUSH
5680: LD_INT 28
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 14
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: LD_INT 2
5697: PUSH
5698: LD_INT 28
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: LD_INT 14
5709: PUSH
5710: LD_INT 1
5712: PUSH
5713: LD_INT 2
5715: PUSH
5716: LD_INT 28
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 14
5727: PUSH
5728: LD_INT 1
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: LD_INT 26
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PPUSH
5751: CALL 58721 0 2
// end else
5755: GO 5948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5757: LD_INT 3
5759: PPUSH
5760: LD_INT 14
5762: PUSH
5763: LD_INT 1
5765: PUSH
5766: LD_INT 2
5768: PUSH
5769: LD_INT 27
5771: PUSH
5772: LD_INT 26
5774: PUSH
5775: LD_INT 26
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_OWVAR 67
5787: ARRAY
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: LIST
5793: LIST
5794: PUSH
5795: LD_INT 14
5797: PUSH
5798: LD_INT 1
5800: PUSH
5801: LD_INT 2
5803: PUSH
5804: LD_INT 27
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: LD_INT 26
5812: PUSH
5813: EMPTY
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_OWVAR 67
5822: ARRAY
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: LIST
5829: PUSH
5830: LD_INT 14
5832: PUSH
5833: LD_INT 1
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: LD_INT 26
5841: PUSH
5842: LD_INT 26
5844: PUSH
5845: LD_INT 29
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: PUSH
5853: LD_OWVAR 67
5857: ARRAY
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: PUSH
5865: LD_INT 13
5867: PUSH
5868: LD_INT 1
5870: PUSH
5871: LD_INT 2
5873: PUSH
5874: LD_INT 26
5876: PUSH
5877: LD_INT 29
5879: PUSH
5880: LD_INT 29
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_OWVAR 67
5892: ARRAY
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 13
5902: PUSH
5903: LD_INT 1
5905: PUSH
5906: LD_INT 2
5908: PUSH
5909: LD_INT 29
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: PUSH
5918: LD_INT 14
5920: PUSH
5921: LD_INT 1
5923: PUSH
5924: LD_INT 2
5926: PUSH
5927: LD_INT 26
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: PPUSH
5944: CALL 58721 0 2
// end ; repeat wait ( 0 0$1 ) ;
5948: LD_INT 35
5950: PPUSH
5951: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5955: LD_INT 3
5957: PPUSH
5958: LD_INT 1
5960: PPUSH
5961: CALL 60139 0 2
5965: PUSH
5966: LD_INT 6
5968: GREATEREQUAL
5969: IFFALSE 5948
// wait ( 0 0$30 ) ;
5971: LD_INT 1050
5973: PPUSH
5974: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5978: LD_ADDR_VAR 0 2
5982: PUSH
5983: LD_INT 3
5985: PPUSH
5986: LD_INT 1
5988: PPUSH
5989: CALL 60139 0 2
5993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5994: LD_ADDR_EXP 129
5998: PUSH
5999: LD_EXP 129
6003: PPUSH
6004: LD_INT 3
6006: PPUSH
6007: LD_EXP 129
6011: PUSH
6012: LD_INT 3
6014: ARRAY
6015: PUSH
6016: LD_VAR 0 2
6020: DIFF
6021: PPUSH
6022: CALL_OW 1
6026: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6027: LD_ADDR_VAR 0 3
6031: PUSH
6032: LD_INT 0
6034: PPUSH
6035: LD_INT 2
6037: PPUSH
6038: CALL_OW 12
6042: ST_TO_ADDR
// if target then
6043: LD_VAR 0 3
6047: IFFALSE 6175
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6049: LD_ADDR_VAR 0 2
6053: PUSH
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 24
6061: PUSH
6062: LD_INT 250
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL_OW 72
6073: ST_TO_ADDR
// for i in tmp do
6074: LD_ADDR_VAR 0 1
6078: PUSH
6079: LD_VAR 0 2
6083: PUSH
6084: FOR_IN
6085: IFFALSE 6125
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6087: LD_VAR 0 1
6091: PPUSH
6092: LD_INT 89
6094: PPUSH
6095: LD_INT 71
6097: PPUSH
6098: CALL_OW 297
6102: PUSH
6103: LD_INT 9
6105: GREATER
6106: IFFALSE 6123
// ComMoveXY ( i , 89 , 71 ) ;
6108: LD_VAR 0 1
6112: PPUSH
6113: LD_INT 89
6115: PPUSH
6116: LD_INT 71
6118: PPUSH
6119: CALL_OW 111
6123: GO 6084
6125: POP
6126: POP
// wait ( 0 0$1 ) ;
6127: LD_INT 35
6129: PPUSH
6130: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6134: LD_VAR 0 2
6138: PPUSH
6139: LD_INT 92
6141: PUSH
6142: LD_INT 89
6144: PUSH
6145: LD_INT 71
6147: PUSH
6148: LD_INT 9
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: PPUSH
6157: CALL_OW 72
6161: PUSH
6162: LD_VAR 0 2
6166: PUSH
6167: LD_INT 1
6169: MINUS
6170: GREATEREQUAL
6171: IFFALSE 6049
// end else
6173: GO 6299
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_VAR 0 2
6184: PPUSH
6185: LD_INT 24
6187: PUSH
6188: LD_INT 250
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 72
6199: ST_TO_ADDR
// for i in tmp do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: LD_VAR 0 2
6209: PUSH
6210: FOR_IN
6211: IFFALSE 6251
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6213: LD_VAR 0 1
6217: PPUSH
6218: LD_INT 125
6220: PPUSH
6221: LD_INT 129
6223: PPUSH
6224: CALL_OW 297
6228: PUSH
6229: LD_INT 9
6231: GREATER
6232: IFFALSE 6249
// ComMoveXY ( i , 125 , 129 ) ;
6234: LD_VAR 0 1
6238: PPUSH
6239: LD_INT 125
6241: PPUSH
6242: LD_INT 129
6244: PPUSH
6245: CALL_OW 111
6249: GO 6210
6251: POP
6252: POP
// wait ( 0 0$1 ) ;
6253: LD_INT 35
6255: PPUSH
6256: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6260: LD_VAR 0 2
6264: PPUSH
6265: LD_INT 92
6267: PUSH
6268: LD_INT 125
6270: PUSH
6271: LD_INT 129
6273: PUSH
6274: LD_INT 9
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: PPUSH
6283: CALL_OW 72
6287: PUSH
6288: LD_VAR 0 2
6292: PUSH
6293: LD_INT 1
6295: MINUS
6296: GREATEREQUAL
6297: IFFALSE 6175
// end ; repeat wait ( 0 0$1 ) ;
6299: LD_INT 35
6301: PPUSH
6302: CALL_OW 67
// for i in tmp do
6306: LD_ADDR_VAR 0 1
6310: PUSH
6311: LD_VAR 0 2
6315: PUSH
6316: FOR_IN
6317: IFFALSE 6399
// begin if GetLives ( i ) > 251 then
6319: LD_VAR 0 1
6323: PPUSH
6324: CALL_OW 256
6328: PUSH
6329: LD_INT 251
6331: GREATER
6332: IFFALSE 6370
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6334: LD_VAR 0 1
6338: PPUSH
6339: LD_INT 81
6341: PUSH
6342: LD_INT 8
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: PPUSH
6354: LD_VAR 0 1
6358: PPUSH
6359: CALL_OW 74
6363: PPUSH
6364: CALL_OW 115
6368: GO 6397
// if IsDead ( i ) then
6370: LD_VAR 0 1
6374: PPUSH
6375: CALL_OW 301
6379: IFFALSE 6397
// tmp := tmp diff i ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PUSH
6391: LD_VAR 0 1
6395: DIFF
6396: ST_TO_ADDR
// end ;
6397: GO 6316
6399: POP
6400: POP
// until not tmp ;
6401: LD_VAR 0 2
6405: NOT
6406: IFFALSE 6299
// end ;
6408: PPOPN 3
6410: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6411: LD_EXP 22
6415: NOT
6416: PUSH
6417: LD_EXP 15
6421: PUSH
6422: LD_INT 6
6424: GREATEREQUAL
6425: AND
6426: PUSH
6427: LD_OWVAR 67
6431: PUSH
6432: LD_INT 1
6434: GREATER
6435: AND
6436: IFFALSE 6953
6438: GO 6440
6440: DISABLE
6441: LD_INT 0
6443: PPUSH
6444: PPUSH
6445: PPUSH
// begin enable ;
6446: ENABLE
// tmp := [ ] ;
6447: LD_ADDR_VAR 0 3
6451: PUSH
6452: EMPTY
6453: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6454: LD_ADDR_VAR 0 1
6458: PUSH
6459: DOUBLE
6460: LD_INT 1
6462: DEC
6463: ST_TO_ADDR
6464: LD_INT 4
6466: PUSH
6467: LD_INT 6
6469: PUSH
6470: LD_INT 7
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: LD_OWVAR 67
6482: ARRAY
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6645
// begin uc_side := 8 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 8
6494: ST_TO_ADDR
// uc_nation := 2 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 2
6502: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6503: LD_INT 13
6505: PUSH
6506: LD_INT 14
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 1
6515: PPUSH
6516: LD_INT 2
6518: PPUSH
6519: CALL_OW 12
6523: ARRAY
6524: PPUSH
6525: LD_INT 1
6527: PPUSH
6528: LD_INT 5
6530: PPUSH
6531: LD_INT 27
6533: PUSH
6534: LD_INT 28
6536: PUSH
6537: LD_INT 26
6539: PUSH
6540: LD_INT 25
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: PUSH
6549: LD_INT 1
6551: PPUSH
6552: LD_INT 4
6554: PPUSH
6555: CALL_OW 12
6559: ARRAY
6560: PPUSH
6561: LD_INT 88
6563: PPUSH
6564: CALL 69889 0 5
// un := CreateVehicle ;
6568: LD_ADDR_VAR 0 2
6572: PUSH
6573: CALL_OW 45
6577: ST_TO_ADDR
// tmp := tmp ^ un ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: LD_VAR 0 3
6587: PUSH
6588: LD_VAR 0 2
6592: ADD
6593: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 3
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 30
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6621: LD_VAR 0 2
6625: PPUSH
6626: LD_INT 16
6628: PPUSH
6629: LD_INT 11
6631: PPUSH
6632: CALL_OW 111
// wait ( 0 0$2 ) ;
6636: LD_INT 70
6638: PPUSH
6639: CALL_OW 67
// end ;
6643: GO 6484
6645: POP
6646: POP
// for i = 1 to Difficulty do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_OWVAR 67
6661: PUSH
6662: FOR_TO
6663: IFFALSE 6788
// begin uc_side := 8 ;
6665: LD_ADDR_OWVAR 20
6669: PUSH
6670: LD_INT 8
6672: ST_TO_ADDR
// uc_nation := 2 ;
6673: LD_ADDR_OWVAR 21
6677: PUSH
6678: LD_INT 2
6680: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6681: LD_INT 0
6683: PPUSH
6684: LD_INT 8
6686: PPUSH
6687: LD_INT 8
6689: PUSH
6690: LD_INT 8
6692: PUSH
6693: LD_INT 9
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: LIST
6700: PUSH
6701: LD_OWVAR 67
6705: ARRAY
6706: PPUSH
6707: CALL_OW 380
// un := CreateHuman ;
6711: LD_ADDR_VAR 0 2
6715: PUSH
6716: CALL_OW 44
6720: ST_TO_ADDR
// tmp := tmp ^ un ;
6721: LD_ADDR_VAR 0 3
6725: PUSH
6726: LD_VAR 0 3
6730: PUSH
6731: LD_VAR 0 2
6735: ADD
6736: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6737: LD_VAR 0 2
6741: PPUSH
6742: LD_INT 3
6744: PPUSH
6745: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 30
6756: PPUSH
6757: LD_INT 0
6759: PPUSH
6760: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6764: LD_VAR 0 2
6768: PPUSH
6769: LD_INT 16
6771: PPUSH
6772: LD_INT 11
6774: PPUSH
6775: CALL_OW 111
// wait ( 0 0$2 ) ;
6779: LD_INT 70
6781: PPUSH
6782: CALL_OW 67
// end ;
6786: GO 6662
6788: POP
6789: POP
// repeat wait ( 0 0$1 ) ;
6790: LD_INT 35
6792: PPUSH
6793: CALL_OW 67
// for i in tmp do
6797: LD_ADDR_VAR 0 1
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: FOR_IN
6808: IFFALSE 6944
// begin if GetLives ( i ) > 250 then
6810: LD_VAR 0 1
6814: PPUSH
6815: CALL_OW 256
6819: PUSH
6820: LD_INT 250
6822: GREATER
6823: IFFALSE 6915
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6825: LD_INT 81
6827: PUSH
6828: LD_INT 8
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 91
6837: PUSH
6838: LD_VAR 0 1
6842: PUSH
6843: LD_INT 10
6845: PUSH
6846: EMPTY
6847: LIST
6848: LIST
6849: LIST
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: NOT
6860: IFFALSE 6879
// ComAgressiveMove ( i , 67 , 110 ) else
6862: LD_VAR 0 1
6866: PPUSH
6867: LD_INT 67
6869: PPUSH
6870: LD_INT 110
6872: PPUSH
6873: CALL_OW 114
6877: GO 6913
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_INT 81
6886: PUSH
6887: LD_INT 8
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PPUSH
6894: CALL_OW 69
6898: PPUSH
6899: LD_VAR 0 1
6903: PPUSH
6904: CALL_OW 74
6908: PPUSH
6909: CALL_OW 115
// end else
6913: GO 6942
// if IsDead ( i ) then
6915: LD_VAR 0 1
6919: PPUSH
6920: CALL_OW 301
6924: IFFALSE 6942
// tmp := tmp diff i ;
6926: LD_ADDR_VAR 0 3
6930: PUSH
6931: LD_VAR 0 3
6935: PUSH
6936: LD_VAR 0 1
6940: DIFF
6941: ST_TO_ADDR
// end ;
6942: GO 6807
6944: POP
6945: POP
// until not tmp ;
6946: LD_VAR 0 3
6950: NOT
6951: IFFALSE 6790
// end ; end_of_file
6953: PPOPN 3
6955: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
// side := 3 ;
6967: LD_ADDR_VAR 0 6
6971: PUSH
6972: LD_INT 3
6974: ST_TO_ADDR
// uc_side := side ;
6975: LD_ADDR_OWVAR 20
6979: PUSH
6980: LD_VAR 0 6
6984: ST_TO_ADDR
// uc_nation := 3 ;
6985: LD_ADDR_OWVAR 21
6989: PUSH
6990: LD_INT 3
6992: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6993: LD_ADDR_VAR 0 2
6997: PUSH
6998: LD_INT 22
7000: PUSH
7001: LD_VAR 0 6
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: LD_INT 21
7012: PUSH
7013: LD_INT 3
7015: PUSH
7016: EMPTY
7017: LIST
7018: LIST
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: PPUSH
7024: CALL_OW 69
7028: PUSH
7029: FOR_IN
7030: IFFALSE 7046
// SetBLevel ( i , 10 ) ;
7032: LD_VAR 0 2
7036: PPUSH
7037: LD_INT 10
7039: PPUSH
7040: CALL_OW 241
7044: GO 7029
7046: POP
7047: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7048: LD_ADDR_VAR 0 9
7052: PUSH
7053: LD_INT 22
7055: PUSH
7056: LD_VAR 0 6
7060: PUSH
7061: EMPTY
7062: LIST
7063: LIST
7064: PUSH
7065: LD_INT 30
7067: PUSH
7068: LD_INT 34
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PPUSH
7079: CALL_OW 69
7083: ST_TO_ADDR
// if teleport then
7084: LD_VAR 0 9
7088: IFFALSE 7109
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7090: LD_VAR 0 9
7094: PUSH
7095: LD_INT 1
7097: ARRAY
7098: PPUSH
7099: LD_INT 123
7101: PPUSH
7102: LD_INT 122
7104: PPUSH
7105: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7109: LD_ADDR_EXP 64
7113: PUSH
7114: LD_STRING Platonov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7122: LD_ADDR_EXP 65
7126: PUSH
7127: LD_STRING Kovalyuk
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7135: LD_ADDR_EXP 67
7139: PUSH
7140: LD_STRING Yakotich
7142: PPUSH
7143: LD_EXP 1
7147: NOT
7148: PPUSH
7149: LD_STRING 09_
7151: PPUSH
7152: CALL 65065 0 3
7156: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7157: LD_ADDR_EXP 66
7161: PUSH
7162: LD_STRING Bystrov
7164: PPUSH
7165: CALL_OW 25
7169: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7170: LD_ADDR_EXP 68
7174: PUSH
7175: LD_STRING Gleb
7177: PPUSH
7178: CALL_OW 25
7182: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7183: LD_STRING 03_Cornel
7185: PPUSH
7186: CALL_OW 28
7190: IFFALSE 7238
// begin Bierezov := NewCharacter ( Mikhail ) ;
7192: LD_ADDR_EXP 69
7196: PUSH
7197: LD_STRING Mikhail
7199: PPUSH
7200: CALL_OW 25
7204: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7205: LD_EXP 69
7209: PPUSH
7210: LD_INT 197
7212: PPUSH
7213: LD_INT 111
7215: PPUSH
7216: LD_INT 9
7218: PPUSH
7219: LD_INT 0
7221: PPUSH
7222: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7226: LD_EXP 69
7230: PPUSH
7231: LD_INT 3
7233: PPUSH
7234: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7238: LD_EXP 64
7242: PPUSH
7243: LD_INT 126
7245: PPUSH
7246: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7250: LD_EXP 65
7254: PPUSH
7255: LD_INT 134
7257: PPUSH
7258: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7262: LD_EXP 67
7266: PPUSH
7267: LD_INT 197
7269: PPUSH
7270: LD_INT 111
7272: PPUSH
7273: LD_INT 9
7275: PPUSH
7276: LD_INT 0
7278: PPUSH
7279: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7283: LD_EXP 66
7287: PPUSH
7288: LD_INT 197
7290: PPUSH
7291: LD_INT 111
7293: PPUSH
7294: LD_INT 9
7296: PPUSH
7297: LD_INT 0
7299: PPUSH
7300: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7304: LD_EXP 68
7308: PPUSH
7309: LD_INT 197
7311: PPUSH
7312: LD_INT 111
7314: PPUSH
7315: LD_INT 9
7317: PPUSH
7318: LD_INT 0
7320: PPUSH
7321: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: LD_INT 126
7332: PPUSH
7333: LD_INT 4
7335: PPUSH
7336: LD_STRING zhukov
7338: PPUSH
7339: LD_INT 9
7341: PUSH
7342: LD_INT 10
7344: PUSH
7345: LD_INT 10
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: LIST
7352: PUSH
7353: LD_OWVAR 67
7357: ARRAY
7358: PPUSH
7359: LD_INT 90000
7361: PUSH
7362: LD_INT 1000
7364: PUSH
7365: LD_INT 300
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: LIST
7372: PPUSH
7373: LD_INT 18
7375: PUSH
7376: LD_INT 8
7378: PUSH
7379: LD_INT 13
7381: PUSH
7382: LD_INT 8
7384: PUSH
7385: EMPTY
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: PPUSH
7391: CALL 73298 0 6
7395: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7396: LD_ADDR_VAR 0 4
7400: PUSH
7401: LD_INT 267
7403: PPUSH
7404: CALL_OW 274
7408: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 1
7416: PPUSH
7417: LD_INT 5000
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 2
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7439: LD_VAR 0 4
7443: PPUSH
7444: LD_INT 3
7446: PPUSH
7447: LD_INT 200
7449: PPUSH
7450: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7454: LD_ADDR_EXP 110
7458: PUSH
7459: LD_EXP 110
7463: PPUSH
7464: LD_INT 2
7466: PPUSH
7467: LD_VAR 0 5
7471: PUSH
7472: LD_INT 22
7474: PUSH
7475: LD_VAR 0 6
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 21
7489: PUSH
7490: LD_INT 2
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: UNION
7510: PUSH
7511: LD_EXP 64
7515: DIFF
7516: PPUSH
7517: CALL_OW 1
7521: ST_TO_ADDR
// behemoths := [ ] ;
7522: LD_ADDR_EXP 72
7526: PUSH
7527: EMPTY
7528: ST_TO_ADDR
// behemothBuilders := [ ] ;
7529: LD_ADDR_EXP 73
7533: PUSH
7534: EMPTY
7535: ST_TO_ADDR
// if Kovalyuk then
7536: LD_EXP 65
7540: IFFALSE 7562
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7542: LD_ADDR_EXP 73
7546: PUSH
7547: LD_EXP 73
7551: PPUSH
7552: LD_EXP 65
7556: PPUSH
7557: CALL 100935 0 2
7561: ST_TO_ADDR
// j := 3 ;
7562: LD_ADDR_VAR 0 3
7566: PUSH
7567: LD_INT 3
7569: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7570: LD_ADDR_VAR 0 2
7574: PUSH
7575: LD_INT 22
7577: PUSH
7578: LD_INT 3
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 25
7587: PUSH
7588: LD_INT 3
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 69
7603: PUSH
7604: LD_EXP 65
7608: DIFF
7609: PUSH
7610: FOR_IN
7611: IFFALSE 7661
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7613: LD_ADDR_EXP 73
7617: PUSH
7618: LD_EXP 73
7622: PPUSH
7623: LD_VAR 0 2
7627: PPUSH
7628: CALL 100935 0 2
7632: ST_TO_ADDR
// j := j - 1 ;
7633: LD_ADDR_VAR 0 3
7637: PUSH
7638: LD_VAR 0 3
7642: PUSH
7643: LD_INT 1
7645: MINUS
7646: ST_TO_ADDR
// if j = 0 then
7647: LD_VAR 0 3
7651: PUSH
7652: LD_INT 0
7654: EQUAL
7655: IFFALSE 7659
// break ;
7657: GO 7661
// end ;
7659: GO 7610
7661: POP
7662: POP
// end ;
7663: LD_VAR 0 1
7667: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7668: LD_INT 0
7670: PPUSH
7671: PPUSH
7672: PPUSH
7673: PPUSH
7674: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7675: LD_ADDR_VAR 0 4
7679: PUSH
7680: LD_INT 209
7682: PUSH
7683: LD_INT 149
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 219
7692: PUSH
7693: LD_INT 154
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 223
7702: PUSH
7703: LD_INT 149
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 232
7712: PUSH
7713: LD_INT 155
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: ST_TO_ADDR
// if not behemothBuilders then
7726: LD_EXP 73
7730: NOT
7731: IFFALSE 7735
// exit ;
7733: GO 7839
// j := 1 ;
7735: LD_ADDR_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: ST_TO_ADDR
// for i in behemothBuilders do
7743: LD_ADDR_VAR 0 2
7747: PUSH
7748: LD_EXP 73
7752: PUSH
7753: FOR_IN
7754: IFFALSE 7837
// begin if IsInUnit ( i ) then
7756: LD_VAR 0 2
7760: PPUSH
7761: CALL_OW 310
7765: IFFALSE 7776
// ComExitBuilding ( i ) ;
7767: LD_VAR 0 2
7771: PPUSH
7772: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 37
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 1
7797: ARRAY
7798: PPUSH
7799: LD_VAR 0 4
7803: PUSH
7804: LD_VAR 0 3
7808: ARRAY
7809: PUSH
7810: LD_INT 2
7812: ARRAY
7813: PPUSH
7814: LD_INT 0
7816: PPUSH
7817: CALL_OW 230
// j := j + 1 ;
7821: LD_ADDR_VAR 0 3
7825: PUSH
7826: LD_VAR 0 3
7830: PUSH
7831: LD_INT 1
7833: PLUS
7834: ST_TO_ADDR
// end ;
7835: GO 7753
7837: POP
7838: POP
// end ;
7839: LD_VAR 0 1
7843: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7844: LD_INT 24
7846: PPUSH
7847: LD_INT 30
7849: PUSH
7850: LD_INT 37
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PPUSH
7857: CALL_OW 70
7861: IFFALSE 7874
7863: GO 7865
7865: DISABLE
// behemothUnderConstruct := true ;
7866: LD_ADDR_EXP 26
7870: PUSH
7871: LD_INT 1
7873: ST_TO_ADDR
7874: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7875: LD_INT 3
7877: PPUSH
7878: CALL 100983 0 1
7882: PUSH
7883: LD_INT 22
7885: PUSH
7886: LD_INT 3
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: PUSH
7893: LD_INT 30
7895: PUSH
7896: LD_INT 37
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PPUSH
7907: CALL_OW 69
7911: NOT
7912: AND
7913: IFFALSE 8099
7915: GO 7917
7917: DISABLE
7918: LD_INT 0
7920: PPUSH
7921: PPUSH
// begin enable ;
7922: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7923: LD_ADDR_VAR 0 2
7927: PUSH
7928: LD_INT 3
7930: PPUSH
7931: CALL 100983 0 1
7935: ST_TO_ADDR
// for i in tmp do
7936: LD_ADDR_VAR 0 1
7940: PUSH
7941: LD_VAR 0 2
7945: PUSH
7946: FOR_IN
7947: IFFALSE 8097
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7949: LD_VAR 0 1
7953: PPUSH
7954: LD_INT 9
7956: PPUSH
7957: CALL_OW 308
7961: PUSH
7962: LD_VAR 0 1
7966: PPUSH
7967: CALL_OW 110
7971: PUSH
7972: LD_INT 2
7974: EQUAL
7975: NOT
7976: AND
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7991: LD_INT 81
7993: PUSH
7994: LD_INT 3
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 91
8003: PUSH
8004: LD_VAR 0 1
8008: PUSH
8009: LD_INT 12
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 69
8025: NOT
8026: PUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 110
8036: PUSH
8037: LD_INT 2
8039: EQUAL
8040: NOT
8041: AND
8042: IFFALSE 8061
// ComAgressiveMove ( i , 64 , 93 ) else
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_INT 64
8051: PPUSH
8052: LD_INT 93
8054: PPUSH
8055: CALL_OW 114
8059: GO 8095
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8061: LD_VAR 0 1
8065: PPUSH
8066: LD_INT 81
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: PPUSH
8076: CALL_OW 69
8080: PPUSH
8081: LD_VAR 0 1
8085: PPUSH
8086: CALL_OW 74
8090: PPUSH
8091: CALL_OW 115
// end ;
8095: GO 7946
8097: POP
8098: POP
// end ;
8099: PPOPN 2
8101: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8102: LD_INT 0
8104: PPUSH
8105: PPUSH
8106: PPUSH
// result := [ ] ;
8107: LD_ADDR_VAR 0 2
8111: PUSH
8112: EMPTY
8113: ST_TO_ADDR
// uc_side := 6 ;
8114: LD_ADDR_OWVAR 20
8118: PUSH
8119: LD_INT 6
8121: ST_TO_ADDR
// uc_nation := 3 ;
8122: LD_ADDR_OWVAR 21
8126: PUSH
8127: LD_INT 3
8129: ST_TO_ADDR
// case strength of 1 :
8130: LD_VAR 0 1
8134: PUSH
8135: LD_INT 1
8137: DOUBLE
8138: EQUAL
8139: IFTRUE 8143
8141: GO 8281
8143: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8144: LD_ADDR_VAR 0 3
8148: PUSH
8149: DOUBLE
8150: LD_INT 1
8152: DEC
8153: ST_TO_ADDR
8154: LD_INT 4
8156: PUSH
8157: LD_INT 5
8159: PUSH
8160: LD_INT 6
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_OWVAR 67
8172: ARRAY
8173: PUSH
8174: FOR_TO
8175: IFFALSE 8277
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8177: LD_INT 22
8179: PUSH
8180: LD_INT 24
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: LD_VAR 0 3
8191: PUSH
8192: LD_INT 2
8194: MOD
8195: PUSH
8196: LD_INT 1
8198: PLUS
8199: ARRAY
8200: PPUSH
8201: LD_INT 1
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 1
8213: PPUSH
8214: LD_INT 2
8216: PPUSH
8217: CALL_OW 12
8221: ARRAY
8222: PPUSH
8223: LD_INT 3
8225: PPUSH
8226: LD_INT 43
8228: PUSH
8229: LD_INT 44
8231: PUSH
8232: LD_INT 45
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: PUSH
8240: LD_INT 1
8242: PPUSH
8243: LD_INT 3
8245: PPUSH
8246: CALL_OW 12
8250: ARRAY
8251: PPUSH
8252: LD_INT 80
8254: PPUSH
8255: CALL 69889 0 5
// result := result union CreateVehicle ;
8259: LD_ADDR_VAR 0 2
8263: PUSH
8264: LD_VAR 0 2
8268: PUSH
8269: CALL_OW 45
8273: UNION
8274: ST_TO_ADDR
// end ;
8275: GO 8174
8277: POP
8278: POP
// end ; 2 :
8279: GO 9232
8281: LD_INT 2
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8445
8289: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 5
8302: PUSH
8303: LD_INT 6
8305: PUSH
8306: LD_INT 7
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: PUSH
8314: LD_OWVAR 67
8318: ARRAY
8319: PUSH
8320: FOR_TO
8321: IFFALSE 8441
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8323: LD_INT 22
8325: PUSH
8326: LD_INT 24
8328: PUSH
8329: LD_INT 24
8331: PUSH
8332: EMPTY
8333: LIST
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 3
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: LD_INT 44
8387: PUSH
8388: LD_INT 46
8390: PUSH
8391: LD_INT 46
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: PUSH
8402: LD_VAR 0 3
8406: PUSH
8407: LD_INT 6
8409: MOD
8410: PUSH
8411: LD_INT 1
8413: PLUS
8414: ARRAY
8415: PPUSH
8416: LD_INT 80
8418: PPUSH
8419: CALL 69889 0 5
// result := result union CreateVehicle ;
8423: LD_ADDR_VAR 0 2
8427: PUSH
8428: LD_VAR 0 2
8432: PUSH
8433: CALL_OW 45
8437: UNION
8438: ST_TO_ADDR
// end ;
8439: GO 8320
8441: POP
8442: POP
// end ; 3 :
8443: GO 9232
8445: LD_INT 3
8447: DOUBLE
8448: EQUAL
8449: IFTRUE 8453
8451: GO 8609
8453: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8454: LD_ADDR_VAR 0 3
8458: PUSH
8459: DOUBLE
8460: LD_INT 1
8462: DEC
8463: ST_TO_ADDR
8464: LD_INT 5
8466: PUSH
8467: LD_INT 7
8469: PUSH
8470: LD_INT 8
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: LD_OWVAR 67
8482: ARRAY
8483: PUSH
8484: FOR_TO
8485: IFFALSE 8605
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8487: LD_INT 22
8489: PUSH
8490: LD_INT 24
8492: PUSH
8493: LD_INT 24
8495: PUSH
8496: EMPTY
8497: LIST
8498: LIST
8499: LIST
8500: PUSH
8501: LD_VAR 0 3
8505: PUSH
8506: LD_INT 3
8508: MOD
8509: PUSH
8510: LD_INT 1
8512: PLUS
8513: ARRAY
8514: PPUSH
8515: LD_INT 1
8517: PUSH
8518: LD_INT 3
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: PUSH
8525: LD_INT 1
8527: PPUSH
8528: LD_INT 2
8530: PPUSH
8531: CALL_OW 12
8535: ARRAY
8536: PPUSH
8537: LD_INT 3
8539: PPUSH
8540: LD_INT 43
8542: PUSH
8543: LD_INT 47
8545: PUSH
8546: LD_INT 45
8548: PUSH
8549: LD_INT 45
8551: PUSH
8552: LD_INT 46
8554: PUSH
8555: LD_INT 46
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: LIST
8565: PUSH
8566: LD_VAR 0 3
8570: PUSH
8571: LD_INT 6
8573: MOD
8574: PUSH
8575: LD_INT 1
8577: PLUS
8578: ARRAY
8579: PPUSH
8580: LD_INT 80
8582: PPUSH
8583: CALL 69889 0 5
// result := result union CreateVehicle ;
8587: LD_ADDR_VAR 0 2
8591: PUSH
8592: LD_VAR 0 2
8596: PUSH
8597: CALL_OW 45
8601: UNION
8602: ST_TO_ADDR
// end ;
8603: GO 8484
8605: POP
8606: POP
// end ; 4 :
8607: GO 9232
8609: LD_INT 4
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 9231
8617: POP
// begin uc_nation := 3 ;
8618: LD_ADDR_OWVAR 21
8622: PUSH
8623: LD_INT 3
8625: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8626: LD_ADDR_VAR 0 3
8630: PUSH
8631: DOUBLE
8632: LD_INT 1
8634: DEC
8635: ST_TO_ADDR
8636: LD_INT 6
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: LD_INT 9
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: LIST
8649: PUSH
8650: LD_OWVAR 67
8654: ARRAY
8655: PUSH
8656: FOR_TO
8657: IFFALSE 8777
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8659: LD_INT 22
8661: PUSH
8662: LD_INT 24
8664: PUSH
8665: LD_INT 24
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_VAR 0 3
8677: PUSH
8678: LD_INT 3
8680: MOD
8681: PUSH
8682: LD_INT 1
8684: PLUS
8685: ARRAY
8686: PPUSH
8687: LD_INT 1
8689: PUSH
8690: LD_INT 3
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 1
8699: PPUSH
8700: LD_INT 2
8702: PPUSH
8703: CALL_OW 12
8707: ARRAY
8708: PPUSH
8709: LD_INT 3
8711: PPUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 47
8717: PUSH
8718: LD_INT 47
8720: PUSH
8721: LD_INT 45
8723: PUSH
8724: LD_INT 46
8726: PUSH
8727: LD_INT 46
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: PUSH
8738: LD_VAR 0 3
8742: PUSH
8743: LD_INT 6
8745: MOD
8746: PUSH
8747: LD_INT 1
8749: PLUS
8750: ARRAY
8751: PPUSH
8752: LD_INT 80
8754: PPUSH
8755: CALL 69889 0 5
// result := result union CreateVehicle ;
8759: LD_ADDR_VAR 0 2
8763: PUSH
8764: LD_VAR 0 2
8768: PUSH
8769: CALL_OW 45
8773: UNION
8774: ST_TO_ADDR
// end ;
8775: GO 8656
8777: POP
8778: POP
// if not KappaStatus then
8779: LD_EXP 2
8783: NOT
8784: IFFALSE 9019
// begin uc_nation := 1 ;
8786: LD_ADDR_OWVAR 21
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// for i = 1 to 3 do
8794: LD_ADDR_VAR 0 3
8798: PUSH
8799: DOUBLE
8800: LD_INT 1
8802: DEC
8803: ST_TO_ADDR
8804: LD_INT 3
8806: PUSH
8807: FOR_TO
8808: IFFALSE 8944
// begin j := rand ( 0 , 1 ) ;
8810: LD_ADDR_VAR 0 4
8814: PUSH
8815: LD_INT 0
8817: PPUSH
8818: LD_INT 1
8820: PPUSH
8821: CALL_OW 12
8825: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8826: LD_INT 3
8828: PUSH
8829: LD_INT 5
8831: PUSH
8832: LD_INT 5
8834: PUSH
8835: LD_INT 4
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: PUSH
8844: LD_VAR 0 4
8848: PUSH
8849: LD_INT 1
8851: PPUSH
8852: LD_INT 3
8854: PPUSH
8855: CALL_OW 12
8859: PLUS
8860: ARRAY
8861: PPUSH
8862: LD_INT 1
8864: PUSH
8865: LD_INT 3
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: PUSH
8872: LD_INT 1
8874: PPUSH
8875: LD_INT 2
8877: PPUSH
8878: CALL_OW 12
8882: ARRAY
8883: PPUSH
8884: LD_INT 3
8886: PPUSH
8887: LD_INT 9
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: LD_INT 6
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_VAR 0 4
8905: PUSH
8906: LD_INT 1
8908: PPUSH
8909: LD_INT 2
8911: PPUSH
8912: CALL_OW 12
8916: PLUS
8917: ARRAY
8918: PPUSH
8919: LD_INT 85
8921: PPUSH
8922: CALL 69889 0 5
// result := result union CreateVehicle ;
8926: LD_ADDR_VAR 0 2
8930: PUSH
8931: LD_VAR 0 2
8935: PUSH
8936: CALL_OW 45
8940: UNION
8941: ST_TO_ADDR
// end ;
8942: GO 8807
8944: POP
8945: POP
// if vsevolodFirstAttack then
8946: LD_EXP 24
8950: IFFALSE 9017
// begin vsevolodFirstAttack := false ;
8952: LD_ADDR_EXP 24
8956: PUSH
8957: LD_INT 0
8959: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8960: LD_INT 5
8962: PPUSH
8963: LD_INT 3
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_INT 6
8971: PPUSH
8972: LD_INT 100
8974: PPUSH
8975: CALL 69889 0 5
// sewiVeh := CreateVehicle ;
8979: LD_ADDR_EXP 71
8983: PUSH
8984: CALL_OW 45
8988: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8989: LD_EXP 71
8993: PPUSH
8994: LD_INT 1
8996: PPUSH
8997: CALL_OW 242
// result := result union sewiVeh ;
9001: LD_ADDR_VAR 0 2
9005: PUSH
9006: LD_VAR 0 2
9010: PUSH
9011: LD_EXP 71
9015: UNION
9016: ST_TO_ADDR
// end ; end else
9017: GO 9229
// if vsevolodFirstAttack then
9019: LD_EXP 24
9023: IFFALSE 9229
// begin vsevolodFirstAttack := false ;
9025: LD_ADDR_EXP 24
9029: PUSH
9030: LD_INT 0
9032: ST_TO_ADDR
// uc_nation := 3 ;
9033: LD_ADDR_OWVAR 21
9037: PUSH
9038: LD_INT 3
9040: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9041: LD_ADDR_VAR 0 3
9045: PUSH
9046: DOUBLE
9047: LD_INT 1
9049: DEC
9050: ST_TO_ADDR
9051: LD_INT 2
9053: PUSH
9054: LD_OWVAR 67
9058: PLUS
9059: PUSH
9060: FOR_TO
9061: IFFALSE 9169
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9063: LD_INT 22
9065: PUSH
9066: LD_INT 24
9068: PUSH
9069: LD_INT 24
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: PUSH
9077: LD_VAR 0 3
9081: PUSH
9082: LD_INT 3
9084: MOD
9085: PUSH
9086: LD_INT 1
9088: PLUS
9089: ARRAY
9090: PPUSH
9091: LD_INT 1
9093: PUSH
9094: LD_INT 3
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PUSH
9101: LD_INT 1
9103: PPUSH
9104: LD_INT 2
9106: PPUSH
9107: CALL_OW 12
9111: ARRAY
9112: PPUSH
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 45
9118: PUSH
9119: LD_INT 47
9121: PUSH
9122: LD_INT 47
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: LIST
9129: PUSH
9130: LD_VAR 0 3
9134: PUSH
9135: LD_INT 3
9137: MOD
9138: PUSH
9139: LD_INT 1
9141: PLUS
9142: ARRAY
9143: PPUSH
9144: LD_INT 80
9146: PPUSH
9147: CALL 69889 0 5
// result := result union CreateVehicle ;
9151: LD_ADDR_VAR 0 2
9155: PUSH
9156: LD_VAR 0 2
9160: PUSH
9161: CALL_OW 45
9165: UNION
9166: ST_TO_ADDR
// end ;
9167: GO 9060
9169: POP
9170: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9171: LD_INT 24
9173: PPUSH
9174: LD_INT 3
9176: PPUSH
9177: LD_INT 1
9179: PPUSH
9180: LD_INT 47
9182: PPUSH
9183: LD_INT 100
9185: PPUSH
9186: CALL 69889 0 5
// sewiVeh := CreateVehicle ;
9190: LD_ADDR_EXP 71
9194: PUSH
9195: CALL_OW 45
9199: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9200: LD_EXP 71
9204: PPUSH
9205: LD_INT 6
9207: NEG
9208: PPUSH
9209: CALL_OW 242
// result := result union sewiVeh ;
9213: LD_ADDR_VAR 0 2
9217: PUSH
9218: LD_VAR 0 2
9222: PUSH
9223: LD_EXP 71
9227: UNION
9228: ST_TO_ADDR
// end ; end ; end ;
9229: GO 9232
9231: POP
// end ;
9232: LD_VAR 0 2
9236: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9237: LD_EXP 16
9241: IFFALSE 10082
9243: GO 9245
9245: DISABLE
9246: LD_INT 0
9248: PPUSH
9249: PPUSH
9250: PPUSH
9251: PPUSH
9252: PPUSH
9253: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9254: LD_ADDR_VAR 0 4
9258: PUSH
9259: LD_INT 11
9261: PUSH
9262: LD_INT 12
9264: PUSH
9265: EMPTY
9266: LIST
9267: LIST
9268: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9269: LD_ADDR_VAR 0 3
9273: PUSH
9274: LD_INT 11550
9276: PUSH
9277: LD_INT 10150
9279: PUSH
9280: LD_INT 9800
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: LIST
9287: PUSH
9288: LD_OWVAR 67
9292: ARRAY
9293: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9294: LD_ADDR_VAR 0 6
9298: PUSH
9299: LD_INT 70
9301: PUSH
9302: LD_INT 118
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PUSH
9309: LD_INT 78
9311: PUSH
9312: LD_INT 31
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: ST_TO_ADDR
// repeat if missionStage = 2 then
9323: LD_EXP 15
9327: PUSH
9328: LD_INT 2
9330: EQUAL
9331: IFFALSE 9342
// wait ( 1 1$30 ) else
9333: LD_INT 3150
9335: PPUSH
9336: CALL_OW 67
9340: GO 9351
// wait ( time ) ;
9342: LD_VAR 0 3
9346: PPUSH
9347: CALL_OW 67
// if missionStage = 6 then
9351: LD_EXP 15
9355: PUSH
9356: LD_INT 6
9358: EQUAL
9359: IFFALSE 9387
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9361: LD_INT 51
9363: PPUSH
9364: LD_INT 6
9366: PPUSH
9367: LD_INT 2
9369: PPUSH
9370: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9374: LD_INT 57
9376: PPUSH
9377: LD_INT 6
9379: PPUSH
9380: LD_INT 2
9382: PPUSH
9383: CALL_OW 322
// end ; if missionStage = 8 then
9387: LD_EXP 15
9391: PUSH
9392: LD_INT 8
9394: EQUAL
9395: IFFALSE 9423
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9397: LD_INT 52
9399: PPUSH
9400: LD_INT 6
9402: PPUSH
9403: LD_INT 2
9405: PPUSH
9406: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9410: LD_INT 58
9412: PPUSH
9413: LD_INT 6
9415: PPUSH
9416: LD_INT 2
9418: PPUSH
9419: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9423: LD_EXP 15
9427: PUSH
9428: LD_INT 10
9430: EQUAL
9431: PUSH
9432: LD_OWVAR 67
9436: PUSH
9437: LD_INT 1
9439: GREATER
9440: AND
9441: IFFALSE 9469
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9443: LD_INT 53
9445: PPUSH
9446: LD_INT 6
9448: PPUSH
9449: LD_INT 2
9451: PPUSH
9452: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9456: LD_INT 59
9458: PPUSH
9459: LD_INT 6
9461: PPUSH
9462: LD_INT 2
9464: PPUSH
9465: CALL_OW 322
// end ; if activeAttacks then
9469: LD_EXP 16
9473: IFFALSE 10076
// begin if missionStage = 2 then
9475: LD_EXP 15
9479: PUSH
9480: LD_INT 2
9482: EQUAL
9483: IFFALSE 9493
// strength := 1 ;
9485: LD_ADDR_VAR 0 5
9489: PUSH
9490: LD_INT 1
9492: ST_TO_ADDR
// if missionStage > 2 then
9493: LD_EXP 15
9497: PUSH
9498: LD_INT 2
9500: GREATER
9501: IFFALSE 9511
// strength := 2 ;
9503: LD_ADDR_VAR 0 5
9507: PUSH
9508: LD_INT 2
9510: ST_TO_ADDR
// if missionStage > 6 then
9511: LD_EXP 15
9515: PUSH
9516: LD_INT 6
9518: GREATER
9519: IFFALSE 9529
// strength := 3 ;
9521: LD_ADDR_VAR 0 5
9525: PUSH
9526: LD_INT 3
9528: ST_TO_ADDR
// if missionStage > 10 then
9529: LD_EXP 15
9533: PUSH
9534: LD_INT 10
9536: GREATER
9537: IFFALSE 9547
// strength := 4 ;
9539: LD_ADDR_VAR 0 5
9543: PUSH
9544: LD_INT 4
9546: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9547: LD_ADDR_VAR 0 2
9551: PUSH
9552: LD_VAR 0 5
9556: PPUSH
9557: CALL 8102 0 1
9561: ST_TO_ADDR
// for i in tmp do
9562: LD_ADDR_VAR 0 1
9566: PUSH
9567: LD_VAR 0 2
9571: PUSH
9572: FOR_IN
9573: IFFALSE 9756
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9575: LD_VAR 0 1
9579: PPUSH
9580: LD_VAR 0 4
9584: PUSH
9585: LD_INT 1
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 12
9595: ARRAY
9596: PPUSH
9597: LD_INT 0
9599: PPUSH
9600: CALL_OW 49
// if i = sewiVeh then
9604: LD_VAR 0 1
9608: PUSH
9609: LD_EXP 71
9613: EQUAL
9614: IFFALSE 9651
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9616: LD_ADDR_EXP 70
9620: PUSH
9621: LD_STRING Vsevolod
9623: PPUSH
9624: LD_INT 0
9626: PPUSH
9627: LD_STRING 
9629: PPUSH
9630: CALL 65065 0 3
9634: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9635: LD_EXP 70
9639: PPUSH
9640: LD_VAR 0 1
9644: PPUSH
9645: CALL_OW 52
// end else
9649: GO 9732
// if GetControl ( i ) = control_manual then
9651: LD_VAR 0 1
9655: PPUSH
9656: CALL_OW 263
9660: PUSH
9661: LD_INT 1
9663: EQUAL
9664: IFFALSE 9732
// begin uc_side := 6 ;
9666: LD_ADDR_OWVAR 20
9670: PUSH
9671: LD_INT 6
9673: ST_TO_ADDR
// uc_nation := 3 ;
9674: LD_ADDR_OWVAR 21
9678: PUSH
9679: LD_INT 3
9681: ST_TO_ADDR
// hc_gallery :=  ;
9682: LD_ADDR_OWVAR 33
9686: PUSH
9687: LD_STRING 
9689: ST_TO_ADDR
// hc_name :=  ;
9690: LD_ADDR_OWVAR 26
9694: PUSH
9695: LD_STRING 
9697: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9698: LD_INT 0
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: LD_INT 10
9706: PPUSH
9707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9711: CALL_OW 44
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9725: LD_INT 10
9727: PPUSH
9728: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9732: LD_VAR 0 1
9736: PPUSH
9737: LD_INT 111
9739: PPUSH
9740: LD_INT 197
9742: PPUSH
9743: CALL_OW 111
// wait ( 0 0$2 ) ;
9747: LD_INT 70
9749: PPUSH
9750: CALL_OW 67
// end ;
9754: GO 9572
9756: POP
9757: POP
// repeat wait ( 0 0$1 ) ;
9758: LD_INT 35
9760: PPUSH
9761: CALL_OW 67
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 10057
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9778: LD_INT 81
9780: PUSH
9781: LD_INT 6
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PUSH
9788: LD_INT 91
9790: PUSH
9791: LD_VAR 0 1
9795: PUSH
9796: LD_INT 12
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 69
9812: IFFALSE 9870
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_INT 81
9821: PUSH
9822: LD_INT 6
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PUSH
9829: LD_INT 91
9831: PUSH
9832: LD_VAR 0 1
9836: PUSH
9837: LD_INT 12
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: PUSH
9845: EMPTY
9846: LIST
9847: LIST
9848: PPUSH
9849: CALL_OW 69
9853: PPUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: CALL_OW 74
9863: PPUSH
9864: CALL_OW 115
9868: GO 10055
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9870: LD_INT 9
9872: PPUSH
9873: LD_INT 81
9875: PUSH
9876: LD_INT 6
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PPUSH
9883: CALL_OW 70
9887: IFFALSE 10021
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9889: LD_VAR 0 1
9893: PPUSH
9894: LD_VAR 0 6
9898: PUSH
9899: LD_INT 1
9901: ARRAY
9902: PUSH
9903: LD_INT 1
9905: ARRAY
9906: PPUSH
9907: LD_VAR 0 6
9911: PUSH
9912: LD_INT 1
9914: ARRAY
9915: PUSH
9916: LD_INT 2
9918: ARRAY
9919: PPUSH
9920: CALL_OW 297
9924: PUSH
9925: LD_INT 10
9927: GREATER
9928: PUSH
9929: LD_VAR 0 1
9933: PPUSH
9934: LD_INT 9
9936: PPUSH
9937: CALL_OW 308
9941: NOT
9942: AND
9943: IFFALSE 9982
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9945: LD_VAR 0 1
9949: PPUSH
9950: LD_VAR 0 6
9954: PUSH
9955: LD_INT 1
9957: ARRAY
9958: PUSH
9959: LD_INT 1
9961: ARRAY
9962: PPUSH
9963: LD_VAR 0 6
9967: PUSH
9968: LD_INT 1
9970: ARRAY
9971: PUSH
9972: LD_INT 2
9974: ARRAY
9975: PPUSH
9976: CALL_OW 114
9980: GO 10019
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_INT 9
9989: PPUSH
9990: LD_INT 81
9992: PUSH
9993: LD_INT 6
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PPUSH
10000: CALL_OW 70
10004: PPUSH
10005: LD_VAR 0 1
10009: PPUSH
10010: CALL_OW 74
10014: PPUSH
10015: CALL_OW 115
// end else
10019: GO 10055
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10021: LD_VAR 0 1
10025: PPUSH
10026: LD_INT 81
10028: PUSH
10029: LD_INT 6
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: PPUSH
10036: CALL_OW 69
10040: PPUSH
10041: LD_VAR 0 1
10045: PPUSH
10046: CALL_OW 74
10050: PPUSH
10051: CALL_OW 115
// end ;
10055: GO 9775
10057: POP
10058: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10059: LD_INT 22
10061: PUSH
10062: LD_INT 6
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PPUSH
10069: CALL_OW 69
10073: NOT
10074: IFFALSE 9758
// end ; until russianDestroyed ;
10076: LD_EXP 21
10080: IFFALSE 9323
// end ;
10082: PPOPN 6
10084: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10085: LD_EXP 21
10089: NOT
10090: PUSH
10091: LD_EXP 15
10095: PUSH
10096: LD_INT 6
10098: GREATEREQUAL
10099: AND
10100: PUSH
10101: LD_INT 2
10103: PPUSH
10104: LD_INT 1
10106: PPUSH
10107: CALL 60139 0 2
10111: NOT
10112: AND
10113: IFFALSE 11069
10115: GO 10117
10117: DISABLE
10118: LD_INT 0
10120: PPUSH
10121: PPUSH
10122: PPUSH
10123: PPUSH
// begin enable ;
10124: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10125: LD_INT 22
10127: PUSH
10128: LD_INT 3
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 30
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: EMPTY
10146: LIST
10147: LIST
10148: PPUSH
10149: CALL_OW 69
10153: NOT
10154: IFFALSE 10158
// exit ;
10156: GO 11069
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10158: LD_ADDR_VAR 0 4
10162: PUSH
10163: LD_INT 22
10165: PUSH
10166: LD_INT 3
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PUSH
10173: LD_INT 30
10175: PUSH
10176: LD_INT 34
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: PPUSH
10187: CALL_OW 69
10191: ST_TO_ADDR
// if Prob ( 40 ) then
10192: LD_INT 40
10194: PPUSH
10195: CALL_OW 13
10199: IFFALSE 10326
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10201: LD_INT 2
10203: PPUSH
10204: LD_INT 22
10206: PUSH
10207: LD_INT 3
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 49
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 22
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 49
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: LIST
10239: PUSH
10240: LD_INT 22
10242: PUSH
10243: LD_INT 3
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 49
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 24
10260: PUSH
10261: LD_INT 3
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 46
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: PUSH
10276: LD_INT 24
10278: PUSH
10279: LD_INT 3
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 46
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: PUSH
10294: LD_INT 24
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 46
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: PPUSH
10320: CALL 58721 0 2
// end else
10324: GO 10449
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10326: LD_INT 2
10328: PPUSH
10329: LD_INT 24
10331: PUSH
10332: LD_INT 3
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 47
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: PUSH
10347: LD_INT 24
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 47
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: PUSH
10365: LD_INT 24
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 47
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: PUSH
10383: LD_INT 24
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 46
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 24
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 46
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 24
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 46
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: LIST
10435: LIST
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: LIST
10444: PPUSH
10445: CALL 58721 0 2
// end ; if Difficulty > 1 then
10449: LD_OWVAR 67
10453: PUSH
10454: LD_INT 1
10456: GREATER
10457: IFFALSE 10487
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10459: LD_INT 2
10461: PPUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 47
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: PPUSH
10483: CALL 58721 0 2
// repeat wait ( 0 0$1 ) ;
10487: LD_INT 35
10489: PPUSH
10490: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10494: LD_INT 2
10496: PPUSH
10497: LD_INT 1
10499: PPUSH
10500: CALL 60139 0 2
10504: PUSH
10505: LD_INT 6
10507: PUSH
10508: LD_INT 7
10510: PUSH
10511: LD_INT 7
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: PUSH
10519: LD_OWVAR 67
10523: ARRAY
10524: GREATEREQUAL
10525: IFFALSE 10487
// wait ( 0 0$30 ) ;
10527: LD_INT 1050
10529: PPUSH
10530: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10534: LD_ADDR_VAR 0 2
10538: PUSH
10539: LD_INT 2
10541: PPUSH
10542: LD_INT 1
10544: PPUSH
10545: CALL 60139 0 2
10549: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10550: LD_ADDR_EXP 129
10554: PUSH
10555: LD_EXP 129
10559: PPUSH
10560: LD_INT 2
10562: PPUSH
10563: LD_EXP 129
10567: PUSH
10568: LD_INT 2
10570: ARRAY
10571: PUSH
10572: LD_VAR 0 2
10576: DIFF
10577: PPUSH
10578: CALL_OW 1
10582: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10583: LD_ADDR_VAR 0 3
10587: PUSH
10588: LD_INT 0
10590: PPUSH
10591: LD_INT 1
10593: PPUSH
10594: CALL_OW 12
10598: ST_TO_ADDR
// if target then
10599: LD_VAR 0 3
10603: IFFALSE 10731
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10605: LD_ADDR_VAR 0 2
10609: PUSH
10610: LD_VAR 0 2
10614: PPUSH
10615: LD_INT 24
10617: PUSH
10618: LD_INT 250
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: PPUSH
10625: CALL_OW 72
10629: ST_TO_ADDR
// for i in tmp do
10630: LD_ADDR_VAR 0 1
10634: PUSH
10635: LD_VAR 0 2
10639: PUSH
10640: FOR_IN
10641: IFFALSE 10681
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10643: LD_VAR 0 1
10647: PPUSH
10648: LD_INT 139
10650: PPUSH
10651: LD_INT 89
10653: PPUSH
10654: CALL_OW 297
10658: PUSH
10659: LD_INT 9
10661: GREATER
10662: IFFALSE 10679
// ComMoveXY ( i , 139 , 89 ) ;
10664: LD_VAR 0 1
10668: PPUSH
10669: LD_INT 139
10671: PPUSH
10672: LD_INT 89
10674: PPUSH
10675: CALL_OW 111
10679: GO 10640
10681: POP
10682: POP
// wait ( 0 0$1 ) ;
10683: LD_INT 35
10685: PPUSH
10686: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10690: LD_VAR 0 2
10694: PPUSH
10695: LD_INT 92
10697: PUSH
10698: LD_INT 139
10700: PUSH
10701: LD_INT 89
10703: PUSH
10704: LD_INT 9
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: PPUSH
10713: CALL_OW 72
10717: PUSH
10718: LD_VAR 0 2
10722: PUSH
10723: LD_INT 1
10725: MINUS
10726: GREATEREQUAL
10727: IFFALSE 10605
// end else
10729: GO 10873
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10731: LD_VAR 0 2
10735: PPUSH
10736: LD_VAR 0 4
10740: PUSH
10741: LD_INT 1
10743: ARRAY
10744: PPUSH
10745: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10749: LD_ADDR_VAR 0 2
10753: PUSH
10754: LD_VAR 0 2
10758: PPUSH
10759: LD_INT 24
10761: PUSH
10762: LD_INT 250
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: PPUSH
10769: CALL_OW 72
10773: ST_TO_ADDR
// for i in tmp do
10774: LD_ADDR_VAR 0 1
10778: PUSH
10779: LD_VAR 0 2
10783: PUSH
10784: FOR_IN
10785: IFFALSE 10825
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 124
10794: PPUSH
10795: LD_INT 139
10797: PPUSH
10798: CALL_OW 297
10802: PUSH
10803: LD_INT 9
10805: GREATER
10806: IFFALSE 10823
// ComMoveXY ( i , 124 , 139 ) ;
10808: LD_VAR 0 1
10812: PPUSH
10813: LD_INT 124
10815: PPUSH
10816: LD_INT 139
10818: PPUSH
10819: CALL_OW 111
10823: GO 10784
10825: POP
10826: POP
// wait ( 0 0$1 ) ;
10827: LD_INT 35
10829: PPUSH
10830: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_INT 92
10841: PUSH
10842: LD_INT 124
10844: PUSH
10845: LD_INT 139
10847: PUSH
10848: LD_INT 9
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 72
10861: PUSH
10862: LD_VAR 0 2
10866: PUSH
10867: LD_INT 1
10869: MINUS
10870: GREATEREQUAL
10871: IFFALSE 10749
// end ; repeat wait ( 0 0$1 ) ;
10873: LD_INT 35
10875: PPUSH
10876: CALL_OW 67
// for i in tmp do
10880: LD_ADDR_VAR 0 1
10884: PUSH
10885: LD_VAR 0 2
10889: PUSH
10890: FOR_IN
10891: IFFALSE 11060
// begin if GetLives ( i ) > 251 then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 256
10902: PUSH
10903: LD_INT 251
10905: GREATER
10906: IFFALSE 11031
// begin if GetWeapon ( i ) = ru_time_lapser then
10908: LD_VAR 0 1
10912: PPUSH
10913: CALL_OW 264
10917: PUSH
10918: LD_INT 49
10920: EQUAL
10921: IFFALSE 10977
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10923: LD_VAR 0 1
10927: PPUSH
10928: LD_INT 2
10930: PUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 1
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PUSH
10941: LD_INT 22
10943: PUSH
10944: LD_INT 8
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PPUSH
10961: LD_VAR 0 1
10965: PPUSH
10966: CALL_OW 74
10970: PPUSH
10971: CALL_OW 112
10975: GO 11029
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10977: LD_VAR 0 1
10981: PPUSH
10982: LD_INT 2
10984: PUSH
10985: LD_INT 22
10987: PUSH
10988: LD_INT 1
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 22
10997: PUSH
10998: LD_INT 8
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: LIST
11009: PPUSH
11010: CALL_OW 69
11014: PPUSH
11015: LD_VAR 0 1
11019: PPUSH
11020: CALL_OW 74
11024: PPUSH
11025: CALL_OW 115
// end else
11029: GO 11058
// if IsDead ( i ) then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 301
11040: IFFALSE 11058
// tmp := tmp diff i ;
11042: LD_ADDR_VAR 0 2
11046: PUSH
11047: LD_VAR 0 2
11051: PUSH
11052: LD_VAR 0 1
11056: DIFF
11057: ST_TO_ADDR
// end ;
11058: GO 10890
11060: POP
11061: POP
// until not tmp ;
11062: LD_VAR 0 2
11066: NOT
11067: IFFALSE 10873
// end ; end_of_file
11069: PPOPN 4
11071: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11072: LD_INT 0
11074: PPUSH
11075: PPUSH
11076: PPUSH
11077: PPUSH
11078: PPUSH
11079: PPUSH
// side := 7 ;
11080: LD_ADDR_VAR 0 5
11084: PUSH
11085: LD_INT 7
11087: ST_TO_ADDR
// uc_side := side ;
11088: LD_ADDR_OWVAR 20
11092: PUSH
11093: LD_VAR 0 5
11097: ST_TO_ADDR
// uc_nation := 1 ;
11098: LD_ADDR_OWVAR 21
11102: PUSH
11103: LD_INT 1
11105: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11106: LD_ADDR_VAR 0 2
11110: PUSH
11111: LD_INT 22
11113: PUSH
11114: LD_VAR 0 5
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PUSH
11123: LD_INT 21
11125: PUSH
11126: LD_INT 3
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PPUSH
11137: CALL_OW 69
11141: PUSH
11142: FOR_IN
11143: IFFALSE 11159
// SetBLevel ( i , 10 ) ;
11145: LD_VAR 0 2
11149: PPUSH
11150: LD_INT 10
11152: PPUSH
11153: CALL_OW 241
11157: GO 11142
11159: POP
11160: POP
// base := GetBase ( al_depot ) ;
11161: LD_ADDR_VAR 0 4
11165: PUSH
11166: LD_INT 2
11168: PPUSH
11169: CALL_OW 274
11173: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11174: LD_ADDR_VAR 0 6
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_VAR 0 5
11186: PUSH
11187: EMPTY
11188: LIST
11189: LIST
11190: PUSH
11191: LD_INT 30
11193: PUSH
11194: LD_INT 34
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 69
11209: ST_TO_ADDR
// if teleport then
11210: LD_VAR 0 6
11214: IFFALSE 11235
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11216: LD_VAR 0 6
11220: PUSH
11221: LD_INT 1
11223: ARRAY
11224: PPUSH
11225: LD_INT 262
11227: PPUSH
11228: LD_INT 119
11230: PPUSH
11231: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 1
11242: PPUSH
11243: LD_INT 19500
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 2
11257: PPUSH
11258: LD_INT 200
11260: PPUSH
11261: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11265: LD_VAR 0 4
11269: PPUSH
11270: LD_INT 3
11272: PPUSH
11273: LD_INT 650
11275: PPUSH
11276: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11280: LD_ADDR_EXP 74
11284: PUSH
11285: LD_STRING Roth
11287: PPUSH
11288: CALL_OW 25
11292: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11293: LD_ADDR_EXP 75
11297: PUSH
11298: LD_STRING Simms
11300: PPUSH
11301: LD_EXP 1
11305: NOT
11306: PPUSH
11307: LD_STRING 10c_
11309: PPUSH
11310: CALL 65065 0 3
11314: ST_TO_ADDR
// if not Simms then
11315: LD_EXP 75
11319: NOT
11320: IFFALSE 11350
// begin uc_nation := 1 ;
11322: LD_ADDR_OWVAR 21
11326: PUSH
11327: LD_INT 1
11329: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11330: LD_INT 2
11332: PPUSH
11333: LD_INT 10
11335: PPUSH
11336: CALL_OW 384
// Simms := CreateHuman ;
11340: LD_ADDR_EXP 75
11344: PUSH
11345: CALL_OW 44
11349: ST_TO_ADDR
// end ; uc_nation := 3 ;
11350: LD_ADDR_OWVAR 21
11354: PUSH
11355: LD_INT 3
11357: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11358: LD_ADDR_EXP 76
11362: PUSH
11363: LD_STRING Kirilenkova
11365: PPUSH
11366: CALL_OW 25
11370: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11371: LD_ADDR_EXP 90
11375: PUSH
11376: LD_STRING Oblukov
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11384: LD_ADDR_EXP 77
11388: PUSH
11389: LD_STRING Dolgov
11391: PPUSH
11392: CALL_OW 25
11396: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11397: LD_ADDR_EXP 78
11401: PUSH
11402: LD_STRING Petrosyan
11404: PPUSH
11405: CALL_OW 25
11409: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11410: LD_ADDR_EXP 89
11414: PUSH
11415: LD_STRING Scholtze
11417: PPUSH
11418: CALL_OW 25
11422: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11423: LD_ADDR_EXP 88
11427: PUSH
11428: LD_STRING Kapitsova
11430: PPUSH
11431: CALL_OW 25
11435: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11436: LD_ADDR_EXP 79
11440: PUSH
11441: LD_STRING Petrovova
11443: PPUSH
11444: CALL_OW 25
11448: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11449: LD_ADDR_EXP 80
11453: PUSH
11454: LD_STRING Kuzmov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11462: LD_ADDR_EXP 87
11466: PUSH
11467: LD_STRING Karamazov
11469: PPUSH
11470: CALL_OW 25
11474: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11475: LD_STRING 13_Lipshchin_1
11477: PPUSH
11478: LD_INT 0
11480: PPUSH
11481: CALL_OW 30
11485: IFFALSE 11500
// Lipshchin := NewCharacter ( Lipshchin ) ;
11487: LD_ADDR_EXP 81
11491: PUSH
11492: LD_STRING Lipshchin
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11500: LD_STRING 13_Titov_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Titov := NewCharacter ( Titov ) ;
11512: LD_ADDR_EXP 83
11516: PUSH
11517: LD_STRING Titov
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11525: LD_STRING 13_Gnyevko_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Gnyevko := NewCharacter ( Gnyevko ) ;
11537: LD_ADDR_EXP 82
11541: PUSH
11542: LD_STRING Gnyevko
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11550: LD_STRING 13_Xavier_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Xavier := NewCharacter ( Xavier2 ) ;
11562: LD_ADDR_EXP 84
11566: PUSH
11567: LD_STRING Xavier2
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11575: LD_STRING 13_Belkov_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Belkov := NewCharacter ( Belkov ) ;
11587: LD_ADDR_EXP 85
11591: PUSH
11592: LD_STRING Belkov
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if not BurlakStatus then
11600: LD_EXP 9
11604: NOT
11605: IFFALSE 11620
// Burlak = NewCharacter ( Burlak ) ;
11607: LD_ADDR_EXP 86
11611: PUSH
11612: LD_STRING Burlak
11614: PPUSH
11615: CALL_OW 25
11619: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11620: LD_ADDR_VAR 0 3
11624: PUSH
11625: LD_EXP 74
11629: PUSH
11630: LD_EXP 76
11634: PUSH
11635: LD_EXP 90
11639: PUSH
11640: LD_EXP 77
11644: PUSH
11645: LD_EXP 78
11649: PUSH
11650: LD_EXP 89
11654: PUSH
11655: LD_EXP 88
11659: PUSH
11660: LD_EXP 79
11664: PUSH
11665: LD_EXP 80
11669: PUSH
11670: LD_EXP 87
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: ST_TO_ADDR
// if Simms then
11687: LD_EXP 75
11691: IFFALSE 11709
// tmp := tmp ^ Simms ;
11693: LD_ADDR_VAR 0 3
11697: PUSH
11698: LD_VAR 0 3
11702: PUSH
11703: LD_EXP 75
11707: ADD
11708: ST_TO_ADDR
// if Titov then
11709: LD_EXP 83
11713: IFFALSE 11731
// tmp := tmp ^ Titov ;
11715: LD_ADDR_VAR 0 3
11719: PUSH
11720: LD_VAR 0 3
11724: PUSH
11725: LD_EXP 83
11729: ADD
11730: ST_TO_ADDR
// if Lipshchin then
11731: LD_EXP 81
11735: IFFALSE 11753
// tmp := tmp ^ Lipshchin ;
11737: LD_ADDR_VAR 0 3
11741: PUSH
11742: LD_VAR 0 3
11746: PUSH
11747: LD_EXP 81
11751: ADD
11752: ST_TO_ADDR
// if Gnyevko then
11753: LD_EXP 82
11757: IFFALSE 11775
// tmp := tmp ^ Gnyevko ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_VAR 0 3
11768: PUSH
11769: LD_EXP 82
11773: ADD
11774: ST_TO_ADDR
// if Xavier then
11775: LD_EXP 84
11779: IFFALSE 11797
// tmp := tmp ^ Xavier ;
11781: LD_ADDR_VAR 0 3
11785: PUSH
11786: LD_VAR 0 3
11790: PUSH
11791: LD_EXP 84
11795: ADD
11796: ST_TO_ADDR
// if Belkov then
11797: LD_EXP 85
11801: IFFALSE 11819
// tmp := tmp ^ Belkov ;
11803: LD_ADDR_VAR 0 3
11807: PUSH
11808: LD_VAR 0 3
11812: PUSH
11813: LD_EXP 85
11817: ADD
11818: ST_TO_ADDR
// if Burlak then
11819: LD_EXP 86
11823: IFFALSE 11841
// tmp := tmp ^ Burlak ;
11825: LD_ADDR_VAR 0 3
11829: PUSH
11830: LD_VAR 0 3
11834: PUSH
11835: LD_EXP 86
11839: ADD
11840: ST_TO_ADDR
// for i = 1 to 11 do
11841: LD_ADDR_VAR 0 2
11845: PUSH
11846: DOUBLE
11847: LD_INT 1
11849: DEC
11850: ST_TO_ADDR
11851: LD_INT 11
11853: PUSH
11854: FOR_TO
11855: IFFALSE 11921
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11857: LD_ADDR_OWVAR 21
11861: PUSH
11862: LD_INT 1
11864: PUSH
11865: LD_INT 3
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: LD_INT 1
11874: PPUSH
11875: LD_INT 2
11877: PPUSH
11878: CALL_OW 12
11882: ARRAY
11883: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11884: LD_INT 0
11886: PPUSH
11887: LD_VAR 0 2
11891: PUSH
11892: LD_INT 2
11894: DIV
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11903: LD_ADDR_VAR 0 3
11907: PUSH
11908: LD_VAR 0 3
11912: PUSH
11913: CALL_OW 44
11917: ADD
11918: ST_TO_ADDR
// end ;
11919: GO 11854
11921: POP
11922: POP
// for i in tmp do
11923: LD_ADDR_VAR 0 2
11927: PUSH
11928: LD_VAR 0 3
11932: PUSH
11933: FOR_IN
11934: IFFALSE 11959
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11936: LD_VAR 0 2
11940: PPUSH
11941: LD_INT 260
11943: PPUSH
11944: LD_INT 235
11946: PPUSH
11947: LD_INT 8
11949: PPUSH
11950: LD_INT 0
11952: PPUSH
11953: CALL_OW 50
11957: GO 11933
11959: POP
11960: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11961: LD_ADDR_EXP 110
11965: PUSH
11966: LD_EXP 110
11970: PPUSH
11971: LD_INT 1
11973: PPUSH
11974: LD_INT 22
11976: PUSH
11977: LD_VAR 0 5
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: PUSH
11986: LD_INT 3
11988: PUSH
11989: LD_INT 21
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PPUSH
12007: CALL_OW 69
12011: PUSH
12012: LD_EXP 74
12016: PUSH
12017: LD_EXP 75
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: DIFF
12026: PPUSH
12027: CALL_OW 1
12031: ST_TO_ADDR
// uc_side := 0 ;
12032: LD_ADDR_OWVAR 20
12036: PUSH
12037: LD_INT 0
12039: ST_TO_ADDR
// uc_nation := 0 ;
12040: LD_ADDR_OWVAR 21
12044: PUSH
12045: LD_INT 0
12047: ST_TO_ADDR
// for i = 1 to 5 do
12048: LD_ADDR_VAR 0 2
12052: PUSH
12053: DOUBLE
12054: LD_INT 1
12056: DEC
12057: ST_TO_ADDR
12058: LD_INT 5
12060: PUSH
12061: FOR_TO
12062: IFFALSE 12099
// begin InitHc ;
12064: CALL_OW 19
// hc_class := class_apeman ;
12068: LD_ADDR_OWVAR 28
12072: PUSH
12073: LD_INT 12
12075: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12076: CALL_OW 44
12080: PPUSH
12081: LD_INT 299
12083: PPUSH
12084: LD_INT 229
12086: PPUSH
12087: LD_INT 10
12089: PPUSH
12090: LD_INT 0
12092: PPUSH
12093: CALL_OW 50
// end ;
12097: GO 12061
12099: POP
12100: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 259
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12116: LD_EXP 74
12120: PPUSH
12121: LD_INT 262
12123: PPUSH
12124: LD_INT 235
12126: PPUSH
12127: CALL_OW 178
// if Simms then
12131: LD_EXP 75
12135: IFFALSE 12166
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_INT 262
12144: PPUSH
12145: LD_INT 235
12147: PPUSH
12148: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12152: LD_EXP 75
12156: PPUSH
12157: LD_EXP 74
12161: PPUSH
12162: CALL_OW 179
// end ; end ;
12166: LD_VAR 0 1
12170: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12171: LD_EXP 31
12175: PUSH
12176: LD_EXP 23
12180: NOT
12181: AND
12182: IFFALSE 12358
12184: GO 12186
12186: DISABLE
12187: LD_INT 0
12189: PPUSH
12190: PPUSH
12191: PPUSH
// begin enable ;
12192: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 81
12200: PUSH
12201: LD_INT 7
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 2
12210: PUSH
12211: LD_INT 32
12213: PUSH
12214: LD_INT 3
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PUSH
12221: LD_INT 30
12223: PUSH
12224: LD_INT 30
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: LD_INT 30
12233: PUSH
12234: LD_INT 28
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PUSH
12241: LD_INT 34
12243: PUSH
12244: LD_INT 49
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: LD_INT 34
12253: PUSH
12254: LD_INT 10
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: LD_INT 34
12263: PUSH
12264: LD_INT 8
12266: PUSH
12267: EMPTY
12268: LIST
12269: LIST
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: LIST
12275: LIST
12276: LIST
12277: LIST
12278: LIST
12279: PUSH
12280: EMPTY
12281: LIST
12282: LIST
12283: PPUSH
12284: CALL_OW 69
12288: ST_TO_ADDR
// if not tmp then
12289: LD_VAR 0 2
12293: NOT
12294: IFFALSE 12298
// exit ;
12296: GO 12358
// target := tmp [ rand ( 1 , tmp ) ] ;
12298: LD_ADDR_VAR 0 3
12302: PUSH
12303: LD_VAR 0 2
12307: PUSH
12308: LD_INT 1
12310: PPUSH
12311: LD_VAR 0 2
12315: PPUSH
12316: CALL_OW 12
12320: ARRAY
12321: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 255
12331: PUSH
12332: LD_INT 1
12334: EQUAL
12335: IFFALSE 12346
// CenterNowOnUnits ( target ) ;
12337: LD_VAR 0 3
12341: PPUSH
12342: CALL_OW 87
// SetLives ( target , 0 ) ;
12346: LD_VAR 0 3
12350: PPUSH
12351: LD_INT 0
12353: PPUSH
12354: CALL_OW 234
// end ;
12358: PPOPN 3
12360: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12361: LD_EXP 23
12365: NOT
12366: PUSH
12367: LD_EXP 31
12371: AND
12372: IFFALSE 12894
12374: GO 12376
12376: DISABLE
12377: LD_INT 0
12379: PPUSH
12380: PPUSH
12381: PPUSH
// begin uc_side := 7 ;
12382: LD_ADDR_OWVAR 20
12386: PUSH
12387: LD_INT 7
12389: ST_TO_ADDR
// uc_nation := 1 ;
12390: LD_ADDR_OWVAR 21
12394: PUSH
12395: LD_INT 1
12397: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_INT 125
12405: PUSH
12406: LD_INT 163
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: PUSH
12413: LD_INT 185
12415: PUSH
12416: LD_INT 168
12418: PUSH
12419: EMPTY
12420: LIST
12421: LIST
12422: PUSH
12423: LD_INT 111
12425: PUSH
12426: LD_INT 97
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: PPUSH
12438: CALL 101027 0 1
12442: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12443: LD_ADDR_EXP 91
12447: PUSH
12448: EMPTY
12449: ST_TO_ADDR
// for i = 1 to Difficulty do
12450: LD_ADDR_VAR 0 1
12454: PUSH
12455: DOUBLE
12456: LD_INT 1
12458: DEC
12459: ST_TO_ADDR
12460: LD_OWVAR 67
12464: PUSH
12465: FOR_TO
12466: IFFALSE 12624
// begin InitHc ;
12468: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12472: LD_INT 0
12474: PPUSH
12475: LD_INT 8
12477: PPUSH
12478: CALL_OW 381
// un := CreateHuman ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: CALL_OW 44
12491: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12492: LD_VAR 0 2
12496: PPUSH
12497: LD_INT 258
12499: PPUSH
12500: LD_INT 267
12502: PPUSH
12503: LD_INT 4
12505: PPUSH
12506: LD_INT 0
12508: PPUSH
12509: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12513: LD_ADDR_EXP 91
12517: PUSH
12518: LD_EXP 91
12522: PUSH
12523: LD_VAR 0 2
12527: UNION
12528: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12529: LD_VAR 0 2
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 1
12547: ARRAY
12548: PPUSH
12549: LD_VAR 0 3
12553: PUSH
12554: LD_VAR 0 1
12558: ARRAY
12559: PUSH
12560: LD_INT 2
12562: ARRAY
12563: PPUSH
12564: LD_INT 4
12566: PPUSH
12567: LD_INT 1
12569: PPUSH
12570: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12574: LD_VAR 0 2
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 1
12592: ARRAY
12593: PPUSH
12594: LD_VAR 0 3
12598: PUSH
12599: LD_VAR 0 1
12603: ARRAY
12604: PUSH
12605: LD_INT 2
12607: ARRAY
12608: PPUSH
12609: CALL_OW 171
// AddComInvisible ( un ) ;
12613: LD_VAR 0 2
12617: PPUSH
12618: CALL_OW 212
// end ;
12622: GO 12465
12624: POP
12625: POP
// repeat wait ( 0 0$20 ) ;
12626: LD_INT 700
12628: PPUSH
12629: CALL_OW 67
// for i in allianceSpecialForce do
12633: LD_ADDR_VAR 0 1
12637: PUSH
12638: LD_EXP 91
12642: PUSH
12643: FOR_IN
12644: IFFALSE 12879
// begin if IsInvisible ( i ) then
12646: LD_VAR 0 1
12650: PPUSH
12651: CALL_OW 571
12655: IFFALSE 12848
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12657: LD_ADDR_VAR 0 3
12661: PUSH
12662: LD_INT 22
12664: PUSH
12665: LD_INT 1
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PUSH
12672: LD_INT 50
12674: PUSH
12675: EMPTY
12676: LIST
12677: PUSH
12678: LD_INT 56
12680: PUSH
12681: EMPTY
12682: LIST
12683: PUSH
12684: LD_INT 91
12686: PUSH
12687: LD_VAR 0 1
12691: PUSH
12692: LD_INT 25
12694: PUSH
12695: LD_INT 30
12697: PUSH
12698: LD_INT 35
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: LIST
12705: PUSH
12706: LD_OWVAR 67
12710: ARRAY
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 2
12719: PUSH
12720: LD_INT 25
12722: PUSH
12723: LD_INT 1
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: LD_INT 25
12732: PUSH
12733: LD_INT 2
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 25
12742: PUSH
12743: LD_INT 3
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 25
12752: PUSH
12753: LD_INT 4
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: LD_INT 25
12762: PUSH
12763: LD_INT 5
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: LD_INT 25
12772: PUSH
12773: LD_INT 8
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: PPUSH
12796: CALL_OW 69
12800: ST_TO_ADDR
// if not tmp then
12801: LD_VAR 0 3
12805: NOT
12806: IFFALSE 12810
// continue ;
12808: GO 12643
// if Prob ( 30 * Difficulty ) then
12810: LD_INT 30
12812: PUSH
12813: LD_OWVAR 67
12817: MUL
12818: PPUSH
12819: CALL_OW 13
12823: IFFALSE 12848
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12825: LD_VAR 0 3
12829: PUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_VAR 0 3
12837: PPUSH
12838: CALL_OW 12
12842: ARRAY
12843: PPUSH
12844: CALL 31141 0 1
// end ; if IsDead ( i ) then
12848: LD_VAR 0 1
12852: PPUSH
12853: CALL_OW 301
12857: IFFALSE 12877
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12859: LD_ADDR_EXP 91
12863: PUSH
12864: LD_EXP 91
12868: PUSH
12869: LD_VAR 0 1
12873: DIFF
12874: ST_TO_ADDR
// continue ;
12875: GO 12643
// end ; end ;
12877: GO 12643
12879: POP
12880: POP
// until allianceDestroyed or not allianceSpecialForce ;
12881: LD_EXP 23
12885: PUSH
12886: LD_EXP 91
12890: NOT
12891: OR
12892: IFFALSE 12626
// end ;
12894: PPOPN 3
12896: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12897: LD_EXP 23
12901: NOT
12902: PUSH
12903: LD_EXP 31
12907: AND
12908: IFFALSE 13875
12910: GO 12912
12912: DISABLE
12913: LD_INT 0
12915: PPUSH
12916: PPUSH
12917: PPUSH
12918: PPUSH
// begin enable ;
12919: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12920: LD_INT 22
12922: PUSH
12923: LD_INT 7
12925: PUSH
12926: EMPTY
12927: LIST
12928: LIST
12929: PUSH
12930: LD_INT 30
12932: PUSH
12933: LD_INT 3
12935: PUSH
12936: EMPTY
12937: LIST
12938: LIST
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PPUSH
12944: CALL_OW 69
12948: NOT
12949: IFFALSE 12953
// exit ;
12951: GO 13875
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12953: LD_ADDR_VAR 0 4
12957: PUSH
12958: LD_INT 22
12960: PUSH
12961: LD_INT 7
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: LD_INT 30
12970: PUSH
12971: LD_INT 34
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PPUSH
12982: CALL_OW 69
12986: ST_TO_ADDR
// if Prob ( 40 ) then
12987: LD_INT 40
12989: PPUSH
12990: CALL_OW 13
12994: IFFALSE 13121
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12996: LD_INT 1
12998: PPUSH
12999: LD_INT 5
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: LD_INT 2
13007: PUSH
13008: LD_INT 6
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: PUSH
13017: LD_INT 5
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: LD_INT 2
13025: PUSH
13026: LD_INT 6
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: PUSH
13035: LD_INT 5
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: LD_INT 2
13043: PUSH
13044: LD_INT 6
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 24
13055: PUSH
13056: LD_INT 3
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 45
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 24
13073: PUSH
13074: LD_INT 3
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 47
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 3
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 45
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL 58721 0 2
// end else
13119: GO 13244
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13121: LD_INT 1
13123: PPUSH
13124: LD_INT 24
13126: PUSH
13127: LD_INT 3
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 47
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: PUSH
13142: LD_INT 24
13144: PUSH
13145: LD_INT 3
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 47
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: PUSH
13160: LD_INT 5
13162: PUSH
13163: LD_INT 3
13165: PUSH
13166: LD_INT 2
13168: PUSH
13169: LD_INT 9
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: PUSH
13178: LD_INT 5
13180: PUSH
13181: LD_INT 3
13183: PUSH
13184: LD_INT 2
13186: PUSH
13187: LD_INT 9
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 24
13198: PUSH
13199: LD_INT 1
13201: PUSH
13202: LD_INT 3
13204: PUSH
13205: LD_INT 45
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 24
13216: PUSH
13217: LD_INT 1
13219: PUSH
13220: LD_INT 3
13222: PUSH
13223: LD_INT 45
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: PPUSH
13240: CALL 58721 0 2
// end ; if Difficulty > 1 then
13244: LD_OWVAR 67
13248: PUSH
13249: LD_INT 1
13251: GREATER
13252: IFFALSE 13282
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13254: LD_INT 1
13256: PPUSH
13257: LD_INT 24
13259: PUSH
13260: LD_INT 3
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: LD_INT 47
13268: PUSH
13269: EMPTY
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: PUSH
13275: EMPTY
13276: LIST
13277: PPUSH
13278: CALL 58721 0 2
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13289: LD_INT 1
13291: PPUSH
13292: LD_INT 1
13294: PPUSH
13295: CALL 60139 0 2
13299: PUSH
13300: LD_INT 6
13302: PUSH
13303: LD_INT 7
13305: PUSH
13306: LD_INT 7
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: PUSH
13314: LD_OWVAR 67
13318: ARRAY
13319: GREATEREQUAL
13320: IFFALSE 13282
// wait ( 0 0$40 ) ;
13322: LD_INT 1400
13324: PPUSH
13325: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13329: LD_ADDR_VAR 0 2
13333: PUSH
13334: LD_INT 1
13336: PPUSH
13337: LD_INT 1
13339: PPUSH
13340: CALL 60139 0 2
13344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13345: LD_ADDR_EXP 129
13349: PUSH
13350: LD_EXP 129
13354: PPUSH
13355: LD_INT 1
13357: PPUSH
13358: LD_EXP 129
13362: PUSH
13363: LD_INT 1
13365: ARRAY
13366: PUSH
13367: LD_VAR 0 2
13371: DIFF
13372: PPUSH
13373: CALL_OW 1
13377: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13378: LD_ADDR_VAR 0 3
13382: PUSH
13383: LD_INT 0
13385: PPUSH
13386: LD_INT 1
13388: PPUSH
13389: CALL_OW 12
13393: ST_TO_ADDR
// if target then
13394: LD_VAR 0 3
13398: IFFALSE 13564
// begin for i in tmp do
13400: LD_ADDR_VAR 0 1
13404: PUSH
13405: LD_VAR 0 2
13409: PUSH
13410: FOR_IN
13411: IFFALSE 13436
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13413: LD_VAR 0 1
13417: PPUSH
13418: LD_INT 179
13420: PPUSH
13421: LD_INT 209
13423: PPUSH
13424: LD_INT 8
13426: PPUSH
13427: LD_INT 1
13429: PPUSH
13430: CALL_OW 483
13434: GO 13410
13436: POP
13437: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13438: LD_ADDR_VAR 0 2
13442: PUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: LD_INT 24
13450: PUSH
13451: LD_INT 250
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: PPUSH
13458: CALL_OW 72
13462: ST_TO_ADDR
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13514
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13476: LD_VAR 0 1
13480: PPUSH
13481: LD_INT 179
13483: PPUSH
13484: LD_INT 209
13486: PPUSH
13487: CALL_OW 297
13491: PUSH
13492: LD_INT 9
13494: GREATER
13495: IFFALSE 13512
// ComMoveXY ( i , 179 , 209 ) ;
13497: LD_VAR 0 1
13501: PPUSH
13502: LD_INT 179
13504: PPUSH
13505: LD_INT 209
13507: PPUSH
13508: CALL_OW 111
13512: GO 13473
13514: POP
13515: POP
// wait ( 0 0$1 ) ;
13516: LD_INT 35
13518: PPUSH
13519: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13523: LD_VAR 0 2
13527: PPUSH
13528: LD_INT 92
13530: PUSH
13531: LD_INT 179
13533: PUSH
13534: LD_INT 209
13536: PUSH
13537: LD_INT 9
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: LIST
13544: LIST
13545: PPUSH
13546: CALL_OW 72
13550: PUSH
13551: LD_VAR 0 2
13555: PUSH
13556: LD_INT 1
13558: MINUS
13559: GREATEREQUAL
13560: IFFALSE 13438
// end else
13562: GO 13726
// begin for i in tmp do
13564: LD_ADDR_VAR 0 1
13568: PUSH
13569: LD_VAR 0 2
13573: PUSH
13574: FOR_IN
13575: IFFALSE 13600
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: LD_INT 285
13584: PPUSH
13585: LD_INT 163
13587: PPUSH
13588: LD_INT 8
13590: PPUSH
13591: LD_INT 1
13593: PPUSH
13594: CALL_OW 483
13598: GO 13574
13600: POP
13601: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13602: LD_ADDR_VAR 0 2
13606: PUSH
13607: LD_VAR 0 2
13611: PPUSH
13612: LD_INT 24
13614: PUSH
13615: LD_INT 250
13617: PUSH
13618: EMPTY
13619: LIST
13620: LIST
13621: PPUSH
13622: CALL_OW 72
13626: ST_TO_ADDR
// for i in tmp do
13627: LD_ADDR_VAR 0 1
13631: PUSH
13632: LD_VAR 0 2
13636: PUSH
13637: FOR_IN
13638: IFFALSE 13678
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13640: LD_VAR 0 1
13644: PPUSH
13645: LD_INT 285
13647: PPUSH
13648: LD_INT 163
13650: PPUSH
13651: CALL_OW 297
13655: PUSH
13656: LD_INT 9
13658: GREATER
13659: IFFALSE 13676
// ComMoveXY ( i , 285 , 163 ) ;
13661: LD_VAR 0 1
13665: PPUSH
13666: LD_INT 285
13668: PPUSH
13669: LD_INT 163
13671: PPUSH
13672: CALL_OW 111
13676: GO 13637
13678: POP
13679: POP
// wait ( 0 0$1 ) ;
13680: LD_INT 35
13682: PPUSH
13683: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13687: LD_VAR 0 2
13691: PPUSH
13692: LD_INT 92
13694: PUSH
13695: LD_INT 285
13697: PUSH
13698: LD_INT 163
13700: PUSH
13701: LD_INT 9
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: PPUSH
13710: CALL_OW 72
13714: PUSH
13715: LD_VAR 0 2
13719: PUSH
13720: LD_INT 1
13722: MINUS
13723: GREATEREQUAL
13724: IFFALSE 13602
// end ; repeat wait ( 0 0$1 ) ;
13726: LD_INT 35
13728: PPUSH
13729: CALL_OW 67
// for i in tmp do
13733: LD_ADDR_VAR 0 1
13737: PUSH
13738: LD_VAR 0 2
13742: PUSH
13743: FOR_IN
13744: IFFALSE 13866
// if GetLives ( i ) > 251 then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 256
13755: PUSH
13756: LD_INT 251
13758: GREATER
13759: IFFALSE 13848
// begin if GetWeapon ( i ) = ru_time_lapser then
13761: LD_VAR 0 1
13765: PPUSH
13766: CALL_OW 264
13770: PUSH
13771: LD_INT 49
13773: EQUAL
13774: IFFALSE 13812
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13776: LD_VAR 0 1
13780: PPUSH
13781: LD_INT 81
13783: PUSH
13784: LD_INT 7
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PPUSH
13791: CALL_OW 69
13795: PPUSH
13796: LD_VAR 0 1
13800: PPUSH
13801: CALL_OW 74
13805: PPUSH
13806: CALL_OW 112
13810: GO 13846
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13812: LD_VAR 0 1
13816: PPUSH
13817: LD_INT 81
13819: PUSH
13820: LD_INT 7
13822: PUSH
13823: EMPTY
13824: LIST
13825: LIST
13826: PPUSH
13827: CALL_OW 69
13831: PPUSH
13832: LD_VAR 0 1
13836: PPUSH
13837: CALL_OW 74
13841: PPUSH
13842: CALL_OW 115
// end else
13846: GO 13864
// tmp := tmp diff i ;
13848: LD_ADDR_VAR 0 2
13852: PUSH
13853: LD_VAR 0 2
13857: PUSH
13858: LD_VAR 0 1
13862: DIFF
13863: ST_TO_ADDR
13864: GO 13743
13866: POP
13867: POP
// until not tmp ;
13868: LD_VAR 0 2
13872: NOT
13873: IFFALSE 13726
// end ; end_of_file
13875: PPOPN 4
13877: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13878: LD_INT 0
13880: PPUSH
13881: PPUSH
13882: PPUSH
13883: PPUSH
// missionStage := 13 ;
13884: LD_ADDR_EXP 15
13888: PUSH
13889: LD_INT 13
13891: ST_TO_ADDR
// uc_side := 2 ;
13892: LD_ADDR_OWVAR 20
13896: PUSH
13897: LD_INT 2
13899: ST_TO_ADDR
// uc_nation := 2 ;
13900: LD_ADDR_OWVAR 21
13904: PUSH
13905: LD_INT 2
13907: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13908: LD_ADDR_EXP 92
13912: PUSH
13913: LD_STRING Omar
13915: PPUSH
13916: CALL_OW 25
13920: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13921: LD_EXP 92
13925: PPUSH
13926: LD_INT 4
13928: PPUSH
13929: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13933: LD_EXP 92
13937: PPUSH
13938: LD_INT 242
13940: PPUSH
13941: LD_INT 75
13943: PPUSH
13944: LD_INT 0
13946: PPUSH
13947: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13951: LD_ADDR_EXP 93
13955: PUSH
13956: LD_STRING Heike
13958: PPUSH
13959: CALL_OW 25
13963: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13964: LD_INT 14
13966: PPUSH
13967: LD_INT 3
13969: PPUSH
13970: LD_INT 1
13972: PPUSH
13973: LD_INT 27
13975: PPUSH
13976: LD_INT 100
13978: PPUSH
13979: CALL 69889 0 5
// veh := CreateVehicle ;
13983: LD_ADDR_VAR 0 3
13987: PUSH
13988: CALL_OW 45
13992: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13993: LD_VAR 0 3
13997: PPUSH
13998: LD_INT 1
14000: PPUSH
14001: CALL_OW 242
// SetDir ( veh , 4 ) ;
14005: LD_VAR 0 3
14009: PPUSH
14010: LD_INT 4
14012: PPUSH
14013: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14017: LD_VAR 0 3
14021: PPUSH
14022: LD_INT 241
14024: PPUSH
14025: LD_INT 72
14027: PPUSH
14028: LD_INT 0
14030: PPUSH
14031: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14035: LD_EXP 93
14039: PPUSH
14040: LD_VAR 0 3
14044: PPUSH
14045: CALL_OW 52
// if KhatamStatus then
14049: LD_EXP 8
14053: IFFALSE 14104
// begin Khatam := NewCharacter ( Khatam ) ;
14055: LD_ADDR_EXP 94
14059: PUSH
14060: LD_STRING Khatam
14062: PPUSH
14063: CALL_OW 25
14067: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14068: LD_EXP 94
14072: PPUSH
14073: LD_INT 245
14075: PPUSH
14076: LD_INT 78
14078: PPUSH
14079: LD_INT 3
14081: PPUSH
14082: LD_INT 0
14084: PPUSH
14085: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14089: LD_EXP 94
14093: PPUSH
14094: LD_INT 4
14096: PPUSH
14097: LD_INT 10
14099: PPUSH
14100: CALL_OW 237
// end ; for i = 1 to Difficulty do
14104: LD_ADDR_VAR 0 2
14108: PUSH
14109: DOUBLE
14110: LD_INT 1
14112: DEC
14113: ST_TO_ADDR
14114: LD_OWVAR 67
14118: PUSH
14119: FOR_TO
14120: IFFALSE 14186
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14122: LD_INT 0
14124: PPUSH
14125: LD_INT 7
14127: PUSH
14128: LD_OWVAR 67
14132: PLUS
14133: PPUSH
14134: CALL_OW 384
// un := CreateHuman ;
14138: LD_ADDR_VAR 0 4
14142: PUSH
14143: CALL_OW 44
14147: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14148: LD_VAR 0 4
14152: PPUSH
14153: LD_INT 28
14155: PUSH
14156: LD_INT 29
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: PUSH
14163: LD_VAR 0 2
14167: PUSH
14168: LD_INT 2
14170: MOD
14171: PUSH
14172: LD_INT 1
14174: PLUS
14175: ARRAY
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 49
// end ;
14184: GO 14119
14186: POP
14187: POP
// for i = 1 to 6 do
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: DOUBLE
14194: LD_INT 1
14196: DEC
14197: ST_TO_ADDR
14198: LD_INT 6
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14247
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14204: LD_INT 0
14206: PPUSH
14207: LD_INT 7
14209: PUSH
14210: LD_OWVAR 67
14214: PLUS
14215: PPUSH
14216: CALL_OW 381
// un := CreateHuman ;
14220: LD_ADDR_VAR 0 4
14224: PUSH
14225: CALL_OW 44
14229: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14230: LD_VAR 0 4
14234: PPUSH
14235: LD_INT 28
14237: PPUSH
14238: LD_INT 0
14240: PPUSH
14241: CALL_OW 49
// end ;
14245: GO 14201
14247: POP
14248: POP
// for i = 1 to 3 do
14249: LD_ADDR_VAR 0 2
14253: PUSH
14254: DOUBLE
14255: LD_INT 1
14257: DEC
14258: ST_TO_ADDR
14259: LD_INT 3
14261: PUSH
14262: FOR_TO
14263: IFFALSE 14311
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14265: LD_INT 0
14267: PPUSH
14268: LD_INT 8
14270: PPUSH
14271: LD_INT 7
14273: PUSH
14274: LD_OWVAR 67
14278: PLUS
14279: PPUSH
14280: CALL_OW 380
// un := CreateHuman ;
14284: LD_ADDR_VAR 0 4
14288: PUSH
14289: CALL_OW 44
14293: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14294: LD_VAR 0 4
14298: PPUSH
14299: LD_INT 28
14301: PPUSH
14302: LD_INT 0
14304: PPUSH
14305: CALL_OW 49
// end ;
14309: GO 14262
14311: POP
14312: POP
// for i = 1 to 3 do
14313: LD_ADDR_VAR 0 2
14317: PUSH
14318: DOUBLE
14319: LD_INT 1
14321: DEC
14322: ST_TO_ADDR
14323: LD_INT 3
14325: PUSH
14326: FOR_TO
14327: IFFALSE 14417
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14329: LD_INT 14
14331: PPUSH
14332: LD_INT 2
14334: PPUSH
14335: LD_INT 1
14337: PPUSH
14338: LD_INT 28
14340: PPUSH
14341: LD_INT 80
14343: PPUSH
14344: CALL 69889 0 5
// veh := CreateVehicle ;
14348: LD_ADDR_VAR 0 3
14352: PUSH
14353: CALL_OW 45
14357: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14358: LD_VAR 0 3
14362: PPUSH
14363: LD_INT 3
14365: PPUSH
14366: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14370: LD_VAR 0 3
14374: PPUSH
14375: LD_INT 29
14377: PPUSH
14378: LD_INT 0
14380: PPUSH
14381: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14385: LD_INT 0
14387: PPUSH
14388: LD_INT 7
14390: PUSH
14391: LD_OWVAR 67
14395: PLUS
14396: PPUSH
14397: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14401: CALL_OW 44
14405: PPUSH
14406: LD_VAR 0 3
14410: PPUSH
14411: CALL_OW 52
// end ;
14415: GO 14326
14417: POP
14418: POP
// for i = 1 to 5 + Difficulty do
14419: LD_ADDR_VAR 0 2
14423: PUSH
14424: DOUBLE
14425: LD_INT 1
14427: DEC
14428: ST_TO_ADDR
14429: LD_INT 5
14431: PUSH
14432: LD_OWVAR 67
14436: PLUS
14437: PUSH
14438: FOR_TO
14439: IFFALSE 14566
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14441: LD_INT 14
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: LD_INT 3
14449: PPUSH
14450: CALL_OW 12
14454: PPUSH
14455: LD_INT 1
14457: PPUSH
14458: LD_INT 28
14460: PUSH
14461: LD_INT 26
14463: PUSH
14464: LD_INT 27
14466: PUSH
14467: LD_INT 25
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: PUSH
14476: LD_VAR 0 2
14480: PUSH
14481: LD_INT 4
14483: MOD
14484: PUSH
14485: LD_INT 1
14487: PLUS
14488: ARRAY
14489: PPUSH
14490: LD_INT 80
14492: PPUSH
14493: CALL 69889 0 5
// veh := CreateVehicle ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: CALL_OW 45
14506: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14507: LD_VAR 0 3
14511: PPUSH
14512: LD_INT 4
14514: PPUSH
14515: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14519: LD_VAR 0 3
14523: PPUSH
14524: LD_INT 28
14526: PPUSH
14527: LD_INT 0
14529: PPUSH
14530: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14534: LD_INT 0
14536: PPUSH
14537: LD_INT 7
14539: PUSH
14540: LD_OWVAR 67
14544: PLUS
14545: PPUSH
14546: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14550: CALL_OW 44
14554: PPUSH
14555: LD_VAR 0 3
14559: PPUSH
14560: CALL_OW 52
// end ;
14564: GO 14438
14566: POP
14567: POP
// for i = 1 to 3 do
14568: LD_ADDR_VAR 0 2
14572: PUSH
14573: DOUBLE
14574: LD_INT 1
14576: DEC
14577: ST_TO_ADDR
14578: LD_INT 3
14580: PUSH
14581: FOR_TO
14582: IFFALSE 14642
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14584: LD_INT 14
14586: PPUSH
14587: LD_INT 3
14589: PPUSH
14590: LD_INT 5
14592: PPUSH
14593: LD_INT 29
14595: PPUSH
14596: LD_INT 80
14598: PPUSH
14599: CALL 69889 0 5
// veh := CreateVehicle ;
14603: LD_ADDR_VAR 0 3
14607: PUSH
14608: CALL_OW 45
14612: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14613: LD_VAR 0 3
14617: PPUSH
14618: LD_INT 4
14620: PPUSH
14621: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14625: LD_VAR 0 3
14629: PPUSH
14630: LD_INT 28
14632: PPUSH
14633: LD_INT 0
14635: PPUSH
14636: CALL_OW 49
// end ;
14640: GO 14581
14642: POP
14643: POP
// end ;
14644: LD_VAR 0 1
14648: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14649: LD_INT 22
14651: PUSH
14652: LD_INT 2
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: PPUSH
14659: CALL_OW 69
14663: IFFALSE 14963
14665: GO 14667
14667: DISABLE
14668: LD_INT 0
14670: PPUSH
14671: PPUSH
14672: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 22
14680: PUSH
14681: LD_INT 2
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: PUSH
14688: LD_INT 25
14690: PUSH
14691: LD_INT 4
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: EMPTY
14699: LIST
14700: LIST
14701: PPUSH
14702: CALL_OW 69
14706: PUSH
14707: LD_EXP 94
14711: DIFF
14712: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14713: LD_ADDR_VAR 0 2
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 2
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PPUSH
14728: CALL_OW 69
14732: PUSH
14733: LD_EXP 94
14737: PUSH
14738: LD_VAR 0 3
14742: UNION
14743: DIFF
14744: ST_TO_ADDR
// if Khatam then
14745: LD_EXP 94
14749: IFFALSE 14766
// ComMoveXY ( Khatam , 211 , 92 ) ;
14751: LD_EXP 94
14755: PPUSH
14756: LD_INT 211
14758: PPUSH
14759: LD_INT 92
14761: PPUSH
14762: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14766: LD_INT 197
14768: PPUSH
14769: LD_INT 80
14771: PPUSH
14772: LD_INT 2
14774: PPUSH
14775: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14779: LD_INT 213
14781: PPUSH
14782: LD_INT 90
14784: PPUSH
14785: LD_INT 2
14787: PPUSH
14788: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14792: LD_INT 215
14794: PPUSH
14795: LD_INT 129
14797: PPUSH
14798: LD_INT 2
14800: PPUSH
14801: CALL_OW 441
// if sci then
14805: LD_VAR 0 3
14809: IFFALSE 14830
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14811: LD_VAR 0 3
14815: PUSH
14816: LD_INT 1
14818: ARRAY
14819: PPUSH
14820: LD_INT 197
14822: PPUSH
14823: LD_INT 80
14825: PPUSH
14826: CALL_OW 158
// if sci > 1 then
14830: LD_VAR 0 3
14834: PUSH
14835: LD_INT 1
14837: GREATER
14838: IFFALSE 14859
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14840: LD_VAR 0 3
14844: PUSH
14845: LD_INT 2
14847: ARRAY
14848: PPUSH
14849: LD_INT 213
14851: PPUSH
14852: LD_INT 90
14854: PPUSH
14855: CALL_OW 158
// if sci > 2 then
14859: LD_VAR 0 3
14863: PUSH
14864: LD_INT 2
14866: GREATER
14867: IFFALSE 14888
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14869: LD_VAR 0 3
14873: PUSH
14874: LD_INT 3
14876: ARRAY
14877: PPUSH
14878: LD_INT 215
14880: PPUSH
14881: LD_INT 129
14883: PPUSH
14884: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14888: LD_INT 35
14890: PPUSH
14891: CALL_OW 67
// for i in tmp do
14895: LD_ADDR_VAR 0 1
14899: PUSH
14900: LD_VAR 0 2
14904: PUSH
14905: FOR_IN
14906: IFFALSE 14944
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14908: LD_VAR 0 1
14912: PPUSH
14913: LD_INT 81
14915: PUSH
14916: LD_INT 2
14918: PUSH
14919: EMPTY
14920: LIST
14921: LIST
14922: PPUSH
14923: CALL_OW 69
14927: PPUSH
14928: LD_VAR 0 1
14932: PPUSH
14933: CALL_OW 74
14937: PPUSH
14938: CALL_OW 115
14942: GO 14905
14944: POP
14945: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14946: LD_INT 22
14948: PUSH
14949: LD_INT 2
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: CALL_OW 69
14960: NOT
14961: IFFALSE 14888
// end ; end_of_file
14963: PPOPN 3
14965: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14966: LD_INT 0
14968: PPUSH
14969: PPUSH
14970: PPUSH
14971: PPUSH
14972: PPUSH
14973: PPUSH
14974: PPUSH
14975: PPUSH
14976: PPUSH
// Video ( true ) ;
14977: LD_INT 1
14979: PPUSH
14980: CALL 100907 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14984: LD_ADDR_VAR 0 5
14988: PUSH
14989: LD_INT 7
14991: PPUSH
14992: LD_INT 0
14994: PPUSH
14995: CALL_OW 517
14999: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15000: LD_ADDR_VAR 0 2
15004: PUSH
15005: DOUBLE
15006: LD_INT 1
15008: DEC
15009: ST_TO_ADDR
15010: LD_VAR 0 5
15014: PUSH
15015: LD_INT 1
15017: ARRAY
15018: PUSH
15019: FOR_TO
15020: IFFALSE 15065
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_VAR 0 5
15041: PUSH
15042: LD_INT 2
15044: ARRAY
15045: PUSH
15046: LD_VAR 0 2
15050: ARRAY
15051: PPUSH
15052: LD_INT 1
15054: PPUSH
15055: LD_INT 15
15057: NEG
15058: PPUSH
15059: CALL 100821 0 4
15063: GO 15019
15065: POP
15066: POP
// CenterNowOnUnits ( Powell ) ;
15067: LD_EXP 58
15071: PPUSH
15072: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15076: LD_ADDR_VAR 0 5
15080: PUSH
15081: LD_EXP 56
15085: PUSH
15086: EMPTY
15087: LIST
15088: ST_TO_ADDR
// if GirlNewVeh then
15089: LD_EXP 57
15093: IFFALSE 15111
// tmp := tmp ^ GirlNewVeh ;
15095: LD_ADDR_VAR 0 5
15099: PUSH
15100: LD_VAR 0 5
15104: PUSH
15105: LD_EXP 57
15109: ADD
15110: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15111: LD_VAR 0 5
15115: PPUSH
15116: LD_INT 60
15118: PPUSH
15119: LD_INT 109
15121: PPUSH
15122: CALL_OW 111
// if KappaStatus then
15126: LD_EXP 2
15130: IFFALSE 15182
// begin Say ( JMM , D1nT-JMM-1 ) ;
15132: LD_EXP 39
15136: PPUSH
15137: LD_STRING D1nT-JMM-1
15139: PPUSH
15140: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15144: LD_EXP 58
15148: PPUSH
15149: LD_STRING D1T-Pow-1
15151: PPUSH
15152: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15156: LD_EXP 39
15160: PPUSH
15161: LD_STRING D1T-JMM-2
15163: PPUSH
15164: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15168: LD_EXP 58
15172: PPUSH
15173: LD_STRING D1T-Pow-2
15175: PPUSH
15176: CALL_OW 88
// end else
15180: GO 15388
// if JMMGirlStatus then
15182: LD_EXP 6
15186: IFFALSE 15331
// begin Say ( JMM , D1T-JMM-1 ) ;
15188: LD_EXP 39
15192: PPUSH
15193: LD_STRING D1T-JMM-1
15195: PPUSH
15196: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15200: LD_EXP 58
15204: PPUSH
15205: LD_STRING D1T-Pow-1
15207: PPUSH
15208: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15212: LD_EXP 39
15216: PPUSH
15217: LD_STRING D1T-JMM-3
15219: PPUSH
15220: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15224: LD_EXP 58
15228: PPUSH
15229: LD_STRING D1T-Pow-3
15231: PPUSH
15232: CALL_OW 88
// if JMMGirl then
15236: LD_EXP 7
15240: IFFALSE 15329
// begin case JMMGirl of 1 :
15242: LD_EXP 7
15246: PUSH
15247: LD_INT 1
15249: DOUBLE
15250: EQUAL
15251: IFTRUE 15255
15253: GO 15270
15255: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15256: LD_EXP 40
15260: PPUSH
15261: LD_STRING D1T-Joan-3
15263: PPUSH
15264: CALL_OW 88
15268: GO 15317
15270: LD_INT 2
15272: DOUBLE
15273: EQUAL
15274: IFTRUE 15278
15276: GO 15293
15278: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15279: LD_EXP 42
15283: PPUSH
15284: LD_STRING D1T-Lisa-3
15286: PPUSH
15287: CALL_OW 88
15291: GO 15317
15293: LD_INT 3
15295: DOUBLE
15296: EQUAL
15297: IFTRUE 15301
15299: GO 15316
15301: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15302: LD_EXP 54
15306: PPUSH
15307: LD_STRING D1T-Con-3
15309: PPUSH
15310: CALL_OW 88
15314: GO 15317
15316: POP
// Say ( Powell , D1T-Pow-4 ) ;
15317: LD_EXP 58
15321: PPUSH
15322: LD_STRING D1T-Pow-4
15324: PPUSH
15325: CALL_OW 88
// end ; end else
15329: GO 15388
// if not FastEnd then
15331: LD_EXP 11
15335: NOT
15336: IFFALSE 15364
// begin Say ( JMM , D1T-JMM-4 ) ;
15338: LD_EXP 39
15342: PPUSH
15343: LD_STRING D1T-JMM-4
15345: PPUSH
15346: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15350: LD_EXP 58
15354: PPUSH
15355: LD_STRING D1T-Pow-5
15357: PPUSH
15358: CALL_OW 88
// end else
15362: GO 15388
// begin Say ( JMM , D1nT-JMM-1 ) ;
15364: LD_EXP 39
15368: PPUSH
15369: LD_STRING D1nT-JMM-1
15371: PPUSH
15372: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15376: LD_EXP 58
15380: PPUSH
15381: LD_STRING D1nT-Pow-1
15383: PPUSH
15384: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15388: LD_INT 35
15390: PPUSH
15391: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15395: LD_EXP 56
15399: PPUSH
15400: CALL_OW 314
15404: NOT
15405: IFFALSE 15388
// ComExitVehicle ( JMM ) ;
15407: LD_EXP 39
15411: PPUSH
15412: CALL_OW 121
// wait ( 3 ) ;
15416: LD_INT 3
15418: PPUSH
15419: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_INT 60
15430: PPUSH
15431: LD_INT 94
15433: PPUSH
15434: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15438: LD_EXP 39
15442: PPUSH
15443: LD_EXP 58
15447: PPUSH
15448: CALL_OW 179
// if Joan then
15452: LD_EXP 40
15456: IFFALSE 15510
// begin ComExitVehicle ( Joan ) ;
15458: LD_EXP 40
15462: PPUSH
15463: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15467: LD_EXP 40
15471: PPUSH
15472: LD_INT 35
15474: PPUSH
15475: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_INT 65
15486: PPUSH
15487: LD_INT 104
15489: PPUSH
15490: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15494: LD_EXP 40
15498: PPUSH
15499: LD_EXP 39
15503: PPUSH
15504: CALL_OW 179
// end else
15508: GO 15644
// if Lisa and JMMGirl = 2 then
15510: LD_EXP 42
15514: PUSH
15515: LD_EXP 7
15519: PUSH
15520: LD_INT 2
15522: EQUAL
15523: AND
15524: IFFALSE 15578
// begin ComExitVehicle ( Lisa ) ;
15526: LD_EXP 42
15530: PPUSH
15531: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15535: LD_EXP 42
15539: PPUSH
15540: LD_INT 35
15542: PPUSH
15543: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_INT 65
15554: PPUSH
15555: LD_INT 104
15557: PPUSH
15558: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15562: LD_EXP 42
15566: PPUSH
15567: LD_EXP 39
15571: PPUSH
15572: CALL_OW 179
// end else
15576: GO 15644
// if Connie and JMMGirl = 3 then
15578: LD_EXP 54
15582: PUSH
15583: LD_EXP 7
15587: PUSH
15588: LD_INT 3
15590: EQUAL
15591: AND
15592: IFFALSE 15644
// begin ComExitVehicle ( Connie ) ;
15594: LD_EXP 54
15598: PPUSH
15599: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15603: LD_EXP 54
15607: PPUSH
15608: LD_INT 35
15610: PPUSH
15611: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_INT 65
15622: PPUSH
15623: LD_INT 104
15625: PPUSH
15626: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15630: LD_EXP 54
15634: PPUSH
15635: LD_EXP 39
15639: PPUSH
15640: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15644: LD_INT 35
15646: PPUSH
15647: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15651: LD_EXP 39
15655: PPUSH
15656: LD_EXP 58
15660: PPUSH
15661: CALL_OW 296
15665: PUSH
15666: LD_INT 6
15668: LESS
15669: IFFALSE 15644
// wait ( 0 0$0.5 ) ;
15671: LD_INT 18
15673: PPUSH
15674: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15678: LD_EXP 39
15682: PPUSH
15683: LD_STRING D1-JMM-1
15685: PPUSH
15686: CALL_OW 88
// async ;
15690: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15691: LD_EXP 58
15695: PPUSH
15696: LD_STRING D1-Pow-1
15698: PPUSH
15699: CALL_OW 88
// if not dialogue_skipped then
15703: LD_OWVAR 59
15707: NOT
15708: IFFALSE 15717
// wait ( 0 0$2 ) ;
15710: LD_INT 70
15712: PPUSH
15713: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15717: LD_INT 170
15719: PPUSH
15720: LD_INT 99
15722: PPUSH
15723: LD_INT 1
15725: PPUSH
15726: LD_INT 6
15728: NEG
15729: PPUSH
15730: CALL 100821 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15734: LD_INT 174
15736: PPUSH
15737: LD_INT 115
15739: PPUSH
15740: LD_INT 1
15742: PPUSH
15743: LD_INT 6
15745: NEG
15746: PPUSH
15747: CALL 100821 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15751: LD_INT 169
15753: PPUSH
15754: LD_INT 71
15756: PPUSH
15757: LD_INT 1
15759: PPUSH
15760: LD_INT 6
15762: NEG
15763: PPUSH
15764: CALL 100821 0 4
// if not dialogue_skipped then
15768: LD_OWVAR 59
15772: NOT
15773: IFFALSE 15792
// begin CenterOnXY ( 170 , 99 ) ;
15775: LD_INT 170
15777: PPUSH
15778: LD_INT 99
15780: PPUSH
15781: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15785: LD_INT 80
15787: PPUSH
15788: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15792: LD_INT 75
15794: PPUSH
15795: LD_INT 53
15797: PPUSH
15798: LD_INT 1
15800: PPUSH
15801: LD_INT 9
15803: NEG
15804: PPUSH
15805: CALL 100821 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15809: LD_INT 54
15811: PPUSH
15812: LD_INT 42
15814: PPUSH
15815: LD_INT 1
15817: PPUSH
15818: LD_INT 9
15820: NEG
15821: PPUSH
15822: CALL 100821 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15826: LD_INT 62
15828: PPUSH
15829: LD_INT 51
15831: PPUSH
15832: LD_INT 1
15834: PPUSH
15835: LD_INT 9
15837: NEG
15838: PPUSH
15839: CALL 100821 0 4
// if not dialogue_skipped then
15843: LD_OWVAR 59
15847: NOT
15848: IFFALSE 15867
// begin CenterOnXY ( 75 , 53 ) ;
15850: LD_INT 75
15852: PPUSH
15853: LD_INT 53
15855: PPUSH
15856: CALL_OW 84
// wait ( 0 0$4 ) ;
15860: LD_INT 140
15862: PPUSH
15863: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15867: LD_EXP 58
15871: PPUSH
15872: CALL_OW 87
// if not dialogue_skipped then
15876: LD_OWVAR 59
15880: NOT
15881: IFFALSE 15890
// wait ( 0 0$2 ) ;
15883: LD_INT 70
15885: PPUSH
15886: CALL_OW 67
// sync ;
15890: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15891: LD_EXP 39
15895: PPUSH
15896: LD_STRING D1-JMM-2
15898: PPUSH
15899: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15903: LD_EXP 58
15907: PPUSH
15908: LD_STRING D1-Pow-2
15910: PPUSH
15911: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15915: LD_EXP 39
15919: PPUSH
15920: LD_STRING D1-JMM-3
15922: PPUSH
15923: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15927: LD_EXP 58
15931: PPUSH
15932: LD_STRING D1-Pow-3
15934: PPUSH
15935: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15939: LD_EXP 39
15943: PPUSH
15944: LD_STRING D1-JMM-4
15946: PPUSH
15947: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15951: LD_EXP 58
15955: PPUSH
15956: LD_STRING D1-Pow-4
15958: PPUSH
15959: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15963: LD_EXP 39
15967: PPUSH
15968: LD_STRING D1-JMM-5
15970: PPUSH
15971: CALL_OW 88
// async ;
15975: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-5
15983: PPUSH
15984: CALL_OW 88
// if not dialogue_skipped then
15988: LD_OWVAR 59
15992: NOT
15993: IFFALSE 16002
// wait ( 0 0$3.6 ) ;
15995: LD_INT 126
15997: PPUSH
15998: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16002: LD_INT 134
16004: PPUSH
16005: LD_INT 210
16007: PPUSH
16008: LD_INT 1
16010: PPUSH
16011: LD_INT 11
16013: NEG
16014: PPUSH
16015: CALL 100821 0 4
// if not dialogue_skipped then
16019: LD_OWVAR 59
16023: NOT
16024: IFFALSE 16043
// begin CenterOnXY ( 134 , 210 ) ;
16026: LD_INT 134
16028: PPUSH
16029: LD_INT 210
16031: PPUSH
16032: CALL_OW 84
// wait ( 0 0$2 ) ;
16036: LD_INT 70
16038: PPUSH
16039: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16043: LD_INT 101
16045: PPUSH
16046: LD_INT 159
16048: PPUSH
16049: LD_INT 1
16051: PPUSH
16052: LD_INT 10
16054: NEG
16055: PPUSH
16056: CALL 100821 0 4
// if not dialogue_skipped then
16060: LD_OWVAR 59
16064: NOT
16065: IFFALSE 16084
// begin CenterOnXY ( 101 , 159 ) ;
16067: LD_INT 101
16069: PPUSH
16070: LD_INT 159
16072: PPUSH
16073: CALL_OW 84
// wait ( 0 0$2 ) ;
16077: LD_INT 70
16079: PPUSH
16080: CALL_OW 67
// end ; sync ;
16084: SYNC
// CenterNowOnUnits ( Powell ) ;
16085: LD_EXP 58
16089: PPUSH
16090: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_INT 1
16101: PUSH
16102: LD_INT 2
16104: PUSH
16105: LD_INT 3
16107: PUSH
16108: LD_INT 4
16110: PUSH
16111: LD_INT 5
16113: PUSH
16114: LD_INT 6
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: LIST
16121: LIST
16122: LIST
16123: LIST
16124: ST_TO_ADDR
// if not dialogue_skipped then
16125: LD_OWVAR 59
16129: NOT
16130: IFFALSE 16299
// begin game_speed := 4 ;
16132: LD_ADDR_OWVAR 65
16136: PUSH
16137: LD_INT 4
16139: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16140: LD_INT 210
16142: PPUSH
16143: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16147: LD_ADDR_VAR 0 7
16151: PUSH
16152: LD_STRING Q1
16154: PPUSH
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 98
16164: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16165: LD_ADDR_VAR 0 7
16169: PUSH
16170: LD_STRING Q1
16172: PPUSH
16173: LD_VAR 0 6
16177: PPUSH
16178: CALL_OW 98
16182: ST_TO_ADDR
// options = options diff dec ;
16183: LD_ADDR_VAR 0 6
16187: PUSH
16188: LD_VAR 0 6
16192: PUSH
16193: LD_VAR 0 7
16197: DIFF
16198: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16199: LD_VAR 0 7
16203: PPUSH
16204: LD_VAR 0 6
16208: PPUSH
16209: CALL 17771 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16213: LD_VAR 0 7
16217: PUSH
16218: LD_INT 5
16220: PUSH
16221: LD_INT 6
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: IN
16228: PUSH
16229: LD_VAR 0 6
16233: PUSH
16234: LD_INT 2
16236: EQUAL
16237: OR
16238: IFFALSE 16165
// if not ( dec in [ 5 , 6 ] ) then
16240: LD_VAR 0 7
16244: PUSH
16245: LD_INT 5
16247: PUSH
16248: LD_INT 6
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: IN
16255: NOT
16256: IFFALSE 16299
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16258: LD_ADDR_VAR 0 7
16262: PUSH
16263: LD_STRING Q1a
16265: PPUSH
16266: LD_INT 1
16268: PUSH
16269: LD_INT 2
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PPUSH
16276: CALL_OW 98
16280: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16281: LD_VAR 0 7
16285: PUSH
16286: LD_INT 4
16288: PLUS
16289: PPUSH
16290: LD_VAR 0 6
16294: PPUSH
16295: CALL 17771 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16299: LD_INT 81
16301: PPUSH
16302: LD_INT 127
16304: PPUSH
16305: CALL_OW 84
// amount := 5 ;
16309: LD_ADDR_VAR 0 8
16313: PUSH
16314: LD_INT 5
16316: ST_TO_ADDR
// macmilan_squad := [ ] ;
16317: LD_ADDR_VAR 0 9
16321: PUSH
16322: EMPTY
16323: ST_TO_ADDR
// if vip < amount then
16324: LD_EXP 59
16328: PUSH
16329: LD_VAR 0 8
16333: LESS
16334: IFFALSE 16378
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16336: LD_ADDR_VAR 0 5
16340: PUSH
16341: LD_EXP 59
16345: PUSH
16346: LD_INT 22
16348: PUSH
16349: LD_INT 4
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: PUSH
16356: LD_INT 21
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: PPUSH
16370: CALL_OW 69
16374: UNION
16375: ST_TO_ADDR
16376: GO 16388
// tmp := vip ;
16378: LD_ADDR_VAR 0 5
16382: PUSH
16383: LD_EXP 59
16387: ST_TO_ADDR
// tmp := tmp diff Powell ;
16388: LD_ADDR_VAR 0 5
16392: PUSH
16393: LD_VAR 0 5
16397: PUSH
16398: LD_EXP 58
16402: DIFF
16403: ST_TO_ADDR
// if tmp < amount then
16404: LD_VAR 0 5
16408: PUSH
16409: LD_VAR 0 8
16413: LESS
16414: IFFALSE 16426
// amount := tmp ;
16416: LD_ADDR_VAR 0 8
16420: PUSH
16421: LD_VAR 0 5
16425: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16426: LD_VAR 0 5
16430: PUSH
16431: LD_INT 1
16433: ARRAY
16434: PPUSH
16435: CALL_OW 257
16439: PUSH
16440: LD_INT 2
16442: NONEQUAL
16443: IFFALSE 16505
// begin if IsInUnit ( tmp [ 1 ] ) then
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 310
16458: IFFALSE 16473
// ComExitBuilding ( tmp [ 1 ] ) ;
16460: LD_VAR 0 5
16464: PUSH
16465: LD_INT 1
16467: ARRAY
16468: PPUSH
16469: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16473: LD_VAR 0 5
16477: PUSH
16478: LD_INT 1
16480: ARRAY
16481: PPUSH
16482: LD_INT 387
16484: PPUSH
16485: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16489: LD_VAR 0 5
16493: PUSH
16494: LD_INT 1
16496: ARRAY
16497: PPUSH
16498: LD_INT 2
16500: PPUSH
16501: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_INT 82
16512: PPUSH
16513: LD_INT 129
16515: PPUSH
16516: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16520: LD_EXP 39
16524: PPUSH
16525: LD_EXP 58
16529: PPUSH
16530: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16534: LD_INT 22
16536: PUSH
16537: LD_INT 1
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PPUSH
16544: CALL_OW 69
16548: PUSH
16549: LD_EXP 39
16553: DIFF
16554: PPUSH
16555: LD_INT 84
16557: PPUSH
16558: LD_INT 128
16560: PPUSH
16561: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16565: LD_INT 22
16567: PUSH
16568: LD_INT 1
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL_OW 69
16579: PUSH
16580: LD_EXP 39
16584: DIFF
16585: PPUSH
16586: LD_EXP 39
16590: PPUSH
16591: CALL_OW 179
// for i = 1 to amount do
16595: LD_ADDR_VAR 0 2
16599: PUSH
16600: DOUBLE
16601: LD_INT 1
16603: DEC
16604: ST_TO_ADDR
16605: LD_VAR 0 8
16609: PUSH
16610: FOR_TO
16611: IFFALSE 16779
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16613: LD_ADDR_VAR 0 9
16617: PUSH
16618: LD_VAR 0 9
16622: PUSH
16623: LD_VAR 0 5
16627: PUSH
16628: LD_VAR 0 2
16632: ARRAY
16633: ADD
16634: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16635: LD_VAR 0 5
16639: PUSH
16640: LD_VAR 0 2
16644: ARRAY
16645: PPUSH
16646: CALL_OW 310
16650: IFFALSE 16667
// AddComExitBuilding ( tmp [ i ] ) ;
16652: LD_VAR 0 5
16656: PUSH
16657: LD_VAR 0 2
16661: ARRAY
16662: PPUSH
16663: CALL_OW 182
// if i = 2 and JMMNewVeh then
16667: LD_VAR 0 2
16671: PUSH
16672: LD_INT 2
16674: EQUAL
16675: PUSH
16676: LD_EXP 56
16680: AND
16681: IFFALSE 16739
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16683: LD_VAR 0 5
16687: PUSH
16688: LD_VAR 0 2
16692: ARRAY
16693: PPUSH
16694: LD_EXP 56
16698: PPUSH
16699: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16703: LD_VAR 0 5
16707: PUSH
16708: LD_VAR 0 2
16712: ARRAY
16713: PPUSH
16714: LD_INT 86
16716: PPUSH
16717: LD_INT 133
16719: PPUSH
16720: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16739: LD_VAR 0 5
16743: PUSH
16744: LD_VAR 0 2
16748: ARRAY
16749: PPUSH
16750: LD_INT 8
16752: PPUSH
16753: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16757: LD_VAR 0 5
16761: PUSH
16762: LD_VAR 0 2
16766: ARRAY
16767: PPUSH
16768: LD_EXP 39
16772: PPUSH
16773: CALL_OW 179
// end ;
16777: GO 16610
16779: POP
16780: POP
// if GirlNewVeh then
16781: LD_EXP 57
16785: IFFALSE 16799
// SetSide ( GirlNewVeh , 4 ) ;
16787: LD_EXP 57
16791: PPUSH
16792: LD_INT 4
16794: PPUSH
16795: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16799: LD_INT 35
16801: PPUSH
16802: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16806: LD_VAR 0 9
16810: PPUSH
16811: LD_INT 95
16813: PUSH
16814: LD_INT 9
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PPUSH
16821: CALL_OW 72
16825: PUSH
16826: LD_INT 0
16828: EQUAL
16829: PUSH
16830: LD_EXP 39
16834: PPUSH
16835: LD_INT 9
16837: PPUSH
16838: CALL_OW 308
16842: NOT
16843: AND
16844: IFFALSE 16799
// wait ( 0 0$2 ) ;
16846: LD_INT 70
16848: PPUSH
16849: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16853: LD_VAR 0 9
16857: PPUSH
16858: LD_INT 1
16860: PPUSH
16861: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16865: LD_INT 21
16867: PUSH
16868: LD_INT 2
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 92
16877: PUSH
16878: LD_INT 83
16880: PUSH
16881: LD_INT 130
16883: PUSH
16884: LD_INT 10
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 69
16901: PPUSH
16902: LD_INT 1
16904: PPUSH
16905: CALL_OW 235
// Video ( false ) ;
16909: LD_INT 0
16911: PPUSH
16912: CALL 100907 0 1
// ChangeMissionObjectives ( M1 ) ;
16916: LD_STRING M1
16918: PPUSH
16919: CALL_OW 337
// SaveForQuickRestart ;
16923: CALL_OW 22
// missionStart := true ;
16927: LD_ADDR_EXP 13
16931: PUSH
16932: LD_INT 1
16934: ST_TO_ADDR
// missionStage := 2 ;
16935: LD_ADDR_EXP 15
16939: PUSH
16940: LD_INT 2
16942: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16943: LD_INT 105
16945: PPUSH
16946: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16950: LD_ADDR_VAR 0 5
16954: PUSH
16955: LD_INT 22
16957: PUSH
16958: LD_INT 4
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 21
16967: PUSH
16968: LD_INT 1
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PPUSH
16979: CALL_OW 69
16983: PUSH
16984: LD_EXP 58
16988: DIFF
16989: ST_TO_ADDR
// if not tmp then
16990: LD_VAR 0 5
16994: NOT
16995: IFFALSE 17010
// tmp := [ Powell ] ;
16997: LD_ADDR_VAR 0 5
17001: PUSH
17002: LD_EXP 58
17006: PUSH
17007: EMPTY
17008: LIST
17009: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17010: LD_ADDR_EXP 110
17014: PUSH
17015: LD_EXP 110
17019: PPUSH
17020: LD_INT 4
17022: PPUSH
17023: LD_INT 22
17025: PUSH
17026: LD_INT 4
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: PUSH
17033: LD_INT 23
17035: PUSH
17036: LD_INT 1
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 3
17045: PUSH
17046: LD_INT 21
17048: PUSH
17049: LD_INT 2
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: PPUSH
17065: CALL_OW 69
17069: PUSH
17070: LD_EXP 58
17074: DIFF
17075: PPUSH
17076: CALL_OW 1
17080: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17081: LD_ADDR_VAR 0 4
17085: PUSH
17086: LD_INT 22
17088: PUSH
17089: LD_INT 4
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 34
17098: PUSH
17099: LD_INT 12
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: PPUSH
17110: CALL_OW 69
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 310
17132: IFFALSE 17147
// ComExitBuilding ( tmp [ 1 ] ) ;
17134: LD_VAR 0 5
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PPUSH
17143: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17147: LD_VAR 0 5
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PPUSH
17156: LD_VAR 0 4
17160: PPUSH
17161: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17165: LD_VAR 0 5
17169: PUSH
17170: LD_INT 1
17172: ARRAY
17173: PPUSH
17174: LD_INT 80
17176: PPUSH
17177: LD_INT 136
17179: PPUSH
17180: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17184: LD_VAR 0 5
17188: PUSH
17189: LD_INT 1
17191: ARRAY
17192: PPUSH
17193: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17197: LD_VAR 0 5
17201: PUSH
17202: LD_INT 1
17204: ARRAY
17205: PPUSH
17206: LD_INT 59
17208: PPUSH
17209: LD_INT 112
17211: PPUSH
17212: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17216: LD_VAR 0 5
17220: PUSH
17221: LD_INT 1
17223: ARRAY
17224: PPUSH
17225: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17229: LD_EXP 40
17233: PUSH
17234: LD_EXP 40
17238: PPUSH
17239: CALL_OW 255
17243: PUSH
17244: LD_INT 1
17246: EQUAL
17247: AND
17248: IFFALSE 17274
// begin Say ( Joan , D3W-Joan-1 ) ;
17250: LD_EXP 40
17254: PPUSH
17255: LD_STRING D3W-Joan-1
17257: PPUSH
17258: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17262: LD_EXP 39
17266: PPUSH
17267: LD_STRING D3W-JMM-1
17269: PPUSH
17270: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17274: LD_EXP 42
17278: PUSH
17279: LD_EXP 42
17283: PPUSH
17284: CALL_OW 255
17288: PUSH
17289: LD_INT 1
17291: EQUAL
17292: AND
17293: PUSH
17294: LD_EXP 42
17298: PUSH
17299: LD_EXP 59
17303: IN
17304: NOT
17305: AND
17306: IFFALSE 17332
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17308: LD_EXP 42
17312: PPUSH
17313: LD_STRING D3W-Lisa-1
17315: PPUSH
17316: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17320: LD_EXP 39
17324: PPUSH
17325: LD_STRING D3W-JMM-1
17327: PPUSH
17328: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17332: LD_EXP 54
17336: PUSH
17337: LD_EXP 54
17341: PPUSH
17342: CALL_OW 255
17346: PUSH
17347: LD_INT 1
17349: EQUAL
17350: AND
17351: IFFALSE 17377
// begin Say ( Connie , D3W-Con-1 ) ;
17353: LD_EXP 54
17357: PPUSH
17358: LD_STRING D3W-Con-1
17360: PPUSH
17361: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17365: LD_EXP 39
17369: PPUSH
17370: LD_STRING D3W-JMM-1
17372: PPUSH
17373: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17377: LD_EXP 42
17381: PUSH
17382: LD_EXP 59
17386: IN
17387: PUSH
17388: LD_EXP 42
17392: PPUSH
17393: CALL_OW 255
17397: PUSH
17398: LD_INT 1
17400: EQUAL
17401: AND
17402: IFFALSE 17418
// Say ( Lisa , D3nW-Lisa-1 ) else
17404: LD_EXP 42
17408: PPUSH
17409: LD_STRING D3nW-Lisa-1
17411: PPUSH
17412: CALL_OW 88
17416: GO 17662
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17418: LD_EXP 45
17422: PUSH
17423: LD_EXP 59
17427: IN
17428: PUSH
17429: LD_EXP 45
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 1
17441: EQUAL
17442: AND
17443: IFFALSE 17459
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17445: LD_EXP 45
17449: PPUSH
17450: LD_STRING D3nW-Cyrus-1
17452: PPUSH
17453: CALL_OW 88
17457: GO 17662
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17459: LD_EXP 44
17463: PUSH
17464: LD_EXP 59
17468: IN
17469: PUSH
17470: LD_EXP 44
17474: PPUSH
17475: CALL_OW 255
17479: PUSH
17480: LD_INT 1
17482: EQUAL
17483: AND
17484: IFFALSE 17500
// Say ( Bobby , D3nW-Bobby-1 ) else
17486: LD_EXP 44
17490: PPUSH
17491: LD_STRING D3nW-Bobby-1
17493: PPUSH
17494: CALL_OW 88
17498: GO 17662
// if Gary in vip and GetSide ( Gary ) = 1 then
17500: LD_EXP 51
17504: PUSH
17505: LD_EXP 59
17509: IN
17510: PUSH
17511: LD_EXP 51
17515: PPUSH
17516: CALL_OW 255
17520: PUSH
17521: LD_INT 1
17523: EQUAL
17524: AND
17525: IFFALSE 17541
// Say ( Gary , D3nW-Gary-1 ) else
17527: LD_EXP 51
17531: PPUSH
17532: LD_STRING D3nW-Gary-1
17534: PPUSH
17535: CALL_OW 88
17539: GO 17662
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17541: LD_EXP 43
17545: PUSH
17546: LD_EXP 59
17550: IN
17551: PUSH
17552: LD_EXP 43
17556: PPUSH
17557: CALL_OW 255
17561: PUSH
17562: LD_INT 1
17564: EQUAL
17565: AND
17566: IFFALSE 17582
// Say ( Donaldson , D3nW-Don-1 ) else
17568: LD_EXP 43
17572: PPUSH
17573: LD_STRING D3nW-Don-1
17575: PPUSH
17576: CALL_OW 88
17580: GO 17662
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17582: LD_EXP 50
17586: PUSH
17587: LD_EXP 59
17591: IN
17592: PUSH
17593: LD_EXP 50
17597: PPUSH
17598: CALL_OW 255
17602: PUSH
17603: LD_INT 1
17605: EQUAL
17606: AND
17607: IFFALSE 17623
// Say ( Cornel , D3nW-Corn-1 ) else
17609: LD_EXP 50
17613: PPUSH
17614: LD_STRING D3nW-Corn-1
17616: PPUSH
17617: CALL_OW 88
17621: GO 17662
// if Frank in vip and GetSide ( Frank ) = 1 then
17623: LD_EXP 52
17627: PUSH
17628: LD_EXP 59
17632: IN
17633: PUSH
17634: LD_EXP 52
17638: PPUSH
17639: CALL_OW 255
17643: PUSH
17644: LD_INT 1
17646: EQUAL
17647: AND
17648: IFFALSE 17662
// Say ( Frank , D3nW-Frank-1 ) ;
17650: LD_EXP 52
17654: PPUSH
17655: LD_STRING D3nW-Frank-1
17657: PPUSH
17658: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17662: LD_EXP 59
17666: PPUSH
17667: LD_INT 22
17669: PUSH
17670: LD_INT 1
17672: PUSH
17673: EMPTY
17674: LIST
17675: LIST
17676: PPUSH
17677: CALL_OW 72
17681: IFFALSE 17707
// begin Say ( JMM , D3nW-JMM-1 ) ;
17683: LD_EXP 39
17687: PPUSH
17688: LD_STRING D3nW-JMM-1
17690: PPUSH
17691: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17695: LD_EXP 39
17699: PPUSH
17700: LD_STRING D3nW-JMM-1a
17702: PPUSH
17703: CALL_OW 88
// end ; t := 0 0$00 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_INT 0
17714: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17715: LD_INT 35
17717: PPUSH
17718: CALL_OW 67
// t := t + 0 0$1 ;
17722: LD_ADDR_VAR 0 3
17726: PUSH
17727: LD_VAR 0 3
17731: PUSH
17732: LD_INT 35
17734: PLUS
17735: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17736: LD_INT 59
17738: PPUSH
17739: LD_INT 112
17741: PPUSH
17742: CALL_OW 428
17746: PUSH
17747: LD_VAR 0 3
17751: PUSH
17752: LD_INT 2100
17754: GREATER
17755: OR
17756: IFFALSE 17715
// activeAttacks := true ;
17758: LD_ADDR_EXP 16
17762: PUSH
17763: LD_INT 1
17765: ST_TO_ADDR
// end ;
17766: LD_VAR 0 1
17770: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17771: LD_INT 0
17773: PPUSH
// case question of 1 :
17774: LD_VAR 0 1
17778: PUSH
17779: LD_INT 1
17781: DOUBLE
17782: EQUAL
17783: IFTRUE 17787
17785: GO 17838
17787: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17788: LD_EXP 39
17792: PPUSH
17793: LD_STRING D2Mot-JMM-1
17795: PPUSH
17796: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17800: LD_EXP 58
17804: PPUSH
17805: LD_STRING D2Mot-Pow-1
17807: PPUSH
17808: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17812: LD_EXP 39
17816: PPUSH
17817: LD_STRING D2Mot-JMM-2
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17824: LD_EXP 58
17828: PPUSH
17829: LD_STRING D2Mot-Pow-2
17831: PPUSH
17832: CALL_OW 88
// end ; 2 :
17836: GO 18189
17838: LD_INT 2
17840: DOUBLE
17841: EQUAL
17842: IFTRUE 17846
17844: GO 17922
17846: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17847: LD_EXP 39
17851: PPUSH
17852: LD_STRING D2Rus-JMM-1
17854: PPUSH
17855: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17859: LD_EXP 58
17863: PPUSH
17864: LD_STRING D2Rus-Pow-1
17866: PPUSH
17867: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17871: LD_EXP 39
17875: PPUSH
17876: LD_STRING D2Rus-JMM-2
17878: PPUSH
17879: CALL_OW 88
// if not ( 3 in list_of_q ) then
17883: LD_INT 3
17885: PUSH
17886: LD_VAR 0 2
17890: IN
17891: NOT
17892: IFFALSE 17908
// Say ( Powell , D2Rus-Pow-2 ) else
17894: LD_EXP 58
17898: PPUSH
17899: LD_STRING D2Rus-Pow-2
17901: PPUSH
17902: CALL_OW 88
17906: GO 17920
// Say ( Powell , D2Rus-Pow-2a ) ;
17908: LD_EXP 58
17912: PPUSH
17913: LD_STRING D2Rus-Pow-2a
17915: PPUSH
17916: CALL_OW 88
// end ; 3 :
17920: GO 18189
17922: LD_INT 3
17924: DOUBLE
17925: EQUAL
17926: IFTRUE 17930
17928: GO 18015
17930: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17931: LD_EXP 39
17935: PPUSH
17936: LD_STRING D2Leg-JMM-1
17938: PPUSH
17939: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17943: LD_EXP 58
17947: PPUSH
17948: LD_STRING D2Leg-Pow-1
17950: PPUSH
17951: CALL_OW 88
// if 2 in list_of_q then
17955: LD_INT 2
17957: PUSH
17958: LD_VAR 0 2
17962: IN
17963: IFFALSE 17989
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17965: LD_EXP 39
17969: PPUSH
17970: LD_STRING D2Leg-JMM-2
17972: PPUSH
17973: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17977: LD_EXP 58
17981: PPUSH
17982: LD_STRING D2Leg-Pow-2
17984: PPUSH
17985: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17989: LD_EXP 39
17993: PPUSH
17994: LD_STRING D2Leg-JMM-3
17996: PPUSH
17997: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18001: LD_EXP 58
18005: PPUSH
18006: LD_STRING D2Leg-Pow-3
18008: PPUSH
18009: CALL_OW 88
// end ; 4 :
18013: GO 18189
18015: LD_INT 4
18017: DOUBLE
18018: EQUAL
18019: IFTRUE 18023
18021: GO 18098
18023: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18024: LD_EXP 39
18028: PPUSH
18029: LD_STRING D2Ar-JMM-1
18031: PPUSH
18032: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18036: LD_EXP 58
18040: PPUSH
18041: LD_STRING D2Ar-Pow-1
18043: PPUSH
18044: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18048: LD_EXP 39
18052: PPUSH
18053: LD_STRING D2Ar-JMM-2
18055: PPUSH
18056: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18060: LD_EXP 58
18064: PPUSH
18065: LD_STRING D2Ar-Pow-2
18067: PPUSH
18068: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18072: LD_EXP 39
18076: PPUSH
18077: LD_STRING D2Ar-JMM-3
18079: PPUSH
18080: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18084: LD_EXP 58
18088: PPUSH
18089: LD_STRING D2Ar-Pow-3
18091: PPUSH
18092: CALL_OW 88
// end ; 5 :
18096: GO 18189
18098: LD_INT 5
18100: DOUBLE
18101: EQUAL
18102: IFTRUE 18106
18104: GO 18121
18106: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18107: LD_EXP 39
18111: PPUSH
18112: LD_STRING D2Conf-JMM-1
18114: PPUSH
18115: CALL_OW 88
18119: GO 18189
18121: LD_INT 6
18123: DOUBLE
18124: EQUAL
18125: IFTRUE 18129
18127: GO 18188
18129: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18130: LD_EXP 39
18134: PPUSH
18135: LD_STRING D2Com-JMM-1
18137: PPUSH
18138: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18142: LD_EXP 58
18146: PPUSH
18147: LD_STRING D2Com-Pow-1
18149: PPUSH
18150: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18154: LD_EXP 39
18158: PPUSH
18159: LD_STRING D2Com-JMM-2
18161: PPUSH
18162: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18166: LD_EXP 58
18170: PPUSH
18171: LD_STRING D2Com-Pow-2
18173: PPUSH
18174: CALL_OW 88
// powellAngerQuery := true ;
18178: LD_ADDR_EXP 36
18182: PUSH
18183: LD_INT 1
18185: ST_TO_ADDR
// end ; end ;
18186: GO 18189
18188: POP
// end ;
18189: LD_VAR 0 3
18193: RET
// every 0 0$5 trigger missionStart do var tmp ;
18194: LD_EXP 13
18198: IFFALSE 18481
18200: GO 18202
18202: DISABLE
18203: LD_INT 0
18205: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18206: LD_INT 35
18208: PPUSH
18209: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18213: LD_INT 14
18215: PPUSH
18216: LD_INT 22
18218: PUSH
18219: LD_INT 1
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: PPUSH
18226: CALL_OW 70
18230: PUSH
18231: LD_EXP 15
18235: PUSH
18236: LD_INT 2
18238: PUSH
18239: LD_INT 3
18241: PUSH
18242: LD_INT 4
18244: PUSH
18245: LD_INT 5
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: IN
18254: AND
18255: IFFALSE 18471
// begin powellAnger := powellAnger + 1 ;
18257: LD_ADDR_EXP 17
18261: PUSH
18262: LD_EXP 17
18266: PUSH
18267: LD_INT 1
18269: PLUS
18270: ST_TO_ADDR
// Video ( true ) ;
18271: LD_INT 1
18273: PPUSH
18274: CALL 100907 0 1
// CenterNowOnUnits ( tmp ) ;
18278: LD_VAR 0 1
18282: PPUSH
18283: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18287: LD_INT 14
18289: PPUSH
18290: LD_INT 22
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PPUSH
18300: CALL_OW 70
18304: PPUSH
18305: LD_INT 86
18307: PPUSH
18308: LD_INT 133
18310: PPUSH
18311: CALL_OW 111
// async ;
18315: ASYNC
// case powellAnger of 1 :
18316: LD_EXP 17
18320: PUSH
18321: LD_INT 1
18323: DOUBLE
18324: EQUAL
18325: IFTRUE 18329
18327: GO 18344
18329: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18330: LD_EXP 58
18334: PPUSH
18335: LD_STRING DBack1-Pow-1
18337: PPUSH
18338: CALL_OW 88
18342: GO 18391
18344: LD_INT 2
18346: DOUBLE
18347: EQUAL
18348: IFTRUE 18352
18350: GO 18367
18352: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18353: LD_EXP 58
18357: PPUSH
18358: LD_STRING DBack2-Pow-1
18360: PPUSH
18361: CALL_OW 88
18365: GO 18391
18367: LD_INT 3
18369: DOUBLE
18370: EQUAL
18371: IFTRUE 18375
18373: GO 18390
18375: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18376: LD_EXP 58
18380: PPUSH
18381: LD_STRING DBack3-Pow-1
18383: PPUSH
18384: CALL_OW 88
18388: GO 18391
18390: POP
// sync ;
18391: SYNC
// repeat wait ( 0 0$1 ) ;
18392: LD_INT 35
18394: PPUSH
18395: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18399: LD_INT 14
18401: PPUSH
18402: LD_INT 22
18404: PUSH
18405: LD_INT 1
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PPUSH
18412: CALL_OW 70
18416: PPUSH
18417: LD_INT 86
18419: PPUSH
18420: LD_INT 133
18422: PPUSH
18423: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18427: LD_INT 14
18429: PPUSH
18430: LD_INT 22
18432: PUSH
18433: LD_INT 1
18435: PUSH
18436: EMPTY
18437: LIST
18438: LIST
18439: PPUSH
18440: CALL_OW 70
18444: NOT
18445: IFFALSE 18392
// if powellAnger >= 3 then
18447: LD_EXP 17
18451: PUSH
18452: LD_INT 3
18454: GREATEREQUAL
18455: IFFALSE 18464
// YouLost ( Dismissed ) ;
18457: LD_STRING Dismissed
18459: PPUSH
18460: CALL_OW 104
// Video ( false ) ;
18464: LD_INT 0
18466: PPUSH
18467: CALL 100907 0 1
// end ; until missionStage > 5 ;
18471: LD_EXP 15
18475: PUSH
18476: LD_INT 5
18478: GREATER
18479: IFFALSE 18206
// end ;
18481: PPOPN 1
18483: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18484: LD_EXP 13
18488: PUSH
18489: LD_INT 22
18491: PUSH
18492: LD_INT 4
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 21
18501: PUSH
18502: LD_INT 2
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PUSH
18509: EMPTY
18510: LIST
18511: LIST
18512: PPUSH
18513: CALL_OW 69
18517: PUSH
18518: LD_INT 4
18520: GREATEREQUAL
18521: AND
18522: PUSH
18523: LD_EXP 15
18527: PUSH
18528: LD_INT 2
18530: EQUAL
18531: AND
18532: IFFALSE 20355
18534: GO 18536
18536: DISABLE
18537: LD_INT 0
18539: PPUSH
18540: PPUSH
18541: PPUSH
18542: PPUSH
18543: PPUSH
18544: PPUSH
18545: PPUSH
18546: PPUSH
// begin missionStage := 3 ;
18547: LD_ADDR_EXP 15
18551: PUSH
18552: LD_INT 3
18554: ST_TO_ADDR
// retreat := false ;
18555: LD_ADDR_VAR 0 4
18559: PUSH
18560: LD_INT 0
18562: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18563: LD_ADDR_VAR 0 5
18567: PUSH
18568: LD_INT 22
18570: PUSH
18571: LD_INT 4
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 30
18580: PUSH
18581: LD_INT 4
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PPUSH
18592: CALL_OW 69
18596: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18597: LD_ADDR_VAR 0 6
18601: PUSH
18602: LD_INT 22
18604: PUSH
18605: LD_INT 4
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: PUSH
18612: LD_INT 30
18614: PUSH
18615: LD_INT 5
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PPUSH
18626: CALL_OW 69
18630: ST_TO_ADDR
// if not bar then
18631: LD_VAR 0 6
18635: NOT
18636: IFFALSE 18689
// begin repeat wait ( 0 0$1 ) ;
18638: LD_INT 35
18640: PPUSH
18641: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18645: LD_INT 22
18647: PUSH
18648: LD_INT 4
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: PUSH
18655: LD_INT 3
18657: PUSH
18658: LD_INT 57
18660: PUSH
18661: EMPTY
18662: LIST
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: PUSH
18668: LD_INT 30
18670: PUSH
18671: LD_INT 5
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: PPUSH
18683: CALL_OW 69
18687: IFFALSE 18638
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18689: LD_ADDR_VAR 0 6
18693: PUSH
18694: LD_INT 22
18696: PUSH
18697: LD_INT 4
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: PUSH
18704: LD_INT 30
18706: PUSH
18707: LD_INT 5
18709: PUSH
18710: EMPTY
18711: LIST
18712: LIST
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: PPUSH
18718: CALL_OW 69
18722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18723: LD_INT 35
18725: PPUSH
18726: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18730: LD_EXP 129
18734: PUSH
18735: LD_INT 4
18737: ARRAY
18738: PUSH
18739: LD_INT 4
18741: GREATEREQUAL
18742: IFFALSE 18723
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18744: LD_ADDR_VAR 0 2
18748: PUSH
18749: LD_INT 22
18751: PUSH
18752: LD_INT 4
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: PUSH
18759: LD_INT 2
18761: PUSH
18762: LD_INT 25
18764: PUSH
18765: LD_INT 1
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: PUSH
18772: LD_INT 25
18774: PUSH
18775: LD_INT 2
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: PUSH
18782: LD_INT 25
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: PUSH
18792: LD_INT 25
18794: PUSH
18795: LD_INT 4
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: PUSH
18802: LD_INT 25
18804: PUSH
18805: LD_INT 5
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PPUSH
18824: CALL_OW 69
18828: PUSH
18829: LD_EXP 58
18833: PUSH
18834: LD_EXP 59
18838: ADD
18839: DIFF
18840: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18841: LD_ADDR_VAR 0 3
18845: PUSH
18846: LD_VAR 0 2
18850: PPUSH
18851: LD_INT 26
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PPUSH
18861: CALL_OW 72
18865: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18866: LD_ADDR_VAR 0 2
18870: PUSH
18871: LD_VAR 0 2
18875: PUSH
18876: LD_VAR 0 3
18880: DIFF
18881: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18882: LD_ADDR_VAR 0 2
18886: PUSH
18887: LD_VAR 0 2
18891: PPUSH
18892: LD_INT 1
18894: PPUSH
18895: CALL 99560 0 2
18899: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18900: LD_ADDR_VAR 0 3
18904: PUSH
18905: LD_VAR 0 3
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 99560 0 2
18917: ST_TO_ADDR
// for i = 1 to 4 do
18918: LD_ADDR_VAR 0 1
18922: PUSH
18923: DOUBLE
18924: LD_INT 1
18926: DEC
18927: ST_TO_ADDR
18928: LD_INT 4
18930: PUSH
18931: FOR_TO
18932: IFFALSE 19098
// begin if tmp2 then
18934: LD_VAR 0 3
18938: IFFALSE 19019
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18940: LD_ADDR_EXP 18
18944: PUSH
18945: LD_EXP 18
18949: PPUSH
18950: LD_INT 1
18952: PPUSH
18953: LD_EXP 18
18957: PUSH
18958: LD_INT 1
18960: ARRAY
18961: PUSH
18962: LD_VAR 0 3
18966: PUSH
18967: LD_VAR 0 3
18971: ARRAY
18972: ADD
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18979: LD_VAR 0 3
18983: PUSH
18984: LD_VAR 0 3
18988: ARRAY
18989: PPUSH
18990: LD_INT 1
18992: PPUSH
18993: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 3
19006: PPUSH
19007: LD_VAR 0 3
19011: PPUSH
19012: CALL_OW 3
19016: ST_TO_ADDR
// end else
19017: GO 19096
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19019: LD_ADDR_EXP 18
19023: PUSH
19024: LD_EXP 18
19028: PPUSH
19029: LD_INT 1
19031: PPUSH
19032: LD_EXP 18
19036: PUSH
19037: LD_INT 1
19039: ARRAY
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 2
19050: ARRAY
19051: ADD
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19058: LD_VAR 0 2
19062: PUSH
19063: LD_VAR 0 2
19067: ARRAY
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19076: LD_ADDR_VAR 0 2
19080: PUSH
19081: LD_VAR 0 2
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 3
19095: ST_TO_ADDR
// end ; end ;
19096: GO 18931
19098: POP
19099: POP
// if tmp2 then
19100: LD_VAR 0 3
19104: IFFALSE 19122
// tmp := tmp union tmp2 ;
19106: LD_ADDR_VAR 0 2
19110: PUSH
19111: LD_VAR 0 2
19115: PUSH
19116: LD_VAR 0 3
19120: UNION
19121: ST_TO_ADDR
// for i = 1 to 4 do
19122: LD_ADDR_VAR 0 1
19126: PUSH
19127: DOUBLE
19128: LD_INT 1
19130: DEC
19131: ST_TO_ADDR
19132: LD_INT 4
19134: PUSH
19135: FOR_TO
19136: IFFALSE 19185
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19138: LD_ADDR_EXP 18
19142: PUSH
19143: LD_EXP 18
19147: PPUSH
19148: LD_INT 2
19150: PPUSH
19151: LD_EXP 18
19155: PUSH
19156: LD_INT 2
19158: ARRAY
19159: PUSH
19160: LD_VAR 0 2
19164: PUSH
19165: LD_VAR 0 2
19169: PUSH
19170: LD_VAR 0 1
19174: MINUS
19175: ARRAY
19176: ADD
19177: PPUSH
19178: CALL_OW 1
19182: ST_TO_ADDR
19183: GO 19135
19185: POP
19186: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19187: LD_ADDR_EXP 110
19191: PUSH
19192: LD_EXP 110
19196: PPUSH
19197: LD_INT 4
19199: PPUSH
19200: LD_EXP 110
19204: PUSH
19205: LD_INT 4
19207: ARRAY
19208: PUSH
19209: LD_EXP 18
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: DIFF
19218: PPUSH
19219: CALL_OW 1
19223: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19224: LD_VAR 0 5
19228: PUSH
19229: LD_INT 1
19231: ARRAY
19232: PPUSH
19233: CALL_OW 313
19237: IFFALSE 19292
// begin for i in UnitsInside ( arm [ 1 ] ) do
19239: LD_ADDR_VAR 0 1
19243: PUSH
19244: LD_VAR 0 5
19248: PUSH
19249: LD_INT 1
19251: ARRAY
19252: PPUSH
19253: CALL_OW 313
19257: PUSH
19258: FOR_IN
19259: IFFALSE 19290
// begin ComExitBuilding ( i ) ;
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19270: LD_VAR 0 1
19274: PPUSH
19275: LD_VAR 0 6
19279: PUSH
19280: LD_INT 1
19282: ARRAY
19283: PPUSH
19284: CALL_OW 180
// end ;
19288: GO 19258
19290: POP
19291: POP
// end ; wait ( 0 0$3 ) ;
19292: LD_INT 105
19294: PPUSH
19295: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19299: LD_ADDR_VAR 0 1
19303: PUSH
19304: LD_EXP 18
19308: PUSH
19309: LD_INT 1
19311: ARRAY
19312: PUSH
19313: FOR_IN
19314: IFFALSE 19421
// begin if IsInUnit ( i ) then
19316: LD_VAR 0 1
19320: PPUSH
19321: CALL_OW 310
19325: IFFALSE 19336
// ComExitBuilding ( i ) ;
19327: LD_VAR 0 1
19331: PPUSH
19332: CALL_OW 122
// if GetClass ( i ) <> 1 then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 257
19345: PUSH
19346: LD_INT 1
19348: NONEQUAL
19349: IFFALSE 19390
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19351: LD_VAR 0 1
19355: PPUSH
19356: LD_VAR 0 5
19360: PUSH
19361: LD_INT 1
19363: ARRAY
19364: PPUSH
19365: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19369: LD_VAR 0 1
19373: PPUSH
19374: LD_INT 1
19376: PPUSH
19377: CALL_OW 183
// AddComExitBuilding ( i ) ;
19381: LD_VAR 0 1
19385: PPUSH
19386: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_INT 60
19397: PPUSH
19398: LD_INT 94
19400: PPUSH
19401: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19405: LD_VAR 0 1
19409: PPUSH
19410: LD_EXP 58
19414: PPUSH
19415: CALL_OW 179
// end ;
19419: GO 19313
19421: POP
19422: POP
// wait ( 0 0$15 ) ;
19423: LD_INT 525
19425: PPUSH
19426: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19430: LD_EXP 58
19434: PPUSH
19435: LD_STRING D4-Pow-1
19437: PPUSH
19438: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19442: LD_ADDR_VAR 0 2
19446: PUSH
19447: LD_EXP 18
19451: PUSH
19452: LD_INT 1
19454: ARRAY
19455: PPUSH
19456: LD_INT 26
19458: PUSH
19459: LD_INT 1
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: PPUSH
19466: CALL_OW 72
19470: ST_TO_ADDR
// if tmp then
19471: LD_VAR 0 2
19475: IFFALSE 19493
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19477: LD_VAR 0 2
19481: PUSH
19482: LD_INT 1
19484: ARRAY
19485: PPUSH
19486: LD_STRING D4-Sol1-1
19488: PPUSH
19489: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19493: LD_EXP 58
19497: PPUSH
19498: LD_STRING D4-Pow-2
19500: PPUSH
19501: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19505: LD_ADDR_VAR 0 1
19509: PUSH
19510: DOUBLE
19511: LD_INT 1
19513: DEC
19514: ST_TO_ADDR
19515: LD_EXP 18
19519: PUSH
19520: LD_INT 1
19522: ARRAY
19523: PUSH
19524: FOR_TO
19525: IFFALSE 19618
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PUSH
19536: LD_VAR 0 1
19540: ARRAY
19541: PPUSH
19542: LD_EXP 129
19546: PUSH
19547: LD_INT 4
19549: ARRAY
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PPUSH
19555: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19559: LD_ADDR_EXP 129
19563: PUSH
19564: LD_EXP 129
19568: PPUSH
19569: LD_INT 4
19571: PPUSH
19572: LD_EXP 129
19576: PUSH
19577: LD_INT 4
19579: ARRAY
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: CALL_OW 3
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19594: LD_INT 8
19596: PPUSH
19597: LD_EXP 18
19601: PUSH
19602: LD_INT 1
19604: ARRAY
19605: PUSH
19606: LD_VAR 0 1
19610: ARRAY
19611: PPUSH
19612: CALL_OW 471
// end ;
19616: GO 19524
19618: POP
19619: POP
// repeat wait ( 0 0$1 ) ;
19620: LD_INT 35
19622: PPUSH
19623: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19627: LD_EXP 18
19631: PUSH
19632: LD_INT 1
19634: ARRAY
19635: PPUSH
19636: LD_INT 55
19638: PUSH
19639: EMPTY
19640: LIST
19641: PPUSH
19642: CALL_OW 72
19646: PUSH
19647: LD_INT 4
19649: GREATEREQUAL
19650: IFFALSE 19620
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 69
19663: PPUSH
19664: LD_INT 94
19666: PPUSH
19667: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19671: LD_EXP 18
19675: PUSH
19676: LD_INT 1
19678: ARRAY
19679: PPUSH
19680: LD_INT 82
19682: PPUSH
19683: LD_INT 83
19685: PPUSH
19686: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19690: LD_EXP 18
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: LD_INT 77
19701: PPUSH
19702: LD_INT 69
19704: PPUSH
19705: CALL_OW 174
// repeat wait ( 3 ) ;
19709: LD_INT 3
19711: PPUSH
19712: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19716: LD_ADDR_VAR 0 1
19720: PUSH
19721: LD_EXP 18
19725: PUSH
19726: LD_INT 1
19728: ARRAY
19729: PUSH
19730: FOR_IN
19731: IFFALSE 19867
// begin if GetLives ( i ) < 990 then
19733: LD_VAR 0 1
19737: PPUSH
19738: CALL_OW 256
19742: PUSH
19743: LD_INT 990
19745: LESS
19746: IFFALSE 19760
// SetLives ( i , 1000 ) ;
19748: LD_VAR 0 1
19752: PPUSH
19753: LD_INT 1000
19755: PPUSH
19756: CALL_OW 234
// if not IsInUnit ( i ) then
19760: LD_VAR 0 1
19764: PPUSH
19765: CALL_OW 310
19769: NOT
19770: IFFALSE 19865
// begin if not HasTask ( i ) then
19772: LD_VAR 0 1
19776: PPUSH
19777: CALL_OW 314
19781: NOT
19782: IFFALSE 19799
// ComMoveXY ( i , 64 , 93 ) ;
19784: LD_VAR 0 1
19788: PPUSH
19789: LD_INT 64
19791: PPUSH
19792: LD_INT 93
19794: PPUSH
19795: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19799: LD_VAR 0 4
19803: NOT
19804: PUSH
19805: LD_VAR 0 1
19809: PPUSH
19810: CALL_OW 258
19814: PUSH
19815: LD_INT 1
19817: EQUAL
19818: AND
19819: IFFALSE 19865
// begin retreat := true ;
19821: LD_ADDR_VAR 0 4
19825: PUSH
19826: LD_INT 1
19828: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19829: LD_VAR 0 1
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19841: LD_VAR 0 1
19845: PPUSH
19846: LD_STRING D4a-Sol1-1
19848: PPUSH
19849: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19853: LD_EXP 58
19857: PPUSH
19858: LD_STRING D4a-Pow-1
19860: PPUSH
19861: CALL_OW 88
// end ; end ; end ;
19865: GO 19730
19867: POP
19868: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19869: LD_EXP 18
19873: PUSH
19874: LD_INT 1
19876: ARRAY
19877: PPUSH
19878: LD_INT 95
19880: PUSH
19881: LD_INT 9
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 55
19893: PUSH
19894: EMPTY
19895: LIST
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PPUSH
19905: CALL_OW 72
19909: PUSH
19910: LD_INT 4
19912: GREATEREQUAL
19913: IFFALSE 19709
// for i in powellSquadAttack [ 1 ] do
19915: LD_ADDR_VAR 0 1
19919: PUSH
19920: LD_EXP 18
19924: PUSH
19925: LD_INT 1
19927: ARRAY
19928: PUSH
19929: FOR_IN
19930: IFFALSE 20066
// begin if GetTag ( i ) = 2 then
19932: LD_VAR 0 1
19936: PPUSH
19937: CALL_OW 110
19941: PUSH
19942: LD_INT 2
19944: EQUAL
19945: IFFALSE 20007
// begin ComMoveXY ( i , 60 , 94 ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_INT 60
19954: PPUSH
19955: LD_INT 94
19957: PPUSH
19958: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19962: LD_VAR 0 1
19966: PPUSH
19967: LD_EXP 58
19971: PPUSH
19972: CALL_OW 179
// wait ( 0 0$3 ) ;
19976: LD_INT 105
19978: PPUSH
19979: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19983: LD_VAR 0 1
19987: PPUSH
19988: LD_STRING D4a-Sol1-2
19990: PPUSH
19991: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19995: LD_EXP 58
19999: PPUSH
20000: LD_STRING D4a-Pow-2
20002: PPUSH
20003: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20007: LD_VAR 0 1
20011: PPUSH
20012: LD_INT 0
20014: PPUSH
20015: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20019: LD_ADDR_EXP 110
20023: PUSH
20024: LD_EXP 110
20028: PPUSH
20029: LD_INT 4
20031: PPUSH
20032: LD_EXP 110
20036: PUSH
20037: LD_INT 4
20039: ARRAY
20040: PUSH
20041: LD_VAR 0 1
20045: UNION
20046: PPUSH
20047: CALL_OW 1
20051: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20052: LD_INT 8
20054: PPUSH
20055: LD_VAR 0 1
20059: PPUSH
20060: CALL_OW 472
// end ;
20064: GO 19929
20066: POP
20067: POP
// wait ( 4 4$00 ) ;
20068: LD_INT 8400
20070: PPUSH
20071: CALL_OW 67
// uc_side := 6 ;
20075: LD_ADDR_OWVAR 20
20079: PUSH
20080: LD_INT 6
20082: ST_TO_ADDR
// uc_nation := 3 ;
20083: LD_ADDR_OWVAR 21
20087: PUSH
20088: LD_INT 3
20090: ST_TO_ADDR
// ru := [ ] ;
20091: LD_ADDR_VAR 0 7
20095: PUSH
20096: EMPTY
20097: ST_TO_ADDR
// for i = 1 to 4 do
20098: LD_ADDR_VAR 0 1
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_INT 4
20110: PUSH
20111: FOR_TO
20112: IFFALSE 20213
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20114: LD_INT 22
20116: PPUSH
20117: LD_INT 1
20119: PPUSH
20120: LD_INT 3
20122: PPUSH
20123: LD_INT 43
20125: PUSH
20126: LD_INT 44
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: PUSH
20133: LD_INT 1
20135: PPUSH
20136: LD_INT 2
20138: PPUSH
20139: CALL_OW 12
20143: ARRAY
20144: PPUSH
20145: LD_INT 89
20147: PPUSH
20148: CALL 69889 0 5
// un := CreateVehicle ;
20152: LD_ADDR_VAR 0 8
20156: PUSH
20157: CALL_OW 45
20161: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20162: LD_VAR 0 8
20166: PPUSH
20167: LD_INT 4
20169: PPUSH
20170: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20174: LD_VAR 0 8
20178: PPUSH
20179: LD_INT 136
20181: PPUSH
20182: LD_INT 90
20184: PPUSH
20185: LD_INT 8
20187: PPUSH
20188: LD_INT 0
20190: PPUSH
20191: CALL_OW 50
// ru := ru ^ un ;
20195: LD_ADDR_VAR 0 7
20199: PUSH
20200: LD_VAR 0 7
20204: PUSH
20205: LD_VAR 0 8
20209: ADD
20210: ST_TO_ADDR
// end ;
20211: GO 20111
20213: POP
20214: POP
// if ru then
20215: LD_VAR 0 7
20219: IFFALSE 20236
// ComAgressiveMove ( ru , 80 , 92 ) ;
20221: LD_VAR 0 7
20225: PPUSH
20226: LD_INT 80
20228: PPUSH
20229: LD_INT 92
20231: PPUSH
20232: CALL_OW 114
// wait ( 8 8$00 ) ;
20236: LD_INT 16800
20238: PPUSH
20239: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20243: LD_INT 4
20245: PPUSH
20246: LD_INT 3
20248: PUSH
20249: LD_INT 1
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 5
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: LIST
20262: LIST
20263: PUSH
20264: LD_INT 4
20266: PUSH
20267: LD_INT 1
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 6
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 1
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 7
20293: PUSH
20294: EMPTY
20295: LIST
20296: LIST
20297: LIST
20298: LIST
20299: PUSH
20300: LD_INT 3
20302: PUSH
20303: LD_INT 1
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 7
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 3
20320: PUSH
20321: LD_INT 1
20323: PUSH
20324: LD_INT 1
20326: PUSH
20327: LD_INT 5
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PPUSH
20343: CALL 58673 0 2
// missionStage := 4 ;
20347: LD_ADDR_EXP 15
20351: PUSH
20352: LD_INT 4
20354: ST_TO_ADDR
// end ;
20355: PPOPN 8
20357: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20358: LD_EXP 15
20362: PUSH
20363: LD_INT 4
20365: EQUAL
20366: PUSH
20367: LD_INT 22
20369: PUSH
20370: LD_INT 4
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: PUSH
20377: LD_INT 21
20379: PUSH
20380: LD_INT 2
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PPUSH
20391: CALL_OW 69
20395: PUSH
20396: LD_INT 5
20398: GREATEREQUAL
20399: AND
20400: IFFALSE 24505
20402: GO 20404
20404: DISABLE
20405: LD_INT 0
20407: PPUSH
20408: PPUSH
20409: PPUSH
20410: PPUSH
20411: PPUSH
20412: PPUSH
20413: PPUSH
20414: PPUSH
20415: PPUSH
20416: PPUSH
20417: PPUSH
20418: PPUSH
20419: PPUSH
// begin missionStage := 5 ;
20420: LD_ADDR_EXP 15
20424: PUSH
20425: LD_INT 5
20427: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20428: LD_ADDR_VAR 0 10
20432: PUSH
20433: LD_INT 22
20435: PUSH
20436: LD_INT 4
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: PUSH
20443: LD_INT 2
20445: PUSH
20446: LD_INT 30
20448: PUSH
20449: LD_INT 4
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: LD_INT 30
20458: PUSH
20459: LD_INT 5
20461: PUSH
20462: EMPTY
20463: LIST
20464: LIST
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: LIST
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PPUSH
20475: CALL_OW 69
20479: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20480: LD_ADDR_VAR 0 6
20484: PUSH
20485: LD_INT 22
20487: PUSH
20488: LD_INT 4
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 21
20497: PUSH
20498: LD_INT 1
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 3
20507: PUSH
20508: LD_INT 25
20510: PUSH
20511: LD_INT 16
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: EMPTY
20519: LIST
20520: LIST
20521: PUSH
20522: LD_INT 3
20524: PUSH
20525: LD_INT 25
20527: PUSH
20528: LD_INT 12
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: LIST
20543: LIST
20544: PPUSH
20545: CALL_OW 69
20549: PUSH
20550: LD_EXP 58
20554: DIFF
20555: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20556: LD_ADDR_VAR 0 9
20560: PUSH
20561: LD_INT 22
20563: PUSH
20564: LD_INT 4
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: LD_INT 30
20573: PUSH
20574: LD_INT 3
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: PUSH
20581: EMPTY
20582: LIST
20583: LIST
20584: PPUSH
20585: CALL_OW 69
20589: PUSH
20590: LD_INT 1
20592: ARRAY
20593: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20594: LD_INT 35
20596: PPUSH
20597: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20601: LD_EXP 129
20605: PUSH
20606: LD_INT 4
20608: ARRAY
20609: PUSH
20610: LD_INT 5
20612: GREATEREQUAL
20613: PUSH
20614: LD_EXP 129
20618: PUSH
20619: LD_INT 4
20621: ARRAY
20622: PPUSH
20623: LD_INT 58
20625: PUSH
20626: EMPTY
20627: LIST
20628: PPUSH
20629: CALL_OW 72
20633: PUSH
20634: LD_INT 5
20636: GREATEREQUAL
20637: AND
20638: IFFALSE 20594
// powellAllowRetreat := false ;
20640: LD_ADDR_EXP 19
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20648: LD_INT 700
20650: PPUSH
20651: CALL_OW 67
// activeAttacks := false ;
20655: LD_ADDR_EXP 16
20659: PUSH
20660: LD_INT 0
20662: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20663: LD_INT 35
20665: PPUSH
20666: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20670: LD_INT 22
20672: PUSH
20673: LD_INT 6
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: PPUSH
20680: CALL_OW 69
20684: PUSH
20685: LD_INT 0
20687: EQUAL
20688: IFFALSE 20663
// tmp := mc_vehicles [ 4 ] ;
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: LD_EXP 129
20699: PUSH
20700: LD_INT 4
20702: ARRAY
20703: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20704: LD_ADDR_VAR 0 1
20708: PUSH
20709: DOUBLE
20710: LD_INT 1
20712: DEC
20713: ST_TO_ADDR
20714: LD_EXP 18
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20981
// begin for j in powellSquadAttack [ i ] do
20722: LD_ADDR_VAR 0 2
20726: PUSH
20727: LD_EXP 18
20731: PUSH
20732: LD_VAR 0 1
20736: ARRAY
20737: PUSH
20738: FOR_IN
20739: IFFALSE 20977
// begin forces := forces diff j ;
20741: LD_ADDR_VAR 0 6
20745: PUSH
20746: LD_VAR 0 6
20750: PUSH
20751: LD_VAR 0 2
20755: DIFF
20756: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20757: LD_VAR 0 2
20761: PPUSH
20762: LD_INT 1
20764: PPUSH
20765: CALL_OW 109
// wait ( 0 0$2 ) ;
20769: LD_INT 70
20771: PPUSH
20772: CALL_OW 67
// if IsInUnit ( j ) then
20776: LD_VAR 0 2
20780: PPUSH
20781: CALL_OW 310
20785: IFFALSE 20796
// ComExitBuilding ( j ) ;
20787: LD_VAR 0 2
20791: PPUSH
20792: CALL_OW 122
// if GetClass ( j ) <> 1 then
20796: LD_VAR 0 2
20800: PPUSH
20801: CALL_OW 257
20805: PUSH
20806: LD_INT 1
20808: NONEQUAL
20809: IFFALSE 20889
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20811: LD_VAR 0 10
20815: PUSH
20816: LD_INT 1
20818: ARRAY
20819: PPUSH
20820: CALL_OW 313
20824: PUSH
20825: LD_INT 5
20827: GREATEREQUAL
20828: IFFALSE 20850
// AddComEnterUnit ( j , arm [ 2 ] ) else
20830: LD_VAR 0 2
20834: PPUSH
20835: LD_VAR 0 10
20839: PUSH
20840: LD_INT 2
20842: ARRAY
20843: PPUSH
20844: CALL_OW 180
20848: GO 20868
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20850: LD_VAR 0 2
20854: PPUSH
20855: LD_VAR 0 10
20859: PUSH
20860: LD_INT 1
20862: ARRAY
20863: PPUSH
20864: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20868: LD_VAR 0 2
20872: PPUSH
20873: LD_INT 1
20875: PPUSH
20876: CALL_OW 183
// AddComExitBuilding ( j ) ;
20880: LD_VAR 0 2
20884: PPUSH
20885: CALL_OW 182
// end ; if i = 2 then
20889: LD_VAR 0 1
20893: PUSH
20894: LD_INT 2
20896: EQUAL
20897: IFFALSE 20914
// AddComMoveXY ( j , 61 , 93 ) ;
20899: LD_VAR 0 2
20903: PPUSH
20904: LD_INT 61
20906: PPUSH
20907: LD_INT 93
20909: PPUSH
20910: CALL_OW 171
// if i = 1 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 1
20921: EQUAL
20922: IFFALSE 20975
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_VAR 0 3
20933: PUSH
20934: LD_INT 1
20936: ARRAY
20937: PPUSH
20938: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20942: LD_ADDR_VAR 0 3
20946: PUSH
20947: LD_VAR 0 3
20951: PPUSH
20952: LD_INT 1
20954: PPUSH
20955: CALL_OW 3
20959: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20960: LD_VAR 0 2
20964: PPUSH
20965: LD_INT 69
20967: PPUSH
20968: LD_INT 94
20970: PPUSH
20971: CALL_OW 171
// end ; end ;
20975: GO 20738
20977: POP
20978: POP
// end ;
20979: GO 20719
20981: POP
20982: POP
// wait ( 0 0$55 ) ;
20983: LD_INT 1925
20985: PPUSH
20986: CALL_OW 67
// MC_Kill ( 4 ) ;
20990: LD_INT 4
20992: PPUSH
20993: CALL 35277 0 1
// tmp := UnitsInside ( fac ) ;
20997: LD_ADDR_VAR 0 3
21001: PUSH
21002: LD_VAR 0 9
21006: PPUSH
21007: CALL_OW 313
21011: ST_TO_ADDR
// if tmp then
21012: LD_VAR 0 3
21016: IFFALSE 21137
// for i in tmp do
21018: LD_ADDR_VAR 0 1
21022: PUSH
21023: LD_VAR 0 3
21027: PUSH
21028: FOR_IN
21029: IFFALSE 21135
// begin ComExitBuilding ( i ) ;
21031: LD_VAR 0 1
21035: PPUSH
21036: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21040: LD_VAR 0 10
21044: PUSH
21045: LD_INT 2
21047: ARRAY
21048: PPUSH
21049: CALL_OW 313
21053: PUSH
21054: LD_INT 6
21056: LESS
21057: IFFALSE 21079
// AddComEnterUnit ( i , arm [ 2 ] ) else
21059: LD_VAR 0 1
21063: PPUSH
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 2
21071: ARRAY
21072: PPUSH
21073: CALL_OW 180
21077: GO 21133
// if UnitsInside ( arm [ 1 ] ) < 6 then
21079: LD_VAR 0 10
21083: PUSH
21084: LD_INT 1
21086: ARRAY
21087: PPUSH
21088: CALL_OW 313
21092: PUSH
21093: LD_INT 6
21095: LESS
21096: IFFALSE 21118
// AddComEnterUnit ( i , arm [ 1 ] ) else
21098: LD_VAR 0 1
21102: PPUSH
21103: LD_VAR 0 10
21107: PUSH
21108: LD_INT 1
21110: ARRAY
21111: PPUSH
21112: CALL_OW 180
21116: GO 21133
// AddComMoveXY ( i , 37 , 68 ) ;
21118: LD_VAR 0 1
21122: PPUSH
21123: LD_INT 37
21125: PPUSH
21126: LD_INT 68
21128: PPUSH
21129: CALL_OW 171
// end ;
21133: GO 21028
21135: POP
21136: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21137: LD_ADDR_VAR 0 11
21141: PUSH
21142: LD_VAR 0 6
21146: PPUSH
21147: LD_INT 26
21149: PUSH
21150: LD_INT 1
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL_OW 72
21161: PUSH
21162: LD_EXP 59
21166: DIFF
21167: ST_TO_ADDR
// if not speaker then
21168: LD_VAR 0 11
21172: NOT
21173: IFFALSE 21200
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21175: LD_ADDR_VAR 0 11
21179: PUSH
21180: LD_VAR 0 6
21184: PPUSH
21185: LD_INT 26
21187: PUSH
21188: LD_INT 1
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PPUSH
21195: CALL_OW 72
21199: ST_TO_ADDR
// if speaker then
21200: LD_VAR 0 11
21204: IFFALSE 21220
// speaker := speaker [ 1 ] ;
21206: LD_ADDR_VAR 0 11
21210: PUSH
21211: LD_VAR 0 11
21215: PUSH
21216: LD_INT 1
21218: ARRAY
21219: ST_TO_ADDR
// Video ( true ) ;
21220: LD_INT 1
21222: PPUSH
21223: CALL 100907 0 1
// CenterNowOnUnits ( Powell ) ;
21227: LD_EXP 58
21231: PPUSH
21232: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21236: LD_ADDR_VAR 0 3
21240: PUSH
21241: LD_VAR 0 6
21245: PPUSH
21246: LD_INT 3
21248: PUSH
21249: LD_INT 25
21251: PUSH
21252: LD_INT 1
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PPUSH
21263: CALL_OW 72
21267: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21268: LD_ADDR_VAR 0 12
21272: PUSH
21273: LD_INT 22
21275: PUSH
21276: LD_INT 4
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 30
21285: PUSH
21286: LD_INT 32
21288: PUSH
21289: EMPTY
21290: LIST
21291: LIST
21292: PUSH
21293: LD_INT 58
21295: PUSH
21296: EMPTY
21297: LIST
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: LIST
21303: PPUSH
21304: CALL_OW 69
21308: ST_TO_ADDR
// for i = 1 to 6 do
21309: LD_ADDR_VAR 0 1
21313: PUSH
21314: DOUBLE
21315: LD_INT 1
21317: DEC
21318: ST_TO_ADDR
21319: LD_INT 6
21321: PUSH
21322: FOR_TO
21323: IFFALSE 21464
// begin if IsInUnit ( tmp [ i ] ) then
21325: LD_VAR 0 3
21329: PUSH
21330: LD_VAR 0 1
21334: ARRAY
21335: PPUSH
21336: CALL_OW 310
21340: IFFALSE 21357
// ComExitBuilding ( tmp [ i ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21357: LD_VAR 0 3
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: PPUSH
21368: LD_VAR 0 10
21372: PUSH
21373: LD_INT 1
21375: ARRAY
21376: PPUSH
21377: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21381: LD_VAR 0 3
21385: PUSH
21386: LD_VAR 0 1
21390: ARRAY
21391: PPUSH
21392: LD_INT 1
21394: PPUSH
21395: CALL_OW 183
// if emp_towers then
21399: LD_VAR 0 12
21403: IFFALSE 21462
// begin AddComExitBuilding ( tmp [ i ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21420: LD_VAR 0 3
21424: PUSH
21425: LD_VAR 0 1
21429: ARRAY
21430: PPUSH
21431: LD_VAR 0 12
21435: PUSH
21436: LD_INT 1
21438: ARRAY
21439: PPUSH
21440: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21444: LD_ADDR_VAR 0 12
21448: PUSH
21449: LD_VAR 0 12
21453: PPUSH
21454: LD_INT 1
21456: PPUSH
21457: CALL_OW 3
21461: ST_TO_ADDR
// end ; end ;
21462: GO 21322
21464: POP
21465: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21466: LD_ADDR_VAR 0 3
21470: PUSH
21471: LD_EXP 18
21475: PUSH
21476: LD_INT 1
21478: ARRAY
21479: PUSH
21480: LD_EXP 18
21484: PUSH
21485: LD_INT 2
21487: ARRAY
21488: ADD
21489: PPUSH
21490: LD_INT 26
21492: PUSH
21493: LD_INT 1
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: PPUSH
21500: CALL_OW 72
21504: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21505: LD_ADDR_VAR 0 1
21509: PUSH
21510: LD_EXP 18
21514: PUSH
21515: LD_INT 2
21517: ARRAY
21518: PUSH
21519: FOR_IN
21520: IFFALSE 21538
// ComTurnUnit ( i , Powell ) ;
21522: LD_VAR 0 1
21526: PPUSH
21527: LD_EXP 58
21531: PPUSH
21532: CALL_OW 119
21536: GO 21519
21538: POP
21539: POP
// Say ( Powell , D5-Pow-1 ) ;
21540: LD_EXP 58
21544: PPUSH
21545: LD_STRING D5-Pow-1
21547: PPUSH
21548: CALL_OW 88
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21574
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21558: LD_VAR 0 3
21562: PUSH
21563: LD_INT 1
21565: ARRAY
21566: PPUSH
21567: LD_STRING D5-Sol2-1
21569: PPUSH
21570: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21574: LD_EXP 58
21578: PPUSH
21579: LD_STRING D5-Pow-2
21581: PPUSH
21582: CALL_OW 88
// if tmp > 1 then
21586: LD_VAR 0 3
21590: PUSH
21591: LD_INT 1
21593: GREATER
21594: IFFALSE 21612
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21596: LD_VAR 0 3
21600: PUSH
21601: LD_INT 2
21603: ARRAY
21604: PPUSH
21605: LD_STRING D5-Sol2-2
21607: PPUSH
21608: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21612: LD_EXP 58
21616: PPUSH
21617: LD_STRING D5-Pow-3
21619: PPUSH
21620: CALL_OW 88
// wait ( 0 0$1 ) ;
21624: LD_INT 35
21626: PPUSH
21627: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21631: LD_ADDR_VAR 0 3
21635: PUSH
21636: LD_EXP 18
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: PUSH
21645: LD_EXP 18
21649: PUSH
21650: LD_INT 2
21652: ARRAY
21653: UNION
21654: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21655: LD_VAR 0 3
21659: PPUSH
21660: LD_INT 80
21662: PPUSH
21663: LD_INT 67
21665: PPUSH
21666: CALL_OW 114
// wait ( 0 0$2 ) ;
21670: LD_INT 70
21672: PPUSH
21673: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21677: LD_INT 79
21679: PPUSH
21680: LD_INT 72
21682: PPUSH
21683: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21687: LD_INT 35
21689: PPUSH
21690: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21694: LD_VAR 0 3
21698: PPUSH
21699: LD_INT 3
21701: PUSH
21702: LD_INT 24
21704: PUSH
21705: LD_INT 1000
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: PPUSH
21716: CALL_OW 72
21720: IFFALSE 21687
// Say ( Powell , D5a-Pow-1 ) ;
21722: LD_EXP 58
21726: PPUSH
21727: LD_STRING D5a-Pow-1
21729: PPUSH
21730: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21734: LD_EXP 58
21738: PPUSH
21739: LD_STRING D5a-Pow-1a
21741: PPUSH
21742: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21746: LD_INT 10
21748: PPUSH
21749: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21753: LD_EXP 58
21757: PPUSH
21758: LD_STRING D5a-Pow-1b
21760: PPUSH
21761: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21765: LD_EXP 58
21769: PPUSH
21770: LD_STRING D5a-Pow-1c
21772: PPUSH
21773: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21777: LD_EXP 58
21781: PPUSH
21782: LD_STRING D5a-Pow-1d
21784: PPUSH
21785: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21789: LD_INT 35
21791: PPUSH
21792: CALL_OW 67
// if not HasTask ( tmp ) then
21796: LD_VAR 0 3
21800: PPUSH
21801: CALL_OW 314
21805: NOT
21806: IFFALSE 21823
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 80
21815: PPUSH
21816: LD_INT 67
21818: PPUSH
21819: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21823: LD_VAR 0 3
21827: PPUSH
21828: LD_INT 24
21830: PUSH
21831: LD_INT 1
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PPUSH
21838: CALL_OW 72
21842: NOT
21843: IFFALSE 21789
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21845: LD_ADDR_VAR 0 3
21849: PUSH
21850: LD_INT 22
21852: PUSH
21853: LD_INT 4
21855: PUSH
21856: EMPTY
21857: LIST
21858: LIST
21859: PUSH
21860: LD_INT 92
21862: PUSH
21863: LD_INT 60
21865: PUSH
21866: LD_INT 93
21868: PUSH
21869: LD_INT 10
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: PUSH
21878: LD_INT 3
21880: PUSH
21881: LD_INT 54
21883: PUSH
21884: EMPTY
21885: LIST
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: LIST
21895: PPUSH
21896: CALL_OW 69
21900: PUSH
21901: LD_EXP 58
21905: DIFF
21906: ST_TO_ADDR
// if tmp then
21907: LD_VAR 0 3
21911: IFFALSE 21945
// for i in tmp do
21913: LD_ADDR_VAR 0 1
21917: PUSH
21918: LD_VAR 0 3
21922: PUSH
21923: FOR_IN
21924: IFFALSE 21943
// ComMoveXY ( i , 36 , 67 ) ;
21926: LD_VAR 0 1
21930: PPUSH
21931: LD_INT 36
21933: PPUSH
21934: LD_INT 67
21936: PPUSH
21937: CALL_OW 111
21941: GO 21923
21943: POP
21944: POP
// wait ( 0 0$3 ) ;
21945: LD_INT 105
21947: PPUSH
21948: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21952: LD_VAR 0 11
21956: PPUSH
21957: LD_STRING D6-Sol3-1
21959: PPUSH
21960: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21964: LD_EXP 58
21968: PPUSH
21969: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21973: LD_EXP 58
21977: PPUSH
21978: LD_STRING D6-Pow-1
21980: PPUSH
21981: CALL_OW 88
// tmp := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// for i = 1 to 2 do
21992: LD_ADDR_VAR 0 1
21996: PUSH
21997: DOUBLE
21998: LD_INT 1
22000: DEC
22001: ST_TO_ADDR
22002: LD_INT 2
22004: PUSH
22005: FOR_TO
22006: IFFALSE 22120
// begin uc_side := 8 ;
22008: LD_ADDR_OWVAR 20
22012: PUSH
22013: LD_INT 8
22015: ST_TO_ADDR
// uc_nation := 2 ;
22016: LD_ADDR_OWVAR 21
22020: PUSH
22021: LD_INT 2
22023: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22024: LD_INT 14
22026: PPUSH
22027: LD_INT 3
22029: PPUSH
22030: LD_INT 2
22032: PPUSH
22033: LD_INT 29
22035: PPUSH
22036: LD_INT 100
22038: PPUSH
22039: CALL 69889 0 5
// veh := CreateVehicle ;
22043: LD_ADDR_VAR 0 13
22047: PUSH
22048: CALL_OW 45
22052: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22053: LD_VAR 0 13
22057: PPUSH
22058: LD_INT 4
22060: PPUSH
22061: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22065: LD_VAR 0 13
22069: PPUSH
22070: LD_INT 99
22072: PPUSH
22073: LD_INT 83
22075: PPUSH
22076: LD_INT 6
22078: PPUSH
22079: LD_INT 0
22081: PPUSH
22082: CALL_OW 50
// wait ( 3 ) ;
22086: LD_INT 3
22088: PPUSH
22089: CALL_OW 67
// Connect ( veh ) ;
22093: LD_VAR 0 13
22097: PPUSH
22098: CALL 72944 0 1
// tmp := tmp ^ veh ;
22102: LD_ADDR_VAR 0 3
22106: PUSH
22107: LD_VAR 0 3
22111: PUSH
22112: LD_VAR 0 13
22116: ADD
22117: ST_TO_ADDR
// end ;
22118: GO 22005
22120: POP
22121: POP
// wait ( 0 0$1 ) ;
22122: LD_INT 35
22124: PPUSH
22125: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22129: LD_INT 99
22131: PPUSH
22132: LD_INT 83
22134: PPUSH
22135: LD_INT 1
22137: PPUSH
22138: LD_INT 10
22140: PPUSH
22141: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22145: LD_INT 99
22147: PPUSH
22148: LD_INT 83
22150: PPUSH
22151: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22155: LD_VAR 0 11
22159: PPUSH
22160: LD_STRING D6-Sol3-2
22162: PPUSH
22163: CALL_OW 88
// async ;
22167: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22168: LD_EXP 58
22172: PPUSH
22173: LD_STRING D6-Pow-2
22175: PPUSH
22176: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22180: LD_VAR 0 3
22184: PUSH
22185: LD_INT 1
22187: ARRAY
22188: PPUSH
22189: LD_VAR 0 9
22193: PPUSH
22194: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22198: LD_VAR 0 3
22202: PUSH
22203: LD_INT 2
22205: ARRAY
22206: PPUSH
22207: LD_INT 22
22209: PUSH
22210: LD_INT 4
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PUSH
22217: LD_INT 21
22219: PUSH
22220: LD_INT 3
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: PPUSH
22231: CALL_OW 69
22235: PPUSH
22236: LD_VAR 0 3
22240: PUSH
22241: LD_INT 2
22243: ARRAY
22244: PPUSH
22245: CALL_OW 74
22249: PPUSH
22250: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22254: LD_EXP 58
22258: PPUSH
22259: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22263: LD_INT 99
22265: PPUSH
22266: LD_INT 83
22268: PPUSH
22269: LD_INT 1
22271: PPUSH
22272: CALL_OW 331
// repeat wait ( 4 ) ;
22276: LD_INT 4
22278: PPUSH
22279: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22283: LD_VAR 0 3
22287: PUSH
22288: LD_INT 1
22290: ARRAY
22291: PPUSH
22292: CALL_OW 256
22296: PUSH
22297: LD_INT 1000
22299: LESS
22300: IFFALSE 22318
// SetLives ( tmp [ 1 ] , 1000 ) ;
22302: LD_VAR 0 3
22306: PUSH
22307: LD_INT 1
22309: ARRAY
22310: PPUSH
22311: LD_INT 1000
22313: PPUSH
22314: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22318: LD_INT 22
22320: PUSH
22321: LD_INT 4
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PUSH
22328: LD_INT 30
22330: PUSH
22331: LD_INT 3
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: PPUSH
22342: CALL_OW 69
22346: PUSH
22347: LD_INT 0
22349: EQUAL
22350: IFFALSE 22276
// sync ;
22352: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22353: LD_EXP 58
22357: PPUSH
22358: LD_STRING D6a-Pow-1
22360: PPUSH
22361: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22365: LD_VAR 0 11
22369: PPUSH
22370: LD_STRING D6a-Sol3-1
22372: PPUSH
22373: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22377: LD_EXP 58
22381: PPUSH
22382: LD_STRING D6a-Pow-2
22384: PPUSH
22385: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22389: LD_VAR 0 11
22393: PPUSH
22394: LD_STRING D6a-Sol3-2
22396: PPUSH
22397: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22401: LD_EXP 58
22405: PPUSH
22406: LD_STRING D6a-Pow-3
22408: PPUSH
22409: CALL_OW 88
// powellCenterCameraMode := true ;
22413: LD_ADDR_EXP 20
22417: PUSH
22418: LD_INT 1
22420: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22421: LD_ADDR_VAR 0 1
22425: PUSH
22426: LD_INT 22
22428: PUSH
22429: LD_INT 8
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: PUSH
22436: LD_INT 25
22438: PUSH
22439: LD_INT 2
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: PPUSH
22450: CALL_OW 69
22454: PUSH
22455: FOR_IN
22456: IFFALSE 22511
// begin SetTag ( i , 1 ) ;
22458: LD_VAR 0 1
22462: PPUSH
22463: LD_INT 1
22465: PPUSH
22466: CALL_OW 109
// ComExitBuilding ( i ) ;
22470: LD_VAR 0 1
22474: PPUSH
22475: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 35
22486: PPUSH
22487: LD_INT 6
22489: PPUSH
22490: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22494: LD_VAR 0 1
22498: PPUSH
22499: LD_INT 53
22501: PPUSH
22502: LD_INT 4
22504: PPUSH
22505: CALL_OW 171
// end ;
22509: GO 22455
22511: POP
22512: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22513: LD_ADDR_VAR 0 3
22517: PUSH
22518: LD_INT 22
22520: PUSH
22521: LD_INT 4
22523: PUSH
22524: EMPTY
22525: LIST
22526: LIST
22527: PUSH
22528: LD_INT 21
22530: PUSH
22531: LD_INT 2
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 3
22540: PUSH
22541: LD_INT 34
22543: PUSH
22544: LD_INT 12
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 69
22564: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22565: LD_EXP 58
22569: PPUSH
22570: LD_VAR 0 3
22574: PPUSH
22575: LD_EXP 58
22579: PPUSH
22580: CALL_OW 74
22584: PPUSH
22585: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 88
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 100
22611: PPUSH
22612: LD_INT 75
22614: PPUSH
22615: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22619: LD_EXP 58
22623: PPUSH
22624: LD_INT 88
22626: PPUSH
22627: LD_INT 53
22629: PPUSH
22630: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22634: LD_INT 8
22636: PPUSH
22637: LD_EXP 58
22641: PPUSH
22642: CALL_OW 471
// repeat wait ( 3 ) ;
22646: LD_INT 3
22648: PPUSH
22649: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22653: LD_INT 22
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 92
22665: PUSH
22666: LD_INT 100
22668: PUSH
22669: LD_INT 75
22671: PUSH
22672: LD_INT 6
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: PPUSH
22685: CALL_OW 69
22689: IFFALSE 22646
// async ;
22691: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22692: LD_EXP 58
22696: PPUSH
22697: LD_STRING D6b-Pow-1
22699: PPUSH
22700: CALL_OW 88
// repeat wait ( 3 ) ;
22704: LD_INT 3
22706: PPUSH
22707: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22711: LD_EXP 58
22715: PPUSH
22716: CALL_OW 310
22720: PPUSH
22721: CALL_OW 256
22725: PUSH
22726: LD_INT 1000
22728: LESS
22729: IFFALSE 22748
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22731: LD_EXP 58
22735: PPUSH
22736: CALL_OW 310
22740: PPUSH
22741: LD_INT 1000
22743: PPUSH
22744: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22748: LD_EXP 58
22752: PPUSH
22753: CALL_OW 256
22757: PUSH
22758: LD_INT 1000
22760: LESS
22761: IFFALSE 22775
// SetLives ( Powell , 1000 ) ;
22763: LD_EXP 58
22767: PPUSH
22768: LD_INT 1000
22770: PPUSH
22771: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22775: LD_EXP 58
22779: PPUSH
22780: LD_EXP 63
22784: PPUSH
22785: CALL_OW 296
22789: PUSH
22790: LD_INT 5
22792: LESS
22793: PUSH
22794: LD_EXP 58
22798: PPUSH
22799: CALL_OW 310
22803: PPUSH
22804: LD_EXP 63
22808: PPUSH
22809: CALL_OW 296
22813: PUSH
22814: LD_INT 5
22816: LESS
22817: OR
22818: IFFALSE 22837
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22820: LD_EXP 58
22824: PPUSH
22825: CALL_OW 310
22829: PPUSH
22830: LD_INT 100
22832: PPUSH
22833: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22837: LD_EXP 58
22841: PPUSH
22842: CALL_OW 310
22846: NOT
22847: IFFALSE 22704
// DoNotAttack ( 8 , powellBomb ) ;
22849: LD_INT 8
22851: PPUSH
22852: LD_EXP 63
22856: PPUSH
22857: CALL_OW 471
// game_speed := 4 ;
22861: LD_ADDR_OWVAR 65
22865: PUSH
22866: LD_INT 4
22868: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22869: LD_EXP 58
22873: PPUSH
22874: LD_STRING D6b-Pow-1a
22876: PPUSH
22877: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22881: LD_EXP 58
22885: PPUSH
22886: LD_EXP 63
22890: PPUSH
22891: CALL_OW 180
// sync ;
22895: SYNC
// repeat wait ( 0 0$1 ) ;
22896: LD_INT 35
22898: PPUSH
22899: CALL_OW 67
// until IsInUnit ( Powell ) ;
22903: LD_EXP 58
22907: PPUSH
22908: CALL_OW 310
22912: IFFALSE 22896
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22914: LD_INT 8
22916: PPUSH
22917: LD_EXP 58
22921: PPUSH
22922: CALL_OW 310
22926: PPUSH
22927: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 91
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 44
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 96
22968: PPUSH
22969: LD_INT 41
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 92
22983: PPUSH
22984: LD_INT 39
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 88
22998: PPUSH
22999: LD_INT 41
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 91
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 44
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 96
23043: PPUSH
23044: LD_INT 41
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 92
23058: PPUSH
23059: LD_INT 39
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 88
23073: PPUSH
23074: LD_INT 41
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 91
23088: PPUSH
23089: LD_INT 44
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 39
23106: PPUSH
23107: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23111: LD_EXP 58
23115: PPUSH
23116: LD_INT 93
23118: PPUSH
23119: LD_INT 36
23121: PPUSH
23122: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23126: LD_INT 122
23128: PPUSH
23129: CALL_OW 67
// game_speed := 4 ;
23133: LD_ADDR_OWVAR 65
23137: PUSH
23138: LD_INT 4
23140: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23141: LD_EXP 58
23145: PPUSH
23146: LD_STRING D6b-Pow-1b
23148: PPUSH
23149: CALL_OW 88
// tmp := [ ] ;
23153: LD_ADDR_VAR 0 3
23157: PUSH
23158: EMPTY
23159: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23160: LD_ADDR_VAR 0 5
23164: PUSH
23165: LD_INT 78
23167: PUSH
23168: LD_INT 47
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: PUSH
23175: LD_INT 106
23177: PUSH
23178: LD_INT 53
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23189: LD_ADDR_VAR 0 1
23193: PUSH
23194: LD_INT 22
23196: PUSH
23197: LD_INT 8
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: PUSH
23204: LD_INT 21
23206: PUSH
23207: LD_INT 3
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 92
23216: PUSH
23217: LD_INT 90
23219: PUSH
23220: LD_INT 52
23222: PUSH
23223: LD_INT 12
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: LIST
23236: PPUSH
23237: CALL_OW 69
23241: PUSH
23242: FOR_IN
23243: IFFALSE 23268
// tmp := tmp ^ UnitsInside ( i ) ;
23245: LD_ADDR_VAR 0 3
23249: PUSH
23250: LD_VAR 0 3
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 313
23264: ADD
23265: ST_TO_ADDR
23266: GO 23242
23268: POP
23269: POP
// for i in tmp do
23270: LD_ADDR_VAR 0 1
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: FOR_IN
23281: IFFALSE 23443
// begin dist := 9999 ;
23283: LD_ADDR_VAR 0 8
23287: PUSH
23288: LD_INT 9999
23290: ST_TO_ADDR
// _xy := [ ] ;
23291: LD_ADDR_VAR 0 7
23295: PUSH
23296: EMPTY
23297: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23298: LD_VAR 0 1
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: CALL_OW 109
// ComExitBuilding ( i ) ;
23310: LD_VAR 0 1
23314: PPUSH
23315: CALL_OW 122
// for j in xy do
23319: LD_ADDR_VAR 0 2
23323: PUSH
23324: LD_VAR 0 5
23328: PUSH
23329: FOR_IN
23330: IFFALSE 23412
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23332: LD_VAR 0 1
23336: PPUSH
23337: LD_VAR 0 2
23341: PUSH
23342: LD_INT 1
23344: ARRAY
23345: PPUSH
23346: LD_VAR 0 2
23350: PUSH
23351: LD_INT 2
23353: ARRAY
23354: PPUSH
23355: CALL_OW 297
23359: PUSH
23360: LD_VAR 0 8
23364: LESS
23365: IFFALSE 23410
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23367: LD_ADDR_VAR 0 8
23371: PUSH
23372: LD_VAR 0 1
23376: PPUSH
23377: LD_VAR 0 2
23381: PUSH
23382: LD_INT 1
23384: ARRAY
23385: PPUSH
23386: LD_VAR 0 2
23390: PUSH
23391: LD_INT 2
23393: ARRAY
23394: PPUSH
23395: CALL_OW 297
23399: ST_TO_ADDR
// _xy := j ;
23400: LD_ADDR_VAR 0 7
23404: PUSH
23405: LD_VAR 0 2
23409: ST_TO_ADDR
// end ;
23410: GO 23329
23412: POP
23413: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23414: LD_VAR 0 1
23418: PPUSH
23419: LD_VAR 0 7
23423: PUSH
23424: LD_INT 1
23426: ARRAY
23427: PPUSH
23428: LD_VAR 0 7
23432: PUSH
23433: LD_INT 2
23435: ARRAY
23436: PPUSH
23437: CALL_OW 171
// end ;
23441: GO 23280
23443: POP
23444: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 3
23454: PPUSH
23455: LD_INT 26
23457: PUSH
23458: LD_INT 1
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 25
23467: PUSH
23468: LD_INT 1
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PPUSH
23479: CALL_OW 72
23483: ST_TO_ADDR
// if tmp2 < 2 then
23484: LD_VAR 0 4
23488: PUSH
23489: LD_INT 2
23491: LESS
23492: IFFALSE 23561
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23494: LD_ADDR_VAR 0 4
23498: PUSH
23499: LD_INT 22
23501: PUSH
23502: LD_INT 8
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: LD_INT 26
23511: PUSH
23512: LD_INT 1
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: PUSH
23519: LD_INT 3
23521: PUSH
23522: LD_INT 25
23524: PUSH
23525: LD_INT 15
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: PUSH
23532: EMPTY
23533: LIST
23534: LIST
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: LIST
23540: PPUSH
23541: CALL_OW 69
23545: PUSH
23546: LD_EXP 60
23550: PUSH
23551: LD_EXP 61
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: DIFF
23560: ST_TO_ADDR
// if tmp2 then
23561: LD_VAR 0 4
23565: IFFALSE 23583
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23567: LD_VAR 0 4
23571: PUSH
23572: LD_INT 1
23574: ARRAY
23575: PPUSH
23576: LD_STRING D6b-ArSol1-1
23578: PPUSH
23579: CALL_OW 88
// async ;
23583: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23584: LD_EXP 58
23588: PPUSH
23589: LD_STRING D6b-Pow-2
23591: PPUSH
23592: CALL_OW 88
// wait ( 0 0$1 ) ;
23596: LD_INT 35
23598: PPUSH
23599: CALL_OW 67
// if tmp2 > 1 then
23603: LD_VAR 0 4
23607: PUSH
23608: LD_INT 1
23610: GREATER
23611: IFFALSE 23629
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23613: LD_VAR 0 4
23617: PUSH
23618: LD_INT 2
23620: ARRAY
23621: PPUSH
23622: LD_STRING D6b-ArSol2-1
23624: PPUSH
23625: CALL_OW 88
// sync ;
23629: SYNC
// repeat wait ( 5 ) ;
23630: LD_INT 5
23632: PPUSH
23633: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23637: LD_INT 93
23639: PPUSH
23640: LD_INT 36
23642: PPUSH
23643: CALL_OW 428
23647: PPUSH
23648: CALL_OW 255
23652: PUSH
23653: LD_INT 4
23655: EQUAL
23656: IFFALSE 23630
// DialogueOn ;
23658: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23662: LD_INT 10
23664: PPUSH
23665: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23669: LD_EXP 58
23673: PPUSH
23674: LD_STRING D6b-Pow-2a
23676: PPUSH
23677: CALL_OW 88
// DialogueOff ;
23681: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23685: LD_EXP 58
23689: PPUSH
23690: CALL_OW 310
23694: PPUSH
23695: LD_INT 332
23697: PPUSH
23698: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23702: LD_INT 93
23704: PPUSH
23705: LD_INT 35
23707: PPUSH
23708: LD_INT 1
23710: PPUSH
23711: LD_INT 6
23713: NEG
23714: PPUSH
23715: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23719: LD_INT 35
23721: PPUSH
23722: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23726: LD_INT 332
23728: PPUSH
23729: CALL_OW 256
23733: PUSH
23734: LD_INT 1000
23736: LESS
23737: PUSH
23738: LD_INT 332
23740: PPUSH
23741: CALL_OW 300
23745: AND
23746: IFFALSE 23758
// SetLives ( kozlov_fac , 0 ) ;
23748: LD_INT 332
23750: PPUSH
23751: LD_INT 0
23753: PPUSH
23754: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23758: LD_INT 332
23760: PPUSH
23761: CALL_OW 301
23765: PUSH
23766: LD_EXP 58
23770: PPUSH
23771: CALL_OW 301
23775: OR
23776: IFFALSE 23719
// game_speed := 4 ;
23778: LD_ADDR_OWVAR 65
23782: PUSH
23783: LD_INT 4
23785: ST_TO_ADDR
// powellCenterCameraMode := false ;
23786: LD_ADDR_EXP 20
23790: PUSH
23791: LD_INT 0
23793: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23794: LD_ADDR_VAR 0 1
23798: PUSH
23799: LD_VAR 0 3
23803: PUSH
23804: LD_INT 22
23806: PUSH
23807: LD_INT 8
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: LD_INT 25
23816: PUSH
23817: LD_INT 2
23819: PUSH
23820: EMPTY
23821: LIST
23822: LIST
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PPUSH
23828: CALL_OW 69
23832: UNION
23833: PUSH
23834: FOR_IN
23835: IFFALSE 23851
// SetTag ( i , 0 ) ;
23837: LD_VAR 0 1
23841: PPUSH
23842: LD_INT 0
23844: PPUSH
23845: CALL_OW 109
23849: GO 23834
23851: POP
23852: POP
// wait ( 0 0$3 ) ;
23853: LD_INT 105
23855: PPUSH
23856: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23860: LD_INT 93
23862: PPUSH
23863: LD_INT 35
23865: PPUSH
23866: LD_INT 1
23868: PPUSH
23869: CALL_OW 331
// DialogueOn ;
23873: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23877: LD_VAR 0 11
23881: PPUSH
23882: LD_STRING D6c-Sol3-1
23884: PPUSH
23885: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23889: LD_INT 10
23891: PPUSH
23892: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23896: LD_EXP 39
23900: PPUSH
23901: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23905: LD_EXP 39
23909: PPUSH
23910: LD_STRING D6c-JMM-1
23912: PPUSH
23913: CALL_OW 88
// if Cyrus then
23917: LD_EXP 45
23921: IFFALSE 23935
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23923: LD_EXP 45
23927: PPUSH
23928: LD_STRING D6c-Cyrus-1
23930: PPUSH
23931: CALL_OW 88
// if Bobby then
23935: LD_EXP 44
23939: IFFALSE 23953
// Say ( Bobby , D6c-Bobby-1 ) ;
23941: LD_EXP 44
23945: PPUSH
23946: LD_STRING D6c-Bobby-1
23948: PPUSH
23949: CALL_OW 88
// if Cornel then
23953: LD_EXP 50
23957: IFFALSE 23971
// Say ( Cornel , D6c-Corn-1 ) ;
23959: LD_EXP 50
23963: PPUSH
23964: LD_STRING D6c-Corn-1
23966: PPUSH
23967: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23971: LD_ADDR_VAR 0 4
23975: PUSH
23976: LD_INT 2
23978: PUSH
23979: LD_INT 22
23981: PUSH
23982: LD_INT 1
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 22
23991: PUSH
23992: LD_INT 4
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: LIST
24003: PUSH
24004: LD_INT 26
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 3
24016: PUSH
24017: LD_INT 25
24019: PUSH
24020: LD_INT 16
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 25
24029: PUSH
24030: LD_INT 12
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: LIST
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: PPUSH
24047: CALL_OW 69
24051: PUSH
24052: LD_VAR 0 11
24056: PUSH
24057: LD_EXP 39
24061: UNION
24062: PUSH
24063: LD_EXP 59
24067: UNION
24068: PUSH
24069: EMPTY
24070: LIST
24071: DIFF
24072: ST_TO_ADDR
// if tmp2 then
24073: LD_VAR 0 4
24077: IFFALSE 24095
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24079: LD_VAR 0 4
24083: PUSH
24084: LD_INT 1
24086: ARRAY
24087: PPUSH
24088: LD_STRING D6c-Sol1-1
24090: PPUSH
24091: CALL_OW 88
// if Lisa then
24095: LD_EXP 42
24099: IFFALSE 24113
// Say ( Lisa , D6c-Lisa-1 ) ;
24101: LD_EXP 42
24105: PPUSH
24106: LD_STRING D6c-Lisa-1
24108: PPUSH
24109: CALL_OW 88
// if Gary then
24113: LD_EXP 51
24117: IFFALSE 24131
// Say ( Gary , D6c-Gary-1 ) ;
24119: LD_EXP 51
24123: PPUSH
24124: LD_STRING D6c-Gary-1
24126: PPUSH
24127: CALL_OW 88
// if Donaldson then
24131: LD_EXP 43
24135: IFFALSE 24149
// Say ( Donaldson , D6c-Don-1 ) ;
24137: LD_EXP 43
24141: PPUSH
24142: LD_STRING D6c-Don-1
24144: PPUSH
24145: CALL_OW 88
// if tmp2 > 1 then
24149: LD_VAR 0 4
24153: PUSH
24154: LD_INT 1
24156: GREATER
24157: IFFALSE 24175
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24159: LD_VAR 0 4
24163: PUSH
24164: LD_INT 2
24166: ARRAY
24167: PPUSH
24168: LD_STRING D6c-Sol2-1
24170: PPUSH
24171: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24175: LD_VAR 0 11
24179: PPUSH
24180: LD_STRING D6c-Sol3-2
24182: PPUSH
24183: CALL_OW 88
// dwait ( 0 0$1 ) ;
24187: LD_INT 35
24189: PPUSH
24190: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24194: LD_EXP 39
24198: PPUSH
24199: LD_STRING D6c-JMM-2
24201: PPUSH
24202: CALL_OW 88
// DialogueOff ;
24206: CALL_OW 7
// Video ( false ) ;
24210: LD_INT 0
24212: PPUSH
24213: CALL 100907 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24217: LD_INT 22
24219: PUSH
24220: LD_INT 4
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PPUSH
24227: CALL_OW 69
24231: PPUSH
24232: LD_INT 1
24234: PPUSH
24235: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 4
24244: PPUSH
24245: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24249: LD_ADDR_VAR 0 1
24253: PUSH
24254: LD_INT 4
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: LD_INT 2
24262: PPUSH
24263: CALL 65128 0 3
24267: PUSH
24268: FOR_IN
24269: IFFALSE 24306
// if GetTech ( i , 1 ) <> state_researched then
24271: LD_VAR 0 1
24275: PPUSH
24276: LD_INT 1
24278: PPUSH
24279: CALL_OW 321
24283: PUSH
24284: LD_INT 2
24286: NONEQUAL
24287: IFFALSE 24304
// SetTech ( i , 1 , state_researched ) ;
24289: LD_VAR 0 1
24293: PPUSH
24294: LD_INT 1
24296: PPUSH
24297: LD_INT 2
24299: PPUSH
24300: CALL_OW 322
24304: GO 24268
24306: POP
24307: POP
// missionStage := 6 ;
24308: LD_ADDR_EXP 15
24312: PUSH
24313: LD_INT 6
24315: ST_TO_ADDR
// activeAttacks := true ;
24316: LD_ADDR_EXP 16
24320: PUSH
24321: LD_INT 1
24323: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24324: LD_STRING M2
24326: PPUSH
24327: CALL_OW 337
// SaveForQuickRestart ;
24331: CALL_OW 22
// wait ( 0 0$40 ) ;
24335: LD_INT 1400
24337: PPUSH
24338: CALL_OW 67
// DialogueOn ;
24342: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24346: LD_EXP 62
24350: PPUSH
24351: LD_STRING D7-Friend-1
24353: PPUSH
24354: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24358: LD_EXP 39
24362: PPUSH
24363: LD_STRING D7-JMM-1
24365: PPUSH
24366: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24370: LD_EXP 62
24374: PPUSH
24375: LD_STRING D7-Friend-2
24377: PPUSH
24378: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24382: LD_EXP 39
24386: PPUSH
24387: LD_STRING D7-JMM-2
24389: PPUSH
24390: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24394: LD_EXP 62
24398: PPUSH
24399: LD_STRING D7-Friend-3
24401: PPUSH
24402: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24406: LD_EXP 39
24410: PPUSH
24411: LD_STRING D7-JMM-3
24413: PPUSH
24414: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24418: LD_EXP 62
24422: PPUSH
24423: LD_STRING D7-Friend-4
24425: PPUSH
24426: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24430: LD_EXP 39
24434: PPUSH
24435: LD_STRING D7-JMM-4
24437: PPUSH
24438: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24442: LD_EXP 62
24446: PPUSH
24447: LD_STRING D7-Friend-5
24449: PPUSH
24450: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24454: LD_EXP 39
24458: PPUSH
24459: LD_STRING D7-JMM-5
24461: PPUSH
24462: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24466: LD_EXP 62
24470: PPUSH
24471: LD_STRING D7-Friend-6
24473: PPUSH
24474: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24478: LD_EXP 39
24482: PPUSH
24483: LD_STRING D7-JMM-6
24485: PPUSH
24486: CALL_OW 88
// DialogueOff ;
24490: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24494: LD_STRING Mlegion
24496: PPUSH
24497: CALL_OW 337
// RebuildKozlovFactory ;
24501: CALL 4855 0 0
// end ;
24505: PPOPN 13
24507: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24508: LD_EXP 20
24512: PUSH
24513: LD_EXP 58
24517: PPUSH
24518: CALL_OW 300
24522: AND
24523: IFFALSE 24565
24525: GO 24527
24527: DISABLE
// begin enable ;
24528: ENABLE
// if IsInUnit ( Powell ) then
24529: LD_EXP 58
24533: PPUSH
24534: CALL_OW 310
24538: IFFALSE 24556
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24540: LD_EXP 58
24544: PPUSH
24545: CALL_OW 310
24549: PPUSH
24550: CALL_OW 85
24554: GO 24565
// CenterOnUnits ( Powell ) ;
24556: LD_EXP 58
24560: PPUSH
24561: CALL_OW 85
// end ;
24565: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24566: LD_INT 22
24568: PUSH
24569: LD_INT 8
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: LD_INT 34
24578: PUSH
24579: LD_INT 48
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 69
24594: IFFALSE 24868
24596: GO 24598
24598: DISABLE
24599: LD_INT 0
24601: PPUSH
24602: PPUSH
// begin if missionStage < 9 then
24603: LD_EXP 15
24607: PUSH
24608: LD_INT 9
24610: LESS
24611: IFFALSE 24621
// missionStage := 9 ;
24613: LD_ADDR_EXP 15
24617: PUSH
24618: LD_INT 9
24620: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24621: LD_ADDR_VAR 0 1
24625: PUSH
24626: LD_INT 22
24628: PUSH
24629: LD_INT 8
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: LD_INT 34
24638: PUSH
24639: LD_INT 48
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PPUSH
24650: CALL_OW 69
24654: PUSH
24655: LD_INT 1
24657: ARRAY
24658: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24659: LD_INT 175
24661: PPUSH
24662: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24666: LD_EXP 12
24670: PUSH
24671: LD_EXP 3
24675: PUSH
24676: LD_INT 0
24678: PUSH
24679: LD_INT 2
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: IN
24686: OR
24687: IFFALSE 24710
// target := [ 68 , 108 , 1 ] else
24689: LD_ADDR_VAR 0 2
24693: PUSH
24694: LD_INT 68
24696: PUSH
24697: LD_INT 108
24699: PUSH
24700: LD_INT 1
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: LIST
24707: ST_TO_ADDR
24708: GO 24729
// target := [ 181 , 88 , 2 ] ;
24710: LD_ADDR_VAR 0 2
24714: PUSH
24715: LD_INT 181
24717: PUSH
24718: LD_INT 88
24720: PUSH
24721: LD_INT 2
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: LIST
24728: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24729: LD_VAR 0 1
24733: PPUSH
24734: LD_VAR 0 2
24738: PUSH
24739: LD_INT 1
24741: ARRAY
24742: PPUSH
24743: LD_VAR 0 2
24747: PUSH
24748: LD_INT 2
24750: ARRAY
24751: PPUSH
24752: CALL_OW 176
// if target [ 3 ] = 1 then
24756: LD_VAR 0 2
24760: PUSH
24761: LD_INT 3
24763: ARRAY
24764: PUSH
24765: LD_INT 1
24767: EQUAL
24768: IFFALSE 24784
// SayRadio ( Kurt , D12-Kurt-1 ) else
24770: LD_EXP 60
24774: PPUSH
24775: LD_STRING D12-Kurt-1
24777: PPUSH
24778: CALL_OW 94
24782: GO 24808
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24784: LD_EXP 60
24788: PPUSH
24789: LD_STRING D12a-Kurt-1
24791: PPUSH
24792: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24796: LD_EXP 74
24800: PPUSH
24801: LD_STRING D12a-Roth-1
24803: PPUSH
24804: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24808: LD_INT 350
24810: PPUSH
24811: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24815: LD_VAR 0 1
24819: PPUSH
24820: LD_INT 22
24822: PUSH
24823: LD_INT 8
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: PUSH
24830: LD_INT 23
24832: PUSH
24833: LD_INT 2
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 30
24842: PUSH
24843: LD_INT 3
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: PUSH
24860: LD_INT 1
24862: ARRAY
24863: PPUSH
24864: CALL_OW 228
// end ;
24868: PPOPN 2
24870: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24871: LD_EXP 60
24875: PPUSH
24876: CALL_OW 256
24880: PUSH
24881: LD_INT 999
24883: LESS
24884: PUSH
24885: LD_INT 22
24887: PUSH
24888: LD_INT 8
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: PUSH
24895: LD_INT 21
24897: PUSH
24898: LD_INT 1
24900: PUSH
24901: EMPTY
24902: LIST
24903: LIST
24904: PUSH
24905: LD_INT 23
24907: PUSH
24908: LD_INT 2
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 69
24924: PUSH
24925: LD_INT 9
24927: PUSH
24928: LD_INT 8
24930: PUSH
24931: LD_INT 7
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: LIST
24938: PUSH
24939: LD_OWVAR 67
24943: ARRAY
24944: LESSEQUAL
24945: OR
24946: PUSH
24947: LD_INT 22
24949: PUSH
24950: LD_INT 8
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 34
24959: PUSH
24960: LD_INT 48
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PPUSH
24971: CALL_OW 69
24975: NOT
24976: AND
24977: PUSH
24978: LD_EXP 60
24982: PPUSH
24983: CALL_OW 302
24987: AND
24988: PUSH
24989: LD_INT 5
24991: PPUSH
24992: LD_INT 22
24994: PUSH
24995: LD_INT 1
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PPUSH
25002: CALL_OW 70
25006: AND
25007: IFFALSE 25712
25009: GO 25011
25011: DISABLE
25012: LD_INT 0
25014: PPUSH
25015: PPUSH
25016: PPUSH
// begin DialogueOn ;
25017: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25021: LD_EXP 39
25025: PPUSH
25026: LD_STRING D13-JMM-1
25028: PPUSH
25029: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25033: LD_EXP 60
25037: PPUSH
25038: LD_STRING D13-Kurt-1
25040: PPUSH
25041: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25045: LD_EXP 39
25049: PPUSH
25050: LD_STRING D13-JMM-2
25052: PPUSH
25053: CALL_OW 88
// if FakeInfo then
25057: LD_EXP 12
25061: IFFALSE 25081
// begin Say ( Kurt , D13-Kurt-2 ) ;
25063: LD_EXP 60
25067: PPUSH
25068: LD_STRING D13-Kurt-2
25070: PPUSH
25071: CALL_OW 88
// DialogueOff ;
25075: CALL_OW 7
// exit ;
25079: GO 25712
// end ; if not KurtStatus then
25081: LD_EXP 3
25085: NOT
25086: IFFALSE 25102
// Say ( Kurt , D13-Kurt-2b ) else
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2b
25095: PPUSH
25096: CALL_OW 88
25100: GO 25114
// Say ( Kurt , D13-Kurt-2a ) ;
25102: LD_EXP 60
25106: PPUSH
25107: LD_STRING D13-Kurt-2a
25109: PPUSH
25110: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25114: LD_EXP 39
25118: PPUSH
25119: LD_STRING D13-JMM-3
25121: PPUSH
25122: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25126: LD_EXP 60
25130: PPUSH
25131: LD_STRING D13-Kurt-3
25133: PPUSH
25134: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25138: LD_EXP 39
25142: PPUSH
25143: LD_STRING D13-JMM-4
25145: PPUSH
25146: CALL_OW 88
// DialogueOff ;
25150: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25154: LD_STRING MlegionOut
25156: PPUSH
25157: CALL_OW 337
// legionDestroyed := true ;
25161: LD_ADDR_EXP 22
25165: PUSH
25166: LD_INT 1
25168: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25169: LD_INT 3
25171: PPUSH
25172: CALL 35277 0 1
// KillUnit ( Kozlov ) ;
25176: LD_EXP 61
25180: PPUSH
25181: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25185: LD_ADDR_VAR 0 1
25189: PUSH
25190: LD_INT 22
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 23
25202: PUSH
25203: LD_INT 3
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 3
25212: PUSH
25213: LD_INT 21
25215: PUSH
25216: LD_INT 33
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: LIST
25231: PPUSH
25232: CALL_OW 69
25236: PUSH
25237: FOR_IN
25238: IFFALSE 25251
// KillUnit ( i ) ;
25240: LD_VAR 0 1
25244: PPUSH
25245: CALL_OW 66
25249: GO 25237
25251: POP
25252: POP
// ChangeSideFog ( 8 , 1 ) ;
25253: LD_INT 8
25255: PPUSH
25256: LD_INT 1
25258: PPUSH
25259: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25263: LD_ADDR_VAR 0 2
25267: PUSH
25268: LD_INT 22
25270: PUSH
25271: LD_INT 8
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 21
25280: PUSH
25281: LD_INT 1
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PPUSH
25292: CALL_OW 69
25296: PUSH
25297: LD_EXP 61
25301: PUSH
25302: LD_EXP 60
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: DIFF
25311: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25312: LD_VAR 0 2
25316: PUSH
25317: LD_INT 6
25319: PUSH
25320: LD_INT 5
25322: PUSH
25323: LD_INT 4
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: LIST
25330: PUSH
25331: LD_OWVAR 67
25335: ARRAY
25336: GREATEREQUAL
25337: IFFALSE 25511
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_INT 6
25346: PUSH
25347: LD_INT 5
25349: PUSH
25350: LD_INT 4
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_OWVAR 67
25362: ARRAY
25363: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25364: LD_ADDR_VAR 0 1
25368: PUSH
25369: DOUBLE
25370: LD_VAR 0 2
25374: PUSH
25375: LD_VAR 0 3
25379: PUSH
25380: LD_INT 1
25382: PLUS
25383: MINUS
25384: INC
25385: ST_TO_ADDR
25386: LD_INT 1
25388: PUSH
25389: FOR_DOWNTO
25390: IFFALSE 25507
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25392: LD_ADDR_EXP 38
25396: PUSH
25397: LD_EXP 38
25401: PUSH
25402: LD_VAR 0 2
25406: PUSH
25407: LD_VAR 0 1
25411: ARRAY
25412: ADD
25413: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25414: LD_VAR 0 2
25418: PUSH
25419: LD_VAR 0 1
25423: ARRAY
25424: PPUSH
25425: CALL_OW 310
25429: IFFALSE 25446
// ComExitBuilding ( tmp [ i ] ) ;
25431: LD_VAR 0 2
25435: PUSH
25436: LD_VAR 0 1
25440: ARRAY
25441: PPUSH
25442: CALL_OW 122
// if IsInUnit ( i ) then
25446: LD_VAR 0 1
25450: PPUSH
25451: CALL_OW 310
25455: IFFALSE 25472
// ComExitVehicle ( tmp [ i ] ) ;
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 1
25466: ARRAY
25467: PPUSH
25468: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25472: LD_VAR 0 2
25476: PUSH
25477: LD_VAR 0 1
25481: ARRAY
25482: PPUSH
25483: LD_INT 34
25485: PUSH
25486: LD_INT 0
25488: PPUSH
25489: LD_INT 6
25491: PPUSH
25492: CALL_OW 12
25496: PLUS
25497: PPUSH
25498: LD_INT 1
25500: PPUSH
25501: CALL_OW 171
// end ;
25505: GO 25389
25507: POP
25508: POP
// end else
25509: GO 25521
// x := tmp ;
25511: LD_ADDR_VAR 0 3
25515: PUSH
25516: LD_VAR 0 2
25520: ST_TO_ADDR
// for i := tmp downto tmp - x do
25521: LD_ADDR_VAR 0 1
25525: PUSH
25526: DOUBLE
25527: LD_VAR 0 2
25531: INC
25532: ST_TO_ADDR
25533: LD_VAR 0 2
25537: PUSH
25538: LD_VAR 0 3
25542: MINUS
25543: PUSH
25544: FOR_DOWNTO
25545: IFFALSE 25599
// begin if IsInUnit ( tmp [ i ] ) then
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PPUSH
25558: CALL_OW 310
25562: IFFALSE 25579
// ComExitVehicle ( tmp [ i ] ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25579: LD_VAR 0 2
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: PPUSH
25590: LD_INT 1
25592: PPUSH
25593: CALL_OW 235
// end ;
25597: GO 25544
25599: POP
25600: POP
// SetSide ( Kurt , 1 ) ;
25601: LD_EXP 60
25605: PPUSH
25606: LD_INT 1
25608: PPUSH
25609: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25613: LD_INT 22
25615: PUSH
25616: LD_INT 8
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 21
25625: PUSH
25626: LD_INT 3
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PPUSH
25637: CALL_OW 69
25641: PPUSH
25642: LD_INT 1
25644: PPUSH
25645: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25649: LD_INT 8
25651: PPUSH
25652: LD_INT 1
25654: PPUSH
25655: LD_INT 1
25657: PPUSH
25658: LD_INT 1
25660: PPUSH
25661: CALL_OW 80
// wait ( 1 1$20 ) ;
25665: LD_INT 2800
25667: PPUSH
25668: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25672: LD_EXP 62
25676: PPUSH
25677: LD_INT 37
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 0
25685: PPUSH
25686: CALL_OW 48
// wait ( 0 0$1 ) ;
25690: LD_INT 35
25692: PPUSH
25693: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 60
25704: PPUSH
25705: LD_INT 95
25707: PPUSH
25708: CALL_OW 111
// end ;
25712: PPOPN 3
25714: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25715: LD_EXP 22
25719: NOT
25720: PUSH
25721: LD_INT 22
25723: PUSH
25724: LD_INT 8
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 21
25733: PUSH
25734: LD_INT 1
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PPUSH
25745: CALL_OW 69
25749: PUSH
25750: LD_INT 0
25752: EQUAL
25753: AND
25754: IFFALSE 25774
25756: GO 25758
25758: DISABLE
// begin legionDestroyed := true ;
25759: LD_ADDR_EXP 22
25763: PUSH
25764: LD_INT 1
25766: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25767: LD_STRING MlegionOut
25769: PPUSH
25770: CALL_OW 337
// end ;
25774: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25775: LD_EXP 38
25779: IFFALSE 25854
25781: GO 25783
25783: DISABLE
25784: LD_INT 0
25786: PPUSH
// begin enable ;
25787: ENABLE
// for i in legionEscapeUnits do
25788: LD_ADDR_VAR 0 1
25792: PUSH
25793: LD_EXP 38
25797: PUSH
25798: FOR_IN
25799: IFFALSE 25852
// begin if IsInArea ( i , legionEscapeArea ) then
25801: LD_VAR 0 1
25805: PPUSH
25806: LD_INT 31
25808: PPUSH
25809: CALL_OW 308
25813: IFFALSE 25826
// RemoveUnit ( i ) else
25815: LD_VAR 0 1
25819: PPUSH
25820: CALL_OW 64
25824: GO 25850
// if not HasTask ( i ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: CALL_OW 314
25835: NOT
25836: IFFALSE 25850
// ComMoveToArea ( i , legionEscapeArea ) ;
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_INT 31
25845: PPUSH
25846: CALL_OW 113
// end ;
25850: GO 25798
25852: POP
25853: POP
// end ;
25854: PPOPN 1
25856: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25857: LD_INT 1
25859: PPUSH
25860: LD_EXP 62
25864: PPUSH
25865: CALL_OW 292
25869: IFFALSE 26167
25871: GO 25873
25873: DISABLE
25874: LD_INT 0
25876: PPUSH
// begin wait ( 0 0$2 ) ;
25877: LD_INT 70
25879: PPUSH
25880: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25884: LD_EXP 62
25888: PPUSH
25889: CALL_OW 87
// DialogueOn ;
25893: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25897: LD_EXP 39
25901: PPUSH
25902: LD_STRING D14-JMM-1
25904: PPUSH
25905: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25909: LD_EXP 62
25913: PPUSH
25914: LD_STRING D14-Friend-1
25916: PPUSH
25917: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25921: LD_EXP 39
25925: PPUSH
25926: LD_STRING D14-JMM-2
25928: PPUSH
25929: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25933: LD_EXP 62
25937: PPUSH
25938: LD_STRING D14-Friend-2
25940: PPUSH
25941: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25945: LD_EXP 39
25949: PPUSH
25950: LD_STRING D14-JMM-3
25952: PPUSH
25953: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25957: LD_EXP 62
25961: PPUSH
25962: LD_STRING D14-Friend-3
25964: PPUSH
25965: CALL_OW 88
// DialogueOff ;
25969: CALL_OW 7
// dec = Query ( Q14 ) ;
25973: LD_ADDR_VAR 0 1
25977: PUSH
25978: LD_STRING Q14
25980: PPUSH
25981: CALL_OW 97
25985: ST_TO_ADDR
// if dec = 1 then
25986: LD_VAR 0 1
25990: PUSH
25991: LD_INT 1
25993: EQUAL
25994: IFFALSE 26028
// begin DialogueOn ;
25996: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26000: LD_EXP 39
26004: PPUSH
26005: LD_STRING D14a-JMM-1
26007: PPUSH
26008: CALL_OW 88
// DialogueOff ;
26012: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26016: LD_EXP 62
26020: PPUSH
26021: LD_INT 1
26023: PPUSH
26024: CALL_OW 235
// end ; if dec = 2 then
26028: LD_VAR 0 1
26032: PUSH
26033: LD_INT 2
26035: EQUAL
26036: IFFALSE 26089
// begin DialogueOn ;
26038: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26042: LD_EXP 39
26046: PPUSH
26047: LD_STRING D14b-JMM-1
26049: PPUSH
26050: CALL_OW 88
// DialogueOff ;
26054: CALL_OW 7
// wait ( 0 0$1 ) ;
26058: LD_INT 35
26060: PPUSH
26061: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26065: LD_EXP 62
26069: PPUSH
26070: LD_INT 9
26072: PPUSH
26073: LD_INT 2
26075: PPUSH
26076: CALL_OW 111
// AddComHold ( Friend ) ;
26080: LD_EXP 62
26084: PPUSH
26085: CALL_OW 200
// end ; if dec = 3 then
26089: LD_VAR 0 1
26093: PUSH
26094: LD_INT 3
26096: EQUAL
26097: IFFALSE 26167
// begin DialogueOn ;
26099: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26103: LD_EXP 39
26107: PPUSH
26108: LD_STRING D14c-JMM-1
26110: PPUSH
26111: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26115: LD_EXP 62
26119: PPUSH
26120: LD_STRING D14c-Friend-1
26122: PPUSH
26123: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26127: LD_EXP 39
26131: PPUSH
26132: LD_STRING D14c-JMM-2
26134: PPUSH
26135: CALL_OW 88
// DialogueOff ;
26139: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26143: LD_EXP 62
26147: PPUSH
26148: LD_INT 9
26150: PPUSH
26151: LD_INT 2
26153: PPUSH
26154: CALL_OW 111
// AddComHold ( Friend ) ;
26158: LD_EXP 62
26162: PPUSH
26163: CALL_OW 200
// end ; end ;
26167: PPOPN 1
26169: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26170: LD_INT 9
26172: PPUSH
26173: LD_INT 2
26175: PPUSH
26176: CALL_OW 428
26180: PUSH
26181: LD_EXP 62
26185: EQUAL
26186: PUSH
26187: LD_EXP 62
26191: PPUSH
26192: CALL_OW 255
26196: PUSH
26197: LD_INT 8
26199: EQUAL
26200: AND
26201: IFFALSE 26215
26203: GO 26205
26205: DISABLE
// RemoveUnit ( Friend ) ;
26206: LD_EXP 62
26210: PPUSH
26211: CALL_OW 64
26215: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26216: LD_EXP 14
26220: PUSH
26221: LD_INT 31500
26223: GREATEREQUAL
26224: PUSH
26225: LD_EXP 7
26229: AND
26230: PUSH
26231: LD_EXP 2
26235: AND
26236: IFFALSE 26666
26238: GO 26240
26240: DISABLE
26241: LD_INT 0
26243: PPUSH
26244: PPUSH
26245: PPUSH
// begin missionStage := 7 ;
26246: LD_ADDR_EXP 15
26250: PUSH
26251: LD_INT 7
26253: ST_TO_ADDR
// uc_side = 1 ;
26254: LD_ADDR_OWVAR 20
26258: PUSH
26259: LD_INT 1
26261: ST_TO_ADDR
// uc_nation = 1 ;
26262: LD_ADDR_OWVAR 21
26266: PUSH
26267: LD_INT 1
26269: ST_TO_ADDR
// for i = 1 to 5 do
26270: LD_ADDR_VAR 0 1
26274: PUSH
26275: DOUBLE
26276: LD_INT 1
26278: DEC
26279: ST_TO_ADDR
26280: LD_INT 5
26282: PUSH
26283: FOR_TO
26284: IFFALSE 26380
// begin vc_engine = 3 ;
26286: LD_ADDR_OWVAR 39
26290: PUSH
26291: LD_INT 3
26293: ST_TO_ADDR
// vc_control = 3 ;
26294: LD_ADDR_OWVAR 38
26298: PUSH
26299: LD_INT 3
26301: ST_TO_ADDR
// vc_chassis = 3 ;
26302: LD_ADDR_OWVAR 37
26306: PUSH
26307: LD_INT 3
26309: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26310: LD_ADDR_OWVAR 40
26314: PUSH
26315: LD_INT 5
26317: PUSH
26318: LD_INT 9
26320: PUSH
26321: LD_INT 7
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: LIST
26328: PUSH
26329: LD_INT 1
26331: PPUSH
26332: LD_INT 3
26334: PPUSH
26335: CALL_OW 12
26339: ARRAY
26340: ST_TO_ADDR
// veh = CreateVehicle ;
26341: LD_ADDR_VAR 0 2
26345: PUSH
26346: CALL_OW 45
26350: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26351: LD_VAR 0 2
26355: PPUSH
26356: LD_INT 1
26358: PPUSH
26359: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26363: LD_VAR 0 2
26367: PPUSH
26368: LD_INT 19
26370: PPUSH
26371: LD_INT 0
26373: PPUSH
26374: CALL_OW 49
// end ;
26378: GO 26283
26380: POP
26381: POP
// vc_engine = 3 ;
26382: LD_ADDR_OWVAR 39
26386: PUSH
26387: LD_INT 3
26389: ST_TO_ADDR
// vc_control = 1 ;
26390: LD_ADDR_OWVAR 38
26394: PUSH
26395: LD_INT 1
26397: ST_TO_ADDR
// vc_chassis = 3 ;
26398: LD_ADDR_OWVAR 37
26402: PUSH
26403: LD_INT 3
26405: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26406: LD_ADDR_OWVAR 40
26410: PUSH
26411: LD_INT 5
26413: PUSH
26414: LD_INT 9
26416: PUSH
26417: LD_INT 7
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 1
26427: PPUSH
26428: LD_INT 3
26430: PPUSH
26431: CALL_OW 12
26435: ARRAY
26436: ST_TO_ADDR
// vehG = CreateVehicle ;
26437: LD_ADDR_VAR 0 3
26441: PUSH
26442: CALL_OW 45
26446: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26447: LD_VAR 0 3
26451: PPUSH
26452: LD_INT 1
26454: PPUSH
26455: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26459: LD_VAR 0 3
26463: PPUSH
26464: LD_INT 19
26466: PPUSH
26467: LD_INT 0
26469: PPUSH
26470: CALL_OW 49
// if JMMGirl = 1 then
26474: LD_EXP 7
26478: PUSH
26479: LD_INT 1
26481: EQUAL
26482: IFFALSE 26538
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26484: LD_ADDR_EXP 40
26488: PUSH
26489: LD_STRING Joan
26491: PPUSH
26492: LD_INT 1
26494: PPUSH
26495: LD_STRING 14_
26497: PPUSH
26498: CALL 65065 0 3
26502: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26503: LD_EXP 40
26507: PPUSH
26508: LD_VAR 0 3
26512: PPUSH
26513: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26517: LD_VAR 0 3
26521: PPUSH
26522: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26526: LD_EXP 40
26530: PPUSH
26531: LD_STRING D10BW-Joan-1
26533: PPUSH
26534: CALL_OW 94
// end ; if JMMGirl = 2 then
26538: LD_EXP 7
26542: PUSH
26543: LD_INT 2
26545: EQUAL
26546: IFFALSE 26602
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26548: LD_ADDR_EXP 42
26552: PUSH
26553: LD_STRING Lisa
26555: PPUSH
26556: LD_INT 1
26558: PPUSH
26559: LD_STRING 14_
26561: PPUSH
26562: CALL 65065 0 3
26566: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26567: LD_EXP 42
26571: PPUSH
26572: LD_VAR 0 3
26576: PPUSH
26577: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26581: LD_VAR 0 3
26585: PPUSH
26586: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26590: LD_EXP 42
26594: PPUSH
26595: LD_STRING D10BW-Lisa-1
26597: PPUSH
26598: CALL_OW 94
// end ; if JMMGirl = 3 then
26602: LD_EXP 7
26606: PUSH
26607: LD_INT 3
26609: EQUAL
26610: IFFALSE 26666
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26612: LD_ADDR_EXP 54
26616: PUSH
26617: LD_STRING Connie
26619: PPUSH
26620: LD_INT 1
26622: PPUSH
26623: LD_STRING 14_
26625: PPUSH
26626: CALL 65065 0 3
26630: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26631: LD_EXP 54
26635: PPUSH
26636: LD_VAR 0 3
26640: PPUSH
26641: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26645: LD_VAR 0 3
26649: PPUSH
26650: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26654: LD_EXP 54
26658: PPUSH
26659: LD_STRING D10BW-Con-1
26661: PPUSH
26662: CALL_OW 94
// end ; end ;
26666: PPOPN 3
26668: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26669: LD_EXP 14
26673: PUSH
26674: LD_INT 94500
26676: GREATEREQUAL
26677: IFFALSE 27089
26679: GO 26681
26681: DISABLE
26682: LD_INT 0
26684: PPUSH
26685: PPUSH
26686: PPUSH
// begin tmp := PrepareStevensSquad ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: CALL 2197 0 0
26696: ST_TO_ADDR
// if not tmp then
26697: LD_VAR 0 3
26701: NOT
26702: IFFALSE 26706
// exit ;
26704: GO 27089
// uc_side := 1 ;
26706: LD_ADDR_OWVAR 20
26710: PUSH
26711: LD_INT 1
26713: ST_TO_ADDR
// uc_nation := 1 ;
26714: LD_ADDR_OWVAR 21
26718: PUSH
26719: LD_INT 1
26721: ST_TO_ADDR
// for i in tmp do
26722: LD_ADDR_VAR 0 1
26726: PUSH
26727: LD_VAR 0 3
26731: PUSH
26732: FOR_IN
26733: IFFALSE 26830
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26735: LD_INT 3
26737: PPUSH
26738: LD_INT 3
26740: PPUSH
26741: LD_INT 1
26743: PPUSH
26744: LD_INT 5
26746: PUSH
26747: LD_INT 9
26749: PUSH
26750: LD_INT 7
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: LIST
26757: PUSH
26758: LD_INT 1
26760: PPUSH
26761: LD_INT 3
26763: PPUSH
26764: CALL_OW 12
26768: ARRAY
26769: PPUSH
26770: LD_INT 40
26772: PPUSH
26773: CALL 69889 0 5
// veh := CreateVehicle ;
26777: LD_ADDR_VAR 0 2
26781: PUSH
26782: CALL_OW 45
26786: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26787: LD_VAR 0 2
26791: PPUSH
26792: LD_INT 1
26794: PPUSH
26795: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26799: LD_VAR 0 2
26803: PPUSH
26804: LD_INT 19
26806: PPUSH
26807: LD_INT 0
26809: PPUSH
26810: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26814: LD_VAR 0 1
26818: PPUSH
26819: LD_VAR 0 2
26823: PPUSH
26824: CALL_OW 52
// end ;
26828: GO 26732
26830: POP
26831: POP
// missionStage := 8 ;
26832: LD_ADDR_EXP 15
26836: PUSH
26837: LD_INT 8
26839: ST_TO_ADDR
// DialogueOn ;
26840: CALL_OW 6
// if Stevens then
26844: LD_EXP 41
26848: IFFALSE 26962
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26850: LD_EXP 41
26854: PPUSH
26855: CALL_OW 310
26859: PPUSH
26860: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26864: LD_EXP 41
26868: PPUSH
26869: LD_STRING D8-Huck-1
26871: PPUSH
26872: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26876: LD_EXP 39
26880: PPUSH
26881: LD_STRING D8-JMM-1
26883: PPUSH
26884: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26888: LD_EXP 41
26892: PPUSH
26893: LD_STRING D8-Huck-2
26895: PPUSH
26896: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26900: LD_EXP 39
26904: PPUSH
26905: LD_STRING D8-JMM-2
26907: PPUSH
26908: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26912: LD_EXP 41
26916: PPUSH
26917: LD_STRING D8-Huck-3
26919: PPUSH
26920: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26924: LD_EXP 39
26928: PPUSH
26929: LD_STRING D8-JMM-3
26931: PPUSH
26932: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26936: LD_EXP 41
26940: PPUSH
26941: LD_STRING D8-Huck-4
26943: PPUSH
26944: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26948: LD_EXP 39
26952: PPUSH
26953: LD_STRING D8-JMM-4
26955: PPUSH
26956: CALL_OW 88
// end else
26960: GO 27072
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26962: LD_EXP 55
26966: PPUSH
26967: CALL_OW 310
26971: PPUSH
26972: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26976: LD_EXP 55
26980: PPUSH
26981: LD_STRING D8-Huck-1
26983: PPUSH
26984: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26988: LD_EXP 39
26992: PPUSH
26993: LD_STRING D8-JMM-1a
26995: PPUSH
26996: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27000: LD_EXP 55
27004: PPUSH
27005: LD_STRING D8-Huck-2
27007: PPUSH
27008: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27012: LD_EXP 39
27016: PPUSH
27017: LD_STRING D8-JMM-2
27019: PPUSH
27020: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27024: LD_EXP 55
27028: PPUSH
27029: LD_STRING D8-Huck-3
27031: PPUSH
27032: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27036: LD_EXP 39
27040: PPUSH
27041: LD_STRING D8-JMM-3
27043: PPUSH
27044: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27048: LD_EXP 55
27052: PPUSH
27053: LD_STRING D8-Huck-4
27055: PPUSH
27056: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27060: LD_EXP 39
27064: PPUSH
27065: LD_STRING D8-JMM-4
27067: PPUSH
27068: CALL_OW 88
// end ; DialogueOff ;
27072: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27076: LD_INT 25
27078: PPUSH
27079: LD_INT 1
27081: PPUSH
27082: LD_INT 1
27084: PPUSH
27085: CALL_OW 322
// end ;
27089: PPOPN 3
27091: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27092: LD_INT 1
27094: PPUSH
27095: LD_EXP 71
27099: PPUSH
27100: CALL_OW 292
27104: IFFALSE 27355
27106: GO 27108
27108: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27109: LD_EXP 71
27113: PPUSH
27114: CALL_OW 87
// DialogueOn ;
27118: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27122: LD_EXP 39
27126: PPUSH
27127: LD_STRING D10nB-JMM-1
27129: PPUSH
27130: CALL_OW 88
// if BurlakStatus = 1 then
27134: LD_EXP 9
27138: PUSH
27139: LD_INT 1
27141: EQUAL
27142: IFFALSE 27156
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27144: LD_EXP 70
27148: PPUSH
27149: LD_STRING D10nB-Vse-1a
27151: PPUSH
27152: CALL_OW 94
// end ; if BurlakStatus = 0 then
27156: LD_EXP 9
27160: PUSH
27161: LD_INT 0
27163: EQUAL
27164: IFFALSE 27178
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27166: LD_EXP 70
27170: PPUSH
27171: LD_STRING D10nB-Vse-1
27173: PPUSH
27174: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27178: LD_EXP 39
27182: PPUSH
27183: LD_STRING D10nB-JMM-2
27185: PPUSH
27186: CALL_OW 88
// if KappaStatus then
27190: LD_EXP 2
27194: IFFALSE 27208
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27196: LD_EXP 70
27200: PPUSH
27201: LD_STRING D10nB-Vse-5a
27203: PPUSH
27204: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27208: LD_EXP 2
27212: NOT
27213: PUSH
27214: LD_EXP 6
27218: PUSH
27219: LD_INT 0
27221: EQUAL
27222: AND
27223: IFFALSE 27351
// begin if JMMGirl = 1 then
27225: LD_EXP 7
27229: PUSH
27230: LD_INT 1
27232: EQUAL
27233: IFFALSE 27283
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27235: LD_EXP 70
27239: PPUSH
27240: LD_STRING D10nB-Vse-2
27242: PPUSH
27243: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27247: LD_EXP 39
27251: PPUSH
27252: LD_STRING D10nB-JMM-3
27254: PPUSH
27255: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27259: LD_EXP 70
27263: PPUSH
27264: LD_STRING D10nB-Vse-3
27266: PPUSH
27267: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27271: LD_EXP 39
27275: PPUSH
27276: LD_STRING D10nB-JMM-4
27278: PPUSH
27279: CALL_OW 88
// end ; if JMMGirl = 2 then
27283: LD_EXP 7
27287: PUSH
27288: LD_INT 2
27290: EQUAL
27291: IFFALSE 27317
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27293: LD_EXP 70
27297: PPUSH
27298: LD_STRING D10nB-Vse-4
27300: PPUSH
27301: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27305: LD_EXP 39
27309: PPUSH
27310: LD_STRING D10nB-JMM-5
27312: PPUSH
27313: CALL_OW 88
// end ; if JMMGirl = 3 then
27317: LD_EXP 7
27321: PUSH
27322: LD_INT 3
27324: EQUAL
27325: IFFALSE 27351
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27327: LD_EXP 70
27331: PPUSH
27332: LD_STRING D10nB-Vse-5
27334: PPUSH
27335: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27339: LD_EXP 39
27343: PPUSH
27344: LD_STRING D10nB-JMM-6
27346: PPUSH
27347: CALL_OW 88
// end ; end ; DialogueOff ;
27351: CALL_OW 7
// end ;
27355: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27356: LD_EXP 14
27360: PUSH
27361: LD_INT 115500
27363: GREATEREQUAL
27364: IFFALSE 27740
27366: GO 27368
27368: DISABLE
27369: LD_INT 0
27371: PPUSH
// begin missionStage := 10 ;
27372: LD_ADDR_EXP 15
27376: PUSH
27377: LD_INT 10
27379: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27380: LD_ADDR_VAR 0 1
27384: PUSH
27385: LD_INT 22
27387: PUSH
27388: LD_INT 1
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PUSH
27395: LD_INT 23
27397: PUSH
27398: LD_INT 1
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 26
27407: PUSH
27408: LD_INT 1
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 3
27417: PUSH
27418: LD_INT 25
27420: PUSH
27421: LD_INT 12
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 3
27434: PUSH
27435: LD_INT 25
27437: PUSH
27438: LD_INT 16
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: PPUSH
27456: CALL_OW 69
27460: PUSH
27461: LD_EXP 39
27465: PUSH
27466: LD_EXP 60
27470: PUSH
27471: LD_EXP 41
27475: PUSH
27476: LD_EXP 55
27480: PUSH
27481: LD_EXP 42
27485: PUSH
27486: LD_EXP 43
27490: PUSH
27491: LD_EXP 44
27495: PUSH
27496: LD_EXP 45
27500: PUSH
27501: LD_EXP 46
27505: PUSH
27506: LD_EXP 47
27510: PUSH
27511: LD_EXP 48
27515: PUSH
27516: LD_EXP 49
27520: PUSH
27521: LD_EXP 50
27525: PUSH
27526: LD_EXP 51
27530: PUSH
27531: LD_EXP 52
27535: PUSH
27536: LD_EXP 53
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: DIFF
27559: ST_TO_ADDR
// if not tmp and Brown then
27560: LD_VAR 0 1
27564: NOT
27565: PUSH
27566: LD_EXP 47
27570: AND
27571: IFFALSE 27586
// tmp := [ Brown ] ;
27573: LD_ADDR_VAR 0 1
27577: PUSH
27578: LD_EXP 47
27582: PUSH
27583: EMPTY
27584: LIST
27585: ST_TO_ADDR
// DialogueOn ;
27586: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27590: LD_VAR 0 1
27594: PUSH
27595: LD_INT 1
27597: ARRAY
27598: PPUSH
27599: LD_STRING D11-Sol1-1
27601: PPUSH
27602: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27606: LD_EXP 64
27610: PPUSH
27611: LD_STRING D11-Pla-1
27613: PPUSH
27614: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27618: LD_EXP 65
27622: PPUSH
27623: LD_STRING D11-Kov-1
27625: PPUSH
27626: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27630: LD_EXP 64
27634: PPUSH
27635: LD_STRING D11-Pla-2
27637: PPUSH
27638: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27642: LD_VAR 0 1
27646: PUSH
27647: LD_INT 1
27649: ARRAY
27650: PPUSH
27651: LD_STRING D11-Sol1-2
27653: PPUSH
27654: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27658: LD_EXP 39
27662: PPUSH
27663: LD_STRING D11-JMM-2
27665: PPUSH
27666: CALL_OW 88
// DialogueOff ;
27670: CALL_OW 7
// allowBehemothConstruct := true ;
27674: LD_ADDR_EXP 25
27678: PUSH
27679: LD_INT 1
27681: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27682: LD_STRING M4
27684: PPUSH
27685: CALL_OW 337
// BuildBehemoths ;
27689: CALL 7668 0 0
// repeat wait ( 15 15$00 ) ;
27693: LD_INT 31500
27695: PPUSH
27696: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27700: LD_EXP 27
27704: IFFALSE 27708
// break ;
27706: GO 27740
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27708: LD_INT 267
27710: PPUSH
27711: CALL_OW 274
27715: PPUSH
27716: LD_INT 1
27718: PPUSH
27719: CALL_OW 275
27723: PUSH
27724: LD_INT 1000
27726: GREATEREQUAL
27727: IFFALSE 27733
// BuildBehemoths ;
27729: CALL 7668 0 0
// until not behemothBuilders ;
27733: LD_EXP 73
27737: NOT
27738: IFFALSE 27693
// end ;
27740: PPOPN 1
27742: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27743: LD_EXP 73
27747: NOT
27748: PUSH
27749: LD_EXP 28
27753: NOT
27754: AND
27755: PUSH
27756: LD_EXP 25
27760: AND
27761: IFFALSE 27781
27763: GO 27765
27765: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27766: LD_STRING M4a
27768: PPUSH
27769: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27773: LD_ADDR_EXP 27
27777: PUSH
27778: LD_INT 1
27780: ST_TO_ADDR
// end ;
27781: END
// every 0 0$1 trigger behemothDone do
27782: LD_EXP 28
27786: IFFALSE 27798
27788: GO 27790
27790: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27791: LD_STRING M4b
27793: PPUSH
27794: CALL_OW 337
27798: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27799: LD_EXP 29
27803: NOT
27804: IFFALSE 28000
27806: GO 27808
27808: DISABLE
27809: LD_INT 0
27811: PPUSH
27812: PPUSH
// begin enable ;
27813: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27814: LD_ADDR_VAR 0 1
27818: PUSH
27819: LD_INT 3
27821: PPUSH
27822: CALL 100983 0 1
27826: ST_TO_ADDR
// if not tmp and not behemothDone then
27827: LD_VAR 0 1
27831: NOT
27832: PUSH
27833: LD_EXP 28
27837: NOT
27838: AND
27839: IFFALSE 27875
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27841: LD_ADDR_VAR 0 1
27845: PUSH
27846: LD_INT 22
27848: PUSH
27849: LD_INT 3
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: PUSH
27856: LD_INT 30
27858: PUSH
27859: LD_INT 37
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PPUSH
27870: CALL_OW 69
27874: ST_TO_ADDR
// if not tmp then
27875: LD_VAR 0 1
27879: NOT
27880: IFFALSE 27884
// exit ;
27882: GO 28000
// for i in tmp do
27884: LD_ADDR_VAR 0 2
27888: PUSH
27889: LD_VAR 0 1
27893: PUSH
27894: FOR_IN
27895: IFFALSE 27998
// if See ( 1 , i ) then
27897: LD_INT 1
27899: PPUSH
27900: LD_VAR 0 2
27904: PPUSH
27905: CALL_OW 292
27909: IFFALSE 27996
// begin if GetType ( i ) = unit_building then
27911: LD_VAR 0 2
27915: PPUSH
27916: CALL_OW 247
27920: PUSH
27921: LD_INT 3
27923: EQUAL
27924: IFFALSE 27962
// begin CenterNowOnUnits ( i ) ;
27926: LD_VAR 0 2
27930: PPUSH
27931: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27935: LD_EXP 39
27939: PPUSH
27940: LD_STRING D17a-JMM-1
27942: PPUSH
27943: CALL_OW 88
// seeBehemoth := true ;
27947: LD_ADDR_EXP 29
27951: PUSH
27952: LD_INT 1
27954: ST_TO_ADDR
// disable ;
27955: DISABLE
// exit ;
27956: POP
27957: POP
27958: GO 28000
// end else
27960: GO 27996
// begin CenterNowOnUnits ( i ) ;
27962: LD_VAR 0 2
27966: PPUSH
27967: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27971: LD_EXP 39
27975: PPUSH
27976: LD_STRING D17b-JMM-1
27978: PPUSH
27979: CALL_OW 88
// seeBehemoth := true ;
27983: LD_ADDR_EXP 29
27987: PUSH
27988: LD_INT 1
27990: ST_TO_ADDR
// disable ;
27991: DISABLE
// exit ;
27992: POP
27993: POP
27994: GO 28000
// end ; end ;
27996: GO 27894
27998: POP
27999: POP
// end ;
28000: PPOPN 2
28002: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28003: LD_EXP 14
28007: PUSH
28008: LD_INT 123200
28010: GREATEREQUAL
28011: IFFALSE 29187
28013: GO 28015
28015: DISABLE
28016: LD_INT 0
28018: PPUSH
28019: PPUSH
28020: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28021: LD_INT 2
28023: PPUSH
28024: LD_INT 23
28026: PUSH
28027: LD_INT 3
28029: PUSH
28030: LD_INT 3
28032: PUSH
28033: LD_INT 48
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: LIST
28040: LIST
28041: PUSH
28042: EMPTY
28043: LIST
28044: PPUSH
28045: CALL 58721 0 2
// repeat wait ( 0 0$1 ) ;
28049: LD_INT 35
28051: PPUSH
28052: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28056: LD_INT 22
28058: PUSH
28059: LD_INT 3
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 34
28068: PUSH
28069: LD_INT 48
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PPUSH
28080: CALL_OW 69
28084: IFFALSE 28049
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28086: LD_ADDR_VAR 0 1
28090: PUSH
28091: LD_INT 22
28093: PUSH
28094: LD_INT 3
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 34
28103: PUSH
28104: LD_INT 48
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: PPUSH
28115: CALL_OW 69
28119: PUSH
28120: LD_INT 1
28122: ARRAY
28123: ST_TO_ADDR
// missionStage := 12 ;
28124: LD_ADDR_EXP 15
28128: PUSH
28129: LD_INT 12
28131: ST_TO_ADDR
// platonovHasBomb := true ;
28132: LD_ADDR_EXP 30
28136: PUSH
28137: LD_INT 1
28139: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: LD_INT 181
28147: PPUSH
28148: LD_INT 86
28150: PPUSH
28151: CALL_OW 171
// AddComHold ( bomb ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 200
// wait ( 0 0$10 ) ;
28164: LD_INT 350
28166: PPUSH
28167: CALL_OW 67
// DialogueOn ;
28171: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28175: LD_EXP 64
28179: PPUSH
28180: LD_STRING D15-Pla-1
28182: PPUSH
28183: CALL_OW 94
// dec = Query ( Q15a ) ;
28187: LD_ADDR_VAR 0 2
28191: PUSH
28192: LD_STRING Q15a
28194: PPUSH
28195: CALL_OW 97
28199: ST_TO_ADDR
// if dec = 1 then
28200: LD_VAR 0 2
28204: PUSH
28205: LD_INT 1
28207: EQUAL
28208: IFFALSE 28231
// begin Say ( JMM , D15a-JMM-1 ) ;
28210: LD_EXP 39
28214: PPUSH
28215: LD_STRING D15a-JMM-1
28217: PPUSH
28218: CALL_OW 88
// YouLost ( Surrender ) ;
28222: LD_STRING Surrender
28224: PPUSH
28225: CALL_OW 104
// exit ;
28229: GO 29187
// end ; if dec = 2 then
28231: LD_VAR 0 2
28235: PUSH
28236: LD_INT 2
28238: EQUAL
28239: IFFALSE 28308
// begin Say ( JMM , D15b-JMM-1 ) ;
28241: LD_EXP 39
28245: PPUSH
28246: LD_STRING D15b-JMM-1
28248: PPUSH
28249: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28253: LD_EXP 64
28257: PPUSH
28258: LD_STRING D15b-Pla-1
28260: PPUSH
28261: CALL_OW 94
// DialogueOff ;
28265: CALL_OW 7
// wait ( 3 3$00 ) ;
28269: LD_INT 6300
28271: PPUSH
28272: CALL_OW 67
// DialogueOn ;
28276: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28280: LD_EXP 39
28284: PPUSH
28285: LD_STRING D15d-JMM-1a
28287: PPUSH
28288: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28292: LD_EXP 64
28296: PPUSH
28297: LD_STRING D15d-Pla-1
28299: PPUSH
28300: CALL_OW 94
// DialogueOff ;
28304: CALL_OW 7
// end ; if dec = 3 then
28308: LD_VAR 0 2
28312: PUSH
28313: LD_INT 3
28315: EQUAL
28316: IFFALSE 28370
// begin Say ( JMM , D15c-JMM-1 ) ;
28318: LD_EXP 39
28322: PPUSH
28323: LD_STRING D15c-JMM-1
28325: PPUSH
28326: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28330: LD_EXP 64
28334: PPUSH
28335: LD_STRING D15c-Pla-1
28337: PPUSH
28338: CALL_OW 94
// DialogueOff ;
28342: CALL_OW 7
// wait ( 0 0$15 ) ;
28346: LD_INT 525
28348: PPUSH
28349: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28353: LD_VAR 0 1
28357: PPUSH
28358: LD_INT 60
28360: PPUSH
28361: LD_INT 95
28363: PPUSH
28364: CALL_OW 116
// exit ;
28368: GO 29187
// end ; if dec = 4 then
28370: LD_VAR 0 2
28374: PUSH
28375: LD_INT 4
28377: EQUAL
28378: IFFALSE 28408
// begin Say ( JMM , D15d-JMM-1 ) ;
28380: LD_EXP 39
28384: PPUSH
28385: LD_STRING D15d-JMM-1
28387: PPUSH
28388: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28392: LD_EXP 64
28396: PPUSH
28397: LD_STRING D15d-Pla-1
28399: PPUSH
28400: CALL_OW 94
// DialogueOff ;
28404: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28408: LD_EXP 62
28412: PPUSH
28413: CALL_OW 302
28417: PUSH
28418: LD_EXP 62
28422: PPUSH
28423: CALL_OW 255
28427: PUSH
28428: LD_INT 1
28430: EQUAL
28431: AND
28432: PUSH
28433: LD_INT 22
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 34
28445: PUSH
28446: LD_INT 8
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PPUSH
28457: CALL_OW 69
28461: NOT
28462: AND
28463: IFFALSE 29088
// begin SetSide ( Friend , 8 ) ;
28465: LD_EXP 62
28469: PPUSH
28470: LD_INT 8
28472: PPUSH
28473: CALL_OW 235
// if IsInUnit ( Friend ) then
28477: LD_EXP 62
28481: PPUSH
28482: CALL_OW 310
28486: IFFALSE 28497
// ComExitBuilding ( Friend ) ;
28488: LD_EXP 62
28492: PPUSH
28493: CALL_OW 122
// if IsDriver ( Friend ) then
28497: LD_EXP 62
28501: PPUSH
28502: CALL 98660 0 1
28506: IFFALSE 28517
// ComExitVehicle ( Friend ) ;
28508: LD_EXP 62
28512: PPUSH
28513: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28517: LD_EXP 62
28521: PPUSH
28522: LD_INT 9
28524: PPUSH
28525: LD_INT 2
28527: PPUSH
28528: CALL_OW 171
// wait ( 0 0$05 ) ;
28532: LD_INT 175
28534: PPUSH
28535: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28539: LD_EXP 62
28543: PPUSH
28544: CALL_OW 87
// DialogueOn ;
28548: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28552: LD_EXP 39
28556: PPUSH
28557: LD_STRING D16-JMM-1
28559: PPUSH
28560: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28564: LD_EXP 62
28568: PPUSH
28569: LD_STRING D16-Friend-1
28571: PPUSH
28572: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28576: LD_EXP 39
28580: PPUSH
28581: LD_STRING D16-JMM-2
28583: PPUSH
28584: CALL_OW 88
// DialogueOff ;
28588: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28592: LD_EXP 62
28596: PPUSH
28597: LD_INT 1
28599: PPUSH
28600: CALL_OW 235
// ComHold ( Friend ) ;
28604: LD_EXP 62
28608: PPUSH
28609: CALL_OW 140
// wait ( 0 0$20 ) ;
28613: LD_INT 700
28615: PPUSH
28616: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28620: LD_EXP 62
28624: PPUSH
28625: LD_INT 9
28627: PPUSH
28628: LD_INT 2
28630: PPUSH
28631: CALL_OW 297
28635: PUSH
28636: LD_INT 30
28638: LESS
28639: IFFALSE 28708
// begin SetSide ( Friend , 8 ) ;
28641: LD_EXP 62
28645: PPUSH
28646: LD_INT 8
28648: PPUSH
28649: CALL_OW 235
// if IsInUnit ( Friend ) then
28653: LD_EXP 62
28657: PPUSH
28658: CALL_OW 310
28662: IFFALSE 28673
// ComExitBuilding ( Friend ) ;
28664: LD_EXP 62
28668: PPUSH
28669: CALL_OW 122
// if IsDriver ( Friend ) then
28673: LD_EXP 62
28677: PPUSH
28678: CALL 98660 0 1
28682: IFFALSE 28693
// ComExitVehicle ( Friend ) ;
28684: LD_EXP 62
28688: PPUSH
28689: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28693: LD_EXP 62
28697: PPUSH
28698: LD_INT 9
28700: PPUSH
28701: LD_INT 2
28703: PPUSH
28704: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28708: LD_INT 1050
28710: PPUSH
28711: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28715: LD_INT 22
28717: PUSH
28718: LD_INT 1
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 34
28727: PUSH
28728: LD_INT 8
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PPUSH
28739: CALL_OW 69
28743: NOT
28744: IFFALSE 29066
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28746: LD_ADDR_VAR 0 3
28750: PUSH
28751: LD_INT 22
28753: PUSH
28754: LD_INT 1
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: PUSH
28761: LD_INT 26
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 3
28773: PUSH
28774: LD_INT 25
28776: PUSH
28777: LD_INT 12
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 25
28786: PUSH
28787: LD_INT 16
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: LIST
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: LIST
28803: PPUSH
28804: CALL_OW 69
28808: PUSH
28809: LD_EXP 39
28813: PUSH
28814: LD_EXP 41
28818: PUSH
28819: LD_EXP 55
28823: PUSH
28824: LD_EXP 42
28828: PUSH
28829: LD_EXP 43
28833: PUSH
28834: LD_EXP 44
28838: PUSH
28839: LD_EXP 45
28843: PUSH
28844: LD_EXP 46
28848: PUSH
28849: LD_EXP 47
28853: PUSH
28854: LD_EXP 48
28858: PUSH
28859: LD_EXP 49
28863: PUSH
28864: LD_EXP 50
28868: PUSH
28869: LD_EXP 51
28873: PUSH
28874: LD_EXP 52
28878: PUSH
28879: LD_EXP 53
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: DIFF
28901: ST_TO_ADDR
// DialogueOn ;
28902: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28906: LD_EXP 64
28910: PPUSH
28911: LD_STRING D16a-Pla-1
28913: PPUSH
28914: CALL_OW 94
// if Stevens then
28918: LD_EXP 41
28922: IFFALSE 28938
// Say ( Stevens , D16a-Huck-1 ) else
28924: LD_EXP 41
28928: PPUSH
28929: LD_STRING D16a-Huck-1
28931: PPUSH
28932: CALL_OW 88
28936: GO 28980
// if Baker then
28938: LD_EXP 55
28942: IFFALSE 28958
// Say ( Baker , D16a-Huck-1 ) else
28944: LD_EXP 55
28948: PPUSH
28949: LD_STRING D16a-Huck-1
28951: PPUSH
28952: CALL_OW 88
28956: GO 28980
// if tmp then
28958: LD_VAR 0 3
28962: IFFALSE 28980
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28964: LD_VAR 0 3
28968: PUSH
28969: LD_INT 1
28971: ARRAY
28972: PPUSH
28973: LD_STRING D16a-Sol1-1
28975: PPUSH
28976: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28980: LD_EXP 62
28984: PPUSH
28985: CALL_OW 255
28989: PUSH
28990: LD_INT 8
28992: EQUAL
28993: IFFALSE 29009
// Say ( JMM , D16a-JMM-1 ) else
28995: LD_EXP 39
28999: PPUSH
29000: LD_STRING D16a-JMM-1
29002: PPUSH
29003: CALL_OW 88
29007: GO 29045
// begin Say ( JMM , D16a-JMM-1a ) ;
29009: LD_EXP 39
29013: PPUSH
29014: LD_STRING D16a-JMM-1a
29016: PPUSH
29017: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29021: LD_EXP 62
29025: PPUSH
29026: LD_STRING D16a-Friend-1
29028: PPUSH
29029: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29033: LD_EXP 62
29037: PPUSH
29038: LD_INT 3
29040: PPUSH
29041: CALL_OW 235
// end ; DialogueOff ;
29045: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29049: LD_VAR 0 1
29053: PPUSH
29054: LD_INT 60
29056: PPUSH
29057: LD_INT 95
29059: PPUSH
29060: CALL_OW 116
// end else
29064: GO 29086
// begin DialogueOn ;
29066: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29070: LD_EXP 64
29074: PPUSH
29075: LD_STRING D16c-Pla-
29077: PPUSH
29078: CALL_OW 94
// DialogueOff ;
29082: CALL_OW 7
// end ; end else
29086: GO 29187
// begin wait ( 3 3$00 ) ;
29088: LD_INT 6300
29090: PPUSH
29091: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29095: LD_INT 22
29097: PUSH
29098: LD_INT 1
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 34
29107: PUSH
29108: LD_INT 8
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PPUSH
29119: CALL_OW 69
29123: NOT
29124: IFFALSE 29167
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29126: LD_EXP 64
29130: PPUSH
29131: LD_STRING D16b-Pla-1
29133: PPUSH
29134: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29138: LD_EXP 39
29142: PPUSH
29143: LD_STRING D16b-JMM-
29145: PPUSH
29146: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29150: LD_VAR 0 1
29154: PPUSH
29155: LD_INT 60
29157: PPUSH
29158: LD_INT 95
29160: PPUSH
29161: CALL_OW 116
// end else
29165: GO 29187
// begin DialogueOn ;
29167: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29171: LD_EXP 64
29175: PPUSH
29176: LD_STRING D16c-Pla-
29178: PPUSH
29179: CALL_OW 94
// DialogueOff ;
29183: CALL_OW 7
// end ; end ; end ;
29187: PPOPN 3
29189: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29190: LD_EXP 14
29194: PUSH
29195: LD_INT 126000
29197: GREATEREQUAL
29198: PUSH
29199: LD_EXP 23
29203: NOT
29204: AND
29205: PUSH
29206: LD_EXP 74
29210: PPUSH
29211: CALL_OW 302
29215: AND
29216: IFFALSE 29574
29218: GO 29220
29220: DISABLE
29221: LD_INT 0
29223: PPUSH
// begin missionStage = 11 ;
29224: LD_ADDR_EXP 15
29228: PUSH
29229: LD_INT 11
29231: ST_TO_ADDR
// DialogueOn ;
29232: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29236: LD_EXP 74
29240: PPUSH
29241: LD_STRING D9-Roth-1
29243: PPUSH
29244: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29248: LD_EXP 39
29252: PPUSH
29253: LD_STRING D9-JMM-1
29255: PPUSH
29256: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29260: LD_EXP 74
29264: PPUSH
29265: LD_STRING D9-Roth-2
29267: PPUSH
29268: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29272: LD_EXP 74
29276: PPUSH
29277: LD_STRING D9-Roth-2a
29279: PPUSH
29280: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29284: LD_EXP 64
29288: PPUSH
29289: LD_STRING D9-Pla-2
29291: PPUSH
29292: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29296: LD_EXP 74
29300: PPUSH
29301: LD_STRING D9-Roth-3
29303: PPUSH
29304: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29308: LD_EXP 64
29312: PPUSH
29313: LD_STRING D9-Pla-3
29315: PPUSH
29316: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29320: LD_EXP 74
29324: PPUSH
29325: LD_STRING D9-Roth-4
29327: PPUSH
29328: CALL_OW 94
// dec = Query ( Q9 ) ;
29332: LD_ADDR_VAR 0 1
29336: PUSH
29337: LD_STRING Q9
29339: PPUSH
29340: CALL_OW 97
29344: ST_TO_ADDR
// if dec = 1 then
29345: LD_VAR 0 1
29349: PUSH
29350: LD_INT 1
29352: EQUAL
29353: IFFALSE 29367
// SayRadio ( Roth , D9a-Roth-1 ) ;
29355: LD_EXP 74
29359: PPUSH
29360: LD_STRING D9a-Roth-1
29362: PPUSH
29363: CALL_OW 94
// if dec = 2 then
29367: LD_VAR 0 1
29371: PUSH
29372: LD_INT 2
29374: EQUAL
29375: IFFALSE 29401
// begin Say ( JMM , D9b-JMM-1 ) ;
29377: LD_EXP 39
29381: PPUSH
29382: LD_STRING D9b-JMM-1
29384: PPUSH
29385: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29389: LD_EXP 74
29393: PPUSH
29394: LD_STRING D9b-Roth-1
29396: PPUSH
29397: CALL_OW 94
// end ; if dec = 3 then
29401: LD_VAR 0 1
29405: PUSH
29406: LD_INT 3
29408: EQUAL
29409: IFFALSE 29471
// begin Say ( JMM , D9c-JMM-1 ) ;
29411: LD_EXP 39
29415: PPUSH
29416: LD_STRING D9c-JMM-1
29418: PPUSH
29419: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29423: LD_EXP 74
29427: PPUSH
29428: LD_STRING D9c-Roth-1
29430: PPUSH
29431: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29435: LD_EXP 39
29439: PPUSH
29440: LD_STRING D9c-JMM-2
29442: PPUSH
29443: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29447: LD_EXP 74
29451: PPUSH
29452: LD_STRING D9c-Roth-2
29454: PPUSH
29455: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29459: LD_EXP 39
29463: PPUSH
29464: LD_STRING D9c-JMM-3
29466: PPUSH
29467: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29471: LD_EXP 74
29475: PPUSH
29476: LD_STRING D9c-Roth-3
29478: PPUSH
29479: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29483: LD_EXP 74
29487: PPUSH
29488: LD_STRING D9cont-Roth-1
29490: PPUSH
29491: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29495: LD_EXP 39
29499: PPUSH
29500: LD_STRING D9cont-JMM-1
29502: PPUSH
29503: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29507: LD_EXP 74
29511: PPUSH
29512: LD_STRING D9cont-Roth-2
29514: PPUSH
29515: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29519: LD_EXP 39
29523: PPUSH
29524: LD_STRING D9cont-JMM-2
29526: PPUSH
29527: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29531: LD_EXP 74
29535: PPUSH
29536: LD_STRING D9cont-Roth-3
29538: PPUSH
29539: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29543: LD_EXP 39
29547: PPUSH
29548: LD_STRING D9cont-JMM-3
29550: PPUSH
29551: CALL_OW 88
// DialogueOff ;
29555: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29559: LD_STRING M3
29561: PPUSH
29562: CALL_OW 337
// allianceActive := true ;
29566: LD_ADDR_EXP 31
29570: PUSH
29571: LD_INT 1
29573: ST_TO_ADDR
// end ;
29574: PPOPN 1
29576: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29577: LD_INT 1
29579: PPUSH
29580: LD_INT 126
29582: PPUSH
29583: CALL_OW 292
29587: PUSH
29588: LD_EXP 64
29592: PPUSH
29593: CALL_OW 310
29597: AND
29598: IFFALSE 29678
29600: GO 29602
29602: DISABLE
29603: LD_INT 0
29605: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29606: LD_EXP 64
29610: PPUSH
29611: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29615: LD_ADDR_VAR 0 1
29619: PUSH
29620: LD_INT 4
29622: PPUSH
29623: LD_INT 22
29625: PUSH
29626: LD_INT 1
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PPUSH
29633: CALL_OW 70
29637: PPUSH
29638: LD_EXP 64
29642: PPUSH
29643: CALL_OW 74
29647: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29648: LD_EXP 64
29652: PPUSH
29653: LD_VAR 0 1
29657: PUSH
29658: LD_INT 1
29660: ARRAY
29661: PPUSH
29662: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29666: LD_EXP 64
29670: PPUSH
29671: LD_STRING D18-Pla-1
29673: PPUSH
29674: CALL_OW 88
// end ;
29678: PPOPN 1
29680: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29681: LD_EXP 64
29685: PPUSH
29686: CALL_OW 301
29690: PUSH
29691: LD_EXP 67
29695: PPUSH
29696: CALL_OW 301
29700: AND
29701: PUSH
29702: LD_INT 22
29704: PUSH
29705: LD_INT 3
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 21
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 50
29724: PUSH
29725: EMPTY
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: LIST
29732: PPUSH
29733: CALL_OW 69
29737: PUSH
29738: LD_INT 7
29740: PUSH
29741: LD_INT 8
29743: PUSH
29744: LD_INT 9
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: LIST
29751: PUSH
29752: LD_OWVAR 67
29756: ARRAY
29757: LESS
29758: AND
29759: IFFALSE 30530
29761: GO 29763
29763: DISABLE
29764: LD_INT 0
29766: PPUSH
29767: PPUSH
29768: PPUSH
29769: PPUSH
// begin MC_Kill ( 1 ) ;
29770: LD_INT 1
29772: PPUSH
29773: CALL 35277 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29777: LD_INT 1
29779: PPUSH
29780: LD_INT 3
29782: PPUSH
29783: LD_INT 1
29785: PPUSH
29786: LD_INT 1
29788: PPUSH
29789: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29793: LD_ADDR_VAR 0 1
29797: PUSH
29798: LD_INT 22
29800: PUSH
29801: LD_INT 3
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 21
29810: PUSH
29811: LD_INT 1
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 24
29820: PUSH
29821: LD_INT 900
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: LIST
29832: PPUSH
29833: CALL_OW 69
29837: PUSH
29838: FOR_IN
29839: IFFALSE 29870
// if GetSex ( i ) = sex_male then
29841: LD_VAR 0 1
29845: PPUSH
29846: CALL_OW 258
29850: PUSH
29851: LD_INT 1
29853: EQUAL
29854: IFFALSE 29868
// begin tmp = i ;
29856: LD_ADDR_VAR 0 2
29860: PUSH
29861: LD_VAR 0 1
29865: ST_TO_ADDR
// break ;
29866: GO 29870
// end ;
29868: GO 29838
29870: POP
29871: POP
// if tmp = 0 then
29872: LD_VAR 0 2
29876: PUSH
29877: LD_INT 0
29879: EQUAL
29880: IFFALSE 29934
// begin uc_side = 3 ;
29882: LD_ADDR_OWVAR 20
29886: PUSH
29887: LD_INT 3
29889: ST_TO_ADDR
// uc_nation = 3 ;
29890: LD_ADDR_OWVAR 21
29894: PUSH
29895: LD_INT 3
29897: ST_TO_ADDR
// hc_name =  ;
29898: LD_ADDR_OWVAR 26
29902: PUSH
29903: LD_STRING 
29905: ST_TO_ADDR
// hc_gallery =  ;
29906: LD_ADDR_OWVAR 33
29910: PUSH
29911: LD_STRING 
29913: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29914: LD_INT 1
29916: PPUSH
29917: LD_INT 10
29919: PPUSH
29920: CALL_OW 381
// tmp = CreateHuman ;
29924: LD_ADDR_VAR 0 2
29928: PUSH
29929: CALL_OW 44
29933: ST_TO_ADDR
// end ; DialogueOn ;
29934: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_STRING DSurrenderRussians-RSol1-1a
29945: PPUSH
29946: CALL_OW 94
// DialogueOff ;
29950: CALL_OW 7
// russianDestroyed := true ;
29954: LD_ADDR_EXP 21
29958: PUSH
29959: LD_INT 1
29961: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29962: LD_INT 22
29964: PUSH
29965: LD_INT 3
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 21
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PPUSH
29986: CALL_OW 69
29990: PPUSH
29991: CALL_OW 122
// wait ( 0 0$1 ) ;
29995: LD_INT 35
29997: PPUSH
29998: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30002: LD_INT 22
30004: PUSH
30005: LD_INT 3
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 21
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PPUSH
30026: CALL_OW 69
30030: PPUSH
30031: LD_INT 25
30033: PPUSH
30034: CALL_OW 173
// wait ( 0 0$10 ) ;
30038: LD_INT 350
30040: PPUSH
30041: CALL_OW 67
// PrepareOmarInvasion ;
30045: CALL 13878 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30049: LD_ADDR_VAR 0 2
30053: PUSH
30054: LD_EXP 92
30058: PPUSH
30059: CALL_OW 250
30063: PUSH
30064: LD_EXP 92
30068: PPUSH
30069: CALL_OW 251
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30078: LD_VAR 0 2
30082: PUSH
30083: LD_INT 1
30085: ARRAY
30086: PPUSH
30087: LD_VAR 0 2
30091: PUSH
30092: LD_INT 2
30094: ARRAY
30095: PPUSH
30096: LD_INT 1
30098: PPUSH
30099: LD_INT 8
30101: NEG
30102: PPUSH
30103: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30107: LD_EXP 92
30111: PPUSH
30112: CALL_OW 87
// DialogueOn ;
30116: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30120: LD_EXP 39
30124: PPUSH
30125: LD_STRING D19-JMM-1
30127: PPUSH
30128: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30132: LD_ADDR_VAR 0 3
30136: PUSH
30137: LD_INT 22
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 26
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PUSH
30157: LD_INT 2
30159: PUSH
30160: LD_INT 25
30162: PUSH
30163: LD_INT 1
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 25
30172: PUSH
30173: LD_INT 2
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 25
30182: PUSH
30183: LD_INT 3
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 25
30192: PUSH
30193: LD_INT 4
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 25
30202: PUSH
30203: LD_INT 5
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 25
30212: PUSH
30213: LD_INT 8
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: LIST
30233: PPUSH
30234: CALL_OW 69
30238: PUSH
30239: LD_EXP 39
30243: PUSH
30244: LD_EXP 40
30248: PUSH
30249: LD_EXP 41
30253: PUSH
30254: LD_EXP 42
30258: PUSH
30259: LD_EXP 43
30263: PUSH
30264: LD_EXP 44
30268: PUSH
30269: LD_EXP 45
30273: PUSH
30274: LD_EXP 46
30278: PUSH
30279: LD_EXP 47
30283: PUSH
30284: LD_EXP 48
30288: PUSH
30289: LD_EXP 49
30293: PUSH
30294: LD_EXP 50
30298: PUSH
30299: LD_EXP 51
30303: PUSH
30304: LD_EXP 52
30308: PUSH
30309: LD_EXP 53
30313: PUSH
30314: LD_EXP 54
30318: PUSH
30319: LD_EXP 55
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: DIFF
30343: ST_TO_ADDR
// if tmp2 then
30344: LD_VAR 0 3
30348: IFFALSE 30366
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30350: LD_VAR 0 3
30354: PUSH
30355: LD_INT 1
30357: ARRAY
30358: PPUSH
30359: LD_STRING D19-Sol1-1
30361: PPUSH
30362: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30366: LD_EXP 39
30370: PPUSH
30371: LD_STRING D19-JMM-2
30373: PPUSH
30374: CALL_OW 88
// DialogueOff ;
30378: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30382: LD_VAR 0 2
30386: PUSH
30387: LD_INT 1
30389: ARRAY
30390: PPUSH
30391: LD_VAR 0 2
30395: PUSH
30396: LD_INT 2
30398: ARRAY
30399: PPUSH
30400: LD_INT 1
30402: PPUSH
30403: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30407: LD_STRING M5
30409: PPUSH
30410: CALL_OW 337
// omarOnMotherLode := false ;
30414: LD_ADDR_VAR 0 4
30418: PUSH
30419: LD_INT 0
30421: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30422: LD_INT 35
30424: PPUSH
30425: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30429: LD_EXP 92
30433: PPUSH
30434: LD_INT 215
30436: PPUSH
30437: LD_INT 100
30439: PPUSH
30440: CALL_OW 297
30444: PUSH
30445: LD_INT 10
30447: LESS
30448: PUSH
30449: LD_VAR 0 4
30453: NOT
30454: AND
30455: IFFALSE 30489
// begin omarOnMotherLode := true ;
30457: LD_ADDR_VAR 0 4
30461: PUSH
30462: LD_INT 1
30464: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30465: LD_EXP 39
30469: PPUSH
30470: LD_STRING D19b-JMM-1
30472: PPUSH
30473: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30477: LD_EXP 92
30481: PPUSH
30482: LD_STRING DOmarContam-Omar-1
30484: PPUSH
30485: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30489: LD_EXP 92
30493: PPUSH
30494: CALL_OW 301
30498: IFFALSE 30422
// Say ( JMM , D19a-JMM-1 ) ;
30500: LD_EXP 39
30504: PPUSH
30505: LD_STRING D19a-JMM-1
30507: PPUSH
30508: CALL_OW 88
// if Heike then
30512: LD_EXP 93
30516: IFFALSE 30530
// Say ( Heike , D19a-Hke-1 ) ;
30518: LD_EXP 93
30522: PPUSH
30523: LD_STRING D19a-Hke-1
30525: PPUSH
30526: CALL_OW 88
// end ;
30530: PPOPN 4
30532: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30533: LD_INT 22
30535: PUSH
30536: LD_INT 3
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 21
30545: PUSH
30546: LD_INT 1
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PPUSH
30557: CALL_OW 69
30561: PUSH
30562: LD_EXP 21
30566: AND
30567: IFFALSE 30635
30569: GO 30571
30571: DISABLE
30572: LD_INT 0
30574: PPUSH
30575: PPUSH
// begin enable ;
30576: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30577: LD_ADDR_VAR 0 2
30581: PUSH
30582: LD_INT 25
30584: PPUSH
30585: LD_INT 22
30587: PUSH
30588: LD_INT 3
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PPUSH
30595: CALL_OW 70
30599: ST_TO_ADDR
// if not tmp then
30600: LD_VAR 0 2
30604: NOT
30605: IFFALSE 30609
// exit ;
30607: GO 30635
// for i in tmp do
30609: LD_ADDR_VAR 0 1
30613: PUSH
30614: LD_VAR 0 2
30618: PUSH
30619: FOR_IN
30620: IFFALSE 30633
// RemoveUnit ( i ) ;
30622: LD_VAR 0 1
30626: PPUSH
30627: CALL_OW 64
30631: GO 30619
30633: POP
30634: POP
// end ;
30635: PPOPN 2
30637: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30638: LD_INT 22
30640: PUSH
30641: LD_INT 7
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 21
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PPUSH
30662: CALL_OW 69
30666: PUSH
30667: LD_INT 6
30669: LESS
30670: IFFALSE 31138
30672: GO 30674
30674: DISABLE
30675: LD_INT 0
30677: PPUSH
30678: PPUSH
// begin MC_Kill ( 1 ) ;
30679: LD_INT 1
30681: PPUSH
30682: CALL 35277 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30686: LD_INT 7
30688: PPUSH
30689: LD_INT 1
30691: PPUSH
30692: LD_INT 1
30694: PPUSH
30695: LD_INT 1
30697: PPUSH
30698: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30702: LD_ADDR_VAR 0 1
30706: PUSH
30707: LD_INT 22
30709: PUSH
30710: LD_INT 7
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 26
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PPUSH
30731: CALL_OW 69
30735: PUSH
30736: LD_EXP 74
30740: DIFF
30741: ST_TO_ADDR
// if tmp then
30742: LD_VAR 0 1
30746: IFFALSE 30764
// tmp := tmp [ 1 ] else
30748: LD_ADDR_VAR 0 1
30752: PUSH
30753: LD_VAR 0 1
30757: PUSH
30758: LD_INT 1
30760: ARRAY
30761: ST_TO_ADDR
30762: GO 30800
// begin uc_side := 7 ;
30764: LD_ADDR_OWVAR 20
30768: PUSH
30769: LD_INT 7
30771: ST_TO_ADDR
// uc_nation := 1 ;
30772: LD_ADDR_OWVAR 21
30776: PUSH
30777: LD_INT 1
30779: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30780: LD_INT 1
30782: PPUSH
30783: LD_INT 8
30785: PPUSH
30786: CALL_OW 384
// tmp := CreateHuman ;
30790: LD_ADDR_VAR 0 1
30794: PUSH
30795: CALL_OW 44
30799: ST_TO_ADDR
// end ; DialogueOn ;
30800: CALL_OW 6
// if IsOK ( Roth ) then
30804: LD_EXP 74
30808: PPUSH
30809: CALL_OW 302
30813: IFFALSE 30827
// Say ( JMM , DAb-JMM-1 ) ;
30815: LD_EXP 39
30819: PPUSH
30820: LD_STRING DAb-JMM-1
30822: PPUSH
30823: CALL_OW 88
// if IsOK ( Roth ) then
30827: LD_EXP 74
30831: PPUSH
30832: CALL_OW 302
30836: IFFALSE 30860
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30838: LD_EXP 74
30842: PPUSH
30843: LD_STRING DSurrenderAlliance-Roth-1
30845: PPUSH
30846: CALL_OW 88
// RothCaptured := true ;
30850: LD_ADDR_EXP 33
30854: PUSH
30855: LD_INT 1
30857: ST_TO_ADDR
// end else
30858: GO 30872
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30860: LD_VAR 0 1
30864: PPUSH
30865: LD_STRING DSurrenderAlliance-Sci1-1
30867: PPUSH
30868: CALL_OW 88
// DialogueOff ;
30872: CALL_OW 7
// allianceDestroyed := true ;
30876: LD_ADDR_EXP 23
30880: PUSH
30881: LD_INT 1
30883: ST_TO_ADDR
// if capturedUnit = 0 then
30884: LD_EXP 34
30888: PUSH
30889: LD_INT 0
30891: EQUAL
30892: IFFALSE 30901
// SetAchievement ( ACH_ALLIANCE ) ;
30894: LD_STRING ACH_ALLIANCE
30896: PPUSH
30897: CALL_OW 543
// if trueAmericans then
30901: LD_EXP 35
30905: IFFALSE 30981
// begin if trueAmericans = 1 then
30907: LD_EXP 35
30911: PUSH
30912: LD_INT 1
30914: EQUAL
30915: IFFALSE 30931
// Say ( JMM , DAb-JMM-1a ) else
30917: LD_EXP 39
30921: PPUSH
30922: LD_STRING DAb-JMM-1a
30924: PPUSH
30925: CALL_OW 88
30929: GO 30943
// Say ( JMM , DAb-JMM-1b ) ;
30931: LD_EXP 39
30935: PPUSH
30936: LD_STRING DAb-JMM-1b
30938: PPUSH
30939: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30943: LD_EXP 35
30947: PPUSH
30948: CALL_OW 87
// for i in trueAmericans do
30952: LD_ADDR_VAR 0 2
30956: PUSH
30957: LD_EXP 35
30961: PUSH
30962: FOR_IN
30963: IFFALSE 30979
// SetSide ( i , 1 ) ;
30965: LD_VAR 0 2
30969: PPUSH
30970: LD_INT 1
30972: PPUSH
30973: CALL_OW 235
30977: GO 30962
30979: POP
30980: POP
// end ; repeat wait ( 0 0$1 ) ;
30981: LD_INT 35
30983: PPUSH
30984: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30988: LD_ADDR_VAR 0 2
30992: PUSH
30993: LD_INT 22
30995: PUSH
30996: LD_INT 7
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 21
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PPUSH
31017: CALL_OW 69
31021: PUSH
31022: FOR_IN
31023: IFFALSE 31105
// begin if IsInUnit ( i ) then
31025: LD_VAR 0 2
31029: PPUSH
31030: CALL_OW 310
31034: IFFALSE 31045
// ComExitBuilding ( i ) ;
31036: LD_VAR 0 2
31040: PPUSH
31041: CALL_OW 122
// if IsDriver ( i ) then
31045: LD_VAR 0 2
31049: PPUSH
31050: CALL 98660 0 1
31054: IFFALSE 31065
// ComExitVehicle ( i ) ;
31056: LD_VAR 0 2
31060: PPUSH
31061: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31065: LD_VAR 0 2
31069: PPUSH
31070: LD_INT 26
31072: PPUSH
31073: CALL_OW 308
31077: NOT
31078: IFFALSE 31094
// AddComMoveToArea ( i , allianceEscapeArea ) else
31080: LD_VAR 0 2
31084: PPUSH
31085: LD_INT 26
31087: PPUSH
31088: CALL_OW 173
31092: GO 31103
// RemoveUnit ( i ) ;
31094: LD_VAR 0 2
31098: PPUSH
31099: CALL_OW 64
// end ;
31103: GO 31022
31105: POP
31106: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31107: LD_INT 22
31109: PUSH
31110: LD_INT 7
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 21
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PPUSH
31131: CALL_OW 69
31135: NOT
31136: IFFALSE 30981
// end ;
31138: PPOPN 2
31140: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31141: LD_INT 0
31143: PPUSH
31144: PPUSH
// if not unit then
31145: LD_VAR 0 1
31149: NOT
31150: IFFALSE 31154
// exit ;
31152: GO 32652
// DoNotAttack ( 7 , unit ) ;
31154: LD_INT 7
31156: PPUSH
31157: LD_VAR 0 1
31161: PPUSH
31162: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31166: LD_VAR 0 1
31170: PPUSH
31171: LD_INT 260
31173: PPUSH
31174: LD_INT 235
31176: PPUSH
31177: LD_INT 3
31179: PPUSH
31180: LD_INT 1
31182: PPUSH
31183: CALL_OW 483
// SetSide ( unit , 4 ) ;
31187: LD_VAR 0 1
31191: PPUSH
31192: LD_INT 4
31194: PPUSH
31195: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31199: LD_ADDR_EXP 34
31203: PUSH
31204: LD_EXP 34
31208: PUSH
31209: LD_INT 1
31211: PLUS
31212: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31213: LD_INT 70
31215: PPUSH
31216: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31220: LD_INT 260
31222: PPUSH
31223: LD_INT 235
31225: PPUSH
31226: LD_INT 1
31228: PPUSH
31229: LD_INT 8
31231: NEG
31232: PPUSH
31233: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31237: LD_VAR 0 1
31241: PPUSH
31242: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31246: LD_VAR 0 1
31250: PPUSH
31251: LD_EXP 74
31255: PPUSH
31256: CALL_OW 119
// DialogueOn ;
31260: CALL_OW 6
// case unit of JMM :
31264: LD_VAR 0 1
31268: PUSH
31269: LD_EXP 39
31273: DOUBLE
31274: EQUAL
31275: IFTRUE 31279
31277: GO 31294
31279: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31280: LD_EXP 39
31284: PPUSH
31285: LD_STRING DA1-JMM-1
31287: PPUSH
31288: CALL_OW 91
31292: GO 31736
31294: LD_EXP 40
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31305: LD_EXP 40
31309: PPUSH
31310: LD_STRING DA1-Joan-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31736
31319: LD_EXP 42
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31330: LD_EXP 42
31334: PPUSH
31335: LD_STRING DA1-Lisa-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31736
31344: LD_EXP 43
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31355: LD_EXP 43
31359: PPUSH
31360: LD_STRING DA1-Don-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31736
31369: LD_EXP 50
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31380: LD_EXP 50
31384: PPUSH
31385: LD_STRING DA1-Corn-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31736
31394: LD_EXP 46
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31405: LD_EXP 46
31409: PPUSH
31410: LD_STRING DA1-Den-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31736
31419: LD_EXP 44
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31430: LD_EXP 44
31434: PPUSH
31435: LD_STRING DA1-Bobby-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31736
31444: LD_EXP 48
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31455: LD_EXP 48
31459: PPUSH
31460: LD_STRING DA1-Glad-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31736
31469: LD_EXP 45
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31480: LD_EXP 45
31484: PPUSH
31485: LD_STRING DA1-Cyrus-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31736
31494: LD_EXP 41
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31505: LD_EXP 41
31509: PPUSH
31510: LD_STRING DA1-Huck-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31736
31519: LD_EXP 55
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31530: LD_EXP 55
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31736
31544: LD_EXP 47
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31555: LD_EXP 47
31559: PPUSH
31560: LD_STRING DA1-Brown-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31736
31569: LD_EXP 51
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31580: LD_EXP 51
31584: PPUSH
31585: LD_STRING DA1-Gary-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31736
31594: LD_EXP 54
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31605: LD_EXP 54
31609: PPUSH
31610: LD_STRING DA1-Con-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31736
31619: LD_EXP 60
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31630: LD_EXP 60
31634: PPUSH
31635: LD_STRING DA1-Kurt-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31736
31644: LD_EXP 53
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31655: LD_EXP 53
31659: PPUSH
31660: LD_STRING DA1-Yam-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31736
31669: LD_EXP 52
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31680: LD_EXP 52
31684: PPUSH
31685: LD_STRING DA1-Frank-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31736
31694: POP
// begin if GetSex ( unit ) = sex_male then
31695: LD_VAR 0 1
31699: PPUSH
31700: CALL_OW 258
31704: PUSH
31705: LD_INT 1
31707: EQUAL
31708: IFFALSE 31724
// ForceSay ( unit , DA1-Sol1-1 ) else
31710: LD_VAR 0 1
31714: PPUSH
31715: LD_STRING DA1-Sol1-1
31717: PPUSH
31718: CALL_OW 91
31722: GO 31736
// ForceSay ( unit , DA1-FSol1-1 ) ;
31724: LD_VAR 0 1
31728: PPUSH
31729: LD_STRING DA1-FSol1-1
31731: PPUSH
31732: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31736: LD_EXP 74
31740: PPUSH
31741: LD_STRING DA-Roth-1
31743: PPUSH
31744: CALL_OW 88
// if capturedUnit = 1 then
31748: LD_EXP 34
31752: PUSH
31753: LD_INT 1
31755: EQUAL
31756: IFFALSE 31784
// begin Say ( Simms , DA-Sim-1 ) ;
31758: LD_EXP 75
31762: PPUSH
31763: LD_STRING DA-Sim-1
31765: PPUSH
31766: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31770: LD_EXP 74
31774: PPUSH
31775: LD_STRING DA-Roth-2
31777: PPUSH
31778: CALL_OW 88
// end else
31782: GO 31796
// Say ( Simms , DA-Sim-2 ) ;
31784: LD_EXP 75
31788: PPUSH
31789: LD_STRING DA-Sim-2
31791: PPUSH
31792: CALL_OW 88
// case unit of JMM :
31796: LD_VAR 0 1
31800: PUSH
31801: LD_EXP 39
31805: DOUBLE
31806: EQUAL
31807: IFTRUE 31811
31809: GO 31826
31811: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31812: LD_EXP 39
31816: PPUSH
31817: LD_STRING DA1-JMM-1a
31819: PPUSH
31820: CALL_OW 91
31824: GO 32333
31826: LD_EXP 40
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31837: LD_EXP 40
31841: PPUSH
31842: LD_STRING DA1-Joan-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32333
31851: LD_EXP 42
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31862: LD_EXP 42
31866: PPUSH
31867: LD_STRING DA1-Lisa-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32333
31876: LD_EXP 43
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31887: LD_EXP 43
31891: PPUSH
31892: LD_STRING DA1-Don-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32333
31901: LD_EXP 50
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31912: LD_EXP 50
31916: PPUSH
31917: LD_STRING DA1-Corn-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32333
31926: LD_EXP 46
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31937: LD_EXP 46
31941: PPUSH
31942: LD_STRING DA1-Den-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32333
31951: LD_EXP 44
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31962: LD_EXP 44
31966: PPUSH
31967: LD_STRING DA1-Bobby-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32333
31976: LD_EXP 48
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31987: LD_EXP 48
31991: PPUSH
31992: LD_STRING DA1-Glad-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32333
32001: LD_EXP 45
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32012: LD_EXP 45
32016: PPUSH
32017: LD_STRING DA1-Cyrus-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32333
32026: LD_EXP 41
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32037: LD_EXP 41
32041: PPUSH
32042: LD_STRING DA1-Huck-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32333
32051: LD_EXP 55
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32062: LD_EXP 55
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32333
32076: LD_EXP 47
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32087: LD_EXP 47
32091: PPUSH
32092: LD_STRING DA1-Brown-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32333
32101: LD_EXP 51
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32112: LD_EXP 51
32116: PPUSH
32117: LD_STRING DA1-Gary-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32333
32126: LD_EXP 54
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32137: LD_EXP 54
32141: PPUSH
32142: LD_STRING DA1-Con-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32333
32151: LD_EXP 60
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32162: LD_EXP 60
32166: PPUSH
32167: LD_STRING DA1-Kurt-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32333
32176: LD_EXP 53
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32187: LD_EXP 53
32191: PPUSH
32192: LD_STRING DA1-Yam-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32333
32201: LD_EXP 52
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32212: LD_EXP 52
32216: PPUSH
32217: LD_STRING DA1-Frank-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32333
32226: POP
// begin join := rand ( 0 , 1 ) ;
32227: LD_ADDR_VAR 0 3
32231: PUSH
32232: LD_INT 0
32234: PPUSH
32235: LD_INT 1
32237: PPUSH
32238: CALL_OW 12
32242: ST_TO_ADDR
// if join then
32243: LD_VAR 0 3
32247: IFFALSE 32292
// begin if GetSex ( unit ) = sex_male then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 258
32258: PUSH
32259: LD_INT 1
32261: EQUAL
32262: IFFALSE 32278
// ForceSay ( unit , DA1-Sol1-1b ) else
32264: LD_VAR 0 1
32268: PPUSH
32269: LD_STRING DA1-Sol1-1b
32271: PPUSH
32272: CALL_OW 91
32276: GO 32290
// ForceSay ( unit , DA1-FSol1-1b ) ;
32278: LD_VAR 0 1
32282: PPUSH
32283: LD_STRING DA1-FSol1-1b
32285: PPUSH
32286: CALL_OW 91
// end else
32290: GO 32333
// begin if GetSex ( unit ) = sex_male then
32292: LD_VAR 0 1
32296: PPUSH
32297: CALL_OW 258
32301: PUSH
32302: LD_INT 1
32304: EQUAL
32305: IFFALSE 32321
// ForceSay ( unit , DA1-Sol1-1a ) else
32307: LD_VAR 0 1
32311: PPUSH
32312: LD_STRING DA1-Sol1-1a
32314: PPUSH
32315: CALL_OW 91
32319: GO 32333
// ForceSay ( unit , DA1-FSol1-1a ) ;
32321: LD_VAR 0 1
32325: PPUSH
32326: LD_STRING DA1-FSol1-1a
32328: PPUSH
32329: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32333: LD_VAR 0 1
32337: PUSH
32338: LD_EXP 39
32342: EQUAL
32343: IFFALSE 32354
// begin YouLost ( JMMCaptured ) ;
32345: LD_STRING JMMCaptured
32347: PPUSH
32348: CALL_OW 104
// exit ;
32352: GO 32652
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32354: LD_VAR 0 1
32358: PUSH
32359: LD_EXP 43
32363: PUSH
32364: LD_EXP 46
32368: PUSH
32369: LD_EXP 44
32373: PUSH
32374: LD_EXP 41
32378: PUSH
32379: LD_EXP 55
32383: PUSH
32384: LD_EXP 47
32388: PUSH
32389: LD_EXP 53
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: IN
32403: PUSH
32404: LD_VAR 0 3
32408: OR
32409: IFFALSE 32508
// begin Say ( Roth , DA-Roth-3 ) ;
32411: LD_EXP 74
32415: PPUSH
32416: LD_STRING DA-Roth-3
32418: PPUSH
32419: CALL_OW 88
// SetSide ( unit , 7 ) ;
32423: LD_VAR 0 1
32427: PPUSH
32428: LD_INT 7
32430: PPUSH
32431: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32435: LD_ADDR_EXP 110
32439: PUSH
32440: LD_EXP 110
32444: PPUSH
32445: LD_INT 1
32447: PPUSH
32448: LD_EXP 110
32452: PUSH
32453: LD_INT 1
32455: ARRAY
32456: PUSH
32457: LD_VAR 0 1
32461: ADD
32462: PPUSH
32463: CALL_OW 1
32467: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32468: LD_INT 260
32470: PPUSH
32471: LD_INT 235
32473: PPUSH
32474: LD_INT 1
32476: PPUSH
32477: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32481: LD_VAR 0 1
32485: PPUSH
32486: LD_INT 1000
32488: PPUSH
32489: CALL_OW 234
// DialogueOff ;
32493: CALL_OW 7
// ComFree ( unit ) ;
32497: LD_VAR 0 1
32501: PPUSH
32502: CALL_OW 139
// end else
32506: GO 32589
// begin Say ( Roth , DA-Roth-3a ) ;
32508: LD_EXP 74
32512: PPUSH
32513: LD_STRING DA-Roth-3a
32515: PPUSH
32516: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32520: LD_ADDR_EXP 35
32524: PUSH
32525: LD_EXP 35
32529: PUSH
32530: LD_VAR 0 1
32534: ADD
32535: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32536: LD_INT 260
32538: PPUSH
32539: LD_INT 235
32541: PPUSH
32542: LD_INT 1
32544: PPUSH
32545: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32549: LD_VAR 0 1
32553: PPUSH
32554: LD_INT 1000
32556: PPUSH
32557: CALL_OW 234
// DialogueOff ;
32561: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 272
32572: PPUSH
32573: LD_INT 254
32575: PPUSH
32576: CALL_OW 111
// AddComHold ( unit ) ;
32580: LD_VAR 0 1
32584: PPUSH
32585: CALL_OW 200
// end ; if capturedUnit = 1 then
32589: LD_EXP 34
32593: PUSH
32594: LD_INT 1
32596: EQUAL
32597: IFFALSE 32652
// begin DialogueOn ;
32599: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32603: LD_EXP 39
32607: PPUSH
32608: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32612: LD_EXP 39
32616: PPUSH
32617: LD_STRING DAa-JMM-1
32619: PPUSH
32620: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32624: LD_EXP 39
32628: PPUSH
32629: LD_STRING DAa-JMM-1a
32631: PPUSH
32632: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32636: LD_EXP 39
32640: PPUSH
32641: LD_STRING DAa-JMM-1b
32643: PPUSH
32644: CALL_OW 88
// DialogueOff ;
32648: CALL_OW 7
// end ; end ;
32652: LD_VAR 0 2
32656: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32657: LD_EXP 15
32661: PUSH
32662: LD_INT 13
32664: GREATEREQUAL
32665: PUSH
32666: LD_INT 22
32668: PUSH
32669: LD_INT 2
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 21
32678: PUSH
32679: LD_INT 1
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PPUSH
32690: CALL_OW 69
32694: PUSH
32695: LD_INT 0
32697: EQUAL
32698: AND
32699: PUSH
32700: LD_INT 22
32702: PUSH
32703: LD_INT 2
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 21
32712: PUSH
32713: LD_INT 2
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 50
32722: PUSH
32723: EMPTY
32724: LIST
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: LIST
32730: PPUSH
32731: CALL_OW 69
32735: PUSH
32736: LD_INT 0
32738: EQUAL
32739: AND
32740: PUSH
32741: LD_EXP 21
32745: AND
32746: PUSH
32747: LD_EXP 22
32751: AND
32752: PUSH
32753: LD_EXP 23
32757: AND
32758: IFFALSE 33400
32760: GO 32762
32762: DISABLE
32763: LD_INT 0
32765: PPUSH
32766: PPUSH
32767: PPUSH
// begin m1 := false ;
32768: LD_ADDR_VAR 0 1
32772: PUSH
32773: LD_INT 0
32775: ST_TO_ADDR
// m2 := false ;
32776: LD_ADDR_VAR 0 2
32780: PUSH
32781: LD_INT 0
32783: ST_TO_ADDR
// m3 := false ;
32784: LD_ADDR_VAR 0 3
32788: PUSH
32789: LD_INT 0
32791: ST_TO_ADDR
// if not bombExploded then
32792: LD_EXP 37
32796: NOT
32797: IFFALSE 32806
// SetAchievement ( ACH_SIBROCKET ) ;
32799: LD_STRING ACH_SIBROCKET
32801: PPUSH
32802: CALL_OW 543
// if tick <= 120 120$00 then
32806: LD_OWVAR 1
32810: PUSH
32811: LD_INT 252000
32813: LESSEQUAL
32814: IFFALSE 32830
// begin wait ( 3 ) ;
32816: LD_INT 3
32818: PPUSH
32819: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32823: LD_STRING ACH_ASPEED_15
32825: PPUSH
32826: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32830: LD_EXP 39
32834: PPUSH
32835: CALL_OW 87
// music_class := 5 ;
32839: LD_ADDR_OWVAR 72
32843: PUSH
32844: LD_INT 5
32846: ST_TO_ADDR
// music_nat := 5 ;
32847: LD_ADDR_OWVAR 71
32851: PUSH
32852: LD_INT 5
32854: ST_TO_ADDR
// DialogueOn ;
32855: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32859: LD_EXP 39
32863: PPUSH
32864: LD_STRING D20-JMM-1
32866: PPUSH
32867: CALL_OW 88
// if IsOK ( Joan ) then
32871: LD_EXP 40
32875: PPUSH
32876: CALL_OW 302
32880: IFFALSE 32894
// Say ( Joan , D20-Joan-1 ) ;
32882: LD_EXP 40
32886: PPUSH
32887: LD_STRING D20-Joan-1
32889: PPUSH
32890: CALL_OW 88
// if IsOk ( Lisa ) then
32894: LD_EXP 42
32898: PPUSH
32899: CALL_OW 302
32903: IFFALSE 32917
// Say ( Lisa , D20-Lisa-1 ) ;
32905: LD_EXP 42
32909: PPUSH
32910: LD_STRING D20-Lisa-1
32912: PPUSH
32913: CALL_OW 88
// if IsOk ( Donaldson ) then
32917: LD_EXP 43
32921: PPUSH
32922: CALL_OW 302
32926: IFFALSE 32940
// Say ( Donaldson , D20-Don-1 ) ;
32928: LD_EXP 43
32932: PPUSH
32933: LD_STRING D20-Don-1
32935: PPUSH
32936: CALL_OW 88
// if IsOK ( Cornel ) then
32940: LD_EXP 50
32944: PPUSH
32945: CALL_OW 302
32949: IFFALSE 32963
// Say ( Cornel , D20-Corn-1 ) ;
32951: LD_EXP 50
32955: PPUSH
32956: LD_STRING D20-Corn-1
32958: PPUSH
32959: CALL_OW 88
// if IsOk ( Denis ) then
32963: LD_EXP 46
32967: PPUSH
32968: CALL_OW 302
32972: IFFALSE 32986
// Say ( Denis , D20-Den-1 ) ;
32974: LD_EXP 46
32978: PPUSH
32979: LD_STRING D20-Den-1
32981: PPUSH
32982: CALL_OW 88
// if IsOk ( Bobby ) then
32986: LD_EXP 44
32990: PPUSH
32991: CALL_OW 302
32995: IFFALSE 33009
// Say ( Bobby , D20-Bobby-1 ) ;
32997: LD_EXP 44
33001: PPUSH
33002: LD_STRING D20-Bobby-1
33004: PPUSH
33005: CALL_OW 88
// if IsOk ( Gladstone ) then
33009: LD_EXP 48
33013: PPUSH
33014: CALL_OW 302
33018: IFFALSE 33032
// Say ( Gladstone , D20-Glad-1 ) ;
33020: LD_EXP 48
33024: PPUSH
33025: LD_STRING D20-Glad-1
33027: PPUSH
33028: CALL_OW 88
// if IsOk ( Cyrus ) then
33032: LD_EXP 45
33036: PPUSH
33037: CALL_OW 302
33041: IFFALSE 33055
// Say ( Cyrus , D20-Cyrus-1 ) ;
33043: LD_EXP 45
33047: PPUSH
33048: LD_STRING D20-Cyrus-1
33050: PPUSH
33051: CALL_OW 88
// if IsOk ( Stevens ) then
33055: LD_EXP 41
33059: PPUSH
33060: CALL_OW 302
33064: IFFALSE 33078
// Say ( Stevens , D20-Huck-1 ) ;
33066: LD_EXP 41
33070: PPUSH
33071: LD_STRING D20-Huck-1
33073: PPUSH
33074: CALL_OW 88
// if IsOk ( Brown ) then
33078: LD_EXP 47
33082: PPUSH
33083: CALL_OW 302
33087: IFFALSE 33101
// Say ( Brown , D20-Brown-1 ) ;
33089: LD_EXP 47
33093: PPUSH
33094: LD_STRING D20-Brown-1
33096: PPUSH
33097: CALL_OW 88
// if IsOk ( Gary ) then
33101: LD_EXP 51
33105: PPUSH
33106: CALL_OW 302
33110: IFFALSE 33124
// Say ( Gary , D20-Gary-1 ) ;
33112: LD_EXP 51
33116: PPUSH
33117: LD_STRING D20-Gary-1
33119: PPUSH
33120: CALL_OW 88
// if IsOk ( Connie ) then
33124: LD_EXP 54
33128: PPUSH
33129: CALL_OW 302
33133: IFFALSE 33147
// Say ( Connie , D20-Con-1 ) ;
33135: LD_EXP 54
33139: PPUSH
33140: LD_STRING D20-Con-1
33142: PPUSH
33143: CALL_OW 88
// if IsOk ( Kurt ) then
33147: LD_EXP 60
33151: PPUSH
33152: CALL_OW 302
33156: IFFALSE 33170
// Say ( Kurt , D20-Kurt-1 ) ;
33158: LD_EXP 60
33162: PPUSH
33163: LD_STRING D20-Kurt-1
33165: PPUSH
33166: CALL_OW 88
// if IsOk ( Kikuchi ) then
33170: LD_EXP 53
33174: PPUSH
33175: CALL_OW 302
33179: IFFALSE 33193
// Say ( Kikuchi , D20-Yam-1 ) ;
33181: LD_EXP 53
33185: PPUSH
33186: LD_STRING D20-Yam-1
33188: PPUSH
33189: CALL_OW 88
// if IsOk ( Frank ) then
33193: LD_EXP 52
33197: PPUSH
33198: CALL_OW 302
33202: IFFALSE 33216
// Say ( Frank , D20-Frank-1 ) ;
33204: LD_EXP 52
33208: PPUSH
33209: LD_STRING D20-Frank-1
33211: PPUSH
33212: CALL_OW 88
// DialogueOff ;
33216: CALL_OW 7
// if RothCaptured then
33220: LD_EXP 33
33224: IFFALSE 33246
// begin m1 := true ;
33226: LD_ADDR_VAR 0 1
33230: PUSH
33231: LD_INT 1
33233: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33234: LD_STRING Roth
33236: PPUSH
33237: LD_INT 1
33239: PPUSH
33240: CALL_OW 101
// end else
33244: GO 33257
// AddMedal ( Roth , - 1 ) ;
33246: LD_STRING Roth
33248: PPUSH
33249: LD_INT 1
33251: NEG
33252: PPUSH
33253: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33257: LD_EXP 27
33261: IFFALSE 33283
// begin m2 := true ;
33263: LD_ADDR_VAR 0 2
33267: PUSH
33268: LD_INT 1
33270: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33271: LD_STRING Project
33273: PPUSH
33274: LD_INT 1
33276: PPUSH
33277: CALL_OW 101
// end else
33281: GO 33294
// AddMedal ( Project , - 1 ) ;
33283: LD_STRING Project
33285: PPUSH
33286: LD_INT 1
33288: NEG
33289: PPUSH
33290: CALL_OW 101
// if lostCounter = 0 then
33294: LD_EXP 32
33298: PUSH
33299: LD_INT 0
33301: EQUAL
33302: IFFALSE 33324
// begin m3 := true ;
33304: LD_ADDR_VAR 0 3
33308: PUSH
33309: LD_INT 1
33311: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33312: LD_STRING NoLosses
33314: PPUSH
33315: LD_INT 1
33317: PPUSH
33318: CALL_OW 101
// end else
33322: GO 33335
// AddMedal ( NoLosses , - 1 ) ;
33324: LD_STRING NoLosses
33326: PPUSH
33327: LD_INT 1
33329: NEG
33330: PPUSH
33331: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33335: LD_VAR 0 1
33339: PUSH
33340: LD_VAR 0 2
33344: AND
33345: PUSH
33346: LD_VAR 0 3
33350: AND
33351: PUSH
33352: LD_OWVAR 67
33356: PUSH
33357: LD_INT 3
33359: EQUAL
33360: AND
33361: IFFALSE 33373
// SetAchievementEX ( ACH_AMER , 15 ) ;
33363: LD_STRING ACH_AMER
33365: PPUSH
33366: LD_INT 15
33368: PPUSH
33369: CALL_OW 564
// GiveMedals ( MAIN ) ;
33373: LD_STRING MAIN
33375: PPUSH
33376: CALL_OW 102
// music_class := 4 ;
33380: LD_ADDR_OWVAR 72
33384: PUSH
33385: LD_INT 4
33387: ST_TO_ADDR
// music_nat := 1 ;
33388: LD_ADDR_OWVAR 71
33392: PUSH
33393: LD_INT 1
33395: ST_TO_ADDR
// YouWin ;
33396: CALL_OW 103
// end ; end_of_file
33400: PPOPN 3
33402: END
// export function CustomEvent ( event ) ; begin
33403: LD_INT 0
33405: PPUSH
// end ;
33406: LD_VAR 0 2
33410: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33411: LD_VAR 0 1
33415: PUSH
33416: LD_INT 1
33418: EQUAL
33419: PUSH
33420: LD_VAR 0 2
33424: PUSH
33425: LD_INT 4
33427: EQUAL
33428: AND
33429: PUSH
33430: LD_EXP 58
33434: PPUSH
33435: CALL_OW 300
33439: AND
33440: IFFALSE 33456
// begin wait ( 0 0$2 ) ;
33442: LD_INT 70
33444: PPUSH
33445: CALL_OW 67
// YouLost ( Dismissed ) ;
33449: LD_STRING Dismissed
33451: PPUSH
33452: CALL_OW 104
// end ; end ;
33456: PPOPN 2
33458: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33459: LD_VAR 0 2
33463: PPUSH
33464: LD_VAR 0 3
33468: PPUSH
33469: LD_INT 18
33471: PPUSH
33472: CALL_OW 309
33476: IFFALSE 33485
// YouLost ( Motherlode3 ) ;
33478: LD_STRING Motherlode3
33480: PPUSH
33481: CALL_OW 104
// end ;
33485: PPOPN 3
33487: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33488: LD_EXP 27
33492: NOT
33493: IFFALSE 33503
// behemothDone := true ;
33495: LD_ADDR_EXP 28
33499: PUSH
33500: LD_INT 1
33502: ST_TO_ADDR
// end ;
33503: PPOPN 1
33505: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33506: LD_VAR 0 1
33510: PPUSH
33511: CALL_OW 255
33515: PUSH
33516: LD_INT 1
33518: EQUAL
33519: IFFALSE 33529
// bombExploded := true ;
33521: LD_ADDR_EXP 37
33525: PUSH
33526: LD_INT 1
33528: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33529: LD_VAR 0 1
33533: PPUSH
33534: CALL_OW 255
33538: PUSH
33539: LD_INT 1
33541: EQUAL
33542: PUSH
33543: LD_EXP 30
33547: AND
33548: PUSH
33549: LD_INT 22
33551: PUSH
33552: LD_INT 3
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 34
33561: PUSH
33562: LD_INT 48
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PPUSH
33573: CALL_OW 69
33577: AND
33578: PUSH
33579: LD_INT 22
33581: PUSH
33582: LD_INT 1
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 34
33591: PUSH
33592: LD_INT 8
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PPUSH
33603: CALL_OW 69
33607: NOT
33608: AND
33609: IFFALSE 33661
// begin wait ( 0 0$5 ) ;
33611: LD_INT 175
33613: PPUSH
33614: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33618: LD_INT 22
33620: PUSH
33621: LD_INT 3
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 34
33630: PUSH
33631: LD_INT 48
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PPUSH
33642: CALL_OW 69
33646: PUSH
33647: LD_INT 1
33649: ARRAY
33650: PPUSH
33651: LD_INT 60
33653: PPUSH
33654: LD_INT 95
33656: PPUSH
33657: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33661: LD_VAR 0 2
33665: PPUSH
33666: LD_VAR 0 3
33670: PPUSH
33671: LD_INT 18
33673: PPUSH
33674: CALL_OW 309
33678: IFFALSE 33738
// begin if GetSide ( unit ) = 1 then
33680: LD_VAR 0 1
33684: PPUSH
33685: CALL_OW 255
33689: PUSH
33690: LD_INT 1
33692: EQUAL
33693: IFFALSE 33709
// begin wait ( 0 0$6 ) ;
33695: LD_INT 210
33697: PPUSH
33698: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33702: LD_STRING Motherlode2
33704: PPUSH
33705: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33709: LD_VAR 0 1
33713: PPUSH
33714: CALL_OW 255
33718: PUSH
33719: LD_INT 8
33721: EQUAL
33722: IFFALSE 33738
// begin wait ( 0 0$6 ) ;
33724: LD_INT 210
33726: PPUSH
33727: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33731: LD_STRING Motherlode1
33733: PPUSH
33734: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33738: LD_VAR 0 1
33742: PPUSH
33743: CALL_OW 255
33747: PUSH
33748: LD_INT 3
33750: EQUAL
33751: IFFALSE 33772
// begin wait ( 0 0$5 ) ;
33753: LD_INT 175
33755: PPUSH
33756: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33760: LD_EXP 64
33764: PPUSH
33765: LD_STRING D18-Pla-1
33767: PPUSH
33768: CALL_OW 94
// end ; end ;
33772: PPOPN 3
33774: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33775: LD_VAR 0 1
33779: PUSH
33780: LD_EXP 73
33784: IN
33785: IFFALSE 33805
// begin behemothBuilders := behemothBuilders diff un ;
33787: LD_ADDR_EXP 73
33791: PUSH
33792: LD_EXP 73
33796: PUSH
33797: LD_VAR 0 1
33801: DIFF
33802: ST_TO_ADDR
// exit ;
33803: GO 33885
// end ; if un = JMM then
33805: LD_VAR 0 1
33809: PUSH
33810: LD_EXP 39
33814: EQUAL
33815: IFFALSE 33826
// begin YouLost ( JMM ) ;
33817: LD_STRING JMM
33819: PPUSH
33820: CALL_OW 104
// exit ;
33824: GO 33885
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] ] ) then
33826: LD_VAR 0 1
33830: PUSH
33831: LD_INT 22
33833: PUSH
33834: LD_INT 1
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 23
33843: PUSH
33844: LD_INT 1
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PPUSH
33855: CALL_OW 69
33859: IN
33860: IFFALSE 33876
// lostCounter := lostCounter + 1 ;
33862: LD_ADDR_EXP 32
33866: PUSH
33867: LD_EXP 32
33871: PUSH
33872: LD_INT 1
33874: PLUS
33875: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33876: LD_VAR 0 1
33880: PPUSH
33881: CALL 62113 0 1
// end ;
33885: PPOPN 1
33887: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33888: LD_VAR 0 1
33892: PPUSH
33893: LD_VAR 0 2
33897: PPUSH
33898: CALL 64447 0 2
// end ;
33902: PPOPN 2
33904: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33905: LD_VAR 0 1
33909: PPUSH
33910: CALL 63515 0 1
// end ;
33914: PPOPN 1
33916: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33917: LD_VAR 0 1
33921: PUSH
33922: LD_INT 22
33924: PUSH
33925: LD_INT 8
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: LD_INT 30
33934: PUSH
33935: LD_INT 2
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 23
33944: PUSH
33945: LD_INT 3
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: LIST
33956: PPUSH
33957: CALL_OW 69
33961: IN
33962: IFFALSE 33989
// begin ComUpgrade ( building ) ;
33964: LD_VAR 0 1
33968: PPUSH
33969: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33973: LD_EXP 61
33977: PPUSH
33978: LD_VAR 0 1
33982: PPUSH
33983: CALL 72862 0 2
// exit ;
33987: GO 33998
// end ; MCE_BuildingComplete ( building ) ;
33989: LD_VAR 0 1
33993: PPUSH
33994: CALL 63756 0 1
// end ;
33998: PPOPN 1
34000: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34001: LD_VAR 0 1
34005: PPUSH
34006: LD_VAR 0 2
34010: PPUSH
34011: CALL 61809 0 2
// end ;
34015: PPOPN 2
34017: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34018: LD_VAR 0 1
34022: PPUSH
34023: LD_VAR 0 2
34027: PPUSH
34028: LD_VAR 0 3
34032: PPUSH
34033: LD_VAR 0 4
34037: PPUSH
34038: LD_VAR 0 5
34042: PPUSH
34043: CALL 61429 0 5
// end ;
34047: PPOPN 5
34049: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34050: LD_VAR 0 1
34054: PPUSH
34055: LD_VAR 0 2
34059: PPUSH
34060: CALL 61025 0 2
// end ;
34064: PPOPN 2
34066: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34067: LD_VAR 0 1
34071: PPUSH
34072: LD_VAR 0 2
34076: PPUSH
34077: LD_VAR 0 3
34081: PPUSH
34082: LD_VAR 0 4
34086: PPUSH
34087: CALL 60863 0 4
// end ;
34091: PPOPN 4
34093: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34094: LD_VAR 0 1
34098: PPUSH
34099: LD_VAR 0 2
34103: PPUSH
34104: LD_VAR 0 3
34108: PPUSH
34109: CALL 60638 0 3
// end ;
34113: PPOPN 3
34115: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34116: LD_VAR 0 1
34120: PPUSH
34121: LD_VAR 0 2
34125: PPUSH
34126: CALL 60523 0 2
// end ;
34130: PPOPN 2
34132: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34133: LD_VAR 0 1
34137: PPUSH
34138: LD_VAR 0 2
34142: PPUSH
34143: CALL 64708 0 2
// end ;
34147: PPOPN 2
34149: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34150: LD_VAR 0 1
34154: PPUSH
34155: CALL_OW 255
34159: PUSH
34160: LD_INT 4
34162: EQUAL
34163: PUSH
34164: LD_VAR 0 1
34168: PUSH
34169: LD_EXP 18
34173: PUSH
34174: LD_INT 1
34176: ARRAY
34177: IN
34178: AND
34179: PUSH
34180: LD_EXP 19
34184: AND
34185: IFFALSE 34204
// begin ComMoveXY ( driver , 61 , 93 ) ;
34187: LD_VAR 0 1
34191: PPUSH
34192: LD_INT 61
34194: PPUSH
34195: LD_INT 93
34197: PPUSH
34198: CALL_OW 111
// exit ;
34202: GO 34228
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34204: LD_VAR 0 1
34208: PPUSH
34209: LD_VAR 0 2
34213: PPUSH
34214: LD_VAR 0 3
34218: PPUSH
34219: LD_VAR 0 4
34223: PPUSH
34224: CALL 64924 0 4
// end ;
34228: PPOPN 4
34230: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34231: LD_VAR 0 1
34235: PPUSH
34236: LD_VAR 0 2
34240: PPUSH
34241: CALL 60332 0 2
// end ;
34245: PPOPN 2
34247: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34248: LD_VAR 0 1
34252: PPUSH
34253: CALL 112437 0 1
// end ; end_of_file
34257: PPOPN 1
34259: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34260: LD_EXP 15
34264: PUSH
34265: LD_INT 2
34267: EQUAL
34268: IFFALSE 34747
34270: GO 34272
34272: DISABLE
34273: LD_INT 0
34275: PPUSH
// begin time := 0 0$40 ;
34276: LD_ADDR_VAR 0 1
34280: PUSH
34281: LD_INT 1400
34283: ST_TO_ADDR
// repeat wait ( time ) ;
34284: LD_VAR 0 1
34288: PPUSH
34289: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34293: LD_INT 1
34295: PPUSH
34296: LD_INT 5
34298: PPUSH
34299: CALL_OW 12
34303: PPUSH
34304: LD_INT 106
34306: PPUSH
34307: LD_INT 150
34309: PPUSH
34310: LD_INT 19
34312: PPUSH
34313: LD_INT 1
34315: PPUSH
34316: CALL_OW 56
// time := time + 0 0$9 ;
34320: LD_ADDR_VAR 0 1
34324: PUSH
34325: LD_VAR 0 1
34329: PUSH
34330: LD_INT 315
34332: PLUS
34333: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34334: LD_INT 455
34336: PPUSH
34337: LD_INT 840
34339: PPUSH
34340: CALL_OW 12
34344: PPUSH
34345: CALL_OW 67
// if Prob ( 50 ) then
34349: LD_INT 50
34351: PPUSH
34352: CALL_OW 13
34356: IFFALSE 34385
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34358: LD_INT 1
34360: PPUSH
34361: LD_INT 5
34363: PPUSH
34364: CALL_OW 12
34368: PPUSH
34369: LD_INT 62
34371: PPUSH
34372: LD_INT 108
34374: PPUSH
34375: LD_INT 10
34377: PPUSH
34378: LD_INT 1
34380: PPUSH
34381: CALL_OW 56
// until missionStage > 4 ;
34385: LD_EXP 15
34389: PUSH
34390: LD_INT 4
34392: GREATER
34393: IFFALSE 34284
// repeat wait ( 0 0$1 ) ;
34395: LD_INT 35
34397: PPUSH
34398: CALL_OW 67
// until missionStage = 6 ;
34402: LD_EXP 15
34406: PUSH
34407: LD_INT 6
34409: EQUAL
34410: IFFALSE 34395
// time := 0 0$50 ;
34412: LD_ADDR_VAR 0 1
34416: PUSH
34417: LD_INT 1750
34419: ST_TO_ADDR
// repeat wait ( time ) ;
34420: LD_VAR 0 1
34424: PPUSH
34425: CALL_OW 67
// if Prob ( 50 ) then
34429: LD_INT 50
34431: PPUSH
34432: CALL_OW 13
34436: IFFALSE 34465
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34438: LD_INT 1
34440: PPUSH
34441: LD_INT 5
34443: PPUSH
34444: CALL_OW 12
34448: PPUSH
34449: LD_INT 106
34451: PPUSH
34452: LD_INT 89
34454: PPUSH
34455: LD_INT 45
34457: PPUSH
34458: LD_INT 1
34460: PPUSH
34461: CALL_OW 56
// time := time + 0 0$2 ;
34465: LD_ADDR_VAR 0 1
34469: PUSH
34470: LD_VAR 0 1
34474: PUSH
34475: LD_INT 70
34477: PLUS
34478: ST_TO_ADDR
// if Prob ( 30 ) then
34479: LD_INT 30
34481: PPUSH
34482: CALL_OW 13
34486: IFFALSE 34532
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34488: LD_INT 385
34490: PPUSH
34491: LD_INT 945
34493: PPUSH
34494: CALL_OW 12
34498: PPUSH
34499: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34503: LD_INT 1
34505: PPUSH
34506: LD_INT 5
34508: PPUSH
34509: CALL_OW 12
34513: PPUSH
34514: LD_INT 21
34516: PPUSH
34517: LD_INT 26
34519: PPUSH
34520: LD_INT 12
34522: PPUSH
34523: LD_INT 1
34525: PPUSH
34526: CALL_OW 56
// end else
34530: GO 34568
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34532: LD_INT 700
34534: PPUSH
34535: LD_INT 1225
34537: PPUSH
34538: CALL_OW 12
34542: PPUSH
34543: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34547: LD_INT 1
34549: PPUSH
34550: LD_INT 5
34552: PPUSH
34553: CALL_OW 12
34557: PPUSH
34558: LD_INT 16
34560: PPUSH
34561: LD_INT 1
34563: PPUSH
34564: CALL_OW 55
// end ; if Prob ( 50 ) then
34568: LD_INT 50
34570: PPUSH
34571: CALL_OW 13
34575: IFFALSE 34621
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34577: LD_INT 700
34579: PPUSH
34580: LD_INT 1050
34582: PPUSH
34583: CALL_OW 12
34587: PPUSH
34588: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34592: LD_INT 1
34594: PPUSH
34595: LD_INT 5
34597: PPUSH
34598: CALL_OW 12
34602: PPUSH
34603: LD_INT 181
34605: PPUSH
34606: LD_INT 218
34608: PPUSH
34609: LD_INT 16
34611: PPUSH
34612: LD_INT 1
34614: PPUSH
34615: CALL_OW 56
// end else
34619: GO 34657
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34621: LD_INT 350
34623: PPUSH
34624: LD_INT 525
34626: PPUSH
34627: CALL_OW 12
34631: PPUSH
34632: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34636: LD_INT 1
34638: PPUSH
34639: LD_INT 5
34641: PPUSH
34642: CALL_OW 12
34646: PPUSH
34647: LD_INT 15
34649: PPUSH
34650: LD_INT 1
34652: PPUSH
34653: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34657: LD_INT 45
34659: PUSH
34660: LD_INT 32
34662: PUSH
34663: LD_INT 25
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: LIST
34670: PUSH
34671: LD_OWVAR 67
34675: ARRAY
34676: PPUSH
34677: CALL_OW 13
34681: IFFALSE 34725
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34683: LD_INT 175
34685: PPUSH
34686: LD_INT 315
34688: PPUSH
34689: CALL_OW 12
34693: PPUSH
34694: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34698: LD_INT 1
34700: PPUSH
34701: LD_INT 5
34703: PPUSH
34704: CALL_OW 12
34708: PPUSH
34709: LD_INT 103
34711: PPUSH
34712: LD_INT 140
34714: PPUSH
34715: LD_INT 20
34717: PPUSH
34718: LD_INT 1
34720: PPUSH
34721: CALL_OW 56
// end ; if time > 1 1$20 then
34725: LD_VAR 0 1
34729: PUSH
34730: LD_INT 2800
34732: GREATER
34733: IFFALSE 34743
// time := 0 0$30 ;
34735: LD_ADDR_VAR 0 1
34739: PUSH
34740: LD_INT 1050
34742: ST_TO_ADDR
// until false ;
34743: LD_INT 0
34745: IFFALSE 34420
// end ; end_of_file
34747: PPOPN 1
34749: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34750: LD_EXP 13
34754: PUSH
34755: LD_EXP 15
34759: PUSH
34760: LD_INT 6
34762: GREATEREQUAL
34763: AND
34764: IFFALSE 34801
34766: GO 34768
34768: DISABLE
// begin enable ;
34769: ENABLE
// missionTime := missionTime + 0 0$1 ;
34770: LD_ADDR_EXP 14
34774: PUSH
34775: LD_EXP 14
34779: PUSH
34780: LD_INT 35
34782: PLUS
34783: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34784: LD_ADDR_OWVAR 47
34788: PUSH
34789: LD_STRING #Am15-1
34791: PUSH
34792: LD_EXP 14
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: ST_TO_ADDR
// end ; end_of_file
34801: END
// export function InitNature ; begin
34802: LD_INT 0
34804: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34805: LD_INT 3
34807: PPUSH
34808: LD_INT 3
34810: PPUSH
34811: LD_INT 2
34813: PPUSH
34814: LD_INT 1
34816: PPUSH
34817: LD_INT 1
34819: PPUSH
34820: LD_INT 0
34822: PPUSH
34823: LD_INT 0
34825: PPUSH
34826: LD_INT 20
34828: PPUSH
34829: LD_INT 0
34831: PPUSH
34832: CALL 97680 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34836: LD_INT 2
34838: PPUSH
34839: LD_INT 1
34841: PPUSH
34842: LD_INT 1
34844: PPUSH
34845: LD_INT 1
34847: PPUSH
34848: LD_INT 1
34850: PPUSH
34851: LD_INT 0
34853: PPUSH
34854: LD_INT 0
34856: PPUSH
34857: LD_INT 21
34859: PPUSH
34860: LD_INT 0
34862: PPUSH
34863: CALL 97680 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34867: LD_INT 4
34869: PPUSH
34870: LD_INT 1
34872: PPUSH
34873: LD_INT 2
34875: PPUSH
34876: LD_INT 4
34878: PPUSH
34879: LD_INT 2
34881: PPUSH
34882: LD_INT 1
34884: PPUSH
34885: LD_INT 0
34887: PPUSH
34888: LD_INT 22
34890: PPUSH
34891: LD_INT 0
34893: PPUSH
34894: CALL 97680 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34898: LD_INT 0
34900: PPUSH
34901: LD_INT 0
34903: PPUSH
34904: LD_INT 0
34906: PPUSH
34907: LD_INT 0
34909: PPUSH
34910: LD_INT 0
34912: PPUSH
34913: LD_INT 0
34915: PPUSH
34916: LD_INT 9
34918: PPUSH
34919: LD_INT 0
34921: PPUSH
34922: LD_INT 23
34924: PPUSH
34925: CALL 97680 0 9
// end ; end_of_file
34929: LD_VAR 0 1
34933: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
34934: GO 34936
34936: DISABLE
// begin ru_radar := 98 ;
34937: LD_ADDR_EXP 95
34941: PUSH
34942: LD_INT 98
34944: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34945: LD_ADDR_EXP 96
34949: PUSH
34950: LD_INT 89
34952: ST_TO_ADDR
// us_hack := 99 ;
34953: LD_ADDR_EXP 97
34957: PUSH
34958: LD_INT 99
34960: ST_TO_ADDR
// us_artillery := 97 ;
34961: LD_ADDR_EXP 98
34965: PUSH
34966: LD_INT 97
34968: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34969: LD_ADDR_EXP 99
34973: PUSH
34974: LD_INT 91
34976: ST_TO_ADDR
// tech_Artillery := 80 ;
34977: LD_ADDR_EXP 100
34981: PUSH
34982: LD_INT 80
34984: ST_TO_ADDR
// tech_RadMat := 81 ;
34985: LD_ADDR_EXP 101
34989: PUSH
34990: LD_INT 81
34992: ST_TO_ADDR
// tech_BasicTools := 82 ;
34993: LD_ADDR_EXP 102
34997: PUSH
34998: LD_INT 82
35000: ST_TO_ADDR
// tech_Cargo := 83 ;
35001: LD_ADDR_EXP 103
35005: PUSH
35006: LD_INT 83
35008: ST_TO_ADDR
// tech_Track := 84 ;
35009: LD_ADDR_EXP 104
35013: PUSH
35014: LD_INT 84
35016: ST_TO_ADDR
// tech_Crane := 85 ;
35017: LD_ADDR_EXP 105
35021: PUSH
35022: LD_INT 85
35024: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35025: LD_ADDR_EXP 106
35029: PUSH
35030: LD_INT 86
35032: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35033: LD_ADDR_EXP 107
35037: PUSH
35038: LD_INT 87
35040: ST_TO_ADDR
// end ; end_of_file
35041: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35042: LD_INT 0
35044: PPUSH
35045: PPUSH
// skirmish := false ;
35046: LD_ADDR_EXP 108
35050: PUSH
35051: LD_INT 0
35053: ST_TO_ADDR
// debug_mc := false ;
35054: LD_ADDR_EXP 109
35058: PUSH
35059: LD_INT 0
35061: ST_TO_ADDR
// mc_bases := [ ] ;
35062: LD_ADDR_EXP 110
35066: PUSH
35067: EMPTY
35068: ST_TO_ADDR
// mc_sides := [ ] ;
35069: LD_ADDR_EXP 136
35073: PUSH
35074: EMPTY
35075: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35076: LD_ADDR_EXP 111
35080: PUSH
35081: EMPTY
35082: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35083: LD_ADDR_EXP 112
35087: PUSH
35088: EMPTY
35089: ST_TO_ADDR
// mc_need_heal := [ ] ;
35090: LD_ADDR_EXP 113
35094: PUSH
35095: EMPTY
35096: ST_TO_ADDR
// mc_healers := [ ] ;
35097: LD_ADDR_EXP 114
35101: PUSH
35102: EMPTY
35103: ST_TO_ADDR
// mc_build_list := [ ] ;
35104: LD_ADDR_EXP 115
35108: PUSH
35109: EMPTY
35110: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35111: LD_ADDR_EXP 142
35115: PUSH
35116: EMPTY
35117: ST_TO_ADDR
// mc_builders := [ ] ;
35118: LD_ADDR_EXP 116
35122: PUSH
35123: EMPTY
35124: ST_TO_ADDR
// mc_construct_list := [ ] ;
35125: LD_ADDR_EXP 117
35129: PUSH
35130: EMPTY
35131: ST_TO_ADDR
// mc_turret_list := [ ] ;
35132: LD_ADDR_EXP 118
35136: PUSH
35137: EMPTY
35138: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35139: LD_ADDR_EXP 119
35143: PUSH
35144: EMPTY
35145: ST_TO_ADDR
// mc_miners := [ ] ;
35146: LD_ADDR_EXP 124
35150: PUSH
35151: EMPTY
35152: ST_TO_ADDR
// mc_mines := [ ] ;
35153: LD_ADDR_EXP 123
35157: PUSH
35158: EMPTY
35159: ST_TO_ADDR
// mc_minefields := [ ] ;
35160: LD_ADDR_EXP 125
35164: PUSH
35165: EMPTY
35166: ST_TO_ADDR
// mc_crates := [ ] ;
35167: LD_ADDR_EXP 126
35171: PUSH
35172: EMPTY
35173: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35174: LD_ADDR_EXP 127
35178: PUSH
35179: EMPTY
35180: ST_TO_ADDR
// mc_crates_area := [ ] ;
35181: LD_ADDR_EXP 128
35185: PUSH
35186: EMPTY
35187: ST_TO_ADDR
// mc_vehicles := [ ] ;
35188: LD_ADDR_EXP 129
35192: PUSH
35193: EMPTY
35194: ST_TO_ADDR
// mc_attack := [ ] ;
35195: LD_ADDR_EXP 130
35199: PUSH
35200: EMPTY
35201: ST_TO_ADDR
// mc_produce := [ ] ;
35202: LD_ADDR_EXP 131
35206: PUSH
35207: EMPTY
35208: ST_TO_ADDR
// mc_defender := [ ] ;
35209: LD_ADDR_EXP 132
35213: PUSH
35214: EMPTY
35215: ST_TO_ADDR
// mc_parking := [ ] ;
35216: LD_ADDR_EXP 134
35220: PUSH
35221: EMPTY
35222: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35223: LD_ADDR_EXP 120
35227: PUSH
35228: EMPTY
35229: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35230: LD_ADDR_EXP 122
35234: PUSH
35235: EMPTY
35236: ST_TO_ADDR
// mc_scan := [ ] ;
35237: LD_ADDR_EXP 133
35241: PUSH
35242: EMPTY
35243: ST_TO_ADDR
// mc_scan_area := [ ] ;
35244: LD_ADDR_EXP 135
35248: PUSH
35249: EMPTY
35250: ST_TO_ADDR
// mc_tech := [ ] ;
35251: LD_ADDR_EXP 137
35255: PUSH
35256: EMPTY
35257: ST_TO_ADDR
// mc_class := [ ] ;
35258: LD_ADDR_EXP 151
35262: PUSH
35263: EMPTY
35264: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35265: LD_ADDR_EXP 152
35269: PUSH
35270: EMPTY
35271: ST_TO_ADDR
// end ;
35272: LD_VAR 0 1
35276: RET
// export function MC_Kill ( base ) ; begin
35277: LD_INT 0
35279: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35280: LD_ADDR_EXP 110
35284: PUSH
35285: LD_EXP 110
35289: PPUSH
35290: LD_VAR 0 1
35294: PPUSH
35295: EMPTY
35296: PPUSH
35297: CALL_OW 1
35301: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35302: LD_ADDR_EXP 111
35306: PUSH
35307: LD_EXP 111
35311: PPUSH
35312: LD_VAR 0 1
35316: PPUSH
35317: EMPTY
35318: PPUSH
35319: CALL_OW 1
35323: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35324: LD_ADDR_EXP 112
35328: PUSH
35329: LD_EXP 112
35333: PPUSH
35334: LD_VAR 0 1
35338: PPUSH
35339: EMPTY
35340: PPUSH
35341: CALL_OW 1
35345: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35346: LD_ADDR_EXP 113
35350: PUSH
35351: LD_EXP 113
35355: PPUSH
35356: LD_VAR 0 1
35360: PPUSH
35361: EMPTY
35362: PPUSH
35363: CALL_OW 1
35367: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35368: LD_ADDR_EXP 114
35372: PUSH
35373: LD_EXP 114
35377: PPUSH
35378: LD_VAR 0 1
35382: PPUSH
35383: EMPTY
35384: PPUSH
35385: CALL_OW 1
35389: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35390: LD_ADDR_EXP 115
35394: PUSH
35395: LD_EXP 115
35399: PPUSH
35400: LD_VAR 0 1
35404: PPUSH
35405: EMPTY
35406: PPUSH
35407: CALL_OW 1
35411: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35412: LD_ADDR_EXP 116
35416: PUSH
35417: LD_EXP 116
35421: PPUSH
35422: LD_VAR 0 1
35426: PPUSH
35427: EMPTY
35428: PPUSH
35429: CALL_OW 1
35433: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35434: LD_ADDR_EXP 117
35438: PUSH
35439: LD_EXP 117
35443: PPUSH
35444: LD_VAR 0 1
35448: PPUSH
35449: EMPTY
35450: PPUSH
35451: CALL_OW 1
35455: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35456: LD_ADDR_EXP 118
35460: PUSH
35461: LD_EXP 118
35465: PPUSH
35466: LD_VAR 0 1
35470: PPUSH
35471: EMPTY
35472: PPUSH
35473: CALL_OW 1
35477: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35478: LD_ADDR_EXP 119
35482: PUSH
35483: LD_EXP 119
35487: PPUSH
35488: LD_VAR 0 1
35492: PPUSH
35493: EMPTY
35494: PPUSH
35495: CALL_OW 1
35499: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35500: LD_ADDR_EXP 120
35504: PUSH
35505: LD_EXP 120
35509: PPUSH
35510: LD_VAR 0 1
35514: PPUSH
35515: EMPTY
35516: PPUSH
35517: CALL_OW 1
35521: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35522: LD_ADDR_EXP 121
35526: PUSH
35527: LD_EXP 121
35531: PPUSH
35532: LD_VAR 0 1
35536: PPUSH
35537: LD_INT 0
35539: PPUSH
35540: CALL_OW 1
35544: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35545: LD_ADDR_EXP 122
35549: PUSH
35550: LD_EXP 122
35554: PPUSH
35555: LD_VAR 0 1
35559: PPUSH
35560: EMPTY
35561: PPUSH
35562: CALL_OW 1
35566: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35567: LD_ADDR_EXP 123
35571: PUSH
35572: LD_EXP 123
35576: PPUSH
35577: LD_VAR 0 1
35581: PPUSH
35582: EMPTY
35583: PPUSH
35584: CALL_OW 1
35588: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35589: LD_ADDR_EXP 124
35593: PUSH
35594: LD_EXP 124
35598: PPUSH
35599: LD_VAR 0 1
35603: PPUSH
35604: EMPTY
35605: PPUSH
35606: CALL_OW 1
35610: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35611: LD_ADDR_EXP 125
35615: PUSH
35616: LD_EXP 125
35620: PPUSH
35621: LD_VAR 0 1
35625: PPUSH
35626: EMPTY
35627: PPUSH
35628: CALL_OW 1
35632: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35633: LD_ADDR_EXP 126
35637: PUSH
35638: LD_EXP 126
35642: PPUSH
35643: LD_VAR 0 1
35647: PPUSH
35648: EMPTY
35649: PPUSH
35650: CALL_OW 1
35654: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35655: LD_ADDR_EXP 127
35659: PUSH
35660: LD_EXP 127
35664: PPUSH
35665: LD_VAR 0 1
35669: PPUSH
35670: EMPTY
35671: PPUSH
35672: CALL_OW 1
35676: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35677: LD_ADDR_EXP 128
35681: PUSH
35682: LD_EXP 128
35686: PPUSH
35687: LD_VAR 0 1
35691: PPUSH
35692: EMPTY
35693: PPUSH
35694: CALL_OW 1
35698: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35699: LD_ADDR_EXP 129
35703: PUSH
35704: LD_EXP 129
35708: PPUSH
35709: LD_VAR 0 1
35713: PPUSH
35714: EMPTY
35715: PPUSH
35716: CALL_OW 1
35720: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35721: LD_ADDR_EXP 130
35725: PUSH
35726: LD_EXP 130
35730: PPUSH
35731: LD_VAR 0 1
35735: PPUSH
35736: EMPTY
35737: PPUSH
35738: CALL_OW 1
35742: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35743: LD_ADDR_EXP 131
35747: PUSH
35748: LD_EXP 131
35752: PPUSH
35753: LD_VAR 0 1
35757: PPUSH
35758: EMPTY
35759: PPUSH
35760: CALL_OW 1
35764: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35765: LD_ADDR_EXP 132
35769: PUSH
35770: LD_EXP 132
35774: PPUSH
35775: LD_VAR 0 1
35779: PPUSH
35780: EMPTY
35781: PPUSH
35782: CALL_OW 1
35786: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35787: LD_ADDR_EXP 133
35791: PUSH
35792: LD_EXP 133
35796: PPUSH
35797: LD_VAR 0 1
35801: PPUSH
35802: EMPTY
35803: PPUSH
35804: CALL_OW 1
35808: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35809: LD_ADDR_EXP 134
35813: PUSH
35814: LD_EXP 134
35818: PPUSH
35819: LD_VAR 0 1
35823: PPUSH
35824: EMPTY
35825: PPUSH
35826: CALL_OW 1
35830: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35831: LD_ADDR_EXP 135
35835: PUSH
35836: LD_EXP 135
35840: PPUSH
35841: LD_VAR 0 1
35845: PPUSH
35846: EMPTY
35847: PPUSH
35848: CALL_OW 1
35852: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35853: LD_ADDR_EXP 137
35857: PUSH
35858: LD_EXP 137
35862: PPUSH
35863: LD_VAR 0 1
35867: PPUSH
35868: EMPTY
35869: PPUSH
35870: CALL_OW 1
35874: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35875: LD_ADDR_EXP 139
35879: PUSH
35880: LD_EXP 139
35884: PPUSH
35885: LD_VAR 0 1
35889: PPUSH
35890: EMPTY
35891: PPUSH
35892: CALL_OW 1
35896: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35897: LD_ADDR_EXP 140
35901: PUSH
35902: LD_EXP 140
35906: PPUSH
35907: LD_VAR 0 1
35911: PPUSH
35912: EMPTY
35913: PPUSH
35914: CALL_OW 1
35918: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35919: LD_ADDR_EXP 141
35923: PUSH
35924: LD_EXP 141
35928: PPUSH
35929: LD_VAR 0 1
35933: PPUSH
35934: EMPTY
35935: PPUSH
35936: CALL_OW 1
35940: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35941: LD_ADDR_EXP 142
35945: PUSH
35946: LD_EXP 142
35950: PPUSH
35951: LD_VAR 0 1
35955: PPUSH
35956: EMPTY
35957: PPUSH
35958: CALL_OW 1
35962: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35963: LD_ADDR_EXP 143
35967: PUSH
35968: LD_EXP 143
35972: PPUSH
35973: LD_VAR 0 1
35977: PPUSH
35978: EMPTY
35979: PPUSH
35980: CALL_OW 1
35984: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35985: LD_ADDR_EXP 144
35989: PUSH
35990: LD_EXP 144
35994: PPUSH
35995: LD_VAR 0 1
35999: PPUSH
36000: EMPTY
36001: PPUSH
36002: CALL_OW 1
36006: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36007: LD_ADDR_EXP 145
36011: PUSH
36012: LD_EXP 145
36016: PPUSH
36017: LD_VAR 0 1
36021: PPUSH
36022: EMPTY
36023: PPUSH
36024: CALL_OW 1
36028: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36029: LD_ADDR_EXP 146
36033: PUSH
36034: LD_EXP 146
36038: PPUSH
36039: LD_VAR 0 1
36043: PPUSH
36044: EMPTY
36045: PPUSH
36046: CALL_OW 1
36050: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36051: LD_ADDR_EXP 147
36055: PUSH
36056: LD_EXP 147
36060: PPUSH
36061: LD_VAR 0 1
36065: PPUSH
36066: EMPTY
36067: PPUSH
36068: CALL_OW 1
36072: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36073: LD_ADDR_EXP 148
36077: PUSH
36078: LD_EXP 148
36082: PPUSH
36083: LD_VAR 0 1
36087: PPUSH
36088: EMPTY
36089: PPUSH
36090: CALL_OW 1
36094: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36095: LD_ADDR_EXP 149
36099: PUSH
36100: LD_EXP 149
36104: PPUSH
36105: LD_VAR 0 1
36109: PPUSH
36110: EMPTY
36111: PPUSH
36112: CALL_OW 1
36116: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36117: LD_ADDR_EXP 150
36121: PUSH
36122: LD_EXP 150
36126: PPUSH
36127: LD_VAR 0 1
36131: PPUSH
36132: EMPTY
36133: PPUSH
36134: CALL_OW 1
36138: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36139: LD_ADDR_EXP 151
36143: PUSH
36144: LD_EXP 151
36148: PPUSH
36149: LD_VAR 0 1
36153: PPUSH
36154: EMPTY
36155: PPUSH
36156: CALL_OW 1
36160: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36161: LD_ADDR_EXP 152
36165: PUSH
36166: LD_EXP 152
36170: PPUSH
36171: LD_VAR 0 1
36175: PPUSH
36176: LD_INT 0
36178: PPUSH
36179: CALL_OW 1
36183: ST_TO_ADDR
// end ;
36184: LD_VAR 0 2
36188: RET
// export function MC_Add ( side , units ) ; var base ; begin
36189: LD_INT 0
36191: PPUSH
36192: PPUSH
// base := mc_bases + 1 ;
36193: LD_ADDR_VAR 0 4
36197: PUSH
36198: LD_EXP 110
36202: PUSH
36203: LD_INT 1
36205: PLUS
36206: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36207: LD_ADDR_EXP 136
36211: PUSH
36212: LD_EXP 136
36216: PPUSH
36217: LD_VAR 0 4
36221: PPUSH
36222: LD_VAR 0 1
36226: PPUSH
36227: CALL_OW 1
36231: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36232: LD_ADDR_EXP 110
36236: PUSH
36237: LD_EXP 110
36241: PPUSH
36242: LD_VAR 0 4
36246: PPUSH
36247: LD_VAR 0 2
36251: PPUSH
36252: CALL_OW 1
36256: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36257: LD_ADDR_EXP 111
36261: PUSH
36262: LD_EXP 111
36266: PPUSH
36267: LD_VAR 0 4
36271: PPUSH
36272: EMPTY
36273: PPUSH
36274: CALL_OW 1
36278: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36279: LD_ADDR_EXP 112
36283: PUSH
36284: LD_EXP 112
36288: PPUSH
36289: LD_VAR 0 4
36293: PPUSH
36294: EMPTY
36295: PPUSH
36296: CALL_OW 1
36300: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36301: LD_ADDR_EXP 113
36305: PUSH
36306: LD_EXP 113
36310: PPUSH
36311: LD_VAR 0 4
36315: PPUSH
36316: EMPTY
36317: PPUSH
36318: CALL_OW 1
36322: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36323: LD_ADDR_EXP 114
36327: PUSH
36328: LD_EXP 114
36332: PPUSH
36333: LD_VAR 0 4
36337: PPUSH
36338: EMPTY
36339: PPUSH
36340: CALL_OW 1
36344: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36345: LD_ADDR_EXP 115
36349: PUSH
36350: LD_EXP 115
36354: PPUSH
36355: LD_VAR 0 4
36359: PPUSH
36360: EMPTY
36361: PPUSH
36362: CALL_OW 1
36366: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36367: LD_ADDR_EXP 116
36371: PUSH
36372: LD_EXP 116
36376: PPUSH
36377: LD_VAR 0 4
36381: PPUSH
36382: EMPTY
36383: PPUSH
36384: CALL_OW 1
36388: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36389: LD_ADDR_EXP 117
36393: PUSH
36394: LD_EXP 117
36398: PPUSH
36399: LD_VAR 0 4
36403: PPUSH
36404: EMPTY
36405: PPUSH
36406: CALL_OW 1
36410: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36411: LD_ADDR_EXP 118
36415: PUSH
36416: LD_EXP 118
36420: PPUSH
36421: LD_VAR 0 4
36425: PPUSH
36426: EMPTY
36427: PPUSH
36428: CALL_OW 1
36432: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36433: LD_ADDR_EXP 119
36437: PUSH
36438: LD_EXP 119
36442: PPUSH
36443: LD_VAR 0 4
36447: PPUSH
36448: EMPTY
36449: PPUSH
36450: CALL_OW 1
36454: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36455: LD_ADDR_EXP 120
36459: PUSH
36460: LD_EXP 120
36464: PPUSH
36465: LD_VAR 0 4
36469: PPUSH
36470: EMPTY
36471: PPUSH
36472: CALL_OW 1
36476: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36477: LD_ADDR_EXP 121
36481: PUSH
36482: LD_EXP 121
36486: PPUSH
36487: LD_VAR 0 4
36491: PPUSH
36492: LD_INT 0
36494: PPUSH
36495: CALL_OW 1
36499: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36500: LD_ADDR_EXP 122
36504: PUSH
36505: LD_EXP 122
36509: PPUSH
36510: LD_VAR 0 4
36514: PPUSH
36515: EMPTY
36516: PPUSH
36517: CALL_OW 1
36521: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36522: LD_ADDR_EXP 123
36526: PUSH
36527: LD_EXP 123
36531: PPUSH
36532: LD_VAR 0 4
36536: PPUSH
36537: EMPTY
36538: PPUSH
36539: CALL_OW 1
36543: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36544: LD_ADDR_EXP 124
36548: PUSH
36549: LD_EXP 124
36553: PPUSH
36554: LD_VAR 0 4
36558: PPUSH
36559: EMPTY
36560: PPUSH
36561: CALL_OW 1
36565: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36566: LD_ADDR_EXP 125
36570: PUSH
36571: LD_EXP 125
36575: PPUSH
36576: LD_VAR 0 4
36580: PPUSH
36581: EMPTY
36582: PPUSH
36583: CALL_OW 1
36587: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36588: LD_ADDR_EXP 126
36592: PUSH
36593: LD_EXP 126
36597: PPUSH
36598: LD_VAR 0 4
36602: PPUSH
36603: EMPTY
36604: PPUSH
36605: CALL_OW 1
36609: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36610: LD_ADDR_EXP 127
36614: PUSH
36615: LD_EXP 127
36619: PPUSH
36620: LD_VAR 0 4
36624: PPUSH
36625: EMPTY
36626: PPUSH
36627: CALL_OW 1
36631: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36632: LD_ADDR_EXP 128
36636: PUSH
36637: LD_EXP 128
36641: PPUSH
36642: LD_VAR 0 4
36646: PPUSH
36647: EMPTY
36648: PPUSH
36649: CALL_OW 1
36653: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36654: LD_ADDR_EXP 129
36658: PUSH
36659: LD_EXP 129
36663: PPUSH
36664: LD_VAR 0 4
36668: PPUSH
36669: EMPTY
36670: PPUSH
36671: CALL_OW 1
36675: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36676: LD_ADDR_EXP 130
36680: PUSH
36681: LD_EXP 130
36685: PPUSH
36686: LD_VAR 0 4
36690: PPUSH
36691: EMPTY
36692: PPUSH
36693: CALL_OW 1
36697: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36698: LD_ADDR_EXP 131
36702: PUSH
36703: LD_EXP 131
36707: PPUSH
36708: LD_VAR 0 4
36712: PPUSH
36713: EMPTY
36714: PPUSH
36715: CALL_OW 1
36719: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36720: LD_ADDR_EXP 132
36724: PUSH
36725: LD_EXP 132
36729: PPUSH
36730: LD_VAR 0 4
36734: PPUSH
36735: EMPTY
36736: PPUSH
36737: CALL_OW 1
36741: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36742: LD_ADDR_EXP 133
36746: PUSH
36747: LD_EXP 133
36751: PPUSH
36752: LD_VAR 0 4
36756: PPUSH
36757: EMPTY
36758: PPUSH
36759: CALL_OW 1
36763: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36764: LD_ADDR_EXP 134
36768: PUSH
36769: LD_EXP 134
36773: PPUSH
36774: LD_VAR 0 4
36778: PPUSH
36779: EMPTY
36780: PPUSH
36781: CALL_OW 1
36785: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36786: LD_ADDR_EXP 135
36790: PUSH
36791: LD_EXP 135
36795: PPUSH
36796: LD_VAR 0 4
36800: PPUSH
36801: EMPTY
36802: PPUSH
36803: CALL_OW 1
36807: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36808: LD_ADDR_EXP 137
36812: PUSH
36813: LD_EXP 137
36817: PPUSH
36818: LD_VAR 0 4
36822: PPUSH
36823: EMPTY
36824: PPUSH
36825: CALL_OW 1
36829: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36830: LD_ADDR_EXP 139
36834: PUSH
36835: LD_EXP 139
36839: PPUSH
36840: LD_VAR 0 4
36844: PPUSH
36845: EMPTY
36846: PPUSH
36847: CALL_OW 1
36851: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36852: LD_ADDR_EXP 140
36856: PUSH
36857: LD_EXP 140
36861: PPUSH
36862: LD_VAR 0 4
36866: PPUSH
36867: EMPTY
36868: PPUSH
36869: CALL_OW 1
36873: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36874: LD_ADDR_EXP 141
36878: PUSH
36879: LD_EXP 141
36883: PPUSH
36884: LD_VAR 0 4
36888: PPUSH
36889: EMPTY
36890: PPUSH
36891: CALL_OW 1
36895: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36896: LD_ADDR_EXP 142
36900: PUSH
36901: LD_EXP 142
36905: PPUSH
36906: LD_VAR 0 4
36910: PPUSH
36911: EMPTY
36912: PPUSH
36913: CALL_OW 1
36917: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36918: LD_ADDR_EXP 143
36922: PUSH
36923: LD_EXP 143
36927: PPUSH
36928: LD_VAR 0 4
36932: PPUSH
36933: EMPTY
36934: PPUSH
36935: CALL_OW 1
36939: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36940: LD_ADDR_EXP 144
36944: PUSH
36945: LD_EXP 144
36949: PPUSH
36950: LD_VAR 0 4
36954: PPUSH
36955: EMPTY
36956: PPUSH
36957: CALL_OW 1
36961: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36962: LD_ADDR_EXP 145
36966: PUSH
36967: LD_EXP 145
36971: PPUSH
36972: LD_VAR 0 4
36976: PPUSH
36977: EMPTY
36978: PPUSH
36979: CALL_OW 1
36983: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36984: LD_ADDR_EXP 146
36988: PUSH
36989: LD_EXP 146
36993: PPUSH
36994: LD_VAR 0 4
36998: PPUSH
36999: EMPTY
37000: PPUSH
37001: CALL_OW 1
37005: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37006: LD_ADDR_EXP 147
37010: PUSH
37011: LD_EXP 147
37015: PPUSH
37016: LD_VAR 0 4
37020: PPUSH
37021: EMPTY
37022: PPUSH
37023: CALL_OW 1
37027: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37028: LD_ADDR_EXP 148
37032: PUSH
37033: LD_EXP 148
37037: PPUSH
37038: LD_VAR 0 4
37042: PPUSH
37043: EMPTY
37044: PPUSH
37045: CALL_OW 1
37049: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37050: LD_ADDR_EXP 149
37054: PUSH
37055: LD_EXP 149
37059: PPUSH
37060: LD_VAR 0 4
37064: PPUSH
37065: EMPTY
37066: PPUSH
37067: CALL_OW 1
37071: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37072: LD_ADDR_EXP 150
37076: PUSH
37077: LD_EXP 150
37081: PPUSH
37082: LD_VAR 0 4
37086: PPUSH
37087: EMPTY
37088: PPUSH
37089: CALL_OW 1
37093: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37094: LD_ADDR_EXP 151
37098: PUSH
37099: LD_EXP 151
37103: PPUSH
37104: LD_VAR 0 4
37108: PPUSH
37109: EMPTY
37110: PPUSH
37111: CALL_OW 1
37115: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37116: LD_ADDR_EXP 152
37120: PUSH
37121: LD_EXP 152
37125: PPUSH
37126: LD_VAR 0 4
37130: PPUSH
37131: LD_INT 0
37133: PPUSH
37134: CALL_OW 1
37138: ST_TO_ADDR
// result := base ;
37139: LD_ADDR_VAR 0 3
37143: PUSH
37144: LD_VAR 0 4
37148: ST_TO_ADDR
// end ;
37149: LD_VAR 0 3
37153: RET
// export function MC_Start ( ) ; var i ; begin
37154: LD_INT 0
37156: PPUSH
37157: PPUSH
// for i = 1 to mc_bases do
37158: LD_ADDR_VAR 0 2
37162: PUSH
37163: DOUBLE
37164: LD_INT 1
37166: DEC
37167: ST_TO_ADDR
37168: LD_EXP 110
37172: PUSH
37173: FOR_TO
37174: IFFALSE 38251
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37176: LD_ADDR_EXP 110
37180: PUSH
37181: LD_EXP 110
37185: PPUSH
37186: LD_VAR 0 2
37190: PPUSH
37191: LD_EXP 110
37195: PUSH
37196: LD_VAR 0 2
37200: ARRAY
37201: PUSH
37202: LD_INT 0
37204: DIFF
37205: PPUSH
37206: CALL_OW 1
37210: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37211: LD_ADDR_EXP 111
37215: PUSH
37216: LD_EXP 111
37220: PPUSH
37221: LD_VAR 0 2
37225: PPUSH
37226: EMPTY
37227: PPUSH
37228: CALL_OW 1
37232: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37233: LD_ADDR_EXP 112
37237: PUSH
37238: LD_EXP 112
37242: PPUSH
37243: LD_VAR 0 2
37247: PPUSH
37248: EMPTY
37249: PPUSH
37250: CALL_OW 1
37254: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37255: LD_ADDR_EXP 113
37259: PUSH
37260: LD_EXP 113
37264: PPUSH
37265: LD_VAR 0 2
37269: PPUSH
37270: EMPTY
37271: PPUSH
37272: CALL_OW 1
37276: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37277: LD_ADDR_EXP 114
37281: PUSH
37282: LD_EXP 114
37286: PPUSH
37287: LD_VAR 0 2
37291: PPUSH
37292: EMPTY
37293: PUSH
37294: EMPTY
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PPUSH
37300: CALL_OW 1
37304: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37305: LD_ADDR_EXP 115
37309: PUSH
37310: LD_EXP 115
37314: PPUSH
37315: LD_VAR 0 2
37319: PPUSH
37320: EMPTY
37321: PPUSH
37322: CALL_OW 1
37326: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37327: LD_ADDR_EXP 142
37331: PUSH
37332: LD_EXP 142
37336: PPUSH
37337: LD_VAR 0 2
37341: PPUSH
37342: EMPTY
37343: PPUSH
37344: CALL_OW 1
37348: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37349: LD_ADDR_EXP 116
37353: PUSH
37354: LD_EXP 116
37358: PPUSH
37359: LD_VAR 0 2
37363: PPUSH
37364: EMPTY
37365: PPUSH
37366: CALL_OW 1
37370: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37371: LD_ADDR_EXP 117
37375: PUSH
37376: LD_EXP 117
37380: PPUSH
37381: LD_VAR 0 2
37385: PPUSH
37386: EMPTY
37387: PPUSH
37388: CALL_OW 1
37392: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37393: LD_ADDR_EXP 118
37397: PUSH
37398: LD_EXP 118
37402: PPUSH
37403: LD_VAR 0 2
37407: PPUSH
37408: LD_EXP 110
37412: PUSH
37413: LD_VAR 0 2
37417: ARRAY
37418: PPUSH
37419: LD_INT 2
37421: PUSH
37422: LD_INT 30
37424: PUSH
37425: LD_INT 32
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 30
37434: PUSH
37435: LD_INT 33
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: LIST
37446: PPUSH
37447: CALL_OW 72
37451: PPUSH
37452: CALL_OW 1
37456: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37457: LD_ADDR_EXP 119
37461: PUSH
37462: LD_EXP 119
37466: PPUSH
37467: LD_VAR 0 2
37471: PPUSH
37472: LD_EXP 110
37476: PUSH
37477: LD_VAR 0 2
37481: ARRAY
37482: PPUSH
37483: LD_INT 2
37485: PUSH
37486: LD_INT 30
37488: PUSH
37489: LD_INT 32
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 30
37498: PUSH
37499: LD_INT 31
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 58
37513: PUSH
37514: EMPTY
37515: LIST
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PPUSH
37521: CALL_OW 72
37525: PPUSH
37526: CALL_OW 1
37530: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37531: LD_ADDR_EXP 120
37535: PUSH
37536: LD_EXP 120
37540: PPUSH
37541: LD_VAR 0 2
37545: PPUSH
37546: EMPTY
37547: PPUSH
37548: CALL_OW 1
37552: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37553: LD_ADDR_EXP 124
37557: PUSH
37558: LD_EXP 124
37562: PPUSH
37563: LD_VAR 0 2
37567: PPUSH
37568: EMPTY
37569: PPUSH
37570: CALL_OW 1
37574: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37575: LD_ADDR_EXP 123
37579: PUSH
37580: LD_EXP 123
37584: PPUSH
37585: LD_VAR 0 2
37589: PPUSH
37590: EMPTY
37591: PPUSH
37592: CALL_OW 1
37596: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37597: LD_ADDR_EXP 125
37601: PUSH
37602: LD_EXP 125
37606: PPUSH
37607: LD_VAR 0 2
37611: PPUSH
37612: EMPTY
37613: PPUSH
37614: CALL_OW 1
37618: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37619: LD_ADDR_EXP 126
37623: PUSH
37624: LD_EXP 126
37628: PPUSH
37629: LD_VAR 0 2
37633: PPUSH
37634: EMPTY
37635: PPUSH
37636: CALL_OW 1
37640: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37641: LD_ADDR_EXP 127
37645: PUSH
37646: LD_EXP 127
37650: PPUSH
37651: LD_VAR 0 2
37655: PPUSH
37656: EMPTY
37657: PPUSH
37658: CALL_OW 1
37662: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37663: LD_ADDR_EXP 128
37667: PUSH
37668: LD_EXP 128
37672: PPUSH
37673: LD_VAR 0 2
37677: PPUSH
37678: EMPTY
37679: PPUSH
37680: CALL_OW 1
37684: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37685: LD_ADDR_EXP 129
37689: PUSH
37690: LD_EXP 129
37694: PPUSH
37695: LD_VAR 0 2
37699: PPUSH
37700: EMPTY
37701: PPUSH
37702: CALL_OW 1
37706: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37707: LD_ADDR_EXP 130
37711: PUSH
37712: LD_EXP 130
37716: PPUSH
37717: LD_VAR 0 2
37721: PPUSH
37722: EMPTY
37723: PPUSH
37724: CALL_OW 1
37728: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37729: LD_ADDR_EXP 131
37733: PUSH
37734: LD_EXP 131
37738: PPUSH
37739: LD_VAR 0 2
37743: PPUSH
37744: EMPTY
37745: PPUSH
37746: CALL_OW 1
37750: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37751: LD_ADDR_EXP 132
37755: PUSH
37756: LD_EXP 132
37760: PPUSH
37761: LD_VAR 0 2
37765: PPUSH
37766: EMPTY
37767: PPUSH
37768: CALL_OW 1
37772: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37773: LD_ADDR_EXP 121
37777: PUSH
37778: LD_EXP 121
37782: PPUSH
37783: LD_VAR 0 2
37787: PPUSH
37788: LD_INT 0
37790: PPUSH
37791: CALL_OW 1
37795: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37796: LD_ADDR_EXP 134
37800: PUSH
37801: LD_EXP 134
37805: PPUSH
37806: LD_VAR 0 2
37810: PPUSH
37811: LD_INT 0
37813: PPUSH
37814: CALL_OW 1
37818: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37819: LD_ADDR_EXP 122
37823: PUSH
37824: LD_EXP 122
37828: PPUSH
37829: LD_VAR 0 2
37833: PPUSH
37834: EMPTY
37835: PPUSH
37836: CALL_OW 1
37840: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37841: LD_ADDR_EXP 133
37845: PUSH
37846: LD_EXP 133
37850: PPUSH
37851: LD_VAR 0 2
37855: PPUSH
37856: LD_INT 0
37858: PPUSH
37859: CALL_OW 1
37863: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37864: LD_ADDR_EXP 135
37868: PUSH
37869: LD_EXP 135
37873: PPUSH
37874: LD_VAR 0 2
37878: PPUSH
37879: EMPTY
37880: PPUSH
37881: CALL_OW 1
37885: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37886: LD_ADDR_EXP 138
37890: PUSH
37891: LD_EXP 138
37895: PPUSH
37896: LD_VAR 0 2
37900: PPUSH
37901: LD_INT 0
37903: PPUSH
37904: CALL_OW 1
37908: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37909: LD_ADDR_EXP 139
37913: PUSH
37914: LD_EXP 139
37918: PPUSH
37919: LD_VAR 0 2
37923: PPUSH
37924: EMPTY
37925: PPUSH
37926: CALL_OW 1
37930: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37931: LD_ADDR_EXP 140
37935: PUSH
37936: LD_EXP 140
37940: PPUSH
37941: LD_VAR 0 2
37945: PPUSH
37946: EMPTY
37947: PPUSH
37948: CALL_OW 1
37952: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37953: LD_ADDR_EXP 141
37957: PUSH
37958: LD_EXP 141
37962: PPUSH
37963: LD_VAR 0 2
37967: PPUSH
37968: EMPTY
37969: PPUSH
37970: CALL_OW 1
37974: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37975: LD_ADDR_EXP 143
37979: PUSH
37980: LD_EXP 143
37984: PPUSH
37985: LD_VAR 0 2
37989: PPUSH
37990: LD_EXP 110
37994: PUSH
37995: LD_VAR 0 2
37999: ARRAY
38000: PPUSH
38001: LD_INT 2
38003: PUSH
38004: LD_INT 30
38006: PUSH
38007: LD_INT 6
38009: PUSH
38010: EMPTY
38011: LIST
38012: LIST
38013: PUSH
38014: LD_INT 30
38016: PUSH
38017: LD_INT 7
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 30
38026: PUSH
38027: LD_INT 8
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: PPUSH
38040: CALL_OW 72
38044: PPUSH
38045: CALL_OW 1
38049: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38050: LD_ADDR_EXP 144
38054: PUSH
38055: LD_EXP 144
38059: PPUSH
38060: LD_VAR 0 2
38064: PPUSH
38065: EMPTY
38066: PPUSH
38067: CALL_OW 1
38071: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38072: LD_ADDR_EXP 145
38076: PUSH
38077: LD_EXP 145
38081: PPUSH
38082: LD_VAR 0 2
38086: PPUSH
38087: EMPTY
38088: PPUSH
38089: CALL_OW 1
38093: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38094: LD_ADDR_EXP 146
38098: PUSH
38099: LD_EXP 146
38103: PPUSH
38104: LD_VAR 0 2
38108: PPUSH
38109: EMPTY
38110: PPUSH
38111: CALL_OW 1
38115: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38116: LD_ADDR_EXP 147
38120: PUSH
38121: LD_EXP 147
38125: PPUSH
38126: LD_VAR 0 2
38130: PPUSH
38131: EMPTY
38132: PPUSH
38133: CALL_OW 1
38137: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38138: LD_ADDR_EXP 148
38142: PUSH
38143: LD_EXP 148
38147: PPUSH
38148: LD_VAR 0 2
38152: PPUSH
38153: EMPTY
38154: PPUSH
38155: CALL_OW 1
38159: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38160: LD_ADDR_EXP 149
38164: PUSH
38165: LD_EXP 149
38169: PPUSH
38170: LD_VAR 0 2
38174: PPUSH
38175: EMPTY
38176: PPUSH
38177: CALL_OW 1
38181: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38182: LD_ADDR_EXP 150
38186: PUSH
38187: LD_EXP 150
38191: PPUSH
38192: LD_VAR 0 2
38196: PPUSH
38197: EMPTY
38198: PPUSH
38199: CALL_OW 1
38203: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38204: LD_ADDR_EXP 151
38208: PUSH
38209: LD_EXP 151
38213: PPUSH
38214: LD_VAR 0 2
38218: PPUSH
38219: EMPTY
38220: PPUSH
38221: CALL_OW 1
38225: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38226: LD_ADDR_EXP 152
38230: PUSH
38231: LD_EXP 152
38235: PPUSH
38236: LD_VAR 0 2
38240: PPUSH
38241: LD_INT 0
38243: PPUSH
38244: CALL_OW 1
38248: ST_TO_ADDR
// end ;
38249: GO 37173
38251: POP
38252: POP
// MC_InitSides ( ) ;
38253: CALL 38539 0 0
// MC_InitResearch ( ) ;
38257: CALL 38278 0 0
// CustomInitMacro ( ) ;
38261: CALL 467 0 0
// skirmish := true ;
38265: LD_ADDR_EXP 108
38269: PUSH
38270: LD_INT 1
38272: ST_TO_ADDR
// end ;
38273: LD_VAR 0 1
38277: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38278: LD_INT 0
38280: PPUSH
38281: PPUSH
38282: PPUSH
38283: PPUSH
38284: PPUSH
38285: PPUSH
// if not mc_bases then
38286: LD_EXP 110
38290: NOT
38291: IFFALSE 38295
// exit ;
38293: GO 38534
// for i = 1 to 8 do
38295: LD_ADDR_VAR 0 2
38299: PUSH
38300: DOUBLE
38301: LD_INT 1
38303: DEC
38304: ST_TO_ADDR
38305: LD_INT 8
38307: PUSH
38308: FOR_TO
38309: IFFALSE 38335
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38311: LD_ADDR_EXP 137
38315: PUSH
38316: LD_EXP 137
38320: PPUSH
38321: LD_VAR 0 2
38325: PPUSH
38326: EMPTY
38327: PPUSH
38328: CALL_OW 1
38332: ST_TO_ADDR
38333: GO 38308
38335: POP
38336: POP
// tmp := [ ] ;
38337: LD_ADDR_VAR 0 5
38341: PUSH
38342: EMPTY
38343: ST_TO_ADDR
// for i = 1 to mc_sides do
38344: LD_ADDR_VAR 0 2
38348: PUSH
38349: DOUBLE
38350: LD_INT 1
38352: DEC
38353: ST_TO_ADDR
38354: LD_EXP 136
38358: PUSH
38359: FOR_TO
38360: IFFALSE 38418
// if not mc_sides [ i ] in tmp then
38362: LD_EXP 136
38366: PUSH
38367: LD_VAR 0 2
38371: ARRAY
38372: PUSH
38373: LD_VAR 0 5
38377: IN
38378: NOT
38379: IFFALSE 38416
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38381: LD_ADDR_VAR 0 5
38385: PUSH
38386: LD_VAR 0 5
38390: PPUSH
38391: LD_VAR 0 5
38395: PUSH
38396: LD_INT 1
38398: PLUS
38399: PPUSH
38400: LD_EXP 136
38404: PUSH
38405: LD_VAR 0 2
38409: ARRAY
38410: PPUSH
38411: CALL_OW 2
38415: ST_TO_ADDR
38416: GO 38359
38418: POP
38419: POP
// if not tmp then
38420: LD_VAR 0 5
38424: NOT
38425: IFFALSE 38429
// exit ;
38427: GO 38534
// for j in tmp do
38429: LD_ADDR_VAR 0 3
38433: PUSH
38434: LD_VAR 0 5
38438: PUSH
38439: FOR_IN
38440: IFFALSE 38532
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38442: LD_ADDR_VAR 0 6
38446: PUSH
38447: LD_INT 22
38449: PUSH
38450: LD_VAR 0 3
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PPUSH
38459: CALL_OW 69
38463: ST_TO_ADDR
// if not un then
38464: LD_VAR 0 6
38468: NOT
38469: IFFALSE 38473
// continue ;
38471: GO 38439
// nation := GetNation ( un [ 1 ] ) ;
38473: LD_ADDR_VAR 0 4
38477: PUSH
38478: LD_VAR 0 6
38482: PUSH
38483: LD_INT 1
38485: ARRAY
38486: PPUSH
38487: CALL_OW 248
38491: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38492: LD_ADDR_EXP 137
38496: PUSH
38497: LD_EXP 137
38501: PPUSH
38502: LD_VAR 0 3
38506: PPUSH
38507: LD_VAR 0 3
38511: PPUSH
38512: LD_VAR 0 4
38516: PPUSH
38517: LD_INT 1
38519: PPUSH
38520: CALL 65128 0 3
38524: PPUSH
38525: CALL_OW 1
38529: ST_TO_ADDR
// end ;
38530: GO 38439
38532: POP
38533: POP
// end ;
38534: LD_VAR 0 1
38538: RET
// export function MC_InitSides ( ) ; var i ; begin
38539: LD_INT 0
38541: PPUSH
38542: PPUSH
// if not mc_bases then
38543: LD_EXP 110
38547: NOT
38548: IFFALSE 38552
// exit ;
38550: GO 38626
// for i = 1 to mc_bases do
38552: LD_ADDR_VAR 0 2
38556: PUSH
38557: DOUBLE
38558: LD_INT 1
38560: DEC
38561: ST_TO_ADDR
38562: LD_EXP 110
38566: PUSH
38567: FOR_TO
38568: IFFALSE 38624
// if mc_bases [ i ] then
38570: LD_EXP 110
38574: PUSH
38575: LD_VAR 0 2
38579: ARRAY
38580: IFFALSE 38622
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38582: LD_ADDR_EXP 136
38586: PUSH
38587: LD_EXP 136
38591: PPUSH
38592: LD_VAR 0 2
38596: PPUSH
38597: LD_EXP 110
38601: PUSH
38602: LD_VAR 0 2
38606: ARRAY
38607: PUSH
38608: LD_INT 1
38610: ARRAY
38611: PPUSH
38612: CALL_OW 255
38616: PPUSH
38617: CALL_OW 1
38621: ST_TO_ADDR
38622: GO 38567
38624: POP
38625: POP
// end ;
38626: LD_VAR 0 1
38630: RET
// every 0 0$01 trigger skirmish do
38631: LD_EXP 108
38635: IFFALSE 38789
38637: GO 38639
38639: DISABLE
// begin enable ;
38640: ENABLE
// MC_CheckBuildings ( ) ;
38641: CALL 43287 0 0
// MC_CheckPeopleLife ( ) ;
38645: CALL 43412 0 0
// RaiseSailEvent ( 100 ) ;
38649: LD_INT 100
38651: PPUSH
38652: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38656: LD_INT 103
38658: PPUSH
38659: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38663: LD_INT 104
38665: PPUSH
38666: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38670: LD_INT 105
38672: PPUSH
38673: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38677: LD_INT 106
38679: PPUSH
38680: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38684: LD_INT 107
38686: PPUSH
38687: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38691: LD_INT 108
38693: PPUSH
38694: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38698: LD_INT 109
38700: PPUSH
38701: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38705: LD_INT 110
38707: PPUSH
38708: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38712: LD_INT 111
38714: PPUSH
38715: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38719: LD_INT 112
38721: PPUSH
38722: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38726: LD_INT 113
38728: PPUSH
38729: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38733: LD_INT 120
38735: PPUSH
38736: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38740: LD_INT 121
38742: PPUSH
38743: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38747: LD_INT 122
38749: PPUSH
38750: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38754: LD_INT 123
38756: PPUSH
38757: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38761: LD_INT 124
38763: PPUSH
38764: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38768: LD_INT 125
38770: PPUSH
38771: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38775: LD_INT 126
38777: PPUSH
38778: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38782: LD_INT 200
38784: PPUSH
38785: CALL_OW 427
// end ;
38789: END
// on SailEvent ( event ) do begin if event < 100 then
38790: LD_VAR 0 1
38794: PUSH
38795: LD_INT 100
38797: LESS
38798: IFFALSE 38809
// CustomEvent ( event ) ;
38800: LD_VAR 0 1
38804: PPUSH
38805: CALL 33403 0 1
// if event = 100 then
38809: LD_VAR 0 1
38813: PUSH
38814: LD_INT 100
38816: EQUAL
38817: IFFALSE 38823
// MC_ClassManager ( ) ;
38819: CALL 39215 0 0
// if event = 101 then
38823: LD_VAR 0 1
38827: PUSH
38828: LD_INT 101
38830: EQUAL
38831: IFFALSE 38837
// MC_RepairBuildings ( ) ;
38833: CALL 43997 0 0
// if event = 102 then
38837: LD_VAR 0 1
38841: PUSH
38842: LD_INT 102
38844: EQUAL
38845: IFFALSE 38851
// MC_Heal ( ) ;
38847: CALL 44856 0 0
// if event = 103 then
38851: LD_VAR 0 1
38855: PUSH
38856: LD_INT 103
38858: EQUAL
38859: IFFALSE 38865
// MC_Build ( ) ;
38861: CALL 45278 0 0
// if event = 104 then
38865: LD_VAR 0 1
38869: PUSH
38870: LD_INT 104
38872: EQUAL
38873: IFFALSE 38879
// MC_TurretWeapon ( ) ;
38875: CALL 46891 0 0
// if event = 105 then
38879: LD_VAR 0 1
38883: PUSH
38884: LD_INT 105
38886: EQUAL
38887: IFFALSE 38893
// MC_BuildUpgrade ( ) ;
38889: CALL 46442 0 0
// if event = 106 then
38893: LD_VAR 0 1
38897: PUSH
38898: LD_INT 106
38900: EQUAL
38901: IFFALSE 38907
// MC_PlantMines ( ) ;
38903: CALL 47321 0 0
// if event = 107 then
38907: LD_VAR 0 1
38911: PUSH
38912: LD_INT 107
38914: EQUAL
38915: IFFALSE 38921
// MC_CollectCrates ( ) ;
38917: CALL 48119 0 0
// if event = 108 then
38921: LD_VAR 0 1
38925: PUSH
38926: LD_INT 108
38928: EQUAL
38929: IFFALSE 38935
// MC_LinkRemoteControl ( ) ;
38931: CALL 49895 0 0
// if event = 109 then
38935: LD_VAR 0 1
38939: PUSH
38940: LD_INT 109
38942: EQUAL
38943: IFFALSE 38949
// MC_ProduceVehicle ( ) ;
38945: CALL 50076 0 0
// if event = 110 then
38949: LD_VAR 0 1
38953: PUSH
38954: LD_INT 110
38956: EQUAL
38957: IFFALSE 38963
// MC_SendAttack ( ) ;
38959: CALL 50542 0 0
// if event = 111 then
38963: LD_VAR 0 1
38967: PUSH
38968: LD_INT 111
38970: EQUAL
38971: IFFALSE 38977
// MC_Defend ( ) ;
38973: CALL 50650 0 0
// if event = 112 then
38977: LD_VAR 0 1
38981: PUSH
38982: LD_INT 112
38984: EQUAL
38985: IFFALSE 38991
// MC_Research ( ) ;
38987: CALL 51255 0 0
// if event = 113 then
38991: LD_VAR 0 1
38995: PUSH
38996: LD_INT 113
38998: EQUAL
38999: IFFALSE 39005
// MC_MinesTrigger ( ) ;
39001: CALL 52369 0 0
// if event = 120 then
39005: LD_VAR 0 1
39009: PUSH
39010: LD_INT 120
39012: EQUAL
39013: IFFALSE 39019
// MC_RepairVehicle ( ) ;
39015: CALL 52468 0 0
// if event = 121 then
39019: LD_VAR 0 1
39023: PUSH
39024: LD_INT 121
39026: EQUAL
39027: IFFALSE 39033
// MC_TameApe ( ) ;
39029: CALL 53198 0 0
// if event = 122 then
39033: LD_VAR 0 1
39037: PUSH
39038: LD_INT 122
39040: EQUAL
39041: IFFALSE 39047
// MC_ChangeApeClass ( ) ;
39043: CALL 54027 0 0
// if event = 123 then
39047: LD_VAR 0 1
39051: PUSH
39052: LD_INT 123
39054: EQUAL
39055: IFFALSE 39061
// MC_Bazooka ( ) ;
39057: CALL 54677 0 0
// if event = 124 then
39061: LD_VAR 0 1
39065: PUSH
39066: LD_INT 124
39068: EQUAL
39069: IFFALSE 39075
// MC_TeleportExit ( ) ;
39071: CALL 54875 0 0
// if event = 125 then
39075: LD_VAR 0 1
39079: PUSH
39080: LD_INT 125
39082: EQUAL
39083: IFFALSE 39089
// MC_Deposits ( ) ;
39085: CALL 55522 0 0
// if event = 126 then
39089: LD_VAR 0 1
39093: PUSH
39094: LD_INT 126
39096: EQUAL
39097: IFFALSE 39103
// MC_RemoteDriver ( ) ;
39099: CALL 56147 0 0
// if event = 200 then
39103: LD_VAR 0 1
39107: PUSH
39108: LD_INT 200
39110: EQUAL
39111: IFFALSE 39117
// MC_Idle ( ) ;
39113: CALL 58096 0 0
// end ;
39117: PPOPN 1
39119: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39120: LD_INT 0
39122: PPUSH
39123: PPUSH
// if not mc_bases [ base ] or not tag then
39124: LD_EXP 110
39128: PUSH
39129: LD_VAR 0 1
39133: ARRAY
39134: NOT
39135: PUSH
39136: LD_VAR 0 2
39140: NOT
39141: OR
39142: IFFALSE 39146
// exit ;
39144: GO 39210
// for i in mc_bases [ base ] union mc_ape [ base ] do
39146: LD_ADDR_VAR 0 4
39150: PUSH
39151: LD_EXP 110
39155: PUSH
39156: LD_VAR 0 1
39160: ARRAY
39161: PUSH
39162: LD_EXP 139
39166: PUSH
39167: LD_VAR 0 1
39171: ARRAY
39172: UNION
39173: PUSH
39174: FOR_IN
39175: IFFALSE 39208
// if GetTag ( i ) = tag then
39177: LD_VAR 0 4
39181: PPUSH
39182: CALL_OW 110
39186: PUSH
39187: LD_VAR 0 2
39191: EQUAL
39192: IFFALSE 39206
// SetTag ( i , 0 ) ;
39194: LD_VAR 0 4
39198: PPUSH
39199: LD_INT 0
39201: PPUSH
39202: CALL_OW 109
39206: GO 39174
39208: POP
39209: POP
// end ;
39210: LD_VAR 0 3
39214: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39215: LD_INT 0
39217: PPUSH
39218: PPUSH
39219: PPUSH
39220: PPUSH
39221: PPUSH
39222: PPUSH
39223: PPUSH
39224: PPUSH
// if not mc_bases then
39225: LD_EXP 110
39229: NOT
39230: IFFALSE 39234
// exit ;
39232: GO 39692
// for i = 1 to mc_bases do
39234: LD_ADDR_VAR 0 2
39238: PUSH
39239: DOUBLE
39240: LD_INT 1
39242: DEC
39243: ST_TO_ADDR
39244: LD_EXP 110
39248: PUSH
39249: FOR_TO
39250: IFFALSE 39690
// begin tmp := MC_ClassCheckReq ( i ) ;
39252: LD_ADDR_VAR 0 4
39256: PUSH
39257: LD_VAR 0 2
39261: PPUSH
39262: CALL 39697 0 1
39266: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39267: LD_ADDR_EXP 151
39271: PUSH
39272: LD_EXP 151
39276: PPUSH
39277: LD_VAR 0 2
39281: PPUSH
39282: LD_VAR 0 4
39286: PPUSH
39287: CALL_OW 1
39291: ST_TO_ADDR
// if not tmp then
39292: LD_VAR 0 4
39296: NOT
39297: IFFALSE 39301
// continue ;
39299: GO 39249
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39301: LD_ADDR_VAR 0 6
39305: PUSH
39306: LD_EXP 110
39310: PUSH
39311: LD_VAR 0 2
39315: ARRAY
39316: PPUSH
39317: LD_INT 2
39319: PUSH
39320: LD_INT 30
39322: PUSH
39323: LD_INT 4
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: PUSH
39330: LD_INT 30
39332: PUSH
39333: LD_INT 5
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: LIST
39344: PPUSH
39345: CALL_OW 72
39349: PUSH
39350: LD_EXP 110
39354: PUSH
39355: LD_VAR 0 2
39359: ARRAY
39360: PPUSH
39361: LD_INT 2
39363: PUSH
39364: LD_INT 30
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 30
39376: PUSH
39377: LD_INT 1
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: LIST
39388: PPUSH
39389: CALL_OW 72
39393: PUSH
39394: LD_EXP 110
39398: PUSH
39399: LD_VAR 0 2
39403: ARRAY
39404: PPUSH
39405: LD_INT 30
39407: PUSH
39408: LD_INT 3
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PPUSH
39415: CALL_OW 72
39419: PUSH
39420: LD_EXP 110
39424: PUSH
39425: LD_VAR 0 2
39429: ARRAY
39430: PPUSH
39431: LD_INT 2
39433: PUSH
39434: LD_INT 30
39436: PUSH
39437: LD_INT 6
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 30
39446: PUSH
39447: LD_INT 7
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 30
39456: PUSH
39457: LD_INT 8
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: PPUSH
39470: CALL_OW 72
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: LIST
39479: LIST
39480: ST_TO_ADDR
// for j = 1 to 4 do
39481: LD_ADDR_VAR 0 3
39485: PUSH
39486: DOUBLE
39487: LD_INT 1
39489: DEC
39490: ST_TO_ADDR
39491: LD_INT 4
39493: PUSH
39494: FOR_TO
39495: IFFALSE 39686
// begin if not tmp [ j ] then
39497: LD_VAR 0 4
39501: PUSH
39502: LD_VAR 0 3
39506: ARRAY
39507: NOT
39508: IFFALSE 39512
// continue ;
39510: GO 39494
// for p in tmp [ j ] do
39512: LD_ADDR_VAR 0 5
39516: PUSH
39517: LD_VAR 0 4
39521: PUSH
39522: LD_VAR 0 3
39526: ARRAY
39527: PUSH
39528: FOR_IN
39529: IFFALSE 39682
// begin if not b [ j ] then
39531: LD_VAR 0 6
39535: PUSH
39536: LD_VAR 0 3
39540: ARRAY
39541: NOT
39542: IFFALSE 39546
// break ;
39544: GO 39682
// e := 0 ;
39546: LD_ADDR_VAR 0 7
39550: PUSH
39551: LD_INT 0
39553: ST_TO_ADDR
// for k in b [ j ] do
39554: LD_ADDR_VAR 0 8
39558: PUSH
39559: LD_VAR 0 6
39563: PUSH
39564: LD_VAR 0 3
39568: ARRAY
39569: PUSH
39570: FOR_IN
39571: IFFALSE 39598
// if IsNotFull ( k ) then
39573: LD_VAR 0 8
39577: PPUSH
39578: CALL 67277 0 1
39582: IFFALSE 39596
// begin e := k ;
39584: LD_ADDR_VAR 0 7
39588: PUSH
39589: LD_VAR 0 8
39593: ST_TO_ADDR
// break ;
39594: GO 39598
// end ;
39596: GO 39570
39598: POP
39599: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39600: LD_VAR 0 7
39604: PUSH
39605: LD_VAR 0 5
39609: PPUSH
39610: LD_VAR 0 7
39614: PPUSH
39615: CALL 99697 0 2
39619: NOT
39620: AND
39621: IFFALSE 39680
// begin if IsInUnit ( p ) then
39623: LD_VAR 0 5
39627: PPUSH
39628: CALL_OW 310
39632: IFFALSE 39643
// ComExitBuilding ( p ) ;
39634: LD_VAR 0 5
39638: PPUSH
39639: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39643: LD_VAR 0 5
39647: PPUSH
39648: LD_VAR 0 7
39652: PPUSH
39653: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39657: LD_VAR 0 5
39661: PPUSH
39662: LD_VAR 0 3
39666: PPUSH
39667: CALL_OW 183
// AddComExitBuilding ( p ) ;
39671: LD_VAR 0 5
39675: PPUSH
39676: CALL_OW 182
// end ; end ;
39680: GO 39528
39682: POP
39683: POP
// end ;
39684: GO 39494
39686: POP
39687: POP
// end ;
39688: GO 39249
39690: POP
39691: POP
// end ;
39692: LD_VAR 0 1
39696: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39697: LD_INT 0
39699: PPUSH
39700: PPUSH
39701: PPUSH
39702: PPUSH
39703: PPUSH
39704: PPUSH
39705: PPUSH
39706: PPUSH
39707: PPUSH
39708: PPUSH
39709: PPUSH
39710: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39711: LD_VAR 0 1
39715: NOT
39716: PUSH
39717: LD_EXP 110
39721: PUSH
39722: LD_VAR 0 1
39726: ARRAY
39727: NOT
39728: OR
39729: PUSH
39730: LD_EXP 110
39734: PUSH
39735: LD_VAR 0 1
39739: ARRAY
39740: PPUSH
39741: LD_INT 2
39743: PUSH
39744: LD_INT 30
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 30
39756: PUSH
39757: LD_INT 1
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: LIST
39768: PPUSH
39769: CALL_OW 72
39773: NOT
39774: OR
39775: IFFALSE 39779
// exit ;
39777: GO 43282
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39779: LD_ADDR_VAR 0 4
39783: PUSH
39784: LD_EXP 110
39788: PUSH
39789: LD_VAR 0 1
39793: ARRAY
39794: PPUSH
39795: LD_INT 2
39797: PUSH
39798: LD_INT 25
39800: PUSH
39801: LD_INT 1
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 25
39810: PUSH
39811: LD_INT 2
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 25
39820: PUSH
39821: LD_INT 3
39823: PUSH
39824: EMPTY
39825: LIST
39826: LIST
39827: PUSH
39828: LD_INT 25
39830: PUSH
39831: LD_INT 4
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PUSH
39838: LD_INT 25
39840: PUSH
39841: LD_INT 5
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 25
39850: PUSH
39851: LD_INT 8
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: LD_INT 25
39860: PUSH
39861: LD_INT 9
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: PPUSH
39878: CALL_OW 72
39882: ST_TO_ADDR
// if not tmp then
39883: LD_VAR 0 4
39887: NOT
39888: IFFALSE 39892
// exit ;
39890: GO 43282
// for i in tmp do
39892: LD_ADDR_VAR 0 3
39896: PUSH
39897: LD_VAR 0 4
39901: PUSH
39902: FOR_IN
39903: IFFALSE 39934
// if GetTag ( i ) then
39905: LD_VAR 0 3
39909: PPUSH
39910: CALL_OW 110
39914: IFFALSE 39932
// tmp := tmp diff i ;
39916: LD_ADDR_VAR 0 4
39920: PUSH
39921: LD_VAR 0 4
39925: PUSH
39926: LD_VAR 0 3
39930: DIFF
39931: ST_TO_ADDR
39932: GO 39902
39934: POP
39935: POP
// if not tmp then
39936: LD_VAR 0 4
39940: NOT
39941: IFFALSE 39945
// exit ;
39943: GO 43282
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39945: LD_ADDR_VAR 0 5
39949: PUSH
39950: LD_EXP 110
39954: PUSH
39955: LD_VAR 0 1
39959: ARRAY
39960: PPUSH
39961: LD_INT 2
39963: PUSH
39964: LD_INT 25
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 25
39976: PUSH
39977: LD_INT 5
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 25
39986: PUSH
39987: LD_INT 8
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 25
39996: PUSH
39997: LD_INT 9
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: PPUSH
40011: CALL_OW 72
40015: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40016: LD_ADDR_VAR 0 6
40020: PUSH
40021: LD_EXP 110
40025: PUSH
40026: LD_VAR 0 1
40030: ARRAY
40031: PPUSH
40032: LD_INT 25
40034: PUSH
40035: LD_INT 2
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PPUSH
40042: CALL_OW 72
40046: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40047: LD_ADDR_VAR 0 7
40051: PUSH
40052: LD_EXP 110
40056: PUSH
40057: LD_VAR 0 1
40061: ARRAY
40062: PPUSH
40063: LD_INT 25
40065: PUSH
40066: LD_INT 3
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PPUSH
40073: CALL_OW 72
40077: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40078: LD_ADDR_VAR 0 8
40082: PUSH
40083: LD_EXP 110
40087: PUSH
40088: LD_VAR 0 1
40092: ARRAY
40093: PPUSH
40094: LD_INT 25
40096: PUSH
40097: LD_INT 4
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 24
40106: PUSH
40107: LD_INT 251
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PPUSH
40118: CALL_OW 72
40122: ST_TO_ADDR
// if mc_scan [ base ] then
40123: LD_EXP 133
40127: PUSH
40128: LD_VAR 0 1
40132: ARRAY
40133: IFFALSE 40594
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40135: LD_ADDR_EXP 152
40139: PUSH
40140: LD_EXP 152
40144: PPUSH
40145: LD_VAR 0 1
40149: PPUSH
40150: LD_INT 4
40152: PPUSH
40153: CALL_OW 1
40157: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40158: LD_ADDR_VAR 0 12
40162: PUSH
40163: LD_EXP 110
40167: PUSH
40168: LD_VAR 0 1
40172: ARRAY
40173: PPUSH
40174: LD_INT 2
40176: PUSH
40177: LD_INT 30
40179: PUSH
40180: LD_INT 4
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 30
40189: PUSH
40190: LD_INT 5
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: LIST
40201: PPUSH
40202: CALL_OW 72
40206: ST_TO_ADDR
// if not b then
40207: LD_VAR 0 12
40211: NOT
40212: IFFALSE 40216
// exit ;
40214: GO 43282
// p := [ ] ;
40216: LD_ADDR_VAR 0 11
40220: PUSH
40221: EMPTY
40222: ST_TO_ADDR
// if sci >= 2 then
40223: LD_VAR 0 8
40227: PUSH
40228: LD_INT 2
40230: GREATEREQUAL
40231: IFFALSE 40262
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40233: LD_ADDR_VAR 0 8
40237: PUSH
40238: LD_VAR 0 8
40242: PUSH
40243: LD_INT 1
40245: ARRAY
40246: PUSH
40247: LD_VAR 0 8
40251: PUSH
40252: LD_INT 2
40254: ARRAY
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: ST_TO_ADDR
40260: GO 40323
// if sci = 1 then
40262: LD_VAR 0 8
40266: PUSH
40267: LD_INT 1
40269: EQUAL
40270: IFFALSE 40291
// sci := [ sci [ 1 ] ] else
40272: LD_ADDR_VAR 0 8
40276: PUSH
40277: LD_VAR 0 8
40281: PUSH
40282: LD_INT 1
40284: ARRAY
40285: PUSH
40286: EMPTY
40287: LIST
40288: ST_TO_ADDR
40289: GO 40323
// if sci = 0 then
40291: LD_VAR 0 8
40295: PUSH
40296: LD_INT 0
40298: EQUAL
40299: IFFALSE 40323
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40301: LD_ADDR_VAR 0 11
40305: PUSH
40306: LD_VAR 0 4
40310: PPUSH
40311: LD_INT 4
40313: PPUSH
40314: CALL 99560 0 2
40318: PUSH
40319: LD_INT 1
40321: ARRAY
40322: ST_TO_ADDR
// if eng > 4 then
40323: LD_VAR 0 6
40327: PUSH
40328: LD_INT 4
40330: GREATER
40331: IFFALSE 40377
// for i = eng downto 4 do
40333: LD_ADDR_VAR 0 3
40337: PUSH
40338: DOUBLE
40339: LD_VAR 0 6
40343: INC
40344: ST_TO_ADDR
40345: LD_INT 4
40347: PUSH
40348: FOR_DOWNTO
40349: IFFALSE 40375
// eng := eng diff eng [ i ] ;
40351: LD_ADDR_VAR 0 6
40355: PUSH
40356: LD_VAR 0 6
40360: PUSH
40361: LD_VAR 0 6
40365: PUSH
40366: LD_VAR 0 3
40370: ARRAY
40371: DIFF
40372: ST_TO_ADDR
40373: GO 40348
40375: POP
40376: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40377: LD_ADDR_VAR 0 4
40381: PUSH
40382: LD_VAR 0 4
40386: PUSH
40387: LD_VAR 0 5
40391: PUSH
40392: LD_VAR 0 6
40396: UNION
40397: PUSH
40398: LD_VAR 0 7
40402: UNION
40403: PUSH
40404: LD_VAR 0 8
40408: UNION
40409: DIFF
40410: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40411: LD_ADDR_VAR 0 13
40415: PUSH
40416: LD_EXP 110
40420: PUSH
40421: LD_VAR 0 1
40425: ARRAY
40426: PPUSH
40427: LD_INT 2
40429: PUSH
40430: LD_INT 30
40432: PUSH
40433: LD_INT 32
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 30
40442: PUSH
40443: LD_INT 31
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: LIST
40454: PPUSH
40455: CALL_OW 72
40459: PUSH
40460: LD_EXP 110
40464: PUSH
40465: LD_VAR 0 1
40469: ARRAY
40470: PPUSH
40471: LD_INT 2
40473: PUSH
40474: LD_INT 30
40476: PUSH
40477: LD_INT 4
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 30
40486: PUSH
40487: LD_INT 5
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: LIST
40498: PPUSH
40499: CALL_OW 72
40503: PUSH
40504: LD_INT 6
40506: MUL
40507: PLUS
40508: ST_TO_ADDR
// if bcount < tmp then
40509: LD_VAR 0 13
40513: PUSH
40514: LD_VAR 0 4
40518: LESS
40519: IFFALSE 40565
// for i = tmp downto bcount do
40521: LD_ADDR_VAR 0 3
40525: PUSH
40526: DOUBLE
40527: LD_VAR 0 4
40531: INC
40532: ST_TO_ADDR
40533: LD_VAR 0 13
40537: PUSH
40538: FOR_DOWNTO
40539: IFFALSE 40563
// tmp := Delete ( tmp , tmp ) ;
40541: LD_ADDR_VAR 0 4
40545: PUSH
40546: LD_VAR 0 4
40550: PPUSH
40551: LD_VAR 0 4
40555: PPUSH
40556: CALL_OW 3
40560: ST_TO_ADDR
40561: GO 40538
40563: POP
40564: POP
// result := [ tmp , 0 , 0 , p ] ;
40565: LD_ADDR_VAR 0 2
40569: PUSH
40570: LD_VAR 0 4
40574: PUSH
40575: LD_INT 0
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: LD_VAR 0 11
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: ST_TO_ADDR
// exit ;
40592: GO 43282
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40594: LD_EXP 110
40598: PUSH
40599: LD_VAR 0 1
40603: ARRAY
40604: PPUSH
40605: LD_INT 2
40607: PUSH
40608: LD_INT 30
40610: PUSH
40611: LD_INT 6
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: LD_INT 30
40620: PUSH
40621: LD_INT 7
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 30
40630: PUSH
40631: LD_INT 8
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: EMPTY
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: PPUSH
40644: CALL_OW 72
40648: NOT
40649: PUSH
40650: LD_EXP 110
40654: PUSH
40655: LD_VAR 0 1
40659: ARRAY
40660: PPUSH
40661: LD_INT 30
40663: PUSH
40664: LD_INT 3
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PPUSH
40671: CALL_OW 72
40675: NOT
40676: AND
40677: IFFALSE 40749
// begin if eng = tmp then
40679: LD_VAR 0 6
40683: PUSH
40684: LD_VAR 0 4
40688: EQUAL
40689: IFFALSE 40693
// exit ;
40691: GO 43282
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40693: LD_ADDR_EXP 152
40697: PUSH
40698: LD_EXP 152
40702: PPUSH
40703: LD_VAR 0 1
40707: PPUSH
40708: LD_INT 1
40710: PPUSH
40711: CALL_OW 1
40715: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40716: LD_ADDR_VAR 0 2
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: LD_VAR 0 4
40728: PUSH
40729: LD_VAR 0 6
40733: DIFF
40734: PUSH
40735: LD_INT 0
40737: PUSH
40738: LD_INT 0
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: ST_TO_ADDR
// exit ;
40747: GO 43282
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40749: LD_EXP 137
40753: PUSH
40754: LD_EXP 136
40758: PUSH
40759: LD_VAR 0 1
40763: ARRAY
40764: ARRAY
40765: PUSH
40766: LD_EXP 110
40770: PUSH
40771: LD_VAR 0 1
40775: ARRAY
40776: PPUSH
40777: LD_INT 2
40779: PUSH
40780: LD_INT 30
40782: PUSH
40783: LD_INT 6
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 30
40792: PUSH
40793: LD_INT 7
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 30
40802: PUSH
40803: LD_INT 8
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: LIST
40814: LIST
40815: PPUSH
40816: CALL_OW 72
40820: AND
40821: PUSH
40822: LD_EXP 110
40826: PUSH
40827: LD_VAR 0 1
40831: ARRAY
40832: PPUSH
40833: LD_INT 30
40835: PUSH
40836: LD_INT 3
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PPUSH
40843: CALL_OW 72
40847: NOT
40848: AND
40849: IFFALSE 41063
// begin if sci >= 6 then
40851: LD_VAR 0 8
40855: PUSH
40856: LD_INT 6
40858: GREATEREQUAL
40859: IFFALSE 40863
// exit ;
40861: GO 43282
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40863: LD_ADDR_EXP 152
40867: PUSH
40868: LD_EXP 152
40872: PPUSH
40873: LD_VAR 0 1
40877: PPUSH
40878: LD_INT 2
40880: PPUSH
40881: CALL_OW 1
40885: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40886: LD_ADDR_VAR 0 9
40890: PUSH
40891: LD_VAR 0 4
40895: PUSH
40896: LD_VAR 0 8
40900: DIFF
40901: PPUSH
40902: LD_INT 4
40904: PPUSH
40905: CALL 99560 0 2
40909: ST_TO_ADDR
// p := [ ] ;
40910: LD_ADDR_VAR 0 11
40914: PUSH
40915: EMPTY
40916: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40917: LD_VAR 0 8
40921: PUSH
40922: LD_INT 6
40924: LESS
40925: PUSH
40926: LD_VAR 0 9
40930: PUSH
40931: LD_INT 6
40933: GREATER
40934: AND
40935: IFFALSE 41016
// begin for i = 1 to 6 - sci do
40937: LD_ADDR_VAR 0 3
40941: PUSH
40942: DOUBLE
40943: LD_INT 1
40945: DEC
40946: ST_TO_ADDR
40947: LD_INT 6
40949: PUSH
40950: LD_VAR 0 8
40954: MINUS
40955: PUSH
40956: FOR_TO
40957: IFFALSE 41012
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40959: LD_ADDR_VAR 0 11
40963: PUSH
40964: LD_VAR 0 11
40968: PPUSH
40969: LD_VAR 0 11
40973: PUSH
40974: LD_INT 1
40976: PLUS
40977: PPUSH
40978: LD_VAR 0 9
40982: PUSH
40983: LD_INT 1
40985: ARRAY
40986: PPUSH
40987: CALL_OW 2
40991: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40992: LD_ADDR_VAR 0 9
40996: PUSH
40997: LD_VAR 0 9
41001: PPUSH
41002: LD_INT 1
41004: PPUSH
41005: CALL_OW 3
41009: ST_TO_ADDR
// end ;
41010: GO 40956
41012: POP
41013: POP
// end else
41014: GO 41036
// if sort then
41016: LD_VAR 0 9
41020: IFFALSE 41036
// p := sort [ 1 ] ;
41022: LD_ADDR_VAR 0 11
41026: PUSH
41027: LD_VAR 0 9
41031: PUSH
41032: LD_INT 1
41034: ARRAY
41035: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41036: LD_ADDR_VAR 0 2
41040: PUSH
41041: LD_INT 0
41043: PUSH
41044: LD_INT 0
41046: PUSH
41047: LD_INT 0
41049: PUSH
41050: LD_VAR 0 11
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: ST_TO_ADDR
// exit ;
41061: GO 43282
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41063: LD_EXP 137
41067: PUSH
41068: LD_EXP 136
41072: PUSH
41073: LD_VAR 0 1
41077: ARRAY
41078: ARRAY
41079: PUSH
41080: LD_EXP 110
41084: PUSH
41085: LD_VAR 0 1
41089: ARRAY
41090: PPUSH
41091: LD_INT 2
41093: PUSH
41094: LD_INT 30
41096: PUSH
41097: LD_INT 6
41099: PUSH
41100: EMPTY
41101: LIST
41102: LIST
41103: PUSH
41104: LD_INT 30
41106: PUSH
41107: LD_INT 7
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: LD_INT 30
41116: PUSH
41117: LD_INT 8
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: LIST
41128: LIST
41129: PPUSH
41130: CALL_OW 72
41134: AND
41135: PUSH
41136: LD_EXP 110
41140: PUSH
41141: LD_VAR 0 1
41145: ARRAY
41146: PPUSH
41147: LD_INT 30
41149: PUSH
41150: LD_INT 3
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PPUSH
41157: CALL_OW 72
41161: AND
41162: IFFALSE 41896
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41164: LD_ADDR_EXP 152
41168: PUSH
41169: LD_EXP 152
41173: PPUSH
41174: LD_VAR 0 1
41178: PPUSH
41179: LD_INT 3
41181: PPUSH
41182: CALL_OW 1
41186: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41187: LD_ADDR_VAR 0 2
41191: PUSH
41192: LD_INT 0
41194: PUSH
41195: LD_INT 0
41197: PUSH
41198: LD_INT 0
41200: PUSH
41201: LD_INT 0
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: ST_TO_ADDR
// if not eng then
41210: LD_VAR 0 6
41214: NOT
41215: IFFALSE 41278
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41217: LD_ADDR_VAR 0 11
41221: PUSH
41222: LD_VAR 0 4
41226: PPUSH
41227: LD_INT 2
41229: PPUSH
41230: CALL 99560 0 2
41234: PUSH
41235: LD_INT 1
41237: ARRAY
41238: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41239: LD_ADDR_VAR 0 2
41243: PUSH
41244: LD_VAR 0 2
41248: PPUSH
41249: LD_INT 2
41251: PPUSH
41252: LD_VAR 0 11
41256: PPUSH
41257: CALL_OW 1
41261: ST_TO_ADDR
// tmp := tmp diff p ;
41262: LD_ADDR_VAR 0 4
41266: PUSH
41267: LD_VAR 0 4
41271: PUSH
41272: LD_VAR 0 11
41276: DIFF
41277: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41278: LD_VAR 0 4
41282: PUSH
41283: LD_VAR 0 8
41287: PUSH
41288: LD_INT 6
41290: LESS
41291: AND
41292: IFFALSE 41480
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41294: LD_ADDR_VAR 0 9
41298: PUSH
41299: LD_VAR 0 4
41303: PUSH
41304: LD_VAR 0 8
41308: PUSH
41309: LD_VAR 0 7
41313: UNION
41314: DIFF
41315: PPUSH
41316: LD_INT 4
41318: PPUSH
41319: CALL 99560 0 2
41323: ST_TO_ADDR
// p := [ ] ;
41324: LD_ADDR_VAR 0 11
41328: PUSH
41329: EMPTY
41330: ST_TO_ADDR
// if sort then
41331: LD_VAR 0 9
41335: IFFALSE 41451
// for i = 1 to 6 - sci do
41337: LD_ADDR_VAR 0 3
41341: PUSH
41342: DOUBLE
41343: LD_INT 1
41345: DEC
41346: ST_TO_ADDR
41347: LD_INT 6
41349: PUSH
41350: LD_VAR 0 8
41354: MINUS
41355: PUSH
41356: FOR_TO
41357: IFFALSE 41449
// begin if i = sort then
41359: LD_VAR 0 3
41363: PUSH
41364: LD_VAR 0 9
41368: EQUAL
41369: IFFALSE 41373
// break ;
41371: GO 41449
// if GetClass ( i ) = 4 then
41373: LD_VAR 0 3
41377: PPUSH
41378: CALL_OW 257
41382: PUSH
41383: LD_INT 4
41385: EQUAL
41386: IFFALSE 41390
// continue ;
41388: GO 41356
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41390: LD_ADDR_VAR 0 11
41394: PUSH
41395: LD_VAR 0 11
41399: PPUSH
41400: LD_VAR 0 11
41404: PUSH
41405: LD_INT 1
41407: PLUS
41408: PPUSH
41409: LD_VAR 0 9
41413: PUSH
41414: LD_VAR 0 3
41418: ARRAY
41419: PPUSH
41420: CALL_OW 2
41424: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41425: LD_ADDR_VAR 0 4
41429: PUSH
41430: LD_VAR 0 4
41434: PUSH
41435: LD_VAR 0 9
41439: PUSH
41440: LD_VAR 0 3
41444: ARRAY
41445: DIFF
41446: ST_TO_ADDR
// end ;
41447: GO 41356
41449: POP
41450: POP
// if p then
41451: LD_VAR 0 11
41455: IFFALSE 41480
// result := Replace ( result , 4 , p ) ;
41457: LD_ADDR_VAR 0 2
41461: PUSH
41462: LD_VAR 0 2
41466: PPUSH
41467: LD_INT 4
41469: PPUSH
41470: LD_VAR 0 11
41474: PPUSH
41475: CALL_OW 1
41479: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41480: LD_VAR 0 4
41484: PUSH
41485: LD_VAR 0 7
41489: PUSH
41490: LD_INT 6
41492: LESS
41493: AND
41494: IFFALSE 41682
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41496: LD_ADDR_VAR 0 9
41500: PUSH
41501: LD_VAR 0 4
41505: PUSH
41506: LD_VAR 0 8
41510: PUSH
41511: LD_VAR 0 7
41515: UNION
41516: DIFF
41517: PPUSH
41518: LD_INT 3
41520: PPUSH
41521: CALL 99560 0 2
41525: ST_TO_ADDR
// p := [ ] ;
41526: LD_ADDR_VAR 0 11
41530: PUSH
41531: EMPTY
41532: ST_TO_ADDR
// if sort then
41533: LD_VAR 0 9
41537: IFFALSE 41653
// for i = 1 to 6 - mech do
41539: LD_ADDR_VAR 0 3
41543: PUSH
41544: DOUBLE
41545: LD_INT 1
41547: DEC
41548: ST_TO_ADDR
41549: LD_INT 6
41551: PUSH
41552: LD_VAR 0 7
41556: MINUS
41557: PUSH
41558: FOR_TO
41559: IFFALSE 41651
// begin if i = sort then
41561: LD_VAR 0 3
41565: PUSH
41566: LD_VAR 0 9
41570: EQUAL
41571: IFFALSE 41575
// break ;
41573: GO 41651
// if GetClass ( i ) = 3 then
41575: LD_VAR 0 3
41579: PPUSH
41580: CALL_OW 257
41584: PUSH
41585: LD_INT 3
41587: EQUAL
41588: IFFALSE 41592
// continue ;
41590: GO 41558
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41592: LD_ADDR_VAR 0 11
41596: PUSH
41597: LD_VAR 0 11
41601: PPUSH
41602: LD_VAR 0 11
41606: PUSH
41607: LD_INT 1
41609: PLUS
41610: PPUSH
41611: LD_VAR 0 9
41615: PUSH
41616: LD_VAR 0 3
41620: ARRAY
41621: PPUSH
41622: CALL_OW 2
41626: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41627: LD_ADDR_VAR 0 4
41631: PUSH
41632: LD_VAR 0 4
41636: PUSH
41637: LD_VAR 0 9
41641: PUSH
41642: LD_VAR 0 3
41646: ARRAY
41647: DIFF
41648: ST_TO_ADDR
// end ;
41649: GO 41558
41651: POP
41652: POP
// if p then
41653: LD_VAR 0 11
41657: IFFALSE 41682
// result := Replace ( result , 3 , p ) ;
41659: LD_ADDR_VAR 0 2
41663: PUSH
41664: LD_VAR 0 2
41668: PPUSH
41669: LD_INT 3
41671: PPUSH
41672: LD_VAR 0 11
41676: PPUSH
41677: CALL_OW 1
41681: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41682: LD_VAR 0 4
41686: PUSH
41687: LD_INT 6
41689: GREATER
41690: PUSH
41691: LD_VAR 0 6
41695: PUSH
41696: LD_INT 6
41698: LESS
41699: AND
41700: IFFALSE 41894
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41702: LD_ADDR_VAR 0 9
41706: PUSH
41707: LD_VAR 0 4
41711: PUSH
41712: LD_VAR 0 8
41716: PUSH
41717: LD_VAR 0 7
41721: UNION
41722: PUSH
41723: LD_VAR 0 6
41727: UNION
41728: DIFF
41729: PPUSH
41730: LD_INT 2
41732: PPUSH
41733: CALL 99560 0 2
41737: ST_TO_ADDR
// p := [ ] ;
41738: LD_ADDR_VAR 0 11
41742: PUSH
41743: EMPTY
41744: ST_TO_ADDR
// if sort then
41745: LD_VAR 0 9
41749: IFFALSE 41865
// for i = 1 to 6 - eng do
41751: LD_ADDR_VAR 0 3
41755: PUSH
41756: DOUBLE
41757: LD_INT 1
41759: DEC
41760: ST_TO_ADDR
41761: LD_INT 6
41763: PUSH
41764: LD_VAR 0 6
41768: MINUS
41769: PUSH
41770: FOR_TO
41771: IFFALSE 41863
// begin if i = sort then
41773: LD_VAR 0 3
41777: PUSH
41778: LD_VAR 0 9
41782: EQUAL
41783: IFFALSE 41787
// break ;
41785: GO 41863
// if GetClass ( i ) = 2 then
41787: LD_VAR 0 3
41791: PPUSH
41792: CALL_OW 257
41796: PUSH
41797: LD_INT 2
41799: EQUAL
41800: IFFALSE 41804
// continue ;
41802: GO 41770
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41804: LD_ADDR_VAR 0 11
41808: PUSH
41809: LD_VAR 0 11
41813: PPUSH
41814: LD_VAR 0 11
41818: PUSH
41819: LD_INT 1
41821: PLUS
41822: PPUSH
41823: LD_VAR 0 9
41827: PUSH
41828: LD_VAR 0 3
41832: ARRAY
41833: PPUSH
41834: CALL_OW 2
41838: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41839: LD_ADDR_VAR 0 4
41843: PUSH
41844: LD_VAR 0 4
41848: PUSH
41849: LD_VAR 0 9
41853: PUSH
41854: LD_VAR 0 3
41858: ARRAY
41859: DIFF
41860: ST_TO_ADDR
// end ;
41861: GO 41770
41863: POP
41864: POP
// if p then
41865: LD_VAR 0 11
41869: IFFALSE 41894
// result := Replace ( result , 2 , p ) ;
41871: LD_ADDR_VAR 0 2
41875: PUSH
41876: LD_VAR 0 2
41880: PPUSH
41881: LD_INT 2
41883: PPUSH
41884: LD_VAR 0 11
41888: PPUSH
41889: CALL_OW 1
41893: ST_TO_ADDR
// end ; exit ;
41894: GO 43282
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41896: LD_EXP 137
41900: PUSH
41901: LD_EXP 136
41905: PUSH
41906: LD_VAR 0 1
41910: ARRAY
41911: ARRAY
41912: NOT
41913: PUSH
41914: LD_EXP 110
41918: PUSH
41919: LD_VAR 0 1
41923: ARRAY
41924: PPUSH
41925: LD_INT 30
41927: PUSH
41928: LD_INT 3
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PPUSH
41935: CALL_OW 72
41939: AND
41940: PUSH
41941: LD_EXP 115
41945: PUSH
41946: LD_VAR 0 1
41950: ARRAY
41951: AND
41952: IFFALSE 42560
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41954: LD_ADDR_EXP 152
41958: PUSH
41959: LD_EXP 152
41963: PPUSH
41964: LD_VAR 0 1
41968: PPUSH
41969: LD_INT 5
41971: PPUSH
41972: CALL_OW 1
41976: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41977: LD_ADDR_VAR 0 2
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: LD_INT 0
41987: PUSH
41988: LD_INT 0
41990: PUSH
41991: LD_INT 0
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: ST_TO_ADDR
// if sci > 1 then
42000: LD_VAR 0 8
42004: PUSH
42005: LD_INT 1
42007: GREATER
42008: IFFALSE 42036
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42010: LD_ADDR_VAR 0 4
42014: PUSH
42015: LD_VAR 0 4
42019: PUSH
42020: LD_VAR 0 8
42024: PUSH
42025: LD_VAR 0 8
42029: PUSH
42030: LD_INT 1
42032: ARRAY
42033: DIFF
42034: DIFF
42035: ST_TO_ADDR
// if tmp and not sci then
42036: LD_VAR 0 4
42040: PUSH
42041: LD_VAR 0 8
42045: NOT
42046: AND
42047: IFFALSE 42116
// begin sort := SortBySkill ( tmp , 4 ) ;
42049: LD_ADDR_VAR 0 9
42053: PUSH
42054: LD_VAR 0 4
42058: PPUSH
42059: LD_INT 4
42061: PPUSH
42062: CALL 99560 0 2
42066: ST_TO_ADDR
// if sort then
42067: LD_VAR 0 9
42071: IFFALSE 42087
// p := sort [ 1 ] ;
42073: LD_ADDR_VAR 0 11
42077: PUSH
42078: LD_VAR 0 9
42082: PUSH
42083: LD_INT 1
42085: ARRAY
42086: ST_TO_ADDR
// if p then
42087: LD_VAR 0 11
42091: IFFALSE 42116
// result := Replace ( result , 4 , p ) ;
42093: LD_ADDR_VAR 0 2
42097: PUSH
42098: LD_VAR 0 2
42102: PPUSH
42103: LD_INT 4
42105: PPUSH
42106: LD_VAR 0 11
42110: PPUSH
42111: CALL_OW 1
42115: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42116: LD_ADDR_VAR 0 4
42120: PUSH
42121: LD_VAR 0 4
42125: PUSH
42126: LD_VAR 0 7
42130: DIFF
42131: ST_TO_ADDR
// if tmp and mech < 6 then
42132: LD_VAR 0 4
42136: PUSH
42137: LD_VAR 0 7
42141: PUSH
42142: LD_INT 6
42144: LESS
42145: AND
42146: IFFALSE 42334
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42148: LD_ADDR_VAR 0 9
42152: PUSH
42153: LD_VAR 0 4
42157: PUSH
42158: LD_VAR 0 8
42162: PUSH
42163: LD_VAR 0 7
42167: UNION
42168: DIFF
42169: PPUSH
42170: LD_INT 3
42172: PPUSH
42173: CALL 99560 0 2
42177: ST_TO_ADDR
// p := [ ] ;
42178: LD_ADDR_VAR 0 11
42182: PUSH
42183: EMPTY
42184: ST_TO_ADDR
// if sort then
42185: LD_VAR 0 9
42189: IFFALSE 42305
// for i = 1 to 6 - mech do
42191: LD_ADDR_VAR 0 3
42195: PUSH
42196: DOUBLE
42197: LD_INT 1
42199: DEC
42200: ST_TO_ADDR
42201: LD_INT 6
42203: PUSH
42204: LD_VAR 0 7
42208: MINUS
42209: PUSH
42210: FOR_TO
42211: IFFALSE 42303
// begin if i = sort then
42213: LD_VAR 0 3
42217: PUSH
42218: LD_VAR 0 9
42222: EQUAL
42223: IFFALSE 42227
// break ;
42225: GO 42303
// if GetClass ( i ) = 3 then
42227: LD_VAR 0 3
42231: PPUSH
42232: CALL_OW 257
42236: PUSH
42237: LD_INT 3
42239: EQUAL
42240: IFFALSE 42244
// continue ;
42242: GO 42210
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42244: LD_ADDR_VAR 0 11
42248: PUSH
42249: LD_VAR 0 11
42253: PPUSH
42254: LD_VAR 0 11
42258: PUSH
42259: LD_INT 1
42261: PLUS
42262: PPUSH
42263: LD_VAR 0 9
42267: PUSH
42268: LD_VAR 0 3
42272: ARRAY
42273: PPUSH
42274: CALL_OW 2
42278: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42279: LD_ADDR_VAR 0 4
42283: PUSH
42284: LD_VAR 0 4
42288: PUSH
42289: LD_VAR 0 9
42293: PUSH
42294: LD_VAR 0 3
42298: ARRAY
42299: DIFF
42300: ST_TO_ADDR
// end ;
42301: GO 42210
42303: POP
42304: POP
// if p then
42305: LD_VAR 0 11
42309: IFFALSE 42334
// result := Replace ( result , 3 , p ) ;
42311: LD_ADDR_VAR 0 2
42315: PUSH
42316: LD_VAR 0 2
42320: PPUSH
42321: LD_INT 3
42323: PPUSH
42324: LD_VAR 0 11
42328: PPUSH
42329: CALL_OW 1
42333: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42334: LD_ADDR_VAR 0 4
42338: PUSH
42339: LD_VAR 0 4
42343: PUSH
42344: LD_VAR 0 6
42348: DIFF
42349: ST_TO_ADDR
// if tmp and eng < 6 then
42350: LD_VAR 0 4
42354: PUSH
42355: LD_VAR 0 6
42359: PUSH
42360: LD_INT 6
42362: LESS
42363: AND
42364: IFFALSE 42558
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42366: LD_ADDR_VAR 0 9
42370: PUSH
42371: LD_VAR 0 4
42375: PUSH
42376: LD_VAR 0 8
42380: PUSH
42381: LD_VAR 0 7
42385: UNION
42386: PUSH
42387: LD_VAR 0 6
42391: UNION
42392: DIFF
42393: PPUSH
42394: LD_INT 2
42396: PPUSH
42397: CALL 99560 0 2
42401: ST_TO_ADDR
// p := [ ] ;
42402: LD_ADDR_VAR 0 11
42406: PUSH
42407: EMPTY
42408: ST_TO_ADDR
// if sort then
42409: LD_VAR 0 9
42413: IFFALSE 42529
// for i = 1 to 6 - eng do
42415: LD_ADDR_VAR 0 3
42419: PUSH
42420: DOUBLE
42421: LD_INT 1
42423: DEC
42424: ST_TO_ADDR
42425: LD_INT 6
42427: PUSH
42428: LD_VAR 0 6
42432: MINUS
42433: PUSH
42434: FOR_TO
42435: IFFALSE 42527
// begin if i = sort then
42437: LD_VAR 0 3
42441: PUSH
42442: LD_VAR 0 9
42446: EQUAL
42447: IFFALSE 42451
// break ;
42449: GO 42527
// if GetClass ( i ) = 2 then
42451: LD_VAR 0 3
42455: PPUSH
42456: CALL_OW 257
42460: PUSH
42461: LD_INT 2
42463: EQUAL
42464: IFFALSE 42468
// continue ;
42466: GO 42434
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42468: LD_ADDR_VAR 0 11
42472: PUSH
42473: LD_VAR 0 11
42477: PPUSH
42478: LD_VAR 0 11
42482: PUSH
42483: LD_INT 1
42485: PLUS
42486: PPUSH
42487: LD_VAR 0 9
42491: PUSH
42492: LD_VAR 0 3
42496: ARRAY
42497: PPUSH
42498: CALL_OW 2
42502: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42503: LD_ADDR_VAR 0 4
42507: PUSH
42508: LD_VAR 0 4
42512: PUSH
42513: LD_VAR 0 9
42517: PUSH
42518: LD_VAR 0 3
42522: ARRAY
42523: DIFF
42524: ST_TO_ADDR
// end ;
42525: GO 42434
42527: POP
42528: POP
// if p then
42529: LD_VAR 0 11
42533: IFFALSE 42558
// result := Replace ( result , 2 , p ) ;
42535: LD_ADDR_VAR 0 2
42539: PUSH
42540: LD_VAR 0 2
42544: PPUSH
42545: LD_INT 2
42547: PPUSH
42548: LD_VAR 0 11
42552: PPUSH
42553: CALL_OW 1
42557: ST_TO_ADDR
// end ; exit ;
42558: GO 43282
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42560: LD_EXP 137
42564: PUSH
42565: LD_EXP 136
42569: PUSH
42570: LD_VAR 0 1
42574: ARRAY
42575: ARRAY
42576: NOT
42577: PUSH
42578: LD_EXP 110
42582: PUSH
42583: LD_VAR 0 1
42587: ARRAY
42588: PPUSH
42589: LD_INT 30
42591: PUSH
42592: LD_INT 3
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PPUSH
42599: CALL_OW 72
42603: AND
42604: PUSH
42605: LD_EXP 115
42609: PUSH
42610: LD_VAR 0 1
42614: ARRAY
42615: NOT
42616: AND
42617: IFFALSE 43282
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42619: LD_ADDR_EXP 152
42623: PUSH
42624: LD_EXP 152
42628: PPUSH
42629: LD_VAR 0 1
42633: PPUSH
42634: LD_INT 6
42636: PPUSH
42637: CALL_OW 1
42641: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42642: LD_ADDR_VAR 0 2
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: LD_INT 0
42655: PUSH
42656: LD_INT 0
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: LIST
42663: LIST
42664: ST_TO_ADDR
// if sci >= 1 then
42665: LD_VAR 0 8
42669: PUSH
42670: LD_INT 1
42672: GREATEREQUAL
42673: IFFALSE 42695
// tmp := tmp diff sci [ 1 ] ;
42675: LD_ADDR_VAR 0 4
42679: PUSH
42680: LD_VAR 0 4
42684: PUSH
42685: LD_VAR 0 8
42689: PUSH
42690: LD_INT 1
42692: ARRAY
42693: DIFF
42694: ST_TO_ADDR
// if tmp and not sci then
42695: LD_VAR 0 4
42699: PUSH
42700: LD_VAR 0 8
42704: NOT
42705: AND
42706: IFFALSE 42775
// begin sort := SortBySkill ( tmp , 4 ) ;
42708: LD_ADDR_VAR 0 9
42712: PUSH
42713: LD_VAR 0 4
42717: PPUSH
42718: LD_INT 4
42720: PPUSH
42721: CALL 99560 0 2
42725: ST_TO_ADDR
// if sort then
42726: LD_VAR 0 9
42730: IFFALSE 42746
// p := sort [ 1 ] ;
42732: LD_ADDR_VAR 0 11
42736: PUSH
42737: LD_VAR 0 9
42741: PUSH
42742: LD_INT 1
42744: ARRAY
42745: ST_TO_ADDR
// if p then
42746: LD_VAR 0 11
42750: IFFALSE 42775
// result := Replace ( result , 4 , p ) ;
42752: LD_ADDR_VAR 0 2
42756: PUSH
42757: LD_VAR 0 2
42761: PPUSH
42762: LD_INT 4
42764: PPUSH
42765: LD_VAR 0 11
42769: PPUSH
42770: CALL_OW 1
42774: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42775: LD_ADDR_VAR 0 4
42779: PUSH
42780: LD_VAR 0 4
42784: PUSH
42785: LD_VAR 0 7
42789: DIFF
42790: ST_TO_ADDR
// if tmp and mech < 6 then
42791: LD_VAR 0 4
42795: PUSH
42796: LD_VAR 0 7
42800: PUSH
42801: LD_INT 6
42803: LESS
42804: AND
42805: IFFALSE 42987
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42807: LD_ADDR_VAR 0 9
42811: PUSH
42812: LD_VAR 0 4
42816: PUSH
42817: LD_VAR 0 7
42821: DIFF
42822: PPUSH
42823: LD_INT 3
42825: PPUSH
42826: CALL 99560 0 2
42830: ST_TO_ADDR
// p := [ ] ;
42831: LD_ADDR_VAR 0 11
42835: PUSH
42836: EMPTY
42837: ST_TO_ADDR
// if sort then
42838: LD_VAR 0 9
42842: IFFALSE 42958
// for i = 1 to 6 - mech do
42844: LD_ADDR_VAR 0 3
42848: PUSH
42849: DOUBLE
42850: LD_INT 1
42852: DEC
42853: ST_TO_ADDR
42854: LD_INT 6
42856: PUSH
42857: LD_VAR 0 7
42861: MINUS
42862: PUSH
42863: FOR_TO
42864: IFFALSE 42956
// begin if i = sort then
42866: LD_VAR 0 3
42870: PUSH
42871: LD_VAR 0 9
42875: EQUAL
42876: IFFALSE 42880
// break ;
42878: GO 42956
// if GetClass ( i ) = 3 then
42880: LD_VAR 0 3
42884: PPUSH
42885: CALL_OW 257
42889: PUSH
42890: LD_INT 3
42892: EQUAL
42893: IFFALSE 42897
// continue ;
42895: GO 42863
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42897: LD_ADDR_VAR 0 11
42901: PUSH
42902: LD_VAR 0 11
42906: PPUSH
42907: LD_VAR 0 11
42911: PUSH
42912: LD_INT 1
42914: PLUS
42915: PPUSH
42916: LD_VAR 0 9
42920: PUSH
42921: LD_VAR 0 3
42925: ARRAY
42926: PPUSH
42927: CALL_OW 2
42931: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42932: LD_ADDR_VAR 0 4
42936: PUSH
42937: LD_VAR 0 4
42941: PUSH
42942: LD_VAR 0 9
42946: PUSH
42947: LD_VAR 0 3
42951: ARRAY
42952: DIFF
42953: ST_TO_ADDR
// end ;
42954: GO 42863
42956: POP
42957: POP
// if p then
42958: LD_VAR 0 11
42962: IFFALSE 42987
// result := Replace ( result , 3 , p ) ;
42964: LD_ADDR_VAR 0 2
42968: PUSH
42969: LD_VAR 0 2
42973: PPUSH
42974: LD_INT 3
42976: PPUSH
42977: LD_VAR 0 11
42981: PPUSH
42982: CALL_OW 1
42986: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42987: LD_ADDR_VAR 0 4
42991: PUSH
42992: LD_VAR 0 4
42996: PUSH
42997: LD_VAR 0 6
43001: DIFF
43002: ST_TO_ADDR
// if tmp and eng < 4 then
43003: LD_VAR 0 4
43007: PUSH
43008: LD_VAR 0 6
43012: PUSH
43013: LD_INT 4
43015: LESS
43016: AND
43017: IFFALSE 43207
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43019: LD_ADDR_VAR 0 9
43023: PUSH
43024: LD_VAR 0 4
43028: PUSH
43029: LD_VAR 0 7
43033: PUSH
43034: LD_VAR 0 6
43038: UNION
43039: DIFF
43040: PPUSH
43041: LD_INT 2
43043: PPUSH
43044: CALL 99560 0 2
43048: ST_TO_ADDR
// p := [ ] ;
43049: LD_ADDR_VAR 0 11
43053: PUSH
43054: EMPTY
43055: ST_TO_ADDR
// if sort then
43056: LD_VAR 0 9
43060: IFFALSE 43176
// for i = 1 to 4 - eng do
43062: LD_ADDR_VAR 0 3
43066: PUSH
43067: DOUBLE
43068: LD_INT 1
43070: DEC
43071: ST_TO_ADDR
43072: LD_INT 4
43074: PUSH
43075: LD_VAR 0 6
43079: MINUS
43080: PUSH
43081: FOR_TO
43082: IFFALSE 43174
// begin if i = sort then
43084: LD_VAR 0 3
43088: PUSH
43089: LD_VAR 0 9
43093: EQUAL
43094: IFFALSE 43098
// break ;
43096: GO 43174
// if GetClass ( i ) = 2 then
43098: LD_VAR 0 3
43102: PPUSH
43103: CALL_OW 257
43107: PUSH
43108: LD_INT 2
43110: EQUAL
43111: IFFALSE 43115
// continue ;
43113: GO 43081
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43115: LD_ADDR_VAR 0 11
43119: PUSH
43120: LD_VAR 0 11
43124: PPUSH
43125: LD_VAR 0 11
43129: PUSH
43130: LD_INT 1
43132: PLUS
43133: PPUSH
43134: LD_VAR 0 9
43138: PUSH
43139: LD_VAR 0 3
43143: ARRAY
43144: PPUSH
43145: CALL_OW 2
43149: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43150: LD_ADDR_VAR 0 4
43154: PUSH
43155: LD_VAR 0 4
43159: PUSH
43160: LD_VAR 0 9
43164: PUSH
43165: LD_VAR 0 3
43169: ARRAY
43170: DIFF
43171: ST_TO_ADDR
// end ;
43172: GO 43081
43174: POP
43175: POP
// if p then
43176: LD_VAR 0 11
43180: IFFALSE 43205
// result := Replace ( result , 2 , p ) ;
43182: LD_ADDR_VAR 0 2
43186: PUSH
43187: LD_VAR 0 2
43191: PPUSH
43192: LD_INT 2
43194: PPUSH
43195: LD_VAR 0 11
43199: PPUSH
43200: CALL_OW 1
43204: ST_TO_ADDR
// end else
43205: GO 43251
// for i = eng downto 5 do
43207: LD_ADDR_VAR 0 3
43211: PUSH
43212: DOUBLE
43213: LD_VAR 0 6
43217: INC
43218: ST_TO_ADDR
43219: LD_INT 5
43221: PUSH
43222: FOR_DOWNTO
43223: IFFALSE 43249
// tmp := tmp union eng [ i ] ;
43225: LD_ADDR_VAR 0 4
43229: PUSH
43230: LD_VAR 0 4
43234: PUSH
43235: LD_VAR 0 6
43239: PUSH
43240: LD_VAR 0 3
43244: ARRAY
43245: UNION
43246: ST_TO_ADDR
43247: GO 43222
43249: POP
43250: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43251: LD_ADDR_VAR 0 2
43255: PUSH
43256: LD_VAR 0 2
43260: PPUSH
43261: LD_INT 1
43263: PPUSH
43264: LD_VAR 0 4
43268: PUSH
43269: LD_VAR 0 5
43273: DIFF
43274: PPUSH
43275: CALL_OW 1
43279: ST_TO_ADDR
// exit ;
43280: GO 43282
// end ; end ;
43282: LD_VAR 0 2
43286: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43287: LD_INT 0
43289: PPUSH
43290: PPUSH
43291: PPUSH
// if not mc_bases then
43292: LD_EXP 110
43296: NOT
43297: IFFALSE 43301
// exit ;
43299: GO 43407
// for i = 1 to mc_bases do
43301: LD_ADDR_VAR 0 2
43305: PUSH
43306: DOUBLE
43307: LD_INT 1
43309: DEC
43310: ST_TO_ADDR
43311: LD_EXP 110
43315: PUSH
43316: FOR_TO
43317: IFFALSE 43398
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43319: LD_ADDR_VAR 0 3
43323: PUSH
43324: LD_EXP 110
43328: PUSH
43329: LD_VAR 0 2
43333: ARRAY
43334: PPUSH
43335: LD_INT 21
43337: PUSH
43338: LD_INT 3
43340: PUSH
43341: EMPTY
43342: LIST
43343: LIST
43344: PUSH
43345: LD_INT 3
43347: PUSH
43348: LD_INT 24
43350: PUSH
43351: LD_INT 1000
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: PUSH
43358: EMPTY
43359: LIST
43360: LIST
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PPUSH
43366: CALL_OW 72
43370: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43371: LD_ADDR_EXP 111
43375: PUSH
43376: LD_EXP 111
43380: PPUSH
43381: LD_VAR 0 2
43385: PPUSH
43386: LD_VAR 0 3
43390: PPUSH
43391: CALL_OW 1
43395: ST_TO_ADDR
// end ;
43396: GO 43316
43398: POP
43399: POP
// RaiseSailEvent ( 101 ) ;
43400: LD_INT 101
43402: PPUSH
43403: CALL_OW 427
// end ;
43407: LD_VAR 0 1
43411: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43412: LD_INT 0
43414: PPUSH
43415: PPUSH
43416: PPUSH
43417: PPUSH
43418: PPUSH
43419: PPUSH
43420: PPUSH
// if not mc_bases then
43421: LD_EXP 110
43425: NOT
43426: IFFALSE 43430
// exit ;
43428: GO 43992
// for i = 1 to mc_bases do
43430: LD_ADDR_VAR 0 2
43434: PUSH
43435: DOUBLE
43436: LD_INT 1
43438: DEC
43439: ST_TO_ADDR
43440: LD_EXP 110
43444: PUSH
43445: FOR_TO
43446: IFFALSE 43983
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43448: LD_ADDR_VAR 0 5
43452: PUSH
43453: LD_EXP 110
43457: PUSH
43458: LD_VAR 0 2
43462: ARRAY
43463: PUSH
43464: LD_EXP 139
43468: PUSH
43469: LD_VAR 0 2
43473: ARRAY
43474: UNION
43475: PPUSH
43476: LD_INT 21
43478: PUSH
43479: LD_INT 1
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PUSH
43486: LD_INT 1
43488: PUSH
43489: LD_INT 3
43491: PUSH
43492: LD_INT 54
43494: PUSH
43495: EMPTY
43496: LIST
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 3
43504: PUSH
43505: LD_INT 24
43507: PUSH
43508: LD_INT 800
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: LIST
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PPUSH
43528: CALL_OW 72
43532: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43533: LD_ADDR_VAR 0 6
43537: PUSH
43538: LD_EXP 110
43542: PUSH
43543: LD_VAR 0 2
43547: ARRAY
43548: PPUSH
43549: LD_INT 21
43551: PUSH
43552: LD_INT 1
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: LD_INT 1
43561: PUSH
43562: LD_INT 3
43564: PUSH
43565: LD_INT 54
43567: PUSH
43568: EMPTY
43569: LIST
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 3
43577: PUSH
43578: LD_INT 24
43580: PUSH
43581: LD_INT 250
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: LIST
43596: PUSH
43597: EMPTY
43598: LIST
43599: LIST
43600: PPUSH
43601: CALL_OW 72
43605: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43606: LD_ADDR_VAR 0 7
43610: PUSH
43611: LD_VAR 0 5
43615: PUSH
43616: LD_VAR 0 6
43620: DIFF
43621: ST_TO_ADDR
// if not need_heal_1 then
43622: LD_VAR 0 6
43626: NOT
43627: IFFALSE 43660
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43629: LD_ADDR_EXP 113
43633: PUSH
43634: LD_EXP 113
43638: PPUSH
43639: LD_VAR 0 2
43643: PUSH
43644: LD_INT 1
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PPUSH
43651: EMPTY
43652: PPUSH
43653: CALL 70011 0 3
43657: ST_TO_ADDR
43658: GO 43730
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43660: LD_ADDR_EXP 113
43664: PUSH
43665: LD_EXP 113
43669: PPUSH
43670: LD_VAR 0 2
43674: PUSH
43675: LD_INT 1
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PPUSH
43682: LD_EXP 113
43686: PUSH
43687: LD_VAR 0 2
43691: ARRAY
43692: PUSH
43693: LD_INT 1
43695: ARRAY
43696: PPUSH
43697: LD_INT 3
43699: PUSH
43700: LD_INT 24
43702: PUSH
43703: LD_INT 1000
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PPUSH
43714: CALL_OW 72
43718: PUSH
43719: LD_VAR 0 6
43723: UNION
43724: PPUSH
43725: CALL 70011 0 3
43729: ST_TO_ADDR
// if not need_heal_2 then
43730: LD_VAR 0 7
43734: NOT
43735: IFFALSE 43768
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43737: LD_ADDR_EXP 113
43741: PUSH
43742: LD_EXP 113
43746: PPUSH
43747: LD_VAR 0 2
43751: PUSH
43752: LD_INT 2
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PPUSH
43759: EMPTY
43760: PPUSH
43761: CALL 70011 0 3
43765: ST_TO_ADDR
43766: GO 43800
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43768: LD_ADDR_EXP 113
43772: PUSH
43773: LD_EXP 113
43777: PPUSH
43778: LD_VAR 0 2
43782: PUSH
43783: LD_INT 2
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PPUSH
43790: LD_VAR 0 7
43794: PPUSH
43795: CALL 70011 0 3
43799: ST_TO_ADDR
// if need_heal_2 then
43800: LD_VAR 0 7
43804: IFFALSE 43965
// for j in need_heal_2 do
43806: LD_ADDR_VAR 0 3
43810: PUSH
43811: LD_VAR 0 7
43815: PUSH
43816: FOR_IN
43817: IFFALSE 43963
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43819: LD_ADDR_VAR 0 5
43823: PUSH
43824: LD_EXP 110
43828: PUSH
43829: LD_VAR 0 2
43833: ARRAY
43834: PPUSH
43835: LD_INT 2
43837: PUSH
43838: LD_INT 30
43840: PUSH
43841: LD_INT 6
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 30
43850: PUSH
43851: LD_INT 7
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 30
43860: PUSH
43861: LD_INT 8
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 30
43870: PUSH
43871: LD_INT 0
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 30
43880: PUSH
43881: LD_INT 1
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: PPUSH
43896: CALL_OW 72
43900: ST_TO_ADDR
// if tmp then
43901: LD_VAR 0 5
43905: IFFALSE 43961
// begin k := NearestUnitToUnit ( tmp , j ) ;
43907: LD_ADDR_VAR 0 4
43911: PUSH
43912: LD_VAR 0 5
43916: PPUSH
43917: LD_VAR 0 3
43921: PPUSH
43922: CALL_OW 74
43926: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
43927: LD_VAR 0 3
43931: PPUSH
43932: LD_VAR 0 4
43936: PPUSH
43937: CALL_OW 296
43941: PUSH
43942: LD_INT 5
43944: GREATER
43945: IFFALSE 43961
// ComMoveUnit ( j , k ) ;
43947: LD_VAR 0 3
43951: PPUSH
43952: LD_VAR 0 4
43956: PPUSH
43957: CALL_OW 112
// end ; end ;
43961: GO 43816
43963: POP
43964: POP
// if not need_heal_1 and not need_heal_2 then
43965: LD_VAR 0 6
43969: NOT
43970: PUSH
43971: LD_VAR 0 7
43975: NOT
43976: AND
43977: IFFALSE 43981
// continue ;
43979: GO 43445
// end ;
43981: GO 43445
43983: POP
43984: POP
// RaiseSailEvent ( 102 ) ;
43985: LD_INT 102
43987: PPUSH
43988: CALL_OW 427
// end ;
43992: LD_VAR 0 1
43996: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43997: LD_INT 0
43999: PPUSH
44000: PPUSH
44001: PPUSH
44002: PPUSH
44003: PPUSH
44004: PPUSH
44005: PPUSH
44006: PPUSH
// if not mc_bases then
44007: LD_EXP 110
44011: NOT
44012: IFFALSE 44016
// exit ;
44014: GO 44851
// for i = 1 to mc_bases do
44016: LD_ADDR_VAR 0 2
44020: PUSH
44021: DOUBLE
44022: LD_INT 1
44024: DEC
44025: ST_TO_ADDR
44026: LD_EXP 110
44030: PUSH
44031: FOR_TO
44032: IFFALSE 44849
// begin if not mc_building_need_repair [ i ] then
44034: LD_EXP 111
44038: PUSH
44039: LD_VAR 0 2
44043: ARRAY
44044: NOT
44045: IFFALSE 44219
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
44047: LD_ADDR_VAR 0 6
44051: PUSH
44052: LD_EXP 129
44056: PUSH
44057: LD_VAR 0 2
44061: ARRAY
44062: PPUSH
44063: LD_INT 3
44065: PUSH
44066: LD_INT 24
44068: PUSH
44069: LD_INT 1000
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 2
44082: PUSH
44083: LD_INT 34
44085: PUSH
44086: LD_INT 13
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: PUSH
44093: LD_INT 34
44095: PUSH
44096: LD_INT 52
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: LIST
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PPUSH
44112: CALL_OW 72
44116: ST_TO_ADDR
// if cranes then
44117: LD_VAR 0 6
44121: IFFALSE 44183
// for j in cranes do
44123: LD_ADDR_VAR 0 3
44127: PUSH
44128: LD_VAR 0 6
44132: PUSH
44133: FOR_IN
44134: IFFALSE 44181
// if not IsInArea ( j , mc_parking [ i ] ) then
44136: LD_VAR 0 3
44140: PPUSH
44141: LD_EXP 134
44145: PUSH
44146: LD_VAR 0 2
44150: ARRAY
44151: PPUSH
44152: CALL_OW 308
44156: NOT
44157: IFFALSE 44179
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44159: LD_VAR 0 3
44163: PPUSH
44164: LD_EXP 134
44168: PUSH
44169: LD_VAR 0 2
44173: ARRAY
44174: PPUSH
44175: CALL_OW 113
44179: GO 44133
44181: POP
44182: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44183: LD_ADDR_EXP 112
44187: PUSH
44188: LD_EXP 112
44192: PPUSH
44193: LD_VAR 0 2
44197: PPUSH
44198: EMPTY
44199: PPUSH
44200: CALL_OW 1
44204: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44205: LD_VAR 0 2
44209: PPUSH
44210: LD_INT 101
44212: PPUSH
44213: CALL 39120 0 2
// continue ;
44217: GO 44031
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44219: LD_ADDR_EXP 116
44223: PUSH
44224: LD_EXP 116
44228: PPUSH
44229: LD_VAR 0 2
44233: PPUSH
44234: EMPTY
44235: PPUSH
44236: CALL_OW 1
44240: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44241: LD_VAR 0 2
44245: PPUSH
44246: LD_INT 103
44248: PPUSH
44249: CALL 39120 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44253: LD_ADDR_VAR 0 5
44257: PUSH
44258: LD_EXP 110
44262: PUSH
44263: LD_VAR 0 2
44267: ARRAY
44268: PUSH
44269: LD_EXP 139
44273: PUSH
44274: LD_VAR 0 2
44278: ARRAY
44279: UNION
44280: PPUSH
44281: LD_INT 2
44283: PUSH
44284: LD_INT 25
44286: PUSH
44287: LD_INT 2
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 25
44296: PUSH
44297: LD_INT 16
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: LIST
44308: PUSH
44309: EMPTY
44310: LIST
44311: PPUSH
44312: CALL_OW 72
44316: PUSH
44317: LD_EXP 113
44321: PUSH
44322: LD_VAR 0 2
44326: ARRAY
44327: PUSH
44328: LD_INT 1
44330: ARRAY
44331: PUSH
44332: LD_EXP 113
44336: PUSH
44337: LD_VAR 0 2
44341: ARRAY
44342: PUSH
44343: LD_INT 2
44345: ARRAY
44346: UNION
44347: DIFF
44348: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44349: LD_ADDR_VAR 0 6
44353: PUSH
44354: LD_EXP 129
44358: PUSH
44359: LD_VAR 0 2
44363: ARRAY
44364: PPUSH
44365: LD_INT 2
44367: PUSH
44368: LD_INT 34
44370: PUSH
44371: LD_INT 13
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: PUSH
44378: LD_INT 34
44380: PUSH
44381: LD_INT 52
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: LIST
44392: PPUSH
44393: CALL_OW 72
44397: ST_TO_ADDR
// if cranes then
44398: LD_VAR 0 6
44402: IFFALSE 44538
// begin for j in cranes do
44404: LD_ADDR_VAR 0 3
44408: PUSH
44409: LD_VAR 0 6
44413: PUSH
44414: FOR_IN
44415: IFFALSE 44536
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44417: LD_VAR 0 3
44421: PPUSH
44422: CALL_OW 256
44426: PUSH
44427: LD_INT 500
44429: GREATEREQUAL
44430: PUSH
44431: LD_VAR 0 3
44435: PPUSH
44436: CALL_OW 314
44440: NOT
44441: AND
44442: IFFALSE 44476
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44444: LD_VAR 0 3
44448: PPUSH
44449: LD_EXP 111
44453: PUSH
44454: LD_VAR 0 2
44458: ARRAY
44459: PPUSH
44460: LD_VAR 0 3
44464: PPUSH
44465: CALL_OW 74
44469: PPUSH
44470: CALL_OW 130
44474: GO 44534
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44476: LD_VAR 0 3
44480: PPUSH
44481: CALL_OW 256
44485: PUSH
44486: LD_INT 500
44488: LESS
44489: PUSH
44490: LD_VAR 0 3
44494: PPUSH
44495: LD_EXP 134
44499: PUSH
44500: LD_VAR 0 2
44504: ARRAY
44505: PPUSH
44506: CALL_OW 308
44510: NOT
44511: AND
44512: IFFALSE 44534
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44514: LD_VAR 0 3
44518: PPUSH
44519: LD_EXP 134
44523: PUSH
44524: LD_VAR 0 2
44528: ARRAY
44529: PPUSH
44530: CALL_OW 113
44534: GO 44414
44536: POP
44537: POP
// end ; if tmp > 3 then
44538: LD_VAR 0 5
44542: PUSH
44543: LD_INT 3
44545: GREATER
44546: IFFALSE 44566
// tmp := ShrinkArray ( tmp , 4 ) ;
44548: LD_ADDR_VAR 0 5
44552: PUSH
44553: LD_VAR 0 5
44557: PPUSH
44558: LD_INT 4
44560: PPUSH
44561: CALL 101237 0 2
44565: ST_TO_ADDR
// if not tmp then
44566: LD_VAR 0 5
44570: NOT
44571: IFFALSE 44575
// continue ;
44573: GO 44031
// for j in tmp do
44575: LD_ADDR_VAR 0 3
44579: PUSH
44580: LD_VAR 0 5
44584: PUSH
44585: FOR_IN
44586: IFFALSE 44845
// begin if IsInUnit ( j ) then
44588: LD_VAR 0 3
44592: PPUSH
44593: CALL_OW 310
44597: IFFALSE 44608
// ComExitBuilding ( j ) ;
44599: LD_VAR 0 3
44603: PPUSH
44604: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44608: LD_VAR 0 3
44612: PUSH
44613: LD_EXP 112
44617: PUSH
44618: LD_VAR 0 2
44622: ARRAY
44623: IN
44624: NOT
44625: IFFALSE 44683
// begin SetTag ( j , 101 ) ;
44627: LD_VAR 0 3
44631: PPUSH
44632: LD_INT 101
44634: PPUSH
44635: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44639: LD_ADDR_EXP 112
44643: PUSH
44644: LD_EXP 112
44648: PPUSH
44649: LD_VAR 0 2
44653: PUSH
44654: LD_EXP 112
44658: PUSH
44659: LD_VAR 0 2
44663: ARRAY
44664: PUSH
44665: LD_INT 1
44667: PLUS
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PPUSH
44673: LD_VAR 0 3
44677: PPUSH
44678: CALL 70011 0 3
44682: ST_TO_ADDR
// end ; wait ( 1 ) ;
44683: LD_INT 1
44685: PPUSH
44686: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44690: LD_ADDR_VAR 0 7
44694: PUSH
44695: LD_EXP 111
44699: PUSH
44700: LD_VAR 0 2
44704: ARRAY
44705: ST_TO_ADDR
// if mc_scan [ i ] then
44706: LD_EXP 133
44710: PUSH
44711: LD_VAR 0 2
44715: ARRAY
44716: IFFALSE 44778
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44718: LD_ADDR_VAR 0 7
44722: PUSH
44723: LD_EXP 111
44727: PUSH
44728: LD_VAR 0 2
44732: ARRAY
44733: PPUSH
44734: LD_INT 3
44736: PUSH
44737: LD_INT 30
44739: PUSH
44740: LD_INT 32
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: PUSH
44747: LD_INT 30
44749: PUSH
44750: LD_INT 33
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 30
44759: PUSH
44760: LD_INT 31
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: PPUSH
44773: CALL_OW 72
44777: ST_TO_ADDR
// if not to_repair_tmp then
44778: LD_VAR 0 7
44782: NOT
44783: IFFALSE 44787
// continue ;
44785: GO 44585
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44787: LD_ADDR_VAR 0 8
44791: PUSH
44792: LD_VAR 0 7
44796: PPUSH
44797: LD_VAR 0 3
44801: PPUSH
44802: CALL_OW 74
44806: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
44807: LD_VAR 0 8
44811: PPUSH
44812: LD_INT 16
44814: PPUSH
44815: CALL 72604 0 2
44819: PUSH
44820: LD_INT 4
44822: ARRAY
44823: PUSH
44824: LD_INT 5
44826: LESS
44827: IFFALSE 44843
// ComRepairBuilding ( j , to_repair ) ;
44829: LD_VAR 0 3
44833: PPUSH
44834: LD_VAR 0 8
44838: PPUSH
44839: CALL_OW 130
// end ;
44843: GO 44585
44845: POP
44846: POP
// end ;
44847: GO 44031
44849: POP
44850: POP
// end ;
44851: LD_VAR 0 1
44855: RET
// export function MC_Heal ; var i , j , tmp ; begin
44856: LD_INT 0
44858: PPUSH
44859: PPUSH
44860: PPUSH
44861: PPUSH
// if not mc_bases then
44862: LD_EXP 110
44866: NOT
44867: IFFALSE 44871
// exit ;
44869: GO 45273
// for i = 1 to mc_bases do
44871: LD_ADDR_VAR 0 2
44875: PUSH
44876: DOUBLE
44877: LD_INT 1
44879: DEC
44880: ST_TO_ADDR
44881: LD_EXP 110
44885: PUSH
44886: FOR_TO
44887: IFFALSE 45271
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44889: LD_EXP 113
44893: PUSH
44894: LD_VAR 0 2
44898: ARRAY
44899: PUSH
44900: LD_INT 1
44902: ARRAY
44903: NOT
44904: PUSH
44905: LD_EXP 113
44909: PUSH
44910: LD_VAR 0 2
44914: ARRAY
44915: PUSH
44916: LD_INT 2
44918: ARRAY
44919: NOT
44920: AND
44921: IFFALSE 44959
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44923: LD_ADDR_EXP 114
44927: PUSH
44928: LD_EXP 114
44932: PPUSH
44933: LD_VAR 0 2
44937: PPUSH
44938: EMPTY
44939: PPUSH
44940: CALL_OW 1
44944: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44945: LD_VAR 0 2
44949: PPUSH
44950: LD_INT 102
44952: PPUSH
44953: CALL 39120 0 2
// continue ;
44957: GO 44886
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44959: LD_ADDR_VAR 0 4
44963: PUSH
44964: LD_EXP 110
44968: PUSH
44969: LD_VAR 0 2
44973: ARRAY
44974: PPUSH
44975: LD_INT 25
44977: PUSH
44978: LD_INT 4
44980: PUSH
44981: EMPTY
44982: LIST
44983: LIST
44984: PPUSH
44985: CALL_OW 72
44989: ST_TO_ADDR
// if not tmp then
44990: LD_VAR 0 4
44994: NOT
44995: IFFALSE 44999
// continue ;
44997: GO 44886
// if mc_taming [ i ] then
44999: LD_EXP 141
45003: PUSH
45004: LD_VAR 0 2
45008: ARRAY
45009: IFFALSE 45033
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45011: LD_ADDR_EXP 141
45015: PUSH
45016: LD_EXP 141
45020: PPUSH
45021: LD_VAR 0 2
45025: PPUSH
45026: EMPTY
45027: PPUSH
45028: CALL_OW 1
45032: ST_TO_ADDR
// for j in tmp do
45033: LD_ADDR_VAR 0 3
45037: PUSH
45038: LD_VAR 0 4
45042: PUSH
45043: FOR_IN
45044: IFFALSE 45267
// begin if IsInUnit ( j ) then
45046: LD_VAR 0 3
45050: PPUSH
45051: CALL_OW 310
45055: IFFALSE 45066
// ComExitBuilding ( j ) ;
45057: LD_VAR 0 3
45061: PPUSH
45062: CALL_OW 122
// if not j in mc_healers [ i ] then
45066: LD_VAR 0 3
45070: PUSH
45071: LD_EXP 114
45075: PUSH
45076: LD_VAR 0 2
45080: ARRAY
45081: IN
45082: NOT
45083: IFFALSE 45129
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45085: LD_ADDR_EXP 114
45089: PUSH
45090: LD_EXP 114
45094: PPUSH
45095: LD_VAR 0 2
45099: PUSH
45100: LD_EXP 114
45104: PUSH
45105: LD_VAR 0 2
45109: ARRAY
45110: PUSH
45111: LD_INT 1
45113: PLUS
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PPUSH
45119: LD_VAR 0 3
45123: PPUSH
45124: CALL 70011 0 3
45128: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45129: LD_VAR 0 3
45133: PPUSH
45134: CALL_OW 110
45138: PUSH
45139: LD_INT 102
45141: NONEQUAL
45142: IFFALSE 45156
// SetTag ( j , 102 ) ;
45144: LD_VAR 0 3
45148: PPUSH
45149: LD_INT 102
45151: PPUSH
45152: CALL_OW 109
// Wait ( 3 ) ;
45156: LD_INT 3
45158: PPUSH
45159: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45163: LD_EXP 113
45167: PUSH
45168: LD_VAR 0 2
45172: ARRAY
45173: PUSH
45174: LD_INT 1
45176: ARRAY
45177: IFFALSE 45209
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45179: LD_VAR 0 3
45183: PPUSH
45184: LD_EXP 113
45188: PUSH
45189: LD_VAR 0 2
45193: ARRAY
45194: PUSH
45195: LD_INT 1
45197: ARRAY
45198: PUSH
45199: LD_INT 1
45201: ARRAY
45202: PPUSH
45203: CALL_OW 128
45207: GO 45265
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45209: LD_VAR 0 3
45213: PPUSH
45214: CALL_OW 314
45218: NOT
45219: PUSH
45220: LD_EXP 113
45224: PUSH
45225: LD_VAR 0 2
45229: ARRAY
45230: PUSH
45231: LD_INT 2
45233: ARRAY
45234: AND
45235: IFFALSE 45265
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45237: LD_VAR 0 3
45241: PPUSH
45242: LD_EXP 113
45246: PUSH
45247: LD_VAR 0 2
45251: ARRAY
45252: PUSH
45253: LD_INT 2
45255: ARRAY
45256: PUSH
45257: LD_INT 1
45259: ARRAY
45260: PPUSH
45261: CALL_OW 128
// end ;
45265: GO 45043
45267: POP
45268: POP
// end ;
45269: GO 44886
45271: POP
45272: POP
// end ;
45273: LD_VAR 0 1
45277: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45278: LD_INT 0
45280: PPUSH
45281: PPUSH
45282: PPUSH
45283: PPUSH
45284: PPUSH
// if not mc_bases then
45285: LD_EXP 110
45289: NOT
45290: IFFALSE 45294
// exit ;
45292: GO 46437
// for i = 1 to mc_bases do
45294: LD_ADDR_VAR 0 2
45298: PUSH
45299: DOUBLE
45300: LD_INT 1
45302: DEC
45303: ST_TO_ADDR
45304: LD_EXP 110
45308: PUSH
45309: FOR_TO
45310: IFFALSE 46435
// begin if mc_scan [ i ] then
45312: LD_EXP 133
45316: PUSH
45317: LD_VAR 0 2
45321: ARRAY
45322: IFFALSE 45326
// continue ;
45324: GO 45309
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45326: LD_EXP 115
45330: PUSH
45331: LD_VAR 0 2
45335: ARRAY
45336: NOT
45337: PUSH
45338: LD_EXP 117
45342: PUSH
45343: LD_VAR 0 2
45347: ARRAY
45348: NOT
45349: AND
45350: PUSH
45351: LD_EXP 116
45355: PUSH
45356: LD_VAR 0 2
45360: ARRAY
45361: AND
45362: IFFALSE 45400
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45364: LD_ADDR_EXP 116
45368: PUSH
45369: LD_EXP 116
45373: PPUSH
45374: LD_VAR 0 2
45378: PPUSH
45379: EMPTY
45380: PPUSH
45381: CALL_OW 1
45385: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45386: LD_VAR 0 2
45390: PPUSH
45391: LD_INT 103
45393: PPUSH
45394: CALL 39120 0 2
// continue ;
45398: GO 45309
// end ; if mc_construct_list [ i ] then
45400: LD_EXP 117
45404: PUSH
45405: LD_VAR 0 2
45409: ARRAY
45410: IFFALSE 45630
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45412: LD_ADDR_VAR 0 4
45416: PUSH
45417: LD_EXP 110
45421: PUSH
45422: LD_VAR 0 2
45426: ARRAY
45427: PPUSH
45428: LD_INT 25
45430: PUSH
45431: LD_INT 2
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: PPUSH
45438: CALL_OW 72
45442: PUSH
45443: LD_EXP 112
45447: PUSH
45448: LD_VAR 0 2
45452: ARRAY
45453: DIFF
45454: ST_TO_ADDR
// if not tmp then
45455: LD_VAR 0 4
45459: NOT
45460: IFFALSE 45464
// continue ;
45462: GO 45309
// for j in tmp do
45464: LD_ADDR_VAR 0 3
45468: PUSH
45469: LD_VAR 0 4
45473: PUSH
45474: FOR_IN
45475: IFFALSE 45626
// begin if not mc_builders [ i ] then
45477: LD_EXP 116
45481: PUSH
45482: LD_VAR 0 2
45486: ARRAY
45487: NOT
45488: IFFALSE 45546
// begin SetTag ( j , 103 ) ;
45490: LD_VAR 0 3
45494: PPUSH
45495: LD_INT 103
45497: PPUSH
45498: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45502: LD_ADDR_EXP 116
45506: PUSH
45507: LD_EXP 116
45511: PPUSH
45512: LD_VAR 0 2
45516: PUSH
45517: LD_EXP 116
45521: PUSH
45522: LD_VAR 0 2
45526: ARRAY
45527: PUSH
45528: LD_INT 1
45530: PLUS
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PPUSH
45536: LD_VAR 0 3
45540: PPUSH
45541: CALL 70011 0 3
45545: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45546: LD_VAR 0 3
45550: PPUSH
45551: CALL_OW 310
45555: IFFALSE 45566
// ComExitBuilding ( j ) ;
45557: LD_VAR 0 3
45561: PPUSH
45562: CALL_OW 122
// wait ( 3 ) ;
45566: LD_INT 3
45568: PPUSH
45569: CALL_OW 67
// if not mc_construct_list [ i ] then
45573: LD_EXP 117
45577: PUSH
45578: LD_VAR 0 2
45582: ARRAY
45583: NOT
45584: IFFALSE 45588
// break ;
45586: GO 45626
// if not HasTask ( j ) then
45588: LD_VAR 0 3
45592: PPUSH
45593: CALL_OW 314
45597: NOT
45598: IFFALSE 45624
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45600: LD_VAR 0 3
45604: PPUSH
45605: LD_EXP 117
45609: PUSH
45610: LD_VAR 0 2
45614: ARRAY
45615: PUSH
45616: LD_INT 1
45618: ARRAY
45619: PPUSH
45620: CALL 72862 0 2
// end ;
45624: GO 45474
45626: POP
45627: POP
// end else
45628: GO 46433
// if mc_build_list [ i ] then
45630: LD_EXP 115
45634: PUSH
45635: LD_VAR 0 2
45639: ARRAY
45640: IFFALSE 46433
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45642: LD_ADDR_VAR 0 5
45646: PUSH
45647: LD_EXP 110
45651: PUSH
45652: LD_VAR 0 2
45656: ARRAY
45657: PPUSH
45658: LD_INT 2
45660: PUSH
45661: LD_INT 30
45663: PUSH
45664: LD_INT 0
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: PUSH
45671: LD_INT 30
45673: PUSH
45674: LD_INT 1
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: LIST
45685: PPUSH
45686: CALL_OW 72
45690: ST_TO_ADDR
// if depot then
45691: LD_VAR 0 5
45695: IFFALSE 45713
// depot := depot [ 1 ] else
45697: LD_ADDR_VAR 0 5
45701: PUSH
45702: LD_VAR 0 5
45706: PUSH
45707: LD_INT 1
45709: ARRAY
45710: ST_TO_ADDR
45711: GO 45721
// depot := 0 ;
45713: LD_ADDR_VAR 0 5
45717: PUSH
45718: LD_INT 0
45720: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45721: LD_EXP 115
45725: PUSH
45726: LD_VAR 0 2
45730: ARRAY
45731: PUSH
45732: LD_INT 1
45734: ARRAY
45735: PUSH
45736: LD_INT 1
45738: ARRAY
45739: PPUSH
45740: CALL 72692 0 1
45744: PUSH
45745: LD_EXP 110
45749: PUSH
45750: LD_VAR 0 2
45754: ARRAY
45755: PPUSH
45756: LD_INT 2
45758: PUSH
45759: LD_INT 30
45761: PUSH
45762: LD_INT 2
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 30
45771: PUSH
45772: LD_INT 3
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: LIST
45783: PPUSH
45784: CALL_OW 72
45788: NOT
45789: AND
45790: IFFALSE 45895
// begin for j = 1 to mc_build_list [ i ] do
45792: LD_ADDR_VAR 0 3
45796: PUSH
45797: DOUBLE
45798: LD_INT 1
45800: DEC
45801: ST_TO_ADDR
45802: LD_EXP 115
45806: PUSH
45807: LD_VAR 0 2
45811: ARRAY
45812: PUSH
45813: FOR_TO
45814: IFFALSE 45893
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45816: LD_EXP 115
45820: PUSH
45821: LD_VAR 0 2
45825: ARRAY
45826: PUSH
45827: LD_VAR 0 3
45831: ARRAY
45832: PUSH
45833: LD_INT 1
45835: ARRAY
45836: PUSH
45837: LD_INT 2
45839: EQUAL
45840: IFFALSE 45891
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45842: LD_ADDR_EXP 115
45846: PUSH
45847: LD_EXP 115
45851: PPUSH
45852: LD_VAR 0 2
45856: PPUSH
45857: LD_EXP 115
45861: PUSH
45862: LD_VAR 0 2
45866: ARRAY
45867: PPUSH
45868: LD_VAR 0 3
45872: PPUSH
45873: LD_INT 1
45875: PPUSH
45876: LD_INT 0
45878: PPUSH
45879: CALL 69429 0 4
45883: PPUSH
45884: CALL_OW 1
45888: ST_TO_ADDR
// break ;
45889: GO 45893
// end ;
45891: GO 45813
45893: POP
45894: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45895: LD_EXP 115
45899: PUSH
45900: LD_VAR 0 2
45904: ARRAY
45905: PUSH
45906: LD_INT 1
45908: ARRAY
45909: PUSH
45910: LD_INT 1
45912: ARRAY
45913: PUSH
45914: LD_INT 0
45916: EQUAL
45917: PUSH
45918: LD_VAR 0 5
45922: PUSH
45923: LD_VAR 0 5
45927: PPUSH
45928: LD_EXP 115
45932: PUSH
45933: LD_VAR 0 2
45937: ARRAY
45938: PUSH
45939: LD_INT 1
45941: ARRAY
45942: PUSH
45943: LD_INT 1
45945: ARRAY
45946: PPUSH
45947: LD_EXP 115
45951: PUSH
45952: LD_VAR 0 2
45956: ARRAY
45957: PUSH
45958: LD_INT 1
45960: ARRAY
45961: PUSH
45962: LD_INT 2
45964: ARRAY
45965: PPUSH
45966: LD_EXP 115
45970: PUSH
45971: LD_VAR 0 2
45975: ARRAY
45976: PUSH
45977: LD_INT 1
45979: ARRAY
45980: PUSH
45981: LD_INT 3
45983: ARRAY
45984: PPUSH
45985: LD_EXP 115
45989: PUSH
45990: LD_VAR 0 2
45994: ARRAY
45995: PUSH
45996: LD_INT 1
45998: ARRAY
45999: PUSH
46000: LD_INT 4
46002: ARRAY
46003: PPUSH
46004: CALL 77426 0 5
46008: AND
46009: OR
46010: IFFALSE 46291
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46012: LD_ADDR_VAR 0 4
46016: PUSH
46017: LD_EXP 110
46021: PUSH
46022: LD_VAR 0 2
46026: ARRAY
46027: PPUSH
46028: LD_INT 25
46030: PUSH
46031: LD_INT 2
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: PPUSH
46038: CALL_OW 72
46042: PUSH
46043: LD_EXP 112
46047: PUSH
46048: LD_VAR 0 2
46052: ARRAY
46053: DIFF
46054: ST_TO_ADDR
// if not tmp then
46055: LD_VAR 0 4
46059: NOT
46060: IFFALSE 46064
// continue ;
46062: GO 45309
// for j in tmp do
46064: LD_ADDR_VAR 0 3
46068: PUSH
46069: LD_VAR 0 4
46073: PUSH
46074: FOR_IN
46075: IFFALSE 46287
// begin if not mc_builders [ i ] then
46077: LD_EXP 116
46081: PUSH
46082: LD_VAR 0 2
46086: ARRAY
46087: NOT
46088: IFFALSE 46146
// begin SetTag ( j , 103 ) ;
46090: LD_VAR 0 3
46094: PPUSH
46095: LD_INT 103
46097: PPUSH
46098: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46102: LD_ADDR_EXP 116
46106: PUSH
46107: LD_EXP 116
46111: PPUSH
46112: LD_VAR 0 2
46116: PUSH
46117: LD_EXP 116
46121: PUSH
46122: LD_VAR 0 2
46126: ARRAY
46127: PUSH
46128: LD_INT 1
46130: PLUS
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: PPUSH
46136: LD_VAR 0 3
46140: PPUSH
46141: CALL 70011 0 3
46145: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46146: LD_VAR 0 3
46150: PPUSH
46151: CALL_OW 310
46155: IFFALSE 46166
// ComExitBuilding ( j ) ;
46157: LD_VAR 0 3
46161: PPUSH
46162: CALL_OW 122
// wait ( 3 ) ;
46166: LD_INT 3
46168: PPUSH
46169: CALL_OW 67
// if not mc_build_list [ i ] then
46173: LD_EXP 115
46177: PUSH
46178: LD_VAR 0 2
46182: ARRAY
46183: NOT
46184: IFFALSE 46188
// break ;
46186: GO 46287
// if not HasTask ( j ) then
46188: LD_VAR 0 3
46192: PPUSH
46193: CALL_OW 314
46197: NOT
46198: IFFALSE 46285
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46200: LD_VAR 0 3
46204: PPUSH
46205: LD_EXP 115
46209: PUSH
46210: LD_VAR 0 2
46214: ARRAY
46215: PUSH
46216: LD_INT 1
46218: ARRAY
46219: PUSH
46220: LD_INT 1
46222: ARRAY
46223: PPUSH
46224: LD_EXP 115
46228: PUSH
46229: LD_VAR 0 2
46233: ARRAY
46234: PUSH
46235: LD_INT 1
46237: ARRAY
46238: PUSH
46239: LD_INT 2
46241: ARRAY
46242: PPUSH
46243: LD_EXP 115
46247: PUSH
46248: LD_VAR 0 2
46252: ARRAY
46253: PUSH
46254: LD_INT 1
46256: ARRAY
46257: PUSH
46258: LD_INT 3
46260: ARRAY
46261: PPUSH
46262: LD_EXP 115
46266: PUSH
46267: LD_VAR 0 2
46271: ARRAY
46272: PUSH
46273: LD_INT 1
46275: ARRAY
46276: PUSH
46277: LD_INT 4
46279: ARRAY
46280: PPUSH
46281: CALL_OW 145
// end ;
46285: GO 46074
46287: POP
46288: POP
// end else
46289: GO 46433
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46291: LD_EXP 110
46295: PUSH
46296: LD_VAR 0 2
46300: ARRAY
46301: PPUSH
46302: LD_EXP 115
46306: PUSH
46307: LD_VAR 0 2
46311: ARRAY
46312: PUSH
46313: LD_INT 1
46315: ARRAY
46316: PUSH
46317: LD_INT 1
46319: ARRAY
46320: PPUSH
46321: LD_EXP 115
46325: PUSH
46326: LD_VAR 0 2
46330: ARRAY
46331: PUSH
46332: LD_INT 1
46334: ARRAY
46335: PUSH
46336: LD_INT 2
46338: ARRAY
46339: PPUSH
46340: LD_EXP 115
46344: PUSH
46345: LD_VAR 0 2
46349: ARRAY
46350: PUSH
46351: LD_INT 1
46353: ARRAY
46354: PUSH
46355: LD_INT 3
46357: ARRAY
46358: PPUSH
46359: LD_EXP 115
46363: PUSH
46364: LD_VAR 0 2
46368: ARRAY
46369: PUSH
46370: LD_INT 1
46372: ARRAY
46373: PUSH
46374: LD_INT 4
46376: ARRAY
46377: PPUSH
46378: CALL 76762 0 5
46382: NOT
46383: IFFALSE 46433
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46385: LD_ADDR_EXP 115
46389: PUSH
46390: LD_EXP 115
46394: PPUSH
46395: LD_VAR 0 2
46399: PPUSH
46400: LD_EXP 115
46404: PUSH
46405: LD_VAR 0 2
46409: ARRAY
46410: PPUSH
46411: LD_INT 1
46413: PPUSH
46414: LD_INT 1
46416: NEG
46417: PPUSH
46418: LD_INT 0
46420: PPUSH
46421: CALL 69429 0 4
46425: PPUSH
46426: CALL_OW 1
46430: ST_TO_ADDR
// continue ;
46431: GO 45309
// end ; end ; end ;
46433: GO 45309
46435: POP
46436: POP
// end ;
46437: LD_VAR 0 1
46441: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46442: LD_INT 0
46444: PPUSH
46445: PPUSH
46446: PPUSH
46447: PPUSH
46448: PPUSH
46449: PPUSH
// if not mc_bases then
46450: LD_EXP 110
46454: NOT
46455: IFFALSE 46459
// exit ;
46457: GO 46886
// for i = 1 to mc_bases do
46459: LD_ADDR_VAR 0 2
46463: PUSH
46464: DOUBLE
46465: LD_INT 1
46467: DEC
46468: ST_TO_ADDR
46469: LD_EXP 110
46473: PUSH
46474: FOR_TO
46475: IFFALSE 46884
// begin tmp := mc_build_upgrade [ i ] ;
46477: LD_ADDR_VAR 0 4
46481: PUSH
46482: LD_EXP 142
46486: PUSH
46487: LD_VAR 0 2
46491: ARRAY
46492: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46493: LD_ADDR_VAR 0 6
46497: PUSH
46498: LD_EXP 143
46502: PUSH
46503: LD_VAR 0 2
46507: ARRAY
46508: PPUSH
46509: LD_INT 2
46511: PUSH
46512: LD_INT 30
46514: PUSH
46515: LD_INT 6
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: PUSH
46522: LD_INT 30
46524: PUSH
46525: LD_INT 7
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: PPUSH
46537: CALL_OW 72
46541: ST_TO_ADDR
// if not tmp and not lab then
46542: LD_VAR 0 4
46546: NOT
46547: PUSH
46548: LD_VAR 0 6
46552: NOT
46553: AND
46554: IFFALSE 46558
// continue ;
46556: GO 46474
// if tmp then
46558: LD_VAR 0 4
46562: IFFALSE 46682
// for j in tmp do
46564: LD_ADDR_VAR 0 3
46568: PUSH
46569: LD_VAR 0 4
46573: PUSH
46574: FOR_IN
46575: IFFALSE 46680
// begin if UpgradeCost ( j ) then
46577: LD_VAR 0 3
46581: PPUSH
46582: CALL 76422 0 1
46586: IFFALSE 46678
// begin ComUpgrade ( j ) ;
46588: LD_VAR 0 3
46592: PPUSH
46593: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46597: LD_ADDR_EXP 142
46601: PUSH
46602: LD_EXP 142
46606: PPUSH
46607: LD_VAR 0 2
46611: PPUSH
46612: LD_EXP 142
46616: PUSH
46617: LD_VAR 0 2
46621: ARRAY
46622: PUSH
46623: LD_VAR 0 3
46627: DIFF
46628: PPUSH
46629: CALL_OW 1
46633: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46634: LD_ADDR_EXP 117
46638: PUSH
46639: LD_EXP 117
46643: PPUSH
46644: LD_VAR 0 2
46648: PUSH
46649: LD_EXP 117
46653: PUSH
46654: LD_VAR 0 2
46658: ARRAY
46659: PUSH
46660: LD_INT 1
46662: PLUS
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PPUSH
46668: LD_VAR 0 3
46672: PPUSH
46673: CALL 70011 0 3
46677: ST_TO_ADDR
// end ; end ;
46678: GO 46574
46680: POP
46681: POP
// if not lab or not mc_lab_upgrade [ i ] then
46682: LD_VAR 0 6
46686: NOT
46687: PUSH
46688: LD_EXP 144
46692: PUSH
46693: LD_VAR 0 2
46697: ARRAY
46698: NOT
46699: OR
46700: IFFALSE 46704
// continue ;
46702: GO 46474
// for j in lab do
46704: LD_ADDR_VAR 0 3
46708: PUSH
46709: LD_VAR 0 6
46713: PUSH
46714: FOR_IN
46715: IFFALSE 46880
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46717: LD_VAR 0 3
46721: PPUSH
46722: CALL_OW 266
46726: PUSH
46727: LD_INT 6
46729: PUSH
46730: LD_INT 7
46732: PUSH
46733: EMPTY
46734: LIST
46735: LIST
46736: IN
46737: PUSH
46738: LD_VAR 0 3
46742: PPUSH
46743: CALL_OW 461
46747: PUSH
46748: LD_INT 1
46750: NONEQUAL
46751: AND
46752: IFFALSE 46878
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46754: LD_VAR 0 3
46758: PPUSH
46759: LD_EXP 144
46763: PUSH
46764: LD_VAR 0 2
46768: ARRAY
46769: PUSH
46770: LD_INT 1
46772: ARRAY
46773: PPUSH
46774: CALL 76627 0 2
46778: IFFALSE 46878
// begin ComCancel ( j ) ;
46780: LD_VAR 0 3
46784: PPUSH
46785: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46789: LD_VAR 0 3
46793: PPUSH
46794: LD_EXP 144
46798: PUSH
46799: LD_VAR 0 2
46803: ARRAY
46804: PUSH
46805: LD_INT 1
46807: ARRAY
46808: PPUSH
46809: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46813: LD_VAR 0 3
46817: PUSH
46818: LD_EXP 117
46822: PUSH
46823: LD_VAR 0 2
46827: ARRAY
46828: IN
46829: NOT
46830: IFFALSE 46876
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46832: LD_ADDR_EXP 117
46836: PUSH
46837: LD_EXP 117
46841: PPUSH
46842: LD_VAR 0 2
46846: PUSH
46847: LD_EXP 117
46851: PUSH
46852: LD_VAR 0 2
46856: ARRAY
46857: PUSH
46858: LD_INT 1
46860: PLUS
46861: PUSH
46862: EMPTY
46863: LIST
46864: LIST
46865: PPUSH
46866: LD_VAR 0 3
46870: PPUSH
46871: CALL 70011 0 3
46875: ST_TO_ADDR
// break ;
46876: GO 46880
// end ; end ; end ;
46878: GO 46714
46880: POP
46881: POP
// end ;
46882: GO 46474
46884: POP
46885: POP
// end ;
46886: LD_VAR 0 1
46890: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46891: LD_INT 0
46893: PPUSH
46894: PPUSH
46895: PPUSH
46896: PPUSH
46897: PPUSH
46898: PPUSH
46899: PPUSH
46900: PPUSH
46901: PPUSH
// if not mc_bases then
46902: LD_EXP 110
46906: NOT
46907: IFFALSE 46911
// exit ;
46909: GO 47316
// for i = 1 to mc_bases do
46911: LD_ADDR_VAR 0 2
46915: PUSH
46916: DOUBLE
46917: LD_INT 1
46919: DEC
46920: ST_TO_ADDR
46921: LD_EXP 110
46925: PUSH
46926: FOR_TO
46927: IFFALSE 47314
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46929: LD_EXP 118
46933: PUSH
46934: LD_VAR 0 2
46938: ARRAY
46939: NOT
46940: PUSH
46941: LD_EXP 110
46945: PUSH
46946: LD_VAR 0 2
46950: ARRAY
46951: PPUSH
46952: LD_INT 30
46954: PUSH
46955: LD_INT 3
46957: PUSH
46958: EMPTY
46959: LIST
46960: LIST
46961: PPUSH
46962: CALL_OW 72
46966: NOT
46967: OR
46968: IFFALSE 46972
// continue ;
46970: GO 46926
// busy := false ;
46972: LD_ADDR_VAR 0 8
46976: PUSH
46977: LD_INT 0
46979: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46980: LD_ADDR_VAR 0 4
46984: PUSH
46985: LD_EXP 110
46989: PUSH
46990: LD_VAR 0 2
46994: ARRAY
46995: PPUSH
46996: LD_INT 30
46998: PUSH
46999: LD_INT 3
47001: PUSH
47002: EMPTY
47003: LIST
47004: LIST
47005: PPUSH
47006: CALL_OW 72
47010: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47011: LD_ADDR_VAR 0 6
47015: PUSH
47016: LD_EXP 118
47020: PUSH
47021: LD_VAR 0 2
47025: ARRAY
47026: PPUSH
47027: LD_INT 2
47029: PUSH
47030: LD_INT 30
47032: PUSH
47033: LD_INT 32
47035: PUSH
47036: EMPTY
47037: LIST
47038: LIST
47039: PUSH
47040: LD_INT 30
47042: PUSH
47043: LD_INT 33
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: PUSH
47050: EMPTY
47051: LIST
47052: LIST
47053: LIST
47054: PPUSH
47055: CALL_OW 72
47059: ST_TO_ADDR
// if not t then
47060: LD_VAR 0 6
47064: NOT
47065: IFFALSE 47069
// continue ;
47067: GO 46926
// for j in tmp do
47069: LD_ADDR_VAR 0 3
47073: PUSH
47074: LD_VAR 0 4
47078: PUSH
47079: FOR_IN
47080: IFFALSE 47110
// if not BuildingStatus ( j ) = bs_idle then
47082: LD_VAR 0 3
47086: PPUSH
47087: CALL_OW 461
47091: PUSH
47092: LD_INT 2
47094: EQUAL
47095: NOT
47096: IFFALSE 47108
// begin busy := true ;
47098: LD_ADDR_VAR 0 8
47102: PUSH
47103: LD_INT 1
47105: ST_TO_ADDR
// break ;
47106: GO 47110
// end ;
47108: GO 47079
47110: POP
47111: POP
// if busy then
47112: LD_VAR 0 8
47116: IFFALSE 47120
// continue ;
47118: GO 46926
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47120: LD_ADDR_VAR 0 7
47124: PUSH
47125: LD_VAR 0 6
47129: PPUSH
47130: LD_INT 35
47132: PUSH
47133: LD_INT 0
47135: PUSH
47136: EMPTY
47137: LIST
47138: LIST
47139: PPUSH
47140: CALL_OW 72
47144: ST_TO_ADDR
// if tw then
47145: LD_VAR 0 7
47149: IFFALSE 47226
// begin tw := tw [ 1 ] ;
47151: LD_ADDR_VAR 0 7
47155: PUSH
47156: LD_VAR 0 7
47160: PUSH
47161: LD_INT 1
47163: ARRAY
47164: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47165: LD_ADDR_VAR 0 9
47169: PUSH
47170: LD_VAR 0 7
47174: PPUSH
47175: LD_EXP 135
47179: PUSH
47180: LD_VAR 0 2
47184: ARRAY
47185: PPUSH
47186: CALL 74981 0 2
47190: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47191: LD_EXP 149
47195: PUSH
47196: LD_VAR 0 2
47200: ARRAY
47201: IFFALSE 47224
// if not weapon in mc_allowed_tower_weapons [ i ] then
47203: LD_VAR 0 9
47207: PUSH
47208: LD_EXP 149
47212: PUSH
47213: LD_VAR 0 2
47217: ARRAY
47218: IN
47219: NOT
47220: IFFALSE 47224
// continue ;
47222: GO 46926
// end else
47224: GO 47289
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47226: LD_ADDR_VAR 0 5
47230: PUSH
47231: LD_EXP 118
47235: PUSH
47236: LD_VAR 0 2
47240: ARRAY
47241: PPUSH
47242: LD_VAR 0 4
47246: PPUSH
47247: CALL 100483 0 2
47251: ST_TO_ADDR
// if not tmp2 then
47252: LD_VAR 0 5
47256: NOT
47257: IFFALSE 47261
// continue ;
47259: GO 46926
// tw := tmp2 [ 1 ] ;
47261: LD_ADDR_VAR 0 7
47265: PUSH
47266: LD_VAR 0 5
47270: PUSH
47271: LD_INT 1
47273: ARRAY
47274: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47275: LD_ADDR_VAR 0 9
47279: PUSH
47280: LD_VAR 0 5
47284: PUSH
47285: LD_INT 2
47287: ARRAY
47288: ST_TO_ADDR
// end ; if not weapon then
47289: LD_VAR 0 9
47293: NOT
47294: IFFALSE 47298
// continue ;
47296: GO 46926
// ComPlaceWeapon ( tw , weapon ) ;
47298: LD_VAR 0 7
47302: PPUSH
47303: LD_VAR 0 9
47307: PPUSH
47308: CALL_OW 148
// end ;
47312: GO 46926
47314: POP
47315: POP
// end ;
47316: LD_VAR 0 1
47320: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47321: LD_INT 0
47323: PPUSH
47324: PPUSH
47325: PPUSH
47326: PPUSH
47327: PPUSH
47328: PPUSH
// if not mc_bases then
47329: LD_EXP 110
47333: NOT
47334: IFFALSE 47338
// exit ;
47336: GO 48114
// for i = 1 to mc_bases do
47338: LD_ADDR_VAR 0 2
47342: PUSH
47343: DOUBLE
47344: LD_INT 1
47346: DEC
47347: ST_TO_ADDR
47348: LD_EXP 110
47352: PUSH
47353: FOR_TO
47354: IFFALSE 48112
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47356: LD_EXP 123
47360: PUSH
47361: LD_VAR 0 2
47365: ARRAY
47366: NOT
47367: PUSH
47368: LD_EXP 123
47372: PUSH
47373: LD_VAR 0 2
47377: ARRAY
47378: PUSH
47379: LD_EXP 124
47383: PUSH
47384: LD_VAR 0 2
47388: ARRAY
47389: EQUAL
47390: OR
47391: PUSH
47392: LD_EXP 133
47396: PUSH
47397: LD_VAR 0 2
47401: ARRAY
47402: OR
47403: IFFALSE 47407
// continue ;
47405: GO 47353
// if mc_miners [ i ] then
47407: LD_EXP 124
47411: PUSH
47412: LD_VAR 0 2
47416: ARRAY
47417: IFFALSE 47799
// begin for j = mc_miners [ i ] downto 1 do
47419: LD_ADDR_VAR 0 3
47423: PUSH
47424: DOUBLE
47425: LD_EXP 124
47429: PUSH
47430: LD_VAR 0 2
47434: ARRAY
47435: INC
47436: ST_TO_ADDR
47437: LD_INT 1
47439: PUSH
47440: FOR_DOWNTO
47441: IFFALSE 47797
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47443: LD_EXP 124
47447: PUSH
47448: LD_VAR 0 2
47452: ARRAY
47453: PUSH
47454: LD_VAR 0 3
47458: ARRAY
47459: PPUSH
47460: CALL_OW 301
47464: PUSH
47465: LD_EXP 124
47469: PUSH
47470: LD_VAR 0 2
47474: ARRAY
47475: PUSH
47476: LD_VAR 0 3
47480: ARRAY
47481: PPUSH
47482: CALL_OW 257
47486: PUSH
47487: LD_INT 1
47489: NONEQUAL
47490: OR
47491: IFFALSE 47554
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47493: LD_ADDR_VAR 0 5
47497: PUSH
47498: LD_EXP 124
47502: PUSH
47503: LD_VAR 0 2
47507: ARRAY
47508: PUSH
47509: LD_EXP 124
47513: PUSH
47514: LD_VAR 0 2
47518: ARRAY
47519: PUSH
47520: LD_VAR 0 3
47524: ARRAY
47525: DIFF
47526: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47527: LD_ADDR_EXP 124
47531: PUSH
47532: LD_EXP 124
47536: PPUSH
47537: LD_VAR 0 2
47541: PPUSH
47542: LD_VAR 0 5
47546: PPUSH
47547: CALL_OW 1
47551: ST_TO_ADDR
// continue ;
47552: GO 47440
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47554: LD_EXP 124
47558: PUSH
47559: LD_VAR 0 2
47563: ARRAY
47564: PUSH
47565: LD_VAR 0 3
47569: ARRAY
47570: PPUSH
47571: CALL_OW 257
47575: PUSH
47576: LD_INT 1
47578: EQUAL
47579: PUSH
47580: LD_EXP 124
47584: PUSH
47585: LD_VAR 0 2
47589: ARRAY
47590: PUSH
47591: LD_VAR 0 3
47595: ARRAY
47596: PPUSH
47597: CALL_OW 459
47601: NOT
47602: AND
47603: PUSH
47604: LD_EXP 124
47608: PUSH
47609: LD_VAR 0 2
47613: ARRAY
47614: PUSH
47615: LD_VAR 0 3
47619: ARRAY
47620: PPUSH
47621: CALL_OW 314
47625: NOT
47626: AND
47627: IFFALSE 47795
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47629: LD_EXP 124
47633: PUSH
47634: LD_VAR 0 2
47638: ARRAY
47639: PUSH
47640: LD_VAR 0 3
47644: ARRAY
47645: PPUSH
47646: CALL_OW 310
47650: IFFALSE 47673
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47652: LD_EXP 124
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: PUSH
47663: LD_VAR 0 3
47667: ARRAY
47668: PPUSH
47669: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47673: LD_EXP 124
47677: PUSH
47678: LD_VAR 0 2
47682: ARRAY
47683: PUSH
47684: LD_VAR 0 3
47688: ARRAY
47689: PPUSH
47690: CALL_OW 314
47694: NOT
47695: IFFALSE 47795
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47697: LD_EXP 124
47701: PUSH
47702: LD_VAR 0 2
47706: ARRAY
47707: PUSH
47708: LD_VAR 0 3
47712: ARRAY
47713: PPUSH
47714: LD_EXP 123
47718: PUSH
47719: LD_VAR 0 2
47723: ARRAY
47724: PUSH
47725: LD_VAR 0 3
47729: PUSH
47730: LD_EXP 123
47734: PUSH
47735: LD_VAR 0 2
47739: ARRAY
47740: MOD
47741: PUSH
47742: LD_INT 1
47744: PLUS
47745: ARRAY
47746: PUSH
47747: LD_INT 1
47749: ARRAY
47750: PPUSH
47751: LD_EXP 123
47755: PUSH
47756: LD_VAR 0 2
47760: ARRAY
47761: PUSH
47762: LD_VAR 0 3
47766: PUSH
47767: LD_EXP 123
47771: PUSH
47772: LD_VAR 0 2
47776: ARRAY
47777: MOD
47778: PUSH
47779: LD_INT 1
47781: PLUS
47782: ARRAY
47783: PUSH
47784: LD_INT 2
47786: ARRAY
47787: PPUSH
47788: LD_INT 0
47790: PPUSH
47791: CALL_OW 193
// end ; end ;
47795: GO 47440
47797: POP
47798: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47799: LD_ADDR_VAR 0 5
47803: PUSH
47804: LD_EXP 110
47808: PUSH
47809: LD_VAR 0 2
47813: ARRAY
47814: PPUSH
47815: LD_INT 2
47817: PUSH
47818: LD_INT 30
47820: PUSH
47821: LD_INT 4
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: LD_INT 30
47830: PUSH
47831: LD_INT 5
47833: PUSH
47834: EMPTY
47835: LIST
47836: LIST
47837: PUSH
47838: LD_INT 30
47840: PUSH
47841: LD_INT 32
47843: PUSH
47844: EMPTY
47845: LIST
47846: LIST
47847: PUSH
47848: EMPTY
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: PPUSH
47854: CALL_OW 72
47858: ST_TO_ADDR
// if not tmp then
47859: LD_VAR 0 5
47863: NOT
47864: IFFALSE 47868
// continue ;
47866: GO 47353
// list := [ ] ;
47868: LD_ADDR_VAR 0 6
47872: PUSH
47873: EMPTY
47874: ST_TO_ADDR
// for j in tmp do
47875: LD_ADDR_VAR 0 3
47879: PUSH
47880: LD_VAR 0 5
47884: PUSH
47885: FOR_IN
47886: IFFALSE 47955
// begin for k in UnitsInside ( j ) do
47888: LD_ADDR_VAR 0 4
47892: PUSH
47893: LD_VAR 0 3
47897: PPUSH
47898: CALL_OW 313
47902: PUSH
47903: FOR_IN
47904: IFFALSE 47951
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47906: LD_VAR 0 4
47910: PPUSH
47911: CALL_OW 257
47915: PUSH
47916: LD_INT 1
47918: EQUAL
47919: PUSH
47920: LD_VAR 0 4
47924: PPUSH
47925: CALL_OW 459
47929: NOT
47930: AND
47931: IFFALSE 47949
// list := list ^ k ;
47933: LD_ADDR_VAR 0 6
47937: PUSH
47938: LD_VAR 0 6
47942: PUSH
47943: LD_VAR 0 4
47947: ADD
47948: ST_TO_ADDR
47949: GO 47903
47951: POP
47952: POP
// end ;
47953: GO 47885
47955: POP
47956: POP
// list := list diff mc_miners [ i ] ;
47957: LD_ADDR_VAR 0 6
47961: PUSH
47962: LD_VAR 0 6
47966: PUSH
47967: LD_EXP 124
47971: PUSH
47972: LD_VAR 0 2
47976: ARRAY
47977: DIFF
47978: ST_TO_ADDR
// if not list then
47979: LD_VAR 0 6
47983: NOT
47984: IFFALSE 47988
// continue ;
47986: GO 47353
// k := mc_mines [ i ] - mc_miners [ i ] ;
47988: LD_ADDR_VAR 0 4
47992: PUSH
47993: LD_EXP 123
47997: PUSH
47998: LD_VAR 0 2
48002: ARRAY
48003: PUSH
48004: LD_EXP 124
48008: PUSH
48009: LD_VAR 0 2
48013: ARRAY
48014: MINUS
48015: ST_TO_ADDR
// if k > list then
48016: LD_VAR 0 4
48020: PUSH
48021: LD_VAR 0 6
48025: GREATER
48026: IFFALSE 48038
// k := list ;
48028: LD_ADDR_VAR 0 4
48032: PUSH
48033: LD_VAR 0 6
48037: ST_TO_ADDR
// for j = 1 to k do
48038: LD_ADDR_VAR 0 3
48042: PUSH
48043: DOUBLE
48044: LD_INT 1
48046: DEC
48047: ST_TO_ADDR
48048: LD_VAR 0 4
48052: PUSH
48053: FOR_TO
48054: IFFALSE 48108
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48056: LD_ADDR_EXP 124
48060: PUSH
48061: LD_EXP 124
48065: PPUSH
48066: LD_VAR 0 2
48070: PUSH
48071: LD_EXP 124
48075: PUSH
48076: LD_VAR 0 2
48080: ARRAY
48081: PUSH
48082: LD_INT 1
48084: PLUS
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: PPUSH
48090: LD_VAR 0 6
48094: PUSH
48095: LD_VAR 0 3
48099: ARRAY
48100: PPUSH
48101: CALL 70011 0 3
48105: ST_TO_ADDR
48106: GO 48053
48108: POP
48109: POP
// end ;
48110: GO 47353
48112: POP
48113: POP
// end ;
48114: LD_VAR 0 1
48118: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48119: LD_INT 0
48121: PPUSH
48122: PPUSH
48123: PPUSH
48124: PPUSH
48125: PPUSH
48126: PPUSH
48127: PPUSH
48128: PPUSH
48129: PPUSH
48130: PPUSH
// if not mc_bases then
48131: LD_EXP 110
48135: NOT
48136: IFFALSE 48140
// exit ;
48138: GO 49890
// for i = 1 to mc_bases do
48140: LD_ADDR_VAR 0 2
48144: PUSH
48145: DOUBLE
48146: LD_INT 1
48148: DEC
48149: ST_TO_ADDR
48150: LD_EXP 110
48154: PUSH
48155: FOR_TO
48156: IFFALSE 49888
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48158: LD_EXP 110
48162: PUSH
48163: LD_VAR 0 2
48167: ARRAY
48168: NOT
48169: PUSH
48170: LD_EXP 117
48174: PUSH
48175: LD_VAR 0 2
48179: ARRAY
48180: OR
48181: IFFALSE 48185
// continue ;
48183: GO 48155
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48185: LD_EXP 126
48189: PUSH
48190: LD_VAR 0 2
48194: ARRAY
48195: NOT
48196: PUSH
48197: LD_EXP 127
48201: PUSH
48202: LD_VAR 0 2
48206: ARRAY
48207: AND
48208: IFFALSE 48246
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48210: LD_ADDR_EXP 127
48214: PUSH
48215: LD_EXP 127
48219: PPUSH
48220: LD_VAR 0 2
48224: PPUSH
48225: EMPTY
48226: PPUSH
48227: CALL_OW 1
48231: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48232: LD_VAR 0 2
48236: PPUSH
48237: LD_INT 107
48239: PPUSH
48240: CALL 39120 0 2
// continue ;
48244: GO 48155
// end ; target := [ ] ;
48246: LD_ADDR_VAR 0 6
48250: PUSH
48251: EMPTY
48252: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48253: LD_ADDR_VAR 0 3
48257: PUSH
48258: DOUBLE
48259: LD_EXP 126
48263: PUSH
48264: LD_VAR 0 2
48268: ARRAY
48269: INC
48270: ST_TO_ADDR
48271: LD_INT 1
48273: PUSH
48274: FOR_DOWNTO
48275: IFFALSE 48535
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48277: LD_EXP 126
48281: PUSH
48282: LD_VAR 0 2
48286: ARRAY
48287: PUSH
48288: LD_VAR 0 3
48292: ARRAY
48293: PUSH
48294: LD_INT 2
48296: ARRAY
48297: PPUSH
48298: LD_EXP 126
48302: PUSH
48303: LD_VAR 0 2
48307: ARRAY
48308: PUSH
48309: LD_VAR 0 3
48313: ARRAY
48314: PUSH
48315: LD_INT 3
48317: ARRAY
48318: PPUSH
48319: CALL_OW 488
48323: PUSH
48324: LD_EXP 126
48328: PUSH
48329: LD_VAR 0 2
48333: ARRAY
48334: PUSH
48335: LD_VAR 0 3
48339: ARRAY
48340: PUSH
48341: LD_INT 2
48343: ARRAY
48344: PPUSH
48345: LD_EXP 126
48349: PUSH
48350: LD_VAR 0 2
48354: ARRAY
48355: PUSH
48356: LD_VAR 0 3
48360: ARRAY
48361: PUSH
48362: LD_INT 3
48364: ARRAY
48365: PPUSH
48366: CALL_OW 284
48370: PUSH
48371: LD_INT 0
48373: EQUAL
48374: AND
48375: IFFALSE 48430
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48377: LD_ADDR_VAR 0 5
48381: PUSH
48382: LD_EXP 126
48386: PUSH
48387: LD_VAR 0 2
48391: ARRAY
48392: PPUSH
48393: LD_VAR 0 3
48397: PPUSH
48398: CALL_OW 3
48402: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48403: LD_ADDR_EXP 126
48407: PUSH
48408: LD_EXP 126
48412: PPUSH
48413: LD_VAR 0 2
48417: PPUSH
48418: LD_VAR 0 5
48422: PPUSH
48423: CALL_OW 1
48427: ST_TO_ADDR
// continue ;
48428: GO 48274
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48430: LD_EXP 110
48434: PUSH
48435: LD_VAR 0 2
48439: ARRAY
48440: PUSH
48441: LD_INT 1
48443: ARRAY
48444: PPUSH
48445: CALL_OW 255
48449: PPUSH
48450: LD_EXP 126
48454: PUSH
48455: LD_VAR 0 2
48459: ARRAY
48460: PUSH
48461: LD_VAR 0 3
48465: ARRAY
48466: PUSH
48467: LD_INT 2
48469: ARRAY
48470: PPUSH
48471: LD_EXP 126
48475: PUSH
48476: LD_VAR 0 2
48480: ARRAY
48481: PUSH
48482: LD_VAR 0 3
48486: ARRAY
48487: PUSH
48488: LD_INT 3
48490: ARRAY
48491: PPUSH
48492: LD_INT 30
48494: PPUSH
48495: CALL 70907 0 4
48499: PUSH
48500: LD_INT 4
48502: ARRAY
48503: PUSH
48504: LD_INT 0
48506: EQUAL
48507: IFFALSE 48533
// begin target := mc_crates [ i ] [ j ] ;
48509: LD_ADDR_VAR 0 6
48513: PUSH
48514: LD_EXP 126
48518: PUSH
48519: LD_VAR 0 2
48523: ARRAY
48524: PUSH
48525: LD_VAR 0 3
48529: ARRAY
48530: ST_TO_ADDR
// break ;
48531: GO 48535
// end ; end ;
48533: GO 48274
48535: POP
48536: POP
// if not target then
48537: LD_VAR 0 6
48541: NOT
48542: IFFALSE 48546
// continue ;
48544: GO 48155
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48546: LD_ADDR_VAR 0 7
48550: PUSH
48551: LD_EXP 129
48555: PUSH
48556: LD_VAR 0 2
48560: ARRAY
48561: PPUSH
48562: LD_INT 2
48564: PUSH
48565: LD_INT 3
48567: PUSH
48568: LD_INT 58
48570: PUSH
48571: EMPTY
48572: LIST
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 61
48580: PUSH
48581: EMPTY
48582: LIST
48583: PUSH
48584: LD_INT 33
48586: PUSH
48587: LD_INT 5
48589: PUSH
48590: EMPTY
48591: LIST
48592: LIST
48593: PUSH
48594: LD_INT 33
48596: PUSH
48597: LD_INT 3
48599: PUSH
48600: EMPTY
48601: LIST
48602: LIST
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: LIST
48608: LIST
48609: LIST
48610: PUSH
48611: LD_INT 2
48613: PUSH
48614: LD_INT 34
48616: PUSH
48617: LD_INT 32
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: PUSH
48624: LD_INT 34
48626: PUSH
48627: LD_INT 51
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: PUSH
48634: LD_INT 34
48636: PUSH
48637: LD_INT 12
48639: PUSH
48640: EMPTY
48641: LIST
48642: LIST
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: PPUSH
48654: CALL_OW 72
48658: ST_TO_ADDR
// if not cargo then
48659: LD_VAR 0 7
48663: NOT
48664: IFFALSE 49307
// begin if mc_crates_collector [ i ] < 5 then
48666: LD_EXP 127
48670: PUSH
48671: LD_VAR 0 2
48675: ARRAY
48676: PUSH
48677: LD_INT 5
48679: LESS
48680: IFFALSE 49046
// begin if mc_ape [ i ] then
48682: LD_EXP 139
48686: PUSH
48687: LD_VAR 0 2
48691: ARRAY
48692: IFFALSE 48739
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48694: LD_ADDR_VAR 0 5
48698: PUSH
48699: LD_EXP 139
48703: PUSH
48704: LD_VAR 0 2
48708: ARRAY
48709: PPUSH
48710: LD_INT 25
48712: PUSH
48713: LD_INT 16
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: PUSH
48720: LD_INT 24
48722: PUSH
48723: LD_INT 750
48725: PUSH
48726: EMPTY
48727: LIST
48728: LIST
48729: PUSH
48730: EMPTY
48731: LIST
48732: LIST
48733: PPUSH
48734: CALL_OW 72
48738: ST_TO_ADDR
// if not tmp then
48739: LD_VAR 0 5
48743: NOT
48744: IFFALSE 48791
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48746: LD_ADDR_VAR 0 5
48750: PUSH
48751: LD_EXP 110
48755: PUSH
48756: LD_VAR 0 2
48760: ARRAY
48761: PPUSH
48762: LD_INT 25
48764: PUSH
48765: LD_INT 2
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PUSH
48772: LD_INT 24
48774: PUSH
48775: LD_INT 750
48777: PUSH
48778: EMPTY
48779: LIST
48780: LIST
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PPUSH
48786: CALL_OW 72
48790: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48791: LD_EXP 139
48795: PUSH
48796: LD_VAR 0 2
48800: ARRAY
48801: PUSH
48802: LD_EXP 110
48806: PUSH
48807: LD_VAR 0 2
48811: ARRAY
48812: PPUSH
48813: LD_INT 25
48815: PUSH
48816: LD_INT 2
48818: PUSH
48819: EMPTY
48820: LIST
48821: LIST
48822: PUSH
48823: LD_INT 24
48825: PUSH
48826: LD_INT 750
48828: PUSH
48829: EMPTY
48830: LIST
48831: LIST
48832: PUSH
48833: EMPTY
48834: LIST
48835: LIST
48836: PPUSH
48837: CALL_OW 72
48841: AND
48842: PUSH
48843: LD_VAR 0 5
48847: PUSH
48848: LD_INT 5
48850: LESS
48851: AND
48852: IFFALSE 48934
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48854: LD_ADDR_VAR 0 3
48858: PUSH
48859: LD_EXP 110
48863: PUSH
48864: LD_VAR 0 2
48868: ARRAY
48869: PPUSH
48870: LD_INT 25
48872: PUSH
48873: LD_INT 2
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 24
48882: PUSH
48883: LD_INT 750
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: EMPTY
48891: LIST
48892: LIST
48893: PPUSH
48894: CALL_OW 72
48898: PUSH
48899: FOR_IN
48900: IFFALSE 48932
// begin tmp := tmp union j ;
48902: LD_ADDR_VAR 0 5
48906: PUSH
48907: LD_VAR 0 5
48911: PUSH
48912: LD_VAR 0 3
48916: UNION
48917: ST_TO_ADDR
// if tmp >= 5 then
48918: LD_VAR 0 5
48922: PUSH
48923: LD_INT 5
48925: GREATEREQUAL
48926: IFFALSE 48930
// break ;
48928: GO 48932
// end ;
48930: GO 48899
48932: POP
48933: POP
// end ; if not tmp then
48934: LD_VAR 0 5
48938: NOT
48939: IFFALSE 48943
// continue ;
48941: GO 48155
// for j in tmp do
48943: LD_ADDR_VAR 0 3
48947: PUSH
48948: LD_VAR 0 5
48952: PUSH
48953: FOR_IN
48954: IFFALSE 49044
// if not GetTag ( j ) then
48956: LD_VAR 0 3
48960: PPUSH
48961: CALL_OW 110
48965: NOT
48966: IFFALSE 49042
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48968: LD_ADDR_EXP 127
48972: PUSH
48973: LD_EXP 127
48977: PPUSH
48978: LD_VAR 0 2
48982: PUSH
48983: LD_EXP 127
48987: PUSH
48988: LD_VAR 0 2
48992: ARRAY
48993: PUSH
48994: LD_INT 1
48996: PLUS
48997: PUSH
48998: EMPTY
48999: LIST
49000: LIST
49001: PPUSH
49002: LD_VAR 0 3
49006: PPUSH
49007: CALL 70011 0 3
49011: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49012: LD_VAR 0 3
49016: PPUSH
49017: LD_INT 107
49019: PPUSH
49020: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49024: LD_EXP 127
49028: PUSH
49029: LD_VAR 0 2
49033: ARRAY
49034: PUSH
49035: LD_INT 5
49037: GREATEREQUAL
49038: IFFALSE 49042
// break ;
49040: GO 49044
// end ;
49042: GO 48953
49044: POP
49045: POP
// end ; if mc_crates_collector [ i ] and target then
49046: LD_EXP 127
49050: PUSH
49051: LD_VAR 0 2
49055: ARRAY
49056: PUSH
49057: LD_VAR 0 6
49061: AND
49062: IFFALSE 49305
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49064: LD_EXP 127
49068: PUSH
49069: LD_VAR 0 2
49073: ARRAY
49074: PUSH
49075: LD_VAR 0 6
49079: PUSH
49080: LD_INT 1
49082: ARRAY
49083: LESS
49084: IFFALSE 49104
// tmp := mc_crates_collector [ i ] else
49086: LD_ADDR_VAR 0 5
49090: PUSH
49091: LD_EXP 127
49095: PUSH
49096: LD_VAR 0 2
49100: ARRAY
49101: ST_TO_ADDR
49102: GO 49118
// tmp := target [ 1 ] ;
49104: LD_ADDR_VAR 0 5
49108: PUSH
49109: LD_VAR 0 6
49113: PUSH
49114: LD_INT 1
49116: ARRAY
49117: ST_TO_ADDR
// k := 0 ;
49118: LD_ADDR_VAR 0 4
49122: PUSH
49123: LD_INT 0
49125: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49126: LD_ADDR_VAR 0 3
49130: PUSH
49131: LD_EXP 127
49135: PUSH
49136: LD_VAR 0 2
49140: ARRAY
49141: PUSH
49142: FOR_IN
49143: IFFALSE 49303
// begin k := k + 1 ;
49145: LD_ADDR_VAR 0 4
49149: PUSH
49150: LD_VAR 0 4
49154: PUSH
49155: LD_INT 1
49157: PLUS
49158: ST_TO_ADDR
// if k > tmp then
49159: LD_VAR 0 4
49163: PUSH
49164: LD_VAR 0 5
49168: GREATER
49169: IFFALSE 49173
// break ;
49171: GO 49303
// if not GetClass ( j ) in [ 2 , 16 ] then
49173: LD_VAR 0 3
49177: PPUSH
49178: CALL_OW 257
49182: PUSH
49183: LD_INT 2
49185: PUSH
49186: LD_INT 16
49188: PUSH
49189: EMPTY
49190: LIST
49191: LIST
49192: IN
49193: NOT
49194: IFFALSE 49247
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49196: LD_ADDR_EXP 127
49200: PUSH
49201: LD_EXP 127
49205: PPUSH
49206: LD_VAR 0 2
49210: PPUSH
49211: LD_EXP 127
49215: PUSH
49216: LD_VAR 0 2
49220: ARRAY
49221: PUSH
49222: LD_VAR 0 3
49226: DIFF
49227: PPUSH
49228: CALL_OW 1
49232: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49233: LD_VAR 0 3
49237: PPUSH
49238: LD_INT 0
49240: PPUSH
49241: CALL_OW 109
// continue ;
49245: GO 49142
// end ; if IsInUnit ( j ) then
49247: LD_VAR 0 3
49251: PPUSH
49252: CALL_OW 310
49256: IFFALSE 49267
// ComExitBuilding ( j ) ;
49258: LD_VAR 0 3
49262: PPUSH
49263: CALL_OW 122
// wait ( 3 ) ;
49267: LD_INT 3
49269: PPUSH
49270: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49274: LD_VAR 0 3
49278: PPUSH
49279: LD_VAR 0 6
49283: PUSH
49284: LD_INT 2
49286: ARRAY
49287: PPUSH
49288: LD_VAR 0 6
49292: PUSH
49293: LD_INT 3
49295: ARRAY
49296: PPUSH
49297: CALL_OW 117
// end ;
49301: GO 49142
49303: POP
49304: POP
// end ; end else
49305: GO 49886
// begin for j in cargo do
49307: LD_ADDR_VAR 0 3
49311: PUSH
49312: LD_VAR 0 7
49316: PUSH
49317: FOR_IN
49318: IFFALSE 49884
// begin if GetTag ( j ) <> 0 then
49320: LD_VAR 0 3
49324: PPUSH
49325: CALL_OW 110
49329: PUSH
49330: LD_INT 0
49332: NONEQUAL
49333: IFFALSE 49337
// continue ;
49335: GO 49317
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49337: LD_VAR 0 3
49341: PPUSH
49342: CALL_OW 256
49346: PUSH
49347: LD_INT 1000
49349: LESS
49350: PUSH
49351: LD_VAR 0 3
49355: PPUSH
49356: LD_EXP 134
49360: PUSH
49361: LD_VAR 0 2
49365: ARRAY
49366: PPUSH
49367: CALL_OW 308
49371: NOT
49372: AND
49373: IFFALSE 49395
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49375: LD_VAR 0 3
49379: PPUSH
49380: LD_EXP 134
49384: PUSH
49385: LD_VAR 0 2
49389: ARRAY
49390: PPUSH
49391: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49395: LD_VAR 0 3
49399: PPUSH
49400: CALL_OW 256
49404: PUSH
49405: LD_INT 1000
49407: LESS
49408: PUSH
49409: LD_VAR 0 3
49413: PPUSH
49414: LD_EXP 134
49418: PUSH
49419: LD_VAR 0 2
49423: ARRAY
49424: PPUSH
49425: CALL_OW 308
49429: AND
49430: IFFALSE 49434
// continue ;
49432: GO 49317
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49434: LD_VAR 0 3
49438: PPUSH
49439: CALL_OW 262
49443: PUSH
49444: LD_INT 2
49446: EQUAL
49447: PUSH
49448: LD_VAR 0 3
49452: PPUSH
49453: CALL_OW 261
49457: PUSH
49458: LD_INT 15
49460: LESS
49461: AND
49462: IFFALSE 49466
// continue ;
49464: GO 49317
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49466: LD_VAR 0 3
49470: PPUSH
49471: CALL_OW 262
49475: PUSH
49476: LD_INT 1
49478: EQUAL
49479: PUSH
49480: LD_VAR 0 3
49484: PPUSH
49485: CALL_OW 261
49489: PUSH
49490: LD_INT 10
49492: LESS
49493: AND
49494: IFFALSE 49823
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49496: LD_ADDR_VAR 0 8
49500: PUSH
49501: LD_EXP 110
49505: PUSH
49506: LD_VAR 0 2
49510: ARRAY
49511: PPUSH
49512: LD_INT 2
49514: PUSH
49515: LD_INT 30
49517: PUSH
49518: LD_INT 0
49520: PUSH
49521: EMPTY
49522: LIST
49523: LIST
49524: PUSH
49525: LD_INT 30
49527: PUSH
49528: LD_INT 1
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: PUSH
49535: EMPTY
49536: LIST
49537: LIST
49538: LIST
49539: PPUSH
49540: CALL_OW 72
49544: ST_TO_ADDR
// if not depot then
49545: LD_VAR 0 8
49549: NOT
49550: IFFALSE 49554
// continue ;
49552: GO 49317
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49554: LD_VAR 0 3
49558: PPUSH
49559: LD_VAR 0 8
49563: PPUSH
49564: LD_VAR 0 3
49568: PPUSH
49569: CALL_OW 74
49573: PPUSH
49574: CALL_OW 296
49578: PUSH
49579: LD_INT 6
49581: LESS
49582: IFFALSE 49598
// SetFuel ( j , 100 ) else
49584: LD_VAR 0 3
49588: PPUSH
49589: LD_INT 100
49591: PPUSH
49592: CALL_OW 240
49596: GO 49823
// if GetFuel ( j ) = 0 then
49598: LD_VAR 0 3
49602: PPUSH
49603: CALL_OW 261
49607: PUSH
49608: LD_INT 0
49610: EQUAL
49611: IFFALSE 49823
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49613: LD_ADDR_EXP 129
49617: PUSH
49618: LD_EXP 129
49622: PPUSH
49623: LD_VAR 0 2
49627: PPUSH
49628: LD_EXP 129
49632: PUSH
49633: LD_VAR 0 2
49637: ARRAY
49638: PUSH
49639: LD_VAR 0 3
49643: DIFF
49644: PPUSH
49645: CALL_OW 1
49649: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49650: LD_VAR 0 3
49654: PPUSH
49655: CALL_OW 263
49659: PUSH
49660: LD_INT 1
49662: EQUAL
49663: IFFALSE 49679
// ComExitVehicle ( IsInUnit ( j ) ) ;
49665: LD_VAR 0 3
49669: PPUSH
49670: CALL_OW 310
49674: PPUSH
49675: CALL_OW 121
// if GetControl ( j ) = control_remote then
49679: LD_VAR 0 3
49683: PPUSH
49684: CALL_OW 263
49688: PUSH
49689: LD_INT 2
49691: EQUAL
49692: IFFALSE 49703
// ComUnlink ( j ) ;
49694: LD_VAR 0 3
49698: PPUSH
49699: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49703: LD_ADDR_VAR 0 9
49707: PUSH
49708: LD_VAR 0 2
49712: PPUSH
49713: LD_INT 3
49715: PPUSH
49716: CALL 59176 0 2
49720: ST_TO_ADDR
// if fac then
49721: LD_VAR 0 9
49725: IFFALSE 49821
// begin for k in fac do
49727: LD_ADDR_VAR 0 4
49731: PUSH
49732: LD_VAR 0 9
49736: PUSH
49737: FOR_IN
49738: IFFALSE 49819
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49740: LD_ADDR_VAR 0 10
49744: PUSH
49745: LD_VAR 0 9
49749: PPUSH
49750: LD_VAR 0 3
49754: PPUSH
49755: CALL_OW 265
49759: PPUSH
49760: LD_VAR 0 3
49764: PPUSH
49765: CALL_OW 262
49769: PPUSH
49770: LD_VAR 0 3
49774: PPUSH
49775: CALL_OW 263
49779: PPUSH
49780: LD_VAR 0 3
49784: PPUSH
49785: CALL_OW 264
49789: PPUSH
49790: CALL 67543 0 5
49794: ST_TO_ADDR
// if components then
49795: LD_VAR 0 10
49799: IFFALSE 49817
// begin MC_InsertProduceList ( i , components ) ;
49801: LD_VAR 0 2
49805: PPUSH
49806: LD_VAR 0 10
49810: PPUSH
49811: CALL 58721 0 2
// break ;
49815: GO 49819
// end ; end ;
49817: GO 49737
49819: POP
49820: POP
// end ; continue ;
49821: GO 49317
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49823: LD_VAR 0 3
49827: PPUSH
49828: LD_INT 1
49830: PPUSH
49831: CALL_OW 289
49835: PUSH
49836: LD_INT 100
49838: LESS
49839: PUSH
49840: LD_VAR 0 3
49844: PPUSH
49845: CALL_OW 314
49849: NOT
49850: AND
49851: IFFALSE 49880
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49853: LD_VAR 0 3
49857: PPUSH
49858: LD_VAR 0 6
49862: PUSH
49863: LD_INT 2
49865: ARRAY
49866: PPUSH
49867: LD_VAR 0 6
49871: PUSH
49872: LD_INT 3
49874: ARRAY
49875: PPUSH
49876: CALL_OW 117
// break ;
49880: GO 49884
// end ;
49882: GO 49317
49884: POP
49885: POP
// end ; end ;
49886: GO 48155
49888: POP
49889: POP
// end ;
49890: LD_VAR 0 1
49894: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49895: LD_INT 0
49897: PPUSH
49898: PPUSH
49899: PPUSH
49900: PPUSH
// if not mc_bases then
49901: LD_EXP 110
49905: NOT
49906: IFFALSE 49910
// exit ;
49908: GO 50071
// for i = 1 to mc_bases do
49910: LD_ADDR_VAR 0 2
49914: PUSH
49915: DOUBLE
49916: LD_INT 1
49918: DEC
49919: ST_TO_ADDR
49920: LD_EXP 110
49924: PUSH
49925: FOR_TO
49926: IFFALSE 50069
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49928: LD_ADDR_VAR 0 4
49932: PUSH
49933: LD_EXP 129
49937: PUSH
49938: LD_VAR 0 2
49942: ARRAY
49943: PUSH
49944: LD_EXP 132
49948: PUSH
49949: LD_VAR 0 2
49953: ARRAY
49954: UNION
49955: PPUSH
49956: LD_INT 33
49958: PUSH
49959: LD_INT 2
49961: PUSH
49962: EMPTY
49963: LIST
49964: LIST
49965: PPUSH
49966: CALL_OW 72
49970: ST_TO_ADDR
// if tmp then
49971: LD_VAR 0 4
49975: IFFALSE 50067
// for j in tmp do
49977: LD_ADDR_VAR 0 3
49981: PUSH
49982: LD_VAR 0 4
49986: PUSH
49987: FOR_IN
49988: IFFALSE 50065
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49990: LD_VAR 0 3
49994: PPUSH
49995: CALL_OW 312
49999: NOT
50000: PUSH
50001: LD_VAR 0 3
50005: PPUSH
50006: CALL_OW 256
50010: PUSH
50011: LD_INT 250
50013: GREATEREQUAL
50014: AND
50015: IFFALSE 50028
// Connect ( j ) else
50017: LD_VAR 0 3
50021: PPUSH
50022: CALL 72944 0 1
50026: GO 50063
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50028: LD_VAR 0 3
50032: PPUSH
50033: CALL_OW 256
50037: PUSH
50038: LD_INT 250
50040: LESS
50041: PUSH
50042: LD_VAR 0 3
50046: PPUSH
50047: CALL_OW 312
50051: AND
50052: IFFALSE 50063
// ComUnlink ( j ) ;
50054: LD_VAR 0 3
50058: PPUSH
50059: CALL_OW 136
50063: GO 49987
50065: POP
50066: POP
// end ;
50067: GO 49925
50069: POP
50070: POP
// end ;
50071: LD_VAR 0 1
50075: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50076: LD_INT 0
50078: PPUSH
50079: PPUSH
50080: PPUSH
50081: PPUSH
50082: PPUSH
// if not mc_bases then
50083: LD_EXP 110
50087: NOT
50088: IFFALSE 50092
// exit ;
50090: GO 50537
// for i = 1 to mc_bases do
50092: LD_ADDR_VAR 0 2
50096: PUSH
50097: DOUBLE
50098: LD_INT 1
50100: DEC
50101: ST_TO_ADDR
50102: LD_EXP 110
50106: PUSH
50107: FOR_TO
50108: IFFALSE 50535
// begin if not mc_produce [ i ] then
50110: LD_EXP 131
50114: PUSH
50115: LD_VAR 0 2
50119: ARRAY
50120: NOT
50121: IFFALSE 50125
// continue ;
50123: GO 50107
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50125: LD_ADDR_VAR 0 5
50129: PUSH
50130: LD_EXP 110
50134: PUSH
50135: LD_VAR 0 2
50139: ARRAY
50140: PPUSH
50141: LD_INT 30
50143: PUSH
50144: LD_INT 3
50146: PUSH
50147: EMPTY
50148: LIST
50149: LIST
50150: PPUSH
50151: CALL_OW 72
50155: ST_TO_ADDR
// if not fac then
50156: LD_VAR 0 5
50160: NOT
50161: IFFALSE 50165
// continue ;
50163: GO 50107
// for j in fac do
50165: LD_ADDR_VAR 0 3
50169: PUSH
50170: LD_VAR 0 5
50174: PUSH
50175: FOR_IN
50176: IFFALSE 50531
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50178: LD_VAR 0 3
50182: PPUSH
50183: CALL_OW 461
50187: PUSH
50188: LD_INT 2
50190: NONEQUAL
50191: PUSH
50192: LD_VAR 0 3
50196: PPUSH
50197: LD_INT 15
50199: PPUSH
50200: CALL 72604 0 2
50204: PUSH
50205: LD_INT 4
50207: ARRAY
50208: OR
50209: IFFALSE 50213
// continue ;
50211: GO 50175
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50213: LD_VAR 0 3
50217: PPUSH
50218: LD_EXP 131
50222: PUSH
50223: LD_VAR 0 2
50227: ARRAY
50228: PUSH
50229: LD_INT 1
50231: ARRAY
50232: PUSH
50233: LD_INT 1
50235: ARRAY
50236: PPUSH
50237: LD_EXP 131
50241: PUSH
50242: LD_VAR 0 2
50246: ARRAY
50247: PUSH
50248: LD_INT 1
50250: ARRAY
50251: PUSH
50252: LD_INT 2
50254: ARRAY
50255: PPUSH
50256: LD_EXP 131
50260: PUSH
50261: LD_VAR 0 2
50265: ARRAY
50266: PUSH
50267: LD_INT 1
50269: ARRAY
50270: PUSH
50271: LD_INT 3
50273: ARRAY
50274: PPUSH
50275: LD_EXP 131
50279: PUSH
50280: LD_VAR 0 2
50284: ARRAY
50285: PUSH
50286: LD_INT 1
50288: ARRAY
50289: PUSH
50290: LD_INT 4
50292: ARRAY
50293: PPUSH
50294: CALL_OW 448
50298: PUSH
50299: LD_VAR 0 3
50303: PPUSH
50304: LD_EXP 131
50308: PUSH
50309: LD_VAR 0 2
50313: ARRAY
50314: PUSH
50315: LD_INT 1
50317: ARRAY
50318: PUSH
50319: LD_INT 1
50321: ARRAY
50322: PUSH
50323: LD_EXP 131
50327: PUSH
50328: LD_VAR 0 2
50332: ARRAY
50333: PUSH
50334: LD_INT 1
50336: ARRAY
50337: PUSH
50338: LD_INT 2
50340: ARRAY
50341: PUSH
50342: LD_EXP 131
50346: PUSH
50347: LD_VAR 0 2
50351: ARRAY
50352: PUSH
50353: LD_INT 1
50355: ARRAY
50356: PUSH
50357: LD_INT 3
50359: ARRAY
50360: PUSH
50361: LD_EXP 131
50365: PUSH
50366: LD_VAR 0 2
50370: ARRAY
50371: PUSH
50372: LD_INT 1
50374: ARRAY
50375: PUSH
50376: LD_INT 4
50378: ARRAY
50379: PUSH
50380: EMPTY
50381: LIST
50382: LIST
50383: LIST
50384: LIST
50385: PPUSH
50386: CALL 76275 0 2
50390: AND
50391: IFFALSE 50529
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50393: LD_VAR 0 3
50397: PPUSH
50398: LD_EXP 131
50402: PUSH
50403: LD_VAR 0 2
50407: ARRAY
50408: PUSH
50409: LD_INT 1
50411: ARRAY
50412: PUSH
50413: LD_INT 1
50415: ARRAY
50416: PPUSH
50417: LD_EXP 131
50421: PUSH
50422: LD_VAR 0 2
50426: ARRAY
50427: PUSH
50428: LD_INT 1
50430: ARRAY
50431: PUSH
50432: LD_INT 2
50434: ARRAY
50435: PPUSH
50436: LD_EXP 131
50440: PUSH
50441: LD_VAR 0 2
50445: ARRAY
50446: PUSH
50447: LD_INT 1
50449: ARRAY
50450: PUSH
50451: LD_INT 3
50453: ARRAY
50454: PPUSH
50455: LD_EXP 131
50459: PUSH
50460: LD_VAR 0 2
50464: ARRAY
50465: PUSH
50466: LD_INT 1
50468: ARRAY
50469: PUSH
50470: LD_INT 4
50472: ARRAY
50473: PPUSH
50474: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50478: LD_ADDR_VAR 0 4
50482: PUSH
50483: LD_EXP 131
50487: PUSH
50488: LD_VAR 0 2
50492: ARRAY
50493: PPUSH
50494: LD_INT 1
50496: PPUSH
50497: CALL_OW 3
50501: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50502: LD_ADDR_EXP 131
50506: PUSH
50507: LD_EXP 131
50511: PPUSH
50512: LD_VAR 0 2
50516: PPUSH
50517: LD_VAR 0 4
50521: PPUSH
50522: CALL_OW 1
50526: ST_TO_ADDR
// break ;
50527: GO 50531
// end ; end ;
50529: GO 50175
50531: POP
50532: POP
// end ;
50533: GO 50107
50535: POP
50536: POP
// end ;
50537: LD_VAR 0 1
50541: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50542: LD_INT 0
50544: PPUSH
50545: PPUSH
50546: PPUSH
// if not mc_bases then
50547: LD_EXP 110
50551: NOT
50552: IFFALSE 50556
// exit ;
50554: GO 50645
// for i = 1 to mc_bases do
50556: LD_ADDR_VAR 0 2
50560: PUSH
50561: DOUBLE
50562: LD_INT 1
50564: DEC
50565: ST_TO_ADDR
50566: LD_EXP 110
50570: PUSH
50571: FOR_TO
50572: IFFALSE 50643
// begin if mc_attack [ i ] then
50574: LD_EXP 130
50578: PUSH
50579: LD_VAR 0 2
50583: ARRAY
50584: IFFALSE 50641
// begin tmp := mc_attack [ i ] [ 1 ] ;
50586: LD_ADDR_VAR 0 3
50590: PUSH
50591: LD_EXP 130
50595: PUSH
50596: LD_VAR 0 2
50600: ARRAY
50601: PUSH
50602: LD_INT 1
50604: ARRAY
50605: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50606: LD_ADDR_EXP 130
50610: PUSH
50611: LD_EXP 130
50615: PPUSH
50616: LD_VAR 0 2
50620: PPUSH
50621: EMPTY
50622: PPUSH
50623: CALL_OW 1
50627: ST_TO_ADDR
// Attack ( tmp ) ;
50628: LD_VAR 0 3
50632: PPUSH
50633: CALL 112907 0 1
// exit ;
50637: POP
50638: POP
50639: GO 50645
// end ; end ;
50641: GO 50571
50643: POP
50644: POP
// end ;
50645: LD_VAR 0 1
50649: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50650: LD_INT 0
50652: PPUSH
50653: PPUSH
50654: PPUSH
50655: PPUSH
50656: PPUSH
50657: PPUSH
50658: PPUSH
// if not mc_bases then
50659: LD_EXP 110
50663: NOT
50664: IFFALSE 50668
// exit ;
50666: GO 51250
// for i = 1 to mc_bases do
50668: LD_ADDR_VAR 0 2
50672: PUSH
50673: DOUBLE
50674: LD_INT 1
50676: DEC
50677: ST_TO_ADDR
50678: LD_EXP 110
50682: PUSH
50683: FOR_TO
50684: IFFALSE 51248
// begin if not mc_bases [ i ] then
50686: LD_EXP 110
50690: PUSH
50691: LD_VAR 0 2
50695: ARRAY
50696: NOT
50697: IFFALSE 50701
// continue ;
50699: GO 50683
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50701: LD_ADDR_VAR 0 7
50705: PUSH
50706: LD_EXP 110
50710: PUSH
50711: LD_VAR 0 2
50715: ARRAY
50716: PUSH
50717: LD_INT 1
50719: ARRAY
50720: PPUSH
50721: CALL 66847 0 1
50725: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50726: LD_ADDR_EXP 133
50730: PUSH
50731: LD_EXP 133
50735: PPUSH
50736: LD_VAR 0 2
50740: PPUSH
50741: LD_EXP 110
50745: PUSH
50746: LD_VAR 0 2
50750: ARRAY
50751: PUSH
50752: LD_INT 1
50754: ARRAY
50755: PPUSH
50756: CALL_OW 255
50760: PPUSH
50761: LD_EXP 135
50765: PUSH
50766: LD_VAR 0 2
50770: ARRAY
50771: PPUSH
50772: CALL 66812 0 2
50776: PPUSH
50777: CALL_OW 1
50781: ST_TO_ADDR
// if not mc_scan [ i ] then
50782: LD_EXP 133
50786: PUSH
50787: LD_VAR 0 2
50791: ARRAY
50792: NOT
50793: IFFALSE 50948
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50795: LD_ADDR_VAR 0 4
50799: PUSH
50800: LD_EXP 110
50804: PUSH
50805: LD_VAR 0 2
50809: ARRAY
50810: PPUSH
50811: LD_INT 2
50813: PUSH
50814: LD_INT 25
50816: PUSH
50817: LD_INT 5
50819: PUSH
50820: EMPTY
50821: LIST
50822: LIST
50823: PUSH
50824: LD_INT 25
50826: PUSH
50827: LD_INT 8
50829: PUSH
50830: EMPTY
50831: LIST
50832: LIST
50833: PUSH
50834: LD_INT 25
50836: PUSH
50837: LD_INT 9
50839: PUSH
50840: EMPTY
50841: LIST
50842: LIST
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: LIST
50848: LIST
50849: PPUSH
50850: CALL_OW 72
50854: ST_TO_ADDR
// if not tmp then
50855: LD_VAR 0 4
50859: NOT
50860: IFFALSE 50864
// continue ;
50862: GO 50683
// for j in tmp do
50864: LD_ADDR_VAR 0 3
50868: PUSH
50869: LD_VAR 0 4
50873: PUSH
50874: FOR_IN
50875: IFFALSE 50946
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50877: LD_VAR 0 3
50881: PPUSH
50882: CALL_OW 310
50886: PPUSH
50887: CALL_OW 266
50891: PUSH
50892: LD_INT 5
50894: EQUAL
50895: PUSH
50896: LD_VAR 0 3
50900: PPUSH
50901: CALL_OW 257
50905: PUSH
50906: LD_INT 1
50908: EQUAL
50909: AND
50910: PUSH
50911: LD_VAR 0 3
50915: PPUSH
50916: CALL_OW 459
50920: NOT
50921: AND
50922: PUSH
50923: LD_VAR 0 7
50927: AND
50928: IFFALSE 50944
// ComChangeProfession ( j , class ) ;
50930: LD_VAR 0 3
50934: PPUSH
50935: LD_VAR 0 7
50939: PPUSH
50940: CALL_OW 123
50944: GO 50874
50946: POP
50947: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50948: LD_EXP 133
50952: PUSH
50953: LD_VAR 0 2
50957: ARRAY
50958: PUSH
50959: LD_EXP 132
50963: PUSH
50964: LD_VAR 0 2
50968: ARRAY
50969: NOT
50970: AND
50971: PUSH
50972: LD_EXP 110
50976: PUSH
50977: LD_VAR 0 2
50981: ARRAY
50982: PPUSH
50983: LD_INT 30
50985: PUSH
50986: LD_INT 32
50988: PUSH
50989: EMPTY
50990: LIST
50991: LIST
50992: PPUSH
50993: CALL_OW 72
50997: NOT
50998: AND
50999: PUSH
51000: LD_EXP 110
51004: PUSH
51005: LD_VAR 0 2
51009: ARRAY
51010: PPUSH
51011: LD_INT 2
51013: PUSH
51014: LD_INT 30
51016: PUSH
51017: LD_INT 4
51019: PUSH
51020: EMPTY
51021: LIST
51022: LIST
51023: PUSH
51024: LD_INT 30
51026: PUSH
51027: LD_INT 5
51029: PUSH
51030: EMPTY
51031: LIST
51032: LIST
51033: PUSH
51034: EMPTY
51035: LIST
51036: LIST
51037: LIST
51038: PPUSH
51039: CALL_OW 72
51043: NOT
51044: AND
51045: IFFALSE 51177
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51047: LD_ADDR_VAR 0 4
51051: PUSH
51052: LD_EXP 110
51056: PUSH
51057: LD_VAR 0 2
51061: ARRAY
51062: PPUSH
51063: LD_INT 2
51065: PUSH
51066: LD_INT 25
51068: PUSH
51069: LD_INT 1
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: PUSH
51076: LD_INT 25
51078: PUSH
51079: LD_INT 5
51081: PUSH
51082: EMPTY
51083: LIST
51084: LIST
51085: PUSH
51086: LD_INT 25
51088: PUSH
51089: LD_INT 8
51091: PUSH
51092: EMPTY
51093: LIST
51094: LIST
51095: PUSH
51096: LD_INT 25
51098: PUSH
51099: LD_INT 9
51101: PUSH
51102: EMPTY
51103: LIST
51104: LIST
51105: PUSH
51106: EMPTY
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: PPUSH
51113: CALL_OW 72
51117: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51118: LD_ADDR_VAR 0 4
51122: PUSH
51123: LD_VAR 0 4
51127: PUSH
51128: LD_VAR 0 4
51132: PPUSH
51133: LD_INT 18
51135: PPUSH
51136: CALL 98572 0 2
51140: DIFF
51141: ST_TO_ADDR
// if tmp then
51142: LD_VAR 0 4
51146: IFFALSE 51177
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51148: LD_VAR 0 2
51152: PPUSH
51153: LD_VAR 0 4
51157: PPUSH
51158: LD_EXP 135
51162: PUSH
51163: LD_VAR 0 2
51167: ARRAY
51168: PPUSH
51169: CALL 117616 0 3
// exit ;
51173: POP
51174: POP
51175: GO 51250
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51177: LD_EXP 133
51181: PUSH
51182: LD_VAR 0 2
51186: ARRAY
51187: PUSH
51188: LD_EXP 132
51192: PUSH
51193: LD_VAR 0 2
51197: ARRAY
51198: AND
51199: IFFALSE 51246
// begin tmp := mc_defender [ i ] ;
51201: LD_ADDR_VAR 0 4
51205: PUSH
51206: LD_EXP 132
51210: PUSH
51211: LD_VAR 0 2
51215: ARRAY
51216: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51217: LD_VAR 0 2
51221: PPUSH
51222: LD_VAR 0 4
51226: PPUSH
51227: LD_EXP 133
51231: PUSH
51232: LD_VAR 0 2
51236: ARRAY
51237: PPUSH
51238: CALL 118177 0 3
// exit ;
51242: POP
51243: POP
51244: GO 51250
// end ; end ;
51246: GO 50683
51248: POP
51249: POP
// end ;
51250: LD_VAR 0 1
51254: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51255: LD_INT 0
51257: PPUSH
51258: PPUSH
51259: PPUSH
51260: PPUSH
51261: PPUSH
51262: PPUSH
51263: PPUSH
51264: PPUSH
51265: PPUSH
51266: PPUSH
51267: PPUSH
// if not mc_bases then
51268: LD_EXP 110
51272: NOT
51273: IFFALSE 51277
// exit ;
51275: GO 52364
// for i = 1 to mc_bases do
51277: LD_ADDR_VAR 0 2
51281: PUSH
51282: DOUBLE
51283: LD_INT 1
51285: DEC
51286: ST_TO_ADDR
51287: LD_EXP 110
51291: PUSH
51292: FOR_TO
51293: IFFALSE 52362
// begin tmp := mc_lab [ i ] ;
51295: LD_ADDR_VAR 0 6
51299: PUSH
51300: LD_EXP 143
51304: PUSH
51305: LD_VAR 0 2
51309: ARRAY
51310: ST_TO_ADDR
// if not tmp then
51311: LD_VAR 0 6
51315: NOT
51316: IFFALSE 51320
// continue ;
51318: GO 51292
// idle_lab := 0 ;
51320: LD_ADDR_VAR 0 11
51324: PUSH
51325: LD_INT 0
51327: ST_TO_ADDR
// for j in tmp do
51328: LD_ADDR_VAR 0 3
51332: PUSH
51333: LD_VAR 0 6
51337: PUSH
51338: FOR_IN
51339: IFFALSE 52358
// begin researching := false ;
51341: LD_ADDR_VAR 0 10
51345: PUSH
51346: LD_INT 0
51348: ST_TO_ADDR
// side := GetSide ( j ) ;
51349: LD_ADDR_VAR 0 4
51353: PUSH
51354: LD_VAR 0 3
51358: PPUSH
51359: CALL_OW 255
51363: ST_TO_ADDR
// if not mc_tech [ side ] then
51364: LD_EXP 137
51368: PUSH
51369: LD_VAR 0 4
51373: ARRAY
51374: NOT
51375: IFFALSE 51379
// continue ;
51377: GO 51338
// if BuildingStatus ( j ) = bs_idle then
51379: LD_VAR 0 3
51383: PPUSH
51384: CALL_OW 461
51388: PUSH
51389: LD_INT 2
51391: EQUAL
51392: IFFALSE 51580
// begin if idle_lab and UnitsInside ( j ) < 6 then
51394: LD_VAR 0 11
51398: PUSH
51399: LD_VAR 0 3
51403: PPUSH
51404: CALL_OW 313
51408: PUSH
51409: LD_INT 6
51411: LESS
51412: AND
51413: IFFALSE 51484
// begin tmp2 := UnitsInside ( idle_lab ) ;
51415: LD_ADDR_VAR 0 9
51419: PUSH
51420: LD_VAR 0 11
51424: PPUSH
51425: CALL_OW 313
51429: ST_TO_ADDR
// if tmp2 then
51430: LD_VAR 0 9
51434: IFFALSE 51476
// for x in tmp2 do
51436: LD_ADDR_VAR 0 7
51440: PUSH
51441: LD_VAR 0 9
51445: PUSH
51446: FOR_IN
51447: IFFALSE 51474
// begin ComExitBuilding ( x ) ;
51449: LD_VAR 0 7
51453: PPUSH
51454: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51458: LD_VAR 0 7
51462: PPUSH
51463: LD_VAR 0 3
51467: PPUSH
51468: CALL_OW 180
// end ;
51472: GO 51446
51474: POP
51475: POP
// idle_lab := 0 ;
51476: LD_ADDR_VAR 0 11
51480: PUSH
51481: LD_INT 0
51483: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51484: LD_ADDR_VAR 0 5
51488: PUSH
51489: LD_EXP 137
51493: PUSH
51494: LD_VAR 0 4
51498: ARRAY
51499: PUSH
51500: FOR_IN
51501: IFFALSE 51561
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51503: LD_VAR 0 3
51507: PPUSH
51508: LD_VAR 0 5
51512: PPUSH
51513: CALL_OW 430
51517: PUSH
51518: LD_VAR 0 4
51522: PPUSH
51523: LD_VAR 0 5
51527: PPUSH
51528: CALL 65917 0 2
51532: AND
51533: IFFALSE 51559
// begin researching := true ;
51535: LD_ADDR_VAR 0 10
51539: PUSH
51540: LD_INT 1
51542: ST_TO_ADDR
// ComResearch ( j , t ) ;
51543: LD_VAR 0 3
51547: PPUSH
51548: LD_VAR 0 5
51552: PPUSH
51553: CALL_OW 124
// break ;
51557: GO 51561
// end ;
51559: GO 51500
51561: POP
51562: POP
// if not researching then
51563: LD_VAR 0 10
51567: NOT
51568: IFFALSE 51580
// idle_lab := j ;
51570: LD_ADDR_VAR 0 11
51574: PUSH
51575: LD_VAR 0 3
51579: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51580: LD_VAR 0 3
51584: PPUSH
51585: CALL_OW 461
51589: PUSH
51590: LD_INT 10
51592: EQUAL
51593: IFFALSE 52181
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51595: LD_EXP 139
51599: PUSH
51600: LD_VAR 0 2
51604: ARRAY
51605: NOT
51606: PUSH
51607: LD_EXP 140
51611: PUSH
51612: LD_VAR 0 2
51616: ARRAY
51617: NOT
51618: AND
51619: PUSH
51620: LD_EXP 137
51624: PUSH
51625: LD_VAR 0 4
51629: ARRAY
51630: PUSH
51631: LD_INT 1
51633: GREATER
51634: AND
51635: IFFALSE 51766
// begin ComCancel ( j ) ;
51637: LD_VAR 0 3
51641: PPUSH
51642: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51646: LD_ADDR_EXP 137
51650: PUSH
51651: LD_EXP 137
51655: PPUSH
51656: LD_VAR 0 4
51660: PPUSH
51661: LD_EXP 137
51665: PUSH
51666: LD_VAR 0 4
51670: ARRAY
51671: PPUSH
51672: LD_EXP 137
51676: PUSH
51677: LD_VAR 0 4
51681: ARRAY
51682: PUSH
51683: LD_INT 1
51685: MINUS
51686: PPUSH
51687: LD_EXP 137
51691: PUSH
51692: LD_VAR 0 4
51696: ARRAY
51697: PPUSH
51698: LD_INT 0
51700: PPUSH
51701: CALL 69429 0 4
51705: PPUSH
51706: CALL_OW 1
51710: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51711: LD_ADDR_EXP 137
51715: PUSH
51716: LD_EXP 137
51720: PPUSH
51721: LD_VAR 0 4
51725: PPUSH
51726: LD_EXP 137
51730: PUSH
51731: LD_VAR 0 4
51735: ARRAY
51736: PPUSH
51737: LD_EXP 137
51741: PUSH
51742: LD_VAR 0 4
51746: ARRAY
51747: PPUSH
51748: LD_INT 1
51750: PPUSH
51751: LD_INT 0
51753: PPUSH
51754: CALL 69429 0 4
51758: PPUSH
51759: CALL_OW 1
51763: ST_TO_ADDR
// continue ;
51764: GO 51338
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51766: LD_EXP 139
51770: PUSH
51771: LD_VAR 0 2
51775: ARRAY
51776: PUSH
51777: LD_EXP 140
51781: PUSH
51782: LD_VAR 0 2
51786: ARRAY
51787: NOT
51788: AND
51789: IFFALSE 51916
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51791: LD_ADDR_EXP 140
51795: PUSH
51796: LD_EXP 140
51800: PPUSH
51801: LD_VAR 0 2
51805: PUSH
51806: LD_EXP 140
51810: PUSH
51811: LD_VAR 0 2
51815: ARRAY
51816: PUSH
51817: LD_INT 1
51819: PLUS
51820: PUSH
51821: EMPTY
51822: LIST
51823: LIST
51824: PPUSH
51825: LD_EXP 139
51829: PUSH
51830: LD_VAR 0 2
51834: ARRAY
51835: PUSH
51836: LD_INT 1
51838: ARRAY
51839: PPUSH
51840: CALL 70011 0 3
51844: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51845: LD_EXP 139
51849: PUSH
51850: LD_VAR 0 2
51854: ARRAY
51855: PUSH
51856: LD_INT 1
51858: ARRAY
51859: PPUSH
51860: LD_INT 112
51862: PPUSH
51863: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51867: LD_ADDR_VAR 0 9
51871: PUSH
51872: LD_EXP 139
51876: PUSH
51877: LD_VAR 0 2
51881: ARRAY
51882: PPUSH
51883: LD_INT 1
51885: PPUSH
51886: CALL_OW 3
51890: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51891: LD_ADDR_EXP 139
51895: PUSH
51896: LD_EXP 139
51900: PPUSH
51901: LD_VAR 0 2
51905: PPUSH
51906: LD_VAR 0 9
51910: PPUSH
51911: CALL_OW 1
51915: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51916: LD_EXP 139
51920: PUSH
51921: LD_VAR 0 2
51925: ARRAY
51926: PUSH
51927: LD_EXP 140
51931: PUSH
51932: LD_VAR 0 2
51936: ARRAY
51937: AND
51938: PUSH
51939: LD_EXP 140
51943: PUSH
51944: LD_VAR 0 2
51948: ARRAY
51949: PUSH
51950: LD_INT 1
51952: ARRAY
51953: PPUSH
51954: CALL_OW 310
51958: NOT
51959: AND
51960: PUSH
51961: LD_VAR 0 3
51965: PPUSH
51966: CALL_OW 313
51970: PUSH
51971: LD_INT 6
51973: EQUAL
51974: AND
51975: IFFALSE 52031
// begin tmp2 := UnitsInside ( j ) ;
51977: LD_ADDR_VAR 0 9
51981: PUSH
51982: LD_VAR 0 3
51986: PPUSH
51987: CALL_OW 313
51991: ST_TO_ADDR
// if tmp2 = 6 then
51992: LD_VAR 0 9
51996: PUSH
51997: LD_INT 6
51999: EQUAL
52000: IFFALSE 52031
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52002: LD_VAR 0 9
52006: PUSH
52007: LD_INT 1
52009: ARRAY
52010: PPUSH
52011: LD_INT 112
52013: PPUSH
52014: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52018: LD_VAR 0 9
52022: PUSH
52023: LD_INT 1
52025: ARRAY
52026: PPUSH
52027: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52031: LD_EXP 140
52035: PUSH
52036: LD_VAR 0 2
52040: ARRAY
52041: PUSH
52042: LD_EXP 140
52046: PUSH
52047: LD_VAR 0 2
52051: ARRAY
52052: PUSH
52053: LD_INT 1
52055: ARRAY
52056: PPUSH
52057: CALL_OW 314
52061: NOT
52062: AND
52063: PUSH
52064: LD_EXP 140
52068: PUSH
52069: LD_VAR 0 2
52073: ARRAY
52074: PUSH
52075: LD_INT 1
52077: ARRAY
52078: PPUSH
52079: CALL_OW 310
52083: NOT
52084: AND
52085: IFFALSE 52111
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52087: LD_EXP 140
52091: PUSH
52092: LD_VAR 0 2
52096: ARRAY
52097: PUSH
52098: LD_INT 1
52100: ARRAY
52101: PPUSH
52102: LD_VAR 0 3
52106: PPUSH
52107: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52111: LD_EXP 140
52115: PUSH
52116: LD_VAR 0 2
52120: ARRAY
52121: PUSH
52122: LD_INT 1
52124: ARRAY
52125: PPUSH
52126: CALL_OW 310
52130: PUSH
52131: LD_EXP 140
52135: PUSH
52136: LD_VAR 0 2
52140: ARRAY
52141: PUSH
52142: LD_INT 1
52144: ARRAY
52145: PPUSH
52146: CALL_OW 310
52150: PPUSH
52151: CALL_OW 461
52155: PUSH
52156: LD_INT 3
52158: NONEQUAL
52159: AND
52160: IFFALSE 52181
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52162: LD_EXP 140
52166: PUSH
52167: LD_VAR 0 2
52171: ARRAY
52172: PUSH
52173: LD_INT 1
52175: ARRAY
52176: PPUSH
52177: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52181: LD_VAR 0 3
52185: PPUSH
52186: CALL_OW 461
52190: PUSH
52191: LD_INT 6
52193: EQUAL
52194: PUSH
52195: LD_VAR 0 6
52199: PUSH
52200: LD_INT 1
52202: GREATER
52203: AND
52204: IFFALSE 52356
// begin sci := [ ] ;
52206: LD_ADDR_VAR 0 8
52210: PUSH
52211: EMPTY
52212: ST_TO_ADDR
// for x in ( tmp diff j ) do
52213: LD_ADDR_VAR 0 7
52217: PUSH
52218: LD_VAR 0 6
52222: PUSH
52223: LD_VAR 0 3
52227: DIFF
52228: PUSH
52229: FOR_IN
52230: IFFALSE 52282
// begin if sci = 6 then
52232: LD_VAR 0 8
52236: PUSH
52237: LD_INT 6
52239: EQUAL
52240: IFFALSE 52244
// break ;
52242: GO 52282
// if BuildingStatus ( x ) = bs_idle then
52244: LD_VAR 0 7
52248: PPUSH
52249: CALL_OW 461
52253: PUSH
52254: LD_INT 2
52256: EQUAL
52257: IFFALSE 52280
// sci := sci ^ UnitsInside ( x ) ;
52259: LD_ADDR_VAR 0 8
52263: PUSH
52264: LD_VAR 0 8
52268: PUSH
52269: LD_VAR 0 7
52273: PPUSH
52274: CALL_OW 313
52278: ADD
52279: ST_TO_ADDR
// end ;
52280: GO 52229
52282: POP
52283: POP
// if not sci then
52284: LD_VAR 0 8
52288: NOT
52289: IFFALSE 52293
// continue ;
52291: GO 51338
// for x in sci do
52293: LD_ADDR_VAR 0 7
52297: PUSH
52298: LD_VAR 0 8
52302: PUSH
52303: FOR_IN
52304: IFFALSE 52354
// if IsInUnit ( x ) and not HasTask ( x ) then
52306: LD_VAR 0 7
52310: PPUSH
52311: CALL_OW 310
52315: PUSH
52316: LD_VAR 0 7
52320: PPUSH
52321: CALL_OW 314
52325: NOT
52326: AND
52327: IFFALSE 52352
// begin ComExitBuilding ( x ) ;
52329: LD_VAR 0 7
52333: PPUSH
52334: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52338: LD_VAR 0 7
52342: PPUSH
52343: LD_VAR 0 3
52347: PPUSH
52348: CALL_OW 180
// end ;
52352: GO 52303
52354: POP
52355: POP
// end ; end ;
52356: GO 51338
52358: POP
52359: POP
// end ;
52360: GO 51292
52362: POP
52363: POP
// end ;
52364: LD_VAR 0 1
52368: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52369: LD_INT 0
52371: PPUSH
52372: PPUSH
// if not mc_bases then
52373: LD_EXP 110
52377: NOT
52378: IFFALSE 52382
// exit ;
52380: GO 52463
// for i = 1 to mc_bases do
52382: LD_ADDR_VAR 0 2
52386: PUSH
52387: DOUBLE
52388: LD_INT 1
52390: DEC
52391: ST_TO_ADDR
52392: LD_EXP 110
52396: PUSH
52397: FOR_TO
52398: IFFALSE 52461
// if mc_mines [ i ] and mc_miners [ i ] then
52400: LD_EXP 123
52404: PUSH
52405: LD_VAR 0 2
52409: ARRAY
52410: PUSH
52411: LD_EXP 124
52415: PUSH
52416: LD_VAR 0 2
52420: ARRAY
52421: AND
52422: IFFALSE 52459
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52424: LD_EXP 124
52428: PUSH
52429: LD_VAR 0 2
52433: ARRAY
52434: PUSH
52435: LD_INT 1
52437: ARRAY
52438: PPUSH
52439: CALL_OW 255
52443: PPUSH
52444: LD_EXP 123
52448: PUSH
52449: LD_VAR 0 2
52453: ARRAY
52454: PPUSH
52455: CALL 67000 0 2
52459: GO 52397
52461: POP
52462: POP
// end ;
52463: LD_VAR 0 1
52467: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52468: LD_INT 0
52470: PPUSH
52471: PPUSH
52472: PPUSH
52473: PPUSH
52474: PPUSH
52475: PPUSH
52476: PPUSH
52477: PPUSH
// if not mc_bases or not mc_parking then
52478: LD_EXP 110
52482: NOT
52483: PUSH
52484: LD_EXP 134
52488: NOT
52489: OR
52490: IFFALSE 52494
// exit ;
52492: GO 53193
// for i = 1 to mc_bases do
52494: LD_ADDR_VAR 0 2
52498: PUSH
52499: DOUBLE
52500: LD_INT 1
52502: DEC
52503: ST_TO_ADDR
52504: LD_EXP 110
52508: PUSH
52509: FOR_TO
52510: IFFALSE 53191
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52512: LD_EXP 110
52516: PUSH
52517: LD_VAR 0 2
52521: ARRAY
52522: NOT
52523: PUSH
52524: LD_EXP 134
52528: PUSH
52529: LD_VAR 0 2
52533: ARRAY
52534: NOT
52535: OR
52536: IFFALSE 52540
// continue ;
52538: GO 52509
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52540: LD_ADDR_VAR 0 5
52544: PUSH
52545: LD_EXP 110
52549: PUSH
52550: LD_VAR 0 2
52554: ARRAY
52555: PUSH
52556: LD_INT 1
52558: ARRAY
52559: PPUSH
52560: CALL_OW 255
52564: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52565: LD_ADDR_VAR 0 6
52569: PUSH
52570: LD_EXP 110
52574: PUSH
52575: LD_VAR 0 2
52579: ARRAY
52580: PPUSH
52581: LD_INT 30
52583: PUSH
52584: LD_INT 3
52586: PUSH
52587: EMPTY
52588: LIST
52589: LIST
52590: PPUSH
52591: CALL_OW 72
52595: ST_TO_ADDR
// if not fac then
52596: LD_VAR 0 6
52600: NOT
52601: IFFALSE 52652
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52603: LD_ADDR_VAR 0 6
52607: PUSH
52608: LD_EXP 110
52612: PUSH
52613: LD_VAR 0 2
52617: ARRAY
52618: PPUSH
52619: LD_INT 2
52621: PUSH
52622: LD_INT 30
52624: PUSH
52625: LD_INT 0
52627: PUSH
52628: EMPTY
52629: LIST
52630: LIST
52631: PUSH
52632: LD_INT 30
52634: PUSH
52635: LD_INT 1
52637: PUSH
52638: EMPTY
52639: LIST
52640: LIST
52641: PUSH
52642: EMPTY
52643: LIST
52644: LIST
52645: LIST
52646: PPUSH
52647: CALL_OW 72
52651: ST_TO_ADDR
// if not fac then
52652: LD_VAR 0 6
52656: NOT
52657: IFFALSE 52661
// continue ;
52659: GO 52509
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52661: LD_ADDR_VAR 0 7
52665: PUSH
52666: LD_EXP 134
52670: PUSH
52671: LD_VAR 0 2
52675: ARRAY
52676: PPUSH
52677: LD_INT 22
52679: PUSH
52680: LD_VAR 0 5
52684: PUSH
52685: EMPTY
52686: LIST
52687: LIST
52688: PUSH
52689: LD_INT 21
52691: PUSH
52692: LD_INT 2
52694: PUSH
52695: EMPTY
52696: LIST
52697: LIST
52698: PUSH
52699: LD_INT 3
52701: PUSH
52702: LD_INT 24
52704: PUSH
52705: LD_INT 1000
52707: PUSH
52708: EMPTY
52709: LIST
52710: LIST
52711: PUSH
52712: EMPTY
52713: LIST
52714: LIST
52715: PUSH
52716: EMPTY
52717: LIST
52718: LIST
52719: LIST
52720: PPUSH
52721: CALL_OW 70
52725: ST_TO_ADDR
// for j in fac do
52726: LD_ADDR_VAR 0 3
52730: PUSH
52731: LD_VAR 0 6
52735: PUSH
52736: FOR_IN
52737: IFFALSE 52818
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52739: LD_ADDR_VAR 0 7
52743: PUSH
52744: LD_VAR 0 7
52748: PUSH
52749: LD_INT 22
52751: PUSH
52752: LD_VAR 0 5
52756: PUSH
52757: EMPTY
52758: LIST
52759: LIST
52760: PUSH
52761: LD_INT 91
52763: PUSH
52764: LD_VAR 0 3
52768: PUSH
52769: LD_INT 15
52771: PUSH
52772: EMPTY
52773: LIST
52774: LIST
52775: LIST
52776: PUSH
52777: LD_INT 21
52779: PUSH
52780: LD_INT 2
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: PUSH
52787: LD_INT 3
52789: PUSH
52790: LD_INT 24
52792: PUSH
52793: LD_INT 1000
52795: PUSH
52796: EMPTY
52797: LIST
52798: LIST
52799: PUSH
52800: EMPTY
52801: LIST
52802: LIST
52803: PUSH
52804: EMPTY
52805: LIST
52806: LIST
52807: LIST
52808: LIST
52809: PPUSH
52810: CALL_OW 69
52814: UNION
52815: ST_TO_ADDR
52816: GO 52736
52818: POP
52819: POP
// if not vehs then
52820: LD_VAR 0 7
52824: NOT
52825: IFFALSE 52851
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52827: LD_ADDR_EXP 122
52831: PUSH
52832: LD_EXP 122
52836: PPUSH
52837: LD_VAR 0 2
52841: PPUSH
52842: EMPTY
52843: PPUSH
52844: CALL_OW 1
52848: ST_TO_ADDR
// continue ;
52849: GO 52509
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52851: LD_ADDR_VAR 0 8
52855: PUSH
52856: LD_EXP 110
52860: PUSH
52861: LD_VAR 0 2
52865: ARRAY
52866: PPUSH
52867: LD_INT 30
52869: PUSH
52870: LD_INT 3
52872: PUSH
52873: EMPTY
52874: LIST
52875: LIST
52876: PPUSH
52877: CALL_OW 72
52881: ST_TO_ADDR
// if tmp then
52882: LD_VAR 0 8
52886: IFFALSE 52989
// begin for j in tmp do
52888: LD_ADDR_VAR 0 3
52892: PUSH
52893: LD_VAR 0 8
52897: PUSH
52898: FOR_IN
52899: IFFALSE 52987
// for k in UnitsInside ( j ) do
52901: LD_ADDR_VAR 0 4
52905: PUSH
52906: LD_VAR 0 3
52910: PPUSH
52911: CALL_OW 313
52915: PUSH
52916: FOR_IN
52917: IFFALSE 52983
// if k then
52919: LD_VAR 0 4
52923: IFFALSE 52981
// if not k in mc_repair_vehicle [ i ] then
52925: LD_VAR 0 4
52929: PUSH
52930: LD_EXP 122
52934: PUSH
52935: LD_VAR 0 2
52939: ARRAY
52940: IN
52941: NOT
52942: IFFALSE 52981
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52944: LD_ADDR_EXP 122
52948: PUSH
52949: LD_EXP 122
52953: PPUSH
52954: LD_VAR 0 2
52958: PPUSH
52959: LD_EXP 122
52963: PUSH
52964: LD_VAR 0 2
52968: ARRAY
52969: PUSH
52970: LD_VAR 0 4
52974: UNION
52975: PPUSH
52976: CALL_OW 1
52980: ST_TO_ADDR
52981: GO 52916
52983: POP
52984: POP
52985: GO 52898
52987: POP
52988: POP
// end ; if not mc_repair_vehicle [ i ] then
52989: LD_EXP 122
52993: PUSH
52994: LD_VAR 0 2
52998: ARRAY
52999: NOT
53000: IFFALSE 53004
// continue ;
53002: GO 52509
// for j in mc_repair_vehicle [ i ] do
53004: LD_ADDR_VAR 0 3
53008: PUSH
53009: LD_EXP 122
53013: PUSH
53014: LD_VAR 0 2
53018: ARRAY
53019: PUSH
53020: FOR_IN
53021: IFFALSE 53187
// begin if GetClass ( j ) <> 3 then
53023: LD_VAR 0 3
53027: PPUSH
53028: CALL_OW 257
53032: PUSH
53033: LD_INT 3
53035: NONEQUAL
53036: IFFALSE 53077
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53038: LD_ADDR_EXP 122
53042: PUSH
53043: LD_EXP 122
53047: PPUSH
53048: LD_VAR 0 2
53052: PPUSH
53053: LD_EXP 122
53057: PUSH
53058: LD_VAR 0 2
53062: ARRAY
53063: PUSH
53064: LD_VAR 0 3
53068: DIFF
53069: PPUSH
53070: CALL_OW 1
53074: ST_TO_ADDR
// continue ;
53075: GO 53020
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53077: LD_VAR 0 3
53081: PPUSH
53082: CALL_OW 311
53086: NOT
53087: PUSH
53088: LD_VAR 0 3
53092: PUSH
53093: LD_EXP 113
53097: PUSH
53098: LD_VAR 0 2
53102: ARRAY
53103: PUSH
53104: LD_INT 1
53106: ARRAY
53107: IN
53108: NOT
53109: AND
53110: PUSH
53111: LD_VAR 0 3
53115: PUSH
53116: LD_EXP 113
53120: PUSH
53121: LD_VAR 0 2
53125: ARRAY
53126: PUSH
53127: LD_INT 2
53129: ARRAY
53130: IN
53131: NOT
53132: AND
53133: IFFALSE 53185
// begin if IsInUnit ( j ) then
53135: LD_VAR 0 3
53139: PPUSH
53140: CALL_OW 310
53144: IFFALSE 53155
// ComExitBuilding ( j ) ;
53146: LD_VAR 0 3
53150: PPUSH
53151: CALL_OW 122
// if not HasTask ( j ) then
53155: LD_VAR 0 3
53159: PPUSH
53160: CALL_OW 314
53164: NOT
53165: IFFALSE 53185
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53167: LD_VAR 0 3
53171: PPUSH
53172: LD_VAR 0 7
53176: PUSH
53177: LD_INT 1
53179: ARRAY
53180: PPUSH
53181: CALL_OW 189
// end ; end ;
53185: GO 53020
53187: POP
53188: POP
// end ;
53189: GO 52509
53191: POP
53192: POP
// end ;
53193: LD_VAR 0 1
53197: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53198: LD_INT 0
53200: PPUSH
53201: PPUSH
53202: PPUSH
53203: PPUSH
53204: PPUSH
53205: PPUSH
53206: PPUSH
53207: PPUSH
53208: PPUSH
53209: PPUSH
53210: PPUSH
// if not mc_bases then
53211: LD_EXP 110
53215: NOT
53216: IFFALSE 53220
// exit ;
53218: GO 54022
// for i = 1 to mc_bases do
53220: LD_ADDR_VAR 0 2
53224: PUSH
53225: DOUBLE
53226: LD_INT 1
53228: DEC
53229: ST_TO_ADDR
53230: LD_EXP 110
53234: PUSH
53235: FOR_TO
53236: IFFALSE 54020
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53238: LD_EXP 138
53242: PUSH
53243: LD_VAR 0 2
53247: ARRAY
53248: NOT
53249: PUSH
53250: LD_EXP 113
53254: PUSH
53255: LD_VAR 0 2
53259: ARRAY
53260: PUSH
53261: LD_INT 1
53263: ARRAY
53264: OR
53265: PUSH
53266: LD_EXP 113
53270: PUSH
53271: LD_VAR 0 2
53275: ARRAY
53276: PUSH
53277: LD_INT 2
53279: ARRAY
53280: OR
53281: PUSH
53282: LD_EXP 136
53286: PUSH
53287: LD_VAR 0 2
53291: ARRAY
53292: PPUSH
53293: LD_INT 1
53295: PPUSH
53296: CALL_OW 325
53300: NOT
53301: OR
53302: PUSH
53303: LD_EXP 133
53307: PUSH
53308: LD_VAR 0 2
53312: ARRAY
53313: OR
53314: IFFALSE 53318
// continue ;
53316: GO 53235
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53318: LD_ADDR_VAR 0 8
53322: PUSH
53323: LD_EXP 110
53327: PUSH
53328: LD_VAR 0 2
53332: ARRAY
53333: PPUSH
53334: LD_INT 25
53336: PUSH
53337: LD_INT 4
53339: PUSH
53340: EMPTY
53341: LIST
53342: LIST
53343: PUSH
53344: LD_INT 50
53346: PUSH
53347: EMPTY
53348: LIST
53349: PUSH
53350: LD_INT 3
53352: PUSH
53353: LD_INT 60
53355: PUSH
53356: EMPTY
53357: LIST
53358: PUSH
53359: EMPTY
53360: LIST
53361: LIST
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: LIST
53367: PPUSH
53368: CALL_OW 72
53372: PUSH
53373: LD_EXP 114
53377: PUSH
53378: LD_VAR 0 2
53382: ARRAY
53383: DIFF
53384: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53385: LD_ADDR_VAR 0 9
53389: PUSH
53390: LD_EXP 110
53394: PUSH
53395: LD_VAR 0 2
53399: ARRAY
53400: PPUSH
53401: LD_INT 2
53403: PUSH
53404: LD_INT 30
53406: PUSH
53407: LD_INT 0
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: PUSH
53414: LD_INT 30
53416: PUSH
53417: LD_INT 1
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: LIST
53428: PPUSH
53429: CALL_OW 72
53433: ST_TO_ADDR
// if not tmp or not dep then
53434: LD_VAR 0 8
53438: NOT
53439: PUSH
53440: LD_VAR 0 9
53444: NOT
53445: OR
53446: IFFALSE 53450
// continue ;
53448: GO 53235
// side := GetSide ( tmp [ 1 ] ) ;
53450: LD_ADDR_VAR 0 11
53454: PUSH
53455: LD_VAR 0 8
53459: PUSH
53460: LD_INT 1
53462: ARRAY
53463: PPUSH
53464: CALL_OW 255
53468: ST_TO_ADDR
// dep := dep [ 1 ] ;
53469: LD_ADDR_VAR 0 9
53473: PUSH
53474: LD_VAR 0 9
53478: PUSH
53479: LD_INT 1
53481: ARRAY
53482: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53483: LD_ADDR_VAR 0 7
53487: PUSH
53488: LD_EXP 138
53492: PUSH
53493: LD_VAR 0 2
53497: ARRAY
53498: PPUSH
53499: LD_INT 22
53501: PUSH
53502: LD_INT 0
53504: PUSH
53505: EMPTY
53506: LIST
53507: LIST
53508: PUSH
53509: LD_INT 25
53511: PUSH
53512: LD_INT 12
53514: PUSH
53515: EMPTY
53516: LIST
53517: LIST
53518: PUSH
53519: EMPTY
53520: LIST
53521: LIST
53522: PPUSH
53523: CALL_OW 70
53527: PUSH
53528: LD_INT 22
53530: PUSH
53531: LD_INT 0
53533: PUSH
53534: EMPTY
53535: LIST
53536: LIST
53537: PUSH
53538: LD_INT 25
53540: PUSH
53541: LD_INT 12
53543: PUSH
53544: EMPTY
53545: LIST
53546: LIST
53547: PUSH
53548: LD_INT 91
53550: PUSH
53551: LD_VAR 0 9
53555: PUSH
53556: LD_INT 20
53558: PUSH
53559: EMPTY
53560: LIST
53561: LIST
53562: LIST
53563: PUSH
53564: EMPTY
53565: LIST
53566: LIST
53567: LIST
53568: PPUSH
53569: CALL_OW 69
53573: UNION
53574: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53575: LD_ADDR_VAR 0 10
53579: PUSH
53580: LD_EXP 138
53584: PUSH
53585: LD_VAR 0 2
53589: ARRAY
53590: PPUSH
53591: LD_INT 81
53593: PUSH
53594: LD_VAR 0 11
53598: PUSH
53599: EMPTY
53600: LIST
53601: LIST
53602: PPUSH
53603: CALL_OW 70
53607: ST_TO_ADDR
// if not apes or danger_at_area then
53608: LD_VAR 0 7
53612: NOT
53613: PUSH
53614: LD_VAR 0 10
53618: OR
53619: IFFALSE 53669
// begin if mc_taming [ i ] then
53621: LD_EXP 141
53625: PUSH
53626: LD_VAR 0 2
53630: ARRAY
53631: IFFALSE 53667
// begin MC_Reset ( i , 121 ) ;
53633: LD_VAR 0 2
53637: PPUSH
53638: LD_INT 121
53640: PPUSH
53641: CALL 39120 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53645: LD_ADDR_EXP 141
53649: PUSH
53650: LD_EXP 141
53654: PPUSH
53655: LD_VAR 0 2
53659: PPUSH
53660: EMPTY
53661: PPUSH
53662: CALL_OW 1
53666: ST_TO_ADDR
// end ; continue ;
53667: GO 53235
// end ; for j in tmp do
53669: LD_ADDR_VAR 0 3
53673: PUSH
53674: LD_VAR 0 8
53678: PUSH
53679: FOR_IN
53680: IFFALSE 54016
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53682: LD_VAR 0 3
53686: PUSH
53687: LD_EXP 141
53691: PUSH
53692: LD_VAR 0 2
53696: ARRAY
53697: IN
53698: NOT
53699: PUSH
53700: LD_EXP 141
53704: PUSH
53705: LD_VAR 0 2
53709: ARRAY
53710: PUSH
53711: LD_INT 3
53713: LESS
53714: AND
53715: IFFALSE 53773
// begin SetTag ( j , 121 ) ;
53717: LD_VAR 0 3
53721: PPUSH
53722: LD_INT 121
53724: PPUSH
53725: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53729: LD_ADDR_EXP 141
53733: PUSH
53734: LD_EXP 141
53738: PPUSH
53739: LD_VAR 0 2
53743: PUSH
53744: LD_EXP 141
53748: PUSH
53749: LD_VAR 0 2
53753: ARRAY
53754: PUSH
53755: LD_INT 1
53757: PLUS
53758: PUSH
53759: EMPTY
53760: LIST
53761: LIST
53762: PPUSH
53763: LD_VAR 0 3
53767: PPUSH
53768: CALL 70011 0 3
53772: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53773: LD_VAR 0 3
53777: PUSH
53778: LD_EXP 141
53782: PUSH
53783: LD_VAR 0 2
53787: ARRAY
53788: IN
53789: IFFALSE 54014
// begin if GetClass ( j ) <> 4 then
53791: LD_VAR 0 3
53795: PPUSH
53796: CALL_OW 257
53800: PUSH
53801: LD_INT 4
53803: NONEQUAL
53804: IFFALSE 53857
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53806: LD_ADDR_EXP 141
53810: PUSH
53811: LD_EXP 141
53815: PPUSH
53816: LD_VAR 0 2
53820: PPUSH
53821: LD_EXP 141
53825: PUSH
53826: LD_VAR 0 2
53830: ARRAY
53831: PUSH
53832: LD_VAR 0 3
53836: DIFF
53837: PPUSH
53838: CALL_OW 1
53842: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53843: LD_VAR 0 3
53847: PPUSH
53848: LD_INT 0
53850: PPUSH
53851: CALL_OW 109
// continue ;
53855: GO 53679
// end ; if IsInUnit ( j ) then
53857: LD_VAR 0 3
53861: PPUSH
53862: CALL_OW 310
53866: IFFALSE 53877
// ComExitBuilding ( j ) ;
53868: LD_VAR 0 3
53872: PPUSH
53873: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53877: LD_ADDR_VAR 0 6
53881: PUSH
53882: LD_VAR 0 7
53886: PPUSH
53887: LD_VAR 0 3
53891: PPUSH
53892: CALL_OW 74
53896: ST_TO_ADDR
// if not ape then
53897: LD_VAR 0 6
53901: NOT
53902: IFFALSE 53906
// break ;
53904: GO 54016
// x := GetX ( ape ) ;
53906: LD_ADDR_VAR 0 4
53910: PUSH
53911: LD_VAR 0 6
53915: PPUSH
53916: CALL_OW 250
53920: ST_TO_ADDR
// y := GetY ( ape ) ;
53921: LD_ADDR_VAR 0 5
53925: PUSH
53926: LD_VAR 0 6
53930: PPUSH
53931: CALL_OW 251
53935: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53936: LD_VAR 0 4
53940: PPUSH
53941: LD_VAR 0 5
53945: PPUSH
53946: CALL_OW 488
53950: NOT
53951: PUSH
53952: LD_VAR 0 11
53956: PPUSH
53957: LD_VAR 0 4
53961: PPUSH
53962: LD_VAR 0 5
53966: PPUSH
53967: LD_INT 20
53969: PPUSH
53970: CALL 70907 0 4
53974: PUSH
53975: LD_INT 4
53977: ARRAY
53978: OR
53979: IFFALSE 53983
// break ;
53981: GO 54016
// if not HasTask ( j ) then
53983: LD_VAR 0 3
53987: PPUSH
53988: CALL_OW 314
53992: NOT
53993: IFFALSE 54014
// ComTameXY ( j , x , y ) ;
53995: LD_VAR 0 3
53999: PPUSH
54000: LD_VAR 0 4
54004: PPUSH
54005: LD_VAR 0 5
54009: PPUSH
54010: CALL_OW 131
// end ; end ;
54014: GO 53679
54016: POP
54017: POP
// end ;
54018: GO 53235
54020: POP
54021: POP
// end ;
54022: LD_VAR 0 1
54026: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54027: LD_INT 0
54029: PPUSH
54030: PPUSH
54031: PPUSH
54032: PPUSH
54033: PPUSH
54034: PPUSH
54035: PPUSH
54036: PPUSH
// if not mc_bases then
54037: LD_EXP 110
54041: NOT
54042: IFFALSE 54046
// exit ;
54044: GO 54672
// for i = 1 to mc_bases do
54046: LD_ADDR_VAR 0 2
54050: PUSH
54051: DOUBLE
54052: LD_INT 1
54054: DEC
54055: ST_TO_ADDR
54056: LD_EXP 110
54060: PUSH
54061: FOR_TO
54062: IFFALSE 54670
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54064: LD_EXP 139
54068: PUSH
54069: LD_VAR 0 2
54073: ARRAY
54074: NOT
54075: PUSH
54076: LD_EXP 139
54080: PUSH
54081: LD_VAR 0 2
54085: ARRAY
54086: PPUSH
54087: LD_INT 25
54089: PUSH
54090: LD_INT 12
54092: PUSH
54093: EMPTY
54094: LIST
54095: LIST
54096: PPUSH
54097: CALL_OW 72
54101: NOT
54102: OR
54103: IFFALSE 54107
// continue ;
54105: GO 54061
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54107: LD_ADDR_VAR 0 5
54111: PUSH
54112: LD_EXP 139
54116: PUSH
54117: LD_VAR 0 2
54121: ARRAY
54122: PUSH
54123: LD_INT 1
54125: ARRAY
54126: PPUSH
54127: CALL_OW 255
54131: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54132: LD_VAR 0 5
54136: PPUSH
54137: LD_INT 2
54139: PPUSH
54140: CALL_OW 325
54144: IFFALSE 54397
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54146: LD_ADDR_VAR 0 4
54150: PUSH
54151: LD_EXP 139
54155: PUSH
54156: LD_VAR 0 2
54160: ARRAY
54161: PPUSH
54162: LD_INT 25
54164: PUSH
54165: LD_INT 16
54167: PUSH
54168: EMPTY
54169: LIST
54170: LIST
54171: PPUSH
54172: CALL_OW 72
54176: ST_TO_ADDR
// if tmp < 6 then
54177: LD_VAR 0 4
54181: PUSH
54182: LD_INT 6
54184: LESS
54185: IFFALSE 54397
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54187: LD_ADDR_VAR 0 6
54191: PUSH
54192: LD_EXP 110
54196: PUSH
54197: LD_VAR 0 2
54201: ARRAY
54202: PPUSH
54203: LD_INT 2
54205: PUSH
54206: LD_INT 30
54208: PUSH
54209: LD_INT 0
54211: PUSH
54212: EMPTY
54213: LIST
54214: LIST
54215: PUSH
54216: LD_INT 30
54218: PUSH
54219: LD_INT 1
54221: PUSH
54222: EMPTY
54223: LIST
54224: LIST
54225: PUSH
54226: EMPTY
54227: LIST
54228: LIST
54229: LIST
54230: PPUSH
54231: CALL_OW 72
54235: ST_TO_ADDR
// if depot then
54236: LD_VAR 0 6
54240: IFFALSE 54397
// begin selected := 0 ;
54242: LD_ADDR_VAR 0 7
54246: PUSH
54247: LD_INT 0
54249: ST_TO_ADDR
// for j in depot do
54250: LD_ADDR_VAR 0 3
54254: PUSH
54255: LD_VAR 0 6
54259: PUSH
54260: FOR_IN
54261: IFFALSE 54292
// begin if UnitsInside ( j ) < 6 then
54263: LD_VAR 0 3
54267: PPUSH
54268: CALL_OW 313
54272: PUSH
54273: LD_INT 6
54275: LESS
54276: IFFALSE 54290
// begin selected := j ;
54278: LD_ADDR_VAR 0 7
54282: PUSH
54283: LD_VAR 0 3
54287: ST_TO_ADDR
// break ;
54288: GO 54292
// end ; end ;
54290: GO 54260
54292: POP
54293: POP
// if selected then
54294: LD_VAR 0 7
54298: IFFALSE 54397
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54300: LD_ADDR_VAR 0 3
54304: PUSH
54305: LD_EXP 139
54309: PUSH
54310: LD_VAR 0 2
54314: ARRAY
54315: PPUSH
54316: LD_INT 25
54318: PUSH
54319: LD_INT 12
54321: PUSH
54322: EMPTY
54323: LIST
54324: LIST
54325: PPUSH
54326: CALL_OW 72
54330: PUSH
54331: FOR_IN
54332: IFFALSE 54395
// if not HasTask ( j ) then
54334: LD_VAR 0 3
54338: PPUSH
54339: CALL_OW 314
54343: NOT
54344: IFFALSE 54393
// begin if not IsInUnit ( j ) then
54346: LD_VAR 0 3
54350: PPUSH
54351: CALL_OW 310
54355: NOT
54356: IFFALSE 54372
// ComEnterUnit ( j , selected ) ;
54358: LD_VAR 0 3
54362: PPUSH
54363: LD_VAR 0 7
54367: PPUSH
54368: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54372: LD_VAR 0 3
54376: PPUSH
54377: LD_INT 16
54379: PPUSH
54380: CALL_OW 183
// AddComExitBuilding ( j ) ;
54384: LD_VAR 0 3
54388: PPUSH
54389: CALL_OW 182
// end ;
54393: GO 54331
54395: POP
54396: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54397: LD_VAR 0 5
54401: PPUSH
54402: LD_INT 11
54404: PPUSH
54405: CALL_OW 325
54409: IFFALSE 54668
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54411: LD_ADDR_VAR 0 4
54415: PUSH
54416: LD_EXP 139
54420: PUSH
54421: LD_VAR 0 2
54425: ARRAY
54426: PPUSH
54427: LD_INT 25
54429: PUSH
54430: LD_INT 16
54432: PUSH
54433: EMPTY
54434: LIST
54435: LIST
54436: PPUSH
54437: CALL_OW 72
54441: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54442: LD_VAR 0 4
54446: PUSH
54447: LD_INT 6
54449: GREATEREQUAL
54450: PUSH
54451: LD_VAR 0 5
54455: PPUSH
54456: LD_INT 2
54458: PPUSH
54459: CALL_OW 325
54463: NOT
54464: OR
54465: IFFALSE 54668
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54467: LD_ADDR_VAR 0 8
54471: PUSH
54472: LD_EXP 110
54476: PUSH
54477: LD_VAR 0 2
54481: ARRAY
54482: PPUSH
54483: LD_INT 2
54485: PUSH
54486: LD_INT 30
54488: PUSH
54489: LD_INT 4
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: PUSH
54496: LD_INT 30
54498: PUSH
54499: LD_INT 5
54501: PUSH
54502: EMPTY
54503: LIST
54504: LIST
54505: PUSH
54506: EMPTY
54507: LIST
54508: LIST
54509: LIST
54510: PPUSH
54511: CALL_OW 72
54515: ST_TO_ADDR
// if barracks then
54516: LD_VAR 0 8
54520: IFFALSE 54668
// begin selected := 0 ;
54522: LD_ADDR_VAR 0 7
54526: PUSH
54527: LD_INT 0
54529: ST_TO_ADDR
// for j in barracks do
54530: LD_ADDR_VAR 0 3
54534: PUSH
54535: LD_VAR 0 8
54539: PUSH
54540: FOR_IN
54541: IFFALSE 54572
// begin if UnitsInside ( j ) < 6 then
54543: LD_VAR 0 3
54547: PPUSH
54548: CALL_OW 313
54552: PUSH
54553: LD_INT 6
54555: LESS
54556: IFFALSE 54570
// begin selected := j ;
54558: LD_ADDR_VAR 0 7
54562: PUSH
54563: LD_VAR 0 3
54567: ST_TO_ADDR
// break ;
54568: GO 54572
// end ; end ;
54570: GO 54540
54572: POP
54573: POP
// if selected then
54574: LD_VAR 0 7
54578: IFFALSE 54668
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54580: LD_ADDR_VAR 0 3
54584: PUSH
54585: LD_EXP 139
54589: PUSH
54590: LD_VAR 0 2
54594: ARRAY
54595: PPUSH
54596: LD_INT 25
54598: PUSH
54599: LD_INT 12
54601: PUSH
54602: EMPTY
54603: LIST
54604: LIST
54605: PPUSH
54606: CALL_OW 72
54610: PUSH
54611: FOR_IN
54612: IFFALSE 54666
// if not IsInUnit ( j ) and not HasTask ( j ) then
54614: LD_VAR 0 3
54618: PPUSH
54619: CALL_OW 310
54623: NOT
54624: PUSH
54625: LD_VAR 0 3
54629: PPUSH
54630: CALL_OW 314
54634: NOT
54635: AND
54636: IFFALSE 54664
// begin ComEnterUnit ( j , selected ) ;
54638: LD_VAR 0 3
54642: PPUSH
54643: LD_VAR 0 7
54647: PPUSH
54648: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54652: LD_VAR 0 3
54656: PPUSH
54657: LD_INT 15
54659: PPUSH
54660: CALL_OW 183
// end ;
54664: GO 54611
54666: POP
54667: POP
// end ; end ; end ; end ; end ;
54668: GO 54061
54670: POP
54671: POP
// end ;
54672: LD_VAR 0 1
54676: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54677: LD_INT 0
54679: PPUSH
54680: PPUSH
54681: PPUSH
54682: PPUSH
// if not mc_bases then
54683: LD_EXP 110
54687: NOT
54688: IFFALSE 54692
// exit ;
54690: GO 54870
// for i = 1 to mc_bases do
54692: LD_ADDR_VAR 0 2
54696: PUSH
54697: DOUBLE
54698: LD_INT 1
54700: DEC
54701: ST_TO_ADDR
54702: LD_EXP 110
54706: PUSH
54707: FOR_TO
54708: IFFALSE 54868
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54710: LD_ADDR_VAR 0 4
54714: PUSH
54715: LD_EXP 110
54719: PUSH
54720: LD_VAR 0 2
54724: ARRAY
54725: PPUSH
54726: LD_INT 25
54728: PUSH
54729: LD_INT 9
54731: PUSH
54732: EMPTY
54733: LIST
54734: LIST
54735: PPUSH
54736: CALL_OW 72
54740: ST_TO_ADDR
// if not tmp then
54741: LD_VAR 0 4
54745: NOT
54746: IFFALSE 54750
// continue ;
54748: GO 54707
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54750: LD_EXP 136
54754: PUSH
54755: LD_VAR 0 2
54759: ARRAY
54760: PPUSH
54761: LD_INT 29
54763: PPUSH
54764: CALL_OW 325
54768: NOT
54769: PUSH
54770: LD_EXP 136
54774: PUSH
54775: LD_VAR 0 2
54779: ARRAY
54780: PPUSH
54781: LD_INT 28
54783: PPUSH
54784: CALL_OW 325
54788: NOT
54789: AND
54790: IFFALSE 54794
// continue ;
54792: GO 54707
// for j in tmp do
54794: LD_ADDR_VAR 0 3
54798: PUSH
54799: LD_VAR 0 4
54803: PUSH
54804: FOR_IN
54805: IFFALSE 54864
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54807: LD_VAR 0 3
54811: PUSH
54812: LD_EXP 113
54816: PUSH
54817: LD_VAR 0 2
54821: ARRAY
54822: PUSH
54823: LD_INT 1
54825: ARRAY
54826: IN
54827: NOT
54828: PUSH
54829: LD_VAR 0 3
54833: PUSH
54834: LD_EXP 113
54838: PUSH
54839: LD_VAR 0 2
54843: ARRAY
54844: PUSH
54845: LD_INT 2
54847: ARRAY
54848: IN
54849: NOT
54850: AND
54851: IFFALSE 54862
// ComSpaceTimeShoot ( j ) ;
54853: LD_VAR 0 3
54857: PPUSH
54858: CALL 66008 0 1
54862: GO 54804
54864: POP
54865: POP
// end ;
54866: GO 54707
54868: POP
54869: POP
// end ;
54870: LD_VAR 0 1
54874: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54875: LD_INT 0
54877: PPUSH
54878: PPUSH
54879: PPUSH
54880: PPUSH
54881: PPUSH
54882: PPUSH
54883: PPUSH
54884: PPUSH
54885: PPUSH
// if not mc_bases then
54886: LD_EXP 110
54890: NOT
54891: IFFALSE 54895
// exit ;
54893: GO 55517
// for i = 1 to mc_bases do
54895: LD_ADDR_VAR 0 2
54899: PUSH
54900: DOUBLE
54901: LD_INT 1
54903: DEC
54904: ST_TO_ADDR
54905: LD_EXP 110
54909: PUSH
54910: FOR_TO
54911: IFFALSE 55515
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54913: LD_EXP 145
54917: PUSH
54918: LD_VAR 0 2
54922: ARRAY
54923: NOT
54924: PUSH
54925: LD_INT 38
54927: PPUSH
54928: LD_EXP 136
54932: PUSH
54933: LD_VAR 0 2
54937: ARRAY
54938: PPUSH
54939: CALL_OW 321
54943: PUSH
54944: LD_INT 2
54946: NONEQUAL
54947: OR
54948: IFFALSE 54952
// continue ;
54950: GO 54910
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54952: LD_ADDR_VAR 0 8
54956: PUSH
54957: LD_EXP 110
54961: PUSH
54962: LD_VAR 0 2
54966: ARRAY
54967: PPUSH
54968: LD_INT 30
54970: PUSH
54971: LD_INT 34
54973: PUSH
54974: EMPTY
54975: LIST
54976: LIST
54977: PPUSH
54978: CALL_OW 72
54982: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54983: LD_ADDR_VAR 0 9
54987: PUSH
54988: LD_EXP 110
54992: PUSH
54993: LD_VAR 0 2
54997: ARRAY
54998: PPUSH
54999: LD_INT 25
55001: PUSH
55002: LD_INT 4
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: PPUSH
55009: CALL_OW 72
55013: PPUSH
55014: LD_INT 0
55016: PPUSH
55017: CALL 98572 0 2
55021: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55022: LD_VAR 0 9
55026: NOT
55027: PUSH
55028: LD_VAR 0 8
55032: NOT
55033: OR
55034: PUSH
55035: LD_EXP 110
55039: PUSH
55040: LD_VAR 0 2
55044: ARRAY
55045: PPUSH
55046: LD_INT 124
55048: PPUSH
55049: CALL 98572 0 2
55053: OR
55054: IFFALSE 55058
// continue ;
55056: GO 54910
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55058: LD_EXP 146
55062: PUSH
55063: LD_VAR 0 2
55067: ARRAY
55068: PUSH
55069: LD_EXP 145
55073: PUSH
55074: LD_VAR 0 2
55078: ARRAY
55079: LESS
55080: PUSH
55081: LD_EXP 146
55085: PUSH
55086: LD_VAR 0 2
55090: ARRAY
55091: PUSH
55092: LD_VAR 0 8
55096: LESS
55097: AND
55098: IFFALSE 55513
// begin tmp := sci [ 1 ] ;
55100: LD_ADDR_VAR 0 7
55104: PUSH
55105: LD_VAR 0 9
55109: PUSH
55110: LD_INT 1
55112: ARRAY
55113: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55114: LD_VAR 0 7
55118: PPUSH
55119: LD_INT 124
55121: PPUSH
55122: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55126: LD_ADDR_VAR 0 3
55130: PUSH
55131: DOUBLE
55132: LD_EXP 145
55136: PUSH
55137: LD_VAR 0 2
55141: ARRAY
55142: INC
55143: ST_TO_ADDR
55144: LD_EXP 145
55148: PUSH
55149: LD_VAR 0 2
55153: ARRAY
55154: PUSH
55155: FOR_DOWNTO
55156: IFFALSE 55499
// begin if IsInUnit ( tmp ) then
55158: LD_VAR 0 7
55162: PPUSH
55163: CALL_OW 310
55167: IFFALSE 55178
// ComExitBuilding ( tmp ) ;
55169: LD_VAR 0 7
55173: PPUSH
55174: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55178: LD_INT 35
55180: PPUSH
55181: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55185: LD_VAR 0 7
55189: PPUSH
55190: CALL_OW 310
55194: NOT
55195: PUSH
55196: LD_VAR 0 7
55200: PPUSH
55201: CALL_OW 314
55205: NOT
55206: AND
55207: IFFALSE 55178
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55209: LD_ADDR_VAR 0 6
55213: PUSH
55214: LD_VAR 0 7
55218: PPUSH
55219: CALL_OW 250
55223: PUSH
55224: LD_VAR 0 7
55228: PPUSH
55229: CALL_OW 251
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55238: LD_INT 35
55240: PPUSH
55241: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55245: LD_ADDR_VAR 0 4
55249: PUSH
55250: LD_EXP 145
55254: PUSH
55255: LD_VAR 0 2
55259: ARRAY
55260: PUSH
55261: LD_VAR 0 3
55265: ARRAY
55266: PUSH
55267: LD_INT 1
55269: ARRAY
55270: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55271: LD_ADDR_VAR 0 5
55275: PUSH
55276: LD_EXP 145
55280: PUSH
55281: LD_VAR 0 2
55285: ARRAY
55286: PUSH
55287: LD_VAR 0 3
55291: ARRAY
55292: PUSH
55293: LD_INT 2
55295: ARRAY
55296: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55297: LD_VAR 0 7
55301: PPUSH
55302: LD_INT 10
55304: PPUSH
55305: CALL 72604 0 2
55309: PUSH
55310: LD_INT 4
55312: ARRAY
55313: IFFALSE 55351
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55315: LD_VAR 0 7
55319: PPUSH
55320: LD_VAR 0 6
55324: PUSH
55325: LD_INT 1
55327: ARRAY
55328: PPUSH
55329: LD_VAR 0 6
55333: PUSH
55334: LD_INT 2
55336: ARRAY
55337: PPUSH
55338: CALL_OW 111
// wait ( 0 0$10 ) ;
55342: LD_INT 350
55344: PPUSH
55345: CALL_OW 67
// end else
55349: GO 55377
// begin ComMoveXY ( tmp , x , y ) ;
55351: LD_VAR 0 7
55355: PPUSH
55356: LD_VAR 0 4
55360: PPUSH
55361: LD_VAR 0 5
55365: PPUSH
55366: CALL_OW 111
// wait ( 0 0$3 ) ;
55370: LD_INT 105
55372: PPUSH
55373: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55377: LD_VAR 0 7
55381: PPUSH
55382: LD_VAR 0 4
55386: PPUSH
55387: LD_VAR 0 5
55391: PPUSH
55392: CALL_OW 307
55396: IFFALSE 55238
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55398: LD_VAR 0 7
55402: PPUSH
55403: LD_VAR 0 4
55407: PPUSH
55408: LD_VAR 0 5
55412: PPUSH
55413: LD_VAR 0 8
55417: PUSH
55418: LD_VAR 0 3
55422: ARRAY
55423: PPUSH
55424: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55428: LD_INT 35
55430: PPUSH
55431: CALL_OW 67
// until not HasTask ( tmp ) ;
55435: LD_VAR 0 7
55439: PPUSH
55440: CALL_OW 314
55444: NOT
55445: IFFALSE 55428
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55447: LD_ADDR_EXP 146
55451: PUSH
55452: LD_EXP 146
55456: PPUSH
55457: LD_VAR 0 2
55461: PUSH
55462: LD_EXP 146
55466: PUSH
55467: LD_VAR 0 2
55471: ARRAY
55472: PUSH
55473: LD_INT 1
55475: PLUS
55476: PUSH
55477: EMPTY
55478: LIST
55479: LIST
55480: PPUSH
55481: LD_VAR 0 8
55485: PUSH
55486: LD_VAR 0 3
55490: ARRAY
55491: PPUSH
55492: CALL 70011 0 3
55496: ST_TO_ADDR
// end ;
55497: GO 55155
55499: POP
55500: POP
// MC_Reset ( i , 124 ) ;
55501: LD_VAR 0 2
55505: PPUSH
55506: LD_INT 124
55508: PPUSH
55509: CALL 39120 0 2
// end ; end ;
55513: GO 54910
55515: POP
55516: POP
// end ;
55517: LD_VAR 0 1
55521: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55522: LD_INT 0
55524: PPUSH
55525: PPUSH
55526: PPUSH
// if not mc_bases then
55527: LD_EXP 110
55531: NOT
55532: IFFALSE 55536
// exit ;
55534: GO 56142
// for i = 1 to mc_bases do
55536: LD_ADDR_VAR 0 2
55540: PUSH
55541: DOUBLE
55542: LD_INT 1
55544: DEC
55545: ST_TO_ADDR
55546: LD_EXP 110
55550: PUSH
55551: FOR_TO
55552: IFFALSE 56140
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55554: LD_ADDR_VAR 0 3
55558: PUSH
55559: LD_EXP 110
55563: PUSH
55564: LD_VAR 0 2
55568: ARRAY
55569: PPUSH
55570: LD_INT 25
55572: PUSH
55573: LD_INT 4
55575: PUSH
55576: EMPTY
55577: LIST
55578: LIST
55579: PPUSH
55580: CALL_OW 72
55584: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55585: LD_VAR 0 3
55589: NOT
55590: PUSH
55591: LD_EXP 147
55595: PUSH
55596: LD_VAR 0 2
55600: ARRAY
55601: NOT
55602: OR
55603: PUSH
55604: LD_EXP 110
55608: PUSH
55609: LD_VAR 0 2
55613: ARRAY
55614: PPUSH
55615: LD_INT 2
55617: PUSH
55618: LD_INT 30
55620: PUSH
55621: LD_INT 0
55623: PUSH
55624: EMPTY
55625: LIST
55626: LIST
55627: PUSH
55628: LD_INT 30
55630: PUSH
55631: LD_INT 1
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: PUSH
55638: EMPTY
55639: LIST
55640: LIST
55641: LIST
55642: PPUSH
55643: CALL_OW 72
55647: NOT
55648: OR
55649: IFFALSE 55699
// begin if mc_deposits_finder [ i ] then
55651: LD_EXP 148
55655: PUSH
55656: LD_VAR 0 2
55660: ARRAY
55661: IFFALSE 55697
// begin MC_Reset ( i , 125 ) ;
55663: LD_VAR 0 2
55667: PPUSH
55668: LD_INT 125
55670: PPUSH
55671: CALL 39120 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55675: LD_ADDR_EXP 148
55679: PUSH
55680: LD_EXP 148
55684: PPUSH
55685: LD_VAR 0 2
55689: PPUSH
55690: EMPTY
55691: PPUSH
55692: CALL_OW 1
55696: ST_TO_ADDR
// end ; continue ;
55697: GO 55551
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55699: LD_EXP 147
55703: PUSH
55704: LD_VAR 0 2
55708: ARRAY
55709: PUSH
55710: LD_INT 1
55712: ARRAY
55713: PUSH
55714: LD_INT 3
55716: ARRAY
55717: PUSH
55718: LD_INT 1
55720: EQUAL
55721: PUSH
55722: LD_INT 20
55724: PPUSH
55725: LD_EXP 136
55729: PUSH
55730: LD_VAR 0 2
55734: ARRAY
55735: PPUSH
55736: CALL_OW 321
55740: PUSH
55741: LD_INT 2
55743: NONEQUAL
55744: AND
55745: IFFALSE 55795
// begin if mc_deposits_finder [ i ] then
55747: LD_EXP 148
55751: PUSH
55752: LD_VAR 0 2
55756: ARRAY
55757: IFFALSE 55793
// begin MC_Reset ( i , 125 ) ;
55759: LD_VAR 0 2
55763: PPUSH
55764: LD_INT 125
55766: PPUSH
55767: CALL 39120 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55771: LD_ADDR_EXP 148
55775: PUSH
55776: LD_EXP 148
55780: PPUSH
55781: LD_VAR 0 2
55785: PPUSH
55786: EMPTY
55787: PPUSH
55788: CALL_OW 1
55792: ST_TO_ADDR
// end ; continue ;
55793: GO 55551
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55795: LD_EXP 147
55799: PUSH
55800: LD_VAR 0 2
55804: ARRAY
55805: PUSH
55806: LD_INT 1
55808: ARRAY
55809: PUSH
55810: LD_INT 1
55812: ARRAY
55813: PPUSH
55814: LD_EXP 147
55818: PUSH
55819: LD_VAR 0 2
55823: ARRAY
55824: PUSH
55825: LD_INT 1
55827: ARRAY
55828: PUSH
55829: LD_INT 2
55831: ARRAY
55832: PPUSH
55833: LD_EXP 136
55837: PUSH
55838: LD_VAR 0 2
55842: ARRAY
55843: PPUSH
55844: CALL_OW 440
55848: IFFALSE 55891
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55850: LD_ADDR_EXP 147
55854: PUSH
55855: LD_EXP 147
55859: PPUSH
55860: LD_VAR 0 2
55864: PPUSH
55865: LD_EXP 147
55869: PUSH
55870: LD_VAR 0 2
55874: ARRAY
55875: PPUSH
55876: LD_INT 1
55878: PPUSH
55879: CALL_OW 3
55883: PPUSH
55884: CALL_OW 1
55888: ST_TO_ADDR
55889: GO 56138
// begin if not mc_deposits_finder [ i ] then
55891: LD_EXP 148
55895: PUSH
55896: LD_VAR 0 2
55900: ARRAY
55901: NOT
55902: IFFALSE 55954
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55904: LD_ADDR_EXP 148
55908: PUSH
55909: LD_EXP 148
55913: PPUSH
55914: LD_VAR 0 2
55918: PPUSH
55919: LD_VAR 0 3
55923: PUSH
55924: LD_INT 1
55926: ARRAY
55927: PUSH
55928: EMPTY
55929: LIST
55930: PPUSH
55931: CALL_OW 1
55935: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55936: LD_VAR 0 3
55940: PUSH
55941: LD_INT 1
55943: ARRAY
55944: PPUSH
55945: LD_INT 125
55947: PPUSH
55948: CALL_OW 109
// end else
55952: GO 56138
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55954: LD_EXP 148
55958: PUSH
55959: LD_VAR 0 2
55963: ARRAY
55964: PUSH
55965: LD_INT 1
55967: ARRAY
55968: PPUSH
55969: CALL_OW 310
55973: IFFALSE 55996
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55975: LD_EXP 148
55979: PUSH
55980: LD_VAR 0 2
55984: ARRAY
55985: PUSH
55986: LD_INT 1
55988: ARRAY
55989: PPUSH
55990: CALL_OW 122
55994: GO 56138
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55996: LD_EXP 148
56000: PUSH
56001: LD_VAR 0 2
56005: ARRAY
56006: PUSH
56007: LD_INT 1
56009: ARRAY
56010: PPUSH
56011: CALL_OW 314
56015: NOT
56016: PUSH
56017: LD_EXP 148
56021: PUSH
56022: LD_VAR 0 2
56026: ARRAY
56027: PUSH
56028: LD_INT 1
56030: ARRAY
56031: PPUSH
56032: LD_EXP 147
56036: PUSH
56037: LD_VAR 0 2
56041: ARRAY
56042: PUSH
56043: LD_INT 1
56045: ARRAY
56046: PUSH
56047: LD_INT 1
56049: ARRAY
56050: PPUSH
56051: LD_EXP 147
56055: PUSH
56056: LD_VAR 0 2
56060: ARRAY
56061: PUSH
56062: LD_INT 1
56064: ARRAY
56065: PUSH
56066: LD_INT 2
56068: ARRAY
56069: PPUSH
56070: CALL_OW 297
56074: PUSH
56075: LD_INT 6
56077: GREATER
56078: AND
56079: IFFALSE 56138
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56081: LD_EXP 148
56085: PUSH
56086: LD_VAR 0 2
56090: ARRAY
56091: PUSH
56092: LD_INT 1
56094: ARRAY
56095: PPUSH
56096: LD_EXP 147
56100: PUSH
56101: LD_VAR 0 2
56105: ARRAY
56106: PUSH
56107: LD_INT 1
56109: ARRAY
56110: PUSH
56111: LD_INT 1
56113: ARRAY
56114: PPUSH
56115: LD_EXP 147
56119: PUSH
56120: LD_VAR 0 2
56124: ARRAY
56125: PUSH
56126: LD_INT 1
56128: ARRAY
56129: PUSH
56130: LD_INT 2
56132: ARRAY
56133: PPUSH
56134: CALL_OW 111
// end ; end ; end ;
56138: GO 55551
56140: POP
56141: POP
// end ;
56142: LD_VAR 0 1
56146: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56147: LD_INT 0
56149: PPUSH
56150: PPUSH
56151: PPUSH
56152: PPUSH
56153: PPUSH
56154: PPUSH
56155: PPUSH
56156: PPUSH
56157: PPUSH
56158: PPUSH
56159: PPUSH
// if not mc_bases then
56160: LD_EXP 110
56164: NOT
56165: IFFALSE 56169
// exit ;
56167: GO 57109
// for i = 1 to mc_bases do
56169: LD_ADDR_VAR 0 2
56173: PUSH
56174: DOUBLE
56175: LD_INT 1
56177: DEC
56178: ST_TO_ADDR
56179: LD_EXP 110
56183: PUSH
56184: FOR_TO
56185: IFFALSE 57107
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56187: LD_EXP 110
56191: PUSH
56192: LD_VAR 0 2
56196: ARRAY
56197: NOT
56198: PUSH
56199: LD_EXP 133
56203: PUSH
56204: LD_VAR 0 2
56208: ARRAY
56209: OR
56210: IFFALSE 56214
// continue ;
56212: GO 56184
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56214: LD_ADDR_VAR 0 7
56218: PUSH
56219: LD_EXP 110
56223: PUSH
56224: LD_VAR 0 2
56228: ARRAY
56229: PUSH
56230: LD_INT 1
56232: ARRAY
56233: PPUSH
56234: CALL_OW 248
56238: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56239: LD_VAR 0 7
56243: PUSH
56244: LD_INT 3
56246: EQUAL
56247: PUSH
56248: LD_EXP 129
56252: PUSH
56253: LD_VAR 0 2
56257: ARRAY
56258: PUSH
56259: LD_EXP 132
56263: PUSH
56264: LD_VAR 0 2
56268: ARRAY
56269: UNION
56270: PPUSH
56271: LD_INT 33
56273: PUSH
56274: LD_INT 2
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: PPUSH
56281: CALL_OW 72
56285: NOT
56286: OR
56287: IFFALSE 56291
// continue ;
56289: GO 56184
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56291: LD_ADDR_VAR 0 9
56295: PUSH
56296: LD_EXP 110
56300: PUSH
56301: LD_VAR 0 2
56305: ARRAY
56306: PPUSH
56307: LD_INT 30
56309: PUSH
56310: LD_INT 36
56312: PUSH
56313: EMPTY
56314: LIST
56315: LIST
56316: PPUSH
56317: CALL_OW 72
56321: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56322: LD_ADDR_VAR 0 10
56326: PUSH
56327: LD_EXP 129
56331: PUSH
56332: LD_VAR 0 2
56336: ARRAY
56337: PPUSH
56338: LD_INT 34
56340: PUSH
56341: LD_INT 31
56343: PUSH
56344: EMPTY
56345: LIST
56346: LIST
56347: PPUSH
56348: CALL_OW 72
56352: ST_TO_ADDR
// if not cts and not mcts then
56353: LD_VAR 0 9
56357: NOT
56358: PUSH
56359: LD_VAR 0 10
56363: NOT
56364: AND
56365: IFFALSE 56369
// continue ;
56367: GO 56184
// x := cts ;
56369: LD_ADDR_VAR 0 11
56373: PUSH
56374: LD_VAR 0 9
56378: ST_TO_ADDR
// if not x then
56379: LD_VAR 0 11
56383: NOT
56384: IFFALSE 56396
// x := mcts ;
56386: LD_ADDR_VAR 0 11
56390: PUSH
56391: LD_VAR 0 10
56395: ST_TO_ADDR
// if not x then
56396: LD_VAR 0 11
56400: NOT
56401: IFFALSE 56405
// continue ;
56403: GO 56184
// if mc_remote_driver [ i ] then
56405: LD_EXP 150
56409: PUSH
56410: LD_VAR 0 2
56414: ARRAY
56415: IFFALSE 56802
// for j in mc_remote_driver [ i ] do
56417: LD_ADDR_VAR 0 3
56421: PUSH
56422: LD_EXP 150
56426: PUSH
56427: LD_VAR 0 2
56431: ARRAY
56432: PUSH
56433: FOR_IN
56434: IFFALSE 56800
// begin if GetClass ( j ) <> 3 then
56436: LD_VAR 0 3
56440: PPUSH
56441: CALL_OW 257
56445: PUSH
56446: LD_INT 3
56448: NONEQUAL
56449: IFFALSE 56502
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56451: LD_ADDR_EXP 150
56455: PUSH
56456: LD_EXP 150
56460: PPUSH
56461: LD_VAR 0 2
56465: PPUSH
56466: LD_EXP 150
56470: PUSH
56471: LD_VAR 0 2
56475: ARRAY
56476: PUSH
56477: LD_VAR 0 3
56481: DIFF
56482: PPUSH
56483: CALL_OW 1
56487: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56488: LD_VAR 0 3
56492: PPUSH
56493: LD_INT 0
56495: PPUSH
56496: CALL_OW 109
// continue ;
56500: GO 56433
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56502: LD_EXP 129
56506: PUSH
56507: LD_VAR 0 2
56511: ARRAY
56512: PPUSH
56513: LD_INT 34
56515: PUSH
56516: LD_INT 31
56518: PUSH
56519: EMPTY
56520: LIST
56521: LIST
56522: PUSH
56523: LD_INT 58
56525: PUSH
56526: EMPTY
56527: LIST
56528: PUSH
56529: EMPTY
56530: LIST
56531: LIST
56532: PPUSH
56533: CALL_OW 72
56537: PUSH
56538: LD_VAR 0 3
56542: PPUSH
56543: CALL 98660 0 1
56547: NOT
56548: AND
56549: IFFALSE 56620
// begin if IsInUnit ( j ) then
56551: LD_VAR 0 3
56555: PPUSH
56556: CALL_OW 310
56560: IFFALSE 56571
// ComExitBuilding ( j ) ;
56562: LD_VAR 0 3
56566: PPUSH
56567: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56571: LD_VAR 0 3
56575: PPUSH
56576: LD_EXP 129
56580: PUSH
56581: LD_VAR 0 2
56585: ARRAY
56586: PPUSH
56587: LD_INT 34
56589: PUSH
56590: LD_INT 31
56592: PUSH
56593: EMPTY
56594: LIST
56595: LIST
56596: PUSH
56597: LD_INT 58
56599: PUSH
56600: EMPTY
56601: LIST
56602: PUSH
56603: EMPTY
56604: LIST
56605: LIST
56606: PPUSH
56607: CALL_OW 72
56611: PUSH
56612: LD_INT 1
56614: ARRAY
56615: PPUSH
56616: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56620: LD_VAR 0 3
56624: PPUSH
56625: CALL_OW 310
56629: NOT
56630: PUSH
56631: LD_VAR 0 3
56635: PPUSH
56636: CALL_OW 310
56640: PPUSH
56641: CALL_OW 266
56645: PUSH
56646: LD_INT 36
56648: NONEQUAL
56649: PUSH
56650: LD_VAR 0 3
56654: PPUSH
56655: CALL 98660 0 1
56659: NOT
56660: AND
56661: OR
56662: IFFALSE 56798
// begin if IsInUnit ( j ) then
56664: LD_VAR 0 3
56668: PPUSH
56669: CALL_OW 310
56673: IFFALSE 56684
// ComExitBuilding ( j ) ;
56675: LD_VAR 0 3
56679: PPUSH
56680: CALL_OW 122
// ct := 0 ;
56684: LD_ADDR_VAR 0 8
56688: PUSH
56689: LD_INT 0
56691: ST_TO_ADDR
// for k in x do
56692: LD_ADDR_VAR 0 4
56696: PUSH
56697: LD_VAR 0 11
56701: PUSH
56702: FOR_IN
56703: IFFALSE 56776
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56705: LD_VAR 0 4
56709: PPUSH
56710: CALL_OW 264
56714: PUSH
56715: LD_INT 31
56717: EQUAL
56718: PUSH
56719: LD_VAR 0 4
56723: PPUSH
56724: CALL_OW 311
56728: NOT
56729: AND
56730: PUSH
56731: LD_VAR 0 4
56735: PPUSH
56736: CALL_OW 266
56740: PUSH
56741: LD_INT 36
56743: EQUAL
56744: PUSH
56745: LD_VAR 0 4
56749: PPUSH
56750: CALL_OW 313
56754: PUSH
56755: LD_INT 3
56757: LESS
56758: AND
56759: OR
56760: IFFALSE 56774
// begin ct := k ;
56762: LD_ADDR_VAR 0 8
56766: PUSH
56767: LD_VAR 0 4
56771: ST_TO_ADDR
// break ;
56772: GO 56776
// end ;
56774: GO 56702
56776: POP
56777: POP
// if ct then
56778: LD_VAR 0 8
56782: IFFALSE 56798
// ComEnterUnit ( j , ct ) ;
56784: LD_VAR 0 3
56788: PPUSH
56789: LD_VAR 0 8
56793: PPUSH
56794: CALL_OW 120
// end ; end ;
56798: GO 56433
56800: POP
56801: POP
// places := 0 ;
56802: LD_ADDR_VAR 0 5
56806: PUSH
56807: LD_INT 0
56809: ST_TO_ADDR
// for j = 1 to x do
56810: LD_ADDR_VAR 0 3
56814: PUSH
56815: DOUBLE
56816: LD_INT 1
56818: DEC
56819: ST_TO_ADDR
56820: LD_VAR 0 11
56824: PUSH
56825: FOR_TO
56826: IFFALSE 56902
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56828: LD_VAR 0 11
56832: PUSH
56833: LD_VAR 0 3
56837: ARRAY
56838: PPUSH
56839: CALL_OW 264
56843: PUSH
56844: LD_INT 31
56846: EQUAL
56847: IFFALSE 56865
// places := places + 1 else
56849: LD_ADDR_VAR 0 5
56853: PUSH
56854: LD_VAR 0 5
56858: PUSH
56859: LD_INT 1
56861: PLUS
56862: ST_TO_ADDR
56863: GO 56900
// if GetBType ( x [ j ] ) = b_control_tower then
56865: LD_VAR 0 11
56869: PUSH
56870: LD_VAR 0 3
56874: ARRAY
56875: PPUSH
56876: CALL_OW 266
56880: PUSH
56881: LD_INT 36
56883: EQUAL
56884: IFFALSE 56900
// places := places + 3 ;
56886: LD_ADDR_VAR 0 5
56890: PUSH
56891: LD_VAR 0 5
56895: PUSH
56896: LD_INT 3
56898: PLUS
56899: ST_TO_ADDR
56900: GO 56825
56902: POP
56903: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56904: LD_VAR 0 5
56908: PUSH
56909: LD_INT 0
56911: EQUAL
56912: PUSH
56913: LD_VAR 0 5
56917: PUSH
56918: LD_EXP 150
56922: PUSH
56923: LD_VAR 0 2
56927: ARRAY
56928: LESSEQUAL
56929: OR
56930: IFFALSE 56934
// continue ;
56932: GO 56184
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56934: LD_ADDR_VAR 0 6
56938: PUSH
56939: LD_EXP 110
56943: PUSH
56944: LD_VAR 0 2
56948: ARRAY
56949: PPUSH
56950: LD_INT 25
56952: PUSH
56953: LD_INT 3
56955: PUSH
56956: EMPTY
56957: LIST
56958: LIST
56959: PPUSH
56960: CALL_OW 72
56964: PUSH
56965: LD_EXP 150
56969: PUSH
56970: LD_VAR 0 2
56974: ARRAY
56975: DIFF
56976: PPUSH
56977: LD_INT 3
56979: PPUSH
56980: CALL 99560 0 2
56984: ST_TO_ADDR
// for j in tmp do
56985: LD_ADDR_VAR 0 3
56989: PUSH
56990: LD_VAR 0 6
56994: PUSH
56995: FOR_IN
56996: IFFALSE 57031
// if GetTag ( j ) > 0 then
56998: LD_VAR 0 3
57002: PPUSH
57003: CALL_OW 110
57007: PUSH
57008: LD_INT 0
57010: GREATER
57011: IFFALSE 57029
// tmp := tmp diff j ;
57013: LD_ADDR_VAR 0 6
57017: PUSH
57018: LD_VAR 0 6
57022: PUSH
57023: LD_VAR 0 3
57027: DIFF
57028: ST_TO_ADDR
57029: GO 56995
57031: POP
57032: POP
// if not tmp then
57033: LD_VAR 0 6
57037: NOT
57038: IFFALSE 57042
// continue ;
57040: GO 56184
// if places then
57042: LD_VAR 0 5
57046: IFFALSE 57105
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57048: LD_ADDR_EXP 150
57052: PUSH
57053: LD_EXP 150
57057: PPUSH
57058: LD_VAR 0 2
57062: PPUSH
57063: LD_EXP 150
57067: PUSH
57068: LD_VAR 0 2
57072: ARRAY
57073: PUSH
57074: LD_VAR 0 6
57078: PUSH
57079: LD_INT 1
57081: ARRAY
57082: UNION
57083: PPUSH
57084: CALL_OW 1
57088: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57089: LD_VAR 0 6
57093: PUSH
57094: LD_INT 1
57096: ARRAY
57097: PPUSH
57098: LD_INT 126
57100: PPUSH
57101: CALL_OW 109
// end ; end ;
57105: GO 56184
57107: POP
57108: POP
// end ;
57109: LD_VAR 0 1
57113: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57114: LD_INT 0
57116: PPUSH
57117: PPUSH
57118: PPUSH
57119: PPUSH
57120: PPUSH
57121: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57122: LD_VAR 0 1
57126: NOT
57127: PUSH
57128: LD_VAR 0 2
57132: NOT
57133: OR
57134: PUSH
57135: LD_VAR 0 3
57139: NOT
57140: OR
57141: PUSH
57142: LD_VAR 0 4
57146: PUSH
57147: LD_INT 1
57149: PUSH
57150: LD_INT 2
57152: PUSH
57153: LD_INT 3
57155: PUSH
57156: LD_INT 4
57158: PUSH
57159: LD_INT 5
57161: PUSH
57162: LD_INT 8
57164: PUSH
57165: LD_INT 9
57167: PUSH
57168: LD_INT 15
57170: PUSH
57171: LD_INT 16
57173: PUSH
57174: EMPTY
57175: LIST
57176: LIST
57177: LIST
57178: LIST
57179: LIST
57180: LIST
57181: LIST
57182: LIST
57183: LIST
57184: IN
57185: NOT
57186: OR
57187: IFFALSE 57191
// exit ;
57189: GO 58091
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57191: LD_ADDR_VAR 0 2
57195: PUSH
57196: LD_VAR 0 2
57200: PPUSH
57201: LD_INT 21
57203: PUSH
57204: LD_INT 3
57206: PUSH
57207: EMPTY
57208: LIST
57209: LIST
57210: PUSH
57211: LD_INT 24
57213: PUSH
57214: LD_INT 250
57216: PUSH
57217: EMPTY
57218: LIST
57219: LIST
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PPUSH
57225: CALL_OW 72
57229: ST_TO_ADDR
// case class of 1 , 15 :
57230: LD_VAR 0 4
57234: PUSH
57235: LD_INT 1
57237: DOUBLE
57238: EQUAL
57239: IFTRUE 57249
57241: LD_INT 15
57243: DOUBLE
57244: EQUAL
57245: IFTRUE 57249
57247: GO 57334
57249: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57250: LD_ADDR_VAR 0 8
57254: PUSH
57255: LD_VAR 0 2
57259: PPUSH
57260: LD_INT 2
57262: PUSH
57263: LD_INT 30
57265: PUSH
57266: LD_INT 32
57268: PUSH
57269: EMPTY
57270: LIST
57271: LIST
57272: PUSH
57273: LD_INT 30
57275: PUSH
57276: LD_INT 31
57278: PUSH
57279: EMPTY
57280: LIST
57281: LIST
57282: PUSH
57283: EMPTY
57284: LIST
57285: LIST
57286: LIST
57287: PPUSH
57288: CALL_OW 72
57292: PUSH
57293: LD_VAR 0 2
57297: PPUSH
57298: LD_INT 2
57300: PUSH
57301: LD_INT 30
57303: PUSH
57304: LD_INT 4
57306: PUSH
57307: EMPTY
57308: LIST
57309: LIST
57310: PUSH
57311: LD_INT 30
57313: PUSH
57314: LD_INT 5
57316: PUSH
57317: EMPTY
57318: LIST
57319: LIST
57320: PUSH
57321: EMPTY
57322: LIST
57323: LIST
57324: LIST
57325: PPUSH
57326: CALL_OW 72
57330: ADD
57331: ST_TO_ADDR
57332: GO 57580
57334: LD_INT 2
57336: DOUBLE
57337: EQUAL
57338: IFTRUE 57348
57340: LD_INT 16
57342: DOUBLE
57343: EQUAL
57344: IFTRUE 57348
57346: GO 57394
57348: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57349: LD_ADDR_VAR 0 8
57353: PUSH
57354: LD_VAR 0 2
57358: PPUSH
57359: LD_INT 2
57361: PUSH
57362: LD_INT 30
57364: PUSH
57365: LD_INT 0
57367: PUSH
57368: EMPTY
57369: LIST
57370: LIST
57371: PUSH
57372: LD_INT 30
57374: PUSH
57375: LD_INT 1
57377: PUSH
57378: EMPTY
57379: LIST
57380: LIST
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: LIST
57386: PPUSH
57387: CALL_OW 72
57391: ST_TO_ADDR
57392: GO 57580
57394: LD_INT 3
57396: DOUBLE
57397: EQUAL
57398: IFTRUE 57402
57400: GO 57448
57402: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57403: LD_ADDR_VAR 0 8
57407: PUSH
57408: LD_VAR 0 2
57412: PPUSH
57413: LD_INT 2
57415: PUSH
57416: LD_INT 30
57418: PUSH
57419: LD_INT 2
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: PUSH
57426: LD_INT 30
57428: PUSH
57429: LD_INT 3
57431: PUSH
57432: EMPTY
57433: LIST
57434: LIST
57435: PUSH
57436: EMPTY
57437: LIST
57438: LIST
57439: LIST
57440: PPUSH
57441: CALL_OW 72
57445: ST_TO_ADDR
57446: GO 57580
57448: LD_INT 4
57450: DOUBLE
57451: EQUAL
57452: IFTRUE 57456
57454: GO 57513
57456: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57457: LD_ADDR_VAR 0 8
57461: PUSH
57462: LD_VAR 0 2
57466: PPUSH
57467: LD_INT 2
57469: PUSH
57470: LD_INT 30
57472: PUSH
57473: LD_INT 6
57475: PUSH
57476: EMPTY
57477: LIST
57478: LIST
57479: PUSH
57480: LD_INT 30
57482: PUSH
57483: LD_INT 7
57485: PUSH
57486: EMPTY
57487: LIST
57488: LIST
57489: PUSH
57490: LD_INT 30
57492: PUSH
57493: LD_INT 8
57495: PUSH
57496: EMPTY
57497: LIST
57498: LIST
57499: PUSH
57500: EMPTY
57501: LIST
57502: LIST
57503: LIST
57504: LIST
57505: PPUSH
57506: CALL_OW 72
57510: ST_TO_ADDR
57511: GO 57580
57513: LD_INT 5
57515: DOUBLE
57516: EQUAL
57517: IFTRUE 57533
57519: LD_INT 8
57521: DOUBLE
57522: EQUAL
57523: IFTRUE 57533
57525: LD_INT 9
57527: DOUBLE
57528: EQUAL
57529: IFTRUE 57533
57531: GO 57579
57533: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57534: LD_ADDR_VAR 0 8
57538: PUSH
57539: LD_VAR 0 2
57543: PPUSH
57544: LD_INT 2
57546: PUSH
57547: LD_INT 30
57549: PUSH
57550: LD_INT 4
57552: PUSH
57553: EMPTY
57554: LIST
57555: LIST
57556: PUSH
57557: LD_INT 30
57559: PUSH
57560: LD_INT 5
57562: PUSH
57563: EMPTY
57564: LIST
57565: LIST
57566: PUSH
57567: EMPTY
57568: LIST
57569: LIST
57570: LIST
57571: PPUSH
57572: CALL_OW 72
57576: ST_TO_ADDR
57577: GO 57580
57579: POP
// if not tmp then
57580: LD_VAR 0 8
57584: NOT
57585: IFFALSE 57589
// exit ;
57587: GO 58091
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57589: LD_VAR 0 4
57593: PUSH
57594: LD_INT 1
57596: PUSH
57597: LD_INT 15
57599: PUSH
57600: EMPTY
57601: LIST
57602: LIST
57603: IN
57604: PUSH
57605: LD_EXP 119
57609: PUSH
57610: LD_VAR 0 1
57614: ARRAY
57615: AND
57616: IFFALSE 57772
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57618: LD_ADDR_VAR 0 9
57622: PUSH
57623: LD_EXP 119
57627: PUSH
57628: LD_VAR 0 1
57632: ARRAY
57633: PUSH
57634: LD_INT 1
57636: ARRAY
57637: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57638: LD_VAR 0 9
57642: PUSH
57643: LD_EXP 120
57647: PUSH
57648: LD_VAR 0 1
57652: ARRAY
57653: IN
57654: NOT
57655: IFFALSE 57770
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57657: LD_ADDR_EXP 120
57661: PUSH
57662: LD_EXP 120
57666: PPUSH
57667: LD_VAR 0 1
57671: PUSH
57672: LD_EXP 120
57676: PUSH
57677: LD_VAR 0 1
57681: ARRAY
57682: PUSH
57683: LD_INT 1
57685: PLUS
57686: PUSH
57687: EMPTY
57688: LIST
57689: LIST
57690: PPUSH
57691: LD_VAR 0 9
57695: PPUSH
57696: CALL 70011 0 3
57700: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57701: LD_ADDR_EXP 119
57705: PUSH
57706: LD_EXP 119
57710: PPUSH
57711: LD_VAR 0 1
57715: PPUSH
57716: LD_EXP 119
57720: PUSH
57721: LD_VAR 0 1
57725: ARRAY
57726: PUSH
57727: LD_VAR 0 9
57731: DIFF
57732: PPUSH
57733: CALL_OW 1
57737: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57738: LD_VAR 0 3
57742: PPUSH
57743: LD_EXP 120
57747: PUSH
57748: LD_VAR 0 1
57752: ARRAY
57753: PUSH
57754: LD_EXP 120
57758: PUSH
57759: LD_VAR 0 1
57763: ARRAY
57764: ARRAY
57765: PPUSH
57766: CALL_OW 120
// end ; exit ;
57770: GO 58091
// end ; if tmp > 1 then
57772: LD_VAR 0 8
57776: PUSH
57777: LD_INT 1
57779: GREATER
57780: IFFALSE 57884
// for i = 2 to tmp do
57782: LD_ADDR_VAR 0 6
57786: PUSH
57787: DOUBLE
57788: LD_INT 2
57790: DEC
57791: ST_TO_ADDR
57792: LD_VAR 0 8
57796: PUSH
57797: FOR_TO
57798: IFFALSE 57882
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57800: LD_VAR 0 8
57804: PUSH
57805: LD_VAR 0 6
57809: ARRAY
57810: PPUSH
57811: CALL_OW 461
57815: PUSH
57816: LD_INT 6
57818: EQUAL
57819: IFFALSE 57880
// begin x := tmp [ i ] ;
57821: LD_ADDR_VAR 0 9
57825: PUSH
57826: LD_VAR 0 8
57830: PUSH
57831: LD_VAR 0 6
57835: ARRAY
57836: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57837: LD_ADDR_VAR 0 8
57841: PUSH
57842: LD_VAR 0 8
57846: PPUSH
57847: LD_VAR 0 6
57851: PPUSH
57852: CALL_OW 3
57856: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57857: LD_ADDR_VAR 0 8
57861: PUSH
57862: LD_VAR 0 8
57866: PPUSH
57867: LD_INT 1
57869: PPUSH
57870: LD_VAR 0 9
57874: PPUSH
57875: CALL_OW 2
57879: ST_TO_ADDR
// end ;
57880: GO 57797
57882: POP
57883: POP
// for i in tmp do
57884: LD_ADDR_VAR 0 6
57888: PUSH
57889: LD_VAR 0 8
57893: PUSH
57894: FOR_IN
57895: IFFALSE 57964
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57897: LD_VAR 0 6
57901: PPUSH
57902: CALL_OW 313
57906: PUSH
57907: LD_INT 6
57909: LESS
57910: PUSH
57911: LD_VAR 0 6
57915: PPUSH
57916: CALL_OW 266
57920: PUSH
57921: LD_INT 31
57923: PUSH
57924: LD_INT 32
57926: PUSH
57927: EMPTY
57928: LIST
57929: LIST
57930: IN
57931: NOT
57932: AND
57933: PUSH
57934: LD_VAR 0 6
57938: PPUSH
57939: CALL_OW 313
57943: PUSH
57944: LD_INT 0
57946: EQUAL
57947: OR
57948: IFFALSE 57962
// begin j := i ;
57950: LD_ADDR_VAR 0 7
57954: PUSH
57955: LD_VAR 0 6
57959: ST_TO_ADDR
// break ;
57960: GO 57964
// end ; end ;
57962: GO 57894
57964: POP
57965: POP
// if j then
57966: LD_VAR 0 7
57970: IFFALSE 57988
// ComEnterUnit ( unit , j ) else
57972: LD_VAR 0 3
57976: PPUSH
57977: LD_VAR 0 7
57981: PPUSH
57982: CALL_OW 120
57986: GO 58091
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57988: LD_ADDR_VAR 0 10
57992: PUSH
57993: LD_VAR 0 2
57997: PPUSH
57998: LD_INT 2
58000: PUSH
58001: LD_INT 30
58003: PUSH
58004: LD_INT 0
58006: PUSH
58007: EMPTY
58008: LIST
58009: LIST
58010: PUSH
58011: LD_INT 30
58013: PUSH
58014: LD_INT 1
58016: PUSH
58017: EMPTY
58018: LIST
58019: LIST
58020: PUSH
58021: EMPTY
58022: LIST
58023: LIST
58024: LIST
58025: PPUSH
58026: CALL_OW 72
58030: ST_TO_ADDR
// if depot then
58031: LD_VAR 0 10
58035: IFFALSE 58091
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58037: LD_ADDR_VAR 0 10
58041: PUSH
58042: LD_VAR 0 10
58046: PPUSH
58047: LD_VAR 0 3
58051: PPUSH
58052: CALL_OW 74
58056: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58057: LD_VAR 0 3
58061: PPUSH
58062: LD_VAR 0 10
58066: PPUSH
58067: CALL_OW 296
58071: PUSH
58072: LD_INT 10
58074: GREATER
58075: IFFALSE 58091
// ComStandNearbyBuilding ( unit , depot ) ;
58077: LD_VAR 0 3
58081: PPUSH
58082: LD_VAR 0 10
58086: PPUSH
58087: CALL 66625 0 2
// end ; end ; end ;
58091: LD_VAR 0 5
58095: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58096: LD_INT 0
58098: PPUSH
58099: PPUSH
58100: PPUSH
58101: PPUSH
// if not mc_bases then
58102: LD_EXP 110
58106: NOT
58107: IFFALSE 58111
// exit ;
58109: GO 58350
// for i = 1 to mc_bases do
58111: LD_ADDR_VAR 0 2
58115: PUSH
58116: DOUBLE
58117: LD_INT 1
58119: DEC
58120: ST_TO_ADDR
58121: LD_EXP 110
58125: PUSH
58126: FOR_TO
58127: IFFALSE 58348
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58129: LD_ADDR_VAR 0 4
58133: PUSH
58134: LD_EXP 110
58138: PUSH
58139: LD_VAR 0 2
58143: ARRAY
58144: PPUSH
58145: LD_INT 21
58147: PUSH
58148: LD_INT 1
58150: PUSH
58151: EMPTY
58152: LIST
58153: LIST
58154: PPUSH
58155: CALL_OW 72
58159: PUSH
58160: LD_EXP 139
58164: PUSH
58165: LD_VAR 0 2
58169: ARRAY
58170: UNION
58171: ST_TO_ADDR
// if not tmp then
58172: LD_VAR 0 4
58176: NOT
58177: IFFALSE 58181
// continue ;
58179: GO 58126
// for j in tmp do
58181: LD_ADDR_VAR 0 3
58185: PUSH
58186: LD_VAR 0 4
58190: PUSH
58191: FOR_IN
58192: IFFALSE 58344
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58194: LD_VAR 0 3
58198: PPUSH
58199: CALL_OW 110
58203: NOT
58204: PUSH
58205: LD_VAR 0 3
58209: PPUSH
58210: CALL_OW 314
58214: NOT
58215: AND
58216: PUSH
58217: LD_VAR 0 3
58221: PPUSH
58222: CALL_OW 311
58226: NOT
58227: AND
58228: PUSH
58229: LD_VAR 0 3
58233: PPUSH
58234: CALL_OW 310
58238: NOT
58239: AND
58240: PUSH
58241: LD_VAR 0 3
58245: PUSH
58246: LD_EXP 113
58250: PUSH
58251: LD_VAR 0 2
58255: ARRAY
58256: PUSH
58257: LD_INT 1
58259: ARRAY
58260: IN
58261: NOT
58262: AND
58263: PUSH
58264: LD_VAR 0 3
58268: PUSH
58269: LD_EXP 113
58273: PUSH
58274: LD_VAR 0 2
58278: ARRAY
58279: PUSH
58280: LD_INT 2
58282: ARRAY
58283: IN
58284: NOT
58285: AND
58286: PUSH
58287: LD_VAR 0 3
58291: PUSH
58292: LD_EXP 122
58296: PUSH
58297: LD_VAR 0 2
58301: ARRAY
58302: IN
58303: NOT
58304: AND
58305: IFFALSE 58342
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58307: LD_VAR 0 2
58311: PPUSH
58312: LD_EXP 110
58316: PUSH
58317: LD_VAR 0 2
58321: ARRAY
58322: PPUSH
58323: LD_VAR 0 3
58327: PPUSH
58328: LD_VAR 0 3
58332: PPUSH
58333: CALL_OW 257
58337: PPUSH
58338: CALL 57114 0 4
// end ;
58342: GO 58191
58344: POP
58345: POP
// end ;
58346: GO 58126
58348: POP
58349: POP
// end ;
58350: LD_VAR 0 1
58354: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58355: LD_INT 0
58357: PPUSH
58358: PPUSH
58359: PPUSH
58360: PPUSH
58361: PPUSH
58362: PPUSH
// if not mc_bases [ base ] then
58363: LD_EXP 110
58367: PUSH
58368: LD_VAR 0 1
58372: ARRAY
58373: NOT
58374: IFFALSE 58378
// exit ;
58376: GO 58560
// tmp := [ ] ;
58378: LD_ADDR_VAR 0 6
58382: PUSH
58383: EMPTY
58384: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58385: LD_ADDR_VAR 0 7
58389: PUSH
58390: LD_VAR 0 3
58394: PPUSH
58395: LD_INT 0
58397: PPUSH
58398: CALL_OW 517
58402: ST_TO_ADDR
// if not list then
58403: LD_VAR 0 7
58407: NOT
58408: IFFALSE 58412
// exit ;
58410: GO 58560
// for i = 1 to amount do
58412: LD_ADDR_VAR 0 5
58416: PUSH
58417: DOUBLE
58418: LD_INT 1
58420: DEC
58421: ST_TO_ADDR
58422: LD_VAR 0 2
58426: PUSH
58427: FOR_TO
58428: IFFALSE 58508
// begin x := rand ( 1 , list [ 1 ] ) ;
58430: LD_ADDR_VAR 0 8
58434: PUSH
58435: LD_INT 1
58437: PPUSH
58438: LD_VAR 0 7
58442: PUSH
58443: LD_INT 1
58445: ARRAY
58446: PPUSH
58447: CALL_OW 12
58451: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58452: LD_ADDR_VAR 0 6
58456: PUSH
58457: LD_VAR 0 6
58461: PPUSH
58462: LD_VAR 0 5
58466: PPUSH
58467: LD_VAR 0 7
58471: PUSH
58472: LD_INT 1
58474: ARRAY
58475: PUSH
58476: LD_VAR 0 8
58480: ARRAY
58481: PUSH
58482: LD_VAR 0 7
58486: PUSH
58487: LD_INT 2
58489: ARRAY
58490: PUSH
58491: LD_VAR 0 8
58495: ARRAY
58496: PUSH
58497: EMPTY
58498: LIST
58499: LIST
58500: PPUSH
58501: CALL_OW 1
58505: ST_TO_ADDR
// end ;
58506: GO 58427
58508: POP
58509: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58510: LD_ADDR_EXP 123
58514: PUSH
58515: LD_EXP 123
58519: PPUSH
58520: LD_VAR 0 1
58524: PPUSH
58525: LD_VAR 0 6
58529: PPUSH
58530: CALL_OW 1
58534: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58535: LD_ADDR_EXP 125
58539: PUSH
58540: LD_EXP 125
58544: PPUSH
58545: LD_VAR 0 1
58549: PPUSH
58550: LD_VAR 0 3
58554: PPUSH
58555: CALL_OW 1
58559: ST_TO_ADDR
// end ;
58560: LD_VAR 0 4
58564: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58565: LD_INT 0
58567: PPUSH
// if not mc_bases [ base ] then
58568: LD_EXP 110
58572: PUSH
58573: LD_VAR 0 1
58577: ARRAY
58578: NOT
58579: IFFALSE 58583
// exit ;
58581: GO 58608
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58583: LD_ADDR_EXP 115
58587: PUSH
58588: LD_EXP 115
58592: PPUSH
58593: LD_VAR 0 1
58597: PPUSH
58598: LD_VAR 0 2
58602: PPUSH
58603: CALL_OW 1
58607: ST_TO_ADDR
// end ;
58608: LD_VAR 0 3
58612: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58613: LD_INT 0
58615: PPUSH
// if not mc_bases [ base ] then
58616: LD_EXP 110
58620: PUSH
58621: LD_VAR 0 1
58625: ARRAY
58626: NOT
58627: IFFALSE 58631
// exit ;
58629: GO 58668
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58631: LD_ADDR_EXP 115
58635: PUSH
58636: LD_EXP 115
58640: PPUSH
58641: LD_VAR 0 1
58645: PPUSH
58646: LD_EXP 115
58650: PUSH
58651: LD_VAR 0 1
58655: ARRAY
58656: PUSH
58657: LD_VAR 0 2
58661: UNION
58662: PPUSH
58663: CALL_OW 1
58667: ST_TO_ADDR
// end ;
58668: LD_VAR 0 3
58672: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58673: LD_INT 0
58675: PPUSH
// if not mc_bases [ base ] then
58676: LD_EXP 110
58680: PUSH
58681: LD_VAR 0 1
58685: ARRAY
58686: NOT
58687: IFFALSE 58691
// exit ;
58689: GO 58716
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58691: LD_ADDR_EXP 131
58695: PUSH
58696: LD_EXP 131
58700: PPUSH
58701: LD_VAR 0 1
58705: PPUSH
58706: LD_VAR 0 2
58710: PPUSH
58711: CALL_OW 1
58715: ST_TO_ADDR
// end ;
58716: LD_VAR 0 3
58720: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58721: LD_INT 0
58723: PPUSH
// if not mc_bases [ base ] then
58724: LD_EXP 110
58728: PUSH
58729: LD_VAR 0 1
58733: ARRAY
58734: NOT
58735: IFFALSE 58739
// exit ;
58737: GO 58776
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58739: LD_ADDR_EXP 131
58743: PUSH
58744: LD_EXP 131
58748: PPUSH
58749: LD_VAR 0 1
58753: PPUSH
58754: LD_EXP 131
58758: PUSH
58759: LD_VAR 0 1
58763: ARRAY
58764: PUSH
58765: LD_VAR 0 2
58769: ADD
58770: PPUSH
58771: CALL_OW 1
58775: ST_TO_ADDR
// end ;
58776: LD_VAR 0 3
58780: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58781: LD_INT 0
58783: PPUSH
// if not mc_bases [ base ] then
58784: LD_EXP 110
58788: PUSH
58789: LD_VAR 0 1
58793: ARRAY
58794: NOT
58795: IFFALSE 58799
// exit ;
58797: GO 58853
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58799: LD_ADDR_EXP 132
58803: PUSH
58804: LD_EXP 132
58808: PPUSH
58809: LD_VAR 0 1
58813: PPUSH
58814: LD_VAR 0 2
58818: PPUSH
58819: CALL_OW 1
58823: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58824: LD_ADDR_EXP 121
58828: PUSH
58829: LD_EXP 121
58833: PPUSH
58834: LD_VAR 0 1
58838: PPUSH
58839: LD_VAR 0 2
58843: PUSH
58844: LD_INT 0
58846: PLUS
58847: PPUSH
58848: CALL_OW 1
58852: ST_TO_ADDR
// end ;
58853: LD_VAR 0 3
58857: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58858: LD_INT 0
58860: PPUSH
// if not mc_bases [ base ] then
58861: LD_EXP 110
58865: PUSH
58866: LD_VAR 0 1
58870: ARRAY
58871: NOT
58872: IFFALSE 58876
// exit ;
58874: GO 58901
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58876: LD_ADDR_EXP 121
58880: PUSH
58881: LD_EXP 121
58885: PPUSH
58886: LD_VAR 0 1
58890: PPUSH
58891: LD_VAR 0 2
58895: PPUSH
58896: CALL_OW 1
58900: ST_TO_ADDR
// end ;
58901: LD_VAR 0 3
58905: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58906: LD_INT 0
58908: PPUSH
58909: PPUSH
58910: PPUSH
58911: PPUSH
// if not mc_bases [ base ] then
58912: LD_EXP 110
58916: PUSH
58917: LD_VAR 0 1
58921: ARRAY
58922: NOT
58923: IFFALSE 58927
// exit ;
58925: GO 58992
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58927: LD_ADDR_EXP 130
58931: PUSH
58932: LD_EXP 130
58936: PPUSH
58937: LD_VAR 0 1
58941: PUSH
58942: LD_EXP 130
58946: PUSH
58947: LD_VAR 0 1
58951: ARRAY
58952: PUSH
58953: LD_INT 1
58955: PLUS
58956: PUSH
58957: EMPTY
58958: LIST
58959: LIST
58960: PPUSH
58961: LD_VAR 0 1
58965: PUSH
58966: LD_VAR 0 2
58970: PUSH
58971: LD_VAR 0 3
58975: PUSH
58976: LD_VAR 0 4
58980: PUSH
58981: EMPTY
58982: LIST
58983: LIST
58984: LIST
58985: LIST
58986: PPUSH
58987: CALL 70011 0 3
58991: ST_TO_ADDR
// end ;
58992: LD_VAR 0 5
58996: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58997: LD_INT 0
58999: PPUSH
// if not mc_bases [ base ] then
59000: LD_EXP 110
59004: PUSH
59005: LD_VAR 0 1
59009: ARRAY
59010: NOT
59011: IFFALSE 59015
// exit ;
59013: GO 59040
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59015: LD_ADDR_EXP 147
59019: PUSH
59020: LD_EXP 147
59024: PPUSH
59025: LD_VAR 0 1
59029: PPUSH
59030: LD_VAR 0 2
59034: PPUSH
59035: CALL_OW 1
59039: ST_TO_ADDR
// end ;
59040: LD_VAR 0 3
59044: RET
// export function MC_GetMinesField ( base ) ; begin
59045: LD_INT 0
59047: PPUSH
// result := mc_mines [ base ] ;
59048: LD_ADDR_VAR 0 2
59052: PUSH
59053: LD_EXP 123
59057: PUSH
59058: LD_VAR 0 1
59062: ARRAY
59063: ST_TO_ADDR
// end ;
59064: LD_VAR 0 2
59068: RET
// export function MC_GetProduceList ( base ) ; begin
59069: LD_INT 0
59071: PPUSH
// result := mc_produce [ base ] ;
59072: LD_ADDR_VAR 0 2
59076: PUSH
59077: LD_EXP 131
59081: PUSH
59082: LD_VAR 0 1
59086: ARRAY
59087: ST_TO_ADDR
// end ;
59088: LD_VAR 0 2
59092: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59093: LD_INT 0
59095: PPUSH
59096: PPUSH
// if not mc_bases then
59097: LD_EXP 110
59101: NOT
59102: IFFALSE 59106
// exit ;
59104: GO 59171
// if mc_bases [ base ] then
59106: LD_EXP 110
59110: PUSH
59111: LD_VAR 0 1
59115: ARRAY
59116: IFFALSE 59171
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59118: LD_ADDR_VAR 0 3
59122: PUSH
59123: LD_EXP 110
59127: PUSH
59128: LD_VAR 0 1
59132: ARRAY
59133: PPUSH
59134: LD_INT 30
59136: PUSH
59137: LD_VAR 0 2
59141: PUSH
59142: EMPTY
59143: LIST
59144: LIST
59145: PPUSH
59146: CALL_OW 72
59150: ST_TO_ADDR
// if result then
59151: LD_VAR 0 3
59155: IFFALSE 59171
// result := result [ 1 ] ;
59157: LD_ADDR_VAR 0 3
59161: PUSH
59162: LD_VAR 0 3
59166: PUSH
59167: LD_INT 1
59169: ARRAY
59170: ST_TO_ADDR
// end ; end ;
59171: LD_VAR 0 3
59175: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59176: LD_INT 0
59178: PPUSH
59179: PPUSH
// if not mc_bases then
59180: LD_EXP 110
59184: NOT
59185: IFFALSE 59189
// exit ;
59187: GO 59234
// if mc_bases [ base ] then
59189: LD_EXP 110
59193: PUSH
59194: LD_VAR 0 1
59198: ARRAY
59199: IFFALSE 59234
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59201: LD_ADDR_VAR 0 3
59205: PUSH
59206: LD_EXP 110
59210: PUSH
59211: LD_VAR 0 1
59215: ARRAY
59216: PPUSH
59217: LD_INT 30
59219: PUSH
59220: LD_VAR 0 2
59224: PUSH
59225: EMPTY
59226: LIST
59227: LIST
59228: PPUSH
59229: CALL_OW 72
59233: ST_TO_ADDR
// end ;
59234: LD_VAR 0 3
59238: RET
// export function MC_SetTame ( base , area ) ; begin
59239: LD_INT 0
59241: PPUSH
// if not mc_bases or not base then
59242: LD_EXP 110
59246: NOT
59247: PUSH
59248: LD_VAR 0 1
59252: NOT
59253: OR
59254: IFFALSE 59258
// exit ;
59256: GO 59283
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59258: LD_ADDR_EXP 138
59262: PUSH
59263: LD_EXP 138
59267: PPUSH
59268: LD_VAR 0 1
59272: PPUSH
59273: LD_VAR 0 2
59277: PPUSH
59278: CALL_OW 1
59282: ST_TO_ADDR
// end ;
59283: LD_VAR 0 3
59287: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59288: LD_INT 0
59290: PPUSH
59291: PPUSH
// if not mc_bases or not base then
59292: LD_EXP 110
59296: NOT
59297: PUSH
59298: LD_VAR 0 1
59302: NOT
59303: OR
59304: IFFALSE 59308
// exit ;
59306: GO 59410
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59308: LD_ADDR_VAR 0 4
59312: PUSH
59313: LD_EXP 110
59317: PUSH
59318: LD_VAR 0 1
59322: ARRAY
59323: PPUSH
59324: LD_INT 30
59326: PUSH
59327: LD_VAR 0 2
59331: PUSH
59332: EMPTY
59333: LIST
59334: LIST
59335: PPUSH
59336: CALL_OW 72
59340: ST_TO_ADDR
// if not tmp then
59341: LD_VAR 0 4
59345: NOT
59346: IFFALSE 59350
// exit ;
59348: GO 59410
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59350: LD_ADDR_EXP 142
59354: PUSH
59355: LD_EXP 142
59359: PPUSH
59360: LD_VAR 0 1
59364: PPUSH
59365: LD_EXP 142
59369: PUSH
59370: LD_VAR 0 1
59374: ARRAY
59375: PPUSH
59376: LD_EXP 142
59380: PUSH
59381: LD_VAR 0 1
59385: ARRAY
59386: PUSH
59387: LD_INT 1
59389: PLUS
59390: PPUSH
59391: LD_VAR 0 4
59395: PUSH
59396: LD_INT 1
59398: ARRAY
59399: PPUSH
59400: CALL_OW 2
59404: PPUSH
59405: CALL_OW 1
59409: ST_TO_ADDR
// end ;
59410: LD_VAR 0 3
59414: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59415: LD_INT 0
59417: PPUSH
59418: PPUSH
// if not mc_bases or not base or not kinds then
59419: LD_EXP 110
59423: NOT
59424: PUSH
59425: LD_VAR 0 1
59429: NOT
59430: OR
59431: PUSH
59432: LD_VAR 0 2
59436: NOT
59437: OR
59438: IFFALSE 59442
// exit ;
59440: GO 59503
// for i in kinds do
59442: LD_ADDR_VAR 0 4
59446: PUSH
59447: LD_VAR 0 2
59451: PUSH
59452: FOR_IN
59453: IFFALSE 59501
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59455: LD_ADDR_EXP 144
59459: PUSH
59460: LD_EXP 144
59464: PPUSH
59465: LD_VAR 0 1
59469: PUSH
59470: LD_EXP 144
59474: PUSH
59475: LD_VAR 0 1
59479: ARRAY
59480: PUSH
59481: LD_INT 1
59483: PLUS
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: PPUSH
59489: LD_VAR 0 4
59493: PPUSH
59494: CALL 70011 0 3
59498: ST_TO_ADDR
59499: GO 59452
59501: POP
59502: POP
// end ;
59503: LD_VAR 0 3
59507: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59508: LD_INT 0
59510: PPUSH
// if not mc_bases or not base or not areas then
59511: LD_EXP 110
59515: NOT
59516: PUSH
59517: LD_VAR 0 1
59521: NOT
59522: OR
59523: PUSH
59524: LD_VAR 0 2
59528: NOT
59529: OR
59530: IFFALSE 59534
// exit ;
59532: GO 59559
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59534: LD_ADDR_EXP 128
59538: PUSH
59539: LD_EXP 128
59543: PPUSH
59544: LD_VAR 0 1
59548: PPUSH
59549: LD_VAR 0 2
59553: PPUSH
59554: CALL_OW 1
59558: ST_TO_ADDR
// end ;
59559: LD_VAR 0 3
59563: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59564: LD_INT 0
59566: PPUSH
// if not mc_bases or not base or not teleports_exit then
59567: LD_EXP 110
59571: NOT
59572: PUSH
59573: LD_VAR 0 1
59577: NOT
59578: OR
59579: PUSH
59580: LD_VAR 0 2
59584: NOT
59585: OR
59586: IFFALSE 59590
// exit ;
59588: GO 59615
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59590: LD_ADDR_EXP 145
59594: PUSH
59595: LD_EXP 145
59599: PPUSH
59600: LD_VAR 0 1
59604: PPUSH
59605: LD_VAR 0 2
59609: PPUSH
59610: CALL_OW 1
59614: ST_TO_ADDR
// end ;
59615: LD_VAR 0 3
59619: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59620: LD_INT 0
59622: PPUSH
59623: PPUSH
59624: PPUSH
// if not mc_bases or not base or not ext_list then
59625: LD_EXP 110
59629: NOT
59630: PUSH
59631: LD_VAR 0 1
59635: NOT
59636: OR
59637: PUSH
59638: LD_VAR 0 5
59642: NOT
59643: OR
59644: IFFALSE 59648
// exit ;
59646: GO 59821
// tmp := GetFacExtXYD ( x , y , d ) ;
59648: LD_ADDR_VAR 0 8
59652: PUSH
59653: LD_VAR 0 2
59657: PPUSH
59658: LD_VAR 0 3
59662: PPUSH
59663: LD_VAR 0 4
59667: PPUSH
59668: CALL 98690 0 3
59672: ST_TO_ADDR
// if not tmp then
59673: LD_VAR 0 8
59677: NOT
59678: IFFALSE 59682
// exit ;
59680: GO 59821
// for i in tmp do
59682: LD_ADDR_VAR 0 7
59686: PUSH
59687: LD_VAR 0 8
59691: PUSH
59692: FOR_IN
59693: IFFALSE 59819
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59695: LD_ADDR_EXP 115
59699: PUSH
59700: LD_EXP 115
59704: PPUSH
59705: LD_VAR 0 1
59709: PPUSH
59710: LD_EXP 115
59714: PUSH
59715: LD_VAR 0 1
59719: ARRAY
59720: PPUSH
59721: LD_EXP 115
59725: PUSH
59726: LD_VAR 0 1
59730: ARRAY
59731: PUSH
59732: LD_INT 1
59734: PLUS
59735: PPUSH
59736: LD_VAR 0 5
59740: PUSH
59741: LD_INT 1
59743: ARRAY
59744: PUSH
59745: LD_VAR 0 7
59749: PUSH
59750: LD_INT 1
59752: ARRAY
59753: PUSH
59754: LD_VAR 0 7
59758: PUSH
59759: LD_INT 2
59761: ARRAY
59762: PUSH
59763: LD_VAR 0 7
59767: PUSH
59768: LD_INT 3
59770: ARRAY
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: LIST
59776: LIST
59777: PPUSH
59778: CALL_OW 2
59782: PPUSH
59783: CALL_OW 1
59787: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59788: LD_ADDR_VAR 0 5
59792: PUSH
59793: LD_VAR 0 5
59797: PPUSH
59798: LD_INT 1
59800: PPUSH
59801: CALL_OW 3
59805: ST_TO_ADDR
// if not ext_list then
59806: LD_VAR 0 5
59810: NOT
59811: IFFALSE 59817
// exit ;
59813: POP
59814: POP
59815: GO 59821
// end ;
59817: GO 59692
59819: POP
59820: POP
// end ;
59821: LD_VAR 0 6
59825: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59826: LD_INT 0
59828: PPUSH
// if not mc_bases or not base or not weapon_list then
59829: LD_EXP 110
59833: NOT
59834: PUSH
59835: LD_VAR 0 1
59839: NOT
59840: OR
59841: PUSH
59842: LD_VAR 0 2
59846: NOT
59847: OR
59848: IFFALSE 59852
// exit ;
59850: GO 59877
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59852: LD_ADDR_EXP 149
59856: PUSH
59857: LD_EXP 149
59861: PPUSH
59862: LD_VAR 0 1
59866: PPUSH
59867: LD_VAR 0 2
59871: PPUSH
59872: CALL_OW 1
59876: ST_TO_ADDR
// end ;
59877: LD_VAR 0 3
59881: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59882: LD_INT 0
59884: PPUSH
// if not mc_bases or not base or not tech_list then
59885: LD_EXP 110
59889: NOT
59890: PUSH
59891: LD_VAR 0 1
59895: NOT
59896: OR
59897: PUSH
59898: LD_VAR 0 2
59902: NOT
59903: OR
59904: IFFALSE 59908
// exit ;
59906: GO 59933
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59908: LD_ADDR_EXP 137
59912: PUSH
59913: LD_EXP 137
59917: PPUSH
59918: LD_VAR 0 1
59922: PPUSH
59923: LD_VAR 0 2
59927: PPUSH
59928: CALL_OW 1
59932: ST_TO_ADDR
// end ;
59933: LD_VAR 0 3
59937: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59938: LD_INT 0
59940: PPUSH
// if not mc_bases or not parking_area or not base then
59941: LD_EXP 110
59945: NOT
59946: PUSH
59947: LD_VAR 0 2
59951: NOT
59952: OR
59953: PUSH
59954: LD_VAR 0 1
59958: NOT
59959: OR
59960: IFFALSE 59964
// exit ;
59962: GO 59989
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59964: LD_ADDR_EXP 134
59968: PUSH
59969: LD_EXP 134
59973: PPUSH
59974: LD_VAR 0 1
59978: PPUSH
59979: LD_VAR 0 2
59983: PPUSH
59984: CALL_OW 1
59988: ST_TO_ADDR
// end ;
59989: LD_VAR 0 3
59993: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59994: LD_INT 0
59996: PPUSH
// if not mc_bases or not base or not scan_area then
59997: LD_EXP 110
60001: NOT
60002: PUSH
60003: LD_VAR 0 1
60007: NOT
60008: OR
60009: PUSH
60010: LD_VAR 0 2
60014: NOT
60015: OR
60016: IFFALSE 60020
// exit ;
60018: GO 60045
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60020: LD_ADDR_EXP 135
60024: PUSH
60025: LD_EXP 135
60029: PPUSH
60030: LD_VAR 0 1
60034: PPUSH
60035: LD_VAR 0 2
60039: PPUSH
60040: CALL_OW 1
60044: ST_TO_ADDR
// end ;
60045: LD_VAR 0 3
60049: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60050: LD_INT 0
60052: PPUSH
60053: PPUSH
// if not mc_bases or not base then
60054: LD_EXP 110
60058: NOT
60059: PUSH
60060: LD_VAR 0 1
60064: NOT
60065: OR
60066: IFFALSE 60070
// exit ;
60068: GO 60134
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60070: LD_ADDR_VAR 0 3
60074: PUSH
60075: LD_INT 1
60077: PUSH
60078: LD_INT 2
60080: PUSH
60081: LD_INT 3
60083: PUSH
60084: LD_INT 4
60086: PUSH
60087: LD_INT 11
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: LIST
60094: LIST
60095: LIST
60096: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60097: LD_ADDR_EXP 137
60101: PUSH
60102: LD_EXP 137
60106: PPUSH
60107: LD_VAR 0 1
60111: PPUSH
60112: LD_EXP 137
60116: PUSH
60117: LD_VAR 0 1
60121: ARRAY
60122: PUSH
60123: LD_VAR 0 3
60127: DIFF
60128: PPUSH
60129: CALL_OW 1
60133: ST_TO_ADDR
// end ;
60134: LD_VAR 0 2
60138: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60139: LD_INT 0
60141: PPUSH
// result := mc_vehicles [ base ] ;
60142: LD_ADDR_VAR 0 3
60146: PUSH
60147: LD_EXP 129
60151: PUSH
60152: LD_VAR 0 1
60156: ARRAY
60157: ST_TO_ADDR
// if onlyCombat then
60158: LD_VAR 0 2
60162: IFFALSE 60327
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60164: LD_ADDR_VAR 0 3
60168: PUSH
60169: LD_VAR 0 3
60173: PUSH
60174: LD_VAR 0 3
60178: PPUSH
60179: LD_INT 2
60181: PUSH
60182: LD_INT 34
60184: PUSH
60185: LD_INT 12
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: LD_INT 34
60194: PUSH
60195: LD_INT 51
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: PUSH
60202: LD_INT 34
60204: PUSH
60205: LD_EXP 96
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: PUSH
60214: LD_INT 34
60216: PUSH
60217: LD_INT 32
60219: PUSH
60220: EMPTY
60221: LIST
60222: LIST
60223: PUSH
60224: LD_INT 34
60226: PUSH
60227: LD_INT 13
60229: PUSH
60230: EMPTY
60231: LIST
60232: LIST
60233: PUSH
60234: LD_INT 34
60236: PUSH
60237: LD_INT 52
60239: PUSH
60240: EMPTY
60241: LIST
60242: LIST
60243: PUSH
60244: LD_INT 34
60246: PUSH
60247: LD_INT 14
60249: PUSH
60250: EMPTY
60251: LIST
60252: LIST
60253: PUSH
60254: LD_INT 34
60256: PUSH
60257: LD_INT 53
60259: PUSH
60260: EMPTY
60261: LIST
60262: LIST
60263: PUSH
60264: LD_INT 34
60266: PUSH
60267: LD_EXP 95
60271: PUSH
60272: EMPTY
60273: LIST
60274: LIST
60275: PUSH
60276: LD_INT 34
60278: PUSH
60279: LD_INT 31
60281: PUSH
60282: EMPTY
60283: LIST
60284: LIST
60285: PUSH
60286: LD_INT 34
60288: PUSH
60289: LD_INT 48
60291: PUSH
60292: EMPTY
60293: LIST
60294: LIST
60295: PUSH
60296: LD_INT 34
60298: PUSH
60299: LD_INT 8
60301: PUSH
60302: EMPTY
60303: LIST
60304: LIST
60305: PUSH
60306: EMPTY
60307: LIST
60308: LIST
60309: LIST
60310: LIST
60311: LIST
60312: LIST
60313: LIST
60314: LIST
60315: LIST
60316: LIST
60317: LIST
60318: LIST
60319: LIST
60320: PPUSH
60321: CALL_OW 72
60325: DIFF
60326: ST_TO_ADDR
// end ; end_of_file
60327: LD_VAR 0 3
60331: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60332: LD_INT 0
60334: PPUSH
60335: PPUSH
60336: PPUSH
// if not mc_bases or not skirmish then
60337: LD_EXP 110
60341: NOT
60342: PUSH
60343: LD_EXP 108
60347: NOT
60348: OR
60349: IFFALSE 60353
// exit ;
60351: GO 60518
// for i = 1 to mc_bases do
60353: LD_ADDR_VAR 0 4
60357: PUSH
60358: DOUBLE
60359: LD_INT 1
60361: DEC
60362: ST_TO_ADDR
60363: LD_EXP 110
60367: PUSH
60368: FOR_TO
60369: IFFALSE 60516
// begin if sci in mc_bases [ i ] then
60371: LD_VAR 0 2
60375: PUSH
60376: LD_EXP 110
60380: PUSH
60381: LD_VAR 0 4
60385: ARRAY
60386: IN
60387: IFFALSE 60514
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60389: LD_ADDR_EXP 139
60393: PUSH
60394: LD_EXP 139
60398: PPUSH
60399: LD_VAR 0 4
60403: PUSH
60404: LD_EXP 139
60408: PUSH
60409: LD_VAR 0 4
60413: ARRAY
60414: PUSH
60415: LD_INT 1
60417: PLUS
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: PPUSH
60423: LD_VAR 0 1
60427: PPUSH
60428: CALL 70011 0 3
60432: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60433: LD_ADDR_VAR 0 5
60437: PUSH
60438: LD_EXP 110
60442: PUSH
60443: LD_VAR 0 4
60447: ARRAY
60448: PPUSH
60449: LD_INT 2
60451: PUSH
60452: LD_INT 30
60454: PUSH
60455: LD_INT 0
60457: PUSH
60458: EMPTY
60459: LIST
60460: LIST
60461: PUSH
60462: LD_INT 30
60464: PUSH
60465: LD_INT 1
60467: PUSH
60468: EMPTY
60469: LIST
60470: LIST
60471: PUSH
60472: EMPTY
60473: LIST
60474: LIST
60475: LIST
60476: PPUSH
60477: CALL_OW 72
60481: PPUSH
60482: LD_VAR 0 1
60486: PPUSH
60487: CALL_OW 74
60491: ST_TO_ADDR
// if tmp then
60492: LD_VAR 0 5
60496: IFFALSE 60512
// ComStandNearbyBuilding ( ape , tmp ) ;
60498: LD_VAR 0 1
60502: PPUSH
60503: LD_VAR 0 5
60507: PPUSH
60508: CALL 66625 0 2
// break ;
60512: GO 60516
// end ; end ;
60514: GO 60368
60516: POP
60517: POP
// end ;
60518: LD_VAR 0 3
60522: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60523: LD_INT 0
60525: PPUSH
60526: PPUSH
60527: PPUSH
// if not mc_bases or not skirmish then
60528: LD_EXP 110
60532: NOT
60533: PUSH
60534: LD_EXP 108
60538: NOT
60539: OR
60540: IFFALSE 60544
// exit ;
60542: GO 60633
// for i = 1 to mc_bases do
60544: LD_ADDR_VAR 0 4
60548: PUSH
60549: DOUBLE
60550: LD_INT 1
60552: DEC
60553: ST_TO_ADDR
60554: LD_EXP 110
60558: PUSH
60559: FOR_TO
60560: IFFALSE 60631
// begin if building in mc_busy_turret_list [ i ] then
60562: LD_VAR 0 1
60566: PUSH
60567: LD_EXP 120
60571: PUSH
60572: LD_VAR 0 4
60576: ARRAY
60577: IN
60578: IFFALSE 60629
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60580: LD_ADDR_VAR 0 5
60584: PUSH
60585: LD_EXP 120
60589: PUSH
60590: LD_VAR 0 4
60594: ARRAY
60595: PUSH
60596: LD_VAR 0 1
60600: DIFF
60601: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60602: LD_ADDR_EXP 120
60606: PUSH
60607: LD_EXP 120
60611: PPUSH
60612: LD_VAR 0 4
60616: PPUSH
60617: LD_VAR 0 5
60621: PPUSH
60622: CALL_OW 1
60626: ST_TO_ADDR
// break ;
60627: GO 60631
// end ; end ;
60629: GO 60559
60631: POP
60632: POP
// end ;
60633: LD_VAR 0 3
60637: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60638: LD_INT 0
60640: PPUSH
60641: PPUSH
60642: PPUSH
// if not mc_bases or not skirmish then
60643: LD_EXP 110
60647: NOT
60648: PUSH
60649: LD_EXP 108
60653: NOT
60654: OR
60655: IFFALSE 60659
// exit ;
60657: GO 60858
// for i = 1 to mc_bases do
60659: LD_ADDR_VAR 0 5
60663: PUSH
60664: DOUBLE
60665: LD_INT 1
60667: DEC
60668: ST_TO_ADDR
60669: LD_EXP 110
60673: PUSH
60674: FOR_TO
60675: IFFALSE 60856
// if building in mc_bases [ i ] then
60677: LD_VAR 0 1
60681: PUSH
60682: LD_EXP 110
60686: PUSH
60687: LD_VAR 0 5
60691: ARRAY
60692: IN
60693: IFFALSE 60854
// begin tmp := mc_bases [ i ] diff building ;
60695: LD_ADDR_VAR 0 6
60699: PUSH
60700: LD_EXP 110
60704: PUSH
60705: LD_VAR 0 5
60709: ARRAY
60710: PUSH
60711: LD_VAR 0 1
60715: DIFF
60716: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60717: LD_ADDR_EXP 110
60721: PUSH
60722: LD_EXP 110
60726: PPUSH
60727: LD_VAR 0 5
60731: PPUSH
60732: LD_VAR 0 6
60736: PPUSH
60737: CALL_OW 1
60741: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60742: LD_VAR 0 1
60746: PUSH
60747: LD_EXP 118
60751: PUSH
60752: LD_VAR 0 5
60756: ARRAY
60757: IN
60758: IFFALSE 60797
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60760: LD_ADDR_EXP 118
60764: PUSH
60765: LD_EXP 118
60769: PPUSH
60770: LD_VAR 0 5
60774: PPUSH
60775: LD_EXP 118
60779: PUSH
60780: LD_VAR 0 5
60784: ARRAY
60785: PUSH
60786: LD_VAR 0 1
60790: DIFF
60791: PPUSH
60792: CALL_OW 1
60796: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60797: LD_VAR 0 1
60801: PUSH
60802: LD_EXP 119
60806: PUSH
60807: LD_VAR 0 5
60811: ARRAY
60812: IN
60813: IFFALSE 60852
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60815: LD_ADDR_EXP 119
60819: PUSH
60820: LD_EXP 119
60824: PPUSH
60825: LD_VAR 0 5
60829: PPUSH
60830: LD_EXP 119
60834: PUSH
60835: LD_VAR 0 5
60839: ARRAY
60840: PUSH
60841: LD_VAR 0 1
60845: DIFF
60846: PPUSH
60847: CALL_OW 1
60851: ST_TO_ADDR
// break ;
60852: GO 60856
// end ;
60854: GO 60674
60856: POP
60857: POP
// end ;
60858: LD_VAR 0 4
60862: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60863: LD_INT 0
60865: PPUSH
60866: PPUSH
60867: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60868: LD_EXP 110
60872: NOT
60873: PUSH
60874: LD_EXP 108
60878: NOT
60879: OR
60880: PUSH
60881: LD_VAR 0 3
60885: PUSH
60886: LD_EXP 136
60890: IN
60891: NOT
60892: OR
60893: IFFALSE 60897
// exit ;
60895: GO 61020
// for i = 1 to mc_vehicles do
60897: LD_ADDR_VAR 0 6
60901: PUSH
60902: DOUBLE
60903: LD_INT 1
60905: DEC
60906: ST_TO_ADDR
60907: LD_EXP 129
60911: PUSH
60912: FOR_TO
60913: IFFALSE 61018
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60915: LD_VAR 0 2
60919: PUSH
60920: LD_EXP 129
60924: PUSH
60925: LD_VAR 0 6
60929: ARRAY
60930: IN
60931: PUSH
60932: LD_VAR 0 1
60936: PUSH
60937: LD_EXP 129
60941: PUSH
60942: LD_VAR 0 6
60946: ARRAY
60947: IN
60948: OR
60949: IFFALSE 61016
// begin tmp := mc_vehicles [ i ] diff old ;
60951: LD_ADDR_VAR 0 7
60955: PUSH
60956: LD_EXP 129
60960: PUSH
60961: LD_VAR 0 6
60965: ARRAY
60966: PUSH
60967: LD_VAR 0 2
60971: DIFF
60972: ST_TO_ADDR
// tmp := tmp diff new ;
60973: LD_ADDR_VAR 0 7
60977: PUSH
60978: LD_VAR 0 7
60982: PUSH
60983: LD_VAR 0 1
60987: DIFF
60988: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60989: LD_ADDR_EXP 129
60993: PUSH
60994: LD_EXP 129
60998: PPUSH
60999: LD_VAR 0 6
61003: PPUSH
61004: LD_VAR 0 7
61008: PPUSH
61009: CALL_OW 1
61013: ST_TO_ADDR
// break ;
61014: GO 61018
// end ;
61016: GO 60912
61018: POP
61019: POP
// end ;
61020: LD_VAR 0 5
61024: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61025: LD_INT 0
61027: PPUSH
61028: PPUSH
61029: PPUSH
61030: PPUSH
// if not mc_bases or not skirmish then
61031: LD_EXP 110
61035: NOT
61036: PUSH
61037: LD_EXP 108
61041: NOT
61042: OR
61043: IFFALSE 61047
// exit ;
61045: GO 61424
// side := GetSide ( vehicle ) ;
61047: LD_ADDR_VAR 0 5
61051: PUSH
61052: LD_VAR 0 1
61056: PPUSH
61057: CALL_OW 255
61061: ST_TO_ADDR
// for i = 1 to mc_bases do
61062: LD_ADDR_VAR 0 4
61066: PUSH
61067: DOUBLE
61068: LD_INT 1
61070: DEC
61071: ST_TO_ADDR
61072: LD_EXP 110
61076: PUSH
61077: FOR_TO
61078: IFFALSE 61422
// begin if factory in mc_bases [ i ] then
61080: LD_VAR 0 2
61084: PUSH
61085: LD_EXP 110
61089: PUSH
61090: LD_VAR 0 4
61094: ARRAY
61095: IN
61096: IFFALSE 61420
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
61098: LD_EXP 132
61102: PUSH
61103: LD_VAR 0 4
61107: ARRAY
61108: PUSH
61109: LD_EXP 121
61113: PUSH
61114: LD_VAR 0 4
61118: ARRAY
61119: LESS
61120: PUSH
61121: LD_VAR 0 1
61125: PPUSH
61126: CALL_OW 264
61130: PUSH
61131: LD_INT 31
61133: PUSH
61134: LD_INT 32
61136: PUSH
61137: LD_INT 51
61139: PUSH
61140: LD_EXP 96
61144: PUSH
61145: LD_INT 12
61147: PUSH
61148: LD_INT 30
61150: PUSH
61151: LD_EXP 95
61155: PUSH
61156: LD_INT 11
61158: PUSH
61159: LD_INT 53
61161: PUSH
61162: LD_INT 14
61164: PUSH
61165: LD_EXP 99
61169: PUSH
61170: LD_INT 29
61172: PUSH
61173: LD_EXP 97
61177: PUSH
61178: LD_INT 13
61180: PUSH
61181: LD_INT 52
61183: PUSH
61184: LD_INT 48
61186: PUSH
61187: LD_INT 8
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: LIST
61194: LIST
61195: LIST
61196: LIST
61197: LIST
61198: LIST
61199: LIST
61200: LIST
61201: LIST
61202: LIST
61203: LIST
61204: LIST
61205: LIST
61206: LIST
61207: LIST
61208: IN
61209: NOT
61210: AND
61211: IFFALSE 61259
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61213: LD_ADDR_EXP 132
61217: PUSH
61218: LD_EXP 132
61222: PPUSH
61223: LD_VAR 0 4
61227: PUSH
61228: LD_EXP 132
61232: PUSH
61233: LD_VAR 0 4
61237: ARRAY
61238: PUSH
61239: LD_INT 1
61241: PLUS
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: PPUSH
61247: LD_VAR 0 1
61251: PPUSH
61252: CALL 70011 0 3
61256: ST_TO_ADDR
61257: GO 61303
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61259: LD_ADDR_EXP 129
61263: PUSH
61264: LD_EXP 129
61268: PPUSH
61269: LD_VAR 0 4
61273: PUSH
61274: LD_EXP 129
61278: PUSH
61279: LD_VAR 0 4
61283: ARRAY
61284: PUSH
61285: LD_INT 1
61287: PLUS
61288: PUSH
61289: EMPTY
61290: LIST
61291: LIST
61292: PPUSH
61293: LD_VAR 0 1
61297: PPUSH
61298: CALL 70011 0 3
61302: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61303: LD_VAR 0 1
61307: PPUSH
61308: CALL_OW 263
61312: PUSH
61313: LD_INT 2
61315: EQUAL
61316: IFFALSE 61336
// begin repeat wait ( 0 0$1 ) ;
61318: LD_INT 35
61320: PPUSH
61321: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61325: LD_VAR 0 1
61329: PPUSH
61330: CALL_OW 312
61334: IFFALSE 61318
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61336: LD_VAR 0 1
61340: PPUSH
61341: LD_EXP 134
61345: PUSH
61346: LD_VAR 0 4
61350: ARRAY
61351: PPUSH
61352: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61356: LD_VAR 0 1
61360: PPUSH
61361: CALL_OW 263
61365: PUSH
61366: LD_INT 1
61368: NONEQUAL
61369: IFFALSE 61373
// break ;
61371: GO 61422
// repeat wait ( 0 0$1 ) ;
61373: LD_INT 35
61375: PPUSH
61376: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61380: LD_VAR 0 1
61384: PPUSH
61385: LD_EXP 134
61389: PUSH
61390: LD_VAR 0 4
61394: ARRAY
61395: PPUSH
61396: CALL_OW 308
61400: IFFALSE 61373
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61402: LD_VAR 0 1
61406: PPUSH
61407: CALL_OW 311
61411: PPUSH
61412: CALL_OW 121
// exit ;
61416: POP
61417: POP
61418: GO 61424
// end ; end ;
61420: GO 61077
61422: POP
61423: POP
// end ;
61424: LD_VAR 0 3
61428: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61429: LD_INT 0
61431: PPUSH
61432: PPUSH
61433: PPUSH
61434: PPUSH
// if not mc_bases or not skirmish then
61435: LD_EXP 110
61439: NOT
61440: PUSH
61441: LD_EXP 108
61445: NOT
61446: OR
61447: IFFALSE 61451
// exit ;
61449: GO 61804
// repeat wait ( 0 0$1 ) ;
61451: LD_INT 35
61453: PPUSH
61454: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61458: LD_VAR 0 2
61462: PPUSH
61463: LD_VAR 0 3
61467: PPUSH
61468: CALL_OW 284
61472: IFFALSE 61451
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61474: LD_VAR 0 2
61478: PPUSH
61479: LD_VAR 0 3
61483: PPUSH
61484: CALL_OW 283
61488: PUSH
61489: LD_INT 4
61491: EQUAL
61492: IFFALSE 61496
// exit ;
61494: GO 61804
// for i = 1 to mc_bases do
61496: LD_ADDR_VAR 0 7
61500: PUSH
61501: DOUBLE
61502: LD_INT 1
61504: DEC
61505: ST_TO_ADDR
61506: LD_EXP 110
61510: PUSH
61511: FOR_TO
61512: IFFALSE 61802
// begin if mc_crates_area [ i ] then
61514: LD_EXP 128
61518: PUSH
61519: LD_VAR 0 7
61523: ARRAY
61524: IFFALSE 61635
// for j in mc_crates_area [ i ] do
61526: LD_ADDR_VAR 0 8
61530: PUSH
61531: LD_EXP 128
61535: PUSH
61536: LD_VAR 0 7
61540: ARRAY
61541: PUSH
61542: FOR_IN
61543: IFFALSE 61633
// if InArea ( x , y , j ) then
61545: LD_VAR 0 2
61549: PPUSH
61550: LD_VAR 0 3
61554: PPUSH
61555: LD_VAR 0 8
61559: PPUSH
61560: CALL_OW 309
61564: IFFALSE 61631
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61566: LD_ADDR_EXP 126
61570: PUSH
61571: LD_EXP 126
61575: PPUSH
61576: LD_VAR 0 7
61580: PUSH
61581: LD_EXP 126
61585: PUSH
61586: LD_VAR 0 7
61590: ARRAY
61591: PUSH
61592: LD_INT 1
61594: PLUS
61595: PUSH
61596: EMPTY
61597: LIST
61598: LIST
61599: PPUSH
61600: LD_VAR 0 4
61604: PUSH
61605: LD_VAR 0 2
61609: PUSH
61610: LD_VAR 0 3
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: LIST
61619: PPUSH
61620: CALL 70011 0 3
61624: ST_TO_ADDR
// exit ;
61625: POP
61626: POP
61627: POP
61628: POP
61629: GO 61804
// end ;
61631: GO 61542
61633: POP
61634: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61635: LD_ADDR_VAR 0 9
61639: PUSH
61640: LD_EXP 110
61644: PUSH
61645: LD_VAR 0 7
61649: ARRAY
61650: PPUSH
61651: LD_INT 2
61653: PUSH
61654: LD_INT 30
61656: PUSH
61657: LD_INT 0
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: PUSH
61664: LD_INT 30
61666: PUSH
61667: LD_INT 1
61669: PUSH
61670: EMPTY
61671: LIST
61672: LIST
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: LIST
61678: PPUSH
61679: CALL_OW 72
61683: ST_TO_ADDR
// if not depot then
61684: LD_VAR 0 9
61688: NOT
61689: IFFALSE 61693
// continue ;
61691: GO 61511
// for j in depot do
61693: LD_ADDR_VAR 0 8
61697: PUSH
61698: LD_VAR 0 9
61702: PUSH
61703: FOR_IN
61704: IFFALSE 61798
// if GetDistUnitXY ( j , x , y ) < 30 then
61706: LD_VAR 0 8
61710: PPUSH
61711: LD_VAR 0 2
61715: PPUSH
61716: LD_VAR 0 3
61720: PPUSH
61721: CALL_OW 297
61725: PUSH
61726: LD_INT 30
61728: LESS
61729: IFFALSE 61796
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61731: LD_ADDR_EXP 126
61735: PUSH
61736: LD_EXP 126
61740: PPUSH
61741: LD_VAR 0 7
61745: PUSH
61746: LD_EXP 126
61750: PUSH
61751: LD_VAR 0 7
61755: ARRAY
61756: PUSH
61757: LD_INT 1
61759: PLUS
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: PPUSH
61765: LD_VAR 0 4
61769: PUSH
61770: LD_VAR 0 2
61774: PUSH
61775: LD_VAR 0 3
61779: PUSH
61780: EMPTY
61781: LIST
61782: LIST
61783: LIST
61784: PPUSH
61785: CALL 70011 0 3
61789: ST_TO_ADDR
// exit ;
61790: POP
61791: POP
61792: POP
61793: POP
61794: GO 61804
// end ;
61796: GO 61703
61798: POP
61799: POP
// end ;
61800: GO 61511
61802: POP
61803: POP
// end ;
61804: LD_VAR 0 6
61808: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61809: LD_INT 0
61811: PPUSH
61812: PPUSH
61813: PPUSH
61814: PPUSH
// if not mc_bases or not skirmish then
61815: LD_EXP 110
61819: NOT
61820: PUSH
61821: LD_EXP 108
61825: NOT
61826: OR
61827: IFFALSE 61831
// exit ;
61829: GO 62108
// side := GetSide ( lab ) ;
61831: LD_ADDR_VAR 0 4
61835: PUSH
61836: LD_VAR 0 2
61840: PPUSH
61841: CALL_OW 255
61845: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61846: LD_VAR 0 4
61850: PUSH
61851: LD_EXP 136
61855: IN
61856: NOT
61857: PUSH
61858: LD_EXP 137
61862: NOT
61863: OR
61864: PUSH
61865: LD_EXP 110
61869: NOT
61870: OR
61871: IFFALSE 61875
// exit ;
61873: GO 62108
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61875: LD_ADDR_EXP 137
61879: PUSH
61880: LD_EXP 137
61884: PPUSH
61885: LD_VAR 0 4
61889: PPUSH
61890: LD_EXP 137
61894: PUSH
61895: LD_VAR 0 4
61899: ARRAY
61900: PUSH
61901: LD_VAR 0 1
61905: DIFF
61906: PPUSH
61907: CALL_OW 1
61911: ST_TO_ADDR
// for i = 1 to mc_bases do
61912: LD_ADDR_VAR 0 5
61916: PUSH
61917: DOUBLE
61918: LD_INT 1
61920: DEC
61921: ST_TO_ADDR
61922: LD_EXP 110
61926: PUSH
61927: FOR_TO
61928: IFFALSE 62106
// begin if lab in mc_bases [ i ] then
61930: LD_VAR 0 2
61934: PUSH
61935: LD_EXP 110
61939: PUSH
61940: LD_VAR 0 5
61944: ARRAY
61945: IN
61946: IFFALSE 62104
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61948: LD_VAR 0 1
61952: PUSH
61953: LD_INT 11
61955: PUSH
61956: LD_INT 4
61958: PUSH
61959: LD_INT 3
61961: PUSH
61962: LD_INT 2
61964: PUSH
61965: EMPTY
61966: LIST
61967: LIST
61968: LIST
61969: LIST
61970: IN
61971: PUSH
61972: LD_EXP 140
61976: PUSH
61977: LD_VAR 0 5
61981: ARRAY
61982: AND
61983: IFFALSE 62104
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61985: LD_ADDR_VAR 0 6
61989: PUSH
61990: LD_EXP 140
61994: PUSH
61995: LD_VAR 0 5
61999: ARRAY
62000: PUSH
62001: LD_INT 1
62003: ARRAY
62004: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62005: LD_ADDR_EXP 140
62009: PUSH
62010: LD_EXP 140
62014: PPUSH
62015: LD_VAR 0 5
62019: PPUSH
62020: EMPTY
62021: PPUSH
62022: CALL_OW 1
62026: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62027: LD_VAR 0 6
62031: PPUSH
62032: LD_INT 0
62034: PPUSH
62035: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62039: LD_VAR 0 6
62043: PPUSH
62044: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62048: LD_ADDR_EXP 139
62052: PUSH
62053: LD_EXP 139
62057: PPUSH
62058: LD_VAR 0 5
62062: PPUSH
62063: LD_EXP 139
62067: PUSH
62068: LD_VAR 0 5
62072: ARRAY
62073: PPUSH
62074: LD_INT 1
62076: PPUSH
62077: LD_VAR 0 6
62081: PPUSH
62082: CALL_OW 2
62086: PPUSH
62087: CALL_OW 1
62091: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62092: LD_VAR 0 5
62096: PPUSH
62097: LD_INT 112
62099: PPUSH
62100: CALL 39120 0 2
// end ; end ; end ;
62104: GO 61927
62106: POP
62107: POP
// end ;
62108: LD_VAR 0 3
62112: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62113: LD_INT 0
62115: PPUSH
62116: PPUSH
62117: PPUSH
62118: PPUSH
62119: PPUSH
62120: PPUSH
62121: PPUSH
62122: PPUSH
// if not mc_bases or not skirmish then
62123: LD_EXP 110
62127: NOT
62128: PUSH
62129: LD_EXP 108
62133: NOT
62134: OR
62135: IFFALSE 62139
// exit ;
62137: GO 63510
// for i = 1 to mc_bases do
62139: LD_ADDR_VAR 0 3
62143: PUSH
62144: DOUBLE
62145: LD_INT 1
62147: DEC
62148: ST_TO_ADDR
62149: LD_EXP 110
62153: PUSH
62154: FOR_TO
62155: IFFALSE 63508
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62157: LD_VAR 0 1
62161: PUSH
62162: LD_EXP 110
62166: PUSH
62167: LD_VAR 0 3
62171: ARRAY
62172: IN
62173: PUSH
62174: LD_VAR 0 1
62178: PUSH
62179: LD_EXP 117
62183: PUSH
62184: LD_VAR 0 3
62188: ARRAY
62189: IN
62190: OR
62191: PUSH
62192: LD_VAR 0 1
62196: PUSH
62197: LD_EXP 132
62201: PUSH
62202: LD_VAR 0 3
62206: ARRAY
62207: IN
62208: OR
62209: PUSH
62210: LD_VAR 0 1
62214: PUSH
62215: LD_EXP 129
62219: PUSH
62220: LD_VAR 0 3
62224: ARRAY
62225: IN
62226: OR
62227: PUSH
62228: LD_VAR 0 1
62232: PUSH
62233: LD_EXP 139
62237: PUSH
62238: LD_VAR 0 3
62242: ARRAY
62243: IN
62244: OR
62245: PUSH
62246: LD_VAR 0 1
62250: PUSH
62251: LD_EXP 140
62255: PUSH
62256: LD_VAR 0 3
62260: ARRAY
62261: IN
62262: OR
62263: IFFALSE 63506
// begin if un in mc_ape [ i ] then
62265: LD_VAR 0 1
62269: PUSH
62270: LD_EXP 139
62274: PUSH
62275: LD_VAR 0 3
62279: ARRAY
62280: IN
62281: IFFALSE 62320
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62283: LD_ADDR_EXP 139
62287: PUSH
62288: LD_EXP 139
62292: PPUSH
62293: LD_VAR 0 3
62297: PPUSH
62298: LD_EXP 139
62302: PUSH
62303: LD_VAR 0 3
62307: ARRAY
62308: PUSH
62309: LD_VAR 0 1
62313: DIFF
62314: PPUSH
62315: CALL_OW 1
62319: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62320: LD_VAR 0 1
62324: PUSH
62325: LD_EXP 140
62329: PUSH
62330: LD_VAR 0 3
62334: ARRAY
62335: IN
62336: IFFALSE 62360
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62338: LD_ADDR_EXP 140
62342: PUSH
62343: LD_EXP 140
62347: PPUSH
62348: LD_VAR 0 3
62352: PPUSH
62353: EMPTY
62354: PPUSH
62355: CALL_OW 1
62359: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62360: LD_VAR 0 1
62364: PPUSH
62365: CALL_OW 247
62369: PUSH
62370: LD_INT 2
62372: EQUAL
62373: PUSH
62374: LD_VAR 0 1
62378: PPUSH
62379: CALL_OW 110
62383: PUSH
62384: LD_INT 20
62386: EQUAL
62387: PUSH
62388: LD_VAR 0 1
62392: PUSH
62393: LD_EXP 132
62397: PUSH
62398: LD_VAR 0 3
62402: ARRAY
62403: IN
62404: OR
62405: PUSH
62406: LD_VAR 0 1
62410: PPUSH
62411: CALL_OW 264
62415: PUSH
62416: LD_INT 12
62418: PUSH
62419: LD_INT 51
62421: PUSH
62422: LD_EXP 96
62426: PUSH
62427: LD_INT 32
62429: PUSH
62430: LD_INT 13
62432: PUSH
62433: LD_INT 52
62435: PUSH
62436: LD_INT 31
62438: PUSH
62439: EMPTY
62440: LIST
62441: LIST
62442: LIST
62443: LIST
62444: LIST
62445: LIST
62446: LIST
62447: IN
62448: OR
62449: AND
62450: IFFALSE 62758
// begin if un in mc_defender [ i ] then
62452: LD_VAR 0 1
62456: PUSH
62457: LD_EXP 132
62461: PUSH
62462: LD_VAR 0 3
62466: ARRAY
62467: IN
62468: IFFALSE 62507
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62470: LD_ADDR_EXP 132
62474: PUSH
62475: LD_EXP 132
62479: PPUSH
62480: LD_VAR 0 3
62484: PPUSH
62485: LD_EXP 132
62489: PUSH
62490: LD_VAR 0 3
62494: ARRAY
62495: PUSH
62496: LD_VAR 0 1
62500: DIFF
62501: PPUSH
62502: CALL_OW 1
62506: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62507: LD_ADDR_VAR 0 8
62511: PUSH
62512: LD_VAR 0 3
62516: PPUSH
62517: LD_INT 3
62519: PPUSH
62520: CALL 59176 0 2
62524: ST_TO_ADDR
// if fac then
62525: LD_VAR 0 8
62529: IFFALSE 62758
// begin for j in fac do
62531: LD_ADDR_VAR 0 4
62535: PUSH
62536: LD_VAR 0 8
62540: PUSH
62541: FOR_IN
62542: IFFALSE 62756
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62544: LD_ADDR_VAR 0 9
62548: PUSH
62549: LD_VAR 0 8
62553: PPUSH
62554: LD_VAR 0 1
62558: PPUSH
62559: CALL_OW 265
62563: PPUSH
62564: LD_VAR 0 1
62568: PPUSH
62569: CALL_OW 262
62573: PPUSH
62574: LD_VAR 0 1
62578: PPUSH
62579: CALL_OW 263
62583: PPUSH
62584: LD_VAR 0 1
62588: PPUSH
62589: CALL_OW 264
62593: PPUSH
62594: CALL 67543 0 5
62598: ST_TO_ADDR
// if components then
62599: LD_VAR 0 9
62603: IFFALSE 62754
// begin if GetWeapon ( un ) = ar_control_tower then
62605: LD_VAR 0 1
62609: PPUSH
62610: CALL_OW 264
62614: PUSH
62615: LD_INT 31
62617: EQUAL
62618: IFFALSE 62735
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62620: LD_VAR 0 1
62624: PPUSH
62625: CALL_OW 311
62629: PPUSH
62630: LD_INT 0
62632: PPUSH
62633: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62637: LD_ADDR_EXP 150
62641: PUSH
62642: LD_EXP 150
62646: PPUSH
62647: LD_VAR 0 3
62651: PPUSH
62652: LD_EXP 150
62656: PUSH
62657: LD_VAR 0 3
62661: ARRAY
62662: PUSH
62663: LD_VAR 0 1
62667: PPUSH
62668: CALL_OW 311
62672: DIFF
62673: PPUSH
62674: CALL_OW 1
62678: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62679: LD_ADDR_VAR 0 7
62683: PUSH
62684: LD_EXP 131
62688: PUSH
62689: LD_VAR 0 3
62693: ARRAY
62694: PPUSH
62695: LD_INT 1
62697: PPUSH
62698: LD_VAR 0 9
62702: PPUSH
62703: CALL_OW 2
62707: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62708: LD_ADDR_EXP 131
62712: PUSH
62713: LD_EXP 131
62717: PPUSH
62718: LD_VAR 0 3
62722: PPUSH
62723: LD_VAR 0 7
62727: PPUSH
62728: CALL_OW 1
62732: ST_TO_ADDR
// end else
62733: GO 62752
// MC_InsertProduceList ( i , [ components ] ) ;
62735: LD_VAR 0 3
62739: PPUSH
62740: LD_VAR 0 9
62744: PUSH
62745: EMPTY
62746: LIST
62747: PPUSH
62748: CALL 58721 0 2
// break ;
62752: GO 62756
// end ; end ;
62754: GO 62541
62756: POP
62757: POP
// end ; end ; if GetType ( un ) = unit_building then
62758: LD_VAR 0 1
62762: PPUSH
62763: CALL_OW 247
62767: PUSH
62768: LD_INT 3
62770: EQUAL
62771: IFFALSE 63174
// begin btype := GetBType ( un ) ;
62773: LD_ADDR_VAR 0 5
62777: PUSH
62778: LD_VAR 0 1
62782: PPUSH
62783: CALL_OW 266
62787: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62788: LD_VAR 0 5
62792: PUSH
62793: LD_INT 29
62795: PUSH
62796: LD_INT 30
62798: PUSH
62799: EMPTY
62800: LIST
62801: LIST
62802: IN
62803: IFFALSE 62876
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62805: LD_VAR 0 1
62809: PPUSH
62810: CALL_OW 250
62814: PPUSH
62815: LD_VAR 0 1
62819: PPUSH
62820: CALL_OW 251
62824: PPUSH
62825: LD_VAR 0 1
62829: PPUSH
62830: CALL_OW 255
62834: PPUSH
62835: CALL_OW 440
62839: NOT
62840: IFFALSE 62876
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62842: LD_VAR 0 1
62846: PPUSH
62847: CALL_OW 250
62851: PPUSH
62852: LD_VAR 0 1
62856: PPUSH
62857: CALL_OW 251
62861: PPUSH
62862: LD_VAR 0 1
62866: PPUSH
62867: CALL_OW 255
62871: PPUSH
62872: CALL_OW 441
// end ; if btype = b_warehouse then
62876: LD_VAR 0 5
62880: PUSH
62881: LD_INT 1
62883: EQUAL
62884: IFFALSE 62902
// begin btype := b_depot ;
62886: LD_ADDR_VAR 0 5
62890: PUSH
62891: LD_INT 0
62893: ST_TO_ADDR
// pos := 1 ;
62894: LD_ADDR_VAR 0 6
62898: PUSH
62899: LD_INT 1
62901: ST_TO_ADDR
// end ; if btype = b_factory then
62902: LD_VAR 0 5
62906: PUSH
62907: LD_INT 3
62909: EQUAL
62910: IFFALSE 62928
// begin btype := b_workshop ;
62912: LD_ADDR_VAR 0 5
62916: PUSH
62917: LD_INT 2
62919: ST_TO_ADDR
// pos := 1 ;
62920: LD_ADDR_VAR 0 6
62924: PUSH
62925: LD_INT 1
62927: ST_TO_ADDR
// end ; if btype = b_barracks then
62928: LD_VAR 0 5
62932: PUSH
62933: LD_INT 5
62935: EQUAL
62936: IFFALSE 62946
// btype := b_armoury ;
62938: LD_ADDR_VAR 0 5
62942: PUSH
62943: LD_INT 4
62945: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62946: LD_VAR 0 5
62950: PUSH
62951: LD_INT 7
62953: PUSH
62954: LD_INT 8
62956: PUSH
62957: EMPTY
62958: LIST
62959: LIST
62960: IN
62961: IFFALSE 62971
// btype := b_lab ;
62963: LD_ADDR_VAR 0 5
62967: PUSH
62968: LD_INT 6
62970: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62971: LD_ADDR_EXP 115
62975: PUSH
62976: LD_EXP 115
62980: PPUSH
62981: LD_VAR 0 3
62985: PUSH
62986: LD_EXP 115
62990: PUSH
62991: LD_VAR 0 3
62995: ARRAY
62996: PUSH
62997: LD_INT 1
62999: PLUS
63000: PUSH
63001: EMPTY
63002: LIST
63003: LIST
63004: PPUSH
63005: LD_VAR 0 5
63009: PUSH
63010: LD_VAR 0 1
63014: PPUSH
63015: CALL_OW 250
63019: PUSH
63020: LD_VAR 0 1
63024: PPUSH
63025: CALL_OW 251
63029: PUSH
63030: LD_VAR 0 1
63034: PPUSH
63035: CALL_OW 254
63039: PUSH
63040: EMPTY
63041: LIST
63042: LIST
63043: LIST
63044: LIST
63045: PPUSH
63046: CALL 70011 0 3
63050: ST_TO_ADDR
// if pos = 1 then
63051: LD_VAR 0 6
63055: PUSH
63056: LD_INT 1
63058: EQUAL
63059: IFFALSE 63174
// begin tmp := mc_build_list [ i ] ;
63061: LD_ADDR_VAR 0 7
63065: PUSH
63066: LD_EXP 115
63070: PUSH
63071: LD_VAR 0 3
63075: ARRAY
63076: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63077: LD_VAR 0 7
63081: PPUSH
63082: LD_INT 2
63084: PUSH
63085: LD_INT 30
63087: PUSH
63088: LD_INT 0
63090: PUSH
63091: EMPTY
63092: LIST
63093: LIST
63094: PUSH
63095: LD_INT 30
63097: PUSH
63098: LD_INT 1
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: PUSH
63105: EMPTY
63106: LIST
63107: LIST
63108: LIST
63109: PPUSH
63110: CALL_OW 72
63114: IFFALSE 63124
// pos := 2 ;
63116: LD_ADDR_VAR 0 6
63120: PUSH
63121: LD_INT 2
63123: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63124: LD_ADDR_VAR 0 7
63128: PUSH
63129: LD_VAR 0 7
63133: PPUSH
63134: LD_VAR 0 6
63138: PPUSH
63139: LD_VAR 0 7
63143: PPUSH
63144: CALL 70337 0 3
63148: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63149: LD_ADDR_EXP 115
63153: PUSH
63154: LD_EXP 115
63158: PPUSH
63159: LD_VAR 0 3
63163: PPUSH
63164: LD_VAR 0 7
63168: PPUSH
63169: CALL_OW 1
63173: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63174: LD_VAR 0 1
63178: PUSH
63179: LD_EXP 110
63183: PUSH
63184: LD_VAR 0 3
63188: ARRAY
63189: IN
63190: IFFALSE 63229
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63192: LD_ADDR_EXP 110
63196: PUSH
63197: LD_EXP 110
63201: PPUSH
63202: LD_VAR 0 3
63206: PPUSH
63207: LD_EXP 110
63211: PUSH
63212: LD_VAR 0 3
63216: ARRAY
63217: PUSH
63218: LD_VAR 0 1
63222: DIFF
63223: PPUSH
63224: CALL_OW 1
63228: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63229: LD_VAR 0 1
63233: PUSH
63234: LD_EXP 117
63238: PUSH
63239: LD_VAR 0 3
63243: ARRAY
63244: IN
63245: IFFALSE 63284
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63247: LD_ADDR_EXP 117
63251: PUSH
63252: LD_EXP 117
63256: PPUSH
63257: LD_VAR 0 3
63261: PPUSH
63262: LD_EXP 117
63266: PUSH
63267: LD_VAR 0 3
63271: ARRAY
63272: PUSH
63273: LD_VAR 0 1
63277: DIFF
63278: PPUSH
63279: CALL_OW 1
63283: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63284: LD_VAR 0 1
63288: PUSH
63289: LD_EXP 129
63293: PUSH
63294: LD_VAR 0 3
63298: ARRAY
63299: IN
63300: IFFALSE 63339
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63302: LD_ADDR_EXP 129
63306: PUSH
63307: LD_EXP 129
63311: PPUSH
63312: LD_VAR 0 3
63316: PPUSH
63317: LD_EXP 129
63321: PUSH
63322: LD_VAR 0 3
63326: ARRAY
63327: PUSH
63328: LD_VAR 0 1
63332: DIFF
63333: PPUSH
63334: CALL_OW 1
63338: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63339: LD_VAR 0 1
63343: PUSH
63344: LD_EXP 132
63348: PUSH
63349: LD_VAR 0 3
63353: ARRAY
63354: IN
63355: IFFALSE 63394
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63357: LD_ADDR_EXP 132
63361: PUSH
63362: LD_EXP 132
63366: PPUSH
63367: LD_VAR 0 3
63371: PPUSH
63372: LD_EXP 132
63376: PUSH
63377: LD_VAR 0 3
63381: ARRAY
63382: PUSH
63383: LD_VAR 0 1
63387: DIFF
63388: PPUSH
63389: CALL_OW 1
63393: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63394: LD_VAR 0 1
63398: PUSH
63399: LD_EXP 119
63403: PUSH
63404: LD_VAR 0 3
63408: ARRAY
63409: IN
63410: IFFALSE 63449
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63412: LD_ADDR_EXP 119
63416: PUSH
63417: LD_EXP 119
63421: PPUSH
63422: LD_VAR 0 3
63426: PPUSH
63427: LD_EXP 119
63431: PUSH
63432: LD_VAR 0 3
63436: ARRAY
63437: PUSH
63438: LD_VAR 0 1
63442: DIFF
63443: PPUSH
63444: CALL_OW 1
63448: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63449: LD_VAR 0 1
63453: PUSH
63454: LD_EXP 118
63458: PUSH
63459: LD_VAR 0 3
63463: ARRAY
63464: IN
63465: IFFALSE 63504
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63467: LD_ADDR_EXP 118
63471: PUSH
63472: LD_EXP 118
63476: PPUSH
63477: LD_VAR 0 3
63481: PPUSH
63482: LD_EXP 118
63486: PUSH
63487: LD_VAR 0 3
63491: ARRAY
63492: PUSH
63493: LD_VAR 0 1
63497: DIFF
63498: PPUSH
63499: CALL_OW 1
63503: ST_TO_ADDR
// end ; break ;
63504: GO 63508
// end ;
63506: GO 62154
63508: POP
63509: POP
// end ;
63510: LD_VAR 0 2
63514: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63515: LD_INT 0
63517: PPUSH
63518: PPUSH
63519: PPUSH
// if not mc_bases or not skirmish then
63520: LD_EXP 110
63524: NOT
63525: PUSH
63526: LD_EXP 108
63530: NOT
63531: OR
63532: IFFALSE 63536
// exit ;
63534: GO 63751
// for i = 1 to mc_bases do
63536: LD_ADDR_VAR 0 3
63540: PUSH
63541: DOUBLE
63542: LD_INT 1
63544: DEC
63545: ST_TO_ADDR
63546: LD_EXP 110
63550: PUSH
63551: FOR_TO
63552: IFFALSE 63749
// begin if building in mc_construct_list [ i ] then
63554: LD_VAR 0 1
63558: PUSH
63559: LD_EXP 117
63563: PUSH
63564: LD_VAR 0 3
63568: ARRAY
63569: IN
63570: IFFALSE 63747
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63572: LD_ADDR_EXP 117
63576: PUSH
63577: LD_EXP 117
63581: PPUSH
63582: LD_VAR 0 3
63586: PPUSH
63587: LD_EXP 117
63591: PUSH
63592: LD_VAR 0 3
63596: ARRAY
63597: PUSH
63598: LD_VAR 0 1
63602: DIFF
63603: PPUSH
63604: CALL_OW 1
63608: ST_TO_ADDR
// if building in mc_lab [ i ] then
63609: LD_VAR 0 1
63613: PUSH
63614: LD_EXP 143
63618: PUSH
63619: LD_VAR 0 3
63623: ARRAY
63624: IN
63625: IFFALSE 63680
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63627: LD_ADDR_EXP 144
63631: PUSH
63632: LD_EXP 144
63636: PPUSH
63637: LD_VAR 0 3
63641: PPUSH
63642: LD_EXP 144
63646: PUSH
63647: LD_VAR 0 3
63651: ARRAY
63652: PPUSH
63653: LD_INT 1
63655: PPUSH
63656: LD_EXP 144
63660: PUSH
63661: LD_VAR 0 3
63665: ARRAY
63666: PPUSH
63667: LD_INT 0
63669: PPUSH
63670: CALL 69429 0 4
63674: PPUSH
63675: CALL_OW 1
63679: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63680: LD_VAR 0 1
63684: PUSH
63685: LD_EXP 110
63689: PUSH
63690: LD_VAR 0 3
63694: ARRAY
63695: IN
63696: NOT
63697: IFFALSE 63743
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63699: LD_ADDR_EXP 110
63703: PUSH
63704: LD_EXP 110
63708: PPUSH
63709: LD_VAR 0 3
63713: PUSH
63714: LD_EXP 110
63718: PUSH
63719: LD_VAR 0 3
63723: ARRAY
63724: PUSH
63725: LD_INT 1
63727: PLUS
63728: PUSH
63729: EMPTY
63730: LIST
63731: LIST
63732: PPUSH
63733: LD_VAR 0 1
63737: PPUSH
63738: CALL 70011 0 3
63742: ST_TO_ADDR
// exit ;
63743: POP
63744: POP
63745: GO 63751
// end ; end ;
63747: GO 63551
63749: POP
63750: POP
// end ;
63751: LD_VAR 0 2
63755: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63756: LD_INT 0
63758: PPUSH
63759: PPUSH
63760: PPUSH
63761: PPUSH
63762: PPUSH
63763: PPUSH
63764: PPUSH
// if not mc_bases or not skirmish then
63765: LD_EXP 110
63769: NOT
63770: PUSH
63771: LD_EXP 108
63775: NOT
63776: OR
63777: IFFALSE 63781
// exit ;
63779: GO 64442
// for i = 1 to mc_bases do
63781: LD_ADDR_VAR 0 3
63785: PUSH
63786: DOUBLE
63787: LD_INT 1
63789: DEC
63790: ST_TO_ADDR
63791: LD_EXP 110
63795: PUSH
63796: FOR_TO
63797: IFFALSE 64440
// begin if building in mc_construct_list [ i ] then
63799: LD_VAR 0 1
63803: PUSH
63804: LD_EXP 117
63808: PUSH
63809: LD_VAR 0 3
63813: ARRAY
63814: IN
63815: IFFALSE 64438
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63817: LD_ADDR_EXP 117
63821: PUSH
63822: LD_EXP 117
63826: PPUSH
63827: LD_VAR 0 3
63831: PPUSH
63832: LD_EXP 117
63836: PUSH
63837: LD_VAR 0 3
63841: ARRAY
63842: PUSH
63843: LD_VAR 0 1
63847: DIFF
63848: PPUSH
63849: CALL_OW 1
63853: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63854: LD_ADDR_EXP 110
63858: PUSH
63859: LD_EXP 110
63863: PPUSH
63864: LD_VAR 0 3
63868: PUSH
63869: LD_EXP 110
63873: PUSH
63874: LD_VAR 0 3
63878: ARRAY
63879: PUSH
63880: LD_INT 1
63882: PLUS
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PPUSH
63888: LD_VAR 0 1
63892: PPUSH
63893: CALL 70011 0 3
63897: ST_TO_ADDR
// btype := GetBType ( building ) ;
63898: LD_ADDR_VAR 0 5
63902: PUSH
63903: LD_VAR 0 1
63907: PPUSH
63908: CALL_OW 266
63912: ST_TO_ADDR
// side := GetSide ( building ) ;
63913: LD_ADDR_VAR 0 8
63917: PUSH
63918: LD_VAR 0 1
63922: PPUSH
63923: CALL_OW 255
63927: ST_TO_ADDR
// if btype = b_lab then
63928: LD_VAR 0 5
63932: PUSH
63933: LD_INT 6
63935: EQUAL
63936: IFFALSE 63986
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63938: LD_ADDR_EXP 143
63942: PUSH
63943: LD_EXP 143
63947: PPUSH
63948: LD_VAR 0 3
63952: PUSH
63953: LD_EXP 143
63957: PUSH
63958: LD_VAR 0 3
63962: ARRAY
63963: PUSH
63964: LD_INT 1
63966: PLUS
63967: PUSH
63968: EMPTY
63969: LIST
63970: LIST
63971: PPUSH
63972: LD_VAR 0 1
63976: PPUSH
63977: CALL 70011 0 3
63981: ST_TO_ADDR
// exit ;
63982: POP
63983: POP
63984: GO 64442
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63986: LD_VAR 0 5
63990: PUSH
63991: LD_INT 0
63993: PUSH
63994: LD_INT 2
63996: PUSH
63997: LD_INT 4
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: LIST
64004: IN
64005: IFFALSE 64129
// begin if btype = b_armoury then
64007: LD_VAR 0 5
64011: PUSH
64012: LD_INT 4
64014: EQUAL
64015: IFFALSE 64025
// btype := b_barracks ;
64017: LD_ADDR_VAR 0 5
64021: PUSH
64022: LD_INT 5
64024: ST_TO_ADDR
// if btype = b_depot then
64025: LD_VAR 0 5
64029: PUSH
64030: LD_INT 0
64032: EQUAL
64033: IFFALSE 64043
// btype := b_warehouse ;
64035: LD_ADDR_VAR 0 5
64039: PUSH
64040: LD_INT 1
64042: ST_TO_ADDR
// if btype = b_workshop then
64043: LD_VAR 0 5
64047: PUSH
64048: LD_INT 2
64050: EQUAL
64051: IFFALSE 64061
// btype := b_factory ;
64053: LD_ADDR_VAR 0 5
64057: PUSH
64058: LD_INT 3
64060: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64061: LD_VAR 0 5
64065: PPUSH
64066: LD_VAR 0 8
64070: PPUSH
64071: CALL_OW 323
64075: PUSH
64076: LD_INT 1
64078: EQUAL
64079: IFFALSE 64125
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64081: LD_ADDR_EXP 142
64085: PUSH
64086: LD_EXP 142
64090: PPUSH
64091: LD_VAR 0 3
64095: PUSH
64096: LD_EXP 142
64100: PUSH
64101: LD_VAR 0 3
64105: ARRAY
64106: PUSH
64107: LD_INT 1
64109: PLUS
64110: PUSH
64111: EMPTY
64112: LIST
64113: LIST
64114: PPUSH
64115: LD_VAR 0 1
64119: PPUSH
64120: CALL 70011 0 3
64124: ST_TO_ADDR
// exit ;
64125: POP
64126: POP
64127: GO 64442
// end ; if btype in [ b_bunker , b_turret ] then
64129: LD_VAR 0 5
64133: PUSH
64134: LD_INT 32
64136: PUSH
64137: LD_INT 33
64139: PUSH
64140: EMPTY
64141: LIST
64142: LIST
64143: IN
64144: IFFALSE 64434
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64146: LD_ADDR_EXP 118
64150: PUSH
64151: LD_EXP 118
64155: PPUSH
64156: LD_VAR 0 3
64160: PUSH
64161: LD_EXP 118
64165: PUSH
64166: LD_VAR 0 3
64170: ARRAY
64171: PUSH
64172: LD_INT 1
64174: PLUS
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: PPUSH
64180: LD_VAR 0 1
64184: PPUSH
64185: CALL 70011 0 3
64189: ST_TO_ADDR
// if btype = b_bunker then
64190: LD_VAR 0 5
64194: PUSH
64195: LD_INT 32
64197: EQUAL
64198: IFFALSE 64434
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64200: LD_ADDR_EXP 119
64204: PUSH
64205: LD_EXP 119
64209: PPUSH
64210: LD_VAR 0 3
64214: PUSH
64215: LD_EXP 119
64219: PUSH
64220: LD_VAR 0 3
64224: ARRAY
64225: PUSH
64226: LD_INT 1
64228: PLUS
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PPUSH
64234: LD_VAR 0 1
64238: PPUSH
64239: CALL 70011 0 3
64243: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64244: LD_ADDR_VAR 0 6
64248: PUSH
64249: LD_EXP 110
64253: PUSH
64254: LD_VAR 0 3
64258: ARRAY
64259: PPUSH
64260: LD_INT 25
64262: PUSH
64263: LD_INT 1
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: PUSH
64270: LD_INT 3
64272: PUSH
64273: LD_INT 54
64275: PUSH
64276: EMPTY
64277: LIST
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PPUSH
64287: CALL_OW 72
64291: ST_TO_ADDR
// if tmp then
64292: LD_VAR 0 6
64296: IFFALSE 64302
// exit ;
64298: POP
64299: POP
64300: GO 64442
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64302: LD_ADDR_VAR 0 6
64306: PUSH
64307: LD_EXP 110
64311: PUSH
64312: LD_VAR 0 3
64316: ARRAY
64317: PPUSH
64318: LD_INT 2
64320: PUSH
64321: LD_INT 30
64323: PUSH
64324: LD_INT 4
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: PUSH
64331: LD_INT 30
64333: PUSH
64334: LD_INT 5
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PUSH
64341: EMPTY
64342: LIST
64343: LIST
64344: LIST
64345: PPUSH
64346: CALL_OW 72
64350: ST_TO_ADDR
// if not tmp then
64351: LD_VAR 0 6
64355: NOT
64356: IFFALSE 64362
// exit ;
64358: POP
64359: POP
64360: GO 64442
// for j in tmp do
64362: LD_ADDR_VAR 0 4
64366: PUSH
64367: LD_VAR 0 6
64371: PUSH
64372: FOR_IN
64373: IFFALSE 64432
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64375: LD_ADDR_VAR 0 7
64379: PUSH
64380: LD_VAR 0 4
64384: PPUSH
64385: CALL_OW 313
64389: PPUSH
64390: LD_INT 25
64392: PUSH
64393: LD_INT 1
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PPUSH
64400: CALL_OW 72
64404: ST_TO_ADDR
// if units then
64405: LD_VAR 0 7
64409: IFFALSE 64430
// begin ComExitBuilding ( units [ 1 ] ) ;
64411: LD_VAR 0 7
64415: PUSH
64416: LD_INT 1
64418: ARRAY
64419: PPUSH
64420: CALL_OW 122
// exit ;
64424: POP
64425: POP
64426: POP
64427: POP
64428: GO 64442
// end ; end ;
64430: GO 64372
64432: POP
64433: POP
// end ; end ; exit ;
64434: POP
64435: POP
64436: GO 64442
// end ; end ;
64438: GO 63796
64440: POP
64441: POP
// end ;
64442: LD_VAR 0 2
64446: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64447: LD_INT 0
64449: PPUSH
64450: PPUSH
64451: PPUSH
64452: PPUSH
64453: PPUSH
64454: PPUSH
64455: PPUSH
// if not mc_bases or not skirmish then
64456: LD_EXP 110
64460: NOT
64461: PUSH
64462: LD_EXP 108
64466: NOT
64467: OR
64468: IFFALSE 64472
// exit ;
64470: GO 64703
// btype := GetBType ( building ) ;
64472: LD_ADDR_VAR 0 6
64476: PUSH
64477: LD_VAR 0 1
64481: PPUSH
64482: CALL_OW 266
64486: ST_TO_ADDR
// x := GetX ( building ) ;
64487: LD_ADDR_VAR 0 7
64491: PUSH
64492: LD_VAR 0 1
64496: PPUSH
64497: CALL_OW 250
64501: ST_TO_ADDR
// y := GetY ( building ) ;
64502: LD_ADDR_VAR 0 8
64506: PUSH
64507: LD_VAR 0 1
64511: PPUSH
64512: CALL_OW 251
64516: ST_TO_ADDR
// d := GetDir ( building ) ;
64517: LD_ADDR_VAR 0 9
64521: PUSH
64522: LD_VAR 0 1
64526: PPUSH
64527: CALL_OW 254
64531: ST_TO_ADDR
// for i = 1 to mc_bases do
64532: LD_ADDR_VAR 0 4
64536: PUSH
64537: DOUBLE
64538: LD_INT 1
64540: DEC
64541: ST_TO_ADDR
64542: LD_EXP 110
64546: PUSH
64547: FOR_TO
64548: IFFALSE 64701
// begin if not mc_build_list [ i ] then
64550: LD_EXP 115
64554: PUSH
64555: LD_VAR 0 4
64559: ARRAY
64560: NOT
64561: IFFALSE 64565
// continue ;
64563: GO 64547
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64565: LD_VAR 0 6
64569: PUSH
64570: LD_VAR 0 7
64574: PUSH
64575: LD_VAR 0 8
64579: PUSH
64580: LD_VAR 0 9
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: PPUSH
64591: LD_EXP 115
64595: PUSH
64596: LD_VAR 0 4
64600: ARRAY
64601: PUSH
64602: LD_INT 1
64604: ARRAY
64605: PPUSH
64606: CALL 76180 0 2
64610: IFFALSE 64699
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64612: LD_ADDR_EXP 115
64616: PUSH
64617: LD_EXP 115
64621: PPUSH
64622: LD_VAR 0 4
64626: PPUSH
64627: LD_EXP 115
64631: PUSH
64632: LD_VAR 0 4
64636: ARRAY
64637: PPUSH
64638: LD_INT 1
64640: PPUSH
64641: CALL_OW 3
64645: PPUSH
64646: CALL_OW 1
64650: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64651: LD_ADDR_EXP 117
64655: PUSH
64656: LD_EXP 117
64660: PPUSH
64661: LD_VAR 0 4
64665: PUSH
64666: LD_EXP 117
64670: PUSH
64671: LD_VAR 0 4
64675: ARRAY
64676: PUSH
64677: LD_INT 1
64679: PLUS
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PPUSH
64685: LD_VAR 0 1
64689: PPUSH
64690: CALL 70011 0 3
64694: ST_TO_ADDR
// exit ;
64695: POP
64696: POP
64697: GO 64703
// end ; end ;
64699: GO 64547
64701: POP
64702: POP
// end ;
64703: LD_VAR 0 3
64707: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64708: LD_INT 0
64710: PPUSH
64711: PPUSH
64712: PPUSH
// if not mc_bases or not skirmish then
64713: LD_EXP 110
64717: NOT
64718: PUSH
64719: LD_EXP 108
64723: NOT
64724: OR
64725: IFFALSE 64729
// exit ;
64727: GO 64919
// for i = 1 to mc_bases do
64729: LD_ADDR_VAR 0 4
64733: PUSH
64734: DOUBLE
64735: LD_INT 1
64737: DEC
64738: ST_TO_ADDR
64739: LD_EXP 110
64743: PUSH
64744: FOR_TO
64745: IFFALSE 64832
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64747: LD_VAR 0 1
64751: PUSH
64752: LD_EXP 118
64756: PUSH
64757: LD_VAR 0 4
64761: ARRAY
64762: IN
64763: PUSH
64764: LD_VAR 0 1
64768: PUSH
64769: LD_EXP 119
64773: PUSH
64774: LD_VAR 0 4
64778: ARRAY
64779: IN
64780: NOT
64781: AND
64782: IFFALSE 64830
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64784: LD_ADDR_EXP 119
64788: PUSH
64789: LD_EXP 119
64793: PPUSH
64794: LD_VAR 0 4
64798: PUSH
64799: LD_EXP 119
64803: PUSH
64804: LD_VAR 0 4
64808: ARRAY
64809: PUSH
64810: LD_INT 1
64812: PLUS
64813: PUSH
64814: EMPTY
64815: LIST
64816: LIST
64817: PPUSH
64818: LD_VAR 0 1
64822: PPUSH
64823: CALL 70011 0 3
64827: ST_TO_ADDR
// break ;
64828: GO 64832
// end ; end ;
64830: GO 64744
64832: POP
64833: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64834: LD_VAR 0 1
64838: PPUSH
64839: CALL_OW 257
64843: PUSH
64844: LD_EXP 136
64848: IN
64849: PUSH
64850: LD_VAR 0 1
64854: PPUSH
64855: CALL_OW 266
64859: PUSH
64860: LD_INT 5
64862: EQUAL
64863: AND
64864: PUSH
64865: LD_VAR 0 2
64869: PPUSH
64870: CALL_OW 110
64874: PUSH
64875: LD_INT 18
64877: NONEQUAL
64878: AND
64879: IFFALSE 64919
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64881: LD_VAR 0 2
64885: PPUSH
64886: CALL_OW 257
64890: PUSH
64891: LD_INT 5
64893: PUSH
64894: LD_INT 8
64896: PUSH
64897: LD_INT 9
64899: PUSH
64900: EMPTY
64901: LIST
64902: LIST
64903: LIST
64904: IN
64905: IFFALSE 64919
// SetClass ( unit , 1 ) ;
64907: LD_VAR 0 2
64911: PPUSH
64912: LD_INT 1
64914: PPUSH
64915: CALL_OW 336
// end ;
64919: LD_VAR 0 3
64923: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64924: LD_INT 0
64926: PPUSH
64927: PPUSH
// if not mc_bases or not skirmish then
64928: LD_EXP 110
64932: NOT
64933: PUSH
64934: LD_EXP 108
64938: NOT
64939: OR
64940: IFFALSE 64944
// exit ;
64942: GO 65060
// if GetLives ( abandoned_vehicle ) > 250 then
64944: LD_VAR 0 2
64948: PPUSH
64949: CALL_OW 256
64953: PUSH
64954: LD_INT 250
64956: GREATER
64957: IFFALSE 64961
// exit ;
64959: GO 65060
// for i = 1 to mc_bases do
64961: LD_ADDR_VAR 0 6
64965: PUSH
64966: DOUBLE
64967: LD_INT 1
64969: DEC
64970: ST_TO_ADDR
64971: LD_EXP 110
64975: PUSH
64976: FOR_TO
64977: IFFALSE 65058
// begin if driver in mc_bases [ i ] then
64979: LD_VAR 0 1
64983: PUSH
64984: LD_EXP 110
64988: PUSH
64989: LD_VAR 0 6
64993: ARRAY
64994: IN
64995: IFFALSE 65056
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64997: LD_VAR 0 1
65001: PPUSH
65002: LD_EXP 110
65006: PUSH
65007: LD_VAR 0 6
65011: ARRAY
65012: PPUSH
65013: LD_INT 2
65015: PUSH
65016: LD_INT 30
65018: PUSH
65019: LD_INT 0
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 30
65028: PUSH
65029: LD_INT 1
65031: PUSH
65032: EMPTY
65033: LIST
65034: LIST
65035: PUSH
65036: EMPTY
65037: LIST
65038: LIST
65039: LIST
65040: PPUSH
65041: CALL_OW 72
65045: PUSH
65046: LD_INT 1
65048: ARRAY
65049: PPUSH
65050: CALL_OW 112
// break ;
65054: GO 65058
// end ; end ;
65056: GO 64976
65058: POP
65059: POP
// end ; end_of_file
65060: LD_VAR 0 5
65064: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65065: LD_INT 0
65067: PPUSH
65068: PPUSH
// if exist_mode then
65069: LD_VAR 0 2
65073: IFFALSE 65098
// unit := CreateCharacter ( prefix & ident ) else
65075: LD_ADDR_VAR 0 5
65079: PUSH
65080: LD_VAR 0 3
65084: PUSH
65085: LD_VAR 0 1
65089: STR
65090: PPUSH
65091: CALL_OW 34
65095: ST_TO_ADDR
65096: GO 65113
// unit := NewCharacter ( ident ) ;
65098: LD_ADDR_VAR 0 5
65102: PUSH
65103: LD_VAR 0 1
65107: PPUSH
65108: CALL_OW 25
65112: ST_TO_ADDR
// result := unit ;
65113: LD_ADDR_VAR 0 4
65117: PUSH
65118: LD_VAR 0 5
65122: ST_TO_ADDR
// end ;
65123: LD_VAR 0 4
65127: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65128: LD_INT 0
65130: PPUSH
65131: PPUSH
// if not side or not nation then
65132: LD_VAR 0 1
65136: NOT
65137: PUSH
65138: LD_VAR 0 2
65142: NOT
65143: OR
65144: IFFALSE 65148
// exit ;
65146: GO 65912
// case nation of nation_american :
65148: LD_VAR 0 2
65152: PUSH
65153: LD_INT 1
65155: DOUBLE
65156: EQUAL
65157: IFTRUE 65161
65159: GO 65375
65161: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65162: LD_ADDR_VAR 0 4
65166: PUSH
65167: LD_INT 35
65169: PUSH
65170: LD_INT 45
65172: PUSH
65173: LD_INT 46
65175: PUSH
65176: LD_INT 47
65178: PUSH
65179: LD_INT 82
65181: PUSH
65182: LD_INT 83
65184: PUSH
65185: LD_INT 84
65187: PUSH
65188: LD_INT 85
65190: PUSH
65191: LD_INT 86
65193: PUSH
65194: LD_INT 1
65196: PUSH
65197: LD_INT 2
65199: PUSH
65200: LD_INT 6
65202: PUSH
65203: LD_INT 15
65205: PUSH
65206: LD_INT 16
65208: PUSH
65209: LD_INT 7
65211: PUSH
65212: LD_INT 12
65214: PUSH
65215: LD_INT 13
65217: PUSH
65218: LD_INT 10
65220: PUSH
65221: LD_INT 14
65223: PUSH
65224: LD_INT 20
65226: PUSH
65227: LD_INT 21
65229: PUSH
65230: LD_INT 22
65232: PUSH
65233: LD_INT 25
65235: PUSH
65236: LD_INT 32
65238: PUSH
65239: LD_INT 27
65241: PUSH
65242: LD_INT 36
65244: PUSH
65245: LD_INT 69
65247: PUSH
65248: LD_INT 39
65250: PUSH
65251: LD_INT 34
65253: PUSH
65254: LD_INT 40
65256: PUSH
65257: LD_INT 48
65259: PUSH
65260: LD_INT 49
65262: PUSH
65263: LD_INT 50
65265: PUSH
65266: LD_INT 51
65268: PUSH
65269: LD_INT 52
65271: PUSH
65272: LD_INT 53
65274: PUSH
65275: LD_INT 54
65277: PUSH
65278: LD_INT 55
65280: PUSH
65281: LD_INT 56
65283: PUSH
65284: LD_INT 57
65286: PUSH
65287: LD_INT 58
65289: PUSH
65290: LD_INT 59
65292: PUSH
65293: LD_INT 60
65295: PUSH
65296: LD_INT 61
65298: PUSH
65299: LD_INT 62
65301: PUSH
65302: LD_INT 80
65304: PUSH
65305: LD_INT 82
65307: PUSH
65308: LD_INT 83
65310: PUSH
65311: LD_INT 84
65313: PUSH
65314: LD_INT 85
65316: PUSH
65317: LD_INT 86
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: LIST
65327: LIST
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: ST_TO_ADDR
65373: GO 65836
65375: LD_INT 2
65377: DOUBLE
65378: EQUAL
65379: IFTRUE 65383
65381: GO 65605
65383: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65384: LD_ADDR_VAR 0 4
65388: PUSH
65389: LD_INT 35
65391: PUSH
65392: LD_INT 45
65394: PUSH
65395: LD_INT 46
65397: PUSH
65398: LD_INT 47
65400: PUSH
65401: LD_INT 82
65403: PUSH
65404: LD_INT 83
65406: PUSH
65407: LD_INT 84
65409: PUSH
65410: LD_INT 85
65412: PUSH
65413: LD_INT 87
65415: PUSH
65416: LD_INT 70
65418: PUSH
65419: LD_INT 1
65421: PUSH
65422: LD_INT 11
65424: PUSH
65425: LD_INT 3
65427: PUSH
65428: LD_INT 4
65430: PUSH
65431: LD_INT 5
65433: PUSH
65434: LD_INT 6
65436: PUSH
65437: LD_INT 15
65439: PUSH
65440: LD_INT 18
65442: PUSH
65443: LD_INT 7
65445: PUSH
65446: LD_INT 17
65448: PUSH
65449: LD_INT 8
65451: PUSH
65452: LD_INT 20
65454: PUSH
65455: LD_INT 21
65457: PUSH
65458: LD_INT 22
65460: PUSH
65461: LD_INT 72
65463: PUSH
65464: LD_INT 26
65466: PUSH
65467: LD_INT 69
65469: PUSH
65470: LD_INT 39
65472: PUSH
65473: LD_INT 40
65475: PUSH
65476: LD_INT 41
65478: PUSH
65479: LD_INT 42
65481: PUSH
65482: LD_INT 43
65484: PUSH
65485: LD_INT 48
65487: PUSH
65488: LD_INT 49
65490: PUSH
65491: LD_INT 50
65493: PUSH
65494: LD_INT 51
65496: PUSH
65497: LD_INT 52
65499: PUSH
65500: LD_INT 53
65502: PUSH
65503: LD_INT 54
65505: PUSH
65506: LD_INT 55
65508: PUSH
65509: LD_INT 56
65511: PUSH
65512: LD_INT 60
65514: PUSH
65515: LD_INT 61
65517: PUSH
65518: LD_INT 62
65520: PUSH
65521: LD_INT 66
65523: PUSH
65524: LD_INT 67
65526: PUSH
65527: LD_INT 68
65529: PUSH
65530: LD_INT 81
65532: PUSH
65533: LD_INT 82
65535: PUSH
65536: LD_INT 83
65538: PUSH
65539: LD_INT 84
65541: PUSH
65542: LD_INT 85
65544: PUSH
65545: LD_INT 87
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: LIST
65552: LIST
65553: LIST
65554: LIST
65555: LIST
65556: LIST
65557: LIST
65558: LIST
65559: LIST
65560: LIST
65561: LIST
65562: LIST
65563: LIST
65564: LIST
65565: LIST
65566: LIST
65567: LIST
65568: LIST
65569: LIST
65570: LIST
65571: LIST
65572: LIST
65573: LIST
65574: LIST
65575: LIST
65576: LIST
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: ST_TO_ADDR
65603: GO 65836
65605: LD_INT 3
65607: DOUBLE
65608: EQUAL
65609: IFTRUE 65613
65611: GO 65835
65613: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65614: LD_ADDR_VAR 0 4
65618: PUSH
65619: LD_INT 46
65621: PUSH
65622: LD_INT 47
65624: PUSH
65625: LD_INT 1
65627: PUSH
65628: LD_INT 2
65630: PUSH
65631: LD_INT 82
65633: PUSH
65634: LD_INT 83
65636: PUSH
65637: LD_INT 84
65639: PUSH
65640: LD_INT 85
65642: PUSH
65643: LD_INT 86
65645: PUSH
65646: LD_INT 11
65648: PUSH
65649: LD_INT 9
65651: PUSH
65652: LD_INT 20
65654: PUSH
65655: LD_INT 19
65657: PUSH
65658: LD_INT 21
65660: PUSH
65661: LD_INT 24
65663: PUSH
65664: LD_INT 22
65666: PUSH
65667: LD_INT 25
65669: PUSH
65670: LD_INT 28
65672: PUSH
65673: LD_INT 29
65675: PUSH
65676: LD_INT 30
65678: PUSH
65679: LD_INT 31
65681: PUSH
65682: LD_INT 37
65684: PUSH
65685: LD_INT 38
65687: PUSH
65688: LD_INT 32
65690: PUSH
65691: LD_INT 27
65693: PUSH
65694: LD_INT 33
65696: PUSH
65697: LD_INT 69
65699: PUSH
65700: LD_INT 39
65702: PUSH
65703: LD_INT 34
65705: PUSH
65706: LD_INT 40
65708: PUSH
65709: LD_INT 71
65711: PUSH
65712: LD_INT 23
65714: PUSH
65715: LD_INT 44
65717: PUSH
65718: LD_INT 48
65720: PUSH
65721: LD_INT 49
65723: PUSH
65724: LD_INT 50
65726: PUSH
65727: LD_INT 51
65729: PUSH
65730: LD_INT 52
65732: PUSH
65733: LD_INT 53
65735: PUSH
65736: LD_INT 54
65738: PUSH
65739: LD_INT 55
65741: PUSH
65742: LD_INT 56
65744: PUSH
65745: LD_INT 57
65747: PUSH
65748: LD_INT 58
65750: PUSH
65751: LD_INT 59
65753: PUSH
65754: LD_INT 63
65756: PUSH
65757: LD_INT 64
65759: PUSH
65760: LD_INT 65
65762: PUSH
65763: LD_INT 82
65765: PUSH
65766: LD_INT 83
65768: PUSH
65769: LD_INT 84
65771: PUSH
65772: LD_INT 85
65774: PUSH
65775: LD_INT 86
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: LIST
65801: LIST
65802: LIST
65803: LIST
65804: LIST
65805: LIST
65806: LIST
65807: LIST
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: ST_TO_ADDR
65833: GO 65836
65835: POP
// if state > - 1 and state < 3 then
65836: LD_VAR 0 3
65840: PUSH
65841: LD_INT 1
65843: NEG
65844: GREATER
65845: PUSH
65846: LD_VAR 0 3
65850: PUSH
65851: LD_INT 3
65853: LESS
65854: AND
65855: IFFALSE 65912
// for i in result do
65857: LD_ADDR_VAR 0 5
65861: PUSH
65862: LD_VAR 0 4
65866: PUSH
65867: FOR_IN
65868: IFFALSE 65910
// if GetTech ( i , side ) <> state then
65870: LD_VAR 0 5
65874: PPUSH
65875: LD_VAR 0 1
65879: PPUSH
65880: CALL_OW 321
65884: PUSH
65885: LD_VAR 0 3
65889: NONEQUAL
65890: IFFALSE 65908
// result := result diff i ;
65892: LD_ADDR_VAR 0 4
65896: PUSH
65897: LD_VAR 0 4
65901: PUSH
65902: LD_VAR 0 5
65906: DIFF
65907: ST_TO_ADDR
65908: GO 65867
65910: POP
65911: POP
// end ;
65912: LD_VAR 0 4
65916: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65917: LD_INT 0
65919: PPUSH
65920: PPUSH
65921: PPUSH
// result := true ;
65922: LD_ADDR_VAR 0 3
65926: PUSH
65927: LD_INT 1
65929: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65930: LD_ADDR_VAR 0 5
65934: PUSH
65935: LD_VAR 0 2
65939: PPUSH
65940: CALL_OW 480
65944: ST_TO_ADDR
// if not tmp then
65945: LD_VAR 0 5
65949: NOT
65950: IFFALSE 65954
// exit ;
65952: GO 66003
// for i in tmp do
65954: LD_ADDR_VAR 0 4
65958: PUSH
65959: LD_VAR 0 5
65963: PUSH
65964: FOR_IN
65965: IFFALSE 66001
// if GetTech ( i , side ) <> state_researched then
65967: LD_VAR 0 4
65971: PPUSH
65972: LD_VAR 0 1
65976: PPUSH
65977: CALL_OW 321
65981: PUSH
65982: LD_INT 2
65984: NONEQUAL
65985: IFFALSE 65999
// begin result := false ;
65987: LD_ADDR_VAR 0 3
65991: PUSH
65992: LD_INT 0
65994: ST_TO_ADDR
// exit ;
65995: POP
65996: POP
65997: GO 66003
// end ;
65999: GO 65964
66001: POP
66002: POP
// end ;
66003: LD_VAR 0 3
66007: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66008: LD_INT 0
66010: PPUSH
66011: PPUSH
66012: PPUSH
66013: PPUSH
66014: PPUSH
66015: PPUSH
66016: PPUSH
66017: PPUSH
66018: PPUSH
66019: PPUSH
66020: PPUSH
66021: PPUSH
66022: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66023: LD_VAR 0 1
66027: NOT
66028: PUSH
66029: LD_VAR 0 1
66033: PPUSH
66034: CALL_OW 257
66038: PUSH
66039: LD_INT 9
66041: NONEQUAL
66042: OR
66043: IFFALSE 66047
// exit ;
66045: GO 66620
// side := GetSide ( unit ) ;
66047: LD_ADDR_VAR 0 9
66051: PUSH
66052: LD_VAR 0 1
66056: PPUSH
66057: CALL_OW 255
66061: ST_TO_ADDR
// tech_space := tech_spacanom ;
66062: LD_ADDR_VAR 0 12
66066: PUSH
66067: LD_INT 29
66069: ST_TO_ADDR
// tech_time := tech_taurad ;
66070: LD_ADDR_VAR 0 13
66074: PUSH
66075: LD_INT 28
66077: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66078: LD_ADDR_VAR 0 11
66082: PUSH
66083: LD_VAR 0 1
66087: PPUSH
66088: CALL_OW 310
66092: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66093: LD_VAR 0 11
66097: PPUSH
66098: CALL_OW 247
66102: PUSH
66103: LD_INT 2
66105: EQUAL
66106: IFFALSE 66110
// exit ;
66108: GO 66620
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66110: LD_ADDR_VAR 0 8
66114: PUSH
66115: LD_INT 81
66117: PUSH
66118: LD_VAR 0 9
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 3
66129: PUSH
66130: LD_INT 21
66132: PUSH
66133: LD_INT 3
66135: PUSH
66136: EMPTY
66137: LIST
66138: LIST
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PPUSH
66148: CALL_OW 69
66152: ST_TO_ADDR
// if not tmp then
66153: LD_VAR 0 8
66157: NOT
66158: IFFALSE 66162
// exit ;
66160: GO 66620
// if in_unit then
66162: LD_VAR 0 11
66166: IFFALSE 66190
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66168: LD_ADDR_VAR 0 10
66172: PUSH
66173: LD_VAR 0 8
66177: PPUSH
66178: LD_VAR 0 11
66182: PPUSH
66183: CALL_OW 74
66187: ST_TO_ADDR
66188: GO 66210
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66190: LD_ADDR_VAR 0 10
66194: PUSH
66195: LD_VAR 0 8
66199: PPUSH
66200: LD_VAR 0 1
66204: PPUSH
66205: CALL_OW 74
66209: ST_TO_ADDR
// if not enemy then
66210: LD_VAR 0 10
66214: NOT
66215: IFFALSE 66219
// exit ;
66217: GO 66620
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66219: LD_VAR 0 11
66223: PUSH
66224: LD_VAR 0 11
66228: PPUSH
66229: LD_VAR 0 10
66233: PPUSH
66234: CALL_OW 296
66238: PUSH
66239: LD_INT 13
66241: GREATER
66242: AND
66243: PUSH
66244: LD_VAR 0 1
66248: PPUSH
66249: LD_VAR 0 10
66253: PPUSH
66254: CALL_OW 296
66258: PUSH
66259: LD_INT 12
66261: GREATER
66262: OR
66263: IFFALSE 66267
// exit ;
66265: GO 66620
// missile := [ 1 ] ;
66267: LD_ADDR_VAR 0 14
66271: PUSH
66272: LD_INT 1
66274: PUSH
66275: EMPTY
66276: LIST
66277: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66278: LD_VAR 0 9
66282: PPUSH
66283: LD_VAR 0 12
66287: PPUSH
66288: CALL_OW 325
66292: IFFALSE 66321
// missile := Insert ( missile , missile + 1 , 2 ) ;
66294: LD_ADDR_VAR 0 14
66298: PUSH
66299: LD_VAR 0 14
66303: PPUSH
66304: LD_VAR 0 14
66308: PUSH
66309: LD_INT 1
66311: PLUS
66312: PPUSH
66313: LD_INT 2
66315: PPUSH
66316: CALL_OW 2
66320: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66321: LD_VAR 0 9
66325: PPUSH
66326: LD_VAR 0 13
66330: PPUSH
66331: CALL_OW 325
66335: PUSH
66336: LD_VAR 0 10
66340: PPUSH
66341: CALL_OW 255
66345: PPUSH
66346: LD_VAR 0 13
66350: PPUSH
66351: CALL_OW 325
66355: NOT
66356: AND
66357: IFFALSE 66386
// missile := Insert ( missile , missile + 1 , 3 ) ;
66359: LD_ADDR_VAR 0 14
66363: PUSH
66364: LD_VAR 0 14
66368: PPUSH
66369: LD_VAR 0 14
66373: PUSH
66374: LD_INT 1
66376: PLUS
66377: PPUSH
66378: LD_INT 3
66380: PPUSH
66381: CALL_OW 2
66385: ST_TO_ADDR
// if missile < 2 then
66386: LD_VAR 0 14
66390: PUSH
66391: LD_INT 2
66393: LESS
66394: IFFALSE 66398
// exit ;
66396: GO 66620
// x := GetX ( enemy ) ;
66398: LD_ADDR_VAR 0 4
66402: PUSH
66403: LD_VAR 0 10
66407: PPUSH
66408: CALL_OW 250
66412: ST_TO_ADDR
// y := GetY ( enemy ) ;
66413: LD_ADDR_VAR 0 5
66417: PUSH
66418: LD_VAR 0 10
66422: PPUSH
66423: CALL_OW 251
66427: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66428: LD_ADDR_VAR 0 6
66432: PUSH
66433: LD_VAR 0 4
66437: PUSH
66438: LD_INT 1
66440: NEG
66441: PPUSH
66442: LD_INT 1
66444: PPUSH
66445: CALL_OW 12
66449: PLUS
66450: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66451: LD_ADDR_VAR 0 7
66455: PUSH
66456: LD_VAR 0 5
66460: PUSH
66461: LD_INT 1
66463: NEG
66464: PPUSH
66465: LD_INT 1
66467: PPUSH
66468: CALL_OW 12
66472: PLUS
66473: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66474: LD_VAR 0 6
66478: PPUSH
66479: LD_VAR 0 7
66483: PPUSH
66484: CALL_OW 488
66488: NOT
66489: IFFALSE 66511
// begin _x := x ;
66491: LD_ADDR_VAR 0 6
66495: PUSH
66496: LD_VAR 0 4
66500: ST_TO_ADDR
// _y := y ;
66501: LD_ADDR_VAR 0 7
66505: PUSH
66506: LD_VAR 0 5
66510: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66511: LD_ADDR_VAR 0 3
66515: PUSH
66516: LD_INT 1
66518: PPUSH
66519: LD_VAR 0 14
66523: PPUSH
66524: CALL_OW 12
66528: ST_TO_ADDR
// case i of 1 :
66529: LD_VAR 0 3
66533: PUSH
66534: LD_INT 1
66536: DOUBLE
66537: EQUAL
66538: IFTRUE 66542
66540: GO 66559
66542: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66543: LD_VAR 0 1
66547: PPUSH
66548: LD_VAR 0 10
66552: PPUSH
66553: CALL_OW 115
66557: GO 66620
66559: LD_INT 2
66561: DOUBLE
66562: EQUAL
66563: IFTRUE 66567
66565: GO 66589
66567: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66568: LD_VAR 0 1
66572: PPUSH
66573: LD_VAR 0 6
66577: PPUSH
66578: LD_VAR 0 7
66582: PPUSH
66583: CALL_OW 153
66587: GO 66620
66589: LD_INT 3
66591: DOUBLE
66592: EQUAL
66593: IFTRUE 66597
66595: GO 66619
66597: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66598: LD_VAR 0 1
66602: PPUSH
66603: LD_VAR 0 6
66607: PPUSH
66608: LD_VAR 0 7
66612: PPUSH
66613: CALL_OW 154
66617: GO 66620
66619: POP
// end ;
66620: LD_VAR 0 2
66624: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66625: LD_INT 0
66627: PPUSH
66628: PPUSH
66629: PPUSH
66630: PPUSH
66631: PPUSH
66632: PPUSH
// if not unit or not building then
66633: LD_VAR 0 1
66637: NOT
66638: PUSH
66639: LD_VAR 0 2
66643: NOT
66644: OR
66645: IFFALSE 66649
// exit ;
66647: GO 66807
// x := GetX ( building ) ;
66649: LD_ADDR_VAR 0 5
66653: PUSH
66654: LD_VAR 0 2
66658: PPUSH
66659: CALL_OW 250
66663: ST_TO_ADDR
// y := GetY ( building ) ;
66664: LD_ADDR_VAR 0 6
66668: PUSH
66669: LD_VAR 0 2
66673: PPUSH
66674: CALL_OW 251
66678: ST_TO_ADDR
// for i = 0 to 5 do
66679: LD_ADDR_VAR 0 4
66683: PUSH
66684: DOUBLE
66685: LD_INT 0
66687: DEC
66688: ST_TO_ADDR
66689: LD_INT 5
66691: PUSH
66692: FOR_TO
66693: IFFALSE 66805
// begin _x := ShiftX ( x , i , 3 ) ;
66695: LD_ADDR_VAR 0 7
66699: PUSH
66700: LD_VAR 0 5
66704: PPUSH
66705: LD_VAR 0 4
66709: PPUSH
66710: LD_INT 3
66712: PPUSH
66713: CALL_OW 272
66717: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66718: LD_ADDR_VAR 0 8
66722: PUSH
66723: LD_VAR 0 6
66727: PPUSH
66728: LD_VAR 0 4
66732: PPUSH
66733: LD_INT 3
66735: PPUSH
66736: CALL_OW 273
66740: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66741: LD_VAR 0 7
66745: PPUSH
66746: LD_VAR 0 8
66750: PPUSH
66751: CALL_OW 488
66755: NOT
66756: IFFALSE 66760
// continue ;
66758: GO 66692
// if HexInfo ( _x , _y ) = 0 then
66760: LD_VAR 0 7
66764: PPUSH
66765: LD_VAR 0 8
66769: PPUSH
66770: CALL_OW 428
66774: PUSH
66775: LD_INT 0
66777: EQUAL
66778: IFFALSE 66803
// begin ComMoveXY ( unit , _x , _y ) ;
66780: LD_VAR 0 1
66784: PPUSH
66785: LD_VAR 0 7
66789: PPUSH
66790: LD_VAR 0 8
66794: PPUSH
66795: CALL_OW 111
// exit ;
66799: POP
66800: POP
66801: GO 66807
// end ; end ;
66803: GO 66692
66805: POP
66806: POP
// end ;
66807: LD_VAR 0 3
66811: RET
// export function ScanBase ( side , base_area ) ; begin
66812: LD_INT 0
66814: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66815: LD_ADDR_VAR 0 3
66819: PUSH
66820: LD_VAR 0 2
66824: PPUSH
66825: LD_INT 81
66827: PUSH
66828: LD_VAR 0 1
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PPUSH
66837: CALL_OW 70
66841: ST_TO_ADDR
// end ;
66842: LD_VAR 0 3
66846: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66847: LD_INT 0
66849: PPUSH
66850: PPUSH
66851: PPUSH
66852: PPUSH
// result := false ;
66853: LD_ADDR_VAR 0 2
66857: PUSH
66858: LD_INT 0
66860: ST_TO_ADDR
// side := GetSide ( unit ) ;
66861: LD_ADDR_VAR 0 3
66865: PUSH
66866: LD_VAR 0 1
66870: PPUSH
66871: CALL_OW 255
66875: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66876: LD_ADDR_VAR 0 4
66880: PUSH
66881: LD_VAR 0 1
66885: PPUSH
66886: CALL_OW 248
66890: ST_TO_ADDR
// case nat of 1 :
66891: LD_VAR 0 4
66895: PUSH
66896: LD_INT 1
66898: DOUBLE
66899: EQUAL
66900: IFTRUE 66904
66902: GO 66915
66904: POP
// tech := tech_lassight ; 2 :
66905: LD_ADDR_VAR 0 5
66909: PUSH
66910: LD_INT 12
66912: ST_TO_ADDR
66913: GO 66954
66915: LD_INT 2
66917: DOUBLE
66918: EQUAL
66919: IFTRUE 66923
66921: GO 66934
66923: POP
// tech := tech_mortar ; 3 :
66924: LD_ADDR_VAR 0 5
66928: PUSH
66929: LD_INT 41
66931: ST_TO_ADDR
66932: GO 66954
66934: LD_INT 3
66936: DOUBLE
66937: EQUAL
66938: IFTRUE 66942
66940: GO 66953
66942: POP
// tech := tech_bazooka ; end ;
66943: LD_ADDR_VAR 0 5
66947: PUSH
66948: LD_INT 44
66950: ST_TO_ADDR
66951: GO 66954
66953: POP
// if Researched ( side , tech ) then
66954: LD_VAR 0 3
66958: PPUSH
66959: LD_VAR 0 5
66963: PPUSH
66964: CALL_OW 325
66968: IFFALSE 66995
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66970: LD_ADDR_VAR 0 2
66974: PUSH
66975: LD_INT 5
66977: PUSH
66978: LD_INT 8
66980: PUSH
66981: LD_INT 9
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: LIST
66988: PUSH
66989: LD_VAR 0 4
66993: ARRAY
66994: ST_TO_ADDR
// end ;
66995: LD_VAR 0 2
66999: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67000: LD_INT 0
67002: PPUSH
67003: PPUSH
67004: PPUSH
// if not mines then
67005: LD_VAR 0 2
67009: NOT
67010: IFFALSE 67014
// exit ;
67012: GO 67158
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67014: LD_ADDR_VAR 0 5
67018: PUSH
67019: LD_INT 81
67021: PUSH
67022: LD_VAR 0 1
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: LD_INT 3
67033: PUSH
67034: LD_INT 21
67036: PUSH
67037: LD_INT 3
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: EMPTY
67045: LIST
67046: LIST
67047: PUSH
67048: EMPTY
67049: LIST
67050: LIST
67051: PPUSH
67052: CALL_OW 69
67056: ST_TO_ADDR
// for i in mines do
67057: LD_ADDR_VAR 0 4
67061: PUSH
67062: LD_VAR 0 2
67066: PUSH
67067: FOR_IN
67068: IFFALSE 67156
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67070: LD_VAR 0 4
67074: PUSH
67075: LD_INT 1
67077: ARRAY
67078: PPUSH
67079: LD_VAR 0 4
67083: PUSH
67084: LD_INT 2
67086: ARRAY
67087: PPUSH
67088: CALL_OW 458
67092: NOT
67093: IFFALSE 67097
// continue ;
67095: GO 67067
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67097: LD_VAR 0 4
67101: PUSH
67102: LD_INT 1
67104: ARRAY
67105: PPUSH
67106: LD_VAR 0 4
67110: PUSH
67111: LD_INT 2
67113: ARRAY
67114: PPUSH
67115: CALL_OW 428
67119: PUSH
67120: LD_VAR 0 5
67124: IN
67125: IFFALSE 67154
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67127: LD_VAR 0 4
67131: PUSH
67132: LD_INT 1
67134: ARRAY
67135: PPUSH
67136: LD_VAR 0 4
67140: PUSH
67141: LD_INT 2
67143: ARRAY
67144: PPUSH
67145: LD_VAR 0 1
67149: PPUSH
67150: CALL_OW 456
// end ;
67154: GO 67067
67156: POP
67157: POP
// end ;
67158: LD_VAR 0 3
67162: RET
// export function Count ( array ) ; var i ; begin
67163: LD_INT 0
67165: PPUSH
67166: PPUSH
// result := 0 ;
67167: LD_ADDR_VAR 0 2
67171: PUSH
67172: LD_INT 0
67174: ST_TO_ADDR
// for i in array do
67175: LD_ADDR_VAR 0 3
67179: PUSH
67180: LD_VAR 0 1
67184: PUSH
67185: FOR_IN
67186: IFFALSE 67210
// if i then
67188: LD_VAR 0 3
67192: IFFALSE 67208
// result := result + 1 ;
67194: LD_ADDR_VAR 0 2
67198: PUSH
67199: LD_VAR 0 2
67203: PUSH
67204: LD_INT 1
67206: PLUS
67207: ST_TO_ADDR
67208: GO 67185
67210: POP
67211: POP
// end ;
67212: LD_VAR 0 2
67216: RET
// export function IsEmpty ( building ) ; begin
67217: LD_INT 0
67219: PPUSH
// if not building then
67220: LD_VAR 0 1
67224: NOT
67225: IFFALSE 67229
// exit ;
67227: GO 67272
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67229: LD_ADDR_VAR 0 2
67233: PUSH
67234: LD_VAR 0 1
67238: PUSH
67239: LD_INT 22
67241: PUSH
67242: LD_VAR 0 1
67246: PPUSH
67247: CALL_OW 255
67251: PUSH
67252: EMPTY
67253: LIST
67254: LIST
67255: PUSH
67256: LD_INT 58
67258: PUSH
67259: EMPTY
67260: LIST
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PPUSH
67266: CALL_OW 69
67270: IN
67271: ST_TO_ADDR
// end ;
67272: LD_VAR 0 2
67276: RET
// export function IsNotFull ( building ) ; begin
67277: LD_INT 0
67279: PPUSH
// if not building then
67280: LD_VAR 0 1
67284: NOT
67285: IFFALSE 67289
// exit ;
67287: GO 67308
// result := UnitsInside ( building ) < 6 ;
67289: LD_ADDR_VAR 0 2
67293: PUSH
67294: LD_VAR 0 1
67298: PPUSH
67299: CALL_OW 313
67303: PUSH
67304: LD_INT 6
67306: LESS
67307: ST_TO_ADDR
// end ;
67308: LD_VAR 0 2
67312: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67313: LD_INT 0
67315: PPUSH
67316: PPUSH
67317: PPUSH
67318: PPUSH
// tmp := [ ] ;
67319: LD_ADDR_VAR 0 3
67323: PUSH
67324: EMPTY
67325: ST_TO_ADDR
// list := [ ] ;
67326: LD_ADDR_VAR 0 5
67330: PUSH
67331: EMPTY
67332: ST_TO_ADDR
// for i = 16 to 25 do
67333: LD_ADDR_VAR 0 4
67337: PUSH
67338: DOUBLE
67339: LD_INT 16
67341: DEC
67342: ST_TO_ADDR
67343: LD_INT 25
67345: PUSH
67346: FOR_TO
67347: IFFALSE 67420
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67349: LD_ADDR_VAR 0 3
67353: PUSH
67354: LD_VAR 0 3
67358: PUSH
67359: LD_INT 22
67361: PUSH
67362: LD_VAR 0 1
67366: PPUSH
67367: CALL_OW 255
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: LD_INT 91
67378: PUSH
67379: LD_VAR 0 1
67383: PUSH
67384: LD_INT 6
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 30
67394: PUSH
67395: LD_VAR 0 4
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: LIST
67408: PUSH
67409: EMPTY
67410: LIST
67411: PPUSH
67412: CALL_OW 69
67416: ADD
67417: ST_TO_ADDR
67418: GO 67346
67420: POP
67421: POP
// for i = 1 to tmp do
67422: LD_ADDR_VAR 0 4
67426: PUSH
67427: DOUBLE
67428: LD_INT 1
67430: DEC
67431: ST_TO_ADDR
67432: LD_VAR 0 3
67436: PUSH
67437: FOR_TO
67438: IFFALSE 67526
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67440: LD_ADDR_VAR 0 5
67444: PUSH
67445: LD_VAR 0 5
67449: PUSH
67450: LD_VAR 0 3
67454: PUSH
67455: LD_VAR 0 4
67459: ARRAY
67460: PPUSH
67461: CALL_OW 266
67465: PUSH
67466: LD_VAR 0 3
67470: PUSH
67471: LD_VAR 0 4
67475: ARRAY
67476: PPUSH
67477: CALL_OW 250
67481: PUSH
67482: LD_VAR 0 3
67486: PUSH
67487: LD_VAR 0 4
67491: ARRAY
67492: PPUSH
67493: CALL_OW 251
67497: PUSH
67498: LD_VAR 0 3
67502: PUSH
67503: LD_VAR 0 4
67507: ARRAY
67508: PPUSH
67509: CALL_OW 254
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: PUSH
67520: EMPTY
67521: LIST
67522: ADD
67523: ST_TO_ADDR
67524: GO 67437
67526: POP
67527: POP
// result := list ;
67528: LD_ADDR_VAR 0 2
67532: PUSH
67533: LD_VAR 0 5
67537: ST_TO_ADDR
// end ;
67538: LD_VAR 0 2
67542: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67543: LD_INT 0
67545: PPUSH
67546: PPUSH
67547: PPUSH
67548: PPUSH
67549: PPUSH
67550: PPUSH
67551: PPUSH
// if not factory then
67552: LD_VAR 0 1
67556: NOT
67557: IFFALSE 67561
// exit ;
67559: GO 68154
// if control = control_apeman then
67561: LD_VAR 0 4
67565: PUSH
67566: LD_INT 5
67568: EQUAL
67569: IFFALSE 67678
// begin tmp := UnitsInside ( factory ) ;
67571: LD_ADDR_VAR 0 8
67575: PUSH
67576: LD_VAR 0 1
67580: PPUSH
67581: CALL_OW 313
67585: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67586: LD_VAR 0 8
67590: PPUSH
67591: LD_INT 25
67593: PUSH
67594: LD_INT 12
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: PPUSH
67601: CALL_OW 72
67605: NOT
67606: IFFALSE 67616
// control := control_manual ;
67608: LD_ADDR_VAR 0 4
67612: PUSH
67613: LD_INT 1
67615: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67616: LD_ADDR_VAR 0 8
67620: PUSH
67621: LD_VAR 0 1
67625: PPUSH
67626: CALL 67313 0 1
67630: ST_TO_ADDR
// if tmp then
67631: LD_VAR 0 8
67635: IFFALSE 67678
// begin for i in tmp do
67637: LD_ADDR_VAR 0 7
67641: PUSH
67642: LD_VAR 0 8
67646: PUSH
67647: FOR_IN
67648: IFFALSE 67676
// if i [ 1 ] = b_ext_radio then
67650: LD_VAR 0 7
67654: PUSH
67655: LD_INT 1
67657: ARRAY
67658: PUSH
67659: LD_INT 22
67661: EQUAL
67662: IFFALSE 67674
// begin control := control_remote ;
67664: LD_ADDR_VAR 0 4
67668: PUSH
67669: LD_INT 2
67671: ST_TO_ADDR
// break ;
67672: GO 67676
// end ;
67674: GO 67647
67676: POP
67677: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67678: LD_VAR 0 1
67682: PPUSH
67683: LD_VAR 0 2
67687: PPUSH
67688: LD_VAR 0 3
67692: PPUSH
67693: LD_VAR 0 4
67697: PPUSH
67698: LD_VAR 0 5
67702: PPUSH
67703: CALL_OW 448
67707: IFFALSE 67742
// begin result := [ chassis , engine , control , weapon ] ;
67709: LD_ADDR_VAR 0 6
67713: PUSH
67714: LD_VAR 0 2
67718: PUSH
67719: LD_VAR 0 3
67723: PUSH
67724: LD_VAR 0 4
67728: PUSH
67729: LD_VAR 0 5
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: ST_TO_ADDR
// exit ;
67740: GO 68154
// end ; _chassis := AvailableChassisList ( factory ) ;
67742: LD_ADDR_VAR 0 9
67746: PUSH
67747: LD_VAR 0 1
67751: PPUSH
67752: CALL_OW 475
67756: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67757: LD_ADDR_VAR 0 11
67761: PUSH
67762: LD_VAR 0 1
67766: PPUSH
67767: CALL_OW 476
67771: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67772: LD_ADDR_VAR 0 12
67776: PUSH
67777: LD_VAR 0 1
67781: PPUSH
67782: CALL_OW 477
67786: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67787: LD_ADDR_VAR 0 10
67791: PUSH
67792: LD_VAR 0 1
67796: PPUSH
67797: CALL_OW 478
67801: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67802: LD_VAR 0 9
67806: NOT
67807: PUSH
67808: LD_VAR 0 11
67812: NOT
67813: OR
67814: PUSH
67815: LD_VAR 0 12
67819: NOT
67820: OR
67821: PUSH
67822: LD_VAR 0 10
67826: NOT
67827: OR
67828: IFFALSE 67863
// begin result := [ chassis , engine , control , weapon ] ;
67830: LD_ADDR_VAR 0 6
67834: PUSH
67835: LD_VAR 0 2
67839: PUSH
67840: LD_VAR 0 3
67844: PUSH
67845: LD_VAR 0 4
67849: PUSH
67850: LD_VAR 0 5
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: ST_TO_ADDR
// exit ;
67861: GO 68154
// end ; if not chassis in _chassis then
67863: LD_VAR 0 2
67867: PUSH
67868: LD_VAR 0 9
67872: IN
67873: NOT
67874: IFFALSE 67900
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67876: LD_ADDR_VAR 0 2
67880: PUSH
67881: LD_VAR 0 9
67885: PUSH
67886: LD_INT 1
67888: PPUSH
67889: LD_VAR 0 9
67893: PPUSH
67894: CALL_OW 12
67898: ARRAY
67899: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67900: LD_VAR 0 2
67904: PPUSH
67905: LD_VAR 0 3
67909: PPUSH
67910: CALL 68159 0 2
67914: NOT
67915: IFFALSE 67974
// repeat engine := _engine [ 1 ] ;
67917: LD_ADDR_VAR 0 3
67921: PUSH
67922: LD_VAR 0 11
67926: PUSH
67927: LD_INT 1
67929: ARRAY
67930: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67931: LD_ADDR_VAR 0 11
67935: PUSH
67936: LD_VAR 0 11
67940: PPUSH
67941: LD_INT 1
67943: PPUSH
67944: CALL_OW 3
67948: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67949: LD_VAR 0 2
67953: PPUSH
67954: LD_VAR 0 3
67958: PPUSH
67959: CALL 68159 0 2
67963: PUSH
67964: LD_VAR 0 11
67968: PUSH
67969: EMPTY
67970: EQUAL
67971: OR
67972: IFFALSE 67917
// if not control in _control then
67974: LD_VAR 0 4
67978: PUSH
67979: LD_VAR 0 12
67983: IN
67984: NOT
67985: IFFALSE 68011
// control := _control [ rand ( 1 , _control ) ] ;
67987: LD_ADDR_VAR 0 4
67991: PUSH
67992: LD_VAR 0 12
67996: PUSH
67997: LD_INT 1
67999: PPUSH
68000: LD_VAR 0 12
68004: PPUSH
68005: CALL_OW 12
68009: ARRAY
68010: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68011: LD_VAR 0 2
68015: PPUSH
68016: LD_VAR 0 5
68020: PPUSH
68021: CALL 68379 0 2
68025: NOT
68026: IFFALSE 68085
// repeat weapon := _weapon [ 1 ] ;
68028: LD_ADDR_VAR 0 5
68032: PUSH
68033: LD_VAR 0 10
68037: PUSH
68038: LD_INT 1
68040: ARRAY
68041: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68042: LD_ADDR_VAR 0 10
68046: PUSH
68047: LD_VAR 0 10
68051: PPUSH
68052: LD_INT 1
68054: PPUSH
68055: CALL_OW 3
68059: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68060: LD_VAR 0 2
68064: PPUSH
68065: LD_VAR 0 5
68069: PPUSH
68070: CALL 68379 0 2
68074: PUSH
68075: LD_VAR 0 10
68079: PUSH
68080: EMPTY
68081: EQUAL
68082: OR
68083: IFFALSE 68028
// result := [ ] ;
68085: LD_ADDR_VAR 0 6
68089: PUSH
68090: EMPTY
68091: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68092: LD_VAR 0 1
68096: PPUSH
68097: LD_VAR 0 2
68101: PPUSH
68102: LD_VAR 0 3
68106: PPUSH
68107: LD_VAR 0 4
68111: PPUSH
68112: LD_VAR 0 5
68116: PPUSH
68117: CALL_OW 448
68121: IFFALSE 68154
// result := [ chassis , engine , control , weapon ] ;
68123: LD_ADDR_VAR 0 6
68127: PUSH
68128: LD_VAR 0 2
68132: PUSH
68133: LD_VAR 0 3
68137: PUSH
68138: LD_VAR 0 4
68142: PUSH
68143: LD_VAR 0 5
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: ST_TO_ADDR
// end ;
68154: LD_VAR 0 6
68158: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68159: LD_INT 0
68161: PPUSH
// if not chassis or not engine then
68162: LD_VAR 0 1
68166: NOT
68167: PUSH
68168: LD_VAR 0 2
68172: NOT
68173: OR
68174: IFFALSE 68178
// exit ;
68176: GO 68374
// case engine of engine_solar :
68178: LD_VAR 0 2
68182: PUSH
68183: LD_INT 2
68185: DOUBLE
68186: EQUAL
68187: IFTRUE 68191
68189: GO 68229
68191: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68192: LD_ADDR_VAR 0 3
68196: PUSH
68197: LD_INT 11
68199: PUSH
68200: LD_INT 12
68202: PUSH
68203: LD_INT 13
68205: PUSH
68206: LD_INT 14
68208: PUSH
68209: LD_INT 1
68211: PUSH
68212: LD_INT 2
68214: PUSH
68215: LD_INT 3
68217: PUSH
68218: EMPTY
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: ST_TO_ADDR
68227: GO 68358
68229: LD_INT 1
68231: DOUBLE
68232: EQUAL
68233: IFTRUE 68237
68235: GO 68299
68237: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68238: LD_ADDR_VAR 0 3
68242: PUSH
68243: LD_INT 11
68245: PUSH
68246: LD_INT 12
68248: PUSH
68249: LD_INT 13
68251: PUSH
68252: LD_INT 14
68254: PUSH
68255: LD_INT 1
68257: PUSH
68258: LD_INT 2
68260: PUSH
68261: LD_INT 3
68263: PUSH
68264: LD_INT 4
68266: PUSH
68267: LD_INT 5
68269: PUSH
68270: LD_INT 21
68272: PUSH
68273: LD_INT 23
68275: PUSH
68276: LD_INT 22
68278: PUSH
68279: LD_INT 24
68281: PUSH
68282: EMPTY
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: ST_TO_ADDR
68297: GO 68358
68299: LD_INT 3
68301: DOUBLE
68302: EQUAL
68303: IFTRUE 68307
68305: GO 68357
68307: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68308: LD_ADDR_VAR 0 3
68312: PUSH
68313: LD_INT 13
68315: PUSH
68316: LD_INT 14
68318: PUSH
68319: LD_INT 2
68321: PUSH
68322: LD_INT 3
68324: PUSH
68325: LD_INT 4
68327: PUSH
68328: LD_INT 5
68330: PUSH
68331: LD_INT 21
68333: PUSH
68334: LD_INT 22
68336: PUSH
68337: LD_INT 23
68339: PUSH
68340: LD_INT 24
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: LIST
68354: ST_TO_ADDR
68355: GO 68358
68357: POP
// result := ( chassis in result ) ;
68358: LD_ADDR_VAR 0 3
68362: PUSH
68363: LD_VAR 0 1
68367: PUSH
68368: LD_VAR 0 3
68372: IN
68373: ST_TO_ADDR
// end ;
68374: LD_VAR 0 3
68378: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68379: LD_INT 0
68381: PPUSH
// if not chassis or not weapon then
68382: LD_VAR 0 1
68386: NOT
68387: PUSH
68388: LD_VAR 0 2
68392: NOT
68393: OR
68394: IFFALSE 68398
// exit ;
68396: GO 69424
// case weapon of us_machine_gun :
68398: LD_VAR 0 2
68402: PUSH
68403: LD_INT 2
68405: DOUBLE
68406: EQUAL
68407: IFTRUE 68411
68409: GO 68441
68411: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68412: LD_ADDR_VAR 0 3
68416: PUSH
68417: LD_INT 1
68419: PUSH
68420: LD_INT 2
68422: PUSH
68423: LD_INT 3
68425: PUSH
68426: LD_INT 4
68428: PUSH
68429: LD_INT 5
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: LIST
68436: LIST
68437: LIST
68438: ST_TO_ADDR
68439: GO 69408
68441: LD_INT 3
68443: DOUBLE
68444: EQUAL
68445: IFTRUE 68449
68447: GO 68479
68449: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68450: LD_ADDR_VAR 0 3
68454: PUSH
68455: LD_INT 1
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: LD_INT 3
68463: PUSH
68464: LD_INT 4
68466: PUSH
68467: LD_INT 5
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: LIST
68474: LIST
68475: LIST
68476: ST_TO_ADDR
68477: GO 69408
68479: LD_INT 11
68481: DOUBLE
68482: EQUAL
68483: IFTRUE 68487
68485: GO 68517
68487: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68488: LD_ADDR_VAR 0 3
68492: PUSH
68493: LD_INT 1
68495: PUSH
68496: LD_INT 2
68498: PUSH
68499: LD_INT 3
68501: PUSH
68502: LD_INT 4
68504: PUSH
68505: LD_INT 5
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: ST_TO_ADDR
68515: GO 69408
68517: LD_INT 4
68519: DOUBLE
68520: EQUAL
68521: IFTRUE 68525
68523: GO 68551
68525: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68526: LD_ADDR_VAR 0 3
68530: PUSH
68531: LD_INT 2
68533: PUSH
68534: LD_INT 3
68536: PUSH
68537: LD_INT 4
68539: PUSH
68540: LD_INT 5
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: ST_TO_ADDR
68549: GO 69408
68551: LD_INT 5
68553: DOUBLE
68554: EQUAL
68555: IFTRUE 68559
68557: GO 68585
68559: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68560: LD_ADDR_VAR 0 3
68564: PUSH
68565: LD_INT 2
68567: PUSH
68568: LD_INT 3
68570: PUSH
68571: LD_INT 4
68573: PUSH
68574: LD_INT 5
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: ST_TO_ADDR
68583: GO 69408
68585: LD_INT 9
68587: DOUBLE
68588: EQUAL
68589: IFTRUE 68593
68591: GO 68619
68593: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68594: LD_ADDR_VAR 0 3
68598: PUSH
68599: LD_INT 2
68601: PUSH
68602: LD_INT 3
68604: PUSH
68605: LD_INT 4
68607: PUSH
68608: LD_INT 5
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: ST_TO_ADDR
68617: GO 69408
68619: LD_INT 7
68621: DOUBLE
68622: EQUAL
68623: IFTRUE 68627
68625: GO 68653
68627: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68628: LD_ADDR_VAR 0 3
68632: PUSH
68633: LD_INT 2
68635: PUSH
68636: LD_INT 3
68638: PUSH
68639: LD_INT 4
68641: PUSH
68642: LD_INT 5
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: LIST
68649: LIST
68650: ST_TO_ADDR
68651: GO 69408
68653: LD_INT 12
68655: DOUBLE
68656: EQUAL
68657: IFTRUE 68661
68659: GO 68687
68661: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68662: LD_ADDR_VAR 0 3
68666: PUSH
68667: LD_INT 2
68669: PUSH
68670: LD_INT 3
68672: PUSH
68673: LD_INT 4
68675: PUSH
68676: LD_INT 5
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: ST_TO_ADDR
68685: GO 69408
68687: LD_INT 13
68689: DOUBLE
68690: EQUAL
68691: IFTRUE 68695
68693: GO 68721
68695: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68696: LD_ADDR_VAR 0 3
68700: PUSH
68701: LD_INT 2
68703: PUSH
68704: LD_INT 3
68706: PUSH
68707: LD_INT 4
68709: PUSH
68710: LD_INT 5
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: ST_TO_ADDR
68719: GO 69408
68721: LD_INT 14
68723: DOUBLE
68724: EQUAL
68725: IFTRUE 68729
68727: GO 68747
68729: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68730: LD_ADDR_VAR 0 3
68734: PUSH
68735: LD_INT 4
68737: PUSH
68738: LD_INT 5
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: ST_TO_ADDR
68745: GO 69408
68747: LD_INT 6
68749: DOUBLE
68750: EQUAL
68751: IFTRUE 68755
68753: GO 68773
68755: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68756: LD_ADDR_VAR 0 3
68760: PUSH
68761: LD_INT 4
68763: PUSH
68764: LD_INT 5
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: ST_TO_ADDR
68771: GO 69408
68773: LD_INT 10
68775: DOUBLE
68776: EQUAL
68777: IFTRUE 68781
68779: GO 68799
68781: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68782: LD_ADDR_VAR 0 3
68786: PUSH
68787: LD_INT 4
68789: PUSH
68790: LD_INT 5
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: ST_TO_ADDR
68797: GO 69408
68799: LD_INT 22
68801: DOUBLE
68802: EQUAL
68803: IFTRUE 68807
68805: GO 68833
68807: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68808: LD_ADDR_VAR 0 3
68812: PUSH
68813: LD_INT 11
68815: PUSH
68816: LD_INT 12
68818: PUSH
68819: LD_INT 13
68821: PUSH
68822: LD_INT 14
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: ST_TO_ADDR
68831: GO 69408
68833: LD_INT 23
68835: DOUBLE
68836: EQUAL
68837: IFTRUE 68841
68839: GO 68867
68841: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68842: LD_ADDR_VAR 0 3
68846: PUSH
68847: LD_INT 11
68849: PUSH
68850: LD_INT 12
68852: PUSH
68853: LD_INT 13
68855: PUSH
68856: LD_INT 14
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: ST_TO_ADDR
68865: GO 69408
68867: LD_INT 24
68869: DOUBLE
68870: EQUAL
68871: IFTRUE 68875
68873: GO 68901
68875: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68876: LD_ADDR_VAR 0 3
68880: PUSH
68881: LD_INT 11
68883: PUSH
68884: LD_INT 12
68886: PUSH
68887: LD_INT 13
68889: PUSH
68890: LD_INT 14
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: ST_TO_ADDR
68899: GO 69408
68901: LD_INT 30
68903: DOUBLE
68904: EQUAL
68905: IFTRUE 68909
68907: GO 68935
68909: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68910: LD_ADDR_VAR 0 3
68914: PUSH
68915: LD_INT 11
68917: PUSH
68918: LD_INT 12
68920: PUSH
68921: LD_INT 13
68923: PUSH
68924: LD_INT 14
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: LIST
68931: LIST
68932: ST_TO_ADDR
68933: GO 69408
68935: LD_INT 25
68937: DOUBLE
68938: EQUAL
68939: IFTRUE 68943
68941: GO 68961
68943: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68944: LD_ADDR_VAR 0 3
68948: PUSH
68949: LD_INT 13
68951: PUSH
68952: LD_INT 14
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: ST_TO_ADDR
68959: GO 69408
68961: LD_INT 27
68963: DOUBLE
68964: EQUAL
68965: IFTRUE 68969
68967: GO 68987
68969: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68970: LD_ADDR_VAR 0 3
68974: PUSH
68975: LD_INT 13
68977: PUSH
68978: LD_INT 14
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: ST_TO_ADDR
68985: GO 69408
68987: LD_INT 28
68989: DOUBLE
68990: EQUAL
68991: IFTRUE 68995
68993: GO 69013
68995: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
68996: LD_ADDR_VAR 0 3
69000: PUSH
69001: LD_INT 13
69003: PUSH
69004: LD_INT 14
69006: PUSH
69007: EMPTY
69008: LIST
69009: LIST
69010: ST_TO_ADDR
69011: GO 69408
69013: LD_INT 29
69015: DOUBLE
69016: EQUAL
69017: IFTRUE 69021
69019: GO 69039
69021: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69022: LD_ADDR_VAR 0 3
69026: PUSH
69027: LD_INT 13
69029: PUSH
69030: LD_INT 14
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: ST_TO_ADDR
69037: GO 69408
69039: LD_INT 31
69041: DOUBLE
69042: EQUAL
69043: IFTRUE 69047
69045: GO 69065
69047: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69048: LD_ADDR_VAR 0 3
69052: PUSH
69053: LD_INT 13
69055: PUSH
69056: LD_INT 14
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: ST_TO_ADDR
69063: GO 69408
69065: LD_INT 26
69067: DOUBLE
69068: EQUAL
69069: IFTRUE 69073
69071: GO 69091
69073: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69074: LD_ADDR_VAR 0 3
69078: PUSH
69079: LD_INT 13
69081: PUSH
69082: LD_INT 14
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: ST_TO_ADDR
69089: GO 69408
69091: LD_INT 42
69093: DOUBLE
69094: EQUAL
69095: IFTRUE 69099
69097: GO 69125
69099: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69100: LD_ADDR_VAR 0 3
69104: PUSH
69105: LD_INT 21
69107: PUSH
69108: LD_INT 22
69110: PUSH
69111: LD_INT 23
69113: PUSH
69114: LD_INT 24
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: LIST
69121: LIST
69122: ST_TO_ADDR
69123: GO 69408
69125: LD_INT 43
69127: DOUBLE
69128: EQUAL
69129: IFTRUE 69133
69131: GO 69159
69133: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69134: LD_ADDR_VAR 0 3
69138: PUSH
69139: LD_INT 21
69141: PUSH
69142: LD_INT 22
69144: PUSH
69145: LD_INT 23
69147: PUSH
69148: LD_INT 24
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: LIST
69155: LIST
69156: ST_TO_ADDR
69157: GO 69408
69159: LD_INT 44
69161: DOUBLE
69162: EQUAL
69163: IFTRUE 69167
69165: GO 69193
69167: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69168: LD_ADDR_VAR 0 3
69172: PUSH
69173: LD_INT 21
69175: PUSH
69176: LD_INT 22
69178: PUSH
69179: LD_INT 23
69181: PUSH
69182: LD_INT 24
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: ST_TO_ADDR
69191: GO 69408
69193: LD_INT 45
69195: DOUBLE
69196: EQUAL
69197: IFTRUE 69201
69199: GO 69227
69201: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69202: LD_ADDR_VAR 0 3
69206: PUSH
69207: LD_INT 21
69209: PUSH
69210: LD_INT 22
69212: PUSH
69213: LD_INT 23
69215: PUSH
69216: LD_INT 24
69218: PUSH
69219: EMPTY
69220: LIST
69221: LIST
69222: LIST
69223: LIST
69224: ST_TO_ADDR
69225: GO 69408
69227: LD_INT 49
69229: DOUBLE
69230: EQUAL
69231: IFTRUE 69235
69233: GO 69261
69235: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69236: LD_ADDR_VAR 0 3
69240: PUSH
69241: LD_INT 21
69243: PUSH
69244: LD_INT 22
69246: PUSH
69247: LD_INT 23
69249: PUSH
69250: LD_INT 24
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: LIST
69257: LIST
69258: ST_TO_ADDR
69259: GO 69408
69261: LD_INT 51
69263: DOUBLE
69264: EQUAL
69265: IFTRUE 69269
69267: GO 69295
69269: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69270: LD_ADDR_VAR 0 3
69274: PUSH
69275: LD_INT 21
69277: PUSH
69278: LD_INT 22
69280: PUSH
69281: LD_INT 23
69283: PUSH
69284: LD_INT 24
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: ST_TO_ADDR
69293: GO 69408
69295: LD_INT 52
69297: DOUBLE
69298: EQUAL
69299: IFTRUE 69303
69301: GO 69329
69303: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69304: LD_ADDR_VAR 0 3
69308: PUSH
69309: LD_INT 21
69311: PUSH
69312: LD_INT 22
69314: PUSH
69315: LD_INT 23
69317: PUSH
69318: LD_INT 24
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: ST_TO_ADDR
69327: GO 69408
69329: LD_INT 53
69331: DOUBLE
69332: EQUAL
69333: IFTRUE 69337
69335: GO 69355
69337: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69338: LD_ADDR_VAR 0 3
69342: PUSH
69343: LD_INT 23
69345: PUSH
69346: LD_INT 24
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: ST_TO_ADDR
69353: GO 69408
69355: LD_INT 46
69357: DOUBLE
69358: EQUAL
69359: IFTRUE 69363
69361: GO 69381
69363: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69364: LD_ADDR_VAR 0 3
69368: PUSH
69369: LD_INT 23
69371: PUSH
69372: LD_INT 24
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: ST_TO_ADDR
69379: GO 69408
69381: LD_INT 47
69383: DOUBLE
69384: EQUAL
69385: IFTRUE 69389
69387: GO 69407
69389: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69390: LD_ADDR_VAR 0 3
69394: PUSH
69395: LD_INT 23
69397: PUSH
69398: LD_INT 24
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: ST_TO_ADDR
69405: GO 69408
69407: POP
// result := ( chassis in result ) ;
69408: LD_ADDR_VAR 0 3
69412: PUSH
69413: LD_VAR 0 1
69417: PUSH
69418: LD_VAR 0 3
69422: IN
69423: ST_TO_ADDR
// end ;
69424: LD_VAR 0 3
69428: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69429: LD_INT 0
69431: PPUSH
69432: PPUSH
69433: PPUSH
69434: PPUSH
69435: PPUSH
69436: PPUSH
69437: PPUSH
// result := array ;
69438: LD_ADDR_VAR 0 5
69442: PUSH
69443: LD_VAR 0 1
69447: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69448: LD_VAR 0 1
69452: NOT
69453: PUSH
69454: LD_VAR 0 2
69458: NOT
69459: OR
69460: PUSH
69461: LD_VAR 0 3
69465: NOT
69466: OR
69467: PUSH
69468: LD_VAR 0 2
69472: PUSH
69473: LD_VAR 0 1
69477: GREATER
69478: OR
69479: PUSH
69480: LD_VAR 0 3
69484: PUSH
69485: LD_VAR 0 1
69489: GREATER
69490: OR
69491: IFFALSE 69495
// exit ;
69493: GO 69791
// if direction then
69495: LD_VAR 0 4
69499: IFFALSE 69563
// begin d := 1 ;
69501: LD_ADDR_VAR 0 9
69505: PUSH
69506: LD_INT 1
69508: ST_TO_ADDR
// if i_from > i_to then
69509: LD_VAR 0 2
69513: PUSH
69514: LD_VAR 0 3
69518: GREATER
69519: IFFALSE 69545
// length := ( array - i_from ) + i_to else
69521: LD_ADDR_VAR 0 11
69525: PUSH
69526: LD_VAR 0 1
69530: PUSH
69531: LD_VAR 0 2
69535: MINUS
69536: PUSH
69537: LD_VAR 0 3
69541: PLUS
69542: ST_TO_ADDR
69543: GO 69561
// length := i_to - i_from ;
69545: LD_ADDR_VAR 0 11
69549: PUSH
69550: LD_VAR 0 3
69554: PUSH
69555: LD_VAR 0 2
69559: MINUS
69560: ST_TO_ADDR
// end else
69561: GO 69624
// begin d := - 1 ;
69563: LD_ADDR_VAR 0 9
69567: PUSH
69568: LD_INT 1
69570: NEG
69571: ST_TO_ADDR
// if i_from > i_to then
69572: LD_VAR 0 2
69576: PUSH
69577: LD_VAR 0 3
69581: GREATER
69582: IFFALSE 69602
// length := i_from - i_to else
69584: LD_ADDR_VAR 0 11
69588: PUSH
69589: LD_VAR 0 2
69593: PUSH
69594: LD_VAR 0 3
69598: MINUS
69599: ST_TO_ADDR
69600: GO 69624
// length := ( array - i_to ) + i_from ;
69602: LD_ADDR_VAR 0 11
69606: PUSH
69607: LD_VAR 0 1
69611: PUSH
69612: LD_VAR 0 3
69616: MINUS
69617: PUSH
69618: LD_VAR 0 2
69622: PLUS
69623: ST_TO_ADDR
// end ; if not length then
69624: LD_VAR 0 11
69628: NOT
69629: IFFALSE 69633
// exit ;
69631: GO 69791
// tmp := array ;
69633: LD_ADDR_VAR 0 10
69637: PUSH
69638: LD_VAR 0 1
69642: ST_TO_ADDR
// for i = 1 to length do
69643: LD_ADDR_VAR 0 6
69647: PUSH
69648: DOUBLE
69649: LD_INT 1
69651: DEC
69652: ST_TO_ADDR
69653: LD_VAR 0 11
69657: PUSH
69658: FOR_TO
69659: IFFALSE 69779
// begin for j = 1 to array do
69661: LD_ADDR_VAR 0 7
69665: PUSH
69666: DOUBLE
69667: LD_INT 1
69669: DEC
69670: ST_TO_ADDR
69671: LD_VAR 0 1
69675: PUSH
69676: FOR_TO
69677: IFFALSE 69765
// begin k := j + d ;
69679: LD_ADDR_VAR 0 8
69683: PUSH
69684: LD_VAR 0 7
69688: PUSH
69689: LD_VAR 0 9
69693: PLUS
69694: ST_TO_ADDR
// if k > array then
69695: LD_VAR 0 8
69699: PUSH
69700: LD_VAR 0 1
69704: GREATER
69705: IFFALSE 69715
// k := 1 ;
69707: LD_ADDR_VAR 0 8
69711: PUSH
69712: LD_INT 1
69714: ST_TO_ADDR
// if not k then
69715: LD_VAR 0 8
69719: NOT
69720: IFFALSE 69732
// k := array ;
69722: LD_ADDR_VAR 0 8
69726: PUSH
69727: LD_VAR 0 1
69731: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69732: LD_ADDR_VAR 0 10
69736: PUSH
69737: LD_VAR 0 10
69741: PPUSH
69742: LD_VAR 0 8
69746: PPUSH
69747: LD_VAR 0 1
69751: PUSH
69752: LD_VAR 0 7
69756: ARRAY
69757: PPUSH
69758: CALL_OW 1
69762: ST_TO_ADDR
// end ;
69763: GO 69676
69765: POP
69766: POP
// array := tmp ;
69767: LD_ADDR_VAR 0 1
69771: PUSH
69772: LD_VAR 0 10
69776: ST_TO_ADDR
// end ;
69777: GO 69658
69779: POP
69780: POP
// result := array ;
69781: LD_ADDR_VAR 0 5
69785: PUSH
69786: LD_VAR 0 1
69790: ST_TO_ADDR
// end ;
69791: LD_VAR 0 5
69795: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69796: LD_INT 0
69798: PPUSH
69799: PPUSH
// result := 0 ;
69800: LD_ADDR_VAR 0 3
69804: PUSH
69805: LD_INT 0
69807: ST_TO_ADDR
// if not array or not value in array then
69808: LD_VAR 0 1
69812: NOT
69813: PUSH
69814: LD_VAR 0 2
69818: PUSH
69819: LD_VAR 0 1
69823: IN
69824: NOT
69825: OR
69826: IFFALSE 69830
// exit ;
69828: GO 69884
// for i = 1 to array do
69830: LD_ADDR_VAR 0 4
69834: PUSH
69835: DOUBLE
69836: LD_INT 1
69838: DEC
69839: ST_TO_ADDR
69840: LD_VAR 0 1
69844: PUSH
69845: FOR_TO
69846: IFFALSE 69882
// if value = array [ i ] then
69848: LD_VAR 0 2
69852: PUSH
69853: LD_VAR 0 1
69857: PUSH
69858: LD_VAR 0 4
69862: ARRAY
69863: EQUAL
69864: IFFALSE 69880
// begin result := i ;
69866: LD_ADDR_VAR 0 3
69870: PUSH
69871: LD_VAR 0 4
69875: ST_TO_ADDR
// exit ;
69876: POP
69877: POP
69878: GO 69884
// end ;
69880: GO 69845
69882: POP
69883: POP
// end ;
69884: LD_VAR 0 3
69888: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69889: LD_INT 0
69891: PPUSH
// vc_chassis := chassis ;
69892: LD_ADDR_OWVAR 37
69896: PUSH
69897: LD_VAR 0 1
69901: ST_TO_ADDR
// vc_engine := engine ;
69902: LD_ADDR_OWVAR 39
69906: PUSH
69907: LD_VAR 0 2
69911: ST_TO_ADDR
// vc_control := control ;
69912: LD_ADDR_OWVAR 38
69916: PUSH
69917: LD_VAR 0 3
69921: ST_TO_ADDR
// vc_weapon := weapon ;
69922: LD_ADDR_OWVAR 40
69926: PUSH
69927: LD_VAR 0 4
69931: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69932: LD_ADDR_OWVAR 41
69936: PUSH
69937: LD_VAR 0 5
69941: ST_TO_ADDR
// end ;
69942: LD_VAR 0 6
69946: RET
// export function WantPlant ( unit ) ; var task ; begin
69947: LD_INT 0
69949: PPUSH
69950: PPUSH
// result := false ;
69951: LD_ADDR_VAR 0 2
69955: PUSH
69956: LD_INT 0
69958: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69959: LD_ADDR_VAR 0 3
69963: PUSH
69964: LD_VAR 0 1
69968: PPUSH
69969: CALL_OW 437
69973: ST_TO_ADDR
// if task then
69974: LD_VAR 0 3
69978: IFFALSE 70006
// if task [ 1 ] [ 1 ] = p then
69980: LD_VAR 0 3
69984: PUSH
69985: LD_INT 1
69987: ARRAY
69988: PUSH
69989: LD_INT 1
69991: ARRAY
69992: PUSH
69993: LD_STRING p
69995: EQUAL
69996: IFFALSE 70006
// result := true ;
69998: LD_ADDR_VAR 0 2
70002: PUSH
70003: LD_INT 1
70005: ST_TO_ADDR
// end ;
70006: LD_VAR 0 2
70010: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70011: LD_INT 0
70013: PPUSH
70014: PPUSH
70015: PPUSH
70016: PPUSH
// if pos < 1 then
70017: LD_VAR 0 2
70021: PUSH
70022: LD_INT 1
70024: LESS
70025: IFFALSE 70029
// exit ;
70027: GO 70332
// if pos = 1 then
70029: LD_VAR 0 2
70033: PUSH
70034: LD_INT 1
70036: EQUAL
70037: IFFALSE 70070
// result := Replace ( arr , pos [ 1 ] , value ) else
70039: LD_ADDR_VAR 0 4
70043: PUSH
70044: LD_VAR 0 1
70048: PPUSH
70049: LD_VAR 0 2
70053: PUSH
70054: LD_INT 1
70056: ARRAY
70057: PPUSH
70058: LD_VAR 0 3
70062: PPUSH
70063: CALL_OW 1
70067: ST_TO_ADDR
70068: GO 70332
// begin tmp := arr ;
70070: LD_ADDR_VAR 0 6
70074: PUSH
70075: LD_VAR 0 1
70079: ST_TO_ADDR
// s_arr := [ tmp ] ;
70080: LD_ADDR_VAR 0 7
70084: PUSH
70085: LD_VAR 0 6
70089: PUSH
70090: EMPTY
70091: LIST
70092: ST_TO_ADDR
// for i = 1 to pos - 1 do
70093: LD_ADDR_VAR 0 5
70097: PUSH
70098: DOUBLE
70099: LD_INT 1
70101: DEC
70102: ST_TO_ADDR
70103: LD_VAR 0 2
70107: PUSH
70108: LD_INT 1
70110: MINUS
70111: PUSH
70112: FOR_TO
70113: IFFALSE 70158
// begin tmp := tmp [ pos [ i ] ] ;
70115: LD_ADDR_VAR 0 6
70119: PUSH
70120: LD_VAR 0 6
70124: PUSH
70125: LD_VAR 0 2
70129: PUSH
70130: LD_VAR 0 5
70134: ARRAY
70135: ARRAY
70136: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70137: LD_ADDR_VAR 0 7
70141: PUSH
70142: LD_VAR 0 7
70146: PUSH
70147: LD_VAR 0 6
70151: PUSH
70152: EMPTY
70153: LIST
70154: ADD
70155: ST_TO_ADDR
// end ;
70156: GO 70112
70158: POP
70159: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70160: LD_ADDR_VAR 0 6
70164: PUSH
70165: LD_VAR 0 6
70169: PPUSH
70170: LD_VAR 0 2
70174: PUSH
70175: LD_VAR 0 2
70179: ARRAY
70180: PPUSH
70181: LD_VAR 0 3
70185: PPUSH
70186: CALL_OW 1
70190: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70191: LD_ADDR_VAR 0 7
70195: PUSH
70196: LD_VAR 0 7
70200: PPUSH
70201: LD_VAR 0 7
70205: PPUSH
70206: LD_VAR 0 6
70210: PPUSH
70211: CALL_OW 1
70215: ST_TO_ADDR
// for i = s_arr downto 2 do
70216: LD_ADDR_VAR 0 5
70220: PUSH
70221: DOUBLE
70222: LD_VAR 0 7
70226: INC
70227: ST_TO_ADDR
70228: LD_INT 2
70230: PUSH
70231: FOR_DOWNTO
70232: IFFALSE 70316
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70234: LD_ADDR_VAR 0 6
70238: PUSH
70239: LD_VAR 0 7
70243: PUSH
70244: LD_VAR 0 5
70248: PUSH
70249: LD_INT 1
70251: MINUS
70252: ARRAY
70253: PPUSH
70254: LD_VAR 0 2
70258: PUSH
70259: LD_VAR 0 5
70263: PUSH
70264: LD_INT 1
70266: MINUS
70267: ARRAY
70268: PPUSH
70269: LD_VAR 0 7
70273: PUSH
70274: LD_VAR 0 5
70278: ARRAY
70279: PPUSH
70280: CALL_OW 1
70284: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70285: LD_ADDR_VAR 0 7
70289: PUSH
70290: LD_VAR 0 7
70294: PPUSH
70295: LD_VAR 0 5
70299: PUSH
70300: LD_INT 1
70302: MINUS
70303: PPUSH
70304: LD_VAR 0 6
70308: PPUSH
70309: CALL_OW 1
70313: ST_TO_ADDR
// end ;
70314: GO 70231
70316: POP
70317: POP
// result := s_arr [ 1 ] ;
70318: LD_ADDR_VAR 0 4
70322: PUSH
70323: LD_VAR 0 7
70327: PUSH
70328: LD_INT 1
70330: ARRAY
70331: ST_TO_ADDR
// end ; end ;
70332: LD_VAR 0 4
70336: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70337: LD_INT 0
70339: PPUSH
70340: PPUSH
// if not list then
70341: LD_VAR 0 1
70345: NOT
70346: IFFALSE 70350
// exit ;
70348: GO 70441
// i := list [ pos1 ] ;
70350: LD_ADDR_VAR 0 5
70354: PUSH
70355: LD_VAR 0 1
70359: PUSH
70360: LD_VAR 0 2
70364: ARRAY
70365: ST_TO_ADDR
// if not i then
70366: LD_VAR 0 5
70370: NOT
70371: IFFALSE 70375
// exit ;
70373: GO 70441
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70375: LD_ADDR_VAR 0 1
70379: PUSH
70380: LD_VAR 0 1
70384: PPUSH
70385: LD_VAR 0 2
70389: PPUSH
70390: LD_VAR 0 1
70394: PUSH
70395: LD_VAR 0 3
70399: ARRAY
70400: PPUSH
70401: CALL_OW 1
70405: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70406: LD_ADDR_VAR 0 1
70410: PUSH
70411: LD_VAR 0 1
70415: PPUSH
70416: LD_VAR 0 3
70420: PPUSH
70421: LD_VAR 0 5
70425: PPUSH
70426: CALL_OW 1
70430: ST_TO_ADDR
// result := list ;
70431: LD_ADDR_VAR 0 4
70435: PUSH
70436: LD_VAR 0 1
70440: ST_TO_ADDR
// end ;
70441: LD_VAR 0 4
70445: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70446: LD_INT 0
70448: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70449: LD_ADDR_VAR 0 5
70453: PUSH
70454: LD_VAR 0 1
70458: PPUSH
70459: CALL_OW 250
70463: PPUSH
70464: LD_VAR 0 1
70468: PPUSH
70469: CALL_OW 251
70473: PPUSH
70474: LD_VAR 0 2
70478: PPUSH
70479: LD_VAR 0 3
70483: PPUSH
70484: LD_VAR 0 4
70488: PPUSH
70489: CALL 70499 0 5
70493: ST_TO_ADDR
// end ;
70494: LD_VAR 0 5
70498: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70499: LD_INT 0
70501: PPUSH
70502: PPUSH
70503: PPUSH
70504: PPUSH
// if not list then
70505: LD_VAR 0 3
70509: NOT
70510: IFFALSE 70514
// exit ;
70512: GO 70902
// result := [ ] ;
70514: LD_ADDR_VAR 0 6
70518: PUSH
70519: EMPTY
70520: ST_TO_ADDR
// for i in list do
70521: LD_ADDR_VAR 0 7
70525: PUSH
70526: LD_VAR 0 3
70530: PUSH
70531: FOR_IN
70532: IFFALSE 70734
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70534: LD_ADDR_VAR 0 9
70538: PUSH
70539: LD_VAR 0 7
70543: PPUSH
70544: LD_VAR 0 1
70548: PPUSH
70549: LD_VAR 0 2
70553: PPUSH
70554: CALL_OW 297
70558: ST_TO_ADDR
// if not result then
70559: LD_VAR 0 6
70563: NOT
70564: IFFALSE 70590
// result := [ [ i , tmp ] ] else
70566: LD_ADDR_VAR 0 6
70570: PUSH
70571: LD_VAR 0 7
70575: PUSH
70576: LD_VAR 0 9
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: EMPTY
70586: LIST
70587: ST_TO_ADDR
70588: GO 70732
// begin if result [ result ] [ 2 ] < tmp then
70590: LD_VAR 0 6
70594: PUSH
70595: LD_VAR 0 6
70599: ARRAY
70600: PUSH
70601: LD_INT 2
70603: ARRAY
70604: PUSH
70605: LD_VAR 0 9
70609: LESS
70610: IFFALSE 70652
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70612: LD_ADDR_VAR 0 6
70616: PUSH
70617: LD_VAR 0 6
70621: PPUSH
70622: LD_VAR 0 6
70626: PUSH
70627: LD_INT 1
70629: PLUS
70630: PPUSH
70631: LD_VAR 0 7
70635: PUSH
70636: LD_VAR 0 9
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: PPUSH
70645: CALL_OW 2
70649: ST_TO_ADDR
70650: GO 70732
// for j = 1 to result do
70652: LD_ADDR_VAR 0 8
70656: PUSH
70657: DOUBLE
70658: LD_INT 1
70660: DEC
70661: ST_TO_ADDR
70662: LD_VAR 0 6
70666: PUSH
70667: FOR_TO
70668: IFFALSE 70730
// begin if tmp < result [ j ] [ 2 ] then
70670: LD_VAR 0 9
70674: PUSH
70675: LD_VAR 0 6
70679: PUSH
70680: LD_VAR 0 8
70684: ARRAY
70685: PUSH
70686: LD_INT 2
70688: ARRAY
70689: LESS
70690: IFFALSE 70728
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70692: LD_ADDR_VAR 0 6
70696: PUSH
70697: LD_VAR 0 6
70701: PPUSH
70702: LD_VAR 0 8
70706: PPUSH
70707: LD_VAR 0 7
70711: PUSH
70712: LD_VAR 0 9
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PPUSH
70721: CALL_OW 2
70725: ST_TO_ADDR
// break ;
70726: GO 70730
// end ; end ;
70728: GO 70667
70730: POP
70731: POP
// end ; end ;
70732: GO 70531
70734: POP
70735: POP
// if result and not asc then
70736: LD_VAR 0 6
70740: PUSH
70741: LD_VAR 0 4
70745: NOT
70746: AND
70747: IFFALSE 70822
// begin tmp := result ;
70749: LD_ADDR_VAR 0 9
70753: PUSH
70754: LD_VAR 0 6
70758: ST_TO_ADDR
// for i = tmp downto 1 do
70759: LD_ADDR_VAR 0 7
70763: PUSH
70764: DOUBLE
70765: LD_VAR 0 9
70769: INC
70770: ST_TO_ADDR
70771: LD_INT 1
70773: PUSH
70774: FOR_DOWNTO
70775: IFFALSE 70820
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70777: LD_ADDR_VAR 0 6
70781: PUSH
70782: LD_VAR 0 6
70786: PPUSH
70787: LD_VAR 0 9
70791: PUSH
70792: LD_VAR 0 7
70796: MINUS
70797: PUSH
70798: LD_INT 1
70800: PLUS
70801: PPUSH
70802: LD_VAR 0 9
70806: PUSH
70807: LD_VAR 0 7
70811: ARRAY
70812: PPUSH
70813: CALL_OW 1
70817: ST_TO_ADDR
70818: GO 70774
70820: POP
70821: POP
// end ; tmp := [ ] ;
70822: LD_ADDR_VAR 0 9
70826: PUSH
70827: EMPTY
70828: ST_TO_ADDR
// if mode then
70829: LD_VAR 0 5
70833: IFFALSE 70902
// begin for i = 1 to result do
70835: LD_ADDR_VAR 0 7
70839: PUSH
70840: DOUBLE
70841: LD_INT 1
70843: DEC
70844: ST_TO_ADDR
70845: LD_VAR 0 6
70849: PUSH
70850: FOR_TO
70851: IFFALSE 70890
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70853: LD_ADDR_VAR 0 9
70857: PUSH
70858: LD_VAR 0 9
70862: PPUSH
70863: LD_VAR 0 7
70867: PPUSH
70868: LD_VAR 0 6
70872: PUSH
70873: LD_VAR 0 7
70877: ARRAY
70878: PUSH
70879: LD_INT 1
70881: ARRAY
70882: PPUSH
70883: CALL_OW 1
70887: ST_TO_ADDR
70888: GO 70850
70890: POP
70891: POP
// result := tmp ;
70892: LD_ADDR_VAR 0 6
70896: PUSH
70897: LD_VAR 0 9
70901: ST_TO_ADDR
// end ; end ;
70902: LD_VAR 0 6
70906: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70907: LD_INT 0
70909: PPUSH
70910: PPUSH
70911: PPUSH
70912: PPUSH
70913: PPUSH
70914: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70915: LD_ADDR_VAR 0 5
70919: PUSH
70920: LD_INT 0
70922: PUSH
70923: LD_INT 0
70925: PUSH
70926: LD_INT 0
70928: PUSH
70929: EMPTY
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: ST_TO_ADDR
// if not x or not y then
70937: LD_VAR 0 2
70941: NOT
70942: PUSH
70943: LD_VAR 0 3
70947: NOT
70948: OR
70949: IFFALSE 70953
// exit ;
70951: GO 72599
// if not range then
70953: LD_VAR 0 4
70957: NOT
70958: IFFALSE 70968
// range := 10 ;
70960: LD_ADDR_VAR 0 4
70964: PUSH
70965: LD_INT 10
70967: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70968: LD_ADDR_VAR 0 8
70972: PUSH
70973: LD_INT 81
70975: PUSH
70976: LD_VAR 0 1
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 92
70987: PUSH
70988: LD_VAR 0 2
70992: PUSH
70993: LD_VAR 0 3
70997: PUSH
70998: LD_VAR 0 4
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: LIST
71007: LIST
71008: PUSH
71009: LD_INT 3
71011: PUSH
71012: LD_INT 21
71014: PUSH
71015: LD_INT 3
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: EMPTY
71023: LIST
71024: LIST
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: LIST
71030: PPUSH
71031: CALL_OW 69
71035: ST_TO_ADDR
// if not tmp then
71036: LD_VAR 0 8
71040: NOT
71041: IFFALSE 71045
// exit ;
71043: GO 72599
// for i in tmp do
71045: LD_ADDR_VAR 0 6
71049: PUSH
71050: LD_VAR 0 8
71054: PUSH
71055: FOR_IN
71056: IFFALSE 72574
// begin points := [ 0 , 0 , 0 ] ;
71058: LD_ADDR_VAR 0 9
71062: PUSH
71063: LD_INT 0
71065: PUSH
71066: LD_INT 0
71068: PUSH
71069: LD_INT 0
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: LIST
71076: ST_TO_ADDR
// bpoints := 1 ;
71077: LD_ADDR_VAR 0 10
71081: PUSH
71082: LD_INT 1
71084: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71085: LD_VAR 0 6
71089: PPUSH
71090: CALL_OW 247
71094: PUSH
71095: LD_INT 1
71097: DOUBLE
71098: EQUAL
71099: IFTRUE 71103
71101: GO 71681
71103: POP
// begin if GetClass ( i ) = 1 then
71104: LD_VAR 0 6
71108: PPUSH
71109: CALL_OW 257
71113: PUSH
71114: LD_INT 1
71116: EQUAL
71117: IFFALSE 71138
// points := [ 10 , 5 , 3 ] ;
71119: LD_ADDR_VAR 0 9
71123: PUSH
71124: LD_INT 10
71126: PUSH
71127: LD_INT 5
71129: PUSH
71130: LD_INT 3
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: LIST
71137: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71138: LD_VAR 0 6
71142: PPUSH
71143: CALL_OW 257
71147: PUSH
71148: LD_INT 2
71150: PUSH
71151: LD_INT 3
71153: PUSH
71154: LD_INT 4
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: LIST
71161: IN
71162: IFFALSE 71183
// points := [ 3 , 2 , 1 ] ;
71164: LD_ADDR_VAR 0 9
71168: PUSH
71169: LD_INT 3
71171: PUSH
71172: LD_INT 2
71174: PUSH
71175: LD_INT 1
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: LIST
71182: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71183: LD_VAR 0 6
71187: PPUSH
71188: CALL_OW 257
71192: PUSH
71193: LD_INT 5
71195: EQUAL
71196: IFFALSE 71217
// points := [ 130 , 5 , 2 ] ;
71198: LD_ADDR_VAR 0 9
71202: PUSH
71203: LD_INT 130
71205: PUSH
71206: LD_INT 5
71208: PUSH
71209: LD_INT 2
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: LIST
71216: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71217: LD_VAR 0 6
71221: PPUSH
71222: CALL_OW 257
71226: PUSH
71227: LD_INT 8
71229: EQUAL
71230: IFFALSE 71251
// points := [ 35 , 35 , 30 ] ;
71232: LD_ADDR_VAR 0 9
71236: PUSH
71237: LD_INT 35
71239: PUSH
71240: LD_INT 35
71242: PUSH
71243: LD_INT 30
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: LIST
71250: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71251: LD_VAR 0 6
71255: PPUSH
71256: CALL_OW 257
71260: PUSH
71261: LD_INT 9
71263: EQUAL
71264: IFFALSE 71285
// points := [ 20 , 55 , 40 ] ;
71266: LD_ADDR_VAR 0 9
71270: PUSH
71271: LD_INT 20
71273: PUSH
71274: LD_INT 55
71276: PUSH
71277: LD_INT 40
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: LIST
71284: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71285: LD_VAR 0 6
71289: PPUSH
71290: CALL_OW 257
71294: PUSH
71295: LD_INT 12
71297: PUSH
71298: LD_INT 16
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: IN
71305: IFFALSE 71326
// points := [ 5 , 3 , 2 ] ;
71307: LD_ADDR_VAR 0 9
71311: PUSH
71312: LD_INT 5
71314: PUSH
71315: LD_INT 3
71317: PUSH
71318: LD_INT 2
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: LIST
71325: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71326: LD_VAR 0 6
71330: PPUSH
71331: CALL_OW 257
71335: PUSH
71336: LD_INT 17
71338: EQUAL
71339: IFFALSE 71360
// points := [ 100 , 50 , 75 ] ;
71341: LD_ADDR_VAR 0 9
71345: PUSH
71346: LD_INT 100
71348: PUSH
71349: LD_INT 50
71351: PUSH
71352: LD_INT 75
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: LIST
71359: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71360: LD_VAR 0 6
71364: PPUSH
71365: CALL_OW 257
71369: PUSH
71370: LD_INT 15
71372: EQUAL
71373: IFFALSE 71394
// points := [ 10 , 5 , 3 ] ;
71375: LD_ADDR_VAR 0 9
71379: PUSH
71380: LD_INT 10
71382: PUSH
71383: LD_INT 5
71385: PUSH
71386: LD_INT 3
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: LIST
71393: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71394: LD_VAR 0 6
71398: PPUSH
71399: CALL_OW 257
71403: PUSH
71404: LD_INT 14
71406: EQUAL
71407: IFFALSE 71428
// points := [ 10 , 0 , 0 ] ;
71409: LD_ADDR_VAR 0 9
71413: PUSH
71414: LD_INT 10
71416: PUSH
71417: LD_INT 0
71419: PUSH
71420: LD_INT 0
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: LIST
71427: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71428: LD_VAR 0 6
71432: PPUSH
71433: CALL_OW 257
71437: PUSH
71438: LD_INT 11
71440: EQUAL
71441: IFFALSE 71462
// points := [ 30 , 10 , 5 ] ;
71443: LD_ADDR_VAR 0 9
71447: PUSH
71448: LD_INT 30
71450: PUSH
71451: LD_INT 10
71453: PUSH
71454: LD_INT 5
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: LIST
71461: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71462: LD_VAR 0 1
71466: PPUSH
71467: LD_INT 5
71469: PPUSH
71470: CALL_OW 321
71474: PUSH
71475: LD_INT 2
71477: EQUAL
71478: IFFALSE 71495
// bpoints := bpoints * 1.8 ;
71480: LD_ADDR_VAR 0 10
71484: PUSH
71485: LD_VAR 0 10
71489: PUSH
71490: LD_REAL  1.80000000000000E+0000
71493: MUL
71494: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71495: LD_VAR 0 6
71499: PPUSH
71500: CALL_OW 257
71504: PUSH
71505: LD_INT 1
71507: PUSH
71508: LD_INT 2
71510: PUSH
71511: LD_INT 3
71513: PUSH
71514: LD_INT 4
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: IN
71523: PUSH
71524: LD_VAR 0 1
71528: PPUSH
71529: LD_INT 51
71531: PPUSH
71532: CALL_OW 321
71536: PUSH
71537: LD_INT 2
71539: EQUAL
71540: AND
71541: IFFALSE 71558
// bpoints := bpoints * 1.2 ;
71543: LD_ADDR_VAR 0 10
71547: PUSH
71548: LD_VAR 0 10
71552: PUSH
71553: LD_REAL  1.20000000000000E+0000
71556: MUL
71557: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71558: LD_VAR 0 6
71562: PPUSH
71563: CALL_OW 257
71567: PUSH
71568: LD_INT 5
71570: PUSH
71571: LD_INT 7
71573: PUSH
71574: LD_INT 9
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: LIST
71581: IN
71582: PUSH
71583: LD_VAR 0 1
71587: PPUSH
71588: LD_INT 52
71590: PPUSH
71591: CALL_OW 321
71595: PUSH
71596: LD_INT 2
71598: EQUAL
71599: AND
71600: IFFALSE 71617
// bpoints := bpoints * 1.5 ;
71602: LD_ADDR_VAR 0 10
71606: PUSH
71607: LD_VAR 0 10
71611: PUSH
71612: LD_REAL  1.50000000000000E+0000
71615: MUL
71616: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71617: LD_VAR 0 1
71621: PPUSH
71622: LD_INT 66
71624: PPUSH
71625: CALL_OW 321
71629: PUSH
71630: LD_INT 2
71632: EQUAL
71633: IFFALSE 71650
// bpoints := bpoints * 1.1 ;
71635: LD_ADDR_VAR 0 10
71639: PUSH
71640: LD_VAR 0 10
71644: PUSH
71645: LD_REAL  1.10000000000000E+0000
71648: MUL
71649: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71650: LD_ADDR_VAR 0 10
71654: PUSH
71655: LD_VAR 0 10
71659: PUSH
71660: LD_VAR 0 6
71664: PPUSH
71665: LD_INT 1
71667: PPUSH
71668: CALL_OW 259
71672: PUSH
71673: LD_REAL  1.15000000000000E+0000
71676: MUL
71677: MUL
71678: ST_TO_ADDR
// end ; unit_vehicle :
71679: GO 72503
71681: LD_INT 2
71683: DOUBLE
71684: EQUAL
71685: IFTRUE 71689
71687: GO 72491
71689: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71690: LD_VAR 0 6
71694: PPUSH
71695: CALL_OW 264
71699: PUSH
71700: LD_INT 2
71702: PUSH
71703: LD_INT 42
71705: PUSH
71706: LD_INT 24
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: LIST
71713: IN
71714: IFFALSE 71735
// points := [ 25 , 5 , 3 ] ;
71716: LD_ADDR_VAR 0 9
71720: PUSH
71721: LD_INT 25
71723: PUSH
71724: LD_INT 5
71726: PUSH
71727: LD_INT 3
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: LIST
71734: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71735: LD_VAR 0 6
71739: PPUSH
71740: CALL_OW 264
71744: PUSH
71745: LD_INT 4
71747: PUSH
71748: LD_INT 43
71750: PUSH
71751: LD_INT 25
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: LIST
71758: IN
71759: IFFALSE 71780
// points := [ 40 , 15 , 5 ] ;
71761: LD_ADDR_VAR 0 9
71765: PUSH
71766: LD_INT 40
71768: PUSH
71769: LD_INT 15
71771: PUSH
71772: LD_INT 5
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: LIST
71779: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71780: LD_VAR 0 6
71784: PPUSH
71785: CALL_OW 264
71789: PUSH
71790: LD_INT 3
71792: PUSH
71793: LD_INT 23
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: IN
71800: IFFALSE 71821
// points := [ 7 , 25 , 8 ] ;
71802: LD_ADDR_VAR 0 9
71806: PUSH
71807: LD_INT 7
71809: PUSH
71810: LD_INT 25
71812: PUSH
71813: LD_INT 8
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: LIST
71820: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71821: LD_VAR 0 6
71825: PPUSH
71826: CALL_OW 264
71830: PUSH
71831: LD_INT 5
71833: PUSH
71834: LD_INT 27
71836: PUSH
71837: LD_INT 44
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: LIST
71844: IN
71845: IFFALSE 71866
// points := [ 14 , 50 , 16 ] ;
71847: LD_ADDR_VAR 0 9
71851: PUSH
71852: LD_INT 14
71854: PUSH
71855: LD_INT 50
71857: PUSH
71858: LD_INT 16
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: LIST
71865: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71866: LD_VAR 0 6
71870: PPUSH
71871: CALL_OW 264
71875: PUSH
71876: LD_INT 6
71878: PUSH
71879: LD_INT 46
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: IN
71886: IFFALSE 71907
// points := [ 32 , 120 , 70 ] ;
71888: LD_ADDR_VAR 0 9
71892: PUSH
71893: LD_INT 32
71895: PUSH
71896: LD_INT 120
71898: PUSH
71899: LD_INT 70
71901: PUSH
71902: EMPTY
71903: LIST
71904: LIST
71905: LIST
71906: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71907: LD_VAR 0 6
71911: PPUSH
71912: CALL_OW 264
71916: PUSH
71917: LD_INT 7
71919: PUSH
71920: LD_INT 28
71922: PUSH
71923: LD_INT 45
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: LIST
71930: IN
71931: IFFALSE 71952
// points := [ 35 , 20 , 45 ] ;
71933: LD_ADDR_VAR 0 9
71937: PUSH
71938: LD_INT 35
71940: PUSH
71941: LD_INT 20
71943: PUSH
71944: LD_INT 45
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: LIST
71951: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71952: LD_VAR 0 6
71956: PPUSH
71957: CALL_OW 264
71961: PUSH
71962: LD_INT 47
71964: PUSH
71965: EMPTY
71966: LIST
71967: IN
71968: IFFALSE 71989
// points := [ 67 , 45 , 75 ] ;
71970: LD_ADDR_VAR 0 9
71974: PUSH
71975: LD_INT 67
71977: PUSH
71978: LD_INT 45
71980: PUSH
71981: LD_INT 75
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: LIST
71988: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71989: LD_VAR 0 6
71993: PPUSH
71994: CALL_OW 264
71998: PUSH
71999: LD_INT 26
72001: PUSH
72002: EMPTY
72003: LIST
72004: IN
72005: IFFALSE 72026
// points := [ 120 , 30 , 80 ] ;
72007: LD_ADDR_VAR 0 9
72011: PUSH
72012: LD_INT 120
72014: PUSH
72015: LD_INT 30
72017: PUSH
72018: LD_INT 80
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: LIST
72025: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72026: LD_VAR 0 6
72030: PPUSH
72031: CALL_OW 264
72035: PUSH
72036: LD_INT 22
72038: PUSH
72039: EMPTY
72040: LIST
72041: IN
72042: IFFALSE 72063
// points := [ 40 , 1 , 1 ] ;
72044: LD_ADDR_VAR 0 9
72048: PUSH
72049: LD_INT 40
72051: PUSH
72052: LD_INT 1
72054: PUSH
72055: LD_INT 1
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: LIST
72062: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72063: LD_VAR 0 6
72067: PPUSH
72068: CALL_OW 264
72072: PUSH
72073: LD_INT 29
72075: PUSH
72076: EMPTY
72077: LIST
72078: IN
72079: IFFALSE 72100
// points := [ 70 , 200 , 400 ] ;
72081: LD_ADDR_VAR 0 9
72085: PUSH
72086: LD_INT 70
72088: PUSH
72089: LD_INT 200
72091: PUSH
72092: LD_INT 400
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: LIST
72099: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72100: LD_VAR 0 6
72104: PPUSH
72105: CALL_OW 264
72109: PUSH
72110: LD_INT 14
72112: PUSH
72113: LD_INT 53
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: IN
72120: IFFALSE 72141
// points := [ 40 , 10 , 20 ] ;
72122: LD_ADDR_VAR 0 9
72126: PUSH
72127: LD_INT 40
72129: PUSH
72130: LD_INT 10
72132: PUSH
72133: LD_INT 20
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: LIST
72140: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72141: LD_VAR 0 6
72145: PPUSH
72146: CALL_OW 264
72150: PUSH
72151: LD_INT 9
72153: PUSH
72154: EMPTY
72155: LIST
72156: IN
72157: IFFALSE 72178
// points := [ 5 , 70 , 20 ] ;
72159: LD_ADDR_VAR 0 9
72163: PUSH
72164: LD_INT 5
72166: PUSH
72167: LD_INT 70
72169: PUSH
72170: LD_INT 20
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: LIST
72177: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72178: LD_VAR 0 6
72182: PPUSH
72183: CALL_OW 264
72187: PUSH
72188: LD_INT 10
72190: PUSH
72191: EMPTY
72192: LIST
72193: IN
72194: IFFALSE 72215
// points := [ 35 , 110 , 70 ] ;
72196: LD_ADDR_VAR 0 9
72200: PUSH
72201: LD_INT 35
72203: PUSH
72204: LD_INT 110
72206: PUSH
72207: LD_INT 70
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: LIST
72214: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72215: LD_VAR 0 6
72219: PPUSH
72220: CALL_OW 265
72224: PUSH
72225: LD_INT 25
72227: EQUAL
72228: IFFALSE 72249
// points := [ 80 , 65 , 100 ] ;
72230: LD_ADDR_VAR 0 9
72234: PUSH
72235: LD_INT 80
72237: PUSH
72238: LD_INT 65
72240: PUSH
72241: LD_INT 100
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: LIST
72248: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72249: LD_VAR 0 6
72253: PPUSH
72254: CALL_OW 263
72258: PUSH
72259: LD_INT 1
72261: EQUAL
72262: IFFALSE 72297
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72264: LD_ADDR_VAR 0 10
72268: PUSH
72269: LD_VAR 0 10
72273: PUSH
72274: LD_VAR 0 6
72278: PPUSH
72279: CALL_OW 311
72283: PPUSH
72284: LD_INT 3
72286: PPUSH
72287: CALL_OW 259
72291: PUSH
72292: LD_INT 4
72294: MUL
72295: MUL
72296: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72297: LD_VAR 0 6
72301: PPUSH
72302: CALL_OW 263
72306: PUSH
72307: LD_INT 2
72309: EQUAL
72310: IFFALSE 72361
// begin j := IsControledBy ( i ) ;
72312: LD_ADDR_VAR 0 7
72316: PUSH
72317: LD_VAR 0 6
72321: PPUSH
72322: CALL_OW 312
72326: ST_TO_ADDR
// if j then
72327: LD_VAR 0 7
72331: IFFALSE 72361
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72333: LD_ADDR_VAR 0 10
72337: PUSH
72338: LD_VAR 0 10
72342: PUSH
72343: LD_VAR 0 7
72347: PPUSH
72348: LD_INT 3
72350: PPUSH
72351: CALL_OW 259
72355: PUSH
72356: LD_INT 3
72358: MUL
72359: MUL
72360: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72361: LD_VAR 0 6
72365: PPUSH
72366: CALL_OW 264
72370: PUSH
72371: LD_INT 5
72373: PUSH
72374: LD_INT 6
72376: PUSH
72377: LD_INT 46
72379: PUSH
72380: LD_INT 44
72382: PUSH
72383: LD_INT 47
72385: PUSH
72386: LD_INT 45
72388: PUSH
72389: LD_INT 28
72391: PUSH
72392: LD_INT 7
72394: PUSH
72395: LD_INT 27
72397: PUSH
72398: LD_INT 29
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: IN
72413: PUSH
72414: LD_VAR 0 1
72418: PPUSH
72419: LD_INT 52
72421: PPUSH
72422: CALL_OW 321
72426: PUSH
72427: LD_INT 2
72429: EQUAL
72430: AND
72431: IFFALSE 72448
// bpoints := bpoints * 1.2 ;
72433: LD_ADDR_VAR 0 10
72437: PUSH
72438: LD_VAR 0 10
72442: PUSH
72443: LD_REAL  1.20000000000000E+0000
72446: MUL
72447: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72448: LD_VAR 0 6
72452: PPUSH
72453: CALL_OW 264
72457: PUSH
72458: LD_INT 6
72460: PUSH
72461: LD_INT 46
72463: PUSH
72464: LD_INT 47
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: LIST
72471: IN
72472: IFFALSE 72489
// bpoints := bpoints * 1.2 ;
72474: LD_ADDR_VAR 0 10
72478: PUSH
72479: LD_VAR 0 10
72483: PUSH
72484: LD_REAL  1.20000000000000E+0000
72487: MUL
72488: ST_TO_ADDR
// end ; unit_building :
72489: GO 72503
72491: LD_INT 3
72493: DOUBLE
72494: EQUAL
72495: IFTRUE 72499
72497: GO 72502
72499: POP
// ; end ;
72500: GO 72503
72502: POP
// for j = 1 to 3 do
72503: LD_ADDR_VAR 0 7
72507: PUSH
72508: DOUBLE
72509: LD_INT 1
72511: DEC
72512: ST_TO_ADDR
72513: LD_INT 3
72515: PUSH
72516: FOR_TO
72517: IFFALSE 72570
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72519: LD_ADDR_VAR 0 5
72523: PUSH
72524: LD_VAR 0 5
72528: PPUSH
72529: LD_VAR 0 7
72533: PPUSH
72534: LD_VAR 0 5
72538: PUSH
72539: LD_VAR 0 7
72543: ARRAY
72544: PUSH
72545: LD_VAR 0 9
72549: PUSH
72550: LD_VAR 0 7
72554: ARRAY
72555: PUSH
72556: LD_VAR 0 10
72560: MUL
72561: PLUS
72562: PPUSH
72563: CALL_OW 1
72567: ST_TO_ADDR
72568: GO 72516
72570: POP
72571: POP
// end ;
72572: GO 71055
72574: POP
72575: POP
// result := Replace ( result , 4 , tmp ) ;
72576: LD_ADDR_VAR 0 5
72580: PUSH
72581: LD_VAR 0 5
72585: PPUSH
72586: LD_INT 4
72588: PPUSH
72589: LD_VAR 0 8
72593: PPUSH
72594: CALL_OW 1
72598: ST_TO_ADDR
// end ;
72599: LD_VAR 0 5
72603: RET
// export function DangerAtRange ( unit , range ) ; begin
72604: LD_INT 0
72606: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72607: LD_ADDR_VAR 0 3
72611: PUSH
72612: LD_VAR 0 1
72616: PPUSH
72617: CALL_OW 255
72621: PPUSH
72622: LD_VAR 0 1
72626: PPUSH
72627: CALL_OW 250
72631: PPUSH
72632: LD_VAR 0 1
72636: PPUSH
72637: CALL_OW 251
72641: PPUSH
72642: LD_VAR 0 2
72646: PPUSH
72647: CALL 70907 0 4
72651: ST_TO_ADDR
// end ;
72652: LD_VAR 0 3
72656: RET
// export function DangerInArea ( side , area ) ; begin
72657: LD_INT 0
72659: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72660: LD_ADDR_VAR 0 3
72664: PUSH
72665: LD_VAR 0 2
72669: PPUSH
72670: LD_INT 81
72672: PUSH
72673: LD_VAR 0 1
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: PPUSH
72682: CALL_OW 70
72686: ST_TO_ADDR
// end ;
72687: LD_VAR 0 3
72691: RET
// export function IsExtension ( b ) ; begin
72692: LD_INT 0
72694: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72695: LD_ADDR_VAR 0 2
72699: PUSH
72700: LD_VAR 0 1
72704: PUSH
72705: LD_INT 23
72707: PUSH
72708: LD_INT 20
72710: PUSH
72711: LD_INT 22
72713: PUSH
72714: LD_INT 17
72716: PUSH
72717: LD_INT 24
72719: PUSH
72720: LD_INT 21
72722: PUSH
72723: LD_INT 19
72725: PUSH
72726: LD_INT 16
72728: PUSH
72729: LD_INT 25
72731: PUSH
72732: LD_INT 18
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: LIST
72741: LIST
72742: LIST
72743: LIST
72744: LIST
72745: LIST
72746: IN
72747: ST_TO_ADDR
// end ;
72748: LD_VAR 0 2
72752: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72753: LD_INT 0
72755: PPUSH
72756: PPUSH
72757: PPUSH
// result := [ ] ;
72758: LD_ADDR_VAR 0 3
72762: PUSH
72763: EMPTY
72764: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72765: LD_ADDR_VAR 0 4
72769: PUSH
72770: LD_VAR 0 2
72774: PPUSH
72775: LD_INT 21
72777: PUSH
72778: LD_INT 3
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: PPUSH
72785: CALL_OW 70
72789: ST_TO_ADDR
// if not tmp then
72790: LD_VAR 0 4
72794: NOT
72795: IFFALSE 72799
// exit ;
72797: GO 72857
// for i in tmp do
72799: LD_ADDR_VAR 0 5
72803: PUSH
72804: LD_VAR 0 4
72808: PUSH
72809: FOR_IN
72810: IFFALSE 72845
// if GetBase ( i ) <> base then
72812: LD_VAR 0 5
72816: PPUSH
72817: CALL_OW 274
72821: PUSH
72822: LD_VAR 0 1
72826: NONEQUAL
72827: IFFALSE 72843
// ComLinkToBase ( base , i ) ;
72829: LD_VAR 0 1
72833: PPUSH
72834: LD_VAR 0 5
72838: PPUSH
72839: CALL_OW 169
72843: GO 72809
72845: POP
72846: POP
// result := tmp ;
72847: LD_ADDR_VAR 0 3
72851: PUSH
72852: LD_VAR 0 4
72856: ST_TO_ADDR
// end ;
72857: LD_VAR 0 3
72861: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72862: LD_INT 0
72864: PPUSH
72865: PPUSH
// if BuildingStatus ( b ) = bs_build then
72866: LD_VAR 0 2
72870: PPUSH
72871: CALL_OW 461
72875: PUSH
72876: LD_INT 1
72878: EQUAL
72879: IFFALSE 72939
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72881: LD_VAR 0 1
72885: PPUSH
72886: LD_STRING h
72888: PUSH
72889: LD_VAR 0 2
72893: PPUSH
72894: CALL_OW 250
72898: PUSH
72899: LD_VAR 0 2
72903: PPUSH
72904: CALL_OW 251
72908: PUSH
72909: LD_VAR 0 2
72913: PUSH
72914: LD_INT 0
72916: PUSH
72917: LD_INT 0
72919: PUSH
72920: LD_INT 0
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: PUSH
72932: EMPTY
72933: LIST
72934: PPUSH
72935: CALL_OW 446
// end ;
72939: LD_VAR 0 3
72943: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72944: LD_INT 0
72946: PPUSH
72947: PPUSH
72948: PPUSH
72949: PPUSH
72950: PPUSH
72951: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72952: LD_VAR 0 1
72956: NOT
72957: PUSH
72958: LD_VAR 0 1
72962: PPUSH
72963: CALL_OW 263
72967: PUSH
72968: LD_INT 2
72970: EQUAL
72971: NOT
72972: OR
72973: IFFALSE 72977
// exit ;
72975: GO 73293
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72977: LD_ADDR_VAR 0 6
72981: PUSH
72982: LD_INT 22
72984: PUSH
72985: LD_VAR 0 1
72989: PPUSH
72990: CALL_OW 255
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 2
73001: PUSH
73002: LD_INT 30
73004: PUSH
73005: LD_INT 36
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PUSH
73012: LD_INT 34
73014: PUSH
73015: LD_INT 31
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: LIST
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PPUSH
73031: CALL_OW 69
73035: ST_TO_ADDR
// if not tmp then
73036: LD_VAR 0 6
73040: NOT
73041: IFFALSE 73045
// exit ;
73043: GO 73293
// result := [ ] ;
73045: LD_ADDR_VAR 0 2
73049: PUSH
73050: EMPTY
73051: ST_TO_ADDR
// for i in tmp do
73052: LD_ADDR_VAR 0 3
73056: PUSH
73057: LD_VAR 0 6
73061: PUSH
73062: FOR_IN
73063: IFFALSE 73134
// begin t := UnitsInside ( i ) ;
73065: LD_ADDR_VAR 0 4
73069: PUSH
73070: LD_VAR 0 3
73074: PPUSH
73075: CALL_OW 313
73079: ST_TO_ADDR
// if t then
73080: LD_VAR 0 4
73084: IFFALSE 73132
// for j in t do
73086: LD_ADDR_VAR 0 7
73090: PUSH
73091: LD_VAR 0 4
73095: PUSH
73096: FOR_IN
73097: IFFALSE 73130
// result := Insert ( result , result + 1 , j ) ;
73099: LD_ADDR_VAR 0 2
73103: PUSH
73104: LD_VAR 0 2
73108: PPUSH
73109: LD_VAR 0 2
73113: PUSH
73114: LD_INT 1
73116: PLUS
73117: PPUSH
73118: LD_VAR 0 7
73122: PPUSH
73123: CALL_OW 2
73127: ST_TO_ADDR
73128: GO 73096
73130: POP
73131: POP
// end ;
73132: GO 73062
73134: POP
73135: POP
// if not result then
73136: LD_VAR 0 2
73140: NOT
73141: IFFALSE 73145
// exit ;
73143: GO 73293
// mech := result [ 1 ] ;
73145: LD_ADDR_VAR 0 5
73149: PUSH
73150: LD_VAR 0 2
73154: PUSH
73155: LD_INT 1
73157: ARRAY
73158: ST_TO_ADDR
// if result > 1 then
73159: LD_VAR 0 2
73163: PUSH
73164: LD_INT 1
73166: GREATER
73167: IFFALSE 73279
// for i = 2 to result do
73169: LD_ADDR_VAR 0 3
73173: PUSH
73174: DOUBLE
73175: LD_INT 2
73177: DEC
73178: ST_TO_ADDR
73179: LD_VAR 0 2
73183: PUSH
73184: FOR_TO
73185: IFFALSE 73277
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73187: LD_ADDR_VAR 0 4
73191: PUSH
73192: LD_VAR 0 2
73196: PUSH
73197: LD_VAR 0 3
73201: ARRAY
73202: PPUSH
73203: LD_INT 3
73205: PPUSH
73206: CALL_OW 259
73210: PUSH
73211: LD_VAR 0 2
73215: PUSH
73216: LD_VAR 0 3
73220: ARRAY
73221: PPUSH
73222: CALL_OW 432
73226: MINUS
73227: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73228: LD_VAR 0 4
73232: PUSH
73233: LD_VAR 0 5
73237: PPUSH
73238: LD_INT 3
73240: PPUSH
73241: CALL_OW 259
73245: PUSH
73246: LD_VAR 0 5
73250: PPUSH
73251: CALL_OW 432
73255: MINUS
73256: GREATEREQUAL
73257: IFFALSE 73275
// mech := result [ i ] ;
73259: LD_ADDR_VAR 0 5
73263: PUSH
73264: LD_VAR 0 2
73268: PUSH
73269: LD_VAR 0 3
73273: ARRAY
73274: ST_TO_ADDR
// end ;
73275: GO 73184
73277: POP
73278: POP
// ComLinkTo ( vehicle , mech ) ;
73279: LD_VAR 0 1
73283: PPUSH
73284: LD_VAR 0 5
73288: PPUSH
73289: CALL_OW 135
// end ;
73293: LD_VAR 0 2
73297: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73298: LD_INT 0
73300: PPUSH
73301: PPUSH
73302: PPUSH
73303: PPUSH
73304: PPUSH
73305: PPUSH
73306: PPUSH
73307: PPUSH
73308: PPUSH
73309: PPUSH
73310: PPUSH
73311: PPUSH
73312: PPUSH
// result := [ ] ;
73313: LD_ADDR_VAR 0 7
73317: PUSH
73318: EMPTY
73319: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73320: LD_VAR 0 1
73324: PPUSH
73325: CALL_OW 266
73329: PUSH
73330: LD_INT 0
73332: PUSH
73333: LD_INT 1
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: IN
73340: NOT
73341: IFFALSE 73345
// exit ;
73343: GO 74976
// if name then
73345: LD_VAR 0 3
73349: IFFALSE 73365
// SetBName ( base_dep , name ) ;
73351: LD_VAR 0 1
73355: PPUSH
73356: LD_VAR 0 3
73360: PPUSH
73361: CALL_OW 500
// base := GetBase ( base_dep ) ;
73365: LD_ADDR_VAR 0 15
73369: PUSH
73370: LD_VAR 0 1
73374: PPUSH
73375: CALL_OW 274
73379: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73380: LD_ADDR_VAR 0 16
73384: PUSH
73385: LD_VAR 0 1
73389: PPUSH
73390: CALL_OW 255
73394: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73395: LD_ADDR_VAR 0 17
73399: PUSH
73400: LD_VAR 0 1
73404: PPUSH
73405: CALL_OW 248
73409: ST_TO_ADDR
// if sources then
73410: LD_VAR 0 5
73414: IFFALSE 73461
// for i = 1 to 3 do
73416: LD_ADDR_VAR 0 8
73420: PUSH
73421: DOUBLE
73422: LD_INT 1
73424: DEC
73425: ST_TO_ADDR
73426: LD_INT 3
73428: PUSH
73429: FOR_TO
73430: IFFALSE 73459
// AddResourceType ( base , i , sources [ i ] ) ;
73432: LD_VAR 0 15
73436: PPUSH
73437: LD_VAR 0 8
73441: PPUSH
73442: LD_VAR 0 5
73446: PUSH
73447: LD_VAR 0 8
73451: ARRAY
73452: PPUSH
73453: CALL_OW 276
73457: GO 73429
73459: POP
73460: POP
// buildings := GetBaseBuildings ( base , area ) ;
73461: LD_ADDR_VAR 0 18
73465: PUSH
73466: LD_VAR 0 15
73470: PPUSH
73471: LD_VAR 0 2
73475: PPUSH
73476: CALL 72753 0 2
73480: ST_TO_ADDR
// InitHc ;
73481: CALL_OW 19
// InitUc ;
73485: CALL_OW 18
// uc_side := side ;
73489: LD_ADDR_OWVAR 20
73493: PUSH
73494: LD_VAR 0 16
73498: ST_TO_ADDR
// uc_nation := nation ;
73499: LD_ADDR_OWVAR 21
73503: PUSH
73504: LD_VAR 0 17
73508: ST_TO_ADDR
// if buildings then
73509: LD_VAR 0 18
73513: IFFALSE 74835
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73515: LD_ADDR_VAR 0 19
73519: PUSH
73520: LD_VAR 0 18
73524: PPUSH
73525: LD_INT 2
73527: PUSH
73528: LD_INT 30
73530: PUSH
73531: LD_INT 29
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 30
73540: PUSH
73541: LD_INT 30
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: LIST
73552: PPUSH
73553: CALL_OW 72
73557: ST_TO_ADDR
// if tmp then
73558: LD_VAR 0 19
73562: IFFALSE 73610
// for i in tmp do
73564: LD_ADDR_VAR 0 8
73568: PUSH
73569: LD_VAR 0 19
73573: PUSH
73574: FOR_IN
73575: IFFALSE 73608
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73577: LD_VAR 0 8
73581: PPUSH
73582: CALL_OW 250
73586: PPUSH
73587: LD_VAR 0 8
73591: PPUSH
73592: CALL_OW 251
73596: PPUSH
73597: LD_VAR 0 16
73601: PPUSH
73602: CALL_OW 441
73606: GO 73574
73608: POP
73609: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73610: LD_VAR 0 18
73614: PPUSH
73615: LD_INT 2
73617: PUSH
73618: LD_INT 30
73620: PUSH
73621: LD_INT 32
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 30
73630: PUSH
73631: LD_INT 33
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: LIST
73642: PPUSH
73643: CALL_OW 72
73647: IFFALSE 73735
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73649: LD_ADDR_VAR 0 8
73653: PUSH
73654: LD_VAR 0 18
73658: PPUSH
73659: LD_INT 2
73661: PUSH
73662: LD_INT 30
73664: PUSH
73665: LD_INT 32
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 30
73674: PUSH
73675: LD_INT 33
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: LIST
73686: PPUSH
73687: CALL_OW 72
73691: PUSH
73692: FOR_IN
73693: IFFALSE 73733
// begin if not GetBWeapon ( i ) then
73695: LD_VAR 0 8
73699: PPUSH
73700: CALL_OW 269
73704: NOT
73705: IFFALSE 73731
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73707: LD_VAR 0 8
73711: PPUSH
73712: LD_VAR 0 8
73716: PPUSH
73717: LD_VAR 0 2
73721: PPUSH
73722: CALL 74981 0 2
73726: PPUSH
73727: CALL_OW 431
// end ;
73731: GO 73692
73733: POP
73734: POP
// end ; for i = 1 to personel do
73735: LD_ADDR_VAR 0 8
73739: PUSH
73740: DOUBLE
73741: LD_INT 1
73743: DEC
73744: ST_TO_ADDR
73745: LD_VAR 0 6
73749: PUSH
73750: FOR_TO
73751: IFFALSE 74815
// begin if i > 4 then
73753: LD_VAR 0 8
73757: PUSH
73758: LD_INT 4
73760: GREATER
73761: IFFALSE 73765
// break ;
73763: GO 74815
// case i of 1 :
73765: LD_VAR 0 8
73769: PUSH
73770: LD_INT 1
73772: DOUBLE
73773: EQUAL
73774: IFTRUE 73778
73776: GO 73858
73778: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73779: LD_ADDR_VAR 0 12
73783: PUSH
73784: LD_VAR 0 18
73788: PPUSH
73789: LD_INT 22
73791: PUSH
73792: LD_VAR 0 16
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 58
73803: PUSH
73804: EMPTY
73805: LIST
73806: PUSH
73807: LD_INT 2
73809: PUSH
73810: LD_INT 30
73812: PUSH
73813: LD_INT 32
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: PUSH
73820: LD_INT 30
73822: PUSH
73823: LD_INT 4
73825: PUSH
73826: EMPTY
73827: LIST
73828: LIST
73829: PUSH
73830: LD_INT 30
73832: PUSH
73833: LD_INT 5
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: LIST
73850: PPUSH
73851: CALL_OW 72
73855: ST_TO_ADDR
73856: GO 74080
73858: LD_INT 2
73860: DOUBLE
73861: EQUAL
73862: IFTRUE 73866
73864: GO 73928
73866: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73867: LD_ADDR_VAR 0 12
73871: PUSH
73872: LD_VAR 0 18
73876: PPUSH
73877: LD_INT 22
73879: PUSH
73880: LD_VAR 0 16
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 2
73891: PUSH
73892: LD_INT 30
73894: PUSH
73895: LD_INT 0
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 30
73904: PUSH
73905: LD_INT 1
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: LIST
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PPUSH
73921: CALL_OW 72
73925: ST_TO_ADDR
73926: GO 74080
73928: LD_INT 3
73930: DOUBLE
73931: EQUAL
73932: IFTRUE 73936
73934: GO 73998
73936: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73937: LD_ADDR_VAR 0 12
73941: PUSH
73942: LD_VAR 0 18
73946: PPUSH
73947: LD_INT 22
73949: PUSH
73950: LD_VAR 0 16
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: LD_INT 2
73961: PUSH
73962: LD_INT 30
73964: PUSH
73965: LD_INT 2
73967: PUSH
73968: EMPTY
73969: LIST
73970: LIST
73971: PUSH
73972: LD_INT 30
73974: PUSH
73975: LD_INT 3
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: LIST
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PPUSH
73991: CALL_OW 72
73995: ST_TO_ADDR
73996: GO 74080
73998: LD_INT 4
74000: DOUBLE
74001: EQUAL
74002: IFTRUE 74006
74004: GO 74079
74006: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74007: LD_ADDR_VAR 0 12
74011: PUSH
74012: LD_VAR 0 18
74016: PPUSH
74017: LD_INT 22
74019: PUSH
74020: LD_VAR 0 16
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 2
74031: PUSH
74032: LD_INT 30
74034: PUSH
74035: LD_INT 6
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 30
74044: PUSH
74045: LD_INT 7
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 30
74054: PUSH
74055: LD_INT 8
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PPUSH
74072: CALL_OW 72
74076: ST_TO_ADDR
74077: GO 74080
74079: POP
// if i = 1 then
74080: LD_VAR 0 8
74084: PUSH
74085: LD_INT 1
74087: EQUAL
74088: IFFALSE 74199
// begin tmp := [ ] ;
74090: LD_ADDR_VAR 0 19
74094: PUSH
74095: EMPTY
74096: ST_TO_ADDR
// for j in f do
74097: LD_ADDR_VAR 0 9
74101: PUSH
74102: LD_VAR 0 12
74106: PUSH
74107: FOR_IN
74108: IFFALSE 74181
// if GetBType ( j ) = b_bunker then
74110: LD_VAR 0 9
74114: PPUSH
74115: CALL_OW 266
74119: PUSH
74120: LD_INT 32
74122: EQUAL
74123: IFFALSE 74150
// tmp := Insert ( tmp , 1 , j ) else
74125: LD_ADDR_VAR 0 19
74129: PUSH
74130: LD_VAR 0 19
74134: PPUSH
74135: LD_INT 1
74137: PPUSH
74138: LD_VAR 0 9
74142: PPUSH
74143: CALL_OW 2
74147: ST_TO_ADDR
74148: GO 74179
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74150: LD_ADDR_VAR 0 19
74154: PUSH
74155: LD_VAR 0 19
74159: PPUSH
74160: LD_VAR 0 19
74164: PUSH
74165: LD_INT 1
74167: PLUS
74168: PPUSH
74169: LD_VAR 0 9
74173: PPUSH
74174: CALL_OW 2
74178: ST_TO_ADDR
74179: GO 74107
74181: POP
74182: POP
// if tmp then
74183: LD_VAR 0 19
74187: IFFALSE 74199
// f := tmp ;
74189: LD_ADDR_VAR 0 12
74193: PUSH
74194: LD_VAR 0 19
74198: ST_TO_ADDR
// end ; x := personel [ i ] ;
74199: LD_ADDR_VAR 0 13
74203: PUSH
74204: LD_VAR 0 6
74208: PUSH
74209: LD_VAR 0 8
74213: ARRAY
74214: ST_TO_ADDR
// if x = - 1 then
74215: LD_VAR 0 13
74219: PUSH
74220: LD_INT 1
74222: NEG
74223: EQUAL
74224: IFFALSE 74433
// begin for j in f do
74226: LD_ADDR_VAR 0 9
74230: PUSH
74231: LD_VAR 0 12
74235: PUSH
74236: FOR_IN
74237: IFFALSE 74429
// repeat InitHc ;
74239: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74243: LD_VAR 0 9
74247: PPUSH
74248: CALL_OW 266
74252: PUSH
74253: LD_INT 5
74255: EQUAL
74256: IFFALSE 74326
// begin if UnitsInside ( j ) < 3 then
74258: LD_VAR 0 9
74262: PPUSH
74263: CALL_OW 313
74267: PUSH
74268: LD_INT 3
74270: LESS
74271: IFFALSE 74307
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74273: LD_INT 0
74275: PPUSH
74276: LD_INT 5
74278: PUSH
74279: LD_INT 8
74281: PUSH
74282: LD_INT 9
74284: PUSH
74285: EMPTY
74286: LIST
74287: LIST
74288: LIST
74289: PUSH
74290: LD_VAR 0 17
74294: ARRAY
74295: PPUSH
74296: LD_VAR 0 4
74300: PPUSH
74301: CALL_OW 380
74305: GO 74324
// PrepareHuman ( false , i , skill ) ;
74307: LD_INT 0
74309: PPUSH
74310: LD_VAR 0 8
74314: PPUSH
74315: LD_VAR 0 4
74319: PPUSH
74320: CALL_OW 380
// end else
74324: GO 74343
// PrepareHuman ( false , i , skill ) ;
74326: LD_INT 0
74328: PPUSH
74329: LD_VAR 0 8
74333: PPUSH
74334: LD_VAR 0 4
74338: PPUSH
74339: CALL_OW 380
// un := CreateHuman ;
74343: LD_ADDR_VAR 0 14
74347: PUSH
74348: CALL_OW 44
74352: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74353: LD_ADDR_VAR 0 7
74357: PUSH
74358: LD_VAR 0 7
74362: PPUSH
74363: LD_INT 1
74365: PPUSH
74366: LD_VAR 0 14
74370: PPUSH
74371: CALL_OW 2
74375: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74376: LD_VAR 0 14
74380: PPUSH
74381: LD_VAR 0 9
74385: PPUSH
74386: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74390: LD_VAR 0 9
74394: PPUSH
74395: CALL_OW 313
74399: PUSH
74400: LD_INT 6
74402: EQUAL
74403: PUSH
74404: LD_VAR 0 9
74408: PPUSH
74409: CALL_OW 266
74413: PUSH
74414: LD_INT 32
74416: PUSH
74417: LD_INT 31
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: IN
74424: OR
74425: IFFALSE 74239
74427: GO 74236
74429: POP
74430: POP
// end else
74431: GO 74813
// for j = 1 to x do
74433: LD_ADDR_VAR 0 9
74437: PUSH
74438: DOUBLE
74439: LD_INT 1
74441: DEC
74442: ST_TO_ADDR
74443: LD_VAR 0 13
74447: PUSH
74448: FOR_TO
74449: IFFALSE 74811
// begin InitHc ;
74451: CALL_OW 19
// if not f then
74455: LD_VAR 0 12
74459: NOT
74460: IFFALSE 74549
// begin PrepareHuman ( false , i , skill ) ;
74462: LD_INT 0
74464: PPUSH
74465: LD_VAR 0 8
74469: PPUSH
74470: LD_VAR 0 4
74474: PPUSH
74475: CALL_OW 380
// un := CreateHuman ;
74479: LD_ADDR_VAR 0 14
74483: PUSH
74484: CALL_OW 44
74488: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74489: LD_ADDR_VAR 0 7
74493: PUSH
74494: LD_VAR 0 7
74498: PPUSH
74499: LD_INT 1
74501: PPUSH
74502: LD_VAR 0 14
74506: PPUSH
74507: CALL_OW 2
74511: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74512: LD_VAR 0 14
74516: PPUSH
74517: LD_VAR 0 1
74521: PPUSH
74522: CALL_OW 250
74526: PPUSH
74527: LD_VAR 0 1
74531: PPUSH
74532: CALL_OW 251
74536: PPUSH
74537: LD_INT 10
74539: PPUSH
74540: LD_INT 0
74542: PPUSH
74543: CALL_OW 50
// continue ;
74547: GO 74448
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74549: LD_VAR 0 12
74553: PUSH
74554: LD_INT 1
74556: ARRAY
74557: PPUSH
74558: CALL_OW 313
74562: PUSH
74563: LD_VAR 0 12
74567: PUSH
74568: LD_INT 1
74570: ARRAY
74571: PPUSH
74572: CALL_OW 266
74576: PUSH
74577: LD_INT 32
74579: PUSH
74580: LD_INT 31
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: IN
74587: AND
74588: PUSH
74589: LD_VAR 0 12
74593: PUSH
74594: LD_INT 1
74596: ARRAY
74597: PPUSH
74598: CALL_OW 313
74602: PUSH
74603: LD_INT 6
74605: EQUAL
74606: OR
74607: IFFALSE 74627
// f := Delete ( f , 1 ) ;
74609: LD_ADDR_VAR 0 12
74613: PUSH
74614: LD_VAR 0 12
74618: PPUSH
74619: LD_INT 1
74621: PPUSH
74622: CALL_OW 3
74626: ST_TO_ADDR
// if not f then
74627: LD_VAR 0 12
74631: NOT
74632: IFFALSE 74650
// begin x := x + 2 ;
74634: LD_ADDR_VAR 0 13
74638: PUSH
74639: LD_VAR 0 13
74643: PUSH
74644: LD_INT 2
74646: PLUS
74647: ST_TO_ADDR
// continue ;
74648: GO 74448
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74650: LD_VAR 0 12
74654: PUSH
74655: LD_INT 1
74657: ARRAY
74658: PPUSH
74659: CALL_OW 266
74663: PUSH
74664: LD_INT 5
74666: EQUAL
74667: IFFALSE 74741
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74669: LD_VAR 0 12
74673: PUSH
74674: LD_INT 1
74676: ARRAY
74677: PPUSH
74678: CALL_OW 313
74682: PUSH
74683: LD_INT 3
74685: LESS
74686: IFFALSE 74722
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74688: LD_INT 0
74690: PPUSH
74691: LD_INT 5
74693: PUSH
74694: LD_INT 8
74696: PUSH
74697: LD_INT 9
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: LIST
74704: PUSH
74705: LD_VAR 0 17
74709: ARRAY
74710: PPUSH
74711: LD_VAR 0 4
74715: PPUSH
74716: CALL_OW 380
74720: GO 74739
// PrepareHuman ( false , i , skill ) ;
74722: LD_INT 0
74724: PPUSH
74725: LD_VAR 0 8
74729: PPUSH
74730: LD_VAR 0 4
74734: PPUSH
74735: CALL_OW 380
// end else
74739: GO 74758
// PrepareHuman ( false , i , skill ) ;
74741: LD_INT 0
74743: PPUSH
74744: LD_VAR 0 8
74748: PPUSH
74749: LD_VAR 0 4
74753: PPUSH
74754: CALL_OW 380
// un := CreateHuman ;
74758: LD_ADDR_VAR 0 14
74762: PUSH
74763: CALL_OW 44
74767: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74768: LD_ADDR_VAR 0 7
74772: PUSH
74773: LD_VAR 0 7
74777: PPUSH
74778: LD_INT 1
74780: PPUSH
74781: LD_VAR 0 14
74785: PPUSH
74786: CALL_OW 2
74790: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74791: LD_VAR 0 14
74795: PPUSH
74796: LD_VAR 0 12
74800: PUSH
74801: LD_INT 1
74803: ARRAY
74804: PPUSH
74805: CALL_OW 52
// end ;
74809: GO 74448
74811: POP
74812: POP
// end ;
74813: GO 73750
74815: POP
74816: POP
// result := result ^ buildings ;
74817: LD_ADDR_VAR 0 7
74821: PUSH
74822: LD_VAR 0 7
74826: PUSH
74827: LD_VAR 0 18
74831: ADD
74832: ST_TO_ADDR
// end else
74833: GO 74976
// begin for i = 1 to personel do
74835: LD_ADDR_VAR 0 8
74839: PUSH
74840: DOUBLE
74841: LD_INT 1
74843: DEC
74844: ST_TO_ADDR
74845: LD_VAR 0 6
74849: PUSH
74850: FOR_TO
74851: IFFALSE 74974
// begin if i > 4 then
74853: LD_VAR 0 8
74857: PUSH
74858: LD_INT 4
74860: GREATER
74861: IFFALSE 74865
// break ;
74863: GO 74974
// x := personel [ i ] ;
74865: LD_ADDR_VAR 0 13
74869: PUSH
74870: LD_VAR 0 6
74874: PUSH
74875: LD_VAR 0 8
74879: ARRAY
74880: ST_TO_ADDR
// if x = - 1 then
74881: LD_VAR 0 13
74885: PUSH
74886: LD_INT 1
74888: NEG
74889: EQUAL
74890: IFFALSE 74894
// continue ;
74892: GO 74850
// PrepareHuman ( false , i , skill ) ;
74894: LD_INT 0
74896: PPUSH
74897: LD_VAR 0 8
74901: PPUSH
74902: LD_VAR 0 4
74906: PPUSH
74907: CALL_OW 380
// un := CreateHuman ;
74911: LD_ADDR_VAR 0 14
74915: PUSH
74916: CALL_OW 44
74920: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74921: LD_VAR 0 14
74925: PPUSH
74926: LD_VAR 0 1
74930: PPUSH
74931: CALL_OW 250
74935: PPUSH
74936: LD_VAR 0 1
74940: PPUSH
74941: CALL_OW 251
74945: PPUSH
74946: LD_INT 10
74948: PPUSH
74949: LD_INT 0
74951: PPUSH
74952: CALL_OW 50
// result := result ^ un ;
74956: LD_ADDR_VAR 0 7
74960: PUSH
74961: LD_VAR 0 7
74965: PUSH
74966: LD_VAR 0 14
74970: ADD
74971: ST_TO_ADDR
// end ;
74972: GO 74850
74974: POP
74975: POP
// end ; end ;
74976: LD_VAR 0 7
74980: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74981: LD_INT 0
74983: PPUSH
74984: PPUSH
74985: PPUSH
74986: PPUSH
74987: PPUSH
74988: PPUSH
74989: PPUSH
74990: PPUSH
74991: PPUSH
74992: PPUSH
74993: PPUSH
74994: PPUSH
74995: PPUSH
74996: PPUSH
74997: PPUSH
74998: PPUSH
// result := false ;
74999: LD_ADDR_VAR 0 3
75003: PUSH
75004: LD_INT 0
75006: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75007: LD_VAR 0 1
75011: NOT
75012: PUSH
75013: LD_VAR 0 1
75017: PPUSH
75018: CALL_OW 266
75022: PUSH
75023: LD_INT 32
75025: PUSH
75026: LD_INT 33
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: IN
75033: NOT
75034: OR
75035: IFFALSE 75039
// exit ;
75037: GO 76175
// nat := GetNation ( tower ) ;
75039: LD_ADDR_VAR 0 12
75043: PUSH
75044: LD_VAR 0 1
75048: PPUSH
75049: CALL_OW 248
75053: ST_TO_ADDR
// side := GetSide ( tower ) ;
75054: LD_ADDR_VAR 0 16
75058: PUSH
75059: LD_VAR 0 1
75063: PPUSH
75064: CALL_OW 255
75068: ST_TO_ADDR
// x := GetX ( tower ) ;
75069: LD_ADDR_VAR 0 10
75073: PUSH
75074: LD_VAR 0 1
75078: PPUSH
75079: CALL_OW 250
75083: ST_TO_ADDR
// y := GetY ( tower ) ;
75084: LD_ADDR_VAR 0 11
75088: PUSH
75089: LD_VAR 0 1
75093: PPUSH
75094: CALL_OW 251
75098: ST_TO_ADDR
// if not x or not y then
75099: LD_VAR 0 10
75103: NOT
75104: PUSH
75105: LD_VAR 0 11
75109: NOT
75110: OR
75111: IFFALSE 75115
// exit ;
75113: GO 76175
// weapon := 0 ;
75115: LD_ADDR_VAR 0 18
75119: PUSH
75120: LD_INT 0
75122: ST_TO_ADDR
// fac_list := [ ] ;
75123: LD_ADDR_VAR 0 17
75127: PUSH
75128: EMPTY
75129: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75130: LD_ADDR_VAR 0 6
75134: PUSH
75135: LD_VAR 0 1
75139: PPUSH
75140: CALL_OW 274
75144: PPUSH
75145: LD_VAR 0 2
75149: PPUSH
75150: CALL 72753 0 2
75154: PPUSH
75155: LD_INT 30
75157: PUSH
75158: LD_INT 3
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PPUSH
75165: CALL_OW 72
75169: ST_TO_ADDR
// if not factories then
75170: LD_VAR 0 6
75174: NOT
75175: IFFALSE 75179
// exit ;
75177: GO 76175
// for i in factories do
75179: LD_ADDR_VAR 0 8
75183: PUSH
75184: LD_VAR 0 6
75188: PUSH
75189: FOR_IN
75190: IFFALSE 75215
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75192: LD_ADDR_VAR 0 17
75196: PUSH
75197: LD_VAR 0 17
75201: PUSH
75202: LD_VAR 0 8
75206: PPUSH
75207: CALL_OW 478
75211: UNION
75212: ST_TO_ADDR
75213: GO 75189
75215: POP
75216: POP
// if not fac_list then
75217: LD_VAR 0 17
75221: NOT
75222: IFFALSE 75226
// exit ;
75224: GO 76175
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75226: LD_ADDR_VAR 0 5
75230: PUSH
75231: LD_INT 4
75233: PUSH
75234: LD_INT 5
75236: PUSH
75237: LD_INT 9
75239: PUSH
75240: LD_INT 10
75242: PUSH
75243: LD_INT 6
75245: PUSH
75246: LD_INT 7
75248: PUSH
75249: LD_INT 11
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: LIST
75256: LIST
75257: LIST
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 27
75263: PUSH
75264: LD_INT 28
75266: PUSH
75267: LD_INT 26
75269: PUSH
75270: LD_INT 30
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 43
75281: PUSH
75282: LD_INT 44
75284: PUSH
75285: LD_INT 46
75287: PUSH
75288: LD_INT 45
75290: PUSH
75291: LD_INT 47
75293: PUSH
75294: LD_INT 49
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: LIST
75301: LIST
75302: LIST
75303: LIST
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: LIST
75309: PUSH
75310: LD_VAR 0 12
75314: ARRAY
75315: ST_TO_ADDR
// for i in list do
75316: LD_ADDR_VAR 0 8
75320: PUSH
75321: LD_VAR 0 5
75325: PUSH
75326: FOR_IN
75327: IFFALSE 75360
// if not i in fac_list then
75329: LD_VAR 0 8
75333: PUSH
75334: LD_VAR 0 17
75338: IN
75339: NOT
75340: IFFALSE 75358
// list := list diff i ;
75342: LD_ADDR_VAR 0 5
75346: PUSH
75347: LD_VAR 0 5
75351: PUSH
75352: LD_VAR 0 8
75356: DIFF
75357: ST_TO_ADDR
75358: GO 75326
75360: POP
75361: POP
// if not list then
75362: LD_VAR 0 5
75366: NOT
75367: IFFALSE 75371
// exit ;
75369: GO 76175
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75371: LD_VAR 0 12
75375: PUSH
75376: LD_INT 3
75378: EQUAL
75379: PUSH
75380: LD_INT 49
75382: PUSH
75383: LD_VAR 0 5
75387: IN
75388: AND
75389: PUSH
75390: LD_INT 31
75392: PPUSH
75393: LD_VAR 0 16
75397: PPUSH
75398: CALL_OW 321
75402: PUSH
75403: LD_INT 2
75405: EQUAL
75406: AND
75407: IFFALSE 75467
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75409: LD_INT 22
75411: PUSH
75412: LD_VAR 0 16
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 35
75423: PUSH
75424: LD_INT 49
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 91
75433: PUSH
75434: LD_VAR 0 1
75438: PUSH
75439: LD_INT 10
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: LIST
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: LIST
75451: PPUSH
75452: CALL_OW 69
75456: NOT
75457: IFFALSE 75467
// weapon := ru_time_lapser ;
75459: LD_ADDR_VAR 0 18
75463: PUSH
75464: LD_INT 49
75466: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75467: LD_VAR 0 12
75471: PUSH
75472: LD_INT 1
75474: PUSH
75475: LD_INT 2
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: IN
75482: PUSH
75483: LD_INT 11
75485: PUSH
75486: LD_VAR 0 5
75490: IN
75491: PUSH
75492: LD_INT 30
75494: PUSH
75495: LD_VAR 0 5
75499: IN
75500: OR
75501: AND
75502: PUSH
75503: LD_INT 6
75505: PPUSH
75506: LD_VAR 0 16
75510: PPUSH
75511: CALL_OW 321
75515: PUSH
75516: LD_INT 2
75518: EQUAL
75519: AND
75520: IFFALSE 75685
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75522: LD_INT 22
75524: PUSH
75525: LD_VAR 0 16
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 2
75536: PUSH
75537: LD_INT 35
75539: PUSH
75540: LD_INT 11
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: LD_INT 35
75549: PUSH
75550: LD_INT 30
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 91
75564: PUSH
75565: LD_VAR 0 1
75569: PUSH
75570: LD_INT 18
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: LIST
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: LIST
75582: PPUSH
75583: CALL_OW 69
75587: NOT
75588: PUSH
75589: LD_INT 22
75591: PUSH
75592: LD_VAR 0 16
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 2
75603: PUSH
75604: LD_INT 30
75606: PUSH
75607: LD_INT 32
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 30
75616: PUSH
75617: LD_INT 33
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 91
75631: PUSH
75632: LD_VAR 0 1
75636: PUSH
75637: LD_INT 12
75639: PUSH
75640: EMPTY
75641: LIST
75642: LIST
75643: LIST
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: LIST
75649: PUSH
75650: EMPTY
75651: LIST
75652: PPUSH
75653: CALL_OW 69
75657: PUSH
75658: LD_INT 2
75660: GREATER
75661: AND
75662: IFFALSE 75685
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75664: LD_ADDR_VAR 0 18
75668: PUSH
75669: LD_INT 11
75671: PUSH
75672: LD_INT 30
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_VAR 0 12
75683: ARRAY
75684: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75685: LD_VAR 0 18
75689: NOT
75690: PUSH
75691: LD_INT 40
75693: PPUSH
75694: LD_VAR 0 16
75698: PPUSH
75699: CALL_OW 321
75703: PUSH
75704: LD_INT 2
75706: EQUAL
75707: AND
75708: PUSH
75709: LD_INT 7
75711: PUSH
75712: LD_VAR 0 5
75716: IN
75717: PUSH
75718: LD_INT 28
75720: PUSH
75721: LD_VAR 0 5
75725: IN
75726: OR
75727: PUSH
75728: LD_INT 45
75730: PUSH
75731: LD_VAR 0 5
75735: IN
75736: OR
75737: AND
75738: IFFALSE 75992
// begin hex := GetHexInfo ( x , y ) ;
75740: LD_ADDR_VAR 0 4
75744: PUSH
75745: LD_VAR 0 10
75749: PPUSH
75750: LD_VAR 0 11
75754: PPUSH
75755: CALL_OW 546
75759: ST_TO_ADDR
// if hex [ 1 ] then
75760: LD_VAR 0 4
75764: PUSH
75765: LD_INT 1
75767: ARRAY
75768: IFFALSE 75772
// exit ;
75770: GO 76175
// height := hex [ 2 ] ;
75772: LD_ADDR_VAR 0 15
75776: PUSH
75777: LD_VAR 0 4
75781: PUSH
75782: LD_INT 2
75784: ARRAY
75785: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75786: LD_ADDR_VAR 0 14
75790: PUSH
75791: LD_INT 0
75793: PUSH
75794: LD_INT 2
75796: PUSH
75797: LD_INT 3
75799: PUSH
75800: LD_INT 5
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: ST_TO_ADDR
// for i in tmp do
75809: LD_ADDR_VAR 0 8
75813: PUSH
75814: LD_VAR 0 14
75818: PUSH
75819: FOR_IN
75820: IFFALSE 75990
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75822: LD_ADDR_VAR 0 9
75826: PUSH
75827: LD_VAR 0 10
75831: PPUSH
75832: LD_VAR 0 8
75836: PPUSH
75837: LD_INT 5
75839: PPUSH
75840: CALL_OW 272
75844: PUSH
75845: LD_VAR 0 11
75849: PPUSH
75850: LD_VAR 0 8
75854: PPUSH
75855: LD_INT 5
75857: PPUSH
75858: CALL_OW 273
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75867: LD_VAR 0 9
75871: PUSH
75872: LD_INT 1
75874: ARRAY
75875: PPUSH
75876: LD_VAR 0 9
75880: PUSH
75881: LD_INT 2
75883: ARRAY
75884: PPUSH
75885: CALL_OW 488
75889: IFFALSE 75988
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75891: LD_ADDR_VAR 0 4
75895: PUSH
75896: LD_VAR 0 9
75900: PUSH
75901: LD_INT 1
75903: ARRAY
75904: PPUSH
75905: LD_VAR 0 9
75909: PUSH
75910: LD_INT 2
75912: ARRAY
75913: PPUSH
75914: CALL_OW 546
75918: ST_TO_ADDR
// if hex [ 1 ] then
75919: LD_VAR 0 4
75923: PUSH
75924: LD_INT 1
75926: ARRAY
75927: IFFALSE 75931
// continue ;
75929: GO 75819
// h := hex [ 2 ] ;
75931: LD_ADDR_VAR 0 13
75935: PUSH
75936: LD_VAR 0 4
75940: PUSH
75941: LD_INT 2
75943: ARRAY
75944: ST_TO_ADDR
// if h + 7 < height then
75945: LD_VAR 0 13
75949: PUSH
75950: LD_INT 7
75952: PLUS
75953: PUSH
75954: LD_VAR 0 15
75958: LESS
75959: IFFALSE 75988
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75961: LD_ADDR_VAR 0 18
75965: PUSH
75966: LD_INT 7
75968: PUSH
75969: LD_INT 28
75971: PUSH
75972: LD_INT 45
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: LIST
75979: PUSH
75980: LD_VAR 0 12
75984: ARRAY
75985: ST_TO_ADDR
// break ;
75986: GO 75990
// end ; end ; end ;
75988: GO 75819
75990: POP
75991: POP
// end ; if not weapon then
75992: LD_VAR 0 18
75996: NOT
75997: IFFALSE 76057
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75999: LD_ADDR_VAR 0 5
76003: PUSH
76004: LD_VAR 0 5
76008: PUSH
76009: LD_INT 11
76011: PUSH
76012: LD_INT 30
76014: PUSH
76015: LD_INT 49
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: LIST
76022: DIFF
76023: ST_TO_ADDR
// if not list then
76024: LD_VAR 0 5
76028: NOT
76029: IFFALSE 76033
// exit ;
76031: GO 76175
// weapon := list [ rand ( 1 , list ) ] ;
76033: LD_ADDR_VAR 0 18
76037: PUSH
76038: LD_VAR 0 5
76042: PUSH
76043: LD_INT 1
76045: PPUSH
76046: LD_VAR 0 5
76050: PPUSH
76051: CALL_OW 12
76055: ARRAY
76056: ST_TO_ADDR
// end ; if weapon then
76057: LD_VAR 0 18
76061: IFFALSE 76175
// begin tmp := CostOfWeapon ( weapon ) ;
76063: LD_ADDR_VAR 0 14
76067: PUSH
76068: LD_VAR 0 18
76072: PPUSH
76073: CALL_OW 451
76077: ST_TO_ADDR
// j := GetBase ( tower ) ;
76078: LD_ADDR_VAR 0 9
76082: PUSH
76083: LD_VAR 0 1
76087: PPUSH
76088: CALL_OW 274
76092: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76093: LD_VAR 0 9
76097: PPUSH
76098: LD_INT 1
76100: PPUSH
76101: CALL_OW 275
76105: PUSH
76106: LD_VAR 0 14
76110: PUSH
76111: LD_INT 1
76113: ARRAY
76114: GREATEREQUAL
76115: PUSH
76116: LD_VAR 0 9
76120: PPUSH
76121: LD_INT 2
76123: PPUSH
76124: CALL_OW 275
76128: PUSH
76129: LD_VAR 0 14
76133: PUSH
76134: LD_INT 2
76136: ARRAY
76137: GREATEREQUAL
76138: AND
76139: PUSH
76140: LD_VAR 0 9
76144: PPUSH
76145: LD_INT 3
76147: PPUSH
76148: CALL_OW 275
76152: PUSH
76153: LD_VAR 0 14
76157: PUSH
76158: LD_INT 3
76160: ARRAY
76161: GREATEREQUAL
76162: AND
76163: IFFALSE 76175
// result := weapon ;
76165: LD_ADDR_VAR 0 3
76169: PUSH
76170: LD_VAR 0 18
76174: ST_TO_ADDR
// end ; end ;
76175: LD_VAR 0 3
76179: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76180: LD_INT 0
76182: PPUSH
76183: PPUSH
// result := true ;
76184: LD_ADDR_VAR 0 3
76188: PUSH
76189: LD_INT 1
76191: ST_TO_ADDR
// if array1 = array2 then
76192: LD_VAR 0 1
76196: PUSH
76197: LD_VAR 0 2
76201: EQUAL
76202: IFFALSE 76262
// begin for i = 1 to array1 do
76204: LD_ADDR_VAR 0 4
76208: PUSH
76209: DOUBLE
76210: LD_INT 1
76212: DEC
76213: ST_TO_ADDR
76214: LD_VAR 0 1
76218: PUSH
76219: FOR_TO
76220: IFFALSE 76258
// if array1 [ i ] <> array2 [ i ] then
76222: LD_VAR 0 1
76226: PUSH
76227: LD_VAR 0 4
76231: ARRAY
76232: PUSH
76233: LD_VAR 0 2
76237: PUSH
76238: LD_VAR 0 4
76242: ARRAY
76243: NONEQUAL
76244: IFFALSE 76256
// begin result := false ;
76246: LD_ADDR_VAR 0 3
76250: PUSH
76251: LD_INT 0
76253: ST_TO_ADDR
// break ;
76254: GO 76258
// end ;
76256: GO 76219
76258: POP
76259: POP
// end else
76260: GO 76270
// result := false ;
76262: LD_ADDR_VAR 0 3
76266: PUSH
76267: LD_INT 0
76269: ST_TO_ADDR
// end ;
76270: LD_VAR 0 3
76274: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76275: LD_INT 0
76277: PPUSH
76278: PPUSH
76279: PPUSH
// pom := GetBase ( fac ) ;
76280: LD_ADDR_VAR 0 5
76284: PUSH
76285: LD_VAR 0 1
76289: PPUSH
76290: CALL_OW 274
76294: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76295: LD_ADDR_VAR 0 4
76299: PUSH
76300: LD_VAR 0 2
76304: PUSH
76305: LD_INT 1
76307: ARRAY
76308: PPUSH
76309: LD_VAR 0 2
76313: PUSH
76314: LD_INT 2
76316: ARRAY
76317: PPUSH
76318: LD_VAR 0 2
76322: PUSH
76323: LD_INT 3
76325: ARRAY
76326: PPUSH
76327: LD_VAR 0 2
76331: PUSH
76332: LD_INT 4
76334: ARRAY
76335: PPUSH
76336: CALL_OW 449
76340: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76341: LD_ADDR_VAR 0 3
76345: PUSH
76346: LD_VAR 0 5
76350: PPUSH
76351: LD_INT 1
76353: PPUSH
76354: CALL_OW 275
76358: PUSH
76359: LD_VAR 0 4
76363: PUSH
76364: LD_INT 1
76366: ARRAY
76367: GREATEREQUAL
76368: PUSH
76369: LD_VAR 0 5
76373: PPUSH
76374: LD_INT 2
76376: PPUSH
76377: CALL_OW 275
76381: PUSH
76382: LD_VAR 0 4
76386: PUSH
76387: LD_INT 2
76389: ARRAY
76390: GREATEREQUAL
76391: AND
76392: PUSH
76393: LD_VAR 0 5
76397: PPUSH
76398: LD_INT 3
76400: PPUSH
76401: CALL_OW 275
76405: PUSH
76406: LD_VAR 0 4
76410: PUSH
76411: LD_INT 3
76413: ARRAY
76414: GREATEREQUAL
76415: AND
76416: ST_TO_ADDR
// end ;
76417: LD_VAR 0 3
76421: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76422: LD_INT 0
76424: PPUSH
76425: PPUSH
76426: PPUSH
76427: PPUSH
// pom := GetBase ( building ) ;
76428: LD_ADDR_VAR 0 3
76432: PUSH
76433: LD_VAR 0 1
76437: PPUSH
76438: CALL_OW 274
76442: ST_TO_ADDR
// if not pom then
76443: LD_VAR 0 3
76447: NOT
76448: IFFALSE 76452
// exit ;
76450: GO 76622
// btype := GetBType ( building ) ;
76452: LD_ADDR_VAR 0 5
76456: PUSH
76457: LD_VAR 0 1
76461: PPUSH
76462: CALL_OW 266
76466: ST_TO_ADDR
// if btype = b_armoury then
76467: LD_VAR 0 5
76471: PUSH
76472: LD_INT 4
76474: EQUAL
76475: IFFALSE 76485
// btype := b_barracks ;
76477: LD_ADDR_VAR 0 5
76481: PUSH
76482: LD_INT 5
76484: ST_TO_ADDR
// if btype = b_depot then
76485: LD_VAR 0 5
76489: PUSH
76490: LD_INT 0
76492: EQUAL
76493: IFFALSE 76503
// btype := b_warehouse ;
76495: LD_ADDR_VAR 0 5
76499: PUSH
76500: LD_INT 1
76502: ST_TO_ADDR
// if btype = b_workshop then
76503: LD_VAR 0 5
76507: PUSH
76508: LD_INT 2
76510: EQUAL
76511: IFFALSE 76521
// btype := b_factory ;
76513: LD_ADDR_VAR 0 5
76517: PUSH
76518: LD_INT 3
76520: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76521: LD_ADDR_VAR 0 4
76525: PUSH
76526: LD_VAR 0 5
76530: PPUSH
76531: LD_VAR 0 1
76535: PPUSH
76536: CALL_OW 248
76540: PPUSH
76541: CALL_OW 450
76545: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76546: LD_ADDR_VAR 0 2
76550: PUSH
76551: LD_VAR 0 3
76555: PPUSH
76556: LD_INT 1
76558: PPUSH
76559: CALL_OW 275
76563: PUSH
76564: LD_VAR 0 4
76568: PUSH
76569: LD_INT 1
76571: ARRAY
76572: GREATEREQUAL
76573: PUSH
76574: LD_VAR 0 3
76578: PPUSH
76579: LD_INT 2
76581: PPUSH
76582: CALL_OW 275
76586: PUSH
76587: LD_VAR 0 4
76591: PUSH
76592: LD_INT 2
76594: ARRAY
76595: GREATEREQUAL
76596: AND
76597: PUSH
76598: LD_VAR 0 3
76602: PPUSH
76603: LD_INT 3
76605: PPUSH
76606: CALL_OW 275
76610: PUSH
76611: LD_VAR 0 4
76615: PUSH
76616: LD_INT 3
76618: ARRAY
76619: GREATEREQUAL
76620: AND
76621: ST_TO_ADDR
// end ;
76622: LD_VAR 0 2
76626: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76627: LD_INT 0
76629: PPUSH
76630: PPUSH
76631: PPUSH
// pom := GetBase ( building ) ;
76632: LD_ADDR_VAR 0 4
76636: PUSH
76637: LD_VAR 0 1
76641: PPUSH
76642: CALL_OW 274
76646: ST_TO_ADDR
// if not pom then
76647: LD_VAR 0 4
76651: NOT
76652: IFFALSE 76656
// exit ;
76654: GO 76757
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76656: LD_ADDR_VAR 0 5
76660: PUSH
76661: LD_VAR 0 2
76665: PPUSH
76666: LD_VAR 0 1
76670: PPUSH
76671: CALL_OW 248
76675: PPUSH
76676: CALL_OW 450
76680: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76681: LD_ADDR_VAR 0 3
76685: PUSH
76686: LD_VAR 0 4
76690: PPUSH
76691: LD_INT 1
76693: PPUSH
76694: CALL_OW 275
76698: PUSH
76699: LD_VAR 0 5
76703: PUSH
76704: LD_INT 1
76706: ARRAY
76707: GREATEREQUAL
76708: PUSH
76709: LD_VAR 0 4
76713: PPUSH
76714: LD_INT 2
76716: PPUSH
76717: CALL_OW 275
76721: PUSH
76722: LD_VAR 0 5
76726: PUSH
76727: LD_INT 2
76729: ARRAY
76730: GREATEREQUAL
76731: AND
76732: PUSH
76733: LD_VAR 0 4
76737: PPUSH
76738: LD_INT 3
76740: PPUSH
76741: CALL_OW 275
76745: PUSH
76746: LD_VAR 0 5
76750: PUSH
76751: LD_INT 3
76753: ARRAY
76754: GREATEREQUAL
76755: AND
76756: ST_TO_ADDR
// end ;
76757: LD_VAR 0 3
76761: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76762: LD_INT 0
76764: PPUSH
76765: PPUSH
76766: PPUSH
76767: PPUSH
76768: PPUSH
76769: PPUSH
76770: PPUSH
76771: PPUSH
76772: PPUSH
76773: PPUSH
// result := false ;
76774: LD_ADDR_VAR 0 6
76778: PUSH
76779: LD_INT 0
76781: ST_TO_ADDR
// if not base or not btype or not x or not y then
76782: LD_VAR 0 1
76786: NOT
76787: PUSH
76788: LD_VAR 0 2
76792: NOT
76793: OR
76794: PUSH
76795: LD_VAR 0 3
76799: NOT
76800: OR
76801: PUSH
76802: LD_VAR 0 4
76806: NOT
76807: OR
76808: IFFALSE 76812
// exit ;
76810: GO 77421
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76812: LD_ADDR_VAR 0 12
76816: PUSH
76817: LD_VAR 0 2
76821: PPUSH
76822: LD_VAR 0 3
76826: PPUSH
76827: LD_VAR 0 4
76831: PPUSH
76832: LD_VAR 0 5
76836: PPUSH
76837: LD_VAR 0 1
76841: PUSH
76842: LD_INT 1
76844: ARRAY
76845: PPUSH
76846: CALL_OW 248
76850: PPUSH
76851: LD_INT 0
76853: PPUSH
76854: CALL 78258 0 6
76858: ST_TO_ADDR
// if not hexes then
76859: LD_VAR 0 12
76863: NOT
76864: IFFALSE 76868
// exit ;
76866: GO 77421
// for i = 1 to hexes do
76868: LD_ADDR_VAR 0 7
76872: PUSH
76873: DOUBLE
76874: LD_INT 1
76876: DEC
76877: ST_TO_ADDR
76878: LD_VAR 0 12
76882: PUSH
76883: FOR_TO
76884: IFFALSE 77419
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76886: LD_ADDR_VAR 0 11
76890: PUSH
76891: LD_VAR 0 12
76895: PUSH
76896: LD_VAR 0 7
76900: ARRAY
76901: PUSH
76902: LD_INT 1
76904: ARRAY
76905: PPUSH
76906: LD_VAR 0 12
76910: PUSH
76911: LD_VAR 0 7
76915: ARRAY
76916: PUSH
76917: LD_INT 2
76919: ARRAY
76920: PPUSH
76921: CALL_OW 428
76925: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76926: LD_VAR 0 12
76930: PUSH
76931: LD_VAR 0 7
76935: ARRAY
76936: PUSH
76937: LD_INT 1
76939: ARRAY
76940: PPUSH
76941: LD_VAR 0 12
76945: PUSH
76946: LD_VAR 0 7
76950: ARRAY
76951: PUSH
76952: LD_INT 2
76954: ARRAY
76955: PPUSH
76956: CALL_OW 351
76960: PUSH
76961: LD_VAR 0 12
76965: PUSH
76966: LD_VAR 0 7
76970: ARRAY
76971: PUSH
76972: LD_INT 1
76974: ARRAY
76975: PPUSH
76976: LD_VAR 0 12
76980: PUSH
76981: LD_VAR 0 7
76985: ARRAY
76986: PUSH
76987: LD_INT 2
76989: ARRAY
76990: PPUSH
76991: CALL_OW 488
76995: NOT
76996: OR
76997: PUSH
76998: LD_VAR 0 11
77002: PPUSH
77003: CALL_OW 247
77007: PUSH
77008: LD_INT 3
77010: EQUAL
77011: OR
77012: IFFALSE 77018
// exit ;
77014: POP
77015: POP
77016: GO 77421
// if not tmp or not tmp in base then
77018: LD_VAR 0 11
77022: NOT
77023: PUSH
77024: LD_VAR 0 11
77028: PUSH
77029: LD_VAR 0 1
77033: IN
77034: NOT
77035: OR
77036: IFFALSE 77040
// continue ;
77038: GO 76883
// result := true ;
77040: LD_ADDR_VAR 0 6
77044: PUSH
77045: LD_INT 1
77047: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77048: LD_ADDR_VAR 0 15
77052: PUSH
77053: LD_VAR 0 1
77057: PPUSH
77058: LD_INT 22
77060: PUSH
77061: LD_VAR 0 11
77065: PPUSH
77066: CALL_OW 255
77070: PUSH
77071: EMPTY
77072: LIST
77073: LIST
77074: PUSH
77075: LD_INT 2
77077: PUSH
77078: LD_INT 30
77080: PUSH
77081: LD_INT 0
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 30
77090: PUSH
77091: LD_INT 1
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: LIST
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PPUSH
77107: CALL_OW 72
77111: ST_TO_ADDR
// if dep then
77112: LD_VAR 0 15
77116: IFFALSE 77252
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77118: LD_ADDR_VAR 0 14
77122: PUSH
77123: LD_VAR 0 15
77127: PUSH
77128: LD_INT 1
77130: ARRAY
77131: PPUSH
77132: CALL_OW 250
77136: PPUSH
77137: LD_VAR 0 15
77141: PUSH
77142: LD_INT 1
77144: ARRAY
77145: PPUSH
77146: CALL_OW 254
77150: PPUSH
77151: LD_INT 5
77153: PPUSH
77154: CALL_OW 272
77158: PUSH
77159: LD_VAR 0 15
77163: PUSH
77164: LD_INT 1
77166: ARRAY
77167: PPUSH
77168: CALL_OW 251
77172: PPUSH
77173: LD_VAR 0 15
77177: PUSH
77178: LD_INT 1
77180: ARRAY
77181: PPUSH
77182: CALL_OW 254
77186: PPUSH
77187: LD_INT 5
77189: PPUSH
77190: CALL_OW 273
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77199: LD_VAR 0 14
77203: PUSH
77204: LD_INT 1
77206: ARRAY
77207: PPUSH
77208: LD_VAR 0 14
77212: PUSH
77213: LD_INT 2
77215: ARRAY
77216: PPUSH
77217: CALL_OW 488
77221: IFFALSE 77252
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77223: LD_VAR 0 11
77227: PPUSH
77228: LD_VAR 0 14
77232: PUSH
77233: LD_INT 1
77235: ARRAY
77236: PPUSH
77237: LD_VAR 0 14
77241: PUSH
77242: LD_INT 2
77244: ARRAY
77245: PPUSH
77246: CALL_OW 111
// continue ;
77250: GO 76883
// end ; end ; r := GetDir ( tmp ) ;
77252: LD_ADDR_VAR 0 13
77256: PUSH
77257: LD_VAR 0 11
77261: PPUSH
77262: CALL_OW 254
77266: ST_TO_ADDR
// if r = 5 then
77267: LD_VAR 0 13
77271: PUSH
77272: LD_INT 5
77274: EQUAL
77275: IFFALSE 77285
// r := 0 ;
77277: LD_ADDR_VAR 0 13
77281: PUSH
77282: LD_INT 0
77284: ST_TO_ADDR
// for j = r to 5 do
77285: LD_ADDR_VAR 0 8
77289: PUSH
77290: DOUBLE
77291: LD_VAR 0 13
77295: DEC
77296: ST_TO_ADDR
77297: LD_INT 5
77299: PUSH
77300: FOR_TO
77301: IFFALSE 77415
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77303: LD_ADDR_VAR 0 9
77307: PUSH
77308: LD_VAR 0 11
77312: PPUSH
77313: CALL_OW 250
77317: PPUSH
77318: LD_VAR 0 8
77322: PPUSH
77323: LD_INT 2
77325: PPUSH
77326: CALL_OW 272
77330: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77331: LD_ADDR_VAR 0 10
77335: PUSH
77336: LD_VAR 0 11
77340: PPUSH
77341: CALL_OW 251
77345: PPUSH
77346: LD_VAR 0 8
77350: PPUSH
77351: LD_INT 2
77353: PPUSH
77354: CALL_OW 273
77358: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77359: LD_VAR 0 9
77363: PPUSH
77364: LD_VAR 0 10
77368: PPUSH
77369: CALL_OW 488
77373: PUSH
77374: LD_VAR 0 9
77378: PPUSH
77379: LD_VAR 0 10
77383: PPUSH
77384: CALL_OW 428
77388: NOT
77389: AND
77390: IFFALSE 77413
// begin ComMoveXY ( tmp , _x , _y ) ;
77392: LD_VAR 0 11
77396: PPUSH
77397: LD_VAR 0 9
77401: PPUSH
77402: LD_VAR 0 10
77406: PPUSH
77407: CALL_OW 111
// break ;
77411: GO 77415
// end ; end ;
77413: GO 77300
77415: POP
77416: POP
// end ;
77417: GO 76883
77419: POP
77420: POP
// end ;
77421: LD_VAR 0 6
77425: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77426: LD_INT 0
77428: PPUSH
77429: PPUSH
77430: PPUSH
77431: PPUSH
77432: PPUSH
77433: PPUSH
77434: PPUSH
77435: PPUSH
77436: PPUSH
77437: PPUSH
// result := false ;
77438: LD_ADDR_VAR 0 6
77442: PUSH
77443: LD_INT 0
77445: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77446: LD_VAR 0 1
77450: NOT
77451: PUSH
77452: LD_VAR 0 1
77456: PPUSH
77457: CALL_OW 266
77461: PUSH
77462: LD_INT 0
77464: PUSH
77465: LD_INT 1
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: IN
77472: NOT
77473: OR
77474: PUSH
77475: LD_VAR 0 2
77479: NOT
77480: OR
77481: PUSH
77482: LD_VAR 0 5
77486: PUSH
77487: LD_INT 0
77489: PUSH
77490: LD_INT 1
77492: PUSH
77493: LD_INT 2
77495: PUSH
77496: LD_INT 3
77498: PUSH
77499: LD_INT 4
77501: PUSH
77502: LD_INT 5
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: LIST
77509: LIST
77510: LIST
77511: LIST
77512: IN
77513: NOT
77514: OR
77515: PUSH
77516: LD_VAR 0 3
77520: PPUSH
77521: LD_VAR 0 4
77525: PPUSH
77526: CALL_OW 488
77530: NOT
77531: OR
77532: IFFALSE 77536
// exit ;
77534: GO 78253
// pom := GetBase ( depot ) ;
77536: LD_ADDR_VAR 0 10
77540: PUSH
77541: LD_VAR 0 1
77545: PPUSH
77546: CALL_OW 274
77550: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77551: LD_ADDR_VAR 0 11
77555: PUSH
77556: LD_VAR 0 2
77560: PPUSH
77561: LD_VAR 0 1
77565: PPUSH
77566: CALL_OW 248
77570: PPUSH
77571: CALL_OW 450
77575: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77576: LD_VAR 0 10
77580: PPUSH
77581: LD_INT 1
77583: PPUSH
77584: CALL_OW 275
77588: PUSH
77589: LD_VAR 0 11
77593: PUSH
77594: LD_INT 1
77596: ARRAY
77597: GREATEREQUAL
77598: PUSH
77599: LD_VAR 0 10
77603: PPUSH
77604: LD_INT 2
77606: PPUSH
77607: CALL_OW 275
77611: PUSH
77612: LD_VAR 0 11
77616: PUSH
77617: LD_INT 2
77619: ARRAY
77620: GREATEREQUAL
77621: AND
77622: PUSH
77623: LD_VAR 0 10
77627: PPUSH
77628: LD_INT 3
77630: PPUSH
77631: CALL_OW 275
77635: PUSH
77636: LD_VAR 0 11
77640: PUSH
77641: LD_INT 3
77643: ARRAY
77644: GREATEREQUAL
77645: AND
77646: NOT
77647: IFFALSE 77651
// exit ;
77649: GO 78253
// if GetBType ( depot ) = b_depot then
77651: LD_VAR 0 1
77655: PPUSH
77656: CALL_OW 266
77660: PUSH
77661: LD_INT 0
77663: EQUAL
77664: IFFALSE 77676
// dist := 28 else
77666: LD_ADDR_VAR 0 14
77670: PUSH
77671: LD_INT 28
77673: ST_TO_ADDR
77674: GO 77684
// dist := 36 ;
77676: LD_ADDR_VAR 0 14
77680: PUSH
77681: LD_INT 36
77683: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77684: LD_VAR 0 1
77688: PPUSH
77689: LD_VAR 0 3
77693: PPUSH
77694: LD_VAR 0 4
77698: PPUSH
77699: CALL_OW 297
77703: PUSH
77704: LD_VAR 0 14
77708: GREATER
77709: IFFALSE 77713
// exit ;
77711: GO 78253
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77713: LD_ADDR_VAR 0 12
77717: PUSH
77718: LD_VAR 0 2
77722: PPUSH
77723: LD_VAR 0 3
77727: PPUSH
77728: LD_VAR 0 4
77732: PPUSH
77733: LD_VAR 0 5
77737: PPUSH
77738: LD_VAR 0 1
77742: PPUSH
77743: CALL_OW 248
77747: PPUSH
77748: LD_INT 0
77750: PPUSH
77751: CALL 78258 0 6
77755: ST_TO_ADDR
// if not hexes then
77756: LD_VAR 0 12
77760: NOT
77761: IFFALSE 77765
// exit ;
77763: GO 78253
// hex := GetHexInfo ( x , y ) ;
77765: LD_ADDR_VAR 0 15
77769: PUSH
77770: LD_VAR 0 3
77774: PPUSH
77775: LD_VAR 0 4
77779: PPUSH
77780: CALL_OW 546
77784: ST_TO_ADDR
// if hex [ 1 ] then
77785: LD_VAR 0 15
77789: PUSH
77790: LD_INT 1
77792: ARRAY
77793: IFFALSE 77797
// exit ;
77795: GO 78253
// height := hex [ 2 ] ;
77797: LD_ADDR_VAR 0 13
77801: PUSH
77802: LD_VAR 0 15
77806: PUSH
77807: LD_INT 2
77809: ARRAY
77810: ST_TO_ADDR
// for i = 1 to hexes do
77811: LD_ADDR_VAR 0 7
77815: PUSH
77816: DOUBLE
77817: LD_INT 1
77819: DEC
77820: ST_TO_ADDR
77821: LD_VAR 0 12
77825: PUSH
77826: FOR_TO
77827: IFFALSE 78157
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77829: LD_VAR 0 12
77833: PUSH
77834: LD_VAR 0 7
77838: ARRAY
77839: PUSH
77840: LD_INT 1
77842: ARRAY
77843: PPUSH
77844: LD_VAR 0 12
77848: PUSH
77849: LD_VAR 0 7
77853: ARRAY
77854: PUSH
77855: LD_INT 2
77857: ARRAY
77858: PPUSH
77859: CALL_OW 488
77863: NOT
77864: PUSH
77865: LD_VAR 0 12
77869: PUSH
77870: LD_VAR 0 7
77874: ARRAY
77875: PUSH
77876: LD_INT 1
77878: ARRAY
77879: PPUSH
77880: LD_VAR 0 12
77884: PUSH
77885: LD_VAR 0 7
77889: ARRAY
77890: PUSH
77891: LD_INT 2
77893: ARRAY
77894: PPUSH
77895: CALL_OW 428
77899: PUSH
77900: LD_INT 0
77902: GREATER
77903: OR
77904: PUSH
77905: LD_VAR 0 12
77909: PUSH
77910: LD_VAR 0 7
77914: ARRAY
77915: PUSH
77916: LD_INT 1
77918: ARRAY
77919: PPUSH
77920: LD_VAR 0 12
77924: PUSH
77925: LD_VAR 0 7
77929: ARRAY
77930: PUSH
77931: LD_INT 2
77933: ARRAY
77934: PPUSH
77935: CALL_OW 351
77939: OR
77940: IFFALSE 77946
// exit ;
77942: POP
77943: POP
77944: GO 78253
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77946: LD_ADDR_VAR 0 8
77950: PUSH
77951: LD_VAR 0 12
77955: PUSH
77956: LD_VAR 0 7
77960: ARRAY
77961: PUSH
77962: LD_INT 1
77964: ARRAY
77965: PPUSH
77966: LD_VAR 0 12
77970: PUSH
77971: LD_VAR 0 7
77975: ARRAY
77976: PUSH
77977: LD_INT 2
77979: ARRAY
77980: PPUSH
77981: CALL_OW 546
77985: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77986: LD_VAR 0 8
77990: PUSH
77991: LD_INT 1
77993: ARRAY
77994: PUSH
77995: LD_VAR 0 8
77999: PUSH
78000: LD_INT 2
78002: ARRAY
78003: PUSH
78004: LD_VAR 0 13
78008: PUSH
78009: LD_INT 2
78011: PLUS
78012: GREATER
78013: OR
78014: PUSH
78015: LD_VAR 0 8
78019: PUSH
78020: LD_INT 2
78022: ARRAY
78023: PUSH
78024: LD_VAR 0 13
78028: PUSH
78029: LD_INT 2
78031: MINUS
78032: LESS
78033: OR
78034: PUSH
78035: LD_VAR 0 8
78039: PUSH
78040: LD_INT 3
78042: ARRAY
78043: PUSH
78044: LD_INT 0
78046: PUSH
78047: LD_INT 8
78049: PUSH
78050: LD_INT 9
78052: PUSH
78053: LD_INT 10
78055: PUSH
78056: LD_INT 11
78058: PUSH
78059: LD_INT 12
78061: PUSH
78062: LD_INT 13
78064: PUSH
78065: LD_INT 16
78067: PUSH
78068: LD_INT 17
78070: PUSH
78071: LD_INT 18
78073: PUSH
78074: LD_INT 19
78076: PUSH
78077: LD_INT 20
78079: PUSH
78080: LD_INT 21
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: LIST
78087: LIST
78088: LIST
78089: LIST
78090: LIST
78091: LIST
78092: LIST
78093: LIST
78094: LIST
78095: LIST
78096: LIST
78097: IN
78098: NOT
78099: OR
78100: PUSH
78101: LD_VAR 0 8
78105: PUSH
78106: LD_INT 5
78108: ARRAY
78109: NOT
78110: OR
78111: PUSH
78112: LD_VAR 0 8
78116: PUSH
78117: LD_INT 6
78119: ARRAY
78120: PUSH
78121: LD_INT 1
78123: PUSH
78124: LD_INT 2
78126: PUSH
78127: LD_INT 7
78129: PUSH
78130: LD_INT 9
78132: PUSH
78133: LD_INT 10
78135: PUSH
78136: LD_INT 11
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: IN
78147: NOT
78148: OR
78149: IFFALSE 78155
// exit ;
78151: POP
78152: POP
78153: GO 78253
// end ;
78155: GO 77826
78157: POP
78158: POP
// side := GetSide ( depot ) ;
78159: LD_ADDR_VAR 0 9
78163: PUSH
78164: LD_VAR 0 1
78168: PPUSH
78169: CALL_OW 255
78173: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78174: LD_VAR 0 9
78178: PPUSH
78179: LD_VAR 0 3
78183: PPUSH
78184: LD_VAR 0 4
78188: PPUSH
78189: LD_INT 20
78191: PPUSH
78192: CALL 70907 0 4
78196: PUSH
78197: LD_INT 4
78199: ARRAY
78200: IFFALSE 78204
// exit ;
78202: GO 78253
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78204: LD_VAR 0 2
78208: PUSH
78209: LD_INT 29
78211: PUSH
78212: LD_INT 30
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: IN
78219: PUSH
78220: LD_VAR 0 3
78224: PPUSH
78225: LD_VAR 0 4
78229: PPUSH
78230: LD_VAR 0 9
78234: PPUSH
78235: CALL_OW 440
78239: NOT
78240: AND
78241: IFFALSE 78245
// exit ;
78243: GO 78253
// result := true ;
78245: LD_ADDR_VAR 0 6
78249: PUSH
78250: LD_INT 1
78252: ST_TO_ADDR
// end ;
78253: LD_VAR 0 6
78257: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
78258: LD_INT 0
78260: PPUSH
78261: PPUSH
78262: PPUSH
78263: PPUSH
78264: PPUSH
78265: PPUSH
78266: PPUSH
78267: PPUSH
78268: PPUSH
78269: PPUSH
78270: PPUSH
78271: PPUSH
78272: PPUSH
78273: PPUSH
78274: PPUSH
78275: PPUSH
78276: PPUSH
78277: PPUSH
78278: PPUSH
78279: PPUSH
78280: PPUSH
78281: PPUSH
78282: PPUSH
78283: PPUSH
78284: PPUSH
78285: PPUSH
78286: PPUSH
78287: PPUSH
78288: PPUSH
78289: PPUSH
78290: PPUSH
78291: PPUSH
78292: PPUSH
78293: PPUSH
78294: PPUSH
78295: PPUSH
78296: PPUSH
78297: PPUSH
78298: PPUSH
78299: PPUSH
78300: PPUSH
78301: PPUSH
78302: PPUSH
78303: PPUSH
78304: PPUSH
78305: PPUSH
78306: PPUSH
78307: PPUSH
78308: PPUSH
78309: PPUSH
78310: PPUSH
78311: PPUSH
78312: PPUSH
78313: PPUSH
78314: PPUSH
78315: PPUSH
78316: PPUSH
78317: PPUSH
// result = [ ] ;
78318: LD_ADDR_VAR 0 7
78322: PUSH
78323: EMPTY
78324: ST_TO_ADDR
// temp_list = [ ] ;
78325: LD_ADDR_VAR 0 9
78329: PUSH
78330: EMPTY
78331: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78332: LD_VAR 0 4
78336: PUSH
78337: LD_INT 0
78339: PUSH
78340: LD_INT 1
78342: PUSH
78343: LD_INT 2
78345: PUSH
78346: LD_INT 3
78348: PUSH
78349: LD_INT 4
78351: PUSH
78352: LD_INT 5
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: IN
78363: NOT
78364: PUSH
78365: LD_VAR 0 1
78369: PUSH
78370: LD_INT 0
78372: PUSH
78373: LD_INT 1
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: IN
78380: PUSH
78381: LD_VAR 0 5
78385: PUSH
78386: LD_INT 1
78388: PUSH
78389: LD_INT 2
78391: PUSH
78392: LD_INT 3
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: LIST
78399: IN
78400: NOT
78401: AND
78402: OR
78403: IFFALSE 78407
// exit ;
78405: GO 96798
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78407: LD_VAR 0 1
78411: PUSH
78412: LD_INT 6
78414: PUSH
78415: LD_INT 7
78417: PUSH
78418: LD_INT 8
78420: PUSH
78421: LD_INT 13
78423: PUSH
78424: LD_INT 12
78426: PUSH
78427: LD_INT 15
78429: PUSH
78430: LD_INT 11
78432: PUSH
78433: LD_INT 14
78435: PUSH
78436: LD_INT 10
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: LIST
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: IN
78450: IFFALSE 78460
// btype = b_lab ;
78452: LD_ADDR_VAR 0 1
78456: PUSH
78457: LD_INT 6
78459: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78460: LD_VAR 0 6
78464: PUSH
78465: LD_INT 0
78467: PUSH
78468: LD_INT 1
78470: PUSH
78471: LD_INT 2
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: LIST
78478: IN
78479: NOT
78480: PUSH
78481: LD_VAR 0 1
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: LD_INT 1
78491: PUSH
78492: LD_INT 2
78494: PUSH
78495: LD_INT 3
78497: PUSH
78498: LD_INT 6
78500: PUSH
78501: LD_INT 36
78503: PUSH
78504: LD_INT 4
78506: PUSH
78507: LD_INT 5
78509: PUSH
78510: LD_INT 31
78512: PUSH
78513: LD_INT 32
78515: PUSH
78516: LD_INT 33
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: IN
78532: NOT
78533: PUSH
78534: LD_VAR 0 6
78538: PUSH
78539: LD_INT 1
78541: EQUAL
78542: AND
78543: OR
78544: PUSH
78545: LD_VAR 0 1
78549: PUSH
78550: LD_INT 2
78552: PUSH
78553: LD_INT 3
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: IN
78560: NOT
78561: PUSH
78562: LD_VAR 0 6
78566: PUSH
78567: LD_INT 2
78569: EQUAL
78570: AND
78571: OR
78572: IFFALSE 78582
// mode = 0 ;
78574: LD_ADDR_VAR 0 6
78578: PUSH
78579: LD_INT 0
78581: ST_TO_ADDR
// case mode of 0 :
78582: LD_VAR 0 6
78586: PUSH
78587: LD_INT 0
78589: DOUBLE
78590: EQUAL
78591: IFTRUE 78595
78593: GO 90048
78595: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78596: LD_ADDR_VAR 0 11
78600: PUSH
78601: LD_INT 0
78603: PUSH
78604: LD_INT 0
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 0
78613: PUSH
78614: LD_INT 1
78616: NEG
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 1
78624: PUSH
78625: LD_INT 0
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: LD_INT 1
78634: PUSH
78635: LD_INT 1
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: LD_INT 0
78644: PUSH
78645: LD_INT 1
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 1
78654: NEG
78655: PUSH
78656: LD_INT 0
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 1
78665: NEG
78666: PUSH
78667: LD_INT 1
78669: NEG
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: LD_INT 2
78681: NEG
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 0
78689: PUSH
78690: LD_INT 2
78692: NEG
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 1
78700: PUSH
78701: LD_INT 1
78703: NEG
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 1
78711: PUSH
78712: LD_INT 2
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 0
78721: PUSH
78722: LD_INT 2
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 1
78731: NEG
78732: PUSH
78733: LD_INT 1
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 1
78742: PUSH
78743: LD_INT 3
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: LD_INT 3
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 1
78762: NEG
78763: PUSH
78764: LD_INT 2
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78789: LD_ADDR_VAR 0 12
78793: PUSH
78794: LD_INT 0
78796: PUSH
78797: LD_INT 0
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 0
78806: PUSH
78807: LD_INT 1
78809: NEG
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 1
78817: PUSH
78818: LD_INT 0
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 1
78827: PUSH
78828: LD_INT 1
78830: PUSH
78831: EMPTY
78832: LIST
78833: LIST
78834: PUSH
78835: LD_INT 0
78837: PUSH
78838: LD_INT 1
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 1
78847: NEG
78848: PUSH
78849: LD_INT 0
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 1
78858: NEG
78859: PUSH
78860: LD_INT 1
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 1
78870: PUSH
78871: LD_INT 1
78873: NEG
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 2
78881: PUSH
78882: LD_INT 0
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 2
78891: PUSH
78892: LD_INT 1
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 1
78901: NEG
78902: PUSH
78903: LD_INT 1
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 2
78912: NEG
78913: PUSH
78914: LD_INT 0
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: PUSH
78921: LD_INT 2
78923: NEG
78924: PUSH
78925: LD_INT 1
78927: NEG
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 2
78935: NEG
78936: PUSH
78937: LD_INT 1
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PUSH
78944: LD_INT 3
78946: NEG
78947: PUSH
78948: LD_INT 0
78950: PUSH
78951: EMPTY
78952: LIST
78953: LIST
78954: PUSH
78955: LD_INT 3
78957: NEG
78958: PUSH
78959: LD_INT 1
78961: NEG
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: LIST
78971: LIST
78972: LIST
78973: LIST
78974: LIST
78975: LIST
78976: LIST
78977: LIST
78978: LIST
78979: LIST
78980: LIST
78981: LIST
78982: LIST
78983: LIST
78984: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78985: LD_ADDR_VAR 0 13
78989: PUSH
78990: LD_INT 0
78992: PUSH
78993: LD_INT 0
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 0
79002: PUSH
79003: LD_INT 1
79005: NEG
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 1
79013: PUSH
79014: LD_INT 0
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 1
79023: PUSH
79024: LD_INT 1
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 0
79033: PUSH
79034: LD_INT 1
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 1
79043: NEG
79044: PUSH
79045: LD_INT 0
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 1
79054: NEG
79055: PUSH
79056: LD_INT 1
79058: NEG
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 1
79066: NEG
79067: PUSH
79068: LD_INT 2
79070: NEG
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 2
79078: PUSH
79079: LD_INT 1
79081: PUSH
79082: EMPTY
79083: LIST
79084: LIST
79085: PUSH
79086: LD_INT 2
79088: PUSH
79089: LD_INT 2
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 1
79098: PUSH
79099: LD_INT 2
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 2
79108: NEG
79109: PUSH
79110: LD_INT 1
79112: NEG
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: PUSH
79118: LD_INT 2
79120: NEG
79121: PUSH
79122: LD_INT 2
79124: NEG
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: LD_INT 2
79132: NEG
79133: PUSH
79134: LD_INT 3
79136: NEG
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 3
79144: NEG
79145: PUSH
79146: LD_INT 2
79148: NEG
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 3
79156: NEG
79157: PUSH
79158: LD_INT 3
79160: NEG
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: LIST
79170: LIST
79171: LIST
79172: LIST
79173: LIST
79174: LIST
79175: LIST
79176: LIST
79177: LIST
79178: LIST
79179: LIST
79180: LIST
79181: LIST
79182: LIST
79183: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79184: LD_ADDR_VAR 0 14
79188: PUSH
79189: LD_INT 0
79191: PUSH
79192: LD_INT 0
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 0
79201: PUSH
79202: LD_INT 1
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 1
79212: PUSH
79213: LD_INT 0
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: LD_INT 1
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 0
79232: PUSH
79233: LD_INT 1
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PUSH
79240: LD_INT 1
79242: NEG
79243: PUSH
79244: LD_INT 0
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 1
79253: NEG
79254: PUSH
79255: LD_INT 1
79257: NEG
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 1
79265: NEG
79266: PUSH
79267: LD_INT 2
79269: NEG
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: PUSH
79275: LD_INT 0
79277: PUSH
79278: LD_INT 2
79280: NEG
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 1
79288: PUSH
79289: LD_INT 1
79291: NEG
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 1
79299: PUSH
79300: LD_INT 2
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 0
79309: PUSH
79310: LD_INT 2
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 1
79319: NEG
79320: PUSH
79321: LD_INT 1
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PUSH
79328: LD_INT 1
79330: NEG
79331: PUSH
79332: LD_INT 3
79334: NEG
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 0
79342: PUSH
79343: LD_INT 3
79345: NEG
79346: PUSH
79347: EMPTY
79348: LIST
79349: LIST
79350: PUSH
79351: LD_INT 1
79353: PUSH
79354: LD_INT 2
79356: NEG
79357: PUSH
79358: EMPTY
79359: LIST
79360: LIST
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: LIST
79366: LIST
79367: LIST
79368: LIST
79369: LIST
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79380: LD_ADDR_VAR 0 15
79384: PUSH
79385: LD_INT 0
79387: PUSH
79388: LD_INT 0
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 0
79397: PUSH
79398: LD_INT 1
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 1
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 1
79418: PUSH
79419: LD_INT 1
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 0
79428: PUSH
79429: LD_INT 1
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 1
79438: NEG
79439: PUSH
79440: LD_INT 0
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 1
79449: NEG
79450: PUSH
79451: LD_INT 1
79453: NEG
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 1
79461: PUSH
79462: LD_INT 1
79464: NEG
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 2
79472: PUSH
79473: LD_INT 0
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 2
79482: PUSH
79483: LD_INT 1
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: NEG
79493: PUSH
79494: LD_INT 1
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 2
79503: NEG
79504: PUSH
79505: LD_INT 0
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 2
79514: NEG
79515: PUSH
79516: LD_INT 1
79518: NEG
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: PUSH
79524: LD_INT 2
79526: PUSH
79527: LD_INT 1
79529: NEG
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 3
79537: PUSH
79538: LD_INT 0
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 3
79547: PUSH
79548: LD_INT 1
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: LIST
79559: LIST
79560: LIST
79561: LIST
79562: LIST
79563: LIST
79564: LIST
79565: LIST
79566: LIST
79567: LIST
79568: LIST
79569: LIST
79570: LIST
79571: LIST
79572: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79573: LD_ADDR_VAR 0 16
79577: PUSH
79578: LD_INT 0
79580: PUSH
79581: LD_INT 0
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 0
79590: PUSH
79591: LD_INT 1
79593: NEG
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: LD_INT 0
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 1
79611: PUSH
79612: LD_INT 1
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 0
79621: PUSH
79622: LD_INT 1
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: LD_INT 0
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 1
79642: NEG
79643: PUSH
79644: LD_INT 1
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 1
79654: NEG
79655: PUSH
79656: LD_INT 2
79658: NEG
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: LD_INT 2
79666: PUSH
79667: LD_INT 1
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 2
79676: PUSH
79677: LD_INT 2
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 1
79686: PUSH
79687: LD_INT 2
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 2
79696: NEG
79697: PUSH
79698: LD_INT 1
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 2
79708: NEG
79709: PUSH
79710: LD_INT 2
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 3
79720: PUSH
79721: LD_INT 2
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 3
79730: PUSH
79731: LD_INT 3
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 2
79740: PUSH
79741: LD_INT 3
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: LIST
79763: LIST
79764: LIST
79765: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79766: LD_ADDR_VAR 0 17
79770: PUSH
79771: LD_INT 0
79773: PUSH
79774: LD_INT 0
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: LD_INT 1
79786: NEG
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 1
79794: PUSH
79795: LD_INT 0
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 1
79804: PUSH
79805: LD_INT 1
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: LD_INT 1
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 1
79824: NEG
79825: PUSH
79826: LD_INT 0
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 1
79835: NEG
79836: PUSH
79837: LD_INT 1
79839: NEG
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 1
79847: NEG
79848: PUSH
79849: LD_INT 2
79851: NEG
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: PUSH
79857: LD_INT 0
79859: PUSH
79860: LD_INT 2
79862: NEG
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 1
79870: PUSH
79871: LD_INT 1
79873: NEG
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 2
79881: PUSH
79882: LD_INT 0
79884: PUSH
79885: EMPTY
79886: LIST
79887: LIST
79888: PUSH
79889: LD_INT 2
79891: PUSH
79892: LD_INT 1
79894: PUSH
79895: EMPTY
79896: LIST
79897: LIST
79898: PUSH
79899: LD_INT 2
79901: PUSH
79902: LD_INT 2
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: LD_INT 2
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 0
79921: PUSH
79922: LD_INT 2
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 1
79931: NEG
79932: PUSH
79933: LD_INT 1
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 2
79942: NEG
79943: PUSH
79944: LD_INT 0
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 2
79953: NEG
79954: PUSH
79955: LD_INT 1
79957: NEG
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 2
79965: NEG
79966: PUSH
79967: LD_INT 2
79969: NEG
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79996: LD_ADDR_VAR 0 18
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: LD_INT 0
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: PUSH
80011: LD_INT 0
80013: PUSH
80014: LD_INT 1
80016: NEG
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: LD_INT 1
80024: PUSH
80025: LD_INT 0
80027: PUSH
80028: EMPTY
80029: LIST
80030: LIST
80031: PUSH
80032: LD_INT 1
80034: PUSH
80035: LD_INT 1
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 0
80044: PUSH
80045: LD_INT 1
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 1
80054: NEG
80055: PUSH
80056: LD_INT 0
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 1
80065: NEG
80066: PUSH
80067: LD_INT 1
80069: NEG
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 1
80077: NEG
80078: PUSH
80079: LD_INT 2
80081: NEG
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 0
80089: PUSH
80090: LD_INT 2
80092: NEG
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 1
80100: PUSH
80101: LD_INT 1
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 2
80111: PUSH
80112: LD_INT 0
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 2
80121: PUSH
80122: LD_INT 1
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 2
80131: PUSH
80132: LD_INT 2
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 1
80141: PUSH
80142: LD_INT 2
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 0
80151: PUSH
80152: LD_INT 2
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PUSH
80159: LD_INT 1
80161: NEG
80162: PUSH
80163: LD_INT 1
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 2
80172: NEG
80173: PUSH
80174: LD_INT 0
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 2
80183: NEG
80184: PUSH
80185: LD_INT 1
80187: NEG
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 2
80195: NEG
80196: PUSH
80197: LD_INT 2
80199: NEG
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: LIST
80222: LIST
80223: LIST
80224: LIST
80225: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80226: LD_ADDR_VAR 0 19
80230: PUSH
80231: LD_INT 0
80233: PUSH
80234: LD_INT 0
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 0
80243: PUSH
80244: LD_INT 1
80246: NEG
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 1
80254: PUSH
80255: LD_INT 0
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 1
80264: PUSH
80265: LD_INT 1
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 0
80274: PUSH
80275: LD_INT 1
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 1
80284: NEG
80285: PUSH
80286: LD_INT 0
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 1
80295: NEG
80296: PUSH
80297: LD_INT 1
80299: NEG
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 1
80307: NEG
80308: PUSH
80309: LD_INT 2
80311: NEG
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 0
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 1
80330: PUSH
80331: LD_INT 1
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 2
80341: PUSH
80342: LD_INT 0
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: LD_INT 2
80351: PUSH
80352: LD_INT 1
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: PUSH
80359: LD_INT 2
80361: PUSH
80362: LD_INT 2
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 1
80371: PUSH
80372: LD_INT 2
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 0
80381: PUSH
80382: LD_INT 2
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 1
80391: NEG
80392: PUSH
80393: LD_INT 1
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: PUSH
80400: LD_INT 2
80402: NEG
80403: PUSH
80404: LD_INT 0
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 2
80413: NEG
80414: PUSH
80415: LD_INT 1
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 2
80425: NEG
80426: PUSH
80427: LD_INT 2
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80456: LD_ADDR_VAR 0 20
80460: PUSH
80461: LD_INT 0
80463: PUSH
80464: LD_INT 0
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: LD_INT 0
80473: PUSH
80474: LD_INT 1
80476: NEG
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 1
80484: PUSH
80485: LD_INT 0
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 1
80494: PUSH
80495: LD_INT 1
80497: PUSH
80498: EMPTY
80499: LIST
80500: LIST
80501: PUSH
80502: LD_INT 0
80504: PUSH
80505: LD_INT 1
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 1
80514: NEG
80515: PUSH
80516: LD_INT 0
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 1
80525: NEG
80526: PUSH
80527: LD_INT 1
80529: NEG
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 1
80537: NEG
80538: PUSH
80539: LD_INT 2
80541: NEG
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 0
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 1
80560: PUSH
80561: LD_INT 1
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 2
80571: PUSH
80572: LD_INT 0
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 2
80581: PUSH
80582: LD_INT 1
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 2
80591: PUSH
80592: LD_INT 2
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 1
80601: PUSH
80602: LD_INT 2
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 0
80611: PUSH
80612: LD_INT 2
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 1
80621: NEG
80622: PUSH
80623: LD_INT 1
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 2
80632: NEG
80633: PUSH
80634: LD_INT 0
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 2
80643: NEG
80644: PUSH
80645: LD_INT 1
80647: NEG
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: LD_INT 2
80655: NEG
80656: PUSH
80657: LD_INT 2
80659: NEG
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: LIST
80671: LIST
80672: LIST
80673: LIST
80674: LIST
80675: LIST
80676: LIST
80677: LIST
80678: LIST
80679: LIST
80680: LIST
80681: LIST
80682: LIST
80683: LIST
80684: LIST
80685: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80686: LD_ADDR_VAR 0 21
80690: PUSH
80691: LD_INT 0
80693: PUSH
80694: LD_INT 0
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 0
80703: PUSH
80704: LD_INT 1
80706: NEG
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 1
80714: PUSH
80715: LD_INT 0
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 1
80724: PUSH
80725: LD_INT 1
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 0
80734: PUSH
80735: LD_INT 1
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 1
80744: NEG
80745: PUSH
80746: LD_INT 0
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 1
80755: NEG
80756: PUSH
80757: LD_INT 1
80759: NEG
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: LD_INT 1
80767: NEG
80768: PUSH
80769: LD_INT 2
80771: NEG
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 0
80779: PUSH
80780: LD_INT 2
80782: NEG
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 1
80790: PUSH
80791: LD_INT 1
80793: NEG
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 2
80801: PUSH
80802: LD_INT 0
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 2
80811: PUSH
80812: LD_INT 1
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 2
80821: PUSH
80822: LD_INT 2
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 1
80831: PUSH
80832: LD_INT 2
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: LD_INT 2
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: LD_INT 1
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: LD_INT 2
80862: NEG
80863: PUSH
80864: LD_INT 0
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 2
80873: NEG
80874: PUSH
80875: LD_INT 1
80877: NEG
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 2
80885: NEG
80886: PUSH
80887: LD_INT 2
80889: NEG
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80916: LD_ADDR_VAR 0 22
80920: PUSH
80921: LD_INT 0
80923: PUSH
80924: LD_INT 0
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: PUSH
80931: LD_INT 0
80933: PUSH
80934: LD_INT 1
80936: NEG
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 1
80944: PUSH
80945: LD_INT 0
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PUSH
80952: LD_INT 1
80954: PUSH
80955: LD_INT 1
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: LD_INT 0
80964: PUSH
80965: LD_INT 1
80967: PUSH
80968: EMPTY
80969: LIST
80970: LIST
80971: PUSH
80972: LD_INT 1
80974: NEG
80975: PUSH
80976: LD_INT 0
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: LD_INT 1
80985: NEG
80986: PUSH
80987: LD_INT 1
80989: NEG
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: LD_INT 1
80997: NEG
80998: PUSH
80999: LD_INT 2
81001: NEG
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 0
81009: PUSH
81010: LD_INT 2
81012: NEG
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: LD_INT 1
81020: PUSH
81021: LD_INT 1
81023: NEG
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 2
81031: PUSH
81032: LD_INT 0
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 2
81041: PUSH
81042: LD_INT 1
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 2
81051: PUSH
81052: LD_INT 2
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 1
81061: PUSH
81062: LD_INT 2
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 0
81071: PUSH
81072: LD_INT 2
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 1
81081: NEG
81082: PUSH
81083: LD_INT 1
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 2
81092: NEG
81093: PUSH
81094: LD_INT 0
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 2
81103: NEG
81104: PUSH
81105: LD_INT 1
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 2
81115: NEG
81116: PUSH
81117: LD_INT 2
81119: NEG
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81146: LD_ADDR_VAR 0 23
81150: PUSH
81151: LD_INT 0
81153: PUSH
81154: LD_INT 0
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 0
81163: PUSH
81164: LD_INT 1
81166: NEG
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 1
81174: PUSH
81175: LD_INT 0
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 1
81184: PUSH
81185: LD_INT 1
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 0
81194: PUSH
81195: LD_INT 1
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 1
81204: NEG
81205: PUSH
81206: LD_INT 0
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 1
81215: NEG
81216: PUSH
81217: LD_INT 1
81219: NEG
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 1
81227: NEG
81228: PUSH
81229: LD_INT 2
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 0
81239: PUSH
81240: LD_INT 2
81242: NEG
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 1
81250: PUSH
81251: LD_INT 1
81253: NEG
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 2
81261: PUSH
81262: LD_INT 0
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 2
81271: PUSH
81272: LD_INT 1
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 2
81281: PUSH
81282: LD_INT 2
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 1
81291: PUSH
81292: LD_INT 2
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: PUSH
81299: LD_INT 0
81301: PUSH
81302: LD_INT 2
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 1
81311: NEG
81312: PUSH
81313: LD_INT 1
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 2
81322: NEG
81323: PUSH
81324: LD_INT 0
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 2
81333: NEG
81334: PUSH
81335: LD_INT 1
81337: NEG
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: LD_INT 2
81345: NEG
81346: PUSH
81347: LD_INT 2
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 2
81357: NEG
81358: PUSH
81359: LD_INT 3
81361: NEG
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: LD_INT 3
81373: NEG
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 1
81381: PUSH
81382: LD_INT 2
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 2
81392: PUSH
81393: LD_INT 1
81395: NEG
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: LIST
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81426: LD_ADDR_VAR 0 24
81430: PUSH
81431: LD_INT 0
81433: PUSH
81434: LD_INT 0
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 0
81443: PUSH
81444: LD_INT 1
81446: NEG
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 1
81454: PUSH
81455: LD_INT 0
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 1
81464: PUSH
81465: LD_INT 1
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 0
81474: PUSH
81475: LD_INT 1
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: LD_INT 1
81484: NEG
81485: PUSH
81486: LD_INT 0
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 1
81495: NEG
81496: PUSH
81497: LD_INT 1
81499: NEG
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: LD_INT 1
81507: NEG
81508: PUSH
81509: LD_INT 2
81511: NEG
81512: PUSH
81513: EMPTY
81514: LIST
81515: LIST
81516: PUSH
81517: LD_INT 0
81519: PUSH
81520: LD_INT 2
81522: NEG
81523: PUSH
81524: EMPTY
81525: LIST
81526: LIST
81527: PUSH
81528: LD_INT 1
81530: PUSH
81531: LD_INT 1
81533: NEG
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: PUSH
81539: LD_INT 2
81541: PUSH
81542: LD_INT 0
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_INT 2
81551: PUSH
81552: LD_INT 1
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 2
81561: PUSH
81562: LD_INT 2
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 1
81571: PUSH
81572: LD_INT 2
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 0
81581: PUSH
81582: LD_INT 2
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 1
81591: NEG
81592: PUSH
81593: LD_INT 1
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: LD_INT 2
81602: NEG
81603: PUSH
81604: LD_INT 0
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 2
81613: NEG
81614: PUSH
81615: LD_INT 1
81617: NEG
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 2
81625: NEG
81626: PUSH
81627: LD_INT 2
81629: NEG
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: LD_INT 1
81637: PUSH
81638: LD_INT 2
81640: NEG
81641: PUSH
81642: EMPTY
81643: LIST
81644: LIST
81645: PUSH
81646: LD_INT 2
81648: PUSH
81649: LD_INT 1
81651: NEG
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: PUSH
81657: LD_INT 3
81659: PUSH
81660: LD_INT 1
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_INT 3
81669: PUSH
81670: LD_INT 2
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81702: LD_ADDR_VAR 0 25
81706: PUSH
81707: LD_INT 0
81709: PUSH
81710: LD_INT 0
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 0
81719: PUSH
81720: LD_INT 1
81722: NEG
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 1
81730: PUSH
81731: LD_INT 0
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 1
81740: PUSH
81741: LD_INT 1
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: PUSH
81748: LD_INT 0
81750: PUSH
81751: LD_INT 1
81753: PUSH
81754: EMPTY
81755: LIST
81756: LIST
81757: PUSH
81758: LD_INT 1
81760: NEG
81761: PUSH
81762: LD_INT 0
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 1
81771: NEG
81772: PUSH
81773: LD_INT 1
81775: NEG
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 1
81783: NEG
81784: PUSH
81785: LD_INT 2
81787: NEG
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 0
81795: PUSH
81796: LD_INT 2
81798: NEG
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: PUSH
81804: LD_INT 1
81806: PUSH
81807: LD_INT 1
81809: NEG
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 2
81817: PUSH
81818: LD_INT 0
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: LD_INT 2
81827: PUSH
81828: LD_INT 1
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 2
81837: PUSH
81838: LD_INT 2
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 1
81847: PUSH
81848: LD_INT 2
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 0
81857: PUSH
81858: LD_INT 2
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 1
81867: NEG
81868: PUSH
81869: LD_INT 1
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 2
81878: NEG
81879: PUSH
81880: LD_INT 0
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 2
81889: NEG
81890: PUSH
81891: LD_INT 1
81893: NEG
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 2
81901: NEG
81902: PUSH
81903: LD_INT 2
81905: NEG
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 3
81913: PUSH
81914: LD_INT 1
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 3
81923: PUSH
81924: LD_INT 2
81926: PUSH
81927: EMPTY
81928: LIST
81929: LIST
81930: PUSH
81931: LD_INT 2
81933: PUSH
81934: LD_INT 3
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 1
81943: PUSH
81944: LD_INT 3
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81976: LD_ADDR_VAR 0 26
81980: PUSH
81981: LD_INT 0
81983: PUSH
81984: LD_INT 0
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 0
81993: PUSH
81994: LD_INT 1
81996: NEG
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 1
82004: PUSH
82005: LD_INT 0
82007: PUSH
82008: EMPTY
82009: LIST
82010: LIST
82011: PUSH
82012: LD_INT 1
82014: PUSH
82015: LD_INT 1
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 0
82024: PUSH
82025: LD_INT 1
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 1
82034: NEG
82035: PUSH
82036: LD_INT 0
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 1
82045: NEG
82046: PUSH
82047: LD_INT 1
82049: NEG
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 1
82057: NEG
82058: PUSH
82059: LD_INT 2
82061: NEG
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 0
82069: PUSH
82070: LD_INT 2
82072: NEG
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 1
82080: PUSH
82081: LD_INT 1
82083: NEG
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 2
82091: PUSH
82092: LD_INT 0
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 2
82101: PUSH
82102: LD_INT 1
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 2
82111: PUSH
82112: LD_INT 2
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: PUSH
82122: LD_INT 2
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 0
82131: PUSH
82132: LD_INT 2
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 1
82141: NEG
82142: PUSH
82143: LD_INT 1
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 2
82152: NEG
82153: PUSH
82154: LD_INT 0
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 2
82163: NEG
82164: PUSH
82165: LD_INT 1
82167: NEG
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: LD_INT 2
82175: NEG
82176: PUSH
82177: LD_INT 2
82179: NEG
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 2
82187: PUSH
82188: LD_INT 3
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 1
82197: PUSH
82198: LD_INT 3
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 1
82207: NEG
82208: PUSH
82209: LD_INT 2
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 2
82218: NEG
82219: PUSH
82220: LD_INT 1
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82252: LD_ADDR_VAR 0 27
82256: PUSH
82257: LD_INT 0
82259: PUSH
82260: LD_INT 0
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: PUSH
82267: LD_INT 0
82269: PUSH
82270: LD_INT 1
82272: NEG
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 1
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 1
82290: PUSH
82291: LD_INT 1
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 0
82300: PUSH
82301: LD_INT 1
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 1
82310: NEG
82311: PUSH
82312: LD_INT 0
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 1
82321: NEG
82322: PUSH
82323: LD_INT 1
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 1
82333: NEG
82334: PUSH
82335: LD_INT 2
82337: NEG
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 0
82345: PUSH
82346: LD_INT 2
82348: NEG
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 1
82356: PUSH
82357: LD_INT 1
82359: NEG
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: PUSH
82365: LD_INT 2
82367: PUSH
82368: LD_INT 0
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 2
82377: PUSH
82378: LD_INT 1
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: LD_INT 2
82387: PUSH
82388: LD_INT 2
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 1
82397: PUSH
82398: LD_INT 2
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 0
82407: PUSH
82408: LD_INT 2
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 1
82417: NEG
82418: PUSH
82419: LD_INT 1
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 2
82428: NEG
82429: PUSH
82430: LD_INT 0
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 2
82439: NEG
82440: PUSH
82441: LD_INT 1
82443: NEG
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 2
82451: NEG
82452: PUSH
82453: LD_INT 2
82455: NEG
82456: PUSH
82457: EMPTY
82458: LIST
82459: LIST
82460: PUSH
82461: LD_INT 1
82463: NEG
82464: PUSH
82465: LD_INT 2
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 2
82474: NEG
82475: PUSH
82476: LD_INT 1
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 3
82485: NEG
82486: PUSH
82487: LD_INT 1
82489: NEG
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 3
82497: NEG
82498: PUSH
82499: LD_INT 2
82501: NEG
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: EMPTY
82508: LIST
82509: LIST
82510: LIST
82511: LIST
82512: LIST
82513: LIST
82514: LIST
82515: LIST
82516: LIST
82517: LIST
82518: LIST
82519: LIST
82520: LIST
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82532: LD_ADDR_VAR 0 28
82536: PUSH
82537: LD_INT 0
82539: PUSH
82540: LD_INT 0
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: PUSH
82547: LD_INT 0
82549: PUSH
82550: LD_INT 1
82552: NEG
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 1
82560: PUSH
82561: LD_INT 0
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 1
82570: PUSH
82571: LD_INT 1
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 0
82580: PUSH
82581: LD_INT 1
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 1
82590: NEG
82591: PUSH
82592: LD_INT 0
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 1
82601: NEG
82602: PUSH
82603: LD_INT 1
82605: NEG
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 1
82613: NEG
82614: PUSH
82615: LD_INT 2
82617: NEG
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 0
82625: PUSH
82626: LD_INT 2
82628: NEG
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: PUSH
82634: LD_INT 1
82636: PUSH
82637: LD_INT 1
82639: NEG
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 2
82647: PUSH
82648: LD_INT 0
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 2
82657: PUSH
82658: LD_INT 1
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 2
82667: PUSH
82668: LD_INT 2
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 1
82677: PUSH
82678: LD_INT 2
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 0
82687: PUSH
82688: LD_INT 2
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 1
82697: NEG
82698: PUSH
82699: LD_INT 1
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: PUSH
82706: LD_INT 2
82708: NEG
82709: PUSH
82710: LD_INT 0
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 2
82719: NEG
82720: PUSH
82721: LD_INT 1
82723: NEG
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 2
82731: NEG
82732: PUSH
82733: LD_INT 2
82735: NEG
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 2
82743: NEG
82744: PUSH
82745: LD_INT 3
82747: NEG
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: LD_INT 1
82755: NEG
82756: PUSH
82757: LD_INT 3
82759: NEG
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 3
82767: NEG
82768: PUSH
82769: LD_INT 1
82771: NEG
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 3
82779: NEG
82780: PUSH
82781: LD_INT 2
82783: NEG
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82814: LD_ADDR_VAR 0 29
82818: PUSH
82819: LD_INT 0
82821: PUSH
82822: LD_INT 0
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 0
82831: PUSH
82832: LD_INT 1
82834: NEG
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: LD_INT 1
82842: PUSH
82843: LD_INT 0
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 1
82852: PUSH
82853: LD_INT 1
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 0
82862: PUSH
82863: LD_INT 1
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 1
82872: NEG
82873: PUSH
82874: LD_INT 0
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 1
82883: NEG
82884: PUSH
82885: LD_INT 1
82887: NEG
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 1
82895: NEG
82896: PUSH
82897: LD_INT 2
82899: NEG
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 0
82907: PUSH
82908: LD_INT 2
82910: NEG
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 1
82918: PUSH
82919: LD_INT 1
82921: NEG
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 2
82929: PUSH
82930: LD_INT 0
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 2
82939: PUSH
82940: LD_INT 1
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 1
82949: PUSH
82950: LD_INT 2
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 0
82959: PUSH
82960: LD_INT 2
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: NEG
82970: PUSH
82971: LD_INT 1
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 2
82980: NEG
82981: PUSH
82982: LD_INT 1
82984: NEG
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 2
82992: NEG
82993: PUSH
82994: LD_INT 2
82996: NEG
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: LD_INT 2
83004: NEG
83005: PUSH
83006: LD_INT 3
83008: NEG
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 2
83016: PUSH
83017: LD_INT 1
83019: NEG
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 3
83027: PUSH
83028: LD_INT 1
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 1
83037: PUSH
83038: LD_INT 3
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 1
83047: NEG
83048: PUSH
83049: LD_INT 2
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 3
83058: NEG
83059: PUSH
83060: LD_INT 2
83062: NEG
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83093: LD_ADDR_VAR 0 30
83097: PUSH
83098: LD_INT 0
83100: PUSH
83101: LD_INT 0
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 0
83110: PUSH
83111: LD_INT 1
83113: NEG
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 1
83121: PUSH
83122: LD_INT 0
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 1
83131: PUSH
83132: LD_INT 1
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 0
83141: PUSH
83142: LD_INT 1
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: LD_INT 0
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 1
83162: NEG
83163: PUSH
83164: LD_INT 1
83166: NEG
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 1
83174: NEG
83175: PUSH
83176: LD_INT 2
83178: NEG
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 0
83186: PUSH
83187: LD_INT 2
83189: NEG
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 1
83197: PUSH
83198: LD_INT 1
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 2
83208: PUSH
83209: LD_INT 0
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: PUSH
83216: LD_INT 2
83218: PUSH
83219: LD_INT 1
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 2
83228: PUSH
83229: LD_INT 2
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 1
83238: PUSH
83239: LD_INT 2
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PUSH
83246: LD_INT 1
83248: NEG
83249: PUSH
83250: LD_INT 1
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 2
83259: NEG
83260: PUSH
83261: LD_INT 0
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 2
83270: NEG
83271: PUSH
83272: LD_INT 1
83274: NEG
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: LD_INT 3
83286: NEG
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 1
83294: PUSH
83295: LD_INT 2
83297: NEG
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 3
83305: PUSH
83306: LD_INT 2
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 2
83315: PUSH
83316: LD_INT 3
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 2
83325: NEG
83326: PUSH
83327: LD_INT 1
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 3
83336: NEG
83337: PUSH
83338: LD_INT 1
83340: NEG
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83371: LD_ADDR_VAR 0 31
83375: PUSH
83376: LD_INT 0
83378: PUSH
83379: LD_INT 0
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 0
83388: PUSH
83389: LD_INT 1
83391: NEG
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 1
83399: PUSH
83400: LD_INT 0
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 1
83409: PUSH
83410: LD_INT 1
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 0
83419: PUSH
83420: LD_INT 1
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 1
83429: NEG
83430: PUSH
83431: LD_INT 0
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: LD_INT 1
83440: NEG
83441: PUSH
83442: LD_INT 1
83444: NEG
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 1
83452: NEG
83453: PUSH
83454: LD_INT 2
83456: NEG
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 1
83464: PUSH
83465: LD_INT 1
83467: NEG
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 2
83475: PUSH
83476: LD_INT 0
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 2
83485: PUSH
83486: LD_INT 1
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: PUSH
83493: LD_INT 2
83495: PUSH
83496: LD_INT 2
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 1
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 0
83515: PUSH
83516: LD_INT 2
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 1
83525: NEG
83526: PUSH
83527: LD_INT 1
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 2
83536: NEG
83537: PUSH
83538: LD_INT 1
83540: NEG
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 2
83548: NEG
83549: PUSH
83550: LD_INT 2
83552: NEG
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 2
83560: NEG
83561: PUSH
83562: LD_INT 3
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 2
83572: PUSH
83573: LD_INT 1
83575: NEG
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 3
83583: PUSH
83584: LD_INT 1
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 1
83593: PUSH
83594: LD_INT 3
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 1
83603: NEG
83604: PUSH
83605: LD_INT 2
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 3
83614: NEG
83615: PUSH
83616: LD_INT 2
83618: NEG
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83649: LD_ADDR_VAR 0 32
83653: PUSH
83654: LD_INT 0
83656: PUSH
83657: LD_INT 0
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 0
83666: PUSH
83667: LD_INT 1
83669: NEG
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 1
83677: PUSH
83678: LD_INT 0
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 1
83687: PUSH
83688: LD_INT 1
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: LD_INT 0
83697: PUSH
83698: LD_INT 1
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 1
83707: NEG
83708: PUSH
83709: LD_INT 0
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PUSH
83716: LD_INT 1
83718: NEG
83719: PUSH
83720: LD_INT 1
83722: NEG
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: PUSH
83728: LD_INT 1
83730: NEG
83731: PUSH
83732: LD_INT 2
83734: NEG
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PUSH
83740: LD_INT 0
83742: PUSH
83743: LD_INT 2
83745: NEG
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 1
83753: PUSH
83754: LD_INT 1
83756: NEG
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 2
83764: PUSH
83765: LD_INT 1
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 2
83774: PUSH
83775: LD_INT 2
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 1
83784: PUSH
83785: LD_INT 2
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 0
83794: PUSH
83795: LD_INT 2
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 1
83804: NEG
83805: PUSH
83806: LD_INT 1
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: PUSH
83813: LD_INT 2
83815: NEG
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 2
83826: NEG
83827: PUSH
83828: LD_INT 1
83830: NEG
83831: PUSH
83832: EMPTY
83833: LIST
83834: LIST
83835: PUSH
83836: LD_INT 1
83838: NEG
83839: PUSH
83840: LD_INT 3
83842: NEG
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: PUSH
83851: LD_INT 2
83853: NEG
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 3
83861: PUSH
83862: LD_INT 2
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 2
83871: PUSH
83872: LD_INT 3
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 2
83881: NEG
83882: PUSH
83883: LD_INT 1
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 3
83892: NEG
83893: PUSH
83894: LD_INT 1
83896: NEG
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: LIST
83906: LIST
83907: LIST
83908: LIST
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83927: LD_ADDR_VAR 0 33
83931: PUSH
83932: LD_INT 0
83934: PUSH
83935: LD_INT 0
83937: PUSH
83938: EMPTY
83939: LIST
83940: LIST
83941: PUSH
83942: LD_INT 0
83944: PUSH
83945: LD_INT 1
83947: NEG
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 1
83955: PUSH
83956: LD_INT 0
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 1
83965: PUSH
83966: LD_INT 1
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 0
83975: PUSH
83976: LD_INT 1
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 1
83985: NEG
83986: PUSH
83987: LD_INT 0
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 1
83996: NEG
83997: PUSH
83998: LD_INT 1
84000: NEG
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: NEG
84009: PUSH
84010: LD_INT 2
84012: NEG
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 1
84020: PUSH
84021: LD_INT 1
84023: NEG
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 2
84031: PUSH
84032: LD_INT 0
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: LD_INT 2
84041: PUSH
84042: LD_INT 1
84044: PUSH
84045: EMPTY
84046: LIST
84047: LIST
84048: PUSH
84049: LD_INT 1
84051: PUSH
84052: LD_INT 2
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 0
84061: PUSH
84062: LD_INT 2
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 1
84071: NEG
84072: PUSH
84073: LD_INT 1
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 2
84082: NEG
84083: PUSH
84084: LD_INT 0
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 2
84093: NEG
84094: PUSH
84095: LD_INT 1
84097: NEG
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 2
84105: NEG
84106: PUSH
84107: LD_INT 2
84109: NEG
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 2
84117: NEG
84118: PUSH
84119: LD_INT 3
84121: NEG
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 2
84129: PUSH
84130: LD_INT 1
84132: NEG
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 3
84140: PUSH
84141: LD_INT 1
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: LD_INT 1
84150: PUSH
84151: LD_INT 3
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: LD_INT 1
84160: NEG
84161: PUSH
84162: LD_INT 2
84164: PUSH
84165: EMPTY
84166: LIST
84167: LIST
84168: PUSH
84169: LD_INT 3
84171: NEG
84172: PUSH
84173: LD_INT 2
84175: NEG
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: LIST
84185: LIST
84186: LIST
84187: LIST
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: LIST
84193: LIST
84194: LIST
84195: LIST
84196: LIST
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84206: LD_ADDR_VAR 0 34
84210: PUSH
84211: LD_INT 0
84213: PUSH
84214: LD_INT 0
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 0
84223: PUSH
84224: LD_INT 1
84226: NEG
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 1
84234: PUSH
84235: LD_INT 0
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: LD_INT 1
84244: PUSH
84245: LD_INT 1
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 0
84254: PUSH
84255: LD_INT 1
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 1
84264: NEG
84265: PUSH
84266: LD_INT 0
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 1
84275: NEG
84276: PUSH
84277: LD_INT 1
84279: NEG
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 1
84287: NEG
84288: PUSH
84289: LD_INT 2
84291: NEG
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 0
84299: PUSH
84300: LD_INT 2
84302: NEG
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 1
84310: PUSH
84311: LD_INT 1
84313: NEG
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 2
84321: PUSH
84322: LD_INT 1
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: PUSH
84329: LD_INT 2
84331: PUSH
84332: LD_INT 2
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 1
84341: PUSH
84342: LD_INT 2
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 1
84351: NEG
84352: PUSH
84353: LD_INT 1
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 2
84362: NEG
84363: PUSH
84364: LD_INT 0
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 2
84373: NEG
84374: PUSH
84375: LD_INT 1
84377: NEG
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 2
84385: NEG
84386: PUSH
84387: LD_INT 2
84389: NEG
84390: PUSH
84391: EMPTY
84392: LIST
84393: LIST
84394: PUSH
84395: LD_INT 1
84397: NEG
84398: PUSH
84399: LD_INT 3
84401: NEG
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: PUSH
84407: LD_INT 1
84409: PUSH
84410: LD_INT 2
84412: NEG
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: LD_INT 3
84420: PUSH
84421: LD_INT 2
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 2
84430: PUSH
84431: LD_INT 3
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 2
84440: NEG
84441: PUSH
84442: LD_INT 1
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 3
84451: NEG
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84486: LD_ADDR_VAR 0 35
84490: PUSH
84491: LD_INT 0
84493: PUSH
84494: LD_INT 0
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 0
84503: PUSH
84504: LD_INT 1
84506: NEG
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: LD_INT 1
84514: PUSH
84515: LD_INT 0
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 1
84524: PUSH
84525: LD_INT 1
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: PUSH
84532: LD_INT 0
84534: PUSH
84535: LD_INT 1
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 1
84544: NEG
84545: PUSH
84546: LD_INT 0
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 1
84555: NEG
84556: PUSH
84557: LD_INT 1
84559: NEG
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: PUSH
84565: LD_INT 2
84567: PUSH
84568: LD_INT 1
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 2
84577: NEG
84578: PUSH
84579: LD_INT 1
84581: NEG
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84598: LD_ADDR_VAR 0 36
84602: PUSH
84603: LD_INT 0
84605: PUSH
84606: LD_INT 0
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 0
84615: PUSH
84616: LD_INT 1
84618: NEG
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 1
84626: PUSH
84627: LD_INT 0
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 1
84636: PUSH
84637: LD_INT 1
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: PUSH
84644: LD_INT 0
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 1
84656: NEG
84657: PUSH
84658: LD_INT 0
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 1
84667: NEG
84668: PUSH
84669: LD_INT 1
84671: NEG
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: PUSH
84677: LD_INT 1
84679: NEG
84680: PUSH
84681: LD_INT 2
84683: NEG
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 1
84691: PUSH
84692: LD_INT 2
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84710: LD_ADDR_VAR 0 37
84714: PUSH
84715: LD_INT 0
84717: PUSH
84718: LD_INT 0
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: PUSH
84725: LD_INT 0
84727: PUSH
84728: LD_INT 1
84730: NEG
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: LD_INT 1
84738: PUSH
84739: LD_INT 0
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: PUSH
84746: LD_INT 1
84748: PUSH
84749: LD_INT 1
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: LD_INT 0
84758: PUSH
84759: LD_INT 1
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: PUSH
84766: LD_INT 1
84768: NEG
84769: PUSH
84770: LD_INT 0
84772: PUSH
84773: EMPTY
84774: LIST
84775: LIST
84776: PUSH
84777: LD_INT 1
84779: NEG
84780: PUSH
84781: LD_INT 1
84783: NEG
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 1
84791: PUSH
84792: LD_INT 1
84794: NEG
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 1
84802: NEG
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84822: LD_ADDR_VAR 0 38
84826: PUSH
84827: LD_INT 0
84829: PUSH
84830: LD_INT 0
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 0
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 1
84850: PUSH
84851: LD_INT 0
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 1
84860: PUSH
84861: LD_INT 1
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PUSH
84868: LD_INT 0
84870: PUSH
84871: LD_INT 1
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: LD_INT 0
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 1
84891: NEG
84892: PUSH
84893: LD_INT 1
84895: NEG
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: LD_INT 2
84903: PUSH
84904: LD_INT 1
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: PUSH
84911: LD_INT 2
84913: NEG
84914: PUSH
84915: LD_INT 1
84917: NEG
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84934: LD_ADDR_VAR 0 39
84938: PUSH
84939: LD_INT 0
84941: PUSH
84942: LD_INT 0
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 0
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 1
84962: PUSH
84963: LD_INT 0
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 1
84972: PUSH
84973: LD_INT 1
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 0
84982: PUSH
84983: LD_INT 1
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 1
84992: NEG
84993: PUSH
84994: LD_INT 0
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 1
85003: NEG
85004: PUSH
85005: LD_INT 1
85007: NEG
85008: PUSH
85009: EMPTY
85010: LIST
85011: LIST
85012: PUSH
85013: LD_INT 1
85015: NEG
85016: PUSH
85017: LD_INT 2
85019: NEG
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 1
85027: PUSH
85028: LD_INT 2
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85046: LD_ADDR_VAR 0 40
85050: PUSH
85051: LD_INT 0
85053: PUSH
85054: LD_INT 0
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 0
85063: PUSH
85064: LD_INT 1
85066: NEG
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 1
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 1
85084: PUSH
85085: LD_INT 1
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: PUSH
85092: LD_INT 0
85094: PUSH
85095: LD_INT 1
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 1
85104: NEG
85105: PUSH
85106: LD_INT 0
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_INT 1
85115: NEG
85116: PUSH
85117: LD_INT 1
85119: NEG
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_INT 1
85127: PUSH
85128: LD_INT 1
85130: NEG
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 1
85138: NEG
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85158: LD_ADDR_VAR 0 41
85162: PUSH
85163: LD_INT 0
85165: PUSH
85166: LD_INT 0
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 0
85175: PUSH
85176: LD_INT 1
85178: NEG
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: LD_INT 1
85186: PUSH
85187: LD_INT 0
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: LD_INT 1
85196: PUSH
85197: LD_INT 1
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 0
85206: PUSH
85207: LD_INT 1
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: PUSH
85214: LD_INT 1
85216: NEG
85217: PUSH
85218: LD_INT 0
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 1
85227: NEG
85228: PUSH
85229: LD_INT 1
85231: NEG
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 1
85239: NEG
85240: PUSH
85241: LD_INT 2
85243: NEG
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 1
85251: PUSH
85252: LD_INT 1
85254: NEG
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: PUSH
85260: LD_INT 2
85262: PUSH
85263: LD_INT 0
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: PUSH
85270: LD_INT 2
85272: PUSH
85273: LD_INT 1
85275: PUSH
85276: EMPTY
85277: LIST
85278: LIST
85279: PUSH
85280: LD_INT 2
85282: PUSH
85283: LD_INT 2
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 1
85292: PUSH
85293: LD_INT 2
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 1
85302: NEG
85303: PUSH
85304: LD_INT 1
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 2
85313: NEG
85314: PUSH
85315: LD_INT 0
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: NEG
85325: PUSH
85326: LD_INT 1
85328: NEG
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 2
85336: NEG
85337: PUSH
85338: LD_INT 2
85340: NEG
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 2
85348: NEG
85349: PUSH
85350: LD_INT 3
85352: NEG
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 2
85360: PUSH
85361: LD_INT 1
85363: NEG
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 3
85371: PUSH
85372: LD_INT 0
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: LD_INT 3
85381: PUSH
85382: LD_INT 1
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: PUSH
85389: LD_INT 3
85391: PUSH
85392: LD_INT 2
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: PUSH
85399: LD_INT 3
85401: PUSH
85402: LD_INT 3
85404: PUSH
85405: EMPTY
85406: LIST
85407: LIST
85408: PUSH
85409: LD_INT 2
85411: PUSH
85412: LD_INT 3
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 2
85421: NEG
85422: PUSH
85423: LD_INT 1
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 3
85432: NEG
85433: PUSH
85434: LD_INT 0
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 3
85443: NEG
85444: PUSH
85445: LD_INT 1
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 3
85455: NEG
85456: PUSH
85457: LD_INT 2
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 3
85467: NEG
85468: PUSH
85469: LD_INT 3
85471: NEG
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85508: LD_ADDR_VAR 0 42
85512: PUSH
85513: LD_INT 0
85515: PUSH
85516: LD_INT 0
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 0
85525: PUSH
85526: LD_INT 1
85528: NEG
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 1
85536: PUSH
85537: LD_INT 0
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: PUSH
85544: LD_INT 1
85546: PUSH
85547: LD_INT 1
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: PUSH
85554: LD_INT 0
85556: PUSH
85557: LD_INT 1
85559: PUSH
85560: EMPTY
85561: LIST
85562: LIST
85563: PUSH
85564: LD_INT 1
85566: NEG
85567: PUSH
85568: LD_INT 0
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 1
85577: NEG
85578: PUSH
85579: LD_INT 1
85581: NEG
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 1
85589: NEG
85590: PUSH
85591: LD_INT 2
85593: NEG
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 0
85601: PUSH
85602: LD_INT 2
85604: NEG
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: LD_INT 1
85612: PUSH
85613: LD_INT 1
85615: NEG
85616: PUSH
85617: EMPTY
85618: LIST
85619: LIST
85620: PUSH
85621: LD_INT 2
85623: PUSH
85624: LD_INT 1
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 2
85633: PUSH
85634: LD_INT 2
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: PUSH
85641: LD_INT 1
85643: PUSH
85644: LD_INT 2
85646: PUSH
85647: EMPTY
85648: LIST
85649: LIST
85650: PUSH
85651: LD_INT 0
85653: PUSH
85654: LD_INT 2
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PUSH
85661: LD_INT 1
85663: NEG
85664: PUSH
85665: LD_INT 1
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 2
85674: NEG
85675: PUSH
85676: LD_INT 1
85678: NEG
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: PUSH
85684: LD_INT 2
85686: NEG
85687: PUSH
85688: LD_INT 2
85690: NEG
85691: PUSH
85692: EMPTY
85693: LIST
85694: LIST
85695: PUSH
85696: LD_INT 2
85698: NEG
85699: PUSH
85700: LD_INT 3
85702: NEG
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 1
85710: NEG
85711: PUSH
85712: LD_INT 3
85714: NEG
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: LD_INT 0
85722: PUSH
85723: LD_INT 3
85725: NEG
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 1
85733: PUSH
85734: LD_INT 2
85736: NEG
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: LD_INT 3
85744: PUSH
85745: LD_INT 2
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: PUSH
85752: LD_INT 3
85754: PUSH
85755: LD_INT 3
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 2
85764: PUSH
85765: LD_INT 3
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 1
85774: PUSH
85775: LD_INT 3
85777: PUSH
85778: EMPTY
85779: LIST
85780: LIST
85781: PUSH
85782: LD_INT 0
85784: PUSH
85785: LD_INT 3
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 1
85794: NEG
85795: PUSH
85796: LD_INT 2
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 3
85805: NEG
85806: PUSH
85807: LD_INT 2
85809: NEG
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 3
85817: NEG
85818: PUSH
85819: LD_INT 3
85821: NEG
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: LIST
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85858: LD_ADDR_VAR 0 43
85862: PUSH
85863: LD_INT 0
85865: PUSH
85866: LD_INT 0
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: PUSH
85873: LD_INT 0
85875: PUSH
85876: LD_INT 1
85878: NEG
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 1
85886: PUSH
85887: LD_INT 0
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 1
85896: PUSH
85897: LD_INT 1
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_INT 0
85906: PUSH
85907: LD_INT 1
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: LD_INT 0
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: LD_INT 1
85927: NEG
85928: PUSH
85929: LD_INT 1
85931: NEG
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 1
85939: NEG
85940: PUSH
85941: LD_INT 2
85943: NEG
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PUSH
85949: LD_INT 0
85951: PUSH
85952: LD_INT 2
85954: NEG
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: LD_INT 1
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 2
85973: PUSH
85974: LD_INT 0
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 2
85983: PUSH
85984: LD_INT 1
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 1
85993: PUSH
85994: LD_INT 2
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 0
86003: PUSH
86004: LD_INT 2
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: PUSH
86011: LD_INT 1
86013: NEG
86014: PUSH
86015: LD_INT 1
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 2
86024: NEG
86025: PUSH
86026: LD_INT 0
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 2
86035: NEG
86036: PUSH
86037: LD_INT 1
86039: NEG
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: LD_INT 1
86047: NEG
86048: PUSH
86049: LD_INT 3
86051: NEG
86052: PUSH
86053: EMPTY
86054: LIST
86055: LIST
86056: PUSH
86057: LD_INT 0
86059: PUSH
86060: LD_INT 3
86062: NEG
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 1
86070: PUSH
86071: LD_INT 2
86073: NEG
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 2
86081: PUSH
86082: LD_INT 1
86084: NEG
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 3
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 3
86102: PUSH
86103: LD_INT 1
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 1
86112: PUSH
86113: LD_INT 3
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: LD_INT 3
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: NEG
86133: PUSH
86134: LD_INT 2
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 2
86143: NEG
86144: PUSH
86145: LD_INT 1
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 3
86154: NEG
86155: PUSH
86156: LD_INT 0
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 3
86165: NEG
86166: PUSH
86167: LD_INT 1
86169: NEG
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86206: LD_ADDR_VAR 0 44
86210: PUSH
86211: LD_INT 0
86213: PUSH
86214: LD_INT 0
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: LD_INT 0
86223: PUSH
86224: LD_INT 1
86226: NEG
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 1
86234: PUSH
86235: LD_INT 0
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 1
86244: PUSH
86245: LD_INT 1
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PUSH
86252: LD_INT 0
86254: PUSH
86255: LD_INT 1
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 1
86264: NEG
86265: PUSH
86266: LD_INT 0
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 1
86275: NEG
86276: PUSH
86277: LD_INT 1
86279: NEG
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 1
86287: NEG
86288: PUSH
86289: LD_INT 2
86291: NEG
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: LD_INT 1
86299: PUSH
86300: LD_INT 1
86302: NEG
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 2
86310: PUSH
86311: LD_INT 0
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: LD_INT 2
86320: PUSH
86321: LD_INT 1
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: LD_INT 2
86330: PUSH
86331: LD_INT 2
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: PUSH
86338: LD_INT 1
86340: PUSH
86341: LD_INT 2
86343: PUSH
86344: EMPTY
86345: LIST
86346: LIST
86347: PUSH
86348: LD_INT 1
86350: NEG
86351: PUSH
86352: LD_INT 1
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 2
86361: NEG
86362: PUSH
86363: LD_INT 0
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 2
86372: NEG
86373: PUSH
86374: LD_INT 1
86376: NEG
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 2
86384: NEG
86385: PUSH
86386: LD_INT 2
86388: NEG
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 2
86396: NEG
86397: PUSH
86398: LD_INT 3
86400: NEG
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 2
86408: PUSH
86409: LD_INT 1
86411: NEG
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 3
86419: PUSH
86420: LD_INT 0
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: PUSH
86427: LD_INT 3
86429: PUSH
86430: LD_INT 1
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: PUSH
86437: LD_INT 3
86439: PUSH
86440: LD_INT 2
86442: PUSH
86443: EMPTY
86444: LIST
86445: LIST
86446: PUSH
86447: LD_INT 3
86449: PUSH
86450: LD_INT 3
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 2
86459: PUSH
86460: LD_INT 3
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 2
86469: NEG
86470: PUSH
86471: LD_INT 1
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 3
86480: NEG
86481: PUSH
86482: LD_INT 0
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 3
86491: NEG
86492: PUSH
86493: LD_INT 1
86495: NEG
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 3
86503: NEG
86504: PUSH
86505: LD_INT 2
86507: NEG
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 3
86515: NEG
86516: PUSH
86517: LD_INT 3
86519: NEG
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: LIST
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86556: LD_ADDR_VAR 0 45
86560: PUSH
86561: LD_INT 0
86563: PUSH
86564: LD_INT 0
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 0
86573: PUSH
86574: LD_INT 1
86576: NEG
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: PUSH
86582: LD_INT 1
86584: PUSH
86585: LD_INT 0
86587: PUSH
86588: EMPTY
86589: LIST
86590: LIST
86591: PUSH
86592: LD_INT 1
86594: PUSH
86595: LD_INT 1
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: PUSH
86602: LD_INT 0
86604: PUSH
86605: LD_INT 1
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 1
86614: NEG
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 1
86625: NEG
86626: PUSH
86627: LD_INT 1
86629: NEG
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 1
86637: NEG
86638: PUSH
86639: LD_INT 2
86641: NEG
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 0
86649: PUSH
86650: LD_INT 2
86652: NEG
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: PUSH
86658: LD_INT 1
86660: PUSH
86661: LD_INT 1
86663: NEG
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PUSH
86669: LD_INT 2
86671: PUSH
86672: LD_INT 1
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PUSH
86679: LD_INT 2
86681: PUSH
86682: LD_INT 2
86684: PUSH
86685: EMPTY
86686: LIST
86687: LIST
86688: PUSH
86689: LD_INT 1
86691: PUSH
86692: LD_INT 2
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 0
86701: PUSH
86702: LD_INT 2
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 1
86711: NEG
86712: PUSH
86713: LD_INT 1
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 2
86722: NEG
86723: PUSH
86724: LD_INT 1
86726: NEG
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PUSH
86732: LD_INT 2
86734: NEG
86735: PUSH
86736: LD_INT 2
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 2
86746: NEG
86747: PUSH
86748: LD_INT 3
86750: NEG
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: NEG
86759: PUSH
86760: LD_INT 3
86762: NEG
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PUSH
86768: LD_INT 0
86770: PUSH
86771: LD_INT 3
86773: NEG
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 1
86781: PUSH
86782: LD_INT 2
86784: NEG
86785: PUSH
86786: EMPTY
86787: LIST
86788: LIST
86789: PUSH
86790: LD_INT 3
86792: PUSH
86793: LD_INT 2
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 3
86802: PUSH
86803: LD_INT 3
86805: PUSH
86806: EMPTY
86807: LIST
86808: LIST
86809: PUSH
86810: LD_INT 2
86812: PUSH
86813: LD_INT 3
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: LD_INT 1
86822: PUSH
86823: LD_INT 3
86825: PUSH
86826: EMPTY
86827: LIST
86828: LIST
86829: PUSH
86830: LD_INT 0
86832: PUSH
86833: LD_INT 3
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PUSH
86840: LD_INT 1
86842: NEG
86843: PUSH
86844: LD_INT 2
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: LD_INT 3
86853: NEG
86854: PUSH
86855: LD_INT 2
86857: NEG
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PUSH
86863: LD_INT 3
86865: NEG
86866: PUSH
86867: LD_INT 3
86869: NEG
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86906: LD_ADDR_VAR 0 46
86910: PUSH
86911: LD_INT 0
86913: PUSH
86914: LD_INT 0
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 0
86923: PUSH
86924: LD_INT 1
86926: NEG
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 1
86934: PUSH
86935: LD_INT 0
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: PUSH
86942: LD_INT 1
86944: PUSH
86945: LD_INT 1
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 0
86954: PUSH
86955: LD_INT 1
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 1
86964: NEG
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: LD_INT 1
86975: NEG
86976: PUSH
86977: LD_INT 1
86979: NEG
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: LD_INT 2
86991: NEG
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 0
86999: PUSH
87000: LD_INT 2
87002: NEG
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: LD_INT 1
87010: PUSH
87011: LD_INT 1
87013: NEG
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 2
87021: PUSH
87022: LD_INT 0
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 2
87031: PUSH
87032: LD_INT 1
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 1
87041: PUSH
87042: LD_INT 2
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: LD_INT 2
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 1
87061: NEG
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 2
87072: NEG
87073: PUSH
87074: LD_INT 0
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 2
87083: NEG
87084: PUSH
87085: LD_INT 1
87087: NEG
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 1
87095: NEG
87096: PUSH
87097: LD_INT 3
87099: NEG
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: LD_INT 3
87110: NEG
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: PUSH
87116: LD_INT 1
87118: PUSH
87119: LD_INT 2
87121: NEG
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: PUSH
87127: LD_INT 2
87129: PUSH
87130: LD_INT 1
87132: NEG
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: LD_INT 3
87140: PUSH
87141: LD_INT 0
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: LD_INT 3
87150: PUSH
87151: LD_INT 1
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 1
87160: PUSH
87161: LD_INT 3
87163: PUSH
87164: EMPTY
87165: LIST
87166: LIST
87167: PUSH
87168: LD_INT 0
87170: PUSH
87171: LD_INT 3
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 1
87180: NEG
87181: PUSH
87182: LD_INT 2
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 2
87191: NEG
87192: PUSH
87193: LD_INT 1
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 3
87202: NEG
87203: PUSH
87204: LD_INT 0
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 3
87213: NEG
87214: PUSH
87215: LD_INT 1
87217: NEG
87218: PUSH
87219: EMPTY
87220: LIST
87221: LIST
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87254: LD_ADDR_VAR 0 47
87258: PUSH
87259: LD_INT 0
87261: PUSH
87262: LD_INT 0
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 0
87271: PUSH
87272: LD_INT 1
87274: NEG
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 1
87282: PUSH
87283: LD_INT 0
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 1
87292: PUSH
87293: LD_INT 1
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: PUSH
87300: LD_INT 0
87302: PUSH
87303: LD_INT 1
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 1
87312: NEG
87313: PUSH
87314: LD_INT 0
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 1
87323: NEG
87324: PUSH
87325: LD_INT 1
87327: NEG
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: PUSH
87333: LD_INT 1
87335: NEG
87336: PUSH
87337: LD_INT 2
87339: NEG
87340: PUSH
87341: EMPTY
87342: LIST
87343: LIST
87344: PUSH
87345: LD_INT 0
87347: PUSH
87348: LD_INT 2
87350: NEG
87351: PUSH
87352: EMPTY
87353: LIST
87354: LIST
87355: PUSH
87356: LD_INT 1
87358: PUSH
87359: LD_INT 1
87361: NEG
87362: PUSH
87363: EMPTY
87364: LIST
87365: LIST
87366: PUSH
87367: LD_INT 2
87369: NEG
87370: PUSH
87371: LD_INT 1
87373: NEG
87374: PUSH
87375: EMPTY
87376: LIST
87377: LIST
87378: PUSH
87379: LD_INT 2
87381: NEG
87382: PUSH
87383: LD_INT 2
87385: NEG
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87405: LD_ADDR_VAR 0 48
87409: PUSH
87410: LD_INT 0
87412: PUSH
87413: LD_INT 0
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 0
87422: PUSH
87423: LD_INT 1
87425: NEG
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 1
87433: PUSH
87434: LD_INT 0
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 1
87443: PUSH
87444: LD_INT 1
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 0
87453: PUSH
87454: LD_INT 1
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 1
87463: NEG
87464: PUSH
87465: LD_INT 0
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 1
87474: NEG
87475: PUSH
87476: LD_INT 1
87478: NEG
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: LD_INT 1
87486: NEG
87487: PUSH
87488: LD_INT 2
87490: NEG
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 0
87498: PUSH
87499: LD_INT 2
87501: NEG
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PUSH
87507: LD_INT 1
87509: PUSH
87510: LD_INT 1
87512: NEG
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 2
87520: PUSH
87521: LD_INT 0
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 2
87530: PUSH
87531: LD_INT 1
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: EMPTY
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87552: LD_ADDR_VAR 0 49
87556: PUSH
87557: LD_INT 0
87559: PUSH
87560: LD_INT 0
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 0
87569: PUSH
87570: LD_INT 1
87572: NEG
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 1
87580: PUSH
87581: LD_INT 0
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: PUSH
87588: LD_INT 1
87590: PUSH
87591: LD_INT 1
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: PUSH
87598: LD_INT 0
87600: PUSH
87601: LD_INT 1
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: PUSH
87608: LD_INT 1
87610: NEG
87611: PUSH
87612: LD_INT 0
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 1
87621: NEG
87622: PUSH
87623: LD_INT 1
87625: NEG
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 1
87633: PUSH
87634: LD_INT 1
87636: NEG
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 2
87644: PUSH
87645: LD_INT 0
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: PUSH
87652: LD_INT 2
87654: PUSH
87655: LD_INT 1
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: LD_INT 2
87664: PUSH
87665: LD_INT 2
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 1
87674: PUSH
87675: LD_INT 2
87677: PUSH
87678: EMPTY
87679: LIST
87680: LIST
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87696: LD_ADDR_VAR 0 50
87700: PUSH
87701: LD_INT 0
87703: PUSH
87704: LD_INT 0
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 0
87713: PUSH
87714: LD_INT 1
87716: NEG
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 1
87724: PUSH
87725: LD_INT 0
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PUSH
87732: LD_INT 1
87734: PUSH
87735: LD_INT 1
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: PUSH
87742: LD_INT 0
87744: PUSH
87745: LD_INT 1
87747: PUSH
87748: EMPTY
87749: LIST
87750: LIST
87751: PUSH
87752: LD_INT 1
87754: NEG
87755: PUSH
87756: LD_INT 0
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 1
87765: NEG
87766: PUSH
87767: LD_INT 1
87769: NEG
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: LD_INT 2
87777: PUSH
87778: LD_INT 1
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: PUSH
87785: LD_INT 2
87787: PUSH
87788: LD_INT 2
87790: PUSH
87791: EMPTY
87792: LIST
87793: LIST
87794: PUSH
87795: LD_INT 1
87797: PUSH
87798: LD_INT 2
87800: PUSH
87801: EMPTY
87802: LIST
87803: LIST
87804: PUSH
87805: LD_INT 0
87807: PUSH
87808: LD_INT 2
87810: PUSH
87811: EMPTY
87812: LIST
87813: LIST
87814: PUSH
87815: LD_INT 1
87817: NEG
87818: PUSH
87819: LD_INT 1
87821: PUSH
87822: EMPTY
87823: LIST
87824: LIST
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87840: LD_ADDR_VAR 0 51
87844: PUSH
87845: LD_INT 0
87847: PUSH
87848: LD_INT 0
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 1
87860: NEG
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 1
87868: PUSH
87869: LD_INT 0
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 1
87878: PUSH
87879: LD_INT 1
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 0
87888: PUSH
87889: LD_INT 1
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 1
87898: NEG
87899: PUSH
87900: LD_INT 0
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 1
87909: NEG
87910: PUSH
87911: LD_INT 1
87913: NEG
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 1
87921: PUSH
87922: LD_INT 2
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 0
87931: PUSH
87932: LD_INT 2
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PUSH
87939: LD_INT 1
87941: NEG
87942: PUSH
87943: LD_INT 1
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 2
87952: NEG
87953: PUSH
87954: LD_INT 0
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 2
87963: NEG
87964: PUSH
87965: LD_INT 1
87967: NEG
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87987: LD_ADDR_VAR 0 52
87991: PUSH
87992: LD_INT 0
87994: PUSH
87995: LD_INT 0
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: LD_INT 1
88007: NEG
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 1
88015: PUSH
88016: LD_INT 0
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: PUSH
88023: LD_INT 1
88025: PUSH
88026: LD_INT 1
88028: PUSH
88029: EMPTY
88030: LIST
88031: LIST
88032: PUSH
88033: LD_INT 0
88035: PUSH
88036: LD_INT 1
88038: PUSH
88039: EMPTY
88040: LIST
88041: LIST
88042: PUSH
88043: LD_INT 1
88045: NEG
88046: PUSH
88047: LD_INT 0
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PUSH
88054: LD_INT 1
88056: NEG
88057: PUSH
88058: LD_INT 1
88060: NEG
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PUSH
88066: LD_INT 1
88068: NEG
88069: PUSH
88070: LD_INT 2
88072: NEG
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 1
88080: NEG
88081: PUSH
88082: LD_INT 1
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 2
88091: NEG
88092: PUSH
88093: LD_INT 0
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 2
88102: NEG
88103: PUSH
88104: LD_INT 1
88106: NEG
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 2
88114: NEG
88115: PUSH
88116: LD_INT 2
88118: NEG
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88138: LD_ADDR_VAR 0 53
88142: PUSH
88143: LD_INT 0
88145: PUSH
88146: LD_INT 0
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 0
88155: PUSH
88156: LD_INT 1
88158: NEG
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 1
88166: PUSH
88167: LD_INT 0
88169: PUSH
88170: EMPTY
88171: LIST
88172: LIST
88173: PUSH
88174: LD_INT 1
88176: PUSH
88177: LD_INT 1
88179: PUSH
88180: EMPTY
88181: LIST
88182: LIST
88183: PUSH
88184: LD_INT 0
88186: PUSH
88187: LD_INT 1
88189: PUSH
88190: EMPTY
88191: LIST
88192: LIST
88193: PUSH
88194: LD_INT 1
88196: NEG
88197: PUSH
88198: LD_INT 0
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 1
88207: NEG
88208: PUSH
88209: LD_INT 1
88211: NEG
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 1
88219: NEG
88220: PUSH
88221: LD_INT 2
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 0
88231: PUSH
88232: LD_INT 2
88234: NEG
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 1
88242: PUSH
88243: LD_INT 1
88245: NEG
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 2
88253: PUSH
88254: LD_INT 0
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: LD_INT 2
88263: PUSH
88264: LD_INT 1
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: PUSH
88271: LD_INT 2
88273: PUSH
88274: LD_INT 2
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 1
88283: PUSH
88284: LD_INT 2
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 0
88293: PUSH
88294: LD_INT 2
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 1
88303: NEG
88304: PUSH
88305: LD_INT 1
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 2
88314: NEG
88315: PUSH
88316: LD_INT 0
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 2
88325: NEG
88326: PUSH
88327: LD_INT 1
88329: NEG
88330: PUSH
88331: EMPTY
88332: LIST
88333: LIST
88334: PUSH
88335: LD_INT 2
88337: NEG
88338: PUSH
88339: LD_INT 2
88341: NEG
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: LIST
88353: LIST
88354: LIST
88355: LIST
88356: LIST
88357: LIST
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88368: LD_ADDR_VAR 0 54
88372: PUSH
88373: LD_INT 0
88375: PUSH
88376: LD_INT 0
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: LD_INT 0
88385: PUSH
88386: LD_INT 1
88388: NEG
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 1
88396: PUSH
88397: LD_INT 0
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 1
88406: PUSH
88407: LD_INT 1
88409: PUSH
88410: EMPTY
88411: LIST
88412: LIST
88413: PUSH
88414: LD_INT 0
88416: PUSH
88417: LD_INT 1
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: PUSH
88424: LD_INT 1
88426: NEG
88427: PUSH
88428: LD_INT 0
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 1
88437: NEG
88438: PUSH
88439: LD_INT 1
88441: NEG
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: PUSH
88447: LD_INT 1
88449: NEG
88450: PUSH
88451: LD_INT 2
88453: NEG
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: PUSH
88459: LD_INT 0
88461: PUSH
88462: LD_INT 2
88464: NEG
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: PUSH
88470: LD_INT 1
88472: PUSH
88473: LD_INT 1
88475: NEG
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 2
88483: PUSH
88484: LD_INT 0
88486: PUSH
88487: EMPTY
88488: LIST
88489: LIST
88490: PUSH
88491: LD_INT 2
88493: PUSH
88494: LD_INT 1
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: PUSH
88501: LD_INT 2
88503: PUSH
88504: LD_INT 2
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: PUSH
88511: LD_INT 1
88513: PUSH
88514: LD_INT 2
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 0
88523: PUSH
88524: LD_INT 2
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 1
88533: NEG
88534: PUSH
88535: LD_INT 1
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 2
88544: NEG
88545: PUSH
88546: LD_INT 0
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 2
88555: NEG
88556: PUSH
88557: LD_INT 1
88559: NEG
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 2
88567: NEG
88568: PUSH
88569: LD_INT 2
88571: NEG
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88598: LD_ADDR_VAR 0 55
88602: PUSH
88603: LD_INT 0
88605: PUSH
88606: LD_INT 0
88608: PUSH
88609: EMPTY
88610: LIST
88611: LIST
88612: PUSH
88613: LD_INT 0
88615: PUSH
88616: LD_INT 1
88618: NEG
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: PUSH
88624: LD_INT 1
88626: PUSH
88627: LD_INT 0
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: LD_INT 1
88636: PUSH
88637: LD_INT 1
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: PUSH
88644: LD_INT 0
88646: PUSH
88647: LD_INT 1
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 1
88656: NEG
88657: PUSH
88658: LD_INT 0
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 1
88667: NEG
88668: PUSH
88669: LD_INT 1
88671: NEG
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 1
88679: NEG
88680: PUSH
88681: LD_INT 2
88683: NEG
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 0
88691: PUSH
88692: LD_INT 2
88694: NEG
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: PUSH
88700: LD_INT 1
88702: PUSH
88703: LD_INT 1
88705: NEG
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 2
88713: PUSH
88714: LD_INT 0
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: LD_INT 2
88723: PUSH
88724: LD_INT 1
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: PUSH
88731: LD_INT 2
88733: PUSH
88734: LD_INT 2
88736: PUSH
88737: EMPTY
88738: LIST
88739: LIST
88740: PUSH
88741: LD_INT 1
88743: PUSH
88744: LD_INT 2
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 0
88753: PUSH
88754: LD_INT 2
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: PUSH
88761: LD_INT 1
88763: NEG
88764: PUSH
88765: LD_INT 1
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 2
88774: NEG
88775: PUSH
88776: LD_INT 0
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 2
88785: NEG
88786: PUSH
88787: LD_INT 1
88789: NEG
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: PUSH
88795: LD_INT 2
88797: NEG
88798: PUSH
88799: LD_INT 2
88801: NEG
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88828: LD_ADDR_VAR 0 56
88832: PUSH
88833: LD_INT 0
88835: PUSH
88836: LD_INT 0
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: PUSH
88843: LD_INT 0
88845: PUSH
88846: LD_INT 1
88848: NEG
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 1
88856: PUSH
88857: LD_INT 0
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: PUSH
88864: LD_INT 1
88866: PUSH
88867: LD_INT 1
88869: PUSH
88870: EMPTY
88871: LIST
88872: LIST
88873: PUSH
88874: LD_INT 0
88876: PUSH
88877: LD_INT 1
88879: PUSH
88880: EMPTY
88881: LIST
88882: LIST
88883: PUSH
88884: LD_INT 1
88886: NEG
88887: PUSH
88888: LD_INT 0
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: LD_INT 1
88897: NEG
88898: PUSH
88899: LD_INT 1
88901: NEG
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: PUSH
88907: LD_INT 1
88909: NEG
88910: PUSH
88911: LD_INT 2
88913: NEG
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: LD_INT 0
88921: PUSH
88922: LD_INT 2
88924: NEG
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: LD_INT 1
88932: PUSH
88933: LD_INT 1
88935: NEG
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: PUSH
88941: LD_INT 2
88943: PUSH
88944: LD_INT 0
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: LD_INT 2
88953: PUSH
88954: LD_INT 1
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: PUSH
88961: LD_INT 2
88963: PUSH
88964: LD_INT 2
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: PUSH
88971: LD_INT 1
88973: PUSH
88974: LD_INT 2
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 0
88983: PUSH
88984: LD_INT 2
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: PUSH
88991: LD_INT 1
88993: NEG
88994: PUSH
88995: LD_INT 1
88997: PUSH
88998: EMPTY
88999: LIST
89000: LIST
89001: PUSH
89002: LD_INT 2
89004: NEG
89005: PUSH
89006: LD_INT 0
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: PUSH
89013: LD_INT 2
89015: NEG
89016: PUSH
89017: LD_INT 1
89019: NEG
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 2
89027: NEG
89028: PUSH
89029: LD_INT 2
89031: NEG
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: LIST
89044: LIST
89045: LIST
89046: LIST
89047: LIST
89048: LIST
89049: LIST
89050: LIST
89051: LIST
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89058: LD_ADDR_VAR 0 57
89062: PUSH
89063: LD_INT 0
89065: PUSH
89066: LD_INT 0
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: LD_INT 0
89075: PUSH
89076: LD_INT 1
89078: NEG
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 1
89086: PUSH
89087: LD_INT 0
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: PUSH
89094: LD_INT 1
89096: PUSH
89097: LD_INT 1
89099: PUSH
89100: EMPTY
89101: LIST
89102: LIST
89103: PUSH
89104: LD_INT 0
89106: PUSH
89107: LD_INT 1
89109: PUSH
89110: EMPTY
89111: LIST
89112: LIST
89113: PUSH
89114: LD_INT 1
89116: NEG
89117: PUSH
89118: LD_INT 0
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: PUSH
89125: LD_INT 1
89127: NEG
89128: PUSH
89129: LD_INT 1
89131: NEG
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: PUSH
89137: LD_INT 1
89139: NEG
89140: PUSH
89141: LD_INT 2
89143: NEG
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: PUSH
89149: LD_INT 0
89151: PUSH
89152: LD_INT 2
89154: NEG
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: PUSH
89160: LD_INT 1
89162: PUSH
89163: LD_INT 1
89165: NEG
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 2
89173: PUSH
89174: LD_INT 0
89176: PUSH
89177: EMPTY
89178: LIST
89179: LIST
89180: PUSH
89181: LD_INT 2
89183: PUSH
89184: LD_INT 1
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: PUSH
89191: LD_INT 2
89193: PUSH
89194: LD_INT 2
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PUSH
89201: LD_INT 1
89203: PUSH
89204: LD_INT 2
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 0
89213: PUSH
89214: LD_INT 2
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: PUSH
89221: LD_INT 1
89223: NEG
89224: PUSH
89225: LD_INT 1
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 2
89234: NEG
89235: PUSH
89236: LD_INT 0
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 2
89245: NEG
89246: PUSH
89247: LD_INT 1
89249: NEG
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: LD_INT 2
89257: NEG
89258: PUSH
89259: LD_INT 2
89261: NEG
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: LIST
89271: LIST
89272: LIST
89273: LIST
89274: LIST
89275: LIST
89276: LIST
89277: LIST
89278: LIST
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89288: LD_ADDR_VAR 0 58
89292: PUSH
89293: LD_INT 0
89295: PUSH
89296: LD_INT 0
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 0
89305: PUSH
89306: LD_INT 1
89308: NEG
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 1
89316: PUSH
89317: LD_INT 0
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 1
89326: PUSH
89327: LD_INT 1
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: LD_INT 0
89336: PUSH
89337: LD_INT 1
89339: PUSH
89340: EMPTY
89341: LIST
89342: LIST
89343: PUSH
89344: LD_INT 1
89346: NEG
89347: PUSH
89348: LD_INT 0
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 1
89357: NEG
89358: PUSH
89359: LD_INT 1
89361: NEG
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 1
89369: NEG
89370: PUSH
89371: LD_INT 2
89373: NEG
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: PUSH
89379: LD_INT 0
89381: PUSH
89382: LD_INT 2
89384: NEG
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PUSH
89390: LD_INT 1
89392: PUSH
89393: LD_INT 1
89395: NEG
89396: PUSH
89397: EMPTY
89398: LIST
89399: LIST
89400: PUSH
89401: LD_INT 2
89403: PUSH
89404: LD_INT 0
89406: PUSH
89407: EMPTY
89408: LIST
89409: LIST
89410: PUSH
89411: LD_INT 2
89413: PUSH
89414: LD_INT 1
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PUSH
89421: LD_INT 2
89423: PUSH
89424: LD_INT 2
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: PUSH
89431: LD_INT 1
89433: PUSH
89434: LD_INT 2
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: PUSH
89441: LD_INT 0
89443: PUSH
89444: LD_INT 2
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 1
89453: NEG
89454: PUSH
89455: LD_INT 1
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 2
89464: NEG
89465: PUSH
89466: LD_INT 0
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: PUSH
89473: LD_INT 2
89475: NEG
89476: PUSH
89477: LD_INT 1
89479: NEG
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: LD_INT 2
89487: NEG
89488: PUSH
89489: LD_INT 2
89491: NEG
89492: PUSH
89493: EMPTY
89494: LIST
89495: LIST
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89518: LD_ADDR_VAR 0 59
89522: PUSH
89523: LD_INT 0
89525: PUSH
89526: LD_INT 0
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: LD_INT 0
89535: PUSH
89536: LD_INT 1
89538: NEG
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: PUSH
89544: LD_INT 1
89546: PUSH
89547: LD_INT 0
89549: PUSH
89550: EMPTY
89551: LIST
89552: LIST
89553: PUSH
89554: LD_INT 1
89556: PUSH
89557: LD_INT 1
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 0
89566: PUSH
89567: LD_INT 1
89569: PUSH
89570: EMPTY
89571: LIST
89572: LIST
89573: PUSH
89574: LD_INT 1
89576: NEG
89577: PUSH
89578: LD_INT 0
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: LD_INT 1
89587: NEG
89588: PUSH
89589: LD_INT 1
89591: NEG
89592: PUSH
89593: EMPTY
89594: LIST
89595: LIST
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: LIST
89601: LIST
89602: LIST
89603: LIST
89604: LIST
89605: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89606: LD_ADDR_VAR 0 60
89610: PUSH
89611: LD_INT 0
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 0
89623: PUSH
89624: LD_INT 1
89626: NEG
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 1
89634: PUSH
89635: LD_INT 0
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 1
89644: PUSH
89645: LD_INT 1
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 0
89654: PUSH
89655: LD_INT 1
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 1
89664: NEG
89665: PUSH
89666: LD_INT 0
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: LD_INT 1
89675: NEG
89676: PUSH
89677: LD_INT 1
89679: NEG
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89694: LD_ADDR_VAR 0 61
89698: PUSH
89699: LD_INT 0
89701: PUSH
89702: LD_INT 0
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 0
89711: PUSH
89712: LD_INT 1
89714: NEG
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 1
89722: PUSH
89723: LD_INT 0
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 1
89732: PUSH
89733: LD_INT 1
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 0
89742: PUSH
89743: LD_INT 1
89745: PUSH
89746: EMPTY
89747: LIST
89748: LIST
89749: PUSH
89750: LD_INT 1
89752: NEG
89753: PUSH
89754: LD_INT 0
89756: PUSH
89757: EMPTY
89758: LIST
89759: LIST
89760: PUSH
89761: LD_INT 1
89763: NEG
89764: PUSH
89765: LD_INT 1
89767: NEG
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89782: LD_ADDR_VAR 0 62
89786: PUSH
89787: LD_INT 0
89789: PUSH
89790: LD_INT 0
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 0
89799: PUSH
89800: LD_INT 1
89802: NEG
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 1
89810: PUSH
89811: LD_INT 0
89813: PUSH
89814: EMPTY
89815: LIST
89816: LIST
89817: PUSH
89818: LD_INT 1
89820: PUSH
89821: LD_INT 1
89823: PUSH
89824: EMPTY
89825: LIST
89826: LIST
89827: PUSH
89828: LD_INT 0
89830: PUSH
89831: LD_INT 1
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: PUSH
89838: LD_INT 1
89840: NEG
89841: PUSH
89842: LD_INT 0
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 1
89851: NEG
89852: PUSH
89853: LD_INT 1
89855: NEG
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89870: LD_ADDR_VAR 0 63
89874: PUSH
89875: LD_INT 0
89877: PUSH
89878: LD_INT 0
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PUSH
89885: LD_INT 0
89887: PUSH
89888: LD_INT 1
89890: NEG
89891: PUSH
89892: EMPTY
89893: LIST
89894: LIST
89895: PUSH
89896: LD_INT 1
89898: PUSH
89899: LD_INT 0
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PUSH
89906: LD_INT 1
89908: PUSH
89909: LD_INT 1
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: PUSH
89916: LD_INT 0
89918: PUSH
89919: LD_INT 1
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 1
89928: NEG
89929: PUSH
89930: LD_INT 0
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 1
89939: NEG
89940: PUSH
89941: LD_INT 1
89943: NEG
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89958: LD_ADDR_VAR 0 64
89962: PUSH
89963: LD_INT 0
89965: PUSH
89966: LD_INT 0
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: LD_INT 0
89975: PUSH
89976: LD_INT 1
89978: NEG
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 1
89986: PUSH
89987: LD_INT 0
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: PUSH
89994: LD_INT 1
89996: PUSH
89997: LD_INT 1
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 0
90006: PUSH
90007: LD_INT 1
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 1
90016: NEG
90017: PUSH
90018: LD_INT 0
90020: PUSH
90021: EMPTY
90022: LIST
90023: LIST
90024: PUSH
90025: LD_INT 1
90027: NEG
90028: PUSH
90029: LD_INT 1
90031: NEG
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: ST_TO_ADDR
// end ; 1 :
90046: GO 95943
90048: LD_INT 1
90050: DOUBLE
90051: EQUAL
90052: IFTRUE 90056
90054: GO 92679
90056: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90057: LD_ADDR_VAR 0 11
90061: PUSH
90062: LD_INT 1
90064: NEG
90065: PUSH
90066: LD_INT 3
90068: NEG
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 0
90076: PUSH
90077: LD_INT 3
90079: NEG
90080: PUSH
90081: EMPTY
90082: LIST
90083: LIST
90084: PUSH
90085: LD_INT 1
90087: PUSH
90088: LD_INT 2
90090: NEG
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: LIST
90100: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90101: LD_ADDR_VAR 0 12
90105: PUSH
90106: LD_INT 2
90108: PUSH
90109: LD_INT 1
90111: NEG
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 3
90119: PUSH
90120: LD_INT 0
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: PUSH
90127: LD_INT 3
90129: PUSH
90130: LD_INT 1
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: LIST
90141: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90142: LD_ADDR_VAR 0 13
90146: PUSH
90147: LD_INT 3
90149: PUSH
90150: LD_INT 2
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: PUSH
90157: LD_INT 3
90159: PUSH
90160: LD_INT 3
90162: PUSH
90163: EMPTY
90164: LIST
90165: LIST
90166: PUSH
90167: LD_INT 2
90169: PUSH
90170: LD_INT 3
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: LIST
90181: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90182: LD_ADDR_VAR 0 14
90186: PUSH
90187: LD_INT 1
90189: PUSH
90190: LD_INT 3
90192: PUSH
90193: EMPTY
90194: LIST
90195: LIST
90196: PUSH
90197: LD_INT 0
90199: PUSH
90200: LD_INT 3
90202: PUSH
90203: EMPTY
90204: LIST
90205: LIST
90206: PUSH
90207: LD_INT 1
90209: NEG
90210: PUSH
90211: LD_INT 2
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: LIST
90222: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90223: LD_ADDR_VAR 0 15
90227: PUSH
90228: LD_INT 2
90230: NEG
90231: PUSH
90232: LD_INT 1
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: LD_INT 3
90241: NEG
90242: PUSH
90243: LD_INT 0
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 3
90252: NEG
90253: PUSH
90254: LD_INT 1
90256: NEG
90257: PUSH
90258: EMPTY
90259: LIST
90260: LIST
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: LIST
90266: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90267: LD_ADDR_VAR 0 16
90271: PUSH
90272: LD_INT 2
90274: NEG
90275: PUSH
90276: LD_INT 3
90278: NEG
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 3
90286: NEG
90287: PUSH
90288: LD_INT 2
90290: NEG
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 3
90298: NEG
90299: PUSH
90300: LD_INT 3
90302: NEG
90303: PUSH
90304: EMPTY
90305: LIST
90306: LIST
90307: PUSH
90308: EMPTY
90309: LIST
90310: LIST
90311: LIST
90312: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90313: LD_ADDR_VAR 0 17
90317: PUSH
90318: LD_INT 1
90320: NEG
90321: PUSH
90322: LD_INT 3
90324: NEG
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: LD_INT 0
90332: PUSH
90333: LD_INT 3
90335: NEG
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 1
90343: PUSH
90344: LD_INT 2
90346: NEG
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: EMPTY
90353: LIST
90354: LIST
90355: LIST
90356: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90357: LD_ADDR_VAR 0 18
90361: PUSH
90362: LD_INT 2
90364: PUSH
90365: LD_INT 1
90367: NEG
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: PUSH
90373: LD_INT 3
90375: PUSH
90376: LD_INT 0
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 3
90385: PUSH
90386: LD_INT 1
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: LIST
90397: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90398: LD_ADDR_VAR 0 19
90402: PUSH
90403: LD_INT 3
90405: PUSH
90406: LD_INT 2
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: PUSH
90413: LD_INT 3
90415: PUSH
90416: LD_INT 3
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 2
90425: PUSH
90426: LD_INT 3
90428: PUSH
90429: EMPTY
90430: LIST
90431: LIST
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: LIST
90437: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90438: LD_ADDR_VAR 0 20
90442: PUSH
90443: LD_INT 1
90445: PUSH
90446: LD_INT 3
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 0
90455: PUSH
90456: LD_INT 3
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 1
90465: NEG
90466: PUSH
90467: LD_INT 2
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: LIST
90478: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90479: LD_ADDR_VAR 0 21
90483: PUSH
90484: LD_INT 2
90486: NEG
90487: PUSH
90488: LD_INT 1
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: PUSH
90495: LD_INT 3
90497: NEG
90498: PUSH
90499: LD_INT 0
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 3
90508: NEG
90509: PUSH
90510: LD_INT 1
90512: NEG
90513: PUSH
90514: EMPTY
90515: LIST
90516: LIST
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: LIST
90522: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90523: LD_ADDR_VAR 0 22
90527: PUSH
90528: LD_INT 2
90530: NEG
90531: PUSH
90532: LD_INT 3
90534: NEG
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: PUSH
90540: LD_INT 3
90542: NEG
90543: PUSH
90544: LD_INT 2
90546: NEG
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PUSH
90552: LD_INT 3
90554: NEG
90555: PUSH
90556: LD_INT 3
90558: NEG
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: LIST
90568: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90569: LD_ADDR_VAR 0 23
90573: PUSH
90574: LD_INT 0
90576: PUSH
90577: LD_INT 3
90579: NEG
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 1
90587: NEG
90588: PUSH
90589: LD_INT 4
90591: NEG
90592: PUSH
90593: EMPTY
90594: LIST
90595: LIST
90596: PUSH
90597: LD_INT 1
90599: PUSH
90600: LD_INT 3
90602: NEG
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: LIST
90612: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90613: LD_ADDR_VAR 0 24
90617: PUSH
90618: LD_INT 3
90620: PUSH
90621: LD_INT 0
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PUSH
90628: LD_INT 3
90630: PUSH
90631: LD_INT 1
90633: NEG
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: LD_INT 4
90641: PUSH
90642: LD_INT 1
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: LIST
90653: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90654: LD_ADDR_VAR 0 25
90658: PUSH
90659: LD_INT 3
90661: PUSH
90662: LD_INT 3
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 4
90671: PUSH
90672: LD_INT 3
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 3
90681: PUSH
90682: LD_INT 4
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: LIST
90693: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90694: LD_ADDR_VAR 0 26
90698: PUSH
90699: LD_INT 0
90701: PUSH
90702: LD_INT 3
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 1
90711: PUSH
90712: LD_INT 4
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 1
90721: NEG
90722: PUSH
90723: LD_INT 3
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: LIST
90734: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90735: LD_ADDR_VAR 0 27
90739: PUSH
90740: LD_INT 3
90742: NEG
90743: PUSH
90744: LD_INT 0
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 3
90753: NEG
90754: PUSH
90755: LD_INT 1
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 4
90764: NEG
90765: PUSH
90766: LD_INT 1
90768: NEG
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: LIST
90778: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90779: LD_ADDR_VAR 0 28
90783: PUSH
90784: LD_INT 3
90786: NEG
90787: PUSH
90788: LD_INT 3
90790: NEG
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 3
90798: NEG
90799: PUSH
90800: LD_INT 4
90802: NEG
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 4
90810: NEG
90811: PUSH
90812: LD_INT 3
90814: NEG
90815: PUSH
90816: EMPTY
90817: LIST
90818: LIST
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: LIST
90824: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90825: LD_ADDR_VAR 0 29
90829: PUSH
90830: LD_INT 1
90832: NEG
90833: PUSH
90834: LD_INT 3
90836: NEG
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 0
90844: PUSH
90845: LD_INT 3
90847: NEG
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 1
90855: PUSH
90856: LD_INT 2
90858: NEG
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 1
90866: NEG
90867: PUSH
90868: LD_INT 4
90870: NEG
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: LD_INT 0
90878: PUSH
90879: LD_INT 4
90881: NEG
90882: PUSH
90883: EMPTY
90884: LIST
90885: LIST
90886: PUSH
90887: LD_INT 1
90889: PUSH
90890: LD_INT 3
90892: NEG
90893: PUSH
90894: EMPTY
90895: LIST
90896: LIST
90897: PUSH
90898: LD_INT 1
90900: NEG
90901: PUSH
90902: LD_INT 5
90904: NEG
90905: PUSH
90906: EMPTY
90907: LIST
90908: LIST
90909: PUSH
90910: LD_INT 0
90912: PUSH
90913: LD_INT 5
90915: NEG
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 1
90923: PUSH
90924: LD_INT 4
90926: NEG
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PUSH
90932: LD_INT 1
90934: NEG
90935: PUSH
90936: LD_INT 6
90938: NEG
90939: PUSH
90940: EMPTY
90941: LIST
90942: LIST
90943: PUSH
90944: LD_INT 0
90946: PUSH
90947: LD_INT 6
90949: NEG
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: LD_INT 5
90960: NEG
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: EMPTY
90967: LIST
90968: LIST
90969: LIST
90970: LIST
90971: LIST
90972: LIST
90973: LIST
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90980: LD_ADDR_VAR 0 30
90984: PUSH
90985: LD_INT 2
90987: PUSH
90988: LD_INT 1
90990: NEG
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: LD_INT 3
90998: PUSH
90999: LD_INT 0
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 3
91008: PUSH
91009: LD_INT 1
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: PUSH
91016: LD_INT 3
91018: PUSH
91019: LD_INT 1
91021: NEG
91022: PUSH
91023: EMPTY
91024: LIST
91025: LIST
91026: PUSH
91027: LD_INT 4
91029: PUSH
91030: LD_INT 0
91032: PUSH
91033: EMPTY
91034: LIST
91035: LIST
91036: PUSH
91037: LD_INT 4
91039: PUSH
91040: LD_INT 1
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: PUSH
91047: LD_INT 4
91049: PUSH
91050: LD_INT 1
91052: NEG
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 5
91060: PUSH
91061: LD_INT 0
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 5
91070: PUSH
91071: LD_INT 1
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 5
91080: PUSH
91081: LD_INT 1
91083: NEG
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 6
91091: PUSH
91092: LD_INT 0
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 6
91101: PUSH
91102: LD_INT 1
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: LIST
91119: LIST
91120: LIST
91121: LIST
91122: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91123: LD_ADDR_VAR 0 31
91127: PUSH
91128: LD_INT 3
91130: PUSH
91131: LD_INT 2
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: PUSH
91138: LD_INT 3
91140: PUSH
91141: LD_INT 3
91143: PUSH
91144: EMPTY
91145: LIST
91146: LIST
91147: PUSH
91148: LD_INT 2
91150: PUSH
91151: LD_INT 3
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: PUSH
91158: LD_INT 4
91160: PUSH
91161: LD_INT 3
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: PUSH
91168: LD_INT 4
91170: PUSH
91171: LD_INT 4
91173: PUSH
91174: EMPTY
91175: LIST
91176: LIST
91177: PUSH
91178: LD_INT 3
91180: PUSH
91181: LD_INT 4
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: PUSH
91188: LD_INT 5
91190: PUSH
91191: LD_INT 4
91193: PUSH
91194: EMPTY
91195: LIST
91196: LIST
91197: PUSH
91198: LD_INT 5
91200: PUSH
91201: LD_INT 5
91203: PUSH
91204: EMPTY
91205: LIST
91206: LIST
91207: PUSH
91208: LD_INT 4
91210: PUSH
91211: LD_INT 5
91213: PUSH
91214: EMPTY
91215: LIST
91216: LIST
91217: PUSH
91218: LD_INT 6
91220: PUSH
91221: LD_INT 5
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: PUSH
91228: LD_INT 6
91230: PUSH
91231: LD_INT 6
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: PUSH
91238: LD_INT 5
91240: PUSH
91241: LD_INT 6
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91262: LD_ADDR_VAR 0 32
91266: PUSH
91267: LD_INT 1
91269: PUSH
91270: LD_INT 3
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 0
91279: PUSH
91280: LD_INT 3
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 1
91289: NEG
91290: PUSH
91291: LD_INT 2
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: PUSH
91298: LD_INT 1
91300: PUSH
91301: LD_INT 4
91303: PUSH
91304: EMPTY
91305: LIST
91306: LIST
91307: PUSH
91308: LD_INT 0
91310: PUSH
91311: LD_INT 4
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PUSH
91318: LD_INT 1
91320: NEG
91321: PUSH
91322: LD_INT 3
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 1
91331: PUSH
91332: LD_INT 5
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 0
91341: PUSH
91342: LD_INT 5
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 1
91351: NEG
91352: PUSH
91353: LD_INT 4
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 1
91362: PUSH
91363: LD_INT 6
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: PUSH
91370: LD_INT 0
91372: PUSH
91373: LD_INT 6
91375: PUSH
91376: EMPTY
91377: LIST
91378: LIST
91379: PUSH
91380: LD_INT 1
91382: NEG
91383: PUSH
91384: LD_INT 5
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91405: LD_ADDR_VAR 0 33
91409: PUSH
91410: LD_INT 2
91412: NEG
91413: PUSH
91414: LD_INT 1
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: LD_INT 3
91423: NEG
91424: PUSH
91425: LD_INT 0
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: PUSH
91432: LD_INT 3
91434: NEG
91435: PUSH
91436: LD_INT 1
91438: NEG
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: PUSH
91444: LD_INT 3
91446: NEG
91447: PUSH
91448: LD_INT 1
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 4
91457: NEG
91458: PUSH
91459: LD_INT 0
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 4
91468: NEG
91469: PUSH
91470: LD_INT 1
91472: NEG
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 4
91480: NEG
91481: PUSH
91482: LD_INT 1
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 5
91491: NEG
91492: PUSH
91493: LD_INT 0
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 5
91502: NEG
91503: PUSH
91504: LD_INT 1
91506: NEG
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 5
91514: NEG
91515: PUSH
91516: LD_INT 1
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 6
91525: NEG
91526: PUSH
91527: LD_INT 0
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: LD_INT 6
91536: NEG
91537: PUSH
91538: LD_INT 1
91540: NEG
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91560: LD_ADDR_VAR 0 34
91564: PUSH
91565: LD_INT 2
91567: NEG
91568: PUSH
91569: LD_INT 3
91571: NEG
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: PUSH
91577: LD_INT 3
91579: NEG
91580: PUSH
91581: LD_INT 2
91583: NEG
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: LD_INT 3
91591: NEG
91592: PUSH
91593: LD_INT 3
91595: NEG
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 3
91603: NEG
91604: PUSH
91605: LD_INT 4
91607: NEG
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 4
91615: NEG
91616: PUSH
91617: LD_INT 3
91619: NEG
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: PUSH
91625: LD_INT 4
91627: NEG
91628: PUSH
91629: LD_INT 4
91631: NEG
91632: PUSH
91633: EMPTY
91634: LIST
91635: LIST
91636: PUSH
91637: LD_INT 4
91639: NEG
91640: PUSH
91641: LD_INT 5
91643: NEG
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: PUSH
91649: LD_INT 5
91651: NEG
91652: PUSH
91653: LD_INT 4
91655: NEG
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 5
91663: NEG
91664: PUSH
91665: LD_INT 5
91667: NEG
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: LD_INT 5
91675: NEG
91676: PUSH
91677: LD_INT 6
91679: NEG
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: LD_INT 6
91687: NEG
91688: PUSH
91689: LD_INT 5
91691: NEG
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PUSH
91697: LD_INT 6
91699: NEG
91700: PUSH
91701: LD_INT 6
91703: NEG
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91723: LD_ADDR_VAR 0 41
91727: PUSH
91728: LD_INT 0
91730: PUSH
91731: LD_INT 2
91733: NEG
91734: PUSH
91735: EMPTY
91736: LIST
91737: LIST
91738: PUSH
91739: LD_INT 1
91741: NEG
91742: PUSH
91743: LD_INT 3
91745: NEG
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 1
91753: PUSH
91754: LD_INT 2
91756: NEG
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: LIST
91766: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91767: LD_ADDR_VAR 0 42
91771: PUSH
91772: LD_INT 2
91774: PUSH
91775: LD_INT 0
91777: PUSH
91778: EMPTY
91779: LIST
91780: LIST
91781: PUSH
91782: LD_INT 2
91784: PUSH
91785: LD_INT 1
91787: NEG
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PUSH
91793: LD_INT 3
91795: PUSH
91796: LD_INT 1
91798: PUSH
91799: EMPTY
91800: LIST
91801: LIST
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: LIST
91807: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91808: LD_ADDR_VAR 0 43
91812: PUSH
91813: LD_INT 2
91815: PUSH
91816: LD_INT 2
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 3
91825: PUSH
91826: LD_INT 2
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: LD_INT 2
91835: PUSH
91836: LD_INT 3
91838: PUSH
91839: EMPTY
91840: LIST
91841: LIST
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: LIST
91847: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91848: LD_ADDR_VAR 0 44
91852: PUSH
91853: LD_INT 0
91855: PUSH
91856: LD_INT 2
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: PUSH
91863: LD_INT 1
91865: PUSH
91866: LD_INT 3
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 1
91875: NEG
91876: PUSH
91877: LD_INT 2
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: LIST
91888: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91889: LD_ADDR_VAR 0 45
91893: PUSH
91894: LD_INT 2
91896: NEG
91897: PUSH
91898: LD_INT 0
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: PUSH
91905: LD_INT 2
91907: NEG
91908: PUSH
91909: LD_INT 1
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: PUSH
91916: LD_INT 3
91918: NEG
91919: PUSH
91920: LD_INT 1
91922: NEG
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: LIST
91932: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91933: LD_ADDR_VAR 0 46
91937: PUSH
91938: LD_INT 2
91940: NEG
91941: PUSH
91942: LD_INT 2
91944: NEG
91945: PUSH
91946: EMPTY
91947: LIST
91948: LIST
91949: PUSH
91950: LD_INT 2
91952: NEG
91953: PUSH
91954: LD_INT 3
91956: NEG
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 3
91964: NEG
91965: PUSH
91966: LD_INT 2
91968: NEG
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: EMPTY
91975: LIST
91976: LIST
91977: LIST
91978: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91979: LD_ADDR_VAR 0 47
91983: PUSH
91984: LD_INT 2
91986: NEG
91987: PUSH
91988: LD_INT 3
91990: NEG
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: LD_INT 1
91998: NEG
91999: PUSH
92000: LD_INT 3
92002: NEG
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92012: LD_ADDR_VAR 0 48
92016: PUSH
92017: LD_INT 1
92019: PUSH
92020: LD_INT 2
92022: NEG
92023: PUSH
92024: EMPTY
92025: LIST
92026: LIST
92027: PUSH
92028: LD_INT 2
92030: PUSH
92031: LD_INT 1
92033: NEG
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92043: LD_ADDR_VAR 0 49
92047: PUSH
92048: LD_INT 3
92050: PUSH
92051: LD_INT 1
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: PUSH
92058: LD_INT 3
92060: PUSH
92061: LD_INT 2
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: PUSH
92068: EMPTY
92069: LIST
92070: LIST
92071: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92072: LD_ADDR_VAR 0 50
92076: PUSH
92077: LD_INT 2
92079: PUSH
92080: LD_INT 3
92082: PUSH
92083: EMPTY
92084: LIST
92085: LIST
92086: PUSH
92087: LD_INT 1
92089: PUSH
92090: LD_INT 3
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92101: LD_ADDR_VAR 0 51
92105: PUSH
92106: LD_INT 1
92108: NEG
92109: PUSH
92110: LD_INT 2
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 2
92119: NEG
92120: PUSH
92121: LD_INT 1
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92132: LD_ADDR_VAR 0 52
92136: PUSH
92137: LD_INT 3
92139: NEG
92140: PUSH
92141: LD_INT 1
92143: NEG
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: LD_INT 3
92151: NEG
92152: PUSH
92153: LD_INT 2
92155: NEG
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92165: LD_ADDR_VAR 0 53
92169: PUSH
92170: LD_INT 1
92172: NEG
92173: PUSH
92174: LD_INT 3
92176: NEG
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: LD_INT 0
92184: PUSH
92185: LD_INT 3
92187: NEG
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 1
92195: PUSH
92196: LD_INT 2
92198: NEG
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: LIST
92208: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92209: LD_ADDR_VAR 0 54
92213: PUSH
92214: LD_INT 2
92216: PUSH
92217: LD_INT 1
92219: NEG
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 3
92227: PUSH
92228: LD_INT 0
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 3
92237: PUSH
92238: LD_INT 1
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: LIST
92249: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92250: LD_ADDR_VAR 0 55
92254: PUSH
92255: LD_INT 3
92257: PUSH
92258: LD_INT 2
92260: PUSH
92261: EMPTY
92262: LIST
92263: LIST
92264: PUSH
92265: LD_INT 3
92267: PUSH
92268: LD_INT 3
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: PUSH
92275: LD_INT 2
92277: PUSH
92278: LD_INT 3
92280: PUSH
92281: EMPTY
92282: LIST
92283: LIST
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: LIST
92289: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92290: LD_ADDR_VAR 0 56
92294: PUSH
92295: LD_INT 1
92297: PUSH
92298: LD_INT 3
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: LD_INT 0
92307: PUSH
92308: LD_INT 3
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: PUSH
92315: LD_INT 1
92317: NEG
92318: PUSH
92319: LD_INT 2
92321: PUSH
92322: EMPTY
92323: LIST
92324: LIST
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: LIST
92330: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92331: LD_ADDR_VAR 0 57
92335: PUSH
92336: LD_INT 2
92338: NEG
92339: PUSH
92340: LD_INT 1
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 3
92349: NEG
92350: PUSH
92351: LD_INT 0
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: LD_INT 3
92360: NEG
92361: PUSH
92362: LD_INT 1
92364: NEG
92365: PUSH
92366: EMPTY
92367: LIST
92368: LIST
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: LIST
92374: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92375: LD_ADDR_VAR 0 58
92379: PUSH
92380: LD_INT 2
92382: NEG
92383: PUSH
92384: LD_INT 3
92386: NEG
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: PUSH
92392: LD_INT 3
92394: NEG
92395: PUSH
92396: LD_INT 2
92398: NEG
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 3
92406: NEG
92407: PUSH
92408: LD_INT 3
92410: NEG
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: LIST
92420: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92421: LD_ADDR_VAR 0 59
92425: PUSH
92426: LD_INT 1
92428: NEG
92429: PUSH
92430: LD_INT 2
92432: NEG
92433: PUSH
92434: EMPTY
92435: LIST
92436: LIST
92437: PUSH
92438: LD_INT 0
92440: PUSH
92441: LD_INT 2
92443: NEG
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: PUSH
92449: LD_INT 1
92451: PUSH
92452: LD_INT 1
92454: NEG
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: LIST
92464: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92465: LD_ADDR_VAR 0 60
92469: PUSH
92470: LD_INT 1
92472: PUSH
92473: LD_INT 1
92475: NEG
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 2
92483: PUSH
92484: LD_INT 0
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: PUSH
92491: LD_INT 2
92493: PUSH
92494: LD_INT 1
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: LIST
92505: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92506: LD_ADDR_VAR 0 61
92510: PUSH
92511: LD_INT 2
92513: PUSH
92514: LD_INT 1
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: PUSH
92521: LD_INT 2
92523: PUSH
92524: LD_INT 2
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: PUSH
92531: LD_INT 1
92533: PUSH
92534: LD_INT 2
92536: PUSH
92537: EMPTY
92538: LIST
92539: LIST
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: LIST
92545: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92546: LD_ADDR_VAR 0 62
92550: PUSH
92551: LD_INT 1
92553: PUSH
92554: LD_INT 2
92556: PUSH
92557: EMPTY
92558: LIST
92559: LIST
92560: PUSH
92561: LD_INT 0
92563: PUSH
92564: LD_INT 2
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: PUSH
92571: LD_INT 1
92573: NEG
92574: PUSH
92575: LD_INT 1
92577: PUSH
92578: EMPTY
92579: LIST
92580: LIST
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: LIST
92586: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92587: LD_ADDR_VAR 0 63
92591: PUSH
92592: LD_INT 1
92594: NEG
92595: PUSH
92596: LD_INT 1
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 2
92605: NEG
92606: PUSH
92607: LD_INT 0
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 2
92616: NEG
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: LIST
92630: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92631: LD_ADDR_VAR 0 64
92635: PUSH
92636: LD_INT 1
92638: NEG
92639: PUSH
92640: LD_INT 2
92642: NEG
92643: PUSH
92644: EMPTY
92645: LIST
92646: LIST
92647: PUSH
92648: LD_INT 2
92650: NEG
92651: PUSH
92652: LD_INT 1
92654: NEG
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 2
92662: NEG
92663: PUSH
92664: LD_INT 2
92666: NEG
92667: PUSH
92668: EMPTY
92669: LIST
92670: LIST
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: LIST
92676: ST_TO_ADDR
// end ; 2 :
92677: GO 95943
92679: LD_INT 2
92681: DOUBLE
92682: EQUAL
92683: IFTRUE 92687
92685: GO 95942
92687: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92688: LD_ADDR_VAR 0 29
92692: PUSH
92693: LD_INT 4
92695: PUSH
92696: LD_INT 0
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 4
92705: PUSH
92706: LD_INT 1
92708: NEG
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: PUSH
92714: LD_INT 5
92716: PUSH
92717: LD_INT 0
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: PUSH
92724: LD_INT 5
92726: PUSH
92727: LD_INT 1
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: LD_INT 4
92736: PUSH
92737: LD_INT 1
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: LD_INT 3
92746: PUSH
92747: LD_INT 0
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 3
92756: PUSH
92757: LD_INT 1
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 3
92767: PUSH
92768: LD_INT 2
92770: NEG
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 5
92778: PUSH
92779: LD_INT 2
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: LD_INT 3
92788: PUSH
92789: LD_INT 3
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: PUSH
92796: LD_INT 3
92798: PUSH
92799: LD_INT 2
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 4
92808: PUSH
92809: LD_INT 3
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 4
92818: PUSH
92819: LD_INT 4
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 3
92828: PUSH
92829: LD_INT 4
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 2
92838: PUSH
92839: LD_INT 3
92841: PUSH
92842: EMPTY
92843: LIST
92844: LIST
92845: PUSH
92846: LD_INT 2
92848: PUSH
92849: LD_INT 2
92851: PUSH
92852: EMPTY
92853: LIST
92854: LIST
92855: PUSH
92856: LD_INT 4
92858: PUSH
92859: LD_INT 2
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: PUSH
92866: LD_INT 2
92868: PUSH
92869: LD_INT 4
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: PUSH
92876: LD_INT 0
92878: PUSH
92879: LD_INT 4
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 0
92888: PUSH
92889: LD_INT 3
92891: PUSH
92892: EMPTY
92893: LIST
92894: LIST
92895: PUSH
92896: LD_INT 1
92898: PUSH
92899: LD_INT 4
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 1
92908: PUSH
92909: LD_INT 5
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PUSH
92916: LD_INT 0
92918: PUSH
92919: LD_INT 5
92921: PUSH
92922: EMPTY
92923: LIST
92924: LIST
92925: PUSH
92926: LD_INT 1
92928: NEG
92929: PUSH
92930: LD_INT 4
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: PUSH
92937: LD_INT 1
92939: NEG
92940: PUSH
92941: LD_INT 3
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: PUSH
92948: LD_INT 2
92950: PUSH
92951: LD_INT 5
92953: PUSH
92954: EMPTY
92955: LIST
92956: LIST
92957: PUSH
92958: LD_INT 2
92960: NEG
92961: PUSH
92962: LD_INT 3
92964: PUSH
92965: EMPTY
92966: LIST
92967: LIST
92968: PUSH
92969: LD_INT 3
92971: NEG
92972: PUSH
92973: LD_INT 0
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PUSH
92980: LD_INT 3
92982: NEG
92983: PUSH
92984: LD_INT 1
92986: NEG
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: LD_INT 2
92994: NEG
92995: PUSH
92996: LD_INT 0
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PUSH
93003: LD_INT 2
93005: NEG
93006: PUSH
93007: LD_INT 1
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: PUSH
93014: LD_INT 3
93016: NEG
93017: PUSH
93018: LD_INT 1
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 4
93027: NEG
93028: PUSH
93029: LD_INT 0
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: PUSH
93036: LD_INT 4
93038: NEG
93039: PUSH
93040: LD_INT 1
93042: NEG
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: PUSH
93048: LD_INT 4
93050: NEG
93051: PUSH
93052: LD_INT 2
93054: NEG
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: PUSH
93060: LD_INT 2
93062: NEG
93063: PUSH
93064: LD_INT 2
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: PUSH
93071: LD_INT 4
93073: NEG
93074: PUSH
93075: LD_INT 4
93077: NEG
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 4
93085: NEG
93086: PUSH
93087: LD_INT 5
93089: NEG
93090: PUSH
93091: EMPTY
93092: LIST
93093: LIST
93094: PUSH
93095: LD_INT 3
93097: NEG
93098: PUSH
93099: LD_INT 4
93101: NEG
93102: PUSH
93103: EMPTY
93104: LIST
93105: LIST
93106: PUSH
93107: LD_INT 3
93109: NEG
93110: PUSH
93111: LD_INT 3
93113: NEG
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 4
93121: NEG
93122: PUSH
93123: LD_INT 3
93125: NEG
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 5
93133: NEG
93134: PUSH
93135: LD_INT 4
93137: NEG
93138: PUSH
93139: EMPTY
93140: LIST
93141: LIST
93142: PUSH
93143: LD_INT 5
93145: NEG
93146: PUSH
93147: LD_INT 5
93149: NEG
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: PUSH
93155: LD_INT 3
93157: NEG
93158: PUSH
93159: LD_INT 5
93161: NEG
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: PUSH
93167: LD_INT 5
93169: NEG
93170: PUSH
93171: LD_INT 3
93173: NEG
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93226: LD_ADDR_VAR 0 30
93230: PUSH
93231: LD_INT 4
93233: PUSH
93234: LD_INT 4
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: PUSH
93241: LD_INT 4
93243: PUSH
93244: LD_INT 3
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: PUSH
93251: LD_INT 5
93253: PUSH
93254: LD_INT 4
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 5
93263: PUSH
93264: LD_INT 5
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: PUSH
93271: LD_INT 4
93273: PUSH
93274: LD_INT 5
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: LD_INT 3
93283: PUSH
93284: LD_INT 4
93286: PUSH
93287: EMPTY
93288: LIST
93289: LIST
93290: PUSH
93291: LD_INT 3
93293: PUSH
93294: LD_INT 3
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 5
93303: PUSH
93304: LD_INT 3
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PUSH
93311: LD_INT 3
93313: PUSH
93314: LD_INT 5
93316: PUSH
93317: EMPTY
93318: LIST
93319: LIST
93320: PUSH
93321: LD_INT 0
93323: PUSH
93324: LD_INT 3
93326: PUSH
93327: EMPTY
93328: LIST
93329: LIST
93330: PUSH
93331: LD_INT 0
93333: PUSH
93334: LD_INT 2
93336: PUSH
93337: EMPTY
93338: LIST
93339: LIST
93340: PUSH
93341: LD_INT 1
93343: PUSH
93344: LD_INT 3
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 1
93353: PUSH
93354: LD_INT 4
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: PUSH
93361: LD_INT 0
93363: PUSH
93364: LD_INT 4
93366: PUSH
93367: EMPTY
93368: LIST
93369: LIST
93370: PUSH
93371: LD_INT 1
93373: NEG
93374: PUSH
93375: LD_INT 3
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: PUSH
93382: LD_INT 1
93384: NEG
93385: PUSH
93386: LD_INT 2
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 2
93395: PUSH
93396: LD_INT 4
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: LD_INT 2
93405: NEG
93406: PUSH
93407: LD_INT 2
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 4
93416: NEG
93417: PUSH
93418: LD_INT 0
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 4
93427: NEG
93428: PUSH
93429: LD_INT 1
93431: NEG
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 3
93439: NEG
93440: PUSH
93441: LD_INT 0
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: PUSH
93448: LD_INT 3
93450: NEG
93451: PUSH
93452: LD_INT 1
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: PUSH
93459: LD_INT 4
93461: NEG
93462: PUSH
93463: LD_INT 1
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 5
93472: NEG
93473: PUSH
93474: LD_INT 0
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 5
93483: NEG
93484: PUSH
93485: LD_INT 1
93487: NEG
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: PUSH
93493: LD_INT 5
93495: NEG
93496: PUSH
93497: LD_INT 2
93499: NEG
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: PUSH
93505: LD_INT 3
93507: NEG
93508: PUSH
93509: LD_INT 2
93511: PUSH
93512: EMPTY
93513: LIST
93514: LIST
93515: PUSH
93516: LD_INT 3
93518: NEG
93519: PUSH
93520: LD_INT 3
93522: NEG
93523: PUSH
93524: EMPTY
93525: LIST
93526: LIST
93527: PUSH
93528: LD_INT 3
93530: NEG
93531: PUSH
93532: LD_INT 4
93534: NEG
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 2
93542: NEG
93543: PUSH
93544: LD_INT 3
93546: NEG
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PUSH
93552: LD_INT 2
93554: NEG
93555: PUSH
93556: LD_INT 2
93558: NEG
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 3
93566: NEG
93567: PUSH
93568: LD_INT 2
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 4
93578: NEG
93579: PUSH
93580: LD_INT 3
93582: NEG
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 4
93590: NEG
93591: PUSH
93592: LD_INT 4
93594: NEG
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: PUSH
93600: LD_INT 2
93602: NEG
93603: PUSH
93604: LD_INT 4
93606: NEG
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PUSH
93612: LD_INT 4
93614: NEG
93615: PUSH
93616: LD_INT 2
93618: NEG
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PUSH
93624: LD_INT 0
93626: PUSH
93627: LD_INT 4
93629: NEG
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 0
93637: PUSH
93638: LD_INT 5
93640: NEG
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: PUSH
93646: LD_INT 1
93648: PUSH
93649: LD_INT 4
93651: NEG
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: LD_INT 1
93659: PUSH
93660: LD_INT 3
93662: NEG
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PUSH
93668: LD_INT 0
93670: PUSH
93671: LD_INT 3
93673: NEG
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: PUSH
93679: LD_INT 1
93681: NEG
93682: PUSH
93683: LD_INT 4
93685: NEG
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 1
93693: NEG
93694: PUSH
93695: LD_INT 5
93697: NEG
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 2
93705: PUSH
93706: LD_INT 3
93708: NEG
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 2
93716: NEG
93717: PUSH
93718: LD_INT 5
93720: NEG
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: LIST
93733: LIST
93734: LIST
93735: LIST
93736: LIST
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: LIST
93748: LIST
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93773: LD_ADDR_VAR 0 31
93777: PUSH
93778: LD_INT 0
93780: PUSH
93781: LD_INT 4
93783: PUSH
93784: EMPTY
93785: LIST
93786: LIST
93787: PUSH
93788: LD_INT 0
93790: PUSH
93791: LD_INT 3
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: PUSH
93798: LD_INT 1
93800: PUSH
93801: LD_INT 4
93803: PUSH
93804: EMPTY
93805: LIST
93806: LIST
93807: PUSH
93808: LD_INT 1
93810: PUSH
93811: LD_INT 5
93813: PUSH
93814: EMPTY
93815: LIST
93816: LIST
93817: PUSH
93818: LD_INT 0
93820: PUSH
93821: LD_INT 5
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: PUSH
93828: LD_INT 1
93830: NEG
93831: PUSH
93832: LD_INT 4
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 1
93841: NEG
93842: PUSH
93843: LD_INT 3
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 2
93852: PUSH
93853: LD_INT 5
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: LD_INT 2
93862: NEG
93863: PUSH
93864: LD_INT 3
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 3
93873: NEG
93874: PUSH
93875: LD_INT 0
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: LD_INT 3
93884: NEG
93885: PUSH
93886: LD_INT 1
93888: NEG
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PUSH
93894: LD_INT 2
93896: NEG
93897: PUSH
93898: LD_INT 0
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: PUSH
93905: LD_INT 2
93907: NEG
93908: PUSH
93909: LD_INT 1
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 3
93918: NEG
93919: PUSH
93920: LD_INT 1
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 4
93929: NEG
93930: PUSH
93931: LD_INT 0
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 4
93940: NEG
93941: PUSH
93942: LD_INT 1
93944: NEG
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 4
93952: NEG
93953: PUSH
93954: LD_INT 2
93956: NEG
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 2
93964: NEG
93965: PUSH
93966: LD_INT 2
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: PUSH
93973: LD_INT 4
93975: NEG
93976: PUSH
93977: LD_INT 4
93979: NEG
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: PUSH
93985: LD_INT 4
93987: NEG
93988: PUSH
93989: LD_INT 5
93991: NEG
93992: PUSH
93993: EMPTY
93994: LIST
93995: LIST
93996: PUSH
93997: LD_INT 3
93999: NEG
94000: PUSH
94001: LD_INT 4
94003: NEG
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: PUSH
94009: LD_INT 3
94011: NEG
94012: PUSH
94013: LD_INT 3
94015: NEG
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 4
94023: NEG
94024: PUSH
94025: LD_INT 3
94027: NEG
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 5
94035: NEG
94036: PUSH
94037: LD_INT 4
94039: NEG
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: LD_INT 5
94047: NEG
94048: PUSH
94049: LD_INT 5
94051: NEG
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: LD_INT 3
94059: NEG
94060: PUSH
94061: LD_INT 5
94063: NEG
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: LD_INT 5
94071: NEG
94072: PUSH
94073: LD_INT 3
94075: NEG
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_INT 0
94083: PUSH
94084: LD_INT 3
94086: NEG
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 0
94094: PUSH
94095: LD_INT 4
94097: NEG
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 1
94105: PUSH
94106: LD_INT 3
94108: NEG
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 1
94116: PUSH
94117: LD_INT 2
94119: NEG
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 0
94127: PUSH
94128: LD_INT 2
94130: NEG
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 1
94138: NEG
94139: PUSH
94140: LD_INT 3
94142: NEG
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 1
94150: NEG
94151: PUSH
94152: LD_INT 4
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 2
94162: PUSH
94163: LD_INT 2
94165: NEG
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: NEG
94174: PUSH
94175: LD_INT 4
94177: NEG
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 4
94185: PUSH
94186: LD_INT 0
94188: PUSH
94189: EMPTY
94190: LIST
94191: LIST
94192: PUSH
94193: LD_INT 4
94195: PUSH
94196: LD_INT 1
94198: NEG
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: PUSH
94204: LD_INT 5
94206: PUSH
94207: LD_INT 0
94209: PUSH
94210: EMPTY
94211: LIST
94212: LIST
94213: PUSH
94214: LD_INT 5
94216: PUSH
94217: LD_INT 1
94219: PUSH
94220: EMPTY
94221: LIST
94222: LIST
94223: PUSH
94224: LD_INT 4
94226: PUSH
94227: LD_INT 1
94229: PUSH
94230: EMPTY
94231: LIST
94232: LIST
94233: PUSH
94234: LD_INT 3
94236: PUSH
94237: LD_INT 0
94239: PUSH
94240: EMPTY
94241: LIST
94242: LIST
94243: PUSH
94244: LD_INT 3
94246: PUSH
94247: LD_INT 1
94249: NEG
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 3
94257: PUSH
94258: LD_INT 2
94260: NEG
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 5
94268: PUSH
94269: LD_INT 2
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: EMPTY
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94323: LD_ADDR_VAR 0 32
94327: PUSH
94328: LD_INT 4
94330: NEG
94331: PUSH
94332: LD_INT 0
94334: PUSH
94335: EMPTY
94336: LIST
94337: LIST
94338: PUSH
94339: LD_INT 4
94341: NEG
94342: PUSH
94343: LD_INT 1
94345: NEG
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: LD_INT 3
94353: NEG
94354: PUSH
94355: LD_INT 0
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 3
94364: NEG
94365: PUSH
94366: LD_INT 1
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 4
94375: NEG
94376: PUSH
94377: LD_INT 1
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 5
94386: NEG
94387: PUSH
94388: LD_INT 0
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 5
94397: NEG
94398: PUSH
94399: LD_INT 1
94401: NEG
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 5
94409: NEG
94410: PUSH
94411: LD_INT 2
94413: NEG
94414: PUSH
94415: EMPTY
94416: LIST
94417: LIST
94418: PUSH
94419: LD_INT 3
94421: NEG
94422: PUSH
94423: LD_INT 2
94425: PUSH
94426: EMPTY
94427: LIST
94428: LIST
94429: PUSH
94430: LD_INT 3
94432: NEG
94433: PUSH
94434: LD_INT 3
94436: NEG
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 3
94444: NEG
94445: PUSH
94446: LD_INT 4
94448: NEG
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: LD_INT 2
94456: NEG
94457: PUSH
94458: LD_INT 3
94460: NEG
94461: PUSH
94462: EMPTY
94463: LIST
94464: LIST
94465: PUSH
94466: LD_INT 2
94468: NEG
94469: PUSH
94470: LD_INT 2
94472: NEG
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 3
94480: NEG
94481: PUSH
94482: LD_INT 2
94484: NEG
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 4
94492: NEG
94493: PUSH
94494: LD_INT 3
94496: NEG
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PUSH
94502: LD_INT 4
94504: NEG
94505: PUSH
94506: LD_INT 4
94508: NEG
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: PUSH
94514: LD_INT 2
94516: NEG
94517: PUSH
94518: LD_INT 4
94520: NEG
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 4
94528: NEG
94529: PUSH
94530: LD_INT 2
94532: NEG
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: PUSH
94538: LD_INT 0
94540: PUSH
94541: LD_INT 4
94543: NEG
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 0
94551: PUSH
94552: LD_INT 5
94554: NEG
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 1
94562: PUSH
94563: LD_INT 4
94565: NEG
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 1
94573: PUSH
94574: LD_INT 3
94576: NEG
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 0
94584: PUSH
94585: LD_INT 3
94587: NEG
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 1
94595: NEG
94596: PUSH
94597: LD_INT 4
94599: NEG
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: LD_INT 1
94607: NEG
94608: PUSH
94609: LD_INT 5
94611: NEG
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PUSH
94617: LD_INT 2
94619: PUSH
94620: LD_INT 3
94622: NEG
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: PUSH
94628: LD_INT 2
94630: NEG
94631: PUSH
94632: LD_INT 5
94634: NEG
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: PUSH
94640: LD_INT 3
94642: PUSH
94643: LD_INT 0
94645: PUSH
94646: EMPTY
94647: LIST
94648: LIST
94649: PUSH
94650: LD_INT 3
94652: PUSH
94653: LD_INT 1
94655: NEG
94656: PUSH
94657: EMPTY
94658: LIST
94659: LIST
94660: PUSH
94661: LD_INT 4
94663: PUSH
94664: LD_INT 0
94666: PUSH
94667: EMPTY
94668: LIST
94669: LIST
94670: PUSH
94671: LD_INT 4
94673: PUSH
94674: LD_INT 1
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: PUSH
94681: LD_INT 3
94683: PUSH
94684: LD_INT 1
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 2
94693: PUSH
94694: LD_INT 0
94696: PUSH
94697: EMPTY
94698: LIST
94699: LIST
94700: PUSH
94701: LD_INT 2
94703: PUSH
94704: LD_INT 1
94706: NEG
94707: PUSH
94708: EMPTY
94709: LIST
94710: LIST
94711: PUSH
94712: LD_INT 2
94714: PUSH
94715: LD_INT 2
94717: NEG
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 4
94725: PUSH
94726: LD_INT 2
94728: PUSH
94729: EMPTY
94730: LIST
94731: LIST
94732: PUSH
94733: LD_INT 4
94735: PUSH
94736: LD_INT 4
94738: PUSH
94739: EMPTY
94740: LIST
94741: LIST
94742: PUSH
94743: LD_INT 4
94745: PUSH
94746: LD_INT 3
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 5
94755: PUSH
94756: LD_INT 4
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 5
94765: PUSH
94766: LD_INT 5
94768: PUSH
94769: EMPTY
94770: LIST
94771: LIST
94772: PUSH
94773: LD_INT 4
94775: PUSH
94776: LD_INT 5
94778: PUSH
94779: EMPTY
94780: LIST
94781: LIST
94782: PUSH
94783: LD_INT 3
94785: PUSH
94786: LD_INT 4
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PUSH
94793: LD_INT 3
94795: PUSH
94796: LD_INT 3
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 5
94805: PUSH
94806: LD_INT 3
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 3
94815: PUSH
94816: LD_INT 5
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94870: LD_ADDR_VAR 0 33
94874: PUSH
94875: LD_INT 4
94877: NEG
94878: PUSH
94879: LD_INT 4
94881: NEG
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: PUSH
94887: LD_INT 4
94889: NEG
94890: PUSH
94891: LD_INT 5
94893: NEG
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 3
94901: NEG
94902: PUSH
94903: LD_INT 4
94905: NEG
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 3
94913: NEG
94914: PUSH
94915: LD_INT 3
94917: NEG
94918: PUSH
94919: EMPTY
94920: LIST
94921: LIST
94922: PUSH
94923: LD_INT 4
94925: NEG
94926: PUSH
94927: LD_INT 3
94929: NEG
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 5
94937: NEG
94938: PUSH
94939: LD_INT 4
94941: NEG
94942: PUSH
94943: EMPTY
94944: LIST
94945: LIST
94946: PUSH
94947: LD_INT 5
94949: NEG
94950: PUSH
94951: LD_INT 5
94953: NEG
94954: PUSH
94955: EMPTY
94956: LIST
94957: LIST
94958: PUSH
94959: LD_INT 3
94961: NEG
94962: PUSH
94963: LD_INT 5
94965: NEG
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: PUSH
94971: LD_INT 5
94973: NEG
94974: PUSH
94975: LD_INT 3
94977: NEG
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: PUSH
94983: LD_INT 0
94985: PUSH
94986: LD_INT 3
94988: NEG
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: PUSH
94994: LD_INT 0
94996: PUSH
94997: LD_INT 4
94999: NEG
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 1
95007: PUSH
95008: LD_INT 3
95010: NEG
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 1
95018: PUSH
95019: LD_INT 2
95021: NEG
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 0
95029: PUSH
95030: LD_INT 2
95032: NEG
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 1
95040: NEG
95041: PUSH
95042: LD_INT 3
95044: NEG
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 1
95052: NEG
95053: PUSH
95054: LD_INT 4
95056: NEG
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 2
95064: PUSH
95065: LD_INT 2
95067: NEG
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 2
95075: NEG
95076: PUSH
95077: LD_INT 4
95079: NEG
95080: PUSH
95081: EMPTY
95082: LIST
95083: LIST
95084: PUSH
95085: LD_INT 4
95087: PUSH
95088: LD_INT 0
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: PUSH
95095: LD_INT 4
95097: PUSH
95098: LD_INT 1
95100: NEG
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 5
95108: PUSH
95109: LD_INT 0
95111: PUSH
95112: EMPTY
95113: LIST
95114: LIST
95115: PUSH
95116: LD_INT 5
95118: PUSH
95119: LD_INT 1
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: LD_INT 4
95128: PUSH
95129: LD_INT 1
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 3
95138: PUSH
95139: LD_INT 0
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: LD_INT 3
95148: PUSH
95149: LD_INT 1
95151: NEG
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: PUSH
95157: LD_INT 3
95159: PUSH
95160: LD_INT 2
95162: NEG
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: PUSH
95168: LD_INT 5
95170: PUSH
95171: LD_INT 2
95173: PUSH
95174: EMPTY
95175: LIST
95176: LIST
95177: PUSH
95178: LD_INT 3
95180: PUSH
95181: LD_INT 3
95183: PUSH
95184: EMPTY
95185: LIST
95186: LIST
95187: PUSH
95188: LD_INT 3
95190: PUSH
95191: LD_INT 2
95193: PUSH
95194: EMPTY
95195: LIST
95196: LIST
95197: PUSH
95198: LD_INT 4
95200: PUSH
95201: LD_INT 3
95203: PUSH
95204: EMPTY
95205: LIST
95206: LIST
95207: PUSH
95208: LD_INT 4
95210: PUSH
95211: LD_INT 4
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: PUSH
95218: LD_INT 3
95220: PUSH
95221: LD_INT 4
95223: PUSH
95224: EMPTY
95225: LIST
95226: LIST
95227: PUSH
95228: LD_INT 2
95230: PUSH
95231: LD_INT 3
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: PUSH
95238: LD_INT 2
95240: PUSH
95241: LD_INT 2
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: LD_INT 4
95250: PUSH
95251: LD_INT 2
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: PUSH
95258: LD_INT 2
95260: PUSH
95261: LD_INT 4
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 0
95270: PUSH
95271: LD_INT 4
95273: PUSH
95274: EMPTY
95275: LIST
95276: LIST
95277: PUSH
95278: LD_INT 0
95280: PUSH
95281: LD_INT 3
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 1
95290: PUSH
95291: LD_INT 4
95293: PUSH
95294: EMPTY
95295: LIST
95296: LIST
95297: PUSH
95298: LD_INT 1
95300: PUSH
95301: LD_INT 5
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: PUSH
95308: LD_INT 0
95310: PUSH
95311: LD_INT 5
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: PUSH
95318: LD_INT 1
95320: NEG
95321: PUSH
95322: LD_INT 4
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: PUSH
95329: LD_INT 1
95331: NEG
95332: PUSH
95333: LD_INT 3
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: PUSH
95340: LD_INT 2
95342: PUSH
95343: LD_INT 5
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 2
95352: NEG
95353: PUSH
95354: LD_INT 3
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95408: LD_ADDR_VAR 0 34
95412: PUSH
95413: LD_INT 0
95415: PUSH
95416: LD_INT 4
95418: NEG
95419: PUSH
95420: EMPTY
95421: LIST
95422: LIST
95423: PUSH
95424: LD_INT 0
95426: PUSH
95427: LD_INT 5
95429: NEG
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: PUSH
95435: LD_INT 1
95437: PUSH
95438: LD_INT 4
95440: NEG
95441: PUSH
95442: EMPTY
95443: LIST
95444: LIST
95445: PUSH
95446: LD_INT 1
95448: PUSH
95449: LD_INT 3
95451: NEG
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: PUSH
95457: LD_INT 0
95459: PUSH
95460: LD_INT 3
95462: NEG
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 1
95470: NEG
95471: PUSH
95472: LD_INT 4
95474: NEG
95475: PUSH
95476: EMPTY
95477: LIST
95478: LIST
95479: PUSH
95480: LD_INT 1
95482: NEG
95483: PUSH
95484: LD_INT 5
95486: NEG
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: LD_INT 2
95494: PUSH
95495: LD_INT 3
95497: NEG
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 2
95505: NEG
95506: PUSH
95507: LD_INT 5
95509: NEG
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: PUSH
95515: LD_INT 3
95517: PUSH
95518: LD_INT 0
95520: PUSH
95521: EMPTY
95522: LIST
95523: LIST
95524: PUSH
95525: LD_INT 3
95527: PUSH
95528: LD_INT 1
95530: NEG
95531: PUSH
95532: EMPTY
95533: LIST
95534: LIST
95535: PUSH
95536: LD_INT 4
95538: PUSH
95539: LD_INT 0
95541: PUSH
95542: EMPTY
95543: LIST
95544: LIST
95545: PUSH
95546: LD_INT 4
95548: PUSH
95549: LD_INT 1
95551: PUSH
95552: EMPTY
95553: LIST
95554: LIST
95555: PUSH
95556: LD_INT 3
95558: PUSH
95559: LD_INT 1
95561: PUSH
95562: EMPTY
95563: LIST
95564: LIST
95565: PUSH
95566: LD_INT 2
95568: PUSH
95569: LD_INT 0
95571: PUSH
95572: EMPTY
95573: LIST
95574: LIST
95575: PUSH
95576: LD_INT 2
95578: PUSH
95579: LD_INT 1
95581: NEG
95582: PUSH
95583: EMPTY
95584: LIST
95585: LIST
95586: PUSH
95587: LD_INT 2
95589: PUSH
95590: LD_INT 2
95592: NEG
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PUSH
95598: LD_INT 4
95600: PUSH
95601: LD_INT 2
95603: PUSH
95604: EMPTY
95605: LIST
95606: LIST
95607: PUSH
95608: LD_INT 4
95610: PUSH
95611: LD_INT 4
95613: PUSH
95614: EMPTY
95615: LIST
95616: LIST
95617: PUSH
95618: LD_INT 4
95620: PUSH
95621: LD_INT 3
95623: PUSH
95624: EMPTY
95625: LIST
95626: LIST
95627: PUSH
95628: LD_INT 5
95630: PUSH
95631: LD_INT 4
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: PUSH
95638: LD_INT 5
95640: PUSH
95641: LD_INT 5
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 4
95650: PUSH
95651: LD_INT 5
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: LD_INT 3
95660: PUSH
95661: LD_INT 4
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: PUSH
95668: LD_INT 3
95670: PUSH
95671: LD_INT 3
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: PUSH
95678: LD_INT 5
95680: PUSH
95681: LD_INT 3
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: LD_INT 3
95690: PUSH
95691: LD_INT 5
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: PUSH
95698: LD_INT 0
95700: PUSH
95701: LD_INT 3
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: PUSH
95708: LD_INT 0
95710: PUSH
95711: LD_INT 2
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: PUSH
95718: LD_INT 1
95720: PUSH
95721: LD_INT 3
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: PUSH
95728: LD_INT 1
95730: PUSH
95731: LD_INT 4
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: PUSH
95738: LD_INT 0
95740: PUSH
95741: LD_INT 4
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: PUSH
95748: LD_INT 1
95750: NEG
95751: PUSH
95752: LD_INT 3
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 1
95761: NEG
95762: PUSH
95763: LD_INT 2
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: PUSH
95770: LD_INT 2
95772: PUSH
95773: LD_INT 4
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: PUSH
95780: LD_INT 2
95782: NEG
95783: PUSH
95784: LD_INT 2
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: PUSH
95791: LD_INT 4
95793: NEG
95794: PUSH
95795: LD_INT 0
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 4
95804: NEG
95805: PUSH
95806: LD_INT 1
95808: NEG
95809: PUSH
95810: EMPTY
95811: LIST
95812: LIST
95813: PUSH
95814: LD_INT 3
95816: NEG
95817: PUSH
95818: LD_INT 0
95820: PUSH
95821: EMPTY
95822: LIST
95823: LIST
95824: PUSH
95825: LD_INT 3
95827: NEG
95828: PUSH
95829: LD_INT 1
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: LD_INT 4
95838: NEG
95839: PUSH
95840: LD_INT 1
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 5
95849: NEG
95850: PUSH
95851: LD_INT 0
95853: PUSH
95854: EMPTY
95855: LIST
95856: LIST
95857: PUSH
95858: LD_INT 5
95860: NEG
95861: PUSH
95862: LD_INT 1
95864: NEG
95865: PUSH
95866: EMPTY
95867: LIST
95868: LIST
95869: PUSH
95870: LD_INT 5
95872: NEG
95873: PUSH
95874: LD_INT 2
95876: NEG
95877: PUSH
95878: EMPTY
95879: LIST
95880: LIST
95881: PUSH
95882: LD_INT 3
95884: NEG
95885: PUSH
95886: LD_INT 2
95888: PUSH
95889: EMPTY
95890: LIST
95891: LIST
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: ST_TO_ADDR
// end ; end ;
95940: GO 95943
95942: POP
// case btype of b_depot , b_warehouse :
95943: LD_VAR 0 1
95947: PUSH
95948: LD_INT 0
95950: DOUBLE
95951: EQUAL
95952: IFTRUE 95962
95954: LD_INT 1
95956: DOUBLE
95957: EQUAL
95958: IFTRUE 95962
95960: GO 96163
95962: POP
// case nation of nation_american :
95963: LD_VAR 0 5
95967: PUSH
95968: LD_INT 1
95970: DOUBLE
95971: EQUAL
95972: IFTRUE 95976
95974: GO 96032
95976: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95977: LD_ADDR_VAR 0 9
95981: PUSH
95982: LD_VAR 0 11
95986: PUSH
95987: LD_VAR 0 12
95991: PUSH
95992: LD_VAR 0 13
95996: PUSH
95997: LD_VAR 0 14
96001: PUSH
96002: LD_VAR 0 15
96006: PUSH
96007: LD_VAR 0 16
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: PUSH
96020: LD_VAR 0 4
96024: PUSH
96025: LD_INT 1
96027: PLUS
96028: ARRAY
96029: ST_TO_ADDR
96030: GO 96161
96032: LD_INT 2
96034: DOUBLE
96035: EQUAL
96036: IFTRUE 96040
96038: GO 96096
96040: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
96041: LD_ADDR_VAR 0 9
96045: PUSH
96046: LD_VAR 0 17
96050: PUSH
96051: LD_VAR 0 18
96055: PUSH
96056: LD_VAR 0 19
96060: PUSH
96061: LD_VAR 0 20
96065: PUSH
96066: LD_VAR 0 21
96070: PUSH
96071: LD_VAR 0 22
96075: PUSH
96076: EMPTY
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: PUSH
96084: LD_VAR 0 4
96088: PUSH
96089: LD_INT 1
96091: PLUS
96092: ARRAY
96093: ST_TO_ADDR
96094: GO 96161
96096: LD_INT 3
96098: DOUBLE
96099: EQUAL
96100: IFTRUE 96104
96102: GO 96160
96104: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96105: LD_ADDR_VAR 0 9
96109: PUSH
96110: LD_VAR 0 23
96114: PUSH
96115: LD_VAR 0 24
96119: PUSH
96120: LD_VAR 0 25
96124: PUSH
96125: LD_VAR 0 26
96129: PUSH
96130: LD_VAR 0 27
96134: PUSH
96135: LD_VAR 0 28
96139: PUSH
96140: EMPTY
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: PUSH
96148: LD_VAR 0 4
96152: PUSH
96153: LD_INT 1
96155: PLUS
96156: ARRAY
96157: ST_TO_ADDR
96158: GO 96161
96160: POP
96161: GO 96716
96163: LD_INT 2
96165: DOUBLE
96166: EQUAL
96167: IFTRUE 96177
96169: LD_INT 3
96171: DOUBLE
96172: EQUAL
96173: IFTRUE 96177
96175: GO 96233
96177: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96178: LD_ADDR_VAR 0 9
96182: PUSH
96183: LD_VAR 0 29
96187: PUSH
96188: LD_VAR 0 30
96192: PUSH
96193: LD_VAR 0 31
96197: PUSH
96198: LD_VAR 0 32
96202: PUSH
96203: LD_VAR 0 33
96207: PUSH
96208: LD_VAR 0 34
96212: PUSH
96213: EMPTY
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: PUSH
96221: LD_VAR 0 4
96225: PUSH
96226: LD_INT 1
96228: PLUS
96229: ARRAY
96230: ST_TO_ADDR
96231: GO 96716
96233: LD_INT 16
96235: DOUBLE
96236: EQUAL
96237: IFTRUE 96295
96239: LD_INT 17
96241: DOUBLE
96242: EQUAL
96243: IFTRUE 96295
96245: LD_INT 18
96247: DOUBLE
96248: EQUAL
96249: IFTRUE 96295
96251: LD_INT 19
96253: DOUBLE
96254: EQUAL
96255: IFTRUE 96295
96257: LD_INT 22
96259: DOUBLE
96260: EQUAL
96261: IFTRUE 96295
96263: LD_INT 20
96265: DOUBLE
96266: EQUAL
96267: IFTRUE 96295
96269: LD_INT 21
96271: DOUBLE
96272: EQUAL
96273: IFTRUE 96295
96275: LD_INT 23
96277: DOUBLE
96278: EQUAL
96279: IFTRUE 96295
96281: LD_INT 24
96283: DOUBLE
96284: EQUAL
96285: IFTRUE 96295
96287: LD_INT 25
96289: DOUBLE
96290: EQUAL
96291: IFTRUE 96295
96293: GO 96351
96295: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96296: LD_ADDR_VAR 0 9
96300: PUSH
96301: LD_VAR 0 35
96305: PUSH
96306: LD_VAR 0 36
96310: PUSH
96311: LD_VAR 0 37
96315: PUSH
96316: LD_VAR 0 38
96320: PUSH
96321: LD_VAR 0 39
96325: PUSH
96326: LD_VAR 0 40
96330: PUSH
96331: EMPTY
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: PUSH
96339: LD_VAR 0 4
96343: PUSH
96344: LD_INT 1
96346: PLUS
96347: ARRAY
96348: ST_TO_ADDR
96349: GO 96716
96351: LD_INT 6
96353: DOUBLE
96354: EQUAL
96355: IFTRUE 96407
96357: LD_INT 7
96359: DOUBLE
96360: EQUAL
96361: IFTRUE 96407
96363: LD_INT 8
96365: DOUBLE
96366: EQUAL
96367: IFTRUE 96407
96369: LD_INT 13
96371: DOUBLE
96372: EQUAL
96373: IFTRUE 96407
96375: LD_INT 12
96377: DOUBLE
96378: EQUAL
96379: IFTRUE 96407
96381: LD_INT 15
96383: DOUBLE
96384: EQUAL
96385: IFTRUE 96407
96387: LD_INT 11
96389: DOUBLE
96390: EQUAL
96391: IFTRUE 96407
96393: LD_INT 14
96395: DOUBLE
96396: EQUAL
96397: IFTRUE 96407
96399: LD_INT 10
96401: DOUBLE
96402: EQUAL
96403: IFTRUE 96407
96405: GO 96463
96407: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96408: LD_ADDR_VAR 0 9
96412: PUSH
96413: LD_VAR 0 41
96417: PUSH
96418: LD_VAR 0 42
96422: PUSH
96423: LD_VAR 0 43
96427: PUSH
96428: LD_VAR 0 44
96432: PUSH
96433: LD_VAR 0 45
96437: PUSH
96438: LD_VAR 0 46
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: PUSH
96451: LD_VAR 0 4
96455: PUSH
96456: LD_INT 1
96458: PLUS
96459: ARRAY
96460: ST_TO_ADDR
96461: GO 96716
96463: LD_INT 36
96465: DOUBLE
96466: EQUAL
96467: IFTRUE 96471
96469: GO 96527
96471: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96472: LD_ADDR_VAR 0 9
96476: PUSH
96477: LD_VAR 0 47
96481: PUSH
96482: LD_VAR 0 48
96486: PUSH
96487: LD_VAR 0 49
96491: PUSH
96492: LD_VAR 0 50
96496: PUSH
96497: LD_VAR 0 51
96501: PUSH
96502: LD_VAR 0 52
96506: PUSH
96507: EMPTY
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: PUSH
96515: LD_VAR 0 4
96519: PUSH
96520: LD_INT 1
96522: PLUS
96523: ARRAY
96524: ST_TO_ADDR
96525: GO 96716
96527: LD_INT 4
96529: DOUBLE
96530: EQUAL
96531: IFTRUE 96553
96533: LD_INT 5
96535: DOUBLE
96536: EQUAL
96537: IFTRUE 96553
96539: LD_INT 34
96541: DOUBLE
96542: EQUAL
96543: IFTRUE 96553
96545: LD_INT 37
96547: DOUBLE
96548: EQUAL
96549: IFTRUE 96553
96551: GO 96609
96553: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96554: LD_ADDR_VAR 0 9
96558: PUSH
96559: LD_VAR 0 53
96563: PUSH
96564: LD_VAR 0 54
96568: PUSH
96569: LD_VAR 0 55
96573: PUSH
96574: LD_VAR 0 56
96578: PUSH
96579: LD_VAR 0 57
96583: PUSH
96584: LD_VAR 0 58
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: PUSH
96597: LD_VAR 0 4
96601: PUSH
96602: LD_INT 1
96604: PLUS
96605: ARRAY
96606: ST_TO_ADDR
96607: GO 96716
96609: LD_INT 31
96611: DOUBLE
96612: EQUAL
96613: IFTRUE 96659
96615: LD_INT 32
96617: DOUBLE
96618: EQUAL
96619: IFTRUE 96659
96621: LD_INT 33
96623: DOUBLE
96624: EQUAL
96625: IFTRUE 96659
96627: LD_INT 27
96629: DOUBLE
96630: EQUAL
96631: IFTRUE 96659
96633: LD_INT 26
96635: DOUBLE
96636: EQUAL
96637: IFTRUE 96659
96639: LD_INT 28
96641: DOUBLE
96642: EQUAL
96643: IFTRUE 96659
96645: LD_INT 29
96647: DOUBLE
96648: EQUAL
96649: IFTRUE 96659
96651: LD_INT 30
96653: DOUBLE
96654: EQUAL
96655: IFTRUE 96659
96657: GO 96715
96659: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96660: LD_ADDR_VAR 0 9
96664: PUSH
96665: LD_VAR 0 59
96669: PUSH
96670: LD_VAR 0 60
96674: PUSH
96675: LD_VAR 0 61
96679: PUSH
96680: LD_VAR 0 62
96684: PUSH
96685: LD_VAR 0 63
96689: PUSH
96690: LD_VAR 0 64
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: PUSH
96703: LD_VAR 0 4
96707: PUSH
96708: LD_INT 1
96710: PLUS
96711: ARRAY
96712: ST_TO_ADDR
96713: GO 96716
96715: POP
// temp_list2 = [ ] ;
96716: LD_ADDR_VAR 0 10
96720: PUSH
96721: EMPTY
96722: ST_TO_ADDR
// for i in temp_list do
96723: LD_ADDR_VAR 0 8
96727: PUSH
96728: LD_VAR 0 9
96732: PUSH
96733: FOR_IN
96734: IFFALSE 96786
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96736: LD_ADDR_VAR 0 10
96740: PUSH
96741: LD_VAR 0 10
96745: PUSH
96746: LD_VAR 0 8
96750: PUSH
96751: LD_INT 1
96753: ARRAY
96754: PUSH
96755: LD_VAR 0 2
96759: PLUS
96760: PUSH
96761: LD_VAR 0 8
96765: PUSH
96766: LD_INT 2
96768: ARRAY
96769: PUSH
96770: LD_VAR 0 3
96774: PLUS
96775: PUSH
96776: EMPTY
96777: LIST
96778: LIST
96779: PUSH
96780: EMPTY
96781: LIST
96782: ADD
96783: ST_TO_ADDR
96784: GO 96733
96786: POP
96787: POP
// result = temp_list2 ;
96788: LD_ADDR_VAR 0 7
96792: PUSH
96793: LD_VAR 0 10
96797: ST_TO_ADDR
// end ;
96798: LD_VAR 0 7
96802: RET
// export function EnemyInRange ( unit , dist ) ; begin
96803: LD_INT 0
96805: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96806: LD_ADDR_VAR 0 3
96810: PUSH
96811: LD_VAR 0 1
96815: PPUSH
96816: CALL_OW 255
96820: PPUSH
96821: LD_VAR 0 1
96825: PPUSH
96826: CALL_OW 250
96830: PPUSH
96831: LD_VAR 0 1
96835: PPUSH
96836: CALL_OW 251
96840: PPUSH
96841: LD_VAR 0 2
96845: PPUSH
96846: CALL 70907 0 4
96850: PUSH
96851: LD_INT 4
96853: ARRAY
96854: ST_TO_ADDR
// end ;
96855: LD_VAR 0 3
96859: RET
// export function PlayerSeeMe ( unit ) ; begin
96860: LD_INT 0
96862: PPUSH
// result := See ( your_side , unit ) ;
96863: LD_ADDR_VAR 0 2
96867: PUSH
96868: LD_OWVAR 2
96872: PPUSH
96873: LD_VAR 0 1
96877: PPUSH
96878: CALL_OW 292
96882: ST_TO_ADDR
// end ;
96883: LD_VAR 0 2
96887: RET
// export function ReverseDir ( unit ) ; begin
96888: LD_INT 0
96890: PPUSH
// if not unit then
96891: LD_VAR 0 1
96895: NOT
96896: IFFALSE 96900
// exit ;
96898: GO 96923
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96900: LD_ADDR_VAR 0 2
96904: PUSH
96905: LD_VAR 0 1
96909: PPUSH
96910: CALL_OW 254
96914: PUSH
96915: LD_INT 3
96917: PLUS
96918: PUSH
96919: LD_INT 6
96921: MOD
96922: ST_TO_ADDR
// end ;
96923: LD_VAR 0 2
96927: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96928: LD_INT 0
96930: PPUSH
96931: PPUSH
96932: PPUSH
96933: PPUSH
96934: PPUSH
// if not hexes then
96935: LD_VAR 0 2
96939: NOT
96940: IFFALSE 96944
// exit ;
96942: GO 97092
// dist := 9999 ;
96944: LD_ADDR_VAR 0 5
96948: PUSH
96949: LD_INT 9999
96951: ST_TO_ADDR
// for i = 1 to hexes do
96952: LD_ADDR_VAR 0 4
96956: PUSH
96957: DOUBLE
96958: LD_INT 1
96960: DEC
96961: ST_TO_ADDR
96962: LD_VAR 0 2
96966: PUSH
96967: FOR_TO
96968: IFFALSE 97080
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96970: LD_VAR 0 1
96974: PPUSH
96975: LD_VAR 0 2
96979: PUSH
96980: LD_VAR 0 4
96984: ARRAY
96985: PUSH
96986: LD_INT 1
96988: ARRAY
96989: PPUSH
96990: LD_VAR 0 2
96994: PUSH
96995: LD_VAR 0 4
96999: ARRAY
97000: PUSH
97001: LD_INT 2
97003: ARRAY
97004: PPUSH
97005: CALL_OW 297
97009: PUSH
97010: LD_VAR 0 5
97014: LESS
97015: IFFALSE 97078
// begin hex := hexes [ i ] ;
97017: LD_ADDR_VAR 0 7
97021: PUSH
97022: LD_VAR 0 2
97026: PUSH
97027: LD_VAR 0 4
97031: ARRAY
97032: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97033: LD_ADDR_VAR 0 5
97037: PUSH
97038: LD_VAR 0 1
97042: PPUSH
97043: LD_VAR 0 2
97047: PUSH
97048: LD_VAR 0 4
97052: ARRAY
97053: PUSH
97054: LD_INT 1
97056: ARRAY
97057: PPUSH
97058: LD_VAR 0 2
97062: PUSH
97063: LD_VAR 0 4
97067: ARRAY
97068: PUSH
97069: LD_INT 2
97071: ARRAY
97072: PPUSH
97073: CALL_OW 297
97077: ST_TO_ADDR
// end ; end ;
97078: GO 96967
97080: POP
97081: POP
// result := hex ;
97082: LD_ADDR_VAR 0 3
97086: PUSH
97087: LD_VAR 0 7
97091: ST_TO_ADDR
// end ;
97092: LD_VAR 0 3
97096: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97097: LD_INT 0
97099: PPUSH
97100: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97101: LD_VAR 0 1
97105: NOT
97106: PUSH
97107: LD_VAR 0 1
97111: PUSH
97112: LD_INT 21
97114: PUSH
97115: LD_INT 2
97117: PUSH
97118: EMPTY
97119: LIST
97120: LIST
97121: PUSH
97122: LD_INT 23
97124: PUSH
97125: LD_INT 2
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PPUSH
97136: CALL_OW 69
97140: IN
97141: NOT
97142: OR
97143: IFFALSE 97147
// exit ;
97145: GO 97194
// for i = 1 to 3 do
97147: LD_ADDR_VAR 0 3
97151: PUSH
97152: DOUBLE
97153: LD_INT 1
97155: DEC
97156: ST_TO_ADDR
97157: LD_INT 3
97159: PUSH
97160: FOR_TO
97161: IFFALSE 97192
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97163: LD_VAR 0 1
97167: PPUSH
97168: CALL_OW 250
97172: PPUSH
97173: LD_VAR 0 1
97177: PPUSH
97178: CALL_OW 251
97182: PPUSH
97183: LD_INT 1
97185: PPUSH
97186: CALL_OW 453
97190: GO 97160
97192: POP
97193: POP
// end ;
97194: LD_VAR 0 2
97198: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97199: LD_INT 0
97201: PPUSH
97202: PPUSH
97203: PPUSH
97204: PPUSH
97205: PPUSH
97206: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97207: LD_VAR 0 1
97211: NOT
97212: PUSH
97213: LD_VAR 0 2
97217: NOT
97218: OR
97219: PUSH
97220: LD_VAR 0 1
97224: PPUSH
97225: CALL_OW 314
97229: OR
97230: IFFALSE 97234
// exit ;
97232: GO 97675
// x := GetX ( enemy_unit ) ;
97234: LD_ADDR_VAR 0 7
97238: PUSH
97239: LD_VAR 0 2
97243: PPUSH
97244: CALL_OW 250
97248: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97249: LD_ADDR_VAR 0 8
97253: PUSH
97254: LD_VAR 0 2
97258: PPUSH
97259: CALL_OW 251
97263: ST_TO_ADDR
// if not x or not y then
97264: LD_VAR 0 7
97268: NOT
97269: PUSH
97270: LD_VAR 0 8
97274: NOT
97275: OR
97276: IFFALSE 97280
// exit ;
97278: GO 97675
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97280: LD_ADDR_VAR 0 6
97284: PUSH
97285: LD_VAR 0 7
97289: PPUSH
97290: LD_INT 0
97292: PPUSH
97293: LD_INT 4
97295: PPUSH
97296: CALL_OW 272
97300: PUSH
97301: LD_VAR 0 8
97305: PPUSH
97306: LD_INT 0
97308: PPUSH
97309: LD_INT 4
97311: PPUSH
97312: CALL_OW 273
97316: PUSH
97317: EMPTY
97318: LIST
97319: LIST
97320: PUSH
97321: LD_VAR 0 7
97325: PPUSH
97326: LD_INT 1
97328: PPUSH
97329: LD_INT 4
97331: PPUSH
97332: CALL_OW 272
97336: PUSH
97337: LD_VAR 0 8
97341: PPUSH
97342: LD_INT 1
97344: PPUSH
97345: LD_INT 4
97347: PPUSH
97348: CALL_OW 273
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_VAR 0 7
97361: PPUSH
97362: LD_INT 2
97364: PPUSH
97365: LD_INT 4
97367: PPUSH
97368: CALL_OW 272
97372: PUSH
97373: LD_VAR 0 8
97377: PPUSH
97378: LD_INT 2
97380: PPUSH
97381: LD_INT 4
97383: PPUSH
97384: CALL_OW 273
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: LD_VAR 0 7
97397: PPUSH
97398: LD_INT 3
97400: PPUSH
97401: LD_INT 4
97403: PPUSH
97404: CALL_OW 272
97408: PUSH
97409: LD_VAR 0 8
97413: PPUSH
97414: LD_INT 3
97416: PPUSH
97417: LD_INT 4
97419: PPUSH
97420: CALL_OW 273
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: PUSH
97429: LD_VAR 0 7
97433: PPUSH
97434: LD_INT 4
97436: PPUSH
97437: LD_INT 4
97439: PPUSH
97440: CALL_OW 272
97444: PUSH
97445: LD_VAR 0 8
97449: PPUSH
97450: LD_INT 4
97452: PPUSH
97453: LD_INT 4
97455: PPUSH
97456: CALL_OW 273
97460: PUSH
97461: EMPTY
97462: LIST
97463: LIST
97464: PUSH
97465: LD_VAR 0 7
97469: PPUSH
97470: LD_INT 5
97472: PPUSH
97473: LD_INT 4
97475: PPUSH
97476: CALL_OW 272
97480: PUSH
97481: LD_VAR 0 8
97485: PPUSH
97486: LD_INT 5
97488: PPUSH
97489: LD_INT 4
97491: PPUSH
97492: CALL_OW 273
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: EMPTY
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: ST_TO_ADDR
// for i = tmp downto 1 do
97509: LD_ADDR_VAR 0 4
97513: PUSH
97514: DOUBLE
97515: LD_VAR 0 6
97519: INC
97520: ST_TO_ADDR
97521: LD_INT 1
97523: PUSH
97524: FOR_DOWNTO
97525: IFFALSE 97626
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97527: LD_VAR 0 6
97531: PUSH
97532: LD_VAR 0 4
97536: ARRAY
97537: PUSH
97538: LD_INT 1
97540: ARRAY
97541: PPUSH
97542: LD_VAR 0 6
97546: PUSH
97547: LD_VAR 0 4
97551: ARRAY
97552: PUSH
97553: LD_INT 2
97555: ARRAY
97556: PPUSH
97557: CALL_OW 488
97561: NOT
97562: PUSH
97563: LD_VAR 0 6
97567: PUSH
97568: LD_VAR 0 4
97572: ARRAY
97573: PUSH
97574: LD_INT 1
97576: ARRAY
97577: PPUSH
97578: LD_VAR 0 6
97582: PUSH
97583: LD_VAR 0 4
97587: ARRAY
97588: PUSH
97589: LD_INT 2
97591: ARRAY
97592: PPUSH
97593: CALL_OW 428
97597: PUSH
97598: LD_INT 0
97600: NONEQUAL
97601: OR
97602: IFFALSE 97624
// tmp := Delete ( tmp , i ) ;
97604: LD_ADDR_VAR 0 6
97608: PUSH
97609: LD_VAR 0 6
97613: PPUSH
97614: LD_VAR 0 4
97618: PPUSH
97619: CALL_OW 3
97623: ST_TO_ADDR
97624: GO 97524
97626: POP
97627: POP
// j := GetClosestHex ( unit , tmp ) ;
97628: LD_ADDR_VAR 0 5
97632: PUSH
97633: LD_VAR 0 1
97637: PPUSH
97638: LD_VAR 0 6
97642: PPUSH
97643: CALL 96928 0 2
97647: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97648: LD_VAR 0 1
97652: PPUSH
97653: LD_VAR 0 5
97657: PUSH
97658: LD_INT 1
97660: ARRAY
97661: PPUSH
97662: LD_VAR 0 5
97666: PUSH
97667: LD_INT 2
97669: ARRAY
97670: PPUSH
97671: CALL_OW 111
// end ;
97675: LD_VAR 0 3
97679: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97680: LD_INT 0
97682: PPUSH
97683: PPUSH
97684: PPUSH
// uc_side = 0 ;
97685: LD_ADDR_OWVAR 20
97689: PUSH
97690: LD_INT 0
97692: ST_TO_ADDR
// uc_nation = 0 ;
97693: LD_ADDR_OWVAR 21
97697: PUSH
97698: LD_INT 0
97700: ST_TO_ADDR
// InitHc ;
97701: CALL_OW 19
// InitVc ;
97705: CALL_OW 20
// if mastodonts then
97709: LD_VAR 0 6
97713: IFFALSE 97780
// for i = 1 to mastodonts do
97715: LD_ADDR_VAR 0 11
97719: PUSH
97720: DOUBLE
97721: LD_INT 1
97723: DEC
97724: ST_TO_ADDR
97725: LD_VAR 0 6
97729: PUSH
97730: FOR_TO
97731: IFFALSE 97778
// begin vc_chassis := 31 ;
97733: LD_ADDR_OWVAR 37
97737: PUSH
97738: LD_INT 31
97740: ST_TO_ADDR
// vc_control := control_rider ;
97741: LD_ADDR_OWVAR 38
97745: PUSH
97746: LD_INT 4
97748: ST_TO_ADDR
// animal := CreateVehicle ;
97749: LD_ADDR_VAR 0 12
97753: PUSH
97754: CALL_OW 45
97758: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97759: LD_VAR 0 12
97763: PPUSH
97764: LD_VAR 0 8
97768: PPUSH
97769: LD_INT 0
97771: PPUSH
97772: CALL 99849 0 3
// end ;
97776: GO 97730
97778: POP
97779: POP
// if horses then
97780: LD_VAR 0 5
97784: IFFALSE 97851
// for i = 1 to horses do
97786: LD_ADDR_VAR 0 11
97790: PUSH
97791: DOUBLE
97792: LD_INT 1
97794: DEC
97795: ST_TO_ADDR
97796: LD_VAR 0 5
97800: PUSH
97801: FOR_TO
97802: IFFALSE 97849
// begin hc_class := 21 ;
97804: LD_ADDR_OWVAR 28
97808: PUSH
97809: LD_INT 21
97811: ST_TO_ADDR
// hc_gallery :=  ;
97812: LD_ADDR_OWVAR 33
97816: PUSH
97817: LD_STRING 
97819: ST_TO_ADDR
// animal := CreateHuman ;
97820: LD_ADDR_VAR 0 12
97824: PUSH
97825: CALL_OW 44
97829: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97830: LD_VAR 0 12
97834: PPUSH
97835: LD_VAR 0 8
97839: PPUSH
97840: LD_INT 0
97842: PPUSH
97843: CALL 99849 0 3
// end ;
97847: GO 97801
97849: POP
97850: POP
// if birds then
97851: LD_VAR 0 1
97855: IFFALSE 97922
// for i = 1 to birds do
97857: LD_ADDR_VAR 0 11
97861: PUSH
97862: DOUBLE
97863: LD_INT 1
97865: DEC
97866: ST_TO_ADDR
97867: LD_VAR 0 1
97871: PUSH
97872: FOR_TO
97873: IFFALSE 97920
// begin hc_class = 18 ;
97875: LD_ADDR_OWVAR 28
97879: PUSH
97880: LD_INT 18
97882: ST_TO_ADDR
// hc_gallery =  ;
97883: LD_ADDR_OWVAR 33
97887: PUSH
97888: LD_STRING 
97890: ST_TO_ADDR
// animal := CreateHuman ;
97891: LD_ADDR_VAR 0 12
97895: PUSH
97896: CALL_OW 44
97900: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97901: LD_VAR 0 12
97905: PPUSH
97906: LD_VAR 0 8
97910: PPUSH
97911: LD_INT 0
97913: PPUSH
97914: CALL 99849 0 3
// end ;
97918: GO 97872
97920: POP
97921: POP
// if tigers then
97922: LD_VAR 0 2
97926: IFFALSE 98010
// for i = 1 to tigers do
97928: LD_ADDR_VAR 0 11
97932: PUSH
97933: DOUBLE
97934: LD_INT 1
97936: DEC
97937: ST_TO_ADDR
97938: LD_VAR 0 2
97942: PUSH
97943: FOR_TO
97944: IFFALSE 98008
// begin hc_class = class_tiger ;
97946: LD_ADDR_OWVAR 28
97950: PUSH
97951: LD_INT 14
97953: ST_TO_ADDR
// hc_gallery =  ;
97954: LD_ADDR_OWVAR 33
97958: PUSH
97959: LD_STRING 
97961: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97962: LD_ADDR_OWVAR 35
97966: PUSH
97967: LD_INT 7
97969: NEG
97970: PPUSH
97971: LD_INT 7
97973: PPUSH
97974: CALL_OW 12
97978: ST_TO_ADDR
// animal := CreateHuman ;
97979: LD_ADDR_VAR 0 12
97983: PUSH
97984: CALL_OW 44
97988: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97989: LD_VAR 0 12
97993: PPUSH
97994: LD_VAR 0 8
97998: PPUSH
97999: LD_INT 0
98001: PPUSH
98002: CALL 99849 0 3
// end ;
98006: GO 97943
98008: POP
98009: POP
// if apemans then
98010: LD_VAR 0 3
98014: IFFALSE 98137
// for i = 1 to apemans do
98016: LD_ADDR_VAR 0 11
98020: PUSH
98021: DOUBLE
98022: LD_INT 1
98024: DEC
98025: ST_TO_ADDR
98026: LD_VAR 0 3
98030: PUSH
98031: FOR_TO
98032: IFFALSE 98135
// begin hc_class = class_apeman ;
98034: LD_ADDR_OWVAR 28
98038: PUSH
98039: LD_INT 12
98041: ST_TO_ADDR
// hc_gallery =  ;
98042: LD_ADDR_OWVAR 33
98046: PUSH
98047: LD_STRING 
98049: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98050: LD_ADDR_OWVAR 35
98054: PUSH
98055: LD_INT 5
98057: NEG
98058: PPUSH
98059: LD_INT 5
98061: PPUSH
98062: CALL_OW 12
98066: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98067: LD_ADDR_OWVAR 31
98071: PUSH
98072: LD_INT 1
98074: PPUSH
98075: LD_INT 3
98077: PPUSH
98078: CALL_OW 12
98082: PUSH
98083: LD_INT 1
98085: PPUSH
98086: LD_INT 3
98088: PPUSH
98089: CALL_OW 12
98093: PUSH
98094: LD_INT 0
98096: PUSH
98097: LD_INT 0
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: ST_TO_ADDR
// animal := CreateHuman ;
98106: LD_ADDR_VAR 0 12
98110: PUSH
98111: CALL_OW 44
98115: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98116: LD_VAR 0 12
98120: PPUSH
98121: LD_VAR 0 8
98125: PPUSH
98126: LD_INT 0
98128: PPUSH
98129: CALL 99849 0 3
// end ;
98133: GO 98031
98135: POP
98136: POP
// if enchidnas then
98137: LD_VAR 0 4
98141: IFFALSE 98208
// for i = 1 to enchidnas do
98143: LD_ADDR_VAR 0 11
98147: PUSH
98148: DOUBLE
98149: LD_INT 1
98151: DEC
98152: ST_TO_ADDR
98153: LD_VAR 0 4
98157: PUSH
98158: FOR_TO
98159: IFFALSE 98206
// begin hc_class = 13 ;
98161: LD_ADDR_OWVAR 28
98165: PUSH
98166: LD_INT 13
98168: ST_TO_ADDR
// hc_gallery =  ;
98169: LD_ADDR_OWVAR 33
98173: PUSH
98174: LD_STRING 
98176: ST_TO_ADDR
// animal := CreateHuman ;
98177: LD_ADDR_VAR 0 12
98181: PUSH
98182: CALL_OW 44
98186: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98187: LD_VAR 0 12
98191: PPUSH
98192: LD_VAR 0 8
98196: PPUSH
98197: LD_INT 0
98199: PPUSH
98200: CALL 99849 0 3
// end ;
98204: GO 98158
98206: POP
98207: POP
// if fishes then
98208: LD_VAR 0 7
98212: IFFALSE 98279
// for i = 1 to fishes do
98214: LD_ADDR_VAR 0 11
98218: PUSH
98219: DOUBLE
98220: LD_INT 1
98222: DEC
98223: ST_TO_ADDR
98224: LD_VAR 0 7
98228: PUSH
98229: FOR_TO
98230: IFFALSE 98277
// begin hc_class = 20 ;
98232: LD_ADDR_OWVAR 28
98236: PUSH
98237: LD_INT 20
98239: ST_TO_ADDR
// hc_gallery =  ;
98240: LD_ADDR_OWVAR 33
98244: PUSH
98245: LD_STRING 
98247: ST_TO_ADDR
// animal := CreateHuman ;
98248: LD_ADDR_VAR 0 12
98252: PUSH
98253: CALL_OW 44
98257: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98258: LD_VAR 0 12
98262: PPUSH
98263: LD_VAR 0 9
98267: PPUSH
98268: LD_INT 0
98270: PPUSH
98271: CALL 99849 0 3
// end ;
98275: GO 98229
98277: POP
98278: POP
// end ;
98279: LD_VAR 0 10
98283: RET
// export function WantHeal ( sci , unit ) ; begin
98284: LD_INT 0
98286: PPUSH
// if GetTaskList ( sci ) > 0 then
98287: LD_VAR 0 1
98291: PPUSH
98292: CALL_OW 437
98296: PUSH
98297: LD_INT 0
98299: GREATER
98300: IFFALSE 98370
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98302: LD_VAR 0 1
98306: PPUSH
98307: CALL_OW 437
98311: PUSH
98312: LD_INT 1
98314: ARRAY
98315: PUSH
98316: LD_INT 1
98318: ARRAY
98319: PUSH
98320: LD_STRING l
98322: EQUAL
98323: PUSH
98324: LD_VAR 0 1
98328: PPUSH
98329: CALL_OW 437
98333: PUSH
98334: LD_INT 1
98336: ARRAY
98337: PUSH
98338: LD_INT 4
98340: ARRAY
98341: PUSH
98342: LD_VAR 0 2
98346: EQUAL
98347: AND
98348: IFFALSE 98360
// result := true else
98350: LD_ADDR_VAR 0 3
98354: PUSH
98355: LD_INT 1
98357: ST_TO_ADDR
98358: GO 98368
// result := false ;
98360: LD_ADDR_VAR 0 3
98364: PUSH
98365: LD_INT 0
98367: ST_TO_ADDR
// end else
98368: GO 98378
// result := false ;
98370: LD_ADDR_VAR 0 3
98374: PUSH
98375: LD_INT 0
98377: ST_TO_ADDR
// end ;
98378: LD_VAR 0 3
98382: RET
// export function HealTarget ( sci ) ; begin
98383: LD_INT 0
98385: PPUSH
// if not sci then
98386: LD_VAR 0 1
98390: NOT
98391: IFFALSE 98395
// exit ;
98393: GO 98460
// result := 0 ;
98395: LD_ADDR_VAR 0 2
98399: PUSH
98400: LD_INT 0
98402: ST_TO_ADDR
// if GetTaskList ( sci ) then
98403: LD_VAR 0 1
98407: PPUSH
98408: CALL_OW 437
98412: IFFALSE 98460
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98414: LD_VAR 0 1
98418: PPUSH
98419: CALL_OW 437
98423: PUSH
98424: LD_INT 1
98426: ARRAY
98427: PUSH
98428: LD_INT 1
98430: ARRAY
98431: PUSH
98432: LD_STRING l
98434: EQUAL
98435: IFFALSE 98460
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98437: LD_ADDR_VAR 0 2
98441: PUSH
98442: LD_VAR 0 1
98446: PPUSH
98447: CALL_OW 437
98451: PUSH
98452: LD_INT 1
98454: ARRAY
98455: PUSH
98456: LD_INT 4
98458: ARRAY
98459: ST_TO_ADDR
// end ;
98460: LD_VAR 0 2
98464: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98465: LD_INT 0
98467: PPUSH
98468: PPUSH
98469: PPUSH
98470: PPUSH
// if not base_units then
98471: LD_VAR 0 1
98475: NOT
98476: IFFALSE 98480
// exit ;
98478: GO 98567
// result := false ;
98480: LD_ADDR_VAR 0 2
98484: PUSH
98485: LD_INT 0
98487: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98488: LD_ADDR_VAR 0 5
98492: PUSH
98493: LD_VAR 0 1
98497: PPUSH
98498: LD_INT 21
98500: PUSH
98501: LD_INT 3
98503: PUSH
98504: EMPTY
98505: LIST
98506: LIST
98507: PPUSH
98508: CALL_OW 72
98512: ST_TO_ADDR
// if not tmp then
98513: LD_VAR 0 5
98517: NOT
98518: IFFALSE 98522
// exit ;
98520: GO 98567
// for i in tmp do
98522: LD_ADDR_VAR 0 3
98526: PUSH
98527: LD_VAR 0 5
98531: PUSH
98532: FOR_IN
98533: IFFALSE 98565
// begin result := EnemyInRange ( i , 22 ) ;
98535: LD_ADDR_VAR 0 2
98539: PUSH
98540: LD_VAR 0 3
98544: PPUSH
98545: LD_INT 22
98547: PPUSH
98548: CALL 96803 0 2
98552: ST_TO_ADDR
// if result then
98553: LD_VAR 0 2
98557: IFFALSE 98563
// exit ;
98559: POP
98560: POP
98561: GO 98567
// end ;
98563: GO 98532
98565: POP
98566: POP
// end ;
98567: LD_VAR 0 2
98571: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98572: LD_INT 0
98574: PPUSH
98575: PPUSH
// if not units then
98576: LD_VAR 0 1
98580: NOT
98581: IFFALSE 98585
// exit ;
98583: GO 98655
// result := [ ] ;
98585: LD_ADDR_VAR 0 3
98589: PUSH
98590: EMPTY
98591: ST_TO_ADDR
// for i in units do
98592: LD_ADDR_VAR 0 4
98596: PUSH
98597: LD_VAR 0 1
98601: PUSH
98602: FOR_IN
98603: IFFALSE 98653
// if GetTag ( i ) = tag then
98605: LD_VAR 0 4
98609: PPUSH
98610: CALL_OW 110
98614: PUSH
98615: LD_VAR 0 2
98619: EQUAL
98620: IFFALSE 98651
// result := Insert ( result , result + 1 , i ) ;
98622: LD_ADDR_VAR 0 3
98626: PUSH
98627: LD_VAR 0 3
98631: PPUSH
98632: LD_VAR 0 3
98636: PUSH
98637: LD_INT 1
98639: PLUS
98640: PPUSH
98641: LD_VAR 0 4
98645: PPUSH
98646: CALL_OW 2
98650: ST_TO_ADDR
98651: GO 98602
98653: POP
98654: POP
// end ;
98655: LD_VAR 0 3
98659: RET
// export function IsDriver ( un ) ; begin
98660: LD_INT 0
98662: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98663: LD_ADDR_VAR 0 2
98667: PUSH
98668: LD_VAR 0 1
98672: PUSH
98673: LD_INT 55
98675: PUSH
98676: EMPTY
98677: LIST
98678: PPUSH
98679: CALL_OW 69
98683: IN
98684: ST_TO_ADDR
// end ;
98685: LD_VAR 0 2
98689: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98690: LD_INT 0
98692: PPUSH
98693: PPUSH
// list := [ ] ;
98694: LD_ADDR_VAR 0 5
98698: PUSH
98699: EMPTY
98700: ST_TO_ADDR
// case d of 0 :
98701: LD_VAR 0 3
98705: PUSH
98706: LD_INT 0
98708: DOUBLE
98709: EQUAL
98710: IFTRUE 98714
98712: GO 98847
98714: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98715: LD_ADDR_VAR 0 5
98719: PUSH
98720: LD_VAR 0 1
98724: PUSH
98725: LD_INT 4
98727: MINUS
98728: PUSH
98729: LD_VAR 0 2
98733: PUSH
98734: LD_INT 4
98736: MINUS
98737: PUSH
98738: LD_INT 2
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: LIST
98745: PUSH
98746: LD_VAR 0 1
98750: PUSH
98751: LD_INT 3
98753: MINUS
98754: PUSH
98755: LD_VAR 0 2
98759: PUSH
98760: LD_INT 1
98762: PUSH
98763: EMPTY
98764: LIST
98765: LIST
98766: LIST
98767: PUSH
98768: LD_VAR 0 1
98772: PUSH
98773: LD_INT 4
98775: PLUS
98776: PUSH
98777: LD_VAR 0 2
98781: PUSH
98782: LD_INT 4
98784: PUSH
98785: EMPTY
98786: LIST
98787: LIST
98788: LIST
98789: PUSH
98790: LD_VAR 0 1
98794: PUSH
98795: LD_INT 3
98797: PLUS
98798: PUSH
98799: LD_VAR 0 2
98803: PUSH
98804: LD_INT 3
98806: PLUS
98807: PUSH
98808: LD_INT 5
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: LIST
98815: PUSH
98816: LD_VAR 0 1
98820: PUSH
98821: LD_VAR 0 2
98825: PUSH
98826: LD_INT 4
98828: PLUS
98829: PUSH
98830: LD_INT 0
98832: PUSH
98833: EMPTY
98834: LIST
98835: LIST
98836: LIST
98837: PUSH
98838: EMPTY
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: ST_TO_ADDR
// end ; 1 :
98845: GO 99545
98847: LD_INT 1
98849: DOUBLE
98850: EQUAL
98851: IFTRUE 98855
98853: GO 98988
98855: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98856: LD_ADDR_VAR 0 5
98860: PUSH
98861: LD_VAR 0 1
98865: PUSH
98866: LD_VAR 0 2
98870: PUSH
98871: LD_INT 4
98873: MINUS
98874: PUSH
98875: LD_INT 3
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: LIST
98882: PUSH
98883: LD_VAR 0 1
98887: PUSH
98888: LD_INT 3
98890: MINUS
98891: PUSH
98892: LD_VAR 0 2
98896: PUSH
98897: LD_INT 3
98899: MINUS
98900: PUSH
98901: LD_INT 2
98903: PUSH
98904: EMPTY
98905: LIST
98906: LIST
98907: LIST
98908: PUSH
98909: LD_VAR 0 1
98913: PUSH
98914: LD_INT 4
98916: MINUS
98917: PUSH
98918: LD_VAR 0 2
98922: PUSH
98923: LD_INT 1
98925: PUSH
98926: EMPTY
98927: LIST
98928: LIST
98929: LIST
98930: PUSH
98931: LD_VAR 0 1
98935: PUSH
98936: LD_VAR 0 2
98940: PUSH
98941: LD_INT 3
98943: PLUS
98944: PUSH
98945: LD_INT 0
98947: PUSH
98948: EMPTY
98949: LIST
98950: LIST
98951: LIST
98952: PUSH
98953: LD_VAR 0 1
98957: PUSH
98958: LD_INT 4
98960: PLUS
98961: PUSH
98962: LD_VAR 0 2
98966: PUSH
98967: LD_INT 4
98969: PLUS
98970: PUSH
98971: LD_INT 5
98973: PUSH
98974: EMPTY
98975: LIST
98976: LIST
98977: LIST
98978: PUSH
98979: EMPTY
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: ST_TO_ADDR
// end ; 2 :
98986: GO 99545
98988: LD_INT 2
98990: DOUBLE
98991: EQUAL
98992: IFTRUE 98996
98994: GO 99125
98996: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
98997: LD_ADDR_VAR 0 5
99001: PUSH
99002: LD_VAR 0 1
99006: PUSH
99007: LD_VAR 0 2
99011: PUSH
99012: LD_INT 3
99014: MINUS
99015: PUSH
99016: LD_INT 3
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: LIST
99023: PUSH
99024: LD_VAR 0 1
99028: PUSH
99029: LD_INT 4
99031: PLUS
99032: PUSH
99033: LD_VAR 0 2
99037: PUSH
99038: LD_INT 4
99040: PUSH
99041: EMPTY
99042: LIST
99043: LIST
99044: LIST
99045: PUSH
99046: LD_VAR 0 1
99050: PUSH
99051: LD_VAR 0 2
99055: PUSH
99056: LD_INT 4
99058: PLUS
99059: PUSH
99060: LD_INT 0
99062: PUSH
99063: EMPTY
99064: LIST
99065: LIST
99066: LIST
99067: PUSH
99068: LD_VAR 0 1
99072: PUSH
99073: LD_INT 3
99075: MINUS
99076: PUSH
99077: LD_VAR 0 2
99081: PUSH
99082: LD_INT 1
99084: PUSH
99085: EMPTY
99086: LIST
99087: LIST
99088: LIST
99089: PUSH
99090: LD_VAR 0 1
99094: PUSH
99095: LD_INT 4
99097: MINUS
99098: PUSH
99099: LD_VAR 0 2
99103: PUSH
99104: LD_INT 4
99106: MINUS
99107: PUSH
99108: LD_INT 2
99110: PUSH
99111: EMPTY
99112: LIST
99113: LIST
99114: LIST
99115: PUSH
99116: EMPTY
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: ST_TO_ADDR
// end ; 3 :
99123: GO 99545
99125: LD_INT 3
99127: DOUBLE
99128: EQUAL
99129: IFTRUE 99133
99131: GO 99266
99133: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99134: LD_ADDR_VAR 0 5
99138: PUSH
99139: LD_VAR 0 1
99143: PUSH
99144: LD_INT 3
99146: PLUS
99147: PUSH
99148: LD_VAR 0 2
99152: PUSH
99153: LD_INT 4
99155: PUSH
99156: EMPTY
99157: LIST
99158: LIST
99159: LIST
99160: PUSH
99161: LD_VAR 0 1
99165: PUSH
99166: LD_INT 4
99168: PLUS
99169: PUSH
99170: LD_VAR 0 2
99174: PUSH
99175: LD_INT 4
99177: PLUS
99178: PUSH
99179: LD_INT 5
99181: PUSH
99182: EMPTY
99183: LIST
99184: LIST
99185: LIST
99186: PUSH
99187: LD_VAR 0 1
99191: PUSH
99192: LD_INT 4
99194: MINUS
99195: PUSH
99196: LD_VAR 0 2
99200: PUSH
99201: LD_INT 1
99203: PUSH
99204: EMPTY
99205: LIST
99206: LIST
99207: LIST
99208: PUSH
99209: LD_VAR 0 1
99213: PUSH
99214: LD_VAR 0 2
99218: PUSH
99219: LD_INT 4
99221: MINUS
99222: PUSH
99223: LD_INT 3
99225: PUSH
99226: EMPTY
99227: LIST
99228: LIST
99229: LIST
99230: PUSH
99231: LD_VAR 0 1
99235: PUSH
99236: LD_INT 3
99238: MINUS
99239: PUSH
99240: LD_VAR 0 2
99244: PUSH
99245: LD_INT 3
99247: MINUS
99248: PUSH
99249: LD_INT 2
99251: PUSH
99252: EMPTY
99253: LIST
99254: LIST
99255: LIST
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: ST_TO_ADDR
// end ; 4 :
99264: GO 99545
99266: LD_INT 4
99268: DOUBLE
99269: EQUAL
99270: IFTRUE 99274
99272: GO 99407
99274: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99275: LD_ADDR_VAR 0 5
99279: PUSH
99280: LD_VAR 0 1
99284: PUSH
99285: LD_VAR 0 2
99289: PUSH
99290: LD_INT 4
99292: PLUS
99293: PUSH
99294: LD_INT 0
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: LIST
99301: PUSH
99302: LD_VAR 0 1
99306: PUSH
99307: LD_INT 3
99309: PLUS
99310: PUSH
99311: LD_VAR 0 2
99315: PUSH
99316: LD_INT 3
99318: PLUS
99319: PUSH
99320: LD_INT 5
99322: PUSH
99323: EMPTY
99324: LIST
99325: LIST
99326: LIST
99327: PUSH
99328: LD_VAR 0 1
99332: PUSH
99333: LD_INT 4
99335: PLUS
99336: PUSH
99337: LD_VAR 0 2
99341: PUSH
99342: LD_INT 4
99344: PUSH
99345: EMPTY
99346: LIST
99347: LIST
99348: LIST
99349: PUSH
99350: LD_VAR 0 1
99354: PUSH
99355: LD_VAR 0 2
99359: PUSH
99360: LD_INT 3
99362: MINUS
99363: PUSH
99364: LD_INT 3
99366: PUSH
99367: EMPTY
99368: LIST
99369: LIST
99370: LIST
99371: PUSH
99372: LD_VAR 0 1
99376: PUSH
99377: LD_INT 4
99379: MINUS
99380: PUSH
99381: LD_VAR 0 2
99385: PUSH
99386: LD_INT 4
99388: MINUS
99389: PUSH
99390: LD_INT 2
99392: PUSH
99393: EMPTY
99394: LIST
99395: LIST
99396: LIST
99397: PUSH
99398: EMPTY
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: ST_TO_ADDR
// end ; 5 :
99405: GO 99545
99407: LD_INT 5
99409: DOUBLE
99410: EQUAL
99411: IFTRUE 99415
99413: GO 99544
99415: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99416: LD_ADDR_VAR 0 5
99420: PUSH
99421: LD_VAR 0 1
99425: PUSH
99426: LD_INT 4
99428: MINUS
99429: PUSH
99430: LD_VAR 0 2
99434: PUSH
99435: LD_INT 1
99437: PUSH
99438: EMPTY
99439: LIST
99440: LIST
99441: LIST
99442: PUSH
99443: LD_VAR 0 1
99447: PUSH
99448: LD_VAR 0 2
99452: PUSH
99453: LD_INT 4
99455: MINUS
99456: PUSH
99457: LD_INT 3
99459: PUSH
99460: EMPTY
99461: LIST
99462: LIST
99463: LIST
99464: PUSH
99465: LD_VAR 0 1
99469: PUSH
99470: LD_INT 4
99472: PLUS
99473: PUSH
99474: LD_VAR 0 2
99478: PUSH
99479: LD_INT 4
99481: PLUS
99482: PUSH
99483: LD_INT 5
99485: PUSH
99486: EMPTY
99487: LIST
99488: LIST
99489: LIST
99490: PUSH
99491: LD_VAR 0 1
99495: PUSH
99496: LD_INT 3
99498: PLUS
99499: PUSH
99500: LD_VAR 0 2
99504: PUSH
99505: LD_INT 4
99507: PUSH
99508: EMPTY
99509: LIST
99510: LIST
99511: LIST
99512: PUSH
99513: LD_VAR 0 1
99517: PUSH
99518: LD_VAR 0 2
99522: PUSH
99523: LD_INT 3
99525: PLUS
99526: PUSH
99527: LD_INT 0
99529: PUSH
99530: EMPTY
99531: LIST
99532: LIST
99533: LIST
99534: PUSH
99535: EMPTY
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: ST_TO_ADDR
// end ; end ;
99542: GO 99545
99544: POP
// result := list ;
99545: LD_ADDR_VAR 0 4
99549: PUSH
99550: LD_VAR 0 5
99554: ST_TO_ADDR
// end ;
99555: LD_VAR 0 4
99559: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99560: LD_INT 0
99562: PPUSH
99563: PPUSH
99564: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99565: LD_VAR 0 1
99569: NOT
99570: PUSH
99571: LD_VAR 0 2
99575: PUSH
99576: LD_INT 1
99578: PUSH
99579: LD_INT 2
99581: PUSH
99582: LD_INT 3
99584: PUSH
99585: LD_INT 4
99587: PUSH
99588: EMPTY
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: IN
99594: NOT
99595: OR
99596: IFFALSE 99600
// exit ;
99598: GO 99692
// tmp := [ ] ;
99600: LD_ADDR_VAR 0 5
99604: PUSH
99605: EMPTY
99606: ST_TO_ADDR
// for i in units do
99607: LD_ADDR_VAR 0 4
99611: PUSH
99612: LD_VAR 0 1
99616: PUSH
99617: FOR_IN
99618: IFFALSE 99661
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99620: LD_ADDR_VAR 0 5
99624: PUSH
99625: LD_VAR 0 5
99629: PPUSH
99630: LD_VAR 0 5
99634: PUSH
99635: LD_INT 1
99637: PLUS
99638: PPUSH
99639: LD_VAR 0 4
99643: PPUSH
99644: LD_VAR 0 2
99648: PPUSH
99649: CALL_OW 259
99653: PPUSH
99654: CALL_OW 2
99658: ST_TO_ADDR
99659: GO 99617
99661: POP
99662: POP
// if not tmp then
99663: LD_VAR 0 5
99667: NOT
99668: IFFALSE 99672
// exit ;
99670: GO 99692
// result := SortListByListDesc ( units , tmp ) ;
99672: LD_ADDR_VAR 0 3
99676: PUSH
99677: LD_VAR 0 1
99681: PPUSH
99682: LD_VAR 0 5
99686: PPUSH
99687: CALL_OW 77
99691: ST_TO_ADDR
// end ;
99692: LD_VAR 0 3
99696: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99697: LD_INT 0
99699: PPUSH
99700: PPUSH
99701: PPUSH
// x := GetX ( building ) ;
99702: LD_ADDR_VAR 0 4
99706: PUSH
99707: LD_VAR 0 2
99711: PPUSH
99712: CALL_OW 250
99716: ST_TO_ADDR
// y := GetY ( building ) ;
99717: LD_ADDR_VAR 0 5
99721: PUSH
99722: LD_VAR 0 2
99726: PPUSH
99727: CALL_OW 251
99731: ST_TO_ADDR
// if GetTaskList ( unit ) then
99732: LD_VAR 0 1
99736: PPUSH
99737: CALL_OW 437
99741: IFFALSE 99836
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99743: LD_STRING e
99745: PUSH
99746: LD_VAR 0 1
99750: PPUSH
99751: CALL_OW 437
99755: PUSH
99756: LD_INT 1
99758: ARRAY
99759: PUSH
99760: LD_INT 1
99762: ARRAY
99763: EQUAL
99764: PUSH
99765: LD_VAR 0 4
99769: PUSH
99770: LD_VAR 0 1
99774: PPUSH
99775: CALL_OW 437
99779: PUSH
99780: LD_INT 1
99782: ARRAY
99783: PUSH
99784: LD_INT 2
99786: ARRAY
99787: EQUAL
99788: AND
99789: PUSH
99790: LD_VAR 0 5
99794: PUSH
99795: LD_VAR 0 1
99799: PPUSH
99800: CALL_OW 437
99804: PUSH
99805: LD_INT 1
99807: ARRAY
99808: PUSH
99809: LD_INT 3
99811: ARRAY
99812: EQUAL
99813: AND
99814: IFFALSE 99826
// result := true else
99816: LD_ADDR_VAR 0 3
99820: PUSH
99821: LD_INT 1
99823: ST_TO_ADDR
99824: GO 99834
// result := false ;
99826: LD_ADDR_VAR 0 3
99830: PUSH
99831: LD_INT 0
99833: ST_TO_ADDR
// end else
99834: GO 99844
// result := false ;
99836: LD_ADDR_VAR 0 3
99840: PUSH
99841: LD_INT 0
99843: ST_TO_ADDR
// end ;
99844: LD_VAR 0 3
99848: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99849: LD_INT 0
99851: PPUSH
99852: PPUSH
99853: PPUSH
99854: PPUSH
// if not unit or not area then
99855: LD_VAR 0 1
99859: NOT
99860: PUSH
99861: LD_VAR 0 2
99865: NOT
99866: OR
99867: IFFALSE 99871
// exit ;
99869: GO 100035
// tmp := AreaToList ( area , i ) ;
99871: LD_ADDR_VAR 0 6
99875: PUSH
99876: LD_VAR 0 2
99880: PPUSH
99881: LD_VAR 0 5
99885: PPUSH
99886: CALL_OW 517
99890: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99891: LD_ADDR_VAR 0 5
99895: PUSH
99896: DOUBLE
99897: LD_INT 1
99899: DEC
99900: ST_TO_ADDR
99901: LD_VAR 0 6
99905: PUSH
99906: LD_INT 1
99908: ARRAY
99909: PUSH
99910: FOR_TO
99911: IFFALSE 100033
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99913: LD_ADDR_VAR 0 7
99917: PUSH
99918: LD_VAR 0 6
99922: PUSH
99923: LD_INT 1
99925: ARRAY
99926: PUSH
99927: LD_VAR 0 5
99931: ARRAY
99932: PUSH
99933: LD_VAR 0 6
99937: PUSH
99938: LD_INT 2
99940: ARRAY
99941: PUSH
99942: LD_VAR 0 5
99946: ARRAY
99947: PUSH
99948: EMPTY
99949: LIST
99950: LIST
99951: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99952: LD_VAR 0 7
99956: PUSH
99957: LD_INT 1
99959: ARRAY
99960: PPUSH
99961: LD_VAR 0 7
99965: PUSH
99966: LD_INT 2
99968: ARRAY
99969: PPUSH
99970: CALL_OW 428
99974: PUSH
99975: LD_INT 0
99977: EQUAL
99978: IFFALSE 100031
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99980: LD_VAR 0 1
99984: PPUSH
99985: LD_VAR 0 7
99989: PUSH
99990: LD_INT 1
99992: ARRAY
99993: PPUSH
99994: LD_VAR 0 7
99998: PUSH
99999: LD_INT 2
100001: ARRAY
100002: PPUSH
100003: LD_VAR 0 3
100007: PPUSH
100008: CALL_OW 48
// result := IsPlaced ( unit ) ;
100012: LD_ADDR_VAR 0 4
100016: PUSH
100017: LD_VAR 0 1
100021: PPUSH
100022: CALL_OW 305
100026: ST_TO_ADDR
// exit ;
100027: POP
100028: POP
100029: GO 100035
// end ; end ;
100031: GO 99910
100033: POP
100034: POP
// end ;
100035: LD_VAR 0 4
100039: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100040: LD_INT 0
100042: PPUSH
100043: PPUSH
100044: PPUSH
// if not side or side > 8 then
100045: LD_VAR 0 1
100049: NOT
100050: PUSH
100051: LD_VAR 0 1
100055: PUSH
100056: LD_INT 8
100058: GREATER
100059: OR
100060: IFFALSE 100064
// exit ;
100062: GO 100251
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100064: LD_ADDR_VAR 0 4
100068: PUSH
100069: LD_INT 22
100071: PUSH
100072: LD_VAR 0 1
100076: PUSH
100077: EMPTY
100078: LIST
100079: LIST
100080: PUSH
100081: LD_INT 21
100083: PUSH
100084: LD_INT 3
100086: PUSH
100087: EMPTY
100088: LIST
100089: LIST
100090: PUSH
100091: EMPTY
100092: LIST
100093: LIST
100094: PPUSH
100095: CALL_OW 69
100099: ST_TO_ADDR
// if not tmp then
100100: LD_VAR 0 4
100104: NOT
100105: IFFALSE 100109
// exit ;
100107: GO 100251
// enable_addtolog := true ;
100109: LD_ADDR_OWVAR 81
100113: PUSH
100114: LD_INT 1
100116: ST_TO_ADDR
// AddToLog ( [ ) ;
100117: LD_STRING [
100119: PPUSH
100120: CALL_OW 561
// for i in tmp do
100124: LD_ADDR_VAR 0 3
100128: PUSH
100129: LD_VAR 0 4
100133: PUSH
100134: FOR_IN
100135: IFFALSE 100242
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100137: LD_STRING [
100139: PUSH
100140: LD_VAR 0 3
100144: PPUSH
100145: CALL_OW 266
100149: STR
100150: PUSH
100151: LD_STRING , 
100153: STR
100154: PUSH
100155: LD_VAR 0 3
100159: PPUSH
100160: CALL_OW 250
100164: STR
100165: PUSH
100166: LD_STRING , 
100168: STR
100169: PUSH
100170: LD_VAR 0 3
100174: PPUSH
100175: CALL_OW 251
100179: STR
100180: PUSH
100181: LD_STRING , 
100183: STR
100184: PUSH
100185: LD_VAR 0 3
100189: PPUSH
100190: CALL_OW 254
100194: STR
100195: PUSH
100196: LD_STRING , 
100198: STR
100199: PUSH
100200: LD_VAR 0 3
100204: PPUSH
100205: LD_INT 1
100207: PPUSH
100208: CALL_OW 268
100212: STR
100213: PUSH
100214: LD_STRING , 
100216: STR
100217: PUSH
100218: LD_VAR 0 3
100222: PPUSH
100223: LD_INT 2
100225: PPUSH
100226: CALL_OW 268
100230: STR
100231: PUSH
100232: LD_STRING ],
100234: STR
100235: PPUSH
100236: CALL_OW 561
// end ;
100240: GO 100134
100242: POP
100243: POP
// AddToLog ( ]; ) ;
100244: LD_STRING ];
100246: PPUSH
100247: CALL_OW 561
// end ;
100251: LD_VAR 0 2
100255: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100256: LD_INT 0
100258: PPUSH
100259: PPUSH
100260: PPUSH
100261: PPUSH
100262: PPUSH
// if not area or not rate or not max then
100263: LD_VAR 0 1
100267: NOT
100268: PUSH
100269: LD_VAR 0 2
100273: NOT
100274: OR
100275: PUSH
100276: LD_VAR 0 4
100280: NOT
100281: OR
100282: IFFALSE 100286
// exit ;
100284: GO 100478
// while 1 do
100286: LD_INT 1
100288: IFFALSE 100478
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100290: LD_ADDR_VAR 0 9
100294: PUSH
100295: LD_VAR 0 1
100299: PPUSH
100300: LD_INT 1
100302: PPUSH
100303: CALL_OW 287
100307: PUSH
100308: LD_INT 10
100310: MUL
100311: ST_TO_ADDR
// r := rate / 10 ;
100312: LD_ADDR_VAR 0 7
100316: PUSH
100317: LD_VAR 0 2
100321: PUSH
100322: LD_INT 10
100324: DIVREAL
100325: ST_TO_ADDR
// time := 1 1$00 ;
100326: LD_ADDR_VAR 0 8
100330: PUSH
100331: LD_INT 2100
100333: ST_TO_ADDR
// if amount < min then
100334: LD_VAR 0 9
100338: PUSH
100339: LD_VAR 0 3
100343: LESS
100344: IFFALSE 100362
// r := r * 2 else
100346: LD_ADDR_VAR 0 7
100350: PUSH
100351: LD_VAR 0 7
100355: PUSH
100356: LD_INT 2
100358: MUL
100359: ST_TO_ADDR
100360: GO 100388
// if amount > max then
100362: LD_VAR 0 9
100366: PUSH
100367: LD_VAR 0 4
100371: GREATER
100372: IFFALSE 100388
// r := r / 2 ;
100374: LD_ADDR_VAR 0 7
100378: PUSH
100379: LD_VAR 0 7
100383: PUSH
100384: LD_INT 2
100386: DIVREAL
100387: ST_TO_ADDR
// time := time / r ;
100388: LD_ADDR_VAR 0 8
100392: PUSH
100393: LD_VAR 0 8
100397: PUSH
100398: LD_VAR 0 7
100402: DIVREAL
100403: ST_TO_ADDR
// if time < 0 then
100404: LD_VAR 0 8
100408: PUSH
100409: LD_INT 0
100411: LESS
100412: IFFALSE 100429
// time := time * - 1 ;
100414: LD_ADDR_VAR 0 8
100418: PUSH
100419: LD_VAR 0 8
100423: PUSH
100424: LD_INT 1
100426: NEG
100427: MUL
100428: ST_TO_ADDR
// wait ( time ) ;
100429: LD_VAR 0 8
100433: PPUSH
100434: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100438: LD_INT 35
100440: PPUSH
100441: LD_INT 875
100443: PPUSH
100444: CALL_OW 12
100448: PPUSH
100449: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100453: LD_INT 1
100455: PPUSH
100456: LD_INT 5
100458: PPUSH
100459: CALL_OW 12
100463: PPUSH
100464: LD_VAR 0 1
100468: PPUSH
100469: LD_INT 1
100471: PPUSH
100472: CALL_OW 55
// end ;
100476: GO 100286
// end ;
100478: LD_VAR 0 5
100482: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100483: LD_INT 0
100485: PPUSH
100486: PPUSH
100487: PPUSH
100488: PPUSH
100489: PPUSH
100490: PPUSH
100491: PPUSH
100492: PPUSH
// if not turrets or not factories then
100493: LD_VAR 0 1
100497: NOT
100498: PUSH
100499: LD_VAR 0 2
100503: NOT
100504: OR
100505: IFFALSE 100509
// exit ;
100507: GO 100816
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100509: LD_ADDR_VAR 0 10
100513: PUSH
100514: LD_INT 5
100516: PUSH
100517: LD_INT 6
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: PUSH
100524: LD_INT 2
100526: PUSH
100527: LD_INT 4
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: PUSH
100534: LD_INT 3
100536: PUSH
100537: LD_INT 5
100539: PUSH
100540: EMPTY
100541: LIST
100542: LIST
100543: PUSH
100544: EMPTY
100545: LIST
100546: LIST
100547: LIST
100548: PUSH
100549: LD_INT 24
100551: PUSH
100552: LD_INT 25
100554: PUSH
100555: EMPTY
100556: LIST
100557: LIST
100558: PUSH
100559: LD_INT 23
100561: PUSH
100562: LD_INT 27
100564: PUSH
100565: EMPTY
100566: LIST
100567: LIST
100568: PUSH
100569: EMPTY
100570: LIST
100571: LIST
100572: PUSH
100573: LD_INT 42
100575: PUSH
100576: LD_INT 43
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PUSH
100583: LD_INT 44
100585: PUSH
100586: LD_INT 46
100588: PUSH
100589: EMPTY
100590: LIST
100591: LIST
100592: PUSH
100593: LD_INT 45
100595: PUSH
100596: LD_INT 47
100598: PUSH
100599: EMPTY
100600: LIST
100601: LIST
100602: PUSH
100603: EMPTY
100604: LIST
100605: LIST
100606: LIST
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: LIST
100612: ST_TO_ADDR
// result := [ ] ;
100613: LD_ADDR_VAR 0 3
100617: PUSH
100618: EMPTY
100619: ST_TO_ADDR
// for i in turrets do
100620: LD_ADDR_VAR 0 4
100624: PUSH
100625: LD_VAR 0 1
100629: PUSH
100630: FOR_IN
100631: IFFALSE 100814
// begin nat := GetNation ( i ) ;
100633: LD_ADDR_VAR 0 7
100637: PUSH
100638: LD_VAR 0 4
100642: PPUSH
100643: CALL_OW 248
100647: ST_TO_ADDR
// weapon := 0 ;
100648: LD_ADDR_VAR 0 8
100652: PUSH
100653: LD_INT 0
100655: ST_TO_ADDR
// if not nat then
100656: LD_VAR 0 7
100660: NOT
100661: IFFALSE 100665
// continue ;
100663: GO 100630
// for j in list [ nat ] do
100665: LD_ADDR_VAR 0 5
100669: PUSH
100670: LD_VAR 0 10
100674: PUSH
100675: LD_VAR 0 7
100679: ARRAY
100680: PUSH
100681: FOR_IN
100682: IFFALSE 100723
// if GetBWeapon ( i ) = j [ 1 ] then
100684: LD_VAR 0 4
100688: PPUSH
100689: CALL_OW 269
100693: PUSH
100694: LD_VAR 0 5
100698: PUSH
100699: LD_INT 1
100701: ARRAY
100702: EQUAL
100703: IFFALSE 100721
// begin weapon := j [ 2 ] ;
100705: LD_ADDR_VAR 0 8
100709: PUSH
100710: LD_VAR 0 5
100714: PUSH
100715: LD_INT 2
100717: ARRAY
100718: ST_TO_ADDR
// break ;
100719: GO 100723
// end ;
100721: GO 100681
100723: POP
100724: POP
// if not weapon then
100725: LD_VAR 0 8
100729: NOT
100730: IFFALSE 100734
// continue ;
100732: GO 100630
// for k in factories do
100734: LD_ADDR_VAR 0 6
100738: PUSH
100739: LD_VAR 0 2
100743: PUSH
100744: FOR_IN
100745: IFFALSE 100810
// begin weapons := AvailableWeaponList ( k ) ;
100747: LD_ADDR_VAR 0 9
100751: PUSH
100752: LD_VAR 0 6
100756: PPUSH
100757: CALL_OW 478
100761: ST_TO_ADDR
// if not weapons then
100762: LD_VAR 0 9
100766: NOT
100767: IFFALSE 100771
// continue ;
100769: GO 100744
// if weapon in weapons then
100771: LD_VAR 0 8
100775: PUSH
100776: LD_VAR 0 9
100780: IN
100781: IFFALSE 100808
// begin result := [ i , weapon ] ;
100783: LD_ADDR_VAR 0 3
100787: PUSH
100788: LD_VAR 0 4
100792: PUSH
100793: LD_VAR 0 8
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: ST_TO_ADDR
// exit ;
100802: POP
100803: POP
100804: POP
100805: POP
100806: GO 100816
// end ; end ;
100808: GO 100744
100810: POP
100811: POP
// end ;
100812: GO 100630
100814: POP
100815: POP
// end ;
100816: LD_VAR 0 3
100820: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100821: LD_INT 0
100823: PPUSH
// if not side or side > 8 then
100824: LD_VAR 0 3
100828: NOT
100829: PUSH
100830: LD_VAR 0 3
100834: PUSH
100835: LD_INT 8
100837: GREATER
100838: OR
100839: IFFALSE 100843
// exit ;
100841: GO 100902
// if not range then
100843: LD_VAR 0 4
100847: NOT
100848: IFFALSE 100859
// range := - 12 ;
100850: LD_ADDR_VAR 0 4
100854: PUSH
100855: LD_INT 12
100857: NEG
100858: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100859: LD_VAR 0 1
100863: PPUSH
100864: LD_VAR 0 2
100868: PPUSH
100869: LD_VAR 0 3
100873: PPUSH
100874: LD_VAR 0 4
100878: PPUSH
100879: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100883: LD_VAR 0 1
100887: PPUSH
100888: LD_VAR 0 2
100892: PPUSH
100893: LD_VAR 0 3
100897: PPUSH
100898: CALL_OW 331
// end ;
100902: LD_VAR 0 5
100906: RET
// export function Video ( mode ) ; begin
100907: LD_INT 0
100909: PPUSH
// ingame_video = mode ;
100910: LD_ADDR_OWVAR 52
100914: PUSH
100915: LD_VAR 0 1
100919: ST_TO_ADDR
// interface_hidden = mode ;
100920: LD_ADDR_OWVAR 54
100924: PUSH
100925: LD_VAR 0 1
100929: ST_TO_ADDR
// end ;
100930: LD_VAR 0 2
100934: RET
// export function Join ( array , element ) ; begin
100935: LD_INT 0
100937: PPUSH
// result := array ^ element ;
100938: LD_ADDR_VAR 0 3
100942: PUSH
100943: LD_VAR 0 1
100947: PUSH
100948: LD_VAR 0 2
100952: ADD
100953: ST_TO_ADDR
// end ;
100954: LD_VAR 0 3
100958: RET
// export function JoinUnion ( array , element ) ; begin
100959: LD_INT 0
100961: PPUSH
// result := array union element ;
100962: LD_ADDR_VAR 0 3
100966: PUSH
100967: LD_VAR 0 1
100971: PUSH
100972: LD_VAR 0 2
100976: UNION
100977: ST_TO_ADDR
// end ;
100978: LD_VAR 0 3
100982: RET
// export function GetBehemoths ( side ) ; begin
100983: LD_INT 0
100985: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
100986: LD_ADDR_VAR 0 2
100990: PUSH
100991: LD_INT 22
100993: PUSH
100994: LD_VAR 0 1
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: PUSH
101003: LD_INT 31
101005: PUSH
101006: LD_INT 25
101008: PUSH
101009: EMPTY
101010: LIST
101011: LIST
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: PPUSH
101017: CALL_OW 69
101021: ST_TO_ADDR
// end ;
101022: LD_VAR 0 2
101026: RET
// export function Shuffle ( array ) ; var i , index ; begin
101027: LD_INT 0
101029: PPUSH
101030: PPUSH
101031: PPUSH
// result := [ ] ;
101032: LD_ADDR_VAR 0 2
101036: PUSH
101037: EMPTY
101038: ST_TO_ADDR
// if not array then
101039: LD_VAR 0 1
101043: NOT
101044: IFFALSE 101048
// exit ;
101046: GO 101147
// Randomize ;
101048: CALL_OW 10
// for i = array downto 1 do
101052: LD_ADDR_VAR 0 3
101056: PUSH
101057: DOUBLE
101058: LD_VAR 0 1
101062: INC
101063: ST_TO_ADDR
101064: LD_INT 1
101066: PUSH
101067: FOR_DOWNTO
101068: IFFALSE 101145
// begin index := rand ( 1 , array ) ;
101070: LD_ADDR_VAR 0 4
101074: PUSH
101075: LD_INT 1
101077: PPUSH
101078: LD_VAR 0 1
101082: PPUSH
101083: CALL_OW 12
101087: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101088: LD_ADDR_VAR 0 2
101092: PUSH
101093: LD_VAR 0 2
101097: PPUSH
101098: LD_VAR 0 2
101102: PUSH
101103: LD_INT 1
101105: PLUS
101106: PPUSH
101107: LD_VAR 0 1
101111: PUSH
101112: LD_VAR 0 4
101116: ARRAY
101117: PPUSH
101118: CALL_OW 2
101122: ST_TO_ADDR
// array := Delete ( array , index ) ;
101123: LD_ADDR_VAR 0 1
101127: PUSH
101128: LD_VAR 0 1
101132: PPUSH
101133: LD_VAR 0 4
101137: PPUSH
101138: CALL_OW 3
101142: ST_TO_ADDR
// end ;
101143: GO 101067
101145: POP
101146: POP
// end ;
101147: LD_VAR 0 2
101151: RET
// export function GetBaseMaterials ( base ) ; begin
101152: LD_INT 0
101154: PPUSH
// result := [ 0 , 0 , 0 ] ;
101155: LD_ADDR_VAR 0 2
101159: PUSH
101160: LD_INT 0
101162: PUSH
101163: LD_INT 0
101165: PUSH
101166: LD_INT 0
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: LIST
101173: ST_TO_ADDR
// if not base then
101174: LD_VAR 0 1
101178: NOT
101179: IFFALSE 101183
// exit ;
101181: GO 101232
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101183: LD_ADDR_VAR 0 2
101187: PUSH
101188: LD_VAR 0 1
101192: PPUSH
101193: LD_INT 1
101195: PPUSH
101196: CALL_OW 275
101200: PUSH
101201: LD_VAR 0 1
101205: PPUSH
101206: LD_INT 2
101208: PPUSH
101209: CALL_OW 275
101213: PUSH
101214: LD_VAR 0 1
101218: PPUSH
101219: LD_INT 3
101221: PPUSH
101222: CALL_OW 275
101226: PUSH
101227: EMPTY
101228: LIST
101229: LIST
101230: LIST
101231: ST_TO_ADDR
// end ;
101232: LD_VAR 0 2
101236: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101237: LD_INT 0
101239: PPUSH
101240: PPUSH
// result := array ;
101241: LD_ADDR_VAR 0 3
101245: PUSH
101246: LD_VAR 0 1
101250: ST_TO_ADDR
// if size > 0 then
101251: LD_VAR 0 2
101255: PUSH
101256: LD_INT 0
101258: GREATER
101259: IFFALSE 101305
// for i := array downto size do
101261: LD_ADDR_VAR 0 4
101265: PUSH
101266: DOUBLE
101267: LD_VAR 0 1
101271: INC
101272: ST_TO_ADDR
101273: LD_VAR 0 2
101277: PUSH
101278: FOR_DOWNTO
101279: IFFALSE 101303
// result := Delete ( result , result ) ;
101281: LD_ADDR_VAR 0 3
101285: PUSH
101286: LD_VAR 0 3
101290: PPUSH
101291: LD_VAR 0 3
101295: PPUSH
101296: CALL_OW 3
101300: ST_TO_ADDR
101301: GO 101278
101303: POP
101304: POP
// end ; end_of_file end_of_file
101305: LD_VAR 0 3
101309: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
101310: GO 101312
101312: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
101313: LD_STRING initStreamRollete();
101315: PPUSH
101316: CALL_OW 559
// InitStreamMode ;
101320: CALL 101329 0 0
// DefineStreamItems ( ) ;
101324: CALL 101769 0 0
// end ;
101328: END
// function InitStreamMode ; begin
101329: LD_INT 0
101331: PPUSH
// streamModeActive := false ;
101332: LD_ADDR_EXP 153
101336: PUSH
101337: LD_INT 0
101339: ST_TO_ADDR
// normalCounter := 36 ;
101340: LD_ADDR_EXP 154
101344: PUSH
101345: LD_INT 36
101347: ST_TO_ADDR
// hardcoreCounter := 16 ;
101348: LD_ADDR_EXP 155
101352: PUSH
101353: LD_INT 16
101355: ST_TO_ADDR
// sRocket := false ;
101356: LD_ADDR_EXP 158
101360: PUSH
101361: LD_INT 0
101363: ST_TO_ADDR
// sSpeed := false ;
101364: LD_ADDR_EXP 157
101368: PUSH
101369: LD_INT 0
101371: ST_TO_ADDR
// sEngine := false ;
101372: LD_ADDR_EXP 159
101376: PUSH
101377: LD_INT 0
101379: ST_TO_ADDR
// sSpec := false ;
101380: LD_ADDR_EXP 156
101384: PUSH
101385: LD_INT 0
101387: ST_TO_ADDR
// sLevel := false ;
101388: LD_ADDR_EXP 160
101392: PUSH
101393: LD_INT 0
101395: ST_TO_ADDR
// sArmoury := false ;
101396: LD_ADDR_EXP 161
101400: PUSH
101401: LD_INT 0
101403: ST_TO_ADDR
// sRadar := false ;
101404: LD_ADDR_EXP 162
101408: PUSH
101409: LD_INT 0
101411: ST_TO_ADDR
// sBunker := false ;
101412: LD_ADDR_EXP 163
101416: PUSH
101417: LD_INT 0
101419: ST_TO_ADDR
// sHack := false ;
101420: LD_ADDR_EXP 164
101424: PUSH
101425: LD_INT 0
101427: ST_TO_ADDR
// sFire := false ;
101428: LD_ADDR_EXP 165
101432: PUSH
101433: LD_INT 0
101435: ST_TO_ADDR
// sRefresh := false ;
101436: LD_ADDR_EXP 166
101440: PUSH
101441: LD_INT 0
101443: ST_TO_ADDR
// sExp := false ;
101444: LD_ADDR_EXP 167
101448: PUSH
101449: LD_INT 0
101451: ST_TO_ADDR
// sDepot := false ;
101452: LD_ADDR_EXP 168
101456: PUSH
101457: LD_INT 0
101459: ST_TO_ADDR
// sFlag := false ;
101460: LD_ADDR_EXP 169
101464: PUSH
101465: LD_INT 0
101467: ST_TO_ADDR
// sKamikadze := false ;
101468: LD_ADDR_EXP 177
101472: PUSH
101473: LD_INT 0
101475: ST_TO_ADDR
// sTroll := false ;
101476: LD_ADDR_EXP 178
101480: PUSH
101481: LD_INT 0
101483: ST_TO_ADDR
// sSlow := false ;
101484: LD_ADDR_EXP 179
101488: PUSH
101489: LD_INT 0
101491: ST_TO_ADDR
// sLack := false ;
101492: LD_ADDR_EXP 180
101496: PUSH
101497: LD_INT 0
101499: ST_TO_ADDR
// sTank := false ;
101500: LD_ADDR_EXP 182
101504: PUSH
101505: LD_INT 0
101507: ST_TO_ADDR
// sRemote := false ;
101508: LD_ADDR_EXP 183
101512: PUSH
101513: LD_INT 0
101515: ST_TO_ADDR
// sPowell := false ;
101516: LD_ADDR_EXP 184
101520: PUSH
101521: LD_INT 0
101523: ST_TO_ADDR
// sTeleport := false ;
101524: LD_ADDR_EXP 187
101528: PUSH
101529: LD_INT 0
101531: ST_TO_ADDR
// sOilTower := false ;
101532: LD_ADDR_EXP 189
101536: PUSH
101537: LD_INT 0
101539: ST_TO_ADDR
// sShovel := false ;
101540: LD_ADDR_EXP 190
101544: PUSH
101545: LD_INT 0
101547: ST_TO_ADDR
// sSheik := false ;
101548: LD_ADDR_EXP 191
101552: PUSH
101553: LD_INT 0
101555: ST_TO_ADDR
// sEarthquake := false ;
101556: LD_ADDR_EXP 193
101560: PUSH
101561: LD_INT 0
101563: ST_TO_ADDR
// sAI := false ;
101564: LD_ADDR_EXP 194
101568: PUSH
101569: LD_INT 0
101571: ST_TO_ADDR
// sCargo := false ;
101572: LD_ADDR_EXP 197
101576: PUSH
101577: LD_INT 0
101579: ST_TO_ADDR
// sDLaser := false ;
101580: LD_ADDR_EXP 198
101584: PUSH
101585: LD_INT 0
101587: ST_TO_ADDR
// sExchange := false ;
101588: LD_ADDR_EXP 199
101592: PUSH
101593: LD_INT 0
101595: ST_TO_ADDR
// sFac := false ;
101596: LD_ADDR_EXP 200
101600: PUSH
101601: LD_INT 0
101603: ST_TO_ADDR
// sPower := false ;
101604: LD_ADDR_EXP 201
101608: PUSH
101609: LD_INT 0
101611: ST_TO_ADDR
// sRandom := false ;
101612: LD_ADDR_EXP 202
101616: PUSH
101617: LD_INT 0
101619: ST_TO_ADDR
// sShield := false ;
101620: LD_ADDR_EXP 203
101624: PUSH
101625: LD_INT 0
101627: ST_TO_ADDR
// sTime := false ;
101628: LD_ADDR_EXP 204
101632: PUSH
101633: LD_INT 0
101635: ST_TO_ADDR
// sTools := false ;
101636: LD_ADDR_EXP 205
101640: PUSH
101641: LD_INT 0
101643: ST_TO_ADDR
// sSold := false ;
101644: LD_ADDR_EXP 170
101648: PUSH
101649: LD_INT 0
101651: ST_TO_ADDR
// sDiff := false ;
101652: LD_ADDR_EXP 171
101656: PUSH
101657: LD_INT 0
101659: ST_TO_ADDR
// sFog := false ;
101660: LD_ADDR_EXP 174
101664: PUSH
101665: LD_INT 0
101667: ST_TO_ADDR
// sReset := false ;
101668: LD_ADDR_EXP 175
101672: PUSH
101673: LD_INT 0
101675: ST_TO_ADDR
// sSun := false ;
101676: LD_ADDR_EXP 176
101680: PUSH
101681: LD_INT 0
101683: ST_TO_ADDR
// sTiger := false ;
101684: LD_ADDR_EXP 172
101688: PUSH
101689: LD_INT 0
101691: ST_TO_ADDR
// sBomb := false ;
101692: LD_ADDR_EXP 173
101696: PUSH
101697: LD_INT 0
101699: ST_TO_ADDR
// sWound := false ;
101700: LD_ADDR_EXP 181
101704: PUSH
101705: LD_INT 0
101707: ST_TO_ADDR
// sBetray := false ;
101708: LD_ADDR_EXP 185
101712: PUSH
101713: LD_INT 0
101715: ST_TO_ADDR
// sContamin := false ;
101716: LD_ADDR_EXP 186
101720: PUSH
101721: LD_INT 0
101723: ST_TO_ADDR
// sOil := false ;
101724: LD_ADDR_EXP 188
101728: PUSH
101729: LD_INT 0
101731: ST_TO_ADDR
// sStu := false ;
101732: LD_ADDR_EXP 192
101736: PUSH
101737: LD_INT 0
101739: ST_TO_ADDR
// sBazooka := false ;
101740: LD_ADDR_EXP 195
101744: PUSH
101745: LD_INT 0
101747: ST_TO_ADDR
// sMortar := false ;
101748: LD_ADDR_EXP 196
101752: PUSH
101753: LD_INT 0
101755: ST_TO_ADDR
// sRanger := false ;
101756: LD_ADDR_EXP 206
101760: PUSH
101761: LD_INT 0
101763: ST_TO_ADDR
// end ;
101764: LD_VAR 0 1
101768: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
101769: LD_INT 0
101771: PPUSH
101772: PPUSH
101773: PPUSH
101774: PPUSH
101775: PPUSH
// result := [ ] ;
101776: LD_ADDR_VAR 0 1
101780: PUSH
101781: EMPTY
101782: ST_TO_ADDR
// if campaign_id = 1 then
101783: LD_OWVAR 69
101787: PUSH
101788: LD_INT 1
101790: EQUAL
101791: IFFALSE 104729
// begin case mission_number of 1 :
101793: LD_OWVAR 70
101797: PUSH
101798: LD_INT 1
101800: DOUBLE
101801: EQUAL
101802: IFTRUE 101806
101804: GO 101870
101806: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
101807: LD_ADDR_VAR 0 1
101811: PUSH
101812: LD_INT 2
101814: PUSH
101815: LD_INT 4
101817: PUSH
101818: LD_INT 11
101820: PUSH
101821: LD_INT 12
101823: PUSH
101824: LD_INT 15
101826: PUSH
101827: LD_INT 16
101829: PUSH
101830: LD_INT 22
101832: PUSH
101833: LD_INT 23
101835: PUSH
101836: LD_INT 26
101838: PUSH
101839: EMPTY
101840: LIST
101841: LIST
101842: LIST
101843: LIST
101844: LIST
101845: LIST
101846: LIST
101847: LIST
101848: LIST
101849: PUSH
101850: LD_INT 101
101852: PUSH
101853: LD_INT 102
101855: PUSH
101856: LD_INT 106
101858: PUSH
101859: EMPTY
101860: LIST
101861: LIST
101862: LIST
101863: PUSH
101864: EMPTY
101865: LIST
101866: LIST
101867: ST_TO_ADDR
101868: GO 104727
101870: LD_INT 2
101872: DOUBLE
101873: EQUAL
101874: IFTRUE 101878
101876: GO 101950
101878: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
101879: LD_ADDR_VAR 0 1
101883: PUSH
101884: LD_INT 2
101886: PUSH
101887: LD_INT 4
101889: PUSH
101890: LD_INT 11
101892: PUSH
101893: LD_INT 12
101895: PUSH
101896: LD_INT 15
101898: PUSH
101899: LD_INT 16
101901: PUSH
101902: LD_INT 22
101904: PUSH
101905: LD_INT 23
101907: PUSH
101908: LD_INT 26
101910: PUSH
101911: EMPTY
101912: LIST
101913: LIST
101914: LIST
101915: LIST
101916: LIST
101917: LIST
101918: LIST
101919: LIST
101920: LIST
101921: PUSH
101922: LD_INT 101
101924: PUSH
101925: LD_INT 102
101927: PUSH
101928: LD_INT 105
101930: PUSH
101931: LD_INT 106
101933: PUSH
101934: LD_INT 108
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: LIST
101941: LIST
101942: LIST
101943: PUSH
101944: EMPTY
101945: LIST
101946: LIST
101947: ST_TO_ADDR
101948: GO 104727
101950: LD_INT 3
101952: DOUBLE
101953: EQUAL
101954: IFTRUE 101958
101956: GO 102034
101958: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
101959: LD_ADDR_VAR 0 1
101963: PUSH
101964: LD_INT 2
101966: PUSH
101967: LD_INT 4
101969: PUSH
101970: LD_INT 5
101972: PUSH
101973: LD_INT 11
101975: PUSH
101976: LD_INT 12
101978: PUSH
101979: LD_INT 15
101981: PUSH
101982: LD_INT 16
101984: PUSH
101985: LD_INT 22
101987: PUSH
101988: LD_INT 26
101990: PUSH
101991: LD_INT 36
101993: PUSH
101994: EMPTY
101995: LIST
101996: LIST
101997: LIST
101998: LIST
101999: LIST
102000: LIST
102001: LIST
102002: LIST
102003: LIST
102004: LIST
102005: PUSH
102006: LD_INT 101
102008: PUSH
102009: LD_INT 102
102011: PUSH
102012: LD_INT 105
102014: PUSH
102015: LD_INT 106
102017: PUSH
102018: LD_INT 108
102020: PUSH
102021: EMPTY
102022: LIST
102023: LIST
102024: LIST
102025: LIST
102026: LIST
102027: PUSH
102028: EMPTY
102029: LIST
102030: LIST
102031: ST_TO_ADDR
102032: GO 104727
102034: LD_INT 4
102036: DOUBLE
102037: EQUAL
102038: IFTRUE 102042
102040: GO 102126
102042: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
102043: LD_ADDR_VAR 0 1
102047: PUSH
102048: LD_INT 2
102050: PUSH
102051: LD_INT 4
102053: PUSH
102054: LD_INT 5
102056: PUSH
102057: LD_INT 8
102059: PUSH
102060: LD_INT 11
102062: PUSH
102063: LD_INT 12
102065: PUSH
102066: LD_INT 15
102068: PUSH
102069: LD_INT 16
102071: PUSH
102072: LD_INT 22
102074: PUSH
102075: LD_INT 23
102077: PUSH
102078: LD_INT 26
102080: PUSH
102081: LD_INT 36
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: LIST
102088: LIST
102089: LIST
102090: LIST
102091: LIST
102092: LIST
102093: LIST
102094: LIST
102095: LIST
102096: LIST
102097: PUSH
102098: LD_INT 101
102100: PUSH
102101: LD_INT 102
102103: PUSH
102104: LD_INT 105
102106: PUSH
102107: LD_INT 106
102109: PUSH
102110: LD_INT 108
102112: PUSH
102113: EMPTY
102114: LIST
102115: LIST
102116: LIST
102117: LIST
102118: LIST
102119: PUSH
102120: EMPTY
102121: LIST
102122: LIST
102123: ST_TO_ADDR
102124: GO 104727
102126: LD_INT 5
102128: DOUBLE
102129: EQUAL
102130: IFTRUE 102134
102132: GO 102234
102134: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
102135: LD_ADDR_VAR 0 1
102139: PUSH
102140: LD_INT 2
102142: PUSH
102143: LD_INT 4
102145: PUSH
102146: LD_INT 5
102148: PUSH
102149: LD_INT 6
102151: PUSH
102152: LD_INT 8
102154: PUSH
102155: LD_INT 11
102157: PUSH
102158: LD_INT 12
102160: PUSH
102161: LD_INT 15
102163: PUSH
102164: LD_INT 16
102166: PUSH
102167: LD_INT 22
102169: PUSH
102170: LD_INT 23
102172: PUSH
102173: LD_INT 25
102175: PUSH
102176: LD_INT 26
102178: PUSH
102179: LD_INT 36
102181: PUSH
102182: EMPTY
102183: LIST
102184: LIST
102185: LIST
102186: LIST
102187: LIST
102188: LIST
102189: LIST
102190: LIST
102191: LIST
102192: LIST
102193: LIST
102194: LIST
102195: LIST
102196: LIST
102197: PUSH
102198: LD_INT 101
102200: PUSH
102201: LD_INT 102
102203: PUSH
102204: LD_INT 105
102206: PUSH
102207: LD_INT 106
102209: PUSH
102210: LD_INT 108
102212: PUSH
102213: LD_INT 109
102215: PUSH
102216: LD_INT 112
102218: PUSH
102219: EMPTY
102220: LIST
102221: LIST
102222: LIST
102223: LIST
102224: LIST
102225: LIST
102226: LIST
102227: PUSH
102228: EMPTY
102229: LIST
102230: LIST
102231: ST_TO_ADDR
102232: GO 104727
102234: LD_INT 6
102236: DOUBLE
102237: EQUAL
102238: IFTRUE 102242
102240: GO 102362
102242: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
102243: LD_ADDR_VAR 0 1
102247: PUSH
102248: LD_INT 2
102250: PUSH
102251: LD_INT 4
102253: PUSH
102254: LD_INT 5
102256: PUSH
102257: LD_INT 6
102259: PUSH
102260: LD_INT 8
102262: PUSH
102263: LD_INT 11
102265: PUSH
102266: LD_INT 12
102268: PUSH
102269: LD_INT 15
102271: PUSH
102272: LD_INT 16
102274: PUSH
102275: LD_INT 20
102277: PUSH
102278: LD_INT 21
102280: PUSH
102281: LD_INT 22
102283: PUSH
102284: LD_INT 23
102286: PUSH
102287: LD_INT 25
102289: PUSH
102290: LD_INT 26
102292: PUSH
102293: LD_INT 30
102295: PUSH
102296: LD_INT 31
102298: PUSH
102299: LD_INT 32
102301: PUSH
102302: LD_INT 36
102304: PUSH
102305: EMPTY
102306: LIST
102307: LIST
102308: LIST
102309: LIST
102310: LIST
102311: LIST
102312: LIST
102313: LIST
102314: LIST
102315: LIST
102316: LIST
102317: LIST
102318: LIST
102319: LIST
102320: LIST
102321: LIST
102322: LIST
102323: LIST
102324: LIST
102325: PUSH
102326: LD_INT 101
102328: PUSH
102329: LD_INT 102
102331: PUSH
102332: LD_INT 105
102334: PUSH
102335: LD_INT 106
102337: PUSH
102338: LD_INT 108
102340: PUSH
102341: LD_INT 109
102343: PUSH
102344: LD_INT 112
102346: PUSH
102347: EMPTY
102348: LIST
102349: LIST
102350: LIST
102351: LIST
102352: LIST
102353: LIST
102354: LIST
102355: PUSH
102356: EMPTY
102357: LIST
102358: LIST
102359: ST_TO_ADDR
102360: GO 104727
102362: LD_INT 7
102364: DOUBLE
102365: EQUAL
102366: IFTRUE 102370
102368: GO 102470
102370: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
102371: LD_ADDR_VAR 0 1
102375: PUSH
102376: LD_INT 2
102378: PUSH
102379: LD_INT 4
102381: PUSH
102382: LD_INT 5
102384: PUSH
102385: LD_INT 7
102387: PUSH
102388: LD_INT 11
102390: PUSH
102391: LD_INT 12
102393: PUSH
102394: LD_INT 15
102396: PUSH
102397: LD_INT 16
102399: PUSH
102400: LD_INT 20
102402: PUSH
102403: LD_INT 21
102405: PUSH
102406: LD_INT 22
102408: PUSH
102409: LD_INT 23
102411: PUSH
102412: LD_INT 25
102414: PUSH
102415: LD_INT 26
102417: PUSH
102418: EMPTY
102419: LIST
102420: LIST
102421: LIST
102422: LIST
102423: LIST
102424: LIST
102425: LIST
102426: LIST
102427: LIST
102428: LIST
102429: LIST
102430: LIST
102431: LIST
102432: LIST
102433: PUSH
102434: LD_INT 101
102436: PUSH
102437: LD_INT 102
102439: PUSH
102440: LD_INT 103
102442: PUSH
102443: LD_INT 105
102445: PUSH
102446: LD_INT 106
102448: PUSH
102449: LD_INT 108
102451: PUSH
102452: LD_INT 112
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: LIST
102459: LIST
102460: LIST
102461: LIST
102462: LIST
102463: PUSH
102464: EMPTY
102465: LIST
102466: LIST
102467: ST_TO_ADDR
102468: GO 104727
102470: LD_INT 8
102472: DOUBLE
102473: EQUAL
102474: IFTRUE 102478
102476: GO 102606
102478: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
102479: LD_ADDR_VAR 0 1
102483: PUSH
102484: LD_INT 2
102486: PUSH
102487: LD_INT 4
102489: PUSH
102490: LD_INT 5
102492: PUSH
102493: LD_INT 6
102495: PUSH
102496: LD_INT 7
102498: PUSH
102499: LD_INT 8
102501: PUSH
102502: LD_INT 11
102504: PUSH
102505: LD_INT 12
102507: PUSH
102508: LD_INT 15
102510: PUSH
102511: LD_INT 16
102513: PUSH
102514: LD_INT 20
102516: PUSH
102517: LD_INT 21
102519: PUSH
102520: LD_INT 22
102522: PUSH
102523: LD_INT 23
102525: PUSH
102526: LD_INT 25
102528: PUSH
102529: LD_INT 26
102531: PUSH
102532: LD_INT 30
102534: PUSH
102535: LD_INT 31
102537: PUSH
102538: LD_INT 32
102540: PUSH
102541: LD_INT 36
102543: PUSH
102544: EMPTY
102545: LIST
102546: LIST
102547: LIST
102548: LIST
102549: LIST
102550: LIST
102551: LIST
102552: LIST
102553: LIST
102554: LIST
102555: LIST
102556: LIST
102557: LIST
102558: LIST
102559: LIST
102560: LIST
102561: LIST
102562: LIST
102563: LIST
102564: LIST
102565: PUSH
102566: LD_INT 101
102568: PUSH
102569: LD_INT 102
102571: PUSH
102572: LD_INT 103
102574: PUSH
102575: LD_INT 105
102577: PUSH
102578: LD_INT 106
102580: PUSH
102581: LD_INT 108
102583: PUSH
102584: LD_INT 109
102586: PUSH
102587: LD_INT 112
102589: PUSH
102590: EMPTY
102591: LIST
102592: LIST
102593: LIST
102594: LIST
102595: LIST
102596: LIST
102597: LIST
102598: LIST
102599: PUSH
102600: EMPTY
102601: LIST
102602: LIST
102603: ST_TO_ADDR
102604: GO 104727
102606: LD_INT 9
102608: DOUBLE
102609: EQUAL
102610: IFTRUE 102614
102612: GO 102750
102614: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
102615: LD_ADDR_VAR 0 1
102619: PUSH
102620: LD_INT 2
102622: PUSH
102623: LD_INT 4
102625: PUSH
102626: LD_INT 5
102628: PUSH
102629: LD_INT 6
102631: PUSH
102632: LD_INT 7
102634: PUSH
102635: LD_INT 8
102637: PUSH
102638: LD_INT 11
102640: PUSH
102641: LD_INT 12
102643: PUSH
102644: LD_INT 15
102646: PUSH
102647: LD_INT 16
102649: PUSH
102650: LD_INT 20
102652: PUSH
102653: LD_INT 21
102655: PUSH
102656: LD_INT 22
102658: PUSH
102659: LD_INT 23
102661: PUSH
102662: LD_INT 25
102664: PUSH
102665: LD_INT 26
102667: PUSH
102668: LD_INT 28
102670: PUSH
102671: LD_INT 30
102673: PUSH
102674: LD_INT 31
102676: PUSH
102677: LD_INT 32
102679: PUSH
102680: LD_INT 36
102682: PUSH
102683: EMPTY
102684: LIST
102685: LIST
102686: LIST
102687: LIST
102688: LIST
102689: LIST
102690: LIST
102691: LIST
102692: LIST
102693: LIST
102694: LIST
102695: LIST
102696: LIST
102697: LIST
102698: LIST
102699: LIST
102700: LIST
102701: LIST
102702: LIST
102703: LIST
102704: LIST
102705: PUSH
102706: LD_INT 101
102708: PUSH
102709: LD_INT 102
102711: PUSH
102712: LD_INT 103
102714: PUSH
102715: LD_INT 105
102717: PUSH
102718: LD_INT 106
102720: PUSH
102721: LD_INT 108
102723: PUSH
102724: LD_INT 109
102726: PUSH
102727: LD_INT 112
102729: PUSH
102730: LD_INT 114
102732: PUSH
102733: EMPTY
102734: LIST
102735: LIST
102736: LIST
102737: LIST
102738: LIST
102739: LIST
102740: LIST
102741: LIST
102742: LIST
102743: PUSH
102744: EMPTY
102745: LIST
102746: LIST
102747: ST_TO_ADDR
102748: GO 104727
102750: LD_INT 10
102752: DOUBLE
102753: EQUAL
102754: IFTRUE 102758
102756: GO 102942
102758: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
102759: LD_ADDR_VAR 0 1
102763: PUSH
102764: LD_INT 2
102766: PUSH
102767: LD_INT 4
102769: PUSH
102770: LD_INT 5
102772: PUSH
102773: LD_INT 6
102775: PUSH
102776: LD_INT 7
102778: PUSH
102779: LD_INT 8
102781: PUSH
102782: LD_INT 9
102784: PUSH
102785: LD_INT 10
102787: PUSH
102788: LD_INT 11
102790: PUSH
102791: LD_INT 12
102793: PUSH
102794: LD_INT 13
102796: PUSH
102797: LD_INT 14
102799: PUSH
102800: LD_INT 15
102802: PUSH
102803: LD_INT 16
102805: PUSH
102806: LD_INT 17
102808: PUSH
102809: LD_INT 18
102811: PUSH
102812: LD_INT 19
102814: PUSH
102815: LD_INT 20
102817: PUSH
102818: LD_INT 21
102820: PUSH
102821: LD_INT 22
102823: PUSH
102824: LD_INT 23
102826: PUSH
102827: LD_INT 24
102829: PUSH
102830: LD_INT 25
102832: PUSH
102833: LD_INT 26
102835: PUSH
102836: LD_INT 28
102838: PUSH
102839: LD_INT 30
102841: PUSH
102842: LD_INT 31
102844: PUSH
102845: LD_INT 32
102847: PUSH
102848: LD_INT 36
102850: PUSH
102851: EMPTY
102852: LIST
102853: LIST
102854: LIST
102855: LIST
102856: LIST
102857: LIST
102858: LIST
102859: LIST
102860: LIST
102861: LIST
102862: LIST
102863: LIST
102864: LIST
102865: LIST
102866: LIST
102867: LIST
102868: LIST
102869: LIST
102870: LIST
102871: LIST
102872: LIST
102873: LIST
102874: LIST
102875: LIST
102876: LIST
102877: LIST
102878: LIST
102879: LIST
102880: LIST
102881: PUSH
102882: LD_INT 101
102884: PUSH
102885: LD_INT 102
102887: PUSH
102888: LD_INT 103
102890: PUSH
102891: LD_INT 104
102893: PUSH
102894: LD_INT 105
102896: PUSH
102897: LD_INT 106
102899: PUSH
102900: LD_INT 107
102902: PUSH
102903: LD_INT 108
102905: PUSH
102906: LD_INT 109
102908: PUSH
102909: LD_INT 110
102911: PUSH
102912: LD_INT 111
102914: PUSH
102915: LD_INT 112
102917: PUSH
102918: LD_INT 114
102920: PUSH
102921: EMPTY
102922: LIST
102923: LIST
102924: LIST
102925: LIST
102926: LIST
102927: LIST
102928: LIST
102929: LIST
102930: LIST
102931: LIST
102932: LIST
102933: LIST
102934: LIST
102935: PUSH
102936: EMPTY
102937: LIST
102938: LIST
102939: ST_TO_ADDR
102940: GO 104727
102942: LD_INT 11
102944: DOUBLE
102945: EQUAL
102946: IFTRUE 102950
102948: GO 103142
102950: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
102951: LD_ADDR_VAR 0 1
102955: PUSH
102956: LD_INT 2
102958: PUSH
102959: LD_INT 3
102961: PUSH
102962: LD_INT 4
102964: PUSH
102965: LD_INT 5
102967: PUSH
102968: LD_INT 6
102970: PUSH
102971: LD_INT 7
102973: PUSH
102974: LD_INT 8
102976: PUSH
102977: LD_INT 9
102979: PUSH
102980: LD_INT 10
102982: PUSH
102983: LD_INT 11
102985: PUSH
102986: LD_INT 12
102988: PUSH
102989: LD_INT 13
102991: PUSH
102992: LD_INT 14
102994: PUSH
102995: LD_INT 15
102997: PUSH
102998: LD_INT 16
103000: PUSH
103001: LD_INT 17
103003: PUSH
103004: LD_INT 18
103006: PUSH
103007: LD_INT 19
103009: PUSH
103010: LD_INT 20
103012: PUSH
103013: LD_INT 21
103015: PUSH
103016: LD_INT 22
103018: PUSH
103019: LD_INT 23
103021: PUSH
103022: LD_INT 24
103024: PUSH
103025: LD_INT 25
103027: PUSH
103028: LD_INT 26
103030: PUSH
103031: LD_INT 28
103033: PUSH
103034: LD_INT 30
103036: PUSH
103037: LD_INT 31
103039: PUSH
103040: LD_INT 32
103042: PUSH
103043: LD_INT 34
103045: PUSH
103046: LD_INT 36
103048: PUSH
103049: EMPTY
103050: LIST
103051: LIST
103052: LIST
103053: LIST
103054: LIST
103055: LIST
103056: LIST
103057: LIST
103058: LIST
103059: LIST
103060: LIST
103061: LIST
103062: LIST
103063: LIST
103064: LIST
103065: LIST
103066: LIST
103067: LIST
103068: LIST
103069: LIST
103070: LIST
103071: LIST
103072: LIST
103073: LIST
103074: LIST
103075: LIST
103076: LIST
103077: LIST
103078: LIST
103079: LIST
103080: LIST
103081: PUSH
103082: LD_INT 101
103084: PUSH
103085: LD_INT 102
103087: PUSH
103088: LD_INT 103
103090: PUSH
103091: LD_INT 104
103093: PUSH
103094: LD_INT 105
103096: PUSH
103097: LD_INT 106
103099: PUSH
103100: LD_INT 107
103102: PUSH
103103: LD_INT 108
103105: PUSH
103106: LD_INT 109
103108: PUSH
103109: LD_INT 110
103111: PUSH
103112: LD_INT 111
103114: PUSH
103115: LD_INT 112
103117: PUSH
103118: LD_INT 114
103120: PUSH
103121: EMPTY
103122: LIST
103123: LIST
103124: LIST
103125: LIST
103126: LIST
103127: LIST
103128: LIST
103129: LIST
103130: LIST
103131: LIST
103132: LIST
103133: LIST
103134: LIST
103135: PUSH
103136: EMPTY
103137: LIST
103138: LIST
103139: ST_TO_ADDR
103140: GO 104727
103142: LD_INT 12
103144: DOUBLE
103145: EQUAL
103146: IFTRUE 103150
103148: GO 103358
103150: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
103151: LD_ADDR_VAR 0 1
103155: PUSH
103156: LD_INT 1
103158: PUSH
103159: LD_INT 2
103161: PUSH
103162: LD_INT 3
103164: PUSH
103165: LD_INT 4
103167: PUSH
103168: LD_INT 5
103170: PUSH
103171: LD_INT 6
103173: PUSH
103174: LD_INT 7
103176: PUSH
103177: LD_INT 8
103179: PUSH
103180: LD_INT 9
103182: PUSH
103183: LD_INT 10
103185: PUSH
103186: LD_INT 11
103188: PUSH
103189: LD_INT 12
103191: PUSH
103192: LD_INT 13
103194: PUSH
103195: LD_INT 14
103197: PUSH
103198: LD_INT 15
103200: PUSH
103201: LD_INT 16
103203: PUSH
103204: LD_INT 17
103206: PUSH
103207: LD_INT 18
103209: PUSH
103210: LD_INT 19
103212: PUSH
103213: LD_INT 20
103215: PUSH
103216: LD_INT 21
103218: PUSH
103219: LD_INT 22
103221: PUSH
103222: LD_INT 23
103224: PUSH
103225: LD_INT 24
103227: PUSH
103228: LD_INT 25
103230: PUSH
103231: LD_INT 26
103233: PUSH
103234: LD_INT 27
103236: PUSH
103237: LD_INT 28
103239: PUSH
103240: LD_INT 30
103242: PUSH
103243: LD_INT 31
103245: PUSH
103246: LD_INT 32
103248: PUSH
103249: LD_INT 33
103251: PUSH
103252: LD_INT 34
103254: PUSH
103255: LD_INT 36
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: LIST
103262: LIST
103263: LIST
103264: LIST
103265: LIST
103266: LIST
103267: LIST
103268: LIST
103269: LIST
103270: LIST
103271: LIST
103272: LIST
103273: LIST
103274: LIST
103275: LIST
103276: LIST
103277: LIST
103278: LIST
103279: LIST
103280: LIST
103281: LIST
103282: LIST
103283: LIST
103284: LIST
103285: LIST
103286: LIST
103287: LIST
103288: LIST
103289: LIST
103290: LIST
103291: LIST
103292: LIST
103293: PUSH
103294: LD_INT 101
103296: PUSH
103297: LD_INT 102
103299: PUSH
103300: LD_INT 103
103302: PUSH
103303: LD_INT 104
103305: PUSH
103306: LD_INT 105
103308: PUSH
103309: LD_INT 106
103311: PUSH
103312: LD_INT 107
103314: PUSH
103315: LD_INT 108
103317: PUSH
103318: LD_INT 109
103320: PUSH
103321: LD_INT 110
103323: PUSH
103324: LD_INT 111
103326: PUSH
103327: LD_INT 112
103329: PUSH
103330: LD_INT 113
103332: PUSH
103333: LD_INT 114
103335: PUSH
103336: EMPTY
103337: LIST
103338: LIST
103339: LIST
103340: LIST
103341: LIST
103342: LIST
103343: LIST
103344: LIST
103345: LIST
103346: LIST
103347: LIST
103348: LIST
103349: LIST
103350: LIST
103351: PUSH
103352: EMPTY
103353: LIST
103354: LIST
103355: ST_TO_ADDR
103356: GO 104727
103358: LD_INT 13
103360: DOUBLE
103361: EQUAL
103362: IFTRUE 103366
103364: GO 103562
103366: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
103367: LD_ADDR_VAR 0 1
103371: PUSH
103372: LD_INT 1
103374: PUSH
103375: LD_INT 2
103377: PUSH
103378: LD_INT 3
103380: PUSH
103381: LD_INT 4
103383: PUSH
103384: LD_INT 5
103386: PUSH
103387: LD_INT 8
103389: PUSH
103390: LD_INT 9
103392: PUSH
103393: LD_INT 10
103395: PUSH
103396: LD_INT 11
103398: PUSH
103399: LD_INT 12
103401: PUSH
103402: LD_INT 14
103404: PUSH
103405: LD_INT 15
103407: PUSH
103408: LD_INT 16
103410: PUSH
103411: LD_INT 17
103413: PUSH
103414: LD_INT 18
103416: PUSH
103417: LD_INT 19
103419: PUSH
103420: LD_INT 20
103422: PUSH
103423: LD_INT 21
103425: PUSH
103426: LD_INT 22
103428: PUSH
103429: LD_INT 23
103431: PUSH
103432: LD_INT 24
103434: PUSH
103435: LD_INT 25
103437: PUSH
103438: LD_INT 26
103440: PUSH
103441: LD_INT 27
103443: PUSH
103444: LD_INT 28
103446: PUSH
103447: LD_INT 30
103449: PUSH
103450: LD_INT 31
103452: PUSH
103453: LD_INT 32
103455: PUSH
103456: LD_INT 33
103458: PUSH
103459: LD_INT 34
103461: PUSH
103462: LD_INT 36
103464: PUSH
103465: EMPTY
103466: LIST
103467: LIST
103468: LIST
103469: LIST
103470: LIST
103471: LIST
103472: LIST
103473: LIST
103474: LIST
103475: LIST
103476: LIST
103477: LIST
103478: LIST
103479: LIST
103480: LIST
103481: LIST
103482: LIST
103483: LIST
103484: LIST
103485: LIST
103486: LIST
103487: LIST
103488: LIST
103489: LIST
103490: LIST
103491: LIST
103492: LIST
103493: LIST
103494: LIST
103495: LIST
103496: LIST
103497: PUSH
103498: LD_INT 101
103500: PUSH
103501: LD_INT 102
103503: PUSH
103504: LD_INT 103
103506: PUSH
103507: LD_INT 104
103509: PUSH
103510: LD_INT 105
103512: PUSH
103513: LD_INT 106
103515: PUSH
103516: LD_INT 107
103518: PUSH
103519: LD_INT 108
103521: PUSH
103522: LD_INT 109
103524: PUSH
103525: LD_INT 110
103527: PUSH
103528: LD_INT 111
103530: PUSH
103531: LD_INT 112
103533: PUSH
103534: LD_INT 113
103536: PUSH
103537: LD_INT 114
103539: PUSH
103540: EMPTY
103541: LIST
103542: LIST
103543: LIST
103544: LIST
103545: LIST
103546: LIST
103547: LIST
103548: LIST
103549: LIST
103550: LIST
103551: LIST
103552: LIST
103553: LIST
103554: LIST
103555: PUSH
103556: EMPTY
103557: LIST
103558: LIST
103559: ST_TO_ADDR
103560: GO 104727
103562: LD_INT 14
103564: DOUBLE
103565: EQUAL
103566: IFTRUE 103570
103568: GO 103782
103570: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
103571: LD_ADDR_VAR 0 1
103575: PUSH
103576: LD_INT 1
103578: PUSH
103579: LD_INT 2
103581: PUSH
103582: LD_INT 3
103584: PUSH
103585: LD_INT 4
103587: PUSH
103588: LD_INT 5
103590: PUSH
103591: LD_INT 6
103593: PUSH
103594: LD_INT 7
103596: PUSH
103597: LD_INT 8
103599: PUSH
103600: LD_INT 9
103602: PUSH
103603: LD_INT 10
103605: PUSH
103606: LD_INT 11
103608: PUSH
103609: LD_INT 12
103611: PUSH
103612: LD_INT 13
103614: PUSH
103615: LD_INT 14
103617: PUSH
103618: LD_INT 15
103620: PUSH
103621: LD_INT 16
103623: PUSH
103624: LD_INT 17
103626: PUSH
103627: LD_INT 18
103629: PUSH
103630: LD_INT 19
103632: PUSH
103633: LD_INT 20
103635: PUSH
103636: LD_INT 21
103638: PUSH
103639: LD_INT 22
103641: PUSH
103642: LD_INT 23
103644: PUSH
103645: LD_INT 24
103647: PUSH
103648: LD_INT 25
103650: PUSH
103651: LD_INT 26
103653: PUSH
103654: LD_INT 27
103656: PUSH
103657: LD_INT 28
103659: PUSH
103660: LD_INT 29
103662: PUSH
103663: LD_INT 30
103665: PUSH
103666: LD_INT 31
103668: PUSH
103669: LD_INT 32
103671: PUSH
103672: LD_INT 33
103674: PUSH
103675: LD_INT 34
103677: PUSH
103678: LD_INT 36
103680: PUSH
103681: EMPTY
103682: LIST
103683: LIST
103684: LIST
103685: LIST
103686: LIST
103687: LIST
103688: LIST
103689: LIST
103690: LIST
103691: LIST
103692: LIST
103693: LIST
103694: LIST
103695: LIST
103696: LIST
103697: LIST
103698: LIST
103699: LIST
103700: LIST
103701: LIST
103702: LIST
103703: LIST
103704: LIST
103705: LIST
103706: LIST
103707: LIST
103708: LIST
103709: LIST
103710: LIST
103711: LIST
103712: LIST
103713: LIST
103714: LIST
103715: LIST
103716: LIST
103717: PUSH
103718: LD_INT 101
103720: PUSH
103721: LD_INT 102
103723: PUSH
103724: LD_INT 103
103726: PUSH
103727: LD_INT 104
103729: PUSH
103730: LD_INT 105
103732: PUSH
103733: LD_INT 106
103735: PUSH
103736: LD_INT 107
103738: PUSH
103739: LD_INT 108
103741: PUSH
103742: LD_INT 109
103744: PUSH
103745: LD_INT 110
103747: PUSH
103748: LD_INT 111
103750: PUSH
103751: LD_INT 112
103753: PUSH
103754: LD_INT 113
103756: PUSH
103757: LD_INT 114
103759: PUSH
103760: EMPTY
103761: LIST
103762: LIST
103763: LIST
103764: LIST
103765: LIST
103766: LIST
103767: LIST
103768: LIST
103769: LIST
103770: LIST
103771: LIST
103772: LIST
103773: LIST
103774: LIST
103775: PUSH
103776: EMPTY
103777: LIST
103778: LIST
103779: ST_TO_ADDR
103780: GO 104727
103782: LD_INT 15
103784: DOUBLE
103785: EQUAL
103786: IFTRUE 103790
103788: GO 104002
103790: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
103791: LD_ADDR_VAR 0 1
103795: PUSH
103796: LD_INT 1
103798: PUSH
103799: LD_INT 2
103801: PUSH
103802: LD_INT 3
103804: PUSH
103805: LD_INT 4
103807: PUSH
103808: LD_INT 5
103810: PUSH
103811: LD_INT 6
103813: PUSH
103814: LD_INT 7
103816: PUSH
103817: LD_INT 8
103819: PUSH
103820: LD_INT 9
103822: PUSH
103823: LD_INT 10
103825: PUSH
103826: LD_INT 11
103828: PUSH
103829: LD_INT 12
103831: PUSH
103832: LD_INT 13
103834: PUSH
103835: LD_INT 14
103837: PUSH
103838: LD_INT 15
103840: PUSH
103841: LD_INT 16
103843: PUSH
103844: LD_INT 17
103846: PUSH
103847: LD_INT 18
103849: PUSH
103850: LD_INT 19
103852: PUSH
103853: LD_INT 20
103855: PUSH
103856: LD_INT 21
103858: PUSH
103859: LD_INT 22
103861: PUSH
103862: LD_INT 23
103864: PUSH
103865: LD_INT 24
103867: PUSH
103868: LD_INT 25
103870: PUSH
103871: LD_INT 26
103873: PUSH
103874: LD_INT 27
103876: PUSH
103877: LD_INT 28
103879: PUSH
103880: LD_INT 29
103882: PUSH
103883: LD_INT 30
103885: PUSH
103886: LD_INT 31
103888: PUSH
103889: LD_INT 32
103891: PUSH
103892: LD_INT 33
103894: PUSH
103895: LD_INT 34
103897: PUSH
103898: LD_INT 36
103900: PUSH
103901: EMPTY
103902: LIST
103903: LIST
103904: LIST
103905: LIST
103906: LIST
103907: LIST
103908: LIST
103909: LIST
103910: LIST
103911: LIST
103912: LIST
103913: LIST
103914: LIST
103915: LIST
103916: LIST
103917: LIST
103918: LIST
103919: LIST
103920: LIST
103921: LIST
103922: LIST
103923: LIST
103924: LIST
103925: LIST
103926: LIST
103927: LIST
103928: LIST
103929: LIST
103930: LIST
103931: LIST
103932: LIST
103933: LIST
103934: LIST
103935: LIST
103936: LIST
103937: PUSH
103938: LD_INT 101
103940: PUSH
103941: LD_INT 102
103943: PUSH
103944: LD_INT 103
103946: PUSH
103947: LD_INT 104
103949: PUSH
103950: LD_INT 105
103952: PUSH
103953: LD_INT 106
103955: PUSH
103956: LD_INT 107
103958: PUSH
103959: LD_INT 108
103961: PUSH
103962: LD_INT 109
103964: PUSH
103965: LD_INT 110
103967: PUSH
103968: LD_INT 111
103970: PUSH
103971: LD_INT 112
103973: PUSH
103974: LD_INT 113
103976: PUSH
103977: LD_INT 114
103979: PUSH
103980: EMPTY
103981: LIST
103982: LIST
103983: LIST
103984: LIST
103985: LIST
103986: LIST
103987: LIST
103988: LIST
103989: LIST
103990: LIST
103991: LIST
103992: LIST
103993: LIST
103994: LIST
103995: PUSH
103996: EMPTY
103997: LIST
103998: LIST
103999: ST_TO_ADDR
104000: GO 104727
104002: LD_INT 16
104004: DOUBLE
104005: EQUAL
104006: IFTRUE 104010
104008: GO 104134
104010: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
104011: LD_ADDR_VAR 0 1
104015: PUSH
104016: LD_INT 2
104018: PUSH
104019: LD_INT 4
104021: PUSH
104022: LD_INT 5
104024: PUSH
104025: LD_INT 7
104027: PUSH
104028: LD_INT 11
104030: PUSH
104031: LD_INT 12
104033: PUSH
104034: LD_INT 15
104036: PUSH
104037: LD_INT 16
104039: PUSH
104040: LD_INT 20
104042: PUSH
104043: LD_INT 21
104045: PUSH
104046: LD_INT 22
104048: PUSH
104049: LD_INT 23
104051: PUSH
104052: LD_INT 25
104054: PUSH
104055: LD_INT 26
104057: PUSH
104058: LD_INT 30
104060: PUSH
104061: LD_INT 31
104063: PUSH
104064: LD_INT 32
104066: PUSH
104067: LD_INT 33
104069: PUSH
104070: LD_INT 34
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: LIST
104077: LIST
104078: LIST
104079: LIST
104080: LIST
104081: LIST
104082: LIST
104083: LIST
104084: LIST
104085: LIST
104086: LIST
104087: LIST
104088: LIST
104089: LIST
104090: LIST
104091: LIST
104092: LIST
104093: PUSH
104094: LD_INT 101
104096: PUSH
104097: LD_INT 102
104099: PUSH
104100: LD_INT 103
104102: PUSH
104103: LD_INT 106
104105: PUSH
104106: LD_INT 108
104108: PUSH
104109: LD_INT 112
104111: PUSH
104112: LD_INT 113
104114: PUSH
104115: LD_INT 114
104117: PUSH
104118: EMPTY
104119: LIST
104120: LIST
104121: LIST
104122: LIST
104123: LIST
104124: LIST
104125: LIST
104126: LIST
104127: PUSH
104128: EMPTY
104129: LIST
104130: LIST
104131: ST_TO_ADDR
104132: GO 104727
104134: LD_INT 17
104136: DOUBLE
104137: EQUAL
104138: IFTRUE 104142
104140: GO 104354
104142: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
104143: LD_ADDR_VAR 0 1
104147: PUSH
104148: LD_INT 1
104150: PUSH
104151: LD_INT 2
104153: PUSH
104154: LD_INT 3
104156: PUSH
104157: LD_INT 4
104159: PUSH
104160: LD_INT 5
104162: PUSH
104163: LD_INT 6
104165: PUSH
104166: LD_INT 7
104168: PUSH
104169: LD_INT 8
104171: PUSH
104172: LD_INT 9
104174: PUSH
104175: LD_INT 10
104177: PUSH
104178: LD_INT 11
104180: PUSH
104181: LD_INT 12
104183: PUSH
104184: LD_INT 13
104186: PUSH
104187: LD_INT 14
104189: PUSH
104190: LD_INT 15
104192: PUSH
104193: LD_INT 16
104195: PUSH
104196: LD_INT 17
104198: PUSH
104199: LD_INT 18
104201: PUSH
104202: LD_INT 19
104204: PUSH
104205: LD_INT 20
104207: PUSH
104208: LD_INT 21
104210: PUSH
104211: LD_INT 22
104213: PUSH
104214: LD_INT 23
104216: PUSH
104217: LD_INT 24
104219: PUSH
104220: LD_INT 25
104222: PUSH
104223: LD_INT 26
104225: PUSH
104226: LD_INT 27
104228: PUSH
104229: LD_INT 28
104231: PUSH
104232: LD_INT 29
104234: PUSH
104235: LD_INT 30
104237: PUSH
104238: LD_INT 31
104240: PUSH
104241: LD_INT 32
104243: PUSH
104244: LD_INT 33
104246: PUSH
104247: LD_INT 34
104249: PUSH
104250: LD_INT 36
104252: PUSH
104253: EMPTY
104254: LIST
104255: LIST
104256: LIST
104257: LIST
104258: LIST
104259: LIST
104260: LIST
104261: LIST
104262: LIST
104263: LIST
104264: LIST
104265: LIST
104266: LIST
104267: LIST
104268: LIST
104269: LIST
104270: LIST
104271: LIST
104272: LIST
104273: LIST
104274: LIST
104275: LIST
104276: LIST
104277: LIST
104278: LIST
104279: LIST
104280: LIST
104281: LIST
104282: LIST
104283: LIST
104284: LIST
104285: LIST
104286: LIST
104287: LIST
104288: LIST
104289: PUSH
104290: LD_INT 101
104292: PUSH
104293: LD_INT 102
104295: PUSH
104296: LD_INT 103
104298: PUSH
104299: LD_INT 104
104301: PUSH
104302: LD_INT 105
104304: PUSH
104305: LD_INT 106
104307: PUSH
104308: LD_INT 107
104310: PUSH
104311: LD_INT 108
104313: PUSH
104314: LD_INT 109
104316: PUSH
104317: LD_INT 110
104319: PUSH
104320: LD_INT 111
104322: PUSH
104323: LD_INT 112
104325: PUSH
104326: LD_INT 113
104328: PUSH
104329: LD_INT 114
104331: PUSH
104332: EMPTY
104333: LIST
104334: LIST
104335: LIST
104336: LIST
104337: LIST
104338: LIST
104339: LIST
104340: LIST
104341: LIST
104342: LIST
104343: LIST
104344: LIST
104345: LIST
104346: LIST
104347: PUSH
104348: EMPTY
104349: LIST
104350: LIST
104351: ST_TO_ADDR
104352: GO 104727
104354: LD_INT 18
104356: DOUBLE
104357: EQUAL
104358: IFTRUE 104362
104360: GO 104498
104362: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
104363: LD_ADDR_VAR 0 1
104367: PUSH
104368: LD_INT 2
104370: PUSH
104371: LD_INT 4
104373: PUSH
104374: LD_INT 5
104376: PUSH
104377: LD_INT 7
104379: PUSH
104380: LD_INT 11
104382: PUSH
104383: LD_INT 12
104385: PUSH
104386: LD_INT 15
104388: PUSH
104389: LD_INT 16
104391: PUSH
104392: LD_INT 20
104394: PUSH
104395: LD_INT 21
104397: PUSH
104398: LD_INT 22
104400: PUSH
104401: LD_INT 23
104403: PUSH
104404: LD_INT 25
104406: PUSH
104407: LD_INT 26
104409: PUSH
104410: LD_INT 30
104412: PUSH
104413: LD_INT 31
104415: PUSH
104416: LD_INT 32
104418: PUSH
104419: LD_INT 33
104421: PUSH
104422: LD_INT 34
104424: PUSH
104425: LD_INT 35
104427: PUSH
104428: LD_INT 36
104430: PUSH
104431: EMPTY
104432: LIST
104433: LIST
104434: LIST
104435: LIST
104436: LIST
104437: LIST
104438: LIST
104439: LIST
104440: LIST
104441: LIST
104442: LIST
104443: LIST
104444: LIST
104445: LIST
104446: LIST
104447: LIST
104448: LIST
104449: LIST
104450: LIST
104451: LIST
104452: LIST
104453: PUSH
104454: LD_INT 101
104456: PUSH
104457: LD_INT 102
104459: PUSH
104460: LD_INT 103
104462: PUSH
104463: LD_INT 106
104465: PUSH
104466: LD_INT 108
104468: PUSH
104469: LD_INT 112
104471: PUSH
104472: LD_INT 113
104474: PUSH
104475: LD_INT 114
104477: PUSH
104478: LD_INT 115
104480: PUSH
104481: EMPTY
104482: LIST
104483: LIST
104484: LIST
104485: LIST
104486: LIST
104487: LIST
104488: LIST
104489: LIST
104490: LIST
104491: PUSH
104492: EMPTY
104493: LIST
104494: LIST
104495: ST_TO_ADDR
104496: GO 104727
104498: LD_INT 19
104500: DOUBLE
104501: EQUAL
104502: IFTRUE 104506
104504: GO 104726
104506: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
104507: LD_ADDR_VAR 0 1
104511: PUSH
104512: LD_INT 1
104514: PUSH
104515: LD_INT 2
104517: PUSH
104518: LD_INT 3
104520: PUSH
104521: LD_INT 4
104523: PUSH
104524: LD_INT 5
104526: PUSH
104527: LD_INT 6
104529: PUSH
104530: LD_INT 7
104532: PUSH
104533: LD_INT 8
104535: PUSH
104536: LD_INT 9
104538: PUSH
104539: LD_INT 10
104541: PUSH
104542: LD_INT 11
104544: PUSH
104545: LD_INT 12
104547: PUSH
104548: LD_INT 13
104550: PUSH
104551: LD_INT 14
104553: PUSH
104554: LD_INT 15
104556: PUSH
104557: LD_INT 16
104559: PUSH
104560: LD_INT 17
104562: PUSH
104563: LD_INT 18
104565: PUSH
104566: LD_INT 19
104568: PUSH
104569: LD_INT 20
104571: PUSH
104572: LD_INT 21
104574: PUSH
104575: LD_INT 22
104577: PUSH
104578: LD_INT 23
104580: PUSH
104581: LD_INT 24
104583: PUSH
104584: LD_INT 25
104586: PUSH
104587: LD_INT 26
104589: PUSH
104590: LD_INT 27
104592: PUSH
104593: LD_INT 28
104595: PUSH
104596: LD_INT 29
104598: PUSH
104599: LD_INT 30
104601: PUSH
104602: LD_INT 31
104604: PUSH
104605: LD_INT 32
104607: PUSH
104608: LD_INT 33
104610: PUSH
104611: LD_INT 34
104613: PUSH
104614: LD_INT 35
104616: PUSH
104617: LD_INT 36
104619: PUSH
104620: EMPTY
104621: LIST
104622: LIST
104623: LIST
104624: LIST
104625: LIST
104626: LIST
104627: LIST
104628: LIST
104629: LIST
104630: LIST
104631: LIST
104632: LIST
104633: LIST
104634: LIST
104635: LIST
104636: LIST
104637: LIST
104638: LIST
104639: LIST
104640: LIST
104641: LIST
104642: LIST
104643: LIST
104644: LIST
104645: LIST
104646: LIST
104647: LIST
104648: LIST
104649: LIST
104650: LIST
104651: LIST
104652: LIST
104653: LIST
104654: LIST
104655: LIST
104656: LIST
104657: PUSH
104658: LD_INT 101
104660: PUSH
104661: LD_INT 102
104663: PUSH
104664: LD_INT 103
104666: PUSH
104667: LD_INT 104
104669: PUSH
104670: LD_INT 105
104672: PUSH
104673: LD_INT 106
104675: PUSH
104676: LD_INT 107
104678: PUSH
104679: LD_INT 108
104681: PUSH
104682: LD_INT 109
104684: PUSH
104685: LD_INT 110
104687: PUSH
104688: LD_INT 111
104690: PUSH
104691: LD_INT 112
104693: PUSH
104694: LD_INT 113
104696: PUSH
104697: LD_INT 114
104699: PUSH
104700: LD_INT 115
104702: PUSH
104703: EMPTY
104704: LIST
104705: LIST
104706: LIST
104707: LIST
104708: LIST
104709: LIST
104710: LIST
104711: LIST
104712: LIST
104713: LIST
104714: LIST
104715: LIST
104716: LIST
104717: LIST
104718: LIST
104719: PUSH
104720: EMPTY
104721: LIST
104722: LIST
104723: ST_TO_ADDR
104724: GO 104727
104726: POP
// end else
104727: GO 104946
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
104729: LD_ADDR_VAR 0 1
104733: PUSH
104734: LD_INT 1
104736: PUSH
104737: LD_INT 2
104739: PUSH
104740: LD_INT 3
104742: PUSH
104743: LD_INT 4
104745: PUSH
104746: LD_INT 5
104748: PUSH
104749: LD_INT 6
104751: PUSH
104752: LD_INT 7
104754: PUSH
104755: LD_INT 8
104757: PUSH
104758: LD_INT 9
104760: PUSH
104761: LD_INT 10
104763: PUSH
104764: LD_INT 11
104766: PUSH
104767: LD_INT 12
104769: PUSH
104770: LD_INT 13
104772: PUSH
104773: LD_INT 14
104775: PUSH
104776: LD_INT 15
104778: PUSH
104779: LD_INT 16
104781: PUSH
104782: LD_INT 17
104784: PUSH
104785: LD_INT 18
104787: PUSH
104788: LD_INT 19
104790: PUSH
104791: LD_INT 20
104793: PUSH
104794: LD_INT 21
104796: PUSH
104797: LD_INT 22
104799: PUSH
104800: LD_INT 23
104802: PUSH
104803: LD_INT 24
104805: PUSH
104806: LD_INT 25
104808: PUSH
104809: LD_INT 26
104811: PUSH
104812: LD_INT 27
104814: PUSH
104815: LD_INT 28
104817: PUSH
104818: LD_INT 29
104820: PUSH
104821: LD_INT 30
104823: PUSH
104824: LD_INT 31
104826: PUSH
104827: LD_INT 32
104829: PUSH
104830: LD_INT 33
104832: PUSH
104833: LD_INT 34
104835: PUSH
104836: LD_INT 35
104838: PUSH
104839: LD_INT 36
104841: PUSH
104842: EMPTY
104843: LIST
104844: LIST
104845: LIST
104846: LIST
104847: LIST
104848: LIST
104849: LIST
104850: LIST
104851: LIST
104852: LIST
104853: LIST
104854: LIST
104855: LIST
104856: LIST
104857: LIST
104858: LIST
104859: LIST
104860: LIST
104861: LIST
104862: LIST
104863: LIST
104864: LIST
104865: LIST
104866: LIST
104867: LIST
104868: LIST
104869: LIST
104870: LIST
104871: LIST
104872: LIST
104873: LIST
104874: LIST
104875: LIST
104876: LIST
104877: LIST
104878: LIST
104879: PUSH
104880: LD_INT 101
104882: PUSH
104883: LD_INT 102
104885: PUSH
104886: LD_INT 103
104888: PUSH
104889: LD_INT 104
104891: PUSH
104892: LD_INT 105
104894: PUSH
104895: LD_INT 106
104897: PUSH
104898: LD_INT 107
104900: PUSH
104901: LD_INT 108
104903: PUSH
104904: LD_INT 109
104906: PUSH
104907: LD_INT 110
104909: PUSH
104910: LD_INT 111
104912: PUSH
104913: LD_INT 112
104915: PUSH
104916: LD_INT 113
104918: PUSH
104919: LD_INT 114
104921: PUSH
104922: LD_INT 115
104924: PUSH
104925: EMPTY
104926: LIST
104927: LIST
104928: LIST
104929: LIST
104930: LIST
104931: LIST
104932: LIST
104933: LIST
104934: LIST
104935: LIST
104936: LIST
104937: LIST
104938: LIST
104939: LIST
104940: LIST
104941: PUSH
104942: EMPTY
104943: LIST
104944: LIST
104945: ST_TO_ADDR
// if result then
104946: LD_VAR 0 1
104950: IFFALSE 105239
// begin normal :=  ;
104952: LD_ADDR_VAR 0 3
104956: PUSH
104957: LD_STRING 
104959: ST_TO_ADDR
// hardcore :=  ;
104960: LD_ADDR_VAR 0 4
104964: PUSH
104965: LD_STRING 
104967: ST_TO_ADDR
// for i = 1 to normalCounter do
104968: LD_ADDR_VAR 0 5
104972: PUSH
104973: DOUBLE
104974: LD_INT 1
104976: DEC
104977: ST_TO_ADDR
104978: LD_EXP 154
104982: PUSH
104983: FOR_TO
104984: IFFALSE 105085
// begin tmp := 0 ;
104986: LD_ADDR_VAR 0 2
104990: PUSH
104991: LD_STRING 0
104993: ST_TO_ADDR
// if result [ 1 ] then
104994: LD_VAR 0 1
104998: PUSH
104999: LD_INT 1
105001: ARRAY
105002: IFFALSE 105067
// if result [ 1 ] [ 1 ] = i then
105004: LD_VAR 0 1
105008: PUSH
105009: LD_INT 1
105011: ARRAY
105012: PUSH
105013: LD_INT 1
105015: ARRAY
105016: PUSH
105017: LD_VAR 0 5
105021: EQUAL
105022: IFFALSE 105067
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
105024: LD_ADDR_VAR 0 1
105028: PUSH
105029: LD_VAR 0 1
105033: PPUSH
105034: LD_INT 1
105036: PPUSH
105037: LD_VAR 0 1
105041: PUSH
105042: LD_INT 1
105044: ARRAY
105045: PPUSH
105046: LD_INT 1
105048: PPUSH
105049: CALL_OW 3
105053: PPUSH
105054: CALL_OW 1
105058: ST_TO_ADDR
// tmp := 1 ;
105059: LD_ADDR_VAR 0 2
105063: PUSH
105064: LD_STRING 1
105066: ST_TO_ADDR
// end ; normal := normal & tmp ;
105067: LD_ADDR_VAR 0 3
105071: PUSH
105072: LD_VAR 0 3
105076: PUSH
105077: LD_VAR 0 2
105081: STR
105082: ST_TO_ADDR
// end ;
105083: GO 104983
105085: POP
105086: POP
// for i = 1 to hardcoreCounter do
105087: LD_ADDR_VAR 0 5
105091: PUSH
105092: DOUBLE
105093: LD_INT 1
105095: DEC
105096: ST_TO_ADDR
105097: LD_EXP 155
105101: PUSH
105102: FOR_TO
105103: IFFALSE 105208
// begin tmp := 0 ;
105105: LD_ADDR_VAR 0 2
105109: PUSH
105110: LD_STRING 0
105112: ST_TO_ADDR
// if result [ 2 ] then
105113: LD_VAR 0 1
105117: PUSH
105118: LD_INT 2
105120: ARRAY
105121: IFFALSE 105190
// if result [ 2 ] [ 1 ] = 100 + i then
105123: LD_VAR 0 1
105127: PUSH
105128: LD_INT 2
105130: ARRAY
105131: PUSH
105132: LD_INT 1
105134: ARRAY
105135: PUSH
105136: LD_INT 100
105138: PUSH
105139: LD_VAR 0 5
105143: PLUS
105144: EQUAL
105145: IFFALSE 105190
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
105147: LD_ADDR_VAR 0 1
105151: PUSH
105152: LD_VAR 0 1
105156: PPUSH
105157: LD_INT 2
105159: PPUSH
105160: LD_VAR 0 1
105164: PUSH
105165: LD_INT 2
105167: ARRAY
105168: PPUSH
105169: LD_INT 1
105171: PPUSH
105172: CALL_OW 3
105176: PPUSH
105177: CALL_OW 1
105181: ST_TO_ADDR
// tmp := 1 ;
105182: LD_ADDR_VAR 0 2
105186: PUSH
105187: LD_STRING 1
105189: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
105190: LD_ADDR_VAR 0 4
105194: PUSH
105195: LD_VAR 0 4
105199: PUSH
105200: LD_VAR 0 2
105204: STR
105205: ST_TO_ADDR
// end ;
105206: GO 105102
105208: POP
105209: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
105210: LD_STRING getStreamItemsFromMission("
105212: PUSH
105213: LD_VAR 0 3
105217: STR
105218: PUSH
105219: LD_STRING ","
105221: STR
105222: PUSH
105223: LD_VAR 0 4
105227: STR
105228: PUSH
105229: LD_STRING ")
105231: STR
105232: PPUSH
105233: CALL_OW 559
// end else
105237: GO 105246
// ToLua ( getStreamItemsFromMission("","") ) ;
105239: LD_STRING getStreamItemsFromMission("","")
105241: PPUSH
105242: CALL_OW 559
// end ;
105246: LD_VAR 0 1
105250: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
105251: LD_VAR 0 2
105255: PUSH
105256: LD_INT 100
105258: EQUAL
105259: IFFALSE 106208
// begin if not StreamModeActive then
105261: LD_EXP 153
105265: NOT
105266: IFFALSE 105276
// StreamModeActive := true ;
105268: LD_ADDR_EXP 153
105272: PUSH
105273: LD_INT 1
105275: ST_TO_ADDR
// if p3 = 0 then
105276: LD_VAR 0 3
105280: PUSH
105281: LD_INT 0
105283: EQUAL
105284: IFFALSE 105290
// InitStreamMode ;
105286: CALL 101329 0 0
// if p3 = 1 then
105290: LD_VAR 0 3
105294: PUSH
105295: LD_INT 1
105297: EQUAL
105298: IFFALSE 105308
// sRocket := true ;
105300: LD_ADDR_EXP 158
105304: PUSH
105305: LD_INT 1
105307: ST_TO_ADDR
// if p3 = 2 then
105308: LD_VAR 0 3
105312: PUSH
105313: LD_INT 2
105315: EQUAL
105316: IFFALSE 105326
// sSpeed := true ;
105318: LD_ADDR_EXP 157
105322: PUSH
105323: LD_INT 1
105325: ST_TO_ADDR
// if p3 = 3 then
105326: LD_VAR 0 3
105330: PUSH
105331: LD_INT 3
105333: EQUAL
105334: IFFALSE 105344
// sEngine := true ;
105336: LD_ADDR_EXP 159
105340: PUSH
105341: LD_INT 1
105343: ST_TO_ADDR
// if p3 = 4 then
105344: LD_VAR 0 3
105348: PUSH
105349: LD_INT 4
105351: EQUAL
105352: IFFALSE 105362
// sSpec := true ;
105354: LD_ADDR_EXP 156
105358: PUSH
105359: LD_INT 1
105361: ST_TO_ADDR
// if p3 = 5 then
105362: LD_VAR 0 3
105366: PUSH
105367: LD_INT 5
105369: EQUAL
105370: IFFALSE 105380
// sLevel := true ;
105372: LD_ADDR_EXP 160
105376: PUSH
105377: LD_INT 1
105379: ST_TO_ADDR
// if p3 = 6 then
105380: LD_VAR 0 3
105384: PUSH
105385: LD_INT 6
105387: EQUAL
105388: IFFALSE 105398
// sArmoury := true ;
105390: LD_ADDR_EXP 161
105394: PUSH
105395: LD_INT 1
105397: ST_TO_ADDR
// if p3 = 7 then
105398: LD_VAR 0 3
105402: PUSH
105403: LD_INT 7
105405: EQUAL
105406: IFFALSE 105416
// sRadar := true ;
105408: LD_ADDR_EXP 162
105412: PUSH
105413: LD_INT 1
105415: ST_TO_ADDR
// if p3 = 8 then
105416: LD_VAR 0 3
105420: PUSH
105421: LD_INT 8
105423: EQUAL
105424: IFFALSE 105434
// sBunker := true ;
105426: LD_ADDR_EXP 163
105430: PUSH
105431: LD_INT 1
105433: ST_TO_ADDR
// if p3 = 9 then
105434: LD_VAR 0 3
105438: PUSH
105439: LD_INT 9
105441: EQUAL
105442: IFFALSE 105452
// sHack := true ;
105444: LD_ADDR_EXP 164
105448: PUSH
105449: LD_INT 1
105451: ST_TO_ADDR
// if p3 = 10 then
105452: LD_VAR 0 3
105456: PUSH
105457: LD_INT 10
105459: EQUAL
105460: IFFALSE 105470
// sFire := true ;
105462: LD_ADDR_EXP 165
105466: PUSH
105467: LD_INT 1
105469: ST_TO_ADDR
// if p3 = 11 then
105470: LD_VAR 0 3
105474: PUSH
105475: LD_INT 11
105477: EQUAL
105478: IFFALSE 105488
// sRefresh := true ;
105480: LD_ADDR_EXP 166
105484: PUSH
105485: LD_INT 1
105487: ST_TO_ADDR
// if p3 = 12 then
105488: LD_VAR 0 3
105492: PUSH
105493: LD_INT 12
105495: EQUAL
105496: IFFALSE 105506
// sExp := true ;
105498: LD_ADDR_EXP 167
105502: PUSH
105503: LD_INT 1
105505: ST_TO_ADDR
// if p3 = 13 then
105506: LD_VAR 0 3
105510: PUSH
105511: LD_INT 13
105513: EQUAL
105514: IFFALSE 105524
// sDepot := true ;
105516: LD_ADDR_EXP 168
105520: PUSH
105521: LD_INT 1
105523: ST_TO_ADDR
// if p3 = 14 then
105524: LD_VAR 0 3
105528: PUSH
105529: LD_INT 14
105531: EQUAL
105532: IFFALSE 105542
// sFlag := true ;
105534: LD_ADDR_EXP 169
105538: PUSH
105539: LD_INT 1
105541: ST_TO_ADDR
// if p3 = 15 then
105542: LD_VAR 0 3
105546: PUSH
105547: LD_INT 15
105549: EQUAL
105550: IFFALSE 105560
// sKamikadze := true ;
105552: LD_ADDR_EXP 177
105556: PUSH
105557: LD_INT 1
105559: ST_TO_ADDR
// if p3 = 16 then
105560: LD_VAR 0 3
105564: PUSH
105565: LD_INT 16
105567: EQUAL
105568: IFFALSE 105578
// sTroll := true ;
105570: LD_ADDR_EXP 178
105574: PUSH
105575: LD_INT 1
105577: ST_TO_ADDR
// if p3 = 17 then
105578: LD_VAR 0 3
105582: PUSH
105583: LD_INT 17
105585: EQUAL
105586: IFFALSE 105596
// sSlow := true ;
105588: LD_ADDR_EXP 179
105592: PUSH
105593: LD_INT 1
105595: ST_TO_ADDR
// if p3 = 18 then
105596: LD_VAR 0 3
105600: PUSH
105601: LD_INT 18
105603: EQUAL
105604: IFFALSE 105614
// sLack := true ;
105606: LD_ADDR_EXP 180
105610: PUSH
105611: LD_INT 1
105613: ST_TO_ADDR
// if p3 = 19 then
105614: LD_VAR 0 3
105618: PUSH
105619: LD_INT 19
105621: EQUAL
105622: IFFALSE 105632
// sTank := true ;
105624: LD_ADDR_EXP 182
105628: PUSH
105629: LD_INT 1
105631: ST_TO_ADDR
// if p3 = 20 then
105632: LD_VAR 0 3
105636: PUSH
105637: LD_INT 20
105639: EQUAL
105640: IFFALSE 105650
// sRemote := true ;
105642: LD_ADDR_EXP 183
105646: PUSH
105647: LD_INT 1
105649: ST_TO_ADDR
// if p3 = 21 then
105650: LD_VAR 0 3
105654: PUSH
105655: LD_INT 21
105657: EQUAL
105658: IFFALSE 105668
// sPowell := true ;
105660: LD_ADDR_EXP 184
105664: PUSH
105665: LD_INT 1
105667: ST_TO_ADDR
// if p3 = 22 then
105668: LD_VAR 0 3
105672: PUSH
105673: LD_INT 22
105675: EQUAL
105676: IFFALSE 105686
// sTeleport := true ;
105678: LD_ADDR_EXP 187
105682: PUSH
105683: LD_INT 1
105685: ST_TO_ADDR
// if p3 = 23 then
105686: LD_VAR 0 3
105690: PUSH
105691: LD_INT 23
105693: EQUAL
105694: IFFALSE 105704
// sOilTower := true ;
105696: LD_ADDR_EXP 189
105700: PUSH
105701: LD_INT 1
105703: ST_TO_ADDR
// if p3 = 24 then
105704: LD_VAR 0 3
105708: PUSH
105709: LD_INT 24
105711: EQUAL
105712: IFFALSE 105722
// sShovel := true ;
105714: LD_ADDR_EXP 190
105718: PUSH
105719: LD_INT 1
105721: ST_TO_ADDR
// if p3 = 25 then
105722: LD_VAR 0 3
105726: PUSH
105727: LD_INT 25
105729: EQUAL
105730: IFFALSE 105740
// sSheik := true ;
105732: LD_ADDR_EXP 191
105736: PUSH
105737: LD_INT 1
105739: ST_TO_ADDR
// if p3 = 26 then
105740: LD_VAR 0 3
105744: PUSH
105745: LD_INT 26
105747: EQUAL
105748: IFFALSE 105758
// sEarthquake := true ;
105750: LD_ADDR_EXP 193
105754: PUSH
105755: LD_INT 1
105757: ST_TO_ADDR
// if p3 = 27 then
105758: LD_VAR 0 3
105762: PUSH
105763: LD_INT 27
105765: EQUAL
105766: IFFALSE 105776
// sAI := true ;
105768: LD_ADDR_EXP 194
105772: PUSH
105773: LD_INT 1
105775: ST_TO_ADDR
// if p3 = 28 then
105776: LD_VAR 0 3
105780: PUSH
105781: LD_INT 28
105783: EQUAL
105784: IFFALSE 105794
// sCargo := true ;
105786: LD_ADDR_EXP 197
105790: PUSH
105791: LD_INT 1
105793: ST_TO_ADDR
// if p3 = 29 then
105794: LD_VAR 0 3
105798: PUSH
105799: LD_INT 29
105801: EQUAL
105802: IFFALSE 105812
// sDLaser := true ;
105804: LD_ADDR_EXP 198
105808: PUSH
105809: LD_INT 1
105811: ST_TO_ADDR
// if p3 = 30 then
105812: LD_VAR 0 3
105816: PUSH
105817: LD_INT 30
105819: EQUAL
105820: IFFALSE 105830
// sExchange := true ;
105822: LD_ADDR_EXP 199
105826: PUSH
105827: LD_INT 1
105829: ST_TO_ADDR
// if p3 = 31 then
105830: LD_VAR 0 3
105834: PUSH
105835: LD_INT 31
105837: EQUAL
105838: IFFALSE 105848
// sFac := true ;
105840: LD_ADDR_EXP 200
105844: PUSH
105845: LD_INT 1
105847: ST_TO_ADDR
// if p3 = 32 then
105848: LD_VAR 0 3
105852: PUSH
105853: LD_INT 32
105855: EQUAL
105856: IFFALSE 105866
// sPower := true ;
105858: LD_ADDR_EXP 201
105862: PUSH
105863: LD_INT 1
105865: ST_TO_ADDR
// if p3 = 33 then
105866: LD_VAR 0 3
105870: PUSH
105871: LD_INT 33
105873: EQUAL
105874: IFFALSE 105884
// sRandom := true ;
105876: LD_ADDR_EXP 202
105880: PUSH
105881: LD_INT 1
105883: ST_TO_ADDR
// if p3 = 34 then
105884: LD_VAR 0 3
105888: PUSH
105889: LD_INT 34
105891: EQUAL
105892: IFFALSE 105902
// sShield := true ;
105894: LD_ADDR_EXP 203
105898: PUSH
105899: LD_INT 1
105901: ST_TO_ADDR
// if p3 = 35 then
105902: LD_VAR 0 3
105906: PUSH
105907: LD_INT 35
105909: EQUAL
105910: IFFALSE 105920
// sTime := true ;
105912: LD_ADDR_EXP 204
105916: PUSH
105917: LD_INT 1
105919: ST_TO_ADDR
// if p3 = 36 then
105920: LD_VAR 0 3
105924: PUSH
105925: LD_INT 36
105927: EQUAL
105928: IFFALSE 105938
// sTools := true ;
105930: LD_ADDR_EXP 205
105934: PUSH
105935: LD_INT 1
105937: ST_TO_ADDR
// if p3 = 101 then
105938: LD_VAR 0 3
105942: PUSH
105943: LD_INT 101
105945: EQUAL
105946: IFFALSE 105956
// sSold := true ;
105948: LD_ADDR_EXP 170
105952: PUSH
105953: LD_INT 1
105955: ST_TO_ADDR
// if p3 = 102 then
105956: LD_VAR 0 3
105960: PUSH
105961: LD_INT 102
105963: EQUAL
105964: IFFALSE 105974
// sDiff := true ;
105966: LD_ADDR_EXP 171
105970: PUSH
105971: LD_INT 1
105973: ST_TO_ADDR
// if p3 = 103 then
105974: LD_VAR 0 3
105978: PUSH
105979: LD_INT 103
105981: EQUAL
105982: IFFALSE 105992
// sFog := true ;
105984: LD_ADDR_EXP 174
105988: PUSH
105989: LD_INT 1
105991: ST_TO_ADDR
// if p3 = 104 then
105992: LD_VAR 0 3
105996: PUSH
105997: LD_INT 104
105999: EQUAL
106000: IFFALSE 106010
// sReset := true ;
106002: LD_ADDR_EXP 175
106006: PUSH
106007: LD_INT 1
106009: ST_TO_ADDR
// if p3 = 105 then
106010: LD_VAR 0 3
106014: PUSH
106015: LD_INT 105
106017: EQUAL
106018: IFFALSE 106028
// sSun := true ;
106020: LD_ADDR_EXP 176
106024: PUSH
106025: LD_INT 1
106027: ST_TO_ADDR
// if p3 = 106 then
106028: LD_VAR 0 3
106032: PUSH
106033: LD_INT 106
106035: EQUAL
106036: IFFALSE 106046
// sTiger := true ;
106038: LD_ADDR_EXP 172
106042: PUSH
106043: LD_INT 1
106045: ST_TO_ADDR
// if p3 = 107 then
106046: LD_VAR 0 3
106050: PUSH
106051: LD_INT 107
106053: EQUAL
106054: IFFALSE 106064
// sBomb := true ;
106056: LD_ADDR_EXP 173
106060: PUSH
106061: LD_INT 1
106063: ST_TO_ADDR
// if p3 = 108 then
106064: LD_VAR 0 3
106068: PUSH
106069: LD_INT 108
106071: EQUAL
106072: IFFALSE 106082
// sWound := true ;
106074: LD_ADDR_EXP 181
106078: PUSH
106079: LD_INT 1
106081: ST_TO_ADDR
// if p3 = 109 then
106082: LD_VAR 0 3
106086: PUSH
106087: LD_INT 109
106089: EQUAL
106090: IFFALSE 106100
// sBetray := true ;
106092: LD_ADDR_EXP 185
106096: PUSH
106097: LD_INT 1
106099: ST_TO_ADDR
// if p3 = 110 then
106100: LD_VAR 0 3
106104: PUSH
106105: LD_INT 110
106107: EQUAL
106108: IFFALSE 106118
// sContamin := true ;
106110: LD_ADDR_EXP 186
106114: PUSH
106115: LD_INT 1
106117: ST_TO_ADDR
// if p3 = 111 then
106118: LD_VAR 0 3
106122: PUSH
106123: LD_INT 111
106125: EQUAL
106126: IFFALSE 106136
// sOil := true ;
106128: LD_ADDR_EXP 188
106132: PUSH
106133: LD_INT 1
106135: ST_TO_ADDR
// if p3 = 112 then
106136: LD_VAR 0 3
106140: PUSH
106141: LD_INT 112
106143: EQUAL
106144: IFFALSE 106154
// sStu := true ;
106146: LD_ADDR_EXP 192
106150: PUSH
106151: LD_INT 1
106153: ST_TO_ADDR
// if p3 = 113 then
106154: LD_VAR 0 3
106158: PUSH
106159: LD_INT 113
106161: EQUAL
106162: IFFALSE 106172
// sBazooka := true ;
106164: LD_ADDR_EXP 195
106168: PUSH
106169: LD_INT 1
106171: ST_TO_ADDR
// if p3 = 114 then
106172: LD_VAR 0 3
106176: PUSH
106177: LD_INT 114
106179: EQUAL
106180: IFFALSE 106190
// sMortar := true ;
106182: LD_ADDR_EXP 196
106186: PUSH
106187: LD_INT 1
106189: ST_TO_ADDR
// if p3 = 115 then
106190: LD_VAR 0 3
106194: PUSH
106195: LD_INT 115
106197: EQUAL
106198: IFFALSE 106208
// sRanger := true ;
106200: LD_ADDR_EXP 206
106204: PUSH
106205: LD_INT 1
106207: ST_TO_ADDR
// end ; end ;
106208: PPOPN 6
106210: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
106211: LD_EXP 153
106215: PUSH
106216: LD_EXP 158
106220: AND
106221: IFFALSE 106345
106223: GO 106225
106225: DISABLE
106226: LD_INT 0
106228: PPUSH
106229: PPUSH
// begin enable ;
106230: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
106231: LD_ADDR_VAR 0 2
106235: PUSH
106236: LD_INT 22
106238: PUSH
106239: LD_OWVAR 2
106243: PUSH
106244: EMPTY
106245: LIST
106246: LIST
106247: PUSH
106248: LD_INT 2
106250: PUSH
106251: LD_INT 34
106253: PUSH
106254: LD_INT 7
106256: PUSH
106257: EMPTY
106258: LIST
106259: LIST
106260: PUSH
106261: LD_INT 34
106263: PUSH
106264: LD_INT 45
106266: PUSH
106267: EMPTY
106268: LIST
106269: LIST
106270: PUSH
106271: LD_INT 34
106273: PUSH
106274: LD_INT 28
106276: PUSH
106277: EMPTY
106278: LIST
106279: LIST
106280: PUSH
106281: LD_INT 34
106283: PUSH
106284: LD_INT 47
106286: PUSH
106287: EMPTY
106288: LIST
106289: LIST
106290: PUSH
106291: EMPTY
106292: LIST
106293: LIST
106294: LIST
106295: LIST
106296: LIST
106297: PUSH
106298: EMPTY
106299: LIST
106300: LIST
106301: PPUSH
106302: CALL_OW 69
106306: ST_TO_ADDR
// if not tmp then
106307: LD_VAR 0 2
106311: NOT
106312: IFFALSE 106316
// exit ;
106314: GO 106345
// for i in tmp do
106316: LD_ADDR_VAR 0 1
106320: PUSH
106321: LD_VAR 0 2
106325: PUSH
106326: FOR_IN
106327: IFFALSE 106343
// begin SetLives ( i , 0 ) ;
106329: LD_VAR 0 1
106333: PPUSH
106334: LD_INT 0
106336: PPUSH
106337: CALL_OW 234
// end ;
106341: GO 106326
106343: POP
106344: POP
// end ;
106345: PPOPN 2
106347: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
106348: LD_EXP 153
106352: PUSH
106353: LD_EXP 159
106357: AND
106358: IFFALSE 106442
106360: GO 106362
106362: DISABLE
106363: LD_INT 0
106365: PPUSH
106366: PPUSH
// begin enable ;
106367: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
106368: LD_ADDR_VAR 0 2
106372: PUSH
106373: LD_INT 22
106375: PUSH
106376: LD_OWVAR 2
106380: PUSH
106381: EMPTY
106382: LIST
106383: LIST
106384: PUSH
106385: LD_INT 32
106387: PUSH
106388: LD_INT 3
106390: PUSH
106391: EMPTY
106392: LIST
106393: LIST
106394: PUSH
106395: EMPTY
106396: LIST
106397: LIST
106398: PPUSH
106399: CALL_OW 69
106403: ST_TO_ADDR
// if not tmp then
106404: LD_VAR 0 2
106408: NOT
106409: IFFALSE 106413
// exit ;
106411: GO 106442
// for i in tmp do
106413: LD_ADDR_VAR 0 1
106417: PUSH
106418: LD_VAR 0 2
106422: PUSH
106423: FOR_IN
106424: IFFALSE 106440
// begin SetLives ( i , 0 ) ;
106426: LD_VAR 0 1
106430: PPUSH
106431: LD_INT 0
106433: PPUSH
106434: CALL_OW 234
// end ;
106438: GO 106423
106440: POP
106441: POP
// end ;
106442: PPOPN 2
106444: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
106445: LD_EXP 153
106449: PUSH
106450: LD_EXP 156
106454: AND
106455: IFFALSE 106548
106457: GO 106459
106459: DISABLE
106460: LD_INT 0
106462: PPUSH
// begin enable ;
106463: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
106464: LD_ADDR_VAR 0 1
106468: PUSH
106469: LD_INT 22
106471: PUSH
106472: LD_OWVAR 2
106476: PUSH
106477: EMPTY
106478: LIST
106479: LIST
106480: PUSH
106481: LD_INT 2
106483: PUSH
106484: LD_INT 25
106486: PUSH
106487: LD_INT 5
106489: PUSH
106490: EMPTY
106491: LIST
106492: LIST
106493: PUSH
106494: LD_INT 25
106496: PUSH
106497: LD_INT 9
106499: PUSH
106500: EMPTY
106501: LIST
106502: LIST
106503: PUSH
106504: LD_INT 25
106506: PUSH
106507: LD_INT 8
106509: PUSH
106510: EMPTY
106511: LIST
106512: LIST
106513: PUSH
106514: EMPTY
106515: LIST
106516: LIST
106517: LIST
106518: LIST
106519: PUSH
106520: EMPTY
106521: LIST
106522: LIST
106523: PPUSH
106524: CALL_OW 69
106528: PUSH
106529: FOR_IN
106530: IFFALSE 106546
// begin SetClass ( i , 1 ) ;
106532: LD_VAR 0 1
106536: PPUSH
106537: LD_INT 1
106539: PPUSH
106540: CALL_OW 336
// end ;
106544: GO 106529
106546: POP
106547: POP
// end ;
106548: PPOPN 1
106550: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
106551: LD_EXP 153
106555: PUSH
106556: LD_EXP 157
106560: AND
106561: PUSH
106562: LD_OWVAR 65
106566: PUSH
106567: LD_INT 7
106569: LESS
106570: AND
106571: IFFALSE 106585
106573: GO 106575
106575: DISABLE
// begin enable ;
106576: ENABLE
// game_speed := 7 ;
106577: LD_ADDR_OWVAR 65
106581: PUSH
106582: LD_INT 7
106584: ST_TO_ADDR
// end ;
106585: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
106586: LD_EXP 153
106590: PUSH
106591: LD_EXP 160
106595: AND
106596: IFFALSE 106798
106598: GO 106600
106600: DISABLE
106601: LD_INT 0
106603: PPUSH
106604: PPUSH
106605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106606: LD_ADDR_VAR 0 3
106610: PUSH
106611: LD_INT 81
106613: PUSH
106614: LD_OWVAR 2
106618: PUSH
106619: EMPTY
106620: LIST
106621: LIST
106622: PUSH
106623: LD_INT 21
106625: PUSH
106626: LD_INT 1
106628: PUSH
106629: EMPTY
106630: LIST
106631: LIST
106632: PUSH
106633: EMPTY
106634: LIST
106635: LIST
106636: PPUSH
106637: CALL_OW 69
106641: ST_TO_ADDR
// if not tmp then
106642: LD_VAR 0 3
106646: NOT
106647: IFFALSE 106651
// exit ;
106649: GO 106798
// if tmp > 5 then
106651: LD_VAR 0 3
106655: PUSH
106656: LD_INT 5
106658: GREATER
106659: IFFALSE 106671
// k := 5 else
106661: LD_ADDR_VAR 0 2
106665: PUSH
106666: LD_INT 5
106668: ST_TO_ADDR
106669: GO 106681
// k := tmp ;
106671: LD_ADDR_VAR 0 2
106675: PUSH
106676: LD_VAR 0 3
106680: ST_TO_ADDR
// for i := 1 to k do
106681: LD_ADDR_VAR 0 1
106685: PUSH
106686: DOUBLE
106687: LD_INT 1
106689: DEC
106690: ST_TO_ADDR
106691: LD_VAR 0 2
106695: PUSH
106696: FOR_TO
106697: IFFALSE 106796
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
106699: LD_VAR 0 3
106703: PUSH
106704: LD_VAR 0 1
106708: ARRAY
106709: PPUSH
106710: LD_VAR 0 1
106714: PUSH
106715: LD_INT 4
106717: MOD
106718: PUSH
106719: LD_INT 1
106721: PLUS
106722: PPUSH
106723: CALL_OW 259
106727: PUSH
106728: LD_INT 10
106730: LESS
106731: IFFALSE 106794
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
106733: LD_VAR 0 3
106737: PUSH
106738: LD_VAR 0 1
106742: ARRAY
106743: PPUSH
106744: LD_VAR 0 1
106748: PUSH
106749: LD_INT 4
106751: MOD
106752: PUSH
106753: LD_INT 1
106755: PLUS
106756: PPUSH
106757: LD_VAR 0 3
106761: PUSH
106762: LD_VAR 0 1
106766: ARRAY
106767: PPUSH
106768: LD_VAR 0 1
106772: PUSH
106773: LD_INT 4
106775: MOD
106776: PUSH
106777: LD_INT 1
106779: PLUS
106780: PPUSH
106781: CALL_OW 259
106785: PUSH
106786: LD_INT 1
106788: PLUS
106789: PPUSH
106790: CALL_OW 237
106794: GO 106696
106796: POP
106797: POP
// end ;
106798: PPOPN 3
106800: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
106801: LD_EXP 153
106805: PUSH
106806: LD_EXP 161
106810: AND
106811: IFFALSE 106831
106813: GO 106815
106815: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
106816: LD_INT 4
106818: PPUSH
106819: LD_OWVAR 2
106823: PPUSH
106824: LD_INT 0
106826: PPUSH
106827: CALL_OW 324
106831: END
// every 0 0$1 trigger StreamModeActive and sShovel do
106832: LD_EXP 153
106836: PUSH
106837: LD_EXP 190
106841: AND
106842: IFFALSE 106862
106844: GO 106846
106846: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
106847: LD_INT 19
106849: PPUSH
106850: LD_OWVAR 2
106854: PPUSH
106855: LD_INT 0
106857: PPUSH
106858: CALL_OW 324
106862: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
106863: LD_EXP 153
106867: PUSH
106868: LD_EXP 162
106872: AND
106873: IFFALSE 106975
106875: GO 106877
106877: DISABLE
106878: LD_INT 0
106880: PPUSH
106881: PPUSH
// begin enable ;
106882: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
106883: LD_ADDR_VAR 0 2
106887: PUSH
106888: LD_INT 22
106890: PUSH
106891: LD_OWVAR 2
106895: PUSH
106896: EMPTY
106897: LIST
106898: LIST
106899: PUSH
106900: LD_INT 2
106902: PUSH
106903: LD_INT 34
106905: PUSH
106906: LD_INT 11
106908: PUSH
106909: EMPTY
106910: LIST
106911: LIST
106912: PUSH
106913: LD_INT 34
106915: PUSH
106916: LD_INT 30
106918: PUSH
106919: EMPTY
106920: LIST
106921: LIST
106922: PUSH
106923: EMPTY
106924: LIST
106925: LIST
106926: LIST
106927: PUSH
106928: EMPTY
106929: LIST
106930: LIST
106931: PPUSH
106932: CALL_OW 69
106936: ST_TO_ADDR
// if not tmp then
106937: LD_VAR 0 2
106941: NOT
106942: IFFALSE 106946
// exit ;
106944: GO 106975
// for i in tmp do
106946: LD_ADDR_VAR 0 1
106950: PUSH
106951: LD_VAR 0 2
106955: PUSH
106956: FOR_IN
106957: IFFALSE 106973
// begin SetLives ( i , 0 ) ;
106959: LD_VAR 0 1
106963: PPUSH
106964: LD_INT 0
106966: PPUSH
106967: CALL_OW 234
// end ;
106971: GO 106956
106973: POP
106974: POP
// end ;
106975: PPOPN 2
106977: END
// every 0 0$1 trigger StreamModeActive and sBunker do
106978: LD_EXP 153
106982: PUSH
106983: LD_EXP 163
106987: AND
106988: IFFALSE 107008
106990: GO 106992
106992: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
106993: LD_INT 32
106995: PPUSH
106996: LD_OWVAR 2
107000: PPUSH
107001: LD_INT 0
107003: PPUSH
107004: CALL_OW 324
107008: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
107009: LD_EXP 153
107013: PUSH
107014: LD_EXP 164
107018: AND
107019: IFFALSE 107200
107021: GO 107023
107023: DISABLE
107024: LD_INT 0
107026: PPUSH
107027: PPUSH
107028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
107029: LD_ADDR_VAR 0 2
107033: PUSH
107034: LD_INT 22
107036: PUSH
107037: LD_OWVAR 2
107041: PUSH
107042: EMPTY
107043: LIST
107044: LIST
107045: PUSH
107046: LD_INT 33
107048: PUSH
107049: LD_INT 3
107051: PUSH
107052: EMPTY
107053: LIST
107054: LIST
107055: PUSH
107056: EMPTY
107057: LIST
107058: LIST
107059: PPUSH
107060: CALL_OW 69
107064: ST_TO_ADDR
// if not tmp then
107065: LD_VAR 0 2
107069: NOT
107070: IFFALSE 107074
// exit ;
107072: GO 107200
// side := 0 ;
107074: LD_ADDR_VAR 0 3
107078: PUSH
107079: LD_INT 0
107081: ST_TO_ADDR
// for i := 1 to 8 do
107082: LD_ADDR_VAR 0 1
107086: PUSH
107087: DOUBLE
107088: LD_INT 1
107090: DEC
107091: ST_TO_ADDR
107092: LD_INT 8
107094: PUSH
107095: FOR_TO
107096: IFFALSE 107144
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
107098: LD_OWVAR 2
107102: PUSH
107103: LD_VAR 0 1
107107: NONEQUAL
107108: PUSH
107109: LD_OWVAR 2
107113: PPUSH
107114: LD_VAR 0 1
107118: PPUSH
107119: CALL_OW 81
107123: PUSH
107124: LD_INT 2
107126: EQUAL
107127: AND
107128: IFFALSE 107142
// begin side := i ;
107130: LD_ADDR_VAR 0 3
107134: PUSH
107135: LD_VAR 0 1
107139: ST_TO_ADDR
// break ;
107140: GO 107144
// end ;
107142: GO 107095
107144: POP
107145: POP
// if not side then
107146: LD_VAR 0 3
107150: NOT
107151: IFFALSE 107155
// exit ;
107153: GO 107200
// for i := 1 to tmp do
107155: LD_ADDR_VAR 0 1
107159: PUSH
107160: DOUBLE
107161: LD_INT 1
107163: DEC
107164: ST_TO_ADDR
107165: LD_VAR 0 2
107169: PUSH
107170: FOR_TO
107171: IFFALSE 107198
// if Prob ( 60 ) then
107173: LD_INT 60
107175: PPUSH
107176: CALL_OW 13
107180: IFFALSE 107196
// SetSide ( i , side ) ;
107182: LD_VAR 0 1
107186: PPUSH
107187: LD_VAR 0 3
107191: PPUSH
107192: CALL_OW 235
107196: GO 107170
107198: POP
107199: POP
// end ;
107200: PPOPN 3
107202: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
107203: LD_EXP 153
107207: PUSH
107208: LD_EXP 166
107212: AND
107213: IFFALSE 107332
107215: GO 107217
107217: DISABLE
107218: LD_INT 0
107220: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
107221: LD_ADDR_VAR 0 1
107225: PUSH
107226: LD_INT 22
107228: PUSH
107229: LD_OWVAR 2
107233: PUSH
107234: EMPTY
107235: LIST
107236: LIST
107237: PUSH
107238: LD_INT 21
107240: PUSH
107241: LD_INT 1
107243: PUSH
107244: EMPTY
107245: LIST
107246: LIST
107247: PUSH
107248: LD_INT 3
107250: PUSH
107251: LD_INT 23
107253: PUSH
107254: LD_INT 0
107256: PUSH
107257: EMPTY
107258: LIST
107259: LIST
107260: PUSH
107261: EMPTY
107262: LIST
107263: LIST
107264: PUSH
107265: EMPTY
107266: LIST
107267: LIST
107268: LIST
107269: PPUSH
107270: CALL_OW 69
107274: PUSH
107275: FOR_IN
107276: IFFALSE 107330
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
107278: LD_VAR 0 1
107282: PPUSH
107283: CALL_OW 257
107287: PUSH
107288: LD_INT 1
107290: PUSH
107291: LD_INT 2
107293: PUSH
107294: LD_INT 3
107296: PUSH
107297: LD_INT 4
107299: PUSH
107300: EMPTY
107301: LIST
107302: LIST
107303: LIST
107304: LIST
107305: IN
107306: IFFALSE 107328
// SetClass ( un , rand ( 1 , 4 ) ) ;
107308: LD_VAR 0 1
107312: PPUSH
107313: LD_INT 1
107315: PPUSH
107316: LD_INT 4
107318: PPUSH
107319: CALL_OW 12
107323: PPUSH
107324: CALL_OW 336
107328: GO 107275
107330: POP
107331: POP
// end ;
107332: PPOPN 1
107334: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
107335: LD_EXP 153
107339: PUSH
107340: LD_EXP 165
107344: AND
107345: IFFALSE 107424
107347: GO 107349
107349: DISABLE
107350: LD_INT 0
107352: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107353: LD_ADDR_VAR 0 1
107357: PUSH
107358: LD_INT 22
107360: PUSH
107361: LD_OWVAR 2
107365: PUSH
107366: EMPTY
107367: LIST
107368: LIST
107369: PUSH
107370: LD_INT 21
107372: PUSH
107373: LD_INT 3
107375: PUSH
107376: EMPTY
107377: LIST
107378: LIST
107379: PUSH
107380: EMPTY
107381: LIST
107382: LIST
107383: PPUSH
107384: CALL_OW 69
107388: ST_TO_ADDR
// if not tmp then
107389: LD_VAR 0 1
107393: NOT
107394: IFFALSE 107398
// exit ;
107396: GO 107424
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
107398: LD_VAR 0 1
107402: PUSH
107403: LD_INT 1
107405: PPUSH
107406: LD_VAR 0 1
107410: PPUSH
107411: CALL_OW 12
107415: ARRAY
107416: PPUSH
107417: LD_INT 100
107419: PPUSH
107420: CALL_OW 234
// end ;
107424: PPOPN 1
107426: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
107427: LD_EXP 153
107431: PUSH
107432: LD_EXP 167
107436: AND
107437: IFFALSE 107535
107439: GO 107441
107441: DISABLE
107442: LD_INT 0
107444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107445: LD_ADDR_VAR 0 1
107449: PUSH
107450: LD_INT 22
107452: PUSH
107453: LD_OWVAR 2
107457: PUSH
107458: EMPTY
107459: LIST
107460: LIST
107461: PUSH
107462: LD_INT 21
107464: PUSH
107465: LD_INT 1
107467: PUSH
107468: EMPTY
107469: LIST
107470: LIST
107471: PUSH
107472: EMPTY
107473: LIST
107474: LIST
107475: PPUSH
107476: CALL_OW 69
107480: ST_TO_ADDR
// if not tmp then
107481: LD_VAR 0 1
107485: NOT
107486: IFFALSE 107490
// exit ;
107488: GO 107535
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
107490: LD_VAR 0 1
107494: PUSH
107495: LD_INT 1
107497: PPUSH
107498: LD_VAR 0 1
107502: PPUSH
107503: CALL_OW 12
107507: ARRAY
107508: PPUSH
107509: LD_INT 1
107511: PPUSH
107512: LD_INT 4
107514: PPUSH
107515: CALL_OW 12
107519: PPUSH
107520: LD_INT 3000
107522: PPUSH
107523: LD_INT 9000
107525: PPUSH
107526: CALL_OW 12
107530: PPUSH
107531: CALL_OW 492
// end ;
107535: PPOPN 1
107537: END
// every 0 0$1 trigger StreamModeActive and sDepot do
107538: LD_EXP 153
107542: PUSH
107543: LD_EXP 168
107547: AND
107548: IFFALSE 107568
107550: GO 107552
107552: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
107553: LD_INT 1
107555: PPUSH
107556: LD_OWVAR 2
107560: PPUSH
107561: LD_INT 0
107563: PPUSH
107564: CALL_OW 324
107568: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
107569: LD_EXP 153
107573: PUSH
107574: LD_EXP 169
107578: AND
107579: IFFALSE 107662
107581: GO 107583
107583: DISABLE
107584: LD_INT 0
107586: PPUSH
107587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107588: LD_ADDR_VAR 0 2
107592: PUSH
107593: LD_INT 22
107595: PUSH
107596: LD_OWVAR 2
107600: PUSH
107601: EMPTY
107602: LIST
107603: LIST
107604: PUSH
107605: LD_INT 21
107607: PUSH
107608: LD_INT 3
107610: PUSH
107611: EMPTY
107612: LIST
107613: LIST
107614: PUSH
107615: EMPTY
107616: LIST
107617: LIST
107618: PPUSH
107619: CALL_OW 69
107623: ST_TO_ADDR
// if not tmp then
107624: LD_VAR 0 2
107628: NOT
107629: IFFALSE 107633
// exit ;
107631: GO 107662
// for i in tmp do
107633: LD_ADDR_VAR 0 1
107637: PUSH
107638: LD_VAR 0 2
107642: PUSH
107643: FOR_IN
107644: IFFALSE 107660
// SetBLevel ( i , 10 ) ;
107646: LD_VAR 0 1
107650: PPUSH
107651: LD_INT 10
107653: PPUSH
107654: CALL_OW 241
107658: GO 107643
107660: POP
107661: POP
// end ;
107662: PPOPN 2
107664: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
107665: LD_EXP 153
107669: PUSH
107670: LD_EXP 170
107674: AND
107675: IFFALSE 107786
107677: GO 107679
107679: DISABLE
107680: LD_INT 0
107682: PPUSH
107683: PPUSH
107684: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107685: LD_ADDR_VAR 0 3
107689: PUSH
107690: LD_INT 22
107692: PUSH
107693: LD_OWVAR 2
107697: PUSH
107698: EMPTY
107699: LIST
107700: LIST
107701: PUSH
107702: LD_INT 25
107704: PUSH
107705: LD_INT 1
107707: PUSH
107708: EMPTY
107709: LIST
107710: LIST
107711: PUSH
107712: EMPTY
107713: LIST
107714: LIST
107715: PPUSH
107716: CALL_OW 69
107720: ST_TO_ADDR
// if not tmp then
107721: LD_VAR 0 3
107725: NOT
107726: IFFALSE 107730
// exit ;
107728: GO 107786
// un := tmp [ rand ( 1 , tmp ) ] ;
107730: LD_ADDR_VAR 0 2
107734: PUSH
107735: LD_VAR 0 3
107739: PUSH
107740: LD_INT 1
107742: PPUSH
107743: LD_VAR 0 3
107747: PPUSH
107748: CALL_OW 12
107752: ARRAY
107753: ST_TO_ADDR
// if Crawls ( un ) then
107754: LD_VAR 0 2
107758: PPUSH
107759: CALL_OW 318
107763: IFFALSE 107774
// ComWalk ( un ) ;
107765: LD_VAR 0 2
107769: PPUSH
107770: CALL_OW 138
// SetClass ( un , class_sniper ) ;
107774: LD_VAR 0 2
107778: PPUSH
107779: LD_INT 5
107781: PPUSH
107782: CALL_OW 336
// end ;
107786: PPOPN 3
107788: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
107789: LD_EXP 153
107793: PUSH
107794: LD_EXP 171
107798: AND
107799: PUSH
107800: LD_OWVAR 67
107804: PUSH
107805: LD_INT 3
107807: LESS
107808: AND
107809: IFFALSE 107828
107811: GO 107813
107813: DISABLE
// Difficulty := Difficulty + 1 ;
107814: LD_ADDR_OWVAR 67
107818: PUSH
107819: LD_OWVAR 67
107823: PUSH
107824: LD_INT 1
107826: PLUS
107827: ST_TO_ADDR
107828: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
107829: LD_EXP 153
107833: PUSH
107834: LD_EXP 172
107838: AND
107839: IFFALSE 107942
107841: GO 107843
107843: DISABLE
107844: LD_INT 0
107846: PPUSH
// begin for i := 1 to 5 do
107847: LD_ADDR_VAR 0 1
107851: PUSH
107852: DOUBLE
107853: LD_INT 1
107855: DEC
107856: ST_TO_ADDR
107857: LD_INT 5
107859: PUSH
107860: FOR_TO
107861: IFFALSE 107940
// begin uc_nation := nation_nature ;
107863: LD_ADDR_OWVAR 21
107867: PUSH
107868: LD_INT 0
107870: ST_TO_ADDR
// uc_side := 0 ;
107871: LD_ADDR_OWVAR 20
107875: PUSH
107876: LD_INT 0
107878: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
107879: LD_ADDR_OWVAR 29
107883: PUSH
107884: LD_INT 12
107886: PUSH
107887: LD_INT 12
107889: PUSH
107890: EMPTY
107891: LIST
107892: LIST
107893: ST_TO_ADDR
// hc_agressivity := 20 ;
107894: LD_ADDR_OWVAR 35
107898: PUSH
107899: LD_INT 20
107901: ST_TO_ADDR
// hc_class := class_tiger ;
107902: LD_ADDR_OWVAR 28
107906: PUSH
107907: LD_INT 14
107909: ST_TO_ADDR
// hc_gallery :=  ;
107910: LD_ADDR_OWVAR 33
107914: PUSH
107915: LD_STRING 
107917: ST_TO_ADDR
// hc_name :=  ;
107918: LD_ADDR_OWVAR 26
107922: PUSH
107923: LD_STRING 
107925: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
107926: CALL_OW 44
107930: PPUSH
107931: LD_INT 0
107933: PPUSH
107934: CALL_OW 51
// end ;
107938: GO 107860
107940: POP
107941: POP
// end ;
107942: PPOPN 1
107944: END
// every 0 0$1 trigger StreamModeActive and sBomb do
107945: LD_EXP 153
107949: PUSH
107950: LD_EXP 173
107954: AND
107955: IFFALSE 107964
107957: GO 107959
107959: DISABLE
// StreamSibBomb ;
107960: CALL 107965 0 0
107964: END
// export function StreamSibBomb ; var i , x , y ; begin
107965: LD_INT 0
107967: PPUSH
107968: PPUSH
107969: PPUSH
107970: PPUSH
// result := false ;
107971: LD_ADDR_VAR 0 1
107975: PUSH
107976: LD_INT 0
107978: ST_TO_ADDR
// for i := 1 to 16 do
107979: LD_ADDR_VAR 0 2
107983: PUSH
107984: DOUBLE
107985: LD_INT 1
107987: DEC
107988: ST_TO_ADDR
107989: LD_INT 16
107991: PUSH
107992: FOR_TO
107993: IFFALSE 108192
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
107995: LD_ADDR_VAR 0 3
107999: PUSH
108000: LD_INT 10
108002: PUSH
108003: LD_INT 20
108005: PUSH
108006: LD_INT 30
108008: PUSH
108009: LD_INT 40
108011: PUSH
108012: LD_INT 50
108014: PUSH
108015: LD_INT 60
108017: PUSH
108018: LD_INT 70
108020: PUSH
108021: LD_INT 80
108023: PUSH
108024: LD_INT 90
108026: PUSH
108027: LD_INT 100
108029: PUSH
108030: LD_INT 110
108032: PUSH
108033: LD_INT 120
108035: PUSH
108036: LD_INT 130
108038: PUSH
108039: LD_INT 140
108041: PUSH
108042: LD_INT 150
108044: PUSH
108045: EMPTY
108046: LIST
108047: LIST
108048: LIST
108049: LIST
108050: LIST
108051: LIST
108052: LIST
108053: LIST
108054: LIST
108055: LIST
108056: LIST
108057: LIST
108058: LIST
108059: LIST
108060: LIST
108061: PUSH
108062: LD_INT 1
108064: PPUSH
108065: LD_INT 15
108067: PPUSH
108068: CALL_OW 12
108072: ARRAY
108073: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108074: LD_ADDR_VAR 0 4
108078: PUSH
108079: LD_INT 10
108081: PUSH
108082: LD_INT 20
108084: PUSH
108085: LD_INT 30
108087: PUSH
108088: LD_INT 40
108090: PUSH
108091: LD_INT 50
108093: PUSH
108094: LD_INT 60
108096: PUSH
108097: LD_INT 70
108099: PUSH
108100: LD_INT 80
108102: PUSH
108103: LD_INT 90
108105: PUSH
108106: LD_INT 100
108108: PUSH
108109: LD_INT 110
108111: PUSH
108112: LD_INT 120
108114: PUSH
108115: LD_INT 130
108117: PUSH
108118: LD_INT 140
108120: PUSH
108121: LD_INT 150
108123: PUSH
108124: EMPTY
108125: LIST
108126: LIST
108127: LIST
108128: LIST
108129: LIST
108130: LIST
108131: LIST
108132: LIST
108133: LIST
108134: LIST
108135: LIST
108136: LIST
108137: LIST
108138: LIST
108139: LIST
108140: PUSH
108141: LD_INT 1
108143: PPUSH
108144: LD_INT 15
108146: PPUSH
108147: CALL_OW 12
108151: ARRAY
108152: ST_TO_ADDR
// if ValidHex ( x , y ) then
108153: LD_VAR 0 3
108157: PPUSH
108158: LD_VAR 0 4
108162: PPUSH
108163: CALL_OW 488
108167: IFFALSE 108190
// begin result := [ x , y ] ;
108169: LD_ADDR_VAR 0 1
108173: PUSH
108174: LD_VAR 0 3
108178: PUSH
108179: LD_VAR 0 4
108183: PUSH
108184: EMPTY
108185: LIST
108186: LIST
108187: ST_TO_ADDR
// break ;
108188: GO 108192
// end ; end ;
108190: GO 107992
108192: POP
108193: POP
// if result then
108194: LD_VAR 0 1
108198: IFFALSE 108258
// begin ToLua ( playSibBomb() ) ;
108200: LD_STRING playSibBomb()
108202: PPUSH
108203: CALL_OW 559
// wait ( 0 0$14 ) ;
108207: LD_INT 490
108209: PPUSH
108210: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
108214: LD_VAR 0 1
108218: PUSH
108219: LD_INT 1
108221: ARRAY
108222: PPUSH
108223: LD_VAR 0 1
108227: PUSH
108228: LD_INT 2
108230: ARRAY
108231: PPUSH
108232: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
108236: LD_VAR 0 1
108240: PUSH
108241: LD_INT 1
108243: ARRAY
108244: PPUSH
108245: LD_VAR 0 1
108249: PUSH
108250: LD_INT 2
108252: ARRAY
108253: PPUSH
108254: CALL_OW 429
// end ; end ;
108258: LD_VAR 0 1
108262: RET
// every 0 0$1 trigger StreamModeActive and sReset do
108263: LD_EXP 153
108267: PUSH
108268: LD_EXP 175
108272: AND
108273: IFFALSE 108285
108275: GO 108277
108277: DISABLE
// YouLost (  ) ;
108278: LD_STRING 
108280: PPUSH
108281: CALL_OW 104
108285: END
// every 0 0$1 trigger StreamModeActive and sFog do
108286: LD_EXP 153
108290: PUSH
108291: LD_EXP 174
108295: AND
108296: IFFALSE 108310
108298: GO 108300
108300: DISABLE
// FogOff ( your_side ) ;
108301: LD_OWVAR 2
108305: PPUSH
108306: CALL_OW 344
108310: END
// every 0 0$1 trigger StreamModeActive and sSun do
108311: LD_EXP 153
108315: PUSH
108316: LD_EXP 176
108320: AND
108321: IFFALSE 108349
108323: GO 108325
108325: DISABLE
// begin solar_recharge_percent := 0 ;
108326: LD_ADDR_OWVAR 79
108330: PUSH
108331: LD_INT 0
108333: ST_TO_ADDR
// wait ( 5 5$00 ) ;
108334: LD_INT 10500
108336: PPUSH
108337: CALL_OW 67
// solar_recharge_percent := 100 ;
108341: LD_ADDR_OWVAR 79
108345: PUSH
108346: LD_INT 100
108348: ST_TO_ADDR
// end ;
108349: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
108350: LD_EXP 153
108354: PUSH
108355: LD_EXP 177
108359: AND
108360: IFFALSE 108599
108362: GO 108364
108364: DISABLE
108365: LD_INT 0
108367: PPUSH
108368: PPUSH
108369: PPUSH
// begin tmp := [ ] ;
108370: LD_ADDR_VAR 0 3
108374: PUSH
108375: EMPTY
108376: ST_TO_ADDR
// for i := 1 to 6 do
108377: LD_ADDR_VAR 0 1
108381: PUSH
108382: DOUBLE
108383: LD_INT 1
108385: DEC
108386: ST_TO_ADDR
108387: LD_INT 6
108389: PUSH
108390: FOR_TO
108391: IFFALSE 108496
// begin uc_nation := nation_nature ;
108393: LD_ADDR_OWVAR 21
108397: PUSH
108398: LD_INT 0
108400: ST_TO_ADDR
// uc_side := 0 ;
108401: LD_ADDR_OWVAR 20
108405: PUSH
108406: LD_INT 0
108408: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108409: LD_ADDR_OWVAR 29
108413: PUSH
108414: LD_INT 12
108416: PUSH
108417: LD_INT 12
108419: PUSH
108420: EMPTY
108421: LIST
108422: LIST
108423: ST_TO_ADDR
// hc_agressivity := 20 ;
108424: LD_ADDR_OWVAR 35
108428: PUSH
108429: LD_INT 20
108431: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
108432: LD_ADDR_OWVAR 28
108436: PUSH
108437: LD_INT 17
108439: ST_TO_ADDR
// hc_gallery :=  ;
108440: LD_ADDR_OWVAR 33
108444: PUSH
108445: LD_STRING 
108447: ST_TO_ADDR
// hc_name :=  ;
108448: LD_ADDR_OWVAR 26
108452: PUSH
108453: LD_STRING 
108455: ST_TO_ADDR
// un := CreateHuman ;
108456: LD_ADDR_VAR 0 2
108460: PUSH
108461: CALL_OW 44
108465: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
108466: LD_VAR 0 2
108470: PPUSH
108471: LD_INT 1
108473: PPUSH
108474: CALL_OW 51
// tmp := tmp ^ un ;
108478: LD_ADDR_VAR 0 3
108482: PUSH
108483: LD_VAR 0 3
108487: PUSH
108488: LD_VAR 0 2
108492: ADD
108493: ST_TO_ADDR
// end ;
108494: GO 108390
108496: POP
108497: POP
// repeat wait ( 0 0$1 ) ;
108498: LD_INT 35
108500: PPUSH
108501: CALL_OW 67
// for un in tmp do
108505: LD_ADDR_VAR 0 2
108509: PUSH
108510: LD_VAR 0 3
108514: PUSH
108515: FOR_IN
108516: IFFALSE 108590
// begin if IsDead ( un ) then
108518: LD_VAR 0 2
108522: PPUSH
108523: CALL_OW 301
108527: IFFALSE 108547
// begin tmp := tmp diff un ;
108529: LD_ADDR_VAR 0 3
108533: PUSH
108534: LD_VAR 0 3
108538: PUSH
108539: LD_VAR 0 2
108543: DIFF
108544: ST_TO_ADDR
// continue ;
108545: GO 108515
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
108547: LD_VAR 0 2
108551: PPUSH
108552: LD_INT 3
108554: PUSH
108555: LD_INT 22
108557: PUSH
108558: LD_INT 0
108560: PUSH
108561: EMPTY
108562: LIST
108563: LIST
108564: PUSH
108565: EMPTY
108566: LIST
108567: LIST
108568: PPUSH
108569: CALL_OW 69
108573: PPUSH
108574: LD_VAR 0 2
108578: PPUSH
108579: CALL_OW 74
108583: PPUSH
108584: CALL_OW 115
// end ;
108588: GO 108515
108590: POP
108591: POP
// until not tmp ;
108592: LD_VAR 0 3
108596: NOT
108597: IFFALSE 108498
// end ;
108599: PPOPN 3
108601: END
// every 0 0$1 trigger StreamModeActive and sTroll do
108602: LD_EXP 153
108606: PUSH
108607: LD_EXP 178
108611: AND
108612: IFFALSE 108666
108614: GO 108616
108616: DISABLE
// begin ToLua ( displayTroll(); ) ;
108617: LD_STRING displayTroll();
108619: PPUSH
108620: CALL_OW 559
// wait ( 3 3$00 ) ;
108624: LD_INT 6300
108626: PPUSH
108627: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108631: LD_STRING hideTroll();
108633: PPUSH
108634: CALL_OW 559
// wait ( 1 1$00 ) ;
108638: LD_INT 2100
108640: PPUSH
108641: CALL_OW 67
// ToLua ( displayTroll(); ) ;
108645: LD_STRING displayTroll();
108647: PPUSH
108648: CALL_OW 559
// wait ( 1 1$00 ) ;
108652: LD_INT 2100
108654: PPUSH
108655: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108659: LD_STRING hideTroll();
108661: PPUSH
108662: CALL_OW 559
// end ;
108666: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
108667: LD_EXP 153
108671: PUSH
108672: LD_EXP 179
108676: AND
108677: IFFALSE 108740
108679: GO 108681
108681: DISABLE
108682: LD_INT 0
108684: PPUSH
// begin p := 0 ;
108685: LD_ADDR_VAR 0 1
108689: PUSH
108690: LD_INT 0
108692: ST_TO_ADDR
// repeat game_speed := 1 ;
108693: LD_ADDR_OWVAR 65
108697: PUSH
108698: LD_INT 1
108700: ST_TO_ADDR
// wait ( 0 0$1 ) ;
108701: LD_INT 35
108703: PPUSH
108704: CALL_OW 67
// p := p + 1 ;
108708: LD_ADDR_VAR 0 1
108712: PUSH
108713: LD_VAR 0 1
108717: PUSH
108718: LD_INT 1
108720: PLUS
108721: ST_TO_ADDR
// until p >= 60 ;
108722: LD_VAR 0 1
108726: PUSH
108727: LD_INT 60
108729: GREATEREQUAL
108730: IFFALSE 108693
// game_speed := 4 ;
108732: LD_ADDR_OWVAR 65
108736: PUSH
108737: LD_INT 4
108739: ST_TO_ADDR
// end ;
108740: PPOPN 1
108742: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
108743: LD_EXP 153
108747: PUSH
108748: LD_EXP 180
108752: AND
108753: IFFALSE 108899
108755: GO 108757
108757: DISABLE
108758: LD_INT 0
108760: PPUSH
108761: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108762: LD_ADDR_VAR 0 1
108766: PUSH
108767: LD_INT 22
108769: PUSH
108770: LD_OWVAR 2
108774: PUSH
108775: EMPTY
108776: LIST
108777: LIST
108778: PUSH
108779: LD_INT 2
108781: PUSH
108782: LD_INT 30
108784: PUSH
108785: LD_INT 0
108787: PUSH
108788: EMPTY
108789: LIST
108790: LIST
108791: PUSH
108792: LD_INT 30
108794: PUSH
108795: LD_INT 1
108797: PUSH
108798: EMPTY
108799: LIST
108800: LIST
108801: PUSH
108802: EMPTY
108803: LIST
108804: LIST
108805: LIST
108806: PUSH
108807: EMPTY
108808: LIST
108809: LIST
108810: PPUSH
108811: CALL_OW 69
108815: ST_TO_ADDR
// if not depot then
108816: LD_VAR 0 1
108820: NOT
108821: IFFALSE 108825
// exit ;
108823: GO 108899
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
108825: LD_ADDR_VAR 0 2
108829: PUSH
108830: LD_VAR 0 1
108834: PUSH
108835: LD_INT 1
108837: PPUSH
108838: LD_VAR 0 1
108842: PPUSH
108843: CALL_OW 12
108847: ARRAY
108848: PPUSH
108849: CALL_OW 274
108853: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
108854: LD_VAR 0 2
108858: PPUSH
108859: LD_INT 1
108861: PPUSH
108862: LD_INT 0
108864: PPUSH
108865: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
108869: LD_VAR 0 2
108873: PPUSH
108874: LD_INT 2
108876: PPUSH
108877: LD_INT 0
108879: PPUSH
108880: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
108884: LD_VAR 0 2
108888: PPUSH
108889: LD_INT 3
108891: PPUSH
108892: LD_INT 0
108894: PPUSH
108895: CALL_OW 277
// end ;
108899: PPOPN 2
108901: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
108902: LD_EXP 153
108906: PUSH
108907: LD_EXP 181
108911: AND
108912: IFFALSE 109009
108914: GO 108916
108916: DISABLE
108917: LD_INT 0
108919: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108920: LD_ADDR_VAR 0 1
108924: PUSH
108925: LD_INT 22
108927: PUSH
108928: LD_OWVAR 2
108932: PUSH
108933: EMPTY
108934: LIST
108935: LIST
108936: PUSH
108937: LD_INT 21
108939: PUSH
108940: LD_INT 1
108942: PUSH
108943: EMPTY
108944: LIST
108945: LIST
108946: PUSH
108947: LD_INT 3
108949: PUSH
108950: LD_INT 23
108952: PUSH
108953: LD_INT 0
108955: PUSH
108956: EMPTY
108957: LIST
108958: LIST
108959: PUSH
108960: EMPTY
108961: LIST
108962: LIST
108963: PUSH
108964: EMPTY
108965: LIST
108966: LIST
108967: LIST
108968: PPUSH
108969: CALL_OW 69
108973: ST_TO_ADDR
// if not tmp then
108974: LD_VAR 0 1
108978: NOT
108979: IFFALSE 108983
// exit ;
108981: GO 109009
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
108983: LD_VAR 0 1
108987: PUSH
108988: LD_INT 1
108990: PPUSH
108991: LD_VAR 0 1
108995: PPUSH
108996: CALL_OW 12
109000: ARRAY
109001: PPUSH
109002: LD_INT 200
109004: PPUSH
109005: CALL_OW 234
// end ;
109009: PPOPN 1
109011: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
109012: LD_EXP 153
109016: PUSH
109017: LD_EXP 182
109021: AND
109022: IFFALSE 109101
109024: GO 109026
109026: DISABLE
109027: LD_INT 0
109029: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
109030: LD_ADDR_VAR 0 1
109034: PUSH
109035: LD_INT 22
109037: PUSH
109038: LD_OWVAR 2
109042: PUSH
109043: EMPTY
109044: LIST
109045: LIST
109046: PUSH
109047: LD_INT 21
109049: PUSH
109050: LD_INT 2
109052: PUSH
109053: EMPTY
109054: LIST
109055: LIST
109056: PUSH
109057: EMPTY
109058: LIST
109059: LIST
109060: PPUSH
109061: CALL_OW 69
109065: ST_TO_ADDR
// if not tmp then
109066: LD_VAR 0 1
109070: NOT
109071: IFFALSE 109075
// exit ;
109073: GO 109101
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
109075: LD_VAR 0 1
109079: PUSH
109080: LD_INT 1
109082: PPUSH
109083: LD_VAR 0 1
109087: PPUSH
109088: CALL_OW 12
109092: ARRAY
109093: PPUSH
109094: LD_INT 60
109096: PPUSH
109097: CALL_OW 234
// end ;
109101: PPOPN 1
109103: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
109104: LD_EXP 153
109108: PUSH
109109: LD_EXP 183
109113: AND
109114: IFFALSE 109213
109116: GO 109118
109118: DISABLE
109119: LD_INT 0
109121: PPUSH
109122: PPUSH
// begin enable ;
109123: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
109124: LD_ADDR_VAR 0 1
109128: PUSH
109129: LD_INT 22
109131: PUSH
109132: LD_OWVAR 2
109136: PUSH
109137: EMPTY
109138: LIST
109139: LIST
109140: PUSH
109141: LD_INT 61
109143: PUSH
109144: EMPTY
109145: LIST
109146: PUSH
109147: LD_INT 33
109149: PUSH
109150: LD_INT 2
109152: PUSH
109153: EMPTY
109154: LIST
109155: LIST
109156: PUSH
109157: EMPTY
109158: LIST
109159: LIST
109160: LIST
109161: PPUSH
109162: CALL_OW 69
109166: ST_TO_ADDR
// if not tmp then
109167: LD_VAR 0 1
109171: NOT
109172: IFFALSE 109176
// exit ;
109174: GO 109213
// for i in tmp do
109176: LD_ADDR_VAR 0 2
109180: PUSH
109181: LD_VAR 0 1
109185: PUSH
109186: FOR_IN
109187: IFFALSE 109211
// if IsControledBy ( i ) then
109189: LD_VAR 0 2
109193: PPUSH
109194: CALL_OW 312
109198: IFFALSE 109209
// ComUnlink ( i ) ;
109200: LD_VAR 0 2
109204: PPUSH
109205: CALL_OW 136
109209: GO 109186
109211: POP
109212: POP
// end ;
109213: PPOPN 2
109215: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
109216: LD_EXP 153
109220: PUSH
109221: LD_EXP 184
109225: AND
109226: IFFALSE 109366
109228: GO 109230
109230: DISABLE
109231: LD_INT 0
109233: PPUSH
109234: PPUSH
// begin ToLua ( displayPowell(); ) ;
109235: LD_STRING displayPowell();
109237: PPUSH
109238: CALL_OW 559
// uc_side := 0 ;
109242: LD_ADDR_OWVAR 20
109246: PUSH
109247: LD_INT 0
109249: ST_TO_ADDR
// uc_nation := 2 ;
109250: LD_ADDR_OWVAR 21
109254: PUSH
109255: LD_INT 2
109257: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
109258: LD_ADDR_OWVAR 37
109262: PUSH
109263: LD_INT 14
109265: ST_TO_ADDR
// vc_engine := engine_siberite ;
109266: LD_ADDR_OWVAR 39
109270: PUSH
109271: LD_INT 3
109273: ST_TO_ADDR
// vc_control := control_apeman ;
109274: LD_ADDR_OWVAR 38
109278: PUSH
109279: LD_INT 5
109281: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
109282: LD_ADDR_OWVAR 40
109286: PUSH
109287: LD_INT 29
109289: ST_TO_ADDR
// un := CreateVehicle ;
109290: LD_ADDR_VAR 0 2
109294: PUSH
109295: CALL_OW 45
109299: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109300: LD_VAR 0 2
109304: PPUSH
109305: LD_INT 1
109307: PPUSH
109308: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
109312: LD_INT 35
109314: PPUSH
109315: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
109319: LD_VAR 0 2
109323: PPUSH
109324: LD_INT 22
109326: PUSH
109327: LD_OWVAR 2
109331: PUSH
109332: EMPTY
109333: LIST
109334: LIST
109335: PPUSH
109336: CALL_OW 69
109340: PPUSH
109341: LD_VAR 0 2
109345: PPUSH
109346: CALL_OW 74
109350: PPUSH
109351: CALL_OW 115
// until IsDead ( un ) ;
109355: LD_VAR 0 2
109359: PPUSH
109360: CALL_OW 301
109364: IFFALSE 109312
// end ;
109366: PPOPN 2
109368: END
// every 0 0$1 trigger StreamModeActive and sStu do
109369: LD_EXP 153
109373: PUSH
109374: LD_EXP 192
109378: AND
109379: IFFALSE 109395
109381: GO 109383
109383: DISABLE
// begin ToLua ( displayStucuk(); ) ;
109384: LD_STRING displayStucuk();
109386: PPUSH
109387: CALL_OW 559
// ResetFog ;
109391: CALL_OW 335
// end ;
109395: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
109396: LD_EXP 153
109400: PUSH
109401: LD_EXP 185
109405: AND
109406: IFFALSE 109547
109408: GO 109410
109410: DISABLE
109411: LD_INT 0
109413: PPUSH
109414: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109415: LD_ADDR_VAR 0 2
109419: PUSH
109420: LD_INT 22
109422: PUSH
109423: LD_OWVAR 2
109427: PUSH
109428: EMPTY
109429: LIST
109430: LIST
109431: PUSH
109432: LD_INT 21
109434: PUSH
109435: LD_INT 1
109437: PUSH
109438: EMPTY
109439: LIST
109440: LIST
109441: PUSH
109442: EMPTY
109443: LIST
109444: LIST
109445: PPUSH
109446: CALL_OW 69
109450: ST_TO_ADDR
// if not tmp then
109451: LD_VAR 0 2
109455: NOT
109456: IFFALSE 109460
// exit ;
109458: GO 109547
// un := tmp [ rand ( 1 , tmp ) ] ;
109460: LD_ADDR_VAR 0 1
109464: PUSH
109465: LD_VAR 0 2
109469: PUSH
109470: LD_INT 1
109472: PPUSH
109473: LD_VAR 0 2
109477: PPUSH
109478: CALL_OW 12
109482: ARRAY
109483: ST_TO_ADDR
// SetSide ( un , 0 ) ;
109484: LD_VAR 0 1
109488: PPUSH
109489: LD_INT 0
109491: PPUSH
109492: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
109496: LD_VAR 0 1
109500: PPUSH
109501: LD_OWVAR 3
109505: PUSH
109506: LD_VAR 0 1
109510: DIFF
109511: PPUSH
109512: LD_VAR 0 1
109516: PPUSH
109517: CALL_OW 74
109521: PPUSH
109522: CALL_OW 115
// wait ( 0 0$20 ) ;
109526: LD_INT 700
109528: PPUSH
109529: CALL_OW 67
// SetSide ( un , your_side ) ;
109533: LD_VAR 0 1
109537: PPUSH
109538: LD_OWVAR 2
109542: PPUSH
109543: CALL_OW 235
// end ;
109547: PPOPN 2
109549: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
109550: LD_EXP 153
109554: PUSH
109555: LD_EXP 186
109559: AND
109560: IFFALSE 109666
109562: GO 109564
109564: DISABLE
109565: LD_INT 0
109567: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109568: LD_ADDR_VAR 0 1
109572: PUSH
109573: LD_INT 22
109575: PUSH
109576: LD_OWVAR 2
109580: PUSH
109581: EMPTY
109582: LIST
109583: LIST
109584: PUSH
109585: LD_INT 2
109587: PUSH
109588: LD_INT 30
109590: PUSH
109591: LD_INT 0
109593: PUSH
109594: EMPTY
109595: LIST
109596: LIST
109597: PUSH
109598: LD_INT 30
109600: PUSH
109601: LD_INT 1
109603: PUSH
109604: EMPTY
109605: LIST
109606: LIST
109607: PUSH
109608: EMPTY
109609: LIST
109610: LIST
109611: LIST
109612: PUSH
109613: EMPTY
109614: LIST
109615: LIST
109616: PPUSH
109617: CALL_OW 69
109621: ST_TO_ADDR
// if not depot then
109622: LD_VAR 0 1
109626: NOT
109627: IFFALSE 109631
// exit ;
109629: GO 109666
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
109631: LD_VAR 0 1
109635: PUSH
109636: LD_INT 1
109638: ARRAY
109639: PPUSH
109640: CALL_OW 250
109644: PPUSH
109645: LD_VAR 0 1
109649: PUSH
109650: LD_INT 1
109652: ARRAY
109653: PPUSH
109654: CALL_OW 251
109658: PPUSH
109659: LD_INT 70
109661: PPUSH
109662: CALL_OW 495
// end ;
109666: PPOPN 1
109668: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
109669: LD_EXP 153
109673: PUSH
109674: LD_EXP 187
109678: AND
109679: IFFALSE 109890
109681: GO 109683
109683: DISABLE
109684: LD_INT 0
109686: PPUSH
109687: PPUSH
109688: PPUSH
109689: PPUSH
109690: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109691: LD_ADDR_VAR 0 5
109695: PUSH
109696: LD_INT 22
109698: PUSH
109699: LD_OWVAR 2
109703: PUSH
109704: EMPTY
109705: LIST
109706: LIST
109707: PUSH
109708: LD_INT 21
109710: PUSH
109711: LD_INT 1
109713: PUSH
109714: EMPTY
109715: LIST
109716: LIST
109717: PUSH
109718: EMPTY
109719: LIST
109720: LIST
109721: PPUSH
109722: CALL_OW 69
109726: ST_TO_ADDR
// if not tmp then
109727: LD_VAR 0 5
109731: NOT
109732: IFFALSE 109736
// exit ;
109734: GO 109890
// for i in tmp do
109736: LD_ADDR_VAR 0 1
109740: PUSH
109741: LD_VAR 0 5
109745: PUSH
109746: FOR_IN
109747: IFFALSE 109888
// begin d := rand ( 0 , 5 ) ;
109749: LD_ADDR_VAR 0 4
109753: PUSH
109754: LD_INT 0
109756: PPUSH
109757: LD_INT 5
109759: PPUSH
109760: CALL_OW 12
109764: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
109765: LD_ADDR_VAR 0 2
109769: PUSH
109770: LD_VAR 0 1
109774: PPUSH
109775: CALL_OW 250
109779: PPUSH
109780: LD_VAR 0 4
109784: PPUSH
109785: LD_INT 3
109787: PPUSH
109788: LD_INT 12
109790: PPUSH
109791: CALL_OW 12
109795: PPUSH
109796: CALL_OW 272
109800: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
109801: LD_ADDR_VAR 0 3
109805: PUSH
109806: LD_VAR 0 1
109810: PPUSH
109811: CALL_OW 251
109815: PPUSH
109816: LD_VAR 0 4
109820: PPUSH
109821: LD_INT 3
109823: PPUSH
109824: LD_INT 12
109826: PPUSH
109827: CALL_OW 12
109831: PPUSH
109832: CALL_OW 273
109836: ST_TO_ADDR
// if ValidHex ( x , y ) then
109837: LD_VAR 0 2
109841: PPUSH
109842: LD_VAR 0 3
109846: PPUSH
109847: CALL_OW 488
109851: IFFALSE 109886
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
109853: LD_VAR 0 1
109857: PPUSH
109858: LD_VAR 0 2
109862: PPUSH
109863: LD_VAR 0 3
109867: PPUSH
109868: LD_INT 3
109870: PPUSH
109871: LD_INT 6
109873: PPUSH
109874: CALL_OW 12
109878: PPUSH
109879: LD_INT 1
109881: PPUSH
109882: CALL_OW 483
// end ;
109886: GO 109746
109888: POP
109889: POP
// end ;
109890: PPOPN 5
109892: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
109893: LD_EXP 153
109897: PUSH
109898: LD_EXP 188
109902: AND
109903: IFFALSE 109997
109905: GO 109907
109907: DISABLE
109908: LD_INT 0
109910: PPUSH
109911: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
109912: LD_ADDR_VAR 0 2
109916: PUSH
109917: LD_INT 22
109919: PUSH
109920: LD_OWVAR 2
109924: PUSH
109925: EMPTY
109926: LIST
109927: LIST
109928: PUSH
109929: LD_INT 32
109931: PUSH
109932: LD_INT 1
109934: PUSH
109935: EMPTY
109936: LIST
109937: LIST
109938: PUSH
109939: LD_INT 21
109941: PUSH
109942: LD_INT 2
109944: PUSH
109945: EMPTY
109946: LIST
109947: LIST
109948: PUSH
109949: EMPTY
109950: LIST
109951: LIST
109952: LIST
109953: PPUSH
109954: CALL_OW 69
109958: ST_TO_ADDR
// if not tmp then
109959: LD_VAR 0 2
109963: NOT
109964: IFFALSE 109968
// exit ;
109966: GO 109997
// for i in tmp do
109968: LD_ADDR_VAR 0 1
109972: PUSH
109973: LD_VAR 0 2
109977: PUSH
109978: FOR_IN
109979: IFFALSE 109995
// SetFuel ( i , 0 ) ;
109981: LD_VAR 0 1
109985: PPUSH
109986: LD_INT 0
109988: PPUSH
109989: CALL_OW 240
109993: GO 109978
109995: POP
109996: POP
// end ;
109997: PPOPN 2
109999: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
110000: LD_EXP 153
110004: PUSH
110005: LD_EXP 189
110009: AND
110010: IFFALSE 110076
110012: GO 110014
110014: DISABLE
110015: LD_INT 0
110017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
110018: LD_ADDR_VAR 0 1
110022: PUSH
110023: LD_INT 22
110025: PUSH
110026: LD_OWVAR 2
110030: PUSH
110031: EMPTY
110032: LIST
110033: LIST
110034: PUSH
110035: LD_INT 30
110037: PUSH
110038: LD_INT 29
110040: PUSH
110041: EMPTY
110042: LIST
110043: LIST
110044: PUSH
110045: EMPTY
110046: LIST
110047: LIST
110048: PPUSH
110049: CALL_OW 69
110053: ST_TO_ADDR
// if not tmp then
110054: LD_VAR 0 1
110058: NOT
110059: IFFALSE 110063
// exit ;
110061: GO 110076
// DestroyUnit ( tmp [ 1 ] ) ;
110063: LD_VAR 0 1
110067: PUSH
110068: LD_INT 1
110070: ARRAY
110071: PPUSH
110072: CALL_OW 65
// end ;
110076: PPOPN 1
110078: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
110079: LD_EXP 153
110083: PUSH
110084: LD_EXP 191
110088: AND
110089: IFFALSE 110218
110091: GO 110093
110093: DISABLE
110094: LD_INT 0
110096: PPUSH
// begin uc_side := 0 ;
110097: LD_ADDR_OWVAR 20
110101: PUSH
110102: LD_INT 0
110104: ST_TO_ADDR
// uc_nation := nation_arabian ;
110105: LD_ADDR_OWVAR 21
110109: PUSH
110110: LD_INT 2
110112: ST_TO_ADDR
// hc_gallery :=  ;
110113: LD_ADDR_OWVAR 33
110117: PUSH
110118: LD_STRING 
110120: ST_TO_ADDR
// hc_name :=  ;
110121: LD_ADDR_OWVAR 26
110125: PUSH
110126: LD_STRING 
110128: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
110129: LD_INT 1
110131: PPUSH
110132: LD_INT 11
110134: PPUSH
110135: LD_INT 10
110137: PPUSH
110138: CALL_OW 380
// un := CreateHuman ;
110142: LD_ADDR_VAR 0 1
110146: PUSH
110147: CALL_OW 44
110151: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110152: LD_VAR 0 1
110156: PPUSH
110157: LD_INT 1
110159: PPUSH
110160: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110164: LD_INT 35
110166: PPUSH
110167: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110171: LD_VAR 0 1
110175: PPUSH
110176: LD_INT 22
110178: PUSH
110179: LD_OWVAR 2
110183: PUSH
110184: EMPTY
110185: LIST
110186: LIST
110187: PPUSH
110188: CALL_OW 69
110192: PPUSH
110193: LD_VAR 0 1
110197: PPUSH
110198: CALL_OW 74
110202: PPUSH
110203: CALL_OW 115
// until IsDead ( un ) ;
110207: LD_VAR 0 1
110211: PPUSH
110212: CALL_OW 301
110216: IFFALSE 110164
// end ;
110218: PPOPN 1
110220: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
110221: LD_EXP 153
110225: PUSH
110226: LD_EXP 193
110230: AND
110231: IFFALSE 110243
110233: GO 110235
110235: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
110236: LD_STRING earthquake(getX(game), 0, 32)
110238: PPUSH
110239: CALL_OW 559
110243: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
110244: LD_EXP 153
110248: PUSH
110249: LD_EXP 194
110253: AND
110254: IFFALSE 110345
110256: GO 110258
110258: DISABLE
110259: LD_INT 0
110261: PPUSH
// begin enable ;
110262: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
110263: LD_ADDR_VAR 0 1
110267: PUSH
110268: LD_INT 22
110270: PUSH
110271: LD_OWVAR 2
110275: PUSH
110276: EMPTY
110277: LIST
110278: LIST
110279: PUSH
110280: LD_INT 21
110282: PUSH
110283: LD_INT 2
110285: PUSH
110286: EMPTY
110287: LIST
110288: LIST
110289: PUSH
110290: LD_INT 33
110292: PUSH
110293: LD_INT 3
110295: PUSH
110296: EMPTY
110297: LIST
110298: LIST
110299: PUSH
110300: EMPTY
110301: LIST
110302: LIST
110303: LIST
110304: PPUSH
110305: CALL_OW 69
110309: ST_TO_ADDR
// if not tmp then
110310: LD_VAR 0 1
110314: NOT
110315: IFFALSE 110319
// exit ;
110317: GO 110345
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
110319: LD_VAR 0 1
110323: PUSH
110324: LD_INT 1
110326: PPUSH
110327: LD_VAR 0 1
110331: PPUSH
110332: CALL_OW 12
110336: ARRAY
110337: PPUSH
110338: LD_INT 1
110340: PPUSH
110341: CALL_OW 234
// end ;
110345: PPOPN 1
110347: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
110348: LD_EXP 153
110352: PUSH
110353: LD_EXP 195
110357: AND
110358: IFFALSE 110499
110360: GO 110362
110362: DISABLE
110363: LD_INT 0
110365: PPUSH
110366: PPUSH
110367: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110368: LD_ADDR_VAR 0 3
110372: PUSH
110373: LD_INT 22
110375: PUSH
110376: LD_OWVAR 2
110380: PUSH
110381: EMPTY
110382: LIST
110383: LIST
110384: PUSH
110385: LD_INT 25
110387: PUSH
110388: LD_INT 1
110390: PUSH
110391: EMPTY
110392: LIST
110393: LIST
110394: PUSH
110395: EMPTY
110396: LIST
110397: LIST
110398: PPUSH
110399: CALL_OW 69
110403: ST_TO_ADDR
// if not tmp then
110404: LD_VAR 0 3
110408: NOT
110409: IFFALSE 110413
// exit ;
110411: GO 110499
// un := tmp [ rand ( 1 , tmp ) ] ;
110413: LD_ADDR_VAR 0 2
110417: PUSH
110418: LD_VAR 0 3
110422: PUSH
110423: LD_INT 1
110425: PPUSH
110426: LD_VAR 0 3
110430: PPUSH
110431: CALL_OW 12
110435: ARRAY
110436: ST_TO_ADDR
// if Crawls ( un ) then
110437: LD_VAR 0 2
110441: PPUSH
110442: CALL_OW 318
110446: IFFALSE 110457
// ComWalk ( un ) ;
110448: LD_VAR 0 2
110452: PPUSH
110453: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
110457: LD_VAR 0 2
110461: PPUSH
110462: LD_INT 9
110464: PPUSH
110465: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
110469: LD_INT 28
110471: PPUSH
110472: LD_OWVAR 2
110476: PPUSH
110477: LD_INT 2
110479: PPUSH
110480: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
110484: LD_INT 29
110486: PPUSH
110487: LD_OWVAR 2
110491: PPUSH
110492: LD_INT 2
110494: PPUSH
110495: CALL_OW 322
// end ;
110499: PPOPN 3
110501: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
110502: LD_EXP 153
110506: PUSH
110507: LD_EXP 196
110511: AND
110512: IFFALSE 110623
110514: GO 110516
110516: DISABLE
110517: LD_INT 0
110519: PPUSH
110520: PPUSH
110521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110522: LD_ADDR_VAR 0 3
110526: PUSH
110527: LD_INT 22
110529: PUSH
110530: LD_OWVAR 2
110534: PUSH
110535: EMPTY
110536: LIST
110537: LIST
110538: PUSH
110539: LD_INT 25
110541: PUSH
110542: LD_INT 1
110544: PUSH
110545: EMPTY
110546: LIST
110547: LIST
110548: PUSH
110549: EMPTY
110550: LIST
110551: LIST
110552: PPUSH
110553: CALL_OW 69
110557: ST_TO_ADDR
// if not tmp then
110558: LD_VAR 0 3
110562: NOT
110563: IFFALSE 110567
// exit ;
110565: GO 110623
// un := tmp [ rand ( 1 , tmp ) ] ;
110567: LD_ADDR_VAR 0 2
110571: PUSH
110572: LD_VAR 0 3
110576: PUSH
110577: LD_INT 1
110579: PPUSH
110580: LD_VAR 0 3
110584: PPUSH
110585: CALL_OW 12
110589: ARRAY
110590: ST_TO_ADDR
// if Crawls ( un ) then
110591: LD_VAR 0 2
110595: PPUSH
110596: CALL_OW 318
110600: IFFALSE 110611
// ComWalk ( un ) ;
110602: LD_VAR 0 2
110606: PPUSH
110607: CALL_OW 138
// SetClass ( un , class_mortar ) ;
110611: LD_VAR 0 2
110615: PPUSH
110616: LD_INT 8
110618: PPUSH
110619: CALL_OW 336
// end ;
110623: PPOPN 3
110625: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
110626: LD_EXP 153
110630: PUSH
110631: LD_EXP 197
110635: AND
110636: IFFALSE 110780
110638: GO 110640
110640: DISABLE
110641: LD_INT 0
110643: PPUSH
110644: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
110645: LD_ADDR_VAR 0 2
110649: PUSH
110650: LD_INT 22
110652: PUSH
110653: LD_OWVAR 2
110657: PUSH
110658: EMPTY
110659: LIST
110660: LIST
110661: PUSH
110662: LD_INT 21
110664: PUSH
110665: LD_INT 2
110667: PUSH
110668: EMPTY
110669: LIST
110670: LIST
110671: PUSH
110672: LD_INT 2
110674: PUSH
110675: LD_INT 34
110677: PUSH
110678: LD_INT 12
110680: PUSH
110681: EMPTY
110682: LIST
110683: LIST
110684: PUSH
110685: LD_INT 34
110687: PUSH
110688: LD_INT 51
110690: PUSH
110691: EMPTY
110692: LIST
110693: LIST
110694: PUSH
110695: LD_INT 34
110697: PUSH
110698: LD_INT 32
110700: PUSH
110701: EMPTY
110702: LIST
110703: LIST
110704: PUSH
110705: EMPTY
110706: LIST
110707: LIST
110708: LIST
110709: LIST
110710: PUSH
110711: EMPTY
110712: LIST
110713: LIST
110714: LIST
110715: PPUSH
110716: CALL_OW 69
110720: ST_TO_ADDR
// if not tmp then
110721: LD_VAR 0 2
110725: NOT
110726: IFFALSE 110730
// exit ;
110728: GO 110780
// for i in tmp do
110730: LD_ADDR_VAR 0 1
110734: PUSH
110735: LD_VAR 0 2
110739: PUSH
110740: FOR_IN
110741: IFFALSE 110778
// if GetCargo ( i , mat_artifact ) = 0 then
110743: LD_VAR 0 1
110747: PPUSH
110748: LD_INT 4
110750: PPUSH
110751: CALL_OW 289
110755: PUSH
110756: LD_INT 0
110758: EQUAL
110759: IFFALSE 110776
// SetCargo ( i , mat_siberit , 100 ) ;
110761: LD_VAR 0 1
110765: PPUSH
110766: LD_INT 3
110768: PPUSH
110769: LD_INT 100
110771: PPUSH
110772: CALL_OW 290
110776: GO 110740
110778: POP
110779: POP
// end ;
110780: PPOPN 2
110782: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
110783: LD_EXP 153
110787: PUSH
110788: LD_EXP 198
110792: AND
110793: IFFALSE 110946
110795: GO 110797
110797: DISABLE
110798: LD_INT 0
110800: PPUSH
110801: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110802: LD_ADDR_VAR 0 2
110806: PUSH
110807: LD_INT 22
110809: PUSH
110810: LD_OWVAR 2
110814: PUSH
110815: EMPTY
110816: LIST
110817: LIST
110818: PPUSH
110819: CALL_OW 69
110823: ST_TO_ADDR
// if not tmp then
110824: LD_VAR 0 2
110828: NOT
110829: IFFALSE 110833
// exit ;
110831: GO 110946
// for i := 1 to 2 do
110833: LD_ADDR_VAR 0 1
110837: PUSH
110838: DOUBLE
110839: LD_INT 1
110841: DEC
110842: ST_TO_ADDR
110843: LD_INT 2
110845: PUSH
110846: FOR_TO
110847: IFFALSE 110944
// begin uc_side := your_side ;
110849: LD_ADDR_OWVAR 20
110853: PUSH
110854: LD_OWVAR 2
110858: ST_TO_ADDR
// uc_nation := nation_american ;
110859: LD_ADDR_OWVAR 21
110863: PUSH
110864: LD_INT 1
110866: ST_TO_ADDR
// vc_chassis := us_morphling ;
110867: LD_ADDR_OWVAR 37
110871: PUSH
110872: LD_INT 5
110874: ST_TO_ADDR
// vc_engine := engine_siberite ;
110875: LD_ADDR_OWVAR 39
110879: PUSH
110880: LD_INT 3
110882: ST_TO_ADDR
// vc_control := control_computer ;
110883: LD_ADDR_OWVAR 38
110887: PUSH
110888: LD_INT 3
110890: ST_TO_ADDR
// vc_weapon := us_double_laser ;
110891: LD_ADDR_OWVAR 40
110895: PUSH
110896: LD_INT 10
110898: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
110899: CALL_OW 45
110903: PPUSH
110904: LD_VAR 0 2
110908: PUSH
110909: LD_INT 1
110911: ARRAY
110912: PPUSH
110913: CALL_OW 250
110917: PPUSH
110918: LD_VAR 0 2
110922: PUSH
110923: LD_INT 1
110925: ARRAY
110926: PPUSH
110927: CALL_OW 251
110931: PPUSH
110932: LD_INT 12
110934: PPUSH
110935: LD_INT 1
110937: PPUSH
110938: CALL_OW 50
// end ;
110942: GO 110846
110944: POP
110945: POP
// end ;
110946: PPOPN 2
110948: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
110949: LD_EXP 153
110953: PUSH
110954: LD_EXP 199
110958: AND
110959: IFFALSE 111181
110961: GO 110963
110963: DISABLE
110964: LD_INT 0
110966: PPUSH
110967: PPUSH
110968: PPUSH
110969: PPUSH
110970: PPUSH
110971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
110972: LD_ADDR_VAR 0 6
110976: PUSH
110977: LD_INT 22
110979: PUSH
110980: LD_OWVAR 2
110984: PUSH
110985: EMPTY
110986: LIST
110987: LIST
110988: PUSH
110989: LD_INT 21
110991: PUSH
110992: LD_INT 1
110994: PUSH
110995: EMPTY
110996: LIST
110997: LIST
110998: PUSH
110999: LD_INT 3
111001: PUSH
111002: LD_INT 23
111004: PUSH
111005: LD_INT 0
111007: PUSH
111008: EMPTY
111009: LIST
111010: LIST
111011: PUSH
111012: EMPTY
111013: LIST
111014: LIST
111015: PUSH
111016: EMPTY
111017: LIST
111018: LIST
111019: LIST
111020: PPUSH
111021: CALL_OW 69
111025: ST_TO_ADDR
// if not tmp then
111026: LD_VAR 0 6
111030: NOT
111031: IFFALSE 111035
// exit ;
111033: GO 111181
// s1 := rand ( 1 , 4 ) ;
111035: LD_ADDR_VAR 0 2
111039: PUSH
111040: LD_INT 1
111042: PPUSH
111043: LD_INT 4
111045: PPUSH
111046: CALL_OW 12
111050: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
111051: LD_ADDR_VAR 0 4
111055: PUSH
111056: LD_VAR 0 6
111060: PUSH
111061: LD_INT 1
111063: ARRAY
111064: PPUSH
111065: LD_VAR 0 2
111069: PPUSH
111070: CALL_OW 259
111074: ST_TO_ADDR
// if s1 = 1 then
111075: LD_VAR 0 2
111079: PUSH
111080: LD_INT 1
111082: EQUAL
111083: IFFALSE 111103
// s2 := rand ( 2 , 4 ) else
111085: LD_ADDR_VAR 0 3
111089: PUSH
111090: LD_INT 2
111092: PPUSH
111093: LD_INT 4
111095: PPUSH
111096: CALL_OW 12
111100: ST_TO_ADDR
111101: GO 111111
// s2 := 1 ;
111103: LD_ADDR_VAR 0 3
111107: PUSH
111108: LD_INT 1
111110: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
111111: LD_ADDR_VAR 0 5
111115: PUSH
111116: LD_VAR 0 6
111120: PUSH
111121: LD_INT 1
111123: ARRAY
111124: PPUSH
111125: LD_VAR 0 3
111129: PPUSH
111130: CALL_OW 259
111134: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
111135: LD_VAR 0 6
111139: PUSH
111140: LD_INT 1
111142: ARRAY
111143: PPUSH
111144: LD_VAR 0 2
111148: PPUSH
111149: LD_VAR 0 5
111153: PPUSH
111154: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
111158: LD_VAR 0 6
111162: PUSH
111163: LD_INT 1
111165: ARRAY
111166: PPUSH
111167: LD_VAR 0 3
111171: PPUSH
111172: LD_VAR 0 4
111176: PPUSH
111177: CALL_OW 237
// end ;
111181: PPOPN 6
111183: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
111184: LD_EXP 153
111188: PUSH
111189: LD_EXP 200
111193: AND
111194: IFFALSE 111273
111196: GO 111198
111198: DISABLE
111199: LD_INT 0
111201: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
111202: LD_ADDR_VAR 0 1
111206: PUSH
111207: LD_INT 22
111209: PUSH
111210: LD_OWVAR 2
111214: PUSH
111215: EMPTY
111216: LIST
111217: LIST
111218: PUSH
111219: LD_INT 30
111221: PUSH
111222: LD_INT 3
111224: PUSH
111225: EMPTY
111226: LIST
111227: LIST
111228: PUSH
111229: EMPTY
111230: LIST
111231: LIST
111232: PPUSH
111233: CALL_OW 69
111237: ST_TO_ADDR
// if not tmp then
111238: LD_VAR 0 1
111242: NOT
111243: IFFALSE 111247
// exit ;
111245: GO 111273
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111247: LD_VAR 0 1
111251: PUSH
111252: LD_INT 1
111254: PPUSH
111255: LD_VAR 0 1
111259: PPUSH
111260: CALL_OW 12
111264: ARRAY
111265: PPUSH
111266: LD_INT 1
111268: PPUSH
111269: CALL_OW 234
// end ;
111273: PPOPN 1
111275: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
111276: LD_EXP 153
111280: PUSH
111281: LD_EXP 201
111285: AND
111286: IFFALSE 111398
111288: GO 111290
111290: DISABLE
111291: LD_INT 0
111293: PPUSH
111294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
111295: LD_ADDR_VAR 0 2
111299: PUSH
111300: LD_INT 22
111302: PUSH
111303: LD_OWVAR 2
111307: PUSH
111308: EMPTY
111309: LIST
111310: LIST
111311: PUSH
111312: LD_INT 2
111314: PUSH
111315: LD_INT 30
111317: PUSH
111318: LD_INT 27
111320: PUSH
111321: EMPTY
111322: LIST
111323: LIST
111324: PUSH
111325: LD_INT 30
111327: PUSH
111328: LD_INT 26
111330: PUSH
111331: EMPTY
111332: LIST
111333: LIST
111334: PUSH
111335: LD_INT 30
111337: PUSH
111338: LD_INT 28
111340: PUSH
111341: EMPTY
111342: LIST
111343: LIST
111344: PUSH
111345: EMPTY
111346: LIST
111347: LIST
111348: LIST
111349: LIST
111350: PUSH
111351: EMPTY
111352: LIST
111353: LIST
111354: PPUSH
111355: CALL_OW 69
111359: ST_TO_ADDR
// if not tmp then
111360: LD_VAR 0 2
111364: NOT
111365: IFFALSE 111369
// exit ;
111367: GO 111398
// for i in tmp do
111369: LD_ADDR_VAR 0 1
111373: PUSH
111374: LD_VAR 0 2
111378: PUSH
111379: FOR_IN
111380: IFFALSE 111396
// SetLives ( i , 1 ) ;
111382: LD_VAR 0 1
111386: PPUSH
111387: LD_INT 1
111389: PPUSH
111390: CALL_OW 234
111394: GO 111379
111396: POP
111397: POP
// end ;
111398: PPOPN 2
111400: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
111401: LD_EXP 153
111405: PUSH
111406: LD_EXP 202
111410: AND
111411: IFFALSE 111685
111413: GO 111415
111415: DISABLE
111416: LD_INT 0
111418: PPUSH
111419: PPUSH
111420: PPUSH
// begin i := rand ( 1 , 7 ) ;
111421: LD_ADDR_VAR 0 1
111425: PUSH
111426: LD_INT 1
111428: PPUSH
111429: LD_INT 7
111431: PPUSH
111432: CALL_OW 12
111436: ST_TO_ADDR
// case i of 1 :
111437: LD_VAR 0 1
111441: PUSH
111442: LD_INT 1
111444: DOUBLE
111445: EQUAL
111446: IFTRUE 111450
111448: GO 111460
111450: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
111451: LD_STRING earthquake(getX(game), 0, 32)
111453: PPUSH
111454: CALL_OW 559
111458: GO 111685
111460: LD_INT 2
111462: DOUBLE
111463: EQUAL
111464: IFTRUE 111468
111466: GO 111482
111468: POP
// begin ToLua ( displayStucuk(); ) ;
111469: LD_STRING displayStucuk();
111471: PPUSH
111472: CALL_OW 559
// ResetFog ;
111476: CALL_OW 335
// end ; 3 :
111480: GO 111685
111482: LD_INT 3
111484: DOUBLE
111485: EQUAL
111486: IFTRUE 111490
111488: GO 111594
111490: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111491: LD_ADDR_VAR 0 2
111495: PUSH
111496: LD_INT 22
111498: PUSH
111499: LD_OWVAR 2
111503: PUSH
111504: EMPTY
111505: LIST
111506: LIST
111507: PUSH
111508: LD_INT 25
111510: PUSH
111511: LD_INT 1
111513: PUSH
111514: EMPTY
111515: LIST
111516: LIST
111517: PUSH
111518: EMPTY
111519: LIST
111520: LIST
111521: PPUSH
111522: CALL_OW 69
111526: ST_TO_ADDR
// if not tmp then
111527: LD_VAR 0 2
111531: NOT
111532: IFFALSE 111536
// exit ;
111534: GO 111685
// un := tmp [ rand ( 1 , tmp ) ] ;
111536: LD_ADDR_VAR 0 3
111540: PUSH
111541: LD_VAR 0 2
111545: PUSH
111546: LD_INT 1
111548: PPUSH
111549: LD_VAR 0 2
111553: PPUSH
111554: CALL_OW 12
111558: ARRAY
111559: ST_TO_ADDR
// if Crawls ( un ) then
111560: LD_VAR 0 3
111564: PPUSH
111565: CALL_OW 318
111569: IFFALSE 111580
// ComWalk ( un ) ;
111571: LD_VAR 0 3
111575: PPUSH
111576: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111580: LD_VAR 0 3
111584: PPUSH
111585: LD_INT 8
111587: PPUSH
111588: CALL_OW 336
// end ; 4 :
111592: GO 111685
111594: LD_INT 4
111596: DOUBLE
111597: EQUAL
111598: IFTRUE 111602
111600: GO 111663
111602: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111603: LD_ADDR_VAR 0 2
111607: PUSH
111608: LD_INT 22
111610: PUSH
111611: LD_OWVAR 2
111615: PUSH
111616: EMPTY
111617: LIST
111618: LIST
111619: PUSH
111620: LD_INT 30
111622: PUSH
111623: LD_INT 29
111625: PUSH
111626: EMPTY
111627: LIST
111628: LIST
111629: PUSH
111630: EMPTY
111631: LIST
111632: LIST
111633: PPUSH
111634: CALL_OW 69
111638: ST_TO_ADDR
// if not tmp then
111639: LD_VAR 0 2
111643: NOT
111644: IFFALSE 111648
// exit ;
111646: GO 111685
// DestroyUnit ( tmp [ 1 ] ) ;
111648: LD_VAR 0 2
111652: PUSH
111653: LD_INT 1
111655: ARRAY
111656: PPUSH
111657: CALL_OW 65
// end ; 5 .. 7 :
111661: GO 111685
111663: LD_INT 5
111665: DOUBLE
111666: GREATEREQUAL
111667: IFFALSE 111675
111669: LD_INT 7
111671: DOUBLE
111672: LESSEQUAL
111673: IFTRUE 111677
111675: GO 111684
111677: POP
// StreamSibBomb ; end ;
111678: CALL 107965 0 0
111682: GO 111685
111684: POP
// end ;
111685: PPOPN 3
111687: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
111688: LD_EXP 153
111692: PUSH
111693: LD_EXP 203
111697: AND
111698: IFFALSE 111854
111700: GO 111702
111702: DISABLE
111703: LD_INT 0
111705: PPUSH
111706: PPUSH
111707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
111708: LD_ADDR_VAR 0 2
111712: PUSH
111713: LD_INT 81
111715: PUSH
111716: LD_OWVAR 2
111720: PUSH
111721: EMPTY
111722: LIST
111723: LIST
111724: PUSH
111725: LD_INT 2
111727: PUSH
111728: LD_INT 21
111730: PUSH
111731: LD_INT 1
111733: PUSH
111734: EMPTY
111735: LIST
111736: LIST
111737: PUSH
111738: LD_INT 21
111740: PUSH
111741: LD_INT 2
111743: PUSH
111744: EMPTY
111745: LIST
111746: LIST
111747: PUSH
111748: EMPTY
111749: LIST
111750: LIST
111751: LIST
111752: PUSH
111753: EMPTY
111754: LIST
111755: LIST
111756: PPUSH
111757: CALL_OW 69
111761: ST_TO_ADDR
// if not tmp then
111762: LD_VAR 0 2
111766: NOT
111767: IFFALSE 111771
// exit ;
111769: GO 111854
// p := 0 ;
111771: LD_ADDR_VAR 0 3
111775: PUSH
111776: LD_INT 0
111778: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
111779: LD_INT 35
111781: PPUSH
111782: CALL_OW 67
// p := p + 1 ;
111786: LD_ADDR_VAR 0 3
111790: PUSH
111791: LD_VAR 0 3
111795: PUSH
111796: LD_INT 1
111798: PLUS
111799: ST_TO_ADDR
// for i in tmp do
111800: LD_ADDR_VAR 0 1
111804: PUSH
111805: LD_VAR 0 2
111809: PUSH
111810: FOR_IN
111811: IFFALSE 111842
// if GetLives ( i ) < 1000 then
111813: LD_VAR 0 1
111817: PPUSH
111818: CALL_OW 256
111822: PUSH
111823: LD_INT 1000
111825: LESS
111826: IFFALSE 111840
// SetLives ( i , 1000 ) ;
111828: LD_VAR 0 1
111832: PPUSH
111833: LD_INT 1000
111835: PPUSH
111836: CALL_OW 234
111840: GO 111810
111842: POP
111843: POP
// until p > 20 ;
111844: LD_VAR 0 3
111848: PUSH
111849: LD_INT 20
111851: GREATER
111852: IFFALSE 111779
// end ;
111854: PPOPN 3
111856: END
// every 0 0$1 trigger StreamModeActive and sTime do
111857: LD_EXP 153
111861: PUSH
111862: LD_EXP 204
111866: AND
111867: IFFALSE 111902
111869: GO 111871
111871: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
111872: LD_INT 28
111874: PPUSH
111875: LD_OWVAR 2
111879: PPUSH
111880: LD_INT 2
111882: PPUSH
111883: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
111887: LD_INT 30
111889: PPUSH
111890: LD_OWVAR 2
111894: PPUSH
111895: LD_INT 2
111897: PPUSH
111898: CALL_OW 322
// end ;
111902: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
111903: LD_EXP 153
111907: PUSH
111908: LD_EXP 205
111912: AND
111913: IFFALSE 112034
111915: GO 111917
111917: DISABLE
111918: LD_INT 0
111920: PPUSH
111921: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111922: LD_ADDR_VAR 0 2
111926: PUSH
111927: LD_INT 22
111929: PUSH
111930: LD_OWVAR 2
111934: PUSH
111935: EMPTY
111936: LIST
111937: LIST
111938: PUSH
111939: LD_INT 21
111941: PUSH
111942: LD_INT 1
111944: PUSH
111945: EMPTY
111946: LIST
111947: LIST
111948: PUSH
111949: LD_INT 3
111951: PUSH
111952: LD_INT 23
111954: PUSH
111955: LD_INT 0
111957: PUSH
111958: EMPTY
111959: LIST
111960: LIST
111961: PUSH
111962: EMPTY
111963: LIST
111964: LIST
111965: PUSH
111966: EMPTY
111967: LIST
111968: LIST
111969: LIST
111970: PPUSH
111971: CALL_OW 69
111975: ST_TO_ADDR
// if not tmp then
111976: LD_VAR 0 2
111980: NOT
111981: IFFALSE 111985
// exit ;
111983: GO 112034
// for i in tmp do
111985: LD_ADDR_VAR 0 1
111989: PUSH
111990: LD_VAR 0 2
111994: PUSH
111995: FOR_IN
111996: IFFALSE 112032
// begin if Crawls ( i ) then
111998: LD_VAR 0 1
112002: PPUSH
112003: CALL_OW 318
112007: IFFALSE 112018
// ComWalk ( i ) ;
112009: LD_VAR 0 1
112013: PPUSH
112014: CALL_OW 138
// SetClass ( i , 2 ) ;
112018: LD_VAR 0 1
112022: PPUSH
112023: LD_INT 2
112025: PPUSH
112026: CALL_OW 336
// end ;
112030: GO 111995
112032: POP
112033: POP
// end ;
112034: PPOPN 2
112036: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
112037: LD_EXP 153
112041: PUSH
112042: LD_EXP 206
112046: AND
112047: IFFALSE 112328
112049: GO 112051
112051: DISABLE
112052: LD_INT 0
112054: PPUSH
112055: PPUSH
112056: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
112057: LD_OWVAR 2
112061: PPUSH
112062: LD_INT 9
112064: PPUSH
112065: LD_INT 1
112067: PPUSH
112068: LD_INT 1
112070: PPUSH
112071: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
112075: LD_INT 9
112077: PPUSH
112078: LD_OWVAR 2
112082: PPUSH
112083: CALL_OW 343
// uc_side := 9 ;
112087: LD_ADDR_OWVAR 20
112091: PUSH
112092: LD_INT 9
112094: ST_TO_ADDR
// uc_nation := 2 ;
112095: LD_ADDR_OWVAR 21
112099: PUSH
112100: LD_INT 2
112102: ST_TO_ADDR
// hc_name := Dark Warrior ;
112103: LD_ADDR_OWVAR 26
112107: PUSH
112108: LD_STRING Dark Warrior
112110: ST_TO_ADDR
// hc_gallery :=  ;
112111: LD_ADDR_OWVAR 33
112115: PUSH
112116: LD_STRING 
112118: ST_TO_ADDR
// hc_noskilllimit := true ;
112119: LD_ADDR_OWVAR 76
112123: PUSH
112124: LD_INT 1
112126: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
112127: LD_ADDR_OWVAR 31
112131: PUSH
112132: LD_INT 30
112134: PUSH
112135: LD_INT 30
112137: PUSH
112138: LD_INT 30
112140: PUSH
112141: LD_INT 30
112143: PUSH
112144: EMPTY
112145: LIST
112146: LIST
112147: LIST
112148: LIST
112149: ST_TO_ADDR
// un := CreateHuman ;
112150: LD_ADDR_VAR 0 3
112154: PUSH
112155: CALL_OW 44
112159: ST_TO_ADDR
// hc_noskilllimit := false ;
112160: LD_ADDR_OWVAR 76
112164: PUSH
112165: LD_INT 0
112167: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112168: LD_VAR 0 3
112172: PPUSH
112173: LD_INT 1
112175: PPUSH
112176: CALL_OW 51
// p := 0 ;
112180: LD_ADDR_VAR 0 2
112184: PUSH
112185: LD_INT 0
112187: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112188: LD_INT 35
112190: PPUSH
112191: CALL_OW 67
// p := p + 1 ;
112195: LD_ADDR_VAR 0 2
112199: PUSH
112200: LD_VAR 0 2
112204: PUSH
112205: LD_INT 1
112207: PLUS
112208: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
112209: LD_VAR 0 3
112213: PPUSH
112214: CALL_OW 256
112218: PUSH
112219: LD_INT 1000
112221: LESS
112222: IFFALSE 112236
// SetLives ( un , 1000 ) ;
112224: LD_VAR 0 3
112228: PPUSH
112229: LD_INT 1000
112231: PPUSH
112232: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
112236: LD_VAR 0 3
112240: PPUSH
112241: LD_INT 81
112243: PUSH
112244: LD_OWVAR 2
112248: PUSH
112249: EMPTY
112250: LIST
112251: LIST
112252: PUSH
112253: LD_INT 91
112255: PUSH
112256: LD_VAR 0 3
112260: PUSH
112261: LD_INT 30
112263: PUSH
112264: EMPTY
112265: LIST
112266: LIST
112267: LIST
112268: PUSH
112269: EMPTY
112270: LIST
112271: LIST
112272: PPUSH
112273: CALL_OW 69
112277: PPUSH
112278: LD_VAR 0 3
112282: PPUSH
112283: CALL_OW 74
112287: PPUSH
112288: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
112292: LD_VAR 0 2
112296: PUSH
112297: LD_INT 60
112299: GREATER
112300: PUSH
112301: LD_VAR 0 3
112305: PPUSH
112306: CALL_OW 301
112310: OR
112311: IFFALSE 112188
// if un then
112313: LD_VAR 0 3
112317: IFFALSE 112328
// RemoveUnit ( un ) ;
112319: LD_VAR 0 3
112323: PPUSH
112324: CALL_OW 64
// end ; end_of_file
112328: PPOPN 3
112330: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
112331: LD_INT 0
112333: PPUSH
112334: PPUSH
112335: PPUSH
112336: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
112337: LD_VAR 0 1
112341: PPUSH
112342: CALL_OW 264
112346: PUSH
112347: LD_EXP 99
112351: EQUAL
112352: IFFALSE 112424
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
112354: LD_INT 68
112356: PPUSH
112357: LD_VAR 0 1
112361: PPUSH
112362: CALL_OW 255
112366: PPUSH
112367: CALL_OW 321
112371: PUSH
112372: LD_INT 2
112374: EQUAL
112375: IFFALSE 112387
// eff := 70 else
112377: LD_ADDR_VAR 0 4
112381: PUSH
112382: LD_INT 70
112384: ST_TO_ADDR
112385: GO 112395
// eff := 30 ;
112387: LD_ADDR_VAR 0 4
112391: PUSH
112392: LD_INT 30
112394: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
112395: LD_VAR 0 1
112399: PPUSH
112400: CALL_OW 250
112404: PPUSH
112405: LD_VAR 0 1
112409: PPUSH
112410: CALL_OW 251
112414: PPUSH
112415: LD_VAR 0 4
112419: PPUSH
112420: CALL_OW 495
// end ; end ;
112424: LD_VAR 0 2
112428: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112429: LD_INT 0
112431: PPUSH
// end ;
112432: LD_VAR 0 4
112436: RET
// export function SOS_Command ( cmd ) ; begin
112437: LD_INT 0
112439: PPUSH
// end ;
112440: LD_VAR 0 2
112444: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
112445: LD_VAR 0 1
112449: PUSH
112450: LD_INT 255
112452: EQUAL
112453: PUSH
112454: LD_VAR 0 2
112458: PPUSH
112459: CALL_OW 264
112463: PUSH
112464: LD_INT 14
112466: PUSH
112467: LD_INT 53
112469: PUSH
112470: EMPTY
112471: LIST
112472: LIST
112473: IN
112474: AND
112475: PUSH
112476: LD_VAR 0 4
112480: PPUSH
112481: LD_VAR 0 5
112485: PPUSH
112486: CALL_OW 488
112490: AND
112491: IFFALSE 112515
// CutTreeXYR ( unit , x , y , 12 ) ;
112493: LD_VAR 0 2
112497: PPUSH
112498: LD_VAR 0 4
112502: PPUSH
112503: LD_VAR 0 5
112507: PPUSH
112508: LD_INT 12
112510: PPUSH
112511: CALL 112518 0 4
// end ;
112515: PPOPN 5
112517: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
112518: LD_INT 0
112520: PPUSH
112521: PPUSH
112522: PPUSH
112523: PPUSH
112524: PPUSH
112525: PPUSH
112526: PPUSH
112527: PPUSH
112528: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
112529: LD_VAR 0 1
112533: NOT
112534: PUSH
112535: LD_VAR 0 2
112539: PPUSH
112540: LD_VAR 0 3
112544: PPUSH
112545: CALL_OW 488
112549: NOT
112550: OR
112551: PUSH
112552: LD_VAR 0 4
112556: NOT
112557: OR
112558: IFFALSE 112562
// exit ;
112560: GO 112902
// list := [ ] ;
112562: LD_ADDR_VAR 0 13
112566: PUSH
112567: EMPTY
112568: ST_TO_ADDR
// if x - r < 0 then
112569: LD_VAR 0 2
112573: PUSH
112574: LD_VAR 0 4
112578: MINUS
112579: PUSH
112580: LD_INT 0
112582: LESS
112583: IFFALSE 112595
// min_x := 0 else
112585: LD_ADDR_VAR 0 7
112589: PUSH
112590: LD_INT 0
112592: ST_TO_ADDR
112593: GO 112611
// min_x := x - r ;
112595: LD_ADDR_VAR 0 7
112599: PUSH
112600: LD_VAR 0 2
112604: PUSH
112605: LD_VAR 0 4
112609: MINUS
112610: ST_TO_ADDR
// if y - r < 0 then
112611: LD_VAR 0 3
112615: PUSH
112616: LD_VAR 0 4
112620: MINUS
112621: PUSH
112622: LD_INT 0
112624: LESS
112625: IFFALSE 112637
// min_y := 0 else
112627: LD_ADDR_VAR 0 8
112631: PUSH
112632: LD_INT 0
112634: ST_TO_ADDR
112635: GO 112653
// min_y := y - r ;
112637: LD_ADDR_VAR 0 8
112641: PUSH
112642: LD_VAR 0 3
112646: PUSH
112647: LD_VAR 0 4
112651: MINUS
112652: ST_TO_ADDR
// max_x := x + r ;
112653: LD_ADDR_VAR 0 9
112657: PUSH
112658: LD_VAR 0 2
112662: PUSH
112663: LD_VAR 0 4
112667: PLUS
112668: ST_TO_ADDR
// max_y := y + r ;
112669: LD_ADDR_VAR 0 10
112673: PUSH
112674: LD_VAR 0 3
112678: PUSH
112679: LD_VAR 0 4
112683: PLUS
112684: ST_TO_ADDR
// for _x = min_x to max_x do
112685: LD_ADDR_VAR 0 11
112689: PUSH
112690: DOUBLE
112691: LD_VAR 0 7
112695: DEC
112696: ST_TO_ADDR
112697: LD_VAR 0 9
112701: PUSH
112702: FOR_TO
112703: IFFALSE 112820
// for _y = min_y to max_y do
112705: LD_ADDR_VAR 0 12
112709: PUSH
112710: DOUBLE
112711: LD_VAR 0 8
112715: DEC
112716: ST_TO_ADDR
112717: LD_VAR 0 10
112721: PUSH
112722: FOR_TO
112723: IFFALSE 112816
// begin if not ValidHex ( _x , _y ) then
112725: LD_VAR 0 11
112729: PPUSH
112730: LD_VAR 0 12
112734: PPUSH
112735: CALL_OW 488
112739: NOT
112740: IFFALSE 112744
// continue ;
112742: GO 112722
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112744: LD_VAR 0 11
112748: PPUSH
112749: LD_VAR 0 12
112753: PPUSH
112754: CALL_OW 351
112758: PUSH
112759: LD_VAR 0 11
112763: PPUSH
112764: LD_VAR 0 12
112768: PPUSH
112769: CALL_OW 554
112773: AND
112774: IFFALSE 112814
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112776: LD_ADDR_VAR 0 13
112780: PUSH
112781: LD_VAR 0 13
112785: PPUSH
112786: LD_VAR 0 13
112790: PUSH
112791: LD_INT 1
112793: PLUS
112794: PPUSH
112795: LD_VAR 0 11
112799: PUSH
112800: LD_VAR 0 12
112804: PUSH
112805: EMPTY
112806: LIST
112807: LIST
112808: PPUSH
112809: CALL_OW 2
112813: ST_TO_ADDR
// end ;
112814: GO 112722
112816: POP
112817: POP
112818: GO 112702
112820: POP
112821: POP
// if not list then
112822: LD_VAR 0 13
112826: NOT
112827: IFFALSE 112831
// exit ;
112829: GO 112902
// for i in list do
112831: LD_ADDR_VAR 0 6
112835: PUSH
112836: LD_VAR 0 13
112840: PUSH
112841: FOR_IN
112842: IFFALSE 112900
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
112844: LD_VAR 0 1
112848: PPUSH
112849: LD_STRING M
112851: PUSH
112852: LD_VAR 0 6
112856: PUSH
112857: LD_INT 1
112859: ARRAY
112860: PUSH
112861: LD_VAR 0 6
112865: PUSH
112866: LD_INT 2
112868: ARRAY
112869: PUSH
112870: LD_INT 0
112872: PUSH
112873: LD_INT 0
112875: PUSH
112876: LD_INT 0
112878: PUSH
112879: LD_INT 0
112881: PUSH
112882: EMPTY
112883: LIST
112884: LIST
112885: LIST
112886: LIST
112887: LIST
112888: LIST
112889: LIST
112890: PUSH
112891: EMPTY
112892: LIST
112893: PPUSH
112894: CALL_OW 447
112898: GO 112841
112900: POP
112901: POP
// end ; end_of_file
112902: LD_VAR 0 5
112906: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112907: LD_INT 0
112909: PPUSH
112910: PPUSH
112911: PPUSH
112912: PPUSH
112913: PPUSH
112914: PPUSH
112915: PPUSH
112916: PPUSH
112917: PPUSH
112918: PPUSH
112919: PPUSH
112920: PPUSH
112921: PPUSH
112922: PPUSH
112923: PPUSH
112924: PPUSH
112925: PPUSH
112926: PPUSH
112927: PPUSH
112928: PPUSH
112929: PPUSH
112930: PPUSH
112931: PPUSH
112932: PPUSH
112933: PPUSH
112934: PPUSH
112935: PPUSH
112936: PPUSH
112937: PPUSH
112938: PPUSH
112939: PPUSH
112940: PPUSH
112941: PPUSH
112942: PPUSH
// if not list then
112943: LD_VAR 0 1
112947: NOT
112948: IFFALSE 112952
// exit ;
112950: GO 117611
// base := list [ 1 ] ;
112952: LD_ADDR_VAR 0 3
112956: PUSH
112957: LD_VAR 0 1
112961: PUSH
112962: LD_INT 1
112964: ARRAY
112965: ST_TO_ADDR
// group := list [ 2 ] ;
112966: LD_ADDR_VAR 0 4
112970: PUSH
112971: LD_VAR 0 1
112975: PUSH
112976: LD_INT 2
112978: ARRAY
112979: ST_TO_ADDR
// path := list [ 3 ] ;
112980: LD_ADDR_VAR 0 5
112984: PUSH
112985: LD_VAR 0 1
112989: PUSH
112990: LD_INT 3
112992: ARRAY
112993: ST_TO_ADDR
// flags := list [ 4 ] ;
112994: LD_ADDR_VAR 0 6
112998: PUSH
112999: LD_VAR 0 1
113003: PUSH
113004: LD_INT 4
113006: ARRAY
113007: ST_TO_ADDR
// mined := [ ] ;
113008: LD_ADDR_VAR 0 27
113012: PUSH
113013: EMPTY
113014: ST_TO_ADDR
// bombed := [ ] ;
113015: LD_ADDR_VAR 0 28
113019: PUSH
113020: EMPTY
113021: ST_TO_ADDR
// healers := [ ] ;
113022: LD_ADDR_VAR 0 31
113026: PUSH
113027: EMPTY
113028: ST_TO_ADDR
// to_heal := [ ] ;
113029: LD_ADDR_VAR 0 30
113033: PUSH
113034: EMPTY
113035: ST_TO_ADDR
// repairs := [ ] ;
113036: LD_ADDR_VAR 0 33
113040: PUSH
113041: EMPTY
113042: ST_TO_ADDR
// to_repair := [ ] ;
113043: LD_ADDR_VAR 0 32
113047: PUSH
113048: EMPTY
113049: ST_TO_ADDR
// if not group or not path then
113050: LD_VAR 0 4
113054: NOT
113055: PUSH
113056: LD_VAR 0 5
113060: NOT
113061: OR
113062: IFFALSE 113066
// exit ;
113064: GO 117611
// side := GetSide ( group [ 1 ] ) ;
113066: LD_ADDR_VAR 0 35
113070: PUSH
113071: LD_VAR 0 4
113075: PUSH
113076: LD_INT 1
113078: ARRAY
113079: PPUSH
113080: CALL_OW 255
113084: ST_TO_ADDR
// if flags then
113085: LD_VAR 0 6
113089: IFFALSE 113233
// begin f_ignore_area := flags [ 1 ] ;
113091: LD_ADDR_VAR 0 17
113095: PUSH
113096: LD_VAR 0 6
113100: PUSH
113101: LD_INT 1
113103: ARRAY
113104: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113105: LD_ADDR_VAR 0 18
113109: PUSH
113110: LD_VAR 0 6
113114: PUSH
113115: LD_INT 2
113117: ARRAY
113118: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113119: LD_ADDR_VAR 0 19
113123: PUSH
113124: LD_VAR 0 6
113128: PUSH
113129: LD_INT 3
113131: ARRAY
113132: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113133: LD_ADDR_VAR 0 20
113137: PUSH
113138: LD_VAR 0 6
113142: PUSH
113143: LD_INT 4
113145: ARRAY
113146: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113147: LD_ADDR_VAR 0 21
113151: PUSH
113152: LD_VAR 0 6
113156: PUSH
113157: LD_INT 5
113159: ARRAY
113160: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113161: LD_ADDR_VAR 0 22
113165: PUSH
113166: LD_VAR 0 6
113170: PUSH
113171: LD_INT 6
113173: ARRAY
113174: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113175: LD_ADDR_VAR 0 23
113179: PUSH
113180: LD_VAR 0 6
113184: PUSH
113185: LD_INT 7
113187: ARRAY
113188: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113189: LD_ADDR_VAR 0 24
113193: PUSH
113194: LD_VAR 0 6
113198: PUSH
113199: LD_INT 8
113201: ARRAY
113202: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113203: LD_ADDR_VAR 0 25
113207: PUSH
113208: LD_VAR 0 6
113212: PUSH
113213: LD_INT 9
113215: ARRAY
113216: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113217: LD_ADDR_VAR 0 26
113221: PUSH
113222: LD_VAR 0 6
113226: PUSH
113227: LD_INT 10
113229: ARRAY
113230: ST_TO_ADDR
// end else
113231: GO 113313
// begin f_ignore_area := false ;
113233: LD_ADDR_VAR 0 17
113237: PUSH
113238: LD_INT 0
113240: ST_TO_ADDR
// f_capture := false ;
113241: LD_ADDR_VAR 0 18
113245: PUSH
113246: LD_INT 0
113248: ST_TO_ADDR
// f_ignore_civ := false ;
113249: LD_ADDR_VAR 0 19
113253: PUSH
113254: LD_INT 0
113256: ST_TO_ADDR
// f_murder := false ;
113257: LD_ADDR_VAR 0 20
113261: PUSH
113262: LD_INT 0
113264: ST_TO_ADDR
// f_mines := false ;
113265: LD_ADDR_VAR 0 21
113269: PUSH
113270: LD_INT 0
113272: ST_TO_ADDR
// f_repair := false ;
113273: LD_ADDR_VAR 0 22
113277: PUSH
113278: LD_INT 0
113280: ST_TO_ADDR
// f_heal := false ;
113281: LD_ADDR_VAR 0 23
113285: PUSH
113286: LD_INT 0
113288: ST_TO_ADDR
// f_spacetime := false ;
113289: LD_ADDR_VAR 0 24
113293: PUSH
113294: LD_INT 0
113296: ST_TO_ADDR
// f_attack_depot := false ;
113297: LD_ADDR_VAR 0 25
113301: PUSH
113302: LD_INT 0
113304: ST_TO_ADDR
// f_crawl := false ;
113305: LD_ADDR_VAR 0 26
113309: PUSH
113310: LD_INT 0
113312: ST_TO_ADDR
// end ; if f_heal then
113313: LD_VAR 0 23
113317: IFFALSE 113344
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113319: LD_ADDR_VAR 0 31
113323: PUSH
113324: LD_VAR 0 4
113328: PPUSH
113329: LD_INT 25
113331: PUSH
113332: LD_INT 4
113334: PUSH
113335: EMPTY
113336: LIST
113337: LIST
113338: PPUSH
113339: CALL_OW 72
113343: ST_TO_ADDR
// if f_repair then
113344: LD_VAR 0 22
113348: IFFALSE 113375
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113350: LD_ADDR_VAR 0 33
113354: PUSH
113355: LD_VAR 0 4
113359: PPUSH
113360: LD_INT 25
113362: PUSH
113363: LD_INT 3
113365: PUSH
113366: EMPTY
113367: LIST
113368: LIST
113369: PPUSH
113370: CALL_OW 72
113374: ST_TO_ADDR
// units_path := [ ] ;
113375: LD_ADDR_VAR 0 16
113379: PUSH
113380: EMPTY
113381: ST_TO_ADDR
// for i = 1 to group do
113382: LD_ADDR_VAR 0 7
113386: PUSH
113387: DOUBLE
113388: LD_INT 1
113390: DEC
113391: ST_TO_ADDR
113392: LD_VAR 0 4
113396: PUSH
113397: FOR_TO
113398: IFFALSE 113427
// units_path := Replace ( units_path , i , path ) ;
113400: LD_ADDR_VAR 0 16
113404: PUSH
113405: LD_VAR 0 16
113409: PPUSH
113410: LD_VAR 0 7
113414: PPUSH
113415: LD_VAR 0 5
113419: PPUSH
113420: CALL_OW 1
113424: ST_TO_ADDR
113425: GO 113397
113427: POP
113428: POP
// repeat for i = group downto 1 do
113429: LD_ADDR_VAR 0 7
113433: PUSH
113434: DOUBLE
113435: LD_VAR 0 4
113439: INC
113440: ST_TO_ADDR
113441: LD_INT 1
113443: PUSH
113444: FOR_DOWNTO
113445: IFFALSE 117567
// begin wait ( 5 ) ;
113447: LD_INT 5
113449: PPUSH
113450: CALL_OW 67
// tmp := [ ] ;
113454: LD_ADDR_VAR 0 14
113458: PUSH
113459: EMPTY
113460: ST_TO_ADDR
// attacking := false ;
113461: LD_ADDR_VAR 0 29
113465: PUSH
113466: LD_INT 0
113468: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113469: LD_VAR 0 4
113473: PUSH
113474: LD_VAR 0 7
113478: ARRAY
113479: PPUSH
113480: CALL_OW 301
113484: PUSH
113485: LD_VAR 0 4
113489: PUSH
113490: LD_VAR 0 7
113494: ARRAY
113495: NOT
113496: OR
113497: IFFALSE 113606
// begin if GetType ( group [ i ] ) = unit_human then
113499: LD_VAR 0 4
113503: PUSH
113504: LD_VAR 0 7
113508: ARRAY
113509: PPUSH
113510: CALL_OW 247
113514: PUSH
113515: LD_INT 1
113517: EQUAL
113518: IFFALSE 113564
// begin to_heal := to_heal diff group [ i ] ;
113520: LD_ADDR_VAR 0 30
113524: PUSH
113525: LD_VAR 0 30
113529: PUSH
113530: LD_VAR 0 4
113534: PUSH
113535: LD_VAR 0 7
113539: ARRAY
113540: DIFF
113541: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113542: LD_ADDR_VAR 0 31
113546: PUSH
113547: LD_VAR 0 31
113551: PUSH
113552: LD_VAR 0 4
113556: PUSH
113557: LD_VAR 0 7
113561: ARRAY
113562: DIFF
113563: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113564: LD_ADDR_VAR 0 4
113568: PUSH
113569: LD_VAR 0 4
113573: PPUSH
113574: LD_VAR 0 7
113578: PPUSH
113579: CALL_OW 3
113583: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113584: LD_ADDR_VAR 0 16
113588: PUSH
113589: LD_VAR 0 16
113593: PPUSH
113594: LD_VAR 0 7
113598: PPUSH
113599: CALL_OW 3
113603: ST_TO_ADDR
// continue ;
113604: GO 113444
// end ; if f_repair then
113606: LD_VAR 0 22
113610: IFFALSE 114099
// begin if GetType ( group [ i ] ) = unit_vehicle then
113612: LD_VAR 0 4
113616: PUSH
113617: LD_VAR 0 7
113621: ARRAY
113622: PPUSH
113623: CALL_OW 247
113627: PUSH
113628: LD_INT 2
113630: EQUAL
113631: IFFALSE 113821
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113633: LD_VAR 0 4
113637: PUSH
113638: LD_VAR 0 7
113642: ARRAY
113643: PPUSH
113644: CALL_OW 256
113648: PUSH
113649: LD_INT 700
113651: LESS
113652: PUSH
113653: LD_VAR 0 4
113657: PUSH
113658: LD_VAR 0 7
113662: ARRAY
113663: PUSH
113664: LD_VAR 0 32
113668: IN
113669: NOT
113670: AND
113671: IFFALSE 113695
// to_repair := to_repair union group [ i ] ;
113673: LD_ADDR_VAR 0 32
113677: PUSH
113678: LD_VAR 0 32
113682: PUSH
113683: LD_VAR 0 4
113687: PUSH
113688: LD_VAR 0 7
113692: ARRAY
113693: UNION
113694: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113695: LD_VAR 0 4
113699: PUSH
113700: LD_VAR 0 7
113704: ARRAY
113705: PPUSH
113706: CALL_OW 256
113710: PUSH
113711: LD_INT 1000
113713: EQUAL
113714: PUSH
113715: LD_VAR 0 4
113719: PUSH
113720: LD_VAR 0 7
113724: ARRAY
113725: PUSH
113726: LD_VAR 0 32
113730: IN
113731: AND
113732: IFFALSE 113756
// to_repair := to_repair diff group [ i ] ;
113734: LD_ADDR_VAR 0 32
113738: PUSH
113739: LD_VAR 0 32
113743: PUSH
113744: LD_VAR 0 4
113748: PUSH
113749: LD_VAR 0 7
113753: ARRAY
113754: DIFF
113755: ST_TO_ADDR
// if group [ i ] in to_repair then
113756: LD_VAR 0 4
113760: PUSH
113761: LD_VAR 0 7
113765: ARRAY
113766: PUSH
113767: LD_VAR 0 32
113771: IN
113772: IFFALSE 113819
// begin if not IsInArea ( group [ i ] , f_repair ) then
113774: LD_VAR 0 4
113778: PUSH
113779: LD_VAR 0 7
113783: ARRAY
113784: PPUSH
113785: LD_VAR 0 22
113789: PPUSH
113790: CALL_OW 308
113794: NOT
113795: IFFALSE 113817
// ComMoveToArea ( group [ i ] , f_repair ) ;
113797: LD_VAR 0 4
113801: PUSH
113802: LD_VAR 0 7
113806: ARRAY
113807: PPUSH
113808: LD_VAR 0 22
113812: PPUSH
113813: CALL_OW 113
// continue ;
113817: GO 113444
// end ; end else
113819: GO 114099
// if group [ i ] in repairs then
113821: LD_VAR 0 4
113825: PUSH
113826: LD_VAR 0 7
113830: ARRAY
113831: PUSH
113832: LD_VAR 0 33
113836: IN
113837: IFFALSE 114099
// begin if IsInUnit ( group [ i ] ) then
113839: LD_VAR 0 4
113843: PUSH
113844: LD_VAR 0 7
113848: ARRAY
113849: PPUSH
113850: CALL_OW 310
113854: IFFALSE 113922
// begin z := IsInUnit ( group [ i ] ) ;
113856: LD_ADDR_VAR 0 13
113860: PUSH
113861: LD_VAR 0 4
113865: PUSH
113866: LD_VAR 0 7
113870: ARRAY
113871: PPUSH
113872: CALL_OW 310
113876: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113877: LD_VAR 0 13
113881: PUSH
113882: LD_VAR 0 32
113886: IN
113887: PUSH
113888: LD_VAR 0 13
113892: PPUSH
113893: LD_VAR 0 22
113897: PPUSH
113898: CALL_OW 308
113902: AND
113903: IFFALSE 113920
// ComExitVehicle ( group [ i ] ) ;
113905: LD_VAR 0 4
113909: PUSH
113910: LD_VAR 0 7
113914: ARRAY
113915: PPUSH
113916: CALL_OW 121
// end else
113920: GO 114099
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113922: LD_ADDR_VAR 0 13
113926: PUSH
113927: LD_VAR 0 4
113931: PPUSH
113932: LD_INT 95
113934: PUSH
113935: LD_VAR 0 22
113939: PUSH
113940: EMPTY
113941: LIST
113942: LIST
113943: PUSH
113944: LD_INT 58
113946: PUSH
113947: EMPTY
113948: LIST
113949: PUSH
113950: EMPTY
113951: LIST
113952: LIST
113953: PPUSH
113954: CALL_OW 72
113958: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113959: LD_VAR 0 4
113963: PUSH
113964: LD_VAR 0 7
113968: ARRAY
113969: PPUSH
113970: CALL_OW 314
113974: NOT
113975: IFFALSE 114097
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113977: LD_ADDR_VAR 0 10
113981: PUSH
113982: LD_VAR 0 13
113986: PPUSH
113987: LD_VAR 0 4
113991: PUSH
113992: LD_VAR 0 7
113996: ARRAY
113997: PPUSH
113998: CALL_OW 74
114002: ST_TO_ADDR
// if not x then
114003: LD_VAR 0 10
114007: NOT
114008: IFFALSE 114012
// continue ;
114010: GO 113444
// if GetLives ( x ) < 1000 then
114012: LD_VAR 0 10
114016: PPUSH
114017: CALL_OW 256
114021: PUSH
114022: LD_INT 1000
114024: LESS
114025: IFFALSE 114049
// ComRepairVehicle ( group [ i ] , x ) else
114027: LD_VAR 0 4
114031: PUSH
114032: LD_VAR 0 7
114036: ARRAY
114037: PPUSH
114038: LD_VAR 0 10
114042: PPUSH
114043: CALL_OW 129
114047: GO 114097
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114049: LD_VAR 0 23
114053: PUSH
114054: LD_VAR 0 4
114058: PUSH
114059: LD_VAR 0 7
114063: ARRAY
114064: PPUSH
114065: CALL_OW 256
114069: PUSH
114070: LD_INT 1000
114072: LESS
114073: AND
114074: NOT
114075: IFFALSE 114097
// ComEnterUnit ( group [ i ] , x ) ;
114077: LD_VAR 0 4
114081: PUSH
114082: LD_VAR 0 7
114086: ARRAY
114087: PPUSH
114088: LD_VAR 0 10
114092: PPUSH
114093: CALL_OW 120
// end ; continue ;
114097: GO 113444
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114099: LD_VAR 0 23
114103: PUSH
114104: LD_VAR 0 4
114108: PUSH
114109: LD_VAR 0 7
114113: ARRAY
114114: PPUSH
114115: CALL_OW 247
114119: PUSH
114120: LD_INT 1
114122: EQUAL
114123: AND
114124: IFFALSE 114602
// begin if group [ i ] in healers then
114126: LD_VAR 0 4
114130: PUSH
114131: LD_VAR 0 7
114135: ARRAY
114136: PUSH
114137: LD_VAR 0 31
114141: IN
114142: IFFALSE 114415
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114144: LD_VAR 0 4
114148: PUSH
114149: LD_VAR 0 7
114153: ARRAY
114154: PPUSH
114155: LD_VAR 0 23
114159: PPUSH
114160: CALL_OW 308
114164: NOT
114165: PUSH
114166: LD_VAR 0 4
114170: PUSH
114171: LD_VAR 0 7
114175: ARRAY
114176: PPUSH
114177: CALL_OW 314
114181: NOT
114182: AND
114183: IFFALSE 114207
// ComMoveToArea ( group [ i ] , f_heal ) else
114185: LD_VAR 0 4
114189: PUSH
114190: LD_VAR 0 7
114194: ARRAY
114195: PPUSH
114196: LD_VAR 0 23
114200: PPUSH
114201: CALL_OW 113
114205: GO 114413
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114207: LD_VAR 0 4
114211: PUSH
114212: LD_VAR 0 7
114216: ARRAY
114217: PPUSH
114218: CALL 98383 0 1
114222: PPUSH
114223: CALL_OW 256
114227: PUSH
114228: LD_INT 1000
114230: EQUAL
114231: IFFALSE 114250
// ComStop ( group [ i ] ) else
114233: LD_VAR 0 4
114237: PUSH
114238: LD_VAR 0 7
114242: ARRAY
114243: PPUSH
114244: CALL_OW 141
114248: GO 114413
// if not HasTask ( group [ i ] ) and to_heal then
114250: LD_VAR 0 4
114254: PUSH
114255: LD_VAR 0 7
114259: ARRAY
114260: PPUSH
114261: CALL_OW 314
114265: NOT
114266: PUSH
114267: LD_VAR 0 30
114271: AND
114272: IFFALSE 114413
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114274: LD_ADDR_VAR 0 13
114278: PUSH
114279: LD_VAR 0 30
114283: PPUSH
114284: LD_INT 3
114286: PUSH
114287: LD_INT 54
114289: PUSH
114290: EMPTY
114291: LIST
114292: PUSH
114293: EMPTY
114294: LIST
114295: LIST
114296: PPUSH
114297: CALL_OW 72
114301: PPUSH
114302: LD_VAR 0 4
114306: PUSH
114307: LD_VAR 0 7
114311: ARRAY
114312: PPUSH
114313: CALL_OW 74
114317: ST_TO_ADDR
// if z then
114318: LD_VAR 0 13
114322: IFFALSE 114413
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114324: LD_INT 91
114326: PUSH
114327: LD_VAR 0 13
114331: PUSH
114332: LD_INT 10
114334: PUSH
114335: EMPTY
114336: LIST
114337: LIST
114338: LIST
114339: PUSH
114340: LD_INT 81
114342: PUSH
114343: LD_VAR 0 13
114347: PPUSH
114348: CALL_OW 255
114352: PUSH
114353: EMPTY
114354: LIST
114355: LIST
114356: PUSH
114357: EMPTY
114358: LIST
114359: LIST
114360: PPUSH
114361: CALL_OW 69
114365: PUSH
114366: LD_INT 0
114368: EQUAL
114369: IFFALSE 114393
// ComHeal ( group [ i ] , z ) else
114371: LD_VAR 0 4
114375: PUSH
114376: LD_VAR 0 7
114380: ARRAY
114381: PPUSH
114382: LD_VAR 0 13
114386: PPUSH
114387: CALL_OW 128
114391: GO 114413
// ComMoveToArea ( group [ i ] , f_heal ) ;
114393: LD_VAR 0 4
114397: PUSH
114398: LD_VAR 0 7
114402: ARRAY
114403: PPUSH
114404: LD_VAR 0 23
114408: PPUSH
114409: CALL_OW 113
// end ; continue ;
114413: GO 113444
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114415: LD_VAR 0 4
114419: PUSH
114420: LD_VAR 0 7
114424: ARRAY
114425: PPUSH
114426: CALL_OW 256
114430: PUSH
114431: LD_INT 700
114433: LESS
114434: PUSH
114435: LD_VAR 0 4
114439: PUSH
114440: LD_VAR 0 7
114444: ARRAY
114445: PUSH
114446: LD_VAR 0 30
114450: IN
114451: NOT
114452: AND
114453: IFFALSE 114477
// to_heal := to_heal union group [ i ] ;
114455: LD_ADDR_VAR 0 30
114459: PUSH
114460: LD_VAR 0 30
114464: PUSH
114465: LD_VAR 0 4
114469: PUSH
114470: LD_VAR 0 7
114474: ARRAY
114475: UNION
114476: ST_TO_ADDR
// if group [ i ] in to_heal then
114477: LD_VAR 0 4
114481: PUSH
114482: LD_VAR 0 7
114486: ARRAY
114487: PUSH
114488: LD_VAR 0 30
114492: IN
114493: IFFALSE 114602
// begin if GetLives ( group [ i ] ) = 1000 then
114495: LD_VAR 0 4
114499: PUSH
114500: LD_VAR 0 7
114504: ARRAY
114505: PPUSH
114506: CALL_OW 256
114510: PUSH
114511: LD_INT 1000
114513: EQUAL
114514: IFFALSE 114540
// to_heal := to_heal diff group [ i ] else
114516: LD_ADDR_VAR 0 30
114520: PUSH
114521: LD_VAR 0 30
114525: PUSH
114526: LD_VAR 0 4
114530: PUSH
114531: LD_VAR 0 7
114535: ARRAY
114536: DIFF
114537: ST_TO_ADDR
114538: GO 114602
// begin if not IsInArea ( group [ i ] , to_heal ) then
114540: LD_VAR 0 4
114544: PUSH
114545: LD_VAR 0 7
114549: ARRAY
114550: PPUSH
114551: LD_VAR 0 30
114555: PPUSH
114556: CALL_OW 308
114560: NOT
114561: IFFALSE 114585
// ComMoveToArea ( group [ i ] , f_heal ) else
114563: LD_VAR 0 4
114567: PUSH
114568: LD_VAR 0 7
114572: ARRAY
114573: PPUSH
114574: LD_VAR 0 23
114578: PPUSH
114579: CALL_OW 113
114583: GO 114600
// ComHold ( group [ i ] ) ;
114585: LD_VAR 0 4
114589: PUSH
114590: LD_VAR 0 7
114594: ARRAY
114595: PPUSH
114596: CALL_OW 140
// continue ;
114600: GO 113444
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114602: LD_VAR 0 4
114606: PUSH
114607: LD_VAR 0 7
114611: ARRAY
114612: PPUSH
114613: LD_INT 10
114615: PPUSH
114616: CALL 96803 0 2
114620: NOT
114621: PUSH
114622: LD_VAR 0 16
114626: PUSH
114627: LD_VAR 0 7
114631: ARRAY
114632: PUSH
114633: EMPTY
114634: EQUAL
114635: NOT
114636: AND
114637: IFFALSE 114903
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114639: LD_VAR 0 4
114643: PUSH
114644: LD_VAR 0 7
114648: ARRAY
114649: PPUSH
114650: CALL_OW 262
114654: PUSH
114655: LD_INT 1
114657: PUSH
114658: LD_INT 2
114660: PUSH
114661: EMPTY
114662: LIST
114663: LIST
114664: IN
114665: IFFALSE 114706
// if GetFuel ( group [ i ] ) < 10 then
114667: LD_VAR 0 4
114671: PUSH
114672: LD_VAR 0 7
114676: ARRAY
114677: PPUSH
114678: CALL_OW 261
114682: PUSH
114683: LD_INT 10
114685: LESS
114686: IFFALSE 114706
// SetFuel ( group [ i ] , 12 ) ;
114688: LD_VAR 0 4
114692: PUSH
114693: LD_VAR 0 7
114697: ARRAY
114698: PPUSH
114699: LD_INT 12
114701: PPUSH
114702: CALL_OW 240
// if units_path [ i ] then
114706: LD_VAR 0 16
114710: PUSH
114711: LD_VAR 0 7
114715: ARRAY
114716: IFFALSE 114901
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114718: LD_VAR 0 4
114722: PUSH
114723: LD_VAR 0 7
114727: ARRAY
114728: PPUSH
114729: LD_VAR 0 16
114733: PUSH
114734: LD_VAR 0 7
114738: ARRAY
114739: PUSH
114740: LD_INT 1
114742: ARRAY
114743: PUSH
114744: LD_INT 1
114746: ARRAY
114747: PPUSH
114748: LD_VAR 0 16
114752: PUSH
114753: LD_VAR 0 7
114757: ARRAY
114758: PUSH
114759: LD_INT 1
114761: ARRAY
114762: PUSH
114763: LD_INT 2
114765: ARRAY
114766: PPUSH
114767: CALL_OW 297
114771: PUSH
114772: LD_INT 6
114774: GREATER
114775: IFFALSE 114850
// begin if not HasTask ( group [ i ] ) then
114777: LD_VAR 0 4
114781: PUSH
114782: LD_VAR 0 7
114786: ARRAY
114787: PPUSH
114788: CALL_OW 314
114792: NOT
114793: IFFALSE 114848
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114795: LD_VAR 0 4
114799: PUSH
114800: LD_VAR 0 7
114804: ARRAY
114805: PPUSH
114806: LD_VAR 0 16
114810: PUSH
114811: LD_VAR 0 7
114815: ARRAY
114816: PUSH
114817: LD_INT 1
114819: ARRAY
114820: PUSH
114821: LD_INT 1
114823: ARRAY
114824: PPUSH
114825: LD_VAR 0 16
114829: PUSH
114830: LD_VAR 0 7
114834: ARRAY
114835: PUSH
114836: LD_INT 1
114838: ARRAY
114839: PUSH
114840: LD_INT 2
114842: ARRAY
114843: PPUSH
114844: CALL_OW 114
// end else
114848: GO 114901
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114850: LD_ADDR_VAR 0 15
114854: PUSH
114855: LD_VAR 0 16
114859: PUSH
114860: LD_VAR 0 7
114864: ARRAY
114865: PPUSH
114866: LD_INT 1
114868: PPUSH
114869: CALL_OW 3
114873: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114874: LD_ADDR_VAR 0 16
114878: PUSH
114879: LD_VAR 0 16
114883: PPUSH
114884: LD_VAR 0 7
114888: PPUSH
114889: LD_VAR 0 15
114893: PPUSH
114894: CALL_OW 1
114898: ST_TO_ADDR
// continue ;
114899: GO 113444
// end ; end ; end else
114901: GO 117565
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114903: LD_ADDR_VAR 0 14
114907: PUSH
114908: LD_INT 81
114910: PUSH
114911: LD_VAR 0 4
114915: PUSH
114916: LD_VAR 0 7
114920: ARRAY
114921: PPUSH
114922: CALL_OW 255
114926: PUSH
114927: EMPTY
114928: LIST
114929: LIST
114930: PPUSH
114931: CALL_OW 69
114935: ST_TO_ADDR
// if not tmp then
114936: LD_VAR 0 14
114940: NOT
114941: IFFALSE 114945
// continue ;
114943: GO 113444
// if f_ignore_area then
114945: LD_VAR 0 17
114949: IFFALSE 115037
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114951: LD_ADDR_VAR 0 15
114955: PUSH
114956: LD_VAR 0 14
114960: PPUSH
114961: LD_INT 3
114963: PUSH
114964: LD_INT 92
114966: PUSH
114967: LD_VAR 0 17
114971: PUSH
114972: LD_INT 1
114974: ARRAY
114975: PUSH
114976: LD_VAR 0 17
114980: PUSH
114981: LD_INT 2
114983: ARRAY
114984: PUSH
114985: LD_VAR 0 17
114989: PUSH
114990: LD_INT 3
114992: ARRAY
114993: PUSH
114994: EMPTY
114995: LIST
114996: LIST
114997: LIST
114998: LIST
114999: PUSH
115000: EMPTY
115001: LIST
115002: LIST
115003: PPUSH
115004: CALL_OW 72
115008: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115009: LD_VAR 0 14
115013: PUSH
115014: LD_VAR 0 15
115018: DIFF
115019: IFFALSE 115037
// tmp := tmp diff tmp2 ;
115021: LD_ADDR_VAR 0 14
115025: PUSH
115026: LD_VAR 0 14
115030: PUSH
115031: LD_VAR 0 15
115035: DIFF
115036: ST_TO_ADDR
// end ; if not f_murder then
115037: LD_VAR 0 20
115041: NOT
115042: IFFALSE 115100
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115044: LD_ADDR_VAR 0 15
115048: PUSH
115049: LD_VAR 0 14
115053: PPUSH
115054: LD_INT 3
115056: PUSH
115057: LD_INT 50
115059: PUSH
115060: EMPTY
115061: LIST
115062: PUSH
115063: EMPTY
115064: LIST
115065: LIST
115066: PPUSH
115067: CALL_OW 72
115071: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115072: LD_VAR 0 14
115076: PUSH
115077: LD_VAR 0 15
115081: DIFF
115082: IFFALSE 115100
// tmp := tmp diff tmp2 ;
115084: LD_ADDR_VAR 0 14
115088: PUSH
115089: LD_VAR 0 14
115093: PUSH
115094: LD_VAR 0 15
115098: DIFF
115099: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115100: LD_ADDR_VAR 0 14
115104: PUSH
115105: LD_VAR 0 4
115109: PUSH
115110: LD_VAR 0 7
115114: ARRAY
115115: PPUSH
115116: LD_VAR 0 14
115120: PPUSH
115121: LD_INT 1
115123: PPUSH
115124: LD_INT 1
115126: PPUSH
115127: CALL 70446 0 4
115131: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115132: LD_VAR 0 4
115136: PUSH
115137: LD_VAR 0 7
115141: ARRAY
115142: PPUSH
115143: CALL_OW 257
115147: PUSH
115148: LD_INT 1
115150: EQUAL
115151: IFFALSE 115599
// begin if WantPlant ( group [ i ] ) then
115153: LD_VAR 0 4
115157: PUSH
115158: LD_VAR 0 7
115162: ARRAY
115163: PPUSH
115164: CALL 69947 0 1
115168: IFFALSE 115172
// continue ;
115170: GO 113444
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115172: LD_VAR 0 18
115176: PUSH
115177: LD_VAR 0 4
115181: PUSH
115182: LD_VAR 0 7
115186: ARRAY
115187: PPUSH
115188: CALL_OW 310
115192: NOT
115193: AND
115194: PUSH
115195: LD_VAR 0 14
115199: PUSH
115200: LD_INT 1
115202: ARRAY
115203: PUSH
115204: LD_VAR 0 14
115208: PPUSH
115209: LD_INT 21
115211: PUSH
115212: LD_INT 2
115214: PUSH
115215: EMPTY
115216: LIST
115217: LIST
115218: PUSH
115219: LD_INT 58
115221: PUSH
115222: EMPTY
115223: LIST
115224: PUSH
115225: EMPTY
115226: LIST
115227: LIST
115228: PPUSH
115229: CALL_OW 72
115233: IN
115234: AND
115235: IFFALSE 115271
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115237: LD_VAR 0 4
115241: PUSH
115242: LD_VAR 0 7
115246: ARRAY
115247: PPUSH
115248: LD_VAR 0 14
115252: PUSH
115253: LD_INT 1
115255: ARRAY
115256: PPUSH
115257: CALL_OW 120
// attacking := true ;
115261: LD_ADDR_VAR 0 29
115265: PUSH
115266: LD_INT 1
115268: ST_TO_ADDR
// continue ;
115269: GO 113444
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115271: LD_VAR 0 26
115275: PUSH
115276: LD_VAR 0 4
115280: PUSH
115281: LD_VAR 0 7
115285: ARRAY
115286: PPUSH
115287: CALL_OW 257
115291: PUSH
115292: LD_INT 1
115294: EQUAL
115295: AND
115296: PUSH
115297: LD_VAR 0 4
115301: PUSH
115302: LD_VAR 0 7
115306: ARRAY
115307: PPUSH
115308: CALL_OW 256
115312: PUSH
115313: LD_INT 800
115315: LESS
115316: AND
115317: PUSH
115318: LD_VAR 0 4
115322: PUSH
115323: LD_VAR 0 7
115327: ARRAY
115328: PPUSH
115329: CALL_OW 318
115333: NOT
115334: AND
115335: IFFALSE 115352
// ComCrawl ( group [ i ] ) ;
115337: LD_VAR 0 4
115341: PUSH
115342: LD_VAR 0 7
115346: ARRAY
115347: PPUSH
115348: CALL_OW 137
// if f_mines then
115352: LD_VAR 0 21
115356: IFFALSE 115599
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115358: LD_VAR 0 14
115362: PUSH
115363: LD_INT 1
115365: ARRAY
115366: PPUSH
115367: CALL_OW 247
115371: PUSH
115372: LD_INT 3
115374: EQUAL
115375: PUSH
115376: LD_VAR 0 14
115380: PUSH
115381: LD_INT 1
115383: ARRAY
115384: PUSH
115385: LD_VAR 0 27
115389: IN
115390: NOT
115391: AND
115392: IFFALSE 115599
// begin x := GetX ( tmp [ 1 ] ) ;
115394: LD_ADDR_VAR 0 10
115398: PUSH
115399: LD_VAR 0 14
115403: PUSH
115404: LD_INT 1
115406: ARRAY
115407: PPUSH
115408: CALL_OW 250
115412: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115413: LD_ADDR_VAR 0 11
115417: PUSH
115418: LD_VAR 0 14
115422: PUSH
115423: LD_INT 1
115425: ARRAY
115426: PPUSH
115427: CALL_OW 251
115431: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115432: LD_ADDR_VAR 0 12
115436: PUSH
115437: LD_VAR 0 4
115441: PUSH
115442: LD_VAR 0 7
115446: ARRAY
115447: PPUSH
115448: CALL 96888 0 1
115452: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115453: LD_VAR 0 4
115457: PUSH
115458: LD_VAR 0 7
115462: ARRAY
115463: PPUSH
115464: LD_VAR 0 10
115468: PPUSH
115469: LD_VAR 0 11
115473: PPUSH
115474: LD_VAR 0 14
115478: PUSH
115479: LD_INT 1
115481: ARRAY
115482: PPUSH
115483: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115487: LD_VAR 0 4
115491: PUSH
115492: LD_VAR 0 7
115496: ARRAY
115497: PPUSH
115498: LD_VAR 0 10
115502: PPUSH
115503: LD_VAR 0 12
115507: PPUSH
115508: LD_INT 7
115510: PPUSH
115511: CALL_OW 272
115515: PPUSH
115516: LD_VAR 0 11
115520: PPUSH
115521: LD_VAR 0 12
115525: PPUSH
115526: LD_INT 7
115528: PPUSH
115529: CALL_OW 273
115533: PPUSH
115534: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115538: LD_VAR 0 4
115542: PUSH
115543: LD_VAR 0 7
115547: ARRAY
115548: PPUSH
115549: LD_INT 71
115551: PPUSH
115552: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115556: LD_ADDR_VAR 0 27
115560: PUSH
115561: LD_VAR 0 27
115565: PPUSH
115566: LD_VAR 0 27
115570: PUSH
115571: LD_INT 1
115573: PLUS
115574: PPUSH
115575: LD_VAR 0 14
115579: PUSH
115580: LD_INT 1
115582: ARRAY
115583: PPUSH
115584: CALL_OW 1
115588: ST_TO_ADDR
// attacking := true ;
115589: LD_ADDR_VAR 0 29
115593: PUSH
115594: LD_INT 1
115596: ST_TO_ADDR
// continue ;
115597: GO 113444
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115599: LD_VAR 0 4
115603: PUSH
115604: LD_VAR 0 7
115608: ARRAY
115609: PPUSH
115610: CALL_OW 257
115614: PUSH
115615: LD_INT 17
115617: EQUAL
115618: PUSH
115619: LD_VAR 0 4
115623: PUSH
115624: LD_VAR 0 7
115628: ARRAY
115629: PPUSH
115630: CALL_OW 110
115634: PUSH
115635: LD_INT 71
115637: EQUAL
115638: NOT
115639: AND
115640: IFFALSE 115786
// begin attacking := false ;
115642: LD_ADDR_VAR 0 29
115646: PUSH
115647: LD_INT 0
115649: ST_TO_ADDR
// k := 5 ;
115650: LD_ADDR_VAR 0 9
115654: PUSH
115655: LD_INT 5
115657: ST_TO_ADDR
// if tmp < k then
115658: LD_VAR 0 14
115662: PUSH
115663: LD_VAR 0 9
115667: LESS
115668: IFFALSE 115680
// k := tmp ;
115670: LD_ADDR_VAR 0 9
115674: PUSH
115675: LD_VAR 0 14
115679: ST_TO_ADDR
// for j = 1 to k do
115680: LD_ADDR_VAR 0 8
115684: PUSH
115685: DOUBLE
115686: LD_INT 1
115688: DEC
115689: ST_TO_ADDR
115690: LD_VAR 0 9
115694: PUSH
115695: FOR_TO
115696: IFFALSE 115784
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115698: LD_VAR 0 14
115702: PUSH
115703: LD_VAR 0 8
115707: ARRAY
115708: PUSH
115709: LD_VAR 0 14
115713: PPUSH
115714: LD_INT 58
115716: PUSH
115717: EMPTY
115718: LIST
115719: PPUSH
115720: CALL_OW 72
115724: IN
115725: NOT
115726: IFFALSE 115782
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115728: LD_VAR 0 4
115732: PUSH
115733: LD_VAR 0 7
115737: ARRAY
115738: PPUSH
115739: LD_VAR 0 14
115743: PUSH
115744: LD_VAR 0 8
115748: ARRAY
115749: PPUSH
115750: CALL_OW 115
// attacking := true ;
115754: LD_ADDR_VAR 0 29
115758: PUSH
115759: LD_INT 1
115761: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115762: LD_VAR 0 4
115766: PUSH
115767: LD_VAR 0 7
115771: ARRAY
115772: PPUSH
115773: LD_INT 71
115775: PPUSH
115776: CALL_OW 109
// continue ;
115780: GO 115695
// end ; end ;
115782: GO 115695
115784: POP
115785: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115786: LD_VAR 0 4
115790: PUSH
115791: LD_VAR 0 7
115795: ARRAY
115796: PPUSH
115797: CALL_OW 257
115801: PUSH
115802: LD_INT 8
115804: EQUAL
115805: PUSH
115806: LD_VAR 0 4
115810: PUSH
115811: LD_VAR 0 7
115815: ARRAY
115816: PPUSH
115817: CALL_OW 264
115821: PUSH
115822: LD_INT 28
115824: PUSH
115825: LD_INT 45
115827: PUSH
115828: LD_INT 7
115830: PUSH
115831: LD_INT 47
115833: PUSH
115834: EMPTY
115835: LIST
115836: LIST
115837: LIST
115838: LIST
115839: IN
115840: OR
115841: IFFALSE 116097
// begin attacking := false ;
115843: LD_ADDR_VAR 0 29
115847: PUSH
115848: LD_INT 0
115850: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115851: LD_VAR 0 14
115855: PUSH
115856: LD_INT 1
115858: ARRAY
115859: PPUSH
115860: CALL_OW 266
115864: PUSH
115865: LD_INT 32
115867: PUSH
115868: LD_INT 31
115870: PUSH
115871: LD_INT 33
115873: PUSH
115874: LD_INT 4
115876: PUSH
115877: LD_INT 5
115879: PUSH
115880: EMPTY
115881: LIST
115882: LIST
115883: LIST
115884: LIST
115885: LIST
115886: IN
115887: IFFALSE 116073
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115889: LD_ADDR_VAR 0 9
115893: PUSH
115894: LD_VAR 0 14
115898: PUSH
115899: LD_INT 1
115901: ARRAY
115902: PPUSH
115903: CALL_OW 266
115907: PPUSH
115908: LD_VAR 0 14
115912: PUSH
115913: LD_INT 1
115915: ARRAY
115916: PPUSH
115917: CALL_OW 250
115921: PPUSH
115922: LD_VAR 0 14
115926: PUSH
115927: LD_INT 1
115929: ARRAY
115930: PPUSH
115931: CALL_OW 251
115935: PPUSH
115936: LD_VAR 0 14
115940: PUSH
115941: LD_INT 1
115943: ARRAY
115944: PPUSH
115945: CALL_OW 254
115949: PPUSH
115950: LD_VAR 0 14
115954: PUSH
115955: LD_INT 1
115957: ARRAY
115958: PPUSH
115959: CALL_OW 248
115963: PPUSH
115964: LD_INT 0
115966: PPUSH
115967: CALL 78258 0 6
115971: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115972: LD_ADDR_VAR 0 8
115976: PUSH
115977: LD_VAR 0 4
115981: PUSH
115982: LD_VAR 0 7
115986: ARRAY
115987: PPUSH
115988: LD_VAR 0 9
115992: PPUSH
115993: CALL 96928 0 2
115997: ST_TO_ADDR
// if j then
115998: LD_VAR 0 8
116002: IFFALSE 116071
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116004: LD_VAR 0 8
116008: PUSH
116009: LD_INT 1
116011: ARRAY
116012: PPUSH
116013: LD_VAR 0 8
116017: PUSH
116018: LD_INT 2
116020: ARRAY
116021: PPUSH
116022: CALL_OW 488
116026: IFFALSE 116071
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116028: LD_VAR 0 4
116032: PUSH
116033: LD_VAR 0 7
116037: ARRAY
116038: PPUSH
116039: LD_VAR 0 8
116043: PUSH
116044: LD_INT 1
116046: ARRAY
116047: PPUSH
116048: LD_VAR 0 8
116052: PUSH
116053: LD_INT 2
116055: ARRAY
116056: PPUSH
116057: CALL_OW 116
// attacking := true ;
116061: LD_ADDR_VAR 0 29
116065: PUSH
116066: LD_INT 1
116068: ST_TO_ADDR
// continue ;
116069: GO 113444
// end ; end else
116071: GO 116097
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116073: LD_VAR 0 4
116077: PUSH
116078: LD_VAR 0 7
116082: ARRAY
116083: PPUSH
116084: LD_VAR 0 14
116088: PUSH
116089: LD_INT 1
116091: ARRAY
116092: PPUSH
116093: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116097: LD_VAR 0 4
116101: PUSH
116102: LD_VAR 0 7
116106: ARRAY
116107: PPUSH
116108: CALL_OW 265
116112: PUSH
116113: LD_INT 11
116115: EQUAL
116116: IFFALSE 116394
// begin k := 10 ;
116118: LD_ADDR_VAR 0 9
116122: PUSH
116123: LD_INT 10
116125: ST_TO_ADDR
// x := 0 ;
116126: LD_ADDR_VAR 0 10
116130: PUSH
116131: LD_INT 0
116133: ST_TO_ADDR
// if tmp < k then
116134: LD_VAR 0 14
116138: PUSH
116139: LD_VAR 0 9
116143: LESS
116144: IFFALSE 116156
// k := tmp ;
116146: LD_ADDR_VAR 0 9
116150: PUSH
116151: LD_VAR 0 14
116155: ST_TO_ADDR
// for j = k downto 1 do
116156: LD_ADDR_VAR 0 8
116160: PUSH
116161: DOUBLE
116162: LD_VAR 0 9
116166: INC
116167: ST_TO_ADDR
116168: LD_INT 1
116170: PUSH
116171: FOR_DOWNTO
116172: IFFALSE 116247
// begin if GetType ( tmp [ j ] ) = unit_human then
116174: LD_VAR 0 14
116178: PUSH
116179: LD_VAR 0 8
116183: ARRAY
116184: PPUSH
116185: CALL_OW 247
116189: PUSH
116190: LD_INT 1
116192: EQUAL
116193: IFFALSE 116245
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116195: LD_VAR 0 4
116199: PUSH
116200: LD_VAR 0 7
116204: ARRAY
116205: PPUSH
116206: LD_VAR 0 14
116210: PUSH
116211: LD_VAR 0 8
116215: ARRAY
116216: PPUSH
116217: CALL 97199 0 2
// x := tmp [ j ] ;
116221: LD_ADDR_VAR 0 10
116225: PUSH
116226: LD_VAR 0 14
116230: PUSH
116231: LD_VAR 0 8
116235: ARRAY
116236: ST_TO_ADDR
// attacking := true ;
116237: LD_ADDR_VAR 0 29
116241: PUSH
116242: LD_INT 1
116244: ST_TO_ADDR
// end ; end ;
116245: GO 116171
116247: POP
116248: POP
// if not x then
116249: LD_VAR 0 10
116253: NOT
116254: IFFALSE 116394
// begin attacking := true ;
116256: LD_ADDR_VAR 0 29
116260: PUSH
116261: LD_INT 1
116263: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116264: LD_VAR 0 4
116268: PUSH
116269: LD_VAR 0 7
116273: ARRAY
116274: PPUSH
116275: CALL_OW 250
116279: PPUSH
116280: LD_VAR 0 4
116284: PUSH
116285: LD_VAR 0 7
116289: ARRAY
116290: PPUSH
116291: CALL_OW 251
116295: PPUSH
116296: CALL_OW 546
116300: PUSH
116301: LD_INT 2
116303: ARRAY
116304: PUSH
116305: LD_VAR 0 14
116309: PUSH
116310: LD_INT 1
116312: ARRAY
116313: PPUSH
116314: CALL_OW 250
116318: PPUSH
116319: LD_VAR 0 14
116323: PUSH
116324: LD_INT 1
116326: ARRAY
116327: PPUSH
116328: CALL_OW 251
116332: PPUSH
116333: CALL_OW 546
116337: PUSH
116338: LD_INT 2
116340: ARRAY
116341: EQUAL
116342: IFFALSE 116370
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116344: LD_VAR 0 4
116348: PUSH
116349: LD_VAR 0 7
116353: ARRAY
116354: PPUSH
116355: LD_VAR 0 14
116359: PUSH
116360: LD_INT 1
116362: ARRAY
116363: PPUSH
116364: CALL 97199 0 2
116368: GO 116394
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116370: LD_VAR 0 4
116374: PUSH
116375: LD_VAR 0 7
116379: ARRAY
116380: PPUSH
116381: LD_VAR 0 14
116385: PUSH
116386: LD_INT 1
116388: ARRAY
116389: PPUSH
116390: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116394: LD_VAR 0 4
116398: PUSH
116399: LD_VAR 0 7
116403: ARRAY
116404: PPUSH
116405: CALL_OW 264
116409: PUSH
116410: LD_INT 29
116412: EQUAL
116413: IFFALSE 116779
// begin if WantsToAttack ( group [ i ] ) in bombed then
116415: LD_VAR 0 4
116419: PUSH
116420: LD_VAR 0 7
116424: ARRAY
116425: PPUSH
116426: CALL_OW 319
116430: PUSH
116431: LD_VAR 0 28
116435: IN
116436: IFFALSE 116440
// continue ;
116438: GO 113444
// k := 8 ;
116440: LD_ADDR_VAR 0 9
116444: PUSH
116445: LD_INT 8
116447: ST_TO_ADDR
// x := 0 ;
116448: LD_ADDR_VAR 0 10
116452: PUSH
116453: LD_INT 0
116455: ST_TO_ADDR
// if tmp < k then
116456: LD_VAR 0 14
116460: PUSH
116461: LD_VAR 0 9
116465: LESS
116466: IFFALSE 116478
// k := tmp ;
116468: LD_ADDR_VAR 0 9
116472: PUSH
116473: LD_VAR 0 14
116477: ST_TO_ADDR
// for j = 1 to k do
116478: LD_ADDR_VAR 0 8
116482: PUSH
116483: DOUBLE
116484: LD_INT 1
116486: DEC
116487: ST_TO_ADDR
116488: LD_VAR 0 9
116492: PUSH
116493: FOR_TO
116494: IFFALSE 116626
// begin if GetType ( tmp [ j ] ) = unit_building then
116496: LD_VAR 0 14
116500: PUSH
116501: LD_VAR 0 8
116505: ARRAY
116506: PPUSH
116507: CALL_OW 247
116511: PUSH
116512: LD_INT 3
116514: EQUAL
116515: IFFALSE 116624
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116517: LD_VAR 0 14
116521: PUSH
116522: LD_VAR 0 8
116526: ARRAY
116527: PUSH
116528: LD_VAR 0 28
116532: IN
116533: NOT
116534: PUSH
116535: LD_VAR 0 14
116539: PUSH
116540: LD_VAR 0 8
116544: ARRAY
116545: PPUSH
116546: CALL_OW 313
116550: AND
116551: IFFALSE 116624
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116553: LD_VAR 0 4
116557: PUSH
116558: LD_VAR 0 7
116562: ARRAY
116563: PPUSH
116564: LD_VAR 0 14
116568: PUSH
116569: LD_VAR 0 8
116573: ARRAY
116574: PPUSH
116575: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116579: LD_ADDR_VAR 0 28
116583: PUSH
116584: LD_VAR 0 28
116588: PPUSH
116589: LD_VAR 0 28
116593: PUSH
116594: LD_INT 1
116596: PLUS
116597: PPUSH
116598: LD_VAR 0 14
116602: PUSH
116603: LD_VAR 0 8
116607: ARRAY
116608: PPUSH
116609: CALL_OW 1
116613: ST_TO_ADDR
// attacking := true ;
116614: LD_ADDR_VAR 0 29
116618: PUSH
116619: LD_INT 1
116621: ST_TO_ADDR
// break ;
116622: GO 116626
// end ; end ;
116624: GO 116493
116626: POP
116627: POP
// if not attacking and f_attack_depot then
116628: LD_VAR 0 29
116632: NOT
116633: PUSH
116634: LD_VAR 0 25
116638: AND
116639: IFFALSE 116734
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116641: LD_ADDR_VAR 0 13
116645: PUSH
116646: LD_VAR 0 14
116650: PPUSH
116651: LD_INT 2
116653: PUSH
116654: LD_INT 30
116656: PUSH
116657: LD_INT 0
116659: PUSH
116660: EMPTY
116661: LIST
116662: LIST
116663: PUSH
116664: LD_INT 30
116666: PUSH
116667: LD_INT 1
116669: PUSH
116670: EMPTY
116671: LIST
116672: LIST
116673: PUSH
116674: EMPTY
116675: LIST
116676: LIST
116677: LIST
116678: PPUSH
116679: CALL_OW 72
116683: ST_TO_ADDR
// if z then
116684: LD_VAR 0 13
116688: IFFALSE 116734
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116690: LD_VAR 0 4
116694: PUSH
116695: LD_VAR 0 7
116699: ARRAY
116700: PPUSH
116701: LD_VAR 0 13
116705: PPUSH
116706: LD_VAR 0 4
116710: PUSH
116711: LD_VAR 0 7
116715: ARRAY
116716: PPUSH
116717: CALL_OW 74
116721: PPUSH
116722: CALL_OW 115
// attacking := true ;
116726: LD_ADDR_VAR 0 29
116730: PUSH
116731: LD_INT 1
116733: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116734: LD_VAR 0 4
116738: PUSH
116739: LD_VAR 0 7
116743: ARRAY
116744: PPUSH
116745: CALL_OW 256
116749: PUSH
116750: LD_INT 500
116752: LESS
116753: IFFALSE 116779
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116755: LD_VAR 0 4
116759: PUSH
116760: LD_VAR 0 7
116764: ARRAY
116765: PPUSH
116766: LD_VAR 0 14
116770: PUSH
116771: LD_INT 1
116773: ARRAY
116774: PPUSH
116775: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116779: LD_VAR 0 4
116783: PUSH
116784: LD_VAR 0 7
116788: ARRAY
116789: PPUSH
116790: CALL_OW 264
116794: PUSH
116795: LD_INT 49
116797: EQUAL
116798: IFFALSE 116919
// begin if not HasTask ( group [ i ] ) then
116800: LD_VAR 0 4
116804: PUSH
116805: LD_VAR 0 7
116809: ARRAY
116810: PPUSH
116811: CALL_OW 314
116815: NOT
116816: IFFALSE 116919
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116818: LD_ADDR_VAR 0 9
116822: PUSH
116823: LD_INT 81
116825: PUSH
116826: LD_VAR 0 4
116830: PUSH
116831: LD_VAR 0 7
116835: ARRAY
116836: PPUSH
116837: CALL_OW 255
116841: PUSH
116842: EMPTY
116843: LIST
116844: LIST
116845: PPUSH
116846: CALL_OW 69
116850: PPUSH
116851: LD_VAR 0 4
116855: PUSH
116856: LD_VAR 0 7
116860: ARRAY
116861: PPUSH
116862: CALL_OW 74
116866: ST_TO_ADDR
// if k then
116867: LD_VAR 0 9
116871: IFFALSE 116919
// if GetDistUnits ( group [ i ] , k ) > 10 then
116873: LD_VAR 0 4
116877: PUSH
116878: LD_VAR 0 7
116882: ARRAY
116883: PPUSH
116884: LD_VAR 0 9
116888: PPUSH
116889: CALL_OW 296
116893: PUSH
116894: LD_INT 10
116896: GREATER
116897: IFFALSE 116919
// ComMoveUnit ( group [ i ] , k ) ;
116899: LD_VAR 0 4
116903: PUSH
116904: LD_VAR 0 7
116908: ARRAY
116909: PPUSH
116910: LD_VAR 0 9
116914: PPUSH
116915: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116919: LD_VAR 0 4
116923: PUSH
116924: LD_VAR 0 7
116928: ARRAY
116929: PPUSH
116930: CALL_OW 256
116934: PUSH
116935: LD_INT 250
116937: LESS
116938: PUSH
116939: LD_VAR 0 4
116943: PUSH
116944: LD_VAR 0 7
116948: ARRAY
116949: PUSH
116950: LD_INT 21
116952: PUSH
116953: LD_INT 2
116955: PUSH
116956: EMPTY
116957: LIST
116958: LIST
116959: PUSH
116960: LD_INT 23
116962: PUSH
116963: LD_INT 2
116965: PUSH
116966: EMPTY
116967: LIST
116968: LIST
116969: PUSH
116970: EMPTY
116971: LIST
116972: LIST
116973: PPUSH
116974: CALL_OW 69
116978: IN
116979: AND
116980: IFFALSE 117105
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116982: LD_ADDR_VAR 0 9
116986: PUSH
116987: LD_OWVAR 3
116991: PUSH
116992: LD_VAR 0 4
116996: PUSH
116997: LD_VAR 0 7
117001: ARRAY
117002: DIFF
117003: PPUSH
117004: LD_VAR 0 4
117008: PUSH
117009: LD_VAR 0 7
117013: ARRAY
117014: PPUSH
117015: CALL_OW 74
117019: ST_TO_ADDR
// if not k then
117020: LD_VAR 0 9
117024: NOT
117025: IFFALSE 117029
// continue ;
117027: GO 113444
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117029: LD_VAR 0 9
117033: PUSH
117034: LD_INT 81
117036: PUSH
117037: LD_VAR 0 4
117041: PUSH
117042: LD_VAR 0 7
117046: ARRAY
117047: PPUSH
117048: CALL_OW 255
117052: PUSH
117053: EMPTY
117054: LIST
117055: LIST
117056: PPUSH
117057: CALL_OW 69
117061: IN
117062: PUSH
117063: LD_VAR 0 9
117067: PPUSH
117068: LD_VAR 0 4
117072: PUSH
117073: LD_VAR 0 7
117077: ARRAY
117078: PPUSH
117079: CALL_OW 296
117083: PUSH
117084: LD_INT 5
117086: LESS
117087: AND
117088: IFFALSE 117105
// ComAutodestruct ( group [ i ] ) ;
117090: LD_VAR 0 4
117094: PUSH
117095: LD_VAR 0 7
117099: ARRAY
117100: PPUSH
117101: CALL 97097 0 1
// end ; if f_attack_depot then
117105: LD_VAR 0 25
117109: IFFALSE 117221
// begin k := 6 ;
117111: LD_ADDR_VAR 0 9
117115: PUSH
117116: LD_INT 6
117118: ST_TO_ADDR
// if tmp < k then
117119: LD_VAR 0 14
117123: PUSH
117124: LD_VAR 0 9
117128: LESS
117129: IFFALSE 117141
// k := tmp ;
117131: LD_ADDR_VAR 0 9
117135: PUSH
117136: LD_VAR 0 14
117140: ST_TO_ADDR
// for j = 1 to k do
117141: LD_ADDR_VAR 0 8
117145: PUSH
117146: DOUBLE
117147: LD_INT 1
117149: DEC
117150: ST_TO_ADDR
117151: LD_VAR 0 9
117155: PUSH
117156: FOR_TO
117157: IFFALSE 117219
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117159: LD_VAR 0 8
117163: PPUSH
117164: CALL_OW 266
117168: PUSH
117169: LD_INT 0
117171: PUSH
117172: LD_INT 1
117174: PUSH
117175: EMPTY
117176: LIST
117177: LIST
117178: IN
117179: IFFALSE 117217
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117181: LD_VAR 0 4
117185: PUSH
117186: LD_VAR 0 7
117190: ARRAY
117191: PPUSH
117192: LD_VAR 0 14
117196: PUSH
117197: LD_VAR 0 8
117201: ARRAY
117202: PPUSH
117203: CALL_OW 115
// attacking := true ;
117207: LD_ADDR_VAR 0 29
117211: PUSH
117212: LD_INT 1
117214: ST_TO_ADDR
// break ;
117215: GO 117219
// end ;
117217: GO 117156
117219: POP
117220: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117221: LD_VAR 0 4
117225: PUSH
117226: LD_VAR 0 7
117230: ARRAY
117231: PPUSH
117232: CALL_OW 302
117236: PUSH
117237: LD_VAR 0 29
117241: NOT
117242: AND
117243: IFFALSE 117565
// begin if GetTag ( group [ i ] ) = 71 then
117245: LD_VAR 0 4
117249: PUSH
117250: LD_VAR 0 7
117254: ARRAY
117255: PPUSH
117256: CALL_OW 110
117260: PUSH
117261: LD_INT 71
117263: EQUAL
117264: IFFALSE 117305
// begin if HasTask ( group [ i ] ) then
117266: LD_VAR 0 4
117270: PUSH
117271: LD_VAR 0 7
117275: ARRAY
117276: PPUSH
117277: CALL_OW 314
117281: IFFALSE 117287
// continue else
117283: GO 113444
117285: GO 117305
// SetTag ( group [ i ] , 0 ) ;
117287: LD_VAR 0 4
117291: PUSH
117292: LD_VAR 0 7
117296: ARRAY
117297: PPUSH
117298: LD_INT 0
117300: PPUSH
117301: CALL_OW 109
// end ; k := 8 ;
117305: LD_ADDR_VAR 0 9
117309: PUSH
117310: LD_INT 8
117312: ST_TO_ADDR
// x := 0 ;
117313: LD_ADDR_VAR 0 10
117317: PUSH
117318: LD_INT 0
117320: ST_TO_ADDR
// if tmp < k then
117321: LD_VAR 0 14
117325: PUSH
117326: LD_VAR 0 9
117330: LESS
117331: IFFALSE 117343
// k := tmp ;
117333: LD_ADDR_VAR 0 9
117337: PUSH
117338: LD_VAR 0 14
117342: ST_TO_ADDR
// for j = 1 to k do
117343: LD_ADDR_VAR 0 8
117347: PUSH
117348: DOUBLE
117349: LD_INT 1
117351: DEC
117352: ST_TO_ADDR
117353: LD_VAR 0 9
117357: PUSH
117358: FOR_TO
117359: IFFALSE 117457
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117361: LD_VAR 0 14
117365: PUSH
117366: LD_VAR 0 8
117370: ARRAY
117371: PPUSH
117372: CALL_OW 247
117376: PUSH
117377: LD_INT 1
117379: EQUAL
117380: PUSH
117381: LD_VAR 0 14
117385: PUSH
117386: LD_VAR 0 8
117390: ARRAY
117391: PPUSH
117392: CALL_OW 256
117396: PUSH
117397: LD_INT 250
117399: LESS
117400: PUSH
117401: LD_VAR 0 20
117405: AND
117406: PUSH
117407: LD_VAR 0 20
117411: NOT
117412: PUSH
117413: LD_VAR 0 14
117417: PUSH
117418: LD_VAR 0 8
117422: ARRAY
117423: PPUSH
117424: CALL_OW 256
117428: PUSH
117429: LD_INT 250
117431: GREATEREQUAL
117432: AND
117433: OR
117434: AND
117435: IFFALSE 117455
// begin x := tmp [ j ] ;
117437: LD_ADDR_VAR 0 10
117441: PUSH
117442: LD_VAR 0 14
117446: PUSH
117447: LD_VAR 0 8
117451: ARRAY
117452: ST_TO_ADDR
// break ;
117453: GO 117457
// end ;
117455: GO 117358
117457: POP
117458: POP
// if x then
117459: LD_VAR 0 10
117463: IFFALSE 117487
// ComAttackUnit ( group [ i ] , x ) else
117465: LD_VAR 0 4
117469: PUSH
117470: LD_VAR 0 7
117474: ARRAY
117475: PPUSH
117476: LD_VAR 0 10
117480: PPUSH
117481: CALL_OW 115
117485: GO 117511
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117487: LD_VAR 0 4
117491: PUSH
117492: LD_VAR 0 7
117496: ARRAY
117497: PPUSH
117498: LD_VAR 0 14
117502: PUSH
117503: LD_INT 1
117505: ARRAY
117506: PPUSH
117507: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117511: LD_VAR 0 4
117515: PUSH
117516: LD_VAR 0 7
117520: ARRAY
117521: PPUSH
117522: CALL_OW 314
117526: NOT
117527: IFFALSE 117565
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117529: LD_VAR 0 4
117533: PUSH
117534: LD_VAR 0 7
117538: ARRAY
117539: PPUSH
117540: LD_VAR 0 14
117544: PPUSH
117545: LD_VAR 0 4
117549: PUSH
117550: LD_VAR 0 7
117554: ARRAY
117555: PPUSH
117556: CALL_OW 74
117560: PPUSH
117561: CALL_OW 115
// end ; end ; end ;
117565: GO 113444
117567: POP
117568: POP
// wait ( 0 0$2 ) ;
117569: LD_INT 70
117571: PPUSH
117572: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117576: LD_VAR 0 4
117580: NOT
117581: PUSH
117582: LD_VAR 0 4
117586: PUSH
117587: EMPTY
117588: EQUAL
117589: OR
117590: PUSH
117591: LD_INT 81
117593: PUSH
117594: LD_VAR 0 35
117598: PUSH
117599: EMPTY
117600: LIST
117601: LIST
117602: PPUSH
117603: CALL_OW 69
117607: NOT
117608: OR
117609: IFFALSE 113429
// end ;
117611: LD_VAR 0 2
117615: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
117616: LD_INT 0
117618: PPUSH
117619: PPUSH
117620: PPUSH
117621: PPUSH
117622: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
117623: LD_VAR 0 1
117627: NOT
117628: PUSH
117629: LD_EXP 110
117633: PUSH
117634: LD_VAR 0 1
117638: ARRAY
117639: NOT
117640: OR
117641: PUSH
117642: LD_VAR 0 2
117646: NOT
117647: OR
117648: PUSH
117649: LD_VAR 0 3
117653: NOT
117654: OR
117655: IFFALSE 117659
// exit ;
117657: GO 118172
// side := mc_sides [ base ] ;
117659: LD_ADDR_VAR 0 6
117663: PUSH
117664: LD_EXP 136
117668: PUSH
117669: LD_VAR 0 1
117673: ARRAY
117674: ST_TO_ADDR
// if not side then
117675: LD_VAR 0 6
117679: NOT
117680: IFFALSE 117684
// exit ;
117682: GO 118172
// for i in solds do
117684: LD_ADDR_VAR 0 7
117688: PUSH
117689: LD_VAR 0 2
117693: PUSH
117694: FOR_IN
117695: IFFALSE 117756
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117697: LD_VAR 0 7
117701: PPUSH
117702: CALL_OW 310
117706: PPUSH
117707: CALL_OW 266
117711: PUSH
117712: LD_INT 32
117714: PUSH
117715: LD_INT 31
117717: PUSH
117718: EMPTY
117719: LIST
117720: LIST
117721: IN
117722: IFFALSE 117742
// solds := solds diff i else
117724: LD_ADDR_VAR 0 2
117728: PUSH
117729: LD_VAR 0 2
117733: PUSH
117734: LD_VAR 0 7
117738: DIFF
117739: ST_TO_ADDR
117740: GO 117754
// SetTag ( i , 18 ) ;
117742: LD_VAR 0 7
117746: PPUSH
117747: LD_INT 18
117749: PPUSH
117750: CALL_OW 109
117754: GO 117694
117756: POP
117757: POP
// if not solds then
117758: LD_VAR 0 2
117762: NOT
117763: IFFALSE 117767
// exit ;
117765: GO 118172
// repeat wait ( 0 0$1 ) ;
117767: LD_INT 35
117769: PPUSH
117770: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
117774: LD_ADDR_VAR 0 5
117778: PUSH
117779: LD_VAR 0 6
117783: PPUSH
117784: LD_VAR 0 3
117788: PPUSH
117789: CALL 66812 0 2
117793: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117794: LD_EXP 110
117798: PUSH
117799: LD_VAR 0 1
117803: ARRAY
117804: NOT
117805: PUSH
117806: LD_EXP 110
117810: PUSH
117811: LD_VAR 0 1
117815: ARRAY
117816: PUSH
117817: EMPTY
117818: EQUAL
117819: OR
117820: IFFALSE 117857
// begin for i in solds do
117822: LD_ADDR_VAR 0 7
117826: PUSH
117827: LD_VAR 0 2
117831: PUSH
117832: FOR_IN
117833: IFFALSE 117846
// ComStop ( i ) ;
117835: LD_VAR 0 7
117839: PPUSH
117840: CALL_OW 141
117844: GO 117832
117846: POP
117847: POP
// solds := [ ] ;
117848: LD_ADDR_VAR 0 2
117852: PUSH
117853: EMPTY
117854: ST_TO_ADDR
// exit ;
117855: GO 118172
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
117857: LD_VAR 0 5
117861: NOT
117862: PUSH
117863: LD_VAR 0 5
117867: PUSH
117868: LD_INT 3
117870: GREATER
117871: OR
117872: PUSH
117873: LD_EXP 132
117877: PUSH
117878: LD_VAR 0 1
117882: ARRAY
117883: OR
117884: IFFALSE 117925
// begin for i in solds do
117886: LD_ADDR_VAR 0 7
117890: PUSH
117891: LD_VAR 0 2
117895: PUSH
117896: FOR_IN
117897: IFFALSE 117921
// if HasTask ( i ) then
117899: LD_VAR 0 7
117903: PPUSH
117904: CALL_OW 314
117908: IFFALSE 117919
// ComStop ( i ) ;
117910: LD_VAR 0 7
117914: PPUSH
117915: CALL_OW 141
117919: GO 117896
117921: POP
117922: POP
// break ;
117923: GO 118160
// end ; for i in solds do
117925: LD_ADDR_VAR 0 7
117929: PUSH
117930: LD_VAR 0 2
117934: PUSH
117935: FOR_IN
117936: IFFALSE 118152
// begin if IsInUnit ( i ) then
117938: LD_VAR 0 7
117942: PPUSH
117943: CALL_OW 310
117947: IFFALSE 117958
// ComExitBuilding ( i ) ;
117949: LD_VAR 0 7
117953: PPUSH
117954: CALL_OW 122
// if GetLives ( i ) > 333 then
117958: LD_VAR 0 7
117962: PPUSH
117963: CALL_OW 256
117967: PUSH
117968: LD_INT 333
117970: GREATER
117971: IFFALSE 117999
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
117973: LD_VAR 0 7
117977: PPUSH
117978: LD_VAR 0 5
117982: PPUSH
117983: LD_VAR 0 7
117987: PPUSH
117988: CALL_OW 74
117992: PPUSH
117993: CALL_OW 115
117997: GO 118150
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117999: LD_ADDR_VAR 0 8
118003: PUSH
118004: LD_EXP 110
118008: PUSH
118009: LD_VAR 0 1
118013: ARRAY
118014: PPUSH
118015: LD_INT 2
118017: PUSH
118018: LD_INT 30
118020: PUSH
118021: LD_INT 0
118023: PUSH
118024: EMPTY
118025: LIST
118026: LIST
118027: PUSH
118028: LD_INT 30
118030: PUSH
118031: LD_INT 1
118033: PUSH
118034: EMPTY
118035: LIST
118036: LIST
118037: PUSH
118038: LD_INT 30
118040: PUSH
118041: LD_INT 6
118043: PUSH
118044: EMPTY
118045: LIST
118046: LIST
118047: PUSH
118048: EMPTY
118049: LIST
118050: LIST
118051: LIST
118052: LIST
118053: PPUSH
118054: CALL_OW 72
118058: PPUSH
118059: LD_VAR 0 7
118063: PPUSH
118064: CALL_OW 74
118068: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118069: LD_VAR 0 7
118073: PPUSH
118074: LD_VAR 0 8
118078: PPUSH
118079: CALL_OW 250
118083: PPUSH
118084: LD_INT 3
118086: PPUSH
118087: LD_INT 5
118089: PPUSH
118090: CALL_OW 272
118094: PPUSH
118095: LD_VAR 0 8
118099: PPUSH
118100: CALL_OW 251
118104: PPUSH
118105: LD_INT 3
118107: PPUSH
118108: LD_INT 5
118110: PPUSH
118111: CALL_OW 273
118115: PPUSH
118116: CALL_OW 111
// SetTag ( i , 0 ) ;
118120: LD_VAR 0 7
118124: PPUSH
118125: LD_INT 0
118127: PPUSH
118128: CALL_OW 109
// solds := solds diff i ;
118132: LD_ADDR_VAR 0 2
118136: PUSH
118137: LD_VAR 0 2
118141: PUSH
118142: LD_VAR 0 7
118146: DIFF
118147: ST_TO_ADDR
// continue ;
118148: GO 117935
// end ; end ;
118150: GO 117935
118152: POP
118153: POP
// until solds ;
118154: LD_VAR 0 2
118158: IFFALSE 117767
// MC_Reset ( base , 18 ) ;
118160: LD_VAR 0 1
118164: PPUSH
118165: LD_INT 18
118167: PPUSH
118168: CALL 39120 0 2
// end ;
118172: LD_VAR 0 4
118176: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
118177: LD_INT 0
118179: PPUSH
118180: PPUSH
118181: PPUSH
118182: PPUSH
118183: PPUSH
118184: PPUSH
118185: PPUSH
118186: PPUSH
118187: PPUSH
118188: PPUSH
118189: PPUSH
118190: PPUSH
118191: PPUSH
118192: PPUSH
118193: PPUSH
118194: PPUSH
118195: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118196: LD_ADDR_VAR 0 13
118200: PUSH
118201: LD_EXP 110
118205: PUSH
118206: LD_VAR 0 1
118210: ARRAY
118211: PPUSH
118212: LD_INT 25
118214: PUSH
118215: LD_INT 3
118217: PUSH
118218: EMPTY
118219: LIST
118220: LIST
118221: PPUSH
118222: CALL_OW 72
118226: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118227: LD_EXP 150
118231: PUSH
118232: LD_VAR 0 1
118236: ARRAY
118237: IFFALSE 118261
// mechs := mechs diff mc_remote_driver [ base ] ;
118239: LD_ADDR_VAR 0 13
118243: PUSH
118244: LD_VAR 0 13
118248: PUSH
118249: LD_EXP 150
118253: PUSH
118254: LD_VAR 0 1
118258: ARRAY
118259: DIFF
118260: ST_TO_ADDR
// for i in mechs do
118261: LD_ADDR_VAR 0 5
118265: PUSH
118266: LD_VAR 0 13
118270: PUSH
118271: FOR_IN
118272: IFFALSE 118307
// if GetTag ( i ) > 0 then
118274: LD_VAR 0 5
118278: PPUSH
118279: CALL_OW 110
118283: PUSH
118284: LD_INT 0
118286: GREATER
118287: IFFALSE 118305
// mechs := mechs diff i ;
118289: LD_ADDR_VAR 0 13
118293: PUSH
118294: LD_VAR 0 13
118298: PUSH
118299: LD_VAR 0 5
118303: DIFF
118304: ST_TO_ADDR
118305: GO 118271
118307: POP
118308: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118309: LD_ADDR_VAR 0 9
118313: PUSH
118314: LD_EXP 110
118318: PUSH
118319: LD_VAR 0 1
118323: ARRAY
118324: PPUSH
118325: LD_INT 2
118327: PUSH
118328: LD_INT 25
118330: PUSH
118331: LD_INT 1
118333: PUSH
118334: EMPTY
118335: LIST
118336: LIST
118337: PUSH
118338: LD_INT 25
118340: PUSH
118341: LD_INT 5
118343: PUSH
118344: EMPTY
118345: LIST
118346: LIST
118347: PUSH
118348: LD_INT 25
118350: PUSH
118351: LD_INT 8
118353: PUSH
118354: EMPTY
118355: LIST
118356: LIST
118357: PUSH
118358: LD_INT 25
118360: PUSH
118361: LD_INT 9
118363: PUSH
118364: EMPTY
118365: LIST
118366: LIST
118367: PUSH
118368: EMPTY
118369: LIST
118370: LIST
118371: LIST
118372: LIST
118373: LIST
118374: PPUSH
118375: CALL_OW 72
118379: ST_TO_ADDR
// if not defenders and not solds then
118380: LD_VAR 0 2
118384: NOT
118385: PUSH
118386: LD_VAR 0 9
118390: NOT
118391: AND
118392: IFFALSE 118396
// exit ;
118394: GO 120022
// depot_under_attack := false ;
118396: LD_ADDR_VAR 0 17
118400: PUSH
118401: LD_INT 0
118403: ST_TO_ADDR
// sold_defenders := [ ] ;
118404: LD_ADDR_VAR 0 18
118408: PUSH
118409: EMPTY
118410: ST_TO_ADDR
// if mechs then
118411: LD_VAR 0 13
118415: IFFALSE 118544
// for i in defenders do
118417: LD_ADDR_VAR 0 5
118421: PUSH
118422: LD_VAR 0 2
118426: PUSH
118427: FOR_IN
118428: IFFALSE 118542
// begin SetTag ( i , 20 ) ;
118430: LD_VAR 0 5
118434: PPUSH
118435: LD_INT 20
118437: PPUSH
118438: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
118442: LD_VAR 0 5
118446: PPUSH
118447: CALL_OW 263
118451: PUSH
118452: LD_INT 1
118454: EQUAL
118455: PUSH
118456: LD_VAR 0 5
118460: PPUSH
118461: CALL_OW 311
118465: NOT
118466: AND
118467: PUSH
118468: LD_VAR 0 13
118472: AND
118473: IFFALSE 118540
// begin un := mechs [ 1 ] ;
118475: LD_ADDR_VAR 0 11
118479: PUSH
118480: LD_VAR 0 13
118484: PUSH
118485: LD_INT 1
118487: ARRAY
118488: ST_TO_ADDR
// ComExitBuilding ( un ) ;
118489: LD_VAR 0 11
118493: PPUSH
118494: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
118498: LD_VAR 0 11
118502: PPUSH
118503: LD_VAR 0 5
118507: PPUSH
118508: CALL_OW 180
// SetTag ( un , 19 ) ;
118512: LD_VAR 0 11
118516: PPUSH
118517: LD_INT 19
118519: PPUSH
118520: CALL_OW 109
// mechs := mechs diff un ;
118524: LD_ADDR_VAR 0 13
118528: PUSH
118529: LD_VAR 0 13
118533: PUSH
118534: LD_VAR 0 11
118538: DIFF
118539: ST_TO_ADDR
// end ; end ;
118540: GO 118427
118542: POP
118543: POP
// if solds then
118544: LD_VAR 0 9
118548: IFFALSE 118607
// for i in solds do
118550: LD_ADDR_VAR 0 5
118554: PUSH
118555: LD_VAR 0 9
118559: PUSH
118560: FOR_IN
118561: IFFALSE 118605
// if not GetTag ( i ) then
118563: LD_VAR 0 5
118567: PPUSH
118568: CALL_OW 110
118572: NOT
118573: IFFALSE 118603
// begin defenders := defenders union i ;
118575: LD_ADDR_VAR 0 2
118579: PUSH
118580: LD_VAR 0 2
118584: PUSH
118585: LD_VAR 0 5
118589: UNION
118590: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118591: LD_VAR 0 5
118595: PPUSH
118596: LD_INT 18
118598: PPUSH
118599: CALL_OW 109
// end ;
118603: GO 118560
118605: POP
118606: POP
// repeat wait ( 0 0$1 ) ;
118607: LD_INT 35
118609: PPUSH
118610: CALL_OW 67
// enemy := mc_scan [ base ] ;
118614: LD_ADDR_VAR 0 3
118618: PUSH
118619: LD_EXP 133
118623: PUSH
118624: LD_VAR 0 1
118628: ARRAY
118629: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118630: LD_EXP 110
118634: PUSH
118635: LD_VAR 0 1
118639: ARRAY
118640: NOT
118641: PUSH
118642: LD_EXP 110
118646: PUSH
118647: LD_VAR 0 1
118651: ARRAY
118652: PUSH
118653: EMPTY
118654: EQUAL
118655: OR
118656: IFFALSE 118693
// begin for i in defenders do
118658: LD_ADDR_VAR 0 5
118662: PUSH
118663: LD_VAR 0 2
118667: PUSH
118668: FOR_IN
118669: IFFALSE 118682
// ComStop ( i ) ;
118671: LD_VAR 0 5
118675: PPUSH
118676: CALL_OW 141
118680: GO 118668
118682: POP
118683: POP
// defenders := [ ] ;
118684: LD_ADDR_VAR 0 2
118688: PUSH
118689: EMPTY
118690: ST_TO_ADDR
// exit ;
118691: GO 120022
// end ; for i in defenders do
118693: LD_ADDR_VAR 0 5
118697: PUSH
118698: LD_VAR 0 2
118702: PUSH
118703: FOR_IN
118704: IFFALSE 119522
// begin e := NearestUnitToUnit ( enemy , i ) ;
118706: LD_ADDR_VAR 0 14
118710: PUSH
118711: LD_VAR 0 3
118715: PPUSH
118716: LD_VAR 0 5
118720: PPUSH
118721: CALL_OW 74
118725: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118726: LD_ADDR_VAR 0 8
118730: PUSH
118731: LD_EXP 110
118735: PUSH
118736: LD_VAR 0 1
118740: ARRAY
118741: PPUSH
118742: LD_INT 2
118744: PUSH
118745: LD_INT 30
118747: PUSH
118748: LD_INT 0
118750: PUSH
118751: EMPTY
118752: LIST
118753: LIST
118754: PUSH
118755: LD_INT 30
118757: PUSH
118758: LD_INT 1
118760: PUSH
118761: EMPTY
118762: LIST
118763: LIST
118764: PUSH
118765: EMPTY
118766: LIST
118767: LIST
118768: LIST
118769: PPUSH
118770: CALL_OW 72
118774: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118775: LD_ADDR_VAR 0 17
118779: PUSH
118780: LD_VAR 0 8
118784: NOT
118785: PUSH
118786: LD_VAR 0 8
118790: PPUSH
118791: LD_INT 3
118793: PUSH
118794: LD_INT 24
118796: PUSH
118797: LD_INT 600
118799: PUSH
118800: EMPTY
118801: LIST
118802: LIST
118803: PUSH
118804: EMPTY
118805: LIST
118806: LIST
118807: PPUSH
118808: CALL_OW 72
118812: OR
118813: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118814: LD_VAR 0 5
118818: PPUSH
118819: CALL_OW 247
118823: PUSH
118824: LD_INT 2
118826: DOUBLE
118827: EQUAL
118828: IFTRUE 118832
118830: GO 119228
118832: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118833: LD_VAR 0 5
118837: PPUSH
118838: CALL_OW 256
118842: PUSH
118843: LD_INT 650
118845: GREATER
118846: PUSH
118847: LD_VAR 0 5
118851: PPUSH
118852: LD_VAR 0 14
118856: PPUSH
118857: CALL_OW 296
118861: PUSH
118862: LD_INT 40
118864: LESS
118865: PUSH
118866: LD_VAR 0 14
118870: PPUSH
118871: LD_EXP 135
118875: PUSH
118876: LD_VAR 0 1
118880: ARRAY
118881: PPUSH
118882: CALL_OW 308
118886: OR
118887: AND
118888: IFFALSE 119010
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118890: LD_VAR 0 5
118894: PPUSH
118895: CALL_OW 262
118899: PUSH
118900: LD_INT 1
118902: EQUAL
118903: PUSH
118904: LD_VAR 0 5
118908: PPUSH
118909: CALL_OW 261
118913: PUSH
118914: LD_INT 30
118916: LESS
118917: AND
118918: PUSH
118919: LD_VAR 0 8
118923: AND
118924: IFFALSE 118994
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118926: LD_VAR 0 5
118930: PPUSH
118931: LD_VAR 0 8
118935: PPUSH
118936: LD_VAR 0 5
118940: PPUSH
118941: CALL_OW 74
118945: PPUSH
118946: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118950: LD_VAR 0 5
118954: PPUSH
118955: LD_VAR 0 8
118959: PPUSH
118960: LD_VAR 0 5
118964: PPUSH
118965: CALL_OW 74
118969: PPUSH
118970: CALL_OW 296
118974: PUSH
118975: LD_INT 6
118977: LESS
118978: IFFALSE 118992
// SetFuel ( i , 100 ) ;
118980: LD_VAR 0 5
118984: PPUSH
118985: LD_INT 100
118987: PPUSH
118988: CALL_OW 240
// end else
118992: GO 119008
// ComAttackUnit ( i , e ) ;
118994: LD_VAR 0 5
118998: PPUSH
118999: LD_VAR 0 14
119003: PPUSH
119004: CALL_OW 115
// end else
119008: GO 119111
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119010: LD_VAR 0 14
119014: PPUSH
119015: LD_EXP 135
119019: PUSH
119020: LD_VAR 0 1
119024: ARRAY
119025: PPUSH
119026: CALL_OW 308
119030: NOT
119031: PUSH
119032: LD_VAR 0 5
119036: PPUSH
119037: LD_VAR 0 14
119041: PPUSH
119042: CALL_OW 296
119046: PUSH
119047: LD_INT 40
119049: GREATEREQUAL
119050: AND
119051: PUSH
119052: LD_VAR 0 5
119056: PPUSH
119057: CALL_OW 256
119061: PUSH
119062: LD_INT 650
119064: LESSEQUAL
119065: OR
119066: PUSH
119067: LD_VAR 0 5
119071: PPUSH
119072: LD_EXP 134
119076: PUSH
119077: LD_VAR 0 1
119081: ARRAY
119082: PPUSH
119083: CALL_OW 308
119087: NOT
119088: AND
119089: IFFALSE 119111
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119091: LD_VAR 0 5
119095: PPUSH
119096: LD_EXP 134
119100: PUSH
119101: LD_VAR 0 1
119105: ARRAY
119106: PPUSH
119107: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119111: LD_VAR 0 5
119115: PPUSH
119116: CALL_OW 256
119120: PUSH
119121: LD_INT 998
119123: LESS
119124: PUSH
119125: LD_VAR 0 5
119129: PPUSH
119130: CALL_OW 263
119134: PUSH
119135: LD_INT 1
119137: EQUAL
119138: AND
119139: PUSH
119140: LD_VAR 0 5
119144: PPUSH
119145: CALL_OW 311
119149: AND
119150: PUSH
119151: LD_VAR 0 5
119155: PPUSH
119156: LD_EXP 134
119160: PUSH
119161: LD_VAR 0 1
119165: ARRAY
119166: PPUSH
119167: CALL_OW 308
119171: AND
119172: IFFALSE 119226
// begin mech := IsDrivenBy ( i ) ;
119174: LD_ADDR_VAR 0 10
119178: PUSH
119179: LD_VAR 0 5
119183: PPUSH
119184: CALL_OW 311
119188: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119189: LD_VAR 0 10
119193: PPUSH
119194: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119198: LD_VAR 0 10
119202: PPUSH
119203: LD_VAR 0 5
119207: PPUSH
119208: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119212: LD_VAR 0 10
119216: PPUSH
119217: LD_VAR 0 5
119221: PPUSH
119222: CALL_OW 180
// end ; end ; unit_human :
119226: GO 119493
119228: LD_INT 1
119230: DOUBLE
119231: EQUAL
119232: IFTRUE 119236
119234: GO 119492
119236: POP
// begin b := IsInUnit ( i ) ;
119237: LD_ADDR_VAR 0 19
119241: PUSH
119242: LD_VAR 0 5
119246: PPUSH
119247: CALL_OW 310
119251: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119252: LD_ADDR_VAR 0 20
119256: PUSH
119257: LD_VAR 0 19
119261: NOT
119262: PUSH
119263: LD_VAR 0 19
119267: PPUSH
119268: CALL_OW 266
119272: PUSH
119273: LD_INT 32
119275: PUSH
119276: LD_INT 31
119278: PUSH
119279: EMPTY
119280: LIST
119281: LIST
119282: IN
119283: OR
119284: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119285: LD_VAR 0 17
119289: PUSH
119290: LD_VAR 0 2
119294: PPUSH
119295: LD_INT 21
119297: PUSH
119298: LD_INT 2
119300: PUSH
119301: EMPTY
119302: LIST
119303: LIST
119304: PPUSH
119305: CALL_OW 72
119309: PUSH
119310: LD_INT 1
119312: LESSEQUAL
119313: OR
119314: PUSH
119315: LD_VAR 0 20
119319: AND
119320: PUSH
119321: LD_VAR 0 5
119325: PUSH
119326: LD_VAR 0 18
119330: IN
119331: NOT
119332: AND
119333: IFFALSE 119426
// begin if b then
119335: LD_VAR 0 19
119339: IFFALSE 119388
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119341: LD_VAR 0 19
119345: PPUSH
119346: LD_VAR 0 3
119350: PPUSH
119351: LD_VAR 0 19
119355: PPUSH
119356: CALL_OW 74
119360: PPUSH
119361: CALL_OW 296
119365: PUSH
119366: LD_INT 10
119368: LESS
119369: PUSH
119370: LD_VAR 0 19
119374: PPUSH
119375: CALL_OW 461
119379: PUSH
119380: LD_INT 7
119382: NONEQUAL
119383: AND
119384: IFFALSE 119388
// continue ;
119386: GO 118703
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119388: LD_ADDR_VAR 0 18
119392: PUSH
119393: LD_VAR 0 18
119397: PPUSH
119398: LD_VAR 0 18
119402: PUSH
119403: LD_INT 1
119405: PLUS
119406: PPUSH
119407: LD_VAR 0 5
119411: PPUSH
119412: CALL_OW 1
119416: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119417: LD_VAR 0 5
119421: PPUSH
119422: CALL_OW 122
// end ; if sold_defenders then
119426: LD_VAR 0 18
119430: IFFALSE 119490
// if i in sold_defenders then
119432: LD_VAR 0 5
119436: PUSH
119437: LD_VAR 0 18
119441: IN
119442: IFFALSE 119490
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119444: LD_VAR 0 5
119448: PPUSH
119449: CALL_OW 314
119453: NOT
119454: PUSH
119455: LD_VAR 0 5
119459: PPUSH
119460: LD_VAR 0 14
119464: PPUSH
119465: CALL_OW 296
119469: PUSH
119470: LD_INT 30
119472: LESS
119473: AND
119474: IFFALSE 119490
// ComAttackUnit ( i , e ) ;
119476: LD_VAR 0 5
119480: PPUSH
119481: LD_VAR 0 14
119485: PPUSH
119486: CALL_OW 115
// end ; end ; end ;
119490: GO 119493
119492: POP
// if IsDead ( i ) then
119493: LD_VAR 0 5
119497: PPUSH
119498: CALL_OW 301
119502: IFFALSE 119520
// defenders := defenders diff i ;
119504: LD_ADDR_VAR 0 2
119508: PUSH
119509: LD_VAR 0 2
119513: PUSH
119514: LD_VAR 0 5
119518: DIFF
119519: ST_TO_ADDR
// end ;
119520: GO 118703
119522: POP
119523: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119524: LD_VAR 0 3
119528: NOT
119529: PUSH
119530: LD_VAR 0 2
119534: NOT
119535: OR
119536: PUSH
119537: LD_EXP 110
119541: PUSH
119542: LD_VAR 0 1
119546: ARRAY
119547: NOT
119548: OR
119549: IFFALSE 118607
// MC_Reset ( base , 18 ) ;
119551: LD_VAR 0 1
119555: PPUSH
119556: LD_INT 18
119558: PPUSH
119559: CALL 39120 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119563: LD_ADDR_VAR 0 2
119567: PUSH
119568: LD_VAR 0 2
119572: PUSH
119573: LD_VAR 0 2
119577: PPUSH
119578: LD_INT 2
119580: PUSH
119581: LD_INT 25
119583: PUSH
119584: LD_INT 1
119586: PUSH
119587: EMPTY
119588: LIST
119589: LIST
119590: PUSH
119591: LD_INT 25
119593: PUSH
119594: LD_INT 5
119596: PUSH
119597: EMPTY
119598: LIST
119599: LIST
119600: PUSH
119601: LD_INT 25
119603: PUSH
119604: LD_INT 8
119606: PUSH
119607: EMPTY
119608: LIST
119609: LIST
119610: PUSH
119611: LD_INT 25
119613: PUSH
119614: LD_INT 9
119616: PUSH
119617: EMPTY
119618: LIST
119619: LIST
119620: PUSH
119621: EMPTY
119622: LIST
119623: LIST
119624: LIST
119625: LIST
119626: LIST
119627: PPUSH
119628: CALL_OW 72
119632: DIFF
119633: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119634: LD_VAR 0 3
119638: NOT
119639: PUSH
119640: LD_VAR 0 2
119644: PPUSH
119645: LD_INT 21
119647: PUSH
119648: LD_INT 2
119650: PUSH
119651: EMPTY
119652: LIST
119653: LIST
119654: PPUSH
119655: CALL_OW 72
119659: AND
119660: IFFALSE 119998
// begin tmp := FilterByTag ( defenders , 19 ) ;
119662: LD_ADDR_VAR 0 12
119666: PUSH
119667: LD_VAR 0 2
119671: PPUSH
119672: LD_INT 19
119674: PPUSH
119675: CALL 98572 0 2
119679: ST_TO_ADDR
// if tmp then
119680: LD_VAR 0 12
119684: IFFALSE 119754
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119686: LD_ADDR_VAR 0 12
119690: PUSH
119691: LD_VAR 0 12
119695: PPUSH
119696: LD_INT 25
119698: PUSH
119699: LD_INT 3
119701: PUSH
119702: EMPTY
119703: LIST
119704: LIST
119705: PPUSH
119706: CALL_OW 72
119710: ST_TO_ADDR
// if tmp then
119711: LD_VAR 0 12
119715: IFFALSE 119754
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119717: LD_ADDR_EXP 122
119721: PUSH
119722: LD_EXP 122
119726: PPUSH
119727: LD_VAR 0 1
119731: PPUSH
119732: LD_EXP 122
119736: PUSH
119737: LD_VAR 0 1
119741: ARRAY
119742: PUSH
119743: LD_VAR 0 12
119747: UNION
119748: PPUSH
119749: CALL_OW 1
119753: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119754: LD_VAR 0 1
119758: PPUSH
119759: LD_INT 19
119761: PPUSH
119762: CALL 39120 0 2
// repeat wait ( 0 0$1 ) ;
119766: LD_INT 35
119768: PPUSH
119769: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119773: LD_EXP 110
119777: PUSH
119778: LD_VAR 0 1
119782: ARRAY
119783: NOT
119784: PUSH
119785: LD_EXP 110
119789: PUSH
119790: LD_VAR 0 1
119794: ARRAY
119795: PUSH
119796: EMPTY
119797: EQUAL
119798: OR
119799: IFFALSE 119836
// begin for i in defenders do
119801: LD_ADDR_VAR 0 5
119805: PUSH
119806: LD_VAR 0 2
119810: PUSH
119811: FOR_IN
119812: IFFALSE 119825
// ComStop ( i ) ;
119814: LD_VAR 0 5
119818: PPUSH
119819: CALL_OW 141
119823: GO 119811
119825: POP
119826: POP
// defenders := [ ] ;
119827: LD_ADDR_VAR 0 2
119831: PUSH
119832: EMPTY
119833: ST_TO_ADDR
// exit ;
119834: GO 120022
// end ; for i in defenders do
119836: LD_ADDR_VAR 0 5
119840: PUSH
119841: LD_VAR 0 2
119845: PUSH
119846: FOR_IN
119847: IFFALSE 119936
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119849: LD_VAR 0 5
119853: PPUSH
119854: LD_EXP 134
119858: PUSH
119859: LD_VAR 0 1
119863: ARRAY
119864: PPUSH
119865: CALL_OW 308
119869: NOT
119870: IFFALSE 119894
// ComMoveToArea ( i , mc_parking [ base ] ) else
119872: LD_VAR 0 5
119876: PPUSH
119877: LD_EXP 134
119881: PUSH
119882: LD_VAR 0 1
119886: ARRAY
119887: PPUSH
119888: CALL_OW 113
119892: GO 119934
// if GetControl ( i ) = control_manual then
119894: LD_VAR 0 5
119898: PPUSH
119899: CALL_OW 263
119903: PUSH
119904: LD_INT 1
119906: EQUAL
119907: IFFALSE 119934
// if IsDrivenBy ( i ) then
119909: LD_VAR 0 5
119913: PPUSH
119914: CALL_OW 311
119918: IFFALSE 119934
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119920: LD_VAR 0 5
119924: PPUSH
119925: CALL_OW 311
119929: PPUSH
119930: CALL_OW 121
// end ;
119934: GO 119846
119936: POP
119937: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119938: LD_VAR 0 2
119942: PPUSH
119943: LD_INT 95
119945: PUSH
119946: LD_EXP 134
119950: PUSH
119951: LD_VAR 0 1
119955: ARRAY
119956: PUSH
119957: EMPTY
119958: LIST
119959: LIST
119960: PPUSH
119961: CALL_OW 72
119965: PUSH
119966: LD_VAR 0 2
119970: EQUAL
119971: PUSH
119972: LD_EXP 133
119976: PUSH
119977: LD_VAR 0 1
119981: ARRAY
119982: OR
119983: PUSH
119984: LD_EXP 110
119988: PUSH
119989: LD_VAR 0 1
119993: ARRAY
119994: NOT
119995: OR
119996: IFFALSE 119766
// end ; MC_Reset ( base , 19 ) ;
119998: LD_VAR 0 1
120002: PPUSH
120003: LD_INT 19
120005: PPUSH
120006: CALL 39120 0 2
// MC_Reset ( base , 20 ) ;
120010: LD_VAR 0 1
120014: PPUSH
120015: LD_INT 20
120017: PPUSH
120018: CALL 39120 0 2
// end ;
120022: LD_VAR 0 4
120026: RET
