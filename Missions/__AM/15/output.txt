// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33815 0 0
// InitNature ;
  19: CALL 33639 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10881 0 0
// PrepareRussian ;
  40: CALL 6874 0 0
// PrepareLegion ;
  44: CALL 4114 0 0
// PreparePowell ;
  48: CALL 2868 0 0
// PrepareAmerican ;
  52: CALL 1640 0 0
// Action ;
  56: CALL 14788 0 0
// MC_Start ( ) ;
  60: CALL 35927 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 58092 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 58185 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57535 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 57350 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 58092 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 58185 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 22
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 52
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 22
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 52
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_INT 24
 792: PUSH
 793: LD_INT 3
 795: PUSH
 796: LD_INT 3
 798: PUSH
 799: LD_INT 47
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: PUSH
 808: LD_INT 24
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 3
 816: PUSH
 817: LD_INT 47
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: LIST
 835: PPUSH
 836: CALL 57350 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 840: LD_INT 2
 842: PPUSH
 843: LD_INT 5
 845: PPUSH
 846: CALL 57535 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 850: LD_INT 2
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL 57965 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 860: LD_INT 3
 862: PPUSH
 863: LD_INT 10
 865: PUSH
 866: LD_INT 12
 868: PUSH
 869: LD_INT 15
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_OWVAR 67
 881: ARRAY
 882: PPUSH
 883: LD_INT 27
 885: PPUSH
 886: CALL 57032 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 890: LD_INT 3
 892: PPUSH
 893: LD_INT 10
 895: PUSH
 896: LD_INT 11
 898: PUSH
 899: LD_INT 13
 901: PUSH
 902: LD_INT 15
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: PPUSH
 911: CALL 58092 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 915: LD_INT 3
 917: PPUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: PPUSH
 924: CALL 58185 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 928: LD_ADDR_EXP 128
 932: PUSH
 933: LD_EXP 128
 937: PPUSH
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 22
 943: PUSH
 944: LD_INT 8
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 25
 953: PUSH
 954: LD_INT 15
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PPUSH
 965: CALL_OW 69
 969: PPUSH
 970: CALL_OW 1
 974: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 975: LD_INT 3
 977: PPUSH
 978: LD_INT 13
 980: PUSH
 981: LD_INT 2
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 31
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 2
1001: PUSH
1002: LD_INT 1
1004: PUSH
1005: LD_INT 31
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 13
1016: PUSH
1017: LD_INT 3
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 32
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL 57350 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1041: LD_INT 4
1043: PPUSH
1044: LD_INT 10
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: PPUSH
1054: CALL 58092 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1058: LD_INT 4
1060: PPUSH
1061: LD_INT 9
1063: PUSH
1064: EMPTY
1065: LIST
1066: PPUSH
1067: CALL 58185 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1071: LD_INT 4
1073: PPUSH
1074: LD_INT 26
1076: PUSH
1077: LD_INT 74
1079: PUSH
1080: LD_INT 107
1082: PUSH
1083: LD_INT 0
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_INT 32
1094: PUSH
1095: LD_INT 77
1097: PUSH
1098: LD_INT 101
1100: PUSH
1101: LD_INT 4
1103: PUSH
1104: EMPTY
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 32
1112: PUSH
1113: LD_INT 69
1115: PUSH
1116: LD_INT 86
1118: PUSH
1119: LD_INT 4
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 77
1133: PUSH
1134: LD_INT 110
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 27
1148: PUSH
1149: LD_INT 42
1151: PUSH
1152: LD_INT 79
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: LD_INT 29
1166: PUSH
1167: LD_INT 86
1169: PUSH
1170: LD_INT 105
1172: PUSH
1173: LD_INT 2
1175: PUSH
1176: EMPTY
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PUSH
1182: LD_INT 30
1184: PUSH
1185: LD_INT 40
1187: PUSH
1188: LD_INT 75
1190: PUSH
1191: LD_INT 1
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 32
1202: PUSH
1203: LD_INT 80
1205: PUSH
1206: LD_INT 106
1208: PUSH
1209: LD_INT 4
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 32
1220: PUSH
1221: LD_INT 75
1223: PUSH
1224: LD_INT 114
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: PUSH
1236: LD_INT 32
1238: PUSH
1239: LD_INT 82
1241: PUSH
1242: LD_INT 110
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_INT 32
1256: PUSH
1257: LD_INT 62
1259: PUSH
1260: LD_INT 78
1262: PUSH
1263: LD_INT 4
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: PUSH
1272: LD_INT 4
1274: PUSH
1275: LD_INT 39
1277: PUSH
1278: LD_INT 61
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL 57242 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1308: LD_INT 4
1310: PPUSH
1311: LD_INT 5
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: LD_INT 7
1319: PUSH
1320: LD_INT 9
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: PPUSH
1329: CALL 58503 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1333: LD_INT 4
1335: PPUSH
1336: LD_INT 40
1338: PUSH
1339: LD_INT 75
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: LIST
1349: PUSH
1350: LD_INT 86
1352: PUSH
1353: LD_INT 105
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PPUSH
1368: CALL 57674 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1372: LD_INT 4
1374: PPUSH
1375: LD_INT 2
1377: PPUSH
1378: CALL 57965 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 0
1387: PPUSH
1388: CALL 57965 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1392: LD_INT 4
1394: PPUSH
1395: LD_INT 54
1397: PPUSH
1398: LD_INT 85
1400: PPUSH
1401: LD_INT 2
1403: PPUSH
1404: LD_INT 19
1406: PUSH
1407: LD_INT 16
1409: PUSH
1410: LD_INT 17
1412: PUSH
1413: LD_INT 18
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: PPUSH
1422: CALL 58297 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1426: LD_INT 4
1428: PPUSH
1429: LD_INT 3
1431: PUSH
1432: LD_INT 1
1434: PUSH
1435: LD_INT 1
1437: PUSH
1438: LD_INT 5
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: PUSH
1447: LD_INT 4
1449: PUSH
1450: LD_INT 1
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 6
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: PUSH
1465: LD_INT 4
1467: PUSH
1468: LD_INT 1
1470: PUSH
1471: LD_INT 1
1473: PUSH
1474: LD_INT 7
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: PUSH
1483: LD_INT 4
1485: PUSH
1486: LD_INT 1
1488: PUSH
1489: LD_INT 1
1491: PUSH
1492: LD_INT 6
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: PUSH
1501: EMPTY
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: PPUSH
1507: CALL 57350 0 2
// MC_SetTame ( 4 , powellApe ) ;
1511: LD_INT 4
1513: PPUSH
1514: LD_INT 13
1516: PPUSH
1517: CALL 57916 0 2
// end ;
1521: LD_VAR 0 1
1525: RET
// every 0 0$1 trigger debug do var i , tmp ;
1526: LD_EXP 1
1530: IFFALSE 1637
1532: GO 1534
1534: DISABLE
1535: LD_INT 0
1537: PPUSH
1538: PPUSH
// begin enable ;
1539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_INT 22
1547: PUSH
1548: LD_INT 1
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 3
1557: PUSH
1558: LD_INT 21
1560: PUSH
1561: LD_INT 3
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: LD_INT 3
1574: PUSH
1575: LD_INT 24
1577: PUSH
1578: LD_INT 999
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: ST_TO_ADDR
// if not tmp then
1599: LD_VAR 0 2
1603: NOT
1604: IFFALSE 1608
// exit ;
1606: GO 1637
// for i in tmp do
1608: LD_ADDR_VAR 0 1
1612: PUSH
1613: LD_VAR 0 2
1617: PUSH
1618: FOR_IN
1619: IFFALSE 1635
// SetLives ( i , 1000 ) ;
1621: LD_VAR 0 1
1625: PPUSH
1626: LD_INT 1000
1628: PPUSH
1629: CALL_OW 234
1633: GO 1618
1635: POP
1636: POP
// end ; end_of_file
1637: PPOPN 2
1639: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1640: LD_INT 0
1642: PPUSH
// uc_side := 1 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 1
1650: ST_TO_ADDR
// uc_nation := 1 ;
1651: LD_ADDR_OWVAR 21
1655: PUSH
1656: LD_INT 1
1658: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1659: LD_ADDR_EXP 36
1663: PUSH
1664: LD_STRING JMM
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 14_
1675: PPUSH
1676: CALL 63608 0 3
1680: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1681: LD_EXP 4
1685: NOT
1686: PUSH
1687: LD_EXP 4
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PUSH
1696: LD_INT 1
1698: ARRAY
1699: NOT
1700: OR
1701: IFFALSE 1724
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 1
1711: PPUSH
1712: LD_INT 5
1714: PPUSH
1715: LD_INT 100
1717: PPUSH
1718: CALL 70385 0 5
1722: GO 1783
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1724: LD_EXP 4
1728: PUSH
1729: LD_INT 1
1731: ARRAY
1732: PUSH
1733: LD_INT 1
1735: ARRAY
1736: PPUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 2
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: PPUSH
1750: LD_EXP 4
1754: PUSH
1755: LD_INT 3
1757: ARRAY
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PPUSH
1763: LD_EXP 4
1767: PUSH
1768: LD_INT 4
1770: ARRAY
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PPUSH
1776: LD_INT 30
1778: PPUSH
1779: CALL 70385 0 5
// JMMNewVeh := CreateVehicle ;
1783: LD_ADDR_EXP 53
1787: PUSH
1788: CALL_OW 45
1792: ST_TO_ADDR
// if not JMMNewVeh then
1793: LD_EXP 53
1797: NOT
1798: IFFALSE 1829
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 3
1805: PPUSH
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 5
1811: PPUSH
1812: LD_INT 100
1814: PPUSH
1815: CALL 70385 0 5
// JMMNewVeh := CreateVehicle ;
1819: LD_ADDR_EXP 53
1823: PUSH
1824: CALL_OW 45
1828: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1829: LD_EXP 53
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1841: LD_EXP 53
1845: PPUSH
1846: LD_INT 79
1848: PPUSH
1849: LD_INT 91
1851: PPUSH
1852: LD_INT 0
1854: PPUSH
1855: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1859: LD_EXP 36
1863: PPUSH
1864: LD_EXP 53
1868: PPUSH
1869: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1873: LD_EXP 6
1877: PUSH
1878: LD_EXP 2
1882: NOT
1883: AND
1884: IFFALSE 2142
// begin if not JMMGirlVeh then
1886: LD_EXP 5
1890: NOT
1891: IFFALSE 1914
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1893: LD_INT 3
1895: PPUSH
1896: LD_INT 3
1898: PPUSH
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 9
1904: PPUSH
1905: LD_INT 100
1907: PPUSH
1908: CALL 70385 0 5
1912: GO 1973
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1914: LD_EXP 5
1918: PUSH
1919: LD_INT 1
1921: ARRAY
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: PPUSH
1927: LD_EXP 5
1931: PUSH
1932: LD_INT 2
1934: ARRAY
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PPUSH
1940: LD_EXP 5
1944: PUSH
1945: LD_INT 3
1947: ARRAY
1948: PUSH
1949: LD_INT 1
1951: ARRAY
1952: PPUSH
1953: LD_EXP 5
1957: PUSH
1958: LD_INT 4
1960: ARRAY
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PPUSH
1966: LD_INT 30
1968: PPUSH
1969: CALL 70385 0 5
// GirlNewVeh := CreateVehicle ;
1973: LD_ADDR_EXP 54
1977: PUSH
1978: CALL_OW 45
1982: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1983: LD_EXP 54
1987: PPUSH
1988: LD_INT 4
1990: PPUSH
1991: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1995: LD_EXP 54
1999: PPUSH
2000: LD_INT 82
2002: PPUSH
2003: LD_INT 96
2005: PPUSH
2006: LD_INT 0
2008: PPUSH
2009: CALL_OW 48
// if JMMGirl = 1 then
2013: LD_EXP 7
2017: PUSH
2018: LD_INT 1
2020: EQUAL
2021: IFFALSE 2056
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2023: LD_ADDR_EXP 37
2027: PUSH
2028: LD_STRING Joan
2030: PPUSH
2031: LD_INT 1
2033: PPUSH
2034: LD_STRING 14_
2036: PPUSH
2037: CALL 63608 0 3
2041: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2042: LD_EXP 37
2046: PPUSH
2047: LD_EXP 54
2051: PPUSH
2052: CALL_OW 52
// end ; if JMMGirl = 2 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 2
2063: EQUAL
2064: IFFALSE 2099
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Lisa
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 63608 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 54
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 3 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 3
2106: EQUAL
2107: IFFALSE 2142
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2109: LD_ADDR_EXP 51
2113: PUSH
2114: LD_STRING Connie
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 63608 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2128: LD_EXP 51
2132: PPUSH
2133: LD_EXP 54
2137: PPUSH
2138: CALL_OW 52
// end ; end ; end ;
2142: LD_VAR 0 1
2146: RET
// export function PrepareStevensSquad ; var tmp ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// uc_side := 1 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// uc_nation := 1 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 1
2166: ST_TO_ADDR
// tmp := [ ] ;
2167: LD_ADDR_VAR 0 2
2171: PUSH
2172: EMPTY
2173: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2174: LD_ADDR_EXP 38
2178: PUSH
2179: LD_STRING Stevens
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13f_
2190: PPUSH
2191: CALL 63608 0 3
2195: ST_TO_ADDR
// if not Stevens then
2196: LD_EXP 38
2200: NOT
2201: IFFALSE 2257
// begin hc_name = Baker Smith ;
2203: LD_ADDR_OWVAR 26
2207: PUSH
2208: LD_STRING Baker Smith
2210: ST_TO_ADDR
// hc_gallery =  ;
2211: LD_ADDR_OWVAR 33
2215: PUSH
2216: LD_STRING 
2218: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2219: LD_INT 1
2221: PPUSH
2222: LD_INT 10
2224: PPUSH
2225: CALL_OW 384
// Baker = CreateHuman ;
2229: LD_ADDR_EXP 52
2233: PUSH
2234: CALL_OW 44
2238: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 52
2253: ADD
2254: ST_TO_ADDR
// end else
2255: GO 2273
// tmp := tmp ^ Stevens ;
2257: LD_ADDR_VAR 0 2
2261: PUSH
2262: LD_VAR 0 2
2266: PUSH
2267: LD_EXP 38
2271: ADD
2272: ST_TO_ADDR
// if not Lisa then
2273: LD_EXP 39
2277: NOT
2278: IFFALSE 2324
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2280: LD_ADDR_EXP 39
2284: PUSH
2285: LD_STRING Lisa
2287: PPUSH
2288: LD_EXP 1
2292: NOT
2293: PPUSH
2294: LD_STRING 13f_
2296: PPUSH
2297: CALL 63608 0 3
2301: ST_TO_ADDR
// if Lisa then
2302: LD_EXP 39
2306: IFFALSE 2324
// tmp := tmp ^ Lisa ;
2308: LD_ADDR_VAR 0 2
2312: PUSH
2313: LD_VAR 0 2
2317: PUSH
2318: LD_EXP 39
2322: ADD
2323: ST_TO_ADDR
// end ; if not Donaldson then
2324: LD_EXP 40
2328: NOT
2329: IFFALSE 2375
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2331: LD_ADDR_EXP 40
2335: PUSH
2336: LD_STRING Donaldson
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13f_
2347: PPUSH
2348: CALL 63608 0 3
2352: ST_TO_ADDR
// if Donaldson then
2353: LD_EXP 40
2357: IFFALSE 2375
// tmp := tmp ^ Donaldson ;
2359: LD_ADDR_VAR 0 2
2363: PUSH
2364: LD_VAR 0 2
2368: PUSH
2369: LD_EXP 40
2373: ADD
2374: ST_TO_ADDR
// end ; if not Bobby then
2375: LD_EXP 41
2379: NOT
2380: IFFALSE 2426
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2382: LD_ADDR_EXP 41
2386: PUSH
2387: LD_STRING Bobby
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: LD_STRING 13f_
2398: PPUSH
2399: CALL 63608 0 3
2403: ST_TO_ADDR
// if Bobby then
2404: LD_EXP 41
2408: IFFALSE 2426
// tmp := tmp ^ Bobby ;
2410: LD_ADDR_VAR 0 2
2414: PUSH
2415: LD_VAR 0 2
2419: PUSH
2420: LD_EXP 41
2424: ADD
2425: ST_TO_ADDR
// end ; if not Cyrus then
2426: LD_EXP 42
2430: NOT
2431: IFFALSE 2477
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2433: LD_ADDR_EXP 42
2437: PUSH
2438: LD_STRING Cyrus
2440: PPUSH
2441: LD_EXP 1
2445: NOT
2446: PPUSH
2447: LD_STRING 13f_
2449: PPUSH
2450: CALL 63608 0 3
2454: ST_TO_ADDR
// if Cyrus then
2455: LD_EXP 42
2459: IFFALSE 2477
// tmp := tmp ^ Cyrus ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 2
2470: PUSH
2471: LD_EXP 42
2475: ADD
2476: ST_TO_ADDR
// end ; if not Brown then
2477: LD_EXP 44
2481: NOT
2482: IFFALSE 2528
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Brown
2491: PPUSH
2492: LD_EXP 1
2496: NOT
2497: PPUSH
2498: LD_STRING 13f_
2500: PPUSH
2501: CALL 63608 0 3
2505: ST_TO_ADDR
// if Brown then
2506: LD_EXP 44
2510: IFFALSE 2528
// tmp := tmp ^ Brown ;
2512: LD_ADDR_VAR 0 2
2516: PUSH
2517: LD_VAR 0 2
2521: PUSH
2522: LD_EXP 44
2526: ADD
2527: ST_TO_ADDR
// end ; if not Gladstone then
2528: LD_EXP 45
2532: NOT
2533: IFFALSE 2579
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2535: LD_ADDR_EXP 45
2539: PUSH
2540: LD_STRING Gladstone
2542: PPUSH
2543: LD_EXP 1
2547: NOT
2548: PPUSH
2549: LD_STRING 13f_
2551: PPUSH
2552: CALL 63608 0 3
2556: ST_TO_ADDR
// if Gladstone then
2557: LD_EXP 45
2561: IFFALSE 2579
// tmp := tmp ^ Gladstone ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_VAR 0 2
2572: PUSH
2573: LD_EXP 45
2577: ADD
2578: ST_TO_ADDR
// end ; if not Houten then
2579: LD_EXP 46
2583: NOT
2584: IFFALSE 2630
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2586: LD_ADDR_EXP 46
2590: PUSH
2591: LD_STRING Houten
2593: PPUSH
2594: LD_EXP 1
2598: NOT
2599: PPUSH
2600: LD_STRING 13f_
2602: PPUSH
2603: CALL 63608 0 3
2607: ST_TO_ADDR
// if Houten then
2608: LD_EXP 46
2612: IFFALSE 2630
// tmp := tmp ^ Houten ;
2614: LD_ADDR_VAR 0 2
2618: PUSH
2619: LD_VAR 0 2
2623: PUSH
2624: LD_EXP 46
2628: ADD
2629: ST_TO_ADDR
// end ; if not Cornel then
2630: LD_EXP 47
2634: NOT
2635: IFFALSE 2681
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2637: LD_ADDR_EXP 47
2641: PUSH
2642: LD_STRING Cornel
2644: PPUSH
2645: LD_EXP 1
2649: NOT
2650: PPUSH
2651: LD_STRING 13f_
2653: PPUSH
2654: CALL 63608 0 3
2658: ST_TO_ADDR
// if Cornel then
2659: LD_EXP 47
2663: IFFALSE 2681
// tmp := tmp ^ Cornel ;
2665: LD_ADDR_VAR 0 2
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: LD_EXP 47
2679: ADD
2680: ST_TO_ADDR
// end ; if not Gary then
2681: LD_EXP 48
2685: NOT
2686: IFFALSE 2732
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2688: LD_ADDR_EXP 48
2692: PUSH
2693: LD_STRING Gary
2695: PPUSH
2696: LD_EXP 1
2700: NOT
2701: PPUSH
2702: LD_STRING 13f_
2704: PPUSH
2705: CALL 63608 0 3
2709: ST_TO_ADDR
// if Gary then
2710: LD_EXP 48
2714: IFFALSE 2732
// tmp := tmp ^ Gary ;
2716: LD_ADDR_VAR 0 2
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: LD_EXP 48
2730: ADD
2731: ST_TO_ADDR
// end ; if not Frank then
2732: LD_EXP 49
2736: NOT
2737: IFFALSE 2783
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2739: LD_ADDR_EXP 49
2743: PUSH
2744: LD_STRING Frank
2746: PPUSH
2747: LD_EXP 1
2751: NOT
2752: PPUSH
2753: LD_STRING 13f_
2755: PPUSH
2756: CALL 63608 0 3
2760: ST_TO_ADDR
// if Frank then
2761: LD_EXP 49
2765: IFFALSE 2783
// tmp := tmp ^ Frank ;
2767: LD_ADDR_VAR 0 2
2771: PUSH
2772: LD_VAR 0 2
2776: PUSH
2777: LD_EXP 49
2781: ADD
2782: ST_TO_ADDR
// end ; if not Kikuchi then
2783: LD_EXP 50
2787: NOT
2788: IFFALSE 2834
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2790: LD_ADDR_EXP 50
2794: PUSH
2795: LD_STRING Kikuchi
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_STRING 13f_
2806: PPUSH
2807: CALL 63608 0 3
2811: ST_TO_ADDR
// if Kikuchi then
2812: LD_EXP 50
2816: IFFALSE 2834
// tmp := tmp ^ Kikuchi ;
2818: LD_ADDR_VAR 0 2
2822: PUSH
2823: LD_VAR 0 2
2827: PUSH
2828: LD_EXP 50
2832: ADD
2833: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_STRING 13_other_survivors
2846: PPUSH
2847: CALL_OW 31
2851: UNION
2852: ST_TO_ADDR
// result := tmp ;
2853: LD_ADDR_VAR 0 1
2857: PUSH
2858: LD_VAR 0 2
2862: ST_TO_ADDR
// end ; end_of_file
2863: LD_VAR 0 1
2867: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2868: LD_INT 0
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
2876: PPUSH
2877: PPUSH
2878: PPUSH
2879: PPUSH
// uc_side := 4 ;
2880: LD_ADDR_OWVAR 20
2884: PUSH
2885: LD_INT 4
2887: ST_TO_ADDR
// uc_nation := 1 ;
2888: LD_ADDR_OWVAR 21
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2896: LD_INT 387
2898: PPUSH
2899: CALL_OW 274
2903: PPUSH
2904: LD_INT 1
2906: PPUSH
2907: LD_INT 2500
2909: PPUSH
2910: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2914: LD_INT 387
2916: PPUSH
2917: CALL_OW 274
2921: PPUSH
2922: LD_INT 2
2924: PPUSH
2925: LD_INT 400
2927: PPUSH
2928: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2932: LD_INT 387
2934: PPUSH
2935: CALL_OW 274
2939: PPUSH
2940: LD_INT 3
2942: PPUSH
2943: LD_INT 10
2945: PPUSH
2946: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2950: LD_ADDR_EXP 55
2954: PUSH
2955: LD_STRING Powell
2957: PPUSH
2958: CALL_OW 25
2962: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2963: LD_EXP 55
2967: PPUSH
2968: LD_INT 57
2970: PPUSH
2971: LD_INT 94
2973: PPUSH
2974: LD_INT 0
2976: PPUSH
2977: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2981: LD_EXP 55
2985: PPUSH
2986: LD_INT 58
2988: PPUSH
2989: LD_INT 94
2991: PPUSH
2992: CALL_OW 118
// vip := [ ] ;
2996: LD_ADDR_EXP 56
3000: PUSH
3001: EMPTY
3002: ST_TO_ADDR
// tmp := [ ] ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if JMMGirl <> 2 then
3010: LD_EXP 7
3014: PUSH
3015: LD_INT 2
3017: NONEQUAL
3018: IFFALSE 3042
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3020: LD_ADDR_EXP 39
3024: PUSH
3025: LD_STRING Lisa
3027: PPUSH
3028: LD_EXP 1
3032: NOT
3033: PPUSH
3034: LD_STRING 13s_
3036: PPUSH
3037: CALL 63608 0 3
3041: ST_TO_ADDR
// if Lisa then
3042: LD_EXP 39
3046: IFFALSE 3064
// tmp := tmp ^ Lisa ;
3048: LD_ADDR_VAR 0 6
3052: PUSH
3053: LD_VAR 0 6
3057: PUSH
3058: LD_EXP 39
3062: ADD
3063: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3064: LD_ADDR_EXP 40
3068: PUSH
3069: LD_STRING Donaldson
3071: PPUSH
3072: LD_EXP 1
3076: NOT
3077: PPUSH
3078: LD_STRING 13s_
3080: PPUSH
3081: CALL 63608 0 3
3085: ST_TO_ADDR
// if Donaldson then
3086: LD_EXP 40
3090: IFFALSE 3108
// tmp := tmp ^ Donaldson ;
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: LD_VAR 0 6
3101: PUSH
3102: LD_EXP 40
3106: ADD
3107: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3108: LD_ADDR_EXP 41
3112: PUSH
3113: LD_STRING Bobby
3115: PPUSH
3116: LD_EXP 1
3120: NOT
3121: PPUSH
3122: LD_STRING 13s_
3124: PPUSH
3125: CALL 63608 0 3
3129: ST_TO_ADDR
// if Bobby then
3130: LD_EXP 41
3134: IFFALSE 3152
// tmp := tmp ^ Bobby ;
3136: LD_ADDR_VAR 0 6
3140: PUSH
3141: LD_VAR 0 6
3145: PUSH
3146: LD_EXP 41
3150: ADD
3151: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3152: LD_ADDR_EXP 42
3156: PUSH
3157: LD_STRING Cyrus
3159: PPUSH
3160: LD_EXP 1
3164: NOT
3165: PPUSH
3166: LD_STRING 13s_
3168: PPUSH
3169: CALL 63608 0 3
3173: ST_TO_ADDR
// if Cyrus then
3174: LD_EXP 42
3178: IFFALSE 3196
// tmp := tmp ^ Cyrus ;
3180: LD_ADDR_VAR 0 6
3184: PUSH
3185: LD_VAR 0 6
3189: PUSH
3190: LD_EXP 42
3194: ADD
3195: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3196: LD_ADDR_EXP 43
3200: PUSH
3201: LD_STRING Denis
3203: PPUSH
3204: LD_EXP 1
3208: NOT
3209: PPUSH
3210: LD_STRING 13s_
3212: PPUSH
3213: CALL 63608 0 3
3217: ST_TO_ADDR
// if not Denis then
3218: LD_EXP 43
3222: NOT
3223: IFFALSE 3247
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3225: LD_ADDR_EXP 43
3229: PUSH
3230: LD_STRING Denis
3232: PPUSH
3233: LD_EXP 1
3237: NOT
3238: PPUSH
3239: LD_STRING 13f_
3241: PPUSH
3242: CALL 63608 0 3
3246: ST_TO_ADDR
// if Denis then
3247: LD_EXP 43
3251: IFFALSE 3269
// tmp := tmp ^ Denis ;
3253: LD_ADDR_VAR 0 6
3257: PUSH
3258: LD_VAR 0 6
3262: PUSH
3263: LD_EXP 43
3267: ADD
3268: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3269: LD_ADDR_EXP 44
3273: PUSH
3274: LD_STRING Brown
3276: PPUSH
3277: LD_EXP 1
3281: NOT
3282: PPUSH
3283: LD_STRING 13s_
3285: PPUSH
3286: CALL 63608 0 3
3290: ST_TO_ADDR
// if Brown then
3291: LD_EXP 44
3295: IFFALSE 3313
// tmp := tmp ^ Brown ;
3297: LD_ADDR_VAR 0 6
3301: PUSH
3302: LD_VAR 0 6
3306: PUSH
3307: LD_EXP 44
3311: ADD
3312: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3313: LD_ADDR_EXP 45
3317: PUSH
3318: LD_STRING Gladstone
3320: PPUSH
3321: LD_EXP 1
3325: NOT
3326: PPUSH
3327: LD_STRING 13s_
3329: PPUSH
3330: CALL 63608 0 3
3334: ST_TO_ADDR
// if Gladstone then
3335: LD_EXP 45
3339: IFFALSE 3357
// tmp := tmp ^ Gladstone ;
3341: LD_ADDR_VAR 0 6
3345: PUSH
3346: LD_VAR 0 6
3350: PUSH
3351: LD_EXP 45
3355: ADD
3356: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3357: LD_ADDR_EXP 46
3361: PUSH
3362: LD_STRING Houten
3364: PPUSH
3365: LD_EXP 1
3369: NOT
3370: PPUSH
3371: LD_STRING 13s_
3373: PPUSH
3374: CALL 63608 0 3
3378: ST_TO_ADDR
// if Houten then
3379: LD_EXP 46
3383: IFFALSE 3401
// tmp := tmp ^ Houten ;
3385: LD_ADDR_VAR 0 6
3389: PUSH
3390: LD_VAR 0 6
3394: PUSH
3395: LD_EXP 46
3399: ADD
3400: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3401: LD_ADDR_EXP 47
3405: PUSH
3406: LD_STRING Cornel
3408: PPUSH
3409: LD_EXP 1
3413: NOT
3414: PPUSH
3415: LD_STRING 13s_
3417: PPUSH
3418: CALL 63608 0 3
3422: ST_TO_ADDR
// if Cornel then
3423: LD_EXP 47
3427: IFFALSE 3445
// tmp := tmp ^ Cornel ;
3429: LD_ADDR_VAR 0 6
3433: PUSH
3434: LD_VAR 0 6
3438: PUSH
3439: LD_EXP 47
3443: ADD
3444: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3445: LD_ADDR_EXP 48
3449: PUSH
3450: LD_STRING Gary
3452: PPUSH
3453: LD_EXP 1
3457: NOT
3458: PPUSH
3459: LD_STRING 13s_
3461: PPUSH
3462: CALL 63608 0 3
3466: ST_TO_ADDR
// if Gary then
3467: LD_EXP 48
3471: IFFALSE 3489
// tmp := tmp ^ Gary ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_VAR 0 6
3482: PUSH
3483: LD_EXP 48
3487: ADD
3488: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3489: LD_ADDR_EXP 49
3493: PUSH
3494: LD_STRING Frank
3496: PPUSH
3497: LD_EXP 1
3501: NOT
3502: PPUSH
3503: LD_STRING 13s_
3505: PPUSH
3506: CALL 63608 0 3
3510: ST_TO_ADDR
// if Frank then
3511: LD_EXP 49
3515: IFFALSE 3533
// tmp := tmp ^ Frank ;
3517: LD_ADDR_VAR 0 6
3521: PUSH
3522: LD_VAR 0 6
3526: PUSH
3527: LD_EXP 49
3531: ADD
3532: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3533: LD_ADDR_EXP 50
3537: PUSH
3538: LD_STRING Kikuchi
3540: PPUSH
3541: LD_EXP 1
3545: NOT
3546: PPUSH
3547: LD_STRING 13s_
3549: PPUSH
3550: CALL 63608 0 3
3554: ST_TO_ADDR
// if Kikuchi then
3555: LD_EXP 50
3559: IFFALSE 3577
// tmp := tmp ^ Kikuchi ;
3561: LD_ADDR_VAR 0 6
3565: PUSH
3566: LD_VAR 0 6
3570: PUSH
3571: LD_EXP 50
3575: ADD
3576: ST_TO_ADDR
// vip := tmp ;
3577: LD_ADDR_EXP 56
3581: PUSH
3582: LD_VAR 0 6
3586: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_VAR 0 6
3596: PUSH
3597: LD_STRING 13s_others
3599: PPUSH
3600: CALL_OW 31
3604: UNION
3605: ST_TO_ADDR
// if tmp < 20 then
3606: LD_VAR 0 6
3610: PUSH
3611: LD_INT 20
3613: LESS
3614: IFFALSE 3681
// for i = 1 to 20 - tmp do
3616: LD_ADDR_VAR 0 2
3620: PUSH
3621: DOUBLE
3622: LD_INT 1
3624: DEC
3625: ST_TO_ADDR
3626: LD_INT 20
3628: PUSH
3629: LD_VAR 0 6
3633: MINUS
3634: PUSH
3635: FOR_TO
3636: IFFALSE 3679
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3638: LD_INT 1
3640: PPUSH
3641: LD_VAR 0 2
3645: PUSH
3646: LD_INT 4
3648: MOD
3649: PUSH
3650: LD_INT 1
3652: PLUS
3653: PPUSH
3654: LD_INT 5
3656: PPUSH
3657: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: CALL_OW 44
3675: ADD
3676: ST_TO_ADDR
// end ;
3677: GO 3635
3679: POP
3680: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 7
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 8
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 6
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 9
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 4
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3795: LD_ADDR_VAR 0 10
3799: PUSH
3800: LD_INT 22
3802: PUSH
3803: LD_INT 4
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: LD_INT 30
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PPUSH
3824: CALL_OW 69
3828: PUSH
3829: LD_INT 1
3831: ARRAY
3832: ST_TO_ADDR
// for i in tmp do
3833: LD_ADDR_VAR 0 2
3837: PUSH
3838: LD_VAR 0 6
3842: PUSH
3843: FOR_IN
3844: IFFALSE 3970
// begin cl := GetClass ( i ) ;
3846: LD_ADDR_VAR 0 5
3850: PUSH
3851: LD_VAR 0 2
3855: PPUSH
3856: CALL_OW 257
3860: ST_TO_ADDR
// if cl > 4 then
3861: LD_VAR 0 5
3865: PUSH
3866: LD_INT 4
3868: GREATER
3869: IFFALSE 3879
// cl := 1 ;
3871: LD_ADDR_VAR 0 5
3875: PUSH
3876: LD_INT 1
3878: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3879: LD_ADDR_VAR 0 3
3883: PUSH
3884: LD_VAR 0 9
3888: PUSH
3889: LD_VAR 0 7
3893: PUSH
3894: LD_VAR 0 10
3898: PUSH
3899: LD_VAR 0 8
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_VAR 0 5
3914: ARRAY
3915: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3916: LD_VAR 0 3
3920: PPUSH
3921: CALL_OW 313
3925: PUSH
3926: LD_INT 5
3928: LESS
3929: IFFALSE 3947
// PlaceHumanInUnit ( i , b ) else
3931: LD_VAR 0 2
3935: PPUSH
3936: LD_VAR 0 3
3940: PPUSH
3941: CALL_OW 52
3945: GO 3968
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3947: LD_VAR 0 2
3951: PPUSH
3952: LD_INT 58
3954: PPUSH
3955: LD_INT 91
3957: PPUSH
3958: LD_INT 6
3960: PPUSH
3961: LD_INT 0
3963: PPUSH
3964: CALL_OW 50
// end ;
3968: GO 3843
3970: POP
3971: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3972: LD_INT 2
3974: PPUSH
3975: LD_INT 1
3977: PPUSH
3978: LD_INT 1
3980: PPUSH
3981: LD_INT 12
3983: PPUSH
3984: LD_INT 100
3986: PPUSH
3987: CALL 70385 0 5
// veh := CreateVehicle ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: CALL_OW 45
4000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4001: LD_VAR 0 4
4005: PPUSH
4006: LD_INT 4
4008: PPUSH
4009: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4013: LD_VAR 0 4
4017: PPUSH
4018: LD_INT 49
4020: PPUSH
4021: LD_INT 88
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4031: LD_VAR 0 4
4035: PPUSH
4036: LD_INT 1
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL_OW 290
// uc_side := 0 ;
4046: LD_ADDR_OWVAR 20
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// uc_nation := 0 ;
4054: LD_ADDR_OWVAR 21
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// for i = 1 to 4 do
4062: LD_ADDR_VAR 0 2
4066: PUSH
4067: DOUBLE
4068: LD_INT 1
4070: DEC
4071: ST_TO_ADDR
4072: LD_INT 4
4074: PUSH
4075: FOR_TO
4076: IFFALSE 4107
// begin InitHc ;
4078: CALL_OW 19
// hc_class := class_apeman ;
4082: LD_ADDR_OWVAR 28
4086: PUSH
4087: LD_INT 12
4089: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4090: CALL_OW 44
4094: PPUSH
4095: LD_INT 13
4097: PPUSH
4098: LD_INT 0
4100: PPUSH
4101: CALL_OW 49
// end ;
4105: GO 4075
4107: POP
4108: POP
// end ; end_of_file
4109: LD_VAR 0 1
4113: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4114: LD_INT 0
4116: PPUSH
4117: PPUSH
4118: PPUSH
4119: PPUSH
4120: PPUSH
// side := 8 ;
4121: LD_ADDR_VAR 0 3
4125: PUSH
4126: LD_INT 8
4128: ST_TO_ADDR
// uc_side := side ;
4129: LD_ADDR_OWVAR 20
4133: PUSH
4134: LD_VAR 0 3
4138: ST_TO_ADDR
// uc_nation := 2 ;
4139: LD_ADDR_OWVAR 21
4143: PUSH
4144: LD_INT 2
4146: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4147: LD_ADDR_VAR 0 2
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: LD_VAR 0 3
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: LD_INT 21
4166: PUSH
4167: LD_INT 3
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PPUSH
4178: CALL_OW 69
4182: PUSH
4183: FOR_IN
4184: IFFALSE 4200
// SetBLevel ( i , 10 ) ;
4186: LD_VAR 0 2
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: CALL_OW 241
4198: GO 4183
4200: POP
4201: POP
// if KurtStatus then
4202: LD_EXP 3
4206: IFFALSE 4229
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4208: LD_ADDR_EXP 57
4212: PUSH
4213: LD_STRING Kurt
4215: PPUSH
4216: LD_INT 0
4218: PPUSH
4219: LD_STRING 
4221: PPUSH
4222: CALL 63608 0 3
4226: ST_TO_ADDR
4227: GO 4251
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4229: LD_ADDR_EXP 57
4233: PUSH
4234: LD_STRING AltKurt
4236: PPUSH
4237: LD_EXP 1
4241: NOT
4242: PPUSH
4243: LD_STRING 
4245: PPUSH
4246: CALL 63608 0 3
4250: ST_TO_ADDR
// if not Kurt then
4251: LD_EXP 57
4255: NOT
4256: IFFALSE 4282
// begin InitHc ;
4258: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 10
4267: PPUSH
4268: CALL_OW 381
// Kurt := CreateHuman ;
4272: LD_ADDR_EXP 57
4276: PUSH
4277: CALL_OW 44
4281: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4282: LD_EXP 57
4286: PPUSH
4287: LD_INT 324
4289: PPUSH
4290: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4294: LD_ADDR_EXP 58
4298: PUSH
4299: LD_STRING Kozlov
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: LD_STRING 
4307: PPUSH
4308: CALL 63608 0 3
4312: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4313: LD_EXP 58
4317: PPUSH
4318: LD_INT 22
4320: PUSH
4321: LD_INT 8
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 23
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: LD_INT 30
4340: PUSH
4341: LD_INT 8
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: PPUSH
4353: CALL_OW 69
4357: PUSH
4358: LD_INT 1
4360: ARRAY
4361: PPUSH
4362: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4366: LD_EXP 58
4370: PPUSH
4371: LD_INT 3
4373: PPUSH
4374: LD_INT 10
4376: PPUSH
4377: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4381: LD_ADDR_VAR 0 5
4385: PUSH
4386: LD_INT 22
4388: PUSH
4389: LD_VAR 0 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 30
4400: PUSH
4401: LD_INT 32
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 58
4410: PUSH
4411: EMPTY
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: PPUSH
4419: CALL_OW 69
4423: ST_TO_ADDR
// for i = 1 to 10 do
4424: LD_ADDR_VAR 0 2
4428: PUSH
4429: DOUBLE
4430: LD_INT 1
4432: DEC
4433: ST_TO_ADDR
4434: LD_INT 10
4436: PUSH
4437: FOR_TO
4438: IFFALSE 4510
// begin uc_nation := nation_nature ;
4440: LD_ADDR_OWVAR 21
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4448: LD_ADDR_OWVAR 28
4452: PUSH
4453: LD_INT 15
4455: ST_TO_ADDR
// hc_gallery :=  ;
4456: LD_ADDR_OWVAR 33
4460: PUSH
4461: LD_STRING 
4463: ST_TO_ADDR
// hc_name :=  ;
4464: LD_ADDR_OWVAR 26
4468: PUSH
4469: LD_STRING 
4471: ST_TO_ADDR
// un := CreateHuman ;
4472: LD_ADDR_VAR 0 4
4476: PUSH
4477: CALL_OW 44
4481: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4482: LD_VAR 0 4
4486: PPUSH
4487: LD_VAR 0 5
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_VAR 0 2
4501: MINUS
4502: ARRAY
4503: PPUSH
4504: CALL_OW 52
// end ;
4508: GO 4437
4510: POP
4511: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_STRING 12_kurt_squad
4519: PPUSH
4520: CALL_OW 31
4524: ST_TO_ADDR
// if tmp then
4525: LD_VAR 0 5
4529: IFFALSE 4563
// for i in tmp do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: LD_VAR 0 5
4540: PUSH
4541: FOR_IN
4542: IFFALSE 4561
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_INT 5
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 49
4559: GO 4541
4561: POP
4562: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4563: LD_INT 324
4565: PPUSH
4566: LD_INT 5
4568: PPUSH
4569: LD_STRING 
4571: PPUSH
4572: LD_INT 8
4574: PUSH
4575: LD_INT 9
4577: PUSH
4578: LD_INT 10
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_OWVAR 67
4590: ARRAY
4591: PPUSH
4592: LD_INT 3000
4594: PUSH
4595: LD_INT 500
4597: PUSH
4598: LD_INT 150
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: LIST
4605: PPUSH
4606: LD_INT 16
4608: PUSH
4609: LD_INT 6
4611: PUSH
4612: LD_INT 6
4614: PUSH
4615: LD_INT 8
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: PPUSH
4624: CALL 73794 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4628: LD_ADDR_EXP 99
4632: PUSH
4633: LD_EXP 99
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 22
4643: PUSH
4644: LD_VAR 0 3
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 23
4655: PUSH
4656: LD_INT 2
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 3
4665: PUSH
4666: LD_INT 21
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PPUSH
4685: CALL_OW 69
4689: PUSH
4690: LD_EXP 57
4694: DIFF
4695: PPUSH
4696: CALL_OW 1
4700: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 7
4706: PPUSH
4707: CALL_OW 383
// Friend := CreateHuman ;
4711: LD_ADDR_EXP 59
4715: PUSH
4716: CALL_OW 44
4720: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4721: LD_INT 14
4723: PPUSH
4724: LD_INT 3
4726: PPUSH
4727: LD_INT 1
4729: PPUSH
4730: LD_INT 29
4732: PPUSH
4733: LD_INT 100
4735: PPUSH
4736: CALL 70385 0 5
// powellBomb := CreateVehicle ;
4740: LD_ADDR_EXP 60
4744: PUSH
4745: CALL_OW 45
4749: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4750: LD_EXP 60
4754: PPUSH
4755: LD_INT 90
4757: PPUSH
4758: LD_INT 51
4760: PPUSH
4761: LD_INT 0
4763: PPUSH
4764: CALL_OW 48
// end ;
4768: LD_VAR 0 1
4772: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4773: LD_INT 0
4775: PPUSH
4776: PPUSH
4777: PPUSH
// if IsLive ( kozlov_fac ) then
4778: LD_INT 332
4780: PPUSH
4781: CALL_OW 300
4785: IFFALSE 4789
// exit ;
4787: GO 5356
// ComExitBuilding ( Kozlov ) ;
4789: LD_EXP 58
4793: PPUSH
4794: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4798: LD_EXP 58
4802: PPUSH
4803: CALL_OW 257
4807: PUSH
4808: LD_INT 2
4810: NONEQUAL
4811: IFFALSE 4846
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 324
4820: PPUSH
4821: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4825: LD_EXP 58
4829: PPUSH
4830: LD_INT 2
4832: PPUSH
4833: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4837: LD_EXP 58
4841: PPUSH
4842: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4846: LD_EXP 58
4850: PPUSH
4851: LD_INT 2
4853: PPUSH
4854: LD_INT 93
4856: PPUSH
4857: LD_INT 32
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4867: LD_INT 35
4869: PPUSH
4870: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4874: LD_INT 22
4876: PUSH
4877: LD_INT 8
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 30
4886: PUSH
4887: LD_INT 3
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 23
4896: PUSH
4897: LD_INT 3
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 57
4906: PUSH
4907: EMPTY
4908: LIST
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: IFFALSE 4867
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4922: LD_ADDR_VAR 0 2
4926: PUSH
4927: LD_INT 22
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 30
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 23
4949: PUSH
4950: LD_INT 3
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: LD_INT 57
4959: PUSH
4960: EMPTY
4961: LIST
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 69
4973: PUSH
4974: LD_INT 1
4976: ARRAY
4977: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4978: LD_INT 22
4980: PUSH
4981: LD_INT 8
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 23
4990: PUSH
4991: LD_INT 3
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 30
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: NOT
5018: IFFALSE 5096
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5020: LD_EXP 58
5024: PPUSH
5025: LD_INT 21
5027: PPUSH
5028: LD_INT 97
5030: PPUSH
5031: LD_INT 36
5033: PPUSH
5034: LD_INT 5
5036: PPUSH
5037: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5041: LD_INT 35
5043: PPUSH
5044: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5048: LD_INT 22
5050: PUSH
5051: LD_INT 8
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: LD_INT 23
5060: PUSH
5061: LD_INT 3
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 30
5070: PUSH
5071: LD_INT 21
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 57
5080: PUSH
5081: EMPTY
5082: LIST
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: IFFALSE 5041
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5096: LD_INT 22
5098: PUSH
5099: LD_INT 8
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 23
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 18
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: LIST
5130: PPUSH
5131: CALL_OW 69
5135: NOT
5136: IFFALSE 5214
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5138: LD_EXP 58
5142: PPUSH
5143: LD_INT 18
5145: PPUSH
5146: LD_INT 89
5148: PPUSH
5149: LD_INT 32
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5159: LD_INT 35
5161: PPUSH
5162: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5166: LD_INT 22
5168: PUSH
5169: LD_INT 8
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 23
5178: PUSH
5179: LD_INT 3
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 30
5188: PUSH
5189: LD_INT 18
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 57
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: IFFALSE 5159
// end ; lab := kozlov_lab ;
5214: LD_ADDR_VAR 0 3
5218: PUSH
5219: LD_INT 336
5221: ST_TO_ADDR
// if not lab then
5222: LD_VAR 0 3
5226: NOT
5227: IFFALSE 5231
// exit ;
5229: GO 5356
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5231: LD_EXP 58
5235: PPUSH
5236: LD_VAR 0 3
5240: PUSH
5241: LD_INT 1
5243: ARRAY
5244: PPUSH
5245: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5249: LD_EXP 58
5253: PPUSH
5254: LD_INT 4
5256: PPUSH
5257: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5261: LD_VAR 0 3
5265: PUSH
5266: LD_INT 1
5268: ARRAY
5269: PPUSH
5270: LD_INT 25
5272: PPUSH
5273: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5277: LD_INT 35
5279: PPUSH
5280: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5284: LD_INT 25
5286: PPUSH
5287: LD_INT 8
5289: PPUSH
5290: CALL_OW 321
5294: PUSH
5295: LD_INT 2
5297: EQUAL
5298: IFFALSE 5277
// ComExitBuilding ( Kozlov ) ;
5300: LD_EXP 58
5304: PPUSH
5305: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5309: LD_EXP 58
5313: PPUSH
5314: LD_VAR 0 2
5318: PPUSH
5319: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5323: LD_EXP 58
5327: PPUSH
5328: LD_INT 3
5330: PPUSH
5331: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5335: LD_VAR 0 2
5339: PPUSH
5340: LD_INT 23
5342: PPUSH
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: LD_INT 48
5351: PPUSH
5352: CALL_OW 125
// end ;
5356: LD_VAR 0 1
5360: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5361: LD_EXP 22
5365: NOT
5366: PUSH
5367: LD_EXP 15
5371: PUSH
5372: LD_INT 6
5374: GREATEREQUAL
5375: AND
5376: IFFALSE 5457
5378: GO 5380
5380: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5381: LD_INT 3
5383: PPUSH
5384: LD_INT 3
5386: PPUSH
5387: CALL 57535 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 14
5396: PUSH
5397: LD_INT 1
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 28
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 14
5414: PUSH
5415: LD_INT 1
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 28
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 14
5432: PUSH
5433: LD_INT 1
5435: PUSH
5436: LD_INT 1
5438: PUSH
5439: LD_INT 28
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: PPUSH
5453: CALL 57398 0 2
// end ;
5457: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5458: LD_EXP 22
5462: NOT
5463: PUSH
5464: LD_EXP 15
5468: PUSH
5469: LD_INT 6
5471: GREATEREQUAL
5472: AND
5473: PUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL 58816 0 2
5484: NOT
5485: AND
5486: IFFALSE 6326
5488: GO 5490
5490: DISABLE
5491: LD_INT 0
5493: PPUSH
5494: PPUSH
5495: PPUSH
// begin enable ;
5496: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5497: LD_INT 22
5499: PUSH
5500: LD_INT 8
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 30
5519: PUSH
5520: LD_INT 3
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: PPUSH
5532: CALL_OW 69
5536: NOT
5537: IFFALSE 5541
// exit ;
5539: GO 6326
// if Prob ( 40 ) then
5541: LD_INT 40
5543: PPUSH
5544: CALL_OW 13
5548: IFFALSE 5675
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5550: LD_INT 3
5552: PPUSH
5553: LD_INT 14
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 28
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 14
5573: PUSH
5574: LD_INT 1
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 28
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 28
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 14
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: LD_INT 28
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_INT 14
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: LD_INT 2
5633: PUSH
5634: LD_INT 28
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 14
5645: PUSH
5646: LD_INT 1
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL 57398 0 2
// end else
5673: GO 5866
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5675: LD_INT 3
5677: PPUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 27
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 26
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_OWVAR 67
5705: ARRAY
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 14
5715: PUSH
5716: LD_INT 1
5718: PUSH
5719: LD_INT 2
5721: PUSH
5722: LD_INT 27
5724: PUSH
5725: LD_INT 26
5727: PUSH
5728: LD_INT 26
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_OWVAR 67
5740: ARRAY
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 14
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: LD_INT 2
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: LD_INT 29
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 13
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 29
5797: PUSH
5798: LD_INT 29
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: PUSH
5806: LD_OWVAR 67
5810: ARRAY
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 13
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: LD_INT 2
5826: PUSH
5827: LD_INT 29
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 26
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PPUSH
5862: CALL 57398 0 2
// end ; repeat wait ( 0 0$1 ) ;
5866: LD_INT 35
5868: PPUSH
5869: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 58816 0 2
5883: PUSH
5884: LD_INT 6
5886: GREATEREQUAL
5887: IFFALSE 5866
// wait ( 0 0$30 ) ;
5889: LD_INT 1050
5891: PPUSH
5892: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5896: LD_ADDR_VAR 0 2
5900: PUSH
5901: LD_INT 3
5903: PPUSH
5904: LD_INT 1
5906: PPUSH
5907: CALL 58816 0 2
5911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5912: LD_ADDR_EXP 118
5916: PUSH
5917: LD_EXP 118
5921: PPUSH
5922: LD_INT 3
5924: PPUSH
5925: LD_EXP 118
5929: PUSH
5930: LD_INT 3
5932: ARRAY
5933: PUSH
5934: LD_VAR 0 2
5938: DIFF
5939: PPUSH
5940: CALL_OW 1
5944: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 0
5952: PPUSH
5953: LD_INT 2
5955: PPUSH
5956: CALL_OW 12
5960: ST_TO_ADDR
// if target then
5961: LD_VAR 0 3
5965: IFFALSE 6093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: LD_VAR 0 2
5976: PPUSH
5977: LD_INT 24
5979: PUSH
5980: LD_INT 250
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PPUSH
5987: CALL_OW 72
5991: ST_TO_ADDR
// for i in tmp do
5992: LD_ADDR_VAR 0 1
5996: PUSH
5997: LD_VAR 0 2
6001: PUSH
6002: FOR_IN
6003: IFFALSE 6043
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6005: LD_VAR 0 1
6009: PPUSH
6010: LD_INT 89
6012: PPUSH
6013: LD_INT 71
6015: PPUSH
6016: CALL_OW 297
6020: PUSH
6021: LD_INT 9
6023: GREATER
6024: IFFALSE 6041
// ComMoveXY ( i , 89 , 71 ) ;
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 89
6033: PPUSH
6034: LD_INT 71
6036: PPUSH
6037: CALL_OW 111
6041: GO 6002
6043: POP
6044: POP
// wait ( 0 0$1 ) ;
6045: LD_INT 35
6047: PPUSH
6048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6052: LD_VAR 0 2
6056: PPUSH
6057: LD_INT 92
6059: PUSH
6060: LD_INT 89
6062: PUSH
6063: LD_INT 71
6065: PUSH
6066: LD_INT 9
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: PUSH
6080: LD_VAR 0 2
6084: PUSH
6085: LD_INT 1
6087: MINUS
6088: GREATEREQUAL
6089: IFFALSE 5967
// end else
6091: GO 6217
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 24
6105: PUSH
6106: LD_INT 250
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: PPUSH
6113: CALL_OW 72
6117: ST_TO_ADDR
// for i in tmp do
6118: LD_ADDR_VAR 0 1
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6169
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 125
6138: PPUSH
6139: LD_INT 129
6141: PPUSH
6142: CALL_OW 297
6146: PUSH
6147: LD_INT 9
6149: GREATER
6150: IFFALSE 6167
// ComMoveXY ( i , 125 , 129 ) ;
6152: LD_VAR 0 1
6156: PPUSH
6157: LD_INT 125
6159: PPUSH
6160: LD_INT 129
6162: PPUSH
6163: CALL_OW 111
6167: GO 6128
6169: POP
6170: POP
// wait ( 0 0$1 ) ;
6171: LD_INT 35
6173: PPUSH
6174: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6178: LD_VAR 0 2
6182: PPUSH
6183: LD_INT 92
6185: PUSH
6186: LD_INT 125
6188: PUSH
6189: LD_INT 129
6191: PUSH
6192: LD_INT 9
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 72
6205: PUSH
6206: LD_VAR 0 2
6210: PUSH
6211: LD_INT 1
6213: MINUS
6214: GREATEREQUAL
6215: IFFALSE 6093
// end ; repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// for i in tmp do
6224: LD_ADDR_VAR 0 1
6228: PUSH
6229: LD_VAR 0 2
6233: PUSH
6234: FOR_IN
6235: IFFALSE 6317
// begin if GetLives ( i ) > 251 then
6237: LD_VAR 0 1
6241: PPUSH
6242: CALL_OW 256
6246: PUSH
6247: LD_INT 251
6249: GREATER
6250: IFFALSE 6288
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6252: LD_VAR 0 1
6256: PPUSH
6257: LD_INT 81
6259: PUSH
6260: LD_INT 8
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PPUSH
6267: CALL_OW 69
6271: PPUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 74
6281: PPUSH
6282: CALL_OW 115
6286: GO 6315
// if IsDead ( i ) then
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 301
6297: IFFALSE 6315
// tmp := tmp diff i ;
6299: LD_ADDR_VAR 0 2
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: LD_VAR 0 1
6313: DIFF
6314: ST_TO_ADDR
// end ;
6315: GO 6234
6317: POP
6318: POP
// until not tmp ;
6319: LD_VAR 0 2
6323: NOT
6324: IFFALSE 6217
// end ;
6326: PPOPN 3
6328: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6329: LD_EXP 22
6333: NOT
6334: PUSH
6335: LD_EXP 15
6339: PUSH
6340: LD_INT 6
6342: GREATEREQUAL
6343: AND
6344: PUSH
6345: LD_OWVAR 67
6349: PUSH
6350: LD_INT 1
6352: GREATER
6353: AND
6354: IFFALSE 6871
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
// begin enable ;
6364: ENABLE
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6372: LD_ADDR_VAR 0 1
6376: PUSH
6377: DOUBLE
6378: LD_INT 1
6380: DEC
6381: ST_TO_ADDR
6382: LD_INT 4
6384: PUSH
6385: LD_INT 6
6387: PUSH
6388: LD_INT 7
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PUSH
6402: FOR_TO
6403: IFFALSE 6563
// begin uc_side := 8 ;
6405: LD_ADDR_OWVAR 20
6409: PUSH
6410: LD_INT 8
6412: ST_TO_ADDR
// uc_nation := 2 ;
6413: LD_ADDR_OWVAR 21
6417: PUSH
6418: LD_INT 2
6420: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6421: LD_INT 13
6423: PUSH
6424: LD_INT 14
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 2
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: LD_INT 1
6445: PPUSH
6446: LD_INT 5
6448: PPUSH
6449: LD_INT 27
6451: PUSH
6452: LD_INT 28
6454: PUSH
6455: LD_INT 26
6457: PUSH
6458: LD_INT 25
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 4
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 88
6481: PPUSH
6482: CALL 70385 0 5
// un := CreateVehicle ;
6486: LD_ADDR_VAR 0 2
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// tmp := tmp ^ un ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: LD_VAR 0 2
6510: ADD
6511: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6512: LD_VAR 0 2
6516: PPUSH
6517: LD_INT 3
6519: PPUSH
6520: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6524: LD_VAR 0 2
6528: PPUSH
6529: LD_INT 30
6531: PPUSH
6532: LD_INT 0
6534: PPUSH
6535: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6539: LD_VAR 0 2
6543: PPUSH
6544: LD_INT 16
6546: PPUSH
6547: LD_INT 11
6549: PPUSH
6550: CALL_OW 111
// wait ( 0 0$2 ) ;
6554: LD_INT 70
6556: PPUSH
6557: CALL_OW 67
// end ;
6561: GO 6402
6563: POP
6564: POP
// for i = 1 to Difficulty do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: DOUBLE
6571: LD_INT 1
6573: DEC
6574: ST_TO_ADDR
6575: LD_OWVAR 67
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6706
// begin uc_side := 8 ;
6583: LD_ADDR_OWVAR 20
6587: PUSH
6588: LD_INT 8
6590: ST_TO_ADDR
// uc_nation := 2 ;
6591: LD_ADDR_OWVAR 21
6595: PUSH
6596: LD_INT 2
6598: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6599: LD_INT 0
6601: PPUSH
6602: LD_INT 8
6604: PPUSH
6605: LD_INT 8
6607: PUSH
6608: LD_INT 8
6610: PUSH
6611: LD_INT 9
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_OWVAR 67
6623: ARRAY
6624: PPUSH
6625: CALL_OW 380
// un := CreateHuman ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: CALL_OW 44
6638: ST_TO_ADDR
// tmp := tmp ^ un ;
6639: LD_ADDR_VAR 0 3
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: LD_VAR 0 2
6653: ADD
6654: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 30
6674: PPUSH
6675: LD_INT 0
6677: PPUSH
6678: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6682: LD_VAR 0 2
6686: PPUSH
6687: LD_INT 16
6689: PPUSH
6690: LD_INT 11
6692: PPUSH
6693: CALL_OW 111
// wait ( 0 0$2 ) ;
6697: LD_INT 70
6699: PPUSH
6700: CALL_OW 67
// end ;
6704: GO 6580
6706: POP
6707: POP
// repeat wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// for i in tmp do
6715: LD_ADDR_VAR 0 1
6719: PUSH
6720: LD_VAR 0 3
6724: PUSH
6725: FOR_IN
6726: IFFALSE 6862
// begin if GetLives ( i ) > 250 then
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 256
6737: PUSH
6738: LD_INT 250
6740: GREATER
6741: IFFALSE 6833
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6743: LD_INT 81
6745: PUSH
6746: LD_INT 8
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 91
6755: PUSH
6756: LD_VAR 0 1
6760: PUSH
6761: LD_INT 10
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: NOT
6778: IFFALSE 6797
// ComAgressiveMove ( i , 67 , 110 ) else
6780: LD_VAR 0 1
6784: PPUSH
6785: LD_INT 67
6787: PPUSH
6788: LD_INT 110
6790: PPUSH
6791: CALL_OW 114
6795: GO 6831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_INT 81
6804: PUSH
6805: LD_INT 8
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PPUSH
6812: CALL_OW 69
6816: PPUSH
6817: LD_VAR 0 1
6821: PPUSH
6822: CALL_OW 74
6826: PPUSH
6827: CALL_OW 115
// end else
6831: GO 6860
// if IsDead ( i ) then
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 301
6842: IFFALSE 6860
// tmp := tmp diff i ;
6844: LD_ADDR_VAR 0 3
6848: PUSH
6849: LD_VAR 0 3
6853: PUSH
6854: LD_VAR 0 1
6858: DIFF
6859: ST_TO_ADDR
// end ;
6860: GO 6725
6862: POP
6863: POP
// until not tmp ;
6864: LD_VAR 0 3
6868: NOT
6869: IFFALSE 6708
// end ; end_of_file
6871: PPOPN 3
6873: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
6884: PPUSH
// side := 3 ;
6885: LD_ADDR_VAR 0 6
6889: PUSH
6890: LD_INT 3
6892: ST_TO_ADDR
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 6
6902: ST_TO_ADDR
// uc_nation := 3 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 3
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_VAR 0 6
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 21
6930: PUSH
6931: LD_INT 3
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PPUSH
6942: CALL_OW 69
6946: PUSH
6947: FOR_IN
6948: IFFALSE 6964
// SetBLevel ( i , 10 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 10
6957: PPUSH
6958: CALL_OW 241
6962: GO 6947
6964: POP
6965: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6966: LD_ADDR_VAR 0 9
6970: PUSH
6971: LD_INT 22
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 30
6985: PUSH
6986: LD_INT 34
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: PPUSH
6997: CALL_OW 69
7001: ST_TO_ADDR
// if teleport then
7002: LD_VAR 0 9
7006: IFFALSE 7027
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7008: LD_VAR 0 9
7012: PUSH
7013: LD_INT 1
7015: ARRAY
7016: PPUSH
7017: LD_INT 123
7019: PPUSH
7020: LD_INT 122
7022: PPUSH
7023: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7027: LD_ADDR_EXP 61
7031: PUSH
7032: LD_STRING Platonov
7034: PPUSH
7035: CALL_OW 25
7039: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7040: LD_ADDR_EXP 62
7044: PUSH
7045: LD_STRING Kovalyuk
7047: PPUSH
7048: CALL_OW 25
7052: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7053: LD_ADDR_EXP 64
7057: PUSH
7058: LD_STRING Yakotich
7060: PPUSH
7061: CALL_OW 25
7065: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7066: LD_ADDR_EXP 63
7070: PUSH
7071: LD_STRING Bystrov
7073: PPUSH
7074: CALL_OW 25
7078: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7079: LD_ADDR_EXP 65
7083: PUSH
7084: LD_STRING Gleb
7086: PPUSH
7087: CALL_OW 25
7091: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7092: LD_STRING 03_Cornel
7094: PPUSH
7095: CALL_OW 28
7099: IFFALSE 7147
// begin Bierezov := NewCharacter ( Mikhail ) ;
7101: LD_ADDR_EXP 66
7105: PUSH
7106: LD_STRING Mikhail
7108: PPUSH
7109: CALL_OW 25
7113: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7114: LD_EXP 66
7118: PPUSH
7119: LD_INT 197
7121: PPUSH
7122: LD_INT 111
7124: PPUSH
7125: LD_INT 9
7127: PPUSH
7128: LD_INT 0
7130: PPUSH
7131: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7135: LD_EXP 66
7139: PPUSH
7140: LD_INT 3
7142: PPUSH
7143: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7147: LD_EXP 61
7151: PPUSH
7152: LD_INT 126
7154: PPUSH
7155: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7159: LD_EXP 62
7163: PPUSH
7164: LD_INT 134
7166: PPUSH
7167: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7171: LD_EXP 64
7175: PPUSH
7176: LD_INT 197
7178: PPUSH
7179: LD_INT 111
7181: PPUSH
7182: LD_INT 9
7184: PPUSH
7185: LD_INT 0
7187: PPUSH
7188: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7192: LD_EXP 63
7196: PPUSH
7197: LD_INT 197
7199: PPUSH
7200: LD_INT 111
7202: PPUSH
7203: LD_INT 9
7205: PPUSH
7206: LD_INT 0
7208: PPUSH
7209: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7213: LD_EXP 65
7217: PPUSH
7218: LD_INT 197
7220: PPUSH
7221: LD_INT 111
7223: PPUSH
7224: LD_INT 9
7226: PPUSH
7227: LD_INT 0
7229: PPUSH
7230: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7234: LD_ADDR_VAR 0 5
7238: PUSH
7239: LD_INT 126
7241: PPUSH
7242: LD_INT 4
7244: PPUSH
7245: LD_STRING zhukov
7247: PPUSH
7248: LD_INT 9
7250: PUSH
7251: LD_INT 10
7253: PUSH
7254: LD_INT 10
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: ARRAY
7267: PPUSH
7268: LD_INT 90000
7270: PUSH
7271: LD_INT 1000
7273: PUSH
7274: LD_INT 300
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: LIST
7281: PPUSH
7282: LD_INT 21
7284: PUSH
7285: LD_INT 8
7287: PUSH
7288: LD_INT 13
7290: PUSH
7291: LD_INT 8
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL 73794 0 6
7304: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: LD_INT 267
7312: PPUSH
7313: CALL_OW 274
7317: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7318: LD_VAR 0 4
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 5000
7328: PPUSH
7329: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7333: LD_VAR 0 4
7337: PPUSH
7338: LD_INT 2
7340: PPUSH
7341: LD_INT 200
7343: PPUSH
7344: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7348: LD_VAR 0 4
7352: PPUSH
7353: LD_INT 3
7355: PPUSH
7356: LD_INT 200
7358: PPUSH
7359: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7363: LD_ADDR_EXP 99
7367: PUSH
7368: LD_EXP 99
7372: PPUSH
7373: LD_INT 2
7375: PPUSH
7376: LD_VAR 0 5
7380: PUSH
7381: LD_INT 22
7383: PUSH
7384: LD_VAR 0 6
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: LD_INT 3
7395: PUSH
7396: LD_INT 21
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: EMPTY
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL_OW 69
7418: UNION
7419: PUSH
7420: LD_EXP 61
7424: DIFF
7425: PPUSH
7426: CALL_OW 1
7430: ST_TO_ADDR
// behemoths := [ ] ;
7431: LD_ADDR_EXP 69
7435: PUSH
7436: EMPTY
7437: ST_TO_ADDR
// behemothBuilders := [ ] ;
7438: LD_ADDR_EXP 70
7442: PUSH
7443: EMPTY
7444: ST_TO_ADDR
// if Kovalyuk then
7445: LD_EXP 62
7449: IFFALSE 7471
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7451: LD_ADDR_EXP 70
7455: PUSH
7456: LD_EXP 70
7460: PPUSH
7461: LD_EXP 62
7465: PPUSH
7466: CALL 106130 0 2
7470: ST_TO_ADDR
// j := 3 ;
7471: LD_ADDR_VAR 0 3
7475: PUSH
7476: LD_INT 3
7478: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7479: LD_ADDR_VAR 0 2
7483: PUSH
7484: LD_INT 22
7486: PUSH
7487: LD_INT 3
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 25
7496: PUSH
7497: LD_INT 3
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: PPUSH
7508: CALL_OW 69
7512: PUSH
7513: LD_EXP 62
7517: DIFF
7518: PUSH
7519: FOR_IN
7520: IFFALSE 7570
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7522: LD_ADDR_EXP 70
7526: PUSH
7527: LD_EXP 70
7531: PPUSH
7532: LD_VAR 0 2
7536: PPUSH
7537: CALL 106130 0 2
7541: ST_TO_ADDR
// j := j - 1 ;
7542: LD_ADDR_VAR 0 3
7546: PUSH
7547: LD_VAR 0 3
7551: PUSH
7552: LD_INT 1
7554: MINUS
7555: ST_TO_ADDR
// if j = 0 then
7556: LD_VAR 0 3
7560: PUSH
7561: LD_INT 0
7563: EQUAL
7564: IFFALSE 7568
// break ;
7566: GO 7570
// end ;
7568: GO 7519
7570: POP
7571: POP
// end ;
7572: LD_VAR 0 1
7576: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7577: LD_INT 0
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7584: LD_ADDR_VAR 0 4
7588: PUSH
7589: LD_INT 209
7591: PUSH
7592: LD_INT 149
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 219
7601: PUSH
7602: LD_INT 154
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 223
7611: PUSH
7612: LD_INT 149
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 232
7621: PUSH
7622: LD_INT 155
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: ST_TO_ADDR
// if not behemothBuilders then
7635: LD_EXP 70
7639: NOT
7640: IFFALSE 7644
// exit ;
7642: GO 7748
// j := 1 ;
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_INT 1
7651: ST_TO_ADDR
// for i in behemothBuilders do
7652: LD_ADDR_VAR 0 2
7656: PUSH
7657: LD_EXP 70
7661: PUSH
7662: FOR_IN
7663: IFFALSE 7746
// begin if IsInUnit ( i ) then
7665: LD_VAR 0 2
7669: PPUSH
7670: CALL_OW 310
7674: IFFALSE 7685
// ComExitBuilding ( i ) ;
7676: LD_VAR 0 2
7680: PPUSH
7681: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7685: LD_VAR 0 2
7689: PPUSH
7690: LD_INT 37
7692: PPUSH
7693: LD_VAR 0 4
7697: PUSH
7698: LD_VAR 0 3
7702: ARRAY
7703: PUSH
7704: LD_INT 1
7706: ARRAY
7707: PPUSH
7708: LD_VAR 0 4
7712: PUSH
7713: LD_VAR 0 3
7717: ARRAY
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: LD_INT 0
7725: PPUSH
7726: CALL_OW 230
// j := j + 1 ;
7730: LD_ADDR_VAR 0 3
7734: PUSH
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: PLUS
7743: ST_TO_ADDR
// end ;
7744: GO 7662
7746: POP
7747: POP
// end ;
7748: LD_VAR 0 1
7752: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7753: LD_INT 24
7755: PPUSH
7756: LD_INT 30
7758: PUSH
7759: LD_INT 37
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 70
7770: IFFALSE 7783
7772: GO 7774
7774: DISABLE
// behemothUnderConstruct := true ;
7775: LD_ADDR_EXP 26
7779: PUSH
7780: LD_INT 1
7782: ST_TO_ADDR
7783: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7784: LD_INT 3
7786: PPUSH
7787: CALL 106178 0 1
7791: PUSH
7792: LD_INT 22
7794: PUSH
7795: LD_INT 3
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PUSH
7802: LD_INT 30
7804: PUSH
7805: LD_INT 37
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: NOT
7821: AND
7822: IFFALSE 8008
7824: GO 7826
7826: DISABLE
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
// begin enable ;
7831: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL 106178 0 1
7844: ST_TO_ADDR
// for i in tmp do
7845: LD_ADDR_VAR 0 1
7849: PUSH
7850: LD_VAR 0 2
7854: PUSH
7855: FOR_IN
7856: IFFALSE 8006
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7858: LD_VAR 0 1
7862: PPUSH
7863: LD_INT 9
7865: PPUSH
7866: CALL_OW 308
7870: PUSH
7871: LD_VAR 0 1
7875: PPUSH
7876: CALL_OW 110
7880: PUSH
7881: LD_INT 2
7883: EQUAL
7884: NOT
7885: AND
7886: IFFALSE 7900
// SetTag ( i , 2 ) ;
7888: LD_VAR 0 1
7892: PPUSH
7893: LD_INT 2
7895: PPUSH
7896: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7900: LD_INT 81
7902: PUSH
7903: LD_INT 3
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 91
7912: PUSH
7913: LD_VAR 0 1
7917: PUSH
7918: LD_INT 12
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 69
7934: NOT
7935: PUSH
7936: LD_VAR 0 1
7940: PPUSH
7941: CALL_OW 110
7945: PUSH
7946: LD_INT 2
7948: EQUAL
7949: NOT
7950: AND
7951: IFFALSE 7970
// ComAgressiveMove ( i , 64 , 93 ) else
7953: LD_VAR 0 1
7957: PPUSH
7958: LD_INT 64
7960: PPUSH
7961: LD_INT 93
7963: PPUSH
7964: CALL_OW 114
7968: GO 8004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7970: LD_VAR 0 1
7974: PPUSH
7975: LD_INT 81
7977: PUSH
7978: LD_INT 3
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: PPUSH
7990: LD_VAR 0 1
7994: PPUSH
7995: CALL_OW 74
7999: PPUSH
8000: CALL_OW 115
// end ;
8004: GO 7855
8006: POP
8007: POP
// end ;
8008: PPOPN 2
8010: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8011: LD_INT 0
8013: PPUSH
8014: PPUSH
8015: PPUSH
// result := [ ] ;
8016: LD_ADDR_VAR 0 2
8020: PUSH
8021: EMPTY
8022: ST_TO_ADDR
// uc_side := 6 ;
8023: LD_ADDR_OWVAR 20
8027: PUSH
8028: LD_INT 6
8030: ST_TO_ADDR
// uc_nation := 3 ;
8031: LD_ADDR_OWVAR 21
8035: PUSH
8036: LD_INT 3
8038: ST_TO_ADDR
// case strength of 1 :
8039: LD_VAR 0 1
8043: PUSH
8044: LD_INT 1
8046: DOUBLE
8047: EQUAL
8048: IFTRUE 8052
8050: GO 8190
8052: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8053: LD_ADDR_VAR 0 3
8057: PUSH
8058: DOUBLE
8059: LD_INT 1
8061: DEC
8062: ST_TO_ADDR
8063: LD_INT 4
8065: PUSH
8066: LD_INT 5
8068: PUSH
8069: LD_INT 6
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_OWVAR 67
8081: ARRAY
8082: PUSH
8083: FOR_TO
8084: IFFALSE 8186
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8086: LD_INT 22
8088: PUSH
8089: LD_INT 24
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: LD_INT 2
8103: MOD
8104: PUSH
8105: LD_INT 1
8107: PLUS
8108: ARRAY
8109: PPUSH
8110: LD_INT 1
8112: PUSH
8113: LD_INT 3
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: LD_INT 1
8122: PPUSH
8123: LD_INT 2
8125: PPUSH
8126: CALL_OW 12
8130: ARRAY
8131: PPUSH
8132: LD_INT 3
8134: PPUSH
8135: LD_INT 43
8137: PUSH
8138: LD_INT 44
8140: PUSH
8141: LD_INT 45
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 1
8151: PPUSH
8152: LD_INT 3
8154: PPUSH
8155: CALL_OW 12
8159: ARRAY
8160: PPUSH
8161: LD_INT 80
8163: PPUSH
8164: CALL 70385 0 5
// result := result union CreateVehicle ;
8168: LD_ADDR_VAR 0 2
8172: PUSH
8173: LD_VAR 0 2
8177: PUSH
8178: CALL_OW 45
8182: UNION
8183: ST_TO_ADDR
// end ;
8184: GO 8083
8186: POP
8187: POP
// end ; 2 :
8188: GO 9134
8190: LD_INT 2
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8354
8198: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8199: LD_ADDR_VAR 0 3
8203: PUSH
8204: DOUBLE
8205: LD_INT 1
8207: DEC
8208: ST_TO_ADDR
8209: LD_INT 6
8211: PUSH
8212: LD_INT 6
8214: PUSH
8215: LD_INT 7
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_OWVAR 67
8227: ARRAY
8228: PUSH
8229: FOR_TO
8230: IFFALSE 8350
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8232: LD_INT 22
8234: PUSH
8235: LD_INT 24
8237: PUSH
8238: LD_INT 24
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: PUSH
8246: LD_VAR 0 3
8250: PUSH
8251: LD_INT 3
8253: MOD
8254: PUSH
8255: LD_INT 1
8257: PLUS
8258: ARRAY
8259: PPUSH
8260: LD_INT 1
8262: PUSH
8263: LD_INT 3
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 1
8272: PPUSH
8273: LD_INT 2
8275: PPUSH
8276: CALL_OW 12
8280: ARRAY
8281: PPUSH
8282: LD_INT 3
8284: PPUSH
8285: LD_INT 43
8287: PUSH
8288: LD_INT 44
8290: PUSH
8291: LD_INT 45
8293: PUSH
8294: LD_INT 44
8296: PUSH
8297: LD_INT 46
8299: PUSH
8300: LD_INT 46
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: PUSH
8311: LD_VAR 0 3
8315: PUSH
8316: LD_INT 6
8318: MOD
8319: PUSH
8320: LD_INT 1
8322: PLUS
8323: ARRAY
8324: PPUSH
8325: LD_INT 80
8327: PPUSH
8328: CALL 70385 0 5
// result := result union CreateVehicle ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_VAR 0 2
8341: PUSH
8342: CALL_OW 45
8346: UNION
8347: ST_TO_ADDR
// end ;
8348: GO 8229
8350: POP
8351: POP
// end ; 3 :
8352: GO 9134
8354: LD_INT 3
8356: DOUBLE
8357: EQUAL
8358: IFTRUE 8362
8360: GO 8518
8362: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8363: LD_ADDR_VAR 0 3
8367: PUSH
8368: DOUBLE
8369: LD_INT 1
8371: DEC
8372: ST_TO_ADDR
8373: LD_INT 6
8375: PUSH
8376: LD_INT 7
8378: PUSH
8379: LD_INT 8
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 47
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 45
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 70385 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 4 :
8516: GO 9134
8518: LD_INT 4
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 9133
8526: POP
// begin uc_nation := 3 ;
8527: LD_ADDR_OWVAR 21
8531: PUSH
8532: LD_INT 3
8534: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 7
8547: PUSH
8548: LD_INT 8
8550: PUSH
8551: LD_INT 9
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PUSH
8559: LD_OWVAR 67
8563: ARRAY
8564: PUSH
8565: FOR_TO
8566: IFFALSE 8686
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8568: LD_INT 22
8570: PUSH
8571: LD_INT 24
8573: PUSH
8574: LD_INT 24
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_VAR 0 3
8586: PUSH
8587: LD_INT 3
8589: MOD
8590: PUSH
8591: LD_INT 1
8593: PLUS
8594: ARRAY
8595: PPUSH
8596: LD_INT 1
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 1
8608: PPUSH
8609: LD_INT 2
8611: PPUSH
8612: CALL_OW 12
8616: ARRAY
8617: PPUSH
8618: LD_INT 3
8620: PPUSH
8621: LD_INT 45
8623: PUSH
8624: LD_INT 47
8626: PUSH
8627: LD_INT 47
8629: PUSH
8630: LD_INT 45
8632: PUSH
8633: LD_INT 46
8635: PUSH
8636: LD_INT 46
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: PUSH
8647: LD_VAR 0 3
8651: PUSH
8652: LD_INT 6
8654: MOD
8655: PUSH
8656: LD_INT 1
8658: PLUS
8659: ARRAY
8660: PPUSH
8661: LD_INT 80
8663: PPUSH
8664: CALL 70385 0 5
// result := result union CreateVehicle ;
8668: LD_ADDR_VAR 0 2
8672: PUSH
8673: LD_VAR 0 2
8677: PUSH
8678: CALL_OW 45
8682: UNION
8683: ST_TO_ADDR
// end ;
8684: GO 8565
8686: POP
8687: POP
// if not KappaStatus then
8688: LD_EXP 2
8692: NOT
8693: IFFALSE 8928
// begin uc_nation := 1 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// for i = 1 to 3 do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 3
8715: PUSH
8716: FOR_TO
8717: IFFALSE 8853
// begin j := rand ( 0 , 1 ) ;
8719: LD_ADDR_VAR 0 4
8723: PUSH
8724: LD_INT 0
8726: PPUSH
8727: LD_INT 1
8729: PPUSH
8730: CALL_OW 12
8734: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8735: LD_INT 3
8737: PUSH
8738: LD_INT 5
8740: PUSH
8741: LD_INT 5
8743: PUSH
8744: LD_INT 4
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: PUSH
8753: LD_VAR 0 4
8757: PUSH
8758: LD_INT 1
8760: PPUSH
8761: LD_INT 3
8763: PPUSH
8764: CALL_OW 12
8768: PLUS
8769: ARRAY
8770: PPUSH
8771: LD_INT 1
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 1
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 12
8791: ARRAY
8792: PPUSH
8793: LD_INT 3
8795: PPUSH
8796: LD_INT 9
8798: PUSH
8799: LD_INT 7
8801: PUSH
8802: LD_INT 6
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: LD_VAR 0 4
8814: PUSH
8815: LD_INT 1
8817: PPUSH
8818: LD_INT 2
8820: PPUSH
8821: CALL_OW 12
8825: PLUS
8826: ARRAY
8827: PPUSH
8828: LD_INT 85
8830: PPUSH
8831: CALL 70385 0 5
// result := result union CreateVehicle ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_VAR 0 2
8844: PUSH
8845: CALL_OW 45
8849: UNION
8850: ST_TO_ADDR
// end ;
8851: GO 8716
8853: POP
8854: POP
// if vsevolodFirstAttack then
8855: LD_EXP 24
8859: IFFALSE 8926
// begin vsevolodFirstAttack := false ;
8861: LD_ADDR_EXP 24
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8869: LD_INT 5
8871: PPUSH
8872: LD_INT 3
8874: PPUSH
8875: LD_INT 1
8877: PPUSH
8878: LD_INT 6
8880: PPUSH
8881: LD_INT 100
8883: PPUSH
8884: CALL 70385 0 5
// sewiVeh := CreateVehicle ;
8888: LD_ADDR_EXP 68
8892: PUSH
8893: CALL_OW 45
8897: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8898: LD_EXP 68
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: CALL_OW 242
// result := result union sewiVeh ;
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_VAR 0 2
8919: PUSH
8920: LD_EXP 68
8924: UNION
8925: ST_TO_ADDR
// end ; end else
8926: GO 9131
// if vsevolodFirstAttack then
8928: LD_EXP 24
8932: IFFALSE 9131
// begin vsevolodFirstAttack := false ;
8934: LD_ADDR_EXP 24
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// uc_nation := 3 ;
8942: LD_ADDR_OWVAR 21
8946: PUSH
8947: LD_INT 3
8949: ST_TO_ADDR
// for i = 1 to 3 do
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: DOUBLE
8956: LD_INT 1
8958: DEC
8959: ST_TO_ADDR
8960: LD_INT 3
8962: PUSH
8963: FOR_TO
8964: IFFALSE 9072
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8966: LD_INT 22
8968: PUSH
8969: LD_INT 24
8971: PUSH
8972: LD_INT 24
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: PUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_INT 3
8987: MOD
8988: PUSH
8989: LD_INT 1
8991: PLUS
8992: ARRAY
8993: PPUSH
8994: LD_INT 1
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: LD_INT 1
9006: PPUSH
9007: LD_INT 2
9009: PPUSH
9010: CALL_OW 12
9014: ARRAY
9015: PPUSH
9016: LD_INT 3
9018: PPUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 47
9024: PUSH
9025: LD_INT 47
9027: PUSH
9028: EMPTY
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_VAR 0 3
9037: PUSH
9038: LD_INT 3
9040: MOD
9041: PUSH
9042: LD_INT 1
9044: PLUS
9045: ARRAY
9046: PPUSH
9047: LD_INT 80
9049: PPUSH
9050: CALL 70385 0 5
// result := result union CreateVehicle ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: CALL_OW 45
9068: UNION
9069: ST_TO_ADDR
// end ;
9070: GO 8963
9072: POP
9073: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9074: LD_INT 24
9076: PPUSH
9077: LD_INT 3
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 47
9085: PPUSH
9086: LD_INT 100
9088: PPUSH
9089: CALL 70385 0 5
// sewiVeh := CreateVehicle ;
9093: LD_ADDR_EXP 68
9097: PUSH
9098: CALL_OW 45
9102: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9103: LD_EXP 68
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 242
// result := result union sewiVeh ;
9115: LD_ADDR_VAR 0 2
9119: PUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_EXP 68
9129: UNION
9130: ST_TO_ADDR
// end ; end ; end ;
9131: GO 9134
9133: POP
// end ;
9134: LD_VAR 0 2
9138: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9139: LD_EXP 16
9143: IFFALSE 9891
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
9153: PPUSH
9154: PPUSH
9155: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9156: LD_ADDR_VAR 0 4
9160: PUSH
9161: LD_INT 11
9163: PUSH
9164: LD_INT 12
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9171: LD_ADDR_VAR 0 3
9175: PUSH
9176: LD_INT 8400
9178: PUSH
9179: LD_INT 7350
9181: PUSH
9182: LD_INT 6650
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: LIST
9189: PUSH
9190: LD_OWVAR 67
9194: ARRAY
9195: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9196: LD_ADDR_VAR 0 6
9200: PUSH
9201: LD_INT 70
9203: PUSH
9204: LD_INT 118
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: LD_INT 78
9213: PUSH
9214: LD_INT 31
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: ST_TO_ADDR
// repeat if missionStage = 2 then
9225: LD_EXP 15
9229: PUSH
9230: LD_INT 2
9232: EQUAL
9233: IFFALSE 9244
// wait ( 1 1$30 ) else
9235: LD_INT 3150
9237: PPUSH
9238: CALL_OW 67
9242: GO 9253
// wait ( time ) ;
9244: LD_VAR 0 3
9248: PPUSH
9249: CALL_OW 67
// if missionStage = 6 then
9253: LD_EXP 15
9257: PUSH
9258: LD_INT 6
9260: EQUAL
9261: IFFALSE 9289
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9263: LD_INT 51
9265: PPUSH
9266: LD_INT 6
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9276: LD_INT 57
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 2
9284: PPUSH
9285: CALL_OW 322
// end ; if missionStage = 8 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 8
9296: EQUAL
9297: IFFALSE 9325
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9299: LD_INT 52
9301: PPUSH
9302: LD_INT 6
9304: PPUSH
9305: LD_INT 2
9307: PPUSH
9308: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9312: LD_INT 58
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 2
9320: PPUSH
9321: CALL_OW 322
// end ; if missionStage = 10 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: EQUAL
9333: IFFALSE 9361
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9335: LD_INT 53
9337: PPUSH
9338: LD_INT 6
9340: PPUSH
9341: LD_INT 2
9343: PPUSH
9344: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9348: LD_INT 59
9350: PPUSH
9351: LD_INT 6
9353: PPUSH
9354: LD_INT 2
9356: PPUSH
9357: CALL_OW 322
// end ; if activeAttacks then
9361: LD_EXP 16
9365: IFFALSE 9885
// begin if missionStage = 2 then
9367: LD_EXP 15
9371: PUSH
9372: LD_INT 2
9374: EQUAL
9375: IFFALSE 9385
// strength := 1 ;
9377: LD_ADDR_VAR 0 5
9381: PUSH
9382: LD_INT 1
9384: ST_TO_ADDR
// if missionStage > 2 then
9385: LD_EXP 15
9389: PUSH
9390: LD_INT 2
9392: GREATER
9393: IFFALSE 9403
// strength := 2 ;
9395: LD_ADDR_VAR 0 5
9399: PUSH
9400: LD_INT 2
9402: ST_TO_ADDR
// if missionStage > 6 then
9403: LD_EXP 15
9407: PUSH
9408: LD_INT 6
9410: GREATER
9411: IFFALSE 9421
// strength := 3 ;
9413: LD_ADDR_VAR 0 5
9417: PUSH
9418: LD_INT 3
9420: ST_TO_ADDR
// if missionStage > 10 then
9421: LD_EXP 15
9425: PUSH
9426: LD_INT 10
9428: GREATER
9429: IFFALSE 9439
// strength := 4 ;
9431: LD_ADDR_VAR 0 5
9435: PUSH
9436: LD_INT 4
9438: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9439: LD_ADDR_VAR 0 2
9443: PUSH
9444: LD_VAR 0 5
9448: PPUSH
9449: CALL 8011 0 1
9453: ST_TO_ADDR
// for i in tmp do
9454: LD_ADDR_VAR 0 1
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: FOR_IN
9465: IFFALSE 9565
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9467: LD_VAR 0 1
9471: PPUSH
9472: LD_VAR 0 4
9476: PUSH
9477: LD_INT 1
9479: PPUSH
9480: LD_INT 2
9482: PPUSH
9483: CALL_OW 12
9487: ARRAY
9488: PPUSH
9489: LD_INT 0
9491: PPUSH
9492: CALL_OW 49
// if i = sewiVeh then
9496: LD_VAR 0 1
9500: PUSH
9501: LD_EXP 68
9505: EQUAL
9506: IFFALSE 9541
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9508: LD_ADDR_EXP 67
9512: PUSH
9513: LD_STRING Vsevolod
9515: PPUSH
9516: LD_INT 0
9518: PPUSH
9519: LD_STRING 
9521: PPUSH
9522: CALL 63608 0 3
9526: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9527: LD_EXP 67
9531: PPUSH
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9541: LD_VAR 0 1
9545: PPUSH
9546: LD_INT 111
9548: PPUSH
9549: LD_INT 197
9551: PPUSH
9552: CALL_OW 111
// wait ( 0 0$2 ) ;
9556: LD_INT 70
9558: PPUSH
9559: CALL_OW 67
// end ;
9563: GO 9464
9565: POP
9566: POP
// repeat wait ( 0 0$1 ) ;
9567: LD_INT 35
9569: PPUSH
9570: CALL_OW 67
// for i in tmp do
9574: LD_ADDR_VAR 0 1
9578: PUSH
9579: LD_VAR 0 2
9583: PUSH
9584: FOR_IN
9585: IFFALSE 9866
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9587: LD_INT 81
9589: PUSH
9590: LD_INT 6
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PUSH
9597: LD_INT 91
9599: PUSH
9600: LD_VAR 0 1
9604: PUSH
9605: LD_INT 12
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PPUSH
9617: CALL_OW 69
9621: IFFALSE 9679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9623: LD_VAR 0 1
9627: PPUSH
9628: LD_INT 81
9630: PUSH
9631: LD_INT 6
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PUSH
9638: LD_INT 91
9640: PUSH
9641: LD_VAR 0 1
9645: PUSH
9646: LD_INT 12
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: LIST
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PPUSH
9658: CALL_OW 69
9662: PPUSH
9663: LD_VAR 0 1
9667: PPUSH
9668: CALL_OW 74
9672: PPUSH
9673: CALL_OW 115
9677: GO 9864
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9679: LD_INT 9
9681: PPUSH
9682: LD_INT 81
9684: PUSH
9685: LD_INT 6
9687: PUSH
9688: EMPTY
9689: LIST
9690: LIST
9691: PPUSH
9692: CALL_OW 70
9696: IFFALSE 9830
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9698: LD_VAR 0 1
9702: PPUSH
9703: LD_VAR 0 6
9707: PUSH
9708: LD_INT 1
9710: ARRAY
9711: PUSH
9712: LD_INT 1
9714: ARRAY
9715: PPUSH
9716: LD_VAR 0 6
9720: PUSH
9721: LD_INT 1
9723: ARRAY
9724: PUSH
9725: LD_INT 2
9727: ARRAY
9728: PPUSH
9729: CALL_OW 297
9733: PUSH
9734: LD_INT 10
9736: GREATER
9737: PUSH
9738: LD_VAR 0 1
9742: PPUSH
9743: LD_INT 9
9745: PPUSH
9746: CALL_OW 308
9750: NOT
9751: AND
9752: IFFALSE 9791
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9754: LD_VAR 0 1
9758: PPUSH
9759: LD_VAR 0 6
9763: PUSH
9764: LD_INT 1
9766: ARRAY
9767: PUSH
9768: LD_INT 1
9770: ARRAY
9771: PPUSH
9772: LD_VAR 0 6
9776: PUSH
9777: LD_INT 1
9779: ARRAY
9780: PUSH
9781: LD_INT 2
9783: ARRAY
9784: PPUSH
9785: CALL_OW 114
9789: GO 9828
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_INT 9
9798: PPUSH
9799: LD_INT 81
9801: PUSH
9802: LD_INT 6
9804: PUSH
9805: EMPTY
9806: LIST
9807: LIST
9808: PPUSH
9809: CALL_OW 70
9813: PPUSH
9814: LD_VAR 0 1
9818: PPUSH
9819: CALL_OW 74
9823: PPUSH
9824: CALL_OW 115
// end else
9828: GO 9864
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9830: LD_VAR 0 1
9834: PPUSH
9835: LD_INT 81
9837: PUSH
9838: LD_INT 6
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: PPUSH
9845: CALL_OW 69
9849: PPUSH
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 74
9859: PPUSH
9860: CALL_OW 115
// end ;
9864: GO 9584
9866: POP
9867: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9868: LD_INT 22
9870: PUSH
9871: LD_INT 6
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PPUSH
9878: CALL_OW 69
9882: NOT
9883: IFFALSE 9567
// end ; until russianDestroyed ;
9885: LD_EXP 21
9889: IFFALSE 9225
// end ;
9891: PPOPN 6
9893: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9894: LD_EXP 21
9898: NOT
9899: PUSH
9900: LD_EXP 15
9904: PUSH
9905: LD_INT 6
9907: GREATEREQUAL
9908: AND
9909: PUSH
9910: LD_INT 2
9912: PPUSH
9913: LD_INT 1
9915: PPUSH
9916: CALL 58816 0 2
9920: NOT
9921: AND
9922: IFFALSE 10878
9924: GO 9926
9926: DISABLE
9927: LD_INT 0
9929: PPUSH
9930: PPUSH
9931: PPUSH
9932: PPUSH
// begin enable ;
9933: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9934: LD_INT 22
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: LD_INT 30
9946: PUSH
9947: LD_INT 3
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PPUSH
9958: CALL_OW 69
9962: NOT
9963: IFFALSE 9967
// exit ;
9965: GO 10878
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9967: LD_ADDR_VAR 0 4
9971: PUSH
9972: LD_INT 22
9974: PUSH
9975: LD_INT 3
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: LD_INT 30
9984: PUSH
9985: LD_INT 34
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PPUSH
9996: CALL_OW 69
10000: ST_TO_ADDR
// if Prob ( 40 ) then
10001: LD_INT 40
10003: PPUSH
10004: CALL_OW 13
10008: IFFALSE 10135
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10010: LD_INT 2
10012: PPUSH
10013: LD_INT 22
10015: PUSH
10016: LD_INT 3
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: LD_INT 49
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: LD_INT 3
10039: PUSH
10040: LD_INT 49
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: LIST
10048: PUSH
10049: LD_INT 22
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 49
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 46
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 46
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 24
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: LD_INT 46
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL 57398 0 2
// end else
10133: GO 10258
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10135: LD_INT 2
10137: PPUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 47
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 47
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 24
10176: PUSH
10177: LD_INT 3
10179: PUSH
10180: LD_INT 3
10182: PUSH
10183: LD_INT 47
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: PUSH
10192: LD_INT 24
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: LD_INT 46
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_INT 24
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 3
10218: PUSH
10219: LD_INT 46
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 24
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 46
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: LIST
10253: PPUSH
10254: CALL 57398 0 2
// end ; if Difficulty > 1 then
10258: LD_OWVAR 67
10262: PUSH
10263: LD_INT 1
10265: GREATER
10266: IFFALSE 10296
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10268: LD_INT 2
10270: PPUSH
10271: LD_INT 24
10273: PUSH
10274: LD_INT 3
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: LD_INT 47
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: PUSH
10289: EMPTY
10290: LIST
10291: PPUSH
10292: CALL 57398 0 2
// repeat wait ( 0 0$1 ) ;
10296: LD_INT 35
10298: PPUSH
10299: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10303: LD_INT 2
10305: PPUSH
10306: LD_INT 1
10308: PPUSH
10309: CALL 58816 0 2
10313: PUSH
10314: LD_INT 6
10316: PUSH
10317: LD_INT 7
10319: PUSH
10320: LD_INT 7
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: LIST
10327: PUSH
10328: LD_OWVAR 67
10332: ARRAY
10333: GREATEREQUAL
10334: IFFALSE 10296
// wait ( 0 0$30 ) ;
10336: LD_INT 1050
10338: PPUSH
10339: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10343: LD_ADDR_VAR 0 2
10347: PUSH
10348: LD_INT 2
10350: PPUSH
10351: LD_INT 1
10353: PPUSH
10354: CALL 58816 0 2
10358: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10359: LD_ADDR_EXP 118
10363: PUSH
10364: LD_EXP 118
10368: PPUSH
10369: LD_INT 2
10371: PPUSH
10372: LD_EXP 118
10376: PUSH
10377: LD_INT 2
10379: ARRAY
10380: PUSH
10381: LD_VAR 0 2
10385: DIFF
10386: PPUSH
10387: CALL_OW 1
10391: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10392: LD_ADDR_VAR 0 3
10396: PUSH
10397: LD_INT 0
10399: PPUSH
10400: LD_INT 1
10402: PPUSH
10403: CALL_OW 12
10407: ST_TO_ADDR
// if target then
10408: LD_VAR 0 3
10412: IFFALSE 10540
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10414: LD_ADDR_VAR 0 2
10418: PUSH
10419: LD_VAR 0 2
10423: PPUSH
10424: LD_INT 24
10426: PUSH
10427: LD_INT 250
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PPUSH
10434: CALL_OW 72
10438: ST_TO_ADDR
// for i in tmp do
10439: LD_ADDR_VAR 0 1
10443: PUSH
10444: LD_VAR 0 2
10448: PUSH
10449: FOR_IN
10450: IFFALSE 10490
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10452: LD_VAR 0 1
10456: PPUSH
10457: LD_INT 139
10459: PPUSH
10460: LD_INT 89
10462: PPUSH
10463: CALL_OW 297
10467: PUSH
10468: LD_INT 9
10470: GREATER
10471: IFFALSE 10488
// ComMoveXY ( i , 139 , 89 ) ;
10473: LD_VAR 0 1
10477: PPUSH
10478: LD_INT 139
10480: PPUSH
10481: LD_INT 89
10483: PPUSH
10484: CALL_OW 111
10488: GO 10449
10490: POP
10491: POP
// wait ( 0 0$1 ) ;
10492: LD_INT 35
10494: PPUSH
10495: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10499: LD_VAR 0 2
10503: PPUSH
10504: LD_INT 92
10506: PUSH
10507: LD_INT 139
10509: PUSH
10510: LD_INT 89
10512: PUSH
10513: LD_INT 9
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: PPUSH
10522: CALL_OW 72
10526: PUSH
10527: LD_VAR 0 2
10531: PUSH
10532: LD_INT 1
10534: MINUS
10535: GREATEREQUAL
10536: IFFALSE 10414
// end else
10538: GO 10682
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10540: LD_VAR 0 2
10544: PPUSH
10545: LD_VAR 0 4
10549: PUSH
10550: LD_INT 1
10552: ARRAY
10553: PPUSH
10554: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10558: LD_ADDR_VAR 0 2
10562: PUSH
10563: LD_VAR 0 2
10567: PPUSH
10568: LD_INT 24
10570: PUSH
10571: LD_INT 250
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PPUSH
10578: CALL_OW 72
10582: ST_TO_ADDR
// for i in tmp do
10583: LD_ADDR_VAR 0 1
10587: PUSH
10588: LD_VAR 0 2
10592: PUSH
10593: FOR_IN
10594: IFFALSE 10634
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10596: LD_VAR 0 1
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 139
10606: PPUSH
10607: CALL_OW 297
10611: PUSH
10612: LD_INT 9
10614: GREATER
10615: IFFALSE 10632
// ComMoveXY ( i , 124 , 139 ) ;
10617: LD_VAR 0 1
10621: PPUSH
10622: LD_INT 124
10624: PPUSH
10625: LD_INT 139
10627: PPUSH
10628: CALL_OW 111
10632: GO 10593
10634: POP
10635: POP
// wait ( 0 0$1 ) ;
10636: LD_INT 35
10638: PPUSH
10639: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10643: LD_VAR 0 2
10647: PPUSH
10648: LD_INT 92
10650: PUSH
10651: LD_INT 124
10653: PUSH
10654: LD_INT 139
10656: PUSH
10657: LD_INT 9
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 72
10670: PUSH
10671: LD_VAR 0 2
10675: PUSH
10676: LD_INT 1
10678: MINUS
10679: GREATEREQUAL
10680: IFFALSE 10558
// end ; repeat wait ( 0 0$1 ) ;
10682: LD_INT 35
10684: PPUSH
10685: CALL_OW 67
// for i in tmp do
10689: LD_ADDR_VAR 0 1
10693: PUSH
10694: LD_VAR 0 2
10698: PUSH
10699: FOR_IN
10700: IFFALSE 10869
// begin if GetLives ( i ) > 251 then
10702: LD_VAR 0 1
10706: PPUSH
10707: CALL_OW 256
10711: PUSH
10712: LD_INT 251
10714: GREATER
10715: IFFALSE 10840
// begin if GetWeapon ( i ) = ru_time_lapser then
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 264
10726: PUSH
10727: LD_INT 49
10729: EQUAL
10730: IFFALSE 10786
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10732: LD_VAR 0 1
10736: PPUSH
10737: LD_INT 2
10739: PUSH
10740: LD_INT 22
10742: PUSH
10743: LD_INT 1
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 22
10752: PUSH
10753: LD_INT 8
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PPUSH
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 74
10779: PPUSH
10780: CALL_OW 112
10784: GO 10838
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10786: LD_VAR 0 1
10790: PPUSH
10791: LD_INT 2
10793: PUSH
10794: LD_INT 22
10796: PUSH
10797: LD_INT 1
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PUSH
10804: LD_INT 22
10806: PUSH
10807: LD_INT 8
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: LIST
10818: PPUSH
10819: CALL_OW 69
10823: PPUSH
10824: LD_VAR 0 1
10828: PPUSH
10829: CALL_OW 74
10833: PPUSH
10834: CALL_OW 115
// end else
10838: GO 10867
// if IsDead ( i ) then
10840: LD_VAR 0 1
10844: PPUSH
10845: CALL_OW 301
10849: IFFALSE 10867
// tmp := tmp diff i ;
10851: LD_ADDR_VAR 0 2
10855: PUSH
10856: LD_VAR 0 2
10860: PUSH
10861: LD_VAR 0 1
10865: DIFF
10866: ST_TO_ADDR
// end ;
10867: GO 10699
10869: POP
10870: POP
// until not tmp ;
10871: LD_VAR 0 2
10875: NOT
10876: IFFALSE 10682
// end ; end_of_file
10878: PPOPN 4
10880: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10881: LD_INT 0
10883: PPUSH
10884: PPUSH
10885: PPUSH
10886: PPUSH
10887: PPUSH
10888: PPUSH
// side := 7 ;
10889: LD_ADDR_VAR 0 5
10893: PUSH
10894: LD_INT 7
10896: ST_TO_ADDR
// uc_side := side ;
10897: LD_ADDR_OWVAR 20
10901: PUSH
10902: LD_VAR 0 5
10906: ST_TO_ADDR
// uc_nation := 1 ;
10907: LD_ADDR_OWVAR 21
10911: PUSH
10912: LD_INT 1
10914: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10915: LD_ADDR_VAR 0 2
10919: PUSH
10920: LD_INT 22
10922: PUSH
10923: LD_VAR 0 5
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 21
10934: PUSH
10935: LD_INT 3
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 69
10950: PUSH
10951: FOR_IN
10952: IFFALSE 10968
// SetBLevel ( i , 10 ) ;
10954: LD_VAR 0 2
10958: PPUSH
10959: LD_INT 10
10961: PPUSH
10962: CALL_OW 241
10966: GO 10951
10968: POP
10969: POP
// base := GetBase ( al_depot ) ;
10970: LD_ADDR_VAR 0 4
10974: PUSH
10975: LD_INT 2
10977: PPUSH
10978: CALL_OW 274
10982: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10983: LD_ADDR_VAR 0 6
10987: PUSH
10988: LD_INT 22
10990: PUSH
10991: LD_VAR 0 5
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PUSH
11000: LD_INT 30
11002: PUSH
11003: LD_INT 34
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: EMPTY
11011: LIST
11012: LIST
11013: PPUSH
11014: CALL_OW 69
11018: ST_TO_ADDR
// if teleport then
11019: LD_VAR 0 6
11023: IFFALSE 11044
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11025: LD_VAR 0 6
11029: PUSH
11030: LD_INT 1
11032: ARRAY
11033: PPUSH
11034: LD_INT 262
11036: PPUSH
11037: LD_INT 119
11039: PPUSH
11040: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11044: LD_VAR 0 4
11048: PPUSH
11049: LD_INT 1
11051: PPUSH
11052: LD_INT 19500
11054: PPUSH
11055: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11059: LD_VAR 0 4
11063: PPUSH
11064: LD_INT 2
11066: PPUSH
11067: LD_INT 200
11069: PPUSH
11070: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11074: LD_VAR 0 4
11078: PPUSH
11079: LD_INT 3
11081: PPUSH
11082: LD_INT 650
11084: PPUSH
11085: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11089: LD_ADDR_EXP 71
11093: PUSH
11094: LD_STRING Roth
11096: PPUSH
11097: CALL_OW 25
11101: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11102: LD_ADDR_EXP 72
11106: PUSH
11107: LD_STRING Simms
11109: PPUSH
11110: LD_EXP 1
11114: NOT
11115: PPUSH
11116: LD_STRING 10c_
11118: PPUSH
11119: CALL 63608 0 3
11123: ST_TO_ADDR
// if not Simms then
11124: LD_EXP 72
11128: NOT
11129: IFFALSE 11159
// begin uc_nation := 1 ;
11131: LD_ADDR_OWVAR 21
11135: PUSH
11136: LD_INT 1
11138: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11139: LD_INT 2
11141: PPUSH
11142: LD_INT 10
11144: PPUSH
11145: CALL_OW 384
// Simms := CreateHuman ;
11149: LD_ADDR_EXP 72
11153: PUSH
11154: CALL_OW 44
11158: ST_TO_ADDR
// end ; uc_nation := 3 ;
11159: LD_ADDR_OWVAR 21
11163: PUSH
11164: LD_INT 3
11166: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11167: LD_ADDR_EXP 73
11171: PUSH
11172: LD_STRING Kirilenkova
11174: PPUSH
11175: CALL_OW 25
11179: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11180: LD_ADDR_EXP 87
11184: PUSH
11185: LD_STRING Oblukov
11187: PPUSH
11188: CALL_OW 25
11192: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11193: LD_ADDR_EXP 74
11197: PUSH
11198: LD_STRING Dolgov
11200: PPUSH
11201: CALL_OW 25
11205: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11206: LD_ADDR_EXP 75
11210: PUSH
11211: LD_STRING Petrosyan
11213: PPUSH
11214: CALL_OW 25
11218: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11219: LD_ADDR_EXP 86
11223: PUSH
11224: LD_STRING Scholtze
11226: PPUSH
11227: CALL_OW 25
11231: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11232: LD_ADDR_EXP 85
11236: PUSH
11237: LD_STRING Kapitsova
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11245: LD_ADDR_EXP 76
11249: PUSH
11250: LD_STRING Petrovova
11252: PPUSH
11253: CALL_OW 25
11257: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11258: LD_ADDR_EXP 77
11262: PUSH
11263: LD_STRING Kuzmov
11265: PPUSH
11266: CALL_OW 25
11270: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11271: LD_ADDR_EXP 84
11275: PUSH
11276: LD_STRING Karamazov
11278: PPUSH
11279: CALL_OW 25
11283: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11284: LD_STRING 13_Lipshchin_1
11286: PPUSH
11287: LD_INT 0
11289: PPUSH
11290: CALL_OW 30
11294: IFFALSE 11309
// Lipshchin := NewCharacter ( Lipshchin ) ;
11296: LD_ADDR_EXP 78
11300: PUSH
11301: LD_STRING Lipshchin
11303: PPUSH
11304: CALL_OW 25
11308: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11309: LD_STRING 13_Titov_1
11311: PPUSH
11312: LD_INT 0
11314: PPUSH
11315: CALL_OW 30
11319: IFFALSE 11334
// Titov := NewCharacter ( Titov ) ;
11321: LD_ADDR_EXP 80
11325: PUSH
11326: LD_STRING Titov
11328: PPUSH
11329: CALL_OW 25
11333: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11334: LD_STRING 13_Gnyevko_1
11336: PPUSH
11337: LD_INT 0
11339: PPUSH
11340: CALL_OW 30
11344: IFFALSE 11359
// Gnyevko := NewCharacter ( Gnyevko ) ;
11346: LD_ADDR_EXP 79
11350: PUSH
11351: LD_STRING Gnyevko
11353: PPUSH
11354: CALL_OW 25
11358: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11359: LD_STRING 13_Xavier_1
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL_OW 30
11369: IFFALSE 11384
// Xavier := NewCharacter ( Xavier2 ) ;
11371: LD_ADDR_EXP 81
11375: PUSH
11376: LD_STRING Xavier2
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11384: LD_STRING 13_Belkov_1
11386: PPUSH
11387: LD_INT 0
11389: PPUSH
11390: CALL_OW 30
11394: IFFALSE 11409
// Belkov := NewCharacter ( Belkov ) ;
11396: LD_ADDR_EXP 82
11400: PUSH
11401: LD_STRING Belkov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// if not BurlakStatus then
11409: LD_EXP 9
11413: NOT
11414: IFFALSE 11429
// Burlak = NewCharacter ( Burlak ) ;
11416: LD_ADDR_EXP 83
11420: PUSH
11421: LD_STRING Burlak
11423: PPUSH
11424: CALL_OW 25
11428: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11429: LD_ADDR_VAR 0 3
11433: PUSH
11434: LD_EXP 71
11438: PUSH
11439: LD_EXP 73
11443: PUSH
11444: LD_EXP 87
11448: PUSH
11449: LD_EXP 74
11453: PUSH
11454: LD_EXP 75
11458: PUSH
11459: LD_EXP 86
11463: PUSH
11464: LD_EXP 85
11468: PUSH
11469: LD_EXP 76
11473: PUSH
11474: LD_EXP 77
11478: PUSH
11479: LD_EXP 84
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: ST_TO_ADDR
// if Simms then
11496: LD_EXP 72
11500: IFFALSE 11518
// tmp := tmp ^ Simms ;
11502: LD_ADDR_VAR 0 3
11506: PUSH
11507: LD_VAR 0 3
11511: PUSH
11512: LD_EXP 72
11516: ADD
11517: ST_TO_ADDR
// if Titov then
11518: LD_EXP 80
11522: IFFALSE 11540
// tmp := tmp ^ Titov ;
11524: LD_ADDR_VAR 0 3
11528: PUSH
11529: LD_VAR 0 3
11533: PUSH
11534: LD_EXP 80
11538: ADD
11539: ST_TO_ADDR
// if Lipshchin then
11540: LD_EXP 78
11544: IFFALSE 11562
// tmp := tmp ^ Lipshchin ;
11546: LD_ADDR_VAR 0 3
11550: PUSH
11551: LD_VAR 0 3
11555: PUSH
11556: LD_EXP 78
11560: ADD
11561: ST_TO_ADDR
// if Gnyevko then
11562: LD_EXP 79
11566: IFFALSE 11584
// tmp := tmp ^ Gnyevko ;
11568: LD_ADDR_VAR 0 3
11572: PUSH
11573: LD_VAR 0 3
11577: PUSH
11578: LD_EXP 79
11582: ADD
11583: ST_TO_ADDR
// if Xavier then
11584: LD_EXP 81
11588: IFFALSE 11606
// tmp := tmp ^ Xavier ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_VAR 0 3
11599: PUSH
11600: LD_EXP 81
11604: ADD
11605: ST_TO_ADDR
// if Belkov then
11606: LD_EXP 82
11610: IFFALSE 11628
// tmp := tmp ^ Belkov ;
11612: LD_ADDR_VAR 0 3
11616: PUSH
11617: LD_VAR 0 3
11621: PUSH
11622: LD_EXP 82
11626: ADD
11627: ST_TO_ADDR
// if Burlak then
11628: LD_EXP 83
11632: IFFALSE 11650
// tmp := tmp ^ Burlak ;
11634: LD_ADDR_VAR 0 3
11638: PUSH
11639: LD_VAR 0 3
11643: PUSH
11644: LD_EXP 83
11648: ADD
11649: ST_TO_ADDR
// for i = 1 to 8 do
11650: LD_ADDR_VAR 0 2
11654: PUSH
11655: DOUBLE
11656: LD_INT 1
11658: DEC
11659: ST_TO_ADDR
11660: LD_INT 8
11662: PUSH
11663: FOR_TO
11664: IFFALSE 11730
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11666: LD_ADDR_OWVAR 21
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: LD_INT 3
11676: PUSH
11677: EMPTY
11678: LIST
11679: LIST
11680: PUSH
11681: LD_INT 1
11683: PPUSH
11684: LD_INT 2
11686: PPUSH
11687: CALL_OW 12
11691: ARRAY
11692: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11693: LD_INT 0
11695: PPUSH
11696: LD_VAR 0 2
11700: PUSH
11701: LD_INT 2
11703: DIV
11704: PPUSH
11705: LD_INT 10
11707: PPUSH
11708: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11712: LD_ADDR_VAR 0 3
11716: PUSH
11717: LD_VAR 0 3
11721: PUSH
11722: CALL_OW 44
11726: ADD
11727: ST_TO_ADDR
// end ;
11728: GO 11663
11730: POP
11731: POP
// for i in tmp do
11732: LD_ADDR_VAR 0 2
11736: PUSH
11737: LD_VAR 0 3
11741: PUSH
11742: FOR_IN
11743: IFFALSE 11768
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11745: LD_VAR 0 2
11749: PPUSH
11750: LD_INT 260
11752: PPUSH
11753: LD_INT 235
11755: PPUSH
11756: LD_INT 8
11758: PPUSH
11759: LD_INT 0
11761: PPUSH
11762: CALL_OW 50
11766: GO 11742
11768: POP
11769: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11770: LD_ADDR_EXP 99
11774: PUSH
11775: LD_EXP 99
11779: PPUSH
11780: LD_INT 1
11782: PPUSH
11783: LD_INT 22
11785: PUSH
11786: LD_VAR 0 5
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: LD_INT 3
11797: PUSH
11798: LD_INT 21
11800: PUSH
11801: LD_INT 2
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PPUSH
11816: CALL_OW 69
11820: PUSH
11821: LD_EXP 71
11825: PUSH
11826: LD_EXP 72
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: DIFF
11835: PPUSH
11836: CALL_OW 1
11840: ST_TO_ADDR
// uc_side := 0 ;
11841: LD_ADDR_OWVAR 20
11845: PUSH
11846: LD_INT 0
11848: ST_TO_ADDR
// uc_nation := 0 ;
11849: LD_ADDR_OWVAR 21
11853: PUSH
11854: LD_INT 0
11856: ST_TO_ADDR
// for i = 1 to 5 do
11857: LD_ADDR_VAR 0 2
11861: PUSH
11862: DOUBLE
11863: LD_INT 1
11865: DEC
11866: ST_TO_ADDR
11867: LD_INT 5
11869: PUSH
11870: FOR_TO
11871: IFFALSE 11908
// begin InitHc ;
11873: CALL_OW 19
// hc_class := class_apeman ;
11877: LD_ADDR_OWVAR 28
11881: PUSH
11882: LD_INT 12
11884: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11885: CALL_OW 44
11889: PPUSH
11890: LD_INT 299
11892: PPUSH
11893: LD_INT 229
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: LD_INT 0
11901: PPUSH
11902: CALL_OW 50
// end ;
11906: GO 11870
11908: POP
11909: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11910: LD_EXP 71
11914: PPUSH
11915: LD_INT 259
11917: PPUSH
11918: LD_INT 235
11920: PPUSH
11921: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11925: LD_EXP 71
11929: PPUSH
11930: LD_INT 262
11932: PPUSH
11933: LD_INT 235
11935: PPUSH
11936: CALL_OW 178
// if Simms then
11940: LD_EXP 72
11944: IFFALSE 11975
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11946: LD_EXP 72
11950: PPUSH
11951: LD_INT 262
11953: PPUSH
11954: LD_INT 235
11956: PPUSH
11957: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11961: LD_EXP 72
11965: PPUSH
11966: LD_EXP 71
11970: PPUSH
11971: CALL_OW 179
// end ; end ;
11975: LD_VAR 0 1
11979: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11980: LD_EXP 31
11984: PUSH
11985: LD_EXP 23
11989: NOT
11990: AND
11991: IFFALSE 12167
11993: GO 11995
11995: DISABLE
11996: LD_INT 0
11998: PPUSH
11999: PPUSH
12000: PPUSH
// begin enable ;
12001: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12002: LD_ADDR_VAR 0 2
12006: PUSH
12007: LD_INT 81
12009: PUSH
12010: LD_INT 7
12012: PUSH
12013: EMPTY
12014: LIST
12015: LIST
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: LD_INT 32
12022: PUSH
12023: LD_INT 3
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: LD_INT 30
12032: PUSH
12033: LD_INT 30
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 30
12042: PUSH
12043: LD_INT 28
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 34
12052: PUSH
12053: LD_INT 49
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: LD_INT 34
12062: PUSH
12063: LD_INT 10
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 34
12072: PUSH
12073: LD_INT 8
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PPUSH
12093: CALL_OW 69
12097: ST_TO_ADDR
// if not tmp then
12098: LD_VAR 0 2
12102: NOT
12103: IFFALSE 12107
// exit ;
12105: GO 12167
// target := tmp [ rand ( 1 , tmp ) ] ;
12107: LD_ADDR_VAR 0 3
12111: PUSH
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 1
12119: PPUSH
12120: LD_VAR 0 2
12124: PPUSH
12125: CALL_OW 12
12129: ARRAY
12130: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12131: LD_VAR 0 3
12135: PPUSH
12136: CALL_OW 255
12140: PUSH
12141: LD_INT 1
12143: EQUAL
12144: IFFALSE 12155
// CenterNowOnUnits ( target ) ;
12146: LD_VAR 0 3
12150: PPUSH
12151: CALL_OW 87
// SetLives ( target , 0 ) ;
12155: LD_VAR 0 3
12159: PPUSH
12160: LD_INT 0
12162: PPUSH
12163: CALL_OW 234
// end ;
12167: PPOPN 3
12169: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12170: LD_EXP 23
12174: NOT
12175: PUSH
12176: LD_EXP 31
12180: AND
12181: IFFALSE 12703
12183: GO 12185
12185: DISABLE
12186: LD_INT 0
12188: PPUSH
12189: PPUSH
12190: PPUSH
// begin uc_side := 7 ;
12191: LD_ADDR_OWVAR 20
12195: PUSH
12196: LD_INT 7
12198: ST_TO_ADDR
// uc_nation := 1 ;
12199: LD_ADDR_OWVAR 21
12203: PUSH
12204: LD_INT 1
12206: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12207: LD_ADDR_VAR 0 3
12211: PUSH
12212: LD_INT 125
12214: PUSH
12215: LD_INT 163
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 185
12224: PUSH
12225: LD_INT 168
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 111
12234: PUSH
12235: LD_INT 97
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: PPUSH
12247: CALL 106222 0 1
12251: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12252: LD_ADDR_EXP 88
12256: PUSH
12257: EMPTY
12258: ST_TO_ADDR
// for i = 1 to Difficulty do
12259: LD_ADDR_VAR 0 1
12263: PUSH
12264: DOUBLE
12265: LD_INT 1
12267: DEC
12268: ST_TO_ADDR
12269: LD_OWVAR 67
12273: PUSH
12274: FOR_TO
12275: IFFALSE 12433
// begin InitHc ;
12277: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12281: LD_INT 0
12283: PPUSH
12284: LD_INT 8
12286: PPUSH
12287: CALL_OW 381
// un := CreateHuman ;
12291: LD_ADDR_VAR 0 2
12295: PUSH
12296: CALL_OW 44
12300: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12301: LD_VAR 0 2
12305: PPUSH
12306: LD_INT 258
12308: PPUSH
12309: LD_INT 267
12311: PPUSH
12312: LD_INT 4
12314: PPUSH
12315: LD_INT 0
12317: PPUSH
12318: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12322: LD_ADDR_EXP 88
12326: PUSH
12327: LD_EXP 88
12331: PUSH
12332: LD_VAR 0 2
12336: UNION
12337: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12338: LD_VAR 0 2
12342: PPUSH
12343: LD_VAR 0 3
12347: PUSH
12348: LD_VAR 0 1
12352: ARRAY
12353: PUSH
12354: LD_INT 1
12356: ARRAY
12357: PPUSH
12358: LD_VAR 0 3
12362: PUSH
12363: LD_VAR 0 1
12367: ARRAY
12368: PUSH
12369: LD_INT 2
12371: ARRAY
12372: PPUSH
12373: LD_INT 4
12375: PPUSH
12376: LD_INT 1
12378: PPUSH
12379: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12383: LD_VAR 0 2
12387: PPUSH
12388: LD_VAR 0 3
12392: PUSH
12393: LD_VAR 0 1
12397: ARRAY
12398: PUSH
12399: LD_INT 1
12401: ARRAY
12402: PPUSH
12403: LD_VAR 0 3
12407: PUSH
12408: LD_VAR 0 1
12412: ARRAY
12413: PUSH
12414: LD_INT 2
12416: ARRAY
12417: PPUSH
12418: CALL_OW 171
// AddComInvisible ( un ) ;
12422: LD_VAR 0 2
12426: PPUSH
12427: CALL_OW 212
// end ;
12431: GO 12274
12433: POP
12434: POP
// repeat wait ( 0 0$20 ) ;
12435: LD_INT 700
12437: PPUSH
12438: CALL_OW 67
// for i in allianceSpecialForce do
12442: LD_ADDR_VAR 0 1
12446: PUSH
12447: LD_EXP 88
12451: PUSH
12452: FOR_IN
12453: IFFALSE 12688
// begin if IsInvisible ( i ) then
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 571
12464: IFFALSE 12657
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12466: LD_ADDR_VAR 0 3
12470: PUSH
12471: LD_INT 22
12473: PUSH
12474: LD_INT 1
12476: PUSH
12477: EMPTY
12478: LIST
12479: LIST
12480: PUSH
12481: LD_INT 50
12483: PUSH
12484: EMPTY
12485: LIST
12486: PUSH
12487: LD_INT 56
12489: PUSH
12490: EMPTY
12491: LIST
12492: PUSH
12493: LD_INT 91
12495: PUSH
12496: LD_VAR 0 1
12500: PUSH
12501: LD_INT 25
12503: PUSH
12504: LD_INT 30
12506: PUSH
12507: LD_INT 35
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: LIST
12514: PUSH
12515: LD_OWVAR 67
12519: ARRAY
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 2
12528: PUSH
12529: LD_INT 25
12531: PUSH
12532: LD_INT 1
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 2
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 3
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 25
12561: PUSH
12562: LD_INT 4
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 25
12571: PUSH
12572: LD_INT 5
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 8
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: LIST
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: PPUSH
12605: CALL_OW 69
12609: ST_TO_ADDR
// if not tmp then
12610: LD_VAR 0 3
12614: NOT
12615: IFFALSE 12619
// continue ;
12617: GO 12452
// if Prob ( 30 * Difficulty ) then
12619: LD_INT 30
12621: PUSH
12622: LD_OWVAR 67
12626: MUL
12627: PPUSH
12628: CALL_OW 13
12632: IFFALSE 12657
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12634: LD_VAR 0 3
12638: PUSH
12639: LD_INT 1
12641: PPUSH
12642: LD_VAR 0 3
12646: PPUSH
12647: CALL_OW 12
12651: ARRAY
12652: PPUSH
12653: CALL 30114 0 1
// end ; if IsDead ( i ) then
12657: LD_VAR 0 1
12661: PPUSH
12662: CALL_OW 301
12666: IFFALSE 12686
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12668: LD_ADDR_EXP 88
12672: PUSH
12673: LD_EXP 88
12677: PUSH
12678: LD_VAR 0 1
12682: DIFF
12683: ST_TO_ADDR
// continue ;
12684: GO 12452
// end ; end ;
12686: GO 12452
12688: POP
12689: POP
// until allianceDestroyed or not allianceSpecialForce ;
12690: LD_EXP 23
12694: PUSH
12695: LD_EXP 88
12699: NOT
12700: OR
12701: IFFALSE 12435
// end ;
12703: PPOPN 3
12705: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12706: LD_EXP 23
12710: NOT
12711: PUSH
12712: LD_EXP 31
12716: AND
12717: PUSH
12718: LD_INT 1
12720: PPUSH
12721: LD_INT 1
12723: PPUSH
12724: CALL 58816 0 2
12728: NOT
12729: AND
12730: IFFALSE 13697
12732: GO 12734
12734: DISABLE
12735: LD_INT 0
12737: PPUSH
12738: PPUSH
12739: PPUSH
12740: PPUSH
// begin enable ;
12741: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12742: LD_INT 22
12744: PUSH
12745: LD_INT 7
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: LD_INT 30
12754: PUSH
12755: LD_INT 3
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PPUSH
12766: CALL_OW 69
12770: NOT
12771: IFFALSE 12775
// exit ;
12773: GO 13697
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12775: LD_ADDR_VAR 0 4
12779: PUSH
12780: LD_INT 22
12782: PUSH
12783: LD_INT 7
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 30
12792: PUSH
12793: LD_INT 34
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PPUSH
12804: CALL_OW 69
12808: ST_TO_ADDR
// if Prob ( 40 ) then
12809: LD_INT 40
12811: PPUSH
12812: CALL_OW 13
12816: IFFALSE 12943
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12818: LD_INT 1
12820: PPUSH
12821: LD_INT 5
12823: PUSH
12824: LD_INT 3
12826: PUSH
12827: LD_INT 2
12829: PUSH
12830: LD_INT 6
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: PUSH
12839: LD_INT 5
12841: PUSH
12842: LD_INT 3
12844: PUSH
12845: LD_INT 2
12847: PUSH
12848: LD_INT 6
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: LIST
12855: LIST
12856: PUSH
12857: LD_INT 5
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 2
12865: PUSH
12866: LD_INT 6
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 24
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: LD_INT 45
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PUSH
12893: LD_INT 24
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: LD_INT 3
12901: PUSH
12902: LD_INT 47
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: PUSH
12911: LD_INT 24
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 3
12919: PUSH
12920: LD_INT 45
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: PPUSH
12937: CALL 57398 0 2
// end else
12941: GO 13066
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 24
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: LD_INT 3
12954: PUSH
12955: LD_INT 47
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 24
12966: PUSH
12967: LD_INT 3
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 47
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 5
12984: PUSH
12985: LD_INT 3
12987: PUSH
12988: LD_INT 2
12990: PUSH
12991: LD_INT 9
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: PUSH
13000: LD_INT 5
13002: PUSH
13003: LD_INT 3
13005: PUSH
13006: LD_INT 2
13008: PUSH
13009: LD_INT 9
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: PUSH
13018: LD_INT 24
13020: PUSH
13021: LD_INT 1
13023: PUSH
13024: LD_INT 3
13026: PUSH
13027: LD_INT 45
13029: PUSH
13030: EMPTY
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: PUSH
13036: LD_INT 24
13038: PUSH
13039: LD_INT 1
13041: PUSH
13042: LD_INT 3
13044: PUSH
13045: LD_INT 45
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: PPUSH
13062: CALL 57398 0 2
// end ; if Difficulty > 1 then
13066: LD_OWVAR 67
13070: PUSH
13071: LD_INT 1
13073: GREATER
13074: IFFALSE 13104
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13076: LD_INT 1
13078: PPUSH
13079: LD_INT 24
13081: PUSH
13082: LD_INT 3
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: LD_INT 47
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: PUSH
13097: EMPTY
13098: LIST
13099: PPUSH
13100: CALL 57398 0 2
// repeat wait ( 0 0$1 ) ;
13104: LD_INT 35
13106: PPUSH
13107: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13111: LD_INT 1
13113: PPUSH
13114: LD_INT 1
13116: PPUSH
13117: CALL 58816 0 2
13121: PUSH
13122: LD_INT 6
13124: PUSH
13125: LD_INT 7
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_OWVAR 67
13140: ARRAY
13141: GREATEREQUAL
13142: IFFALSE 13104
// wait ( 0 0$40 ) ;
13144: LD_INT 1400
13146: PPUSH
13147: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13151: LD_ADDR_VAR 0 2
13155: PUSH
13156: LD_INT 1
13158: PPUSH
13159: LD_INT 1
13161: PPUSH
13162: CALL 58816 0 2
13166: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13167: LD_ADDR_EXP 118
13171: PUSH
13172: LD_EXP 118
13176: PPUSH
13177: LD_INT 1
13179: PPUSH
13180: LD_EXP 118
13184: PUSH
13185: LD_INT 1
13187: ARRAY
13188: PUSH
13189: LD_VAR 0 2
13193: DIFF
13194: PPUSH
13195: CALL_OW 1
13199: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13200: LD_ADDR_VAR 0 3
13204: PUSH
13205: LD_INT 0
13207: PPUSH
13208: LD_INT 1
13210: PPUSH
13211: CALL_OW 12
13215: ST_TO_ADDR
// if target then
13216: LD_VAR 0 3
13220: IFFALSE 13386
// begin for i in tmp do
13222: LD_ADDR_VAR 0 1
13226: PUSH
13227: LD_VAR 0 2
13231: PUSH
13232: FOR_IN
13233: IFFALSE 13258
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13235: LD_VAR 0 1
13239: PPUSH
13240: LD_INT 179
13242: PPUSH
13243: LD_INT 209
13245: PPUSH
13246: LD_INT 8
13248: PPUSH
13249: LD_INT 1
13251: PPUSH
13252: CALL_OW 483
13256: GO 13232
13258: POP
13259: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13260: LD_ADDR_VAR 0 2
13264: PUSH
13265: LD_VAR 0 2
13269: PPUSH
13270: LD_INT 24
13272: PUSH
13273: LD_INT 250
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: PPUSH
13280: CALL_OW 72
13284: ST_TO_ADDR
// for i in tmp do
13285: LD_ADDR_VAR 0 1
13289: PUSH
13290: LD_VAR 0 2
13294: PUSH
13295: FOR_IN
13296: IFFALSE 13336
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13298: LD_VAR 0 1
13302: PPUSH
13303: LD_INT 179
13305: PPUSH
13306: LD_INT 209
13308: PPUSH
13309: CALL_OW 297
13313: PUSH
13314: LD_INT 9
13316: GREATER
13317: IFFALSE 13334
// ComMoveXY ( i , 179 , 209 ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: LD_INT 179
13326: PPUSH
13327: LD_INT 209
13329: PPUSH
13330: CALL_OW 111
13334: GO 13295
13336: POP
13337: POP
// wait ( 0 0$1 ) ;
13338: LD_INT 35
13340: PPUSH
13341: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13345: LD_VAR 0 2
13349: PPUSH
13350: LD_INT 92
13352: PUSH
13353: LD_INT 179
13355: PUSH
13356: LD_INT 209
13358: PUSH
13359: LD_INT 9
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: PPUSH
13368: CALL_OW 72
13372: PUSH
13373: LD_VAR 0 2
13377: PUSH
13378: LD_INT 1
13380: MINUS
13381: GREATEREQUAL
13382: IFFALSE 13260
// end else
13384: GO 13548
// begin for i in tmp do
13386: LD_ADDR_VAR 0 1
13390: PUSH
13391: LD_VAR 0 2
13395: PUSH
13396: FOR_IN
13397: IFFALSE 13422
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13399: LD_VAR 0 1
13403: PPUSH
13404: LD_INT 285
13406: PPUSH
13407: LD_INT 163
13409: PPUSH
13410: LD_INT 8
13412: PPUSH
13413: LD_INT 1
13415: PPUSH
13416: CALL_OW 483
13420: GO 13396
13422: POP
13423: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13424: LD_ADDR_VAR 0 2
13428: PUSH
13429: LD_VAR 0 2
13433: PPUSH
13434: LD_INT 24
13436: PUSH
13437: LD_INT 250
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PPUSH
13444: CALL_OW 72
13448: ST_TO_ADDR
// for i in tmp do
13449: LD_ADDR_VAR 0 1
13453: PUSH
13454: LD_VAR 0 2
13458: PUSH
13459: FOR_IN
13460: IFFALSE 13500
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13462: LD_VAR 0 1
13466: PPUSH
13467: LD_INT 285
13469: PPUSH
13470: LD_INT 163
13472: PPUSH
13473: CALL_OW 297
13477: PUSH
13478: LD_INT 9
13480: GREATER
13481: IFFALSE 13498
// ComMoveXY ( i , 285 , 163 ) ;
13483: LD_VAR 0 1
13487: PPUSH
13488: LD_INT 285
13490: PPUSH
13491: LD_INT 163
13493: PPUSH
13494: CALL_OW 111
13498: GO 13459
13500: POP
13501: POP
// wait ( 0 0$1 ) ;
13502: LD_INT 35
13504: PPUSH
13505: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13509: LD_VAR 0 2
13513: PPUSH
13514: LD_INT 92
13516: PUSH
13517: LD_INT 285
13519: PUSH
13520: LD_INT 163
13522: PUSH
13523: LD_INT 9
13525: PUSH
13526: EMPTY
13527: LIST
13528: LIST
13529: LIST
13530: LIST
13531: PPUSH
13532: CALL_OW 72
13536: PUSH
13537: LD_VAR 0 2
13541: PUSH
13542: LD_INT 1
13544: MINUS
13545: GREATEREQUAL
13546: IFFALSE 13424
// end ; repeat wait ( 0 0$1 ) ;
13548: LD_INT 35
13550: PPUSH
13551: CALL_OW 67
// for i in tmp do
13555: LD_ADDR_VAR 0 1
13559: PUSH
13560: LD_VAR 0 2
13564: PUSH
13565: FOR_IN
13566: IFFALSE 13688
// if GetLives ( i ) > 251 then
13568: LD_VAR 0 1
13572: PPUSH
13573: CALL_OW 256
13577: PUSH
13578: LD_INT 251
13580: GREATER
13581: IFFALSE 13670
// begin if GetWeapon ( i ) = ru_time_lapser then
13583: LD_VAR 0 1
13587: PPUSH
13588: CALL_OW 264
13592: PUSH
13593: LD_INT 49
13595: EQUAL
13596: IFFALSE 13634
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13598: LD_VAR 0 1
13602: PPUSH
13603: LD_INT 81
13605: PUSH
13606: LD_INT 7
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PPUSH
13613: CALL_OW 69
13617: PPUSH
13618: LD_VAR 0 1
13622: PPUSH
13623: CALL_OW 74
13627: PPUSH
13628: CALL_OW 112
13632: GO 13668
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13634: LD_VAR 0 1
13638: PPUSH
13639: LD_INT 81
13641: PUSH
13642: LD_INT 7
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 69
13653: PPUSH
13654: LD_VAR 0 1
13658: PPUSH
13659: CALL_OW 74
13663: PPUSH
13664: CALL_OW 115
// end else
13668: GO 13686
// tmp := tmp diff i ;
13670: LD_ADDR_VAR 0 2
13674: PUSH
13675: LD_VAR 0 2
13679: PUSH
13680: LD_VAR 0 1
13684: DIFF
13685: ST_TO_ADDR
13686: GO 13565
13688: POP
13689: POP
// until not tmp ;
13690: LD_VAR 0 2
13694: NOT
13695: IFFALSE 13548
// end ; end_of_file
13697: PPOPN 4
13699: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13700: LD_INT 0
13702: PPUSH
13703: PPUSH
13704: PPUSH
13705: PPUSH
// missionStage := 13 ;
13706: LD_ADDR_EXP 15
13710: PUSH
13711: LD_INT 13
13713: ST_TO_ADDR
// uc_side := 2 ;
13714: LD_ADDR_OWVAR 20
13718: PUSH
13719: LD_INT 2
13721: ST_TO_ADDR
// uc_nation := 2 ;
13722: LD_ADDR_OWVAR 21
13726: PUSH
13727: LD_INT 2
13729: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13730: LD_ADDR_EXP 89
13734: PUSH
13735: LD_STRING Omar
13737: PPUSH
13738: CALL_OW 25
13742: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13743: LD_EXP 89
13747: PPUSH
13748: LD_INT 4
13750: PPUSH
13751: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13755: LD_EXP 89
13759: PPUSH
13760: LD_INT 242
13762: PPUSH
13763: LD_INT 75
13765: PPUSH
13766: LD_INT 0
13768: PPUSH
13769: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13773: LD_ADDR_EXP 90
13777: PUSH
13778: LD_STRING Heike
13780: PPUSH
13781: CALL_OW 25
13785: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13786: LD_INT 14
13788: PPUSH
13789: LD_INT 3
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: LD_INT 27
13797: PPUSH
13798: LD_INT 100
13800: PPUSH
13801: CALL 70385 0 5
// veh := CreateVehicle ;
13805: LD_ADDR_VAR 0 3
13809: PUSH
13810: CALL_OW 45
13814: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13815: LD_VAR 0 3
13819: PPUSH
13820: LD_INT 1
13822: PPUSH
13823: CALL_OW 242
// SetDir ( veh , 4 ) ;
13827: LD_VAR 0 3
13831: PPUSH
13832: LD_INT 4
13834: PPUSH
13835: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13839: LD_VAR 0 3
13843: PPUSH
13844: LD_INT 241
13846: PPUSH
13847: LD_INT 72
13849: PPUSH
13850: LD_INT 0
13852: PPUSH
13853: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13857: LD_EXP 90
13861: PPUSH
13862: LD_VAR 0 3
13866: PPUSH
13867: CALL_OW 52
// if KhatamStatus then
13871: LD_EXP 8
13875: IFFALSE 13926
// begin Khatam := NewCharacter ( Khatam ) ;
13877: LD_ADDR_EXP 91
13881: PUSH
13882: LD_STRING Khatam
13884: PPUSH
13885: CALL_OW 25
13889: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13890: LD_EXP 91
13894: PPUSH
13895: LD_INT 245
13897: PPUSH
13898: LD_INT 78
13900: PPUSH
13901: LD_INT 3
13903: PPUSH
13904: LD_INT 0
13906: PPUSH
13907: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13911: LD_EXP 91
13915: PPUSH
13916: LD_INT 4
13918: PPUSH
13919: LD_INT 10
13921: PPUSH
13922: CALL_OW 237
// end ; for i = 1 to Difficulty do
13926: LD_ADDR_VAR 0 2
13930: PUSH
13931: DOUBLE
13932: LD_INT 1
13934: DEC
13935: ST_TO_ADDR
13936: LD_OWVAR 67
13940: PUSH
13941: FOR_TO
13942: IFFALSE 14008
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13944: LD_INT 0
13946: PPUSH
13947: LD_INT 7
13949: PUSH
13950: LD_OWVAR 67
13954: PLUS
13955: PPUSH
13956: CALL_OW 384
// un := CreateHuman ;
13960: LD_ADDR_VAR 0 4
13964: PUSH
13965: CALL_OW 44
13969: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13970: LD_VAR 0 4
13974: PPUSH
13975: LD_INT 28
13977: PUSH
13978: LD_INT 29
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: PUSH
13985: LD_VAR 0 2
13989: PUSH
13990: LD_INT 2
13992: MOD
13993: PUSH
13994: LD_INT 1
13996: PLUS
13997: ARRAY
13998: PPUSH
13999: LD_INT 0
14001: PPUSH
14002: CALL_OW 49
// end ;
14006: GO 13941
14008: POP
14009: POP
// for i = 1 to 6 do
14010: LD_ADDR_VAR 0 2
14014: PUSH
14015: DOUBLE
14016: LD_INT 1
14018: DEC
14019: ST_TO_ADDR
14020: LD_INT 6
14022: PUSH
14023: FOR_TO
14024: IFFALSE 14069
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14026: LD_INT 0
14028: PPUSH
14029: LD_INT 7
14031: PUSH
14032: LD_OWVAR 67
14036: PLUS
14037: PPUSH
14038: CALL_OW 381
// un := CreateHuman ;
14042: LD_ADDR_VAR 0 4
14046: PUSH
14047: CALL_OW 44
14051: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14052: LD_VAR 0 4
14056: PPUSH
14057: LD_INT 28
14059: PPUSH
14060: LD_INT 0
14062: PPUSH
14063: CALL_OW 49
// end ;
14067: GO 14023
14069: POP
14070: POP
// for i = 1 to 3 do
14071: LD_ADDR_VAR 0 2
14075: PUSH
14076: DOUBLE
14077: LD_INT 1
14079: DEC
14080: ST_TO_ADDR
14081: LD_INT 3
14083: PUSH
14084: FOR_TO
14085: IFFALSE 14133
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14087: LD_INT 0
14089: PPUSH
14090: LD_INT 8
14092: PPUSH
14093: LD_INT 7
14095: PUSH
14096: LD_OWVAR 67
14100: PLUS
14101: PPUSH
14102: CALL_OW 380
// un := CreateHuman ;
14106: LD_ADDR_VAR 0 4
14110: PUSH
14111: CALL_OW 44
14115: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14116: LD_VAR 0 4
14120: PPUSH
14121: LD_INT 28
14123: PPUSH
14124: LD_INT 0
14126: PPUSH
14127: CALL_OW 49
// end ;
14131: GO 14084
14133: POP
14134: POP
// for i = 1 to 3 do
14135: LD_ADDR_VAR 0 2
14139: PUSH
14140: DOUBLE
14141: LD_INT 1
14143: DEC
14144: ST_TO_ADDR
14145: LD_INT 3
14147: PUSH
14148: FOR_TO
14149: IFFALSE 14239
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14151: LD_INT 14
14153: PPUSH
14154: LD_INT 2
14156: PPUSH
14157: LD_INT 1
14159: PPUSH
14160: LD_INT 28
14162: PPUSH
14163: LD_INT 80
14165: PPUSH
14166: CALL 70385 0 5
// veh := CreateVehicle ;
14170: LD_ADDR_VAR 0 3
14174: PUSH
14175: CALL_OW 45
14179: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14180: LD_VAR 0 3
14184: PPUSH
14185: LD_INT 3
14187: PPUSH
14188: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14192: LD_VAR 0 3
14196: PPUSH
14197: LD_INT 29
14199: PPUSH
14200: LD_INT 0
14202: PPUSH
14203: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14207: LD_INT 0
14209: PPUSH
14210: LD_INT 7
14212: PUSH
14213: LD_OWVAR 67
14217: PLUS
14218: PPUSH
14219: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14223: CALL_OW 44
14227: PPUSH
14228: LD_VAR 0 3
14232: PPUSH
14233: CALL_OW 52
// end ;
14237: GO 14148
14239: POP
14240: POP
// for i = 1 to 5 + Difficulty do
14241: LD_ADDR_VAR 0 2
14245: PUSH
14246: DOUBLE
14247: LD_INT 1
14249: DEC
14250: ST_TO_ADDR
14251: LD_INT 5
14253: PUSH
14254: LD_OWVAR 67
14258: PLUS
14259: PUSH
14260: FOR_TO
14261: IFFALSE 14388
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14263: LD_INT 14
14265: PPUSH
14266: LD_INT 1
14268: PPUSH
14269: LD_INT 3
14271: PPUSH
14272: CALL_OW 12
14276: PPUSH
14277: LD_INT 1
14279: PPUSH
14280: LD_INT 28
14282: PUSH
14283: LD_INT 26
14285: PUSH
14286: LD_INT 27
14288: PUSH
14289: LD_INT 25
14291: PUSH
14292: EMPTY
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: PUSH
14298: LD_VAR 0 2
14302: PUSH
14303: LD_INT 4
14305: MOD
14306: PUSH
14307: LD_INT 1
14309: PLUS
14310: ARRAY
14311: PPUSH
14312: LD_INT 80
14314: PPUSH
14315: CALL 70385 0 5
// veh := CreateVehicle ;
14319: LD_ADDR_VAR 0 3
14323: PUSH
14324: CALL_OW 45
14328: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14329: LD_VAR 0 3
14333: PPUSH
14334: LD_INT 4
14336: PPUSH
14337: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14341: LD_VAR 0 3
14345: PPUSH
14346: LD_INT 28
14348: PPUSH
14349: LD_INT 0
14351: PPUSH
14352: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14356: LD_INT 0
14358: PPUSH
14359: LD_INT 7
14361: PUSH
14362: LD_OWVAR 67
14366: PLUS
14367: PPUSH
14368: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14372: CALL_OW 44
14376: PPUSH
14377: LD_VAR 0 3
14381: PPUSH
14382: CALL_OW 52
// end ;
14386: GO 14260
14388: POP
14389: POP
// for i = 1 to 3 do
14390: LD_ADDR_VAR 0 2
14394: PUSH
14395: DOUBLE
14396: LD_INT 1
14398: DEC
14399: ST_TO_ADDR
14400: LD_INT 3
14402: PUSH
14403: FOR_TO
14404: IFFALSE 14464
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14406: LD_INT 14
14408: PPUSH
14409: LD_INT 3
14411: PPUSH
14412: LD_INT 5
14414: PPUSH
14415: LD_INT 29
14417: PPUSH
14418: LD_INT 80
14420: PPUSH
14421: CALL 70385 0 5
// veh := CreateVehicle ;
14425: LD_ADDR_VAR 0 3
14429: PUSH
14430: CALL_OW 45
14434: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14435: LD_VAR 0 3
14439: PPUSH
14440: LD_INT 4
14442: PPUSH
14443: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14447: LD_VAR 0 3
14451: PPUSH
14452: LD_INT 28
14454: PPUSH
14455: LD_INT 0
14457: PPUSH
14458: CALL_OW 49
// end ;
14462: GO 14403
14464: POP
14465: POP
// end ;
14466: LD_VAR 0 1
14470: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14471: LD_INT 22
14473: PUSH
14474: LD_INT 2
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PPUSH
14481: CALL_OW 69
14485: IFFALSE 14785
14487: GO 14489
14489: DISABLE
14490: LD_INT 0
14492: PPUSH
14493: PPUSH
14494: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14495: LD_ADDR_VAR 0 3
14499: PUSH
14500: LD_INT 22
14502: PUSH
14503: LD_INT 2
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PUSH
14510: LD_INT 25
14512: PUSH
14513: LD_INT 4
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: PPUSH
14524: CALL_OW 69
14528: PUSH
14529: LD_EXP 91
14533: DIFF
14534: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14535: LD_ADDR_VAR 0 2
14539: PUSH
14540: LD_INT 22
14542: PUSH
14543: LD_INT 2
14545: PUSH
14546: EMPTY
14547: LIST
14548: LIST
14549: PPUSH
14550: CALL_OW 69
14554: PUSH
14555: LD_EXP 91
14559: PUSH
14560: LD_VAR 0 3
14564: UNION
14565: DIFF
14566: ST_TO_ADDR
// if Khatam then
14567: LD_EXP 91
14571: IFFALSE 14588
// ComMoveXY ( Khatam , 211 , 92 ) ;
14573: LD_EXP 91
14577: PPUSH
14578: LD_INT 211
14580: PPUSH
14581: LD_INT 92
14583: PPUSH
14584: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14588: LD_INT 197
14590: PPUSH
14591: LD_INT 80
14593: PPUSH
14594: LD_INT 2
14596: PPUSH
14597: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14601: LD_INT 213
14603: PPUSH
14604: LD_INT 90
14606: PPUSH
14607: LD_INT 2
14609: PPUSH
14610: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14614: LD_INT 215
14616: PPUSH
14617: LD_INT 129
14619: PPUSH
14620: LD_INT 2
14622: PPUSH
14623: CALL_OW 441
// if sci then
14627: LD_VAR 0 3
14631: IFFALSE 14652
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14633: LD_VAR 0 3
14637: PUSH
14638: LD_INT 1
14640: ARRAY
14641: PPUSH
14642: LD_INT 197
14644: PPUSH
14645: LD_INT 80
14647: PPUSH
14648: CALL_OW 158
// if sci > 1 then
14652: LD_VAR 0 3
14656: PUSH
14657: LD_INT 1
14659: GREATER
14660: IFFALSE 14681
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14662: LD_VAR 0 3
14666: PUSH
14667: LD_INT 2
14669: ARRAY
14670: PPUSH
14671: LD_INT 213
14673: PPUSH
14674: LD_INT 90
14676: PPUSH
14677: CALL_OW 158
// if sci > 2 then
14681: LD_VAR 0 3
14685: PUSH
14686: LD_INT 2
14688: GREATER
14689: IFFALSE 14710
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14691: LD_VAR 0 3
14695: PUSH
14696: LD_INT 3
14698: ARRAY
14699: PPUSH
14700: LD_INT 215
14702: PPUSH
14703: LD_INT 129
14705: PPUSH
14706: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14710: LD_INT 35
14712: PPUSH
14713: CALL_OW 67
// for i in tmp do
14717: LD_ADDR_VAR 0 1
14721: PUSH
14722: LD_VAR 0 2
14726: PUSH
14727: FOR_IN
14728: IFFALSE 14766
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14730: LD_VAR 0 1
14734: PPUSH
14735: LD_INT 81
14737: PUSH
14738: LD_INT 2
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: PPUSH
14745: CALL_OW 69
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: PPUSH
14760: CALL_OW 115
14764: GO 14727
14766: POP
14767: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14768: LD_INT 22
14770: PUSH
14771: LD_INT 2
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: PPUSH
14778: CALL_OW 69
14782: NOT
14783: IFFALSE 14710
// end ; end_of_file
14785: PPOPN 3
14787: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14788: LD_INT 0
14790: PPUSH
14791: PPUSH
14792: PPUSH
14793: PPUSH
14794: PPUSH
14795: PPUSH
14796: PPUSH
14797: PPUSH
14798: PPUSH
// Video ( true ) ;
14799: LD_INT 1
14801: PPUSH
14802: CALL 106102 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14806: LD_ADDR_VAR 0 5
14810: PUSH
14811: LD_INT 7
14813: PPUSH
14814: LD_INT 0
14816: PPUSH
14817: CALL_OW 517
14821: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14822: LD_ADDR_VAR 0 2
14826: PUSH
14827: DOUBLE
14828: LD_INT 1
14830: DEC
14831: ST_TO_ADDR
14832: LD_VAR 0 5
14836: PUSH
14837: LD_INT 1
14839: ARRAY
14840: PUSH
14841: FOR_TO
14842: IFFALSE 14887
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14844: LD_VAR 0 5
14848: PUSH
14849: LD_INT 1
14851: ARRAY
14852: PUSH
14853: LD_VAR 0 2
14857: ARRAY
14858: PPUSH
14859: LD_VAR 0 5
14863: PUSH
14864: LD_INT 2
14866: ARRAY
14867: PUSH
14868: LD_VAR 0 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 1
14876: PPUSH
14877: LD_INT 15
14879: NEG
14880: PPUSH
14881: CALL 106016 0 4
14885: GO 14841
14887: POP
14888: POP
// CenterNowOnUnits ( Powell ) ;
14889: LD_EXP 55
14893: PPUSH
14894: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14898: LD_ADDR_VAR 0 5
14902: PUSH
14903: LD_EXP 53
14907: PUSH
14908: EMPTY
14909: LIST
14910: ST_TO_ADDR
// if GirlNewVeh then
14911: LD_EXP 54
14915: IFFALSE 14933
// tmp := tmp ^ GirlNewVeh ;
14917: LD_ADDR_VAR 0 5
14921: PUSH
14922: LD_VAR 0 5
14926: PUSH
14927: LD_EXP 54
14931: ADD
14932: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14933: LD_VAR 0 5
14937: PPUSH
14938: LD_INT 60
14940: PPUSH
14941: LD_INT 109
14943: PPUSH
14944: CALL_OW 111
// if KappaStatus then
14948: LD_EXP 2
14952: IFFALSE 15004
// begin Say ( JMM , D1nT-JMM-1 ) ;
14954: LD_EXP 36
14958: PPUSH
14959: LD_STRING D1nT-JMM-1
14961: PPUSH
14962: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14966: LD_EXP 55
14970: PPUSH
14971: LD_STRING D1T-Pow-1
14973: PPUSH
14974: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14978: LD_EXP 36
14982: PPUSH
14983: LD_STRING D1T-JMM-2
14985: PPUSH
14986: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14990: LD_EXP 55
14994: PPUSH
14995: LD_STRING D1T-Pow-2
14997: PPUSH
14998: CALL_OW 88
// end else
15002: GO 15210
// if JMMGirlStatus then
15004: LD_EXP 6
15008: IFFALSE 15153
// begin Say ( JMM , D1T-JMM-1 ) ;
15010: LD_EXP 36
15014: PPUSH
15015: LD_STRING D1T-JMM-1
15017: PPUSH
15018: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15022: LD_EXP 55
15026: PPUSH
15027: LD_STRING D1T-Pow-1
15029: PPUSH
15030: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15034: LD_EXP 36
15038: PPUSH
15039: LD_STRING D1T-JMM-3
15041: PPUSH
15042: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15046: LD_EXP 55
15050: PPUSH
15051: LD_STRING D1T-Pow-3
15053: PPUSH
15054: CALL_OW 88
// if JMMGirl then
15058: LD_EXP 7
15062: IFFALSE 15151
// begin case JMMGirl of 1 :
15064: LD_EXP 7
15068: PUSH
15069: LD_INT 1
15071: DOUBLE
15072: EQUAL
15073: IFTRUE 15077
15075: GO 15092
15077: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15078: LD_EXP 37
15082: PPUSH
15083: LD_STRING D1T-Joan-3
15085: PPUSH
15086: CALL_OW 88
15090: GO 15139
15092: LD_INT 2
15094: DOUBLE
15095: EQUAL
15096: IFTRUE 15100
15098: GO 15115
15100: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15101: LD_EXP 39
15105: PPUSH
15106: LD_STRING D1T-Lisa-3
15108: PPUSH
15109: CALL_OW 88
15113: GO 15139
15115: LD_INT 3
15117: DOUBLE
15118: EQUAL
15119: IFTRUE 15123
15121: GO 15138
15123: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15124: LD_EXP 51
15128: PPUSH
15129: LD_STRING D1T-Con-3
15131: PPUSH
15132: CALL_OW 88
15136: GO 15139
15138: POP
// Say ( Powell , D1T-Pow-4 ) ;
15139: LD_EXP 55
15143: PPUSH
15144: LD_STRING D1T-Pow-4
15146: PPUSH
15147: CALL_OW 88
// end ; end else
15151: GO 15210
// if not FastEnd then
15153: LD_EXP 11
15157: NOT
15158: IFFALSE 15186
// begin Say ( JMM , D1T-JMM-4 ) ;
15160: LD_EXP 36
15164: PPUSH
15165: LD_STRING D1T-JMM-4
15167: PPUSH
15168: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15172: LD_EXP 55
15176: PPUSH
15177: LD_STRING D1T-Pow-5
15179: PPUSH
15180: CALL_OW 88
// end else
15184: GO 15210
// begin Say ( JMM , D1nT-JMM-1 ) ;
15186: LD_EXP 36
15190: PPUSH
15191: LD_STRING D1nT-JMM-1
15193: PPUSH
15194: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15198: LD_EXP 55
15202: PPUSH
15203: LD_STRING D1nT-Pow-1
15205: PPUSH
15206: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15210: LD_INT 35
15212: PPUSH
15213: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15217: LD_EXP 53
15221: PPUSH
15222: CALL_OW 314
15226: NOT
15227: IFFALSE 15210
// ComExitVehicle ( JMM ) ;
15229: LD_EXP 36
15233: PPUSH
15234: CALL_OW 121
// wait ( 3 ) ;
15238: LD_INT 3
15240: PPUSH
15241: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15245: LD_EXP 36
15249: PPUSH
15250: LD_INT 60
15252: PPUSH
15253: LD_INT 94
15255: PPUSH
15256: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15260: LD_EXP 36
15264: PPUSH
15265: LD_EXP 55
15269: PPUSH
15270: CALL_OW 179
// if Joan then
15274: LD_EXP 37
15278: IFFALSE 15332
// begin ComExitVehicle ( Joan ) ;
15280: LD_EXP 37
15284: PPUSH
15285: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15289: LD_EXP 37
15293: PPUSH
15294: LD_INT 35
15296: PPUSH
15297: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15301: LD_EXP 37
15305: PPUSH
15306: LD_INT 65
15308: PPUSH
15309: LD_INT 104
15311: PPUSH
15312: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15316: LD_EXP 37
15320: PPUSH
15321: LD_EXP 36
15325: PPUSH
15326: CALL_OW 179
// end else
15330: GO 15466
// if Lisa and JMMGirl = 2 then
15332: LD_EXP 39
15336: PUSH
15337: LD_EXP 7
15341: PUSH
15342: LD_INT 2
15344: EQUAL
15345: AND
15346: IFFALSE 15400
// begin ComExitVehicle ( Lisa ) ;
15348: LD_EXP 39
15352: PPUSH
15353: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15357: LD_EXP 39
15361: PPUSH
15362: LD_INT 35
15364: PPUSH
15365: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15369: LD_EXP 39
15373: PPUSH
15374: LD_INT 65
15376: PPUSH
15377: LD_INT 104
15379: PPUSH
15380: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15384: LD_EXP 39
15388: PPUSH
15389: LD_EXP 36
15393: PPUSH
15394: CALL_OW 179
// end else
15398: GO 15466
// if Connie and JMMGirl = 3 then
15400: LD_EXP 51
15404: PUSH
15405: LD_EXP 7
15409: PUSH
15410: LD_INT 3
15412: EQUAL
15413: AND
15414: IFFALSE 15466
// begin ComExitVehicle ( Connie ) ;
15416: LD_EXP 51
15420: PPUSH
15421: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15425: LD_EXP 51
15429: PPUSH
15430: LD_INT 35
15432: PPUSH
15433: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15437: LD_EXP 51
15441: PPUSH
15442: LD_INT 65
15444: PPUSH
15445: LD_INT 104
15447: PPUSH
15448: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15452: LD_EXP 51
15456: PPUSH
15457: LD_EXP 36
15461: PPUSH
15462: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15466: LD_INT 35
15468: PPUSH
15469: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15473: LD_EXP 36
15477: PPUSH
15478: LD_EXP 55
15482: PPUSH
15483: CALL_OW 296
15487: PUSH
15488: LD_INT 6
15490: LESS
15491: IFFALSE 15466
// wait ( 0 0$0.5 ) ;
15493: LD_INT 18
15495: PPUSH
15496: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15500: LD_EXP 36
15504: PPUSH
15505: LD_STRING D1-JMM-1
15507: PPUSH
15508: CALL_OW 88
// async ;
15512: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15513: LD_EXP 55
15517: PPUSH
15518: LD_STRING D1-Pow-1
15520: PPUSH
15521: CALL_OW 88
// if not dialogue_skipped then
15525: LD_OWVAR 59
15529: NOT
15530: IFFALSE 15539
// wait ( 0 0$2 ) ;
15532: LD_INT 70
15534: PPUSH
15535: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15539: LD_INT 170
15541: PPUSH
15542: LD_INT 99
15544: PPUSH
15545: LD_INT 1
15547: PPUSH
15548: LD_INT 6
15550: NEG
15551: PPUSH
15552: CALL 106016 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15556: LD_INT 174
15558: PPUSH
15559: LD_INT 115
15561: PPUSH
15562: LD_INT 1
15564: PPUSH
15565: LD_INT 6
15567: NEG
15568: PPUSH
15569: CALL 106016 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15573: LD_INT 169
15575: PPUSH
15576: LD_INT 71
15578: PPUSH
15579: LD_INT 1
15581: PPUSH
15582: LD_INT 6
15584: NEG
15585: PPUSH
15586: CALL 106016 0 4
// if not dialogue_skipped then
15590: LD_OWVAR 59
15594: NOT
15595: IFFALSE 15614
// begin CenterOnXY ( 170 , 99 ) ;
15597: LD_INT 170
15599: PPUSH
15600: LD_INT 99
15602: PPUSH
15603: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15607: LD_INT 80
15609: PPUSH
15610: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15614: LD_INT 75
15616: PPUSH
15617: LD_INT 53
15619: PPUSH
15620: LD_INT 1
15622: PPUSH
15623: LD_INT 9
15625: NEG
15626: PPUSH
15627: CALL 106016 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15631: LD_INT 54
15633: PPUSH
15634: LD_INT 42
15636: PPUSH
15637: LD_INT 1
15639: PPUSH
15640: LD_INT 9
15642: NEG
15643: PPUSH
15644: CALL 106016 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15648: LD_INT 62
15650: PPUSH
15651: LD_INT 51
15653: PPUSH
15654: LD_INT 1
15656: PPUSH
15657: LD_INT 9
15659: NEG
15660: PPUSH
15661: CALL 106016 0 4
// if not dialogue_skipped then
15665: LD_OWVAR 59
15669: NOT
15670: IFFALSE 15689
// begin CenterOnXY ( 75 , 53 ) ;
15672: LD_INT 75
15674: PPUSH
15675: LD_INT 53
15677: PPUSH
15678: CALL_OW 84
// wait ( 0 0$4 ) ;
15682: LD_INT 140
15684: PPUSH
15685: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15689: LD_EXP 55
15693: PPUSH
15694: CALL_OW 87
// if not dialogue_skipped then
15698: LD_OWVAR 59
15702: NOT
15703: IFFALSE 15712
// wait ( 0 0$2 ) ;
15705: LD_INT 70
15707: PPUSH
15708: CALL_OW 67
// sync ;
15712: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15713: LD_EXP 36
15717: PPUSH
15718: LD_STRING D1-JMM-2
15720: PPUSH
15721: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15725: LD_EXP 55
15729: PPUSH
15730: LD_STRING D1-Pow-2
15732: PPUSH
15733: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15737: LD_EXP 36
15741: PPUSH
15742: LD_STRING D1-JMM-3
15744: PPUSH
15745: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15749: LD_EXP 55
15753: PPUSH
15754: LD_STRING D1-Pow-3
15756: PPUSH
15757: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15761: LD_EXP 36
15765: PPUSH
15766: LD_STRING D1-JMM-4
15768: PPUSH
15769: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15773: LD_EXP 55
15777: PPUSH
15778: LD_STRING D1-Pow-4
15780: PPUSH
15781: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15785: LD_EXP 36
15789: PPUSH
15790: LD_STRING D1-JMM-5
15792: PPUSH
15793: CALL_OW 88
// async ;
15797: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15798: LD_EXP 55
15802: PPUSH
15803: LD_STRING D1-Pow-5
15805: PPUSH
15806: CALL_OW 88
// if not dialogue_skipped then
15810: LD_OWVAR 59
15814: NOT
15815: IFFALSE 15824
// wait ( 0 0$3.6 ) ;
15817: LD_INT 126
15819: PPUSH
15820: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15824: LD_INT 134
15826: PPUSH
15827: LD_INT 210
15829: PPUSH
15830: LD_INT 1
15832: PPUSH
15833: LD_INT 11
15835: NEG
15836: PPUSH
15837: CALL 106016 0 4
// if not dialogue_skipped then
15841: LD_OWVAR 59
15845: NOT
15846: IFFALSE 15865
// begin CenterOnXY ( 134 , 210 ) ;
15848: LD_INT 134
15850: PPUSH
15851: LD_INT 210
15853: PPUSH
15854: CALL_OW 84
// wait ( 0 0$2 ) ;
15858: LD_INT 70
15860: PPUSH
15861: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15865: LD_INT 101
15867: PPUSH
15868: LD_INT 159
15870: PPUSH
15871: LD_INT 1
15873: PPUSH
15874: LD_INT 10
15876: NEG
15877: PPUSH
15878: CALL 106016 0 4
// if not dialogue_skipped then
15882: LD_OWVAR 59
15886: NOT
15887: IFFALSE 15906
// begin CenterOnXY ( 101 , 159 ) ;
15889: LD_INT 101
15891: PPUSH
15892: LD_INT 159
15894: PPUSH
15895: CALL_OW 84
// wait ( 0 0$2 ) ;
15899: LD_INT 70
15901: PPUSH
15902: CALL_OW 67
// end ; sync ;
15906: SYNC
// CenterNowOnUnits ( Powell ) ;
15907: LD_EXP 55
15911: PPUSH
15912: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15916: LD_ADDR_VAR 0 6
15920: PUSH
15921: LD_INT 1
15923: PUSH
15924: LD_INT 2
15926: PUSH
15927: LD_INT 3
15929: PUSH
15930: LD_INT 4
15932: PUSH
15933: LD_INT 5
15935: PUSH
15936: LD_INT 6
15938: PUSH
15939: EMPTY
15940: LIST
15941: LIST
15942: LIST
15943: LIST
15944: LIST
15945: LIST
15946: ST_TO_ADDR
// if not dialogue_skipped then
15947: LD_OWVAR 59
15951: NOT
15952: IFFALSE 16121
// begin game_speed := 4 ;
15954: LD_ADDR_OWVAR 65
15958: PUSH
15959: LD_INT 4
15961: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15962: LD_INT 210
15964: PPUSH
15965: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15969: LD_ADDR_VAR 0 7
15973: PUSH
15974: LD_STRING Q1
15976: PPUSH
15977: LD_VAR 0 6
15981: PPUSH
15982: CALL_OW 98
15986: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15987: LD_ADDR_VAR 0 7
15991: PUSH
15992: LD_STRING Q1
15994: PPUSH
15995: LD_VAR 0 6
15999: PPUSH
16000: CALL_OW 98
16004: ST_TO_ADDR
// options = options diff dec ;
16005: LD_ADDR_VAR 0 6
16009: PUSH
16010: LD_VAR 0 6
16014: PUSH
16015: LD_VAR 0 7
16019: DIFF
16020: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16021: LD_VAR 0 7
16025: PPUSH
16026: LD_VAR 0 6
16030: PPUSH
16031: CALL 17424 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16035: LD_VAR 0 7
16039: PUSH
16040: LD_INT 5
16042: PUSH
16043: LD_INT 6
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: IN
16050: PUSH
16051: LD_VAR 0 6
16055: PUSH
16056: LD_INT 2
16058: EQUAL
16059: OR
16060: IFFALSE 15987
// if not ( dec in [ 5 , 6 ] ) then
16062: LD_VAR 0 7
16066: PUSH
16067: LD_INT 5
16069: PUSH
16070: LD_INT 6
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: IN
16077: NOT
16078: IFFALSE 16121
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16080: LD_ADDR_VAR 0 7
16084: PUSH
16085: LD_STRING Q1a
16087: PPUSH
16088: LD_INT 1
16090: PUSH
16091: LD_INT 2
16093: PUSH
16094: EMPTY
16095: LIST
16096: LIST
16097: PPUSH
16098: CALL_OW 98
16102: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16103: LD_VAR 0 7
16107: PUSH
16108: LD_INT 4
16110: PLUS
16111: PPUSH
16112: LD_VAR 0 6
16116: PPUSH
16117: CALL 17424 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16121: LD_INT 81
16123: PPUSH
16124: LD_INT 127
16126: PPUSH
16127: CALL_OW 84
// amount := 5 ;
16131: LD_ADDR_VAR 0 8
16135: PUSH
16136: LD_INT 5
16138: ST_TO_ADDR
// macmilan_squad := [ ] ;
16139: LD_ADDR_VAR 0 9
16143: PUSH
16144: EMPTY
16145: ST_TO_ADDR
// if vip < amount then
16146: LD_EXP 56
16150: PUSH
16151: LD_VAR 0 8
16155: LESS
16156: IFFALSE 16200
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16158: LD_ADDR_VAR 0 5
16162: PUSH
16163: LD_EXP 56
16167: PUSH
16168: LD_INT 22
16170: PUSH
16171: LD_INT 4
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: PUSH
16178: LD_INT 21
16180: PUSH
16181: LD_INT 1
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: EMPTY
16189: LIST
16190: LIST
16191: PPUSH
16192: CALL_OW 69
16196: UNION
16197: ST_TO_ADDR
16198: GO 16210
// tmp := vip ;
16200: LD_ADDR_VAR 0 5
16204: PUSH
16205: LD_EXP 56
16209: ST_TO_ADDR
// tmp := tmp diff Powell ;
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_VAR 0 5
16219: PUSH
16220: LD_EXP 55
16224: DIFF
16225: ST_TO_ADDR
// if tmp < amount then
16226: LD_VAR 0 5
16230: PUSH
16231: LD_VAR 0 8
16235: LESS
16236: IFFALSE 16248
// amount := tmp ;
16238: LD_ADDR_VAR 0 8
16242: PUSH
16243: LD_VAR 0 5
16247: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16248: LD_VAR 0 5
16252: PUSH
16253: LD_INT 1
16255: ARRAY
16256: PPUSH
16257: CALL_OW 257
16261: PUSH
16262: LD_INT 2
16264: NONEQUAL
16265: IFFALSE 16327
// begin if IsInUnit ( tmp [ 1 ] ) then
16267: LD_VAR 0 5
16271: PUSH
16272: LD_INT 1
16274: ARRAY
16275: PPUSH
16276: CALL_OW 310
16280: IFFALSE 16295
// ComExitBuilding ( tmp [ 1 ] ) ;
16282: LD_VAR 0 5
16286: PUSH
16287: LD_INT 1
16289: ARRAY
16290: PPUSH
16291: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16295: LD_VAR 0 5
16299: PUSH
16300: LD_INT 1
16302: ARRAY
16303: PPUSH
16304: LD_INT 387
16306: PPUSH
16307: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16311: LD_VAR 0 5
16315: PUSH
16316: LD_INT 1
16318: ARRAY
16319: PPUSH
16320: LD_INT 2
16322: PPUSH
16323: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16327: LD_EXP 36
16331: PPUSH
16332: LD_INT 82
16334: PPUSH
16335: LD_INT 129
16337: PPUSH
16338: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16342: LD_EXP 36
16346: PPUSH
16347: LD_EXP 55
16351: PPUSH
16352: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16356: LD_INT 22
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PPUSH
16366: CALL_OW 69
16370: PUSH
16371: LD_EXP 36
16375: DIFF
16376: PPUSH
16377: LD_INT 84
16379: PPUSH
16380: LD_INT 128
16382: PPUSH
16383: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16387: LD_INT 22
16389: PUSH
16390: LD_INT 1
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PPUSH
16397: CALL_OW 69
16401: PUSH
16402: LD_EXP 36
16406: DIFF
16407: PPUSH
16408: LD_EXP 36
16412: PPUSH
16413: CALL_OW 179
// for i = 1 to amount do
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: DOUBLE
16423: LD_INT 1
16425: DEC
16426: ST_TO_ADDR
16427: LD_VAR 0 8
16431: PUSH
16432: FOR_TO
16433: IFFALSE 16601
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16435: LD_ADDR_VAR 0 9
16439: PUSH
16440: LD_VAR 0 9
16444: PUSH
16445: LD_VAR 0 5
16449: PUSH
16450: LD_VAR 0 2
16454: ARRAY
16455: ADD
16456: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16457: LD_VAR 0 5
16461: PUSH
16462: LD_VAR 0 2
16466: ARRAY
16467: PPUSH
16468: CALL_OW 310
16472: IFFALSE 16489
// AddComExitBuilding ( tmp [ i ] ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_VAR 0 2
16483: ARRAY
16484: PPUSH
16485: CALL_OW 182
// if i = 2 and JMMNewVeh then
16489: LD_VAR 0 2
16493: PUSH
16494: LD_INT 2
16496: EQUAL
16497: PUSH
16498: LD_EXP 53
16502: AND
16503: IFFALSE 16561
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16505: LD_VAR 0 5
16509: PUSH
16510: LD_VAR 0 2
16514: ARRAY
16515: PPUSH
16516: LD_EXP 53
16520: PPUSH
16521: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16525: LD_VAR 0 5
16529: PUSH
16530: LD_VAR 0 2
16534: ARRAY
16535: PPUSH
16536: LD_INT 86
16538: PPUSH
16539: LD_INT 133
16541: PPUSH
16542: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16546: LD_VAR 0 5
16550: PUSH
16551: LD_VAR 0 2
16555: ARRAY
16556: PPUSH
16557: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16561: LD_VAR 0 5
16565: PUSH
16566: LD_VAR 0 2
16570: ARRAY
16571: PPUSH
16572: LD_INT 8
16574: PPUSH
16575: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16579: LD_VAR 0 5
16583: PUSH
16584: LD_VAR 0 2
16588: ARRAY
16589: PPUSH
16590: LD_EXP 36
16594: PPUSH
16595: CALL_OW 179
// end ;
16599: GO 16432
16601: POP
16602: POP
// if GirlNewVeh then
16603: LD_EXP 54
16607: IFFALSE 16621
// SetSide ( GirlNewVeh , 4 ) ;
16609: LD_EXP 54
16613: PPUSH
16614: LD_INT 4
16616: PPUSH
16617: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16621: LD_INT 35
16623: PPUSH
16624: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16628: LD_VAR 0 9
16632: PPUSH
16633: LD_INT 95
16635: PUSH
16636: LD_INT 9
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: PPUSH
16643: CALL_OW 72
16647: PUSH
16648: LD_INT 0
16650: EQUAL
16651: PUSH
16652: LD_EXP 36
16656: PPUSH
16657: LD_INT 9
16659: PPUSH
16660: CALL_OW 308
16664: NOT
16665: AND
16666: IFFALSE 16621
// wait ( 0 0$2 ) ;
16668: LD_INT 70
16670: PPUSH
16671: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16675: LD_VAR 0 9
16679: PPUSH
16680: LD_INT 1
16682: PPUSH
16683: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16687: LD_INT 21
16689: PUSH
16690: LD_INT 2
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: PUSH
16697: LD_INT 92
16699: PUSH
16700: LD_INT 83
16702: PUSH
16703: LD_INT 130
16705: PUSH
16706: LD_INT 10
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PPUSH
16719: CALL_OW 69
16723: PPUSH
16724: LD_INT 1
16726: PPUSH
16727: CALL_OW 235
// Video ( false ) ;
16731: LD_INT 0
16733: PPUSH
16734: CALL 106102 0 1
// ChangeMissionObjectives ( M1 ) ;
16738: LD_STRING M1
16740: PPUSH
16741: CALL_OW 337
// SaveForQuickRestart ;
16745: CALL_OW 22
// missionStart := true ;
16749: LD_ADDR_EXP 13
16753: PUSH
16754: LD_INT 1
16756: ST_TO_ADDR
// missionStage := 2 ;
16757: LD_ADDR_EXP 15
16761: PUSH
16762: LD_INT 2
16764: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16765: LD_INT 105
16767: PPUSH
16768: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16772: LD_ADDR_VAR 0 5
16776: PUSH
16777: LD_INT 22
16779: PUSH
16780: LD_INT 4
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PUSH
16787: LD_INT 21
16789: PUSH
16790: LD_INT 1
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PPUSH
16801: CALL_OW 69
16805: PUSH
16806: LD_EXP 55
16810: DIFF
16811: ST_TO_ADDR
// if not tmp then
16812: LD_VAR 0 5
16816: NOT
16817: IFFALSE 16832
// tmp := [ Powell ] ;
16819: LD_ADDR_VAR 0 5
16823: PUSH
16824: LD_EXP 55
16828: PUSH
16829: EMPTY
16830: LIST
16831: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16832: LD_ADDR_EXP 99
16836: PUSH
16837: LD_EXP 99
16841: PPUSH
16842: LD_INT 4
16844: PPUSH
16845: LD_INT 22
16847: PUSH
16848: LD_INT 4
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 23
16857: PUSH
16858: LD_INT 1
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 3
16867: PUSH
16868: LD_INT 21
16870: PUSH
16871: LD_INT 2
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: LIST
16886: PPUSH
16887: CALL_OW 69
16891: PUSH
16892: LD_EXP 55
16896: DIFF
16897: PPUSH
16898: CALL_OW 1
16902: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16903: LD_ADDR_VAR 0 4
16907: PUSH
16908: LD_INT 22
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 34
16920: PUSH
16921: LD_INT 12
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PPUSH
16932: CALL_OW 69
16936: PUSH
16937: LD_INT 1
16939: ARRAY
16940: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16941: LD_VAR 0 5
16945: PUSH
16946: LD_INT 1
16948: ARRAY
16949: PPUSH
16950: CALL_OW 310
16954: IFFALSE 16969
// ComExitBuilding ( tmp [ 1 ] ) ;
16956: LD_VAR 0 5
16960: PUSH
16961: LD_INT 1
16963: ARRAY
16964: PPUSH
16965: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16969: LD_VAR 0 5
16973: PUSH
16974: LD_INT 1
16976: ARRAY
16977: PPUSH
16978: LD_VAR 0 4
16982: PPUSH
16983: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16987: LD_VAR 0 5
16991: PUSH
16992: LD_INT 1
16994: ARRAY
16995: PPUSH
16996: LD_INT 80
16998: PPUSH
16999: LD_INT 136
17001: PPUSH
17002: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17006: LD_VAR 0 5
17010: PUSH
17011: LD_INT 1
17013: ARRAY
17014: PPUSH
17015: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17019: LD_VAR 0 5
17023: PUSH
17024: LD_INT 1
17026: ARRAY
17027: PPUSH
17028: LD_INT 59
17030: PPUSH
17031: LD_INT 112
17033: PPUSH
17034: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17038: LD_VAR 0 5
17042: PUSH
17043: LD_INT 1
17045: ARRAY
17046: PPUSH
17047: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17051: LD_EXP 39
17055: PUSH
17056: LD_EXP 56
17060: IN
17061: PUSH
17062: LD_EXP 39
17066: PPUSH
17067: CALL_OW 255
17071: PUSH
17072: LD_INT 1
17074: EQUAL
17075: AND
17076: IFFALSE 17092
// Say ( Lisa , D3nW-Lisa-1 ) else
17078: LD_EXP 39
17082: PPUSH
17083: LD_STRING D3nW-Lisa-1
17085: PPUSH
17086: CALL_OW 88
17090: GO 17336
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17092: LD_EXP 42
17096: PUSH
17097: LD_EXP 56
17101: IN
17102: PUSH
17103: LD_EXP 42
17107: PPUSH
17108: CALL_OW 255
17112: PUSH
17113: LD_INT 1
17115: EQUAL
17116: AND
17117: IFFALSE 17133
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17119: LD_EXP 42
17123: PPUSH
17124: LD_STRING D3nW-Cyrus-1
17126: PPUSH
17127: CALL_OW 88
17131: GO 17336
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17133: LD_EXP 41
17137: PUSH
17138: LD_EXP 56
17142: IN
17143: PUSH
17144: LD_EXP 41
17148: PPUSH
17149: CALL_OW 255
17153: PUSH
17154: LD_INT 1
17156: EQUAL
17157: AND
17158: IFFALSE 17174
// Say ( Bobby , D3nW-Bobby-1 ) else
17160: LD_EXP 41
17164: PPUSH
17165: LD_STRING D3nW-Bobby-1
17167: PPUSH
17168: CALL_OW 88
17172: GO 17336
// if Gary in vip and GetSide ( Gary ) = 1 then
17174: LD_EXP 48
17178: PUSH
17179: LD_EXP 56
17183: IN
17184: PUSH
17185: LD_EXP 48
17189: PPUSH
17190: CALL_OW 255
17194: PUSH
17195: LD_INT 1
17197: EQUAL
17198: AND
17199: IFFALSE 17215
// Say ( Gary , D3nW-Gary-1 ) else
17201: LD_EXP 48
17205: PPUSH
17206: LD_STRING D3nW-Gary-1
17208: PPUSH
17209: CALL_OW 88
17213: GO 17336
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17215: LD_EXP 40
17219: PUSH
17220: LD_EXP 56
17224: IN
17225: PUSH
17226: LD_EXP 40
17230: PPUSH
17231: CALL_OW 255
17235: PUSH
17236: LD_INT 1
17238: EQUAL
17239: AND
17240: IFFALSE 17256
// Say ( Donaldson , D3nW-Don-1 ) else
17242: LD_EXP 40
17246: PPUSH
17247: LD_STRING D3nW-Don-1
17249: PPUSH
17250: CALL_OW 88
17254: GO 17336
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17256: LD_EXP 47
17260: PUSH
17261: LD_EXP 56
17265: IN
17266: PUSH
17267: LD_EXP 47
17271: PPUSH
17272: CALL_OW 255
17276: PUSH
17277: LD_INT 1
17279: EQUAL
17280: AND
17281: IFFALSE 17297
// Say ( Cornel , D3nW-Corn-1 ) else
17283: LD_EXP 47
17287: PPUSH
17288: LD_STRING D3nW-Corn-1
17290: PPUSH
17291: CALL_OW 88
17295: GO 17336
// if Frank in vip and GetSide ( Frank ) = 1 then
17297: LD_EXP 49
17301: PUSH
17302: LD_EXP 56
17306: IN
17307: PUSH
17308: LD_EXP 49
17312: PPUSH
17313: CALL_OW 255
17317: PUSH
17318: LD_INT 1
17320: EQUAL
17321: AND
17322: IFFALSE 17336
// Say ( Frank , D3nW-Frank-1 ) ;
17324: LD_EXP 49
17328: PPUSH
17329: LD_STRING D3nW-Frank-1
17331: PPUSH
17332: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17336: LD_EXP 36
17340: PPUSH
17341: LD_STRING D3nW-JMM-1
17343: PPUSH
17344: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17348: LD_EXP 36
17352: PPUSH
17353: LD_STRING D3nW-JMM-1a
17355: PPUSH
17356: CALL_OW 88
// t := 0 0$00 ;
17360: LD_ADDR_VAR 0 3
17364: PUSH
17365: LD_INT 0
17367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17368: LD_INT 35
17370: PPUSH
17371: CALL_OW 67
// t := t + 0 0$1 ;
17375: LD_ADDR_VAR 0 3
17379: PUSH
17380: LD_VAR 0 3
17384: PUSH
17385: LD_INT 35
17387: PLUS
17388: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17389: LD_INT 59
17391: PPUSH
17392: LD_INT 112
17394: PPUSH
17395: CALL_OW 428
17399: PUSH
17400: LD_VAR 0 3
17404: PUSH
17405: LD_INT 2100
17407: GREATER
17408: OR
17409: IFFALSE 17368
// activeAttacks := true ;
17411: LD_ADDR_EXP 16
17415: PUSH
17416: LD_INT 1
17418: ST_TO_ADDR
// end ;
17419: LD_VAR 0 1
17423: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17424: LD_INT 0
17426: PPUSH
// case question of 1 :
17427: LD_VAR 0 1
17431: PUSH
17432: LD_INT 1
17434: DOUBLE
17435: EQUAL
17436: IFTRUE 17440
17438: GO 17491
17440: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17441: LD_EXP 36
17445: PPUSH
17446: LD_STRING D2Mot-JMM-1
17448: PPUSH
17449: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17453: LD_EXP 55
17457: PPUSH
17458: LD_STRING D2Mot-Pow-1
17460: PPUSH
17461: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17465: LD_EXP 36
17469: PPUSH
17470: LD_STRING D2Mot-JMM-2
17472: PPUSH
17473: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17477: LD_EXP 55
17481: PPUSH
17482: LD_STRING D2Mot-Pow-2
17484: PPUSH
17485: CALL_OW 88
// end ; 2 :
17489: GO 17834
17491: LD_INT 2
17493: DOUBLE
17494: EQUAL
17495: IFTRUE 17499
17497: GO 17575
17499: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17500: LD_EXP 36
17504: PPUSH
17505: LD_STRING D2Rus-JMM-1
17507: PPUSH
17508: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17512: LD_EXP 55
17516: PPUSH
17517: LD_STRING D2Rus-Pow-1
17519: PPUSH
17520: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17524: LD_EXP 36
17528: PPUSH
17529: LD_STRING D2Rus-JMM-2
17531: PPUSH
17532: CALL_OW 88
// if not ( 3 in list_of_q ) then
17536: LD_INT 3
17538: PUSH
17539: LD_VAR 0 2
17543: IN
17544: NOT
17545: IFFALSE 17561
// Say ( Powell , D2Rus-Pow-2 ) else
17547: LD_EXP 55
17551: PPUSH
17552: LD_STRING D2Rus-Pow-2
17554: PPUSH
17555: CALL_OW 88
17559: GO 17573
// Say ( Powell , D2Rus-Pow-2a ) ;
17561: LD_EXP 55
17565: PPUSH
17566: LD_STRING D2Rus-Pow-2a
17568: PPUSH
17569: CALL_OW 88
// end ; 3 :
17573: GO 17834
17575: LD_INT 3
17577: DOUBLE
17578: EQUAL
17579: IFTRUE 17583
17581: GO 17668
17583: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17584: LD_EXP 36
17588: PPUSH
17589: LD_STRING D2Leg-JMM-1
17591: PPUSH
17592: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17596: LD_EXP 55
17600: PPUSH
17601: LD_STRING D2Leg-Pow-1
17603: PPUSH
17604: CALL_OW 88
// if 2 in list_of_q then
17608: LD_INT 2
17610: PUSH
17611: LD_VAR 0 2
17615: IN
17616: IFFALSE 17642
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17618: LD_EXP 36
17622: PPUSH
17623: LD_STRING D2Leg-JMM-2
17625: PPUSH
17626: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17630: LD_EXP 55
17634: PPUSH
17635: LD_STRING D2Leg-Pow-2
17637: PPUSH
17638: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17642: LD_EXP 36
17646: PPUSH
17647: LD_STRING D2Leg-JMM-3
17649: PPUSH
17650: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17654: LD_EXP 55
17658: PPUSH
17659: LD_STRING D2Leg-Pow-3
17661: PPUSH
17662: CALL_OW 88
// end ; 4 :
17666: GO 17834
17668: LD_INT 4
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17751
17676: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17677: LD_EXP 36
17681: PPUSH
17682: LD_STRING D2Ar-JMM-1
17684: PPUSH
17685: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17689: LD_EXP 55
17693: PPUSH
17694: LD_STRING D2Ar-Pow-1
17696: PPUSH
17697: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17701: LD_EXP 36
17705: PPUSH
17706: LD_STRING D2Ar-JMM-2
17708: PPUSH
17709: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17713: LD_EXP 55
17717: PPUSH
17718: LD_STRING D2Ar-Pow-2
17720: PPUSH
17721: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17725: LD_EXP 36
17729: PPUSH
17730: LD_STRING D2Ar-JMM-3
17732: PPUSH
17733: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17737: LD_EXP 55
17741: PPUSH
17742: LD_STRING D2Ar-Pow-3
17744: PPUSH
17745: CALL_OW 88
// end ; 5 :
17749: GO 17834
17751: LD_INT 5
17753: DOUBLE
17754: EQUAL
17755: IFTRUE 17759
17757: GO 17774
17759: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17760: LD_EXP 36
17764: PPUSH
17765: LD_STRING D2Conf-JMM-1
17767: PPUSH
17768: CALL_OW 88
17772: GO 17834
17774: LD_INT 6
17776: DOUBLE
17777: EQUAL
17778: IFTRUE 17782
17780: GO 17833
17782: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17783: LD_EXP 36
17787: PPUSH
17788: LD_STRING D2Com-JMM-1
17790: PPUSH
17791: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17795: LD_EXP 55
17799: PPUSH
17800: LD_STRING D2Com-Pow-1
17802: PPUSH
17803: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17807: LD_EXP 36
17811: PPUSH
17812: LD_STRING D2Com-JMM-2
17814: PPUSH
17815: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17819: LD_EXP 55
17823: PPUSH
17824: LD_STRING D2Com-Pow-2
17826: PPUSH
17827: CALL_OW 88
// end ; end ;
17831: GO 17834
17833: POP
// end ;
17834: LD_VAR 0 3
17838: RET
// every 0 0$5 trigger missionStart do var tmp ;
17839: LD_EXP 13
17843: IFFALSE 18126
17845: GO 17847
17847: DISABLE
17848: LD_INT 0
17850: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17851: LD_INT 35
17853: PPUSH
17854: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17858: LD_INT 14
17860: PPUSH
17861: LD_INT 22
17863: PUSH
17864: LD_INT 1
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: PPUSH
17871: CALL_OW 70
17875: PUSH
17876: LD_EXP 15
17880: PUSH
17881: LD_INT 2
17883: PUSH
17884: LD_INT 3
17886: PUSH
17887: LD_INT 4
17889: PUSH
17890: LD_INT 5
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: IN
17899: AND
17900: IFFALSE 18116
// begin powellAnger := powellAnger + 1 ;
17902: LD_ADDR_EXP 17
17906: PUSH
17907: LD_EXP 17
17911: PUSH
17912: LD_INT 1
17914: PLUS
17915: ST_TO_ADDR
// Video ( true ) ;
17916: LD_INT 1
17918: PPUSH
17919: CALL 106102 0 1
// CenterNowOnUnits ( tmp ) ;
17923: LD_VAR 0 1
17927: PPUSH
17928: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17932: LD_INT 14
17934: PPUSH
17935: LD_INT 22
17937: PUSH
17938: LD_INT 1
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: PPUSH
17945: CALL_OW 70
17949: PPUSH
17950: LD_INT 86
17952: PPUSH
17953: LD_INT 133
17955: PPUSH
17956: CALL_OW 111
// async ;
17960: ASYNC
// case powellAnger of 1 :
17961: LD_EXP 17
17965: PUSH
17966: LD_INT 1
17968: DOUBLE
17969: EQUAL
17970: IFTRUE 17974
17972: GO 17989
17974: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17975: LD_EXP 55
17979: PPUSH
17980: LD_STRING DBack1-Pow-1
17982: PPUSH
17983: CALL_OW 88
17987: GO 18036
17989: LD_INT 2
17991: DOUBLE
17992: EQUAL
17993: IFTRUE 17997
17995: GO 18012
17997: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17998: LD_EXP 55
18002: PPUSH
18003: LD_STRING DBack2-Pow-1
18005: PPUSH
18006: CALL_OW 88
18010: GO 18036
18012: LD_INT 3
18014: DOUBLE
18015: EQUAL
18016: IFTRUE 18020
18018: GO 18035
18020: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18021: LD_EXP 55
18025: PPUSH
18026: LD_STRING DBack3-Pow-1
18028: PPUSH
18029: CALL_OW 88
18033: GO 18036
18035: POP
// sync ;
18036: SYNC
// repeat wait ( 0 0$1 ) ;
18037: LD_INT 35
18039: PPUSH
18040: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18044: LD_INT 14
18046: PPUSH
18047: LD_INT 22
18049: PUSH
18050: LD_INT 1
18052: PUSH
18053: EMPTY
18054: LIST
18055: LIST
18056: PPUSH
18057: CALL_OW 70
18061: PPUSH
18062: LD_INT 86
18064: PPUSH
18065: LD_INT 133
18067: PPUSH
18068: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18072: LD_INT 14
18074: PPUSH
18075: LD_INT 22
18077: PUSH
18078: LD_INT 1
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: PPUSH
18085: CALL_OW 70
18089: NOT
18090: IFFALSE 18037
// if powellAnger >= 3 then
18092: LD_EXP 17
18096: PUSH
18097: LD_INT 3
18099: GREATEREQUAL
18100: IFFALSE 18109
// YouLost ( Dismissed ) ;
18102: LD_STRING Dismissed
18104: PPUSH
18105: CALL_OW 104
// Video ( false ) ;
18109: LD_INT 0
18111: PPUSH
18112: CALL 106102 0 1
// end ; until missionStage > 5 ;
18116: LD_EXP 15
18120: PUSH
18121: LD_INT 5
18123: GREATER
18124: IFFALSE 17851
// end ;
18126: PPOPN 1
18128: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18129: LD_EXP 13
18133: PUSH
18134: LD_INT 22
18136: PUSH
18137: LD_INT 4
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: PUSH
18144: LD_INT 21
18146: PUSH
18147: LD_INT 2
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: PPUSH
18158: CALL_OW 69
18162: PUSH
18163: LD_INT 4
18165: GREATEREQUAL
18166: AND
18167: PUSH
18168: LD_EXP 15
18172: PUSH
18173: LD_INT 2
18175: EQUAL
18176: AND
18177: IFFALSE 20000
18179: GO 18181
18181: DISABLE
18182: LD_INT 0
18184: PPUSH
18185: PPUSH
18186: PPUSH
18187: PPUSH
18188: PPUSH
18189: PPUSH
18190: PPUSH
18191: PPUSH
// begin missionStage := 3 ;
18192: LD_ADDR_EXP 15
18196: PUSH
18197: LD_INT 3
18199: ST_TO_ADDR
// retreat := false ;
18200: LD_ADDR_VAR 0 4
18204: PUSH
18205: LD_INT 0
18207: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18208: LD_ADDR_VAR 0 5
18212: PUSH
18213: LD_INT 22
18215: PUSH
18216: LD_INT 4
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: PUSH
18223: LD_INT 30
18225: PUSH
18226: LD_INT 4
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: PPUSH
18237: CALL_OW 69
18241: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18242: LD_ADDR_VAR 0 6
18246: PUSH
18247: LD_INT 22
18249: PUSH
18250: LD_INT 4
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: PUSH
18257: LD_INT 30
18259: PUSH
18260: LD_INT 5
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: EMPTY
18268: LIST
18269: LIST
18270: PPUSH
18271: CALL_OW 69
18275: ST_TO_ADDR
// if not bar then
18276: LD_VAR 0 6
18280: NOT
18281: IFFALSE 18334
// begin repeat wait ( 0 0$1 ) ;
18283: LD_INT 35
18285: PPUSH
18286: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18290: LD_INT 22
18292: PUSH
18293: LD_INT 4
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 3
18302: PUSH
18303: LD_INT 57
18305: PUSH
18306: EMPTY
18307: LIST
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 5
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: LIST
18327: PPUSH
18328: CALL_OW 69
18332: IFFALSE 18283
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18334: LD_ADDR_VAR 0 6
18338: PUSH
18339: LD_INT 22
18341: PUSH
18342: LD_INT 4
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PUSH
18349: LD_INT 30
18351: PUSH
18352: LD_INT 5
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PPUSH
18363: CALL_OW 69
18367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18368: LD_INT 35
18370: PPUSH
18371: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18375: LD_EXP 118
18379: PUSH
18380: LD_INT 4
18382: ARRAY
18383: PUSH
18384: LD_INT 4
18386: GREATEREQUAL
18387: IFFALSE 18368
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18389: LD_ADDR_VAR 0 2
18393: PUSH
18394: LD_INT 22
18396: PUSH
18397: LD_INT 4
18399: PUSH
18400: EMPTY
18401: LIST
18402: LIST
18403: PUSH
18404: LD_INT 2
18406: PUSH
18407: LD_INT 25
18409: PUSH
18410: LD_INT 1
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: PUSH
18417: LD_INT 25
18419: PUSH
18420: LD_INT 2
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 25
18429: PUSH
18430: LD_INT 3
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 25
18439: PUSH
18440: LD_INT 4
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 25
18449: PUSH
18450: LD_INT 5
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: LIST
18463: LIST
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PPUSH
18469: CALL_OW 69
18473: PUSH
18474: LD_EXP 55
18478: PUSH
18479: LD_EXP 56
18483: ADD
18484: DIFF
18485: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18486: LD_ADDR_VAR 0 3
18490: PUSH
18491: LD_VAR 0 2
18495: PPUSH
18496: LD_INT 26
18498: PUSH
18499: LD_INT 1
18501: PUSH
18502: EMPTY
18503: LIST
18504: LIST
18505: PPUSH
18506: CALL_OW 72
18510: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18511: LD_ADDR_VAR 0 2
18515: PUSH
18516: LD_VAR 0 2
18520: PUSH
18521: LD_VAR 0 3
18525: DIFF
18526: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18527: LD_ADDR_VAR 0 2
18531: PUSH
18532: LD_VAR 0 2
18536: PPUSH
18537: LD_INT 1
18539: PPUSH
18540: CALL 104755 0 2
18544: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18545: LD_ADDR_VAR 0 3
18549: PUSH
18550: LD_VAR 0 3
18554: PPUSH
18555: LD_INT 1
18557: PPUSH
18558: CALL 104755 0 2
18562: ST_TO_ADDR
// for i = 1 to 4 do
18563: LD_ADDR_VAR 0 1
18567: PUSH
18568: DOUBLE
18569: LD_INT 1
18571: DEC
18572: ST_TO_ADDR
18573: LD_INT 4
18575: PUSH
18576: FOR_TO
18577: IFFALSE 18743
// begin if tmp2 then
18579: LD_VAR 0 3
18583: IFFALSE 18664
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18585: LD_ADDR_EXP 18
18589: PUSH
18590: LD_EXP 18
18594: PPUSH
18595: LD_INT 1
18597: PPUSH
18598: LD_EXP 18
18602: PUSH
18603: LD_INT 1
18605: ARRAY
18606: PUSH
18607: LD_VAR 0 3
18611: PUSH
18612: LD_VAR 0 3
18616: ARRAY
18617: ADD
18618: PPUSH
18619: CALL_OW 1
18623: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18624: LD_VAR 0 3
18628: PUSH
18629: LD_VAR 0 3
18633: ARRAY
18634: PPUSH
18635: LD_INT 1
18637: PPUSH
18638: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18642: LD_ADDR_VAR 0 3
18646: PUSH
18647: LD_VAR 0 3
18651: PPUSH
18652: LD_VAR 0 3
18656: PPUSH
18657: CALL_OW 3
18661: ST_TO_ADDR
// end else
18662: GO 18741
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18664: LD_ADDR_EXP 18
18668: PUSH
18669: LD_EXP 18
18673: PPUSH
18674: LD_INT 1
18676: PPUSH
18677: LD_EXP 18
18681: PUSH
18682: LD_INT 1
18684: ARRAY
18685: PUSH
18686: LD_VAR 0 2
18690: PUSH
18691: LD_VAR 0 2
18695: ARRAY
18696: ADD
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18703: LD_VAR 0 2
18707: PUSH
18708: LD_VAR 0 2
18712: ARRAY
18713: PPUSH
18714: LD_INT 1
18716: PPUSH
18717: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18721: LD_ADDR_VAR 0 2
18725: PUSH
18726: LD_VAR 0 2
18730: PPUSH
18731: LD_VAR 0 2
18735: PPUSH
18736: CALL_OW 3
18740: ST_TO_ADDR
// end ; end ;
18741: GO 18576
18743: POP
18744: POP
// if tmp2 then
18745: LD_VAR 0 3
18749: IFFALSE 18767
// tmp := tmp union tmp2 ;
18751: LD_ADDR_VAR 0 2
18755: PUSH
18756: LD_VAR 0 2
18760: PUSH
18761: LD_VAR 0 3
18765: UNION
18766: ST_TO_ADDR
// for i = 1 to 4 do
18767: LD_ADDR_VAR 0 1
18771: PUSH
18772: DOUBLE
18773: LD_INT 1
18775: DEC
18776: ST_TO_ADDR
18777: LD_INT 4
18779: PUSH
18780: FOR_TO
18781: IFFALSE 18830
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18783: LD_ADDR_EXP 18
18787: PUSH
18788: LD_EXP 18
18792: PPUSH
18793: LD_INT 2
18795: PPUSH
18796: LD_EXP 18
18800: PUSH
18801: LD_INT 2
18803: ARRAY
18804: PUSH
18805: LD_VAR 0 2
18809: PUSH
18810: LD_VAR 0 2
18814: PUSH
18815: LD_VAR 0 1
18819: MINUS
18820: ARRAY
18821: ADD
18822: PPUSH
18823: CALL_OW 1
18827: ST_TO_ADDR
18828: GO 18780
18830: POP
18831: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18832: LD_ADDR_EXP 99
18836: PUSH
18837: LD_EXP 99
18841: PPUSH
18842: LD_INT 4
18844: PPUSH
18845: LD_EXP 99
18849: PUSH
18850: LD_INT 4
18852: ARRAY
18853: PUSH
18854: LD_EXP 18
18858: PUSH
18859: LD_INT 1
18861: ARRAY
18862: DIFF
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18869: LD_VAR 0 5
18873: PUSH
18874: LD_INT 1
18876: ARRAY
18877: PPUSH
18878: CALL_OW 313
18882: IFFALSE 18937
// begin for i in UnitsInside ( arm [ 1 ] ) do
18884: LD_ADDR_VAR 0 1
18888: PUSH
18889: LD_VAR 0 5
18893: PUSH
18894: LD_INT 1
18896: ARRAY
18897: PPUSH
18898: CALL_OW 313
18902: PUSH
18903: FOR_IN
18904: IFFALSE 18935
// begin ComExitBuilding ( i ) ;
18906: LD_VAR 0 1
18910: PPUSH
18911: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18915: LD_VAR 0 1
18919: PPUSH
18920: LD_VAR 0 6
18924: PUSH
18925: LD_INT 1
18927: ARRAY
18928: PPUSH
18929: CALL_OW 180
// end ;
18933: GO 18903
18935: POP
18936: POP
// end ; wait ( 0 0$3 ) ;
18937: LD_INT 105
18939: PPUSH
18940: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18944: LD_ADDR_VAR 0 1
18948: PUSH
18949: LD_EXP 18
18953: PUSH
18954: LD_INT 1
18956: ARRAY
18957: PUSH
18958: FOR_IN
18959: IFFALSE 19066
// begin if IsInUnit ( i ) then
18961: LD_VAR 0 1
18965: PPUSH
18966: CALL_OW 310
18970: IFFALSE 18981
// ComExitBuilding ( i ) ;
18972: LD_VAR 0 1
18976: PPUSH
18977: CALL_OW 122
// if GetClass ( i ) <> 1 then
18981: LD_VAR 0 1
18985: PPUSH
18986: CALL_OW 257
18990: PUSH
18991: LD_INT 1
18993: NONEQUAL
18994: IFFALSE 19035
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18996: LD_VAR 0 1
19000: PPUSH
19001: LD_VAR 0 5
19005: PUSH
19006: LD_INT 1
19008: ARRAY
19009: PPUSH
19010: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19014: LD_VAR 0 1
19018: PPUSH
19019: LD_INT 1
19021: PPUSH
19022: CALL_OW 183
// AddComExitBuilding ( i ) ;
19026: LD_VAR 0 1
19030: PPUSH
19031: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19035: LD_VAR 0 1
19039: PPUSH
19040: LD_INT 60
19042: PPUSH
19043: LD_INT 94
19045: PPUSH
19046: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19050: LD_VAR 0 1
19054: PPUSH
19055: LD_EXP 55
19059: PPUSH
19060: CALL_OW 179
// end ;
19064: GO 18958
19066: POP
19067: POP
// wait ( 0 0$15 ) ;
19068: LD_INT 525
19070: PPUSH
19071: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19075: LD_EXP 55
19079: PPUSH
19080: LD_STRING D4-Pow-1
19082: PPUSH
19083: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19087: LD_ADDR_VAR 0 2
19091: PUSH
19092: LD_EXP 18
19096: PUSH
19097: LD_INT 1
19099: ARRAY
19100: PPUSH
19101: LD_INT 26
19103: PUSH
19104: LD_INT 1
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PPUSH
19111: CALL_OW 72
19115: ST_TO_ADDR
// if tmp then
19116: LD_VAR 0 2
19120: IFFALSE 19138
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19122: LD_VAR 0 2
19126: PUSH
19127: LD_INT 1
19129: ARRAY
19130: PPUSH
19131: LD_STRING D4-Sol1-1
19133: PPUSH
19134: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19138: LD_EXP 55
19142: PPUSH
19143: LD_STRING D4-Pow-2
19145: PPUSH
19146: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: DOUBLE
19156: LD_INT 1
19158: DEC
19159: ST_TO_ADDR
19160: LD_EXP 18
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: PUSH
19169: FOR_TO
19170: IFFALSE 19263
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19172: LD_EXP 18
19176: PUSH
19177: LD_INT 1
19179: ARRAY
19180: PUSH
19181: LD_VAR 0 1
19185: ARRAY
19186: PPUSH
19187: LD_EXP 118
19191: PUSH
19192: LD_INT 4
19194: ARRAY
19195: PUSH
19196: LD_INT 1
19198: ARRAY
19199: PPUSH
19200: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19204: LD_ADDR_EXP 118
19208: PUSH
19209: LD_EXP 118
19213: PPUSH
19214: LD_INT 4
19216: PPUSH
19217: LD_EXP 118
19221: PUSH
19222: LD_INT 4
19224: ARRAY
19225: PPUSH
19226: LD_INT 1
19228: PPUSH
19229: CALL_OW 3
19233: PPUSH
19234: CALL_OW 1
19238: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19239: LD_INT 8
19241: PPUSH
19242: LD_EXP 18
19246: PUSH
19247: LD_INT 1
19249: ARRAY
19250: PUSH
19251: LD_VAR 0 1
19255: ARRAY
19256: PPUSH
19257: CALL_OW 471
// end ;
19261: GO 19169
19263: POP
19264: POP
// repeat wait ( 0 0$1 ) ;
19265: LD_INT 35
19267: PPUSH
19268: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19272: LD_EXP 18
19276: PUSH
19277: LD_INT 1
19279: ARRAY
19280: PPUSH
19281: LD_INT 55
19283: PUSH
19284: EMPTY
19285: LIST
19286: PPUSH
19287: CALL_OW 72
19291: PUSH
19292: LD_INT 4
19294: GREATEREQUAL
19295: IFFALSE 19265
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19297: LD_EXP 18
19301: PUSH
19302: LD_INT 1
19304: ARRAY
19305: PPUSH
19306: LD_INT 69
19308: PPUSH
19309: LD_INT 94
19311: PPUSH
19312: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19316: LD_EXP 18
19320: PUSH
19321: LD_INT 1
19323: ARRAY
19324: PPUSH
19325: LD_INT 82
19327: PPUSH
19328: LD_INT 83
19330: PPUSH
19331: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19335: LD_EXP 18
19339: PUSH
19340: LD_INT 1
19342: ARRAY
19343: PPUSH
19344: LD_INT 77
19346: PPUSH
19347: LD_INT 69
19349: PPUSH
19350: CALL_OW 174
// repeat wait ( 3 ) ;
19354: LD_INT 3
19356: PPUSH
19357: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19361: LD_ADDR_VAR 0 1
19365: PUSH
19366: LD_EXP 18
19370: PUSH
19371: LD_INT 1
19373: ARRAY
19374: PUSH
19375: FOR_IN
19376: IFFALSE 19512
// begin if GetLives ( i ) < 990 then
19378: LD_VAR 0 1
19382: PPUSH
19383: CALL_OW 256
19387: PUSH
19388: LD_INT 990
19390: LESS
19391: IFFALSE 19405
// SetLives ( i , 1000 ) ;
19393: LD_VAR 0 1
19397: PPUSH
19398: LD_INT 1000
19400: PPUSH
19401: CALL_OW 234
// if not IsInUnit ( i ) then
19405: LD_VAR 0 1
19409: PPUSH
19410: CALL_OW 310
19414: NOT
19415: IFFALSE 19510
// begin if not HasTask ( i ) then
19417: LD_VAR 0 1
19421: PPUSH
19422: CALL_OW 314
19426: NOT
19427: IFFALSE 19444
// ComMoveXY ( i , 64 , 93 ) ;
19429: LD_VAR 0 1
19433: PPUSH
19434: LD_INT 64
19436: PPUSH
19437: LD_INT 93
19439: PPUSH
19440: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19444: LD_VAR 0 4
19448: NOT
19449: PUSH
19450: LD_VAR 0 1
19454: PPUSH
19455: CALL_OW 258
19459: PUSH
19460: LD_INT 1
19462: EQUAL
19463: AND
19464: IFFALSE 19510
// begin retreat := true ;
19466: LD_ADDR_VAR 0 4
19470: PUSH
19471: LD_INT 1
19473: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19474: LD_VAR 0 1
19478: PPUSH
19479: LD_INT 2
19481: PPUSH
19482: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19486: LD_VAR 0 1
19490: PPUSH
19491: LD_STRING D4a-Sol1-1
19493: PPUSH
19494: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19498: LD_EXP 55
19502: PPUSH
19503: LD_STRING D4a-Pow-1
19505: PPUSH
19506: CALL_OW 88
// end ; end ; end ;
19510: GO 19375
19512: POP
19513: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19514: LD_EXP 18
19518: PUSH
19519: LD_INT 1
19521: ARRAY
19522: PPUSH
19523: LD_INT 95
19525: PUSH
19526: LD_INT 9
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PUSH
19533: LD_INT 3
19535: PUSH
19536: LD_INT 55
19538: PUSH
19539: EMPTY
19540: LIST
19541: PUSH
19542: EMPTY
19543: LIST
19544: LIST
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: PPUSH
19550: CALL_OW 72
19554: PUSH
19555: LD_INT 4
19557: GREATEREQUAL
19558: IFFALSE 19354
// for i in powellSquadAttack [ 1 ] do
19560: LD_ADDR_VAR 0 1
19564: PUSH
19565: LD_EXP 18
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PUSH
19574: FOR_IN
19575: IFFALSE 19711
// begin if GetTag ( i ) = 2 then
19577: LD_VAR 0 1
19581: PPUSH
19582: CALL_OW 110
19586: PUSH
19587: LD_INT 2
19589: EQUAL
19590: IFFALSE 19652
// begin ComMoveXY ( i , 60 , 94 ) ;
19592: LD_VAR 0 1
19596: PPUSH
19597: LD_INT 60
19599: PPUSH
19600: LD_INT 94
19602: PPUSH
19603: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19607: LD_VAR 0 1
19611: PPUSH
19612: LD_EXP 55
19616: PPUSH
19617: CALL_OW 179
// wait ( 0 0$3 ) ;
19621: LD_INT 105
19623: PPUSH
19624: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19628: LD_VAR 0 1
19632: PPUSH
19633: LD_STRING D4a-Sol1-2
19635: PPUSH
19636: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19640: LD_EXP 55
19644: PPUSH
19645: LD_STRING D4a-Pow-2
19647: PPUSH
19648: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19652: LD_VAR 0 1
19656: PPUSH
19657: LD_INT 0
19659: PPUSH
19660: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19664: LD_ADDR_EXP 99
19668: PUSH
19669: LD_EXP 99
19673: PPUSH
19674: LD_INT 4
19676: PPUSH
19677: LD_EXP 99
19681: PUSH
19682: LD_INT 4
19684: ARRAY
19685: PUSH
19686: LD_VAR 0 1
19690: UNION
19691: PPUSH
19692: CALL_OW 1
19696: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19697: LD_INT 8
19699: PPUSH
19700: LD_VAR 0 1
19704: PPUSH
19705: CALL_OW 472
// end ;
19709: GO 19574
19711: POP
19712: POP
// wait ( 4 4$00 ) ;
19713: LD_INT 8400
19715: PPUSH
19716: CALL_OW 67
// uc_side := 6 ;
19720: LD_ADDR_OWVAR 20
19724: PUSH
19725: LD_INT 6
19727: ST_TO_ADDR
// uc_nation := 3 ;
19728: LD_ADDR_OWVAR 21
19732: PUSH
19733: LD_INT 3
19735: ST_TO_ADDR
// ru := [ ] ;
19736: LD_ADDR_VAR 0 7
19740: PUSH
19741: EMPTY
19742: ST_TO_ADDR
// for i = 1 to 4 do
19743: LD_ADDR_VAR 0 1
19747: PUSH
19748: DOUBLE
19749: LD_INT 1
19751: DEC
19752: ST_TO_ADDR
19753: LD_INT 4
19755: PUSH
19756: FOR_TO
19757: IFFALSE 19858
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19759: LD_INT 22
19761: PPUSH
19762: LD_INT 1
19764: PPUSH
19765: LD_INT 3
19767: PPUSH
19768: LD_INT 43
19770: PUSH
19771: LD_INT 44
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PUSH
19778: LD_INT 1
19780: PPUSH
19781: LD_INT 2
19783: PPUSH
19784: CALL_OW 12
19788: ARRAY
19789: PPUSH
19790: LD_INT 89
19792: PPUSH
19793: CALL 70385 0 5
// un := CreateVehicle ;
19797: LD_ADDR_VAR 0 8
19801: PUSH
19802: CALL_OW 45
19806: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19807: LD_VAR 0 8
19811: PPUSH
19812: LD_INT 4
19814: PPUSH
19815: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19819: LD_VAR 0 8
19823: PPUSH
19824: LD_INT 136
19826: PPUSH
19827: LD_INT 90
19829: PPUSH
19830: LD_INT 8
19832: PPUSH
19833: LD_INT 0
19835: PPUSH
19836: CALL_OW 50
// ru := ru ^ un ;
19840: LD_ADDR_VAR 0 7
19844: PUSH
19845: LD_VAR 0 7
19849: PUSH
19850: LD_VAR 0 8
19854: ADD
19855: ST_TO_ADDR
// end ;
19856: GO 19756
19858: POP
19859: POP
// if ru then
19860: LD_VAR 0 7
19864: IFFALSE 19881
// ComAgressiveMove ( ru , 80 , 92 ) ;
19866: LD_VAR 0 7
19870: PPUSH
19871: LD_INT 80
19873: PPUSH
19874: LD_INT 92
19876: PPUSH
19877: CALL_OW 114
// wait ( 8 8$00 ) ;
19881: LD_INT 16800
19883: PPUSH
19884: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19888: LD_INT 4
19890: PPUSH
19891: LD_INT 3
19893: PUSH
19894: LD_INT 1
19896: PUSH
19897: LD_INT 1
19899: PUSH
19900: LD_INT 5
19902: PUSH
19903: EMPTY
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: PUSH
19909: LD_INT 4
19911: PUSH
19912: LD_INT 1
19914: PUSH
19915: LD_INT 1
19917: PUSH
19918: LD_INT 6
19920: PUSH
19921: EMPTY
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: PUSH
19927: LD_INT 4
19929: PUSH
19930: LD_INT 1
19932: PUSH
19933: LD_INT 1
19935: PUSH
19936: LD_INT 7
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: LIST
19944: PUSH
19945: LD_INT 3
19947: PUSH
19948: LD_INT 1
19950: PUSH
19951: LD_INT 1
19953: PUSH
19954: LD_INT 7
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: PUSH
19963: LD_INT 3
19965: PUSH
19966: LD_INT 1
19968: PUSH
19969: LD_INT 1
19971: PUSH
19972: LD_INT 5
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: PPUSH
19988: CALL 57350 0 2
// missionStage := 4 ;
19992: LD_ADDR_EXP 15
19996: PUSH
19997: LD_INT 4
19999: ST_TO_ADDR
// end ;
20000: PPOPN 8
20002: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20003: LD_EXP 15
20007: PUSH
20008: LD_INT 4
20010: EQUAL
20011: PUSH
20012: LD_INT 22
20014: PUSH
20015: LD_INT 4
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: PUSH
20022: LD_INT 21
20024: PUSH
20025: LD_INT 2
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PPUSH
20036: CALL_OW 69
20040: PUSH
20041: LD_INT 5
20043: GREATEREQUAL
20044: AND
20045: IFFALSE 24138
20047: GO 20049
20049: DISABLE
20050: LD_INT 0
20052: PPUSH
20053: PPUSH
20054: PPUSH
20055: PPUSH
20056: PPUSH
20057: PPUSH
20058: PPUSH
20059: PPUSH
20060: PPUSH
20061: PPUSH
20062: PPUSH
20063: PPUSH
20064: PPUSH
// begin missionStage := 5 ;
20065: LD_ADDR_EXP 15
20069: PUSH
20070: LD_INT 5
20072: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20073: LD_ADDR_VAR 0 10
20077: PUSH
20078: LD_INT 22
20080: PUSH
20081: LD_INT 4
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 2
20090: PUSH
20091: LD_INT 30
20093: PUSH
20094: LD_INT 4
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: PUSH
20101: LD_INT 30
20103: PUSH
20104: LD_INT 5
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: PUSH
20111: EMPTY
20112: LIST
20113: LIST
20114: LIST
20115: PUSH
20116: EMPTY
20117: LIST
20118: LIST
20119: PPUSH
20120: CALL_OW 69
20124: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20125: LD_ADDR_VAR 0 6
20129: PUSH
20130: LD_INT 22
20132: PUSH
20133: LD_INT 4
20135: PUSH
20136: EMPTY
20137: LIST
20138: LIST
20139: PUSH
20140: LD_INT 21
20142: PUSH
20143: LD_INT 1
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: PUSH
20150: LD_INT 3
20152: PUSH
20153: LD_INT 25
20155: PUSH
20156: LD_INT 16
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: LD_INT 25
20172: PUSH
20173: LD_INT 12
20175: PUSH
20176: EMPTY
20177: LIST
20178: LIST
20179: PUSH
20180: EMPTY
20181: LIST
20182: LIST
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: PPUSH
20190: CALL_OW 69
20194: PUSH
20195: LD_EXP 55
20199: DIFF
20200: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20201: LD_ADDR_VAR 0 9
20205: PUSH
20206: LD_INT 22
20208: PUSH
20209: LD_INT 4
20211: PUSH
20212: EMPTY
20213: LIST
20214: LIST
20215: PUSH
20216: LD_INT 30
20218: PUSH
20219: LD_INT 3
20221: PUSH
20222: EMPTY
20223: LIST
20224: LIST
20225: PUSH
20226: EMPTY
20227: LIST
20228: LIST
20229: PPUSH
20230: CALL_OW 69
20234: PUSH
20235: LD_INT 1
20237: ARRAY
20238: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20239: LD_INT 35
20241: PPUSH
20242: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20246: LD_EXP 118
20250: PUSH
20251: LD_INT 4
20253: ARRAY
20254: PUSH
20255: LD_INT 5
20257: GREATEREQUAL
20258: PUSH
20259: LD_EXP 118
20263: PUSH
20264: LD_INT 4
20266: ARRAY
20267: PPUSH
20268: LD_INT 58
20270: PUSH
20271: EMPTY
20272: LIST
20273: PPUSH
20274: CALL_OW 72
20278: PUSH
20279: LD_INT 5
20281: GREATEREQUAL
20282: AND
20283: IFFALSE 20239
// powellAllowRetreat := false ;
20285: LD_ADDR_EXP 19
20289: PUSH
20290: LD_INT 0
20292: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20293: LD_INT 700
20295: PPUSH
20296: CALL_OW 67
// activeAttacks := false ;
20300: LD_ADDR_EXP 16
20304: PUSH
20305: LD_INT 0
20307: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20308: LD_INT 35
20310: PPUSH
20311: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20315: LD_INT 22
20317: PUSH
20318: LD_INT 6
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: PPUSH
20325: CALL_OW 69
20329: PUSH
20330: LD_INT 0
20332: EQUAL
20333: IFFALSE 20308
// tmp := mc_vehicles [ 4 ] ;
20335: LD_ADDR_VAR 0 3
20339: PUSH
20340: LD_EXP 118
20344: PUSH
20345: LD_INT 4
20347: ARRAY
20348: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20349: LD_ADDR_VAR 0 1
20353: PUSH
20354: DOUBLE
20355: LD_INT 1
20357: DEC
20358: ST_TO_ADDR
20359: LD_EXP 18
20363: PUSH
20364: FOR_TO
20365: IFFALSE 20626
// begin for j in powellSquadAttack [ i ] do
20367: LD_ADDR_VAR 0 2
20371: PUSH
20372: LD_EXP 18
20376: PUSH
20377: LD_VAR 0 1
20381: ARRAY
20382: PUSH
20383: FOR_IN
20384: IFFALSE 20622
// begin forces := forces diff j ;
20386: LD_ADDR_VAR 0 6
20390: PUSH
20391: LD_VAR 0 6
20395: PUSH
20396: LD_VAR 0 2
20400: DIFF
20401: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20402: LD_VAR 0 2
20406: PPUSH
20407: LD_INT 1
20409: PPUSH
20410: CALL_OW 109
// wait ( 0 0$2 ) ;
20414: LD_INT 70
20416: PPUSH
20417: CALL_OW 67
// if IsInUnit ( j ) then
20421: LD_VAR 0 2
20425: PPUSH
20426: CALL_OW 310
20430: IFFALSE 20441
// ComExitBuilding ( j ) ;
20432: LD_VAR 0 2
20436: PPUSH
20437: CALL_OW 122
// if GetClass ( j ) <> 1 then
20441: LD_VAR 0 2
20445: PPUSH
20446: CALL_OW 257
20450: PUSH
20451: LD_INT 1
20453: NONEQUAL
20454: IFFALSE 20534
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20456: LD_VAR 0 10
20460: PUSH
20461: LD_INT 1
20463: ARRAY
20464: PPUSH
20465: CALL_OW 313
20469: PUSH
20470: LD_INT 5
20472: GREATEREQUAL
20473: IFFALSE 20495
// AddComEnterUnit ( j , arm [ 2 ] ) else
20475: LD_VAR 0 2
20479: PPUSH
20480: LD_VAR 0 10
20484: PUSH
20485: LD_INT 2
20487: ARRAY
20488: PPUSH
20489: CALL_OW 180
20493: GO 20513
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20495: LD_VAR 0 2
20499: PPUSH
20500: LD_VAR 0 10
20504: PUSH
20505: LD_INT 1
20507: ARRAY
20508: PPUSH
20509: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20513: LD_VAR 0 2
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: CALL_OW 183
// AddComExitBuilding ( j ) ;
20525: LD_VAR 0 2
20529: PPUSH
20530: CALL_OW 182
// end ; if i = 2 then
20534: LD_VAR 0 1
20538: PUSH
20539: LD_INT 2
20541: EQUAL
20542: IFFALSE 20559
// AddComMoveXY ( j , 61 , 93 ) ;
20544: LD_VAR 0 2
20548: PPUSH
20549: LD_INT 61
20551: PPUSH
20552: LD_INT 93
20554: PPUSH
20555: CALL_OW 171
// if i = 1 then
20559: LD_VAR 0 1
20563: PUSH
20564: LD_INT 1
20566: EQUAL
20567: IFFALSE 20620
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20569: LD_VAR 0 2
20573: PPUSH
20574: LD_VAR 0 3
20578: PUSH
20579: LD_INT 1
20581: ARRAY
20582: PPUSH
20583: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20587: LD_ADDR_VAR 0 3
20591: PUSH
20592: LD_VAR 0 3
20596: PPUSH
20597: LD_INT 1
20599: PPUSH
20600: CALL_OW 3
20604: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20605: LD_VAR 0 2
20609: PPUSH
20610: LD_INT 69
20612: PPUSH
20613: LD_INT 94
20615: PPUSH
20616: CALL_OW 171
// end ; end ;
20620: GO 20383
20622: POP
20623: POP
// end ;
20624: GO 20364
20626: POP
20627: POP
// wait ( 0 0$55 ) ;
20628: LD_INT 1925
20630: PPUSH
20631: CALL_OW 67
// MC_Kill ( 4 ) ;
20635: LD_INT 4
20637: PPUSH
20638: CALL 34050 0 1
// tmp := UnitsInside ( fac ) ;
20642: LD_ADDR_VAR 0 3
20646: PUSH
20647: LD_VAR 0 9
20651: PPUSH
20652: CALL_OW 313
20656: ST_TO_ADDR
// if tmp then
20657: LD_VAR 0 3
20661: IFFALSE 20782
// for i in tmp do
20663: LD_ADDR_VAR 0 1
20667: PUSH
20668: LD_VAR 0 3
20672: PUSH
20673: FOR_IN
20674: IFFALSE 20780
// begin ComExitBuilding ( i ) ;
20676: LD_VAR 0 1
20680: PPUSH
20681: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20685: LD_VAR 0 10
20689: PUSH
20690: LD_INT 2
20692: ARRAY
20693: PPUSH
20694: CALL_OW 313
20698: PUSH
20699: LD_INT 6
20701: LESS
20702: IFFALSE 20724
// AddComEnterUnit ( i , arm [ 2 ] ) else
20704: LD_VAR 0 1
20708: PPUSH
20709: LD_VAR 0 10
20713: PUSH
20714: LD_INT 2
20716: ARRAY
20717: PPUSH
20718: CALL_OW 180
20722: GO 20778
// if UnitsInside ( arm [ 1 ] ) < 6 then
20724: LD_VAR 0 10
20728: PUSH
20729: LD_INT 1
20731: ARRAY
20732: PPUSH
20733: CALL_OW 313
20737: PUSH
20738: LD_INT 6
20740: LESS
20741: IFFALSE 20763
// AddComEnterUnit ( i , arm [ 1 ] ) else
20743: LD_VAR 0 1
20747: PPUSH
20748: LD_VAR 0 10
20752: PUSH
20753: LD_INT 1
20755: ARRAY
20756: PPUSH
20757: CALL_OW 180
20761: GO 20778
// AddComMoveXY ( i , 37 , 68 ) ;
20763: LD_VAR 0 1
20767: PPUSH
20768: LD_INT 37
20770: PPUSH
20771: LD_INT 68
20773: PPUSH
20774: CALL_OW 171
// end ;
20778: GO 20673
20780: POP
20781: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20782: LD_ADDR_VAR 0 11
20786: PUSH
20787: LD_VAR 0 6
20791: PPUSH
20792: LD_INT 26
20794: PUSH
20795: LD_INT 1
20797: PUSH
20798: EMPTY
20799: LIST
20800: LIST
20801: PPUSH
20802: CALL_OW 72
20806: PUSH
20807: LD_EXP 56
20811: DIFF
20812: ST_TO_ADDR
// if not speaker then
20813: LD_VAR 0 11
20817: NOT
20818: IFFALSE 20845
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20820: LD_ADDR_VAR 0 11
20824: PUSH
20825: LD_VAR 0 6
20829: PPUSH
20830: LD_INT 26
20832: PUSH
20833: LD_INT 1
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: PPUSH
20840: CALL_OW 72
20844: ST_TO_ADDR
// if speaker then
20845: LD_VAR 0 11
20849: IFFALSE 20865
// speaker := speaker [ 1 ] ;
20851: LD_ADDR_VAR 0 11
20855: PUSH
20856: LD_VAR 0 11
20860: PUSH
20861: LD_INT 1
20863: ARRAY
20864: ST_TO_ADDR
// Video ( true ) ;
20865: LD_INT 1
20867: PPUSH
20868: CALL 106102 0 1
// CenterNowOnUnits ( Powell ) ;
20872: LD_EXP 55
20876: PPUSH
20877: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20881: LD_ADDR_VAR 0 3
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_INT 3
20893: PUSH
20894: LD_INT 25
20896: PUSH
20897: LD_INT 1
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: PPUSH
20908: CALL_OW 72
20912: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20913: LD_ADDR_VAR 0 12
20917: PUSH
20918: LD_INT 22
20920: PUSH
20921: LD_INT 4
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: PUSH
20928: LD_INT 30
20930: PUSH
20931: LD_INT 32
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PUSH
20938: LD_INT 58
20940: PUSH
20941: EMPTY
20942: LIST
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: LIST
20948: PPUSH
20949: CALL_OW 69
20953: ST_TO_ADDR
// for i = 1 to 6 do
20954: LD_ADDR_VAR 0 1
20958: PUSH
20959: DOUBLE
20960: LD_INT 1
20962: DEC
20963: ST_TO_ADDR
20964: LD_INT 6
20966: PUSH
20967: FOR_TO
20968: IFFALSE 21109
// begin if IsInUnit ( tmp [ i ] ) then
20970: LD_VAR 0 3
20974: PUSH
20975: LD_VAR 0 1
20979: ARRAY
20980: PPUSH
20981: CALL_OW 310
20985: IFFALSE 21002
// ComExitBuilding ( tmp [ i ] ) ;
20987: LD_VAR 0 3
20991: PUSH
20992: LD_VAR 0 1
20996: ARRAY
20997: PPUSH
20998: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21002: LD_VAR 0 3
21006: PUSH
21007: LD_VAR 0 1
21011: ARRAY
21012: PPUSH
21013: LD_VAR 0 10
21017: PUSH
21018: LD_INT 1
21020: ARRAY
21021: PPUSH
21022: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21026: LD_VAR 0 3
21030: PUSH
21031: LD_VAR 0 1
21035: ARRAY
21036: PPUSH
21037: LD_INT 1
21039: PPUSH
21040: CALL_OW 183
// if emp_towers then
21044: LD_VAR 0 12
21048: IFFALSE 21107
// begin AddComExitBuilding ( tmp [ i ] ) ;
21050: LD_VAR 0 3
21054: PUSH
21055: LD_VAR 0 1
21059: ARRAY
21060: PPUSH
21061: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21065: LD_VAR 0 3
21069: PUSH
21070: LD_VAR 0 1
21074: ARRAY
21075: PPUSH
21076: LD_VAR 0 12
21080: PUSH
21081: LD_INT 1
21083: ARRAY
21084: PPUSH
21085: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21089: LD_ADDR_VAR 0 12
21093: PUSH
21094: LD_VAR 0 12
21098: PPUSH
21099: LD_INT 1
21101: PPUSH
21102: CALL_OW 3
21106: ST_TO_ADDR
// end ; end ;
21107: GO 20967
21109: POP
21110: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: LD_EXP 18
21120: PUSH
21121: LD_INT 1
21123: ARRAY
21124: PUSH
21125: LD_EXP 18
21129: PUSH
21130: LD_INT 2
21132: ARRAY
21133: ADD
21134: PPUSH
21135: LD_INT 26
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PPUSH
21145: CALL_OW 72
21149: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21150: LD_ADDR_VAR 0 1
21154: PUSH
21155: LD_EXP 18
21159: PUSH
21160: LD_INT 2
21162: ARRAY
21163: PUSH
21164: FOR_IN
21165: IFFALSE 21183
// ComTurnUnit ( i , Powell ) ;
21167: LD_VAR 0 1
21171: PPUSH
21172: LD_EXP 55
21176: PPUSH
21177: CALL_OW 119
21181: GO 21164
21183: POP
21184: POP
// Say ( Powell , D5-Pow-1 ) ;
21185: LD_EXP 55
21189: PPUSH
21190: LD_STRING D5-Pow-1
21192: PPUSH
21193: CALL_OW 88
// if tmp then
21197: LD_VAR 0 3
21201: IFFALSE 21219
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21203: LD_VAR 0 3
21207: PUSH
21208: LD_INT 1
21210: ARRAY
21211: PPUSH
21212: LD_STRING D5-Sol2-1
21214: PPUSH
21215: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21219: LD_EXP 55
21223: PPUSH
21224: LD_STRING D5-Pow-2
21226: PPUSH
21227: CALL_OW 88
// if tmp > 1 then
21231: LD_VAR 0 3
21235: PUSH
21236: LD_INT 1
21238: GREATER
21239: IFFALSE 21257
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21241: LD_VAR 0 3
21245: PUSH
21246: LD_INT 2
21248: ARRAY
21249: PPUSH
21250: LD_STRING D5-Sol2-2
21252: PPUSH
21253: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21257: LD_EXP 55
21261: PPUSH
21262: LD_STRING D5-Pow-3
21264: PPUSH
21265: CALL_OW 88
// wait ( 0 0$1 ) ;
21269: LD_INT 35
21271: PPUSH
21272: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21276: LD_ADDR_VAR 0 3
21280: PUSH
21281: LD_EXP 18
21285: PUSH
21286: LD_INT 1
21288: ARRAY
21289: PUSH
21290: LD_EXP 18
21294: PUSH
21295: LD_INT 2
21297: ARRAY
21298: UNION
21299: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21300: LD_VAR 0 3
21304: PPUSH
21305: LD_INT 80
21307: PPUSH
21308: LD_INT 67
21310: PPUSH
21311: CALL_OW 114
// wait ( 0 0$2 ) ;
21315: LD_INT 70
21317: PPUSH
21318: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21322: LD_INT 79
21324: PPUSH
21325: LD_INT 72
21327: PPUSH
21328: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21332: LD_INT 35
21334: PPUSH
21335: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21339: LD_VAR 0 3
21343: PPUSH
21344: LD_INT 3
21346: PUSH
21347: LD_INT 24
21349: PUSH
21350: LD_INT 1000
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: PUSH
21357: EMPTY
21358: LIST
21359: LIST
21360: PPUSH
21361: CALL_OW 72
21365: IFFALSE 21332
// Say ( Powell , D5a-Pow-1 ) ;
21367: LD_EXP 55
21371: PPUSH
21372: LD_STRING D5a-Pow-1
21374: PPUSH
21375: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21379: LD_EXP 55
21383: PPUSH
21384: LD_STRING D5a-Pow-1a
21386: PPUSH
21387: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21391: LD_INT 10
21393: PPUSH
21394: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21398: LD_EXP 55
21402: PPUSH
21403: LD_STRING D5a-Pow-1b
21405: PPUSH
21406: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21410: LD_EXP 55
21414: PPUSH
21415: LD_STRING D5a-Pow-1c
21417: PPUSH
21418: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21422: LD_EXP 55
21426: PPUSH
21427: LD_STRING D5a-Pow-1d
21429: PPUSH
21430: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21434: LD_INT 35
21436: PPUSH
21437: CALL_OW 67
// if not HasTask ( tmp ) then
21441: LD_VAR 0 3
21445: PPUSH
21446: CALL_OW 314
21450: NOT
21451: IFFALSE 21468
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21453: LD_VAR 0 3
21457: PPUSH
21458: LD_INT 80
21460: PPUSH
21461: LD_INT 67
21463: PPUSH
21464: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21468: LD_VAR 0 3
21472: PPUSH
21473: LD_INT 24
21475: PUSH
21476: LD_INT 1
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: PPUSH
21483: CALL_OW 72
21487: NOT
21488: IFFALSE 21434
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21490: LD_ADDR_VAR 0 3
21494: PUSH
21495: LD_INT 22
21497: PUSH
21498: LD_INT 4
21500: PUSH
21501: EMPTY
21502: LIST
21503: LIST
21504: PUSH
21505: LD_INT 92
21507: PUSH
21508: LD_INT 60
21510: PUSH
21511: LD_INT 93
21513: PUSH
21514: LD_INT 10
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: LIST
21521: LIST
21522: PUSH
21523: LD_INT 3
21525: PUSH
21526: LD_INT 54
21528: PUSH
21529: EMPTY
21530: LIST
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: PUSH
21536: EMPTY
21537: LIST
21538: LIST
21539: LIST
21540: PPUSH
21541: CALL_OW 69
21545: PUSH
21546: LD_EXP 55
21550: DIFF
21551: ST_TO_ADDR
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21590
// for i in tmp do
21558: LD_ADDR_VAR 0 1
21562: PUSH
21563: LD_VAR 0 3
21567: PUSH
21568: FOR_IN
21569: IFFALSE 21588
// ComMoveXY ( i , 36 , 67 ) ;
21571: LD_VAR 0 1
21575: PPUSH
21576: LD_INT 36
21578: PPUSH
21579: LD_INT 67
21581: PPUSH
21582: CALL_OW 111
21586: GO 21568
21588: POP
21589: POP
// wait ( 0 0$3 ) ;
21590: LD_INT 105
21592: PPUSH
21593: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21597: LD_VAR 0 11
21601: PPUSH
21602: LD_STRING D6-Sol3-1
21604: PPUSH
21605: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21609: LD_EXP 55
21613: PPUSH
21614: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21618: LD_EXP 55
21622: PPUSH
21623: LD_STRING D6-Pow-1
21625: PPUSH
21626: CALL_OW 88
// tmp := [ ] ;
21630: LD_ADDR_VAR 0 3
21634: PUSH
21635: EMPTY
21636: ST_TO_ADDR
// for i = 1 to 2 do
21637: LD_ADDR_VAR 0 1
21641: PUSH
21642: DOUBLE
21643: LD_INT 1
21645: DEC
21646: ST_TO_ADDR
21647: LD_INT 2
21649: PUSH
21650: FOR_TO
21651: IFFALSE 21765
// begin uc_side := 8 ;
21653: LD_ADDR_OWVAR 20
21657: PUSH
21658: LD_INT 8
21660: ST_TO_ADDR
// uc_nation := 2 ;
21661: LD_ADDR_OWVAR 21
21665: PUSH
21666: LD_INT 2
21668: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21669: LD_INT 14
21671: PPUSH
21672: LD_INT 3
21674: PPUSH
21675: LD_INT 2
21677: PPUSH
21678: LD_INT 29
21680: PPUSH
21681: LD_INT 100
21683: PPUSH
21684: CALL 70385 0 5
// veh := CreateVehicle ;
21688: LD_ADDR_VAR 0 13
21692: PUSH
21693: CALL_OW 45
21697: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21698: LD_VAR 0 13
21702: PPUSH
21703: LD_INT 4
21705: PPUSH
21706: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21710: LD_VAR 0 13
21714: PPUSH
21715: LD_INT 99
21717: PPUSH
21718: LD_INT 83
21720: PPUSH
21721: LD_INT 6
21723: PPUSH
21724: LD_INT 0
21726: PPUSH
21727: CALL_OW 50
// wait ( 3 ) ;
21731: LD_INT 3
21733: PPUSH
21734: CALL_OW 67
// Connect ( veh ) ;
21738: LD_VAR 0 13
21742: PPUSH
21743: CALL 73440 0 1
// tmp := tmp ^ veh ;
21747: LD_ADDR_VAR 0 3
21751: PUSH
21752: LD_VAR 0 3
21756: PUSH
21757: LD_VAR 0 13
21761: ADD
21762: ST_TO_ADDR
// end ;
21763: GO 21650
21765: POP
21766: POP
// wait ( 0 0$1 ) ;
21767: LD_INT 35
21769: PPUSH
21770: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21774: LD_INT 99
21776: PPUSH
21777: LD_INT 83
21779: PPUSH
21780: LD_INT 1
21782: PPUSH
21783: LD_INT 10
21785: PPUSH
21786: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21790: LD_INT 99
21792: PPUSH
21793: LD_INT 83
21795: PPUSH
21796: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21800: LD_VAR 0 11
21804: PPUSH
21805: LD_STRING D6-Sol3-2
21807: PPUSH
21808: CALL_OW 88
// async ;
21812: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21813: LD_EXP 55
21817: PPUSH
21818: LD_STRING D6-Pow-2
21820: PPUSH
21821: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21825: LD_VAR 0 3
21829: PUSH
21830: LD_INT 1
21832: ARRAY
21833: PPUSH
21834: LD_VAR 0 9
21838: PPUSH
21839: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21843: LD_VAR 0 3
21847: PUSH
21848: LD_INT 2
21850: ARRAY
21851: PPUSH
21852: LD_INT 22
21854: PUSH
21855: LD_INT 4
21857: PUSH
21858: EMPTY
21859: LIST
21860: LIST
21861: PUSH
21862: LD_INT 21
21864: PUSH
21865: LD_INT 3
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PPUSH
21876: CALL_OW 69
21880: PPUSH
21881: LD_VAR 0 3
21885: PUSH
21886: LD_INT 2
21888: ARRAY
21889: PPUSH
21890: CALL_OW 74
21894: PPUSH
21895: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21899: LD_EXP 55
21903: PPUSH
21904: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21908: LD_INT 99
21910: PPUSH
21911: LD_INT 83
21913: PPUSH
21914: LD_INT 1
21916: PPUSH
21917: CALL_OW 331
// repeat wait ( 4 ) ;
21921: LD_INT 4
21923: PPUSH
21924: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21928: LD_VAR 0 3
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PPUSH
21937: CALL_OW 256
21941: PUSH
21942: LD_INT 1000
21944: LESS
21945: IFFALSE 21963
// SetLives ( tmp [ 1 ] , 1000 ) ;
21947: LD_VAR 0 3
21951: PUSH
21952: LD_INT 1
21954: ARRAY
21955: PPUSH
21956: LD_INT 1000
21958: PPUSH
21959: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21963: LD_INT 22
21965: PUSH
21966: LD_INT 4
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: PUSH
21973: LD_INT 30
21975: PUSH
21976: LD_INT 3
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PUSH
21983: EMPTY
21984: LIST
21985: LIST
21986: PPUSH
21987: CALL_OW 69
21991: PUSH
21992: LD_INT 0
21994: EQUAL
21995: IFFALSE 21921
// sync ;
21997: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21998: LD_EXP 55
22002: PPUSH
22003: LD_STRING D6a-Pow-1
22005: PPUSH
22006: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22010: LD_VAR 0 11
22014: PPUSH
22015: LD_STRING D6a-Sol3-1
22017: PPUSH
22018: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22022: LD_EXP 55
22026: PPUSH
22027: LD_STRING D6a-Pow-2
22029: PPUSH
22030: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22034: LD_VAR 0 11
22038: PPUSH
22039: LD_STRING D6a-Sol3-2
22041: PPUSH
22042: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22046: LD_EXP 55
22050: PPUSH
22051: LD_STRING D6a-Pow-3
22053: PPUSH
22054: CALL_OW 88
// powellCenterCameraMode := true ;
22058: LD_ADDR_EXP 20
22062: PUSH
22063: LD_INT 1
22065: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22066: LD_ADDR_VAR 0 1
22070: PUSH
22071: LD_INT 22
22073: PUSH
22074: LD_INT 8
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: PUSH
22081: LD_INT 25
22083: PUSH
22084: LD_INT 2
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PPUSH
22095: CALL_OW 69
22099: PUSH
22100: FOR_IN
22101: IFFALSE 22156
// begin SetTag ( i , 1 ) ;
22103: LD_VAR 0 1
22107: PPUSH
22108: LD_INT 1
22110: PPUSH
22111: CALL_OW 109
// ComExitBuilding ( i ) ;
22115: LD_VAR 0 1
22119: PPUSH
22120: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22124: LD_VAR 0 1
22128: PPUSH
22129: LD_INT 35
22131: PPUSH
22132: LD_INT 6
22134: PPUSH
22135: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22139: LD_VAR 0 1
22143: PPUSH
22144: LD_INT 53
22146: PPUSH
22147: LD_INT 4
22149: PPUSH
22150: CALL_OW 171
// end ;
22154: GO 22100
22156: POP
22157: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22158: LD_ADDR_VAR 0 3
22162: PUSH
22163: LD_INT 22
22165: PUSH
22166: LD_INT 4
22168: PUSH
22169: EMPTY
22170: LIST
22171: LIST
22172: PUSH
22173: LD_INT 21
22175: PUSH
22176: LD_INT 2
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: PUSH
22183: LD_INT 3
22185: PUSH
22186: LD_INT 34
22188: PUSH
22189: LD_INT 12
22191: PUSH
22192: EMPTY
22193: LIST
22194: LIST
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: PUSH
22200: EMPTY
22201: LIST
22202: LIST
22203: LIST
22204: PPUSH
22205: CALL_OW 69
22209: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22210: LD_EXP 55
22214: PPUSH
22215: LD_VAR 0 3
22219: PPUSH
22220: LD_EXP 55
22224: PPUSH
22225: CALL_OW 74
22229: PPUSH
22230: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22234: LD_EXP 55
22238: PPUSH
22239: LD_INT 100
22241: PPUSH
22242: LD_INT 88
22244: PPUSH
22245: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22249: LD_EXP 55
22253: PPUSH
22254: LD_INT 100
22256: PPUSH
22257: LD_INT 75
22259: PPUSH
22260: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22264: LD_EXP 55
22268: PPUSH
22269: LD_INT 88
22271: PPUSH
22272: LD_INT 53
22274: PPUSH
22275: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22279: LD_INT 8
22281: PPUSH
22282: LD_EXP 55
22286: PPUSH
22287: CALL_OW 471
// repeat wait ( 3 ) ;
22291: LD_INT 3
22293: PPUSH
22294: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22298: LD_INT 22
22300: PUSH
22301: LD_INT 4
22303: PUSH
22304: EMPTY
22305: LIST
22306: LIST
22307: PUSH
22308: LD_INT 92
22310: PUSH
22311: LD_INT 100
22313: PUSH
22314: LD_INT 75
22316: PUSH
22317: LD_INT 6
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: LIST
22324: LIST
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL_OW 69
22334: IFFALSE 22291
// async ;
22336: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22337: LD_EXP 55
22341: PPUSH
22342: LD_STRING D6b-Pow-1
22344: PPUSH
22345: CALL_OW 88
// repeat wait ( 3 ) ;
22349: LD_INT 3
22351: PPUSH
22352: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22356: LD_EXP 55
22360: PPUSH
22361: CALL_OW 310
22365: PPUSH
22366: CALL_OW 256
22370: PUSH
22371: LD_INT 1000
22373: LESS
22374: IFFALSE 22393
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22376: LD_EXP 55
22380: PPUSH
22381: CALL_OW 310
22385: PPUSH
22386: LD_INT 1000
22388: PPUSH
22389: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22393: LD_EXP 55
22397: PPUSH
22398: CALL_OW 256
22402: PUSH
22403: LD_INT 1000
22405: LESS
22406: IFFALSE 22420
// SetLives ( Powell , 1000 ) ;
22408: LD_EXP 55
22412: PPUSH
22413: LD_INT 1000
22415: PPUSH
22416: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22420: LD_EXP 55
22424: PPUSH
22425: LD_EXP 60
22429: PPUSH
22430: CALL_OW 296
22434: PUSH
22435: LD_INT 5
22437: LESS
22438: PUSH
22439: LD_EXP 55
22443: PPUSH
22444: CALL_OW 310
22448: PPUSH
22449: LD_EXP 60
22453: PPUSH
22454: CALL_OW 296
22458: PUSH
22459: LD_INT 5
22461: LESS
22462: OR
22463: IFFALSE 22482
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22465: LD_EXP 55
22469: PPUSH
22470: CALL_OW 310
22474: PPUSH
22475: LD_INT 100
22477: PPUSH
22478: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22482: LD_EXP 55
22486: PPUSH
22487: CALL_OW 310
22491: NOT
22492: IFFALSE 22349
// game_speed := 4 ;
22494: LD_ADDR_OWVAR 65
22498: PUSH
22499: LD_INT 4
22501: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22502: LD_EXP 55
22506: PPUSH
22507: LD_STRING D6b-Pow-1a
22509: PPUSH
22510: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22514: LD_EXP 55
22518: PPUSH
22519: LD_EXP 60
22523: PPUSH
22524: CALL_OW 180
// sync ;
22528: SYNC
// repeat wait ( 0 0$1 ) ;
22529: LD_INT 35
22531: PPUSH
22532: CALL_OW 67
// until IsInUnit ( Powell ) ;
22536: LD_EXP 55
22540: PPUSH
22541: CALL_OW 310
22545: IFFALSE 22529
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22547: LD_INT 8
22549: PPUSH
22550: LD_EXP 55
22554: PPUSH
22555: CALL_OW 310
22559: PPUSH
22560: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22564: LD_EXP 55
22568: PPUSH
22569: LD_INT 91
22571: PPUSH
22572: LD_INT 44
22574: PPUSH
22575: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22579: LD_EXP 55
22583: PPUSH
22584: LD_INT 96
22586: PPUSH
22587: LD_INT 44
22589: PPUSH
22590: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22594: LD_EXP 55
22598: PPUSH
22599: LD_INT 96
22601: PPUSH
22602: LD_INT 41
22604: PPUSH
22605: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22609: LD_EXP 55
22613: PPUSH
22614: LD_INT 92
22616: PPUSH
22617: LD_INT 39
22619: PPUSH
22620: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22624: LD_EXP 55
22628: PPUSH
22629: LD_INT 88
22631: PPUSH
22632: LD_INT 41
22634: PPUSH
22635: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22639: LD_EXP 55
22643: PPUSH
22644: LD_INT 91
22646: PPUSH
22647: LD_INT 44
22649: PPUSH
22650: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22654: LD_EXP 55
22658: PPUSH
22659: LD_INT 96
22661: PPUSH
22662: LD_INT 44
22664: PPUSH
22665: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22669: LD_EXP 55
22673: PPUSH
22674: LD_INT 96
22676: PPUSH
22677: LD_INT 41
22679: PPUSH
22680: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22684: LD_EXP 55
22688: PPUSH
22689: LD_INT 92
22691: PPUSH
22692: LD_INT 39
22694: PPUSH
22695: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22699: LD_EXP 55
22703: PPUSH
22704: LD_INT 88
22706: PPUSH
22707: LD_INT 41
22709: PPUSH
22710: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22714: LD_EXP 55
22718: PPUSH
22719: LD_INT 91
22721: PPUSH
22722: LD_INT 44
22724: PPUSH
22725: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22729: LD_EXP 55
22733: PPUSH
22734: LD_INT 93
22736: PPUSH
22737: LD_INT 39
22739: PPUSH
22740: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22744: LD_EXP 55
22748: PPUSH
22749: LD_INT 93
22751: PPUSH
22752: LD_INT 36
22754: PPUSH
22755: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22759: LD_INT 122
22761: PPUSH
22762: CALL_OW 67
// game_speed := 4 ;
22766: LD_ADDR_OWVAR 65
22770: PUSH
22771: LD_INT 4
22773: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22774: LD_EXP 55
22778: PPUSH
22779: LD_STRING D6b-Pow-1b
22781: PPUSH
22782: CALL_OW 88
// tmp := [ ] ;
22786: LD_ADDR_VAR 0 3
22790: PUSH
22791: EMPTY
22792: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22793: LD_ADDR_VAR 0 5
22797: PUSH
22798: LD_INT 78
22800: PUSH
22801: LD_INT 47
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: PUSH
22808: LD_INT 106
22810: PUSH
22811: LD_INT 53
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22822: LD_ADDR_VAR 0 1
22826: PUSH
22827: LD_INT 22
22829: PUSH
22830: LD_INT 8
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: PUSH
22837: LD_INT 21
22839: PUSH
22840: LD_INT 3
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 92
22849: PUSH
22850: LD_INT 90
22852: PUSH
22853: LD_INT 52
22855: PUSH
22856: LD_INT 12
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 69
22874: PUSH
22875: FOR_IN
22876: IFFALSE 22901
// tmp := tmp ^ UnitsInside ( i ) ;
22878: LD_ADDR_VAR 0 3
22882: PUSH
22883: LD_VAR 0 3
22887: PUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: CALL_OW 313
22897: ADD
22898: ST_TO_ADDR
22899: GO 22875
22901: POP
22902: POP
// for i in tmp do
22903: LD_ADDR_VAR 0 1
22907: PUSH
22908: LD_VAR 0 3
22912: PUSH
22913: FOR_IN
22914: IFFALSE 23076
// begin dist := 9999 ;
22916: LD_ADDR_VAR 0 8
22920: PUSH
22921: LD_INT 9999
22923: ST_TO_ADDR
// _xy := [ ] ;
22924: LD_ADDR_VAR 0 7
22928: PUSH
22929: EMPTY
22930: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22931: LD_VAR 0 1
22935: PPUSH
22936: LD_INT 1
22938: PPUSH
22939: CALL_OW 109
// ComExitBuilding ( i ) ;
22943: LD_VAR 0 1
22947: PPUSH
22948: CALL_OW 122
// for j in xy do
22952: LD_ADDR_VAR 0 2
22956: PUSH
22957: LD_VAR 0 5
22961: PUSH
22962: FOR_IN
22963: IFFALSE 23045
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22965: LD_VAR 0 1
22969: PPUSH
22970: LD_VAR 0 2
22974: PUSH
22975: LD_INT 1
22977: ARRAY
22978: PPUSH
22979: LD_VAR 0 2
22983: PUSH
22984: LD_INT 2
22986: ARRAY
22987: PPUSH
22988: CALL_OW 297
22992: PUSH
22993: LD_VAR 0 8
22997: LESS
22998: IFFALSE 23043
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23000: LD_ADDR_VAR 0 8
23004: PUSH
23005: LD_VAR 0 1
23009: PPUSH
23010: LD_VAR 0 2
23014: PUSH
23015: LD_INT 1
23017: ARRAY
23018: PPUSH
23019: LD_VAR 0 2
23023: PUSH
23024: LD_INT 2
23026: ARRAY
23027: PPUSH
23028: CALL_OW 297
23032: ST_TO_ADDR
// _xy := j ;
23033: LD_ADDR_VAR 0 7
23037: PUSH
23038: LD_VAR 0 2
23042: ST_TO_ADDR
// end ;
23043: GO 22962
23045: POP
23046: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23047: LD_VAR 0 1
23051: PPUSH
23052: LD_VAR 0 7
23056: PUSH
23057: LD_INT 1
23059: ARRAY
23060: PPUSH
23061: LD_VAR 0 7
23065: PUSH
23066: LD_INT 2
23068: ARRAY
23069: PPUSH
23070: CALL_OW 171
// end ;
23074: GO 22913
23076: POP
23077: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23078: LD_ADDR_VAR 0 4
23082: PUSH
23083: LD_VAR 0 3
23087: PPUSH
23088: LD_INT 26
23090: PUSH
23091: LD_INT 1
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: PUSH
23098: LD_INT 25
23100: PUSH
23101: LD_INT 1
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: PPUSH
23112: CALL_OW 72
23116: ST_TO_ADDR
// if tmp2 < 2 then
23117: LD_VAR 0 4
23121: PUSH
23122: LD_INT 2
23124: LESS
23125: IFFALSE 23194
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23127: LD_ADDR_VAR 0 4
23131: PUSH
23132: LD_INT 22
23134: PUSH
23135: LD_INT 8
23137: PUSH
23138: EMPTY
23139: LIST
23140: LIST
23141: PUSH
23142: LD_INT 26
23144: PUSH
23145: LD_INT 1
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: PUSH
23152: LD_INT 3
23154: PUSH
23155: LD_INT 25
23157: PUSH
23158: LD_INT 15
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: LIST
23173: PPUSH
23174: CALL_OW 69
23178: PUSH
23179: LD_EXP 57
23183: PUSH
23184: LD_EXP 58
23188: PUSH
23189: EMPTY
23190: LIST
23191: LIST
23192: DIFF
23193: ST_TO_ADDR
// if tmp2 then
23194: LD_VAR 0 4
23198: IFFALSE 23216
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23200: LD_VAR 0 4
23204: PUSH
23205: LD_INT 1
23207: ARRAY
23208: PPUSH
23209: LD_STRING D6b-ArSol1-1
23211: PPUSH
23212: CALL_OW 88
// async ;
23216: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23217: LD_EXP 55
23221: PPUSH
23222: LD_STRING D6b-Pow-2
23224: PPUSH
23225: CALL_OW 88
// wait ( 0 0$1 ) ;
23229: LD_INT 35
23231: PPUSH
23232: CALL_OW 67
// if tmp2 > 1 then
23236: LD_VAR 0 4
23240: PUSH
23241: LD_INT 1
23243: GREATER
23244: IFFALSE 23262
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23246: LD_VAR 0 4
23250: PUSH
23251: LD_INT 2
23253: ARRAY
23254: PPUSH
23255: LD_STRING D6b-ArSol2-1
23257: PPUSH
23258: CALL_OW 88
// sync ;
23262: SYNC
// repeat wait ( 5 ) ;
23263: LD_INT 5
23265: PPUSH
23266: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23270: LD_INT 93
23272: PPUSH
23273: LD_INT 36
23275: PPUSH
23276: CALL_OW 428
23280: PPUSH
23281: CALL_OW 255
23285: PUSH
23286: LD_INT 4
23288: EQUAL
23289: IFFALSE 23263
// DialogueOn ;
23291: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23295: LD_INT 10
23297: PPUSH
23298: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23302: LD_EXP 55
23306: PPUSH
23307: LD_STRING D6b-Pow-2a
23309: PPUSH
23310: CALL_OW 88
// DialogueOff ;
23314: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23318: LD_EXP 55
23322: PPUSH
23323: CALL_OW 310
23327: PPUSH
23328: LD_INT 332
23330: PPUSH
23331: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23335: LD_INT 93
23337: PPUSH
23338: LD_INT 35
23340: PPUSH
23341: LD_INT 1
23343: PPUSH
23344: LD_INT 6
23346: NEG
23347: PPUSH
23348: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23352: LD_INT 35
23354: PPUSH
23355: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23359: LD_INT 332
23361: PPUSH
23362: CALL_OW 256
23366: PUSH
23367: LD_INT 1000
23369: LESS
23370: PUSH
23371: LD_INT 332
23373: PPUSH
23374: CALL_OW 300
23378: AND
23379: IFFALSE 23391
// SetLives ( kozlov_fac , 0 ) ;
23381: LD_INT 332
23383: PPUSH
23384: LD_INT 0
23386: PPUSH
23387: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23391: LD_INT 332
23393: PPUSH
23394: CALL_OW 301
23398: PUSH
23399: LD_EXP 55
23403: PPUSH
23404: CALL_OW 301
23408: OR
23409: IFFALSE 23352
// game_speed := 4 ;
23411: LD_ADDR_OWVAR 65
23415: PUSH
23416: LD_INT 4
23418: ST_TO_ADDR
// powellCenterCameraMode := false ;
23419: LD_ADDR_EXP 20
23423: PUSH
23424: LD_INT 0
23426: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23427: LD_ADDR_VAR 0 1
23431: PUSH
23432: LD_VAR 0 3
23436: PUSH
23437: LD_INT 22
23439: PUSH
23440: LD_INT 8
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 25
23449: PUSH
23450: LD_INT 2
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: PPUSH
23461: CALL_OW 69
23465: UNION
23466: PUSH
23467: FOR_IN
23468: IFFALSE 23484
// SetTag ( i , 0 ) ;
23470: LD_VAR 0 1
23474: PPUSH
23475: LD_INT 0
23477: PPUSH
23478: CALL_OW 109
23482: GO 23467
23484: POP
23485: POP
// wait ( 0 0$3 ) ;
23486: LD_INT 105
23488: PPUSH
23489: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23493: LD_INT 93
23495: PPUSH
23496: LD_INT 35
23498: PPUSH
23499: LD_INT 1
23501: PPUSH
23502: CALL_OW 331
// DialogueOn ;
23506: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23510: LD_VAR 0 11
23514: PPUSH
23515: LD_STRING D6c-Sol3-1
23517: PPUSH
23518: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23522: LD_INT 10
23524: PPUSH
23525: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23529: LD_EXP 36
23533: PPUSH
23534: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23538: LD_EXP 36
23542: PPUSH
23543: LD_STRING D6c-JMM-1
23545: PPUSH
23546: CALL_OW 88
// if Cyrus then
23550: LD_EXP 42
23554: IFFALSE 23568
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23556: LD_EXP 42
23560: PPUSH
23561: LD_STRING D6c-Cyrus-1
23563: PPUSH
23564: CALL_OW 88
// if Bobby then
23568: LD_EXP 41
23572: IFFALSE 23586
// Say ( Bobby , D6c-Bobby-1 ) ;
23574: LD_EXP 41
23578: PPUSH
23579: LD_STRING D6c-Bobby-1
23581: PPUSH
23582: CALL_OW 88
// if Cornel then
23586: LD_EXP 47
23590: IFFALSE 23604
// Say ( Cornel , D6c-Corn-1 ) ;
23592: LD_EXP 47
23596: PPUSH
23597: LD_STRING D6c-Corn-1
23599: PPUSH
23600: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23604: LD_ADDR_VAR 0 4
23608: PUSH
23609: LD_INT 2
23611: PUSH
23612: LD_INT 22
23614: PUSH
23615: LD_INT 1
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 22
23624: PUSH
23625: LD_INT 4
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: PUSH
23637: LD_INT 26
23639: PUSH
23640: LD_INT 1
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 3
23649: PUSH
23650: LD_INT 25
23652: PUSH
23653: LD_INT 16
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 25
23662: PUSH
23663: LD_INT 12
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: LIST
23679: PPUSH
23680: CALL_OW 69
23684: PUSH
23685: LD_VAR 0 11
23689: PUSH
23690: LD_EXP 36
23694: UNION
23695: PUSH
23696: LD_EXP 56
23700: UNION
23701: PUSH
23702: EMPTY
23703: LIST
23704: DIFF
23705: ST_TO_ADDR
// if tmp2 then
23706: LD_VAR 0 4
23710: IFFALSE 23728
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23712: LD_VAR 0 4
23716: PUSH
23717: LD_INT 1
23719: ARRAY
23720: PPUSH
23721: LD_STRING D6c-Sol1-1
23723: PPUSH
23724: CALL_OW 88
// if Lisa then
23728: LD_EXP 39
23732: IFFALSE 23746
// Say ( Lisa , D6c-Lisa-1 ) ;
23734: LD_EXP 39
23738: PPUSH
23739: LD_STRING D6c-Lisa-1
23741: PPUSH
23742: CALL_OW 88
// if Gary then
23746: LD_EXP 48
23750: IFFALSE 23764
// Say ( Gary , D6c-Gary-1 ) ;
23752: LD_EXP 48
23756: PPUSH
23757: LD_STRING D6c-Gary-1
23759: PPUSH
23760: CALL_OW 88
// if Donaldson then
23764: LD_EXP 40
23768: IFFALSE 23782
// Say ( Donaldson , D6c-Don-1 ) ;
23770: LD_EXP 40
23774: PPUSH
23775: LD_STRING D6c-Don-1
23777: PPUSH
23778: CALL_OW 88
// if tmp2 > 1 then
23782: LD_VAR 0 4
23786: PUSH
23787: LD_INT 1
23789: GREATER
23790: IFFALSE 23808
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23792: LD_VAR 0 4
23796: PUSH
23797: LD_INT 2
23799: ARRAY
23800: PPUSH
23801: LD_STRING D6c-Sol2-1
23803: PPUSH
23804: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23808: LD_VAR 0 11
23812: PPUSH
23813: LD_STRING D6c-Sol3-2
23815: PPUSH
23816: CALL_OW 88
// dwait ( 0 0$1 ) ;
23820: LD_INT 35
23822: PPUSH
23823: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23827: LD_EXP 36
23831: PPUSH
23832: LD_STRING D6c-JMM-2
23834: PPUSH
23835: CALL_OW 88
// DialogueOff ;
23839: CALL_OW 7
// Video ( false ) ;
23843: LD_INT 0
23845: PPUSH
23846: CALL 106102 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23850: LD_INT 22
23852: PUSH
23853: LD_INT 4
23855: PUSH
23856: EMPTY
23857: LIST
23858: LIST
23859: PPUSH
23860: CALL_OW 69
23864: PPUSH
23865: LD_INT 1
23867: PPUSH
23868: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23872: LD_INT 4
23874: PPUSH
23875: LD_INT 4
23877: PPUSH
23878: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23882: LD_ADDR_VAR 0 1
23886: PUSH
23887: LD_INT 4
23889: PPUSH
23890: LD_INT 1
23892: PPUSH
23893: LD_INT 2
23895: PPUSH
23896: CALL 63671 0 3
23900: PUSH
23901: FOR_IN
23902: IFFALSE 23939
// if GetTech ( i , 1 ) <> state_researched then
23904: LD_VAR 0 1
23908: PPUSH
23909: LD_INT 1
23911: PPUSH
23912: CALL_OW 321
23916: PUSH
23917: LD_INT 2
23919: NONEQUAL
23920: IFFALSE 23937
// SetTech ( i , 1 , state_researched ) ;
23922: LD_VAR 0 1
23926: PPUSH
23927: LD_INT 1
23929: PPUSH
23930: LD_INT 2
23932: PPUSH
23933: CALL_OW 322
23937: GO 23901
23939: POP
23940: POP
// missionStage := 6 ;
23941: LD_ADDR_EXP 15
23945: PUSH
23946: LD_INT 6
23948: ST_TO_ADDR
// activeAttacks := true ;
23949: LD_ADDR_EXP 16
23953: PUSH
23954: LD_INT 1
23956: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23957: LD_STRING M2
23959: PPUSH
23960: CALL_OW 337
// SaveForQuickRestart ;
23964: CALL_OW 22
// wait ( 0 0$40 ) ;
23968: LD_INT 1400
23970: PPUSH
23971: CALL_OW 67
// DialogueOn ;
23975: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23979: LD_EXP 59
23983: PPUSH
23984: LD_STRING D7-Friend-1
23986: PPUSH
23987: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23991: LD_EXP 36
23995: PPUSH
23996: LD_STRING D7-JMM-1
23998: PPUSH
23999: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24003: LD_EXP 59
24007: PPUSH
24008: LD_STRING D7-Friend-2
24010: PPUSH
24011: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24015: LD_EXP 36
24019: PPUSH
24020: LD_STRING D7-JMM-2
24022: PPUSH
24023: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24027: LD_EXP 59
24031: PPUSH
24032: LD_STRING D7-Friend-3
24034: PPUSH
24035: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24039: LD_EXP 36
24043: PPUSH
24044: LD_STRING D7-JMM-3
24046: PPUSH
24047: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24051: LD_EXP 59
24055: PPUSH
24056: LD_STRING D7-Friend-4
24058: PPUSH
24059: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24063: LD_EXP 36
24067: PPUSH
24068: LD_STRING D7-JMM-4
24070: PPUSH
24071: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24075: LD_EXP 59
24079: PPUSH
24080: LD_STRING D7-Friend-5
24082: PPUSH
24083: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24087: LD_EXP 36
24091: PPUSH
24092: LD_STRING D7-JMM-5
24094: PPUSH
24095: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24099: LD_EXP 59
24103: PPUSH
24104: LD_STRING D7-Friend-6
24106: PPUSH
24107: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24111: LD_EXP 36
24115: PPUSH
24116: LD_STRING D7-JMM-6
24118: PPUSH
24119: CALL_OW 88
// DialogueOff ;
24123: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24127: LD_STRING Mlegion
24129: PPUSH
24130: CALL_OW 337
// RebuildKozlovFactory ;
24134: CALL 4773 0 0
// end ;
24138: PPOPN 13
24140: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24141: LD_EXP 20
24145: PUSH
24146: LD_EXP 55
24150: PPUSH
24151: CALL_OW 300
24155: AND
24156: IFFALSE 24198
24158: GO 24160
24160: DISABLE
// begin enable ;
24161: ENABLE
// if IsInUnit ( Powell ) then
24162: LD_EXP 55
24166: PPUSH
24167: CALL_OW 310
24171: IFFALSE 24189
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24173: LD_EXP 55
24177: PPUSH
24178: CALL_OW 310
24182: PPUSH
24183: CALL_OW 85
24187: GO 24198
// CenterOnUnits ( Powell ) ;
24189: LD_EXP 55
24193: PPUSH
24194: CALL_OW 85
// end ;
24198: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24199: LD_INT 22
24201: PUSH
24202: LD_INT 8
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 34
24211: PUSH
24212: LD_INT 48
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PUSH
24219: EMPTY
24220: LIST
24221: LIST
24222: PPUSH
24223: CALL_OW 69
24227: IFFALSE 24490
24229: GO 24231
24231: DISABLE
24232: LD_INT 0
24234: PPUSH
24235: PPUSH
// begin if missionStage < 9 then
24236: LD_EXP 15
24240: PUSH
24241: LD_INT 9
24243: LESS
24244: IFFALSE 24254
// missionStage := 9 ;
24246: LD_ADDR_EXP 15
24250: PUSH
24251: LD_INT 9
24253: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24254: LD_ADDR_VAR 0 1
24258: PUSH
24259: LD_INT 22
24261: PUSH
24262: LD_INT 8
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_INT 34
24271: PUSH
24272: LD_INT 48
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: PUSH
24279: EMPTY
24280: LIST
24281: LIST
24282: PPUSH
24283: CALL_OW 69
24287: PUSH
24288: LD_INT 1
24290: ARRAY
24291: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24292: LD_INT 175
24294: PPUSH
24295: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24299: LD_EXP 12
24303: PUSH
24304: LD_EXP 3
24308: PUSH
24309: LD_INT 0
24311: PUSH
24312: LD_INT 2
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: IN
24319: OR
24320: IFFALSE 24343
// target := [ 68 , 108 , 1 ] else
24322: LD_ADDR_VAR 0 2
24326: PUSH
24327: LD_INT 68
24329: PUSH
24330: LD_INT 108
24332: PUSH
24333: LD_INT 1
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: ST_TO_ADDR
24341: GO 24362
// target := [ 181 , 88 , 2 ] ;
24343: LD_ADDR_VAR 0 2
24347: PUSH
24348: LD_INT 181
24350: PUSH
24351: LD_INT 88
24353: PUSH
24354: LD_INT 2
24356: PUSH
24357: EMPTY
24358: LIST
24359: LIST
24360: LIST
24361: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24362: LD_VAR 0 1
24366: PPUSH
24367: LD_VAR 0 2
24371: PUSH
24372: LD_INT 1
24374: ARRAY
24375: PPUSH
24376: LD_VAR 0 2
24380: PUSH
24381: LD_INT 2
24383: ARRAY
24384: PPUSH
24385: CALL_OW 176
// if target [ 3 ] = 1 then
24389: LD_VAR 0 2
24393: PUSH
24394: LD_INT 3
24396: ARRAY
24397: PUSH
24398: LD_INT 1
24400: EQUAL
24401: IFFALSE 24417
// SayRadio ( Kurt , D12-Kurt-1 ) else
24403: LD_EXP 57
24407: PPUSH
24408: LD_STRING D12-Kurt-1
24410: PPUSH
24411: CALL_OW 94
24415: GO 24441
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24417: LD_EXP 57
24421: PPUSH
24422: LD_STRING D12a-Kurt-1
24424: PPUSH
24425: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24429: LD_EXP 71
24433: PPUSH
24434: LD_STRING D12a-Roth-1
24436: PPUSH
24437: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24441: LD_INT 350
24443: PPUSH
24444: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24448: LD_VAR 0 1
24452: PPUSH
24453: LD_INT 22
24455: PUSH
24456: LD_INT 8
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PUSH
24463: LD_INT 30
24465: PUSH
24466: LD_INT 3
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PPUSH
24477: CALL_OW 69
24481: PUSH
24482: LD_INT 1
24484: ARRAY
24485: PPUSH
24486: CALL_OW 228
// end ;
24490: PPOPN 2
24492: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24493: LD_INT 22
24495: PUSH
24496: LD_INT 8
24498: PUSH
24499: EMPTY
24500: LIST
24501: LIST
24502: PUSH
24503: LD_INT 21
24505: PUSH
24506: LD_INT 1
24508: PUSH
24509: EMPTY
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 23
24515: PUSH
24516: LD_INT 2
24518: PUSH
24519: EMPTY
24520: LIST
24521: LIST
24522: PUSH
24523: EMPTY
24524: LIST
24525: LIST
24526: LIST
24527: PPUSH
24528: CALL_OW 69
24532: PUSH
24533: LD_INT 8
24535: PUSH
24536: LD_INT 7
24538: PUSH
24539: LD_INT 6
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: LIST
24546: PUSH
24547: LD_OWVAR 67
24551: ARRAY
24552: LESSEQUAL
24553: PUSH
24554: LD_INT 22
24556: PUSH
24557: LD_INT 8
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: LD_INT 34
24566: PUSH
24567: LD_INT 48
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PPUSH
24578: CALL_OW 69
24582: NOT
24583: AND
24584: PUSH
24585: LD_EXP 57
24589: PPUSH
24590: CALL_OW 302
24594: AND
24595: IFFALSE 24912
24597: GO 24599
24599: DISABLE
// begin DialogueOn ;
24600: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24604: LD_EXP 36
24608: PPUSH
24609: LD_STRING D13-JMM-1
24611: PPUSH
24612: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24616: LD_EXP 57
24620: PPUSH
24621: LD_STRING D13-Kurt-1
24623: PPUSH
24624: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24628: LD_EXP 36
24632: PPUSH
24633: LD_STRING D13-JMM-2
24635: PPUSH
24636: CALL_OW 88
// if FakeInfo then
24640: LD_EXP 12
24644: IFFALSE 24664
// begin Say ( Kurt , D13-Kurt-2 ) ;
24646: LD_EXP 57
24650: PPUSH
24651: LD_STRING D13-Kurt-2
24653: PPUSH
24654: CALL_OW 88
// DialogueOff ;
24658: CALL_OW 7
// exit ;
24662: GO 24912
// end ; if not KurtStatus then
24664: LD_EXP 3
24668: NOT
24669: IFFALSE 24685
// Say ( Kurt , D13-Kurt-2b ) else
24671: LD_EXP 57
24675: PPUSH
24676: LD_STRING D13-Kurt-2b
24678: PPUSH
24679: CALL_OW 88
24683: GO 24697
// Say ( Kurt , D13-Kurt-2a ) ;
24685: LD_EXP 57
24689: PPUSH
24690: LD_STRING D13-Kurt-2a
24692: PPUSH
24693: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24697: LD_EXP 57
24701: PPUSH
24702: LD_STRING D13-Kurt-2a
24704: PPUSH
24705: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24709: LD_EXP 36
24713: PPUSH
24714: LD_STRING D13-JMM-3
24716: PPUSH
24717: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24721: LD_EXP 57
24725: PPUSH
24726: LD_STRING D13-Kurt-3
24728: PPUSH
24729: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24733: LD_EXP 36
24737: PPUSH
24738: LD_STRING D13-JMM-4
24740: PPUSH
24741: CALL_OW 88
// DialogueOff ;
24745: CALL_OW 7
// MC_Kill ( 3 ) ;
24749: LD_INT 3
24751: PPUSH
24752: CALL 34050 0 1
// KillUnit ( Kozlov ) ;
24756: LD_EXP 58
24760: PPUSH
24761: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24765: LD_INT 22
24767: PUSH
24768: LD_INT 8
24770: PUSH
24771: EMPTY
24772: LIST
24773: LIST
24774: PUSH
24775: LD_INT 21
24777: PUSH
24778: LD_INT 3
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 23
24787: PUSH
24788: LD_INT 3
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 30
24797: PUSH
24798: LD_INT 3
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: LIST
24810: PPUSH
24811: CALL_OW 69
24815: PUSH
24816: LD_INT 1
24818: ARRAY
24819: PPUSH
24820: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24824: LD_INT 8
24826: PPUSH
24827: LD_INT 1
24829: PPUSH
24830: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24834: LD_INT 22
24836: PUSH
24837: LD_INT 8
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 69
24848: PPUSH
24849: LD_INT 1
24851: PPUSH
24852: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24856: LD_INT 8
24858: PPUSH
24859: LD_INT 1
24861: PPUSH
24862: LD_INT 1
24864: PPUSH
24865: LD_INT 1
24867: PPUSH
24868: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24872: LD_EXP 59
24876: PPUSH
24877: LD_INT 37
24879: PPUSH
24880: LD_INT 1
24882: PPUSH
24883: LD_INT 0
24885: PPUSH
24886: CALL_OW 48
// wait ( 0 0$1 ) ;
24890: LD_INT 35
24892: PPUSH
24893: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24897: LD_EXP 59
24901: PPUSH
24902: LD_INT 60
24904: PPUSH
24905: LD_INT 95
24907: PPUSH
24908: CALL_OW 111
// end ;
24912: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24913: LD_INT 22
24915: PUSH
24916: LD_INT 8
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: PUSH
24923: LD_INT 21
24925: PUSH
24926: LD_INT 1
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PPUSH
24937: CALL_OW 69
24941: PUSH
24942: LD_INT 0
24944: EQUAL
24945: IFFALSE 24965
24947: GO 24949
24949: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24950: LD_STRING MlegionOut
24952: PPUSH
24953: CALL_OW 337
// legionDestroyed := true ;
24957: LD_ADDR_EXP 22
24961: PUSH
24962: LD_INT 1
24964: ST_TO_ADDR
// end ;
24965: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24966: LD_INT 1
24968: PPUSH
24969: LD_EXP 59
24973: PPUSH
24974: CALL_OW 292
24978: IFFALSE 25278
24980: GO 24982
24982: DISABLE
24983: LD_INT 0
24985: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24986: LD_EXP 59
24990: PPUSH
24991: CALL_OW 87
// DialogueOn ;
24995: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24999: LD_EXP 36
25003: PPUSH
25004: LD_STRING D14-JMM-1
25006: PPUSH
25007: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25011: LD_EXP 59
25015: PPUSH
25016: LD_STRING D14-Friend-1
25018: PPUSH
25019: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25023: LD_EXP 36
25027: PPUSH
25028: LD_STRING D14-JMM-2
25030: PPUSH
25031: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25035: LD_EXP 59
25039: PPUSH
25040: LD_STRING D14-Friend-2
25042: PPUSH
25043: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25047: LD_EXP 36
25051: PPUSH
25052: LD_STRING D14-JMM-3
25054: PPUSH
25055: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25059: LD_EXP 59
25063: PPUSH
25064: LD_STRING D14-Friend-3
25066: PPUSH
25067: CALL_OW 88
// DialogueOff ;
25071: CALL_OW 7
// dec = Query ( Q14 ) ;
25075: LD_ADDR_VAR 0 1
25079: PUSH
25080: LD_STRING Q14
25082: PPUSH
25083: CALL_OW 97
25087: ST_TO_ADDR
// if dec = 1 then
25088: LD_VAR 0 1
25092: PUSH
25093: LD_INT 1
25095: EQUAL
25096: IFFALSE 25130
// begin DialogueOn ;
25098: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25102: LD_EXP 36
25106: PPUSH
25107: LD_STRING D14a-JMM-1
25109: PPUSH
25110: CALL_OW 88
// DialogueOff ;
25114: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25118: LD_EXP 59
25122: PPUSH
25123: LD_INT 1
25125: PPUSH
25126: CALL_OW 235
// end ; if dec = 2 then
25130: LD_VAR 0 1
25134: PUSH
25135: LD_INT 2
25137: EQUAL
25138: IFFALSE 25184
// begin DialogueOn ;
25140: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25144: LD_EXP 36
25148: PPUSH
25149: LD_STRING D14b-JMM-1
25151: PPUSH
25152: CALL_OW 88
// DialogueOff ;
25156: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25160: LD_EXP 59
25164: PPUSH
25165: LD_INT 9
25167: PPUSH
25168: LD_INT 2
25170: PPUSH
25171: CALL_OW 111
// AddComHold ( Friend ) ;
25175: LD_EXP 59
25179: PPUSH
25180: CALL_OW 200
// end ; if dec = 3 then
25184: LD_VAR 0 1
25188: PUSH
25189: LD_INT 3
25191: EQUAL
25192: IFFALSE 25278
// begin DialogueOn ;
25194: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25198: LD_EXP 36
25202: PPUSH
25203: LD_STRING D14c-JMM-1
25205: PPUSH
25206: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25210: LD_EXP 59
25214: PPUSH
25215: LD_STRING D14c-Friend-1
25217: PPUSH
25218: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25222: LD_EXP 36
25226: PPUSH
25227: LD_STRING D14c-JMM-2
25229: PPUSH
25230: CALL_OW 88
// DialogueOff ;
25234: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25238: LD_INT 8
25240: PPUSH
25241: LD_INT 1
25243: PPUSH
25244: LD_INT 2
25246: PPUSH
25247: LD_INT 1
25249: PPUSH
25250: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25254: LD_EXP 59
25258: PPUSH
25259: LD_INT 9
25261: PPUSH
25262: LD_INT 2
25264: PPUSH
25265: CALL_OW 111
// AddComHold ( Friend ) ;
25269: LD_EXP 59
25273: PPUSH
25274: CALL_OW 200
// end ; end ;
25278: PPOPN 1
25280: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25281: LD_INT 9
25283: PPUSH
25284: LD_INT 2
25286: PPUSH
25287: CALL_OW 428
25291: PUSH
25292: LD_EXP 59
25296: EQUAL
25297: PUSH
25298: LD_EXP 59
25302: PPUSH
25303: CALL_OW 255
25307: PUSH
25308: LD_INT 8
25310: EQUAL
25311: AND
25312: IFFALSE 25326
25314: GO 25316
25316: DISABLE
// RemoveUnit ( Friend ) ;
25317: LD_EXP 59
25321: PPUSH
25322: CALL_OW 64
25326: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25327: LD_EXP 14
25331: PUSH
25332: LD_INT 31500
25334: GREATEREQUAL
25335: PUSH
25336: LD_EXP 7
25340: AND
25341: PUSH
25342: LD_EXP 2
25346: AND
25347: IFFALSE 25777
25349: GO 25351
25351: DISABLE
25352: LD_INT 0
25354: PPUSH
25355: PPUSH
25356: PPUSH
// begin missionStage := 7 ;
25357: LD_ADDR_EXP 15
25361: PUSH
25362: LD_INT 7
25364: ST_TO_ADDR
// uc_side = 1 ;
25365: LD_ADDR_OWVAR 20
25369: PUSH
25370: LD_INT 1
25372: ST_TO_ADDR
// uc_nation = 1 ;
25373: LD_ADDR_OWVAR 21
25377: PUSH
25378: LD_INT 1
25380: ST_TO_ADDR
// for i = 1 to 5 do
25381: LD_ADDR_VAR 0 1
25385: PUSH
25386: DOUBLE
25387: LD_INT 1
25389: DEC
25390: ST_TO_ADDR
25391: LD_INT 5
25393: PUSH
25394: FOR_TO
25395: IFFALSE 25491
// begin vc_engine = 3 ;
25397: LD_ADDR_OWVAR 39
25401: PUSH
25402: LD_INT 3
25404: ST_TO_ADDR
// vc_control = 3 ;
25405: LD_ADDR_OWVAR 38
25409: PUSH
25410: LD_INT 3
25412: ST_TO_ADDR
// vc_chassis = 3 ;
25413: LD_ADDR_OWVAR 37
25417: PUSH
25418: LD_INT 3
25420: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25421: LD_ADDR_OWVAR 40
25425: PUSH
25426: LD_INT 5
25428: PUSH
25429: LD_INT 9
25431: PUSH
25432: LD_INT 7
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: LIST
25439: PUSH
25440: LD_INT 1
25442: PPUSH
25443: LD_INT 3
25445: PPUSH
25446: CALL_OW 12
25450: ARRAY
25451: ST_TO_ADDR
// veh = CreateVehicle ;
25452: LD_ADDR_VAR 0 2
25456: PUSH
25457: CALL_OW 45
25461: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25462: LD_VAR 0 2
25466: PPUSH
25467: LD_INT 1
25469: PPUSH
25470: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25474: LD_VAR 0 2
25478: PPUSH
25479: LD_INT 19
25481: PPUSH
25482: LD_INT 0
25484: PPUSH
25485: CALL_OW 49
// end ;
25489: GO 25394
25491: POP
25492: POP
// vc_engine = 3 ;
25493: LD_ADDR_OWVAR 39
25497: PUSH
25498: LD_INT 3
25500: ST_TO_ADDR
// vc_control = 1 ;
25501: LD_ADDR_OWVAR 38
25505: PUSH
25506: LD_INT 1
25508: ST_TO_ADDR
// vc_chassis = 3 ;
25509: LD_ADDR_OWVAR 37
25513: PUSH
25514: LD_INT 3
25516: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25517: LD_ADDR_OWVAR 40
25521: PUSH
25522: LD_INT 5
25524: PUSH
25525: LD_INT 9
25527: PUSH
25528: LD_INT 7
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 1
25538: PPUSH
25539: LD_INT 3
25541: PPUSH
25542: CALL_OW 12
25546: ARRAY
25547: ST_TO_ADDR
// vehG = CreateVehicle ;
25548: LD_ADDR_VAR 0 3
25552: PUSH
25553: CALL_OW 45
25557: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25558: LD_VAR 0 3
25562: PPUSH
25563: LD_INT 1
25565: PPUSH
25566: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25570: LD_VAR 0 3
25574: PPUSH
25575: LD_INT 19
25577: PPUSH
25578: LD_INT 0
25580: PPUSH
25581: CALL_OW 49
// if JMMGirl = 1 then
25585: LD_EXP 7
25589: PUSH
25590: LD_INT 1
25592: EQUAL
25593: IFFALSE 25649
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25595: LD_ADDR_EXP 37
25599: PUSH
25600: LD_STRING Joan
25602: PPUSH
25603: LD_INT 1
25605: PPUSH
25606: LD_STRING 14_
25608: PPUSH
25609: CALL 63608 0 3
25613: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25614: LD_EXP 37
25618: PPUSH
25619: LD_VAR 0 3
25623: PPUSH
25624: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25628: LD_VAR 0 3
25632: PPUSH
25633: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25637: LD_EXP 37
25641: PPUSH
25642: LD_STRING D10BW-Joan-1
25644: PPUSH
25645: CALL_OW 94
// end ; if JMMGirl = 2 then
25649: LD_EXP 7
25653: PUSH
25654: LD_INT 2
25656: EQUAL
25657: IFFALSE 25713
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25659: LD_ADDR_EXP 39
25663: PUSH
25664: LD_STRING Lisa
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: LD_STRING 14_
25672: PPUSH
25673: CALL 63608 0 3
25677: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25678: LD_EXP 39
25682: PPUSH
25683: LD_VAR 0 3
25687: PPUSH
25688: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25692: LD_VAR 0 3
25696: PPUSH
25697: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25701: LD_EXP 39
25705: PPUSH
25706: LD_STRING D10BW-Lisa-1
25708: PPUSH
25709: CALL_OW 94
// end ; if JMMGirl = 3 then
25713: LD_EXP 7
25717: PUSH
25718: LD_INT 3
25720: EQUAL
25721: IFFALSE 25777
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25723: LD_ADDR_EXP 51
25727: PUSH
25728: LD_STRING Connie
25730: PPUSH
25731: LD_INT 1
25733: PPUSH
25734: LD_STRING 14_
25736: PPUSH
25737: CALL 63608 0 3
25741: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25742: LD_EXP 51
25746: PPUSH
25747: LD_VAR 0 3
25751: PPUSH
25752: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25756: LD_VAR 0 3
25760: PPUSH
25761: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25765: LD_EXP 39
25769: PPUSH
25770: LD_STRING D10BW-Con-1
25772: PPUSH
25773: CALL_OW 94
// end ; end ;
25777: PPOPN 3
25779: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25780: LD_EXP 14
25784: PUSH
25785: LD_INT 94500
25787: GREATEREQUAL
25788: IFFALSE 26200
25790: GO 25792
25792: DISABLE
25793: LD_INT 0
25795: PPUSH
25796: PPUSH
25797: PPUSH
// begin tmp := PrepareStevensSquad ;
25798: LD_ADDR_VAR 0 3
25802: PUSH
25803: CALL 2147 0 0
25807: ST_TO_ADDR
// if not tmp then
25808: LD_VAR 0 3
25812: NOT
25813: IFFALSE 25817
// exit ;
25815: GO 26200
// uc_side := 1 ;
25817: LD_ADDR_OWVAR 20
25821: PUSH
25822: LD_INT 1
25824: ST_TO_ADDR
// uc_nation := 1 ;
25825: LD_ADDR_OWVAR 21
25829: PUSH
25830: LD_INT 1
25832: ST_TO_ADDR
// for i in tmp do
25833: LD_ADDR_VAR 0 1
25837: PUSH
25838: LD_VAR 0 3
25842: PUSH
25843: FOR_IN
25844: IFFALSE 25941
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25846: LD_INT 3
25848: PPUSH
25849: LD_INT 3
25851: PPUSH
25852: LD_INT 1
25854: PPUSH
25855: LD_INT 5
25857: PUSH
25858: LD_INT 9
25860: PUSH
25861: LD_INT 7
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: LIST
25868: PUSH
25869: LD_INT 1
25871: PPUSH
25872: LD_INT 3
25874: PPUSH
25875: CALL_OW 12
25879: ARRAY
25880: PPUSH
25881: LD_INT 40
25883: PPUSH
25884: CALL 70385 0 5
// veh := CreateVehicle ;
25888: LD_ADDR_VAR 0 2
25892: PUSH
25893: CALL_OW 45
25897: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25898: LD_VAR 0 2
25902: PPUSH
25903: LD_INT 1
25905: PPUSH
25906: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25910: LD_VAR 0 2
25914: PPUSH
25915: LD_INT 19
25917: PPUSH
25918: LD_INT 0
25920: PPUSH
25921: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25925: LD_VAR 0 1
25929: PPUSH
25930: LD_VAR 0 2
25934: PPUSH
25935: CALL_OW 52
// end ;
25939: GO 25843
25941: POP
25942: POP
// missionStage := 8 ;
25943: LD_ADDR_EXP 15
25947: PUSH
25948: LD_INT 8
25950: ST_TO_ADDR
// DialogueOn ;
25951: CALL_OW 6
// if Stevens then
25955: LD_EXP 38
25959: IFFALSE 26073
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25961: LD_EXP 38
25965: PPUSH
25966: CALL_OW 310
25970: PPUSH
25971: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25975: LD_EXP 38
25979: PPUSH
25980: LD_STRING D8-Huck-1
25982: PPUSH
25983: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25987: LD_EXP 36
25991: PPUSH
25992: LD_STRING D8-JMM-1
25994: PPUSH
25995: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25999: LD_EXP 38
26003: PPUSH
26004: LD_STRING D8-Huck-2
26006: PPUSH
26007: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26011: LD_EXP 36
26015: PPUSH
26016: LD_STRING D8-JMM-2
26018: PPUSH
26019: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26023: LD_EXP 38
26027: PPUSH
26028: LD_STRING D8-Huck-3
26030: PPUSH
26031: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26035: LD_EXP 36
26039: PPUSH
26040: LD_STRING D8-JMM-3
26042: PPUSH
26043: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26047: LD_EXP 38
26051: PPUSH
26052: LD_STRING D8-Huck-4
26054: PPUSH
26055: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26059: LD_EXP 36
26063: PPUSH
26064: LD_STRING D8-JMM-4
26066: PPUSH
26067: CALL_OW 88
// end else
26071: GO 26183
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26073: LD_EXP 52
26077: PPUSH
26078: CALL_OW 310
26082: PPUSH
26083: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26087: LD_EXP 52
26091: PPUSH
26092: LD_STRING D8-Huck-1
26094: PPUSH
26095: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26099: LD_EXP 36
26103: PPUSH
26104: LD_STRING D8-JMM-1a
26106: PPUSH
26107: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26111: LD_EXP 52
26115: PPUSH
26116: LD_STRING D8-Huck-2
26118: PPUSH
26119: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26123: LD_EXP 36
26127: PPUSH
26128: LD_STRING D8-JMM-2
26130: PPUSH
26131: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26135: LD_EXP 52
26139: PPUSH
26140: LD_STRING D8-Huck-3
26142: PPUSH
26143: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26147: LD_EXP 36
26151: PPUSH
26152: LD_STRING D8-JMM-3
26154: PPUSH
26155: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26159: LD_EXP 52
26163: PPUSH
26164: LD_STRING D8-Huck-4
26166: PPUSH
26167: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26171: LD_EXP 36
26175: PPUSH
26176: LD_STRING D8-JMM-4
26178: PPUSH
26179: CALL_OW 88
// end ; DialogueOff ;
26183: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26187: LD_INT 25
26189: PPUSH
26190: LD_INT 1
26192: PPUSH
26193: LD_INT 1
26195: PPUSH
26196: CALL_OW 322
// end ;
26200: PPOPN 3
26202: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26203: LD_INT 1
26205: PPUSH
26206: LD_EXP 68
26210: PPUSH
26211: CALL_OW 292
26215: IFFALSE 26466
26217: GO 26219
26219: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26220: LD_EXP 68
26224: PPUSH
26225: CALL_OW 87
// DialogueOn ;
26229: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26233: LD_EXP 36
26237: PPUSH
26238: LD_STRING D10nB-JMM-1
26240: PPUSH
26241: CALL_OW 88
// if BurlakStatus = 1 then
26245: LD_EXP 9
26249: PUSH
26250: LD_INT 1
26252: EQUAL
26253: IFFALSE 26267
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26255: LD_EXP 67
26259: PPUSH
26260: LD_STRING D10nB-Vse-1a
26262: PPUSH
26263: CALL_OW 94
// end ; if BurlakStatus = 0 then
26267: LD_EXP 9
26271: PUSH
26272: LD_INT 0
26274: EQUAL
26275: IFFALSE 26289
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26277: LD_EXP 67
26281: PPUSH
26282: LD_STRING D10nB-Vse-1
26284: PPUSH
26285: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26289: LD_EXP 36
26293: PPUSH
26294: LD_STRING D10nB-JMM-2
26296: PPUSH
26297: CALL_OW 88
// if KappaStatus then
26301: LD_EXP 2
26305: IFFALSE 26319
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26307: LD_EXP 67
26311: PPUSH
26312: LD_STRING D10nB-Vse-5a
26314: PPUSH
26315: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26319: LD_EXP 2
26323: NOT
26324: PUSH
26325: LD_EXP 6
26329: PUSH
26330: LD_INT 0
26332: EQUAL
26333: AND
26334: IFFALSE 26462
// begin if JMMGirl = 1 then
26336: LD_EXP 7
26340: PUSH
26341: LD_INT 1
26343: EQUAL
26344: IFFALSE 26394
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26346: LD_EXP 67
26350: PPUSH
26351: LD_STRING D10nB-Vse-2
26353: PPUSH
26354: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26358: LD_EXP 36
26362: PPUSH
26363: LD_STRING D10nB-JMM-3
26365: PPUSH
26366: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26370: LD_EXP 67
26374: PPUSH
26375: LD_STRING D10nB-Vse-3
26377: PPUSH
26378: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26382: LD_EXP 36
26386: PPUSH
26387: LD_STRING D10nB-JMM-4
26389: PPUSH
26390: CALL_OW 88
// end ; if JMMGirl = 2 then
26394: LD_EXP 7
26398: PUSH
26399: LD_INT 2
26401: EQUAL
26402: IFFALSE 26428
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26404: LD_EXP 67
26408: PPUSH
26409: LD_STRING D10nB-Vse-4
26411: PPUSH
26412: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26416: LD_EXP 36
26420: PPUSH
26421: LD_STRING D10nB-JMM-5
26423: PPUSH
26424: CALL_OW 88
// end ; if JMMGirl = 3 then
26428: LD_EXP 7
26432: PUSH
26433: LD_INT 3
26435: EQUAL
26436: IFFALSE 26462
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26438: LD_EXP 67
26442: PPUSH
26443: LD_STRING D10nB-Vse-5
26445: PPUSH
26446: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26450: LD_EXP 36
26454: PPUSH
26455: LD_STRING D10nB-JMM-6
26457: PPUSH
26458: CALL_OW 88
// end ; end ; DialogueOff ;
26462: CALL_OW 7
// end ;
26466: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26467: LD_EXP 14
26471: PUSH
26472: LD_INT 115500
26474: GREATEREQUAL
26475: IFFALSE 26834
26477: GO 26479
26479: DISABLE
26480: LD_INT 0
26482: PPUSH
// begin missionStage := 10 ;
26483: LD_ADDR_EXP 15
26487: PUSH
26488: LD_INT 10
26490: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26491: LD_ADDR_VAR 0 1
26495: PUSH
26496: LD_INT 22
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 26
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 3
26518: PUSH
26519: LD_INT 25
26521: PUSH
26522: LD_INT 12
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: PUSH
26533: LD_INT 3
26535: PUSH
26536: LD_INT 25
26538: PUSH
26539: LD_INT 16
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: PPUSH
26556: CALL_OW 69
26560: PUSH
26561: LD_EXP 36
26565: PUSH
26566: LD_EXP 38
26570: PUSH
26571: LD_EXP 52
26575: PUSH
26576: LD_EXP 39
26580: PUSH
26581: LD_EXP 40
26585: PUSH
26586: LD_EXP 41
26590: PUSH
26591: LD_EXP 42
26595: PUSH
26596: LD_EXP 43
26600: PUSH
26601: LD_EXP 44
26605: PUSH
26606: LD_EXP 45
26610: PUSH
26611: LD_EXP 46
26615: PUSH
26616: LD_EXP 47
26620: PUSH
26621: LD_EXP 48
26625: PUSH
26626: LD_EXP 49
26630: PUSH
26631: LD_EXP 50
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: DIFF
26653: ST_TO_ADDR
// if not tmp and Brown then
26654: LD_VAR 0 1
26658: NOT
26659: PUSH
26660: LD_EXP 44
26664: AND
26665: IFFALSE 26680
// tmp := [ Brown ] ;
26667: LD_ADDR_VAR 0 1
26671: PUSH
26672: LD_EXP 44
26676: PUSH
26677: EMPTY
26678: LIST
26679: ST_TO_ADDR
// DialogueOn ;
26680: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26684: LD_VAR 0 1
26688: PUSH
26689: LD_INT 1
26691: ARRAY
26692: PPUSH
26693: LD_STRING D11-Sol1-1
26695: PPUSH
26696: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26700: LD_EXP 61
26704: PPUSH
26705: LD_STRING D11-Pla-1
26707: PPUSH
26708: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26712: LD_EXP 62
26716: PPUSH
26717: LD_STRING D11-Kov-1
26719: PPUSH
26720: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26724: LD_EXP 61
26728: PPUSH
26729: LD_STRING D11-Pla-2
26731: PPUSH
26732: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26736: LD_VAR 0 1
26740: PUSH
26741: LD_INT 1
26743: ARRAY
26744: PPUSH
26745: LD_STRING D11-Sol1-2
26747: PPUSH
26748: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26752: LD_EXP 36
26756: PPUSH
26757: LD_STRING D11-JMM-2
26759: PPUSH
26760: CALL_OW 88
// DialogueOff ;
26764: CALL_OW 7
// allowBehemothConstruct := true ;
26768: LD_ADDR_EXP 25
26772: PUSH
26773: LD_INT 1
26775: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26776: LD_STRING M4
26778: PPUSH
26779: CALL_OW 337
// BuildBehemoths ;
26783: CALL 7577 0 0
// repeat wait ( 15 15$00 ) ;
26787: LD_INT 31500
26789: PPUSH
26790: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26794: LD_EXP 27
26798: IFFALSE 26802
// break ;
26800: GO 26834
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26802: LD_INT 267
26804: PPUSH
26805: CALL_OW 274
26809: PPUSH
26810: LD_INT 1
26812: PPUSH
26813: CALL_OW 275
26817: PUSH
26818: LD_INT 1000
26820: GREATEREQUAL
26821: IFFALSE 26827
// BuildBehemoths ;
26823: CALL 7577 0 0
// until not behemothBuilders ;
26827: LD_EXP 70
26831: NOT
26832: IFFALSE 26787
// end ;
26834: PPOPN 1
26836: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26837: LD_EXP 70
26841: NOT
26842: PUSH
26843: LD_EXP 28
26847: NOT
26848: AND
26849: PUSH
26850: LD_EXP 25
26854: AND
26855: IFFALSE 26875
26857: GO 26859
26859: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26860: LD_STRING M4a
26862: PPUSH
26863: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26867: LD_ADDR_EXP 27
26871: PUSH
26872: LD_INT 1
26874: ST_TO_ADDR
// end ;
26875: END
// every 0 0$1 trigger behemothDone do
26876: LD_EXP 28
26880: IFFALSE 26892
26882: GO 26884
26884: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26885: LD_STRING M4b
26887: PPUSH
26888: CALL_OW 337
26892: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26893: LD_EXP 29
26897: NOT
26898: IFFALSE 27094
26900: GO 26902
26902: DISABLE
26903: LD_INT 0
26905: PPUSH
26906: PPUSH
// begin enable ;
26907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26908: LD_ADDR_VAR 0 1
26912: PUSH
26913: LD_INT 3
26915: PPUSH
26916: CALL 106178 0 1
26920: ST_TO_ADDR
// if not tmp and not behemothDone then
26921: LD_VAR 0 1
26925: NOT
26926: PUSH
26927: LD_EXP 28
26931: NOT
26932: AND
26933: IFFALSE 26969
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26935: LD_ADDR_VAR 0 1
26939: PUSH
26940: LD_INT 22
26942: PUSH
26943: LD_INT 3
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 30
26952: PUSH
26953: LD_INT 37
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PPUSH
26964: CALL_OW 69
26968: ST_TO_ADDR
// if not tmp then
26969: LD_VAR 0 1
26973: NOT
26974: IFFALSE 26978
// exit ;
26976: GO 27094
// for i in tmp do
26978: LD_ADDR_VAR 0 2
26982: PUSH
26983: LD_VAR 0 1
26987: PUSH
26988: FOR_IN
26989: IFFALSE 27092
// if See ( 1 , i ) then
26991: LD_INT 1
26993: PPUSH
26994: LD_VAR 0 2
26998: PPUSH
26999: CALL_OW 292
27003: IFFALSE 27090
// begin if GetType ( i ) = unit_building then
27005: LD_VAR 0 2
27009: PPUSH
27010: CALL_OW 247
27014: PUSH
27015: LD_INT 3
27017: EQUAL
27018: IFFALSE 27056
// begin CenterNowOnUnits ( i ) ;
27020: LD_VAR 0 2
27024: PPUSH
27025: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27029: LD_EXP 36
27033: PPUSH
27034: LD_STRING D17a-JMM-1
27036: PPUSH
27037: CALL_OW 88
// seeBehemoth := true ;
27041: LD_ADDR_EXP 29
27045: PUSH
27046: LD_INT 1
27048: ST_TO_ADDR
// disable ;
27049: DISABLE
// exit ;
27050: POP
27051: POP
27052: GO 27094
// end else
27054: GO 27090
// begin CenterNowOnUnits ( i ) ;
27056: LD_VAR 0 2
27060: PPUSH
27061: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27065: LD_EXP 36
27069: PPUSH
27070: LD_STRING D17b-JMM-1
27072: PPUSH
27073: CALL_OW 88
// seeBehemoth := true ;
27077: LD_ADDR_EXP 29
27081: PUSH
27082: LD_INT 1
27084: ST_TO_ADDR
// disable ;
27085: DISABLE
// exit ;
27086: POP
27087: POP
27088: GO 27094
// end ; end ;
27090: GO 26988
27092: POP
27093: POP
// end ;
27094: PPOPN 2
27096: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27097: LD_EXP 14
27101: PUSH
27102: LD_INT 116550
27104: GREATEREQUAL
27105: IFFALSE 28281
27107: GO 27109
27109: DISABLE
27110: LD_INT 0
27112: PPUSH
27113: PPUSH
27114: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27115: LD_INT 2
27117: PPUSH
27118: LD_INT 23
27120: PUSH
27121: LD_INT 3
27123: PUSH
27124: LD_INT 3
27126: PUSH
27127: LD_INT 48
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: PUSH
27136: EMPTY
27137: LIST
27138: PPUSH
27139: CALL 57398 0 2
// repeat wait ( 0 0$1 ) ;
27143: LD_INT 35
27145: PPUSH
27146: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27150: LD_INT 22
27152: PUSH
27153: LD_INT 3
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: LD_INT 34
27162: PUSH
27163: LD_INT 48
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PPUSH
27174: CALL_OW 69
27178: IFFALSE 27143
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27180: LD_ADDR_VAR 0 1
27184: PUSH
27185: LD_INT 22
27187: PUSH
27188: LD_INT 3
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 34
27197: PUSH
27198: LD_INT 48
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: PPUSH
27209: CALL_OW 69
27213: PUSH
27214: LD_INT 1
27216: ARRAY
27217: ST_TO_ADDR
// missionStage := 12 ;
27218: LD_ADDR_EXP 15
27222: PUSH
27223: LD_INT 12
27225: ST_TO_ADDR
// platonovHasBomb := true ;
27226: LD_ADDR_EXP 30
27230: PUSH
27231: LD_INT 1
27233: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27234: LD_VAR 0 1
27238: PPUSH
27239: LD_INT 181
27241: PPUSH
27242: LD_INT 86
27244: PPUSH
27245: CALL_OW 171
// AddComHold ( bomb ) ;
27249: LD_VAR 0 1
27253: PPUSH
27254: CALL_OW 200
// wait ( 0 0$10 ) ;
27258: LD_INT 350
27260: PPUSH
27261: CALL_OW 67
// DialogueOn ;
27265: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27269: LD_EXP 61
27273: PPUSH
27274: LD_STRING D15-Pla-1
27276: PPUSH
27277: CALL_OW 94
// dec = Query ( Q15a ) ;
27281: LD_ADDR_VAR 0 2
27285: PUSH
27286: LD_STRING Q15a
27288: PPUSH
27289: CALL_OW 97
27293: ST_TO_ADDR
// if dec = 1 then
27294: LD_VAR 0 2
27298: PUSH
27299: LD_INT 1
27301: EQUAL
27302: IFFALSE 27325
// begin Say ( JMM , D15a-JMM-1 ) ;
27304: LD_EXP 36
27308: PPUSH
27309: LD_STRING D15a-JMM-1
27311: PPUSH
27312: CALL_OW 88
// YouLost ( Surrender ) ;
27316: LD_STRING Surrender
27318: PPUSH
27319: CALL_OW 104
// exit ;
27323: GO 28281
// end ; if dec = 2 then
27325: LD_VAR 0 2
27329: PUSH
27330: LD_INT 2
27332: EQUAL
27333: IFFALSE 27402
// begin Say ( JMM , D15b-JMM-1 ) ;
27335: LD_EXP 36
27339: PPUSH
27340: LD_STRING D15b-JMM-1
27342: PPUSH
27343: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27347: LD_EXP 61
27351: PPUSH
27352: LD_STRING D15b-Pla-1
27354: PPUSH
27355: CALL_OW 94
// DialogueOff ;
27359: CALL_OW 7
// wait ( 3 3$00 ) ;
27363: LD_INT 6300
27365: PPUSH
27366: CALL_OW 67
// DialogueOn ;
27370: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27374: LD_EXP 36
27378: PPUSH
27379: LD_STRING D15d-JMM-1a
27381: PPUSH
27382: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27386: LD_EXP 61
27390: PPUSH
27391: LD_STRING D15d-Pla-1
27393: PPUSH
27394: CALL_OW 94
// DialogueOff ;
27398: CALL_OW 7
// end ; if dec = 3 then
27402: LD_VAR 0 2
27406: PUSH
27407: LD_INT 3
27409: EQUAL
27410: IFFALSE 27464
// begin Say ( JMM , D15c-JMM-1 ) ;
27412: LD_EXP 36
27416: PPUSH
27417: LD_STRING D15c-JMM-1
27419: PPUSH
27420: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27424: LD_EXP 61
27428: PPUSH
27429: LD_STRING D15c-Pla-1
27431: PPUSH
27432: CALL_OW 94
// DialogueOff ;
27436: CALL_OW 7
// wait ( 0 0$15 ) ;
27440: LD_INT 525
27442: PPUSH
27443: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 60
27454: PPUSH
27455: LD_INT 95
27457: PPUSH
27458: CALL_OW 116
// exit ;
27462: GO 28281
// end ; if dec = 4 then
27464: LD_VAR 0 2
27468: PUSH
27469: LD_INT 4
27471: EQUAL
27472: IFFALSE 27502
// begin Say ( JMM , D15d-JMM-1 ) ;
27474: LD_EXP 36
27478: PPUSH
27479: LD_STRING D15d-JMM-1
27481: PPUSH
27482: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27486: LD_EXP 61
27490: PPUSH
27491: LD_STRING D15d-Pla-1
27493: PPUSH
27494: CALL_OW 94
// DialogueOff ;
27498: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27502: LD_EXP 59
27506: PPUSH
27507: CALL_OW 302
27511: PUSH
27512: LD_EXP 59
27516: PPUSH
27517: CALL_OW 255
27521: PUSH
27522: LD_INT 1
27524: EQUAL
27525: AND
27526: PUSH
27527: LD_INT 22
27529: PUSH
27530: LD_INT 1
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 34
27539: PUSH
27540: LD_INT 8
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: PPUSH
27551: CALL_OW 69
27555: NOT
27556: AND
27557: IFFALSE 28182
// begin SetSide ( Friend , 8 ) ;
27559: LD_EXP 59
27563: PPUSH
27564: LD_INT 8
27566: PPUSH
27567: CALL_OW 235
// if IsInUnit ( Friend ) then
27571: LD_EXP 59
27575: PPUSH
27576: CALL_OW 310
27580: IFFALSE 27591
// ComExitBuilding ( Friend ) ;
27582: LD_EXP 59
27586: PPUSH
27587: CALL_OW 122
// if IsDriver ( Friend ) then
27591: LD_EXP 59
27595: PPUSH
27596: CALL 103855 0 1
27600: IFFALSE 27611
// ComExitVehicle ( Friend ) ;
27602: LD_EXP 59
27606: PPUSH
27607: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27611: LD_EXP 59
27615: PPUSH
27616: LD_INT 9
27618: PPUSH
27619: LD_INT 2
27621: PPUSH
27622: CALL_OW 171
// wait ( 0 0$05 ) ;
27626: LD_INT 175
27628: PPUSH
27629: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27633: LD_EXP 59
27637: PPUSH
27638: CALL_OW 87
// DialogueOn ;
27642: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27646: LD_EXP 36
27650: PPUSH
27651: LD_STRING D16-JMM-1
27653: PPUSH
27654: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27658: LD_EXP 59
27662: PPUSH
27663: LD_STRING D16-Friend-1
27665: PPUSH
27666: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27670: LD_EXP 36
27674: PPUSH
27675: LD_STRING D16-JMM-2
27677: PPUSH
27678: CALL_OW 88
// DialogueOff ;
27682: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27686: LD_EXP 59
27690: PPUSH
27691: LD_INT 1
27693: PPUSH
27694: CALL_OW 235
// ComHold ( Friend ) ;
27698: LD_EXP 59
27702: PPUSH
27703: CALL_OW 140
// wait ( 0 0$20 ) ;
27707: LD_INT 700
27709: PPUSH
27710: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27714: LD_EXP 59
27718: PPUSH
27719: LD_INT 9
27721: PPUSH
27722: LD_INT 2
27724: PPUSH
27725: CALL_OW 297
27729: PUSH
27730: LD_INT 30
27732: LESS
27733: IFFALSE 27802
// begin SetSide ( Friend , 8 ) ;
27735: LD_EXP 59
27739: PPUSH
27740: LD_INT 8
27742: PPUSH
27743: CALL_OW 235
// if IsInUnit ( Friend ) then
27747: LD_EXP 59
27751: PPUSH
27752: CALL_OW 310
27756: IFFALSE 27767
// ComExitBuilding ( Friend ) ;
27758: LD_EXP 59
27762: PPUSH
27763: CALL_OW 122
// if IsDriver ( Friend ) then
27767: LD_EXP 59
27771: PPUSH
27772: CALL 103855 0 1
27776: IFFALSE 27787
// ComExitVehicle ( Friend ) ;
27778: LD_EXP 59
27782: PPUSH
27783: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27787: LD_EXP 59
27791: PPUSH
27792: LD_INT 9
27794: PPUSH
27795: LD_INT 2
27797: PPUSH
27798: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27802: LD_INT 1050
27804: PPUSH
27805: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27809: LD_INT 22
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 34
27821: PUSH
27822: LD_INT 8
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PPUSH
27833: CALL_OW 69
27837: NOT
27838: IFFALSE 28160
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27840: LD_ADDR_VAR 0 3
27844: PUSH
27845: LD_INT 22
27847: PUSH
27848: LD_INT 1
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: LD_INT 26
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 3
27867: PUSH
27868: LD_INT 25
27870: PUSH
27871: LD_INT 12
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 25
27880: PUSH
27881: LD_INT 16
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: LIST
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: LIST
27897: PPUSH
27898: CALL_OW 69
27902: PUSH
27903: LD_EXP 36
27907: PUSH
27908: LD_EXP 38
27912: PUSH
27913: LD_EXP 52
27917: PUSH
27918: LD_EXP 39
27922: PUSH
27923: LD_EXP 40
27927: PUSH
27928: LD_EXP 41
27932: PUSH
27933: LD_EXP 42
27937: PUSH
27938: LD_EXP 43
27942: PUSH
27943: LD_EXP 44
27947: PUSH
27948: LD_EXP 45
27952: PUSH
27953: LD_EXP 46
27957: PUSH
27958: LD_EXP 47
27962: PUSH
27963: LD_EXP 48
27967: PUSH
27968: LD_EXP 49
27972: PUSH
27973: LD_EXP 50
27977: PUSH
27978: EMPTY
27979: LIST
27980: LIST
27981: LIST
27982: LIST
27983: LIST
27984: LIST
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: LIST
27991: LIST
27992: LIST
27993: LIST
27994: DIFF
27995: ST_TO_ADDR
// DialogueOn ;
27996: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28000: LD_EXP 61
28004: PPUSH
28005: LD_STRING D16a-Pla-1
28007: PPUSH
28008: CALL_OW 94
// if Stevens then
28012: LD_EXP 38
28016: IFFALSE 28032
// Say ( Stevens , D16a-Huck-1 ) else
28018: LD_EXP 38
28022: PPUSH
28023: LD_STRING D16a-Huck-1
28025: PPUSH
28026: CALL_OW 88
28030: GO 28074
// if Baker then
28032: LD_EXP 52
28036: IFFALSE 28052
// Say ( Baker , D16a-Huck-1 ) else
28038: LD_EXP 52
28042: PPUSH
28043: LD_STRING D16a-Huck-1
28045: PPUSH
28046: CALL_OW 88
28050: GO 28074
// if tmp then
28052: LD_VAR 0 3
28056: IFFALSE 28074
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28058: LD_VAR 0 3
28062: PUSH
28063: LD_INT 1
28065: ARRAY
28066: PPUSH
28067: LD_STRING D16a-Sol1-1
28069: PPUSH
28070: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28074: LD_EXP 59
28078: PPUSH
28079: CALL_OW 255
28083: PUSH
28084: LD_INT 8
28086: EQUAL
28087: IFFALSE 28103
// Say ( JMM , D16a-JMM-1 ) else
28089: LD_EXP 36
28093: PPUSH
28094: LD_STRING D16a-JMM-1
28096: PPUSH
28097: CALL_OW 88
28101: GO 28139
// begin Say ( JMM , D16a-JMM-1a ) ;
28103: LD_EXP 36
28107: PPUSH
28108: LD_STRING D16a-JMM-1a
28110: PPUSH
28111: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28115: LD_EXP 59
28119: PPUSH
28120: LD_STRING D16a-Friend-1
28122: PPUSH
28123: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28127: LD_EXP 59
28131: PPUSH
28132: LD_INT 3
28134: PPUSH
28135: CALL_OW 235
// end ; DialogueOff ;
28139: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28143: LD_VAR 0 1
28147: PPUSH
28148: LD_INT 60
28150: PPUSH
28151: LD_INT 95
28153: PPUSH
28154: CALL_OW 116
// end else
28158: GO 28180
// begin DialogueOn ;
28160: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28164: LD_EXP 61
28168: PPUSH
28169: LD_STRING D16c-Pla-
28171: PPUSH
28172: CALL_OW 94
// DialogueOff ;
28176: CALL_OW 7
// end ; end else
28180: GO 28281
// begin wait ( 3 3$00 ) ;
28182: LD_INT 6300
28184: PPUSH
28185: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28189: LD_INT 22
28191: PUSH
28192: LD_INT 1
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 34
28201: PUSH
28202: LD_INT 8
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 69
28217: NOT
28218: IFFALSE 28261
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28220: LD_EXP 61
28224: PPUSH
28225: LD_STRING D16b-Pla-1
28227: PPUSH
28228: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28232: LD_EXP 36
28236: PPUSH
28237: LD_STRING D16b-JMM-
28239: PPUSH
28240: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28244: LD_VAR 0 1
28248: PPUSH
28249: LD_INT 60
28251: PPUSH
28252: LD_INT 95
28254: PPUSH
28255: CALL_OW 116
// end else
28259: GO 28281
// begin DialogueOn ;
28261: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28265: LD_EXP 61
28269: PPUSH
28270: LD_STRING D16c-Pla-
28272: PPUSH
28273: CALL_OW 94
// DialogueOff ;
28277: CALL_OW 7
// end ; end ; end ;
28281: PPOPN 3
28283: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28284: LD_EXP 14
28288: PUSH
28289: LD_INT 126000
28291: GREATEREQUAL
28292: PUSH
28293: LD_EXP 23
28297: NOT
28298: AND
28299: PUSH
28300: LD_EXP 71
28304: PPUSH
28305: CALL_OW 302
28309: AND
28310: IFFALSE 28668
28312: GO 28314
28314: DISABLE
28315: LD_INT 0
28317: PPUSH
// begin missionStage = 11 ;
28318: LD_ADDR_EXP 15
28322: PUSH
28323: LD_INT 11
28325: ST_TO_ADDR
// DialogueOn ;
28326: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28330: LD_EXP 71
28334: PPUSH
28335: LD_STRING D9-Roth-1
28337: PPUSH
28338: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28342: LD_EXP 36
28346: PPUSH
28347: LD_STRING D9-JMM-1
28349: PPUSH
28350: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28354: LD_EXP 71
28358: PPUSH
28359: LD_STRING D9-Roth-2
28361: PPUSH
28362: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28366: LD_EXP 71
28370: PPUSH
28371: LD_STRING D9-Roth-2a
28373: PPUSH
28374: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28378: LD_EXP 61
28382: PPUSH
28383: LD_STRING D9-Pla-2
28385: PPUSH
28386: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28390: LD_EXP 71
28394: PPUSH
28395: LD_STRING D9-Roth-3
28397: PPUSH
28398: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28402: LD_EXP 61
28406: PPUSH
28407: LD_STRING D9-Pla-3
28409: PPUSH
28410: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28414: LD_EXP 71
28418: PPUSH
28419: LD_STRING D9-Roth-4
28421: PPUSH
28422: CALL_OW 94
// dec = Query ( Q9 ) ;
28426: LD_ADDR_VAR 0 1
28430: PUSH
28431: LD_STRING Q9
28433: PPUSH
28434: CALL_OW 97
28438: ST_TO_ADDR
// if dec = 1 then
28439: LD_VAR 0 1
28443: PUSH
28444: LD_INT 1
28446: EQUAL
28447: IFFALSE 28461
// SayRadio ( Roth , D9a-Roth-1 ) ;
28449: LD_EXP 71
28453: PPUSH
28454: LD_STRING D9a-Roth-1
28456: PPUSH
28457: CALL_OW 94
// if dec = 2 then
28461: LD_VAR 0 1
28465: PUSH
28466: LD_INT 2
28468: EQUAL
28469: IFFALSE 28495
// begin Say ( JMM , D9b-JMM-1 ) ;
28471: LD_EXP 36
28475: PPUSH
28476: LD_STRING D9b-JMM-1
28478: PPUSH
28479: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28483: LD_EXP 71
28487: PPUSH
28488: LD_STRING D9b-Roth-1
28490: PPUSH
28491: CALL_OW 94
// end ; if dec = 3 then
28495: LD_VAR 0 1
28499: PUSH
28500: LD_INT 3
28502: EQUAL
28503: IFFALSE 28565
// begin Say ( JMM , D9c-JMM-1 ) ;
28505: LD_EXP 36
28509: PPUSH
28510: LD_STRING D9c-JMM-1
28512: PPUSH
28513: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28517: LD_EXP 71
28521: PPUSH
28522: LD_STRING D9c-Roth-1
28524: PPUSH
28525: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28529: LD_EXP 36
28533: PPUSH
28534: LD_STRING D9c-JMM-2
28536: PPUSH
28537: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28541: LD_EXP 71
28545: PPUSH
28546: LD_STRING D9c-Roth-2
28548: PPUSH
28549: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28553: LD_EXP 36
28557: PPUSH
28558: LD_STRING D9c-JMM-3
28560: PPUSH
28561: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28565: LD_EXP 71
28569: PPUSH
28570: LD_STRING D9c-Roth-3
28572: PPUSH
28573: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28577: LD_EXP 71
28581: PPUSH
28582: LD_STRING D9cont-Roth-1
28584: PPUSH
28585: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28589: LD_EXP 36
28593: PPUSH
28594: LD_STRING D9cont-JMM-1
28596: PPUSH
28597: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28601: LD_EXP 71
28605: PPUSH
28606: LD_STRING D9cont-Roth-2
28608: PPUSH
28609: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28613: LD_EXP 36
28617: PPUSH
28618: LD_STRING D9cont-JMM-2
28620: PPUSH
28621: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28625: LD_EXP 71
28629: PPUSH
28630: LD_STRING D9cont-Roth-3
28632: PPUSH
28633: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28637: LD_EXP 36
28641: PPUSH
28642: LD_STRING D9cont-JMM-3
28644: PPUSH
28645: CALL_OW 88
// DialogueOff ;
28649: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28653: LD_STRING M3
28655: PPUSH
28656: CALL_OW 337
// allianceActive := true ;
28660: LD_ADDR_EXP 31
28664: PUSH
28665: LD_INT 1
28667: ST_TO_ADDR
// end ;
28668: PPOPN 1
28670: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28671: LD_EXP 61
28675: PPUSH
28676: CALL_OW 301
28680: PUSH
28681: LD_EXP 64
28685: PPUSH
28686: CALL_OW 301
28690: AND
28691: PUSH
28692: LD_INT 22
28694: PUSH
28695: LD_INT 3
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 21
28704: PUSH
28705: LD_INT 1
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 50
28714: PUSH
28715: EMPTY
28716: LIST
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: LIST
28722: PPUSH
28723: CALL_OW 69
28727: PUSH
28728: LD_INT 7
28730: PUSH
28731: LD_INT 8
28733: PUSH
28734: LD_INT 9
28736: PUSH
28737: EMPTY
28738: LIST
28739: LIST
28740: LIST
28741: PUSH
28742: LD_OWVAR 67
28746: ARRAY
28747: LESS
28748: AND
28749: IFFALSE 29520
28751: GO 28753
28753: DISABLE
28754: LD_INT 0
28756: PPUSH
28757: PPUSH
28758: PPUSH
28759: PPUSH
// begin MC_Kill ( 1 ) ;
28760: LD_INT 1
28762: PPUSH
28763: CALL 34050 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28767: LD_INT 1
28769: PPUSH
28770: LD_INT 3
28772: PPUSH
28773: LD_INT 1
28775: PPUSH
28776: LD_INT 1
28778: PPUSH
28779: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28783: LD_ADDR_VAR 0 1
28787: PUSH
28788: LD_INT 22
28790: PUSH
28791: LD_INT 3
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 21
28800: PUSH
28801: LD_INT 1
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 24
28810: PUSH
28811: LD_INT 900
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: LIST
28822: PPUSH
28823: CALL_OW 69
28827: PUSH
28828: FOR_IN
28829: IFFALSE 28860
// if GetSex ( i ) = sex_male then
28831: LD_VAR 0 1
28835: PPUSH
28836: CALL_OW 258
28840: PUSH
28841: LD_INT 1
28843: EQUAL
28844: IFFALSE 28858
// begin tmp = i ;
28846: LD_ADDR_VAR 0 2
28850: PUSH
28851: LD_VAR 0 1
28855: ST_TO_ADDR
// break ;
28856: GO 28860
// end ;
28858: GO 28828
28860: POP
28861: POP
// if tmp = 0 then
28862: LD_VAR 0 2
28866: PUSH
28867: LD_INT 0
28869: EQUAL
28870: IFFALSE 28924
// begin uc_side = 3 ;
28872: LD_ADDR_OWVAR 20
28876: PUSH
28877: LD_INT 3
28879: ST_TO_ADDR
// uc_nation = 3 ;
28880: LD_ADDR_OWVAR 21
28884: PUSH
28885: LD_INT 3
28887: ST_TO_ADDR
// hc_name =  ;
28888: LD_ADDR_OWVAR 26
28892: PUSH
28893: LD_STRING 
28895: ST_TO_ADDR
// hc_gallery =  ;
28896: LD_ADDR_OWVAR 33
28900: PUSH
28901: LD_STRING 
28903: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28904: LD_INT 1
28906: PPUSH
28907: LD_INT 10
28909: PPUSH
28910: CALL_OW 381
// tmp = CreateHuman ;
28914: LD_ADDR_VAR 0 2
28918: PUSH
28919: CALL_OW 44
28923: ST_TO_ADDR
// end ; DialogueOn ;
28924: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28928: LD_VAR 0 2
28932: PPUSH
28933: LD_STRING DSurrenderRussians-RSol1-1a
28935: PPUSH
28936: CALL_OW 88
// DialogueOff ;
28940: CALL_OW 7
// russianDestroyed := true ;
28944: LD_ADDR_EXP 21
28948: PUSH
28949: LD_INT 1
28951: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28952: LD_INT 22
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 21
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: PPUSH
28976: CALL_OW 69
28980: PPUSH
28981: CALL_OW 122
// wait ( 0 0$1 ) ;
28985: LD_INT 35
28987: PPUSH
28988: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28992: LD_INT 22
28994: PUSH
28995: LD_INT 3
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 21
29004: PUSH
29005: LD_INT 1
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PPUSH
29016: CALL_OW 69
29020: PPUSH
29021: LD_INT 25
29023: PPUSH
29024: CALL_OW 173
// wait ( 0 0$10 ) ;
29028: LD_INT 350
29030: PPUSH
29031: CALL_OW 67
// PrepareOmarInvasion ;
29035: CALL 13700 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29039: LD_ADDR_VAR 0 2
29043: PUSH
29044: LD_EXP 89
29048: PPUSH
29049: CALL_OW 250
29053: PUSH
29054: LD_EXP 89
29058: PPUSH
29059: CALL_OW 251
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29068: LD_VAR 0 2
29072: PUSH
29073: LD_INT 1
29075: ARRAY
29076: PPUSH
29077: LD_VAR 0 2
29081: PUSH
29082: LD_INT 2
29084: ARRAY
29085: PPUSH
29086: LD_INT 1
29088: PPUSH
29089: LD_INT 8
29091: NEG
29092: PPUSH
29093: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29097: LD_EXP 89
29101: PPUSH
29102: CALL_OW 87
// DialogueOn ;
29106: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29110: LD_EXP 36
29114: PPUSH
29115: LD_STRING D19-JMM-1
29117: PPUSH
29118: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29122: LD_ADDR_VAR 0 3
29126: PUSH
29127: LD_INT 22
29129: PUSH
29130: LD_INT 1
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 26
29139: PUSH
29140: LD_INT 1
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 2
29149: PUSH
29150: LD_INT 25
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 25
29162: PUSH
29163: LD_INT 2
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 25
29172: PUSH
29173: LD_INT 3
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 25
29182: PUSH
29183: LD_INT 4
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 25
29192: PUSH
29193: LD_INT 5
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 25
29202: PUSH
29203: LD_INT 8
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: LIST
29223: PPUSH
29224: CALL_OW 69
29228: PUSH
29229: LD_EXP 36
29233: PUSH
29234: LD_EXP 37
29238: PUSH
29239: LD_EXP 38
29243: PUSH
29244: LD_EXP 39
29248: PUSH
29249: LD_EXP 40
29253: PUSH
29254: LD_EXP 41
29258: PUSH
29259: LD_EXP 42
29263: PUSH
29264: LD_EXP 43
29268: PUSH
29269: LD_EXP 44
29273: PUSH
29274: LD_EXP 45
29278: PUSH
29279: LD_EXP 46
29283: PUSH
29284: LD_EXP 47
29288: PUSH
29289: LD_EXP 48
29293: PUSH
29294: LD_EXP 49
29298: PUSH
29299: LD_EXP 50
29303: PUSH
29304: LD_EXP 51
29308: PUSH
29309: LD_EXP 52
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: DIFF
29333: ST_TO_ADDR
// if tmp2 then
29334: LD_VAR 0 3
29338: IFFALSE 29356
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29340: LD_VAR 0 3
29344: PUSH
29345: LD_INT 1
29347: ARRAY
29348: PPUSH
29349: LD_STRING D19-Sol1-1
29351: PPUSH
29352: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29356: LD_EXP 36
29360: PPUSH
29361: LD_STRING D19-JMM-2
29363: PPUSH
29364: CALL_OW 88
// DialogueOff ;
29368: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29372: LD_VAR 0 2
29376: PUSH
29377: LD_INT 1
29379: ARRAY
29380: PPUSH
29381: LD_VAR 0 2
29385: PUSH
29386: LD_INT 2
29388: ARRAY
29389: PPUSH
29390: LD_INT 1
29392: PPUSH
29393: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29397: LD_STRING M5
29399: PPUSH
29400: CALL_OW 337
// omarOnMotherLode := false ;
29404: LD_ADDR_VAR 0 4
29408: PUSH
29409: LD_INT 0
29411: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29412: LD_INT 35
29414: PPUSH
29415: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29419: LD_EXP 89
29423: PPUSH
29424: LD_INT 215
29426: PPUSH
29427: LD_INT 100
29429: PPUSH
29430: CALL_OW 297
29434: PUSH
29435: LD_INT 10
29437: LESS
29438: PUSH
29439: LD_VAR 0 4
29443: NOT
29444: AND
29445: IFFALSE 29479
// begin omarOnMotherLode := true ;
29447: LD_ADDR_VAR 0 4
29451: PUSH
29452: LD_INT 1
29454: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29455: LD_EXP 36
29459: PPUSH
29460: LD_STRING D19b-JMM-1
29462: PPUSH
29463: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29467: LD_EXP 89
29471: PPUSH
29472: LD_STRING DOmarContam-Omar-1
29474: PPUSH
29475: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29479: LD_EXP 89
29483: PPUSH
29484: CALL_OW 301
29488: IFFALSE 29412
// Say ( JMM , D19a-JMM-1 ) ;
29490: LD_EXP 36
29494: PPUSH
29495: LD_STRING D19a-JMM-1
29497: PPUSH
29498: CALL_OW 88
// if Heike then
29502: LD_EXP 90
29506: IFFALSE 29520
// Say ( Heike , D19a-Hke-1 ) ;
29508: LD_EXP 90
29512: PPUSH
29513: LD_STRING D19a-Hke-1
29515: PPUSH
29516: CALL_OW 88
// end ;
29520: PPOPN 4
29522: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29523: LD_INT 22
29525: PUSH
29526: LD_INT 3
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 21
29535: PUSH
29536: LD_INT 1
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL_OW 69
29551: PUSH
29552: LD_EXP 21
29556: AND
29557: IFFALSE 29625
29559: GO 29561
29561: DISABLE
29562: LD_INT 0
29564: PPUSH
29565: PPUSH
// begin enable ;
29566: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29567: LD_ADDR_VAR 0 2
29571: PUSH
29572: LD_INT 25
29574: PPUSH
29575: LD_INT 22
29577: PUSH
29578: LD_INT 3
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PPUSH
29585: CALL_OW 70
29589: ST_TO_ADDR
// if not tmp then
29590: LD_VAR 0 2
29594: NOT
29595: IFFALSE 29599
// exit ;
29597: GO 29625
// for i in tmp do
29599: LD_ADDR_VAR 0 1
29603: PUSH
29604: LD_VAR 0 2
29608: PUSH
29609: FOR_IN
29610: IFFALSE 29623
// RemoveUnit ( i ) ;
29612: LD_VAR 0 1
29616: PPUSH
29617: CALL_OW 64
29621: GO 29609
29623: POP
29624: POP
// end ;
29625: PPOPN 2
29627: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29628: LD_INT 22
29630: PUSH
29631: LD_INT 7
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 21
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PPUSH
29652: CALL_OW 69
29656: PUSH
29657: LD_INT 6
29659: LESS
29660: IFFALSE 30111
29662: GO 29664
29664: DISABLE
29665: LD_INT 0
29667: PPUSH
29668: PPUSH
// begin MC_Kill ( 1 ) ;
29669: LD_INT 1
29671: PPUSH
29672: CALL 34050 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29676: LD_INT 7
29678: PPUSH
29679: LD_INT 1
29681: PPUSH
29682: LD_INT 1
29684: PPUSH
29685: LD_INT 1
29687: PPUSH
29688: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29692: LD_ADDR_VAR 0 1
29696: PUSH
29697: LD_INT 22
29699: PUSH
29700: LD_INT 7
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 26
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PPUSH
29721: CALL_OW 69
29725: PUSH
29726: LD_EXP 71
29730: DIFF
29731: ST_TO_ADDR
// if tmp then
29732: LD_VAR 0 1
29736: IFFALSE 29754
// tmp := tmp [ 1 ] else
29738: LD_ADDR_VAR 0 1
29742: PUSH
29743: LD_VAR 0 1
29747: PUSH
29748: LD_INT 1
29750: ARRAY
29751: ST_TO_ADDR
29752: GO 29790
// begin uc_side := 7 ;
29754: LD_ADDR_OWVAR 20
29758: PUSH
29759: LD_INT 7
29761: ST_TO_ADDR
// uc_nation := 1 ;
29762: LD_ADDR_OWVAR 21
29766: PUSH
29767: LD_INT 1
29769: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29770: LD_INT 1
29772: PPUSH
29773: LD_INT 8
29775: PPUSH
29776: CALL_OW 384
// tmp := CreateHuman ;
29780: LD_ADDR_VAR 0 1
29784: PUSH
29785: CALL_OW 44
29789: ST_TO_ADDR
// end ; DialogueOn ;
29790: CALL_OW 6
// if IsOK ( Roth ) then
29794: LD_EXP 71
29798: PPUSH
29799: CALL_OW 302
29803: IFFALSE 29817
// Say ( JMM , DAb-JMM-1 ) ;
29805: LD_EXP 36
29809: PPUSH
29810: LD_STRING DAb-JMM-1
29812: PPUSH
29813: CALL_OW 88
// if IsOK ( Roth ) then
29817: LD_EXP 71
29821: PPUSH
29822: CALL_OW 302
29826: IFFALSE 29850
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29828: LD_EXP 71
29832: PPUSH
29833: LD_STRING DSurrenderAlliance-Roth-1
29835: PPUSH
29836: CALL_OW 88
// RothCaptured := true ;
29840: LD_ADDR_EXP 33
29844: PUSH
29845: LD_INT 1
29847: ST_TO_ADDR
// end else
29848: GO 29862
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29850: LD_VAR 0 1
29854: PPUSH
29855: LD_STRING DSurrenderAlliance-Sci1-1
29857: PPUSH
29858: CALL_OW 88
// DialogueOff ;
29862: CALL_OW 7
// allianceDestroyed := true ;
29866: LD_ADDR_EXP 23
29870: PUSH
29871: LD_INT 1
29873: ST_TO_ADDR
// if trueAmericans then
29874: LD_EXP 35
29878: IFFALSE 29954
// begin if trueAmericans = 1 then
29880: LD_EXP 35
29884: PUSH
29885: LD_INT 1
29887: EQUAL
29888: IFFALSE 29904
// Say ( JMM , DAb-JMM-1a ) else
29890: LD_EXP 36
29894: PPUSH
29895: LD_STRING DAb-JMM-1a
29897: PPUSH
29898: CALL_OW 88
29902: GO 29916
// Say ( JMM , DAb-JMM-1b ) ;
29904: LD_EXP 36
29908: PPUSH
29909: LD_STRING DAb-JMM-1b
29911: PPUSH
29912: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29916: LD_EXP 35
29920: PPUSH
29921: CALL_OW 87
// for i in trueAmericans do
29925: LD_ADDR_VAR 0 2
29929: PUSH
29930: LD_EXP 35
29934: PUSH
29935: FOR_IN
29936: IFFALSE 29952
// SetSide ( i , 1 ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_INT 1
29945: PPUSH
29946: CALL_OW 235
29950: GO 29935
29952: POP
29953: POP
// end ; repeat wait ( 0 0$1 ) ;
29954: LD_INT 35
29956: PPUSH
29957: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29961: LD_ADDR_VAR 0 2
29965: PUSH
29966: LD_INT 22
29968: PUSH
29969: LD_INT 7
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 21
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PPUSH
29990: CALL_OW 69
29994: PUSH
29995: FOR_IN
29996: IFFALSE 30078
// begin if IsInUnit ( i ) then
29998: LD_VAR 0 2
30002: PPUSH
30003: CALL_OW 310
30007: IFFALSE 30018
// ComExitBuilding ( i ) ;
30009: LD_VAR 0 2
30013: PPUSH
30014: CALL_OW 122
// if IsDriver ( i ) then
30018: LD_VAR 0 2
30022: PPUSH
30023: CALL 103855 0 1
30027: IFFALSE 30038
// ComExitVehicle ( i ) ;
30029: LD_VAR 0 2
30033: PPUSH
30034: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30038: LD_VAR 0 2
30042: PPUSH
30043: LD_INT 26
30045: PPUSH
30046: CALL_OW 308
30050: NOT
30051: IFFALSE 30067
// AddComMoveToArea ( i , allianceEscapeArea ) else
30053: LD_VAR 0 2
30057: PPUSH
30058: LD_INT 26
30060: PPUSH
30061: CALL_OW 173
30065: GO 30076
// RemoveUnit ( i ) ;
30067: LD_VAR 0 2
30071: PPUSH
30072: CALL_OW 64
// end ;
30076: GO 29995
30078: POP
30079: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30080: LD_INT 22
30082: PUSH
30083: LD_INT 7
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 21
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PPUSH
30104: CALL_OW 69
30108: NOT
30109: IFFALSE 29954
// end ;
30111: PPOPN 2
30113: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30114: LD_INT 0
30116: PPUSH
30117: PPUSH
// if not unit then
30118: LD_VAR 0 1
30122: NOT
30123: IFFALSE 30127
// exit ;
30125: GO 31625
// DoNotAttack ( 7 , unit ) ;
30127: LD_INT 7
30129: PPUSH
30130: LD_VAR 0 1
30134: PPUSH
30135: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30139: LD_VAR 0 1
30143: PPUSH
30144: LD_INT 260
30146: PPUSH
30147: LD_INT 235
30149: PPUSH
30150: LD_INT 3
30152: PPUSH
30153: LD_INT 1
30155: PPUSH
30156: CALL_OW 483
// SetSide ( unit , 4 ) ;
30160: LD_VAR 0 1
30164: PPUSH
30165: LD_INT 4
30167: PPUSH
30168: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30172: LD_ADDR_EXP 34
30176: PUSH
30177: LD_EXP 34
30181: PUSH
30182: LD_INT 1
30184: PLUS
30185: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30186: LD_INT 70
30188: PPUSH
30189: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30193: LD_INT 260
30195: PPUSH
30196: LD_INT 235
30198: PPUSH
30199: LD_INT 1
30201: PPUSH
30202: LD_INT 8
30204: NEG
30205: PPUSH
30206: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30210: LD_VAR 0 1
30214: PPUSH
30215: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30219: LD_VAR 0 1
30223: PPUSH
30224: LD_EXP 71
30228: PPUSH
30229: CALL_OW 119
// DialogueOn ;
30233: CALL_OW 6
// case unit of JMM :
30237: LD_VAR 0 1
30241: PUSH
30242: LD_EXP 36
30246: DOUBLE
30247: EQUAL
30248: IFTRUE 30252
30250: GO 30267
30252: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30253: LD_EXP 36
30257: PPUSH
30258: LD_STRING DA1-JMM-1
30260: PPUSH
30261: CALL_OW 91
30265: GO 30709
30267: LD_EXP 37
30271: DOUBLE
30272: EQUAL
30273: IFTRUE 30277
30275: GO 30292
30277: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30278: LD_EXP 37
30282: PPUSH
30283: LD_STRING DA1-Joan-1
30285: PPUSH
30286: CALL_OW 91
30290: GO 30709
30292: LD_EXP 39
30296: DOUBLE
30297: EQUAL
30298: IFTRUE 30302
30300: GO 30317
30302: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30303: LD_EXP 39
30307: PPUSH
30308: LD_STRING DA1-Lisa-1
30310: PPUSH
30311: CALL_OW 91
30315: GO 30709
30317: LD_EXP 40
30321: DOUBLE
30322: EQUAL
30323: IFTRUE 30327
30325: GO 30342
30327: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30328: LD_EXP 40
30332: PPUSH
30333: LD_STRING DA1-Don-1
30335: PPUSH
30336: CALL_OW 91
30340: GO 30709
30342: LD_EXP 47
30346: DOUBLE
30347: EQUAL
30348: IFTRUE 30352
30350: GO 30367
30352: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30353: LD_EXP 47
30357: PPUSH
30358: LD_STRING DA1-Corn-1
30360: PPUSH
30361: CALL_OW 91
30365: GO 30709
30367: LD_EXP 43
30371: DOUBLE
30372: EQUAL
30373: IFTRUE 30377
30375: GO 30392
30377: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30378: LD_EXP 43
30382: PPUSH
30383: LD_STRING DA1-Den-1
30385: PPUSH
30386: CALL_OW 91
30390: GO 30709
30392: LD_EXP 41
30396: DOUBLE
30397: EQUAL
30398: IFTRUE 30402
30400: GO 30417
30402: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30403: LD_EXP 41
30407: PPUSH
30408: LD_STRING DA1-Bobby-1
30410: PPUSH
30411: CALL_OW 91
30415: GO 30709
30417: LD_EXP 45
30421: DOUBLE
30422: EQUAL
30423: IFTRUE 30427
30425: GO 30442
30427: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30428: LD_EXP 45
30432: PPUSH
30433: LD_STRING DA1-Glad-1
30435: PPUSH
30436: CALL_OW 91
30440: GO 30709
30442: LD_EXP 42
30446: DOUBLE
30447: EQUAL
30448: IFTRUE 30452
30450: GO 30467
30452: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30453: LD_EXP 42
30457: PPUSH
30458: LD_STRING DA1-Cyrus-1
30460: PPUSH
30461: CALL_OW 91
30465: GO 30709
30467: LD_EXP 38
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30492
30477: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30478: LD_EXP 38
30482: PPUSH
30483: LD_STRING DA1-Huck-1
30485: PPUSH
30486: CALL_OW 91
30490: GO 30709
30492: LD_EXP 52
30496: DOUBLE
30497: EQUAL
30498: IFTRUE 30502
30500: GO 30517
30502: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30503: LD_EXP 52
30507: PPUSH
30508: LD_STRING DA1-Huck-1
30510: PPUSH
30511: CALL_OW 91
30515: GO 30709
30517: LD_EXP 44
30521: DOUBLE
30522: EQUAL
30523: IFTRUE 30527
30525: GO 30542
30527: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30528: LD_EXP 44
30532: PPUSH
30533: LD_STRING DA1-Brown-1
30535: PPUSH
30536: CALL_OW 91
30540: GO 30709
30542: LD_EXP 48
30546: DOUBLE
30547: EQUAL
30548: IFTRUE 30552
30550: GO 30567
30552: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30553: LD_EXP 48
30557: PPUSH
30558: LD_STRING DA1-Gary-1
30560: PPUSH
30561: CALL_OW 91
30565: GO 30709
30567: LD_EXP 51
30571: DOUBLE
30572: EQUAL
30573: IFTRUE 30577
30575: GO 30592
30577: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30578: LD_EXP 51
30582: PPUSH
30583: LD_STRING DA1-Con-1
30585: PPUSH
30586: CALL_OW 91
30590: GO 30709
30592: LD_EXP 57
30596: DOUBLE
30597: EQUAL
30598: IFTRUE 30602
30600: GO 30617
30602: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30603: LD_EXP 57
30607: PPUSH
30608: LD_STRING DA1-Kurt-1
30610: PPUSH
30611: CALL_OW 91
30615: GO 30709
30617: LD_EXP 50
30621: DOUBLE
30622: EQUAL
30623: IFTRUE 30627
30625: GO 30642
30627: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30628: LD_EXP 50
30632: PPUSH
30633: LD_STRING DA1-Yam-1
30635: PPUSH
30636: CALL_OW 91
30640: GO 30709
30642: LD_EXP 49
30646: DOUBLE
30647: EQUAL
30648: IFTRUE 30652
30650: GO 30667
30652: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30653: LD_EXP 49
30657: PPUSH
30658: LD_STRING DA1-Frank-1
30660: PPUSH
30661: CALL_OW 91
30665: GO 30709
30667: POP
// begin if GetSex ( unit ) = sex_male then
30668: LD_VAR 0 1
30672: PPUSH
30673: CALL_OW 258
30677: PUSH
30678: LD_INT 1
30680: EQUAL
30681: IFFALSE 30697
// ForceSay ( unit , DA1-Sol1-1 ) else
30683: LD_VAR 0 1
30687: PPUSH
30688: LD_STRING DA1-Sol1-1
30690: PPUSH
30691: CALL_OW 91
30695: GO 30709
// ForceSay ( unit , DA1-FSol1-1 ) ;
30697: LD_VAR 0 1
30701: PPUSH
30702: LD_STRING DA1-FSol1-1
30704: PPUSH
30705: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30709: LD_EXP 71
30713: PPUSH
30714: LD_STRING DA-Roth-1
30716: PPUSH
30717: CALL_OW 88
// if capturedUnit = 1 then
30721: LD_EXP 34
30725: PUSH
30726: LD_INT 1
30728: EQUAL
30729: IFFALSE 30757
// begin Say ( Simms , DA-Sim-1 ) ;
30731: LD_EXP 72
30735: PPUSH
30736: LD_STRING DA-Sim-1
30738: PPUSH
30739: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30743: LD_EXP 71
30747: PPUSH
30748: LD_STRING DA-Roth-2
30750: PPUSH
30751: CALL_OW 88
// end else
30755: GO 30769
// Say ( Simms , DA-Sim-2 ) ;
30757: LD_EXP 72
30761: PPUSH
30762: LD_STRING DA-Sim-2
30764: PPUSH
30765: CALL_OW 88
// case unit of JMM :
30769: LD_VAR 0 1
30773: PUSH
30774: LD_EXP 36
30778: DOUBLE
30779: EQUAL
30780: IFTRUE 30784
30782: GO 30799
30784: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30785: LD_EXP 36
30789: PPUSH
30790: LD_STRING DA1-JMM-1a
30792: PPUSH
30793: CALL_OW 91
30797: GO 31306
30799: LD_EXP 37
30803: DOUBLE
30804: EQUAL
30805: IFTRUE 30809
30807: GO 30824
30809: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30810: LD_EXP 37
30814: PPUSH
30815: LD_STRING DA1-Joan-1a
30817: PPUSH
30818: CALL_OW 91
30822: GO 31306
30824: LD_EXP 39
30828: DOUBLE
30829: EQUAL
30830: IFTRUE 30834
30832: GO 30849
30834: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30835: LD_EXP 39
30839: PPUSH
30840: LD_STRING DA1-Lisa-1a
30842: PPUSH
30843: CALL_OW 91
30847: GO 31306
30849: LD_EXP 40
30853: DOUBLE
30854: EQUAL
30855: IFTRUE 30859
30857: GO 30874
30859: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30860: LD_EXP 40
30864: PPUSH
30865: LD_STRING DA1-Don-1a
30867: PPUSH
30868: CALL_OW 91
30872: GO 31306
30874: LD_EXP 47
30878: DOUBLE
30879: EQUAL
30880: IFTRUE 30884
30882: GO 30899
30884: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30885: LD_EXP 47
30889: PPUSH
30890: LD_STRING DA1-Corn-1a
30892: PPUSH
30893: CALL_OW 91
30897: GO 31306
30899: LD_EXP 43
30903: DOUBLE
30904: EQUAL
30905: IFTRUE 30909
30907: GO 30924
30909: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30910: LD_EXP 43
30914: PPUSH
30915: LD_STRING DA1-Den-1a
30917: PPUSH
30918: CALL_OW 91
30922: GO 31306
30924: LD_EXP 41
30928: DOUBLE
30929: EQUAL
30930: IFTRUE 30934
30932: GO 30949
30934: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30935: LD_EXP 41
30939: PPUSH
30940: LD_STRING DA1-Bobby-1a
30942: PPUSH
30943: CALL_OW 91
30947: GO 31306
30949: LD_EXP 45
30953: DOUBLE
30954: EQUAL
30955: IFTRUE 30959
30957: GO 30974
30959: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30960: LD_EXP 45
30964: PPUSH
30965: LD_STRING DA1-Glad-1a
30967: PPUSH
30968: CALL_OW 91
30972: GO 31306
30974: LD_EXP 42
30978: DOUBLE
30979: EQUAL
30980: IFTRUE 30984
30982: GO 30999
30984: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30985: LD_EXP 42
30989: PPUSH
30990: LD_STRING DA1-Cyrus-1a
30992: PPUSH
30993: CALL_OW 91
30997: GO 31306
30999: LD_EXP 38
31003: DOUBLE
31004: EQUAL
31005: IFTRUE 31009
31007: GO 31024
31009: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31010: LD_EXP 38
31014: PPUSH
31015: LD_STRING DA1-Huck-1a
31017: PPUSH
31018: CALL_OW 91
31022: GO 31306
31024: LD_EXP 52
31028: DOUBLE
31029: EQUAL
31030: IFTRUE 31034
31032: GO 31049
31034: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31035: LD_EXP 52
31039: PPUSH
31040: LD_STRING DA1-Huck-1a
31042: PPUSH
31043: CALL_OW 91
31047: GO 31306
31049: LD_EXP 44
31053: DOUBLE
31054: EQUAL
31055: IFTRUE 31059
31057: GO 31074
31059: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31060: LD_EXP 44
31064: PPUSH
31065: LD_STRING DA1-Brown-1a
31067: PPUSH
31068: CALL_OW 91
31072: GO 31306
31074: LD_EXP 48
31078: DOUBLE
31079: EQUAL
31080: IFTRUE 31084
31082: GO 31099
31084: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31085: LD_EXP 48
31089: PPUSH
31090: LD_STRING DA1-Gary-1a
31092: PPUSH
31093: CALL_OW 91
31097: GO 31306
31099: LD_EXP 51
31103: DOUBLE
31104: EQUAL
31105: IFTRUE 31109
31107: GO 31124
31109: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31110: LD_EXP 51
31114: PPUSH
31115: LD_STRING DA1-Con-1a
31117: PPUSH
31118: CALL_OW 91
31122: GO 31306
31124: LD_EXP 57
31128: DOUBLE
31129: EQUAL
31130: IFTRUE 31134
31132: GO 31149
31134: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31135: LD_EXP 57
31139: PPUSH
31140: LD_STRING DA1-Kurt-1a
31142: PPUSH
31143: CALL_OW 91
31147: GO 31306
31149: LD_EXP 50
31153: DOUBLE
31154: EQUAL
31155: IFTRUE 31159
31157: GO 31174
31159: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31160: LD_EXP 50
31164: PPUSH
31165: LD_STRING DA1-Yam-1a
31167: PPUSH
31168: CALL_OW 91
31172: GO 31306
31174: LD_EXP 49
31178: DOUBLE
31179: EQUAL
31180: IFTRUE 31184
31182: GO 31199
31184: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31185: LD_EXP 49
31189: PPUSH
31190: LD_STRING DA1-Frank-1a
31192: PPUSH
31193: CALL_OW 91
31197: GO 31306
31199: POP
// begin join := rand ( 0 , 1 ) ;
31200: LD_ADDR_VAR 0 3
31204: PUSH
31205: LD_INT 0
31207: PPUSH
31208: LD_INT 1
31210: PPUSH
31211: CALL_OW 12
31215: ST_TO_ADDR
// if join then
31216: LD_VAR 0 3
31220: IFFALSE 31265
// begin if GetSex ( unit ) = sex_male then
31222: LD_VAR 0 1
31226: PPUSH
31227: CALL_OW 258
31231: PUSH
31232: LD_INT 1
31234: EQUAL
31235: IFFALSE 31251
// ForceSay ( unit , DA1-Sol1-1b ) else
31237: LD_VAR 0 1
31241: PPUSH
31242: LD_STRING DA1-Sol1-1b
31244: PPUSH
31245: CALL_OW 91
31249: GO 31263
// ForceSay ( unit , DA1-FSol1-1b ) ;
31251: LD_VAR 0 1
31255: PPUSH
31256: LD_STRING DA1-FSol1-1b
31258: PPUSH
31259: CALL_OW 91
// end else
31263: GO 31306
// begin if GetSex ( unit ) = sex_male then
31265: LD_VAR 0 1
31269: PPUSH
31270: CALL_OW 258
31274: PUSH
31275: LD_INT 1
31277: EQUAL
31278: IFFALSE 31294
// ForceSay ( unit , DA1-Sol1-1a ) else
31280: LD_VAR 0 1
31284: PPUSH
31285: LD_STRING DA1-Sol1-1a
31287: PPUSH
31288: CALL_OW 91
31292: GO 31306
// ForceSay ( unit , DA1-FSol1-1a ) ;
31294: LD_VAR 0 1
31298: PPUSH
31299: LD_STRING DA1-FSol1-1a
31301: PPUSH
31302: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31306: LD_VAR 0 1
31310: PUSH
31311: LD_EXP 36
31315: EQUAL
31316: IFFALSE 31327
// begin YouLost ( JMMCaptured ) ;
31318: LD_STRING JMMCaptured
31320: PPUSH
31321: CALL_OW 104
// exit ;
31325: GO 31625
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31327: LD_VAR 0 1
31331: PUSH
31332: LD_EXP 40
31336: PUSH
31337: LD_EXP 43
31341: PUSH
31342: LD_EXP 41
31346: PUSH
31347: LD_EXP 38
31351: PUSH
31352: LD_EXP 52
31356: PUSH
31357: LD_EXP 44
31361: PUSH
31362: LD_EXP 50
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: IN
31376: PUSH
31377: LD_VAR 0 3
31381: OR
31382: IFFALSE 31481
// begin Say ( Roth , DA-Roth-3 ) ;
31384: LD_EXP 71
31388: PPUSH
31389: LD_STRING DA-Roth-3
31391: PPUSH
31392: CALL_OW 88
// SetSide ( unit , 7 ) ;
31396: LD_VAR 0 1
31400: PPUSH
31401: LD_INT 7
31403: PPUSH
31404: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31408: LD_ADDR_EXP 99
31412: PUSH
31413: LD_EXP 99
31417: PPUSH
31418: LD_INT 1
31420: PPUSH
31421: LD_EXP 99
31425: PUSH
31426: LD_INT 1
31428: ARRAY
31429: PUSH
31430: LD_VAR 0 1
31434: ADD
31435: PPUSH
31436: CALL_OW 1
31440: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31441: LD_INT 260
31443: PPUSH
31444: LD_INT 235
31446: PPUSH
31447: LD_INT 1
31449: PPUSH
31450: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31454: LD_VAR 0 1
31458: PPUSH
31459: LD_INT 1000
31461: PPUSH
31462: CALL_OW 234
// DialogueOff ;
31466: CALL_OW 7
// ComFree ( unit ) ;
31470: LD_VAR 0 1
31474: PPUSH
31475: CALL_OW 139
// end else
31479: GO 31562
// begin Say ( Roth , DA-Roth-3a ) ;
31481: LD_EXP 71
31485: PPUSH
31486: LD_STRING DA-Roth-3a
31488: PPUSH
31489: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31493: LD_ADDR_EXP 35
31497: PUSH
31498: LD_EXP 35
31502: PUSH
31503: LD_VAR 0 1
31507: ADD
31508: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31509: LD_INT 260
31511: PPUSH
31512: LD_INT 235
31514: PPUSH
31515: LD_INT 1
31517: PPUSH
31518: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31522: LD_VAR 0 1
31526: PPUSH
31527: LD_INT 1000
31529: PPUSH
31530: CALL_OW 234
// DialogueOff ;
31534: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31538: LD_VAR 0 1
31542: PPUSH
31543: LD_INT 272
31545: PPUSH
31546: LD_INT 254
31548: PPUSH
31549: CALL_OW 111
// AddComHold ( unit ) ;
31553: LD_VAR 0 1
31557: PPUSH
31558: CALL_OW 200
// end ; if capturedUnit = 1 then
31562: LD_EXP 34
31566: PUSH
31567: LD_INT 1
31569: EQUAL
31570: IFFALSE 31625
// begin DialogueOn ;
31572: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31576: LD_EXP 36
31580: PPUSH
31581: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31585: LD_EXP 36
31589: PPUSH
31590: LD_STRING DAa-JMM-1
31592: PPUSH
31593: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31597: LD_EXP 36
31601: PPUSH
31602: LD_STRING DAa-JMM-1a
31604: PPUSH
31605: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31609: LD_EXP 36
31613: PPUSH
31614: LD_STRING DAa-JMM-1b
31616: PPUSH
31617: CALL_OW 88
// DialogueOff ;
31621: CALL_OW 7
// end ; end ;
31625: LD_VAR 0 2
31629: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31630: LD_EXP 15
31634: PUSH
31635: LD_INT 13
31637: GREATEREQUAL
31638: PUSH
31639: LD_INT 22
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 21
31651: PUSH
31652: LD_INT 1
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PPUSH
31663: CALL_OW 69
31667: PUSH
31668: LD_INT 0
31670: EQUAL
31671: AND
31672: PUSH
31673: LD_INT 22
31675: PUSH
31676: LD_INT 2
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 21
31685: PUSH
31686: LD_INT 2
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 50
31695: PUSH
31696: EMPTY
31697: LIST
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: LIST
31703: PPUSH
31704: CALL_OW 69
31708: PUSH
31709: LD_INT 0
31711: EQUAL
31712: AND
31713: PUSH
31714: LD_EXP 21
31718: AND
31719: PUSH
31720: LD_EXP 22
31724: AND
31725: PUSH
31726: LD_EXP 23
31730: AND
31731: IFFALSE 32244
31733: GO 31735
31735: DISABLE
// begin CenterNowOnUnits ( JMM ) ;
31736: LD_EXP 36
31740: PPUSH
31741: CALL_OW 87
// music_class := 5 ;
31745: LD_ADDR_OWVAR 72
31749: PUSH
31750: LD_INT 5
31752: ST_TO_ADDR
// music_nat := 5 ;
31753: LD_ADDR_OWVAR 71
31757: PUSH
31758: LD_INT 5
31760: ST_TO_ADDR
// DialogueOn ;
31761: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
31765: LD_EXP 36
31769: PPUSH
31770: LD_STRING D20-JMM-1
31772: PPUSH
31773: CALL_OW 88
// if IsOK ( Joan ) then
31777: LD_EXP 37
31781: PPUSH
31782: CALL_OW 302
31786: IFFALSE 31800
// Say ( Joan , D20-Joan-1 ) ;
31788: LD_EXP 37
31792: PPUSH
31793: LD_STRING D20-Joan-1
31795: PPUSH
31796: CALL_OW 88
// if IsOk ( Lisa ) then
31800: LD_EXP 39
31804: PPUSH
31805: CALL_OW 302
31809: IFFALSE 31823
// Say ( Lisa , D20-Lisa-1 ) ;
31811: LD_EXP 39
31815: PPUSH
31816: LD_STRING D20-Lisa-1
31818: PPUSH
31819: CALL_OW 88
// if IsOk ( Donaldson ) then
31823: LD_EXP 40
31827: PPUSH
31828: CALL_OW 302
31832: IFFALSE 31846
// Say ( Donaldson , D20-Don-1 ) ;
31834: LD_EXP 40
31838: PPUSH
31839: LD_STRING D20-Don-1
31841: PPUSH
31842: CALL_OW 88
// if IsOK ( Cornel ) then
31846: LD_EXP 47
31850: PPUSH
31851: CALL_OW 302
31855: IFFALSE 31869
// Say ( Cornel , D20-Corn-1 ) ;
31857: LD_EXP 47
31861: PPUSH
31862: LD_STRING D20-Corn-1
31864: PPUSH
31865: CALL_OW 88
// if IsOk ( Denis ) then
31869: LD_EXP 43
31873: PPUSH
31874: CALL_OW 302
31878: IFFALSE 31892
// Say ( Denis , D20-Den-1 ) ;
31880: LD_EXP 43
31884: PPUSH
31885: LD_STRING D20-Den-1
31887: PPUSH
31888: CALL_OW 88
// if IsOk ( Bobby ) then
31892: LD_EXP 41
31896: PPUSH
31897: CALL_OW 302
31901: IFFALSE 31915
// Say ( Bobby , D20-Bobby-1 ) ;
31903: LD_EXP 41
31907: PPUSH
31908: LD_STRING D20-Bobby-1
31910: PPUSH
31911: CALL_OW 88
// if IsOk ( Gladstone ) then
31915: LD_EXP 45
31919: PPUSH
31920: CALL_OW 302
31924: IFFALSE 31938
// Say ( Gladstone , D20-Glad-1 ) ;
31926: LD_EXP 45
31930: PPUSH
31931: LD_STRING D20-Glad-1
31933: PPUSH
31934: CALL_OW 88
// if IsOk ( Cyrus ) then
31938: LD_EXP 42
31942: PPUSH
31943: CALL_OW 302
31947: IFFALSE 31961
// Say ( Cyrus , D20-Cyrus-1 ) ;
31949: LD_EXP 42
31953: PPUSH
31954: LD_STRING D20-Cyrus-1
31956: PPUSH
31957: CALL_OW 88
// if IsOk ( Stevens ) then
31961: LD_EXP 38
31965: PPUSH
31966: CALL_OW 302
31970: IFFALSE 31984
// Say ( Stevens , D20-Huck-1 ) ;
31972: LD_EXP 38
31976: PPUSH
31977: LD_STRING D20-Huck-1
31979: PPUSH
31980: CALL_OW 88
// if IsOk ( Brown ) then
31984: LD_EXP 44
31988: PPUSH
31989: CALL_OW 302
31993: IFFALSE 32007
// Say ( Brown , D20-Brown-1 ) ;
31995: LD_EXP 44
31999: PPUSH
32000: LD_STRING D20-Brown-1
32002: PPUSH
32003: CALL_OW 88
// if IsOk ( Gary ) then
32007: LD_EXP 48
32011: PPUSH
32012: CALL_OW 302
32016: IFFALSE 32030
// Say ( Gary , D20-Gary-1 ) ;
32018: LD_EXP 48
32022: PPUSH
32023: LD_STRING D20-Gary-1
32025: PPUSH
32026: CALL_OW 88
// if IsOk ( Connie ) then
32030: LD_EXP 51
32034: PPUSH
32035: CALL_OW 302
32039: IFFALSE 32053
// Say ( Connie , D20-Con-1 ) ;
32041: LD_EXP 51
32045: PPUSH
32046: LD_STRING D20-Con-1
32048: PPUSH
32049: CALL_OW 88
// if IsOk ( Kurt ) then
32053: LD_EXP 57
32057: PPUSH
32058: CALL_OW 302
32062: IFFALSE 32076
// Say ( Kurt , D20-Kurt-1 ) ;
32064: LD_EXP 57
32068: PPUSH
32069: LD_STRING D20-Kurt-1
32071: PPUSH
32072: CALL_OW 88
// if IsOk ( Kikuchi ) then
32076: LD_EXP 50
32080: PPUSH
32081: CALL_OW 302
32085: IFFALSE 32099
// Say ( Kikuchi , D20-Yam-1 ) ;
32087: LD_EXP 50
32091: PPUSH
32092: LD_STRING D20-Yam-1
32094: PPUSH
32095: CALL_OW 88
// if IsOk ( Frank ) then
32099: LD_EXP 49
32103: PPUSH
32104: CALL_OW 302
32108: IFFALSE 32122
// Say ( Frank , D20-Frank-1 ) ;
32110: LD_EXP 49
32114: PPUSH
32115: LD_STRING D20-Frank-1
32117: PPUSH
32118: CALL_OW 88
// DialogueOff ;
32122: CALL_OW 7
// if RothCaptured then
32126: LD_EXP 33
32130: IFFALSE 32144
// AddMedal ( Roth , 1 ) else
32132: LD_STRING Roth
32134: PPUSH
32135: LD_INT 1
32137: PPUSH
32138: CALL_OW 101
32142: GO 32155
// AddMedal ( Roth , - 1 ) ;
32144: LD_STRING Roth
32146: PPUSH
32147: LD_INT 1
32149: NEG
32150: PPUSH
32151: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32155: LD_EXP 27
32159: IFFALSE 32173
// AddMedal ( Project , 1 ) else
32161: LD_STRING Project
32163: PPUSH
32164: LD_INT 1
32166: PPUSH
32167: CALL_OW 101
32171: GO 32184
// AddMedal ( Project , - 1 ) ;
32173: LD_STRING Project
32175: PPUSH
32176: LD_INT 1
32178: NEG
32179: PPUSH
32180: CALL_OW 101
// if lostCounter = 0 then
32184: LD_EXP 32
32188: PUSH
32189: LD_INT 0
32191: EQUAL
32192: IFFALSE 32206
// AddMedal ( NoLosses , 1 ) else
32194: LD_STRING NoLosses
32196: PPUSH
32197: LD_INT 1
32199: PPUSH
32200: CALL_OW 101
32204: GO 32217
// AddMedal ( NoLosses , - 1 ) ;
32206: LD_STRING NoLosses
32208: PPUSH
32209: LD_INT 1
32211: NEG
32212: PPUSH
32213: CALL_OW 101
// GiveMedals ( MAIN ) ;
32217: LD_STRING MAIN
32219: PPUSH
32220: CALL_OW 102
// music_class := 4 ;
32224: LD_ADDR_OWVAR 72
32228: PUSH
32229: LD_INT 4
32231: ST_TO_ADDR
// music_nat := 1 ;
32232: LD_ADDR_OWVAR 71
32236: PUSH
32237: LD_INT 1
32239: ST_TO_ADDR
// YouWin ;
32240: CALL_OW 103
// end ; end_of_file
32244: END
// export function CustomEvent ( event ) ; begin
32245: LD_INT 0
32247: PPUSH
// end ;
32248: LD_VAR 0 2
32252: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32253: LD_VAR 0 1
32257: PUSH
32258: LD_INT 1
32260: EQUAL
32261: PUSH
32262: LD_VAR 0 2
32266: PUSH
32267: LD_INT 4
32269: EQUAL
32270: AND
32271: PUSH
32272: LD_EXP 55
32276: PPUSH
32277: CALL_OW 300
32281: AND
32282: IFFALSE 32298
// begin wait ( 0 0$2 ) ;
32284: LD_INT 70
32286: PPUSH
32287: CALL_OW 67
// YouLost ( Dismissed ) ;
32291: LD_STRING Dismissed
32293: PPUSH
32294: CALL_OW 104
// end ; end ;
32298: PPOPN 2
32300: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32301: LD_VAR 0 2
32305: PPUSH
32306: LD_VAR 0 3
32310: PPUSH
32311: LD_INT 18
32313: PPUSH
32314: CALL_OW 309
32318: IFFALSE 32327
// YouLost ( Motherlode3 ) ;
32320: LD_STRING Motherlode3
32322: PPUSH
32323: CALL_OW 104
// end ;
32327: PPOPN 3
32329: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32330: LD_EXP 27
32334: NOT
32335: IFFALSE 32345
// behemothDone := true ;
32337: LD_ADDR_EXP 28
32341: PUSH
32342: LD_INT 1
32344: ST_TO_ADDR
// end ;
32345: PPOPN 1
32347: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32348: LD_VAR 0 1
32352: PPUSH
32353: CALL_OW 255
32357: PUSH
32358: LD_INT 1
32360: EQUAL
32361: PUSH
32362: LD_EXP 30
32366: AND
32367: PUSH
32368: LD_INT 22
32370: PUSH
32371: LD_INT 3
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 34
32380: PUSH
32381: LD_INT 48
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PPUSH
32392: CALL_OW 69
32396: AND
32397: PUSH
32398: LD_INT 22
32400: PUSH
32401: LD_INT 1
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 34
32410: PUSH
32411: LD_INT 8
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PPUSH
32422: CALL_OW 69
32426: NOT
32427: AND
32428: IFFALSE 32480
// begin wait ( 0 0$5 ) ;
32430: LD_INT 175
32432: PPUSH
32433: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32437: LD_INT 22
32439: PUSH
32440: LD_INT 3
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 34
32449: PUSH
32450: LD_INT 48
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PPUSH
32461: CALL_OW 69
32465: PUSH
32466: LD_INT 1
32468: ARRAY
32469: PPUSH
32470: LD_INT 60
32472: PPUSH
32473: LD_INT 95
32475: PPUSH
32476: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32480: LD_VAR 0 2
32484: PPUSH
32485: LD_VAR 0 3
32489: PPUSH
32490: LD_INT 18
32492: PPUSH
32493: CALL_OW 309
32497: IFFALSE 32557
// begin if GetSide ( unit ) = 1 then
32499: LD_VAR 0 1
32503: PPUSH
32504: CALL_OW 255
32508: PUSH
32509: LD_INT 1
32511: EQUAL
32512: IFFALSE 32528
// begin wait ( 0 0$6 ) ;
32514: LD_INT 210
32516: PPUSH
32517: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32521: LD_STRING Motherlode2
32523: PPUSH
32524: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32528: LD_VAR 0 1
32532: PPUSH
32533: CALL_OW 255
32537: PUSH
32538: LD_INT 8
32540: EQUAL
32541: IFFALSE 32557
// begin wait ( 0 0$6 ) ;
32543: LD_INT 210
32545: PPUSH
32546: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32550: LD_STRING Motherlode1
32552: PPUSH
32553: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32557: LD_VAR 0 1
32561: PPUSH
32562: CALL_OW 255
32566: PUSH
32567: LD_INT 3
32569: EQUAL
32570: IFFALSE 32591
// begin wait ( 0 0$5 ) ;
32572: LD_INT 175
32574: PPUSH
32575: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32579: LD_EXP 61
32583: PPUSH
32584: LD_STRING D18-Pla-1
32586: PPUSH
32587: CALL_OW 94
// end ; end ;
32591: PPOPN 3
32593: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32594: LD_VAR 0 1
32598: PUSH
32599: LD_EXP 70
32603: IN
32604: IFFALSE 32624
// begin behemothBuilders := behemothBuilders diff un ;
32606: LD_ADDR_EXP 70
32610: PUSH
32611: LD_EXP 70
32615: PUSH
32616: LD_VAR 0 1
32620: DIFF
32621: ST_TO_ADDR
// exit ;
32622: GO 32722
// end ; if un = JMM then
32624: LD_VAR 0 1
32628: PUSH
32629: LD_EXP 36
32633: EQUAL
32634: IFFALSE 32645
// begin YouLost ( JMM ) ;
32636: LD_STRING JMM
32638: PPUSH
32639: CALL_OW 104
// exit ;
32643: GO 32722
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32645: LD_VAR 0 1
32649: PUSH
32650: LD_INT 22
32652: PUSH
32653: LD_INT 1
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 3
32662: PUSH
32663: LD_INT 25
32665: PUSH
32666: LD_INT 16
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 25
32675: PUSH
32676: LD_INT 12
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: LIST
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PPUSH
32692: CALL_OW 69
32696: IN
32697: IFFALSE 32713
// lostCounter := lostCounter + 1 ;
32699: LD_ADDR_EXP 32
32703: PUSH
32704: LD_EXP 32
32708: PUSH
32709: LD_INT 1
32711: PLUS
32712: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32713: LD_VAR 0 1
32717: PPUSH
32718: CALL 60790 0 1
// end ;
32722: PPOPN 1
32724: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32725: LD_VAR 0 1
32729: PPUSH
32730: LD_VAR 0 2
32734: PPUSH
32735: CALL 62990 0 2
// end ;
32739: PPOPN 2
32741: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32742: LD_VAR 0 1
32746: PPUSH
32747: CALL 62058 0 1
// end ;
32751: PPOPN 1
32753: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32754: LD_VAR 0 1
32758: PUSH
32759: LD_INT 22
32761: PUSH
32762: LD_INT 8
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 30
32771: PUSH
32772: LD_INT 2
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: LD_INT 23
32781: PUSH
32782: LD_INT 3
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: LIST
32793: PPUSH
32794: CALL_OW 69
32798: IN
32799: IFFALSE 32826
// begin ComUpgrade ( building ) ;
32801: LD_VAR 0 1
32805: PPUSH
32806: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32810: LD_EXP 58
32814: PPUSH
32815: LD_VAR 0 1
32819: PPUSH
32820: CALL 73358 0 2
// exit ;
32824: GO 32835
// end ; MCE_BuildingComplete ( building ) ;
32826: LD_VAR 0 1
32830: PPUSH
32831: CALL 62299 0 1
// end ;
32835: PPOPN 1
32837: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32838: LD_VAR 0 1
32842: PPUSH
32843: LD_VAR 0 2
32847: PPUSH
32848: CALL 60486 0 2
// end ;
32852: PPOPN 2
32854: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32855: LD_VAR 0 1
32859: PPUSH
32860: LD_VAR 0 2
32864: PPUSH
32865: LD_VAR 0 3
32869: PPUSH
32870: LD_VAR 0 4
32874: PPUSH
32875: LD_VAR 0 5
32879: PPUSH
32880: CALL 60106 0 5
// end ;
32884: PPOPN 5
32886: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32887: LD_VAR 0 1
32891: PPUSH
32892: LD_VAR 0 2
32896: PPUSH
32897: CALL 59702 0 2
// end ;
32901: PPOPN 2
32903: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32904: LD_VAR 0 1
32908: PPUSH
32909: LD_VAR 0 2
32913: PPUSH
32914: LD_VAR 0 3
32918: PPUSH
32919: LD_VAR 0 4
32923: PPUSH
32924: CALL 59540 0 4
// end ;
32928: PPOPN 4
32930: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32931: LD_VAR 0 1
32935: PPUSH
32936: LD_VAR 0 2
32940: PPUSH
32941: LD_VAR 0 3
32945: PPUSH
32946: CALL 59315 0 3
// end ;
32950: PPOPN 3
32952: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32953: LD_VAR 0 1
32957: PPUSH
32958: LD_VAR 0 2
32962: PPUSH
32963: CALL 59200 0 2
// end ;
32967: PPOPN 2
32969: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32970: LD_VAR 0 1
32974: PPUSH
32975: LD_VAR 0 2
32979: PPUSH
32980: CALL 63251 0 2
// end ;
32984: PPOPN 2
32986: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32987: LD_VAR 0 1
32991: PPUSH
32992: CALL_OW 255
32996: PUSH
32997: LD_INT 4
32999: EQUAL
33000: PUSH
33001: LD_VAR 0 1
33005: PUSH
33006: LD_EXP 18
33010: PUSH
33011: LD_INT 1
33013: ARRAY
33014: IN
33015: AND
33016: PUSH
33017: LD_EXP 19
33021: AND
33022: IFFALSE 33041
// begin ComMoveXY ( driver , 61 , 93 ) ;
33024: LD_VAR 0 1
33028: PPUSH
33029: LD_INT 61
33031: PPUSH
33032: LD_INT 93
33034: PPUSH
33035: CALL_OW 111
// exit ;
33039: GO 33065
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33041: LD_VAR 0 1
33045: PPUSH
33046: LD_VAR 0 2
33050: PPUSH
33051: LD_VAR 0 3
33055: PPUSH
33056: LD_VAR 0 4
33060: PPUSH
33061: CALL 63467 0 4
// end ;
33065: PPOPN 4
33067: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33068: LD_VAR 0 1
33072: PPUSH
33073: LD_VAR 0 2
33077: PPUSH
33078: CALL 59009 0 2
// end ;
33082: PPOPN 2
33084: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33085: LD_VAR 0 1
33089: PPUSH
33090: CALL 106530 0 1
// end ; end_of_file
33094: PPOPN 1
33096: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33097: LD_EXP 15
33101: PUSH
33102: LD_INT 2
33104: EQUAL
33105: IFFALSE 33584
33107: GO 33109
33109: DISABLE
33110: LD_INT 0
33112: PPUSH
// begin time := 0 0$40 ;
33113: LD_ADDR_VAR 0 1
33117: PUSH
33118: LD_INT 1400
33120: ST_TO_ADDR
// repeat wait ( time ) ;
33121: LD_VAR 0 1
33125: PPUSH
33126: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33130: LD_INT 1
33132: PPUSH
33133: LD_INT 5
33135: PPUSH
33136: CALL_OW 12
33140: PPUSH
33141: LD_INT 106
33143: PPUSH
33144: LD_INT 150
33146: PPUSH
33147: LD_INT 19
33149: PPUSH
33150: LD_INT 1
33152: PPUSH
33153: CALL_OW 56
// time := time + 0 0$9 ;
33157: LD_ADDR_VAR 0 1
33161: PUSH
33162: LD_VAR 0 1
33166: PUSH
33167: LD_INT 315
33169: PLUS
33170: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33171: LD_INT 455
33173: PPUSH
33174: LD_INT 840
33176: PPUSH
33177: CALL_OW 12
33181: PPUSH
33182: CALL_OW 67
// if Prob ( 50 ) then
33186: LD_INT 50
33188: PPUSH
33189: CALL_OW 13
33193: IFFALSE 33222
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33195: LD_INT 1
33197: PPUSH
33198: LD_INT 5
33200: PPUSH
33201: CALL_OW 12
33205: PPUSH
33206: LD_INT 62
33208: PPUSH
33209: LD_INT 108
33211: PPUSH
33212: LD_INT 10
33214: PPUSH
33215: LD_INT 1
33217: PPUSH
33218: CALL_OW 56
// until missionStage > 4 ;
33222: LD_EXP 15
33226: PUSH
33227: LD_INT 4
33229: GREATER
33230: IFFALSE 33121
// repeat wait ( 0 0$1 ) ;
33232: LD_INT 35
33234: PPUSH
33235: CALL_OW 67
// until missionStage = 6 ;
33239: LD_EXP 15
33243: PUSH
33244: LD_INT 6
33246: EQUAL
33247: IFFALSE 33232
// time := 0 0$50 ;
33249: LD_ADDR_VAR 0 1
33253: PUSH
33254: LD_INT 1750
33256: ST_TO_ADDR
// repeat wait ( time ) ;
33257: LD_VAR 0 1
33261: PPUSH
33262: CALL_OW 67
// if Prob ( 50 ) then
33266: LD_INT 50
33268: PPUSH
33269: CALL_OW 13
33273: IFFALSE 33302
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33275: LD_INT 1
33277: PPUSH
33278: LD_INT 5
33280: PPUSH
33281: CALL_OW 12
33285: PPUSH
33286: LD_INT 106
33288: PPUSH
33289: LD_INT 89
33291: PPUSH
33292: LD_INT 45
33294: PPUSH
33295: LD_INT 1
33297: PPUSH
33298: CALL_OW 56
// time := time + 0 0$3 ;
33302: LD_ADDR_VAR 0 1
33306: PUSH
33307: LD_VAR 0 1
33311: PUSH
33312: LD_INT 105
33314: PLUS
33315: ST_TO_ADDR
// if Prob ( 30 ) then
33316: LD_INT 30
33318: PPUSH
33319: CALL_OW 13
33323: IFFALSE 33369
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33325: LD_INT 525
33327: PPUSH
33328: LD_INT 735
33330: PPUSH
33331: CALL_OW 12
33335: PPUSH
33336: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33340: LD_INT 1
33342: PPUSH
33343: LD_INT 5
33345: PPUSH
33346: CALL_OW 12
33350: PPUSH
33351: LD_INT 21
33353: PPUSH
33354: LD_INT 26
33356: PPUSH
33357: LD_INT 12
33359: PPUSH
33360: LD_INT 1
33362: PPUSH
33363: CALL_OW 56
// end else
33367: GO 33405
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33369: LD_INT 700
33371: PPUSH
33372: LD_INT 1225
33374: PPUSH
33375: CALL_OW 12
33379: PPUSH
33380: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33384: LD_INT 1
33386: PPUSH
33387: LD_INT 5
33389: PPUSH
33390: CALL_OW 12
33394: PPUSH
33395: LD_INT 16
33397: PPUSH
33398: LD_INT 1
33400: PPUSH
33401: CALL_OW 55
// end ; if Prob ( 50 ) then
33405: LD_INT 50
33407: PPUSH
33408: CALL_OW 13
33412: IFFALSE 33458
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33414: LD_INT 700
33416: PPUSH
33417: LD_INT 1050
33419: PPUSH
33420: CALL_OW 12
33424: PPUSH
33425: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33429: LD_INT 1
33431: PPUSH
33432: LD_INT 5
33434: PPUSH
33435: CALL_OW 12
33439: PPUSH
33440: LD_INT 181
33442: PPUSH
33443: LD_INT 218
33445: PPUSH
33446: LD_INT 16
33448: PPUSH
33449: LD_INT 1
33451: PPUSH
33452: CALL_OW 56
// end else
33456: GO 33494
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33458: LD_INT 350
33460: PPUSH
33461: LD_INT 525
33463: PPUSH
33464: CALL_OW 12
33468: PPUSH
33469: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33473: LD_INT 1
33475: PPUSH
33476: LD_INT 5
33478: PPUSH
33479: CALL_OW 12
33483: PPUSH
33484: LD_INT 15
33486: PPUSH
33487: LD_INT 1
33489: PPUSH
33490: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33494: LD_INT 45
33496: PUSH
33497: LD_INT 32
33499: PUSH
33500: LD_INT 25
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: LIST
33507: PUSH
33508: LD_OWVAR 67
33512: ARRAY
33513: PPUSH
33514: CALL_OW 13
33518: IFFALSE 33562
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33520: LD_INT 525
33522: PPUSH
33523: LD_INT 875
33525: PPUSH
33526: CALL_OW 12
33530: PPUSH
33531: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33535: LD_INT 1
33537: PPUSH
33538: LD_INT 5
33540: PPUSH
33541: CALL_OW 12
33545: PPUSH
33546: LD_INT 103
33548: PPUSH
33549: LD_INT 140
33551: PPUSH
33552: LD_INT 20
33554: PPUSH
33555: LD_INT 1
33557: PPUSH
33558: CALL_OW 56
// end ; if time > 2 2$20 then
33562: LD_VAR 0 1
33566: PUSH
33567: LD_INT 4900
33569: GREATER
33570: IFFALSE 33580
// time := 0 0$50 ;
33572: LD_ADDR_VAR 0 1
33576: PUSH
33577: LD_INT 1750
33579: ST_TO_ADDR
// until false ;
33580: LD_INT 0
33582: IFFALSE 33257
// end ; end_of_file
33584: PPOPN 1
33586: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33587: LD_EXP 13
33591: PUSH
33592: LD_EXP 15
33596: PUSH
33597: LD_INT 6
33599: GREATEREQUAL
33600: AND
33601: IFFALSE 33638
33603: GO 33605
33605: DISABLE
// begin enable ;
33606: ENABLE
// missionTime := missionTime + 0 0$1 ;
33607: LD_ADDR_EXP 14
33611: PUSH
33612: LD_EXP 14
33616: PUSH
33617: LD_INT 35
33619: PLUS
33620: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33621: LD_ADDR_OWVAR 47
33625: PUSH
33626: LD_STRING #Am15-1
33628: PUSH
33629: LD_EXP 14
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: ST_TO_ADDR
// end ; end_of_file
33638: END
// export function InitNature ; begin
33639: LD_INT 0
33641: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33642: LD_INT 3
33644: PPUSH
33645: LD_INT 3
33647: PPUSH
33648: LD_INT 2
33650: PPUSH
33651: LD_INT 1
33653: PPUSH
33654: LD_INT 1
33656: PPUSH
33657: LD_INT 0
33659: PPUSH
33660: LD_INT 0
33662: PPUSH
33663: LD_INT 20
33665: PPUSH
33666: LD_INT 0
33668: PPUSH
33669: CALL 98199 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33673: LD_INT 2
33675: PPUSH
33676: LD_INT 1
33678: PPUSH
33679: LD_INT 1
33681: PPUSH
33682: LD_INT 1
33684: PPUSH
33685: LD_INT 1
33687: PPUSH
33688: LD_INT 0
33690: PPUSH
33691: LD_INT 0
33693: PPUSH
33694: LD_INT 21
33696: PPUSH
33697: LD_INT 0
33699: PPUSH
33700: CALL 98199 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33704: LD_INT 4
33706: PPUSH
33707: LD_INT 1
33709: PPUSH
33710: LD_INT 2
33712: PPUSH
33713: LD_INT 4
33715: PPUSH
33716: LD_INT 2
33718: PPUSH
33719: LD_INT 1
33721: PPUSH
33722: LD_INT 0
33724: PPUSH
33725: LD_INT 22
33727: PPUSH
33728: LD_INT 0
33730: PPUSH
33731: CALL 98199 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33735: LD_INT 0
33737: PPUSH
33738: LD_INT 0
33740: PPUSH
33741: LD_INT 0
33743: PPUSH
33744: LD_INT 0
33746: PPUSH
33747: LD_INT 0
33749: PPUSH
33750: LD_INT 0
33752: PPUSH
33753: LD_INT 9
33755: PPUSH
33756: LD_INT 0
33758: PPUSH
33759: LD_INT 23
33761: PPUSH
33762: CALL 98199 0 9
// end ; end_of_file
33766: LD_VAR 0 1
33770: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33771: GO 33773
33773: DISABLE
// begin ru_radar := 98 ;
33774: LD_ADDR_EXP 92
33778: PUSH
33779: LD_INT 98
33781: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33782: LD_ADDR_EXP 93
33786: PUSH
33787: LD_INT 89
33789: ST_TO_ADDR
// us_hack := 99 ;
33790: LD_ADDR_EXP 94
33794: PUSH
33795: LD_INT 99
33797: ST_TO_ADDR
// us_artillery := 97 ;
33798: LD_ADDR_EXP 95
33802: PUSH
33803: LD_INT 97
33805: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33806: LD_ADDR_EXP 96
33810: PUSH
33811: LD_INT 91
33813: ST_TO_ADDR
// end ; end_of_file
33814: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33815: LD_INT 0
33817: PPUSH
33818: PPUSH
// skirmish := false ;
33819: LD_ADDR_EXP 97
33823: PUSH
33824: LD_INT 0
33826: ST_TO_ADDR
// debug_mc := false ;
33827: LD_ADDR_EXP 98
33831: PUSH
33832: LD_INT 0
33834: ST_TO_ADDR
// mc_bases := [ ] ;
33835: LD_ADDR_EXP 99
33839: PUSH
33840: EMPTY
33841: ST_TO_ADDR
// mc_sides := [ ] ;
33842: LD_ADDR_EXP 125
33846: PUSH
33847: EMPTY
33848: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33849: LD_ADDR_EXP 100
33853: PUSH
33854: EMPTY
33855: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33856: LD_ADDR_EXP 101
33860: PUSH
33861: EMPTY
33862: ST_TO_ADDR
// mc_need_heal := [ ] ;
33863: LD_ADDR_EXP 102
33867: PUSH
33868: EMPTY
33869: ST_TO_ADDR
// mc_healers := [ ] ;
33870: LD_ADDR_EXP 103
33874: PUSH
33875: EMPTY
33876: ST_TO_ADDR
// mc_build_list := [ ] ;
33877: LD_ADDR_EXP 104
33881: PUSH
33882: EMPTY
33883: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33884: LD_ADDR_EXP 131
33888: PUSH
33889: EMPTY
33890: ST_TO_ADDR
// mc_builders := [ ] ;
33891: LD_ADDR_EXP 105
33895: PUSH
33896: EMPTY
33897: ST_TO_ADDR
// mc_construct_list := [ ] ;
33898: LD_ADDR_EXP 106
33902: PUSH
33903: EMPTY
33904: ST_TO_ADDR
// mc_turret_list := [ ] ;
33905: LD_ADDR_EXP 107
33909: PUSH
33910: EMPTY
33911: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33912: LD_ADDR_EXP 108
33916: PUSH
33917: EMPTY
33918: ST_TO_ADDR
// mc_miners := [ ] ;
33919: LD_ADDR_EXP 113
33923: PUSH
33924: EMPTY
33925: ST_TO_ADDR
// mc_mines := [ ] ;
33926: LD_ADDR_EXP 112
33930: PUSH
33931: EMPTY
33932: ST_TO_ADDR
// mc_minefields := [ ] ;
33933: LD_ADDR_EXP 114
33937: PUSH
33938: EMPTY
33939: ST_TO_ADDR
// mc_crates := [ ] ;
33940: LD_ADDR_EXP 115
33944: PUSH
33945: EMPTY
33946: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33947: LD_ADDR_EXP 116
33951: PUSH
33952: EMPTY
33953: ST_TO_ADDR
// mc_crates_area := [ ] ;
33954: LD_ADDR_EXP 117
33958: PUSH
33959: EMPTY
33960: ST_TO_ADDR
// mc_vehicles := [ ] ;
33961: LD_ADDR_EXP 118
33965: PUSH
33966: EMPTY
33967: ST_TO_ADDR
// mc_attack := [ ] ;
33968: LD_ADDR_EXP 119
33972: PUSH
33973: EMPTY
33974: ST_TO_ADDR
// mc_produce := [ ] ;
33975: LD_ADDR_EXP 120
33979: PUSH
33980: EMPTY
33981: ST_TO_ADDR
// mc_defender := [ ] ;
33982: LD_ADDR_EXP 121
33986: PUSH
33987: EMPTY
33988: ST_TO_ADDR
// mc_parking := [ ] ;
33989: LD_ADDR_EXP 123
33993: PUSH
33994: EMPTY
33995: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33996: LD_ADDR_EXP 109
34000: PUSH
34001: EMPTY
34002: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34003: LD_ADDR_EXP 111
34007: PUSH
34008: EMPTY
34009: ST_TO_ADDR
// mc_scan := [ ] ;
34010: LD_ADDR_EXP 122
34014: PUSH
34015: EMPTY
34016: ST_TO_ADDR
// mc_scan_area := [ ] ;
34017: LD_ADDR_EXP 124
34021: PUSH
34022: EMPTY
34023: ST_TO_ADDR
// mc_tech := [ ] ;
34024: LD_ADDR_EXP 126
34028: PUSH
34029: EMPTY
34030: ST_TO_ADDR
// mc_class := [ ] ;
34031: LD_ADDR_EXP 140
34035: PUSH
34036: EMPTY
34037: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34038: LD_ADDR_EXP 141
34042: PUSH
34043: EMPTY
34044: ST_TO_ADDR
// end ;
34045: LD_VAR 0 1
34049: RET
// export function MC_Kill ( base ) ; begin
34050: LD_INT 0
34052: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34053: LD_ADDR_EXP 99
34057: PUSH
34058: LD_EXP 99
34062: PPUSH
34063: LD_VAR 0 1
34067: PPUSH
34068: EMPTY
34069: PPUSH
34070: CALL_OW 1
34074: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34075: LD_ADDR_EXP 100
34079: PUSH
34080: LD_EXP 100
34084: PPUSH
34085: LD_VAR 0 1
34089: PPUSH
34090: EMPTY
34091: PPUSH
34092: CALL_OW 1
34096: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34097: LD_ADDR_EXP 101
34101: PUSH
34102: LD_EXP 101
34106: PPUSH
34107: LD_VAR 0 1
34111: PPUSH
34112: EMPTY
34113: PPUSH
34114: CALL_OW 1
34118: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34119: LD_ADDR_EXP 102
34123: PUSH
34124: LD_EXP 102
34128: PPUSH
34129: LD_VAR 0 1
34133: PPUSH
34134: EMPTY
34135: PPUSH
34136: CALL_OW 1
34140: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34141: LD_ADDR_EXP 103
34145: PUSH
34146: LD_EXP 103
34150: PPUSH
34151: LD_VAR 0 1
34155: PPUSH
34156: EMPTY
34157: PPUSH
34158: CALL_OW 1
34162: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34163: LD_ADDR_EXP 104
34167: PUSH
34168: LD_EXP 104
34172: PPUSH
34173: LD_VAR 0 1
34177: PPUSH
34178: EMPTY
34179: PPUSH
34180: CALL_OW 1
34184: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34185: LD_ADDR_EXP 105
34189: PUSH
34190: LD_EXP 105
34194: PPUSH
34195: LD_VAR 0 1
34199: PPUSH
34200: EMPTY
34201: PPUSH
34202: CALL_OW 1
34206: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34207: LD_ADDR_EXP 106
34211: PUSH
34212: LD_EXP 106
34216: PPUSH
34217: LD_VAR 0 1
34221: PPUSH
34222: EMPTY
34223: PPUSH
34224: CALL_OW 1
34228: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34229: LD_ADDR_EXP 107
34233: PUSH
34234: LD_EXP 107
34238: PPUSH
34239: LD_VAR 0 1
34243: PPUSH
34244: EMPTY
34245: PPUSH
34246: CALL_OW 1
34250: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34251: LD_ADDR_EXP 108
34255: PUSH
34256: LD_EXP 108
34260: PPUSH
34261: LD_VAR 0 1
34265: PPUSH
34266: EMPTY
34267: PPUSH
34268: CALL_OW 1
34272: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34273: LD_ADDR_EXP 109
34277: PUSH
34278: LD_EXP 109
34282: PPUSH
34283: LD_VAR 0 1
34287: PPUSH
34288: EMPTY
34289: PPUSH
34290: CALL_OW 1
34294: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34295: LD_ADDR_EXP 110
34299: PUSH
34300: LD_EXP 110
34304: PPUSH
34305: LD_VAR 0 1
34309: PPUSH
34310: LD_INT 0
34312: PPUSH
34313: CALL_OW 1
34317: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34318: LD_ADDR_EXP 111
34322: PUSH
34323: LD_EXP 111
34327: PPUSH
34328: LD_VAR 0 1
34332: PPUSH
34333: EMPTY
34334: PPUSH
34335: CALL_OW 1
34339: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34340: LD_ADDR_EXP 112
34344: PUSH
34345: LD_EXP 112
34349: PPUSH
34350: LD_VAR 0 1
34354: PPUSH
34355: EMPTY
34356: PPUSH
34357: CALL_OW 1
34361: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34362: LD_ADDR_EXP 113
34366: PUSH
34367: LD_EXP 113
34371: PPUSH
34372: LD_VAR 0 1
34376: PPUSH
34377: EMPTY
34378: PPUSH
34379: CALL_OW 1
34383: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34384: LD_ADDR_EXP 114
34388: PUSH
34389: LD_EXP 114
34393: PPUSH
34394: LD_VAR 0 1
34398: PPUSH
34399: EMPTY
34400: PPUSH
34401: CALL_OW 1
34405: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34406: LD_ADDR_EXP 115
34410: PUSH
34411: LD_EXP 115
34415: PPUSH
34416: LD_VAR 0 1
34420: PPUSH
34421: EMPTY
34422: PPUSH
34423: CALL_OW 1
34427: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34428: LD_ADDR_EXP 116
34432: PUSH
34433: LD_EXP 116
34437: PPUSH
34438: LD_VAR 0 1
34442: PPUSH
34443: EMPTY
34444: PPUSH
34445: CALL_OW 1
34449: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34450: LD_ADDR_EXP 117
34454: PUSH
34455: LD_EXP 117
34459: PPUSH
34460: LD_VAR 0 1
34464: PPUSH
34465: EMPTY
34466: PPUSH
34467: CALL_OW 1
34471: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34472: LD_ADDR_EXP 118
34476: PUSH
34477: LD_EXP 118
34481: PPUSH
34482: LD_VAR 0 1
34486: PPUSH
34487: EMPTY
34488: PPUSH
34489: CALL_OW 1
34493: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34494: LD_ADDR_EXP 119
34498: PUSH
34499: LD_EXP 119
34503: PPUSH
34504: LD_VAR 0 1
34508: PPUSH
34509: EMPTY
34510: PPUSH
34511: CALL_OW 1
34515: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34516: LD_ADDR_EXP 120
34520: PUSH
34521: LD_EXP 120
34525: PPUSH
34526: LD_VAR 0 1
34530: PPUSH
34531: EMPTY
34532: PPUSH
34533: CALL_OW 1
34537: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34538: LD_ADDR_EXP 121
34542: PUSH
34543: LD_EXP 121
34547: PPUSH
34548: LD_VAR 0 1
34552: PPUSH
34553: EMPTY
34554: PPUSH
34555: CALL_OW 1
34559: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34560: LD_ADDR_EXP 122
34564: PUSH
34565: LD_EXP 122
34569: PPUSH
34570: LD_VAR 0 1
34574: PPUSH
34575: EMPTY
34576: PPUSH
34577: CALL_OW 1
34581: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34582: LD_ADDR_EXP 123
34586: PUSH
34587: LD_EXP 123
34591: PPUSH
34592: LD_VAR 0 1
34596: PPUSH
34597: EMPTY
34598: PPUSH
34599: CALL_OW 1
34603: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34604: LD_ADDR_EXP 124
34608: PUSH
34609: LD_EXP 124
34613: PPUSH
34614: LD_VAR 0 1
34618: PPUSH
34619: EMPTY
34620: PPUSH
34621: CALL_OW 1
34625: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34626: LD_ADDR_EXP 126
34630: PUSH
34631: LD_EXP 126
34635: PPUSH
34636: LD_VAR 0 1
34640: PPUSH
34641: EMPTY
34642: PPUSH
34643: CALL_OW 1
34647: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34648: LD_ADDR_EXP 128
34652: PUSH
34653: LD_EXP 128
34657: PPUSH
34658: LD_VAR 0 1
34662: PPUSH
34663: EMPTY
34664: PPUSH
34665: CALL_OW 1
34669: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34670: LD_ADDR_EXP 129
34674: PUSH
34675: LD_EXP 129
34679: PPUSH
34680: LD_VAR 0 1
34684: PPUSH
34685: EMPTY
34686: PPUSH
34687: CALL_OW 1
34691: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34692: LD_ADDR_EXP 130
34696: PUSH
34697: LD_EXP 130
34701: PPUSH
34702: LD_VAR 0 1
34706: PPUSH
34707: EMPTY
34708: PPUSH
34709: CALL_OW 1
34713: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34714: LD_ADDR_EXP 131
34718: PUSH
34719: LD_EXP 131
34723: PPUSH
34724: LD_VAR 0 1
34728: PPUSH
34729: EMPTY
34730: PPUSH
34731: CALL_OW 1
34735: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34736: LD_ADDR_EXP 132
34740: PUSH
34741: LD_EXP 132
34745: PPUSH
34746: LD_VAR 0 1
34750: PPUSH
34751: EMPTY
34752: PPUSH
34753: CALL_OW 1
34757: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34758: LD_ADDR_EXP 133
34762: PUSH
34763: LD_EXP 133
34767: PPUSH
34768: LD_VAR 0 1
34772: PPUSH
34773: EMPTY
34774: PPUSH
34775: CALL_OW 1
34779: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34780: LD_ADDR_EXP 134
34784: PUSH
34785: LD_EXP 134
34789: PPUSH
34790: LD_VAR 0 1
34794: PPUSH
34795: EMPTY
34796: PPUSH
34797: CALL_OW 1
34801: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34802: LD_ADDR_EXP 135
34806: PUSH
34807: LD_EXP 135
34811: PPUSH
34812: LD_VAR 0 1
34816: PPUSH
34817: EMPTY
34818: PPUSH
34819: CALL_OW 1
34823: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34824: LD_ADDR_EXP 136
34828: PUSH
34829: LD_EXP 136
34833: PPUSH
34834: LD_VAR 0 1
34838: PPUSH
34839: EMPTY
34840: PPUSH
34841: CALL_OW 1
34845: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34846: LD_ADDR_EXP 137
34850: PUSH
34851: LD_EXP 137
34855: PPUSH
34856: LD_VAR 0 1
34860: PPUSH
34861: EMPTY
34862: PPUSH
34863: CALL_OW 1
34867: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34868: LD_ADDR_EXP 138
34872: PUSH
34873: LD_EXP 138
34877: PPUSH
34878: LD_VAR 0 1
34882: PPUSH
34883: EMPTY
34884: PPUSH
34885: CALL_OW 1
34889: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34890: LD_ADDR_EXP 139
34894: PUSH
34895: LD_EXP 139
34899: PPUSH
34900: LD_VAR 0 1
34904: PPUSH
34905: EMPTY
34906: PPUSH
34907: CALL_OW 1
34911: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34912: LD_ADDR_EXP 140
34916: PUSH
34917: LD_EXP 140
34921: PPUSH
34922: LD_VAR 0 1
34926: PPUSH
34927: EMPTY
34928: PPUSH
34929: CALL_OW 1
34933: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34934: LD_ADDR_EXP 141
34938: PUSH
34939: LD_EXP 141
34943: PPUSH
34944: LD_VAR 0 1
34948: PPUSH
34949: LD_INT 0
34951: PPUSH
34952: CALL_OW 1
34956: ST_TO_ADDR
// end ;
34957: LD_VAR 0 2
34961: RET
// export function MC_Add ( side , units ) ; var base ; begin
34962: LD_INT 0
34964: PPUSH
34965: PPUSH
// base := mc_bases + 1 ;
34966: LD_ADDR_VAR 0 4
34970: PUSH
34971: LD_EXP 99
34975: PUSH
34976: LD_INT 1
34978: PLUS
34979: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
34980: LD_ADDR_EXP 125
34984: PUSH
34985: LD_EXP 125
34989: PPUSH
34990: LD_VAR 0 4
34994: PPUSH
34995: LD_VAR 0 1
34999: PPUSH
35000: CALL_OW 1
35004: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35005: LD_ADDR_EXP 99
35009: PUSH
35010: LD_EXP 99
35014: PPUSH
35015: LD_VAR 0 4
35019: PPUSH
35020: LD_VAR 0 2
35024: PPUSH
35025: CALL_OW 1
35029: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35030: LD_ADDR_EXP 100
35034: PUSH
35035: LD_EXP 100
35039: PPUSH
35040: LD_VAR 0 4
35044: PPUSH
35045: EMPTY
35046: PPUSH
35047: CALL_OW 1
35051: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35052: LD_ADDR_EXP 101
35056: PUSH
35057: LD_EXP 101
35061: PPUSH
35062: LD_VAR 0 4
35066: PPUSH
35067: EMPTY
35068: PPUSH
35069: CALL_OW 1
35073: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35074: LD_ADDR_EXP 102
35078: PUSH
35079: LD_EXP 102
35083: PPUSH
35084: LD_VAR 0 4
35088: PPUSH
35089: EMPTY
35090: PPUSH
35091: CALL_OW 1
35095: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35096: LD_ADDR_EXP 103
35100: PUSH
35101: LD_EXP 103
35105: PPUSH
35106: LD_VAR 0 4
35110: PPUSH
35111: EMPTY
35112: PPUSH
35113: CALL_OW 1
35117: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35118: LD_ADDR_EXP 104
35122: PUSH
35123: LD_EXP 104
35127: PPUSH
35128: LD_VAR 0 4
35132: PPUSH
35133: EMPTY
35134: PPUSH
35135: CALL_OW 1
35139: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35140: LD_ADDR_EXP 105
35144: PUSH
35145: LD_EXP 105
35149: PPUSH
35150: LD_VAR 0 4
35154: PPUSH
35155: EMPTY
35156: PPUSH
35157: CALL_OW 1
35161: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35162: LD_ADDR_EXP 106
35166: PUSH
35167: LD_EXP 106
35171: PPUSH
35172: LD_VAR 0 4
35176: PPUSH
35177: EMPTY
35178: PPUSH
35179: CALL_OW 1
35183: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35184: LD_ADDR_EXP 107
35188: PUSH
35189: LD_EXP 107
35193: PPUSH
35194: LD_VAR 0 4
35198: PPUSH
35199: EMPTY
35200: PPUSH
35201: CALL_OW 1
35205: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35206: LD_ADDR_EXP 108
35210: PUSH
35211: LD_EXP 108
35215: PPUSH
35216: LD_VAR 0 4
35220: PPUSH
35221: EMPTY
35222: PPUSH
35223: CALL_OW 1
35227: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35228: LD_ADDR_EXP 109
35232: PUSH
35233: LD_EXP 109
35237: PPUSH
35238: LD_VAR 0 4
35242: PPUSH
35243: EMPTY
35244: PPUSH
35245: CALL_OW 1
35249: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35250: LD_ADDR_EXP 110
35254: PUSH
35255: LD_EXP 110
35259: PPUSH
35260: LD_VAR 0 4
35264: PPUSH
35265: LD_INT 0
35267: PPUSH
35268: CALL_OW 1
35272: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35273: LD_ADDR_EXP 111
35277: PUSH
35278: LD_EXP 111
35282: PPUSH
35283: LD_VAR 0 4
35287: PPUSH
35288: EMPTY
35289: PPUSH
35290: CALL_OW 1
35294: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35295: LD_ADDR_EXP 112
35299: PUSH
35300: LD_EXP 112
35304: PPUSH
35305: LD_VAR 0 4
35309: PPUSH
35310: EMPTY
35311: PPUSH
35312: CALL_OW 1
35316: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35317: LD_ADDR_EXP 113
35321: PUSH
35322: LD_EXP 113
35326: PPUSH
35327: LD_VAR 0 4
35331: PPUSH
35332: EMPTY
35333: PPUSH
35334: CALL_OW 1
35338: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35339: LD_ADDR_EXP 114
35343: PUSH
35344: LD_EXP 114
35348: PPUSH
35349: LD_VAR 0 4
35353: PPUSH
35354: EMPTY
35355: PPUSH
35356: CALL_OW 1
35360: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35361: LD_ADDR_EXP 115
35365: PUSH
35366: LD_EXP 115
35370: PPUSH
35371: LD_VAR 0 4
35375: PPUSH
35376: EMPTY
35377: PPUSH
35378: CALL_OW 1
35382: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35383: LD_ADDR_EXP 116
35387: PUSH
35388: LD_EXP 116
35392: PPUSH
35393: LD_VAR 0 4
35397: PPUSH
35398: EMPTY
35399: PPUSH
35400: CALL_OW 1
35404: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35405: LD_ADDR_EXP 117
35409: PUSH
35410: LD_EXP 117
35414: PPUSH
35415: LD_VAR 0 4
35419: PPUSH
35420: EMPTY
35421: PPUSH
35422: CALL_OW 1
35426: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35427: LD_ADDR_EXP 118
35431: PUSH
35432: LD_EXP 118
35436: PPUSH
35437: LD_VAR 0 4
35441: PPUSH
35442: EMPTY
35443: PPUSH
35444: CALL_OW 1
35448: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35449: LD_ADDR_EXP 119
35453: PUSH
35454: LD_EXP 119
35458: PPUSH
35459: LD_VAR 0 4
35463: PPUSH
35464: EMPTY
35465: PPUSH
35466: CALL_OW 1
35470: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35471: LD_ADDR_EXP 120
35475: PUSH
35476: LD_EXP 120
35480: PPUSH
35481: LD_VAR 0 4
35485: PPUSH
35486: EMPTY
35487: PPUSH
35488: CALL_OW 1
35492: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35493: LD_ADDR_EXP 121
35497: PUSH
35498: LD_EXP 121
35502: PPUSH
35503: LD_VAR 0 4
35507: PPUSH
35508: EMPTY
35509: PPUSH
35510: CALL_OW 1
35514: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35515: LD_ADDR_EXP 122
35519: PUSH
35520: LD_EXP 122
35524: PPUSH
35525: LD_VAR 0 4
35529: PPUSH
35530: EMPTY
35531: PPUSH
35532: CALL_OW 1
35536: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35537: LD_ADDR_EXP 123
35541: PUSH
35542: LD_EXP 123
35546: PPUSH
35547: LD_VAR 0 4
35551: PPUSH
35552: EMPTY
35553: PPUSH
35554: CALL_OW 1
35558: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35559: LD_ADDR_EXP 124
35563: PUSH
35564: LD_EXP 124
35568: PPUSH
35569: LD_VAR 0 4
35573: PPUSH
35574: EMPTY
35575: PPUSH
35576: CALL_OW 1
35580: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35581: LD_ADDR_EXP 126
35585: PUSH
35586: LD_EXP 126
35590: PPUSH
35591: LD_VAR 0 4
35595: PPUSH
35596: EMPTY
35597: PPUSH
35598: CALL_OW 1
35602: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35603: LD_ADDR_EXP 128
35607: PUSH
35608: LD_EXP 128
35612: PPUSH
35613: LD_VAR 0 4
35617: PPUSH
35618: EMPTY
35619: PPUSH
35620: CALL_OW 1
35624: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35625: LD_ADDR_EXP 129
35629: PUSH
35630: LD_EXP 129
35634: PPUSH
35635: LD_VAR 0 4
35639: PPUSH
35640: EMPTY
35641: PPUSH
35642: CALL_OW 1
35646: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35647: LD_ADDR_EXP 130
35651: PUSH
35652: LD_EXP 130
35656: PPUSH
35657: LD_VAR 0 4
35661: PPUSH
35662: EMPTY
35663: PPUSH
35664: CALL_OW 1
35668: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35669: LD_ADDR_EXP 131
35673: PUSH
35674: LD_EXP 131
35678: PPUSH
35679: LD_VAR 0 4
35683: PPUSH
35684: EMPTY
35685: PPUSH
35686: CALL_OW 1
35690: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35691: LD_ADDR_EXP 132
35695: PUSH
35696: LD_EXP 132
35700: PPUSH
35701: LD_VAR 0 4
35705: PPUSH
35706: EMPTY
35707: PPUSH
35708: CALL_OW 1
35712: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35713: LD_ADDR_EXP 133
35717: PUSH
35718: LD_EXP 133
35722: PPUSH
35723: LD_VAR 0 4
35727: PPUSH
35728: EMPTY
35729: PPUSH
35730: CALL_OW 1
35734: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35735: LD_ADDR_EXP 134
35739: PUSH
35740: LD_EXP 134
35744: PPUSH
35745: LD_VAR 0 4
35749: PPUSH
35750: EMPTY
35751: PPUSH
35752: CALL_OW 1
35756: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35757: LD_ADDR_EXP 135
35761: PUSH
35762: LD_EXP 135
35766: PPUSH
35767: LD_VAR 0 4
35771: PPUSH
35772: EMPTY
35773: PPUSH
35774: CALL_OW 1
35778: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35779: LD_ADDR_EXP 136
35783: PUSH
35784: LD_EXP 136
35788: PPUSH
35789: LD_VAR 0 4
35793: PPUSH
35794: EMPTY
35795: PPUSH
35796: CALL_OW 1
35800: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35801: LD_ADDR_EXP 137
35805: PUSH
35806: LD_EXP 137
35810: PPUSH
35811: LD_VAR 0 4
35815: PPUSH
35816: EMPTY
35817: PPUSH
35818: CALL_OW 1
35822: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35823: LD_ADDR_EXP 138
35827: PUSH
35828: LD_EXP 138
35832: PPUSH
35833: LD_VAR 0 4
35837: PPUSH
35838: EMPTY
35839: PPUSH
35840: CALL_OW 1
35844: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35845: LD_ADDR_EXP 139
35849: PUSH
35850: LD_EXP 139
35854: PPUSH
35855: LD_VAR 0 4
35859: PPUSH
35860: EMPTY
35861: PPUSH
35862: CALL_OW 1
35866: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35867: LD_ADDR_EXP 140
35871: PUSH
35872: LD_EXP 140
35876: PPUSH
35877: LD_VAR 0 4
35881: PPUSH
35882: EMPTY
35883: PPUSH
35884: CALL_OW 1
35888: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35889: LD_ADDR_EXP 141
35893: PUSH
35894: LD_EXP 141
35898: PPUSH
35899: LD_VAR 0 4
35903: PPUSH
35904: LD_INT 0
35906: PPUSH
35907: CALL_OW 1
35911: ST_TO_ADDR
// result := base ;
35912: LD_ADDR_VAR 0 3
35916: PUSH
35917: LD_VAR 0 4
35921: ST_TO_ADDR
// end ;
35922: LD_VAR 0 3
35926: RET
// export function MC_Start ( ) ; var i ; begin
35927: LD_INT 0
35929: PPUSH
35930: PPUSH
// for i = 1 to mc_bases do
35931: LD_ADDR_VAR 0 2
35935: PUSH
35936: DOUBLE
35937: LD_INT 1
35939: DEC
35940: ST_TO_ADDR
35941: LD_EXP 99
35945: PUSH
35946: FOR_TO
35947: IFFALSE 37024
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
35949: LD_ADDR_EXP 99
35953: PUSH
35954: LD_EXP 99
35958: PPUSH
35959: LD_VAR 0 2
35963: PPUSH
35964: LD_EXP 99
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: PUSH
35975: LD_INT 0
35977: DIFF
35978: PPUSH
35979: CALL_OW 1
35983: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
35984: LD_ADDR_EXP 100
35988: PUSH
35989: LD_EXP 100
35993: PPUSH
35994: LD_VAR 0 2
35998: PPUSH
35999: EMPTY
36000: PPUSH
36001: CALL_OW 1
36005: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36006: LD_ADDR_EXP 101
36010: PUSH
36011: LD_EXP 101
36015: PPUSH
36016: LD_VAR 0 2
36020: PPUSH
36021: EMPTY
36022: PPUSH
36023: CALL_OW 1
36027: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36028: LD_ADDR_EXP 102
36032: PUSH
36033: LD_EXP 102
36037: PPUSH
36038: LD_VAR 0 2
36042: PPUSH
36043: EMPTY
36044: PPUSH
36045: CALL_OW 1
36049: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36050: LD_ADDR_EXP 103
36054: PUSH
36055: LD_EXP 103
36059: PPUSH
36060: LD_VAR 0 2
36064: PPUSH
36065: EMPTY
36066: PUSH
36067: EMPTY
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PPUSH
36073: CALL_OW 1
36077: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36078: LD_ADDR_EXP 104
36082: PUSH
36083: LD_EXP 104
36087: PPUSH
36088: LD_VAR 0 2
36092: PPUSH
36093: EMPTY
36094: PPUSH
36095: CALL_OW 1
36099: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36100: LD_ADDR_EXP 131
36104: PUSH
36105: LD_EXP 131
36109: PPUSH
36110: LD_VAR 0 2
36114: PPUSH
36115: EMPTY
36116: PPUSH
36117: CALL_OW 1
36121: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36122: LD_ADDR_EXP 105
36126: PUSH
36127: LD_EXP 105
36131: PPUSH
36132: LD_VAR 0 2
36136: PPUSH
36137: EMPTY
36138: PPUSH
36139: CALL_OW 1
36143: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36144: LD_ADDR_EXP 106
36148: PUSH
36149: LD_EXP 106
36153: PPUSH
36154: LD_VAR 0 2
36158: PPUSH
36159: EMPTY
36160: PPUSH
36161: CALL_OW 1
36165: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36166: LD_ADDR_EXP 107
36170: PUSH
36171: LD_EXP 107
36175: PPUSH
36176: LD_VAR 0 2
36180: PPUSH
36181: LD_EXP 99
36185: PUSH
36186: LD_VAR 0 2
36190: ARRAY
36191: PPUSH
36192: LD_INT 2
36194: PUSH
36195: LD_INT 30
36197: PUSH
36198: LD_INT 32
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 30
36207: PUSH
36208: LD_INT 33
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: LIST
36219: PPUSH
36220: CALL_OW 72
36224: PPUSH
36225: CALL_OW 1
36229: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36230: LD_ADDR_EXP 108
36234: PUSH
36235: LD_EXP 108
36239: PPUSH
36240: LD_VAR 0 2
36244: PPUSH
36245: LD_EXP 99
36249: PUSH
36250: LD_VAR 0 2
36254: ARRAY
36255: PPUSH
36256: LD_INT 2
36258: PUSH
36259: LD_INT 30
36261: PUSH
36262: LD_INT 32
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 30
36271: PUSH
36272: LD_INT 31
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 58
36286: PUSH
36287: EMPTY
36288: LIST
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PPUSH
36294: CALL_OW 72
36298: PPUSH
36299: CALL_OW 1
36303: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36304: LD_ADDR_EXP 109
36308: PUSH
36309: LD_EXP 109
36313: PPUSH
36314: LD_VAR 0 2
36318: PPUSH
36319: EMPTY
36320: PPUSH
36321: CALL_OW 1
36325: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36326: LD_ADDR_EXP 113
36330: PUSH
36331: LD_EXP 113
36335: PPUSH
36336: LD_VAR 0 2
36340: PPUSH
36341: EMPTY
36342: PPUSH
36343: CALL_OW 1
36347: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36348: LD_ADDR_EXP 112
36352: PUSH
36353: LD_EXP 112
36357: PPUSH
36358: LD_VAR 0 2
36362: PPUSH
36363: EMPTY
36364: PPUSH
36365: CALL_OW 1
36369: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36370: LD_ADDR_EXP 114
36374: PUSH
36375: LD_EXP 114
36379: PPUSH
36380: LD_VAR 0 2
36384: PPUSH
36385: EMPTY
36386: PPUSH
36387: CALL_OW 1
36391: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36392: LD_ADDR_EXP 115
36396: PUSH
36397: LD_EXP 115
36401: PPUSH
36402: LD_VAR 0 2
36406: PPUSH
36407: EMPTY
36408: PPUSH
36409: CALL_OW 1
36413: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36414: LD_ADDR_EXP 116
36418: PUSH
36419: LD_EXP 116
36423: PPUSH
36424: LD_VAR 0 2
36428: PPUSH
36429: EMPTY
36430: PPUSH
36431: CALL_OW 1
36435: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36436: LD_ADDR_EXP 117
36440: PUSH
36441: LD_EXP 117
36445: PPUSH
36446: LD_VAR 0 2
36450: PPUSH
36451: EMPTY
36452: PPUSH
36453: CALL_OW 1
36457: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36458: LD_ADDR_EXP 118
36462: PUSH
36463: LD_EXP 118
36467: PPUSH
36468: LD_VAR 0 2
36472: PPUSH
36473: EMPTY
36474: PPUSH
36475: CALL_OW 1
36479: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36480: LD_ADDR_EXP 119
36484: PUSH
36485: LD_EXP 119
36489: PPUSH
36490: LD_VAR 0 2
36494: PPUSH
36495: EMPTY
36496: PPUSH
36497: CALL_OW 1
36501: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36502: LD_ADDR_EXP 120
36506: PUSH
36507: LD_EXP 120
36511: PPUSH
36512: LD_VAR 0 2
36516: PPUSH
36517: EMPTY
36518: PPUSH
36519: CALL_OW 1
36523: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36524: LD_ADDR_EXP 121
36528: PUSH
36529: LD_EXP 121
36533: PPUSH
36534: LD_VAR 0 2
36538: PPUSH
36539: EMPTY
36540: PPUSH
36541: CALL_OW 1
36545: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36546: LD_ADDR_EXP 110
36550: PUSH
36551: LD_EXP 110
36555: PPUSH
36556: LD_VAR 0 2
36560: PPUSH
36561: LD_INT 0
36563: PPUSH
36564: CALL_OW 1
36568: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36569: LD_ADDR_EXP 123
36573: PUSH
36574: LD_EXP 123
36578: PPUSH
36579: LD_VAR 0 2
36583: PPUSH
36584: LD_INT 0
36586: PPUSH
36587: CALL_OW 1
36591: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36592: LD_ADDR_EXP 111
36596: PUSH
36597: LD_EXP 111
36601: PPUSH
36602: LD_VAR 0 2
36606: PPUSH
36607: EMPTY
36608: PPUSH
36609: CALL_OW 1
36613: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36614: LD_ADDR_EXP 122
36618: PUSH
36619: LD_EXP 122
36623: PPUSH
36624: LD_VAR 0 2
36628: PPUSH
36629: LD_INT 0
36631: PPUSH
36632: CALL_OW 1
36636: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36637: LD_ADDR_EXP 124
36641: PUSH
36642: LD_EXP 124
36646: PPUSH
36647: LD_VAR 0 2
36651: PPUSH
36652: EMPTY
36653: PPUSH
36654: CALL_OW 1
36658: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36659: LD_ADDR_EXP 127
36663: PUSH
36664: LD_EXP 127
36668: PPUSH
36669: LD_VAR 0 2
36673: PPUSH
36674: LD_INT 0
36676: PPUSH
36677: CALL_OW 1
36681: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36682: LD_ADDR_EXP 128
36686: PUSH
36687: LD_EXP 128
36691: PPUSH
36692: LD_VAR 0 2
36696: PPUSH
36697: EMPTY
36698: PPUSH
36699: CALL_OW 1
36703: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36704: LD_ADDR_EXP 129
36708: PUSH
36709: LD_EXP 129
36713: PPUSH
36714: LD_VAR 0 2
36718: PPUSH
36719: EMPTY
36720: PPUSH
36721: CALL_OW 1
36725: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36726: LD_ADDR_EXP 130
36730: PUSH
36731: LD_EXP 130
36735: PPUSH
36736: LD_VAR 0 2
36740: PPUSH
36741: EMPTY
36742: PPUSH
36743: CALL_OW 1
36747: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36748: LD_ADDR_EXP 132
36752: PUSH
36753: LD_EXP 132
36757: PPUSH
36758: LD_VAR 0 2
36762: PPUSH
36763: LD_EXP 99
36767: PUSH
36768: LD_VAR 0 2
36772: ARRAY
36773: PPUSH
36774: LD_INT 2
36776: PUSH
36777: LD_INT 30
36779: PUSH
36780: LD_INT 6
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: PUSH
36787: LD_INT 30
36789: PUSH
36790: LD_INT 7
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 30
36799: PUSH
36800: LD_INT 8
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: LIST
36811: LIST
36812: PPUSH
36813: CALL_OW 72
36817: PPUSH
36818: CALL_OW 1
36822: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36823: LD_ADDR_EXP 133
36827: PUSH
36828: LD_EXP 133
36832: PPUSH
36833: LD_VAR 0 2
36837: PPUSH
36838: EMPTY
36839: PPUSH
36840: CALL_OW 1
36844: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36845: LD_ADDR_EXP 134
36849: PUSH
36850: LD_EXP 134
36854: PPUSH
36855: LD_VAR 0 2
36859: PPUSH
36860: EMPTY
36861: PPUSH
36862: CALL_OW 1
36866: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36867: LD_ADDR_EXP 135
36871: PUSH
36872: LD_EXP 135
36876: PPUSH
36877: LD_VAR 0 2
36881: PPUSH
36882: EMPTY
36883: PPUSH
36884: CALL_OW 1
36888: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36889: LD_ADDR_EXP 136
36893: PUSH
36894: LD_EXP 136
36898: PPUSH
36899: LD_VAR 0 2
36903: PPUSH
36904: EMPTY
36905: PPUSH
36906: CALL_OW 1
36910: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36911: LD_ADDR_EXP 137
36915: PUSH
36916: LD_EXP 137
36920: PPUSH
36921: LD_VAR 0 2
36925: PPUSH
36926: EMPTY
36927: PPUSH
36928: CALL_OW 1
36932: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
36933: LD_ADDR_EXP 138
36937: PUSH
36938: LD_EXP 138
36942: PPUSH
36943: LD_VAR 0 2
36947: PPUSH
36948: EMPTY
36949: PPUSH
36950: CALL_OW 1
36954: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
36955: LD_ADDR_EXP 139
36959: PUSH
36960: LD_EXP 139
36964: PPUSH
36965: LD_VAR 0 2
36969: PPUSH
36970: EMPTY
36971: PPUSH
36972: CALL_OW 1
36976: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
36977: LD_ADDR_EXP 140
36981: PUSH
36982: LD_EXP 140
36986: PPUSH
36987: LD_VAR 0 2
36991: PPUSH
36992: EMPTY
36993: PPUSH
36994: CALL_OW 1
36998: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
36999: LD_ADDR_EXP 141
37003: PUSH
37004: LD_EXP 141
37008: PPUSH
37009: LD_VAR 0 2
37013: PPUSH
37014: LD_INT 0
37016: PPUSH
37017: CALL_OW 1
37021: ST_TO_ADDR
// end ;
37022: GO 35946
37024: POP
37025: POP
// MC_InitSides ( ) ;
37026: CALL 37312 0 0
// MC_InitResearch ( ) ;
37030: CALL 37051 0 0
// CustomInitMacro ( ) ;
37034: CALL 444 0 0
// skirmish := true ;
37038: LD_ADDR_EXP 97
37042: PUSH
37043: LD_INT 1
37045: ST_TO_ADDR
// end ;
37046: LD_VAR 0 1
37050: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37051: LD_INT 0
37053: PPUSH
37054: PPUSH
37055: PPUSH
37056: PPUSH
37057: PPUSH
37058: PPUSH
// if not mc_bases then
37059: LD_EXP 99
37063: NOT
37064: IFFALSE 37068
// exit ;
37066: GO 37307
// for i = 1 to 8 do
37068: LD_ADDR_VAR 0 2
37072: PUSH
37073: DOUBLE
37074: LD_INT 1
37076: DEC
37077: ST_TO_ADDR
37078: LD_INT 8
37080: PUSH
37081: FOR_TO
37082: IFFALSE 37108
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37084: LD_ADDR_EXP 126
37088: PUSH
37089: LD_EXP 126
37093: PPUSH
37094: LD_VAR 0 2
37098: PPUSH
37099: EMPTY
37100: PPUSH
37101: CALL_OW 1
37105: ST_TO_ADDR
37106: GO 37081
37108: POP
37109: POP
// tmp := [ ] ;
37110: LD_ADDR_VAR 0 5
37114: PUSH
37115: EMPTY
37116: ST_TO_ADDR
// for i = 1 to mc_sides do
37117: LD_ADDR_VAR 0 2
37121: PUSH
37122: DOUBLE
37123: LD_INT 1
37125: DEC
37126: ST_TO_ADDR
37127: LD_EXP 125
37131: PUSH
37132: FOR_TO
37133: IFFALSE 37191
// if not mc_sides [ i ] in tmp then
37135: LD_EXP 125
37139: PUSH
37140: LD_VAR 0 2
37144: ARRAY
37145: PUSH
37146: LD_VAR 0 5
37150: IN
37151: NOT
37152: IFFALSE 37189
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37154: LD_ADDR_VAR 0 5
37158: PUSH
37159: LD_VAR 0 5
37163: PPUSH
37164: LD_VAR 0 5
37168: PUSH
37169: LD_INT 1
37171: PLUS
37172: PPUSH
37173: LD_EXP 125
37177: PUSH
37178: LD_VAR 0 2
37182: ARRAY
37183: PPUSH
37184: CALL_OW 2
37188: ST_TO_ADDR
37189: GO 37132
37191: POP
37192: POP
// if not tmp then
37193: LD_VAR 0 5
37197: NOT
37198: IFFALSE 37202
// exit ;
37200: GO 37307
// for j in tmp do
37202: LD_ADDR_VAR 0 3
37206: PUSH
37207: LD_VAR 0 5
37211: PUSH
37212: FOR_IN
37213: IFFALSE 37305
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37215: LD_ADDR_VAR 0 6
37219: PUSH
37220: LD_INT 22
37222: PUSH
37223: LD_VAR 0 3
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PPUSH
37232: CALL_OW 69
37236: ST_TO_ADDR
// if not un then
37237: LD_VAR 0 6
37241: NOT
37242: IFFALSE 37246
// continue ;
37244: GO 37212
// nation := GetNation ( un [ 1 ] ) ;
37246: LD_ADDR_VAR 0 4
37250: PUSH
37251: LD_VAR 0 6
37255: PUSH
37256: LD_INT 1
37258: ARRAY
37259: PPUSH
37260: CALL_OW 248
37264: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37265: LD_ADDR_EXP 126
37269: PUSH
37270: LD_EXP 126
37274: PPUSH
37275: LD_VAR 0 3
37279: PPUSH
37280: LD_VAR 0 3
37284: PPUSH
37285: LD_VAR 0 4
37289: PPUSH
37290: LD_INT 1
37292: PPUSH
37293: CALL 63671 0 3
37297: PPUSH
37298: CALL_OW 1
37302: ST_TO_ADDR
// end ;
37303: GO 37212
37305: POP
37306: POP
// end ;
37307: LD_VAR 0 1
37311: RET
// export function MC_InitSides ( ) ; var i ; begin
37312: LD_INT 0
37314: PPUSH
37315: PPUSH
// if not mc_bases then
37316: LD_EXP 99
37320: NOT
37321: IFFALSE 37325
// exit ;
37323: GO 37399
// for i = 1 to mc_bases do
37325: LD_ADDR_VAR 0 2
37329: PUSH
37330: DOUBLE
37331: LD_INT 1
37333: DEC
37334: ST_TO_ADDR
37335: LD_EXP 99
37339: PUSH
37340: FOR_TO
37341: IFFALSE 37397
// if mc_bases [ i ] then
37343: LD_EXP 99
37347: PUSH
37348: LD_VAR 0 2
37352: ARRAY
37353: IFFALSE 37395
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37355: LD_ADDR_EXP 125
37359: PUSH
37360: LD_EXP 125
37364: PPUSH
37365: LD_VAR 0 2
37369: PPUSH
37370: LD_EXP 99
37374: PUSH
37375: LD_VAR 0 2
37379: ARRAY
37380: PUSH
37381: LD_INT 1
37383: ARRAY
37384: PPUSH
37385: CALL_OW 255
37389: PPUSH
37390: CALL_OW 1
37394: ST_TO_ADDR
37395: GO 37340
37397: POP
37398: POP
// end ;
37399: LD_VAR 0 1
37403: RET
// every 0 0$01 trigger skirmish do
37404: LD_EXP 97
37408: IFFALSE 37562
37410: GO 37412
37412: DISABLE
// begin enable ;
37413: ENABLE
// MC_CheckBuildings ( ) ;
37414: CALL 42060 0 0
// MC_CheckPeopleLife ( ) ;
37418: CALL 42185 0 0
// RaiseSailEvent ( 100 ) ;
37422: LD_INT 100
37424: PPUSH
37425: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37429: LD_INT 103
37431: PPUSH
37432: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37436: LD_INT 104
37438: PPUSH
37439: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37443: LD_INT 105
37445: PPUSH
37446: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37450: LD_INT 106
37452: PPUSH
37453: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37457: LD_INT 107
37459: PPUSH
37460: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37464: LD_INT 108
37466: PPUSH
37467: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37471: LD_INT 109
37473: PPUSH
37474: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37478: LD_INT 110
37480: PPUSH
37481: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37485: LD_INT 111
37487: PPUSH
37488: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37492: LD_INT 112
37494: PPUSH
37495: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37499: LD_INT 113
37501: PPUSH
37502: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37506: LD_INT 120
37508: PPUSH
37509: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37513: LD_INT 121
37515: PPUSH
37516: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37520: LD_INT 122
37522: PPUSH
37523: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37527: LD_INT 123
37529: PPUSH
37530: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37534: LD_INT 124
37536: PPUSH
37537: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37541: LD_INT 125
37543: PPUSH
37544: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37548: LD_INT 126
37550: PPUSH
37551: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37555: LD_INT 200
37557: PPUSH
37558: CALL_OW 427
// end ;
37562: END
// on SailEvent ( event ) do begin if event < 100 then
37563: LD_VAR 0 1
37567: PUSH
37568: LD_INT 100
37570: LESS
37571: IFFALSE 37582
// CustomEvent ( event ) ;
37573: LD_VAR 0 1
37577: PPUSH
37578: CALL 32245 0 1
// if event = 100 then
37582: LD_VAR 0 1
37586: PUSH
37587: LD_INT 100
37589: EQUAL
37590: IFFALSE 37596
// MC_ClassManager ( ) ;
37592: CALL 37988 0 0
// if event = 101 then
37596: LD_VAR 0 1
37600: PUSH
37601: LD_INT 101
37603: EQUAL
37604: IFFALSE 37610
// MC_RepairBuildings ( ) ;
37606: CALL 42781 0 0
// if event = 102 then
37610: LD_VAR 0 1
37614: PUSH
37615: LD_INT 102
37617: EQUAL
37618: IFFALSE 37624
// MC_Heal ( ) ;
37620: CALL 43513 0 0
// if event = 103 then
37624: LD_VAR 0 1
37628: PUSH
37629: LD_INT 103
37631: EQUAL
37632: IFFALSE 37638
// MC_Build ( ) ;
37634: CALL 43935 0 0
// if event = 104 then
37638: LD_VAR 0 1
37642: PUSH
37643: LD_INT 104
37645: EQUAL
37646: IFFALSE 37652
// MC_TurretWeapon ( ) ;
37648: CALL 45548 0 0
// if event = 105 then
37652: LD_VAR 0 1
37656: PUSH
37657: LD_INT 105
37659: EQUAL
37660: IFFALSE 37666
// MC_BuildUpgrade ( ) ;
37662: CALL 45099 0 0
// if event = 106 then
37666: LD_VAR 0 1
37670: PUSH
37671: LD_INT 106
37673: EQUAL
37674: IFFALSE 37680
// MC_PlantMines ( ) ;
37676: CALL 45978 0 0
// if event = 107 then
37680: LD_VAR 0 1
37684: PUSH
37685: LD_INT 107
37687: EQUAL
37688: IFFALSE 37694
// MC_CollectCrates ( ) ;
37690: CALL 47012 0 0
// if event = 108 then
37694: LD_VAR 0 1
37698: PUSH
37699: LD_INT 108
37701: EQUAL
37702: IFFALSE 37708
// MC_LinkRemoteControl ( ) ;
37704: CALL 48788 0 0
// if event = 109 then
37708: LD_VAR 0 1
37712: PUSH
37713: LD_INT 109
37715: EQUAL
37716: IFFALSE 37722
// MC_ProduceVehicle ( ) ;
37718: CALL 48969 0 0
// if event = 110 then
37722: LD_VAR 0 1
37726: PUSH
37727: LD_INT 110
37729: EQUAL
37730: IFFALSE 37736
// MC_SendAttack ( ) ;
37732: CALL 49435 0 0
// if event = 111 then
37736: LD_VAR 0 1
37740: PUSH
37741: LD_INT 111
37743: EQUAL
37744: IFFALSE 37750
// MC_Defend ( ) ;
37746: CALL 49543 0 0
// if event = 112 then
37750: LD_VAR 0 1
37754: PUSH
37755: LD_INT 112
37757: EQUAL
37758: IFFALSE 37764
// MC_Research ( ) ;
37760: CALL 50148 0 0
// if event = 113 then
37764: LD_VAR 0 1
37768: PUSH
37769: LD_INT 113
37771: EQUAL
37772: IFFALSE 37778
// MC_MinesTrigger ( ) ;
37774: CALL 51262 0 0
// if event = 120 then
37778: LD_VAR 0 1
37782: PUSH
37783: LD_INT 120
37785: EQUAL
37786: IFFALSE 37792
// MC_RepairVehicle ( ) ;
37788: CALL 51361 0 0
// if event = 121 then
37792: LD_VAR 0 1
37796: PUSH
37797: LD_INT 121
37799: EQUAL
37800: IFFALSE 37806
// MC_TameApe ( ) ;
37802: CALL 52091 0 0
// if event = 122 then
37806: LD_VAR 0 1
37810: PUSH
37811: LD_INT 122
37813: EQUAL
37814: IFFALSE 37820
// MC_ChangeApeClass ( ) ;
37816: CALL 52920 0 0
// if event = 123 then
37820: LD_VAR 0 1
37824: PUSH
37825: LD_INT 123
37827: EQUAL
37828: IFFALSE 37834
// MC_Bazooka ( ) ;
37830: CALL 53570 0 0
// if event = 124 then
37834: LD_VAR 0 1
37838: PUSH
37839: LD_INT 124
37841: EQUAL
37842: IFFALSE 37848
// MC_TeleportExit ( ) ;
37844: CALL 53768 0 0
// if event = 125 then
37848: LD_VAR 0 1
37852: PUSH
37853: LD_INT 125
37855: EQUAL
37856: IFFALSE 37862
// MC_Deposits ( ) ;
37858: CALL 54415 0 0
// if event = 126 then
37862: LD_VAR 0 1
37866: PUSH
37867: LD_INT 126
37869: EQUAL
37870: IFFALSE 37876
// MC_RemoteDriver ( ) ;
37872: CALL 55040 0 0
// if event = 200 then
37876: LD_VAR 0 1
37880: PUSH
37881: LD_INT 200
37883: EQUAL
37884: IFFALSE 37890
// MC_Idle ( ) ;
37886: CALL 56773 0 0
// end ;
37890: PPOPN 1
37892: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37893: LD_INT 0
37895: PPUSH
37896: PPUSH
// if not mc_bases [ base ] or not tag then
37897: LD_EXP 99
37901: PUSH
37902: LD_VAR 0 1
37906: ARRAY
37907: NOT
37908: PUSH
37909: LD_VAR 0 2
37913: NOT
37914: OR
37915: IFFALSE 37919
// exit ;
37917: GO 37983
// for i in mc_bases [ base ] union mc_ape [ base ] do
37919: LD_ADDR_VAR 0 4
37923: PUSH
37924: LD_EXP 99
37928: PUSH
37929: LD_VAR 0 1
37933: ARRAY
37934: PUSH
37935: LD_EXP 128
37939: PUSH
37940: LD_VAR 0 1
37944: ARRAY
37945: UNION
37946: PUSH
37947: FOR_IN
37948: IFFALSE 37981
// if GetTag ( i ) = tag then
37950: LD_VAR 0 4
37954: PPUSH
37955: CALL_OW 110
37959: PUSH
37960: LD_VAR 0 2
37964: EQUAL
37965: IFFALSE 37979
// SetTag ( i , 0 ) ;
37967: LD_VAR 0 4
37971: PPUSH
37972: LD_INT 0
37974: PPUSH
37975: CALL_OW 109
37979: GO 37947
37981: POP
37982: POP
// end ;
37983: LD_VAR 0 3
37987: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
37988: LD_INT 0
37990: PPUSH
37991: PPUSH
37992: PPUSH
37993: PPUSH
37994: PPUSH
37995: PPUSH
37996: PPUSH
37997: PPUSH
// if not mc_bases then
37998: LD_EXP 99
38002: NOT
38003: IFFALSE 38007
// exit ;
38005: GO 38465
// for i = 1 to mc_bases do
38007: LD_ADDR_VAR 0 2
38011: PUSH
38012: DOUBLE
38013: LD_INT 1
38015: DEC
38016: ST_TO_ADDR
38017: LD_EXP 99
38021: PUSH
38022: FOR_TO
38023: IFFALSE 38463
// begin tmp := MC_ClassCheckReq ( i ) ;
38025: LD_ADDR_VAR 0 4
38029: PUSH
38030: LD_VAR 0 2
38034: PPUSH
38035: CALL 38470 0 1
38039: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38040: LD_ADDR_EXP 140
38044: PUSH
38045: LD_EXP 140
38049: PPUSH
38050: LD_VAR 0 2
38054: PPUSH
38055: LD_VAR 0 4
38059: PPUSH
38060: CALL_OW 1
38064: ST_TO_ADDR
// if not tmp then
38065: LD_VAR 0 4
38069: NOT
38070: IFFALSE 38074
// continue ;
38072: GO 38022
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38074: LD_ADDR_VAR 0 6
38078: PUSH
38079: LD_EXP 99
38083: PUSH
38084: LD_VAR 0 2
38088: ARRAY
38089: PPUSH
38090: LD_INT 2
38092: PUSH
38093: LD_INT 30
38095: PUSH
38096: LD_INT 4
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 30
38105: PUSH
38106: LD_INT 5
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: LIST
38117: PPUSH
38118: CALL_OW 72
38122: PUSH
38123: LD_EXP 99
38127: PUSH
38128: LD_VAR 0 2
38132: ARRAY
38133: PPUSH
38134: LD_INT 2
38136: PUSH
38137: LD_INT 30
38139: PUSH
38140: LD_INT 0
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 30
38149: PUSH
38150: LD_INT 1
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: LIST
38161: PPUSH
38162: CALL_OW 72
38166: PUSH
38167: LD_EXP 99
38171: PUSH
38172: LD_VAR 0 2
38176: ARRAY
38177: PPUSH
38178: LD_INT 30
38180: PUSH
38181: LD_INT 3
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PPUSH
38188: CALL_OW 72
38192: PUSH
38193: LD_EXP 99
38197: PUSH
38198: LD_VAR 0 2
38202: ARRAY
38203: PPUSH
38204: LD_INT 2
38206: PUSH
38207: LD_INT 30
38209: PUSH
38210: LD_INT 6
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: PUSH
38217: LD_INT 30
38219: PUSH
38220: LD_INT 7
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 30
38229: PUSH
38230: LD_INT 8
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: PPUSH
38243: CALL_OW 72
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: LIST
38252: LIST
38253: ST_TO_ADDR
// for j = 1 to 4 do
38254: LD_ADDR_VAR 0 3
38258: PUSH
38259: DOUBLE
38260: LD_INT 1
38262: DEC
38263: ST_TO_ADDR
38264: LD_INT 4
38266: PUSH
38267: FOR_TO
38268: IFFALSE 38459
// begin if not tmp [ j ] then
38270: LD_VAR 0 4
38274: PUSH
38275: LD_VAR 0 3
38279: ARRAY
38280: NOT
38281: IFFALSE 38285
// continue ;
38283: GO 38267
// for p in tmp [ j ] do
38285: LD_ADDR_VAR 0 5
38289: PUSH
38290: LD_VAR 0 4
38294: PUSH
38295: LD_VAR 0 3
38299: ARRAY
38300: PUSH
38301: FOR_IN
38302: IFFALSE 38455
// begin if not b [ j ] then
38304: LD_VAR 0 6
38308: PUSH
38309: LD_VAR 0 3
38313: ARRAY
38314: NOT
38315: IFFALSE 38319
// break ;
38317: GO 38455
// e := 0 ;
38319: LD_ADDR_VAR 0 7
38323: PUSH
38324: LD_INT 0
38326: ST_TO_ADDR
// for k in b [ j ] do
38327: LD_ADDR_VAR 0 8
38331: PUSH
38332: LD_VAR 0 6
38336: PUSH
38337: LD_VAR 0 3
38341: ARRAY
38342: PUSH
38343: FOR_IN
38344: IFFALSE 38371
// if IsNotFull ( k ) then
38346: LD_VAR 0 8
38350: PPUSH
38351: CALL 67773 0 1
38355: IFFALSE 38369
// begin e := k ;
38357: LD_ADDR_VAR 0 7
38361: PUSH
38362: LD_VAR 0 8
38366: ST_TO_ADDR
// break ;
38367: GO 38371
// end ;
38369: GO 38343
38371: POP
38372: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38373: LD_VAR 0 7
38377: PUSH
38378: LD_VAR 0 5
38382: PPUSH
38383: LD_VAR 0 7
38387: PPUSH
38388: CALL 104892 0 2
38392: NOT
38393: AND
38394: IFFALSE 38453
// begin if IsInUnit ( p ) then
38396: LD_VAR 0 5
38400: PPUSH
38401: CALL_OW 310
38405: IFFALSE 38416
// ComExitBuilding ( p ) ;
38407: LD_VAR 0 5
38411: PPUSH
38412: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38416: LD_VAR 0 5
38420: PPUSH
38421: LD_VAR 0 7
38425: PPUSH
38426: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38430: LD_VAR 0 5
38434: PPUSH
38435: LD_VAR 0 3
38439: PPUSH
38440: CALL_OW 183
// AddComExitBuilding ( p ) ;
38444: LD_VAR 0 5
38448: PPUSH
38449: CALL_OW 182
// end ; end ;
38453: GO 38301
38455: POP
38456: POP
// end ;
38457: GO 38267
38459: POP
38460: POP
// end ;
38461: GO 38022
38463: POP
38464: POP
// end ;
38465: LD_VAR 0 1
38469: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38470: LD_INT 0
38472: PPUSH
38473: PPUSH
38474: PPUSH
38475: PPUSH
38476: PPUSH
38477: PPUSH
38478: PPUSH
38479: PPUSH
38480: PPUSH
38481: PPUSH
38482: PPUSH
38483: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38484: LD_VAR 0 1
38488: NOT
38489: PUSH
38490: LD_EXP 99
38494: PUSH
38495: LD_VAR 0 1
38499: ARRAY
38500: NOT
38501: OR
38502: PUSH
38503: LD_EXP 99
38507: PUSH
38508: LD_VAR 0 1
38512: ARRAY
38513: PPUSH
38514: LD_INT 2
38516: PUSH
38517: LD_INT 30
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: LD_INT 30
38529: PUSH
38530: LD_INT 1
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: LIST
38541: PPUSH
38542: CALL_OW 72
38546: NOT
38547: OR
38548: IFFALSE 38552
// exit ;
38550: GO 42055
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38552: LD_ADDR_VAR 0 4
38556: PUSH
38557: LD_EXP 99
38561: PUSH
38562: LD_VAR 0 1
38566: ARRAY
38567: PPUSH
38568: LD_INT 2
38570: PUSH
38571: LD_INT 25
38573: PUSH
38574: LD_INT 1
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 25
38583: PUSH
38584: LD_INT 2
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 25
38593: PUSH
38594: LD_INT 3
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 25
38603: PUSH
38604: LD_INT 4
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 25
38613: PUSH
38614: LD_INT 5
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 25
38623: PUSH
38624: LD_INT 8
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 25
38633: PUSH
38634: LD_INT 9
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: LIST
38650: PPUSH
38651: CALL_OW 72
38655: ST_TO_ADDR
// if not tmp then
38656: LD_VAR 0 4
38660: NOT
38661: IFFALSE 38665
// exit ;
38663: GO 42055
// for i in tmp do
38665: LD_ADDR_VAR 0 3
38669: PUSH
38670: LD_VAR 0 4
38674: PUSH
38675: FOR_IN
38676: IFFALSE 38707
// if GetTag ( i ) then
38678: LD_VAR 0 3
38682: PPUSH
38683: CALL_OW 110
38687: IFFALSE 38705
// tmp := tmp diff i ;
38689: LD_ADDR_VAR 0 4
38693: PUSH
38694: LD_VAR 0 4
38698: PUSH
38699: LD_VAR 0 3
38703: DIFF
38704: ST_TO_ADDR
38705: GO 38675
38707: POP
38708: POP
// if not tmp then
38709: LD_VAR 0 4
38713: NOT
38714: IFFALSE 38718
// exit ;
38716: GO 42055
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38718: LD_ADDR_VAR 0 5
38722: PUSH
38723: LD_EXP 99
38727: PUSH
38728: LD_VAR 0 1
38732: ARRAY
38733: PPUSH
38734: LD_INT 2
38736: PUSH
38737: LD_INT 25
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 25
38749: PUSH
38750: LD_INT 5
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 25
38759: PUSH
38760: LD_INT 8
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 25
38769: PUSH
38770: LD_INT 9
38772: PUSH
38773: EMPTY
38774: LIST
38775: LIST
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: LIST
38781: LIST
38782: LIST
38783: PPUSH
38784: CALL_OW 72
38788: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38789: LD_ADDR_VAR 0 6
38793: PUSH
38794: LD_EXP 99
38798: PUSH
38799: LD_VAR 0 1
38803: ARRAY
38804: PPUSH
38805: LD_INT 25
38807: PUSH
38808: LD_INT 2
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PPUSH
38815: CALL_OW 72
38819: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38820: LD_ADDR_VAR 0 7
38824: PUSH
38825: LD_EXP 99
38829: PUSH
38830: LD_VAR 0 1
38834: ARRAY
38835: PPUSH
38836: LD_INT 25
38838: PUSH
38839: LD_INT 3
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PPUSH
38846: CALL_OW 72
38850: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38851: LD_ADDR_VAR 0 8
38855: PUSH
38856: LD_EXP 99
38860: PUSH
38861: LD_VAR 0 1
38865: ARRAY
38866: PPUSH
38867: LD_INT 25
38869: PUSH
38870: LD_INT 4
38872: PUSH
38873: EMPTY
38874: LIST
38875: LIST
38876: PUSH
38877: LD_INT 24
38879: PUSH
38880: LD_INT 251
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PPUSH
38891: CALL_OW 72
38895: ST_TO_ADDR
// if mc_scan [ base ] then
38896: LD_EXP 122
38900: PUSH
38901: LD_VAR 0 1
38905: ARRAY
38906: IFFALSE 39367
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
38908: LD_ADDR_EXP 141
38912: PUSH
38913: LD_EXP 141
38917: PPUSH
38918: LD_VAR 0 1
38922: PPUSH
38923: LD_INT 4
38925: PPUSH
38926: CALL_OW 1
38930: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38931: LD_ADDR_VAR 0 12
38935: PUSH
38936: LD_EXP 99
38940: PUSH
38941: LD_VAR 0 1
38945: ARRAY
38946: PPUSH
38947: LD_INT 2
38949: PUSH
38950: LD_INT 30
38952: PUSH
38953: LD_INT 4
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 30
38962: PUSH
38963: LD_INT 5
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: LIST
38974: PPUSH
38975: CALL_OW 72
38979: ST_TO_ADDR
// if not b then
38980: LD_VAR 0 12
38984: NOT
38985: IFFALSE 38989
// exit ;
38987: GO 42055
// p := [ ] ;
38989: LD_ADDR_VAR 0 11
38993: PUSH
38994: EMPTY
38995: ST_TO_ADDR
// if sci >= 2 then
38996: LD_VAR 0 8
39000: PUSH
39001: LD_INT 2
39003: GREATEREQUAL
39004: IFFALSE 39035
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39006: LD_ADDR_VAR 0 8
39010: PUSH
39011: LD_VAR 0 8
39015: PUSH
39016: LD_INT 1
39018: ARRAY
39019: PUSH
39020: LD_VAR 0 8
39024: PUSH
39025: LD_INT 2
39027: ARRAY
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: ST_TO_ADDR
39033: GO 39096
// if sci = 1 then
39035: LD_VAR 0 8
39039: PUSH
39040: LD_INT 1
39042: EQUAL
39043: IFFALSE 39064
// sci := [ sci [ 1 ] ] else
39045: LD_ADDR_VAR 0 8
39049: PUSH
39050: LD_VAR 0 8
39054: PUSH
39055: LD_INT 1
39057: ARRAY
39058: PUSH
39059: EMPTY
39060: LIST
39061: ST_TO_ADDR
39062: GO 39096
// if sci = 0 then
39064: LD_VAR 0 8
39068: PUSH
39069: LD_INT 0
39071: EQUAL
39072: IFFALSE 39096
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39074: LD_ADDR_VAR 0 11
39078: PUSH
39079: LD_VAR 0 4
39083: PPUSH
39084: LD_INT 4
39086: PPUSH
39087: CALL 104755 0 2
39091: PUSH
39092: LD_INT 1
39094: ARRAY
39095: ST_TO_ADDR
// if eng > 4 then
39096: LD_VAR 0 6
39100: PUSH
39101: LD_INT 4
39103: GREATER
39104: IFFALSE 39150
// for i = eng downto 4 do
39106: LD_ADDR_VAR 0 3
39110: PUSH
39111: DOUBLE
39112: LD_VAR 0 6
39116: INC
39117: ST_TO_ADDR
39118: LD_INT 4
39120: PUSH
39121: FOR_DOWNTO
39122: IFFALSE 39148
// eng := eng diff eng [ i ] ;
39124: LD_ADDR_VAR 0 6
39128: PUSH
39129: LD_VAR 0 6
39133: PUSH
39134: LD_VAR 0 6
39138: PUSH
39139: LD_VAR 0 3
39143: ARRAY
39144: DIFF
39145: ST_TO_ADDR
39146: GO 39121
39148: POP
39149: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39150: LD_ADDR_VAR 0 4
39154: PUSH
39155: LD_VAR 0 4
39159: PUSH
39160: LD_VAR 0 5
39164: PUSH
39165: LD_VAR 0 6
39169: UNION
39170: PUSH
39171: LD_VAR 0 7
39175: UNION
39176: PUSH
39177: LD_VAR 0 8
39181: UNION
39182: DIFF
39183: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39184: LD_ADDR_VAR 0 13
39188: PUSH
39189: LD_EXP 99
39193: PUSH
39194: LD_VAR 0 1
39198: ARRAY
39199: PPUSH
39200: LD_INT 2
39202: PUSH
39203: LD_INT 30
39205: PUSH
39206: LD_INT 32
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 30
39215: PUSH
39216: LD_INT 31
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: LIST
39227: PPUSH
39228: CALL_OW 72
39232: PUSH
39233: LD_EXP 99
39237: PUSH
39238: LD_VAR 0 1
39242: ARRAY
39243: PPUSH
39244: LD_INT 2
39246: PUSH
39247: LD_INT 30
39249: PUSH
39250: LD_INT 4
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 30
39259: PUSH
39260: LD_INT 5
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: LIST
39271: PPUSH
39272: CALL_OW 72
39276: PUSH
39277: LD_INT 6
39279: MUL
39280: PLUS
39281: ST_TO_ADDR
// if bcount < tmp then
39282: LD_VAR 0 13
39286: PUSH
39287: LD_VAR 0 4
39291: LESS
39292: IFFALSE 39338
// for i = tmp downto bcount do
39294: LD_ADDR_VAR 0 3
39298: PUSH
39299: DOUBLE
39300: LD_VAR 0 4
39304: INC
39305: ST_TO_ADDR
39306: LD_VAR 0 13
39310: PUSH
39311: FOR_DOWNTO
39312: IFFALSE 39336
// tmp := Delete ( tmp , tmp ) ;
39314: LD_ADDR_VAR 0 4
39318: PUSH
39319: LD_VAR 0 4
39323: PPUSH
39324: LD_VAR 0 4
39328: PPUSH
39329: CALL_OW 3
39333: ST_TO_ADDR
39334: GO 39311
39336: POP
39337: POP
// result := [ tmp , 0 , 0 , p ] ;
39338: LD_ADDR_VAR 0 2
39342: PUSH
39343: LD_VAR 0 4
39347: PUSH
39348: LD_INT 0
39350: PUSH
39351: LD_INT 0
39353: PUSH
39354: LD_VAR 0 11
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: ST_TO_ADDR
// exit ;
39365: GO 42055
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39367: LD_EXP 99
39371: PUSH
39372: LD_VAR 0 1
39376: ARRAY
39377: PPUSH
39378: LD_INT 2
39380: PUSH
39381: LD_INT 30
39383: PUSH
39384: LD_INT 6
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 30
39393: PUSH
39394: LD_INT 7
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 30
39403: PUSH
39404: LD_INT 8
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: PPUSH
39417: CALL_OW 72
39421: NOT
39422: PUSH
39423: LD_EXP 99
39427: PUSH
39428: LD_VAR 0 1
39432: ARRAY
39433: PPUSH
39434: LD_INT 30
39436: PUSH
39437: LD_INT 3
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PPUSH
39444: CALL_OW 72
39448: NOT
39449: AND
39450: IFFALSE 39522
// begin if eng = tmp then
39452: LD_VAR 0 6
39456: PUSH
39457: LD_VAR 0 4
39461: EQUAL
39462: IFFALSE 39466
// exit ;
39464: GO 42055
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39466: LD_ADDR_EXP 141
39470: PUSH
39471: LD_EXP 141
39475: PPUSH
39476: LD_VAR 0 1
39480: PPUSH
39481: LD_INT 1
39483: PPUSH
39484: CALL_OW 1
39488: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39489: LD_ADDR_VAR 0 2
39493: PUSH
39494: LD_INT 0
39496: PUSH
39497: LD_VAR 0 4
39501: PUSH
39502: LD_VAR 0 6
39506: DIFF
39507: PUSH
39508: LD_INT 0
39510: PUSH
39511: LD_INT 0
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: ST_TO_ADDR
// exit ;
39520: GO 42055
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39522: LD_EXP 126
39526: PUSH
39527: LD_EXP 125
39531: PUSH
39532: LD_VAR 0 1
39536: ARRAY
39537: ARRAY
39538: PUSH
39539: LD_EXP 99
39543: PUSH
39544: LD_VAR 0 1
39548: ARRAY
39549: PPUSH
39550: LD_INT 2
39552: PUSH
39553: LD_INT 30
39555: PUSH
39556: LD_INT 6
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 30
39565: PUSH
39566: LD_INT 7
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 30
39575: PUSH
39576: LD_INT 8
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: PPUSH
39589: CALL_OW 72
39593: AND
39594: PUSH
39595: LD_EXP 99
39599: PUSH
39600: LD_VAR 0 1
39604: ARRAY
39605: PPUSH
39606: LD_INT 30
39608: PUSH
39609: LD_INT 3
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PPUSH
39616: CALL_OW 72
39620: NOT
39621: AND
39622: IFFALSE 39836
// begin if sci >= 6 then
39624: LD_VAR 0 8
39628: PUSH
39629: LD_INT 6
39631: GREATEREQUAL
39632: IFFALSE 39636
// exit ;
39634: GO 42055
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39636: LD_ADDR_EXP 141
39640: PUSH
39641: LD_EXP 141
39645: PPUSH
39646: LD_VAR 0 1
39650: PPUSH
39651: LD_INT 2
39653: PPUSH
39654: CALL_OW 1
39658: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39659: LD_ADDR_VAR 0 9
39663: PUSH
39664: LD_VAR 0 4
39668: PUSH
39669: LD_VAR 0 8
39673: DIFF
39674: PPUSH
39675: LD_INT 4
39677: PPUSH
39678: CALL 104755 0 2
39682: ST_TO_ADDR
// p := [ ] ;
39683: LD_ADDR_VAR 0 11
39687: PUSH
39688: EMPTY
39689: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39690: LD_VAR 0 8
39694: PUSH
39695: LD_INT 6
39697: LESS
39698: PUSH
39699: LD_VAR 0 9
39703: PUSH
39704: LD_INT 6
39706: GREATER
39707: AND
39708: IFFALSE 39789
// begin for i = 1 to 6 - sci do
39710: LD_ADDR_VAR 0 3
39714: PUSH
39715: DOUBLE
39716: LD_INT 1
39718: DEC
39719: ST_TO_ADDR
39720: LD_INT 6
39722: PUSH
39723: LD_VAR 0 8
39727: MINUS
39728: PUSH
39729: FOR_TO
39730: IFFALSE 39785
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39732: LD_ADDR_VAR 0 11
39736: PUSH
39737: LD_VAR 0 11
39741: PPUSH
39742: LD_VAR 0 11
39746: PUSH
39747: LD_INT 1
39749: PLUS
39750: PPUSH
39751: LD_VAR 0 9
39755: PUSH
39756: LD_INT 1
39758: ARRAY
39759: PPUSH
39760: CALL_OW 2
39764: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39765: LD_ADDR_VAR 0 9
39769: PUSH
39770: LD_VAR 0 9
39774: PPUSH
39775: LD_INT 1
39777: PPUSH
39778: CALL_OW 3
39782: ST_TO_ADDR
// end ;
39783: GO 39729
39785: POP
39786: POP
// end else
39787: GO 39809
// if sort then
39789: LD_VAR 0 9
39793: IFFALSE 39809
// p := sort [ 1 ] ;
39795: LD_ADDR_VAR 0 11
39799: PUSH
39800: LD_VAR 0 9
39804: PUSH
39805: LD_INT 1
39807: ARRAY
39808: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39809: LD_ADDR_VAR 0 2
39813: PUSH
39814: LD_INT 0
39816: PUSH
39817: LD_INT 0
39819: PUSH
39820: LD_INT 0
39822: PUSH
39823: LD_VAR 0 11
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: LIST
39832: LIST
39833: ST_TO_ADDR
// exit ;
39834: GO 42055
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39836: LD_EXP 126
39840: PUSH
39841: LD_EXP 125
39845: PUSH
39846: LD_VAR 0 1
39850: ARRAY
39851: ARRAY
39852: PUSH
39853: LD_EXP 99
39857: PUSH
39858: LD_VAR 0 1
39862: ARRAY
39863: PPUSH
39864: LD_INT 2
39866: PUSH
39867: LD_INT 30
39869: PUSH
39870: LD_INT 6
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 30
39879: PUSH
39880: LD_INT 7
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 30
39889: PUSH
39890: LD_INT 8
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: PPUSH
39903: CALL_OW 72
39907: AND
39908: PUSH
39909: LD_EXP 99
39913: PUSH
39914: LD_VAR 0 1
39918: ARRAY
39919: PPUSH
39920: LD_INT 30
39922: PUSH
39923: LD_INT 3
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PPUSH
39930: CALL_OW 72
39934: AND
39935: IFFALSE 40669
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
39937: LD_ADDR_EXP 141
39941: PUSH
39942: LD_EXP 141
39946: PPUSH
39947: LD_VAR 0 1
39951: PPUSH
39952: LD_INT 3
39954: PPUSH
39955: CALL_OW 1
39959: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39960: LD_ADDR_VAR 0 2
39964: PUSH
39965: LD_INT 0
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: LD_INT 0
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: ST_TO_ADDR
// if not eng then
39983: LD_VAR 0 6
39987: NOT
39988: IFFALSE 40051
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
39990: LD_ADDR_VAR 0 11
39994: PUSH
39995: LD_VAR 0 4
39999: PPUSH
40000: LD_INT 2
40002: PPUSH
40003: CALL 104755 0 2
40007: PUSH
40008: LD_INT 1
40010: ARRAY
40011: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40012: LD_ADDR_VAR 0 2
40016: PUSH
40017: LD_VAR 0 2
40021: PPUSH
40022: LD_INT 2
40024: PPUSH
40025: LD_VAR 0 11
40029: PPUSH
40030: CALL_OW 1
40034: ST_TO_ADDR
// tmp := tmp diff p ;
40035: LD_ADDR_VAR 0 4
40039: PUSH
40040: LD_VAR 0 4
40044: PUSH
40045: LD_VAR 0 11
40049: DIFF
40050: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40051: LD_VAR 0 4
40055: PUSH
40056: LD_VAR 0 8
40060: PUSH
40061: LD_INT 6
40063: LESS
40064: AND
40065: IFFALSE 40253
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40067: LD_ADDR_VAR 0 9
40071: PUSH
40072: LD_VAR 0 4
40076: PUSH
40077: LD_VAR 0 8
40081: PUSH
40082: LD_VAR 0 7
40086: UNION
40087: DIFF
40088: PPUSH
40089: LD_INT 4
40091: PPUSH
40092: CALL 104755 0 2
40096: ST_TO_ADDR
// p := [ ] ;
40097: LD_ADDR_VAR 0 11
40101: PUSH
40102: EMPTY
40103: ST_TO_ADDR
// if sort then
40104: LD_VAR 0 9
40108: IFFALSE 40224
// for i = 1 to 6 - sci do
40110: LD_ADDR_VAR 0 3
40114: PUSH
40115: DOUBLE
40116: LD_INT 1
40118: DEC
40119: ST_TO_ADDR
40120: LD_INT 6
40122: PUSH
40123: LD_VAR 0 8
40127: MINUS
40128: PUSH
40129: FOR_TO
40130: IFFALSE 40222
// begin if i = sort then
40132: LD_VAR 0 3
40136: PUSH
40137: LD_VAR 0 9
40141: EQUAL
40142: IFFALSE 40146
// break ;
40144: GO 40222
// if GetClass ( i ) = 4 then
40146: LD_VAR 0 3
40150: PPUSH
40151: CALL_OW 257
40155: PUSH
40156: LD_INT 4
40158: EQUAL
40159: IFFALSE 40163
// continue ;
40161: GO 40129
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40163: LD_ADDR_VAR 0 11
40167: PUSH
40168: LD_VAR 0 11
40172: PPUSH
40173: LD_VAR 0 11
40177: PUSH
40178: LD_INT 1
40180: PLUS
40181: PPUSH
40182: LD_VAR 0 9
40186: PUSH
40187: LD_VAR 0 3
40191: ARRAY
40192: PPUSH
40193: CALL_OW 2
40197: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40198: LD_ADDR_VAR 0 4
40202: PUSH
40203: LD_VAR 0 4
40207: PUSH
40208: LD_VAR 0 9
40212: PUSH
40213: LD_VAR 0 3
40217: ARRAY
40218: DIFF
40219: ST_TO_ADDR
// end ;
40220: GO 40129
40222: POP
40223: POP
// if p then
40224: LD_VAR 0 11
40228: IFFALSE 40253
// result := Replace ( result , 4 , p ) ;
40230: LD_ADDR_VAR 0 2
40234: PUSH
40235: LD_VAR 0 2
40239: PPUSH
40240: LD_INT 4
40242: PPUSH
40243: LD_VAR 0 11
40247: PPUSH
40248: CALL_OW 1
40252: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40253: LD_VAR 0 4
40257: PUSH
40258: LD_VAR 0 7
40262: PUSH
40263: LD_INT 6
40265: LESS
40266: AND
40267: IFFALSE 40455
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40269: LD_ADDR_VAR 0 9
40273: PUSH
40274: LD_VAR 0 4
40278: PUSH
40279: LD_VAR 0 8
40283: PUSH
40284: LD_VAR 0 7
40288: UNION
40289: DIFF
40290: PPUSH
40291: LD_INT 3
40293: PPUSH
40294: CALL 104755 0 2
40298: ST_TO_ADDR
// p := [ ] ;
40299: LD_ADDR_VAR 0 11
40303: PUSH
40304: EMPTY
40305: ST_TO_ADDR
// if sort then
40306: LD_VAR 0 9
40310: IFFALSE 40426
// for i = 1 to 6 - mech do
40312: LD_ADDR_VAR 0 3
40316: PUSH
40317: DOUBLE
40318: LD_INT 1
40320: DEC
40321: ST_TO_ADDR
40322: LD_INT 6
40324: PUSH
40325: LD_VAR 0 7
40329: MINUS
40330: PUSH
40331: FOR_TO
40332: IFFALSE 40424
// begin if i = sort then
40334: LD_VAR 0 3
40338: PUSH
40339: LD_VAR 0 9
40343: EQUAL
40344: IFFALSE 40348
// break ;
40346: GO 40424
// if GetClass ( i ) = 3 then
40348: LD_VAR 0 3
40352: PPUSH
40353: CALL_OW 257
40357: PUSH
40358: LD_INT 3
40360: EQUAL
40361: IFFALSE 40365
// continue ;
40363: GO 40331
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40365: LD_ADDR_VAR 0 11
40369: PUSH
40370: LD_VAR 0 11
40374: PPUSH
40375: LD_VAR 0 11
40379: PUSH
40380: LD_INT 1
40382: PLUS
40383: PPUSH
40384: LD_VAR 0 9
40388: PUSH
40389: LD_VAR 0 3
40393: ARRAY
40394: PPUSH
40395: CALL_OW 2
40399: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40400: LD_ADDR_VAR 0 4
40404: PUSH
40405: LD_VAR 0 4
40409: PUSH
40410: LD_VAR 0 9
40414: PUSH
40415: LD_VAR 0 3
40419: ARRAY
40420: DIFF
40421: ST_TO_ADDR
// end ;
40422: GO 40331
40424: POP
40425: POP
// if p then
40426: LD_VAR 0 11
40430: IFFALSE 40455
// result := Replace ( result , 3 , p ) ;
40432: LD_ADDR_VAR 0 2
40436: PUSH
40437: LD_VAR 0 2
40441: PPUSH
40442: LD_INT 3
40444: PPUSH
40445: LD_VAR 0 11
40449: PPUSH
40450: CALL_OW 1
40454: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40455: LD_VAR 0 4
40459: PUSH
40460: LD_INT 6
40462: GREATER
40463: PUSH
40464: LD_VAR 0 6
40468: PUSH
40469: LD_INT 6
40471: LESS
40472: AND
40473: IFFALSE 40667
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40475: LD_ADDR_VAR 0 9
40479: PUSH
40480: LD_VAR 0 4
40484: PUSH
40485: LD_VAR 0 8
40489: PUSH
40490: LD_VAR 0 7
40494: UNION
40495: PUSH
40496: LD_VAR 0 6
40500: UNION
40501: DIFF
40502: PPUSH
40503: LD_INT 2
40505: PPUSH
40506: CALL 104755 0 2
40510: ST_TO_ADDR
// p := [ ] ;
40511: LD_ADDR_VAR 0 11
40515: PUSH
40516: EMPTY
40517: ST_TO_ADDR
// if sort then
40518: LD_VAR 0 9
40522: IFFALSE 40638
// for i = 1 to 6 - eng do
40524: LD_ADDR_VAR 0 3
40528: PUSH
40529: DOUBLE
40530: LD_INT 1
40532: DEC
40533: ST_TO_ADDR
40534: LD_INT 6
40536: PUSH
40537: LD_VAR 0 6
40541: MINUS
40542: PUSH
40543: FOR_TO
40544: IFFALSE 40636
// begin if i = sort then
40546: LD_VAR 0 3
40550: PUSH
40551: LD_VAR 0 9
40555: EQUAL
40556: IFFALSE 40560
// break ;
40558: GO 40636
// if GetClass ( i ) = 2 then
40560: LD_VAR 0 3
40564: PPUSH
40565: CALL_OW 257
40569: PUSH
40570: LD_INT 2
40572: EQUAL
40573: IFFALSE 40577
// continue ;
40575: GO 40543
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40577: LD_ADDR_VAR 0 11
40581: PUSH
40582: LD_VAR 0 11
40586: PPUSH
40587: LD_VAR 0 11
40591: PUSH
40592: LD_INT 1
40594: PLUS
40595: PPUSH
40596: LD_VAR 0 9
40600: PUSH
40601: LD_VAR 0 3
40605: ARRAY
40606: PPUSH
40607: CALL_OW 2
40611: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40612: LD_ADDR_VAR 0 4
40616: PUSH
40617: LD_VAR 0 4
40621: PUSH
40622: LD_VAR 0 9
40626: PUSH
40627: LD_VAR 0 3
40631: ARRAY
40632: DIFF
40633: ST_TO_ADDR
// end ;
40634: GO 40543
40636: POP
40637: POP
// if p then
40638: LD_VAR 0 11
40642: IFFALSE 40667
// result := Replace ( result , 2 , p ) ;
40644: LD_ADDR_VAR 0 2
40648: PUSH
40649: LD_VAR 0 2
40653: PPUSH
40654: LD_INT 2
40656: PPUSH
40657: LD_VAR 0 11
40661: PPUSH
40662: CALL_OW 1
40666: ST_TO_ADDR
// end ; exit ;
40667: GO 42055
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40669: LD_EXP 126
40673: PUSH
40674: LD_EXP 125
40678: PUSH
40679: LD_VAR 0 1
40683: ARRAY
40684: ARRAY
40685: NOT
40686: PUSH
40687: LD_EXP 99
40691: PUSH
40692: LD_VAR 0 1
40696: ARRAY
40697: PPUSH
40698: LD_INT 30
40700: PUSH
40701: LD_INT 3
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PPUSH
40708: CALL_OW 72
40712: AND
40713: PUSH
40714: LD_EXP 104
40718: PUSH
40719: LD_VAR 0 1
40723: ARRAY
40724: AND
40725: IFFALSE 41333
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40727: LD_ADDR_EXP 141
40731: PUSH
40732: LD_EXP 141
40736: PPUSH
40737: LD_VAR 0 1
40741: PPUSH
40742: LD_INT 5
40744: PPUSH
40745: CALL_OW 1
40749: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40750: LD_ADDR_VAR 0 2
40754: PUSH
40755: LD_INT 0
40757: PUSH
40758: LD_INT 0
40760: PUSH
40761: LD_INT 0
40763: PUSH
40764: LD_INT 0
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: LIST
40771: LIST
40772: ST_TO_ADDR
// if sci > 1 then
40773: LD_VAR 0 8
40777: PUSH
40778: LD_INT 1
40780: GREATER
40781: IFFALSE 40809
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40783: LD_ADDR_VAR 0 4
40787: PUSH
40788: LD_VAR 0 4
40792: PUSH
40793: LD_VAR 0 8
40797: PUSH
40798: LD_VAR 0 8
40802: PUSH
40803: LD_INT 1
40805: ARRAY
40806: DIFF
40807: DIFF
40808: ST_TO_ADDR
// if tmp and not sci then
40809: LD_VAR 0 4
40813: PUSH
40814: LD_VAR 0 8
40818: NOT
40819: AND
40820: IFFALSE 40889
// begin sort := SortBySkill ( tmp , 4 ) ;
40822: LD_ADDR_VAR 0 9
40826: PUSH
40827: LD_VAR 0 4
40831: PPUSH
40832: LD_INT 4
40834: PPUSH
40835: CALL 104755 0 2
40839: ST_TO_ADDR
// if sort then
40840: LD_VAR 0 9
40844: IFFALSE 40860
// p := sort [ 1 ] ;
40846: LD_ADDR_VAR 0 11
40850: PUSH
40851: LD_VAR 0 9
40855: PUSH
40856: LD_INT 1
40858: ARRAY
40859: ST_TO_ADDR
// if p then
40860: LD_VAR 0 11
40864: IFFALSE 40889
// result := Replace ( result , 4 , p ) ;
40866: LD_ADDR_VAR 0 2
40870: PUSH
40871: LD_VAR 0 2
40875: PPUSH
40876: LD_INT 4
40878: PPUSH
40879: LD_VAR 0 11
40883: PPUSH
40884: CALL_OW 1
40888: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40889: LD_ADDR_VAR 0 4
40893: PUSH
40894: LD_VAR 0 4
40898: PUSH
40899: LD_VAR 0 7
40903: DIFF
40904: ST_TO_ADDR
// if tmp and mech < 6 then
40905: LD_VAR 0 4
40909: PUSH
40910: LD_VAR 0 7
40914: PUSH
40915: LD_INT 6
40917: LESS
40918: AND
40919: IFFALSE 41107
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40921: LD_ADDR_VAR 0 9
40925: PUSH
40926: LD_VAR 0 4
40930: PUSH
40931: LD_VAR 0 8
40935: PUSH
40936: LD_VAR 0 7
40940: UNION
40941: DIFF
40942: PPUSH
40943: LD_INT 3
40945: PPUSH
40946: CALL 104755 0 2
40950: ST_TO_ADDR
// p := [ ] ;
40951: LD_ADDR_VAR 0 11
40955: PUSH
40956: EMPTY
40957: ST_TO_ADDR
// if sort then
40958: LD_VAR 0 9
40962: IFFALSE 41078
// for i = 1 to 6 - mech do
40964: LD_ADDR_VAR 0 3
40968: PUSH
40969: DOUBLE
40970: LD_INT 1
40972: DEC
40973: ST_TO_ADDR
40974: LD_INT 6
40976: PUSH
40977: LD_VAR 0 7
40981: MINUS
40982: PUSH
40983: FOR_TO
40984: IFFALSE 41076
// begin if i = sort then
40986: LD_VAR 0 3
40990: PUSH
40991: LD_VAR 0 9
40995: EQUAL
40996: IFFALSE 41000
// break ;
40998: GO 41076
// if GetClass ( i ) = 3 then
41000: LD_VAR 0 3
41004: PPUSH
41005: CALL_OW 257
41009: PUSH
41010: LD_INT 3
41012: EQUAL
41013: IFFALSE 41017
// continue ;
41015: GO 40983
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41017: LD_ADDR_VAR 0 11
41021: PUSH
41022: LD_VAR 0 11
41026: PPUSH
41027: LD_VAR 0 11
41031: PUSH
41032: LD_INT 1
41034: PLUS
41035: PPUSH
41036: LD_VAR 0 9
41040: PUSH
41041: LD_VAR 0 3
41045: ARRAY
41046: PPUSH
41047: CALL_OW 2
41051: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41052: LD_ADDR_VAR 0 4
41056: PUSH
41057: LD_VAR 0 4
41061: PUSH
41062: LD_VAR 0 9
41066: PUSH
41067: LD_VAR 0 3
41071: ARRAY
41072: DIFF
41073: ST_TO_ADDR
// end ;
41074: GO 40983
41076: POP
41077: POP
// if p then
41078: LD_VAR 0 11
41082: IFFALSE 41107
// result := Replace ( result , 3 , p ) ;
41084: LD_ADDR_VAR 0 2
41088: PUSH
41089: LD_VAR 0 2
41093: PPUSH
41094: LD_INT 3
41096: PPUSH
41097: LD_VAR 0 11
41101: PPUSH
41102: CALL_OW 1
41106: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41107: LD_ADDR_VAR 0 4
41111: PUSH
41112: LD_VAR 0 4
41116: PUSH
41117: LD_VAR 0 6
41121: DIFF
41122: ST_TO_ADDR
// if tmp and eng < 6 then
41123: LD_VAR 0 4
41127: PUSH
41128: LD_VAR 0 6
41132: PUSH
41133: LD_INT 6
41135: LESS
41136: AND
41137: IFFALSE 41331
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41139: LD_ADDR_VAR 0 9
41143: PUSH
41144: LD_VAR 0 4
41148: PUSH
41149: LD_VAR 0 8
41153: PUSH
41154: LD_VAR 0 7
41158: UNION
41159: PUSH
41160: LD_VAR 0 6
41164: UNION
41165: DIFF
41166: PPUSH
41167: LD_INT 2
41169: PPUSH
41170: CALL 104755 0 2
41174: ST_TO_ADDR
// p := [ ] ;
41175: LD_ADDR_VAR 0 11
41179: PUSH
41180: EMPTY
41181: ST_TO_ADDR
// if sort then
41182: LD_VAR 0 9
41186: IFFALSE 41302
// for i = 1 to 6 - eng do
41188: LD_ADDR_VAR 0 3
41192: PUSH
41193: DOUBLE
41194: LD_INT 1
41196: DEC
41197: ST_TO_ADDR
41198: LD_INT 6
41200: PUSH
41201: LD_VAR 0 6
41205: MINUS
41206: PUSH
41207: FOR_TO
41208: IFFALSE 41300
// begin if i = sort then
41210: LD_VAR 0 3
41214: PUSH
41215: LD_VAR 0 9
41219: EQUAL
41220: IFFALSE 41224
// break ;
41222: GO 41300
// if GetClass ( i ) = 2 then
41224: LD_VAR 0 3
41228: PPUSH
41229: CALL_OW 257
41233: PUSH
41234: LD_INT 2
41236: EQUAL
41237: IFFALSE 41241
// continue ;
41239: GO 41207
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41241: LD_ADDR_VAR 0 11
41245: PUSH
41246: LD_VAR 0 11
41250: PPUSH
41251: LD_VAR 0 11
41255: PUSH
41256: LD_INT 1
41258: PLUS
41259: PPUSH
41260: LD_VAR 0 9
41264: PUSH
41265: LD_VAR 0 3
41269: ARRAY
41270: PPUSH
41271: CALL_OW 2
41275: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41276: LD_ADDR_VAR 0 4
41280: PUSH
41281: LD_VAR 0 4
41285: PUSH
41286: LD_VAR 0 9
41290: PUSH
41291: LD_VAR 0 3
41295: ARRAY
41296: DIFF
41297: ST_TO_ADDR
// end ;
41298: GO 41207
41300: POP
41301: POP
// if p then
41302: LD_VAR 0 11
41306: IFFALSE 41331
// result := Replace ( result , 2 , p ) ;
41308: LD_ADDR_VAR 0 2
41312: PUSH
41313: LD_VAR 0 2
41317: PPUSH
41318: LD_INT 2
41320: PPUSH
41321: LD_VAR 0 11
41325: PPUSH
41326: CALL_OW 1
41330: ST_TO_ADDR
// end ; exit ;
41331: GO 42055
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41333: LD_EXP 126
41337: PUSH
41338: LD_EXP 125
41342: PUSH
41343: LD_VAR 0 1
41347: ARRAY
41348: ARRAY
41349: NOT
41350: PUSH
41351: LD_EXP 99
41355: PUSH
41356: LD_VAR 0 1
41360: ARRAY
41361: PPUSH
41362: LD_INT 30
41364: PUSH
41365: LD_INT 3
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PPUSH
41372: CALL_OW 72
41376: AND
41377: PUSH
41378: LD_EXP 104
41382: PUSH
41383: LD_VAR 0 1
41387: ARRAY
41388: NOT
41389: AND
41390: IFFALSE 42055
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41392: LD_ADDR_EXP 141
41396: PUSH
41397: LD_EXP 141
41401: PPUSH
41402: LD_VAR 0 1
41406: PPUSH
41407: LD_INT 6
41409: PPUSH
41410: CALL_OW 1
41414: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41415: LD_ADDR_VAR 0 2
41419: PUSH
41420: LD_INT 0
41422: PUSH
41423: LD_INT 0
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: ST_TO_ADDR
// if sci >= 1 then
41438: LD_VAR 0 8
41442: PUSH
41443: LD_INT 1
41445: GREATEREQUAL
41446: IFFALSE 41468
// tmp := tmp diff sci [ 1 ] ;
41448: LD_ADDR_VAR 0 4
41452: PUSH
41453: LD_VAR 0 4
41457: PUSH
41458: LD_VAR 0 8
41462: PUSH
41463: LD_INT 1
41465: ARRAY
41466: DIFF
41467: ST_TO_ADDR
// if tmp and not sci then
41468: LD_VAR 0 4
41472: PUSH
41473: LD_VAR 0 8
41477: NOT
41478: AND
41479: IFFALSE 41548
// begin sort := SortBySkill ( tmp , 4 ) ;
41481: LD_ADDR_VAR 0 9
41485: PUSH
41486: LD_VAR 0 4
41490: PPUSH
41491: LD_INT 4
41493: PPUSH
41494: CALL 104755 0 2
41498: ST_TO_ADDR
// if sort then
41499: LD_VAR 0 9
41503: IFFALSE 41519
// p := sort [ 1 ] ;
41505: LD_ADDR_VAR 0 11
41509: PUSH
41510: LD_VAR 0 9
41514: PUSH
41515: LD_INT 1
41517: ARRAY
41518: ST_TO_ADDR
// if p then
41519: LD_VAR 0 11
41523: IFFALSE 41548
// result := Replace ( result , 4 , p ) ;
41525: LD_ADDR_VAR 0 2
41529: PUSH
41530: LD_VAR 0 2
41534: PPUSH
41535: LD_INT 4
41537: PPUSH
41538: LD_VAR 0 11
41542: PPUSH
41543: CALL_OW 1
41547: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41548: LD_ADDR_VAR 0 4
41552: PUSH
41553: LD_VAR 0 4
41557: PUSH
41558: LD_VAR 0 7
41562: DIFF
41563: ST_TO_ADDR
// if tmp and mech < 6 then
41564: LD_VAR 0 4
41568: PUSH
41569: LD_VAR 0 7
41573: PUSH
41574: LD_INT 6
41576: LESS
41577: AND
41578: IFFALSE 41760
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41580: LD_ADDR_VAR 0 9
41584: PUSH
41585: LD_VAR 0 4
41589: PUSH
41590: LD_VAR 0 7
41594: DIFF
41595: PPUSH
41596: LD_INT 3
41598: PPUSH
41599: CALL 104755 0 2
41603: ST_TO_ADDR
// p := [ ] ;
41604: LD_ADDR_VAR 0 11
41608: PUSH
41609: EMPTY
41610: ST_TO_ADDR
// if sort then
41611: LD_VAR 0 9
41615: IFFALSE 41731
// for i = 1 to 6 - mech do
41617: LD_ADDR_VAR 0 3
41621: PUSH
41622: DOUBLE
41623: LD_INT 1
41625: DEC
41626: ST_TO_ADDR
41627: LD_INT 6
41629: PUSH
41630: LD_VAR 0 7
41634: MINUS
41635: PUSH
41636: FOR_TO
41637: IFFALSE 41729
// begin if i = sort then
41639: LD_VAR 0 3
41643: PUSH
41644: LD_VAR 0 9
41648: EQUAL
41649: IFFALSE 41653
// break ;
41651: GO 41729
// if GetClass ( i ) = 3 then
41653: LD_VAR 0 3
41657: PPUSH
41658: CALL_OW 257
41662: PUSH
41663: LD_INT 3
41665: EQUAL
41666: IFFALSE 41670
// continue ;
41668: GO 41636
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41670: LD_ADDR_VAR 0 11
41674: PUSH
41675: LD_VAR 0 11
41679: PPUSH
41680: LD_VAR 0 11
41684: PUSH
41685: LD_INT 1
41687: PLUS
41688: PPUSH
41689: LD_VAR 0 9
41693: PUSH
41694: LD_VAR 0 3
41698: ARRAY
41699: PPUSH
41700: CALL_OW 2
41704: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41705: LD_ADDR_VAR 0 4
41709: PUSH
41710: LD_VAR 0 4
41714: PUSH
41715: LD_VAR 0 9
41719: PUSH
41720: LD_VAR 0 3
41724: ARRAY
41725: DIFF
41726: ST_TO_ADDR
// end ;
41727: GO 41636
41729: POP
41730: POP
// if p then
41731: LD_VAR 0 11
41735: IFFALSE 41760
// result := Replace ( result , 3 , p ) ;
41737: LD_ADDR_VAR 0 2
41741: PUSH
41742: LD_VAR 0 2
41746: PPUSH
41747: LD_INT 3
41749: PPUSH
41750: LD_VAR 0 11
41754: PPUSH
41755: CALL_OW 1
41759: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41760: LD_ADDR_VAR 0 4
41764: PUSH
41765: LD_VAR 0 4
41769: PUSH
41770: LD_VAR 0 6
41774: DIFF
41775: ST_TO_ADDR
// if tmp and eng < 4 then
41776: LD_VAR 0 4
41780: PUSH
41781: LD_VAR 0 6
41785: PUSH
41786: LD_INT 4
41788: LESS
41789: AND
41790: IFFALSE 41980
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41792: LD_ADDR_VAR 0 9
41796: PUSH
41797: LD_VAR 0 4
41801: PUSH
41802: LD_VAR 0 7
41806: PUSH
41807: LD_VAR 0 6
41811: UNION
41812: DIFF
41813: PPUSH
41814: LD_INT 2
41816: PPUSH
41817: CALL 104755 0 2
41821: ST_TO_ADDR
// p := [ ] ;
41822: LD_ADDR_VAR 0 11
41826: PUSH
41827: EMPTY
41828: ST_TO_ADDR
// if sort then
41829: LD_VAR 0 9
41833: IFFALSE 41949
// for i = 1 to 4 - eng do
41835: LD_ADDR_VAR 0 3
41839: PUSH
41840: DOUBLE
41841: LD_INT 1
41843: DEC
41844: ST_TO_ADDR
41845: LD_INT 4
41847: PUSH
41848: LD_VAR 0 6
41852: MINUS
41853: PUSH
41854: FOR_TO
41855: IFFALSE 41947
// begin if i = sort then
41857: LD_VAR 0 3
41861: PUSH
41862: LD_VAR 0 9
41866: EQUAL
41867: IFFALSE 41871
// break ;
41869: GO 41947
// if GetClass ( i ) = 2 then
41871: LD_VAR 0 3
41875: PPUSH
41876: CALL_OW 257
41880: PUSH
41881: LD_INT 2
41883: EQUAL
41884: IFFALSE 41888
// continue ;
41886: GO 41854
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41888: LD_ADDR_VAR 0 11
41892: PUSH
41893: LD_VAR 0 11
41897: PPUSH
41898: LD_VAR 0 11
41902: PUSH
41903: LD_INT 1
41905: PLUS
41906: PPUSH
41907: LD_VAR 0 9
41911: PUSH
41912: LD_VAR 0 3
41916: ARRAY
41917: PPUSH
41918: CALL_OW 2
41922: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41923: LD_ADDR_VAR 0 4
41927: PUSH
41928: LD_VAR 0 4
41932: PUSH
41933: LD_VAR 0 9
41937: PUSH
41938: LD_VAR 0 3
41942: ARRAY
41943: DIFF
41944: ST_TO_ADDR
// end ;
41945: GO 41854
41947: POP
41948: POP
// if p then
41949: LD_VAR 0 11
41953: IFFALSE 41978
// result := Replace ( result , 2 , p ) ;
41955: LD_ADDR_VAR 0 2
41959: PUSH
41960: LD_VAR 0 2
41964: PPUSH
41965: LD_INT 2
41967: PPUSH
41968: LD_VAR 0 11
41972: PPUSH
41973: CALL_OW 1
41977: ST_TO_ADDR
// end else
41978: GO 42024
// for i = eng downto 5 do
41980: LD_ADDR_VAR 0 3
41984: PUSH
41985: DOUBLE
41986: LD_VAR 0 6
41990: INC
41991: ST_TO_ADDR
41992: LD_INT 5
41994: PUSH
41995: FOR_DOWNTO
41996: IFFALSE 42022
// tmp := tmp union eng [ i ] ;
41998: LD_ADDR_VAR 0 4
42002: PUSH
42003: LD_VAR 0 4
42007: PUSH
42008: LD_VAR 0 6
42012: PUSH
42013: LD_VAR 0 3
42017: ARRAY
42018: UNION
42019: ST_TO_ADDR
42020: GO 41995
42022: POP
42023: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42024: LD_ADDR_VAR 0 2
42028: PUSH
42029: LD_VAR 0 2
42033: PPUSH
42034: LD_INT 1
42036: PPUSH
42037: LD_VAR 0 4
42041: PUSH
42042: LD_VAR 0 5
42046: DIFF
42047: PPUSH
42048: CALL_OW 1
42052: ST_TO_ADDR
// exit ;
42053: GO 42055
// end ; end ;
42055: LD_VAR 0 2
42059: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42060: LD_INT 0
42062: PPUSH
42063: PPUSH
42064: PPUSH
// if not mc_bases then
42065: LD_EXP 99
42069: NOT
42070: IFFALSE 42074
// exit ;
42072: GO 42180
// for i = 1 to mc_bases do
42074: LD_ADDR_VAR 0 2
42078: PUSH
42079: DOUBLE
42080: LD_INT 1
42082: DEC
42083: ST_TO_ADDR
42084: LD_EXP 99
42088: PUSH
42089: FOR_TO
42090: IFFALSE 42171
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42092: LD_ADDR_VAR 0 3
42096: PUSH
42097: LD_EXP 99
42101: PUSH
42102: LD_VAR 0 2
42106: ARRAY
42107: PPUSH
42108: LD_INT 21
42110: PUSH
42111: LD_INT 3
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 3
42120: PUSH
42121: LD_INT 24
42123: PUSH
42124: LD_INT 1000
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: EMPTY
42132: LIST
42133: LIST
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PPUSH
42139: CALL_OW 72
42143: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42144: LD_ADDR_EXP 100
42148: PUSH
42149: LD_EXP 100
42153: PPUSH
42154: LD_VAR 0 2
42158: PPUSH
42159: LD_VAR 0 3
42163: PPUSH
42164: CALL_OW 1
42168: ST_TO_ADDR
// end ;
42169: GO 42089
42171: POP
42172: POP
// RaiseSailEvent ( 101 ) ;
42173: LD_INT 101
42175: PPUSH
42176: CALL_OW 427
// end ;
42180: LD_VAR 0 1
42184: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42185: LD_INT 0
42187: PPUSH
42188: PPUSH
42189: PPUSH
42190: PPUSH
42191: PPUSH
42192: PPUSH
42193: PPUSH
// if not mc_bases then
42194: LD_EXP 99
42198: NOT
42199: IFFALSE 42203
// exit ;
42201: GO 42776
// for i = 1 to mc_bases do
42203: LD_ADDR_VAR 0 2
42207: PUSH
42208: DOUBLE
42209: LD_INT 1
42211: DEC
42212: ST_TO_ADDR
42213: LD_EXP 99
42217: PUSH
42218: FOR_TO
42219: IFFALSE 42767
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42221: LD_ADDR_VAR 0 5
42225: PUSH
42226: LD_EXP 99
42230: PUSH
42231: LD_VAR 0 2
42235: ARRAY
42236: PUSH
42237: LD_EXP 128
42241: PUSH
42242: LD_VAR 0 2
42246: ARRAY
42247: UNION
42248: PPUSH
42249: LD_INT 21
42251: PUSH
42252: LD_INT 1
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: LD_INT 1
42261: PUSH
42262: LD_INT 3
42264: PUSH
42265: LD_INT 54
42267: PUSH
42268: EMPTY
42269: LIST
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 3
42277: PUSH
42278: LD_INT 24
42280: PUSH
42281: LD_INT 800
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: LIST
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PPUSH
42301: CALL_OW 72
42305: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42306: LD_ADDR_VAR 0 6
42310: PUSH
42311: LD_EXP 99
42315: PUSH
42316: LD_VAR 0 2
42320: ARRAY
42321: PPUSH
42322: LD_INT 21
42324: PUSH
42325: LD_INT 1
42327: PUSH
42328: EMPTY
42329: LIST
42330: LIST
42331: PUSH
42332: LD_INT 1
42334: PUSH
42335: LD_INT 3
42337: PUSH
42338: LD_INT 54
42340: PUSH
42341: EMPTY
42342: LIST
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: LD_INT 3
42350: PUSH
42351: LD_INT 24
42353: PUSH
42354: LD_INT 250
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: LIST
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PPUSH
42374: CALL_OW 72
42378: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42379: LD_ADDR_VAR 0 7
42383: PUSH
42384: LD_VAR 0 5
42388: PUSH
42389: LD_VAR 0 6
42393: DIFF
42394: ST_TO_ADDR
// if not need_heal_1 then
42395: LD_VAR 0 6
42399: NOT
42400: IFFALSE 42433
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42402: LD_ADDR_EXP 102
42406: PUSH
42407: LD_EXP 102
42411: PPUSH
42412: LD_VAR 0 2
42416: PUSH
42417: LD_INT 1
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PPUSH
42424: EMPTY
42425: PPUSH
42426: CALL 70507 0 3
42430: ST_TO_ADDR
42431: GO 42503
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42433: LD_ADDR_EXP 102
42437: PUSH
42438: LD_EXP 102
42442: PPUSH
42443: LD_VAR 0 2
42447: PUSH
42448: LD_INT 1
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PPUSH
42455: LD_EXP 102
42459: PUSH
42460: LD_VAR 0 2
42464: ARRAY
42465: PUSH
42466: LD_INT 1
42468: ARRAY
42469: PPUSH
42470: LD_INT 3
42472: PUSH
42473: LD_INT 24
42475: PUSH
42476: LD_INT 1000
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PPUSH
42487: CALL_OW 72
42491: PUSH
42492: LD_VAR 0 6
42496: UNION
42497: PPUSH
42498: CALL 70507 0 3
42502: ST_TO_ADDR
// if not need_heal_2 then
42503: LD_VAR 0 7
42507: NOT
42508: IFFALSE 42541
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42510: LD_ADDR_EXP 102
42514: PUSH
42515: LD_EXP 102
42519: PPUSH
42520: LD_VAR 0 2
42524: PUSH
42525: LD_INT 2
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PPUSH
42532: EMPTY
42533: PPUSH
42534: CALL 70507 0 3
42538: ST_TO_ADDR
42539: GO 42573
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42541: LD_ADDR_EXP 102
42545: PUSH
42546: LD_EXP 102
42550: PPUSH
42551: LD_VAR 0 2
42555: PUSH
42556: LD_INT 2
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PPUSH
42563: LD_VAR 0 7
42567: PPUSH
42568: CALL 70507 0 3
42572: ST_TO_ADDR
// if need_heal_2 then
42573: LD_VAR 0 7
42577: IFFALSE 42749
// for j in need_heal_2 do
42579: LD_ADDR_VAR 0 3
42583: PUSH
42584: LD_VAR 0 7
42588: PUSH
42589: FOR_IN
42590: IFFALSE 42747
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42592: LD_ADDR_VAR 0 5
42596: PUSH
42597: LD_EXP 99
42601: PUSH
42602: LD_VAR 0 2
42606: ARRAY
42607: PPUSH
42608: LD_INT 2
42610: PUSH
42611: LD_INT 30
42613: PUSH
42614: LD_INT 6
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 30
42623: PUSH
42624: LD_INT 7
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: PUSH
42631: LD_INT 30
42633: PUSH
42634: LD_INT 8
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 30
42643: PUSH
42644: LD_INT 0
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: LD_INT 30
42653: PUSH
42654: LD_INT 1
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: LD_INT 25
42663: PUSH
42664: LD_INT 4
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: LIST
42675: LIST
42676: LIST
42677: LIST
42678: LIST
42679: PPUSH
42680: CALL_OW 72
42684: ST_TO_ADDR
// if tmp then
42685: LD_VAR 0 5
42689: IFFALSE 42745
// begin k := NearestUnitToUnit ( tmp , j ) ;
42691: LD_ADDR_VAR 0 4
42695: PUSH
42696: LD_VAR 0 5
42700: PPUSH
42701: LD_VAR 0 3
42705: PPUSH
42706: CALL_OW 74
42710: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42711: LD_VAR 0 3
42715: PPUSH
42716: LD_VAR 0 4
42720: PPUSH
42721: CALL_OW 296
42725: PUSH
42726: LD_INT 7
42728: GREATER
42729: IFFALSE 42745
// ComMoveUnit ( j , k ) ;
42731: LD_VAR 0 3
42735: PPUSH
42736: LD_VAR 0 4
42740: PPUSH
42741: CALL_OW 112
// end ; end ;
42745: GO 42589
42747: POP
42748: POP
// if not need_heal_1 and not need_heal_2 then
42749: LD_VAR 0 6
42753: NOT
42754: PUSH
42755: LD_VAR 0 7
42759: NOT
42760: AND
42761: IFFALSE 42765
// continue ;
42763: GO 42218
// end ;
42765: GO 42218
42767: POP
42768: POP
// RaiseSailEvent ( 102 ) ;
42769: LD_INT 102
42771: PPUSH
42772: CALL_OW 427
// end ;
42776: LD_VAR 0 1
42780: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
42781: LD_INT 0
42783: PPUSH
42784: PPUSH
42785: PPUSH
42786: PPUSH
42787: PPUSH
42788: PPUSH
// if not mc_bases then
42789: LD_EXP 99
42793: NOT
42794: IFFALSE 42798
// exit ;
42796: GO 43508
// for i = 1 to mc_bases do
42798: LD_ADDR_VAR 0 2
42802: PUSH
42803: DOUBLE
42804: LD_INT 1
42806: DEC
42807: ST_TO_ADDR
42808: LD_EXP 99
42812: PUSH
42813: FOR_TO
42814: IFFALSE 43506
// begin if not mc_building_need_repair [ i ] then
42816: LD_EXP 100
42820: PUSH
42821: LD_VAR 0 2
42825: ARRAY
42826: NOT
42827: IFFALSE 43001
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
42829: LD_ADDR_VAR 0 6
42833: PUSH
42834: LD_EXP 118
42838: PUSH
42839: LD_VAR 0 2
42843: ARRAY
42844: PPUSH
42845: LD_INT 3
42847: PUSH
42848: LD_INT 24
42850: PUSH
42851: LD_INT 1000
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PUSH
42862: LD_INT 2
42864: PUSH
42865: LD_INT 34
42867: PUSH
42868: LD_INT 13
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PUSH
42875: LD_INT 34
42877: PUSH
42878: LD_INT 52
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: LIST
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PPUSH
42894: CALL_OW 72
42898: ST_TO_ADDR
// if cranes then
42899: LD_VAR 0 6
42903: IFFALSE 42965
// for j in cranes do
42905: LD_ADDR_VAR 0 3
42909: PUSH
42910: LD_VAR 0 6
42914: PUSH
42915: FOR_IN
42916: IFFALSE 42963
// if not IsInArea ( j , mc_parking [ i ] ) then
42918: LD_VAR 0 3
42922: PPUSH
42923: LD_EXP 123
42927: PUSH
42928: LD_VAR 0 2
42932: ARRAY
42933: PPUSH
42934: CALL_OW 308
42938: NOT
42939: IFFALSE 42961
// ComMoveToArea ( j , mc_parking [ i ] ) ;
42941: LD_VAR 0 3
42945: PPUSH
42946: LD_EXP 123
42950: PUSH
42951: LD_VAR 0 2
42955: ARRAY
42956: PPUSH
42957: CALL_OW 113
42961: GO 42915
42963: POP
42964: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42965: LD_ADDR_EXP 101
42969: PUSH
42970: LD_EXP 101
42974: PPUSH
42975: LD_VAR 0 2
42979: PPUSH
42980: EMPTY
42981: PPUSH
42982: CALL_OW 1
42986: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
42987: LD_VAR 0 2
42991: PPUSH
42992: LD_INT 101
42994: PPUSH
42995: CALL 37893 0 2
// continue ;
42999: GO 42813
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43001: LD_ADDR_EXP 105
43005: PUSH
43006: LD_EXP 105
43010: PPUSH
43011: LD_VAR 0 2
43015: PPUSH
43016: EMPTY
43017: PPUSH
43018: CALL_OW 1
43022: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43023: LD_VAR 0 2
43027: PPUSH
43028: LD_INT 103
43030: PPUSH
43031: CALL 37893 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43035: LD_ADDR_VAR 0 5
43039: PUSH
43040: LD_EXP 99
43044: PUSH
43045: LD_VAR 0 2
43049: ARRAY
43050: PUSH
43051: LD_EXP 128
43055: PUSH
43056: LD_VAR 0 2
43060: ARRAY
43061: UNION
43062: PPUSH
43063: LD_INT 2
43065: PUSH
43066: LD_INT 25
43068: PUSH
43069: LD_INT 2
43071: PUSH
43072: EMPTY
43073: LIST
43074: LIST
43075: PUSH
43076: LD_INT 25
43078: PUSH
43079: LD_INT 16
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: LIST
43090: PUSH
43091: EMPTY
43092: LIST
43093: PPUSH
43094: CALL_OW 72
43098: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43099: LD_ADDR_VAR 0 6
43103: PUSH
43104: LD_EXP 118
43108: PUSH
43109: LD_VAR 0 2
43113: ARRAY
43114: PPUSH
43115: LD_INT 2
43117: PUSH
43118: LD_INT 34
43120: PUSH
43121: LD_INT 13
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: PUSH
43128: LD_INT 34
43130: PUSH
43131: LD_INT 52
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: LIST
43142: PPUSH
43143: CALL_OW 72
43147: ST_TO_ADDR
// if cranes then
43148: LD_VAR 0 6
43152: IFFALSE 43288
// begin for j in cranes do
43154: LD_ADDR_VAR 0 3
43158: PUSH
43159: LD_VAR 0 6
43163: PUSH
43164: FOR_IN
43165: IFFALSE 43286
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43167: LD_VAR 0 3
43171: PPUSH
43172: CALL_OW 256
43176: PUSH
43177: LD_INT 500
43179: GREATEREQUAL
43180: PUSH
43181: LD_VAR 0 3
43185: PPUSH
43186: CALL_OW 314
43190: NOT
43191: AND
43192: IFFALSE 43226
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43194: LD_VAR 0 3
43198: PPUSH
43199: LD_EXP 100
43203: PUSH
43204: LD_VAR 0 2
43208: ARRAY
43209: PPUSH
43210: LD_VAR 0 3
43214: PPUSH
43215: CALL_OW 74
43219: PPUSH
43220: CALL_OW 130
43224: GO 43284
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43226: LD_VAR 0 3
43230: PPUSH
43231: CALL_OW 256
43235: PUSH
43236: LD_INT 500
43238: LESS
43239: PUSH
43240: LD_VAR 0 3
43244: PPUSH
43245: LD_EXP 123
43249: PUSH
43250: LD_VAR 0 2
43254: ARRAY
43255: PPUSH
43256: CALL_OW 308
43260: NOT
43261: AND
43262: IFFALSE 43284
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43264: LD_VAR 0 3
43268: PPUSH
43269: LD_EXP 123
43273: PUSH
43274: LD_VAR 0 2
43278: ARRAY
43279: PPUSH
43280: CALL_OW 113
43284: GO 43164
43286: POP
43287: POP
// end ; if not tmp then
43288: LD_VAR 0 5
43292: NOT
43293: IFFALSE 43297
// continue ;
43295: GO 42813
// for j in tmp do
43297: LD_ADDR_VAR 0 3
43301: PUSH
43302: LD_VAR 0 5
43306: PUSH
43307: FOR_IN
43308: IFFALSE 43502
// begin if mc_need_heal [ i ] then
43310: LD_EXP 102
43314: PUSH
43315: LD_VAR 0 2
43319: ARRAY
43320: IFFALSE 43368
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43322: LD_VAR 0 3
43326: PUSH
43327: LD_EXP 102
43331: PUSH
43332: LD_VAR 0 2
43336: ARRAY
43337: PUSH
43338: LD_INT 1
43340: ARRAY
43341: IN
43342: PUSH
43343: LD_VAR 0 3
43347: PUSH
43348: LD_EXP 102
43352: PUSH
43353: LD_VAR 0 2
43357: ARRAY
43358: PUSH
43359: LD_INT 2
43361: ARRAY
43362: IN
43363: OR
43364: IFFALSE 43368
// continue ;
43366: GO 43307
// if IsInUnit ( j ) then
43368: LD_VAR 0 3
43372: PPUSH
43373: CALL_OW 310
43377: IFFALSE 43388
// ComExitBuilding ( j ) ;
43379: LD_VAR 0 3
43383: PPUSH
43384: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43388: LD_VAR 0 3
43392: PUSH
43393: LD_EXP 101
43397: PUSH
43398: LD_VAR 0 2
43402: ARRAY
43403: IN
43404: NOT
43405: IFFALSE 43463
// begin SetTag ( j , 101 ) ;
43407: LD_VAR 0 3
43411: PPUSH
43412: LD_INT 101
43414: PPUSH
43415: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43419: LD_ADDR_EXP 101
43423: PUSH
43424: LD_EXP 101
43428: PPUSH
43429: LD_VAR 0 2
43433: PUSH
43434: LD_EXP 101
43438: PUSH
43439: LD_VAR 0 2
43443: ARRAY
43444: PUSH
43445: LD_INT 1
43447: PLUS
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: PPUSH
43453: LD_VAR 0 3
43457: PPUSH
43458: CALL 70507 0 3
43462: ST_TO_ADDR
// end ; wait ( 1 ) ;
43463: LD_INT 1
43465: PPUSH
43466: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43470: LD_VAR 0 3
43474: PPUSH
43475: LD_EXP 100
43479: PUSH
43480: LD_VAR 0 2
43484: ARRAY
43485: PPUSH
43486: LD_VAR 0 3
43490: PPUSH
43491: CALL_OW 74
43495: PPUSH
43496: CALL_OW 130
// end ;
43500: GO 43307
43502: POP
43503: POP
// end ;
43504: GO 42813
43506: POP
43507: POP
// end ;
43508: LD_VAR 0 1
43512: RET
// export function MC_Heal ; var i , j , tmp ; begin
43513: LD_INT 0
43515: PPUSH
43516: PPUSH
43517: PPUSH
43518: PPUSH
// if not mc_bases then
43519: LD_EXP 99
43523: NOT
43524: IFFALSE 43528
// exit ;
43526: GO 43930
// for i = 1 to mc_bases do
43528: LD_ADDR_VAR 0 2
43532: PUSH
43533: DOUBLE
43534: LD_INT 1
43536: DEC
43537: ST_TO_ADDR
43538: LD_EXP 99
43542: PUSH
43543: FOR_TO
43544: IFFALSE 43928
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43546: LD_EXP 102
43550: PUSH
43551: LD_VAR 0 2
43555: ARRAY
43556: PUSH
43557: LD_INT 1
43559: ARRAY
43560: NOT
43561: PUSH
43562: LD_EXP 102
43566: PUSH
43567: LD_VAR 0 2
43571: ARRAY
43572: PUSH
43573: LD_INT 2
43575: ARRAY
43576: NOT
43577: AND
43578: IFFALSE 43616
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43580: LD_ADDR_EXP 103
43584: PUSH
43585: LD_EXP 103
43589: PPUSH
43590: LD_VAR 0 2
43594: PPUSH
43595: EMPTY
43596: PPUSH
43597: CALL_OW 1
43601: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43602: LD_VAR 0 2
43606: PPUSH
43607: LD_INT 102
43609: PPUSH
43610: CALL 37893 0 2
// continue ;
43614: GO 43543
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43616: LD_ADDR_VAR 0 4
43620: PUSH
43621: LD_EXP 99
43625: PUSH
43626: LD_VAR 0 2
43630: ARRAY
43631: PPUSH
43632: LD_INT 25
43634: PUSH
43635: LD_INT 4
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: PPUSH
43642: CALL_OW 72
43646: ST_TO_ADDR
// if not tmp then
43647: LD_VAR 0 4
43651: NOT
43652: IFFALSE 43656
// continue ;
43654: GO 43543
// if mc_taming [ i ] then
43656: LD_EXP 130
43660: PUSH
43661: LD_VAR 0 2
43665: ARRAY
43666: IFFALSE 43690
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43668: LD_ADDR_EXP 130
43672: PUSH
43673: LD_EXP 130
43677: PPUSH
43678: LD_VAR 0 2
43682: PPUSH
43683: EMPTY
43684: PPUSH
43685: CALL_OW 1
43689: ST_TO_ADDR
// for j in tmp do
43690: LD_ADDR_VAR 0 3
43694: PUSH
43695: LD_VAR 0 4
43699: PUSH
43700: FOR_IN
43701: IFFALSE 43924
// begin if IsInUnit ( j ) then
43703: LD_VAR 0 3
43707: PPUSH
43708: CALL_OW 310
43712: IFFALSE 43723
// ComExitBuilding ( j ) ;
43714: LD_VAR 0 3
43718: PPUSH
43719: CALL_OW 122
// if not j in mc_healers [ i ] then
43723: LD_VAR 0 3
43727: PUSH
43728: LD_EXP 103
43732: PUSH
43733: LD_VAR 0 2
43737: ARRAY
43738: IN
43739: NOT
43740: IFFALSE 43786
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43742: LD_ADDR_EXP 103
43746: PUSH
43747: LD_EXP 103
43751: PPUSH
43752: LD_VAR 0 2
43756: PUSH
43757: LD_EXP 103
43761: PUSH
43762: LD_VAR 0 2
43766: ARRAY
43767: PUSH
43768: LD_INT 1
43770: PLUS
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PPUSH
43776: LD_VAR 0 3
43780: PPUSH
43781: CALL 70507 0 3
43785: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43786: LD_VAR 0 3
43790: PPUSH
43791: CALL_OW 110
43795: PUSH
43796: LD_INT 102
43798: NONEQUAL
43799: IFFALSE 43813
// SetTag ( j , 102 ) ;
43801: LD_VAR 0 3
43805: PPUSH
43806: LD_INT 102
43808: PPUSH
43809: CALL_OW 109
// Wait ( 3 ) ;
43813: LD_INT 3
43815: PPUSH
43816: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43820: LD_EXP 102
43824: PUSH
43825: LD_VAR 0 2
43829: ARRAY
43830: PUSH
43831: LD_INT 1
43833: ARRAY
43834: IFFALSE 43866
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43836: LD_VAR 0 3
43840: PPUSH
43841: LD_EXP 102
43845: PUSH
43846: LD_VAR 0 2
43850: ARRAY
43851: PUSH
43852: LD_INT 1
43854: ARRAY
43855: PUSH
43856: LD_INT 1
43858: ARRAY
43859: PPUSH
43860: CALL_OW 128
43864: GO 43922
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43866: LD_VAR 0 3
43870: PPUSH
43871: CALL_OW 314
43875: NOT
43876: PUSH
43877: LD_EXP 102
43881: PUSH
43882: LD_VAR 0 2
43886: ARRAY
43887: PUSH
43888: LD_INT 2
43890: ARRAY
43891: AND
43892: IFFALSE 43922
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43894: LD_VAR 0 3
43898: PPUSH
43899: LD_EXP 102
43903: PUSH
43904: LD_VAR 0 2
43908: ARRAY
43909: PUSH
43910: LD_INT 2
43912: ARRAY
43913: PUSH
43914: LD_INT 1
43916: ARRAY
43917: PPUSH
43918: CALL_OW 128
// end ;
43922: GO 43700
43924: POP
43925: POP
// end ;
43926: GO 43543
43928: POP
43929: POP
// end ;
43930: LD_VAR 0 1
43934: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
43935: LD_INT 0
43937: PPUSH
43938: PPUSH
43939: PPUSH
43940: PPUSH
43941: PPUSH
// if not mc_bases then
43942: LD_EXP 99
43946: NOT
43947: IFFALSE 43951
// exit ;
43949: GO 45094
// for i = 1 to mc_bases do
43951: LD_ADDR_VAR 0 2
43955: PUSH
43956: DOUBLE
43957: LD_INT 1
43959: DEC
43960: ST_TO_ADDR
43961: LD_EXP 99
43965: PUSH
43966: FOR_TO
43967: IFFALSE 45092
// begin if mc_scan [ i ] then
43969: LD_EXP 122
43973: PUSH
43974: LD_VAR 0 2
43978: ARRAY
43979: IFFALSE 43983
// continue ;
43981: GO 43966
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
43983: LD_EXP 104
43987: PUSH
43988: LD_VAR 0 2
43992: ARRAY
43993: NOT
43994: PUSH
43995: LD_EXP 106
43999: PUSH
44000: LD_VAR 0 2
44004: ARRAY
44005: NOT
44006: AND
44007: PUSH
44008: LD_EXP 105
44012: PUSH
44013: LD_VAR 0 2
44017: ARRAY
44018: AND
44019: IFFALSE 44057
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44021: LD_ADDR_EXP 105
44025: PUSH
44026: LD_EXP 105
44030: PPUSH
44031: LD_VAR 0 2
44035: PPUSH
44036: EMPTY
44037: PPUSH
44038: CALL_OW 1
44042: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44043: LD_VAR 0 2
44047: PPUSH
44048: LD_INT 103
44050: PPUSH
44051: CALL 37893 0 2
// continue ;
44055: GO 43966
// end ; if mc_construct_list [ i ] then
44057: LD_EXP 106
44061: PUSH
44062: LD_VAR 0 2
44066: ARRAY
44067: IFFALSE 44287
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44069: LD_ADDR_VAR 0 4
44073: PUSH
44074: LD_EXP 99
44078: PUSH
44079: LD_VAR 0 2
44083: ARRAY
44084: PPUSH
44085: LD_INT 25
44087: PUSH
44088: LD_INT 2
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PPUSH
44095: CALL_OW 72
44099: PUSH
44100: LD_EXP 101
44104: PUSH
44105: LD_VAR 0 2
44109: ARRAY
44110: DIFF
44111: ST_TO_ADDR
// if not tmp then
44112: LD_VAR 0 4
44116: NOT
44117: IFFALSE 44121
// continue ;
44119: GO 43966
// for j in tmp do
44121: LD_ADDR_VAR 0 3
44125: PUSH
44126: LD_VAR 0 4
44130: PUSH
44131: FOR_IN
44132: IFFALSE 44283
// begin if not mc_builders [ i ] then
44134: LD_EXP 105
44138: PUSH
44139: LD_VAR 0 2
44143: ARRAY
44144: NOT
44145: IFFALSE 44203
// begin SetTag ( j , 103 ) ;
44147: LD_VAR 0 3
44151: PPUSH
44152: LD_INT 103
44154: PPUSH
44155: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44159: LD_ADDR_EXP 105
44163: PUSH
44164: LD_EXP 105
44168: PPUSH
44169: LD_VAR 0 2
44173: PUSH
44174: LD_EXP 105
44178: PUSH
44179: LD_VAR 0 2
44183: ARRAY
44184: PUSH
44185: LD_INT 1
44187: PLUS
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PPUSH
44193: LD_VAR 0 3
44197: PPUSH
44198: CALL 70507 0 3
44202: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44203: LD_VAR 0 3
44207: PPUSH
44208: CALL_OW 310
44212: IFFALSE 44223
// ComExitBuilding ( j ) ;
44214: LD_VAR 0 3
44218: PPUSH
44219: CALL_OW 122
// wait ( 3 ) ;
44223: LD_INT 3
44225: PPUSH
44226: CALL_OW 67
// if not mc_construct_list [ i ] then
44230: LD_EXP 106
44234: PUSH
44235: LD_VAR 0 2
44239: ARRAY
44240: NOT
44241: IFFALSE 44245
// break ;
44243: GO 44283
// if not HasTask ( j ) then
44245: LD_VAR 0 3
44249: PPUSH
44250: CALL_OW 314
44254: NOT
44255: IFFALSE 44281
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44257: LD_VAR 0 3
44261: PPUSH
44262: LD_EXP 106
44266: PUSH
44267: LD_VAR 0 2
44271: ARRAY
44272: PUSH
44273: LD_INT 1
44275: ARRAY
44276: PPUSH
44277: CALL 73358 0 2
// end ;
44281: GO 44131
44283: POP
44284: POP
// end else
44285: GO 45090
// if mc_build_list [ i ] then
44287: LD_EXP 104
44291: PUSH
44292: LD_VAR 0 2
44296: ARRAY
44297: IFFALSE 45090
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44299: LD_ADDR_VAR 0 5
44303: PUSH
44304: LD_EXP 99
44308: PUSH
44309: LD_VAR 0 2
44313: ARRAY
44314: PPUSH
44315: LD_INT 2
44317: PUSH
44318: LD_INT 30
44320: PUSH
44321: LD_INT 0
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 30
44330: PUSH
44331: LD_INT 1
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: LIST
44342: PPUSH
44343: CALL_OW 72
44347: ST_TO_ADDR
// if depot then
44348: LD_VAR 0 5
44352: IFFALSE 44370
// depot := depot [ 1 ] else
44354: LD_ADDR_VAR 0 5
44358: PUSH
44359: LD_VAR 0 5
44363: PUSH
44364: LD_INT 1
44366: ARRAY
44367: ST_TO_ADDR
44368: GO 44378
// depot := 0 ;
44370: LD_ADDR_VAR 0 5
44374: PUSH
44375: LD_INT 0
44377: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44378: LD_EXP 104
44382: PUSH
44383: LD_VAR 0 2
44387: ARRAY
44388: PUSH
44389: LD_INT 1
44391: ARRAY
44392: PUSH
44393: LD_INT 1
44395: ARRAY
44396: PPUSH
44397: CALL 73188 0 1
44401: PUSH
44402: LD_EXP 99
44406: PUSH
44407: LD_VAR 0 2
44411: ARRAY
44412: PPUSH
44413: LD_INT 2
44415: PUSH
44416: LD_INT 30
44418: PUSH
44419: LD_INT 2
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 30
44428: PUSH
44429: LD_INT 3
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: LIST
44440: PPUSH
44441: CALL_OW 72
44445: NOT
44446: AND
44447: IFFALSE 44552
// begin for j = 1 to mc_build_list [ i ] do
44449: LD_ADDR_VAR 0 3
44453: PUSH
44454: DOUBLE
44455: LD_INT 1
44457: DEC
44458: ST_TO_ADDR
44459: LD_EXP 104
44463: PUSH
44464: LD_VAR 0 2
44468: ARRAY
44469: PUSH
44470: FOR_TO
44471: IFFALSE 44550
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44473: LD_EXP 104
44477: PUSH
44478: LD_VAR 0 2
44482: ARRAY
44483: PUSH
44484: LD_VAR 0 3
44488: ARRAY
44489: PUSH
44490: LD_INT 1
44492: ARRAY
44493: PUSH
44494: LD_INT 2
44496: EQUAL
44497: IFFALSE 44548
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44499: LD_ADDR_EXP 104
44503: PUSH
44504: LD_EXP 104
44508: PPUSH
44509: LD_VAR 0 2
44513: PPUSH
44514: LD_EXP 104
44518: PUSH
44519: LD_VAR 0 2
44523: ARRAY
44524: PPUSH
44525: LD_VAR 0 3
44529: PPUSH
44530: LD_INT 1
44532: PPUSH
44533: LD_INT 0
44535: PPUSH
44536: CALL 69925 0 4
44540: PPUSH
44541: CALL_OW 1
44545: ST_TO_ADDR
// break ;
44546: GO 44550
// end ;
44548: GO 44470
44550: POP
44551: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44552: LD_EXP 104
44556: PUSH
44557: LD_VAR 0 2
44561: ARRAY
44562: PUSH
44563: LD_INT 1
44565: ARRAY
44566: PUSH
44567: LD_INT 1
44569: ARRAY
44570: PUSH
44571: LD_INT 0
44573: EQUAL
44574: PUSH
44575: LD_VAR 0 5
44579: PUSH
44580: LD_VAR 0 5
44584: PPUSH
44585: LD_EXP 104
44589: PUSH
44590: LD_VAR 0 2
44594: ARRAY
44595: PUSH
44596: LD_INT 1
44598: ARRAY
44599: PUSH
44600: LD_INT 1
44602: ARRAY
44603: PPUSH
44604: LD_EXP 104
44608: PUSH
44609: LD_VAR 0 2
44613: ARRAY
44614: PUSH
44615: LD_INT 1
44617: ARRAY
44618: PUSH
44619: LD_INT 2
44621: ARRAY
44622: PPUSH
44623: LD_EXP 104
44627: PUSH
44628: LD_VAR 0 2
44632: ARRAY
44633: PUSH
44634: LD_INT 1
44636: ARRAY
44637: PUSH
44638: LD_INT 3
44640: ARRAY
44641: PPUSH
44642: LD_EXP 104
44646: PUSH
44647: LD_VAR 0 2
44651: ARRAY
44652: PUSH
44653: LD_INT 1
44655: ARRAY
44656: PUSH
44657: LD_INT 4
44659: ARRAY
44660: PPUSH
44661: CALL 77922 0 5
44665: AND
44666: OR
44667: IFFALSE 44948
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44669: LD_ADDR_VAR 0 4
44673: PUSH
44674: LD_EXP 99
44678: PUSH
44679: LD_VAR 0 2
44683: ARRAY
44684: PPUSH
44685: LD_INT 25
44687: PUSH
44688: LD_INT 2
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PPUSH
44695: CALL_OW 72
44699: PUSH
44700: LD_EXP 101
44704: PUSH
44705: LD_VAR 0 2
44709: ARRAY
44710: DIFF
44711: ST_TO_ADDR
// if not tmp then
44712: LD_VAR 0 4
44716: NOT
44717: IFFALSE 44721
// continue ;
44719: GO 43966
// for j in tmp do
44721: LD_ADDR_VAR 0 3
44725: PUSH
44726: LD_VAR 0 4
44730: PUSH
44731: FOR_IN
44732: IFFALSE 44944
// begin if not mc_builders [ i ] then
44734: LD_EXP 105
44738: PUSH
44739: LD_VAR 0 2
44743: ARRAY
44744: NOT
44745: IFFALSE 44803
// begin SetTag ( j , 103 ) ;
44747: LD_VAR 0 3
44751: PPUSH
44752: LD_INT 103
44754: PPUSH
44755: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44759: LD_ADDR_EXP 105
44763: PUSH
44764: LD_EXP 105
44768: PPUSH
44769: LD_VAR 0 2
44773: PUSH
44774: LD_EXP 105
44778: PUSH
44779: LD_VAR 0 2
44783: ARRAY
44784: PUSH
44785: LD_INT 1
44787: PLUS
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PPUSH
44793: LD_VAR 0 3
44797: PPUSH
44798: CALL 70507 0 3
44802: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44803: LD_VAR 0 3
44807: PPUSH
44808: CALL_OW 310
44812: IFFALSE 44823
// ComExitBuilding ( j ) ;
44814: LD_VAR 0 3
44818: PPUSH
44819: CALL_OW 122
// wait ( 3 ) ;
44823: LD_INT 3
44825: PPUSH
44826: CALL_OW 67
// if not mc_build_list [ i ] then
44830: LD_EXP 104
44834: PUSH
44835: LD_VAR 0 2
44839: ARRAY
44840: NOT
44841: IFFALSE 44845
// break ;
44843: GO 44944
// if not HasTask ( j ) then
44845: LD_VAR 0 3
44849: PPUSH
44850: CALL_OW 314
44854: NOT
44855: IFFALSE 44942
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44857: LD_VAR 0 3
44861: PPUSH
44862: LD_EXP 104
44866: PUSH
44867: LD_VAR 0 2
44871: ARRAY
44872: PUSH
44873: LD_INT 1
44875: ARRAY
44876: PUSH
44877: LD_INT 1
44879: ARRAY
44880: PPUSH
44881: LD_EXP 104
44885: PUSH
44886: LD_VAR 0 2
44890: ARRAY
44891: PUSH
44892: LD_INT 1
44894: ARRAY
44895: PUSH
44896: LD_INT 2
44898: ARRAY
44899: PPUSH
44900: LD_EXP 104
44904: PUSH
44905: LD_VAR 0 2
44909: ARRAY
44910: PUSH
44911: LD_INT 1
44913: ARRAY
44914: PUSH
44915: LD_INT 3
44917: ARRAY
44918: PPUSH
44919: LD_EXP 104
44923: PUSH
44924: LD_VAR 0 2
44928: ARRAY
44929: PUSH
44930: LD_INT 1
44932: ARRAY
44933: PUSH
44934: LD_INT 4
44936: ARRAY
44937: PPUSH
44938: CALL_OW 145
// end ;
44942: GO 44731
44944: POP
44945: POP
// end else
44946: GO 45090
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
44948: LD_EXP 99
44952: PUSH
44953: LD_VAR 0 2
44957: ARRAY
44958: PPUSH
44959: LD_EXP 104
44963: PUSH
44964: LD_VAR 0 2
44968: ARRAY
44969: PUSH
44970: LD_INT 1
44972: ARRAY
44973: PUSH
44974: LD_INT 1
44976: ARRAY
44977: PPUSH
44978: LD_EXP 104
44982: PUSH
44983: LD_VAR 0 2
44987: ARRAY
44988: PUSH
44989: LD_INT 1
44991: ARRAY
44992: PUSH
44993: LD_INT 2
44995: ARRAY
44996: PPUSH
44997: LD_EXP 104
45001: PUSH
45002: LD_VAR 0 2
45006: ARRAY
45007: PUSH
45008: LD_INT 1
45010: ARRAY
45011: PUSH
45012: LD_INT 3
45014: ARRAY
45015: PPUSH
45016: LD_EXP 104
45020: PUSH
45021: LD_VAR 0 2
45025: ARRAY
45026: PUSH
45027: LD_INT 1
45029: ARRAY
45030: PUSH
45031: LD_INT 4
45033: ARRAY
45034: PPUSH
45035: CALL 77258 0 5
45039: NOT
45040: IFFALSE 45090
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45042: LD_ADDR_EXP 104
45046: PUSH
45047: LD_EXP 104
45051: PPUSH
45052: LD_VAR 0 2
45056: PPUSH
45057: LD_EXP 104
45061: PUSH
45062: LD_VAR 0 2
45066: ARRAY
45067: PPUSH
45068: LD_INT 1
45070: PPUSH
45071: LD_INT 1
45073: NEG
45074: PPUSH
45075: LD_INT 0
45077: PPUSH
45078: CALL 69925 0 4
45082: PPUSH
45083: CALL_OW 1
45087: ST_TO_ADDR
// continue ;
45088: GO 43966
// end ; end ; end ;
45090: GO 43966
45092: POP
45093: POP
// end ;
45094: LD_VAR 0 1
45098: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45099: LD_INT 0
45101: PPUSH
45102: PPUSH
45103: PPUSH
45104: PPUSH
45105: PPUSH
45106: PPUSH
// if not mc_bases then
45107: LD_EXP 99
45111: NOT
45112: IFFALSE 45116
// exit ;
45114: GO 45543
// for i = 1 to mc_bases do
45116: LD_ADDR_VAR 0 2
45120: PUSH
45121: DOUBLE
45122: LD_INT 1
45124: DEC
45125: ST_TO_ADDR
45126: LD_EXP 99
45130: PUSH
45131: FOR_TO
45132: IFFALSE 45541
// begin tmp := mc_build_upgrade [ i ] ;
45134: LD_ADDR_VAR 0 4
45138: PUSH
45139: LD_EXP 131
45143: PUSH
45144: LD_VAR 0 2
45148: ARRAY
45149: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45150: LD_ADDR_VAR 0 6
45154: PUSH
45155: LD_EXP 132
45159: PUSH
45160: LD_VAR 0 2
45164: ARRAY
45165: PPUSH
45166: LD_INT 2
45168: PUSH
45169: LD_INT 30
45171: PUSH
45172: LD_INT 6
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 30
45181: PUSH
45182: LD_INT 7
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: EMPTY
45190: LIST
45191: LIST
45192: LIST
45193: PPUSH
45194: CALL_OW 72
45198: ST_TO_ADDR
// if not tmp and not lab then
45199: LD_VAR 0 4
45203: NOT
45204: PUSH
45205: LD_VAR 0 6
45209: NOT
45210: AND
45211: IFFALSE 45215
// continue ;
45213: GO 45131
// if tmp then
45215: LD_VAR 0 4
45219: IFFALSE 45339
// for j in tmp do
45221: LD_ADDR_VAR 0 3
45225: PUSH
45226: LD_VAR 0 4
45230: PUSH
45231: FOR_IN
45232: IFFALSE 45337
// begin if UpgradeCost ( j ) then
45234: LD_VAR 0 3
45238: PPUSH
45239: CALL 76918 0 1
45243: IFFALSE 45335
// begin ComUpgrade ( j ) ;
45245: LD_VAR 0 3
45249: PPUSH
45250: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45254: LD_ADDR_EXP 131
45258: PUSH
45259: LD_EXP 131
45263: PPUSH
45264: LD_VAR 0 2
45268: PPUSH
45269: LD_EXP 131
45273: PUSH
45274: LD_VAR 0 2
45278: ARRAY
45279: PUSH
45280: LD_VAR 0 3
45284: DIFF
45285: PPUSH
45286: CALL_OW 1
45290: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45291: LD_ADDR_EXP 106
45295: PUSH
45296: LD_EXP 106
45300: PPUSH
45301: LD_VAR 0 2
45305: PUSH
45306: LD_EXP 106
45310: PUSH
45311: LD_VAR 0 2
45315: ARRAY
45316: PUSH
45317: LD_INT 1
45319: PLUS
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: PPUSH
45325: LD_VAR 0 3
45329: PPUSH
45330: CALL 70507 0 3
45334: ST_TO_ADDR
// end ; end ;
45335: GO 45231
45337: POP
45338: POP
// if not lab or not mc_lab_upgrade [ i ] then
45339: LD_VAR 0 6
45343: NOT
45344: PUSH
45345: LD_EXP 133
45349: PUSH
45350: LD_VAR 0 2
45354: ARRAY
45355: NOT
45356: OR
45357: IFFALSE 45361
// continue ;
45359: GO 45131
// for j in lab do
45361: LD_ADDR_VAR 0 3
45365: PUSH
45366: LD_VAR 0 6
45370: PUSH
45371: FOR_IN
45372: IFFALSE 45537
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45374: LD_VAR 0 3
45378: PPUSH
45379: CALL_OW 266
45383: PUSH
45384: LD_INT 6
45386: PUSH
45387: LD_INT 7
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: IN
45394: PUSH
45395: LD_VAR 0 3
45399: PPUSH
45400: CALL_OW 461
45404: PUSH
45405: LD_INT 1
45407: NONEQUAL
45408: AND
45409: IFFALSE 45535
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45411: LD_VAR 0 3
45415: PPUSH
45416: LD_EXP 133
45420: PUSH
45421: LD_VAR 0 2
45425: ARRAY
45426: PUSH
45427: LD_INT 1
45429: ARRAY
45430: PPUSH
45431: CALL 77123 0 2
45435: IFFALSE 45535
// begin ComCancel ( j ) ;
45437: LD_VAR 0 3
45441: PPUSH
45442: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45446: LD_VAR 0 3
45450: PPUSH
45451: LD_EXP 133
45455: PUSH
45456: LD_VAR 0 2
45460: ARRAY
45461: PUSH
45462: LD_INT 1
45464: ARRAY
45465: PPUSH
45466: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45470: LD_VAR 0 3
45474: PUSH
45475: LD_EXP 106
45479: PUSH
45480: LD_VAR 0 2
45484: ARRAY
45485: IN
45486: NOT
45487: IFFALSE 45533
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45489: LD_ADDR_EXP 106
45493: PUSH
45494: LD_EXP 106
45498: PPUSH
45499: LD_VAR 0 2
45503: PUSH
45504: LD_EXP 106
45508: PUSH
45509: LD_VAR 0 2
45513: ARRAY
45514: PUSH
45515: LD_INT 1
45517: PLUS
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PPUSH
45523: LD_VAR 0 3
45527: PPUSH
45528: CALL 70507 0 3
45532: ST_TO_ADDR
// break ;
45533: GO 45537
// end ; end ; end ;
45535: GO 45371
45537: POP
45538: POP
// end ;
45539: GO 45131
45541: POP
45542: POP
// end ;
45543: LD_VAR 0 1
45547: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45548: LD_INT 0
45550: PPUSH
45551: PPUSH
45552: PPUSH
45553: PPUSH
45554: PPUSH
45555: PPUSH
45556: PPUSH
45557: PPUSH
45558: PPUSH
// if not mc_bases then
45559: LD_EXP 99
45563: NOT
45564: IFFALSE 45568
// exit ;
45566: GO 45973
// for i = 1 to mc_bases do
45568: LD_ADDR_VAR 0 2
45572: PUSH
45573: DOUBLE
45574: LD_INT 1
45576: DEC
45577: ST_TO_ADDR
45578: LD_EXP 99
45582: PUSH
45583: FOR_TO
45584: IFFALSE 45971
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45586: LD_EXP 107
45590: PUSH
45591: LD_VAR 0 2
45595: ARRAY
45596: NOT
45597: PUSH
45598: LD_EXP 99
45602: PUSH
45603: LD_VAR 0 2
45607: ARRAY
45608: PPUSH
45609: LD_INT 30
45611: PUSH
45612: LD_INT 3
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PPUSH
45619: CALL_OW 72
45623: NOT
45624: OR
45625: IFFALSE 45629
// continue ;
45627: GO 45583
// busy := false ;
45629: LD_ADDR_VAR 0 8
45633: PUSH
45634: LD_INT 0
45636: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45637: LD_ADDR_VAR 0 4
45641: PUSH
45642: LD_EXP 99
45646: PUSH
45647: LD_VAR 0 2
45651: ARRAY
45652: PPUSH
45653: LD_INT 30
45655: PUSH
45656: LD_INT 3
45658: PUSH
45659: EMPTY
45660: LIST
45661: LIST
45662: PPUSH
45663: CALL_OW 72
45667: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45668: LD_ADDR_VAR 0 6
45672: PUSH
45673: LD_EXP 107
45677: PUSH
45678: LD_VAR 0 2
45682: ARRAY
45683: PPUSH
45684: LD_INT 2
45686: PUSH
45687: LD_INT 30
45689: PUSH
45690: LD_INT 32
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 30
45699: PUSH
45700: LD_INT 33
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: EMPTY
45708: LIST
45709: LIST
45710: LIST
45711: PPUSH
45712: CALL_OW 72
45716: ST_TO_ADDR
// if not t then
45717: LD_VAR 0 6
45721: NOT
45722: IFFALSE 45726
// continue ;
45724: GO 45583
// for j in tmp do
45726: LD_ADDR_VAR 0 3
45730: PUSH
45731: LD_VAR 0 4
45735: PUSH
45736: FOR_IN
45737: IFFALSE 45767
// if not BuildingStatus ( j ) = bs_idle then
45739: LD_VAR 0 3
45743: PPUSH
45744: CALL_OW 461
45748: PUSH
45749: LD_INT 2
45751: EQUAL
45752: NOT
45753: IFFALSE 45765
// begin busy := true ;
45755: LD_ADDR_VAR 0 8
45759: PUSH
45760: LD_INT 1
45762: ST_TO_ADDR
// break ;
45763: GO 45767
// end ;
45765: GO 45736
45767: POP
45768: POP
// if busy then
45769: LD_VAR 0 8
45773: IFFALSE 45777
// continue ;
45775: GO 45583
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45777: LD_ADDR_VAR 0 7
45781: PUSH
45782: LD_VAR 0 6
45786: PPUSH
45787: LD_INT 35
45789: PUSH
45790: LD_INT 0
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PPUSH
45797: CALL_OW 72
45801: ST_TO_ADDR
// if tw then
45802: LD_VAR 0 7
45806: IFFALSE 45883
// begin tw := tw [ 1 ] ;
45808: LD_ADDR_VAR 0 7
45812: PUSH
45813: LD_VAR 0 7
45817: PUSH
45818: LD_INT 1
45820: ARRAY
45821: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45822: LD_ADDR_VAR 0 9
45826: PUSH
45827: LD_VAR 0 7
45831: PPUSH
45832: LD_EXP 124
45836: PUSH
45837: LD_VAR 0 2
45841: ARRAY
45842: PPUSH
45843: CALL 75477 0 2
45847: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45848: LD_EXP 138
45852: PUSH
45853: LD_VAR 0 2
45857: ARRAY
45858: IFFALSE 45881
// if not weapon in mc_allowed_tower_weapons [ i ] then
45860: LD_VAR 0 9
45864: PUSH
45865: LD_EXP 138
45869: PUSH
45870: LD_VAR 0 2
45874: ARRAY
45875: IN
45876: NOT
45877: IFFALSE 45881
// continue ;
45879: GO 45583
// end else
45881: GO 45946
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45883: LD_ADDR_VAR 0 5
45887: PUSH
45888: LD_EXP 107
45892: PUSH
45893: LD_VAR 0 2
45897: ARRAY
45898: PPUSH
45899: LD_VAR 0 4
45903: PPUSH
45904: CALL 105678 0 2
45908: ST_TO_ADDR
// if not tmp2 then
45909: LD_VAR 0 5
45913: NOT
45914: IFFALSE 45918
// continue ;
45916: GO 45583
// tw := tmp2 [ 1 ] ;
45918: LD_ADDR_VAR 0 7
45922: PUSH
45923: LD_VAR 0 5
45927: PUSH
45928: LD_INT 1
45930: ARRAY
45931: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
45932: LD_ADDR_VAR 0 9
45936: PUSH
45937: LD_VAR 0 5
45941: PUSH
45942: LD_INT 2
45944: ARRAY
45945: ST_TO_ADDR
// end ; if not weapon then
45946: LD_VAR 0 9
45950: NOT
45951: IFFALSE 45955
// continue ;
45953: GO 45583
// ComPlaceWeapon ( tw , weapon ) ;
45955: LD_VAR 0 7
45959: PPUSH
45960: LD_VAR 0 9
45964: PPUSH
45965: CALL_OW 148
// end ;
45969: GO 45583
45971: POP
45972: POP
// end ;
45973: LD_VAR 0 1
45977: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
45978: LD_INT 0
45980: PPUSH
45981: PPUSH
45982: PPUSH
45983: PPUSH
45984: PPUSH
45985: PPUSH
// if not mc_bases then
45986: LD_EXP 99
45990: NOT
45991: IFFALSE 45995
// exit ;
45993: GO 47007
// for i = 1 to mc_bases do
45995: LD_ADDR_VAR 0 2
45999: PUSH
46000: DOUBLE
46001: LD_INT 1
46003: DEC
46004: ST_TO_ADDR
46005: LD_EXP 99
46009: PUSH
46010: FOR_TO
46011: IFFALSE 47005
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46013: LD_EXP 112
46017: PUSH
46018: LD_VAR 0 2
46022: ARRAY
46023: NOT
46024: PUSH
46025: LD_EXP 112
46029: PUSH
46030: LD_VAR 0 2
46034: ARRAY
46035: PUSH
46036: LD_EXP 113
46040: PUSH
46041: LD_VAR 0 2
46045: ARRAY
46046: EQUAL
46047: OR
46048: IFFALSE 46052
// continue ;
46050: GO 46010
// if mc_miners [ i ] then
46052: LD_EXP 113
46056: PUSH
46057: LD_VAR 0 2
46061: ARRAY
46062: IFFALSE 46692
// begin k := 1 ;
46064: LD_ADDR_VAR 0 4
46068: PUSH
46069: LD_INT 1
46071: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46072: LD_ADDR_VAR 0 3
46076: PUSH
46077: DOUBLE
46078: LD_EXP 113
46082: PUSH
46083: LD_VAR 0 2
46087: ARRAY
46088: INC
46089: ST_TO_ADDR
46090: LD_INT 1
46092: PUSH
46093: FOR_DOWNTO
46094: IFFALSE 46690
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46096: LD_EXP 113
46100: PUSH
46101: LD_VAR 0 2
46105: ARRAY
46106: PUSH
46107: LD_VAR 0 3
46111: ARRAY
46112: PPUSH
46113: CALL_OW 301
46117: PUSH
46118: LD_EXP 113
46122: PUSH
46123: LD_VAR 0 2
46127: ARRAY
46128: PUSH
46129: LD_VAR 0 3
46133: ARRAY
46134: PPUSH
46135: CALL_OW 257
46139: PUSH
46140: LD_INT 1
46142: NONEQUAL
46143: OR
46144: IFFALSE 46207
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46146: LD_ADDR_VAR 0 5
46150: PUSH
46151: LD_EXP 113
46155: PUSH
46156: LD_VAR 0 2
46160: ARRAY
46161: PUSH
46162: LD_EXP 113
46166: PUSH
46167: LD_VAR 0 2
46171: ARRAY
46172: PUSH
46173: LD_VAR 0 3
46177: ARRAY
46178: DIFF
46179: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46180: LD_ADDR_EXP 113
46184: PUSH
46185: LD_EXP 113
46189: PPUSH
46190: LD_VAR 0 2
46194: PPUSH
46195: LD_VAR 0 5
46199: PPUSH
46200: CALL_OW 1
46204: ST_TO_ADDR
// continue ;
46205: GO 46093
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46207: LD_EXP 113
46211: PUSH
46212: LD_VAR 0 2
46216: ARRAY
46217: PUSH
46218: LD_VAR 0 3
46222: ARRAY
46223: PPUSH
46224: CALL 70443 0 1
46228: PUSH
46229: LD_EXP 113
46233: PUSH
46234: LD_VAR 0 2
46238: ARRAY
46239: PUSH
46240: LD_VAR 0 3
46244: ARRAY
46245: PPUSH
46246: CALL_OW 255
46250: PPUSH
46251: LD_EXP 112
46255: PUSH
46256: LD_VAR 0 2
46260: ARRAY
46261: PUSH
46262: LD_VAR 0 4
46266: ARRAY
46267: PUSH
46268: LD_INT 1
46270: ARRAY
46271: PPUSH
46272: LD_EXP 112
46276: PUSH
46277: LD_VAR 0 2
46281: ARRAY
46282: PUSH
46283: LD_VAR 0 4
46287: ARRAY
46288: PUSH
46289: LD_INT 2
46291: ARRAY
46292: PPUSH
46293: LD_INT 15
46295: PPUSH
46296: CALL 71403 0 4
46300: PUSH
46301: LD_INT 4
46303: ARRAY
46304: PUSH
46305: LD_EXP 113
46309: PUSH
46310: LD_VAR 0 2
46314: ARRAY
46315: PUSH
46316: LD_VAR 0 3
46320: ARRAY
46321: PPUSH
46322: LD_INT 10
46324: PPUSH
46325: CALL 73100 0 2
46329: PUSH
46330: LD_INT 4
46332: ARRAY
46333: OR
46334: AND
46335: IFFALSE 46358
// ComStop ( mc_miners [ i ] [ j ] ) ;
46337: LD_EXP 113
46341: PUSH
46342: LD_VAR 0 2
46346: ARRAY
46347: PUSH
46348: LD_VAR 0 3
46352: ARRAY
46353: PPUSH
46354: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46358: LD_EXP 113
46362: PUSH
46363: LD_VAR 0 2
46367: ARRAY
46368: PUSH
46369: LD_VAR 0 3
46373: ARRAY
46374: PPUSH
46375: CALL_OW 257
46379: PUSH
46380: LD_INT 1
46382: EQUAL
46383: PUSH
46384: LD_EXP 113
46388: PUSH
46389: LD_VAR 0 2
46393: ARRAY
46394: PUSH
46395: LD_VAR 0 3
46399: ARRAY
46400: PPUSH
46401: CALL_OW 459
46405: NOT
46406: AND
46407: PUSH
46408: LD_EXP 113
46412: PUSH
46413: LD_VAR 0 2
46417: ARRAY
46418: PUSH
46419: LD_VAR 0 3
46423: ARRAY
46424: PPUSH
46425: CALL_OW 255
46429: PPUSH
46430: LD_EXP 112
46434: PUSH
46435: LD_VAR 0 2
46439: ARRAY
46440: PUSH
46441: LD_VAR 0 4
46445: ARRAY
46446: PUSH
46447: LD_INT 1
46449: ARRAY
46450: PPUSH
46451: LD_EXP 112
46455: PUSH
46456: LD_VAR 0 2
46460: ARRAY
46461: PUSH
46462: LD_VAR 0 4
46466: ARRAY
46467: PUSH
46468: LD_INT 2
46470: ARRAY
46471: PPUSH
46472: LD_INT 15
46474: PPUSH
46475: CALL 71403 0 4
46479: PUSH
46480: LD_INT 4
46482: ARRAY
46483: PUSH
46484: LD_INT 0
46486: EQUAL
46487: AND
46488: PUSH
46489: LD_EXP 113
46493: PUSH
46494: LD_VAR 0 2
46498: ARRAY
46499: PUSH
46500: LD_VAR 0 3
46504: ARRAY
46505: PPUSH
46506: CALL_OW 314
46510: NOT
46511: AND
46512: IFFALSE 46688
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46514: LD_EXP 113
46518: PUSH
46519: LD_VAR 0 2
46523: ARRAY
46524: PUSH
46525: LD_VAR 0 3
46529: ARRAY
46530: PPUSH
46531: CALL_OW 310
46535: IFFALSE 46558
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46537: LD_EXP 113
46541: PUSH
46542: LD_VAR 0 2
46546: ARRAY
46547: PUSH
46548: LD_VAR 0 3
46552: ARRAY
46553: PPUSH
46554: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46558: LD_EXP 113
46562: PUSH
46563: LD_VAR 0 2
46567: ARRAY
46568: PUSH
46569: LD_VAR 0 3
46573: ARRAY
46574: PPUSH
46575: CALL_OW 314
46579: NOT
46580: IFFALSE 46648
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46582: LD_EXP 113
46586: PUSH
46587: LD_VAR 0 2
46591: ARRAY
46592: PUSH
46593: LD_VAR 0 3
46597: ARRAY
46598: PPUSH
46599: LD_EXP 112
46603: PUSH
46604: LD_VAR 0 2
46608: ARRAY
46609: PUSH
46610: LD_VAR 0 4
46614: ARRAY
46615: PUSH
46616: LD_INT 1
46618: ARRAY
46619: PPUSH
46620: LD_EXP 112
46624: PUSH
46625: LD_VAR 0 2
46629: ARRAY
46630: PUSH
46631: LD_VAR 0 4
46635: ARRAY
46636: PUSH
46637: LD_INT 2
46639: ARRAY
46640: PPUSH
46641: LD_INT 0
46643: PPUSH
46644: CALL_OW 193
// k := k + 1 ;
46648: LD_ADDR_VAR 0 4
46652: PUSH
46653: LD_VAR 0 4
46657: PUSH
46658: LD_INT 1
46660: PLUS
46661: ST_TO_ADDR
// if k > mc_mines [ i ] then
46662: LD_VAR 0 4
46666: PUSH
46667: LD_EXP 112
46671: PUSH
46672: LD_VAR 0 2
46676: ARRAY
46677: GREATER
46678: IFFALSE 46688
// k := 1 ;
46680: LD_ADDR_VAR 0 4
46684: PUSH
46685: LD_INT 1
46687: ST_TO_ADDR
// end ; end ;
46688: GO 46093
46690: POP
46691: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46692: LD_ADDR_VAR 0 5
46696: PUSH
46697: LD_EXP 99
46701: PUSH
46702: LD_VAR 0 2
46706: ARRAY
46707: PPUSH
46708: LD_INT 2
46710: PUSH
46711: LD_INT 30
46713: PUSH
46714: LD_INT 4
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 30
46723: PUSH
46724: LD_INT 5
46726: PUSH
46727: EMPTY
46728: LIST
46729: LIST
46730: PUSH
46731: LD_INT 30
46733: PUSH
46734: LD_INT 32
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: PPUSH
46747: CALL_OW 72
46751: ST_TO_ADDR
// if not tmp then
46752: LD_VAR 0 5
46756: NOT
46757: IFFALSE 46761
// continue ;
46759: GO 46010
// list := [ ] ;
46761: LD_ADDR_VAR 0 6
46765: PUSH
46766: EMPTY
46767: ST_TO_ADDR
// for j in tmp do
46768: LD_ADDR_VAR 0 3
46772: PUSH
46773: LD_VAR 0 5
46777: PUSH
46778: FOR_IN
46779: IFFALSE 46848
// begin for k in UnitsInside ( j ) do
46781: LD_ADDR_VAR 0 4
46785: PUSH
46786: LD_VAR 0 3
46790: PPUSH
46791: CALL_OW 313
46795: PUSH
46796: FOR_IN
46797: IFFALSE 46844
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46799: LD_VAR 0 4
46803: PPUSH
46804: CALL_OW 257
46808: PUSH
46809: LD_INT 1
46811: EQUAL
46812: PUSH
46813: LD_VAR 0 4
46817: PPUSH
46818: CALL_OW 459
46822: NOT
46823: AND
46824: IFFALSE 46842
// list := list ^ k ;
46826: LD_ADDR_VAR 0 6
46830: PUSH
46831: LD_VAR 0 6
46835: PUSH
46836: LD_VAR 0 4
46840: ADD
46841: ST_TO_ADDR
46842: GO 46796
46844: POP
46845: POP
// end ;
46846: GO 46778
46848: POP
46849: POP
// list := list diff mc_miners [ i ] ;
46850: LD_ADDR_VAR 0 6
46854: PUSH
46855: LD_VAR 0 6
46859: PUSH
46860: LD_EXP 113
46864: PUSH
46865: LD_VAR 0 2
46869: ARRAY
46870: DIFF
46871: ST_TO_ADDR
// if not list then
46872: LD_VAR 0 6
46876: NOT
46877: IFFALSE 46881
// continue ;
46879: GO 46010
// k := mc_mines [ i ] - mc_miners [ i ] ;
46881: LD_ADDR_VAR 0 4
46885: PUSH
46886: LD_EXP 112
46890: PUSH
46891: LD_VAR 0 2
46895: ARRAY
46896: PUSH
46897: LD_EXP 113
46901: PUSH
46902: LD_VAR 0 2
46906: ARRAY
46907: MINUS
46908: ST_TO_ADDR
// if k > list then
46909: LD_VAR 0 4
46913: PUSH
46914: LD_VAR 0 6
46918: GREATER
46919: IFFALSE 46931
// k := list ;
46921: LD_ADDR_VAR 0 4
46925: PUSH
46926: LD_VAR 0 6
46930: ST_TO_ADDR
// for j = 1 to k do
46931: LD_ADDR_VAR 0 3
46935: PUSH
46936: DOUBLE
46937: LD_INT 1
46939: DEC
46940: ST_TO_ADDR
46941: LD_VAR 0 4
46945: PUSH
46946: FOR_TO
46947: IFFALSE 47001
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
46949: LD_ADDR_EXP 113
46953: PUSH
46954: LD_EXP 113
46958: PPUSH
46959: LD_VAR 0 2
46963: PUSH
46964: LD_EXP 113
46968: PUSH
46969: LD_VAR 0 2
46973: ARRAY
46974: PUSH
46975: LD_INT 1
46977: PLUS
46978: PUSH
46979: EMPTY
46980: LIST
46981: LIST
46982: PPUSH
46983: LD_VAR 0 6
46987: PUSH
46988: LD_VAR 0 3
46992: ARRAY
46993: PPUSH
46994: CALL 70507 0 3
46998: ST_TO_ADDR
46999: GO 46946
47001: POP
47002: POP
// end ;
47003: GO 46010
47005: POP
47006: POP
// end ;
47007: LD_VAR 0 1
47011: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47012: LD_INT 0
47014: PPUSH
47015: PPUSH
47016: PPUSH
47017: PPUSH
47018: PPUSH
47019: PPUSH
47020: PPUSH
47021: PPUSH
47022: PPUSH
47023: PPUSH
// if not mc_bases then
47024: LD_EXP 99
47028: NOT
47029: IFFALSE 47033
// exit ;
47031: GO 48783
// for i = 1 to mc_bases do
47033: LD_ADDR_VAR 0 2
47037: PUSH
47038: DOUBLE
47039: LD_INT 1
47041: DEC
47042: ST_TO_ADDR
47043: LD_EXP 99
47047: PUSH
47048: FOR_TO
47049: IFFALSE 48781
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47051: LD_EXP 99
47055: PUSH
47056: LD_VAR 0 2
47060: ARRAY
47061: NOT
47062: PUSH
47063: LD_EXP 106
47067: PUSH
47068: LD_VAR 0 2
47072: ARRAY
47073: OR
47074: IFFALSE 47078
// continue ;
47076: GO 47048
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47078: LD_EXP 115
47082: PUSH
47083: LD_VAR 0 2
47087: ARRAY
47088: NOT
47089: PUSH
47090: LD_EXP 116
47094: PUSH
47095: LD_VAR 0 2
47099: ARRAY
47100: AND
47101: IFFALSE 47139
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47103: LD_ADDR_EXP 116
47107: PUSH
47108: LD_EXP 116
47112: PPUSH
47113: LD_VAR 0 2
47117: PPUSH
47118: EMPTY
47119: PPUSH
47120: CALL_OW 1
47124: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47125: LD_VAR 0 2
47129: PPUSH
47130: LD_INT 107
47132: PPUSH
47133: CALL 37893 0 2
// continue ;
47137: GO 47048
// end ; target := [ ] ;
47139: LD_ADDR_VAR 0 6
47143: PUSH
47144: EMPTY
47145: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47146: LD_ADDR_VAR 0 3
47150: PUSH
47151: DOUBLE
47152: LD_EXP 115
47156: PUSH
47157: LD_VAR 0 2
47161: ARRAY
47162: INC
47163: ST_TO_ADDR
47164: LD_INT 1
47166: PUSH
47167: FOR_DOWNTO
47168: IFFALSE 47428
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47170: LD_EXP 115
47174: PUSH
47175: LD_VAR 0 2
47179: ARRAY
47180: PUSH
47181: LD_VAR 0 3
47185: ARRAY
47186: PUSH
47187: LD_INT 2
47189: ARRAY
47190: PPUSH
47191: LD_EXP 115
47195: PUSH
47196: LD_VAR 0 2
47200: ARRAY
47201: PUSH
47202: LD_VAR 0 3
47206: ARRAY
47207: PUSH
47208: LD_INT 3
47210: ARRAY
47211: PPUSH
47212: CALL_OW 488
47216: PUSH
47217: LD_EXP 115
47221: PUSH
47222: LD_VAR 0 2
47226: ARRAY
47227: PUSH
47228: LD_VAR 0 3
47232: ARRAY
47233: PUSH
47234: LD_INT 2
47236: ARRAY
47237: PPUSH
47238: LD_EXP 115
47242: PUSH
47243: LD_VAR 0 2
47247: ARRAY
47248: PUSH
47249: LD_VAR 0 3
47253: ARRAY
47254: PUSH
47255: LD_INT 3
47257: ARRAY
47258: PPUSH
47259: CALL_OW 284
47263: PUSH
47264: LD_INT 0
47266: EQUAL
47267: AND
47268: IFFALSE 47323
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47270: LD_ADDR_VAR 0 5
47274: PUSH
47275: LD_EXP 115
47279: PUSH
47280: LD_VAR 0 2
47284: ARRAY
47285: PPUSH
47286: LD_VAR 0 3
47290: PPUSH
47291: CALL_OW 3
47295: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47296: LD_ADDR_EXP 115
47300: PUSH
47301: LD_EXP 115
47305: PPUSH
47306: LD_VAR 0 2
47310: PPUSH
47311: LD_VAR 0 5
47315: PPUSH
47316: CALL_OW 1
47320: ST_TO_ADDR
// continue ;
47321: GO 47167
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47323: LD_EXP 99
47327: PUSH
47328: LD_VAR 0 2
47332: ARRAY
47333: PUSH
47334: LD_INT 1
47336: ARRAY
47337: PPUSH
47338: CALL_OW 255
47342: PPUSH
47343: LD_EXP 115
47347: PUSH
47348: LD_VAR 0 2
47352: ARRAY
47353: PUSH
47354: LD_VAR 0 3
47358: ARRAY
47359: PUSH
47360: LD_INT 2
47362: ARRAY
47363: PPUSH
47364: LD_EXP 115
47368: PUSH
47369: LD_VAR 0 2
47373: ARRAY
47374: PUSH
47375: LD_VAR 0 3
47379: ARRAY
47380: PUSH
47381: LD_INT 3
47383: ARRAY
47384: PPUSH
47385: LD_INT 30
47387: PPUSH
47388: CALL 71403 0 4
47392: PUSH
47393: LD_INT 4
47395: ARRAY
47396: PUSH
47397: LD_INT 0
47399: EQUAL
47400: IFFALSE 47426
// begin target := mc_crates [ i ] [ j ] ;
47402: LD_ADDR_VAR 0 6
47406: PUSH
47407: LD_EXP 115
47411: PUSH
47412: LD_VAR 0 2
47416: ARRAY
47417: PUSH
47418: LD_VAR 0 3
47422: ARRAY
47423: ST_TO_ADDR
// break ;
47424: GO 47428
// end ; end ;
47426: GO 47167
47428: POP
47429: POP
// if not target then
47430: LD_VAR 0 6
47434: NOT
47435: IFFALSE 47439
// continue ;
47437: GO 47048
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47439: LD_ADDR_VAR 0 7
47443: PUSH
47444: LD_EXP 118
47448: PUSH
47449: LD_VAR 0 2
47453: ARRAY
47454: PPUSH
47455: LD_INT 2
47457: PUSH
47458: LD_INT 3
47460: PUSH
47461: LD_INT 58
47463: PUSH
47464: EMPTY
47465: LIST
47466: PUSH
47467: EMPTY
47468: LIST
47469: LIST
47470: PUSH
47471: LD_INT 61
47473: PUSH
47474: EMPTY
47475: LIST
47476: PUSH
47477: LD_INT 33
47479: PUSH
47480: LD_INT 5
47482: PUSH
47483: EMPTY
47484: LIST
47485: LIST
47486: PUSH
47487: LD_INT 33
47489: PUSH
47490: LD_INT 3
47492: PUSH
47493: EMPTY
47494: LIST
47495: LIST
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: PUSH
47504: LD_INT 2
47506: PUSH
47507: LD_INT 34
47509: PUSH
47510: LD_INT 32
47512: PUSH
47513: EMPTY
47514: LIST
47515: LIST
47516: PUSH
47517: LD_INT 34
47519: PUSH
47520: LD_INT 51
47522: PUSH
47523: EMPTY
47524: LIST
47525: LIST
47526: PUSH
47527: LD_INT 34
47529: PUSH
47530: LD_INT 12
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: PUSH
47537: EMPTY
47538: LIST
47539: LIST
47540: LIST
47541: LIST
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PPUSH
47547: CALL_OW 72
47551: ST_TO_ADDR
// if not cargo then
47552: LD_VAR 0 7
47556: NOT
47557: IFFALSE 48200
// begin if mc_crates_collector [ i ] < 5 then
47559: LD_EXP 116
47563: PUSH
47564: LD_VAR 0 2
47568: ARRAY
47569: PUSH
47570: LD_INT 5
47572: LESS
47573: IFFALSE 47939
// begin if mc_ape [ i ] then
47575: LD_EXP 128
47579: PUSH
47580: LD_VAR 0 2
47584: ARRAY
47585: IFFALSE 47632
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47587: LD_ADDR_VAR 0 5
47591: PUSH
47592: LD_EXP 128
47596: PUSH
47597: LD_VAR 0 2
47601: ARRAY
47602: PPUSH
47603: LD_INT 25
47605: PUSH
47606: LD_INT 16
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 24
47615: PUSH
47616: LD_INT 750
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: PPUSH
47627: CALL_OW 72
47631: ST_TO_ADDR
// if not tmp then
47632: LD_VAR 0 5
47636: NOT
47637: IFFALSE 47684
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47639: LD_ADDR_VAR 0 5
47643: PUSH
47644: LD_EXP 99
47648: PUSH
47649: LD_VAR 0 2
47653: ARRAY
47654: PPUSH
47655: LD_INT 25
47657: PUSH
47658: LD_INT 2
47660: PUSH
47661: EMPTY
47662: LIST
47663: LIST
47664: PUSH
47665: LD_INT 24
47667: PUSH
47668: LD_INT 750
47670: PUSH
47671: EMPTY
47672: LIST
47673: LIST
47674: PUSH
47675: EMPTY
47676: LIST
47677: LIST
47678: PPUSH
47679: CALL_OW 72
47683: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47684: LD_EXP 128
47688: PUSH
47689: LD_VAR 0 2
47693: ARRAY
47694: PUSH
47695: LD_EXP 99
47699: PUSH
47700: LD_VAR 0 2
47704: ARRAY
47705: PPUSH
47706: LD_INT 25
47708: PUSH
47709: LD_INT 2
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: LD_INT 24
47718: PUSH
47719: LD_INT 750
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: PUSH
47726: EMPTY
47727: LIST
47728: LIST
47729: PPUSH
47730: CALL_OW 72
47734: AND
47735: PUSH
47736: LD_VAR 0 5
47740: PUSH
47741: LD_INT 5
47743: LESS
47744: AND
47745: IFFALSE 47827
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47747: LD_ADDR_VAR 0 3
47751: PUSH
47752: LD_EXP 99
47756: PUSH
47757: LD_VAR 0 2
47761: ARRAY
47762: PPUSH
47763: LD_INT 25
47765: PUSH
47766: LD_INT 2
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 24
47775: PUSH
47776: LD_INT 750
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: PPUSH
47787: CALL_OW 72
47791: PUSH
47792: FOR_IN
47793: IFFALSE 47825
// begin tmp := tmp union j ;
47795: LD_ADDR_VAR 0 5
47799: PUSH
47800: LD_VAR 0 5
47804: PUSH
47805: LD_VAR 0 3
47809: UNION
47810: ST_TO_ADDR
// if tmp >= 5 then
47811: LD_VAR 0 5
47815: PUSH
47816: LD_INT 5
47818: GREATEREQUAL
47819: IFFALSE 47823
// break ;
47821: GO 47825
// end ;
47823: GO 47792
47825: POP
47826: POP
// end ; if not tmp then
47827: LD_VAR 0 5
47831: NOT
47832: IFFALSE 47836
// continue ;
47834: GO 47048
// for j in tmp do
47836: LD_ADDR_VAR 0 3
47840: PUSH
47841: LD_VAR 0 5
47845: PUSH
47846: FOR_IN
47847: IFFALSE 47937
// if not GetTag ( j ) then
47849: LD_VAR 0 3
47853: PPUSH
47854: CALL_OW 110
47858: NOT
47859: IFFALSE 47935
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47861: LD_ADDR_EXP 116
47865: PUSH
47866: LD_EXP 116
47870: PPUSH
47871: LD_VAR 0 2
47875: PUSH
47876: LD_EXP 116
47880: PUSH
47881: LD_VAR 0 2
47885: ARRAY
47886: PUSH
47887: LD_INT 1
47889: PLUS
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: PPUSH
47895: LD_VAR 0 3
47899: PPUSH
47900: CALL 70507 0 3
47904: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47905: LD_VAR 0 3
47909: PPUSH
47910: LD_INT 107
47912: PPUSH
47913: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
47917: LD_EXP 116
47921: PUSH
47922: LD_VAR 0 2
47926: ARRAY
47927: PUSH
47928: LD_INT 5
47930: GREATEREQUAL
47931: IFFALSE 47935
// break ;
47933: GO 47937
// end ;
47935: GO 47846
47937: POP
47938: POP
// end ; if mc_crates_collector [ i ] and target then
47939: LD_EXP 116
47943: PUSH
47944: LD_VAR 0 2
47948: ARRAY
47949: PUSH
47950: LD_VAR 0 6
47954: AND
47955: IFFALSE 48198
// begin if mc_crates_collector [ i ] < target [ 1 ] then
47957: LD_EXP 116
47961: PUSH
47962: LD_VAR 0 2
47966: ARRAY
47967: PUSH
47968: LD_VAR 0 6
47972: PUSH
47973: LD_INT 1
47975: ARRAY
47976: LESS
47977: IFFALSE 47997
// tmp := mc_crates_collector [ i ] else
47979: LD_ADDR_VAR 0 5
47983: PUSH
47984: LD_EXP 116
47988: PUSH
47989: LD_VAR 0 2
47993: ARRAY
47994: ST_TO_ADDR
47995: GO 48011
// tmp := target [ 1 ] ;
47997: LD_ADDR_VAR 0 5
48001: PUSH
48002: LD_VAR 0 6
48006: PUSH
48007: LD_INT 1
48009: ARRAY
48010: ST_TO_ADDR
// k := 0 ;
48011: LD_ADDR_VAR 0 4
48015: PUSH
48016: LD_INT 0
48018: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48019: LD_ADDR_VAR 0 3
48023: PUSH
48024: LD_EXP 116
48028: PUSH
48029: LD_VAR 0 2
48033: ARRAY
48034: PUSH
48035: FOR_IN
48036: IFFALSE 48196
// begin k := k + 1 ;
48038: LD_ADDR_VAR 0 4
48042: PUSH
48043: LD_VAR 0 4
48047: PUSH
48048: LD_INT 1
48050: PLUS
48051: ST_TO_ADDR
// if k > tmp then
48052: LD_VAR 0 4
48056: PUSH
48057: LD_VAR 0 5
48061: GREATER
48062: IFFALSE 48066
// break ;
48064: GO 48196
// if not GetClass ( j ) in [ 2 , 16 ] then
48066: LD_VAR 0 3
48070: PPUSH
48071: CALL_OW 257
48075: PUSH
48076: LD_INT 2
48078: PUSH
48079: LD_INT 16
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: IN
48086: NOT
48087: IFFALSE 48140
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48089: LD_ADDR_EXP 116
48093: PUSH
48094: LD_EXP 116
48098: PPUSH
48099: LD_VAR 0 2
48103: PPUSH
48104: LD_EXP 116
48108: PUSH
48109: LD_VAR 0 2
48113: ARRAY
48114: PUSH
48115: LD_VAR 0 3
48119: DIFF
48120: PPUSH
48121: CALL_OW 1
48125: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48126: LD_VAR 0 3
48130: PPUSH
48131: LD_INT 0
48133: PPUSH
48134: CALL_OW 109
// continue ;
48138: GO 48035
// end ; if IsInUnit ( j ) then
48140: LD_VAR 0 3
48144: PPUSH
48145: CALL_OW 310
48149: IFFALSE 48160
// ComExitBuilding ( j ) ;
48151: LD_VAR 0 3
48155: PPUSH
48156: CALL_OW 122
// wait ( 3 ) ;
48160: LD_INT 3
48162: PPUSH
48163: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48167: LD_VAR 0 3
48171: PPUSH
48172: LD_VAR 0 6
48176: PUSH
48177: LD_INT 2
48179: ARRAY
48180: PPUSH
48181: LD_VAR 0 6
48185: PUSH
48186: LD_INT 3
48188: ARRAY
48189: PPUSH
48190: CALL_OW 117
// end ;
48194: GO 48035
48196: POP
48197: POP
// end ; end else
48198: GO 48779
// begin for j in cargo do
48200: LD_ADDR_VAR 0 3
48204: PUSH
48205: LD_VAR 0 7
48209: PUSH
48210: FOR_IN
48211: IFFALSE 48777
// begin if GetTag ( j ) <> 0 then
48213: LD_VAR 0 3
48217: PPUSH
48218: CALL_OW 110
48222: PUSH
48223: LD_INT 0
48225: NONEQUAL
48226: IFFALSE 48230
// continue ;
48228: GO 48210
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48230: LD_VAR 0 3
48234: PPUSH
48235: CALL_OW 256
48239: PUSH
48240: LD_INT 1000
48242: LESS
48243: PUSH
48244: LD_VAR 0 3
48248: PPUSH
48249: LD_EXP 123
48253: PUSH
48254: LD_VAR 0 2
48258: ARRAY
48259: PPUSH
48260: CALL_OW 308
48264: NOT
48265: AND
48266: IFFALSE 48288
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48268: LD_VAR 0 3
48272: PPUSH
48273: LD_EXP 123
48277: PUSH
48278: LD_VAR 0 2
48282: ARRAY
48283: PPUSH
48284: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48288: LD_VAR 0 3
48292: PPUSH
48293: CALL_OW 256
48297: PUSH
48298: LD_INT 1000
48300: LESS
48301: PUSH
48302: LD_VAR 0 3
48306: PPUSH
48307: LD_EXP 123
48311: PUSH
48312: LD_VAR 0 2
48316: ARRAY
48317: PPUSH
48318: CALL_OW 308
48322: AND
48323: IFFALSE 48327
// continue ;
48325: GO 48210
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48327: LD_VAR 0 3
48331: PPUSH
48332: CALL_OW 262
48336: PUSH
48337: LD_INT 2
48339: EQUAL
48340: PUSH
48341: LD_VAR 0 3
48345: PPUSH
48346: CALL_OW 261
48350: PUSH
48351: LD_INT 15
48353: LESS
48354: AND
48355: IFFALSE 48359
// continue ;
48357: GO 48210
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48359: LD_VAR 0 3
48363: PPUSH
48364: CALL_OW 262
48368: PUSH
48369: LD_INT 1
48371: EQUAL
48372: PUSH
48373: LD_VAR 0 3
48377: PPUSH
48378: CALL_OW 261
48382: PUSH
48383: LD_INT 10
48385: LESS
48386: AND
48387: IFFALSE 48716
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48389: LD_ADDR_VAR 0 8
48393: PUSH
48394: LD_EXP 99
48398: PUSH
48399: LD_VAR 0 2
48403: ARRAY
48404: PPUSH
48405: LD_INT 2
48407: PUSH
48408: LD_INT 30
48410: PUSH
48411: LD_INT 0
48413: PUSH
48414: EMPTY
48415: LIST
48416: LIST
48417: PUSH
48418: LD_INT 30
48420: PUSH
48421: LD_INT 1
48423: PUSH
48424: EMPTY
48425: LIST
48426: LIST
48427: PUSH
48428: EMPTY
48429: LIST
48430: LIST
48431: LIST
48432: PPUSH
48433: CALL_OW 72
48437: ST_TO_ADDR
// if not depot then
48438: LD_VAR 0 8
48442: NOT
48443: IFFALSE 48447
// continue ;
48445: GO 48210
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48447: LD_VAR 0 3
48451: PPUSH
48452: LD_VAR 0 8
48456: PPUSH
48457: LD_VAR 0 3
48461: PPUSH
48462: CALL_OW 74
48466: PPUSH
48467: CALL_OW 296
48471: PUSH
48472: LD_INT 6
48474: LESS
48475: IFFALSE 48491
// SetFuel ( j , 100 ) else
48477: LD_VAR 0 3
48481: PPUSH
48482: LD_INT 100
48484: PPUSH
48485: CALL_OW 240
48489: GO 48716
// if GetFuel ( j ) = 0 then
48491: LD_VAR 0 3
48495: PPUSH
48496: CALL_OW 261
48500: PUSH
48501: LD_INT 0
48503: EQUAL
48504: IFFALSE 48716
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48506: LD_ADDR_EXP 118
48510: PUSH
48511: LD_EXP 118
48515: PPUSH
48516: LD_VAR 0 2
48520: PPUSH
48521: LD_EXP 118
48525: PUSH
48526: LD_VAR 0 2
48530: ARRAY
48531: PUSH
48532: LD_VAR 0 3
48536: DIFF
48537: PPUSH
48538: CALL_OW 1
48542: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48543: LD_VAR 0 3
48547: PPUSH
48548: CALL_OW 263
48552: PUSH
48553: LD_INT 1
48555: EQUAL
48556: IFFALSE 48572
// ComExitVehicle ( IsInUnit ( j ) ) ;
48558: LD_VAR 0 3
48562: PPUSH
48563: CALL_OW 310
48567: PPUSH
48568: CALL_OW 121
// if GetControl ( j ) = control_remote then
48572: LD_VAR 0 3
48576: PPUSH
48577: CALL_OW 263
48581: PUSH
48582: LD_INT 2
48584: EQUAL
48585: IFFALSE 48596
// ComUnlink ( j ) ;
48587: LD_VAR 0 3
48591: PPUSH
48592: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48596: LD_ADDR_VAR 0 9
48600: PUSH
48601: LD_VAR 0 2
48605: PPUSH
48606: LD_INT 3
48608: PPUSH
48609: CALL 57853 0 2
48613: ST_TO_ADDR
// if fac then
48614: LD_VAR 0 9
48618: IFFALSE 48714
// begin for k in fac do
48620: LD_ADDR_VAR 0 4
48624: PUSH
48625: LD_VAR 0 9
48629: PUSH
48630: FOR_IN
48631: IFFALSE 48712
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48633: LD_ADDR_VAR 0 10
48637: PUSH
48638: LD_VAR 0 9
48642: PPUSH
48643: LD_VAR 0 3
48647: PPUSH
48648: CALL_OW 265
48652: PPUSH
48653: LD_VAR 0 3
48657: PPUSH
48658: CALL_OW 262
48662: PPUSH
48663: LD_VAR 0 3
48667: PPUSH
48668: CALL_OW 263
48672: PPUSH
48673: LD_VAR 0 3
48677: PPUSH
48678: CALL_OW 264
48682: PPUSH
48683: CALL 68039 0 5
48687: ST_TO_ADDR
// if components then
48688: LD_VAR 0 10
48692: IFFALSE 48710
// begin MC_InsertProduceList ( i , components ) ;
48694: LD_VAR 0 2
48698: PPUSH
48699: LD_VAR 0 10
48703: PPUSH
48704: CALL 57398 0 2
// break ;
48708: GO 48712
// end ; end ;
48710: GO 48630
48712: POP
48713: POP
// end ; continue ;
48714: GO 48210
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48716: LD_VAR 0 3
48720: PPUSH
48721: LD_INT 1
48723: PPUSH
48724: CALL_OW 289
48728: PUSH
48729: LD_INT 100
48731: LESS
48732: PUSH
48733: LD_VAR 0 3
48737: PPUSH
48738: CALL_OW 314
48742: NOT
48743: AND
48744: IFFALSE 48773
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48746: LD_VAR 0 3
48750: PPUSH
48751: LD_VAR 0 6
48755: PUSH
48756: LD_INT 2
48758: ARRAY
48759: PPUSH
48760: LD_VAR 0 6
48764: PUSH
48765: LD_INT 3
48767: ARRAY
48768: PPUSH
48769: CALL_OW 117
// break ;
48773: GO 48777
// end ;
48775: GO 48210
48777: POP
48778: POP
// end ; end ;
48779: GO 47048
48781: POP
48782: POP
// end ;
48783: LD_VAR 0 1
48787: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48788: LD_INT 0
48790: PPUSH
48791: PPUSH
48792: PPUSH
48793: PPUSH
// if not mc_bases then
48794: LD_EXP 99
48798: NOT
48799: IFFALSE 48803
// exit ;
48801: GO 48964
// for i = 1 to mc_bases do
48803: LD_ADDR_VAR 0 2
48807: PUSH
48808: DOUBLE
48809: LD_INT 1
48811: DEC
48812: ST_TO_ADDR
48813: LD_EXP 99
48817: PUSH
48818: FOR_TO
48819: IFFALSE 48962
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48821: LD_ADDR_VAR 0 4
48825: PUSH
48826: LD_EXP 118
48830: PUSH
48831: LD_VAR 0 2
48835: ARRAY
48836: PUSH
48837: LD_EXP 121
48841: PUSH
48842: LD_VAR 0 2
48846: ARRAY
48847: UNION
48848: PPUSH
48849: LD_INT 33
48851: PUSH
48852: LD_INT 2
48854: PUSH
48855: EMPTY
48856: LIST
48857: LIST
48858: PPUSH
48859: CALL_OW 72
48863: ST_TO_ADDR
// if tmp then
48864: LD_VAR 0 4
48868: IFFALSE 48960
// for j in tmp do
48870: LD_ADDR_VAR 0 3
48874: PUSH
48875: LD_VAR 0 4
48879: PUSH
48880: FOR_IN
48881: IFFALSE 48958
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48883: LD_VAR 0 3
48887: PPUSH
48888: CALL_OW 312
48892: NOT
48893: PUSH
48894: LD_VAR 0 3
48898: PPUSH
48899: CALL_OW 256
48903: PUSH
48904: LD_INT 250
48906: GREATEREQUAL
48907: AND
48908: IFFALSE 48921
// Connect ( j ) else
48910: LD_VAR 0 3
48914: PPUSH
48915: CALL 73440 0 1
48919: GO 48956
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
48921: LD_VAR 0 3
48925: PPUSH
48926: CALL_OW 256
48930: PUSH
48931: LD_INT 250
48933: LESS
48934: PUSH
48935: LD_VAR 0 3
48939: PPUSH
48940: CALL_OW 312
48944: AND
48945: IFFALSE 48956
// ComUnlink ( j ) ;
48947: LD_VAR 0 3
48951: PPUSH
48952: CALL_OW 136
48956: GO 48880
48958: POP
48959: POP
// end ;
48960: GO 48818
48962: POP
48963: POP
// end ;
48964: LD_VAR 0 1
48968: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
48969: LD_INT 0
48971: PPUSH
48972: PPUSH
48973: PPUSH
48974: PPUSH
48975: PPUSH
// if not mc_bases then
48976: LD_EXP 99
48980: NOT
48981: IFFALSE 48985
// exit ;
48983: GO 49430
// for i = 1 to mc_bases do
48985: LD_ADDR_VAR 0 2
48989: PUSH
48990: DOUBLE
48991: LD_INT 1
48993: DEC
48994: ST_TO_ADDR
48995: LD_EXP 99
48999: PUSH
49000: FOR_TO
49001: IFFALSE 49428
// begin if not mc_produce [ i ] then
49003: LD_EXP 120
49007: PUSH
49008: LD_VAR 0 2
49012: ARRAY
49013: NOT
49014: IFFALSE 49018
// continue ;
49016: GO 49000
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49018: LD_ADDR_VAR 0 5
49022: PUSH
49023: LD_EXP 99
49027: PUSH
49028: LD_VAR 0 2
49032: ARRAY
49033: PPUSH
49034: LD_INT 30
49036: PUSH
49037: LD_INT 3
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PPUSH
49044: CALL_OW 72
49048: ST_TO_ADDR
// if not fac then
49049: LD_VAR 0 5
49053: NOT
49054: IFFALSE 49058
// continue ;
49056: GO 49000
// for j in fac do
49058: LD_ADDR_VAR 0 3
49062: PUSH
49063: LD_VAR 0 5
49067: PUSH
49068: FOR_IN
49069: IFFALSE 49424
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49071: LD_VAR 0 3
49075: PPUSH
49076: CALL_OW 461
49080: PUSH
49081: LD_INT 2
49083: NONEQUAL
49084: PUSH
49085: LD_VAR 0 3
49089: PPUSH
49090: LD_INT 15
49092: PPUSH
49093: CALL 73100 0 2
49097: PUSH
49098: LD_INT 4
49100: ARRAY
49101: OR
49102: IFFALSE 49106
// continue ;
49104: GO 49068
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49106: LD_VAR 0 3
49110: PPUSH
49111: LD_EXP 120
49115: PUSH
49116: LD_VAR 0 2
49120: ARRAY
49121: PUSH
49122: LD_INT 1
49124: ARRAY
49125: PUSH
49126: LD_INT 1
49128: ARRAY
49129: PPUSH
49130: LD_EXP 120
49134: PUSH
49135: LD_VAR 0 2
49139: ARRAY
49140: PUSH
49141: LD_INT 1
49143: ARRAY
49144: PUSH
49145: LD_INT 2
49147: ARRAY
49148: PPUSH
49149: LD_EXP 120
49153: PUSH
49154: LD_VAR 0 2
49158: ARRAY
49159: PUSH
49160: LD_INT 1
49162: ARRAY
49163: PUSH
49164: LD_INT 3
49166: ARRAY
49167: PPUSH
49168: LD_EXP 120
49172: PUSH
49173: LD_VAR 0 2
49177: ARRAY
49178: PUSH
49179: LD_INT 1
49181: ARRAY
49182: PUSH
49183: LD_INT 4
49185: ARRAY
49186: PPUSH
49187: CALL_OW 448
49191: PUSH
49192: LD_VAR 0 3
49196: PPUSH
49197: LD_EXP 120
49201: PUSH
49202: LD_VAR 0 2
49206: ARRAY
49207: PUSH
49208: LD_INT 1
49210: ARRAY
49211: PUSH
49212: LD_INT 1
49214: ARRAY
49215: PUSH
49216: LD_EXP 120
49220: PUSH
49221: LD_VAR 0 2
49225: ARRAY
49226: PUSH
49227: LD_INT 1
49229: ARRAY
49230: PUSH
49231: LD_INT 2
49233: ARRAY
49234: PUSH
49235: LD_EXP 120
49239: PUSH
49240: LD_VAR 0 2
49244: ARRAY
49245: PUSH
49246: LD_INT 1
49248: ARRAY
49249: PUSH
49250: LD_INT 3
49252: ARRAY
49253: PUSH
49254: LD_EXP 120
49258: PUSH
49259: LD_VAR 0 2
49263: ARRAY
49264: PUSH
49265: LD_INT 1
49267: ARRAY
49268: PUSH
49269: LD_INT 4
49271: ARRAY
49272: PUSH
49273: EMPTY
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: PPUSH
49279: CALL 76771 0 2
49283: AND
49284: IFFALSE 49422
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49286: LD_VAR 0 3
49290: PPUSH
49291: LD_EXP 120
49295: PUSH
49296: LD_VAR 0 2
49300: ARRAY
49301: PUSH
49302: LD_INT 1
49304: ARRAY
49305: PUSH
49306: LD_INT 1
49308: ARRAY
49309: PPUSH
49310: LD_EXP 120
49314: PUSH
49315: LD_VAR 0 2
49319: ARRAY
49320: PUSH
49321: LD_INT 1
49323: ARRAY
49324: PUSH
49325: LD_INT 2
49327: ARRAY
49328: PPUSH
49329: LD_EXP 120
49333: PUSH
49334: LD_VAR 0 2
49338: ARRAY
49339: PUSH
49340: LD_INT 1
49342: ARRAY
49343: PUSH
49344: LD_INT 3
49346: ARRAY
49347: PPUSH
49348: LD_EXP 120
49352: PUSH
49353: LD_VAR 0 2
49357: ARRAY
49358: PUSH
49359: LD_INT 1
49361: ARRAY
49362: PUSH
49363: LD_INT 4
49365: ARRAY
49366: PPUSH
49367: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49371: LD_ADDR_VAR 0 4
49375: PUSH
49376: LD_EXP 120
49380: PUSH
49381: LD_VAR 0 2
49385: ARRAY
49386: PPUSH
49387: LD_INT 1
49389: PPUSH
49390: CALL_OW 3
49394: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49395: LD_ADDR_EXP 120
49399: PUSH
49400: LD_EXP 120
49404: PPUSH
49405: LD_VAR 0 2
49409: PPUSH
49410: LD_VAR 0 4
49414: PPUSH
49415: CALL_OW 1
49419: ST_TO_ADDR
// break ;
49420: GO 49424
// end ; end ;
49422: GO 49068
49424: POP
49425: POP
// end ;
49426: GO 49000
49428: POP
49429: POP
// end ;
49430: LD_VAR 0 1
49434: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49435: LD_INT 0
49437: PPUSH
49438: PPUSH
49439: PPUSH
// if not mc_bases then
49440: LD_EXP 99
49444: NOT
49445: IFFALSE 49449
// exit ;
49447: GO 49538
// for i = 1 to mc_bases do
49449: LD_ADDR_VAR 0 2
49453: PUSH
49454: DOUBLE
49455: LD_INT 1
49457: DEC
49458: ST_TO_ADDR
49459: LD_EXP 99
49463: PUSH
49464: FOR_TO
49465: IFFALSE 49536
// begin if mc_attack [ i ] then
49467: LD_EXP 119
49471: PUSH
49472: LD_VAR 0 2
49476: ARRAY
49477: IFFALSE 49534
// begin tmp := mc_attack [ i ] [ 1 ] ;
49479: LD_ADDR_VAR 0 3
49483: PUSH
49484: LD_EXP 119
49488: PUSH
49489: LD_VAR 0 2
49493: ARRAY
49494: PUSH
49495: LD_INT 1
49497: ARRAY
49498: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49499: LD_ADDR_EXP 119
49503: PUSH
49504: LD_EXP 119
49508: PPUSH
49509: LD_VAR 0 2
49513: PPUSH
49514: EMPTY
49515: PPUSH
49516: CALL_OW 1
49520: ST_TO_ADDR
// Attack ( tmp ) ;
49521: LD_VAR 0 3
49525: PPUSH
49526: CALL 98984 0 1
// exit ;
49530: POP
49531: POP
49532: GO 49538
// end ; end ;
49534: GO 49464
49536: POP
49537: POP
// end ;
49538: LD_VAR 0 1
49542: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49543: LD_INT 0
49545: PPUSH
49546: PPUSH
49547: PPUSH
49548: PPUSH
49549: PPUSH
49550: PPUSH
49551: PPUSH
// if not mc_bases then
49552: LD_EXP 99
49556: NOT
49557: IFFALSE 49561
// exit ;
49559: GO 50143
// for i = 1 to mc_bases do
49561: LD_ADDR_VAR 0 2
49565: PUSH
49566: DOUBLE
49567: LD_INT 1
49569: DEC
49570: ST_TO_ADDR
49571: LD_EXP 99
49575: PUSH
49576: FOR_TO
49577: IFFALSE 50141
// begin if not mc_bases [ i ] then
49579: LD_EXP 99
49583: PUSH
49584: LD_VAR 0 2
49588: ARRAY
49589: NOT
49590: IFFALSE 49594
// continue ;
49592: GO 49576
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49594: LD_ADDR_VAR 0 7
49598: PUSH
49599: LD_EXP 99
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PUSH
49610: LD_INT 1
49612: ARRAY
49613: PPUSH
49614: CALL 67343 0 1
49618: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49619: LD_ADDR_EXP 122
49623: PUSH
49624: LD_EXP 122
49628: PPUSH
49629: LD_VAR 0 2
49633: PPUSH
49634: LD_EXP 99
49638: PUSH
49639: LD_VAR 0 2
49643: ARRAY
49644: PUSH
49645: LD_INT 1
49647: ARRAY
49648: PPUSH
49649: CALL_OW 255
49653: PPUSH
49654: LD_EXP 124
49658: PUSH
49659: LD_VAR 0 2
49663: ARRAY
49664: PPUSH
49665: CALL 65235 0 2
49669: PPUSH
49670: CALL_OW 1
49674: ST_TO_ADDR
// if not mc_scan [ i ] then
49675: LD_EXP 122
49679: PUSH
49680: LD_VAR 0 2
49684: ARRAY
49685: NOT
49686: IFFALSE 49841
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49688: LD_ADDR_VAR 0 4
49692: PUSH
49693: LD_EXP 99
49697: PUSH
49698: LD_VAR 0 2
49702: ARRAY
49703: PPUSH
49704: LD_INT 2
49706: PUSH
49707: LD_INT 25
49709: PUSH
49710: LD_INT 5
49712: PUSH
49713: EMPTY
49714: LIST
49715: LIST
49716: PUSH
49717: LD_INT 25
49719: PUSH
49720: LD_INT 8
49722: PUSH
49723: EMPTY
49724: LIST
49725: LIST
49726: PUSH
49727: LD_INT 25
49729: PUSH
49730: LD_INT 9
49732: PUSH
49733: EMPTY
49734: LIST
49735: LIST
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: LIST
49741: LIST
49742: PPUSH
49743: CALL_OW 72
49747: ST_TO_ADDR
// if not tmp then
49748: LD_VAR 0 4
49752: NOT
49753: IFFALSE 49757
// continue ;
49755: GO 49576
// for j in tmp do
49757: LD_ADDR_VAR 0 3
49761: PUSH
49762: LD_VAR 0 4
49766: PUSH
49767: FOR_IN
49768: IFFALSE 49839
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49770: LD_VAR 0 3
49774: PPUSH
49775: CALL_OW 310
49779: PPUSH
49780: CALL_OW 266
49784: PUSH
49785: LD_INT 5
49787: EQUAL
49788: PUSH
49789: LD_VAR 0 3
49793: PPUSH
49794: CALL_OW 257
49798: PUSH
49799: LD_INT 1
49801: EQUAL
49802: AND
49803: PUSH
49804: LD_VAR 0 3
49808: PPUSH
49809: CALL_OW 459
49813: NOT
49814: AND
49815: PUSH
49816: LD_VAR 0 7
49820: AND
49821: IFFALSE 49837
// ComChangeProfession ( j , class ) ;
49823: LD_VAR 0 3
49827: PPUSH
49828: LD_VAR 0 7
49832: PPUSH
49833: CALL_OW 123
49837: GO 49767
49839: POP
49840: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49841: LD_EXP 122
49845: PUSH
49846: LD_VAR 0 2
49850: ARRAY
49851: PUSH
49852: LD_EXP 121
49856: PUSH
49857: LD_VAR 0 2
49861: ARRAY
49862: NOT
49863: AND
49864: PUSH
49865: LD_EXP 99
49869: PUSH
49870: LD_VAR 0 2
49874: ARRAY
49875: PPUSH
49876: LD_INT 30
49878: PUSH
49879: LD_INT 32
49881: PUSH
49882: EMPTY
49883: LIST
49884: LIST
49885: PPUSH
49886: CALL_OW 72
49890: NOT
49891: AND
49892: PUSH
49893: LD_EXP 99
49897: PUSH
49898: LD_VAR 0 2
49902: ARRAY
49903: PPUSH
49904: LD_INT 2
49906: PUSH
49907: LD_INT 30
49909: PUSH
49910: LD_INT 4
49912: PUSH
49913: EMPTY
49914: LIST
49915: LIST
49916: PUSH
49917: LD_INT 30
49919: PUSH
49920: LD_INT 5
49922: PUSH
49923: EMPTY
49924: LIST
49925: LIST
49926: PUSH
49927: EMPTY
49928: LIST
49929: LIST
49930: LIST
49931: PPUSH
49932: CALL_OW 72
49936: NOT
49937: AND
49938: IFFALSE 50070
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49940: LD_ADDR_VAR 0 4
49944: PUSH
49945: LD_EXP 99
49949: PUSH
49950: LD_VAR 0 2
49954: ARRAY
49955: PPUSH
49956: LD_INT 2
49958: PUSH
49959: LD_INT 25
49961: PUSH
49962: LD_INT 1
49964: PUSH
49965: EMPTY
49966: LIST
49967: LIST
49968: PUSH
49969: LD_INT 25
49971: PUSH
49972: LD_INT 5
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PUSH
49979: LD_INT 25
49981: PUSH
49982: LD_INT 8
49984: PUSH
49985: EMPTY
49986: LIST
49987: LIST
49988: PUSH
49989: LD_INT 25
49991: PUSH
49992: LD_INT 9
49994: PUSH
49995: EMPTY
49996: LIST
49997: LIST
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: PPUSH
50006: CALL_OW 72
50010: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50011: LD_ADDR_VAR 0 4
50015: PUSH
50016: LD_VAR 0 4
50020: PUSH
50021: LD_VAR 0 4
50025: PPUSH
50026: LD_INT 18
50028: PPUSH
50029: CALL 103767 0 2
50033: DIFF
50034: ST_TO_ADDR
// if tmp then
50035: LD_VAR 0 4
50039: IFFALSE 50070
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50041: LD_VAR 0 2
50045: PPUSH
50046: LD_VAR 0 4
50050: PPUSH
50051: LD_EXP 124
50055: PUSH
50056: LD_VAR 0 2
50060: ARRAY
50061: PPUSH
50062: CALL 65270 0 3
// exit ;
50066: POP
50067: POP
50068: GO 50143
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50070: LD_EXP 122
50074: PUSH
50075: LD_VAR 0 2
50079: ARRAY
50080: PUSH
50081: LD_EXP 121
50085: PUSH
50086: LD_VAR 0 2
50090: ARRAY
50091: AND
50092: IFFALSE 50139
// begin tmp := mc_defender [ i ] ;
50094: LD_ADDR_VAR 0 4
50098: PUSH
50099: LD_EXP 121
50103: PUSH
50104: LD_VAR 0 2
50108: ARRAY
50109: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50110: LD_VAR 0 2
50114: PPUSH
50115: LD_VAR 0 4
50119: PPUSH
50120: LD_EXP 122
50124: PUSH
50125: LD_VAR 0 2
50129: ARRAY
50130: PPUSH
50131: CALL 65768 0 3
// exit ;
50135: POP
50136: POP
50137: GO 50143
// end ; end ;
50139: GO 49576
50141: POP
50142: POP
// end ;
50143: LD_VAR 0 1
50147: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50148: LD_INT 0
50150: PPUSH
50151: PPUSH
50152: PPUSH
50153: PPUSH
50154: PPUSH
50155: PPUSH
50156: PPUSH
50157: PPUSH
50158: PPUSH
50159: PPUSH
50160: PPUSH
// if not mc_bases then
50161: LD_EXP 99
50165: NOT
50166: IFFALSE 50170
// exit ;
50168: GO 51257
// for i = 1 to mc_bases do
50170: LD_ADDR_VAR 0 2
50174: PUSH
50175: DOUBLE
50176: LD_INT 1
50178: DEC
50179: ST_TO_ADDR
50180: LD_EXP 99
50184: PUSH
50185: FOR_TO
50186: IFFALSE 51255
// begin tmp := mc_lab [ i ] ;
50188: LD_ADDR_VAR 0 6
50192: PUSH
50193: LD_EXP 132
50197: PUSH
50198: LD_VAR 0 2
50202: ARRAY
50203: ST_TO_ADDR
// if not tmp then
50204: LD_VAR 0 6
50208: NOT
50209: IFFALSE 50213
// continue ;
50211: GO 50185
// idle_lab := 0 ;
50213: LD_ADDR_VAR 0 11
50217: PUSH
50218: LD_INT 0
50220: ST_TO_ADDR
// for j in tmp do
50221: LD_ADDR_VAR 0 3
50225: PUSH
50226: LD_VAR 0 6
50230: PUSH
50231: FOR_IN
50232: IFFALSE 51251
// begin researching := false ;
50234: LD_ADDR_VAR 0 10
50238: PUSH
50239: LD_INT 0
50241: ST_TO_ADDR
// side := GetSide ( j ) ;
50242: LD_ADDR_VAR 0 4
50246: PUSH
50247: LD_VAR 0 3
50251: PPUSH
50252: CALL_OW 255
50256: ST_TO_ADDR
// if not mc_tech [ side ] then
50257: LD_EXP 126
50261: PUSH
50262: LD_VAR 0 4
50266: ARRAY
50267: NOT
50268: IFFALSE 50272
// continue ;
50270: GO 50231
// if BuildingStatus ( j ) = bs_idle then
50272: LD_VAR 0 3
50276: PPUSH
50277: CALL_OW 461
50281: PUSH
50282: LD_INT 2
50284: EQUAL
50285: IFFALSE 50473
// begin if idle_lab and UnitsInside ( j ) < 6 then
50287: LD_VAR 0 11
50291: PUSH
50292: LD_VAR 0 3
50296: PPUSH
50297: CALL_OW 313
50301: PUSH
50302: LD_INT 6
50304: LESS
50305: AND
50306: IFFALSE 50377
// begin tmp2 := UnitsInside ( idle_lab ) ;
50308: LD_ADDR_VAR 0 9
50312: PUSH
50313: LD_VAR 0 11
50317: PPUSH
50318: CALL_OW 313
50322: ST_TO_ADDR
// if tmp2 then
50323: LD_VAR 0 9
50327: IFFALSE 50369
// for x in tmp2 do
50329: LD_ADDR_VAR 0 7
50333: PUSH
50334: LD_VAR 0 9
50338: PUSH
50339: FOR_IN
50340: IFFALSE 50367
// begin ComExitBuilding ( x ) ;
50342: LD_VAR 0 7
50346: PPUSH
50347: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50351: LD_VAR 0 7
50355: PPUSH
50356: LD_VAR 0 3
50360: PPUSH
50361: CALL_OW 180
// end ;
50365: GO 50339
50367: POP
50368: POP
// idle_lab := 0 ;
50369: LD_ADDR_VAR 0 11
50373: PUSH
50374: LD_INT 0
50376: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50377: LD_ADDR_VAR 0 5
50381: PUSH
50382: LD_EXP 126
50386: PUSH
50387: LD_VAR 0 4
50391: ARRAY
50392: PUSH
50393: FOR_IN
50394: IFFALSE 50454
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50396: LD_VAR 0 3
50400: PPUSH
50401: LD_VAR 0 5
50405: PPUSH
50406: CALL_OW 430
50410: PUSH
50411: LD_VAR 0 4
50415: PPUSH
50416: LD_VAR 0 5
50420: PPUSH
50421: CALL 64340 0 2
50425: AND
50426: IFFALSE 50452
// begin researching := true ;
50428: LD_ADDR_VAR 0 10
50432: PUSH
50433: LD_INT 1
50435: ST_TO_ADDR
// ComResearch ( j , t ) ;
50436: LD_VAR 0 3
50440: PPUSH
50441: LD_VAR 0 5
50445: PPUSH
50446: CALL_OW 124
// break ;
50450: GO 50454
// end ;
50452: GO 50393
50454: POP
50455: POP
// if not researching then
50456: LD_VAR 0 10
50460: NOT
50461: IFFALSE 50473
// idle_lab := j ;
50463: LD_ADDR_VAR 0 11
50467: PUSH
50468: LD_VAR 0 3
50472: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50473: LD_VAR 0 3
50477: PPUSH
50478: CALL_OW 461
50482: PUSH
50483: LD_INT 10
50485: EQUAL
50486: IFFALSE 51074
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50488: LD_EXP 128
50492: PUSH
50493: LD_VAR 0 2
50497: ARRAY
50498: NOT
50499: PUSH
50500: LD_EXP 129
50504: PUSH
50505: LD_VAR 0 2
50509: ARRAY
50510: NOT
50511: AND
50512: PUSH
50513: LD_EXP 126
50517: PUSH
50518: LD_VAR 0 4
50522: ARRAY
50523: PUSH
50524: LD_INT 1
50526: GREATER
50527: AND
50528: IFFALSE 50659
// begin ComCancel ( j ) ;
50530: LD_VAR 0 3
50534: PPUSH
50535: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50539: LD_ADDR_EXP 126
50543: PUSH
50544: LD_EXP 126
50548: PPUSH
50549: LD_VAR 0 4
50553: PPUSH
50554: LD_EXP 126
50558: PUSH
50559: LD_VAR 0 4
50563: ARRAY
50564: PPUSH
50565: LD_EXP 126
50569: PUSH
50570: LD_VAR 0 4
50574: ARRAY
50575: PUSH
50576: LD_INT 1
50578: MINUS
50579: PPUSH
50580: LD_EXP 126
50584: PUSH
50585: LD_VAR 0 4
50589: ARRAY
50590: PPUSH
50591: LD_INT 0
50593: PPUSH
50594: CALL 69925 0 4
50598: PPUSH
50599: CALL_OW 1
50603: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50604: LD_ADDR_EXP 126
50608: PUSH
50609: LD_EXP 126
50613: PPUSH
50614: LD_VAR 0 4
50618: PPUSH
50619: LD_EXP 126
50623: PUSH
50624: LD_VAR 0 4
50628: ARRAY
50629: PPUSH
50630: LD_EXP 126
50634: PUSH
50635: LD_VAR 0 4
50639: ARRAY
50640: PPUSH
50641: LD_INT 1
50643: PPUSH
50644: LD_INT 0
50646: PPUSH
50647: CALL 69925 0 4
50651: PPUSH
50652: CALL_OW 1
50656: ST_TO_ADDR
// continue ;
50657: GO 50231
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50659: LD_EXP 128
50663: PUSH
50664: LD_VAR 0 2
50668: ARRAY
50669: PUSH
50670: LD_EXP 129
50674: PUSH
50675: LD_VAR 0 2
50679: ARRAY
50680: NOT
50681: AND
50682: IFFALSE 50809
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50684: LD_ADDR_EXP 129
50688: PUSH
50689: LD_EXP 129
50693: PPUSH
50694: LD_VAR 0 2
50698: PUSH
50699: LD_EXP 129
50703: PUSH
50704: LD_VAR 0 2
50708: ARRAY
50709: PUSH
50710: LD_INT 1
50712: PLUS
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: PPUSH
50718: LD_EXP 128
50722: PUSH
50723: LD_VAR 0 2
50727: ARRAY
50728: PUSH
50729: LD_INT 1
50731: ARRAY
50732: PPUSH
50733: CALL 70507 0 3
50737: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50738: LD_EXP 128
50742: PUSH
50743: LD_VAR 0 2
50747: ARRAY
50748: PUSH
50749: LD_INT 1
50751: ARRAY
50752: PPUSH
50753: LD_INT 112
50755: PPUSH
50756: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50760: LD_ADDR_VAR 0 9
50764: PUSH
50765: LD_EXP 128
50769: PUSH
50770: LD_VAR 0 2
50774: ARRAY
50775: PPUSH
50776: LD_INT 1
50778: PPUSH
50779: CALL_OW 3
50783: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50784: LD_ADDR_EXP 128
50788: PUSH
50789: LD_EXP 128
50793: PPUSH
50794: LD_VAR 0 2
50798: PPUSH
50799: LD_VAR 0 9
50803: PPUSH
50804: CALL_OW 1
50808: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50809: LD_EXP 128
50813: PUSH
50814: LD_VAR 0 2
50818: ARRAY
50819: PUSH
50820: LD_EXP 129
50824: PUSH
50825: LD_VAR 0 2
50829: ARRAY
50830: AND
50831: PUSH
50832: LD_EXP 129
50836: PUSH
50837: LD_VAR 0 2
50841: ARRAY
50842: PUSH
50843: LD_INT 1
50845: ARRAY
50846: PPUSH
50847: CALL_OW 310
50851: NOT
50852: AND
50853: PUSH
50854: LD_VAR 0 3
50858: PPUSH
50859: CALL_OW 313
50863: PUSH
50864: LD_INT 6
50866: EQUAL
50867: AND
50868: IFFALSE 50924
// begin tmp2 := UnitsInside ( j ) ;
50870: LD_ADDR_VAR 0 9
50874: PUSH
50875: LD_VAR 0 3
50879: PPUSH
50880: CALL_OW 313
50884: ST_TO_ADDR
// if tmp2 = 6 then
50885: LD_VAR 0 9
50889: PUSH
50890: LD_INT 6
50892: EQUAL
50893: IFFALSE 50924
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50895: LD_VAR 0 9
50899: PUSH
50900: LD_INT 1
50902: ARRAY
50903: PPUSH
50904: LD_INT 112
50906: PPUSH
50907: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
50911: LD_VAR 0 9
50915: PUSH
50916: LD_INT 1
50918: ARRAY
50919: PPUSH
50920: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
50924: LD_EXP 129
50928: PUSH
50929: LD_VAR 0 2
50933: ARRAY
50934: PUSH
50935: LD_EXP 129
50939: PUSH
50940: LD_VAR 0 2
50944: ARRAY
50945: PUSH
50946: LD_INT 1
50948: ARRAY
50949: PPUSH
50950: CALL_OW 314
50954: NOT
50955: AND
50956: PUSH
50957: LD_EXP 129
50961: PUSH
50962: LD_VAR 0 2
50966: ARRAY
50967: PUSH
50968: LD_INT 1
50970: ARRAY
50971: PPUSH
50972: CALL_OW 310
50976: NOT
50977: AND
50978: IFFALSE 51004
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
50980: LD_EXP 129
50984: PUSH
50985: LD_VAR 0 2
50989: ARRAY
50990: PUSH
50991: LD_INT 1
50993: ARRAY
50994: PPUSH
50995: LD_VAR 0 3
50999: PPUSH
51000: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51004: LD_EXP 129
51008: PUSH
51009: LD_VAR 0 2
51013: ARRAY
51014: PUSH
51015: LD_INT 1
51017: ARRAY
51018: PPUSH
51019: CALL_OW 310
51023: PUSH
51024: LD_EXP 129
51028: PUSH
51029: LD_VAR 0 2
51033: ARRAY
51034: PUSH
51035: LD_INT 1
51037: ARRAY
51038: PPUSH
51039: CALL_OW 310
51043: PPUSH
51044: CALL_OW 461
51048: PUSH
51049: LD_INT 3
51051: NONEQUAL
51052: AND
51053: IFFALSE 51074
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51055: LD_EXP 129
51059: PUSH
51060: LD_VAR 0 2
51064: ARRAY
51065: PUSH
51066: LD_INT 1
51068: ARRAY
51069: PPUSH
51070: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51074: LD_VAR 0 3
51078: PPUSH
51079: CALL_OW 461
51083: PUSH
51084: LD_INT 6
51086: EQUAL
51087: PUSH
51088: LD_VAR 0 6
51092: PUSH
51093: LD_INT 1
51095: GREATER
51096: AND
51097: IFFALSE 51249
// begin sci := [ ] ;
51099: LD_ADDR_VAR 0 8
51103: PUSH
51104: EMPTY
51105: ST_TO_ADDR
// for x in ( tmp diff j ) do
51106: LD_ADDR_VAR 0 7
51110: PUSH
51111: LD_VAR 0 6
51115: PUSH
51116: LD_VAR 0 3
51120: DIFF
51121: PUSH
51122: FOR_IN
51123: IFFALSE 51175
// begin if sci = 6 then
51125: LD_VAR 0 8
51129: PUSH
51130: LD_INT 6
51132: EQUAL
51133: IFFALSE 51137
// break ;
51135: GO 51175
// if BuildingStatus ( x ) = bs_idle then
51137: LD_VAR 0 7
51141: PPUSH
51142: CALL_OW 461
51146: PUSH
51147: LD_INT 2
51149: EQUAL
51150: IFFALSE 51173
// sci := sci ^ UnitsInside ( x ) ;
51152: LD_ADDR_VAR 0 8
51156: PUSH
51157: LD_VAR 0 8
51161: PUSH
51162: LD_VAR 0 7
51166: PPUSH
51167: CALL_OW 313
51171: ADD
51172: ST_TO_ADDR
// end ;
51173: GO 51122
51175: POP
51176: POP
// if not sci then
51177: LD_VAR 0 8
51181: NOT
51182: IFFALSE 51186
// continue ;
51184: GO 50231
// for x in sci do
51186: LD_ADDR_VAR 0 7
51190: PUSH
51191: LD_VAR 0 8
51195: PUSH
51196: FOR_IN
51197: IFFALSE 51247
// if IsInUnit ( x ) and not HasTask ( x ) then
51199: LD_VAR 0 7
51203: PPUSH
51204: CALL_OW 310
51208: PUSH
51209: LD_VAR 0 7
51213: PPUSH
51214: CALL_OW 314
51218: NOT
51219: AND
51220: IFFALSE 51245
// begin ComExitBuilding ( x ) ;
51222: LD_VAR 0 7
51226: PPUSH
51227: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51231: LD_VAR 0 7
51235: PPUSH
51236: LD_VAR 0 3
51240: PPUSH
51241: CALL_OW 180
// end ;
51245: GO 51196
51247: POP
51248: POP
// end ; end ;
51249: GO 50231
51251: POP
51252: POP
// end ;
51253: GO 50185
51255: POP
51256: POP
// end ;
51257: LD_VAR 0 1
51261: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51262: LD_INT 0
51264: PPUSH
51265: PPUSH
// if not mc_bases then
51266: LD_EXP 99
51270: NOT
51271: IFFALSE 51275
// exit ;
51273: GO 51356
// for i = 1 to mc_bases do
51275: LD_ADDR_VAR 0 2
51279: PUSH
51280: DOUBLE
51281: LD_INT 1
51283: DEC
51284: ST_TO_ADDR
51285: LD_EXP 99
51289: PUSH
51290: FOR_TO
51291: IFFALSE 51354
// if mc_mines [ i ] and mc_miners [ i ] then
51293: LD_EXP 112
51297: PUSH
51298: LD_VAR 0 2
51302: ARRAY
51303: PUSH
51304: LD_EXP 113
51308: PUSH
51309: LD_VAR 0 2
51313: ARRAY
51314: AND
51315: IFFALSE 51352
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51317: LD_EXP 113
51321: PUSH
51322: LD_VAR 0 2
51326: ARRAY
51327: PUSH
51328: LD_INT 1
51330: ARRAY
51331: PPUSH
51332: CALL_OW 255
51336: PPUSH
51337: LD_EXP 112
51341: PUSH
51342: LD_VAR 0 2
51346: ARRAY
51347: PPUSH
51348: CALL 67496 0 2
51352: GO 51290
51354: POP
51355: POP
// end ;
51356: LD_VAR 0 1
51360: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51361: LD_INT 0
51363: PPUSH
51364: PPUSH
51365: PPUSH
51366: PPUSH
51367: PPUSH
51368: PPUSH
51369: PPUSH
51370: PPUSH
// if not mc_bases or not mc_parking then
51371: LD_EXP 99
51375: NOT
51376: PUSH
51377: LD_EXP 123
51381: NOT
51382: OR
51383: IFFALSE 51387
// exit ;
51385: GO 52086
// for i = 1 to mc_bases do
51387: LD_ADDR_VAR 0 2
51391: PUSH
51392: DOUBLE
51393: LD_INT 1
51395: DEC
51396: ST_TO_ADDR
51397: LD_EXP 99
51401: PUSH
51402: FOR_TO
51403: IFFALSE 52084
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51405: LD_EXP 99
51409: PUSH
51410: LD_VAR 0 2
51414: ARRAY
51415: NOT
51416: PUSH
51417: LD_EXP 123
51421: PUSH
51422: LD_VAR 0 2
51426: ARRAY
51427: NOT
51428: OR
51429: IFFALSE 51433
// continue ;
51431: GO 51402
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51433: LD_ADDR_VAR 0 5
51437: PUSH
51438: LD_EXP 99
51442: PUSH
51443: LD_VAR 0 2
51447: ARRAY
51448: PUSH
51449: LD_INT 1
51451: ARRAY
51452: PPUSH
51453: CALL_OW 255
51457: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51458: LD_ADDR_VAR 0 6
51462: PUSH
51463: LD_EXP 99
51467: PUSH
51468: LD_VAR 0 2
51472: ARRAY
51473: PPUSH
51474: LD_INT 30
51476: PUSH
51477: LD_INT 3
51479: PUSH
51480: EMPTY
51481: LIST
51482: LIST
51483: PPUSH
51484: CALL_OW 72
51488: ST_TO_ADDR
// if not fac then
51489: LD_VAR 0 6
51493: NOT
51494: IFFALSE 51545
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51496: LD_ADDR_VAR 0 6
51500: PUSH
51501: LD_EXP 99
51505: PUSH
51506: LD_VAR 0 2
51510: ARRAY
51511: PPUSH
51512: LD_INT 2
51514: PUSH
51515: LD_INT 30
51517: PUSH
51518: LD_INT 0
51520: PUSH
51521: EMPTY
51522: LIST
51523: LIST
51524: PUSH
51525: LD_INT 30
51527: PUSH
51528: LD_INT 1
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: PUSH
51535: EMPTY
51536: LIST
51537: LIST
51538: LIST
51539: PPUSH
51540: CALL_OW 72
51544: ST_TO_ADDR
// if not fac then
51545: LD_VAR 0 6
51549: NOT
51550: IFFALSE 51554
// continue ;
51552: GO 51402
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51554: LD_ADDR_VAR 0 7
51558: PUSH
51559: LD_EXP 123
51563: PUSH
51564: LD_VAR 0 2
51568: ARRAY
51569: PPUSH
51570: LD_INT 22
51572: PUSH
51573: LD_VAR 0 5
51577: PUSH
51578: EMPTY
51579: LIST
51580: LIST
51581: PUSH
51582: LD_INT 21
51584: PUSH
51585: LD_INT 2
51587: PUSH
51588: EMPTY
51589: LIST
51590: LIST
51591: PUSH
51592: LD_INT 3
51594: PUSH
51595: LD_INT 24
51597: PUSH
51598: LD_INT 1000
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: PUSH
51609: EMPTY
51610: LIST
51611: LIST
51612: LIST
51613: PPUSH
51614: CALL_OW 70
51618: ST_TO_ADDR
// for j in fac do
51619: LD_ADDR_VAR 0 3
51623: PUSH
51624: LD_VAR 0 6
51628: PUSH
51629: FOR_IN
51630: IFFALSE 51711
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51632: LD_ADDR_VAR 0 7
51636: PUSH
51637: LD_VAR 0 7
51641: PUSH
51642: LD_INT 22
51644: PUSH
51645: LD_VAR 0 5
51649: PUSH
51650: EMPTY
51651: LIST
51652: LIST
51653: PUSH
51654: LD_INT 91
51656: PUSH
51657: LD_VAR 0 3
51661: PUSH
51662: LD_INT 15
51664: PUSH
51665: EMPTY
51666: LIST
51667: LIST
51668: LIST
51669: PUSH
51670: LD_INT 21
51672: PUSH
51673: LD_INT 2
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PUSH
51680: LD_INT 3
51682: PUSH
51683: LD_INT 24
51685: PUSH
51686: LD_INT 1000
51688: PUSH
51689: EMPTY
51690: LIST
51691: LIST
51692: PUSH
51693: EMPTY
51694: LIST
51695: LIST
51696: PUSH
51697: EMPTY
51698: LIST
51699: LIST
51700: LIST
51701: LIST
51702: PPUSH
51703: CALL_OW 69
51707: UNION
51708: ST_TO_ADDR
51709: GO 51629
51711: POP
51712: POP
// if not vehs then
51713: LD_VAR 0 7
51717: NOT
51718: IFFALSE 51744
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51720: LD_ADDR_EXP 111
51724: PUSH
51725: LD_EXP 111
51729: PPUSH
51730: LD_VAR 0 2
51734: PPUSH
51735: EMPTY
51736: PPUSH
51737: CALL_OW 1
51741: ST_TO_ADDR
// continue ;
51742: GO 51402
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51744: LD_ADDR_VAR 0 8
51748: PUSH
51749: LD_EXP 99
51753: PUSH
51754: LD_VAR 0 2
51758: ARRAY
51759: PPUSH
51760: LD_INT 30
51762: PUSH
51763: LD_INT 3
51765: PUSH
51766: EMPTY
51767: LIST
51768: LIST
51769: PPUSH
51770: CALL_OW 72
51774: ST_TO_ADDR
// if tmp then
51775: LD_VAR 0 8
51779: IFFALSE 51882
// begin for j in tmp do
51781: LD_ADDR_VAR 0 3
51785: PUSH
51786: LD_VAR 0 8
51790: PUSH
51791: FOR_IN
51792: IFFALSE 51880
// for k in UnitsInside ( j ) do
51794: LD_ADDR_VAR 0 4
51798: PUSH
51799: LD_VAR 0 3
51803: PPUSH
51804: CALL_OW 313
51808: PUSH
51809: FOR_IN
51810: IFFALSE 51876
// if k then
51812: LD_VAR 0 4
51816: IFFALSE 51874
// if not k in mc_repair_vehicle [ i ] then
51818: LD_VAR 0 4
51822: PUSH
51823: LD_EXP 111
51827: PUSH
51828: LD_VAR 0 2
51832: ARRAY
51833: IN
51834: NOT
51835: IFFALSE 51874
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51837: LD_ADDR_EXP 111
51841: PUSH
51842: LD_EXP 111
51846: PPUSH
51847: LD_VAR 0 2
51851: PPUSH
51852: LD_EXP 111
51856: PUSH
51857: LD_VAR 0 2
51861: ARRAY
51862: PUSH
51863: LD_VAR 0 4
51867: UNION
51868: PPUSH
51869: CALL_OW 1
51873: ST_TO_ADDR
51874: GO 51809
51876: POP
51877: POP
51878: GO 51791
51880: POP
51881: POP
// end ; if not mc_repair_vehicle [ i ] then
51882: LD_EXP 111
51886: PUSH
51887: LD_VAR 0 2
51891: ARRAY
51892: NOT
51893: IFFALSE 51897
// continue ;
51895: GO 51402
// for j in mc_repair_vehicle [ i ] do
51897: LD_ADDR_VAR 0 3
51901: PUSH
51902: LD_EXP 111
51906: PUSH
51907: LD_VAR 0 2
51911: ARRAY
51912: PUSH
51913: FOR_IN
51914: IFFALSE 52080
// begin if GetClass ( j ) <> 3 then
51916: LD_VAR 0 3
51920: PPUSH
51921: CALL_OW 257
51925: PUSH
51926: LD_INT 3
51928: NONEQUAL
51929: IFFALSE 51970
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
51931: LD_ADDR_EXP 111
51935: PUSH
51936: LD_EXP 111
51940: PPUSH
51941: LD_VAR 0 2
51945: PPUSH
51946: LD_EXP 111
51950: PUSH
51951: LD_VAR 0 2
51955: ARRAY
51956: PUSH
51957: LD_VAR 0 3
51961: DIFF
51962: PPUSH
51963: CALL_OW 1
51967: ST_TO_ADDR
// continue ;
51968: GO 51913
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51970: LD_VAR 0 3
51974: PPUSH
51975: CALL_OW 311
51979: NOT
51980: PUSH
51981: LD_VAR 0 3
51985: PUSH
51986: LD_EXP 102
51990: PUSH
51991: LD_VAR 0 2
51995: ARRAY
51996: PUSH
51997: LD_INT 1
51999: ARRAY
52000: IN
52001: NOT
52002: AND
52003: PUSH
52004: LD_VAR 0 3
52008: PUSH
52009: LD_EXP 102
52013: PUSH
52014: LD_VAR 0 2
52018: ARRAY
52019: PUSH
52020: LD_INT 2
52022: ARRAY
52023: IN
52024: NOT
52025: AND
52026: IFFALSE 52078
// begin if IsInUnit ( j ) then
52028: LD_VAR 0 3
52032: PPUSH
52033: CALL_OW 310
52037: IFFALSE 52048
// ComExitBuilding ( j ) ;
52039: LD_VAR 0 3
52043: PPUSH
52044: CALL_OW 122
// if not HasTask ( j ) then
52048: LD_VAR 0 3
52052: PPUSH
52053: CALL_OW 314
52057: NOT
52058: IFFALSE 52078
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52060: LD_VAR 0 3
52064: PPUSH
52065: LD_VAR 0 7
52069: PUSH
52070: LD_INT 1
52072: ARRAY
52073: PPUSH
52074: CALL_OW 189
// end ; end ;
52078: GO 51913
52080: POP
52081: POP
// end ;
52082: GO 51402
52084: POP
52085: POP
// end ;
52086: LD_VAR 0 1
52090: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52091: LD_INT 0
52093: PPUSH
52094: PPUSH
52095: PPUSH
52096: PPUSH
52097: PPUSH
52098: PPUSH
52099: PPUSH
52100: PPUSH
52101: PPUSH
52102: PPUSH
52103: PPUSH
// if not mc_bases then
52104: LD_EXP 99
52108: NOT
52109: IFFALSE 52113
// exit ;
52111: GO 52915
// for i = 1 to mc_bases do
52113: LD_ADDR_VAR 0 2
52117: PUSH
52118: DOUBLE
52119: LD_INT 1
52121: DEC
52122: ST_TO_ADDR
52123: LD_EXP 99
52127: PUSH
52128: FOR_TO
52129: IFFALSE 52913
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52131: LD_EXP 127
52135: PUSH
52136: LD_VAR 0 2
52140: ARRAY
52141: NOT
52142: PUSH
52143: LD_EXP 102
52147: PUSH
52148: LD_VAR 0 2
52152: ARRAY
52153: PUSH
52154: LD_INT 1
52156: ARRAY
52157: OR
52158: PUSH
52159: LD_EXP 102
52163: PUSH
52164: LD_VAR 0 2
52168: ARRAY
52169: PUSH
52170: LD_INT 2
52172: ARRAY
52173: OR
52174: PUSH
52175: LD_EXP 125
52179: PUSH
52180: LD_VAR 0 2
52184: ARRAY
52185: PPUSH
52186: LD_INT 1
52188: PPUSH
52189: CALL_OW 325
52193: NOT
52194: OR
52195: PUSH
52196: LD_EXP 122
52200: PUSH
52201: LD_VAR 0 2
52205: ARRAY
52206: OR
52207: IFFALSE 52211
// continue ;
52209: GO 52128
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52211: LD_ADDR_VAR 0 8
52215: PUSH
52216: LD_EXP 99
52220: PUSH
52221: LD_VAR 0 2
52225: ARRAY
52226: PPUSH
52227: LD_INT 25
52229: PUSH
52230: LD_INT 4
52232: PUSH
52233: EMPTY
52234: LIST
52235: LIST
52236: PUSH
52237: LD_INT 50
52239: PUSH
52240: EMPTY
52241: LIST
52242: PUSH
52243: LD_INT 3
52245: PUSH
52246: LD_INT 60
52248: PUSH
52249: EMPTY
52250: LIST
52251: PUSH
52252: EMPTY
52253: LIST
52254: LIST
52255: PUSH
52256: EMPTY
52257: LIST
52258: LIST
52259: LIST
52260: PPUSH
52261: CALL_OW 72
52265: PUSH
52266: LD_EXP 103
52270: PUSH
52271: LD_VAR 0 2
52275: ARRAY
52276: DIFF
52277: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52278: LD_ADDR_VAR 0 9
52282: PUSH
52283: LD_EXP 99
52287: PUSH
52288: LD_VAR 0 2
52292: ARRAY
52293: PPUSH
52294: LD_INT 2
52296: PUSH
52297: LD_INT 30
52299: PUSH
52300: LD_INT 0
52302: PUSH
52303: EMPTY
52304: LIST
52305: LIST
52306: PUSH
52307: LD_INT 30
52309: PUSH
52310: LD_INT 1
52312: PUSH
52313: EMPTY
52314: LIST
52315: LIST
52316: PUSH
52317: EMPTY
52318: LIST
52319: LIST
52320: LIST
52321: PPUSH
52322: CALL_OW 72
52326: ST_TO_ADDR
// if not tmp or not dep then
52327: LD_VAR 0 8
52331: NOT
52332: PUSH
52333: LD_VAR 0 9
52337: NOT
52338: OR
52339: IFFALSE 52343
// continue ;
52341: GO 52128
// side := GetSide ( tmp [ 1 ] ) ;
52343: LD_ADDR_VAR 0 11
52347: PUSH
52348: LD_VAR 0 8
52352: PUSH
52353: LD_INT 1
52355: ARRAY
52356: PPUSH
52357: CALL_OW 255
52361: ST_TO_ADDR
// dep := dep [ 1 ] ;
52362: LD_ADDR_VAR 0 9
52366: PUSH
52367: LD_VAR 0 9
52371: PUSH
52372: LD_INT 1
52374: ARRAY
52375: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52376: LD_ADDR_VAR 0 7
52380: PUSH
52381: LD_EXP 127
52385: PUSH
52386: LD_VAR 0 2
52390: ARRAY
52391: PPUSH
52392: LD_INT 22
52394: PUSH
52395: LD_INT 0
52397: PUSH
52398: EMPTY
52399: LIST
52400: LIST
52401: PUSH
52402: LD_INT 25
52404: PUSH
52405: LD_INT 12
52407: PUSH
52408: EMPTY
52409: LIST
52410: LIST
52411: PUSH
52412: EMPTY
52413: LIST
52414: LIST
52415: PPUSH
52416: CALL_OW 70
52420: PUSH
52421: LD_INT 22
52423: PUSH
52424: LD_INT 0
52426: PUSH
52427: EMPTY
52428: LIST
52429: LIST
52430: PUSH
52431: LD_INT 25
52433: PUSH
52434: LD_INT 12
52436: PUSH
52437: EMPTY
52438: LIST
52439: LIST
52440: PUSH
52441: LD_INT 91
52443: PUSH
52444: LD_VAR 0 9
52448: PUSH
52449: LD_INT 20
52451: PUSH
52452: EMPTY
52453: LIST
52454: LIST
52455: LIST
52456: PUSH
52457: EMPTY
52458: LIST
52459: LIST
52460: LIST
52461: PPUSH
52462: CALL_OW 69
52466: UNION
52467: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52468: LD_ADDR_VAR 0 10
52472: PUSH
52473: LD_EXP 127
52477: PUSH
52478: LD_VAR 0 2
52482: ARRAY
52483: PPUSH
52484: LD_INT 81
52486: PUSH
52487: LD_VAR 0 11
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: PPUSH
52496: CALL_OW 70
52500: ST_TO_ADDR
// if not apes or danger_at_area then
52501: LD_VAR 0 7
52505: NOT
52506: PUSH
52507: LD_VAR 0 10
52511: OR
52512: IFFALSE 52562
// begin if mc_taming [ i ] then
52514: LD_EXP 130
52518: PUSH
52519: LD_VAR 0 2
52523: ARRAY
52524: IFFALSE 52560
// begin MC_Reset ( i , 121 ) ;
52526: LD_VAR 0 2
52530: PPUSH
52531: LD_INT 121
52533: PPUSH
52534: CALL 37893 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52538: LD_ADDR_EXP 130
52542: PUSH
52543: LD_EXP 130
52547: PPUSH
52548: LD_VAR 0 2
52552: PPUSH
52553: EMPTY
52554: PPUSH
52555: CALL_OW 1
52559: ST_TO_ADDR
// end ; continue ;
52560: GO 52128
// end ; for j in tmp do
52562: LD_ADDR_VAR 0 3
52566: PUSH
52567: LD_VAR 0 8
52571: PUSH
52572: FOR_IN
52573: IFFALSE 52909
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52575: LD_VAR 0 3
52579: PUSH
52580: LD_EXP 130
52584: PUSH
52585: LD_VAR 0 2
52589: ARRAY
52590: IN
52591: NOT
52592: PUSH
52593: LD_EXP 130
52597: PUSH
52598: LD_VAR 0 2
52602: ARRAY
52603: PUSH
52604: LD_INT 3
52606: LESS
52607: AND
52608: IFFALSE 52666
// begin SetTag ( j , 121 ) ;
52610: LD_VAR 0 3
52614: PPUSH
52615: LD_INT 121
52617: PPUSH
52618: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52622: LD_ADDR_EXP 130
52626: PUSH
52627: LD_EXP 130
52631: PPUSH
52632: LD_VAR 0 2
52636: PUSH
52637: LD_EXP 130
52641: PUSH
52642: LD_VAR 0 2
52646: ARRAY
52647: PUSH
52648: LD_INT 1
52650: PLUS
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: PPUSH
52656: LD_VAR 0 3
52660: PPUSH
52661: CALL 70507 0 3
52665: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52666: LD_VAR 0 3
52670: PUSH
52671: LD_EXP 130
52675: PUSH
52676: LD_VAR 0 2
52680: ARRAY
52681: IN
52682: IFFALSE 52907
// begin if GetClass ( j ) <> 4 then
52684: LD_VAR 0 3
52688: PPUSH
52689: CALL_OW 257
52693: PUSH
52694: LD_INT 4
52696: NONEQUAL
52697: IFFALSE 52750
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52699: LD_ADDR_EXP 130
52703: PUSH
52704: LD_EXP 130
52708: PPUSH
52709: LD_VAR 0 2
52713: PPUSH
52714: LD_EXP 130
52718: PUSH
52719: LD_VAR 0 2
52723: ARRAY
52724: PUSH
52725: LD_VAR 0 3
52729: DIFF
52730: PPUSH
52731: CALL_OW 1
52735: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52736: LD_VAR 0 3
52740: PPUSH
52741: LD_INT 0
52743: PPUSH
52744: CALL_OW 109
// continue ;
52748: GO 52572
// end ; if IsInUnit ( j ) then
52750: LD_VAR 0 3
52754: PPUSH
52755: CALL_OW 310
52759: IFFALSE 52770
// ComExitBuilding ( j ) ;
52761: LD_VAR 0 3
52765: PPUSH
52766: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52770: LD_ADDR_VAR 0 6
52774: PUSH
52775: LD_VAR 0 7
52779: PPUSH
52780: LD_VAR 0 3
52784: PPUSH
52785: CALL_OW 74
52789: ST_TO_ADDR
// if not ape then
52790: LD_VAR 0 6
52794: NOT
52795: IFFALSE 52799
// break ;
52797: GO 52909
// x := GetX ( ape ) ;
52799: LD_ADDR_VAR 0 4
52803: PUSH
52804: LD_VAR 0 6
52808: PPUSH
52809: CALL_OW 250
52813: ST_TO_ADDR
// y := GetY ( ape ) ;
52814: LD_ADDR_VAR 0 5
52818: PUSH
52819: LD_VAR 0 6
52823: PPUSH
52824: CALL_OW 251
52828: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52829: LD_VAR 0 4
52833: PPUSH
52834: LD_VAR 0 5
52838: PPUSH
52839: CALL_OW 488
52843: NOT
52844: PUSH
52845: LD_VAR 0 11
52849: PPUSH
52850: LD_VAR 0 4
52854: PPUSH
52855: LD_VAR 0 5
52859: PPUSH
52860: LD_INT 20
52862: PPUSH
52863: CALL 71403 0 4
52867: PUSH
52868: LD_INT 4
52870: ARRAY
52871: OR
52872: IFFALSE 52876
// break ;
52874: GO 52909
// if not HasTask ( j ) then
52876: LD_VAR 0 3
52880: PPUSH
52881: CALL_OW 314
52885: NOT
52886: IFFALSE 52907
// ComTameXY ( j , x , y ) ;
52888: LD_VAR 0 3
52892: PPUSH
52893: LD_VAR 0 4
52897: PPUSH
52898: LD_VAR 0 5
52902: PPUSH
52903: CALL_OW 131
// end ; end ;
52907: GO 52572
52909: POP
52910: POP
// end ;
52911: GO 52128
52913: POP
52914: POP
// end ;
52915: LD_VAR 0 1
52919: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
52920: LD_INT 0
52922: PPUSH
52923: PPUSH
52924: PPUSH
52925: PPUSH
52926: PPUSH
52927: PPUSH
52928: PPUSH
52929: PPUSH
// if not mc_bases then
52930: LD_EXP 99
52934: NOT
52935: IFFALSE 52939
// exit ;
52937: GO 53565
// for i = 1 to mc_bases do
52939: LD_ADDR_VAR 0 2
52943: PUSH
52944: DOUBLE
52945: LD_INT 1
52947: DEC
52948: ST_TO_ADDR
52949: LD_EXP 99
52953: PUSH
52954: FOR_TO
52955: IFFALSE 53563
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
52957: LD_EXP 128
52961: PUSH
52962: LD_VAR 0 2
52966: ARRAY
52967: NOT
52968: PUSH
52969: LD_EXP 128
52973: PUSH
52974: LD_VAR 0 2
52978: ARRAY
52979: PPUSH
52980: LD_INT 25
52982: PUSH
52983: LD_INT 12
52985: PUSH
52986: EMPTY
52987: LIST
52988: LIST
52989: PPUSH
52990: CALL_OW 72
52994: NOT
52995: OR
52996: IFFALSE 53000
// continue ;
52998: GO 52954
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53000: LD_ADDR_VAR 0 5
53004: PUSH
53005: LD_EXP 128
53009: PUSH
53010: LD_VAR 0 2
53014: ARRAY
53015: PUSH
53016: LD_INT 1
53018: ARRAY
53019: PPUSH
53020: CALL_OW 255
53024: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53025: LD_VAR 0 5
53029: PPUSH
53030: LD_INT 2
53032: PPUSH
53033: CALL_OW 325
53037: IFFALSE 53290
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53039: LD_ADDR_VAR 0 4
53043: PUSH
53044: LD_EXP 128
53048: PUSH
53049: LD_VAR 0 2
53053: ARRAY
53054: PPUSH
53055: LD_INT 25
53057: PUSH
53058: LD_INT 16
53060: PUSH
53061: EMPTY
53062: LIST
53063: LIST
53064: PPUSH
53065: CALL_OW 72
53069: ST_TO_ADDR
// if tmp < 6 then
53070: LD_VAR 0 4
53074: PUSH
53075: LD_INT 6
53077: LESS
53078: IFFALSE 53290
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53080: LD_ADDR_VAR 0 6
53084: PUSH
53085: LD_EXP 99
53089: PUSH
53090: LD_VAR 0 2
53094: ARRAY
53095: PPUSH
53096: LD_INT 2
53098: PUSH
53099: LD_INT 30
53101: PUSH
53102: LD_INT 0
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: PUSH
53109: LD_INT 30
53111: PUSH
53112: LD_INT 1
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: PUSH
53119: EMPTY
53120: LIST
53121: LIST
53122: LIST
53123: PPUSH
53124: CALL_OW 72
53128: ST_TO_ADDR
// if depot then
53129: LD_VAR 0 6
53133: IFFALSE 53290
// begin selected := 0 ;
53135: LD_ADDR_VAR 0 7
53139: PUSH
53140: LD_INT 0
53142: ST_TO_ADDR
// for j in depot do
53143: LD_ADDR_VAR 0 3
53147: PUSH
53148: LD_VAR 0 6
53152: PUSH
53153: FOR_IN
53154: IFFALSE 53185
// begin if UnitsInside ( j ) < 6 then
53156: LD_VAR 0 3
53160: PPUSH
53161: CALL_OW 313
53165: PUSH
53166: LD_INT 6
53168: LESS
53169: IFFALSE 53183
// begin selected := j ;
53171: LD_ADDR_VAR 0 7
53175: PUSH
53176: LD_VAR 0 3
53180: ST_TO_ADDR
// break ;
53181: GO 53185
// end ; end ;
53183: GO 53153
53185: POP
53186: POP
// if selected then
53187: LD_VAR 0 7
53191: IFFALSE 53290
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53193: LD_ADDR_VAR 0 3
53197: PUSH
53198: LD_EXP 128
53202: PUSH
53203: LD_VAR 0 2
53207: ARRAY
53208: PPUSH
53209: LD_INT 25
53211: PUSH
53212: LD_INT 12
53214: PUSH
53215: EMPTY
53216: LIST
53217: LIST
53218: PPUSH
53219: CALL_OW 72
53223: PUSH
53224: FOR_IN
53225: IFFALSE 53288
// if not HasTask ( j ) then
53227: LD_VAR 0 3
53231: PPUSH
53232: CALL_OW 314
53236: NOT
53237: IFFALSE 53286
// begin if not IsInUnit ( j ) then
53239: LD_VAR 0 3
53243: PPUSH
53244: CALL_OW 310
53248: NOT
53249: IFFALSE 53265
// ComEnterUnit ( j , selected ) ;
53251: LD_VAR 0 3
53255: PPUSH
53256: LD_VAR 0 7
53260: PPUSH
53261: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53265: LD_VAR 0 3
53269: PPUSH
53270: LD_INT 16
53272: PPUSH
53273: CALL_OW 183
// AddComExitBuilding ( j ) ;
53277: LD_VAR 0 3
53281: PPUSH
53282: CALL_OW 182
// end ;
53286: GO 53224
53288: POP
53289: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53290: LD_VAR 0 5
53294: PPUSH
53295: LD_INT 11
53297: PPUSH
53298: CALL_OW 325
53302: IFFALSE 53561
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53304: LD_ADDR_VAR 0 4
53308: PUSH
53309: LD_EXP 128
53313: PUSH
53314: LD_VAR 0 2
53318: ARRAY
53319: PPUSH
53320: LD_INT 25
53322: PUSH
53323: LD_INT 16
53325: PUSH
53326: EMPTY
53327: LIST
53328: LIST
53329: PPUSH
53330: CALL_OW 72
53334: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53335: LD_VAR 0 4
53339: PUSH
53340: LD_INT 6
53342: GREATEREQUAL
53343: PUSH
53344: LD_VAR 0 5
53348: PPUSH
53349: LD_INT 2
53351: PPUSH
53352: CALL_OW 325
53356: NOT
53357: OR
53358: IFFALSE 53561
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53360: LD_ADDR_VAR 0 8
53364: PUSH
53365: LD_EXP 99
53369: PUSH
53370: LD_VAR 0 2
53374: ARRAY
53375: PPUSH
53376: LD_INT 2
53378: PUSH
53379: LD_INT 30
53381: PUSH
53382: LD_INT 4
53384: PUSH
53385: EMPTY
53386: LIST
53387: LIST
53388: PUSH
53389: LD_INT 30
53391: PUSH
53392: LD_INT 5
53394: PUSH
53395: EMPTY
53396: LIST
53397: LIST
53398: PUSH
53399: EMPTY
53400: LIST
53401: LIST
53402: LIST
53403: PPUSH
53404: CALL_OW 72
53408: ST_TO_ADDR
// if barracks then
53409: LD_VAR 0 8
53413: IFFALSE 53561
// begin selected := 0 ;
53415: LD_ADDR_VAR 0 7
53419: PUSH
53420: LD_INT 0
53422: ST_TO_ADDR
// for j in barracks do
53423: LD_ADDR_VAR 0 3
53427: PUSH
53428: LD_VAR 0 8
53432: PUSH
53433: FOR_IN
53434: IFFALSE 53465
// begin if UnitsInside ( j ) < 6 then
53436: LD_VAR 0 3
53440: PPUSH
53441: CALL_OW 313
53445: PUSH
53446: LD_INT 6
53448: LESS
53449: IFFALSE 53463
// begin selected := j ;
53451: LD_ADDR_VAR 0 7
53455: PUSH
53456: LD_VAR 0 3
53460: ST_TO_ADDR
// break ;
53461: GO 53465
// end ; end ;
53463: GO 53433
53465: POP
53466: POP
// if selected then
53467: LD_VAR 0 7
53471: IFFALSE 53561
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53473: LD_ADDR_VAR 0 3
53477: PUSH
53478: LD_EXP 128
53482: PUSH
53483: LD_VAR 0 2
53487: ARRAY
53488: PPUSH
53489: LD_INT 25
53491: PUSH
53492: LD_INT 12
53494: PUSH
53495: EMPTY
53496: LIST
53497: LIST
53498: PPUSH
53499: CALL_OW 72
53503: PUSH
53504: FOR_IN
53505: IFFALSE 53559
// if not IsInUnit ( j ) and not HasTask ( j ) then
53507: LD_VAR 0 3
53511: PPUSH
53512: CALL_OW 310
53516: NOT
53517: PUSH
53518: LD_VAR 0 3
53522: PPUSH
53523: CALL_OW 314
53527: NOT
53528: AND
53529: IFFALSE 53557
// begin ComEnterUnit ( j , selected ) ;
53531: LD_VAR 0 3
53535: PPUSH
53536: LD_VAR 0 7
53540: PPUSH
53541: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53545: LD_VAR 0 3
53549: PPUSH
53550: LD_INT 15
53552: PPUSH
53553: CALL_OW 183
// end ;
53557: GO 53504
53559: POP
53560: POP
// end ; end ; end ; end ; end ;
53561: GO 52954
53563: POP
53564: POP
// end ;
53565: LD_VAR 0 1
53569: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53570: LD_INT 0
53572: PPUSH
53573: PPUSH
53574: PPUSH
53575: PPUSH
// if not mc_bases then
53576: LD_EXP 99
53580: NOT
53581: IFFALSE 53585
// exit ;
53583: GO 53763
// for i = 1 to mc_bases do
53585: LD_ADDR_VAR 0 2
53589: PUSH
53590: DOUBLE
53591: LD_INT 1
53593: DEC
53594: ST_TO_ADDR
53595: LD_EXP 99
53599: PUSH
53600: FOR_TO
53601: IFFALSE 53761
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53603: LD_ADDR_VAR 0 4
53607: PUSH
53608: LD_EXP 99
53612: PUSH
53613: LD_VAR 0 2
53617: ARRAY
53618: PPUSH
53619: LD_INT 25
53621: PUSH
53622: LD_INT 9
53624: PUSH
53625: EMPTY
53626: LIST
53627: LIST
53628: PPUSH
53629: CALL_OW 72
53633: ST_TO_ADDR
// if not tmp then
53634: LD_VAR 0 4
53638: NOT
53639: IFFALSE 53643
// continue ;
53641: GO 53600
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53643: LD_EXP 125
53647: PUSH
53648: LD_VAR 0 2
53652: ARRAY
53653: PPUSH
53654: LD_INT 29
53656: PPUSH
53657: CALL_OW 325
53661: NOT
53662: PUSH
53663: LD_EXP 125
53667: PUSH
53668: LD_VAR 0 2
53672: ARRAY
53673: PPUSH
53674: LD_INT 28
53676: PPUSH
53677: CALL_OW 325
53681: NOT
53682: AND
53683: IFFALSE 53687
// continue ;
53685: GO 53600
// for j in tmp do
53687: LD_ADDR_VAR 0 3
53691: PUSH
53692: LD_VAR 0 4
53696: PUSH
53697: FOR_IN
53698: IFFALSE 53757
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53700: LD_VAR 0 3
53704: PUSH
53705: LD_EXP 102
53709: PUSH
53710: LD_VAR 0 2
53714: ARRAY
53715: PUSH
53716: LD_INT 1
53718: ARRAY
53719: IN
53720: NOT
53721: PUSH
53722: LD_VAR 0 3
53726: PUSH
53727: LD_EXP 102
53731: PUSH
53732: LD_VAR 0 2
53736: ARRAY
53737: PUSH
53738: LD_INT 2
53740: ARRAY
53741: IN
53742: NOT
53743: AND
53744: IFFALSE 53755
// ComSpaceTimeShoot ( j ) ;
53746: LD_VAR 0 3
53750: PPUSH
53751: CALL 64431 0 1
53755: GO 53697
53757: POP
53758: POP
// end ;
53759: GO 53600
53761: POP
53762: POP
// end ;
53763: LD_VAR 0 1
53767: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53768: LD_INT 0
53770: PPUSH
53771: PPUSH
53772: PPUSH
53773: PPUSH
53774: PPUSH
53775: PPUSH
53776: PPUSH
53777: PPUSH
53778: PPUSH
// if not mc_bases then
53779: LD_EXP 99
53783: NOT
53784: IFFALSE 53788
// exit ;
53786: GO 54410
// for i = 1 to mc_bases do
53788: LD_ADDR_VAR 0 2
53792: PUSH
53793: DOUBLE
53794: LD_INT 1
53796: DEC
53797: ST_TO_ADDR
53798: LD_EXP 99
53802: PUSH
53803: FOR_TO
53804: IFFALSE 54408
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53806: LD_EXP 134
53810: PUSH
53811: LD_VAR 0 2
53815: ARRAY
53816: NOT
53817: PUSH
53818: LD_INT 38
53820: PPUSH
53821: LD_EXP 125
53825: PUSH
53826: LD_VAR 0 2
53830: ARRAY
53831: PPUSH
53832: CALL_OW 321
53836: PUSH
53837: LD_INT 2
53839: NONEQUAL
53840: OR
53841: IFFALSE 53845
// continue ;
53843: GO 53803
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53845: LD_ADDR_VAR 0 8
53849: PUSH
53850: LD_EXP 99
53854: PUSH
53855: LD_VAR 0 2
53859: ARRAY
53860: PPUSH
53861: LD_INT 30
53863: PUSH
53864: LD_INT 34
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: PPUSH
53871: CALL_OW 72
53875: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53876: LD_ADDR_VAR 0 9
53880: PUSH
53881: LD_EXP 99
53885: PUSH
53886: LD_VAR 0 2
53890: ARRAY
53891: PPUSH
53892: LD_INT 25
53894: PUSH
53895: LD_INT 4
53897: PUSH
53898: EMPTY
53899: LIST
53900: LIST
53901: PPUSH
53902: CALL_OW 72
53906: PPUSH
53907: LD_INT 0
53909: PPUSH
53910: CALL 103767 0 2
53914: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
53915: LD_VAR 0 9
53919: NOT
53920: PUSH
53921: LD_VAR 0 8
53925: NOT
53926: OR
53927: PUSH
53928: LD_EXP 99
53932: PUSH
53933: LD_VAR 0 2
53937: ARRAY
53938: PPUSH
53939: LD_INT 124
53941: PPUSH
53942: CALL 103767 0 2
53946: OR
53947: IFFALSE 53951
// continue ;
53949: GO 53803
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
53951: LD_EXP 135
53955: PUSH
53956: LD_VAR 0 2
53960: ARRAY
53961: PUSH
53962: LD_EXP 134
53966: PUSH
53967: LD_VAR 0 2
53971: ARRAY
53972: LESS
53973: PUSH
53974: LD_EXP 135
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PUSH
53985: LD_VAR 0 8
53989: LESS
53990: AND
53991: IFFALSE 54406
// begin tmp := sci [ 1 ] ;
53993: LD_ADDR_VAR 0 7
53997: PUSH
53998: LD_VAR 0 9
54002: PUSH
54003: LD_INT 1
54005: ARRAY
54006: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54007: LD_VAR 0 7
54011: PPUSH
54012: LD_INT 124
54014: PPUSH
54015: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54019: LD_ADDR_VAR 0 3
54023: PUSH
54024: DOUBLE
54025: LD_EXP 134
54029: PUSH
54030: LD_VAR 0 2
54034: ARRAY
54035: INC
54036: ST_TO_ADDR
54037: LD_EXP 134
54041: PUSH
54042: LD_VAR 0 2
54046: ARRAY
54047: PUSH
54048: FOR_DOWNTO
54049: IFFALSE 54392
// begin if IsInUnit ( tmp ) then
54051: LD_VAR 0 7
54055: PPUSH
54056: CALL_OW 310
54060: IFFALSE 54071
// ComExitBuilding ( tmp ) ;
54062: LD_VAR 0 7
54066: PPUSH
54067: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54071: LD_INT 35
54073: PPUSH
54074: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54078: LD_VAR 0 7
54082: PPUSH
54083: CALL_OW 310
54087: NOT
54088: PUSH
54089: LD_VAR 0 7
54093: PPUSH
54094: CALL_OW 314
54098: NOT
54099: AND
54100: IFFALSE 54071
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54102: LD_ADDR_VAR 0 6
54106: PUSH
54107: LD_VAR 0 7
54111: PPUSH
54112: CALL_OW 250
54116: PUSH
54117: LD_VAR 0 7
54121: PPUSH
54122: CALL_OW 251
54126: PUSH
54127: EMPTY
54128: LIST
54129: LIST
54130: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54131: LD_INT 35
54133: PPUSH
54134: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54138: LD_ADDR_VAR 0 4
54142: PUSH
54143: LD_EXP 134
54147: PUSH
54148: LD_VAR 0 2
54152: ARRAY
54153: PUSH
54154: LD_VAR 0 3
54158: ARRAY
54159: PUSH
54160: LD_INT 1
54162: ARRAY
54163: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54164: LD_ADDR_VAR 0 5
54168: PUSH
54169: LD_EXP 134
54173: PUSH
54174: LD_VAR 0 2
54178: ARRAY
54179: PUSH
54180: LD_VAR 0 3
54184: ARRAY
54185: PUSH
54186: LD_INT 2
54188: ARRAY
54189: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54190: LD_VAR 0 7
54194: PPUSH
54195: LD_INT 10
54197: PPUSH
54198: CALL 73100 0 2
54202: PUSH
54203: LD_INT 4
54205: ARRAY
54206: IFFALSE 54244
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54208: LD_VAR 0 7
54212: PPUSH
54213: LD_VAR 0 6
54217: PUSH
54218: LD_INT 1
54220: ARRAY
54221: PPUSH
54222: LD_VAR 0 6
54226: PUSH
54227: LD_INT 2
54229: ARRAY
54230: PPUSH
54231: CALL_OW 111
// wait ( 0 0$10 ) ;
54235: LD_INT 350
54237: PPUSH
54238: CALL_OW 67
// end else
54242: GO 54270
// begin ComMoveXY ( tmp , x , y ) ;
54244: LD_VAR 0 7
54248: PPUSH
54249: LD_VAR 0 4
54253: PPUSH
54254: LD_VAR 0 5
54258: PPUSH
54259: CALL_OW 111
// wait ( 0 0$3 ) ;
54263: LD_INT 105
54265: PPUSH
54266: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54270: LD_VAR 0 7
54274: PPUSH
54275: LD_VAR 0 4
54279: PPUSH
54280: LD_VAR 0 5
54284: PPUSH
54285: CALL_OW 307
54289: IFFALSE 54131
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54291: LD_VAR 0 7
54295: PPUSH
54296: LD_VAR 0 4
54300: PPUSH
54301: LD_VAR 0 5
54305: PPUSH
54306: LD_VAR 0 8
54310: PUSH
54311: LD_VAR 0 3
54315: ARRAY
54316: PPUSH
54317: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54321: LD_INT 35
54323: PPUSH
54324: CALL_OW 67
// until not HasTask ( tmp ) ;
54328: LD_VAR 0 7
54332: PPUSH
54333: CALL_OW 314
54337: NOT
54338: IFFALSE 54321
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54340: LD_ADDR_EXP 135
54344: PUSH
54345: LD_EXP 135
54349: PPUSH
54350: LD_VAR 0 2
54354: PUSH
54355: LD_EXP 135
54359: PUSH
54360: LD_VAR 0 2
54364: ARRAY
54365: PUSH
54366: LD_INT 1
54368: PLUS
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: PPUSH
54374: LD_VAR 0 8
54378: PUSH
54379: LD_VAR 0 3
54383: ARRAY
54384: PPUSH
54385: CALL 70507 0 3
54389: ST_TO_ADDR
// end ;
54390: GO 54048
54392: POP
54393: POP
// MC_Reset ( i , 124 ) ;
54394: LD_VAR 0 2
54398: PPUSH
54399: LD_INT 124
54401: PPUSH
54402: CALL 37893 0 2
// end ; end ;
54406: GO 53803
54408: POP
54409: POP
// end ;
54410: LD_VAR 0 1
54414: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54415: LD_INT 0
54417: PPUSH
54418: PPUSH
54419: PPUSH
// if not mc_bases then
54420: LD_EXP 99
54424: NOT
54425: IFFALSE 54429
// exit ;
54427: GO 55035
// for i = 1 to mc_bases do
54429: LD_ADDR_VAR 0 2
54433: PUSH
54434: DOUBLE
54435: LD_INT 1
54437: DEC
54438: ST_TO_ADDR
54439: LD_EXP 99
54443: PUSH
54444: FOR_TO
54445: IFFALSE 55033
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54447: LD_ADDR_VAR 0 3
54451: PUSH
54452: LD_EXP 99
54456: PUSH
54457: LD_VAR 0 2
54461: ARRAY
54462: PPUSH
54463: LD_INT 25
54465: PUSH
54466: LD_INT 4
54468: PUSH
54469: EMPTY
54470: LIST
54471: LIST
54472: PPUSH
54473: CALL_OW 72
54477: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54478: LD_VAR 0 3
54482: NOT
54483: PUSH
54484: LD_EXP 136
54488: PUSH
54489: LD_VAR 0 2
54493: ARRAY
54494: NOT
54495: OR
54496: PUSH
54497: LD_EXP 99
54501: PUSH
54502: LD_VAR 0 2
54506: ARRAY
54507: PPUSH
54508: LD_INT 2
54510: PUSH
54511: LD_INT 30
54513: PUSH
54514: LD_INT 0
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: PUSH
54521: LD_INT 30
54523: PUSH
54524: LD_INT 1
54526: PUSH
54527: EMPTY
54528: LIST
54529: LIST
54530: PUSH
54531: EMPTY
54532: LIST
54533: LIST
54534: LIST
54535: PPUSH
54536: CALL_OW 72
54540: NOT
54541: OR
54542: IFFALSE 54592
// begin if mc_deposits_finder [ i ] then
54544: LD_EXP 137
54548: PUSH
54549: LD_VAR 0 2
54553: ARRAY
54554: IFFALSE 54590
// begin MC_Reset ( i , 125 ) ;
54556: LD_VAR 0 2
54560: PPUSH
54561: LD_INT 125
54563: PPUSH
54564: CALL 37893 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54568: LD_ADDR_EXP 137
54572: PUSH
54573: LD_EXP 137
54577: PPUSH
54578: LD_VAR 0 2
54582: PPUSH
54583: EMPTY
54584: PPUSH
54585: CALL_OW 1
54589: ST_TO_ADDR
// end ; continue ;
54590: GO 54444
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54592: LD_EXP 136
54596: PUSH
54597: LD_VAR 0 2
54601: ARRAY
54602: PUSH
54603: LD_INT 1
54605: ARRAY
54606: PUSH
54607: LD_INT 3
54609: ARRAY
54610: PUSH
54611: LD_INT 1
54613: EQUAL
54614: PUSH
54615: LD_INT 20
54617: PPUSH
54618: LD_EXP 125
54622: PUSH
54623: LD_VAR 0 2
54627: ARRAY
54628: PPUSH
54629: CALL_OW 321
54633: PUSH
54634: LD_INT 2
54636: NONEQUAL
54637: AND
54638: IFFALSE 54688
// begin if mc_deposits_finder [ i ] then
54640: LD_EXP 137
54644: PUSH
54645: LD_VAR 0 2
54649: ARRAY
54650: IFFALSE 54686
// begin MC_Reset ( i , 125 ) ;
54652: LD_VAR 0 2
54656: PPUSH
54657: LD_INT 125
54659: PPUSH
54660: CALL 37893 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54664: LD_ADDR_EXP 137
54668: PUSH
54669: LD_EXP 137
54673: PPUSH
54674: LD_VAR 0 2
54678: PPUSH
54679: EMPTY
54680: PPUSH
54681: CALL_OW 1
54685: ST_TO_ADDR
// end ; continue ;
54686: GO 54444
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54688: LD_EXP 136
54692: PUSH
54693: LD_VAR 0 2
54697: ARRAY
54698: PUSH
54699: LD_INT 1
54701: ARRAY
54702: PUSH
54703: LD_INT 1
54705: ARRAY
54706: PPUSH
54707: LD_EXP 136
54711: PUSH
54712: LD_VAR 0 2
54716: ARRAY
54717: PUSH
54718: LD_INT 1
54720: ARRAY
54721: PUSH
54722: LD_INT 2
54724: ARRAY
54725: PPUSH
54726: LD_EXP 125
54730: PUSH
54731: LD_VAR 0 2
54735: ARRAY
54736: PPUSH
54737: CALL_OW 440
54741: IFFALSE 54784
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54743: LD_ADDR_EXP 136
54747: PUSH
54748: LD_EXP 136
54752: PPUSH
54753: LD_VAR 0 2
54757: PPUSH
54758: LD_EXP 136
54762: PUSH
54763: LD_VAR 0 2
54767: ARRAY
54768: PPUSH
54769: LD_INT 1
54771: PPUSH
54772: CALL_OW 3
54776: PPUSH
54777: CALL_OW 1
54781: ST_TO_ADDR
54782: GO 55031
// begin if not mc_deposits_finder [ i ] then
54784: LD_EXP 137
54788: PUSH
54789: LD_VAR 0 2
54793: ARRAY
54794: NOT
54795: IFFALSE 54847
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54797: LD_ADDR_EXP 137
54801: PUSH
54802: LD_EXP 137
54806: PPUSH
54807: LD_VAR 0 2
54811: PPUSH
54812: LD_VAR 0 3
54816: PUSH
54817: LD_INT 1
54819: ARRAY
54820: PUSH
54821: EMPTY
54822: LIST
54823: PPUSH
54824: CALL_OW 1
54828: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54829: LD_VAR 0 3
54833: PUSH
54834: LD_INT 1
54836: ARRAY
54837: PPUSH
54838: LD_INT 125
54840: PPUSH
54841: CALL_OW 109
// end else
54845: GO 55031
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54847: LD_EXP 137
54851: PUSH
54852: LD_VAR 0 2
54856: ARRAY
54857: PUSH
54858: LD_INT 1
54860: ARRAY
54861: PPUSH
54862: CALL_OW 310
54866: IFFALSE 54889
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54868: LD_EXP 137
54872: PUSH
54873: LD_VAR 0 2
54877: ARRAY
54878: PUSH
54879: LD_INT 1
54881: ARRAY
54882: PPUSH
54883: CALL_OW 122
54887: GO 55031
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54889: LD_EXP 137
54893: PUSH
54894: LD_VAR 0 2
54898: ARRAY
54899: PUSH
54900: LD_INT 1
54902: ARRAY
54903: PPUSH
54904: CALL_OW 314
54908: NOT
54909: PUSH
54910: LD_EXP 137
54914: PUSH
54915: LD_VAR 0 2
54919: ARRAY
54920: PUSH
54921: LD_INT 1
54923: ARRAY
54924: PPUSH
54925: LD_EXP 136
54929: PUSH
54930: LD_VAR 0 2
54934: ARRAY
54935: PUSH
54936: LD_INT 1
54938: ARRAY
54939: PUSH
54940: LD_INT 1
54942: ARRAY
54943: PPUSH
54944: LD_EXP 136
54948: PUSH
54949: LD_VAR 0 2
54953: ARRAY
54954: PUSH
54955: LD_INT 1
54957: ARRAY
54958: PUSH
54959: LD_INT 2
54961: ARRAY
54962: PPUSH
54963: CALL_OW 297
54967: PUSH
54968: LD_INT 6
54970: GREATER
54971: AND
54972: IFFALSE 55031
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
54974: LD_EXP 137
54978: PUSH
54979: LD_VAR 0 2
54983: ARRAY
54984: PUSH
54985: LD_INT 1
54987: ARRAY
54988: PPUSH
54989: LD_EXP 136
54993: PUSH
54994: LD_VAR 0 2
54998: ARRAY
54999: PUSH
55000: LD_INT 1
55002: ARRAY
55003: PUSH
55004: LD_INT 1
55006: ARRAY
55007: PPUSH
55008: LD_EXP 136
55012: PUSH
55013: LD_VAR 0 2
55017: ARRAY
55018: PUSH
55019: LD_INT 1
55021: ARRAY
55022: PUSH
55023: LD_INT 2
55025: ARRAY
55026: PPUSH
55027: CALL_OW 111
// end ; end ; end ;
55031: GO 54444
55033: POP
55034: POP
// end ;
55035: LD_VAR 0 1
55039: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55040: LD_INT 0
55042: PPUSH
55043: PPUSH
55044: PPUSH
55045: PPUSH
55046: PPUSH
55047: PPUSH
55048: PPUSH
55049: PPUSH
55050: PPUSH
55051: PPUSH
55052: PPUSH
// if not mc_bases then
55053: LD_EXP 99
55057: NOT
55058: IFFALSE 55062
// exit ;
55060: GO 55786
// for i = 1 to mc_bases do
55062: LD_ADDR_VAR 0 2
55066: PUSH
55067: DOUBLE
55068: LD_INT 1
55070: DEC
55071: ST_TO_ADDR
55072: LD_EXP 99
55076: PUSH
55077: FOR_TO
55078: IFFALSE 55784
// begin if not mc_bases [ i ] then
55080: LD_EXP 99
55084: PUSH
55085: LD_VAR 0 2
55089: ARRAY
55090: NOT
55091: IFFALSE 55095
// continue ;
55093: GO 55077
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55095: LD_ADDR_VAR 0 7
55099: PUSH
55100: LD_EXP 99
55104: PUSH
55105: LD_VAR 0 2
55109: ARRAY
55110: PUSH
55111: LD_INT 1
55113: ARRAY
55114: PPUSH
55115: CALL_OW 248
55119: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55120: LD_VAR 0 7
55124: PUSH
55125: LD_INT 3
55127: EQUAL
55128: PUSH
55129: LD_EXP 118
55133: PUSH
55134: LD_VAR 0 2
55138: ARRAY
55139: PUSH
55140: LD_EXP 121
55144: PUSH
55145: LD_VAR 0 2
55149: ARRAY
55150: UNION
55151: PPUSH
55152: LD_INT 33
55154: PUSH
55155: LD_INT 2
55157: PUSH
55158: EMPTY
55159: LIST
55160: LIST
55161: PPUSH
55162: CALL_OW 72
55166: NOT
55167: OR
55168: IFFALSE 55172
// continue ;
55170: GO 55077
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55172: LD_ADDR_VAR 0 9
55176: PUSH
55177: LD_EXP 99
55181: PUSH
55182: LD_VAR 0 2
55186: ARRAY
55187: PPUSH
55188: LD_INT 30
55190: PUSH
55191: LD_INT 36
55193: PUSH
55194: EMPTY
55195: LIST
55196: LIST
55197: PPUSH
55198: CALL_OW 72
55202: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55203: LD_ADDR_VAR 0 10
55207: PUSH
55208: LD_EXP 118
55212: PUSH
55213: LD_VAR 0 2
55217: ARRAY
55218: PPUSH
55219: LD_INT 34
55221: PUSH
55222: LD_INT 31
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: PPUSH
55229: CALL_OW 72
55233: ST_TO_ADDR
// if not cts and not mcts then
55234: LD_VAR 0 9
55238: NOT
55239: PUSH
55240: LD_VAR 0 10
55244: NOT
55245: AND
55246: IFFALSE 55250
// continue ;
55248: GO 55077
// x := cts ;
55250: LD_ADDR_VAR 0 11
55254: PUSH
55255: LD_VAR 0 9
55259: ST_TO_ADDR
// if not x then
55260: LD_VAR 0 11
55264: NOT
55265: IFFALSE 55277
// x := mcts ;
55267: LD_ADDR_VAR 0 11
55271: PUSH
55272: LD_VAR 0 10
55276: ST_TO_ADDR
// if mc_remote_driver [ i ] then
55277: LD_EXP 139
55281: PUSH
55282: LD_VAR 0 2
55286: ARRAY
55287: IFFALSE 55556
// for j in mc_remote_driver [ i ] do
55289: LD_ADDR_VAR 0 3
55293: PUSH
55294: LD_EXP 139
55298: PUSH
55299: LD_VAR 0 2
55303: ARRAY
55304: PUSH
55305: FOR_IN
55306: IFFALSE 55554
// begin if GetClass ( j ) <> 3 then
55308: LD_VAR 0 3
55312: PPUSH
55313: CALL_OW 257
55317: PUSH
55318: LD_INT 3
55320: NONEQUAL
55321: IFFALSE 55374
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55323: LD_ADDR_EXP 139
55327: PUSH
55328: LD_EXP 139
55332: PPUSH
55333: LD_VAR 0 2
55337: PPUSH
55338: LD_EXP 139
55342: PUSH
55343: LD_VAR 0 2
55347: ARRAY
55348: PUSH
55349: LD_VAR 0 3
55353: DIFF
55354: PPUSH
55355: CALL_OW 1
55359: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55360: LD_VAR 0 3
55364: PPUSH
55365: LD_INT 0
55367: PPUSH
55368: CALL_OW 109
// continue ;
55372: GO 55305
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55374: LD_VAR 0 3
55378: PPUSH
55379: CALL_OW 310
55383: NOT
55384: PUSH
55385: LD_VAR 0 3
55389: PPUSH
55390: CALL_OW 310
55394: PPUSH
55395: CALL_OW 266
55399: PUSH
55400: LD_INT 36
55402: NONEQUAL
55403: PUSH
55404: LD_VAR 0 3
55408: PPUSH
55409: CALL 103855 0 1
55413: NOT
55414: AND
55415: OR
55416: IFFALSE 55552
// begin if IsInUnit ( j ) then
55418: LD_VAR 0 3
55422: PPUSH
55423: CALL_OW 310
55427: IFFALSE 55438
// ComExitBuilding ( j ) ;
55429: LD_VAR 0 3
55433: PPUSH
55434: CALL_OW 122
// ct := 0 ;
55438: LD_ADDR_VAR 0 8
55442: PUSH
55443: LD_INT 0
55445: ST_TO_ADDR
// for k in x do
55446: LD_ADDR_VAR 0 4
55450: PUSH
55451: LD_VAR 0 11
55455: PUSH
55456: FOR_IN
55457: IFFALSE 55530
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55459: LD_VAR 0 4
55463: PPUSH
55464: CALL_OW 264
55468: PUSH
55469: LD_INT 31
55471: EQUAL
55472: PUSH
55473: LD_VAR 0 4
55477: PPUSH
55478: CALL_OW 311
55482: NOT
55483: AND
55484: PUSH
55485: LD_VAR 0 4
55489: PPUSH
55490: CALL_OW 266
55494: PUSH
55495: LD_INT 36
55497: EQUAL
55498: PUSH
55499: LD_VAR 0 4
55503: PPUSH
55504: CALL_OW 313
55508: PUSH
55509: LD_INT 3
55511: LESS
55512: AND
55513: OR
55514: IFFALSE 55528
// begin ct := k ;
55516: LD_ADDR_VAR 0 8
55520: PUSH
55521: LD_VAR 0 4
55525: ST_TO_ADDR
// break ;
55526: GO 55530
// end ;
55528: GO 55456
55530: POP
55531: POP
// if ct then
55532: LD_VAR 0 8
55536: IFFALSE 55552
// ComEnterUnit ( j , ct ) ;
55538: LD_VAR 0 3
55542: PPUSH
55543: LD_VAR 0 8
55547: PPUSH
55548: CALL_OW 120
// end ; end ;
55552: GO 55305
55554: POP
55555: POP
// places := 0 ;
55556: LD_ADDR_VAR 0 5
55560: PUSH
55561: LD_INT 0
55563: ST_TO_ADDR
// for j = 1 to x do
55564: LD_ADDR_VAR 0 3
55568: PUSH
55569: DOUBLE
55570: LD_INT 1
55572: DEC
55573: ST_TO_ADDR
55574: LD_VAR 0 11
55578: PUSH
55579: FOR_TO
55580: IFFALSE 55635
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55582: LD_VAR 0 11
55586: PUSH
55587: LD_VAR 0 3
55591: ARRAY
55592: PPUSH
55593: CALL_OW 264
55597: PUSH
55598: LD_INT 31
55600: EQUAL
55601: IFFALSE 55619
// places := places + 1 else
55603: LD_ADDR_VAR 0 5
55607: PUSH
55608: LD_VAR 0 5
55612: PUSH
55613: LD_INT 1
55615: PLUS
55616: ST_TO_ADDR
55617: GO 55633
// places := places + 3 ;
55619: LD_ADDR_VAR 0 5
55623: PUSH
55624: LD_VAR 0 5
55628: PUSH
55629: LD_INT 3
55631: PLUS
55632: ST_TO_ADDR
55633: GO 55579
55635: POP
55636: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55637: LD_ADDR_VAR 0 6
55641: PUSH
55642: LD_EXP 99
55646: PUSH
55647: LD_VAR 0 2
55651: ARRAY
55652: PPUSH
55653: LD_INT 25
55655: PUSH
55656: LD_INT 3
55658: PUSH
55659: EMPTY
55660: LIST
55661: LIST
55662: PPUSH
55663: CALL_OW 72
55667: PUSH
55668: LD_EXP 139
55672: PUSH
55673: LD_VAR 0 2
55677: ARRAY
55678: DIFF
55679: PPUSH
55680: LD_INT 3
55682: PPUSH
55683: CALL 104755 0 2
55687: ST_TO_ADDR
// if not tmp then
55688: LD_VAR 0 6
55692: NOT
55693: IFFALSE 55697
// continue ;
55695: GO 55077
// places := places - mc_remote_driver [ i ] ;
55697: LD_ADDR_VAR 0 5
55701: PUSH
55702: LD_VAR 0 5
55706: PUSH
55707: LD_EXP 139
55711: PUSH
55712: LD_VAR 0 2
55716: ARRAY
55717: MINUS
55718: ST_TO_ADDR
// if places then
55719: LD_VAR 0 5
55723: IFFALSE 55782
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
55725: LD_ADDR_EXP 139
55729: PUSH
55730: LD_EXP 139
55734: PPUSH
55735: LD_VAR 0 2
55739: PPUSH
55740: LD_EXP 139
55744: PUSH
55745: LD_VAR 0 2
55749: ARRAY
55750: PUSH
55751: LD_VAR 0 6
55755: PUSH
55756: LD_INT 1
55758: ARRAY
55759: UNION
55760: PPUSH
55761: CALL_OW 1
55765: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
55766: LD_VAR 0 6
55770: PUSH
55771: LD_INT 1
55773: ARRAY
55774: PPUSH
55775: LD_INT 126
55777: PPUSH
55778: CALL_OW 109
// end ; end ;
55782: GO 55077
55784: POP
55785: POP
// end ;
55786: LD_VAR 0 1
55790: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
55791: LD_INT 0
55793: PPUSH
55794: PPUSH
55795: PPUSH
55796: PPUSH
55797: PPUSH
55798: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
55799: LD_VAR 0 1
55803: NOT
55804: PUSH
55805: LD_VAR 0 2
55809: NOT
55810: OR
55811: PUSH
55812: LD_VAR 0 3
55816: NOT
55817: OR
55818: PUSH
55819: LD_VAR 0 4
55823: PUSH
55824: LD_INT 1
55826: PUSH
55827: LD_INT 2
55829: PUSH
55830: LD_INT 3
55832: PUSH
55833: LD_INT 4
55835: PUSH
55836: LD_INT 5
55838: PUSH
55839: LD_INT 8
55841: PUSH
55842: LD_INT 9
55844: PUSH
55845: LD_INT 15
55847: PUSH
55848: LD_INT 16
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: LIST
55855: LIST
55856: LIST
55857: LIST
55858: LIST
55859: LIST
55860: LIST
55861: IN
55862: NOT
55863: OR
55864: IFFALSE 55868
// exit ;
55866: GO 56768
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
55868: LD_ADDR_VAR 0 2
55872: PUSH
55873: LD_VAR 0 2
55877: PPUSH
55878: LD_INT 21
55880: PUSH
55881: LD_INT 3
55883: PUSH
55884: EMPTY
55885: LIST
55886: LIST
55887: PUSH
55888: LD_INT 24
55890: PUSH
55891: LD_INT 250
55893: PUSH
55894: EMPTY
55895: LIST
55896: LIST
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: PPUSH
55902: CALL_OW 72
55906: ST_TO_ADDR
// case class of 1 , 15 :
55907: LD_VAR 0 4
55911: PUSH
55912: LD_INT 1
55914: DOUBLE
55915: EQUAL
55916: IFTRUE 55926
55918: LD_INT 15
55920: DOUBLE
55921: EQUAL
55922: IFTRUE 55926
55924: GO 56011
55926: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
55927: LD_ADDR_VAR 0 8
55931: PUSH
55932: LD_VAR 0 2
55936: PPUSH
55937: LD_INT 2
55939: PUSH
55940: LD_INT 30
55942: PUSH
55943: LD_INT 32
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: PUSH
55950: LD_INT 30
55952: PUSH
55953: LD_INT 31
55955: PUSH
55956: EMPTY
55957: LIST
55958: LIST
55959: PUSH
55960: EMPTY
55961: LIST
55962: LIST
55963: LIST
55964: PPUSH
55965: CALL_OW 72
55969: PUSH
55970: LD_VAR 0 2
55974: PPUSH
55975: LD_INT 2
55977: PUSH
55978: LD_INT 30
55980: PUSH
55981: LD_INT 4
55983: PUSH
55984: EMPTY
55985: LIST
55986: LIST
55987: PUSH
55988: LD_INT 30
55990: PUSH
55991: LD_INT 5
55993: PUSH
55994: EMPTY
55995: LIST
55996: LIST
55997: PUSH
55998: EMPTY
55999: LIST
56000: LIST
56001: LIST
56002: PPUSH
56003: CALL_OW 72
56007: ADD
56008: ST_TO_ADDR
56009: GO 56257
56011: LD_INT 2
56013: DOUBLE
56014: EQUAL
56015: IFTRUE 56025
56017: LD_INT 16
56019: DOUBLE
56020: EQUAL
56021: IFTRUE 56025
56023: GO 56071
56025: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56026: LD_ADDR_VAR 0 8
56030: PUSH
56031: LD_VAR 0 2
56035: PPUSH
56036: LD_INT 2
56038: PUSH
56039: LD_INT 30
56041: PUSH
56042: LD_INT 0
56044: PUSH
56045: EMPTY
56046: LIST
56047: LIST
56048: PUSH
56049: LD_INT 30
56051: PUSH
56052: LD_INT 1
56054: PUSH
56055: EMPTY
56056: LIST
56057: LIST
56058: PUSH
56059: EMPTY
56060: LIST
56061: LIST
56062: LIST
56063: PPUSH
56064: CALL_OW 72
56068: ST_TO_ADDR
56069: GO 56257
56071: LD_INT 3
56073: DOUBLE
56074: EQUAL
56075: IFTRUE 56079
56077: GO 56125
56079: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56080: LD_ADDR_VAR 0 8
56084: PUSH
56085: LD_VAR 0 2
56089: PPUSH
56090: LD_INT 2
56092: PUSH
56093: LD_INT 30
56095: PUSH
56096: LD_INT 2
56098: PUSH
56099: EMPTY
56100: LIST
56101: LIST
56102: PUSH
56103: LD_INT 30
56105: PUSH
56106: LD_INT 3
56108: PUSH
56109: EMPTY
56110: LIST
56111: LIST
56112: PUSH
56113: EMPTY
56114: LIST
56115: LIST
56116: LIST
56117: PPUSH
56118: CALL_OW 72
56122: ST_TO_ADDR
56123: GO 56257
56125: LD_INT 4
56127: DOUBLE
56128: EQUAL
56129: IFTRUE 56133
56131: GO 56190
56133: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56134: LD_ADDR_VAR 0 8
56138: PUSH
56139: LD_VAR 0 2
56143: PPUSH
56144: LD_INT 2
56146: PUSH
56147: LD_INT 30
56149: PUSH
56150: LD_INT 6
56152: PUSH
56153: EMPTY
56154: LIST
56155: LIST
56156: PUSH
56157: LD_INT 30
56159: PUSH
56160: LD_INT 7
56162: PUSH
56163: EMPTY
56164: LIST
56165: LIST
56166: PUSH
56167: LD_INT 30
56169: PUSH
56170: LD_INT 8
56172: PUSH
56173: EMPTY
56174: LIST
56175: LIST
56176: PUSH
56177: EMPTY
56178: LIST
56179: LIST
56180: LIST
56181: LIST
56182: PPUSH
56183: CALL_OW 72
56187: ST_TO_ADDR
56188: GO 56257
56190: LD_INT 5
56192: DOUBLE
56193: EQUAL
56194: IFTRUE 56210
56196: LD_INT 8
56198: DOUBLE
56199: EQUAL
56200: IFTRUE 56210
56202: LD_INT 9
56204: DOUBLE
56205: EQUAL
56206: IFTRUE 56210
56208: GO 56256
56210: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56211: LD_ADDR_VAR 0 8
56215: PUSH
56216: LD_VAR 0 2
56220: PPUSH
56221: LD_INT 2
56223: PUSH
56224: LD_INT 30
56226: PUSH
56227: LD_INT 4
56229: PUSH
56230: EMPTY
56231: LIST
56232: LIST
56233: PUSH
56234: LD_INT 30
56236: PUSH
56237: LD_INT 5
56239: PUSH
56240: EMPTY
56241: LIST
56242: LIST
56243: PUSH
56244: EMPTY
56245: LIST
56246: LIST
56247: LIST
56248: PPUSH
56249: CALL_OW 72
56253: ST_TO_ADDR
56254: GO 56257
56256: POP
// if not tmp then
56257: LD_VAR 0 8
56261: NOT
56262: IFFALSE 56266
// exit ;
56264: GO 56768
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56266: LD_VAR 0 4
56270: PUSH
56271: LD_INT 1
56273: PUSH
56274: LD_INT 15
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: IN
56281: PUSH
56282: LD_EXP 108
56286: PUSH
56287: LD_VAR 0 1
56291: ARRAY
56292: AND
56293: IFFALSE 56449
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56295: LD_ADDR_VAR 0 9
56299: PUSH
56300: LD_EXP 108
56304: PUSH
56305: LD_VAR 0 1
56309: ARRAY
56310: PUSH
56311: LD_INT 1
56313: ARRAY
56314: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56315: LD_VAR 0 9
56319: PUSH
56320: LD_EXP 109
56324: PUSH
56325: LD_VAR 0 1
56329: ARRAY
56330: IN
56331: NOT
56332: IFFALSE 56447
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56334: LD_ADDR_EXP 109
56338: PUSH
56339: LD_EXP 109
56343: PPUSH
56344: LD_VAR 0 1
56348: PUSH
56349: LD_EXP 109
56353: PUSH
56354: LD_VAR 0 1
56358: ARRAY
56359: PUSH
56360: LD_INT 1
56362: PLUS
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: PPUSH
56368: LD_VAR 0 9
56372: PPUSH
56373: CALL 70507 0 3
56377: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56378: LD_ADDR_EXP 108
56382: PUSH
56383: LD_EXP 108
56387: PPUSH
56388: LD_VAR 0 1
56392: PPUSH
56393: LD_EXP 108
56397: PUSH
56398: LD_VAR 0 1
56402: ARRAY
56403: PUSH
56404: LD_VAR 0 9
56408: DIFF
56409: PPUSH
56410: CALL_OW 1
56414: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56415: LD_VAR 0 3
56419: PPUSH
56420: LD_EXP 109
56424: PUSH
56425: LD_VAR 0 1
56429: ARRAY
56430: PUSH
56431: LD_EXP 109
56435: PUSH
56436: LD_VAR 0 1
56440: ARRAY
56441: ARRAY
56442: PPUSH
56443: CALL_OW 120
// end ; exit ;
56447: GO 56768
// end ; if tmp > 1 then
56449: LD_VAR 0 8
56453: PUSH
56454: LD_INT 1
56456: GREATER
56457: IFFALSE 56561
// for i = 2 to tmp do
56459: LD_ADDR_VAR 0 6
56463: PUSH
56464: DOUBLE
56465: LD_INT 2
56467: DEC
56468: ST_TO_ADDR
56469: LD_VAR 0 8
56473: PUSH
56474: FOR_TO
56475: IFFALSE 56559
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56477: LD_VAR 0 8
56481: PUSH
56482: LD_VAR 0 6
56486: ARRAY
56487: PPUSH
56488: CALL_OW 461
56492: PUSH
56493: LD_INT 6
56495: EQUAL
56496: IFFALSE 56557
// begin x := tmp [ i ] ;
56498: LD_ADDR_VAR 0 9
56502: PUSH
56503: LD_VAR 0 8
56507: PUSH
56508: LD_VAR 0 6
56512: ARRAY
56513: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56514: LD_ADDR_VAR 0 8
56518: PUSH
56519: LD_VAR 0 8
56523: PPUSH
56524: LD_VAR 0 6
56528: PPUSH
56529: CALL_OW 3
56533: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56534: LD_ADDR_VAR 0 8
56538: PUSH
56539: LD_VAR 0 8
56543: PPUSH
56544: LD_INT 1
56546: PPUSH
56547: LD_VAR 0 9
56551: PPUSH
56552: CALL_OW 2
56556: ST_TO_ADDR
// end ;
56557: GO 56474
56559: POP
56560: POP
// for i in tmp do
56561: LD_ADDR_VAR 0 6
56565: PUSH
56566: LD_VAR 0 8
56570: PUSH
56571: FOR_IN
56572: IFFALSE 56641
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56574: LD_VAR 0 6
56578: PPUSH
56579: CALL_OW 313
56583: PUSH
56584: LD_INT 6
56586: LESS
56587: PUSH
56588: LD_VAR 0 6
56592: PPUSH
56593: CALL_OW 266
56597: PUSH
56598: LD_INT 31
56600: PUSH
56601: LD_INT 32
56603: PUSH
56604: EMPTY
56605: LIST
56606: LIST
56607: IN
56608: NOT
56609: AND
56610: PUSH
56611: LD_VAR 0 6
56615: PPUSH
56616: CALL_OW 313
56620: PUSH
56621: LD_INT 0
56623: EQUAL
56624: OR
56625: IFFALSE 56639
// begin j := i ;
56627: LD_ADDR_VAR 0 7
56631: PUSH
56632: LD_VAR 0 6
56636: ST_TO_ADDR
// break ;
56637: GO 56641
// end ; end ;
56639: GO 56571
56641: POP
56642: POP
// if j then
56643: LD_VAR 0 7
56647: IFFALSE 56665
// ComEnterUnit ( unit , j ) else
56649: LD_VAR 0 3
56653: PPUSH
56654: LD_VAR 0 7
56658: PPUSH
56659: CALL_OW 120
56663: GO 56768
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56665: LD_ADDR_VAR 0 10
56669: PUSH
56670: LD_VAR 0 2
56674: PPUSH
56675: LD_INT 2
56677: PUSH
56678: LD_INT 30
56680: PUSH
56681: LD_INT 0
56683: PUSH
56684: EMPTY
56685: LIST
56686: LIST
56687: PUSH
56688: LD_INT 30
56690: PUSH
56691: LD_INT 1
56693: PUSH
56694: EMPTY
56695: LIST
56696: LIST
56697: PUSH
56698: EMPTY
56699: LIST
56700: LIST
56701: LIST
56702: PPUSH
56703: CALL_OW 72
56707: ST_TO_ADDR
// if depot then
56708: LD_VAR 0 10
56712: IFFALSE 56768
// begin depot := NearestUnitToUnit ( depot , unit ) ;
56714: LD_ADDR_VAR 0 10
56718: PUSH
56719: LD_VAR 0 10
56723: PPUSH
56724: LD_VAR 0 3
56728: PPUSH
56729: CALL_OW 74
56733: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
56734: LD_VAR 0 3
56738: PPUSH
56739: LD_VAR 0 10
56743: PPUSH
56744: CALL_OW 296
56748: PUSH
56749: LD_INT 10
56751: GREATER
56752: IFFALSE 56768
// ComStandNearbyBuilding ( unit , depot ) ;
56754: LD_VAR 0 3
56758: PPUSH
56759: LD_VAR 0 10
56763: PPUSH
56764: CALL 65048 0 2
// end ; end ; end ;
56768: LD_VAR 0 5
56772: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
56773: LD_INT 0
56775: PPUSH
56776: PPUSH
56777: PPUSH
56778: PPUSH
// if not mc_bases then
56779: LD_EXP 99
56783: NOT
56784: IFFALSE 56788
// exit ;
56786: GO 57027
// for i = 1 to mc_bases do
56788: LD_ADDR_VAR 0 2
56792: PUSH
56793: DOUBLE
56794: LD_INT 1
56796: DEC
56797: ST_TO_ADDR
56798: LD_EXP 99
56802: PUSH
56803: FOR_TO
56804: IFFALSE 57025
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
56806: LD_ADDR_VAR 0 4
56810: PUSH
56811: LD_EXP 99
56815: PUSH
56816: LD_VAR 0 2
56820: ARRAY
56821: PPUSH
56822: LD_INT 21
56824: PUSH
56825: LD_INT 1
56827: PUSH
56828: EMPTY
56829: LIST
56830: LIST
56831: PPUSH
56832: CALL_OW 72
56836: PUSH
56837: LD_EXP 128
56841: PUSH
56842: LD_VAR 0 2
56846: ARRAY
56847: UNION
56848: ST_TO_ADDR
// if not tmp then
56849: LD_VAR 0 4
56853: NOT
56854: IFFALSE 56858
// continue ;
56856: GO 56803
// for j in tmp do
56858: LD_ADDR_VAR 0 3
56862: PUSH
56863: LD_VAR 0 4
56867: PUSH
56868: FOR_IN
56869: IFFALSE 57021
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
56871: LD_VAR 0 3
56875: PPUSH
56876: CALL_OW 110
56880: NOT
56881: PUSH
56882: LD_VAR 0 3
56886: PPUSH
56887: CALL_OW 314
56891: NOT
56892: AND
56893: PUSH
56894: LD_VAR 0 3
56898: PPUSH
56899: CALL_OW 311
56903: NOT
56904: AND
56905: PUSH
56906: LD_VAR 0 3
56910: PPUSH
56911: CALL_OW 310
56915: NOT
56916: AND
56917: PUSH
56918: LD_VAR 0 3
56922: PUSH
56923: LD_EXP 102
56927: PUSH
56928: LD_VAR 0 2
56932: ARRAY
56933: PUSH
56934: LD_INT 1
56936: ARRAY
56937: IN
56938: NOT
56939: AND
56940: PUSH
56941: LD_VAR 0 3
56945: PUSH
56946: LD_EXP 102
56950: PUSH
56951: LD_VAR 0 2
56955: ARRAY
56956: PUSH
56957: LD_INT 2
56959: ARRAY
56960: IN
56961: NOT
56962: AND
56963: PUSH
56964: LD_VAR 0 3
56968: PUSH
56969: LD_EXP 111
56973: PUSH
56974: LD_VAR 0 2
56978: ARRAY
56979: IN
56980: NOT
56981: AND
56982: IFFALSE 57019
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
56984: LD_VAR 0 2
56988: PPUSH
56989: LD_EXP 99
56993: PUSH
56994: LD_VAR 0 2
56998: ARRAY
56999: PPUSH
57000: LD_VAR 0 3
57004: PPUSH
57005: LD_VAR 0 3
57009: PPUSH
57010: CALL_OW 257
57014: PPUSH
57015: CALL 55791 0 4
// end ;
57019: GO 56868
57021: POP
57022: POP
// end ;
57023: GO 56803
57025: POP
57026: POP
// end ;
57027: LD_VAR 0 1
57031: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57032: LD_INT 0
57034: PPUSH
57035: PPUSH
57036: PPUSH
57037: PPUSH
57038: PPUSH
57039: PPUSH
// if not mc_bases [ base ] then
57040: LD_EXP 99
57044: PUSH
57045: LD_VAR 0 1
57049: ARRAY
57050: NOT
57051: IFFALSE 57055
// exit ;
57053: GO 57237
// tmp := [ ] ;
57055: LD_ADDR_VAR 0 6
57059: PUSH
57060: EMPTY
57061: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57062: LD_ADDR_VAR 0 7
57066: PUSH
57067: LD_VAR 0 3
57071: PPUSH
57072: LD_INT 0
57074: PPUSH
57075: CALL_OW 517
57079: ST_TO_ADDR
// if not list then
57080: LD_VAR 0 7
57084: NOT
57085: IFFALSE 57089
// exit ;
57087: GO 57237
// for i = 1 to amount do
57089: LD_ADDR_VAR 0 5
57093: PUSH
57094: DOUBLE
57095: LD_INT 1
57097: DEC
57098: ST_TO_ADDR
57099: LD_VAR 0 2
57103: PUSH
57104: FOR_TO
57105: IFFALSE 57185
// begin x := rand ( 1 , list [ 1 ] ) ;
57107: LD_ADDR_VAR 0 8
57111: PUSH
57112: LD_INT 1
57114: PPUSH
57115: LD_VAR 0 7
57119: PUSH
57120: LD_INT 1
57122: ARRAY
57123: PPUSH
57124: CALL_OW 12
57128: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57129: LD_ADDR_VAR 0 6
57133: PUSH
57134: LD_VAR 0 6
57138: PPUSH
57139: LD_VAR 0 5
57143: PPUSH
57144: LD_VAR 0 7
57148: PUSH
57149: LD_INT 1
57151: ARRAY
57152: PUSH
57153: LD_VAR 0 8
57157: ARRAY
57158: PUSH
57159: LD_VAR 0 7
57163: PUSH
57164: LD_INT 2
57166: ARRAY
57167: PUSH
57168: LD_VAR 0 8
57172: ARRAY
57173: PUSH
57174: EMPTY
57175: LIST
57176: LIST
57177: PPUSH
57178: CALL_OW 1
57182: ST_TO_ADDR
// end ;
57183: GO 57104
57185: POP
57186: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57187: LD_ADDR_EXP 112
57191: PUSH
57192: LD_EXP 112
57196: PPUSH
57197: LD_VAR 0 1
57201: PPUSH
57202: LD_VAR 0 6
57206: PPUSH
57207: CALL_OW 1
57211: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57212: LD_ADDR_EXP 114
57216: PUSH
57217: LD_EXP 114
57221: PPUSH
57222: LD_VAR 0 1
57226: PPUSH
57227: LD_VAR 0 3
57231: PPUSH
57232: CALL_OW 1
57236: ST_TO_ADDR
// end ;
57237: LD_VAR 0 4
57241: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57242: LD_INT 0
57244: PPUSH
// if not mc_bases [ base ] then
57245: LD_EXP 99
57249: PUSH
57250: LD_VAR 0 1
57254: ARRAY
57255: NOT
57256: IFFALSE 57260
// exit ;
57258: GO 57285
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57260: LD_ADDR_EXP 104
57264: PUSH
57265: LD_EXP 104
57269: PPUSH
57270: LD_VAR 0 1
57274: PPUSH
57275: LD_VAR 0 2
57279: PPUSH
57280: CALL_OW 1
57284: ST_TO_ADDR
// end ;
57285: LD_VAR 0 3
57289: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57290: LD_INT 0
57292: PPUSH
// if not mc_bases [ base ] then
57293: LD_EXP 99
57297: PUSH
57298: LD_VAR 0 1
57302: ARRAY
57303: NOT
57304: IFFALSE 57308
// exit ;
57306: GO 57345
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57308: LD_ADDR_EXP 104
57312: PUSH
57313: LD_EXP 104
57317: PPUSH
57318: LD_VAR 0 1
57322: PPUSH
57323: LD_EXP 104
57327: PUSH
57328: LD_VAR 0 1
57332: ARRAY
57333: PUSH
57334: LD_VAR 0 2
57338: UNION
57339: PPUSH
57340: CALL_OW 1
57344: ST_TO_ADDR
// end ;
57345: LD_VAR 0 3
57349: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57350: LD_INT 0
57352: PPUSH
// if not mc_bases [ base ] then
57353: LD_EXP 99
57357: PUSH
57358: LD_VAR 0 1
57362: ARRAY
57363: NOT
57364: IFFALSE 57368
// exit ;
57366: GO 57393
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57368: LD_ADDR_EXP 120
57372: PUSH
57373: LD_EXP 120
57377: PPUSH
57378: LD_VAR 0 1
57382: PPUSH
57383: LD_VAR 0 2
57387: PPUSH
57388: CALL_OW 1
57392: ST_TO_ADDR
// end ;
57393: LD_VAR 0 3
57397: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57398: LD_INT 0
57400: PPUSH
// if not mc_bases [ base ] then
57401: LD_EXP 99
57405: PUSH
57406: LD_VAR 0 1
57410: ARRAY
57411: NOT
57412: IFFALSE 57416
// exit ;
57414: GO 57453
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57416: LD_ADDR_EXP 120
57420: PUSH
57421: LD_EXP 120
57425: PPUSH
57426: LD_VAR 0 1
57430: PPUSH
57431: LD_EXP 120
57435: PUSH
57436: LD_VAR 0 1
57440: ARRAY
57441: PUSH
57442: LD_VAR 0 2
57446: ADD
57447: PPUSH
57448: CALL_OW 1
57452: ST_TO_ADDR
// end ;
57453: LD_VAR 0 3
57457: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57458: LD_INT 0
57460: PPUSH
// if not mc_bases [ base ] then
57461: LD_EXP 99
57465: PUSH
57466: LD_VAR 0 1
57470: ARRAY
57471: NOT
57472: IFFALSE 57476
// exit ;
57474: GO 57530
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57476: LD_ADDR_EXP 121
57480: PUSH
57481: LD_EXP 121
57485: PPUSH
57486: LD_VAR 0 1
57490: PPUSH
57491: LD_VAR 0 2
57495: PPUSH
57496: CALL_OW 1
57500: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57501: LD_ADDR_EXP 110
57505: PUSH
57506: LD_EXP 110
57510: PPUSH
57511: LD_VAR 0 1
57515: PPUSH
57516: LD_VAR 0 2
57520: PUSH
57521: LD_INT 0
57523: PLUS
57524: PPUSH
57525: CALL_OW 1
57529: ST_TO_ADDR
// end ;
57530: LD_VAR 0 3
57534: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57535: LD_INT 0
57537: PPUSH
// if not mc_bases [ base ] then
57538: LD_EXP 99
57542: PUSH
57543: LD_VAR 0 1
57547: ARRAY
57548: NOT
57549: IFFALSE 57553
// exit ;
57551: GO 57578
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57553: LD_ADDR_EXP 110
57557: PUSH
57558: LD_EXP 110
57562: PPUSH
57563: LD_VAR 0 1
57567: PPUSH
57568: LD_VAR 0 2
57572: PPUSH
57573: CALL_OW 1
57577: ST_TO_ADDR
// end ;
57578: LD_VAR 0 3
57582: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57583: LD_INT 0
57585: PPUSH
57586: PPUSH
57587: PPUSH
57588: PPUSH
// if not mc_bases [ base ] then
57589: LD_EXP 99
57593: PUSH
57594: LD_VAR 0 1
57598: ARRAY
57599: NOT
57600: IFFALSE 57604
// exit ;
57602: GO 57669
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57604: LD_ADDR_EXP 119
57608: PUSH
57609: LD_EXP 119
57613: PPUSH
57614: LD_VAR 0 1
57618: PUSH
57619: LD_EXP 119
57623: PUSH
57624: LD_VAR 0 1
57628: ARRAY
57629: PUSH
57630: LD_INT 1
57632: PLUS
57633: PUSH
57634: EMPTY
57635: LIST
57636: LIST
57637: PPUSH
57638: LD_VAR 0 1
57642: PUSH
57643: LD_VAR 0 2
57647: PUSH
57648: LD_VAR 0 3
57652: PUSH
57653: LD_VAR 0 4
57657: PUSH
57658: EMPTY
57659: LIST
57660: LIST
57661: LIST
57662: LIST
57663: PPUSH
57664: CALL 70507 0 3
57668: ST_TO_ADDR
// end ;
57669: LD_VAR 0 5
57673: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57674: LD_INT 0
57676: PPUSH
// if not mc_bases [ base ] then
57677: LD_EXP 99
57681: PUSH
57682: LD_VAR 0 1
57686: ARRAY
57687: NOT
57688: IFFALSE 57692
// exit ;
57690: GO 57717
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
57692: LD_ADDR_EXP 136
57696: PUSH
57697: LD_EXP 136
57701: PPUSH
57702: LD_VAR 0 1
57706: PPUSH
57707: LD_VAR 0 2
57711: PPUSH
57712: CALL_OW 1
57716: ST_TO_ADDR
// end ;
57717: LD_VAR 0 3
57721: RET
// export function MC_GetMinesField ( base ) ; begin
57722: LD_INT 0
57724: PPUSH
// result := mc_mines [ base ] ;
57725: LD_ADDR_VAR 0 2
57729: PUSH
57730: LD_EXP 112
57734: PUSH
57735: LD_VAR 0 1
57739: ARRAY
57740: ST_TO_ADDR
// end ;
57741: LD_VAR 0 2
57745: RET
// export function MC_GetProduceList ( base ) ; begin
57746: LD_INT 0
57748: PPUSH
// result := mc_produce [ base ] ;
57749: LD_ADDR_VAR 0 2
57753: PUSH
57754: LD_EXP 120
57758: PUSH
57759: LD_VAR 0 1
57763: ARRAY
57764: ST_TO_ADDR
// end ;
57765: LD_VAR 0 2
57769: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
57770: LD_INT 0
57772: PPUSH
57773: PPUSH
// if not mc_bases then
57774: LD_EXP 99
57778: NOT
57779: IFFALSE 57783
// exit ;
57781: GO 57848
// if mc_bases [ base ] then
57783: LD_EXP 99
57787: PUSH
57788: LD_VAR 0 1
57792: ARRAY
57793: IFFALSE 57848
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57795: LD_ADDR_VAR 0 3
57799: PUSH
57800: LD_EXP 99
57804: PUSH
57805: LD_VAR 0 1
57809: ARRAY
57810: PPUSH
57811: LD_INT 30
57813: PUSH
57814: LD_VAR 0 2
57818: PUSH
57819: EMPTY
57820: LIST
57821: LIST
57822: PPUSH
57823: CALL_OW 72
57827: ST_TO_ADDR
// if result then
57828: LD_VAR 0 3
57832: IFFALSE 57848
// result := result [ 1 ] ;
57834: LD_ADDR_VAR 0 3
57838: PUSH
57839: LD_VAR 0 3
57843: PUSH
57844: LD_INT 1
57846: ARRAY
57847: ST_TO_ADDR
// end ; end ;
57848: LD_VAR 0 3
57852: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
57853: LD_INT 0
57855: PPUSH
57856: PPUSH
// if not mc_bases then
57857: LD_EXP 99
57861: NOT
57862: IFFALSE 57866
// exit ;
57864: GO 57911
// if mc_bases [ base ] then
57866: LD_EXP 99
57870: PUSH
57871: LD_VAR 0 1
57875: ARRAY
57876: IFFALSE 57911
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57878: LD_ADDR_VAR 0 3
57882: PUSH
57883: LD_EXP 99
57887: PUSH
57888: LD_VAR 0 1
57892: ARRAY
57893: PPUSH
57894: LD_INT 30
57896: PUSH
57897: LD_VAR 0 2
57901: PUSH
57902: EMPTY
57903: LIST
57904: LIST
57905: PPUSH
57906: CALL_OW 72
57910: ST_TO_ADDR
// end ;
57911: LD_VAR 0 3
57915: RET
// export function MC_SetTame ( base , area ) ; begin
57916: LD_INT 0
57918: PPUSH
// if not mc_bases or not base then
57919: LD_EXP 99
57923: NOT
57924: PUSH
57925: LD_VAR 0 1
57929: NOT
57930: OR
57931: IFFALSE 57935
// exit ;
57933: GO 57960
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
57935: LD_ADDR_EXP 127
57939: PUSH
57940: LD_EXP 127
57944: PPUSH
57945: LD_VAR 0 1
57949: PPUSH
57950: LD_VAR 0 2
57954: PPUSH
57955: CALL_OW 1
57959: ST_TO_ADDR
// end ;
57960: LD_VAR 0 3
57964: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
57965: LD_INT 0
57967: PPUSH
57968: PPUSH
// if not mc_bases or not base then
57969: LD_EXP 99
57973: NOT
57974: PUSH
57975: LD_VAR 0 1
57979: NOT
57980: OR
57981: IFFALSE 57985
// exit ;
57983: GO 58087
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57985: LD_ADDR_VAR 0 4
57989: PUSH
57990: LD_EXP 99
57994: PUSH
57995: LD_VAR 0 1
57999: ARRAY
58000: PPUSH
58001: LD_INT 30
58003: PUSH
58004: LD_VAR 0 2
58008: PUSH
58009: EMPTY
58010: LIST
58011: LIST
58012: PPUSH
58013: CALL_OW 72
58017: ST_TO_ADDR
// if not tmp then
58018: LD_VAR 0 4
58022: NOT
58023: IFFALSE 58027
// exit ;
58025: GO 58087
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58027: LD_ADDR_EXP 131
58031: PUSH
58032: LD_EXP 131
58036: PPUSH
58037: LD_VAR 0 1
58041: PPUSH
58042: LD_EXP 131
58046: PUSH
58047: LD_VAR 0 1
58051: ARRAY
58052: PPUSH
58053: LD_EXP 131
58057: PUSH
58058: LD_VAR 0 1
58062: ARRAY
58063: PUSH
58064: LD_INT 1
58066: PLUS
58067: PPUSH
58068: LD_VAR 0 4
58072: PUSH
58073: LD_INT 1
58075: ARRAY
58076: PPUSH
58077: CALL_OW 2
58081: PPUSH
58082: CALL_OW 1
58086: ST_TO_ADDR
// end ;
58087: LD_VAR 0 3
58091: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58092: LD_INT 0
58094: PPUSH
58095: PPUSH
// if not mc_bases or not base or not kinds then
58096: LD_EXP 99
58100: NOT
58101: PUSH
58102: LD_VAR 0 1
58106: NOT
58107: OR
58108: PUSH
58109: LD_VAR 0 2
58113: NOT
58114: OR
58115: IFFALSE 58119
// exit ;
58117: GO 58180
// for i in kinds do
58119: LD_ADDR_VAR 0 4
58123: PUSH
58124: LD_VAR 0 2
58128: PUSH
58129: FOR_IN
58130: IFFALSE 58178
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58132: LD_ADDR_EXP 133
58136: PUSH
58137: LD_EXP 133
58141: PPUSH
58142: LD_VAR 0 1
58146: PUSH
58147: LD_EXP 133
58151: PUSH
58152: LD_VAR 0 1
58156: ARRAY
58157: PUSH
58158: LD_INT 1
58160: PLUS
58161: PUSH
58162: EMPTY
58163: LIST
58164: LIST
58165: PPUSH
58166: LD_VAR 0 4
58170: PPUSH
58171: CALL 70507 0 3
58175: ST_TO_ADDR
58176: GO 58129
58178: POP
58179: POP
// end ;
58180: LD_VAR 0 3
58184: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58185: LD_INT 0
58187: PPUSH
// if not mc_bases or not base or not areas then
58188: LD_EXP 99
58192: NOT
58193: PUSH
58194: LD_VAR 0 1
58198: NOT
58199: OR
58200: PUSH
58201: LD_VAR 0 2
58205: NOT
58206: OR
58207: IFFALSE 58211
// exit ;
58209: GO 58236
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58211: LD_ADDR_EXP 117
58215: PUSH
58216: LD_EXP 117
58220: PPUSH
58221: LD_VAR 0 1
58225: PPUSH
58226: LD_VAR 0 2
58230: PPUSH
58231: CALL_OW 1
58235: ST_TO_ADDR
// end ;
58236: LD_VAR 0 3
58240: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58241: LD_INT 0
58243: PPUSH
// if not mc_bases or not base or not teleports_exit then
58244: LD_EXP 99
58248: NOT
58249: PUSH
58250: LD_VAR 0 1
58254: NOT
58255: OR
58256: PUSH
58257: LD_VAR 0 2
58261: NOT
58262: OR
58263: IFFALSE 58267
// exit ;
58265: GO 58292
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58267: LD_ADDR_EXP 134
58271: PUSH
58272: LD_EXP 134
58276: PPUSH
58277: LD_VAR 0 1
58281: PPUSH
58282: LD_VAR 0 2
58286: PPUSH
58287: CALL_OW 1
58291: ST_TO_ADDR
// end ;
58292: LD_VAR 0 3
58296: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58297: LD_INT 0
58299: PPUSH
58300: PPUSH
58301: PPUSH
// if not mc_bases or not base or not ext_list then
58302: LD_EXP 99
58306: NOT
58307: PUSH
58308: LD_VAR 0 1
58312: NOT
58313: OR
58314: PUSH
58315: LD_VAR 0 5
58319: NOT
58320: OR
58321: IFFALSE 58325
// exit ;
58323: GO 58498
// tmp := GetFacExtXYD ( x , y , d ) ;
58325: LD_ADDR_VAR 0 8
58329: PUSH
58330: LD_VAR 0 2
58334: PPUSH
58335: LD_VAR 0 3
58339: PPUSH
58340: LD_VAR 0 4
58344: PPUSH
58345: CALL 103885 0 3
58349: ST_TO_ADDR
// if not tmp then
58350: LD_VAR 0 8
58354: NOT
58355: IFFALSE 58359
// exit ;
58357: GO 58498
// for i in tmp do
58359: LD_ADDR_VAR 0 7
58363: PUSH
58364: LD_VAR 0 8
58368: PUSH
58369: FOR_IN
58370: IFFALSE 58496
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58372: LD_ADDR_EXP 104
58376: PUSH
58377: LD_EXP 104
58381: PPUSH
58382: LD_VAR 0 1
58386: PPUSH
58387: LD_EXP 104
58391: PUSH
58392: LD_VAR 0 1
58396: ARRAY
58397: PPUSH
58398: LD_EXP 104
58402: PUSH
58403: LD_VAR 0 1
58407: ARRAY
58408: PUSH
58409: LD_INT 1
58411: PLUS
58412: PPUSH
58413: LD_VAR 0 5
58417: PUSH
58418: LD_INT 1
58420: ARRAY
58421: PUSH
58422: LD_VAR 0 7
58426: PUSH
58427: LD_INT 1
58429: ARRAY
58430: PUSH
58431: LD_VAR 0 7
58435: PUSH
58436: LD_INT 2
58438: ARRAY
58439: PUSH
58440: LD_VAR 0 7
58444: PUSH
58445: LD_INT 3
58447: ARRAY
58448: PUSH
58449: EMPTY
58450: LIST
58451: LIST
58452: LIST
58453: LIST
58454: PPUSH
58455: CALL_OW 2
58459: PPUSH
58460: CALL_OW 1
58464: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58465: LD_ADDR_VAR 0 5
58469: PUSH
58470: LD_VAR 0 5
58474: PPUSH
58475: LD_INT 1
58477: PPUSH
58478: CALL_OW 3
58482: ST_TO_ADDR
// if not ext_list then
58483: LD_VAR 0 5
58487: NOT
58488: IFFALSE 58494
// exit ;
58490: POP
58491: POP
58492: GO 58498
// end ;
58494: GO 58369
58496: POP
58497: POP
// end ;
58498: LD_VAR 0 6
58502: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58503: LD_INT 0
58505: PPUSH
// if not mc_bases or not base or not weapon_list then
58506: LD_EXP 99
58510: NOT
58511: PUSH
58512: LD_VAR 0 1
58516: NOT
58517: OR
58518: PUSH
58519: LD_VAR 0 2
58523: NOT
58524: OR
58525: IFFALSE 58529
// exit ;
58527: GO 58554
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58529: LD_ADDR_EXP 138
58533: PUSH
58534: LD_EXP 138
58538: PPUSH
58539: LD_VAR 0 1
58543: PPUSH
58544: LD_VAR 0 2
58548: PPUSH
58549: CALL_OW 1
58553: ST_TO_ADDR
// end ;
58554: LD_VAR 0 3
58558: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58559: LD_INT 0
58561: PPUSH
// if not mc_bases or not base or not tech_list then
58562: LD_EXP 99
58566: NOT
58567: PUSH
58568: LD_VAR 0 1
58572: NOT
58573: OR
58574: PUSH
58575: LD_VAR 0 2
58579: NOT
58580: OR
58581: IFFALSE 58585
// exit ;
58583: GO 58610
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58585: LD_ADDR_EXP 126
58589: PUSH
58590: LD_EXP 126
58594: PPUSH
58595: LD_VAR 0 1
58599: PPUSH
58600: LD_VAR 0 2
58604: PPUSH
58605: CALL_OW 1
58609: ST_TO_ADDR
// end ;
58610: LD_VAR 0 3
58614: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58615: LD_INT 0
58617: PPUSH
// if not mc_bases or not parking_area or not base then
58618: LD_EXP 99
58622: NOT
58623: PUSH
58624: LD_VAR 0 2
58628: NOT
58629: OR
58630: PUSH
58631: LD_VAR 0 1
58635: NOT
58636: OR
58637: IFFALSE 58641
// exit ;
58639: GO 58666
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58641: LD_ADDR_EXP 123
58645: PUSH
58646: LD_EXP 123
58650: PPUSH
58651: LD_VAR 0 1
58655: PPUSH
58656: LD_VAR 0 2
58660: PPUSH
58661: CALL_OW 1
58665: ST_TO_ADDR
// end ;
58666: LD_VAR 0 3
58670: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58671: LD_INT 0
58673: PPUSH
// if not mc_bases or not base or not scan_area then
58674: LD_EXP 99
58678: NOT
58679: PUSH
58680: LD_VAR 0 1
58684: NOT
58685: OR
58686: PUSH
58687: LD_VAR 0 2
58691: NOT
58692: OR
58693: IFFALSE 58697
// exit ;
58695: GO 58722
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
58697: LD_ADDR_EXP 124
58701: PUSH
58702: LD_EXP 124
58706: PPUSH
58707: LD_VAR 0 1
58711: PPUSH
58712: LD_VAR 0 2
58716: PPUSH
58717: CALL_OW 1
58721: ST_TO_ADDR
// end ;
58722: LD_VAR 0 3
58726: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
58727: LD_INT 0
58729: PPUSH
58730: PPUSH
// if not mc_bases or not base then
58731: LD_EXP 99
58735: NOT
58736: PUSH
58737: LD_VAR 0 1
58741: NOT
58742: OR
58743: IFFALSE 58747
// exit ;
58745: GO 58811
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
58747: LD_ADDR_VAR 0 3
58751: PUSH
58752: LD_INT 1
58754: PUSH
58755: LD_INT 2
58757: PUSH
58758: LD_INT 3
58760: PUSH
58761: LD_INT 4
58763: PUSH
58764: LD_INT 11
58766: PUSH
58767: EMPTY
58768: LIST
58769: LIST
58770: LIST
58771: LIST
58772: LIST
58773: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
58774: LD_ADDR_EXP 126
58778: PUSH
58779: LD_EXP 126
58783: PPUSH
58784: LD_VAR 0 1
58788: PPUSH
58789: LD_EXP 126
58793: PUSH
58794: LD_VAR 0 1
58798: ARRAY
58799: PUSH
58800: LD_VAR 0 3
58804: DIFF
58805: PPUSH
58806: CALL_OW 1
58810: ST_TO_ADDR
// end ;
58811: LD_VAR 0 2
58815: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
58816: LD_INT 0
58818: PPUSH
// result := mc_vehicles [ base ] ;
58819: LD_ADDR_VAR 0 3
58823: PUSH
58824: LD_EXP 118
58828: PUSH
58829: LD_VAR 0 1
58833: ARRAY
58834: ST_TO_ADDR
// if onlyCombat then
58835: LD_VAR 0 2
58839: IFFALSE 59004
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
58841: LD_ADDR_VAR 0 3
58845: PUSH
58846: LD_VAR 0 3
58850: PUSH
58851: LD_VAR 0 3
58855: PPUSH
58856: LD_INT 2
58858: PUSH
58859: LD_INT 34
58861: PUSH
58862: LD_INT 12
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: PUSH
58869: LD_INT 34
58871: PUSH
58872: LD_INT 51
58874: PUSH
58875: EMPTY
58876: LIST
58877: LIST
58878: PUSH
58879: LD_INT 34
58881: PUSH
58882: LD_EXP 93
58886: PUSH
58887: EMPTY
58888: LIST
58889: LIST
58890: PUSH
58891: LD_INT 34
58893: PUSH
58894: LD_INT 32
58896: PUSH
58897: EMPTY
58898: LIST
58899: LIST
58900: PUSH
58901: LD_INT 34
58903: PUSH
58904: LD_INT 13
58906: PUSH
58907: EMPTY
58908: LIST
58909: LIST
58910: PUSH
58911: LD_INT 34
58913: PUSH
58914: LD_INT 52
58916: PUSH
58917: EMPTY
58918: LIST
58919: LIST
58920: PUSH
58921: LD_INT 34
58923: PUSH
58924: LD_INT 14
58926: PUSH
58927: EMPTY
58928: LIST
58929: LIST
58930: PUSH
58931: LD_INT 34
58933: PUSH
58934: LD_INT 53
58936: PUSH
58937: EMPTY
58938: LIST
58939: LIST
58940: PUSH
58941: LD_INT 34
58943: PUSH
58944: LD_EXP 92
58948: PUSH
58949: EMPTY
58950: LIST
58951: LIST
58952: PUSH
58953: LD_INT 34
58955: PUSH
58956: LD_INT 31
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: PUSH
58963: LD_INT 34
58965: PUSH
58966: LD_INT 48
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: PUSH
58973: LD_INT 34
58975: PUSH
58976: LD_INT 8
58978: PUSH
58979: EMPTY
58980: LIST
58981: LIST
58982: PUSH
58983: EMPTY
58984: LIST
58985: LIST
58986: LIST
58987: LIST
58988: LIST
58989: LIST
58990: LIST
58991: LIST
58992: LIST
58993: LIST
58994: LIST
58995: LIST
58996: LIST
58997: PPUSH
58998: CALL_OW 72
59002: DIFF
59003: ST_TO_ADDR
// end ; end_of_file
59004: LD_VAR 0 3
59008: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59009: LD_INT 0
59011: PPUSH
59012: PPUSH
59013: PPUSH
// if not mc_bases or not skirmish then
59014: LD_EXP 99
59018: NOT
59019: PUSH
59020: LD_EXP 97
59024: NOT
59025: OR
59026: IFFALSE 59030
// exit ;
59028: GO 59195
// for i = 1 to mc_bases do
59030: LD_ADDR_VAR 0 4
59034: PUSH
59035: DOUBLE
59036: LD_INT 1
59038: DEC
59039: ST_TO_ADDR
59040: LD_EXP 99
59044: PUSH
59045: FOR_TO
59046: IFFALSE 59193
// begin if sci in mc_bases [ i ] then
59048: LD_VAR 0 2
59052: PUSH
59053: LD_EXP 99
59057: PUSH
59058: LD_VAR 0 4
59062: ARRAY
59063: IN
59064: IFFALSE 59191
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59066: LD_ADDR_EXP 128
59070: PUSH
59071: LD_EXP 128
59075: PPUSH
59076: LD_VAR 0 4
59080: PUSH
59081: LD_EXP 128
59085: PUSH
59086: LD_VAR 0 4
59090: ARRAY
59091: PUSH
59092: LD_INT 1
59094: PLUS
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PPUSH
59100: LD_VAR 0 1
59104: PPUSH
59105: CALL 70507 0 3
59109: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59110: LD_ADDR_VAR 0 5
59114: PUSH
59115: LD_EXP 99
59119: PUSH
59120: LD_VAR 0 4
59124: ARRAY
59125: PPUSH
59126: LD_INT 2
59128: PUSH
59129: LD_INT 30
59131: PUSH
59132: LD_INT 0
59134: PUSH
59135: EMPTY
59136: LIST
59137: LIST
59138: PUSH
59139: LD_INT 30
59141: PUSH
59142: LD_INT 1
59144: PUSH
59145: EMPTY
59146: LIST
59147: LIST
59148: PUSH
59149: EMPTY
59150: LIST
59151: LIST
59152: LIST
59153: PPUSH
59154: CALL_OW 72
59158: PPUSH
59159: LD_VAR 0 1
59163: PPUSH
59164: CALL_OW 74
59168: ST_TO_ADDR
// if tmp then
59169: LD_VAR 0 5
59173: IFFALSE 59189
// ComStandNearbyBuilding ( ape , tmp ) ;
59175: LD_VAR 0 1
59179: PPUSH
59180: LD_VAR 0 5
59184: PPUSH
59185: CALL 65048 0 2
// break ;
59189: GO 59193
// end ; end ;
59191: GO 59045
59193: POP
59194: POP
// end ;
59195: LD_VAR 0 3
59199: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59200: LD_INT 0
59202: PPUSH
59203: PPUSH
59204: PPUSH
// if not mc_bases or not skirmish then
59205: LD_EXP 99
59209: NOT
59210: PUSH
59211: LD_EXP 97
59215: NOT
59216: OR
59217: IFFALSE 59221
// exit ;
59219: GO 59310
// for i = 1 to mc_bases do
59221: LD_ADDR_VAR 0 4
59225: PUSH
59226: DOUBLE
59227: LD_INT 1
59229: DEC
59230: ST_TO_ADDR
59231: LD_EXP 99
59235: PUSH
59236: FOR_TO
59237: IFFALSE 59308
// begin if building in mc_busy_turret_list [ i ] then
59239: LD_VAR 0 1
59243: PUSH
59244: LD_EXP 109
59248: PUSH
59249: LD_VAR 0 4
59253: ARRAY
59254: IN
59255: IFFALSE 59306
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59257: LD_ADDR_VAR 0 5
59261: PUSH
59262: LD_EXP 109
59266: PUSH
59267: LD_VAR 0 4
59271: ARRAY
59272: PUSH
59273: LD_VAR 0 1
59277: DIFF
59278: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59279: LD_ADDR_EXP 109
59283: PUSH
59284: LD_EXP 109
59288: PPUSH
59289: LD_VAR 0 4
59293: PPUSH
59294: LD_VAR 0 5
59298: PPUSH
59299: CALL_OW 1
59303: ST_TO_ADDR
// break ;
59304: GO 59308
// end ; end ;
59306: GO 59236
59308: POP
59309: POP
// end ;
59310: LD_VAR 0 3
59314: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59315: LD_INT 0
59317: PPUSH
59318: PPUSH
59319: PPUSH
// if not mc_bases or not skirmish then
59320: LD_EXP 99
59324: NOT
59325: PUSH
59326: LD_EXP 97
59330: NOT
59331: OR
59332: IFFALSE 59336
// exit ;
59334: GO 59535
// for i = 1 to mc_bases do
59336: LD_ADDR_VAR 0 5
59340: PUSH
59341: DOUBLE
59342: LD_INT 1
59344: DEC
59345: ST_TO_ADDR
59346: LD_EXP 99
59350: PUSH
59351: FOR_TO
59352: IFFALSE 59533
// if building in mc_bases [ i ] then
59354: LD_VAR 0 1
59358: PUSH
59359: LD_EXP 99
59363: PUSH
59364: LD_VAR 0 5
59368: ARRAY
59369: IN
59370: IFFALSE 59531
// begin tmp := mc_bases [ i ] diff building ;
59372: LD_ADDR_VAR 0 6
59376: PUSH
59377: LD_EXP 99
59381: PUSH
59382: LD_VAR 0 5
59386: ARRAY
59387: PUSH
59388: LD_VAR 0 1
59392: DIFF
59393: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59394: LD_ADDR_EXP 99
59398: PUSH
59399: LD_EXP 99
59403: PPUSH
59404: LD_VAR 0 5
59408: PPUSH
59409: LD_VAR 0 6
59413: PPUSH
59414: CALL_OW 1
59418: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59419: LD_VAR 0 1
59423: PUSH
59424: LD_EXP 107
59428: PUSH
59429: LD_VAR 0 5
59433: ARRAY
59434: IN
59435: IFFALSE 59474
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59437: LD_ADDR_EXP 107
59441: PUSH
59442: LD_EXP 107
59446: PPUSH
59447: LD_VAR 0 5
59451: PPUSH
59452: LD_EXP 107
59456: PUSH
59457: LD_VAR 0 5
59461: ARRAY
59462: PUSH
59463: LD_VAR 0 1
59467: DIFF
59468: PPUSH
59469: CALL_OW 1
59473: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59474: LD_VAR 0 1
59478: PUSH
59479: LD_EXP 108
59483: PUSH
59484: LD_VAR 0 5
59488: ARRAY
59489: IN
59490: IFFALSE 59529
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59492: LD_ADDR_EXP 108
59496: PUSH
59497: LD_EXP 108
59501: PPUSH
59502: LD_VAR 0 5
59506: PPUSH
59507: LD_EXP 108
59511: PUSH
59512: LD_VAR 0 5
59516: ARRAY
59517: PUSH
59518: LD_VAR 0 1
59522: DIFF
59523: PPUSH
59524: CALL_OW 1
59528: ST_TO_ADDR
// break ;
59529: GO 59533
// end ;
59531: GO 59351
59533: POP
59534: POP
// end ;
59535: LD_VAR 0 4
59539: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59540: LD_INT 0
59542: PPUSH
59543: PPUSH
59544: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59545: LD_EXP 99
59549: NOT
59550: PUSH
59551: LD_EXP 97
59555: NOT
59556: OR
59557: PUSH
59558: LD_VAR 0 3
59562: PUSH
59563: LD_EXP 125
59567: IN
59568: NOT
59569: OR
59570: IFFALSE 59574
// exit ;
59572: GO 59697
// for i = 1 to mc_vehicles do
59574: LD_ADDR_VAR 0 6
59578: PUSH
59579: DOUBLE
59580: LD_INT 1
59582: DEC
59583: ST_TO_ADDR
59584: LD_EXP 118
59588: PUSH
59589: FOR_TO
59590: IFFALSE 59695
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59592: LD_VAR 0 2
59596: PUSH
59597: LD_EXP 118
59601: PUSH
59602: LD_VAR 0 6
59606: ARRAY
59607: IN
59608: PUSH
59609: LD_VAR 0 1
59613: PUSH
59614: LD_EXP 118
59618: PUSH
59619: LD_VAR 0 6
59623: ARRAY
59624: IN
59625: OR
59626: IFFALSE 59693
// begin tmp := mc_vehicles [ i ] diff old ;
59628: LD_ADDR_VAR 0 7
59632: PUSH
59633: LD_EXP 118
59637: PUSH
59638: LD_VAR 0 6
59642: ARRAY
59643: PUSH
59644: LD_VAR 0 2
59648: DIFF
59649: ST_TO_ADDR
// tmp := tmp diff new ;
59650: LD_ADDR_VAR 0 7
59654: PUSH
59655: LD_VAR 0 7
59659: PUSH
59660: LD_VAR 0 1
59664: DIFF
59665: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59666: LD_ADDR_EXP 118
59670: PUSH
59671: LD_EXP 118
59675: PPUSH
59676: LD_VAR 0 6
59680: PPUSH
59681: LD_VAR 0 7
59685: PPUSH
59686: CALL_OW 1
59690: ST_TO_ADDR
// break ;
59691: GO 59695
// end ;
59693: GO 59589
59695: POP
59696: POP
// end ;
59697: LD_VAR 0 5
59701: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
59702: LD_INT 0
59704: PPUSH
59705: PPUSH
59706: PPUSH
59707: PPUSH
// if not mc_bases or not skirmish then
59708: LD_EXP 99
59712: NOT
59713: PUSH
59714: LD_EXP 97
59718: NOT
59719: OR
59720: IFFALSE 59724
// exit ;
59722: GO 60101
// side := GetSide ( vehicle ) ;
59724: LD_ADDR_VAR 0 5
59728: PUSH
59729: LD_VAR 0 1
59733: PPUSH
59734: CALL_OW 255
59738: ST_TO_ADDR
// for i = 1 to mc_bases do
59739: LD_ADDR_VAR 0 4
59743: PUSH
59744: DOUBLE
59745: LD_INT 1
59747: DEC
59748: ST_TO_ADDR
59749: LD_EXP 99
59753: PUSH
59754: FOR_TO
59755: IFFALSE 60099
// begin if factory in mc_bases [ i ] then
59757: LD_VAR 0 2
59761: PUSH
59762: LD_EXP 99
59766: PUSH
59767: LD_VAR 0 4
59771: ARRAY
59772: IN
59773: IFFALSE 60097
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
59775: LD_EXP 121
59779: PUSH
59780: LD_VAR 0 4
59784: ARRAY
59785: PUSH
59786: LD_EXP 110
59790: PUSH
59791: LD_VAR 0 4
59795: ARRAY
59796: LESS
59797: PUSH
59798: LD_VAR 0 1
59802: PPUSH
59803: CALL_OW 264
59807: PUSH
59808: LD_INT 31
59810: PUSH
59811: LD_INT 32
59813: PUSH
59814: LD_INT 51
59816: PUSH
59817: LD_EXP 93
59821: PUSH
59822: LD_INT 12
59824: PUSH
59825: LD_INT 30
59827: PUSH
59828: LD_EXP 92
59832: PUSH
59833: LD_INT 11
59835: PUSH
59836: LD_INT 53
59838: PUSH
59839: LD_INT 14
59841: PUSH
59842: LD_EXP 96
59846: PUSH
59847: LD_INT 29
59849: PUSH
59850: LD_EXP 94
59854: PUSH
59855: LD_INT 13
59857: PUSH
59858: LD_INT 52
59860: PUSH
59861: LD_INT 48
59863: PUSH
59864: LD_INT 8
59866: PUSH
59867: EMPTY
59868: LIST
59869: LIST
59870: LIST
59871: LIST
59872: LIST
59873: LIST
59874: LIST
59875: LIST
59876: LIST
59877: LIST
59878: LIST
59879: LIST
59880: LIST
59881: LIST
59882: LIST
59883: LIST
59884: LIST
59885: IN
59886: NOT
59887: AND
59888: IFFALSE 59936
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
59890: LD_ADDR_EXP 121
59894: PUSH
59895: LD_EXP 121
59899: PPUSH
59900: LD_VAR 0 4
59904: PUSH
59905: LD_EXP 121
59909: PUSH
59910: LD_VAR 0 4
59914: ARRAY
59915: PUSH
59916: LD_INT 1
59918: PLUS
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: PPUSH
59924: LD_VAR 0 1
59928: PPUSH
59929: CALL 70507 0 3
59933: ST_TO_ADDR
59934: GO 59980
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
59936: LD_ADDR_EXP 118
59940: PUSH
59941: LD_EXP 118
59945: PPUSH
59946: LD_VAR 0 4
59950: PUSH
59951: LD_EXP 118
59955: PUSH
59956: LD_VAR 0 4
59960: ARRAY
59961: PUSH
59962: LD_INT 1
59964: PLUS
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: PPUSH
59970: LD_VAR 0 1
59974: PPUSH
59975: CALL 70507 0 3
59979: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
59980: LD_VAR 0 1
59984: PPUSH
59985: CALL_OW 263
59989: PUSH
59990: LD_INT 2
59992: EQUAL
59993: IFFALSE 60013
// begin repeat wait ( 0 0$1 ) ;
59995: LD_INT 35
59997: PPUSH
59998: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60002: LD_VAR 0 1
60006: PPUSH
60007: CALL_OW 312
60011: IFFALSE 59995
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60013: LD_VAR 0 1
60017: PPUSH
60018: LD_EXP 123
60022: PUSH
60023: LD_VAR 0 4
60027: ARRAY
60028: PPUSH
60029: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60033: LD_VAR 0 1
60037: PPUSH
60038: CALL_OW 263
60042: PUSH
60043: LD_INT 1
60045: NONEQUAL
60046: IFFALSE 60050
// break ;
60048: GO 60099
// repeat wait ( 0 0$1 ) ;
60050: LD_INT 35
60052: PPUSH
60053: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60057: LD_VAR 0 1
60061: PPUSH
60062: LD_EXP 123
60066: PUSH
60067: LD_VAR 0 4
60071: ARRAY
60072: PPUSH
60073: CALL_OW 308
60077: IFFALSE 60050
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60079: LD_VAR 0 1
60083: PPUSH
60084: CALL_OW 311
60088: PPUSH
60089: CALL_OW 121
// exit ;
60093: POP
60094: POP
60095: GO 60101
// end ; end ;
60097: GO 59754
60099: POP
60100: POP
// end ;
60101: LD_VAR 0 3
60105: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60106: LD_INT 0
60108: PPUSH
60109: PPUSH
60110: PPUSH
60111: PPUSH
// if not mc_bases or not skirmish then
60112: LD_EXP 99
60116: NOT
60117: PUSH
60118: LD_EXP 97
60122: NOT
60123: OR
60124: IFFALSE 60128
// exit ;
60126: GO 60481
// repeat wait ( 0 0$1 ) ;
60128: LD_INT 35
60130: PPUSH
60131: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60135: LD_VAR 0 2
60139: PPUSH
60140: LD_VAR 0 3
60144: PPUSH
60145: CALL_OW 284
60149: IFFALSE 60128
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60151: LD_VAR 0 2
60155: PPUSH
60156: LD_VAR 0 3
60160: PPUSH
60161: CALL_OW 283
60165: PUSH
60166: LD_INT 4
60168: EQUAL
60169: IFFALSE 60173
// exit ;
60171: GO 60481
// for i = 1 to mc_bases do
60173: LD_ADDR_VAR 0 7
60177: PUSH
60178: DOUBLE
60179: LD_INT 1
60181: DEC
60182: ST_TO_ADDR
60183: LD_EXP 99
60187: PUSH
60188: FOR_TO
60189: IFFALSE 60479
// begin if mc_crates_area [ i ] then
60191: LD_EXP 117
60195: PUSH
60196: LD_VAR 0 7
60200: ARRAY
60201: IFFALSE 60312
// for j in mc_crates_area [ i ] do
60203: LD_ADDR_VAR 0 8
60207: PUSH
60208: LD_EXP 117
60212: PUSH
60213: LD_VAR 0 7
60217: ARRAY
60218: PUSH
60219: FOR_IN
60220: IFFALSE 60310
// if InArea ( x , y , j ) then
60222: LD_VAR 0 2
60226: PPUSH
60227: LD_VAR 0 3
60231: PPUSH
60232: LD_VAR 0 8
60236: PPUSH
60237: CALL_OW 309
60241: IFFALSE 60308
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60243: LD_ADDR_EXP 115
60247: PUSH
60248: LD_EXP 115
60252: PPUSH
60253: LD_VAR 0 7
60257: PUSH
60258: LD_EXP 115
60262: PUSH
60263: LD_VAR 0 7
60267: ARRAY
60268: PUSH
60269: LD_INT 1
60271: PLUS
60272: PUSH
60273: EMPTY
60274: LIST
60275: LIST
60276: PPUSH
60277: LD_VAR 0 4
60281: PUSH
60282: LD_VAR 0 2
60286: PUSH
60287: LD_VAR 0 3
60291: PUSH
60292: EMPTY
60293: LIST
60294: LIST
60295: LIST
60296: PPUSH
60297: CALL 70507 0 3
60301: ST_TO_ADDR
// exit ;
60302: POP
60303: POP
60304: POP
60305: POP
60306: GO 60481
// end ;
60308: GO 60219
60310: POP
60311: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60312: LD_ADDR_VAR 0 9
60316: PUSH
60317: LD_EXP 99
60321: PUSH
60322: LD_VAR 0 7
60326: ARRAY
60327: PPUSH
60328: LD_INT 2
60330: PUSH
60331: LD_INT 30
60333: PUSH
60334: LD_INT 0
60336: PUSH
60337: EMPTY
60338: LIST
60339: LIST
60340: PUSH
60341: LD_INT 30
60343: PUSH
60344: LD_INT 1
60346: PUSH
60347: EMPTY
60348: LIST
60349: LIST
60350: PUSH
60351: EMPTY
60352: LIST
60353: LIST
60354: LIST
60355: PPUSH
60356: CALL_OW 72
60360: ST_TO_ADDR
// if not depot then
60361: LD_VAR 0 9
60365: NOT
60366: IFFALSE 60370
// continue ;
60368: GO 60188
// for j in depot do
60370: LD_ADDR_VAR 0 8
60374: PUSH
60375: LD_VAR 0 9
60379: PUSH
60380: FOR_IN
60381: IFFALSE 60475
// if GetDistUnitXY ( j , x , y ) < 30 then
60383: LD_VAR 0 8
60387: PPUSH
60388: LD_VAR 0 2
60392: PPUSH
60393: LD_VAR 0 3
60397: PPUSH
60398: CALL_OW 297
60402: PUSH
60403: LD_INT 30
60405: LESS
60406: IFFALSE 60473
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60408: LD_ADDR_EXP 115
60412: PUSH
60413: LD_EXP 115
60417: PPUSH
60418: LD_VAR 0 7
60422: PUSH
60423: LD_EXP 115
60427: PUSH
60428: LD_VAR 0 7
60432: ARRAY
60433: PUSH
60434: LD_INT 1
60436: PLUS
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: PPUSH
60442: LD_VAR 0 4
60446: PUSH
60447: LD_VAR 0 2
60451: PUSH
60452: LD_VAR 0 3
60456: PUSH
60457: EMPTY
60458: LIST
60459: LIST
60460: LIST
60461: PPUSH
60462: CALL 70507 0 3
60466: ST_TO_ADDR
// exit ;
60467: POP
60468: POP
60469: POP
60470: POP
60471: GO 60481
// end ;
60473: GO 60380
60475: POP
60476: POP
// end ;
60477: GO 60188
60479: POP
60480: POP
// end ;
60481: LD_VAR 0 6
60485: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
60486: LD_INT 0
60488: PPUSH
60489: PPUSH
60490: PPUSH
60491: PPUSH
// if not mc_bases or not skirmish then
60492: LD_EXP 99
60496: NOT
60497: PUSH
60498: LD_EXP 97
60502: NOT
60503: OR
60504: IFFALSE 60508
// exit ;
60506: GO 60785
// side := GetSide ( lab ) ;
60508: LD_ADDR_VAR 0 4
60512: PUSH
60513: LD_VAR 0 2
60517: PPUSH
60518: CALL_OW 255
60522: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60523: LD_VAR 0 4
60527: PUSH
60528: LD_EXP 125
60532: IN
60533: NOT
60534: PUSH
60535: LD_EXP 126
60539: NOT
60540: OR
60541: PUSH
60542: LD_EXP 99
60546: NOT
60547: OR
60548: IFFALSE 60552
// exit ;
60550: GO 60785
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60552: LD_ADDR_EXP 126
60556: PUSH
60557: LD_EXP 126
60561: PPUSH
60562: LD_VAR 0 4
60566: PPUSH
60567: LD_EXP 126
60571: PUSH
60572: LD_VAR 0 4
60576: ARRAY
60577: PUSH
60578: LD_VAR 0 1
60582: DIFF
60583: PPUSH
60584: CALL_OW 1
60588: ST_TO_ADDR
// for i = 1 to mc_bases do
60589: LD_ADDR_VAR 0 5
60593: PUSH
60594: DOUBLE
60595: LD_INT 1
60597: DEC
60598: ST_TO_ADDR
60599: LD_EXP 99
60603: PUSH
60604: FOR_TO
60605: IFFALSE 60783
// begin if lab in mc_bases [ i ] then
60607: LD_VAR 0 2
60611: PUSH
60612: LD_EXP 99
60616: PUSH
60617: LD_VAR 0 5
60621: ARRAY
60622: IN
60623: IFFALSE 60781
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60625: LD_VAR 0 1
60629: PUSH
60630: LD_INT 11
60632: PUSH
60633: LD_INT 4
60635: PUSH
60636: LD_INT 3
60638: PUSH
60639: LD_INT 2
60641: PUSH
60642: EMPTY
60643: LIST
60644: LIST
60645: LIST
60646: LIST
60647: IN
60648: PUSH
60649: LD_EXP 129
60653: PUSH
60654: LD_VAR 0 5
60658: ARRAY
60659: AND
60660: IFFALSE 60781
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60662: LD_ADDR_VAR 0 6
60666: PUSH
60667: LD_EXP 129
60671: PUSH
60672: LD_VAR 0 5
60676: ARRAY
60677: PUSH
60678: LD_INT 1
60680: ARRAY
60681: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60682: LD_ADDR_EXP 129
60686: PUSH
60687: LD_EXP 129
60691: PPUSH
60692: LD_VAR 0 5
60696: PPUSH
60697: EMPTY
60698: PPUSH
60699: CALL_OW 1
60703: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
60704: LD_VAR 0 6
60708: PPUSH
60709: LD_INT 0
60711: PPUSH
60712: CALL_OW 109
// ComExitBuilding ( tmp ) ;
60716: LD_VAR 0 6
60720: PPUSH
60721: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
60725: LD_ADDR_EXP 128
60729: PUSH
60730: LD_EXP 128
60734: PPUSH
60735: LD_VAR 0 5
60739: PPUSH
60740: LD_EXP 128
60744: PUSH
60745: LD_VAR 0 5
60749: ARRAY
60750: PPUSH
60751: LD_INT 1
60753: PPUSH
60754: LD_VAR 0 6
60758: PPUSH
60759: CALL_OW 2
60763: PPUSH
60764: CALL_OW 1
60768: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
60769: LD_VAR 0 5
60773: PPUSH
60774: LD_INT 112
60776: PPUSH
60777: CALL 37893 0 2
// end ; end ; end ;
60781: GO 60604
60783: POP
60784: POP
// end ;
60785: LD_VAR 0 3
60789: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
60790: LD_INT 0
60792: PPUSH
60793: PPUSH
60794: PPUSH
60795: PPUSH
60796: PPUSH
60797: PPUSH
60798: PPUSH
60799: PPUSH
// if not mc_bases or not skirmish then
60800: LD_EXP 99
60804: NOT
60805: PUSH
60806: LD_EXP 97
60810: NOT
60811: OR
60812: IFFALSE 60816
// exit ;
60814: GO 62053
// for i = 1 to mc_bases do
60816: LD_ADDR_VAR 0 3
60820: PUSH
60821: DOUBLE
60822: LD_INT 1
60824: DEC
60825: ST_TO_ADDR
60826: LD_EXP 99
60830: PUSH
60831: FOR_TO
60832: IFFALSE 62051
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
60834: LD_VAR 0 1
60838: PUSH
60839: LD_EXP 99
60843: PUSH
60844: LD_VAR 0 3
60848: ARRAY
60849: IN
60850: PUSH
60851: LD_VAR 0 1
60855: PUSH
60856: LD_EXP 106
60860: PUSH
60861: LD_VAR 0 3
60865: ARRAY
60866: IN
60867: OR
60868: PUSH
60869: LD_VAR 0 1
60873: PUSH
60874: LD_EXP 121
60878: PUSH
60879: LD_VAR 0 3
60883: ARRAY
60884: IN
60885: OR
60886: PUSH
60887: LD_VAR 0 1
60891: PUSH
60892: LD_EXP 118
60896: PUSH
60897: LD_VAR 0 3
60901: ARRAY
60902: IN
60903: OR
60904: PUSH
60905: LD_VAR 0 1
60909: PUSH
60910: LD_EXP 128
60914: PUSH
60915: LD_VAR 0 3
60919: ARRAY
60920: IN
60921: OR
60922: PUSH
60923: LD_VAR 0 1
60927: PUSH
60928: LD_EXP 129
60932: PUSH
60933: LD_VAR 0 3
60937: ARRAY
60938: IN
60939: OR
60940: IFFALSE 62049
// begin if un in mc_ape [ i ] then
60942: LD_VAR 0 1
60946: PUSH
60947: LD_EXP 128
60951: PUSH
60952: LD_VAR 0 3
60956: ARRAY
60957: IN
60958: IFFALSE 60997
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
60960: LD_ADDR_EXP 128
60964: PUSH
60965: LD_EXP 128
60969: PPUSH
60970: LD_VAR 0 3
60974: PPUSH
60975: LD_EXP 128
60979: PUSH
60980: LD_VAR 0 3
60984: ARRAY
60985: PUSH
60986: LD_VAR 0 1
60990: DIFF
60991: PPUSH
60992: CALL_OW 1
60996: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
60997: LD_VAR 0 1
61001: PUSH
61002: LD_EXP 129
61006: PUSH
61007: LD_VAR 0 3
61011: ARRAY
61012: IN
61013: IFFALSE 61037
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61015: LD_ADDR_EXP 129
61019: PUSH
61020: LD_EXP 129
61024: PPUSH
61025: LD_VAR 0 3
61029: PPUSH
61030: EMPTY
61031: PPUSH
61032: CALL_OW 1
61036: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
61037: LD_VAR 0 1
61041: PPUSH
61042: CALL_OW 247
61046: PUSH
61047: LD_INT 2
61049: EQUAL
61050: PUSH
61051: LD_VAR 0 1
61055: PPUSH
61056: CALL_OW 110
61060: PUSH
61061: LD_INT 20
61063: EQUAL
61064: PUSH
61065: LD_VAR 0 1
61069: PUSH
61070: LD_EXP 121
61074: PUSH
61075: LD_VAR 0 3
61079: ARRAY
61080: IN
61081: OR
61082: PUSH
61083: LD_VAR 0 1
61087: PPUSH
61088: CALL_OW 264
61092: PUSH
61093: LD_INT 12
61095: PUSH
61096: LD_INT 51
61098: PUSH
61099: LD_EXP 93
61103: PUSH
61104: LD_INT 32
61106: PUSH
61107: LD_INT 13
61109: PUSH
61110: LD_INT 52
61112: PUSH
61113: EMPTY
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: IN
61121: OR
61122: AND
61123: IFFALSE 61301
// begin if un in mc_defender [ i ] then
61125: LD_VAR 0 1
61129: PUSH
61130: LD_EXP 121
61134: PUSH
61135: LD_VAR 0 3
61139: ARRAY
61140: IN
61141: IFFALSE 61180
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61143: LD_ADDR_EXP 121
61147: PUSH
61148: LD_EXP 121
61152: PPUSH
61153: LD_VAR 0 3
61157: PPUSH
61158: LD_EXP 121
61162: PUSH
61163: LD_VAR 0 3
61167: ARRAY
61168: PUSH
61169: LD_VAR 0 1
61173: DIFF
61174: PPUSH
61175: CALL_OW 1
61179: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61180: LD_ADDR_VAR 0 8
61184: PUSH
61185: LD_VAR 0 3
61189: PPUSH
61190: LD_INT 3
61192: PPUSH
61193: CALL 57853 0 2
61197: ST_TO_ADDR
// if fac then
61198: LD_VAR 0 8
61202: IFFALSE 61301
// begin for j in fac do
61204: LD_ADDR_VAR 0 4
61208: PUSH
61209: LD_VAR 0 8
61213: PUSH
61214: FOR_IN
61215: IFFALSE 61299
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61217: LD_ADDR_VAR 0 9
61221: PUSH
61222: LD_VAR 0 8
61226: PPUSH
61227: LD_VAR 0 1
61231: PPUSH
61232: CALL_OW 265
61236: PPUSH
61237: LD_VAR 0 1
61241: PPUSH
61242: CALL_OW 262
61246: PPUSH
61247: LD_VAR 0 1
61251: PPUSH
61252: CALL_OW 263
61256: PPUSH
61257: LD_VAR 0 1
61261: PPUSH
61262: CALL_OW 264
61266: PPUSH
61267: CALL 68039 0 5
61271: ST_TO_ADDR
// if components then
61272: LD_VAR 0 9
61276: IFFALSE 61297
// begin MC_InsertProduceList ( i , [ components ] ) ;
61278: LD_VAR 0 3
61282: PPUSH
61283: LD_VAR 0 9
61287: PUSH
61288: EMPTY
61289: LIST
61290: PPUSH
61291: CALL 57398 0 2
// break ;
61295: GO 61299
// end ; end ;
61297: GO 61214
61299: POP
61300: POP
// end ; end ; if GetType ( un ) = unit_building then
61301: LD_VAR 0 1
61305: PPUSH
61306: CALL_OW 247
61310: PUSH
61311: LD_INT 3
61313: EQUAL
61314: IFFALSE 61717
// begin btype := GetBType ( un ) ;
61316: LD_ADDR_VAR 0 5
61320: PUSH
61321: LD_VAR 0 1
61325: PPUSH
61326: CALL_OW 266
61330: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61331: LD_VAR 0 5
61335: PUSH
61336: LD_INT 29
61338: PUSH
61339: LD_INT 30
61341: PUSH
61342: EMPTY
61343: LIST
61344: LIST
61345: IN
61346: IFFALSE 61419
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
61348: LD_VAR 0 1
61352: PPUSH
61353: CALL_OW 250
61357: PPUSH
61358: LD_VAR 0 1
61362: PPUSH
61363: CALL_OW 251
61367: PPUSH
61368: LD_VAR 0 1
61372: PPUSH
61373: CALL_OW 255
61377: PPUSH
61378: CALL_OW 440
61382: NOT
61383: IFFALSE 61419
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
61385: LD_VAR 0 1
61389: PPUSH
61390: CALL_OW 250
61394: PPUSH
61395: LD_VAR 0 1
61399: PPUSH
61400: CALL_OW 251
61404: PPUSH
61405: LD_VAR 0 1
61409: PPUSH
61410: CALL_OW 255
61414: PPUSH
61415: CALL_OW 441
// end ; if btype = b_warehouse then
61419: LD_VAR 0 5
61423: PUSH
61424: LD_INT 1
61426: EQUAL
61427: IFFALSE 61445
// begin btype := b_depot ;
61429: LD_ADDR_VAR 0 5
61433: PUSH
61434: LD_INT 0
61436: ST_TO_ADDR
// pos := 1 ;
61437: LD_ADDR_VAR 0 6
61441: PUSH
61442: LD_INT 1
61444: ST_TO_ADDR
// end ; if btype = b_factory then
61445: LD_VAR 0 5
61449: PUSH
61450: LD_INT 3
61452: EQUAL
61453: IFFALSE 61471
// begin btype := b_workshop ;
61455: LD_ADDR_VAR 0 5
61459: PUSH
61460: LD_INT 2
61462: ST_TO_ADDR
// pos := 1 ;
61463: LD_ADDR_VAR 0 6
61467: PUSH
61468: LD_INT 1
61470: ST_TO_ADDR
// end ; if btype = b_barracks then
61471: LD_VAR 0 5
61475: PUSH
61476: LD_INT 5
61478: EQUAL
61479: IFFALSE 61489
// btype := b_armoury ;
61481: LD_ADDR_VAR 0 5
61485: PUSH
61486: LD_INT 4
61488: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
61489: LD_VAR 0 5
61493: PUSH
61494: LD_INT 7
61496: PUSH
61497: LD_INT 8
61499: PUSH
61500: EMPTY
61501: LIST
61502: LIST
61503: IN
61504: IFFALSE 61514
// btype := b_lab ;
61506: LD_ADDR_VAR 0 5
61510: PUSH
61511: LD_INT 6
61513: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
61514: LD_ADDR_EXP 104
61518: PUSH
61519: LD_EXP 104
61523: PPUSH
61524: LD_VAR 0 3
61528: PUSH
61529: LD_EXP 104
61533: PUSH
61534: LD_VAR 0 3
61538: ARRAY
61539: PUSH
61540: LD_INT 1
61542: PLUS
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PPUSH
61548: LD_VAR 0 5
61552: PUSH
61553: LD_VAR 0 1
61557: PPUSH
61558: CALL_OW 250
61562: PUSH
61563: LD_VAR 0 1
61567: PPUSH
61568: CALL_OW 251
61572: PUSH
61573: LD_VAR 0 1
61577: PPUSH
61578: CALL_OW 254
61582: PUSH
61583: EMPTY
61584: LIST
61585: LIST
61586: LIST
61587: LIST
61588: PPUSH
61589: CALL 70507 0 3
61593: ST_TO_ADDR
// if pos = 1 then
61594: LD_VAR 0 6
61598: PUSH
61599: LD_INT 1
61601: EQUAL
61602: IFFALSE 61717
// begin tmp := mc_build_list [ i ] ;
61604: LD_ADDR_VAR 0 7
61608: PUSH
61609: LD_EXP 104
61613: PUSH
61614: LD_VAR 0 3
61618: ARRAY
61619: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61620: LD_VAR 0 7
61624: PPUSH
61625: LD_INT 2
61627: PUSH
61628: LD_INT 30
61630: PUSH
61631: LD_INT 0
61633: PUSH
61634: EMPTY
61635: LIST
61636: LIST
61637: PUSH
61638: LD_INT 30
61640: PUSH
61641: LD_INT 1
61643: PUSH
61644: EMPTY
61645: LIST
61646: LIST
61647: PUSH
61648: EMPTY
61649: LIST
61650: LIST
61651: LIST
61652: PPUSH
61653: CALL_OW 72
61657: IFFALSE 61667
// pos := 2 ;
61659: LD_ADDR_VAR 0 6
61663: PUSH
61664: LD_INT 2
61666: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
61667: LD_ADDR_VAR 0 7
61671: PUSH
61672: LD_VAR 0 7
61676: PPUSH
61677: LD_VAR 0 6
61681: PPUSH
61682: LD_VAR 0 7
61686: PPUSH
61687: CALL 70833 0 3
61691: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
61692: LD_ADDR_EXP 104
61696: PUSH
61697: LD_EXP 104
61701: PPUSH
61702: LD_VAR 0 3
61706: PPUSH
61707: LD_VAR 0 7
61711: PPUSH
61712: CALL_OW 1
61716: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
61717: LD_VAR 0 1
61721: PUSH
61722: LD_EXP 99
61726: PUSH
61727: LD_VAR 0 3
61731: ARRAY
61732: IN
61733: IFFALSE 61772
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
61735: LD_ADDR_EXP 99
61739: PUSH
61740: LD_EXP 99
61744: PPUSH
61745: LD_VAR 0 3
61749: PPUSH
61750: LD_EXP 99
61754: PUSH
61755: LD_VAR 0 3
61759: ARRAY
61760: PUSH
61761: LD_VAR 0 1
61765: DIFF
61766: PPUSH
61767: CALL_OW 1
61771: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
61772: LD_VAR 0 1
61776: PUSH
61777: LD_EXP 106
61781: PUSH
61782: LD_VAR 0 3
61786: ARRAY
61787: IN
61788: IFFALSE 61827
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
61790: LD_ADDR_EXP 106
61794: PUSH
61795: LD_EXP 106
61799: PPUSH
61800: LD_VAR 0 3
61804: PPUSH
61805: LD_EXP 106
61809: PUSH
61810: LD_VAR 0 3
61814: ARRAY
61815: PUSH
61816: LD_VAR 0 1
61820: DIFF
61821: PPUSH
61822: CALL_OW 1
61826: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
61827: LD_VAR 0 1
61831: PUSH
61832: LD_EXP 118
61836: PUSH
61837: LD_VAR 0 3
61841: ARRAY
61842: IN
61843: IFFALSE 61882
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
61845: LD_ADDR_EXP 118
61849: PUSH
61850: LD_EXP 118
61854: PPUSH
61855: LD_VAR 0 3
61859: PPUSH
61860: LD_EXP 118
61864: PUSH
61865: LD_VAR 0 3
61869: ARRAY
61870: PUSH
61871: LD_VAR 0 1
61875: DIFF
61876: PPUSH
61877: CALL_OW 1
61881: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
61882: LD_VAR 0 1
61886: PUSH
61887: LD_EXP 121
61891: PUSH
61892: LD_VAR 0 3
61896: ARRAY
61897: IN
61898: IFFALSE 61937
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61900: LD_ADDR_EXP 121
61904: PUSH
61905: LD_EXP 121
61909: PPUSH
61910: LD_VAR 0 3
61914: PPUSH
61915: LD_EXP 121
61919: PUSH
61920: LD_VAR 0 3
61924: ARRAY
61925: PUSH
61926: LD_VAR 0 1
61930: DIFF
61931: PPUSH
61932: CALL_OW 1
61936: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
61937: LD_VAR 0 1
61941: PUSH
61942: LD_EXP 108
61946: PUSH
61947: LD_VAR 0 3
61951: ARRAY
61952: IN
61953: IFFALSE 61992
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
61955: LD_ADDR_EXP 108
61959: PUSH
61960: LD_EXP 108
61964: PPUSH
61965: LD_VAR 0 3
61969: PPUSH
61970: LD_EXP 108
61974: PUSH
61975: LD_VAR 0 3
61979: ARRAY
61980: PUSH
61981: LD_VAR 0 1
61985: DIFF
61986: PPUSH
61987: CALL_OW 1
61991: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
61992: LD_VAR 0 1
61996: PUSH
61997: LD_EXP 107
62001: PUSH
62002: LD_VAR 0 3
62006: ARRAY
62007: IN
62008: IFFALSE 62047
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62010: LD_ADDR_EXP 107
62014: PUSH
62015: LD_EXP 107
62019: PPUSH
62020: LD_VAR 0 3
62024: PPUSH
62025: LD_EXP 107
62029: PUSH
62030: LD_VAR 0 3
62034: ARRAY
62035: PUSH
62036: LD_VAR 0 1
62040: DIFF
62041: PPUSH
62042: CALL_OW 1
62046: ST_TO_ADDR
// end ; break ;
62047: GO 62051
// end ;
62049: GO 60831
62051: POP
62052: POP
// end ;
62053: LD_VAR 0 2
62057: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62058: LD_INT 0
62060: PPUSH
62061: PPUSH
62062: PPUSH
// if not mc_bases or not skirmish then
62063: LD_EXP 99
62067: NOT
62068: PUSH
62069: LD_EXP 97
62073: NOT
62074: OR
62075: IFFALSE 62079
// exit ;
62077: GO 62294
// for i = 1 to mc_bases do
62079: LD_ADDR_VAR 0 3
62083: PUSH
62084: DOUBLE
62085: LD_INT 1
62087: DEC
62088: ST_TO_ADDR
62089: LD_EXP 99
62093: PUSH
62094: FOR_TO
62095: IFFALSE 62292
// begin if building in mc_construct_list [ i ] then
62097: LD_VAR 0 1
62101: PUSH
62102: LD_EXP 106
62106: PUSH
62107: LD_VAR 0 3
62111: ARRAY
62112: IN
62113: IFFALSE 62290
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62115: LD_ADDR_EXP 106
62119: PUSH
62120: LD_EXP 106
62124: PPUSH
62125: LD_VAR 0 3
62129: PPUSH
62130: LD_EXP 106
62134: PUSH
62135: LD_VAR 0 3
62139: ARRAY
62140: PUSH
62141: LD_VAR 0 1
62145: DIFF
62146: PPUSH
62147: CALL_OW 1
62151: ST_TO_ADDR
// if building in mc_lab [ i ] then
62152: LD_VAR 0 1
62156: PUSH
62157: LD_EXP 132
62161: PUSH
62162: LD_VAR 0 3
62166: ARRAY
62167: IN
62168: IFFALSE 62223
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62170: LD_ADDR_EXP 133
62174: PUSH
62175: LD_EXP 133
62179: PPUSH
62180: LD_VAR 0 3
62184: PPUSH
62185: LD_EXP 133
62189: PUSH
62190: LD_VAR 0 3
62194: ARRAY
62195: PPUSH
62196: LD_INT 1
62198: PPUSH
62199: LD_EXP 133
62203: PUSH
62204: LD_VAR 0 3
62208: ARRAY
62209: PPUSH
62210: LD_INT 0
62212: PPUSH
62213: CALL 69925 0 4
62217: PPUSH
62218: CALL_OW 1
62222: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62223: LD_VAR 0 1
62227: PUSH
62228: LD_EXP 99
62232: PUSH
62233: LD_VAR 0 3
62237: ARRAY
62238: IN
62239: NOT
62240: IFFALSE 62286
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62242: LD_ADDR_EXP 99
62246: PUSH
62247: LD_EXP 99
62251: PPUSH
62252: LD_VAR 0 3
62256: PUSH
62257: LD_EXP 99
62261: PUSH
62262: LD_VAR 0 3
62266: ARRAY
62267: PUSH
62268: LD_INT 1
62270: PLUS
62271: PUSH
62272: EMPTY
62273: LIST
62274: LIST
62275: PPUSH
62276: LD_VAR 0 1
62280: PPUSH
62281: CALL 70507 0 3
62285: ST_TO_ADDR
// exit ;
62286: POP
62287: POP
62288: GO 62294
// end ; end ;
62290: GO 62094
62292: POP
62293: POP
// end ;
62294: LD_VAR 0 2
62298: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62299: LD_INT 0
62301: PPUSH
62302: PPUSH
62303: PPUSH
62304: PPUSH
62305: PPUSH
62306: PPUSH
62307: PPUSH
// if not mc_bases or not skirmish then
62308: LD_EXP 99
62312: NOT
62313: PUSH
62314: LD_EXP 97
62318: NOT
62319: OR
62320: IFFALSE 62324
// exit ;
62322: GO 62985
// for i = 1 to mc_bases do
62324: LD_ADDR_VAR 0 3
62328: PUSH
62329: DOUBLE
62330: LD_INT 1
62332: DEC
62333: ST_TO_ADDR
62334: LD_EXP 99
62338: PUSH
62339: FOR_TO
62340: IFFALSE 62983
// begin if building in mc_construct_list [ i ] then
62342: LD_VAR 0 1
62346: PUSH
62347: LD_EXP 106
62351: PUSH
62352: LD_VAR 0 3
62356: ARRAY
62357: IN
62358: IFFALSE 62981
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62360: LD_ADDR_EXP 106
62364: PUSH
62365: LD_EXP 106
62369: PPUSH
62370: LD_VAR 0 3
62374: PPUSH
62375: LD_EXP 106
62379: PUSH
62380: LD_VAR 0 3
62384: ARRAY
62385: PUSH
62386: LD_VAR 0 1
62390: DIFF
62391: PPUSH
62392: CALL_OW 1
62396: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62397: LD_ADDR_EXP 99
62401: PUSH
62402: LD_EXP 99
62406: PPUSH
62407: LD_VAR 0 3
62411: PUSH
62412: LD_EXP 99
62416: PUSH
62417: LD_VAR 0 3
62421: ARRAY
62422: PUSH
62423: LD_INT 1
62425: PLUS
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: PPUSH
62431: LD_VAR 0 1
62435: PPUSH
62436: CALL 70507 0 3
62440: ST_TO_ADDR
// btype := GetBType ( building ) ;
62441: LD_ADDR_VAR 0 5
62445: PUSH
62446: LD_VAR 0 1
62450: PPUSH
62451: CALL_OW 266
62455: ST_TO_ADDR
// side := GetSide ( building ) ;
62456: LD_ADDR_VAR 0 8
62460: PUSH
62461: LD_VAR 0 1
62465: PPUSH
62466: CALL_OW 255
62470: ST_TO_ADDR
// if btype = b_lab then
62471: LD_VAR 0 5
62475: PUSH
62476: LD_INT 6
62478: EQUAL
62479: IFFALSE 62529
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
62481: LD_ADDR_EXP 132
62485: PUSH
62486: LD_EXP 132
62490: PPUSH
62491: LD_VAR 0 3
62495: PUSH
62496: LD_EXP 132
62500: PUSH
62501: LD_VAR 0 3
62505: ARRAY
62506: PUSH
62507: LD_INT 1
62509: PLUS
62510: PUSH
62511: EMPTY
62512: LIST
62513: LIST
62514: PPUSH
62515: LD_VAR 0 1
62519: PPUSH
62520: CALL 70507 0 3
62524: ST_TO_ADDR
// exit ;
62525: POP
62526: POP
62527: GO 62985
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
62529: LD_VAR 0 5
62533: PUSH
62534: LD_INT 0
62536: PUSH
62537: LD_INT 2
62539: PUSH
62540: LD_INT 4
62542: PUSH
62543: EMPTY
62544: LIST
62545: LIST
62546: LIST
62547: IN
62548: IFFALSE 62672
// begin if btype = b_armoury then
62550: LD_VAR 0 5
62554: PUSH
62555: LD_INT 4
62557: EQUAL
62558: IFFALSE 62568
// btype := b_barracks ;
62560: LD_ADDR_VAR 0 5
62564: PUSH
62565: LD_INT 5
62567: ST_TO_ADDR
// if btype = b_depot then
62568: LD_VAR 0 5
62572: PUSH
62573: LD_INT 0
62575: EQUAL
62576: IFFALSE 62586
// btype := b_warehouse ;
62578: LD_ADDR_VAR 0 5
62582: PUSH
62583: LD_INT 1
62585: ST_TO_ADDR
// if btype = b_workshop then
62586: LD_VAR 0 5
62590: PUSH
62591: LD_INT 2
62593: EQUAL
62594: IFFALSE 62604
// btype := b_factory ;
62596: LD_ADDR_VAR 0 5
62600: PUSH
62601: LD_INT 3
62603: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
62604: LD_VAR 0 5
62608: PPUSH
62609: LD_VAR 0 8
62613: PPUSH
62614: CALL_OW 323
62618: PUSH
62619: LD_INT 1
62621: EQUAL
62622: IFFALSE 62668
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
62624: LD_ADDR_EXP 131
62628: PUSH
62629: LD_EXP 131
62633: PPUSH
62634: LD_VAR 0 3
62638: PUSH
62639: LD_EXP 131
62643: PUSH
62644: LD_VAR 0 3
62648: ARRAY
62649: PUSH
62650: LD_INT 1
62652: PLUS
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: PPUSH
62658: LD_VAR 0 1
62662: PPUSH
62663: CALL 70507 0 3
62667: ST_TO_ADDR
// exit ;
62668: POP
62669: POP
62670: GO 62985
// end ; if btype in [ b_bunker , b_turret ] then
62672: LD_VAR 0 5
62676: PUSH
62677: LD_INT 32
62679: PUSH
62680: LD_INT 33
62682: PUSH
62683: EMPTY
62684: LIST
62685: LIST
62686: IN
62687: IFFALSE 62977
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
62689: LD_ADDR_EXP 107
62693: PUSH
62694: LD_EXP 107
62698: PPUSH
62699: LD_VAR 0 3
62703: PUSH
62704: LD_EXP 107
62708: PUSH
62709: LD_VAR 0 3
62713: ARRAY
62714: PUSH
62715: LD_INT 1
62717: PLUS
62718: PUSH
62719: EMPTY
62720: LIST
62721: LIST
62722: PPUSH
62723: LD_VAR 0 1
62727: PPUSH
62728: CALL 70507 0 3
62732: ST_TO_ADDR
// if btype = b_bunker then
62733: LD_VAR 0 5
62737: PUSH
62738: LD_INT 32
62740: EQUAL
62741: IFFALSE 62977
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62743: LD_ADDR_EXP 108
62747: PUSH
62748: LD_EXP 108
62752: PPUSH
62753: LD_VAR 0 3
62757: PUSH
62758: LD_EXP 108
62762: PUSH
62763: LD_VAR 0 3
62767: ARRAY
62768: PUSH
62769: LD_INT 1
62771: PLUS
62772: PUSH
62773: EMPTY
62774: LIST
62775: LIST
62776: PPUSH
62777: LD_VAR 0 1
62781: PPUSH
62782: CALL 70507 0 3
62786: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
62787: LD_ADDR_VAR 0 6
62791: PUSH
62792: LD_EXP 99
62796: PUSH
62797: LD_VAR 0 3
62801: ARRAY
62802: PPUSH
62803: LD_INT 25
62805: PUSH
62806: LD_INT 1
62808: PUSH
62809: EMPTY
62810: LIST
62811: LIST
62812: PUSH
62813: LD_INT 3
62815: PUSH
62816: LD_INT 54
62818: PUSH
62819: EMPTY
62820: LIST
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: PUSH
62826: EMPTY
62827: LIST
62828: LIST
62829: PPUSH
62830: CALL_OW 72
62834: ST_TO_ADDR
// if tmp then
62835: LD_VAR 0 6
62839: IFFALSE 62845
// exit ;
62841: POP
62842: POP
62843: GO 62985
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62845: LD_ADDR_VAR 0 6
62849: PUSH
62850: LD_EXP 99
62854: PUSH
62855: LD_VAR 0 3
62859: ARRAY
62860: PPUSH
62861: LD_INT 2
62863: PUSH
62864: LD_INT 30
62866: PUSH
62867: LD_INT 4
62869: PUSH
62870: EMPTY
62871: LIST
62872: LIST
62873: PUSH
62874: LD_INT 30
62876: PUSH
62877: LD_INT 5
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: PUSH
62884: EMPTY
62885: LIST
62886: LIST
62887: LIST
62888: PPUSH
62889: CALL_OW 72
62893: ST_TO_ADDR
// if not tmp then
62894: LD_VAR 0 6
62898: NOT
62899: IFFALSE 62905
// exit ;
62901: POP
62902: POP
62903: GO 62985
// for j in tmp do
62905: LD_ADDR_VAR 0 4
62909: PUSH
62910: LD_VAR 0 6
62914: PUSH
62915: FOR_IN
62916: IFFALSE 62975
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
62918: LD_ADDR_VAR 0 7
62922: PUSH
62923: LD_VAR 0 4
62927: PPUSH
62928: CALL_OW 313
62932: PPUSH
62933: LD_INT 25
62935: PUSH
62936: LD_INT 1
62938: PUSH
62939: EMPTY
62940: LIST
62941: LIST
62942: PPUSH
62943: CALL_OW 72
62947: ST_TO_ADDR
// if units then
62948: LD_VAR 0 7
62952: IFFALSE 62973
// begin ComExitBuilding ( units [ 1 ] ) ;
62954: LD_VAR 0 7
62958: PUSH
62959: LD_INT 1
62961: ARRAY
62962: PPUSH
62963: CALL_OW 122
// exit ;
62967: POP
62968: POP
62969: POP
62970: POP
62971: GO 62985
// end ; end ;
62973: GO 62915
62975: POP
62976: POP
// end ; end ; exit ;
62977: POP
62978: POP
62979: GO 62985
// end ; end ;
62981: GO 62339
62983: POP
62984: POP
// end ;
62985: LD_VAR 0 2
62989: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
62990: LD_INT 0
62992: PPUSH
62993: PPUSH
62994: PPUSH
62995: PPUSH
62996: PPUSH
62997: PPUSH
62998: PPUSH
// if not mc_bases or not skirmish then
62999: LD_EXP 99
63003: NOT
63004: PUSH
63005: LD_EXP 97
63009: NOT
63010: OR
63011: IFFALSE 63015
// exit ;
63013: GO 63246
// btype := GetBType ( building ) ;
63015: LD_ADDR_VAR 0 6
63019: PUSH
63020: LD_VAR 0 1
63024: PPUSH
63025: CALL_OW 266
63029: ST_TO_ADDR
// x := GetX ( building ) ;
63030: LD_ADDR_VAR 0 7
63034: PUSH
63035: LD_VAR 0 1
63039: PPUSH
63040: CALL_OW 250
63044: ST_TO_ADDR
// y := GetY ( building ) ;
63045: LD_ADDR_VAR 0 8
63049: PUSH
63050: LD_VAR 0 1
63054: PPUSH
63055: CALL_OW 251
63059: ST_TO_ADDR
// d := GetDir ( building ) ;
63060: LD_ADDR_VAR 0 9
63064: PUSH
63065: LD_VAR 0 1
63069: PPUSH
63070: CALL_OW 254
63074: ST_TO_ADDR
// for i = 1 to mc_bases do
63075: LD_ADDR_VAR 0 4
63079: PUSH
63080: DOUBLE
63081: LD_INT 1
63083: DEC
63084: ST_TO_ADDR
63085: LD_EXP 99
63089: PUSH
63090: FOR_TO
63091: IFFALSE 63244
// begin if not mc_build_list [ i ] then
63093: LD_EXP 104
63097: PUSH
63098: LD_VAR 0 4
63102: ARRAY
63103: NOT
63104: IFFALSE 63108
// continue ;
63106: GO 63090
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63108: LD_VAR 0 6
63112: PUSH
63113: LD_VAR 0 7
63117: PUSH
63118: LD_VAR 0 8
63122: PUSH
63123: LD_VAR 0 9
63127: PUSH
63128: EMPTY
63129: LIST
63130: LIST
63131: LIST
63132: LIST
63133: PPUSH
63134: LD_EXP 104
63138: PUSH
63139: LD_VAR 0 4
63143: ARRAY
63144: PUSH
63145: LD_INT 1
63147: ARRAY
63148: PPUSH
63149: CALL 76676 0 2
63153: IFFALSE 63242
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63155: LD_ADDR_EXP 104
63159: PUSH
63160: LD_EXP 104
63164: PPUSH
63165: LD_VAR 0 4
63169: PPUSH
63170: LD_EXP 104
63174: PUSH
63175: LD_VAR 0 4
63179: ARRAY
63180: PPUSH
63181: LD_INT 1
63183: PPUSH
63184: CALL_OW 3
63188: PPUSH
63189: CALL_OW 1
63193: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63194: LD_ADDR_EXP 106
63198: PUSH
63199: LD_EXP 106
63203: PPUSH
63204: LD_VAR 0 4
63208: PUSH
63209: LD_EXP 106
63213: PUSH
63214: LD_VAR 0 4
63218: ARRAY
63219: PUSH
63220: LD_INT 1
63222: PLUS
63223: PUSH
63224: EMPTY
63225: LIST
63226: LIST
63227: PPUSH
63228: LD_VAR 0 1
63232: PPUSH
63233: CALL 70507 0 3
63237: ST_TO_ADDR
// exit ;
63238: POP
63239: POP
63240: GO 63246
// end ; end ;
63242: GO 63090
63244: POP
63245: POP
// end ;
63246: LD_VAR 0 3
63250: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63251: LD_INT 0
63253: PPUSH
63254: PPUSH
63255: PPUSH
// if not mc_bases or not skirmish then
63256: LD_EXP 99
63260: NOT
63261: PUSH
63262: LD_EXP 97
63266: NOT
63267: OR
63268: IFFALSE 63272
// exit ;
63270: GO 63462
// for i = 1 to mc_bases do
63272: LD_ADDR_VAR 0 4
63276: PUSH
63277: DOUBLE
63278: LD_INT 1
63280: DEC
63281: ST_TO_ADDR
63282: LD_EXP 99
63286: PUSH
63287: FOR_TO
63288: IFFALSE 63375
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63290: LD_VAR 0 1
63294: PUSH
63295: LD_EXP 107
63299: PUSH
63300: LD_VAR 0 4
63304: ARRAY
63305: IN
63306: PUSH
63307: LD_VAR 0 1
63311: PUSH
63312: LD_EXP 108
63316: PUSH
63317: LD_VAR 0 4
63321: ARRAY
63322: IN
63323: NOT
63324: AND
63325: IFFALSE 63373
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63327: LD_ADDR_EXP 108
63331: PUSH
63332: LD_EXP 108
63336: PPUSH
63337: LD_VAR 0 4
63341: PUSH
63342: LD_EXP 108
63346: PUSH
63347: LD_VAR 0 4
63351: ARRAY
63352: PUSH
63353: LD_INT 1
63355: PLUS
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PPUSH
63361: LD_VAR 0 1
63365: PPUSH
63366: CALL 70507 0 3
63370: ST_TO_ADDR
// break ;
63371: GO 63375
// end ; end ;
63373: GO 63287
63375: POP
63376: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
63377: LD_VAR 0 1
63381: PPUSH
63382: CALL_OW 257
63386: PUSH
63387: LD_EXP 125
63391: IN
63392: PUSH
63393: LD_VAR 0 1
63397: PPUSH
63398: CALL_OW 266
63402: PUSH
63403: LD_INT 5
63405: EQUAL
63406: AND
63407: PUSH
63408: LD_VAR 0 2
63412: PPUSH
63413: CALL_OW 110
63417: PUSH
63418: LD_INT 18
63420: NONEQUAL
63421: AND
63422: IFFALSE 63462
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
63424: LD_VAR 0 2
63428: PPUSH
63429: CALL_OW 257
63433: PUSH
63434: LD_INT 5
63436: PUSH
63437: LD_INT 8
63439: PUSH
63440: LD_INT 9
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: LIST
63447: IN
63448: IFFALSE 63462
// SetClass ( unit , 1 ) ;
63450: LD_VAR 0 2
63454: PPUSH
63455: LD_INT 1
63457: PPUSH
63458: CALL_OW 336
// end ;
63462: LD_VAR 0 3
63466: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
63467: LD_INT 0
63469: PPUSH
63470: PPUSH
// if not mc_bases or not skirmish then
63471: LD_EXP 99
63475: NOT
63476: PUSH
63477: LD_EXP 97
63481: NOT
63482: OR
63483: IFFALSE 63487
// exit ;
63485: GO 63603
// if GetLives ( abandoned_vehicle ) > 250 then
63487: LD_VAR 0 2
63491: PPUSH
63492: CALL_OW 256
63496: PUSH
63497: LD_INT 250
63499: GREATER
63500: IFFALSE 63504
// exit ;
63502: GO 63603
// for i = 1 to mc_bases do
63504: LD_ADDR_VAR 0 6
63508: PUSH
63509: DOUBLE
63510: LD_INT 1
63512: DEC
63513: ST_TO_ADDR
63514: LD_EXP 99
63518: PUSH
63519: FOR_TO
63520: IFFALSE 63601
// begin if driver in mc_bases [ i ] then
63522: LD_VAR 0 1
63526: PUSH
63527: LD_EXP 99
63531: PUSH
63532: LD_VAR 0 6
63536: ARRAY
63537: IN
63538: IFFALSE 63599
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
63540: LD_VAR 0 1
63544: PPUSH
63545: LD_EXP 99
63549: PUSH
63550: LD_VAR 0 6
63554: ARRAY
63555: PPUSH
63556: LD_INT 2
63558: PUSH
63559: LD_INT 30
63561: PUSH
63562: LD_INT 0
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: PUSH
63569: LD_INT 30
63571: PUSH
63572: LD_INT 1
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: PUSH
63579: EMPTY
63580: LIST
63581: LIST
63582: LIST
63583: PPUSH
63584: CALL_OW 72
63588: PUSH
63589: LD_INT 1
63591: ARRAY
63592: PPUSH
63593: CALL_OW 112
// break ;
63597: GO 63601
// end ; end ;
63599: GO 63519
63601: POP
63602: POP
// end ; end_of_file
63603: LD_VAR 0 5
63607: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63608: LD_INT 0
63610: PPUSH
63611: PPUSH
// if exist_mode then
63612: LD_VAR 0 2
63616: IFFALSE 63641
// unit := CreateCharacter ( prefix & ident ) else
63618: LD_ADDR_VAR 0 5
63622: PUSH
63623: LD_VAR 0 3
63627: PUSH
63628: LD_VAR 0 1
63632: STR
63633: PPUSH
63634: CALL_OW 34
63638: ST_TO_ADDR
63639: GO 63656
// unit := NewCharacter ( ident ) ;
63641: LD_ADDR_VAR 0 5
63645: PUSH
63646: LD_VAR 0 1
63650: PPUSH
63651: CALL_OW 25
63655: ST_TO_ADDR
// result := unit ;
63656: LD_ADDR_VAR 0 4
63660: PUSH
63661: LD_VAR 0 5
63665: ST_TO_ADDR
// end ;
63666: LD_VAR 0 4
63670: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63671: LD_INT 0
63673: PPUSH
63674: PPUSH
// if not side or not nation then
63675: LD_VAR 0 1
63679: NOT
63680: PUSH
63681: LD_VAR 0 2
63685: NOT
63686: OR
63687: IFFALSE 63691
// exit ;
63689: GO 64335
// case nation of nation_american :
63691: LD_VAR 0 2
63695: PUSH
63696: LD_INT 1
63698: DOUBLE
63699: EQUAL
63700: IFTRUE 63704
63702: GO 63878
63704: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
63705: LD_ADDR_VAR 0 4
63709: PUSH
63710: LD_INT 35
63712: PUSH
63713: LD_INT 45
63715: PUSH
63716: LD_INT 46
63718: PUSH
63719: LD_INT 47
63721: PUSH
63722: LD_INT 1
63724: PUSH
63725: LD_INT 2
63727: PUSH
63728: LD_INT 6
63730: PUSH
63731: LD_INT 15
63733: PUSH
63734: LD_INT 16
63736: PUSH
63737: LD_INT 7
63739: PUSH
63740: LD_INT 12
63742: PUSH
63743: LD_INT 13
63745: PUSH
63746: LD_INT 10
63748: PUSH
63749: LD_INT 14
63751: PUSH
63752: LD_INT 20
63754: PUSH
63755: LD_INT 21
63757: PUSH
63758: LD_INT 22
63760: PUSH
63761: LD_INT 25
63763: PUSH
63764: LD_INT 32
63766: PUSH
63767: LD_INT 27
63769: PUSH
63770: LD_INT 36
63772: PUSH
63773: LD_INT 69
63775: PUSH
63776: LD_INT 39
63778: PUSH
63779: LD_INT 34
63781: PUSH
63782: LD_INT 40
63784: PUSH
63785: LD_INT 48
63787: PUSH
63788: LD_INT 49
63790: PUSH
63791: LD_INT 50
63793: PUSH
63794: LD_INT 51
63796: PUSH
63797: LD_INT 52
63799: PUSH
63800: LD_INT 53
63802: PUSH
63803: LD_INT 54
63805: PUSH
63806: LD_INT 55
63808: PUSH
63809: LD_INT 56
63811: PUSH
63812: LD_INT 57
63814: PUSH
63815: LD_INT 58
63817: PUSH
63818: LD_INT 59
63820: PUSH
63821: LD_INT 60
63823: PUSH
63824: LD_INT 61
63826: PUSH
63827: LD_INT 62
63829: PUSH
63830: LD_INT 80
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: LIST
63837: LIST
63838: LIST
63839: LIST
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: LIST
63873: LIST
63874: LIST
63875: ST_TO_ADDR
63876: GO 64259
63878: LD_INT 2
63880: DOUBLE
63881: EQUAL
63882: IFTRUE 63886
63884: GO 64068
63886: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
63887: LD_ADDR_VAR 0 4
63891: PUSH
63892: LD_INT 35
63894: PUSH
63895: LD_INT 45
63897: PUSH
63898: LD_INT 46
63900: PUSH
63901: LD_INT 47
63903: PUSH
63904: LD_INT 70
63906: PUSH
63907: LD_INT 1
63909: PUSH
63910: LD_INT 11
63912: PUSH
63913: LD_INT 3
63915: PUSH
63916: LD_INT 4
63918: PUSH
63919: LD_INT 5
63921: PUSH
63922: LD_INT 6
63924: PUSH
63925: LD_INT 15
63927: PUSH
63928: LD_INT 18
63930: PUSH
63931: LD_INT 7
63933: PUSH
63934: LD_INT 17
63936: PUSH
63937: LD_INT 8
63939: PUSH
63940: LD_INT 20
63942: PUSH
63943: LD_INT 21
63945: PUSH
63946: LD_INT 22
63948: PUSH
63949: LD_INT 72
63951: PUSH
63952: LD_INT 26
63954: PUSH
63955: LD_INT 69
63957: PUSH
63958: LD_INT 39
63960: PUSH
63961: LD_INT 40
63963: PUSH
63964: LD_INT 41
63966: PUSH
63967: LD_INT 42
63969: PUSH
63970: LD_INT 43
63972: PUSH
63973: LD_INT 48
63975: PUSH
63976: LD_INT 49
63978: PUSH
63979: LD_INT 50
63981: PUSH
63982: LD_INT 51
63984: PUSH
63985: LD_INT 52
63987: PUSH
63988: LD_INT 53
63990: PUSH
63991: LD_INT 54
63993: PUSH
63994: LD_INT 55
63996: PUSH
63997: LD_INT 56
63999: PUSH
64000: LD_INT 60
64002: PUSH
64003: LD_INT 61
64005: PUSH
64006: LD_INT 62
64008: PUSH
64009: LD_INT 66
64011: PUSH
64012: LD_INT 67
64014: PUSH
64015: LD_INT 68
64017: PUSH
64018: LD_INT 81
64020: PUSH
64021: EMPTY
64022: LIST
64023: LIST
64024: LIST
64025: LIST
64026: LIST
64027: LIST
64028: LIST
64029: LIST
64030: LIST
64031: LIST
64032: LIST
64033: LIST
64034: LIST
64035: LIST
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: LIST
64061: LIST
64062: LIST
64063: LIST
64064: LIST
64065: ST_TO_ADDR
64066: GO 64259
64068: LD_INT 3
64070: DOUBLE
64071: EQUAL
64072: IFTRUE 64076
64074: GO 64258
64076: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64077: LD_ADDR_VAR 0 4
64081: PUSH
64082: LD_INT 46
64084: PUSH
64085: LD_INT 47
64087: PUSH
64088: LD_INT 1
64090: PUSH
64091: LD_INT 2
64093: PUSH
64094: LD_INT 11
64096: PUSH
64097: LD_INT 9
64099: PUSH
64100: LD_INT 20
64102: PUSH
64103: LD_INT 19
64105: PUSH
64106: LD_INT 21
64108: PUSH
64109: LD_INT 24
64111: PUSH
64112: LD_INT 22
64114: PUSH
64115: LD_INT 25
64117: PUSH
64118: LD_INT 28
64120: PUSH
64121: LD_INT 29
64123: PUSH
64124: LD_INT 30
64126: PUSH
64127: LD_INT 31
64129: PUSH
64130: LD_INT 37
64132: PUSH
64133: LD_INT 38
64135: PUSH
64136: LD_INT 32
64138: PUSH
64139: LD_INT 27
64141: PUSH
64142: LD_INT 33
64144: PUSH
64145: LD_INT 69
64147: PUSH
64148: LD_INT 39
64150: PUSH
64151: LD_INT 34
64153: PUSH
64154: LD_INT 40
64156: PUSH
64157: LD_INT 71
64159: PUSH
64160: LD_INT 23
64162: PUSH
64163: LD_INT 44
64165: PUSH
64166: LD_INT 48
64168: PUSH
64169: LD_INT 49
64171: PUSH
64172: LD_INT 50
64174: PUSH
64175: LD_INT 51
64177: PUSH
64178: LD_INT 52
64180: PUSH
64181: LD_INT 53
64183: PUSH
64184: LD_INT 54
64186: PUSH
64187: LD_INT 55
64189: PUSH
64190: LD_INT 56
64192: PUSH
64193: LD_INT 57
64195: PUSH
64196: LD_INT 58
64198: PUSH
64199: LD_INT 59
64201: PUSH
64202: LD_INT 63
64204: PUSH
64205: LD_INT 64
64207: PUSH
64208: LD_INT 65
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: LIST
64215: LIST
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: LIST
64255: ST_TO_ADDR
64256: GO 64259
64258: POP
// if state > - 1 and state < 3 then
64259: LD_VAR 0 3
64263: PUSH
64264: LD_INT 1
64266: NEG
64267: GREATER
64268: PUSH
64269: LD_VAR 0 3
64273: PUSH
64274: LD_INT 3
64276: LESS
64277: AND
64278: IFFALSE 64335
// for i in result do
64280: LD_ADDR_VAR 0 5
64284: PUSH
64285: LD_VAR 0 4
64289: PUSH
64290: FOR_IN
64291: IFFALSE 64333
// if GetTech ( i , side ) <> state then
64293: LD_VAR 0 5
64297: PPUSH
64298: LD_VAR 0 1
64302: PPUSH
64303: CALL_OW 321
64307: PUSH
64308: LD_VAR 0 3
64312: NONEQUAL
64313: IFFALSE 64331
// result := result diff i ;
64315: LD_ADDR_VAR 0 4
64319: PUSH
64320: LD_VAR 0 4
64324: PUSH
64325: LD_VAR 0 5
64329: DIFF
64330: ST_TO_ADDR
64331: GO 64290
64333: POP
64334: POP
// end ;
64335: LD_VAR 0 4
64339: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64340: LD_INT 0
64342: PPUSH
64343: PPUSH
64344: PPUSH
// result := true ;
64345: LD_ADDR_VAR 0 3
64349: PUSH
64350: LD_INT 1
64352: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64353: LD_ADDR_VAR 0 5
64357: PUSH
64358: LD_VAR 0 2
64362: PPUSH
64363: CALL_OW 480
64367: ST_TO_ADDR
// if not tmp then
64368: LD_VAR 0 5
64372: NOT
64373: IFFALSE 64377
// exit ;
64375: GO 64426
// for i in tmp do
64377: LD_ADDR_VAR 0 4
64381: PUSH
64382: LD_VAR 0 5
64386: PUSH
64387: FOR_IN
64388: IFFALSE 64424
// if GetTech ( i , side ) <> state_researched then
64390: LD_VAR 0 4
64394: PPUSH
64395: LD_VAR 0 1
64399: PPUSH
64400: CALL_OW 321
64404: PUSH
64405: LD_INT 2
64407: NONEQUAL
64408: IFFALSE 64422
// begin result := false ;
64410: LD_ADDR_VAR 0 3
64414: PUSH
64415: LD_INT 0
64417: ST_TO_ADDR
// exit ;
64418: POP
64419: POP
64420: GO 64426
// end ;
64422: GO 64387
64424: POP
64425: POP
// end ;
64426: LD_VAR 0 3
64430: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64431: LD_INT 0
64433: PPUSH
64434: PPUSH
64435: PPUSH
64436: PPUSH
64437: PPUSH
64438: PPUSH
64439: PPUSH
64440: PPUSH
64441: PPUSH
64442: PPUSH
64443: PPUSH
64444: PPUSH
64445: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64446: LD_VAR 0 1
64450: NOT
64451: PUSH
64452: LD_VAR 0 1
64456: PPUSH
64457: CALL_OW 257
64461: PUSH
64462: LD_INT 9
64464: NONEQUAL
64465: OR
64466: IFFALSE 64470
// exit ;
64468: GO 65043
// side := GetSide ( unit ) ;
64470: LD_ADDR_VAR 0 9
64474: PUSH
64475: LD_VAR 0 1
64479: PPUSH
64480: CALL_OW 255
64484: ST_TO_ADDR
// tech_space := tech_spacanom ;
64485: LD_ADDR_VAR 0 12
64489: PUSH
64490: LD_INT 29
64492: ST_TO_ADDR
// tech_time := tech_taurad ;
64493: LD_ADDR_VAR 0 13
64497: PUSH
64498: LD_INT 28
64500: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64501: LD_ADDR_VAR 0 11
64505: PUSH
64506: LD_VAR 0 1
64510: PPUSH
64511: CALL_OW 310
64515: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64516: LD_VAR 0 11
64520: PPUSH
64521: CALL_OW 247
64525: PUSH
64526: LD_INT 2
64528: EQUAL
64529: IFFALSE 64533
// exit ;
64531: GO 65043
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64533: LD_ADDR_VAR 0 8
64537: PUSH
64538: LD_INT 81
64540: PUSH
64541: LD_VAR 0 9
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 3
64552: PUSH
64553: LD_INT 21
64555: PUSH
64556: LD_INT 3
64558: PUSH
64559: EMPTY
64560: LIST
64561: LIST
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PPUSH
64571: CALL_OW 69
64575: ST_TO_ADDR
// if not tmp then
64576: LD_VAR 0 8
64580: NOT
64581: IFFALSE 64585
// exit ;
64583: GO 65043
// if in_unit then
64585: LD_VAR 0 11
64589: IFFALSE 64613
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64591: LD_ADDR_VAR 0 10
64595: PUSH
64596: LD_VAR 0 8
64600: PPUSH
64601: LD_VAR 0 11
64605: PPUSH
64606: CALL_OW 74
64610: ST_TO_ADDR
64611: GO 64633
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64613: LD_ADDR_VAR 0 10
64617: PUSH
64618: LD_VAR 0 8
64622: PPUSH
64623: LD_VAR 0 1
64627: PPUSH
64628: CALL_OW 74
64632: ST_TO_ADDR
// if not enemy then
64633: LD_VAR 0 10
64637: NOT
64638: IFFALSE 64642
// exit ;
64640: GO 65043
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64642: LD_VAR 0 11
64646: PUSH
64647: LD_VAR 0 11
64651: PPUSH
64652: LD_VAR 0 10
64656: PPUSH
64657: CALL_OW 296
64661: PUSH
64662: LD_INT 13
64664: GREATER
64665: AND
64666: PUSH
64667: LD_VAR 0 1
64671: PPUSH
64672: LD_VAR 0 10
64676: PPUSH
64677: CALL_OW 296
64681: PUSH
64682: LD_INT 12
64684: GREATER
64685: OR
64686: IFFALSE 64690
// exit ;
64688: GO 65043
// missile := [ 1 ] ;
64690: LD_ADDR_VAR 0 14
64694: PUSH
64695: LD_INT 1
64697: PUSH
64698: EMPTY
64699: LIST
64700: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64701: LD_VAR 0 9
64705: PPUSH
64706: LD_VAR 0 12
64710: PPUSH
64711: CALL_OW 325
64715: IFFALSE 64744
// missile := Insert ( missile , missile + 1 , 2 ) ;
64717: LD_ADDR_VAR 0 14
64721: PUSH
64722: LD_VAR 0 14
64726: PPUSH
64727: LD_VAR 0 14
64731: PUSH
64732: LD_INT 1
64734: PLUS
64735: PPUSH
64736: LD_INT 2
64738: PPUSH
64739: CALL_OW 2
64743: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64744: LD_VAR 0 9
64748: PPUSH
64749: LD_VAR 0 13
64753: PPUSH
64754: CALL_OW 325
64758: PUSH
64759: LD_VAR 0 10
64763: PPUSH
64764: CALL_OW 255
64768: PPUSH
64769: LD_VAR 0 13
64773: PPUSH
64774: CALL_OW 325
64778: NOT
64779: AND
64780: IFFALSE 64809
// missile := Insert ( missile , missile + 1 , 3 ) ;
64782: LD_ADDR_VAR 0 14
64786: PUSH
64787: LD_VAR 0 14
64791: PPUSH
64792: LD_VAR 0 14
64796: PUSH
64797: LD_INT 1
64799: PLUS
64800: PPUSH
64801: LD_INT 3
64803: PPUSH
64804: CALL_OW 2
64808: ST_TO_ADDR
// if missile < 2 then
64809: LD_VAR 0 14
64813: PUSH
64814: LD_INT 2
64816: LESS
64817: IFFALSE 64821
// exit ;
64819: GO 65043
// x := GetX ( enemy ) ;
64821: LD_ADDR_VAR 0 4
64825: PUSH
64826: LD_VAR 0 10
64830: PPUSH
64831: CALL_OW 250
64835: ST_TO_ADDR
// y := GetY ( enemy ) ;
64836: LD_ADDR_VAR 0 5
64840: PUSH
64841: LD_VAR 0 10
64845: PPUSH
64846: CALL_OW 251
64850: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64851: LD_ADDR_VAR 0 6
64855: PUSH
64856: LD_VAR 0 4
64860: PUSH
64861: LD_INT 1
64863: NEG
64864: PPUSH
64865: LD_INT 1
64867: PPUSH
64868: CALL_OW 12
64872: PLUS
64873: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64874: LD_ADDR_VAR 0 7
64878: PUSH
64879: LD_VAR 0 5
64883: PUSH
64884: LD_INT 1
64886: NEG
64887: PPUSH
64888: LD_INT 1
64890: PPUSH
64891: CALL_OW 12
64895: PLUS
64896: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64897: LD_VAR 0 6
64901: PPUSH
64902: LD_VAR 0 7
64906: PPUSH
64907: CALL_OW 488
64911: NOT
64912: IFFALSE 64934
// begin _x := x ;
64914: LD_ADDR_VAR 0 6
64918: PUSH
64919: LD_VAR 0 4
64923: ST_TO_ADDR
// _y := y ;
64924: LD_ADDR_VAR 0 7
64928: PUSH
64929: LD_VAR 0 5
64933: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64934: LD_ADDR_VAR 0 3
64938: PUSH
64939: LD_INT 1
64941: PPUSH
64942: LD_VAR 0 14
64946: PPUSH
64947: CALL_OW 12
64951: ST_TO_ADDR
// case i of 1 :
64952: LD_VAR 0 3
64956: PUSH
64957: LD_INT 1
64959: DOUBLE
64960: EQUAL
64961: IFTRUE 64965
64963: GO 64982
64965: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64966: LD_VAR 0 1
64970: PPUSH
64971: LD_VAR 0 10
64975: PPUSH
64976: CALL_OW 115
64980: GO 65043
64982: LD_INT 2
64984: DOUBLE
64985: EQUAL
64986: IFTRUE 64990
64988: GO 65012
64990: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64991: LD_VAR 0 1
64995: PPUSH
64996: LD_VAR 0 6
65000: PPUSH
65001: LD_VAR 0 7
65005: PPUSH
65006: CALL_OW 153
65010: GO 65043
65012: LD_INT 3
65014: DOUBLE
65015: EQUAL
65016: IFTRUE 65020
65018: GO 65042
65020: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65021: LD_VAR 0 1
65025: PPUSH
65026: LD_VAR 0 6
65030: PPUSH
65031: LD_VAR 0 7
65035: PPUSH
65036: CALL_OW 154
65040: GO 65043
65042: POP
// end ;
65043: LD_VAR 0 2
65047: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65048: LD_INT 0
65050: PPUSH
65051: PPUSH
65052: PPUSH
65053: PPUSH
65054: PPUSH
65055: PPUSH
// if not unit or not building then
65056: LD_VAR 0 1
65060: NOT
65061: PUSH
65062: LD_VAR 0 2
65066: NOT
65067: OR
65068: IFFALSE 65072
// exit ;
65070: GO 65230
// x := GetX ( building ) ;
65072: LD_ADDR_VAR 0 5
65076: PUSH
65077: LD_VAR 0 2
65081: PPUSH
65082: CALL_OW 250
65086: ST_TO_ADDR
// y := GetY ( building ) ;
65087: LD_ADDR_VAR 0 6
65091: PUSH
65092: LD_VAR 0 2
65096: PPUSH
65097: CALL_OW 251
65101: ST_TO_ADDR
// for i = 0 to 5 do
65102: LD_ADDR_VAR 0 4
65106: PUSH
65107: DOUBLE
65108: LD_INT 0
65110: DEC
65111: ST_TO_ADDR
65112: LD_INT 5
65114: PUSH
65115: FOR_TO
65116: IFFALSE 65228
// begin _x := ShiftX ( x , i , 3 ) ;
65118: LD_ADDR_VAR 0 7
65122: PUSH
65123: LD_VAR 0 5
65127: PPUSH
65128: LD_VAR 0 4
65132: PPUSH
65133: LD_INT 3
65135: PPUSH
65136: CALL_OW 272
65140: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65141: LD_ADDR_VAR 0 8
65145: PUSH
65146: LD_VAR 0 6
65150: PPUSH
65151: LD_VAR 0 4
65155: PPUSH
65156: LD_INT 3
65158: PPUSH
65159: CALL_OW 273
65163: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65164: LD_VAR 0 7
65168: PPUSH
65169: LD_VAR 0 8
65173: PPUSH
65174: CALL_OW 488
65178: NOT
65179: IFFALSE 65183
// continue ;
65181: GO 65115
// if HexInfo ( _x , _y ) = 0 then
65183: LD_VAR 0 7
65187: PPUSH
65188: LD_VAR 0 8
65192: PPUSH
65193: CALL_OW 428
65197: PUSH
65198: LD_INT 0
65200: EQUAL
65201: IFFALSE 65226
// begin ComMoveXY ( unit , _x , _y ) ;
65203: LD_VAR 0 1
65207: PPUSH
65208: LD_VAR 0 7
65212: PPUSH
65213: LD_VAR 0 8
65217: PPUSH
65218: CALL_OW 111
// exit ;
65222: POP
65223: POP
65224: GO 65230
// end ; end ;
65226: GO 65115
65228: POP
65229: POP
// end ;
65230: LD_VAR 0 3
65234: RET
// export function ScanBase ( side , base_area ) ; begin
65235: LD_INT 0
65237: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65238: LD_ADDR_VAR 0 3
65242: PUSH
65243: LD_VAR 0 2
65247: PPUSH
65248: LD_INT 81
65250: PUSH
65251: LD_VAR 0 1
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: PPUSH
65260: CALL_OW 70
65264: ST_TO_ADDR
// end ;
65265: LD_VAR 0 3
65269: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65270: LD_INT 0
65272: PPUSH
65273: PPUSH
65274: PPUSH
65275: PPUSH
65276: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65277: LD_VAR 0 1
65281: NOT
65282: PUSH
65283: LD_EXP 99
65287: PUSH
65288: LD_VAR 0 1
65292: ARRAY
65293: NOT
65294: OR
65295: PUSH
65296: LD_VAR 0 2
65300: NOT
65301: OR
65302: PUSH
65303: LD_VAR 0 3
65307: NOT
65308: OR
65309: IFFALSE 65313
// exit ;
65311: GO 65763
// side := mc_sides [ base ] ;
65313: LD_ADDR_VAR 0 6
65317: PUSH
65318: LD_EXP 125
65322: PUSH
65323: LD_VAR 0 1
65327: ARRAY
65328: ST_TO_ADDR
// if not side then
65329: LD_VAR 0 6
65333: NOT
65334: IFFALSE 65338
// exit ;
65336: GO 65763
// for i in solds do
65338: LD_ADDR_VAR 0 7
65342: PUSH
65343: LD_VAR 0 2
65347: PUSH
65348: FOR_IN
65349: IFFALSE 65410
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
65351: LD_VAR 0 7
65355: PPUSH
65356: CALL_OW 310
65360: PPUSH
65361: CALL_OW 266
65365: PUSH
65366: LD_INT 32
65368: PUSH
65369: LD_INT 31
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: IN
65376: IFFALSE 65396
// solds := solds diff i else
65378: LD_ADDR_VAR 0 2
65382: PUSH
65383: LD_VAR 0 2
65387: PUSH
65388: LD_VAR 0 7
65392: DIFF
65393: ST_TO_ADDR
65394: GO 65408
// SetTag ( i , 18 ) ;
65396: LD_VAR 0 7
65400: PPUSH
65401: LD_INT 18
65403: PPUSH
65404: CALL_OW 109
65408: GO 65348
65410: POP
65411: POP
// if not solds then
65412: LD_VAR 0 2
65416: NOT
65417: IFFALSE 65421
// exit ;
65419: GO 65763
// repeat wait ( 0 0$1 ) ;
65421: LD_INT 35
65423: PPUSH
65424: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
65428: LD_ADDR_VAR 0 5
65432: PUSH
65433: LD_VAR 0 6
65437: PPUSH
65438: LD_VAR 0 3
65442: PPUSH
65443: CALL 65235 0 2
65447: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
65448: LD_VAR 0 5
65452: NOT
65453: PUSH
65454: LD_VAR 0 5
65458: PUSH
65459: LD_INT 3
65461: GREATER
65462: OR
65463: PUSH
65464: LD_EXP 121
65468: PUSH
65469: LD_VAR 0 1
65473: ARRAY
65474: OR
65475: IFFALSE 65516
// begin for i in solds do
65477: LD_ADDR_VAR 0 7
65481: PUSH
65482: LD_VAR 0 2
65486: PUSH
65487: FOR_IN
65488: IFFALSE 65512
// if HasTask ( i ) then
65490: LD_VAR 0 7
65494: PPUSH
65495: CALL_OW 314
65499: IFFALSE 65510
// ComStop ( i ) ;
65501: LD_VAR 0 7
65505: PPUSH
65506: CALL_OW 141
65510: GO 65487
65512: POP
65513: POP
// break ;
65514: GO 65751
// end ; for i in solds do
65516: LD_ADDR_VAR 0 7
65520: PUSH
65521: LD_VAR 0 2
65525: PUSH
65526: FOR_IN
65527: IFFALSE 65743
// begin if IsInUnit ( i ) then
65529: LD_VAR 0 7
65533: PPUSH
65534: CALL_OW 310
65538: IFFALSE 65549
// ComExitBuilding ( i ) ;
65540: LD_VAR 0 7
65544: PPUSH
65545: CALL_OW 122
// if GetLives ( i ) > 333 then
65549: LD_VAR 0 7
65553: PPUSH
65554: CALL_OW 256
65558: PUSH
65559: LD_INT 333
65561: GREATER
65562: IFFALSE 65590
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
65564: LD_VAR 0 7
65568: PPUSH
65569: LD_VAR 0 5
65573: PPUSH
65574: LD_VAR 0 7
65578: PPUSH
65579: CALL_OW 74
65583: PPUSH
65584: CALL_OW 115
65588: GO 65741
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
65590: LD_ADDR_VAR 0 8
65594: PUSH
65595: LD_EXP 99
65599: PUSH
65600: LD_VAR 0 1
65604: ARRAY
65605: PPUSH
65606: LD_INT 2
65608: PUSH
65609: LD_INT 30
65611: PUSH
65612: LD_INT 0
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: PUSH
65619: LD_INT 30
65621: PUSH
65622: LD_INT 1
65624: PUSH
65625: EMPTY
65626: LIST
65627: LIST
65628: PUSH
65629: LD_INT 30
65631: PUSH
65632: LD_INT 6
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: LIST
65643: LIST
65644: PPUSH
65645: CALL_OW 72
65649: PPUSH
65650: LD_VAR 0 7
65654: PPUSH
65655: CALL_OW 74
65659: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
65660: LD_VAR 0 7
65664: PPUSH
65665: LD_VAR 0 8
65669: PPUSH
65670: CALL_OW 250
65674: PPUSH
65675: LD_INT 3
65677: PPUSH
65678: LD_INT 5
65680: PPUSH
65681: CALL_OW 272
65685: PPUSH
65686: LD_VAR 0 8
65690: PPUSH
65691: CALL_OW 251
65695: PPUSH
65696: LD_INT 3
65698: PPUSH
65699: LD_INT 5
65701: PPUSH
65702: CALL_OW 273
65706: PPUSH
65707: CALL_OW 111
// SetTag ( i , 0 ) ;
65711: LD_VAR 0 7
65715: PPUSH
65716: LD_INT 0
65718: PPUSH
65719: CALL_OW 109
// solds := solds diff i ;
65723: LD_ADDR_VAR 0 2
65727: PUSH
65728: LD_VAR 0 2
65732: PUSH
65733: LD_VAR 0 7
65737: DIFF
65738: ST_TO_ADDR
// continue ;
65739: GO 65526
// end ; end ;
65741: GO 65526
65743: POP
65744: POP
// until solds ;
65745: LD_VAR 0 2
65749: IFFALSE 65421
// MC_Reset ( base , 18 ) ;
65751: LD_VAR 0 1
65755: PPUSH
65756: LD_INT 18
65758: PPUSH
65759: CALL 37893 0 2
// end ;
65763: LD_VAR 0 4
65767: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
65768: LD_INT 0
65770: PPUSH
65771: PPUSH
65772: PPUSH
65773: PPUSH
65774: PPUSH
65775: PPUSH
65776: PPUSH
65777: PPUSH
65778: PPUSH
65779: PPUSH
65780: PPUSH
65781: PPUSH
65782: PPUSH
65783: PPUSH
65784: PPUSH
65785: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65786: LD_ADDR_VAR 0 12
65790: PUSH
65791: LD_EXP 99
65795: PUSH
65796: LD_VAR 0 1
65800: ARRAY
65801: PPUSH
65802: LD_INT 25
65804: PUSH
65805: LD_INT 3
65807: PUSH
65808: EMPTY
65809: LIST
65810: LIST
65811: PPUSH
65812: CALL_OW 72
65816: ST_TO_ADDR
// if mc_remote_driver [ base ] then
65817: LD_EXP 139
65821: PUSH
65822: LD_VAR 0 1
65826: ARRAY
65827: IFFALSE 65851
// mechs := mechs diff mc_remote_driver [ base ] ;
65829: LD_ADDR_VAR 0 12
65833: PUSH
65834: LD_VAR 0 12
65838: PUSH
65839: LD_EXP 139
65843: PUSH
65844: LD_VAR 0 1
65848: ARRAY
65849: DIFF
65850: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65851: LD_ADDR_VAR 0 8
65855: PUSH
65856: LD_EXP 99
65860: PUSH
65861: LD_VAR 0 1
65865: ARRAY
65866: PPUSH
65867: LD_INT 2
65869: PUSH
65870: LD_INT 25
65872: PUSH
65873: LD_INT 1
65875: PUSH
65876: EMPTY
65877: LIST
65878: LIST
65879: PUSH
65880: LD_INT 25
65882: PUSH
65883: LD_INT 5
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: PUSH
65890: LD_INT 25
65892: PUSH
65893: LD_INT 8
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: LD_INT 25
65902: PUSH
65903: LD_INT 9
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: PUSH
65910: EMPTY
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: PPUSH
65917: CALL_OW 72
65921: ST_TO_ADDR
// if not defenders and not solds then
65922: LD_VAR 0 2
65926: NOT
65927: PUSH
65928: LD_VAR 0 8
65932: NOT
65933: AND
65934: IFFALSE 65938
// exit ;
65936: GO 67338
// depot_under_attack := false ;
65938: LD_ADDR_VAR 0 16
65942: PUSH
65943: LD_INT 0
65945: ST_TO_ADDR
// sold_defenders := [ ] ;
65946: LD_ADDR_VAR 0 17
65950: PUSH
65951: EMPTY
65952: ST_TO_ADDR
// if mechs then
65953: LD_VAR 0 12
65957: IFFALSE 66086
// for i in defenders do
65959: LD_ADDR_VAR 0 5
65963: PUSH
65964: LD_VAR 0 2
65968: PUSH
65969: FOR_IN
65970: IFFALSE 66084
// begin SetTag ( i , 20 ) ;
65972: LD_VAR 0 5
65976: PPUSH
65977: LD_INT 20
65979: PPUSH
65980: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
65984: LD_VAR 0 5
65988: PPUSH
65989: CALL_OW 263
65993: PUSH
65994: LD_INT 1
65996: EQUAL
65997: PUSH
65998: LD_VAR 0 5
66002: PPUSH
66003: CALL_OW 311
66007: NOT
66008: AND
66009: PUSH
66010: LD_VAR 0 12
66014: AND
66015: IFFALSE 66082
// begin un := mechs [ 1 ] ;
66017: LD_ADDR_VAR 0 10
66021: PUSH
66022: LD_VAR 0 12
66026: PUSH
66027: LD_INT 1
66029: ARRAY
66030: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66031: LD_VAR 0 10
66035: PPUSH
66036: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66040: LD_VAR 0 10
66044: PPUSH
66045: LD_VAR 0 5
66049: PPUSH
66050: CALL_OW 180
// SetTag ( un , 19 ) ;
66054: LD_VAR 0 10
66058: PPUSH
66059: LD_INT 19
66061: PPUSH
66062: CALL_OW 109
// mechs := mechs diff un ;
66066: LD_ADDR_VAR 0 12
66070: PUSH
66071: LD_VAR 0 12
66075: PUSH
66076: LD_VAR 0 10
66080: DIFF
66081: ST_TO_ADDR
// end ; end ;
66082: GO 65969
66084: POP
66085: POP
// if solds then
66086: LD_VAR 0 8
66090: IFFALSE 66149
// for i in solds do
66092: LD_ADDR_VAR 0 5
66096: PUSH
66097: LD_VAR 0 8
66101: PUSH
66102: FOR_IN
66103: IFFALSE 66147
// if not GetTag ( i ) then
66105: LD_VAR 0 5
66109: PPUSH
66110: CALL_OW 110
66114: NOT
66115: IFFALSE 66145
// begin defenders := defenders union i ;
66117: LD_ADDR_VAR 0 2
66121: PUSH
66122: LD_VAR 0 2
66126: PUSH
66127: LD_VAR 0 5
66131: UNION
66132: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66133: LD_VAR 0 5
66137: PPUSH
66138: LD_INT 18
66140: PPUSH
66141: CALL_OW 109
// end ;
66145: GO 66102
66147: POP
66148: POP
// repeat wait ( 0 0$1 ) ;
66149: LD_INT 35
66151: PPUSH
66152: CALL_OW 67
// enemy := mc_scan [ base ] ;
66156: LD_ADDR_VAR 0 3
66160: PUSH
66161: LD_EXP 122
66165: PUSH
66166: LD_VAR 0 1
66170: ARRAY
66171: ST_TO_ADDR
// for i in defenders do
66172: LD_ADDR_VAR 0 5
66176: PUSH
66177: LD_VAR 0 2
66181: PUSH
66182: FOR_IN
66183: IFFALSE 66913
// begin e := NearestUnitToUnit ( enemy , i ) ;
66185: LD_ADDR_VAR 0 13
66189: PUSH
66190: LD_VAR 0 3
66194: PPUSH
66195: LD_VAR 0 5
66199: PPUSH
66200: CALL_OW 74
66204: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
66205: LD_ADDR_VAR 0 16
66209: PUSH
66210: LD_EXP 99
66214: PUSH
66215: LD_VAR 0 1
66219: ARRAY
66220: PPUSH
66221: LD_INT 2
66223: PUSH
66224: LD_INT 30
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 30
66236: PUSH
66237: LD_INT 1
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: EMPTY
66245: LIST
66246: LIST
66247: LIST
66248: PPUSH
66249: CALL_OW 72
66253: NOT
66254: PUSH
66255: LD_EXP 99
66259: PUSH
66260: LD_VAR 0 1
66264: ARRAY
66265: PPUSH
66266: LD_INT 2
66268: PUSH
66269: LD_INT 30
66271: PUSH
66272: LD_INT 0
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: LD_INT 30
66281: PUSH
66282: LD_INT 1
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: LIST
66293: PPUSH
66294: CALL_OW 72
66298: PPUSH
66299: CALL_OW 256
66303: PUSH
66304: LD_INT 600
66306: LESS
66307: OR
66308: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
66309: LD_VAR 0 5
66313: PPUSH
66314: CALL_OW 247
66318: PUSH
66319: LD_INT 2
66321: DOUBLE
66322: EQUAL
66323: IFTRUE 66327
66325: GO 66619
66327: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
66328: LD_VAR 0 5
66332: PPUSH
66333: CALL_OW 256
66337: PUSH
66338: LD_INT 650
66340: GREATER
66341: PUSH
66342: LD_VAR 0 5
66346: PPUSH
66347: LD_VAR 0 13
66351: PPUSH
66352: CALL_OW 296
66356: PUSH
66357: LD_INT 40
66359: LESS
66360: PUSH
66361: LD_VAR 0 13
66365: PPUSH
66366: LD_EXP 124
66370: PUSH
66371: LD_VAR 0 1
66375: ARRAY
66376: PPUSH
66377: CALL_OW 308
66381: OR
66382: AND
66383: IFFALSE 66401
// ComAttackUnit ( i , e ) else
66385: LD_VAR 0 5
66389: PPUSH
66390: LD_VAR 0 13
66394: PPUSH
66395: CALL_OW 115
66399: GO 66502
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
66401: LD_VAR 0 13
66405: PPUSH
66406: LD_EXP 124
66410: PUSH
66411: LD_VAR 0 1
66415: ARRAY
66416: PPUSH
66417: CALL_OW 308
66421: NOT
66422: PUSH
66423: LD_VAR 0 5
66427: PPUSH
66428: LD_VAR 0 13
66432: PPUSH
66433: CALL_OW 296
66437: PUSH
66438: LD_INT 40
66440: GREATEREQUAL
66441: AND
66442: PUSH
66443: LD_VAR 0 5
66447: PPUSH
66448: CALL_OW 256
66452: PUSH
66453: LD_INT 650
66455: LESSEQUAL
66456: OR
66457: PUSH
66458: LD_VAR 0 5
66462: PPUSH
66463: LD_EXP 123
66467: PUSH
66468: LD_VAR 0 1
66472: ARRAY
66473: PPUSH
66474: CALL_OW 308
66478: NOT
66479: AND
66480: IFFALSE 66502
// ComMoveToArea ( i , mc_parking [ base ] ) ;
66482: LD_VAR 0 5
66486: PPUSH
66487: LD_EXP 123
66491: PUSH
66492: LD_VAR 0 1
66496: ARRAY
66497: PPUSH
66498: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
66502: LD_VAR 0 5
66506: PPUSH
66507: CALL_OW 256
66511: PUSH
66512: LD_INT 998
66514: LESS
66515: PUSH
66516: LD_VAR 0 5
66520: PPUSH
66521: CALL_OW 263
66525: PUSH
66526: LD_INT 1
66528: EQUAL
66529: AND
66530: PUSH
66531: LD_VAR 0 5
66535: PPUSH
66536: CALL_OW 311
66540: AND
66541: PUSH
66542: LD_VAR 0 5
66546: PPUSH
66547: LD_EXP 123
66551: PUSH
66552: LD_VAR 0 1
66556: ARRAY
66557: PPUSH
66558: CALL_OW 308
66562: AND
66563: IFFALSE 66617
// begin mech := IsDrivenBy ( i ) ;
66565: LD_ADDR_VAR 0 9
66569: PUSH
66570: LD_VAR 0 5
66574: PPUSH
66575: CALL_OW 311
66579: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
66580: LD_VAR 0 9
66584: PPUSH
66585: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
66589: LD_VAR 0 9
66593: PPUSH
66594: LD_VAR 0 5
66598: PPUSH
66599: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
66603: LD_VAR 0 9
66607: PPUSH
66608: LD_VAR 0 5
66612: PPUSH
66613: CALL_OW 180
// end ; end ; unit_human :
66617: GO 66884
66619: LD_INT 1
66621: DOUBLE
66622: EQUAL
66623: IFTRUE 66627
66625: GO 66883
66627: POP
// begin b := IsInUnit ( i ) ;
66628: LD_ADDR_VAR 0 18
66632: PUSH
66633: LD_VAR 0 5
66637: PPUSH
66638: CALL_OW 310
66642: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
66643: LD_ADDR_VAR 0 19
66647: PUSH
66648: LD_VAR 0 18
66652: NOT
66653: PUSH
66654: LD_VAR 0 18
66658: PPUSH
66659: CALL_OW 266
66663: PUSH
66664: LD_INT 32
66666: PUSH
66667: LD_INT 31
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: IN
66674: OR
66675: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
66676: LD_VAR 0 16
66680: PUSH
66681: LD_VAR 0 2
66685: PPUSH
66686: LD_INT 21
66688: PUSH
66689: LD_INT 2
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PPUSH
66696: CALL_OW 72
66700: PUSH
66701: LD_INT 1
66703: LESSEQUAL
66704: OR
66705: PUSH
66706: LD_VAR 0 19
66710: AND
66711: PUSH
66712: LD_VAR 0 5
66716: PUSH
66717: LD_VAR 0 17
66721: IN
66722: NOT
66723: AND
66724: IFFALSE 66817
// begin if b then
66726: LD_VAR 0 18
66730: IFFALSE 66779
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
66732: LD_VAR 0 18
66736: PPUSH
66737: LD_VAR 0 3
66741: PPUSH
66742: LD_VAR 0 18
66746: PPUSH
66747: CALL_OW 74
66751: PPUSH
66752: CALL_OW 296
66756: PUSH
66757: LD_INT 10
66759: LESS
66760: PUSH
66761: LD_VAR 0 18
66765: PPUSH
66766: CALL_OW 461
66770: PUSH
66771: LD_INT 7
66773: NONEQUAL
66774: AND
66775: IFFALSE 66779
// continue ;
66777: GO 66182
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
66779: LD_ADDR_VAR 0 17
66783: PUSH
66784: LD_VAR 0 17
66788: PPUSH
66789: LD_VAR 0 17
66793: PUSH
66794: LD_INT 1
66796: PLUS
66797: PPUSH
66798: LD_VAR 0 5
66802: PPUSH
66803: CALL_OW 1
66807: ST_TO_ADDR
// ComExitBuilding ( i ) ;
66808: LD_VAR 0 5
66812: PPUSH
66813: CALL_OW 122
// end ; if sold_defenders then
66817: LD_VAR 0 17
66821: IFFALSE 66881
// if i in sold_defenders then
66823: LD_VAR 0 5
66827: PUSH
66828: LD_VAR 0 17
66832: IN
66833: IFFALSE 66881
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
66835: LD_VAR 0 5
66839: PPUSH
66840: CALL_OW 314
66844: NOT
66845: PUSH
66846: LD_VAR 0 5
66850: PPUSH
66851: LD_VAR 0 13
66855: PPUSH
66856: CALL_OW 296
66860: PUSH
66861: LD_INT 30
66863: LESS
66864: AND
66865: IFFALSE 66881
// ComAttackUnit ( i , e ) ;
66867: LD_VAR 0 5
66871: PPUSH
66872: LD_VAR 0 13
66876: PPUSH
66877: CALL_OW 115
// end ; end ; end ;
66881: GO 66884
66883: POP
// if IsDead ( i ) then
66884: LD_VAR 0 5
66888: PPUSH
66889: CALL_OW 301
66893: IFFALSE 66911
// defenders := defenders diff i ;
66895: LD_ADDR_VAR 0 2
66899: PUSH
66900: LD_VAR 0 2
66904: PUSH
66905: LD_VAR 0 5
66909: DIFF
66910: ST_TO_ADDR
// end ;
66911: GO 66182
66913: POP
66914: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
66915: LD_VAR 0 3
66919: NOT
66920: PUSH
66921: LD_VAR 0 2
66925: NOT
66926: OR
66927: PUSH
66928: LD_EXP 99
66932: PUSH
66933: LD_VAR 0 1
66937: ARRAY
66938: NOT
66939: OR
66940: IFFALSE 66149
// MC_Reset ( base , 18 ) ;
66942: LD_VAR 0 1
66946: PPUSH
66947: LD_INT 18
66949: PPUSH
66950: CALL 37893 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66954: LD_ADDR_VAR 0 2
66958: PUSH
66959: LD_VAR 0 2
66963: PUSH
66964: LD_VAR 0 2
66968: PPUSH
66969: LD_INT 2
66971: PUSH
66972: LD_INT 25
66974: PUSH
66975: LD_INT 1
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PUSH
66982: LD_INT 25
66984: PUSH
66985: LD_INT 5
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 25
66994: PUSH
66995: LD_INT 8
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 25
67004: PUSH
67005: LD_INT 9
67007: PUSH
67008: EMPTY
67009: LIST
67010: LIST
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: PPUSH
67019: CALL_OW 72
67023: DIFF
67024: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67025: LD_VAR 0 3
67029: NOT
67030: PUSH
67031: LD_VAR 0 2
67035: PPUSH
67036: LD_INT 21
67038: PUSH
67039: LD_INT 2
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PPUSH
67046: CALL_OW 72
67050: AND
67051: IFFALSE 67326
// begin tmp := FilterByTag ( defenders , 19 ) ;
67053: LD_ADDR_VAR 0 11
67057: PUSH
67058: LD_VAR 0 2
67062: PPUSH
67063: LD_INT 19
67065: PPUSH
67066: CALL 103767 0 2
67070: ST_TO_ADDR
// if tmp then
67071: LD_VAR 0 11
67075: IFFALSE 67145
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
67077: LD_ADDR_VAR 0 11
67081: PUSH
67082: LD_VAR 0 11
67086: PPUSH
67087: LD_INT 25
67089: PUSH
67090: LD_INT 3
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PPUSH
67097: CALL_OW 72
67101: ST_TO_ADDR
// if tmp then
67102: LD_VAR 0 11
67106: IFFALSE 67145
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
67108: LD_ADDR_EXP 111
67112: PUSH
67113: LD_EXP 111
67117: PPUSH
67118: LD_VAR 0 1
67122: PPUSH
67123: LD_EXP 111
67127: PUSH
67128: LD_VAR 0 1
67132: ARRAY
67133: PUSH
67134: LD_VAR 0 11
67138: UNION
67139: PPUSH
67140: CALL_OW 1
67144: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
67145: LD_VAR 0 1
67149: PPUSH
67150: LD_INT 19
67152: PPUSH
67153: CALL 37893 0 2
// repeat wait ( 0 0$1 ) ;
67157: LD_INT 35
67159: PPUSH
67160: CALL_OW 67
// for i in defenders do
67164: LD_ADDR_VAR 0 5
67168: PUSH
67169: LD_VAR 0 2
67173: PUSH
67174: FOR_IN
67175: IFFALSE 67264
// begin if not IsInArea ( i , mc_parking [ base ] ) then
67177: LD_VAR 0 5
67181: PPUSH
67182: LD_EXP 123
67186: PUSH
67187: LD_VAR 0 1
67191: ARRAY
67192: PPUSH
67193: CALL_OW 308
67197: NOT
67198: IFFALSE 67222
// ComMoveToArea ( i , mc_parking [ base ] ) else
67200: LD_VAR 0 5
67204: PPUSH
67205: LD_EXP 123
67209: PUSH
67210: LD_VAR 0 1
67214: ARRAY
67215: PPUSH
67216: CALL_OW 113
67220: GO 67262
// if GetControl ( i ) = control_manual then
67222: LD_VAR 0 5
67226: PPUSH
67227: CALL_OW 263
67231: PUSH
67232: LD_INT 1
67234: EQUAL
67235: IFFALSE 67262
// if IsDrivenBy ( i ) then
67237: LD_VAR 0 5
67241: PPUSH
67242: CALL_OW 311
67246: IFFALSE 67262
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
67248: LD_VAR 0 5
67252: PPUSH
67253: CALL_OW 311
67257: PPUSH
67258: CALL_OW 121
// end ;
67262: GO 67174
67264: POP
67265: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
67266: LD_VAR 0 2
67270: PPUSH
67271: LD_INT 95
67273: PUSH
67274: LD_EXP 123
67278: PUSH
67279: LD_VAR 0 1
67283: ARRAY
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: PPUSH
67289: CALL_OW 72
67293: PUSH
67294: LD_VAR 0 2
67298: EQUAL
67299: PUSH
67300: LD_EXP 122
67304: PUSH
67305: LD_VAR 0 1
67309: ARRAY
67310: OR
67311: PUSH
67312: LD_EXP 99
67316: PUSH
67317: LD_VAR 0 1
67321: ARRAY
67322: NOT
67323: OR
67324: IFFALSE 67157
// end ; MC_Reset ( base , 20 ) ;
67326: LD_VAR 0 1
67330: PPUSH
67331: LD_INT 20
67333: PPUSH
67334: CALL 37893 0 2
// end ;
67338: LD_VAR 0 4
67342: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67343: LD_INT 0
67345: PPUSH
67346: PPUSH
67347: PPUSH
67348: PPUSH
// result := false ;
67349: LD_ADDR_VAR 0 2
67353: PUSH
67354: LD_INT 0
67356: ST_TO_ADDR
// side := GetSide ( unit ) ;
67357: LD_ADDR_VAR 0 3
67361: PUSH
67362: LD_VAR 0 1
67366: PPUSH
67367: CALL_OW 255
67371: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67372: LD_ADDR_VAR 0 4
67376: PUSH
67377: LD_VAR 0 1
67381: PPUSH
67382: CALL_OW 248
67386: ST_TO_ADDR
// case nat of 1 :
67387: LD_VAR 0 4
67391: PUSH
67392: LD_INT 1
67394: DOUBLE
67395: EQUAL
67396: IFTRUE 67400
67398: GO 67411
67400: POP
// tech := tech_lassight ; 2 :
67401: LD_ADDR_VAR 0 5
67405: PUSH
67406: LD_INT 12
67408: ST_TO_ADDR
67409: GO 67450
67411: LD_INT 2
67413: DOUBLE
67414: EQUAL
67415: IFTRUE 67419
67417: GO 67430
67419: POP
// tech := tech_mortar ; 3 :
67420: LD_ADDR_VAR 0 5
67424: PUSH
67425: LD_INT 41
67427: ST_TO_ADDR
67428: GO 67450
67430: LD_INT 3
67432: DOUBLE
67433: EQUAL
67434: IFTRUE 67438
67436: GO 67449
67438: POP
// tech := tech_bazooka ; end ;
67439: LD_ADDR_VAR 0 5
67443: PUSH
67444: LD_INT 44
67446: ST_TO_ADDR
67447: GO 67450
67449: POP
// if Researched ( side , tech ) then
67450: LD_VAR 0 3
67454: PPUSH
67455: LD_VAR 0 5
67459: PPUSH
67460: CALL_OW 325
67464: IFFALSE 67491
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67466: LD_ADDR_VAR 0 2
67470: PUSH
67471: LD_INT 5
67473: PUSH
67474: LD_INT 8
67476: PUSH
67477: LD_INT 9
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: LIST
67484: PUSH
67485: LD_VAR 0 4
67489: ARRAY
67490: ST_TO_ADDR
// end ;
67491: LD_VAR 0 2
67495: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67496: LD_INT 0
67498: PPUSH
67499: PPUSH
67500: PPUSH
// if not mines then
67501: LD_VAR 0 2
67505: NOT
67506: IFFALSE 67510
// exit ;
67508: GO 67654
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67510: LD_ADDR_VAR 0 5
67514: PUSH
67515: LD_INT 81
67517: PUSH
67518: LD_VAR 0 1
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: LD_INT 3
67529: PUSH
67530: LD_INT 21
67532: PUSH
67533: LD_INT 3
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PPUSH
67548: CALL_OW 69
67552: ST_TO_ADDR
// for i in mines do
67553: LD_ADDR_VAR 0 4
67557: PUSH
67558: LD_VAR 0 2
67562: PUSH
67563: FOR_IN
67564: IFFALSE 67652
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67566: LD_VAR 0 4
67570: PUSH
67571: LD_INT 1
67573: ARRAY
67574: PPUSH
67575: LD_VAR 0 4
67579: PUSH
67580: LD_INT 2
67582: ARRAY
67583: PPUSH
67584: CALL_OW 458
67588: NOT
67589: IFFALSE 67593
// continue ;
67591: GO 67563
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67593: LD_VAR 0 4
67597: PUSH
67598: LD_INT 1
67600: ARRAY
67601: PPUSH
67602: LD_VAR 0 4
67606: PUSH
67607: LD_INT 2
67609: ARRAY
67610: PPUSH
67611: CALL_OW 428
67615: PUSH
67616: LD_VAR 0 5
67620: IN
67621: IFFALSE 67650
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67623: LD_VAR 0 4
67627: PUSH
67628: LD_INT 1
67630: ARRAY
67631: PPUSH
67632: LD_VAR 0 4
67636: PUSH
67637: LD_INT 2
67639: ARRAY
67640: PPUSH
67641: LD_VAR 0 1
67645: PPUSH
67646: CALL_OW 456
// end ;
67650: GO 67563
67652: POP
67653: POP
// end ;
67654: LD_VAR 0 3
67658: RET
// export function Count ( array ) ; var i ; begin
67659: LD_INT 0
67661: PPUSH
67662: PPUSH
// result := 0 ;
67663: LD_ADDR_VAR 0 2
67667: PUSH
67668: LD_INT 0
67670: ST_TO_ADDR
// for i in array do
67671: LD_ADDR_VAR 0 3
67675: PUSH
67676: LD_VAR 0 1
67680: PUSH
67681: FOR_IN
67682: IFFALSE 67706
// if i then
67684: LD_VAR 0 3
67688: IFFALSE 67704
// result := result + 1 ;
67690: LD_ADDR_VAR 0 2
67694: PUSH
67695: LD_VAR 0 2
67699: PUSH
67700: LD_INT 1
67702: PLUS
67703: ST_TO_ADDR
67704: GO 67681
67706: POP
67707: POP
// end ;
67708: LD_VAR 0 2
67712: RET
// export function IsEmpty ( building ) ; begin
67713: LD_INT 0
67715: PPUSH
// if not building then
67716: LD_VAR 0 1
67720: NOT
67721: IFFALSE 67725
// exit ;
67723: GO 67768
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67725: LD_ADDR_VAR 0 2
67729: PUSH
67730: LD_VAR 0 1
67734: PUSH
67735: LD_INT 22
67737: PUSH
67738: LD_VAR 0 1
67742: PPUSH
67743: CALL_OW 255
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PUSH
67752: LD_INT 58
67754: PUSH
67755: EMPTY
67756: LIST
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: PPUSH
67762: CALL_OW 69
67766: IN
67767: ST_TO_ADDR
// end ;
67768: LD_VAR 0 2
67772: RET
// export function IsNotFull ( building ) ; begin
67773: LD_INT 0
67775: PPUSH
// if not building then
67776: LD_VAR 0 1
67780: NOT
67781: IFFALSE 67785
// exit ;
67783: GO 67804
// result := UnitsInside ( building ) < 6 ;
67785: LD_ADDR_VAR 0 2
67789: PUSH
67790: LD_VAR 0 1
67794: PPUSH
67795: CALL_OW 313
67799: PUSH
67800: LD_INT 6
67802: LESS
67803: ST_TO_ADDR
// end ;
67804: LD_VAR 0 2
67808: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67809: LD_INT 0
67811: PPUSH
67812: PPUSH
67813: PPUSH
67814: PPUSH
// tmp := [ ] ;
67815: LD_ADDR_VAR 0 3
67819: PUSH
67820: EMPTY
67821: ST_TO_ADDR
// list := [ ] ;
67822: LD_ADDR_VAR 0 5
67826: PUSH
67827: EMPTY
67828: ST_TO_ADDR
// for i = 16 to 25 do
67829: LD_ADDR_VAR 0 4
67833: PUSH
67834: DOUBLE
67835: LD_INT 16
67837: DEC
67838: ST_TO_ADDR
67839: LD_INT 25
67841: PUSH
67842: FOR_TO
67843: IFFALSE 67916
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67845: LD_ADDR_VAR 0 3
67849: PUSH
67850: LD_VAR 0 3
67854: PUSH
67855: LD_INT 22
67857: PUSH
67858: LD_VAR 0 1
67862: PPUSH
67863: CALL_OW 255
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 91
67874: PUSH
67875: LD_VAR 0 1
67879: PUSH
67880: LD_INT 6
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 30
67890: PUSH
67891: LD_VAR 0 4
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: LIST
67904: PUSH
67905: EMPTY
67906: LIST
67907: PPUSH
67908: CALL_OW 69
67912: ADD
67913: ST_TO_ADDR
67914: GO 67842
67916: POP
67917: POP
// for i = 1 to tmp do
67918: LD_ADDR_VAR 0 4
67922: PUSH
67923: DOUBLE
67924: LD_INT 1
67926: DEC
67927: ST_TO_ADDR
67928: LD_VAR 0 3
67932: PUSH
67933: FOR_TO
67934: IFFALSE 68022
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67936: LD_ADDR_VAR 0 5
67940: PUSH
67941: LD_VAR 0 5
67945: PUSH
67946: LD_VAR 0 3
67950: PUSH
67951: LD_VAR 0 4
67955: ARRAY
67956: PPUSH
67957: CALL_OW 266
67961: PUSH
67962: LD_VAR 0 3
67966: PUSH
67967: LD_VAR 0 4
67971: ARRAY
67972: PPUSH
67973: CALL_OW 250
67977: PUSH
67978: LD_VAR 0 3
67982: PUSH
67983: LD_VAR 0 4
67987: ARRAY
67988: PPUSH
67989: CALL_OW 251
67993: PUSH
67994: LD_VAR 0 3
67998: PUSH
67999: LD_VAR 0 4
68003: ARRAY
68004: PPUSH
68005: CALL_OW 254
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: PUSH
68016: EMPTY
68017: LIST
68018: ADD
68019: ST_TO_ADDR
68020: GO 67933
68022: POP
68023: POP
// result := list ;
68024: LD_ADDR_VAR 0 2
68028: PUSH
68029: LD_VAR 0 5
68033: ST_TO_ADDR
// end ;
68034: LD_VAR 0 2
68038: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68039: LD_INT 0
68041: PPUSH
68042: PPUSH
68043: PPUSH
68044: PPUSH
68045: PPUSH
68046: PPUSH
68047: PPUSH
// if not factory then
68048: LD_VAR 0 1
68052: NOT
68053: IFFALSE 68057
// exit ;
68055: GO 68650
// if control = control_apeman then
68057: LD_VAR 0 4
68061: PUSH
68062: LD_INT 5
68064: EQUAL
68065: IFFALSE 68174
// begin tmp := UnitsInside ( factory ) ;
68067: LD_ADDR_VAR 0 8
68071: PUSH
68072: LD_VAR 0 1
68076: PPUSH
68077: CALL_OW 313
68081: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68082: LD_VAR 0 8
68086: PPUSH
68087: LD_INT 25
68089: PUSH
68090: LD_INT 12
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PPUSH
68097: CALL_OW 72
68101: NOT
68102: IFFALSE 68112
// control := control_manual ;
68104: LD_ADDR_VAR 0 4
68108: PUSH
68109: LD_INT 1
68111: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68112: LD_ADDR_VAR 0 8
68116: PUSH
68117: LD_VAR 0 1
68121: PPUSH
68122: CALL 67809 0 1
68126: ST_TO_ADDR
// if tmp then
68127: LD_VAR 0 8
68131: IFFALSE 68174
// begin for i in tmp do
68133: LD_ADDR_VAR 0 7
68137: PUSH
68138: LD_VAR 0 8
68142: PUSH
68143: FOR_IN
68144: IFFALSE 68172
// if i [ 1 ] = b_ext_radio then
68146: LD_VAR 0 7
68150: PUSH
68151: LD_INT 1
68153: ARRAY
68154: PUSH
68155: LD_INT 22
68157: EQUAL
68158: IFFALSE 68170
// begin control := control_remote ;
68160: LD_ADDR_VAR 0 4
68164: PUSH
68165: LD_INT 2
68167: ST_TO_ADDR
// break ;
68168: GO 68172
// end ;
68170: GO 68143
68172: POP
68173: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68174: LD_VAR 0 1
68178: PPUSH
68179: LD_VAR 0 2
68183: PPUSH
68184: LD_VAR 0 3
68188: PPUSH
68189: LD_VAR 0 4
68193: PPUSH
68194: LD_VAR 0 5
68198: PPUSH
68199: CALL_OW 448
68203: IFFALSE 68238
// begin result := [ chassis , engine , control , weapon ] ;
68205: LD_ADDR_VAR 0 6
68209: PUSH
68210: LD_VAR 0 2
68214: PUSH
68215: LD_VAR 0 3
68219: PUSH
68220: LD_VAR 0 4
68224: PUSH
68225: LD_VAR 0 5
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: LIST
68234: LIST
68235: ST_TO_ADDR
// exit ;
68236: GO 68650
// end ; _chassis := AvailableChassisList ( factory ) ;
68238: LD_ADDR_VAR 0 9
68242: PUSH
68243: LD_VAR 0 1
68247: PPUSH
68248: CALL_OW 475
68252: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68253: LD_ADDR_VAR 0 11
68257: PUSH
68258: LD_VAR 0 1
68262: PPUSH
68263: CALL_OW 476
68267: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68268: LD_ADDR_VAR 0 12
68272: PUSH
68273: LD_VAR 0 1
68277: PPUSH
68278: CALL_OW 477
68282: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68283: LD_ADDR_VAR 0 10
68287: PUSH
68288: LD_VAR 0 1
68292: PPUSH
68293: CALL_OW 478
68297: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68298: LD_VAR 0 9
68302: NOT
68303: PUSH
68304: LD_VAR 0 11
68308: NOT
68309: OR
68310: PUSH
68311: LD_VAR 0 12
68315: NOT
68316: OR
68317: PUSH
68318: LD_VAR 0 10
68322: NOT
68323: OR
68324: IFFALSE 68359
// begin result := [ chassis , engine , control , weapon ] ;
68326: LD_ADDR_VAR 0 6
68330: PUSH
68331: LD_VAR 0 2
68335: PUSH
68336: LD_VAR 0 3
68340: PUSH
68341: LD_VAR 0 4
68345: PUSH
68346: LD_VAR 0 5
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: LIST
68355: LIST
68356: ST_TO_ADDR
// exit ;
68357: GO 68650
// end ; if not chassis in _chassis then
68359: LD_VAR 0 2
68363: PUSH
68364: LD_VAR 0 9
68368: IN
68369: NOT
68370: IFFALSE 68396
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68372: LD_ADDR_VAR 0 2
68376: PUSH
68377: LD_VAR 0 9
68381: PUSH
68382: LD_INT 1
68384: PPUSH
68385: LD_VAR 0 9
68389: PPUSH
68390: CALL_OW 12
68394: ARRAY
68395: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68396: LD_VAR 0 2
68400: PPUSH
68401: LD_VAR 0 3
68405: PPUSH
68406: CALL 68655 0 2
68410: NOT
68411: IFFALSE 68470
// repeat engine := _engine [ 1 ] ;
68413: LD_ADDR_VAR 0 3
68417: PUSH
68418: LD_VAR 0 11
68422: PUSH
68423: LD_INT 1
68425: ARRAY
68426: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68427: LD_ADDR_VAR 0 11
68431: PUSH
68432: LD_VAR 0 11
68436: PPUSH
68437: LD_INT 1
68439: PPUSH
68440: CALL_OW 3
68444: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68445: LD_VAR 0 2
68449: PPUSH
68450: LD_VAR 0 3
68454: PPUSH
68455: CALL 68655 0 2
68459: PUSH
68460: LD_VAR 0 11
68464: PUSH
68465: EMPTY
68466: EQUAL
68467: OR
68468: IFFALSE 68413
// if not control in _control then
68470: LD_VAR 0 4
68474: PUSH
68475: LD_VAR 0 12
68479: IN
68480: NOT
68481: IFFALSE 68507
// control := _control [ rand ( 1 , _control ) ] ;
68483: LD_ADDR_VAR 0 4
68487: PUSH
68488: LD_VAR 0 12
68492: PUSH
68493: LD_INT 1
68495: PPUSH
68496: LD_VAR 0 12
68500: PPUSH
68501: CALL_OW 12
68505: ARRAY
68506: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68507: LD_VAR 0 2
68511: PPUSH
68512: LD_VAR 0 5
68516: PPUSH
68517: CALL 68875 0 2
68521: NOT
68522: IFFALSE 68581
// repeat weapon := _weapon [ 1 ] ;
68524: LD_ADDR_VAR 0 5
68528: PUSH
68529: LD_VAR 0 10
68533: PUSH
68534: LD_INT 1
68536: ARRAY
68537: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68538: LD_ADDR_VAR 0 10
68542: PUSH
68543: LD_VAR 0 10
68547: PPUSH
68548: LD_INT 1
68550: PPUSH
68551: CALL_OW 3
68555: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68556: LD_VAR 0 2
68560: PPUSH
68561: LD_VAR 0 5
68565: PPUSH
68566: CALL 68875 0 2
68570: PUSH
68571: LD_VAR 0 10
68575: PUSH
68576: EMPTY
68577: EQUAL
68578: OR
68579: IFFALSE 68524
// result := [ ] ;
68581: LD_ADDR_VAR 0 6
68585: PUSH
68586: EMPTY
68587: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68588: LD_VAR 0 1
68592: PPUSH
68593: LD_VAR 0 2
68597: PPUSH
68598: LD_VAR 0 3
68602: PPUSH
68603: LD_VAR 0 4
68607: PPUSH
68608: LD_VAR 0 5
68612: PPUSH
68613: CALL_OW 448
68617: IFFALSE 68650
// result := [ chassis , engine , control , weapon ] ;
68619: LD_ADDR_VAR 0 6
68623: PUSH
68624: LD_VAR 0 2
68628: PUSH
68629: LD_VAR 0 3
68633: PUSH
68634: LD_VAR 0 4
68638: PUSH
68639: LD_VAR 0 5
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: ST_TO_ADDR
// end ;
68650: LD_VAR 0 6
68654: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68655: LD_INT 0
68657: PPUSH
// if not chassis or not engine then
68658: LD_VAR 0 1
68662: NOT
68663: PUSH
68664: LD_VAR 0 2
68668: NOT
68669: OR
68670: IFFALSE 68674
// exit ;
68672: GO 68870
// case engine of engine_solar :
68674: LD_VAR 0 2
68678: PUSH
68679: LD_INT 2
68681: DOUBLE
68682: EQUAL
68683: IFTRUE 68687
68685: GO 68725
68687: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68688: LD_ADDR_VAR 0 3
68692: PUSH
68693: LD_INT 11
68695: PUSH
68696: LD_INT 12
68698: PUSH
68699: LD_INT 13
68701: PUSH
68702: LD_INT 14
68704: PUSH
68705: LD_INT 1
68707: PUSH
68708: LD_INT 2
68710: PUSH
68711: LD_INT 3
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: ST_TO_ADDR
68723: GO 68854
68725: LD_INT 1
68727: DOUBLE
68728: EQUAL
68729: IFTRUE 68733
68731: GO 68795
68733: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68734: LD_ADDR_VAR 0 3
68738: PUSH
68739: LD_INT 11
68741: PUSH
68742: LD_INT 12
68744: PUSH
68745: LD_INT 13
68747: PUSH
68748: LD_INT 14
68750: PUSH
68751: LD_INT 1
68753: PUSH
68754: LD_INT 2
68756: PUSH
68757: LD_INT 3
68759: PUSH
68760: LD_INT 4
68762: PUSH
68763: LD_INT 5
68765: PUSH
68766: LD_INT 21
68768: PUSH
68769: LD_INT 23
68771: PUSH
68772: LD_INT 22
68774: PUSH
68775: LD_INT 24
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: LIST
68782: LIST
68783: LIST
68784: LIST
68785: LIST
68786: LIST
68787: LIST
68788: LIST
68789: LIST
68790: LIST
68791: LIST
68792: ST_TO_ADDR
68793: GO 68854
68795: LD_INT 3
68797: DOUBLE
68798: EQUAL
68799: IFTRUE 68803
68801: GO 68853
68803: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68804: LD_ADDR_VAR 0 3
68808: PUSH
68809: LD_INT 13
68811: PUSH
68812: LD_INT 14
68814: PUSH
68815: LD_INT 2
68817: PUSH
68818: LD_INT 3
68820: PUSH
68821: LD_INT 4
68823: PUSH
68824: LD_INT 5
68826: PUSH
68827: LD_INT 21
68829: PUSH
68830: LD_INT 22
68832: PUSH
68833: LD_INT 23
68835: PUSH
68836: LD_INT 24
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: ST_TO_ADDR
68851: GO 68854
68853: POP
// result := ( chassis in result ) ;
68854: LD_ADDR_VAR 0 3
68858: PUSH
68859: LD_VAR 0 1
68863: PUSH
68864: LD_VAR 0 3
68868: IN
68869: ST_TO_ADDR
// end ;
68870: LD_VAR 0 3
68874: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68875: LD_INT 0
68877: PPUSH
// if not chassis or not weapon then
68878: LD_VAR 0 1
68882: NOT
68883: PUSH
68884: LD_VAR 0 2
68888: NOT
68889: OR
68890: IFFALSE 68894
// exit ;
68892: GO 69920
// case weapon of us_machine_gun :
68894: LD_VAR 0 2
68898: PUSH
68899: LD_INT 2
68901: DOUBLE
68902: EQUAL
68903: IFTRUE 68907
68905: GO 68937
68907: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68908: LD_ADDR_VAR 0 3
68912: PUSH
68913: LD_INT 1
68915: PUSH
68916: LD_INT 2
68918: PUSH
68919: LD_INT 3
68921: PUSH
68922: LD_INT 4
68924: PUSH
68925: LD_INT 5
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: LIST
68932: LIST
68933: LIST
68934: ST_TO_ADDR
68935: GO 69904
68937: LD_INT 3
68939: DOUBLE
68940: EQUAL
68941: IFTRUE 68945
68943: GO 68975
68945: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68946: LD_ADDR_VAR 0 3
68950: PUSH
68951: LD_INT 1
68953: PUSH
68954: LD_INT 2
68956: PUSH
68957: LD_INT 3
68959: PUSH
68960: LD_INT 4
68962: PUSH
68963: LD_INT 5
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: ST_TO_ADDR
68973: GO 69904
68975: LD_INT 11
68977: DOUBLE
68978: EQUAL
68979: IFTRUE 68983
68981: GO 69013
68983: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68984: LD_ADDR_VAR 0 3
68988: PUSH
68989: LD_INT 1
68991: PUSH
68992: LD_INT 2
68994: PUSH
68995: LD_INT 3
68997: PUSH
68998: LD_INT 4
69000: PUSH
69001: LD_INT 5
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: ST_TO_ADDR
69011: GO 69904
69013: LD_INT 4
69015: DOUBLE
69016: EQUAL
69017: IFTRUE 69021
69019: GO 69047
69021: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69022: LD_ADDR_VAR 0 3
69026: PUSH
69027: LD_INT 2
69029: PUSH
69030: LD_INT 3
69032: PUSH
69033: LD_INT 4
69035: PUSH
69036: LD_INT 5
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: ST_TO_ADDR
69045: GO 69904
69047: LD_INT 5
69049: DOUBLE
69050: EQUAL
69051: IFTRUE 69055
69053: GO 69081
69055: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69056: LD_ADDR_VAR 0 3
69060: PUSH
69061: LD_INT 2
69063: PUSH
69064: LD_INT 3
69066: PUSH
69067: LD_INT 4
69069: PUSH
69070: LD_INT 5
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: ST_TO_ADDR
69079: GO 69904
69081: LD_INT 9
69083: DOUBLE
69084: EQUAL
69085: IFTRUE 69089
69087: GO 69115
69089: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69090: LD_ADDR_VAR 0 3
69094: PUSH
69095: LD_INT 2
69097: PUSH
69098: LD_INT 3
69100: PUSH
69101: LD_INT 4
69103: PUSH
69104: LD_INT 5
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: ST_TO_ADDR
69113: GO 69904
69115: LD_INT 7
69117: DOUBLE
69118: EQUAL
69119: IFTRUE 69123
69121: GO 69149
69123: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69124: LD_ADDR_VAR 0 3
69128: PUSH
69129: LD_INT 2
69131: PUSH
69132: LD_INT 3
69134: PUSH
69135: LD_INT 4
69137: PUSH
69138: LD_INT 5
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: ST_TO_ADDR
69147: GO 69904
69149: LD_INT 12
69151: DOUBLE
69152: EQUAL
69153: IFTRUE 69157
69155: GO 69183
69157: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69158: LD_ADDR_VAR 0 3
69162: PUSH
69163: LD_INT 2
69165: PUSH
69166: LD_INT 3
69168: PUSH
69169: LD_INT 4
69171: PUSH
69172: LD_INT 5
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: ST_TO_ADDR
69181: GO 69904
69183: LD_INT 13
69185: DOUBLE
69186: EQUAL
69187: IFTRUE 69191
69189: GO 69217
69191: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69192: LD_ADDR_VAR 0 3
69196: PUSH
69197: LD_INT 2
69199: PUSH
69200: LD_INT 3
69202: PUSH
69203: LD_INT 4
69205: PUSH
69206: LD_INT 5
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: ST_TO_ADDR
69215: GO 69904
69217: LD_INT 14
69219: DOUBLE
69220: EQUAL
69221: IFTRUE 69225
69223: GO 69243
69225: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69226: LD_ADDR_VAR 0 3
69230: PUSH
69231: LD_INT 4
69233: PUSH
69234: LD_INT 5
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: ST_TO_ADDR
69241: GO 69904
69243: LD_INT 6
69245: DOUBLE
69246: EQUAL
69247: IFTRUE 69251
69249: GO 69269
69251: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69252: LD_ADDR_VAR 0 3
69256: PUSH
69257: LD_INT 4
69259: PUSH
69260: LD_INT 5
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: ST_TO_ADDR
69267: GO 69904
69269: LD_INT 10
69271: DOUBLE
69272: EQUAL
69273: IFTRUE 69277
69275: GO 69295
69277: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69278: LD_ADDR_VAR 0 3
69282: PUSH
69283: LD_INT 4
69285: PUSH
69286: LD_INT 5
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: ST_TO_ADDR
69293: GO 69904
69295: LD_INT 22
69297: DOUBLE
69298: EQUAL
69299: IFTRUE 69303
69301: GO 69329
69303: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69304: LD_ADDR_VAR 0 3
69308: PUSH
69309: LD_INT 11
69311: PUSH
69312: LD_INT 12
69314: PUSH
69315: LD_INT 13
69317: PUSH
69318: LD_INT 14
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: ST_TO_ADDR
69327: GO 69904
69329: LD_INT 23
69331: DOUBLE
69332: EQUAL
69333: IFTRUE 69337
69335: GO 69363
69337: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69338: LD_ADDR_VAR 0 3
69342: PUSH
69343: LD_INT 11
69345: PUSH
69346: LD_INT 12
69348: PUSH
69349: LD_INT 13
69351: PUSH
69352: LD_INT 14
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: ST_TO_ADDR
69361: GO 69904
69363: LD_INT 24
69365: DOUBLE
69366: EQUAL
69367: IFTRUE 69371
69369: GO 69397
69371: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69372: LD_ADDR_VAR 0 3
69376: PUSH
69377: LD_INT 11
69379: PUSH
69380: LD_INT 12
69382: PUSH
69383: LD_INT 13
69385: PUSH
69386: LD_INT 14
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: ST_TO_ADDR
69395: GO 69904
69397: LD_INT 30
69399: DOUBLE
69400: EQUAL
69401: IFTRUE 69405
69403: GO 69431
69405: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69406: LD_ADDR_VAR 0 3
69410: PUSH
69411: LD_INT 11
69413: PUSH
69414: LD_INT 12
69416: PUSH
69417: LD_INT 13
69419: PUSH
69420: LD_INT 14
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: ST_TO_ADDR
69429: GO 69904
69431: LD_INT 25
69433: DOUBLE
69434: EQUAL
69435: IFTRUE 69439
69437: GO 69457
69439: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69440: LD_ADDR_VAR 0 3
69444: PUSH
69445: LD_INT 13
69447: PUSH
69448: LD_INT 14
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: ST_TO_ADDR
69455: GO 69904
69457: LD_INT 27
69459: DOUBLE
69460: EQUAL
69461: IFTRUE 69465
69463: GO 69483
69465: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69466: LD_ADDR_VAR 0 3
69470: PUSH
69471: LD_INT 13
69473: PUSH
69474: LD_INT 14
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: ST_TO_ADDR
69481: GO 69904
69483: LD_INT 28
69485: DOUBLE
69486: EQUAL
69487: IFTRUE 69491
69489: GO 69509
69491: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69492: LD_ADDR_VAR 0 3
69496: PUSH
69497: LD_INT 13
69499: PUSH
69500: LD_INT 14
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: ST_TO_ADDR
69507: GO 69904
69509: LD_INT 29
69511: DOUBLE
69512: EQUAL
69513: IFTRUE 69517
69515: GO 69535
69517: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69518: LD_ADDR_VAR 0 3
69522: PUSH
69523: LD_INT 13
69525: PUSH
69526: LD_INT 14
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: ST_TO_ADDR
69533: GO 69904
69535: LD_INT 31
69537: DOUBLE
69538: EQUAL
69539: IFTRUE 69543
69541: GO 69561
69543: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69544: LD_ADDR_VAR 0 3
69548: PUSH
69549: LD_INT 13
69551: PUSH
69552: LD_INT 14
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: ST_TO_ADDR
69559: GO 69904
69561: LD_INT 26
69563: DOUBLE
69564: EQUAL
69565: IFTRUE 69569
69567: GO 69587
69569: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69570: LD_ADDR_VAR 0 3
69574: PUSH
69575: LD_INT 13
69577: PUSH
69578: LD_INT 14
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: ST_TO_ADDR
69585: GO 69904
69587: LD_INT 42
69589: DOUBLE
69590: EQUAL
69591: IFTRUE 69595
69593: GO 69621
69595: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69596: LD_ADDR_VAR 0 3
69600: PUSH
69601: LD_INT 21
69603: PUSH
69604: LD_INT 22
69606: PUSH
69607: LD_INT 23
69609: PUSH
69610: LD_INT 24
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: LIST
69617: LIST
69618: ST_TO_ADDR
69619: GO 69904
69621: LD_INT 43
69623: DOUBLE
69624: EQUAL
69625: IFTRUE 69629
69627: GO 69655
69629: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69630: LD_ADDR_VAR 0 3
69634: PUSH
69635: LD_INT 21
69637: PUSH
69638: LD_INT 22
69640: PUSH
69641: LD_INT 23
69643: PUSH
69644: LD_INT 24
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: ST_TO_ADDR
69653: GO 69904
69655: LD_INT 44
69657: DOUBLE
69658: EQUAL
69659: IFTRUE 69663
69661: GO 69689
69663: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69664: LD_ADDR_VAR 0 3
69668: PUSH
69669: LD_INT 21
69671: PUSH
69672: LD_INT 22
69674: PUSH
69675: LD_INT 23
69677: PUSH
69678: LD_INT 24
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: ST_TO_ADDR
69687: GO 69904
69689: LD_INT 45
69691: DOUBLE
69692: EQUAL
69693: IFTRUE 69697
69695: GO 69723
69697: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69698: LD_ADDR_VAR 0 3
69702: PUSH
69703: LD_INT 21
69705: PUSH
69706: LD_INT 22
69708: PUSH
69709: LD_INT 23
69711: PUSH
69712: LD_INT 24
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: ST_TO_ADDR
69721: GO 69904
69723: LD_INT 49
69725: DOUBLE
69726: EQUAL
69727: IFTRUE 69731
69729: GO 69757
69731: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69732: LD_ADDR_VAR 0 3
69736: PUSH
69737: LD_INT 21
69739: PUSH
69740: LD_INT 22
69742: PUSH
69743: LD_INT 23
69745: PUSH
69746: LD_INT 24
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: ST_TO_ADDR
69755: GO 69904
69757: LD_INT 51
69759: DOUBLE
69760: EQUAL
69761: IFTRUE 69765
69763: GO 69791
69765: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69766: LD_ADDR_VAR 0 3
69770: PUSH
69771: LD_INT 21
69773: PUSH
69774: LD_INT 22
69776: PUSH
69777: LD_INT 23
69779: PUSH
69780: LD_INT 24
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: LIST
69787: LIST
69788: ST_TO_ADDR
69789: GO 69904
69791: LD_INT 52
69793: DOUBLE
69794: EQUAL
69795: IFTRUE 69799
69797: GO 69825
69799: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69800: LD_ADDR_VAR 0 3
69804: PUSH
69805: LD_INT 21
69807: PUSH
69808: LD_INT 22
69810: PUSH
69811: LD_INT 23
69813: PUSH
69814: LD_INT 24
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: LIST
69821: LIST
69822: ST_TO_ADDR
69823: GO 69904
69825: LD_INT 53
69827: DOUBLE
69828: EQUAL
69829: IFTRUE 69833
69831: GO 69851
69833: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69834: LD_ADDR_VAR 0 3
69838: PUSH
69839: LD_INT 23
69841: PUSH
69842: LD_INT 24
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: ST_TO_ADDR
69849: GO 69904
69851: LD_INT 46
69853: DOUBLE
69854: EQUAL
69855: IFTRUE 69859
69857: GO 69877
69859: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69860: LD_ADDR_VAR 0 3
69864: PUSH
69865: LD_INT 23
69867: PUSH
69868: LD_INT 24
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: ST_TO_ADDR
69875: GO 69904
69877: LD_INT 47
69879: DOUBLE
69880: EQUAL
69881: IFTRUE 69885
69883: GO 69903
69885: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69886: LD_ADDR_VAR 0 3
69890: PUSH
69891: LD_INT 23
69893: PUSH
69894: LD_INT 24
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: ST_TO_ADDR
69901: GO 69904
69903: POP
// result := ( chassis in result ) ;
69904: LD_ADDR_VAR 0 3
69908: PUSH
69909: LD_VAR 0 1
69913: PUSH
69914: LD_VAR 0 3
69918: IN
69919: ST_TO_ADDR
// end ;
69920: LD_VAR 0 3
69924: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69925: LD_INT 0
69927: PPUSH
69928: PPUSH
69929: PPUSH
69930: PPUSH
69931: PPUSH
69932: PPUSH
69933: PPUSH
// result := array ;
69934: LD_ADDR_VAR 0 5
69938: PUSH
69939: LD_VAR 0 1
69943: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69944: LD_VAR 0 1
69948: NOT
69949: PUSH
69950: LD_VAR 0 2
69954: NOT
69955: OR
69956: PUSH
69957: LD_VAR 0 3
69961: NOT
69962: OR
69963: PUSH
69964: LD_VAR 0 2
69968: PUSH
69969: LD_VAR 0 1
69973: GREATER
69974: OR
69975: PUSH
69976: LD_VAR 0 3
69980: PUSH
69981: LD_VAR 0 1
69985: GREATER
69986: OR
69987: IFFALSE 69991
// exit ;
69989: GO 70287
// if direction then
69991: LD_VAR 0 4
69995: IFFALSE 70059
// begin d := 1 ;
69997: LD_ADDR_VAR 0 9
70001: PUSH
70002: LD_INT 1
70004: ST_TO_ADDR
// if i_from > i_to then
70005: LD_VAR 0 2
70009: PUSH
70010: LD_VAR 0 3
70014: GREATER
70015: IFFALSE 70041
// length := ( array - i_from ) + i_to else
70017: LD_ADDR_VAR 0 11
70021: PUSH
70022: LD_VAR 0 1
70026: PUSH
70027: LD_VAR 0 2
70031: MINUS
70032: PUSH
70033: LD_VAR 0 3
70037: PLUS
70038: ST_TO_ADDR
70039: GO 70057
// length := i_to - i_from ;
70041: LD_ADDR_VAR 0 11
70045: PUSH
70046: LD_VAR 0 3
70050: PUSH
70051: LD_VAR 0 2
70055: MINUS
70056: ST_TO_ADDR
// end else
70057: GO 70120
// begin d := - 1 ;
70059: LD_ADDR_VAR 0 9
70063: PUSH
70064: LD_INT 1
70066: NEG
70067: ST_TO_ADDR
// if i_from > i_to then
70068: LD_VAR 0 2
70072: PUSH
70073: LD_VAR 0 3
70077: GREATER
70078: IFFALSE 70098
// length := i_from - i_to else
70080: LD_ADDR_VAR 0 11
70084: PUSH
70085: LD_VAR 0 2
70089: PUSH
70090: LD_VAR 0 3
70094: MINUS
70095: ST_TO_ADDR
70096: GO 70120
// length := ( array - i_to ) + i_from ;
70098: LD_ADDR_VAR 0 11
70102: PUSH
70103: LD_VAR 0 1
70107: PUSH
70108: LD_VAR 0 3
70112: MINUS
70113: PUSH
70114: LD_VAR 0 2
70118: PLUS
70119: ST_TO_ADDR
// end ; if not length then
70120: LD_VAR 0 11
70124: NOT
70125: IFFALSE 70129
// exit ;
70127: GO 70287
// tmp := array ;
70129: LD_ADDR_VAR 0 10
70133: PUSH
70134: LD_VAR 0 1
70138: ST_TO_ADDR
// for i = 1 to length do
70139: LD_ADDR_VAR 0 6
70143: PUSH
70144: DOUBLE
70145: LD_INT 1
70147: DEC
70148: ST_TO_ADDR
70149: LD_VAR 0 11
70153: PUSH
70154: FOR_TO
70155: IFFALSE 70275
// begin for j = 1 to array do
70157: LD_ADDR_VAR 0 7
70161: PUSH
70162: DOUBLE
70163: LD_INT 1
70165: DEC
70166: ST_TO_ADDR
70167: LD_VAR 0 1
70171: PUSH
70172: FOR_TO
70173: IFFALSE 70261
// begin k := j + d ;
70175: LD_ADDR_VAR 0 8
70179: PUSH
70180: LD_VAR 0 7
70184: PUSH
70185: LD_VAR 0 9
70189: PLUS
70190: ST_TO_ADDR
// if k > array then
70191: LD_VAR 0 8
70195: PUSH
70196: LD_VAR 0 1
70200: GREATER
70201: IFFALSE 70211
// k := 1 ;
70203: LD_ADDR_VAR 0 8
70207: PUSH
70208: LD_INT 1
70210: ST_TO_ADDR
// if not k then
70211: LD_VAR 0 8
70215: NOT
70216: IFFALSE 70228
// k := array ;
70218: LD_ADDR_VAR 0 8
70222: PUSH
70223: LD_VAR 0 1
70227: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70228: LD_ADDR_VAR 0 10
70232: PUSH
70233: LD_VAR 0 10
70237: PPUSH
70238: LD_VAR 0 8
70242: PPUSH
70243: LD_VAR 0 1
70247: PUSH
70248: LD_VAR 0 7
70252: ARRAY
70253: PPUSH
70254: CALL_OW 1
70258: ST_TO_ADDR
// end ;
70259: GO 70172
70261: POP
70262: POP
// array := tmp ;
70263: LD_ADDR_VAR 0 1
70267: PUSH
70268: LD_VAR 0 10
70272: ST_TO_ADDR
// end ;
70273: GO 70154
70275: POP
70276: POP
// result := array ;
70277: LD_ADDR_VAR 0 5
70281: PUSH
70282: LD_VAR 0 1
70286: ST_TO_ADDR
// end ;
70287: LD_VAR 0 5
70291: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70292: LD_INT 0
70294: PPUSH
70295: PPUSH
// result := 0 ;
70296: LD_ADDR_VAR 0 3
70300: PUSH
70301: LD_INT 0
70303: ST_TO_ADDR
// if not array or not value in array then
70304: LD_VAR 0 1
70308: NOT
70309: PUSH
70310: LD_VAR 0 2
70314: PUSH
70315: LD_VAR 0 1
70319: IN
70320: NOT
70321: OR
70322: IFFALSE 70326
// exit ;
70324: GO 70380
// for i = 1 to array do
70326: LD_ADDR_VAR 0 4
70330: PUSH
70331: DOUBLE
70332: LD_INT 1
70334: DEC
70335: ST_TO_ADDR
70336: LD_VAR 0 1
70340: PUSH
70341: FOR_TO
70342: IFFALSE 70378
// if value = array [ i ] then
70344: LD_VAR 0 2
70348: PUSH
70349: LD_VAR 0 1
70353: PUSH
70354: LD_VAR 0 4
70358: ARRAY
70359: EQUAL
70360: IFFALSE 70376
// begin result := i ;
70362: LD_ADDR_VAR 0 3
70366: PUSH
70367: LD_VAR 0 4
70371: ST_TO_ADDR
// exit ;
70372: POP
70373: POP
70374: GO 70380
// end ;
70376: GO 70341
70378: POP
70379: POP
// end ;
70380: LD_VAR 0 3
70384: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70385: LD_INT 0
70387: PPUSH
// vc_chassis := chassis ;
70388: LD_ADDR_OWVAR 37
70392: PUSH
70393: LD_VAR 0 1
70397: ST_TO_ADDR
// vc_engine := engine ;
70398: LD_ADDR_OWVAR 39
70402: PUSH
70403: LD_VAR 0 2
70407: ST_TO_ADDR
// vc_control := control ;
70408: LD_ADDR_OWVAR 38
70412: PUSH
70413: LD_VAR 0 3
70417: ST_TO_ADDR
// vc_weapon := weapon ;
70418: LD_ADDR_OWVAR 40
70422: PUSH
70423: LD_VAR 0 4
70427: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70428: LD_ADDR_OWVAR 41
70432: PUSH
70433: LD_VAR 0 5
70437: ST_TO_ADDR
// end ;
70438: LD_VAR 0 6
70442: RET
// export function WantPlant ( unit ) ; var task ; begin
70443: LD_INT 0
70445: PPUSH
70446: PPUSH
// result := false ;
70447: LD_ADDR_VAR 0 2
70451: PUSH
70452: LD_INT 0
70454: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70455: LD_ADDR_VAR 0 3
70459: PUSH
70460: LD_VAR 0 1
70464: PPUSH
70465: CALL_OW 437
70469: ST_TO_ADDR
// if task then
70470: LD_VAR 0 3
70474: IFFALSE 70502
// if task [ 1 ] [ 1 ] = p then
70476: LD_VAR 0 3
70480: PUSH
70481: LD_INT 1
70483: ARRAY
70484: PUSH
70485: LD_INT 1
70487: ARRAY
70488: PUSH
70489: LD_STRING p
70491: EQUAL
70492: IFFALSE 70502
// result := true ;
70494: LD_ADDR_VAR 0 2
70498: PUSH
70499: LD_INT 1
70501: ST_TO_ADDR
// end ;
70502: LD_VAR 0 2
70506: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70507: LD_INT 0
70509: PPUSH
70510: PPUSH
70511: PPUSH
70512: PPUSH
// if pos < 1 then
70513: LD_VAR 0 2
70517: PUSH
70518: LD_INT 1
70520: LESS
70521: IFFALSE 70525
// exit ;
70523: GO 70828
// if pos = 1 then
70525: LD_VAR 0 2
70529: PUSH
70530: LD_INT 1
70532: EQUAL
70533: IFFALSE 70566
// result := Replace ( arr , pos [ 1 ] , value ) else
70535: LD_ADDR_VAR 0 4
70539: PUSH
70540: LD_VAR 0 1
70544: PPUSH
70545: LD_VAR 0 2
70549: PUSH
70550: LD_INT 1
70552: ARRAY
70553: PPUSH
70554: LD_VAR 0 3
70558: PPUSH
70559: CALL_OW 1
70563: ST_TO_ADDR
70564: GO 70828
// begin tmp := arr ;
70566: LD_ADDR_VAR 0 6
70570: PUSH
70571: LD_VAR 0 1
70575: ST_TO_ADDR
// s_arr := [ tmp ] ;
70576: LD_ADDR_VAR 0 7
70580: PUSH
70581: LD_VAR 0 6
70585: PUSH
70586: EMPTY
70587: LIST
70588: ST_TO_ADDR
// for i = 1 to pos - 1 do
70589: LD_ADDR_VAR 0 5
70593: PUSH
70594: DOUBLE
70595: LD_INT 1
70597: DEC
70598: ST_TO_ADDR
70599: LD_VAR 0 2
70603: PUSH
70604: LD_INT 1
70606: MINUS
70607: PUSH
70608: FOR_TO
70609: IFFALSE 70654
// begin tmp := tmp [ pos [ i ] ] ;
70611: LD_ADDR_VAR 0 6
70615: PUSH
70616: LD_VAR 0 6
70620: PUSH
70621: LD_VAR 0 2
70625: PUSH
70626: LD_VAR 0 5
70630: ARRAY
70631: ARRAY
70632: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70633: LD_ADDR_VAR 0 7
70637: PUSH
70638: LD_VAR 0 7
70642: PUSH
70643: LD_VAR 0 6
70647: PUSH
70648: EMPTY
70649: LIST
70650: ADD
70651: ST_TO_ADDR
// end ;
70652: GO 70608
70654: POP
70655: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70656: LD_ADDR_VAR 0 6
70660: PUSH
70661: LD_VAR 0 6
70665: PPUSH
70666: LD_VAR 0 2
70670: PUSH
70671: LD_VAR 0 2
70675: ARRAY
70676: PPUSH
70677: LD_VAR 0 3
70681: PPUSH
70682: CALL_OW 1
70686: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70687: LD_ADDR_VAR 0 7
70691: PUSH
70692: LD_VAR 0 7
70696: PPUSH
70697: LD_VAR 0 7
70701: PPUSH
70702: LD_VAR 0 6
70706: PPUSH
70707: CALL_OW 1
70711: ST_TO_ADDR
// for i = s_arr downto 2 do
70712: LD_ADDR_VAR 0 5
70716: PUSH
70717: DOUBLE
70718: LD_VAR 0 7
70722: INC
70723: ST_TO_ADDR
70724: LD_INT 2
70726: PUSH
70727: FOR_DOWNTO
70728: IFFALSE 70812
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70730: LD_ADDR_VAR 0 6
70734: PUSH
70735: LD_VAR 0 7
70739: PUSH
70740: LD_VAR 0 5
70744: PUSH
70745: LD_INT 1
70747: MINUS
70748: ARRAY
70749: PPUSH
70750: LD_VAR 0 2
70754: PUSH
70755: LD_VAR 0 5
70759: PUSH
70760: LD_INT 1
70762: MINUS
70763: ARRAY
70764: PPUSH
70765: LD_VAR 0 7
70769: PUSH
70770: LD_VAR 0 5
70774: ARRAY
70775: PPUSH
70776: CALL_OW 1
70780: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70781: LD_ADDR_VAR 0 7
70785: PUSH
70786: LD_VAR 0 7
70790: PPUSH
70791: LD_VAR 0 5
70795: PUSH
70796: LD_INT 1
70798: MINUS
70799: PPUSH
70800: LD_VAR 0 6
70804: PPUSH
70805: CALL_OW 1
70809: ST_TO_ADDR
// end ;
70810: GO 70727
70812: POP
70813: POP
// result := s_arr [ 1 ] ;
70814: LD_ADDR_VAR 0 4
70818: PUSH
70819: LD_VAR 0 7
70823: PUSH
70824: LD_INT 1
70826: ARRAY
70827: ST_TO_ADDR
// end ; end ;
70828: LD_VAR 0 4
70832: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70833: LD_INT 0
70835: PPUSH
70836: PPUSH
// if not list then
70837: LD_VAR 0 1
70841: NOT
70842: IFFALSE 70846
// exit ;
70844: GO 70937
// i := list [ pos1 ] ;
70846: LD_ADDR_VAR 0 5
70850: PUSH
70851: LD_VAR 0 1
70855: PUSH
70856: LD_VAR 0 2
70860: ARRAY
70861: ST_TO_ADDR
// if not i then
70862: LD_VAR 0 5
70866: NOT
70867: IFFALSE 70871
// exit ;
70869: GO 70937
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70871: LD_ADDR_VAR 0 1
70875: PUSH
70876: LD_VAR 0 1
70880: PPUSH
70881: LD_VAR 0 2
70885: PPUSH
70886: LD_VAR 0 1
70890: PUSH
70891: LD_VAR 0 3
70895: ARRAY
70896: PPUSH
70897: CALL_OW 1
70901: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70902: LD_ADDR_VAR 0 1
70906: PUSH
70907: LD_VAR 0 1
70911: PPUSH
70912: LD_VAR 0 3
70916: PPUSH
70917: LD_VAR 0 5
70921: PPUSH
70922: CALL_OW 1
70926: ST_TO_ADDR
// result := list ;
70927: LD_ADDR_VAR 0 4
70931: PUSH
70932: LD_VAR 0 1
70936: ST_TO_ADDR
// end ;
70937: LD_VAR 0 4
70941: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70942: LD_INT 0
70944: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70945: LD_ADDR_VAR 0 5
70949: PUSH
70950: LD_VAR 0 1
70954: PPUSH
70955: CALL_OW 250
70959: PPUSH
70960: LD_VAR 0 1
70964: PPUSH
70965: CALL_OW 251
70969: PPUSH
70970: LD_VAR 0 2
70974: PPUSH
70975: LD_VAR 0 3
70979: PPUSH
70980: LD_VAR 0 4
70984: PPUSH
70985: CALL 70995 0 5
70989: ST_TO_ADDR
// end ;
70990: LD_VAR 0 5
70994: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70995: LD_INT 0
70997: PPUSH
70998: PPUSH
70999: PPUSH
71000: PPUSH
// if not list then
71001: LD_VAR 0 3
71005: NOT
71006: IFFALSE 71010
// exit ;
71008: GO 71398
// result := [ ] ;
71010: LD_ADDR_VAR 0 6
71014: PUSH
71015: EMPTY
71016: ST_TO_ADDR
// for i in list do
71017: LD_ADDR_VAR 0 7
71021: PUSH
71022: LD_VAR 0 3
71026: PUSH
71027: FOR_IN
71028: IFFALSE 71230
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71030: LD_ADDR_VAR 0 9
71034: PUSH
71035: LD_VAR 0 7
71039: PPUSH
71040: LD_VAR 0 1
71044: PPUSH
71045: LD_VAR 0 2
71049: PPUSH
71050: CALL_OW 297
71054: ST_TO_ADDR
// if not result then
71055: LD_VAR 0 6
71059: NOT
71060: IFFALSE 71086
// result := [ [ i , tmp ] ] else
71062: LD_ADDR_VAR 0 6
71066: PUSH
71067: LD_VAR 0 7
71071: PUSH
71072: LD_VAR 0 9
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: EMPTY
71082: LIST
71083: ST_TO_ADDR
71084: GO 71228
// begin if result [ result ] [ 2 ] < tmp then
71086: LD_VAR 0 6
71090: PUSH
71091: LD_VAR 0 6
71095: ARRAY
71096: PUSH
71097: LD_INT 2
71099: ARRAY
71100: PUSH
71101: LD_VAR 0 9
71105: LESS
71106: IFFALSE 71148
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71108: LD_ADDR_VAR 0 6
71112: PUSH
71113: LD_VAR 0 6
71117: PPUSH
71118: LD_VAR 0 6
71122: PUSH
71123: LD_INT 1
71125: PLUS
71126: PPUSH
71127: LD_VAR 0 7
71131: PUSH
71132: LD_VAR 0 9
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PPUSH
71141: CALL_OW 2
71145: ST_TO_ADDR
71146: GO 71228
// for j = 1 to result do
71148: LD_ADDR_VAR 0 8
71152: PUSH
71153: DOUBLE
71154: LD_INT 1
71156: DEC
71157: ST_TO_ADDR
71158: LD_VAR 0 6
71162: PUSH
71163: FOR_TO
71164: IFFALSE 71226
// begin if tmp < result [ j ] [ 2 ] then
71166: LD_VAR 0 9
71170: PUSH
71171: LD_VAR 0 6
71175: PUSH
71176: LD_VAR 0 8
71180: ARRAY
71181: PUSH
71182: LD_INT 2
71184: ARRAY
71185: LESS
71186: IFFALSE 71224
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71188: LD_ADDR_VAR 0 6
71192: PUSH
71193: LD_VAR 0 6
71197: PPUSH
71198: LD_VAR 0 8
71202: PPUSH
71203: LD_VAR 0 7
71207: PUSH
71208: LD_VAR 0 9
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PPUSH
71217: CALL_OW 2
71221: ST_TO_ADDR
// break ;
71222: GO 71226
// end ; end ;
71224: GO 71163
71226: POP
71227: POP
// end ; end ;
71228: GO 71027
71230: POP
71231: POP
// if result and not asc then
71232: LD_VAR 0 6
71236: PUSH
71237: LD_VAR 0 4
71241: NOT
71242: AND
71243: IFFALSE 71318
// begin tmp := result ;
71245: LD_ADDR_VAR 0 9
71249: PUSH
71250: LD_VAR 0 6
71254: ST_TO_ADDR
// for i = tmp downto 1 do
71255: LD_ADDR_VAR 0 7
71259: PUSH
71260: DOUBLE
71261: LD_VAR 0 9
71265: INC
71266: ST_TO_ADDR
71267: LD_INT 1
71269: PUSH
71270: FOR_DOWNTO
71271: IFFALSE 71316
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71273: LD_ADDR_VAR 0 6
71277: PUSH
71278: LD_VAR 0 6
71282: PPUSH
71283: LD_VAR 0 9
71287: PUSH
71288: LD_VAR 0 7
71292: MINUS
71293: PUSH
71294: LD_INT 1
71296: PLUS
71297: PPUSH
71298: LD_VAR 0 9
71302: PUSH
71303: LD_VAR 0 7
71307: ARRAY
71308: PPUSH
71309: CALL_OW 1
71313: ST_TO_ADDR
71314: GO 71270
71316: POP
71317: POP
// end ; tmp := [ ] ;
71318: LD_ADDR_VAR 0 9
71322: PUSH
71323: EMPTY
71324: ST_TO_ADDR
// if mode then
71325: LD_VAR 0 5
71329: IFFALSE 71398
// begin for i = 1 to result do
71331: LD_ADDR_VAR 0 7
71335: PUSH
71336: DOUBLE
71337: LD_INT 1
71339: DEC
71340: ST_TO_ADDR
71341: LD_VAR 0 6
71345: PUSH
71346: FOR_TO
71347: IFFALSE 71386
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71349: LD_ADDR_VAR 0 9
71353: PUSH
71354: LD_VAR 0 9
71358: PPUSH
71359: LD_VAR 0 7
71363: PPUSH
71364: LD_VAR 0 6
71368: PUSH
71369: LD_VAR 0 7
71373: ARRAY
71374: PUSH
71375: LD_INT 1
71377: ARRAY
71378: PPUSH
71379: CALL_OW 1
71383: ST_TO_ADDR
71384: GO 71346
71386: POP
71387: POP
// result := tmp ;
71388: LD_ADDR_VAR 0 6
71392: PUSH
71393: LD_VAR 0 9
71397: ST_TO_ADDR
// end ; end ;
71398: LD_VAR 0 6
71402: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71403: LD_INT 0
71405: PPUSH
71406: PPUSH
71407: PPUSH
71408: PPUSH
71409: PPUSH
71410: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71411: LD_ADDR_VAR 0 5
71415: PUSH
71416: LD_INT 0
71418: PUSH
71419: LD_INT 0
71421: PUSH
71422: LD_INT 0
71424: PUSH
71425: EMPTY
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: ST_TO_ADDR
// if not x or not y then
71433: LD_VAR 0 2
71437: NOT
71438: PUSH
71439: LD_VAR 0 3
71443: NOT
71444: OR
71445: IFFALSE 71449
// exit ;
71447: GO 73095
// if not range then
71449: LD_VAR 0 4
71453: NOT
71454: IFFALSE 71464
// range := 10 ;
71456: LD_ADDR_VAR 0 4
71460: PUSH
71461: LD_INT 10
71463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71464: LD_ADDR_VAR 0 8
71468: PUSH
71469: LD_INT 81
71471: PUSH
71472: LD_VAR 0 1
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 92
71483: PUSH
71484: LD_VAR 0 2
71488: PUSH
71489: LD_VAR 0 3
71493: PUSH
71494: LD_VAR 0 4
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 3
71507: PUSH
71508: LD_INT 21
71510: PUSH
71511: LD_INT 3
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: LIST
71526: PPUSH
71527: CALL_OW 69
71531: ST_TO_ADDR
// if not tmp then
71532: LD_VAR 0 8
71536: NOT
71537: IFFALSE 71541
// exit ;
71539: GO 73095
// for i in tmp do
71541: LD_ADDR_VAR 0 6
71545: PUSH
71546: LD_VAR 0 8
71550: PUSH
71551: FOR_IN
71552: IFFALSE 73070
// begin points := [ 0 , 0 , 0 ] ;
71554: LD_ADDR_VAR 0 9
71558: PUSH
71559: LD_INT 0
71561: PUSH
71562: LD_INT 0
71564: PUSH
71565: LD_INT 0
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: LIST
71572: ST_TO_ADDR
// bpoints := 1 ;
71573: LD_ADDR_VAR 0 10
71577: PUSH
71578: LD_INT 1
71580: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71581: LD_VAR 0 6
71585: PPUSH
71586: CALL_OW 247
71590: PUSH
71591: LD_INT 1
71593: DOUBLE
71594: EQUAL
71595: IFTRUE 71599
71597: GO 72177
71599: POP
// begin if GetClass ( i ) = 1 then
71600: LD_VAR 0 6
71604: PPUSH
71605: CALL_OW 257
71609: PUSH
71610: LD_INT 1
71612: EQUAL
71613: IFFALSE 71634
// points := [ 10 , 5 , 3 ] ;
71615: LD_ADDR_VAR 0 9
71619: PUSH
71620: LD_INT 10
71622: PUSH
71623: LD_INT 5
71625: PUSH
71626: LD_INT 3
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: LIST
71633: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71634: LD_VAR 0 6
71638: PPUSH
71639: CALL_OW 257
71643: PUSH
71644: LD_INT 2
71646: PUSH
71647: LD_INT 3
71649: PUSH
71650: LD_INT 4
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: LIST
71657: IN
71658: IFFALSE 71679
// points := [ 3 , 2 , 1 ] ;
71660: LD_ADDR_VAR 0 9
71664: PUSH
71665: LD_INT 3
71667: PUSH
71668: LD_INT 2
71670: PUSH
71671: LD_INT 1
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: LIST
71678: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71679: LD_VAR 0 6
71683: PPUSH
71684: CALL_OW 257
71688: PUSH
71689: LD_INT 5
71691: EQUAL
71692: IFFALSE 71713
// points := [ 130 , 5 , 2 ] ;
71694: LD_ADDR_VAR 0 9
71698: PUSH
71699: LD_INT 130
71701: PUSH
71702: LD_INT 5
71704: PUSH
71705: LD_INT 2
71707: PUSH
71708: EMPTY
71709: LIST
71710: LIST
71711: LIST
71712: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71713: LD_VAR 0 6
71717: PPUSH
71718: CALL_OW 257
71722: PUSH
71723: LD_INT 8
71725: EQUAL
71726: IFFALSE 71747
// points := [ 35 , 35 , 30 ] ;
71728: LD_ADDR_VAR 0 9
71732: PUSH
71733: LD_INT 35
71735: PUSH
71736: LD_INT 35
71738: PUSH
71739: LD_INT 30
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: LIST
71746: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71747: LD_VAR 0 6
71751: PPUSH
71752: CALL_OW 257
71756: PUSH
71757: LD_INT 9
71759: EQUAL
71760: IFFALSE 71781
// points := [ 20 , 55 , 40 ] ;
71762: LD_ADDR_VAR 0 9
71766: PUSH
71767: LD_INT 20
71769: PUSH
71770: LD_INT 55
71772: PUSH
71773: LD_INT 40
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: LIST
71780: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71781: LD_VAR 0 6
71785: PPUSH
71786: CALL_OW 257
71790: PUSH
71791: LD_INT 12
71793: PUSH
71794: LD_INT 16
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: IN
71801: IFFALSE 71822
// points := [ 5 , 3 , 2 ] ;
71803: LD_ADDR_VAR 0 9
71807: PUSH
71808: LD_INT 5
71810: PUSH
71811: LD_INT 3
71813: PUSH
71814: LD_INT 2
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: LIST
71821: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71822: LD_VAR 0 6
71826: PPUSH
71827: CALL_OW 257
71831: PUSH
71832: LD_INT 17
71834: EQUAL
71835: IFFALSE 71856
// points := [ 100 , 50 , 75 ] ;
71837: LD_ADDR_VAR 0 9
71841: PUSH
71842: LD_INT 100
71844: PUSH
71845: LD_INT 50
71847: PUSH
71848: LD_INT 75
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: LIST
71855: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71856: LD_VAR 0 6
71860: PPUSH
71861: CALL_OW 257
71865: PUSH
71866: LD_INT 15
71868: EQUAL
71869: IFFALSE 71890
// points := [ 10 , 5 , 3 ] ;
71871: LD_ADDR_VAR 0 9
71875: PUSH
71876: LD_INT 10
71878: PUSH
71879: LD_INT 5
71881: PUSH
71882: LD_INT 3
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: LIST
71889: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71890: LD_VAR 0 6
71894: PPUSH
71895: CALL_OW 257
71899: PUSH
71900: LD_INT 14
71902: EQUAL
71903: IFFALSE 71924
// points := [ 10 , 0 , 0 ] ;
71905: LD_ADDR_VAR 0 9
71909: PUSH
71910: LD_INT 10
71912: PUSH
71913: LD_INT 0
71915: PUSH
71916: LD_INT 0
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: LIST
71923: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71924: LD_VAR 0 6
71928: PPUSH
71929: CALL_OW 257
71933: PUSH
71934: LD_INT 11
71936: EQUAL
71937: IFFALSE 71958
// points := [ 30 , 10 , 5 ] ;
71939: LD_ADDR_VAR 0 9
71943: PUSH
71944: LD_INT 30
71946: PUSH
71947: LD_INT 10
71949: PUSH
71950: LD_INT 5
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: LIST
71957: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71958: LD_VAR 0 1
71962: PPUSH
71963: LD_INT 5
71965: PPUSH
71966: CALL_OW 321
71970: PUSH
71971: LD_INT 2
71973: EQUAL
71974: IFFALSE 71991
// bpoints := bpoints * 1.8 ;
71976: LD_ADDR_VAR 0 10
71980: PUSH
71981: LD_VAR 0 10
71985: PUSH
71986: LD_REAL  1.80000000000000E+0000
71989: MUL
71990: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71991: LD_VAR 0 6
71995: PPUSH
71996: CALL_OW 257
72000: PUSH
72001: LD_INT 1
72003: PUSH
72004: LD_INT 2
72006: PUSH
72007: LD_INT 3
72009: PUSH
72010: LD_INT 4
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: LIST
72017: LIST
72018: IN
72019: PUSH
72020: LD_VAR 0 1
72024: PPUSH
72025: LD_INT 51
72027: PPUSH
72028: CALL_OW 321
72032: PUSH
72033: LD_INT 2
72035: EQUAL
72036: AND
72037: IFFALSE 72054
// bpoints := bpoints * 1.2 ;
72039: LD_ADDR_VAR 0 10
72043: PUSH
72044: LD_VAR 0 10
72048: PUSH
72049: LD_REAL  1.20000000000000E+0000
72052: MUL
72053: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72054: LD_VAR 0 6
72058: PPUSH
72059: CALL_OW 257
72063: PUSH
72064: LD_INT 5
72066: PUSH
72067: LD_INT 7
72069: PUSH
72070: LD_INT 9
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: LIST
72077: IN
72078: PUSH
72079: LD_VAR 0 1
72083: PPUSH
72084: LD_INT 52
72086: PPUSH
72087: CALL_OW 321
72091: PUSH
72092: LD_INT 2
72094: EQUAL
72095: AND
72096: IFFALSE 72113
// bpoints := bpoints * 1.5 ;
72098: LD_ADDR_VAR 0 10
72102: PUSH
72103: LD_VAR 0 10
72107: PUSH
72108: LD_REAL  1.50000000000000E+0000
72111: MUL
72112: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72113: LD_VAR 0 1
72117: PPUSH
72118: LD_INT 66
72120: PPUSH
72121: CALL_OW 321
72125: PUSH
72126: LD_INT 2
72128: EQUAL
72129: IFFALSE 72146
// bpoints := bpoints * 1.1 ;
72131: LD_ADDR_VAR 0 10
72135: PUSH
72136: LD_VAR 0 10
72140: PUSH
72141: LD_REAL  1.10000000000000E+0000
72144: MUL
72145: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72146: LD_ADDR_VAR 0 10
72150: PUSH
72151: LD_VAR 0 10
72155: PUSH
72156: LD_VAR 0 6
72160: PPUSH
72161: LD_INT 1
72163: PPUSH
72164: CALL_OW 259
72168: PUSH
72169: LD_REAL  1.15000000000000E+0000
72172: MUL
72173: MUL
72174: ST_TO_ADDR
// end ; unit_vehicle :
72175: GO 72999
72177: LD_INT 2
72179: DOUBLE
72180: EQUAL
72181: IFTRUE 72185
72183: GO 72987
72185: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72186: LD_VAR 0 6
72190: PPUSH
72191: CALL_OW 264
72195: PUSH
72196: LD_INT 2
72198: PUSH
72199: LD_INT 42
72201: PUSH
72202: LD_INT 24
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: LIST
72209: IN
72210: IFFALSE 72231
// points := [ 25 , 5 , 3 ] ;
72212: LD_ADDR_VAR 0 9
72216: PUSH
72217: LD_INT 25
72219: PUSH
72220: LD_INT 5
72222: PUSH
72223: LD_INT 3
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: LIST
72230: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72231: LD_VAR 0 6
72235: PPUSH
72236: CALL_OW 264
72240: PUSH
72241: LD_INT 4
72243: PUSH
72244: LD_INT 43
72246: PUSH
72247: LD_INT 25
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: LIST
72254: IN
72255: IFFALSE 72276
// points := [ 40 , 15 , 5 ] ;
72257: LD_ADDR_VAR 0 9
72261: PUSH
72262: LD_INT 40
72264: PUSH
72265: LD_INT 15
72267: PUSH
72268: LD_INT 5
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: LIST
72275: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72276: LD_VAR 0 6
72280: PPUSH
72281: CALL_OW 264
72285: PUSH
72286: LD_INT 3
72288: PUSH
72289: LD_INT 23
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: IN
72296: IFFALSE 72317
// points := [ 7 , 25 , 8 ] ;
72298: LD_ADDR_VAR 0 9
72302: PUSH
72303: LD_INT 7
72305: PUSH
72306: LD_INT 25
72308: PUSH
72309: LD_INT 8
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: LIST
72316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72317: LD_VAR 0 6
72321: PPUSH
72322: CALL_OW 264
72326: PUSH
72327: LD_INT 5
72329: PUSH
72330: LD_INT 27
72332: PUSH
72333: LD_INT 44
72335: PUSH
72336: EMPTY
72337: LIST
72338: LIST
72339: LIST
72340: IN
72341: IFFALSE 72362
// points := [ 14 , 50 , 16 ] ;
72343: LD_ADDR_VAR 0 9
72347: PUSH
72348: LD_INT 14
72350: PUSH
72351: LD_INT 50
72353: PUSH
72354: LD_INT 16
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: LIST
72361: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72362: LD_VAR 0 6
72366: PPUSH
72367: CALL_OW 264
72371: PUSH
72372: LD_INT 6
72374: PUSH
72375: LD_INT 46
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: IN
72382: IFFALSE 72403
// points := [ 32 , 120 , 70 ] ;
72384: LD_ADDR_VAR 0 9
72388: PUSH
72389: LD_INT 32
72391: PUSH
72392: LD_INT 120
72394: PUSH
72395: LD_INT 70
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: LIST
72402: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
72403: LD_VAR 0 6
72407: PPUSH
72408: CALL_OW 264
72412: PUSH
72413: LD_INT 7
72415: PUSH
72416: LD_INT 28
72418: PUSH
72419: LD_INT 45
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: LIST
72426: IN
72427: IFFALSE 72448
// points := [ 35 , 20 , 45 ] ;
72429: LD_ADDR_VAR 0 9
72433: PUSH
72434: LD_INT 35
72436: PUSH
72437: LD_INT 20
72439: PUSH
72440: LD_INT 45
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: LIST
72447: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72448: LD_VAR 0 6
72452: PPUSH
72453: CALL_OW 264
72457: PUSH
72458: LD_INT 47
72460: PUSH
72461: EMPTY
72462: LIST
72463: IN
72464: IFFALSE 72485
// points := [ 67 , 45 , 75 ] ;
72466: LD_ADDR_VAR 0 9
72470: PUSH
72471: LD_INT 67
72473: PUSH
72474: LD_INT 45
72476: PUSH
72477: LD_INT 75
72479: PUSH
72480: EMPTY
72481: LIST
72482: LIST
72483: LIST
72484: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72485: LD_VAR 0 6
72489: PPUSH
72490: CALL_OW 264
72494: PUSH
72495: LD_INT 26
72497: PUSH
72498: EMPTY
72499: LIST
72500: IN
72501: IFFALSE 72522
// points := [ 120 , 30 , 80 ] ;
72503: LD_ADDR_VAR 0 9
72507: PUSH
72508: LD_INT 120
72510: PUSH
72511: LD_INT 30
72513: PUSH
72514: LD_INT 80
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: LIST
72521: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72522: LD_VAR 0 6
72526: PPUSH
72527: CALL_OW 264
72531: PUSH
72532: LD_INT 22
72534: PUSH
72535: EMPTY
72536: LIST
72537: IN
72538: IFFALSE 72559
// points := [ 40 , 1 , 1 ] ;
72540: LD_ADDR_VAR 0 9
72544: PUSH
72545: LD_INT 40
72547: PUSH
72548: LD_INT 1
72550: PUSH
72551: LD_INT 1
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: LIST
72558: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72559: LD_VAR 0 6
72563: PPUSH
72564: CALL_OW 264
72568: PUSH
72569: LD_INT 29
72571: PUSH
72572: EMPTY
72573: LIST
72574: IN
72575: IFFALSE 72596
// points := [ 70 , 200 , 400 ] ;
72577: LD_ADDR_VAR 0 9
72581: PUSH
72582: LD_INT 70
72584: PUSH
72585: LD_INT 200
72587: PUSH
72588: LD_INT 400
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: LIST
72595: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72596: LD_VAR 0 6
72600: PPUSH
72601: CALL_OW 264
72605: PUSH
72606: LD_INT 14
72608: PUSH
72609: LD_INT 53
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: IN
72616: IFFALSE 72637
// points := [ 40 , 10 , 20 ] ;
72618: LD_ADDR_VAR 0 9
72622: PUSH
72623: LD_INT 40
72625: PUSH
72626: LD_INT 10
72628: PUSH
72629: LD_INT 20
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: LIST
72636: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72637: LD_VAR 0 6
72641: PPUSH
72642: CALL_OW 264
72646: PUSH
72647: LD_INT 9
72649: PUSH
72650: EMPTY
72651: LIST
72652: IN
72653: IFFALSE 72674
// points := [ 5 , 70 , 20 ] ;
72655: LD_ADDR_VAR 0 9
72659: PUSH
72660: LD_INT 5
72662: PUSH
72663: LD_INT 70
72665: PUSH
72666: LD_INT 20
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: LIST
72673: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72674: LD_VAR 0 6
72678: PPUSH
72679: CALL_OW 264
72683: PUSH
72684: LD_INT 10
72686: PUSH
72687: EMPTY
72688: LIST
72689: IN
72690: IFFALSE 72711
// points := [ 35 , 110 , 70 ] ;
72692: LD_ADDR_VAR 0 9
72696: PUSH
72697: LD_INT 35
72699: PUSH
72700: LD_INT 110
72702: PUSH
72703: LD_INT 70
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: LIST
72710: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72711: LD_VAR 0 6
72715: PPUSH
72716: CALL_OW 265
72720: PUSH
72721: LD_INT 25
72723: EQUAL
72724: IFFALSE 72745
// points := [ 80 , 65 , 100 ] ;
72726: LD_ADDR_VAR 0 9
72730: PUSH
72731: LD_INT 80
72733: PUSH
72734: LD_INT 65
72736: PUSH
72737: LD_INT 100
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: LIST
72744: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72745: LD_VAR 0 6
72749: PPUSH
72750: CALL_OW 263
72754: PUSH
72755: LD_INT 1
72757: EQUAL
72758: IFFALSE 72793
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72760: LD_ADDR_VAR 0 10
72764: PUSH
72765: LD_VAR 0 10
72769: PUSH
72770: LD_VAR 0 6
72774: PPUSH
72775: CALL_OW 311
72779: PPUSH
72780: LD_INT 3
72782: PPUSH
72783: CALL_OW 259
72787: PUSH
72788: LD_INT 4
72790: MUL
72791: MUL
72792: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72793: LD_VAR 0 6
72797: PPUSH
72798: CALL_OW 263
72802: PUSH
72803: LD_INT 2
72805: EQUAL
72806: IFFALSE 72857
// begin j := IsControledBy ( i ) ;
72808: LD_ADDR_VAR 0 7
72812: PUSH
72813: LD_VAR 0 6
72817: PPUSH
72818: CALL_OW 312
72822: ST_TO_ADDR
// if j then
72823: LD_VAR 0 7
72827: IFFALSE 72857
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72829: LD_ADDR_VAR 0 10
72833: PUSH
72834: LD_VAR 0 10
72838: PUSH
72839: LD_VAR 0 7
72843: PPUSH
72844: LD_INT 3
72846: PPUSH
72847: CALL_OW 259
72851: PUSH
72852: LD_INT 3
72854: MUL
72855: MUL
72856: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72857: LD_VAR 0 6
72861: PPUSH
72862: CALL_OW 264
72866: PUSH
72867: LD_INT 5
72869: PUSH
72870: LD_INT 6
72872: PUSH
72873: LD_INT 46
72875: PUSH
72876: LD_INT 44
72878: PUSH
72879: LD_INT 47
72881: PUSH
72882: LD_INT 45
72884: PUSH
72885: LD_INT 28
72887: PUSH
72888: LD_INT 7
72890: PUSH
72891: LD_INT 27
72893: PUSH
72894: LD_INT 29
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: LIST
72901: LIST
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: LIST
72908: IN
72909: PUSH
72910: LD_VAR 0 1
72914: PPUSH
72915: LD_INT 52
72917: PPUSH
72918: CALL_OW 321
72922: PUSH
72923: LD_INT 2
72925: EQUAL
72926: AND
72927: IFFALSE 72944
// bpoints := bpoints * 1.2 ;
72929: LD_ADDR_VAR 0 10
72933: PUSH
72934: LD_VAR 0 10
72938: PUSH
72939: LD_REAL  1.20000000000000E+0000
72942: MUL
72943: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72944: LD_VAR 0 6
72948: PPUSH
72949: CALL_OW 264
72953: PUSH
72954: LD_INT 6
72956: PUSH
72957: LD_INT 46
72959: PUSH
72960: LD_INT 47
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: LIST
72967: IN
72968: IFFALSE 72985
// bpoints := bpoints * 1.2 ;
72970: LD_ADDR_VAR 0 10
72974: PUSH
72975: LD_VAR 0 10
72979: PUSH
72980: LD_REAL  1.20000000000000E+0000
72983: MUL
72984: ST_TO_ADDR
// end ; unit_building :
72985: GO 72999
72987: LD_INT 3
72989: DOUBLE
72990: EQUAL
72991: IFTRUE 72995
72993: GO 72998
72995: POP
// ; end ;
72996: GO 72999
72998: POP
// for j = 1 to 3 do
72999: LD_ADDR_VAR 0 7
73003: PUSH
73004: DOUBLE
73005: LD_INT 1
73007: DEC
73008: ST_TO_ADDR
73009: LD_INT 3
73011: PUSH
73012: FOR_TO
73013: IFFALSE 73066
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73015: LD_ADDR_VAR 0 5
73019: PUSH
73020: LD_VAR 0 5
73024: PPUSH
73025: LD_VAR 0 7
73029: PPUSH
73030: LD_VAR 0 5
73034: PUSH
73035: LD_VAR 0 7
73039: ARRAY
73040: PUSH
73041: LD_VAR 0 9
73045: PUSH
73046: LD_VAR 0 7
73050: ARRAY
73051: PUSH
73052: LD_VAR 0 10
73056: MUL
73057: PLUS
73058: PPUSH
73059: CALL_OW 1
73063: ST_TO_ADDR
73064: GO 73012
73066: POP
73067: POP
// end ;
73068: GO 71551
73070: POP
73071: POP
// result := Replace ( result , 4 , tmp ) ;
73072: LD_ADDR_VAR 0 5
73076: PUSH
73077: LD_VAR 0 5
73081: PPUSH
73082: LD_INT 4
73084: PPUSH
73085: LD_VAR 0 8
73089: PPUSH
73090: CALL_OW 1
73094: ST_TO_ADDR
// end ;
73095: LD_VAR 0 5
73099: RET
// export function DangerAtRange ( unit , range ) ; begin
73100: LD_INT 0
73102: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73103: LD_ADDR_VAR 0 3
73107: PUSH
73108: LD_VAR 0 1
73112: PPUSH
73113: CALL_OW 255
73117: PPUSH
73118: LD_VAR 0 1
73122: PPUSH
73123: CALL_OW 250
73127: PPUSH
73128: LD_VAR 0 1
73132: PPUSH
73133: CALL_OW 251
73137: PPUSH
73138: LD_VAR 0 2
73142: PPUSH
73143: CALL 71403 0 4
73147: ST_TO_ADDR
// end ;
73148: LD_VAR 0 3
73152: RET
// export function DangerInArea ( side , area ) ; begin
73153: LD_INT 0
73155: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73156: LD_ADDR_VAR 0 3
73160: PUSH
73161: LD_VAR 0 2
73165: PPUSH
73166: LD_INT 81
73168: PUSH
73169: LD_VAR 0 1
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PPUSH
73178: CALL_OW 70
73182: ST_TO_ADDR
// end ;
73183: LD_VAR 0 3
73187: RET
// export function IsExtension ( b ) ; begin
73188: LD_INT 0
73190: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73191: LD_ADDR_VAR 0 2
73195: PUSH
73196: LD_VAR 0 1
73200: PUSH
73201: LD_INT 23
73203: PUSH
73204: LD_INT 20
73206: PUSH
73207: LD_INT 22
73209: PUSH
73210: LD_INT 17
73212: PUSH
73213: LD_INT 24
73215: PUSH
73216: LD_INT 21
73218: PUSH
73219: LD_INT 19
73221: PUSH
73222: LD_INT 16
73224: PUSH
73225: LD_INT 25
73227: PUSH
73228: LD_INT 18
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: IN
73243: ST_TO_ADDR
// end ;
73244: LD_VAR 0 2
73248: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
73249: LD_INT 0
73251: PPUSH
73252: PPUSH
73253: PPUSH
// result := [ ] ;
73254: LD_ADDR_VAR 0 3
73258: PUSH
73259: EMPTY
73260: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73261: LD_ADDR_VAR 0 4
73265: PUSH
73266: LD_VAR 0 2
73270: PPUSH
73271: LD_INT 21
73273: PUSH
73274: LD_INT 3
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PPUSH
73281: CALL_OW 70
73285: ST_TO_ADDR
// if not tmp then
73286: LD_VAR 0 4
73290: NOT
73291: IFFALSE 73295
// exit ;
73293: GO 73353
// for i in tmp do
73295: LD_ADDR_VAR 0 5
73299: PUSH
73300: LD_VAR 0 4
73304: PUSH
73305: FOR_IN
73306: IFFALSE 73341
// if GetBase ( i ) <> base then
73308: LD_VAR 0 5
73312: PPUSH
73313: CALL_OW 274
73317: PUSH
73318: LD_VAR 0 1
73322: NONEQUAL
73323: IFFALSE 73339
// ComLinkToBase ( base , i ) ;
73325: LD_VAR 0 1
73329: PPUSH
73330: LD_VAR 0 5
73334: PPUSH
73335: CALL_OW 169
73339: GO 73305
73341: POP
73342: POP
// result := tmp ;
73343: LD_ADDR_VAR 0 3
73347: PUSH
73348: LD_VAR 0 4
73352: ST_TO_ADDR
// end ;
73353: LD_VAR 0 3
73357: RET
// export function ComComplete ( unit , b ) ; var i ; begin
73358: LD_INT 0
73360: PPUSH
73361: PPUSH
// if BuildingStatus ( b ) = bs_build then
73362: LD_VAR 0 2
73366: PPUSH
73367: CALL_OW 461
73371: PUSH
73372: LD_INT 1
73374: EQUAL
73375: IFFALSE 73435
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73377: LD_VAR 0 1
73381: PPUSH
73382: LD_STRING h
73384: PUSH
73385: LD_VAR 0 2
73389: PPUSH
73390: CALL_OW 250
73394: PUSH
73395: LD_VAR 0 2
73399: PPUSH
73400: CALL_OW 251
73404: PUSH
73405: LD_VAR 0 2
73409: PUSH
73410: LD_INT 0
73412: PUSH
73413: LD_INT 0
73415: PUSH
73416: LD_INT 0
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: LIST
73423: LIST
73424: LIST
73425: LIST
73426: LIST
73427: PUSH
73428: EMPTY
73429: LIST
73430: PPUSH
73431: CALL_OW 446
// end ;
73435: LD_VAR 0 3
73439: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73440: LD_INT 0
73442: PPUSH
73443: PPUSH
73444: PPUSH
73445: PPUSH
73446: PPUSH
73447: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73448: LD_VAR 0 1
73452: NOT
73453: PUSH
73454: LD_VAR 0 1
73458: PPUSH
73459: CALL_OW 263
73463: PUSH
73464: LD_INT 2
73466: EQUAL
73467: NOT
73468: OR
73469: IFFALSE 73473
// exit ;
73471: GO 73789
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73473: LD_ADDR_VAR 0 6
73477: PUSH
73478: LD_INT 22
73480: PUSH
73481: LD_VAR 0 1
73485: PPUSH
73486: CALL_OW 255
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 2
73497: PUSH
73498: LD_INT 30
73500: PUSH
73501: LD_INT 36
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 34
73510: PUSH
73511: LD_INT 31
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: LIST
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PPUSH
73527: CALL_OW 69
73531: ST_TO_ADDR
// if not tmp then
73532: LD_VAR 0 6
73536: NOT
73537: IFFALSE 73541
// exit ;
73539: GO 73789
// result := [ ] ;
73541: LD_ADDR_VAR 0 2
73545: PUSH
73546: EMPTY
73547: ST_TO_ADDR
// for i in tmp do
73548: LD_ADDR_VAR 0 3
73552: PUSH
73553: LD_VAR 0 6
73557: PUSH
73558: FOR_IN
73559: IFFALSE 73630
// begin t := UnitsInside ( i ) ;
73561: LD_ADDR_VAR 0 4
73565: PUSH
73566: LD_VAR 0 3
73570: PPUSH
73571: CALL_OW 313
73575: ST_TO_ADDR
// if t then
73576: LD_VAR 0 4
73580: IFFALSE 73628
// for j in t do
73582: LD_ADDR_VAR 0 7
73586: PUSH
73587: LD_VAR 0 4
73591: PUSH
73592: FOR_IN
73593: IFFALSE 73626
// result := Insert ( result , result + 1 , j ) ;
73595: LD_ADDR_VAR 0 2
73599: PUSH
73600: LD_VAR 0 2
73604: PPUSH
73605: LD_VAR 0 2
73609: PUSH
73610: LD_INT 1
73612: PLUS
73613: PPUSH
73614: LD_VAR 0 7
73618: PPUSH
73619: CALL_OW 2
73623: ST_TO_ADDR
73624: GO 73592
73626: POP
73627: POP
// end ;
73628: GO 73558
73630: POP
73631: POP
// if not result then
73632: LD_VAR 0 2
73636: NOT
73637: IFFALSE 73641
// exit ;
73639: GO 73789
// mech := result [ 1 ] ;
73641: LD_ADDR_VAR 0 5
73645: PUSH
73646: LD_VAR 0 2
73650: PUSH
73651: LD_INT 1
73653: ARRAY
73654: ST_TO_ADDR
// if result > 1 then
73655: LD_VAR 0 2
73659: PUSH
73660: LD_INT 1
73662: GREATER
73663: IFFALSE 73775
// for i = 2 to result do
73665: LD_ADDR_VAR 0 3
73669: PUSH
73670: DOUBLE
73671: LD_INT 2
73673: DEC
73674: ST_TO_ADDR
73675: LD_VAR 0 2
73679: PUSH
73680: FOR_TO
73681: IFFALSE 73773
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73683: LD_ADDR_VAR 0 4
73687: PUSH
73688: LD_VAR 0 2
73692: PUSH
73693: LD_VAR 0 3
73697: ARRAY
73698: PPUSH
73699: LD_INT 3
73701: PPUSH
73702: CALL_OW 259
73706: PUSH
73707: LD_VAR 0 2
73711: PUSH
73712: LD_VAR 0 3
73716: ARRAY
73717: PPUSH
73718: CALL_OW 432
73722: MINUS
73723: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73724: LD_VAR 0 4
73728: PUSH
73729: LD_VAR 0 5
73733: PPUSH
73734: LD_INT 3
73736: PPUSH
73737: CALL_OW 259
73741: PUSH
73742: LD_VAR 0 5
73746: PPUSH
73747: CALL_OW 432
73751: MINUS
73752: GREATEREQUAL
73753: IFFALSE 73771
// mech := result [ i ] ;
73755: LD_ADDR_VAR 0 5
73759: PUSH
73760: LD_VAR 0 2
73764: PUSH
73765: LD_VAR 0 3
73769: ARRAY
73770: ST_TO_ADDR
// end ;
73771: GO 73680
73773: POP
73774: POP
// ComLinkTo ( vehicle , mech ) ;
73775: LD_VAR 0 1
73779: PPUSH
73780: LD_VAR 0 5
73784: PPUSH
73785: CALL_OW 135
// end ;
73789: LD_VAR 0 2
73793: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73794: LD_INT 0
73796: PPUSH
73797: PPUSH
73798: PPUSH
73799: PPUSH
73800: PPUSH
73801: PPUSH
73802: PPUSH
73803: PPUSH
73804: PPUSH
73805: PPUSH
73806: PPUSH
73807: PPUSH
73808: PPUSH
// result := [ ] ;
73809: LD_ADDR_VAR 0 7
73813: PUSH
73814: EMPTY
73815: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73816: LD_VAR 0 1
73820: PPUSH
73821: CALL_OW 266
73825: PUSH
73826: LD_INT 0
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: IN
73836: NOT
73837: IFFALSE 73841
// exit ;
73839: GO 75472
// if name then
73841: LD_VAR 0 3
73845: IFFALSE 73861
// SetBName ( base_dep , name ) ;
73847: LD_VAR 0 1
73851: PPUSH
73852: LD_VAR 0 3
73856: PPUSH
73857: CALL_OW 500
// base := GetBase ( base_dep ) ;
73861: LD_ADDR_VAR 0 15
73865: PUSH
73866: LD_VAR 0 1
73870: PPUSH
73871: CALL_OW 274
73875: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73876: LD_ADDR_VAR 0 16
73880: PUSH
73881: LD_VAR 0 1
73885: PPUSH
73886: CALL_OW 255
73890: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73891: LD_ADDR_VAR 0 17
73895: PUSH
73896: LD_VAR 0 1
73900: PPUSH
73901: CALL_OW 248
73905: ST_TO_ADDR
// if sources then
73906: LD_VAR 0 5
73910: IFFALSE 73957
// for i = 1 to 3 do
73912: LD_ADDR_VAR 0 8
73916: PUSH
73917: DOUBLE
73918: LD_INT 1
73920: DEC
73921: ST_TO_ADDR
73922: LD_INT 3
73924: PUSH
73925: FOR_TO
73926: IFFALSE 73955
// AddResourceType ( base , i , sources [ i ] ) ;
73928: LD_VAR 0 15
73932: PPUSH
73933: LD_VAR 0 8
73937: PPUSH
73938: LD_VAR 0 5
73942: PUSH
73943: LD_VAR 0 8
73947: ARRAY
73948: PPUSH
73949: CALL_OW 276
73953: GO 73925
73955: POP
73956: POP
// buildings := GetBaseBuildings ( base , area ) ;
73957: LD_ADDR_VAR 0 18
73961: PUSH
73962: LD_VAR 0 15
73966: PPUSH
73967: LD_VAR 0 2
73971: PPUSH
73972: CALL 73249 0 2
73976: ST_TO_ADDR
// InitHc ;
73977: CALL_OW 19
// InitUc ;
73981: CALL_OW 18
// uc_side := side ;
73985: LD_ADDR_OWVAR 20
73989: PUSH
73990: LD_VAR 0 16
73994: ST_TO_ADDR
// uc_nation := nation ;
73995: LD_ADDR_OWVAR 21
73999: PUSH
74000: LD_VAR 0 17
74004: ST_TO_ADDR
// if buildings then
74005: LD_VAR 0 18
74009: IFFALSE 75331
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74011: LD_ADDR_VAR 0 19
74015: PUSH
74016: LD_VAR 0 18
74020: PPUSH
74021: LD_INT 2
74023: PUSH
74024: LD_INT 30
74026: PUSH
74027: LD_INT 29
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 30
74036: PUSH
74037: LD_INT 30
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: LIST
74048: PPUSH
74049: CALL_OW 72
74053: ST_TO_ADDR
// if tmp then
74054: LD_VAR 0 19
74058: IFFALSE 74106
// for i in tmp do
74060: LD_ADDR_VAR 0 8
74064: PUSH
74065: LD_VAR 0 19
74069: PUSH
74070: FOR_IN
74071: IFFALSE 74104
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74073: LD_VAR 0 8
74077: PPUSH
74078: CALL_OW 250
74082: PPUSH
74083: LD_VAR 0 8
74087: PPUSH
74088: CALL_OW 251
74092: PPUSH
74093: LD_VAR 0 16
74097: PPUSH
74098: CALL_OW 441
74102: GO 74070
74104: POP
74105: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74106: LD_VAR 0 18
74110: PPUSH
74111: LD_INT 2
74113: PUSH
74114: LD_INT 30
74116: PUSH
74117: LD_INT 32
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: PUSH
74124: LD_INT 30
74126: PUSH
74127: LD_INT 33
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: LIST
74138: PPUSH
74139: CALL_OW 72
74143: IFFALSE 74231
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74145: LD_ADDR_VAR 0 8
74149: PUSH
74150: LD_VAR 0 18
74154: PPUSH
74155: LD_INT 2
74157: PUSH
74158: LD_INT 30
74160: PUSH
74161: LD_INT 32
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 30
74170: PUSH
74171: LD_INT 33
74173: PUSH
74174: EMPTY
74175: LIST
74176: LIST
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: LIST
74182: PPUSH
74183: CALL_OW 72
74187: PUSH
74188: FOR_IN
74189: IFFALSE 74229
// begin if not GetBWeapon ( i ) then
74191: LD_VAR 0 8
74195: PPUSH
74196: CALL_OW 269
74200: NOT
74201: IFFALSE 74227
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74203: LD_VAR 0 8
74207: PPUSH
74208: LD_VAR 0 8
74212: PPUSH
74213: LD_VAR 0 2
74217: PPUSH
74218: CALL 75477 0 2
74222: PPUSH
74223: CALL_OW 431
// end ;
74227: GO 74188
74229: POP
74230: POP
// end ; for i = 1 to personel do
74231: LD_ADDR_VAR 0 8
74235: PUSH
74236: DOUBLE
74237: LD_INT 1
74239: DEC
74240: ST_TO_ADDR
74241: LD_VAR 0 6
74245: PUSH
74246: FOR_TO
74247: IFFALSE 75311
// begin if i > 4 then
74249: LD_VAR 0 8
74253: PUSH
74254: LD_INT 4
74256: GREATER
74257: IFFALSE 74261
// break ;
74259: GO 75311
// case i of 1 :
74261: LD_VAR 0 8
74265: PUSH
74266: LD_INT 1
74268: DOUBLE
74269: EQUAL
74270: IFTRUE 74274
74272: GO 74354
74274: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74275: LD_ADDR_VAR 0 12
74279: PUSH
74280: LD_VAR 0 18
74284: PPUSH
74285: LD_INT 22
74287: PUSH
74288: LD_VAR 0 16
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: LD_INT 58
74299: PUSH
74300: EMPTY
74301: LIST
74302: PUSH
74303: LD_INT 2
74305: PUSH
74306: LD_INT 30
74308: PUSH
74309: LD_INT 32
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 30
74318: PUSH
74319: LD_INT 4
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 30
74328: PUSH
74329: LD_INT 5
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: EMPTY
74337: LIST
74338: LIST
74339: LIST
74340: LIST
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: LIST
74346: PPUSH
74347: CALL_OW 72
74351: ST_TO_ADDR
74352: GO 74576
74354: LD_INT 2
74356: DOUBLE
74357: EQUAL
74358: IFTRUE 74362
74360: GO 74424
74362: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74363: LD_ADDR_VAR 0 12
74367: PUSH
74368: LD_VAR 0 18
74372: PPUSH
74373: LD_INT 22
74375: PUSH
74376: LD_VAR 0 16
74380: PUSH
74381: EMPTY
74382: LIST
74383: LIST
74384: PUSH
74385: LD_INT 2
74387: PUSH
74388: LD_INT 30
74390: PUSH
74391: LD_INT 0
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 30
74400: PUSH
74401: LD_INT 1
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: LIST
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PPUSH
74417: CALL_OW 72
74421: ST_TO_ADDR
74422: GO 74576
74424: LD_INT 3
74426: DOUBLE
74427: EQUAL
74428: IFTRUE 74432
74430: GO 74494
74432: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74433: LD_ADDR_VAR 0 12
74437: PUSH
74438: LD_VAR 0 18
74442: PPUSH
74443: LD_INT 22
74445: PUSH
74446: LD_VAR 0 16
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 2
74457: PUSH
74458: LD_INT 30
74460: PUSH
74461: LD_INT 2
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: LD_INT 30
74470: PUSH
74471: LD_INT 3
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: LIST
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PPUSH
74487: CALL_OW 72
74491: ST_TO_ADDR
74492: GO 74576
74494: LD_INT 4
74496: DOUBLE
74497: EQUAL
74498: IFTRUE 74502
74500: GO 74575
74502: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74503: LD_ADDR_VAR 0 12
74507: PUSH
74508: LD_VAR 0 18
74512: PPUSH
74513: LD_INT 22
74515: PUSH
74516: LD_VAR 0 16
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 2
74527: PUSH
74528: LD_INT 30
74530: PUSH
74531: LD_INT 6
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 30
74540: PUSH
74541: LD_INT 7
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 30
74550: PUSH
74551: LD_INT 8
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: LIST
74562: LIST
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PPUSH
74568: CALL_OW 72
74572: ST_TO_ADDR
74573: GO 74576
74575: POP
// if i = 1 then
74576: LD_VAR 0 8
74580: PUSH
74581: LD_INT 1
74583: EQUAL
74584: IFFALSE 74695
// begin tmp := [ ] ;
74586: LD_ADDR_VAR 0 19
74590: PUSH
74591: EMPTY
74592: ST_TO_ADDR
// for j in f do
74593: LD_ADDR_VAR 0 9
74597: PUSH
74598: LD_VAR 0 12
74602: PUSH
74603: FOR_IN
74604: IFFALSE 74677
// if GetBType ( j ) = b_bunker then
74606: LD_VAR 0 9
74610: PPUSH
74611: CALL_OW 266
74615: PUSH
74616: LD_INT 32
74618: EQUAL
74619: IFFALSE 74646
// tmp := Insert ( tmp , 1 , j ) else
74621: LD_ADDR_VAR 0 19
74625: PUSH
74626: LD_VAR 0 19
74630: PPUSH
74631: LD_INT 1
74633: PPUSH
74634: LD_VAR 0 9
74638: PPUSH
74639: CALL_OW 2
74643: ST_TO_ADDR
74644: GO 74675
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74646: LD_ADDR_VAR 0 19
74650: PUSH
74651: LD_VAR 0 19
74655: PPUSH
74656: LD_VAR 0 19
74660: PUSH
74661: LD_INT 1
74663: PLUS
74664: PPUSH
74665: LD_VAR 0 9
74669: PPUSH
74670: CALL_OW 2
74674: ST_TO_ADDR
74675: GO 74603
74677: POP
74678: POP
// if tmp then
74679: LD_VAR 0 19
74683: IFFALSE 74695
// f := tmp ;
74685: LD_ADDR_VAR 0 12
74689: PUSH
74690: LD_VAR 0 19
74694: ST_TO_ADDR
// end ; x := personel [ i ] ;
74695: LD_ADDR_VAR 0 13
74699: PUSH
74700: LD_VAR 0 6
74704: PUSH
74705: LD_VAR 0 8
74709: ARRAY
74710: ST_TO_ADDR
// if x = - 1 then
74711: LD_VAR 0 13
74715: PUSH
74716: LD_INT 1
74718: NEG
74719: EQUAL
74720: IFFALSE 74929
// begin for j in f do
74722: LD_ADDR_VAR 0 9
74726: PUSH
74727: LD_VAR 0 12
74731: PUSH
74732: FOR_IN
74733: IFFALSE 74925
// repeat InitHc ;
74735: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74739: LD_VAR 0 9
74743: PPUSH
74744: CALL_OW 266
74748: PUSH
74749: LD_INT 5
74751: EQUAL
74752: IFFALSE 74822
// begin if UnitsInside ( j ) < 3 then
74754: LD_VAR 0 9
74758: PPUSH
74759: CALL_OW 313
74763: PUSH
74764: LD_INT 3
74766: LESS
74767: IFFALSE 74803
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74769: LD_INT 0
74771: PPUSH
74772: LD_INT 5
74774: PUSH
74775: LD_INT 8
74777: PUSH
74778: LD_INT 9
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: LIST
74785: PUSH
74786: LD_VAR 0 17
74790: ARRAY
74791: PPUSH
74792: LD_VAR 0 4
74796: PPUSH
74797: CALL_OW 380
74801: GO 74820
// PrepareHuman ( false , i , skill ) ;
74803: LD_INT 0
74805: PPUSH
74806: LD_VAR 0 8
74810: PPUSH
74811: LD_VAR 0 4
74815: PPUSH
74816: CALL_OW 380
// end else
74820: GO 74839
// PrepareHuman ( false , i , skill ) ;
74822: LD_INT 0
74824: PPUSH
74825: LD_VAR 0 8
74829: PPUSH
74830: LD_VAR 0 4
74834: PPUSH
74835: CALL_OW 380
// un := CreateHuman ;
74839: LD_ADDR_VAR 0 14
74843: PUSH
74844: CALL_OW 44
74848: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74849: LD_ADDR_VAR 0 7
74853: PUSH
74854: LD_VAR 0 7
74858: PPUSH
74859: LD_INT 1
74861: PPUSH
74862: LD_VAR 0 14
74866: PPUSH
74867: CALL_OW 2
74871: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74872: LD_VAR 0 14
74876: PPUSH
74877: LD_VAR 0 9
74881: PPUSH
74882: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74886: LD_VAR 0 9
74890: PPUSH
74891: CALL_OW 313
74895: PUSH
74896: LD_INT 6
74898: EQUAL
74899: PUSH
74900: LD_VAR 0 9
74904: PPUSH
74905: CALL_OW 266
74909: PUSH
74910: LD_INT 32
74912: PUSH
74913: LD_INT 31
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: IN
74920: OR
74921: IFFALSE 74735
74923: GO 74732
74925: POP
74926: POP
// end else
74927: GO 75309
// for j = 1 to x do
74929: LD_ADDR_VAR 0 9
74933: PUSH
74934: DOUBLE
74935: LD_INT 1
74937: DEC
74938: ST_TO_ADDR
74939: LD_VAR 0 13
74943: PUSH
74944: FOR_TO
74945: IFFALSE 75307
// begin InitHc ;
74947: CALL_OW 19
// if not f then
74951: LD_VAR 0 12
74955: NOT
74956: IFFALSE 75045
// begin PrepareHuman ( false , i , skill ) ;
74958: LD_INT 0
74960: PPUSH
74961: LD_VAR 0 8
74965: PPUSH
74966: LD_VAR 0 4
74970: PPUSH
74971: CALL_OW 380
// un := CreateHuman ;
74975: LD_ADDR_VAR 0 14
74979: PUSH
74980: CALL_OW 44
74984: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74985: LD_ADDR_VAR 0 7
74989: PUSH
74990: LD_VAR 0 7
74994: PPUSH
74995: LD_INT 1
74997: PPUSH
74998: LD_VAR 0 14
75002: PPUSH
75003: CALL_OW 2
75007: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75008: LD_VAR 0 14
75012: PPUSH
75013: LD_VAR 0 1
75017: PPUSH
75018: CALL_OW 250
75022: PPUSH
75023: LD_VAR 0 1
75027: PPUSH
75028: CALL_OW 251
75032: PPUSH
75033: LD_INT 10
75035: PPUSH
75036: LD_INT 0
75038: PPUSH
75039: CALL_OW 50
// continue ;
75043: GO 74944
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75045: LD_VAR 0 12
75049: PUSH
75050: LD_INT 1
75052: ARRAY
75053: PPUSH
75054: CALL_OW 313
75058: PUSH
75059: LD_VAR 0 12
75063: PUSH
75064: LD_INT 1
75066: ARRAY
75067: PPUSH
75068: CALL_OW 266
75072: PUSH
75073: LD_INT 32
75075: PUSH
75076: LD_INT 31
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: IN
75083: AND
75084: PUSH
75085: LD_VAR 0 12
75089: PUSH
75090: LD_INT 1
75092: ARRAY
75093: PPUSH
75094: CALL_OW 313
75098: PUSH
75099: LD_INT 6
75101: EQUAL
75102: OR
75103: IFFALSE 75123
// f := Delete ( f , 1 ) ;
75105: LD_ADDR_VAR 0 12
75109: PUSH
75110: LD_VAR 0 12
75114: PPUSH
75115: LD_INT 1
75117: PPUSH
75118: CALL_OW 3
75122: ST_TO_ADDR
// if not f then
75123: LD_VAR 0 12
75127: NOT
75128: IFFALSE 75146
// begin x := x + 2 ;
75130: LD_ADDR_VAR 0 13
75134: PUSH
75135: LD_VAR 0 13
75139: PUSH
75140: LD_INT 2
75142: PLUS
75143: ST_TO_ADDR
// continue ;
75144: GO 74944
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75146: LD_VAR 0 12
75150: PUSH
75151: LD_INT 1
75153: ARRAY
75154: PPUSH
75155: CALL_OW 266
75159: PUSH
75160: LD_INT 5
75162: EQUAL
75163: IFFALSE 75237
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75165: LD_VAR 0 12
75169: PUSH
75170: LD_INT 1
75172: ARRAY
75173: PPUSH
75174: CALL_OW 313
75178: PUSH
75179: LD_INT 3
75181: LESS
75182: IFFALSE 75218
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75184: LD_INT 0
75186: PPUSH
75187: LD_INT 5
75189: PUSH
75190: LD_INT 8
75192: PUSH
75193: LD_INT 9
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: LIST
75200: PUSH
75201: LD_VAR 0 17
75205: ARRAY
75206: PPUSH
75207: LD_VAR 0 4
75211: PPUSH
75212: CALL_OW 380
75216: GO 75235
// PrepareHuman ( false , i , skill ) ;
75218: LD_INT 0
75220: PPUSH
75221: LD_VAR 0 8
75225: PPUSH
75226: LD_VAR 0 4
75230: PPUSH
75231: CALL_OW 380
// end else
75235: GO 75254
// PrepareHuman ( false , i , skill ) ;
75237: LD_INT 0
75239: PPUSH
75240: LD_VAR 0 8
75244: PPUSH
75245: LD_VAR 0 4
75249: PPUSH
75250: CALL_OW 380
// un := CreateHuman ;
75254: LD_ADDR_VAR 0 14
75258: PUSH
75259: CALL_OW 44
75263: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75264: LD_ADDR_VAR 0 7
75268: PUSH
75269: LD_VAR 0 7
75273: PPUSH
75274: LD_INT 1
75276: PPUSH
75277: LD_VAR 0 14
75281: PPUSH
75282: CALL_OW 2
75286: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75287: LD_VAR 0 14
75291: PPUSH
75292: LD_VAR 0 12
75296: PUSH
75297: LD_INT 1
75299: ARRAY
75300: PPUSH
75301: CALL_OW 52
// end ;
75305: GO 74944
75307: POP
75308: POP
// end ;
75309: GO 74246
75311: POP
75312: POP
// result := result ^ buildings ;
75313: LD_ADDR_VAR 0 7
75317: PUSH
75318: LD_VAR 0 7
75322: PUSH
75323: LD_VAR 0 18
75327: ADD
75328: ST_TO_ADDR
// end else
75329: GO 75472
// begin for i = 1 to personel do
75331: LD_ADDR_VAR 0 8
75335: PUSH
75336: DOUBLE
75337: LD_INT 1
75339: DEC
75340: ST_TO_ADDR
75341: LD_VAR 0 6
75345: PUSH
75346: FOR_TO
75347: IFFALSE 75470
// begin if i > 4 then
75349: LD_VAR 0 8
75353: PUSH
75354: LD_INT 4
75356: GREATER
75357: IFFALSE 75361
// break ;
75359: GO 75470
// x := personel [ i ] ;
75361: LD_ADDR_VAR 0 13
75365: PUSH
75366: LD_VAR 0 6
75370: PUSH
75371: LD_VAR 0 8
75375: ARRAY
75376: ST_TO_ADDR
// if x = - 1 then
75377: LD_VAR 0 13
75381: PUSH
75382: LD_INT 1
75384: NEG
75385: EQUAL
75386: IFFALSE 75390
// continue ;
75388: GO 75346
// PrepareHuman ( false , i , skill ) ;
75390: LD_INT 0
75392: PPUSH
75393: LD_VAR 0 8
75397: PPUSH
75398: LD_VAR 0 4
75402: PPUSH
75403: CALL_OW 380
// un := CreateHuman ;
75407: LD_ADDR_VAR 0 14
75411: PUSH
75412: CALL_OW 44
75416: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75417: LD_VAR 0 14
75421: PPUSH
75422: LD_VAR 0 1
75426: PPUSH
75427: CALL_OW 250
75431: PPUSH
75432: LD_VAR 0 1
75436: PPUSH
75437: CALL_OW 251
75441: PPUSH
75442: LD_INT 10
75444: PPUSH
75445: LD_INT 0
75447: PPUSH
75448: CALL_OW 50
// result := result ^ un ;
75452: LD_ADDR_VAR 0 7
75456: PUSH
75457: LD_VAR 0 7
75461: PUSH
75462: LD_VAR 0 14
75466: ADD
75467: ST_TO_ADDR
// end ;
75468: GO 75346
75470: POP
75471: POP
// end ; end ;
75472: LD_VAR 0 7
75476: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75477: LD_INT 0
75479: PPUSH
75480: PPUSH
75481: PPUSH
75482: PPUSH
75483: PPUSH
75484: PPUSH
75485: PPUSH
75486: PPUSH
75487: PPUSH
75488: PPUSH
75489: PPUSH
75490: PPUSH
75491: PPUSH
75492: PPUSH
75493: PPUSH
75494: PPUSH
// result := false ;
75495: LD_ADDR_VAR 0 3
75499: PUSH
75500: LD_INT 0
75502: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75503: LD_VAR 0 1
75507: NOT
75508: PUSH
75509: LD_VAR 0 1
75513: PPUSH
75514: CALL_OW 266
75518: PUSH
75519: LD_INT 32
75521: PUSH
75522: LD_INT 33
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: IN
75529: NOT
75530: OR
75531: IFFALSE 75535
// exit ;
75533: GO 76671
// nat := GetNation ( tower ) ;
75535: LD_ADDR_VAR 0 12
75539: PUSH
75540: LD_VAR 0 1
75544: PPUSH
75545: CALL_OW 248
75549: ST_TO_ADDR
// side := GetSide ( tower ) ;
75550: LD_ADDR_VAR 0 16
75554: PUSH
75555: LD_VAR 0 1
75559: PPUSH
75560: CALL_OW 255
75564: ST_TO_ADDR
// x := GetX ( tower ) ;
75565: LD_ADDR_VAR 0 10
75569: PUSH
75570: LD_VAR 0 1
75574: PPUSH
75575: CALL_OW 250
75579: ST_TO_ADDR
// y := GetY ( tower ) ;
75580: LD_ADDR_VAR 0 11
75584: PUSH
75585: LD_VAR 0 1
75589: PPUSH
75590: CALL_OW 251
75594: ST_TO_ADDR
// if not x or not y then
75595: LD_VAR 0 10
75599: NOT
75600: PUSH
75601: LD_VAR 0 11
75605: NOT
75606: OR
75607: IFFALSE 75611
// exit ;
75609: GO 76671
// weapon := 0 ;
75611: LD_ADDR_VAR 0 18
75615: PUSH
75616: LD_INT 0
75618: ST_TO_ADDR
// fac_list := [ ] ;
75619: LD_ADDR_VAR 0 17
75623: PUSH
75624: EMPTY
75625: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75626: LD_ADDR_VAR 0 6
75630: PUSH
75631: LD_VAR 0 1
75635: PPUSH
75636: CALL_OW 274
75640: PPUSH
75641: LD_VAR 0 2
75645: PPUSH
75646: CALL 73249 0 2
75650: PPUSH
75651: LD_INT 30
75653: PUSH
75654: LD_INT 3
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PPUSH
75661: CALL_OW 72
75665: ST_TO_ADDR
// if not factories then
75666: LD_VAR 0 6
75670: NOT
75671: IFFALSE 75675
// exit ;
75673: GO 76671
// for i in factories do
75675: LD_ADDR_VAR 0 8
75679: PUSH
75680: LD_VAR 0 6
75684: PUSH
75685: FOR_IN
75686: IFFALSE 75711
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75688: LD_ADDR_VAR 0 17
75692: PUSH
75693: LD_VAR 0 17
75697: PUSH
75698: LD_VAR 0 8
75702: PPUSH
75703: CALL_OW 478
75707: UNION
75708: ST_TO_ADDR
75709: GO 75685
75711: POP
75712: POP
// if not fac_list then
75713: LD_VAR 0 17
75717: NOT
75718: IFFALSE 75722
// exit ;
75720: GO 76671
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75722: LD_ADDR_VAR 0 5
75726: PUSH
75727: LD_INT 4
75729: PUSH
75730: LD_INT 5
75732: PUSH
75733: LD_INT 9
75735: PUSH
75736: LD_INT 10
75738: PUSH
75739: LD_INT 6
75741: PUSH
75742: LD_INT 7
75744: PUSH
75745: LD_INT 11
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 27
75759: PUSH
75760: LD_INT 28
75762: PUSH
75763: LD_INT 26
75765: PUSH
75766: LD_INT 30
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 43
75777: PUSH
75778: LD_INT 44
75780: PUSH
75781: LD_INT 46
75783: PUSH
75784: LD_INT 45
75786: PUSH
75787: LD_INT 47
75789: PUSH
75790: LD_INT 49
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: LIST
75805: PUSH
75806: LD_VAR 0 12
75810: ARRAY
75811: ST_TO_ADDR
// for i in list do
75812: LD_ADDR_VAR 0 8
75816: PUSH
75817: LD_VAR 0 5
75821: PUSH
75822: FOR_IN
75823: IFFALSE 75856
// if not i in fac_list then
75825: LD_VAR 0 8
75829: PUSH
75830: LD_VAR 0 17
75834: IN
75835: NOT
75836: IFFALSE 75854
// list := list diff i ;
75838: LD_ADDR_VAR 0 5
75842: PUSH
75843: LD_VAR 0 5
75847: PUSH
75848: LD_VAR 0 8
75852: DIFF
75853: ST_TO_ADDR
75854: GO 75822
75856: POP
75857: POP
// if not list then
75858: LD_VAR 0 5
75862: NOT
75863: IFFALSE 75867
// exit ;
75865: GO 76671
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75867: LD_VAR 0 12
75871: PUSH
75872: LD_INT 3
75874: EQUAL
75875: PUSH
75876: LD_INT 49
75878: PUSH
75879: LD_VAR 0 5
75883: IN
75884: AND
75885: PUSH
75886: LD_INT 31
75888: PPUSH
75889: LD_VAR 0 16
75893: PPUSH
75894: CALL_OW 321
75898: PUSH
75899: LD_INT 2
75901: EQUAL
75902: AND
75903: IFFALSE 75963
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75905: LD_INT 22
75907: PUSH
75908: LD_VAR 0 16
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: LD_INT 35
75919: PUSH
75920: LD_INT 49
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 91
75929: PUSH
75930: LD_VAR 0 1
75934: PUSH
75935: LD_INT 10
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: LIST
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: LIST
75947: PPUSH
75948: CALL_OW 69
75952: NOT
75953: IFFALSE 75963
// weapon := ru_time_lapser ;
75955: LD_ADDR_VAR 0 18
75959: PUSH
75960: LD_INT 49
75962: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75963: LD_VAR 0 12
75967: PUSH
75968: LD_INT 1
75970: PUSH
75971: LD_INT 2
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: IN
75978: PUSH
75979: LD_INT 11
75981: PUSH
75982: LD_VAR 0 5
75986: IN
75987: PUSH
75988: LD_INT 30
75990: PUSH
75991: LD_VAR 0 5
75995: IN
75996: OR
75997: AND
75998: PUSH
75999: LD_INT 6
76001: PPUSH
76002: LD_VAR 0 16
76006: PPUSH
76007: CALL_OW 321
76011: PUSH
76012: LD_INT 2
76014: EQUAL
76015: AND
76016: IFFALSE 76181
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76018: LD_INT 22
76020: PUSH
76021: LD_VAR 0 16
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 2
76032: PUSH
76033: LD_INT 35
76035: PUSH
76036: LD_INT 11
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 35
76045: PUSH
76046: LD_INT 30
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: LIST
76057: PUSH
76058: LD_INT 91
76060: PUSH
76061: LD_VAR 0 1
76065: PUSH
76066: LD_INT 18
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: LIST
76073: PUSH
76074: EMPTY
76075: LIST
76076: LIST
76077: LIST
76078: PPUSH
76079: CALL_OW 69
76083: NOT
76084: PUSH
76085: LD_INT 22
76087: PUSH
76088: LD_VAR 0 16
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 2
76099: PUSH
76100: LD_INT 30
76102: PUSH
76103: LD_INT 32
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 30
76112: PUSH
76113: LD_INT 33
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 91
76127: PUSH
76128: LD_VAR 0 1
76132: PUSH
76133: LD_INT 12
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: LIST
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: LIST
76145: PUSH
76146: EMPTY
76147: LIST
76148: PPUSH
76149: CALL_OW 69
76153: PUSH
76154: LD_INT 2
76156: GREATER
76157: AND
76158: IFFALSE 76181
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76160: LD_ADDR_VAR 0 18
76164: PUSH
76165: LD_INT 11
76167: PUSH
76168: LD_INT 30
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_VAR 0 12
76179: ARRAY
76180: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76181: LD_VAR 0 18
76185: NOT
76186: PUSH
76187: LD_INT 40
76189: PPUSH
76190: LD_VAR 0 16
76194: PPUSH
76195: CALL_OW 321
76199: PUSH
76200: LD_INT 2
76202: EQUAL
76203: AND
76204: PUSH
76205: LD_INT 7
76207: PUSH
76208: LD_VAR 0 5
76212: IN
76213: PUSH
76214: LD_INT 28
76216: PUSH
76217: LD_VAR 0 5
76221: IN
76222: OR
76223: PUSH
76224: LD_INT 45
76226: PUSH
76227: LD_VAR 0 5
76231: IN
76232: OR
76233: AND
76234: IFFALSE 76488
// begin hex := GetHexInfo ( x , y ) ;
76236: LD_ADDR_VAR 0 4
76240: PUSH
76241: LD_VAR 0 10
76245: PPUSH
76246: LD_VAR 0 11
76250: PPUSH
76251: CALL_OW 546
76255: ST_TO_ADDR
// if hex [ 1 ] then
76256: LD_VAR 0 4
76260: PUSH
76261: LD_INT 1
76263: ARRAY
76264: IFFALSE 76268
// exit ;
76266: GO 76671
// height := hex [ 2 ] ;
76268: LD_ADDR_VAR 0 15
76272: PUSH
76273: LD_VAR 0 4
76277: PUSH
76278: LD_INT 2
76280: ARRAY
76281: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76282: LD_ADDR_VAR 0 14
76286: PUSH
76287: LD_INT 0
76289: PUSH
76290: LD_INT 2
76292: PUSH
76293: LD_INT 3
76295: PUSH
76296: LD_INT 5
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: ST_TO_ADDR
// for i in tmp do
76305: LD_ADDR_VAR 0 8
76309: PUSH
76310: LD_VAR 0 14
76314: PUSH
76315: FOR_IN
76316: IFFALSE 76486
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76318: LD_ADDR_VAR 0 9
76322: PUSH
76323: LD_VAR 0 10
76327: PPUSH
76328: LD_VAR 0 8
76332: PPUSH
76333: LD_INT 5
76335: PPUSH
76336: CALL_OW 272
76340: PUSH
76341: LD_VAR 0 11
76345: PPUSH
76346: LD_VAR 0 8
76350: PPUSH
76351: LD_INT 5
76353: PPUSH
76354: CALL_OW 273
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76363: LD_VAR 0 9
76367: PUSH
76368: LD_INT 1
76370: ARRAY
76371: PPUSH
76372: LD_VAR 0 9
76376: PUSH
76377: LD_INT 2
76379: ARRAY
76380: PPUSH
76381: CALL_OW 488
76385: IFFALSE 76484
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76387: LD_ADDR_VAR 0 4
76391: PUSH
76392: LD_VAR 0 9
76396: PUSH
76397: LD_INT 1
76399: ARRAY
76400: PPUSH
76401: LD_VAR 0 9
76405: PUSH
76406: LD_INT 2
76408: ARRAY
76409: PPUSH
76410: CALL_OW 546
76414: ST_TO_ADDR
// if hex [ 1 ] then
76415: LD_VAR 0 4
76419: PUSH
76420: LD_INT 1
76422: ARRAY
76423: IFFALSE 76427
// continue ;
76425: GO 76315
// h := hex [ 2 ] ;
76427: LD_ADDR_VAR 0 13
76431: PUSH
76432: LD_VAR 0 4
76436: PUSH
76437: LD_INT 2
76439: ARRAY
76440: ST_TO_ADDR
// if h + 7 < height then
76441: LD_VAR 0 13
76445: PUSH
76446: LD_INT 7
76448: PLUS
76449: PUSH
76450: LD_VAR 0 15
76454: LESS
76455: IFFALSE 76484
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76457: LD_ADDR_VAR 0 18
76461: PUSH
76462: LD_INT 7
76464: PUSH
76465: LD_INT 28
76467: PUSH
76468: LD_INT 45
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: LIST
76475: PUSH
76476: LD_VAR 0 12
76480: ARRAY
76481: ST_TO_ADDR
// break ;
76482: GO 76486
// end ; end ; end ;
76484: GO 76315
76486: POP
76487: POP
// end ; if not weapon then
76488: LD_VAR 0 18
76492: NOT
76493: IFFALSE 76553
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76495: LD_ADDR_VAR 0 5
76499: PUSH
76500: LD_VAR 0 5
76504: PUSH
76505: LD_INT 11
76507: PUSH
76508: LD_INT 30
76510: PUSH
76511: LD_INT 49
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: LIST
76518: DIFF
76519: ST_TO_ADDR
// if not list then
76520: LD_VAR 0 5
76524: NOT
76525: IFFALSE 76529
// exit ;
76527: GO 76671
// weapon := list [ rand ( 1 , list ) ] ;
76529: LD_ADDR_VAR 0 18
76533: PUSH
76534: LD_VAR 0 5
76538: PUSH
76539: LD_INT 1
76541: PPUSH
76542: LD_VAR 0 5
76546: PPUSH
76547: CALL_OW 12
76551: ARRAY
76552: ST_TO_ADDR
// end ; if weapon then
76553: LD_VAR 0 18
76557: IFFALSE 76671
// begin tmp := CostOfWeapon ( weapon ) ;
76559: LD_ADDR_VAR 0 14
76563: PUSH
76564: LD_VAR 0 18
76568: PPUSH
76569: CALL_OW 451
76573: ST_TO_ADDR
// j := GetBase ( tower ) ;
76574: LD_ADDR_VAR 0 9
76578: PUSH
76579: LD_VAR 0 1
76583: PPUSH
76584: CALL_OW 274
76588: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76589: LD_VAR 0 9
76593: PPUSH
76594: LD_INT 1
76596: PPUSH
76597: CALL_OW 275
76601: PUSH
76602: LD_VAR 0 14
76606: PUSH
76607: LD_INT 1
76609: ARRAY
76610: GREATEREQUAL
76611: PUSH
76612: LD_VAR 0 9
76616: PPUSH
76617: LD_INT 2
76619: PPUSH
76620: CALL_OW 275
76624: PUSH
76625: LD_VAR 0 14
76629: PUSH
76630: LD_INT 2
76632: ARRAY
76633: GREATEREQUAL
76634: AND
76635: PUSH
76636: LD_VAR 0 9
76640: PPUSH
76641: LD_INT 3
76643: PPUSH
76644: CALL_OW 275
76648: PUSH
76649: LD_VAR 0 14
76653: PUSH
76654: LD_INT 3
76656: ARRAY
76657: GREATEREQUAL
76658: AND
76659: IFFALSE 76671
// result := weapon ;
76661: LD_ADDR_VAR 0 3
76665: PUSH
76666: LD_VAR 0 18
76670: ST_TO_ADDR
// end ; end ;
76671: LD_VAR 0 3
76675: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76676: LD_INT 0
76678: PPUSH
76679: PPUSH
// result := true ;
76680: LD_ADDR_VAR 0 3
76684: PUSH
76685: LD_INT 1
76687: ST_TO_ADDR
// if array1 = array2 then
76688: LD_VAR 0 1
76692: PUSH
76693: LD_VAR 0 2
76697: EQUAL
76698: IFFALSE 76758
// begin for i = 1 to array1 do
76700: LD_ADDR_VAR 0 4
76704: PUSH
76705: DOUBLE
76706: LD_INT 1
76708: DEC
76709: ST_TO_ADDR
76710: LD_VAR 0 1
76714: PUSH
76715: FOR_TO
76716: IFFALSE 76754
// if array1 [ i ] <> array2 [ i ] then
76718: LD_VAR 0 1
76722: PUSH
76723: LD_VAR 0 4
76727: ARRAY
76728: PUSH
76729: LD_VAR 0 2
76733: PUSH
76734: LD_VAR 0 4
76738: ARRAY
76739: NONEQUAL
76740: IFFALSE 76752
// begin result := false ;
76742: LD_ADDR_VAR 0 3
76746: PUSH
76747: LD_INT 0
76749: ST_TO_ADDR
// break ;
76750: GO 76754
// end ;
76752: GO 76715
76754: POP
76755: POP
// end else
76756: GO 76766
// result := false ;
76758: LD_ADDR_VAR 0 3
76762: PUSH
76763: LD_INT 0
76765: ST_TO_ADDR
// end ;
76766: LD_VAR 0 3
76770: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76771: LD_INT 0
76773: PPUSH
76774: PPUSH
76775: PPUSH
// pom := GetBase ( fac ) ;
76776: LD_ADDR_VAR 0 5
76780: PUSH
76781: LD_VAR 0 1
76785: PPUSH
76786: CALL_OW 274
76790: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76791: LD_ADDR_VAR 0 4
76795: PUSH
76796: LD_VAR 0 2
76800: PUSH
76801: LD_INT 1
76803: ARRAY
76804: PPUSH
76805: LD_VAR 0 2
76809: PUSH
76810: LD_INT 2
76812: ARRAY
76813: PPUSH
76814: LD_VAR 0 2
76818: PUSH
76819: LD_INT 3
76821: ARRAY
76822: PPUSH
76823: LD_VAR 0 2
76827: PUSH
76828: LD_INT 4
76830: ARRAY
76831: PPUSH
76832: CALL_OW 449
76836: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76837: LD_ADDR_VAR 0 3
76841: PUSH
76842: LD_VAR 0 5
76846: PPUSH
76847: LD_INT 1
76849: PPUSH
76850: CALL_OW 275
76854: PUSH
76855: LD_VAR 0 4
76859: PUSH
76860: LD_INT 1
76862: ARRAY
76863: GREATEREQUAL
76864: PUSH
76865: LD_VAR 0 5
76869: PPUSH
76870: LD_INT 2
76872: PPUSH
76873: CALL_OW 275
76877: PUSH
76878: LD_VAR 0 4
76882: PUSH
76883: LD_INT 2
76885: ARRAY
76886: GREATEREQUAL
76887: AND
76888: PUSH
76889: LD_VAR 0 5
76893: PPUSH
76894: LD_INT 3
76896: PPUSH
76897: CALL_OW 275
76901: PUSH
76902: LD_VAR 0 4
76906: PUSH
76907: LD_INT 3
76909: ARRAY
76910: GREATEREQUAL
76911: AND
76912: ST_TO_ADDR
// end ;
76913: LD_VAR 0 3
76917: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76918: LD_INT 0
76920: PPUSH
76921: PPUSH
76922: PPUSH
76923: PPUSH
// pom := GetBase ( building ) ;
76924: LD_ADDR_VAR 0 3
76928: PUSH
76929: LD_VAR 0 1
76933: PPUSH
76934: CALL_OW 274
76938: ST_TO_ADDR
// if not pom then
76939: LD_VAR 0 3
76943: NOT
76944: IFFALSE 76948
// exit ;
76946: GO 77118
// btype := GetBType ( building ) ;
76948: LD_ADDR_VAR 0 5
76952: PUSH
76953: LD_VAR 0 1
76957: PPUSH
76958: CALL_OW 266
76962: ST_TO_ADDR
// if btype = b_armoury then
76963: LD_VAR 0 5
76967: PUSH
76968: LD_INT 4
76970: EQUAL
76971: IFFALSE 76981
// btype := b_barracks ;
76973: LD_ADDR_VAR 0 5
76977: PUSH
76978: LD_INT 5
76980: ST_TO_ADDR
// if btype = b_depot then
76981: LD_VAR 0 5
76985: PUSH
76986: LD_INT 0
76988: EQUAL
76989: IFFALSE 76999
// btype := b_warehouse ;
76991: LD_ADDR_VAR 0 5
76995: PUSH
76996: LD_INT 1
76998: ST_TO_ADDR
// if btype = b_workshop then
76999: LD_VAR 0 5
77003: PUSH
77004: LD_INT 2
77006: EQUAL
77007: IFFALSE 77017
// btype := b_factory ;
77009: LD_ADDR_VAR 0 5
77013: PUSH
77014: LD_INT 3
77016: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77017: LD_ADDR_VAR 0 4
77021: PUSH
77022: LD_VAR 0 5
77026: PPUSH
77027: LD_VAR 0 1
77031: PPUSH
77032: CALL_OW 248
77036: PPUSH
77037: CALL_OW 450
77041: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77042: LD_ADDR_VAR 0 2
77046: PUSH
77047: LD_VAR 0 3
77051: PPUSH
77052: LD_INT 1
77054: PPUSH
77055: CALL_OW 275
77059: PUSH
77060: LD_VAR 0 4
77064: PUSH
77065: LD_INT 1
77067: ARRAY
77068: GREATEREQUAL
77069: PUSH
77070: LD_VAR 0 3
77074: PPUSH
77075: LD_INT 2
77077: PPUSH
77078: CALL_OW 275
77082: PUSH
77083: LD_VAR 0 4
77087: PUSH
77088: LD_INT 2
77090: ARRAY
77091: GREATEREQUAL
77092: AND
77093: PUSH
77094: LD_VAR 0 3
77098: PPUSH
77099: LD_INT 3
77101: PPUSH
77102: CALL_OW 275
77106: PUSH
77107: LD_VAR 0 4
77111: PUSH
77112: LD_INT 3
77114: ARRAY
77115: GREATEREQUAL
77116: AND
77117: ST_TO_ADDR
// end ;
77118: LD_VAR 0 2
77122: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77123: LD_INT 0
77125: PPUSH
77126: PPUSH
77127: PPUSH
// pom := GetBase ( building ) ;
77128: LD_ADDR_VAR 0 4
77132: PUSH
77133: LD_VAR 0 1
77137: PPUSH
77138: CALL_OW 274
77142: ST_TO_ADDR
// if not pom then
77143: LD_VAR 0 4
77147: NOT
77148: IFFALSE 77152
// exit ;
77150: GO 77253
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77152: LD_ADDR_VAR 0 5
77156: PUSH
77157: LD_VAR 0 2
77161: PPUSH
77162: LD_VAR 0 1
77166: PPUSH
77167: CALL_OW 248
77171: PPUSH
77172: CALL_OW 450
77176: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77177: LD_ADDR_VAR 0 3
77181: PUSH
77182: LD_VAR 0 4
77186: PPUSH
77187: LD_INT 1
77189: PPUSH
77190: CALL_OW 275
77194: PUSH
77195: LD_VAR 0 5
77199: PUSH
77200: LD_INT 1
77202: ARRAY
77203: GREATEREQUAL
77204: PUSH
77205: LD_VAR 0 4
77209: PPUSH
77210: LD_INT 2
77212: PPUSH
77213: CALL_OW 275
77217: PUSH
77218: LD_VAR 0 5
77222: PUSH
77223: LD_INT 2
77225: ARRAY
77226: GREATEREQUAL
77227: AND
77228: PUSH
77229: LD_VAR 0 4
77233: PPUSH
77234: LD_INT 3
77236: PPUSH
77237: CALL_OW 275
77241: PUSH
77242: LD_VAR 0 5
77246: PUSH
77247: LD_INT 3
77249: ARRAY
77250: GREATEREQUAL
77251: AND
77252: ST_TO_ADDR
// end ;
77253: LD_VAR 0 3
77257: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
77258: LD_INT 0
77260: PPUSH
77261: PPUSH
77262: PPUSH
77263: PPUSH
77264: PPUSH
77265: PPUSH
77266: PPUSH
77267: PPUSH
77268: PPUSH
77269: PPUSH
// result := false ;
77270: LD_ADDR_VAR 0 6
77274: PUSH
77275: LD_INT 0
77277: ST_TO_ADDR
// if not base or not btype or not x or not y then
77278: LD_VAR 0 1
77282: NOT
77283: PUSH
77284: LD_VAR 0 2
77288: NOT
77289: OR
77290: PUSH
77291: LD_VAR 0 3
77295: NOT
77296: OR
77297: PUSH
77298: LD_VAR 0 4
77302: NOT
77303: OR
77304: IFFALSE 77308
// exit ;
77306: GO 77917
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
77308: LD_ADDR_VAR 0 12
77312: PUSH
77313: LD_VAR 0 2
77317: PPUSH
77318: LD_VAR 0 3
77322: PPUSH
77323: LD_VAR 0 4
77327: PPUSH
77328: LD_VAR 0 5
77332: PPUSH
77333: LD_VAR 0 1
77337: PUSH
77338: LD_INT 1
77340: ARRAY
77341: PPUSH
77342: CALL_OW 248
77346: PPUSH
77347: LD_INT 0
77349: PPUSH
77350: CALL 78754 0 6
77354: ST_TO_ADDR
// if not hexes then
77355: LD_VAR 0 12
77359: NOT
77360: IFFALSE 77364
// exit ;
77362: GO 77917
// for i = 1 to hexes do
77364: LD_ADDR_VAR 0 7
77368: PUSH
77369: DOUBLE
77370: LD_INT 1
77372: DEC
77373: ST_TO_ADDR
77374: LD_VAR 0 12
77378: PUSH
77379: FOR_TO
77380: IFFALSE 77915
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77382: LD_ADDR_VAR 0 11
77386: PUSH
77387: LD_VAR 0 12
77391: PUSH
77392: LD_VAR 0 7
77396: ARRAY
77397: PUSH
77398: LD_INT 1
77400: ARRAY
77401: PPUSH
77402: LD_VAR 0 12
77406: PUSH
77407: LD_VAR 0 7
77411: ARRAY
77412: PUSH
77413: LD_INT 2
77415: ARRAY
77416: PPUSH
77417: CALL_OW 428
77421: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77422: LD_VAR 0 12
77426: PUSH
77427: LD_VAR 0 7
77431: ARRAY
77432: PUSH
77433: LD_INT 1
77435: ARRAY
77436: PPUSH
77437: LD_VAR 0 12
77441: PUSH
77442: LD_VAR 0 7
77446: ARRAY
77447: PUSH
77448: LD_INT 2
77450: ARRAY
77451: PPUSH
77452: CALL_OW 351
77456: PUSH
77457: LD_VAR 0 12
77461: PUSH
77462: LD_VAR 0 7
77466: ARRAY
77467: PUSH
77468: LD_INT 1
77470: ARRAY
77471: PPUSH
77472: LD_VAR 0 12
77476: PUSH
77477: LD_VAR 0 7
77481: ARRAY
77482: PUSH
77483: LD_INT 2
77485: ARRAY
77486: PPUSH
77487: CALL_OW 488
77491: NOT
77492: OR
77493: PUSH
77494: LD_VAR 0 11
77498: PPUSH
77499: CALL_OW 247
77503: PUSH
77504: LD_INT 3
77506: EQUAL
77507: OR
77508: IFFALSE 77514
// exit ;
77510: POP
77511: POP
77512: GO 77917
// if not tmp or not tmp in base then
77514: LD_VAR 0 11
77518: NOT
77519: PUSH
77520: LD_VAR 0 11
77524: PUSH
77525: LD_VAR 0 1
77529: IN
77530: NOT
77531: OR
77532: IFFALSE 77536
// continue ;
77534: GO 77379
// result := true ;
77536: LD_ADDR_VAR 0 6
77540: PUSH
77541: LD_INT 1
77543: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77544: LD_ADDR_VAR 0 15
77548: PUSH
77549: LD_VAR 0 1
77553: PPUSH
77554: LD_INT 22
77556: PUSH
77557: LD_VAR 0 11
77561: PPUSH
77562: CALL_OW 255
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: LD_INT 2
77573: PUSH
77574: LD_INT 30
77576: PUSH
77577: LD_INT 0
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 30
77586: PUSH
77587: LD_INT 1
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: LIST
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PPUSH
77603: CALL_OW 72
77607: ST_TO_ADDR
// if dep then
77608: LD_VAR 0 15
77612: IFFALSE 77748
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77614: LD_ADDR_VAR 0 14
77618: PUSH
77619: LD_VAR 0 15
77623: PUSH
77624: LD_INT 1
77626: ARRAY
77627: PPUSH
77628: CALL_OW 250
77632: PPUSH
77633: LD_VAR 0 15
77637: PUSH
77638: LD_INT 1
77640: ARRAY
77641: PPUSH
77642: CALL_OW 254
77646: PPUSH
77647: LD_INT 5
77649: PPUSH
77650: CALL_OW 272
77654: PUSH
77655: LD_VAR 0 15
77659: PUSH
77660: LD_INT 1
77662: ARRAY
77663: PPUSH
77664: CALL_OW 251
77668: PPUSH
77669: LD_VAR 0 15
77673: PUSH
77674: LD_INT 1
77676: ARRAY
77677: PPUSH
77678: CALL_OW 254
77682: PPUSH
77683: LD_INT 5
77685: PPUSH
77686: CALL_OW 273
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77695: LD_VAR 0 14
77699: PUSH
77700: LD_INT 1
77702: ARRAY
77703: PPUSH
77704: LD_VAR 0 14
77708: PUSH
77709: LD_INT 2
77711: ARRAY
77712: PPUSH
77713: CALL_OW 488
77717: IFFALSE 77748
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77719: LD_VAR 0 11
77723: PPUSH
77724: LD_VAR 0 14
77728: PUSH
77729: LD_INT 1
77731: ARRAY
77732: PPUSH
77733: LD_VAR 0 14
77737: PUSH
77738: LD_INT 2
77740: ARRAY
77741: PPUSH
77742: CALL_OW 111
// continue ;
77746: GO 77379
// end ; end ; r := GetDir ( tmp ) ;
77748: LD_ADDR_VAR 0 13
77752: PUSH
77753: LD_VAR 0 11
77757: PPUSH
77758: CALL_OW 254
77762: ST_TO_ADDR
// if r = 5 then
77763: LD_VAR 0 13
77767: PUSH
77768: LD_INT 5
77770: EQUAL
77771: IFFALSE 77781
// r := 0 ;
77773: LD_ADDR_VAR 0 13
77777: PUSH
77778: LD_INT 0
77780: ST_TO_ADDR
// for j = r to 5 do
77781: LD_ADDR_VAR 0 8
77785: PUSH
77786: DOUBLE
77787: LD_VAR 0 13
77791: DEC
77792: ST_TO_ADDR
77793: LD_INT 5
77795: PUSH
77796: FOR_TO
77797: IFFALSE 77911
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77799: LD_ADDR_VAR 0 9
77803: PUSH
77804: LD_VAR 0 11
77808: PPUSH
77809: CALL_OW 250
77813: PPUSH
77814: LD_VAR 0 8
77818: PPUSH
77819: LD_INT 2
77821: PPUSH
77822: CALL_OW 272
77826: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77827: LD_ADDR_VAR 0 10
77831: PUSH
77832: LD_VAR 0 11
77836: PPUSH
77837: CALL_OW 251
77841: PPUSH
77842: LD_VAR 0 8
77846: PPUSH
77847: LD_INT 2
77849: PPUSH
77850: CALL_OW 273
77854: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77855: LD_VAR 0 9
77859: PPUSH
77860: LD_VAR 0 10
77864: PPUSH
77865: CALL_OW 488
77869: PUSH
77870: LD_VAR 0 9
77874: PPUSH
77875: LD_VAR 0 10
77879: PPUSH
77880: CALL_OW 428
77884: NOT
77885: AND
77886: IFFALSE 77909
// begin ComMoveXY ( tmp , _x , _y ) ;
77888: LD_VAR 0 11
77892: PPUSH
77893: LD_VAR 0 9
77897: PPUSH
77898: LD_VAR 0 10
77902: PPUSH
77903: CALL_OW 111
// break ;
77907: GO 77911
// end ; end ;
77909: GO 77796
77911: POP
77912: POP
// end ;
77913: GO 77379
77915: POP
77916: POP
// end ;
77917: LD_VAR 0 6
77921: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77922: LD_INT 0
77924: PPUSH
77925: PPUSH
77926: PPUSH
77927: PPUSH
77928: PPUSH
77929: PPUSH
77930: PPUSH
77931: PPUSH
77932: PPUSH
77933: PPUSH
// result := false ;
77934: LD_ADDR_VAR 0 6
77938: PUSH
77939: LD_INT 0
77941: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77942: LD_VAR 0 1
77946: NOT
77947: PUSH
77948: LD_VAR 0 1
77952: PPUSH
77953: CALL_OW 266
77957: PUSH
77958: LD_INT 0
77960: PUSH
77961: LD_INT 1
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: IN
77968: NOT
77969: OR
77970: PUSH
77971: LD_VAR 0 2
77975: NOT
77976: OR
77977: PUSH
77978: LD_VAR 0 5
77982: PUSH
77983: LD_INT 0
77985: PUSH
77986: LD_INT 1
77988: PUSH
77989: LD_INT 2
77991: PUSH
77992: LD_INT 3
77994: PUSH
77995: LD_INT 4
77997: PUSH
77998: LD_INT 5
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: IN
78009: NOT
78010: OR
78011: PUSH
78012: LD_VAR 0 3
78016: PPUSH
78017: LD_VAR 0 4
78021: PPUSH
78022: CALL_OW 488
78026: NOT
78027: OR
78028: IFFALSE 78032
// exit ;
78030: GO 78749
// pom := GetBase ( depot ) ;
78032: LD_ADDR_VAR 0 10
78036: PUSH
78037: LD_VAR 0 1
78041: PPUSH
78042: CALL_OW 274
78046: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78047: LD_ADDR_VAR 0 11
78051: PUSH
78052: LD_VAR 0 2
78056: PPUSH
78057: LD_VAR 0 1
78061: PPUSH
78062: CALL_OW 248
78066: PPUSH
78067: CALL_OW 450
78071: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78072: LD_VAR 0 10
78076: PPUSH
78077: LD_INT 1
78079: PPUSH
78080: CALL_OW 275
78084: PUSH
78085: LD_VAR 0 11
78089: PUSH
78090: LD_INT 1
78092: ARRAY
78093: GREATEREQUAL
78094: PUSH
78095: LD_VAR 0 10
78099: PPUSH
78100: LD_INT 2
78102: PPUSH
78103: CALL_OW 275
78107: PUSH
78108: LD_VAR 0 11
78112: PUSH
78113: LD_INT 2
78115: ARRAY
78116: GREATEREQUAL
78117: AND
78118: PUSH
78119: LD_VAR 0 10
78123: PPUSH
78124: LD_INT 3
78126: PPUSH
78127: CALL_OW 275
78131: PUSH
78132: LD_VAR 0 11
78136: PUSH
78137: LD_INT 3
78139: ARRAY
78140: GREATEREQUAL
78141: AND
78142: NOT
78143: IFFALSE 78147
// exit ;
78145: GO 78749
// if GetBType ( depot ) = b_depot then
78147: LD_VAR 0 1
78151: PPUSH
78152: CALL_OW 266
78156: PUSH
78157: LD_INT 0
78159: EQUAL
78160: IFFALSE 78172
// dist := 28 else
78162: LD_ADDR_VAR 0 14
78166: PUSH
78167: LD_INT 28
78169: ST_TO_ADDR
78170: GO 78180
// dist := 36 ;
78172: LD_ADDR_VAR 0 14
78176: PUSH
78177: LD_INT 36
78179: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78180: LD_VAR 0 1
78184: PPUSH
78185: LD_VAR 0 3
78189: PPUSH
78190: LD_VAR 0 4
78194: PPUSH
78195: CALL_OW 297
78199: PUSH
78200: LD_VAR 0 14
78204: GREATER
78205: IFFALSE 78209
// exit ;
78207: GO 78749
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78209: LD_ADDR_VAR 0 12
78213: PUSH
78214: LD_VAR 0 2
78218: PPUSH
78219: LD_VAR 0 3
78223: PPUSH
78224: LD_VAR 0 4
78228: PPUSH
78229: LD_VAR 0 5
78233: PPUSH
78234: LD_VAR 0 1
78238: PPUSH
78239: CALL_OW 248
78243: PPUSH
78244: LD_INT 0
78246: PPUSH
78247: CALL 78754 0 6
78251: ST_TO_ADDR
// if not hexes then
78252: LD_VAR 0 12
78256: NOT
78257: IFFALSE 78261
// exit ;
78259: GO 78749
// hex := GetHexInfo ( x , y ) ;
78261: LD_ADDR_VAR 0 15
78265: PUSH
78266: LD_VAR 0 3
78270: PPUSH
78271: LD_VAR 0 4
78275: PPUSH
78276: CALL_OW 546
78280: ST_TO_ADDR
// if hex [ 1 ] then
78281: LD_VAR 0 15
78285: PUSH
78286: LD_INT 1
78288: ARRAY
78289: IFFALSE 78293
// exit ;
78291: GO 78749
// height := hex [ 2 ] ;
78293: LD_ADDR_VAR 0 13
78297: PUSH
78298: LD_VAR 0 15
78302: PUSH
78303: LD_INT 2
78305: ARRAY
78306: ST_TO_ADDR
// for i = 1 to hexes do
78307: LD_ADDR_VAR 0 7
78311: PUSH
78312: DOUBLE
78313: LD_INT 1
78315: DEC
78316: ST_TO_ADDR
78317: LD_VAR 0 12
78321: PUSH
78322: FOR_TO
78323: IFFALSE 78653
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
78325: LD_VAR 0 12
78329: PUSH
78330: LD_VAR 0 7
78334: ARRAY
78335: PUSH
78336: LD_INT 1
78338: ARRAY
78339: PPUSH
78340: LD_VAR 0 12
78344: PUSH
78345: LD_VAR 0 7
78349: ARRAY
78350: PUSH
78351: LD_INT 2
78353: ARRAY
78354: PPUSH
78355: CALL_OW 488
78359: NOT
78360: PUSH
78361: LD_VAR 0 12
78365: PUSH
78366: LD_VAR 0 7
78370: ARRAY
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: PPUSH
78376: LD_VAR 0 12
78380: PUSH
78381: LD_VAR 0 7
78385: ARRAY
78386: PUSH
78387: LD_INT 2
78389: ARRAY
78390: PPUSH
78391: CALL_OW 428
78395: PUSH
78396: LD_INT 0
78398: GREATER
78399: OR
78400: PUSH
78401: LD_VAR 0 12
78405: PUSH
78406: LD_VAR 0 7
78410: ARRAY
78411: PUSH
78412: LD_INT 1
78414: ARRAY
78415: PPUSH
78416: LD_VAR 0 12
78420: PUSH
78421: LD_VAR 0 7
78425: ARRAY
78426: PUSH
78427: LD_INT 2
78429: ARRAY
78430: PPUSH
78431: CALL_OW 351
78435: OR
78436: IFFALSE 78442
// exit ;
78438: POP
78439: POP
78440: GO 78749
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78442: LD_ADDR_VAR 0 8
78446: PUSH
78447: LD_VAR 0 12
78451: PUSH
78452: LD_VAR 0 7
78456: ARRAY
78457: PUSH
78458: LD_INT 1
78460: ARRAY
78461: PPUSH
78462: LD_VAR 0 12
78466: PUSH
78467: LD_VAR 0 7
78471: ARRAY
78472: PUSH
78473: LD_INT 2
78475: ARRAY
78476: PPUSH
78477: CALL_OW 546
78481: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78482: LD_VAR 0 8
78486: PUSH
78487: LD_INT 1
78489: ARRAY
78490: PUSH
78491: LD_VAR 0 8
78495: PUSH
78496: LD_INT 2
78498: ARRAY
78499: PUSH
78500: LD_VAR 0 13
78504: PUSH
78505: LD_INT 2
78507: PLUS
78508: GREATER
78509: OR
78510: PUSH
78511: LD_VAR 0 8
78515: PUSH
78516: LD_INT 2
78518: ARRAY
78519: PUSH
78520: LD_VAR 0 13
78524: PUSH
78525: LD_INT 2
78527: MINUS
78528: LESS
78529: OR
78530: PUSH
78531: LD_VAR 0 8
78535: PUSH
78536: LD_INT 3
78538: ARRAY
78539: PUSH
78540: LD_INT 0
78542: PUSH
78543: LD_INT 8
78545: PUSH
78546: LD_INT 9
78548: PUSH
78549: LD_INT 10
78551: PUSH
78552: LD_INT 11
78554: PUSH
78555: LD_INT 12
78557: PUSH
78558: LD_INT 13
78560: PUSH
78561: LD_INT 16
78563: PUSH
78564: LD_INT 17
78566: PUSH
78567: LD_INT 18
78569: PUSH
78570: LD_INT 19
78572: PUSH
78573: LD_INT 20
78575: PUSH
78576: LD_INT 21
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: LIST
78585: LIST
78586: LIST
78587: LIST
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: LIST
78593: IN
78594: NOT
78595: OR
78596: PUSH
78597: LD_VAR 0 8
78601: PUSH
78602: LD_INT 5
78604: ARRAY
78605: NOT
78606: OR
78607: PUSH
78608: LD_VAR 0 8
78612: PUSH
78613: LD_INT 6
78615: ARRAY
78616: PUSH
78617: LD_INT 1
78619: PUSH
78620: LD_INT 2
78622: PUSH
78623: LD_INT 7
78625: PUSH
78626: LD_INT 9
78628: PUSH
78629: LD_INT 10
78631: PUSH
78632: LD_INT 11
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: LIST
78639: LIST
78640: LIST
78641: LIST
78642: IN
78643: NOT
78644: OR
78645: IFFALSE 78651
// exit ;
78647: POP
78648: POP
78649: GO 78749
// end ;
78651: GO 78322
78653: POP
78654: POP
// side := GetSide ( depot ) ;
78655: LD_ADDR_VAR 0 9
78659: PUSH
78660: LD_VAR 0 1
78664: PPUSH
78665: CALL_OW 255
78669: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78670: LD_VAR 0 9
78674: PPUSH
78675: LD_VAR 0 3
78679: PPUSH
78680: LD_VAR 0 4
78684: PPUSH
78685: LD_INT 20
78687: PPUSH
78688: CALL 71403 0 4
78692: PUSH
78693: LD_INT 4
78695: ARRAY
78696: IFFALSE 78700
// exit ;
78698: GO 78749
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78700: LD_VAR 0 2
78704: PUSH
78705: LD_INT 29
78707: PUSH
78708: LD_INT 30
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: IN
78715: PUSH
78716: LD_VAR 0 3
78720: PPUSH
78721: LD_VAR 0 4
78725: PPUSH
78726: LD_VAR 0 9
78730: PPUSH
78731: CALL_OW 440
78735: NOT
78736: AND
78737: IFFALSE 78741
// exit ;
78739: GO 78749
// result := true ;
78741: LD_ADDR_VAR 0 6
78745: PUSH
78746: LD_INT 1
78748: ST_TO_ADDR
// end ;
78749: LD_VAR 0 6
78753: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
78754: LD_INT 0
78756: PPUSH
78757: PPUSH
78758: PPUSH
78759: PPUSH
78760: PPUSH
78761: PPUSH
78762: PPUSH
78763: PPUSH
78764: PPUSH
78765: PPUSH
78766: PPUSH
78767: PPUSH
78768: PPUSH
78769: PPUSH
78770: PPUSH
78771: PPUSH
78772: PPUSH
78773: PPUSH
78774: PPUSH
78775: PPUSH
78776: PPUSH
78777: PPUSH
78778: PPUSH
78779: PPUSH
78780: PPUSH
78781: PPUSH
78782: PPUSH
78783: PPUSH
78784: PPUSH
78785: PPUSH
78786: PPUSH
78787: PPUSH
78788: PPUSH
78789: PPUSH
78790: PPUSH
78791: PPUSH
78792: PPUSH
78793: PPUSH
78794: PPUSH
78795: PPUSH
78796: PPUSH
78797: PPUSH
78798: PPUSH
78799: PPUSH
78800: PPUSH
78801: PPUSH
78802: PPUSH
78803: PPUSH
78804: PPUSH
78805: PPUSH
78806: PPUSH
78807: PPUSH
78808: PPUSH
78809: PPUSH
78810: PPUSH
78811: PPUSH
78812: PPUSH
78813: PPUSH
// result = [ ] ;
78814: LD_ADDR_VAR 0 7
78818: PUSH
78819: EMPTY
78820: ST_TO_ADDR
// temp_list = [ ] ;
78821: LD_ADDR_VAR 0 9
78825: PUSH
78826: EMPTY
78827: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78828: LD_VAR 0 4
78832: PUSH
78833: LD_INT 0
78835: PUSH
78836: LD_INT 1
78838: PUSH
78839: LD_INT 2
78841: PUSH
78842: LD_INT 3
78844: PUSH
78845: LD_INT 4
78847: PUSH
78848: LD_INT 5
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: LIST
78858: IN
78859: NOT
78860: PUSH
78861: LD_VAR 0 1
78865: PUSH
78866: LD_INT 0
78868: PUSH
78869: LD_INT 1
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: IN
78876: PUSH
78877: LD_VAR 0 5
78881: PUSH
78882: LD_INT 1
78884: PUSH
78885: LD_INT 2
78887: PUSH
78888: LD_INT 3
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: LIST
78895: IN
78896: NOT
78897: AND
78898: OR
78899: IFFALSE 78903
// exit ;
78901: GO 97294
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78903: LD_VAR 0 1
78907: PUSH
78908: LD_INT 6
78910: PUSH
78911: LD_INT 7
78913: PUSH
78914: LD_INT 8
78916: PUSH
78917: LD_INT 13
78919: PUSH
78920: LD_INT 12
78922: PUSH
78923: LD_INT 15
78925: PUSH
78926: LD_INT 11
78928: PUSH
78929: LD_INT 14
78931: PUSH
78932: LD_INT 10
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: LIST
78939: LIST
78940: LIST
78941: LIST
78942: LIST
78943: LIST
78944: LIST
78945: IN
78946: IFFALSE 78956
// btype = b_lab ;
78948: LD_ADDR_VAR 0 1
78952: PUSH
78953: LD_INT 6
78955: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78956: LD_VAR 0 6
78960: PUSH
78961: LD_INT 0
78963: PUSH
78964: LD_INT 1
78966: PUSH
78967: LD_INT 2
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: LIST
78974: IN
78975: NOT
78976: PUSH
78977: LD_VAR 0 1
78981: PUSH
78982: LD_INT 0
78984: PUSH
78985: LD_INT 1
78987: PUSH
78988: LD_INT 2
78990: PUSH
78991: LD_INT 3
78993: PUSH
78994: LD_INT 6
78996: PUSH
78997: LD_INT 36
78999: PUSH
79000: LD_INT 4
79002: PUSH
79003: LD_INT 5
79005: PUSH
79006: LD_INT 31
79008: PUSH
79009: LD_INT 32
79011: PUSH
79012: LD_INT 33
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: IN
79028: NOT
79029: PUSH
79030: LD_VAR 0 6
79034: PUSH
79035: LD_INT 1
79037: EQUAL
79038: AND
79039: OR
79040: PUSH
79041: LD_VAR 0 1
79045: PUSH
79046: LD_INT 2
79048: PUSH
79049: LD_INT 3
79051: PUSH
79052: EMPTY
79053: LIST
79054: LIST
79055: IN
79056: NOT
79057: PUSH
79058: LD_VAR 0 6
79062: PUSH
79063: LD_INT 2
79065: EQUAL
79066: AND
79067: OR
79068: IFFALSE 79078
// mode = 0 ;
79070: LD_ADDR_VAR 0 6
79074: PUSH
79075: LD_INT 0
79077: ST_TO_ADDR
// case mode of 0 :
79078: LD_VAR 0 6
79082: PUSH
79083: LD_INT 0
79085: DOUBLE
79086: EQUAL
79087: IFTRUE 79091
79089: GO 90544
79091: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79092: LD_ADDR_VAR 0 11
79096: PUSH
79097: LD_INT 0
79099: PUSH
79100: LD_INT 0
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 0
79109: PUSH
79110: LD_INT 1
79112: NEG
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: PUSH
79118: LD_INT 1
79120: PUSH
79121: LD_INT 0
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 1
79130: PUSH
79131: LD_INT 1
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 0
79140: PUSH
79141: LD_INT 1
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 1
79150: NEG
79151: PUSH
79152: LD_INT 0
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 1
79161: NEG
79162: PUSH
79163: LD_INT 1
79165: NEG
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 1
79173: NEG
79174: PUSH
79175: LD_INT 2
79177: NEG
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 0
79185: PUSH
79186: LD_INT 2
79188: NEG
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 1
79196: PUSH
79197: LD_INT 1
79199: NEG
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: LD_INT 1
79207: PUSH
79208: LD_INT 2
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 0
79217: PUSH
79218: LD_INT 2
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 1
79227: NEG
79228: PUSH
79229: LD_INT 1
79231: PUSH
79232: EMPTY
79233: LIST
79234: LIST
79235: PUSH
79236: LD_INT 1
79238: PUSH
79239: LD_INT 3
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 0
79248: PUSH
79249: LD_INT 3
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 1
79258: NEG
79259: PUSH
79260: LD_INT 2
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: LIST
79271: LIST
79272: LIST
79273: LIST
79274: LIST
79275: LIST
79276: LIST
79277: LIST
79278: LIST
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79285: LD_ADDR_VAR 0 12
79289: PUSH
79290: LD_INT 0
79292: PUSH
79293: LD_INT 0
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 0
79302: PUSH
79303: LD_INT 1
79305: NEG
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 1
79313: PUSH
79314: LD_INT 0
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: PUSH
79321: LD_INT 1
79323: PUSH
79324: LD_INT 1
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: PUSH
79331: LD_INT 0
79333: PUSH
79334: LD_INT 1
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: PUSH
79341: LD_INT 1
79343: NEG
79344: PUSH
79345: LD_INT 0
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: LD_INT 1
79354: NEG
79355: PUSH
79356: LD_INT 1
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 1
79366: PUSH
79367: LD_INT 1
79369: NEG
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 2
79377: PUSH
79378: LD_INT 0
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 2
79387: PUSH
79388: LD_INT 1
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 1
79397: NEG
79398: PUSH
79399: LD_INT 1
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 2
79408: NEG
79409: PUSH
79410: LD_INT 0
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: PUSH
79417: LD_INT 2
79419: NEG
79420: PUSH
79421: LD_INT 1
79423: NEG
79424: PUSH
79425: EMPTY
79426: LIST
79427: LIST
79428: PUSH
79429: LD_INT 2
79431: NEG
79432: PUSH
79433: LD_INT 1
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PUSH
79440: LD_INT 3
79442: NEG
79443: PUSH
79444: LD_INT 0
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: LD_INT 3
79453: NEG
79454: PUSH
79455: LD_INT 1
79457: NEG
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: LIST
79467: LIST
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: LIST
79480: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79481: LD_ADDR_VAR 0 13
79485: PUSH
79486: LD_INT 0
79488: PUSH
79489: LD_INT 0
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 0
79498: PUSH
79499: LD_INT 1
79501: NEG
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 1
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 1
79519: PUSH
79520: LD_INT 1
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: LD_INT 1
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 1
79539: NEG
79540: PUSH
79541: LD_INT 0
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 1
79550: NEG
79551: PUSH
79552: LD_INT 1
79554: NEG
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: NEG
79563: PUSH
79564: LD_INT 2
79566: NEG
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 2
79574: PUSH
79575: LD_INT 1
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 2
79584: PUSH
79585: LD_INT 2
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 1
79594: PUSH
79595: LD_INT 2
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 2
79604: NEG
79605: PUSH
79606: LD_INT 1
79608: NEG
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 2
79616: NEG
79617: PUSH
79618: LD_INT 2
79620: NEG
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 2
79628: NEG
79629: PUSH
79630: LD_INT 3
79632: NEG
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 3
79640: NEG
79641: PUSH
79642: LD_INT 2
79644: NEG
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: LD_INT 3
79652: NEG
79653: PUSH
79654: LD_INT 3
79656: NEG
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: LIST
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79680: LD_ADDR_VAR 0 14
79684: PUSH
79685: LD_INT 0
79687: PUSH
79688: LD_INT 0
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 0
79697: PUSH
79698: LD_INT 1
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 1
79708: PUSH
79709: LD_INT 0
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 1
79718: PUSH
79719: LD_INT 1
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 0
79728: PUSH
79729: LD_INT 1
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PUSH
79736: LD_INT 1
79738: NEG
79739: PUSH
79740: LD_INT 0
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 1
79749: NEG
79750: PUSH
79751: LD_INT 1
79753: NEG
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 1
79761: NEG
79762: PUSH
79763: LD_INT 2
79765: NEG
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 0
79773: PUSH
79774: LD_INT 2
79776: NEG
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 1
79784: PUSH
79785: LD_INT 1
79787: NEG
79788: PUSH
79789: EMPTY
79790: LIST
79791: LIST
79792: PUSH
79793: LD_INT 1
79795: PUSH
79796: LD_INT 2
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 0
79805: PUSH
79806: LD_INT 2
79808: PUSH
79809: EMPTY
79810: LIST
79811: LIST
79812: PUSH
79813: LD_INT 1
79815: NEG
79816: PUSH
79817: LD_INT 1
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 1
79826: NEG
79827: PUSH
79828: LD_INT 3
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 0
79838: PUSH
79839: LD_INT 3
79841: NEG
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: LD_INT 1
79849: PUSH
79850: LD_INT 2
79852: NEG
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79876: LD_ADDR_VAR 0 15
79880: PUSH
79881: LD_INT 0
79883: PUSH
79884: LD_INT 0
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: PUSH
79891: LD_INT 0
79893: PUSH
79894: LD_INT 1
79896: NEG
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 1
79904: PUSH
79905: LD_INT 0
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 1
79914: PUSH
79915: LD_INT 1
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 0
79924: PUSH
79925: LD_INT 1
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 1
79934: NEG
79935: PUSH
79936: LD_INT 0
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 1
79945: NEG
79946: PUSH
79947: LD_INT 1
79949: NEG
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 1
79957: PUSH
79958: LD_INT 1
79960: NEG
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 2
79968: PUSH
79969: LD_INT 0
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: LD_INT 2
79978: PUSH
79979: LD_INT 1
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 1
79988: NEG
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 2
79999: NEG
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 2
80010: NEG
80011: PUSH
80012: LD_INT 1
80014: NEG
80015: PUSH
80016: EMPTY
80017: LIST
80018: LIST
80019: PUSH
80020: LD_INT 2
80022: PUSH
80023: LD_INT 1
80025: NEG
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: PUSH
80031: LD_INT 3
80033: PUSH
80034: LD_INT 0
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 3
80043: PUSH
80044: LD_INT 1
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: LIST
80055: LIST
80056: LIST
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80069: LD_ADDR_VAR 0 16
80073: PUSH
80074: LD_INT 0
80076: PUSH
80077: LD_INT 0
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: LD_INT 0
80086: PUSH
80087: LD_INT 1
80089: NEG
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 1
80097: PUSH
80098: LD_INT 0
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 1
80107: PUSH
80108: LD_INT 1
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 0
80117: PUSH
80118: LD_INT 1
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 1
80127: NEG
80128: PUSH
80129: LD_INT 0
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 1
80138: NEG
80139: PUSH
80140: LD_INT 1
80142: NEG
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: LD_INT 1
80150: NEG
80151: PUSH
80152: LD_INT 2
80154: NEG
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 2
80162: PUSH
80163: LD_INT 1
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 2
80172: PUSH
80173: LD_INT 2
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 1
80182: PUSH
80183: LD_INT 2
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 2
80192: NEG
80193: PUSH
80194: LD_INT 1
80196: NEG
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 2
80204: NEG
80205: PUSH
80206: LD_INT 2
80208: NEG
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 3
80216: PUSH
80217: LD_INT 2
80219: PUSH
80220: EMPTY
80221: LIST
80222: LIST
80223: PUSH
80224: LD_INT 3
80226: PUSH
80227: LD_INT 3
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: PUSH
80234: LD_INT 2
80236: PUSH
80237: LD_INT 3
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: LIST
80248: LIST
80249: LIST
80250: LIST
80251: LIST
80252: LIST
80253: LIST
80254: LIST
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80262: LD_ADDR_VAR 0 17
80266: PUSH
80267: LD_INT 0
80269: PUSH
80270: LD_INT 0
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 0
80279: PUSH
80280: LD_INT 1
80282: NEG
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 1
80290: PUSH
80291: LD_INT 0
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 1
80300: PUSH
80301: LD_INT 1
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 0
80310: PUSH
80311: LD_INT 1
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 1
80320: NEG
80321: PUSH
80322: LD_INT 0
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 1
80331: NEG
80332: PUSH
80333: LD_INT 1
80335: NEG
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 1
80343: NEG
80344: PUSH
80345: LD_INT 2
80347: NEG
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 0
80355: PUSH
80356: LD_INT 2
80358: NEG
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 1
80366: PUSH
80367: LD_INT 1
80369: NEG
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 2
80377: PUSH
80378: LD_INT 0
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 2
80387: PUSH
80388: LD_INT 1
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 2
80397: PUSH
80398: LD_INT 2
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 1
80407: PUSH
80408: LD_INT 2
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 0
80417: PUSH
80418: LD_INT 2
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 1
80427: NEG
80428: PUSH
80429: LD_INT 1
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 2
80438: NEG
80439: PUSH
80440: LD_INT 0
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 2
80449: NEG
80450: PUSH
80451: LD_INT 1
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 2
80461: NEG
80462: PUSH
80463: LD_INT 2
80465: NEG
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: LIST
80483: LIST
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80492: LD_ADDR_VAR 0 18
80496: PUSH
80497: LD_INT 0
80499: PUSH
80500: LD_INT 0
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PUSH
80507: LD_INT 0
80509: PUSH
80510: LD_INT 1
80512: NEG
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 1
80520: PUSH
80521: LD_INT 0
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 1
80530: PUSH
80531: LD_INT 1
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 0
80540: PUSH
80541: LD_INT 1
80543: PUSH
80544: EMPTY
80545: LIST
80546: LIST
80547: PUSH
80548: LD_INT 1
80550: NEG
80551: PUSH
80552: LD_INT 0
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 1
80561: NEG
80562: PUSH
80563: LD_INT 1
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 1
80573: NEG
80574: PUSH
80575: LD_INT 2
80577: NEG
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 0
80585: PUSH
80586: LD_INT 2
80588: NEG
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 1
80596: PUSH
80597: LD_INT 1
80599: NEG
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 2
80607: PUSH
80608: LD_INT 0
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 2
80617: PUSH
80618: LD_INT 1
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 2
80627: PUSH
80628: LD_INT 2
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: PUSH
80638: LD_INT 2
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: LD_INT 2
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 1
80657: NEG
80658: PUSH
80659: LD_INT 1
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 2
80668: NEG
80669: PUSH
80670: LD_INT 0
80672: PUSH
80673: EMPTY
80674: LIST
80675: LIST
80676: PUSH
80677: LD_INT 2
80679: NEG
80680: PUSH
80681: LD_INT 1
80683: NEG
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 2
80691: NEG
80692: PUSH
80693: LD_INT 2
80695: NEG
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80722: LD_ADDR_VAR 0 19
80726: PUSH
80727: LD_INT 0
80729: PUSH
80730: LD_INT 0
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 0
80739: PUSH
80740: LD_INT 1
80742: NEG
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 1
80750: PUSH
80751: LD_INT 0
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 1
80760: PUSH
80761: LD_INT 1
80763: PUSH
80764: EMPTY
80765: LIST
80766: LIST
80767: PUSH
80768: LD_INT 0
80770: PUSH
80771: LD_INT 1
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 1
80780: NEG
80781: PUSH
80782: LD_INT 0
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PUSH
80789: LD_INT 1
80791: NEG
80792: PUSH
80793: LD_INT 1
80795: NEG
80796: PUSH
80797: EMPTY
80798: LIST
80799: LIST
80800: PUSH
80801: LD_INT 1
80803: NEG
80804: PUSH
80805: LD_INT 2
80807: NEG
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: PUSH
80813: LD_INT 0
80815: PUSH
80816: LD_INT 2
80818: NEG
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 1
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 2
80837: PUSH
80838: LD_INT 0
80840: PUSH
80841: EMPTY
80842: LIST
80843: LIST
80844: PUSH
80845: LD_INT 2
80847: PUSH
80848: LD_INT 1
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: LD_INT 2
80857: PUSH
80858: LD_INT 2
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 1
80867: PUSH
80868: LD_INT 2
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: LD_INT 0
80877: PUSH
80878: LD_INT 2
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 1
80887: NEG
80888: PUSH
80889: LD_INT 1
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: PUSH
80896: LD_INT 2
80898: NEG
80899: PUSH
80900: LD_INT 0
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 2
80909: NEG
80910: PUSH
80911: LD_INT 1
80913: NEG
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 2
80921: NEG
80922: PUSH
80923: LD_INT 2
80925: NEG
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80952: LD_ADDR_VAR 0 20
80956: PUSH
80957: LD_INT 0
80959: PUSH
80960: LD_INT 0
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 0
80969: PUSH
80970: LD_INT 1
80972: NEG
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 1
80980: PUSH
80981: LD_INT 0
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 1
80990: PUSH
80991: LD_INT 1
80993: PUSH
80994: EMPTY
80995: LIST
80996: LIST
80997: PUSH
80998: LD_INT 0
81000: PUSH
81001: LD_INT 1
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 1
81010: NEG
81011: PUSH
81012: LD_INT 0
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: LD_INT 1
81025: NEG
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 1
81033: NEG
81034: PUSH
81035: LD_INT 2
81037: NEG
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 0
81045: PUSH
81046: LD_INT 2
81048: NEG
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: PUSH
81054: LD_INT 1
81056: PUSH
81057: LD_INT 1
81059: NEG
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 2
81067: PUSH
81068: LD_INT 0
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 2
81077: PUSH
81078: LD_INT 1
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 2
81087: PUSH
81088: LD_INT 2
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 1
81097: PUSH
81098: LD_INT 2
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 0
81107: PUSH
81108: LD_INT 2
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 1
81117: NEG
81118: PUSH
81119: LD_INT 1
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 2
81128: NEG
81129: PUSH
81130: LD_INT 0
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 2
81139: NEG
81140: PUSH
81141: LD_INT 1
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 2
81151: NEG
81152: PUSH
81153: LD_INT 2
81155: NEG
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81182: LD_ADDR_VAR 0 21
81186: PUSH
81187: LD_INT 0
81189: PUSH
81190: LD_INT 0
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 0
81199: PUSH
81200: LD_INT 1
81202: NEG
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 1
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 1
81220: PUSH
81221: LD_INT 1
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 0
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 1
81240: NEG
81241: PUSH
81242: LD_INT 0
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 1
81251: NEG
81252: PUSH
81253: LD_INT 1
81255: NEG
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: LD_INT 2
81267: NEG
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 0
81275: PUSH
81276: LD_INT 2
81278: NEG
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 1
81286: PUSH
81287: LD_INT 1
81289: NEG
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 2
81297: PUSH
81298: LD_INT 0
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 2
81307: PUSH
81308: LD_INT 1
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 2
81317: PUSH
81318: LD_INT 2
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 1
81327: PUSH
81328: LD_INT 2
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 0
81337: PUSH
81338: LD_INT 2
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 1
81347: NEG
81348: PUSH
81349: LD_INT 1
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 2
81358: NEG
81359: PUSH
81360: LD_INT 0
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 2
81369: NEG
81370: PUSH
81371: LD_INT 1
81373: NEG
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 2
81381: NEG
81382: PUSH
81383: LD_INT 2
81385: NEG
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: LIST
81395: LIST
81396: LIST
81397: LIST
81398: LIST
81399: LIST
81400: LIST
81401: LIST
81402: LIST
81403: LIST
81404: LIST
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81412: LD_ADDR_VAR 0 22
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: LD_INT 0
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: PUSH
81427: LD_INT 0
81429: PUSH
81430: LD_INT 1
81432: NEG
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 1
81440: PUSH
81441: LD_INT 0
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 1
81450: PUSH
81451: LD_INT 1
81453: PUSH
81454: EMPTY
81455: LIST
81456: LIST
81457: PUSH
81458: LD_INT 0
81460: PUSH
81461: LD_INT 1
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 1
81470: NEG
81471: PUSH
81472: LD_INT 0
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 1
81481: NEG
81482: PUSH
81483: LD_INT 1
81485: NEG
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 1
81493: NEG
81494: PUSH
81495: LD_INT 2
81497: NEG
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: PUSH
81503: LD_INT 0
81505: PUSH
81506: LD_INT 2
81508: NEG
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 1
81516: PUSH
81517: LD_INT 1
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 2
81527: PUSH
81528: LD_INT 0
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 2
81537: PUSH
81538: LD_INT 1
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 2
81547: PUSH
81548: LD_INT 2
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 1
81557: PUSH
81558: LD_INT 2
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 0
81567: PUSH
81568: LD_INT 2
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: NEG
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 2
81588: NEG
81589: PUSH
81590: LD_INT 0
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: PUSH
81597: LD_INT 2
81599: NEG
81600: PUSH
81601: LD_INT 1
81603: NEG
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: PUSH
81609: LD_INT 2
81611: NEG
81612: PUSH
81613: LD_INT 2
81615: NEG
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81642: LD_ADDR_VAR 0 23
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: LD_INT 0
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: PUSH
81657: LD_INT 0
81659: PUSH
81660: LD_INT 1
81662: NEG
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 1
81670: PUSH
81671: LD_INT 0
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 1
81680: PUSH
81681: LD_INT 1
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 0
81690: PUSH
81691: LD_INT 1
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 1
81700: NEG
81701: PUSH
81702: LD_INT 0
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 1
81711: NEG
81712: PUSH
81713: LD_INT 1
81715: NEG
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 1
81723: NEG
81724: PUSH
81725: LD_INT 2
81727: NEG
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 0
81735: PUSH
81736: LD_INT 2
81738: NEG
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: LD_INT 1
81746: PUSH
81747: LD_INT 1
81749: NEG
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 2
81757: PUSH
81758: LD_INT 0
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 2
81767: PUSH
81768: LD_INT 1
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 2
81777: PUSH
81778: LD_INT 2
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: LD_INT 2
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 0
81797: PUSH
81798: LD_INT 2
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 1
81807: NEG
81808: PUSH
81809: LD_INT 1
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 2
81818: NEG
81819: PUSH
81820: LD_INT 0
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 2
81829: NEG
81830: PUSH
81831: LD_INT 1
81833: NEG
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 2
81841: NEG
81842: PUSH
81843: LD_INT 2
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 2
81853: NEG
81854: PUSH
81855: LD_INT 3
81857: NEG
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 1
81865: NEG
81866: PUSH
81867: LD_INT 3
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 1
81877: PUSH
81878: LD_INT 2
81880: NEG
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 2
81888: PUSH
81889: LD_INT 1
81891: NEG
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: LIST
81901: LIST
81902: LIST
81903: LIST
81904: LIST
81905: LIST
81906: LIST
81907: LIST
81908: LIST
81909: LIST
81910: LIST
81911: LIST
81912: LIST
81913: LIST
81914: LIST
81915: LIST
81916: LIST
81917: LIST
81918: LIST
81919: LIST
81920: LIST
81921: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81922: LD_ADDR_VAR 0 24
81926: PUSH
81927: LD_INT 0
81929: PUSH
81930: LD_INT 0
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 0
81939: PUSH
81940: LD_INT 1
81942: NEG
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 1
81950: PUSH
81951: LD_INT 0
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 1
81960: PUSH
81961: LD_INT 1
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: LD_INT 1
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 1
81980: NEG
81981: PUSH
81982: LD_INT 0
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 1
81991: NEG
81992: PUSH
81993: LD_INT 1
81995: NEG
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 1
82003: NEG
82004: PUSH
82005: LD_INT 2
82007: NEG
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 0
82015: PUSH
82016: LD_INT 2
82018: NEG
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 1
82026: PUSH
82027: LD_INT 1
82029: NEG
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PUSH
82035: LD_INT 2
82037: PUSH
82038: LD_INT 0
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: LD_INT 2
82047: PUSH
82048: LD_INT 1
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 2
82057: PUSH
82058: LD_INT 2
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 1
82067: PUSH
82068: LD_INT 2
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 0
82077: PUSH
82078: LD_INT 2
82080: PUSH
82081: EMPTY
82082: LIST
82083: LIST
82084: PUSH
82085: LD_INT 1
82087: NEG
82088: PUSH
82089: LD_INT 1
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: LD_INT 2
82098: NEG
82099: PUSH
82100: LD_INT 0
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 2
82109: NEG
82110: PUSH
82111: LD_INT 1
82113: NEG
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 2
82121: NEG
82122: PUSH
82123: LD_INT 2
82125: NEG
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 1
82133: PUSH
82134: LD_INT 2
82136: NEG
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 2
82144: PUSH
82145: LD_INT 1
82147: NEG
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 3
82155: PUSH
82156: LD_INT 1
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 3
82165: PUSH
82166: LD_INT 2
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82198: LD_ADDR_VAR 0 25
82202: PUSH
82203: LD_INT 0
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: LD_INT 1
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 1
82226: PUSH
82227: LD_INT 0
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 1
82236: PUSH
82237: LD_INT 1
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 0
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 1
82256: NEG
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 1
82267: NEG
82268: PUSH
82269: LD_INT 1
82271: NEG
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 1
82279: NEG
82280: PUSH
82281: LD_INT 2
82283: NEG
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: LD_INT 2
82294: NEG
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 1
82302: PUSH
82303: LD_INT 1
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 2
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 2
82323: PUSH
82324: LD_INT 1
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 2
82333: PUSH
82334: LD_INT 2
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: LD_INT 2
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: LD_INT 2
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 1
82363: NEG
82364: PUSH
82365: LD_INT 1
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 2
82374: NEG
82375: PUSH
82376: LD_INT 0
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 2
82385: NEG
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 2
82397: NEG
82398: PUSH
82399: LD_INT 2
82401: NEG
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: LD_INT 3
82409: PUSH
82410: LD_INT 1
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 3
82419: PUSH
82420: LD_INT 2
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 2
82429: PUSH
82430: LD_INT 3
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 1
82439: PUSH
82440: LD_INT 3
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: LIST
82451: LIST
82452: LIST
82453: LIST
82454: LIST
82455: LIST
82456: LIST
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: LIST
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: LIST
82469: LIST
82470: LIST
82471: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82472: LD_ADDR_VAR 0 26
82476: PUSH
82477: LD_INT 0
82479: PUSH
82480: LD_INT 0
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 0
82489: PUSH
82490: LD_INT 1
82492: NEG
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 1
82500: PUSH
82501: LD_INT 0
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 1
82510: PUSH
82511: LD_INT 1
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 0
82520: PUSH
82521: LD_INT 1
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 1
82530: NEG
82531: PUSH
82532: LD_INT 0
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 1
82541: NEG
82542: PUSH
82543: LD_INT 1
82545: NEG
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 1
82553: NEG
82554: PUSH
82555: LD_INT 2
82557: NEG
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 0
82565: PUSH
82566: LD_INT 2
82568: NEG
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 1
82576: PUSH
82577: LD_INT 1
82579: NEG
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 2
82587: PUSH
82588: LD_INT 0
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 2
82597: PUSH
82598: LD_INT 1
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 2
82607: PUSH
82608: LD_INT 2
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 1
82617: PUSH
82618: LD_INT 2
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 0
82627: PUSH
82628: LD_INT 2
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 1
82637: NEG
82638: PUSH
82639: LD_INT 1
82641: PUSH
82642: EMPTY
82643: LIST
82644: LIST
82645: PUSH
82646: LD_INT 2
82648: NEG
82649: PUSH
82650: LD_INT 0
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 2
82659: NEG
82660: PUSH
82661: LD_INT 1
82663: NEG
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 2
82671: NEG
82672: PUSH
82673: LD_INT 2
82675: NEG
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 2
82683: PUSH
82684: LD_INT 3
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: PUSH
82691: LD_INT 1
82693: PUSH
82694: LD_INT 3
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 1
82703: NEG
82704: PUSH
82705: LD_INT 2
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 2
82714: NEG
82715: PUSH
82716: LD_INT 1
82718: PUSH
82719: EMPTY
82720: LIST
82721: LIST
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82748: LD_ADDR_VAR 0 27
82752: PUSH
82753: LD_INT 0
82755: PUSH
82756: LD_INT 0
82758: PUSH
82759: EMPTY
82760: LIST
82761: LIST
82762: PUSH
82763: LD_INT 0
82765: PUSH
82766: LD_INT 1
82768: NEG
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 1
82776: PUSH
82777: LD_INT 0
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 1
82786: PUSH
82787: LD_INT 1
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 0
82796: PUSH
82797: LD_INT 1
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 1
82806: NEG
82807: PUSH
82808: LD_INT 0
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: PUSH
82815: LD_INT 1
82817: NEG
82818: PUSH
82819: LD_INT 1
82821: NEG
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 1
82829: NEG
82830: PUSH
82831: LD_INT 2
82833: NEG
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 0
82841: PUSH
82842: LD_INT 2
82844: NEG
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 1
82852: PUSH
82853: LD_INT 1
82855: NEG
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 2
82863: PUSH
82864: LD_INT 0
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 2
82873: PUSH
82874: LD_INT 1
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 2
82883: PUSH
82884: LD_INT 2
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 1
82893: PUSH
82894: LD_INT 2
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: PUSH
82901: LD_INT 0
82903: PUSH
82904: LD_INT 2
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 1
82913: NEG
82914: PUSH
82915: LD_INT 1
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 2
82924: NEG
82925: PUSH
82926: LD_INT 0
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 2
82935: NEG
82936: PUSH
82937: LD_INT 1
82939: NEG
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: PUSH
82945: LD_INT 2
82947: NEG
82948: PUSH
82949: LD_INT 2
82951: NEG
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 1
82959: NEG
82960: PUSH
82961: LD_INT 2
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 2
82970: NEG
82971: PUSH
82972: LD_INT 1
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 3
82981: NEG
82982: PUSH
82983: LD_INT 1
82985: NEG
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 3
82993: NEG
82994: PUSH
82995: LD_INT 2
82997: NEG
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: LIST
83025: LIST
83026: LIST
83027: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83028: LD_ADDR_VAR 0 28
83032: PUSH
83033: LD_INT 0
83035: PUSH
83036: LD_INT 0
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 0
83045: PUSH
83046: LD_INT 1
83048: NEG
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 1
83056: PUSH
83057: LD_INT 0
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: PUSH
83067: LD_INT 1
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 0
83076: PUSH
83077: LD_INT 1
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: LD_INT 1
83086: NEG
83087: PUSH
83088: LD_INT 0
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 1
83097: NEG
83098: PUSH
83099: LD_INT 1
83101: NEG
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 1
83109: NEG
83110: PUSH
83111: LD_INT 2
83113: NEG
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 0
83121: PUSH
83122: LD_INT 2
83124: NEG
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 1
83132: PUSH
83133: LD_INT 1
83135: NEG
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 2
83143: PUSH
83144: LD_INT 0
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 2
83153: PUSH
83154: LD_INT 1
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 2
83163: PUSH
83164: LD_INT 2
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: LD_INT 2
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: LD_INT 0
83183: PUSH
83184: LD_INT 2
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 1
83193: NEG
83194: PUSH
83195: LD_INT 1
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: LD_INT 2
83204: NEG
83205: PUSH
83206: LD_INT 0
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 2
83215: NEG
83216: PUSH
83217: LD_INT 1
83219: NEG
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 2
83227: NEG
83228: PUSH
83229: LD_INT 2
83231: NEG
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 2
83239: NEG
83240: PUSH
83241: LD_INT 3
83243: NEG
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 1
83251: NEG
83252: PUSH
83253: LD_INT 3
83255: NEG
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 3
83263: NEG
83264: PUSH
83265: LD_INT 1
83267: NEG
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 3
83275: NEG
83276: PUSH
83277: LD_INT 2
83279: NEG
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: LIST
83305: LIST
83306: LIST
83307: LIST
83308: LIST
83309: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83310: LD_ADDR_VAR 0 29
83314: PUSH
83315: LD_INT 0
83317: PUSH
83318: LD_INT 0
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: LD_INT 0
83327: PUSH
83328: LD_INT 1
83330: NEG
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 1
83338: PUSH
83339: LD_INT 0
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 1
83348: PUSH
83349: LD_INT 1
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 0
83358: PUSH
83359: LD_INT 1
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 1
83368: NEG
83369: PUSH
83370: LD_INT 0
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 1
83379: NEG
83380: PUSH
83381: LD_INT 1
83383: NEG
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: LD_INT 1
83391: NEG
83392: PUSH
83393: LD_INT 2
83395: NEG
83396: PUSH
83397: EMPTY
83398: LIST
83399: LIST
83400: PUSH
83401: LD_INT 0
83403: PUSH
83404: LD_INT 2
83406: NEG
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 1
83414: PUSH
83415: LD_INT 1
83417: NEG
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 2
83425: PUSH
83426: LD_INT 0
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 2
83435: PUSH
83436: LD_INT 1
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 1
83445: PUSH
83446: LD_INT 2
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 0
83455: PUSH
83456: LD_INT 2
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 1
83465: NEG
83466: PUSH
83467: LD_INT 1
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 2
83476: NEG
83477: PUSH
83478: LD_INT 1
83480: NEG
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 2
83488: NEG
83489: PUSH
83490: LD_INT 2
83492: NEG
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 2
83500: NEG
83501: PUSH
83502: LD_INT 3
83504: NEG
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 2
83512: PUSH
83513: LD_INT 1
83515: NEG
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 3
83523: PUSH
83524: LD_INT 1
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 1
83533: PUSH
83534: LD_INT 3
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 1
83543: NEG
83544: PUSH
83545: LD_INT 2
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 3
83554: NEG
83555: PUSH
83556: LD_INT 2
83558: NEG
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83589: LD_ADDR_VAR 0 30
83593: PUSH
83594: LD_INT 0
83596: PUSH
83597: LD_INT 0
83599: PUSH
83600: EMPTY
83601: LIST
83602: LIST
83603: PUSH
83604: LD_INT 0
83606: PUSH
83607: LD_INT 1
83609: NEG
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: PUSH
83618: LD_INT 0
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: LD_INT 1
83627: PUSH
83628: LD_INT 1
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 0
83637: PUSH
83638: LD_INT 1
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 1
83647: NEG
83648: PUSH
83649: LD_INT 0
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: PUSH
83656: LD_INT 1
83658: NEG
83659: PUSH
83660: LD_INT 1
83662: NEG
83663: PUSH
83664: EMPTY
83665: LIST
83666: LIST
83667: PUSH
83668: LD_INT 1
83670: NEG
83671: PUSH
83672: LD_INT 2
83674: NEG
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 0
83682: PUSH
83683: LD_INT 2
83685: NEG
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: PUSH
83691: LD_INT 1
83693: PUSH
83694: LD_INT 1
83696: NEG
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: LD_INT 2
83704: PUSH
83705: LD_INT 0
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 2
83714: PUSH
83715: LD_INT 1
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 2
83724: PUSH
83725: LD_INT 2
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 1
83734: PUSH
83735: LD_INT 2
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 1
83744: NEG
83745: PUSH
83746: LD_INT 1
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 2
83755: NEG
83756: PUSH
83757: LD_INT 0
83759: PUSH
83760: EMPTY
83761: LIST
83762: LIST
83763: PUSH
83764: LD_INT 2
83766: NEG
83767: PUSH
83768: LD_INT 1
83770: NEG
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 1
83778: NEG
83779: PUSH
83780: LD_INT 3
83782: NEG
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 1
83790: PUSH
83791: LD_INT 2
83793: NEG
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 3
83801: PUSH
83802: LD_INT 2
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 2
83811: PUSH
83812: LD_INT 3
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 2
83821: NEG
83822: PUSH
83823: LD_INT 1
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: PUSH
83830: LD_INT 3
83832: NEG
83833: PUSH
83834: LD_INT 1
83836: NEG
83837: PUSH
83838: EMPTY
83839: LIST
83840: LIST
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: LIST
83865: LIST
83866: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83867: LD_ADDR_VAR 0 31
83871: PUSH
83872: LD_INT 0
83874: PUSH
83875: LD_INT 0
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: PUSH
83882: LD_INT 0
83884: PUSH
83885: LD_INT 1
83887: NEG
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: PUSH
83893: LD_INT 1
83895: PUSH
83896: LD_INT 0
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 1
83905: PUSH
83906: LD_INT 1
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: LD_INT 0
83915: PUSH
83916: LD_INT 1
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: LD_INT 1
83925: NEG
83926: PUSH
83927: LD_INT 0
83929: PUSH
83930: EMPTY
83931: LIST
83932: LIST
83933: PUSH
83934: LD_INT 1
83936: NEG
83937: PUSH
83938: LD_INT 1
83940: NEG
83941: PUSH
83942: EMPTY
83943: LIST
83944: LIST
83945: PUSH
83946: LD_INT 1
83948: NEG
83949: PUSH
83950: LD_INT 2
83952: NEG
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 1
83960: PUSH
83961: LD_INT 1
83963: NEG
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 2
83971: PUSH
83972: LD_INT 0
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 2
83981: PUSH
83982: LD_INT 1
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 2
83991: PUSH
83992: LD_INT 2
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 1
84001: PUSH
84002: LD_INT 2
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 0
84011: PUSH
84012: LD_INT 2
84014: PUSH
84015: EMPTY
84016: LIST
84017: LIST
84018: PUSH
84019: LD_INT 1
84021: NEG
84022: PUSH
84023: LD_INT 1
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 2
84032: NEG
84033: PUSH
84034: LD_INT 1
84036: NEG
84037: PUSH
84038: EMPTY
84039: LIST
84040: LIST
84041: PUSH
84042: LD_INT 2
84044: NEG
84045: PUSH
84046: LD_INT 2
84048: NEG
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 2
84056: NEG
84057: PUSH
84058: LD_INT 3
84060: NEG
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 2
84068: PUSH
84069: LD_INT 1
84071: NEG
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 3
84079: PUSH
84080: LD_INT 1
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 1
84089: PUSH
84090: LD_INT 3
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 1
84099: NEG
84100: PUSH
84101: LD_INT 2
84103: PUSH
84104: EMPTY
84105: LIST
84106: LIST
84107: PUSH
84108: LD_INT 3
84110: NEG
84111: PUSH
84112: LD_INT 2
84114: NEG
84115: PUSH
84116: EMPTY
84117: LIST
84118: LIST
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: LIST
84130: LIST
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84145: LD_ADDR_VAR 0 32
84149: PUSH
84150: LD_INT 0
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 1
84173: PUSH
84174: LD_INT 0
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 1
84183: PUSH
84184: LD_INT 1
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: LD_INT 1
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: LD_INT 0
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 1
84214: NEG
84215: PUSH
84216: LD_INT 1
84218: NEG
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 1
84226: NEG
84227: PUSH
84228: LD_INT 2
84230: NEG
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 0
84238: PUSH
84239: LD_INT 2
84241: NEG
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 1
84249: PUSH
84250: LD_INT 1
84252: NEG
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PUSH
84258: LD_INT 2
84260: PUSH
84261: LD_INT 1
84263: PUSH
84264: EMPTY
84265: LIST
84266: LIST
84267: PUSH
84268: LD_INT 2
84270: PUSH
84271: LD_INT 2
84273: PUSH
84274: EMPTY
84275: LIST
84276: LIST
84277: PUSH
84278: LD_INT 1
84280: PUSH
84281: LD_INT 2
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: PUSH
84288: LD_INT 0
84290: PUSH
84291: LD_INT 2
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: LD_INT 1
84300: NEG
84301: PUSH
84302: LD_INT 1
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 2
84311: NEG
84312: PUSH
84313: LD_INT 0
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: LD_INT 2
84322: NEG
84323: PUSH
84324: LD_INT 1
84326: NEG
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 1
84334: NEG
84335: PUSH
84336: LD_INT 3
84338: NEG
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: PUSH
84344: LD_INT 1
84346: PUSH
84347: LD_INT 2
84349: NEG
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: PUSH
84355: LD_INT 3
84357: PUSH
84358: LD_INT 2
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: PUSH
84365: LD_INT 2
84367: PUSH
84368: LD_INT 3
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: LD_INT 1
84381: PUSH
84382: EMPTY
84383: LIST
84384: LIST
84385: PUSH
84386: LD_INT 3
84388: NEG
84389: PUSH
84390: LD_INT 1
84392: NEG
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: LIST
84411: LIST
84412: LIST
84413: LIST
84414: LIST
84415: LIST
84416: LIST
84417: LIST
84418: LIST
84419: LIST
84420: LIST
84421: LIST
84422: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84423: LD_ADDR_VAR 0 33
84427: PUSH
84428: LD_INT 0
84430: PUSH
84431: LD_INT 0
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 0
84440: PUSH
84441: LD_INT 1
84443: NEG
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 1
84451: PUSH
84452: LD_INT 0
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 1
84461: PUSH
84462: LD_INT 1
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 0
84471: PUSH
84472: LD_INT 1
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: LD_INT 1
84481: NEG
84482: PUSH
84483: LD_INT 0
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 1
84492: NEG
84493: PUSH
84494: LD_INT 1
84496: NEG
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: LD_INT 1
84504: NEG
84505: PUSH
84506: LD_INT 2
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 1
84516: PUSH
84517: LD_INT 1
84519: NEG
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 2
84527: PUSH
84528: LD_INT 0
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 2
84537: PUSH
84538: LD_INT 1
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 1
84547: PUSH
84548: LD_INT 2
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 0
84557: PUSH
84558: LD_INT 2
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: PUSH
84565: LD_INT 1
84567: NEG
84568: PUSH
84569: LD_INT 1
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: PUSH
84576: LD_INT 2
84578: NEG
84579: PUSH
84580: LD_INT 0
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: LD_INT 2
84589: NEG
84590: PUSH
84591: LD_INT 1
84593: NEG
84594: PUSH
84595: EMPTY
84596: LIST
84597: LIST
84598: PUSH
84599: LD_INT 2
84601: NEG
84602: PUSH
84603: LD_INT 2
84605: NEG
84606: PUSH
84607: EMPTY
84608: LIST
84609: LIST
84610: PUSH
84611: LD_INT 2
84613: NEG
84614: PUSH
84615: LD_INT 3
84617: NEG
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 2
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 3
84636: PUSH
84637: LD_INT 1
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: PUSH
84644: LD_INT 1
84646: PUSH
84647: LD_INT 3
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 1
84656: NEG
84657: PUSH
84658: LD_INT 2
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 3
84667: NEG
84668: PUSH
84669: LD_INT 2
84671: NEG
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84702: LD_ADDR_VAR 0 34
84706: PUSH
84707: LD_INT 0
84709: PUSH
84710: LD_INT 0
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 0
84719: PUSH
84720: LD_INT 1
84722: NEG
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 1
84730: PUSH
84731: LD_INT 0
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: PUSH
84738: LD_INT 1
84740: PUSH
84741: LD_INT 1
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: PUSH
84748: LD_INT 0
84750: PUSH
84751: LD_INT 1
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: PUSH
84758: LD_INT 1
84760: NEG
84761: PUSH
84762: LD_INT 0
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PUSH
84769: LD_INT 1
84771: NEG
84772: PUSH
84773: LD_INT 1
84775: NEG
84776: PUSH
84777: EMPTY
84778: LIST
84779: LIST
84780: PUSH
84781: LD_INT 1
84783: NEG
84784: PUSH
84785: LD_INT 2
84787: NEG
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 0
84795: PUSH
84796: LD_INT 2
84798: NEG
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: LD_INT 1
84809: NEG
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 2
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 2
84827: PUSH
84828: LD_INT 2
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 1
84837: PUSH
84838: LD_INT 2
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 1
84847: NEG
84848: PUSH
84849: LD_INT 1
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: LD_INT 2
84858: NEG
84859: PUSH
84860: LD_INT 0
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: PUSH
84867: LD_INT 2
84869: NEG
84870: PUSH
84871: LD_INT 1
84873: NEG
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 2
84881: NEG
84882: PUSH
84883: LD_INT 2
84885: NEG
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 1
84893: NEG
84894: PUSH
84895: LD_INT 3
84897: NEG
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: PUSH
84903: LD_INT 1
84905: PUSH
84906: LD_INT 2
84908: NEG
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 3
84916: PUSH
84917: LD_INT 2
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PUSH
84924: LD_INT 2
84926: PUSH
84927: LD_INT 3
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: LD_INT 2
84936: NEG
84937: PUSH
84938: LD_INT 1
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PUSH
84945: LD_INT 3
84947: NEG
84948: PUSH
84949: LD_INT 1
84951: NEG
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: LIST
84981: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84982: LD_ADDR_VAR 0 35
84986: PUSH
84987: LD_INT 0
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 0
84999: PUSH
85000: LD_INT 1
85002: NEG
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 1
85010: PUSH
85011: LD_INT 0
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 1
85020: PUSH
85021: LD_INT 1
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 0
85030: PUSH
85031: LD_INT 1
85033: PUSH
85034: EMPTY
85035: LIST
85036: LIST
85037: PUSH
85038: LD_INT 1
85040: NEG
85041: PUSH
85042: LD_INT 0
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: LD_INT 1
85051: NEG
85052: PUSH
85053: LD_INT 1
85055: NEG
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 2
85063: PUSH
85064: LD_INT 1
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 2
85073: NEG
85074: PUSH
85075: LD_INT 1
85077: NEG
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85094: LD_ADDR_VAR 0 36
85098: PUSH
85099: LD_INT 0
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 0
85111: PUSH
85112: LD_INT 1
85114: NEG
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: LD_INT 1
85122: PUSH
85123: LD_INT 0
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 1
85132: PUSH
85133: LD_INT 1
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 0
85142: PUSH
85143: LD_INT 1
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: LD_INT 1
85152: NEG
85153: PUSH
85154: LD_INT 0
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 1
85163: NEG
85164: PUSH
85165: LD_INT 1
85167: NEG
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 1
85175: NEG
85176: PUSH
85177: LD_INT 2
85179: NEG
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: PUSH
85185: LD_INT 1
85187: PUSH
85188: LD_INT 2
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85206: LD_ADDR_VAR 0 37
85210: PUSH
85211: LD_INT 0
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: LD_INT 1
85226: NEG
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 1
85234: PUSH
85235: LD_INT 0
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 1
85244: PUSH
85245: LD_INT 1
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 0
85254: PUSH
85255: LD_INT 1
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PUSH
85262: LD_INT 1
85264: NEG
85265: PUSH
85266: LD_INT 0
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 1
85275: NEG
85276: PUSH
85277: LD_INT 1
85279: NEG
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: LD_INT 1
85287: PUSH
85288: LD_INT 1
85290: NEG
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: NEG
85299: PUSH
85300: LD_INT 1
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85318: LD_ADDR_VAR 0 38
85322: PUSH
85323: LD_INT 0
85325: PUSH
85326: LD_INT 0
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 0
85335: PUSH
85336: LD_INT 1
85338: NEG
85339: PUSH
85340: EMPTY
85341: LIST
85342: LIST
85343: PUSH
85344: LD_INT 1
85346: PUSH
85347: LD_INT 0
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 1
85356: PUSH
85357: LD_INT 1
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: LD_INT 1
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 1
85376: NEG
85377: PUSH
85378: LD_INT 0
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 1
85387: NEG
85388: PUSH
85389: LD_INT 1
85391: NEG
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 2
85399: PUSH
85400: LD_INT 1
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 2
85409: NEG
85410: PUSH
85411: LD_INT 1
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: EMPTY
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: LIST
85428: LIST
85429: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85430: LD_ADDR_VAR 0 39
85434: PUSH
85435: LD_INT 0
85437: PUSH
85438: LD_INT 0
85440: PUSH
85441: EMPTY
85442: LIST
85443: LIST
85444: PUSH
85445: LD_INT 0
85447: PUSH
85448: LD_INT 1
85450: NEG
85451: PUSH
85452: EMPTY
85453: LIST
85454: LIST
85455: PUSH
85456: LD_INT 1
85458: PUSH
85459: LD_INT 0
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: PUSH
85466: LD_INT 1
85468: PUSH
85469: LD_INT 1
85471: PUSH
85472: EMPTY
85473: LIST
85474: LIST
85475: PUSH
85476: LD_INT 0
85478: PUSH
85479: LD_INT 1
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 1
85488: NEG
85489: PUSH
85490: LD_INT 0
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 1
85499: NEG
85500: PUSH
85501: LD_INT 1
85503: NEG
85504: PUSH
85505: EMPTY
85506: LIST
85507: LIST
85508: PUSH
85509: LD_INT 1
85511: NEG
85512: PUSH
85513: LD_INT 2
85515: NEG
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: LD_INT 2
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85542: LD_ADDR_VAR 0 40
85546: PUSH
85547: LD_INT 0
85549: PUSH
85550: LD_INT 0
85552: PUSH
85553: EMPTY
85554: LIST
85555: LIST
85556: PUSH
85557: LD_INT 0
85559: PUSH
85560: LD_INT 1
85562: NEG
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PUSH
85568: LD_INT 1
85570: PUSH
85571: LD_INT 0
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 1
85580: PUSH
85581: LD_INT 1
85583: PUSH
85584: EMPTY
85585: LIST
85586: LIST
85587: PUSH
85588: LD_INT 0
85590: PUSH
85591: LD_INT 1
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: LD_INT 1
85600: NEG
85601: PUSH
85602: LD_INT 0
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 1
85611: NEG
85612: PUSH
85613: LD_INT 1
85615: NEG
85616: PUSH
85617: EMPTY
85618: LIST
85619: LIST
85620: PUSH
85621: LD_INT 1
85623: PUSH
85624: LD_INT 1
85626: NEG
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 1
85634: NEG
85635: PUSH
85636: LD_INT 1
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: LIST
85652: LIST
85653: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85654: LD_ADDR_VAR 0 41
85658: PUSH
85659: LD_INT 0
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: PUSH
85669: LD_INT 0
85671: PUSH
85672: LD_INT 1
85674: NEG
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: PUSH
85680: LD_INT 1
85682: PUSH
85683: LD_INT 0
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 1
85692: PUSH
85693: LD_INT 1
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 0
85702: PUSH
85703: LD_INT 1
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 1
85712: NEG
85713: PUSH
85714: LD_INT 0
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 1
85723: NEG
85724: PUSH
85725: LD_INT 1
85727: NEG
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 1
85735: NEG
85736: PUSH
85737: LD_INT 2
85739: NEG
85740: PUSH
85741: EMPTY
85742: LIST
85743: LIST
85744: PUSH
85745: LD_INT 1
85747: PUSH
85748: LD_INT 1
85750: NEG
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 2
85758: PUSH
85759: LD_INT 0
85761: PUSH
85762: EMPTY
85763: LIST
85764: LIST
85765: PUSH
85766: LD_INT 2
85768: PUSH
85769: LD_INT 1
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 2
85778: PUSH
85779: LD_INT 2
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PUSH
85786: LD_INT 1
85788: PUSH
85789: LD_INT 2
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: PUSH
85796: LD_INT 1
85798: NEG
85799: PUSH
85800: LD_INT 1
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PUSH
85807: LD_INT 2
85809: NEG
85810: PUSH
85811: LD_INT 0
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: PUSH
85818: LD_INT 2
85820: NEG
85821: PUSH
85822: LD_INT 1
85824: NEG
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 2
85832: NEG
85833: PUSH
85834: LD_INT 2
85836: NEG
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 2
85844: NEG
85845: PUSH
85846: LD_INT 3
85848: NEG
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 2
85856: PUSH
85857: LD_INT 1
85859: NEG
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 3
85867: PUSH
85868: LD_INT 0
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 3
85877: PUSH
85878: LD_INT 1
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PUSH
85885: LD_INT 3
85887: PUSH
85888: LD_INT 2
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: PUSH
85895: LD_INT 3
85897: PUSH
85898: LD_INT 3
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: LD_INT 2
85907: PUSH
85908: LD_INT 3
85910: PUSH
85911: EMPTY
85912: LIST
85913: LIST
85914: PUSH
85915: LD_INT 2
85917: NEG
85918: PUSH
85919: LD_INT 1
85921: PUSH
85922: EMPTY
85923: LIST
85924: LIST
85925: PUSH
85926: LD_INT 3
85928: NEG
85929: PUSH
85930: LD_INT 0
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 3
85939: NEG
85940: PUSH
85941: LD_INT 1
85943: NEG
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PUSH
85949: LD_INT 3
85951: NEG
85952: PUSH
85953: LD_INT 2
85955: NEG
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 3
85963: NEG
85964: PUSH
85965: LD_INT 3
85967: NEG
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: LIST
85999: LIST
86000: LIST
86001: LIST
86002: LIST
86003: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86004: LD_ADDR_VAR 0 42
86008: PUSH
86009: LD_INT 0
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 0
86021: PUSH
86022: LD_INT 1
86024: NEG
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 1
86032: PUSH
86033: LD_INT 0
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 1
86042: PUSH
86043: LD_INT 1
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 0
86052: PUSH
86053: LD_INT 1
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 1
86062: NEG
86063: PUSH
86064: LD_INT 0
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: LD_INT 1
86073: NEG
86074: PUSH
86075: LD_INT 1
86077: NEG
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 1
86085: NEG
86086: PUSH
86087: LD_INT 2
86089: NEG
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: LD_INT 2
86100: NEG
86101: PUSH
86102: EMPTY
86103: LIST
86104: LIST
86105: PUSH
86106: LD_INT 1
86108: PUSH
86109: LD_INT 1
86111: NEG
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 2
86119: PUSH
86120: LD_INT 1
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 2
86129: PUSH
86130: LD_INT 2
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 1
86139: PUSH
86140: LD_INT 2
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: LD_INT 2
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 1
86159: NEG
86160: PUSH
86161: LD_INT 1
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 2
86170: NEG
86171: PUSH
86172: LD_INT 1
86174: NEG
86175: PUSH
86176: EMPTY
86177: LIST
86178: LIST
86179: PUSH
86180: LD_INT 2
86182: NEG
86183: PUSH
86184: LD_INT 2
86186: NEG
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: LD_INT 2
86194: NEG
86195: PUSH
86196: LD_INT 3
86198: NEG
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 1
86206: NEG
86207: PUSH
86208: LD_INT 3
86210: NEG
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: PUSH
86216: LD_INT 0
86218: PUSH
86219: LD_INT 3
86221: NEG
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: PUSH
86227: LD_INT 1
86229: PUSH
86230: LD_INT 2
86232: NEG
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: PUSH
86238: LD_INT 3
86240: PUSH
86241: LD_INT 2
86243: PUSH
86244: EMPTY
86245: LIST
86246: LIST
86247: PUSH
86248: LD_INT 3
86250: PUSH
86251: LD_INT 3
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 2
86260: PUSH
86261: LD_INT 3
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 1
86270: PUSH
86271: LD_INT 3
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 0
86280: PUSH
86281: LD_INT 3
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 1
86290: NEG
86291: PUSH
86292: LD_INT 2
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 3
86301: NEG
86302: PUSH
86303: LD_INT 2
86305: NEG
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 3
86313: NEG
86314: PUSH
86315: LD_INT 3
86317: NEG
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: LIST
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: LIST
86351: LIST
86352: LIST
86353: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86354: LD_ADDR_VAR 0 43
86358: PUSH
86359: LD_INT 0
86361: PUSH
86362: LD_INT 0
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 0
86371: PUSH
86372: LD_INT 1
86374: NEG
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PUSH
86380: LD_INT 1
86382: PUSH
86383: LD_INT 0
86385: PUSH
86386: EMPTY
86387: LIST
86388: LIST
86389: PUSH
86390: LD_INT 1
86392: PUSH
86393: LD_INT 1
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: PUSH
86400: LD_INT 0
86402: PUSH
86403: LD_INT 1
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: LD_INT 1
86412: NEG
86413: PUSH
86414: LD_INT 0
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 1
86423: NEG
86424: PUSH
86425: LD_INT 1
86427: NEG
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: LD_INT 1
86435: NEG
86436: PUSH
86437: LD_INT 2
86439: NEG
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 0
86447: PUSH
86448: LD_INT 2
86450: NEG
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 1
86458: PUSH
86459: LD_INT 1
86461: NEG
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 2
86469: PUSH
86470: LD_INT 0
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 2
86479: PUSH
86480: LD_INT 1
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: PUSH
86490: LD_INT 2
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 0
86499: PUSH
86500: LD_INT 2
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 1
86509: NEG
86510: PUSH
86511: LD_INT 1
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 2
86520: NEG
86521: PUSH
86522: LD_INT 0
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: PUSH
86529: LD_INT 2
86531: NEG
86532: PUSH
86533: LD_INT 1
86535: NEG
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 1
86543: NEG
86544: PUSH
86545: LD_INT 3
86547: NEG
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 0
86555: PUSH
86556: LD_INT 3
86558: NEG
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 1
86566: PUSH
86567: LD_INT 2
86569: NEG
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 2
86577: PUSH
86578: LD_INT 1
86580: NEG
86581: PUSH
86582: EMPTY
86583: LIST
86584: LIST
86585: PUSH
86586: LD_INT 3
86588: PUSH
86589: LD_INT 0
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: PUSH
86596: LD_INT 3
86598: PUSH
86599: LD_INT 1
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 1
86608: PUSH
86609: LD_INT 3
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: LD_INT 3
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PUSH
86626: LD_INT 1
86628: NEG
86629: PUSH
86630: LD_INT 2
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: PUSH
86637: LD_INT 2
86639: NEG
86640: PUSH
86641: LD_INT 1
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: LD_INT 3
86650: NEG
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 3
86661: NEG
86662: PUSH
86663: LD_INT 1
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86702: LD_ADDR_VAR 0 44
86706: PUSH
86707: LD_INT 0
86709: PUSH
86710: LD_INT 0
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: PUSH
86717: LD_INT 0
86719: PUSH
86720: LD_INT 1
86722: NEG
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 1
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: LD_INT 1
86740: PUSH
86741: LD_INT 1
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PUSH
86748: LD_INT 0
86750: PUSH
86751: LD_INT 1
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 1
86760: NEG
86761: PUSH
86762: LD_INT 0
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 1
86771: NEG
86772: PUSH
86773: LD_INT 1
86775: NEG
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: NEG
86784: PUSH
86785: LD_INT 2
86787: NEG
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 1
86795: PUSH
86796: LD_INT 1
86798: NEG
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 2
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 2
86816: PUSH
86817: LD_INT 1
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PUSH
86824: LD_INT 2
86826: PUSH
86827: LD_INT 2
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PUSH
86834: LD_INT 1
86836: PUSH
86837: LD_INT 2
86839: PUSH
86840: EMPTY
86841: LIST
86842: LIST
86843: PUSH
86844: LD_INT 1
86846: NEG
86847: PUSH
86848: LD_INT 1
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_INT 2
86857: NEG
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 2
86868: NEG
86869: PUSH
86870: LD_INT 1
86872: NEG
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 2
86880: NEG
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 2
86892: NEG
86893: PUSH
86894: LD_INT 3
86896: NEG
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 2
86904: PUSH
86905: LD_INT 1
86907: NEG
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: LD_INT 3
86915: PUSH
86916: LD_INT 0
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: PUSH
86923: LD_INT 3
86925: PUSH
86926: LD_INT 1
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 3
86935: PUSH
86936: LD_INT 2
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: LD_INT 3
86945: PUSH
86946: LD_INT 3
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 2
86955: PUSH
86956: LD_INT 3
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 2
86965: NEG
86966: PUSH
86967: LD_INT 1
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: LD_INT 3
86976: NEG
86977: PUSH
86978: LD_INT 0
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 3
86987: NEG
86988: PUSH
86989: LD_INT 1
86991: NEG
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 3
86999: NEG
87000: PUSH
87001: LD_INT 2
87003: NEG
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 3
87011: NEG
87012: PUSH
87013: LD_INT 3
87015: NEG
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87052: LD_ADDR_VAR 0 45
87056: PUSH
87057: LD_INT 0
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 0
87069: PUSH
87070: LD_INT 1
87072: NEG
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 1
87080: PUSH
87081: LD_INT 0
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 1
87090: PUSH
87091: LD_INT 1
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 0
87100: PUSH
87101: LD_INT 1
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 1
87110: NEG
87111: PUSH
87112: LD_INT 0
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: LD_INT 1
87121: NEG
87122: PUSH
87123: LD_INT 1
87125: NEG
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 1
87133: NEG
87134: PUSH
87135: LD_INT 2
87137: NEG
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 0
87145: PUSH
87146: LD_INT 2
87148: NEG
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 1
87156: PUSH
87157: LD_INT 1
87159: NEG
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 2
87167: PUSH
87168: LD_INT 1
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 2
87177: PUSH
87178: LD_INT 2
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 1
87187: PUSH
87188: LD_INT 2
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 0
87197: PUSH
87198: LD_INT 2
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 1
87207: NEG
87208: PUSH
87209: LD_INT 1
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 2
87218: NEG
87219: PUSH
87220: LD_INT 1
87222: NEG
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: PUSH
87228: LD_INT 2
87230: NEG
87231: PUSH
87232: LD_INT 2
87234: NEG
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 2
87242: NEG
87243: PUSH
87244: LD_INT 3
87246: NEG
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 1
87254: NEG
87255: PUSH
87256: LD_INT 3
87258: NEG
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 0
87266: PUSH
87267: LD_INT 3
87269: NEG
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 1
87277: PUSH
87278: LD_INT 2
87280: NEG
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: LD_INT 3
87288: PUSH
87289: LD_INT 2
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 3
87298: PUSH
87299: LD_INT 3
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 2
87308: PUSH
87309: LD_INT 3
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 1
87318: PUSH
87319: LD_INT 3
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 0
87328: PUSH
87329: LD_INT 3
87331: PUSH
87332: EMPTY
87333: LIST
87334: LIST
87335: PUSH
87336: LD_INT 1
87338: NEG
87339: PUSH
87340: LD_INT 2
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 3
87349: NEG
87350: PUSH
87351: LD_INT 2
87353: NEG
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: PUSH
87359: LD_INT 3
87361: NEG
87362: PUSH
87363: LD_INT 3
87365: NEG
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87402: LD_ADDR_VAR 0 46
87406: PUSH
87407: LD_INT 0
87409: PUSH
87410: LD_INT 0
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 0
87419: PUSH
87420: LD_INT 1
87422: NEG
87423: PUSH
87424: EMPTY
87425: LIST
87426: LIST
87427: PUSH
87428: LD_INT 1
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 1
87440: PUSH
87441: LD_INT 1
87443: PUSH
87444: EMPTY
87445: LIST
87446: LIST
87447: PUSH
87448: LD_INT 0
87450: PUSH
87451: LD_INT 1
87453: PUSH
87454: EMPTY
87455: LIST
87456: LIST
87457: PUSH
87458: LD_INT 1
87460: NEG
87461: PUSH
87462: LD_INT 0
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: LD_INT 1
87471: NEG
87472: PUSH
87473: LD_INT 1
87475: NEG
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 1
87483: NEG
87484: PUSH
87485: LD_INT 2
87487: NEG
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 0
87495: PUSH
87496: LD_INT 2
87498: NEG
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 1
87506: PUSH
87507: LD_INT 1
87509: NEG
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 2
87517: PUSH
87518: LD_INT 0
87520: PUSH
87521: EMPTY
87522: LIST
87523: LIST
87524: PUSH
87525: LD_INT 2
87527: PUSH
87528: LD_INT 1
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 1
87537: PUSH
87538: LD_INT 2
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 0
87547: PUSH
87548: LD_INT 2
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 1
87557: NEG
87558: PUSH
87559: LD_INT 1
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PUSH
87566: LD_INT 2
87568: NEG
87569: PUSH
87570: LD_INT 0
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 2
87579: NEG
87580: PUSH
87581: LD_INT 1
87583: NEG
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: PUSH
87589: LD_INT 1
87591: NEG
87592: PUSH
87593: LD_INT 3
87595: NEG
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 0
87603: PUSH
87604: LD_INT 3
87606: NEG
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 1
87614: PUSH
87615: LD_INT 2
87617: NEG
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 2
87625: PUSH
87626: LD_INT 1
87628: NEG
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 3
87636: PUSH
87637: LD_INT 0
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: PUSH
87644: LD_INT 3
87646: PUSH
87647: LD_INT 1
87649: PUSH
87650: EMPTY
87651: LIST
87652: LIST
87653: PUSH
87654: LD_INT 1
87656: PUSH
87657: LD_INT 3
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 0
87666: PUSH
87667: LD_INT 3
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 1
87676: NEG
87677: PUSH
87678: LD_INT 2
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: PUSH
87685: LD_INT 2
87687: NEG
87688: PUSH
87689: LD_INT 1
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 3
87698: NEG
87699: PUSH
87700: LD_INT 0
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 3
87709: NEG
87710: PUSH
87711: LD_INT 1
87713: NEG
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87750: LD_ADDR_VAR 0 47
87754: PUSH
87755: LD_INT 0
87757: PUSH
87758: LD_INT 0
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: PUSH
87765: LD_INT 0
87767: PUSH
87768: LD_INT 1
87770: NEG
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: PUSH
87776: LD_INT 1
87778: PUSH
87779: LD_INT 0
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: PUSH
87786: LD_INT 1
87788: PUSH
87789: LD_INT 1
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: PUSH
87796: LD_INT 0
87798: PUSH
87799: LD_INT 1
87801: PUSH
87802: EMPTY
87803: LIST
87804: LIST
87805: PUSH
87806: LD_INT 1
87808: NEG
87809: PUSH
87810: LD_INT 0
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: LD_INT 1
87823: NEG
87824: PUSH
87825: EMPTY
87826: LIST
87827: LIST
87828: PUSH
87829: LD_INT 1
87831: NEG
87832: PUSH
87833: LD_INT 2
87835: NEG
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: PUSH
87841: LD_INT 0
87843: PUSH
87844: LD_INT 2
87846: NEG
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: PUSH
87852: LD_INT 1
87854: PUSH
87855: LD_INT 1
87857: NEG
87858: PUSH
87859: EMPTY
87860: LIST
87861: LIST
87862: PUSH
87863: LD_INT 2
87865: NEG
87866: PUSH
87867: LD_INT 1
87869: NEG
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PUSH
87875: LD_INT 2
87877: NEG
87878: PUSH
87879: LD_INT 2
87881: NEG
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87901: LD_ADDR_VAR 0 48
87905: PUSH
87906: LD_INT 0
87908: PUSH
87909: LD_INT 0
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 0
87918: PUSH
87919: LD_INT 1
87921: NEG
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PUSH
87927: LD_INT 1
87929: PUSH
87930: LD_INT 0
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: PUSH
87937: LD_INT 1
87939: PUSH
87940: LD_INT 1
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: LD_INT 0
87949: PUSH
87950: LD_INT 1
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PUSH
87957: LD_INT 1
87959: NEG
87960: PUSH
87961: LD_INT 0
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 1
87970: NEG
87971: PUSH
87972: LD_INT 1
87974: NEG
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: PUSH
87980: LD_INT 1
87982: NEG
87983: PUSH
87984: LD_INT 2
87986: NEG
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 0
87994: PUSH
87995: LD_INT 2
87997: NEG
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: PUSH
88003: LD_INT 1
88005: PUSH
88006: LD_INT 1
88008: NEG
88009: PUSH
88010: EMPTY
88011: LIST
88012: LIST
88013: PUSH
88014: LD_INT 2
88016: PUSH
88017: LD_INT 0
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 2
88026: PUSH
88027: LD_INT 1
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88048: LD_ADDR_VAR 0 49
88052: PUSH
88053: LD_INT 0
88055: PUSH
88056: LD_INT 0
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: LD_INT 1
88068: NEG
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 1
88076: PUSH
88077: LD_INT 0
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 1
88086: PUSH
88087: LD_INT 1
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 0
88096: PUSH
88097: LD_INT 1
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 1
88106: NEG
88107: PUSH
88108: LD_INT 0
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 1
88117: NEG
88118: PUSH
88119: LD_INT 1
88121: NEG
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 1
88129: PUSH
88130: LD_INT 1
88132: NEG
88133: PUSH
88134: EMPTY
88135: LIST
88136: LIST
88137: PUSH
88138: LD_INT 2
88140: PUSH
88141: LD_INT 0
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PUSH
88148: LD_INT 2
88150: PUSH
88151: LD_INT 1
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PUSH
88158: LD_INT 2
88160: PUSH
88161: LD_INT 2
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 1
88170: PUSH
88171: LD_INT 2
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88192: LD_ADDR_VAR 0 50
88196: PUSH
88197: LD_INT 0
88199: PUSH
88200: LD_INT 0
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: LD_INT 1
88212: NEG
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 1
88220: PUSH
88221: LD_INT 0
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 1
88230: PUSH
88231: LD_INT 1
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: PUSH
88238: LD_INT 0
88240: PUSH
88241: LD_INT 1
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 1
88250: NEG
88251: PUSH
88252: LD_INT 0
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 1
88261: NEG
88262: PUSH
88263: LD_INT 1
88265: NEG
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: PUSH
88271: LD_INT 2
88273: PUSH
88274: LD_INT 1
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 2
88283: PUSH
88284: LD_INT 2
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 1
88293: PUSH
88294: LD_INT 2
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 0
88303: PUSH
88304: LD_INT 2
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 1
88313: NEG
88314: PUSH
88315: LD_INT 1
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88336: LD_ADDR_VAR 0 51
88340: PUSH
88341: LD_INT 0
88343: PUSH
88344: LD_INT 0
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 0
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 1
88364: PUSH
88365: LD_INT 0
88367: PUSH
88368: EMPTY
88369: LIST
88370: LIST
88371: PUSH
88372: LD_INT 1
88374: PUSH
88375: LD_INT 1
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PUSH
88382: LD_INT 0
88384: PUSH
88385: LD_INT 1
88387: PUSH
88388: EMPTY
88389: LIST
88390: LIST
88391: PUSH
88392: LD_INT 1
88394: NEG
88395: PUSH
88396: LD_INT 0
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: PUSH
88403: LD_INT 1
88405: NEG
88406: PUSH
88407: LD_INT 1
88409: NEG
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 1
88417: PUSH
88418: LD_INT 2
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 0
88427: PUSH
88428: LD_INT 2
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 1
88437: NEG
88438: PUSH
88439: LD_INT 1
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 2
88448: NEG
88449: PUSH
88450: LD_INT 0
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 2
88459: NEG
88460: PUSH
88461: LD_INT 1
88463: NEG
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88483: LD_ADDR_VAR 0 52
88487: PUSH
88488: LD_INT 0
88490: PUSH
88491: LD_INT 0
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 0
88500: PUSH
88501: LD_INT 1
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 1
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 1
88521: PUSH
88522: LD_INT 1
88524: PUSH
88525: EMPTY
88526: LIST
88527: LIST
88528: PUSH
88529: LD_INT 0
88531: PUSH
88532: LD_INT 1
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 1
88541: NEG
88542: PUSH
88543: LD_INT 0
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 1
88552: NEG
88553: PUSH
88554: LD_INT 1
88556: NEG
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: LD_INT 1
88564: NEG
88565: PUSH
88566: LD_INT 2
88568: NEG
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 1
88576: NEG
88577: PUSH
88578: LD_INT 1
88580: PUSH
88581: EMPTY
88582: LIST
88583: LIST
88584: PUSH
88585: LD_INT 2
88587: NEG
88588: PUSH
88589: LD_INT 0
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 2
88598: NEG
88599: PUSH
88600: LD_INT 1
88602: NEG
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PUSH
88608: LD_INT 2
88610: NEG
88611: PUSH
88612: LD_INT 2
88614: NEG
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88634: LD_ADDR_VAR 0 53
88638: PUSH
88639: LD_INT 0
88641: PUSH
88642: LD_INT 0
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 0
88651: PUSH
88652: LD_INT 1
88654: NEG
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 1
88662: PUSH
88663: LD_INT 0
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 1
88672: PUSH
88673: LD_INT 1
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 0
88682: PUSH
88683: LD_INT 1
88685: PUSH
88686: EMPTY
88687: LIST
88688: LIST
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: LD_INT 0
88696: PUSH
88697: EMPTY
88698: LIST
88699: LIST
88700: PUSH
88701: LD_INT 1
88703: NEG
88704: PUSH
88705: LD_INT 1
88707: NEG
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PUSH
88713: LD_INT 1
88715: NEG
88716: PUSH
88717: LD_INT 2
88719: NEG
88720: PUSH
88721: EMPTY
88722: LIST
88723: LIST
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: LD_INT 2
88730: NEG
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: PUSH
88736: LD_INT 1
88738: PUSH
88739: LD_INT 1
88741: NEG
88742: PUSH
88743: EMPTY
88744: LIST
88745: LIST
88746: PUSH
88747: LD_INT 2
88749: PUSH
88750: LD_INT 0
88752: PUSH
88753: EMPTY
88754: LIST
88755: LIST
88756: PUSH
88757: LD_INT 2
88759: PUSH
88760: LD_INT 1
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 2
88769: PUSH
88770: LD_INT 2
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 1
88779: PUSH
88780: LD_INT 2
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 0
88789: PUSH
88790: LD_INT 2
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 1
88799: NEG
88800: PUSH
88801: LD_INT 1
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 2
88810: NEG
88811: PUSH
88812: LD_INT 0
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: LD_INT 2
88821: NEG
88822: PUSH
88823: LD_INT 1
88825: NEG
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: PUSH
88831: LD_INT 2
88833: NEG
88834: PUSH
88835: LD_INT 2
88837: NEG
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: PUSH
88843: EMPTY
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88864: LD_ADDR_VAR 0 54
88868: PUSH
88869: LD_INT 0
88871: PUSH
88872: LD_INT 0
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 0
88881: PUSH
88882: LD_INT 1
88884: NEG
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 1
88892: PUSH
88893: LD_INT 0
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 1
88902: PUSH
88903: LD_INT 1
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 0
88912: PUSH
88913: LD_INT 1
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 1
88922: NEG
88923: PUSH
88924: LD_INT 0
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 1
88933: NEG
88934: PUSH
88935: LD_INT 1
88937: NEG
88938: PUSH
88939: EMPTY
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 1
88945: NEG
88946: PUSH
88947: LD_INT 2
88949: NEG
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: PUSH
88955: LD_INT 0
88957: PUSH
88958: LD_INT 2
88960: NEG
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 1
88968: PUSH
88969: LD_INT 1
88971: NEG
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 2
88979: PUSH
88980: LD_INT 0
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 2
88989: PUSH
88990: LD_INT 1
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: LD_INT 2
88999: PUSH
89000: LD_INT 2
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 1
89009: PUSH
89010: LD_INT 2
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: PUSH
89017: LD_INT 0
89019: PUSH
89020: LD_INT 2
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 1
89029: NEG
89030: PUSH
89031: LD_INT 1
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 2
89040: NEG
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 2
89051: NEG
89052: PUSH
89053: LD_INT 1
89055: NEG
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 2
89063: NEG
89064: PUSH
89065: LD_INT 2
89067: NEG
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89094: LD_ADDR_VAR 0 55
89098: PUSH
89099: LD_INT 0
89101: PUSH
89102: LD_INT 0
89104: PUSH
89105: EMPTY
89106: LIST
89107: LIST
89108: PUSH
89109: LD_INT 0
89111: PUSH
89112: LD_INT 1
89114: NEG
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 1
89122: PUSH
89123: LD_INT 0
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 1
89132: PUSH
89133: LD_INT 1
89135: PUSH
89136: EMPTY
89137: LIST
89138: LIST
89139: PUSH
89140: LD_INT 0
89142: PUSH
89143: LD_INT 1
89145: PUSH
89146: EMPTY
89147: LIST
89148: LIST
89149: PUSH
89150: LD_INT 1
89152: NEG
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 1
89163: NEG
89164: PUSH
89165: LD_INT 1
89167: NEG
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: PUSH
89173: LD_INT 1
89175: NEG
89176: PUSH
89177: LD_INT 2
89179: NEG
89180: PUSH
89181: EMPTY
89182: LIST
89183: LIST
89184: PUSH
89185: LD_INT 0
89187: PUSH
89188: LD_INT 2
89190: NEG
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: PUSH
89196: LD_INT 1
89198: PUSH
89199: LD_INT 1
89201: NEG
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: LD_INT 2
89209: PUSH
89210: LD_INT 0
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: PUSH
89217: LD_INT 2
89219: PUSH
89220: LD_INT 1
89222: PUSH
89223: EMPTY
89224: LIST
89225: LIST
89226: PUSH
89227: LD_INT 2
89229: PUSH
89230: LD_INT 2
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 1
89239: PUSH
89240: LD_INT 2
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: PUSH
89247: LD_INT 0
89249: PUSH
89250: LD_INT 2
89252: PUSH
89253: EMPTY
89254: LIST
89255: LIST
89256: PUSH
89257: LD_INT 1
89259: NEG
89260: PUSH
89261: LD_INT 1
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 2
89270: NEG
89271: PUSH
89272: LD_INT 0
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 2
89281: NEG
89282: PUSH
89283: LD_INT 1
89285: NEG
89286: PUSH
89287: EMPTY
89288: LIST
89289: LIST
89290: PUSH
89291: LD_INT 2
89293: NEG
89294: PUSH
89295: LD_INT 2
89297: NEG
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: LIST
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89324: LD_ADDR_VAR 0 56
89328: PUSH
89329: LD_INT 0
89331: PUSH
89332: LD_INT 0
89334: PUSH
89335: EMPTY
89336: LIST
89337: LIST
89338: PUSH
89339: LD_INT 0
89341: PUSH
89342: LD_INT 1
89344: NEG
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PUSH
89350: LD_INT 1
89352: PUSH
89353: LD_INT 0
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 1
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 0
89372: PUSH
89373: LD_INT 1
89375: PUSH
89376: EMPTY
89377: LIST
89378: LIST
89379: PUSH
89380: LD_INT 1
89382: NEG
89383: PUSH
89384: LD_INT 0
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PUSH
89391: LD_INT 1
89393: NEG
89394: PUSH
89395: LD_INT 1
89397: NEG
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: LD_INT 1
89405: NEG
89406: PUSH
89407: LD_INT 2
89409: NEG
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 0
89417: PUSH
89418: LD_INT 2
89420: NEG
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 1
89428: PUSH
89429: LD_INT 1
89431: NEG
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 2
89439: PUSH
89440: LD_INT 0
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: LD_INT 2
89449: PUSH
89450: LD_INT 1
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 2
89459: PUSH
89460: LD_INT 2
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 1
89469: PUSH
89470: LD_INT 2
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: LD_INT 0
89479: PUSH
89480: LD_INT 2
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 1
89489: NEG
89490: PUSH
89491: LD_INT 1
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 2
89500: NEG
89501: PUSH
89502: LD_INT 0
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: PUSH
89509: LD_INT 2
89511: NEG
89512: PUSH
89513: LD_INT 1
89515: NEG
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: LD_INT 2
89527: NEG
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89554: LD_ADDR_VAR 0 57
89558: PUSH
89559: LD_INT 0
89561: PUSH
89562: LD_INT 0
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: LD_INT 0
89571: PUSH
89572: LD_INT 1
89574: NEG
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: PUSH
89580: LD_INT 1
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 1
89592: PUSH
89593: LD_INT 1
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: LD_INT 0
89602: PUSH
89603: LD_INT 1
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: PUSH
89610: LD_INT 1
89612: NEG
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 1
89623: NEG
89624: PUSH
89625: LD_INT 1
89627: NEG
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: PUSH
89633: LD_INT 1
89635: NEG
89636: PUSH
89637: LD_INT 2
89639: NEG
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 0
89647: PUSH
89648: LD_INT 2
89650: NEG
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 1
89658: PUSH
89659: LD_INT 1
89661: NEG
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: PUSH
89667: LD_INT 2
89669: PUSH
89670: LD_INT 0
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: PUSH
89677: LD_INT 2
89679: PUSH
89680: LD_INT 1
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 2
89689: PUSH
89690: LD_INT 2
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PUSH
89697: LD_INT 1
89699: PUSH
89700: LD_INT 2
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: PUSH
89707: LD_INT 0
89709: PUSH
89710: LD_INT 2
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 1
89719: NEG
89720: PUSH
89721: LD_INT 1
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 2
89730: NEG
89731: PUSH
89732: LD_INT 0
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 2
89741: NEG
89742: PUSH
89743: LD_INT 1
89745: NEG
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 2
89753: NEG
89754: PUSH
89755: LD_INT 2
89757: NEG
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89784: LD_ADDR_VAR 0 58
89788: PUSH
89789: LD_INT 0
89791: PUSH
89792: LD_INT 0
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 0
89801: PUSH
89802: LD_INT 1
89804: NEG
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 1
89812: PUSH
89813: LD_INT 0
89815: PUSH
89816: EMPTY
89817: LIST
89818: LIST
89819: PUSH
89820: LD_INT 1
89822: PUSH
89823: LD_INT 1
89825: PUSH
89826: EMPTY
89827: LIST
89828: LIST
89829: PUSH
89830: LD_INT 0
89832: PUSH
89833: LD_INT 1
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: PUSH
89840: LD_INT 1
89842: NEG
89843: PUSH
89844: LD_INT 0
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: LD_INT 1
89853: NEG
89854: PUSH
89855: LD_INT 1
89857: NEG
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 1
89865: NEG
89866: PUSH
89867: LD_INT 2
89869: NEG
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 0
89877: PUSH
89878: LD_INT 2
89880: NEG
89881: PUSH
89882: EMPTY
89883: LIST
89884: LIST
89885: PUSH
89886: LD_INT 1
89888: PUSH
89889: LD_INT 1
89891: NEG
89892: PUSH
89893: EMPTY
89894: LIST
89895: LIST
89896: PUSH
89897: LD_INT 2
89899: PUSH
89900: LD_INT 0
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 2
89909: PUSH
89910: LD_INT 1
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 2
89919: PUSH
89920: LD_INT 2
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: PUSH
89927: LD_INT 1
89929: PUSH
89930: LD_INT 2
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 0
89939: PUSH
89940: LD_INT 2
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: PUSH
89951: LD_INT 1
89953: PUSH
89954: EMPTY
89955: LIST
89956: LIST
89957: PUSH
89958: LD_INT 2
89960: NEG
89961: PUSH
89962: LD_INT 0
89964: PUSH
89965: EMPTY
89966: LIST
89967: LIST
89968: PUSH
89969: LD_INT 2
89971: NEG
89972: PUSH
89973: LD_INT 1
89975: NEG
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: LD_INT 2
89983: NEG
89984: PUSH
89985: LD_INT 2
89987: NEG
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: LIST
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90014: LD_ADDR_VAR 0 59
90018: PUSH
90019: LD_INT 0
90021: PUSH
90022: LD_INT 0
90024: PUSH
90025: EMPTY
90026: LIST
90027: LIST
90028: PUSH
90029: LD_INT 0
90031: PUSH
90032: LD_INT 1
90034: NEG
90035: PUSH
90036: EMPTY
90037: LIST
90038: LIST
90039: PUSH
90040: LD_INT 1
90042: PUSH
90043: LD_INT 0
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: PUSH
90050: LD_INT 1
90052: PUSH
90053: LD_INT 1
90055: PUSH
90056: EMPTY
90057: LIST
90058: LIST
90059: PUSH
90060: LD_INT 0
90062: PUSH
90063: LD_INT 1
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: PUSH
90070: LD_INT 1
90072: NEG
90073: PUSH
90074: LD_INT 0
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: PUSH
90081: LD_INT 1
90083: NEG
90084: PUSH
90085: LD_INT 1
90087: NEG
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90102: LD_ADDR_VAR 0 60
90106: PUSH
90107: LD_INT 0
90109: PUSH
90110: LD_INT 0
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 0
90119: PUSH
90120: LD_INT 1
90122: NEG
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 1
90130: PUSH
90131: LD_INT 0
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 1
90140: PUSH
90141: LD_INT 1
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 0
90150: PUSH
90151: LD_INT 1
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 1
90160: NEG
90161: PUSH
90162: LD_INT 0
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 1
90171: NEG
90172: PUSH
90173: LD_INT 1
90175: NEG
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90190: LD_ADDR_VAR 0 61
90194: PUSH
90195: LD_INT 0
90197: PUSH
90198: LD_INT 0
90200: PUSH
90201: EMPTY
90202: LIST
90203: LIST
90204: PUSH
90205: LD_INT 0
90207: PUSH
90208: LD_INT 1
90210: NEG
90211: PUSH
90212: EMPTY
90213: LIST
90214: LIST
90215: PUSH
90216: LD_INT 1
90218: PUSH
90219: LD_INT 0
90221: PUSH
90222: EMPTY
90223: LIST
90224: LIST
90225: PUSH
90226: LD_INT 1
90228: PUSH
90229: LD_INT 1
90231: PUSH
90232: EMPTY
90233: LIST
90234: LIST
90235: PUSH
90236: LD_INT 0
90238: PUSH
90239: LD_INT 1
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 1
90248: NEG
90249: PUSH
90250: LD_INT 0
90252: PUSH
90253: EMPTY
90254: LIST
90255: LIST
90256: PUSH
90257: LD_INT 1
90259: NEG
90260: PUSH
90261: LD_INT 1
90263: NEG
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90278: LD_ADDR_VAR 0 62
90282: PUSH
90283: LD_INT 0
90285: PUSH
90286: LD_INT 0
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: PUSH
90293: LD_INT 0
90295: PUSH
90296: LD_INT 1
90298: NEG
90299: PUSH
90300: EMPTY
90301: LIST
90302: LIST
90303: PUSH
90304: LD_INT 1
90306: PUSH
90307: LD_INT 0
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 1
90316: PUSH
90317: LD_INT 1
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: PUSH
90324: LD_INT 0
90326: PUSH
90327: LD_INT 1
90329: PUSH
90330: EMPTY
90331: LIST
90332: LIST
90333: PUSH
90334: LD_INT 1
90336: NEG
90337: PUSH
90338: LD_INT 0
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: PUSH
90345: LD_INT 1
90347: NEG
90348: PUSH
90349: LD_INT 1
90351: NEG
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90366: LD_ADDR_VAR 0 63
90370: PUSH
90371: LD_INT 0
90373: PUSH
90374: LD_INT 0
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 0
90383: PUSH
90384: LD_INT 1
90386: NEG
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: PUSH
90392: LD_INT 1
90394: PUSH
90395: LD_INT 0
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 1
90404: PUSH
90405: LD_INT 1
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 0
90414: PUSH
90415: LD_INT 1
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 1
90424: NEG
90425: PUSH
90426: LD_INT 0
90428: PUSH
90429: EMPTY
90430: LIST
90431: LIST
90432: PUSH
90433: LD_INT 1
90435: NEG
90436: PUSH
90437: LD_INT 1
90439: NEG
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: LIST
90451: LIST
90452: LIST
90453: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90454: LD_ADDR_VAR 0 64
90458: PUSH
90459: LD_INT 0
90461: PUSH
90462: LD_INT 0
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 0
90471: PUSH
90472: LD_INT 1
90474: NEG
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: LD_INT 0
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: PUSH
90493: LD_INT 1
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: LD_INT 0
90502: PUSH
90503: LD_INT 1
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PUSH
90510: LD_INT 1
90512: NEG
90513: PUSH
90514: LD_INT 0
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: PUSH
90521: LD_INT 1
90523: NEG
90524: PUSH
90525: LD_INT 1
90527: NEG
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: LIST
90537: LIST
90538: LIST
90539: LIST
90540: LIST
90541: ST_TO_ADDR
// end ; 1 :
90542: GO 96439
90544: LD_INT 1
90546: DOUBLE
90547: EQUAL
90548: IFTRUE 90552
90550: GO 93175
90552: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90553: LD_ADDR_VAR 0 11
90557: PUSH
90558: LD_INT 1
90560: NEG
90561: PUSH
90562: LD_INT 3
90564: NEG
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 0
90572: PUSH
90573: LD_INT 3
90575: NEG
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 1
90583: PUSH
90584: LD_INT 2
90586: NEG
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: LIST
90596: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90597: LD_ADDR_VAR 0 12
90601: PUSH
90602: LD_INT 2
90604: PUSH
90605: LD_INT 1
90607: NEG
90608: PUSH
90609: EMPTY
90610: LIST
90611: LIST
90612: PUSH
90613: LD_INT 3
90615: PUSH
90616: LD_INT 0
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: PUSH
90623: LD_INT 3
90625: PUSH
90626: LD_INT 1
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: LIST
90637: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90638: LD_ADDR_VAR 0 13
90642: PUSH
90643: LD_INT 3
90645: PUSH
90646: LD_INT 2
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: PUSH
90653: LD_INT 3
90655: PUSH
90656: LD_INT 3
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: PUSH
90663: LD_INT 2
90665: PUSH
90666: LD_INT 3
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: LIST
90677: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90678: LD_ADDR_VAR 0 14
90682: PUSH
90683: LD_INT 1
90685: PUSH
90686: LD_INT 3
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 0
90695: PUSH
90696: LD_INT 3
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 1
90705: NEG
90706: PUSH
90707: LD_INT 2
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: LIST
90718: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90719: LD_ADDR_VAR 0 15
90723: PUSH
90724: LD_INT 2
90726: NEG
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: LD_INT 3
90737: NEG
90738: PUSH
90739: LD_INT 0
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: LD_INT 3
90748: NEG
90749: PUSH
90750: LD_INT 1
90752: NEG
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: LIST
90762: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90763: LD_ADDR_VAR 0 16
90767: PUSH
90768: LD_INT 2
90770: NEG
90771: PUSH
90772: LD_INT 3
90774: NEG
90775: PUSH
90776: EMPTY
90777: LIST
90778: LIST
90779: PUSH
90780: LD_INT 3
90782: NEG
90783: PUSH
90784: LD_INT 2
90786: NEG
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 3
90794: NEG
90795: PUSH
90796: LD_INT 3
90798: NEG
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: LIST
90808: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90809: LD_ADDR_VAR 0 17
90813: PUSH
90814: LD_INT 1
90816: NEG
90817: PUSH
90818: LD_INT 3
90820: NEG
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 0
90828: PUSH
90829: LD_INT 3
90831: NEG
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: PUSH
90837: LD_INT 1
90839: PUSH
90840: LD_INT 2
90842: NEG
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: LIST
90852: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90853: LD_ADDR_VAR 0 18
90857: PUSH
90858: LD_INT 2
90860: PUSH
90861: LD_INT 1
90863: NEG
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 3
90871: PUSH
90872: LD_INT 0
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 3
90881: PUSH
90882: LD_INT 1
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: LIST
90893: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90894: LD_ADDR_VAR 0 19
90898: PUSH
90899: LD_INT 3
90901: PUSH
90902: LD_INT 2
90904: PUSH
90905: EMPTY
90906: LIST
90907: LIST
90908: PUSH
90909: LD_INT 3
90911: PUSH
90912: LD_INT 3
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: LD_INT 2
90921: PUSH
90922: LD_INT 3
90924: PUSH
90925: EMPTY
90926: LIST
90927: LIST
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: LIST
90933: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90934: LD_ADDR_VAR 0 20
90938: PUSH
90939: LD_INT 1
90941: PUSH
90942: LD_INT 3
90944: PUSH
90945: EMPTY
90946: LIST
90947: LIST
90948: PUSH
90949: LD_INT 0
90951: PUSH
90952: LD_INT 3
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: LD_INT 1
90961: NEG
90962: PUSH
90963: LD_INT 2
90965: PUSH
90966: EMPTY
90967: LIST
90968: LIST
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: LIST
90974: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90975: LD_ADDR_VAR 0 21
90979: PUSH
90980: LD_INT 2
90982: NEG
90983: PUSH
90984: LD_INT 1
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: PUSH
90991: LD_INT 3
90993: NEG
90994: PUSH
90995: LD_INT 0
90997: PUSH
90998: EMPTY
90999: LIST
91000: LIST
91001: PUSH
91002: LD_INT 3
91004: NEG
91005: PUSH
91006: LD_INT 1
91008: NEG
91009: PUSH
91010: EMPTY
91011: LIST
91012: LIST
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: LIST
91018: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91019: LD_ADDR_VAR 0 22
91023: PUSH
91024: LD_INT 2
91026: NEG
91027: PUSH
91028: LD_INT 3
91030: NEG
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 3
91038: NEG
91039: PUSH
91040: LD_INT 2
91042: NEG
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 3
91050: NEG
91051: PUSH
91052: LD_INT 3
91054: NEG
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: LIST
91064: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91065: LD_ADDR_VAR 0 23
91069: PUSH
91070: LD_INT 0
91072: PUSH
91073: LD_INT 3
91075: NEG
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 1
91083: NEG
91084: PUSH
91085: LD_INT 4
91087: NEG
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 1
91095: PUSH
91096: LD_INT 3
91098: NEG
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: LIST
91108: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91109: LD_ADDR_VAR 0 24
91113: PUSH
91114: LD_INT 3
91116: PUSH
91117: LD_INT 0
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: LD_INT 3
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 4
91137: PUSH
91138: LD_INT 1
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: LIST
91149: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91150: LD_ADDR_VAR 0 25
91154: PUSH
91155: LD_INT 3
91157: PUSH
91158: LD_INT 3
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: LD_INT 4
91167: PUSH
91168: LD_INT 3
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 3
91177: PUSH
91178: LD_INT 4
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: LIST
91189: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91190: LD_ADDR_VAR 0 26
91194: PUSH
91195: LD_INT 0
91197: PUSH
91198: LD_INT 3
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: LD_INT 4
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 1
91217: NEG
91218: PUSH
91219: LD_INT 3
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: LIST
91230: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91231: LD_ADDR_VAR 0 27
91235: PUSH
91236: LD_INT 3
91238: NEG
91239: PUSH
91240: LD_INT 0
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 3
91249: NEG
91250: PUSH
91251: LD_INT 1
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: PUSH
91258: LD_INT 4
91260: NEG
91261: PUSH
91262: LD_INT 1
91264: NEG
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: LIST
91274: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
91275: LD_ADDR_VAR 0 28
91279: PUSH
91280: LD_INT 3
91282: NEG
91283: PUSH
91284: LD_INT 3
91286: NEG
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: PUSH
91292: LD_INT 3
91294: NEG
91295: PUSH
91296: LD_INT 4
91298: NEG
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: PUSH
91304: LD_INT 4
91306: NEG
91307: PUSH
91308: LD_INT 3
91310: NEG
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: LIST
91320: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
91321: LD_ADDR_VAR 0 29
91325: PUSH
91326: LD_INT 1
91328: NEG
91329: PUSH
91330: LD_INT 3
91332: NEG
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: PUSH
91338: LD_INT 0
91340: PUSH
91341: LD_INT 3
91343: NEG
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 1
91351: PUSH
91352: LD_INT 2
91354: NEG
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 1
91362: NEG
91363: PUSH
91364: LD_INT 4
91366: NEG
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PUSH
91372: LD_INT 0
91374: PUSH
91375: LD_INT 4
91377: NEG
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 1
91385: PUSH
91386: LD_INT 3
91388: NEG
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 1
91396: NEG
91397: PUSH
91398: LD_INT 5
91400: NEG
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 0
91408: PUSH
91409: LD_INT 5
91411: NEG
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 1
91419: PUSH
91420: LD_INT 4
91422: NEG
91423: PUSH
91424: EMPTY
91425: LIST
91426: LIST
91427: PUSH
91428: LD_INT 1
91430: NEG
91431: PUSH
91432: LD_INT 6
91434: NEG
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 0
91442: PUSH
91443: LD_INT 6
91445: NEG
91446: PUSH
91447: EMPTY
91448: LIST
91449: LIST
91450: PUSH
91451: LD_INT 1
91453: PUSH
91454: LD_INT 5
91456: NEG
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91476: LD_ADDR_VAR 0 30
91480: PUSH
91481: LD_INT 2
91483: PUSH
91484: LD_INT 1
91486: NEG
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: PUSH
91492: LD_INT 3
91494: PUSH
91495: LD_INT 0
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 3
91504: PUSH
91505: LD_INT 1
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 3
91514: PUSH
91515: LD_INT 1
91517: NEG
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 4
91525: PUSH
91526: LD_INT 0
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: LD_INT 4
91535: PUSH
91536: LD_INT 1
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 4
91545: PUSH
91546: LD_INT 1
91548: NEG
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: LD_INT 5
91556: PUSH
91557: LD_INT 0
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 5
91566: PUSH
91567: LD_INT 1
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: LD_INT 5
91576: PUSH
91577: LD_INT 1
91579: NEG
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: PUSH
91585: LD_INT 6
91587: PUSH
91588: LD_INT 0
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: PUSH
91595: LD_INT 6
91597: PUSH
91598: LD_INT 1
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91619: LD_ADDR_VAR 0 31
91623: PUSH
91624: LD_INT 3
91626: PUSH
91627: LD_INT 2
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 3
91636: PUSH
91637: LD_INT 3
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 2
91646: PUSH
91647: LD_INT 3
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 4
91656: PUSH
91657: LD_INT 3
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 4
91666: PUSH
91667: LD_INT 4
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: LD_INT 3
91676: PUSH
91677: LD_INT 4
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 5
91686: PUSH
91687: LD_INT 4
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 5
91696: PUSH
91697: LD_INT 5
91699: PUSH
91700: EMPTY
91701: LIST
91702: LIST
91703: PUSH
91704: LD_INT 4
91706: PUSH
91707: LD_INT 5
91709: PUSH
91710: EMPTY
91711: LIST
91712: LIST
91713: PUSH
91714: LD_INT 6
91716: PUSH
91717: LD_INT 5
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: PUSH
91724: LD_INT 6
91726: PUSH
91727: LD_INT 6
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: PUSH
91734: LD_INT 5
91736: PUSH
91737: LD_INT 6
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91758: LD_ADDR_VAR 0 32
91762: PUSH
91763: LD_INT 1
91765: PUSH
91766: LD_INT 3
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 0
91775: PUSH
91776: LD_INT 3
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: PUSH
91783: LD_INT 1
91785: NEG
91786: PUSH
91787: LD_INT 2
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: PUSH
91794: LD_INT 1
91796: PUSH
91797: LD_INT 4
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: PUSH
91804: LD_INT 0
91806: PUSH
91807: LD_INT 4
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: PUSH
91814: LD_INT 1
91816: NEG
91817: PUSH
91818: LD_INT 3
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: PUSH
91825: LD_INT 1
91827: PUSH
91828: LD_INT 5
91830: PUSH
91831: EMPTY
91832: LIST
91833: LIST
91834: PUSH
91835: LD_INT 0
91837: PUSH
91838: LD_INT 5
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 1
91847: NEG
91848: PUSH
91849: LD_INT 4
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 1
91858: PUSH
91859: LD_INT 6
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 0
91868: PUSH
91869: LD_INT 6
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 1
91878: NEG
91879: PUSH
91880: LD_INT 5
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91901: LD_ADDR_VAR 0 33
91905: PUSH
91906: LD_INT 2
91908: NEG
91909: PUSH
91910: LD_INT 1
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: PUSH
91917: LD_INT 3
91919: NEG
91920: PUSH
91921: LD_INT 0
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 3
91930: NEG
91931: PUSH
91932: LD_INT 1
91934: NEG
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: LD_INT 3
91942: NEG
91943: PUSH
91944: LD_INT 1
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 4
91953: NEG
91954: PUSH
91955: LD_INT 0
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 4
91964: NEG
91965: PUSH
91966: LD_INT 1
91968: NEG
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: LD_INT 4
91976: NEG
91977: PUSH
91978: LD_INT 1
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: PUSH
91985: LD_INT 5
91987: NEG
91988: PUSH
91989: LD_INT 0
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: LD_INT 5
91998: NEG
91999: PUSH
92000: LD_INT 1
92002: NEG
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: LD_INT 5
92010: NEG
92011: PUSH
92012: LD_INT 1
92014: PUSH
92015: EMPTY
92016: LIST
92017: LIST
92018: PUSH
92019: LD_INT 6
92021: NEG
92022: PUSH
92023: LD_INT 0
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 6
92032: NEG
92033: PUSH
92034: LD_INT 1
92036: NEG
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: LIST
92054: LIST
92055: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92056: LD_ADDR_VAR 0 34
92060: PUSH
92061: LD_INT 2
92063: NEG
92064: PUSH
92065: LD_INT 3
92067: NEG
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: PUSH
92073: LD_INT 3
92075: NEG
92076: PUSH
92077: LD_INT 2
92079: NEG
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 3
92087: NEG
92088: PUSH
92089: LD_INT 3
92091: NEG
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 3
92099: NEG
92100: PUSH
92101: LD_INT 4
92103: NEG
92104: PUSH
92105: EMPTY
92106: LIST
92107: LIST
92108: PUSH
92109: LD_INT 4
92111: NEG
92112: PUSH
92113: LD_INT 3
92115: NEG
92116: PUSH
92117: EMPTY
92118: LIST
92119: LIST
92120: PUSH
92121: LD_INT 4
92123: NEG
92124: PUSH
92125: LD_INT 4
92127: NEG
92128: PUSH
92129: EMPTY
92130: LIST
92131: LIST
92132: PUSH
92133: LD_INT 4
92135: NEG
92136: PUSH
92137: LD_INT 5
92139: NEG
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PUSH
92145: LD_INT 5
92147: NEG
92148: PUSH
92149: LD_INT 4
92151: NEG
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 5
92159: NEG
92160: PUSH
92161: LD_INT 5
92163: NEG
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 5
92171: NEG
92172: PUSH
92173: LD_INT 6
92175: NEG
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 6
92183: NEG
92184: PUSH
92185: LD_INT 5
92187: NEG
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 6
92195: NEG
92196: PUSH
92197: LD_INT 6
92199: NEG
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92219: LD_ADDR_VAR 0 41
92223: PUSH
92224: LD_INT 0
92226: PUSH
92227: LD_INT 2
92229: NEG
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 1
92237: NEG
92238: PUSH
92239: LD_INT 3
92241: NEG
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 1
92249: PUSH
92250: LD_INT 2
92252: NEG
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: PUSH
92258: EMPTY
92259: LIST
92260: LIST
92261: LIST
92262: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
92263: LD_ADDR_VAR 0 42
92267: PUSH
92268: LD_INT 2
92270: PUSH
92271: LD_INT 0
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 2
92280: PUSH
92281: LD_INT 1
92283: NEG
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: PUSH
92289: LD_INT 3
92291: PUSH
92292: LD_INT 1
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: LIST
92303: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
92304: LD_ADDR_VAR 0 43
92308: PUSH
92309: LD_INT 2
92311: PUSH
92312: LD_INT 2
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 3
92321: PUSH
92322: LD_INT 2
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 2
92331: PUSH
92332: LD_INT 3
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: LIST
92343: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
92344: LD_ADDR_VAR 0 44
92348: PUSH
92349: LD_INT 0
92351: PUSH
92352: LD_INT 2
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: PUSH
92359: LD_INT 1
92361: PUSH
92362: LD_INT 3
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: PUSH
92369: LD_INT 1
92371: NEG
92372: PUSH
92373: LD_INT 2
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: LIST
92384: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
92385: LD_ADDR_VAR 0 45
92389: PUSH
92390: LD_INT 2
92392: NEG
92393: PUSH
92394: LD_INT 0
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: LD_INT 2
92403: NEG
92404: PUSH
92405: LD_INT 1
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 3
92414: NEG
92415: PUSH
92416: LD_INT 1
92418: NEG
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: LIST
92428: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
92429: LD_ADDR_VAR 0 46
92433: PUSH
92434: LD_INT 2
92436: NEG
92437: PUSH
92438: LD_INT 2
92440: NEG
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: LD_INT 2
92448: NEG
92449: PUSH
92450: LD_INT 3
92452: NEG
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 3
92460: NEG
92461: PUSH
92462: LD_INT 2
92464: NEG
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: LIST
92474: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92475: LD_ADDR_VAR 0 47
92479: PUSH
92480: LD_INT 2
92482: NEG
92483: PUSH
92484: LD_INT 3
92486: NEG
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: LD_INT 1
92494: NEG
92495: PUSH
92496: LD_INT 3
92498: NEG
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92508: LD_ADDR_VAR 0 48
92512: PUSH
92513: LD_INT 1
92515: PUSH
92516: LD_INT 2
92518: NEG
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 2
92526: PUSH
92527: LD_INT 1
92529: NEG
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92539: LD_ADDR_VAR 0 49
92543: PUSH
92544: LD_INT 3
92546: PUSH
92547: LD_INT 1
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: PUSH
92554: LD_INT 3
92556: PUSH
92557: LD_INT 2
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92568: LD_ADDR_VAR 0 50
92572: PUSH
92573: LD_INT 2
92575: PUSH
92576: LD_INT 3
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: PUSH
92583: LD_INT 1
92585: PUSH
92586: LD_INT 3
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92597: LD_ADDR_VAR 0 51
92601: PUSH
92602: LD_INT 1
92604: NEG
92605: PUSH
92606: LD_INT 2
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PUSH
92613: LD_INT 2
92615: NEG
92616: PUSH
92617: LD_INT 1
92619: PUSH
92620: EMPTY
92621: LIST
92622: LIST
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92628: LD_ADDR_VAR 0 52
92632: PUSH
92633: LD_INT 3
92635: NEG
92636: PUSH
92637: LD_INT 1
92639: NEG
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 3
92647: NEG
92648: PUSH
92649: LD_INT 2
92651: NEG
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: EMPTY
92658: LIST
92659: LIST
92660: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92661: LD_ADDR_VAR 0 53
92665: PUSH
92666: LD_INT 1
92668: NEG
92669: PUSH
92670: LD_INT 3
92672: NEG
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PUSH
92678: LD_INT 0
92680: PUSH
92681: LD_INT 3
92683: NEG
92684: PUSH
92685: EMPTY
92686: LIST
92687: LIST
92688: PUSH
92689: LD_INT 1
92691: PUSH
92692: LD_INT 2
92694: NEG
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: LIST
92704: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92705: LD_ADDR_VAR 0 54
92709: PUSH
92710: LD_INT 2
92712: PUSH
92713: LD_INT 1
92715: NEG
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 3
92723: PUSH
92724: LD_INT 0
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 3
92733: PUSH
92734: LD_INT 1
92736: PUSH
92737: EMPTY
92738: LIST
92739: LIST
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: LIST
92745: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92746: LD_ADDR_VAR 0 55
92750: PUSH
92751: LD_INT 3
92753: PUSH
92754: LD_INT 2
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: PUSH
92761: LD_INT 3
92763: PUSH
92764: LD_INT 3
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 2
92773: PUSH
92774: LD_INT 3
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: EMPTY
92782: LIST
92783: LIST
92784: LIST
92785: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92786: LD_ADDR_VAR 0 56
92790: PUSH
92791: LD_INT 1
92793: PUSH
92794: LD_INT 3
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: PUSH
92801: LD_INT 0
92803: PUSH
92804: LD_INT 3
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 1
92813: NEG
92814: PUSH
92815: LD_INT 2
92817: PUSH
92818: EMPTY
92819: LIST
92820: LIST
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: LIST
92826: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92827: LD_ADDR_VAR 0 57
92831: PUSH
92832: LD_INT 2
92834: NEG
92835: PUSH
92836: LD_INT 1
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: PUSH
92843: LD_INT 3
92845: NEG
92846: PUSH
92847: LD_INT 0
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: PUSH
92854: LD_INT 3
92856: NEG
92857: PUSH
92858: LD_INT 1
92860: NEG
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: PUSH
92866: EMPTY
92867: LIST
92868: LIST
92869: LIST
92870: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92871: LD_ADDR_VAR 0 58
92875: PUSH
92876: LD_INT 2
92878: NEG
92879: PUSH
92880: LD_INT 3
92882: NEG
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 3
92890: NEG
92891: PUSH
92892: LD_INT 2
92894: NEG
92895: PUSH
92896: EMPTY
92897: LIST
92898: LIST
92899: PUSH
92900: LD_INT 3
92902: NEG
92903: PUSH
92904: LD_INT 3
92906: NEG
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: LIST
92916: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92917: LD_ADDR_VAR 0 59
92921: PUSH
92922: LD_INT 1
92924: NEG
92925: PUSH
92926: LD_INT 2
92928: NEG
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PUSH
92934: LD_INT 0
92936: PUSH
92937: LD_INT 2
92939: NEG
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 1
92947: PUSH
92948: LD_INT 1
92950: NEG
92951: PUSH
92952: EMPTY
92953: LIST
92954: LIST
92955: PUSH
92956: EMPTY
92957: LIST
92958: LIST
92959: LIST
92960: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92961: LD_ADDR_VAR 0 60
92965: PUSH
92966: LD_INT 1
92968: PUSH
92969: LD_INT 1
92971: NEG
92972: PUSH
92973: EMPTY
92974: LIST
92975: LIST
92976: PUSH
92977: LD_INT 2
92979: PUSH
92980: LD_INT 0
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 2
92989: PUSH
92990: LD_INT 1
92992: PUSH
92993: EMPTY
92994: LIST
92995: LIST
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: LIST
93001: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93002: LD_ADDR_VAR 0 61
93006: PUSH
93007: LD_INT 2
93009: PUSH
93010: LD_INT 1
93012: PUSH
93013: EMPTY
93014: LIST
93015: LIST
93016: PUSH
93017: LD_INT 2
93019: PUSH
93020: LD_INT 2
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: LD_INT 1
93029: PUSH
93030: LD_INT 2
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: LIST
93041: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93042: LD_ADDR_VAR 0 62
93046: PUSH
93047: LD_INT 1
93049: PUSH
93050: LD_INT 2
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: PUSH
93057: LD_INT 0
93059: PUSH
93060: LD_INT 2
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: PUSH
93067: LD_INT 1
93069: NEG
93070: PUSH
93071: LD_INT 1
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: LIST
93082: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93083: LD_ADDR_VAR 0 63
93087: PUSH
93088: LD_INT 1
93090: NEG
93091: PUSH
93092: LD_INT 1
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 2
93101: NEG
93102: PUSH
93103: LD_INT 0
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: LD_INT 2
93112: NEG
93113: PUSH
93114: LD_INT 1
93116: NEG
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: LIST
93126: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93127: LD_ADDR_VAR 0 64
93131: PUSH
93132: LD_INT 1
93134: NEG
93135: PUSH
93136: LD_INT 2
93138: NEG
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: LD_INT 2
93146: NEG
93147: PUSH
93148: LD_INT 1
93150: NEG
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 2
93158: NEG
93159: PUSH
93160: LD_INT 2
93162: NEG
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: LIST
93172: ST_TO_ADDR
// end ; 2 :
93173: GO 96439
93175: LD_INT 2
93177: DOUBLE
93178: EQUAL
93179: IFTRUE 93183
93181: GO 96438
93183: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93184: LD_ADDR_VAR 0 29
93188: PUSH
93189: LD_INT 4
93191: PUSH
93192: LD_INT 0
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 4
93201: PUSH
93202: LD_INT 1
93204: NEG
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PUSH
93210: LD_INT 5
93212: PUSH
93213: LD_INT 0
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: LD_INT 5
93222: PUSH
93223: LD_INT 1
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PUSH
93230: LD_INT 4
93232: PUSH
93233: LD_INT 1
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: LD_INT 3
93242: PUSH
93243: LD_INT 0
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: LD_INT 3
93252: PUSH
93253: LD_INT 1
93255: NEG
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 3
93263: PUSH
93264: LD_INT 2
93266: NEG
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 5
93274: PUSH
93275: LD_INT 2
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: PUSH
93282: LD_INT 3
93284: PUSH
93285: LD_INT 3
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 3
93294: PUSH
93295: LD_INT 2
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 4
93304: PUSH
93305: LD_INT 3
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: LD_INT 4
93314: PUSH
93315: LD_INT 4
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: LD_INT 3
93324: PUSH
93325: LD_INT 4
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: LD_INT 2
93334: PUSH
93335: LD_INT 3
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 2
93344: PUSH
93345: LD_INT 2
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 4
93354: PUSH
93355: LD_INT 2
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: PUSH
93362: LD_INT 2
93364: PUSH
93365: LD_INT 4
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: PUSH
93372: LD_INT 0
93374: PUSH
93375: LD_INT 4
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: PUSH
93382: LD_INT 0
93384: PUSH
93385: LD_INT 3
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 1
93394: PUSH
93395: LD_INT 4
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PUSH
93402: LD_INT 1
93404: PUSH
93405: LD_INT 5
93407: PUSH
93408: EMPTY
93409: LIST
93410: LIST
93411: PUSH
93412: LD_INT 0
93414: PUSH
93415: LD_INT 5
93417: PUSH
93418: EMPTY
93419: LIST
93420: LIST
93421: PUSH
93422: LD_INT 1
93424: NEG
93425: PUSH
93426: LD_INT 4
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: LD_INT 1
93435: NEG
93436: PUSH
93437: LD_INT 3
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 2
93446: PUSH
93447: LD_INT 5
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: LD_INT 2
93456: NEG
93457: PUSH
93458: LD_INT 3
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 3
93467: NEG
93468: PUSH
93469: LD_INT 0
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 3
93478: NEG
93479: PUSH
93480: LD_INT 1
93482: NEG
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 2
93490: NEG
93491: PUSH
93492: LD_INT 0
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: PUSH
93499: LD_INT 2
93501: NEG
93502: PUSH
93503: LD_INT 1
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 3
93512: NEG
93513: PUSH
93514: LD_INT 1
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 4
93523: NEG
93524: PUSH
93525: LD_INT 0
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 4
93534: NEG
93535: PUSH
93536: LD_INT 1
93538: NEG
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: PUSH
93544: LD_INT 4
93546: NEG
93547: PUSH
93548: LD_INT 2
93550: NEG
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: LD_INT 2
93558: NEG
93559: PUSH
93560: LD_INT 2
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: PUSH
93567: LD_INT 4
93569: NEG
93570: PUSH
93571: LD_INT 4
93573: NEG
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 4
93581: NEG
93582: PUSH
93583: LD_INT 5
93585: NEG
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 3
93593: NEG
93594: PUSH
93595: LD_INT 4
93597: NEG
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: PUSH
93603: LD_INT 3
93605: NEG
93606: PUSH
93607: LD_INT 3
93609: NEG
93610: PUSH
93611: EMPTY
93612: LIST
93613: LIST
93614: PUSH
93615: LD_INT 4
93617: NEG
93618: PUSH
93619: LD_INT 3
93621: NEG
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 5
93629: NEG
93630: PUSH
93631: LD_INT 4
93633: NEG
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 5
93641: NEG
93642: PUSH
93643: LD_INT 5
93645: NEG
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 3
93653: NEG
93654: PUSH
93655: LD_INT 5
93657: NEG
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 5
93665: NEG
93666: PUSH
93667: LD_INT 3
93669: NEG
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93722: LD_ADDR_VAR 0 30
93726: PUSH
93727: LD_INT 4
93729: PUSH
93730: LD_INT 4
93732: PUSH
93733: EMPTY
93734: LIST
93735: LIST
93736: PUSH
93737: LD_INT 4
93739: PUSH
93740: LD_INT 3
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 5
93749: PUSH
93750: LD_INT 4
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: LD_INT 5
93759: PUSH
93760: LD_INT 5
93762: PUSH
93763: EMPTY
93764: LIST
93765: LIST
93766: PUSH
93767: LD_INT 4
93769: PUSH
93770: LD_INT 5
93772: PUSH
93773: EMPTY
93774: LIST
93775: LIST
93776: PUSH
93777: LD_INT 3
93779: PUSH
93780: LD_INT 4
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 3
93789: PUSH
93790: LD_INT 3
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 5
93799: PUSH
93800: LD_INT 3
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: PUSH
93807: LD_INT 3
93809: PUSH
93810: LD_INT 5
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 0
93819: PUSH
93820: LD_INT 3
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 0
93829: PUSH
93830: LD_INT 2
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 1
93839: PUSH
93840: LD_INT 3
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: PUSH
93847: LD_INT 1
93849: PUSH
93850: LD_INT 4
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PUSH
93857: LD_INT 0
93859: PUSH
93860: LD_INT 4
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: PUSH
93867: LD_INT 1
93869: NEG
93870: PUSH
93871: LD_INT 3
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: PUSH
93878: LD_INT 1
93880: NEG
93881: PUSH
93882: LD_INT 2
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: PUSH
93889: LD_INT 2
93891: PUSH
93892: LD_INT 4
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: PUSH
93899: LD_INT 2
93901: NEG
93902: PUSH
93903: LD_INT 2
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 4
93912: NEG
93913: PUSH
93914: LD_INT 0
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 4
93923: NEG
93924: PUSH
93925: LD_INT 1
93927: NEG
93928: PUSH
93929: EMPTY
93930: LIST
93931: LIST
93932: PUSH
93933: LD_INT 3
93935: NEG
93936: PUSH
93937: LD_INT 0
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PUSH
93944: LD_INT 3
93946: NEG
93947: PUSH
93948: LD_INT 1
93950: PUSH
93951: EMPTY
93952: LIST
93953: LIST
93954: PUSH
93955: LD_INT 4
93957: NEG
93958: PUSH
93959: LD_INT 1
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: LD_INT 5
93968: NEG
93969: PUSH
93970: LD_INT 0
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 5
93979: NEG
93980: PUSH
93981: LD_INT 1
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 5
93991: NEG
93992: PUSH
93993: LD_INT 2
93995: NEG
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: LD_INT 3
94003: NEG
94004: PUSH
94005: LD_INT 2
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PUSH
94012: LD_INT 3
94014: NEG
94015: PUSH
94016: LD_INT 3
94018: NEG
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: LD_INT 3
94026: NEG
94027: PUSH
94028: LD_INT 4
94030: NEG
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 2
94038: NEG
94039: PUSH
94040: LD_INT 3
94042: NEG
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 2
94050: NEG
94051: PUSH
94052: LD_INT 2
94054: NEG
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: LD_INT 3
94062: NEG
94063: PUSH
94064: LD_INT 2
94066: NEG
94067: PUSH
94068: EMPTY
94069: LIST
94070: LIST
94071: PUSH
94072: LD_INT 4
94074: NEG
94075: PUSH
94076: LD_INT 3
94078: NEG
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 4
94086: NEG
94087: PUSH
94088: LD_INT 4
94090: NEG
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 2
94098: NEG
94099: PUSH
94100: LD_INT 4
94102: NEG
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 4
94110: NEG
94111: PUSH
94112: LD_INT 2
94114: NEG
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: PUSH
94120: LD_INT 0
94122: PUSH
94123: LD_INT 4
94125: NEG
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 0
94133: PUSH
94134: LD_INT 5
94136: NEG
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: PUSH
94142: LD_INT 1
94144: PUSH
94145: LD_INT 4
94147: NEG
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: PUSH
94153: LD_INT 1
94155: PUSH
94156: LD_INT 3
94158: NEG
94159: PUSH
94160: EMPTY
94161: LIST
94162: LIST
94163: PUSH
94164: LD_INT 0
94166: PUSH
94167: LD_INT 3
94169: NEG
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 1
94177: NEG
94178: PUSH
94179: LD_INT 4
94181: NEG
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: LD_INT 1
94189: NEG
94190: PUSH
94191: LD_INT 5
94193: NEG
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: PUSH
94199: LD_INT 2
94201: PUSH
94202: LD_INT 3
94204: NEG
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: LD_INT 2
94212: NEG
94213: PUSH
94214: LD_INT 5
94216: NEG
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: PUSH
94222: EMPTY
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
94269: LD_ADDR_VAR 0 31
94273: PUSH
94274: LD_INT 0
94276: PUSH
94277: LD_INT 4
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 0
94286: PUSH
94287: LD_INT 3
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 1
94296: PUSH
94297: LD_INT 4
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: PUSH
94304: LD_INT 1
94306: PUSH
94307: LD_INT 5
94309: PUSH
94310: EMPTY
94311: LIST
94312: LIST
94313: PUSH
94314: LD_INT 0
94316: PUSH
94317: LD_INT 5
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: PUSH
94324: LD_INT 1
94326: NEG
94327: PUSH
94328: LD_INT 4
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 1
94337: NEG
94338: PUSH
94339: LD_INT 3
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PUSH
94346: LD_INT 2
94348: PUSH
94349: LD_INT 5
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: LD_INT 2
94358: NEG
94359: PUSH
94360: LD_INT 3
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: PUSH
94367: LD_INT 3
94369: NEG
94370: PUSH
94371: LD_INT 0
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 3
94380: NEG
94381: PUSH
94382: LD_INT 1
94384: NEG
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: PUSH
94390: LD_INT 2
94392: NEG
94393: PUSH
94394: LD_INT 0
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 2
94403: NEG
94404: PUSH
94405: LD_INT 1
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 3
94414: NEG
94415: PUSH
94416: LD_INT 1
94418: PUSH
94419: EMPTY
94420: LIST
94421: LIST
94422: PUSH
94423: LD_INT 4
94425: NEG
94426: PUSH
94427: LD_INT 0
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 4
94436: NEG
94437: PUSH
94438: LD_INT 1
94440: NEG
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 4
94448: NEG
94449: PUSH
94450: LD_INT 2
94452: NEG
94453: PUSH
94454: EMPTY
94455: LIST
94456: LIST
94457: PUSH
94458: LD_INT 2
94460: NEG
94461: PUSH
94462: LD_INT 2
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 4
94471: NEG
94472: PUSH
94473: LD_INT 4
94475: NEG
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 4
94483: NEG
94484: PUSH
94485: LD_INT 5
94487: NEG
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 3
94495: NEG
94496: PUSH
94497: LD_INT 4
94499: NEG
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 3
94507: NEG
94508: PUSH
94509: LD_INT 3
94511: NEG
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 4
94519: NEG
94520: PUSH
94521: LD_INT 3
94523: NEG
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 5
94531: NEG
94532: PUSH
94533: LD_INT 4
94535: NEG
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: PUSH
94541: LD_INT 5
94543: NEG
94544: PUSH
94545: LD_INT 5
94547: NEG
94548: PUSH
94549: EMPTY
94550: LIST
94551: LIST
94552: PUSH
94553: LD_INT 3
94555: NEG
94556: PUSH
94557: LD_INT 5
94559: NEG
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 5
94567: NEG
94568: PUSH
94569: LD_INT 3
94571: NEG
94572: PUSH
94573: EMPTY
94574: LIST
94575: LIST
94576: PUSH
94577: LD_INT 0
94579: PUSH
94580: LD_INT 3
94582: NEG
94583: PUSH
94584: EMPTY
94585: LIST
94586: LIST
94587: PUSH
94588: LD_INT 0
94590: PUSH
94591: LD_INT 4
94593: NEG
94594: PUSH
94595: EMPTY
94596: LIST
94597: LIST
94598: PUSH
94599: LD_INT 1
94601: PUSH
94602: LD_INT 3
94604: NEG
94605: PUSH
94606: EMPTY
94607: LIST
94608: LIST
94609: PUSH
94610: LD_INT 1
94612: PUSH
94613: LD_INT 2
94615: NEG
94616: PUSH
94617: EMPTY
94618: LIST
94619: LIST
94620: PUSH
94621: LD_INT 0
94623: PUSH
94624: LD_INT 2
94626: NEG
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 1
94634: NEG
94635: PUSH
94636: LD_INT 3
94638: NEG
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 1
94646: NEG
94647: PUSH
94648: LD_INT 4
94650: NEG
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: PUSH
94656: LD_INT 2
94658: PUSH
94659: LD_INT 2
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 2
94669: NEG
94670: PUSH
94671: LD_INT 4
94673: NEG
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 4
94681: PUSH
94682: LD_INT 0
94684: PUSH
94685: EMPTY
94686: LIST
94687: LIST
94688: PUSH
94689: LD_INT 4
94691: PUSH
94692: LD_INT 1
94694: NEG
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PUSH
94700: LD_INT 5
94702: PUSH
94703: LD_INT 0
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: LD_INT 5
94712: PUSH
94713: LD_INT 1
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 4
94722: PUSH
94723: LD_INT 1
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 3
94732: PUSH
94733: LD_INT 0
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 3
94742: PUSH
94743: LD_INT 1
94745: NEG
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: LD_INT 3
94753: PUSH
94754: LD_INT 2
94756: NEG
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 5
94764: PUSH
94765: LD_INT 2
94767: PUSH
94768: EMPTY
94769: LIST
94770: LIST
94771: PUSH
94772: EMPTY
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94819: LD_ADDR_VAR 0 32
94823: PUSH
94824: LD_INT 4
94826: NEG
94827: PUSH
94828: LD_INT 0
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 4
94837: NEG
94838: PUSH
94839: LD_INT 1
94841: NEG
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 3
94849: NEG
94850: PUSH
94851: LD_INT 0
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 3
94860: NEG
94861: PUSH
94862: LD_INT 1
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 4
94871: NEG
94872: PUSH
94873: LD_INT 1
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: PUSH
94880: LD_INT 5
94882: NEG
94883: PUSH
94884: LD_INT 0
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: PUSH
94891: LD_INT 5
94893: NEG
94894: PUSH
94895: LD_INT 1
94897: NEG
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: PUSH
94903: LD_INT 5
94905: NEG
94906: PUSH
94907: LD_INT 2
94909: NEG
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PUSH
94915: LD_INT 3
94917: NEG
94918: PUSH
94919: LD_INT 2
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 3
94928: NEG
94929: PUSH
94930: LD_INT 3
94932: NEG
94933: PUSH
94934: EMPTY
94935: LIST
94936: LIST
94937: PUSH
94938: LD_INT 3
94940: NEG
94941: PUSH
94942: LD_INT 4
94944: NEG
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 2
94952: NEG
94953: PUSH
94954: LD_INT 3
94956: NEG
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: LD_INT 2
94964: NEG
94965: PUSH
94966: LD_INT 2
94968: NEG
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 3
94976: NEG
94977: PUSH
94978: LD_INT 2
94980: NEG
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 4
94988: NEG
94989: PUSH
94990: LD_INT 3
94992: NEG
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PUSH
94998: LD_INT 4
95000: NEG
95001: PUSH
95002: LD_INT 4
95004: NEG
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: PUSH
95010: LD_INT 2
95012: NEG
95013: PUSH
95014: LD_INT 4
95016: NEG
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: LD_INT 4
95024: NEG
95025: PUSH
95026: LD_INT 2
95028: NEG
95029: PUSH
95030: EMPTY
95031: LIST
95032: LIST
95033: PUSH
95034: LD_INT 0
95036: PUSH
95037: LD_INT 4
95039: NEG
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PUSH
95045: LD_INT 0
95047: PUSH
95048: LD_INT 5
95050: NEG
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: PUSH
95056: LD_INT 1
95058: PUSH
95059: LD_INT 4
95061: NEG
95062: PUSH
95063: EMPTY
95064: LIST
95065: LIST
95066: PUSH
95067: LD_INT 1
95069: PUSH
95070: LD_INT 3
95072: NEG
95073: PUSH
95074: EMPTY
95075: LIST
95076: LIST
95077: PUSH
95078: LD_INT 0
95080: PUSH
95081: LD_INT 3
95083: NEG
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PUSH
95089: LD_INT 1
95091: NEG
95092: PUSH
95093: LD_INT 4
95095: NEG
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: PUSH
95101: LD_INT 1
95103: NEG
95104: PUSH
95105: LD_INT 5
95107: NEG
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: PUSH
95113: LD_INT 2
95115: PUSH
95116: LD_INT 3
95118: NEG
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 2
95126: NEG
95127: PUSH
95128: LD_INT 5
95130: NEG
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 3
95138: PUSH
95139: LD_INT 0
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: LD_INT 3
95148: PUSH
95149: LD_INT 1
95151: NEG
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: PUSH
95157: LD_INT 4
95159: PUSH
95160: LD_INT 0
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: LD_INT 4
95169: PUSH
95170: LD_INT 1
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: LD_INT 3
95179: PUSH
95180: LD_INT 1
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 2
95189: PUSH
95190: LD_INT 0
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: PUSH
95197: LD_INT 2
95199: PUSH
95200: LD_INT 1
95202: NEG
95203: PUSH
95204: EMPTY
95205: LIST
95206: LIST
95207: PUSH
95208: LD_INT 2
95210: PUSH
95211: LD_INT 2
95213: NEG
95214: PUSH
95215: EMPTY
95216: LIST
95217: LIST
95218: PUSH
95219: LD_INT 4
95221: PUSH
95222: LD_INT 2
95224: PUSH
95225: EMPTY
95226: LIST
95227: LIST
95228: PUSH
95229: LD_INT 4
95231: PUSH
95232: LD_INT 4
95234: PUSH
95235: EMPTY
95236: LIST
95237: LIST
95238: PUSH
95239: LD_INT 4
95241: PUSH
95242: LD_INT 3
95244: PUSH
95245: EMPTY
95246: LIST
95247: LIST
95248: PUSH
95249: LD_INT 5
95251: PUSH
95252: LD_INT 4
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: PUSH
95259: LD_INT 5
95261: PUSH
95262: LD_INT 5
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: PUSH
95269: LD_INT 4
95271: PUSH
95272: LD_INT 5
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 3
95281: PUSH
95282: LD_INT 4
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: PUSH
95289: LD_INT 3
95291: PUSH
95292: LD_INT 3
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: LD_INT 5
95301: PUSH
95302: LD_INT 3
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: PUSH
95309: LD_INT 3
95311: PUSH
95312: LD_INT 5
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
95366: LD_ADDR_VAR 0 33
95370: PUSH
95371: LD_INT 4
95373: NEG
95374: PUSH
95375: LD_INT 4
95377: NEG
95378: PUSH
95379: EMPTY
95380: LIST
95381: LIST
95382: PUSH
95383: LD_INT 4
95385: NEG
95386: PUSH
95387: LD_INT 5
95389: NEG
95390: PUSH
95391: EMPTY
95392: LIST
95393: LIST
95394: PUSH
95395: LD_INT 3
95397: NEG
95398: PUSH
95399: LD_INT 4
95401: NEG
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 3
95409: NEG
95410: PUSH
95411: LD_INT 3
95413: NEG
95414: PUSH
95415: EMPTY
95416: LIST
95417: LIST
95418: PUSH
95419: LD_INT 4
95421: NEG
95422: PUSH
95423: LD_INT 3
95425: NEG
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 5
95433: NEG
95434: PUSH
95435: LD_INT 4
95437: NEG
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PUSH
95443: LD_INT 5
95445: NEG
95446: PUSH
95447: LD_INT 5
95449: NEG
95450: PUSH
95451: EMPTY
95452: LIST
95453: LIST
95454: PUSH
95455: LD_INT 3
95457: NEG
95458: PUSH
95459: LD_INT 5
95461: NEG
95462: PUSH
95463: EMPTY
95464: LIST
95465: LIST
95466: PUSH
95467: LD_INT 5
95469: NEG
95470: PUSH
95471: LD_INT 3
95473: NEG
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: PUSH
95479: LD_INT 0
95481: PUSH
95482: LD_INT 3
95484: NEG
95485: PUSH
95486: EMPTY
95487: LIST
95488: LIST
95489: PUSH
95490: LD_INT 0
95492: PUSH
95493: LD_INT 4
95495: NEG
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: PUSH
95501: LD_INT 1
95503: PUSH
95504: LD_INT 3
95506: NEG
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: PUSH
95512: LD_INT 1
95514: PUSH
95515: LD_INT 2
95517: NEG
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: PUSH
95523: LD_INT 0
95525: PUSH
95526: LD_INT 2
95528: NEG
95529: PUSH
95530: EMPTY
95531: LIST
95532: LIST
95533: PUSH
95534: LD_INT 1
95536: NEG
95537: PUSH
95538: LD_INT 3
95540: NEG
95541: PUSH
95542: EMPTY
95543: LIST
95544: LIST
95545: PUSH
95546: LD_INT 1
95548: NEG
95549: PUSH
95550: LD_INT 4
95552: NEG
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: PUSH
95558: LD_INT 2
95560: PUSH
95561: LD_INT 2
95563: NEG
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PUSH
95569: LD_INT 2
95571: NEG
95572: PUSH
95573: LD_INT 4
95575: NEG
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: LD_INT 4
95583: PUSH
95584: LD_INT 0
95586: PUSH
95587: EMPTY
95588: LIST
95589: LIST
95590: PUSH
95591: LD_INT 4
95593: PUSH
95594: LD_INT 1
95596: NEG
95597: PUSH
95598: EMPTY
95599: LIST
95600: LIST
95601: PUSH
95602: LD_INT 5
95604: PUSH
95605: LD_INT 0
95607: PUSH
95608: EMPTY
95609: LIST
95610: LIST
95611: PUSH
95612: LD_INT 5
95614: PUSH
95615: LD_INT 1
95617: PUSH
95618: EMPTY
95619: LIST
95620: LIST
95621: PUSH
95622: LD_INT 4
95624: PUSH
95625: LD_INT 1
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PUSH
95632: LD_INT 3
95634: PUSH
95635: LD_INT 0
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: PUSH
95642: LD_INT 3
95644: PUSH
95645: LD_INT 1
95647: NEG
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: PUSH
95653: LD_INT 3
95655: PUSH
95656: LD_INT 2
95658: NEG
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 5
95666: PUSH
95667: LD_INT 2
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: PUSH
95674: LD_INT 3
95676: PUSH
95677: LD_INT 3
95679: PUSH
95680: EMPTY
95681: LIST
95682: LIST
95683: PUSH
95684: LD_INT 3
95686: PUSH
95687: LD_INT 2
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: PUSH
95694: LD_INT 4
95696: PUSH
95697: LD_INT 3
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: PUSH
95704: LD_INT 4
95706: PUSH
95707: LD_INT 4
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: PUSH
95714: LD_INT 3
95716: PUSH
95717: LD_INT 4
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: LD_INT 2
95726: PUSH
95727: LD_INT 3
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: LD_INT 2
95736: PUSH
95737: LD_INT 2
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 4
95746: PUSH
95747: LD_INT 2
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: LD_INT 2
95756: PUSH
95757: LD_INT 4
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: LD_INT 0
95766: PUSH
95767: LD_INT 4
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 0
95776: PUSH
95777: LD_INT 3
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 1
95786: PUSH
95787: LD_INT 4
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PUSH
95794: LD_INT 1
95796: PUSH
95797: LD_INT 5
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: PUSH
95804: LD_INT 0
95806: PUSH
95807: LD_INT 5
95809: PUSH
95810: EMPTY
95811: LIST
95812: LIST
95813: PUSH
95814: LD_INT 1
95816: NEG
95817: PUSH
95818: LD_INT 4
95820: PUSH
95821: EMPTY
95822: LIST
95823: LIST
95824: PUSH
95825: LD_INT 1
95827: NEG
95828: PUSH
95829: LD_INT 3
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: LD_INT 2
95838: PUSH
95839: LD_INT 5
95841: PUSH
95842: EMPTY
95843: LIST
95844: LIST
95845: PUSH
95846: LD_INT 2
95848: NEG
95849: PUSH
95850: LD_INT 3
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95904: LD_ADDR_VAR 0 34
95908: PUSH
95909: LD_INT 0
95911: PUSH
95912: LD_INT 4
95914: NEG
95915: PUSH
95916: EMPTY
95917: LIST
95918: LIST
95919: PUSH
95920: LD_INT 0
95922: PUSH
95923: LD_INT 5
95925: NEG
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 1
95933: PUSH
95934: LD_INT 4
95936: NEG
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: LD_INT 1
95944: PUSH
95945: LD_INT 3
95947: NEG
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 0
95955: PUSH
95956: LD_INT 3
95958: NEG
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 1
95966: NEG
95967: PUSH
95968: LD_INT 4
95970: NEG
95971: PUSH
95972: EMPTY
95973: LIST
95974: LIST
95975: PUSH
95976: LD_INT 1
95978: NEG
95979: PUSH
95980: LD_INT 5
95982: NEG
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: PUSH
95988: LD_INT 2
95990: PUSH
95991: LD_INT 3
95993: NEG
95994: PUSH
95995: EMPTY
95996: LIST
95997: LIST
95998: PUSH
95999: LD_INT 2
96001: NEG
96002: PUSH
96003: LD_INT 5
96005: NEG
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: LD_INT 3
96013: PUSH
96014: LD_INT 0
96016: PUSH
96017: EMPTY
96018: LIST
96019: LIST
96020: PUSH
96021: LD_INT 3
96023: PUSH
96024: LD_INT 1
96026: NEG
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: PUSH
96032: LD_INT 4
96034: PUSH
96035: LD_INT 0
96037: PUSH
96038: EMPTY
96039: LIST
96040: LIST
96041: PUSH
96042: LD_INT 4
96044: PUSH
96045: LD_INT 1
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 3
96054: PUSH
96055: LD_INT 1
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 2
96064: PUSH
96065: LD_INT 0
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: PUSH
96072: LD_INT 2
96074: PUSH
96075: LD_INT 1
96077: NEG
96078: PUSH
96079: EMPTY
96080: LIST
96081: LIST
96082: PUSH
96083: LD_INT 2
96085: PUSH
96086: LD_INT 2
96088: NEG
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 4
96096: PUSH
96097: LD_INT 2
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: PUSH
96104: LD_INT 4
96106: PUSH
96107: LD_INT 4
96109: PUSH
96110: EMPTY
96111: LIST
96112: LIST
96113: PUSH
96114: LD_INT 4
96116: PUSH
96117: LD_INT 3
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PUSH
96124: LD_INT 5
96126: PUSH
96127: LD_INT 4
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: PUSH
96134: LD_INT 5
96136: PUSH
96137: LD_INT 5
96139: PUSH
96140: EMPTY
96141: LIST
96142: LIST
96143: PUSH
96144: LD_INT 4
96146: PUSH
96147: LD_INT 5
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: PUSH
96154: LD_INT 3
96156: PUSH
96157: LD_INT 4
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: LD_INT 3
96166: PUSH
96167: LD_INT 3
96169: PUSH
96170: EMPTY
96171: LIST
96172: LIST
96173: PUSH
96174: LD_INT 5
96176: PUSH
96177: LD_INT 3
96179: PUSH
96180: EMPTY
96181: LIST
96182: LIST
96183: PUSH
96184: LD_INT 3
96186: PUSH
96187: LD_INT 5
96189: PUSH
96190: EMPTY
96191: LIST
96192: LIST
96193: PUSH
96194: LD_INT 0
96196: PUSH
96197: LD_INT 3
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 0
96206: PUSH
96207: LD_INT 2
96209: PUSH
96210: EMPTY
96211: LIST
96212: LIST
96213: PUSH
96214: LD_INT 1
96216: PUSH
96217: LD_INT 3
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: LD_INT 1
96226: PUSH
96227: LD_INT 4
96229: PUSH
96230: EMPTY
96231: LIST
96232: LIST
96233: PUSH
96234: LD_INT 0
96236: PUSH
96237: LD_INT 4
96239: PUSH
96240: EMPTY
96241: LIST
96242: LIST
96243: PUSH
96244: LD_INT 1
96246: NEG
96247: PUSH
96248: LD_INT 3
96250: PUSH
96251: EMPTY
96252: LIST
96253: LIST
96254: PUSH
96255: LD_INT 1
96257: NEG
96258: PUSH
96259: LD_INT 2
96261: PUSH
96262: EMPTY
96263: LIST
96264: LIST
96265: PUSH
96266: LD_INT 2
96268: PUSH
96269: LD_INT 4
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 2
96278: NEG
96279: PUSH
96280: LD_INT 2
96282: PUSH
96283: EMPTY
96284: LIST
96285: LIST
96286: PUSH
96287: LD_INT 4
96289: NEG
96290: PUSH
96291: LD_INT 0
96293: PUSH
96294: EMPTY
96295: LIST
96296: LIST
96297: PUSH
96298: LD_INT 4
96300: NEG
96301: PUSH
96302: LD_INT 1
96304: NEG
96305: PUSH
96306: EMPTY
96307: LIST
96308: LIST
96309: PUSH
96310: LD_INT 3
96312: NEG
96313: PUSH
96314: LD_INT 0
96316: PUSH
96317: EMPTY
96318: LIST
96319: LIST
96320: PUSH
96321: LD_INT 3
96323: NEG
96324: PUSH
96325: LD_INT 1
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: LD_INT 4
96334: NEG
96335: PUSH
96336: LD_INT 1
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 5
96345: NEG
96346: PUSH
96347: LD_INT 0
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: LD_INT 5
96356: NEG
96357: PUSH
96358: LD_INT 1
96360: NEG
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: PUSH
96366: LD_INT 5
96368: NEG
96369: PUSH
96370: LD_INT 2
96372: NEG
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: PUSH
96378: LD_INT 3
96380: NEG
96381: PUSH
96382: LD_INT 2
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: PUSH
96389: EMPTY
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: ST_TO_ADDR
// end ; end ;
96436: GO 96439
96438: POP
// case btype of b_depot , b_warehouse :
96439: LD_VAR 0 1
96443: PUSH
96444: LD_INT 0
96446: DOUBLE
96447: EQUAL
96448: IFTRUE 96458
96450: LD_INT 1
96452: DOUBLE
96453: EQUAL
96454: IFTRUE 96458
96456: GO 96659
96458: POP
// case nation of nation_american :
96459: LD_VAR 0 5
96463: PUSH
96464: LD_INT 1
96466: DOUBLE
96467: EQUAL
96468: IFTRUE 96472
96470: GO 96528
96472: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
96473: LD_ADDR_VAR 0 9
96477: PUSH
96478: LD_VAR 0 11
96482: PUSH
96483: LD_VAR 0 12
96487: PUSH
96488: LD_VAR 0 13
96492: PUSH
96493: LD_VAR 0 14
96497: PUSH
96498: LD_VAR 0 15
96502: PUSH
96503: LD_VAR 0 16
96507: PUSH
96508: EMPTY
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: PUSH
96516: LD_VAR 0 4
96520: PUSH
96521: LD_INT 1
96523: PLUS
96524: ARRAY
96525: ST_TO_ADDR
96526: GO 96657
96528: LD_INT 2
96530: DOUBLE
96531: EQUAL
96532: IFTRUE 96536
96534: GO 96592
96536: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
96537: LD_ADDR_VAR 0 9
96541: PUSH
96542: LD_VAR 0 17
96546: PUSH
96547: LD_VAR 0 18
96551: PUSH
96552: LD_VAR 0 19
96556: PUSH
96557: LD_VAR 0 20
96561: PUSH
96562: LD_VAR 0 21
96566: PUSH
96567: LD_VAR 0 22
96571: PUSH
96572: EMPTY
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: PUSH
96580: LD_VAR 0 4
96584: PUSH
96585: LD_INT 1
96587: PLUS
96588: ARRAY
96589: ST_TO_ADDR
96590: GO 96657
96592: LD_INT 3
96594: DOUBLE
96595: EQUAL
96596: IFTRUE 96600
96598: GO 96656
96600: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96601: LD_ADDR_VAR 0 9
96605: PUSH
96606: LD_VAR 0 23
96610: PUSH
96611: LD_VAR 0 24
96615: PUSH
96616: LD_VAR 0 25
96620: PUSH
96621: LD_VAR 0 26
96625: PUSH
96626: LD_VAR 0 27
96630: PUSH
96631: LD_VAR 0 28
96635: PUSH
96636: EMPTY
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: PUSH
96644: LD_VAR 0 4
96648: PUSH
96649: LD_INT 1
96651: PLUS
96652: ARRAY
96653: ST_TO_ADDR
96654: GO 96657
96656: POP
96657: GO 97212
96659: LD_INT 2
96661: DOUBLE
96662: EQUAL
96663: IFTRUE 96673
96665: LD_INT 3
96667: DOUBLE
96668: EQUAL
96669: IFTRUE 96673
96671: GO 96729
96673: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96674: LD_ADDR_VAR 0 9
96678: PUSH
96679: LD_VAR 0 29
96683: PUSH
96684: LD_VAR 0 30
96688: PUSH
96689: LD_VAR 0 31
96693: PUSH
96694: LD_VAR 0 32
96698: PUSH
96699: LD_VAR 0 33
96703: PUSH
96704: LD_VAR 0 34
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: PUSH
96717: LD_VAR 0 4
96721: PUSH
96722: LD_INT 1
96724: PLUS
96725: ARRAY
96726: ST_TO_ADDR
96727: GO 97212
96729: LD_INT 16
96731: DOUBLE
96732: EQUAL
96733: IFTRUE 96791
96735: LD_INT 17
96737: DOUBLE
96738: EQUAL
96739: IFTRUE 96791
96741: LD_INT 18
96743: DOUBLE
96744: EQUAL
96745: IFTRUE 96791
96747: LD_INT 19
96749: DOUBLE
96750: EQUAL
96751: IFTRUE 96791
96753: LD_INT 22
96755: DOUBLE
96756: EQUAL
96757: IFTRUE 96791
96759: LD_INT 20
96761: DOUBLE
96762: EQUAL
96763: IFTRUE 96791
96765: LD_INT 21
96767: DOUBLE
96768: EQUAL
96769: IFTRUE 96791
96771: LD_INT 23
96773: DOUBLE
96774: EQUAL
96775: IFTRUE 96791
96777: LD_INT 24
96779: DOUBLE
96780: EQUAL
96781: IFTRUE 96791
96783: LD_INT 25
96785: DOUBLE
96786: EQUAL
96787: IFTRUE 96791
96789: GO 96847
96791: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96792: LD_ADDR_VAR 0 9
96796: PUSH
96797: LD_VAR 0 35
96801: PUSH
96802: LD_VAR 0 36
96806: PUSH
96807: LD_VAR 0 37
96811: PUSH
96812: LD_VAR 0 38
96816: PUSH
96817: LD_VAR 0 39
96821: PUSH
96822: LD_VAR 0 40
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: PUSH
96835: LD_VAR 0 4
96839: PUSH
96840: LD_INT 1
96842: PLUS
96843: ARRAY
96844: ST_TO_ADDR
96845: GO 97212
96847: LD_INT 6
96849: DOUBLE
96850: EQUAL
96851: IFTRUE 96903
96853: LD_INT 7
96855: DOUBLE
96856: EQUAL
96857: IFTRUE 96903
96859: LD_INT 8
96861: DOUBLE
96862: EQUAL
96863: IFTRUE 96903
96865: LD_INT 13
96867: DOUBLE
96868: EQUAL
96869: IFTRUE 96903
96871: LD_INT 12
96873: DOUBLE
96874: EQUAL
96875: IFTRUE 96903
96877: LD_INT 15
96879: DOUBLE
96880: EQUAL
96881: IFTRUE 96903
96883: LD_INT 11
96885: DOUBLE
96886: EQUAL
96887: IFTRUE 96903
96889: LD_INT 14
96891: DOUBLE
96892: EQUAL
96893: IFTRUE 96903
96895: LD_INT 10
96897: DOUBLE
96898: EQUAL
96899: IFTRUE 96903
96901: GO 96959
96903: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96904: LD_ADDR_VAR 0 9
96908: PUSH
96909: LD_VAR 0 41
96913: PUSH
96914: LD_VAR 0 42
96918: PUSH
96919: LD_VAR 0 43
96923: PUSH
96924: LD_VAR 0 44
96928: PUSH
96929: LD_VAR 0 45
96933: PUSH
96934: LD_VAR 0 46
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: PUSH
96947: LD_VAR 0 4
96951: PUSH
96952: LD_INT 1
96954: PLUS
96955: ARRAY
96956: ST_TO_ADDR
96957: GO 97212
96959: LD_INT 36
96961: DOUBLE
96962: EQUAL
96963: IFTRUE 96967
96965: GO 97023
96967: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96968: LD_ADDR_VAR 0 9
96972: PUSH
96973: LD_VAR 0 47
96977: PUSH
96978: LD_VAR 0 48
96982: PUSH
96983: LD_VAR 0 49
96987: PUSH
96988: LD_VAR 0 50
96992: PUSH
96993: LD_VAR 0 51
96997: PUSH
96998: LD_VAR 0 52
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: LIST
97007: LIST
97008: LIST
97009: LIST
97010: PUSH
97011: LD_VAR 0 4
97015: PUSH
97016: LD_INT 1
97018: PLUS
97019: ARRAY
97020: ST_TO_ADDR
97021: GO 97212
97023: LD_INT 4
97025: DOUBLE
97026: EQUAL
97027: IFTRUE 97049
97029: LD_INT 5
97031: DOUBLE
97032: EQUAL
97033: IFTRUE 97049
97035: LD_INT 34
97037: DOUBLE
97038: EQUAL
97039: IFTRUE 97049
97041: LD_INT 37
97043: DOUBLE
97044: EQUAL
97045: IFTRUE 97049
97047: GO 97105
97049: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97050: LD_ADDR_VAR 0 9
97054: PUSH
97055: LD_VAR 0 53
97059: PUSH
97060: LD_VAR 0 54
97064: PUSH
97065: LD_VAR 0 55
97069: PUSH
97070: LD_VAR 0 56
97074: PUSH
97075: LD_VAR 0 57
97079: PUSH
97080: LD_VAR 0 58
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: PUSH
97093: LD_VAR 0 4
97097: PUSH
97098: LD_INT 1
97100: PLUS
97101: ARRAY
97102: ST_TO_ADDR
97103: GO 97212
97105: LD_INT 31
97107: DOUBLE
97108: EQUAL
97109: IFTRUE 97155
97111: LD_INT 32
97113: DOUBLE
97114: EQUAL
97115: IFTRUE 97155
97117: LD_INT 33
97119: DOUBLE
97120: EQUAL
97121: IFTRUE 97155
97123: LD_INT 27
97125: DOUBLE
97126: EQUAL
97127: IFTRUE 97155
97129: LD_INT 26
97131: DOUBLE
97132: EQUAL
97133: IFTRUE 97155
97135: LD_INT 28
97137: DOUBLE
97138: EQUAL
97139: IFTRUE 97155
97141: LD_INT 29
97143: DOUBLE
97144: EQUAL
97145: IFTRUE 97155
97147: LD_INT 30
97149: DOUBLE
97150: EQUAL
97151: IFTRUE 97155
97153: GO 97211
97155: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
97156: LD_ADDR_VAR 0 9
97160: PUSH
97161: LD_VAR 0 59
97165: PUSH
97166: LD_VAR 0 60
97170: PUSH
97171: LD_VAR 0 61
97175: PUSH
97176: LD_VAR 0 62
97180: PUSH
97181: LD_VAR 0 63
97185: PUSH
97186: LD_VAR 0 64
97190: PUSH
97191: EMPTY
97192: LIST
97193: LIST
97194: LIST
97195: LIST
97196: LIST
97197: LIST
97198: PUSH
97199: LD_VAR 0 4
97203: PUSH
97204: LD_INT 1
97206: PLUS
97207: ARRAY
97208: ST_TO_ADDR
97209: GO 97212
97211: POP
// temp_list2 = [ ] ;
97212: LD_ADDR_VAR 0 10
97216: PUSH
97217: EMPTY
97218: ST_TO_ADDR
// for i in temp_list do
97219: LD_ADDR_VAR 0 8
97223: PUSH
97224: LD_VAR 0 9
97228: PUSH
97229: FOR_IN
97230: IFFALSE 97282
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97232: LD_ADDR_VAR 0 10
97236: PUSH
97237: LD_VAR 0 10
97241: PUSH
97242: LD_VAR 0 8
97246: PUSH
97247: LD_INT 1
97249: ARRAY
97250: PUSH
97251: LD_VAR 0 2
97255: PLUS
97256: PUSH
97257: LD_VAR 0 8
97261: PUSH
97262: LD_INT 2
97264: ARRAY
97265: PUSH
97266: LD_VAR 0 3
97270: PLUS
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: EMPTY
97277: LIST
97278: ADD
97279: ST_TO_ADDR
97280: GO 97229
97282: POP
97283: POP
// result = temp_list2 ;
97284: LD_ADDR_VAR 0 7
97288: PUSH
97289: LD_VAR 0 10
97293: ST_TO_ADDR
// end ;
97294: LD_VAR 0 7
97298: RET
// export function EnemyInRange ( unit , dist ) ; begin
97299: LD_INT 0
97301: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
97302: LD_ADDR_VAR 0 3
97306: PUSH
97307: LD_VAR 0 1
97311: PPUSH
97312: CALL_OW 255
97316: PPUSH
97317: LD_VAR 0 1
97321: PPUSH
97322: CALL_OW 250
97326: PPUSH
97327: LD_VAR 0 1
97331: PPUSH
97332: CALL_OW 251
97336: PPUSH
97337: LD_VAR 0 2
97341: PPUSH
97342: CALL 71403 0 4
97346: PUSH
97347: LD_INT 4
97349: ARRAY
97350: ST_TO_ADDR
// end ;
97351: LD_VAR 0 3
97355: RET
// export function PlayerSeeMe ( unit ) ; begin
97356: LD_INT 0
97358: PPUSH
// result := See ( your_side , unit ) ;
97359: LD_ADDR_VAR 0 2
97363: PUSH
97364: LD_OWVAR 2
97368: PPUSH
97369: LD_VAR 0 1
97373: PPUSH
97374: CALL_OW 292
97378: ST_TO_ADDR
// end ;
97379: LD_VAR 0 2
97383: RET
// export function ReverseDir ( unit ) ; begin
97384: LD_INT 0
97386: PPUSH
// if not unit then
97387: LD_VAR 0 1
97391: NOT
97392: IFFALSE 97396
// exit ;
97394: GO 97442
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
97396: LD_ADDR_VAR 0 2
97400: PUSH
97401: LD_INT 3
97403: PUSH
97404: LD_INT 4
97406: PUSH
97407: LD_INT 5
97409: PUSH
97410: LD_INT 0
97412: PUSH
97413: LD_INT 1
97415: PUSH
97416: LD_INT 2
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: PUSH
97427: LD_VAR 0 1
97431: PPUSH
97432: CALL_OW 254
97436: PUSH
97437: LD_INT 1
97439: PLUS
97440: ARRAY
97441: ST_TO_ADDR
// end ;
97442: LD_VAR 0 2
97446: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
97447: LD_INT 0
97449: PPUSH
97450: PPUSH
97451: PPUSH
97452: PPUSH
97453: PPUSH
// if not hexes then
97454: LD_VAR 0 2
97458: NOT
97459: IFFALSE 97463
// exit ;
97461: GO 97611
// dist := 9999 ;
97463: LD_ADDR_VAR 0 5
97467: PUSH
97468: LD_INT 9999
97470: ST_TO_ADDR
// for i = 1 to hexes do
97471: LD_ADDR_VAR 0 4
97475: PUSH
97476: DOUBLE
97477: LD_INT 1
97479: DEC
97480: ST_TO_ADDR
97481: LD_VAR 0 2
97485: PUSH
97486: FOR_TO
97487: IFFALSE 97599
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97489: LD_VAR 0 1
97493: PPUSH
97494: LD_VAR 0 2
97498: PUSH
97499: LD_VAR 0 4
97503: ARRAY
97504: PUSH
97505: LD_INT 1
97507: ARRAY
97508: PPUSH
97509: LD_VAR 0 2
97513: PUSH
97514: LD_VAR 0 4
97518: ARRAY
97519: PUSH
97520: LD_INT 2
97522: ARRAY
97523: PPUSH
97524: CALL_OW 297
97528: PUSH
97529: LD_VAR 0 5
97533: LESS
97534: IFFALSE 97597
// begin hex := hexes [ i ] ;
97536: LD_ADDR_VAR 0 7
97540: PUSH
97541: LD_VAR 0 2
97545: PUSH
97546: LD_VAR 0 4
97550: ARRAY
97551: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97552: LD_ADDR_VAR 0 5
97556: PUSH
97557: LD_VAR 0 1
97561: PPUSH
97562: LD_VAR 0 2
97566: PUSH
97567: LD_VAR 0 4
97571: ARRAY
97572: PUSH
97573: LD_INT 1
97575: ARRAY
97576: PPUSH
97577: LD_VAR 0 2
97581: PUSH
97582: LD_VAR 0 4
97586: ARRAY
97587: PUSH
97588: LD_INT 2
97590: ARRAY
97591: PPUSH
97592: CALL_OW 297
97596: ST_TO_ADDR
// end ; end ;
97597: GO 97486
97599: POP
97600: POP
// result := hex ;
97601: LD_ADDR_VAR 0 3
97605: PUSH
97606: LD_VAR 0 7
97610: ST_TO_ADDR
// end ;
97611: LD_VAR 0 3
97615: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97616: LD_INT 0
97618: PPUSH
97619: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97620: LD_VAR 0 1
97624: NOT
97625: PUSH
97626: LD_VAR 0 1
97630: PUSH
97631: LD_INT 21
97633: PUSH
97634: LD_INT 2
97636: PUSH
97637: EMPTY
97638: LIST
97639: LIST
97640: PUSH
97641: LD_INT 23
97643: PUSH
97644: LD_INT 2
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: PUSH
97651: EMPTY
97652: LIST
97653: LIST
97654: PPUSH
97655: CALL_OW 69
97659: IN
97660: NOT
97661: OR
97662: IFFALSE 97666
// exit ;
97664: GO 97713
// for i = 1 to 3 do
97666: LD_ADDR_VAR 0 3
97670: PUSH
97671: DOUBLE
97672: LD_INT 1
97674: DEC
97675: ST_TO_ADDR
97676: LD_INT 3
97678: PUSH
97679: FOR_TO
97680: IFFALSE 97711
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97682: LD_VAR 0 1
97686: PPUSH
97687: CALL_OW 250
97691: PPUSH
97692: LD_VAR 0 1
97696: PPUSH
97697: CALL_OW 251
97701: PPUSH
97702: LD_INT 1
97704: PPUSH
97705: CALL_OW 453
97709: GO 97679
97711: POP
97712: POP
// end ;
97713: LD_VAR 0 2
97717: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97718: LD_INT 0
97720: PPUSH
97721: PPUSH
97722: PPUSH
97723: PPUSH
97724: PPUSH
97725: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97726: LD_VAR 0 1
97730: NOT
97731: PUSH
97732: LD_VAR 0 2
97736: NOT
97737: OR
97738: PUSH
97739: LD_VAR 0 1
97743: PPUSH
97744: CALL_OW 314
97748: OR
97749: IFFALSE 97753
// exit ;
97751: GO 98194
// x := GetX ( enemy_unit ) ;
97753: LD_ADDR_VAR 0 7
97757: PUSH
97758: LD_VAR 0 2
97762: PPUSH
97763: CALL_OW 250
97767: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97768: LD_ADDR_VAR 0 8
97772: PUSH
97773: LD_VAR 0 2
97777: PPUSH
97778: CALL_OW 251
97782: ST_TO_ADDR
// if not x or not y then
97783: LD_VAR 0 7
97787: NOT
97788: PUSH
97789: LD_VAR 0 8
97793: NOT
97794: OR
97795: IFFALSE 97799
// exit ;
97797: GO 98194
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97799: LD_ADDR_VAR 0 6
97803: PUSH
97804: LD_VAR 0 7
97808: PPUSH
97809: LD_INT 0
97811: PPUSH
97812: LD_INT 4
97814: PPUSH
97815: CALL_OW 272
97819: PUSH
97820: LD_VAR 0 8
97824: PPUSH
97825: LD_INT 0
97827: PPUSH
97828: LD_INT 4
97830: PPUSH
97831: CALL_OW 273
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: PUSH
97840: LD_VAR 0 7
97844: PPUSH
97845: LD_INT 1
97847: PPUSH
97848: LD_INT 4
97850: PPUSH
97851: CALL_OW 272
97855: PUSH
97856: LD_VAR 0 8
97860: PPUSH
97861: LD_INT 1
97863: PPUSH
97864: LD_INT 4
97866: PPUSH
97867: CALL_OW 273
97871: PUSH
97872: EMPTY
97873: LIST
97874: LIST
97875: PUSH
97876: LD_VAR 0 7
97880: PPUSH
97881: LD_INT 2
97883: PPUSH
97884: LD_INT 4
97886: PPUSH
97887: CALL_OW 272
97891: PUSH
97892: LD_VAR 0 8
97896: PPUSH
97897: LD_INT 2
97899: PPUSH
97900: LD_INT 4
97902: PPUSH
97903: CALL_OW 273
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PUSH
97912: LD_VAR 0 7
97916: PPUSH
97917: LD_INT 3
97919: PPUSH
97920: LD_INT 4
97922: PPUSH
97923: CALL_OW 272
97927: PUSH
97928: LD_VAR 0 8
97932: PPUSH
97933: LD_INT 3
97935: PPUSH
97936: LD_INT 4
97938: PPUSH
97939: CALL_OW 273
97943: PUSH
97944: EMPTY
97945: LIST
97946: LIST
97947: PUSH
97948: LD_VAR 0 7
97952: PPUSH
97953: LD_INT 4
97955: PPUSH
97956: LD_INT 4
97958: PPUSH
97959: CALL_OW 272
97963: PUSH
97964: LD_VAR 0 8
97968: PPUSH
97969: LD_INT 4
97971: PPUSH
97972: LD_INT 4
97974: PPUSH
97975: CALL_OW 273
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: PUSH
97984: LD_VAR 0 7
97988: PPUSH
97989: LD_INT 5
97991: PPUSH
97992: LD_INT 4
97994: PPUSH
97995: CALL_OW 272
97999: PUSH
98000: LD_VAR 0 8
98004: PPUSH
98005: LD_INT 5
98007: PPUSH
98008: LD_INT 4
98010: PPUSH
98011: CALL_OW 273
98015: PUSH
98016: EMPTY
98017: LIST
98018: LIST
98019: PUSH
98020: EMPTY
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: ST_TO_ADDR
// for i = tmp downto 1 do
98028: LD_ADDR_VAR 0 4
98032: PUSH
98033: DOUBLE
98034: LD_VAR 0 6
98038: INC
98039: ST_TO_ADDR
98040: LD_INT 1
98042: PUSH
98043: FOR_DOWNTO
98044: IFFALSE 98145
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98046: LD_VAR 0 6
98050: PUSH
98051: LD_VAR 0 4
98055: ARRAY
98056: PUSH
98057: LD_INT 1
98059: ARRAY
98060: PPUSH
98061: LD_VAR 0 6
98065: PUSH
98066: LD_VAR 0 4
98070: ARRAY
98071: PUSH
98072: LD_INT 2
98074: ARRAY
98075: PPUSH
98076: CALL_OW 488
98080: NOT
98081: PUSH
98082: LD_VAR 0 6
98086: PUSH
98087: LD_VAR 0 4
98091: ARRAY
98092: PUSH
98093: LD_INT 1
98095: ARRAY
98096: PPUSH
98097: LD_VAR 0 6
98101: PUSH
98102: LD_VAR 0 4
98106: ARRAY
98107: PUSH
98108: LD_INT 2
98110: ARRAY
98111: PPUSH
98112: CALL_OW 428
98116: PUSH
98117: LD_INT 0
98119: NONEQUAL
98120: OR
98121: IFFALSE 98143
// tmp := Delete ( tmp , i ) ;
98123: LD_ADDR_VAR 0 6
98127: PUSH
98128: LD_VAR 0 6
98132: PPUSH
98133: LD_VAR 0 4
98137: PPUSH
98138: CALL_OW 3
98142: ST_TO_ADDR
98143: GO 98043
98145: POP
98146: POP
// j := GetClosestHex ( unit , tmp ) ;
98147: LD_ADDR_VAR 0 5
98151: PUSH
98152: LD_VAR 0 1
98156: PPUSH
98157: LD_VAR 0 6
98161: PPUSH
98162: CALL 97447 0 2
98166: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98167: LD_VAR 0 1
98171: PPUSH
98172: LD_VAR 0 5
98176: PUSH
98177: LD_INT 1
98179: ARRAY
98180: PPUSH
98181: LD_VAR 0 5
98185: PUSH
98186: LD_INT 2
98188: ARRAY
98189: PPUSH
98190: CALL_OW 111
// end ;
98194: LD_VAR 0 3
98198: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98199: LD_INT 0
98201: PPUSH
98202: PPUSH
98203: PPUSH
// uc_side = 0 ;
98204: LD_ADDR_OWVAR 20
98208: PUSH
98209: LD_INT 0
98211: ST_TO_ADDR
// uc_nation = 0 ;
98212: LD_ADDR_OWVAR 21
98216: PUSH
98217: LD_INT 0
98219: ST_TO_ADDR
// InitHc ;
98220: CALL_OW 19
// InitVc ;
98224: CALL_OW 20
// if mastodonts then
98228: LD_VAR 0 6
98232: IFFALSE 98299
// for i = 1 to mastodonts do
98234: LD_ADDR_VAR 0 11
98238: PUSH
98239: DOUBLE
98240: LD_INT 1
98242: DEC
98243: ST_TO_ADDR
98244: LD_VAR 0 6
98248: PUSH
98249: FOR_TO
98250: IFFALSE 98297
// begin vc_chassis := 31 ;
98252: LD_ADDR_OWVAR 37
98256: PUSH
98257: LD_INT 31
98259: ST_TO_ADDR
// vc_control := control_rider ;
98260: LD_ADDR_OWVAR 38
98264: PUSH
98265: LD_INT 4
98267: ST_TO_ADDR
// animal := CreateVehicle ;
98268: LD_ADDR_VAR 0 12
98272: PUSH
98273: CALL_OW 45
98277: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98278: LD_VAR 0 12
98282: PPUSH
98283: LD_VAR 0 8
98287: PPUSH
98288: LD_INT 0
98290: PPUSH
98291: CALL 105044 0 3
// end ;
98295: GO 98249
98297: POP
98298: POP
// if horses then
98299: LD_VAR 0 5
98303: IFFALSE 98370
// for i = 1 to horses do
98305: LD_ADDR_VAR 0 11
98309: PUSH
98310: DOUBLE
98311: LD_INT 1
98313: DEC
98314: ST_TO_ADDR
98315: LD_VAR 0 5
98319: PUSH
98320: FOR_TO
98321: IFFALSE 98368
// begin hc_class := 21 ;
98323: LD_ADDR_OWVAR 28
98327: PUSH
98328: LD_INT 21
98330: ST_TO_ADDR
// hc_gallery :=  ;
98331: LD_ADDR_OWVAR 33
98335: PUSH
98336: LD_STRING 
98338: ST_TO_ADDR
// animal := CreateHuman ;
98339: LD_ADDR_VAR 0 12
98343: PUSH
98344: CALL_OW 44
98348: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98349: LD_VAR 0 12
98353: PPUSH
98354: LD_VAR 0 8
98358: PPUSH
98359: LD_INT 0
98361: PPUSH
98362: CALL 105044 0 3
// end ;
98366: GO 98320
98368: POP
98369: POP
// if birds then
98370: LD_VAR 0 1
98374: IFFALSE 98441
// for i = 1 to birds do
98376: LD_ADDR_VAR 0 11
98380: PUSH
98381: DOUBLE
98382: LD_INT 1
98384: DEC
98385: ST_TO_ADDR
98386: LD_VAR 0 1
98390: PUSH
98391: FOR_TO
98392: IFFALSE 98439
// begin hc_class = 18 ;
98394: LD_ADDR_OWVAR 28
98398: PUSH
98399: LD_INT 18
98401: ST_TO_ADDR
// hc_gallery =  ;
98402: LD_ADDR_OWVAR 33
98406: PUSH
98407: LD_STRING 
98409: ST_TO_ADDR
// animal := CreateHuman ;
98410: LD_ADDR_VAR 0 12
98414: PUSH
98415: CALL_OW 44
98419: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98420: LD_VAR 0 12
98424: PPUSH
98425: LD_VAR 0 8
98429: PPUSH
98430: LD_INT 0
98432: PPUSH
98433: CALL 105044 0 3
// end ;
98437: GO 98391
98439: POP
98440: POP
// if tigers then
98441: LD_VAR 0 2
98445: IFFALSE 98529
// for i = 1 to tigers do
98447: LD_ADDR_VAR 0 11
98451: PUSH
98452: DOUBLE
98453: LD_INT 1
98455: DEC
98456: ST_TO_ADDR
98457: LD_VAR 0 2
98461: PUSH
98462: FOR_TO
98463: IFFALSE 98527
// begin hc_class = class_tiger ;
98465: LD_ADDR_OWVAR 28
98469: PUSH
98470: LD_INT 14
98472: ST_TO_ADDR
// hc_gallery =  ;
98473: LD_ADDR_OWVAR 33
98477: PUSH
98478: LD_STRING 
98480: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98481: LD_ADDR_OWVAR 35
98485: PUSH
98486: LD_INT 7
98488: NEG
98489: PPUSH
98490: LD_INT 7
98492: PPUSH
98493: CALL_OW 12
98497: ST_TO_ADDR
// animal := CreateHuman ;
98498: LD_ADDR_VAR 0 12
98502: PUSH
98503: CALL_OW 44
98507: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98508: LD_VAR 0 12
98512: PPUSH
98513: LD_VAR 0 8
98517: PPUSH
98518: LD_INT 0
98520: PPUSH
98521: CALL 105044 0 3
// end ;
98525: GO 98462
98527: POP
98528: POP
// if apemans then
98529: LD_VAR 0 3
98533: IFFALSE 98656
// for i = 1 to apemans do
98535: LD_ADDR_VAR 0 11
98539: PUSH
98540: DOUBLE
98541: LD_INT 1
98543: DEC
98544: ST_TO_ADDR
98545: LD_VAR 0 3
98549: PUSH
98550: FOR_TO
98551: IFFALSE 98654
// begin hc_class = class_apeman ;
98553: LD_ADDR_OWVAR 28
98557: PUSH
98558: LD_INT 12
98560: ST_TO_ADDR
// hc_gallery =  ;
98561: LD_ADDR_OWVAR 33
98565: PUSH
98566: LD_STRING 
98568: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98569: LD_ADDR_OWVAR 35
98573: PUSH
98574: LD_INT 5
98576: NEG
98577: PPUSH
98578: LD_INT 5
98580: PPUSH
98581: CALL_OW 12
98585: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98586: LD_ADDR_OWVAR 31
98590: PUSH
98591: LD_INT 1
98593: PPUSH
98594: LD_INT 3
98596: PPUSH
98597: CALL_OW 12
98601: PUSH
98602: LD_INT 1
98604: PPUSH
98605: LD_INT 3
98607: PPUSH
98608: CALL_OW 12
98612: PUSH
98613: LD_INT 0
98615: PUSH
98616: LD_INT 0
98618: PUSH
98619: EMPTY
98620: LIST
98621: LIST
98622: LIST
98623: LIST
98624: ST_TO_ADDR
// animal := CreateHuman ;
98625: LD_ADDR_VAR 0 12
98629: PUSH
98630: CALL_OW 44
98634: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98635: LD_VAR 0 12
98639: PPUSH
98640: LD_VAR 0 8
98644: PPUSH
98645: LD_INT 0
98647: PPUSH
98648: CALL 105044 0 3
// end ;
98652: GO 98550
98654: POP
98655: POP
// if enchidnas then
98656: LD_VAR 0 4
98660: IFFALSE 98727
// for i = 1 to enchidnas do
98662: LD_ADDR_VAR 0 11
98666: PUSH
98667: DOUBLE
98668: LD_INT 1
98670: DEC
98671: ST_TO_ADDR
98672: LD_VAR 0 4
98676: PUSH
98677: FOR_TO
98678: IFFALSE 98725
// begin hc_class = 13 ;
98680: LD_ADDR_OWVAR 28
98684: PUSH
98685: LD_INT 13
98687: ST_TO_ADDR
// hc_gallery =  ;
98688: LD_ADDR_OWVAR 33
98692: PUSH
98693: LD_STRING 
98695: ST_TO_ADDR
// animal := CreateHuman ;
98696: LD_ADDR_VAR 0 12
98700: PUSH
98701: CALL_OW 44
98705: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98706: LD_VAR 0 12
98710: PPUSH
98711: LD_VAR 0 8
98715: PPUSH
98716: LD_INT 0
98718: PPUSH
98719: CALL 105044 0 3
// end ;
98723: GO 98677
98725: POP
98726: POP
// if fishes then
98727: LD_VAR 0 7
98731: IFFALSE 98798
// for i = 1 to fishes do
98733: LD_ADDR_VAR 0 11
98737: PUSH
98738: DOUBLE
98739: LD_INT 1
98741: DEC
98742: ST_TO_ADDR
98743: LD_VAR 0 7
98747: PUSH
98748: FOR_TO
98749: IFFALSE 98796
// begin hc_class = 20 ;
98751: LD_ADDR_OWVAR 28
98755: PUSH
98756: LD_INT 20
98758: ST_TO_ADDR
// hc_gallery =  ;
98759: LD_ADDR_OWVAR 33
98763: PUSH
98764: LD_STRING 
98766: ST_TO_ADDR
// animal := CreateHuman ;
98767: LD_ADDR_VAR 0 12
98771: PUSH
98772: CALL_OW 44
98776: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98777: LD_VAR 0 12
98781: PPUSH
98782: LD_VAR 0 9
98786: PPUSH
98787: LD_INT 0
98789: PPUSH
98790: CALL 105044 0 3
// end ;
98794: GO 98748
98796: POP
98797: POP
// end ;
98798: LD_VAR 0 10
98802: RET
// export function WantHeal ( sci , unit ) ; begin
98803: LD_INT 0
98805: PPUSH
// if GetTaskList ( sci ) > 0 then
98806: LD_VAR 0 1
98810: PPUSH
98811: CALL_OW 437
98815: PUSH
98816: LD_INT 0
98818: GREATER
98819: IFFALSE 98889
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98821: LD_VAR 0 1
98825: PPUSH
98826: CALL_OW 437
98830: PUSH
98831: LD_INT 1
98833: ARRAY
98834: PUSH
98835: LD_INT 1
98837: ARRAY
98838: PUSH
98839: LD_STRING l
98841: EQUAL
98842: PUSH
98843: LD_VAR 0 1
98847: PPUSH
98848: CALL_OW 437
98852: PUSH
98853: LD_INT 1
98855: ARRAY
98856: PUSH
98857: LD_INT 4
98859: ARRAY
98860: PUSH
98861: LD_VAR 0 2
98865: EQUAL
98866: AND
98867: IFFALSE 98879
// result := true else
98869: LD_ADDR_VAR 0 3
98873: PUSH
98874: LD_INT 1
98876: ST_TO_ADDR
98877: GO 98887
// result := false ;
98879: LD_ADDR_VAR 0 3
98883: PUSH
98884: LD_INT 0
98886: ST_TO_ADDR
// end else
98887: GO 98897
// result := false ;
98889: LD_ADDR_VAR 0 3
98893: PUSH
98894: LD_INT 0
98896: ST_TO_ADDR
// end ;
98897: LD_VAR 0 3
98901: RET
// export function HealTarget ( sci ) ; begin
98902: LD_INT 0
98904: PPUSH
// if not sci then
98905: LD_VAR 0 1
98909: NOT
98910: IFFALSE 98914
// exit ;
98912: GO 98979
// result := 0 ;
98914: LD_ADDR_VAR 0 2
98918: PUSH
98919: LD_INT 0
98921: ST_TO_ADDR
// if GetTaskList ( sci ) then
98922: LD_VAR 0 1
98926: PPUSH
98927: CALL_OW 437
98931: IFFALSE 98979
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98933: LD_VAR 0 1
98937: PPUSH
98938: CALL_OW 437
98942: PUSH
98943: LD_INT 1
98945: ARRAY
98946: PUSH
98947: LD_INT 1
98949: ARRAY
98950: PUSH
98951: LD_STRING l
98953: EQUAL
98954: IFFALSE 98979
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98956: LD_ADDR_VAR 0 2
98960: PUSH
98961: LD_VAR 0 1
98965: PPUSH
98966: CALL_OW 437
98970: PUSH
98971: LD_INT 1
98973: ARRAY
98974: PUSH
98975: LD_INT 4
98977: ARRAY
98978: ST_TO_ADDR
// end ;
98979: LD_VAR 0 2
98983: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98984: LD_INT 0
98986: PPUSH
98987: PPUSH
98988: PPUSH
98989: PPUSH
98990: PPUSH
98991: PPUSH
98992: PPUSH
98993: PPUSH
98994: PPUSH
98995: PPUSH
98996: PPUSH
98997: PPUSH
98998: PPUSH
98999: PPUSH
99000: PPUSH
99001: PPUSH
99002: PPUSH
99003: PPUSH
99004: PPUSH
99005: PPUSH
99006: PPUSH
99007: PPUSH
99008: PPUSH
99009: PPUSH
99010: PPUSH
99011: PPUSH
99012: PPUSH
99013: PPUSH
99014: PPUSH
99015: PPUSH
99016: PPUSH
99017: PPUSH
99018: PPUSH
99019: PPUSH
// if not list then
99020: LD_VAR 0 1
99024: NOT
99025: IFFALSE 99029
// exit ;
99027: GO 103655
// base := list [ 1 ] ;
99029: LD_ADDR_VAR 0 3
99033: PUSH
99034: LD_VAR 0 1
99038: PUSH
99039: LD_INT 1
99041: ARRAY
99042: ST_TO_ADDR
// group := list [ 2 ] ;
99043: LD_ADDR_VAR 0 4
99047: PUSH
99048: LD_VAR 0 1
99052: PUSH
99053: LD_INT 2
99055: ARRAY
99056: ST_TO_ADDR
// path := list [ 3 ] ;
99057: LD_ADDR_VAR 0 5
99061: PUSH
99062: LD_VAR 0 1
99066: PUSH
99067: LD_INT 3
99069: ARRAY
99070: ST_TO_ADDR
// flags := list [ 4 ] ;
99071: LD_ADDR_VAR 0 6
99075: PUSH
99076: LD_VAR 0 1
99080: PUSH
99081: LD_INT 4
99083: ARRAY
99084: ST_TO_ADDR
// mined := [ ] ;
99085: LD_ADDR_VAR 0 27
99089: PUSH
99090: EMPTY
99091: ST_TO_ADDR
// bombed := [ ] ;
99092: LD_ADDR_VAR 0 28
99096: PUSH
99097: EMPTY
99098: ST_TO_ADDR
// healers := [ ] ;
99099: LD_ADDR_VAR 0 31
99103: PUSH
99104: EMPTY
99105: ST_TO_ADDR
// to_heal := [ ] ;
99106: LD_ADDR_VAR 0 30
99110: PUSH
99111: EMPTY
99112: ST_TO_ADDR
// repairs := [ ] ;
99113: LD_ADDR_VAR 0 33
99117: PUSH
99118: EMPTY
99119: ST_TO_ADDR
// to_repair := [ ] ;
99120: LD_ADDR_VAR 0 32
99124: PUSH
99125: EMPTY
99126: ST_TO_ADDR
// if not group or not path then
99127: LD_VAR 0 4
99131: NOT
99132: PUSH
99133: LD_VAR 0 5
99137: NOT
99138: OR
99139: IFFALSE 99143
// exit ;
99141: GO 103655
// side := GetSide ( group [ 1 ] ) ;
99143: LD_ADDR_VAR 0 35
99147: PUSH
99148: LD_VAR 0 4
99152: PUSH
99153: LD_INT 1
99155: ARRAY
99156: PPUSH
99157: CALL_OW 255
99161: ST_TO_ADDR
// if flags then
99162: LD_VAR 0 6
99166: IFFALSE 99310
// begin f_ignore_area := flags [ 1 ] ;
99168: LD_ADDR_VAR 0 17
99172: PUSH
99173: LD_VAR 0 6
99177: PUSH
99178: LD_INT 1
99180: ARRAY
99181: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99182: LD_ADDR_VAR 0 18
99186: PUSH
99187: LD_VAR 0 6
99191: PUSH
99192: LD_INT 2
99194: ARRAY
99195: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99196: LD_ADDR_VAR 0 19
99200: PUSH
99201: LD_VAR 0 6
99205: PUSH
99206: LD_INT 3
99208: ARRAY
99209: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99210: LD_ADDR_VAR 0 20
99214: PUSH
99215: LD_VAR 0 6
99219: PUSH
99220: LD_INT 4
99222: ARRAY
99223: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99224: LD_ADDR_VAR 0 21
99228: PUSH
99229: LD_VAR 0 6
99233: PUSH
99234: LD_INT 5
99236: ARRAY
99237: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99238: LD_ADDR_VAR 0 22
99242: PUSH
99243: LD_VAR 0 6
99247: PUSH
99248: LD_INT 6
99250: ARRAY
99251: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99252: LD_ADDR_VAR 0 23
99256: PUSH
99257: LD_VAR 0 6
99261: PUSH
99262: LD_INT 7
99264: ARRAY
99265: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99266: LD_ADDR_VAR 0 24
99270: PUSH
99271: LD_VAR 0 6
99275: PUSH
99276: LD_INT 8
99278: ARRAY
99279: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99280: LD_ADDR_VAR 0 25
99284: PUSH
99285: LD_VAR 0 6
99289: PUSH
99290: LD_INT 9
99292: ARRAY
99293: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99294: LD_ADDR_VAR 0 26
99298: PUSH
99299: LD_VAR 0 6
99303: PUSH
99304: LD_INT 10
99306: ARRAY
99307: ST_TO_ADDR
// end else
99308: GO 99390
// begin f_ignore_area := false ;
99310: LD_ADDR_VAR 0 17
99314: PUSH
99315: LD_INT 0
99317: ST_TO_ADDR
// f_capture := false ;
99318: LD_ADDR_VAR 0 18
99322: PUSH
99323: LD_INT 0
99325: ST_TO_ADDR
// f_ignore_civ := false ;
99326: LD_ADDR_VAR 0 19
99330: PUSH
99331: LD_INT 0
99333: ST_TO_ADDR
// f_murder := false ;
99334: LD_ADDR_VAR 0 20
99338: PUSH
99339: LD_INT 0
99341: ST_TO_ADDR
// f_mines := false ;
99342: LD_ADDR_VAR 0 21
99346: PUSH
99347: LD_INT 0
99349: ST_TO_ADDR
// f_repair := false ;
99350: LD_ADDR_VAR 0 22
99354: PUSH
99355: LD_INT 0
99357: ST_TO_ADDR
// f_heal := false ;
99358: LD_ADDR_VAR 0 23
99362: PUSH
99363: LD_INT 0
99365: ST_TO_ADDR
// f_spacetime := false ;
99366: LD_ADDR_VAR 0 24
99370: PUSH
99371: LD_INT 0
99373: ST_TO_ADDR
// f_attack_depot := false ;
99374: LD_ADDR_VAR 0 25
99378: PUSH
99379: LD_INT 0
99381: ST_TO_ADDR
// f_crawl := false ;
99382: LD_ADDR_VAR 0 26
99386: PUSH
99387: LD_INT 0
99389: ST_TO_ADDR
// end ; if f_heal then
99390: LD_VAR 0 23
99394: IFFALSE 99421
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
99396: LD_ADDR_VAR 0 31
99400: PUSH
99401: LD_VAR 0 4
99405: PPUSH
99406: LD_INT 25
99408: PUSH
99409: LD_INT 4
99411: PUSH
99412: EMPTY
99413: LIST
99414: LIST
99415: PPUSH
99416: CALL_OW 72
99420: ST_TO_ADDR
// if f_repair then
99421: LD_VAR 0 22
99425: IFFALSE 99452
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
99427: LD_ADDR_VAR 0 33
99431: PUSH
99432: LD_VAR 0 4
99436: PPUSH
99437: LD_INT 25
99439: PUSH
99440: LD_INT 3
99442: PUSH
99443: EMPTY
99444: LIST
99445: LIST
99446: PPUSH
99447: CALL_OW 72
99451: ST_TO_ADDR
// units_path := [ ] ;
99452: LD_ADDR_VAR 0 16
99456: PUSH
99457: EMPTY
99458: ST_TO_ADDR
// for i = 1 to group do
99459: LD_ADDR_VAR 0 7
99463: PUSH
99464: DOUBLE
99465: LD_INT 1
99467: DEC
99468: ST_TO_ADDR
99469: LD_VAR 0 4
99473: PUSH
99474: FOR_TO
99475: IFFALSE 99504
// units_path := Replace ( units_path , i , path ) ;
99477: LD_ADDR_VAR 0 16
99481: PUSH
99482: LD_VAR 0 16
99486: PPUSH
99487: LD_VAR 0 7
99491: PPUSH
99492: LD_VAR 0 5
99496: PPUSH
99497: CALL_OW 1
99501: ST_TO_ADDR
99502: GO 99474
99504: POP
99505: POP
// repeat for i = group downto 1 do
99506: LD_ADDR_VAR 0 7
99510: PUSH
99511: DOUBLE
99512: LD_VAR 0 4
99516: INC
99517: ST_TO_ADDR
99518: LD_INT 1
99520: PUSH
99521: FOR_DOWNTO
99522: IFFALSE 103618
// begin wait ( 5 ) ;
99524: LD_INT 5
99526: PPUSH
99527: CALL_OW 67
// tmp := [ ] ;
99531: LD_ADDR_VAR 0 14
99535: PUSH
99536: EMPTY
99537: ST_TO_ADDR
// attacking := false ;
99538: LD_ADDR_VAR 0 29
99542: PUSH
99543: LD_INT 0
99545: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99546: LD_VAR 0 4
99550: PUSH
99551: LD_VAR 0 7
99555: ARRAY
99556: PPUSH
99557: CALL_OW 301
99561: PUSH
99562: LD_VAR 0 4
99566: PUSH
99567: LD_VAR 0 7
99571: ARRAY
99572: NOT
99573: OR
99574: IFFALSE 99683
// begin if GetType ( group [ i ] ) = unit_human then
99576: LD_VAR 0 4
99580: PUSH
99581: LD_VAR 0 7
99585: ARRAY
99586: PPUSH
99587: CALL_OW 247
99591: PUSH
99592: LD_INT 1
99594: EQUAL
99595: IFFALSE 99641
// begin to_heal := to_heal diff group [ i ] ;
99597: LD_ADDR_VAR 0 30
99601: PUSH
99602: LD_VAR 0 30
99606: PUSH
99607: LD_VAR 0 4
99611: PUSH
99612: LD_VAR 0 7
99616: ARRAY
99617: DIFF
99618: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99619: LD_ADDR_VAR 0 31
99623: PUSH
99624: LD_VAR 0 31
99628: PUSH
99629: LD_VAR 0 4
99633: PUSH
99634: LD_VAR 0 7
99638: ARRAY
99639: DIFF
99640: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99641: LD_ADDR_VAR 0 4
99645: PUSH
99646: LD_VAR 0 4
99650: PPUSH
99651: LD_VAR 0 7
99655: PPUSH
99656: CALL_OW 3
99660: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99661: LD_ADDR_VAR 0 16
99665: PUSH
99666: LD_VAR 0 16
99670: PPUSH
99671: LD_VAR 0 7
99675: PPUSH
99676: CALL_OW 3
99680: ST_TO_ADDR
// continue ;
99681: GO 99521
// end ; if f_repair then
99683: LD_VAR 0 22
99687: IFFALSE 100176
// begin if GetType ( group [ i ] ) = unit_vehicle then
99689: LD_VAR 0 4
99693: PUSH
99694: LD_VAR 0 7
99698: ARRAY
99699: PPUSH
99700: CALL_OW 247
99704: PUSH
99705: LD_INT 2
99707: EQUAL
99708: IFFALSE 99898
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99710: LD_VAR 0 4
99714: PUSH
99715: LD_VAR 0 7
99719: ARRAY
99720: PPUSH
99721: CALL_OW 256
99725: PUSH
99726: LD_INT 700
99728: LESS
99729: PUSH
99730: LD_VAR 0 4
99734: PUSH
99735: LD_VAR 0 7
99739: ARRAY
99740: PUSH
99741: LD_VAR 0 32
99745: IN
99746: NOT
99747: AND
99748: IFFALSE 99772
// to_repair := to_repair union group [ i ] ;
99750: LD_ADDR_VAR 0 32
99754: PUSH
99755: LD_VAR 0 32
99759: PUSH
99760: LD_VAR 0 4
99764: PUSH
99765: LD_VAR 0 7
99769: ARRAY
99770: UNION
99771: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99772: LD_VAR 0 4
99776: PUSH
99777: LD_VAR 0 7
99781: ARRAY
99782: PPUSH
99783: CALL_OW 256
99787: PUSH
99788: LD_INT 1000
99790: EQUAL
99791: PUSH
99792: LD_VAR 0 4
99796: PUSH
99797: LD_VAR 0 7
99801: ARRAY
99802: PUSH
99803: LD_VAR 0 32
99807: IN
99808: AND
99809: IFFALSE 99833
// to_repair := to_repair diff group [ i ] ;
99811: LD_ADDR_VAR 0 32
99815: PUSH
99816: LD_VAR 0 32
99820: PUSH
99821: LD_VAR 0 4
99825: PUSH
99826: LD_VAR 0 7
99830: ARRAY
99831: DIFF
99832: ST_TO_ADDR
// if group [ i ] in to_repair then
99833: LD_VAR 0 4
99837: PUSH
99838: LD_VAR 0 7
99842: ARRAY
99843: PUSH
99844: LD_VAR 0 32
99848: IN
99849: IFFALSE 99896
// begin if not IsInArea ( group [ i ] , f_repair ) then
99851: LD_VAR 0 4
99855: PUSH
99856: LD_VAR 0 7
99860: ARRAY
99861: PPUSH
99862: LD_VAR 0 22
99866: PPUSH
99867: CALL_OW 308
99871: NOT
99872: IFFALSE 99894
// ComMoveToArea ( group [ i ] , f_repair ) ;
99874: LD_VAR 0 4
99878: PUSH
99879: LD_VAR 0 7
99883: ARRAY
99884: PPUSH
99885: LD_VAR 0 22
99889: PPUSH
99890: CALL_OW 113
// continue ;
99894: GO 99521
// end ; end else
99896: GO 100176
// if group [ i ] in repairs then
99898: LD_VAR 0 4
99902: PUSH
99903: LD_VAR 0 7
99907: ARRAY
99908: PUSH
99909: LD_VAR 0 33
99913: IN
99914: IFFALSE 100176
// begin if IsInUnit ( group [ i ] ) then
99916: LD_VAR 0 4
99920: PUSH
99921: LD_VAR 0 7
99925: ARRAY
99926: PPUSH
99927: CALL_OW 310
99931: IFFALSE 99999
// begin z := IsInUnit ( group [ i ] ) ;
99933: LD_ADDR_VAR 0 13
99937: PUSH
99938: LD_VAR 0 4
99942: PUSH
99943: LD_VAR 0 7
99947: ARRAY
99948: PPUSH
99949: CALL_OW 310
99953: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99954: LD_VAR 0 13
99958: PUSH
99959: LD_VAR 0 32
99963: IN
99964: PUSH
99965: LD_VAR 0 13
99969: PPUSH
99970: LD_VAR 0 22
99974: PPUSH
99975: CALL_OW 308
99979: AND
99980: IFFALSE 99997
// ComExitVehicle ( group [ i ] ) ;
99982: LD_VAR 0 4
99986: PUSH
99987: LD_VAR 0 7
99991: ARRAY
99992: PPUSH
99993: CALL_OW 121
// end else
99997: GO 100176
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99999: LD_ADDR_VAR 0 13
100003: PUSH
100004: LD_VAR 0 4
100008: PPUSH
100009: LD_INT 95
100011: PUSH
100012: LD_VAR 0 22
100016: PUSH
100017: EMPTY
100018: LIST
100019: LIST
100020: PUSH
100021: LD_INT 58
100023: PUSH
100024: EMPTY
100025: LIST
100026: PUSH
100027: EMPTY
100028: LIST
100029: LIST
100030: PPUSH
100031: CALL_OW 72
100035: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100036: LD_VAR 0 4
100040: PUSH
100041: LD_VAR 0 7
100045: ARRAY
100046: PPUSH
100047: CALL_OW 314
100051: NOT
100052: IFFALSE 100174
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100054: LD_ADDR_VAR 0 10
100058: PUSH
100059: LD_VAR 0 13
100063: PPUSH
100064: LD_VAR 0 4
100068: PUSH
100069: LD_VAR 0 7
100073: ARRAY
100074: PPUSH
100075: CALL_OW 74
100079: ST_TO_ADDR
// if not x then
100080: LD_VAR 0 10
100084: NOT
100085: IFFALSE 100089
// continue ;
100087: GO 99521
// if GetLives ( x ) < 1000 then
100089: LD_VAR 0 10
100093: PPUSH
100094: CALL_OW 256
100098: PUSH
100099: LD_INT 1000
100101: LESS
100102: IFFALSE 100126
// ComRepairVehicle ( group [ i ] , x ) else
100104: LD_VAR 0 4
100108: PUSH
100109: LD_VAR 0 7
100113: ARRAY
100114: PPUSH
100115: LD_VAR 0 10
100119: PPUSH
100120: CALL_OW 129
100124: GO 100174
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100126: LD_VAR 0 23
100130: PUSH
100131: LD_VAR 0 4
100135: PUSH
100136: LD_VAR 0 7
100140: ARRAY
100141: PPUSH
100142: CALL_OW 256
100146: PUSH
100147: LD_INT 1000
100149: LESS
100150: AND
100151: NOT
100152: IFFALSE 100174
// ComEnterUnit ( group [ i ] , x ) ;
100154: LD_VAR 0 4
100158: PUSH
100159: LD_VAR 0 7
100163: ARRAY
100164: PPUSH
100165: LD_VAR 0 10
100169: PPUSH
100170: CALL_OW 120
// end ; continue ;
100174: GO 99521
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100176: LD_VAR 0 23
100180: PUSH
100181: LD_VAR 0 4
100185: PUSH
100186: LD_VAR 0 7
100190: ARRAY
100191: PPUSH
100192: CALL_OW 247
100196: PUSH
100197: LD_INT 1
100199: EQUAL
100200: AND
100201: IFFALSE 100679
// begin if group [ i ] in healers then
100203: LD_VAR 0 4
100207: PUSH
100208: LD_VAR 0 7
100212: ARRAY
100213: PUSH
100214: LD_VAR 0 31
100218: IN
100219: IFFALSE 100492
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100221: LD_VAR 0 4
100225: PUSH
100226: LD_VAR 0 7
100230: ARRAY
100231: PPUSH
100232: LD_VAR 0 23
100236: PPUSH
100237: CALL_OW 308
100241: NOT
100242: PUSH
100243: LD_VAR 0 4
100247: PUSH
100248: LD_VAR 0 7
100252: ARRAY
100253: PPUSH
100254: CALL_OW 314
100258: NOT
100259: AND
100260: IFFALSE 100284
// ComMoveToArea ( group [ i ] , f_heal ) else
100262: LD_VAR 0 4
100266: PUSH
100267: LD_VAR 0 7
100271: ARRAY
100272: PPUSH
100273: LD_VAR 0 23
100277: PPUSH
100278: CALL_OW 113
100282: GO 100490
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100284: LD_VAR 0 4
100288: PUSH
100289: LD_VAR 0 7
100293: ARRAY
100294: PPUSH
100295: CALL 98902 0 1
100299: PPUSH
100300: CALL_OW 256
100304: PUSH
100305: LD_INT 1000
100307: EQUAL
100308: IFFALSE 100327
// ComStop ( group [ i ] ) else
100310: LD_VAR 0 4
100314: PUSH
100315: LD_VAR 0 7
100319: ARRAY
100320: PPUSH
100321: CALL_OW 141
100325: GO 100490
// if not HasTask ( group [ i ] ) and to_heal then
100327: LD_VAR 0 4
100331: PUSH
100332: LD_VAR 0 7
100336: ARRAY
100337: PPUSH
100338: CALL_OW 314
100342: NOT
100343: PUSH
100344: LD_VAR 0 30
100348: AND
100349: IFFALSE 100490
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100351: LD_ADDR_VAR 0 13
100355: PUSH
100356: LD_VAR 0 30
100360: PPUSH
100361: LD_INT 3
100363: PUSH
100364: LD_INT 54
100366: PUSH
100367: EMPTY
100368: LIST
100369: PUSH
100370: EMPTY
100371: LIST
100372: LIST
100373: PPUSH
100374: CALL_OW 72
100378: PPUSH
100379: LD_VAR 0 4
100383: PUSH
100384: LD_VAR 0 7
100388: ARRAY
100389: PPUSH
100390: CALL_OW 74
100394: ST_TO_ADDR
// if z then
100395: LD_VAR 0 13
100399: IFFALSE 100490
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
100401: LD_INT 91
100403: PUSH
100404: LD_VAR 0 13
100408: PUSH
100409: LD_INT 10
100411: PUSH
100412: EMPTY
100413: LIST
100414: LIST
100415: LIST
100416: PUSH
100417: LD_INT 81
100419: PUSH
100420: LD_VAR 0 13
100424: PPUSH
100425: CALL_OW 255
100429: PUSH
100430: EMPTY
100431: LIST
100432: LIST
100433: PUSH
100434: EMPTY
100435: LIST
100436: LIST
100437: PPUSH
100438: CALL_OW 69
100442: PUSH
100443: LD_INT 0
100445: EQUAL
100446: IFFALSE 100470
// ComHeal ( group [ i ] , z ) else
100448: LD_VAR 0 4
100452: PUSH
100453: LD_VAR 0 7
100457: ARRAY
100458: PPUSH
100459: LD_VAR 0 13
100463: PPUSH
100464: CALL_OW 128
100468: GO 100490
// ComMoveToArea ( group [ i ] , f_heal ) ;
100470: LD_VAR 0 4
100474: PUSH
100475: LD_VAR 0 7
100479: ARRAY
100480: PPUSH
100481: LD_VAR 0 23
100485: PPUSH
100486: CALL_OW 113
// end ; continue ;
100490: GO 99521
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
100492: LD_VAR 0 4
100496: PUSH
100497: LD_VAR 0 7
100501: ARRAY
100502: PPUSH
100503: CALL_OW 256
100507: PUSH
100508: LD_INT 700
100510: LESS
100511: PUSH
100512: LD_VAR 0 4
100516: PUSH
100517: LD_VAR 0 7
100521: ARRAY
100522: PUSH
100523: LD_VAR 0 30
100527: IN
100528: NOT
100529: AND
100530: IFFALSE 100554
// to_heal := to_heal union group [ i ] ;
100532: LD_ADDR_VAR 0 30
100536: PUSH
100537: LD_VAR 0 30
100541: PUSH
100542: LD_VAR 0 4
100546: PUSH
100547: LD_VAR 0 7
100551: ARRAY
100552: UNION
100553: ST_TO_ADDR
// if group [ i ] in to_heal then
100554: LD_VAR 0 4
100558: PUSH
100559: LD_VAR 0 7
100563: ARRAY
100564: PUSH
100565: LD_VAR 0 30
100569: IN
100570: IFFALSE 100679
// begin if GetLives ( group [ i ] ) = 1000 then
100572: LD_VAR 0 4
100576: PUSH
100577: LD_VAR 0 7
100581: ARRAY
100582: PPUSH
100583: CALL_OW 256
100587: PUSH
100588: LD_INT 1000
100590: EQUAL
100591: IFFALSE 100617
// to_heal := to_heal diff group [ i ] else
100593: LD_ADDR_VAR 0 30
100597: PUSH
100598: LD_VAR 0 30
100602: PUSH
100603: LD_VAR 0 4
100607: PUSH
100608: LD_VAR 0 7
100612: ARRAY
100613: DIFF
100614: ST_TO_ADDR
100615: GO 100679
// begin if not IsInArea ( group [ i ] , to_heal ) then
100617: LD_VAR 0 4
100621: PUSH
100622: LD_VAR 0 7
100626: ARRAY
100627: PPUSH
100628: LD_VAR 0 30
100632: PPUSH
100633: CALL_OW 308
100637: NOT
100638: IFFALSE 100662
// ComMoveToArea ( group [ i ] , f_heal ) else
100640: LD_VAR 0 4
100644: PUSH
100645: LD_VAR 0 7
100649: ARRAY
100650: PPUSH
100651: LD_VAR 0 23
100655: PPUSH
100656: CALL_OW 113
100660: GO 100677
// ComHold ( group [ i ] ) ;
100662: LD_VAR 0 4
100666: PUSH
100667: LD_VAR 0 7
100671: ARRAY
100672: PPUSH
100673: CALL_OW 140
// continue ;
100677: GO 99521
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100679: LD_VAR 0 4
100683: PUSH
100684: LD_VAR 0 7
100688: ARRAY
100689: PPUSH
100690: LD_INT 10
100692: PPUSH
100693: CALL 97299 0 2
100697: NOT
100698: PUSH
100699: LD_VAR 0 16
100703: PUSH
100704: LD_VAR 0 7
100708: ARRAY
100709: PUSH
100710: EMPTY
100711: EQUAL
100712: NOT
100713: AND
100714: IFFALSE 100980
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100716: LD_VAR 0 4
100720: PUSH
100721: LD_VAR 0 7
100725: ARRAY
100726: PPUSH
100727: CALL_OW 262
100731: PUSH
100732: LD_INT 1
100734: PUSH
100735: LD_INT 2
100737: PUSH
100738: EMPTY
100739: LIST
100740: LIST
100741: IN
100742: IFFALSE 100783
// if GetFuel ( group [ i ] ) < 10 then
100744: LD_VAR 0 4
100748: PUSH
100749: LD_VAR 0 7
100753: ARRAY
100754: PPUSH
100755: CALL_OW 261
100759: PUSH
100760: LD_INT 10
100762: LESS
100763: IFFALSE 100783
// SetFuel ( group [ i ] , 12 ) ;
100765: LD_VAR 0 4
100769: PUSH
100770: LD_VAR 0 7
100774: ARRAY
100775: PPUSH
100776: LD_INT 12
100778: PPUSH
100779: CALL_OW 240
// if units_path [ i ] then
100783: LD_VAR 0 16
100787: PUSH
100788: LD_VAR 0 7
100792: ARRAY
100793: IFFALSE 100978
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100795: LD_VAR 0 4
100799: PUSH
100800: LD_VAR 0 7
100804: ARRAY
100805: PPUSH
100806: LD_VAR 0 16
100810: PUSH
100811: LD_VAR 0 7
100815: ARRAY
100816: PUSH
100817: LD_INT 1
100819: ARRAY
100820: PUSH
100821: LD_INT 1
100823: ARRAY
100824: PPUSH
100825: LD_VAR 0 16
100829: PUSH
100830: LD_VAR 0 7
100834: ARRAY
100835: PUSH
100836: LD_INT 1
100838: ARRAY
100839: PUSH
100840: LD_INT 2
100842: ARRAY
100843: PPUSH
100844: CALL_OW 297
100848: PUSH
100849: LD_INT 6
100851: GREATER
100852: IFFALSE 100927
// begin if not HasTask ( group [ i ] ) then
100854: LD_VAR 0 4
100858: PUSH
100859: LD_VAR 0 7
100863: ARRAY
100864: PPUSH
100865: CALL_OW 314
100869: NOT
100870: IFFALSE 100925
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100872: LD_VAR 0 4
100876: PUSH
100877: LD_VAR 0 7
100881: ARRAY
100882: PPUSH
100883: LD_VAR 0 16
100887: PUSH
100888: LD_VAR 0 7
100892: ARRAY
100893: PUSH
100894: LD_INT 1
100896: ARRAY
100897: PUSH
100898: LD_INT 1
100900: ARRAY
100901: PPUSH
100902: LD_VAR 0 16
100906: PUSH
100907: LD_VAR 0 7
100911: ARRAY
100912: PUSH
100913: LD_INT 1
100915: ARRAY
100916: PUSH
100917: LD_INT 2
100919: ARRAY
100920: PPUSH
100921: CALL_OW 114
// end else
100925: GO 100978
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100927: LD_ADDR_VAR 0 15
100931: PUSH
100932: LD_VAR 0 16
100936: PUSH
100937: LD_VAR 0 7
100941: ARRAY
100942: PPUSH
100943: LD_INT 1
100945: PPUSH
100946: CALL_OW 3
100950: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100951: LD_ADDR_VAR 0 16
100955: PUSH
100956: LD_VAR 0 16
100960: PPUSH
100961: LD_VAR 0 7
100965: PPUSH
100966: LD_VAR 0 15
100970: PPUSH
100971: CALL_OW 1
100975: ST_TO_ADDR
// continue ;
100976: GO 99521
// end ; end ; end else
100978: GO 103616
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100980: LD_ADDR_VAR 0 14
100984: PUSH
100985: LD_INT 81
100987: PUSH
100988: LD_VAR 0 4
100992: PUSH
100993: LD_VAR 0 7
100997: ARRAY
100998: PPUSH
100999: CALL_OW 255
101003: PUSH
101004: EMPTY
101005: LIST
101006: LIST
101007: PPUSH
101008: CALL_OW 69
101012: ST_TO_ADDR
// if not tmp then
101013: LD_VAR 0 14
101017: NOT
101018: IFFALSE 101022
// continue ;
101020: GO 99521
// if f_ignore_area then
101022: LD_VAR 0 17
101026: IFFALSE 101114
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101028: LD_ADDR_VAR 0 15
101032: PUSH
101033: LD_VAR 0 14
101037: PPUSH
101038: LD_INT 3
101040: PUSH
101041: LD_INT 92
101043: PUSH
101044: LD_VAR 0 17
101048: PUSH
101049: LD_INT 1
101051: ARRAY
101052: PUSH
101053: LD_VAR 0 17
101057: PUSH
101058: LD_INT 2
101060: ARRAY
101061: PUSH
101062: LD_VAR 0 17
101066: PUSH
101067: LD_INT 3
101069: ARRAY
101070: PUSH
101071: EMPTY
101072: LIST
101073: LIST
101074: LIST
101075: LIST
101076: PUSH
101077: EMPTY
101078: LIST
101079: LIST
101080: PPUSH
101081: CALL_OW 72
101085: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101086: LD_VAR 0 14
101090: PUSH
101091: LD_VAR 0 15
101095: DIFF
101096: IFFALSE 101114
// tmp := tmp diff tmp2 ;
101098: LD_ADDR_VAR 0 14
101102: PUSH
101103: LD_VAR 0 14
101107: PUSH
101108: LD_VAR 0 15
101112: DIFF
101113: ST_TO_ADDR
// end ; if not f_murder then
101114: LD_VAR 0 20
101118: NOT
101119: IFFALSE 101177
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101121: LD_ADDR_VAR 0 15
101125: PUSH
101126: LD_VAR 0 14
101130: PPUSH
101131: LD_INT 3
101133: PUSH
101134: LD_INT 50
101136: PUSH
101137: EMPTY
101138: LIST
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: PPUSH
101144: CALL_OW 72
101148: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101149: LD_VAR 0 14
101153: PUSH
101154: LD_VAR 0 15
101158: DIFF
101159: IFFALSE 101177
// tmp := tmp diff tmp2 ;
101161: LD_ADDR_VAR 0 14
101165: PUSH
101166: LD_VAR 0 14
101170: PUSH
101171: LD_VAR 0 15
101175: DIFF
101176: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101177: LD_ADDR_VAR 0 14
101181: PUSH
101182: LD_VAR 0 4
101186: PUSH
101187: LD_VAR 0 7
101191: ARRAY
101192: PPUSH
101193: LD_VAR 0 14
101197: PPUSH
101198: LD_INT 1
101200: PPUSH
101201: LD_INT 1
101203: PPUSH
101204: CALL 70942 0 4
101208: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101209: LD_VAR 0 4
101213: PUSH
101214: LD_VAR 0 7
101218: ARRAY
101219: PPUSH
101220: CALL_OW 257
101224: PUSH
101225: LD_INT 1
101227: EQUAL
101228: IFFALSE 101676
// begin if WantPlant ( group [ i ] ) then
101230: LD_VAR 0 4
101234: PUSH
101235: LD_VAR 0 7
101239: ARRAY
101240: PPUSH
101241: CALL 70443 0 1
101245: IFFALSE 101249
// continue ;
101247: GO 99521
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101249: LD_VAR 0 18
101253: PUSH
101254: LD_VAR 0 4
101258: PUSH
101259: LD_VAR 0 7
101263: ARRAY
101264: PPUSH
101265: CALL_OW 310
101269: NOT
101270: AND
101271: PUSH
101272: LD_VAR 0 14
101276: PUSH
101277: LD_INT 1
101279: ARRAY
101280: PUSH
101281: LD_VAR 0 14
101285: PPUSH
101286: LD_INT 21
101288: PUSH
101289: LD_INT 2
101291: PUSH
101292: EMPTY
101293: LIST
101294: LIST
101295: PUSH
101296: LD_INT 58
101298: PUSH
101299: EMPTY
101300: LIST
101301: PUSH
101302: EMPTY
101303: LIST
101304: LIST
101305: PPUSH
101306: CALL_OW 72
101310: IN
101311: AND
101312: IFFALSE 101348
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101314: LD_VAR 0 4
101318: PUSH
101319: LD_VAR 0 7
101323: ARRAY
101324: PPUSH
101325: LD_VAR 0 14
101329: PUSH
101330: LD_INT 1
101332: ARRAY
101333: PPUSH
101334: CALL_OW 120
// attacking := true ;
101338: LD_ADDR_VAR 0 29
101342: PUSH
101343: LD_INT 1
101345: ST_TO_ADDR
// continue ;
101346: GO 99521
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101348: LD_VAR 0 26
101352: PUSH
101353: LD_VAR 0 4
101357: PUSH
101358: LD_VAR 0 7
101362: ARRAY
101363: PPUSH
101364: CALL_OW 257
101368: PUSH
101369: LD_INT 1
101371: EQUAL
101372: AND
101373: PUSH
101374: LD_VAR 0 4
101378: PUSH
101379: LD_VAR 0 7
101383: ARRAY
101384: PPUSH
101385: CALL_OW 256
101389: PUSH
101390: LD_INT 800
101392: LESS
101393: AND
101394: PUSH
101395: LD_VAR 0 4
101399: PUSH
101400: LD_VAR 0 7
101404: ARRAY
101405: PPUSH
101406: CALL_OW 318
101410: NOT
101411: AND
101412: IFFALSE 101429
// ComCrawl ( group [ i ] ) ;
101414: LD_VAR 0 4
101418: PUSH
101419: LD_VAR 0 7
101423: ARRAY
101424: PPUSH
101425: CALL_OW 137
// if f_mines then
101429: LD_VAR 0 21
101433: IFFALSE 101676
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
101435: LD_VAR 0 14
101439: PUSH
101440: LD_INT 1
101442: ARRAY
101443: PPUSH
101444: CALL_OW 247
101448: PUSH
101449: LD_INT 3
101451: EQUAL
101452: PUSH
101453: LD_VAR 0 14
101457: PUSH
101458: LD_INT 1
101460: ARRAY
101461: PUSH
101462: LD_VAR 0 27
101466: IN
101467: NOT
101468: AND
101469: IFFALSE 101676
// begin x := GetX ( tmp [ 1 ] ) ;
101471: LD_ADDR_VAR 0 10
101475: PUSH
101476: LD_VAR 0 14
101480: PUSH
101481: LD_INT 1
101483: ARRAY
101484: PPUSH
101485: CALL_OW 250
101489: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
101490: LD_ADDR_VAR 0 11
101494: PUSH
101495: LD_VAR 0 14
101499: PUSH
101500: LD_INT 1
101502: ARRAY
101503: PPUSH
101504: CALL_OW 251
101508: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
101509: LD_ADDR_VAR 0 12
101513: PUSH
101514: LD_VAR 0 4
101518: PUSH
101519: LD_VAR 0 7
101523: ARRAY
101524: PPUSH
101525: CALL 97384 0 1
101529: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
101530: LD_VAR 0 4
101534: PUSH
101535: LD_VAR 0 7
101539: ARRAY
101540: PPUSH
101541: LD_VAR 0 10
101545: PPUSH
101546: LD_VAR 0 11
101550: PPUSH
101551: LD_VAR 0 14
101555: PUSH
101556: LD_INT 1
101558: ARRAY
101559: PPUSH
101560: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101564: LD_VAR 0 4
101568: PUSH
101569: LD_VAR 0 7
101573: ARRAY
101574: PPUSH
101575: LD_VAR 0 10
101579: PPUSH
101580: LD_VAR 0 12
101584: PPUSH
101585: LD_INT 7
101587: PPUSH
101588: CALL_OW 272
101592: PPUSH
101593: LD_VAR 0 11
101597: PPUSH
101598: LD_VAR 0 12
101602: PPUSH
101603: LD_INT 7
101605: PPUSH
101606: CALL_OW 273
101610: PPUSH
101611: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101615: LD_VAR 0 4
101619: PUSH
101620: LD_VAR 0 7
101624: ARRAY
101625: PPUSH
101626: LD_INT 71
101628: PPUSH
101629: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101633: LD_ADDR_VAR 0 27
101637: PUSH
101638: LD_VAR 0 27
101642: PPUSH
101643: LD_VAR 0 27
101647: PUSH
101648: LD_INT 1
101650: PLUS
101651: PPUSH
101652: LD_VAR 0 14
101656: PUSH
101657: LD_INT 1
101659: ARRAY
101660: PPUSH
101661: CALL_OW 1
101665: ST_TO_ADDR
// attacking := true ;
101666: LD_ADDR_VAR 0 29
101670: PUSH
101671: LD_INT 1
101673: ST_TO_ADDR
// continue ;
101674: GO 99521
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101676: LD_VAR 0 4
101680: PUSH
101681: LD_VAR 0 7
101685: ARRAY
101686: PPUSH
101687: CALL_OW 257
101691: PUSH
101692: LD_INT 17
101694: EQUAL
101695: PUSH
101696: LD_VAR 0 4
101700: PUSH
101701: LD_VAR 0 7
101705: ARRAY
101706: PPUSH
101707: CALL_OW 110
101711: PUSH
101712: LD_INT 71
101714: EQUAL
101715: NOT
101716: AND
101717: IFFALSE 101863
// begin attacking := false ;
101719: LD_ADDR_VAR 0 29
101723: PUSH
101724: LD_INT 0
101726: ST_TO_ADDR
// k := 5 ;
101727: LD_ADDR_VAR 0 9
101731: PUSH
101732: LD_INT 5
101734: ST_TO_ADDR
// if tmp < k then
101735: LD_VAR 0 14
101739: PUSH
101740: LD_VAR 0 9
101744: LESS
101745: IFFALSE 101757
// k := tmp ;
101747: LD_ADDR_VAR 0 9
101751: PUSH
101752: LD_VAR 0 14
101756: ST_TO_ADDR
// for j = 1 to k do
101757: LD_ADDR_VAR 0 8
101761: PUSH
101762: DOUBLE
101763: LD_INT 1
101765: DEC
101766: ST_TO_ADDR
101767: LD_VAR 0 9
101771: PUSH
101772: FOR_TO
101773: IFFALSE 101861
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101775: LD_VAR 0 14
101779: PUSH
101780: LD_VAR 0 8
101784: ARRAY
101785: PUSH
101786: LD_VAR 0 14
101790: PPUSH
101791: LD_INT 58
101793: PUSH
101794: EMPTY
101795: LIST
101796: PPUSH
101797: CALL_OW 72
101801: IN
101802: NOT
101803: IFFALSE 101859
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101805: LD_VAR 0 4
101809: PUSH
101810: LD_VAR 0 7
101814: ARRAY
101815: PPUSH
101816: LD_VAR 0 14
101820: PUSH
101821: LD_VAR 0 8
101825: ARRAY
101826: PPUSH
101827: CALL_OW 115
// attacking := true ;
101831: LD_ADDR_VAR 0 29
101835: PUSH
101836: LD_INT 1
101838: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101839: LD_VAR 0 4
101843: PUSH
101844: LD_VAR 0 7
101848: ARRAY
101849: PPUSH
101850: LD_INT 71
101852: PPUSH
101853: CALL_OW 109
// continue ;
101857: GO 101772
// end ; end ;
101859: GO 101772
101861: POP
101862: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101863: LD_VAR 0 4
101867: PUSH
101868: LD_VAR 0 7
101872: ARRAY
101873: PPUSH
101874: CALL_OW 257
101878: PUSH
101879: LD_INT 8
101881: EQUAL
101882: PUSH
101883: LD_VAR 0 4
101887: PUSH
101888: LD_VAR 0 7
101892: ARRAY
101893: PPUSH
101894: CALL_OW 264
101898: PUSH
101899: LD_INT 28
101901: PUSH
101902: LD_INT 45
101904: PUSH
101905: LD_INT 7
101907: PUSH
101908: LD_INT 47
101910: PUSH
101911: EMPTY
101912: LIST
101913: LIST
101914: LIST
101915: LIST
101916: IN
101917: OR
101918: IFFALSE 102148
// begin attacking := false ;
101920: LD_ADDR_VAR 0 29
101924: PUSH
101925: LD_INT 0
101927: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101928: LD_VAR 0 14
101932: PUSH
101933: LD_INT 1
101935: ARRAY
101936: PPUSH
101937: CALL_OW 266
101941: PUSH
101942: LD_INT 32
101944: PUSH
101945: LD_INT 31
101947: PUSH
101948: LD_INT 33
101950: PUSH
101951: LD_INT 4
101953: PUSH
101954: LD_INT 5
101956: PUSH
101957: EMPTY
101958: LIST
101959: LIST
101960: LIST
101961: LIST
101962: LIST
101963: IN
101964: IFFALSE 102148
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101966: LD_ADDR_VAR 0 9
101970: PUSH
101971: LD_VAR 0 14
101975: PUSH
101976: LD_INT 1
101978: ARRAY
101979: PPUSH
101980: CALL_OW 266
101984: PPUSH
101985: LD_VAR 0 14
101989: PUSH
101990: LD_INT 1
101992: ARRAY
101993: PPUSH
101994: CALL_OW 250
101998: PPUSH
101999: LD_VAR 0 14
102003: PUSH
102004: LD_INT 1
102006: ARRAY
102007: PPUSH
102008: CALL_OW 251
102012: PPUSH
102013: LD_VAR 0 14
102017: PUSH
102018: LD_INT 1
102020: ARRAY
102021: PPUSH
102022: CALL_OW 254
102026: PPUSH
102027: LD_VAR 0 14
102031: PUSH
102032: LD_INT 1
102034: ARRAY
102035: PPUSH
102036: CALL_OW 248
102040: PPUSH
102041: LD_INT 0
102043: PPUSH
102044: CALL 78754 0 6
102048: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102049: LD_ADDR_VAR 0 8
102053: PUSH
102054: LD_VAR 0 4
102058: PUSH
102059: LD_VAR 0 7
102063: ARRAY
102064: PPUSH
102065: LD_VAR 0 9
102069: PPUSH
102070: CALL 97447 0 2
102074: ST_TO_ADDR
// if j then
102075: LD_VAR 0 8
102079: IFFALSE 102148
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102081: LD_VAR 0 8
102085: PUSH
102086: LD_INT 1
102088: ARRAY
102089: PPUSH
102090: LD_VAR 0 8
102094: PUSH
102095: LD_INT 2
102097: ARRAY
102098: PPUSH
102099: CALL_OW 488
102103: IFFALSE 102148
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102105: LD_VAR 0 4
102109: PUSH
102110: LD_VAR 0 7
102114: ARRAY
102115: PPUSH
102116: LD_VAR 0 8
102120: PUSH
102121: LD_INT 1
102123: ARRAY
102124: PPUSH
102125: LD_VAR 0 8
102129: PUSH
102130: LD_INT 2
102132: ARRAY
102133: PPUSH
102134: CALL_OW 116
// attacking := true ;
102138: LD_ADDR_VAR 0 29
102142: PUSH
102143: LD_INT 1
102145: ST_TO_ADDR
// continue ;
102146: GO 99521
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102148: LD_VAR 0 4
102152: PUSH
102153: LD_VAR 0 7
102157: ARRAY
102158: PPUSH
102159: CALL_OW 265
102163: PUSH
102164: LD_INT 11
102166: EQUAL
102167: IFFALSE 102445
// begin k := 10 ;
102169: LD_ADDR_VAR 0 9
102173: PUSH
102174: LD_INT 10
102176: ST_TO_ADDR
// x := 0 ;
102177: LD_ADDR_VAR 0 10
102181: PUSH
102182: LD_INT 0
102184: ST_TO_ADDR
// if tmp < k then
102185: LD_VAR 0 14
102189: PUSH
102190: LD_VAR 0 9
102194: LESS
102195: IFFALSE 102207
// k := tmp ;
102197: LD_ADDR_VAR 0 9
102201: PUSH
102202: LD_VAR 0 14
102206: ST_TO_ADDR
// for j = k downto 1 do
102207: LD_ADDR_VAR 0 8
102211: PUSH
102212: DOUBLE
102213: LD_VAR 0 9
102217: INC
102218: ST_TO_ADDR
102219: LD_INT 1
102221: PUSH
102222: FOR_DOWNTO
102223: IFFALSE 102298
// begin if GetType ( tmp [ j ] ) = unit_human then
102225: LD_VAR 0 14
102229: PUSH
102230: LD_VAR 0 8
102234: ARRAY
102235: PPUSH
102236: CALL_OW 247
102240: PUSH
102241: LD_INT 1
102243: EQUAL
102244: IFFALSE 102296
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102246: LD_VAR 0 4
102250: PUSH
102251: LD_VAR 0 7
102255: ARRAY
102256: PPUSH
102257: LD_VAR 0 14
102261: PUSH
102262: LD_VAR 0 8
102266: ARRAY
102267: PPUSH
102268: CALL 97718 0 2
// x := tmp [ j ] ;
102272: LD_ADDR_VAR 0 10
102276: PUSH
102277: LD_VAR 0 14
102281: PUSH
102282: LD_VAR 0 8
102286: ARRAY
102287: ST_TO_ADDR
// attacking := true ;
102288: LD_ADDR_VAR 0 29
102292: PUSH
102293: LD_INT 1
102295: ST_TO_ADDR
// end ; end ;
102296: GO 102222
102298: POP
102299: POP
// if not x then
102300: LD_VAR 0 10
102304: NOT
102305: IFFALSE 102445
// begin attacking := true ;
102307: LD_ADDR_VAR 0 29
102311: PUSH
102312: LD_INT 1
102314: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102315: LD_VAR 0 4
102319: PUSH
102320: LD_VAR 0 7
102324: ARRAY
102325: PPUSH
102326: CALL_OW 250
102330: PPUSH
102331: LD_VAR 0 4
102335: PUSH
102336: LD_VAR 0 7
102340: ARRAY
102341: PPUSH
102342: CALL_OW 251
102346: PPUSH
102347: CALL_OW 546
102351: PUSH
102352: LD_INT 2
102354: ARRAY
102355: PUSH
102356: LD_VAR 0 14
102360: PUSH
102361: LD_INT 1
102363: ARRAY
102364: PPUSH
102365: CALL_OW 250
102369: PPUSH
102370: LD_VAR 0 14
102374: PUSH
102375: LD_INT 1
102377: ARRAY
102378: PPUSH
102379: CALL_OW 251
102383: PPUSH
102384: CALL_OW 546
102388: PUSH
102389: LD_INT 2
102391: ARRAY
102392: EQUAL
102393: IFFALSE 102421
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
102395: LD_VAR 0 4
102399: PUSH
102400: LD_VAR 0 7
102404: ARRAY
102405: PPUSH
102406: LD_VAR 0 14
102410: PUSH
102411: LD_INT 1
102413: ARRAY
102414: PPUSH
102415: CALL 97718 0 2
102419: GO 102445
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102421: LD_VAR 0 4
102425: PUSH
102426: LD_VAR 0 7
102430: ARRAY
102431: PPUSH
102432: LD_VAR 0 14
102436: PUSH
102437: LD_INT 1
102439: ARRAY
102440: PPUSH
102441: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
102445: LD_VAR 0 4
102449: PUSH
102450: LD_VAR 0 7
102454: ARRAY
102455: PPUSH
102456: CALL_OW 264
102460: PUSH
102461: LD_INT 29
102463: EQUAL
102464: IFFALSE 102830
// begin if WantsToAttack ( group [ i ] ) in bombed then
102466: LD_VAR 0 4
102470: PUSH
102471: LD_VAR 0 7
102475: ARRAY
102476: PPUSH
102477: CALL_OW 319
102481: PUSH
102482: LD_VAR 0 28
102486: IN
102487: IFFALSE 102491
// continue ;
102489: GO 99521
// k := 8 ;
102491: LD_ADDR_VAR 0 9
102495: PUSH
102496: LD_INT 8
102498: ST_TO_ADDR
// x := 0 ;
102499: LD_ADDR_VAR 0 10
102503: PUSH
102504: LD_INT 0
102506: ST_TO_ADDR
// if tmp < k then
102507: LD_VAR 0 14
102511: PUSH
102512: LD_VAR 0 9
102516: LESS
102517: IFFALSE 102529
// k := tmp ;
102519: LD_ADDR_VAR 0 9
102523: PUSH
102524: LD_VAR 0 14
102528: ST_TO_ADDR
// for j = 1 to k do
102529: LD_ADDR_VAR 0 8
102533: PUSH
102534: DOUBLE
102535: LD_INT 1
102537: DEC
102538: ST_TO_ADDR
102539: LD_VAR 0 9
102543: PUSH
102544: FOR_TO
102545: IFFALSE 102677
// begin if GetType ( tmp [ j ] ) = unit_building then
102547: LD_VAR 0 14
102551: PUSH
102552: LD_VAR 0 8
102556: ARRAY
102557: PPUSH
102558: CALL_OW 247
102562: PUSH
102563: LD_INT 3
102565: EQUAL
102566: IFFALSE 102675
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102568: LD_VAR 0 14
102572: PUSH
102573: LD_VAR 0 8
102577: ARRAY
102578: PUSH
102579: LD_VAR 0 28
102583: IN
102584: NOT
102585: PUSH
102586: LD_VAR 0 14
102590: PUSH
102591: LD_VAR 0 8
102595: ARRAY
102596: PPUSH
102597: CALL_OW 313
102601: AND
102602: IFFALSE 102675
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102604: LD_VAR 0 4
102608: PUSH
102609: LD_VAR 0 7
102613: ARRAY
102614: PPUSH
102615: LD_VAR 0 14
102619: PUSH
102620: LD_VAR 0 8
102624: ARRAY
102625: PPUSH
102626: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102630: LD_ADDR_VAR 0 28
102634: PUSH
102635: LD_VAR 0 28
102639: PPUSH
102640: LD_VAR 0 28
102644: PUSH
102645: LD_INT 1
102647: PLUS
102648: PPUSH
102649: LD_VAR 0 14
102653: PUSH
102654: LD_VAR 0 8
102658: ARRAY
102659: PPUSH
102660: CALL_OW 1
102664: ST_TO_ADDR
// attacking := true ;
102665: LD_ADDR_VAR 0 29
102669: PUSH
102670: LD_INT 1
102672: ST_TO_ADDR
// break ;
102673: GO 102677
// end ; end ;
102675: GO 102544
102677: POP
102678: POP
// if not attacking and f_attack_depot then
102679: LD_VAR 0 29
102683: NOT
102684: PUSH
102685: LD_VAR 0 25
102689: AND
102690: IFFALSE 102785
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102692: LD_ADDR_VAR 0 13
102696: PUSH
102697: LD_VAR 0 14
102701: PPUSH
102702: LD_INT 2
102704: PUSH
102705: LD_INT 30
102707: PUSH
102708: LD_INT 0
102710: PUSH
102711: EMPTY
102712: LIST
102713: LIST
102714: PUSH
102715: LD_INT 30
102717: PUSH
102718: LD_INT 1
102720: PUSH
102721: EMPTY
102722: LIST
102723: LIST
102724: PUSH
102725: EMPTY
102726: LIST
102727: LIST
102728: LIST
102729: PPUSH
102730: CALL_OW 72
102734: ST_TO_ADDR
// if z then
102735: LD_VAR 0 13
102739: IFFALSE 102785
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102741: LD_VAR 0 4
102745: PUSH
102746: LD_VAR 0 7
102750: ARRAY
102751: PPUSH
102752: LD_VAR 0 13
102756: PPUSH
102757: LD_VAR 0 4
102761: PUSH
102762: LD_VAR 0 7
102766: ARRAY
102767: PPUSH
102768: CALL_OW 74
102772: PPUSH
102773: CALL_OW 115
// attacking := true ;
102777: LD_ADDR_VAR 0 29
102781: PUSH
102782: LD_INT 1
102784: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102785: LD_VAR 0 4
102789: PUSH
102790: LD_VAR 0 7
102794: ARRAY
102795: PPUSH
102796: CALL_OW 256
102800: PUSH
102801: LD_INT 500
102803: LESS
102804: IFFALSE 102830
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102806: LD_VAR 0 4
102810: PUSH
102811: LD_VAR 0 7
102815: ARRAY
102816: PPUSH
102817: LD_VAR 0 14
102821: PUSH
102822: LD_INT 1
102824: ARRAY
102825: PPUSH
102826: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102830: LD_VAR 0 4
102834: PUSH
102835: LD_VAR 0 7
102839: ARRAY
102840: PPUSH
102841: CALL_OW 264
102845: PUSH
102846: LD_INT 49
102848: EQUAL
102849: IFFALSE 102970
// begin if not HasTask ( group [ i ] ) then
102851: LD_VAR 0 4
102855: PUSH
102856: LD_VAR 0 7
102860: ARRAY
102861: PPUSH
102862: CALL_OW 314
102866: NOT
102867: IFFALSE 102970
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102869: LD_ADDR_VAR 0 9
102873: PUSH
102874: LD_INT 81
102876: PUSH
102877: LD_VAR 0 4
102881: PUSH
102882: LD_VAR 0 7
102886: ARRAY
102887: PPUSH
102888: CALL_OW 255
102892: PUSH
102893: EMPTY
102894: LIST
102895: LIST
102896: PPUSH
102897: CALL_OW 69
102901: PPUSH
102902: LD_VAR 0 4
102906: PUSH
102907: LD_VAR 0 7
102911: ARRAY
102912: PPUSH
102913: CALL_OW 74
102917: ST_TO_ADDR
// if k then
102918: LD_VAR 0 9
102922: IFFALSE 102970
// if GetDistUnits ( group [ i ] , k ) > 10 then
102924: LD_VAR 0 4
102928: PUSH
102929: LD_VAR 0 7
102933: ARRAY
102934: PPUSH
102935: LD_VAR 0 9
102939: PPUSH
102940: CALL_OW 296
102944: PUSH
102945: LD_INT 10
102947: GREATER
102948: IFFALSE 102970
// ComMoveUnit ( group [ i ] , k ) ;
102950: LD_VAR 0 4
102954: PUSH
102955: LD_VAR 0 7
102959: ARRAY
102960: PPUSH
102961: LD_VAR 0 9
102965: PPUSH
102966: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102970: LD_VAR 0 4
102974: PUSH
102975: LD_VAR 0 7
102979: ARRAY
102980: PPUSH
102981: CALL_OW 256
102985: PUSH
102986: LD_INT 250
102988: LESS
102989: PUSH
102990: LD_VAR 0 4
102994: PUSH
102995: LD_VAR 0 7
102999: ARRAY
103000: PUSH
103001: LD_INT 21
103003: PUSH
103004: LD_INT 2
103006: PUSH
103007: EMPTY
103008: LIST
103009: LIST
103010: PUSH
103011: LD_INT 23
103013: PUSH
103014: LD_INT 2
103016: PUSH
103017: EMPTY
103018: LIST
103019: LIST
103020: PUSH
103021: EMPTY
103022: LIST
103023: LIST
103024: PPUSH
103025: CALL_OW 69
103029: IN
103030: AND
103031: IFFALSE 103156
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103033: LD_ADDR_VAR 0 9
103037: PUSH
103038: LD_OWVAR 3
103042: PUSH
103043: LD_VAR 0 4
103047: PUSH
103048: LD_VAR 0 7
103052: ARRAY
103053: DIFF
103054: PPUSH
103055: LD_VAR 0 4
103059: PUSH
103060: LD_VAR 0 7
103064: ARRAY
103065: PPUSH
103066: CALL_OW 74
103070: ST_TO_ADDR
// if not k then
103071: LD_VAR 0 9
103075: NOT
103076: IFFALSE 103080
// continue ;
103078: GO 99521
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103080: LD_VAR 0 9
103084: PUSH
103085: LD_INT 81
103087: PUSH
103088: LD_VAR 0 4
103092: PUSH
103093: LD_VAR 0 7
103097: ARRAY
103098: PPUSH
103099: CALL_OW 255
103103: PUSH
103104: EMPTY
103105: LIST
103106: LIST
103107: PPUSH
103108: CALL_OW 69
103112: IN
103113: PUSH
103114: LD_VAR 0 9
103118: PPUSH
103119: LD_VAR 0 4
103123: PUSH
103124: LD_VAR 0 7
103128: ARRAY
103129: PPUSH
103130: CALL_OW 296
103134: PUSH
103135: LD_INT 5
103137: LESS
103138: AND
103139: IFFALSE 103156
// ComAutodestruct ( group [ i ] ) ;
103141: LD_VAR 0 4
103145: PUSH
103146: LD_VAR 0 7
103150: ARRAY
103151: PPUSH
103152: CALL 97616 0 1
// end ; if f_attack_depot then
103156: LD_VAR 0 25
103160: IFFALSE 103272
// begin k := 6 ;
103162: LD_ADDR_VAR 0 9
103166: PUSH
103167: LD_INT 6
103169: ST_TO_ADDR
// if tmp < k then
103170: LD_VAR 0 14
103174: PUSH
103175: LD_VAR 0 9
103179: LESS
103180: IFFALSE 103192
// k := tmp ;
103182: LD_ADDR_VAR 0 9
103186: PUSH
103187: LD_VAR 0 14
103191: ST_TO_ADDR
// for j = 1 to k do
103192: LD_ADDR_VAR 0 8
103196: PUSH
103197: DOUBLE
103198: LD_INT 1
103200: DEC
103201: ST_TO_ADDR
103202: LD_VAR 0 9
103206: PUSH
103207: FOR_TO
103208: IFFALSE 103270
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103210: LD_VAR 0 8
103214: PPUSH
103215: CALL_OW 266
103219: PUSH
103220: LD_INT 0
103222: PUSH
103223: LD_INT 1
103225: PUSH
103226: EMPTY
103227: LIST
103228: LIST
103229: IN
103230: IFFALSE 103268
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103232: LD_VAR 0 4
103236: PUSH
103237: LD_VAR 0 7
103241: ARRAY
103242: PPUSH
103243: LD_VAR 0 14
103247: PUSH
103248: LD_VAR 0 8
103252: ARRAY
103253: PPUSH
103254: CALL_OW 115
// attacking := true ;
103258: LD_ADDR_VAR 0 29
103262: PUSH
103263: LD_INT 1
103265: ST_TO_ADDR
// break ;
103266: GO 103270
// end ;
103268: GO 103207
103270: POP
103271: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103272: LD_VAR 0 4
103276: PUSH
103277: LD_VAR 0 7
103281: ARRAY
103282: PPUSH
103283: CALL_OW 302
103287: PUSH
103288: LD_VAR 0 29
103292: NOT
103293: AND
103294: IFFALSE 103616
// begin if GetTag ( group [ i ] ) = 71 then
103296: LD_VAR 0 4
103300: PUSH
103301: LD_VAR 0 7
103305: ARRAY
103306: PPUSH
103307: CALL_OW 110
103311: PUSH
103312: LD_INT 71
103314: EQUAL
103315: IFFALSE 103356
// begin if HasTask ( group [ i ] ) then
103317: LD_VAR 0 4
103321: PUSH
103322: LD_VAR 0 7
103326: ARRAY
103327: PPUSH
103328: CALL_OW 314
103332: IFFALSE 103338
// continue else
103334: GO 99521
103336: GO 103356
// SetTag ( group [ i ] , 0 ) ;
103338: LD_VAR 0 4
103342: PUSH
103343: LD_VAR 0 7
103347: ARRAY
103348: PPUSH
103349: LD_INT 0
103351: PPUSH
103352: CALL_OW 109
// end ; k := 8 ;
103356: LD_ADDR_VAR 0 9
103360: PUSH
103361: LD_INT 8
103363: ST_TO_ADDR
// x := 0 ;
103364: LD_ADDR_VAR 0 10
103368: PUSH
103369: LD_INT 0
103371: ST_TO_ADDR
// if tmp < k then
103372: LD_VAR 0 14
103376: PUSH
103377: LD_VAR 0 9
103381: LESS
103382: IFFALSE 103394
// k := tmp ;
103384: LD_ADDR_VAR 0 9
103388: PUSH
103389: LD_VAR 0 14
103393: ST_TO_ADDR
// for j = 1 to k do
103394: LD_ADDR_VAR 0 8
103398: PUSH
103399: DOUBLE
103400: LD_INT 1
103402: DEC
103403: ST_TO_ADDR
103404: LD_VAR 0 9
103408: PUSH
103409: FOR_TO
103410: IFFALSE 103508
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
103412: LD_VAR 0 14
103416: PUSH
103417: LD_VAR 0 8
103421: ARRAY
103422: PPUSH
103423: CALL_OW 247
103427: PUSH
103428: LD_INT 1
103430: EQUAL
103431: PUSH
103432: LD_VAR 0 14
103436: PUSH
103437: LD_VAR 0 8
103441: ARRAY
103442: PPUSH
103443: CALL_OW 256
103447: PUSH
103448: LD_INT 250
103450: LESS
103451: PUSH
103452: LD_VAR 0 20
103456: AND
103457: PUSH
103458: LD_VAR 0 20
103462: NOT
103463: PUSH
103464: LD_VAR 0 14
103468: PUSH
103469: LD_VAR 0 8
103473: ARRAY
103474: PPUSH
103475: CALL_OW 256
103479: PUSH
103480: LD_INT 250
103482: GREATEREQUAL
103483: AND
103484: OR
103485: AND
103486: IFFALSE 103506
// begin x := tmp [ j ] ;
103488: LD_ADDR_VAR 0 10
103492: PUSH
103493: LD_VAR 0 14
103497: PUSH
103498: LD_VAR 0 8
103502: ARRAY
103503: ST_TO_ADDR
// break ;
103504: GO 103508
// end ;
103506: GO 103409
103508: POP
103509: POP
// if x then
103510: LD_VAR 0 10
103514: IFFALSE 103538
// ComAttackUnit ( group [ i ] , x ) else
103516: LD_VAR 0 4
103520: PUSH
103521: LD_VAR 0 7
103525: ARRAY
103526: PPUSH
103527: LD_VAR 0 10
103531: PPUSH
103532: CALL_OW 115
103536: GO 103562
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103538: LD_VAR 0 4
103542: PUSH
103543: LD_VAR 0 7
103547: ARRAY
103548: PPUSH
103549: LD_VAR 0 14
103553: PUSH
103554: LD_INT 1
103556: ARRAY
103557: PPUSH
103558: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103562: LD_VAR 0 4
103566: PUSH
103567: LD_VAR 0 7
103571: ARRAY
103572: PPUSH
103573: CALL_OW 314
103577: NOT
103578: IFFALSE 103616
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103580: LD_VAR 0 4
103584: PUSH
103585: LD_VAR 0 7
103589: ARRAY
103590: PPUSH
103591: LD_VAR 0 14
103595: PPUSH
103596: LD_VAR 0 4
103600: PUSH
103601: LD_VAR 0 7
103605: ARRAY
103606: PPUSH
103607: CALL_OW 74
103611: PPUSH
103612: CALL_OW 115
// end ; end ; end ;
103616: GO 99521
103618: POP
103619: POP
// wait ( 0 0$1 ) ;
103620: LD_INT 35
103622: PPUSH
103623: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103627: LD_VAR 0 4
103631: PUSH
103632: EMPTY
103633: EQUAL
103634: PUSH
103635: LD_INT 81
103637: PUSH
103638: LD_VAR 0 35
103642: PUSH
103643: EMPTY
103644: LIST
103645: LIST
103646: PPUSH
103647: CALL_OW 69
103651: NOT
103652: OR
103653: IFFALSE 99506
// end ;
103655: LD_VAR 0 2
103659: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
103660: LD_INT 0
103662: PPUSH
103663: PPUSH
103664: PPUSH
103665: PPUSH
// if not base_units then
103666: LD_VAR 0 1
103670: NOT
103671: IFFALSE 103675
// exit ;
103673: GO 103762
// result := false ;
103675: LD_ADDR_VAR 0 2
103679: PUSH
103680: LD_INT 0
103682: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
103683: LD_ADDR_VAR 0 5
103687: PUSH
103688: LD_VAR 0 1
103692: PPUSH
103693: LD_INT 21
103695: PUSH
103696: LD_INT 3
103698: PUSH
103699: EMPTY
103700: LIST
103701: LIST
103702: PPUSH
103703: CALL_OW 72
103707: ST_TO_ADDR
// if not tmp then
103708: LD_VAR 0 5
103712: NOT
103713: IFFALSE 103717
// exit ;
103715: GO 103762
// for i in tmp do
103717: LD_ADDR_VAR 0 3
103721: PUSH
103722: LD_VAR 0 5
103726: PUSH
103727: FOR_IN
103728: IFFALSE 103760
// begin result := EnemyInRange ( i , 22 ) ;
103730: LD_ADDR_VAR 0 2
103734: PUSH
103735: LD_VAR 0 3
103739: PPUSH
103740: LD_INT 22
103742: PPUSH
103743: CALL 97299 0 2
103747: ST_TO_ADDR
// if result then
103748: LD_VAR 0 2
103752: IFFALSE 103758
// exit ;
103754: POP
103755: POP
103756: GO 103762
// end ;
103758: GO 103727
103760: POP
103761: POP
// end ;
103762: LD_VAR 0 2
103766: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
103767: LD_INT 0
103769: PPUSH
103770: PPUSH
// if not units then
103771: LD_VAR 0 1
103775: NOT
103776: IFFALSE 103780
// exit ;
103778: GO 103850
// result := [ ] ;
103780: LD_ADDR_VAR 0 3
103784: PUSH
103785: EMPTY
103786: ST_TO_ADDR
// for i in units do
103787: LD_ADDR_VAR 0 4
103791: PUSH
103792: LD_VAR 0 1
103796: PUSH
103797: FOR_IN
103798: IFFALSE 103848
// if GetTag ( i ) = tag then
103800: LD_VAR 0 4
103804: PPUSH
103805: CALL_OW 110
103809: PUSH
103810: LD_VAR 0 2
103814: EQUAL
103815: IFFALSE 103846
// result := Insert ( result , result + 1 , i ) ;
103817: LD_ADDR_VAR 0 3
103821: PUSH
103822: LD_VAR 0 3
103826: PPUSH
103827: LD_VAR 0 3
103831: PUSH
103832: LD_INT 1
103834: PLUS
103835: PPUSH
103836: LD_VAR 0 4
103840: PPUSH
103841: CALL_OW 2
103845: ST_TO_ADDR
103846: GO 103797
103848: POP
103849: POP
// end ;
103850: LD_VAR 0 3
103854: RET
// export function IsDriver ( un ) ; begin
103855: LD_INT 0
103857: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
103858: LD_ADDR_VAR 0 2
103862: PUSH
103863: LD_VAR 0 1
103867: PUSH
103868: LD_INT 55
103870: PUSH
103871: EMPTY
103872: LIST
103873: PPUSH
103874: CALL_OW 69
103878: IN
103879: ST_TO_ADDR
// end ;
103880: LD_VAR 0 2
103884: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103885: LD_INT 0
103887: PPUSH
103888: PPUSH
// list := [ ] ;
103889: LD_ADDR_VAR 0 5
103893: PUSH
103894: EMPTY
103895: ST_TO_ADDR
// case d of 0 :
103896: LD_VAR 0 3
103900: PUSH
103901: LD_INT 0
103903: DOUBLE
103904: EQUAL
103905: IFTRUE 103909
103907: GO 104042
103909: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103910: LD_ADDR_VAR 0 5
103914: PUSH
103915: LD_VAR 0 1
103919: PUSH
103920: LD_INT 4
103922: MINUS
103923: PUSH
103924: LD_VAR 0 2
103928: PUSH
103929: LD_INT 4
103931: MINUS
103932: PUSH
103933: LD_INT 2
103935: PUSH
103936: EMPTY
103937: LIST
103938: LIST
103939: LIST
103940: PUSH
103941: LD_VAR 0 1
103945: PUSH
103946: LD_INT 3
103948: MINUS
103949: PUSH
103950: LD_VAR 0 2
103954: PUSH
103955: LD_INT 1
103957: PUSH
103958: EMPTY
103959: LIST
103960: LIST
103961: LIST
103962: PUSH
103963: LD_VAR 0 1
103967: PUSH
103968: LD_INT 4
103970: PLUS
103971: PUSH
103972: LD_VAR 0 2
103976: PUSH
103977: LD_INT 4
103979: PUSH
103980: EMPTY
103981: LIST
103982: LIST
103983: LIST
103984: PUSH
103985: LD_VAR 0 1
103989: PUSH
103990: LD_INT 3
103992: PLUS
103993: PUSH
103994: LD_VAR 0 2
103998: PUSH
103999: LD_INT 3
104001: PLUS
104002: PUSH
104003: LD_INT 5
104005: PUSH
104006: EMPTY
104007: LIST
104008: LIST
104009: LIST
104010: PUSH
104011: LD_VAR 0 1
104015: PUSH
104016: LD_VAR 0 2
104020: PUSH
104021: LD_INT 4
104023: PLUS
104024: PUSH
104025: LD_INT 0
104027: PUSH
104028: EMPTY
104029: LIST
104030: LIST
104031: LIST
104032: PUSH
104033: EMPTY
104034: LIST
104035: LIST
104036: LIST
104037: LIST
104038: LIST
104039: ST_TO_ADDR
// end ; 1 :
104040: GO 104740
104042: LD_INT 1
104044: DOUBLE
104045: EQUAL
104046: IFTRUE 104050
104048: GO 104183
104050: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104051: LD_ADDR_VAR 0 5
104055: PUSH
104056: LD_VAR 0 1
104060: PUSH
104061: LD_VAR 0 2
104065: PUSH
104066: LD_INT 4
104068: MINUS
104069: PUSH
104070: LD_INT 3
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: LIST
104077: PUSH
104078: LD_VAR 0 1
104082: PUSH
104083: LD_INT 3
104085: MINUS
104086: PUSH
104087: LD_VAR 0 2
104091: PUSH
104092: LD_INT 3
104094: MINUS
104095: PUSH
104096: LD_INT 2
104098: PUSH
104099: EMPTY
104100: LIST
104101: LIST
104102: LIST
104103: PUSH
104104: LD_VAR 0 1
104108: PUSH
104109: LD_INT 4
104111: MINUS
104112: PUSH
104113: LD_VAR 0 2
104117: PUSH
104118: LD_INT 1
104120: PUSH
104121: EMPTY
104122: LIST
104123: LIST
104124: LIST
104125: PUSH
104126: LD_VAR 0 1
104130: PUSH
104131: LD_VAR 0 2
104135: PUSH
104136: LD_INT 3
104138: PLUS
104139: PUSH
104140: LD_INT 0
104142: PUSH
104143: EMPTY
104144: LIST
104145: LIST
104146: LIST
104147: PUSH
104148: LD_VAR 0 1
104152: PUSH
104153: LD_INT 4
104155: PLUS
104156: PUSH
104157: LD_VAR 0 2
104161: PUSH
104162: LD_INT 4
104164: PLUS
104165: PUSH
104166: LD_INT 5
104168: PUSH
104169: EMPTY
104170: LIST
104171: LIST
104172: LIST
104173: PUSH
104174: EMPTY
104175: LIST
104176: LIST
104177: LIST
104178: LIST
104179: LIST
104180: ST_TO_ADDR
// end ; 2 :
104181: GO 104740
104183: LD_INT 2
104185: DOUBLE
104186: EQUAL
104187: IFTRUE 104191
104189: GO 104320
104191: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104192: LD_ADDR_VAR 0 5
104196: PUSH
104197: LD_VAR 0 1
104201: PUSH
104202: LD_VAR 0 2
104206: PUSH
104207: LD_INT 3
104209: MINUS
104210: PUSH
104211: LD_INT 3
104213: PUSH
104214: EMPTY
104215: LIST
104216: LIST
104217: LIST
104218: PUSH
104219: LD_VAR 0 1
104223: PUSH
104224: LD_INT 4
104226: PLUS
104227: PUSH
104228: LD_VAR 0 2
104232: PUSH
104233: LD_INT 4
104235: PUSH
104236: EMPTY
104237: LIST
104238: LIST
104239: LIST
104240: PUSH
104241: LD_VAR 0 1
104245: PUSH
104246: LD_VAR 0 2
104250: PUSH
104251: LD_INT 4
104253: PLUS
104254: PUSH
104255: LD_INT 0
104257: PUSH
104258: EMPTY
104259: LIST
104260: LIST
104261: LIST
104262: PUSH
104263: LD_VAR 0 1
104267: PUSH
104268: LD_INT 3
104270: MINUS
104271: PUSH
104272: LD_VAR 0 2
104276: PUSH
104277: LD_INT 1
104279: PUSH
104280: EMPTY
104281: LIST
104282: LIST
104283: LIST
104284: PUSH
104285: LD_VAR 0 1
104289: PUSH
104290: LD_INT 4
104292: MINUS
104293: PUSH
104294: LD_VAR 0 2
104298: PUSH
104299: LD_INT 4
104301: MINUS
104302: PUSH
104303: LD_INT 2
104305: PUSH
104306: EMPTY
104307: LIST
104308: LIST
104309: LIST
104310: PUSH
104311: EMPTY
104312: LIST
104313: LIST
104314: LIST
104315: LIST
104316: LIST
104317: ST_TO_ADDR
// end ; 3 :
104318: GO 104740
104320: LD_INT 3
104322: DOUBLE
104323: EQUAL
104324: IFTRUE 104328
104326: GO 104461
104328: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
104329: LD_ADDR_VAR 0 5
104333: PUSH
104334: LD_VAR 0 1
104338: PUSH
104339: LD_INT 3
104341: PLUS
104342: PUSH
104343: LD_VAR 0 2
104347: PUSH
104348: LD_INT 4
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: LIST
104355: PUSH
104356: LD_VAR 0 1
104360: PUSH
104361: LD_INT 4
104363: PLUS
104364: PUSH
104365: LD_VAR 0 2
104369: PUSH
104370: LD_INT 4
104372: PLUS
104373: PUSH
104374: LD_INT 5
104376: PUSH
104377: EMPTY
104378: LIST
104379: LIST
104380: LIST
104381: PUSH
104382: LD_VAR 0 1
104386: PUSH
104387: LD_INT 4
104389: MINUS
104390: PUSH
104391: LD_VAR 0 2
104395: PUSH
104396: LD_INT 1
104398: PUSH
104399: EMPTY
104400: LIST
104401: LIST
104402: LIST
104403: PUSH
104404: LD_VAR 0 1
104408: PUSH
104409: LD_VAR 0 2
104413: PUSH
104414: LD_INT 4
104416: MINUS
104417: PUSH
104418: LD_INT 3
104420: PUSH
104421: EMPTY
104422: LIST
104423: LIST
104424: LIST
104425: PUSH
104426: LD_VAR 0 1
104430: PUSH
104431: LD_INT 3
104433: MINUS
104434: PUSH
104435: LD_VAR 0 2
104439: PUSH
104440: LD_INT 3
104442: MINUS
104443: PUSH
104444: LD_INT 2
104446: PUSH
104447: EMPTY
104448: LIST
104449: LIST
104450: LIST
104451: PUSH
104452: EMPTY
104453: LIST
104454: LIST
104455: LIST
104456: LIST
104457: LIST
104458: ST_TO_ADDR
// end ; 4 :
104459: GO 104740
104461: LD_INT 4
104463: DOUBLE
104464: EQUAL
104465: IFTRUE 104469
104467: GO 104602
104469: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
104470: LD_ADDR_VAR 0 5
104474: PUSH
104475: LD_VAR 0 1
104479: PUSH
104480: LD_VAR 0 2
104484: PUSH
104485: LD_INT 4
104487: PLUS
104488: PUSH
104489: LD_INT 0
104491: PUSH
104492: EMPTY
104493: LIST
104494: LIST
104495: LIST
104496: PUSH
104497: LD_VAR 0 1
104501: PUSH
104502: LD_INT 3
104504: PLUS
104505: PUSH
104506: LD_VAR 0 2
104510: PUSH
104511: LD_INT 3
104513: PLUS
104514: PUSH
104515: LD_INT 5
104517: PUSH
104518: EMPTY
104519: LIST
104520: LIST
104521: LIST
104522: PUSH
104523: LD_VAR 0 1
104527: PUSH
104528: LD_INT 4
104530: PLUS
104531: PUSH
104532: LD_VAR 0 2
104536: PUSH
104537: LD_INT 4
104539: PUSH
104540: EMPTY
104541: LIST
104542: LIST
104543: LIST
104544: PUSH
104545: LD_VAR 0 1
104549: PUSH
104550: LD_VAR 0 2
104554: PUSH
104555: LD_INT 3
104557: MINUS
104558: PUSH
104559: LD_INT 3
104561: PUSH
104562: EMPTY
104563: LIST
104564: LIST
104565: LIST
104566: PUSH
104567: LD_VAR 0 1
104571: PUSH
104572: LD_INT 4
104574: MINUS
104575: PUSH
104576: LD_VAR 0 2
104580: PUSH
104581: LD_INT 4
104583: MINUS
104584: PUSH
104585: LD_INT 2
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: LIST
104592: PUSH
104593: EMPTY
104594: LIST
104595: LIST
104596: LIST
104597: LIST
104598: LIST
104599: ST_TO_ADDR
// end ; 5 :
104600: GO 104740
104602: LD_INT 5
104604: DOUBLE
104605: EQUAL
104606: IFTRUE 104610
104608: GO 104739
104610: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
104611: LD_ADDR_VAR 0 5
104615: PUSH
104616: LD_VAR 0 1
104620: PUSH
104621: LD_INT 4
104623: MINUS
104624: PUSH
104625: LD_VAR 0 2
104629: PUSH
104630: LD_INT 1
104632: PUSH
104633: EMPTY
104634: LIST
104635: LIST
104636: LIST
104637: PUSH
104638: LD_VAR 0 1
104642: PUSH
104643: LD_VAR 0 2
104647: PUSH
104648: LD_INT 4
104650: MINUS
104651: PUSH
104652: LD_INT 3
104654: PUSH
104655: EMPTY
104656: LIST
104657: LIST
104658: LIST
104659: PUSH
104660: LD_VAR 0 1
104664: PUSH
104665: LD_INT 4
104667: PLUS
104668: PUSH
104669: LD_VAR 0 2
104673: PUSH
104674: LD_INT 4
104676: PLUS
104677: PUSH
104678: LD_INT 5
104680: PUSH
104681: EMPTY
104682: LIST
104683: LIST
104684: LIST
104685: PUSH
104686: LD_VAR 0 1
104690: PUSH
104691: LD_INT 3
104693: PLUS
104694: PUSH
104695: LD_VAR 0 2
104699: PUSH
104700: LD_INT 4
104702: PUSH
104703: EMPTY
104704: LIST
104705: LIST
104706: LIST
104707: PUSH
104708: LD_VAR 0 1
104712: PUSH
104713: LD_VAR 0 2
104717: PUSH
104718: LD_INT 3
104720: PLUS
104721: PUSH
104722: LD_INT 0
104724: PUSH
104725: EMPTY
104726: LIST
104727: LIST
104728: LIST
104729: PUSH
104730: EMPTY
104731: LIST
104732: LIST
104733: LIST
104734: LIST
104735: LIST
104736: ST_TO_ADDR
// end ; end ;
104737: GO 104740
104739: POP
// result := list ;
104740: LD_ADDR_VAR 0 4
104744: PUSH
104745: LD_VAR 0 5
104749: ST_TO_ADDR
// end ;
104750: LD_VAR 0 4
104754: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
104755: LD_INT 0
104757: PPUSH
104758: PPUSH
104759: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
104760: LD_VAR 0 1
104764: NOT
104765: PUSH
104766: LD_VAR 0 2
104770: PUSH
104771: LD_INT 1
104773: PUSH
104774: LD_INT 2
104776: PUSH
104777: LD_INT 3
104779: PUSH
104780: LD_INT 4
104782: PUSH
104783: EMPTY
104784: LIST
104785: LIST
104786: LIST
104787: LIST
104788: IN
104789: NOT
104790: OR
104791: IFFALSE 104795
// exit ;
104793: GO 104887
// tmp := [ ] ;
104795: LD_ADDR_VAR 0 5
104799: PUSH
104800: EMPTY
104801: ST_TO_ADDR
// for i in units do
104802: LD_ADDR_VAR 0 4
104806: PUSH
104807: LD_VAR 0 1
104811: PUSH
104812: FOR_IN
104813: IFFALSE 104856
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
104815: LD_ADDR_VAR 0 5
104819: PUSH
104820: LD_VAR 0 5
104824: PPUSH
104825: LD_VAR 0 5
104829: PUSH
104830: LD_INT 1
104832: PLUS
104833: PPUSH
104834: LD_VAR 0 4
104838: PPUSH
104839: LD_VAR 0 2
104843: PPUSH
104844: CALL_OW 259
104848: PPUSH
104849: CALL_OW 2
104853: ST_TO_ADDR
104854: GO 104812
104856: POP
104857: POP
// if not tmp then
104858: LD_VAR 0 5
104862: NOT
104863: IFFALSE 104867
// exit ;
104865: GO 104887
// result := SortListByListDesc ( units , tmp ) ;
104867: LD_ADDR_VAR 0 3
104871: PUSH
104872: LD_VAR 0 1
104876: PPUSH
104877: LD_VAR 0 5
104881: PPUSH
104882: CALL_OW 77
104886: ST_TO_ADDR
// end ;
104887: LD_VAR 0 3
104891: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104892: LD_INT 0
104894: PPUSH
104895: PPUSH
104896: PPUSH
// x := GetX ( building ) ;
104897: LD_ADDR_VAR 0 4
104901: PUSH
104902: LD_VAR 0 2
104906: PPUSH
104907: CALL_OW 250
104911: ST_TO_ADDR
// y := GetY ( building ) ;
104912: LD_ADDR_VAR 0 5
104916: PUSH
104917: LD_VAR 0 2
104921: PPUSH
104922: CALL_OW 251
104926: ST_TO_ADDR
// if GetTaskList ( unit ) then
104927: LD_VAR 0 1
104931: PPUSH
104932: CALL_OW 437
104936: IFFALSE 105031
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104938: LD_STRING e
104940: PUSH
104941: LD_VAR 0 1
104945: PPUSH
104946: CALL_OW 437
104950: PUSH
104951: LD_INT 1
104953: ARRAY
104954: PUSH
104955: LD_INT 1
104957: ARRAY
104958: EQUAL
104959: PUSH
104960: LD_VAR 0 4
104964: PUSH
104965: LD_VAR 0 1
104969: PPUSH
104970: CALL_OW 437
104974: PUSH
104975: LD_INT 1
104977: ARRAY
104978: PUSH
104979: LD_INT 2
104981: ARRAY
104982: EQUAL
104983: AND
104984: PUSH
104985: LD_VAR 0 5
104989: PUSH
104990: LD_VAR 0 1
104994: PPUSH
104995: CALL_OW 437
104999: PUSH
105000: LD_INT 1
105002: ARRAY
105003: PUSH
105004: LD_INT 3
105006: ARRAY
105007: EQUAL
105008: AND
105009: IFFALSE 105021
// result := true else
105011: LD_ADDR_VAR 0 3
105015: PUSH
105016: LD_INT 1
105018: ST_TO_ADDR
105019: GO 105029
// result := false ;
105021: LD_ADDR_VAR 0 3
105025: PUSH
105026: LD_INT 0
105028: ST_TO_ADDR
// end else
105029: GO 105039
// result := false ;
105031: LD_ADDR_VAR 0 3
105035: PUSH
105036: LD_INT 0
105038: ST_TO_ADDR
// end ;
105039: LD_VAR 0 3
105043: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105044: LD_INT 0
105046: PPUSH
105047: PPUSH
105048: PPUSH
105049: PPUSH
// if not unit or not area then
105050: LD_VAR 0 1
105054: NOT
105055: PUSH
105056: LD_VAR 0 2
105060: NOT
105061: OR
105062: IFFALSE 105066
// exit ;
105064: GO 105230
// tmp := AreaToList ( area , i ) ;
105066: LD_ADDR_VAR 0 6
105070: PUSH
105071: LD_VAR 0 2
105075: PPUSH
105076: LD_VAR 0 5
105080: PPUSH
105081: CALL_OW 517
105085: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105086: LD_ADDR_VAR 0 5
105090: PUSH
105091: DOUBLE
105092: LD_INT 1
105094: DEC
105095: ST_TO_ADDR
105096: LD_VAR 0 6
105100: PUSH
105101: LD_INT 1
105103: ARRAY
105104: PUSH
105105: FOR_TO
105106: IFFALSE 105228
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105108: LD_ADDR_VAR 0 7
105112: PUSH
105113: LD_VAR 0 6
105117: PUSH
105118: LD_INT 1
105120: ARRAY
105121: PUSH
105122: LD_VAR 0 5
105126: ARRAY
105127: PUSH
105128: LD_VAR 0 6
105132: PUSH
105133: LD_INT 2
105135: ARRAY
105136: PUSH
105137: LD_VAR 0 5
105141: ARRAY
105142: PUSH
105143: EMPTY
105144: LIST
105145: LIST
105146: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
105147: LD_VAR 0 7
105151: PUSH
105152: LD_INT 1
105154: ARRAY
105155: PPUSH
105156: LD_VAR 0 7
105160: PUSH
105161: LD_INT 2
105163: ARRAY
105164: PPUSH
105165: CALL_OW 428
105169: PUSH
105170: LD_INT 0
105172: EQUAL
105173: IFFALSE 105226
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
105175: LD_VAR 0 1
105179: PPUSH
105180: LD_VAR 0 7
105184: PUSH
105185: LD_INT 1
105187: ARRAY
105188: PPUSH
105189: LD_VAR 0 7
105193: PUSH
105194: LD_INT 2
105196: ARRAY
105197: PPUSH
105198: LD_VAR 0 3
105202: PPUSH
105203: CALL_OW 48
// result := IsPlaced ( unit ) ;
105207: LD_ADDR_VAR 0 4
105211: PUSH
105212: LD_VAR 0 1
105216: PPUSH
105217: CALL_OW 305
105221: ST_TO_ADDR
// exit ;
105222: POP
105223: POP
105224: GO 105230
// end ; end ;
105226: GO 105105
105228: POP
105229: POP
// end ;
105230: LD_VAR 0 4
105234: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105235: LD_INT 0
105237: PPUSH
105238: PPUSH
105239: PPUSH
// if not side or side > 8 then
105240: LD_VAR 0 1
105244: NOT
105245: PUSH
105246: LD_VAR 0 1
105250: PUSH
105251: LD_INT 8
105253: GREATER
105254: OR
105255: IFFALSE 105259
// exit ;
105257: GO 105446
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105259: LD_ADDR_VAR 0 4
105263: PUSH
105264: LD_INT 22
105266: PUSH
105267: LD_VAR 0 1
105271: PUSH
105272: EMPTY
105273: LIST
105274: LIST
105275: PUSH
105276: LD_INT 21
105278: PUSH
105279: LD_INT 3
105281: PUSH
105282: EMPTY
105283: LIST
105284: LIST
105285: PUSH
105286: EMPTY
105287: LIST
105288: LIST
105289: PPUSH
105290: CALL_OW 69
105294: ST_TO_ADDR
// if not tmp then
105295: LD_VAR 0 4
105299: NOT
105300: IFFALSE 105304
// exit ;
105302: GO 105446
// enable_addtolog := true ;
105304: LD_ADDR_OWVAR 81
105308: PUSH
105309: LD_INT 1
105311: ST_TO_ADDR
// AddToLog ( [ ) ;
105312: LD_STRING [
105314: PPUSH
105315: CALL_OW 561
// for i in tmp do
105319: LD_ADDR_VAR 0 3
105323: PUSH
105324: LD_VAR 0 4
105328: PUSH
105329: FOR_IN
105330: IFFALSE 105437
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
105332: LD_STRING [
105334: PUSH
105335: LD_VAR 0 3
105339: PPUSH
105340: CALL_OW 266
105344: STR
105345: PUSH
105346: LD_STRING , 
105348: STR
105349: PUSH
105350: LD_VAR 0 3
105354: PPUSH
105355: CALL_OW 250
105359: STR
105360: PUSH
105361: LD_STRING , 
105363: STR
105364: PUSH
105365: LD_VAR 0 3
105369: PPUSH
105370: CALL_OW 251
105374: STR
105375: PUSH
105376: LD_STRING , 
105378: STR
105379: PUSH
105380: LD_VAR 0 3
105384: PPUSH
105385: CALL_OW 254
105389: STR
105390: PUSH
105391: LD_STRING , 
105393: STR
105394: PUSH
105395: LD_VAR 0 3
105399: PPUSH
105400: LD_INT 1
105402: PPUSH
105403: CALL_OW 268
105407: STR
105408: PUSH
105409: LD_STRING , 
105411: STR
105412: PUSH
105413: LD_VAR 0 3
105417: PPUSH
105418: LD_INT 2
105420: PPUSH
105421: CALL_OW 268
105425: STR
105426: PUSH
105427: LD_STRING ],
105429: STR
105430: PPUSH
105431: CALL_OW 561
// end ;
105435: GO 105329
105437: POP
105438: POP
// AddToLog ( ]; ) ;
105439: LD_STRING ];
105441: PPUSH
105442: CALL_OW 561
// end ;
105446: LD_VAR 0 2
105450: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
105451: LD_INT 0
105453: PPUSH
105454: PPUSH
105455: PPUSH
105456: PPUSH
105457: PPUSH
// if not area or not rate or not max then
105458: LD_VAR 0 1
105462: NOT
105463: PUSH
105464: LD_VAR 0 2
105468: NOT
105469: OR
105470: PUSH
105471: LD_VAR 0 4
105475: NOT
105476: OR
105477: IFFALSE 105481
// exit ;
105479: GO 105673
// while 1 do
105481: LD_INT 1
105483: IFFALSE 105673
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
105485: LD_ADDR_VAR 0 9
105489: PUSH
105490: LD_VAR 0 1
105494: PPUSH
105495: LD_INT 1
105497: PPUSH
105498: CALL_OW 287
105502: PUSH
105503: LD_INT 10
105505: MUL
105506: ST_TO_ADDR
// r := rate / 10 ;
105507: LD_ADDR_VAR 0 7
105511: PUSH
105512: LD_VAR 0 2
105516: PUSH
105517: LD_INT 10
105519: DIVREAL
105520: ST_TO_ADDR
// time := 1 1$00 ;
105521: LD_ADDR_VAR 0 8
105525: PUSH
105526: LD_INT 2100
105528: ST_TO_ADDR
// if amount < min then
105529: LD_VAR 0 9
105533: PUSH
105534: LD_VAR 0 3
105538: LESS
105539: IFFALSE 105557
// r := r * 2 else
105541: LD_ADDR_VAR 0 7
105545: PUSH
105546: LD_VAR 0 7
105550: PUSH
105551: LD_INT 2
105553: MUL
105554: ST_TO_ADDR
105555: GO 105583
// if amount > max then
105557: LD_VAR 0 9
105561: PUSH
105562: LD_VAR 0 4
105566: GREATER
105567: IFFALSE 105583
// r := r / 2 ;
105569: LD_ADDR_VAR 0 7
105573: PUSH
105574: LD_VAR 0 7
105578: PUSH
105579: LD_INT 2
105581: DIVREAL
105582: ST_TO_ADDR
// time := time / r ;
105583: LD_ADDR_VAR 0 8
105587: PUSH
105588: LD_VAR 0 8
105592: PUSH
105593: LD_VAR 0 7
105597: DIVREAL
105598: ST_TO_ADDR
// if time < 0 then
105599: LD_VAR 0 8
105603: PUSH
105604: LD_INT 0
105606: LESS
105607: IFFALSE 105624
// time := time * - 1 ;
105609: LD_ADDR_VAR 0 8
105613: PUSH
105614: LD_VAR 0 8
105618: PUSH
105619: LD_INT 1
105621: NEG
105622: MUL
105623: ST_TO_ADDR
// wait ( time ) ;
105624: LD_VAR 0 8
105628: PPUSH
105629: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
105633: LD_INT 35
105635: PPUSH
105636: LD_INT 875
105638: PPUSH
105639: CALL_OW 12
105643: PPUSH
105644: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
105648: LD_INT 1
105650: PPUSH
105651: LD_INT 5
105653: PPUSH
105654: CALL_OW 12
105658: PPUSH
105659: LD_VAR 0 1
105663: PPUSH
105664: LD_INT 1
105666: PPUSH
105667: CALL_OW 55
// end ;
105671: GO 105481
// end ;
105673: LD_VAR 0 5
105677: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
105678: LD_INT 0
105680: PPUSH
105681: PPUSH
105682: PPUSH
105683: PPUSH
105684: PPUSH
105685: PPUSH
105686: PPUSH
105687: PPUSH
// if not turrets or not factories then
105688: LD_VAR 0 1
105692: NOT
105693: PUSH
105694: LD_VAR 0 2
105698: NOT
105699: OR
105700: IFFALSE 105704
// exit ;
105702: GO 106011
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
105704: LD_ADDR_VAR 0 10
105708: PUSH
105709: LD_INT 5
105711: PUSH
105712: LD_INT 6
105714: PUSH
105715: EMPTY
105716: LIST
105717: LIST
105718: PUSH
105719: LD_INT 2
105721: PUSH
105722: LD_INT 4
105724: PUSH
105725: EMPTY
105726: LIST
105727: LIST
105728: PUSH
105729: LD_INT 3
105731: PUSH
105732: LD_INT 5
105734: PUSH
105735: EMPTY
105736: LIST
105737: LIST
105738: PUSH
105739: EMPTY
105740: LIST
105741: LIST
105742: LIST
105743: PUSH
105744: LD_INT 24
105746: PUSH
105747: LD_INT 25
105749: PUSH
105750: EMPTY
105751: LIST
105752: LIST
105753: PUSH
105754: LD_INT 23
105756: PUSH
105757: LD_INT 27
105759: PUSH
105760: EMPTY
105761: LIST
105762: LIST
105763: PUSH
105764: EMPTY
105765: LIST
105766: LIST
105767: PUSH
105768: LD_INT 42
105770: PUSH
105771: LD_INT 43
105773: PUSH
105774: EMPTY
105775: LIST
105776: LIST
105777: PUSH
105778: LD_INT 44
105780: PUSH
105781: LD_INT 46
105783: PUSH
105784: EMPTY
105785: LIST
105786: LIST
105787: PUSH
105788: LD_INT 45
105790: PUSH
105791: LD_INT 47
105793: PUSH
105794: EMPTY
105795: LIST
105796: LIST
105797: PUSH
105798: EMPTY
105799: LIST
105800: LIST
105801: LIST
105802: PUSH
105803: EMPTY
105804: LIST
105805: LIST
105806: LIST
105807: ST_TO_ADDR
// result := [ ] ;
105808: LD_ADDR_VAR 0 3
105812: PUSH
105813: EMPTY
105814: ST_TO_ADDR
// for i in turrets do
105815: LD_ADDR_VAR 0 4
105819: PUSH
105820: LD_VAR 0 1
105824: PUSH
105825: FOR_IN
105826: IFFALSE 106009
// begin nat := GetNation ( i ) ;
105828: LD_ADDR_VAR 0 7
105832: PUSH
105833: LD_VAR 0 4
105837: PPUSH
105838: CALL_OW 248
105842: ST_TO_ADDR
// weapon := 0 ;
105843: LD_ADDR_VAR 0 8
105847: PUSH
105848: LD_INT 0
105850: ST_TO_ADDR
// if not nat then
105851: LD_VAR 0 7
105855: NOT
105856: IFFALSE 105860
// continue ;
105858: GO 105825
// for j in list [ nat ] do
105860: LD_ADDR_VAR 0 5
105864: PUSH
105865: LD_VAR 0 10
105869: PUSH
105870: LD_VAR 0 7
105874: ARRAY
105875: PUSH
105876: FOR_IN
105877: IFFALSE 105918
// if GetBWeapon ( i ) = j [ 1 ] then
105879: LD_VAR 0 4
105883: PPUSH
105884: CALL_OW 269
105888: PUSH
105889: LD_VAR 0 5
105893: PUSH
105894: LD_INT 1
105896: ARRAY
105897: EQUAL
105898: IFFALSE 105916
// begin weapon := j [ 2 ] ;
105900: LD_ADDR_VAR 0 8
105904: PUSH
105905: LD_VAR 0 5
105909: PUSH
105910: LD_INT 2
105912: ARRAY
105913: ST_TO_ADDR
// break ;
105914: GO 105918
// end ;
105916: GO 105876
105918: POP
105919: POP
// if not weapon then
105920: LD_VAR 0 8
105924: NOT
105925: IFFALSE 105929
// continue ;
105927: GO 105825
// for k in factories do
105929: LD_ADDR_VAR 0 6
105933: PUSH
105934: LD_VAR 0 2
105938: PUSH
105939: FOR_IN
105940: IFFALSE 106005
// begin weapons := AvailableWeaponList ( k ) ;
105942: LD_ADDR_VAR 0 9
105946: PUSH
105947: LD_VAR 0 6
105951: PPUSH
105952: CALL_OW 478
105956: ST_TO_ADDR
// if not weapons then
105957: LD_VAR 0 9
105961: NOT
105962: IFFALSE 105966
// continue ;
105964: GO 105939
// if weapon in weapons then
105966: LD_VAR 0 8
105970: PUSH
105971: LD_VAR 0 9
105975: IN
105976: IFFALSE 106003
// begin result := [ i , weapon ] ;
105978: LD_ADDR_VAR 0 3
105982: PUSH
105983: LD_VAR 0 4
105987: PUSH
105988: LD_VAR 0 8
105992: PUSH
105993: EMPTY
105994: LIST
105995: LIST
105996: ST_TO_ADDR
// exit ;
105997: POP
105998: POP
105999: POP
106000: POP
106001: GO 106011
// end ; end ;
106003: GO 105939
106005: POP
106006: POP
// end ;
106007: GO 105825
106009: POP
106010: POP
// end ;
106011: LD_VAR 0 3
106015: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106016: LD_INT 0
106018: PPUSH
// if not side or side > 8 then
106019: LD_VAR 0 3
106023: NOT
106024: PUSH
106025: LD_VAR 0 3
106029: PUSH
106030: LD_INT 8
106032: GREATER
106033: OR
106034: IFFALSE 106038
// exit ;
106036: GO 106097
// if not range then
106038: LD_VAR 0 4
106042: NOT
106043: IFFALSE 106054
// range := - 12 ;
106045: LD_ADDR_VAR 0 4
106049: PUSH
106050: LD_INT 12
106052: NEG
106053: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106054: LD_VAR 0 1
106058: PPUSH
106059: LD_VAR 0 2
106063: PPUSH
106064: LD_VAR 0 3
106068: PPUSH
106069: LD_VAR 0 4
106073: PPUSH
106074: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106078: LD_VAR 0 1
106082: PPUSH
106083: LD_VAR 0 2
106087: PPUSH
106088: LD_VAR 0 3
106092: PPUSH
106093: CALL_OW 331
// end ;
106097: LD_VAR 0 5
106101: RET
// export function Video ( mode ) ; begin
106102: LD_INT 0
106104: PPUSH
// ingame_video = mode ;
106105: LD_ADDR_OWVAR 52
106109: PUSH
106110: LD_VAR 0 1
106114: ST_TO_ADDR
// interface_hidden = mode ;
106115: LD_ADDR_OWVAR 54
106119: PUSH
106120: LD_VAR 0 1
106124: ST_TO_ADDR
// end ;
106125: LD_VAR 0 2
106129: RET
// export function Join ( array , element ) ; begin
106130: LD_INT 0
106132: PPUSH
// result := array ^ element ;
106133: LD_ADDR_VAR 0 3
106137: PUSH
106138: LD_VAR 0 1
106142: PUSH
106143: LD_VAR 0 2
106147: ADD
106148: ST_TO_ADDR
// end ;
106149: LD_VAR 0 3
106153: RET
// export function JoinUnion ( array , element ) ; begin
106154: LD_INT 0
106156: PPUSH
// result := array union element ;
106157: LD_ADDR_VAR 0 3
106161: PUSH
106162: LD_VAR 0 1
106166: PUSH
106167: LD_VAR 0 2
106171: UNION
106172: ST_TO_ADDR
// end ;
106173: LD_VAR 0 3
106177: RET
// export function GetBehemoths ( side ) ; begin
106178: LD_INT 0
106180: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
106181: LD_ADDR_VAR 0 2
106185: PUSH
106186: LD_INT 22
106188: PUSH
106189: LD_VAR 0 1
106193: PUSH
106194: EMPTY
106195: LIST
106196: LIST
106197: PUSH
106198: LD_INT 31
106200: PUSH
106201: LD_INT 25
106203: PUSH
106204: EMPTY
106205: LIST
106206: LIST
106207: PUSH
106208: EMPTY
106209: LIST
106210: LIST
106211: PPUSH
106212: CALL_OW 69
106216: ST_TO_ADDR
// end ;
106217: LD_VAR 0 2
106221: RET
// export function Shuffle ( array ) ; var i , index ; begin
106222: LD_INT 0
106224: PPUSH
106225: PPUSH
106226: PPUSH
// result := [ ] ;
106227: LD_ADDR_VAR 0 2
106231: PUSH
106232: EMPTY
106233: ST_TO_ADDR
// if not array then
106234: LD_VAR 0 1
106238: NOT
106239: IFFALSE 106243
// exit ;
106241: GO 106342
// Randomize ;
106243: CALL_OW 10
// for i = array downto 1 do
106247: LD_ADDR_VAR 0 3
106251: PUSH
106252: DOUBLE
106253: LD_VAR 0 1
106257: INC
106258: ST_TO_ADDR
106259: LD_INT 1
106261: PUSH
106262: FOR_DOWNTO
106263: IFFALSE 106340
// begin index := rand ( 1 , array ) ;
106265: LD_ADDR_VAR 0 4
106269: PUSH
106270: LD_INT 1
106272: PPUSH
106273: LD_VAR 0 1
106277: PPUSH
106278: CALL_OW 12
106282: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106283: LD_ADDR_VAR 0 2
106287: PUSH
106288: LD_VAR 0 2
106292: PPUSH
106293: LD_VAR 0 2
106297: PUSH
106298: LD_INT 1
106300: PLUS
106301: PPUSH
106302: LD_VAR 0 1
106306: PUSH
106307: LD_VAR 0 4
106311: ARRAY
106312: PPUSH
106313: CALL_OW 2
106317: ST_TO_ADDR
// array := Delete ( array , index ) ;
106318: LD_ADDR_VAR 0 1
106322: PUSH
106323: LD_VAR 0 1
106327: PPUSH
106328: LD_VAR 0 4
106332: PPUSH
106333: CALL_OW 3
106337: ST_TO_ADDR
// end ;
106338: GO 106262
106340: POP
106341: POP
// end ;
106342: LD_VAR 0 2
106346: RET
// export function GetBaseMaterials ( base ) ; begin
106347: LD_INT 0
106349: PPUSH
// result := [ 0 , 0 , 0 ] ;
106350: LD_ADDR_VAR 0 2
106354: PUSH
106355: LD_INT 0
106357: PUSH
106358: LD_INT 0
106360: PUSH
106361: LD_INT 0
106363: PUSH
106364: EMPTY
106365: LIST
106366: LIST
106367: LIST
106368: ST_TO_ADDR
// if not base then
106369: LD_VAR 0 1
106373: NOT
106374: IFFALSE 106378
// exit ;
106376: GO 106427
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
106378: LD_ADDR_VAR 0 2
106382: PUSH
106383: LD_VAR 0 1
106387: PPUSH
106388: LD_INT 1
106390: PPUSH
106391: CALL_OW 275
106395: PUSH
106396: LD_VAR 0 1
106400: PPUSH
106401: LD_INT 2
106403: PPUSH
106404: CALL_OW 275
106408: PUSH
106409: LD_VAR 0 1
106413: PPUSH
106414: LD_INT 3
106416: PPUSH
106417: CALL_OW 275
106421: PUSH
106422: EMPTY
106423: LIST
106424: LIST
106425: LIST
106426: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
106427: LD_VAR 0 2
106431: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
106432: LD_INT 0
106434: PPUSH
106435: PPUSH
106436: PPUSH
106437: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106438: LD_VAR 0 1
106442: PPUSH
106443: CALL_OW 264
106447: PUSH
106448: LD_EXP 96
106452: EQUAL
106453: IFFALSE 106525
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106455: LD_INT 68
106457: PPUSH
106458: LD_VAR 0 1
106462: PPUSH
106463: CALL_OW 255
106467: PPUSH
106468: CALL_OW 321
106472: PUSH
106473: LD_INT 2
106475: EQUAL
106476: IFFALSE 106488
// eff := 70 else
106478: LD_ADDR_VAR 0 6
106482: PUSH
106483: LD_INT 70
106485: ST_TO_ADDR
106486: GO 106496
// eff := 30 ;
106488: LD_ADDR_VAR 0 6
106492: PUSH
106493: LD_INT 30
106495: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106496: LD_VAR 0 1
106500: PPUSH
106501: CALL_OW 250
106505: PPUSH
106506: LD_VAR 0 1
106510: PPUSH
106511: CALL_OW 251
106515: PPUSH
106516: LD_VAR 0 6
106520: PPUSH
106521: CALL_OW 495
// end ; end ;
106525: LD_VAR 0 4
106529: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
106530: LD_INT 0
106532: PPUSH
106533: PPUSH
106534: PPUSH
106535: PPUSH
106536: PPUSH
106537: PPUSH
// if cmd = 124 then
106538: LD_VAR 0 1
106542: PUSH
106543: LD_INT 124
106545: EQUAL
106546: IFFALSE 106752
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
106548: LD_ADDR_VAR 0 5
106552: PUSH
106553: LD_INT 2
106555: PUSH
106556: LD_INT 34
106558: PUSH
106559: LD_INT 53
106561: PUSH
106562: EMPTY
106563: LIST
106564: LIST
106565: PUSH
106566: LD_INT 34
106568: PUSH
106569: LD_INT 14
106571: PUSH
106572: EMPTY
106573: LIST
106574: LIST
106575: PUSH
106576: EMPTY
106577: LIST
106578: LIST
106579: LIST
106580: PPUSH
106581: CALL_OW 69
106585: ST_TO_ADDR
// if not tmp then
106586: LD_VAR 0 5
106590: NOT
106591: IFFALSE 106595
// exit ;
106593: GO 106752
// for i in tmp do
106595: LD_ADDR_VAR 0 3
106599: PUSH
106600: LD_VAR 0 5
106604: PUSH
106605: FOR_IN
106606: IFFALSE 106750
// begin taskList := GetTaskList ( i ) ;
106608: LD_ADDR_VAR 0 6
106612: PUSH
106613: LD_VAR 0 3
106617: PPUSH
106618: CALL_OW 437
106622: ST_TO_ADDR
// if not taskList then
106623: LD_VAR 0 6
106627: NOT
106628: IFFALSE 106632
// continue ;
106630: GO 106605
// for j = 1 to taskList do
106632: LD_ADDR_VAR 0 4
106636: PUSH
106637: DOUBLE
106638: LD_INT 1
106640: DEC
106641: ST_TO_ADDR
106642: LD_VAR 0 6
106646: PUSH
106647: FOR_TO
106648: IFFALSE 106746
// if taskList [ j ] [ 1 ] = | then
106650: LD_VAR 0 6
106654: PUSH
106655: LD_VAR 0 4
106659: ARRAY
106660: PUSH
106661: LD_INT 1
106663: ARRAY
106664: PUSH
106665: LD_STRING |
106667: EQUAL
106668: IFFALSE 106744
// begin _taskList := Delete ( taskList , 1 ) ;
106670: LD_ADDR_VAR 0 7
106674: PUSH
106675: LD_VAR 0 6
106679: PPUSH
106680: LD_INT 1
106682: PPUSH
106683: CALL_OW 3
106687: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
106688: LD_VAR 0 3
106692: PPUSH
106693: LD_VAR 0 7
106697: PPUSH
106698: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
106702: LD_VAR 0 3
106706: PPUSH
106707: LD_VAR 0 6
106711: PUSH
106712: LD_VAR 0 4
106716: ARRAY
106717: PUSH
106718: LD_INT 2
106720: ARRAY
106721: PPUSH
106722: LD_VAR 0 6
106726: PUSH
106727: LD_VAR 0 4
106731: ARRAY
106732: PUSH
106733: LD_INT 3
106735: ARRAY
106736: PPUSH
106737: LD_INT 8
106739: PPUSH
106740: CALL 106757 0 4
// end ;
106744: GO 106647
106746: POP
106747: POP
// end ;
106748: GO 106605
106750: POP
106751: POP
// end ; end ;
106752: LD_VAR 0 2
106756: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106757: LD_INT 0
106759: PPUSH
106760: PPUSH
106761: PPUSH
106762: PPUSH
106763: PPUSH
106764: PPUSH
106765: PPUSH
106766: PPUSH
106767: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106768: LD_VAR 0 1
106772: NOT
106773: PUSH
106774: LD_VAR 0 2
106778: PPUSH
106779: LD_VAR 0 3
106783: PPUSH
106784: CALL_OW 488
106788: NOT
106789: OR
106790: PUSH
106791: LD_VAR 0 4
106795: NOT
106796: OR
106797: IFFALSE 106801
// exit ;
106799: GO 107141
// list := [ ] ;
106801: LD_ADDR_VAR 0 13
106805: PUSH
106806: EMPTY
106807: ST_TO_ADDR
// if x - r < 0 then
106808: LD_VAR 0 2
106812: PUSH
106813: LD_VAR 0 4
106817: MINUS
106818: PUSH
106819: LD_INT 0
106821: LESS
106822: IFFALSE 106834
// min_x := 0 else
106824: LD_ADDR_VAR 0 7
106828: PUSH
106829: LD_INT 0
106831: ST_TO_ADDR
106832: GO 106850
// min_x := x - r ;
106834: LD_ADDR_VAR 0 7
106838: PUSH
106839: LD_VAR 0 2
106843: PUSH
106844: LD_VAR 0 4
106848: MINUS
106849: ST_TO_ADDR
// if y - r < 0 then
106850: LD_VAR 0 3
106854: PUSH
106855: LD_VAR 0 4
106859: MINUS
106860: PUSH
106861: LD_INT 0
106863: LESS
106864: IFFALSE 106876
// min_y := 0 else
106866: LD_ADDR_VAR 0 8
106870: PUSH
106871: LD_INT 0
106873: ST_TO_ADDR
106874: GO 106892
// min_y := y - r ;
106876: LD_ADDR_VAR 0 8
106880: PUSH
106881: LD_VAR 0 3
106885: PUSH
106886: LD_VAR 0 4
106890: MINUS
106891: ST_TO_ADDR
// max_x := x + r ;
106892: LD_ADDR_VAR 0 9
106896: PUSH
106897: LD_VAR 0 2
106901: PUSH
106902: LD_VAR 0 4
106906: PLUS
106907: ST_TO_ADDR
// max_y := y + r ;
106908: LD_ADDR_VAR 0 10
106912: PUSH
106913: LD_VAR 0 3
106917: PUSH
106918: LD_VAR 0 4
106922: PLUS
106923: ST_TO_ADDR
// for _x = min_x to max_x do
106924: LD_ADDR_VAR 0 11
106928: PUSH
106929: DOUBLE
106930: LD_VAR 0 7
106934: DEC
106935: ST_TO_ADDR
106936: LD_VAR 0 9
106940: PUSH
106941: FOR_TO
106942: IFFALSE 107059
// for _y = min_y to max_y do
106944: LD_ADDR_VAR 0 12
106948: PUSH
106949: DOUBLE
106950: LD_VAR 0 8
106954: DEC
106955: ST_TO_ADDR
106956: LD_VAR 0 10
106960: PUSH
106961: FOR_TO
106962: IFFALSE 107055
// begin if not ValidHex ( _x , _y ) then
106964: LD_VAR 0 11
106968: PPUSH
106969: LD_VAR 0 12
106973: PPUSH
106974: CALL_OW 488
106978: NOT
106979: IFFALSE 106983
// continue ;
106981: GO 106961
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106983: LD_VAR 0 11
106987: PPUSH
106988: LD_VAR 0 12
106992: PPUSH
106993: CALL_OW 351
106997: PUSH
106998: LD_VAR 0 11
107002: PPUSH
107003: LD_VAR 0 12
107007: PPUSH
107008: CALL_OW 554
107012: AND
107013: IFFALSE 107053
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107015: LD_ADDR_VAR 0 13
107019: PUSH
107020: LD_VAR 0 13
107024: PPUSH
107025: LD_VAR 0 13
107029: PUSH
107030: LD_INT 1
107032: PLUS
107033: PPUSH
107034: LD_VAR 0 11
107038: PUSH
107039: LD_VAR 0 12
107043: PUSH
107044: EMPTY
107045: LIST
107046: LIST
107047: PPUSH
107048: CALL_OW 2
107052: ST_TO_ADDR
// end ;
107053: GO 106961
107055: POP
107056: POP
107057: GO 106941
107059: POP
107060: POP
// if not list then
107061: LD_VAR 0 13
107065: NOT
107066: IFFALSE 107070
// exit ;
107068: GO 107141
// for i in list do
107070: LD_ADDR_VAR 0 6
107074: PUSH
107075: LD_VAR 0 13
107079: PUSH
107080: FOR_IN
107081: IFFALSE 107139
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107083: LD_VAR 0 1
107087: PPUSH
107088: LD_STRING M
107090: PUSH
107091: LD_VAR 0 6
107095: PUSH
107096: LD_INT 1
107098: ARRAY
107099: PUSH
107100: LD_VAR 0 6
107104: PUSH
107105: LD_INT 2
107107: ARRAY
107108: PUSH
107109: LD_INT 0
107111: PUSH
107112: LD_INT 0
107114: PUSH
107115: LD_INT 0
107117: PUSH
107118: LD_INT 0
107120: PUSH
107121: EMPTY
107122: LIST
107123: LIST
107124: LIST
107125: LIST
107126: LIST
107127: LIST
107128: LIST
107129: PUSH
107130: EMPTY
107131: LIST
107132: PPUSH
107133: CALL_OW 447
107137: GO 107080
107139: POP
107140: POP
// end ;
107141: LD_VAR 0 5
107145: RET
